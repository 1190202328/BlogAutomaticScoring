[
  {
    "head": "软件构造实验心得（一）",
    "paragraphs": [
      "从软件构造这门课中，我学到了很多编程知识",
      "而这门课的四个实验，静下心来做，更是能令人获益匪浅",
      "下面分享出我的实验报告，供其他同学们参考"
    ],
    "sentences": [
      "从软件构造这门课中，我学到了很多编程知识",
      "而这门课的四个实验，静下心来做，更是能令人获益匪浅",
      "下面分享出我的实验报告，供其他同学们参考"
    ],
    "codes": [],
    "date": "2020-07-11",
    "text": "从软件构造这门课中，我学到了很多编程知识\n而这门课的四个实验，静下心来做，更是能令人获益匪浅\n下面分享出我的实验报告，供其他同学们参考\n"
  },
  {
    "head": "线段树&树状数组模板",
    "paragraphs": [
      "线段树模板",
      "板子敲错两遍就离谱......",
      "树状数组模板",
      "果然树状数组好敲很多哇QAQ"
    ],
    "sentences": [
      "线段树模板",
      "板子敲错两遍就离谱......树状数组模板",
      "果然树状数组好敲很多哇QAQ"
    ],
    "codes": [
      "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#define fr(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=100005;\nint n,q;\nll tree[4*maxn+1];\nll lz[4*maxn+1];\nvoid build(int node,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tscanf(\"%lld\",&tree[node]);\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(node*2,l,mid);\n\tbuild(node*2+1,mid+1,r);\n\ttree[node]=tree[node*2]+tree[node*2+1];\n}\nvoid update(int node,int l,int r,int index)\n{\n\tif(l==r)\n\t{\n\t\ttree[node]=index;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tif(index<=mid)\n\t\tupdate(node*2,l,mid,index);\n\telse \n\t\tupdate(node*2+1,mid+1,r,index);\n\ttree[node]=tree[node*2]+tree[node*2+1];\n}\nvoid push_down(int node,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tlz[node]=0;\n\t\treturn;\n\t}\n\tif(lz[node])\n\t{\n\t\tint mid=(l+r)>>1;\n\t\ttree[2*node]+=(mid-l+1)*lz[node];\n\t\ttree[2*node+1]+=(r-mid)*lz[node];\n\t\tlz[2*node]+=lz[node];\n\t\tlz[2*node+1]+=lz[node];\n\t\tlz[node]=0;\n\t}\n}\nvoid update_range(int node,int l,int r,int L,int R,int add)\n{\n\tif(l>=L&&R>=r)\n\t{\n\t\tlz[node]+=add;\n\t\ttree[node]+=(r-l+1)*add;\n\t\treturn;\n\t}\n\tpush_down(node,l,r);\n\tint mid=(l+r)>>1;\n\tif(mid>=L)\n\t\tupdate_range(node*2,l,mid,L,R,add);\n\tif(mid<R)\n\t\tupdate_range(node*2+1,mid+1,r,L,R,add);\n\ttree[node]=tree[node*2]+tree[node*2+1];\n}\nll query_range(int node,int l,int r,int L,int R)\n{\n\tif(l>=L&&R>=r) return tree[node];\n\tpush_down(node,l,r);\n\tint mid=(l+r)>>1;\n\tll sum=0;\n\tif(mid>=L)\n\t\tsum+=query_range(node*2,l,mid,L,R);\n\tif(mid<R)\n\t\tsum+=query_range(node*2+1,mid+1,r,L,R);\n\treturn sum;\n}\nint main()\n{ \n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tbuild(1,1,n);\n\tmemset(lz,0,sizeof(lz));\n\treturn 0;\n} ",
      "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=500005;\nint C[maxn];\nint lowbit(int x)\n{\n\treturn (-x)&x;\n} \nvoid insert(int i,int w)\n{\n\twhile(i<=n)\n\t{\n\t\tC[i]+=w;\n\t\ti+=lowbit(i);\n\t}\n}\nint query(int i)\n{\n\tint sum=0;\n\twhile(i>=1)\n\t{\n\t\tsum+=C[i];\n\t\ti-=lowbit(i);\n\t}\n\treturn sum;\n}\nint main()\n{\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\t\n\treturn 0;\n}\n\n"
    ],
    "date": "2020-08-05",
    "text": "线段树模板\n板子敲错两遍就离谱......\n树状数组模板\n果然树状数组好敲很多哇QAQ\n"
  },
  {
    "head": "字符串（马拉车+KMP+Tries树模板）",
    "paragraphs": [
      "马拉车",
      "异或Tries树",
      "KMP，Code froces 1137B Camp Schedule",
      "写的好乱好杂",
      "自己水平好低",
      "有时间来改改吧"
    ],
    "sentences": [
      "马拉车",
      "异或Tries树",
      "KMP",
      "Code froces 1137B Camp Schedule",
      "写的好乱好杂",
      "自己水平好低",
      "有时间来改改吧"
    ],
    "codes": [
      "void manacher()\n{\n\tint pos=0,r=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(i<r) p[i]=min(p[2*pos-i],r-i);\n\t\telse p[i]=1;\n\t\twhile(s2[i-p[i]]==s2[i+p[i]]) p[i]++;\n\t\tif(i+p[i]>r) r=i+p[i],pos=i;\n\t}\n}",
      "\nvoid init()\n{\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tint cnt=0;\n\ts2[0]='#';\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ts2[++cnt]=s[i];\n\t\ts2[++cnt]='#';\n\t}\n\tn=cnt;\n}",
      "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=3200005;\nint Tries[maxn][2];\nint cnt[maxn];\nint tot;\nint n,m;\nvoid init()\n{\n\tmemset(cnt,0,sizeof(cnt));\n\tmemset(Tries,0,sizeof(Tries));\n\ttot=0;\n}\nvoid insert(int x)\n{\n\tint now=0;\n\tfor(int i=31;i>=0;i--)\n\t{\n\t\tif(x&(1<<i))\n\t\t{\n\t\t\tif(Tries[now][1]==0)\n\t\t\t\tTries[now][1]=++tot;\n\t\t\tnow=Tries[now][1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Tries[now][0]==0)\n\t\t\t\tTries[now][0]=++tot;\n\t\t\tnow=Tries[now][0];\n\t\t}\n\t}\n}\nvoid solve(int x)\n{\n\tint now=0;\n\tint ans=0;\n\tfor(int i=31;i>=0;i--)\n\t{\n\t\tif(x&(1<<i))\n\t\t{\n\t\t//\tprintf(\"%d %d\\n\",i,x);\n\t\t\tif(Tries[now][0])\n\t\t\t{\n\t\t\t\tnow=Tries[now][0];\n\t\t\t}\n\t\t\telse\n\t\t\t\tnow=Tries[now][1],ans+=(1<<i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Tries[now][1])\n\t\t\t{\n\t\t\t\tans+=(1<<i);\n\t\t\t\tnow=Tries[now][1];\n\t\t\t}\n\t\t\telse\n\t\t\t\tnow=Tries[now][0];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\tint t;\n\tscanf(\"%d\",&t);\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tint x;\n\t\tinit();\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tinsert(x);\n\t\t}\n\t\tprintf(\"Case #%d:\\n\",i);\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tsolve(x);\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
      "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nchar s[500005];\nchar s2[500005];\nint nextt[500005];\nint n,n2;\nstring ans;\nvoid getc()\n{\n\tint i;\n\tint j=-1;\n\tnextt[0]=-1;\n\tfor(i=0;i<n2;)\n\t\tif(j==-1||s2[i]==s2[j]) nextt[++i]=++j;\n\t\telse j=nextt[j];\n}\nint main()\n{\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%s\",s);\n\tscanf(\"%s\",s2);\n\tint num1=0,num0=0;\n\tn=strlen(s);\n\tn2=strlen(s2);\n\tgetc();\n\tfor(int i=0;i<n;i++)\n\t\tif(s[i]=='1') num1++;\n\t\telse num0++;\n\tint cnt=0;\n\tif(n<n2)\n\t{\n\t\tcout<<s<<endl;\n\t\treturn 0;\n\t}\n\t\t\n\twhile(num1>0&&num0>0)\n\t{\n\t\tif(s2[cnt]=='0')\n\t\t{\n\t\t\tif(num0>0)\n\t\t\t{\n\t\t\t\tnum0--;\n\t\t\t\tans+='0';\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(num1>0)\n\t\t\t{\n\t\t\t\tnum1--;\n\t\t\t\tans+='1';\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif(cnt==n2)\n\t\t\tcnt=nextt[cnt];\n\t}\n\twhile(num0) num0--,ans+='0';\n\twhile(num1) num1--,ans+='1';\n\tcout<<ans<<endl;\n\treturn 0;\n}"
    ],
    "date": "2020-08-07",
    "text": "马拉车\n异或Tries树\nKMP，Code froces 1137B Camp Schedule\n写的好乱好杂\n自己水平好低\n有时间来改改吧\n"
  },
  {
    "head": "软件构造 Java Software(二）",
    "paragraphs": [
      "第二次实验与相关课程总结",
      "课程总结",
      "抽象数据类型",
      "可变数据类型",
      "不可变数据类型",
      "operations of an abstract type",
      "表示独立性",
      "测试抽象数据类型",
      "不变量",
      "Abstraction Function",
      "面向对象",
      "接口Interface",
      "重载与重写",
      "抽象类",
      "第二次实验总结",
      "关于测试优先",
      "关于Safety from rep exposure和Representation invariant",
      "关于文件读入",
      "课程总结",
      "抽象数据类型",
      "抽象数据类型与表示独立性：如何设计良好的抽象数据结构，通过封装来避免客户端获取数据的内部表示（即“表示泄露”），避免潜在的bug——在client和implementer之间建立“防火墙”",
      "可变数据类型",
      "可变类型的对象：提供了可改变其内部数据的值的操作，例如List",
      "不可变数据类型",
      "不变数据类型： 其操作不改变内部值，而是构造新的对象 ，例如int,String",
      "operations of an abstract type",
      "构造器：可能实现为构造函数或静态函数",
      "变值器：改变对象属性的方法，通常返回为void",
      "观察器：观察对象属性，如The size() method of List",
      "生产器：从旧的对象中创建一个新的对象，如concat() method of String",
      "表示独立性",
      "client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。",
      "测试抽象数据类型",
      "测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；",
      "测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。",
      "不变量",
      "immutability是典型的不变量。immutable的抽象数据类型不能有变值器。对于一些属性不变量，采用private final进行修饰，同时采用防御式编程来保证其不变性。",
      "Abstraction Function",
      "由表示空间映射到抽象空间称为AF。",
      "ADT开发者关注表示空间R，client关注抽象空间A，",
      "它是满射但未必单射，也未必双射。",
      "面向对象",
      "接口Interface",
      "Interface和Class: 定义和实现ADT",
      "接口之间可以继承与扩展",
      "一个类可以实现多个接口",
      "一个接口可以有多种实现类",
      "接口中只确定ADT规约而不具体实现方法，实际当中更倾向于使用接口来定义变量。",
      "使用接口来完成信息隐藏，客户端仅使用接口中定义方法，客户端无法直接访问属性。",
      "重载与重写",
      "关于重写/覆盖：若超类中加了final修饰则无法重载，重写的函数的具体使用是在运行时决定，重写的函数参数与原函数相同。",
      "关于重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型，方便client调用，client可用不同的参数列表，调用同样的函数，重载函数是在编译时进行的静态类型检查。",
      "抽象类",
      "介于接口与类之间，如果某些操作是所有子类型都共有，但彼此有差别，可以在父类型中设计抽象方法，在各子类型中重写",
      "泛型是一种类型变量，泛型类，泛型接口，泛型方法，其定义中包含了类型变量",
      "第二次实验总结",
      "关于测试优先",
      "设计测试样例时避免重复造轮子，看似写了很多行测试样例，但却没有实际发现错误，同时对于equals和==这部分测试要多留心。",
      "关于Safety from rep exposure和Representation invariant",
      "对于表示的独立性采用checkRep来进行检查，checkRep使用assert语句",
      "assert vertices2.equals(vertices);",
      "对于表示泄露的预防，所有属性都采用private final 修饰，并且都采用",
      "Collections.unmodifiableSet",
      "或者new 一个新值来进行防御式拷贝。",
      "关于文件读入",
      "在第一次实验中采用了一种文件读入方法，这里采用另一种文件读入",
      "打开文件输入流，用scanner按行读入，然后采用分隔符或正则语言进行匹配",
      "没学习那些概念之前，做实验稍显吃力，学习了之后发现不过按图索骥，实现起来又较为简单"
    ],
    "sentences": [
      "第二次实验与相关课程总结",
      "课程总结",
      "抽象数据类型",
      "可变数据类型",
      "不可变数据类型",
      "operations of an abstract type",
      "表示独立性",
      "测试抽象数据类型",
      "不变量",
      "Abstraction Function",
      "面向对象",
      "接口Interface",
      "重载与重写",
      "抽象类",
      "第二次实验总结",
      "关于测试优先",
      "关于Safety from rep exposure和Representation invariant",
      "关于文件读入",
      "课程总结",
      "抽象数据类型",
      "抽象数据类型与表示独立性：如何设计良好的抽象数据结构",
      "通过封装来避免客户端获取数据的内部表示（即“表示泄露”）",
      "避免潜在的bug——在client和implementer之间建立“防火墙”",
      "可变数据类型",
      "可变类型的对象：提供了可改变其内部数据的值的操作",
      "例如List",
      "不可变数据类型",
      "不变数据类型： 其操作不改变内部值",
      "而是构造新的对象 ",
      "例如int,String",
      "operations of an abstract type",
      "构造器：可能实现为构造函数或静态函数",
      "变值器：改变对象属性的方法，通常返回为void",
      "观察器：观察对象属性",
      "如The size() method of List",
      "生产器：从旧的对象中创建一个新的对象",
      "如concat() method of String",
      "表示独立性",
      "client使用ADT时无需考虑其内部如何实现",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "测试抽象数据类型",
      "测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；测试observers：调用creators, producers, and mutators等方法产生或改变对象",
      "来看结果是否正确",
      "不变量",
      "immutability是典型的不变量",
      "immutable的抽象数据类型不能有变值器",
      "对于一些属性不变量",
      "采用private final进行修饰",
      "同时采用防御式编程来保证其不变性",
      "Abstraction Function",
      "由表示空间映射到抽象空间称为AF",
      "ADT开发者关注表示空间R",
      "client关注抽象空间A",
      "它是满射但未必单射",
      "也未必双射",
      "面向对象",
      "接口Interface",
      "Interface和Class: 定义和实现ADT",
      "接口之间可以继承与扩展",
      "一个类可以实现多个接口",
      "一个接口可以有多种实现类",
      "接口中只确定ADT规约而不具体实现方法",
      "实际当中更倾向于使用接口来定义变量",
      "使用接口来完成信息隐藏",
      "客户端仅使用接口中定义方法",
      "客户端无法直接访问属性",
      "重载与重写",
      "关于重写/覆盖：若超类中加了final修饰则无法重载",
      "重写的函数的具体使用是在运行时决定",
      "重写的函数参数与原函数相同",
      "关于重载：多个方法具有同样的名字",
      "但有不同的参数列表或返回值类型",
      "方便client调用",
      "client可用不同的参数列表",
      "调用同样的函数",
      "重载函数是在编译时进行的静态类型检查",
      "抽象类",
      "介于接口与类之间",
      "如果某些操作是所有子类型都共有",
      "但彼此有差别",
      "可以在父类型中设计抽象方法",
      "在各子类型中重写",
      "泛型是一种类型变量",
      "泛型类",
      "泛型接口",
      "泛型方法",
      "其定义中包含了类型变量",
      "第二次实验总结",
      "关于测试优先",
      "设计测试样例时避免重复造轮子",
      "看似写了很多行测试样例",
      "但却没有实际发现错误",
      "同时对于equals和==这部分测试要多留心",
      "关于Safety from rep exposure和Representation invariant",
      "对于表示的独立性采用checkRep来进行检查",
      "checkRep使用assert语句",
      "assert vertices2.equals(vertices);对于表示泄露的预防",
      "所有属性都采用private final 修饰",
      "并且都采用",
      "Collections.unmodifiableSet",
      "或者new 一个新值来进行防御式拷贝",
      "关于文件读入",
      "在第一次实验中采用了一种文件读入方法，这里采用另一种文件读入",
      "打开文件输入流",
      "用scanner按行读入",
      "然后采用分隔符或正则语言进行匹配",
      "没学习那些概念之前",
      "做实验稍显吃力",
      "学习了之后发现不过按图索骥",
      "实现起来又较为简单"
    ],
    "codes": [
      "InputStream is = new FileInputStream(corpus);\nScanner scan = new Scanner(is);\nwhile(scan.hasNext()) {\n    \t\tList<String>inputString = Arrays.asList(scan.nextLine().split(\" \"));\n    \t\tIterator<String>it = inputString.iterator();\n    \t\tString lastString = new String();\n    \t\tString nowString = new String();\n    \t\twhile(it.hasNext()) {\n    \t\t\tlastString = nowString;\n    \t\t\tnowString = it.next();\n    \t\t\tnowString = nowString.toLowerCase();\n    \t\t\tgraph.add(nowString);\n    \t\t\tint nowWeight;\n    \t\t\tif(lastString.isEmpty() == false) {\n    \t\t\t\tnowWeight = graph.set(lastString, nowString, 0);\n    \t\t\t\tgraph.set(lastString, nowString, nowWeight + 1);\n    \t\t\t\tMap<String, Integer>targets = graph.targets(lastString);\n    \t\t\t}\n    \t\t}\n    \t}\n"
    ],
    "date": "2021-06-29",
    "text": "第二次实验与相关课程总结\n课程总结\n抽象数据类型\n可变数据类型\n不可变数据类型\noperations of an abstract type\n表示独立性\n测试抽象数据类型\n不变量\nAbstraction Function\n面向对象\n接口Interface\n重载与重写\n抽象类\n第二次实验总结\n关于测试优先\n关于Safety from rep exposure和Representation invariant\n关于文件读入\n课程总结\n抽象数据类型\n抽象数据类型与表示独立性：如何设计良好的抽象数据结构，通过封装来避免客户端获取数据的内部表示（即“表示泄露”），避免潜在的bug——在client和implementer之间建立“防火墙”\n可变数据类型\n可变类型的对象：提供了可改变其内部数据的值的操作，例如List\n不可变数据类型\n不变数据类型： 其操作不改变内部值，而是构造新的对象 ，例如int,String\noperations of an abstract type\n构造器：可能实现为构造函数或静态函数\n变值器：改变对象属性的方法，通常返回为void\n观察器：观察对象属性，如The size() method of List\n生产器：从旧的对象中创建一个新的对象，如concat() method of String\n表示独立性\nclient使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。\n测试抽象数据类型\n测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；\n测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。\n不变量\nimmutability是典型的不变量。immutable的抽象数据类型不能有变值器。对于一些属性不变量，采用private final进行修饰，同时采用防御式编程来保证其不变性。\nAbstraction Function\n由表示空间映射到抽象空间称为AF。\nADT开发者关注表示空间R，client关注抽象空间A，\n它是满射但未必单射，也未必双射。\n面向对象\n接口Interface\nInterface和Class: 定义和实现ADT\n接口之间可以继承与扩展\n一个类可以实现多个接口\n一个接口可以有多种实现类\n接口中只确定ADT规约而不具体实现方法，实际当中更倾向于使用接口来定义变量。\n使用接口来完成信息隐藏，客户端仅使用接口中定义方法，客户端无法直接访问属性。\n重载与重写\n关于重写/覆盖：若超类中加了final修饰则无法重载，重写的函数的具体使用是在运行时决定，重写的函数参数与原函数相同。\n关于重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型，方便client调用，client可用不同的参数列表，调用同样的函数，重载函数是在编译时进行的静态类型检查。\n抽象类\n介于接口与类之间，如果某些操作是所有子类型都共有，但彼此有差别，可以在父类型中设计抽象方法，在各子类型中重写\n泛型是一种类型变量，泛型类，泛型接口，泛型方法，其定义中包含了类型变量\n第二次实验总结\n关于测试优先\n设计测试样例时避免重复造轮子，看似写了很多行测试样例，但却没有实际发现错误，同时对于equals和==这部分测试要多留心。\n关于Safety from rep exposure和Representation invariant\n对于表示的独立性采用checkRep来进行检查，checkRep使用assert语句\nassert vertices2.equals(vertices);\n对于表示泄露的预防，所有属性都采用private final 修饰，并且都采用\nCollections.unmodifiableSet\n或者new 一个新值来进行防御式拷贝。\n关于文件读入\n在第一次实验中采用了一种文件读入方法，这里采用另一种文件读入\n打开文件输入流，用scanner按行读入，然后采用分隔符或正则语言进行匹配\n没学习那些概念之前，做实验稍显吃力，学习了之后发现不过按图索骥，实现起来又较为简单\n"
  },
  {
    "head": "Java 软件构造Software construction (三)",
    "paragraphs": [
      "第三次实验部分及相关课程学习",
      "相关课程",
      "可复用性",
      "四个层次上的可复用性",
      "LSP原则Liskov Substitution Principle",
      "委派delegation",
      "可维护性",
      "5个设计原则SOLID",
      "SRP",
      "OCP",
      "ISP",
      "DIP",
      "面向可维护性和可复用性的设计模式",
      "创建型模式",
      "Structural patterns",
      "Behavioral patterns",
      "第三次实验",
      "关于github",
      "相关课程",
      "可复用性",
      "四个层次上的可复用性",
      "代码层次，模块层次：类/接口，库层次：API/包，系统层次：框架",
      "LSP原则Liskov Substitution Principle",
      "子类型多态：客户端可用统一的方式处理不同类型的对象",
      "Same or stronger invariants 更强的不变量",
      "Same or weaker preconditions 更弱的前置条件",
      "Same or stronger postconditions更强的后置条件",
      "所以子类型方法参数为逆变，子类型返回值为协变，异常类型为协变",
      "协变即为越来越具体，逆变即为越来越抽象",
      "委派delegation",
      "委派：一个对象请求另一个对象的功能",
      "委派模式：通过运行时动态绑定，实现对其他类中代码的动态复用",
      "当子类只需要复用父类的一部分方法时，就可以不需要使用继承，而用委派机制来实现，同时一个类不需要继承另一个类的全部方法，就通过委派机制调用部分方法。",
      "委派的三种类型是，Use，Association，Composition/aggregation",
      "可维护性",
      "5个设计原则SOLID",
      "SRP:单一责任原则 OCP:开放-封闭原则 LSP:Liskov替换原则 DIP：依赖转置原则 ISP：接口聚合原则",
      "SRP",
      "不应该有多于1个原因让你的ADT发生变化，否则就拆分开",
      "OCP",
      "模块的行为可扩展，模块的代码不应该修改，解决方案：抽象技术",
      "ISP",
      "不能强迫客户端依赖于他们不需要接口，只提供必要接口",
      "DIP",
      "抽象的模块不应依赖于具体的模块",
      "面向可维护性和可复用性的设计模式",
      "创建型模式",
      "工厂方法模式：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。",
      "Structural patterns",
      "适配器模式：通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。",
      "装饰器模式：当特性需要组合时，对每一个特性构造子类，通过委派机制增加到对象上，就像穿一层又一层的衣服",
      "Behavioral patterns",
      "策略模式：有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里",
      "模板模式：做事情的步骤一样，但具体方法不同，共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。",
      "迭代器模式：客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型",
      "visitor模式：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT。",
      "第三次实验",
      "关于github",
      "github在一开始的时候抽风了QAQ，所以一直没有创建仓库，等github好了的时候再创建仓库pull的时候发现",
      "查询后发现出现这个问题是因为本地仓库和远程仓库变成独立两个仓库了（一开始没有clone仓库）",
      "pull命令后紧接着使用–allow-unrelated-history选项来解决问题。"
    ],
    "sentences": [
      "第三次实验部分及相关课程学习",
      "相关课程",
      "可复用性",
      "四个层次上的可复用性",
      "LSP原则Liskov Substitution Principle",
      "委派delegation",
      "可维护性",
      "5个设计原则SOLID",
      "SRP",
      "OCP",
      "ISP",
      "DIP",
      "面向可维护性和可复用性的设计模式",
      "创建型模式",
      "Structural patterns",
      "Behavioral patterns",
      "第三次实验",
      "关于github",
      "相关课程",
      "可复用性",
      "四个层次上的可复用性",
      "代码层次",
      "模块层次：类/接口",
      "库层次：API/包",
      "系统层次：框架",
      "LSP原则Liskov Substitution Principle",
      "子类型多态：客户端可用统一的方式处理不同类型的对象",
      "Same or stronger invariants 更强的不变量",
      "Same or weaker preconditions 更弱的前置条件",
      "Same or stronger postconditions更强的后置条件",
      "所以子类型方法参数为逆变，子类型返回值为协变，异常类型为协变",
      "协变即为越来越具体，逆变即为越来越抽象",
      "委派delegation",
      "委派：一个对象请求另一个对象的功能",
      "委派模式：通过运行时动态绑定，实现对其他类中代码的动态复用",
      "当子类只需要复用父类的一部分方法时",
      "就可以不需要使用继承",
      "而用委派机制来实现",
      "同时一个类不需要继承另一个类的全部方法",
      "就通过委派机制调用部分方法",
      "委派的三种类型是",
      "Use",
      "Association",
      "Composition/aggregation",
      "可维护性",
      "5个设计原则SOLID",
      "SRP:单一责任原则 OCP:开放-封闭原则 LSP:Liskov替换原则 DIP：依赖转置原则 ISP：接口聚合原则",
      "SRP",
      "不应该有多于1个原因让你的ADT发生变化，否则就拆分开",
      "OCP",
      "模块的行为可扩展，模块的代码不应该修改，解决方案：抽象技术",
      "ISP",
      "不能强迫客户端依赖于他们不需要接口，只提供必要接口",
      "DIP",
      "抽象的模块不应依赖于具体的模块",
      "面向可维护性和可复用性的设计模式",
      "创建型模式",
      "工厂方法模式：当client不知道要创建哪个具体类的实例",
      "或者不想在client代码中指明要具体创建的实例时",
      "用工厂方法",
      "定义一个用于创建对象的接口",
      "让其子类来决定实例化哪一个类",
      "从而使一个类的实例化延迟到其子类",
      "Structural patterns",
      "适配器模式：通过增加一个接口",
      "将已存在的子类封装起来",
      "client面向接口编程",
      "从而隐藏了具体子类",
      "装饰器模式：当特性需要组合时",
      "对每一个特性构造子类",
      "通过委派机制增加到对象上",
      "就像穿一层又一层的衣服",
      "Behavioral patterns",
      "策略模式：有多种不同的算法来实现同一个任务",
      "但需要client根据需要动态切换算法",
      "而不是写死在代码里",
      "模板模式：做事情的步骤一样",
      "但具体方法不同",
      "共性的步骤在抽象类内公共实现",
      "差异化的步骤在各个子类中实现",
      "使用继承和重写实现模板模式",
      "迭代器模式：客户端希望遍历被放入容器/集合类的一组ADT对象",
      "无需关心容器的具体类型",
      "visitor模式：对特定类型的object的特定操作(visit)",
      "在运行时将二者动态绑定到一起",
      "该操作可以灵活更改",
      "无需更改被visit的类",
      "为ADT预留一个将来可扩展功能的“接入点”",
      "外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT",
      "第三次实验",
      "关于github",
      "github在一开始的时候抽风了QAQ",
      "所以一直没有创建仓库",
      "等github好了的时候再创建仓库pull的时候发现",
      "查询后发现出现这个问题是因为本地仓库和远程仓库变成独立两个仓库了（一开始没有clone仓库）",
      "pull命令后紧接着使用–allow-unrelated-history选项来解决问题"
    ],
    "codes": [],
    "date": "2021-06-30",
    "text": "第三次实验部分及相关课程学习\n相关课程\n可复用性\n四个层次上的可复用性\nLSP原则Liskov Substitution Principle\n委派delegation\n可维护性\n5个设计原则SOLID\nSRP\nOCP\nISP\nDIP\n面向可维护性和可复用性的设计模式\n创建型模式\nStructural patterns\nBehavioral patterns\n第三次实验\n关于github\n相关课程\n可复用性\n四个层次上的可复用性\n代码层次，模块层次：类/接口，库层次：API/包，系统层次：框架\nLSP原则Liskov Substitution Principle\n子类型多态：客户端可用统一的方式处理不同类型的对象\nSame or stronger invariants 更强的不变量\nSame or weaker preconditions 更弱的前置条件\nSame or stronger postconditions更强的后置条件\n所以子类型方法参数为逆变，子类型返回值为协变，异常类型为协变\n协变即为越来越具体，逆变即为越来越抽象\n委派delegation\n委派：一个对象请求另一个对象的功能\n委派模式：通过运行时动态绑定，实现对其他类中代码的动态复用\n当子类只需要复用父类的一部分方法时，就可以不需要使用继承，而用委派机制来实现，同时一个类不需要继承另一个类的全部方法，就通过委派机制调用部分方法。\n委派的三种类型是，Use，Association，Composition/aggregation\n可维护性\n5个设计原则SOLID\nSRP:单一责任原则 OCP:开放-封闭原则 LSP:Liskov替换原则 DIP：依赖转置原则 ISP：接口聚合原则\nSRP\n不应该有多于1个原因让你的ADT发生变化，否则就拆分开\nOCP\n模块的行为可扩展，模块的代码不应该修改，解决方案：抽象技术\nISP\n不能强迫客户端依赖于他们不需要接口，只提供必要接口\nDIP\n抽象的模块不应依赖于具体的模块\n面向可维护性和可复用性的设计模式\n创建型模式\n工厂方法模式：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。\nStructural patterns\n适配器模式：通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。\n装饰器模式：当特性需要组合时，对每一个特性构造子类，通过委派机制增加到对象上，就像穿一层又一层的衣服\nBehavioral patterns\n策略模式：有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里\n模板模式：做事情的步骤一样，但具体方法不同，共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。\n迭代器模式：客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型\nvisitor模式：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT。\n第三次实验\n关于github\ngithub在一开始的时候抽风了QAQ，所以一直没有创建仓库，等github好了的时候再创建仓库pull的时候发现\n查询后发现出现这个问题是因为本地仓库和远程仓库变成独立两个仓库了（一开始没有clone仓库）\npull命令后紧接着使用–allow-unrelated-history选项来解决问题。\n"
  },
  {
    "head": "Java 软件构造Software construction（六）",
    "paragraphs": [
      "复习与思考",
      "软件构造的多维度视图和质量目标",
      "多维度视图",
      "具体某些重要视图",
      "质量目标",
      "外部质量因素",
      "内部质量因素",
      "五大质量目标",
      "软件构造的多维度视图和质量目标",
      "该部分是该怎样以全面的眼光/模型/视图来看待软件系统的，搞清楚构造对象是什么，如何刻画，并学会构造过程中应考虑的质量指标，理解清楚如何构造对象才算好。",
      "多维度视图",
      "按阶段划分：构造时/运行时视图",
      "按动态性划分:时刻/阶段视图",
      "按构造对象层次划分：代码/构件视图",
      "关于多维度视图的整体表现如下图所示",
      "对于这副图的理解，个人认为首先掌握好代码与构件视图的区别，构件永远是高于代码层面的变化，如包，文件，配置，版本，日志，进程等等。然后掌握运行与构造时视图的区别，构造时都是关于文件本身不涉及执行时的变化，运行时则是关于栈，变量，内存信息等的一些执行时变化，至于时刻和阶段视图的区分则是一个时间点和一个时间段的区别，如一个时间点的source code是具体怎样的和一个时间段的code churn代码变化是怎么样的。",
      "具体某些重要视图",
      "(1)Build-time, moment, and code-level view：",
      "词汇层面:source code",
      "语法层面:AST(半结构化的语言彻底结构化成一棵树)",
      "语义层面：Class Diagram(图形化形式化的实现具体目标的结构)",
      "(2) Build-time, period, and code-level view",
      "Code churn 代码变化",
      "(3) Build-time, moment, and component-level view",
      "文件，包，库等等，注意静态链接在构造时，动态链接在运行时",
      "(4) Build-time, period, and component-level view",
      "SCI配置项和版本（基线和版本）",
      "(5) Run-time, moment, and code-level view",
      "Code Snapshot:描述程序运行时内存里变量层面的状态",
      "(6) Run-time, period and code-level view",
      "Execution tracing 执行跟踪",
      "质量目标",
      "分为外部质量因素与内部质量因素，外部质量因素影响用户，内部质量因素影响软件和它本身开发者，外部质量取决于内部质量。",
      "外部质量因素",
      "正确性：最重要的质量指标",
      "健壮性：针对异常情况的处理，这里对异常情况的定义为未被specification覆盖的情况即为“异常情况”！",
      "可扩展性： 对软件的规约进行修改，是否足够容易",
      "可复用性：一次开发，多次使用，不要重复造轮子！！",
      "兼容性：不同的软件系统之间相互可容易的集成",
      "性能： 性能毫无意义，除非有足够的正确性，过早的优化是万恶之源！！改变算法思想！",
      "可移植性：软件可方便的在不同的技术环境之间移植",
      "易用性：字面意思",
      "Functionality：每增加一小点功能，都确保其他质量属性不受到损失",
      "Timeliness：在用户想要其前则发布",
      "内部质量因素",
      "Size",
      "五大质量目标"
    ],
    "sentences": [
      "复习与思考",
      "软件构造的多维度视图和质量目标",
      "多维度视图",
      "具体某些重要视图",
      "质量目标",
      "外部质量因素",
      "内部质量因素",
      "五大质量目标",
      "软件构造的多维度视图和质量目标",
      "该部分是该怎样以全面的眼光/模型/视图来看待软件系统的",
      "搞清楚构造对象是什么",
      "如何刻画",
      "并学会构造过程中应考虑的质量指标",
      "理解清楚如何构造对象才算好",
      "多维度视图",
      "按阶段划分：构造时/运行时视图",
      "按动态性划分:时刻/阶段视图",
      "按构造对象层次划分：代码/构件视图",
      "关于多维度视图的整体表现如下图所示",
      "对于这副图的理解",
      "个人认为首先掌握好代码与构件视图的区别",
      "构件永远是高于代码层面的变化",
      "如包",
      "文件",
      "配置",
      "版本",
      "日志",
      "进程等等",
      "然后掌握运行与构造时视图的区别",
      "构造时都是关于文件本身不涉及执行时的变化",
      "运行时则是关于栈",
      "变量",
      "内存信息等的一些执行时变化",
      "至于时刻和阶段视图的区分则是一个时间点和一个时间段的区别",
      "如一个时间点的source code是具体怎样的和一个时间段的code churn代码变化是怎么样的",
      "具体某些重要视图",
      "(1)Build-time, moment, and code-level view：词汇层面:source code",
      "语法层面:AST(半结构化的语言彻底结构化成一棵树)",
      "语义层面：Class Diagram(图形化形式化的实现具体目标的结构)",
      "(2) Build-time, period, and code-level view",
      "Code churn 代码变化",
      "(3) Build-time, moment, and component-level view",
      "文件，包，库等等，注意静态链接在构造时，动态链接在运行时",
      "(4) Build-time, period, and component-level view",
      "SCI配置项和版本（基线和版本）",
      "(5) Run-time, moment, and code-level view",
      "Code Snapshot:描述程序运行时内存里变量层面的状态",
      "(6) Run-time, period and code-level view",
      "Execution tracing 执行跟踪",
      "质量目标",
      "分为外部质量因素与内部质量因素",
      "外部质量因素影响用户",
      "内部质量因素影响软件和它本身开发者",
      "外部质量取决于内部质量",
      "外部质量因素",
      "正确性：最重要的质量指标",
      "健壮性：针对异常情况的处理",
      "这里对异常情况的定义为未被specification覆盖的情况即为“异常情况”！",
      "可扩展性： 对软件的规约进行修改，是否足够容易",
      "可复用性：一次开发，多次使用，不要重复造轮子！！",
      "兼容性：不同的软件系统之间相互可容易的集成",
      "性能： 性能毫无意义",
      "除非有足够的正确性",
      "过早的优化是万恶之源！！改变算法思想！",
      "可移植性：软件可方便的在不同的技术环境之间移植",
      "易用性：字面意思",
      "Functionality：每增加一小点功能",
      "都确保其他质量属性不受到损失",
      "Timeliness：在用户想要其前则发布",
      "内部质量因素",
      "Size",
      "五大质量目标"
    ],
    "codes": [
      "Readability",
      "Understandability",
      "Clearness"
    ],
    "date": "2021-07-05",
    "text": "复习与思考\n软件构造的多维度视图和质量目标\n多维度视图\n具体某些重要视图\n质量目标\n外部质量因素\n内部质量因素\n五大质量目标\n软件构造的多维度视图和质量目标\n该部分是该怎样以全面的眼光/模型/视图来看待软件系统的，搞清楚构造对象是什么，如何刻画，并学会构造过程中应考虑的质量指标，理解清楚如何构造对象才算好。\n多维度视图\n按阶段划分：构造时/运行时视图\n按动态性划分:时刻/阶段视图\n按构造对象层次划分：代码/构件视图\n关于多维度视图的整体表现如下图所示\n对于这副图的理解，个人认为首先掌握好代码与构件视图的区别，构件永远是高于代码层面的变化，如包，文件，配置，版本，日志，进程等等。然后掌握运行与构造时视图的区别，构造时都是关于文件本身不涉及执行时的变化，运行时则是关于栈，变量，内存信息等的一些执行时变化，至于时刻和阶段视图的区分则是一个时间点和一个时间段的区别，如一个时间点的source code是具体怎样的和一个时间段的code churn代码变化是怎么样的。\n具体某些重要视图\n(1)Build-time, moment, and code-level view：\n词汇层面:source code\n语法层面:AST(半结构化的语言彻底结构化成一棵树)\n语义层面：Class Diagram(图形化形式化的实现具体目标的结构)\n(2) Build-time, period, and code-level view\nCode churn 代码变化\n(3) Build-time, moment, and component-level view\n文件，包，库等等，注意静态链接在构造时，动态链接在运行时\n(4) Build-time, period, and component-level view\nSCI配置项和版本（基线和版本）\n(5) Run-time, moment, and code-level view\nCode Snapshot:描述程序运行时内存里变量层面的状态\n(6) Run-time, period and code-level view\nExecution tracing 执行跟踪\n质量目标\n分为外部质量因素与内部质量因素，外部质量因素影响用户，内部质量因素影响软件和它本身开发者，外部质量取决于内部质量。\n外部质量因素\n正确性：最重要的质量指标\n健壮性：针对异常情况的处理，这里对异常情况的定义为未被specification覆盖的情况即为“异常情况”！\n可扩展性： 对软件的规约进行修改，是否足够容易\n可复用性：一次开发，多次使用，不要重复造轮子！！\n兼容性：不同的软件系统之间相互可容易的集成\n性能： 性能毫无意义，除非有足够的正确性，过早的优化是万恶之源！！改变算法思想！\n可移植性：软件可方便的在不同的技术环境之间移植\n易用性：字面意思\nFunctionality：每增加一小点功能，都确保其他质量属性不受到损失\nTimeliness：在用户想要其前则发布\n内部质量因素\nSize\n五大质量目标\n"
  },
  {
    "head": "poj 1220 number base conversion高精度进制转换java",
    "paragraphs": [
      "c++和java 两种来写，感觉java写着要顺一些，虽然代码存在很多java的错误习惯，还是贴一下，所以一定要好好学java啊orz",
      "c++呢就是从从第i次开始，(i=1,2,3....)每一次都从首位开始枚举字符串，不断地求商取对应进制的模，求出来对应进制第i位上的数，直至结束。"
    ],
    "sentences": [
      "c++和java 两种来写",
      "感觉java写着要顺一些",
      "虽然代码存在很多java的错误习惯",
      "还是贴一下",
      "所以一定要好好学java啊orz",
      "c++呢就是从从第i次开始",
      "(i=1,2,3....)每一次都从首位开始枚举字符串",
      "不断地求商取对应进制的模",
      "求出来对应进制第i位上的数",
      "直至结束"
    ],
    "codes": [
      "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Scanner;\nimport java.util.*;\nimport java.text.*;\nimport java.io.*;\n\n \n\n \npublic class Main{\n \n        public static int getint(char ch)\n        {\n            if(Character.isDigit(ch)) return (ch-'0');\n            else if(Character.isUpperCase(ch)) return (ch-'A'+10);\n            else return (ch-'a'+36);    \n        }\n\n        public static char getchar(int i)\n        {\n            if(i>=0&&i<=9) return (char)(i+'0');\n            else if(i>=10&&i<=35) return (char)(i-10+'A');\n            else return (char)(i-36+'a');\n        }\n        public static void main(String[] args) {\n        Scanner cin = new Scanner(new BufferedInputStream(System.in));\n        int t=cin.nextInt();\n        while(t--!=0)\n        {\n        \n            String s;\n            String ans=new String();\n            int base1,base2;\n            base1=cin.nextInt();\n            base2=cin.nextInt();\n             s=cin.next();\n            BigInteger result=BigInteger.valueOf(0);\n            for(int i=0;i<s.length();i++)\n            {\n\n                            result=result.multiply(result.valueOf(base1)).add(result.valueOf(getint(s.charAt(i))));\n            }\n            while(!result.equals(BigInteger.ZERO))\n            {\n                ans=getchar(result.mod(result.valueOf(base2)).intValue())+ans;\n                result=result.divide(result.valueOf(base2));\n            }\n            if(ans.length()==0) ans+='0';\n            System.out.println(base1+\" \"+s+'\\n'+base2+' '+ans);\n            System.out.println();\n             \n \n         }\n    }\n \n}"
    ],
    "date": "2020-08-02",
    "text": "c++和java 两种来写，感觉java写着要顺一些，虽然代码存在很多java的错误习惯，还是贴一下，所以一定要好好学java啊orz\nc++呢就是从从第i次开始，(i=1,2,3....)每一次都从首位开始枚举字符串，不断地求商取对应进制的模，求出来对应进制第i位上的数，直至结束。\n"
  },
  {
    "head": "Java 软件构造（七）",
    "paragraphs": [
      "杂项总结",
      "抽象类",
      "适配器",
      "内聚和耦合",
      "表示泄露",
      "default方法",
      "LSP和JAVA",
      "set与mutable",
      "黑盒与白盒",
      "最后的最后",
      "抽象类",
      "在多种设计模式中，均有采用继承抽象类来复用代码，同时进行委派实现个性化的操作",
      "适配器",
      "设计模式中最不擅长的一种模式，这是一种结构型模式，是直接进行委派不适配是，增加接口在适配器子类中进行转换适配和隐藏之前委派的一种模式。",
      "内聚和耦合",
      "高内聚低耦合是软件工程的重要概念，描述的功能应该是单一、简单、易理解且模块化的。",
      "表示泄露",
      "不仅影响不变性，也影响表示独立性，检查时从public - private 、 外部参数赋值给可变属性，返回值为可变属性等几个方面来进行检查。",
      "default方法",
      "通过其在接口中统一实现某些功能。无需在各个类中重复实现它，增量式增加而不破坏原来的类。",
      "LSP和JAVA",
      "子类型方法参数的逆变，在实际运行中算为overloadQAQ。同时Arrays也是协变的。Generics不是协变的。",
      "set与mutable",
      "mutable对象在set集合类中发生改变后，集合类行为不确定。",
      "黑盒与白盒",
      "白盒着眼于代码，黑盒着眼于模块，如白盒测试和黑盒测试，一个需要检查代码，一个只关注最后行为，白盒复用源代码可见，黑盒复用源代码不可见，白盒框架代码层面的继承，黑盒框架是实现特定接口/delegation进行框架扩展。",
      "最后的最后",
      "明天就是期末考试了，越复习越觉得之前写的代码还有很多很多可以修改的地方，想着时间再多一点，再尽善尽美一些。日升不滞哇，总会有遗憾，但遗憾是完善的过程，所以不能停止思考，更不能停止书写代码，不断前行，朝着理想的彼岸，绝对的理念进发。"
    ],
    "sentences": [
      "杂项总结",
      "抽象类",
      "适配器",
      "内聚和耦合",
      "表示泄露",
      "default方法",
      "LSP和JAVA",
      "set与mutable",
      "黑盒与白盒",
      "最后的最后",
      "抽象类",
      "在多种设计模式中",
      "均有采用继承抽象类来复用代码",
      "同时进行委派实现个性化的操作",
      "适配器",
      "设计模式中最不擅长的一种模式",
      "这是一种结构型模式",
      "是直接进行委派不适配是",
      "增加接口在适配器子类中进行转换适配和隐藏之前委派的一种模式",
      "内聚和耦合",
      "高内聚低耦合是软件工程的重要概念",
      "描述的功能应该是单一、简单、易理解且模块化的",
      "表示泄露",
      "不仅影响不变性",
      "也影响表示独立性",
      "检查时从public - private 、 外部参数赋值给可变属性",
      "返回值为可变属性等几个方面来进行检查",
      "default方法",
      "通过其在接口中统一实现某些功能",
      "无需在各个类中重复实现它，增量式增加而不破坏原来的类",
      "LSP和JAVA",
      "子类型方法参数的逆变，在实际运行中算为overloadQAQ",
      "同时Arrays也是协变的",
      "Generics不是协变的",
      "set与mutable",
      "mutable对象在set集合类中发生改变后",
      "集合类行为不确定",
      "黑盒与白盒",
      "白盒着眼于代码",
      "黑盒着眼于模块",
      "如白盒测试和黑盒测试",
      "一个需要检查代码",
      "一个只关注最后行为",
      "白盒复用源代码可见",
      "黑盒复用源代码不可见",
      "白盒框架代码层面的继承",
      "黑盒框架是实现特定接口/delegation进行框架扩展",
      "最后的最后",
      "明天就是期末考试了",
      "越复习越觉得之前写的代码还有很多很多可以修改的地方",
      "想着时间再多一点",
      "再尽善尽美一些",
      "日升不滞哇",
      "总会有遗憾",
      "但遗憾是完善的过程",
      "所以不能停止思考",
      "更不能停止书写代码",
      "不断前行",
      "朝着理想的彼岸",
      "绝对的理念进发"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "杂项总结\n抽象类\n适配器\n内聚和耦合\n表示泄露\ndefault方法\nLSP和JAVA\nset与mutable\n黑盒与白盒\n最后的最后\n抽象类\n在多种设计模式中，均有采用继承抽象类来复用代码，同时进行委派实现个性化的操作\n适配器\n设计模式中最不擅长的一种模式，这是一种结构型模式，是直接进行委派不适配是，增加接口在适配器子类中进行转换适配和隐藏之前委派的一种模式。\n内聚和耦合\n高内聚低耦合是软件工程的重要概念，描述的功能应该是单一、简单、易理解且模块化的。\n表示泄露\n不仅影响不变性，也影响表示独立性，检查时从public - private 、 外部参数赋值给可变属性，返回值为可变属性等几个方面来进行检查。\ndefault方法\n通过其在接口中统一实现某些功能。无需在各个类中重复实现它，增量式增加而不破坏原来的类。\nLSP和JAVA\n子类型方法参数的逆变，在实际运行中算为overloadQAQ。同时Arrays也是协变的。Generics不是协变的。\nset与mutable\nmutable对象在set集合类中发生改变后，集合类行为不确定。\n黑盒与白盒\n白盒着眼于代码，黑盒着眼于模块，如白盒测试和黑盒测试，一个需要检查代码，一个只关注最后行为，白盒复用源代码可见，黑盒复用源代码不可见，白盒框架代码层面的继承，黑盒框架是实现特定接口/delegation进行框架扩展。\n最后的最后\n明天就是期末考试了，越复习越觉得之前写的代码还有很多很多可以修改的地方，想着时间再多一点，再尽善尽美一些。日升不滞哇，总会有遗憾，但遗憾是完善的过程，所以不能停止思考，更不能停止书写代码，不断前行，朝着理想的彼岸，绝对的理念进发。\n"
  },
  {
    "head": "一些细节",
    "paragraphs": [
      "引用参数的数组降价",
      "优先队列的缺省定义",
      "动态规划的边界条件",
      "c++的全局变量，慎",
      "关于memset造成MLE的问题，AC自动机！",
      "双目运算符的优先级！！"
    ],
    "sentences": [
      "引用参数的数组降价",
      "优先队列的缺省定义",
      "动态规划的边界条件",
      "c++的全局变量，慎",
      "关于memset造成MLE的问题，AC自动机！",
      "双目运算符的优先级！！"
    ],
    "codes": [],
    "date": "2017-07-26",
    "text": "引用参数的数组降价\n优先队列的缺省定义\n动态规划的边界条件\nc++的全局变量，慎\n关于memset造成MLE的问题，AC自动机！\n双目运算符的优先级！！\n"
  },
  {
    "head": "Java 软件构造 Software Construction（一）",
    "paragraphs": [
      "Java 软件构造 Software Construction（一）",
      "文章目录",
      "Java 软件构造 Software Construction（一）",
      "第一节课内容自我总结",
      "第一次实验",
      "git操作",
      "java读入",
      "命令行读入",
      "文件读入",
      "一些总结",
      "已经做好学习",
      "信息安全",
      "专业的准备，那么在学习这门课程时，也就有了自己在心中定下的要求。",
      "课上也提到本课内容及其丰富，虽然压缩了一些学时，但内容没有减少太多。也许未来会有些痛苦吧：），但现在站在山脚下的我，窥不见山的全貌，也难体会爬山的苦累。",
      "那么就只是爬山就好了，功不唐捐罢，积跬步至千里罢，进一步有进一步的欢喜罢，不管山有多高，只是不停爬山罢。",
      "也许有一天能一览众山小，能守得云开见月明，而我记录下这些足迹，告诉自己这些太远的路，是因为什么而出发。",
      "第一节课内容自我总结",
      "第一次实验",
      "git操作",
      "使用git remote的操作来链接远程仓库",
      "采用的较多的操作分别为`",
      "java读入",
      "命令行读入",
      "一开始采用如下方法判断",
      "后发现，while(scan.hasNextInt())无法处理读入回车停止的问题，于是采用先读入一行字符串后转换为int的形式进行",
      "文件读入",
      "首先是关于File类的一些基础性问题，在引用绝对路径时，注意不同操作系统文件路径分隔符不同的问题，采用File.separator来解决此类问题，即",
      "也可以用相对路径的方法新建File对象，根目录为project的根文件夹",
      "对于文件读入问题，可新建一个字节输入流，然后再读入即可",
      "一些总结",
      "java的数组为",
      "引用传递"
    ],
    "sentences": [
      "Java 软件构造 Software Construction（一）",
      "文章目录",
      "Java 软件构造 Software Construction（一）",
      "第一节课内容自我总结",
      "第一次实验",
      "git操作",
      "java读入",
      "命令行读入",
      "文件读入",
      "一些总结",
      "已经做好学习",
      "信息安全",
      "专业的准备",
      "那么在学习这门课程时",
      "也就有了自己在心中定下的要求",
      "课上也提到本课内容及其丰富",
      "虽然压缩了一些学时",
      "但内容没有减少太多",
      "也许未来会有些痛苦吧：）",
      "但现在站在山脚下的我",
      "窥不见山的全貌",
      "也难体会爬山的苦累",
      "那么就只是爬山就好了",
      "功不唐捐罢",
      "积跬步至千里罢",
      "进一步有进一步的欢喜罢",
      "不管山有多高",
      "只是不停爬山罢",
      "也许有一天能一览众山小",
      "能守得云开见月明",
      "而我记录下这些足迹",
      "告诉自己这些太远的路",
      "是因为什么而出发",
      "第一节课内容自我总结",
      "第一次实验",
      "git操作",
      "使用git remote的操作来链接远程仓库",
      "采用的较多的操作分别为`",
      "java读入",
      "命令行读入",
      "一开始采用如下方法判断",
      "后发现",
      "while(scan.hasNextInt())无法处理读入回车停止的问题",
      "于是采用先读入一行字符串后转换为int的形式进行",
      "文件读入",
      "首先是关于File类的一些基础性问题",
      "在引用绝对路径时",
      "注意不同操作系统文件路径分隔符不同的问题",
      "采用File.separator来解决此类问题",
      "即",
      "也可以用相对路径的方法新建File对象",
      "根目录为project的根文件夹",
      "对于文件读入问题，可新建一个字节输入流，然后再读入即可",
      "一些总结",
      "java的数组为",
      "引用传递"
    ],
    "codes": [
      "git remote//列出当前远程分支\n",
      "git remote -v//列出当前远程分支带url的信息\n",
      "git remote add origin @git.com:~~~~~//以ssh的方式，本地远程分支命名为origin来连接仓库\n",
      "git remote rm origin //删除本地指定为origin的远程地址\n",
      "git add .  //将文件添加至暂存区\n",
      "git commit -m \"\"  //将暂存区内容上传至本地仓库, -m后接备注信息\n",
      "git push origin master//上传至远程仓库，后两项为远程仓库名和分支名\n",
      "public static int command_line_input(int citations[]) {\n\t\tint paper_num = 0;                     //初始化数组长度\n\t\tScanner scan = new Scanner(System.in); //创造输入流对象\n\t\t\n\t\twhile(scan.hasNextInt()) {\n\t\t\tcitations[paper_num++] = scan.nextInt(); //读入论文\n\t\t\tif(citations[paper_num-1] < 0) {\t     //当论文引用量小于0时为非法输入\n\t\t\t\tillegal_input();\n\t\t\t\tscan.close();                         \n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}`在这里插入代码片`\n\t\n\t\tif(scan.hasNext()) {\t\t\t\t\t\t//若读入了非整型数字，同样为非法操作\n\t\t\tillegal_input();\t\n\t\t\tscan.close();             \t\t\t\t\t \t\n\t\t\treturn -1;\t\t\t\t\t\t\t\t\t \t\t\t\n\t\t}\n\t\t\n\t\tscan.close();             \n\t\t\n\t\treturn paper_num;\n\t}\n",
      "public static int command_line_input(int citations[]) {\n\t\tScanner scan = new Scanner(System.in); //创造输入流对象\n\t\t\n\t\tString citations_string[] = null;      //初始化读入字符串\n\t\tcitations_string = scan.nextLine().split(\" \");//读入带空格字符串\n\t\tscan.close();\n\t\t\n\t\tint paper_num = citations_string.length;     //初始化数组长度\n\t\tcitations = new int[paper_num];\n\t\tfor(int i = 0;i < paper_num;i++) {\n\t\t\ttry {\n\t\t\t\tcitations[i] = Integer.valueOf(citations_string[i]);\n\t\t\t}\n\t\t\tcatch(Exception e) {                    //遇到不是数字的情况输出非法信息\n\t\t\t\tillegal_input();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif(citations[i] < 0) {\n\t\t\t\tillegal_input();                    //引用量小于0也输出非法信息\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn paper_num;\n\t}\n",
      "File file = new File(\"d:\" + File.seprator + \"xx.txt\");\n",
      "File file = new File(\"\"src\" + File.separator + \"test\" + File.separator + \"input.txt\");\n",
      "InputStream is = new FileInputStream(\"src\" + File.separator + \"test\" + File.separator + \"input.txt\");\nScanner file_scan = new Scanner(is);\n"
    ],
    "date": "2021-06-15",
    "text": "Java 软件构造 Software Construction（一）\n文章目录\nJava 软件构造 Software Construction（一）\n第一节课内容自我总结\n第一次实验\ngit操作\njava读入\n命令行读入\n文件读入\n一些总结\n已经做好学习\n信息安全\n专业的准备，那么在学习这门课程时，也就有了自己在心中定下的要求。\n课上也提到本课内容及其丰富，虽然压缩了一些学时，但内容没有减少太多。也许未来会有些痛苦吧：），但现在站在山脚下的我，窥不见山的全貌，也难体会爬山的苦累。\n那么就只是爬山就好了，功不唐捐罢，积跬步至千里罢，进一步有进一步的欢喜罢，不管山有多高，只是不停爬山罢。\n也许有一天能一览众山小，能守得云开见月明，而我记录下这些足迹，告诉自己这些太远的路，是因为什么而出发。\n第一节课内容自我总结\n第一次实验\ngit操作\n使用git remote的操作来链接远程仓库\n采用的较多的操作分别为`\njava读入\n命令行读入\n一开始采用如下方法判断\n后发现，while(scan.hasNextInt())无法处理读入回车停止的问题，于是采用先读入一行字符串后转换为int的形式进行\n文件读入\n首先是关于File类的一些基础性问题，在引用绝对路径时，注意不同操作系统文件路径分隔符不同的问题，采用File.separator来解决此类问题，即\n也可以用相对路径的方法新建File对象，根目录为project的根文件夹\n对于文件读入问题，可新建一个字节输入流，然后再读入即可\n一些总结\njava的数组为\n引用传递\n"
  },
  {
    "head": "Java 软件构造 Software Construction（五）",
    "paragraphs": [
      "第三次实验相关",
      "关于Scanner与java.util.NoSuchElementException",
      "关于正则表达式（续）",
      "关于捕获组",
      "关于git checkout",
      "关于Scanner与java.util.NoSuchElementException",
      "一次关闭（System.in)后则永久关闭，再次打开会出现java.util.NoSuchElementException错误。",
      "关于正则表达式（续）",
      "注意大括号属于特殊字符需要加\\{来匹配",
      "关于捕获组",
      "捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。",
      "特殊的组group(0)代表整个表达式。",
      "下列代码为捕获一个,152-1234-1234}中152-1234-1234电话号的实例",
      "关于git checkout",
      "git 创建新分支的操作为",
      "切换到新分支的操作为",
      "将这两个操作合并在一起为",
      "在切换分支是是对当前HEAD指针指向的变化",
      "下图为本次实验分支指向的变化"
    ],
    "sentences": [
      "第三次实验相关",
      "关于Scanner与java.util.NoSuchElementException",
      "关于正则表达式（续）",
      "关于捕获组",
      "关于git checkout",
      "关于Scanner与java.util.NoSuchElementException",
      "一次关闭（System.in)后则永久关闭",
      "再次打开会出现java.util.NoSuchElementException错误",
      "关于正则表达式（续）",
      "注意大括号属于特殊字符需要加\\{来匹配",
      "关于捕获组",
      "捕获组是把多个字符当一个单独单元进行处理的方法",
      "它通过对括号内的字符分组来创建",
      "特殊的组group(0)代表整个表达式",
      "下列代码为捕获一个,152-1234-1234}中152-1234-1234电话号的实例",
      "关于git checkout",
      "git 创建新分支的操作为",
      "切换到新分支的操作为",
      "将这两个操作合并在一起为",
      "在切换分支是是对当前HEAD指针指向的变化",
      "下图为本次实验分支指向的变化"
    ],
    "codes": [
      "\t\t\tString phone = new String();\n\t\t\tpattern = Pattern.compile(\",(\\\\d{3}-\\\\d{4}-\\\\d{4})\\\\}\");\n\t\t\tmatcher = pattern.matcher(content);\n\t\t\tif(matcher.find() == true) {\n\t\t\t\tphone = matcher.group(1);\n\t\t\t}\n\t\t\telse return false;\n",
      "git branch branchName\n",
      "git checkout branchName\n",
      "git checkout -b branchName\n"
    ],
    "date": "2021-07-03",
    "text": "第三次实验相关\n关于Scanner与java.util.NoSuchElementException\n关于正则表达式（续）\n关于捕获组\n关于git checkout\n关于Scanner与java.util.NoSuchElementException\n一次关闭（System.in)后则永久关闭，再次打开会出现java.util.NoSuchElementException错误。\n关于正则表达式（续）\n注意大括号属于特殊字符需要加\\{来匹配\n关于捕获组\n捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。\n特殊的组group(0)代表整个表达式。\n下列代码为捕获一个,152-1234-1234}中152-1234-1234电话号的实例\n关于git checkout\ngit 创建新分支的操作为\n切换到新分支的操作为\n将这两个操作合并在一起为\n在切换分支是是对当前HEAD指针指向的变化\n下图为本次实验分支指向的变化\n"
  },
  {
    "head": "Java 软件构造 Software Construction(四）",
    "paragraphs": [
      "第三次实验相关",
      "关于Java自带类Date与Calendar的使用",
      "关于正则表达式",
      "关于Java自带类Date与Calendar的使用",
      "然后就发现这小破玩意基本被更厉害的Calendar替代了QAQ",
      "这里再介绍关于Calendar的使用",
      "Calendar是一个抽象类，且加上了protected修饰，所以要用其getInstance方法来构造",
      "关于正则表达式",
      "首先要注意的是，在java中\\表示插入一个正则表达式的反斜线，其后的字符具有特殊的意义",
      "一些常用的匹配为",
      "一次或多次匹配前面的字符或子表达式。",
      "零次或一次匹配前面的字符或子表达式。",
      "零次或多次匹配前面的字符或子表达式。",
      "{n}",
      "n 是非负整数。正好匹配 n 次。",
      "x或符号y",
      "匹配 x 或 y。",
      "[xyz]",
      "字符集。匹配包含的任一字符。",
      "[a-z]",
      "字符范围。匹配指定范围内的任何字符。",
      "数字字符匹配。等效于 [0-9]。",
      "对于模式匹配的基本操作为"
    ],
    "sentences": [
      "第三次实验相关",
      "关于Java自带类Date与Calendar的使用",
      "关于正则表达式",
      "关于Java自带类Date与Calendar的使用",
      "然后就发现这小破玩意基本被更厉害的Calendar替代了QAQ",
      "这里再介绍关于Calendar的使用",
      "Calendar是一个抽象类",
      "且加上了protected修饰",
      "所以要用其getInstance方法来构造",
      "关于正则表达式",
      "首先要注意的是",
      "在java中\\表示插入一个正则表达式的反斜线",
      "其后的字符具有特殊的意义",
      "一些常用的匹配为",
      "一次或多次匹配前面的字符或子表达式",
      "零次或一次匹配前面的字符或子表达式",
      "零次或多次匹配前面的字符或子表达式",
      "{n}",
      "n 是非负整数",
      "正好匹配 n 次",
      "x或符号y",
      "匹配 x 或 y",
      "[xyz]",
      "字符集",
      "匹配包含的任一字符",
      "[a-z]",
      "字符范围",
      "匹配指定范围内的任何字符",
      "数字字符匹配",
      "等效于 [0-9]",
      "对于模式匹配的基本操作为"
    ],
    "codes": [
      "Date d = new Date();//创建一个代表系统当前日期\nd = Date(2021-1900, 7-1, 1); //创建一个代表2021.7.1日期的Date，注意参数的设置\n//获取年月日方法如下\n int year = d.getYear() + 1900;\n int month = d.getMonth() + 1;\n int date = d.getDate();\n",
      "Calendar s = Calendar.getInstance();//默认当前日期\ns.set(2021, 7 - 1, 1);//调用set来设置，如此设置为2021.7.1\n//获取日期要用Calendar自带的常数来进行获取\n// 获得年月日\nint year = s.get(Calendar.YEAR);\nint month = s.get(Calendar.MONTH) + 1;\nint date = s.get(Calendar.DATE);\n",
      "String content = \"asdjdsfjsdlf13213asakd.,[l[12\";\nPattern pattern = Pattern.compile(\"[a-z]{3}\");\nMatcher matcher = pattern.matcher(content);\nif(matcher.find()){\n\tSystem.out.println(\"YES\");\n}\n"
    ],
    "date": "2021-07-01",
    "text": "第三次实验相关\n关于Java自带类Date与Calendar的使用\n关于正则表达式\n关于Java自带类Date与Calendar的使用\n然后就发现这小破玩意基本被更厉害的Calendar替代了QAQ\n这里再介绍关于Calendar的使用\nCalendar是一个抽象类，且加上了protected修饰，所以要用其getInstance方法来构造\n关于正则表达式\n首先要注意的是，在java中\\表示插入一个正则表达式的反斜线，其后的字符具有特殊的意义\n一些常用的匹配为\n一次或多次匹配前面的字符或子表达式。\n零次或一次匹配前面的字符或子表达式。\n零次或多次匹配前面的字符或子表达式。\n{n}\nn 是非负整数。正好匹配 n 次。\nx或符号y\n匹配 x 或 y。\n[xyz]\n字符集。匹配包含的任一字符。\n[a-z]\n字符范围。匹配指定范围内的任何字符。\n数字字符匹配。等效于 [0-9]。\n对于模式匹配的基本操作为\n"
  },
  {
    "head": "软件构造课程总结（4）",
    "paragraphs": [
      "软件构造课程总结（4）",
      "这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。",
      "1.对象、类、属性和方法",
      "Instance多个栈、static一个栈",
      "2.接口和枚举",
      "接口确定ADT规约，类用来实现ADT",
      "倾向于使用接口来定义变量。",
      "接口中一般没有constructor",
      "3.通过接口来写代码",
      "先写一个接口public interface MyString，再写一个实现pulic class SimplyMyString implements MyString，其中使用@override重写方法，而在接口中只出现方法。",
      "客户端需要知道某个具体实现类的名字来建立接口。",
      "静态工厂方法：直接在接口中实现建立。",
      "4.default方法",
      "接口的通用方法",
      "5.继承和重写：",
      "6.继承",
      "严格继承：不能重写",
      "如果不想子类重写，则加上final关键字",
      "7.重写",
      "使用super来调用父类型的方法",
      "抽象方法，不同的子类型各自重写",
      "静态类型检查",
      "8.多态",
      "9.泛型"
    ],
    "sentences": [
      "软件构造课程总结（4）",
      "这里是HIT2021软件构造课程的总结博客",
      "主要书写了本学期软件构造的所有课程内容和实验内容",
      "1.对象、类、属性和方法",
      "Instance多个栈、static一个栈",
      "2.接口和枚举",
      "接口确定ADT规约，类用来实现ADT",
      "倾向于使用接口来定义变量",
      "接口中一般没有constructor",
      "3.通过接口来写代码",
      "先写一个接口public interface MyString",
      "再写一个实现pulic class SimplyMyString implements MyString",
      "其中使用@override重写方法",
      "而在接口中只出现方法",
      "客户端需要知道某个具体实现类的名字来建立接口",
      "静态工厂方法：直接在接口中实现建立",
      "4.default方法",
      "接口的通用方法",
      "5.继承和重写：6.继承",
      "严格继承：不能重写",
      "如果不想子类重写，则加上final关键字",
      "7.重写",
      "使用super来调用父类型的方法",
      "抽象方法，不同的子类型各自重写",
      "静态类型检查",
      "8.多态",
      "9.泛型"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "软件构造课程总结（4）\n这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。\n1.对象、类、属性和方法\nInstance多个栈、static一个栈\n2.接口和枚举\n接口确定ADT规约，类用来实现ADT\n倾向于使用接口来定义变量。\n接口中一般没有constructor\n3.通过接口来写代码\n先写一个接口public interface MyString，再写一个实现pulic class SimplyMyString implements MyString，其中使用@override重写方法，而在接口中只出现方法。\n客户端需要知道某个具体实现类的名字来建立接口。\n静态工厂方法：直接在接口中实现建立。\n4.default方法\n接口的通用方法\n5.继承和重写：\n6.继承\n严格继承：不能重写\n如果不想子类重写，则加上final关键字\n7.重写\n使用super来调用父类型的方法\n抽象方法，不同的子类型各自重写\n静态类型检查\n8.多态\n9.泛型\n"
  },
  {
    "head": "软件构造课程总结（2）",
    "paragraphs": [
      "软件构造课程总结（2）",
      "这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。",
      "第四章、数据类型与类型检验",
      "1.程序中的数据类型",
      "数据类型范围基本数据类型和对象数据类型。",
      "基本数据类型：",
      "int, long, byte, short, char,float, double, boolean",
      "只有值，没有ID",
      "均为不可变类型",
      "在栈中分配内存",
      "对象数据类型：",
      "又值也有ID",
      "在堆中分配内存",
      "对象数据类型的结构：",
      "有继承关系",
      "有操作符",
      "有重载",
      "2.可变和不可变类型",
      "一句话来说，可变数据类型在内存中的值是可以变化的，而不可变数据类型在内存中的值是不能变化的，如果要改变变量，则需要重新分配一块内存，在这个内存中赋值，并且将指针到这块新的内存。",
      "在创造变量的时候加上final关键字可以使得变量变为不可变类型。",
      "比如String是一种不可变类型，则以下代码会在内存中发生这样的变化：",
      "String s = “a”;",
      "s = s.concat(“b”);",
      "先创造一个字符串\"a\"，将s指向这块内存。",
      "然后创造一个字符串\"ab\"，将s的指针改为这块内存。",
      "不可变类型与可变类型在遇到多个引用的时候会存在差异。",
      "不可变类型需要垃圾回收，但比较安全。",
      "可变类型不需要垃圾回收，速度比较快，但是不那么安全。",
      "可变类型需要防御式拷贝进行保护。",
      "第五章、数据类型与类型检验",
      "1.spec",
      "一句话来说，spec描述了函数的作用，以及前置条件（对输入的限制）和后置条件（对输出的要求）。",
      "2.spec的强度",
      "一句话来说，前置条件越弱，后置条件越强，spec就越强。"
    ],
    "sentences": [
      "软件构造课程总结（2）",
      "这里是HIT2021软件构造课程的总结博客",
      "主要书写了本学期软件构造的所有课程内容和实验内容",
      "第四章、数据类型与类型检验",
      "1.程序中的数据类型",
      "数据类型范围基本数据类型和对象数据类型",
      "基本数据类型：int, long, byte, short, char,float, double, boolean",
      "只有值，没有ID",
      "均为不可变类型",
      "在栈中分配内存",
      "对象数据类型：又值也有ID",
      "在堆中分配内存",
      "对象数据类型的结构：有继承关系",
      "有操作符",
      "有重载",
      "2.可变和不可变类型",
      "一句话来说",
      "可变数据类型在内存中的值是可以变化的",
      "而不可变数据类型在内存中的值是不能变化的",
      "如果要改变变量",
      "则需要重新分配一块内存",
      "在这个内存中赋值",
      "并且将指针到这块新的内存",
      "在创造变量的时候加上final关键字可以使得变量变为不可变类型",
      "比如String是一种不可变类型",
      "则以下代码会在内存中发生这样的变化：String s = “a”;s = s.concat(“b”);先创造一个字符串\"a\"",
      "将s指向这块内存",
      "然后创造一个字符串\"ab\"，将s的指针改为这块内存",
      "不可变类型与可变类型在遇到多个引用的时候会存在差异",
      "不可变类型需要垃圾回收，但比较安全",
      "可变类型不需要垃圾回收，速度比较快，但是不那么安全",
      "可变类型需要防御式拷贝进行保护",
      "第五章、数据类型与类型检验",
      "1.spec",
      "一句话来说",
      "spec描述了函数的作用",
      "以及前置条件（对输入的限制）和后置条件（对输出的要求）",
      "2.spec的强度",
      "一句话来说，前置条件越弱，后置条件越强，spec就越强"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "软件构造课程总结（2）\n这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。\n第四章、数据类型与类型检验\n1.程序中的数据类型\n数据类型范围基本数据类型和对象数据类型。\n基本数据类型：\nint, long, byte, short, char,float, double, boolean\n只有值，没有ID\n均为不可变类型\n在栈中分配内存\n对象数据类型：\n又值也有ID\n在堆中分配内存\n对象数据类型的结构：\n有继承关系\n有操作符\n有重载\n2.可变和不可变类型\n一句话来说，可变数据类型在内存中的值是可以变化的，而不可变数据类型在内存中的值是不能变化的，如果要改变变量，则需要重新分配一块内存，在这个内存中赋值，并且将指针到这块新的内存。\n在创造变量的时候加上final关键字可以使得变量变为不可变类型。\n比如String是一种不可变类型，则以下代码会在内存中发生这样的变化：\nString s = “a”;\ns = s.concat(“b”);\n先创造一个字符串\"a\"，将s指向这块内存。\n然后创造一个字符串\"ab\"，将s的指针改为这块内存。\n不可变类型与可变类型在遇到多个引用的时候会存在差异。\n不可变类型需要垃圾回收，但比较安全。\n可变类型不需要垃圾回收，速度比较快，但是不那么安全。\n可变类型需要防御式拷贝进行保护。\n第五章、数据类型与类型检验\n1.spec\n一句话来说，spec描述了函数的作用，以及前置条件（对输入的限制）和后置条件（对输出的要求）。\n2.spec的强度\n一句话来说，前置条件越弱，后置条件越强，spec就越强。\n"
  },
  {
    "head": "软件构造课程总结（5）",
    "paragraphs": [
      "软件构造课程总结（5）",
      "这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。",
      "第八章、ADT和OOP中的等价性",
      "1.根据AF来判断",
      "2.equals()重写Object的方法",
      "3.Hash的特别方法",
      "4.可变类型的等价性",
      "观察等价性（可能有bug）",
      "行为等价性（看内存位置，直接用Object的==）",
      "第十一章、面向可复用性和可维护性的设计方式",
      "关键词：工厂方法、adapter、decorator、strategy、template method、iterator、visitor",
      "设计模式：强调类、对象之间的交互关系，有创建型模式、结构性模式、行为类模式",
      "①创建型模式；",
      "工厂方法模式：一句话：通过接口实现creator",
      "Adapter模式：略",
      "Decorator模式：",
      "对每一个特性构造子类，使用委派机制增加到对象上",
      "2020期末考试考点总结：",
      "①checkRep，用assert对precondition进行合法性检查",
      "方法一：正则表达式",
      "方法二：String转为整数，小数",
      "②表示泄露",
      "③snapshot书写",
      "④健壮性处理：异常和防御式编程",
      "⑤测试：等价类划分和边界值测试",
      "⑥线程安全thread safe",
      "⑦AF和RI，spec中precondition强度的比较",
      "⑧设计模式之模板模式（可扩展性）",
      "⑨委派",
      "⑩LSP结构",
      "外部质量属性、git、安全性"
    ],
    "sentences": [
      "软件构造课程总结（5）",
      "这里是HIT2021软件构造课程的总结博客",
      "主要书写了本学期软件构造的所有课程内容和实验内容",
      "第八章、ADT和OOP中的等价性",
      "1.根据AF来判断",
      "2.equals()重写Object的方法",
      "3.Hash的特别方法",
      "4.可变类型的等价性",
      "观察等价性（可能有bug）",
      "行为等价性（看内存位置，直接用Object的==）",
      "第十一章、面向可复用性和可维护性的设计方式",
      "关键词：工厂方法、adapter、decorator、strategy、template method、iterator、visitor",
      "设计模式：强调类、对象之间的交互关系",
      "有创建型模式、结构性模式、行为类模式",
      "①创建型模式；工厂方法模式：一句话：通过接口实现creator",
      "Adapter模式：略",
      "Decorator模式：对每一个特性构造子类",
      "使用委派机制增加到对象上",
      "2020期末考试考点总结：①checkRep",
      "用assert对precondition进行合法性检查",
      "方法一：正则表达式",
      "方法二：String转为整数，小数",
      "②表示泄露",
      "③snapshot书写",
      "④健壮性处理：异常和防御式编程",
      "⑤测试：等价类划分和边界值测试",
      "⑥线程安全thread safe",
      "⑦AF和RI，spec中precondition强度的比较",
      "⑧设计模式之模板模式（可扩展性）",
      "⑨委派",
      "⑩LSP结构",
      "外部质量属性、git、安全性"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "软件构造课程总结（5）\n这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。\n第八章、ADT和OOP中的等价性\n1.根据AF来判断\n2.equals()重写Object的方法\n3.Hash的特别方法\n4.可变类型的等价性\n观察等价性（可能有bug）\n行为等价性（看内存位置，直接用Object的==）\n第十一章、面向可复用性和可维护性的设计方式\n关键词：工厂方法、adapter、decorator、strategy、template method、iterator、visitor\n设计模式：强调类、对象之间的交互关系，有创建型模式、结构性模式、行为类模式\n①创建型模式；\n工厂方法模式：一句话：通过接口实现creator\nAdapter模式：略\nDecorator模式：\n对每一个特性构造子类，使用委派机制增加到对象上\n2020期末考试考点总结：\n①checkRep，用assert对precondition进行合法性检查\n方法一：正则表达式\n方法二：String转为整数，小数\n②表示泄露\n③snapshot书写\n④健壮性处理：异常和防御式编程\n⑤测试：等价类划分和边界值测试\n⑥线程安全thread safe\n⑦AF和RI，spec中precondition强度的比较\n⑧设计模式之模板模式（可扩展性）\n⑨委派\n⑩LSP结构\n外部质量属性、git、安全性\n"
  },
  {
    "head": "软件构造课程总结（1）",
    "paragraphs": [
      "软件构造课程总结（1）",
      "这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。",
      "第一章、软件构造的多篇维度视图和质量目标",
      "1.软件构造的多重视图：",
      "这一小节主要讲述了软件构造的三视图维度，分别从时间点还是时间段（Moment or Period）、构建还是运行（Build-time or Run-time）以及代码的逻辑结构和物理结构（Code-level or Component-level）讲述了软件构造。",
      "下面是一些比较重要的知识点：",
      "1.Code-level：代码的逻辑结构",
      "2.Component-level：代码的物理结构",
      "3.Moment view：特定时刻的软件形态",
      "4.Period view：软件形态随时间的变化",
      "5.三种形式：词汇层面，语法层面，语义层面",
      "6.AST：语法分析树，在编译原理中十分重要",
      "7.语义：源代码的目标",
      "8.源代码：现实世界的代码",
      "9.Code Churn：结构随着版本的变化的改变",
      "10.Library：库文件，存在静态链接和动态链接两种形式",
      "11.UML：类图",
      "12.Code snapshot：描述程序运行时内存中变量层面的状态。",
      "13.Memory dump：记录运行时的内存信息",
      "14.Log：日志",
      "2.软件构造的质量",
      "这一小节讲述了软件构造时衡量软件质量的几个标准：",
      "1.正确性：",
      "按照软件的规约spec正确的执行。正确性也是最重要的质量标准。",
      "几个保证正确性的方法：",
      "①测试，将详细在第二节中讲解",
      "②防御式编程：相关的知识有防御式拷贝，权限的使用（private关键字）",
      "③checkRep()函数的编写：在程序中我们可以编写一个检查程序，这个方法将时时刻刻检查我们类型中的不变量是否正确。",
      "2.健壮性",
      "健壮性是指程序在遇到不符合spec的规定时仍然能够正确的处理，比如返回异常报错",
      "3.可扩展性",
      "我们有时候需要对软件的规约进行修改、拓展，是否足够容易？这里就需要我们增强程序的可扩展性。一个可扩展性好的程序可以针对用户的需求扩大进行快速的迭代。",
      "4.可复用性",
      "一次开发，多次使用。",
      "5.兼容性",
      "6.同构性",
      "7.性能",
      "8.可移植性",
      "9.易用性",
      "10.及时性",
      "等等。。",
      "我们在编写程序的时候需要对以上这些标准进行衡量，从而构建出一个最能满足客户需求的程序。比如，通常正确性是程序的第一位，而在性能和可扩展性、可复用性的衡量上，则需要根据客户的需求进行设计。",
      "第二章、软件测试和测试优先的编程",
      "这一章主要讲述了如何进行程序测试和测试优先编程的思想。我们测试程序，应该抱着找出错误的决心，这是我们测试的第一要义。",
      "测试程序主要有两个要点：",
      "①等价类",
      "基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。",
      "我们需要针对每个输入数据需要满足的约束条件，划分等价类。",
      "而 每个等价类代表着对输入约束加以满足或违反的有效或无效数据的集合。",
      "而由于等价类的特性，我们只需要从等价类中选择一个来测试即可。",
      "例子：",
      "n是正奇数：",
      "正数：>0、<0",
      "奇数：奇数、偶数",
      "奇数隐含着整数：整数、非整数",
      "或者：",
      "输入的学号no需满足的条件：",
      "长度为10位：10、>10、<10",
      "以118开头：以此开头、以其他开头",
      "之后两位数应为03/36/37：03、36、37、其他",
      "②边界测试",
      "在工程师进行测试时，发现错误往往出现在边界情况上，比如在上面的例子中，n=0就是一个边界情况。边界值分析方法是对等价类划分方法的补充。通过边界测试，可以让我们更好的测试出错误。",
      "第三章、软件构造过程和配置管理",
      "这一章主要介绍了两个重要知识点：敏捷开发和git的结构和使用",
      "①敏捷开发",
      "敏捷开发主要通过快速迭代和小规模的持续改进，以快速适应变化。",
      "在2001年Agile Manifesto发表敏捷宣言。",
      "Agile = 增量 + 迭代",
      "每次迭代处理一个小规模增量",
      "②git",
      "1.git的层次结构：工作目录workspace、暂存区staging、仓库local repository和远程仓库remote repository（通常是github）。所有的操作就在这四个层次上进行。",
      "2.git中文件的结构：我们使用一个树结构来描述git的文件结构：每个commit指向一个父亲；多个",
      "commit指向同一个父亲：分支；一个commit指向两个父亲：合并",
      "以上是我总结的一到三章的重点知识。"
    ],
    "sentences": [
      "软件构造课程总结（1）",
      "这里是HIT2021软件构造课程的总结博客",
      "主要书写了本学期软件构造的所有课程内容和实验内容",
      "第一章、软件构造的多篇维度视图和质量目标",
      "1.软件构造的多重视图：这一小节主要讲述了软件构造的三视图维度",
      "分别从时间点还是时间段（Moment or Period）、构建还是运行（Build-time or Run-time）以及代码的逻辑结构和物理结构（Code-level or Component-level）讲述了软件构造",
      "下面是一些比较重要的知识点：1.Code-level：代码的逻辑结构",
      "2.Component-level：代码的物理结构",
      "3.Moment view：特定时刻的软件形态",
      "4.Period view：软件形态随时间的变化",
      "5.三种形式：词汇层面，语法层面，语义层面",
      "6.AST：语法分析树，在编译原理中十分重要",
      "7.语义：源代码的目标",
      "8.源代码：现实世界的代码",
      "9.Code Churn：结构随着版本的变化的改变",
      "10.Library：库文件，存在静态链接和动态链接两种形式",
      "11.UML：类图",
      "12.Code snapshot：描述程序运行时内存中变量层面的状态",
      "13.Memory dump：记录运行时的内存信息",
      "14.Log：日志",
      "2.软件构造的质量",
      "这一小节讲述了软件构造时衡量软件质量的几个标准：1.正确性：按照软件的规约spec正确的执行",
      "正确性也是最重要的质量标准",
      "几个保证正确性的方法：①测试，将详细在第二节中讲解",
      "②防御式编程：相关的知识有防御式拷贝",
      "权限的使用（private关键字）",
      "③checkRep()函数的编写：在程序中我们可以编写一个检查程序",
      "这个方法将时时刻刻检查我们类型中的不变量是否正确",
      "2.健壮性",
      "健壮性是指程序在遇到不符合spec的规定时仍然能够正确的处理",
      "比如返回异常报错",
      "3.可扩展性",
      "我们有时候需要对软件的规约进行修改、拓展",
      "是否足够容易？这里就需要我们增强程序的可扩展性",
      "一个可扩展性好的程序可以针对用户的需求扩大进行快速的迭代",
      "4.可复用性",
      "一次开发，多次使用",
      "5.兼容性",
      "6.同构性",
      "7.性能",
      "8.可移植性",
      "9.易用性",
      "10.及时性",
      "等等",
      "我们在编写程序的时候需要对以上这些标准进行衡量",
      "从而构建出一个最能满足客户需求的程序",
      "比如",
      "通常正确性是程序的第一位",
      "而在性能和可扩展性、可复用性的衡量上",
      "则需要根据客户的需求进行设计",
      "第二章、软件测试和测试优先的编程",
      "这一章主要讲述了如何进行程序测试和测试优先编程的思想",
      "我们测试程序，应该抱着找出错误的决心，这是我们测试的第一要义",
      "测试程序主要有两个要点：①等价类",
      "基于等价类划分的测试：将被测函数的输入域划分为等价类",
      "从等价类中导出测试用例",
      "我们需要针对每个输入数据需要满足的约束条件，划分等价类",
      "而 每个等价类代表着对输入约束加以满足或违反的有效或无效数据的集合",
      "而由于等价类的特性，我们只需要从等价类中选择一个来测试即可",
      "例子：n是正奇数：正数：>0、<0",
      "奇数：奇数、偶数",
      "奇数隐含着整数：整数、非整数",
      "或者：输入的学号no需满足的条件：长度为10位：10、>10、<10",
      "以118开头：以此开头、以其他开头",
      "之后两位数应为03/36/37：03、36、37、其他",
      "②边界测试",
      "在工程师进行测试时",
      "发现错误往往出现在边界情况上",
      "比如在上面的例子中",
      "n=0就是一个边界情况",
      "边界值分析方法是对等价类划分方法的补充",
      "通过边界测试，可以让我们更好的测试出错误",
      "第三章、软件构造过程和配置管理",
      "这一章主要介绍了两个重要知识点：敏捷开发和git的结构和使用",
      "①敏捷开发",
      "敏捷开发主要通过快速迭代和小规模的持续改进，以快速适应变化",
      "在2001年Agile Manifesto发表敏捷宣言",
      "Agile = 增量 + 迭代",
      "每次迭代处理一个小规模增量",
      "②git",
      "1.git的层次结构：工作目录workspace、暂存区staging、仓库local repository和远程仓库remote repository（通常是github）",
      "所有的操作就在这四个层次上进行",
      "2.git中文件的结构：我们使用一个树结构来描述git的文件结构：每个commit指向一个父亲；多个",
      "commit指向同一个父亲：分支；一个commit指向两个父亲：合并",
      "以上是我总结的一到三章的重点知识"
    ],
    "codes": [],
    "date": "2021-07-05",
    "text": "软件构造课程总结（1）\n这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。\n第一章、软件构造的多篇维度视图和质量目标\n1.软件构造的多重视图：\n这一小节主要讲述了软件构造的三视图维度，分别从时间点还是时间段（Moment or Period）、构建还是运行（Build-time or Run-time）以及代码的逻辑结构和物理结构（Code-level or Component-level）讲述了软件构造。\n下面是一些比较重要的知识点：\n1.Code-level：代码的逻辑结构\n2.Component-level：代码的物理结构\n3.Moment view：特定时刻的软件形态\n4.Period view：软件形态随时间的变化\n5.三种形式：词汇层面，语法层面，语义层面\n6.AST：语法分析树，在编译原理中十分重要\n7.语义：源代码的目标\n8.源代码：现实世界的代码\n9.Code Churn：结构随着版本的变化的改变\n10.Library：库文件，存在静态链接和动态链接两种形式\n11.UML：类图\n12.Code snapshot：描述程序运行时内存中变量层面的状态。\n13.Memory dump：记录运行时的内存信息\n14.Log：日志\n2.软件构造的质量\n这一小节讲述了软件构造时衡量软件质量的几个标准：\n1.正确性：\n按照软件的规约spec正确的执行。正确性也是最重要的质量标准。\n几个保证正确性的方法：\n①测试，将详细在第二节中讲解\n②防御式编程：相关的知识有防御式拷贝，权限的使用（private关键字）\n③checkRep()函数的编写：在程序中我们可以编写一个检查程序，这个方法将时时刻刻检查我们类型中的不变量是否正确。\n2.健壮性\n健壮性是指程序在遇到不符合spec的规定时仍然能够正确的处理，比如返回异常报错\n3.可扩展性\n我们有时候需要对软件的规约进行修改、拓展，是否足够容易？这里就需要我们增强程序的可扩展性。一个可扩展性好的程序可以针对用户的需求扩大进行快速的迭代。\n4.可复用性\n一次开发，多次使用。\n5.兼容性\n6.同构性\n7.性能\n8.可移植性\n9.易用性\n10.及时性\n等等。。\n我们在编写程序的时候需要对以上这些标准进行衡量，从而构建出一个最能满足客户需求的程序。比如，通常正确性是程序的第一位，而在性能和可扩展性、可复用性的衡量上，则需要根据客户的需求进行设计。\n第二章、软件测试和测试优先的编程\n这一章主要讲述了如何进行程序测试和测试优先编程的思想。我们测试程序，应该抱着找出错误的决心，这是我们测试的第一要义。\n测试程序主要有两个要点：\n①等价类\n基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。\n我们需要针对每个输入数据需要满足的约束条件，划分等价类。\n而 每个等价类代表着对输入约束加以满足或违反的有效或无效数据的集合。\n而由于等价类的特性，我们只需要从等价类中选择一个来测试即可。\n例子：\nn是正奇数：\n正数：>0、<0\n奇数：奇数、偶数\n奇数隐含着整数：整数、非整数\n或者：\n输入的学号no需满足的条件：\n长度为10位：10、>10、<10\n以118开头：以此开头、以其他开头\n之后两位数应为03/36/37：03、36、37、其他\n②边界测试\n在工程师进行测试时，发现错误往往出现在边界情况上，比如在上面的例子中，n=0就是一个边界情况。边界值分析方法是对等价类划分方法的补充。通过边界测试，可以让我们更好的测试出错误。\n第三章、软件构造过程和配置管理\n这一章主要介绍了两个重要知识点：敏捷开发和git的结构和使用\n①敏捷开发\n敏捷开发主要通过快速迭代和小规模的持续改进，以快速适应变化。\n在2001年Agile Manifesto发表敏捷宣言。\nAgile = 增量 + 迭代\n每次迭代处理一个小规模增量\n②git\n1.git的层次结构：工作目录workspace、暂存区staging、仓库local repository和远程仓库remote repository（通常是github）。所有的操作就在这四个层次上进行。\n2.git中文件的结构：我们使用一个树结构来描述git的文件结构：每个commit指向一个父亲；多个\ncommit指向同一个父亲：分支；一个commit指向两个父亲：合并\n以上是我总结的一到三章的重点知识。\n"
  },
  {
    "head": "软件构造课程总结（3）",
    "paragraphs": [
      "软件构造课程总结（3）",
      "这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。",
      "第六章、ADT",
      "1.表示独立性：通过封装来阻止用户访问程序内部",
      "2.抽象函数AF",
      "3.表示不变量RI",
      "4.数据抽象：强调作用于数据上的操作，在java中使用类的方法",
      "5.可变数据类型和不可变数据类型：改变时，前者改变内存中数值，后者构造一个新对象",
      "6.四种方法：creators、producers、observes、mutators",
      "7.creators：构造函数或者静态函数，或者工厂方法",
      "8.mutators：通常返回void",
      "9.int是immutable没有构造器mutators，而String是immutable所以也没有构造器mutators",
      "10.list是mutable，存在构造器mutators，比如add()",
      "11.抽象类型设计",
      "Ⅰ.简洁一致的操作",
      "Ⅱ.面向用户需求，满足所有需要且尽量简洁",
      "Ⅲ.要么抽象要么具体。",
      "12.表示独立性",
      "内部实现对与用户无关",
      "例子：MyString",
      "要点：不能让用户访问到类体（使用private表示、observers使用保护式拷贝）",
      "13.测试ADT",
      "同样是测试四个部分：creators、producers、observes、mutators",
      "主要测试返回值和操作结果",
      "14.不变量",
      "程序中始终保持不变的属性，比如一个家庭类当中，人数总是大于0的。",
      "15.RI（Rep Invariant）",
      "开发者关注R，client关注I",
      "三种关系：满射、非单射、非双射",
      "AF：抽象函数，R到A的映射",
      "R中存在非法值，这时在A中无映射",
      "RI中元素合法的子集",
      "16.AF",
      "一个R到A的映射",
      "总结一下RI和AF：RI是输入的约束条件，AF是输入到输出的函数"
    ],
    "sentences": [
      "软件构造课程总结（3）",
      "这里是HIT2021软件构造课程的总结博客",
      "主要书写了本学期软件构造的所有课程内容和实验内容",
      "第六章、ADT",
      "1.表示独立性：通过封装来阻止用户访问程序内部",
      "2.抽象函数AF",
      "3.表示不变量RI",
      "4.数据抽象：强调作用于数据上的操作",
      "在java中使用类的方法",
      "5.可变数据类型和不可变数据类型：改变时",
      "前者改变内存中数值",
      "后者构造一个新对象",
      "6.四种方法：creators、producers、observes、mutators",
      "7.creators：构造函数或者静态函数，或者工厂方法",
      "8.mutators：通常返回void",
      "9.int是immutable没有构造器mutators",
      "而String是immutable所以也没有构造器mutators",
      "10.list是mutable",
      "存在构造器mutators",
      "比如add()",
      "11.抽象类型设计",
      "Ⅰ.简洁一致的操作",
      "Ⅱ.面向用户需求，满足所有需要且尽量简洁",
      "Ⅲ.要么抽象要么具体",
      "12.表示独立性",
      "内部实现对与用户无关",
      "例子：MyString",
      "要点：不能让用户访问到类体（使用private表示、observers使用保护式拷贝）",
      "13.测试ADT",
      "同样是测试四个部分：creators、producers、observes、mutators",
      "主要测试返回值和操作结果",
      "14.不变量",
      "程序中始终保持不变的属性",
      "比如一个家庭类当中",
      "人数总是大于0的",
      "15.RI（Rep Invariant）",
      "开发者关注R，client关注I",
      "三种关系：满射、非单射、非双射",
      "AF：抽象函数，R到A的映射",
      "R中存在非法值，这时在A中无映射",
      "RI中元素合法的子集",
      "16.AF",
      "一个R到A的映射",
      "总结一下RI和AF：RI是输入的约束条件",
      "AF是输入到输出的函数"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "软件构造课程总结（3）\n这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。\n第六章、ADT\n1.表示独立性：通过封装来阻止用户访问程序内部\n2.抽象函数AF\n3.表示不变量RI\n4.数据抽象：强调作用于数据上的操作，在java中使用类的方法\n5.可变数据类型和不可变数据类型：改变时，前者改变内存中数值，后者构造一个新对象\n6.四种方法：creators、producers、observes、mutators\n7.creators：构造函数或者静态函数，或者工厂方法\n8.mutators：通常返回void\n9.int是immutable没有构造器mutators，而String是immutable所以也没有构造器mutators\n10.list是mutable，存在构造器mutators，比如add()\n11.抽象类型设计\nⅠ.简洁一致的操作\nⅡ.面向用户需求，满足所有需要且尽量简洁\nⅢ.要么抽象要么具体。\n12.表示独立性\n内部实现对与用户无关\n例子：MyString\n要点：不能让用户访问到类体（使用private表示、observers使用保护式拷贝）\n13.测试ADT\n同样是测试四个部分：creators、producers、observes、mutators\n主要测试返回值和操作结果\n14.不变量\n程序中始终保持不变的属性，比如一个家庭类当中，人数总是大于0的。\n15.RI（Rep Invariant）\n开发者关注R，client关注I\n三种关系：满射、非单射、非双射\nAF：抽象函数，R到A的映射\nR中存在非法值，这时在A中无映射\nRI中元素合法的子集\n16.AF\n一个R到A的映射\n总结一下RI和AF：RI是输入的约束条件，AF是输入到输出的函数\n"
  },
  {
    "head": "HDU - 4460 Friend Chains（邻接表&BFS）",
    "paragraphs": [
      "小白日记.2 HDU - 4460 Friend Chains",
      "题目大意：如果两个人互为朋友则距离为一，距离可累加，求一群人中任意两个人之间的最短距离的最大值。",
      "常见的BFS",
      "利用邻接表剪枝",
      "代码如下：",
      "总结与收获：",
      "1.邻接表的使用",
      "2.map将字符串映射为数字",
      "3.初始化"
    ],
    "sentences": [
      "小白日记.2 HDU - 4460 Friend Chains",
      "题目大意：如果两个人互为朋友则距离为一",
      "距离可累加",
      "求一群人中任意两个人之间的最短距离的最大值",
      "常见的BFS",
      "利用邻接表剪枝",
      "代码如下：总结与收获：1.邻接表的使用",
      "2.map将字符串映射为数字",
      "3.初始化"
    ],
    "codes": [
      "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nmap <string,int> m;\nvector <int> gx[1007];\nint cc[1007];\nint k=0,ok=0,N;\n\nstruct node{\n    int p;\n    int t;\n};\n\nvoid Bfs(int x)\n{\n    memset(cc,0,sizeof(cc));\n    queue <node> q;\n    node now,next;\n    now.p=x;\n    now.t=0;\n    q.push(now);\n    cc[x]=1;\n    while(!q.empty()){\n        now=q.front();\n        q.pop();\n        for(int i=0;i<gx[now.p].size();i++){//利用邻接表简化代码\n            int j=gx[now.p][i];\n            if(cc[j]==0){\n                next.p=j;\n                next.t=now.t+1;\n                q.push(next);\n                cc[j]=1;//查重 剪枝\n                k=max(k,next.t);\n            }\n        }\n    }\n    for(int i=0;i<N;i++){\n        if(cc[i]==0){\n            ok=1;\n        }\n    }\n}\n\nint main()\n{\n    int c;\n    string str;\n    while(cin>>N&&N){\n        ok=0;\n        k=0;\n        m.clear();\n        for(int i=0;i<N;i++){//初始化\n            gx[i].clear();\n        }\n        for(int i=0;i<N;i++){\n            cin>>str;\n            m[str]=i;//将字符串映射为数字\n        }\n        cin>>c;\n        while(c--){\n            int a1,a2;\n            cin>>str;\n            a1=m[str];\n            cin>>str;\n            a2=m[str];\n            gx[a1].push_back(a2);\n            gx[a2].push_back(a1);//建立邻接表\n        }\n        for(int i=0;i<N;i++){\n            Bfs(i);\n            if(ok==1) break;\n        }\n        if(ok==1)\n            cout<<-1<<endl;\n        else\n            cout<<k<<endl;\n    }\n    return 0;\n}\n\n"
    ],
    "date": "2020-03-06",
    "text": "小白日记.2 HDU - 4460 Friend Chains\n题目大意：如果两个人互为朋友则距离为一，距离可累加，求一群人中任意两个人之间的最短距离的最大值。\n常见的BFS\n利用邻接表剪枝\n代码如下：\n总结与收获：\n1.邻接表的使用\n2.map将字符串映射为数字\n3.初始化\n"
  },
  {
    "head": "软件构造笔记（十一）---PPT第七讲",
    "paragraphs": [
      "面向对象的编程",
      "静态/实例方法",
      "接口和类",
      "静态工厂方法",
      "default",
      "三个关键字",
      "重写 Override",
      "重载 Overrload",
      "静态/实例方法",
      "静态变量/方法：与类关联的变量，而不是与类的实例关联的变量。若将方法与类关联，则为静态方法",
      "要引用类变量和方法，可以用句点(’.’)将类的名称和类方法或类变量的名称连接起来",
      "实例变量/方法：不是类方法或类变量的方法和变量称为实例方法或实例变量。",
      "要引用实例方法和变量，必须引用来自类实例的方法和变量。",
      "总结：类变量和类方法与一个类关联，并且每个类只出现一次。使用它们不需要创建对象。",
      "实例方法和变量在一个类的每个实例中出现一次。静态方法不与类的任何特定实例相关联，而实例方法(声明时不使用Static关键字)必须在特定对象上调用。",
      "举例来说：",
      "注意：",
      "1.静态方法只能调用静态变量",
      "2.实例方法既可以调用静态变量，也可以调用正常变量",
      "3.main函数中调用static变量：使用类+方法名称调用",
      "两者对比：",
      "接口和类",
      "Interface和Class: 定义和实现ADT",
      "接口：确定ADT 规约；类：实现ADT",
      "1.接口之间可以继承与扩展",
      "2.一个类可以实现多个接口（从而具备了多个接口中的方法）",
      "3.一个接口可以有多种实现类",
      "4.也可以不需要接口直接使用类作为ADT ，既有ADT 定义也有ADT实现，实际中更倾向于使用接口来定义变量",
      "静态工厂方法",
      "设MyString是接口，FastMyString是实现MyString接口的类",
      "实现过程出现了问题：",
      "1.打破了抽象边界，接口定义中没有包含constructor，也无法保证所有实现类中都包含了同样名字的constructor。",
      "2.故而，客户端需要知道该接口的某个具体实现类的名字",
      "修改策略：使用静态工厂方法，可以避免使用具体实现类的名字",
      "default",
      "接口中的每个方法在所有类中都要实现；通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它；以增量式的为接口增加额外的功能而不破坏已实现的类",
      "三个关键字",
      "private：只能在声明类中访问",
      "protected：可从声明类的子类(以及包内)访问",
      "public：可以任意访问",
      "重写 Override",
      "重写是在运行时决定执行哪个方法",
      "使用final关键字的方法不能在子类中被重写",
      "重写的函数：完全同样的signature",
      "实际执行时调用哪个方法，",
      "运行时",
      "如果父类的一个对象被用来调用该方法，则父类中的版本将被执行;如果使用子类的对象来调用该方法，则执行子类中的版本",
      "父类型中的被重写函数体不为空：意味着对其大多数子类型来说，该方法",
      "是可以被直接复用的。",
      "对某些子类型来说，有特殊性，故重写父类型中的函数，实现自己的特殊",
      "如果父类型中的某个函数实现体为空，意味着其所有子类型都需要这个功能，但各有差异，没有共性，在每个子类中均需要重写。",
      "重写之后，利用super()复用了父类型中函数的功能，并对其进行了扩展",
      "子类的构造方法若要继承父类，则应该放在构造函数的第一步",
      "重载 Overrload",
      "重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型",
      "价值：方便client 调用，client 可用不同的参数列表，调用同样的函数",
      "重载是在编译阶段时决定要具体执行哪个方法，即静态检查时决定",
      "特点：",
      "1.不同的参数列表",
      "2.相同/不同的返回值类型",
      "3.相同/不同的public/private/protected",
      "4.可以声明异常",
      "5.可以在同一个类内重载，也可在子类中重载",
      "举例来说：定义如下的类",
      "若判断条件如下，会产生异常，原因是由于重载方法是在编译时检查，ah2此时还是Animal类型，所以应用的eat方法不应该传入参数",
      "以下两种声明方式就不会出错",
      "第一个调用Animal类中的方法",
      "第二个调用Horse类中的方法，传入参数",
      "另一个例子如下",
      "Animal若是接口，则可以按照3的方式进行调用",
      "两者的区别与联系：",
      "泛型接口的实现方法",
      "1.泛型接口、非泛型实现类",
      "2.泛型接口、泛型实现类"
    ],
    "sentences": [
      "面向对象的编程",
      "静态/实例方法",
      "接口和类",
      "静态工厂方法",
      "default",
      "三个关键字",
      "重写 Override",
      "重载 Overrload",
      "静态/实例方法",
      "静态变量/方法：与类关联的变量，而不是与类的实例关联的变量",
      "若将方法与类关联，则为静态方法",
      "要引用类变量和方法",
      "可以用句点(’.’)将类的名称和类方法或类变量的名称连接起来",
      "实例变量/方法：不是类方法或类变量的方法和变量称为实例方法或实例变量",
      "要引用实例方法和变量，必须引用来自类实例的方法和变量",
      "总结：类变量和类方法与一个类关联，并且每个类只出现一次",
      "使用它们不需要创建对象",
      "实例方法和变量在一个类的每个实例中出现一次",
      "静态方法不与类的任何特定实例相关联",
      "而实例方法(声明时不使用Static关键字)必须在特定对象上调用",
      "举例来说：注意：1.静态方法只能调用静态变量",
      "2.实例方法既可以调用静态变量，也可以调用正常变量",
      "3.main函数中调用static变量：使用类+方法名称调用",
      "两者对比：接口和类",
      "Interface和Class: 定义和实现ADT",
      "接口：确定ADT 规约；类：实现ADT",
      "1.接口之间可以继承与扩展",
      "2.一个类可以实现多个接口（从而具备了多个接口中的方法）",
      "3.一个接口可以有多种实现类",
      "4.也可以不需要接口直接使用类作为ADT ",
      "既有ADT 定义也有ADT实现",
      "实际中更倾向于使用接口来定义变量",
      "静态工厂方法",
      "设MyString是接口",
      "FastMyString是实现MyString接口的类",
      "实现过程出现了问题：1.打破了抽象边界",
      "接口定义中没有包含constructor",
      "也无法保证所有实现类中都包含了同样名字的constructor",
      "2.故而，客户端需要知道该接口的某个具体实现类的名字",
      "修改策略：使用静态工厂方法，可以避免使用具体实现类的名字",
      "default",
      "接口中的每个方法在所有类中都要实现；通过default方法",
      "在接口中统一实现某些功能",
      "无需在各个类中重复实现它；以增量式的为接口增加额外的功能而不破坏已实现的类",
      "三个关键字",
      "private：只能在声明类中访问",
      "protected：可从声明类的子类(以及包内)访问",
      "public：可以任意访问",
      "重写 Override",
      "重写是在运行时决定执行哪个方法",
      "使用final关键字的方法不能在子类中被重写",
      "重写的函数：完全同样的signature",
      "实际执行时调用哪个方法，运行时",
      "如果父类的一个对象被用来调用该方法",
      "则父类中的版本将被执行;如果使用子类的对象来调用该方法",
      "则执行子类中的版本",
      "父类型中的被重写函数体不为空：意味着对其大多数子类型来说",
      "该方法",
      "是可以被直接复用的",
      "对某些子类型来说",
      "有特殊性",
      "故重写父类型中的函数",
      "实现自己的特殊",
      "如果父类型中的某个函数实现体为空",
      "意味着其所有子类型都需要这个功能",
      "但各有差异",
      "没有共性",
      "在每个子类中均需要重写",
      "重写之后",
      "利用super()复用了父类型中函数的功能",
      "并对其进行了扩展",
      "子类的构造方法若要继承父类，则应该放在构造函数的第一步",
      "重载 Overrload",
      "重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型",
      "价值：方便client 调用",
      "client 可用不同的参数列表",
      "调用同样的函数",
      "重载是在编译阶段时决定要具体执行哪个方法，即静态检查时决定",
      "特点：1.不同的参数列表",
      "2.相同/不同的返回值类型",
      "3.相同/不同的public/private/protected",
      "4.可以声明异常",
      "5.可以在同一个类内重载，也可在子类中重载",
      "举例来说：定义如下的类",
      "若判断条件如下",
      "会产生异常",
      "原因是由于重载方法是在编译时检查",
      "ah2此时还是Animal类型",
      "所以应用的eat方法不应该传入参数",
      "以下两种声明方式就不会出错",
      "第一个调用Animal类中的方法",
      "第二个调用Horse类中的方法，传入参数",
      "另一个例子如下",
      "Animal若是接口，则可以按照3的方式进行调用",
      "两者的区别与联系：泛型接口的实现方法",
      "1.泛型接口、非泛型实现类",
      "2.泛型接口、泛型实现类"
    ],
    "codes": [],
    "date": "2021-07-02",
    "text": "面向对象的编程\n静态/实例方法\n接口和类\n静态工厂方法\ndefault\n三个关键字\n重写 Override\n重载 Overrload\n静态/实例方法\n静态变量/方法：与类关联的变量，而不是与类的实例关联的变量。若将方法与类关联，则为静态方法\n要引用类变量和方法，可以用句点(’.’)将类的名称和类方法或类变量的名称连接起来\n实例变量/方法：不是类方法或类变量的方法和变量称为实例方法或实例变量。\n要引用实例方法和变量，必须引用来自类实例的方法和变量。\n总结：类变量和类方法与一个类关联，并且每个类只出现一次。使用它们不需要创建对象。\n实例方法和变量在一个类的每个实例中出现一次。静态方法不与类的任何特定实例相关联，而实例方法(声明时不使用Static关键字)必须在特定对象上调用。\n举例来说：\n注意：\n1.静态方法只能调用静态变量\n2.实例方法既可以调用静态变量，也可以调用正常变量\n3.main函数中调用static变量：使用类+方法名称调用\n两者对比：\n接口和类\nInterface和Class: 定义和实现ADT\n接口：确定ADT 规约；类：实现ADT\n1.接口之间可以继承与扩展\n2.一个类可以实现多个接口（从而具备了多个接口中的方法）\n3.一个接口可以有多种实现类\n4.也可以不需要接口直接使用类作为ADT ，既有ADT 定义也有ADT实现，实际中更倾向于使用接口来定义变量\n静态工厂方法\n设MyString是接口，FastMyString是实现MyString接口的类\n实现过程出现了问题：\n1.打破了抽象边界，接口定义中没有包含constructor，也无法保证所有实现类中都包含了同样名字的constructor。\n2.故而，客户端需要知道该接口的某个具体实现类的名字\n修改策略：使用静态工厂方法，可以避免使用具体实现类的名字\ndefault\n接口中的每个方法在所有类中都要实现；通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它；以增量式的为接口增加额外的功能而不破坏已实现的类\n三个关键字\nprivate：只能在声明类中访问\nprotected：可从声明类的子类(以及包内)访问\npublic：可以任意访问\n重写 Override\n重写是在运行时决定执行哪个方法\n使用final关键字的方法不能在子类中被重写\n重写的函数：完全同样的signature\n实际执行时调用哪个方法，\n运行时\n如果父类的一个对象被用来调用该方法，则父类中的版本将被执行;如果使用子类的对象来调用该方法，则执行子类中的版本\n父类型中的被重写函数体不为空：意味着对其大多数子类型来说，该方法\n是可以被直接复用的。\n对某些子类型来说，有特殊性，故重写父类型中的函数，实现自己的特殊\n如果父类型中的某个函数实现体为空，意味着其所有子类型都需要这个功能，但各有差异，没有共性，在每个子类中均需要重写。\n重写之后，利用super()复用了父类型中函数的功能，并对其进行了扩展\n子类的构造方法若要继承父类，则应该放在构造函数的第一步\n重载 Overrload\n重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型\n价值：方便client 调用，client 可用不同的参数列表，调用同样的函数\n重载是在编译阶段时决定要具体执行哪个方法，即静态检查时决定\n特点：\n1.不同的参数列表\n2.相同/不同的返回值类型\n3.相同/不同的public/private/protected\n4.可以声明异常\n5.可以在同一个类内重载，也可在子类中重载\n举例来说：定义如下的类\n若判断条件如下，会产生异常，原因是由于重载方法是在编译时检查，ah2此时还是Animal类型，所以应用的eat方法不应该传入参数\n以下两种声明方式就不会出错\n第一个调用Animal类中的方法\n第二个调用Horse类中的方法，传入参数\n另一个例子如下\nAnimal若是接口，则可以按照3的方式进行调用\n两者的区别与联系：\n泛型接口的实现方法\n1.泛型接口、非泛型实现类\n2.泛型接口、泛型实现类\n"
  },
  {
    "head": "软件构造笔记（六）---PPT第一讲",
    "paragraphs": [
      "多维度视图和质量目标",
      "多维度试图",
      "Build-time",
      "1.build-time\\moment\\code-level view",
      "2.build-time\\period\\code-level view",
      "3.build-time\\moment\\component-level view",
      "4.build-time\\period\\component-level view",
      "Run-time",
      "1.run-time\\moment\\code-level view",
      "2.run-time\\period\\code-level view",
      "3.run-time\\moment\\component-level view",
      "4.run-time\\period\\component-level view",
      "视图维度的转换",
      "质量目标",
      "外部质量因素",
      "内部质量因素",
      "两者关系",
      "多维度试图",
      "按阶段划分：构造时/运行时",
      "按动态性划分：时刻/阶段",
      "按构造对象的层次划分：代码/构件",
      "Build-time",
      "1.build-time\\moment\\code-level view",
      "1.词汇层面：Lexical-oriented source code",
      "2.语法层面：AST",
      "3.语义层面：Class Diagram",
      "2.build-time\\period\\code-level view",
      "Code churn：代码变化",
      "3.build-time\\moment\\component-level view",
      "Package\\File\\Static Linking\\Library",
      "4.build-time\\period\\component-level view",
      "Configuration Item(配置项)\\Version(版本)",
      "Run-time",
      "1.run-time\\moment\\code-level view",
      "Snapshot diagram代码快照图\\Memory Dump内存信息转储",
      "2.run-time\\period\\code-level view",
      "Execution stack trace执行跟踪：用日志方式记录程序执行的调用次序",
      "3.run-time\\moment\\component-level view",
      "Dynamic linking等",
      "4.run-time\\period\\component-level view",
      "Event log：事件日志",
      "视图维度的转换",
      "质量目标",
      "外部质量因素",
      "影响用户",
      "1.正确性：发现不正确、消除不正确",
      "2.健壮性：针对异常情况的处理",
      "3.可扩展性：对spec的修改是否足够容易",
      "4.可复用性：一次开发，多次使用",
      "5.兼容性：不同软件系统之间相互可容易的集成",
      "6.性能：与其他质量属性折中",
      "7.可移植性：软件在不同的技术环境之间移植",
      "8.易用性 ：容易学、安装、操作",
      "9.功能性",
      "10.及时性",
      "内部质量因素",
      "影响软件本身和它的开发者",
      "1.可读性 2.易理解性 3.清晰性 4.大小",
      "两者关系",
      "外部质量取决于内部质量"
    ],
    "sentences": [
      "多维度视图和质量目标",
      "多维度试图",
      "Build-time",
      "1.build-time\\moment\\code-level view",
      "2.build-time\\period\\code-level view",
      "3.build-time\\moment\\component-level view",
      "4.build-time\\period\\component-level view",
      "Run-time",
      "1.run-time\\moment\\code-level view",
      "2.run-time\\period\\code-level view",
      "3.run-time\\moment\\component-level view",
      "4.run-time\\period\\component-level view",
      "视图维度的转换",
      "质量目标",
      "外部质量因素",
      "内部质量因素",
      "两者关系",
      "多维度试图",
      "按阶段划分：构造时/运行时",
      "按动态性划分：时刻/阶段",
      "按构造对象的层次划分：代码/构件",
      "Build-time",
      "1.build-time\\moment\\code-level view",
      "1.词汇层面：Lexical-oriented source code",
      "2.语法层面：AST",
      "3.语义层面：Class Diagram",
      "2.build-time\\period\\code-level view",
      "Code churn：代码变化",
      "3.build-time\\moment\\component-level view",
      "Package\\File\\Static Linking\\Library",
      "4.build-time\\period\\component-level view",
      "Configuration Item(配置项)\\Version(版本)",
      "Run-time",
      "1.run-time\\moment\\code-level view",
      "Snapshot diagram代码快照图\\Memory Dump内存信息转储",
      "2.run-time\\period\\code-level view",
      "Execution stack trace执行跟踪：用日志方式记录程序执行的调用次序",
      "3.run-time\\moment\\component-level view",
      "Dynamic linking等",
      "4.run-time\\period\\component-level view",
      "Event log：事件日志",
      "视图维度的转换",
      "质量目标",
      "外部质量因素",
      "影响用户",
      "1.正确性：发现不正确、消除不正确",
      "2.健壮性：针对异常情况的处理",
      "3.可扩展性：对spec的修改是否足够容易",
      "4.可复用性：一次开发，多次使用",
      "5.兼容性：不同软件系统之间相互可容易的集成",
      "6.性能：与其他质量属性折中",
      "7.可移植性：软件在不同的技术环境之间移植",
      "8.易用性 ：容易学、安装、操作",
      "9.功能性",
      "10.及时性",
      "内部质量因素",
      "影响软件本身和它的开发者",
      "1.可读性 2.易理解性 3.清晰性 4.大小",
      "两者关系",
      "外部质量取决于内部质量"
    ],
    "codes": [],
    "date": "2021-06-28",
    "text": "多维度视图和质量目标\n多维度试图\nBuild-time\n1.build-time\\moment\\code-level view\n2.build-time\\period\\code-level view\n3.build-time\\moment\\component-level view\n4.build-time\\period\\component-level view\nRun-time\n1.run-time\\moment\\code-level view\n2.run-time\\period\\code-level view\n3.run-time\\moment\\component-level view\n4.run-time\\period\\component-level view\n视图维度的转换\n质量目标\n外部质量因素\n内部质量因素\n两者关系\n多维度试图\n按阶段划分：构造时/运行时\n按动态性划分：时刻/阶段\n按构造对象的层次划分：代码/构件\nBuild-time\n1.build-time\\moment\\code-level view\n1.词汇层面：Lexical-oriented source code\n2.语法层面：AST\n3.语义层面：Class Diagram\n2.build-time\\period\\code-level view\nCode churn：代码变化\n3.build-time\\moment\\component-level view\nPackage\\File\\Static Linking\\Library\n4.build-time\\period\\component-level view\nConfiguration Item(配置项)\\Version(版本)\nRun-time\n1.run-time\\moment\\code-level view\nSnapshot diagram代码快照图\\Memory Dump内存信息转储\n2.run-time\\period\\code-level view\nExecution stack trace执行跟踪：用日志方式记录程序执行的调用次序\n3.run-time\\moment\\component-level view\nDynamic linking等\n4.run-time\\period\\component-level view\nEvent log：事件日志\n视图维度的转换\n质量目标\n外部质量因素\n影响用户\n1.正确性：发现不正确、消除不正确\n2.健壮性：针对异常情况的处理\n3.可扩展性：对spec的修改是否足够容易\n4.可复用性：一次开发，多次使用\n5.兼容性：不同软件系统之间相互可容易的集成\n6.性能：与其他质量属性折中\n7.可移植性：软件在不同的技术环境之间移植\n8.易用性 ：容易学、安装、操作\n9.功能性\n10.及时性\n内部质量因素\n影响软件本身和它的开发者\n1.可读性 2.易理解性 3.清晰性 4.大小\n两者关系\n外部质量取决于内部质量\n"
  },
  {
    "head": "软件构造笔记（二）",
    "paragraphs": [
      "面向复用的软件构造技术",
      "一.复用基本概念",
      "（一）复用编程：",
      "（二）四类复用级别：",
      "二.LSP--Liskov Substitution Principle",
      "（一）内容：",
      "（二）协变：",
      "（三）逆变：",
      "三.Delegation",
      "一.复用基本概念",
      "（一）复用编程：",
      "1.programming for reuse 面向复用编程：开发出可复用的软件",
      "2.programming with reuse 基于复用编程：利用已有的可复用软件搭建应用系统",
      "（二）四类复用级别：",
      "1.源代码级别的复用",
      "2.模块级别的复用：类、抽象类、接口",
      "3.库级别的复用：API、包",
      "4.系统级别的复用：框架",
      "二.LSP–Liskov Substitution Principle",
      "（一）内容：",
      "1.前置条件不能强化",
      "2.后置条件不能弱化",
      "3.不变量要保持",
      "4.子类型方法参数：逆变",
      "5.子类型方法返回值：协变",
      "（二）协变：",
      "1.返回值类型：不变或变得更具体",
      "2.异常类型：不变或变得更具体",
      "3.举例：",
      "（1）返回值类型",
      "（2）异常值类型",
      "（三）逆变：",
      "1.参数类型：要相反的变化，要不变或越来越抽象",
      "2.举例：(会报错，目前Java把这种形式看作overload）",
      "三.Delegation",
      "1.委派：一个对象请求另一个对象的功能",
      "2.定义类时不用extends",
      "比如：private Graph graph = Graph.empty()",
      "3.使用条件：",
      "子类只需要复用父类中的一小部分方法",
      "4.建立delegation步骤：",
      "（1）永久保存delegation关系：List< Student > ls;",
      "（2）建立delegation关系：this.ls.add(s);",
      "（3）逐个delegate：通过for循环实现",
      "5.举例来讲："
    ],
    "sentences": [
      "面向复用的软件构造技术",
      "一.复用基本概念",
      "（一）复用编程：（二）四类复用级别：二.LSP--Liskov Substitution Principle",
      "（一）内容：（二）协变：（三）逆变：三.Delegation",
      "一.复用基本概念",
      "（一）复用编程：1.programming for reuse 面向复用编程：开发出可复用的软件",
      "2.programming with reuse 基于复用编程：利用已有的可复用软件搭建应用系统",
      "（二）四类复用级别：1.源代码级别的复用",
      "2.模块级别的复用：类、抽象类、接口",
      "3.库级别的复用：API、包",
      "4.系统级别的复用：框架",
      "二.LSP–Liskov Substitution Principle",
      "（一）内容：1.前置条件不能强化",
      "2.后置条件不能弱化",
      "3.不变量要保持",
      "4.子类型方法参数：逆变",
      "5.子类型方法返回值：协变",
      "（二）协变：1.返回值类型：不变或变得更具体",
      "2.异常类型：不变或变得更具体",
      "3.举例：（1）返回值类型",
      "（2）异常值类型",
      "（三）逆变：1.参数类型：要相反的变化，要不变或越来越抽象",
      "2.举例：(会报错",
      "目前Java把这种形式看作overload）",
      "三.Delegation",
      "1.委派：一个对象请求另一个对象的功能",
      "2.定义类时不用extends",
      "比如：private Graph graph = Graph.empty()",
      "3.使用条件：子类只需要复用父类中的一小部分方法",
      "4.建立delegation步骤：（1）永久保存delegation关系：List< Student > ls;（2）建立delegation关系：this.ls.add(s);（3）逐个delegate：通过for循环实现",
      "5.举例来讲："
    ],
    "codes": [
      "class T{  //父类\n\tObject a(){...}\n}\n\nclass S extends T{  //子类\n\t@Override\n\tString a(){...}\n}\n",
      "class T{  //父类\n\tvoid b throws Throwable{...}\n}\n\nclass S extends T{  //子类\n\t@Override\n\tvoid b throws IOException{...}\n}\n",
      "class T{  //父类\n\tvoid c(String s) {...}\n}\n\nclass S extends T{  //子类\n\t@Override\n\tvoid c(Object s) {...}\n}\n",
      "class Professor{\n\tList<Student> ls;\n\t\n\tvoid enroll(Student s) {\n\t\tthis.ls.add(s);\n\t}\n\tvoid evalute(){\n\t\tdouble score = 0;\n\t\tfor(Student s: ls)\n\t\t\tscore += s.evaluate(this);\n\t}\n}\n"
    ],
    "date": "2021-06-12",
    "text": "面向复用的软件构造技术\n一.复用基本概念\n（一）复用编程：\n（二）四类复用级别：\n二.LSP--Liskov Substitution Principle\n（一）内容：\n（二）协变：\n（三）逆变：\n三.Delegation\n一.复用基本概念\n（一）复用编程：\n1.programming for reuse 面向复用编程：开发出可复用的软件\n2.programming with reuse 基于复用编程：利用已有的可复用软件搭建应用系统\n（二）四类复用级别：\n1.源代码级别的复用\n2.模块级别的复用：类、抽象类、接口\n3.库级别的复用：API、包\n4.系统级别的复用：框架\n二.LSP–Liskov Substitution Principle\n（一）内容：\n1.前置条件不能强化\n2.后置条件不能弱化\n3.不变量要保持\n4.子类型方法参数：逆变\n5.子类型方法返回值：协变\n（二）协变：\n1.返回值类型：不变或变得更具体\n2.异常类型：不变或变得更具体\n3.举例：\n（1）返回值类型\n（2）异常值类型\n（三）逆变：\n1.参数类型：要相反的变化，要不变或越来越抽象\n2.举例：(会报错，目前Java把这种形式看作overload）\n三.Delegation\n1.委派：一个对象请求另一个对象的功能\n2.定义类时不用extends\n比如：private Graph graph = Graph.empty()\n3.使用条件：\n子类只需要复用父类中的一小部分方法\n4.建立delegation步骤：\n（1）永久保存delegation关系：List< Student > ls;\n（2）建立delegation关系：this.ls.add(s);\n（3）逐个delegate：通过for循环实现\n5.举例来讲：\n"
  },
  {
    "head": "工厂方法--笔记四",
    "paragraphs": [
      "工厂方法",
      "使用原因",
      "衣服工厂抽象类",
      "工厂定义了统一行为，具体类来实现具体行为",
      "调用代码",
      "使用原因",
      "当client不知道要创建哪个具体类的实例，或不想再client代码中指明要具体创建的实例时，用工厂方法。",
      "定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。",
      "小A要开两个工厂做衣服，分别做短袖和长袖",
      "衣服工厂抽象类",
      "工厂定义了统一行为，具体类来实现具体行为",
      "短袖实现类",
      "长袖实现类",
      "调用代码"
    ],
    "sentences": [
      "工厂方法",
      "使用原因",
      "衣服工厂抽象类",
      "工厂定义了统一行为，具体类来实现具体行为",
      "调用代码",
      "使用原因",
      "当client不知道要创建哪个具体类的实例",
      "或不想再client代码中指明要具体创建的实例时",
      "用工厂方法",
      "定义一个用于创建对象的接口",
      "让其子类来决定实例化哪一个类",
      "从而使一个类的实例化延迟到其子类",
      "小A要开两个工厂做衣服，分别做短袖和长袖",
      "衣服工厂抽象类",
      "工厂定义了统一行为，具体类来实现具体行为",
      "短袖实现类",
      "长袖实现类",
      "调用代码"
    ],
    "codes": [
      "public abstract class ClothesFactory(){\n\tpublic abstract Cloth makeClothes();\n}\n",
      "public class shortSleeveFactory extends ClothesFactory{\n\t@Override\n\tpublic Cloth makeClothes(){\n\t\treturn new shortSleeve();\n\t}\n}\n",
      "public class longSleeveFactory extends ClothesFactory{\n\t@Override\n\tpublic Cloth makeClothes{\n\t\treturn new longSleeve();\n\t}\n}\n",
      "public class Main{\n\tpublic static void main(String[] args){\n\t\t//短袖\n\t\tClothesFactory short = new shortSleeveFactory();\n\t\tshort.makeClothes.make();\n\t\t//长袖\n\t\tClothesFactory long = new longSleeveFactory();\n\t\tlong.makeClothes.make();\n"
    ],
    "date": "2021-06-21",
    "text": "工厂方法\n使用原因\n衣服工厂抽象类\n工厂定义了统一行为，具体类来实现具体行为\n调用代码\n使用原因\n当client不知道要创建哪个具体类的实例，或不想再client代码中指明要具体创建的实例时，用工厂方法。\n定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。\n小A要开两个工厂做衣服，分别做短袖和长袖\n衣服工厂抽象类\n工厂定义了统一行为，具体类来实现具体行为\n短袖实现类\n长袖实现类\n调用代码\n"
  },
  {
    "head": "软件构造笔记（三）",
    "paragraphs": [
      "判断ADT中的等价性",
      "一.引用等价性 ==",
      "二.对象等价性 equals",
      "前言：在很多场景下，需要判定两个对象是否“相等”，本文主要讨论==和equals的区别。",
      "一.引用等价性 ==",
      "对基本数据类型，使用==判定相等",
      "二.对象等价性 equals",
      "1.对对象类型，使用equals判定相等",
      "2.equals的实现：",
      "一般来说，这个equals的实现通常不是程序员所期待的，所以一般需要重写",
      "3.错误示例：",
      "d2是Duration类型，所以传入参数时实现的是Duration中的equals，即判断长度相等，所以结果为true；而o2是Object类型，所以传入参数时实现的是Object中的equals，即通过引用等价性进行判断，由于d1和o2是两个不同的对象，所以结果为false.",
      "！！原因是上面equals的实现并不是重写，而是重载，因为改变了参数的类型。",
      "4.重写equals的方法",
      "5.对于可变类型的等价性",
      "实现行为等价性即可，而且无需重写equals和hashcode两个函数"
    ],
    "sentences": [
      "判断ADT中的等价性",
      "一.引用等价性 ==",
      "二.对象等价性 equals",
      "前言：在很多场景下",
      "需要判定两个对象是否“相等”",
      "本文主要讨论==和equals的区别",
      "一.引用等价性 ==",
      "对基本数据类型，使用==判定相等",
      "二.对象等价性 equals",
      "1.对对象类型，使用equals判定相等",
      "2.equals的实现：一般来说",
      "这个equals的实现通常不是程序员所期待的",
      "所以一般需要重写",
      "3.错误示例：d2是Duration类型",
      "所以传入参数时实现的是Duration中的equals",
      "即判断长度相等",
      "所以结果为true；而o2是Object类型",
      "所以传入参数时实现的是Object中的equals",
      "即通过引用等价性进行判断",
      "由于d1和o2是两个不同的对象",
      "所以结果为false.！！原因是上面equals的实现并不是重写",
      "而是重载",
      "因为改变了参数的类型",
      "4.重写equals的方法",
      "5.对于可变类型的等价性",
      "实现行为等价性即可",
      "而且无需重写equals和hashcode两个函数"
    ],
    "codes": [
      "public class Object{\n\t...\n\tpublic boolean equals(Object that){\n\t\treturn this == that;  //在对象等价性的判断是用引用等价性实现的\n\t}\n}\n",
      "public class Duration{\n\t...\n\tpublic boolean equals(Duration that){\n\t\treturn this.getLength() == that.getLength()\n\t}\n}\n\nDuration d1 = new Duration(1, 2);\nDuration d2 = new Duration(1, 2);\nObject o2 = d2;\nd1.equals(d2);  //结果为true\nd1.equals(o2);  //结果为false\n",
      "@Override\npublic boolwan equals(Object that){\n\treturn that instanceof Duration && this.sameValue((Duration)that);\n}\nprivate boolean sameValue(Duration that){\n\treturn this.getLength == that.getLength();\n}\n"
    ],
    "date": "2021-06-21",
    "text": "判断ADT中的等价性\n一.引用等价性 ==\n二.对象等价性 equals\n前言：在很多场景下，需要判定两个对象是否“相等”，本文主要讨论==和equals的区别。\n一.引用等价性 ==\n对基本数据类型，使用==判定相等\n二.对象等价性 equals\n1.对对象类型，使用equals判定相等\n2.equals的实现：\n一般来说，这个equals的实现通常不是程序员所期待的，所以一般需要重写\n3.错误示例：\nd2是Duration类型，所以传入参数时实现的是Duration中的equals，即判断长度相等，所以结果为true；而o2是Object类型，所以传入参数时实现的是Object中的equals，即通过引用等价性进行判断，由于d1和o2是两个不同的对象，所以结果为false.\n！！原因是上面equals的实现并不是重写，而是重载，因为改变了参数的类型。\n4.重写equals的方法\n5.对于可变类型的等价性\n实现行为等价性即可，而且无需重写equals和hashcode两个函数\n"
  },
  {
    "head": "软件构造笔记（十三）---PPT第九讲",
    "paragraphs": [
      "面向复用的软件构造技术",
      "LSP原则-Liskov替换原则",
      "协变 Co-variance",
      "通配符",
      "逆变 Contra-variance",
      "Comparator< T>",
      "Comparable< T>",
      "Delegation 委派",
      "CRP",
      "委派的四种形式",
      "白盒框架",
      "黑盒框架",
      "LSP原则-Liskov替换原则",
      "一.基本内容（子类型多态）",
      "1.子类型可以增加方法，但不可删",
      "2.子类型需要实现抽象类型中的所有未实现方法",
      "3.子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance的参数",
      "4.子类型中重写的方法必须使用同样类型的参数或者符合contra-variance的参数",
      "5.子类型中重写的方法不能抛出额外的异常",
      "6.子类方法具有更强的不变量",
      "7.子类方法具有更弱的前置条件",
      "8.子类方法具有更强的后置条件",
      "二.实例",
      "1.具有更强的不变量",
      "2.更弱的前置条件和更强的后置条件",
      "3.不符合条件的方法，调用GraphicProgram中的scaleW方法可能会导致h不等于w，破坏表示不变性",
      "4.不兼容的spec：",
      "三.满足条件",
      "1.前置条件不能强化",
      "2.后置条件不能弱化",
      "3.不变量要保持",
      "4.子类型方法参数：逆变",
      "5.子类型方法的返回值：协变",
      "6.异常类型：协变",
      "协变 Co-variance",
      "父类型->子类型：越来越具体specific",
      "返回值类型：不变或变得更具体",
      "异常的类型：不变或变得更具体",
      "对于子类，更特定的类可能有更特定的返回类型",
      "为子类型的方法声明的每个异常都应该是为超类型的方法声明的某些异常的子类型。",
      "数组是协变的",
      "给定Java的子类型规则，T类型的数组[]可以包含T类型的元素或T的任何子类型。",
      "泛型不是协变的",
      "Box< Integer >不是Box< Number >的子类型，即使Integer是Number的子类型。",
      "给定两个具体类型A和B(例如，Number和Integer)，无论A和B是否相关，MyClass< A>与MyClass< B >没有关系。MyClass< A>和MyClass< B>的共同父类是Object。",
      "通配符",
      "一.使用通配符(?)指定无限制通配符类型，例如List< ?>",
      "二.如下情况通常使用通配符：",
      "1.编写一个可以使用Object类中提供的功能实现的方法。",
      "2.当代码在泛型类中使用不依赖于类型参数的方法时。例如,List.size或List.clear。",
      "实际上，Class< ?>之所以如此常用，是因为Class中的大多数方法不依赖于T。",
      "三.上下界",
      "1.低有界通配符< ? super A>",
      "List< Interger>只匹配Integer类型的列表",
      "List< ? super Integer>匹配Integer的超类型的任何类型的列表，如Integer、Number和Object。",
      "2.上有界通配符< ? extends A>",
      "总结来说",
      "逆变 Contra-variance",
      "父类型->子类型：越来越具体specific",
      "参数类型：要相反的变化，要不变或越来越抽象",
      "Comparator< T>",
      "若ADT需要比较大小，可实现Comparator接口并override compare()函数",
      "举例来说",
      "输出结果",
      "Comparable< T>",
      "另一种方法：让ADT实现Comparable接口，然后override compareTo()方法",
      "与Comparator的区别：不需要构建新的Comparator类，比较代码放在ADT内部。",
      "举例来说",
      "Delegation 委派",
      "委派/委托：一个对象请求另一个对象的功能",
      "与继承的区别",
      "继承:通过新操作或重写操作来扩展基类。",
      "委派:捕获一个操作并将其发送给另一个对象。",
      "如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现。",
      "一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。",
      "尽量用delegation代替inheritance",
      "CRP",
      "类应该通过它们的组合(通过包含实现所需功能的其他类的实例)来实现多态行为和代码重用，而不是从基类或父类继承。",
      "组合一个对象可以做什么(has_a或use_a)比扩展它是什么(is_a)要好。",
      "“委托” 发生在object 层面，而“继承”发生在class 层面",
      "举例：",
      "使用CRP原则实现",
      "使用接口实现公共的方法但不同的实现",
      "通过接口的组合定义行为的组合，从组合接口中派生具体类，在类中进行委派，可以通过委派实现对象实例和方法的调用",
      "委派的四种形式",
      "1.Dependency: 临时性的delegation",
      "使用类的最简单形式是调用它的方法;两个类之间的这种形式的关系称为“use -a”关系，在这种关系中，一个类利用另一个类，而没有实际将它作为属性合并。",
      "例如，它可以是一个参数，也可以在方法中本地使用。依赖关系:一个对象的实现需要其他对象(供应商)的临时关系。",
      "2.Association: 永久性的delegation",
      "关联:对象类之间的持久关系，允许一个对象实例导致另一个对象实例代表它执行一个操作。",
      "has_a:一个类有另一个类作为属性/实例变量-这种关系是结构性的，因为它指定了一种对象连接到另一种对象，而不代表行为。",
      "3.Composition: 更强的association，但难以变化",
      "组合是一种将简单对象或数据类型组合成更复杂的对象或数据类型的方法。is_part_of:一个类有另一个类作为属性/实例变量。",
      "4.Aggregation: 更弱的association，可动态变化",
      "聚合:对象存在于另一个对象之外，在另一个对象之外创建，因此它被作为参数传递给构造函数。",
      "白盒框架",
      "通过subclassing和overriding方法扩展",
      "1.允许每个非私有方法的扩展",
      "2.需要理解超类的实现",
      "3.一次只有一个扩展",
      "4.一起编译",
      "5.通常是所谓的开发框架",
      "黑盒框架",
      "通过委派和接口组合实现方法",
      "1.允许在接口中公开功能的扩展",
      "2.只需要了解接口",
      "3.多个插件",
      "4.经常提供更多的模块化",
      "5.独立的部署",
      "6.通常是所谓的终端用户框架，平台"
    ],
    "sentences": [
      "面向复用的软件构造技术",
      "LSP原则-Liskov替换原则",
      "协变 Co-variance",
      "通配符",
      "逆变 Contra-variance",
      "Comparator< T>",
      "Comparable< T>",
      "Delegation 委派",
      "CRP",
      "委派的四种形式",
      "白盒框架",
      "黑盒框架",
      "LSP原则-Liskov替换原则",
      "一.基本内容（子类型多态）",
      "1.子类型可以增加方法，但不可删",
      "2.子类型需要实现抽象类型中的所有未实现方法",
      "3.子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance的参数",
      "4.子类型中重写的方法必须使用同样类型的参数或者符合contra-variance的参数",
      "5.子类型中重写的方法不能抛出额外的异常",
      "6.子类方法具有更强的不变量",
      "7.子类方法具有更弱的前置条件",
      "8.子类方法具有更强的后置条件",
      "二.实例",
      "1.具有更强的不变量",
      "2.更弱的前置条件和更强的后置条件",
      "3.不符合条件的方法",
      "调用GraphicProgram中的scaleW方法可能会导致h不等于w",
      "破坏表示不变性",
      "4.不兼容的spec：三.满足条件",
      "1.前置条件不能强化",
      "2.后置条件不能弱化",
      "3.不变量要保持",
      "4.子类型方法参数：逆变",
      "5.子类型方法的返回值：协变",
      "6.异常类型：协变",
      "协变 Co-variance",
      "父类型->子类型：越来越具体specific",
      "返回值类型：不变或变得更具体",
      "异常的类型：不变或变得更具体",
      "对于子类，更特定的类可能有更特定的返回类型",
      "为子类型的方法声明的每个异常都应该是为超类型的方法声明的某些异常的子类型",
      "数组是协变的",
      "给定Java的子类型规则",
      "T类型的数组[]可以包含T类型的元素或T的任何子类型",
      "泛型不是协变的",
      "Box< Integer >不是Box< Number >的子类型",
      "即使Integer是Number的子类型",
      "给定两个具体类型A和B(例如",
      "Number和Integer)",
      "无论A和B是否相关",
      "MyClass< A>与MyClass< B >没有关系",
      "MyClass< A>和MyClass< B>的共同父类是Object",
      "通配符",
      "一.使用通配符(?)指定无限制通配符类型",
      "例如List< ?>",
      "二.如下情况通常使用通配符：1.编写一个可以使用Object类中提供的功能实现的方法",
      "2.当代码在泛型类中使用不依赖于类型参数的方法时",
      "例如,List.size或List.clear",
      "实际上",
      "Class< ?>之所以如此常用",
      "是因为Class中的大多数方法不依赖于T",
      "三.上下界",
      "1.低有界通配符< ? super A>",
      "List< Interger>只匹配Integer类型的列表",
      "List< ? super Integer>匹配Integer的超类型的任何类型的列表",
      "如Integer、Number和Object",
      "2.上有界通配符< ? extends A>",
      "总结来说",
      "逆变 Contra-variance",
      "父类型->子类型：越来越具体specific",
      "参数类型：要相反的变化，要不变或越来越抽象",
      "Comparator< T>",
      "若ADT需要比较大小",
      "可实现Comparator接口并override compare()函数",
      "举例来说",
      "输出结果",
      "Comparable< T>",
      "另一种方法：让ADT实现Comparable接口",
      "然后override compareTo()方法",
      "与Comparator的区别：不需要构建新的Comparator类",
      "比较代码放在ADT内部",
      "举例来说",
      "Delegation 委派",
      "委派/委托：一个对象请求另一个对象的功能",
      "与继承的区别",
      "继承:通过新操作或重写操作来扩展基类",
      "委派:捕获一个操作并将其发送给另一个对象",
      "如果子类只需要复用父类中的一小部分方法",
      "可以不需要使用继承",
      "而是通过委派机制来实现",
      "一个类不需要继承另一个类的全部方法",
      "通过委托机制调用部分方法",
      "从而避免大量无用的方法",
      "尽量用delegation代替inheritance",
      "CRP",
      "类应该通过它们的组合(通过包含实现所需功能的其他类的实例)来实现多态行为和代码重用",
      "而不是从基类或父类继承",
      "组合一个对象可以做什么(has_a或use_a)比扩展它是什么(is_a)要好",
      "“委托” 发生在object 层面",
      "而“继承”发生在class 层面",
      "举例：使用CRP原则实现",
      "使用接口实现公共的方法但不同的实现",
      "通过接口的组合定义行为的组合",
      "从组合接口中派生具体类",
      "在类中进行委派",
      "可以通过委派实现对象实例和方法的调用",
      "委派的四种形式",
      "1.Dependency: 临时性的delegation",
      "使用类的最简单形式是调用它的方法;两个类之间的这种形式的关系称为“use -a”关系",
      "在这种关系中",
      "一个类利用另一个类",
      "而没有实际将它作为属性合并",
      "例如，它可以是一个参数，也可以在方法中本地使用",
      "依赖关系:一个对象的实现需要其他对象(供应商)的临时关系",
      "2.Association: 永久性的delegation",
      "关联:对象类之间的持久关系",
      "允许一个对象实例导致另一个对象实例代表它执行一个操作",
      "has_a:一个类有另一个类作为属性/实例变量-这种关系是结构性的",
      "因为它指定了一种对象连接到另一种对象",
      "而不代表行为",
      "3.Composition: 更强的association",
      "但难以变化",
      "组合是一种将简单对象或数据类型组合成更复杂的对象或数据类型的方法",
      "is_part_of:一个类有另一个类作为属性/实例变量",
      "4.Aggregation: 更弱的association",
      "可动态变化",
      "聚合:对象存在于另一个对象之外",
      "在另一个对象之外创建",
      "因此它被作为参数传递给构造函数",
      "白盒框架",
      "通过subclassing和overriding方法扩展",
      "1.允许每个非私有方法的扩展",
      "2.需要理解超类的实现",
      "3.一次只有一个扩展",
      "4.一起编译",
      "5.通常是所谓的开发框架",
      "黑盒框架",
      "通过委派和接口组合实现方法",
      "1.允许在接口中公开功能的扩展",
      "2.只需要了解接口",
      "3.多个插件",
      "4.经常提供更多的模块化",
      "5.独立的部署",
      "6.通常是所谓的终端用户框架，平台"
    ],
    "codes": [
      "//首先实现一个Edge类\npublic class Edge {\n\tdouble weight;\n\t\n\tpublic Edge(double w) {\n\t\tweight = w;\n\t}\n\t\n\tpublic double getWeight() {\n\t\treturn weight;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"权重为\"+weight;\n\t}\n}\n\npublic static void main(String[] args) {\n\t\tList<Edge> list = new LinkedList<>();\n\t\tlist.add(new Edge(5.0));\n\t\tlist.add(new Edge(4.5));\n\t\tlist.add(new Edge(3.9));\n\t\tlist.add(new Edge(8.7));\n\t\t//使用Comparator接口进行比较\n\t\tCollections.sort(list, new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge o1, Edge o2) {\n\t\t\t\tif(o1.getWeight() > o2.getWeight()) return 1;\n\t\t\t\telse return -1;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(list);\n\t}\n",
      "// 实现Comparable接口，重写compareTo方法\npublic class Edge implements Comparable<Edge>{\n\tdouble weight;\n\t\n\tpublic Edge(double w) {\n\t\tweight = w;\n\t}\n\t\n\tpublic double getWeight() {\n\t\treturn weight;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"权重为\"+weight;\n\t}\n\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\tif(this.getWeight()>o.getWeight())  return 1;\n\t\telse return -1;\n\t}\n}\n\npublic static void main(String[] args) {\n\t\tEdge[] edge = new Edge[] {\n\t\t\tnew Edge(5.0),\n\t\t\tnew Edge(4.5),\n\t\t\tnew Edge(3.9),\n\t\t\tnew Edge(8.7)\n\t\t};\n\t\tArrays.sort(edge);  // 使用Arrays.sort()方法进行排序\n\t\tSystem.out.println(Arrays.toString(edge));\n\t}\n"
    ],
    "date": "2021-07-03",
    "text": "面向复用的软件构造技术\nLSP原则-Liskov替换原则\n协变 Co-variance\n通配符\n逆变 Contra-variance\nComparator< T>\nComparable< T>\nDelegation 委派\nCRP\n委派的四种形式\n白盒框架\n黑盒框架\nLSP原则-Liskov替换原则\n一.基本内容（子类型多态）\n1.子类型可以增加方法，但不可删\n2.子类型需要实现抽象类型中的所有未实现方法\n3.子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance的参数\n4.子类型中重写的方法必须使用同样类型的参数或者符合contra-variance的参数\n5.子类型中重写的方法不能抛出额外的异常\n6.子类方法具有更强的不变量\n7.子类方法具有更弱的前置条件\n8.子类方法具有更强的后置条件\n二.实例\n1.具有更强的不变量\n2.更弱的前置条件和更强的后置条件\n3.不符合条件的方法，调用GraphicProgram中的scaleW方法可能会导致h不等于w，破坏表示不变性\n4.不兼容的spec：\n三.满足条件\n1.前置条件不能强化\n2.后置条件不能弱化\n3.不变量要保持\n4.子类型方法参数：逆变\n5.子类型方法的返回值：协变\n6.异常类型：协变\n协变 Co-variance\n父类型->子类型：越来越具体specific\n返回值类型：不变或变得更具体\n异常的类型：不变或变得更具体\n对于子类，更特定的类可能有更特定的返回类型\n为子类型的方法声明的每个异常都应该是为超类型的方法声明的某些异常的子类型。\n数组是协变的\n给定Java的子类型规则，T类型的数组[]可以包含T类型的元素或T的任何子类型。\n泛型不是协变的\nBox< Integer >不是Box< Number >的子类型，即使Integer是Number的子类型。\n给定两个具体类型A和B(例如，Number和Integer)，无论A和B是否相关，MyClass< A>与MyClass< B >没有关系。MyClass< A>和MyClass< B>的共同父类是Object。\n通配符\n一.使用通配符(?)指定无限制通配符类型，例如List< ?>\n二.如下情况通常使用通配符：\n1.编写一个可以使用Object类中提供的功能实现的方法。\n2.当代码在泛型类中使用不依赖于类型参数的方法时。例如,List.size或List.clear。\n实际上，Class< ?>之所以如此常用，是因为Class中的大多数方法不依赖于T。\n三.上下界\n1.低有界通配符< ? super A>\nList< Interger>只匹配Integer类型的列表\nList< ? super Integer>匹配Integer的超类型的任何类型的列表，如Integer、Number和Object。\n2.上有界通配符< ? extends A>\n总结来说\n逆变 Contra-variance\n父类型->子类型：越来越具体specific\n参数类型：要相反的变化，要不变或越来越抽象\nComparator< T>\n若ADT需要比较大小，可实现Comparator接口并override compare()函数\n举例来说\n输出结果\nComparable< T>\n另一种方法：让ADT实现Comparable接口，然后override compareTo()方法\n与Comparator的区别：不需要构建新的Comparator类，比较代码放在ADT内部。\n举例来说\nDelegation 委派\n委派/委托：一个对象请求另一个对象的功能\n与继承的区别\n继承:通过新操作或重写操作来扩展基类。\n委派:捕获一个操作并将其发送给另一个对象。\n如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现。\n一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。\n尽量用delegation代替inheritance\nCRP\n类应该通过它们的组合(通过包含实现所需功能的其他类的实例)来实现多态行为和代码重用，而不是从基类或父类继承。\n组合一个对象可以做什么(has_a或use_a)比扩展它是什么(is_a)要好。\n“委托” 发生在object 层面，而“继承”发生在class 层面\n举例：\n使用CRP原则实现\n使用接口实现公共的方法但不同的实现\n通过接口的组合定义行为的组合，从组合接口中派生具体类，在类中进行委派，可以通过委派实现对象实例和方法的调用\n委派的四种形式\n1.Dependency: 临时性的delegation\n使用类的最简单形式是调用它的方法;两个类之间的这种形式的关系称为“use -a”关系，在这种关系中，一个类利用另一个类，而没有实际将它作为属性合并。\n例如，它可以是一个参数，也可以在方法中本地使用。依赖关系:一个对象的实现需要其他对象(供应商)的临时关系。\n2.Association: 永久性的delegation\n关联:对象类之间的持久关系，允许一个对象实例导致另一个对象实例代表它执行一个操作。\nhas_a:一个类有另一个类作为属性/实例变量-这种关系是结构性的，因为它指定了一种对象连接到另一种对象，而不代表行为。\n3.Composition: 更强的association，但难以变化\n组合是一种将简单对象或数据类型组合成更复杂的对象或数据类型的方法。is_part_of:一个类有另一个类作为属性/实例变量。\n4.Aggregation: 更弱的association，可动态变化\n聚合:对象存在于另一个对象之外，在另一个对象之外创建，因此它被作为参数传递给构造函数。\n白盒框架\n通过subclassing和overriding方法扩展\n1.允许每个非私有方法的扩展\n2.需要理解超类的实现\n3.一次只有一个扩展\n4.一起编译\n5.通常是所谓的开发框架\n黑盒框架\n通过委派和接口组合实现方法\n1.允许在接口中公开功能的扩展\n2.只需要了解接口\n3.多个插件\n4.经常提供更多的模块化\n5.独立的部署\n6.通常是所谓的终端用户框架，平台\n"
  },
  {
    "head": "软件构造笔记（一）",
    "paragraphs": [
      "笔记一",
      "Java基本知识",
      "一. String、StringBuilder、StringBuffer类",
      "二. Map类基本用法",
      "多维度视图和质量目标总结",
      "一.描述软件系统的三个维度",
      "二. AST",
      "三.质量属性",
      "Java基本知识",
      "一. String、StringBuilder、StringBuffer类",
      "运行速度：StringBuilder>StringBuffer>String",
      "原因：String是字符串常量，StringBuilder和StringBuffer是字符串变量，String对象一旦创建之后该对象是不可更改的，但后两者是可以更改的",
      "在本例中，首先在第8行创建一个String对象str赋值为\"abc\"，在第10行，JVM又创建了一个新的对象名为str，把原来的str值和\"de\"加起来赋值给新的str，原来的str就会被JVM垃圾回收机制给回收掉了。所以Java中String对象进行的操作实际上是一个",
      "不断创建新的对象并将旧的对象回收的一个过程",
      "，所以执行速度很慢。",
      "而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，若以速度比String快很多",
      "二. Map类基本用法",
      "Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。",
      "Map中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过建可以找对所对应的值。",
      "Collection中的集合称为单列集合，Map中的集合称为双列集合。",
      "Map集合遍历键值对方式",
      "迭代器",
      "进行遍历",
      "foreach",
      "进行遍历",
      "多维度视图和质量目标总结",
      "一.描述软件系统的三个维度",
      "By phases: build- and run-time views",
      "By dynamics: moment and period views",
      "二. AST",
      "Java source",
      "：首先，提供一些源代码进行解析。此源代码可以在项目中以Java文件的式提供，也可以直接以 char[]包含Java源代码的形式提供。",
      "Parse",
      "：解析在1处描述的源代码 。该步骤所需的全部由类提供 org.eclipse.jdt.core.dom.ASTParser。",
      "该抽象语法树是步骤2的结果",
      "。它是一个树模型，完全代表在步骤1中提供的源。如果需要，解析器还会计算并包括称为“绑定”的其他符号解析信息。",
      "Manipulating the AST",
      "：如果需要更改第3点的AST，可以通过两种方式完成：",
      "(1)通过直接修改AST。",
      "(2)通过在单独的协议中记录修改。",
      "Writing changes back",
      "：如果进行了更改，则需要将其应用于1提供的源代码。",
      "IDocument",
      "：是步骤1的源代码的包装， 在第5步需要",
      "三.质量属性",
      "External quality factors",
      "(1)Correctness: 按照预先定义的“规约”执行，是最重要的质量指标",
      "(2)Robustness: 针对异常情况的处理，出现规约定义之外的清醒的时候，软件要做出恰当的反应",
      "(3)Extendibility: 对软件的规约进行修改是否足够容易",
      "(4)Reusability: 是软件可用于构建许多不同应用程序的能力，一次开发，多次使用",
      "(5)Compatibility: 不同的软件系统之间相互可容易的集成",
      "(6)Efficiency: 软件的性能效率",
      "(7)Protability: 软件可方便的在不同的技术环境之间移植",
      "(8)Ease of use: 容易学、安装、操作、监控",
      "(9)Functionality: 系统提供可能性的范围",
      "(10)Timeliness: 指软件系统在用户使用时或使用之前是否能及时发布",
      "另外，还有很多其他的外部质量属性",
      "Internal quality factors",
      "(1)Readability",
      "(2)Understandability",
      "(3)Clearness",
      "(4)Size",
      "Five key quality objectives of software construction",
      "(1)Easy to understand: elegant and beautiful code / understandability",
      "(2) Ready for change: maintainability and adaptability",
      "(3) Cheap for develop: design for/with reuse: reusability",
      "(4) Safe from bugs: robustness – Efficient to run: performance",
      "参考文献",
      "https://www.cnblogs.com/weibanggang/p/9455926.html",
      "https://blog.csdn.net/qq_29373285/article/details/81487594",
      "https://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/index.html#bib-example-project"
    ],
    "sentences": [
      "笔记一",
      "Java基本知识",
      "一. String、StringBuilder、StringBuffer类",
      "二. Map类基本用法",
      "多维度视图和质量目标总结",
      "一.描述软件系统的三个维度",
      "二. AST",
      "三.质量属性",
      "Java基本知识",
      "一. String、StringBuilder、StringBuffer类",
      "运行速度：StringBuilder>StringBuffer>String",
      "原因：String是字符串常量",
      "StringBuilder和StringBuffer是字符串变量",
      "String对象一旦创建之后该对象是不可更改的",
      "但后两者是可以更改的",
      "在本例中",
      "首先在第8行创建一个String对象str赋值为\"abc\"",
      "在第10行",
      "JVM又创建了一个新的对象名为str",
      "把原来的str值和\"de\"加起来赋值给新的str",
      "原来的str就会被JVM垃圾回收机制给回收掉了",
      "所以Java中String对象进行的操作实际上是一个",
      "不断创建新的对象并将旧的对象回收的一个过程",
      "，所以执行速度很慢",
      "而StringBuilder和StringBuffer的对象是变量",
      "对变量进行操作就是直接对该对象进行更改",
      "而不进行创建和回收的操作",
      "若以速度比String快很多",
      "二. Map类基本用法",
      "Collection中的集合",
      "元素是孤立存在的",
      "向集合中存储元素采用一个个元素的方式存储",
      "Map中的集合",
      "元素是成对存在的",
      "每个元素由键与值两部分组成",
      "通过建可以找对所对应的值",
      "Collection中的集合称为单列集合",
      "Map中的集合称为双列集合",
      "Map集合遍历键值对方式",
      "迭代器",
      "进行遍历",
      "foreach",
      "进行遍历",
      "多维度视图和质量目标总结",
      "一.描述软件系统的三个维度",
      "By phases: build- and run-time views",
      "By dynamics: moment and period views",
      "二. AST",
      "Java source",
      "：首先，提供一些源代码进行解析",
      "此源代码可以在项目中以Java文件的式提供",
      "也可以直接以 char[]包含Java源代码的形式提供",
      "Parse",
      "：解析在1处描述的源代码 ",
      "该步骤所需的全部由类提供 org.eclipse.jdt.core.dom.ASTParser",
      "该抽象语法树是步骤2的结果",
      "它是一个树模型，完全代表在步骤1中提供的源",
      "如果需要，解析器还会计算并包括称为“绑定”的其他符号解析信息",
      "Manipulating the AST",
      "：如果需要更改第3点的AST",
      "可以通过两种方式完成：(1)通过直接修改AST",
      "(2)通过在单独的协议中记录修改",
      "Writing changes back",
      "：如果进行了更改，则需要将其应用于1提供的源代码",
      "IDocument",
      "：是步骤1的源代码的包装， 在第5步需要",
      "三.质量属性",
      "External quality factors",
      "(1)Correctness: 按照预先定义的“规约”执行",
      "是最重要的质量指标",
      "(2)Robustness: 针对异常情况的处理",
      "出现规约定义之外的清醒的时候",
      "软件要做出恰当的反应",
      "(3)Extendibility: 对软件的规约进行修改是否足够容易",
      "(4)Reusability: 是软件可用于构建许多不同应用程序的能力",
      "一次开发",
      "多次使用",
      "(5)Compatibility: 不同的软件系统之间相互可容易的集成",
      "(6)Efficiency: 软件的性能效率",
      "(7)Protability: 软件可方便的在不同的技术环境之间移植",
      "(8)Ease of use: 容易学、安装、操作、监控",
      "(9)Functionality: 系统提供可能性的范围",
      "(10)Timeliness: 指软件系统在用户使用时或使用之前是否能及时发布",
      "另外，还有很多其他的外部质量属性",
      "Internal quality factors",
      "(1)Readability",
      "(2)Understandability",
      "(3)Clearness",
      "(4)Size",
      "Five key quality objectives of software construction",
      "(1)Easy to understand: elegant and beautiful code / understandability",
      "(2) Ready for change: maintainability and adaptability",
      "(3) Cheap for develop: design for/with reuse: reusability",
      "(4) Safe from bugs: robustness – Efficient to run: performance",
      "参考文献",
      "https://www.cnblogs.com/weibanggang/p/9455926.html",
      "https://blog.csdn.net/qq_29373285/article/details/81487594",
      "https://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/index.html#bib-example-project"
    ],
    "codes": [
      "public class Welcome {\n\tpublic static void main(String[] args) {\n\t\tString str = \"abc\";\n\t\tSystem.out.println(str);\n\t\tstr = str + \"de\";\n\t\tSystem.out.println(str);\n\t}\n}\n",
      "public class Welcome {\n\tpublic static void main(String[] args) {\n\t\t// 创建map对象\n\t\tMap<String,String> map = new HashMap<>();\n\t\t// 向map对象中添加元素\n\t\tmap.put(\"age\", \"18\");\n\t\tmap.put(\"name\", \"Mary\");\n\t\tmap.put(\"hobby\", \"piano\");\n\t\t// 获取map中键元素\n\t\tSet<String> keySet = map.keySet();\n\t\t// 利用迭代器遍历元素\n\t\tIterator<String> it = keySet.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\t// 得到每一个key\n\t\t\tString key = it.next();\n\t\t\t// 得到每一个key对应的value\n\t\t\tString value = map.get(key);\n\t\t\tSystem.out.println(key+\"=\"+value);\n\t\t}\n\t}\n}\n",
      "public class Welcome {\n\tpublic static void main(String[] args) {\n\t\t// 创建map对象\n\t\tMap<String,String> map = new HashMap<>();\n\t\t// 向map对象中添加元素\n\t\tmap.put(\"age\", \"18\");\n\t\tmap.put(\"name\", \"Mary\");\n\t\tmap.put(\"hobby\", \"piano\");\n\t\t// 获取map中键元素\n\t\tSet<String> keySet = map.keySet();\n\t\t// 利用foreach进行遍历\n\t\tfor (String key : keySet) {\n\t\t\tString value = map.get(key);\n\t\t\tSystem.out.println(key+\"=\"+value);\n\t\t}\n\t}\n}\n",
      "By level: code and component views"
    ],
    "date": "2021-05-04",
    "text": "笔记一\nJava基本知识\n一. String、StringBuilder、StringBuffer类\n二. Map类基本用法\n多维度视图和质量目标总结\n一.描述软件系统的三个维度\n二. AST\n三.质量属性\nJava基本知识\n一. String、StringBuilder、StringBuffer类\n运行速度：StringBuilder>StringBuffer>String\n原因：String是字符串常量，StringBuilder和StringBuffer是字符串变量，String对象一旦创建之后该对象是不可更改的，但后两者是可以更改的\n在本例中，首先在第8行创建一个String对象str赋值为\"abc\"，在第10行，JVM又创建了一个新的对象名为str，把原来的str值和\"de\"加起来赋值给新的str，原来的str就会被JVM垃圾回收机制给回收掉了。所以Java中String对象进行的操作实际上是一个\n不断创建新的对象并将旧的对象回收的一个过程\n，所以执行速度很慢。\n而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，若以速度比String快很多\n二. Map类基本用法\nCollection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。\nMap中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过建可以找对所对应的值。\nCollection中的集合称为单列集合，Map中的集合称为双列集合。\nMap集合遍历键值对方式\n迭代器\n进行遍历\nforeach\n进行遍历\n多维度视图和质量目标总结\n一.描述软件系统的三个维度\nBy phases: build- and run-time views\nBy dynamics: moment and period views\n二. AST\nJava source\n：首先，提供一些源代码进行解析。此源代码可以在项目中以Java文件的式提供，也可以直接以 char[]包含Java源代码的形式提供。\nParse\n：解析在1处描述的源代码 。该步骤所需的全部由类提供 org.eclipse.jdt.core.dom.ASTParser。\n该抽象语法树是步骤2的结果\n。它是一个树模型，完全代表在步骤1中提供的源。如果需要，解析器还会计算并包括称为“绑定”的其他符号解析信息。\nManipulating the AST\n：如果需要更改第3点的AST，可以通过两种方式完成：\n(1)通过直接修改AST。\n(2)通过在单独的协议中记录修改。\nWriting changes back\n：如果进行了更改，则需要将其应用于1提供的源代码。\nIDocument\n：是步骤1的源代码的包装， 在第5步需要\n三.质量属性\nExternal quality factors\n(1)Correctness: 按照预先定义的“规约”执行，是最重要的质量指标\n(2)Robustness: 针对异常情况的处理，出现规约定义之外的清醒的时候，软件要做出恰当的反应\n(3)Extendibility: 对软件的规约进行修改是否足够容易\n(4)Reusability: 是软件可用于构建许多不同应用程序的能力，一次开发，多次使用\n(5)Compatibility: 不同的软件系统之间相互可容易的集成\n(6)Efficiency: 软件的性能效率\n(7)Protability: 软件可方便的在不同的技术环境之间移植\n(8)Ease of use: 容易学、安装、操作、监控\n(9)Functionality: 系统提供可能性的范围\n(10)Timeliness: 指软件系统在用户使用时或使用之前是否能及时发布\n另外，还有很多其他的外部质量属性\nInternal quality factors\n(1)Readability\n(2)Understandability\n(3)Clearness\n(4)Size\nFive key quality objectives of software construction\n(1)Easy to understand: elegant and beautiful code / understandability\n(2) Ready for change: maintainability and adaptability\n(3) Cheap for develop: design for/with reuse: reusability\n(4) Safe from bugs: robustness – Efficient to run: performance\n参考文献\nhttps://www.cnblogs.com/weibanggang/p/9455926.html\nhttps://blog.csdn.net/qq_29373285/article/details/81487594\nhttps://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/index.html#bib-example-project\n"
  },
  {
    "head": "软件构造笔记（八）---PPT第四讲",
    "paragraphs": [
      "数据类型与类型检查",
      "数据类型",
      "静态/动态类型检查",
      "静态类型检查",
      "动态类型检查",
      "两者关系",
      "可变/不变的数据类型",
      "不变的数据类型",
      "final",
      "String",
      "可变的数据类型",
      "StringBuilder",
      "解决可变类型不安全的方法",
      "Snapshot理解数据类型",
      "数据类型",
      "基本数据类型/对象数据类型",
      "静态/动态类型检查",
      "静态类型检查",
      "可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性。",
      "Java是静态类型语言，所有变量的类型在编译时(在程序运行之前)都是已知的，因此编译器也可以推导出所有表达式的类型。如果a和b被声明为int型，那么编译器得出a+b也是int型。",
      "比如，如果输入\"a\"*“b”，尝试将两个字符串相乘，然后静态类型检查将在编程时捕获此错误，而不是在执行期间等待到达该行。",
      "1.Syntax errors 语法错误",
      "2.Wrong names 类名/ 函数名错误：比如Math.sine(2)，正确的名字是sin",
      "3.Wrong number of arguments 参数数目错误，比如Math.sin(30, 20) .",
      "4.Wrong argument types 参数类型错误, like Math.sin(“30”) .",
      "5.Wrong return types 返回值类型错误, like return “30”，但是这个函数应该返回int",
      "动态类型检查",
      "1.Illegal argument values 非法的参数值：例如，整数表达式x/y只有在y实际上为零时才错误;否则它的工作原理。在这个表达式中，除以0不是静态误差，而是动态误差。",
      "2.Unrepresentable return values 非法的返回值：当特定的返回值不能在类型中表示时。",
      "3.Out-of-range indexes 越界：在字符串上使用负数或太大的索引。",
      "4.Calling a method on a null object reference. 空指针",
      "两者关系",
      "静态检查倾向于与变量的特定值无关的类型和错误有关。静态类型保证一个变量会有这个集合中的一些值，但是我们直到运行时才知道它的确切值。因此，如果错误只会由某些值引起，如除0或索引超出范围，那么编译器不会引发关于它的静态错误。",
      "相比之下，动态检查往往是关于特定值引起的错误。",
      "静态检查：关于“类型”的检查，不考虑值",
      "动态检查：关于“值”的检查",
      "可变/不变的数据类型",
      "改变一个变量：将该变量指向另一个值的存储空间",
      "改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。",
      "不变的数据类型",
      "不变对象：一旦被创建，始终指向同一个值/引用",
      "如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变",
      "final",
      "final int a = 5;",
      "1.final类无法派生子类",
      "2.final变量无法改变值/引用",
      "3.final方法无法被子类重写",
      "String",
      "缺点：使用不可变类型，对其频繁修改会产生大量的临时拷贝( 需要垃圾回收)",
      "优点：安全",
      "可变的数据类型",
      "可变对象：拥有方法可以修改自己的值/引用",
      "StringBuilder",
      "优点：可变类型最少化拷贝以提高效率",
      "缺点：不安全",
      "最后输出结果为",
      "因为可变类型导致list的值发生变化",
      "解决可变类型不安全的方法",
      "进行防御式拷贝",
      "Snapshot理解数据类型",
      "基本类型",
      "对象类型",
      "对象值是一个按其类型标记的圆。",
      "可变对象",
      "不可变对象：用双线椭圆",
      "String s = “a”;",
      "s = s + “b”;",
      "不可变的引用：用双线箭头"
    ],
    "sentences": [
      "数据类型与类型检查",
      "数据类型",
      "静态/动态类型检查",
      "静态类型检查",
      "动态类型检查",
      "两者关系",
      "可变/不变的数据类型",
      "不变的数据类型",
      "final",
      "String",
      "可变的数据类型",
      "StringBuilder",
      "解决可变类型不安全的方法",
      "Snapshot理解数据类型",
      "数据类型",
      "基本数据类型/对象数据类型",
      "静态/动态类型检查",
      "静态类型检查",
      "可在编译阶段发现错误",
      "避免了将错误带入到运行阶段",
      "可提高程序正确性/健壮性",
      "Java是静态类型语言",
      "所有变量的类型在编译时(在程序运行之前)都是已知的",
      "因此编译器也可以推导出所有表达式的类型",
      "如果a和b被声明为int型，那么编译器得出a+b也是int型",
      "比如",
      "如果输入\"a\"*“b”",
      "尝试将两个字符串相乘",
      "然后静态类型检查将在编程时捕获此错误",
      "而不是在执行期间等待到达该行",
      "1.Syntax errors 语法错误",
      "2.Wrong names 类名/ 函数名错误：比如Math.sine(2)",
      "正确的名字是sin",
      "3.Wrong number of arguments 参数数目错误",
      "比如Math.sin(30, 20) .4.Wrong argument types 参数类型错误, like Math.sin(“30”) .5.Wrong return types 返回值类型错误, like return “30”",
      "但是这个函数应该返回int",
      "动态类型检查",
      "1.Illegal argument values 非法的参数值：例如",
      "整数表达式x/y只有在y实际上为零时才错误;否则它的工作原理",
      "在这个表达式中，除以0不是静态误差，而是动态误差",
      "2.Unrepresentable return values 非法的返回值：当特定的返回值不能在类型中表示时",
      "3.Out-of-range indexes 越界：在字符串上使用负数或太大的索引",
      "4.Calling a method on a null object reference. 空指针",
      "两者关系",
      "静态检查倾向于与变量的特定值无关的类型和错误有关",
      "静态类型保证一个变量会有这个集合中的一些值",
      "但是我们直到运行时才知道它的确切值",
      "因此",
      "如果错误只会由某些值引起",
      "如除0或索引超出范围",
      "那么编译器不会引发关于它的静态错误",
      "相比之下，动态检查往往是关于特定值引起的错误",
      "静态检查：关于“类型”的检查，不考虑值",
      "动态检查：关于“值”的检查",
      "可变/不变的数据类型",
      "改变一个变量：将该变量指向另一个值的存储空间",
      "改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值",
      "不变的数据类型",
      "不变对象：一旦被创建，始终指向同一个值/引用",
      "如果是引用类型",
      "也可以是不变的：一旦确定其指向的对象",
      "不能再被改变",
      "final",
      "final int a = 5;1.final类无法派生子类",
      "2.final变量无法改变值/引用",
      "3.final方法无法被子类重写",
      "String",
      "缺点：使用不可变类型",
      "对其频繁修改会产生大量的临时拷贝( 需要垃圾回收)",
      "优点：安全",
      "可变的数据类型",
      "可变对象：拥有方法可以修改自己的值/引用",
      "StringBuilder",
      "优点：可变类型最少化拷贝以提高效率",
      "缺点：不安全",
      "最后输出结果为",
      "因为可变类型导致list的值发生变化",
      "解决可变类型不安全的方法",
      "进行防御式拷贝",
      "Snapshot理解数据类型",
      "基本类型",
      "对象类型",
      "对象值是一个按其类型标记的圆",
      "可变对象",
      "不可变对象：用双线椭圆",
      "String s = “a”;s = s + “b”;不可变的引用：用双线箭头"
    ],
    "codes": [
      "public static int sum(List<Integer> list) {\n\t\tint sum = 0;\n\t\tfor(int x: list) {\n\t\t\tsum += x;\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static int sumAbsolute(List<Integer> list) {\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tlist.set(i, Math.abs(list.get(i)));\n\t\t}\n\t\treturn sum(list);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tList<Integer> myData = Arrays.asList(-5, -3, -2);\n\t\tSystem.out.println(sumAbsolute(myData));\n\t\tSystem.out.println(sum(myData));\n\t}\n"
    ],
    "date": "2021-07-01",
    "text": "数据类型与类型检查\n数据类型\n静态/动态类型检查\n静态类型检查\n动态类型检查\n两者关系\n可变/不变的数据类型\n不变的数据类型\nfinal\nString\n可变的数据类型\nStringBuilder\n解决可变类型不安全的方法\nSnapshot理解数据类型\n数据类型\n基本数据类型/对象数据类型\n静态/动态类型检查\n静态类型检查\n可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性。\nJava是静态类型语言，所有变量的类型在编译时(在程序运行之前)都是已知的，因此编译器也可以推导出所有表达式的类型。如果a和b被声明为int型，那么编译器得出a+b也是int型。\n比如，如果输入\"a\"*“b”，尝试将两个字符串相乘，然后静态类型检查将在编程时捕获此错误，而不是在执行期间等待到达该行。\n1.Syntax errors 语法错误\n2.Wrong names 类名/ 函数名错误：比如Math.sine(2)，正确的名字是sin\n3.Wrong number of arguments 参数数目错误，比如Math.sin(30, 20) .\n4.Wrong argument types 参数类型错误, like Math.sin(“30”) .\n5.Wrong return types 返回值类型错误, like return “30”，但是这个函数应该返回int\n动态类型检查\n1.Illegal argument values 非法的参数值：例如，整数表达式x/y只有在y实际上为零时才错误;否则它的工作原理。在这个表达式中，除以0不是静态误差，而是动态误差。\n2.Unrepresentable return values 非法的返回值：当特定的返回值不能在类型中表示时。\n3.Out-of-range indexes 越界：在字符串上使用负数或太大的索引。\n4.Calling a method on a null object reference. 空指针\n两者关系\n静态检查倾向于与变量的特定值无关的类型和错误有关。静态类型保证一个变量会有这个集合中的一些值，但是我们直到运行时才知道它的确切值。因此，如果错误只会由某些值引起，如除0或索引超出范围，那么编译器不会引发关于它的静态错误。\n相比之下，动态检查往往是关于特定值引起的错误。\n静态检查：关于“类型”的检查，不考虑值\n动态检查：关于“值”的检查\n可变/不变的数据类型\n改变一个变量：将该变量指向另一个值的存储空间\n改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。\n不变的数据类型\n不变对象：一旦被创建，始终指向同一个值/引用\n如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变\nfinal\nfinal int a = 5;\n1.final类无法派生子类\n2.final变量无法改变值/引用\n3.final方法无法被子类重写\nString\n缺点：使用不可变类型，对其频繁修改会产生大量的临时拷贝( 需要垃圾回收)\n优点：安全\n可变的数据类型\n可变对象：拥有方法可以修改自己的值/引用\nStringBuilder\n优点：可变类型最少化拷贝以提高效率\n缺点：不安全\n最后输出结果为\n因为可变类型导致list的值发生变化\n解决可变类型不安全的方法\n进行防御式拷贝\nSnapshot理解数据类型\n基本类型\n对象类型\n对象值是一个按其类型标记的圆。\n可变对象\n不可变对象：用双线椭圆\nString s = “a”;\ns = s + “b”;\n不可变的引用：用双线箭头\n"
  },
  {
    "head": "软件构造笔记（十二）---PPT第八讲",
    "paragraphs": [
      "ADT和OOP中的等价性",
      "引用等价性",
      "对象等价性",
      "equals()函数",
      "hashcode()函数",
      "观察等价性",
      "行为等价性",
      "等价性的划分：",
      "不可变对象的引用等价性==和对象等价性equals()",
      "可变对象的观察等价性和行为等价性",
      "引用等价性",
      "== 操作符比较引用。",
      "它测试引用相等。两个引用是 == 如果它们指向内存中的相同存储。在快照图中，如果两个引用的箭头指向同一个对象气泡，则它们为==。",
      "== 对基本数据类型，使用== 判定相等",
      "对象等价性",
      "equals()函数",
      "equals()操作比较对象内容——换句话说，对象相等。",
      "对对象类型，使用equals()",
      "正常的equals()方法：在Object 中实现的缺省equals() 是在判断引用等价性，所以应该重写equals()方法",
      "错误重写：这是",
      "Overload",
      "，不是重写",
      "正确重写：",
      "一个更好的方法去实现equals()",
      "hashcode()函数",
      "等价的对象必须有相同的hashCode",
      "根据上面描述的Duration类，在修改equals()函数之后，d1.equals(d2)=true，但是输出hashCode()的值发现两者的哈希值不同",
      "修改方法：为对象的每个组件计算一个散列代码，用于确定是否相等(通常通过调用每个组件的hashCode方法)，然后组合这些散列代码，并进行一些算术操作。",
      "对于Duration，这很容易，因为类的抽象值已经是一个整数值:",
      "观察等价性",
      "当不能通过不改变对象状态的观察来区分它们时，也就是说，只调用observer、producer和creator方法。这通常被严格地称为观察等价性，因为它测试两个对象在程序的当前状态下是否“看起来”相同。",
      "观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致",
      "对可变类型来说，往往倾向于实现严格的观察等价性",
      "实现观察等价性的缺陷：",
      "行为等价性",
      "当它们不能通过任何观察来区分时，甚至状态也会改变。这种解释允许调用两个对象上的任何方法，包括mutators。这被称为行为平等，因为它测试两个物体在当前状态和所有未来状态下是否会“表现”相同。",
      "行为等价性：调用对象的任何方法都展示出一致的结果",
      "对可变类型，实现行为等价性即可",
      "。也就是说，只有指向同样内存空间的objects，才是相等的。所以对可变类型来说，无需重写equals() and hashCode()这两个函数，直接继承Object 的两个方法即可。如果一定要判断两个可变对象看起来是否一致，最好定义一个新的方法。",
      "1.对于不可变对象：",
      "equals()应该比较抽象值。这就相当于说equals()应该提供行为平等。",
      "hashCode()应该将抽象值映射为整数。",
      "所以，不可变类型必须重写equals()和hashcode()函数",
      "2.对于可变对象：",
      "equals()应该比较引用，就像==一样。同样，这就相当于说equals()应该提供行为平等。",
      "hashCode()应该将引用映射为一个整数。",
      "所以，可变类型不需要重写equals()和hashcode()函数"
    ],
    "sentences": [
      "ADT和OOP中的等价性",
      "引用等价性",
      "对象等价性",
      "equals()函数",
      "hashcode()函数",
      "观察等价性",
      "行为等价性",
      "等价性的划分：不可变对象的引用等价性==和对象等价性equals()",
      "可变对象的观察等价性和行为等价性",
      "引用等价性",
      "== 操作符比较引用",
      "它测试引用相等",
      "两个引用是 == 如果它们指向内存中的相同存储",
      "在快照图中",
      "如果两个引用的箭头指向同一个对象气泡",
      "则它们为==",
      "== 对基本数据类型，使用== 判定相等",
      "对象等价性",
      "equals()函数",
      "equals()操作比较对象内容——换句话说，对象相等",
      "对对象类型，使用equals()",
      "正常的equals()方法：在Object 中实现的缺省equals() 是在判断引用等价性",
      "所以应该重写equals()方法",
      "错误重写：这是",
      "Overload",
      "，不是重写",
      "正确重写：一个更好的方法去实现equals()",
      "hashcode()函数",
      "等价的对象必须有相同的hashCode",
      "根据上面描述的Duration类",
      "在修改equals()函数之后",
      "d1.equals(d2)=true",
      "但是输出hashCode()的值发现两者的哈希值不同",
      "修改方法：为对象的每个组件计算一个散列代码",
      "用于确定是否相等(通常通过调用每个组件的hashCode方法)",
      "然后组合这些散列代码",
      "并进行一些算术操作",
      "对于Duration",
      "这很容易",
      "因为类的抽象值已经是一个整数值:观察等价性",
      "当不能通过不改变对象状态的观察来区分它们时",
      "也就是说",
      "只调用observer、producer和creator方法",
      "这通常被严格地称为观察等价性",
      "因为它测试两个对象在程序的当前状态下是否“看起来”相同",
      "观察等价性：在不改变状态的情况下",
      "两个mutable对象是否看起来一致",
      "对可变类型来说，往往倾向于实现严格的观察等价性",
      "实现观察等价性的缺陷：行为等价性",
      "当它们不能通过任何观察来区分时，甚至状态也会改变",
      "这种解释允许调用两个对象上的任何方法，包括mutators",
      "这被称为行为平等",
      "因为它测试两个物体在当前状态和所有未来状态下是否会“表现”相同",
      "行为等价性：调用对象的任何方法都展示出一致的结果",
      "对可变类型，实现行为等价性即可",
      "也就是说，只有指向同样内存空间的objects，才是相等的",
      "所以对可变类型来说",
      "无需重写equals() and hashCode()这两个函数",
      "直接继承Object 的两个方法即可",
      "如果一定要判断两个可变对象看起来是否一致",
      "最好定义一个新的方法",
      "1.对于不可变对象：equals()应该比较抽象值",
      "这就相当于说equals()应该提供行为平等",
      "hashCode()应该将抽象值映射为整数",
      "所以",
      "不可变类型必须重写equals()和hashcode()函数",
      "2.对于可变对象：equals()应该比较引用，就像==一样",
      "同样，这就相当于说equals()应该提供行为平等",
      "hashCode()应该将引用映射为一个整数",
      "所以",
      "可变类型不需要重写equals()和hashcode()函数"
    ],
    "codes": [],
    "date": "2021-07-02",
    "text": "ADT和OOP中的等价性\n引用等价性\n对象等价性\nequals()函数\nhashcode()函数\n观察等价性\n行为等价性\n等价性的划分：\n不可变对象的引用等价性==和对象等价性equals()\n可变对象的观察等价性和行为等价性\n引用等价性\n== 操作符比较引用。\n它测试引用相等。两个引用是 == 如果它们指向内存中的相同存储。在快照图中，如果两个引用的箭头指向同一个对象气泡，则它们为==。\n== 对基本数据类型，使用== 判定相等\n对象等价性\nequals()函数\nequals()操作比较对象内容——换句话说，对象相等。\n对对象类型，使用equals()\n正常的equals()方法：在Object 中实现的缺省equals() 是在判断引用等价性，所以应该重写equals()方法\n错误重写：这是\nOverload\n，不是重写\n正确重写：\n一个更好的方法去实现equals()\nhashcode()函数\n等价的对象必须有相同的hashCode\n根据上面描述的Duration类，在修改equals()函数之后，d1.equals(d2)=true，但是输出hashCode()的值发现两者的哈希值不同\n修改方法：为对象的每个组件计算一个散列代码，用于确定是否相等(通常通过调用每个组件的hashCode方法)，然后组合这些散列代码，并进行一些算术操作。\n对于Duration，这很容易，因为类的抽象值已经是一个整数值:\n观察等价性\n当不能通过不改变对象状态的观察来区分它们时，也就是说，只调用observer、producer和creator方法。这通常被严格地称为观察等价性，因为它测试两个对象在程序的当前状态下是否“看起来”相同。\n观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致\n对可变类型来说，往往倾向于实现严格的观察等价性\n实现观察等价性的缺陷：\n行为等价性\n当它们不能通过任何观察来区分时，甚至状态也会改变。这种解释允许调用两个对象上的任何方法，包括mutators。这被称为行为平等，因为它测试两个物体在当前状态和所有未来状态下是否会“表现”相同。\n行为等价性：调用对象的任何方法都展示出一致的结果\n对可变类型，实现行为等价性即可\n。也就是说，只有指向同样内存空间的objects，才是相等的。所以对可变类型来说，无需重写equals() and hashCode()这两个函数，直接继承Object 的两个方法即可。如果一定要判断两个可变对象看起来是否一致，最好定义一个新的方法。\n1.对于不可变对象：\nequals()应该比较抽象值。这就相当于说equals()应该提供行为平等。\nhashCode()应该将抽象值映射为整数。\n所以，不可变类型必须重写equals()和hashcode()函数\n2.对于可变对象：\nequals()应该比较引用，就像==一样。同样，这就相当于说equals()应该提供行为平等。\nhashCode()应该将引用映射为一个整数。\n所以，可变类型不需要重写equals()和hashcode()函数\n"
  },
  {
    "head": "软件构造笔记（十）---PPT第六讲",
    "paragraphs": [
      "抽象数据类型ADT",
      "ADT操作的四种类型",
      "Creator 构造器",
      "Producer 生产器",
      "Observer 观察器",
      "Mutator 变值器",
      "测试四种类型",
      "ADT特性",
      "表示独立性 Representation Independence",
      "不变量 Invariants",
      "AF和RI",
      "两个空间",
      "抽象函数AF",
      "表示不变量RI",
      "抽象类型：强调“作用于数据上的操作”，程序员和client无需关心数据如何具体存储的，只需设计/使用操作即可。",
      "可变类型的对象：提供了可改变其内部数据的值的操作",
      "不变数据类型： 其操作不改变内部值，而是构造新的对象",
      "ADT操作的四种类型",
      "Creator 构造器",
      "1.构造器创建该类型的新对象。",
      "2.构造器可以接受一个对象作为参数，但不能接受正在构造的类型的对象。",
      "3.可能实现为构造函数或静态函数",
      "Producer 生产器",
      "生产器从该类型的旧对象创建新对象",
      "例如，String的concat()方法是一个生成器:它接受两个字符串并生成一个表示它们的连接的新字符串。",
      "Observer 观察器",
      "观察器接受抽象类型的对象并返回不同类型的对象。",
      "例如，List的size()方法返回一个int。",
      "Mutator 变值器",
      "1.变值器是改变对象属性的方法",
      "例如，List的add()方法通过在列表的末尾添加一个元素来改变列表。",
      "2.变值器通常返回void， 如果返回值为void，则必然意味着它改变了对象的某些内部状态；变值器也可能返回非空类型",
      "测试四种类型",
      "1.测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；",
      "2.测试observers：调用creators, producers, and mutators等方法产生或",
      "改变对象，来看结果是否正确。",
      "ADT特性",
      "表示独立性 Representation Independence",
      "client使用ADT 时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。",
      "例如，List提供的操作与列表是作为链表还是以数组表示无关。",
      "违反表示独立性的例子：函数直接调用内部rep的方法进行实现，也就是只有知道内部实现才能进行如下调用，所以破坏了独立性",
      "下图中能看出右边修改后的例子调用getMembers()函数，调用的方法是返回值List的get方法，而不是内部实现的set的方法。换句话说，外部实现只需要关注外部已知的内容，而不需要关注内部的实现，保持了很好的独立性",
      "不变量 Invariants",
      "由ADT来负责其不变量，与client端的任何行为无关",
      "为什么需要表示不变量？",
      "举例来说",
      "这是一个不可变的ADT，但由于字段都定义为public，既可以被外部访问，所以客户端可以直接对字段进行操作，对安全性有威胁。",
      "这被称为表示泄露representation exposure：这意味着类之外的代码可以直接修改字段。不仅影响不变性，也影响了表示独立性：无法在不影响客户端的情况下改变其内部表示",
      "首先进行第一步修改，将字段修饰为private final",
      "private和public关键字指示哪些字段和方法只能在类内部访问，哪些字段和方法可以从类外部访问。",
      "final关键字还有助于保证该不可变类型的字段在对象构造后不会被重新赋值。",
      "但是还是存在一些问题，retweetLater应该返回另一条信息，但却是一个小时之后才返回，所以Tweet的不变性被破坏了，原因是该方法泄露了对可变对象的引用。",
      "解决方法：进行防御式拷贝",
      "另外一个例子",
      "这个代码会导致date都为23",
      "因为Date()是可变类型，在每次调用时，Tweet都指向相同的Date()对象",
      "解决方法：防御式拷贝",
      "注意：通常，应该仔细检查所有ADT操作的参数类型和返回类型。如果任何类型是可变的，请确保不会返回对其表示的直接引用。因为这样做会造成表示泄露。",
      "AF和RI",
      "表示不变量Rep Invariant和抽象函数 Abstraction Function",
      "两个空间",
      "表示值(代表值)的空间由实际实现实体的值组成。",
      "抽象值构成的空间：client看到和使用的值。",
      "ADT开发者关注表示空间R，client关注抽象空间A",
      "抽象函数AF",
      "抽象函数：R和A之间映射关系的函数，即如何去解释R中的每一个值为A中的每一个值。关系：AF: R->A",
      "R中的部分值并非合法的，在A中无映射值",
      "1.每个抽象值都被一些代表值映射到（满射）",
      "2.一些抽象值被多个代表值映射到（未必单射）",
      "3.并不是所有的rep值都被映射（未必双射）",
      "表示不变量RI",
      "RI: R -> boolean",
      "表示不变性RI ：某个具体的“表示”是否是“合法的”",
      "也可将RI 看作：所有表示值的一个子集，包含了所有合法的表示值",
      "也可将RI 看作：一个条件，描述了什么是“合法”的表示值",
      "下图是AF和RI的书写",
      "选择某种特定的表示方式R，进而指定某个子集是“合法”的(RI)，并为该子集中的每个值做出“解释”(AF)——即如何映射到抽象空间中的值。",
      "设计ADT：",
      "(1) 选择R和A；",
      "(2) RI — 合法的表示值；",
      "(3) 如何解释合法的表示值 —映射AF",
      "做出具体的解释：每个rep value如何映射到abstract value"
    ],
    "sentences": [
      "抽象数据类型ADT",
      "ADT操作的四种类型",
      "Creator 构造器",
      "Producer 生产器",
      "Observer 观察器",
      "Mutator 变值器",
      "测试四种类型",
      "ADT特性",
      "表示独立性 Representation Independence",
      "不变量 Invariants",
      "AF和RI",
      "两个空间",
      "抽象函数AF",
      "表示不变量RI",
      "抽象类型：强调“作用于数据上的操作”",
      "程序员和client无需关心数据如何具体存储的",
      "只需设计/使用操作即可",
      "可变类型的对象：提供了可改变其内部数据的值的操作",
      "不变数据类型： 其操作不改变内部值，而是构造新的对象",
      "ADT操作的四种类型",
      "Creator 构造器",
      "1.构造器创建该类型的新对象",
      "2.构造器可以接受一个对象作为参数",
      "但不能接受正在构造的类型的对象",
      "3.可能实现为构造函数或静态函数",
      "Producer 生产器",
      "生产器从该类型的旧对象创建新对象",
      "例如",
      "String的concat()方法是一个生成器:它接受两个字符串并生成一个表示它们的连接的新字符串",
      "Observer 观察器",
      "观察器接受抽象类型的对象并返回不同类型的对象",
      "例如，List的size()方法返回一个int",
      "Mutator 变值器",
      "1.变值器是改变对象属性的方法",
      "例如",
      "List的add()方法通过在列表的末尾添加一个元素来改变列表",
      "2.变值器通常返回void",
      " 如果返回值为void",
      "则必然意味着它改变了对象的某些内部状态；变值器也可能返回非空类型",
      "测试四种类型",
      "1.测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；2.测试observers：调用creators, producers, and mutators等方法产生或",
      "改变对象，来看结果是否正确",
      "ADT特性",
      "表示独立性 Representation Independence",
      "client使用ADT 时无需考虑其内部如何实现",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "例如，List提供的操作与列表是作为链表还是以数组表示无关",
      "违反表示独立性的例子：函数直接调用内部rep的方法进行实现",
      "也就是只有知道内部实现才能进行如下调用",
      "所以破坏了独立性",
      "下图中能看出右边修改后的例子调用getMembers()函数",
      "调用的方法是返回值List的get方法",
      "而不是内部实现的set的方法",
      "换句话说",
      "外部实现只需要关注外部已知的内容",
      "而不需要关注内部的实现",
      "保持了很好的独立性",
      "不变量 Invariants",
      "由ADT来负责其不变量，与client端的任何行为无关",
      "为什么需要表示不变量？",
      "举例来说",
      "这是一个不可变的ADT",
      "但由于字段都定义为public",
      "既可以被外部访问",
      "所以客户端可以直接对字段进行操作",
      "对安全性有威胁",
      "这被称为表示泄露representation exposure：这意味着类之外的代码可以直接修改字段",
      "不仅影响不变性",
      "也影响了表示独立性：无法在不影响客户端的情况下改变其内部表示",
      "首先进行第一步修改，将字段修饰为private final",
      "private和public关键字指示哪些字段和方法只能在类内部访问",
      "哪些字段和方法可以从类外部访问",
      "final关键字还有助于保证该不可变类型的字段在对象构造后不会被重新赋值",
      "但是还是存在一些问题",
      "retweetLater应该返回另一条信息",
      "但却是一个小时之后才返回",
      "所以Tweet的不变性被破坏了",
      "原因是该方法泄露了对可变对象的引用",
      "解决方法：进行防御式拷贝",
      "另外一个例子",
      "这个代码会导致date都为23",
      "因为Date()是可变类型",
      "在每次调用时",
      "Tweet都指向相同的Date()对象",
      "解决方法：防御式拷贝",
      "注意：通常，应该仔细检查所有ADT操作的参数类型和返回类型",
      "如果任何类型是可变的，请确保不会返回对其表示的直接引用",
      "因为这样做会造成表示泄露",
      "AF和RI",
      "表示不变量Rep Invariant和抽象函数 Abstraction Function",
      "两个空间",
      "表示值(代表值)的空间由实际实现实体的值组成",
      "抽象值构成的空间：client看到和使用的值",
      "ADT开发者关注表示空间R，client关注抽象空间A",
      "抽象函数AF",
      "抽象函数：R和A之间映射关系的函数",
      "即如何去解释R中的每一个值为A中的每一个值",
      "关系：AF: R->A",
      "R中的部分值并非合法的，在A中无映射值",
      "1.每个抽象值都被一些代表值映射到（满射）",
      "2.一些抽象值被多个代表值映射到（未必单射）",
      "3.并不是所有的rep值都被映射（未必双射）",
      "表示不变量RI",
      "RI: R -> boolean",
      "表示不变性RI ：某个具体的“表示”是否是“合法的”",
      "也可将RI 看作：所有表示值的一个子集",
      "包含了所有合法的表示值",
      "也可将RI 看作：一个条件，描述了什么是“合法”的表示值",
      "下图是AF和RI的书写",
      "选择某种特定的表示方式R",
      "进而指定某个子集是“合法”的(RI)",
      "并为该子集中的每个值做出“解释”(AF)——即如何映射到抽象空间中的值",
      "设计ADT：(1) 选择R和A；(2) RI — 合法的表示值；(3) 如何解释合法的表示值 —映射AF",
      "做出具体的解释：每个rep value如何映射到abstract value"
    ],
    "codes": [],
    "date": "2021-07-01",
    "text": "抽象数据类型ADT\nADT操作的四种类型\nCreator 构造器\nProducer 生产器\nObserver 观察器\nMutator 变值器\n测试四种类型\nADT特性\n表示独立性 Representation Independence\n不变量 Invariants\nAF和RI\n两个空间\n抽象函数AF\n表示不变量RI\n抽象类型：强调“作用于数据上的操作”，程序员和client无需关心数据如何具体存储的，只需设计/使用操作即可。\n可变类型的对象：提供了可改变其内部数据的值的操作\n不变数据类型： 其操作不改变内部值，而是构造新的对象\nADT操作的四种类型\nCreator 构造器\n1.构造器创建该类型的新对象。\n2.构造器可以接受一个对象作为参数，但不能接受正在构造的类型的对象。\n3.可能实现为构造函数或静态函数\nProducer 生产器\n生产器从该类型的旧对象创建新对象\n例如，String的concat()方法是一个生成器:它接受两个字符串并生成一个表示它们的连接的新字符串。\nObserver 观察器\n观察器接受抽象类型的对象并返回不同类型的对象。\n例如，List的size()方法返回一个int。\nMutator 变值器\n1.变值器是改变对象属性的方法\n例如，List的add()方法通过在列表的末尾添加一个元素来改变列表。\n2.变值器通常返回void， 如果返回值为void，则必然意味着它改变了对象的某些内部状态；变值器也可能返回非空类型\n测试四种类型\n1.测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；\n2.测试observers：调用creators, producers, and mutators等方法产生或\n改变对象，来看结果是否正确。\nADT特性\n表示独立性 Representation Independence\nclient使用ADT 时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。\n例如，List提供的操作与列表是作为链表还是以数组表示无关。\n违反表示独立性的例子：函数直接调用内部rep的方法进行实现，也就是只有知道内部实现才能进行如下调用，所以破坏了独立性\n下图中能看出右边修改后的例子调用getMembers()函数，调用的方法是返回值List的get方法，而不是内部实现的set的方法。换句话说，外部实现只需要关注外部已知的内容，而不需要关注内部的实现，保持了很好的独立性\n不变量 Invariants\n由ADT来负责其不变量，与client端的任何行为无关\n为什么需要表示不变量？\n举例来说\n这是一个不可变的ADT，但由于字段都定义为public，既可以被外部访问，所以客户端可以直接对字段进行操作，对安全性有威胁。\n这被称为表示泄露representation exposure：这意味着类之外的代码可以直接修改字段。不仅影响不变性，也影响了表示独立性：无法在不影响客户端的情况下改变其内部表示\n首先进行第一步修改，将字段修饰为private final\nprivate和public关键字指示哪些字段和方法只能在类内部访问，哪些字段和方法可以从类外部访问。\nfinal关键字还有助于保证该不可变类型的字段在对象构造后不会被重新赋值。\n但是还是存在一些问题，retweetLater应该返回另一条信息，但却是一个小时之后才返回，所以Tweet的不变性被破坏了，原因是该方法泄露了对可变对象的引用。\n解决方法：进行防御式拷贝\n另外一个例子\n这个代码会导致date都为23\n因为Date()是可变类型，在每次调用时，Tweet都指向相同的Date()对象\n解决方法：防御式拷贝\n注意：通常，应该仔细检查所有ADT操作的参数类型和返回类型。如果任何类型是可变的，请确保不会返回对其表示的直接引用。因为这样做会造成表示泄露。\nAF和RI\n表示不变量Rep Invariant和抽象函数 Abstraction Function\n两个空间\n表示值(代表值)的空间由实际实现实体的值组成。\n抽象值构成的空间：client看到和使用的值。\nADT开发者关注表示空间R，client关注抽象空间A\n抽象函数AF\n抽象函数：R和A之间映射关系的函数，即如何去解释R中的每一个值为A中的每一个值。关系：AF: R->A\nR中的部分值并非合法的，在A中无映射值\n1.每个抽象值都被一些代表值映射到（满射）\n2.一些抽象值被多个代表值映射到（未必单射）\n3.并不是所有的rep值都被映射（未必双射）\n表示不变量RI\nRI: R -> boolean\n表示不变性RI ：某个具体的“表示”是否是“合法的”\n也可将RI 看作：所有表示值的一个子集，包含了所有合法的表示值\n也可将RI 看作：一个条件，描述了什么是“合法”的表示值\n下图是AF和RI的书写\n选择某种特定的表示方式R，进而指定某个子集是“合法”的(RI)，并为该子集中的每个值做出“解释”(AF)——即如何映射到抽象空间中的值。\n设计ADT：\n(1) 选择R和A；\n(2) RI — 合法的表示值；\n(3) 如何解释合法的表示值 —映射AF\n做出具体的解释：每个rep value如何映射到abstract value\n"
  },
  {
    "head": "软件构造笔记（十五）--PPT第十一讲",
    "paragraphs": [
      "面向可复用性和可维护性的设计模式",
      "Creational patterns 创建型模式",
      "Structural patterns 结构型模式",
      "Adapter 适配器模式",
      "Decorator 装饰器模式",
      "Behavioral patterns 行为类模式",
      "Strategy 策略模式",
      "Template Method 模板模式",
      "Iterator",
      "Visitor",
      "设计模式的对比",
      "共性模式1",
      "共性模式2",
      "Creational patterns 创建型模式",
      "工厂方法模式",
      "当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。",
      "定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。",
      "比如静态工厂方法：",
      "Structural patterns 结构型模式",
      "Adapter 适配器模式",
      "1.内容：将某个类/接口转换为client期望的其他形式，通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。",
      "2.举例：",
      "设置一个接口Shape，通过具体子类Rectangle实现display方法，但由于这个方法不是我们所期望的，我们需要通过一个适配器来实现内部的方法，并在Rectangle内部进行调用，这样可以通过接口封装内部实现",
      "Decorator 装饰器模式",
      "本节内容引用：https://www.cnblogs.com/yxlaisj/p/10446504.html",
      "1.用每个子类实现不同的特性，为对象增加不同侧面的特性，对每一个特性构造子类，通过委派机制增加到对象上。",
      "使用subtyping and delegation",
      "2.举例：",
      "咖啡接口，获取价格和配料",
      "原味咖啡类，实现咖啡接口，配料中只有咖啡",
      "咖啡对象的装饰器类，同样实现Coffee接口，定义一个Coffe对象的引用，在构造器中进行初始化。并且将getCost（）和getIntegredients()方法转发给被装饰对象。",
      "具体的装饰器类，负责往咖啡中“添加”牛奶，注意看getCost（）方法和getIngredients()方法，可以在转发请求之前或者之后，增加功能。",
      "另一个具体装饰器类，用来给咖啡加糖，一样的逻辑。",
      "客户端使用装饰器模式",
      "Behavioral patterns 行为类模式",
      "Strategy 策略模式",
      "1.内容：有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里，为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。",
      "2.实现方式：",
      "3.举例：",
      "下图两个pay()方法的实现就是模板模式",
      "Template Method 模板模式",
      "1.问题：一些客户端共享相同的算法，但在细节上有所不同，例如，一个算法由可定制的部分和不变的部分组成。公共步骤不应在子类中重复，但需要重用。",
      "解决方法：共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现",
      "使用继承和重写实现模板模式",
      "2.举例：",
      "具体代码：",
      "抽象类的实现：",
      "Iterator",
      "客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式",
      "Visitor",
      "1.内容： 对特定类型的object 的特定操作(visit) ，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit 的类。本质上：将数据和作用于数据上的某种/ 些特定操作分离开来。为ADT 预留一个将来可扩展功能的“接入点”，外部实现的功能代码，可以在不改变ADT 本身的情况下通过delegation 接入ADT",
      "2.举例：",
      "Visitor vs Iterator",
      "迭代器：以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。",
      "Visitor：在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT",
      "Visitor vs Strategy",
      "二者都是通过delegation 建立两个对象的动态联系",
      "但是Visitor强调是的外部定义某种对ADT的操作，该操作于ADT自身关系不大（只是访问ADT），故ADT内部只需要开放accept(visitor)即可，client通过它设定visitor操作并在外部调用。",
      "而Strategy则强调是对ADT内部某些要实现的功能的相应算法的灵活替换。这些算法是ADT功能的重要组成部分，只不过是delegate到外部strategy类而已。",
      "区别：visitor是站在外部client的角度，灵活增加对ADT的各种不同操作（哪怕ADT没实现该操作），strategy则是站在内部ADT的角度，灵活变化对其内部功能的不同配置。",
      "设计模式的对比",
      "共性模式1",
      "对于Adapter",
      "适用场合：你已经有了一个类，但其方法与目前client的需求不一致。",
      "根据OCP原则，不能改这个类，所以扩展一个adaptor和一个统一接口。",
      "对于模板模式：适用场合：有共性的算法流程，但算法各步骤有不同的实现，典型的“将共性提升至超类型，将个性保留在子类型”",
      "共性模式2",
      "对于Strategy：",
      "对于Iterator",
      "对于工厂方法：",
      "对于Visitor："
    ],
    "sentences": [
      "面向可复用性和可维护性的设计模式",
      "Creational patterns 创建型模式",
      "Structural patterns 结构型模式",
      "Adapter 适配器模式",
      "Decorator 装饰器模式",
      "Behavioral patterns 行为类模式",
      "Strategy 策略模式",
      "Template Method 模板模式",
      "Iterator",
      "Visitor",
      "设计模式的对比",
      "共性模式1",
      "共性模式2",
      "Creational patterns 创建型模式",
      "工厂方法模式",
      "当client不知道要创建哪个具体类的实例",
      "或者不想在client代码中指明要具体创建的实例时",
      "用工厂方法",
      "定义一个用于创建对象的接口",
      "让其子类来决定实例化哪一个类",
      "从而使一个类的实例化延迟到其子类",
      "比如静态工厂方法：Structural patterns 结构型模式",
      "Adapter 适配器模式",
      "1.内容：将某个类/接口转换为client期望的其他形式",
      "通过增加一个接口",
      "将已存在的子类封装起来",
      "client面向接口编程",
      "从而隐藏了具体子类",
      "2.举例：设置一个接口Shape",
      "通过具体子类Rectangle实现display方法",
      "但由于这个方法不是我们所期望的",
      "我们需要通过一个适配器来实现内部的方法",
      "并在Rectangle内部进行调用",
      "这样可以通过接口封装内部实现",
      "Decorator 装饰器模式",
      "本节内容引用：https://www.cnblogs.com/yxlaisj/p/10446504.html",
      "1.用每个子类实现不同的特性",
      "为对象增加不同侧面的特性",
      "对每一个特性构造子类",
      "通过委派机制增加到对象上",
      "使用subtyping and delegation",
      "2.举例：咖啡接口，获取价格和配料",
      "原味咖啡类，实现咖啡接口，配料中只有咖啡",
      "咖啡对象的装饰器类",
      "同样实现Coffee接口",
      "定义一个Coffe对象的引用",
      "在构造器中进行初始化",
      "并且将getCost（）和getIntegredients()方法转发给被装饰对象",
      "具体的装饰器类",
      "负责往咖啡中“添加”牛奶",
      "注意看getCost（）方法和getIngredients()方法",
      "可以在转发请求之前或者之后",
      "增加功能",
      "另一个具体装饰器类，用来给咖啡加糖，一样的逻辑",
      "客户端使用装饰器模式",
      "Behavioral patterns 行为类模式",
      "Strategy 策略模式",
      "1.内容：有多种不同的算法来实现同一个任务",
      "但需要client根据需要动态切换算法",
      "而不是写死在代码里",
      "为不同的实现算法构造抽象接口",
      "利用delegation",
      "运行时动态传入client倾向的算法类实例",
      "2.实现方式：3.举例：下图两个pay()方法的实现就是模板模式",
      "Template Method 模板模式",
      "1.问题：一些客户端共享相同的算法",
      "但在细节上有所不同",
      "例如",
      "一个算法由可定制的部分和不变的部分组成",
      "公共步骤不应在子类中重复，但需要重用",
      "解决方法：共性的步骤在抽象类内公共实现",
      "差异化的步骤在各个子类中实现",
      "使用继承和重写实现模板模式",
      "2.举例：具体代码：抽象类的实现：Iterator",
      "客户端希望遍历被放入容器/集合类的一组ADT对象",
      "无需关心容器的具体类型",
      "也就是说",
      "不管对象被放进哪里",
      "都应该提供同样的遍历方式",
      "Visitor",
      "1.内容： 对特定类型的object 的特定操作(visit) ",
      "在运行时将二者动态绑定到一起",
      "该操作可以灵活更改",
      "无需更改被visit 的类",
      "本质上：将数据和作用于数据上的某种/ 些特定操作分离开来",
      "为ADT 预留一个将来可扩展功能的“接入点”",
      "外部实现的功能代码",
      "可以在不改变ADT 本身的情况下通过delegation 接入ADT",
      "2.举例：Visitor vs Iterator",
      "迭代器：以遍历的方式访问集合数据而无需暴露其内部表示",
      "将“遍历”这项功能delegate到外部的iterator对象",
      "Visitor：在特定ADT上执行某种特定操作",
      "但该操作不在ADT内部实现",
      "而是delegate到独立的visitor对象",
      "客户端可灵活扩展/改变visitor的操作算法",
      "而不影响ADT",
      "Visitor vs Strategy",
      "二者都是通过delegation 建立两个对象的动态联系",
      "但是Visitor强调是的外部定义某种对ADT的操作",
      "该操作于ADT自身关系不大（只是访问ADT）",
      "故ADT内部只需要开放accept(visitor)即可",
      "client通过它设定visitor操作并在外部调用",
      "而Strategy则强调是对ADT内部某些要实现的功能的相应算法的灵活替换",
      "这些算法是ADT功能的重要组成部分",
      "只不过是delegate到外部strategy类而已",
      "区别：visitor是站在外部client的角度",
      "灵活增加对ADT的各种不同操作（哪怕ADT没实现该操作）",
      "strategy则是站在内部ADT的角度",
      "灵活变化对其内部功能的不同配置",
      "设计模式的对比",
      "共性模式1",
      "对于Adapter",
      "适用场合：你已经有了一个类",
      "但其方法与目前client的需求不一致",
      "根据OCP原则",
      "不能改这个类",
      "所以扩展一个adaptor和一个统一接口",
      "对于模板模式：适用场合：有共性的算法流程",
      "但算法各步骤有不同的实现",
      "典型的“将共性提升至超类型",
      "将个性保留在子类型”",
      "共性模式2",
      "对于Strategy：对于Iterator",
      "对于工厂方法：对于Visitor："
    ],
    "codes": [
      "/**\n * 咖啡\n */\ninterface Coffee {\n    /** 获取价格 */\n    double getCost();\n    /** 获取配料 */\n    String getIngredients();\n}\n",
      "/**\n * 原味咖啡\n */\nclass SimpleCoffee implements Coffee {\n\n    @Override\n    public double getCost() {\n        return 1;\n    }\n\n    @Override\n    public String getIngredients() {\n        return \"Coffee\";\n    }\n}\n",
      "/**\n * 咖啡的\"装饰器\"，可以给咖啡添加各种\"配料\"\n */\nabstract class CoffeeDecorator implements Coffee {\n    protected final Coffee decoratedCoffee;\n\n    /**\n     * 在构造方法中，初始化咖啡对象的引用\n     */\n    public CoffeeDecorator(Coffee coffee) {\n        decoratedCoffee = coffee;\n    }\n\n    /**\n     * 装饰器父类中直接转发\"请求\"至引用对象\n     */\n    public double getCost() {\n        return decoratedCoffee.getCost();\n    }\n\n    public String getIngredients() {\n        return decoratedCoffee.getIngredients();\n    }\n}\n",
      "/**\n * 此装饰类混合\"牛奶\"到原味咖啡中\n */\nclass WithMilk extends CoffeeDecorator {\n\n    public WithMilk(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public double getCost() {\n        double additionalCost = 0.5;\n        return super.getCost() + additionalCost;\n    }\n\n    @Override\n    public String getIngredients() {\n        String additionalIngredient = \"milk\";\n        return super.getIngredients() + \", \" + additionalIngredient;\n    }\n}\n",
      "class WithSugar extends CoffeeDecorator {\n\n    public WithSugar(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public double getCost() {\n        return super.getCost() + 1;\n    }\n\n    @Override\n    public String getIngredients() {\n        return super.getIngredients() + \", Sugar\";\n    }\n}\n",
      "public class DecoratorDemo {\n\n    static void print(Coffee c) {\n        System.out.println(\"花费了: \" + c.getCost());\n        System.out.println(\"配料: \" + c.getIngredients());\n        System.out.println(\"============\");\n    }\n\n    public static void main(String[] args) {\n        //原味咖啡\n        Coffee c = new SimpleCoffee();\n        print(c);\n\n        //增加牛奶的咖啡\n        c = new WithMilk(c);\n        print(c);\n\n        //再加一点糖\n        c = new WithSugar(c);\n        print(c);\n    }\n}\n"
    ],
    "date": "2021-07-03",
    "text": "面向可复用性和可维护性的设计模式\nCreational patterns 创建型模式\nStructural patterns 结构型模式\nAdapter 适配器模式\nDecorator 装饰器模式\nBehavioral patterns 行为类模式\nStrategy 策略模式\nTemplate Method 模板模式\nIterator\nVisitor\n设计模式的对比\n共性模式1\n共性模式2\nCreational patterns 创建型模式\n工厂方法模式\n当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。\n定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。\n比如静态工厂方法：\nStructural patterns 结构型模式\nAdapter 适配器模式\n1.内容：将某个类/接口转换为client期望的其他形式，通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。\n2.举例：\n设置一个接口Shape，通过具体子类Rectangle实现display方法，但由于这个方法不是我们所期望的，我们需要通过一个适配器来实现内部的方法，并在Rectangle内部进行调用，这样可以通过接口封装内部实现\nDecorator 装饰器模式\n本节内容引用：https://www.cnblogs.com/yxlaisj/p/10446504.html\n1.用每个子类实现不同的特性，为对象增加不同侧面的特性，对每一个特性构造子类，通过委派机制增加到对象上。\n使用subtyping and delegation\n2.举例：\n咖啡接口，获取价格和配料\n原味咖啡类，实现咖啡接口，配料中只有咖啡\n咖啡对象的装饰器类，同样实现Coffee接口，定义一个Coffe对象的引用，在构造器中进行初始化。并且将getCost（）和getIntegredients()方法转发给被装饰对象。\n具体的装饰器类，负责往咖啡中“添加”牛奶，注意看getCost（）方法和getIngredients()方法，可以在转发请求之前或者之后，增加功能。\n另一个具体装饰器类，用来给咖啡加糖，一样的逻辑。\n客户端使用装饰器模式\nBehavioral patterns 行为类模式\nStrategy 策略模式\n1.内容：有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里，为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。\n2.实现方式：\n3.举例：\n下图两个pay()方法的实现就是模板模式\nTemplate Method 模板模式\n1.问题：一些客户端共享相同的算法，但在细节上有所不同，例如，一个算法由可定制的部分和不变的部分组成。公共步骤不应在子类中重复，但需要重用。\n解决方法：共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现\n使用继承和重写实现模板模式\n2.举例：\n具体代码：\n抽象类的实现：\nIterator\n客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式\nVisitor\n1.内容： 对特定类型的object 的特定操作(visit) ，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit 的类。本质上：将数据和作用于数据上的某种/ 些特定操作分离开来。为ADT 预留一个将来可扩展功能的“接入点”，外部实现的功能代码，可以在不改变ADT 本身的情况下通过delegation 接入ADT\n2.举例：\nVisitor vs Iterator\n迭代器：以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。\nVisitor：在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT\nVisitor vs Strategy\n二者都是通过delegation 建立两个对象的动态联系\n但是Visitor强调是的外部定义某种对ADT的操作，该操作于ADT自身关系不大（只是访问ADT），故ADT内部只需要开放accept(visitor)即可，client通过它设定visitor操作并在外部调用。\n而Strategy则强调是对ADT内部某些要实现的功能的相应算法的灵活替换。这些算法是ADT功能的重要组成部分，只不过是delegate到外部strategy类而已。\n区别：visitor是站在外部client的角度，灵活增加对ADT的各种不同操作（哪怕ADT没实现该操作），strategy则是站在内部ADT的角度，灵活变化对其内部功能的不同配置。\n设计模式的对比\n共性模式1\n对于Adapter\n适用场合：你已经有了一个类，但其方法与目前client的需求不一致。\n根据OCP原则，不能改这个类，所以扩展一个adaptor和一个统一接口。\n对于模板模式：适用场合：有共性的算法流程，但算法各步骤有不同的实现，典型的“将共性提升至超类型，将个性保留在子类型”\n共性模式2\n对于Strategy：\n对于Iterator\n对于工厂方法：\n对于Visitor：\n"
  },
  {
    "head": "软件构造笔记（五）",
    "paragraphs": [
      "Java 面向对象编程",
      "静态变量、静态方法",
      "1.静态变量",
      "2.静态方法",
      "接口和类",
      "1.接口",
      "2.使用静态工厂方法可以避免客户知道具体子类名称",
      "使用default关键字",
      "静态变量、静态方法",
      "1.静态变量",
      "静态变量是属于类的，而不是属于类创建的对象",
      "2.静态方法",
      "静态方法只能访问类的静态变量或调用类的静态方法。",
      "静态方法通常作为工具方法使用，当其被其它类使用时，不需要创建类的实例",
      "接口和类",
      "1.接口",
      "1.接口之间可以继承和扩展",
      "2.一个类可以实现多个接口",
      "3.一个接口可以有多种实现类",
      "2.使用静态工厂方法可以避免客户知道具体子类名称",
      "举例来说",
      "客户端具体实现时",
      "为了避免这种情况发生",
      "使用default关键字",
      "在接口统一实现某些功能，无需在各个类中重复使用它"
    ],
    "sentences": [
      "Java 面向对象编程",
      "静态变量、静态方法",
      "1.静态变量",
      "2.静态方法",
      "接口和类",
      "1.接口",
      "2.使用静态工厂方法可以避免客户知道具体子类名称",
      "使用default关键字",
      "静态变量、静态方法",
      "1.静态变量",
      "静态变量是属于类的，而不是属于类创建的对象",
      "2.静态方法",
      "静态方法只能访问类的静态变量或调用类的静态方法",
      "静态方法通常作为工具方法使用",
      "当其被其它类使用时",
      "不需要创建类的实例",
      "接口和类",
      "1.接口",
      "1.接口之间可以继承和扩展",
      "2.一个类可以实现多个接口",
      "3.一个接口可以有多种实现类",
      "2.使用静态工厂方法可以避免客户知道具体子类名称",
      "举例来说",
      "客户端具体实现时",
      "为了避免这种情况发生",
      "使用default关键字",
      "在接口统一实现某些功能，无需在各个类中重复使用它"
    ],
    "codes": [
      "public static int num;\npublic static String s;\n",
      "class Difference{\n\tpublic static void main(String[] args){\n\t\tdisplay();\n\t\tDifference t = new Difference();\n\t\tt.show();\n\t}\n\t// 静态方法\n\tstatic void display(){\n\t\tSystem.out.println(\"Amazing!\");\n\t}\n\t// 普通方法\n\tvoic show(){\n\t\tSystem.out.println(\"Awesome!\");\n\t}\n",
      "public class FastMyString implements MyString{\n\t...\n}\n",
      "MyString s = new FastMyString(true);  //知道具体实现类的名字\n",
      "public interface MyString{\n\t// 在接口里定义子类返回\n\tpublic static MyString valueOf(boolean b){\n\t\treturn new FastMyString(true);\n\t}\n}\n\nMyString s = MyString.valueOf(true);\n",
      "public interface Example{\n\tdefault int method1(int a){...}\n\tstatic int method2(int b){...}\n\tpublic int method3();\n}\n\npublic class C implements Example{\n\t@Override\n\tpublic int method3(){...}\n\t\n\tpublic static void main(String[] args){\n\t\tExample.method2(2);\n\t\tC c = new C();\n\t\tc.method1(1);\n\t\tc.method3();\n\t}\n}\n"
    ],
    "date": "2021-06-25",
    "text": "Java 面向对象编程\n静态变量、静态方法\n1.静态变量\n2.静态方法\n接口和类\n1.接口\n2.使用静态工厂方法可以避免客户知道具体子类名称\n使用default关键字\n静态变量、静态方法\n1.静态变量\n静态变量是属于类的，而不是属于类创建的对象\n2.静态方法\n静态方法只能访问类的静态变量或调用类的静态方法。\n静态方法通常作为工具方法使用，当其被其它类使用时，不需要创建类的实例\n接口和类\n1.接口\n1.接口之间可以继承和扩展\n2.一个类可以实现多个接口\n3.一个接口可以有多种实现类\n2.使用静态工厂方法可以避免客户知道具体子类名称\n举例来说\n客户端具体实现时\n为了避免这种情况发生\n使用default关键字\n在接口统一实现某些功能，无需在各个类中重复使用它\n"
  },
  {
    "head": "软件构造笔记（七）---PPT第三讲",
    "paragraphs": [
      "软件配置管理SCM与版本控制系统VCS",
      "软件配置管理SCM",
      "基本概念",
      "版本控制系统VCS",
      "本地版本控制系统",
      "集中式版本控制系统",
      "分布式版本控制系统",
      "Git工具",
      "操作可视化",
      "Object Graph",
      "存储文件",
      "基本操作",
      "git commit",
      "git push",
      "git分支/合并",
      "软件配置管理SCM",
      "基本概念",
      "1.SCM：追踪和控制软件的变化",
      "2.SCI软件配置项：软件中发生变化的基本单元，如文件",
      "3.baseline基线：软件持续变化过程中的稳定时刻，如对外发布的版本",
      "4.CMDB：配置管理数据库",
      "版本控制系统VCS",
      "本地版本控制系统",
      "仓库存储于开发者本地机器，无法共享和协作",
      "集中式版本控制系统",
      "仓库存储于独立的服务器，支持多开发者之间的协作",
      "分布式版本控制系统",
      "仓库存储于独立的服务器+每个开发者的本地机器",
      "Git工具",
      "操作可视化",
      "workspace：工作区",
      "staging：暂存区",
      "Object Graph",
      "特点：",
      "（1）A->B表示在版本B的基础上作出变化，形成了版本A",
      "（2）每个commit指向一个父亲",
      "（3）多个commit指向同一个父亲：分支",
      "（4）一个commit指向两个父亲：合并",
      "存储文件",
      "Git存储发生变化的文件（而非代码行），不变化的文件不重复存储",
      "基本操作",
      "git commit",
      "git push",
      "git分支/合并",
      "git checkout –b iss53：创建名为iss53的新分支，即创建一个指针指向当前位置",
      "git commit：由于此时在iss53分支上，所以只对该分支进行操作，提交文件后，将iss53指针向后移动一步，master指针不变",
      "下面的操作同理，切换到master分支，创建新分支：hotfix，在该分支进行提交",
      "切换到master分支，将其与hotfix分支进行合并，合并结果就是两个指针指向同一处",
      "-d代表删除hotfix分支",
      "若要合并master与iss53分支",
      "最终结果："
    ],
    "sentences": [
      "软件配置管理SCM与版本控制系统VCS",
      "软件配置管理SCM",
      "基本概念",
      "版本控制系统VCS",
      "本地版本控制系统",
      "集中式版本控制系统",
      "分布式版本控制系统",
      "Git工具",
      "操作可视化",
      "Object Graph",
      "存储文件",
      "基本操作",
      "git commit",
      "git push",
      "git分支/合并",
      "软件配置管理SCM",
      "基本概念",
      "1.SCM：追踪和控制软件的变化",
      "2.SCI软件配置项：软件中发生变化的基本单元，如文件",
      "3.baseline基线：软件持续变化过程中的稳定时刻",
      "如对外发布的版本",
      "4.CMDB：配置管理数据库",
      "版本控制系统VCS",
      "本地版本控制系统",
      "仓库存储于开发者本地机器，无法共享和协作",
      "集中式版本控制系统",
      "仓库存储于独立的服务器，支持多开发者之间的协作",
      "分布式版本控制系统",
      "仓库存储于独立的服务器+每个开发者的本地机器",
      "Git工具",
      "操作可视化",
      "workspace：工作区",
      "staging：暂存区",
      "Object Graph",
      "特点：（1）A->B表示在版本B的基础上作出变化",
      "形成了版本A",
      "（2）每个commit指向一个父亲",
      "（3）多个commit指向同一个父亲：分支",
      "（4）一个commit指向两个父亲：合并",
      "存储文件",
      "Git存储发生变化的文件（而非代码行）",
      "不变化的文件不重复存储",
      "基本操作",
      "git commit",
      "git push",
      "git分支/合并",
      "git checkout –b iss53：创建名为iss53的新分支",
      "即创建一个指针指向当前位置",
      "git commit：由于此时在iss53分支上",
      "所以只对该分支进行操作",
      "提交文件后",
      "将iss53指针向后移动一步",
      "master指针不变",
      "下面的操作同理",
      "切换到master分支",
      "创建新分支：hotfix",
      "在该分支进行提交",
      "切换到master分支",
      "将其与hotfix分支进行合并",
      "合并结果就是两个指针指向同一处",
      "-d代表删除hotfix分支",
      "若要合并master与iss53分支",
      "最终结果："
    ],
    "codes": [],
    "date": "2021-07-01",
    "text": "软件配置管理SCM与版本控制系统VCS\n软件配置管理SCM\n基本概念\n版本控制系统VCS\n本地版本控制系统\n集中式版本控制系统\n分布式版本控制系统\nGit工具\n操作可视化\nObject Graph\n存储文件\n基本操作\ngit commit\ngit push\ngit分支/合并\n软件配置管理SCM\n基本概念\n1.SCM：追踪和控制软件的变化\n2.SCI软件配置项：软件中发生变化的基本单元，如文件\n3.baseline基线：软件持续变化过程中的稳定时刻，如对外发布的版本\n4.CMDB：配置管理数据库\n版本控制系统VCS\n本地版本控制系统\n仓库存储于开发者本地机器，无法共享和协作\n集中式版本控制系统\n仓库存储于独立的服务器，支持多开发者之间的协作\n分布式版本控制系统\n仓库存储于独立的服务器+每个开发者的本地机器\nGit工具\n操作可视化\nworkspace：工作区\nstaging：暂存区\nObject Graph\n特点：\n（1）A->B表示在版本B的基础上作出变化，形成了版本A\n（2）每个commit指向一个父亲\n（3）多个commit指向同一个父亲：分支\n（4）一个commit指向两个父亲：合并\n存储文件\nGit存储发生变化的文件（而非代码行），不变化的文件不重复存储\n基本操作\ngit commit\ngit push\ngit分支/合并\ngit checkout –b iss53：创建名为iss53的新分支，即创建一个指针指向当前位置\ngit commit：由于此时在iss53分支上，所以只对该分支进行操作，提交文件后，将iss53指针向后移动一步，master指针不变\n下面的操作同理，切换到master分支，创建新分支：hotfix，在该分支进行提交\n切换到master分支，将其与hotfix分支进行合并，合并结果就是两个指针指向同一处\n-d代表删除hotfix分支\n若要合并master与iss53分支\n最终结果：\n"
  },
  {
    "head": "软件构造笔记（十六）---PPT第十二讲",
    "paragraphs": [
      "面向正确性与健壮性的软件构造",
      "两个特性",
      "健壮性",
      "正确性",
      "错误与异常",
      "Error",
      "自定义异常类",
      "Assertions",
      "两个特性",
      "健壮性",
      "1.健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度。",
      "2.面向健壮性的编程",
      "（1）处理未期望的行为和错误终止",
      "（2）即使终止执行，也要准确/无歧义的向用户展示全面的错误信息",
      "（3）错误信息有助于进行debug",
      "尽可能保持软件运行而不是总是退出两者的比较",
      "正确性",
      "正确性：程序按照spec 加以执行的能力，是最重要的质量指标！",
      "永不给用户错误的结果",
      "两者的对比：",
      "错误与异常",
      "Error",
      "1.Error类描述了Java运行时系统内部很少发生的内部系统错误和资源耗尽情况(例如，VirtualMachineError, LinkageError)。",
      "不应该抛出这种类型的对象，如果发生这样的内部错误，除了通知用户并试图优雅地终止程序外，你能做的很少。",
      "内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结束",
      "2.种类",
      "（1）User input errors 用户输入错误",
      "（2）Device errors 设备错误",
      "（3）Physical limitations 物理限制",
      "Exception",
      "一.Exception类描述了由你的程序引起的错误(例如FileNotFoundException, IOException)。这些错误可以被你的程序捕获和处理(例如，执行一个替代操作或做一个优雅的退出关闭所有的文件，网络和数据库连接)。",
      "异常：你自己程序导致的问题，可以捕获、可以处理",
      "二.分类：",
      "1.运行时异常：由程序员在代码里处理不当造成",
      "2.其他异常：由外部原因造成",
      "checked Exception",
      "1.处理方法：",
      "（1）你必须捕获和处理异常,或者告诉编译器不能处理它宣称你的方法抛出的异常,代码。",
      "（2）然后使用你的方法将不得不处理,异常(可以选择声明抛出的异常,如果它不能处理)。",
      "（3）编译器将检查我们是否完成了以下两件事中的一件(catch或declare)。",
      "2.编译过程：",
      "必须捕获并指定错误处理器handler，否则编译无法通过，类似于编程语言中的static type checking",
      "从Exception中派生出子类型",
      "编译器可帮助检查你的程序是否已抛出或处理了可能的异常",
      "3.解决办法：",
      "（1）Declaring exceptions (throws) 声明“本方法可能会发生XX异常”",
      "（2）Throwing an exception (throw) 抛出XX异常",
      "（3）Catching an exception (try, catch, finally) 捕获并处理XX异常",
      "4.通过throws",
      "在函数头后和spec中均声明异常的种类",
      "父子函数–参见LSP原则",
      "（1）如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛",
      "（2）子类型方法可以抛出更具体的异常，也可以不抛出任何异常",
      "（3）如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。",
      "错误示例：",
      "5.通过throw",
      "（1）找到一个能表达错误的Exception类/或者构造一个新的Exception类",
      "（2）构造Exception类的实例，将错误信息写入，抛出它",
      "一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码",
      "6.通过try/catch",
      "异常发生后，如果找不到处理器，就终止执行程序，在控制台打印出stack trace，所以可以通过try/catch捕获并处理异常",
      "举例来看：",
      "7.通过finally",
      "（1）当异常抛出时，方法中正常执行的代码被终止，如果异常发生前曾申请过某些资源，那么异常发生后这些资源要被恰当的清理，可以使用finally进行处理",
      "（2）可以不使用catch子句而使用finally子句。",
      "不管代码是否抛出异常，finally都会被执行",
      "try-catch-finally",
      "分情况讨论：",
      "1.该代码不抛出任何异常。",
      "程序首先执行try块中的所有代码。然后执行finally子句中的代码。然后，执行finally子句后的第一个语句。换句话说，执行通过点1、2、5和6。",
      "2.代码抛出一个异常，该异常在catch子句中被捕获。",
      "程序执行try块中的所有代码，直到抛出异常为止。try块中的其余代码将被跳过。然后，程序执行匹配的catch子句中的代码，然后执行finally子句中的代码。",
      "如果catch子句没有抛出异常，则程序执行finally子句后的第一行。执行通过点1、3、4、5和6。如果catch子句抛出一个异常，那么该异常将被抛回调用者，执行只通过点1、3和5。",
      "3.该代码抛出一个未在任何catch子句中捕获的异常。",
      "在这里，程序执行try块中的所有代码，直到抛出异常。跳过try块中的剩余代码。然后，执行finally子句中的代码，并将异常抛回给该方法的调用者。执行只通过点1和点5。",
      "unchecked Exception",
      "Errors and Runtime Exceptions",
      "1.处理方法：",
      "（1）错误表示发生在应用程序之外的情况，例如系统崩溃。运行时异常通常是由于应用程序逻辑中的错误而发生的。",
      "（2）在这些情况下你什么都做不了，只能重写你的程序代码。所以编译器不会检查这些。",
      "（3）这些运行时异常将在开发和测试期间发现。然后我们必须重构我们的代码来删除这些错误。",
      "2.编译过程：",
      "可以不处理，编译没问题，但执行时出现就导致程序失败，代表程序中的潜在bug类似于编程语言中的dynamic type checking",
      "从RuntimeException 派生出子类型",
      "3.举例：在编程和编译的时候，IDE与编译器均不会给出任何错误提示",
      "两者比较",
      "1.使用情况：",
      "（1）如果客户端可以通过其他的方法恢复异常，那么采用checked exception；",
      "（2）如果客户端对出现的这种异常无能为力，那么采用unchecked exception；",
      "（3）异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。",
      "2.对比表格",
      "自定义异常类",
      "为了定义checked Exception，你要创建java.lang.Exception的一个子类(或子类的层次结构):",
      "可能抛出或传播此异常的方法必须声明它:",
      "举个例子：",
      "Assertions",
      "一.定义：在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误。",
      "当断言为真时，意味着一切都按预期运行。",
      "当断言为假时，意味着它在代码中检测到一个意外错误。"
    ],
    "sentences": [
      "面向正确性与健壮性的软件构造",
      "两个特性",
      "健壮性",
      "正确性",
      "错误与异常",
      "Error",
      "自定义异常类",
      "Assertions",
      "两个特性",
      "健壮性",
      "1.健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度",
      "2.面向健壮性的编程",
      "（1）处理未期望的行为和错误终止",
      "（2）即使终止执行",
      "也要准确/无歧义的向用户展示全面的错误信息",
      "（3）错误信息有助于进行debug",
      "尽可能保持软件运行而不是总是退出两者的比较",
      "正确性",
      "正确性：程序按照spec 加以执行的能力",
      "是最重要的质量指标！",
      "永不给用户错误的结果",
      "两者的对比：错误与异常",
      "Error",
      "1.Error类描述了Java运行时系统内部很少发生的内部系统错误和资源耗尽情况(例如",
      "VirtualMachineError, LinkageError)",
      "不应该抛出这种类型的对象",
      "如果发生这样的内部错误",
      "除了通知用户并试图优雅地终止程序外",
      "你能做的很少",
      "内部错误：程序员通常无能为力",
      "一旦发生",
      "想办法让程序优雅的结束",
      "2.种类",
      "（1）User input errors 用户输入错误",
      "（2）Device errors 设备错误",
      "（3）Physical limitations 物理限制",
      "Exception",
      "一.Exception类描述了由你的程序引起的错误(例如FileNotFoundException, IOException)",
      "这些错误可以被你的程序捕获和处理(例如",
      "执行一个替代操作或做一个优雅的退出关闭所有的文件",
      "网络和数据库连接)",
      "异常：你自己程序导致的问题，可以捕获、可以处理",
      "二.分类：1.运行时异常：由程序员在代码里处理不当造成",
      "2.其他异常：由外部原因造成",
      "checked Exception",
      "1.处理方法：（1）你必须捕获和处理异常,或者告诉编译器不能处理它宣称你的方法抛出的异常,代码",
      "（2）然后使用你的方法将不得不处理,异常(可以选择声明抛出的异常,如果它不能处理)",
      "（3）编译器将检查我们是否完成了以下两件事中的一件(catch或declare)",
      "2.编译过程：必须捕获并指定错误处理器handler",
      "否则编译无法通过",
      "类似于编程语言中的static type checking",
      "从Exception中派生出子类型",
      "编译器可帮助检查你的程序是否已抛出或处理了可能的异常",
      "3.解决办法：（1）Declaring exceptions (throws) 声明“本方法可能会发生XX异常”",
      "（2）Throwing an exception (throw) 抛出XX异常",
      "（3）Catching an exception (try, catch, finally) 捕获并处理XX异常",
      "4.通过throws",
      "在函数头后和spec中均声明异常的种类",
      "父子函数–参见LSP原则",
      "（1）如果子类型中override了父类型中的函数",
      "那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛",
      "（2）子类型方法可以抛出更具体的异常，也可以不抛出任何异常",
      "（3）如果父类型的方法未抛出异常",
      "那么子类型的方法也不能抛出异常",
      "错误示例：5.通过throw",
      "（1）找到一个能表达错误的Exception类/或者构造一个新的Exception类",
      "（2）构造Exception类的实例，将错误信息写入，抛出它",
      "一旦抛出异常",
      "方法不会再将控制权返回给调用它的client",
      "因此也无需考虑返回错误代码",
      "6.通过try/catch",
      "异常发生后",
      "如果找不到处理器",
      "就终止执行程序",
      "在控制台打印出stack trace",
      "所以可以通过try/catch捕获并处理异常",
      "举例来看：7.通过finally",
      "（1）当异常抛出时",
      "方法中正常执行的代码被终止",
      "如果异常发生前曾申请过某些资源",
      "那么异常发生后这些资源要被恰当的清理",
      "可以使用finally进行处理",
      "（2）可以不使用catch子句而使用finally子句",
      "不管代码是否抛出异常，finally都会被执行",
      "try-catch-finally",
      "分情况讨论：1.该代码不抛出任何异常",
      "程序首先执行try块中的所有代码",
      "然后执行finally子句中的代码",
      "然后，执行finally子句后的第一个语句",
      "换句话说，执行通过点1、2、5和6",
      "2.代码抛出一个异常，该异常在catch子句中被捕获",
      "程序执行try块中的所有代码，直到抛出异常为止",
      "try块中的其余代码将被跳过",
      "然后",
      "程序执行匹配的catch子句中的代码",
      "然后执行finally子句中的代码",
      "如果catch子句没有抛出异常",
      "则程序执行finally子句后的第一行",
      "执行通过点1、3、4、5和6",
      "如果catch子句抛出一个异常",
      "那么该异常将被抛回调用者",
      "执行只通过点1、3和5",
      "3.该代码抛出一个未在任何catch子句中捕获的异常",
      "在这里，程序执行try块中的所有代码，直到抛出异常",
      "跳过try块中的剩余代码",
      "然后",
      "执行finally子句中的代码",
      "并将异常抛回给该方法的调用者",
      "执行只通过点1和点5",
      "unchecked Exception",
      "Errors and Runtime Exceptions",
      "1.处理方法：（1）错误表示发生在应用程序之外的情况",
      "例如系统崩溃",
      "运行时异常通常是由于应用程序逻辑中的错误而发生的",
      "（2）在这些情况下你什么都做不了，只能重写你的程序代码",
      "所以编译器不会检查这些",
      "（3）这些运行时异常将在开发和测试期间发现",
      "然后我们必须重构我们的代码来删除这些错误",
      "2.编译过程：可以不处理",
      "编译没问题",
      "但执行时出现就导致程序失败",
      "代表程序中的潜在bug类似于编程语言中的dynamic type checking",
      "从RuntimeException 派生出子类型",
      "3.举例：在编程和编译的时候",
      "IDE与编译器均不会给出任何错误提示",
      "两者比较",
      "1.使用情况：（1）如果客户端可以通过其他的方法恢复异常",
      "那么采用checked exception；（2）如果客户端对出现的这种异常无能为力",
      "那么采用unchecked exception；（3）异常出现的时候",
      "要做一些试图恢复它的动作而不要仅仅的打印它的信息",
      "2.对比表格",
      "自定义异常类",
      "为了定义checked Exception",
      "你要创建java.lang.Exception的一个子类(或子类的层次结构):可能抛出或传播此异常的方法必须声明它:举个例子：Assertions",
      "一.定义：在开发阶段的代码中嵌入，检验某些“假设”是否成立",
      "若成立，表明程序运行正常，否则表明存在错误",
      "当断言为真时，意味着一切都按预期运行",
      "当断言为假时，意味着它在代码中检测到一个意外错误"
    ],
    "codes": [
      "Exception",
      "checked Exception",
      "try-catch-finally",
      "unchecked Exception"
    ],
    "date": "2021-07-04",
    "text": "面向正确性与健壮性的软件构造\n两个特性\n健壮性\n正确性\n错误与异常\nError\n自定义异常类\nAssertions\n两个特性\n健壮性\n1.健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度。\n2.面向健壮性的编程\n（1）处理未期望的行为和错误终止\n（2）即使终止执行，也要准确/无歧义的向用户展示全面的错误信息\n（3）错误信息有助于进行debug\n尽可能保持软件运行而不是总是退出两者的比较\n正确性\n正确性：程序按照spec 加以执行的能力，是最重要的质量指标！\n永不给用户错误的结果\n两者的对比：\n错误与异常\nError\n1.Error类描述了Java运行时系统内部很少发生的内部系统错误和资源耗尽情况(例如，VirtualMachineError, LinkageError)。\n不应该抛出这种类型的对象，如果发生这样的内部错误，除了通知用户并试图优雅地终止程序外，你能做的很少。\n内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结束\n2.种类\n（1）User input errors 用户输入错误\n（2）Device errors 设备错误\n（3）Physical limitations 物理限制\nException\n一.Exception类描述了由你的程序引起的错误(例如FileNotFoundException, IOException)。这些错误可以被你的程序捕获和处理(例如，执行一个替代操作或做一个优雅的退出关闭所有的文件，网络和数据库连接)。\n异常：你自己程序导致的问题，可以捕获、可以处理\n二.分类：\n1.运行时异常：由程序员在代码里处理不当造成\n2.其他异常：由外部原因造成\nchecked Exception\n1.处理方法：\n（1）你必须捕获和处理异常,或者告诉编译器不能处理它宣称你的方法抛出的异常,代码。\n（2）然后使用你的方法将不得不处理,异常(可以选择声明抛出的异常,如果它不能处理)。\n（3）编译器将检查我们是否完成了以下两件事中的一件(catch或declare)。\n2.编译过程：\n必须捕获并指定错误处理器handler，否则编译无法通过，类似于编程语言中的static type checking\n从Exception中派生出子类型\n编译器可帮助检查你的程序是否已抛出或处理了可能的异常\n3.解决办法：\n（1）Declaring exceptions (throws) 声明“本方法可能会发生XX异常”\n（2）Throwing an exception (throw) 抛出XX异常\n（3）Catching an exception (try, catch, finally) 捕获并处理XX异常\n4.通过throws\n在函数头后和spec中均声明异常的种类\n父子函数–参见LSP原则\n（1）如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛\n（2）子类型方法可以抛出更具体的异常，也可以不抛出任何异常\n（3）如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。\n错误示例：\n5.通过throw\n（1）找到一个能表达错误的Exception类/或者构造一个新的Exception类\n（2）构造Exception类的实例，将错误信息写入，抛出它\n一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码\n6.通过try/catch\n异常发生后，如果找不到处理器，就终止执行程序，在控制台打印出stack trace，所以可以通过try/catch捕获并处理异常\n举例来看：\n7.通过finally\n（1）当异常抛出时，方法中正常执行的代码被终止，如果异常发生前曾申请过某些资源，那么异常发生后这些资源要被恰当的清理，可以使用finally进行处理\n（2）可以不使用catch子句而使用finally子句。\n不管代码是否抛出异常，finally都会被执行\ntry-catch-finally\n分情况讨论：\n1.该代码不抛出任何异常。\n程序首先执行try块中的所有代码。然后执行finally子句中的代码。然后，执行finally子句后的第一个语句。换句话说，执行通过点1、2、5和6。\n2.代码抛出一个异常，该异常在catch子句中被捕获。\n程序执行try块中的所有代码，直到抛出异常为止。try块中的其余代码将被跳过。然后，程序执行匹配的catch子句中的代码，然后执行finally子句中的代码。\n如果catch子句没有抛出异常，则程序执行finally子句后的第一行。执行通过点1、3、4、5和6。如果catch子句抛出一个异常，那么该异常将被抛回调用者，执行只通过点1、3和5。\n3.该代码抛出一个未在任何catch子句中捕获的异常。\n在这里，程序执行try块中的所有代码，直到抛出异常。跳过try块中的剩余代码。然后，执行finally子句中的代码，并将异常抛回给该方法的调用者。执行只通过点1和点5。\nunchecked Exception\nErrors and Runtime Exceptions\n1.处理方法：\n（1）错误表示发生在应用程序之外的情况，例如系统崩溃。运行时异常通常是由于应用程序逻辑中的错误而发生的。\n（2）在这些情况下你什么都做不了，只能重写你的程序代码。所以编译器不会检查这些。\n（3）这些运行时异常将在开发和测试期间发现。然后我们必须重构我们的代码来删除这些错误。\n2.编译过程：\n可以不处理，编译没问题，但执行时出现就导致程序失败，代表程序中的潜在bug类似于编程语言中的dynamic type checking\n从RuntimeException 派生出子类型\n3.举例：在编程和编译的时候，IDE与编译器均不会给出任何错误提示\n两者比较\n1.使用情况：\n（1）如果客户端可以通过其他的方法恢复异常，那么采用checked exception；\n（2）如果客户端对出现的这种异常无能为力，那么采用unchecked exception；\n（3）异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。\n2.对比表格\n自定义异常类\n为了定义checked Exception，你要创建java.lang.Exception的一个子类(或子类的层次结构):\n可能抛出或传播此异常的方法必须声明它:\n举个例子：\nAssertions\n一.定义：在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误。\n当断言为真时，意味着一切都按预期运行。\n当断言为假时，意味着它在代码中检测到一个意外错误。\n"
  },
  {
    "head": "软件构造笔记（十四）---PPT第十讲",
    "paragraphs": [
      "面向可维护性的构造技术",
      "OO设计原则：SOLID",
      "(DIP) The Dependency Inversion Principle",
      "OO设计原则：SOLID",
      "(SRP) The Single Responsibility Principle",
      "SRP–单一责任原则",
      "1.内容：不应有多于1个的原因使得一个类发生变化，即一个类，一个责任",
      "2.举例：",
      "(OCP) The Open-Closed Principle",
      "OCP–开放-封闭原则",
      "1.对扩展性的开放：",
      "这意味着模块的行为可以被扩展。当应用程序的需求发生变化时，或者满足新应用程序的需求时，我们可以使模块以新的不同的方式运行。",
      "2.对修改的封闭：",
      "但模块自身的代码是不应被修改的，扩展模块行为的一般途径是修改模块的内部实现，如果一个模块不能被修改，那么它通常被认为是具有固定的行为。",
      "3.实现方式：",
      "第一种：如果有多种类型的Server，那么针对每一种新出现的Server，不得不修改Server类的内部具体实现。不推荐使用",
      "第二种：通过构造一个抽象的Server类：AbstractServer，该抽象类中包含针对所有类型的Server都通用的代码，从而实现了对修改的封闭；当出现新的Server类型时，只需从该抽象类中派生出具体的子类ConcreteServer即可，从而支持了对扩展的开放。",
      "4.举例：",
      "左边：如果要修改m_type的值，则要修改内部代码实现，破坏对修改的封闭。",
      "右边：如果要修改m_type的值，只需要增加额外的类进行实现就可以，其他无关的类都不做改动，满足OCP原则",
      "(LSP) The Liskov Substitution Principle",
      "LSP–Liskov 替换原则",
      "子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异",
      "(ISP) The Interface Segregation Principle",
      "ISP–接口隔离原则",
      "1.“ 胖”接口具有很多缺点：不够聚合",
      "胖接口可分解为多个小的接口，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的端口。",
      "2.举例：",
      "这是一个不好的实现方式，RobotWorker不需要实现eat()方法，但由于接口中包含两个方法，所以都要实现，不满足ISP原则。",
      "修改方式如下：",
      "将上述两个接口分离，实现类时只实现需要功能的接口即可。",
      "(DIP) The Dependency Inversion Principle",
      "DIP–依赖转置原则",
      "1.抽象的模块不应依赖于具体的模块，具体应依赖于抽象",
      "举个例子：",
      "下面的实现是通过接口而不是具体类实现的",
      "2.实现方法：",
      "不推荐的方法：上层client的代码中直接嵌入了对下层具体实现机制的调用",
      "满足DIP的方法：上层client的代码面向抽象接口编程，隔离对下层具体实现机制的直接接触",
      "再举个例子：",
      "delegation要通过接口实现，而不是具体子类"
    ],
    "sentences": [
      "面向可维护性的构造技术",
      "OO设计原则：SOLID",
      "(DIP) The Dependency Inversion Principle",
      "OO设计原则：SOLID",
      "(SRP) The Single Responsibility Principle",
      "SRP–单一责任原则",
      "1.内容：不应有多于1个的原因使得一个类发生变化",
      "即一个类",
      "一个责任",
      "2.举例：(OCP) The Open-Closed Principle",
      "OCP–开放-封闭原则",
      "1.对扩展性的开放：这意味着模块的行为可以被扩展",
      "当应用程序的需求发生变化时",
      "或者满足新应用程序的需求时",
      "我们可以使模块以新的不同的方式运行",
      "2.对修改的封闭：但模块自身的代码是不应被修改的",
      "扩展模块行为的一般途径是修改模块的内部实现",
      "如果一个模块不能被修改",
      "那么它通常被认为是具有固定的行为",
      "3.实现方式：第一种：如果有多种类型的Server",
      "那么针对每一种新出现的Server",
      "不得不修改Server类的内部具体实现",
      "不推荐使用",
      "第二种：通过构造一个抽象的Server类：AbstractServer",
      "该抽象类中包含针对所有类型的Server都通用的代码",
      "从而实现了对修改的封闭；当出现新的Server类型时",
      "只需从该抽象类中派生出具体的子类ConcreteServer即可",
      "从而支持了对扩展的开放",
      "4.举例：左边：如果要修改m_type的值",
      "则要修改内部代码实现",
      "破坏对修改的封闭",
      "右边：如果要修改m_type的值",
      "只需要增加额外的类进行实现就可以",
      "其他无关的类都不做改动",
      "满足OCP原则",
      "(LSP) The Liskov Substitution Principle",
      "LSP–Liskov 替换原则",
      "子类型必须能够替换其基类型",
      "派生类必须能够通过其基类的接口使用",
      "客户端无需了解二者之间的差异",
      "(ISP) The Interface Segregation Principle",
      "ISP–接口隔离原则",
      "1.“ 胖”接口具有很多缺点：不够聚合",
      "胖接口可分解为多个小的接口",
      "不同的接口向不同的客户端提供服务",
      "客户端只访问自己所需要的端口",
      "2.举例：这是一个不好的实现方式",
      "RobotWorker不需要实现eat()方法",
      "但由于接口中包含两个方法",
      "所以都要实现",
      "不满足ISP原则",
      "修改方式如下：将上述两个接口分离",
      "实现类时只实现需要功能的接口即可",
      "(DIP) The Dependency Inversion Principle",
      "DIP–依赖转置原则",
      "1.抽象的模块不应依赖于具体的模块，具体应依赖于抽象",
      "举个例子：下面的实现是通过接口而不是具体类实现的",
      "2.实现方法：不推荐的方法：上层client的代码中直接嵌入了对下层具体实现机制的调用",
      "满足DIP的方法：上层client的代码面向抽象接口编程",
      "隔离对下层具体实现机制的直接接触",
      "再举个例子：delegation要通过接口实现",
      "而不是具体子类"
    ],
    "codes": [
      "(SRP) The Single Responsibility Principle",
      "(OCP) The Open-Closed Principle",
      "(LSP) The Liskov Substitution Principle",
      "(ISP) The Interface Segregation Principle"
    ],
    "date": "2021-07-03",
    "text": "面向可维护性的构造技术\nOO设计原则：SOLID\n(DIP) The Dependency Inversion Principle\nOO设计原则：SOLID\n(SRP) The Single Responsibility Principle\nSRP–单一责任原则\n1.内容：不应有多于1个的原因使得一个类发生变化，即一个类，一个责任\n2.举例：\n(OCP) The Open-Closed Principle\nOCP–开放-封闭原则\n1.对扩展性的开放：\n这意味着模块的行为可以被扩展。当应用程序的需求发生变化时，或者满足新应用程序的需求时，我们可以使模块以新的不同的方式运行。\n2.对修改的封闭：\n但模块自身的代码是不应被修改的，扩展模块行为的一般途径是修改模块的内部实现，如果一个模块不能被修改，那么它通常被认为是具有固定的行为。\n3.实现方式：\n第一种：如果有多种类型的Server，那么针对每一种新出现的Server，不得不修改Server类的内部具体实现。不推荐使用\n第二种：通过构造一个抽象的Server类：AbstractServer，该抽象类中包含针对所有类型的Server都通用的代码，从而实现了对修改的封闭；当出现新的Server类型时，只需从该抽象类中派生出具体的子类ConcreteServer即可，从而支持了对扩展的开放。\n4.举例：\n左边：如果要修改m_type的值，则要修改内部代码实现，破坏对修改的封闭。\n右边：如果要修改m_type的值，只需要增加额外的类进行实现就可以，其他无关的类都不做改动，满足OCP原则\n(LSP) The Liskov Substitution Principle\nLSP–Liskov 替换原则\n子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异\n(ISP) The Interface Segregation Principle\nISP–接口隔离原则\n1.“ 胖”接口具有很多缺点：不够聚合\n胖接口可分解为多个小的接口，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的端口。\n2.举例：\n这是一个不好的实现方式，RobotWorker不需要实现eat()方法，但由于接口中包含两个方法，所以都要实现，不满足ISP原则。\n修改方式如下：\n将上述两个接口分离，实现类时只实现需要功能的接口即可。\n(DIP) The Dependency Inversion Principle\nDIP–依赖转置原则\n1.抽象的模块不应依赖于具体的模块，具体应依赖于抽象\n举个例子：\n下面的实现是通过接口而不是具体类实现的\n2.实现方法：\n不推荐的方法：上层client的代码中直接嵌入了对下层具体实现机制的调用\n满足DIP的方法：上层client的代码面向抽象接口编程，隔离对下层具体实现机制的直接接触\n再举个例子：\ndelegation要通过接口实现，而不是具体子类\n"
  },
  {
    "head": "软件构造笔记（九）---PPT第五讲",
    "paragraphs": [
      "设计规约",
      "行为等价性",
      "规约前置/后置条件",
      "设计规约",
      "规约的强度",
      "行为等价性",
      "举例来说：站在客户的角度，下面两个函数行为是否等价",
      "分情况：",
      "1.当val缺失时，findFirst返回arr的长度，findLast返回-1",
      "2.当val出现两次时，findFirst返回较低的索引，findLast返回较高的索引。",
      "3.但是当val恰好出现在数组的一个下标处时，这两个方法的行为是相同的。当它们调用这个方法时，它们将传入一个包含一个元素val的arr。对于这样的客户端，这两个方法是相同的。",
      "所以，其实现在没有办法准确定义这两个函数行为是否等价。",
      "但如果我们设计一个spec规约，根据规约判定两个函数是否等价，能看出来，上述两个函数满足改规约，所以函数等价",
      "如何判断行为等价性：",
      "1.单纯的看实现代码，并不足以判定不同的implmentation是否是“行为等价的”。",
      "2.需要根据代码的spec（开发者与client之间形成的contract）判定行为等价性。",
      "3.在编写代码之前，需要弄清楚spec如何协商形成、如何撰写。",
      "规约前置/后置条件",
      "1.前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "2.后置条件：对开发者的约束，方法结束时必须满足的条件",
      "3.契约：如果前置条件满足了，后置条件必须满足。如果前置条件不满足，则方法可做任何事情。",
      "4.设计特点：",
      "参数由@param子句描述，结果由@return和@throws子句描述。尽可能将前置条件放入@param中，将后置条件放入@return和@throws中。",
      "5.方法的说明可以讨论方法的参数和返回值，但绝不应该讨论方法的局部变量或方法类的私有字段。",
      "6.可变方法的spec：",
      "前两种都是可变方法，会修改传入的参数，但是除非在后置条件里声明过，否则方法内部不应该改变输入参数。应尽量遵循此规则，尽量不设计mutating 的spec ，否则就容易引发bugs 。",
      "设计规约",
      "规约的强度",
      "1.存在规约S1和S2，判断是否可以用S2替代S1",
      "若满足条件：S2的前置条件更弱、后置条件更强，则证明S2>=S1，可以用S2代替S1",
      "spec变强：更放松的前置条件+更严格的后置条件",
      "越强的规约，意味着implementor的自由度和责任越重，而client的",
      "责任越轻。",
      "2.举例：",
      "（1）前置条件变弱，后置条件不变",
      "判断后置条件是要在满足第一个函数的前置条件的前提下，能发现后置条件相同",
      "（2）前置条件和后置条件都变弱了，无法判断"
    ],
    "sentences": [
      "设计规约",
      "行为等价性",
      "规约前置/后置条件",
      "设计规约",
      "规约的强度",
      "行为等价性",
      "举例来说：站在客户的角度，下面两个函数行为是否等价",
      "分情况：1.当val缺失时",
      "findFirst返回arr的长度",
      "findLast返回-1",
      "2.当val出现两次时",
      "findFirst返回较低的索引",
      "findLast返回较高的索引",
      "3.但是当val恰好出现在数组的一个下标处时",
      "这两个方法的行为是相同的",
      "当它们调用这个方法时",
      "它们将传入一个包含一个元素val的arr",
      "对于这样的客户端，这两个方法是相同的",
      "所以，其实现在没有办法准确定义这两个函数行为是否等价",
      "但如果我们设计一个spec规约",
      "根据规约判定两个函数是否等价",
      "能看出来",
      "上述两个函数满足改规约",
      "所以函数等价",
      "如何判断行为等价性：1.单纯的看实现代码",
      "并不足以判定不同的implmentation是否是“行为等价的”",
      "2.需要根据代码的spec（开发者与client之间形成的contract）判定行为等价性",
      "3.在编写代码之前，需要弄清楚spec如何协商形成、如何撰写",
      "规约前置/后置条件",
      "1.前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "2.后置条件：对开发者的约束，方法结束时必须满足的条件",
      "3.契约：如果前置条件满足了，后置条件必须满足",
      "如果前置条件不满足，则方法可做任何事情",
      "4.设计特点：参数由@param子句描述",
      "结果由@return和@throws子句描述",
      "尽可能将前置条件放入@param中",
      "将后置条件放入@return和@throws中",
      "5.方法的说明可以讨论方法的参数和返回值",
      "但绝不应该讨论方法的局部变量或方法类的私有字段",
      "6.可变方法的spec：前两种都是可变方法",
      "会修改传入的参数",
      "但是除非在后置条件里声明过",
      "否则方法内部不应该改变输入参数",
      "应尽量遵循此规则",
      "尽量不设计mutating 的spec ",
      "否则就容易引发bugs ",
      "设计规约",
      "规约的强度",
      "1.存在规约S1和S2，判断是否可以用S2替代S1",
      "若满足条件：S2的前置条件更弱、后置条件更强",
      "则证明S2>=S1",
      "可以用S2代替S1",
      "spec变强：更放松的前置条件+更严格的后置条件",
      "越强的规约",
      "意味着implementor的自由度和责任越重",
      "而client的",
      "责任越轻",
      "2.举例：（1）前置条件变弱，后置条件不变",
      "判断后置条件是要在满足第一个函数的前置条件的前提下",
      "能发现后置条件相同",
      "（2）前置条件和后置条件都变弱了，无法判断"
    ],
    "codes": [],
    "date": "2021-07-01",
    "text": "设计规约\n行为等价性\n规约前置/后置条件\n设计规约\n规约的强度\n行为等价性\n举例来说：站在客户的角度，下面两个函数行为是否等价\n分情况：\n1.当val缺失时，findFirst返回arr的长度，findLast返回-1\n2.当val出现两次时，findFirst返回较低的索引，findLast返回较高的索引。\n3.但是当val恰好出现在数组的一个下标处时，这两个方法的行为是相同的。当它们调用这个方法时，它们将传入一个包含一个元素val的arr。对于这样的客户端，这两个方法是相同的。\n所以，其实现在没有办法准确定义这两个函数行为是否等价。\n但如果我们设计一个spec规约，根据规约判定两个函数是否等价，能看出来，上述两个函数满足改规约，所以函数等价\n如何判断行为等价性：\n1.单纯的看实现代码，并不足以判定不同的implmentation是否是“行为等价的”。\n2.需要根据代码的spec（开发者与client之间形成的contract）判定行为等价性。\n3.在编写代码之前，需要弄清楚spec如何协商形成、如何撰写。\n规约前置/后置条件\n1.前置条件：对客户端的约束，在使用方法时必须满足的条件\n2.后置条件：对开发者的约束，方法结束时必须满足的条件\n3.契约：如果前置条件满足了，后置条件必须满足。如果前置条件不满足，则方法可做任何事情。\n4.设计特点：\n参数由@param子句描述，结果由@return和@throws子句描述。尽可能将前置条件放入@param中，将后置条件放入@return和@throws中。\n5.方法的说明可以讨论方法的参数和返回值，但绝不应该讨论方法的局部变量或方法类的私有字段。\n6.可变方法的spec：\n前两种都是可变方法，会修改传入的参数，但是除非在后置条件里声明过，否则方法内部不应该改变输入参数。应尽量遵循此规则，尽量不设计mutating 的spec ，否则就容易引发bugs 。\n设计规约\n规约的强度\n1.存在规约S1和S2，判断是否可以用S2替代S1\n若满足条件：S2的前置条件更弱、后置条件更强，则证明S2>=S1，可以用S2代替S1\nspec变强：更放松的前置条件+更严格的后置条件\n越强的规约，意味着implementor的自由度和责任越重，而client的\n责任越轻。\n2.举例：\n（1）前置条件变弱，后置条件不变\n判断后置条件是要在满足第一个函数的前置条件的前提下，能发现后置条件相同\n（2）前置条件和后置条件都变弱了，无法判断\n"
  },
  {
    "head": "力扣---数组专题I (简单)",
    "paragraphs": [
      "题目名称",
      "1.867--转置矩阵--简单",
      "2.面试题 17.10. 主要元素",
      "3. 977-有序数组的平方",
      "4. 628-三个数的最大乘积",
      "5. 219-存在重复元素II",
      "6. 228-汇总区间",
      "7.1-两数之和",
      "8.167-两数之和II-输入有序数组",
      "1.867–转置矩阵–简单",
      "(1)题目条件：",
      "（2）题解：",
      "该题的目的是对已知矩阵进行转置，由于矩阵的行数和列数可能不相等，对于一个m行n列的矩阵，利用vector创建一个n行m列的空矩阵res，进行赋值操作，res[j][i] = matrix[i][j]。",
      "2.面试题 17.10. 主要元素",
      "（1）题目条件：",
      "（2）题解：",
      "摩尔投票法:",
      "在网上看到了一个形象的比喻，多个候选人要选举总统，如果其中一个人获得选票比其他人加起来的还多，那么即使进行一对一的比拼，最后剩下的还是这个人。",
      "算法步骤：",
      "I. 遍历数组元素，从第一个元素开始，计数器初始设置为0，st设置为数组第一个元素",
      "II.遇到与st相同的元素时，count加1，否则，count减一。若count=0时，st更换为现在的元素",
      "III.最后重新遍历一遍数组，看st的数量是否超过数组元素的一半，若超过一半，则返回该元素，否则返回-1.",
      "排序方法：",
      "将数组从小到大排序，若某个元素数量超过数组元素个数一半，数组最中间的元素一定是该元素。",
      "3. 977-有序数组的平方",
      "（1）题目条件：",
      "（2）解题方法：",
      "暴力算法",
      "先将数组元素都平方，然后将数组重新排序",
      "双指针",
      "题目条件给出数组是非递减顺序排列的，对于正数来说，平方之后顺序不变，对于负数来说，平方之后顺序反转，所以平方后的最大值出现在数组开头或者结尾，最小值出现在数组中间。",
      "4. 628-三个数的最大乘积",
      "（1）题目条件：",
      "（2）题解：",
      "最大值可能出现的情况只有两种，一种是三个全是正数，即数组最大的三个正数，另一种是两个负数一个正数，最小的两个负数和最大的一个正数",
      "排序法",
      "非排序法",
      "是要找到最大的三个值和最小的两个值就可以了",
      "5. 219-存在重复元素II",
      "（1）题目条件：",
      "（2）题解：",
      "哈希表HashSet，HashSet继承于set类，set类的元素都是唯一的。",
      "算法步骤：",
      "i. 构造一个哈希表set，让哈希表的长度始终为k",
      "ii. 遍历整个数组，看遍历的元素是否已经存在于set集合中了，若在集合中，则返回true，若没在集合中，则将该元素加入哈希表，若哈希表的长度超过k，则将最先加入的元素移除",
      "解法说明：https://leetcode-cn.com/problems/contains-duplicate-ii/solution/hua-jie-suan-fa-219-cun-zai-zhong-fu-yuan-su-ii-by/",
      "6. 228-汇总区间",
      "（1）题目条件：",
      "（2）题解：",
      "代码注意事项",
      "i.while(i < n && nums[i-1]+1 == nums[i])要先写i<n，因为若数组只有一个元素，则i<n是错误的直接不进行循环，但若是先写后面的条件，由于nums[i]不存在，所以会报错",
      "（这个问题找了好久）",
      "ii. c++中存在string类，将数字转换成字符可以使用to_string函数，在后面添加元素可以用append函数",
      "7.1-两数之和",
      "（1）题目条件：",
      "（2）题解：",
      "暴力枚举",
      "哈希表",
      "8.167-两数之和II-输入有序数组",
      "（1）题目条件：",
      "（2）题解：",
      "利用数组有序的条件",
      "二分查找",
      "固定第一个值，寻找第二个值的时候用二分查找的方法能缩短查找时间，提高效率。",
      "双指针",
      "初始时将两个指针放在数组两侧，sum为两个指针指向数据之和",
      "若sum==target，则找到唯一解",
      "若sum<target，左指针向右移，增大sum",
      "若sum>target，右指针向左移，减小sum"
    ],
    "sentences": [
      "题目名称",
      "1.867--转置矩阵--简单",
      "2.面试题 17.10. 主要元素",
      "3. 977-有序数组的平方",
      "4. 628-三个数的最大乘积",
      "5. 219-存在重复元素II",
      "6. 228-汇总区间",
      "7.1-两数之和",
      "8.167-两数之和II-输入有序数组",
      "1.867–转置矩阵–简单",
      "(1)题目条件：（2）题解：该题的目的是对已知矩阵进行转置",
      "由于矩阵的行数和列数可能不相等",
      "对于一个m行n列的矩阵",
      "利用vector创建一个n行m列的空矩阵res",
      "进行赋值操作",
      "res[j][i] = matrix[i][j]",
      "2.面试题 17.10. 主要元素",
      "（1）题目条件：（2）题解：摩尔投票法:在网上看到了一个形象的比喻",
      "多个候选人要选举总统",
      "如果其中一个人获得选票比其他人加起来的还多",
      "那么即使进行一对一的比拼",
      "最后剩下的还是这个人",
      "算法步骤：I. 遍历数组元素",
      "从第一个元素开始",
      "计数器初始设置为0",
      "st设置为数组第一个元素",
      "II.遇到与st相同的元素时",
      "count加1",
      "否则",
      "count减一",
      "若count=0时，st更换为现在的元素",
      "III.最后重新遍历一遍数组",
      "看st的数量是否超过数组元素的一半",
      "若超过一半",
      "则返回该元素",
      "否则返回-1.排序方法：将数组从小到大排序",
      "若某个元素数量超过数组元素个数一半",
      "数组最中间的元素一定是该元素",
      "3. 977-有序数组的平方",
      "（1）题目条件：（2）解题方法：暴力算法",
      "先将数组元素都平方，然后将数组重新排序",
      "双指针",
      "题目条件给出数组是非递减顺序排列的",
      "对于正数来说",
      "平方之后顺序不变",
      "对于负数来说",
      "平方之后顺序反转",
      "所以平方后的最大值出现在数组开头或者结尾",
      "最小值出现在数组中间",
      "4. 628-三个数的最大乘积",
      "（1）题目条件：（2）题解：最大值可能出现的情况只有两种",
      "一种是三个全是正数",
      "即数组最大的三个正数",
      "另一种是两个负数一个正数",
      "最小的两个负数和最大的一个正数",
      "排序法",
      "非排序法",
      "是要找到最大的三个值和最小的两个值就可以了",
      "5. 219-存在重复元素II",
      "（1）题目条件：（2）题解：哈希表HashSet",
      "HashSet继承于set类",
      "set类的元素都是唯一的",
      "算法步骤：i. 构造一个哈希表set，让哈希表的长度始终为k",
      "ii. 遍历整个数组",
      "看遍历的元素是否已经存在于set集合中了",
      "若在集合中",
      "则返回true",
      "若没在集合中",
      "则将该元素加入哈希表",
      "若哈希表的长度超过k",
      "则将最先加入的元素移除",
      "解法说明：https://leetcode-cn.com/problems/contains-duplicate-ii/solution/hua-jie-suan-fa-219-cun-zai-zhong-fu-yuan-su-ii-by/",
      "6. 228-汇总区间",
      "（1）题目条件：（2）题解：代码注意事项",
      "i.while(i < n && nums[i-1]+1 == nums[i])要先写i<n",
      "因为若数组只有一个元素",
      "则i<n是错误的直接不进行循环",
      "但若是先写后面的条件",
      "由于nums[i]不存在",
      "所以会报错",
      "（这个问题找了好久）",
      "ii. c++中存在string类",
      "将数字转换成字符可以使用to_string函数",
      "在后面添加元素可以用append函数",
      "7.1-两数之和",
      "（1）题目条件：（2）题解：暴力枚举",
      "哈希表",
      "8.167-两数之和II-输入有序数组",
      "（1）题目条件：（2）题解：利用数组有序的条件",
      "二分查找",
      "固定第一个值",
      "寻找第二个值的时候用二分查找的方法能缩短查找时间",
      "提高效率",
      "双指针",
      "初始时将两个指针放在数组两侧，sum为两个指针指向数据之和",
      "若sum==target，则找到唯一解",
      "若sum<target，左指针向右移，增大sum",
      "若sum>target，右指针向左移，减小sum"
    ],
    "codes": [
      "class Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<vector<int>> res(n, vector<int>(m));\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                res[j][i] = matrix[i][j];\n            }\n        }\n        return res;\n    }\n};\n",
      "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0)  return -1;\n        int st = nums[0], count = 0;\n        for(int i = 0; i < n; i++){\n            if(nums[i] == st){\n                count++;\n            }\n            else{\n                count--;\n                if(count <= 0){\n                    st = nums[i];\n                    count = 1;\n                }  \n            }\n        }\n        count = 0;\n        for(int i = 0; i < n; i++){\n            if(st == nums[i])  count++;\n        }\n        if(count > n/2)  return st;\n        else  return -1;\n    }\n};\n",
      "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0)  return -1;\n        sort(nums.begin(), nums.end());  //对数组从小到大排序\n        int mid = nums[n/2];\n        int count = 0;  //设置计数器\n        for(int i = 0; i < n; i++){\n            if(mid == nums[i])  count++;\n        }\n        if(count > n/2)  return mid;\n        else  return -1;\n    }\n};\n",
      "class Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            nums[i] = nums[i] * nums[i];\n        }\n        sort(nums.begin(), nums.end());\n        return nums;\n    }\n};\n",
      "class Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size()-1;\n        int i, j;\n        vector<int> ans(nums.size(), 0);\n        for(i=0, j=nums.size()-1; i <= j;){\n            if(nums[i]*nums[i] < nums[j]*nums[j]){\n                ans[n--] = nums[j] * nums[j];\n                j--;\n            }\n            else{\n                ans[n--] = nums[i] * nums[i];\n                i++;\n            }\n        }\n        return ans;\n    }\n};\n",
      "class Solution {\npublic:\n    int maximumProduct(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        return max(nums[0]*nums[1]*nums[n-1], nums[n-3]*nums[n-2]*nums[n-1]);\n    }\n};\n",
      "class Solution {\npublic:\n    int maximumProduct(vector<int>& nums) {\n        int n = nums.size();\n        int max1 = -1000, max2 = -1000, max3 = -1000;  //第一、第二、第三大的数\n        int min1 = 1000, min2 = 1000; //第一、第二小的数\n        for(int i = 0; i < n; i++){\n            if(nums[i] >= max1){  //大于最大的数\n                max3 = max2; max2 = max1; max1 = nums[i]; \n            }\n            else if(nums[i] >= max2){  //在max1和max2之间\n                 max3 = max2; max2 = nums[i]; \n            }\n            else if(nums[i] >= max3){   //在max2和max3之间\n                max3 = nums[i];\n            }\n            if(nums[i] <= min1){  //比最小值还小\n                min2 = min1; min1 = nums[i]; \n            }\n            else if(nums[i] <= min2){  //在min1和min2之间\n                min2 = nums[i];\n            }\n        }\n        return max(min1*min2*max1, max3*max2*max1);\n    }\n};\n",
      "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        HashSet<Integer> set = new HashSet<>();\n        for(int i = 0; i < nums.length; i++){\n            if(set.contains(nums[i]))  return true;\n            set.add(nums[i]);\n            if(set.size() > k){\n                set.remove(nums[i-k]);\n            }\n        }\n        return false;\n    }\n}\n",
      "class Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        int i = 0;\n        vector<string> ret;\n        int n = nums.size();\n        while(i < n){\n            int low = i;\n            i++;\n            while(i < n && nums[i-1]+1 == nums[i]){\n                i++;\n            }\n            int high = i-1;\n            string temp = to_string(nums[low]);\n            if(low < high){  //证明存在一个区间\n                temp.append(\"->\");\n                temp.append(to_string(nums[high]));\n            }\n            ret.push_back(temp);\n        }\n        return ret;\n    }\n};\n",
      "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            int j = i+1;\n            while(j < n){\n                if(nums[i] + nums[j] == target){\n                    return vector<int>{i, j};\n                }\n                else{\n                    j++;\n                }\n            }\n        }\n        return vector<int>{-1,-1};\n    }\n};\n",
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            if(map.containsKey(target-nums[i])){\n                return new int[]{map.get(target-nums[i]), i};\n            }\n            map.put(nums[i], i);\n        }\n        return new int[]{-1, -1};\n    }\n}\n",
      "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int n = numbers.size();\n        for(int i = 0; i < n; i++){\n            int low = i+1, high = n-1;\n            while(low <= high){\n                int mid = (high-low)/2 + low;\n                if(numbers[mid] == target - numbers[i]){\n                    return {i+1, mid+1};\n                }\n                else if(numbers[mid] > target - numbers[i]){\n                    high = mid - 1;\n                }\n                else{\n                    low = mid + 1;\n                }\n            }\n        }\n        return {-1, -1};\n    }\n};\n",
      "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int low = 0, high = numbers.size()-1;\n        while(low < high){\n            int sum = numbers[low] + numbers[high];\n            if(sum == target){\n                return {low+1, high+1};\n            }\n            else if(sum > target){\n                high--;\n            }\n            else{\n                low++;\n            }\n        }\n        return {-1,-1};\n    }\n};\n```\n\n"
    ],
    "date": "2021-03-25",
    "text": "题目名称\n1.867--转置矩阵--简单\n2.面试题 17.10. 主要元素\n3. 977-有序数组的平方\n4. 628-三个数的最大乘积\n5. 219-存在重复元素II\n6. 228-汇总区间\n7.1-两数之和\n8.167-两数之和II-输入有序数组\n1.867–转置矩阵–简单\n(1)题目条件：\n（2）题解：\n该题的目的是对已知矩阵进行转置，由于矩阵的行数和列数可能不相等，对于一个m行n列的矩阵，利用vector创建一个n行m列的空矩阵res，进行赋值操作，res[j][i] = matrix[i][j]。\n2.面试题 17.10. 主要元素\n（1）题目条件：\n（2）题解：\n摩尔投票法:\n在网上看到了一个形象的比喻，多个候选人要选举总统，如果其中一个人获得选票比其他人加起来的还多，那么即使进行一对一的比拼，最后剩下的还是这个人。\n算法步骤：\nI. 遍历数组元素，从第一个元素开始，计数器初始设置为0，st设置为数组第一个元素\nII.遇到与st相同的元素时，count加1，否则，count减一。若count=0时，st更换为现在的元素\nIII.最后重新遍历一遍数组，看st的数量是否超过数组元素的一半，若超过一半，则返回该元素，否则返回-1.\n排序方法：\n将数组从小到大排序，若某个元素数量超过数组元素个数一半，数组最中间的元素一定是该元素。\n3. 977-有序数组的平方\n（1）题目条件：\n（2）解题方法：\n暴力算法\n先将数组元素都平方，然后将数组重新排序\n双指针\n题目条件给出数组是非递减顺序排列的，对于正数来说，平方之后顺序不变，对于负数来说，平方之后顺序反转，所以平方后的最大值出现在数组开头或者结尾，最小值出现在数组中间。\n4. 628-三个数的最大乘积\n（1）题目条件：\n（2）题解：\n最大值可能出现的情况只有两种，一种是三个全是正数，即数组最大的三个正数，另一种是两个负数一个正数，最小的两个负数和最大的一个正数\n排序法\n非排序法\n是要找到最大的三个值和最小的两个值就可以了\n5. 219-存在重复元素II\n（1）题目条件：\n（2）题解：\n哈希表HashSet，HashSet继承于set类，set类的元素都是唯一的。\n算法步骤：\ni. 构造一个哈希表set，让哈希表的长度始终为k\nii. 遍历整个数组，看遍历的元素是否已经存在于set集合中了，若在集合中，则返回true，若没在集合中，则将该元素加入哈希表，若哈希表的长度超过k，则将最先加入的元素移除\n解法说明：https://leetcode-cn.com/problems/contains-duplicate-ii/solution/hua-jie-suan-fa-219-cun-zai-zhong-fu-yuan-su-ii-by/\n6. 228-汇总区间\n（1）题目条件：\n（2）题解：\n代码注意事项\ni.while(i < n && nums[i-1]+1 == nums[i])要先写i<n，因为若数组只有一个元素，则i<n是错误的直接不进行循环，但若是先写后面的条件，由于nums[i]不存在，所以会报错\n（这个问题找了好久）\nii. c++中存在string类，将数字转换成字符可以使用to_string函数，在后面添加元素可以用append函数\n7.1-两数之和\n（1）题目条件：\n（2）题解：\n暴力枚举\n哈希表\n8.167-两数之和II-输入有序数组\n（1）题目条件：\n（2）题解：\n利用数组有序的条件\n二分查找\n固定第一个值，寻找第二个值的时候用二分查找的方法能缩短查找时间，提高效率。\n双指针\n初始时将两个指针放在数组两侧，sum为两个指针指向数据之和\n若sum==target，则找到唯一解\n若sum<target，左指针向右移，增大sum\n若sum>target，右指针向左移，减小sum\n"
  },
  {
    "head": "软件构造博客6.final的功能用法总结",
    "paragraphs": [
      "关于final，相信使用过Java的人都对它不陌生，而本文则将对它的功能和用法进行总结。",
      "final关键字是一种变量前面的修饰符，代表着程序员的最终决策，final变量只能被赋值一次。",
      "例如以下例子",
      "以上两种方法都是错误的，因为对于double来说，final变量只能被赋值一次。同时对于基本的数值变量，比如int ,float , double, boolean ,其final一旦被确定则不可以进行任何修改。（如上面例子）",
      "然而对于那些可变的（mutable）对象（object）变量，比如Data类，stringbuilder等，final只是固定了对其的引用，并不能保证其中的值不被修改。",
      "如下例子：",
      "以上两种方法都是可行的，所以我们到底该怎么理解final呢？",
      "笔者的理解是：把final想象成一个固定的引用即可，对于基本变量类型，其被彻底固定，对于对象变量，我们仍可以使用其引用去修改它。"
    ],
    "sentences": [
      "关于final",
      "相信使用过Java的人都对它不陌生",
      "而本文则将对它的功能和用法进行总结",
      "final关键字是一种变量前面的修饰符",
      "代表着程序员的最终决策",
      "final变量只能被赋值一次",
      "例如以下例子",
      "以上两种方法都是错误的",
      "因为对于double来说",
      "final变量只能被赋值一次",
      "同时对于基本的数值变量",
      "比如int ,float , double, boolean ,其final一旦被确定则不可以进行任何修改",
      "（如上面例子）",
      "然而对于那些可变的（mutable）对象（object）变量",
      "比如Data类",
      "stringbuilder等",
      "final只是固定了对其的引用",
      "并不能保证其中的值不被修改",
      "如下例子：以上两种方法都是可行的",
      "所以我们到底该怎么理解final呢？",
      "笔者的理解是：把final想象成一个固定的引用即可",
      "对于基本变量类型",
      "其被彻底固定",
      "对于对象变量",
      "我们仍可以使用其引用去修改它"
    ],
    "codes": [
      "final double a = 3.1;\n\ta=3.1412; \n\n\nfinal double b;\n\tb=3.1;\n\tb=3.1412;",
      "final StringBuilder stringBuilder1 = new StringBuilder();\n\t    stringBuilder1.append(\"I am so smart...\");\n\t    System.out.print(stringBuilder1);\n\nfinal StringBuilder stringBuilder1 = new StringBuilder();\n\t    StringBuilder stringBuilder2 =stringBuilder1;\n\t    stringBuilder2.append(\"I am so smart...\");\n\t    System.out.print(stringBuilder1);\n\t\t\n"
    ],
    "date": "2021-07-02",
    "text": "关于final，相信使用过Java的人都对它不陌生，而本文则将对它的功能和用法进行总结。\nfinal关键字是一种变量前面的修饰符，代表着程序员的最终决策，final变量只能被赋值一次。\n例如以下例子\n以上两种方法都是错误的，因为对于double来说，final变量只能被赋值一次。同时对于基本的数值变量，比如int ,float , double, boolean ,其final一旦被确定则不可以进行任何修改。（如上面例子）\n然而对于那些可变的（mutable）对象（object）变量，比如Data类，stringbuilder等，final只是固定了对其的引用，并不能保证其中的值不被修改。\n如下例子：\n以上两种方法都是可行的，所以我们到底该怎么理解final呢？\n笔者的理解是：把final想象成一个固定的引用即可，对于基本变量类型，其被彻底固定，对于对象变量，我们仍可以使用其引用去修改它。\n"
  },
  {
    "head": "软件构造博客2.凸包问题的思考",
    "paragraphs": [
      "在进行软件构造Lab1的时候，相信大家都会遇到求解凸包问题，而很多人在第一次接触的时候难免会产生疑惑，笔者就这个问题谈一下自己的思考和解决方法：",
      "首先让我们明确一个问题：什么是凸包问题。",
      "凸包（Convex Hull）是一个计算几何（图形学）中的概念。在一个",
      "向量空间",
      "V中，对于给定集合P，所有包含P的",
      "S被称为P的凸包。P的凸包可以用P内所有点(p1，...Pn)的",
      "凸组合",
      "来构造。在二维",
      "欧几里得空间",
      "中，凸包可想象为一个正多边形，它的边界和内部包含着所有顶点。",
      "按照笔者的理解通俗来说，就是把所有顶点看作一堆木棒，现在你需要去找到一根绳子画一个范围，将所有的木棍包括在里面。很显然，就跟我们平时拿绳子捆木棍一样，绳子最先接触到的肯定是最外面的木棍，而凸包就是这些以这些最外面的木棍作为顶点构成的凸多边形。所以我们接下来的问题就是分析如何去找到这些最外面的“木棍”以及相应的时间复杂度。",
      "求解凸包问题主要有三种方法，本文主要讲解前两种方法：",
      "方法一.暴力破解",
      "没错，说到解决问题第一个思考的肯定是暴力求解。具体思想十分简单：对于一个n个点集合中的两个点p1和p2，当且仅当该集合中的其它点都位于穿过这两点的直线的同一边时，它们的连线就是该集合凸包边界的一部分，简言之，p1和p2就是凸包问题中最小凸多边形的顶点。对每一对点都做一遍检验之后，满足条件的线段就构成了该凸包的边界。",
      "在编写代码过程中，我们只需要建立一个直角坐标系，然后求出p1和p2的直线方程，然后将其他点代入方程计算结果是否全部大于等于0或者小于等于0，如果是则是凸包边界上的点，否则就不是。",
      "而本方法的时间复杂度比较容易分析，为O(n^3)。实现代码如下：",
      "方法二.Gift-wrapping算法",
      "本算法的基本思想为：遍历全部的点，找到最左侧的点，则这个点一定是凸包上的一个点，以这个点为凸包上的第一个点，初始角度为0°(相对于y轴正向的顺时针偏移)。接下来寻找凸包上的下一个点：遍历全部的点，找到从当前点的当前角度转向该点所需旋转最小角度的点。最后以寻找到的下一个点为当前点，当前角度更新为原角度加上旋转角度的和，然后继续去寻找下一个点，直到找到的下一个点为第一个时结束。",
      "而本算法因为每次的起点都是上次找到的凸包点，因此外层循环的复杂度为O(W)，W为凸包上的点，内层循环每次都会全部遍历点，因此时间复杂度为 O(n) ,因此总的是间复杂度为 O(nW) ,在一般情况下凸包上的点的期望为logn，算法复杂度为 O(nlogn) ,极端情况下，如下所示，所有点都在类似圆弧上的话，外层循环也是n，因此时间复杂度会达到O(n^2)。",
      "算法实现：",
      "方法三.Graham-Scan法",
      "本算法的思想是先找到凸包上的一个点，然后从那个点开始按逆时针方向逐个找凸包上的点，实际上就是进行极角排序，然后对其查询使用。时间复杂度为O（nlogn）。",
      "具体实现方法略，读者可自行查阅相关文章。同时我们可以证明凸包问题的解法的时间复杂度不会低于O（nlogn），具体证明也请读者自行进行。"
    ],
    "sentences": [
      "在进行软件构造Lab1的时候",
      "相信大家都会遇到求解凸包问题",
      "而很多人在第一次接触的时候难免会产生疑惑",
      "笔者就这个问题谈一下自己的思考和解决方法：首先让我们明确一个问题：什么是凸包问题",
      "凸包（Convex Hull）是一个计算几何（图形学）中的概念",
      "在一个",
      "向量空间",
      "V中，对于给定集合P，所有包含P的",
      "S被称为P的凸包",
      "P的凸包可以用P内所有点(p1，...Pn)的",
      "凸组合",
      "来构造",
      "在二维",
      "欧几里得空间",
      "中，凸包可想象为一个正多边形，它的边界和内部包含着所有顶点",
      "按照笔者的理解通俗来说",
      "就是把所有顶点看作一堆木棒",
      "现在你需要去找到一根绳子画一个范围",
      "将所有的木棍包括在里面",
      "很显然",
      "就跟我们平时拿绳子捆木棍一样",
      "绳子最先接触到的肯定是最外面的木棍",
      "而凸包就是这些以这些最外面的木棍作为顶点构成的凸多边形",
      "所以我们接下来的问题就是分析如何去找到这些最外面的“木棍”以及相应的时间复杂度",
      "求解凸包问题主要有三种方法",
      "本文主要讲解前两种方法：方法一.暴力破解",
      "没错，说到解决问题第一个思考的肯定是暴力求解",
      "具体思想十分简单：对于一个n个点集合中的两个点p1和p2",
      "当且仅当该集合中的其它点都位于穿过这两点的直线的同一边时",
      "它们的连线就是该集合凸包边界的一部分",
      "简言之",
      "p1和p2就是凸包问题中最小凸多边形的顶点",
      "对每一对点都做一遍检验之后",
      "满足条件的线段就构成了该凸包的边界",
      "在编写代码过程中",
      "我们只需要建立一个直角坐标系",
      "然后求出p1和p2的直线方程",
      "然后将其他点代入方程计算结果是否全部大于等于0或者小于等于0",
      "如果是则是凸包边界上的点",
      "否则就不是",
      "而本方法的时间复杂度比较容易分析，为O(n^3)",
      "实现代码如下：方法二.Gift-wrapping算法",
      "本算法的基本思想为：遍历全部的点",
      "找到最左侧的点",
      "则这个点一定是凸包上的一个点",
      "以这个点为凸包上的第一个点",
      "初始角度为0°(相对于y轴正向的顺时针偏移)",
      "接下来寻找凸包上的下一个点：遍历全部的点",
      "找到从当前点的当前角度转向该点所需旋转最小角度的点",
      "最后以寻找到的下一个点为当前点",
      "当前角度更新为原角度加上旋转角度的和",
      "然后继续去寻找下一个点",
      "直到找到的下一个点为第一个时结束",
      "而本算法因为每次的起点都是上次找到的凸包点",
      "因此外层循环的复杂度为O(W)",
      "W为凸包上的点",
      "内层循环每次都会全部遍历点",
      "因此时间复杂度为 O(n) ,因此总的是间复杂度为 O(nW) ,在一般情况下凸包上的点的期望为logn",
      "算法复杂度为 O(nlogn) ,极端情况下",
      "如下所示",
      "所有点都在类似圆弧上的话",
      "外层循环也是n",
      "因此时间复杂度会达到O(n^2)",
      "算法实现：方法三.Graham-Scan法",
      "本算法的思想是先找到凸包上的一个点",
      "然后从那个点开始按逆时针方向逐个找凸包上的点",
      "实际上就是进行极角排序",
      "然后对其查询使用",
      "时间复杂度为O（nlogn）",
      "具体实现方法略，读者可自行查阅相关文章",
      "同时我们可以证明凸包问题的解法的时间复杂度不会低于O（nlogn）",
      "具体证明也请读者自行进行"
    ],
    "codes": [
      "public class ConvexHull {\n    //返回点集合中凸多边形的点集合\n    public static Point[] getConvexPoint(Point[] A){\n        Point[] result = new Point[A.length];\n        int len = 0;  //用于计算最终返回结果中是凸包中点的个数\n        for(int i = 0;i < A.length;i++){\n            for(int j = 0;j < A.length;j++){\n                if(j == i)     //除去选中作为确定直线的第一个点\n                    continue;\n                \n                int[] judge = new int[A.length];   //存放点到直线距离所使用判断公式的结果\n                \n                for(int k = 0;k < A.length;k++){\n                    int a = A[j].getY() - A[i].getY();\n                    int b = A[i].getX() - A[j].getX();\n                    int c = (A[i].getX())*(A[j].getY()) - (A[i].getY())*(A[j].getX());\n\n                    judge[k] = a*(A[k].getX()) + b*(A[k].getY()) - c;  //根据公式计算具体判断结果\n                }\n                \n                if(JudgeArray(judge)){  // 如果点均在直线的一边,则相应的A[i]是凸包中的点\n                    result[len++] = A[i];\n                    break;\n                }    \n            }\n        }\n        Point[] result1 = new Point[len];\n        for(int m = 0;m < len;m++)\n            result1[m] = result[m];\n        return result1;\n    }\n    \n    //判断数组中元素是否全部大于等于0或者小于等于0，如果是则返回true，否则返回false\n    public static boolean JudgeArray(int[] Array){\n        boolean judge = false;\n        int len1 = 0, len2 = 0;\n        \n        for(int i = 0;i < Array.length;i++){\n            if(Array[i] >= 0)\n                len1++;\n        }\n        for(int j = 0;j < Array.length;j++){\n            if(Array[j] <= 0)\n                len2++;\n        }\n        \n        if(len1 == Array.length || len2 == Array.length)\n            judge = true;\n        return judge;\n    }",
      "public static Set<Point> convexHull(Set<Point> points) {\n        if(points.size()<=2) {\n            return points;\n        }\n        HashSet<Point> result =new HashSet<Point>();\n        Point tmp=points.iterator().next();\n        Point start = tmp;\n        Point targ = tmp;\n        double angle = 0,a1=0,at=0;\n        for(Point p:points) {\n            if(p.x()<start.x()||p.x()==start.x()&&p.y()>start.y())\n                start = p;\n        }\n        result.add(start);\n        Point ptr = start;\n        while(true) {\n            at=TurtleSoup.newCalculateBearingToPoint(angle, ptr.x(), ptr.y(), targ.x(), targ.y());\n            for(Point q:points) {\n                if(targ==q)\n                    continue;\n                a1=TurtleSoup.newCalculateBearingToPoint(angle, ptr.x(), ptr.y(), q.x(), q.y());\n                if(a1<at) {//选择偏转角度最小的\n                    targ =q;\n                    at=a1;\n                }else if(a1==at) {//选择距离更大的\n                    double dist=TurtleSoup.calculateDistance(ptr.x(), ptr.y(), targ.x(), targ.y());\n                    double dis1=TurtleSoup.calculateDistance(ptr.x(), ptr.y(), q.x(), q.y());\n                    if(dis1>dist) {\n                        targ=q;\n                        at=a1;\n                    }\n                }\n            }\n            if(targ == start)//终止条件\n                break;\n            else {\n                angle=at;\n                result.add(targ);\n                ptr =targ;\n            }\n        }\n        return result;\n    }"
    ],
    "date": "2021-07-01",
    "text": "在进行软件构造Lab1的时候，相信大家都会遇到求解凸包问题，而很多人在第一次接触的时候难免会产生疑惑，笔者就这个问题谈一下自己的思考和解决方法：\n首先让我们明确一个问题：什么是凸包问题。\n凸包（Convex Hull）是一个计算几何（图形学）中的概念。在一个\n向量空间\nV中，对于给定集合P，所有包含P的\nS被称为P的凸包。P的凸包可以用P内所有点(p1，...Pn)的\n凸组合\n来构造。在二维\n欧几里得空间\n中，凸包可想象为一个正多边形，它的边界和内部包含着所有顶点。\n按照笔者的理解通俗来说，就是把所有顶点看作一堆木棒，现在你需要去找到一根绳子画一个范围，将所有的木棍包括在里面。很显然，就跟我们平时拿绳子捆木棍一样，绳子最先接触到的肯定是最外面的木棍，而凸包就是这些以这些最外面的木棍作为顶点构成的凸多边形。所以我们接下来的问题就是分析如何去找到这些最外面的“木棍”以及相应的时间复杂度。\n求解凸包问题主要有三种方法，本文主要讲解前两种方法：\n方法一.暴力破解\n没错，说到解决问题第一个思考的肯定是暴力求解。具体思想十分简单：对于一个n个点集合中的两个点p1和p2，当且仅当该集合中的其它点都位于穿过这两点的直线的同一边时，它们的连线就是该集合凸包边界的一部分，简言之，p1和p2就是凸包问题中最小凸多边形的顶点。对每一对点都做一遍检验之后，满足条件的线段就构成了该凸包的边界。\n在编写代码过程中，我们只需要建立一个直角坐标系，然后求出p1和p2的直线方程，然后将其他点代入方程计算结果是否全部大于等于0或者小于等于0，如果是则是凸包边界上的点，否则就不是。\n而本方法的时间复杂度比较容易分析，为O(n^3)。实现代码如下：\n方法二.Gift-wrapping算法\n本算法的基本思想为：遍历全部的点，找到最左侧的点，则这个点一定是凸包上的一个点，以这个点为凸包上的第一个点，初始角度为0°(相对于y轴正向的顺时针偏移)。接下来寻找凸包上的下一个点：遍历全部的点，找到从当前点的当前角度转向该点所需旋转最小角度的点。最后以寻找到的下一个点为当前点，当前角度更新为原角度加上旋转角度的和，然后继续去寻找下一个点，直到找到的下一个点为第一个时结束。\n而本算法因为每次的起点都是上次找到的凸包点，因此外层循环的复杂度为O(W)，W为凸包上的点，内层循环每次都会全部遍历点，因此时间复杂度为 O(n) ,因此总的是间复杂度为 O(nW) ,在一般情况下凸包上的点的期望为logn，算法复杂度为 O(nlogn) ,极端情况下，如下所示，所有点都在类似圆弧上的话，外层循环也是n，因此时间复杂度会达到O(n^2)。\n算法实现：\n方法三.Graham-Scan法\n本算法的思想是先找到凸包上的一个点，然后从那个点开始按逆时针方向逐个找凸包上的点，实际上就是进行极角排序，然后对其查询使用。时间复杂度为O（nlogn）。\n具体实现方法略，读者可自行查阅相关文章。同时我们可以证明凸包问题的解法的时间复杂度不会低于O（nlogn），具体证明也请读者自行进行。\n"
  },
  {
    "head": "软件构造博客4.Git多分支操作",
    "paragraphs": [
      "在Lab3中，我们遇到了利用Git新建仓库和进行不同仓库的提交的操作，下文就这个问题给出较为详细的操作方法：",
      "首先还是Github仓库和本地仓库的设立，这部分过程在我的博客1当中有介绍，有这部分需求的同学可以移步博客1，下面就让我们来看看怎么进行分支操作：",
      "右击我们的本地仓库，选择Git Bash here，可以看到现在的默认分支为master，这时候我们想要新建一个分支change并且提交文件到Github的change分支上，则相关操作有：",
      "git branch change(如果你想新建的分支是别的名字的话，这里就修改成你想要的分支名)",
      "然后我们输入git branch，就发现现在有两个分支存在，而当前是位于master分支上，之后我们进行分支切换操作：",
      "通过git checkout change进行分支切换，为了验证我们再次输入git branch，可以看到现在指向的分支为change，证明我们切换分支成功，具体操作截图如下：",
      "之后的相关提交操作在我的博客1中有介绍，这里就不再介绍了，有需要的同学可以查看我的软件构造博客1。"
    ],
    "sentences": [
      "在Lab3中",
      "我们遇到了利用Git新建仓库和进行不同仓库的提交的操作",
      "下文就这个问题给出较为详细的操作方法：首先还是Github仓库和本地仓库的设立",
      "这部分过程在我的博客1当中有介绍",
      "有这部分需求的同学可以移步博客1",
      "下面就让我们来看看怎么进行分支操作：右击我们的本地仓库",
      "选择Git Bash here",
      "可以看到现在的默认分支为master",
      "这时候我们想要新建一个分支change并且提交文件到Github的change分支上",
      "则相关操作有：git branch change(如果你想新建的分支是别的名字的话",
      "这里就修改成你想要的分支名)",
      "然后我们输入git branch",
      "就发现现在有两个分支存在",
      "而当前是位于master分支上",
      "之后我们进行分支切换操作：通过git checkout change进行分支切换",
      "为了验证我们再次输入git branch",
      "可以看到现在指向的分支为change",
      "证明我们切换分支成功",
      "具体操作截图如下：之后的相关提交操作在我的博客1中有介绍",
      "这里就不再介绍了",
      "有需要的同学可以查看我的软件构造博客1"
    ],
    "codes": [],
    "date": "2021-07-01",
    "text": "在Lab3中，我们遇到了利用Git新建仓库和进行不同仓库的提交的操作，下文就这个问题给出较为详细的操作方法：\n首先还是Github仓库和本地仓库的设立，这部分过程在我的博客1当中有介绍，有这部分需求的同学可以移步博客1，下面就让我们来看看怎么进行分支操作：\n右击我们的本地仓库，选择Git Bash here，可以看到现在的默认分支为master，这时候我们想要新建一个分支change并且提交文件到Github的change分支上，则相关操作有：\ngit branch change(如果你想新建的分支是别的名字的话，这里就修改成你想要的分支名)\n然后我们输入git branch，就发现现在有两个分支存在，而当前是位于master分支上，之后我们进行分支切换操作：\n通过git checkout change进行分支切换，为了验证我们再次输入git branch，可以看到现在指向的分支为change，证明我们切换分支成功，具体操作截图如下：\n之后的相关提交操作在我的博客1中有介绍，这里就不再介绍了，有需要的同学可以查看我的软件构造博客1。\n"
  },
  {
    "head": "软件构造博客5.正则表达式梳理",
    "paragraphs": [
      "在Lab3的实现过程中涉及到正则表达式的解析，本文就这个问题给出相关知识点的梳理。",
      "首先我们先要了解什么是正则表达式。根据定义，正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。",
      "构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。",
      "正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为\"元字符\"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。",
      "在实际应用过程中我们使用grammar判断字符串是否合法，并解析成程序里使用的数据结构，通常是递归的数据结构。",
      "url ::=‘http://’ hostname ‘/’",
      "hostname ::= ‘mit.edu’ | ‘stanford.edu’ | ‘google.com’",
      "其中，url是根节点（特殊的非终止符），与’google.com’相似的是终止符，hosname是非终止符",
      "操作：",
      "连接： x ::= y z（空格）",
      "重复（0次或多次）：x::=y*",
      "选择：x::= y|z",
      "有无：x::= y?",
      "重复（1次或多次）：x::= y+",
      "区间：x::= [a-c] equals x::= ‘a’ | ‘b’ | ‘c’",
      "x ::= [aeiou] equals x::= ‘a’ | ‘e’ | ‘i’ | ‘o’ | ‘u’",
      "不包含区间：x::=[^a-c] equals x::= ‘d’ | ‘e’ | ‘f’ |…",
      "*?+ 优先级最高，连接次之，|最低",
      "而正则语法的定义为：简化之后可以表达为一个产生式而不包含任何非终止节点",
      "正则表达式的语法规则为："
    ],
    "sentences": [
      "在Lab3的实现过程中涉及到正则表达式的解析",
      "本文就这个问题给出相关知识点的梳理",
      "首先我们先要了解什么是正则表达式",
      "根据定义",
      "正则表达式(regular expression)描述了一种字符串匹配的模式（pattern）",
      "可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等",
      "构造正则表达式的方法和创建数学表达式的方法一样",
      "也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式",
      "正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合",
      "正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为\"元字符\"）组成的文字模式",
      "模式描述在搜索文本时要匹配的一个或多个字符串",
      "正则表达式作为一个模板",
      "将某个字符模式与所搜索的字符串进行匹配",
      "在实际应用过程中我们使用grammar判断字符串是否合法",
      "并解析成程序里使用的数据结构",
      "通常是递归的数据结构",
      "url ::=‘http://’ hostname ‘/’",
      "hostname ::= ‘mit.edu’ | ‘stanford.edu’ | ‘google.com’",
      "其中",
      "url是根节点（特殊的非终止符）",
      "与’google.com’相似的是终止符",
      "hosname是非终止符",
      "操作：连接： x ::= y z（空格）",
      "重复（0次或多次）：x::=y*",
      "选择：x::= y|z",
      "有无：x::= y?",
      "重复（1次或多次）：x::= y+",
      "区间：x::= [a-c] equals x::= ‘a’ | ‘b’ | ‘c’",
      "x ::= [aeiou] equals x::= ‘a’ | ‘e’ | ‘i’ | ‘o’ | ‘u’",
      "不包含区间：x::=[^a-c] equals x::= ‘d’ | ‘e’ | ‘f’ |…",
      "*?+ 优先级最高，连接次之，|最低",
      "而正则语法的定义为：简化之后可以表达为一个产生式而不包含任何非终止节点",
      "正则表达式的语法规则为："
    ],
    "codes": [],
    "date": "2021-07-02",
    "text": "在Lab3的实现过程中涉及到正则表达式的解析，本文就这个问题给出相关知识点的梳理。\n首先我们先要了解什么是正则表达式。根据定义，正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。\n正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为\"元字符\"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。\n在实际应用过程中我们使用grammar判断字符串是否合法，并解析成程序里使用的数据结构，通常是递归的数据结构。\nurl ::=‘http://’ hostname ‘/’\nhostname ::= ‘mit.edu’ | ‘stanford.edu’ | ‘google.com’\n其中，url是根节点（特殊的非终止符），与’google.com’相似的是终止符，hosname是非终止符\n操作：\n连接： x ::= y z（空格）\n重复（0次或多次）：x::=y*\n选择：x::= y|z\n有无：x::= y?\n重复（1次或多次）：x::= y+\n区间：x::= [a-c] equals x::= ‘a’ | ‘b’ | ‘c’\nx ::= [aeiou] equals x::= ‘a’ | ‘e’ | ‘i’ | ‘o’ | ‘u’\n不包含区间：x::=[^a-c] equals x::= ‘d’ | ‘e’ | ‘f’ |…\n*?+ 优先级最高，连接次之，|最低\n而正则语法的定义为：简化之后可以表达为一个产生式而不包含任何非终止节点\n正则表达式的语法规则为：\n"
  },
  {
    "head": "企业实训1.华为DevEco Studio 2.0问题简述",
    "paragraphs": [
      "春季学期终于结束了，然而“规格严格，功夫到家”的工大学子迅速开始了紧张刺激的夏季学期，夏季学期有一门叫做企业实训的选修(必修)课，我为了不去所谓的沈阳的企业(虽然最后学部安排的实训也挺不错)和另一名同学加入了老师的研究所。一周多下来，虽然我们还在和Ubuntu和DevEco较劲，但是也感觉学到了很多东西。",
      "本系列博客就是讲述笔者实训期间所碰到的问题和感想，以及实训过程中遇到的操作问题和解决方法。",
      "首先是DevEco Studio 2.0的下载和Sample跑通，这个工具好像是华为一个多月以前才推出的，用的人也不是特别多，导致我们无法面向CSDN编程了，还好最后还是顺利完成了47个Sample的跑通(除了那个鬼畜的不知道为什么要使用Openharmony的JShelloworld)，但是我在这里还是想吐槽几点：",
      "1.很多的Sample都要求使用API Version 6，然而在华为发行的Release的稳定版本中只支持导入API Version5，要想用API Version 6必须下载Beta版本，那你的Release版本设计出来到底为了什么呢emmmm",
      "2.虽然华为要求下载Beta版本的DevEco需要账号验证，但是你只要把这个工具关了，下一次使用就需要重新登陆验证，这也是我觉得十分不人性化的一个地方，讲道理你都推出这么多个版本了，这么影响开发者体验的功能还没有进行改善真的是不应该",
      "3.虚拟机型还不够多，尤其是针对分布式系统方面。就拿Sample中的DistributedScheduler来说，它的代码使用的是API Version 6，但是分布式虚拟机里根本没有设备是API Version 6的，这点也挺离谱的",
      "4.在实机导入Sample的时候无法进行自动签名，虽然根据文档上面说2.1Release版本及以后就都支持自动签名了，但是实际操作发现并不可以，还好最后用方式二解决了（这里还遇到一个让我现在都不知道为什么的一个问题==）",
      "除此之外的大大小小的一些问题就不再赘述了，不过这也是笔者接触的第一个国内厂商的开发工具，里面的功能也特别多，虽然还存在一些问题，但是还是要给予鼓励的。",
      "本来想在这篇博客中写一下OpenHarmony的源码获取过程以及问题解决方法的，但是笔者鸽子属性发作了，所以还是等到有时间了再写写吧= ="
    ],
    "sentences": [
      "春季学期终于结束了",
      "然而“规格严格",
      "功夫到家”的工大学子迅速开始了紧张刺激的夏季学期",
      "夏季学期有一门叫做企业实训的选修(必修)课",
      "我为了不去所谓的沈阳的企业(虽然最后学部安排的实训也挺不错)和另一名同学加入了老师的研究所",
      "一周多下来",
      "虽然我们还在和Ubuntu和DevEco较劲",
      "但是也感觉学到了很多东西",
      "本系列博客就是讲述笔者实训期间所碰到的问题和感想",
      "以及实训过程中遇到的操作问题和解决方法",
      "首先是DevEco Studio 2.0的下载和Sample跑通",
      "这个工具好像是华为一个多月以前才推出的",
      "用的人也不是特别多",
      "导致我们无法面向CSDN编程了",
      "还好最后还是顺利完成了47个Sample的跑通(除了那个鬼畜的不知道为什么要使用Openharmony的JShelloworld)",
      "但是我在这里还是想吐槽几点：1.很多的Sample都要求使用API Version 6",
      "然而在华为发行的Release的稳定版本中只支持导入API Version5",
      "要想用API Version 6必须下载Beta版本",
      "那你的Release版本设计出来到底为了什么呢emmmm",
      "2.虽然华为要求下载Beta版本的DevEco需要账号验证",
      "但是你只要把这个工具关了",
      "下一次使用就需要重新登陆验证",
      "这也是我觉得十分不人性化的一个地方",
      "讲道理你都推出这么多个版本了",
      "这么影响开发者体验的功能还没有进行改善真的是不应该",
      "3.虚拟机型还不够多，尤其是针对分布式系统方面",
      "就拿Sample中的DistributedScheduler来说",
      "它的代码使用的是API Version 6",
      "但是分布式虚拟机里根本没有设备是API Version 6的",
      "这点也挺离谱的",
      "4.在实机导入Sample的时候无法进行自动签名",
      "虽然根据文档上面说2.1Release版本及以后就都支持自动签名了",
      "但是实际操作发现并不可以",
      "还好最后用方式二解决了（这里还遇到一个让我现在都不知道为什么的一个问题==）",
      "除此之外的大大小小的一些问题就不再赘述了",
      "不过这也是笔者接触的第一个国内厂商的开发工具",
      "里面的功能也特别多",
      "虽然还存在一些问题",
      "但是还是要给予鼓励的",
      "本来想在这篇博客中写一下OpenHarmony的源码获取过程以及问题解决方法的",
      "但是笔者鸽子属性发作了",
      "所以还是等到有时间了再写写吧= ="
    ],
    "codes": [],
    "date": "2021-07-15",
    "text": "春季学期终于结束了，然而“规格严格，功夫到家”的工大学子迅速开始了紧张刺激的夏季学期，夏季学期有一门叫做企业实训的选修(必修)课，我为了不去所谓的沈阳的企业(虽然最后学部安排的实训也挺不错)和另一名同学加入了老师的研究所。一周多下来，虽然我们还在和Ubuntu和DevEco较劲，但是也感觉学到了很多东西。\n本系列博客就是讲述笔者实训期间所碰到的问题和感想，以及实训过程中遇到的操作问题和解决方法。\n首先是DevEco Studio 2.0的下载和Sample跑通，这个工具好像是华为一个多月以前才推出的，用的人也不是特别多，导致我们无法面向CSDN编程了，还好最后还是顺利完成了47个Sample的跑通(除了那个鬼畜的不知道为什么要使用Openharmony的JShelloworld)，但是我在这里还是想吐槽几点：\n1.很多的Sample都要求使用API Version 6，然而在华为发行的Release的稳定版本中只支持导入API Version5，要想用API Version 6必须下载Beta版本，那你的Release版本设计出来到底为了什么呢emmmm\n2.虽然华为要求下载Beta版本的DevEco需要账号验证，但是你只要把这个工具关了，下一次使用就需要重新登陆验证，这也是我觉得十分不人性化的一个地方，讲道理你都推出这么多个版本了，这么影响开发者体验的功能还没有进行改善真的是不应该\n3.虚拟机型还不够多，尤其是针对分布式系统方面。就拿Sample中的DistributedScheduler来说，它的代码使用的是API Version 6，但是分布式虚拟机里根本没有设备是API Version 6的，这点也挺离谱的\n4.在实机导入Sample的时候无法进行自动签名，虽然根据文档上面说2.1Release版本及以后就都支持自动签名了，但是实际操作发现并不可以，还好最后用方式二解决了（这里还遇到一个让我现在都不知道为什么的一个问题==）\n除此之外的大大小小的一些问题就不再赘述了，不过这也是笔者接触的第一个国内厂商的开发工具，里面的功能也特别多，虽然还存在一些问题，但是还是要给予鼓励的。\n本来想在这篇博客中写一下OpenHarmony的源码获取过程以及问题解决方法的，但是笔者鸽子属性发作了，所以还是等到有时间了再写写吧= =\n"
  },
  {
    "head": "软件构造博客3.代码测试思考",
    "paragraphs": [
      "相信很多同学都发现，每次的软件构造实验都要求我们进行测试代码的编写，而且课程中也很重视测试对于编程的作用，那么测试为什么这么重要呢，我们又该根据什么原则编写测试代码呢，本文就此问题给出笔者的一些看法。",
      "测试为什么那么重要",
      "在软件开发的过程中，我们提倡测试驱动开发(TDD)的方法，原因正是基于测试的重要性：",
      "1.测试是提高软件质量的重要手段",
      "2.测试可以确认开发的程序是否达到用户需求",
      "3.测试可以具体关注系统的某一特定方面的质量特性",
      "4.先进行测试可以节省大量的调试时间",
      "注：测试并不能保证程序100%没有错误！",
      "我们该如何进行测试",
      "按照老师PPT上的介绍，良好的测试应该有如下特点：",
      "1.能发现错误",
      "2.不冗余",
      "3.体现最佳特性",
      "4.别太复杂也别太简单",
      "而测试也是分层级的，从低到高依次为：",
      "单元测试: 是指对软件中的最小可测试单元进行检查和验证，Java里单元指一个类或一个方法",
      "集成测试：也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行测试",
      "系统测试：是对整个系统的测试，将硬件、软件、操作人员看作一个整体，检验它是否有不符合系统说明书的地方",
      "验收测试：是部署软件之前的最后一个测试操作。在软件产品完成了单元测试、集成测试和系统测试之后，产品发布之前所进行的软件测试活动。",
      "此外还有回归测试，它指的是修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。",
      "测试方法有白盒测试和黑盒测试：",
      "白盒测试：对程序内部代码结构的测试 ，要考虑内部实现细节",
      "黑盒测试：对程序外部表现出来的行为的测试，黑盒测试完 全从函数spec导出测试用例，不考虑函数内部实现",
      "而我们实验中主要采用的方法是根据等价类的划分来编写测试样例：",
      "基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例",
      "针对每个输 入数据需要满足的约束条件划分等价类",
      "每个等价类代表着对输入约束加以满足/违反的有效 /无效数据的集合 。",
      "而相似的输入，将会展示相似的行为。",
      "故可从每个等价类中选一个代表作为测试用例即可",
      "可以按照下面的准则划分：",
      "输入数据限定了数值范围",
      "输入数据指明了特定的值",
      "输入数据确定了一组数",
      "输入数据是Y/N",
      "笛卡尔积做到全覆盖和对于每个维度的取值则至少覆盖一次即可，测试完备，但用例数量多，前者测试代价高 但是并非所有组合情况都可能，后者测试用例少，代价低，但测试覆盖度未必高，通常情况下在这两个方案之间选取一个折衷的方案。",
      "以Lab2中ConcreteVerticesGraph的部分测试代码为例，读者自行体会这种以等价类划分为基础的测试样例编写："
    ],
    "sentences": [
      "相信很多同学都发现",
      "每次的软件构造实验都要求我们进行测试代码的编写",
      "而且课程中也很重视测试对于编程的作用",
      "那么测试为什么这么重要呢",
      "我们又该根据什么原则编写测试代码呢",
      "本文就此问题给出笔者的一些看法",
      "测试为什么那么重要",
      "在软件开发的过程中",
      "我们提倡测试驱动开发(TDD)的方法",
      "原因正是基于测试的重要性：1.测试是提高软件质量的重要手段",
      "2.测试可以确认开发的程序是否达到用户需求",
      "3.测试可以具体关注系统的某一特定方面的质量特性",
      "4.先进行测试可以节省大量的调试时间",
      "注：测试并不能保证程序100%没有错误！",
      "我们该如何进行测试",
      "按照老师PPT上的介绍",
      "良好的测试应该有如下特点：1.能发现错误",
      "2.不冗余",
      "3.体现最佳特性",
      "4.别太复杂也别太简单",
      "而测试也是分层级的",
      "从低到高依次为：单元测试: 是指对软件中的最小可测试单元进行检查和验证",
      "Java里单元指一个类或一个方法",
      "集成测试：也叫组装测试或联合测试",
      "在单元测试的基础上",
      "将所有模块按照设计要求组装成为子系统或系统",
      "进行测试",
      "系统测试：是对整个系统的测试",
      "将硬件、软件、操作人员看作一个整体",
      "检验它是否有不符合系统说明书的地方",
      "验收测试：是部署软件之前的最后一个测试操作",
      "在软件产品完成了单元测试、集成测试和系统测试之后",
      "产品发布之前所进行的软件测试活动",
      "此外还有回归测试",
      "它指的是修改了旧代码后",
      "重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误",
      "测试方法有白盒测试和黑盒测试：白盒测试：对程序内部代码结构的测试 ",
      "要考虑内部实现细节",
      "黑盒测试：对程序外部表现出来的行为的测试",
      "黑盒测试完 全从函数spec导出测试用例",
      "不考虑函数内部实现",
      "而我们实验中主要采用的方法是根据等价类的划分来编写测试样例：基于等价类划分的测试：将被测函数的输入域划分为等价类",
      "从等价类中导出测试用例",
      "针对每个输 入数据需要满足的约束条件划分等价类",
      "每个等价类代表着对输入约束加以满足/违反的有效 /无效数据的集合 ",
      "而相似的输入，将会展示相似的行为",
      "故可从每个等价类中选一个代表作为测试用例即可",
      "可以按照下面的准则划分：输入数据限定了数值范围",
      "输入数据指明了特定的值",
      "输入数据确定了一组数",
      "输入数据是Y/N",
      "笛卡尔积做到全覆盖和对于每个维度的取值则至少覆盖一次即可",
      "测试完备",
      "但用例数量多",
      "前者测试代价高 但是并非所有组合情况都可能",
      "后者测试用例少",
      "代价低",
      "但测试覆盖度未必高",
      "通常情况下在这两个方案之间选取一个折衷的方案",
      "以Lab2中ConcreteVerticesGraph的部分测试代码为例",
      "读者自行体会这种以等价类划分为基础的测试样例编写："
    ],
    "codes": [
      "// Testing strategy\n    // 按照加入的点划分：点已经存在，点不存在\n    // 按照加入的权值划分：权值为0，权值大于0，权值小于0\n    @Test\n\tpublic void testAddsource() {\n    \tVertex<String> vertex = new Vertex<String>(\"a\");\n    \tassertEquals(0, vertex.addSource(\"b\", 5));\n    \tassertEquals(0, vertex.addSource(\"c\", 3));\n    \tassertEquals(5, vertex.addSource(\"b\", 4));\n    \tassertEquals(4, vertex.addSource(\"b\", 0));\n    \tassertEquals(-1, vertex.addSource(\"b\", -1));\n    }\n    \n    // Testing strategy\n    // 按照加入的点划分：点已经存在，点不存在\n    // 按照加入的权值划分：权值为0，权值大于0，权值小于0\n    \n    @Test\n\tpublic void testAddtarget() {\n    \tVertex<String> vertex = new Vertex<String>(\"a\");\n    \tassertEquals(0, vertex.addTarget(\"b\", 5));\n    \tassertEquals(0, vertex.addTarget(\"c\", 3));\n    \tassertEquals(5, vertex.addTarget(\"b\", 4));\n    \tassertEquals(4, vertex.addTarget(\"b\", 0));\n    \tassertEquals(-1, vertex.addTarget(\"b\", -1));\n    }\n    \n    // Testing strategy\n    // 按照移除的点划分：点已经存在，点不存在\n    @Test\n\tpublic void testRemovesource() {\n    \tVertex<String> vertex = new Vertex<String>(\"a\");\n    \tvertex.addSource(\"b\", 5);\n    \tvertex.addSource(\"c\", 3);\n    \tassertEquals(0, vertex.removeSource(\"d\"));\n    \tassertEquals(5, vertex.removeSource(\"b\"));\n    }\n    \n    // Testing strategy\n    // 按照移除的点划分：点已经存在，点不存在\n     \n    @Test\n\tpublic void testRemovetarget() {\n    \tVertex<String> vertex = new Vertex<String>(\"a\");\n    \tvertex.addTarget(\"b\", 5);\n    \tvertex.addTarget(\"c\", 3);\n    \tassertEquals(0, vertex.removeTarget(\"d\"));\n    \tassertEquals(5, vertex.removeTarget(\"b\"));\n    }"
    ],
    "date": "2021-07-01",
    "text": "相信很多同学都发现，每次的软件构造实验都要求我们进行测试代码的编写，而且课程中也很重视测试对于编程的作用，那么测试为什么这么重要呢，我们又该根据什么原则编写测试代码呢，本文就此问题给出笔者的一些看法。\n测试为什么那么重要\n在软件开发的过程中，我们提倡测试驱动开发(TDD)的方法，原因正是基于测试的重要性：\n1.测试是提高软件质量的重要手段\n2.测试可以确认开发的程序是否达到用户需求\n3.测试可以具体关注系统的某一特定方面的质量特性\n4.先进行测试可以节省大量的调试时间\n注：测试并不能保证程序100%没有错误！\n我们该如何进行测试\n按照老师PPT上的介绍，良好的测试应该有如下特点：\n1.能发现错误\n2.不冗余\n3.体现最佳特性\n4.别太复杂也别太简单\n而测试也是分层级的，从低到高依次为：\n单元测试: 是指对软件中的最小可测试单元进行检查和验证，Java里单元指一个类或一个方法\n集成测试：也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行测试\n系统测试：是对整个系统的测试，将硬件、软件、操作人员看作一个整体，检验它是否有不符合系统说明书的地方\n验收测试：是部署软件之前的最后一个测试操作。在软件产品完成了单元测试、集成测试和系统测试之后，产品发布之前所进行的软件测试活动。\n此外还有回归测试，它指的是修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。\n测试方法有白盒测试和黑盒测试：\n白盒测试：对程序内部代码结构的测试 ，要考虑内部实现细节\n黑盒测试：对程序外部表现出来的行为的测试，黑盒测试完 全从函数spec导出测试用例，不考虑函数内部实现\n而我们实验中主要采用的方法是根据等价类的划分来编写测试样例：\n基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例\n针对每个输 入数据需要满足的约束条件划分等价类\n每个等价类代表着对输入约束加以满足/违反的有效 /无效数据的集合 。\n而相似的输入，将会展示相似的行为。\n故可从每个等价类中选一个代表作为测试用例即可\n可以按照下面的准则划分：\n输入数据限定了数值范围\n输入数据指明了特定的值\n输入数据确定了一组数\n输入数据是Y/N\n笛卡尔积做到全覆盖和对于每个维度的取值则至少覆盖一次即可，测试完备，但用例数量多，前者测试代价高 但是并非所有组合情况都可能，后者测试用例少，代价低，但测试覆盖度未必高，通常情况下在这两个方案之间选取一个折衷的方案。\n以Lab2中ConcreteVerticesGraph的部分测试代码为例，读者自行体会这种以等价类划分为基础的测试样例编写：\n"
  },
  {
    "head": "软件构造博客1. Git的相关操作和使用",
    "paragraphs": [
      "博客主要讲述笔者实验中遇到的一些问题的解决方法：",
      "在开始软件构造实验的时候，相信大家都会对利用Git进行提交文件到Github上的指令有困惑，本文就这个问题给出了较为详细的操作步骤。",
      "Git的相关安装操作实验手册上面已经有了介绍，这里就不再赘述。同时你还需要一个Github账号和仓库（感觉在说废话。。）。",
      "1.打开你的Github仓库，点击code，将上面的URL复制下来（其实直接利用浏览器复制也可以）",
      "2.然后去本地建立仓库与Github上的仓库相关联，找到你想建立本地仓库的位置，右击，如果你之前成功安装了Git的话，会出现Git Bash here，点击它。",
      "3.在命令行中输入git clone https...(就是你从Github上复制得来的URL)",
      "然后我们就会发现在你创建的地方出现了一个和你Github仓库名一样的文件夹，那就是你和Github仓库相关联的本地仓库文件夹。接下来我们就要通过本地仓库将文件提交到Github仓库中。",
      "4.将你想要提交的文件全部放入本地文件夹中，然后进入Git bash，在命令行中输入如下代码：",
      "git add . （此操作是把文件夹下面的文件进行添加）",
      "git commit -m ”随便写（提交信息）” （提交信息随便写，但是在软件开发的过程中最好是你实验的进度）",
      "git push -u origin master（分支名） （本操作是将本地仓库push到github上面的master分支，如果交到其他分支上需要修改分支名字，第一次操作可能需要你输入帐号和密码）",
      "完成这些操作后，我们打开我们的Github仓库以后就能看到我们提交之后的结果了。",
      "除了上面以外，还有一些笔者在实际实验过后得出的一点可能称得上是建议的几点：",
      "1.虽然Github也能手动提交，但是效率比较低，而且如果验收方是利用软件进行文件的检查的话手动提交的文件可能不会被查到，而且利用Git提交还能让开发者在Github上看清每次提交的差别，因此实际应用中笔者还是鼓励大家利用Git将提交到Github上。",
      "2.虽然我们学校的WIFI自称能够直接访问Github，但是根据笔者自身体验下来，这种情况很少，甚至几乎没有==，不知道别的同学是不是跟我一样，所以还是鼓励大家在进行访问和提交操作的时候进行一些合理的“科学上网”，从而提高使用Git和Github的体验。"
    ],
    "sentences": [
      "博客主要讲述笔者实验中遇到的一些问题的解决方法：在开始软件构造实验的时候",
      "相信大家都会对利用Git进行提交文件到Github上的指令有困惑",
      "本文就这个问题给出了较为详细的操作步骤",
      "Git的相关安装操作实验手册上面已经有了介绍，这里就不再赘述",
      "同时你还需要一个Github账号和仓库（感觉在说废话",
      "）",
      "1.打开你的Github仓库",
      "点击code",
      "将上面的URL复制下来（其实直接利用浏览器复制也可以）",
      "2.然后去本地建立仓库与Github上的仓库相关联",
      "找到你想建立本地仓库的位置",
      "右击",
      "如果你之前成功安装了Git的话",
      "会出现Git Bash here",
      "点击它",
      "3.在命令行中输入git clone https...(就是你从Github上复制得来的URL)",
      "然后我们就会发现在你创建的地方出现了一个和你Github仓库名一样的文件夹",
      "那就是你和Github仓库相关联的本地仓库文件夹",
      "接下来我们就要通过本地仓库将文件提交到Github仓库中",
      "4.将你想要提交的文件全部放入本地文件夹中",
      "然后进入Git bash",
      "在命令行中输入如下代码：git add . （此操作是把文件夹下面的文件进行添加）",
      "git commit -m ”随便写（提交信息）” （提交信息随便写",
      "但是在软件开发的过程中最好是你实验的进度）",
      "git push -u origin master（分支名） （本操作是将本地仓库push到github上面的master分支",
      "如果交到其他分支上需要修改分支名字",
      "第一次操作可能需要你输入帐号和密码）",
      "完成这些操作后",
      "我们打开我们的Github仓库以后就能看到我们提交之后的结果了",
      "除了上面以外",
      "还有一些笔者在实际实验过后得出的一点可能称得上是建议的几点：1.虽然Github也能手动提交",
      "但是效率比较低",
      "而且如果验收方是利用软件进行文件的检查的话手动提交的文件可能不会被查到",
      "而且利用Git提交还能让开发者在Github上看清每次提交的差别",
      "因此实际应用中笔者还是鼓励大家利用Git将提交到Github上",
      "2.虽然我们学校的WIFI自称能够直接访问Github",
      "但是根据笔者自身体验下来",
      "这种情况很少",
      "甚至几乎没有==",
      "不知道别的同学是不是跟我一样",
      "所以还是鼓励大家在进行访问和提交操作的时候进行一些合理的“科学上网”",
      "从而提高使用Git和Github的体验"
    ],
    "codes": [],
    "date": "2021-06-30",
    "text": "博客主要讲述笔者实验中遇到的一些问题的解决方法：\n在开始软件构造实验的时候，相信大家都会对利用Git进行提交文件到Github上的指令有困惑，本文就这个问题给出了较为详细的操作步骤。\nGit的相关安装操作实验手册上面已经有了介绍，这里就不再赘述。同时你还需要一个Github账号和仓库（感觉在说废话。。）。\n1.打开你的Github仓库，点击code，将上面的URL复制下来（其实直接利用浏览器复制也可以）\n2.然后去本地建立仓库与Github上的仓库相关联，找到你想建立本地仓库的位置，右击，如果你之前成功安装了Git的话，会出现Git Bash here，点击它。\n3.在命令行中输入git clone https...(就是你从Github上复制得来的URL)\n然后我们就会发现在你创建的地方出现了一个和你Github仓库名一样的文件夹，那就是你和Github仓库相关联的本地仓库文件夹。接下来我们就要通过本地仓库将文件提交到Github仓库中。\n4.将你想要提交的文件全部放入本地文件夹中，然后进入Git bash，在命令行中输入如下代码：\ngit add . （此操作是把文件夹下面的文件进行添加）\ngit commit -m ”随便写（提交信息）” （提交信息随便写，但是在软件开发的过程中最好是你实验的进度）\ngit push -u origin master（分支名） （本操作是将本地仓库push到github上面的master分支，如果交到其他分支上需要修改分支名字，第一次操作可能需要你输入帐号和密码）\n完成这些操作后，我们打开我们的Github仓库以后就能看到我们提交之后的结果了。\n除了上面以外，还有一些笔者在实际实验过后得出的一点可能称得上是建议的几点：\n1.虽然Github也能手动提交，但是效率比较低，而且如果验收方是利用软件进行文件的检查的话手动提交的文件可能不会被查到，而且利用Git提交还能让开发者在Github上看清每次提交的差别，因此实际应用中笔者还是鼓励大家利用Git将提交到Github上。\n2.虽然我们学校的WIFI自称能够直接访问Github，但是根据笔者自身体验下来，这种情况很少，甚至几乎没有==，不知道别的同学是不是跟我一样，所以还是鼓励大家在进行访问和提交操作的时候进行一些合理的“科学上网”，从而提高使用Git和Github的体验。\n"
  },
  {
    "head": "软件构造4",
    "paragraphs": [
      "1.参数类型是否匹配，在静态类型检查阶段完成。返回值类型是否匹配，也在静态类型检查阶段完成。",
      "2.精确的规约有助于划分责任，规约可以扮演防火墙的角色。只讲能做什么，不讲怎么实现。可以通过规约判断方法的等价性。",
      "3. 静态类型声明是一种规约，可据此进行静态类型检查static checking。",
      "4. spec变强：更放松的前置条件+更严格的后置条件。在比较后置条件时，应该在满足对方的前置条件的情况下进行判断。一旦规约1比规约2强，那么可以用规约1替换规约2。",
      "5.抽象数据型由操作定义，与内部实现无关。",
      "6.可变与不可变数据类型。可变数据类型：提供了可改变其内部数据的值的操作。不可变数据类型： 其操作不改变内部值，而是构造新的对象。",
      "7.构造器：可能实现为构造函数或静态函数。构造器被实现为静态函数，通常被称为工厂方法。工厂方法用于创建对象，属于静态方法；实例方法在创建对象后才能调用函数并且工作。",
      "生产器：新产生的数据与旧的数据类型一致。",
      "观察器：数据类型不一致。",
      "变值器：改变函数内部对象属性的方法。变值器通常返回void则必然意味着它改变了对象的某些内部状态。也可能返回非空类型。",
      "8. 抽象空间A：抽象值构成的空间，即client看到和使用的值。表示空间R：内部表示的值构成的空间，其中既有非法的表示值，也有合法的表示值。AF：表示空间R与抽象空间A的映射关系。一定是满射，但未必是单射，也未必是双射。即R中的非法值没有映射对象，R中的多个合法值可能映射到A中相同的值。AF应当显示的以注释的形式写在代码中，以便于理解。",
      "9.表示独立性：不暴露内部属性与实现方法。",
      "10.RI：一种要求，说明R中的值哪些是合法的，哪些是非法的。RI也应该显示的以注释的形式写在代码中，用于时刻提醒自己。",
      "11.在所有可能改变rep的方法内都应该调用checkRep来检查。checkRep只是自己用于在编程时防止出错或产生非法的表示值所定义的方法。这是一个良好的编程习惯。",
      "12.设计ADT方法：(1) 选择R和A；(2) RI ：合法的表示值；(3) AF：如何解释合法的表示值 。"
    ],
    "sentences": [
      "1.参数类型是否匹配，在静态类型检查阶段完成",
      "返回值类型是否匹配，也在静态类型检查阶段完成",
      "2.精确的规约有助于划分责任，规约可以扮演防火墙的角色",
      "只讲能做什么，不讲怎么实现",
      "可以通过规约判断方法的等价性",
      "3. 静态类型声明是一种规约",
      "可据此进行静态类型检查static checking",
      "4. spec变强：更放松的前置条件+更严格的后置条件",
      "在比较后置条件时，应该在满足对方的前置条件的情况下进行判断",
      "一旦规约1比规约2强，那么可以用规约1替换规约2",
      "5.抽象数据型由操作定义，与内部实现无关",
      "6.可变与不可变数据类型",
      "可变数据类型：提供了可改变其内部数据的值的操作",
      "不可变数据类型： 其操作不改变内部值，而是构造新的对象",
      "7.构造器：可能实现为构造函数或静态函数",
      "构造器被实现为静态函数，通常被称为工厂方法",
      "工厂方法用于创建对象",
      "属于静态方法；实例方法在创建对象后才能调用函数并且工作",
      "生产器：新产生的数据与旧的数据类型一致",
      "观察器：数据类型不一致",
      "变值器：改变函数内部对象属性的方法",
      "变值器通常返回void则必然意味着它改变了对象的某些内部状态",
      "也可能返回非空类型",
      "8. 抽象空间A：抽象值构成的空间",
      "即client看到和使用的值",
      "表示空间R：内部表示的值构成的空间",
      "其中既有非法的表示值",
      "也有合法的表示值",
      "AF：表示空间R与抽象空间A的映射关系",
      "一定是满射，但未必是单射，也未必是双射",
      "即R中的非法值没有映射对象",
      "R中的多个合法值可能映射到A中相同的值",
      "AF应当显示的以注释的形式写在代码中，以便于理解",
      "9.表示独立性：不暴露内部属性与实现方法",
      "10.RI：一种要求，说明R中的值哪些是合法的，哪些是非法的",
      "RI也应该显示的以注释的形式写在代码中，用于时刻提醒自己",
      "11.在所有可能改变rep的方法内都应该调用checkRep来检查",
      "checkRep只是自己用于在编程时防止出错或产生非法的表示值所定义的方法",
      "这是一个良好的编程习惯",
      "12.设计ADT方法：(1) 选择R和A；(2) RI ：合法的表示值；(3) AF：如何解释合法的表示值 "
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "1.参数类型是否匹配，在静态类型检查阶段完成。返回值类型是否匹配，也在静态类型检查阶段完成。\n2.精确的规约有助于划分责任，规约可以扮演防火墙的角色。只讲能做什么，不讲怎么实现。可以通过规约判断方法的等价性。\n3. 静态类型声明是一种规约，可据此进行静态类型检查static checking。\n4. spec变强：更放松的前置条件+更严格的后置条件。在比较后置条件时，应该在满足对方的前置条件的情况下进行判断。一旦规约1比规约2强，那么可以用规约1替换规约2。\n5.抽象数据型由操作定义，与内部实现无关。\n6.可变与不可变数据类型。可变数据类型：提供了可改变其内部数据的值的操作。不可变数据类型： 其操作不改变内部值，而是构造新的对象。\n7.构造器：可能实现为构造函数或静态函数。构造器被实现为静态函数，通常被称为工厂方法。工厂方法用于创建对象，属于静态方法；实例方法在创建对象后才能调用函数并且工作。\n生产器：新产生的数据与旧的数据类型一致。\n观察器：数据类型不一致。\n变值器：改变函数内部对象属性的方法。变值器通常返回void则必然意味着它改变了对象的某些内部状态。也可能返回非空类型。\n8. 抽象空间A：抽象值构成的空间，即client看到和使用的值。表示空间R：内部表示的值构成的空间，其中既有非法的表示值，也有合法的表示值。AF：表示空间R与抽象空间A的映射关系。一定是满射，但未必是单射，也未必是双射。即R中的非法值没有映射对象，R中的多个合法值可能映射到A中相同的值。AF应当显示的以注释的形式写在代码中，以便于理解。\n9.表示独立性：不暴露内部属性与实现方法。\n10.RI：一种要求，说明R中的值哪些是合法的，哪些是非法的。RI也应该显示的以注释的形式写在代码中，用于时刻提醒自己。\n11.在所有可能改变rep的方法内都应该调用checkRep来检查。checkRep只是自己用于在编程时防止出错或产生非法的表示值所定义的方法。这是一个良好的编程习惯。\n12.设计ADT方法：(1) 选择R和A；(2) RI ：合法的表示值；(3) AF：如何解释合法的表示值 。\n"
  },
  {
    "head": "软件构造3",
    "paragraphs": [
      "继承关系可以有效地在先前定义的某个类的基础上实现其定义的所有方法功能，并添加自己的独特方法功能。继承关系不仅能够体现复用的价值，还能够使设计思路变得清晰，逻辑结构更加鲜明。同时能够减少工作量，也更容易应对新的变化。",
      "在继承时应遵循LSP原则，final定义的类无法派生出子类，且子类应比父类具有更强的规约、更强的不变量。子类型可以增加方法，但是不能删除。子类型需要实现抽象类型中的所有未实现方法。子类型中可以重写父类型中的方法，但是需要满足子类型方法的参数满足逆变、子类型方法的返回值满足协变且子类型不能抛出比父类型更多的异常。",
      "逆变的过程是参数不便或变得越来越抽象的过程，如从String变为Object，但是目前java中遇到这种情况只能当做overload看待。"
    ],
    "sentences": [
      "继承关系可以有效地在先前定义的某个类的基础上实现其定义的所有方法功能",
      "并添加自己的独特方法功能",
      "继承关系不仅能够体现复用的价值",
      "还能够使设计思路变得清晰",
      "逻辑结构更加鲜明",
      "同时能够减少工作量，也更容易应对新的变化",
      "在继承时应遵循LSP原则",
      "final定义的类无法派生出子类",
      "且子类应比父类具有更强的规约、更强的不变量",
      "子类型可以增加方法，但是不能删除",
      "子类型需要实现抽象类型中的所有未实现方法",
      "子类型中可以重写父类型中的方法",
      "但是需要满足子类型方法的参数满足逆变、子类型方法的返回值满足协变且子类型不能抛出比父类型更多的异常",
      "逆变的过程是参数不便或变得越来越抽象的过程",
      "如从String变为Object",
      "但是目前java中遇到这种情况只能当做overload看待"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "继承关系可以有效地在先前定义的某个类的基础上实现其定义的所有方法功能，并添加自己的独特方法功能。继承关系不仅能够体现复用的价值，还能够使设计思路变得清晰，逻辑结构更加鲜明。同时能够减少工作量，也更容易应对新的变化。\n在继承时应遵循LSP原则，final定义的类无法派生出子类，且子类应比父类具有更强的规约、更强的不变量。子类型可以增加方法，但是不能删除。子类型需要实现抽象类型中的所有未实现方法。子类型中可以重写父类型中的方法，但是需要满足子类型方法的参数满足逆变、子类型方法的返回值满足协变且子类型不能抛出比父类型更多的异常。\n逆变的过程是参数不便或变得越来越抽象的过程，如从String变为Object，但是目前java中遇到这种情况只能当做overload看待。\n"
  },
  {
    "head": "软件构造1",
    "paragraphs": [
      "在经过一段时间的软件构造课程以及java编程的学习过后，本人总结了许多收获与先前未曾了解的知识，在此将分成几个部分进行阐述。",
      "1.接口以及面向对象的编程",
      "对于java语言来说，最突出的优势就在于其面向对象的编程能力。其中接口是很方便的一个工具。当接口被定义好后，后续可以有多种实现。当完成这些不同的实现后，可以根据具体的需求来使用不同的实现。这样可以很好地进行复用。在具体的需求发生变化时，也可以更加灵活地进行调整与改变，而不需要像面向过程的编程那样需要调整许多代码，且每面临一次变化都需要调整一次代码，这样的代价未免过高，也不适合进行维护。所以，接口就显示出了独特的优势。",
      "2.测试驱动的编程",
      "经过这一段时间的编程体会，我深刻地感受到了测试驱动的编程带来的好处。在每次编写代码的实现之前，先写好测试用例是一个非常好的习惯。测试用例不仅可以全面地测试我们的实现代码，更重要的是能够引导我们的编程思路。同时，当完成了测试用例后，在编写实现的过程中可以随时进行测试，这样便于我们随时发现并更改实现中的错误。若总是先将实现写好后再编写测试用例，则若测试用例不通过的话我们也很难找出代码中的错误，这样便会浪费大量的时间。同时，若测试用例的编写全面的话，也会使我们注意到一些我们未曾发觉的潜在的风险，或是在我们的实现中并未考虑到的情况。所以测试驱动的编程会带来许多好处。再编写测试用例时，要做到全面、精简。要划分好等价类，并用笛卡尔乘积全覆盖的方式进行编写，以保证各个情况的分类的组合都能够测试的到。同时也要注意精简，不必重复很多相似或同类的测试用例。"
    ],
    "sentences": [
      "在经过一段时间的软件构造课程以及java编程的学习过后",
      "本人总结了许多收获与先前未曾了解的知识",
      "在此将分成几个部分进行阐述",
      "1.接口以及面向对象的编程",
      "对于java语言来说，最突出的优势就在于其面向对象的编程能力",
      "其中接口是很方便的一个工具",
      "当接口被定义好后，后续可以有多种实现",
      "当完成这些不同的实现后，可以根据具体的需求来使用不同的实现",
      "这样可以很好地进行复用",
      "在具体的需求发生变化时",
      "也可以更加灵活地进行调整与改变",
      "而不需要像面向过程的编程那样需要调整许多代码",
      "且每面临一次变化都需要调整一次代码",
      "这样的代价未免过高",
      "也不适合进行维护",
      "所以，接口就显示出了独特的优势",
      "2.测试驱动的编程",
      "经过这一段时间的编程体会",
      "我深刻地感受到了测试驱动的编程带来的好处",
      "在每次编写代码的实现之前，先写好测试用例是一个非常好的习惯",
      "测试用例不仅可以全面地测试我们的实现代码",
      "更重要的是能够引导我们的编程思路",
      "同时",
      "当完成了测试用例后",
      "在编写实现的过程中可以随时进行测试",
      "这样便于我们随时发现并更改实现中的错误",
      "若总是先将实现写好后再编写测试用例",
      "则若测试用例不通过的话我们也很难找出代码中的错误",
      "这样便会浪费大量的时间",
      "同时",
      "若测试用例的编写全面的话",
      "也会使我们注意到一些我们未曾发觉的潜在的风险",
      "或是在我们的实现中并未考虑到的情况",
      "所以测试驱动的编程会带来许多好处",
      "再编写测试用例时，要做到全面、精简",
      "要划分好等价类",
      "并用笛卡尔乘积全覆盖的方式进行编写",
      "以保证各个情况的分类的组合都能够测试的到",
      "同时也要注意精简，不必重复很多相似或同类的测试用例"
    ],
    "codes": [],
    "date": "2021-07-04",
    "text": "在经过一段时间的软件构造课程以及java编程的学习过后，本人总结了许多收获与先前未曾了解的知识，在此将分成几个部分进行阐述。\n1.接口以及面向对象的编程\n对于java语言来说，最突出的优势就在于其面向对象的编程能力。其中接口是很方便的一个工具。当接口被定义好后，后续可以有多种实现。当完成这些不同的实现后，可以根据具体的需求来使用不同的实现。这样可以很好地进行复用。在具体的需求发生变化时，也可以更加灵活地进行调整与改变，而不需要像面向过程的编程那样需要调整许多代码，且每面临一次变化都需要调整一次代码，这样的代价未免过高，也不适合进行维护。所以，接口就显示出了独特的优势。\n2.测试驱动的编程\n经过这一段时间的编程体会，我深刻地感受到了测试驱动的编程带来的好处。在每次编写代码的实现之前，先写好测试用例是一个非常好的习惯。测试用例不仅可以全面地测试我们的实现代码，更重要的是能够引导我们的编程思路。同时，当完成了测试用例后，在编写实现的过程中可以随时进行测试，这样便于我们随时发现并更改实现中的错误。若总是先将实现写好后再编写测试用例，则若测试用例不通过的话我们也很难找出代码中的错误，这样便会浪费大量的时间。同时，若测试用例的编写全面的话，也会使我们注意到一些我们未曾发觉的潜在的风险，或是在我们的实现中并未考虑到的情况。所以测试驱动的编程会带来许多好处。再编写测试用例时，要做到全面、精简。要划分好等价类，并用笛卡尔乘积全覆盖的方式进行编写，以保证各个情况的分类的组合都能够测试的到。同时也要注意精简，不必重复很多相似或同类的测试用例。\n"
  },
  {
    "head": "软件构造5",
    "paragraphs": [
      "由于软件构造课程需要用到git来提交实验结果，而本人是第一次使用到git，在使用过程中遇到了许多问题，故在此记录下一些git的使用方法以及一些问题的处理。",
      "一.仓库克隆",
      "1.右键点击要克隆到的本地文件夹，选择git bash here。",
      "2.在命令行中输入git clone +要克隆的仓库的URL地址，回车，即可将远程的github上的仓库中的东西克隆到本地的文件夹中。",
      "二.提交",
      "1.右键点击要提交的文件或项目文件夹，选择git bash here。",
      "2.输入git init命令，回车，用来在当前项目的目录中生成本地的git管理库，我们可以发现在当前目录下多了一个.git的隐藏文件夹。此步骤即为初始化本地仓库。",
      "3.输入git add ./git add *命令，回车，将项目中所有的文件添加到缓存区中。如果想添加特定文件，把.换成对应的文件名即可。",
      "4.输入git commit -m \"first commit\"命令，回车，即可将缓存区中的文件提交到本地仓库中。其中双引号中的内容为注释，可以根据个人需要进行修改。",
      "5.如果是第一次操作，可能会出现需要输入邮箱以及名字的提示，根据提示输入完毕后，再次输入git commit -m \"first commit\"即可。",
      "6.输入git remote add origin +自己的仓库URL地址，回车。即可将本地仓库连接到远程仓库，即github上的仓库。",
      "7.输入git push origin master，回车，将本地仓库中master分支上的内容上传到github仓库中，等待一会后看到文件上传的过程显示完成后即为提交成功。",
      "注：在git push的过程中可能会弹出failed to access或timed out等提示，这些提示并不是说明提交的过程出错，而是只是因为网络的问题暂时无法连接到远程仓库，遇到这些问题时可以尝试反复提交直到成功为止，或使用加速器进行提交。没有意外情况的话多尝试几次即可成功。",
      "三.创建新分支",
      "1.右键点击要创建新分支的文件或项目文件夹，选择git bash here。",
      "2.输入",
      "git checkout -b +新的分支名，回车，即可",
      "创建新分支。这时可以看到文件夹后面的分支名变为了新建立的分支名。",
      "3.然后即可依照二中的步骤在新的分支上进行添加文件到缓存区并将缓存区的文件提交到本地仓库等操作。",
      "4.如果需要将新的分支提交到github，则需要",
      "输入git push origin +新的分支名，回车，即可向上述过程那样将文件或项目提交到远程仓库。",
      "5.如需切换回master分支，可以输入",
      "git checkout master，回车即可。想切换到其他分支只需要输入git checkout",
      "+分支名即可。",
      "注：在切换分支后，本地文件夹中文件的内容会根据分支的不同进行改变。其内容会与本地仓库中文件的内容保持同步，故在切换分支进行文件更改时需要注意。且若其中一个分支中的本地文件被修改，在切换到其他分支前需要先将修改后的内容提交，再切换分支，否则修改后的内容无法保存。"
    ],
    "sentences": [
      "由于软件构造课程需要用到git来提交实验结果",
      "而本人是第一次使用到git",
      "在使用过程中遇到了许多问题",
      "故在此记录下一些git的使用方法以及一些问题的处理",
      "一.仓库克隆",
      "1.右键点击要克隆到的本地文件夹",
      "选择git bash here",
      "2.在命令行中输入git clone +要克隆的仓库的URL地址",
      "回车",
      "即可将远程的github上的仓库中的东西克隆到本地的文件夹中",
      "二.提交",
      "1.右键点击要提交的文件或项目文件夹",
      "选择git bash here",
      "2.输入git init命令",
      "回车",
      "用来在当前项目的目录中生成本地的git管理库",
      "我们可以发现在当前目录下多了一个.git的隐藏文件夹",
      "此步骤即为初始化本地仓库",
      "3.输入git add ./git add *命令",
      "回车",
      "将项目中所有的文件添加到缓存区中",
      "如果想添加特定文件，把.换成对应的文件名即可",
      "4.输入git commit -m \"first commit\"命令",
      "回车",
      "即可将缓存区中的文件提交到本地仓库中",
      "其中双引号中的内容为注释，可以根据个人需要进行修改",
      "5.如果是第一次操作",
      "可能会出现需要输入邮箱以及名字的提示",
      "根据提示输入完毕后",
      "再次输入git commit -m \"first commit\"即可",
      "6.输入git remote add origin +自己的仓库URL地址",
      "回车",
      "即可将本地仓库连接到远程仓库，即github上的仓库",
      "7.输入git push origin master",
      "回车",
      "将本地仓库中master分支上的内容上传到github仓库中",
      "等待一会后看到文件上传的过程显示完成后即为提交成功",
      "注：在git push的过程中可能会弹出failed to access或timed out等提示",
      "这些提示并不是说明提交的过程出错",
      "而是只是因为网络的问题暂时无法连接到远程仓库",
      "遇到这些问题时可以尝试反复提交直到成功为止",
      "或使用加速器进行提交",
      "没有意外情况的话多尝试几次即可成功",
      "三.创建新分支",
      "1.右键点击要创建新分支的文件或项目文件夹",
      "选择git bash here",
      "2.输入",
      "git checkout -b +新的分支名，回车，即可",
      "创建新分支",
      "这时可以看到文件夹后面的分支名变为了新建立的分支名",
      "3.然后即可依照二中的步骤在新的分支上进行添加文件到缓存区并将缓存区的文件提交到本地仓库等操作",
      "4.如果需要将新的分支提交到github，则需要",
      "输入git push origin +新的分支名",
      "回车",
      "即可向上述过程那样将文件或项目提交到远程仓库",
      "5.如需切换回master分支，可以输入",
      "git checkout master，回车即可",
      "想切换到其他分支只需要输入git checkout",
      "+分支名即可",
      "注：在切换分支后",
      "本地文件夹中文件的内容会根据分支的不同进行改变",
      "其内容会与本地仓库中文件的内容保持同步",
      "故在切换分支进行文件更改时需要注意",
      "且若其中一个分支中的本地文件被修改",
      "在切换到其他分支前需要先将修改后的内容提交",
      "再切换分支",
      "否则修改后的内容无法保存"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "由于软件构造课程需要用到git来提交实验结果，而本人是第一次使用到git，在使用过程中遇到了许多问题，故在此记录下一些git的使用方法以及一些问题的处理。\n一.仓库克隆\n1.右键点击要克隆到的本地文件夹，选择git bash here。\n2.在命令行中输入git clone +要克隆的仓库的URL地址，回车，即可将远程的github上的仓库中的东西克隆到本地的文件夹中。\n二.提交\n1.右键点击要提交的文件或项目文件夹，选择git bash here。\n2.输入git init命令，回车，用来在当前项目的目录中生成本地的git管理库，我们可以发现在当前目录下多了一个.git的隐藏文件夹。此步骤即为初始化本地仓库。\n3.输入git add ./git add *命令，回车，将项目中所有的文件添加到缓存区中。如果想添加特定文件，把.换成对应的文件名即可。\n4.输入git commit -m \"first commit\"命令，回车，即可将缓存区中的文件提交到本地仓库中。其中双引号中的内容为注释，可以根据个人需要进行修改。\n5.如果是第一次操作，可能会出现需要输入邮箱以及名字的提示，根据提示输入完毕后，再次输入git commit -m \"first commit\"即可。\n6.输入git remote add origin +自己的仓库URL地址，回车。即可将本地仓库连接到远程仓库，即github上的仓库。\n7.输入git push origin master，回车，将本地仓库中master分支上的内容上传到github仓库中，等待一会后看到文件上传的过程显示完成后即为提交成功。\n注：在git push的过程中可能会弹出failed to access或timed out等提示，这些提示并不是说明提交的过程出错，而是只是因为网络的问题暂时无法连接到远程仓库，遇到这些问题时可以尝试反复提交直到成功为止，或使用加速器进行提交。没有意外情况的话多尝试几次即可成功。\n三.创建新分支\n1.右键点击要创建新分支的文件或项目文件夹，选择git bash here。\n2.输入\ngit checkout -b +新的分支名，回车，即可\n创建新分支。这时可以看到文件夹后面的分支名变为了新建立的分支名。\n3.然后即可依照二中的步骤在新的分支上进行添加文件到缓存区并将缓存区的文件提交到本地仓库等操作。\n4.如果需要将新的分支提交到github，则需要\n输入git push origin +新的分支名，回车，即可向上述过程那样将文件或项目提交到远程仓库。\n5.如需切换回master分支，可以输入\ngit checkout master，回车即可。想切换到其他分支只需要输入git checkout\n+分支名即可。\n注：在切换分支后，本地文件夹中文件的内容会根据分支的不同进行改变。其内容会与本地仓库中文件的内容保持同步，故在切换分支进行文件更改时需要注意。且若其中一个分支中的本地文件被修改，在切换到其他分支前需要先将修改后的内容提交，再切换分支，否则修改后的内容无法保存。\n"
  },
  {
    "head": "软件构造6",
    "paragraphs": [
      "在此记录一个之前从未了解到的问题。",
      "首先来看本人定义的一个ADT，命名为Employee，定义的ADT如下：",
      "其中，name、job、phone均为private final修饰的，而在重写equals的过程中，我们发现在将obj强制类型转换为Employee后，在判断两个对象的name、job和phone是否相同的过程中可以直接访问e中的name、job和phone，即可以直接使用e.name、e.job、e.phone，而name、job、phone这三个表示都是private final的，按常规认识来说应当无法直接访问到，所以这是一个非常有意思的地方。",
      "在翻阅PPT后，我们又发现了一处出现这种情况的地方，如下图所示。",
      "这里，first和last都是private final的，但在重写的equals中都可以直接通过n.first和n.last访问。",
      "这种情况是之前在编程中未曾发现的，如果可以通过这种方式访问内部的表示的话，也就免去了在equals方法内部调用getname、getjob和getphone方法才能得到相应的表示的麻烦，更加清晰、明了。"
    ],
    "sentences": [
      "在此记录一个之前从未了解到的问题",
      "首先来看本人定义的一个ADT",
      "命名为Employee",
      "定义的ADT如下：其中",
      "name、job、phone均为private final修饰的",
      "而在重写equals的过程中",
      "我们发现在将obj强制类型转换为Employee后",
      "在判断两个对象的name、job和phone是否相同的过程中可以直接访问e中的name、job和phone",
      "即可以直接使用e.name、e.job、e.phone",
      "而name、job、phone这三个表示都是private final的",
      "按常规认识来说应当无法直接访问到",
      "所以这是一个非常有意思的地方",
      "在翻阅PPT后",
      "我们又发现了一处出现这种情况的地方",
      "如下图所示",
      "这里",
      "first和last都是private final的",
      "但在重写的equals中都可以直接通过n.first和n.last访问",
      "这种情况是之前在编程中未曾发现的",
      "如果可以通过这种方式访问内部的表示的话",
      "也就免去了在equals方法内部调用getname、getjob和getphone方法才能得到相应的表示的麻烦",
      "更加清晰、明了"
    ],
    "codes": [
      "public class Employee {\n\n\tprivate final String name;\n\tprivate final String job;\n\tprivate final String phone;\n\t// Abstraction function:\n    //  name映射为员工名字，job映射为员工职务，phone映射为员工电话号码\n    // Representation invariant:\n\t//  name,job,phone都不为空\n    // Safety from rep exposure:\n    //   使用private final修饰实例字段，防御式编程。\n\t\n\t/**\n\t * 初始化\n\t * @param name 员工名字\n\t * @param job 员工职务\n\t * @param phone 员工电话号码\n\t */\n\tpublic Employee(String name,String job,String phone) {\n\t\tthis.name=name;\n\t\tthis.job=job;\n\t\tthis.phone=phone;\n\t\tcheckrep();\n\t}\n\t\n\t/**\n\t * 获得员工名字\n\t * @return 员工名字\n\t */\n\tpublic String getname() {\n\t\treturn name;\n\t}\n\t/**\n\t * 获得员工职务\n\t * @return 员工职务\n\t */\n\tpublic String getjob() {\n\t\treturn job;\n\t}\n\t/**\n\t * 获得员工电话号码\n\t * @return 员工电话号码\n\t */\n\tpublic String getphone() {\n\t\treturn phone;\n\t}\n\t/**\n\t * 检查\n\t */\n\tprivate void checkrep() {\n\t\tassert name!=null;\n\t\tassert job!=null;\n\t\tassert phone!=null;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\tString s=\"Employee:\\n\"+\"姓名：\"+name+\"\\n\"+\"职务：\"+job+\"\\n\"+\"手机号码：\"+phone+\"\\n\"+\"\\n\";\n\t\treturn s;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif(obj==null) {\n\t\t\treturn false;\n\t\t}\n\t\tif(obj instanceof Employee) {\n\t\t\tif(this==obj) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tEmployee e=(Employee) obj;\n\t\t\tif(name.equals(e.name)&&job.equals(e.job)&&phone.equals(e.phone)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\treturn name.hashCode()+job.hashCode()+phone.hashCode();\n\t}\n}"
    ],
    "date": "2021-07-07",
    "text": "在此记录一个之前从未了解到的问题。\n首先来看本人定义的一个ADT，命名为Employee，定义的ADT如下：\n其中，name、job、phone均为private final修饰的，而在重写equals的过程中，我们发现在将obj强制类型转换为Employee后，在判断两个对象的name、job和phone是否相同的过程中可以直接访问e中的name、job和phone，即可以直接使用e.name、e.job、e.phone，而name、job、phone这三个表示都是private final的，按常规认识来说应当无法直接访问到，所以这是一个非常有意思的地方。\n在翻阅PPT后，我们又发现了一处出现这种情况的地方，如下图所示。\n这里，first和last都是private final的，但在重写的equals中都可以直接通过n.first和n.last访问。\n这种情况是之前在编程中未曾发现的，如果可以通过这种方式访问内部的表示的话，也就免去了在equals方法内部调用getname、getjob和getphone方法才能得到相应的表示的麻烦，更加清晰、明了。\n"
  },
  {
    "head": "软件构造2",
    "paragraphs": [
      "1.静态类型语言：在编译阶段进行类型检查并发现错误，避免将错误代入运行阶段，提高了代码的正确/健壮性。 动态类型语言：在运行阶段进行类型检查。",
      "静态检查无法检查出与变量值有关的错误。可以检查出：语法错误，类名/函数名错误，参数数目错误，参数类型错误，返回值类型错误。",
      "动态检查能检查出：非法的参数值，非法的返回值，越界，空指针。",
      "2.final类无法派生子类。final变量无法改变值/引用。final方法无法被子类重写。",
      "3. 不变对象：一旦被创建，始终指向同一个值/引用。可变对象：拥有方法可以修改自己的值/引用",
      "4.不可变类型，在修改时会频繁发生拷贝。",
      "5. 可变还是不可变：（1）看方法是否改变参数（2）看return是否是mutable类型（3）保证所有属性都是private，尽量加final。有时引用不可变但是指向的值是可变的。",
      "6.List在遍历时被修改，就会发生某些错误或抛出异常。可以用iterator自带的remove方法。如果用List.remove删除元素，那么可能会发生遍历过程中的元素经过修改后的下标与期望的下标不匹配的情况。"
    ],
    "sentences": [
      "1.静态类型语言：在编译阶段进行类型检查并发现错误",
      "避免将错误代入运行阶段",
      "提高了代码的正确/健壮性",
      " 动态类型语言：在运行阶段进行类型检查",
      "静态检查无法检查出与变量值有关的错误",
      "可以检查出：语法错误",
      "类名/函数名错误",
      "参数数目错误",
      "参数类型错误",
      "返回值类型错误",
      "动态检查能检查出：非法的参数值，非法的返回值，越界，空指针",
      "2.final类无法派生子类",
      "final变量无法改变值/引用",
      "final方法无法被子类重写",
      "3. 不变对象：一旦被创建，始终指向同一个值/引用",
      "可变对象：拥有方法可以修改自己的值/引用",
      "4.不可变类型，在修改时会频繁发生拷贝",
      "5. 可变还是不可变：（1）看方法是否改变参数（2）看return是否是mutable类型（3）保证所有属性都是private",
      "尽量加final",
      "有时引用不可变但是指向的值是可变的",
      "6.List在遍历时被修改，就会发生某些错误或抛出异常",
      "可以用iterator自带的remove方法",
      "如果用List.remove删除元素",
      "那么可能会发生遍历过程中的元素经过修改后的下标与期望的下标不匹配的情况"
    ],
    "codes": [],
    "date": "2021-07-05",
    "text": "1.静态类型语言：在编译阶段进行类型检查并发现错误，避免将错误代入运行阶段，提高了代码的正确/健壮性。 动态类型语言：在运行阶段进行类型检查。\n静态检查无法检查出与变量值有关的错误。可以检查出：语法错误，类名/函数名错误，参数数目错误，参数类型错误，返回值类型错误。\n动态检查能检查出：非法的参数值，非法的返回值，越界，空指针。\n2.final类无法派生子类。final变量无法改变值/引用。final方法无法被子类重写。\n3. 不变对象：一旦被创建，始终指向同一个值/引用。可变对象：拥有方法可以修改自己的值/引用\n4.不可变类型，在修改时会频繁发生拷贝。\n5. 可变还是不可变：（1）看方法是否改变参数（2）看return是否是mutable类型（3）保证所有属性都是private，尽量加final。有时引用不可变但是指向的值是可变的。\n6.List在遍历时被修改，就会发生某些错误或抛出异常。可以用iterator自带的remove方法。如果用List.remove删除元素，那么可能会发生遍历过程中的元素经过修改后的下标与期望的下标不匹配的情况。\n"
  },
  {
    "head": "Java 防止内部成员变量外部泄露的措施",
    "paragraphs": [
      "做Lab2时最大的收获是关于防泄漏方面的方法和思想。有必要写一点东西记录一下。",
      "其实在此之前我本以为类内部的成员变量暴露给外界是无所谓的。去年暑假的java语言课我写的所有类成员变量全部是public修饰的，自认为这样在类外部可以直接引用查看更加方便。现在想想还是当时还是所知甚少。",
      "Java语言一个很大的特性就是取消了指针类型，这也导致Java中除基本数据类型(int等类型)之外所有类型作为参数传递时传递的是引用（其实个人理解传递的全都是指针地址）而不是一个类的副本。如果某个可变类作为成员变量被暴露在外部，那么这个成员变量在外部可谓是一丝不挂的，外部可随意操纵、修改它，如果有人怀有恶意那么后果可想而知了。所以一定加以保护。",
      "首先是成员变量的权限修饰词，非特殊情况成员变量一致用private修饰，仅限类内部直接使用，如果外部需要查看，则单独写一个observer方法专门返回这个变量的值。",
      "再者就是用final修饰。这个修饰词对于基本类型（int、boolean等）的后果是一旦赋值后便不能再修改，无论是内部还是外部。对于一些可变类（List Set），这些类无法在外部被引用，内部可以直接使用或修改。而对于成员方法，用final修饰就代表无法被子类继承（断子绝孙方法）。所以一般情况下可变类成员变量都要用final修饰一下，基础类型变量视情况而定，如果在类中以一种条件常量存在，完全可以用final修饰。final这个修饰词还是非常安全的。",
      "最后是关于成员方法返回值的问题。如果成员方法返回的是基础类型值，那么没有问题，因为这类值传递的不是引用，无伤大雅。但如果返回的是可变类，那么就有问题了。如果一个observer方法把可变类成员变量返回到外部，那么外部实际上还是得到了这个类的引用，即使用了final修饰仍然是非常危险的。所以我们在返回前要做一些安全性处理。",
      "一种方法是使用Collections.unmodifiableXXX()方法加固返回变量。使用这个方法处理后可变类若在外部遭到修改，那么系统立马会抛出异常。",
      "另一种方法是手动复制，在局部定义一个同类型的类，然后将所有信息复制到这个新类中作为副本返回，这样就直接避免了成员变量地址的暴露。",
      "以上就是在实验过程中用到的所有措施，这种安全性的编程思想在以后非常关键。"
    ],
    "sentences": [
      "做Lab2时最大的收获是关于防泄漏方面的方法和思想",
      "有必要写一点东西记录一下",
      "其实在此之前我本以为类内部的成员变量暴露给外界是无所谓的",
      "去年暑假的java语言课我写的所有类成员变量全部是public修饰的",
      "自认为这样在类外部可以直接引用查看更加方便",
      "现在想想还是当时还是所知甚少",
      "Java语言一个很大的特性就是取消了指针类型",
      "这也导致Java中除基本数据类型(int等类型)之外所有类型作为参数传递时传递的是引用（其实个人理解传递的全都是指针地址）而不是一个类的副本",
      "如果某个可变类作为成员变量被暴露在外部",
      "那么这个成员变量在外部可谓是一丝不挂的",
      "外部可随意操纵、修改它",
      "如果有人怀有恶意那么后果可想而知了",
      "所以一定加以保护",
      "首先是成员变量的权限修饰词",
      "非特殊情况成员变量一致用private修饰",
      "仅限类内部直接使用",
      "如果外部需要查看",
      "则单独写一个observer方法专门返回这个变量的值",
      "再者就是用final修饰",
      "这个修饰词对于基本类型（int、boolean等）的后果是一旦赋值后便不能再修改",
      "无论是内部还是外部",
      "对于一些可变类（List Set）",
      "这些类无法在外部被引用",
      "内部可以直接使用或修改",
      "而对于成员方法",
      "用final修饰就代表无法被子类继承（断子绝孙方法）",
      "所以一般情况下可变类成员变量都要用final修饰一下",
      "基础类型变量视情况而定",
      "如果在类中以一种条件常量存在",
      "完全可以用final修饰",
      "final这个修饰词还是非常安全的",
      "最后是关于成员方法返回值的问题",
      "如果成员方法返回的是基础类型值",
      "那么没有问题",
      "因为这类值传递的不是引用",
      "无伤大雅",
      "但如果返回的是可变类，那么就有问题了",
      "如果一个observer方法把可变类成员变量返回到外部",
      "那么外部实际上还是得到了这个类的引用",
      "即使用了final修饰仍然是非常危险的",
      "所以我们在返回前要做一些安全性处理",
      "一种方法是使用Collections.unmodifiableXXX()方法加固返回变量",
      "使用这个方法处理后可变类若在外部遭到修改",
      "那么系统立马会抛出异常",
      "另一种方法是手动复制",
      "在局部定义一个同类型的类",
      "然后将所有信息复制到这个新类中作为副本返回",
      "这样就直接避免了成员变量地址的暴露",
      "以上就是在实验过程中用到的所有措施",
      "这种安全性的编程思想在以后非常关键"
    ],
    "codes": [],
    "date": "2021-07-04",
    "text": "做Lab2时最大的收获是关于防泄漏方面的方法和思想。有必要写一点东西记录一下。\n其实在此之前我本以为类内部的成员变量暴露给外界是无所谓的。去年暑假的java语言课我写的所有类成员变量全部是public修饰的，自认为这样在类外部可以直接引用查看更加方便。现在想想还是当时还是所知甚少。\nJava语言一个很大的特性就是取消了指针类型，这也导致Java中除基本数据类型(int等类型)之外所有类型作为参数传递时传递的是引用（其实个人理解传递的全都是指针地址）而不是一个类的副本。如果某个可变类作为成员变量被暴露在外部，那么这个成员变量在外部可谓是一丝不挂的，外部可随意操纵、修改它，如果有人怀有恶意那么后果可想而知了。所以一定加以保护。\n首先是成员变量的权限修饰词，非特殊情况成员变量一致用private修饰，仅限类内部直接使用，如果外部需要查看，则单独写一个observer方法专门返回这个变量的值。\n再者就是用final修饰。这个修饰词对于基本类型（int、boolean等）的后果是一旦赋值后便不能再修改，无论是内部还是外部。对于一些可变类（List Set），这些类无法在外部被引用，内部可以直接使用或修改。而对于成员方法，用final修饰就代表无法被子类继承（断子绝孙方法）。所以一般情况下可变类成员变量都要用final修饰一下，基础类型变量视情况而定，如果在类中以一种条件常量存在，完全可以用final修饰。final这个修饰词还是非常安全的。\n最后是关于成员方法返回值的问题。如果成员方法返回的是基础类型值，那么没有问题，因为这类值传递的不是引用，无伤大雅。但如果返回的是可变类，那么就有问题了。如果一个observer方法把可变类成员变量返回到外部，那么外部实际上还是得到了这个类的引用，即使用了final修饰仍然是非常危险的。所以我们在返回前要做一些安全性处理。\n一种方法是使用Collections.unmodifiableXXX()方法加固返回变量。使用这个方法处理后可变类若在外部遭到修改，那么系统立马会抛出异常。\n另一种方法是手动复制，在局部定义一个同类型的类，然后将所有信息复制到这个新类中作为副本返回，这样就直接避免了成员变量地址的暴露。\n以上就是在实验过程中用到的所有措施，这种安全性的编程思想在以后非常关键。\n"
  },
  {
    "head": "博客开通 开坑软件构造",
    "paragraphs": [
      "开始学习软件构造！",
      "不定期更新代码心得。"
    ],
    "sentences": [
      "开始学习软件构造！",
      "不定期更新代码心得"
    ],
    "codes": [],
    "date": "2021-05-06",
    "text": "开始学习软件构造！\n不定期更新代码心得。\n"
  },
  {
    "head": "相对路径./ ../区别",
    "paragraphs": [
      "相对路径：由于是相对的，所以必须有一个基准作为参照物来说明",
      "/ 基准所在的最顶级目录即根目录，根目录是相对于其他子目录来说的",
      "./ 基准所在的当前目录",
      "…/ 基准所在的当前目录的上一级目录（当前目录的父级目录）"
    ],
    "sentences": [
      "相对路径：由于是相对的，所以必须有一个基准作为参照物来说明",
      "/ 基准所在的最顶级目录即根目录",
      "根目录是相对于其他子目录来说的",
      "./ 基准所在的当前目录",
      "…/ 基准所在的当前目录的上一级目录（当前目录的父级目录）"
    ],
    "codes": [],
    "date": "2021-05-24",
    "text": "相对路径：由于是相对的，所以必须有一个基准作为参照物来说明\n/ 基准所在的最顶级目录即根目录，根目录是相对于其他子目录来说的\n./ 基准所在的当前目录\n…/ 基准所在的当前目录的上一级目录（当前目录的父级目录）\n"
  },
  {
    "head": "Java 关于日期——周工作日——时间戳的转换",
    "paragraphs": [
      "Lab3开发应用的过程中，与用户交互使用的格式大多是日期和周工作日的形式。",
      "比如日期：2021-07-04；周工作日形式：1(Monday)…7(Sunday)。而应用底层ADT的处理过程都是基于绝对时间戳的。在ADT将结果计算出来之后，同样要以日期或周工作日的形式打印信息反馈给用户。因此在这个过程中反复用到了日期与绝对时间戳的互相转化。",
      "自己造轮子写转化算法是比较麻烦的，难度不大，但细节很多（腊月、2月、闰年、平年），调试也需要花一番功夫。上网查了查，大概知道了java自带的日期类Date、日历类Calendar，以及日期格式化类SimpleDateFormat。借助这几个类的接口可以直接实现转化。",
      "但需要注意的是，这几个类的时间可以精确到毫秒级，也就是说转化后的时间戳1个单位表示1毫秒。而我们的应用中完全不需要如此高的精度，应用一精确到日，应用三精确到小时即可。虽然实验指导书上非常有先见之明的建议将ADT内部有关时间戳的类型全部定义为long，但调试的时候看一堆十几位的整数也是够累眼睛的，不如手动调整一下精度。",
      "原来想的是：一天24小时、一小时60分钟、一分钟60秒、一秒1000毫秒，那么只需要将精度为毫秒的时间戳/24/60/60/1000即可，这样得到的结果1个单位就表示1天，同理如果要精确到小时只需/60/60/1000。但测试了一下发现并不对，这么直接除是除不尽的。急中生智我打印了一下时间戳1对应的日期，是1970-01-01 …。总之是位于这个日期中午的某个时间段而不是00:00。那么显然事件戳的起始点并不是1。但几乎可以肯定1970应该是万年历的起点（Windows系统时间起点就是1970）。那么顺势打印一下1970-01-01 00:00的时间戳，发现为-28800000，看来起点是这个数（至于为甚么要设这么个奇怪的数当起点我也很迷惑）。那么我们只需要在上面的计算公式中引入28800000这个偏移量就行了。",
      "日期转时间戳的时候，要先将java自带类的转化结果+28800000，再依次除掉那些常数，最后2021-07-02这个日期顺利的除成了18335（具体多少忘了）左右一个数，大概算一下从1970年到现在差不多就是这么多天，那么我们的转换应该没有大问题了。",
      "日期转时间戳（精确到日）代码如下：",
      "相应的反过来时间戳转日期需要-28800000这个偏移量（逆运算嘛），代码如下：",
      "有了这两个函数，在与用户交互时表示问题就非常方便了。"
    ],
    "sentences": [
      "Lab3开发应用的过程中",
      "与用户交互使用的格式大多是日期和周工作日的形式",
      "比如日期：2021-07-04；周工作日形式：1(Monday)…7(Sunday)",
      "而应用底层ADT的处理过程都是基于绝对时间戳的",
      "在ADT将结果计算出来之后",
      "同样要以日期或周工作日的形式打印信息反馈给用户",
      "因此在这个过程中反复用到了日期与绝对时间戳的互相转化",
      "自己造轮子写转化算法是比较麻烦的",
      "难度不大",
      "但细节很多（腊月、2月、闰年、平年）",
      "调试也需要花一番功夫",
      "上网查了查",
      "大概知道了java自带的日期类Date、日历类Calendar",
      "以及日期格式化类SimpleDateFormat",
      "借助这几个类的接口可以直接实现转化",
      "但需要注意的是",
      "这几个类的时间可以精确到毫秒级",
      "也就是说转化后的时间戳1个单位表示1毫秒",
      "而我们的应用中完全不需要如此高的精度",
      "应用一精确到日",
      "应用三精确到小时即可",
      "虽然实验指导书上非常有先见之明的建议将ADT内部有关时间戳的类型全部定义为long",
      "但调试的时候看一堆十几位的整数也是够累眼睛的",
      "不如手动调整一下精度",
      "原来想的是：一天24小时、一小时60分钟、一分钟60秒、一秒1000毫秒",
      "那么只需要将精度为毫秒的时间戳/24/60/60/1000即可",
      "这样得到的结果1个单位就表示1天",
      "同理如果要精确到小时只需/60/60/1000",
      "但测试了一下发现并不对，这么直接除是除不尽的",
      "急中生智我打印了一下时间戳1对应的日期",
      "是1970-01-01 …",
      "总之是位于这个日期中午的某个时间段而不是00:00",
      "那么显然事件戳的起始点并不是1",
      "但几乎可以肯定1970应该是万年历的起点（Windows系统时间起点就是1970）",
      "那么顺势打印一下1970-01-01 00:00的时间戳",
      "发现为-28800000",
      "看来起点是这个数（至于为甚么要设这么个奇怪的数当起点我也很迷惑）",
      "那么我们只需要在上面的计算公式中引入28800000这个偏移量就行了",
      "日期转时间戳的时候",
      "要先将java自带类的转化结果+28800000",
      "再依次除掉那些常数",
      "最后2021-07-02这个日期顺利的除成了18335（具体多少忘了）左右一个数",
      "大概算一下从1970年到现在差不多就是这么多天",
      "那么我们的转换应该没有大问题了",
      "日期转时间戳（精确到日）代码如下：相应的反过来时间戳转日期需要-28800000这个偏移量（逆运算嘛）",
      "代码如下：有了这两个函数",
      "在与用户交互时表示问题就非常方便了"
    ],
    "codes": [
      "    /**\n     * 将日期转化为抽象的时间戳\n     *\n     * @return 转化后的时间戳\n     */\n    public long Date2Time(String date) throws ParseException {\n        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");\n        Date d = format.parse(date);\n        return (d.getTime() + 28800000L) / 1000L / 60L / 60L / 24L;\n    }\n",
      "    /**\n     * 将时间戳转化为人可以看懂的格式化日期\n     *\n     * @return 格式化日期字符串\n     */\n    public String Time2Date(long time) {\n        time = time * 60L * 60L * 24L * 1000L - 28800000L;\n        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");\n        return format.format(new Date(time));\n    }\n"
    ],
    "date": "2021-07-04",
    "text": "Lab3开发应用的过程中，与用户交互使用的格式大多是日期和周工作日的形式。\n比如日期：2021-07-04；周工作日形式：1(Monday)…7(Sunday)。而应用底层ADT的处理过程都是基于绝对时间戳的。在ADT将结果计算出来之后，同样要以日期或周工作日的形式打印信息反馈给用户。因此在这个过程中反复用到了日期与绝对时间戳的互相转化。\n自己造轮子写转化算法是比较麻烦的，难度不大，但细节很多（腊月、2月、闰年、平年），调试也需要花一番功夫。上网查了查，大概知道了java自带的日期类Date、日历类Calendar，以及日期格式化类SimpleDateFormat。借助这几个类的接口可以直接实现转化。\n但需要注意的是，这几个类的时间可以精确到毫秒级，也就是说转化后的时间戳1个单位表示1毫秒。而我们的应用中完全不需要如此高的精度，应用一精确到日，应用三精确到小时即可。虽然实验指导书上非常有先见之明的建议将ADT内部有关时间戳的类型全部定义为long，但调试的时候看一堆十几位的整数也是够累眼睛的，不如手动调整一下精度。\n原来想的是：一天24小时、一小时60分钟、一分钟60秒、一秒1000毫秒，那么只需要将精度为毫秒的时间戳/24/60/60/1000即可，这样得到的结果1个单位就表示1天，同理如果要精确到小时只需/60/60/1000。但测试了一下发现并不对，这么直接除是除不尽的。急中生智我打印了一下时间戳1对应的日期，是1970-01-01 …。总之是位于这个日期中午的某个时间段而不是00:00。那么显然事件戳的起始点并不是1。但几乎可以肯定1970应该是万年历的起点（Windows系统时间起点就是1970）。那么顺势打印一下1970-01-01 00:00的时间戳，发现为-28800000，看来起点是这个数（至于为甚么要设这么个奇怪的数当起点我也很迷惑）。那么我们只需要在上面的计算公式中引入28800000这个偏移量就行了。\n日期转时间戳的时候，要先将java自带类的转化结果+28800000，再依次除掉那些常数，最后2021-07-02这个日期顺利的除成了18335（具体多少忘了）左右一个数，大概算一下从1970年到现在差不多就是这么多天，那么我们的转换应该没有大问题了。\n日期转时间戳（精确到日）代码如下：\n相应的反过来时间戳转日期需要-28800000这个偏移量（逆运算嘛），代码如下：\n有了这两个函数，在与用户交互时表示问题就非常方便了。\n"
  },
  {
    "head": "关于Java软件开发中Decorator设计模式的认识",
    "paragraphs": [
      "Lab3最终敲定使用Decorator设计模式进行开发，最终结果证明这个选择是完全正确的。",
      "Decorator设计模式本身强大的可扩展性和可复用性完全符合我的预期，对于上层ADT的开发没有占据多少时间（大量的时间都耗在了用户交互开发上了，打印信息真的是个枯燥而无脑的工作）。而且接口的具体实现类、Decorator类以及各个具体装饰类借助IDEA强大的纠错能力，根本没有调试，后续直接调用跑测试没出现任何底层的问题（问题还是全出现在输入信息提取、信息打印格式上）。",
      "Decorator设计模式的核心是编写装饰类。一个基本的抽象装饰类Decorator是必不可少的，同时这也是Decorator设计模式最巧妙的地方。基本装饰类本身定义为接口的实现类，但又往往用abstract修饰，也就是说基础装饰类是不能直接调用的，他只是各具体装饰类相互结合的一个跳板。基础装饰类内部通过委派一个接口的多态来实现继承各个方法，正是因为这个委派，使得逐层装饰的效果都可以被组合。",
      "直接看一下用具体装饰类组装一个具有多种特性的ADT的定义方式：",
      "这是应用一中定义无空白、无重叠、标签唯一时间轴的方式。代表三种特性的具体装饰类依次嵌套，并作为参数传给上一层类的构造器进行构造。这种定义形式看起来非常复杂，但再看一下具体装饰类的写法就一目了然了：",
      "这里标签唯一特性表现为重写了insert方法，在每次插入时间轴前检查该标签是否已经存在，如果不存在，再调用父类的插入方法，这就是新的特性。注意这里使用的是super，调用的是父类的方法。而每一个具体装饰类的父类都是基础装饰类Decorator。再看一下Decorator类的结构",
      "也就是说在定义时将无特性的接口实现类CommonIntervalSet作为参数传入UniqueIntervalSet，UniqueIntervalSet的构造器将则个类传给父类进行构造，此时基础装饰类Decorato委派给了CommonIntervalSet。那么每次执行insert操作时，会进入UniqueIntervalSet的特性插入方法，如果达到了插入条件，他再使用super.insert通过父类操作，而其父类Decorator内部正是CommonIntervalSet，所以最后还是会调用CommonIntervalSet的插入方法。那么试想这样逐层嵌套，执行一个方法会根据这样的委派体系依次经历那些装饰类的特性操作，这样便实现了特性的组合。",
      "需要注意的是，嵌套定义具有组合特性的ADT时，定义出来的ADT只能使用公用方法和最外层具体装饰类的特有方法。具体装饰类中一般通过重写方法来赋予特性。如果在具体装饰类中撰写新方法赋予特性，那么在定义时该类必须位于最外层嵌套，嵌套在内层的类的特有方法是无法直接调用的。",
      "最后通过这样一种强大的设计模式，实验三最后新的变化一节修改特性时只需修改一行定义代码即可。因为对于Decorator设计模式来说修改特性就是重新组合嵌套装饰类，我们只需改变一下组装具体ADT时用到的装饰类即可。"
    ],
    "sentences": [
      "Lab3最终敲定使用Decorator设计模式进行开发",
      "最终结果证明这个选择是完全正确的",
      "Decorator设计模式本身强大的可扩展性和可复用性完全符合我的预期",
      "对于上层ADT的开发没有占据多少时间（大量的时间都耗在了用户交互开发上了",
      "打印信息真的是个枯燥而无脑的工作）",
      "而且接口的具体实现类、Decorator类以及各个具体装饰类借助IDEA强大的纠错能力",
      "根本没有调试",
      "后续直接调用跑测试没出现任何底层的问题（问题还是全出现在输入信息提取、信息打印格式上）",
      "Decorator设计模式的核心是编写装饰类",
      "一个基本的抽象装饰类Decorator是必不可少的",
      "同时这也是Decorator设计模式最巧妙的地方",
      "基本装饰类本身定义为接口的实现类",
      "但又往往用abstract修饰",
      "也就是说基础装饰类是不能直接调用的",
      "他只是各具体装饰类相互结合的一个跳板",
      "基础装饰类内部通过委派一个接口的多态来实现继承各个方法",
      "正是因为这个委派",
      "使得逐层装饰的效果都可以被组合",
      "直接看一下用具体装饰类组装一个具有多种特性的ADT的定义方式：这是应用一中定义无空白、无重叠、标签唯一时间轴的方式",
      "代表三种特性的具体装饰类依次嵌套",
      "并作为参数传给上一层类的构造器进行构造",
      "这种定义形式看起来非常复杂",
      "但再看一下具体装饰类的写法就一目了然了：这里标签唯一特性表现为重写了insert方法",
      "在每次插入时间轴前检查该标签是否已经存在",
      "如果不存在",
      "再调用父类的插入方法",
      "这就是新的特性",
      "注意这里使用的是super，调用的是父类的方法",
      "而每一个具体装饰类的父类都是基础装饰类Decorator",
      "再看一下Decorator类的结构",
      "也就是说在定义时将无特性的接口实现类CommonIntervalSet作为参数传入UniqueIntervalSet",
      "UniqueIntervalSet的构造器将则个类传给父类进行构造",
      "此时基础装饰类Decorato委派给了CommonIntervalSet",
      "那么每次执行insert操作时",
      "会进入UniqueIntervalSet的特性插入方法",
      "如果达到了插入条件",
      "他再使用super.insert通过父类操作",
      "而其父类Decorator内部正是CommonIntervalSet",
      "所以最后还是会调用CommonIntervalSet的插入方法",
      "那么试想这样逐层嵌套",
      "执行一个方法会根据这样的委派体系依次经历那些装饰类的特性操作",
      "这样便实现了特性的组合",
      "需要注意的是",
      "嵌套定义具有组合特性的ADT时",
      "定义出来的ADT只能使用公用方法和最外层具体装饰类的特有方法",
      "具体装饰类中一般通过重写方法来赋予特性",
      "如果在具体装饰类中撰写新方法赋予特性",
      "那么在定义时该类必须位于最外层嵌套",
      "嵌套在内层的类的特有方法是无法直接调用的",
      "最后通过这样一种强大的设计模式",
      "实验三最后新的变化一节修改特性时只需修改一行定义代码即可",
      "因为对于Decorator设计模式来说修改特性就是重新组合嵌套装饰类",
      "我们只需改变一下组装具体ADT时用到的装饰类即可"
    ],
    "codes": [
      "    private final NonBlankIntervalSet<Employee> DutyIntervalSet =\n            new NonBlankIntervalSet<Employee>(\n                    new NonOverlapIntervalSet<Employee>(\n                            new UniqueIntervalSet<Employee>(\n                                    new CommonIntervalSet<Employee>())));\n",
      "public class UniqueIntervalSet<L> extends IntervalDecorator<L> {\n\n    public UniqueIntervalSet(IntervalSet<L> set) {\n        super(set);\n    }\n\n    /**\n     * 在当前时间轴中插入新的时间段和标签。\n     * 若待插入时间段的标签与某个已有时间段标签相同，则不执行插入。\n     *\n     * @param label 待插入时间段的标签\n     * @param start 待插入时间段的开始时间\n     * @param end   待插入时间段的结束时间\n     */\n    @Override\n    public void insert(L label, long start, long end) {\n        if (super.labels().contains(label)) {\n            System.out.println(\"Label already exist!\");\n            return;\n        }\n        super.insert(label, start, end);\n    }\n}\n",
      "public abstract class IntervalDecorator<L> implements IntervalSet<L>{\n    protected final IntervalSet<L> intervalSet;\n\n    protected IntervalDecorator(IntervalSet<L> set) {\n        this.intervalSet = set;\n    }\n\n    @Override\n    public void insert(L label, long start, long end) {\n        intervalSet.insert(label,start,end);\n    }\n    \n\t@Override\t\n    //其他方法依次委派...........\n    //.........................\n}    \n"
    ],
    "date": "2021-07-04",
    "text": "Lab3最终敲定使用Decorator设计模式进行开发，最终结果证明这个选择是完全正确的。\nDecorator设计模式本身强大的可扩展性和可复用性完全符合我的预期，对于上层ADT的开发没有占据多少时间（大量的时间都耗在了用户交互开发上了，打印信息真的是个枯燥而无脑的工作）。而且接口的具体实现类、Decorator类以及各个具体装饰类借助IDEA强大的纠错能力，根本没有调试，后续直接调用跑测试没出现任何底层的问题（问题还是全出现在输入信息提取、信息打印格式上）。\nDecorator设计模式的核心是编写装饰类。一个基本的抽象装饰类Decorator是必不可少的，同时这也是Decorator设计模式最巧妙的地方。基本装饰类本身定义为接口的实现类，但又往往用abstract修饰，也就是说基础装饰类是不能直接调用的，他只是各具体装饰类相互结合的一个跳板。基础装饰类内部通过委派一个接口的多态来实现继承各个方法，正是因为这个委派，使得逐层装饰的效果都可以被组合。\n直接看一下用具体装饰类组装一个具有多种特性的ADT的定义方式：\n这是应用一中定义无空白、无重叠、标签唯一时间轴的方式。代表三种特性的具体装饰类依次嵌套，并作为参数传给上一层类的构造器进行构造。这种定义形式看起来非常复杂，但再看一下具体装饰类的写法就一目了然了：\n这里标签唯一特性表现为重写了insert方法，在每次插入时间轴前检查该标签是否已经存在，如果不存在，再调用父类的插入方法，这就是新的特性。注意这里使用的是super，调用的是父类的方法。而每一个具体装饰类的父类都是基础装饰类Decorator。再看一下Decorator类的结构\n也就是说在定义时将无特性的接口实现类CommonIntervalSet作为参数传入UniqueIntervalSet，UniqueIntervalSet的构造器将则个类传给父类进行构造，此时基础装饰类Decorato委派给了CommonIntervalSet。那么每次执行insert操作时，会进入UniqueIntervalSet的特性插入方法，如果达到了插入条件，他再使用super.insert通过父类操作，而其父类Decorator内部正是CommonIntervalSet，所以最后还是会调用CommonIntervalSet的插入方法。那么试想这样逐层嵌套，执行一个方法会根据这样的委派体系依次经历那些装饰类的特性操作，这样便实现了特性的组合。\n需要注意的是，嵌套定义具有组合特性的ADT时，定义出来的ADT只能使用公用方法和最外层具体装饰类的特有方法。具体装饰类中一般通过重写方法来赋予特性。如果在具体装饰类中撰写新方法赋予特性，那么在定义时该类必须位于最外层嵌套，嵌套在内层的类的特有方法是无法直接调用的。\n最后通过这样一种强大的设计模式，实验三最后新的变化一节修改特性时只需修改一行定义代码即可。因为对于Decorator设计模式来说修改特性就是重新组合嵌套装饰类，我们只需改变一下组装具体ADT时用到的装饰类即可。\n"
  },
  {
    "head": "使用Git管理github远程仓库的方式",
    "paragraphs": [
      "今天上的第一节软构课就要求我们学习使用Git，未来的三个实验全部通过Git提交。晚上下课后就回去搞了搞，比我想象的复杂，骂了Git一整个晚上。之前偶尔用过Github，都是通过网页上传附件的形式上传到仓库，这次整这个git属实给我整迷糊了。",
      "Git被普遍称为功能强大的版本管理工具，强不强大暂时感受不出来，但是用起来真tm的麻烦。安装好后和远程仓库关联起来就废了半天劲。网上的教程大多是远程公开仓库关联本地仓库，奈何我们的实验仓库都是private的，关联需要密钥认证，根据为数不多的教程一步一步照着弄才勉强关联好。",
      "首先本地创建一个本地仓库，在想要创建的文件夹下打开git bash输入",
      "这样本地会多出一个.git隐藏文件夹，作为仓库管理文件。然后在bash创建输入以下命令配置身份",
      "之后生成rsa密钥作为和git交互的凭证",
      "然后在C盘用户文件夹.ssh文件夹下找到两个rsa文件，分别是秘钥和公钥。我们需要把公钥.pub交给github。具体就是打开github的设置添加一个SSHkey，把公钥内容复制进去。",
      "然后在bush输入以下命令测试连接，连接成功就可以了。",
      "至此把github和本地认证好后，我推荐用Git gui来执行以后的push操作，毕竟图形界面适合初学者。在图形界面中根据remote->add->branch…等等选项自己可以摸索出来和远程仓库建立连接，无非就是复制以下ssh设定一下分支名。然后就可以push上传。",
      "当然这只是个开始，push的过程中我还经历了各种各样的错误，大多与git分支管理方式有关，git分支的管理属实有点复杂。如果push上传了一个文件，在本地又删除，之后再次上传会出现错误告诉你本地仓库滞后于远程仓库的更新balabala，死活不让上传。这时候开bash用-force选项强制上传即可。不知道把一个上传搞这么严格有什么用，也许以后能慢慢发现好处吧。"
    ],
    "sentences": [
      "今天上的第一节软构课就要求我们学习使用Git",
      "未来的三个实验全部通过Git提交",
      "晚上下课后就回去搞了搞，比我想象的复杂，骂了Git一整个晚上",
      "之前偶尔用过Github",
      "都是通过网页上传附件的形式上传到仓库",
      "这次整这个git属实给我整迷糊了",
      "Git被普遍称为功能强大的版本管理工具",
      "强不强大暂时感受不出来",
      "但是用起来真tm的麻烦",
      "安装好后和远程仓库关联起来就废了半天劲",
      "网上的教程大多是远程公开仓库关联本地仓库",
      "奈何我们的实验仓库都是private的",
      "关联需要密钥认证",
      "根据为数不多的教程一步一步照着弄才勉强关联好",
      "首先本地创建一个本地仓库",
      "在想要创建的文件夹下打开git bash输入",
      "这样本地会多出一个.git隐藏文件夹，作为仓库管理文件",
      "然后在bash创建输入以下命令配置身份",
      "之后生成rsa密钥作为和git交互的凭证",
      "然后在C盘用户文件夹.ssh文件夹下找到两个rsa文件",
      "分别是秘钥和公钥",
      "我们需要把公钥.pub交给github",
      "具体就是打开github的设置添加一个SSHkey",
      "把公钥内容复制进去",
      "然后在bush输入以下命令测试连接，连接成功就可以了",
      "至此把github和本地认证好后",
      "我推荐用Git gui来执行以后的push操作",
      "毕竟图形界面适合初学者",
      "在图形界面中根据remote->add->branch…等等选项自己可以摸索出来和远程仓库建立连接",
      "无非就是复制以下ssh设定一下分支名",
      "然后就可以push上传",
      "当然这只是个开始",
      "push的过程中我还经历了各种各样的错误",
      "大多与git分支管理方式有关",
      "git分支的管理属实有点复杂",
      "如果push上传了一个文件",
      "在本地又删除",
      "之后再次上传会出现错误告诉你本地仓库滞后于远程仓库的更新balabala",
      "死活不让上传",
      "这时候开bash用-force选项强制上传即可",
      "不知道把一个上传搞这么严格有什么用，也许以后能慢慢发现好处吧"
    ],
    "codes": [
      "\tgit init\n",
      "\tgit config --global user.name \"username\"  \n\tgit config --global user.email \"email\" \n",
      "\tssh-keygen -t rsa -C \"email\"\n",
      "\tssh -T git@github.com\n"
    ],
    "date": "2021-07-05",
    "text": "今天上的第一节软构课就要求我们学习使用Git，未来的三个实验全部通过Git提交。晚上下课后就回去搞了搞，比我想象的复杂，骂了Git一整个晚上。之前偶尔用过Github，都是通过网页上传附件的形式上传到仓库，这次整这个git属实给我整迷糊了。\nGit被普遍称为功能强大的版本管理工具，强不强大暂时感受不出来，但是用起来真tm的麻烦。安装好后和远程仓库关联起来就废了半天劲。网上的教程大多是远程公开仓库关联本地仓库，奈何我们的实验仓库都是private的，关联需要密钥认证，根据为数不多的教程一步一步照着弄才勉强关联好。\n首先本地创建一个本地仓库，在想要创建的文件夹下打开git bash输入\n这样本地会多出一个.git隐藏文件夹，作为仓库管理文件。然后在bash创建输入以下命令配置身份\n之后生成rsa密钥作为和git交互的凭证\n然后在C盘用户文件夹.ssh文件夹下找到两个rsa文件，分别是秘钥和公钥。我们需要把公钥.pub交给github。具体就是打开github的设置添加一个SSHkey，把公钥内容复制进去。\n然后在bush输入以下命令测试连接，连接成功就可以了。\n至此把github和本地认证好后，我推荐用Git gui来执行以后的push操作，毕竟图形界面适合初学者。在图形界面中根据remote->add->branch…等等选项自己可以摸索出来和远程仓库建立连接，无非就是复制以下ssh设定一下分支名。然后就可以push上传。\n当然这只是个开始，push的过程中我还经历了各种各样的错误，大多与git分支管理方式有关，git分支的管理属实有点复杂。如果push上传了一个文件，在本地又删除，之后再次上传会出现错误告诉你本地仓库滞后于远程仓库的更新balabala，死活不让上传。这时候开bash用-force选项强制上传即可。不知道把一个上传搞这么严格有什么用，也许以后能慢慢发现好处吧。\n"
  },
  {
    "head": "类方法与实例方法的区别",
    "paragraphs": [
      "类方法",
      "用static修饰的方法。",
      "由于类方法是属于整个类的，所以类方法的方法体中不能有与类的对象有关的内容。",
      "即类方法体有如下限制：",
      "类方法中不能引用对象变量；",
      "类方法中不能调用类的对象方法；",
      "在类方法中不能调使用super，this关键字；",
      "类方法不能被覆盖。",
      "实例方法",
      "当一个类创建了一个对象后，这个对象就可以调用该类的方法（对象方法）。",
      "实例方法中可以引用对象变量，也可以引用类变量；",
      "实例方法中可以调用类方法；",
      "对象方法中可以使用super，this关键字。",
      "区别和注意事项",
      "类方法可以通过类名调用，实例方法不能通过类名调用",
      "当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址",
      "当该类创建对象后，类中的实例方法才分配入口地址，",
      "从而实例方法可以被类创建的任何对象调用执行。",
      "类方法在该类被加载到内存时，就分配了相应的入口地址。",
      "从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。",
      "类方法的入口地址直到程序退出时才被取消。",
      "当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址。",
      "也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。",
      "在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，",
      "这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址"
    ],
    "sentences": [
      "类方法",
      "用static修饰的方法",
      "由于类方法是属于整个类的",
      "所以类方法的方法体中不能有与类的对象有关的内容",
      "即类方法体有如下限制：类方法中不能引用对象变量；类方法中不能调用类的对象方法；在类方法中不能调使用super",
      "this关键字；类方法不能被覆盖",
      "实例方法",
      "当一个类创建了一个对象后",
      "这个对象就可以调用该类的方法（对象方法）",
      "实例方法中可以引用对象变量",
      "也可以引用类变量；实例方法中可以调用类方法；对象方法中可以使用super",
      "this关键字",
      "区别和注意事项",
      "类方法可以通过类名调用，实例方法不能通过类名调用",
      "当类的字节码文件被加载到内存时",
      "类的实例方法不会被分配入口地址",
      "当该类创建对象后",
      "类中的实例方法才分配入口地址",
      "从而实例方法可以被类创建的任何对象调用执行",
      "类方法在该类被加载到内存时，就分配了相应的入口地址",
      "从而类方法不仅可以被类创建的任何对象调用执行",
      "也可以直接通过类名调用",
      "类方法的入口地址直到程序退出时才被取消",
      "当我们创建第一个对象时",
      "类中的实例方法就分配了入口地址",
      "当再创建对象时",
      "不再分配入口地址",
      "也就是说",
      "方法的入口地址被所有的对象共享",
      "当所有的对象都不存在时",
      "方法的入口地址才被取消",
      "在Java语言中",
      "类中的类方法不可以操作实例变量",
      "也不可以调用实例方法",
      "这是因为在类创建对象之前",
      "实例成员变量还没有分配内存",
      "而且实例方法也没有入口地址"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "类方法\n用static修饰的方法。\n由于类方法是属于整个类的，所以类方法的方法体中不能有与类的对象有关的内容。\n即类方法体有如下限制：\n类方法中不能引用对象变量；\n类方法中不能调用类的对象方法；\n在类方法中不能调使用super，this关键字；\n类方法不能被覆盖。\n实例方法\n当一个类创建了一个对象后，这个对象就可以调用该类的方法（对象方法）。\n实例方法中可以引用对象变量，也可以引用类变量；\n实例方法中可以调用类方法；\n对象方法中可以使用super，this关键字。\n区别和注意事项\n类方法可以通过类名调用，实例方法不能通过类名调用\n当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址\n当该类创建对象后，类中的实例方法才分配入口地址，\n从而实例方法可以被类创建的任何对象调用执行。\n类方法在该类被加载到内存时，就分配了相应的入口地址。\n从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。\n类方法的入口地址直到程序退出时才被取消。\n当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址。\n也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。\n在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，\n这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址\n"
  },
  {
    "head": "哈工大软件构造Lab2导读 - Stanford 6.031 Problem Set 2: Poetic Walks",
    "paragraphs": [
      "文章目录",
      "一、P1-Problem 1：编写测试用例",
      "1.GraphStaticTest",
      "2.GraphInstanceTest",
      "二、实现两个ADT",
      "1.AF，RI，Safety from Rep exposure .etc",
      "2.checkRep ( )",
      "3.方法的具体实现",
      "4.实现Graph.empty ( )",
      "三、Poetic Walks",
      "1.题目意思梳理（结合MIT页面和spec看）",
      "2.编写测试用例",
      "3.具体实现Poet",
      "1) 构造方法GraphPoet",
      "2) 生成句子方法Poem",
      "3) toString方法",
      "4.测试代码覆盖度",
      "四、重构Lab 1中的Social Network",
      "由于实验的介绍为MIT的全英文页面，要点分散，可能造成理解上的困难。所以在这里梳理总结一下软构lab2的整个流程，可以结合MIT的问题描述来看。希望能帮到后来的学弟学妹，不要拿到程序包直接两眼一抹黑，不知从何下手。",
      "写下这篇文章是在完成实验后进行回忆，如有疏漏请多指正。",
      "先简单总结Lab 2完成的工作：从github将代码clone到本地，根据已有spec完成测试用例的编写（P1，Problem 1），再分别编写两个ADT：",
      "ConcreteVerticesGraph",
      "ConcreteEdgesGraph",
      "的具体实现（P1，Problem 2 / 3）。之后，我们利用两个ADT分别实现具体的类GraphPoet，并完成一系列的工作（P1，Problem 4）。并重构我们在Lab 1中实现过的人际关系图（P2）",
      "本实验的完成基于IDEA，可以方便地可视化代码覆盖度，所以没有涉及安装EclEmma。",
      "一、P1-Problem 1：编写测试用例",
      "按照TDD（Test-Driven Development，测试驱动开发）的策略，在编写具体实现之前，我们需要根据已有的spec设计出对应方法的测试。",
      "1.GraphStaticTest",
      "这一部分是对",
      "Graph.empty()",
      "的测试，可以先不用管，在完成 Problem 3.2 实现",
      "Graph.empty()",
      "之前，这一块的代码是跑不起来的XD",
      "对GraphStaticTest的补充也需要在Problem 3.2中进行。",
      "2.GraphInstanceTest",
      "这一部分是对Graph中的具体方法进行测试，需要好好构思构思，",
      "如果刚开始草草写了/没有考虑周全，那么在后面代码覆盖度过低，会反复回头来修改这部分，耽误很多时间！",
      "具体而言，这一部分要按等价类划分的方法，编写测试用例。严格写下来的话，代码行数不少。举个栗子：",
      "Testing strategy",
      "testRemove( )",
      "测试remove( )方法，等价类划分如下：",
      "删除点是否在图中：是，否",
      "删除点是否有相连边：是，否",
      "排除不可能的情况，共3个等价类，所以需要写三组测试。",
      "另外，提醒考虑ADT对有环图的支持并测试，后续部分会用到。",
      "二、实现两个ADT",
      "1.AF，RI，Safety from Rep exposure .etc",
      "具体实现两个ADT，首先要求我们撰写相信很多同学这是第一次实际写一个程序的AF、RI，这些概念的具体意义可以参见",
      "关于AF, RI, Rep exposure",
      "其实举个例子，照葫芦画瓢也还算容易。例如，对于",
      "ConcreteEdgesGraph",
      "，它的这些概念可以解释如下：",
      "Abstraction function:",
      "AF(vertices) = Graph中的点",
      "AF(edges) = Graph中的边",
      "Representation invariant:",
      "点的名字不能重复",
      "所有点都在vertices中",
      "edge的权值为正",
      "两点间的单向边最多只能有一条",
      "Safety from rep exposure:",
      "成员变量vertices与edges均用private final修饰，防止其被外部修改",
      "在涉及返回内部变量时，采用防御性拷贝的方式，创造一份新的变量return",
      "2.checkRep ( )",
      "checkRep ( )部分就是针对RI设计出检查代码。比如，在RI中有一条“edge的权值为正”，则在checkRep ( )中需要用",
      "assert语句",
      "检查edge的成员是否大于0，",
      "在每次运行方法（如add，set）且修改了成员变量后，需要在return前调用checkRep ( )进行检查",
      "3.方法的具体实现",
      "在实现",
      "ConcreteVerticesGraph",
      "ConcreteEdgesGraph",
      "时，MIT的页面要求先用String型，再用泛型L，其实可以直接用泛型L来写，节省后续改的工作量。若用泛型L来写，则需要将两个ADT的部分内容修改为如下：",
      "相关方法的具体实现在这里暂且不表，在完成方法的实现后，可以通过前面写的测试用例来检验方法编写是否正确，并看看代码覆盖度，有哪些代码没有覆盖到。（",
      "实验要求代码覆盖度尽可能达到100%",
      "在这里简单讲一下IDEA的代码覆盖度测试：",
      "运行之后：",
      "另外注意，两个ADT中需要分别实现成员",
      "Edge",
      "与成员",
      "Vertex",
      "ConcreteEdgesGraphTest",
      "ConcreteVerticesGraphTest",
      "中，需要完成对",
      "Edge",
      "Vertex",
      "各自成员方法的测试。",
      "4.实现Graph.empty ( )",
      "这一部分要求我们对",
      "Graph.java",
      "empty ( )",
      "方法进行实现，具体来说，就是让",
      "empty ( )",
      "方法返回两个具体ADT中的一个，如图：",
      "完成后，在",
      "GraphStaticTest",
      "中补充测试代码，具体来说，就是模仿已有代码，验证在Interger，Double等类型下是否正确，如图：",
      "三、Poetic Walks",
      "到此，我们已经完成了MIT页面上的Problem 1~3，开始解决Problem 4。",
      "1.题目意思梳理（结合MIT页面和spec看）",
      "在这一步中，需要依据语料生成一个单词图，单词图的每个顶点是语料中的一个单词，单词图的边代表前一个单词紧接着后一个单词，边的权重为前一个单词紧接着后一个单词的次数，并且不考虑大小写与标点符号。举个例子：",
      "hello,hello,HeLlo,world!",
      "其中，hello→hello出现两次，hello→world出现一次，则这个语料构成的图为：",
      "更加具体的示例可以参照MIT实验官网的页面。",
      "在根据语料构造好图后，下面需要完成的任务是：输入一个句子，提取出句子两两相邻的单词对，在图中进行一次检索，若句子的前后两单词w1→w2在单词图中隔着一个顶点b，则将b加入句子中，得到w1→b→w2。具体的构建规则如下：",
      "① w1与w2间只能间隔一个顶点，这也就是说，如果在图中出现了w1→a→b→w2，甚至间隔更多的情况，则不会在w1→w2间加入单词。",
      "② 如果从w1到w2同时有两条路径w1→a→w2与w1→b→w2，则选择权重最高路径上的单词加入w1与w2之间。",
      "③ 输出的句子中原单词的大小写保持不变，加入的单词全用小写。",
      "④ 可以存在指向自己的边，即该图可以是带环图。",
      "2.编写测试用例",
      "在理清思路后，我们可以着手开始编写测试用例，具体的测试策略为编写Poem与toString方法的测试用例，对于Poem，采用不同的语料，测试能否得到正确的输出；对于toString，则用不同用例测试toString方法的正确性。",
      "举个例子如图：",
      "mugar-omni-theater.txt",
      "中保存着语料",
      "This is a test of the Mugar Omni Theater sound system.",
      "此条测试的意义是输入句子input，经过图处理后，检验输出是否与我们的预期AccOutput相同。",
      "3.具体实现Poet",
      "在GraphPoet中，我们需要依次实现三个方法：",
      "1) 构造方法GraphPoet",
      "在GraphPoet的构造方法中，我们需要读取文本文档，并由其中语料按照前文所阐述的方法生成一个单词图。具体实现方式为：输入文件路径并按行读入，将单词进行切分，进行删除标点符号，大写转小写等预处理，每次取相邻元素在图中添加新边。",
      "2) 生成句子方法Poem",
      "Poem方法输入一个String参数作为原始句子，输出根据单词图匹配过的，扩充了bridge words的新句子。具体实现思路为一次读入两个单词，检索前一个单词子节点的子节点，若其中包含后一个单词，则选择途径通路权重最高的一路，将该路上途径节点表示的单词加入原来两单词之间。",
      "3) toString方法",
      "简单重写toString方法，将整个图中所有点的指向转化为一条字符串输出。",
      "4.测试代码覆盖度",
      "代码覆盖度建议尽量达到100%",
      "四、重构Lab 1中的Social Network",
      "这一环节要求我们基于在前面步骤中定义的Graph及其两种实现，将泛型L替换为Person，按照Lab1中Social NetWorek的要求，实现Lab1 Problem 3中FriendshipGraph的各种功能，并且尽可能复用我们在前文构造的类中已经实现的方法。最后，运行提供的main ( ) 和执行Lab1中的Junit测试用例，确保其正常运行。",
      "有Lab 1的基础，这部分的重构算是比较快的。利用",
      "ConcreteEdgesGraphTest",
      "ConcreteVerticesGraphTest",
      "其一便可完成。测试代码与main函数之间copy，略加修改就可。",
      "总得来说，Lab 2相较于前几届的版本，难度降低了很多，但仍有不易理解的地方，需要花一些时间才能完成。"
    ],
    "sentences": [
      "文章目录",
      "一、P1-Problem 1：编写测试用例",
      "1.GraphStaticTest",
      "2.GraphInstanceTest",
      "二、实现两个ADT",
      "1.AF",
      "RI",
      "Safety from Rep exposure .etc",
      "2.checkRep ( )",
      "3.方法的具体实现",
      "4.实现Graph.empty ( )",
      "三、Poetic Walks",
      "1.题目意思梳理（结合MIT页面和spec看）",
      "2.编写测试用例",
      "3.具体实现Poet",
      "1) 构造方法GraphPoet",
      "2) 生成句子方法Poem",
      "3) toString方法",
      "4.测试代码覆盖度",
      "四、重构Lab 1中的Social Network",
      "由于实验的介绍为MIT的全英文页面",
      "要点分散",
      "可能造成理解上的困难",
      "所以在这里梳理总结一下软构lab2的整个流程",
      "可以结合MIT的问题描述来看",
      "希望能帮到后来的学弟学妹",
      "不要拿到程序包直接两眼一抹黑",
      "不知从何下手",
      "写下这篇文章是在完成实验后进行回忆，如有疏漏请多指正",
      "先简单总结Lab 2完成的工作：从github将代码clone到本地",
      "根据已有spec完成测试用例的编写（P1",
      "Problem 1）",
      "再分别编写两个ADT：ConcreteVerticesGraph",
      "ConcreteEdgesGraph",
      "的具体实现（P1，Problem 2 / 3）",
      "之后",
      "我们利用两个ADT分别实现具体的类GraphPoet",
      "并完成一系列的工作（P1",
      "Problem 4）",
      "并重构我们在Lab 1中实现过的人际关系图（P2）",
      "本实验的完成基于IDEA",
      "可以方便地可视化代码覆盖度",
      "所以没有涉及安装EclEmma",
      "一、P1-Problem 1：编写测试用例",
      "按照TDD（Test-Driven Development",
      "测试驱动开发）的策略",
      "在编写具体实现之前",
      "我们需要根据已有的spec设计出对应方法的测试",
      "1.GraphStaticTest",
      "这一部分是对",
      "Graph.empty()",
      "的测试，可以先不用管，在完成 Problem 3.2 实现",
      "Graph.empty()",
      "之前，这一块的代码是跑不起来的XD",
      "对GraphStaticTest的补充也需要在Problem 3.2中进行",
      "2.GraphInstanceTest",
      "这一部分是对Graph中的具体方法进行测试",
      "需要好好构思构思",
      "如果刚开始草草写了/没有考虑周全",
      "那么在后面代码覆盖度过低",
      "会反复回头来修改这部分",
      "耽误很多时间！",
      "具体而言，这一部分要按等价类划分的方法，编写测试用例",
      "严格写下来的话，代码行数不少",
      "举个栗子：Testing strategy",
      "testRemove( )",
      "测试remove( )方法",
      "等价类划分如下：删除点是否在图中：是",
      "否",
      "删除点是否有相连边：是，否",
      "排除不可能的情况，共3个等价类，所以需要写三组测试",
      "另外，提醒考虑ADT对有环图的支持并测试，后续部分会用到",
      "二、实现两个ADT",
      "1.AF",
      "RI",
      "Safety from Rep exposure .etc",
      "具体实现两个ADT",
      "首先要求我们撰写相信很多同学这是第一次实际写一个程序的AF、RI",
      "这些概念的具体意义可以参见",
      "关于AF, RI, Rep exposure",
      "其实举个例子，照葫芦画瓢也还算容易",
      "例如，对于",
      "ConcreteEdgesGraph",
      "",
      "它的这些概念可以解释如下：Abstraction function:AF(vertices) = Graph中的点",
      "AF(edges) = Graph中的边",
      "Representation invariant:点的名字不能重复",
      "所有点都在vertices中",
      "edge的权值为正",
      "两点间的单向边最多只能有一条",
      "Safety from rep exposure:成员变量vertices与edges均用private final修饰",
      "防止其被外部修改",
      "在涉及返回内部变量时",
      "采用防御性拷贝的方式",
      "创造一份新的变量return",
      "2.checkRep ( )",
      "checkRep ( )部分就是针对RI设计出检查代码",
      "比如",
      "在RI中有一条“edge的权值为正”",
      "则在checkRep ( )中需要用",
      "assert语句",
      "检查edge的成员是否大于0",
      "在每次运行方法（如add",
      "set）且修改了成员变量后",
      "需要在return前调用checkRep ( )进行检查",
      "3.方法的具体实现",
      "在实现",
      "ConcreteVerticesGraph",
      "ConcreteEdgesGraph",
      "时",
      "MIT的页面要求先用String型",
      "再用泛型L",
      "其实可以直接用泛型L来写",
      "节省后续改的工作量",
      "若用泛型L来写",
      "则需要将两个ADT的部分内容修改为如下：相关方法的具体实现在这里暂且不表",
      "在完成方法的实现后",
      "可以通过前面写的测试用例来检验方法编写是否正确",
      "并看看代码覆盖度",
      "有哪些代码没有覆盖到",
      "（",
      "实验要求代码覆盖度尽可能达到100%",
      "在这里简单讲一下IDEA的代码覆盖度测试：运行之后：另外注意",
      "两个ADT中需要分别实现成员",
      "Edge",
      "与成员",
      "Vertex",
      "ConcreteEdgesGraphTest",
      "ConcreteVerticesGraphTest",
      "中，需要完成对",
      "Edge",
      "Vertex",
      "各自成员方法的测试",
      "4.实现Graph.empty ( )",
      "这一部分要求我们对",
      "Graph.java",
      "empty ( )",
      "方法进行实现，具体来说，就是让",
      "empty ( )",
      "方法返回两个具体ADT中的一个，如图：完成后，在",
      "GraphStaticTest",
      "中补充测试代码",
      "具体来说",
      "就是模仿已有代码",
      "验证在Interger",
      "Double等类型下是否正确",
      "如图：三、Poetic Walks",
      "到此",
      "我们已经完成了MIT页面上的Problem 1~3",
      "开始解决Problem 4",
      "1.题目意思梳理（结合MIT页面和spec看）",
      "在这一步中",
      "需要依据语料生成一个单词图",
      "单词图的每个顶点是语料中的一个单词",
      "单词图的边代表前一个单词紧接着后一个单词",
      "边的权重为前一个单词紧接着后一个单词的次数",
      "并且不考虑大小写与标点符号",
      "举个例子：hello,hello,HeLlo,world!",
      "其中",
      "hello→hello出现两次",
      "hello→world出现一次",
      "则这个语料构成的图为：更加具体的示例可以参照MIT实验官网的页面",
      "在根据语料构造好图后",
      "下面需要完成的任务是：输入一个句子",
      "提取出句子两两相邻的单词对",
      "在图中进行一次检索",
      "若句子的前后两单词w1→w2在单词图中隔着一个顶点b",
      "则将b加入句子中",
      "得到w1→b→w2",
      "具体的构建规则如下：① w1与w2间只能间隔一个顶点",
      "这也就是说",
      "如果在图中出现了w1→a→b→w2",
      "甚至间隔更多的情况",
      "则不会在w1→w2间加入单词",
      "② 如果从w1到w2同时有两条路径w1→a→w2与w1→b→w2",
      "则选择权重最高路径上的单词加入w1与w2之间",
      "③ 输出的句子中原单词的大小写保持不变，加入的单词全用小写",
      "④ 可以存在指向自己的边，即该图可以是带环图",
      "2.编写测试用例",
      "在理清思路后",
      "我们可以着手开始编写测试用例",
      "具体的测试策略为编写Poem与toString方法的测试用例",
      "对于Poem",
      "采用不同的语料",
      "测试能否得到正确的输出；对于toString",
      "则用不同用例测试toString方法的正确性",
      "举个例子如图：mugar-omni-theater.txt",
      "中保存着语料",
      "This is a test of the Mugar Omni Theater sound system.此条测试的意义是输入句子input",
      "经过图处理后",
      "检验输出是否与我们的预期AccOutput相同",
      "3.具体实现Poet",
      "在GraphPoet中",
      "我们需要依次实现三个方法：1) 构造方法GraphPoet",
      "在GraphPoet的构造方法中",
      "我们需要读取文本文档",
      "并由其中语料按照前文所阐述的方法生成一个单词图",
      "具体实现方式为：输入文件路径并按行读入",
      "将单词进行切分",
      "进行删除标点符号",
      "大写转小写等预处理",
      "每次取相邻元素在图中添加新边",
      "2) 生成句子方法Poem",
      "Poem方法输入一个String参数作为原始句子",
      "输出根据单词图匹配过的",
      "扩充了bridge words的新句子",
      "具体实现思路为一次读入两个单词",
      "检索前一个单词子节点的子节点",
      "若其中包含后一个单词",
      "则选择途径通路权重最高的一路",
      "将该路上途径节点表示的单词加入原来两单词之间",
      "3) toString方法",
      "简单重写toString方法",
      "将整个图中所有点的指向转化为一条字符串输出",
      "4.测试代码覆盖度",
      "代码覆盖度建议尽量达到100%",
      "四、重构Lab 1中的Social Network",
      "这一环节要求我们基于在前面步骤中定义的Graph及其两种实现",
      "将泛型L替换为Person",
      "按照Lab1中Social NetWorek的要求",
      "实现Lab1 Problem 3中FriendshipGraph的各种功能",
      "并且尽可能复用我们在前文构造的类中已经实现的方法",
      "最后",
      "运行提供的main ( ) 和执行Lab1中的Junit测试用例",
      "确保其正常运行",
      "有Lab 1的基础，这部分的重构算是比较快的",
      "利用",
      "ConcreteEdgesGraphTest",
      "ConcreteVerticesGraphTest",
      "其一便可完成",
      "测试代码与main函数之间copy，略加修改就可",
      "总得来说",
      "Lab 2相较于前几届的版本",
      "难度降低了很多",
      "但仍有不易理解的地方",
      "需要花一些时间才能完成"
    ],
    "codes": [
      "public class ConcreteEdgesGraph<L> implements Graph<L> { ... }\n\nclass Edge<L> { ... }\n",
      "public class ConcreteVerticesGraph<L> implements Graph<L> { ... }\n\nclass Vertex<L> { ... }\n"
    ],
    "date": "2021-06-14",
    "text": "文章目录\n一、P1-Problem 1：编写测试用例\n1.GraphStaticTest\n2.GraphInstanceTest\n二、实现两个ADT\n1.AF，RI，Safety from Rep exposure .etc\n2.checkRep ( )\n3.方法的具体实现\n4.实现Graph.empty ( )\n三、Poetic Walks\n1.题目意思梳理（结合MIT页面和spec看）\n2.编写测试用例\n3.具体实现Poet\n1) 构造方法GraphPoet\n2) 生成句子方法Poem\n3) toString方法\n4.测试代码覆盖度\n四、重构Lab 1中的Social Network\n由于实验的介绍为MIT的全英文页面，要点分散，可能造成理解上的困难。所以在这里梳理总结一下软构lab2的整个流程，可以结合MIT的问题描述来看。希望能帮到后来的学弟学妹，不要拿到程序包直接两眼一抹黑，不知从何下手。\n写下这篇文章是在完成实验后进行回忆，如有疏漏请多指正。\n先简单总结Lab 2完成的工作：从github将代码clone到本地，根据已有spec完成测试用例的编写（P1，Problem 1），再分别编写两个ADT：\nConcreteVerticesGraph\nConcreteEdgesGraph\n的具体实现（P1，Problem 2 / 3）。之后，我们利用两个ADT分别实现具体的类GraphPoet，并完成一系列的工作（P1，Problem 4）。并重构我们在Lab 1中实现过的人际关系图（P2）\n本实验的完成基于IDEA，可以方便地可视化代码覆盖度，所以没有涉及安装EclEmma。\n一、P1-Problem 1：编写测试用例\n按照TDD（Test-Driven Development，测试驱动开发）的策略，在编写具体实现之前，我们需要根据已有的spec设计出对应方法的测试。\n1.GraphStaticTest\n这一部分是对\nGraph.empty()\n的测试，可以先不用管，在完成 Problem 3.2 实现\nGraph.empty()\n之前，这一块的代码是跑不起来的XD\n对GraphStaticTest的补充也需要在Problem 3.2中进行。\n2.GraphInstanceTest\n这一部分是对Graph中的具体方法进行测试，需要好好构思构思，\n如果刚开始草草写了/没有考虑周全，那么在后面代码覆盖度过低，会反复回头来修改这部分，耽误很多时间！\n具体而言，这一部分要按等价类划分的方法，编写测试用例。严格写下来的话，代码行数不少。举个栗子：\nTesting strategy\ntestRemove( )\n测试remove( )方法，等价类划分如下：\n删除点是否在图中：是，否\n删除点是否有相连边：是，否\n排除不可能的情况，共3个等价类，所以需要写三组测试。\n另外，提醒考虑ADT对有环图的支持并测试，后续部分会用到。\n二、实现两个ADT\n1.AF，RI，Safety from Rep exposure .etc\n具体实现两个ADT，首先要求我们撰写相信很多同学这是第一次实际写一个程序的AF、RI，这些概念的具体意义可以参见\n关于AF, RI, Rep exposure\n其实举个例子，照葫芦画瓢也还算容易。例如，对于\nConcreteEdgesGraph\n，它的这些概念可以解释如下：\nAbstraction function:\nAF(vertices) = Graph中的点\nAF(edges) = Graph中的边\nRepresentation invariant:\n点的名字不能重复\n所有点都在vertices中\nedge的权值为正\n两点间的单向边最多只能有一条\nSafety from rep exposure:\n成员变量vertices与edges均用private final修饰，防止其被外部修改\n在涉及返回内部变量时，采用防御性拷贝的方式，创造一份新的变量return\n2.checkRep ( )\ncheckRep ( )部分就是针对RI设计出检查代码。比如，在RI中有一条“edge的权值为正”，则在checkRep ( )中需要用\nassert语句\n检查edge的成员是否大于0，\n在每次运行方法（如add，set）且修改了成员变量后，需要在return前调用checkRep ( )进行检查\n3.方法的具体实现\n在实现\nConcreteVerticesGraph\nConcreteEdgesGraph\n时，MIT的页面要求先用String型，再用泛型L，其实可以直接用泛型L来写，节省后续改的工作量。若用泛型L来写，则需要将两个ADT的部分内容修改为如下：\n相关方法的具体实现在这里暂且不表，在完成方法的实现后，可以通过前面写的测试用例来检验方法编写是否正确，并看看代码覆盖度，有哪些代码没有覆盖到。（\n实验要求代码覆盖度尽可能达到100%\n在这里简单讲一下IDEA的代码覆盖度测试：\n运行之后：\n另外注意，两个ADT中需要分别实现成员\nEdge\n与成员\nVertex\nConcreteEdgesGraphTest\nConcreteVerticesGraphTest\n中，需要完成对\nEdge\nVertex\n各自成员方法的测试。\n4.实现Graph.empty ( )\n这一部分要求我们对\nGraph.java\nempty ( )\n方法进行实现，具体来说，就是让\nempty ( )\n方法返回两个具体ADT中的一个，如图：\n完成后，在\nGraphStaticTest\n中补充测试代码，具体来说，就是模仿已有代码，验证在Interger，Double等类型下是否正确，如图：\n三、Poetic Walks\n到此，我们已经完成了MIT页面上的Problem 1~3，开始解决Problem 4。\n1.题目意思梳理（结合MIT页面和spec看）\n在这一步中，需要依据语料生成一个单词图，单词图的每个顶点是语料中的一个单词，单词图的边代表前一个单词紧接着后一个单词，边的权重为前一个单词紧接着后一个单词的次数，并且不考虑大小写与标点符号。举个例子：\nhello,hello,HeLlo,world!\n其中，hello→hello出现两次，hello→world出现一次，则这个语料构成的图为：\n更加具体的示例可以参照MIT实验官网的页面。\n在根据语料构造好图后，下面需要完成的任务是：输入一个句子，提取出句子两两相邻的单词对，在图中进行一次检索，若句子的前后两单词w1→w2在单词图中隔着一个顶点b，则将b加入句子中，得到w1→b→w2。具体的构建规则如下：\n① w1与w2间只能间隔一个顶点，这也就是说，如果在图中出现了w1→a→b→w2，甚至间隔更多的情况，则不会在w1→w2间加入单词。\n② 如果从w1到w2同时有两条路径w1→a→w2与w1→b→w2，则选择权重最高路径上的单词加入w1与w2之间。\n③ 输出的句子中原单词的大小写保持不变，加入的单词全用小写。\n④ 可以存在指向自己的边，即该图可以是带环图。\n2.编写测试用例\n在理清思路后，我们可以着手开始编写测试用例，具体的测试策略为编写Poem与toString方法的测试用例，对于Poem，采用不同的语料，测试能否得到正确的输出；对于toString，则用不同用例测试toString方法的正确性。\n举个例子如图：\nmugar-omni-theater.txt\n中保存着语料\nThis is a test of the Mugar Omni Theater sound system.\n此条测试的意义是输入句子input，经过图处理后，检验输出是否与我们的预期AccOutput相同。\n3.具体实现Poet\n在GraphPoet中，我们需要依次实现三个方法：\n1) 构造方法GraphPoet\n在GraphPoet的构造方法中，我们需要读取文本文档，并由其中语料按照前文所阐述的方法生成一个单词图。具体实现方式为：输入文件路径并按行读入，将单词进行切分，进行删除标点符号，大写转小写等预处理，每次取相邻元素在图中添加新边。\n2) 生成句子方法Poem\nPoem方法输入一个String参数作为原始句子，输出根据单词图匹配过的，扩充了bridge words的新句子。具体实现思路为一次读入两个单词，检索前一个单词子节点的子节点，若其中包含后一个单词，则选择途径通路权重最高的一路，将该路上途径节点表示的单词加入原来两单词之间。\n3) toString方法\n简单重写toString方法，将整个图中所有点的指向转化为一条字符串输出。\n4.测试代码覆盖度\n代码覆盖度建议尽量达到100%\n四、重构Lab 1中的Social Network\n这一环节要求我们基于在前面步骤中定义的Graph及其两种实现，将泛型L替换为Person，按照Lab1中Social NetWorek的要求，实现Lab1 Problem 3中FriendshipGraph的各种功能，并且尽可能复用我们在前文构造的类中已经实现的方法。最后，运行提供的main ( ) 和执行Lab1中的Junit测试用例，确保其正常运行。\n有Lab 1的基础，这部分的重构算是比较快的。利用\nConcreteEdgesGraphTest\nConcreteVerticesGraphTest\n其一便可完成。测试代码与main函数之间copy，略加修改就可。\n总得来说，Lab 2相较于前几届的版本，难度降低了很多，但仍有不易理解的地方，需要花一些时间才能完成。\n"
  },
  {
    "head": "Java实现无向图深搜确定任意两点间最短距离",
    "paragraphs": [
      "软件构造lab1实验中编写的Problem3部分，在此处做个记录",
      "涉及的数据类，方法",
      "Graph类",
      "表示无向图。其下有几个重要变量：",
      "persons：为ArrayList，用于保存graph中的节点。其定义为：",
      "public",
      "List",
      "Person",
      "persons",
      "new",
      "ArrayList",
      "Person",
      "relationships：为嵌套的Vector，保存节点间的关系矩阵。若两节点直接相连，则对应位置为1；若两节点不直接相连，则对应位置为0。其定义为：",
      "public",
      "Vector",
      "Vector",
      "Integer",
      "relationships",
      "new",
      "Vector",
      "Vector",
      "Integer",
      "Person类",
      "表示图中的顶点。具有",
      "name",
      "index",
      "两个私有变量，",
      "name",
      "为String类型，表示名称，是顶点的标识；",
      "index",
      "为int型，代表顶点在关系矩阵中对应第index行与第index列。若顶点不在图中，则",
      "index",
      "为默认值-1。",
      "getDistance方法",
      "输入参数为两个Person顶点，返回值为两顶点间的最短距离。为了方便说明，规定相连两点间距为1。方法声明为：",
      "public",
      "int",
      "getDistance",
      "Person p1",
      "Person p2",
      "算法基本思想",
      "首先对异常情况进行判断，若输入两顶点相同 / 有不在图中的顶点，则直接返回-1。实现方法为具体根据person的index与name成员判断。",
      "BFS深搜",
      "。具体的实现如下：",
      "首先构造以下三个变量：",
      "int",
      "distance",
      "// 起始点到终点的距离，初始为0",
      "Queue",
      "Person",
      "queue",
      "new",
      "LinkedList",
      "Person",
      "// 队列，用于BFS搜索",
      "int",
      "visit",
      "new",
      "int",
      "persons",
      "size",
      "// visit数组（visit为标志是否访问过的数组,访问过为1，否则为0）",
      "boolean",
      "isQueueEnd",
      "new",
      "boolean",
      "persons",
      "size",
      "// isQueueEnd标志节点i是否是某轮bfs深搜的终点，若是，其为true，,需要使distance++",
      "在我们的算法中，先将初始顶点",
      "加入队列，因为其访问过，且为第0轮深搜的终点，故设置",
      "visit[]",
      "isQueueEnd[]",
      "对应位为1。然后弹出该顶点，依次搜索与该顶点直接相连的顶点入队，将这些顶点的",
      "visit[]",
      "位均设置为1，",
      "且设置当前轮最后一个入队顶点的",
      "isQueueEnd[]",
      "对应位为1",
      "，由此，便完成了一轮BFS搜索。",
      "终结情况判断：",
      "当队首为终结顶点",
      "时，正常结束，返回",
      "distance",
      "当检测到队空时，说明没有从",
      "的通路，返回-1",
      "以下图为例来解释我们的算法：",
      "假设计算从P1到P6的距离：",
      "1. 先将P1入队",
      "2.弹出P1，加入P2,P3,P4，并标记P4为当前轮终点，distance++。",
      "3.之后按顺序依次进行:",
      "直到队首为P6，返回此时的distance值。",
      "具体实现",
      "person类",
      "getDistance()方法"
    ],
    "sentences": [
      "软件构造lab1实验中编写的Problem3部分",
      "在此处做个记录",
      "涉及的数据类，方法",
      "Graph类",
      "表示无向图",
      "其下有几个重要变量：persons：为ArrayList",
      "用于保存graph中的节点",
      "其定义为：public",
      "List",
      "Person",
      "persons",
      "new",
      "ArrayList",
      "Person",
      "relationships：为嵌套的Vector",
      "保存节点间的关系矩阵",
      "若两节点直接相连",
      "则对应位置为1；若两节点不直接相连",
      "则对应位置为0",
      "其定义为：public",
      "Vector",
      "Vector",
      "Integer",
      "relationships",
      "new",
      "Vector",
      "Vector",
      "Integer",
      "Person类",
      "表示图中的顶点",
      "具有",
      "name",
      "index",
      "两个私有变量，name",
      "为String类型，表示名称，是顶点的标识；index",
      "为int型",
      "代表顶点在关系矩阵中对应第index行与第index列",
      "若顶点不在图中，则",
      "index",
      "为默认值-1",
      "getDistance方法",
      "输入参数为两个Person顶点，返回值为两顶点间的最短距离",
      "为了方便说明，规定相连两点间距为1",
      "方法声明为：public",
      "int",
      "getDistance",
      "Person p1",
      "Person p2",
      "算法基本思想",
      "首先对异常情况进行判断",
      "若输入两顶点相同 / 有不在图中的顶点",
      "则直接返回-1",
      "实现方法为具体根据person的index与name成员判断",
      "BFS深搜",
      "具体的实现如下：首先构造以下三个变量：int",
      "distance",
      "// 起始点到终点的距离，初始为0",
      "Queue",
      "Person",
      "queue",
      "new",
      "LinkedList",
      "Person",
      "// 队列，用于BFS搜索",
      "int",
      "visit",
      "new",
      "int",
      "persons",
      "size",
      "// visit数组（visit为标志是否访问过的数组,访问过为1",
      "否则为0）",
      "boolean",
      "isQueueEnd",
      "new",
      "boolean",
      "persons",
      "size",
      "// isQueueEnd标志节点i是否是某轮bfs深搜的终点",
      "若是",
      "其为true",
      ",需要使distance++",
      "在我们的算法中，先将初始顶点",
      "加入队列，因为其访问过，且为第0轮深搜的终点，故设置",
      "visit[]",
      "isQueueEnd[]",
      "对应位为1",
      "然后弹出该顶点",
      "依次搜索与该顶点直接相连的顶点入队",
      "将这些顶点的",
      "visit[]",
      "位均设置为1，且设置当前轮最后一个入队顶点的",
      "isQueueEnd[]",
      "对应位为1",
      "，由此，便完成了一轮BFS搜索",
      "终结情况判断：当队首为终结顶点",
      "时，正常结束，返回",
      "distance",
      "当检测到队空时，说明没有从",
      "的通路，返回-1",
      "以下图为例来解释我们的算法：假设计算从P1到P6的距离：1. 先将P1入队",
      "2.弹出P1",
      "加入P2,P3,P4",
      "并标记P4为当前轮终点",
      "distance++",
      "3.之后按顺序依次进行:直到队首为P6",
      "返回此时的distance值",
      "具体实现",
      "person类",
      "getDistance()方法"
    ],
    "codes": [
      "public List<Person> persons = new ArrayList<Person>();\n",
      "public Vector<Vector<Integer>> relationships = new Vector<Vector<Integer>>();\n",
      "public int getDistance(Person p1, Person p2) \n",
      "int distance =0; // 起始点到终点的距离，初始为0\nQueue<Person> queue = new LinkedList<Person>(); // 队列，用于BFS搜索\nint[] visit = new int[persons.size()]; // visit数组（visit为标志是否访问过的数组,访问过为1，否则为0）\nboolean[] isQueueEnd = new boolean[persons.size()];  // isQueueEnd标志节点i是否是某轮bfs深搜的终点，若是，其为true，,需要使distance++\n",
      "public class Person {\n    private String name;\n    private int index = -1;\n\n    public Person(String name){\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n}\n",
      "/**\n     * Add a new edge from p1 to p2.\n     *\n     * @param p1 The starting vertex of the new edge\n     * @param p2 The ending vertex of the new edge\n     * @return The shortest distance between p1 and p2. If there are no any paths between them, return -1.\n     */\n    public int getDistance(Person p1, Person p2) {\n        // 异常情况处理\n        // p1与p2有其一不在关系图中\n        if (p1.getIndex() == -1) {\n            System.out.print(p1.getName() + \"不在关系图中\");\n            return -1;\n        }\n        if (p2.getIndex() == -1) {\n            System.out.print(p2.getName() + \"不在关系图中\");\n            return -1;\n        }\n        // p1与p2相等\n        if (p1.getIndex() == p2.getIndex()) {\n            return 0;\n        }\n        Queue<Person> queue = new LinkedList<Person>(); // 队列，用于BFS搜素\n        int distance = 0;\n        Person temp = new Person(\"\");\n        Person queueEnd = new Person(\"\");\n        Vector<Integer> tempCol = new Vector<Integer>();\n        // visit数组（visit为标志是否访问过的数组,访问过为1，否则为0）\n        int[] visit = new int[persons.size()];\n        // isQueueEnd标志节点i是否是某轮bfs深搜的终点，若是，其为true，,需要使distance++\n        boolean[] isQueueEnd = new boolean[persons.size()];\n\n\n        // 初始化，对p1进行设定\n        queue.add(p1);\n        visit[p1.getIndex()] = 1;\n        isQueueEnd[p1.getIndex()]=true;\n\n        while (queue.peek() != p2) {\n            temp = queue.poll(); // 弹出并保存queue的头元素\n            // 将与queue头元素直接相连，且未访问过的元素入队\n            tempCol = relationships.get(temp.getIndex()); // tempCol保存头元素对应的关系矩阵行\n            for (int i = 0; i < tempCol.size(); i++) { // 头元素对应的关系矩阵行，遍历此行中的所有元素，找到与头元素直接相邻的元素\n                if (tempCol.get(i) == 1) {\n                    // 查找index为i的person，并将其加入队列,同时把其标记为访问过\n                    for (Person t : persons) {\n                        if (t.getIndex() == i && visit[i] == 0) {\n                            queue.add(t);\n                            visit[i] = 1;\n                            queueEnd = t; // 记录当前队尾\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // 最后队列空，说明没有p1到p2的直接通路\n            if (queue.isEmpty())\n                return -1;\n\n            // 记录当前队尾，并使distance++\n            if (isQueueEnd[temp.getIndex()]) {\n                isQueueEnd[queueEnd.getIndex()]=true;\n                distance++;\n            }\n        }\n        return distance;\n    }\n"
    ],
    "date": "2021-05-24",
    "text": "软件构造lab1实验中编写的Problem3部分，在此处做个记录\n涉及的数据类，方法\nGraph类\n表示无向图。其下有几个重要变量：\npersons：为ArrayList，用于保存graph中的节点。其定义为：\npublic\nList\nPerson\npersons\nnew\nArrayList\nPerson\nrelationships：为嵌套的Vector，保存节点间的关系矩阵。若两节点直接相连，则对应位置为1；若两节点不直接相连，则对应位置为0。其定义为：\npublic\nVector\nVector\nInteger\nrelationships\nnew\nVector\nVector\nInteger\nPerson类\n表示图中的顶点。具有\nname\nindex\n两个私有变量，\nname\n为String类型，表示名称，是顶点的标识；\nindex\n为int型，代表顶点在关系矩阵中对应第index行与第index列。若顶点不在图中，则\nindex\n为默认值-1。\ngetDistance方法\n输入参数为两个Person顶点，返回值为两顶点间的最短距离。为了方便说明，规定相连两点间距为1。方法声明为：\npublic\nint\ngetDistance\nPerson p1\nPerson p2\n算法基本思想\n首先对异常情况进行判断，若输入两顶点相同 / 有不在图中的顶点，则直接返回-1。实现方法为具体根据person的index与name成员判断。\nBFS深搜\n。具体的实现如下：\n首先构造以下三个变量：\nint\ndistance\n// 起始点到终点的距离，初始为0\nQueue\nPerson\nqueue\nnew\nLinkedList\nPerson\n// 队列，用于BFS搜索\nint\nvisit\nnew\nint\npersons\nsize\n// visit数组（visit为标志是否访问过的数组,访问过为1，否则为0）\nboolean\nisQueueEnd\nnew\nboolean\npersons\nsize\n// isQueueEnd标志节点i是否是某轮bfs深搜的终点，若是，其为true，,需要使distance++\n在我们的算法中，先将初始顶点\n加入队列，因为其访问过，且为第0轮深搜的终点，故设置\nvisit[]\nisQueueEnd[]\n对应位为1。然后弹出该顶点，依次搜索与该顶点直接相连的顶点入队，将这些顶点的\nvisit[]\n位均设置为1，\n且设置当前轮最后一个入队顶点的\nisQueueEnd[]\n对应位为1\n，由此，便完成了一轮BFS搜索。\n终结情况判断：\n当队首为终结顶点\n时，正常结束，返回\ndistance\n当检测到队空时，说明没有从\n的通路，返回-1\n以下图为例来解释我们的算法：\n假设计算从P1到P6的距离：\n1. 先将P1入队\n2.弹出P1，加入P2,P3,P4，并标记P4为当前轮终点，distance++。\n3.之后按顺序依次进行:\n直到队首为P6，返回此时的distance值。\n具体实现\nperson类\ngetDistance()方法\n"
  },
  {
    "head": "Github 将https方式改为ssh方式，进行push与clone",
    "paragraphs": [
      "使用Git提交到Github时，若采用默认的https方式进行push与clone，则会比较慢，且对大文件容易出现报错的情况，故我们可以将其改为ssh方式。",
      "打开Github的仓库，点击code，进入显示ssh的页面",
      "到本地项目文件夹子，打开git bash。查看clone 地址：gitremote -v",
      "移除https的方式 gitremote rm origin",
      "添加新的git方式：ssh方式，ssh方式地址的话，在github上，切换到ssh方式，然后复制地址。",
      "git remote add origin 刚刚复制的git地址",
      "gitremote -v",
      "看到地址是以git@github.com:开头，说明ssh方式添加成功",
      "重新push（提交一下）",
      "gitpush origin maste",
      "完成以上步骤，便由https方式改为了ssh方式。"
    ],
    "sentences": [
      "使用Git提交到Github时",
      "若采用默认的https方式进行push与clone",
      "则会比较慢",
      "且对大文件容易出现报错的情况",
      "故我们可以将其改为ssh方式",
      "打开Github的仓库，点击code，进入显示ssh的页面",
      "到本地项目文件夹子，打开git bash",
      "查看clone 地址：gitremote -v",
      "移除https的方式 gitremote rm origin",
      "添加新的git方式：ssh方式",
      "ssh方式地址的话",
      "在github上",
      "切换到ssh方式",
      "然后复制地址",
      "git remote add origin 刚刚复制的git地址",
      "gitremote -v",
      "看到地址是以git@github.com:开头",
      "说明ssh方式添加成功",
      "重新push（提交一下）",
      "gitpush origin maste",
      "完成以上步骤，便由https方式改为了ssh方式"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "使用Git提交到Github时，若采用默认的https方式进行push与clone，则会比较慢，且对大文件容易出现报错的情况，故我们可以将其改为ssh方式。\n打开Github的仓库，点击code，进入显示ssh的页面\n到本地项目文件夹子，打开git bash。查看clone 地址：gitremote -v\n移除https的方式 gitremote rm origin\n添加新的git方式：ssh方式，ssh方式地址的话，在github上，切换到ssh方式，然后复制地址。\ngit remote add origin 刚刚复制的git地址\ngitremote -v\n看到地址是以git@github.com:开头，说明ssh方式添加成功\n重新push（提交一下）\ngitpush origin maste\n完成以上步骤，便由https方式改为了ssh方式。\n"
  },
  {
    "head": "git配置SSH公钥，并与github在线仓库进行链接",
    "paragraphs": [
      "首先参考其他资料",
      "完成git的安装",
      "然后步入正题：",
      "ssh公钥的生成",
      "1.进入 C:\\Users\\Administrator\\.ssh文件夹",
      "2.在.ssh文件夹下打开git bash，输入",
      "ssh-keygen -t rsa",
      "，输入后一直回车即可生成秘钥：",
      "3.回到.ssh文件夹，可以看到生成的公钥与私钥。用记事本打开id_rsa.pub，复制其中内容到github的秘钥设置页面：",
      "最后点击Add SSH Key，便完成了秘钥的设置。",
      "SSH公钥链接在线仓库",
      "来链接对应仓库",
      "相比https，通过ssh进行链接的好处是速度更快，且没有文件大小的上传限制。",
      "https://lanlan2017.github.io/blog/9f3d9944/"
    ],
    "sentences": [
      "首先参考其他资料",
      "完成git的安装",
      "然后步入正题：ssh公钥的生成",
      "1.进入 C:\\Users\\Administrator\\.ssh文件夹",
      "2.在.ssh文件夹下打开git bash，输入",
      "ssh-keygen -t rsa",
      "",
      "输入后一直回车即可生成秘钥：3.回到.ssh文件夹",
      "可以看到生成的公钥与私钥",
      "用记事本打开id_rsa.pub",
      "复制其中内容到github的秘钥设置页面：最后点击Add SSH Key",
      "便完成了秘钥的设置",
      "SSH公钥链接在线仓库",
      "来链接对应仓库",
      "相比https",
      "通过ssh进行链接的好处是速度更快",
      "且没有文件大小的上传限制",
      "https://lanlan2017.github.io/blog/9f3d9944/"
    ],
    "codes": [
      "git remote set url origin 在线仓库SSH地址\n"
    ],
    "date": "2021-05-23",
    "text": "首先参考其他资料\n完成git的安装\n然后步入正题：\nssh公钥的生成\n1.进入 C:\\Users\\Administrator\\.ssh文件夹\n2.在.ssh文件夹下打开git bash，输入\nssh-keygen -t rsa\n，输入后一直回车即可生成秘钥：\n3.回到.ssh文件夹，可以看到生成的公钥与私钥。用记事本打开id_rsa.pub，复制其中内容到github的秘钥设置页面：\n最后点击Add SSH Key，便完成了秘钥的设置。\nSSH公钥链接在线仓库\n来链接对应仓库\n相比https，通过ssh进行链接的好处是速度更快，且没有文件大小的上传限制。\nhttps://lanlan2017.github.io/blog/9f3d9944/\n"
  },
  {
    "head": "VS Code下运行Python程序报错ModuleNotFoundError的解决方案",
    "paragraphs": [
      "基本情况：安装了Anaconda虚拟环境，在用VS Code写Python程序时，遇见了这样的错误：",
      "ModuleNotFoundError: No module named ‘torch’",
      "经过测试，只有部分包如tensorflow, keras无法导入，而其他一些包如xlwt则导入正常，可以使用。",
      "查找了网上的很多方法，如修改setting.json文件，并没有起到作用，最后通过开启设置中的run in terminal功能得以解决：",
      "Ctrl + Shift + P 打开用户设置 → 拓展 → Run Code Configuration → 勾选 Run In Terminal 即可。"
    ],
    "sentences": [
      "基本情况：安装了Anaconda虚拟环境",
      "在用VS Code写Python程序时",
      "遇见了这样的错误：ModuleNotFoundError: No module named ‘torch’",
      "经过测试",
      "只有部分包如tensorflow, keras无法导入",
      "而其他一些包如xlwt则导入正常",
      "可以使用",
      "查找了网上的很多方法",
      "如修改setting.json文件",
      "并没有起到作用",
      "最后通过开启设置中的run in terminal功能得以解决：Ctrl + Shift + P 打开用户设置 → 拓展 → Run Code Configuration → 勾选 Run In Terminal 即可"
    ],
    "codes": [],
    "date": "2021-03-28",
    "text": "基本情况：安装了Anaconda虚拟环境，在用VS Code写Python程序时，遇见了这样的错误：\nModuleNotFoundError: No module named ‘torch’\n经过测试，只有部分包如tensorflow, keras无法导入，而其他一些包如xlwt则导入正常，可以使用。\n查找了网上的很多方法，如修改setting.json文件，并没有起到作用，最后通过开启设置中的run in terminal功能得以解决：\nCtrl + Shift + P 打开用户设置 → 拓展 → Run Code Configuration → 勾选 Run In Terminal 即可。\n"
  },
  {
    "head": "新添加jar包，IDEA的maven工程pom.xml添加新的依赖时报错（Travis CI在线build）",
    "paragraphs": [
      "笔者因为写JUnit测试用例时用到了",
      "assertThat(MapObject, hasEntry(\"key\",\"value\"));",
      "IDEA报错但根据提示仍不知道原因，后面才知道原来需要一个jar包--",
      "hamcrest-all.jar",
      "https://search.maven.org/search?q=g:org.hamcrest",
      "中下载了该包并将其移动到",
      ".m2\\repository\\org\\hamcrest目录下，然后从IDEA的Project Structure中添加了该包",
      "一开始没添加依赖到pom.xml，直到要上传到GitHub并且在Travis CI进行在线build的时候，才添加依赖于pom.xml中，但出现了报错（",
      "因为之前问题解决了，所以现在hamcrest-all和它的version不报错了，这里拿hamcrest-library做实验",
      "），出现红字：",
      "可以先在IDEA",
      "右侧的maven处点击reload",
      "如果字体不红的话问题就解决了，",
      "但如果还不行的话，可能就要",
      "把jar包安装到本地仓库",
      "当然前提是你需要安装和配置maven（教程挺多的）",
      "安装配置后然后打开cmd，首先cd到你放置你新安装jar包的目录下，",
      "然后输入：（这里拿hamcrest-all-1.3为例）",
      "-DgroupId、-DartifactId、-Dversion",
      "均可以在依赖中看到，",
      "（能查看添加依赖的网站：",
      "https://mvnrepository.com",
      "-Dpackaging",
      "为包的类型，即jar",
      "-Dfile",
      "是当时新添加的包的名字。",
      "输完命令后回车，然后若提示BUILD SUCCESS，则jar包安装到本地仓库成功。",
      "成功后回到IDEA下再次",
      "reload。"
    ],
    "sentences": [
      "笔者因为写JUnit测试用例时用到了",
      "assertThat(MapObject, hasEntry(\"key\",\"value\"));IDEA报错但根据提示仍不知道原因",
      "后面才知道原来需要一个jar包--",
      "hamcrest-all.jar",
      "https://search.maven.org/search?q=g:org.hamcrest",
      "中下载了该包并将其移动到",
      ".m2\\repository\\org\\hamcrest目录下",
      "然后从IDEA的Project Structure中添加了该包",
      "一开始没添加依赖到pom.xml",
      "直到要上传到GitHub并且在Travis CI进行在线build的时候",
      "才添加依赖于pom.xml中",
      "但出现了报错（",
      "因为之前问题解决了",
      "所以现在hamcrest-all和它的version不报错了",
      "这里拿hamcrest-library做实验",
      "），出现红字：可以先在IDEA",
      "右侧的maven处点击reload",
      "如果字体不红的话问题就解决了，但如果还不行的话，可能就要",
      "把jar包安装到本地仓库",
      "当然前提是你需要安装和配置maven（教程挺多的）",
      "安装配置后然后打开cmd",
      "首先cd到你放置你新安装jar包的目录下",
      "然后输入：（这里拿hamcrest-all-1.3为例）",
      "-DgroupId、-DartifactId、-Dversion",
      "均可以在依赖中看到",
      "（能查看添加依赖的网站：https://mvnrepository.com",
      "-Dpackaging",
      "为包的类型，即jar",
      "-Dfile",
      "是当时新添加的包的名字",
      "输完命令后回车",
      "然后若提示BUILD SUCCESS",
      "则jar包安装到本地仓库成功",
      "成功后回到IDEA下再次",
      "reload"
    ],
    "codes": [
      "mvn install:install-file -DgroupId=org.hamcrest -DartifactId=hamcrest-all -Dversion=1.3 -Dpackaging=jar -Dfile=hamcrest-all-1.3.jar"
    ],
    "date": "2021-06-01",
    "text": "笔者因为写JUnit测试用例时用到了\nassertThat(MapObject, hasEntry(\"key\",\"value\"));\nIDEA报错但根据提示仍不知道原因，后面才知道原来需要一个jar包--\nhamcrest-all.jar\nhttps://search.maven.org/search?q=g:org.hamcrest\n中下载了该包并将其移动到\n.m2\\repository\\org\\hamcrest目录下，然后从IDEA的Project Structure中添加了该包\n一开始没添加依赖到pom.xml，直到要上传到GitHub并且在Travis CI进行在线build的时候，才添加依赖于pom.xml中，但出现了报错（\n因为之前问题解决了，所以现在hamcrest-all和它的version不报错了，这里拿hamcrest-library做实验\n），出现红字：\n可以先在IDEA\n右侧的maven处点击reload\n如果字体不红的话问题就解决了，\n但如果还不行的话，可能就要\n把jar包安装到本地仓库\n当然前提是你需要安装和配置maven（教程挺多的）\n安装配置后然后打开cmd，首先cd到你放置你新安装jar包的目录下，\n然后输入：（这里拿hamcrest-all-1.3为例）\n-DgroupId、-DartifactId、-Dversion\n均可以在依赖中看到，\n（能查看添加依赖的网站：\nhttps://mvnrepository.com\n-Dpackaging\n为包的类型，即jar\n-Dfile\n是当时新添加的包的名字。\n输完命令后回车，然后若提示BUILD SUCCESS，则jar包安装到本地仓库成功。\n成功后回到IDEA下再次\nreload。\n"
  },
  {
    "head": "HIT软件构造Lab3实验心得",
    "paragraphs": [
      "首先是有关Git的，删除分支的一些操作，因为IDEA不能删除特定分支（可能是我不会？），",
      "先是git branch -b main，这个main指的是你要删除的",
      "分支的名字，",
      "而后是git push origin --delete main，main指的是你要删除的",
      "远程仓库",
      "分支的名字。",
      "接下来是整个实验一个很重要的地方，是关于MultiIntervalSet如何",
      "IntervalSet，这部分是个难点，我的想法是增加一个私有的成员变量xxx，其类型为List<IntervalSet<L>>，然后List中的元素的存放的时间段数量依次递减，insert时就寻找还没有插入该label的IntervalSet即可。",
      "然后是装饰器Decorator，实现checkBlank或checkOverlap是通过两个具体装饰角色来进行的，而装饰器和具体装饰角色的其他方法是直接return的，此时如果已经插入有很多时间段的intervalSet进行装饰后，调用相关方法就会出现固定的返回值，因此我们要checkBlank时，需新建立一个变量，通过",
      "IntervalSet<L> intervalset = new 具体装饰角色的名字(intervalSet);",
      "声明后调用checkBlank即可完成检查，而后续还需要用intervalSet时只能用intervalSet来调用方法，因为intervalset调用方法的返回值是固定的。"
    ],
    "sentences": [
      "首先是有关Git的",
      "删除分支的一些操作",
      "因为IDEA不能删除特定分支（可能是我不会？）",
      "先是git branch -b main",
      "这个main指的是你要删除的",
      "分支的名字",
      "而后是git push origin --delete main",
      "main指的是你要删除的",
      "远程仓库",
      "分支的名字",
      "接下来是整个实验一个很重要的地方",
      "是关于MultiIntervalSet如何",
      "IntervalSet",
      "这部分是个难点",
      "我的想法是增加一个私有的成员变量xxx",
      "其类型为List<IntervalSet<L>>",
      "然后List中的元素的存放的时间段数量依次递减",
      "insert时就寻找还没有插入该label的IntervalSet即可",
      "然后是装饰器Decorator",
      "实现checkBlank或checkOverlap是通过两个具体装饰角色来进行的",
      "而装饰器和具体装饰角色的其他方法是直接return的",
      "此时如果已经插入有很多时间段的intervalSet进行装饰后",
      "调用相关方法就会出现固定的返回值",
      "因此我们要checkBlank时",
      "需新建立一个变量",
      "通过",
      "IntervalSet<L> intervalset = new 具体装饰角色的名字(intervalSet);声明后调用checkBlank即可完成检查",
      "而后续还需要用intervalSet时只能用intervalSet来调用方法",
      "因为intervalset调用方法的返回值是固定的"
    ],
    "codes": [],
    "date": "2021-07-02",
    "text": "首先是有关Git的，删除分支的一些操作，因为IDEA不能删除特定分支（可能是我不会？），\n先是git branch -b main，这个main指的是你要删除的\n分支的名字，\n而后是git push origin --delete main，main指的是你要删除的\n远程仓库\n分支的名字。\n接下来是整个实验一个很重要的地方，是关于MultiIntervalSet如何\nIntervalSet，这部分是个难点，我的想法是增加一个私有的成员变量xxx，其类型为List<IntervalSet<L>>，然后List中的元素的存放的时间段数量依次递减，insert时就寻找还没有插入该label的IntervalSet即可。\n然后是装饰器Decorator，实现checkBlank或checkOverlap是通过两个具体装饰角色来进行的，而装饰器和具体装饰角色的其他方法是直接return的，此时如果已经插入有很多时间段的intervalSet进行装饰后，调用相关方法就会出现固定的返回值，因此我们要checkBlank时，需新建立一个变量，通过\nIntervalSet<L> intervalset = new 具体装饰角色的名字(intervalSet);\n声明后调用checkBlank即可完成检查，而后续还需要用intervalSet时只能用intervalSet来调用方法，因为intervalset调用方法的返回值是固定的。\n"
  },
  {
    "head": "Java环境的配置",
    "paragraphs": [
      "课程最开始配置Java环境，但是完全没有学习过Java。之前学习C语言，编译器和环境只需要直接安装一个软件即可，而对于Java的环境配置很复杂，最后从Mooc上的新手课程中才搞清楚各种环境的关系。",
      "对于Java的在官网上，环境相关的有JVM，JDK，JRE，JSE。各个文件分别对应的功能如下：",
      "JVM：Java虚拟机，Java编译过后的.class文件需要在JVM上运行，是Java可以跨平台的原因。",
      "JRE:Java运行环境，包含了JVM和Java程序所需的核心类库。如果只是需要运行一个开发好的Java程序，我们只需在计算机中安装JRE即可。",
      "JDK:Java开发工具包，包含了Java的开发工具、编译工具、打包工具。如果需要进行Java编程，就需要下载JDK。",
      "三者的关系：JDK包含了JRE，JRE包含了JVM",
      "下载安装好对应的环境以后，与C语言不同的是，你需要自行下载编译器，Java环境里是不具有编译器，既编辑代码的功能的。推荐安装Eclipse作为编译器。通过Eclipse即可开始Java编程了！"
    ],
    "sentences": [
      "课程最开始配置Java环境，但是完全没有学习过Java",
      "之前学习C语言",
      "编译器和环境只需要直接安装一个软件即可",
      "而对于Java的环境配置很复杂",
      "最后从Mooc上的新手课程中才搞清楚各种环境的关系",
      "对于Java的在官网上",
      "环境相关的有JVM",
      "JDK",
      "JRE",
      "JSE",
      "各个文件分别对应的功能如下：JVM：Java虚拟机",
      "Java编译过后的.class文件需要在JVM上运行",
      "是Java可以跨平台的原因",
      "JRE:Java运行环境",
      "包含了JVM和Java程序所需的核心类库",
      "如果只是需要运行一个开发好的Java程序",
      "我们只需在计算机中安装JRE即可",
      "JDK:Java开发工具包",
      "包含了Java的开发工具、编译工具、打包工具",
      "如果需要进行Java编程，就需要下载JDK",
      "三者的关系：JDK包含了JRE，JRE包含了JVM",
      "下载安装好对应的环境以后",
      "与C语言不同的是",
      "你需要自行下载编译器",
      "Java环境里是不具有编译器",
      "既编辑代码的功能的",
      "推荐安装Eclipse作为编译器",
      "通过Eclipse即可开始Java编程了！"
    ],
    "codes": [],
    "date": "2021-07-05",
    "text": "课程最开始配置Java环境，但是完全没有学习过Java。之前学习C语言，编译器和环境只需要直接安装一个软件即可，而对于Java的环境配置很复杂，最后从Mooc上的新手课程中才搞清楚各种环境的关系。\n对于Java的在官网上，环境相关的有JVM，JDK，JRE，JSE。各个文件分别对应的功能如下：\nJVM：Java虚拟机，Java编译过后的.class文件需要在JVM上运行，是Java可以跨平台的原因。\nJRE:Java运行环境，包含了JVM和Java程序所需的核心类库。如果只是需要运行一个开发好的Java程序，我们只需在计算机中安装JRE即可。\nJDK:Java开发工具包，包含了Java的开发工具、编译工具、打包工具。如果需要进行Java编程，就需要下载JDK。\n三者的关系：JDK包含了JRE，JRE包含了JVM\n下载安装好对应的环境以后，与C语言不同的是，你需要自行下载编译器，Java环境里是不具有编译器，既编辑代码的功能的。推荐安装Eclipse作为编译器。通过Eclipse即可开始Java编程了！\n"
  },
  {
    "head": "EclipseIDE的统计代码覆盖度工具EclEmma",
    "paragraphs": [
      "首先，EclEmma是一个开源的软件测试工具，可以统计代码覆盖率覆盖率。",
      "代码覆盖率用来刻画在软件测试里，被测试的程序的代码被测试的比例和程度。",
      "在JUnit测试时，被测试代码被调用的比例是由代码在JUnit里使用的情况决定的。",
      "EclEmma的安装：在Eclipse的Help中选取Eclipse Marketplace",
      "然后搜索EclEmma，点击Install即可直接安装EclEmma工具。",
      "安装完毕后，右键选取你需要统计代码覆盖度的代码文件，选取Coverage As，再选取Junit Test就可以测试出在Junit测试中的统计代码覆盖度。",
      "调用后可以看见如图的标识：",
      "绿色表示代码在JUnit测试中被执行到，黄色表示代码在JUnit测试中被部分执行到，红色表示代码没有在JUnit测试被执行到。",
      "下方也有对于代码覆盖度的总体统计，最具体可以查看某个函数的代码覆盖度的数据。"
    ],
    "sentences": [
      "首先",
      "EclEmma是一个开源的软件测试工具",
      "可以统计代码覆盖率覆盖率",
      "代码覆盖率用来刻画在软件测试里",
      "被测试的程序的代码被测试的比例和程度",
      "在JUnit测试时",
      "被测试代码被调用的比例是由代码在JUnit里使用的情况决定的",
      "EclEmma的安装：在Eclipse的Help中选取Eclipse Marketplace",
      "然后搜索EclEmma",
      "点击Install即可直接安装EclEmma工具",
      "安装完毕后",
      "右键选取你需要统计代码覆盖度的代码文件",
      "选取Coverage As",
      "再选取Junit Test就可以测试出在Junit测试中的统计代码覆盖度",
      "调用后可以看见如图的标识：绿色表示代码在JUnit测试中被执行到",
      "黄色表示代码在JUnit测试中被部分执行到",
      "红色表示代码没有在JUnit测试被执行到",
      "下方也有对于代码覆盖度的总体统计",
      "最具体可以查看某个函数的代码覆盖度的数据"
    ],
    "codes": [],
    "date": "2021-07-05",
    "text": "首先，EclEmma是一个开源的软件测试工具，可以统计代码覆盖率覆盖率。\n代码覆盖率用来刻画在软件测试里，被测试的程序的代码被测试的比例和程度。\n在JUnit测试时，被测试代码被调用的比例是由代码在JUnit里使用的情况决定的。\nEclEmma的安装：在Eclipse的Help中选取Eclipse Marketplace\n然后搜索EclEmma，点击Install即可直接安装EclEmma工具。\n安装完毕后，右键选取你需要统计代码覆盖度的代码文件，选取Coverage As，再选取Junit Test就可以测试出在Junit测试中的统计代码覆盖度。\n调用后可以看见如图的标识：\n绿色表示代码在JUnit测试中被执行到，黄色表示代码在JUnit测试中被部分执行到，红色表示代码没有在JUnit测试被执行到。\n下方也有对于代码覆盖度的总体统计，最具体可以查看某个函数的代码覆盖度的数据。\n"
  },
  {
    "head": "软件构造——面向可维护的设计模式",
    "paragraphs": [
      "1.创建模式",
      "这些类的作用主要就是为了创建对象，对应采取的模式就是不同的创建模式，分为以下几种模式。",
      "A.工厂方法模式",
      "使用ADT的时候，如果我们想创建一个对象，我们就要调用构造函数，而构造函数不会在接口中而是在实现类中，因此抽象程度降低了，而且导致用户可能会依赖于这个实现类的实现方式，而不是接口。为了解决这些，工厂模式应运而生。",
      "我们也可以说其实就是对构造函数的包装(就像之前对其他字段或方法的包装一样)，包装到一个新的类中，从而实现隐藏了这个原始类的类名，新的类一般只有一个方法，那就是用来构造原有类的对象。",
      "另外还有一种实现的结果相同的方法，就是在原始的类中添加静态工厂方法，同时将构造方法设置为私有。",
      "B.抽象工厂模式",
      "相比于普通的工厂方法模式中，一个工厂就用于创造一个类的对象，其实抽象方法模式就是变成了一个工厂可以创建一组类的对象，不过创建的搭配是固定好的。",
      "我们可以举下列在麦当劳点餐的例子来大致说明：",
      "对于普通的，没有使用创造模式的情况，我们就是这样点：一个奥尔良鸡腿堡，一个中可乐。我们提出需求时就直接是知道了具体的类，比如是奥尔良鸡腿堡，而不是通过它的父类“汉堡”。",
      "而工厂方法模式，我们是这样点：有一个个优惠卷，每个卷有对应的产品。我们给服务员这些卷，让他们拿出对应的产品，而我们不再需要知道这些产品的名字。通过优惠卷信息的不同，通过不同的工厂去创造对应的对象。",
      "而抽象工厂模式，我们是这样点：有一个个优惠卷，里面都是一个套餐。我们同样不用知道这些套餐中任何一个产品的名字，但是这些产品是绑定在这一个套餐之内的了，我们不再能一个个产品的去点，但是这样我们创建的时候对固定的模式更方便。",
      "2.结构模式",
      "通过改变类之间的结构，让类呈现新的功能。",
      "A.代理模式",
      "有的时候我们在创建一个类的对象时，就要进行一定的操作，而有的时候这个操作很费时间，而操作不一定必须，则此时我们就可以创建一个对应的包装，来实现将所谓的这个操作和对象的创建分隔开。",
      "下面是一个很好的例子。",
      "首先这张图说明在创建这个图片的时候，就调用了loadfromDisk这个需要花费很多时间的操作。",
      "如果我们想要实现仅仅是创建一个对象而不是立刻执行加载操作，则可以执行如下操作：创建一个虚拟的了类，构造方法中不再有display而是挪到了外面，通过委托的机制进行调用。",
      "代理模式与适配器模式的区别：前者的目的是解决私密问题和耗费过大的问题，而后者的目的主要是消除不匹配，让客户端和内部的类以统一的方式建立联系。",
      "3.行为模式",
      "行为性模式主要用于描述类或对象的交互以及职责分配。",
      "A.观察者模式",
      "总的来说就是一种一对多，类似于广播的模式。",
      "在被观察者中，应该有添加观察者和删除观察者的操作(用于将观察者与被观察者之间建立联系)，还有就是将信息通知给观察者的操作(notify)。对于观察者，也该有更新状态的操作(当然是由被观察者的notify来操作)",
      "例子如下所示，观察者即为被观察者中的一个列表。通过调用观察者的update操作来实现notify操作。(当然这里不能删除被观察者)",
      "粉丝(被观察者)的例子如下，subject属性代表着对应的被观察者所观察的观察者。",
      "当然，java中提供了Observer接口和Observable抽象类，类似于迭代器模式。",
      "B.访问者模式",
      "总的来说，访问者模式就是，被访问者中的某个具体的操作，因为各种原因，去委托给另外的类进行完成。委托给的类就是访问者。",
      "我们还是用例子来说明，不然太抽象。",
      "首先这是第一棵继承树，是被访问的那个类。其中要有accept方法，参数是访问类的对象，通过accept方法来让其访问。",
      "而第二棵继承树就是访问类了。其中要有visit方法，通过多态实现取分访问不同类型的对象从而有多种实现，而实现中即可以正常的写业务逻辑了。这个例子相当于把每种物品的计算价格的操作委托给了另一个类，这也就是访问者模式最主要的目的。",
      "与迭代器模式的区别：迭代器模式主要是进行一个个的访问，而访问者模式主要是被访问者将对应的某种功能的实现交给访问者，客户端可以灵活的改变访问者中的操作算法。",
      "4.设计模式总结",
      "虽然设计模式种类很多，但是抽象出的类与类之间的关联效果，都是如下两张图所示。",
      "首先是单一继承树的情况。",
      "其次是两颗继承树的情况。",
      "至于如何去取分这些样式相同的模式，主要是通过它里面方法的不同，就类似于大家都是人，但是由于自身能做的事情不同，因此有不同的职业一样。"
    ],
    "sentences": [
      "1.创建模式",
      "这些类的作用主要就是为了创建对象",
      "对应采取的模式就是不同的创建模式",
      "分为以下几种模式",
      "A.工厂方法模式",
      "使用ADT的时候",
      "如果我们想创建一个对象",
      "我们就要调用构造函数",
      "而构造函数不会在接口中而是在实现类中",
      "因此抽象程度降低了",
      "而且导致用户可能会依赖于这个实现类的实现方式",
      "而不是接口",
      "为了解决这些，工厂模式应运而生",
      "我们也可以说其实就是对构造函数的包装(就像之前对其他字段或方法的包装一样)",
      "包装到一个新的类中",
      "从而实现隐藏了这个原始类的类名",
      "新的类一般只有一个方法",
      "那就是用来构造原有类的对象",
      "另外还有一种实现的结果相同的方法",
      "就是在原始的类中添加静态工厂方法",
      "同时将构造方法设置为私有",
      "B.抽象工厂模式",
      "相比于普通的工厂方法模式中",
      "一个工厂就用于创造一个类的对象",
      "其实抽象方法模式就是变成了一个工厂可以创建一组类的对象",
      "不过创建的搭配是固定好的",
      "我们可以举下列在麦当劳点餐的例子来大致说明：对于普通的",
      "没有使用创造模式的情况",
      "我们就是这样点：一个奥尔良鸡腿堡",
      "一个中可乐",
      "我们提出需求时就直接是知道了具体的类",
      "比如是奥尔良鸡腿堡",
      "而不是通过它的父类“汉堡”",
      "而工厂方法模式",
      "我们是这样点：有一个个优惠卷",
      "每个卷有对应的产品",
      "我们给服务员这些卷",
      "让他们拿出对应的产品",
      "而我们不再需要知道这些产品的名字",
      "通过优惠卷信息的不同，通过不同的工厂去创造对应的对象",
      "而抽象工厂模式",
      "我们是这样点：有一个个优惠卷",
      "里面都是一个套餐",
      "我们同样不用知道这些套餐中任何一个产品的名字",
      "但是这些产品是绑定在这一个套餐之内的了",
      "我们不再能一个个产品的去点",
      "但是这样我们创建的时候对固定的模式更方便",
      "2.结构模式",
      "通过改变类之间的结构，让类呈现新的功能",
      "A.代理模式",
      "有的时候我们在创建一个类的对象时",
      "就要进行一定的操作",
      "而有的时候这个操作很费时间",
      "而操作不一定必须",
      "则此时我们就可以创建一个对应的包装",
      "来实现将所谓的这个操作和对象的创建分隔开",
      "下面是一个很好的例子",
      "首先这张图说明在创建这个图片的时候",
      "就调用了loadfromDisk这个需要花费很多时间的操作",
      "如果我们想要实现仅仅是创建一个对象而不是立刻执行加载操作",
      "则可以执行如下操作：创建一个虚拟的了类",
      "构造方法中不再有display而是挪到了外面",
      "通过委托的机制进行调用",
      "代理模式与适配器模式的区别：前者的目的是解决私密问题和耗费过大的问题",
      "而后者的目的主要是消除不匹配",
      "让客户端和内部的类以统一的方式建立联系",
      "3.行为模式",
      "行为性模式主要用于描述类或对象的交互以及职责分配",
      "A.观察者模式",
      "总的来说就是一种一对多，类似于广播的模式",
      "在被观察者中",
      "应该有添加观察者和删除观察者的操作(用于将观察者与被观察者之间建立联系)",
      "还有就是将信息通知给观察者的操作(notify)",
      "对于观察者",
      "也该有更新状态的操作(当然是由被观察者的notify来操作)",
      "例子如下所示，观察者即为被观察者中的一个列表",
      "通过调用观察者的update操作来实现notify操作",
      "(当然这里不能删除被观察者)",
      "粉丝(被观察者)的例子如下",
      "subject属性代表着对应的被观察者所观察的观察者",
      "当然",
      "java中提供了Observer接口和Observable抽象类",
      "类似于迭代器模式",
      "B.访问者模式",
      "总的来说",
      "访问者模式就是",
      "被访问者中的某个具体的操作",
      "因为各种原因",
      "去委托给另外的类进行完成",
      "委托给的类就是访问者",
      "我们还是用例子来说明，不然太抽象",
      "首先这是第一棵继承树，是被访问的那个类",
      "其中要有accept方法",
      "参数是访问类的对象",
      "通过accept方法来让其访问",
      "而第二棵继承树就是访问类了",
      "其中要有visit方法",
      "通过多态实现取分访问不同类型的对象从而有多种实现",
      "而实现中即可以正常的写业务逻辑了",
      "这个例子相当于把每种物品的计算价格的操作委托给了另一个类",
      "这也就是访问者模式最主要的目的",
      "与迭代器模式的区别：迭代器模式主要是进行一个个的访问",
      "而访问者模式主要是被访问者将对应的某种功能的实现交给访问者",
      "客户端可以灵活的改变访问者中的操作算法",
      "4.设计模式总结",
      "虽然设计模式种类很多",
      "但是抽象出的类与类之间的关联效果",
      "都是如下两张图所示",
      "首先是单一继承树的情况",
      "其次是两颗继承树的情况",
      "至于如何去取分这些样式相同的模式",
      "主要是通过它里面方法的不同",
      "就类似于大家都是人",
      "但是由于自身能做的事情不同",
      "因此有不同的职业一样"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "1.创建模式\n这些类的作用主要就是为了创建对象，对应采取的模式就是不同的创建模式，分为以下几种模式。\nA.工厂方法模式\n使用ADT的时候，如果我们想创建一个对象，我们就要调用构造函数，而构造函数不会在接口中而是在实现类中，因此抽象程度降低了，而且导致用户可能会依赖于这个实现类的实现方式，而不是接口。为了解决这些，工厂模式应运而生。\n我们也可以说其实就是对构造函数的包装(就像之前对其他字段或方法的包装一样)，包装到一个新的类中，从而实现隐藏了这个原始类的类名，新的类一般只有一个方法，那就是用来构造原有类的对象。\n另外还有一种实现的结果相同的方法，就是在原始的类中添加静态工厂方法，同时将构造方法设置为私有。\nB.抽象工厂模式\n相比于普通的工厂方法模式中，一个工厂就用于创造一个类的对象，其实抽象方法模式就是变成了一个工厂可以创建一组类的对象，不过创建的搭配是固定好的。\n我们可以举下列在麦当劳点餐的例子来大致说明：\n对于普通的，没有使用创造模式的情况，我们就是这样点：一个奥尔良鸡腿堡，一个中可乐。我们提出需求时就直接是知道了具体的类，比如是奥尔良鸡腿堡，而不是通过它的父类“汉堡”。\n而工厂方法模式，我们是这样点：有一个个优惠卷，每个卷有对应的产品。我们给服务员这些卷，让他们拿出对应的产品，而我们不再需要知道这些产品的名字。通过优惠卷信息的不同，通过不同的工厂去创造对应的对象。\n而抽象工厂模式，我们是这样点：有一个个优惠卷，里面都是一个套餐。我们同样不用知道这些套餐中任何一个产品的名字，但是这些产品是绑定在这一个套餐之内的了，我们不再能一个个产品的去点，但是这样我们创建的时候对固定的模式更方便。\n2.结构模式\n通过改变类之间的结构，让类呈现新的功能。\nA.代理模式\n有的时候我们在创建一个类的对象时，就要进行一定的操作，而有的时候这个操作很费时间，而操作不一定必须，则此时我们就可以创建一个对应的包装，来实现将所谓的这个操作和对象的创建分隔开。\n下面是一个很好的例子。\n首先这张图说明在创建这个图片的时候，就调用了loadfromDisk这个需要花费很多时间的操作。\n如果我们想要实现仅仅是创建一个对象而不是立刻执行加载操作，则可以执行如下操作：创建一个虚拟的了类，构造方法中不再有display而是挪到了外面，通过委托的机制进行调用。\n代理模式与适配器模式的区别：前者的目的是解决私密问题和耗费过大的问题，而后者的目的主要是消除不匹配，让客户端和内部的类以统一的方式建立联系。\n3.行为模式\n行为性模式主要用于描述类或对象的交互以及职责分配。\nA.观察者模式\n总的来说就是一种一对多，类似于广播的模式。\n在被观察者中，应该有添加观察者和删除观察者的操作(用于将观察者与被观察者之间建立联系)，还有就是将信息通知给观察者的操作(notify)。对于观察者，也该有更新状态的操作(当然是由被观察者的notify来操作)\n例子如下所示，观察者即为被观察者中的一个列表。通过调用观察者的update操作来实现notify操作。(当然这里不能删除被观察者)\n粉丝(被观察者)的例子如下，subject属性代表着对应的被观察者所观察的观察者。\n当然，java中提供了Observer接口和Observable抽象类，类似于迭代器模式。\nB.访问者模式\n总的来说，访问者模式就是，被访问者中的某个具体的操作，因为各种原因，去委托给另外的类进行完成。委托给的类就是访问者。\n我们还是用例子来说明，不然太抽象。\n首先这是第一棵继承树，是被访问的那个类。其中要有accept方法，参数是访问类的对象，通过accept方法来让其访问。\n而第二棵继承树就是访问类了。其中要有visit方法，通过多态实现取分访问不同类型的对象从而有多种实现，而实现中即可以正常的写业务逻辑了。这个例子相当于把每种物品的计算价格的操作委托给了另一个类，这也就是访问者模式最主要的目的。\n与迭代器模式的区别：迭代器模式主要是进行一个个的访问，而访问者模式主要是被访问者将对应的某种功能的实现交给访问者，客户端可以灵活的改变访问者中的操作算法。\n4.设计模式总结\n虽然设计模式种类很多，但是抽象出的类与类之间的关联效果，都是如下两张图所示。\n首先是单一继承树的情况。\n其次是两颗继承树的情况。\n至于如何去取分这些样式相同的模式，主要是通过它里面方法的不同，就类似于大家都是人，但是由于自身能做的事情不同，因此有不同的职业一样。\n"
  },
  {
    "head": "JAVA正则表达式",
    "paragraphs": [
      "一、单个符号",
      "1、英文句点.符号：匹配单个任意字符。",
      "表达式t.o 可以匹配：tno，t#o，teo等等。不可以匹配：tnno，to，Tno，t正o等。",
      "2、中括号[]：只有方括号里面指定的字符才参与匹配，也只能匹配单个字符。",
      "表达式：t[abcd]n 只可以匹配：tan，tbn，tcn，tdn。不可以匹配：thn，tabn，tn等。",
      "3、| 符号。相当与“或”，可以匹配指定的字符，但是也只能选择其中一项进行匹配。",
      "表达式：t(a|b|c|dd)n 只可以匹配：tan，tbn，tcn，tddn。不可以匹配taan，tn，tabcn等。",
      "4、表示匹配次数的符号",
      "5、^符号：表示否，如果用在方括号内，^表示不想匹配的字符。",
      "表达式：[^x] 第一个字符不能是x",
      "6、\\S符号：非空字符",
      "7、\\s符号：空字符，只可以匹配一个空格、制表符、回车符、换页符，不可以匹配自己输入的多个空格。",
      "8、\\r符号：空格符，与\\n、\\tab相同",
      "二、快捷符号",
      "1、\\d表示[0—9]",
      "2、\\D表示[^0—9]",
      "3、\\w表示[0—9A—Z_a—z]",
      "4、\\W表示[^0—9A—Z_a—z]",
      "5、\\s表示[\\t\\n\\r\\f]",
      "6、\\S表示[^\\t\\n\\r\\f]",
      "三、Pattern和Matcher",
      "实例：",
      ".matcher(\"Evening is full of the linnet's wings\");",
      "i++;",
      "monitor.expect(new String[] {",
      "\"Evening\",",
      "\"is\",",
      "\"full\",",
      "\"of\",",
      "\"the\",",
      "\"linnet\",",
      "\"s\",",
      "\"Evening vening ening ning ing ng g is is s full \" +",
      "\"full ull ll l of of f the the he e linnet linnet \" +",
      "\"innet nnet net et t s s wings wings ings ngs gs s \"",
      "});",
      "用括号可以给pattern进行分组，用group（int i）引用。"
    ],
    "sentences": [
      "一、单个符号",
      "1、英文句点.符号：匹配单个任意字符",
      "表达式t.o 可以匹配：tno，t#o，teo等等",
      "不可以匹配：tnno，to，Tno，t正o等",
      "2、中括号[]：只有方括号里面指定的字符才参与匹配",
      "也只能匹配单个字符",
      "表达式：t[abcd]n 只可以匹配：tan",
      "tbn",
      "tcn",
      "tdn",
      "不可以匹配：thn，tabn，tn等",
      "3、| 符号",
      "相当与“或”",
      "可以匹配指定的字符",
      "但是也只能选择其中一项进行匹配",
      "表达式：t(a|b|c|dd)n 只可以匹配：tan",
      "tbn",
      "tcn",
      "tddn",
      "不可以匹配taan，tn，tabcn等",
      "4、表示匹配次数的符号",
      "5、^符号：表示否，如果用在方括号内，^表示不想匹配的字符",
      "表达式：[^x] 第一个字符不能是x",
      "6、\\S符号：非空字符",
      "7、\\s符号：空字符",
      "只可以匹配一个空格、制表符、回车符、换页符",
      "不可以匹配自己输入的多个空格",
      "8、\\r符号：空格符，与\\n、\\tab相同",
      "二、快捷符号",
      "1、\\d表示[0—9]",
      "2、\\D表示[^0—9]",
      "3、\\w表示[0—9A—Z_a—z]",
      "4、\\W表示[^0—9A—Z_a—z]",
      "5、\\s表示[\\t\\n\\r\\f]",
      "6、\\S表示[^\\t\\n\\r\\f]",
      "三、Pattern和Matcher",
      "实例：.matcher(\"Evening is full of the linnet's wings\");i++;monitor.expect(new String[] {",
      "\"Evening\",\"is\",\"full\",\"of\",\"the\",\"linnet\",\"s\",\"Evening vening ening ning ing ng g is is s full \" +",
      "\"full ull ll l of of f the the he e linnet linnet \" +",
      "\"innet nnet net et t s s wings wings ings ngs gs s \"",
      "});用括号可以给pattern进行分组",
      "用group（int i）引用"
    ],
    "codes": [
      "publicclass FindDemo {",
      "privatestatic Test monitor = new Test();",
      "publicstaticvoid main(String[] args) {",
      "Matcher m = Pattern.compile(\"//w+\")",
      "while(m.find())",
      "System.out.println(m.group());",
      "int i = 0;",
      "while(m.find(i)) {",
      "System.out.print(m.group() + \" \");",
      "\"wings\","
    ],
    "date": "2021-06-30",
    "text": "一、单个符号\n1、英文句点.符号：匹配单个任意字符。\n表达式t.o 可以匹配：tno，t#o，teo等等。不可以匹配：tnno，to，Tno，t正o等。\n2、中括号[]：只有方括号里面指定的字符才参与匹配，也只能匹配单个字符。\n表达式：t[abcd]n 只可以匹配：tan，tbn，tcn，tdn。不可以匹配：thn，tabn，tn等。\n3、| 符号。相当与“或”，可以匹配指定的字符，但是也只能选择其中一项进行匹配。\n表达式：t(a|b|c|dd)n 只可以匹配：tan，tbn，tcn，tddn。不可以匹配taan，tn，tabcn等。\n4、表示匹配次数的符号\n5、^符号：表示否，如果用在方括号内，^表示不想匹配的字符。\n表达式：[^x] 第一个字符不能是x\n6、\\S符号：非空字符\n7、\\s符号：空字符，只可以匹配一个空格、制表符、回车符、换页符，不可以匹配自己输入的多个空格。\n8、\\r符号：空格符，与\\n、\\tab相同\n二、快捷符号\n1、\\d表示[0—9]\n2、\\D表示[^0—9]\n3、\\w表示[0—9A—Z_a—z]\n4、\\W表示[^0—9A—Z_a—z]\n5、\\s表示[\\t\\n\\r\\f]\n6、\\S表示[^\\t\\n\\r\\f]\n三、Pattern和Matcher\n实例：\n.matcher(\"Evening is full of the linnet's wings\");\ni++;\nmonitor.expect(new String[] {\n\"Evening\",\n\"is\",\n\"full\",\n\"of\",\n\"the\",\n\"linnet\",\n\"s\",\n\"Evening vening ening ning ing ng g is is s full \" +\n\"full ull ll l of of f the the he e linnet linnet \" +\n\"innet nnet net et t s s wings wings ings ngs gs s \"\n});\n用括号可以给pattern进行分组，用group（int i）引用。\n"
  },
  {
    "head": "JAVA可复用性",
    "paragraphs": [
      "一.可复用性的度量、形态与外部表现",
      "1.可复用性简介",
      "虽然说复用有不同层级，但是总的来说可复用性就是我们重复使用我们已经编写好的模块。因此过程分为两部分:在某些模块编写出可复用度高的代码，然后在某些模块尽量调用这些代码。",
      "越抽象的东西，可复用性一般越强。因此总的来说，java中接口的可复用性大于抽象类，抽象类大于一般类。",
      "可复用性高显然会带来很多优点：首先编写软件的过程会很愉快(如果能很简单复用的话)，可以让代码更标准，实现的更可靠等等。",
      "但是有时为了提高可复用性，我们也会付出很高的代价，主要是很多时候想实现好的可复用性是很难的，会有很高的开发代价，维护代价以及复用时要进行适配带来的代价。比如Lab2中，Graph这个ADT想实现很好的可复用性就很简单，但对于棋类游戏，想让这个ADT对很多种特定的棋类都有很好的可复用性，就是非常让人头疼的事情。",
      "2.可复用性的衡量",
      "总的来说分为两点，一是复用的次数是否很频繁以及是否可以广泛的应用在很多情况之中(这两个有很强的正相关性，比如List可以广泛的被应用，所以理所当然的用的次数很频繁)；二是复用的代价如何。可见我们并不能定量的去判断某个软件可复用性效果如何，我们只能定性的做一些观察。",
      "3.复用的层面",
      "两种复用的方式：白盒复用和黑盒复用。黑盒复用就类似于调用API接口，或者方法等等；白盒复用是直接得到想要复用的源代码(或其他内容)等等，然后自己根据需要进行修改。",
      "根据复用内容的结构从小到大，分为如下四种复用。",
      "(1).源代码级别的复用:这个是最底层的复用，就是简单的复制粘贴修改。",
      "(2).模块级复用:以class作为最基本的单元，复用的方式有继承和委托，其中委托的耦合度明显低于继承。",
      "(3).类库级重用:相当于把一系列的class进行了打包，类似于第三方库的调用。",
      "(4).框架级复用:在框架的基础上，填充自己的代码，形成完整系统。(其实就类似于一些实验中，给出了很多代码，要求我们填入一些自己的代码)",
      "二.面向复用的软件构造技术",
      "1.LSP与泛型中的运用",
      "在我们3.4的继承，多态，泛型等等的基础上，这里我们主要介绍LSP，即Liskov替换原则。",
      "Liskov替换原则用数学性的语言来说，则如下图所示。",
      "从实际设计的角度来说，这个原则其实就是对子类型的约束：要求子类型对象完全可以当作父类型的对象来使用，其中就包括了规约的前置条件不能强化，后置条件不能弱化，要保持不变量等等。",
      "下面介绍协变与异变的概念。",
      "协变：子类对父类方法的覆写中，异常、返回值的类型是父类方法中返回值的类型的子类型，就称之为协变。",
      "逆变：顾名思义，与协变恰恰相反。",
      "因此为了复合Liskov替换原则，我们要求如果有变化的话，那异常，返回值必须是协变，参数必须是异变(当然，在java语言中参数的异变或协变导致方法不再是覆写，而是重载)。",
      "java中的泛型是类型不变的，如下图所示，是十分经典的例子。如果想进行协变或逆变，则需要使用通配符，例如List<? extends Number>是List < Number>的子类型，但是不论如何都要确保一个List中的元素都是一种类型的(尽管多种元素都可以放入)。",
      "Class为类型类，详细的用法可以参考“java中的反射”，可以得到很多信息，来验证我们上面的说法。这里就不详细说明了。",
      "2.委托与组合",
      "委托顾名思义，类似于现实中我们委托别人去做一些事情，抽象到代码中，那就是在某个类的方法中，传入其他类的变量，把实现逻辑写在这个其他类的方法中，并在这个类的方法中调用。",
      "例如我们想通过List的复用性实现stack，如果是继承关系的话，则stack中不可避免的有很多与我们期待的数据结构不匹配的方法。因此我们应该采取委托的方式，将pop等函数里某些操作委托给list即可。",
      "由于继承过于严格，因此如果不是有很强的继承关系，使用委托会更合适。",
      "总的来说，委托有四种形式。",
      "(1).依赖(Dependency):逻辑即为A use B,在A的方法中通过把B当作参数来或在方法的局部中，调用B的方法，是一种临时性的委托，只有调用这个方法的时候，它们才有临时关系。",
      "(2).关联(Association):逻辑即为A has B,对象A中的字段中有对象B，之后的操作和前面类似；只是A与B之间就有一个相对长的关系了。",
      "(3).组合(Composition):逻辑即为B is part of B,A中有字段B，且在A被构造时，B就被初始化好了(A中的定义导致的，比如A中有private T B = new T(…)语句)；因此它们声明周期一致。",
      "(4).聚合(Aggregation):逻辑即为A owns B，与(3)很相似，只是B构造的方式是通过A的构造函数的参数。因此对于B的构造，比第三种要灵活。",
      "3.框架设计",
      "有两种形式：一是白盒框架，二是黑盒框架。",
      "白盒框架：主要采用继承的方式，通过构建子类的方式进行扩展，子类中有main函数。代码是可见的，但是带来的问题就是要对父类的代码有了解，更贴近于开发者使用。",
      "黑盒框架：主要采用用插件实现接口和委托的方式进行扩展，子类中没有main函数。更贴近于用户使用。",
      "但无论是那种框架，控制权都是在框架手上的，这其实是框架和很多类构成的一个体系的区别。",
      "至于如何设计好一个框架，总的来说与多个类之间的设计思想一致，只是需要更多的去了解这个框架的用途，然后更有针对性地去开发。",
      "三.面向复用的设计模式",
      "总的来说，针对开发的阶段不同，设计模式分为以下三种：创建型模式、结构型模式、行为类模式。本章主要是讲解其中与可复用性密切相关的一些模式。",
      "1.结构型模式",
      "(1).适配器模式",
      "主要是用于解决类之间的接口不兼容的问题。一般用于新版本的时候重新定义了接口或者新创建了一些类，要和旧版本写适配的时候。方式还是一样有两种，分为继承和委托，不过一般委托更方便些。",
      "(2).装饰者模式",
      "总的来说，就是把一个个特殊功能看成是装饰品，然后调用时通过决定加入哪些装饰品从而得到我们想要的结果，而不是通过继承的方式来得到具体的类。",
      "具体实现方式就以ppt上冰淇淋这个例子来举例了，这也是最简单的一个装饰着模式的例子了。",
      "我们对于一个冰激凌，想在它上面添加一些食料。由于不同种的食料可以组合，采用继承会组合数爆炸。因此我们可以采用如下的策略：首先定义接口，其中有我们想要有不同实现的方法：AddTopping()方法；其次，我们正常的实现没有任何装饰的类，用于委托；之后，我们定义一个装饰器基类，把没装饰的类的一个对象作为自己的一个字段(其实就是委托)，然后并不实现要装饰的方法，准备留到子类；注意这个类和没有装饰的类是类似于“兄弟关系”，都是实现共同的接口。",
      "之后，我们再把对应的三种装饰方式实现为装饰器基类的子类，其中构造函数还是调用父类的构造函数，在待装饰的地方，就是先调用父类的操作，再加上自己独特的操作而成，这就是所谓的“装饰”。",
      "之后客户端的调用就顺理成章了。我们想要哪些装饰，就套入哪个装饰的构造方法即可，就类似于递归调用，因为我们在编写类的时候方法的实现就是递归的。",
      "不过这个模式在情况复杂的时候，写起来难度很大，逻辑上哪些应该先装饰，哪些应该后装饰还有冲突等如何处理也是个问题。",
      "(3).外观模式",
      "这个模式比较简单，其实就是客户端有的时候功能组合比较多，可能用起来比较复杂。因此我们就采用外观模式：用一个相对简化，统一的接口来实现对一系列接口的组合使用。",
      "2.行为类模式",
      "(1).策略模式",
      "其实这个模式也比较直观，就是实现的代码中，会根据用户输入的不同，采取不同策略的实现方式，就比如C++中的排序sort()函数，系统其实会根据输入的不同采取不同的算法。",
      "当然，内部的实现可以是最简单的先评判输入，然后再生成对应的参数，调用其他接口(委托)；更好的更隐蔽的方式是使用工厂模式，这个在后面的章节中会介绍。",
      "(2).模板模式",
      "模板模式很适合白盒框架，其实就是在父类中定义一系列抽象方法(即为一个个流程)，以及一个方法来定义这些流程的实现步骤，然后再用子类去实现这一个个流程的具体步骤。可见，这个模式和策略模式有相似的地方，就是具体也是采用不同的方法，只是保证步骤一样。",
      "(3).迭代器模式",
      "不关心容器具体类型，用一种统一的方式进行遍历。",
      "一般来说，实现的方式如下图所示。首先，这个类要实现Iterable接口，从而要实现蓝框中的方法得到迭代器。然后，我们就可以自己去实现对应的迭代器，其中这个迭代器要实现Iterator接口。通过这种方式，客户端在遍历的时候，完全无需看到迭代器是如何工作的。"
    ],
    "sentences": [
      "一.可复用性的度量、形态与外部表现",
      "1.可复用性简介",
      "虽然说复用有不同层级",
      "但是总的来说可复用性就是我们重复使用我们已经编写好的模块",
      "因此过程分为两部分:在某些模块编写出可复用度高的代码",
      "然后在某些模块尽量调用这些代码",
      "越抽象的东西，可复用性一般越强",
      "因此总的来说",
      "java中接口的可复用性大于抽象类",
      "抽象类大于一般类",
      "可复用性高显然会带来很多优点：首先编写软件的过程会很愉快(如果能很简单复用的话)",
      "可以让代码更标准",
      "实现的更可靠等等",
      "但是有时为了提高可复用性",
      "我们也会付出很高的代价",
      "主要是很多时候想实现好的可复用性是很难的",
      "会有很高的开发代价",
      "维护代价以及复用时要进行适配带来的代价",
      "比如Lab2中",
      "Graph这个ADT想实现很好的可复用性就很简单",
      "但对于棋类游戏",
      "想让这个ADT对很多种特定的棋类都有很好的可复用性",
      "就是非常让人头疼的事情",
      "2.可复用性的衡量",
      "总的来说分为两点",
      "一是复用的次数是否很频繁以及是否可以广泛的应用在很多情况之中(这两个有很强的正相关性",
      "比如List可以广泛的被应用",
      "所以理所当然的用的次数很频繁)；二是复用的代价如何",
      "可见我们并不能定量的去判断某个软件可复用性效果如何",
      "我们只能定性的做一些观察",
      "3.复用的层面",
      "两种复用的方式：白盒复用和黑盒复用",
      "黑盒复用就类似于调用API接口",
      "或者方法等等；白盒复用是直接得到想要复用的源代码(或其他内容)等等",
      "然后自己根据需要进行修改",
      "根据复用内容的结构从小到大，分为如下四种复用",
      "(1).源代码级别的复用:这个是最底层的复用",
      "就是简单的复制粘贴修改",
      "(2).模块级复用:以class作为最基本的单元",
      "复用的方式有继承和委托",
      "其中委托的耦合度明显低于继承",
      "(3).类库级重用:相当于把一系列的class进行了打包",
      "类似于第三方库的调用",
      "(4).框架级复用:在框架的基础上",
      "填充自己的代码",
      "形成完整系统",
      "(其实就类似于一些实验中",
      "给出了很多代码",
      "要求我们填入一些自己的代码)",
      "二.面向复用的软件构造技术",
      "1.LSP与泛型中的运用",
      "在我们3.4的继承",
      "多态",
      "泛型等等的基础上",
      "这里我们主要介绍LSP",
      "即Liskov替换原则",
      "Liskov替换原则用数学性的语言来说，则如下图所示",
      "从实际设计的角度来说",
      "这个原则其实就是对子类型的约束：要求子类型对象完全可以当作父类型的对象来使用",
      "其中就包括了规约的前置条件不能强化",
      "后置条件不能弱化",
      "要保持不变量等等",
      "下面介绍协变与异变的概念",
      "协变：子类对父类方法的覆写中",
      "异常、返回值的类型是父类方法中返回值的类型的子类型",
      "就称之为协变",
      "逆变：顾名思义，与协变恰恰相反",
      "因此为了复合Liskov替换原则",
      "我们要求如果有变化的话",
      "那异常",
      "返回值必须是协变",
      "参数必须是异变(当然",
      "在java语言中参数的异变或协变导致方法不再是覆写",
      "而是重载)",
      "java中的泛型是类型不变的，如下图所示，是十分经典的例子",
      "如果想进行协变或逆变",
      "则需要使用通配符",
      "例如List<? extends Number>是List < Number>的子类型",
      "但是不论如何都要确保一个List中的元素都是一种类型的(尽管多种元素都可以放入)",
      "Class为类型类",
      "详细的用法可以参考“java中的反射”",
      "可以得到很多信息",
      "来验证我们上面的说法",
      "这里就不详细说明了",
      "2.委托与组合",
      "委托顾名思义",
      "类似于现实中我们委托别人去做一些事情",
      "抽象到代码中",
      "那就是在某个类的方法中",
      "传入其他类的变量",
      "把实现逻辑写在这个其他类的方法中",
      "并在这个类的方法中调用",
      "例如我们想通过List的复用性实现stack",
      "如果是继承关系的话",
      "则stack中不可避免的有很多与我们期待的数据结构不匹配的方法",
      "因此我们应该采取委托的方式",
      "将pop等函数里某些操作委托给list即可",
      "由于继承过于严格",
      "因此如果不是有很强的继承关系",
      "使用委托会更合适",
      "总的来说，委托有四种形式",
      "(1).依赖(Dependency):逻辑即为A use B,在A的方法中通过把B当作参数来或在方法的局部中",
      "调用B的方法",
      "是一种临时性的委托",
      "只有调用这个方法的时候",
      "它们才有临时关系",
      "(2).关联(Association):逻辑即为A has B,对象A中的字段中有对象B",
      "之后的操作和前面类似；只是A与B之间就有一个相对长的关系了",
      "(3).组合(Composition):逻辑即为B is part of B,A中有字段B",
      "且在A被构造时",
      "B就被初始化好了(A中的定义导致的",
      "比如A中有private T B = new T(…)语句)；因此它们声明周期一致",
      "(4).聚合(Aggregation):逻辑即为A owns B",
      "与(3)很相似",
      "只是B构造的方式是通过A的构造函数的参数",
      "因此对于B的构造，比第三种要灵活",
      "3.框架设计",
      "有两种形式：一是白盒框架，二是黑盒框架",
      "白盒框架：主要采用继承的方式",
      "通过构建子类的方式进行扩展",
      "子类中有main函数",
      "代码是可见的",
      "但是带来的问题就是要对父类的代码有了解",
      "更贴近于开发者使用",
      "黑盒框架：主要采用用插件实现接口和委托的方式进行扩展",
      "子类中没有main函数",
      "更贴近于用户使用",
      "但无论是那种框架",
      "控制权都是在框架手上的",
      "这其实是框架和很多类构成的一个体系的区别",
      "至于如何设计好一个框架",
      "总的来说与多个类之间的设计思想一致",
      "只是需要更多的去了解这个框架的用途",
      "然后更有针对性地去开发",
      "三.面向复用的设计模式",
      "总的来说",
      "针对开发的阶段不同",
      "设计模式分为以下三种：创建型模式、结构型模式、行为类模式",
      "本章主要是讲解其中与可复用性密切相关的一些模式",
      "1.结构型模式",
      "(1).适配器模式",
      "主要是用于解决类之间的接口不兼容的问题",
      "一般用于新版本的时候重新定义了接口或者新创建了一些类",
      "要和旧版本写适配的时候",
      "方式还是一样有两种，分为继承和委托，不过一般委托更方便些",
      "(2).装饰者模式",
      "总的来说",
      "就是把一个个特殊功能看成是装饰品",
      "然后调用时通过决定加入哪些装饰品从而得到我们想要的结果",
      "而不是通过继承的方式来得到具体的类",
      "具体实现方式就以ppt上冰淇淋这个例子来举例了",
      "这也是最简单的一个装饰着模式的例子了",
      "我们对于一个冰激凌，想在它上面添加一些食料",
      "由于不同种的食料可以组合，采用继承会组合数爆炸",
      "因此我们可以采用如下的策略：首先定义接口",
      "其中有我们想要有不同实现的方法：AddTopping()方法；其次",
      "我们正常的实现没有任何装饰的类",
      "用于委托；之后",
      "我们定义一个装饰器基类",
      "把没装饰的类的一个对象作为自己的一个字段(其实就是委托)",
      "然后并不实现要装饰的方法",
      "准备留到子类；注意这个类和没有装饰的类是类似于“兄弟关系”",
      "都是实现共同的接口",
      "之后",
      "我们再把对应的三种装饰方式实现为装饰器基类的子类",
      "其中构造函数还是调用父类的构造函数",
      "在待装饰的地方",
      "就是先调用父类的操作",
      "再加上自己独特的操作而成",
      "这就是所谓的“装饰”",
      "之后客户端的调用就顺理成章了",
      "我们想要哪些装饰",
      "就套入哪个装饰的构造方法即可",
      "就类似于递归调用",
      "因为我们在编写类的时候方法的实现就是递归的",
      "不过这个模式在情况复杂的时候",
      "写起来难度很大",
      "逻辑上哪些应该先装饰",
      "哪些应该后装饰还有冲突等如何处理也是个问题",
      "(3).外观模式",
      "这个模式比较简单",
      "其实就是客户端有的时候功能组合比较多",
      "可能用起来比较复杂",
      "因此我们就采用外观模式：用一个相对简化",
      "统一的接口来实现对一系列接口的组合使用",
      "2.行为类模式",
      "(1).策略模式",
      "其实这个模式也比较直观",
      "就是实现的代码中",
      "会根据用户输入的不同",
      "采取不同策略的实现方式",
      "就比如C++中的排序sort()函数",
      "系统其实会根据输入的不同采取不同的算法",
      "当然",
      "内部的实现可以是最简单的先评判输入",
      "然后再生成对应的参数",
      "调用其他接口(委托)；更好的更隐蔽的方式是使用工厂模式",
      "这个在后面的章节中会介绍",
      "(2).模板模式",
      "模板模式很适合白盒框架",
      "其实就是在父类中定义一系列抽象方法(即为一个个流程)",
      "以及一个方法来定义这些流程的实现步骤",
      "然后再用子类去实现这一个个流程的具体步骤",
      "可见",
      "这个模式和策略模式有相似的地方",
      "就是具体也是采用不同的方法",
      "只是保证步骤一样",
      "(3).迭代器模式",
      "不关心容器具体类型，用一种统一的方式进行遍历",
      "一般来说，实现的方式如下图所示",
      "首先",
      "这个类要实现Iterable接口",
      "从而要实现蓝框中的方法得到迭代器",
      "然后",
      "我们就可以自己去实现对应的迭代器",
      "其中这个迭代器要实现Iterator接口",
      "通过这种方式",
      "客户端在遍历的时候",
      "完全无需看到迭代器是如何工作的"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "一.可复用性的度量、形态与外部表现\n1.可复用性简介\n虽然说复用有不同层级，但是总的来说可复用性就是我们重复使用我们已经编写好的模块。因此过程分为两部分:在某些模块编写出可复用度高的代码，然后在某些模块尽量调用这些代码。\n越抽象的东西，可复用性一般越强。因此总的来说，java中接口的可复用性大于抽象类，抽象类大于一般类。\n可复用性高显然会带来很多优点：首先编写软件的过程会很愉快(如果能很简单复用的话)，可以让代码更标准，实现的更可靠等等。\n但是有时为了提高可复用性，我们也会付出很高的代价，主要是很多时候想实现好的可复用性是很难的，会有很高的开发代价，维护代价以及复用时要进行适配带来的代价。比如Lab2中，Graph这个ADT想实现很好的可复用性就很简单，但对于棋类游戏，想让这个ADT对很多种特定的棋类都有很好的可复用性，就是非常让人头疼的事情。\n2.可复用性的衡量\n总的来说分为两点，一是复用的次数是否很频繁以及是否可以广泛的应用在很多情况之中(这两个有很强的正相关性，比如List可以广泛的被应用，所以理所当然的用的次数很频繁)；二是复用的代价如何。可见我们并不能定量的去判断某个软件可复用性效果如何，我们只能定性的做一些观察。\n3.复用的层面\n两种复用的方式：白盒复用和黑盒复用。黑盒复用就类似于调用API接口，或者方法等等；白盒复用是直接得到想要复用的源代码(或其他内容)等等，然后自己根据需要进行修改。\n根据复用内容的结构从小到大，分为如下四种复用。\n(1).源代码级别的复用:这个是最底层的复用，就是简单的复制粘贴修改。\n(2).模块级复用:以class作为最基本的单元，复用的方式有继承和委托，其中委托的耦合度明显低于继承。\n(3).类库级重用:相当于把一系列的class进行了打包，类似于第三方库的调用。\n(4).框架级复用:在框架的基础上，填充自己的代码，形成完整系统。(其实就类似于一些实验中，给出了很多代码，要求我们填入一些自己的代码)\n二.面向复用的软件构造技术\n1.LSP与泛型中的运用\n在我们3.4的继承，多态，泛型等等的基础上，这里我们主要介绍LSP，即Liskov替换原则。\nLiskov替换原则用数学性的语言来说，则如下图所示。\n从实际设计的角度来说，这个原则其实就是对子类型的约束：要求子类型对象完全可以当作父类型的对象来使用，其中就包括了规约的前置条件不能强化，后置条件不能弱化，要保持不变量等等。\n下面介绍协变与异变的概念。\n协变：子类对父类方法的覆写中，异常、返回值的类型是父类方法中返回值的类型的子类型，就称之为协变。\n逆变：顾名思义，与协变恰恰相反。\n因此为了复合Liskov替换原则，我们要求如果有变化的话，那异常，返回值必须是协变，参数必须是异变(当然，在java语言中参数的异变或协变导致方法不再是覆写，而是重载)。\njava中的泛型是类型不变的，如下图所示，是十分经典的例子。如果想进行协变或逆变，则需要使用通配符，例如List<? extends Number>是List < Number>的子类型，但是不论如何都要确保一个List中的元素都是一种类型的(尽管多种元素都可以放入)。\nClass为类型类，详细的用法可以参考“java中的反射”，可以得到很多信息，来验证我们上面的说法。这里就不详细说明了。\n2.委托与组合\n委托顾名思义，类似于现实中我们委托别人去做一些事情，抽象到代码中，那就是在某个类的方法中，传入其他类的变量，把实现逻辑写在这个其他类的方法中，并在这个类的方法中调用。\n例如我们想通过List的复用性实现stack，如果是继承关系的话，则stack中不可避免的有很多与我们期待的数据结构不匹配的方法。因此我们应该采取委托的方式，将pop等函数里某些操作委托给list即可。\n由于继承过于严格，因此如果不是有很强的继承关系，使用委托会更合适。\n总的来说，委托有四种形式。\n(1).依赖(Dependency):逻辑即为A use B,在A的方法中通过把B当作参数来或在方法的局部中，调用B的方法，是一种临时性的委托，只有调用这个方法的时候，它们才有临时关系。\n(2).关联(Association):逻辑即为A has B,对象A中的字段中有对象B，之后的操作和前面类似；只是A与B之间就有一个相对长的关系了。\n(3).组合(Composition):逻辑即为B is part of B,A中有字段B，且在A被构造时，B就被初始化好了(A中的定义导致的，比如A中有private T B = new T(…)语句)；因此它们声明周期一致。\n(4).聚合(Aggregation):逻辑即为A owns B，与(3)很相似，只是B构造的方式是通过A的构造函数的参数。因此对于B的构造，比第三种要灵活。\n3.框架设计\n有两种形式：一是白盒框架，二是黑盒框架。\n白盒框架：主要采用继承的方式，通过构建子类的方式进行扩展，子类中有main函数。代码是可见的，但是带来的问题就是要对父类的代码有了解，更贴近于开发者使用。\n黑盒框架：主要采用用插件实现接口和委托的方式进行扩展，子类中没有main函数。更贴近于用户使用。\n但无论是那种框架，控制权都是在框架手上的，这其实是框架和很多类构成的一个体系的区别。\n至于如何设计好一个框架，总的来说与多个类之间的设计思想一致，只是需要更多的去了解这个框架的用途，然后更有针对性地去开发。\n三.面向复用的设计模式\n总的来说，针对开发的阶段不同，设计模式分为以下三种：创建型模式、结构型模式、行为类模式。本章主要是讲解其中与可复用性密切相关的一些模式。\n1.结构型模式\n(1).适配器模式\n主要是用于解决类之间的接口不兼容的问题。一般用于新版本的时候重新定义了接口或者新创建了一些类，要和旧版本写适配的时候。方式还是一样有两种，分为继承和委托，不过一般委托更方便些。\n(2).装饰者模式\n总的来说，就是把一个个特殊功能看成是装饰品，然后调用时通过决定加入哪些装饰品从而得到我们想要的结果，而不是通过继承的方式来得到具体的类。\n具体实现方式就以ppt上冰淇淋这个例子来举例了，这也是最简单的一个装饰着模式的例子了。\n我们对于一个冰激凌，想在它上面添加一些食料。由于不同种的食料可以组合，采用继承会组合数爆炸。因此我们可以采用如下的策略：首先定义接口，其中有我们想要有不同实现的方法：AddTopping()方法；其次，我们正常的实现没有任何装饰的类，用于委托；之后，我们定义一个装饰器基类，把没装饰的类的一个对象作为自己的一个字段(其实就是委托)，然后并不实现要装饰的方法，准备留到子类；注意这个类和没有装饰的类是类似于“兄弟关系”，都是实现共同的接口。\n之后，我们再把对应的三种装饰方式实现为装饰器基类的子类，其中构造函数还是调用父类的构造函数，在待装饰的地方，就是先调用父类的操作，再加上自己独特的操作而成，这就是所谓的“装饰”。\n之后客户端的调用就顺理成章了。我们想要哪些装饰，就套入哪个装饰的构造方法即可，就类似于递归调用，因为我们在编写类的时候方法的实现就是递归的。\n不过这个模式在情况复杂的时候，写起来难度很大，逻辑上哪些应该先装饰，哪些应该后装饰还有冲突等如何处理也是个问题。\n(3).外观模式\n这个模式比较简单，其实就是客户端有的时候功能组合比较多，可能用起来比较复杂。因此我们就采用外观模式：用一个相对简化，统一的接口来实现对一系列接口的组合使用。\n2.行为类模式\n(1).策略模式\n其实这个模式也比较直观，就是实现的代码中，会根据用户输入的不同，采取不同策略的实现方式，就比如C++中的排序sort()函数，系统其实会根据输入的不同采取不同的算法。\n当然，内部的实现可以是最简单的先评判输入，然后再生成对应的参数，调用其他接口(委托)；更好的更隐蔽的方式是使用工厂模式，这个在后面的章节中会介绍。\n(2).模板模式\n模板模式很适合白盒框架，其实就是在父类中定义一系列抽象方法(即为一个个流程)，以及一个方法来定义这些流程的实现步骤，然后再用子类去实现这一个个流程的具体步骤。可见，这个模式和策略模式有相似的地方，就是具体也是采用不同的方法，只是保证步骤一样。\n(3).迭代器模式\n不关心容器具体类型，用一种统一的方式进行遍历。\n一般来说，实现的方式如下图所示。首先，这个类要实现Iterable接口，从而要实现蓝框中的方法得到迭代器。然后，我们就可以自己去实现对应的迭代器，其中这个迭代器要实现Iterator接口。通过这种方式，客户端在遍历的时候，完全无需看到迭代器是如何工作的。\n"
  },
  {
    "head": "32位Ubuntu系统share文件夹消失问题的解决",
    "paragraphs": [
      "用的是VMware虚拟机，经常在Ubuntu重启后share共享文件夹消失。",
      "输入如下代码：",
      "sudovmhgfs-fuse.host://mnt/hgfs/-oallow_other-ouid=1000",
      "即可解决。好耶！"
    ],
    "sentences": [
      "用的是VMware虚拟机",
      "经常在Ubuntu重启后share共享文件夹消失",
      "输入如下代码：sudovmhgfs-fuse.host://mnt/hgfs/-oallow_other-ouid=1000",
      "即可解决",
      "好耶！"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "用的是VMware虚拟机，经常在Ubuntu重启后share共享文件夹消失。\n输入如下代码：\nsudovmhgfs-fuse.host://mnt/hgfs/-oallow_other-ouid=1000\n即可解决。好耶！\n"
  },
  {
    "head": "详解Java中的checked异常和unchecked异常",
    "paragraphs": [
      "详解Java中的checked异常和unchecked异常",
      "（一）Java的异常层次结构",
      "要想明白Java中checked Exception和unchecked Exception的区别，我们首先来看一下Java的异常层次结构。",
      "这是一个简化的Java异常层次结构示意图，需要注意的是所有的类都是从Throwable继承而来，下一层则分为两个结构，Error和Exception。其中Error类层次描述了Java运行时系统的内部错误和资源耗尽错误，这种错误除了简单的报告给用户，并尽力阻止程序安全终止之外，一般也米有别的解决办法了。",
      "(二）unchecked异常和checked异常的区别",
      "有了上面的认识之后，我们再来看什么是checked异常，什么是unchecked的异常。其实，Java语言规范对这两个定义十分简单，将派生于Error或者RuntimeException的异常称为unchecked异常，所有其他的异常成为checked异常。尽管，这个定义十分简单，但是RuntimeException却是一个非常让人容易混淆的观念，似乎我们所有的异常都是在程序运行的过程中。我《Effective Java》中关于Ru ntimeException异常的阐述也不是那么尽如人意，",
      "Use checked exceptions for recoverable conditions and runtime exceptions for programming errors (Item 58 in 2nd edition)",
      "不过从这句话中我们可以简单引申一下，也就是说，如果出现了RuntimeException，就一定是程序员自身的问题。比如说，数组下标越界和访问空指针异常等等，只要你稍加留心这些异常都是在编码阶段可以避免的异常。如果你还是觉得这两个概念不好区分，那么“最暴力“的方法就是将常见的RuntimeException背下来，这样就可以省去很多判断的时间。",
      "（三）为什么要对unchecked异常和checked异常进行区分？",
      "原因其实很简单，编译器将检查你是否为所有的已检查异常提供了异常处理机制，比如说我们使用Class.forName()来查找给定的字符串的class对象的时候，如果没有为这个方法提供异常处理，编译是无法通过的。",
      "（四）我们应该对哪些异常进行声明？",
      "我们前面说，RuntimeException是在programing过程中可以避免的错误，那是不是我们就不需要抛出这些异常呢？原则上来说，是这样的，但是Java规范中并没有对此进行限制，只是看上去你抛出一个数组越界的异常并没有多少实际意义，相反还会对性能造成一定的损失。那么我们应该如何来设计抛出异常呢？我们要记住以下两种情况是必声明throws异常的：",
      "调用一个checked异常的方法，例如IOException，至于原因我们前面已经讨论过了，如果抛出所有的checked异常时无法通过编译的。",
      "程序运行过程中发现错误，利用throw语句抛出一个异常。",
      "对于unchecked异常，无非主要是两种情况要么是可以避免的（Runtime Exception），要么是不可控制的。这些也是需要声明异常的。"
    ],
    "sentences": [
      "详解Java中的checked异常和unchecked异常",
      "（一）Java的异常层次结构",
      "要想明白Java中checked Exception和unchecked Exception的区别",
      "我们首先来看一下Java的异常层次结构",
      "这是一个简化的Java异常层次结构示意图",
      "需要注意的是所有的类都是从Throwable继承而来",
      "下一层则分为两个结构",
      "Error和Exception",
      "其中Error类层次描述了Java运行时系统的内部错误和资源耗尽错误",
      "这种错误除了简单的报告给用户",
      "并尽力阻止程序安全终止之外",
      "一般也米有别的解决办法了",
      "(二）unchecked异常和checked异常的区别",
      "有了上面的认识之后",
      "我们再来看什么是checked异常",
      "什么是unchecked的异常",
      "其实",
      "Java语言规范对这两个定义十分简单",
      "将派生于Error或者RuntimeException的异常称为unchecked异常",
      "所有其他的异常成为checked异常",
      "尽管",
      "这个定义十分简单",
      "但是RuntimeException却是一个非常让人容易混淆的观念",
      "似乎我们所有的异常都是在程序运行的过程中",
      "我《Effective Java》中关于Ru ntimeException异常的阐述也不是那么尽如人意",
      "Use checked exceptions for recoverable conditions and runtime exceptions for programming errors (Item 58 in 2nd edition)",
      "不过从这句话中我们可以简单引申一下",
      "也就是说",
      "如果出现了RuntimeException",
      "就一定是程序员自身的问题",
      "比如说",
      "数组下标越界和访问空指针异常等等",
      "只要你稍加留心这些异常都是在编码阶段可以避免的异常",
      "如果你还是觉得这两个概念不好区分",
      "那么“最暴力“的方法就是将常见的RuntimeException背下来",
      "这样就可以省去很多判断的时间",
      "（三）为什么要对unchecked异常和checked异常进行区分？",
      "原因其实很简单",
      "编译器将检查你是否为所有的已检查异常提供了异常处理机制",
      "比如说我们使用Class.forName()来查找给定的字符串的class对象的时候",
      "如果没有为这个方法提供异常处理",
      "编译是无法通过的",
      "（四）我们应该对哪些异常进行声明？",
      "我们前面说",
      "RuntimeException是在programing过程中可以避免的错误",
      "那是不是我们就不需要抛出这些异常呢？原则上来说",
      "是这样的",
      "但是Java规范中并没有对此进行限制",
      "只是看上去你抛出一个数组越界的异常并没有多少实际意义",
      "相反还会对性能造成一定的损失",
      "那么我们应该如何来设计抛出异常呢？我们要记住以下两种情况是必声明throws异常的：调用一个checked异常的方法",
      "例如IOException",
      "至于原因我们前面已经讨论过了",
      "如果抛出所有的checked异常时无法通过编译的",
      "程序运行过程中发现错误，利用throw语句抛出一个异常",
      "对于unchecked异常",
      "无非主要是两种情况要么是可以避免的（Runtime Exception）",
      "要么是不可控制的",
      "这些也是需要声明异常的"
    ],
    "codes": [],
    "date": "2021-05-31",
    "text": "详解Java中的checked异常和unchecked异常\n（一）Java的异常层次结构\n要想明白Java中checked Exception和unchecked Exception的区别，我们首先来看一下Java的异常层次结构。\n这是一个简化的Java异常层次结构示意图，需要注意的是所有的类都是从Throwable继承而来，下一层则分为两个结构，Error和Exception。其中Error类层次描述了Java运行时系统的内部错误和资源耗尽错误，这种错误除了简单的报告给用户，并尽力阻止程序安全终止之外，一般也米有别的解决办法了。\n(二）unchecked异常和checked异常的区别\n有了上面的认识之后，我们再来看什么是checked异常，什么是unchecked的异常。其实，Java语言规范对这两个定义十分简单，将派生于Error或者RuntimeException的异常称为unchecked异常，所有其他的异常成为checked异常。尽管，这个定义十分简单，但是RuntimeException却是一个非常让人容易混淆的观念，似乎我们所有的异常都是在程序运行的过程中。我《Effective Java》中关于Ru ntimeException异常的阐述也不是那么尽如人意，\nUse checked exceptions for recoverable conditions and runtime exceptions for programming errors (Item 58 in 2nd edition)\n不过从这句话中我们可以简单引申一下，也就是说，如果出现了RuntimeException，就一定是程序员自身的问题。比如说，数组下标越界和访问空指针异常等等，只要你稍加留心这些异常都是在编码阶段可以避免的异常。如果你还是觉得这两个概念不好区分，那么“最暴力“的方法就是将常见的RuntimeException背下来，这样就可以省去很多判断的时间。\n（三）为什么要对unchecked异常和checked异常进行区分？\n原因其实很简单，编译器将检查你是否为所有的已检查异常提供了异常处理机制，比如说我们使用Class.forName()来查找给定的字符串的class对象的时候，如果没有为这个方法提供异常处理，编译是无法通过的。\n（四）我们应该对哪些异常进行声明？\n我们前面说，RuntimeException是在programing过程中可以避免的错误，那是不是我们就不需要抛出这些异常呢？原则上来说，是这样的，但是Java规范中并没有对此进行限制，只是看上去你抛出一个数组越界的异常并没有多少实际意义，相反还会对性能造成一定的损失。那么我们应该如何来设计抛出异常呢？我们要记住以下两种情况是必声明throws异常的：\n调用一个checked异常的方法，例如IOException，至于原因我们前面已经讨论过了，如果抛出所有的checked异常时无法通过编译的。\n程序运行过程中发现错误，利用throw语句抛出一个异常。\n对于unchecked异常，无非主要是两种情况要么是可以避免的（Runtime Exception），要么是不可控制的。这些也是需要声明异常的。\n"
  },
  {
    "head": "软件构造——OOP",
    "paragraphs": [
      "一.OOP基础",
      " 这里只是对需要注意的地方做一些常识性总结，毕竟这些都是java初学者必须要熟练掌握的内容。",
      "1.OOP的一些基本概念",
      " 在java语言中，我们最经常遇到的OOP概念即为类，对象和接口。",
      " 现实世界中的对象可映射为编程中的对象，其中状态即映射为字段，行为则映射为方法。",
      " 类的概念是在对象的概念产生后产生的。类是对一组对象统一的表达，是一个抽象的概念，现实世界中并不存在类的实体；而对象则是类的实例化。",
      " 类中的字段和方法分为属于类的和属于对象的。加static即为属于类，在类的外部用类名.字段/方法名进行操作；而不加static即为属于对象，在类的外部用对象名.字段/方法名进行操作。",
      " 注：静态方法中无法直接调用非静态成员和方法，但是可以new一个对象，之后再使用。",
      " 接口不能有构造方法，也要写规约，实现接口的类对相应的方法可以不写规约。要注意如果接口的规约表示为不可变类，那相应的实现中也要是不可变的，这点常常被忽视。",
      " 以前使用接口并不能完全隐藏实现，但现在接口中可以有静态方法，从而实现完全的隐藏，例如 实验二中的graph接口。",
      "2.信息隐藏与封装",
      " 实现方式:尽量使用接口声明变量，客户端仅使用接口中定义的方法，让客户端不能直接访问属性。可采用不同的权限修饰词来进行约束，以下为四个修饰词各自的权限。",
      " 总的来说，不需要用户使用的方法都应尽量是private的，或者作用域能尽量小就尽量小。况且作用域越小，容错率越高。",
      "3.继承与覆写",
      " 子类覆写的方法的可见性要大于等于父类，因为子类的对象应可以转型为父类对象，可见性的降低就会出现错误。同理，子类抛出的异常必须是父类的子集。",
      " 覆写的方法是在运行时判断类型来调用的，因此以new构造的类型为准。",
      " 在子类中,用super关键字来调用父类的各种方法，用的最多的是构造方法。",
      "4.多态",
      " 多态主要分为三种，我们下面分别来介绍。",
      " A.特殊多态:一个方法可以有多个同名的实现(方法重载)。要求参数列表必须有不同的地方，其他的并没有要求，总之就是把重载的方法看作和之前完全不同的方法。",
      " 重载是编译时确定，属于静态检查。而覆写是运行时确定。因此对于类A 变量名 = new 类B(参数)而言，编译时类型为A，运行时类型为B。具体例子如下图所示。",
      " 另外，还需注意这种变量作为参数时多态的用法，如下图所示。",
      " B.参数化多态:一个类型名字可以代表多个类型(泛型化编程)。",
      " 泛型类/接口的格式：关键字 类名/接口名<占位符>(){…} 占位符其实就相当于额外的参数，代表着对应的类型。实际调用的时候使用类型参数，转化为对应的类名(因此如果希望是整型参数，要用Integer而不是int)，因此运行阶段不存在泛型。泛型接口可以有泛型或非泛型的实现类，取决于自己的需求。",
      " 泛型方法的格式：关键字 <占位符> 返回值 方法名(参数列表){…}，注意，参数列表中有泛型变量，并不会导致这是一个泛型方法，因为这其实是属于泛型类的泛型变量。",
      " 对于静态方法，如果使用泛型参数，那么必须也定义为泛型方法。",
      " C.子类型/包含多态:一个变量名字可以代表多个类的实例。其实就如同上面的例子用到的一样。子类型的实例也可以说是父类型的一个实例(当然反之不成立)，因此子类型的规约不能弱化超类型的规约。",
      "二.ADT和OOP中的等价性",
      "1.三种判断等价性的方法",
      " <1>.利用数学上等价的定义:满足自反性，对称性和传递性。",
      " <2>.利用AF来定义ADT的等价判断，如果两个值的AF映射值相同，则说明他们等价。",
      " <3>.在调用者角度，如果调用两个对象的所有任意操作，效果都完全一样，那么则说明他们等价。",
      "2.“==”与equals",
      " 对于“==”,代表着判断两个对象的地址空间是不是在同一个位置，也被称为引用等价性；而equals则代表着判断两个对象的内容，也被称为对象等价性。",
      " object类的equals默认为判断两者的地址空间是不是在同一位置。总的来说，对于基本数据类型，我们应该用“==”，而对于对象数据类型，我们应该用equals判断(当然，要根据需要判断是否应该覆写)，当然，我们要明确知道我们写的方法是覆写还是重载。",
      " 除了写equals方法，尽量不要用instanceof和getclass()，因为他们不符合OOP的思想，不是好的书写风格。",
      "3.hashcode与equals",
      " hashcode方法就类似于数据结构中的哈希函数一样，功能就是把一个个对象映射到一个地址(也就是桶)。默认的方式是按照地址映射，一般地址不同则值不同。",
      " 当我们使用HashSet等类似的数据结构的时候，这时再进行寻找时，就如同正常哈希表一样了，是通过判断哈希值是否相等先进行判断，哈希值相同是equals成立的前提，也是首先判断的方法。此时如果我们只重写equals而不重写hashcode，则hashcode还是默认的按地址算出一个值，一般而言只要地址不同则哈希值就不同了，导致了我们equals方法看似失效。",
      " 综上，equals()应满足如下条件：首先满足等价性(数学意义上)，其次保证在不被修改的情况下，每次调用的结果应该相同，同时要处理对象为null的情况还有如果这个类使用了哈希表进行查询(比如放入了HashSet中)，则也要覆写hashcode方法。",
      "4.可变类型的等价性",
      " 有两种判断方式:观察等价性与行为等价性；分别代表不改变状态的前提下，通过观察器来判断两者是否相同以及调用任何方法是否有相同的结果，但由于是可变类型，也就相当于判断地址是否相同了。",
      " 虽然很多时候我们倾向于判断观察等价性是否相同，但是可能引起bug甚至破坏RI，尤其是使用了Set的时候。比如经典的Set<List< T >>引起的bug。",
      " 因此，总结起来来说，对于可变类型，我们不应该覆写equals方法和hashcode方法，如果想“比较”，我们可以使用其他自定义的方法；而对于不可变类型，如果我们想要“比较”，那么我们是一定要覆写这两个方法的。",
      "5.装箱及其等价性",
      " 在使用集合类时，我们前面也提到过，会进行隐式的装箱操作。因此，装箱完毕后，如果是两个不同对象，即使是整数的装箱，使用“==”进行判断也会返回false，要进行equals的覆写。",
      " 但是下面有一个特例，那就是如果是-128到127之间的整数，进行两次装箱操作，那得到的地址是一样的(得益于java的缓存机制)。当然，上面也是要求只装箱，不能为两次new的操作，不然肯定地址值不同。"
    ],
    "sentences": [
      "一.OOP基础",
      " 这里只是对需要注意的地方做一些常识性总结",
      "毕竟这些都是java初学者必须要熟练掌握的内容",
      "1.OOP的一些基本概念",
      " 在java语言中",
      "我们最经常遇到的OOP概念即为类",
      "对象和接口",
      " 现实世界中的对象可映射为编程中的对象",
      "其中状态即映射为字段",
      "行为则映射为方法",
      " 类的概念是在对象的概念产生后产生的",
      "类是对一组对象统一的表达",
      "是一个抽象的概念",
      "现实世界中并不存在类的实体；而对象则是类的实例化",
      " 类中的字段和方法分为属于类的和属于对象的",
      "加static即为属于类",
      "在类的外部用类名.字段/方法名进行操作；而不加static即为属于对象",
      "在类的外部用对象名.字段/方法名进行操作",
      " 注：静态方法中无法直接调用非静态成员和方法",
      "但是可以new一个对象",
      "之后再使用",
      " 接口不能有构造方法",
      "也要写规约",
      "实现接口的类对相应的方法可以不写规约",
      "要注意如果接口的规约表示为不可变类",
      "那相应的实现中也要是不可变的",
      "这点常常被忽视",
      " 以前使用接口并不能完全隐藏实现",
      "但现在接口中可以有静态方法",
      "从而实现完全的隐藏",
      "例如 实验二中的graph接口",
      "2.信息隐藏与封装",
      " 实现方式:尽量使用接口声明变量",
      "客户端仅使用接口中定义的方法",
      "让客户端不能直接访问属性",
      "可采用不同的权限修饰词来进行约束，以下为四个修饰词各自的权限",
      " 总的来说",
      "不需要用户使用的方法都应尽量是private的",
      "或者作用域能尽量小就尽量小",
      "况且作用域越小，容错率越高",
      "3.继承与覆写",
      " 子类覆写的方法的可见性要大于等于父类",
      "因为子类的对象应可以转型为父类对象",
      "可见性的降低就会出现错误",
      "同理，子类抛出的异常必须是父类的子集",
      " 覆写的方法是在运行时判断类型来调用的",
      "因此以new构造的类型为准",
      " 在子类中,用super关键字来调用父类的各种方法",
      "用的最多的是构造方法",
      "4.多态",
      " 多态主要分为三种，我们下面分别来介绍",
      " A.特殊多态:一个方法可以有多个同名的实现(方法重载)",
      "要求参数列表必须有不同的地方",
      "其他的并没有要求",
      "总之就是把重载的方法看作和之前完全不同的方法",
      " 重载是编译时确定，属于静态检查",
      "而覆写是运行时确定",
      "因此对于类A 变量名 = new 类B(参数)而言",
      "编译时类型为A",
      "运行时类型为B",
      "具体例子如下图所示",
      " 另外，还需注意这种变量作为参数时多态的用法，如下图所示",
      " B.参数化多态:一个类型名字可以代表多个类型(泛型化编程)",
      " 泛型类/接口的格式：关键字 类名/接口名<占位符>(){…} 占位符其实就相当于额外的参数",
      "代表着对应的类型",
      "实际调用的时候使用类型参数",
      "转化为对应的类名(因此如果希望是整型参数",
      "要用Integer而不是int)",
      "因此运行阶段不存在泛型",
      "泛型接口可以有泛型或非泛型的实现类，取决于自己的需求",
      " 泛型方法的格式：关键字 <占位符> 返回值 方法名(参数列表){…}",
      "注意",
      "参数列表中有泛型变量",
      "并不会导致这是一个泛型方法",
      "因为这其实是属于泛型类的泛型变量",
      " 对于静态方法，如果使用泛型参数，那么必须也定义为泛型方法",
      " C.子类型/包含多态:一个变量名字可以代表多个类的实例",
      "其实就如同上面的例子用到的一样",
      "子类型的实例也可以说是父类型的一个实例(当然反之不成立)",
      "因此子类型的规约不能弱化超类型的规约",
      "二.ADT和OOP中的等价性",
      "1.三种判断等价性的方法",
      " <1>.利用数学上等价的定义:满足自反性，对称性和传递性",
      " <2>.利用AF来定义ADT的等价判断",
      "如果两个值的AF映射值相同",
      "则说明他们等价",
      " <3>.在调用者角度",
      "如果调用两个对象的所有任意操作",
      "效果都完全一样",
      "那么则说明他们等价",
      "2.“==”与equals",
      " 对于“==”,代表着判断两个对象的地址空间是不是在同一个位置",
      "也被称为引用等价性；而equals则代表着判断两个对象的内容",
      "也被称为对象等价性",
      " object类的equals默认为判断两者的地址空间是不是在同一位置",
      "总的来说",
      "对于基本数据类型",
      "我们应该用“==”",
      "而对于对象数据类型",
      "我们应该用equals判断(当然",
      "要根据需要判断是否应该覆写)",
      "当然",
      "我们要明确知道我们写的方法是覆写还是重载",
      " 除了写equals方法",
      "尽量不要用instanceof和getclass()",
      "因为他们不符合OOP的思想",
      "不是好的书写风格",
      "3.hashcode与equals",
      " hashcode方法就类似于数据结构中的哈希函数一样",
      "功能就是把一个个对象映射到一个地址(也就是桶)",
      "默认的方式是按照地址映射，一般地址不同则值不同",
      " 当我们使用HashSet等类似的数据结构的时候",
      "这时再进行寻找时",
      "就如同正常哈希表一样了",
      "是通过判断哈希值是否相等先进行判断",
      "哈希值相同是equals成立的前提",
      "也是首先判断的方法",
      "此时如果我们只重写equals而不重写hashcode",
      "则hashcode还是默认的按地址算出一个值",
      "一般而言只要地址不同则哈希值就不同了",
      "导致了我们equals方法看似失效",
      " 综上",
      "equals()应满足如下条件：首先满足等价性(数学意义上)",
      "其次保证在不被修改的情况下",
      "每次调用的结果应该相同",
      "同时要处理对象为null的情况还有如果这个类使用了哈希表进行查询(比如放入了HashSet中)",
      "则也要覆写hashcode方法",
      "4.可变类型的等价性",
      " 有两种判断方式:观察等价性与行为等价性；分别代表不改变状态的前提下",
      "通过观察器来判断两者是否相同以及调用任何方法是否有相同的结果",
      "但由于是可变类型",
      "也就相当于判断地址是否相同了",
      " 虽然很多时候我们倾向于判断观察等价性是否相同",
      "但是可能引起bug甚至破坏RI",
      "尤其是使用了Set的时候",
      "比如经典的Set<List< T >>引起的bug",
      " 因此",
      "总结起来来说",
      "对于可变类型",
      "我们不应该覆写equals方法和hashcode方法",
      "如果想“比较”",
      "我们可以使用其他自定义的方法；而对于不可变类型",
      "如果我们想要“比较”",
      "那么我们是一定要覆写这两个方法的",
      "5.装箱及其等价性",
      " 在使用集合类时，我们前面也提到过，会进行隐式的装箱操作",
      "因此",
      "装箱完毕后",
      "如果是两个不同对象",
      "即使是整数的装箱",
      "使用“==”进行判断也会返回false",
      "要进行equals的覆写",
      " 但是下面有一个特例",
      "那就是如果是-128到127之间的整数",
      "进行两次装箱操作",
      "那得到的地址是一样的(得益于java的缓存机制)",
      "当然",
      "上面也是要求只装箱",
      "不能为两次new的操作",
      "不然肯定地址值不同"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "一.OOP基础\n 这里只是对需要注意的地方做一些常识性总结，毕竟这些都是java初学者必须要熟练掌握的内容。\n1.OOP的一些基本概念\n 在java语言中，我们最经常遇到的OOP概念即为类，对象和接口。\n 现实世界中的对象可映射为编程中的对象，其中状态即映射为字段，行为则映射为方法。\n 类的概念是在对象的概念产生后产生的。类是对一组对象统一的表达，是一个抽象的概念，现实世界中并不存在类的实体；而对象则是类的实例化。\n 类中的字段和方法分为属于类的和属于对象的。加static即为属于类，在类的外部用类名.字段/方法名进行操作；而不加static即为属于对象，在类的外部用对象名.字段/方法名进行操作。\n 注：静态方法中无法直接调用非静态成员和方法，但是可以new一个对象，之后再使用。\n 接口不能有构造方法，也要写规约，实现接口的类对相应的方法可以不写规约。要注意如果接口的规约表示为不可变类，那相应的实现中也要是不可变的，这点常常被忽视。\n 以前使用接口并不能完全隐藏实现，但现在接口中可以有静态方法，从而实现完全的隐藏，例如 实验二中的graph接口。\n2.信息隐藏与封装\n 实现方式:尽量使用接口声明变量，客户端仅使用接口中定义的方法，让客户端不能直接访问属性。可采用不同的权限修饰词来进行约束，以下为四个修饰词各自的权限。\n 总的来说，不需要用户使用的方法都应尽量是private的，或者作用域能尽量小就尽量小。况且作用域越小，容错率越高。\n3.继承与覆写\n 子类覆写的方法的可见性要大于等于父类，因为子类的对象应可以转型为父类对象，可见性的降低就会出现错误。同理，子类抛出的异常必须是父类的子集。\n 覆写的方法是在运行时判断类型来调用的，因此以new构造的类型为准。\n 在子类中,用super关键字来调用父类的各种方法，用的最多的是构造方法。\n4.多态\n 多态主要分为三种，我们下面分别来介绍。\n A.特殊多态:一个方法可以有多个同名的实现(方法重载)。要求参数列表必须有不同的地方，其他的并没有要求，总之就是把重载的方法看作和之前完全不同的方法。\n 重载是编译时确定，属于静态检查。而覆写是运行时确定。因此对于类A 变量名 = new 类B(参数)而言，编译时类型为A，运行时类型为B。具体例子如下图所示。\n 另外，还需注意这种变量作为参数时多态的用法，如下图所示。\n B.参数化多态:一个类型名字可以代表多个类型(泛型化编程)。\n 泛型类/接口的格式：关键字 类名/接口名<占位符>(){…} 占位符其实就相当于额外的参数，代表着对应的类型。实际调用的时候使用类型参数，转化为对应的类名(因此如果希望是整型参数，要用Integer而不是int)，因此运行阶段不存在泛型。泛型接口可以有泛型或非泛型的实现类，取决于自己的需求。\n 泛型方法的格式：关键字 <占位符> 返回值 方法名(参数列表){…}，注意，参数列表中有泛型变量，并不会导致这是一个泛型方法，因为这其实是属于泛型类的泛型变量。\n 对于静态方法，如果使用泛型参数，那么必须也定义为泛型方法。\n C.子类型/包含多态:一个变量名字可以代表多个类的实例。其实就如同上面的例子用到的一样。子类型的实例也可以说是父类型的一个实例(当然反之不成立)，因此子类型的规约不能弱化超类型的规约。\n二.ADT和OOP中的等价性\n1.三种判断等价性的方法\n <1>.利用数学上等价的定义:满足自反性，对称性和传递性。\n <2>.利用AF来定义ADT的等价判断，如果两个值的AF映射值相同，则说明他们等价。\n <3>.在调用者角度，如果调用两个对象的所有任意操作，效果都完全一样，那么则说明他们等价。\n2.“==”与equals\n 对于“==”,代表着判断两个对象的地址空间是不是在同一个位置，也被称为引用等价性；而equals则代表着判断两个对象的内容，也被称为对象等价性。\n object类的equals默认为判断两者的地址空间是不是在同一位置。总的来说，对于基本数据类型，我们应该用“==”，而对于对象数据类型，我们应该用equals判断(当然，要根据需要判断是否应该覆写)，当然，我们要明确知道我们写的方法是覆写还是重载。\n 除了写equals方法，尽量不要用instanceof和getclass()，因为他们不符合OOP的思想，不是好的书写风格。\n3.hashcode与equals\n hashcode方法就类似于数据结构中的哈希函数一样，功能就是把一个个对象映射到一个地址(也就是桶)。默认的方式是按照地址映射，一般地址不同则值不同。\n 当我们使用HashSet等类似的数据结构的时候，这时再进行寻找时，就如同正常哈希表一样了，是通过判断哈希值是否相等先进行判断，哈希值相同是equals成立的前提，也是首先判断的方法。此时如果我们只重写equals而不重写hashcode，则hashcode还是默认的按地址算出一个值，一般而言只要地址不同则哈希值就不同了，导致了我们equals方法看似失效。\n 综上，equals()应满足如下条件：首先满足等价性(数学意义上)，其次保证在不被修改的情况下，每次调用的结果应该相同，同时要处理对象为null的情况还有如果这个类使用了哈希表进行查询(比如放入了HashSet中)，则也要覆写hashcode方法。\n4.可变类型的等价性\n 有两种判断方式:观察等价性与行为等价性；分别代表不改变状态的前提下，通过观察器来判断两者是否相同以及调用任何方法是否有相同的结果，但由于是可变类型，也就相当于判断地址是否相同了。\n 虽然很多时候我们倾向于判断观察等价性是否相同，但是可能引起bug甚至破坏RI，尤其是使用了Set的时候。比如经典的Set<List< T >>引起的bug。\n 因此，总结起来来说，对于可变类型，我们不应该覆写equals方法和hashcode方法，如果想“比较”，我们可以使用其他自定义的方法；而对于不可变类型，如果我们想要“比较”，那么我们是一定要覆写这两个方法的。\n5.装箱及其等价性\n 在使用集合类时，我们前面也提到过，会进行隐式的装箱操作。因此，装箱完毕后，如果是两个不同对象，即使是整数的装箱，使用“==”进行判断也会返回false，要进行equals的覆写。\n 但是下面有一个特例，那就是如果是-128到127之间的整数，进行两次装箱操作，那得到的地址是一样的(得益于java的缓存机制)。当然，上面也是要求只装箱，不能为两次new的操作，不然肯定地址值不同。\n"
  },
  {
    "head": "软件构造——ADT",
    "paragraphs": [
      "一.ADT的基本概念",
      " 数据抽象：由一组操作所刻画的数据类型；强调的是操作而不是具体如何存储的。",
      " 可以看出对应的抽象可能有多种实现方式。所以可见ADT是由操作定义的，与内部实现方式无关；一般用户也不关心实现方式，只关心暴露出的操作(通过规约来达成一致)。",
      "二.典型的类型和操作",
      " 类型上可分为可变数据类型和不可变数据类型，与3.1节的含义相同。",
      " 下面内容为重点",
      " 操作上可以分为四类，分别是构造器、生产器、观察器、变值器。",
      " 构造器是从无到有的过程，一般用构造方法或者静态工厂方法来实现。",
      " 生产器是从旧到新的过程，一般是一些对不可变类型的修改导致新生成一个对象等等的操作。",
      " 观察器顾名思义，仅仅是看我们想要得到的内容，而不进行修改。",
      " 变值器也是顾名思义，指的那些改变对象属性的方法。一般返回值为void的方法很可能是变值器。有变值器的数据类型就是可变数据类型，否则就是不可变数据类型。",
      "三.ADT的设计法则",
      " 法则1：操作要简洁，一致。对于复杂的操作，应该拆分成多个简单操作的叠加，以此提高内聚性。",
      " 法则2：操作要全面(即需要的功能要可以实现)，且为用户提供方便的操作。",
      " 法则3：要不是针对抽象，要不是针对具体，不要两者混合。因此面向具体应用的类型不应该有通用方法，面向通用的类型也不该有具体方法。",
      "四.表示独立性",
      " 表示独立性(Representation Independence)的含义为，客户端使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端，客户端调用的结果应该是相同的；也就是我们前面一直强调的用户调用与内部实现方式无关。",
      "五.ADT的测试",
      " 总的来说，对构造器、生产器、变值器的测试要用观察器检查；对观察器的测试要用其他三类方法来产生或构造对象。但这样的风险是，可能会产生互相依赖的现象，导致无法找到真正的错误原因。",
      " 解决方案：新创建一些方法来解除这些耦合，或者是把一部分私有方法改为公有方法，测试完后再换回私有。或者如果对于小型程序，只要测试结果都是正确的，也就可以解决问题。",
      "六.不变量",
      " 不变量就是ADT在使用的过程中永远为真的性质，与客户端的行为无关。为了确保 ADT使用时的正确性以及出错误时定位错误，我们一般会经常判断我们的不变量是否为真。",
      " 例如不可变类型是不可变的，自己设计的set中不能有重复值(要求不能有重复值)等等。",
      " 一般导致不变量被破坏是因为表示泄露：将我们不应该被修改的内容交给了客户端去修改。总的来说，杜绝方法如下：尽量都使用不可变的数据类型；否则至少让输入的参数为不可变类型，同时做好防御性拷贝，返回新的对象，或者是把返回的字段改为不可变的。",
      "七.表示不变量(RI)与抽象函数(AF)",
      " 首先，我们做如下的两个定义。",
      " R：表示空间，ADT中实际存储的内容。(当然和ADT的实现密切相关)",
      " A：抽象空间，客户端看到和使用的值。",
      " AF：从R到A之间的一个对应关系(映射)，即AF：R → A。",
      " 当然，A中的元素都肯定在R中至少有一个对应；而R中却可能有元素不和A中的任何元素对应(即不遵守规约的内容)，因此可见AF为满射而未必为单射。注：这里的映射其实指的是部分映射，因为映射要求R中每个元素都有A来对应，因此对全体R来看的话，只要每个像都有一个原像，那就是单射了；但即使既是单射又是满射，也可能不是双射。",
      " RI：从R到boolean的一个映射，即RI：R → boolean，其中如果R中的元素在A中有像即表示合法，则该元素在RI的映射值为true。也可以说RI是一个条件，描述了哪些是合法值。",
      " 下图为一个简单的例子，实现的内容为字符集合。",
      " 不同的内部表示要设计不同的AF和RI，主要流程是先通过某种特定的表示方式R，来指定出RI，从而再做出相应的解释，也就是AF。",
      " 我们应该在开发阶段，对所有改变不变量的方法中随时检查(除了观察者之外的方法)。因此我们一般会使用assert语句。",
      "八.AF，RI和表示泄露安全说明的文档化",
      " 这些都是写在代码的注释中，而非规约中。要给出理由，证明代码并未对外泄露其内部表示，比如字段全部为private，还有对可变字段的处理等等。",
      " 可用表示不变量来代替一些前置条件。"
    ],
    "sentences": [
      "一.ADT的基本概念",
      " 数据抽象：由一组操作所刻画的数据类型；强调的是操作而不是具体如何存储的",
      " 可以看出对应的抽象可能有多种实现方式",
      "所以可见ADT是由操作定义的",
      "与内部实现方式无关；一般用户也不关心实现方式",
      "只关心暴露出的操作(通过规约来达成一致)",
      "二.典型的类型和操作",
      " 类型上可分为可变数据类型和不可变数据类型",
      "与3.1节的含义相同",
      " 下面内容为重点",
      " 操作上可以分为四类，分别是构造器、生产器、观察器、变值器",
      " 构造器是从无到有的过程",
      "一般用构造方法或者静态工厂方法来实现",
      " 生产器是从旧到新的过程",
      "一般是一些对不可变类型的修改导致新生成一个对象等等的操作",
      " 观察器顾名思义，仅仅是看我们想要得到的内容，而不进行修改",
      " 变值器也是顾名思义，指的那些改变对象属性的方法",
      "一般返回值为void的方法很可能是变值器",
      "有变值器的数据类型就是可变数据类型，否则就是不可变数据类型",
      "三.ADT的设计法则",
      " 法则1：操作要简洁，一致",
      "对于复杂的操作，应该拆分成多个简单操作的叠加，以此提高内聚性",
      " 法则2：操作要全面(即需要的功能要可以实现)",
      "且为用户提供方便的操作",
      " 法则3：要不是针对抽象，要不是针对具体，不要两者混合",
      "因此面向具体应用的类型不应该有通用方法",
      "面向通用的类型也不该有具体方法",
      "四.表示独立性",
      " 表示独立性(Representation Independence)的含义为",
      "客户端使用ADT时无需考虑其内部如何实现",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "客户端调用的结果应该是相同的；也就是我们前面一直强调的用户调用与内部实现方式无关",
      "五.ADT的测试",
      " 总的来说",
      "对构造器、生产器、变值器的测试要用观察器检查；对观察器的测试要用其他三类方法来产生或构造对象",
      "但这样的风险是",
      "可能会产生互相依赖的现象",
      "导致无法找到真正的错误原因",
      " 解决方案：新创建一些方法来解除这些耦合",
      "或者是把一部分私有方法改为公有方法",
      "测试完后再换回私有",
      "或者如果对于小型程序",
      "只要测试结果都是正确的",
      "也就可以解决问题",
      "六.不变量",
      " 不变量就是ADT在使用的过程中永远为真的性质",
      "与客户端的行为无关",
      "为了确保 ADT使用时的正确性以及出错误时定位错误",
      "我们一般会经常判断我们的不变量是否为真",
      " 例如不可变类型是不可变的",
      "自己设计的set中不能有重复值(要求不能有重复值)等等",
      " 一般导致不变量被破坏是因为表示泄露：将我们不应该被修改的内容交给了客户端去修改",
      "总的来说",
      "杜绝方法如下：尽量都使用不可变的数据类型；否则至少让输入的参数为不可变类型",
      "同时做好防御性拷贝",
      "返回新的对象",
      "或者是把返回的字段改为不可变的",
      "七.表示不变量(RI)与抽象函数(AF)",
      " 首先，我们做如下的两个定义",
      " R：表示空间，ADT中实际存储的内容",
      "(当然和ADT的实现密切相关)",
      " A：抽象空间，客户端看到和使用的值",
      " AF：从R到A之间的一个对应关系(映射)",
      "即AF：R → A",
      " 当然",
      "A中的元素都肯定在R中至少有一个对应；而R中却可能有元素不和A中的任何元素对应(即不遵守规约的内容)",
      "因此可见AF为满射而未必为单射",
      "注：这里的映射其实指的是部分映射",
      "因为映射要求R中每个元素都有A来对应",
      "因此对全体R来看的话",
      "只要每个像都有一个原像",
      "那就是单射了；但即使既是单射又是满射",
      "也可能不是双射",
      " RI：从R到boolean的一个映射",
      "即RI：R → boolean",
      "其中如果R中的元素在A中有像即表示合法",
      "则该元素在RI的映射值为true",
      "也可以说RI是一个条件，描述了哪些是合法值",
      " 下图为一个简单的例子，实现的内容为字符集合",
      " 不同的内部表示要设计不同的AF和RI",
      "主要流程是先通过某种特定的表示方式R",
      "来指定出RI",
      "从而再做出相应的解释",
      "也就是AF",
      " 我们应该在开发阶段",
      "对所有改变不变量的方法中随时检查(除了观察者之外的方法)",
      "因此我们一般会使用assert语句",
      "八.AF，RI和表示泄露安全说明的文档化",
      " 这些都是写在代码的注释中，而非规约中",
      "要给出理由",
      "证明代码并未对外泄露其内部表示",
      "比如字段全部为private",
      "还有对可变字段的处理等等",
      " 可用表示不变量来代替一些前置条件"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "一.ADT的基本概念\n 数据抽象：由一组操作所刻画的数据类型；强调的是操作而不是具体如何存储的。\n 可以看出对应的抽象可能有多种实现方式。所以可见ADT是由操作定义的，与内部实现方式无关；一般用户也不关心实现方式，只关心暴露出的操作(通过规约来达成一致)。\n二.典型的类型和操作\n 类型上可分为可变数据类型和不可变数据类型，与3.1节的含义相同。\n 下面内容为重点\n 操作上可以分为四类，分别是构造器、生产器、观察器、变值器。\n 构造器是从无到有的过程，一般用构造方法或者静态工厂方法来实现。\n 生产器是从旧到新的过程，一般是一些对不可变类型的修改导致新生成一个对象等等的操作。\n 观察器顾名思义，仅仅是看我们想要得到的内容，而不进行修改。\n 变值器也是顾名思义，指的那些改变对象属性的方法。一般返回值为void的方法很可能是变值器。有变值器的数据类型就是可变数据类型，否则就是不可变数据类型。\n三.ADT的设计法则\n 法则1：操作要简洁，一致。对于复杂的操作，应该拆分成多个简单操作的叠加，以此提高内聚性。\n 法则2：操作要全面(即需要的功能要可以实现)，且为用户提供方便的操作。\n 法则3：要不是针对抽象，要不是针对具体，不要两者混合。因此面向具体应用的类型不应该有通用方法，面向通用的类型也不该有具体方法。\n四.表示独立性\n 表示独立性(Representation Independence)的含义为，客户端使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端，客户端调用的结果应该是相同的；也就是我们前面一直强调的用户调用与内部实现方式无关。\n五.ADT的测试\n 总的来说，对构造器、生产器、变值器的测试要用观察器检查；对观察器的测试要用其他三类方法来产生或构造对象。但这样的风险是，可能会产生互相依赖的现象，导致无法找到真正的错误原因。\n 解决方案：新创建一些方法来解除这些耦合，或者是把一部分私有方法改为公有方法，测试完后再换回私有。或者如果对于小型程序，只要测试结果都是正确的，也就可以解决问题。\n六.不变量\n 不变量就是ADT在使用的过程中永远为真的性质，与客户端的行为无关。为了确保 ADT使用时的正确性以及出错误时定位错误，我们一般会经常判断我们的不变量是否为真。\n 例如不可变类型是不可变的，自己设计的set中不能有重复值(要求不能有重复值)等等。\n 一般导致不变量被破坏是因为表示泄露：将我们不应该被修改的内容交给了客户端去修改。总的来说，杜绝方法如下：尽量都使用不可变的数据类型；否则至少让输入的参数为不可变类型，同时做好防御性拷贝，返回新的对象，或者是把返回的字段改为不可变的。\n七.表示不变量(RI)与抽象函数(AF)\n 首先，我们做如下的两个定义。\n R：表示空间，ADT中实际存储的内容。(当然和ADT的实现密切相关)\n A：抽象空间，客户端看到和使用的值。\n AF：从R到A之间的一个对应关系(映射)，即AF：R → A。\n 当然，A中的元素都肯定在R中至少有一个对应；而R中却可能有元素不和A中的任何元素对应(即不遵守规约的内容)，因此可见AF为满射而未必为单射。注：这里的映射其实指的是部分映射，因为映射要求R中每个元素都有A来对应，因此对全体R来看的话，只要每个像都有一个原像，那就是单射了；但即使既是单射又是满射，也可能不是双射。\n RI：从R到boolean的一个映射，即RI：R → boolean，其中如果R中的元素在A中有像即表示合法，则该元素在RI的映射值为true。也可以说RI是一个条件，描述了哪些是合法值。\n 下图为一个简单的例子，实现的内容为字符集合。\n 不同的内部表示要设计不同的AF和RI，主要流程是先通过某种特定的表示方式R，来指定出RI，从而再做出相应的解释，也就是AF。\n 我们应该在开发阶段，对所有改变不变量的方法中随时检查(除了观察者之外的方法)。因此我们一般会使用assert语句。\n八.AF，RI和表示泄露安全说明的文档化\n 这些都是写在代码的注释中，而非规约中。要给出理由，证明代码并未对外泄露其内部表示，比如字段全部为private，还有对可变字段的处理等等。\n 可用表示不变量来代替一些前置条件。\n"
  },
  {
    "head": "HashMap的底层实现原理",
    "paragraphs": [
      "HashMap是最常用的Map接口的实现类型，通过存储键值对的方式，来表示两个集合的映射关系。",
      "一、构造方法",
      "HashMap有四个构造方法",
      "HashMap() //无参构造方法",
      "HashMap(int initialCapacity) //指定初始容量的构造方法",
      "HashMap(int initialCapacity, float loadFactor) //指定初始容量和负载因子",
      "HashMap(Map<? extends K,? extends V> m) //指定集合，转化为HashMap",
      "HashMap默认初始容量为16，HashMap的扩容十分耗时，如果能提前知道容量尽量提前设置。扩容时会将容量翻倍。",
      "二、数据结构",
      "HashMap的主要数据结构是哈希表，用“拉链法”实现。",
      "哈希表是一组链表的数组。以内置静态类Entry作为结点，Entry的属性有 hash，key，value，next",
      "通过Entry.next将所有Entry连接成链表",
      "哈希表通过类型K的内置函数hashCode()，根据这个函数和容量len，可以",
      "直接确定查找值所在位置",
      "，而不需要一个个比较。这样就Entry所在的位置，直接找到数据，提升效率。",
      "三、函数实现",
      "1.get(K key)",
      "首先要寻找key的Entry，计算key.hashCode()%len，得到index，那么就在Entry[index]所在的链表中找到对应key相等的Entry,然后返回Entry中的value即可，如果没找到则返回null",
      "2.put(K key,V value)",
      "计算key.hashCode()%len，得到index，遍历Entry[index]如果找到对应的key，替换上新的value并返回原来的value。否则调用addEntry(hash,key,value,index),即给链表添加新的Entry结点",
      "三、后记",
      "在Jdk1.8中，引用了红黑树，进一步提高了HashMap的效率，HashMap的实现方式做了一些改变，数据结构的存储由数组+链表的方式，变化为数组+链表+红黑树的存储方式，但是基本思想没有改变"
    ],
    "sentences": [
      "HashMap是最常用的Map接口的实现类型",
      "通过存储键值对的方式",
      "来表示两个集合的映射关系",
      "一、构造方法",
      "HashMap有四个构造方法",
      "HashMap() //无参构造方法",
      "HashMap(int initialCapacity) //指定初始容量的构造方法",
      "HashMap(int initialCapacity, float loadFactor) //指定初始容量和负载因子",
      "HashMap(Map<? extends K,? extends V> m) //指定集合",
      "转化为HashMap",
      "HashMap默认初始容量为16",
      "HashMap的扩容十分耗时",
      "如果能提前知道容量尽量提前设置",
      "扩容时会将容量翻倍",
      "二、数据结构",
      "HashMap的主要数据结构是哈希表，用“拉链法”实现",
      "哈希表是一组链表的数组",
      "以内置静态类Entry作为结点",
      "Entry的属性有 hash",
      "key",
      "value",
      "next",
      "通过Entry.next将所有Entry连接成链表",
      "哈希表通过类型K的内置函数hashCode()",
      "根据这个函数和容量len",
      "可以",
      "直接确定查找值所在位置",
      "，而不需要一个个比较",
      "这样就Entry所在的位置，直接找到数据，提升效率",
      "三、函数实现",
      "1.get(K key)",
      "首先要寻找key的Entry",
      "计算key.hashCode()%len",
      "得到index",
      "那么就在Entry[index]所在的链表中找到对应key相等的Entry,然后返回Entry中的value即可",
      "如果没找到则返回null",
      "2.put(K key,V value)",
      "计算key.hashCode()%len",
      "得到index",
      "遍历Entry[index]如果找到对应的key",
      "替换上新的value并返回原来的value",
      "否则调用addEntry(hash,key,value,index),即给链表添加新的Entry结点",
      "三、后记",
      "在Jdk1.8中",
      "引用了红黑树",
      "进一步提高了HashMap的效率",
      "HashMap的实现方式做了一些改变",
      "数据结构的存储由数组+链表的方式",
      "变化为数组+链表+红黑树的存储方式",
      "但是基本思想没有改变"
    ],
    "codes": [],
    "date": "2021-06-30",
    "text": "HashMap是最常用的Map接口的实现类型，通过存储键值对的方式，来表示两个集合的映射关系。\n一、构造方法\nHashMap有四个构造方法\nHashMap() //无参构造方法\nHashMap(int initialCapacity) //指定初始容量的构造方法\nHashMap(int initialCapacity, float loadFactor) //指定初始容量和负载因子\nHashMap(Map<? extends K,? extends V> m) //指定集合，转化为HashMap\nHashMap默认初始容量为16，HashMap的扩容十分耗时，如果能提前知道容量尽量提前设置。扩容时会将容量翻倍。\n二、数据结构\nHashMap的主要数据结构是哈希表，用“拉链法”实现。\n哈希表是一组链表的数组。以内置静态类Entry作为结点，Entry的属性有 hash，key，value，next\n通过Entry.next将所有Entry连接成链表\n哈希表通过类型K的内置函数hashCode()，根据这个函数和容量len，可以\n直接确定查找值所在位置\n，而不需要一个个比较。这样就Entry所在的位置，直接找到数据，提升效率。\n三、函数实现\n1.get(K key)\n首先要寻找key的Entry，计算key.hashCode()%len，得到index，那么就在Entry[index]所在的链表中找到对应key相等的Entry,然后返回Entry中的value即可，如果没找到则返回null\n2.put(K key,V value)\n计算key.hashCode()%len，得到index，遍历Entry[index]如果找到对应的key，替换上新的value并返回原来的value。否则调用addEntry(hash,key,value,index),即给链表添加新的Entry结点\n三、后记\n在Jdk1.8中，引用了红黑树，进一步提高了HashMap的效率，HashMap的实现方式做了一些改变，数据结构的存储由数组+链表的方式，变化为数组+链表+红黑树的存储方式，但是基本思想没有改变\n"
  },
  {
    "head": "哈工大——软件构造 广度搜索",
    "paragraphs": [
      "在Lab1实验三中对人际关系的搜索中需要使用广度搜索。由于Java中没有提供现成的队列，我对当时的Person类额外添加了两个属性，一个是是否已经访问的标志 isVisited和用于广度遍历时记录层数的length",
      "手写了一个很简单的队列",
      "public void Offer(Person name) {",
      "QueueList.add(name);",
      "return QueueList.remove(0);",
      "这里使用了动态数组，所以入队操作直接使用add，加到数组尾部而pop是将队头元素抛出所以用remove（0）实现。"
    ],
    "sentences": [
      "在Lab1实验三中对人际关系的搜索中需要使用广度搜索",
      "由于Java中没有提供现成的队列",
      "我对当时的Person类额外添加了两个属性",
      "一个是是否已经访问的标志 isVisited和用于广度遍历时记录层数的length",
      "手写了一个很简单的队列",
      "public void Offer(Person name) {",
      "QueueList.add(name);return QueueList.remove(0);这里使用了动态数组",
      "所以入队操作直接使用add",
      "加到数组尾部而pop是将队头元素抛出所以用remove（0）实现"
    ],
    "codes": [
      "package P3;",
      "import java.util.*;",
      "public class Person {",
      "public int length;",
      "public String name;",
      "public boolean isVisited;",
      "public Listneighborlist;",
      "public Person(String name) {",
      "this.name = name;",
      "length = 0;",
      "isVisited = false;",
      "neighborlist = new ArrayList();",
      "package P3;",
      "import java.util.*;",
      "public class MyQueue {",
      "public List QueueList;",
      "public MyQueue(){",
      "QueueList = new ArrayList();",
      "public Person Poll() {",
      "if(QueueList.isEmpty()) {",
      "return null;"
    ],
    "date": "2021-06-30",
    "text": "在Lab1实验三中对人际关系的搜索中需要使用广度搜索。由于Java中没有提供现成的队列，我对当时的Person类额外添加了两个属性，一个是是否已经访问的标志 isVisited和用于广度遍历时记录层数的length\n手写了一个很简单的队列\npublic void Offer(Person name) {\nQueueList.add(name);\nreturn QueueList.remove(0);\n这里使用了动态数组，所以入队操作直接使用add，加到数组尾部而pop是将队头元素抛出所以用remove（0）实现。\n"
  },
  {
    "head": "软件构造---关于list",
    "paragraphs": [
      "已知LinkedList和ArrayList均实现了List接口",
      "二者实现结构不同arraylist是基于数组，linkedlist是基于链表",
      "对于随机访问get和set，ArrayList优于LinkedList，因为ArrayList可以随机定位，而LinkedList要移动指针一步一步的移动到节点处。",
      "同时对于add和remove方法，链表的明显比数组有优势的多。",
      "对于get，由于数组可以随机访存，链表是顺序的，所以get方法ArrayList时间开销较小。",
      "另外arraylist的初始化时默认10容量，而linkedlist默认初始化为空。",
      "综上，如果对list有较多的增删操作那么优先选用linkedlist，如果只是访问较多的话，那么arraylist优势较大。不过我一般都直接用arraylist。。"
    ],
    "sentences": [
      "已知LinkedList和ArrayList均实现了List接口",
      "二者实现结构不同arraylist是基于数组",
      "linkedlist是基于链表",
      "对于随机访问get和set",
      "ArrayList优于LinkedList",
      "因为ArrayList可以随机定位",
      "而LinkedList要移动指针一步一步的移动到节点处",
      "同时对于add和remove方法，链表的明显比数组有优势的多",
      "对于get",
      "由于数组可以随机访存",
      "链表是顺序的",
      "所以get方法ArrayList时间开销较小",
      "另外arraylist的初始化时默认10容量",
      "而linkedlist默认初始化为空",
      "综上",
      "如果对list有较多的增删操作那么优先选用linkedlist",
      "如果只是访问较多的话",
      "那么arraylist优势较大",
      "不过我一般都直接用arraylist"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "已知LinkedList和ArrayList均实现了List接口\n二者实现结构不同arraylist是基于数组，linkedlist是基于链表\n对于随机访问get和set，ArrayList优于LinkedList，因为ArrayList可以随机定位，而LinkedList要移动指针一步一步的移动到节点处。\n同时对于add和remove方法，链表的明显比数组有优势的多。\n对于get，由于数组可以随机访存，链表是顺序的，所以get方法ArrayList时间开销较小。\n另外arraylist的初始化时默认10容量，而linkedlist默认初始化为空。\n综上，如果对list有较多的增删操作那么优先选用linkedlist，如果只是访问较多的话，那么arraylist优势较大。不过我一般都直接用arraylist。。\n"
  },
  {
    "head": "哈工大——软件构造 关于迭代器Iterator",
    "paragraphs": [
      "哈工大——软件构造",
      "关于迭代器Iterator",
      "迭代器Iterator提供了遍历集合类的方法，主要用法为：",
      "Iterator< Integer > it = mylist.iterator.",
      "声明一个迭代器",
      "遍历的时候基本格式为",
      "while(it.hasNext())",
      "Integer i = it.next();",
      "需要使用迭代器的时候为：",
      "遍历时删除元素",
      "由于arraylist每次遍历的时候会去判断该集合是否被修改过，调用的方法是checkForComodification()。 如果被修改会抛出ConcurrentModificationException异常。机制主要是通过维护2个变量来实现，modCount记录了修改次数，expectedModCount记录期望修改次数。 通过iterator.remove()进行的删除操作，会同时修改modCount、ConcurrentModificationException; 而通过list.remove(object/index)，则只会修改modCount。 这也是fast-fail机制。",
      "而迭代器里面的删除同步了expectedModCount和modCount这两个值，所以不会报错。",
      "但是，需要注意的是，在使用迭代器一边遍历一边删除同时进行增加时，还是会报错，抛出ConcurrentModificationException异常，这里我个人的解决方案是在遍历过程中设置一个addflag变量，如果遍历过程中会有新元素加入，那么先记录数值并设置addflag为true，在遍历完成后再根据addflag决定是否向集合类中增加相应元素。"
    ],
    "sentences": [
      "哈工大——软件构造",
      "关于迭代器Iterator",
      "迭代器Iterator提供了遍历集合类的方法",
      "主要用法为：Iterator< Integer > it = mylist.iterator.声明一个迭代器",
      "遍历的时候基本格式为",
      "while(it.hasNext())",
      "Integer i = it.next();需要使用迭代器的时候为：遍历时删除元素",
      "由于arraylist每次遍历的时候会去判断该集合是否被修改过",
      "调用的方法是checkForComodification()",
      " 如果被修改会抛出ConcurrentModificationException异常",
      "机制主要是通过维护2个变量来实现",
      "modCount记录了修改次数",
      "expectedModCount记录期望修改次数",
      " 通过iterator.remove()进行的删除操作",
      "会同时修改modCount、ConcurrentModificationException; 而通过list.remove(object/index)",
      "则只会修改modCount",
      " 这也是fast-fail机制",
      "而迭代器里面的删除同步了expectedModCount和modCount这两个值",
      "所以不会报错",
      "但是",
      "需要注意的是",
      "在使用迭代器一边遍历一边删除同时进行增加时",
      "还是会报错",
      "抛出ConcurrentModificationException异常",
      "这里我个人的解决方案是在遍历过程中设置一个addflag变量",
      "如果遍历过程中会有新元素加入",
      "那么先记录数值并设置addflag为true",
      "在遍历完成后再根据addflag决定是否向集合类中增加相应元素"
    ],
    "codes": [],
    "date": "2021-06-30",
    "text": "哈工大——软件构造\n关于迭代器Iterator\n迭代器Iterator提供了遍历集合类的方法，主要用法为：\nIterator< Integer > it = mylist.iterator.\n声明一个迭代器\n遍历的时候基本格式为\nwhile(it.hasNext())\nInteger i = it.next();\n需要使用迭代器的时候为：\n遍历时删除元素\n由于arraylist每次遍历的时候会去判断该集合是否被修改过，调用的方法是checkForComodification()。 如果被修改会抛出ConcurrentModificationException异常。机制主要是通过维护2个变量来实现，modCount记录了修改次数，expectedModCount记录期望修改次数。 通过iterator.remove()进行的删除操作，会同时修改modCount、ConcurrentModificationException; 而通过list.remove(object/index)，则只会修改modCount。 这也是fast-fail机制。\n而迭代器里面的删除同步了expectedModCount和modCount这两个值，所以不会报错。\n但是，需要注意的是，在使用迭代器一边遍历一边删除同时进行增加时，还是会报错，抛出ConcurrentModificationException异常，这里我个人的解决方案是在遍历过程中设置一个addflag变量，如果遍历过程中会有新元素加入，那么先记录数值并设置addflag为true，在遍历完成后再根据addflag决定是否向集合类中增加相应元素。\n"
  },
  {
    "head": "有关抽象类的感悟",
    "paragraphs": [
      "概念：",
      "在面向对象方法中，抽象类主要用来进行类型隐藏。构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的；",
      "通过从这个抽象体派生，也可扩展此模块的行为功能。为了能够实现面向对象设计的一个最核心的原则OCP(Open-Closed Principle)，抽象类是其中的关键所在。",
      "抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。",
      "抽象类的特点：",
      "1，抽象方法一定在抽象类中。",
      "2，抽象方法和抽象类都必须被abstract关键字修饰。",
      "3，抽象类不可以用new创建对象。因为调用抽象方法没意义。",
      "4，抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。",
      "如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。",
      "抽象类比一般类多个了抽象函数。就是在类中可以定义抽象方法。",
      "抽象类不可以实例化。",
      "特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象。",
      "abstract 关键字，和哪些关键字不能共存。",
      "final：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。",
      "private: 抽象类中的私有的抽象方法，不被子类所知，就无法被复写。",
      "而抽象方法出现的就是需要被复写。",
      "static：如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了。",
      "可是抽象方法运行没意义。"
    ],
    "sentences": [
      "概念：在面向对象方法中，抽象类主要用来进行类型隐藏",
      "构造出一个固定的一组行为的抽象描述",
      "但是这组行为却能够有任意个可能的具体实现方式",
      "这个抽象描述就是抽象类",
      "而这一组任意个可能的具体实现则表现为所有可能的派生类",
      "模块可以操作一个抽象体",
      "由于模块依赖于一个固定的抽象体",
      "因此它可以是不允许修改的；通过从这个抽象体派生",
      "也可扩展此模块的行为功能",
      "为了能够实现面向对象设计的一个最核心的原则OCP(Open-Closed Principle)",
      "抽象类是其中的关键所在",
      "抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念",
      "是对一系列看上去不同",
      "但是本质上相同的具体概念的抽象",
      "抽象类的特点：1，抽象方法一定在抽象类中",
      "2，抽象方法和抽象类都必须被abstract关键字修饰",
      "3，抽象类不可以用new创建对象",
      "因为调用抽象方法没意义",
      "4",
      "抽象类中的抽象方法要被使用",
      "必须由子类复写起所有的抽象方法后",
      "建立子类对象调用",
      "如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类",
      "抽象类比一般类多个了抽象函数",
      "就是在类中可以定义抽象方法",
      "抽象类不可以实例化",
      "特殊：抽象类中可以不定义抽象方法",
      "这样做仅仅是不让该类建立对象",
      "abstract 关键字，和哪些关键字不能共存",
      "final：被final修饰的类不能有子类",
      "而被abstract修饰的类一定是一个父类",
      "private: 抽象类中的私有的抽象方法",
      "不被子类所知",
      "就无法被复写",
      "而抽象方法出现的就是需要被复写",
      "static：如果static可以修饰抽象方法",
      "那么连对象都省了",
      "直接类名调用就可以了",
      "可是抽象方法运行没意义"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "概念：\n在面向对象方法中，抽象类主要用来进行类型隐藏。构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的；\n通过从这个抽象体派生，也可扩展此模块的行为功能。为了能够实现面向对象设计的一个最核心的原则OCP(Open-Closed Principle)，抽象类是其中的关键所在。\n抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。\n抽象类的特点：\n1，抽象方法一定在抽象类中。\n2，抽象方法和抽象类都必须被abstract关键字修饰。\n3，抽象类不可以用new创建对象。因为调用抽象方法没意义。\n4，抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。\n如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。\n抽象类比一般类多个了抽象函数。就是在类中可以定义抽象方法。\n抽象类不可以实例化。\n特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象。\nabstract 关键字，和哪些关键字不能共存。\nfinal：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。\nprivate: 抽象类中的私有的抽象方法，不被子类所知，就无法被复写。\n而抽象方法出现的就是需要被复写。\nstatic：如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了。\n可是抽象方法运行没意义。\n"
  },
  {
    "head": "有关lsp的思考",
    "paragraphs": [
      "含义：只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，有子类出现的地方，父类未必就能适应。",
      "*子类型可以增加方法，但不可删",
      "子类必须完全实现父类的方法，在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了里氏替换原则。",
      "*子类型中重写的方法必须有相同或子类型的返回值",
      "*子类型中重写的方法必须使用同样类型的参数",
      "*子类型中重写的方法不能抛出额外的异常",
      "同时，这也可以体现在方法的规约上面。",
      "Same or stronger invariants 更强的不变量",
      "Same or weaker preconditions 更弱的前置条件",
      "Same or stronger postconditions 更强的后置条件",
      "采用里氏替换原则的目的就是增强程序的健壮性，版本升级是也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。",
      "基本介绍：",
      "1）如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明的使用其子类的对象。",
      "2）在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。",
      "3）里氏替换原则原则指出，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。",
      "理解：即是在业务处理过程中，我们在用子类继承父类时，尽量不要重写父类中的方法，如果迫不得己必须重写，可采用聚合，组合和依赖等方法。",
      "总结一下，即是：",
      "继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合度，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。",
      "那么如何解决：里氏替换原则"
    ],
    "sentences": [
      "含义：只要父类能出现的地方子类就可以出现",
      "而且替换为子类也不会产生任何错误或异常",
      "使用者可能根本就不需要知道是父类还是子类",
      "但是，有子类出现的地方，父类未必就能适应",
      "*子类型可以增加方法，但不可删",
      "子类必须完全实现父类的方法",
      "在类中调用其他类时务必要使用父类或接口",
      "如果不能使用父类或接口",
      "则说明类的设计已经违背了里氏替换原则",
      "*子类型中重写的方法必须有相同或子类型的返回值",
      "*子类型中重写的方法必须使用同样类型的参数",
      "*子类型中重写的方法不能抛出额外的异常",
      "同时，这也可以体现在方法的规约上面",
      "Same or stronger invariants 更强的不变量",
      "Same or weaker preconditions 更弱的前置条件",
      "Same or stronger postconditions 更强的后置条件",
      "采用里氏替换原则的目的就是增强程序的健壮性",
      "版本升级是也可以保持非常好的兼容性",
      "即使增加子类，原有的子类还可以继续运行",
      "在实际项目中",
      "每个子类对应不同的业务含义",
      "使用父类作为参数",
      "传递不同的子类完成不同的业务逻辑",
      "基本介绍：1）如果对每个类型为T1的对象o1",
      "都有类型为T2的对象o2",
      "使得以T1定义的所有程序P在所有的对象o1都替换成o2时",
      "程序P的行为没有发生变化",
      "那么类型T2是类型T1的子类型",
      "换句话说，所有引用基类的地方必须能透明的使用其子类的对象",
      "2）在使用继承时",
      "遵循里氏替换原则",
      "在子类中尽量不要重写父类的方法",
      "3）里氏替换原则原则指出",
      "继承实际上让两个类耦合性增强了",
      "在适当的情况下",
      "可以通过聚合",
      "组合",
      "依赖来解决问题",
      "理解：即是在业务处理过程中",
      "我们在用子类继承父类时",
      "尽量不要重写父类中的方法",
      "如果迫不得己必须重写",
      "可采用聚合",
      "组合和依赖等方法",
      "总结一下，即是：继承在给程序设计带来便利的同时，也带来了弊端",
      "比如使用继承会给程序带来侵入性",
      "程序的可移植性降低",
      "增加对象间的耦合度",
      "如果一个类被其他的类所继承",
      "则当这个类需要修改时",
      "必须考虑到所有的子类",
      "并且父类修改后",
      "所有涉及到子类的功能都有可能产生故障",
      "那么如何解决：里氏替换原则"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "含义：只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，有子类出现的地方，父类未必就能适应。\n*子类型可以增加方法，但不可删\n子类必须完全实现父类的方法，在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了里氏替换原则。\n*子类型中重写的方法必须有相同或子类型的返回值\n*子类型中重写的方法必须使用同样类型的参数\n*子类型中重写的方法不能抛出额外的异常\n同时，这也可以体现在方法的规约上面。\nSame or stronger invariants 更强的不变量\nSame or weaker preconditions 更弱的前置条件\nSame or stronger postconditions 更强的后置条件\n采用里氏替换原则的目的就是增强程序的健壮性，版本升级是也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。\n基本介绍：\n1）如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明的使用其子类的对象。\n2）在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。\n3）里氏替换原则原则指出，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。\n理解：即是在业务处理过程中，我们在用子类继承父类时，尽量不要重写父类中的方法，如果迫不得己必须重写，可采用聚合，组合和依赖等方法。\n总结一下，即是：\n继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合度，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。\n那么如何解决：里氏替换原则\n"
  },
  {
    "head": "pair的应用",
    "paragraphs": [
      "在lab3的相关问题中我发现用pair存信息比较合适。我们学习了一个相关结构配对(Pair)。配对提供了一种方便方式来处理简单的键值关联，当我们想从方法返回两个值时特别有用。",
      "在核心Java库中可以使用配对(Pair)的实现。除此之外，某些第三方库，比如Apache Commons和Vavr，已经在各自的api中公开了这个功能。",
      "核心java配对实现",
      "Pair类",
      "Pair类在javafx.util 包中，类构造函数有两个参数，键及对应值：",
      "示例描述使用Pair类实现简单Integer到String的映射。示例中getKey方法返回key对象，getValue方法返回对应值对象。",
      "AbstractMap.SimpleEntry 和 AbstractMap.SimpleImmutableEntry",
      "SimpleEntry定义在抽象类AbstractMap里面，其构造方法与Pair类似：",
      "其键和值可以通过标准的getter和setter方法获得。",
      "另外AbstractMap 类还包含一个嵌套类，表示不可变配对：SimpleImmutableEntry 类。",
      "AbstractMap.SimpleImmutableEntry entry",
      "= new AbstractMap.SimpleImmutableEntry<>(1, “one”);"
    ],
    "sentences": [
      "在lab3的相关问题中我发现用pair存信息比较合适",
      "我们学习了一个相关结构配对(Pair)",
      "配对提供了一种方便方式来处理简单的键值关联",
      "当我们想从方法返回两个值时特别有用",
      "在核心Java库中可以使用配对(Pair)的实现",
      "除此之外",
      "某些第三方库",
      "比如Apache Commons和Vavr",
      "已经在各自的api中公开了这个功能",
      "核心java配对实现",
      "Pair类",
      "Pair类在javafx.util 包中",
      "类构造函数有两个参数",
      "键及对应值：示例描述使用Pair类实现简单Integer到String的映射",
      "示例中getKey方法返回key对象",
      "getValue方法返回对应值对象",
      "AbstractMap.SimpleEntry 和 AbstractMap.SimpleImmutableEntry",
      "SimpleEntry定义在抽象类AbstractMap里面",
      "其构造方法与Pair类似：其键和值可以通过标准的getter和setter方法获得",
      "另外AbstractMap 类还包含一个嵌套类",
      "表示不可变配对：SimpleImmutableEntry 类",
      "AbstractMap.SimpleImmutableEntry entry",
      "= new AbstractMap.SimpleImmutableEntry<>(1, “one”);"
    ],
    "codes": [
      "Pair pair = new Pair<>(1, “One”);",
      "Integer key = pair.getKey();",
      "String value = pair.getValue();",
      "AbstractMap.SimpleEntry entry",
      "= new AbstractMap.SimpleEntry<>(1, “one”);",
      "Integer key = entry.getKey();",
      "String value = entry.getValue();"
    ],
    "date": "2021-07-06",
    "text": "在lab3的相关问题中我发现用pair存信息比较合适。我们学习了一个相关结构配对(Pair)。配对提供了一种方便方式来处理简单的键值关联，当我们想从方法返回两个值时特别有用。\n在核心Java库中可以使用配对(Pair)的实现。除此之外，某些第三方库，比如Apache Commons和Vavr，已经在各自的api中公开了这个功能。\n核心java配对实现\nPair类\nPair类在javafx.util 包中，类构造函数有两个参数，键及对应值：\n示例描述使用Pair类实现简单Integer到String的映射。示例中getKey方法返回key对象，getValue方法返回对应值对象。\nAbstractMap.SimpleEntry 和 AbstractMap.SimpleImmutableEntry\nSimpleEntry定义在抽象类AbstractMap里面，其构造方法与Pair类似：\n其键和值可以通过标准的getter和setter方法获得。\n另外AbstractMap 类还包含一个嵌套类，表示不可变配对：SimpleImmutableEntry 类。\nAbstractMap.SimpleImmutableEntry entry\n= new AbstractMap.SimpleImmutableEntry<>(1, “one”);\n"
  },
  {
    "head": "有关delegation的思考",
    "paragraphs": [
      "什么是委派模式？",
      "委派模式，并不属于23种经典的设计模式。但是在Spring框架源码中，它有多次体现。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。",
      "字面理解委派模式",
      "项目组，包括：项目经理A、程序员B和程序员C。目前甲方有个项目，需要完成一个xxx任务。首先甲方会直接找到项目经理A去谈这个项目，而不是直接找B和C。项目经理分析这个项目，发现需要两人合作来完成，所以将A1模块分给B，将A2模块分给C，由B和C来合作完成该项目。",
      "委派模式的主要特点",
      "干活是我(B和C)的，功劳是你的(A)。 项目经理属于渔翁得利型",
      "委派模式的其他特点",
      "①委派机制，类似于中介的功能",
      "代码实现",
      "1.甲方现在有一个项目projectA",
      "/**",
      "现在有一个项目projectA",
      "public interface IDelegate {",
      "//项目A",
      "public void projectA();",
      "2.项目经理评估后，需要两个程序员B和C来完成",
      "/**",
      "程序员B",
      "System.out.println(“程序员B完成模块A”);",
      "程序员C",
      "System.out.println(“程序员C完成模块B”);",
      "3.项目经理具体的分配过程",
      "/**",
      "项目经理A(虽然它也有工作,需要实现projectA,但是它的具体工作就是分配任务)",
      "public class ManagerA implements IDelegate{",
      "封装构造方法,来获得具体实现该需求(程序员B和C)的实例",
      "4.测试。即：分工完成后，项目具体的完成情况",
      "/**",
      "需求的完成情况",
      "public class test {",
      "public static void main(String[] args) {",
      "//1.现在甲方有一个新的需求",
      "//2.项目经理分析完后,发现需要程序员B和C来完成",
      "IDelegate exuctorB = new ProgrammerB();",
      "IDelegate exuctorC = new ProgrammerC();",
      "//3.项目经理获取到B和C的引用，然后让B和C来完成工作",
      "new ManagerA(exuctorB).projectA();",
      "new ManagerA(exuctorC).projectA();",
      "//4.工作完成",
      "//5.代码看着像是项目经理A完成的，但实际是B和C完成的。即：干活是B和C，实际功劳确实A的"
    ],
    "sentences": [
      "什么是委派模式？",
      "委派模式，并不属于23种经典的设计模式",
      "但是在Spring框架源码中，它有多次体现",
      "在委托模式中",
      "有两个对象参与处理同一个请求",
      "接受请求的对象将请求委托给另一个对象来处理",
      "字面理解委派模式",
      "项目组，包括：项目经理A、程序员B和程序员C",
      "目前甲方有个项目，需要完成一个xxx任务",
      "首先甲方会直接找到项目经理A去谈这个项目，而不是直接找B和C",
      "项目经理分析这个项目",
      "发现需要两人合作来完成",
      "所以将A1模块分给B",
      "将A2模块分给C",
      "由B和C来合作完成该项目",
      "委派模式的主要特点",
      "干活是我(B和C)的，功劳是你的(A)",
      " 项目经理属于渔翁得利型",
      "委派模式的其他特点",
      "①委派机制，类似于中介的功能",
      "代码实现",
      "1.甲方现在有一个项目projectA",
      "/**",
      "现在有一个项目projectA",
      "public interface IDelegate {",
      "//项目A",
      "public void projectA();2.项目经理评估后",
      "需要两个程序员B和C来完成",
      "/**",
      "程序员B",
      "System.out.println(“程序员B完成模块A”);程序员C",
      "System.out.println(“程序员C完成模块B”);3.项目经理具体的分配过程",
      "/**",
      "项目经理A(虽然它也有工作,需要实现projectA,但是它的具体工作就是分配任务)",
      "public class ManagerA implements IDelegate{",
      "封装构造方法,来获得具体实现该需求(程序员B和C)的实例",
      "4.测试",
      "即：分工完成后，项目具体的完成情况",
      "/**",
      "需求的完成情况",
      "public class test {",
      "public static void main(String[] args) {",
      "//1.现在甲方有一个新的需求",
      "//2.项目经理分析完后,发现需要程序员B和C来完成",
      "IDelegate exuctorB = new ProgrammerB();IDelegate exuctorC = new ProgrammerC();//3.项目经理获取到B和C的引用",
      "然后让B和C来完成工作",
      "new ManagerA(exuctorB).projectA();new ManagerA(exuctorC).projectA();//4.工作完成",
      "//5.代码看着像是项目经理A完成的，但实际是B和C完成的",
      "即：干活是B和C，实际功劳确实A的"
    ],
    "codes": [
      "   在该需求中，项目经理只起到了一个协调工作的作用，其实实际的工作是由B和C来完成的。由此可总结出委派模式的主要特点如下。\n",
      "    ②持有被委托人的引用(项目经理A可以随意使唤B和C)\n\n    ③不关心过程，只关心结果(代理模式：关心的是过程，不关心结果)\n",
      "public class ProgrammerB implements IDelegate{",
      "@Override",
      "public void projectA() {",
      "public class ProgrammerC implements IDelegate{",
      "@Override",
      "public void projectA() {",
      "IDelegate iDelegate;",
      "public ManagerA(IDelegate iDelegate) {",
      "this.iDelegate = iDelegate;",
      "@Override",
      "public void projectA() {",
      "this.iDelegate.projectA();"
    ],
    "date": "2021-07-07",
    "text": "什么是委派模式？\n委派模式，并不属于23种经典的设计模式。但是在Spring框架源码中，它有多次体现。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。\n字面理解委派模式\n项目组，包括：项目经理A、程序员B和程序员C。目前甲方有个项目，需要完成一个xxx任务。首先甲方会直接找到项目经理A去谈这个项目，而不是直接找B和C。项目经理分析这个项目，发现需要两人合作来完成，所以将A1模块分给B，将A2模块分给C，由B和C来合作完成该项目。\n委派模式的主要特点\n干活是我(B和C)的，功劳是你的(A)。 项目经理属于渔翁得利型\n委派模式的其他特点\n①委派机制，类似于中介的功能\n代码实现\n1.甲方现在有一个项目projectA\n/**\n现在有一个项目projectA\npublic interface IDelegate {\n//项目A\npublic void projectA();\n2.项目经理评估后，需要两个程序员B和C来完成\n/**\n程序员B\nSystem.out.println(“程序员B完成模块A”);\n程序员C\nSystem.out.println(“程序员C完成模块B”);\n3.项目经理具体的分配过程\n/**\n项目经理A(虽然它也有工作,需要实现projectA,但是它的具体工作就是分配任务)\npublic class ManagerA implements IDelegate{\n封装构造方法,来获得具体实现该需求(程序员B和C)的实例\n4.测试。即：分工完成后，项目具体的完成情况\n/**\n需求的完成情况\npublic class test {\npublic static void main(String[] args) {\n//1.现在甲方有一个新的需求\n//2.项目经理分析完后,发现需要程序员B和C来完成\nIDelegate exuctorB = new ProgrammerB();\nIDelegate exuctorC = new ProgrammerC();\n//3.项目经理获取到B和C的引用，然后让B和C来完成工作\nnew ManagerA(exuctorB).projectA();\nnew ManagerA(exuctorC).projectA();\n//4.工作完成\n//5.代码看着像是项目经理A完成的，但实际是B和C完成的。即：干活是B和C，实际功劳确实A的\n"
  },
  {
    "head": "ADT,AF,RI,REP EXPOSURE",
    "paragraphs": [
      "ADT介绍",
      "抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。",
      "ADT具有三个特性，即表示泄漏、抽象函数AF以及表示不变量RI，在我看来，这三个特性都是为不变性所服务的。其中，表示泄漏保证了ADT的内部表示不会被客户端其它代码所篡改，影响不变性，其次，表示不变量RI，对ADT的内部表示进行限制，获取到希望的表示信息，即程序面对的表示，通过抽象函数AF得到客户端所见到的表示。",
      "AF指的是抽象函数，抽象函数为表示值空间到抽象值空间的一个映射",
      "R:面向实现的表示值空间",
      "A:面向规格说明的抽象值空间",
      "R ==>A 一定是满射,但不一定是单射.",
      "抽象函数即一个R到A的映射: AF : R → A",
      "RI指的是表示不变性。\"表示\"即ADT中的各个属性;",
      "而表示不变性即这些属性必须保持的性质,如年龄不能为负数, 概率不能大于1.",
      "checkRep",
      "RI指的是检查不变性，检查不变性就是确定RI是否还成立.",
      "在实现中采用断言技术assert来检查不变性是否保持，可以更早地捕获bug",
      "避免表示泄露的方法",
      "表示泄露: 指的是外部代码能直接改变(不借用类中的mutator方法)类中的属性.",
      "我们需要注意三个关键词：private、final、immutable，所有的操作均为了赋予field这三个属性。",
      "1.所有观察ADT属性的操作全都用observor来实现，这没什么好说的。",
      "2.由于现在写的ADT都较为简单，private和final这两个前缀能加就加上。",
      "3.immutabl的field由于是被数据类型本身决定，所以需要会使用防御式拷贝来保护。"
    ],
    "sentences": [
      "ADT介绍",
      "抽象数据类型（Abstract Data Type",
      "ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型",
      "抽象数据类型是间接定义的",
      "通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）",
      "ADT具有三个特性",
      "即表示泄漏、抽象函数AF以及表示不变量RI",
      "在我看来",
      "这三个特性都是为不变性所服务的",
      "其中",
      "表示泄漏保证了ADT的内部表示不会被客户端其它代码所篡改",
      "影响不变性",
      "其次",
      "表示不变量RI",
      "对ADT的内部表示进行限制",
      "获取到希望的表示信息",
      "即程序面对的表示",
      "通过抽象函数AF得到客户端所见到的表示",
      "AF指的是抽象函数",
      "抽象函数为表示值空间到抽象值空间的一个映射",
      "R:面向实现的表示值空间",
      "A:面向规格说明的抽象值空间",
      "R ==>A 一定是满射,但不一定是单射.抽象函数即一个R到A的映射: AF : R → A",
      "RI指的是表示不变性",
      "\"表示\"即ADT中的各个属性;而表示不变性即这些属性必须保持的性质,如年龄不能为负数, 概率不能大于1.checkRep",
      "RI指的是检查不变性",
      "检查不变性就是确定RI是否还成立.在实现中采用断言技术assert来检查不变性是否保持",
      "可以更早地捕获bug",
      "避免表示泄露的方法",
      "表示泄露: 指的是外部代码能直接改变(不借用类中的mutator方法)类中的属性.我们需要注意三个关键词：private、final、immutable",
      "所有的操作均为了赋予field这三个属性",
      "1.所有观察ADT属性的操作全都用observor来实现",
      "这没什么好说的",
      "2.由于现在写的ADT都较为简单",
      "private和final这两个前缀能加就加上",
      "3.immutabl的field由于是被数据类型本身决定",
      "所以需要会使用防御式拷贝来保护"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "ADT介绍\n抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。\nADT具有三个特性，即表示泄漏、抽象函数AF以及表示不变量RI，在我看来，这三个特性都是为不变性所服务的。其中，表示泄漏保证了ADT的内部表示不会被客户端其它代码所篡改，影响不变性，其次，表示不变量RI，对ADT的内部表示进行限制，获取到希望的表示信息，即程序面对的表示，通过抽象函数AF得到客户端所见到的表示。\nAF指的是抽象函数，抽象函数为表示值空间到抽象值空间的一个映射\nR:面向实现的表示值空间\nA:面向规格说明的抽象值空间\nR ==>A 一定是满射,但不一定是单射.\n抽象函数即一个R到A的映射: AF : R → A\nRI指的是表示不变性。\"表示\"即ADT中的各个属性;\n而表示不变性即这些属性必须保持的性质,如年龄不能为负数, 概率不能大于1.\ncheckRep\nRI指的是检查不变性，检查不变性就是确定RI是否还成立.\n在实现中采用断言技术assert来检查不变性是否保持，可以更早地捕获bug\n避免表示泄露的方法\n表示泄露: 指的是外部代码能直接改变(不借用类中的mutator方法)类中的属性.\n我们需要注意三个关键词：private、final、immutable，所有的操作均为了赋予field这三个属性。\n1.所有观察ADT属性的操作全都用observor来实现，这没什么好说的。\n2.由于现在写的ADT都较为简单，private和final这两个前缀能加就加上。\n3.immutabl的field由于是被数据类型本身决定，所以需要会使用防御式拷贝来保护。\n"
  },
  {
    "head": "HIT软件构造1~3章期末复习笔记",
    "paragraphs": [
      "第一讲：",
      "软件构造的多维度视图及质量目标",
      "·软件构造的多维度视图：",
      "按构造对象划分：代码、构建视图（Code or Component level）",
      "·软件构造的阶段划分、各阶段的构造活动：",
      "语法树、流程图：B+C+M",
      "版本控制工具：B+C+P",
      "UML图：R+C+P",
      "·内部外部质量指标：",
      "外部质量指标：",
      "正确性（最重要）、健壮性、可扩展性、可复用性 （兼容性、可移植性、易用性）",
      "内部质量指标：",
      "LOC（line of code）、可读性、可理解性、规模、耦合度（低）、内聚度（高）、（圈）复杂度",
      "第三讲：",
      "软件构造过程与配置管理",
      "·SCM（软件配置管理）——追踪、控制软件的变化",
      "SCI：软件配置项：软件发生变化的基本单元（形式：文件）",
      "Baseline：基线：软件持续变化过程中的“稳定时刻”",
      "CMDB：配置管理数据库：存储软件的各配置项随时间发生变化的信息+基线",
      "Versioning：版本控制",
      "·VCS（版本控制系统）",
      "Local VCS：本地版本控制系统：仓库存储于开发者本地机器，无法共享和合作",
      "Centralized VCS：集中式版本控制系统：仓库存储于独立的服务器，支持多开发者间的协作",
      "Distributed VCS：分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器",
      "·GIt",
      "基本结构：",
      "Git repository ：dictionary 本地CMDB",
      "Working dictionary 工作目录（本地文件系统）",
      "Staging area 暂存区（隔离工作目录与git仓库）",
      "基本指令：",
      "git pull origin master （从远程仓库pull）",
      "git clone ...... .git （克隆到本地仓库）",
      "git checkout change （切换分支）",
      "git checkout -b change （新建并切换到分支change）",
      "git merge change （将change分支与当前分支合并）",
      "每个commit指向一个父亲；",
      "合并：一个commit指向多个父亲",
      "分支：多个commit指向一个父亲"
    ],
    "sentences": [
      "第一讲：软件构造的多维度视图及质量目标",
      "·软件构造的多维度视图：按构造对象划分：代码、构建视图（Code or Component level）",
      "·软件构造的阶段划分、各阶段的构造活动：语法树、流程图：B+C+M",
      "版本控制工具：B+C+P",
      "UML图：R+C+P",
      "·内部外部质量指标：外部质量指标：正确性（最重要）、健壮性、可扩展性、可复用性 （兼容性、可移植性、易用性）",
      "内部质量指标：LOC（line of code）、可读性、可理解性、规模、耦合度（低）、内聚度（高）、（圈）复杂度",
      "第三讲：软件构造过程与配置管理",
      "·SCM（软件配置管理）——追踪、控制软件的变化",
      "SCI：软件配置项：软件发生变化的基本单元（形式：文件）",
      "Baseline：基线：软件持续变化过程中的“稳定时刻”",
      "CMDB：配置管理数据库：存储软件的各配置项随时间发生变化的信息+基线",
      "Versioning：版本控制",
      "·VCS（版本控制系统）",
      "Local VCS：本地版本控制系统：仓库存储于开发者本地机器",
      "无法共享和合作",
      "Centralized VCS：集中式版本控制系统：仓库存储于独立的服务器",
      "支持多开发者间的协作",
      "Distributed VCS：分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器",
      "·GIt",
      "基本结构：Git repository ：dictionary 本地CMDB",
      "Working dictionary 工作目录（本地文件系统）",
      "Staging area 暂存区（隔离工作目录与git仓库）",
      "基本指令：git pull origin master （从远程仓库pull）",
      "git clone ...... .git （克隆到本地仓库）",
      "git checkout change （切换分支）",
      "git checkout -b change （新建并切换到分支change）",
      "git merge change （将change分支与当前分支合并）",
      "每个commit指向一个父亲；合并：一个commit指向多个父亲",
      "分支：多个commit指向一个父亲"
    ],
    "codes": [
      "git add .（git add *）",
      "git commit -m “version”",
      "git push origin master"
    ],
    "date": "2021-07-06",
    "text": "第一讲：\n软件构造的多维度视图及质量目标\n·软件构造的多维度视图：\n按构造对象划分：代码、构建视图（Code or Component level）\n·软件构造的阶段划分、各阶段的构造活动：\n语法树、流程图：B+C+M\n版本控制工具：B+C+P\nUML图：R+C+P\n·内部外部质量指标：\n外部质量指标：\n正确性（最重要）、健壮性、可扩展性、可复用性 （兼容性、可移植性、易用性）\n内部质量指标：\nLOC（line of code）、可读性、可理解性、规模、耦合度（低）、内聚度（高）、（圈）复杂度\n第三讲：\n软件构造过程与配置管理\n·SCM（软件配置管理）——追踪、控制软件的变化\nSCI：软件配置项：软件发生变化的基本单元（形式：文件）\nBaseline：基线：软件持续变化过程中的“稳定时刻”\nCMDB：配置管理数据库：存储软件的各配置项随时间发生变化的信息+基线\nVersioning：版本控制\n·VCS（版本控制系统）\nLocal VCS：本地版本控制系统：仓库存储于开发者本地机器，无法共享和合作\nCentralized VCS：集中式版本控制系统：仓库存储于独立的服务器，支持多开发者间的协作\nDistributed VCS：分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器\n·GIt\n基本结构：\nGit repository ：dictionary 本地CMDB\nWorking dictionary 工作目录（本地文件系统）\nStaging area 暂存区（隔离工作目录与git仓库）\n基本指令：\ngit pull origin master （从远程仓库pull）\ngit clone ...... .git （克隆到本地仓库）\ngit checkout change （切换分支）\ngit checkout -b change （新建并切换到分支change）\ngit merge change （将change分支与当前分支合并）\n每个commit指向一个父亲；\n合并：一个commit指向多个父亲\n分支：多个commit指向一个父亲\n"
  },
  {
    "head": "HIT软件构造期末复习笔记第2,12章",
    "paragraphs": [
      "第二讲： 软件测试与测试优先的编程",
      "·黑盒测试：对程序外部表现出来的行为进行测试；用于检查代码的功能，不关注内部的实现细节——检查是否符合规约",
      "等价类划分：针对每个输入数据需要满足的约束条件，划分等价类；从等价类中导出测试用例",
      "边界值分析：对等价类划分的一个补充（在等价类划分时将边界值作为等价类之一加入考虑）",
      "测试用例：输入+执行条件+期望结果",
      "·测试覆盖度：",
      "（1）笛卡尔积：全覆盖",
      "（2）每个维度的每个取值至少被一个测试用例覆盖一次即可",
      "代码覆盖度：",
      "函数覆盖、语句覆盖、分支覆盖、条件覆盖、路径覆盖",
      "覆盖度标准（100%语句覆盖，90%路径覆盖）",
      "·以注释的形式撰写测试策略：",
      "·TDD：",
      "（1）先写spec （2）再写符合spec的测试用例 （3）写代码、执行测试、有问题再改、再执行测试用例，直到通过它",
      "·Junit assert xxx：",
      "第十二讲： 面向正确性与健壮性的软件构造",
      "·健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度——倾向于容错",
      "·正确性：程序按照spec加以执行的能力（最重要的质量指标）——倾向于直接报错",
      "可靠性 = 健壮性 + 正确性",
      "·Error/Runtime异常",
      "Error：内部错误，一旦发生，想办法让程序优雅的结束",
      "Exception：异常：自己程序导致的问题，可以捕获，可以处理",
      "（1）将错误信息传递给上层调用者，并报告“案发现场”的信息",
      "（2）Return外的第二种退出途径",
      "（3）若找不到异常处理程序，整个系统完全退出",
      "（4）分为运行时异常和其他异常",
      "运行时异常：程序员在代码中处理不当造成，可避免",
      "其他异常：由外部原因造成，无法完全避免",
      "·Checked异常，Unchecked异常",
      "Checked异常：必须捕获并指定错误处理器handle，否则编译无法通过",
      "·Checked异常处理机制",
      "（1）使用throws声明异常",
      "方法应throws的异常：",
      "该方法调用的其他函数抛出的checked exception",
      "当前方法检测并使用throws抛出的checked exception",
      "若无handler来处理抛出的checked exception，程序就终止执行",
      "（2）使用throw抛出异常：",
      "1.找到一个能表达错误的Exception类/或者构造出一个新的Exception类",
      "2.构造Exception类的一个实例，将错误信息写入",
      "3.抛出错误（throw）",
      "4.一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码",
      "·自定义异常类",
      "Finally关键字：无论程序是否碰到异常，finally关键字都将被执行",
      "·断言",
      "在开发阶段的代码中嵌入，检验某些假设是否成立。若成立则表明程序运行正常，否则表明存在错误",
      "断言即是对代码中程序员所做的假设的文档化，不会影响程序的性能",
      "形式：",
      "所构造的message将在发生错误时显示给用户，便于快速发现错误所在；实际运行阶段，不再使用断言！",
      "出现AssertionError即表示内部某些假设被违反了",
      "可使用assert的情况：",
      "内部不变量、表示不变量、控制流不变量（switch-case）、方法的前置、后置条件",
      "断言只检查程序内部的状态是否符合规约，断言一旦false，程序就停止执行，外部错误（不受自己控制）要使用Exception机制去处理",
      "·防御式编程的基本思路：",
      "（1）最好的防御就是不要引入bug",
      "（2）若无法避免，则将bug限制在最小范围内；限定在一个方法内部，不扩散",
      "（3）Fail fast"
    ],
    "sentences": [
      "第二讲： 软件测试与测试优先的编程",
      "·黑盒测试：对程序外部表现出来的行为进行测试；用于检查代码的功能",
      "不关注内部的实现细节——检查是否符合规约",
      "等价类划分：针对每个输入数据需要满足的约束条件",
      "划分等价类；从等价类中导出测试用例",
      "边界值分析：对等价类划分的一个补充（在等价类划分时将边界值作为等价类之一加入考虑）",
      "测试用例：输入+执行条件+期望结果",
      "·测试覆盖度：（1）笛卡尔积：全覆盖",
      "（2）每个维度的每个取值至少被一个测试用例覆盖一次即可",
      "代码覆盖度：函数覆盖、语句覆盖、分支覆盖、条件覆盖、路径覆盖",
      "覆盖度标准（100%语句覆盖，90%路径覆盖）",
      "·以注释的形式撰写测试策略：·TDD：（1）先写spec （2）再写符合spec的测试用例 （3）写代码、执行测试、有问题再改、再执行测试用例",
      "直到通过它",
      "·Junit assert xxx：第十二讲： 面向正确性与健壮性的软件构造",
      "·健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度——倾向于容错",
      "·正确性：程序按照spec加以执行的能力（最重要的质量指标）——倾向于直接报错",
      "可靠性 = 健壮性 + 正确性",
      "·Error/Runtime异常",
      "Error：内部错误，一旦发生，想办法让程序优雅的结束",
      "Exception：异常：自己程序导致的问题",
      "可以捕获",
      "可以处理",
      "（1）将错误信息传递给上层调用者，并报告“案发现场”的信息",
      "（2）Return外的第二种退出途径",
      "（3）若找不到异常处理程序，整个系统完全退出",
      "（4）分为运行时异常和其他异常",
      "运行时异常：程序员在代码中处理不当造成，可避免",
      "其他异常：由外部原因造成，无法完全避免",
      "·Checked异常，Unchecked异常",
      "Checked异常：必须捕获并指定错误处理器handle",
      "否则编译无法通过",
      "·Checked异常处理机制",
      "（1）使用throws声明异常",
      "方法应throws的异常：该方法调用的其他函数抛出的checked exception",
      "当前方法检测并使用throws抛出的checked exception",
      "若无handler来处理抛出的checked exception",
      "程序就终止执行",
      "（2）使用throw抛出异常：1.找到一个能表达错误的Exception类/或者构造出一个新的Exception类",
      "2.构造Exception类的一个实例，将错误信息写入",
      "3.抛出错误（throw）",
      "4.一旦抛出异常",
      "方法不会再将控制权返回给调用它的client",
      "因此也无需考虑返回错误代码",
      "·自定义异常类",
      "Finally关键字：无论程序是否碰到异常",
      "finally关键字都将被执行",
      "·断言",
      "在开发阶段的代码中嵌入，检验某些假设是否成立",
      "若成立则表明程序运行正常，否则表明存在错误",
      "断言即是对代码中程序员所做的假设的文档化，不会影响程序的性能",
      "形式：所构造的message将在发生错误时显示给用户",
      "便于快速发现错误所在；实际运行阶段",
      "不再使用断言！",
      "出现AssertionError即表示内部某些假设被违反了",
      "可使用assert的情况：内部不变量、表示不变量、控制流不变量（switch-case）、方法的前置、后置条件",
      "断言只检查程序内部的状态是否符合规约",
      "断言一旦false",
      "程序就停止执行",
      "外部错误（不受自己控制）要使用Exception机制去处理",
      "·防御式编程的基本思路：（1）最好的防御就是不要引入bug",
      "（2）若无法避免",
      "则将bug限制在最小范围内；限定在一个方法内部",
      "不扩散",
      "（3）Fail fast"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "第二讲： 软件测试与测试优先的编程\n·黑盒测试：对程序外部表现出来的行为进行测试；用于检查代码的功能，不关注内部的实现细节——检查是否符合规约\n等价类划分：针对每个输入数据需要满足的约束条件，划分等价类；从等价类中导出测试用例\n边界值分析：对等价类划分的一个补充（在等价类划分时将边界值作为等价类之一加入考虑）\n测试用例：输入+执行条件+期望结果\n·测试覆盖度：\n（1）笛卡尔积：全覆盖\n（2）每个维度的每个取值至少被一个测试用例覆盖一次即可\n代码覆盖度：\n函数覆盖、语句覆盖、分支覆盖、条件覆盖、路径覆盖\n覆盖度标准（100%语句覆盖，90%路径覆盖）\n·以注释的形式撰写测试策略：\n·TDD：\n（1）先写spec （2）再写符合spec的测试用例 （3）写代码、执行测试、有问题再改、再执行测试用例，直到通过它\n·Junit assert xxx：\n第十二讲： 面向正确性与健壮性的软件构造\n·健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度——倾向于容错\n·正确性：程序按照spec加以执行的能力（最重要的质量指标）——倾向于直接报错\n可靠性 = 健壮性 + 正确性\n·Error/Runtime异常\nError：内部错误，一旦发生，想办法让程序优雅的结束\nException：异常：自己程序导致的问题，可以捕获，可以处理\n（1）将错误信息传递给上层调用者，并报告“案发现场”的信息\n（2）Return外的第二种退出途径\n（3）若找不到异常处理程序，整个系统完全退出\n（4）分为运行时异常和其他异常\n运行时异常：程序员在代码中处理不当造成，可避免\n其他异常：由外部原因造成，无法完全避免\n·Checked异常，Unchecked异常\nChecked异常：必须捕获并指定错误处理器handle，否则编译无法通过\n·Checked异常处理机制\n（1）使用throws声明异常\n方法应throws的异常：\n该方法调用的其他函数抛出的checked exception\n当前方法检测并使用throws抛出的checked exception\n若无handler来处理抛出的checked exception，程序就终止执行\n（2）使用throw抛出异常：\n1.找到一个能表达错误的Exception类/或者构造出一个新的Exception类\n2.构造Exception类的一个实例，将错误信息写入\n3.抛出错误（throw）\n4.一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码\n·自定义异常类\nFinally关键字：无论程序是否碰到异常，finally关键字都将被执行\n·断言\n在开发阶段的代码中嵌入，检验某些假设是否成立。若成立则表明程序运行正常，否则表明存在错误\n断言即是对代码中程序员所做的假设的文档化，不会影响程序的性能\n形式：\n所构造的message将在发生错误时显示给用户，便于快速发现错误所在；实际运行阶段，不再使用断言！\n出现AssertionError即表示内部某些假设被违反了\n可使用assert的情况：\n内部不变量、表示不变量、控制流不变量（switch-case）、方法的前置、后置条件\n断言只检查程序内部的状态是否符合规约，断言一旦false，程序就停止执行，外部错误（不受自己控制）要使用Exception机制去处理\n·防御式编程的基本思路：\n（1）最好的防御就是不要引入bug\n（2）若无法避免，则将bug限制在最小范围内；限定在一个方法内部，不扩散\n（3）Fail fast\n"
  },
  {
    "head": "Git：删除远程仓库中的文件及文件夹&GIt中错误“SSL_ERROR_SYSCALL,errno 10054”的解决",
    "paragraphs": [
      "eg.删除GitHub远程仓库中的FriendshipGraphTest.java文件",
      "使用git pull origin master指令拉取远程仓库",
      "使用git rm -r --cached filename指令删除特定文件与文件夹",
      "使用git commit -m “...”指令提交删除操作至本地仓库",
      "使用git push指令上传至远程仓库",
      "最终结果",
      "·GIt中错误“SSL_ERROR_SYSCALL,errno 10054”的解决方案：",
      "此问题为安全设置问题：",
      "使用指令：",
      "git config http.sslVerify \"false\"",
      "即可解决",
      "·Git中错误：“TimeOut”解决方法：",
      "因github为境外网站，时常出现崩坏的情况；如遇此情况：",
      "反复多次提交即可解决。",
      "参考文献：",
      "https://www.cnblogs.com/emmetyang/p/10620819.html"
    ],
    "sentences": [
      "eg.删除GitHub远程仓库中的FriendshipGraphTest.java文件",
      "使用git pull origin master指令拉取远程仓库",
      "使用git rm -r --cached filename指令删除特定文件与文件夹",
      "使用git commit -m “...”指令提交删除操作至本地仓库",
      "使用git push指令上传至远程仓库",
      "最终结果",
      "·GIt中错误“SSL_ERROR_SYSCALL,errno 10054”的解决方案：此问题为安全设置问题：使用指令：git config http.sslVerify \"false\"",
      "即可解决",
      "·Git中错误：“TimeOut”解决方法：因github为境外网站",
      "时常出现崩坏的情况；如遇此情况：反复多次提交即可解决",
      "参考文献：https://www.cnblogs.com/emmetyang/p/10620819.html"
    ],
    "codes": [],
    "date": "2021-05-23",
    "text": "eg.删除GitHub远程仓库中的FriendshipGraphTest.java文件\n使用git pull origin master指令拉取远程仓库\n使用git rm -r --cached filename指令删除特定文件与文件夹\n使用git commit -m “...”指令提交删除操作至本地仓库\n使用git push指令上传至远程仓库\n最终结果\n·GIt中错误“SSL_ERROR_SYSCALL,errno 10054”的解决方案：\n此问题为安全设置问题：\n使用指令：\ngit config http.sslVerify \"false\"\n即可解决\n·Git中错误：“TimeOut”解决方法：\n因github为境外网站，时常出现崩坏的情况；如遇此情况：\n反复多次提交即可解决。\n参考文献：\nhttps://www.cnblogs.com/emmetyang/p/10620819.html\n"
  },
  {
    "head": "HIT软件构造期末复习笔记第9~11章",
    "paragraphs": [
      "第九讲： 面向复用的软件构造技术",
      "·白盒框架：通过代码层面的继承进行框架扩展",
      "·黑盒框架：通过实现特定接口、委派进行框架扩展",
      "·LSP原则",
      "（1）子类型可以增加方法，但不可以删除方法",
      "（2）子类型需要实现抽象类型中所有未实现的方法",
      "（3）子类型中重写的方法必须有相同或子类型的返回值或符合co-variance的参数",
      "（4）子类型中的重写的方法必须使用同样类型的参数或符合contra-variance的参数",
      "（5）子类型中重写的方法不能抛出额外的异常",
      "（更强的不变量，更弱的前置条件，更强的后置条件）",
      "子类型方法参数：逆变",
      "子类型方法的返回值：协变",
      "异常类型：协变",
      "·协变：",
      "父类型 --> 子类型：越来越具体的spec",
      "返回值类型、异常类型：不变或变的更具体",
      "·逆变：",
      "父类型 --> 子类型：越来越具体的spec",
      "参数类型：要不变或越来越抽象",
      "（目前Java遇到此种情况，均当作overload看待）",
      "·数组的子类型化",
      "·泛型的子类型化",
      "ArrayList是List的子类型，而List不是List的子类型",
      "泛型不支持协变——类型擦除",
      "List不是List的子类型！",
      "·解决：使用通配符？",
      "·组合和委派",
      "委派：一个对象请求另一个对象的功能（复用的一种常见形式）",
      "委派模式：通过运行时动态绑定，实现对其他类中代码的复用",
      "委派发生在object层，继承发生在class层",
      "分类：",
      "（1）Dependency：临时性的delegation",
      " （2）Association：永久性的delegation",
      "（3）Composition：更强的association（难以变化）",
      "（4）Aggregation：更弱的association（可动态变化）",
      "·接口的组合",
      "·CRP原则",
      "·白盒框架的原理与实现",
      "·黑盒框架的原理与实现",
      "第十讲： 面向可维护性的构造技术",
      "·可维护性的常见度量指标：",
      "可维护性、可扩展性、灵活性、可适应性、可管理性、支持性",
      "圈复杂度、代码行数、可维护性指数、继承的层次数、类之间的耦合度、单元测试的覆盖度",
      "·聚合度、耦合度：高聚合+低耦合",
      "·SOLID：",
      "SRP：单一责任原则",
      "OCP：开放-封闭原则",
      "LSP：Liskov替换原则",
      "ISP：接口聚合原则",
      "DIP：依赖转置原则",
      "SRP：不应有多于一个原因让你的ADT发生变化，否则就拆分开",
      "OCP：",
      "对扩展性的开放：模块的行为应该是可扩展的",
      "对修改的封闭：模块自身的代码不应被修改；扩展模块行为的一般途径是修改模块的内部实现",
      "LSP：",
      "子类型必须能替代其基类型；派生类必须能够通过其基类的接口使用，客户端无需理解这二者的差异",
      "ISP：",
      "不能强迫客户端依赖于它不需要的接口，只提供必需的接口",
      "DIP：",
      "抽象的模块不应依赖于具体的模块，具体应依赖于抽象",
      "（delegation时要通过interface建立联系，而非具体的子类）",
      "·语法驱动的构造",
      "从外部读取文本数据，在应用中做进一步的处理",
      "用语法判断字符串是否合法，并解析成程序里使用的数据结构",
      "·正则表达式",
      "第十一讲： 面向可复用性和可维护性的设计模式",
      "·创建型模式：",
      "··工厂方法（“虚拟构造器”）",
      "当客户端不知道要创建哪个具体类的实例，或不想在client代码中指明要具体创建的实例时，用工厂方法",
      "定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类",
      "·结构型模式：",
      "··Adapter（适配器模式）",
      "将某个类、接口转换为client期望的其他形式；通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体的子类",
      "··Decorator（装饰器模式）",
      "为对象增加不同侧面的属性，对每个特性构造子类，通过委派机制增加到对象上",
      "客户端需要一个具有多种特性的object，通过一层一层的装饰来实现",
      "·行为型模式",
      "··Strategy（策略模式）",
      "有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而非写死在代码中；为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例",
      "··Template method（模板模式）",
      "做事情的步骤一致，但方法不一样；共性的步骤在抽象类中公共实现，差异化的步骤在各个子类中实现",
      "使用继承和重写实现模板模式",
      "··Iterator（迭代器模式）",
      "客户端希望遍历被放入到容器、集合类中的一组ADT对象，无需关心容器的具体类型",
      "为ADT实现iterable接口，实现该接口的集合对象是可遍历迭代的（只含iterator方法）",
      "实现自己独特的Iterator迭代器（next、hasNext、remove），允许客户端应用这个迭代器进行显式或隐式的迭代遍历",
      "··Visitor",
      "将数据和作用于数据上的某种、某些种特定操作分离开来",
      "为ADT预留一个将来可扩展功能的接入点，外部实现的代码功能能在不改变ADT本身的情况下通过delegation接入ADT"
    ],
    "sentences": [
      "第九讲： 面向复用的软件构造技术",
      "·白盒框架：通过代码层面的继承进行框架扩展",
      "·黑盒框架：通过实现特定接口、委派进行框架扩展",
      "·LSP原则",
      "（1）子类型可以增加方法，但不可以删除方法",
      "（2）子类型需要实现抽象类型中所有未实现的方法",
      "（3）子类型中重写的方法必须有相同或子类型的返回值或符合co-variance的参数",
      "（4）子类型中的重写的方法必须使用同样类型的参数或符合contra-variance的参数",
      "（5）子类型中重写的方法不能抛出额外的异常",
      "（更强的不变量，更弱的前置条件，更强的后置条件）",
      "子类型方法参数：逆变",
      "子类型方法的返回值：协变",
      "异常类型：协变",
      "·协变：父类型 --> 子类型：越来越具体的spec",
      "返回值类型、异常类型：不变或变的更具体",
      "·逆变：父类型 --> 子类型：越来越具体的spec",
      "参数类型：要不变或越来越抽象",
      "（目前Java遇到此种情况，均当作overload看待）",
      "·数组的子类型化",
      "·泛型的子类型化",
      "ArrayList是List的子类型",
      "而List不是List的子类型",
      "泛型不支持协变——类型擦除",
      "List不是List的子类型！",
      "·解决：使用通配符？",
      "·组合和委派",
      "委派：一个对象请求另一个对象的功能（复用的一种常见形式）",
      "委派模式：通过运行时动态绑定，实现对其他类中代码的复用",
      "委派发生在object层，继承发生在class层",
      "分类：（1）Dependency：临时性的delegation",
      " （2）Association：永久性的delegation",
      "（3）Composition：更强的association（难以变化）",
      "（4）Aggregation：更弱的association（可动态变化）",
      "·接口的组合",
      "·CRP原则",
      "·白盒框架的原理与实现",
      "·黑盒框架的原理与实现",
      "第十讲： 面向可维护性的构造技术",
      "·可维护性的常见度量指标：可维护性、可扩展性、灵活性、可适应性、可管理性、支持性",
      "圈复杂度、代码行数、可维护性指数、继承的层次数、类之间的耦合度、单元测试的覆盖度",
      "·聚合度、耦合度：高聚合+低耦合",
      "·SOLID：SRP：单一责任原则",
      "OCP：开放-封闭原则",
      "LSP：Liskov替换原则",
      "ISP：接口聚合原则",
      "DIP：依赖转置原则",
      "SRP：不应有多于一个原因让你的ADT发生变化，否则就拆分开",
      "OCP：对扩展性的开放：模块的行为应该是可扩展的",
      "对修改的封闭：模块自身的代码不应被修改；扩展模块行为的一般途径是修改模块的内部实现",
      "LSP：子类型必须能替代其基类型；派生类必须能够通过其基类的接口使用",
      "客户端无需理解这二者的差异",
      "ISP：不能强迫客户端依赖于它不需要的接口，只提供必需的接口",
      "DIP：抽象的模块不应依赖于具体的模块，具体应依赖于抽象",
      "（delegation时要通过interface建立联系",
      "而非具体的子类）",
      "·语法驱动的构造",
      "从外部读取文本数据，在应用中做进一步的处理",
      "用语法判断字符串是否合法，并解析成程序里使用的数据结构",
      "·正则表达式",
      "第十一讲： 面向可复用性和可维护性的设计模式",
      "·创建型模式：··工厂方法（“虚拟构造器”）",
      "当客户端不知道要创建哪个具体类的实例",
      "或不想在client代码中指明要具体创建的实例时",
      "用工厂方法",
      "定义一个用于创建对象的接口",
      "让其子类来决定实例化哪一个类",
      "从而使一个类的实例化延迟到其子类",
      "·结构型模式：··Adapter（适配器模式）",
      "将某个类、接口转换为client期望的其他形式；通过增加一个接口",
      "将已存在的子类封装起来",
      "client面向接口编程",
      "从而隐藏了具体的子类",
      "··Decorator（装饰器模式）",
      "为对象增加不同侧面的属性",
      "对每个特性构造子类",
      "通过委派机制增加到对象上",
      "客户端需要一个具有多种特性的object",
      "通过一层一层的装饰来实现",
      "·行为型模式",
      "··Strategy（策略模式）",
      "有多种不同的算法来实现同一个任务",
      "但需要client根据需要动态切换算法",
      "而非写死在代码中；为不同的实现算法构造抽象接口",
      "利用delegation",
      "运行时动态传入client倾向的算法类实例",
      "··Template method（模板模式）",
      "做事情的步骤一致",
      "但方法不一样；共性的步骤在抽象类中公共实现",
      "差异化的步骤在各个子类中实现",
      "使用继承和重写实现模板模式",
      "··Iterator（迭代器模式）",
      "客户端希望遍历被放入到容器、集合类中的一组ADT对象",
      "无需关心容器的具体类型",
      "为ADT实现iterable接口",
      "实现该接口的集合对象是可遍历迭代的（只含iterator方法）",
      "实现自己独特的Iterator迭代器（next、hasNext、remove）",
      "允许客户端应用这个迭代器进行显式或隐式的迭代遍历",
      "··Visitor",
      "将数据和作用于数据上的某种、某些种特定操作分离开来",
      "为ADT预留一个将来可扩展功能的接入点",
      "外部实现的代码功能能在不改变ADT本身的情况下通过delegation接入ADT"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "第九讲： 面向复用的软件构造技术\n·白盒框架：通过代码层面的继承进行框架扩展\n·黑盒框架：通过实现特定接口、委派进行框架扩展\n·LSP原则\n（1）子类型可以增加方法，但不可以删除方法\n（2）子类型需要实现抽象类型中所有未实现的方法\n（3）子类型中重写的方法必须有相同或子类型的返回值或符合co-variance的参数\n（4）子类型中的重写的方法必须使用同样类型的参数或符合contra-variance的参数\n（5）子类型中重写的方法不能抛出额外的异常\n（更强的不变量，更弱的前置条件，更强的后置条件）\n子类型方法参数：逆变\n子类型方法的返回值：协变\n异常类型：协变\n·协变：\n父类型 --> 子类型：越来越具体的spec\n返回值类型、异常类型：不变或变的更具体\n·逆变：\n父类型 --> 子类型：越来越具体的spec\n参数类型：要不变或越来越抽象\n（目前Java遇到此种情况，均当作overload看待）\n·数组的子类型化\n·泛型的子类型化\nArrayList是List的子类型，而List不是List的子类型\n泛型不支持协变——类型擦除\nList不是List的子类型！\n·解决：使用通配符？\n·组合和委派\n委派：一个对象请求另一个对象的功能（复用的一种常见形式）\n委派模式：通过运行时动态绑定，实现对其他类中代码的复用\n委派发生在object层，继承发生在class层\n分类：\n（1）Dependency：临时性的delegation\n （2）Association：永久性的delegation\n（3）Composition：更强的association（难以变化）\n（4）Aggregation：更弱的association（可动态变化）\n·接口的组合\n·CRP原则\n·白盒框架的原理与实现\n·黑盒框架的原理与实现\n第十讲： 面向可维护性的构造技术\n·可维护性的常见度量指标：\n可维护性、可扩展性、灵活性、可适应性、可管理性、支持性\n圈复杂度、代码行数、可维护性指数、继承的层次数、类之间的耦合度、单元测试的覆盖度\n·聚合度、耦合度：高聚合+低耦合\n·SOLID：\nSRP：单一责任原则\nOCP：开放-封闭原则\nLSP：Liskov替换原则\nISP：接口聚合原则\nDIP：依赖转置原则\nSRP：不应有多于一个原因让你的ADT发生变化，否则就拆分开\nOCP：\n对扩展性的开放：模块的行为应该是可扩展的\n对修改的封闭：模块自身的代码不应被修改；扩展模块行为的一般途径是修改模块的内部实现\nLSP：\n子类型必须能替代其基类型；派生类必须能够通过其基类的接口使用，客户端无需理解这二者的差异\nISP：\n不能强迫客户端依赖于它不需要的接口，只提供必需的接口\nDIP：\n抽象的模块不应依赖于具体的模块，具体应依赖于抽象\n（delegation时要通过interface建立联系，而非具体的子类）\n·语法驱动的构造\n从外部读取文本数据，在应用中做进一步的处理\n用语法判断字符串是否合法，并解析成程序里使用的数据结构\n·正则表达式\n第十一讲： 面向可复用性和可维护性的设计模式\n·创建型模式：\n··工厂方法（“虚拟构造器”）\n当客户端不知道要创建哪个具体类的实例，或不想在client代码中指明要具体创建的实例时，用工厂方法\n定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类\n·结构型模式：\n··Adapter（适配器模式）\n将某个类、接口转换为client期望的其他形式；通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体的子类\n··Decorator（装饰器模式）\n为对象增加不同侧面的属性，对每个特性构造子类，通过委派机制增加到对象上\n客户端需要一个具有多种特性的object，通过一层一层的装饰来实现\n·行为型模式\n··Strategy（策略模式）\n有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而非写死在代码中；为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例\n··Template method（模板模式）\n做事情的步骤一致，但方法不一样；共性的步骤在抽象类中公共实现，差异化的步骤在各个子类中实现\n使用继承和重写实现模板模式\n··Iterator（迭代器模式）\n客户端希望遍历被放入到容器、集合类中的一组ADT对象，无需关心容器的具体类型\n为ADT实现iterable接口，实现该接口的集合对象是可遍历迭代的（只含iterator方法）\n实现自己独特的Iterator迭代器（next、hasNext、remove），允许客户端应用这个迭代器进行显式或隐式的迭代遍历\n··Visitor\n将数据和作用于数据上的某种、某些种特定操作分离开来\n为ADT预留一个将来可扩展功能的接入点，外部实现的代码功能能在不改变ADT本身的情况下通过delegation接入ADT\n"
  },
  {
    "head": "HIT软件构造期末复习4~8章",
    "paragraphs": [
      "第四讲： 数据类型与类型检验",
      "·基本数据类型，对象数据类型",
      "可将基本类型包装成对象类型，通常是在定义集合类型时使用它们，一般情况避免使用",
      "Java：静态类型语言；在编译阶段进行类型检查",
      "·静态类型检查",
      "可在编译阶段发现错误，避免了将错误带入到运行阶段，提高程序健壮性、正确性",
      "关于“类型”的检查！！",
      "（1）语法错误 （2）类名/函数名错误 （3）参数数目错误 （4）参数类型错误",
      "（5）返回值类型错误",
      " ·动态类型检查",
      "关于“值”的检查！！",
      "（1）非法的参数值 （2）非法的返回值 （3）越界、空指针",
      "·值的改变，引用的改变，final",
      "改变一个变量：将该变量指向另一个值的存储空间",
      "改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值",
      "不变数据类型：一旦被创建，其值不能改变",
      "若是引用类型，也可是不变的：一旦确定其指向的对象，不能再被改变",
      "Mutable对象：拥有方法可以修改自己的值/引用",
      "Immutable对象：一旦被创建，始终指向同一个值/引用",
      "Final类：",
      "（1）无法派生出子类",
      "（2）Final变量无法改变值或引用",
      "（3）Final方法无法被子类重写",
      "（4）修饰基本类型：起常量作用，基本类型的值不能改变",
      "（5）修饰引用类型：不能在指向其他对象，但被引用对象的值可以改变",
      "对可变数据类型，采取防御式拷贝——给客户端返回一个全新的对象（副本）",
      "对不可变数据类型，无需采用防御式拷贝（应对有多个引用的情况）",
      "安全的使用可变数据类型：作为局部变量，只有一个引用，不涉及共享",
      "·Snapshot diagram：",
      "用于描述程序运行时的内部状态",
      "·迭代器：",
      "对iter使用remove方法可避免mutable对象对迭代器的破坏",
      "注：此种不变性是在运行阶段获得的，编译阶段无法据此进行静态检查",
      "第五讲： 设计规约",
      "·specification",
      "客户端无需阅读调用函数的代码，只需要理解spec即可",
      "规约可以隔离变化，无需通知客户端",
      "前置条件：对客户端的约束，使用方法时必须满足的条件",
      "后置条件：对开发者的约束，方法结束时必须满足的条件",
      "契约：前置条件满足，后置条件必须满足；前置条件不满足，后置条件不一定满足",
      "·行为等价性",
      "站在客户端的角度看待行为等价性；根据规约判断行为是否等价",
      "静态类型声明是一种规约，可据此进行静态类型检查static checking",
      "方法前的注释也是一种规约，但需要人工判定其是否满足",
      "Javadoc：",
      "·比较规约：",
      "（1）规约的强度 （2）规约的确定性 （3）规约的陈述性",
      "·规约强度：",
      "Spec变强：更强的后置条件+更弱的前置条件",
      "可用更强的规约替换更弱的规约",
      "操作式规约：（eg.伪代码）",
      "声明式规约：（无内部实现的描述，只有初终状态）更有价值",
      "内部实现的细节不在规约里呈现，放在代码实现体内部内部的注释内呈现",
      "规约质量：",
      "·内聚的（spec描述的规约单一、简单、易理解）",
      "·信息丰富的（不能让客户端产生理解的歧义）",
      "·既足够强又足够弱",
      "第六讲： 抽象数据类型",
      "ADT特性：表示泄漏、抽象函数AF、表示不变量RI",
      "ADT由操作定义，与其内部如何实现无关",
      "不变数据类型：其操作不改变内部值，而是构造新的对象",
      "·ADT操作的四种类型：",
      "构造器：可能实现为构造函数或静态函数",
      "生产器：由旧对象产生新对象",
      "观察器",
      "变值器",
      "测试creator、producer、mutator时用observer来观察这些操作是否的结果是否满足spec",
      "测试observer时用creator、producer、mutator等方法产生或改变对象，来看结果是否正确",
      "·表示独立性",
      "客户端使用ADT时无需考虑其内部是如何实现的，ADT内部表示的变化不应影响外部spec和客户端。",
      "·不变量",
      "在任何时候总是true，由ADT负责其不变量，与客户端的任何操作均无关",
      "（immutability即是一个典型的不变量）",
      "·表示泄漏",
      "不仅影响不变性，也影响表示独立性；无法在不影响客户端的情况下改变其内部表示！",
      "使用immutable对象，可彻底的避免表示泄漏！",
      "·表示空间、抽象空间、AF",
      "ADT开发者关注R，client关注A",
      "满射！！！",
      "AF：R --> A",
      "·RI（表示不变性）",
      "所有表示值的一个子集，包含了所有合法的表示值",
      "选择某种特定的表示方式R，进而指定某个子集是合法的（RI），并为该子集中的每个值做出解释（AF）",
      "·设计ADT：",
      "（1）选择R和A （2）RI：合法的表示值 （3）如何解释合法的表示值：映射AF",
      "·随时检查RI是否满足",
      "在所有可能会改变rep的方法中都要检查",
      "·在代码中以注释的形式记录AF、RI",
      "要精确记录的RI：rep中的所有fields何为有效",
      "要精确记录的AF：如何解释每一个R值",
      "表示泄漏的安全声明：给出理由，证明代码并未对外泄漏其内部表示",
      "ADT的规约里只能使用client可见的内容来撰写，包含参数、返回值、异常等",
      "若规约里提及值，则只能采用A空间中的值",
      "在代码中以注释的形式写出AF和RI而不能在javadoc文档中，防止被外部看到而破坏表示独立性",
      "构造器和生产器在创建对象时要确保不变量为true",
      "变值器和观察器在执行时必须保持不变性",
      "在每个方法return前，用checkRep()检查不变量是否得以保持",
      "第七讲： 面向对象编程",
      "·interface、class",
      "定义、实现ADT",
      "接口：确定ADT规约",
      "（java interface cannot have constructors）",
      "类：实现ADT",
      "接口中的静态工厂方法",
      "使用接口类型声明变量，客户端仅使用接口中定义的方法，客户端无法直接访问属性",
      "·inheritance & override",
      "重写的函数：与父类或接口完全相同的signature；实际执行时调用哪个函数，运行时决定",
      "若父类型中的某个函数体的实现为空，说明其所有子类型都需要这个功能，但各有差异，无共性，在每个子类中均需要重写",
      "重写过后，使用supper()复用父类型中函数的功能，并对其进行扩展",
      "·多态 & overload",
      "（1）特殊多态：功能重载",
      "（2）参数化多态：使用泛型",
      "（3）子类型多态：不同类型的对象可以统一处理，无需区分，从而隔离了变化；LSP原则",
      "B is a subtype of A means that every B is A；every B satisfies the spec of A",
      "子类型的spec不能弱化父类型的spec",
      "第八讲： ADT和OOP中的等价性",
      "·等价性",
      "基于AF定义ADT的等价操作——AF映射到相同的结果，则等价",
      "等价关系：自反、传递、对称",
      "·equals( )和==",
      "：引用等价性",
      "两个对象指向内存的同一段空间时，这两者引用等价",
      "Equals( )：对象等价性",
      "具有相同的内容",
      "自定义ADT时要重写Object类的equals方法",
      "在object类中实现的缺省equals是在判断引用等价性！",
      "对基本数据类型，使用",
      "判断相等",
      "对对象类型，使用equals判断相等（eg.String）",
      "重写equals的正确姿势",
      "其中instanceof操作符用于判断类的一致性",
      "·Equals等价关系：自反、对称、传递",
      "用是否为等价关系检验equals是否正确",
      "·hashCode( )",
      "“相等”的对象，其hashCode的结果一定相同",
      "两个equals的对象，一定要有同样的hashCode（除非你能保证你的ADT不会被放置到hash类型的集合类中！）",
      "·可变对象的观察等价性、行为等价性：",
      "观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致",
      "行为等价性：调用对象的任何方法都展示出一致的结果",
      "若某个mutable的对象包含在Set集合类当中，当其发生改变后，集合类的行为不确定",
      "对所有可变类型对象，实现行为等价性即可，也就是说只有指向相同内存空间的objects才是相等的；对所有mutable类型的对象，无需重写hashCode和equals方法，直接继承Object类的两个方法即可",
      "·不可变对象的引用等价性、对象等价性：",
      "不可变对象需重写equals方法及hashCode方法"
    ],
    "sentences": [
      "第四讲： 数据类型与类型检验",
      "·基本数据类型，对象数据类型",
      "可将基本类型包装成对象类型",
      "通常是在定义集合类型时使用它们",
      "一般情况避免使用",
      "Java：静态类型语言；在编译阶段进行类型检查",
      "·静态类型检查",
      "可在编译阶段发现错误",
      "避免了将错误带入到运行阶段",
      "提高程序健壮性、正确性",
      "关于“类型”的检查！！",
      "（1）语法错误 （2）类名/函数名错误 （3）参数数目错误 （4）参数类型错误",
      "（5）返回值类型错误",
      " ·动态类型检查",
      "关于“值”的检查！！",
      "（1）非法的参数值 （2）非法的返回值 （3）越界、空指针",
      "·值的改变，引用的改变，final",
      "改变一个变量：将该变量指向另一个值的存储空间",
      "改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值",
      "不变数据类型：一旦被创建，其值不能改变",
      "若是引用类型",
      "也可是不变的：一旦确定其指向的对象",
      "不能再被改变",
      "Mutable对象：拥有方法可以修改自己的值/引用",
      "Immutable对象：一旦被创建，始终指向同一个值/引用",
      "Final类：（1）无法派生出子类",
      "（2）Final变量无法改变值或引用",
      "（3）Final方法无法被子类重写",
      "（4）修饰基本类型：起常量作用，基本类型的值不能改变",
      "（5）修饰引用类型：不能在指向其他对象",
      "但被引用对象的值可以改变",
      "对可变数据类型",
      "采取防御式拷贝——给客户端返回一个全新的对象（副本）",
      "对不可变数据类型，无需采用防御式拷贝（应对有多个引用的情况）",
      "安全的使用可变数据类型：作为局部变量",
      "只有一个引用",
      "不涉及共享",
      "·Snapshot diagram：用于描述程序运行时的内部状态",
      "·迭代器：对iter使用remove方法可避免mutable对象对迭代器的破坏",
      "注：此种不变性是在运行阶段获得的",
      "编译阶段无法据此进行静态检查",
      "第五讲： 设计规约",
      "·specification",
      "客户端无需阅读调用函数的代码，只需要理解spec即可",
      "规约可以隔离变化，无需通知客户端",
      "前置条件：对客户端的约束，使用方法时必须满足的条件",
      "后置条件：对开发者的约束，方法结束时必须满足的条件",
      "契约：前置条件满足",
      "后置条件必须满足；前置条件不满足",
      "后置条件不一定满足",
      "·行为等价性",
      "站在客户端的角度看待行为等价性；根据规约判断行为是否等价",
      "静态类型声明是一种规约",
      "可据此进行静态类型检查static checking",
      "方法前的注释也是一种规约，但需要人工判定其是否满足",
      "Javadoc：·比较规约：（1）规约的强度 （2）规约的确定性 （3）规约的陈述性",
      "·规约强度：Spec变强：更强的后置条件+更弱的前置条件",
      "可用更强的规约替换更弱的规约",
      "操作式规约：（eg.伪代码）",
      "声明式规约：（无内部实现的描述，只有初终状态）更有价值",
      "内部实现的细节不在规约里呈现",
      "放在代码实现体内部内部的注释内呈现",
      "规约质量：·内聚的（spec描述的规约单一、简单、易理解）",
      "·信息丰富的（不能让客户端产生理解的歧义）",
      "·既足够强又足够弱",
      "第六讲： 抽象数据类型",
      "ADT特性：表示泄漏、抽象函数AF、表示不变量RI",
      "ADT由操作定义，与其内部如何实现无关",
      "不变数据类型：其操作不改变内部值，而是构造新的对象",
      "·ADT操作的四种类型：构造器：可能实现为构造函数或静态函数",
      "生产器：由旧对象产生新对象",
      "观察器",
      "变值器",
      "测试creator、producer、mutator时用observer来观察这些操作是否的结果是否满足spec",
      "测试observer时用creator、producer、mutator等方法产生或改变对象",
      "来看结果是否正确",
      "·表示独立性",
      "客户端使用ADT时无需考虑其内部是如何实现的",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "·不变量",
      "在任何时候总是true",
      "由ADT负责其不变量",
      "与客户端的任何操作均无关",
      "（immutability即是一个典型的不变量）",
      "·表示泄漏",
      "不仅影响不变性",
      "也影响表示独立性；无法在不影响客户端的情况下改变其内部表示！",
      "使用immutable对象，可彻底的避免表示泄漏！",
      "·表示空间、抽象空间、AF",
      "ADT开发者关注R，client关注A",
      "满射！！！",
      "AF：R --> A",
      "·RI（表示不变性）",
      "所有表示值的一个子集，包含了所有合法的表示值",
      "选择某种特定的表示方式R",
      "进而指定某个子集是合法的（RI）",
      "并为该子集中的每个值做出解释（AF）",
      "·设计ADT：（1）选择R和A （2）RI：合法的表示值 （3）如何解释合法的表示值：映射AF",
      "·随时检查RI是否满足",
      "在所有可能会改变rep的方法中都要检查",
      "·在代码中以注释的形式记录AF、RI",
      "要精确记录的RI：rep中的所有fields何为有效",
      "要精确记录的AF：如何解释每一个R值",
      "表示泄漏的安全声明：给出理由，证明代码并未对外泄漏其内部表示",
      "ADT的规约里只能使用client可见的内容来撰写",
      "包含参数、返回值、异常等",
      "若规约里提及值，则只能采用A空间中的值",
      "在代码中以注释的形式写出AF和RI而不能在javadoc文档中",
      "防止被外部看到而破坏表示独立性",
      "构造器和生产器在创建对象时要确保不变量为true",
      "变值器和观察器在执行时必须保持不变性",
      "在每个方法return前",
      "用checkRep()检查不变量是否得以保持",
      "第七讲： 面向对象编程",
      "·interface、class",
      "定义、实现ADT",
      "接口：确定ADT规约",
      "（java interface cannot have constructors）",
      "类：实现ADT",
      "接口中的静态工厂方法",
      "使用接口类型声明变量",
      "客户端仅使用接口中定义的方法",
      "客户端无法直接访问属性",
      "·inheritance & override",
      "重写的函数：与父类或接口完全相同的signature；实际执行时调用哪个函数",
      "运行时决定",
      "若父类型中的某个函数体的实现为空",
      "说明其所有子类型都需要这个功能",
      "但各有差异",
      "无共性",
      "在每个子类中均需要重写",
      "重写过后",
      "使用supper()复用父类型中函数的功能",
      "并对其进行扩展",
      "·多态 & overload",
      "（1）特殊多态：功能重载",
      "（2）参数化多态：使用泛型",
      "（3）子类型多态：不同类型的对象可以统一处理",
      "无需区分",
      "从而隔离了变化；LSP原则",
      "B is a subtype of A means that every B is A；every B satisfies the spec of A",
      "子类型的spec不能弱化父类型的spec",
      "第八讲： ADT和OOP中的等价性",
      "·等价性",
      "基于AF定义ADT的等价操作——AF映射到相同的结果，则等价",
      "等价关系：自反、传递、对称",
      "·equals( )和==",
      "：引用等价性",
      "两个对象指向内存的同一段空间时，这两者引用等价",
      "Equals( )：对象等价性",
      "具有相同的内容",
      "自定义ADT时要重写Object类的equals方法",
      "在object类中实现的缺省equals是在判断引用等价性！",
      "对基本数据类型，使用",
      "判断相等",
      "对对象类型，使用equals判断相等（eg.String）",
      "重写equals的正确姿势",
      "其中instanceof操作符用于判断类的一致性",
      "·Equals等价关系：自反、对称、传递",
      "用是否为等价关系检验equals是否正确",
      "·hashCode( )",
      "“相等”的对象，其hashCode的结果一定相同",
      "两个equals的对象",
      "一定要有同样的hashCode（除非你能保证你的ADT不会被放置到hash类型的集合类中！）",
      "·可变对象的观察等价性、行为等价性：观察等价性：在不改变状态的情况下",
      "两个mutable对象是否看起来一致",
      "行为等价性：调用对象的任何方法都展示出一致的结果",
      "若某个mutable的对象包含在Set集合类当中",
      "当其发生改变后",
      "集合类的行为不确定",
      "对所有可变类型对象",
      "实现行为等价性即可",
      "也就是说只有指向相同内存空间的objects才是相等的；对所有mutable类型的对象",
      "无需重写hashCode和equals方法",
      "直接继承Object类的两个方法即可",
      "·不可变对象的引用等价性、对象等价性：不可变对象需重写equals方法及hashCode方法"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "第四讲： 数据类型与类型检验\n·基本数据类型，对象数据类型\n可将基本类型包装成对象类型，通常是在定义集合类型时使用它们，一般情况避免使用\nJava：静态类型语言；在编译阶段进行类型检查\n·静态类型检查\n可在编译阶段发现错误，避免了将错误带入到运行阶段，提高程序健壮性、正确性\n关于“类型”的检查！！\n（1）语法错误 （2）类名/函数名错误 （3）参数数目错误 （4）参数类型错误\n（5）返回值类型错误\n ·动态类型检查\n关于“值”的检查！！\n（1）非法的参数值 （2）非法的返回值 （3）越界、空指针\n·值的改变，引用的改变，final\n改变一个变量：将该变量指向另一个值的存储空间\n改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值\n不变数据类型：一旦被创建，其值不能改变\n若是引用类型，也可是不变的：一旦确定其指向的对象，不能再被改变\nMutable对象：拥有方法可以修改自己的值/引用\nImmutable对象：一旦被创建，始终指向同一个值/引用\nFinal类：\n（1）无法派生出子类\n（2）Final变量无法改变值或引用\n（3）Final方法无法被子类重写\n（4）修饰基本类型：起常量作用，基本类型的值不能改变\n（5）修饰引用类型：不能在指向其他对象，但被引用对象的值可以改变\n对可变数据类型，采取防御式拷贝——给客户端返回一个全新的对象（副本）\n对不可变数据类型，无需采用防御式拷贝（应对有多个引用的情况）\n安全的使用可变数据类型：作为局部变量，只有一个引用，不涉及共享\n·Snapshot diagram：\n用于描述程序运行时的内部状态\n·迭代器：\n对iter使用remove方法可避免mutable对象对迭代器的破坏\n注：此种不变性是在运行阶段获得的，编译阶段无法据此进行静态检查\n第五讲： 设计规约\n·specification\n客户端无需阅读调用函数的代码，只需要理解spec即可\n规约可以隔离变化，无需通知客户端\n前置条件：对客户端的约束，使用方法时必须满足的条件\n后置条件：对开发者的约束，方法结束时必须满足的条件\n契约：前置条件满足，后置条件必须满足；前置条件不满足，后置条件不一定满足\n·行为等价性\n站在客户端的角度看待行为等价性；根据规约判断行为是否等价\n静态类型声明是一种规约，可据此进行静态类型检查static checking\n方法前的注释也是一种规约，但需要人工判定其是否满足\nJavadoc：\n·比较规约：\n（1）规约的强度 （2）规约的确定性 （3）规约的陈述性\n·规约强度：\nSpec变强：更强的后置条件+更弱的前置条件\n可用更强的规约替换更弱的规约\n操作式规约：（eg.伪代码）\n声明式规约：（无内部实现的描述，只有初终状态）更有价值\n内部实现的细节不在规约里呈现，放在代码实现体内部内部的注释内呈现\n规约质量：\n·内聚的（spec描述的规约单一、简单、易理解）\n·信息丰富的（不能让客户端产生理解的歧义）\n·既足够强又足够弱\n第六讲： 抽象数据类型\nADT特性：表示泄漏、抽象函数AF、表示不变量RI\nADT由操作定义，与其内部如何实现无关\n不变数据类型：其操作不改变内部值，而是构造新的对象\n·ADT操作的四种类型：\n构造器：可能实现为构造函数或静态函数\n生产器：由旧对象产生新对象\n观察器\n变值器\n测试creator、producer、mutator时用observer来观察这些操作是否的结果是否满足spec\n测试observer时用creator、producer、mutator等方法产生或改变对象，来看结果是否正确\n·表示独立性\n客户端使用ADT时无需考虑其内部是如何实现的，ADT内部表示的变化不应影响外部spec和客户端。\n·不变量\n在任何时候总是true，由ADT负责其不变量，与客户端的任何操作均无关\n（immutability即是一个典型的不变量）\n·表示泄漏\n不仅影响不变性，也影响表示独立性；无法在不影响客户端的情况下改变其内部表示！\n使用immutable对象，可彻底的避免表示泄漏！\n·表示空间、抽象空间、AF\nADT开发者关注R，client关注A\n满射！！！\nAF：R --> A\n·RI（表示不变性）\n所有表示值的一个子集，包含了所有合法的表示值\n选择某种特定的表示方式R，进而指定某个子集是合法的（RI），并为该子集中的每个值做出解释（AF）\n·设计ADT：\n（1）选择R和A （2）RI：合法的表示值 （3）如何解释合法的表示值：映射AF\n·随时检查RI是否满足\n在所有可能会改变rep的方法中都要检查\n·在代码中以注释的形式记录AF、RI\n要精确记录的RI：rep中的所有fields何为有效\n要精确记录的AF：如何解释每一个R值\n表示泄漏的安全声明：给出理由，证明代码并未对外泄漏其内部表示\nADT的规约里只能使用client可见的内容来撰写，包含参数、返回值、异常等\n若规约里提及值，则只能采用A空间中的值\n在代码中以注释的形式写出AF和RI而不能在javadoc文档中，防止被外部看到而破坏表示独立性\n构造器和生产器在创建对象时要确保不变量为true\n变值器和观察器在执行时必须保持不变性\n在每个方法return前，用checkRep()检查不变量是否得以保持\n第七讲： 面向对象编程\n·interface、class\n定义、实现ADT\n接口：确定ADT规约\n（java interface cannot have constructors）\n类：实现ADT\n接口中的静态工厂方法\n使用接口类型声明变量，客户端仅使用接口中定义的方法，客户端无法直接访问属性\n·inheritance & override\n重写的函数：与父类或接口完全相同的signature；实际执行时调用哪个函数，运行时决定\n若父类型中的某个函数体的实现为空，说明其所有子类型都需要这个功能，但各有差异，无共性，在每个子类中均需要重写\n重写过后，使用supper()复用父类型中函数的功能，并对其进行扩展\n·多态 & overload\n（1）特殊多态：功能重载\n（2）参数化多态：使用泛型\n（3）子类型多态：不同类型的对象可以统一处理，无需区分，从而隔离了变化；LSP原则\nB is a subtype of A means that every B is A；every B satisfies the spec of A\n子类型的spec不能弱化父类型的spec\n第八讲： ADT和OOP中的等价性\n·等价性\n基于AF定义ADT的等价操作——AF映射到相同的结果，则等价\n等价关系：自反、传递、对称\n·equals( )和==\n：引用等价性\n两个对象指向内存的同一段空间时，这两者引用等价\nEquals( )：对象等价性\n具有相同的内容\n自定义ADT时要重写Object类的equals方法\n在object类中实现的缺省equals是在判断引用等价性！\n对基本数据类型，使用\n判断相等\n对对象类型，使用equals判断相等（eg.String）\n重写equals的正确姿势\n其中instanceof操作符用于判断类的一致性\n·Equals等价关系：自反、对称、传递\n用是否为等价关系检验equals是否正确\n·hashCode( )\n“相等”的对象，其hashCode的结果一定相同\n两个equals的对象，一定要有同样的hashCode（除非你能保证你的ADT不会被放置到hash类型的集合类中！）\n·可变对象的观察等价性、行为等价性：\n观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致\n行为等价性：调用对象的任何方法都展示出一致的结果\n若某个mutable的对象包含在Set集合类当中，当其发生改变后，集合类的行为不确定\n对所有可变类型对象，实现行为等价性即可，也就是说只有指向相同内存空间的objects才是相等的；对所有mutable类型的对象，无需重写hashCode和equals方法，直接继承Object类的两个方法即可\n·不可变对象的引用等价性、对象等价性：\n不可变对象需重写equals方法及hashCode方法\n"
  },
  {
    "head": "Java按行读取文件内容：简要方法介绍和实例演示",
    "paragraphs": [
      "Java 按行读取文件内容：简要方法介绍和实例演示",
      "1、使用到的相关方法和类简介",
      "public FileInputStream(File file) throws FileNotFoundException",
      "Creates a FileInputStream by opening a connection to an actual file, the file named by the File object file in the file system. A new FileDescriptor object is created to represent this file connection.",
      "If the named file does not exist, is a directory rather than a regular",
      "file, or for some other reason cannot be opened for reading then a",
      "FileNotFoundException - if the file does not exist, is a directory",
      "rather than a regular file, or for some other reason cannot be opened",
      "for reading. SecurityException - if a security manager exists and its",
      "checkRead method denies read access to the file.",
      "这是查阅的java原始库中的描述，简单介绍就是传入参数file，试图通过关联一个具体的文件建立一个文件输入流，如果文件名字不存在、无法被打开或是无法被阅读，那么就抛出异常。",
      "建立文件输入流后，进一步需要建立BufferedReader对象来对文件输入进行读取。以下给出java原文档给出的实例，其中传入BufferedReader的参数还可以是InputStreamReader等输入流。",
      "BufferedReader in",
      "= new BufferedReader(new FileReader(“foo.in”));",
      "建立好字符读入后，便可以调用其中的方法进行按行读取内容。这里主要给出一个之后需要用到的方法，也就是按行读取一个字符串。",
      "String readLine() Reads a line of text.",
      "2、实例演示",
      "这段代码处理的是读取文件中的不含负数和小数的矩阵，按行对矩阵进行处理，最终将矩阵保存在input中，方便后续进一步处理。代码中的fileName便是读入文件的路径。"
    ],
    "sentences": [
      "Java 按行读取文件内容：简要方法介绍和实例演示",
      "1、使用到的相关方法和类简介",
      "public FileInputStream(File file) throws FileNotFoundException",
      "Creates a FileInputStream by opening a connection to an actual file, the file named by the File object file in the file system. A new FileDescriptor object is created to represent this file connection.If the named file does not exist, is a directory rather than a regular",
      "file, or for some other reason cannot be opened for reading then a",
      "FileNotFoundException - if the file does not exist, is a directory",
      "rather than a regular file, or for some other reason cannot be opened",
      "for reading. SecurityException - if a security manager exists and its",
      "checkRead method denies read access to the file.这是查阅的java原始库中的描述",
      "简单介绍就是传入参数file",
      "试图通过关联一个具体的文件建立一个文件输入流",
      "如果文件名字不存在、无法被打开或是无法被阅读",
      "那么就抛出异常",
      "建立文件输入流后",
      "进一步需要建立BufferedReader对象来对文件输入进行读取",
      "以下给出java原文档给出的实例",
      "其中传入BufferedReader的参数还可以是InputStreamReader等输入流",
      "BufferedReader in",
      "= new BufferedReader(new FileReader(“foo.in”));建立好字符读入后",
      "便可以调用其中的方法进行按行读取内容",
      "这里主要给出一个之后需要用到的方法，也就是按行读取一个字符串",
      "String readLine() Reads a line of text.2、实例演示",
      "这段代码处理的是读取文件中的不含负数和小数的矩阵",
      "按行对矩阵进行处理",
      "最终将矩阵保存在input中",
      "方便后续进一步处理",
      "代码中的fileName便是读入文件的路径"
    ],
    "codes": [
      "\t\tFile fileInput = new File(fileName);\n\t\tArrayList<ArrayList<Integer>> input = new ArrayList<ArrayList<Integer>>();\n\t\tString str = new String();\n\t\tint i = 0;\n\t\ttry {\n\t\t\tFileInputStream file = new FileInputStream(fileInput);\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(file, \"UTF-8\"));// 构造一个BufferedReader类来读取文件\n\t\t\twhile ((str = br.readLine()) != null) {\n\t\t\t\tArrayList<Integer> e = new ArrayList<Integer>();\n\t\t\t\tinput.add(e);\n\t\t\t\t// System.out.println(str);\n\t\t\t\tfor (String a : str.split(\"\\t\")) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif(Integer.parseInt(a)<0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"输入中含有负数\");\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinput.get(i).add(Integer.parseInt(a));\n\t\t\t\t\t} catch (Exception w) {\n\t\t\t\t\t\tSystem.out.println(\"非法输入格式或内容\");\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"读入文件错误\");\n\t\t\treturn null;\n\t\t}\n",
      "FileNotFoundException is thrown.",
      "Parameters:",
      "file - the file to be opened for reading.",
      "Throws:"
    ],
    "date": "2021-07-05",
    "text": "Java 按行读取文件内容：简要方法介绍和实例演示\n1、使用到的相关方法和类简介\npublic FileInputStream(File file) throws FileNotFoundException\nCreates a FileInputStream by opening a connection to an actual file, the file named by the File object file in the file system. A new FileDescriptor object is created to represent this file connection.\nIf the named file does not exist, is a directory rather than a regular\nfile, or for some other reason cannot be opened for reading then a\nFileNotFoundException - if the file does not exist, is a directory\nrather than a regular file, or for some other reason cannot be opened\nfor reading. SecurityException - if a security manager exists and its\ncheckRead method denies read access to the file.\n这是查阅的java原始库中的描述，简单介绍就是传入参数file，试图通过关联一个具体的文件建立一个文件输入流，如果文件名字不存在、无法被打开或是无法被阅读，那么就抛出异常。\n建立文件输入流后，进一步需要建立BufferedReader对象来对文件输入进行读取。以下给出java原文档给出的实例，其中传入BufferedReader的参数还可以是InputStreamReader等输入流。\nBufferedReader in\n= new BufferedReader(new FileReader(“foo.in”));\n建立好字符读入后，便可以调用其中的方法进行按行读取内容。这里主要给出一个之后需要用到的方法，也就是按行读取一个字符串。\nString readLine() Reads a line of text.\n2、实例演示\n这段代码处理的是读取文件中的不含负数和小数的矩阵，按行对矩阵进行处理，最终将矩阵保存在input中，方便后续进一步处理。代码中的fileName便是读入文件的路径。\n"
  },
  {
    "head": "在Eclipse中使用Junit测试代码",
    "paragraphs": [
      "一、在项目中加入Junit库",
      "右击项目文件，在选项中选择BuildPath这一选项。",
      "选择Add Libbraries选项，在其中找到Junit，可以自行选择需要的Junit版本。",
      "当你的项目中除了之前的基础库文件，还出现了Junit库，说明已经添加完成了。",
      "二、Junit代码的构建",
      "以我之前对构建的图的类为例说明Junit代码的基本思路。",
      "首先对于任何用于测试的函数，都需要加上@Test标签，否则Eclipse不会识别你的测试方法，运行时不会执行。",
      "然后重点使用assertEquals函数，这个函数前一个参数是给定的正确结果，后一个参数是你要测试方法的返回结果。只有当两者相同，测试的结果才会是正确的。",
      "正确的结果将被标注为绿色，红色代表有运行错误，蓝色代表assertEquals结果出现错误，可以进一步进行检查。",
      "比如以下这个例子",
      "这一测试出现蓝色，双击这一内容进行检查。",
      "发现以下错误信息。",
      "双击上面一行进一步对比结果。",
      "可以看到详细的比较结果，然后返回查看代码的运行情况，进行debug。",
      "3、使用注意",
      "(1)当使用Junit时如果代码中包含有exit函数，测试程序会直接卡死，网上有一些处理方式，详细可以查看",
      "https://blog.csdn.net/weixin_43872188/article/details/104781255",
      "(2)如果函数没有返回值可以进行比较，可以在类中定义相关的观察者方法，比如重写toString函数，当成检查的方式。",
      "(3)测试类也可以进行继承，并且子类如果没有重写父类中的测试函数，子类会自动执行父类的测试。",
      "举例：",
      "可以看到这一类中只写了三个测试方法。",
      "运行后可以看到执行了一些其他函数，而这些函数恰恰就是父类中的测试函数。"
    ],
    "sentences": [
      "一、在项目中加入Junit库",
      "右击项目文件，在选项中选择BuildPath这一选项",
      "选择Add Libbraries选项",
      "在其中找到Junit",
      "可以自行选择需要的Junit版本",
      "当你的项目中除了之前的基础库文件",
      "还出现了Junit库",
      "说明已经添加完成了",
      "二、Junit代码的构建",
      "以我之前对构建的图的类为例说明Junit代码的基本思路",
      "首先对于任何用于测试的函数",
      "都需要加上@Test标签",
      "否则Eclipse不会识别你的测试方法",
      "运行时不会执行",
      "然后重点使用assertEquals函数",
      "这个函数前一个参数是给定的正确结果",
      "后一个参数是你要测试方法的返回结果",
      "只有当两者相同，测试的结果才会是正确的",
      "正确的结果将被标注为绿色",
      "红色代表有运行错误",
      "蓝色代表assertEquals结果出现错误",
      "可以进一步进行检查",
      "比如以下这个例子",
      "这一测试出现蓝色，双击这一内容进行检查",
      "发现以下错误信息",
      "双击上面一行进一步对比结果",
      "可以看到详细的比较结果",
      "然后返回查看代码的运行情况",
      "进行debug",
      "3、使用注意",
      "(1)当使用Junit时如果代码中包含有exit函数",
      "测试程序会直接卡死",
      "网上有一些处理方式",
      "详细可以查看",
      "https://blog.csdn.net/weixin_43872188/article/details/104781255",
      "(2)如果函数没有返回值可以进行比较",
      "可以在类中定义相关的观察者方法",
      "比如重写toString函数",
      "当成检查的方式",
      "(3)测试类也可以进行继承",
      "并且子类如果没有重写父类中的测试函数",
      "子类会自动执行父类的测试",
      "举例：可以看到这一类中只写了三个测试方法",
      "运行后可以看到执行了一些其他函数",
      "而这些函数恰恰就是父类中的测试函数"
    ],
    "codes": [
      "    @Test\n    public void testSet()\n    {\n    \tGraph<String> current=emptyInstance();\n    \t//测试错误输入负的权值\n    \tassertEquals(-1,current.set(\"A\", \"B\", -1));\n    \tassertEquals(false,current.vertices().contains(\"A\"));\n    \tassertEquals(false,current.vertices().contains(\"B\"));\n    \tassertEquals(false,current.targets(\"A\").containsKey(\"B\"));\n    \t//测试权值不为0，图中没有这两点也没有这条边的情况，返回值应该是零，并且两个点应该已经被插入到图中，这条边也已经被插入到图中\n    \tassertEquals(0,current.set(\"A\", \"B\", 1));\n    \tassertEquals(true,current.vertices().contains(\"A\"));\n    \tassertEquals(true,current.vertices().contains(\"B\"));\n    \tassertEquals(true,current.targets(\"A\").containsKey(\"B\"));\n    \t//测试权值不为零，图中已经存在这两点的情况，返回值应该是1（同时完成对先前加入的边的权值的查看）\n    \tassertEquals(1,current.set(\"A\", \"B\", 2));\n    \t//测试权值为0，图中已经存在这两点的情况，返回值应该是2，并且这条边已经被删除\n    \tassertEquals(2,current.set(\"A\", \"B\", 0));\n      \tassertEquals(false,current.targets(\"A\").containsKey(\"B\"));\n    \t//测试权值不为零，图中有这两个点，但是没有这样的边的情况，返回值应该是0，并且这条边已经被添加\n    \tassertEquals(0,current.set(\"A\", \"B\", 2));\n    \tassertEquals(true,current.targets(\"A\").containsKey(\"B\"));\n    \t//测试权值为0，图中没有这两点也没有这条边的情况，返回值应该是0，但是同时没有对这两个点进行插入操作，也没有对这条边进行插入\n    \tassertEquals(0,current.set(\"C\", \"D\", 0));\n    \tassertEquals(false,current.vertices().contains(\"C\"));\n    \tassertEquals(false,current.vertices().contains(\"D\"));\n    \tassertEquals(false,current.targets(\"C\").containsKey(\"D\"));\n    }\n"
    ],
    "date": "2021-07-05",
    "text": "一、在项目中加入Junit库\n右击项目文件，在选项中选择BuildPath这一选项。\n选择Add Libbraries选项，在其中找到Junit，可以自行选择需要的Junit版本。\n当你的项目中除了之前的基础库文件，还出现了Junit库，说明已经添加完成了。\n二、Junit代码的构建\n以我之前对构建的图的类为例说明Junit代码的基本思路。\n首先对于任何用于测试的函数，都需要加上@Test标签，否则Eclipse不会识别你的测试方法，运行时不会执行。\n然后重点使用assertEquals函数，这个函数前一个参数是给定的正确结果，后一个参数是你要测试方法的返回结果。只有当两者相同，测试的结果才会是正确的。\n正确的结果将被标注为绿色，红色代表有运行错误，蓝色代表assertEquals结果出现错误，可以进一步进行检查。\n比如以下这个例子\n这一测试出现蓝色，双击这一内容进行检查。\n发现以下错误信息。\n双击上面一行进一步对比结果。\n可以看到详细的比较结果，然后返回查看代码的运行情况，进行debug。\n3、使用注意\n(1)当使用Junit时如果代码中包含有exit函数，测试程序会直接卡死，网上有一些处理方式，详细可以查看\nhttps://blog.csdn.net/weixin_43872188/article/details/104781255\n(2)如果函数没有返回值可以进行比较，可以在类中定义相关的观察者方法，比如重写toString函数，当成检查的方式。\n(3)测试类也可以进行继承，并且子类如果没有重写父类中的测试函数，子类会自动执行父类的测试。\n举例：\n可以看到这一类中只写了三个测试方法。\n运行后可以看到执行了一些其他函数，而这些函数恰恰就是父类中的测试函数。\n"
  },
  {
    "head": "格式化日期的转化",
    "paragraphs": [
      "1、格式化字符串日期转化为可计算可比较日期",
      "应用场景：如果时间的输入参数是一个字符串，那么比较两个日期就比较困难，计算两个日期之间差了多长时间更困难。",
      "经过查阅资料，发现日期可以通过字符串转化成long型的时间，这个时间表示的是从1970-1-1开始的毫秒时间。",
      "代码如下：",
      "这里输入日期的格式需要为“年-月-日”，对于不同的应用场景，只需修改格式串中的字符串。如果格式错误，会给出提示信息，并且退出运行，这个报错机制也可自行修改。",
      "2、long型毫秒时间转化回字符串时间",
      "虽然long型的时间方便计算，但是字符串的时间方便观察，所以也需要将其转化回来。",
      "3、将字符串日期转化成星期",
      "这个函数的原型得到的day结果是，星期日：1，星期一到星期六：2-7，这里是为了方便处理我进行了转化。",
      "在学习这一部分内容时，我主要参考了：",
      "https://blog.csdn.net/dashenmepi/article/details/108725254"
    ],
    "sentences": [
      "1、格式化字符串日期转化为可计算可比较日期",
      "应用场景：如果时间的输入参数是一个字符串",
      "那么比较两个日期就比较困难",
      "计算两个日期之间差了多长时间更困难",
      "经过查阅资料",
      "发现日期可以通过字符串转化成long型的时间",
      "这个时间表示的是从1970-1-1开始的毫秒时间",
      "代码如下：这里输入日期的格式需要为“年-月-日”",
      "对于不同的应用场景",
      "只需修改格式串中的字符串",
      "如果格式错误",
      "会给出提示信息",
      "并且退出运行",
      "这个报错机制也可自行修改",
      "2、long型毫秒时间转化回字符串时间",
      "虽然long型的时间方便计算",
      "但是字符串的时间方便观察",
      "所以也需要将其转化回来",
      "3、将字符串日期转化成星期",
      "这个函数的原型得到的day结果是",
      "星期日：1",
      "星期一到星期六：2-7",
      "这里是为了方便处理我进行了转化",
      "在学习这一部分内容时",
      "我主要参考了：https://blog.csdn.net/dashenmepi/article/details/108725254"
    ],
    "codes": [
      "public long parseTime(String date)\n{\n\tDateFormat dft = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tlong time=0;\n\ttry {\n\t\t   Date d = dft.parse(date);\n\t       time=d.getTime();\n\t} catch (ParseException e) {\n\t      System.out.println(\"时间错误\");\n\t      System.exit(0);\n\t}\n\treturn time;\n}\n",
      "public String timeToString(long time)\n{\n\tDateFormat dft = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tDate reparse=new Date();\n    reparse.setTime(time);\n    return dft.format(reparse);\n}\n",
      "\t/**\n\t * 将字符串类型的时间信息转化成具体的星期几\n\t * @param time 字符串类型的时间\n\t * @return 周一到周五0-4，周六5，周日6\n\t */\n\tpublic int parseTime(String time)\n\t{\n\t\tDateFormat dft = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\tint day=0;\n\t\ttry {\n\t\t\t   Date d = dft.parse(time);\n\t\t       Calendar cal = Calendar.getInstance();\n\t\t       cal.setTime(d);\n\t\t       day = cal.get(Calendar.DAY_OF_WEEK);\n\t\t} catch (ParseException e) {\n\t\t       System.out.println(\"错误时间信息\");\n\t\t       System.exit(0);\n\t\t}\n\t\tif(day==1)\n\t\t{\n\t\t\treturn 6;\n\t\t}\n\t\treturn day-2;\n\t}\n"
    ],
    "date": "2021-07-05",
    "text": "1、格式化字符串日期转化为可计算可比较日期\n应用场景：如果时间的输入参数是一个字符串，那么比较两个日期就比较困难，计算两个日期之间差了多长时间更困难。\n经过查阅资料，发现日期可以通过字符串转化成long型的时间，这个时间表示的是从1970-1-1开始的毫秒时间。\n代码如下：\n这里输入日期的格式需要为“年-月-日”，对于不同的应用场景，只需修改格式串中的字符串。如果格式错误，会给出提示信息，并且退出运行，这个报错机制也可自行修改。\n2、long型毫秒时间转化回字符串时间\n虽然long型的时间方便计算，但是字符串的时间方便观察，所以也需要将其转化回来。\n3、将字符串日期转化成星期\n这个函数的原型得到的day结果是，星期日：1，星期一到星期六：2-7，这里是为了方便处理我进行了转化。\n在学习这一部分内容时，我主要参考了：\nhttps://blog.csdn.net/dashenmepi/article/details/108725254\n"
  },
  {
    "head": "Git中较为常见的命令和错误",
    "paragraphs": [
      "一、常用指令",
      "1、将自己本地的代码上传到自己的github仓库中",
      "这些指令是常常用来将自己本地代码推送到master分支的操作。",
      "2、新建分支",
      "这是用来新建分支，并将内容推送到新分支上的操作。",
      "3、查看当前提交信息",
      "第一条指令用于查看当前分支提交记录，第二条指令可以给出当前分支更加完整的先后顺序信息，第三条可以给出所有分支的提交信息和结构。",
      "二、问题及解决方案",
      "1、在github上的文件夹出现白色箭头，无法进入访问",
      "问题原因：文件夹内部有.git的隐藏文件，可以通过查看隐藏文件的选项在文件管理器中查看。github因此将其视为子模块。",
      "解决方案：",
      "（1）删除文件夹里面的.git文件夹",
      "（2）执行git rm --cached [文件夹名]",
      "（3）执行git add [文件夹名]",
      "（4）执行git commit -m “msg”",
      "（5）执行git push origin [branch_name]",
      "概括来说就是先删除文件夹里的.git文件，重新将其push到仓库。",
      "2、GitHub提交的时显示Updates were rejected because the remote contains work that you do",
      "问题原因：此问题原因较多，但根本原因是远程仓库中的文件有部分本地库中没有。",
      "解决方法：",
      "git pull origin master //把远程仓库master分支拉取到本地仓库master分支",
      "但是如果改动很大，比如直接在两个不同的文件夹下进行push操作，即使进行pull也可能出现其他问题。",
      "比如，refusing to merge unrelated histories",
      "解决方案：",
      "git pull origin master --allow-unrelated-histories",
      "以上是我在学习过程中遇到的问题和使用的情况，学习时主要参考了以下内容：",
      "https://blog.csdn.net/u012308586/article/details/104905828",
      "https://blog.csdn.net/u012145252/article/details/80628451",
      "https://blog.csdn.net/xiebaochun/article/details/114143346"
    ],
    "sentences": [
      "一、常用指令",
      "1、将自己本地的代码上传到自己的github仓库中",
      "这些指令是常常用来将自己本地代码推送到master分支的操作",
      "2、新建分支",
      "这是用来新建分支，并将内容推送到新分支上的操作",
      "3、查看当前提交信息",
      "第一条指令用于查看当前分支提交记录",
      "第二条指令可以给出当前分支更加完整的先后顺序信息",
      "第三条可以给出所有分支的提交信息和结构",
      "二、问题及解决方案",
      "1、在github上的文件夹出现白色箭头，无法进入访问",
      "问题原因：文件夹内部有.git的隐藏文件",
      "可以通过查看隐藏文件的选项在文件管理器中查看",
      "github因此将其视为子模块",
      "解决方案：（1）删除文件夹里面的.git文件夹",
      "（2）执行git rm --cached [文件夹名]",
      "（3）执行git add [文件夹名]",
      "（4）执行git commit -m “msg”",
      "（5）执行git push origin [branch_name]",
      "概括来说就是先删除文件夹里的.git文件",
      "重新将其push到仓库",
      "2、GitHub提交的时显示Updates were rejected because the remote contains work that you do",
      "问题原因：此问题原因较多",
      "但根本原因是远程仓库中的文件有部分本地库中没有",
      "解决方法：git pull origin master //把远程仓库master分支拉取到本地仓库master分支",
      "但是如果改动很大",
      "比如直接在两个不同的文件夹下进行push操作",
      "即使进行pull也可能出现其他问题",
      "比如",
      "refusing to merge unrelated histories",
      "解决方案：git pull origin master --allow-unrelated-histories",
      "以上是我在学习过程中遇到的问题和使用的情况",
      "学习时主要参考了以下内容：https://blog.csdn.net/u012308586/article/details/104905828",
      "https://blog.csdn.net/u012145252/article/details/80628451",
      "https://blog.csdn.net/xiebaochun/article/details/114143346"
    ],
    "codes": [
      "git init                        //初始化仓库\ngit add  .                   //添加文件到本地暂存区    或用  git add   (文件name)\ngit commit -m “first commit”       //提交到本地仓库\ngit remote add origin    远程仓库地址            //添加远程仓库 \ngit push -u origin master                                //把本地仓库的master分支推送到远程仓库master分支\n",
      "…最初在 master 上工作…\ngit checkout -b change 创建新分支同时也切换到了change分支\n比如现在想要将内容推送到change分支\ngit add *\ngit commit -m \"change\"在该分支上提交\ngit push origin change\ngit checkout master 切换回 master 分支\n",
      "git log\ngit log --graph\ngit log --graph --all\n"
    ],
    "date": "2021-07-05",
    "text": "一、常用指令\n1、将自己本地的代码上传到自己的github仓库中\n这些指令是常常用来将自己本地代码推送到master分支的操作。\n2、新建分支\n这是用来新建分支，并将内容推送到新分支上的操作。\n3、查看当前提交信息\n第一条指令用于查看当前分支提交记录，第二条指令可以给出当前分支更加完整的先后顺序信息，第三条可以给出所有分支的提交信息和结构。\n二、问题及解决方案\n1、在github上的文件夹出现白色箭头，无法进入访问\n问题原因：文件夹内部有.git的隐藏文件，可以通过查看隐藏文件的选项在文件管理器中查看。github因此将其视为子模块。\n解决方案：\n（1）删除文件夹里面的.git文件夹\n（2）执行git rm --cached [文件夹名]\n（3）执行git add [文件夹名]\n（4）执行git commit -m “msg”\n（5）执行git push origin [branch_name]\n概括来说就是先删除文件夹里的.git文件，重新将其push到仓库。\n2、GitHub提交的时显示Updates were rejected because the remote contains work that you do\n问题原因：此问题原因较多，但根本原因是远程仓库中的文件有部分本地库中没有。\n解决方法：\ngit pull origin master //把远程仓库master分支拉取到本地仓库master分支\n但是如果改动很大，比如直接在两个不同的文件夹下进行push操作，即使进行pull也可能出现其他问题。\n比如，refusing to merge unrelated histories\n解决方案：\ngit pull origin master --allow-unrelated-histories\n以上是我在学习过程中遇到的问题和使用的情况，学习时主要参考了以下内容：\nhttps://blog.csdn.net/u012308586/article/details/104905828\nhttps://blog.csdn.net/u012145252/article/details/80628451\nhttps://blog.csdn.net/xiebaochun/article/details/114143346\n"
  },
  {
    "head": "Java正则表达式实例讲解",
    "paragraphs": [
      "Java正则表达式实例讲解",
      "首先观察本次需要读取的文件的内容",
      "本段是一组排班人员的信息，第一部分是员工的信息包括其姓名、职称和电话，第二部分是值班表的开始时间和结束时间，第三部分是员工将要被放在排班表的位置信息。",
      "我们的目标是将以上介绍的信息全部读取出来。",
      "首先处理第一部分，我们最终要获得的是员工的姓名、职称和手机号，在对其所处部分进行对应后，建立以下正则表达式。",
      "第一行用于匹配Employee的第一行，也就是对应开始读入员工信息。",
      "表达式含义:",
      "\\\\s代表任何空白字符，包括空格、制表符、换页符等。",
      "后面跟一个*代表此空白符可以重复多次，或者一次也没有。与之类似的有+这个符号，表示这个位置至少有一个这样的字符。",
      "\\{代表匹配大括号，注意在正则表达式中{带有格式说明的意思，所以为了表示其本身也需要加上\\\\。",
      "第二行用于匹配后面真正的员工信息。",
      "表达式含义：",
      "这次与上次的式子不同，加入了（）括住了部分内容，括住的部分就代表将要在后面提取的内容，从前到后序号依次从一开始，在后面将通过这一顺序提取信息。",
      "[]括住的内容表示这一位置可能出现的字符，加上^代表除了这一字符的其他字符。",
      "后面\\\\d代表一个数字字符，与[0-9]相同，后面加上{3}代表重复三次，也就是按照文件中3-4-4的顺序进行提取。",
      "最后一个\\\\D*代表非数字字符的重复或空。",
      "这样便构建了读取的正则表达式，但是想要按照表达式提取还没有完。",
      "这三句分别对应匹配后面三种句式，其中的内容与前面相似，我就不再详细介绍了。",
      "其中[0-9|-]，代表这一处可以是0-9的数字字符或是“-”这一字符，表示或者关系，采用|即可，表示范围可以使用 头-尾。",
      "用于匹配正则表达式的字符串规则构建完成，后面就是提取目标信息。",
      "创建Pattern对象对正则表达式进行解析。",
      "创建Matcher对象对读入字符串进行组捕获，之前在正则表达式中，我构建了五小括号，其中对应的内容分别保存在了group(1)到group(5)。group(0)中保存的式整个捕获的字符串。",
      "这些是提取后的内容，其中还有其他内部处理，这里只是简单验证正确性。",
      "我学习这部分内容主要参考的网址：",
      "https://www.runoob.com/java/java-regular-expressions.html",
      "里面内容比较全面，大家可以把我的当成一个实例来看。"
    ],
    "sentences": [
      "Java正则表达式实例讲解",
      "首先观察本次需要读取的文件的内容",
      "本段是一组排班人员的信息",
      "第一部分是员工的信息包括其姓名、职称和电话",
      "第二部分是值班表的开始时间和结束时间",
      "第三部分是员工将要被放在排班表的位置信息",
      "我们的目标是将以上介绍的信息全部读取出来",
      "首先处理第一部分",
      "我们最终要获得的是员工的姓名、职称和手机号",
      "在对其所处部分进行对应后",
      "建立以下正则表达式",
      "第一行用于匹配Employee的第一行",
      "也就是对应开始读入员工信息",
      "表达式含义:\\\\s代表任何空白字符",
      "包括空格、制表符、换页符等",
      "后面跟一个*代表此空白符可以重复多次，或者一次也没有",
      "与之类似的有+这个符号，表示这个位置至少有一个这样的字符",
      "\\{代表匹配大括号",
      "注意在正则表达式中{带有格式说明的意思",
      "所以为了表示其本身也需要加上\\\\",
      "第二行用于匹配后面真正的员工信息",
      "表达式含义：这次与上次的式子不同",
      "加入了（）括住了部分内容",
      "括住的部分就代表将要在后面提取的内容",
      "从前到后序号依次从一开始",
      "在后面将通过这一顺序提取信息",
      "[]括住的内容表示这一位置可能出现的字符",
      "加上^代表除了这一字符的其他字符",
      "后面\\\\d代表一个数字字符",
      "与[0-9]相同",
      "后面加上{3}代表重复三次",
      "也就是按照文件中3-4-4的顺序进行提取",
      "最后一个\\\\D*代表非数字字符的重复或空",
      "这样便构建了读取的正则表达式，但是想要按照表达式提取还没有完",
      "这三句分别对应匹配后面三种句式",
      "其中的内容与前面相似",
      "我就不再详细介绍了",
      "其中[0-9|-]",
      "代表这一处可以是0-9的数字字符或是“-”这一字符",
      "表示或者关系",
      "采用|即可",
      "表示范围可以使用 头-尾",
      "用于匹配正则表达式的字符串规则构建完成，后面就是提取目标信息",
      "创建Pattern对象对正则表达式进行解析",
      "创建Matcher对象对读入字符串进行组捕获",
      "之前在正则表达式中",
      "我构建了五小括号",
      "其中对应的内容分别保存在了group(1)到group(5)",
      "group(0)中保存的式整个捕获的字符串",
      "这些是提取后的内容",
      "其中还有其他内部处理",
      "这里只是简单验证正确性",
      "我学习这部分内容主要参考的网址：https://www.runoob.com/java/java-regular-expressions.html",
      "里面内容比较全面，大家可以把我的当成一个实例来看"
    ],
    "codes": [
      "String employeeEntrance=\"\\\\s*Employee\\\\{\\\\s*\";\nString employeePattern=\"\\\\s*([^\\\\{]*)\\\\{([^,]*),(\\\\d{3})-(\\\\d{4})-(\\\\d{4})\\\\D*\";\n",
      "String periodPattern=\"Period\\\\{([0-9|-]*),([0-9|-]*)\\\\}\";\nString rosterEntrance=\"Roster\\\\{\\\\s*\";\nString rosterPattern=\"\\\\s*([^\\\\{]*)\\\\{([0-9|-]*),([0-9|-]*)\\\\}\";\n",
      "Pattern employee = Pattern.compile(employeeEntrance);\nPattern emessage = Pattern.compile(employeePattern);\nPattern period=Pattern.compile(periodPattern);\nPattern roster=Pattern.compile(rosterEntrance);\nPattern rmessage=Pattern.compile(rosterPattern);\n",
      "Matcher message = emessage.matcher(str);\nwhile(message.find())\n{\n\tString name=message.group(1).substring(2);\n        String position=message.group(2);\n        String phone=message.group(3)+message.group(4)+message.group(5);\n        Stuff s=new Stuff(name,phone,position);\n        addStuff(s);\n        str=br.readLine();\n        message=emessage.matcher(str);\n}\n",
      "Employee{",
      "ZhangSan{Manger,139-0451-0000}",
      "LiSi{Secretary,151-0101-0000}",
      "WangWu{Associate Dean,177-2021-0301}",
      "ZhaoLiua{Professor,138-1920-3912}",
      "ZhaoLiub{Lecturer,138-1921-3912}",
      "ZhaoLiuc{Professor,138-1922-3912}",
      "ZhaoLiud{Lecturer,198-1920-3912}",
      "ZhaoLiue{Professor,178-1920-3912}",
      "ZhaoLiuf{Lecturer,138-1929-3912}",
      "ZhaoLiug{Professor,138-1920-0000}",
      "ZhaoLiuh{AssciateProfessor,138-1929-0000}",
      "ZhaoLiui{Professor,138-1920-0200}",
      "ZhaoLiuj{AssciateProfessor,138-1920-0044}",
      "ZhaoLiuk{Professor,188-1920-0000}",
      "Period{2021-01-10,2021-03-06}",
      "Roster{",
      "ZhangSan{2021-01-10,2021-01-11}",
      "LiSi{2021-01-12,2021-01-20}",
      "WangWu{2021-01-21,2021-01-21}",
      "ZhaoLiua{2021-01-22,2021-01-22}",
      "ZhaoLiub{2021-01-23,2021-01-29}",
      "ZhaoLiuc{2021-01-30,2021-01-31}",
      "ZhaoLiud{2021-02-01,2021-02-08}",
      "ZhaoLiue{2021-02-09,2021-02-15}",
      "ZhaoLiuf{2021-02-16,2021-02-24}",
      "ZhaoLiug{2021-02-25,2021-02-28}",
      "ZhaoLiuh{2021-03-01,2021-03-01}",
      "ZhaoLiui{2021-03-02,2021-03-04}",
      "ZhaoLiuj{2021-03-05,2021-03-05}",
      "ZhaoLiuk{2021-03-06,2021-03-06}"
    ],
    "date": "2021-07-05",
    "text": "Java正则表达式实例讲解\n首先观察本次需要读取的文件的内容\n本段是一组排班人员的信息，第一部分是员工的信息包括其姓名、职称和电话，第二部分是值班表的开始时间和结束时间，第三部分是员工将要被放在排班表的位置信息。\n我们的目标是将以上介绍的信息全部读取出来。\n首先处理第一部分，我们最终要获得的是员工的姓名、职称和手机号，在对其所处部分进行对应后，建立以下正则表达式。\n第一行用于匹配Employee的第一行，也就是对应开始读入员工信息。\n表达式含义:\n\\\\s代表任何空白字符，包括空格、制表符、换页符等。\n后面跟一个*代表此空白符可以重复多次，或者一次也没有。与之类似的有+这个符号，表示这个位置至少有一个这样的字符。\n\\{代表匹配大括号，注意在正则表达式中{带有格式说明的意思，所以为了表示其本身也需要加上\\\\。\n第二行用于匹配后面真正的员工信息。\n表达式含义：\n这次与上次的式子不同，加入了（）括住了部分内容，括住的部分就代表将要在后面提取的内容，从前到后序号依次从一开始，在后面将通过这一顺序提取信息。\n[]括住的内容表示这一位置可能出现的字符，加上^代表除了这一字符的其他字符。\n后面\\\\d代表一个数字字符，与[0-9]相同，后面加上{3}代表重复三次，也就是按照文件中3-4-4的顺序进行提取。\n最后一个\\\\D*代表非数字字符的重复或空。\n这样便构建了读取的正则表达式，但是想要按照表达式提取还没有完。\n这三句分别对应匹配后面三种句式，其中的内容与前面相似，我就不再详细介绍了。\n其中[0-9|-]，代表这一处可以是0-9的数字字符或是“-”这一字符，表示或者关系，采用|即可，表示范围可以使用 头-尾。\n用于匹配正则表达式的字符串规则构建完成，后面就是提取目标信息。\n创建Pattern对象对正则表达式进行解析。\n创建Matcher对象对读入字符串进行组捕获，之前在正则表达式中，我构建了五小括号，其中对应的内容分别保存在了group(1)到group(5)。group(0)中保存的式整个捕获的字符串。\n这些是提取后的内容，其中还有其他内部处理，这里只是简单验证正确性。\n我学习这部分内容主要参考的网址：\nhttps://www.runoob.com/java/java-regular-expressions.html\n里面内容比较全面，大家可以把我的当成一个实例来看。\n"
  },
  {
    "head": "[HIT]哈工大2021软件构造学习心得",
    "paragraphs": [
      "复习了一遍软件构造的概念，对这门课的学习方式和学习内容也有了些体会和心得，给大家分享下我的感受。",
      "第一就是这是门编程课，所以一定要动手！！！一定要动手！！！一定要动手！！！个人评判目前学过的四门编程课，动手要求能力：C语言程序设计>软件构造>数据结构>算法设计。编程课不去敲代码是绝对不行的，哪怕你不去上课，习题课的内容、实验课的内容你也要亲自动手去敲。因为很多东西你只学理论是永远学不明白的，就像教你竖式乘法你却不去动手计算。Lab3我想对于绝大多数同学都是个很大的挑战，但也是这个实验中，我对继承、抽象类、具体类、接口等等各种概念才有了自己的认识。多动手，才是学好这门课的最主要途径！",
      "第二，这门课的先修真的太重要了。没学过Java和Git的我从第一节课就开始懵，直接懵到考试前，所以建议学弟学妹们，在学习数据结构，或者更早的时候，顺道就给Java学了吧。而且学了Java才后知后觉，用Java实现数据结构里的链表、树、图有多么轻松！想想当初C语言折磨得我...悔不当初。所以，有空早学Java，早晚都要学的！",
      "我觉得以上两点就是能确保你学好这门课的全部要素了，当然我哪点做的都不好...但是期末了，三个Lab都写完了，复习也复习过一遍了，突然发现这门课是一门越学的深入越能感受到其巧妙的课程。我想每个同学Lab1和第一次习题课写的代码现在如果再找出来，都能挑一大堆毛病出来，这不正是这门课的收获。虽然只有短短32学时，我们已经从面向过程的古板简陋的C语言程序员，变成能从很多层面写代码，面向对象编程的Java程序员了，而且越是用的多，越能感受到这种不一样的编程方式的魅力。我现在很有一种冲动，就是和很多人一起完成一个大型程序，用所谓敏捷编程的思想做个什么项目出来，感觉这种交互性、协同性，才能激发我编程的激情。然后再回过头看看我们的作品，分析分析他的健壮性、正确性、复用性、可维护性等等，我想我又会有新的感想。C语言教我从无到有，而软件构造和数据结构则教我们从有到好，从好到更好。",
      "以上就是我对这门课的一些感想，当然还有24小时时间，试还是要考，仍需继续学习才是。"
    ],
    "sentences": [
      "复习了一遍软件构造的概念",
      "对这门课的学习方式和学习内容也有了些体会和心得",
      "给大家分享下我的感受",
      "第一就是这是门编程课",
      "所以一定要动手！！！一定要动手！！！一定要动手！！！个人评判目前学过的四门编程课",
      "动手要求能力：C语言程序设计>软件构造>数据结构>算法设计",
      "编程课不去敲代码是绝对不行的",
      "哪怕你不去上课",
      "习题课的内容、实验课的内容你也要亲自动手去敲",
      "因为很多东西你只学理论是永远学不明白的",
      "就像教你竖式乘法你却不去动手计算",
      "Lab3我想对于绝大多数同学都是个很大的挑战",
      "但也是这个实验中",
      "我对继承、抽象类、具体类、接口等等各种概念才有了自己的认识",
      "多动手，才是学好这门课的最主要途径！",
      "第二，这门课的先修真的太重要了",
      "没学过Java和Git的我从第一节课就开始懵",
      "直接懵到考试前",
      "所以建议学弟学妹们",
      "在学习数据结构",
      "或者更早的时候",
      "顺道就给Java学了吧",
      "而且学了Java才后知后觉",
      "用Java实现数据结构里的链表、树、图有多么轻松！想想当初C语言折磨得我...悔不当初",
      "所以，有空早学Java，早晚都要学的！",
      "我觉得以上两点就是能确保你学好这门课的全部要素了",
      "当然我哪点做的都不好...但是期末了",
      "三个Lab都写完了",
      "复习也复习过一遍了",
      "突然发现这门课是一门越学的深入越能感受到其巧妙的课程",
      "我想每个同学Lab1和第一次习题课写的代码现在如果再找出来",
      "都能挑一大堆毛病出来",
      "这不正是这门课的收获",
      "虽然只有短短32学时",
      "我们已经从面向过程的古板简陋的C语言程序员",
      "变成能从很多层面写代码",
      "面向对象编程的Java程序员了",
      "而且越是用的多",
      "越能感受到这种不一样的编程方式的魅力",
      "我现在很有一种冲动",
      "就是和很多人一起完成一个大型程序",
      "用所谓敏捷编程的思想做个什么项目出来",
      "感觉这种交互性、协同性",
      "才能激发我编程的激情",
      "然后再回过头看看我们的作品",
      "分析分析他的健壮性、正确性、复用性、可维护性等等",
      "我想我又会有新的感想",
      "C语言教我从无到有",
      "而软件构造和数据结构则教我们从有到好",
      "从好到更好",
      "以上就是我对这门课的一些感想",
      "当然还有24小时时间",
      "试还是要考",
      "仍需继续学习才是"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "复习了一遍软件构造的概念，对这门课的学习方式和学习内容也有了些体会和心得，给大家分享下我的感受。\n第一就是这是门编程课，所以一定要动手！！！一定要动手！！！一定要动手！！！个人评判目前学过的四门编程课，动手要求能力：C语言程序设计>软件构造>数据结构>算法设计。编程课不去敲代码是绝对不行的，哪怕你不去上课，习题课的内容、实验课的内容你也要亲自动手去敲。因为很多东西你只学理论是永远学不明白的，就像教你竖式乘法你却不去动手计算。Lab3我想对于绝大多数同学都是个很大的挑战，但也是这个实验中，我对继承、抽象类、具体类、接口等等各种概念才有了自己的认识。多动手，才是学好这门课的最主要途径！\n第二，这门课的先修真的太重要了。没学过Java和Git的我从第一节课就开始懵，直接懵到考试前，所以建议学弟学妹们，在学习数据结构，或者更早的时候，顺道就给Java学了吧。而且学了Java才后知后觉，用Java实现数据结构里的链表、树、图有多么轻松！想想当初C语言折磨得我...悔不当初。所以，有空早学Java，早晚都要学的！\n我觉得以上两点就是能确保你学好这门课的全部要素了，当然我哪点做的都不好...但是期末了，三个Lab都写完了，复习也复习过一遍了，突然发现这门课是一门越学的深入越能感受到其巧妙的课程。我想每个同学Lab1和第一次习题课写的代码现在如果再找出来，都能挑一大堆毛病出来，这不正是这门课的收获。虽然只有短短32学时，我们已经从面向过程的古板简陋的C语言程序员，变成能从很多层面写代码，面向对象编程的Java程序员了，而且越是用的多，越能感受到这种不一样的编程方式的魅力。我现在很有一种冲动，就是和很多人一起完成一个大型程序，用所谓敏捷编程的思想做个什么项目出来，感觉这种交互性、协同性，才能激发我编程的激情。然后再回过头看看我们的作品，分析分析他的健壮性、正确性、复用性、可维护性等等，我想我又会有新的感想。C语言教我从无到有，而软件构造和数据结构则教我们从有到好，从好到更好。\n以上就是我对这门课的一些感想，当然还有24小时时间，试还是要考，仍需继续学习才是。\n"
  },
  {
    "head": "[HIT]哈工大2021软件构造知识点理解(2)——七大设计模式",
    "paragraphs": [
      "不管怎么看，以我现在的水平，我都不可能在一篇文章中说明白一个设计模式，更别说七个。但如果你完全不知道这七大模式都是什么，那么这篇文章或许对引领你建立对这六种模式理解的框架有所帮助。",
      "其实Java开发共有23种模式，关于这23种模式CSDN上优秀的文章比比皆是，但因为考试只针对其中六种，故在此为那些正在学习和明年将学习的学弟们写一篇入门的不能再入门的文章。",
      "1）Adapter模式：Adapter模式也叫做适配器模式，什么是这个所谓的适配器模式呢。我来用最通俗的语言举个例子：假设你有一个3.5毫米插头耳机，并且你使用的是老款的安卓手机，上面带有一个3.5插孔耳机孔，你当然可以自由地使用这个耳机。但有一天你要换手机了，换成最新款的苹果手机，上面并不带有3.5插孔耳机孔，而是一个苹果专用接口，你该怎么做呢？将耳机线拆开将其重新焊接上苹果接口？还是给苹果手机拆开凿一个3.5插孔的耳机孔？现实中没有人这么做。因为这时就轮到我们的适配器登场了。只需要一个转换口，将原来的接口转换为适合耳机的接口即可。这里的这个转换口，就是Adapter。在Java编程实际过程中，Adapter一般是将具体类和接口进行转接，Adapter是OCP(Open-Closed Principle)的体现之一。关于更详细的Adapter模式讲解，可参考以下文章：",
      "(4条消息) 适配器模式的三种形式_烟雨星空的博客-CSDN博客_适配器模式",
      "2）Decorator模式：装饰者模式，在我看来是这七大模式中最优雅当然也最晦涩难懂的设计模式。举一个经典的例子，也就是奶茶加珍珠的例子。假设一家奶茶店产品有红茶绿茶四季春奶茶，相应的配料有珍珠椰果红豆布丁奥利奥等等，作为软件工程师的你如何为这家店设计一个点餐平台呢？朴素的思想是排列组合，设计一个抽象类Tea，然后为每种具体饮品分别实现，在每个具体类中用bool isPearl，isOrio等等标记加料情况，那如果一个顾客加了三份珍珠怎么办呢？而且在每个具体类中重复的使用相同的bool变量，显然不符合我们避免代码复用的思想。优雅的解决方案是，为PearledTea等具体类设计一个统一的抽象类AddedTea，这个AdderTea继承Tea，且委托具体饮品类如RedTea等中的方法来完成功能，这样就形成了一个层层包装的商品流程。为简化例子，假设功能只有一个getPrice计算价格，一位顾客点了一杯三份珍珠一份奥利奥的红茶，那么包装的效果应如下所示：",
      "关于更详细的Decorator模式讲解可参考：",
      "(4条消息) 装饰者模式(通俗易懂)_笔记别偷看-CSDN博客_装饰着模式",
      "3）Template模式：也叫模板模式，这个应该是最好理解的一个设计模式，同样开始举例子：假设用户想进行球类运动，球类运动的一般步骤假设是：换运动服——打球——洗澡——回家，可以见得不管打什么球，用户的换运动服和洗澡步骤都是一样的。那么模板模式的思想就是先设计一个抽象类，直接在其中具体实现换衣服方法和洗澡方法，至于具体打球方法留给各子类去完成。这个模式不贴参考文章了，应该明白意思就理解了，毕竟Lab中用的还蛮多的。",
      "4）Strategy模式：策略模式，主要结合@Override使用。这种模式我们C语言最早期就接触过，用Switch语句选择不同的排序方式然后单步调试观察运行效果，可以类比到策略模式中。策略模式就是用户端动态的选择不同的算法来完成同一个任务，过程是首先构造一个接口，然后客户端传入要使用的算法后通过委托来实现所选择的算法。委托策略一般是Aggregation，也就是较折中的策略。策略模式可以参考",
      "(4条消息) 策略模式及简单Java案例代码实现_Len-CSDN博客_策略模式java",
      "5）Iterator模式：迭代器模式是较常用的轻量化模式，最为常见的便是链表List的遍历。迭代器模式设计要求设计者所完成的ADT无需关心容器具体类型的情况下即可完成迭代过程，其具体的实现方式是在ADT中实现Iterable接口，此接口内部只有一个返回一个迭代器的方法，然后再创建一个内部类实现Iterator接口，重写其hasNext()、next()和remove()方法，同样不贴参考文章了，贴一段代码，来自",
      "(4条消息) [HITSC]哈工大2020春软件构造复习笔记 (4)_北言栾生的博客-CSDN博客",
      "6）Visitor模式：访问者模式的总体思想是数据Data与操作Operation分离的思想。实现较为复杂却并不困难：假设你家地下车库中放着各种乱七八糟的东西，如旧衣服篮球报纸玩具，而你要做的是是为你的汽车加油，但对其中大部分物品(Element)这个操作是不合法的，所以朴素的思想是在加油方法中加入判断语句，但如果是一个泛化操作，比如如果找到了玩具做什么，找到了报纸做什么，那么大段的switch-case不仅不优雅而且性能级差。因此Visitor模式的思想是通过一个Visitor抽象类，在其具体实现中实现visit方法，另外定义一个Element接口，在其具体实现中根据应用需求能够完成此时对应的操作，这样在访问时就能利用Dependency策略的委托来完成对应操作。深入学习可以参考",
      "(4条消息) 设计模式(JAVA)——Visitor模式_读书 好学 求知-CSDN博客",
      "7）Factory Method模式：工厂方法模式也较好理解，举个例子，假如你要为你们家买一台空调，但还没决定好要买哪个牌子的空调，于是你对卖空调的工厂传入了你的需求。卖空调的工厂有很多子工厂，分别能生产海尔美的格力各种空调，这样一来，不管你买哪个牌子都可以直接与总工厂协商，总工厂再交由子工厂来具体实现为你生产空调这一操作。总工厂相当于一个接口，而子工厂则是这个接口的具体实现类。最为常见的Factory Method模式如使用Collection的时候，假设你要定义一个Map接口局部变量，你既可以实现为HashMap，也可以实现为TreeMap。更多请参考",
      "(4条消息) 设计模式之工厂方法模式_Mr.yang的博客-CSDN博客",
      "以上例子或者思想并不是我独立创造的，而是基本上全部来源于别人优秀的文章，我只是将他们进行总结归纳整合，在此抛砖引玉，希望为大家软件构造学习之路能有所启发有所帮助。"
    ],
    "sentences": [
      "不管怎么看",
      "以我现在的水平",
      "我都不可能在一篇文章中说明白一个设计模式",
      "更别说七个",
      "但如果你完全不知道这七大模式都是什么",
      "那么这篇文章或许对引领你建立对这六种模式理解的框架有所帮助",
      "其实Java开发共有23种模式",
      "关于这23种模式CSDN上优秀的文章比比皆是",
      "但因为考试只针对其中六种",
      "故在此为那些正在学习和明年将学习的学弟们写一篇入门的不能再入门的文章",
      "1）Adapter模式：Adapter模式也叫做适配器模式",
      "什么是这个所谓的适配器模式呢",
      "我来用最通俗的语言举个例子：假设你有一个3.5毫米插头耳机",
      "并且你使用的是老款的安卓手机",
      "上面带有一个3.5插孔耳机孔",
      "你当然可以自由地使用这个耳机",
      "但有一天你要换手机了",
      "换成最新款的苹果手机",
      "上面并不带有3.5插孔耳机孔",
      "而是一个苹果专用接口",
      "你该怎么做呢？将耳机线拆开将其重新焊接上苹果接口？还是给苹果手机拆开凿一个3.5插孔的耳机孔？现实中没有人这么做",
      "因为这时就轮到我们的适配器登场了",
      "只需要一个转换口，将原来的接口转换为适合耳机的接口即可",
      "这里的这个转换口，就是Adapter",
      "在Java编程实际过程中",
      "Adapter一般是将具体类和接口进行转接",
      "Adapter是OCP(Open-Closed Principle)的体现之一",
      "关于更详细的Adapter模式讲解",
      "可参考以下文章：(4条消息) 适配器模式的三种形式_烟雨星空的博客-CSDN博客_适配器模式",
      "2）Decorator模式：装饰者模式",
      "在我看来是这七大模式中最优雅当然也最晦涩难懂的设计模式",
      "举一个经典的例子，也就是奶茶加珍珠的例子",
      "假设一家奶茶店产品有红茶绿茶四季春奶茶",
      "相应的配料有珍珠椰果红豆布丁奥利奥等等",
      "作为软件工程师的你如何为这家店设计一个点餐平台呢？朴素的思想是排列组合",
      "设计一个抽象类Tea",
      "然后为每种具体饮品分别实现",
      "在每个具体类中用bool isPearl",
      "isOrio等等标记加料情况",
      "那如果一个顾客加了三份珍珠怎么办呢？而且在每个具体类中重复的使用相同的bool变量",
      "显然不符合我们避免代码复用的思想",
      "优雅的解决方案是",
      "为PearledTea等具体类设计一个统一的抽象类AddedTea",
      "这个AdderTea继承Tea",
      "且委托具体饮品类如RedTea等中的方法来完成功能",
      "这样就形成了一个层层包装的商品流程",
      "为简化例子",
      "假设功能只有一个getPrice计算价格",
      "一位顾客点了一杯三份珍珠一份奥利奥的红茶",
      "那么包装的效果应如下所示：关于更详细的Decorator模式讲解可参考：(4条消息) 装饰者模式(通俗易懂)_笔记别偷看-CSDN博客_装饰着模式",
      "3）Template模式：也叫模板模式",
      "这个应该是最好理解的一个设计模式",
      "同样开始举例子：假设用户想进行球类运动",
      "球类运动的一般步骤假设是：换运动服——打球——洗澡——回家",
      "可以见得不管打什么球",
      "用户的换运动服和洗澡步骤都是一样的",
      "那么模板模式的思想就是先设计一个抽象类",
      "直接在其中具体实现换衣服方法和洗澡方法",
      "至于具体打球方法留给各子类去完成",
      "这个模式不贴参考文章了",
      "应该明白意思就理解了",
      "毕竟Lab中用的还蛮多的",
      "4）Strategy模式：策略模式",
      "主要结合@Override使用",
      "这种模式我们C语言最早期就接触过",
      "用Switch语句选择不同的排序方式然后单步调试观察运行效果",
      "可以类比到策略模式中",
      "策略模式就是用户端动态的选择不同的算法来完成同一个任务",
      "过程是首先构造一个接口",
      "然后客户端传入要使用的算法后通过委托来实现所选择的算法",
      "委托策略一般是Aggregation，也就是较折中的策略",
      "策略模式可以参考",
      "(4条消息) 策略模式及简单Java案例代码实现_Len-CSDN博客_策略模式java",
      "5）Iterator模式：迭代器模式是较常用的轻量化模式",
      "最为常见的便是链表List的遍历",
      "迭代器模式设计要求设计者所完成的ADT无需关心容器具体类型的情况下即可完成迭代过程",
      "其具体的实现方式是在ADT中实现Iterable接口",
      "此接口内部只有一个返回一个迭代器的方法",
      "然后再创建一个内部类实现Iterator接口",
      "重写其hasNext()、next()和remove()方法",
      "同样不贴参考文章了",
      "贴一段代码",
      "来自",
      "(4条消息) [HITSC]哈工大2020春软件构造复习笔记 (4)_北言栾生的博客-CSDN博客",
      "6）Visitor模式：访问者模式的总体思想是数据Data与操作Operation分离的思想",
      "实现较为复杂却并不困难：假设你家地下车库中放着各种乱七八糟的东西",
      "如旧衣服篮球报纸玩具",
      "而你要做的是是为你的汽车加油",
      "但对其中大部分物品(Element)这个操作是不合法的",
      "所以朴素的思想是在加油方法中加入判断语句",
      "但如果是一个泛化操作",
      "比如如果找到了玩具做什么",
      "找到了报纸做什么",
      "那么大段的switch-case不仅不优雅而且性能级差",
      "因此Visitor模式的思想是通过一个Visitor抽象类",
      "在其具体实现中实现visit方法",
      "另外定义一个Element接口",
      "在其具体实现中根据应用需求能够完成此时对应的操作",
      "这样在访问时就能利用Dependency策略的委托来完成对应操作",
      "深入学习可以参考",
      "(4条消息) 设计模式(JAVA)——Visitor模式_读书 好学 求知-CSDN博客",
      "7）Factory Method模式：工厂方法模式也较好理解",
      "举个例子",
      "假如你要为你们家买一台空调",
      "但还没决定好要买哪个牌子的空调",
      "于是你对卖空调的工厂传入了你的需求",
      "卖空调的工厂有很多子工厂",
      "分别能生产海尔美的格力各种空调",
      "这样一来",
      "不管你买哪个牌子都可以直接与总工厂协商",
      "总工厂再交由子工厂来具体实现为你生产空调这一操作",
      "总工厂相当于一个接口，而子工厂则是这个接口的具体实现类",
      "最为常见的Factory Method模式如使用Collection的时候",
      "假设你要定义一个Map接口局部变量",
      "你既可以实现为HashMap",
      "也可以实现为TreeMap",
      "更多请参考",
      "(4条消息) 设计模式之工厂方法模式_Mr.yang的博客-CSDN博客",
      "以上例子或者思想并不是我独立创造的",
      "而是基本上全部来源于别人优秀的文章",
      "我只是将他们进行总结归纳整合",
      "在此抛砖引玉",
      "希望为大家软件构造学习之路能有所启发有所帮助"
    ],
    "codes": [
      "public class Pair<E> implements Iterable<E> {\n\tprivate final E first, second;\n\tpublic Pair(E f, E s) { first = f; second = s; }\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new PairIterator();\n\t\t}\n\tprivate class PairIterator implements Iterator<E> {\n\t\tprivate boolean seenFirst = false, seenSecond = false;\n\t\tpublic boolean hasNext() { return !seenSecond; }\n\t\tpublic E next() {\n\t\t\tif (!seenFirst) { seenFirst = true; return first; }\n\t\t\tif (!seenSecond) { seenSecond = true; return second; }\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n    //使用隐式方法迭代\n    public static void main(String[] args){\n\t\tPair<String> pair = new Pair<String>(\"foo\", \"bar\");\n\t\tfor (String s : pair) { ... }\n    }\n}\n"
    ],
    "date": "2021-07-07",
    "text": "不管怎么看，以我现在的水平，我都不可能在一篇文章中说明白一个设计模式，更别说七个。但如果你完全不知道这七大模式都是什么，那么这篇文章或许对引领你建立对这六种模式理解的框架有所帮助。\n其实Java开发共有23种模式，关于这23种模式CSDN上优秀的文章比比皆是，但因为考试只针对其中六种，故在此为那些正在学习和明年将学习的学弟们写一篇入门的不能再入门的文章。\n1）Adapter模式：Adapter模式也叫做适配器模式，什么是这个所谓的适配器模式呢。我来用最通俗的语言举个例子：假设你有一个3.5毫米插头耳机，并且你使用的是老款的安卓手机，上面带有一个3.5插孔耳机孔，你当然可以自由地使用这个耳机。但有一天你要换手机了，换成最新款的苹果手机，上面并不带有3.5插孔耳机孔，而是一个苹果专用接口，你该怎么做呢？将耳机线拆开将其重新焊接上苹果接口？还是给苹果手机拆开凿一个3.5插孔的耳机孔？现实中没有人这么做。因为这时就轮到我们的适配器登场了。只需要一个转换口，将原来的接口转换为适合耳机的接口即可。这里的这个转换口，就是Adapter。在Java编程实际过程中，Adapter一般是将具体类和接口进行转接，Adapter是OCP(Open-Closed Principle)的体现之一。关于更详细的Adapter模式讲解，可参考以下文章：\n(4条消息) 适配器模式的三种形式_烟雨星空的博客-CSDN博客_适配器模式\n2）Decorator模式：装饰者模式，在我看来是这七大模式中最优雅当然也最晦涩难懂的设计模式。举一个经典的例子，也就是奶茶加珍珠的例子。假设一家奶茶店产品有红茶绿茶四季春奶茶，相应的配料有珍珠椰果红豆布丁奥利奥等等，作为软件工程师的你如何为这家店设计一个点餐平台呢？朴素的思想是排列组合，设计一个抽象类Tea，然后为每种具体饮品分别实现，在每个具体类中用bool isPearl，isOrio等等标记加料情况，那如果一个顾客加了三份珍珠怎么办呢？而且在每个具体类中重复的使用相同的bool变量，显然不符合我们避免代码复用的思想。优雅的解决方案是，为PearledTea等具体类设计一个统一的抽象类AddedTea，这个AdderTea继承Tea，且委托具体饮品类如RedTea等中的方法来完成功能，这样就形成了一个层层包装的商品流程。为简化例子，假设功能只有一个getPrice计算价格，一位顾客点了一杯三份珍珠一份奥利奥的红茶，那么包装的效果应如下所示：\n关于更详细的Decorator模式讲解可参考：\n(4条消息) 装饰者模式(通俗易懂)_笔记别偷看-CSDN博客_装饰着模式\n3）Template模式：也叫模板模式，这个应该是最好理解的一个设计模式，同样开始举例子：假设用户想进行球类运动，球类运动的一般步骤假设是：换运动服——打球——洗澡——回家，可以见得不管打什么球，用户的换运动服和洗澡步骤都是一样的。那么模板模式的思想就是先设计一个抽象类，直接在其中具体实现换衣服方法和洗澡方法，至于具体打球方法留给各子类去完成。这个模式不贴参考文章了，应该明白意思就理解了，毕竟Lab中用的还蛮多的。\n4）Strategy模式：策略模式，主要结合@Override使用。这种模式我们C语言最早期就接触过，用Switch语句选择不同的排序方式然后单步调试观察运行效果，可以类比到策略模式中。策略模式就是用户端动态的选择不同的算法来完成同一个任务，过程是首先构造一个接口，然后客户端传入要使用的算法后通过委托来实现所选择的算法。委托策略一般是Aggregation，也就是较折中的策略。策略模式可以参考\n(4条消息) 策略模式及简单Java案例代码实现_Len-CSDN博客_策略模式java\n5）Iterator模式：迭代器模式是较常用的轻量化模式，最为常见的便是链表List的遍历。迭代器模式设计要求设计者所完成的ADT无需关心容器具体类型的情况下即可完成迭代过程，其具体的实现方式是在ADT中实现Iterable接口，此接口内部只有一个返回一个迭代器的方法，然后再创建一个内部类实现Iterator接口，重写其hasNext()、next()和remove()方法，同样不贴参考文章了，贴一段代码，来自\n(4条消息) [HITSC]哈工大2020春软件构造复习笔记 (4)_北言栾生的博客-CSDN博客\n6）Visitor模式：访问者模式的总体思想是数据Data与操作Operation分离的思想。实现较为复杂却并不困难：假设你家地下车库中放着各种乱七八糟的东西，如旧衣服篮球报纸玩具，而你要做的是是为你的汽车加油，但对其中大部分物品(Element)这个操作是不合法的，所以朴素的思想是在加油方法中加入判断语句，但如果是一个泛化操作，比如如果找到了玩具做什么，找到了报纸做什么，那么大段的switch-case不仅不优雅而且性能级差。因此Visitor模式的思想是通过一个Visitor抽象类，在其具体实现中实现visit方法，另外定义一个Element接口，在其具体实现中根据应用需求能够完成此时对应的操作，这样在访问时就能利用Dependency策略的委托来完成对应操作。深入学习可以参考\n(4条消息) 设计模式(JAVA)——Visitor模式_读书 好学 求知-CSDN博客\n7）Factory Method模式：工厂方法模式也较好理解，举个例子，假如你要为你们家买一台空调，但还没决定好要买哪个牌子的空调，于是你对卖空调的工厂传入了你的需求。卖空调的工厂有很多子工厂，分别能生产海尔美的格力各种空调，这样一来，不管你买哪个牌子都可以直接与总工厂协商，总工厂再交由子工厂来具体实现为你生产空调这一操作。总工厂相当于一个接口，而子工厂则是这个接口的具体实现类。最为常见的Factory Method模式如使用Collection的时候，假设你要定义一个Map接口局部变量，你既可以实现为HashMap，也可以实现为TreeMap。更多请参考\n(4条消息) 设计模式之工厂方法模式_Mr.yang的博客-CSDN博客\n以上例子或者思想并不是我独立创造的，而是基本上全部来源于别人优秀的文章，我只是将他们进行总结归纳整合，在此抛砖引玉，希望为大家软件构造学习之路能有所启发有所帮助。\n"
  },
  {
    "head": "[HIT]哈工大2021软件构造知识点理解(1)——委托",
    "paragraphs": [
      "总有一些知识点，看起来似懂非懂，因此决定写几篇文章来对这些知识点总结归纳，顺便加强自己的理解，也欢迎各位积极指正其中理解不到位的地方。",
      "在可复用处个人认为最难理解的地方就是委托(Delegation)，因此此处着重讨论一下Java中的四种委托——Dependency、Association、Aggregation和Composition。",
      "由弱到强分别是Dependency->Association，Association中Aggregation->Composition。",
      "假设有两个类A和B，A的Rep中含有B的对象，并且在之后A委托B，调用了B的方法，这样的委托称作Association，否则，若B的对象只作为A的某方法中的局部变量出现，我们管这样的委托叫做Dependency。",
      "比如对于下面这个再简单不过的类B：",
      "Dependency策略：",
      "而关于Association策略，将其拆分成两部分，先来说较好理解的较强的Competition策略：",
      "较弱的Aggregation策略：",
      "是不是有些懵，不用担心，接下来来总结一下：",
      "1）Dependency策略的委托就像是一个渣男/渣女委托你办事，用完你就把你给甩了，并且在以前或者以后甚至都看不出任何你存在过的痕迹。",
      "2）Competition策略的委托截然不同，就像一个贞洁烈女，只要我委托你办事了，我就赖上你了，而且我的对象从此以后只能是你，不能是别人。",
      "3）Aggregation比较中庸，我委托给你了，我的心中就给你了一个位置，或许在未来我的对象会变，但他也永远是你的那个类型。",
      "用这种方式来理解委托的概念，是不是就好理解多了。以上就是知识点理解第一篇的全部内容了。"
    ],
    "sentences": [
      "总有一些知识点",
      "看起来似懂非懂",
      "因此决定写几篇文章来对这些知识点总结归纳",
      "顺便加强自己的理解",
      "也欢迎各位积极指正其中理解不到位的地方",
      "在可复用处个人认为最难理解的地方就是委托(Delegation)",
      "因此此处着重讨论一下Java中的四种委托——Dependency、Association、Aggregation和Composition",
      "由弱到强分别是Dependency->Association",
      "Association中Aggregation->Composition",
      "假设有两个类A和B",
      "A的Rep中含有B的对象",
      "并且在之后A委托B",
      "调用了B的方法",
      "这样的委托称作Association",
      "否则",
      "若B的对象只作为A的某方法中的局部变量出现",
      "我们管这样的委托叫做Dependency",
      "比如对于下面这个再简单不过的类B：Dependency策略：而关于Association策略",
      "将其拆分成两部分",
      "先来说较好理解的较强的Competition策略：较弱的Aggregation策略：是不是有些懵",
      "不用担心",
      "接下来来总结一下：1）Dependency策略的委托就像是一个渣男/渣女委托你办事",
      "用完你就把你给甩了",
      "并且在以前或者以后甚至都看不出任何你存在过的痕迹",
      "2）Competition策略的委托截然不同",
      "就像一个贞洁烈女",
      "只要我委托你办事了",
      "我就赖上你了",
      "而且我的对象从此以后只能是你",
      "不能是别人",
      "3）Aggregation比较中庸",
      "我委托给你了",
      "我的心中就给你了一个位置",
      "或许在未来我的对象会变",
      "但他也永远是你的那个类型",
      "用这种方式来理解委托的概念，是不是就好理解多了",
      "以上就是知识点理解第一篇的全部内容了"
    ],
    "codes": [
      "public class B {\n    private final int num;\n    public B(int num){\n        this.num = num;\n    }\n    public int getNum() {\n        return num;\n    }\n}\n",
      "public class A {\n    private final int num;\n    public A(){\n        B b = new B(10);\n        num = b.getNum();\n    }\n}",
      "public class A {\n    private final int num;\n    private final B b = new B(10);\n    public A(){\n        num = b.getNum();\n    }\n}\n",
      "public class A {\n    private final int num;\n    private final B b;\n    public A(int num){//此处传参也可以是B b，看使用场景\n        B b = new B(num);\n        this.b = b;\n        this.num = this.b.getNum();\n    }\n}\n"
    ],
    "date": "2021-07-07",
    "text": "总有一些知识点，看起来似懂非懂，因此决定写几篇文章来对这些知识点总结归纳，顺便加强自己的理解，也欢迎各位积极指正其中理解不到位的地方。\n在可复用处个人认为最难理解的地方就是委托(Delegation)，因此此处着重讨论一下Java中的四种委托——Dependency、Association、Aggregation和Composition。\n由弱到强分别是Dependency->Association，Association中Aggregation->Composition。\n假设有两个类A和B，A的Rep中含有B的对象，并且在之后A委托B，调用了B的方法，这样的委托称作Association，否则，若B的对象只作为A的某方法中的局部变量出现，我们管这样的委托叫做Dependency。\n比如对于下面这个再简单不过的类B：\nDependency策略：\n而关于Association策略，将其拆分成两部分，先来说较好理解的较强的Competition策略：\n较弱的Aggregation策略：\n是不是有些懵，不用担心，接下来来总结一下：\n1）Dependency策略的委托就像是一个渣男/渣女委托你办事，用完你就把你给甩了，并且在以前或者以后甚至都看不出任何你存在过的痕迹。\n2）Competition策略的委托截然不同，就像一个贞洁烈女，只要我委托你办事了，我就赖上你了，而且我的对象从此以后只能是你，不能是别人。\n3）Aggregation比较中庸，我委托给你了，我的心中就给你了一个位置，或许在未来我的对象会变，但他也永远是你的那个类型。\n用这种方式来理解委托的概念，是不是就好理解多了。以上就是知识点理解第一篇的全部内容了。\n"
  },
  {
    "head": "[HIT]哈工大2021软件构造知识点理解(3)——异常与断言",
    "paragraphs": [
      "首先理解Java中异常的组织结构。Java中的异常Exception是一个类，继承自Throwable，Throwable还派生出Error类。Exception子类一般分为RuntimeException和一般性异常。",
      "RuntimeException=运行时异常=系统异常=uncheckedException，可以编译通过，此类异常一定是程序员的问题，常见如被0除异常，是程序健壮性低的体现，打印异常信息即可。",
      "一般性异常=受控异常=编译时异常=checkedException，此类异常必须显示的捕获/传递否则无法编译通过。",
      "然后理解，捕获和抛出的有关概念：",
      "1）捕获：try-catch-finally语句，try捕获异常，try接口会对可能含有异常的代码进行检查，若出现了异常信息，将异常传递给后面的catch()块进行处理，catch括号内为异常类，try后面可以跟多个catch块，对应不同的异常处理。try-catch类似于循环中的if-break，当异常出现时后续代码不会执行。而finally块是不管异常与否都会执行，也就是若出现异常，停止继续执行try块转而执行finally块，而若未出现异常，执行完try块将执行finally块。由于try-catch的break性质，一般先截获子异常，再截获父异常。由具体到抽象，由小范围到大范围。",
      "2）抛出：注意，有两种语句：throws和throw。throws语句，一般在方法的声明处，跟在函数名后参数前。“出错了就不管了”的赖皮属性声明此方法可能产生的所有异常，不作处理将异常向上传递，异常处理交给调用者。throw用来在方法体内部抛出具体的异常，后面跟异常对象名，将错误信息真正的抛出。异常对象后面一般会跟getMessage()方法和printStackTrace()方法，二者区别在于getMessage会打印异常描述信息如日志信息，而printStackTrace会打印堆栈信息。",
      "有了这些概念，assert就很容易了。",
      "assert语句常见有两种：",
      "须注意的是，assert在IDE常规工作模式下并不会生效。",
      "自定义异常也是考点的一部分，一般来说是一个继承自Exception的类，只含有无参数构造方法和有参数构造方法两个方法，如下：",
      "调用时需使用"
    ],
    "sentences": [
      "首先理解Java中异常的组织结构",
      "Java中的异常Exception是一个类",
      "继承自Throwable",
      "Throwable还派生出Error类",
      "Exception子类一般分为RuntimeException和一般性异常",
      "RuntimeException=运行时异常=系统异常=uncheckedException",
      "可以编译通过",
      "此类异常一定是程序员的问题",
      "常见如被0除异常",
      "是程序健壮性低的体现",
      "打印异常信息即可",
      "一般性异常=受控异常=编译时异常=checkedException",
      "此类异常必须显示的捕获/传递否则无法编译通过",
      "然后理解",
      "捕获和抛出的有关概念：1）捕获：try-catch-finally语句",
      "try捕获异常",
      "try接口会对可能含有异常的代码进行检查",
      "若出现了异常信息",
      "将异常传递给后面的catch()块进行处理",
      "catch括号内为异常类",
      "try后面可以跟多个catch块",
      "对应不同的异常处理",
      "try-catch类似于循环中的if-break",
      "当异常出现时后续代码不会执行",
      "而finally块是不管异常与否都会执行",
      "也就是若出现异常",
      "停止继续执行try块转而执行finally块",
      "而若未出现异常",
      "执行完try块将执行finally块",
      "由于try-catch的break性质",
      "一般先截获子异常",
      "再截获父异常",
      "由具体到抽象，由小范围到大范围",
      "2）抛出：注意，有两种语句：throws和throw",
      "throws语句，一般在方法的声明处，跟在函数名后参数前",
      "“出错了就不管了”的赖皮属性声明此方法可能产生的所有异常",
      "不作处理将异常向上传递",
      "异常处理交给调用者",
      "throw用来在方法体内部抛出具体的异常",
      "后面跟异常对象名",
      "将错误信息真正的抛出",
      "异常对象后面一般会跟getMessage()方法和printStackTrace()方法",
      "二者区别在于getMessage会打印异常描述信息如日志信息",
      "而printStackTrace会打印堆栈信息",
      "有了这些概念，assert就很容易了",
      "assert语句常见有两种：须注意的是",
      "assert在IDE常规工作模式下并不会生效",
      "自定义异常也是考点的一部分",
      "一般来说是一个继承自Exception的类",
      "只含有无参数构造方法和有参数构造方法两个方法",
      "如下：调用时需使用"
    ],
    "codes": [
      "assert condition;//condition为真则无事发生，为假则抛出一个AssertionError对象\n\nassert condition:message;//condition为真无事发生，为假会将message传入AssertionError进行错误信息输出",
      "public class MyException extends Exception{\n    public MyException(){\n        super();\n    }\n    public MyException(String msg){\n        super(msg);\n    }\n}",
      "throw new MyException(message);"
    ],
    "date": "2021-07-07",
    "text": "首先理解Java中异常的组织结构。Java中的异常Exception是一个类，继承自Throwable，Throwable还派生出Error类。Exception子类一般分为RuntimeException和一般性异常。\nRuntimeException=运行时异常=系统异常=uncheckedException，可以编译通过，此类异常一定是程序员的问题，常见如被0除异常，是程序健壮性低的体现，打印异常信息即可。\n一般性异常=受控异常=编译时异常=checkedException，此类异常必须显示的捕获/传递否则无法编译通过。\n然后理解，捕获和抛出的有关概念：\n1）捕获：try-catch-finally语句，try捕获异常，try接口会对可能含有异常的代码进行检查，若出现了异常信息，将异常传递给后面的catch()块进行处理，catch括号内为异常类，try后面可以跟多个catch块，对应不同的异常处理。try-catch类似于循环中的if-break，当异常出现时后续代码不会执行。而finally块是不管异常与否都会执行，也就是若出现异常，停止继续执行try块转而执行finally块，而若未出现异常，执行完try块将执行finally块。由于try-catch的break性质，一般先截获子异常，再截获父异常。由具体到抽象，由小范围到大范围。\n2）抛出：注意，有两种语句：throws和throw。throws语句，一般在方法的声明处，跟在函数名后参数前。“出错了就不管了”的赖皮属性声明此方法可能产生的所有异常，不作处理将异常向上传递，异常处理交给调用者。throw用来在方法体内部抛出具体的异常，后面跟异常对象名，将错误信息真正的抛出。异常对象后面一般会跟getMessage()方法和printStackTrace()方法，二者区别在于getMessage会打印异常描述信息如日志信息，而printStackTrace会打印堆栈信息。\n有了这些概念，assert就很容易了。\nassert语句常见有两种：\n须注意的是，assert在IDE常规工作模式下并不会生效。\n自定义异常也是考点的一部分，一般来说是一个继承自Exception的类，只含有无参数构造方法和有参数构造方法两个方法，如下：\n调用时需使用\n"
  },
  {
    "head": "代码之路—— Fast Food",
    "paragraphs": [
      "Fast Food",
      "The fastfood chain McBurger owns several restaurants along a highway. Recently, they have decided to build several depots along the highway, each one located at a restaurant and supplying several of the restaurants with the needed ingredients. Naturally, these depots should be placed so that the average distance between a restaurant and its assigned depot is minimized. You are to write a program that computes the optimal positions and assignments of the depots.",
      "To make this more precise, the management of McBurger has issued the following specification: You will be given the positions of n restaurants along the highway as n integers d1 < d2 < … < dn (these are the distances measured from the company’s headquarter, which happens to be at the same highway). Furthermore, a number k (k <= n) will be given, the number of depots to be built.",
      "The k depots will be built at the locations of k different restaurants. Each restaurant will be assigned to the closest depot, from which it will then receive its supplies. To minimize shipping costs, the total distance sum, defined as",
      "must be as small as possible.",
      "Write a program that computes the positions of the k depots, such that the total distance sum is minimized.",
      "Input",
      "The input file contains several descriptions of fastfood chains. Each description starts with a line containing the two integers n and k. n and k will satisfy 1 <= n <= 200, 1 <= k <= 30, k <= n. Following this will n lines containing one integer each, giving the positions di of the restaurants, ordered increasingly.",
      "The input file will end with a case starting with n = k = 0. This case should not be processed.",
      "Output",
      "For each chain, first output the number of the chain. Then output a line containing the total distance sum.",
      "Output a blank line after each test case.",
      "1.如果已知从第i个商店到第j个商店中有一个仓库，则这个仓库位于中间，也就是中位数（i+j）/2，原因如下：",
      "假设在5个商店中有一个仓库，则对于最远的2个商店，也就是第1个和第5个，无论仓库位于哪里，其路程和都是第1个仓库到第5个仓库的距离，此时可以不再讨论仓库对于这两个商店的影响，此时要讨论的商店仅剩3个，再依据上面的思路去讨论类似的问题，最后仅剩1个商店或2个商店，则仓库位于中位数处是距离和最小的。（反证即可）",
      "2.依据上面的思路进行动态规划。dp[ i ][ j ]代表前j个商店有i个仓库，找到动态转移方程：",
      "dp[ i ][ j ] = min( dp[ i ][ j ] , dp[ i-1 ][ m ] + cost[ m+1 ][ j ])",
      "其中 i-1<=m<=j-1, 由于仓库数量确定为i-1，而商店数量未知，但可以确定他的取值范围。（第i-1个仓库在第i-1个商店）m=i-1,（第i个仓库在j处），则m=j-1。"
    ],
    "sentences": [
      "Fast Food",
      "The fastfood chain McBurger owns several restaurants along a highway. Recently, they have decided to build several depots along the highway, each one located at a restaurant and supplying several of the restaurants with the needed ingredients. Naturally, these depots should be placed so that the average distance between a restaurant and its assigned depot is minimized. You are to write a program that computes the optimal positions and assignments of the depots.To make this more precise, the management of McBurger has issued the following specification: You will be given the positions of n restaurants along the highway as n integers d1 < d2 < … < dn (these are the distances measured from the company’s headquarter, which happens to be at the same highway). Furthermore, a number k (k <= n) will be given, the number of depots to be built.The k depots will be built at the locations of k different restaurants. Each restaurant will be assigned to the closest depot, from which it will then receive its supplies. To minimize shipping costs, the total distance sum, defined as",
      "must be as small as possible.Write a program that computes the positions of the k depots, such that the total distance sum is minimized.Input",
      "The input file contains several descriptions of fastfood chains. Each description starts with a line containing the two integers n and k. n and k will satisfy 1 <= n <= 200, 1 <= k <= 30, k <= n. Following this will n lines containing one integer each, giving the positions di of the restaurants, ordered increasingly.The input file will end with a case starting with n = k = 0. This case should not be processed.Output",
      "For each chain, first output the number of the chain. Then output a line containing the total distance sum.Output a blank line after each test case.1.如果已知从第i个商店到第j个商店中有一个仓库",
      "则这个仓库位于中间",
      "也就是中位数（i+j）/2",
      "原因如下：假设在5个商店中有一个仓库",
      "则对于最远的2个商店",
      "也就是第1个和第5个",
      "无论仓库位于哪里",
      "其路程和都是第1个仓库到第5个仓库的距离",
      "此时可以不再讨论仓库对于这两个商店的影响",
      "此时要讨论的商店仅剩3个",
      "再依据上面的思路去讨论类似的问题",
      "最后仅剩1个商店或2个商店",
      "则仓库位于中位数处是距离和最小的",
      "（反证即可）",
      "2.依据上面的思路进行动态规划",
      "dp[ i ][ j ]代表前j个商店有i个仓库",
      "找到动态转移方程：dp[ i ][ j ] = min( dp[ i ][ j ] , dp[ i-1 ][ m ] + cost[ m+1 ][ j ])",
      "其中 i-1<=m<=j-1, 由于仓库数量确定为i-1",
      "而商店数量未知",
      "但可以确定他的取值范围",
      "（第i-1个仓库在第i-1个商店）m=i-1,（第i个仓库在j处）",
      "则m=j-1"
    ],
    "codes": [
      "\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdlib.h>\n#define Max 10000\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\nint dp[40][210];\nint cost[210][210];\nint dis[210];\n\nint min(int x, int y){\n\treturn x>y?y:x;\n}\n\nint main(int argc, char *argv[]) {\n\tint n, k, i ,j, count = 0;\n\twhile(scanf(\"%d%d\", &n, &k) == 2 && n != 0 && k != 0){\n\t\tcount++;\n\t\tmemset(dp, Max, sizeof(dp));\n\t\tmemset(cost, 0, sizeof(cost));\n\t\tmemset(dis, 0, sizeof(dis));\n\t\tfor(i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\",dis + i);\n\t\t}\n\t\tfor(i = 1; i <= n; i++){\t\t//计算从第i个餐厅到第j个餐厅只有一个仓库距离的求和 \n\t\t\tfor(j = i; j <= n; j++){\n\t\t\t\tfor(int m = i; m <= j; m++){\n\t\t\t\t\tcost[i][j] += abs(dis[m]-dis[(i+j)/2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 1; i <= n ; i++){\t//街上只有一个商店，此时距离和为cost \n\t\t\tdp[1][i] = cost[1][i];\n\t\t}\n\t\tfor(i = 2; i <= k; i++){\t\t//i代表街上的仓库数量 \n\t\t\tfor(j = i; j <= n; j++){\t\t//j代表街上商店的数量，商店要大于等于仓库数量 \n\t\t\t\tfor(int m = i-1; m <= j-1; m++){\t\t//状态转移方程，从i-1个仓库去推，由于商店数量未知，但知道其范围为 i-1~j-1 \n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i-1][m] + cost[m+1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"Chain %d\\n\",count);\n\t\tprintf(\"Total distance sum = %d\\n\",dp[k][n]);\n\t\tprintf(\"\\n\");\n\t}\n}\n\n\n\n"
    ],
    "date": "2020-09-09",
    "text": "Fast Food\nThe fastfood chain McBurger owns several restaurants along a highway. Recently, they have decided to build several depots along the highway, each one located at a restaurant and supplying several of the restaurants with the needed ingredients. Naturally, these depots should be placed so that the average distance between a restaurant and its assigned depot is minimized. You are to write a program that computes the optimal positions and assignments of the depots.\nTo make this more precise, the management of McBurger has issued the following specification: You will be given the positions of n restaurants along the highway as n integers d1 < d2 < … < dn (these are the distances measured from the company’s headquarter, which happens to be at the same highway). Furthermore, a number k (k <= n) will be given, the number of depots to be built.\nThe k depots will be built at the locations of k different restaurants. Each restaurant will be assigned to the closest depot, from which it will then receive its supplies. To minimize shipping costs, the total distance sum, defined as\nmust be as small as possible.\nWrite a program that computes the positions of the k depots, such that the total distance sum is minimized.\nInput\nThe input file contains several descriptions of fastfood chains. Each description starts with a line containing the two integers n and k. n and k will satisfy 1 <= n <= 200, 1 <= k <= 30, k <= n. Following this will n lines containing one integer each, giving the positions di of the restaurants, ordered increasingly.\nThe input file will end with a case starting with n = k = 0. This case should not be processed.\nOutput\nFor each chain, first output the number of the chain. Then output a line containing the total distance sum.\nOutput a blank line after each test case.\n1.如果已知从第i个商店到第j个商店中有一个仓库，则这个仓库位于中间，也就是中位数（i+j）/2，原因如下：\n假设在5个商店中有一个仓库，则对于最远的2个商店，也就是第1个和第5个，无论仓库位于哪里，其路程和都是第1个仓库到第5个仓库的距离，此时可以不再讨论仓库对于这两个商店的影响，此时要讨论的商店仅剩3个，再依据上面的思路去讨论类似的问题，最后仅剩1个商店或2个商店，则仓库位于中位数处是距离和最小的。（反证即可）\n2.依据上面的思路进行动态规划。dp[ i ][ j ]代表前j个商店有i个仓库，找到动态转移方程：\ndp[ i ][ j ] = min( dp[ i ][ j ] , dp[ i-1 ][ m ] + cost[ m+1 ][ j ])\n其中 i-1<=m<=j-1, 由于仓库数量确定为i-1，而商店数量未知，但可以确定他的取值范围。（第i-1个仓库在第i-1个商店）m=i-1,（第i个仓库在j处），则m=j-1。\n"
  },
  {
    "head": "HIT 软件构造21年春lab总结",
    "paragraphs": [
      "HIT 软件构造21年春lab",
      "Lab1",
      "P2 convexHull",
      "Lab2",
      "迭代器删除",
      "toString的益处",
      "AF，REP的理解",
      "参数输入类型的对比",
      "Lab2",
      "1.MultiIntervalSet对于IntervalSet的委派",
      "关于周期性的疑惑",
      "Lab1",
      "P2 convexHull",
      "关于二维凸包的一个问题，一开始的想法是：先选定最右下角的点作为基点，然后如果下一个点在相对于以基点做的y轴的右侧则后续的点都得选取逆时针角度最大的点，直到回到基点。以上想法是由于之前写过一个计算两个向量转向的函数，而如果是逆时针的话就是角度大于180度，所以就相当于寻找旋转角最大的即可，不过实际操作起来发现时间复杂度过大，于是去寻找了相关的算法，发现了向量叉乘结果可以判断逆时针还是顺时针，于是陷入了沉思。",
      "向量的叉乘究竟是如何判断逆时针还是顺时针，我查找了许多的参考资料都没有一个完整地解答这一个原理。我们知道，根据右手螺旋守则，逆时针方向的向量叉乘都指向同一侧，而顺时针都指向另一侧，个人猜测这个原理是个发现，由于发现逆时针叉乘结果都是正的，才规定叉乘结果是正就是逆时针，叉乘结果是负就是顺时针。",
      "Lab2",
      "在lab2中有许多新的发现。",
      "迭代器删除",
      "例如如果要删除容器里面的元素，例如：list，map，set。最好是使用迭代器来删除，因为如果用for循环来删除，假设当删去第i个元素时，后续的所有元素就会往前移动，第i+1变为i，i+2变为i+1……。而此时循环中的控制循环次数变量仍是i，且下一个循环就变为i+1，而我们本来的i+1元素已经到了第i个元素，所以会有漏删的可能性。这种时候我们就最好使用迭代器删除。然后迭代器中最难书写的就是Map了，需要在Map.Entry使用迭代器。",
      "toString的益处",
      "toString()函数在debug中的帮助。toString是为了让我们更好地理解一个ADT类，用人能听懂的话。当我们override了toString后，我们在debug时，我们的ADT变量就会用我们定义的toString来表示，如果我们没有toString，则该变量显示的就是内存地址，这不方便我们去理解内部的情况，所以后续在编写ADT时，最好先将toString完成。",
      "AF，REP的理解",
      "AF我的理解是用人的语言去描述ADT类型，让使用者可以听懂这个ADT是用来表示什么的。",
      "REP我的理解是它声明了有什么变量，变量之间或者变量本身要满足什么关系。",
      "参数输入类型的对比",
      "在FriendshipGraph中，我将原本的参数输入从Person改为String，然后在方法内部再new出Person。这里是由于习题课的时候老师提过一嘴，采用基础数据类型的好处在于让客户端对我们内部的实现了解更少，这样子更有利于我们保护内部的数据。",
      "Lab2",
      "1.MultiIntervalSet对于IntervalSet的委派",
      "在MultiIntervalSet中要求将IntervalSet作为我们的Rep，称为intervalSet，需要复用IntervalSet中已实现的类和功能。但是IntervalSet接口的实现类CommonIntervalSet是针对标签只有一个时间段的插入。那么问题来了，如果要在MultiIntervalSet中通过intervalSet来插入一个标签多个时间段就必须得重写MultiIntervalSet的标签。然而时间段的管理都在intervalSet这个我们的Rep中的成员变量中。",
      "但是MultiIntervalSet正常来说是无法范文IntervalSet中的Rep，所以我们就需要将IntervalSet中的Rep返回出来，于是我增加了一个getIntervalSet的函数。",
      "现在又有个问题了：当DutyIntervalSet继承了CommonIntervalSet，它就多了一个getIntervalSet函数，很显然在DutyIntervalSet类中，我们是不想把他的Rep返回给客户端，对于这个问题我的想法是将DutyIntervalSet的getIntervalSet重写为空，但是这个方法又不符合LSP原则了。",
      "所以重写了MultiIntervalSet中的Rep，一开始的方法是将IntervalSet中的rep定义为Map<L, List<·Interval >>。现在我们将MultiIntervalSet中的Rep定义为List<·IntervalSet>。如果同一个标签有新的Interval就往List中add一个新的Interval。由此能很好地实现委派的任务。",
      "关于周期性的疑惑",
      "关于App1与App2，没有要求周期性。那么岂不本应该意味着App1和App2不论是否满足周期性都是正确的？而且App1本身便是一个标签一个时间段，从定义上一开始就不满足周期性。所以对于App1和App2我不去检验周期性，而对于App3由于要求满足周期性原则，所以如果经检验，不满足周期性我便抛出异常。",
      "以上是我对周期性的理解。"
    ],
    "sentences": [
      "HIT 软件构造21年春lab",
      "Lab1",
      "P2 convexHull",
      "Lab2",
      "迭代器删除",
      "toString的益处",
      "AF，REP的理解",
      "参数输入类型的对比",
      "Lab2",
      "1.MultiIntervalSet对于IntervalSet的委派",
      "关于周期性的疑惑",
      "Lab1",
      "P2 convexHull",
      "关于二维凸包的一个问题",
      "一开始的想法是：先选定最右下角的点作为基点",
      "然后如果下一个点在相对于以基点做的y轴的右侧则后续的点都得选取逆时针角度最大的点",
      "直到回到基点",
      "以上想法是由于之前写过一个计算两个向量转向的函数",
      "而如果是逆时针的话就是角度大于180度",
      "所以就相当于寻找旋转角最大的即可",
      "不过实际操作起来发现时间复杂度过大",
      "于是去寻找了相关的算法",
      "发现了向量叉乘结果可以判断逆时针还是顺时针",
      "于是陷入了沉思",
      "向量的叉乘究竟是如何判断逆时针还是顺时针",
      "我查找了许多的参考资料都没有一个完整地解答这一个原理",
      "我们知道",
      "根据右手螺旋守则",
      "逆时针方向的向量叉乘都指向同一侧",
      "而顺时针都指向另一侧",
      "个人猜测这个原理是个发现",
      "由于发现逆时针叉乘结果都是正的",
      "才规定叉乘结果是正就是逆时针",
      "叉乘结果是负就是顺时针",
      "Lab2",
      "在lab2中有许多新的发现",
      "迭代器删除",
      "例如如果要删除容器里面的元素，例如：list，map，set",
      "最好是使用迭代器来删除",
      "因为如果用for循环来删除",
      "假设当删去第i个元素时",
      "后续的所有元素就会往前移动",
      "第i+1变为i",
      "i+2变为i+1……",
      "而此时循环中的控制循环次数变量仍是i",
      "且下一个循环就变为i+1",
      "而我们本来的i+1元素已经到了第i个元素",
      "所以会有漏删的可能性",
      "这种时候我们就最好使用迭代器删除",
      "然后迭代器中最难书写的就是Map了",
      "需要在Map.Entry使用迭代器",
      "toString的益处",
      "toString()函数在debug中的帮助",
      "toString是为了让我们更好地理解一个ADT类",
      "用人能听懂的话",
      "当我们override了toString后",
      "我们在debug时",
      "我们的ADT变量就会用我们定义的toString来表示",
      "如果我们没有toString",
      "则该变量显示的就是内存地址",
      "这不方便我们去理解内部的情况",
      "所以后续在编写ADT时",
      "最好先将toString完成",
      "AF，REP的理解",
      "AF我的理解是用人的语言去描述ADT类型",
      "让使用者可以听懂这个ADT是用来表示什么的",
      "REP我的理解是它声明了有什么变量",
      "变量之间或者变量本身要满足什么关系",
      "参数输入类型的对比",
      "在FriendshipGraph中",
      "我将原本的参数输入从Person改为String",
      "然后在方法内部再new出Person",
      "这里是由于习题课的时候老师提过一嘴",
      "采用基础数据类型的好处在于让客户端对我们内部的实现了解更少",
      "这样子更有利于我们保护内部的数据",
      "Lab2",
      "1.MultiIntervalSet对于IntervalSet的委派",
      "在MultiIntervalSet中要求将IntervalSet作为我们的Rep",
      "称为intervalSet",
      "需要复用IntervalSet中已实现的类和功能",
      "但是IntervalSet接口的实现类CommonIntervalSet是针对标签只有一个时间段的插入",
      "那么问题来了",
      "如果要在MultiIntervalSet中通过intervalSet来插入一个标签多个时间段就必须得重写MultiIntervalSet的标签",
      "然而时间段的管理都在intervalSet这个我们的Rep中的成员变量中",
      "但是MultiIntervalSet正常来说是无法范文IntervalSet中的Rep",
      "所以我们就需要将IntervalSet中的Rep返回出来",
      "于是我增加了一个getIntervalSet的函数",
      "现在又有个问题了：当DutyIntervalSet继承了CommonIntervalSet",
      "它就多了一个getIntervalSet函数",
      "很显然在DutyIntervalSet类中",
      "我们是不想把他的Rep返回给客户端",
      "对于这个问题我的想法是将DutyIntervalSet的getIntervalSet重写为空",
      "但是这个方法又不符合LSP原则了",
      "所以重写了MultiIntervalSet中的Rep",
      "一开始的方法是将IntervalSet中的rep定义为Map<L, List<·Interval >>",
      "现在我们将MultiIntervalSet中的Rep定义为List<·IntervalSet>",
      "如果同一个标签有新的Interval就往List中add一个新的Interval",
      "由此能很好地实现委派的任务",
      "关于周期性的疑惑",
      "关于App1与App2，没有要求周期性",
      "那么岂不本应该意味着App1和App2不论是否满足周期性都是正确的？而且App1本身便是一个标签一个时间段",
      "从定义上一开始就不满足周期性",
      "所以对于App1和App2我不去检验周期性",
      "而对于App3由于要求满足周期性原则",
      "所以如果经检验",
      "不满足周期性我便抛出异常",
      "以上是我对周期性的理解"
    ],
    "codes": [],
    "date": "2021-06-15",
    "text": "HIT 软件构造21年春lab\nLab1\nP2 convexHull\nLab2\n迭代器删除\ntoString的益处\nAF，REP的理解\n参数输入类型的对比\nLab2\n1.MultiIntervalSet对于IntervalSet的委派\n关于周期性的疑惑\nLab1\nP2 convexHull\n关于二维凸包的一个问题，一开始的想法是：先选定最右下角的点作为基点，然后如果下一个点在相对于以基点做的y轴的右侧则后续的点都得选取逆时针角度最大的点，直到回到基点。以上想法是由于之前写过一个计算两个向量转向的函数，而如果是逆时针的话就是角度大于180度，所以就相当于寻找旋转角最大的即可，不过实际操作起来发现时间复杂度过大，于是去寻找了相关的算法，发现了向量叉乘结果可以判断逆时针还是顺时针，于是陷入了沉思。\n向量的叉乘究竟是如何判断逆时针还是顺时针，我查找了许多的参考资料都没有一个完整地解答这一个原理。我们知道，根据右手螺旋守则，逆时针方向的向量叉乘都指向同一侧，而顺时针都指向另一侧，个人猜测这个原理是个发现，由于发现逆时针叉乘结果都是正的，才规定叉乘结果是正就是逆时针，叉乘结果是负就是顺时针。\nLab2\n在lab2中有许多新的发现。\n迭代器删除\n例如如果要删除容器里面的元素，例如：list，map，set。最好是使用迭代器来删除，因为如果用for循环来删除，假设当删去第i个元素时，后续的所有元素就会往前移动，第i+1变为i，i+2变为i+1……。而此时循环中的控制循环次数变量仍是i，且下一个循环就变为i+1，而我们本来的i+1元素已经到了第i个元素，所以会有漏删的可能性。这种时候我们就最好使用迭代器删除。然后迭代器中最难书写的就是Map了，需要在Map.Entry使用迭代器。\ntoString的益处\ntoString()函数在debug中的帮助。toString是为了让我们更好地理解一个ADT类，用人能听懂的话。当我们override了toString后，我们在debug时，我们的ADT变量就会用我们定义的toString来表示，如果我们没有toString，则该变量显示的就是内存地址，这不方便我们去理解内部的情况，所以后续在编写ADT时，最好先将toString完成。\nAF，REP的理解\nAF我的理解是用人的语言去描述ADT类型，让使用者可以听懂这个ADT是用来表示什么的。\nREP我的理解是它声明了有什么变量，变量之间或者变量本身要满足什么关系。\n参数输入类型的对比\n在FriendshipGraph中，我将原本的参数输入从Person改为String，然后在方法内部再new出Person。这里是由于习题课的时候老师提过一嘴，采用基础数据类型的好处在于让客户端对我们内部的实现了解更少，这样子更有利于我们保护内部的数据。\nLab2\n1.MultiIntervalSet对于IntervalSet的委派\n在MultiIntervalSet中要求将IntervalSet作为我们的Rep，称为intervalSet，需要复用IntervalSet中已实现的类和功能。但是IntervalSet接口的实现类CommonIntervalSet是针对标签只有一个时间段的插入。那么问题来了，如果要在MultiIntervalSet中通过intervalSet来插入一个标签多个时间段就必须得重写MultiIntervalSet的标签。然而时间段的管理都在intervalSet这个我们的Rep中的成员变量中。\n但是MultiIntervalSet正常来说是无法范文IntervalSet中的Rep，所以我们就需要将IntervalSet中的Rep返回出来，于是我增加了一个getIntervalSet的函数。\n现在又有个问题了：当DutyIntervalSet继承了CommonIntervalSet，它就多了一个getIntervalSet函数，很显然在DutyIntervalSet类中，我们是不想把他的Rep返回给客户端，对于这个问题我的想法是将DutyIntervalSet的getIntervalSet重写为空，但是这个方法又不符合LSP原则了。\n所以重写了MultiIntervalSet中的Rep，一开始的方法是将IntervalSet中的rep定义为Map<L, List<·Interval >>。现在我们将MultiIntervalSet中的Rep定义为List<·IntervalSet>。如果同一个标签有新的Interval就往List中add一个新的Interval。由此能很好地实现委派的任务。\n关于周期性的疑惑\n关于App1与App2，没有要求周期性。那么岂不本应该意味着App1和App2不论是否满足周期性都是正确的？而且App1本身便是一个标签一个时间段，从定义上一开始就不满足周期性。所以对于App1和App2我不去检验周期性，而对于App3由于要求满足周期性原则，所以如果经检验，不满足周期性我便抛出异常。\n以上是我对周期性的理解。\n"
  },
  {
    "head": "LSP原则学习笔记",
    "paragraphs": [
      "LSP原则要求，子类要能替换父类型，从中总结出几点符合的条件要求：",
      "子类的Spec要强于或等于父类。Spec强=前置条件更弱 |（在对比双方中满足更强的前置条件下）后置条件更强。",
      "子类型的异常可以更具体，协变",
      "子类型的返回类型可以更具体，协变",
      "其实这点很好理解，比如父类的返回值原本为Animal，换回子类型之后，返回的是Cat，其中Cat extends Animal，这在编译上是可以通过的。如果父类型是Cat，子类型返回Animal，那这就在编译上无法通过了",
      "子类型的参数类型可以更宽松，逆变",
      "同样从编译角度去考虑，假设父类型传入的是一个接口的参数，例如ArrayList<.L>，那么子类型改为List<.L>，原本传入父类型的参数仍然可以传入子类型的对象中，所以是满足的。如果反过来，父类型中是List<.L>，子类型是ArrayList<.L>，那么这在编译上就不能通过了，因为传入父类型的参数可以是LinkList，与ArrayList不同。"
    ],
    "sentences": [
      "LSP原则要求",
      "子类要能替换父类型",
      "从中总结出几点符合的条件要求：子类的Spec要强于或等于父类",
      "Spec强=前置条件更弱 |（在对比双方中满足更强的前置条件下）后置条件更强",
      "子类型的异常可以更具体，协变",
      "子类型的返回类型可以更具体，协变",
      "其实这点很好理解",
      "比如父类的返回值原本为Animal",
      "换回子类型之后",
      "返回的是Cat",
      "其中Cat extends Animal",
      "这在编译上是可以通过的",
      "如果父类型是Cat",
      "子类型返回Animal",
      "那这就在编译上无法通过了",
      "子类型的参数类型可以更宽松，逆变",
      "同样从编译角度去考虑",
      "假设父类型传入的是一个接口的参数",
      "例如ArrayList<.L>",
      "那么子类型改为List<.L>",
      "原本传入父类型的参数仍然可以传入子类型的对象中",
      "所以是满足的",
      "如果反过来",
      "父类型中是List<.L>",
      "子类型是ArrayList<.L>",
      "那么这在编译上就不能通过了",
      "因为传入父类型的参数可以是LinkList",
      "与ArrayList不同"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "LSP原则要求，子类要能替换父类型，从中总结出几点符合的条件要求：\n子类的Spec要强于或等于父类。Spec强=前置条件更弱 |（在对比双方中满足更强的前置条件下）后置条件更强。\n子类型的异常可以更具体，协变\n子类型的返回类型可以更具体，协变\n其实这点很好理解，比如父类的返回值原本为Animal，换回子类型之后，返回的是Cat，其中Cat extends Animal，这在编译上是可以通过的。如果父类型是Cat，子类型返回Animal，那这就在编译上无法通过了\n子类型的参数类型可以更宽松，逆变\n同样从编译角度去考虑，假设父类型传入的是一个接口的参数，例如ArrayList<.L>，那么子类型改为List<.L>，原本传入父类型的参数仍然可以传入子类型的对象中，所以是满足的。如果反过来，父类型中是List<.L>，子类型是ArrayList<.L>，那么这在编译上就不能通过了，因为传入父类型的参数可以是LinkList，与ArrayList不同。\n"
  },
  {
    "head": "代码之路- Joseph‘s problem I（Joseph问题）",
    "paragraphs": [
      "1016 - Joseph's problem I（Joseph问题）",
      "Problem Description",
      "Input",
      "Output",
      "Sample Input",
      "Sample Output",
      "AC代码",
      "Problem Description",
      "The Joseph’s problem is notoriously known. For those who are not familiar with the problem, among n people numbered 1,2…n, standing in circle every mth is going to be executed and only the life of the last remaining person will be saved. Joseph was smart enough to choose the position of the last remaining person, thus saving his life to give the message about the incident.",
      "Although many good programmers have been saved since Joseph spread out this information, Joseph’s cousin introduced a new variant of the malignant game. This insane character is known for its barbarian ideas and wishes to clean up the world from silly programmers. We had to infiltrate some the agents of the ACM in order to know the process in this new mortal game.",
      "In order to save yourself from this evil practice, you must develop a tool capable of predicting which person will be saved.",
      "The Destructive Process",
      "The persons are eliminated in a very peculiar order; m is a dynamical variable, which each time takes a different value corresponding to the prime numbers’ succession (2,3,5,7…). So in order to kill the ith person, Joseph’s cousin counts up to the ith prime.",
      "Input",
      "It consists of separate lines containing n [1…3501], and finishes with a 0.",
      "Output",
      "The output will consist in separate lines containing the position of the person which life will be saved.",
      "Sample Input",
      "Sample Output",
      "约瑟夫环指的是在n个人中，从第一个人开始数数，数到m时，第m个人就被淘汰，之后再继续从第m+1个人开始重新数数。求最后被留下来的人在初始n个人中排第几个。而本题m是变量。不过只要修改下求解方程即可。",
      "约瑟夫环可以从一开始开始求解，不过此时需要创立数组进行维护，由于维护非常麻烦，所以想到能否从最后一个开始去逆推。于是找到了如下的关系式",
      "x’(第n轮的序号)=x(第n-1轮的序号)-(m(要数的个数)% people（第n-1轮的人数）",
      "修改下为如下式子：",
      "x = (x’ + m(第n-1轮要数的个数)) % people",
      "AC代码"
    ],
    "sentences": [
      "1016 - Joseph's problem I（Joseph问题）",
      "Problem Description",
      "Input",
      "Output",
      "Sample Input",
      "Sample Output",
      "AC代码",
      "Problem Description",
      "The Joseph’s problem is notoriously known. For those who are not familiar with the problem, among n people numbered 1,2…n, standing in circle every mth is going to be executed and only the life of the last remaining person will be saved. Joseph was smart enough to choose the position of the last remaining person, thus saving his life to give the message about the incident.Although many good programmers have been saved since Joseph spread out this information, Joseph’s cousin introduced a new variant of the malignant game. This insane character is known for its barbarian ideas and wishes to clean up the world from silly programmers. We had to infiltrate some the agents of the ACM in order to know the process in this new mortal game.In order to save yourself from this evil practice, you must develop a tool capable of predicting which person will be saved.The Destructive Process",
      "The persons are eliminated in a very peculiar order; m is a dynamical variable, which each time takes a different value corresponding to the prime numbers’ succession (2,3,5,7…). So in order to kill the ith person, Joseph’s cousin counts up to the ith prime.Input",
      "It consists of separate lines containing n [1…3501], and finishes with a 0.Output",
      "The output will consist in separate lines containing the position of the person which life will be saved.Sample Input",
      "Sample Output",
      "约瑟夫环指的是在n个人中",
      "从第一个人开始数数",
      "数到m时",
      "第m个人就被淘汰",
      "之后再继续从第m+1个人开始重新数数",
      "求最后被留下来的人在初始n个人中排第几个",
      "而本题m是变量",
      "不过只要修改下求解方程即可",
      "约瑟夫环可以从一开始开始求解",
      "不过此时需要创立数组进行维护",
      "由于维护非常麻烦",
      "所以想到能否从最后一个开始去逆推",
      "于是找到了如下的关系式",
      "x’(第n轮的序号)=x(第n-1轮的序号)-(m(要数的个数)% people（第n-1轮的人数）",
      "修改下为如下式子：x = (x’ + m(第n-1轮要数的个数)) % people",
      "AC代码"
    ],
    "codes": [
      "#include <stdio.h>\n#include <stdlib.h>\n#define Max 3502\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\nint prime[Max];\n\nvoid isprime(){\n\tint cnt = 0, i = 3;\n\tprime[cnt++] = 2;\n\twhile(1){\n\t\tint flag = 0;\n\t\tfor(int j = 2; j < i; j++){\n\t\t\tif(i%j == 0){\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag == 0){\n\t\t\tprime[cnt++] = i;\n\t\t}\n\t\tif(cnt > Max){\n\t\t\tbreak;\n\t\t}\n\t\ti += 2;\n\t}\n}\n\nint main() {\n\tint n;\n\tisprime();\n\twhile(scanf(\"%d\",&n),n){\n\t\tint cut = n-2, ans = 0, people = 2;\n\t\tfor(; cut >=0; cut--, people++){\n\t\t\tint box = prime[cut];\n\t\t\tans = (ans+box) % people;\n\t\t}\n\t\tprintf(\"%d\\n\",ans+1);\n\t}\n\treturn 0;\n}\n"
    ],
    "date": "2020-09-18",
    "text": "1016 - Joseph's problem I（Joseph问题）\nProblem Description\nInput\nOutput\nSample Input\nSample Output\nAC代码\nProblem Description\nThe Joseph’s problem is notoriously known. For those who are not familiar with the problem, among n people numbered 1,2…n, standing in circle every mth is going to be executed and only the life of the last remaining person will be saved. Joseph was smart enough to choose the position of the last remaining person, thus saving his life to give the message about the incident.\nAlthough many good programmers have been saved since Joseph spread out this information, Joseph’s cousin introduced a new variant of the malignant game. This insane character is known for its barbarian ideas and wishes to clean up the world from silly programmers. We had to infiltrate some the agents of the ACM in order to know the process in this new mortal game.\nIn order to save yourself from this evil practice, you must develop a tool capable of predicting which person will be saved.\nThe Destructive Process\nThe persons are eliminated in a very peculiar order; m is a dynamical variable, which each time takes a different value corresponding to the prime numbers’ succession (2,3,5,7…). So in order to kill the ith person, Joseph’s cousin counts up to the ith prime.\nInput\nIt consists of separate lines containing n [1…3501], and finishes with a 0.\nOutput\nThe output will consist in separate lines containing the position of the person which life will be saved.\nSample Input\nSample Output\n约瑟夫环指的是在n个人中，从第一个人开始数数，数到m时，第m个人就被淘汰，之后再继续从第m+1个人开始重新数数。求最后被留下来的人在初始n个人中排第几个。而本题m是变量。不过只要修改下求解方程即可。\n约瑟夫环可以从一开始开始求解，不过此时需要创立数组进行维护，由于维护非常麻烦，所以想到能否从最后一个开始去逆推。于是找到了如下的关系式\nx’(第n轮的序号)=x(第n-1轮的序号)-(m(要数的个数)% people（第n-1轮的人数）\n修改下为如下式子：\nx = (x’ + m(第n-1轮要数的个数)) % people\nAC代码\n"
  },
  {
    "head": "Decoding Task",
    "paragraphs": [
      "Decoding Task",
      "AC代码",
      "题目偏长，放一个链接",
      "http://acm.hit.edu.cn/problemset/1012",
      "本题难度感觉在于题目理解，题目要求2个十六进制数来代表一个btye，所以首先2个字符2个字符处理，转换为十进制。由于第二串字符（记为bi）多出一个空格（由十进制的32表示）。所以先用32异或b[1]，得到第一个密匙，在与第一串字符（记为ai）a[1]异或，得到明文，以此类推。",
      "AC代码"
    ],
    "sentences": [
      "Decoding Task",
      "AC代码",
      "题目偏长，放一个链接",
      "http://acm.hit.edu.cn/problemset/1012",
      "本题难度感觉在于题目理解",
      "题目要求2个十六进制数来代表一个btye",
      "所以首先2个字符2个字符处理",
      "转换为十进制",
      "由于第二串字符（记为bi）多出一个空格（由十进制的32表示）",
      "所以先用32异或b[1]",
      "得到第一个密匙",
      "在与第一串字符（记为ai）a[1]异或",
      "得到明文",
      "以此类推",
      "AC代码"
    ],
    "codes": [
      "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define M 20006\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\nchar a[M],b[M],c[M];\nint ans[M];\nint len;\n\nint cread(char x){\t16进制转换为10进制\n\tif(x >= 'A'){\n\t\treturn x-'A'+10;\n\t}\n\tif(x >= '0' && x <= '9'){\n\t\treturn x-'0';\n\t}\n}\n\nvoid todec(char *x){\t先将第一个字符串转换为十进制\n\tfor(int i = 0; i < len; i += 2){\n\t\tans[i/2] = cread(x[i])*16 + cread(x[i+1]);\n\t}\n}\n\nint main(int argc, char *argv[]) {\n\twhile(scanf(\"%s%s\",a,b) != EOF){\n\t\tlen = strlen(a);\n\t\ttodec(a);\n\t\tint ex = 32, cnt = 0;\n\t\tfor(int i = 0; i < len+2; i += 2){\n\t\t\tint x = cread(b[i]), y = cread(b[i+1]);\n\t\t\tx = x*16+y;\n\t\t\tex = ex^x;\n\t\t\tprintf(\"%02X\", ex);\n\t\t\tex = ans[cnt++]^ex;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n"
    ],
    "date": "2020-09-15",
    "text": "Decoding Task\nAC代码\n题目偏长，放一个链接\nhttp://acm.hit.edu.cn/problemset/1012\n本题难度感觉在于题目理解，题目要求2个十六进制数来代表一个btye，所以首先2个字符2个字符处理，转换为十进制。由于第二串字符（记为bi）多出一个空格（由十进制的32表示）。所以先用32异或b[1]，得到第一个密匙，在与第一串字符（记为ai）a[1]异或，得到明文，以此类推。\nAC代码\n"
  },
  {
    "head": "软件构造的一些个人体会2",
    "paragraphs": [
      "在整个软件构造的课程中和学习Java的过程当中，学到了一些比较重要的知识点。对于一些知识点我理解的不是很透彻，觉得还是要进一步多学习一些。在这里稍微地总结一下之前学到的，理解起来对我来说比较困难的一些知识点吧。",
      "关于Immutable和mutable",
      "这个方面是在学习的时候让我感到比较难理解的。对于immutable：拥有方法可以修改自己的值或者引用，对于mutable：一旦被创建，始终指向同一个值或者引用。比如一个经常被举得例子，就是String和StringBuilder。",
      "mutable和immediate各有各的好处吧，不过为了避免一些错误，保证程序的正确性，多考虑使用mutable。",
      "spec结构和强度",
      "这个是课程的一个很重要的部分，实验和上课的时候经常强调。对于spec：",
      "前置条件：对客户端的约束，在使用方法时必须满足的条件；",
      "@param annotation：说明每个参数的前置条件；",
      "后置条件：对开发者的约束，方法结束时必须满足的条件；",
      "@return annotation：说明后置条件；",
      "@throws annotation：说明出现异常的时候会发生什么。",
      "对于spec的强度，一般来说，使得spec变强的要求是更宽松的前置条件，加上更严格的后置条件。同时要注意，spec不可以暴露实现细节，不可以暴露局部变量，也不可以暴露私有的数据域。",
      "关于等价性",
      "不可变类型的等价性",
      "判断等价的两个方式：",
      "AF映射到同样的结果，则等价。",
      "站在外部观察者角度：对两个对象调用任何相同的操作，都会得到相同的结果，则认为这两个对象是等价的。两个等价的对象调用相同的Observer应该返回相同的结果。",
      "==：引用等价性",
      "equals()：对象等价性",
      "可变数据类型的等价性",
      "观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致。调用Observer方法表现出相同的结果。约等于对象等价性。",
      "行为等价性：约等于引用等价性。调用对象的任何方法都展示出一致的结果。包括mutator、producer、observer。",
      "其他部分",
      "其他的很多知识点也是很重要的，比如继承，委派，逆变，协变，LSP等部分，在这里就不具体的展开了，毕竟我自己觉得我的理解还是有待提升的。"
    ],
    "sentences": [
      "在整个软件构造的课程中和学习Java的过程当中",
      "学到了一些比较重要的知识点",
      "对于一些知识点我理解的不是很透彻，觉得还是要进一步多学习一些",
      "在这里稍微地总结一下之前学到的",
      "理解起来对我来说比较困难的一些知识点吧",
      "关于Immutable和mutable",
      "这个方面是在学习的时候让我感到比较难理解的",
      "对于immutable：拥有方法可以修改自己的值或者引用",
      "对于mutable：一旦被创建",
      "始终指向同一个值或者引用",
      "比如一个经常被举得例子",
      "就是String和StringBuilder",
      "mutable和immediate各有各的好处吧",
      "不过为了避免一些错误",
      "保证程序的正确性",
      "多考虑使用mutable",
      "spec结构和强度",
      "这个是课程的一个很重要的部分，实验和上课的时候经常强调",
      "对于spec：前置条件：对客户端的约束",
      "在使用方法时必须满足的条件；@param annotation：说明每个参数的前置条件；后置条件：对开发者的约束",
      "方法结束时必须满足的条件；@return annotation：说明后置条件；@throws annotation：说明出现异常的时候会发生什么",
      "对于spec的强度",
      "一般来说",
      "使得spec变强的要求是更宽松的前置条件",
      "加上更严格的后置条件",
      "同时要注意",
      "spec不可以暴露实现细节",
      "不可以暴露局部变量",
      "也不可以暴露私有的数据域",
      "关于等价性",
      "不可变类型的等价性",
      "判断等价的两个方式：AF映射到同样的结果，则等价",
      "站在外部观察者角度：对两个对象调用任何相同的操作",
      "都会得到相同的结果",
      "则认为这两个对象是等价的",
      "两个等价的对象调用相同的Observer应该返回相同的结果",
      "==：引用等价性",
      "equals()：对象等价性",
      "可变数据类型的等价性",
      "观察等价性：在不改变状态的情况下",
      "两个mutable对象是否看起来一致",
      "调用Observer方法表现出相同的结果",
      "约等于对象等价性",
      "行为等价性：约等于引用等价性",
      "调用对象的任何方法都展示出一致的结果",
      "包括mutator、producer、observer",
      "其他部分",
      "其他的很多知识点也是很重要的",
      "比如继承",
      "委派",
      "逆变",
      "协变",
      "LSP等部分",
      "在这里就不具体的展开了",
      "毕竟我自己觉得我的理解还是有待提升的"
    ],
    "codes": [
      "String s = \"a\";\t//开辟一个存储空间，里面存着字符a，s指向这块空间，记为space1\nString t = s;\t//让t指向s所指向的空间即space1\ns = s.concat(\"b\"); //把字符a和字符b连接，然后把“ab”放在一个新的存储空间，记为space2，最后让s指向这块空间\n//我们可以看到，现在s和t所指向的是两块不同的空间，空间中的内容也不一样，因此s和t的效果是不一样的\n\nStringBuilder sb = new StringBuilder(\"a\"); //开辟一个存储空间，里面存着字符a\nStringBuilder tb = sb;\t//开辟一个存储空间，里面存着字符a\nsb.append(\"b\");\t//取出a，然后与字符b连接，然后把“ab”仍然放在这块空间内，把原来的“a”覆盖了，sb的指向没变\n//在这个情况下，由于从始至终只用到了一块存储空间，所以sb和tb的效果实际上是相同的\n"
    ],
    "date": "2021-07-07",
    "text": "在整个软件构造的课程中和学习Java的过程当中，学到了一些比较重要的知识点。对于一些知识点我理解的不是很透彻，觉得还是要进一步多学习一些。在这里稍微地总结一下之前学到的，理解起来对我来说比较困难的一些知识点吧。\n关于Immutable和mutable\n这个方面是在学习的时候让我感到比较难理解的。对于immutable：拥有方法可以修改自己的值或者引用，对于mutable：一旦被创建，始终指向同一个值或者引用。比如一个经常被举得例子，就是String和StringBuilder。\nmutable和immediate各有各的好处吧，不过为了避免一些错误，保证程序的正确性，多考虑使用mutable。\nspec结构和强度\n这个是课程的一个很重要的部分，实验和上课的时候经常强调。对于spec：\n前置条件：对客户端的约束，在使用方法时必须满足的条件；\n@param annotation：说明每个参数的前置条件；\n后置条件：对开发者的约束，方法结束时必须满足的条件；\n@return annotation：说明后置条件；\n@throws annotation：说明出现异常的时候会发生什么。\n对于spec的强度，一般来说，使得spec变强的要求是更宽松的前置条件，加上更严格的后置条件。同时要注意，spec不可以暴露实现细节，不可以暴露局部变量，也不可以暴露私有的数据域。\n关于等价性\n不可变类型的等价性\n判断等价的两个方式：\nAF映射到同样的结果，则等价。\n站在外部观察者角度：对两个对象调用任何相同的操作，都会得到相同的结果，则认为这两个对象是等价的。两个等价的对象调用相同的Observer应该返回相同的结果。\n==：引用等价性\nequals()：对象等价性\n可变数据类型的等价性\n观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致。调用Observer方法表现出相同的结果。约等于对象等价性。\n行为等价性：约等于引用等价性。调用对象的任何方法都展示出一致的结果。包括mutator、producer、observer。\n其他部分\n其他的很多知识点也是很重要的，比如继承，委派，逆变，协变，LSP等部分，在这里就不具体的展开了，毕竟我自己觉得我的理解还是有待提升的。\n"
  },
  {
    "head": "软件构造的一些个人体会1",
    "paragraphs": [
      "大二下学期的后半学期，学校开了软件构造这一门课。到不久之前结课为止，也是上了大半学期了，所以就在期末之前稍微提一下在这们课上学到的一些东西和自己的一些个人体会吧。",
      "1.Git和GitHub在课程中的使用",
      "在大一的时候就已经听过学长在讲座上介绍过Git以及GitHub，但是当时没有系统的学习过，就一直对这个东西是半懂不懂的状态。在软构这门课上，专门学习了版本控制系统VCS，同时实验课要求使用Git上传代码到GitHub上，所以自己查了一些资料，算是有了一些基本的了解了。",
      "在软件构造实验的时候使用到的git命令不多，主要是以下这一些：",
      "创建：git init",
      "暂存：git add .",
      "链接：git remote add origin",
      " 提交：git commit -m “commit message”",
      "推送：git push- u origin master",
      "在实验三还涉及到一些分支的命令。",
      "2.对于测试的一些想法",
      "软件构造课程上，老师十分强调测试用例的重要性，实验的要求里面也是十分的重视写测试代码。这里跟之前接触到的编程课还是有些不同的。之前的课程，比如大一的程序设计基础，还有上学期的数据结构和这学期的计算机系统，主要是使用的C语言，写代码的时候也没有特意去强调测试用例和debug等方面。不过在这一门课程里，不同的就是真的很重视测试代码。虽然我在写实验的过程中对写测试代码不是很熟练，有时候会有抵触的情绪，但是客观的说，测试用例能帮助我们节约很多的调试时间。以及，通过测试衍生出来的代码覆盖度问题，选取测试用例的问题，我认为都是很有帮助的。",
      "3.spec和代码注释",
      "之前的编程课强调实现的过程，更多的是自己和自己之间的一种行为，因此我在写代码，对于注释总是觉得能省则省，能够满足基本的看得懂就行。而现在在软件构造这门课上，更多的是强调了面向对象的思想，这时候写spec和代码的注释等就很重要了，不过在这方面我觉得我的意识还是不够。课程里面也是有挺多的地方涉及到这一方面的东西。好的spec好像⼀道防火墙⼀样将客户和实现者隔离开，它使得客户不必知道这个单元是如何运行的，也使得实现者不必管这个单元会被怎么使用。",
      "4.课程的一些想法",
      "这一门课最主要的内容就是介绍ADT和OOP的部分，还有一些复用性和可维护性的知识点，最后又讲了一些面向健壮性与正确性的内容。由于课时的压缩，整体的课程压力还是很大的。个人感觉难理解的主要是ADT以及OOP，可能是因为之前没学过Java，在大一的夏季学期学习的C++也忘了挺多内容的。再加上课程的课时紧张，要求我们自学Java，这就导致了在某一些方面学的不精的问题了。课程的内容比较多，全部面面俱到是很难的，我自己能力也不足。在后面的博客我想要讲一些我自己觉得比较重要的部分吧。"
    ],
    "sentences": [
      "大二下学期的后半学期，学校开了软件构造这一门课",
      "到不久之前结课为止",
      "也是上了大半学期了",
      "所以就在期末之前稍微提一下在这们课上学到的一些东西和自己的一些个人体会吧",
      "1.Git和GitHub在课程中的使用",
      "在大一的时候就已经听过学长在讲座上介绍过Git以及GitHub",
      "但是当时没有系统的学习过",
      "就一直对这个东西是半懂不懂的状态",
      "在软构这门课上",
      "专门学习了版本控制系统VCS",
      "同时实验课要求使用Git上传代码到GitHub上",
      "所以自己查了一些资料",
      "算是有了一些基本的了解了",
      "在软件构造实验的时候使用到的git命令不多",
      "主要是以下这一些：创建：git init",
      "暂存：git add .链接：git remote add origin",
      " 提交：git commit -m “commit message”",
      "推送：git push- u origin master",
      "在实验三还涉及到一些分支的命令",
      "2.对于测试的一些想法",
      "软件构造课程上",
      "老师十分强调测试用例的重要性",
      "实验的要求里面也是十分的重视写测试代码",
      "这里跟之前接触到的编程课还是有些不同的",
      "之前的课程",
      "比如大一的程序设计基础",
      "还有上学期的数据结构和这学期的计算机系统",
      "主要是使用的C语言",
      "写代码的时候也没有特意去强调测试用例和debug等方面",
      "不过在这一门课程里，不同的就是真的很重视测试代码",
      "虽然我在写实验的过程中对写测试代码不是很熟练",
      "有时候会有抵触的情绪",
      "但是客观的说",
      "测试用例能帮助我们节约很多的调试时间",
      "以及",
      "通过测试衍生出来的代码覆盖度问题",
      "选取测试用例的问题",
      "我认为都是很有帮助的",
      "3.spec和代码注释",
      "之前的编程课强调实现的过程",
      "更多的是自己和自己之间的一种行为",
      "因此我在写代码",
      "对于注释总是觉得能省则省",
      "能够满足基本的看得懂就行",
      "而现在在软件构造这门课上",
      "更多的是强调了面向对象的思想",
      "这时候写spec和代码的注释等就很重要了",
      "不过在这方面我觉得我的意识还是不够",
      "课程里面也是有挺多的地方涉及到这一方面的东西",
      "好的spec好像⼀道防火墙⼀样将客户和实现者隔离开",
      "它使得客户不必知道这个单元是如何运行的",
      "也使得实现者不必管这个单元会被怎么使用",
      "4.课程的一些想法",
      "这一门课最主要的内容就是介绍ADT和OOP的部分",
      "还有一些复用性和可维护性的知识点",
      "最后又讲了一些面向健壮性与正确性的内容",
      "由于课时的压缩，整体的课程压力还是很大的",
      "个人感觉难理解的主要是ADT以及OOP",
      "可能是因为之前没学过Java",
      "在大一的夏季学期学习的C++也忘了挺多内容的",
      "再加上课程的课时紧张",
      "要求我们自学Java",
      "这就导致了在某一些方面学的不精的问题了",
      "课程的内容比较多，全部面面俱到是很难的，我自己能力也不足",
      "在后面的博客我想要讲一些我自己觉得比较重要的部分吧"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "大二下学期的后半学期，学校开了软件构造这一门课。到不久之前结课为止，也是上了大半学期了，所以就在期末之前稍微提一下在这们课上学到的一些东西和自己的一些个人体会吧。\n1.Git和GitHub在课程中的使用\n在大一的时候就已经听过学长在讲座上介绍过Git以及GitHub，但是当时没有系统的学习过，就一直对这个东西是半懂不懂的状态。在软构这门课上，专门学习了版本控制系统VCS，同时实验课要求使用Git上传代码到GitHub上，所以自己查了一些资料，算是有了一些基本的了解了。\n在软件构造实验的时候使用到的git命令不多，主要是以下这一些：\n创建：git init\n暂存：git add .\n链接：git remote add origin\n 提交：git commit -m “commit message”\n推送：git push- u origin master\n在实验三还涉及到一些分支的命令。\n2.对于测试的一些想法\n软件构造课程上，老师十分强调测试用例的重要性，实验的要求里面也是十分的重视写测试代码。这里跟之前接触到的编程课还是有些不同的。之前的课程，比如大一的程序设计基础，还有上学期的数据结构和这学期的计算机系统，主要是使用的C语言，写代码的时候也没有特意去强调测试用例和debug等方面。不过在这一门课程里，不同的就是真的很重视测试代码。虽然我在写实验的过程中对写测试代码不是很熟练，有时候会有抵触的情绪，但是客观的说，测试用例能帮助我们节约很多的调试时间。以及，通过测试衍生出来的代码覆盖度问题，选取测试用例的问题，我认为都是很有帮助的。\n3.spec和代码注释\n之前的编程课强调实现的过程，更多的是自己和自己之间的一种行为，因此我在写代码，对于注释总是觉得能省则省，能够满足基本的看得懂就行。而现在在软件构造这门课上，更多的是强调了面向对象的思想，这时候写spec和代码的注释等就很重要了，不过在这方面我觉得我的意识还是不够。课程里面也是有挺多的地方涉及到这一方面的东西。好的spec好像⼀道防火墙⼀样将客户和实现者隔离开，它使得客户不必知道这个单元是如何运行的，也使得实现者不必管这个单元会被怎么使用。\n4.课程的一些想法\n这一门课最主要的内容就是介绍ADT和OOP的部分，还有一些复用性和可维护性的知识点，最后又讲了一些面向健壮性与正确性的内容。由于课时的压缩，整体的课程压力还是很大的。个人感觉难理解的主要是ADT以及OOP，可能是因为之前没学过Java，在大一的夏季学期学习的C++也忘了挺多内容的。再加上课程的课时紧张，要求我们自学Java，这就导致了在某一些方面学的不精的问题了。课程的内容比较多，全部面面俱到是很难的，我自己能力也不足。在后面的博客我想要讲一些我自己觉得比较重要的部分吧。\n"
  },
  {
    "head": "哈工大软件构造Lab2",
    "paragraphs": [
      "2021",
      "年春季学期",
      "计算学部《软件构造》课程",
      "Lab 2",
      "实验报告",
      "1 实验目标概述··· 1",
      "2 实验环境配置··· 1",
      "3 实验过程··· 2",
      "3.1 Poetic Walks· 2",
      "3.1.1 Get the code and prepare Git repository· 2",
      "3.1.2 Problem 1: Test · 2",
      "3.1.3 Graph <String>· 3",
      "3.1.3.1 · 3",
      "3.1.3.2 Implement ConcreteVerticesGraph· 5",
      "3.1.4 · 7",
      "3.1.4.1 · 7",
      "3.1.4.2 Implement Graph.empty()· 7",
      "3.1.5 Problem 4: Poetic walks· 8",
      "3.1.5.1 Test GraphPoet· 8",
      "3.1.5.2 Implement GraphPoet· 8",
      "3.1.5.3 Graph poetry slam·· 9",
      "3.1.6 使用Eclemma检查测试的代码覆盖度··· 9",
      "3.1.7 Before you’re done· 10",
      "3.2 Re-implement the Social Network in Lab1· 10",
      "3.2.1 FriendshipGraph类··· 11",
      "3.2.2 Person类··· 11",
      "3.2.3 客户端main()· 11",
      "3.2.4 测试用例··· 12",
      "3.2.5 提交至Git仓库··· 12",
      "4 实验进度记录··· 13",
      "5 实验过程中遇到的困难与解决途径··· 13",
      "6 实验过程中收获的经验、教训、感想··· 13",
      "6.1 实验过程中收获的经验和教训··· 13",
      "6.2 针对以下方面的感受··· 14",
      "实验目标概述",
      "本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现 ADT。具体来说：",
      "针对给定的应用问题，从问题描述中识别所需的 ADT；",
      "设计 ADT 规约（pre-condition、post-condition）并评估规约的质量；",
      "根据 ADT 的规约设计测试用例；",
      "ADT 的泛型化；",
      "根据规约设计 ADT 的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）",
      "使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；",
      "测试 ADT 的实现并评估测试的覆盖度；",
      "使用 ADT 及其实现，为应用问题开发程序；",
      "在测试代码中，能够写出 testing strategy 并据此设计测试用例。",
      "实验环境配置",
      "Eclipse和Git在上一次实验中已经配置好了。本次实验只需要在eclipse中配置EclEmma用来检查测试的代码覆盖度。在Help->Eclipse Marketplace中查找EclEmma，发现最初安装Eclipse就已经默认安装EclEmma了。这样，本实验所需要的所有环境就都配置好了。",
      "在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）。",
      "https://github.com/ComputerScienceHIT/HIT-Lab2-1190200817",
      "实验过程",
      "请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。",
      "Poetic Walks",
      "任务要求实现两种不同形式的图，给出了一个图接口来规定图所包含的各种方法，两种不同的实现需要继承这个接口，实现给定方法，同时需要满足泛型要求。在完成了两种实现后，任选一种实现形式完成自动扩展诗歌的任务。",
      "Get the code and prepare Git repository",
      "使用git init初始化一个本地仓库，通过git clone将GitHub上的文件下载到这个仓库中。这时就可以利用IDE进行代码编写。每当认为某一处代码修改完成，可以让它成为一个新的版本时，利用git add添加相应代码，使用git commit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过git push origin master将本地仓库push到GitHub上。",
      "Problem 1: Test",
      "Graph <String>",
      "思路：对Graph<String>接口中的所有方法进行测试，设计相应的测试策略，按等价类划分的方法进行测试。",
      "测试策略：（1）对add方法进行测试，等价类划分：加入的点已经存在于图中；加入的点不在图中。（2）对set方法进行测试，等价类划分：设置的边已经在图中，权值依次为大于零（即需要更新权值）、等于零（即删除该边）、小于零（是非法情况，不做任何操作）；设置的边不在图中，但顶点在图中，权值依次为大于零、等于零、小于零；设置的边的顶点不在图中，权值依次为大于零、等于零、小于零。（3）对remove方法进行测试，等价类划分：要删除的点在图中，但不关联边；要删除的点在图中，且关联边；要删除的点不在图中。（4）对vertices方法进行测试，等价类划分：点集为空；点集非空。（5）对sources方法进行测试，等价类划分：作为参数的顶点存在源点（返回非空）；作为参数的点不存在源点（返回为空）。（6）对targets 方法进行测试，等价类划分同（5），即是否存在目标点。在对每一个方法进行测试时，同时需要考虑其他方法的影响，因此在每个测试中都会同时测试一些其他方法。",
      "结果：在实现了两种形式的图之后，运行编写的junit测试用例，通过。",
      "Problem 2: Implement",
      "Graph <String>",
      "Implement",
      "ConcreteEdgesGraph",
      "（1）设计Edge类：Edge类应该含有一条有向边的所有信息，即起点标签、终点标签以及权值。",
      "关于Edge类的AF、RI和防止表示泄露的方式：",
      "Abstraction function：AF(source)=该边的起点、AF(target)=该边的终点、AF(weight)=该边的权值",
      "Representation invariant：source与target非空且weight为正数",
      "Safety from rep exposure：将source,target,weight设置为private,外部无法直接引用",
      "由于Edge需要是不可变类型，将起点标签、终点标签以及权值都设置为private final，并且Edge类中的方法不能修改这些属性。",
      "Edge",
      "中的方法包括：getSource()：获得起点标签；getTarget()：获得终点标签；getWeight()：获得权值（由于int和顶点类型L都是不可变类型，因此正常返回不会影响其不可变性）；Edge()：构造方法；checkRep()：检查表示不变量；同时重写了hashCode、equals和toString用于Edge类型判断相等。",
      "（2）测试Edge类：对Edge类除checkRep()外的所有方法进行测试，对于getSource()、getTarget()、getWeight()、toString()、hashCode()，都是简单的返回结果，不存在特殊情况，无需划分等价类，对每个方法进行一次测试即可。对于equals()方法，只要划分成两个Edge实例相等和不相等两种情况。",
      "（3）利用Edge实现ConcreteEdgesGraph：",
      "关于ConcreteEdgesGraph类的AF、RI和防止表示泄露的方式：",
      "Abstraction function：AF(vertices) = {vertex | vertex in vertices}、AF(edges) = {edges[i] | 0 <= i < edges.sizes()}",
      "Representation invariant：edges中每条边满足长度大于零；起点终点都在vertices中；以一个点为起点另一个点为终点最多只有一条边(边不能重复)",
      "Safety from rep exposure：将vertices和edges设置为private,外部无法直接引用、返回vertices时进行防御式拷贝",
      "各方法的实现思路如下：",
      "方法名",
      "实现思路",
      "add()",
      "判断要加入的顶点是否已经存在于vertices集合，若存在，直接返回false；不存在则向vertices中添加顶点，返回true",
      "set()",
      "参数source、target、weight，在edges中寻找是否有以source为起点、target为终点的边。若有，则记录权值并将这条边删去，当weight大于零时重新添加新边；若没有，判断weight的值，若weight大于零，则添加新边，同时可能需要向vertices添加新顶点，否则不做操作。最后，如果之前记录过权值，就将其返回，权值为负时返回-1，其他情况都返回0.",
      "remove()",
      "首先判断要删除的点是否在点集vertices中，如果不在，不做任何操作并返回false。若存在，在点集中将该点删除，同时遍历所有的边，只要某条边的起点或终点是要删除的点，就将这条边从edges中删除，最后返回true。",
      "vertices()",
      "返回vertices的一份不可修改的拷贝。",
      "sources()",
      "遍历所有的边，如果某条边的终点是输入参数，就将其放进结果映射中，最后返回结果映射。",
      "targets()",
      "遍历所有的边，如果某条边的起点是输入参数，就将其放进结果映射中，最后返回结果映射。",
      "toString()",
      "依次遍历点集vertices和边集edges，将所有信息组合成字符串，格式为”Vertices:…,Edges:…”",
      "（4）实现后，利用继承自GraphInstanceTest的ConcreteEdgesGraph进行测试，测试通过。",
      "Implement",
      "ConcreteVerticesGraph",
      "（1）设计Vertex类：Vertex类应该含有与一个顶点有关的所有信息，即一个Vertex实例相当于一个邻接表。因此属性包括顶点的标签vertex和表示邻接关系的映射adjacent（其中adjacent的键是终点，值是这条边的权值）。为了避免表示泄露，使用private final修饰这两个属性。",
      "关于Vertex类的AF、RI和防止表示泄露的方式：",
      "Abstraction function：AF(vertex) = 顶点的标签、AF(adjacent) = 以该点为起点的所有边的集合",
      "Representation invariant: vertex非空且每个边的权值大于0",
      "Safety from rep exposure：将vertex和adjacent设置为private，外部无法直接引用、返回adjacent时进行防御式拷贝",
      "Vertex中的方法包括：getVertex()：获得顶点标签；getAdjacent()：获得邻接表；set()：改变邻接表中的某个条目，与Graph中的set相对应；remove()：删除邻接表中的某个条目，与Graph中的remove相对应；Vertex()：构造方法；checkRep()：检查表示不变量；同时重写了hashCode、equals和toString用于判断相等。Vertex类型是可变的，因为set()方法和remove()方法都会改变Vertex内部的属性值。",
      "（2）测试Vertex类：对Vertex类除checkRep()外的所有方法进行测试。其中getVertex()只是简单地获得标签，无需划分等价类；getAdjacent()划分为邻接表空/非空两种情况；equals()划分为两个Vertex实例相等/不相等；toString()划分为邻接表空/非空两种情况；测试set()、remove()方法的策略和GraphInstanceTest中对set()、remove()的测试策略一致，详见3.1.2.",
      "（3）利用Vertex实现ConcreteVerticesGraph：",
      "关于ConcreteVerticesGraph类的AF、RI和防止表示泄露的方式：",
      "Abstraction function：AF(vertices) = {vertices[i] | 0 <= i < vertices.sizes()}",
      "Representation invariant：vertices中不能有重复顶点",
      "Safety from rep exposure：将vertices设置为private,外部无法直接引用",
      "各方法的实现思路如下：",
      "方法名",
      "实现思路",
      "add()",
      "判断要加入的顶点是否是vertices中某个Vertex实例的标签，若不是，直接返回false；否则以输入参数为标签新建一个Vertex并加入vertices，返回true",
      "set()",
      "参数source、target、weight，在vertices中寻找是否有以source为标签的Vertex实例。若有，继续在其邻接表中寻找是否存在一个键是target，存在则记录权值，当weight>0时更新，weight=0时删除，weight<0时不操作；否则在weight大于零时添加新边。若没有，只有在weight>0时新建一个以source为标签的Vertex并加入vertices中，同时添加一条新边。只有在之前记录权值的情况下返回权值，权值为负时直接返回-1，其他情况均返回零。",
      "remove()",
      "首先判断要删除的点是否是vertices中某个Vertex实例的标签，如果不是，不做任何操作并返回false。若是，在vertices中将该点删除。同时遍历vertices中所有的Vertex实例，删除其邻接表中关于要删除边的信息，最后返回true。",
      "vertices()",
      "遍历vertices，将每个点的标签加入返回集合即可。",
      "sources()",
      "遍历所有顶点，如果其邻接表中有终点的信息，就将其放进结果映射中，最后返回结果映射。",
      "targets()",
      "如果源点存在，返回源点的邻接表的一份不可修改拷贝；否则返回一个空映射。",
      "toString()",
      "依次遍历点集vertices和边集edges，将所有信息组合成字符串，格式为”Vertices:…,Edges:…”",
      "（4）实现后，利用继承自GraphInstanceTest的ConcreteVerticesGraph进行测试，测试通过。",
      "Problem 3: Implement generic",
      "Graph<L>",
      "Make the implementations generic",
      "由于在针对String类型实现Graph时没有用到String类的特殊性质，所有相等的比较都是用equals实现，所有转化为字符串都是用toString实现，也没有用到String可比较的性质。因此，可以直接将刚才针对String类实现的ConcreteEdgesGraph和ConcreteVerticesGraph中的所有String更换为L即可。同时，Edge类和Vertex类也需要使用泛型，将其中所有的String改为L。在GraphStaticTest测试程序中，用和3.1.2中相同的测试策略，测试了泛型为Integer的情况，测试通过。",
      "Implement",
      "Graph.empty()",
      "在Graph.empty()中，只需返回一个具体的Graph实例即可，可以在ConcreteEdgesGraph和ConcreteVerticesGraph任选其一。我选择了ConcreteVerticesGraph。",
      "综上，关于Graph的实现全部完成，所有测试都顺利通过。",
      "Problem 4: Poetic walks",
      "任务要求利用之前实现的图，将语料库文件转化为一种图结构，并且根据输入的字符串在图中搜索可以插入的单词，完成诗句的扩展。",
      "Test",
      "GraphPoet",
      "对GraphPoet中的所有方法进行测试。GraphPoet中只有两个方法，构造方法GraphPoet()和产生诗的poem()。",
      "使用按等价类划分的方法对每个方法进行测试。",
      "测试策略：（1）对构造方法，功能是读入语料库文件并产生相应的图。按照文件的形式划分等价类：文件为空；文件只有一行，且分隔符都是单个空格；文件有一行，但分隔符可能是连续空格；文件有多行但不存在空行；文件存在空行。针对以上情况设计语料库文件形式，测试是否能够正确生成相应的图结构。（2）对于poem()方法。按照输入字符串的形式和扩展形式划分等价类：输入字符串是空串；输入字符串存在连续空格；扩展后未插入单词；插入单词的过程中不存在比较行为；插入单词的过程中存在比较行为，测试是否能够正确扩展诗句。",
      "Implement",
      "GraphPoet",
      "构造函数的实现：每次从文件中读入一行，用.split(“\\\\s+”)将读入的文本分割成单词，同时将所有单词转化为小写。对于分割后String数组中的每一个字符串，从它到它之后的字符串的边的权重加一，可以通过使用两个set()完成。",
      "同时需要注意保留行尾的字符串，它到下一行第一个单词的边的权重需要加一。此外还要特别考虑空行的情况。",
      "poem()函数的实现：先将输入字符串用.split(“\\\\s+”)分隔成单词，从前向后依次遍历两个单词，对前面的单词调用targets()得到它所有指向的顶点，对后面的单词调用sources()得到所有指向它的顶点。得到的两个结果的交集就是这两个单词的所有中间顶点，找到使得两条边权值和最大的顶点就是需要插入的顶点。维护一个List按顺序保存结果字符串中的每一个单词，每得到一个要插入的顶点，就将其对应的单词加到List中，每次循环最后将后面的单词也加入List中。循环结束时，List保存的就是结果字符串中的每个单词，将它们连接起来，中间由单个空格分隔就得到扩展后的字符串。",
      "使用前面设计的测试用例测试，通过。",
      "Graph poetry slam",
      "语料库内容如下：",
      "扩展代码：",
      "扩展结果：",
      "Eclemma检查测试的代码覆盖度",
      "除GraphPoet和FriendshipGraph中的main函数没有覆盖，其他基本都覆盖到了。",
      "Before you’re done",
      "通过Git提交当前版本到GitHub上你的Lab2仓库：先使用git status确定未被添加的代码；再使用git add添加相应代码；使用git commit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过git push origin master将本地仓库push到GitHub上。",
      "在这里给出你的项目的目录结构树状示意图。（Eclipse中显示的项目目录结构）",
      "Re-implement the Social Network in Lab1",
      "利用之前实现好的Graph<L>，重新实现Lab1中的Social NetWork，并且要尽可能复用已经实现的add()和set()方法，并能和之前一样通过测试。这让我们体会到实现好一个类型对之后的工作有很大的简化。",
      "FriendshipGraph",
      "使用ConcreteVerticesGraph<Person>作为FriendshipGraph中的图结构，并且用private final修饰，避免表示泄露。",
      "addVertex()方法直接使用Graph中的add()方法实现：",
      "addEdge()方法直接使用Graph中的set()方法实现，由于此题不带权，因此权值均设置为1：",
      "getDistance()没有太大变化，和之前一样利用广度优先搜索实现。",
      "Person",
      "由于使用ConcreteVerticesGraph<Person>实现，要求Person是不可变类型，定义Person的属性只有一个，即名字字符串，同时用private final修饰。",
      "关于Vertex类的AF、RI和防止表示泄露的方式：",
      "Abstraction function：AF(name) = 这个人的名字",
      "Representation invariant：名字不能为null",
      "Safety from rep exposure：将name设置为private,外部无法引用",
      "Person类的方法包括：checkRep()检查表示不变量；getName()获得名字；Person()构造方法；重写的hashCode()、equals()、toString()使得便于判断重复；同时实现了compareTo()方法使得Person类是可比较的。可以发现，所有方法都无法更改Person内部的属性，因此Person类是不可变的。",
      "客户端",
      "main()",
      "客户端代码已经在Lab1中给出：",
      "测试用例",
      "对FriendshipGraph中的所有方法进行测试。使用按等价类划分的方法对每个方法进行测试。",
      "测试策略：（1）对于addVertex()方法，测试添加重复的人和不重复的人的情况；（2）对于addEdge()方法，测试三种情况：添加朋友关系的人不在图中；添加自己到自己的朋友关系；正常添加朋友；（3）对于getDistance()测试三种情况：没有朋友关系的两个人之间的距离；有朋友关系的两个人之间的距离；自己到自己的距离。",
      "使用按照测试策略设计的测试用例测试，通过。",
      "提交至",
      "Git仓库",
      "通过Git提交当前版本到GitHub上你的Lab2仓库：先使用git status确定未被添加的代码；再使用git add添加相应代码；使用git commit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过git push origin master将本地仓库push到GitHub上。",
      "项目的目录结构树状示意图见3.1.7",
      "实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "时间段",
      "计划任务",
      "实际完成情况",
      "2021.5.21",
      "18:30-20:30",
      "设计GraphInstanceTest中的测试用例",
      "2021.5.22",
      "19:30-22:00",
      "实现ConcreteEdgesGraph<String>并进行测试",
      "2021.5.23",
      "18:30-21:00",
      "实现ConcreteVerticesGraph<String>并进行测试",
      "2021.5.23",
      "21:00-21:30",
      "将特定类型转换为泛型",
      "发现前面实现中的问题并进行了修改，延期一小时完成",
      "2021.5.24",
      "20:00-22:30",
      "设计GraphPoet测试用例并实现GraphPoet，进行测试",
      "2021.5.25",
      "10:00-11:30",
      "利用ConcreteVerticesGraph重新实现之前的FriendshipGraph并进行测试",
      "实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "撰写AF,RI,Safety from rep exposure时不知道从何写起",
      "查看PPT中的示例以及在网上查找相关的示例理解撰写思路和方法，并逐渐掌握了撰写方法。",
      "测试用例覆盖的情况不全面",
      "仔细地设计测试用例，尽可能覆盖等价类中所有的情况。",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "在实现使用泛型的类时，一定要事先完整地想好各个功能如何实现，特别是每个方法都要满足所有可能的类型，要特别小心不要利用某些类特有的性质。比如，在实现泛型为String的特殊情况时，使用了compareTo方法，这个方法不是所有类都有的，扩展到泛型时会产生错误，需要重新设计方法的实现。",
      "针对以下方面的感受",
      "面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？",
      "面向ADT的编程需要从实际中进行抽象，并进行合理的设计，有很好的可扩展性和可复用性；而直接面向应用场景编程只针对特定应用，每次更换应用场景时都要重新编程，扩展性很差，只适合简单的应用场景。",
      "使用泛型和不使用泛型的编程，对你来说有何差异？",
      "使用泛型能够扩展应用范围，可以适用于不同的类，能够很好地应对变化，并且能提高可复用性。但使用泛型也使得功能的实现更加困难，必须考虑可能的所有类型，不能依赖任何特定类型，需要更全面细致的考虑。",
      "在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？",
      "这使得测试时不需考虑方法的实际实现，不会让测试过度依赖具体的实现方法，这也体现了测试优先编程的优势，可以更加容易地发现错误，保证测试的有效性。我也在逐渐适应这种测试优先的编程方法，也体会到这种方法确实很有效。",
      "P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？",
      "可以提高代码的可复用性，减少大量重复的工作。",
      "P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？",
      "正在逐渐适应从具体应用场景到ADT的“抽象映射”，并逐渐掌握抽象的方法。在P3自主设计时，仍然需要参考P1给出的逻辑关系，仿照P1进行设计，我也在自主设计的过程中逐渐掌握设计思路和方法，并尽可能地进行独立设计。",
      "为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "这些工作使得客户端了解各方法的功能但无法得知内部具体实现，同时可以防止内部变量被客户端恶意修改。时刻检查表示不变量，可以更好地保证代码的正确和安全。虽然这些工作有些麻烦，但却是好的软件必须具备的，因此我愿意在以后编程中坚持这么做。",
      "关于本实验的工作量、难度、deadline。",
      "工作量不大，难度不太大，但是撰写specification, invariants, RI, AF以及testing strategy会使用较长时间。deadline很合适，给了三周时间，完全可以完成。",
      "《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "逐渐理解了软件构造过程中独有的思路和方法，也逐渐适应了与之前完全不同的编程过程。建议实验内容还是翻译成中文，有些英文读起来会有歧义。"
    ],
    "sentences": [
      "2021",
      "年春季学期",
      "计算学部《软件构造》课程",
      "Lab 2",
      "实验报告",
      "1 实验目标概述··· 1",
      "2 实验环境配置··· 1",
      "3 实验过程··· 2",
      "3.1 Poetic Walks· 2",
      "3.1.1 Get the code and prepare Git repository· 2",
      "3.1.2 Problem 1: Test · 2",
      "3.1.3 Graph <String>· 3",
      "3.1.3.1 · 3",
      "3.1.3.2 Implement ConcreteVerticesGraph· 5",
      "3.1.4 · 7",
      "3.1.4.1 · 7",
      "3.1.4.2 Implement Graph.empty()· 7",
      "3.1.5 Problem 4: Poetic walks· 8",
      "3.1.5.1 Test GraphPoet· 8",
      "3.1.5.2 Implement GraphPoet· 8",
      "3.1.5.3 Graph poetry slam·· 9",
      "3.1.6 使用Eclemma检查测试的代码覆盖度··· 9",
      "3.1.7 Before you’re done· 10",
      "3.2 Re-implement the Social Network in Lab1· 10",
      "3.2.1 FriendshipGraph类··· 11",
      "3.2.2 Person类··· 11",
      "3.2.3 客户端main()· 11",
      "3.2.4 测试用例··· 12",
      "3.2.5 提交至Git仓库··· 12",
      "4 实验进度记录··· 13",
      "5 实验过程中遇到的困难与解决途径··· 13",
      "6 实验过程中收获的经验、教训、感想··· 13",
      "6.1 实验过程中收获的经验和教训··· 13",
      "6.2 针对以下方面的感受··· 14",
      "实验目标概述",
      "本次实验训练抽象数据类型（ADT）的设计、规约、测试",
      "并使用面向对象编程（OOP）技术实现 ADT",
      "具体来说：针对给定的应用问题",
      "从问题描述中识别所需的 ADT；设计 ADT 规约（pre-condition、post-condition）并评估规约的质量；根据 ADT 的规约设计测试用例；ADT 的泛型化；根据规约设计 ADT 的多种不同的实现；针对每种实现",
      "设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）",
      "使用 OOP 实现 ADT",
      "并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；测试 ADT 的实现并评估测试的覆盖度；使用 ADT 及其实现",
      "为应用问题开发程序；在测试代码中",
      "能够写出 testing strategy 并据此设计测试用例",
      "实验环境配置",
      "Eclipse和Git在上一次实验中已经配置好了",
      "本次实验只需要在eclipse中配置EclEmma用来检查测试的代码覆盖度",
      "在Help->Eclipse Marketplace中查找EclEmma",
      "发现最初安装Eclipse就已经默认安装EclEmma了",
      "这样，本实验所需要的所有环境就都配置好了",
      "在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）",
      "https://github.com/ComputerScienceHIT/HIT-Lab2-1190200817",
      "实验过程",
      "请仔细对照实验手册",
      "针对三个问题中的每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）",
      "Poetic Walks",
      "任务要求实现两种不同形式的图",
      "给出了一个图接口来规定图所包含的各种方法",
      "两种不同的实现需要继承这个接口",
      "实现给定方法",
      "同时需要满足泛型要求",
      "在完成了两种实现后，任选一种实现形式完成自动扩展诗歌的任务",
      "Get the code and prepare Git repository",
      "使用git init初始化一个本地仓库",
      "通过git clone将GitHub上的文件下载到这个仓库中",
      "这时就可以利用IDE进行代码编写",
      "每当认为某一处代码修改完成",
      "可以让它成为一个新的版本时",
      "利用git add添加相应代码",
      "使用git commit将本地文件加入到本地仓库",
      "当所有的代码都修改完毕",
      "通过git push origin master将本地仓库push到GitHub上",
      "Problem 1: Test",
      "Graph <String>",
      "思路：对Graph<String>接口中的所有方法进行测试",
      "设计相应的测试策略",
      "按等价类划分的方法进行测试",
      "测试策略：（1）对add方法进行测试",
      "等价类划分：加入的点已经存在于图中；加入的点不在图中",
      "（2）对set方法进行测试",
      "等价类划分：设置的边已经在图中",
      "权值依次为大于零（即需要更新权值）、等于零（即删除该边）、小于零（是非法情况",
      "不做任何操作）；设置的边不在图中",
      "但顶点在图中",
      "权值依次为大于零、等于零、小于零；设置的边的顶点不在图中",
      "权值依次为大于零、等于零、小于零",
      "（3）对remove方法进行测试",
      "等价类划分：要删除的点在图中",
      "但不关联边；要删除的点在图中",
      "且关联边；要删除的点不在图中",
      "（4）对vertices方法进行测试",
      "等价类划分：点集为空；点集非空",
      "（5）对sources方法进行测试",
      "等价类划分：作为参数的顶点存在源点（返回非空）；作为参数的点不存在源点（返回为空）",
      "（6）对targets 方法进行测试",
      "等价类划分同（5）",
      "即是否存在目标点",
      "在对每一个方法进行测试时",
      "同时需要考虑其他方法的影响",
      "因此在每个测试中都会同时测试一些其他方法",
      "结果：在实现了两种形式的图之后",
      "运行编写的junit测试用例",
      "通过",
      "Problem 2: Implement",
      "Graph <String>",
      "Implement",
      "ConcreteEdgesGraph",
      "（1）设计Edge类：Edge类应该含有一条有向边的所有信息",
      "即起点标签、终点标签以及权值",
      "关于Edge类的AF、RI和防止表示泄露的方式：Abstraction function：AF(source)=该边的起点、AF(target)=该边的终点、AF(weight)=该边的权值",
      "Representation invariant：source与target非空且weight为正数",
      "Safety from rep exposure：将source,target,weight设置为private,外部无法直接引用",
      "由于Edge需要是不可变类型",
      "将起点标签、终点标签以及权值都设置为private final",
      "并且Edge类中的方法不能修改这些属性",
      "Edge",
      "中的方法包括：getSource()：获得起点标签；getTarget()：获得终点标签；getWeight()：获得权值（由于int和顶点类型L都是不可变类型",
      "因此正常返回不会影响其不可变性）；Edge()：构造方法；checkRep()：检查表示不变量；同时重写了hashCode、equals和toString用于Edge类型判断相等",
      "（2）测试Edge类：对Edge类除checkRep()外的所有方法进行测试",
      "对于getSource()、getTarget()、getWeight()、toString()、hashCode()",
      "都是简单的返回结果",
      "不存在特殊情况",
      "无需划分等价类",
      "对每个方法进行一次测试即可",
      "对于equals()方法",
      "只要划分成两个Edge实例相等和不相等两种情况",
      "（3）利用Edge实现ConcreteEdgesGraph：关于ConcreteEdgesGraph类的AF、RI和防止表示泄露的方式：Abstraction function：AF(vertices) = {vertex | vertex in vertices}、AF(edges) = {edges[i] | 0 <= i < edges.sizes()}",
      "Representation invariant：edges中每条边满足长度大于零；起点终点都在vertices中；以一个点为起点另一个点为终点最多只有一条边(边不能重复)",
      "Safety from rep exposure：将vertices和edges设置为private,外部无法直接引用、返回vertices时进行防御式拷贝",
      "各方法的实现思路如下：方法名",
      "实现思路",
      "add()",
      "判断要加入的顶点是否已经存在于vertices集合",
      "若存在",
      "直接返回false；不存在则向vertices中添加顶点",
      "返回true",
      "set()",
      "参数source、target、weight",
      "在edges中寻找是否有以source为起点、target为终点的边",
      "若有",
      "则记录权值并将这条边删去",
      "当weight大于零时重新添加新边；若没有",
      "判断weight的值",
      "若weight大于零",
      "则添加新边",
      "同时可能需要向vertices添加新顶点",
      "否则不做操作",
      "最后",
      "如果之前记录过权值",
      "就将其返回",
      "权值为负时返回-1",
      "其他情况都返回0.remove()",
      "首先判断要删除的点是否在点集vertices中",
      "如果不在",
      "不做任何操作并返回false",
      "若存在",
      "在点集中将该点删除",
      "同时遍历所有的边",
      "只要某条边的起点或终点是要删除的点",
      "就将这条边从edges中删除",
      "最后返回true",
      "vertices()",
      "返回vertices的一份不可修改的拷贝",
      "sources()",
      "遍历所有的边",
      "如果某条边的终点是输入参数",
      "就将其放进结果映射中",
      "最后返回结果映射",
      "targets()",
      "遍历所有的边",
      "如果某条边的起点是输入参数",
      "就将其放进结果映射中",
      "最后返回结果映射",
      "toString()",
      "依次遍历点集vertices和边集edges",
      "将所有信息组合成字符串",
      "格式为”Vertices:…,Edges:…”",
      "（4）实现后",
      "利用继承自GraphInstanceTest的ConcreteEdgesGraph进行测试",
      "测试通过",
      "Implement",
      "ConcreteVerticesGraph",
      "（1）设计Vertex类：Vertex类应该含有与一个顶点有关的所有信息",
      "即一个Vertex实例相当于一个邻接表",
      "因此属性包括顶点的标签vertex和表示邻接关系的映射adjacent（其中adjacent的键是终点",
      "值是这条边的权值）",
      "为了避免表示泄露",
      "使用private final修饰这两个属性",
      "关于Vertex类的AF、RI和防止表示泄露的方式：Abstraction function：AF(vertex) = 顶点的标签、AF(adjacent) = 以该点为起点的所有边的集合",
      "Representation invariant: vertex非空且每个边的权值大于0",
      "Safety from rep exposure：将vertex和adjacent设置为private",
      "外部无法直接引用、返回adjacent时进行防御式拷贝",
      "Vertex中的方法包括：getVertex()：获得顶点标签；getAdjacent()：获得邻接表；set()：改变邻接表中的某个条目",
      "与Graph中的set相对应；remove()：删除邻接表中的某个条目",
      "与Graph中的remove相对应；Vertex()：构造方法；checkRep()：检查表示不变量；同时重写了hashCode、equals和toString用于判断相等",
      "Vertex类型是可变的",
      "因为set()方法和remove()方法都会改变Vertex内部的属性值",
      "（2）测试Vertex类：对Vertex类除checkRep()外的所有方法进行测试",
      "其中getVertex()只是简单地获得标签",
      "无需划分等价类；getAdjacent()划分为邻接表空/非空两种情况；equals()划分为两个Vertex实例相等/不相等；toString()划分为邻接表空/非空两种情况；测试set()、remove()方法的策略和GraphInstanceTest中对set()、remove()的测试策略一致",
      "详见3.1.2.（3）利用Vertex实现ConcreteVerticesGraph：关于ConcreteVerticesGraph类的AF、RI和防止表示泄露的方式：Abstraction function：AF(vertices) = {vertices[i] | 0 <= i < vertices.sizes()}",
      "Representation invariant：vertices中不能有重复顶点",
      "Safety from rep exposure：将vertices设置为private,外部无法直接引用",
      "各方法的实现思路如下：方法名",
      "实现思路",
      "add()",
      "判断要加入的顶点是否是vertices中某个Vertex实例的标签",
      "若不是",
      "直接返回false；否则以输入参数为标签新建一个Vertex并加入vertices",
      "返回true",
      "set()",
      "参数source、target、weight",
      "在vertices中寻找是否有以source为标签的Vertex实例",
      "若有",
      "继续在其邻接表中寻找是否存在一个键是target",
      "存在则记录权值",
      "当weight>0时更新",
      "weight=0时删除",
      "weight<0时不操作；否则在weight大于零时添加新边",
      "若没有",
      "只有在weight>0时新建一个以source为标签的Vertex并加入vertices中",
      "同时添加一条新边",
      "只有在之前记录权值的情况下返回权值",
      "权值为负时直接返回-1",
      "其他情况均返回零",
      "remove()",
      "首先判断要删除的点是否是vertices中某个Vertex实例的标签",
      "如果不是",
      "不做任何操作并返回false",
      "若是，在vertices中将该点删除",
      "同时遍历vertices中所有的Vertex实例",
      "删除其邻接表中关于要删除边的信息",
      "最后返回true",
      "vertices()",
      "遍历vertices，将每个点的标签加入返回集合即可",
      "sources()",
      "遍历所有顶点",
      "如果其邻接表中有终点的信息",
      "就将其放进结果映射中",
      "最后返回结果映射",
      "targets()",
      "如果源点存在",
      "返回源点的邻接表的一份不可修改拷贝；否则返回一个空映射",
      "toString()",
      "依次遍历点集vertices和边集edges",
      "将所有信息组合成字符串",
      "格式为”Vertices:…,Edges:…”",
      "（4）实现后",
      "利用继承自GraphInstanceTest的ConcreteVerticesGraph进行测试",
      "测试通过",
      "Problem 3: Implement generic",
      "Graph<L>",
      "Make the implementations generic",
      "由于在针对String类型实现Graph时没有用到String类的特殊性质",
      "所有相等的比较都是用equals实现",
      "所有转化为字符串都是用toString实现",
      "也没有用到String可比较的性质",
      "因此",
      "可以直接将刚才针对String类实现的ConcreteEdgesGraph和ConcreteVerticesGraph中的所有String更换为L即可",
      "同时",
      "Edge类和Vertex类也需要使用泛型",
      "将其中所有的String改为L",
      "在GraphStaticTest测试程序中",
      "用和3.1.2中相同的测试策略",
      "测试了泛型为Integer的情况",
      "测试通过",
      "Implement",
      "Graph.empty()",
      "在Graph.empty()中",
      "只需返回一个具体的Graph实例即可",
      "可以在ConcreteEdgesGraph和ConcreteVerticesGraph任选其一",
      "我选择了ConcreteVerticesGraph",
      "综上，关于Graph的实现全部完成，所有测试都顺利通过",
      "Problem 4: Poetic walks",
      "任务要求利用之前实现的图",
      "将语料库文件转化为一种图结构",
      "并且根据输入的字符串在图中搜索可以插入的单词",
      "完成诗句的扩展",
      "Test",
      "GraphPoet",
      "对GraphPoet中的所有方法进行测试",
      "GraphPoet中只有两个方法",
      "构造方法GraphPoet()和产生诗的poem()",
      "使用按等价类划分的方法对每个方法进行测试",
      "测试策略：（1）对构造方法",
      "功能是读入语料库文件并产生相应的图",
      "按照文件的形式划分等价类：文件为空；文件只有一行",
      "且分隔符都是单个空格；文件有一行",
      "但分隔符可能是连续空格；文件有多行但不存在空行；文件存在空行",
      "针对以上情况设计语料库文件形式",
      "测试是否能够正确生成相应的图结构",
      "（2）对于poem()方法",
      "按照输入字符串的形式和扩展形式划分等价类：输入字符串是空串；输入字符串存在连续空格；扩展后未插入单词；插入单词的过程中不存在比较行为；插入单词的过程中存在比较行为",
      "测试是否能够正确扩展诗句",
      "Implement",
      "GraphPoet",
      "构造函数的实现：每次从文件中读入一行",
      "用.split(“\\\\s+”)将读入的文本分割成单词",
      "同时将所有单词转化为小写",
      "对于分割后String数组中的每一个字符串",
      "从它到它之后的字符串的边的权重加一",
      "可以通过使用两个set()完成",
      "同时需要注意保留行尾的字符串",
      "它到下一行第一个单词的边的权重需要加一",
      "此外还要特别考虑空行的情况",
      "poem()函数的实现：先将输入字符串用.split(“\\\\s+”)分隔成单词",
      "从前向后依次遍历两个单词",
      "对前面的单词调用targets()得到它所有指向的顶点",
      "对后面的单词调用sources()得到所有指向它的顶点",
      "得到的两个结果的交集就是这两个单词的所有中间顶点",
      "找到使得两条边权值和最大的顶点就是需要插入的顶点",
      "维护一个List按顺序保存结果字符串中的每一个单词",
      "每得到一个要插入的顶点",
      "就将其对应的单词加到List中",
      "每次循环最后将后面的单词也加入List中",
      "循环结束时",
      "List保存的就是结果字符串中的每个单词",
      "将它们连接起来",
      "中间由单个空格分隔就得到扩展后的字符串",
      "使用前面设计的测试用例测试，通过",
      "Graph poetry slam",
      "语料库内容如下：扩展代码：扩展结果：Eclemma检查测试的代码覆盖度",
      "除GraphPoet和FriendshipGraph中的main函数没有覆盖",
      "其他基本都覆盖到了",
      "Before you’re done",
      "通过Git提交当前版本到GitHub上你的Lab2仓库：先使用git status确定未被添加的代码；再使用git add添加相应代码；使用git commit将本地文件加入到本地仓库",
      "当所有的代码都修改完毕",
      "通过git push origin master将本地仓库push到GitHub上",
      "在这里给出你的项目的目录结构树状示意图",
      "（Eclipse中显示的项目目录结构）",
      "Re-implement the Social Network in Lab1",
      "利用之前实现好的Graph<L>",
      "重新实现Lab1中的Social NetWork",
      "并且要尽可能复用已经实现的add()和set()方法",
      "并能和之前一样通过测试",
      "这让我们体会到实现好一个类型对之后的工作有很大的简化",
      "FriendshipGraph",
      "使用ConcreteVerticesGraph<Person>作为FriendshipGraph中的图结构",
      "并且用private final修饰",
      "避免表示泄露",
      "addVertex()方法直接使用Graph中的add()方法实现：addEdge()方法直接使用Graph中的set()方法实现",
      "由于此题不带权",
      "因此权值均设置为1：getDistance()没有太大变化",
      "和之前一样利用广度优先搜索实现",
      "Person",
      "由于使用ConcreteVerticesGraph<Person>实现",
      "要求Person是不可变类型",
      "定义Person的属性只有一个",
      "即名字字符串",
      "同时用private final修饰",
      "关于Vertex类的AF、RI和防止表示泄露的方式：Abstraction function：AF(name) = 这个人的名字",
      "Representation invariant：名字不能为null",
      "Safety from rep exposure：将name设置为private,外部无法引用",
      "Person类的方法包括：checkRep()检查表示不变量；getName()获得名字；Person()构造方法；重写的hashCode()、equals()、toString()使得便于判断重复；同时实现了compareTo()方法使得Person类是可比较的",
      "可以发现",
      "所有方法都无法更改Person内部的属性",
      "因此Person类是不可变的",
      "客户端",
      "main()",
      "客户端代码已经在Lab1中给出：测试用例",
      "对FriendshipGraph中的所有方法进行测试",
      "使用按等价类划分的方法对每个方法进行测试",
      "测试策略：（1）对于addVertex()方法",
      "测试添加重复的人和不重复的人的情况；（2）对于addEdge()方法",
      "测试三种情况：添加朋友关系的人不在图中；添加自己到自己的朋友关系；正常添加朋友；（3）对于getDistance()测试三种情况：没有朋友关系的两个人之间的距离；有朋友关系的两个人之间的距离；自己到自己的距离",
      "使用按照测试策略设计的测试用例测试，通过",
      "提交至",
      "Git仓库",
      "通过Git提交当前版本到GitHub上你的Lab2仓库：先使用git status确定未被添加的代码；再使用git add添加相应代码；使用git commit将本地文件加入到本地仓库",
      "当所有的代码都修改完毕",
      "通过git push origin master将本地仓库push到GitHub上",
      "项目的目录结构树状示意图见3.1.7",
      "实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "时间段",
      "计划任务",
      "实际完成情况",
      "2021.5.21",
      "18:30-20:30",
      "设计GraphInstanceTest中的测试用例",
      "2021.5.22",
      "19:30-22:00",
      "实现ConcreteEdgesGraph<String>并进行测试",
      "2021.5.23",
      "18:30-21:00",
      "实现ConcreteVerticesGraph<String>并进行测试",
      "2021.5.23",
      "21:00-21:30",
      "将特定类型转换为泛型",
      "发现前面实现中的问题并进行了修改，延期一小时完成",
      "2021.5.24",
      "20:00-22:30",
      "设计GraphPoet测试用例并实现GraphPoet",
      "进行测试",
      "2021.5.25",
      "10:00-11:30",
      "利用ConcreteVerticesGraph重新实现之前的FriendshipGraph并进行测试",
      "实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "撰写AF,RI,Safety from rep exposure时不知道从何写起",
      "查看PPT中的示例以及在网上查找相关的示例理解撰写思路和方法",
      "并逐渐掌握了撰写方法",
      "测试用例覆盖的情况不全面",
      "仔细地设计测试用例，尽可能覆盖等价类中所有的情况",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "在实现使用泛型的类时",
      "一定要事先完整地想好各个功能如何实现",
      "特别是每个方法都要满足所有可能的类型",
      "要特别小心不要利用某些类特有的性质",
      "比如",
      "在实现泛型为String的特殊情况时",
      "使用了compareTo方法",
      "这个方法不是所有类都有的",
      "扩展到泛型时会产生错误",
      "需要重新设计方法的实现",
      "针对以下方面的感受",
      "面向ADT的编程和直接面向应用场景编程",
      "你体会到二者有何差异？",
      "面向ADT的编程需要从实际中进行抽象",
      "并进行合理的设计",
      "有很好的可扩展性和可复用性；而直接面向应用场景编程只针对特定应用",
      "每次更换应用场景时都要重新编程",
      "扩展性很差",
      "只适合简单的应用场景",
      "使用泛型和不使用泛型的编程，对你来说有何差异？",
      "使用泛型能够扩展应用范围",
      "可以适用于不同的类",
      "能够很好地应对变化",
      "并且能提高可复用性",
      "但使用泛型也使得功能的实现更加困难",
      "必须考虑可能的所有类型",
      "不能依赖任何特定类型",
      "需要更全面细致的考虑",
      "在给出ADT的规约后就开始编写测试用例",
      "优势是什么？你是否能够适应这种测试方式？",
      "这使得测试时不需考虑方法的实际实现",
      "不会让测试过度依赖具体的实现方法",
      "这也体现了测试优先编程的优势",
      "可以更加容易地发现错误",
      "保证测试的有效性",
      "我也在逐渐适应这种测试优先的编程方法",
      "也体会到这种方法确实很有效",
      "P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？",
      "可以提高代码的可复用性，减少大量重复的工作",
      "P3要求你从0开始设计ADT并使用它们完成一个具体应用",
      "你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系",
      "P3要求你自主设计这些内容",
      "你的感受如何？",
      "正在逐渐适应从具体应用场景到ADT的“抽象映射”",
      "并逐渐掌握抽象的方法",
      "在P3自主设计时",
      "仍然需要参考P1给出的逻辑关系",
      "仿照P1进行设计",
      "我也在自主设计的过程中逐渐掌握设计思路和方法",
      "并尽可能地进行独立设计",
      "为ADT撰写specification, invariants, RI, AF",
      "时刻注意ADT是否有rep exposure",
      "这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "这些工作使得客户端了解各方法的功能但无法得知内部具体实现",
      "同时可以防止内部变量被客户端恶意修改",
      "时刻检查表示不变量，可以更好地保证代码的正确和安全",
      "虽然这些工作有些麻烦",
      "但却是好的软件必须具备的",
      "因此我愿意在以后编程中坚持这么做",
      "关于本实验的工作量、难度、deadline",
      "工作量不大",
      "难度不太大",
      "但是撰写specification, invariants, RI, AF以及testing strategy会使用较长时间",
      "deadline很合适，给了三周时间，完全可以完成",
      "《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "逐渐理解了软件构造过程中独有的思路和方法",
      "也逐渐适应了与之前完全不同的编程过程",
      "建议实验内容还是翻译成中文，有些英文读起来会有歧义"
    ],
    "codes": [
      "Problem 2: Implement",
      "Graph <String>",
      "Implement",
      "ConcreteEdgesGraph",
      "Problem 3: Implement generic",
      "Graph<L>",
      "Make the implementations generic"
    ],
    "date": "2021-06-13",
    "text": "2021\n年春季学期\n计算学部《软件构造》课程\nLab 2\n实验报告\n1 实验目标概述··· 1\n2 实验环境配置··· 1\n3 实验过程··· 2\n3.1 Poetic Walks· 2\n3.1.1 Get the code and prepare Git repository· 2\n3.1.2 Problem 1: Test · 2\n3.1.3 Graph <String>· 3\n3.1.3.1 · 3\n3.1.3.2 Implement ConcreteVerticesGraph· 5\n3.1.4 · 7\n3.1.4.1 · 7\n3.1.4.2 Implement Graph.empty()· 7\n3.1.5 Problem 4: Poetic walks· 8\n3.1.5.1 Test GraphPoet· 8\n3.1.5.2 Implement GraphPoet· 8\n3.1.5.3 Graph poetry slam·· 9\n3.1.6 使用Eclemma检查测试的代码覆盖度··· 9\n3.1.7 Before you’re done· 10\n3.2 Re-implement the Social Network in Lab1· 10\n3.2.1 FriendshipGraph类··· 11\n3.2.2 Person类··· 11\n3.2.3 客户端main()· 11\n3.2.4 测试用例··· 12\n3.2.5 提交至Git仓库··· 12\n4 实验进度记录··· 13\n5 实验过程中遇到的困难与解决途径··· 13\n6 实验过程中收获的经验、教训、感想··· 13\n6.1 实验过程中收获的经验和教训··· 13\n6.2 针对以下方面的感受··· 14\n实验目标概述\n本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现 ADT。具体来说：\n针对给定的应用问题，从问题描述中识别所需的 ADT；\n设计 ADT 规约（pre-condition、post-condition）并评估规约的质量；\n根据 ADT 的规约设计测试用例；\nADT 的泛型化；\n根据规约设计 ADT 的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）\n使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；\n测试 ADT 的实现并评估测试的覆盖度；\n使用 ADT 及其实现，为应用问题开发程序；\n在测试代码中，能够写出 testing strategy 并据此设计测试用例。\n实验环境配置\nEclipse和Git在上一次实验中已经配置好了。本次实验只需要在eclipse中配置EclEmma用来检查测试的代码覆盖度。在Help->Eclipse Marketplace中查找EclEmma，发现最初安装Eclipse就已经默认安装EclEmma了。这样，本实验所需要的所有环境就都配置好了。\n在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）。\nhttps://github.com/ComputerScienceHIT/HIT-Lab2-1190200817\n实验过程\n请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\nPoetic Walks\n任务要求实现两种不同形式的图，给出了一个图接口来规定图所包含的各种方法，两种不同的实现需要继承这个接口，实现给定方法，同时需要满足泛型要求。在完成了两种实现后，任选一种实现形式完成自动扩展诗歌的任务。\nGet the code and prepare Git repository\n使用git init初始化一个本地仓库，通过git clone将GitHub上的文件下载到这个仓库中。这时就可以利用IDE进行代码编写。每当认为某一处代码修改完成，可以让它成为一个新的版本时，利用git add添加相应代码，使用git commit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过git push origin master将本地仓库push到GitHub上。\nProblem 1: Test\nGraph <String>\n思路：对Graph<String>接口中的所有方法进行测试，设计相应的测试策略，按等价类划分的方法进行测试。\n测试策略：（1）对add方法进行测试，等价类划分：加入的点已经存在于图中；加入的点不在图中。（2）对set方法进行测试，等价类划分：设置的边已经在图中，权值依次为大于零（即需要更新权值）、等于零（即删除该边）、小于零（是非法情况，不做任何操作）；设置的边不在图中，但顶点在图中，权值依次为大于零、等于零、小于零；设置的边的顶点不在图中，权值依次为大于零、等于零、小于零。（3）对remove方法进行测试，等价类划分：要删除的点在图中，但不关联边；要删除的点在图中，且关联边；要删除的点不在图中。（4）对vertices方法进行测试，等价类划分：点集为空；点集非空。（5）对sources方法进行测试，等价类划分：作为参数的顶点存在源点（返回非空）；作为参数的点不存在源点（返回为空）。（6）对targets 方法进行测试，等价类划分同（5），即是否存在目标点。在对每一个方法进行测试时，同时需要考虑其他方法的影响，因此在每个测试中都会同时测试一些其他方法。\n结果：在实现了两种形式的图之后，运行编写的junit测试用例，通过。\nProblem 2: Implement\nGraph <String>\nImplement\nConcreteEdgesGraph\n（1）设计Edge类：Edge类应该含有一条有向边的所有信息，即起点标签、终点标签以及权值。\n关于Edge类的AF、RI和防止表示泄露的方式：\nAbstraction function：AF(source)=该边的起点、AF(target)=该边的终点、AF(weight)=该边的权值\nRepresentation invariant：source与target非空且weight为正数\nSafety from rep exposure：将source,target,weight设置为private,外部无法直接引用\n由于Edge需要是不可变类型，将起点标签、终点标签以及权值都设置为private final，并且Edge类中的方法不能修改这些属性。\nEdge\n中的方法包括：getSource()：获得起点标签；getTarget()：获得终点标签；getWeight()：获得权值（由于int和顶点类型L都是不可变类型，因此正常返回不会影响其不可变性）；Edge()：构造方法；checkRep()：检查表示不变量；同时重写了hashCode、equals和toString用于Edge类型判断相等。\n（2）测试Edge类：对Edge类除checkRep()外的所有方法进行测试，对于getSource()、getTarget()、getWeight()、toString()、hashCode()，都是简单的返回结果，不存在特殊情况，无需划分等价类，对每个方法进行一次测试即可。对于equals()方法，只要划分成两个Edge实例相等和不相等两种情况。\n（3）利用Edge实现ConcreteEdgesGraph：\n关于ConcreteEdgesGraph类的AF、RI和防止表示泄露的方式：\nAbstraction function：AF(vertices) = {vertex | vertex in vertices}、AF(edges) = {edges[i] | 0 <= i < edges.sizes()}\nRepresentation invariant：edges中每条边满足长度大于零；起点终点都在vertices中；以一个点为起点另一个点为终点最多只有一条边(边不能重复)\nSafety from rep exposure：将vertices和edges设置为private,外部无法直接引用、返回vertices时进行防御式拷贝\n各方法的实现思路如下：\n方法名\n实现思路\nadd()\n判断要加入的顶点是否已经存在于vertices集合，若存在，直接返回false；不存在则向vertices中添加顶点，返回true\nset()\n参数source、target、weight，在edges中寻找是否有以source为起点、target为终点的边。若有，则记录权值并将这条边删去，当weight大于零时重新添加新边；若没有，判断weight的值，若weight大于零，则添加新边，同时可能需要向vertices添加新顶点，否则不做操作。最后，如果之前记录过权值，就将其返回，权值为负时返回-1，其他情况都返回0.\nremove()\n首先判断要删除的点是否在点集vertices中，如果不在，不做任何操作并返回false。若存在，在点集中将该点删除，同时遍历所有的边，只要某条边的起点或终点是要删除的点，就将这条边从edges中删除，最后返回true。\nvertices()\n返回vertices的一份不可修改的拷贝。\nsources()\n遍历所有的边，如果某条边的终点是输入参数，就将其放进结果映射中，最后返回结果映射。\ntargets()\n遍历所有的边，如果某条边的起点是输入参数，就将其放进结果映射中，最后返回结果映射。\ntoString()\n依次遍历点集vertices和边集edges，将所有信息组合成字符串，格式为”Vertices:…,Edges:…”\n（4）实现后，利用继承自GraphInstanceTest的ConcreteEdgesGraph进行测试，测试通过。\nImplement\nConcreteVerticesGraph\n（1）设计Vertex类：Vertex类应该含有与一个顶点有关的所有信息，即一个Vertex实例相当于一个邻接表。因此属性包括顶点的标签vertex和表示邻接关系的映射adjacent（其中adjacent的键是终点，值是这条边的权值）。为了避免表示泄露，使用private final修饰这两个属性。\n关于Vertex类的AF、RI和防止表示泄露的方式：\nAbstraction function：AF(vertex) = 顶点的标签、AF(adjacent) = 以该点为起点的所有边的集合\nRepresentation invariant: vertex非空且每个边的权值大于0\nSafety from rep exposure：将vertex和adjacent设置为private，外部无法直接引用、返回adjacent时进行防御式拷贝\nVertex中的方法包括：getVertex()：获得顶点标签；getAdjacent()：获得邻接表；set()：改变邻接表中的某个条目，与Graph中的set相对应；remove()：删除邻接表中的某个条目，与Graph中的remove相对应；Vertex()：构造方法；checkRep()：检查表示不变量；同时重写了hashCode、equals和toString用于判断相等。Vertex类型是可变的，因为set()方法和remove()方法都会改变Vertex内部的属性值。\n（2）测试Vertex类：对Vertex类除checkRep()外的所有方法进行测试。其中getVertex()只是简单地获得标签，无需划分等价类；getAdjacent()划分为邻接表空/非空两种情况；equals()划分为两个Vertex实例相等/不相等；toString()划分为邻接表空/非空两种情况；测试set()、remove()方法的策略和GraphInstanceTest中对set()、remove()的测试策略一致，详见3.1.2.\n（3）利用Vertex实现ConcreteVerticesGraph：\n关于ConcreteVerticesGraph类的AF、RI和防止表示泄露的方式：\nAbstraction function：AF(vertices) = {vertices[i] | 0 <= i < vertices.sizes()}\nRepresentation invariant：vertices中不能有重复顶点\nSafety from rep exposure：将vertices设置为private,外部无法直接引用\n各方法的实现思路如下：\n方法名\n实现思路\nadd()\n判断要加入的顶点是否是vertices中某个Vertex实例的标签，若不是，直接返回false；否则以输入参数为标签新建一个Vertex并加入vertices，返回true\nset()\n参数source、target、weight，在vertices中寻找是否有以source为标签的Vertex实例。若有，继续在其邻接表中寻找是否存在一个键是target，存在则记录权值，当weight>0时更新，weight=0时删除，weight<0时不操作；否则在weight大于零时添加新边。若没有，只有在weight>0时新建一个以source为标签的Vertex并加入vertices中，同时添加一条新边。只有在之前记录权值的情况下返回权值，权值为负时直接返回-1，其他情况均返回零。\nremove()\n首先判断要删除的点是否是vertices中某个Vertex实例的标签，如果不是，不做任何操作并返回false。若是，在vertices中将该点删除。同时遍历vertices中所有的Vertex实例，删除其邻接表中关于要删除边的信息，最后返回true。\nvertices()\n遍历vertices，将每个点的标签加入返回集合即可。\nsources()\n遍历所有顶点，如果其邻接表中有终点的信息，就将其放进结果映射中，最后返回结果映射。\ntargets()\n如果源点存在，返回源点的邻接表的一份不可修改拷贝；否则返回一个空映射。\ntoString()\n依次遍历点集vertices和边集edges，将所有信息组合成字符串，格式为”Vertices:…,Edges:…”\n（4）实现后，利用继承自GraphInstanceTest的ConcreteVerticesGraph进行测试，测试通过。\nProblem 3: Implement generic\nGraph<L>\nMake the implementations generic\n由于在针对String类型实现Graph时没有用到String类的特殊性质，所有相等的比较都是用equals实现，所有转化为字符串都是用toString实现，也没有用到String可比较的性质。因此，可以直接将刚才针对String类实现的ConcreteEdgesGraph和ConcreteVerticesGraph中的所有String更换为L即可。同时，Edge类和Vertex类也需要使用泛型，将其中所有的String改为L。在GraphStaticTest测试程序中，用和3.1.2中相同的测试策略，测试了泛型为Integer的情况，测试通过。\nImplement\nGraph.empty()\n在Graph.empty()中，只需返回一个具体的Graph实例即可，可以在ConcreteEdgesGraph和ConcreteVerticesGraph任选其一。我选择了ConcreteVerticesGraph。\n综上，关于Graph的实现全部完成，所有测试都顺利通过。\nProblem 4: Poetic walks\n任务要求利用之前实现的图，将语料库文件转化为一种图结构，并且根据输入的字符串在图中搜索可以插入的单词，完成诗句的扩展。\nTest\nGraphPoet\n对GraphPoet中的所有方法进行测试。GraphPoet中只有两个方法，构造方法GraphPoet()和产生诗的poem()。\n使用按等价类划分的方法对每个方法进行测试。\n测试策略：（1）对构造方法，功能是读入语料库文件并产生相应的图。按照文件的形式划分等价类：文件为空；文件只有一行，且分隔符都是单个空格；文件有一行，但分隔符可能是连续空格；文件有多行但不存在空行；文件存在空行。针对以上情况设计语料库文件形式，测试是否能够正确生成相应的图结构。（2）对于poem()方法。按照输入字符串的形式和扩展形式划分等价类：输入字符串是空串；输入字符串存在连续空格；扩展后未插入单词；插入单词的过程中不存在比较行为；插入单词的过程中存在比较行为，测试是否能够正确扩展诗句。\nImplement\nGraphPoet\n构造函数的实现：每次从文件中读入一行，用.split(“\\\\s+”)将读入的文本分割成单词，同时将所有单词转化为小写。对于分割后String数组中的每一个字符串，从它到它之后的字符串的边的权重加一，可以通过使用两个set()完成。\n同时需要注意保留行尾的字符串，它到下一行第一个单词的边的权重需要加一。此外还要特别考虑空行的情况。\npoem()函数的实现：先将输入字符串用.split(“\\\\s+”)分隔成单词，从前向后依次遍历两个单词，对前面的单词调用targets()得到它所有指向的顶点，对后面的单词调用sources()得到所有指向它的顶点。得到的两个结果的交集就是这两个单词的所有中间顶点，找到使得两条边权值和最大的顶点就是需要插入的顶点。维护一个List按顺序保存结果字符串中的每一个单词，每得到一个要插入的顶点，就将其对应的单词加到List中，每次循环最后将后面的单词也加入List中。循环结束时，List保存的就是结果字符串中的每个单词，将它们连接起来，中间由单个空格分隔就得到扩展后的字符串。\n使用前面设计的测试用例测试，通过。\nGraph poetry slam\n语料库内容如下：\n扩展代码：\n扩展结果：\nEclemma检查测试的代码覆盖度\n除GraphPoet和FriendshipGraph中的main函数没有覆盖，其他基本都覆盖到了。\nBefore you’re done\n通过Git提交当前版本到GitHub上你的Lab2仓库：先使用git status确定未被添加的代码；再使用git add添加相应代码；使用git commit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过git push origin master将本地仓库push到GitHub上。\n在这里给出你的项目的目录结构树状示意图。（Eclipse中显示的项目目录结构）\nRe-implement the Social Network in Lab1\n利用之前实现好的Graph<L>，重新实现Lab1中的Social NetWork，并且要尽可能复用已经实现的add()和set()方法，并能和之前一样通过测试。这让我们体会到实现好一个类型对之后的工作有很大的简化。\nFriendshipGraph\n使用ConcreteVerticesGraph<Person>作为FriendshipGraph中的图结构，并且用private final修饰，避免表示泄露。\naddVertex()方法直接使用Graph中的add()方法实现：\naddEdge()方法直接使用Graph中的set()方法实现，由于此题不带权，因此权值均设置为1：\ngetDistance()没有太大变化，和之前一样利用广度优先搜索实现。\nPerson\n由于使用ConcreteVerticesGraph<Person>实现，要求Person是不可变类型，定义Person的属性只有一个，即名字字符串，同时用private final修饰。\n关于Vertex类的AF、RI和防止表示泄露的方式：\nAbstraction function：AF(name) = 这个人的名字\nRepresentation invariant：名字不能为null\nSafety from rep exposure：将name设置为private,外部无法引用\nPerson类的方法包括：checkRep()检查表示不变量；getName()获得名字；Person()构造方法；重写的hashCode()、equals()、toString()使得便于判断重复；同时实现了compareTo()方法使得Person类是可比较的。可以发现，所有方法都无法更改Person内部的属性，因此Person类是不可变的。\n客户端\nmain()\n客户端代码已经在Lab1中给出：\n测试用例\n对FriendshipGraph中的所有方法进行测试。使用按等价类划分的方法对每个方法进行测试。\n测试策略：（1）对于addVertex()方法，测试添加重复的人和不重复的人的情况；（2）对于addEdge()方法，测试三种情况：添加朋友关系的人不在图中；添加自己到自己的朋友关系；正常添加朋友；（3）对于getDistance()测试三种情况：没有朋友关系的两个人之间的距离；有朋友关系的两个人之间的距离；自己到自己的距离。\n使用按照测试策略设计的测试用例测试，通过。\n提交至\nGit仓库\n通过Git提交当前版本到GitHub上你的Lab2仓库：先使用git status确定未被添加的代码；再使用git add添加相应代码；使用git commit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过git push origin master将本地仓库push到GitHub上。\n项目的目录结构树状示意图见3.1.7\n实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n时间段\n计划任务\n实际完成情况\n2021.5.21\n18:30-20:30\n设计GraphInstanceTest中的测试用例\n2021.5.22\n19:30-22:00\n实现ConcreteEdgesGraph<String>并进行测试\n2021.5.23\n18:30-21:00\n实现ConcreteVerticesGraph<String>并进行测试\n2021.5.23\n21:00-21:30\n将特定类型转换为泛型\n发现前面实现中的问题并进行了修改，延期一小时完成\n2021.5.24\n20:00-22:30\n设计GraphPoet测试用例并实现GraphPoet，进行测试\n2021.5.25\n10:00-11:30\n利用ConcreteVerticesGraph重新实现之前的FriendshipGraph并进行测试\n实验过程中遇到的困难与解决途径\n遇到的难点\n解决途径\n撰写AF,RI,Safety from rep exposure时不知道从何写起\n查看PPT中的示例以及在网上查找相关的示例理解撰写思路和方法，并逐渐掌握了撰写方法。\n测试用例覆盖的情况不全面\n仔细地设计测试用例，尽可能覆盖等价类中所有的情况。\n实验过程中收获的经验、教训、感想\n实验过程中收获的经验和教训\n在实现使用泛型的类时，一定要事先完整地想好各个功能如何实现，特别是每个方法都要满足所有可能的类型，要特别小心不要利用某些类特有的性质。比如，在实现泛型为String的特殊情况时，使用了compareTo方法，这个方法不是所有类都有的，扩展到泛型时会产生错误，需要重新设计方法的实现。\n针对以下方面的感受\n面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？\n面向ADT的编程需要从实际中进行抽象，并进行合理的设计，有很好的可扩展性和可复用性；而直接面向应用场景编程只针对特定应用，每次更换应用场景时都要重新编程，扩展性很差，只适合简单的应用场景。\n使用泛型和不使用泛型的编程，对你来说有何差异？\n使用泛型能够扩展应用范围，可以适用于不同的类，能够很好地应对变化，并且能提高可复用性。但使用泛型也使得功能的实现更加困难，必须考虑可能的所有类型，不能依赖任何特定类型，需要更全面细致的考虑。\n在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？\n这使得测试时不需考虑方法的实际实现，不会让测试过度依赖具体的实现方法，这也体现了测试优先编程的优势，可以更加容易地发现错误，保证测试的有效性。我也在逐渐适应这种测试优先的编程方法，也体会到这种方法确实很有效。\nP1设计的ADT在多个应用场景下使用，这种复用带来什么好处？\n可以提高代码的可复用性，减少大量重复的工作。\nP3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？\n正在逐渐适应从具体应用场景到ADT的“抽象映射”，并逐渐掌握抽象的方法。在P3自主设计时，仍然需要参考P1给出的逻辑关系，仿照P1进行设计，我也在自主设计的过程中逐渐掌握设计思路和方法，并尽可能地进行独立设计。\n为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？\n这些工作使得客户端了解各方法的功能但无法得知内部具体实现，同时可以防止内部变量被客户端恶意修改。时刻检查表示不变量，可以更好地保证代码的正确和安全。虽然这些工作有些麻烦，但却是好的软件必须具备的，因此我愿意在以后编程中坚持这么做。\n关于本实验的工作量、难度、deadline。\n工作量不大，难度不太大，但是撰写specification, invariants, RI, AF以及testing strategy会使用较长时间。deadline很合适，给了三周时间，完全可以完成。\n《软件构造》课程进展到目前，你对该课程有何体会和建议？\n逐渐理解了软件构造过程中独有的思路和方法，也逐渐适应了与之前完全不同的编程过程。建议实验内容还是翻译成中文，有些英文读起来会有歧义。\n"
  },
  {
    "head": "Java继承问题以及子类转换为父类时调用方法及属性的情况",
    "paragraphs": [
      "1.方法的继承",
      "子类可以继承父类的非private方法。",
      "输出结果为Parent.",
      "子类可以重写父类的非private方法。",
      "这时，输出结果为Child",
      "对于父类的private方法，子类是不可见的，尝试调用父类的private方法会导致静态检查直接报错。",
      "当然，子类中也可以添加自己独特的新方法。如果子类中写了一个和父类某个private方法一样的方法，这不能算重写，应该也算添加新方法。",
      "2.属性的继承",
      "属性的继承和方法的继承类似，子类可以继承父类的非private属性。父子类定义如下：",
      "子类child可以访问np属性，在main中进行测试，输出结果为0.",
      "当然，类似于方法的重写，子类也可以覆盖掉父类的属性。",
      "测试代码和上面一样，输出结果为1.",
      "当子类试图访问父类的private属性时，静态检查会直接报错。",
      "子类中也可以添加自己独特的新属性。",
      "3.方法与属性混合的情况",
      "如果方法是从父类继承的，那么方法中使用到的属性都是父类的属性。",
      "在main中测试，输出结果是0.即使子类中已经覆盖了属性np，但是方法的行为仍然和父类一致，这时就不能简单地看代码的逻辑了。如果子类想按照代码的逻辑实现功能的话就只能重写，而重写的代码和之前一模一样。",
      "这时测试输出结果为1.",
      "然而对于方法内部再次调用方法的情况，却正好相反。如果从父类继承来的方法A调用了方法B，并且子类重写了方法B，当子类调用方法A时，方法A内部会调用被重写的方法B.",
      "子类调用A()时会输出Override。",
      "4.子类转换为父类时，调用方法及属性的情况",
      "显然的是，当子类转换为父类后，只能调用父类中存在的方法、访问父类中存在的属性。",
      "当访问属性时，属性的值是父类中的值。",
      "输出结果为0.",
      "而调用的方法应该是子类中的方法。",
      "如果方法被重写，调用的方法就是子类中被重写的方法。",
      "输出结果为Override。",
      "如果方法没有被重写，调用的方法就是父类中的方法。",
      "输出结果为Origin。",
      "如果调用的方法中访问了某个属性或者又调用了其他方法时，会遵循3中给出的分析。",
      "简单总结一下",
      "对于属性的访问，在运行前就会确定，因此只看当前的类型，当前的类型是什么就访问这个类型中定义的属性；而对方法的调用在运行时才会确定，要看原本的类型（即new的时候的类型），按照这个类型调用相应方法。而方法内部如果访问了属性，这个属性是定义该方法的那个类型中的属性；方法内部如果调用了其他方法，被调用的方法仍然是这个类型中的方法，当然，也存在嵌套的情况。"
    ],
    "sentences": [
      "1.方法的继承",
      "子类可以继承父类的非private方法",
      "输出结果为Parent.子类可以重写父类的非private方法",
      "这时，输出结果为Child",
      "对于父类的private方法",
      "子类是不可见的",
      "尝试调用父类的private方法会导致静态检查直接报错",
      "当然，子类中也可以添加自己独特的新方法",
      "如果子类中写了一个和父类某个private方法一样的方法",
      "这不能算重写",
      "应该也算添加新方法",
      "2.属性的继承",
      "属性的继承和方法的继承类似",
      "子类可以继承父类的非private属性",
      "父子类定义如下：子类child可以访问np属性",
      "在main中进行测试",
      "输出结果为0.当然",
      "类似于方法的重写",
      "子类也可以覆盖掉父类的属性",
      "测试代码和上面一样",
      "输出结果为1.当子类试图访问父类的private属性时",
      "静态检查会直接报错",
      "子类中也可以添加自己独特的新属性",
      "3.方法与属性混合的情况",
      "如果方法是从父类继承的，那么方法中使用到的属性都是父类的属性",
      "在main中测试",
      "输出结果是0.即使子类中已经覆盖了属性np",
      "但是方法的行为仍然和父类一致",
      "这时就不能简单地看代码的逻辑了",
      "如果子类想按照代码的逻辑实现功能的话就只能重写",
      "而重写的代码和之前一模一样",
      "这时测试输出结果为1.然而对于方法内部再次调用方法的情况",
      "却正好相反",
      "如果从父类继承来的方法A调用了方法B",
      "并且子类重写了方法B",
      "当子类调用方法A时",
      "方法A内部会调用被重写的方法B.子类调用A()时会输出Override",
      "4.子类转换为父类时，调用方法及属性的情况",
      "显然的是",
      "当子类转换为父类后",
      "只能调用父类中存在的方法、访问父类中存在的属性",
      "当访问属性时，属性的值是父类中的值",
      "输出结果为0.而调用的方法应该是子类中的方法",
      "如果方法被重写，调用的方法就是子类中被重写的方法",
      "输出结果为Override",
      "如果方法没有被重写，调用的方法就是父类中的方法",
      "输出结果为Origin",
      "如果调用的方法中访问了某个属性或者又调用了其他方法时",
      "会遵循3中给出的分析",
      "简单总结一下",
      "对于属性的访问",
      "在运行前就会确定",
      "因此只看当前的类型",
      "当前的类型是什么就访问这个类型中定义的属性；而对方法的调用在运行时才会确定",
      "要看原本的类型（即new的时候的类型）",
      "按照这个类型调用相应方法",
      "而方法内部如果访问了属性",
      "这个属性是定义该方法的那个类型中的属性；方法内部如果调用了其他方法",
      "被调用的方法仍然是这个类型中的方法",
      "当然",
      "也存在嵌套的情况"
    ],
    "codes": [
      "class parent{\n\tpublic void pnp() {\n\t\tSystem.out.println(\"Parent\");\n\t}\n}\nclass child extends parent{\n\n}",
      "child c = new child();\nc.pnp();",
      "class parent{\n\tpublic void pnp() {\n\t\tSystem.out.println(\"Parent\");\n\t}\n}\nclass child extends parent{\n\t@Override\n\tpublic void pnp() {\n\t\tSystem.out.println(\"Child\");\n\t}\n}",
      "class parent{\n\tint np = 0;\n}\nclass child extends parent{\n\t\n}",
      "child ch = new child();\nSystem.out.println(ch.np);",
      "class parent{\n\tint np = 0;\n}\nclass child extends parent{\n\tint np = 1;\n}",
      "class parent{\n\tint np = 0;\n\tpublic void pnp() {\n\t\tSystem.out.println(np);\n\t}\n}\nclass child extends parent{\n\tint np = 1;\n}",
      "child ch = new child();\nch.pnp();",
      "class parent{\n\tint np = 0;\n\tpublic void pnp() {\n\t\tSystem.out.println(np);\n\t}\n}\nclass child extends parent{\n\tint np = 1;\n\t@Override\n\tpublic void pnp() {\n\t\tSystem.out.println(np);\n\t}\n}",
      "class parent{\n\tpublic void A() {\n\t\tB();\n\t}\n\tpublic void B() {\n\t\tSystem.out.println(\"Origin\");\n\t}\n}\nclass child extends parent{\n\tpublic void B() {\n\t\tSystem.out.println(\"Override\");\n\t}\n}",
      "class parent{\n\tint np = 0;\n}\nclass child extends parent{\n\tint np = 1;\n}",
      "parent c = new child();\nSystem.out.println(c.np);",
      "class parent{\n\tpublic void A() {\n\t\tSystem.out.println(\"Origin\");\n\t}\n}\nclass child extends parent{\n\t@Override\n\tpublic void A() {\n\t\tSystem.out.println(\"Override\");\n\t}\n}",
      "parent c = new child();\nc.A();",
      "class parent{\n\tpublic void A() {\n\t\tSystem.out.println(\"Origin\");\n\t}\n}\nclass child extends parent{\n\t\n}",
      "parent c = new child();\nc.A();"
    ],
    "date": "2021-06-06",
    "text": "1.方法的继承\n子类可以继承父类的非private方法。\n输出结果为Parent.\n子类可以重写父类的非private方法。\n这时，输出结果为Child\n对于父类的private方法，子类是不可见的，尝试调用父类的private方法会导致静态检查直接报错。\n当然，子类中也可以添加自己独特的新方法。如果子类中写了一个和父类某个private方法一样的方法，这不能算重写，应该也算添加新方法。\n2.属性的继承\n属性的继承和方法的继承类似，子类可以继承父类的非private属性。父子类定义如下：\n子类child可以访问np属性，在main中进行测试，输出结果为0.\n当然，类似于方法的重写，子类也可以覆盖掉父类的属性。\n测试代码和上面一样，输出结果为1.\n当子类试图访问父类的private属性时，静态检查会直接报错。\n子类中也可以添加自己独特的新属性。\n3.方法与属性混合的情况\n如果方法是从父类继承的，那么方法中使用到的属性都是父类的属性。\n在main中测试，输出结果是0.即使子类中已经覆盖了属性np，但是方法的行为仍然和父类一致，这时就不能简单地看代码的逻辑了。如果子类想按照代码的逻辑实现功能的话就只能重写，而重写的代码和之前一模一样。\n这时测试输出结果为1.\n然而对于方法内部再次调用方法的情况，却正好相反。如果从父类继承来的方法A调用了方法B，并且子类重写了方法B，当子类调用方法A时，方法A内部会调用被重写的方法B.\n子类调用A()时会输出Override。\n4.子类转换为父类时，调用方法及属性的情况\n显然的是，当子类转换为父类后，只能调用父类中存在的方法、访问父类中存在的属性。\n当访问属性时，属性的值是父类中的值。\n输出结果为0.\n而调用的方法应该是子类中的方法。\n如果方法被重写，调用的方法就是子类中被重写的方法。\n输出结果为Override。\n如果方法没有被重写，调用的方法就是父类中的方法。\n输出结果为Origin。\n如果调用的方法中访问了某个属性或者又调用了其他方法时，会遵循3中给出的分析。\n简单总结一下\n对于属性的访问，在运行前就会确定，因此只看当前的类型，当前的类型是什么就访问这个类型中定义的属性；而对方法的调用在运行时才会确定，要看原本的类型（即new的时候的类型），按照这个类型调用相应方法。而方法内部如果访问了属性，这个属性是定义该方法的那个类型中的属性；方法内部如果调用了其他方法，被调用的方法仍然是这个类型中的方法，当然，也存在嵌套的情况。\n"
  },
  {
    "head": "2021哈工大软件构造Lab3",
    "paragraphs": [
      "2021年春季学期",
      "计算学部《软件构造》课程",
      "Lab 3实验报告",
      "实验源码：",
      "https://github.com/1190200817/SC_Lab3",
      "1 实验目标概述··· 1",
      "2 实验环境配置··· 1",
      "3 实验过程··· 1",
      "3.1 待开发的三个应用场景··· 1",
      "3.2 面向可复用性和可维护性的设计：IntervalSet<L>· 2",
      "3.2.1 IntervalSet<L>的共性操作··· 2",
      "3.2.2 局部共性特征的设计方案··· 3",
      "3.2.3 面向各应用的IntervalSet子类型设计（个性化特征的设计方案）··· 4",
      "3.3 面向可复用性和可维护性的设计：MultiIntervalSet<L>· 7",
      "3.3.1 MultiIntervalSet<L>的共性操作··· 7",
      "3.3.2 局部共性特征的设计方案··· 7",
      "3.3.3 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）··· 9",
      "3.4 面向复用的设计：L· 11",
      "3.5 可复用API设计··· 13",
      "3.5.1 计算相似度··· 13",
      "3.5.2 计算时间冲突比例··· 14",
      "3.5.3 计算空闲时间比例··· 15",
      "3.6 应用设计与开发··· 15",
      "3.6.1 排班管理系统··· 15",
      "3.6.2 操作系统的进程调度管理系统··· 17",
      "3.6.3 课表管理系统··· 18",
      "3.7 基于语法的数据读入··· 18",
      "3.8 应对面临的新变化··· 20",
      "3.8.1 变化1· 20",
      "3.8.2 变化2· 21",
      "3.9 Git仓库结构··· 21",
      "4 实验进度记录··· 22",
      "5 实验过程中遇到的困难与解决途径··· 23",
      "6 实验过程中收获的经验、教训、感想··· 24",
      "6.1 实验过程中收获的经验和教训··· 24",
      "6.2 针对以下方面的感受··· 24",
      "实验目标概述",
      "本次实验覆盖课程第 2、3 章的内容，目标是编写具有可复用性和可维护性的软件，主要使用以下软件构造技术：",
      "子类型、泛型、多态、重写、重载",
      "继承、代理、组合",
      "语法驱动的编程、正则表达式",
      "API 设计、API 复用",
      "本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过 ADT 和泛型等抽象技术，开发一套可复用的 ADT 及其实现，充分考虑这些应用之间的相似性和差异性，使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。",
      "实验环境配置",
      "Eclipse和Git在上一次实验中已经配置好了。本次实验无需额外配置环境。",
      "在这里给出你的GitHub Lab3仓库的URL地址（Lab3-学号）。",
      "https://github.com/ComputerScienceHIT/HIT-Lab3-1190200817",
      "实验过程",
      "请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。",
      "待开发的三个应用场景",
      "简要介绍三个应用：",
      "①值班表管理，一个单位有 n 个员工，在某个时间段内安排值班。每天只能安排一个员工且不能出现无人值班的情况；每个员工需要安排在连续的几天内。值班表内需要记录员工的名字、职位、手机号码，以便于外界联系值班员。",
      "②操作系统进程调度管理，进程被调度在 CPU 上执行，操作系统决定在各个时段内执行哪个进程。操作系统可挂起某个正在执行的进程，在后续时刻可以恢复执行被挂起的进程。每个时间只能有一个进程在执行，其他进程处于休眠状态；一个进程的执行被分为多个时间段；在特定时刻，CPU 可以“闲置”；调度无规律，可看作是随机调度。",
      "③大学课表管理：课程需要特定的教室和特定的教师。假设各周的课表都是完全一样的，同样的课程安排将以“周”为单位进行周期性的重复，直到学期结束；一门课程每周可以出现 1 次，也可以安排多次，且由同一位教师承担并在同样的教室进行；允许课表中有空白时间段；同一个时间段内可以安排不同的课程；一位教师也可以承担课表中的多门课程。",
      "相同之处：都包含了具有不同特征的“时间段集合”对象。每个时间段对应一个对象标签。",
      "不同之处：有三个维度上的差异。①是否允许时间轴上有空白。在应用1中，不允许有空白；在应用2和应用3中，允许有空白。②是否允许不同的 interval 之间有重叠。在应用1和应用2中，不允许有重叠；在应用3中，允许有重叠。③是否包含周期性的时间段。应用 3 中以“一周”为单位重复某个课程，但应用1和应用2中不存在这种情况。",
      "面向可复用性和可维护性的设计：",
      "IntervalSet<L>",
      "该节是本实验的核心部分。",
      "IntervalSet<L>",
      "的共性操作",
      "这个ADT描述了一组在时间轴上分布的“时间段”，每个时间段附着一个特定的标签，且标签不重复。因此共性的方法包括：",
      "静态工厂方法empty()：创建一个空对象。",
      "void insert(long start, long end, L label)：在当前对象中插入新的时间段和标签。",
      "Set<L> labels()：获得当前对象中的标签集合。",
      "boolean remove(L label)：从当前对象中移除某个标签所关联的时间段。",
      "long start (L label)：返回某个标签对应的时间段的开始时间。",
      "long end (L label)：返回某个标签对应的时间段的结束时间。",
      "IntervalSet<L> copy()：返回这个对象的副本。",
      "局部共性特征的设计方案",
      "由于IntervalSet是一对一的结构，即一个标签对应一个时间段，因此可以使用Map作为内部的数据结构，定义为：",
      "private final Map<L, time> intervalMap = new HashMap<>();",
      "由于时间段是两个long型的整数构成的，因此可以定义一个辅助类time表示一个时间段。其中start是时间段的开始，end是时间段的结束，同时要求start一定大于0且start一定比end小。这里time实现了Comparable接口是为了满足下面MultiIntervalSet中的一些功能。",
      "对于empty()方法，直接返回一个具体实现类。",
      "对于insert()方法，首先判断非法条件（start<0和start>=end），然后判断Map中是否包含标签，若包含该标签，那只有在重复设置相同时间段时才合法，否则会抛出IntervalConflictException；若不包含该标签，就直接插入时间段。（注意，这里是允许不同标签之间存在Overlap的）",
      "对于labels()方法，直接返回Map中所有的键构成的集合即可。",
      "对于remove()方法，判断Map的键中是否存在该标签，若不存在，直接返回false；若存在，就在Map中删除该标签，并返回true。",
      "对于start()方法，判断Map的键中是否存在该标签，若不存在，直接返回-1，否则可以得到标签对应的时间段time，调用time的getStart()方法就可以得到时间段的开始时间并返回。",
      "对于end()方法，同上，但要调用time的getEnd()方法得到时间段的结束时间并返回。",
      "对于copy()方法，先新建一个空白的IntervalSet副本，然后遍历Map。将遍历得到的所有时间段和标签通过insert()方法插入到新的副本中，最后返回该副本。",
      "此外，还需要重写toString方法提供容易阅读的信息。",
      "面向各应用的",
      "IntervalSet子类型设计（个性化特征的设计方案）",
      "一、使用decorator装饰器的方法进行是否允许不同的 interval 之间有重叠以及周期性的维度的个性特征的设计。向装饰器中传入待装饰的IntervalSet，并在继承该装饰器的具体子类中实现相应的个性化功能。如下图，在装饰器IntervalSetDecorator中有属性intervalSet，是一个待装饰的IntervalSet类，而IntervalSetDecorator中的所有方法都调用intervalSet的相应方法。",
      "①不允许重叠的IntervalSet实现如下：",
      "首先NoOverlapIntervalSet继承装饰器IntervalSetDecorator，并实现IntervalSet接口。在NoOverlapIntervalSet中添加一个属性intervalMap记录添加的所有时间段。",
      "在重写的insert()方法中，首先判断新添加的时间段是否与已添加的时间段发生重叠，如果有，直接抛出异常；否则就调用未重写的父类的insert()方法进行插入。",
      "②周期性的IntervalSet实现如下：",
      "首先PeriodicIntervalSet继承装饰器IntervalSetDecorator，并实现IntervalSet接口。在PeriodicIntervalSet中添加一个属性period记录时间周期。",
      "在重写的insert()方法中，将开始时间和结束时间对周期取模后再调用未重写的父类的insert()方法进行插入。",
      "二、使用代理的方式进行是否允许时间轴上有空白这个维度的个性特征的设计。由于不允许空白相当于添加了新的方法，因此将这个特性抽象为一个接口NoBlankIntervalSet：",
      "接口中包含三个方法：blankIntervals()返回所有的空白时间段集合；getStart-Time()返回总的开始时间；getEndTime()返回总的结束时间。",
      "一个具体的不允许时间轴上有空白的IntervalSet只需要实现NoBlank-IntervalSet接口。具体实现类CommonNoBlankIntervalSet的实现如下：",
      "属性startTime是总的开始时间，endTime是总的结束时间。blankIntervals()的实现如图，首先将空白时间段设置为整个时间段，然后遍历所有的时间段，将这些时间段从空白时间段中去除，最后得到的就是所有的空白时间段。",
      "面向可复用性和可维护性的设计：",
      "MultiIntervalSet<L>",
      "MultiIntervalSet<L>",
      "的共性操作",
      "静态工厂方法empty()：创建一个空对象。",
      "MultiIntervalSet(IntervalSet<L> initial)：利用initial中包含的数据创建非空对象。",
      "void insert(long start, long end, L label)：在当前对象中插入新的时间段和标签。",
      "Set<L> labels()：获得当前对象中的标签集合。",
      "boolean remove(L label)：从当前对象中移除某个标签所关联的所有时间段。",
      "IntervalSet<Integer> intervals(L label)：从当前对象中获取与某个标签所关联的所有时间段。",
      "局部共性特征的设计方案",
      "由于要求必须使用 IntervalSet<L>作为其 rep 的一部分，因此选择IntervalSet<L>组成的List作为rep。一个IntervalSet中只存储某个标签对应的一个时间段，如果一个标签对应多个时间段，需要分散在不同的IntervalSet中。",
      "对于empty()方法，直接返回一个具体实现类。",
      "对于initial初始化方法，直接将传入的IntervalSet的副本作为rep的一个元素。",
      "对于insert()方法，首先判断非法情况。之后遍历IntervalSet列表得到标签对应的所有时间段，判断已存在的时间段和要增加的时间段是否存在重叠，如果重叠则抛出异常；若不重叠，就寻找某个不存在该标签的IntervalSet，将这个时间段插入该IntervalSet，如果列表中所有的IntervalSet都包含该标签，就需要新建一个空白的IntervaSet加入列表，再进行插入。",
      "对于labels()方法，可以直接返回第一个IntervalSet中的所有标签组成的集合。（因为插入时都是从头开始遍历的，因此不会存在某个标签出现在后面的IntervalSet而不在第一个IntervalSet中的情况）",
      "对于remove()方法，直接对每个IntervalSet调用remove()方法即可。",
      "对于intervals()方法，遍历IntervalSet列表得到标签对应的所有时间段，将时间段从小到大进行排序（前面time的实现中进行了说明）。然后将每个时间段以它的顺序作为标签插入到一个IntervalSet中并返回。",
      "此外，还需要重写toString方法提供容易阅读的信息。",
      "面向各应用的",
      "MultiIntervalSet子类型设计（个性化特征的设计方案）",
      "与3.2.3同理，使用decorator装饰器的方法进行是否允许不同的interval之间有重叠以及周期性的维度的个性特征的设计。向装饰器中传入待装饰的MultiIntervalSet，并在继承该装饰器的具体子类中实现相应的个性化功能。如下图，在装饰器MultiIntervalSetDecorator中有属性multiIntervalSet，是一个待装饰的MultiIntervalSet类，而MultiIntervalSetDecorator中的所有方法都调用multiIntervalSet的相应方法。",
      "①不允许重叠的MultiIntervalSet实现如下：",
      "首先NoOverlapMultiIntervalSet继承装饰器MultiIntervalSetDecorator，并实现MultiIntervalSet接口。",
      "在重写的insert()方法中，首先判断新添加的时间段是否与已添加的时间段发生重叠，如果有，直接抛出异常；否则就调用未重写的父类的insert()方法进行插入。",
      "②周期性的MultiIntervalSet实现如下：",
      "首先PeriodicMultiIntervalSet继承装饰器MultiIntervalSetDecorator，并实现MultiIntervalSet接口。在PeriodicMultiIntervalSet中添加一个属性period记录时间周期。",
      "在重写的insert()方法中，将开始时间和结束时间对周期取模后再调用未重写的父类的insert()方法进行插入。",
      "面向复用的设计：",
      "设计三个应用的不同标签，分别为“员工”（Employee）、“进程”（Process）、",
      "“课程”（Course）。并且它们都是immutable类。",
      "①对于Employee，具有的属性为：姓名、职务、手机号码。",
      "除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：只有三个属性均相同时才认为是相同的。",
      "②对于",
      "Course，具有的属性为：课程 ID、课程名称、教师名字、地点。",
      "除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：只有四个属性均相同时才认为是相同的。",
      "此外，Course类实现了Comparable接口，这是为了APP中显示课程顺序的合理性。",
      "③对于Process，具有的属性为：进程 ID、进程名称、最短执行时间、最长执行时间。",
      "除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：进程ID相同时认为是相同的。",
      "可复用",
      "API设计",
      "计算相似度",
      "对于两个MultiIntervalSet：s1和s2，遍历s1中的标签，查看s2中是否存在相同的标签，如果不存在，则对相似度没有贡献；如果存在，那么这个标签在s1和s2中各有一个时间段的集合，计算这两个时间段集合的重合长度，将所有的重合长度加在一起除以MultiIntervalSet的时间跨度就是两个MultiIntervalSet的相似度。",
      "时间冲突比例",
      "对于IntervalSet来说，由于它是一个特殊的MultiIntervalSet，因此可以把它转换成MultiIntervalSet后再调用针对MultiIntervalSet的计算时间冲突比例的函数。",
      "对于MultiIntervalSet，维护一个冲突时间段的集合conflictTime，初始时为空。遍历set中的标签，判断该标签和其他标签的时间段是否存在重合，如果存在，就将冲突的时间段加入conflictTime。向conflictTime加入时间段也需要考虑重合的问题，集合中不能有重合的时间段，因此向conflictTime加入时间段时需要进行适当的合并。最后conflictTime中的时间长度除以总的时间跨度就是时间冲突比例。",
      "计算空闲时间比例",
      "对于IntervalSet来说，由于它是一个特殊的MultiIntervalSet，因此可以把它转换成MultiIntervalSet后再调用针对MultiIntervalSet的计算空闲时间比例的函数。",
      "对于MultiIntervalSet，原理类似于3.2.3中的blankIntervals()方法。维护一个空闲时间段的集合freeTime，初始时为整个时间段。遍历set中的所有时间段，并将其从freeTime中删去。最后freeTime中的时间长度除以总的时间跨度就是空闲比例。",
      "应用设计与开发",
      "利用上述设计和实现的ADT，实现手册里要求的各项功能。",
      "排班管理系统",
      "使用DutyIntervalSet作为数据结构，同时维护一个Employee的集合可以存储未被安排的员工。刚进入时APP，会提示初始化一些信息，包括：排班开始日期、结束日期以及一组员工信息。初始化结束后，打印一个菜单，告诉用户提供的一些功能。",
      "根据用户选择的功能采取相应的操作。其中选项",
      "1,2涉及对Employee集合的增删；3对应DutyIntervalSet的insert操作；4对应DutyIntervalSet的remove操作；5对应DutyIntervalSet的blankIntervals操作；7对应DutyIntervalSet的blankIntervals操作以及DutyIntervalSet的labels、start、end操作；8的操作见3.7节。由于这些操作都是简单地使用一些函数，因此不再详细叙述。这里只介绍“6：自动编排”的实现方法：首先调用DutyIntervalSet的blankIntervals操作得到未被安排的时间段，然后遍历Employee集合，找出未被安排的员工，将这些未被安排的时间段和员工一对一匹配起来，并调用insert方法插入到DutyIntervalSet中。",
      "此外，APP还拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。举例来说，针对添加员工的操作，存在各种非法的输入情况，在APP中都得到了相应的解决，并提示给用户。",
      "操作系统的进程调度管理系统",
      "使用ProcessIntervalSet作为数据结构，同时维护一个的Map存储进程和已执行时间的映射关系。进入APP后，会打印一个菜单，告诉用户提供的一些功能。",
      "根据用户选择的功能采取相应的操作。其中选项1,2涉及对Map的增删；5，6对应ProcessIntervalSet的intervals操作。由于这些操作都是简单地使用一些函数，因此不再详细叙述。这里介绍3,4的实现方法，选项3：从时间点0开始进入一个循环，当所有的进程都被执行完成后退出循环。在循环中，首先使用随机数（random.nextBoolean）决定是否调度进程，如果决定不调度进程，则闲置一段随机的时间（random.nextInt）；如果决定调度进程，则随机选择一个未完成的进程（使用随机数选择进程的序号）并执行一段随机的时间（random.nextInt），执行结束后，如果该进程的总执行时间已经落到最短执行时间和最长执行时间的区间内，则该进程被执行完成，然后从这个时间点开始进行下一轮的循环。选项4：和选项3唯一的不同在于进程的选择不是随机的，而是选择距离其最大执行时间差距最小的进程。",
      "同样地，APP拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。",
      "课表管理系统",
      "使用CourseIntervalSet作为数据结构，同时维护一个Course的Map存储未被安排的课程以及对应的剩余学时数。刚进入时APP，会提示初始化一些信息，包括：学期开始日期、总周数、以及一组课程信息。初始化结束后，打印一个菜单，告诉用户提供的一些功能。",
      "根据用户选择的功能采取相应的操作。其中选项1,2涉及对Course映射的增删；3对应CourseIntervalSet的insert操作；4对应CourseIntervalSet的remove操作；5对应对Course映射的遍历以及显示；6,7对应API中操作的使用；8对应CourseIntervalSet的intervals操作。由于这些操作都是简单地使用一些函数，因此不再详细叙述。",
      "同样地，APP拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。",
      "基于语法的数据读入",
      "首先对文件的格式进行分析，文件总共包括三个部分，分别是Employee、Period和Roster，每个部分有自己独特的格式。在假设没有空格、缩进和空行的情况下，可以分别设计识别每个部分的正则表达式。",
      "Employee部分的正则表达式：",
      "Period部分的正则表达式：",
      "Roster部分的正则表达式：",
      "对于整个文件，由于三个部分出现的顺序是不定的，即共有六种情况，因此识别整个文件的正则表达式为：",
      "首先利用这个正则表达式判断文件的格式是否正确，如果正确就抽取出每个部分。",
      "利用Employee内部的格式抽取出员工信息：",
      "利用Period的格式抽取出时间段信息：",
      "利用Roster内部的格式抽取出排班信息：",
      "根据抽取出的信息，就可以构造出一个排班表了，在构造的同时判断一些错误，如：员工信息重复、员工未定义、时间重叠等。",
      "在APP中，读入用户指定的文件，并去除所有的空格、缩进、空行，之后调用Parser解析信息，在出现错误时提示给用户相应错误信息。",
      "应对面临的新变化",
      "修改之前的DutyIntervalSet实现的是IntervalSet接口，但是本次变化要求每个标签可以对应多个时间段，因此要求DutyIntervalSet实现MulitIntervalSet接口，同时还要保持不允许重叠的特征。因此只需要修改DutyIntervalSet继承的装饰器类型以及实现的接口类型即可。具体修改如图：",
      "修改前的代码：",
      "修改后的代码：",
      "由于DutyIntervalSet从实现IntervalSet接口变为实现MulitIntervalSet接口，因此一些方法会发生变化，例如不再支持start()和end()方法，同时新增加了intervals()方法。因此，在DutyRosterApp需要修改相应的实现方法。举例来说，对于APP中的可视化排班信息的功能，需要遍历DutyIntervalSet中的信息，之前的遍历方式直接使用labels()方法：",
      "但是，修改之后需要使用intervals()方法：",
      "在其他地方也涉及这种变化，就不一一列举了。同时，需要修改测试代码保持测试的正确性。",
      "除修改测试代码的变化，一共修改大约50行代码，花费时间较短，说明之前的设计较为合理，应对变化的能力比较强，可维护性很好。测试代码的修改大约也在50行左右。",
      "由于使用了装饰器，只需要将原来传入装饰器的MultiIntervalSet改为不能重叠的NonOverlapMultiIntervalSet即可。如果不考虑测试代码的话，真正修改的代码只有一行！说明之前的设计较为合理，应对变化的能力比较强，可维护性很好。具体修改如图：",
      "修改前的代码（传入可重叠的MultiIntervalSet）：",
      "修改后的代码（传入不可重叠的NoOverlapMultiIntervalSet）：",
      "为了使得测试仍然保持正确，需要修改原来的测试代码，总共修改的代码量大约为50行，花费时间较短。",
      "Git",
      "仓库结构",
      "请在完成全部实验要求之后，利用Git log指令或Git图形化客户端或GitHub上项目仓库的Insight页面，给出",
      "你的仓库到目前为止的",
      "Object Graph，尤其是区分清楚change分支和master分支所指向的位置。",
      "使用git log指令， 得到如下结果：",
      "可以看出，Git仓库到目前为止的Object Graph有如下形式：",
      "实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。",
      "不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。",
      "时间段",
      "计划任务",
      "实际完成情况",
      "2021.6.28",
      "12:30-14:30",
      "设计IntervalSet接口并完成一个具体的实现类CommonIntervalSet，编写测试",
      "2021.6.28",
      "14:30-17:00",
      "设计MultiIntervalSet接口并完成具体的实现类CommonMultiIntervalSet，编写测试",
      "2021.6.28",
      "17:30-18:30",
      "设计IntervalSet和Common-MultiIntervalSet的装饰器",
      "2021.6.28",
      "18:30-19:30",
      "在有无空白的维度上，设计NoBlankIntervalSet接口并完成具体实现类CommonNoBlankIntervalSet，编写测试",
      "2021.6.28",
      "19:30-21:00",
      "在是否允许重叠的维度上，设计实现不允许重叠的装饰类NoOverlapIntervalSet和NoOverlap-MultiIntervalSet，编写测试",
      "2021.6.28",
      "21:30-22:30",
      "在周期性的维度上，设计实现周期性的装饰类PeriodicIntervalSet和PeriodicMultiIntervalSet，编写测试",
      "2021.6.29",
      "9:00-10:00",
      "实现Employee、Process、Course类，编写测试",
      "2021.6.29",
      "10:00-12:30",
      "设计实现API，编写测试",
      "2021.6.29",
      "13:30-14:00",
      "实现DutyIntervalSet、Process-IntervalSet和CourseIntervalSet，编写测试",
      "2021.6.29",
      "14:00-17:30",
      "实现DutyRosterApp",
      "测试健壮性时发现很多不足，延期一小时完成",
      "2021.6.29",
      "19:00-22:00",
      "实现CourseScheduleApp",
      "测试健壮性时发现很多不足，延期半小时完成",
      "2021.6.30",
      "9:00-12:00",
      "实现ProcessScheduleApp",
      "2021.6.30",
      "16:30-17:30",
      "学习正则表达式",
      "2021.6.30",
      "18:30-20:30",
      "设计实现解析器Parser，编写测试",
      "由于对正则表达式不太熟悉，延期半小时完成",
      "2021.6.30",
      "21:00-22:30",
      "向DutyRosterApp中加入解析文件功能",
      "2021.7.1",
      "9:00-10:00",
      "完善整个项目的注释（spec、AF、RI、safe from exposure、test strategy）",
      "2021.7.1",
      "10:30-11:30",
      "修改代码以面对新的变化",
      "实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "对装饰器不够熟悉，不知如何编写正确的装饰器以实现功能。",
      "在网上查看其它应用使用装饰器的方法并加以总结，逐渐熟悉装饰器的使用。",
      "编写APP时遇到很多的健壮性问题。",
      "仔细分析每个步骤中用户可能的所有输入，针对任何非法情况都作出提示。虽然很耗费时间，但效果很好。",
      "不知如何设计正则表达式来抽取大量的文件信息。",
      "在学习正则表达式语法的同时进行一些小的测试，从小的正则表达式开始，逐渐累积成复杂的正则表达式，最终实现对文件的解析。",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "设计ADT时一定要考虑得全面且清楚，在最终决定实现方案后再编写代码，否则在后面的应用实现中发现问题时只能再重新设计。同时，在编写APP时，一定要事先考虑健壮性的问题，不然，在编写完代码之后进行测试时会遇到很多的健壮性问题，这时再去修改就会使得代码很臃肿，可读性变差，出错的可能性更高。",
      "针对以下方面的感受",
      "重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用，你是否体会到复用的好处？",
      "面向ADT的编程需要从实际中进行抽象，并进行合理的设计，有很好的可扩展性和可复用性；而直接面向应用场景编程只针对特定应用，每次更换应用场景时都要重新编程，扩展性很差，只适合简单的应用场景。本实验中设计一个ADT就可以应用到三个不同的场景，大大缩短了开发时间。",
      "重新思考Lab2中的问题：为ADT撰写复杂的specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？",
      "这些工作使得客户端了解各方法的功能但无法得知内部具体实现，可以防止内部变量被客户端恶意修改，时刻检查表示不变量，保证安全性。虽然这些工作有些麻烦，但却是好的软件必须具备的，因此我愿意在以后编程中坚持这么做。同时，在复杂的软件开发过程中，好的注释可以节省大量阅读代码的时间，使得开发时间大大降低。",
      "之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？",
      "由于API面向的场景是广泛的，因此开发难度很大，但是一旦开发一个好的API，就可以在大量场合中应用，大大提高代码的复用性。",
      "你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？",
      "语法驱动编程为实际应用提供了很大的便利，用户无需繁琐地一行一行地输入信息，而只需提供一个文件以及一定的语法规则即可。而对于应用的开发者，只需根据语法规则编写代码，即使改变语法规则也可以很快地修改实现代码，有很好的可维护性。",
      "Lab1和Lab2的大部分工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过五周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？",
      "ADT的难度主要体现在抽象上。一个好的ADT既不能过于具体，也不能过于抽象。需要从大量应用场景中寻找共性，抽象的程度也很难把握。对于这种情况，只能反复的推敲，比较不同设计方案的差异并选择最好的ADT设计方案。",
      "“抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的五个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？",
      "接口、抽象类、类的抽象程度一定是逐渐降低的，将所有应用的共性抽象为接口，然后在抽象类以及类中添加新的特性。通过接口的组合可以形成新的接口，并可以具备不同接口中的抽象。类的继承也可以增加更具体的新的特性。同时，使用正确的设计模式可以使得代码的可复用性和可维护性最大化。",
      "关于本实验的工作量、难度、deadline。",
      "难度适中，可以接受，但是工作量很大，尤其是APP的编写要花费很长时间。虽然给了三周时间，但是和其他课的实验、大作业、考试有重叠，总体上时间还是很紧。希望各课程的老师可以相互协调一下实验安排。",
      "到目前为止你对《软件构造》课程的评价。",
      "逐渐理解了软件构造过程中独有的思路和方法，也逐渐适应了与之前完全不同的编程过程。通过Lab3大量的代码训练，自己的编程水平也有了极大的提高。"
    ],
    "sentences": [
      "2021年春季学期",
      "计算学部《软件构造》课程",
      "Lab 3实验报告",
      "实验源码：https://github.com/1190200817/SC_Lab3",
      "1 实验目标概述··· 1",
      "2 实验环境配置··· 1",
      "3 实验过程··· 1",
      "3.1 待开发的三个应用场景··· 1",
      "3.2 面向可复用性和可维护性的设计：IntervalSet<L>· 2",
      "3.2.1 IntervalSet<L>的共性操作··· 2",
      "3.2.2 局部共性特征的设计方案··· 3",
      "3.2.3 面向各应用的IntervalSet子类型设计（个性化特征的设计方案）··· 4",
      "3.3 面向可复用性和可维护性的设计：MultiIntervalSet<L>· 7",
      "3.3.1 MultiIntervalSet<L>的共性操作··· 7",
      "3.3.2 局部共性特征的设计方案··· 7",
      "3.3.3 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）··· 9",
      "3.4 面向复用的设计：L· 11",
      "3.5 可复用API设计··· 13",
      "3.5.1 计算相似度··· 13",
      "3.5.2 计算时间冲突比例··· 14",
      "3.5.3 计算空闲时间比例··· 15",
      "3.6 应用设计与开发··· 15",
      "3.6.1 排班管理系统··· 15",
      "3.6.2 操作系统的进程调度管理系统··· 17",
      "3.6.3 课表管理系统··· 18",
      "3.7 基于语法的数据读入··· 18",
      "3.8 应对面临的新变化··· 20",
      "3.8.1 变化1· 20",
      "3.8.2 变化2· 21",
      "3.9 Git仓库结构··· 21",
      "4 实验进度记录··· 22",
      "5 实验过程中遇到的困难与解决途径··· 23",
      "6 实验过程中收获的经验、教训、感想··· 24",
      "6.1 实验过程中收获的经验和教训··· 24",
      "6.2 针对以下方面的感受··· 24",
      "实验目标概述",
      "本次实验覆盖课程第 2、3 章的内容",
      "目标是编写具有可复用性和可维护性的软件",
      "主要使用以下软件构造技术：子类型、泛型、多态、重写、重载",
      "继承、代理、组合",
      "语法驱动的编程、正则表达式",
      "API 设计、API 复用",
      "本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理）",
      "学生不是直接针对每个应用分别编程实现",
      "而是通过 ADT 和泛型等抽象技术",
      "开发一套可复用的 ADT 及其实现",
      "充分考虑这些应用之间的相似性和差异性",
      "使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）",
      "实验环境配置",
      "Eclipse和Git在上一次实验中已经配置好了",
      "本次实验无需额外配置环境",
      "在这里给出你的GitHub Lab3仓库的URL地址（Lab3-学号）",
      "https://github.com/ComputerScienceHIT/HIT-Lab3-1190200817",
      "实验过程",
      "请仔细对照实验手册",
      "针对每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）",
      "待开发的三个应用场景",
      "简要介绍三个应用：①值班表管理",
      "一个单位有 n 个员工",
      "在某个时间段内安排值班",
      "每天只能安排一个员工且不能出现无人值班的情况；每个员工需要安排在连续的几天内",
      "值班表内需要记录员工的名字、职位、手机号码",
      "以便于外界联系值班员",
      "②操作系统进程调度管理",
      "进程被调度在 CPU 上执行",
      "操作系统决定在各个时段内执行哪个进程",
      "操作系统可挂起某个正在执行的进程",
      "在后续时刻可以恢复执行被挂起的进程",
      "每个时间只能有一个进程在执行",
      "其他进程处于休眠状态；一个进程的执行被分为多个时间段；在特定时刻",
      "CPU 可以“闲置”；调度无规律",
      "可看作是随机调度",
      "③大学课表管理：课程需要特定的教室和特定的教师",
      "假设各周的课表都是完全一样的",
      "同样的课程安排将以“周”为单位进行周期性的重复",
      "直到学期结束；一门课程每周可以出现 1 次",
      "也可以安排多次",
      "且由同一位教师承担并在同样的教室进行；允许课表中有空白时间段；同一个时间段内可以安排不同的课程；一位教师也可以承担课表中的多门课程",
      "相同之处：都包含了具有不同特征的“时间段集合”对象",
      "每个时间段对应一个对象标签",
      "不同之处：有三个维度上的差异",
      "①是否允许时间轴上有空白",
      "在应用1中，不允许有空白；在应用2和应用3中，允许有空白",
      "②是否允许不同的 interval 之间有重叠",
      "在应用1和应用2中，不允许有重叠；在应用3中，允许有重叠",
      "③是否包含周期性的时间段",
      "应用 3 中以“一周”为单位重复某个课程",
      "但应用1和应用2中不存在这种情况",
      "面向可复用性和可维护性的设计：IntervalSet<L>",
      "该节是本实验的核心部分",
      "IntervalSet<L>",
      "的共性操作",
      "这个ADT描述了一组在时间轴上分布的“时间段”",
      "每个时间段附着一个特定的标签",
      "且标签不重复",
      "因此共性的方法包括：静态工厂方法empty()：创建一个空对象",
      "void insert(long start, long end, L label)：在当前对象中插入新的时间段和标签",
      "Set<L> labels()：获得当前对象中的标签集合",
      "boolean remove(L label)：从当前对象中移除某个标签所关联的时间段",
      "long start (L label)：返回某个标签对应的时间段的开始时间",
      "long end (L label)：返回某个标签对应的时间段的结束时间",
      "IntervalSet<L> copy()：返回这个对象的副本",
      "局部共性特征的设计方案",
      "由于IntervalSet是一对一的结构",
      "即一个标签对应一个时间段",
      "因此可以使用Map作为内部的数据结构",
      "定义为：private final Map<L, time> intervalMap = new HashMap<>();由于时间段是两个long型的整数构成的",
      "因此可以定义一个辅助类time表示一个时间段",
      "其中start是时间段的开始",
      "end是时间段的结束",
      "同时要求start一定大于0且start一定比end小",
      "这里time实现了Comparable接口是为了满足下面MultiIntervalSet中的一些功能",
      "对于empty()方法，直接返回一个具体实现类",
      "对于insert()方法",
      "首先判断非法条件（start<0和start>=end）",
      "然后判断Map中是否包含标签",
      "若包含该标签",
      "那只有在重复设置相同时间段时才合法",
      "否则会抛出IntervalConflictException；若不包含该标签",
      "就直接插入时间段",
      "（注意，这里是允许不同标签之间存在Overlap的）",
      "对于labels()方法",
      "直接返回Map中所有的键构成的集合即可",
      "对于remove()方法",
      "判断Map的键中是否存在该标签",
      "若不存在",
      "直接返回false；若存在",
      "就在Map中删除该标签",
      "并返回true",
      "对于start()方法",
      "判断Map的键中是否存在该标签",
      "若不存在",
      "直接返回-1",
      "否则可以得到标签对应的时间段time",
      "调用time的getStart()方法就可以得到时间段的开始时间并返回",
      "对于end()方法",
      "同上",
      "但要调用time的getEnd()方法得到时间段的结束时间并返回",
      "对于copy()方法",
      "先新建一个空白的IntervalSet副本",
      "然后遍历Map",
      "将遍历得到的所有时间段和标签通过insert()方法插入到新的副本中",
      "最后返回该副本",
      "此外，还需要重写toString方法提供容易阅读的信息",
      "面向各应用的",
      "IntervalSet子类型设计（个性化特征的设计方案）",
      "一、使用decorator装饰器的方法进行是否允许不同的 interval 之间有重叠以及周期性的维度的个性特征的设计",
      "向装饰器中传入待装饰的IntervalSet",
      "并在继承该装饰器的具体子类中实现相应的个性化功能",
      "如下图",
      "在装饰器IntervalSetDecorator中有属性intervalSet",
      "是一个待装饰的IntervalSet类",
      "而IntervalSetDecorator中的所有方法都调用intervalSet的相应方法",
      "①不允许重叠的IntervalSet实现如下：首先NoOverlapIntervalSet继承装饰器IntervalSetDecorator",
      "并实现IntervalSet接口",
      "在NoOverlapIntervalSet中添加一个属性intervalMap记录添加的所有时间段",
      "在重写的insert()方法中",
      "首先判断新添加的时间段是否与已添加的时间段发生重叠",
      "如果有",
      "直接抛出异常；否则就调用未重写的父类的insert()方法进行插入",
      "②周期性的IntervalSet实现如下：首先PeriodicIntervalSet继承装饰器IntervalSetDecorator",
      "并实现IntervalSet接口",
      "在PeriodicIntervalSet中添加一个属性period记录时间周期",
      "在重写的insert()方法中",
      "将开始时间和结束时间对周期取模后再调用未重写的父类的insert()方法进行插入",
      "二、使用代理的方式进行是否允许时间轴上有空白这个维度的个性特征的设计",
      "由于不允许空白相当于添加了新的方法",
      "因此将这个特性抽象为一个接口NoBlankIntervalSet：接口中包含三个方法：blankIntervals()返回所有的空白时间段集合；getStart-Time()返回总的开始时间；getEndTime()返回总的结束时间",
      "一个具体的不允许时间轴上有空白的IntervalSet只需要实现NoBlank-IntervalSet接口",
      "具体实现类CommonNoBlankIntervalSet的实现如下：属性startTime是总的开始时间",
      "endTime是总的结束时间",
      "blankIntervals()的实现如图",
      "首先将空白时间段设置为整个时间段",
      "然后遍历所有的时间段",
      "将这些时间段从空白时间段中去除",
      "最后得到的就是所有的空白时间段",
      "面向可复用性和可维护性的设计：MultiIntervalSet<L>",
      "MultiIntervalSet<L>",
      "的共性操作",
      "静态工厂方法empty()：创建一个空对象",
      "MultiIntervalSet(IntervalSet<L> initial)：利用initial中包含的数据创建非空对象",
      "void insert(long start, long end, L label)：在当前对象中插入新的时间段和标签",
      "Set<L> labels()：获得当前对象中的标签集合",
      "boolean remove(L label)：从当前对象中移除某个标签所关联的所有时间段",
      "IntervalSet<Integer> intervals(L label)：从当前对象中获取与某个标签所关联的所有时间段",
      "局部共性特征的设计方案",
      "由于要求必须使用 IntervalSet<L>作为其 rep 的一部分",
      "因此选择IntervalSet<L>组成的List作为rep",
      "一个IntervalSet中只存储某个标签对应的一个时间段",
      "如果一个标签对应多个时间段",
      "需要分散在不同的IntervalSet中",
      "对于empty()方法，直接返回一个具体实现类",
      "对于initial初始化方法",
      "直接将传入的IntervalSet的副本作为rep的一个元素",
      "对于insert()方法，首先判断非法情况",
      "之后遍历IntervalSet列表得到标签对应的所有时间段",
      "判断已存在的时间段和要增加的时间段是否存在重叠",
      "如果重叠则抛出异常；若不重叠",
      "就寻找某个不存在该标签的IntervalSet",
      "将这个时间段插入该IntervalSet",
      "如果列表中所有的IntervalSet都包含该标签",
      "就需要新建一个空白的IntervaSet加入列表",
      "再进行插入",
      "对于labels()方法",
      "可以直接返回第一个IntervalSet中的所有标签组成的集合",
      "（因为插入时都是从头开始遍历的",
      "因此不会存在某个标签出现在后面的IntervalSet而不在第一个IntervalSet中的情况）",
      "对于remove()方法",
      "直接对每个IntervalSet调用remove()方法即可",
      "对于intervals()方法",
      "遍历IntervalSet列表得到标签对应的所有时间段",
      "将时间段从小到大进行排序（前面time的实现中进行了说明）",
      "然后将每个时间段以它的顺序作为标签插入到一个IntervalSet中并返回",
      "此外，还需要重写toString方法提供容易阅读的信息",
      "面向各应用的",
      "MultiIntervalSet子类型设计（个性化特征的设计方案）",
      "与3.2.3同理",
      "使用decorator装饰器的方法进行是否允许不同的interval之间有重叠以及周期性的维度的个性特征的设计",
      "向装饰器中传入待装饰的MultiIntervalSet",
      "并在继承该装饰器的具体子类中实现相应的个性化功能",
      "如下图",
      "在装饰器MultiIntervalSetDecorator中有属性multiIntervalSet",
      "是一个待装饰的MultiIntervalSet类",
      "而MultiIntervalSetDecorator中的所有方法都调用multiIntervalSet的相应方法",
      "①不允许重叠的MultiIntervalSet实现如下：首先NoOverlapMultiIntervalSet继承装饰器MultiIntervalSetDecorator",
      "并实现MultiIntervalSet接口",
      "在重写的insert()方法中",
      "首先判断新添加的时间段是否与已添加的时间段发生重叠",
      "如果有",
      "直接抛出异常；否则就调用未重写的父类的insert()方法进行插入",
      "②周期性的MultiIntervalSet实现如下：首先PeriodicMultiIntervalSet继承装饰器MultiIntervalSetDecorator",
      "并实现MultiIntervalSet接口",
      "在PeriodicMultiIntervalSet中添加一个属性period记录时间周期",
      "在重写的insert()方法中",
      "将开始时间和结束时间对周期取模后再调用未重写的父类的insert()方法进行插入",
      "面向复用的设计：设计三个应用的不同标签",
      "分别为“员工”（Employee）、“进程”（Process）、“课程”（Course）",
      "并且它们都是immutable类",
      "①对于Employee，具有的属性为：姓名、职务、手机号码",
      "除了相应的get方法之外",
      "还需要重写equals()、hashCode()和toString()方法",
      "equals()的判断依据是：只有三个属性均相同时才认为是相同的",
      "②对于",
      "Course",
      "具有的属性为：课程 ID、课程名称、教师名字、地点",
      "除了相应的get方法之外",
      "还需要重写equals()、hashCode()和toString()方法",
      "equals()的判断依据是：只有四个属性均相同时才认为是相同的",
      "此外",
      "Course类实现了Comparable接口",
      "这是为了APP中显示课程顺序的合理性",
      "③对于Process",
      "具有的属性为：进程 ID、进程名称、最短执行时间、最长执行时间",
      "除了相应的get方法之外",
      "还需要重写equals()、hashCode()和toString()方法",
      "equals()的判断依据是：进程ID相同时认为是相同的",
      "可复用",
      "API设计",
      "计算相似度",
      "对于两个MultiIntervalSet：s1和s2",
      "遍历s1中的标签",
      "查看s2中是否存在相同的标签",
      "如果不存在",
      "则对相似度没有贡献；如果存在",
      "那么这个标签在s1和s2中各有一个时间段的集合",
      "计算这两个时间段集合的重合长度",
      "将所有的重合长度加在一起除以MultiIntervalSet的时间跨度就是两个MultiIntervalSet的相似度",
      "时间冲突比例",
      "对于IntervalSet来说",
      "由于它是一个特殊的MultiIntervalSet",
      "因此可以把它转换成MultiIntervalSet后再调用针对MultiIntervalSet的计算时间冲突比例的函数",
      "对于MultiIntervalSet",
      "维护一个冲突时间段的集合conflictTime",
      "初始时为空",
      "遍历set中的标签",
      "判断该标签和其他标签的时间段是否存在重合",
      "如果存在",
      "就将冲突的时间段加入conflictTime",
      "向conflictTime加入时间段也需要考虑重合的问题",
      "集合中不能有重合的时间段",
      "因此向conflictTime加入时间段时需要进行适当的合并",
      "最后conflictTime中的时间长度除以总的时间跨度就是时间冲突比例",
      "计算空闲时间比例",
      "对于IntervalSet来说",
      "由于它是一个特殊的MultiIntervalSet",
      "因此可以把它转换成MultiIntervalSet后再调用针对MultiIntervalSet的计算空闲时间比例的函数",
      "对于MultiIntervalSet",
      "原理类似于3.2.3中的blankIntervals()方法",
      "维护一个空闲时间段的集合freeTime，初始时为整个时间段",
      "遍历set中的所有时间段，并将其从freeTime中删去",
      "最后freeTime中的时间长度除以总的时间跨度就是空闲比例",
      "应用设计与开发",
      "利用上述设计和实现的ADT，实现手册里要求的各项功能",
      "排班管理系统",
      "使用DutyIntervalSet作为数据结构",
      "同时维护一个Employee的集合可以存储未被安排的员工",
      "刚进入时APP",
      "会提示初始化一些信息",
      "包括：排班开始日期、结束日期以及一组员工信息",
      "初始化结束后，打印一个菜单，告诉用户提供的一些功能",
      "根据用户选择的功能采取相应的操作",
      "其中选项",
      "1,2涉及对Employee集合的增删；3对应DutyIntervalSet的insert操作；4对应DutyIntervalSet的remove操作；5对应DutyIntervalSet的blankIntervals操作；7对应DutyIntervalSet的blankIntervals操作以及DutyIntervalSet的labels、start、end操作；8的操作见3.7节",
      "由于这些操作都是简单地使用一些函数，因此不再详细叙述",
      "这里只介绍“6：自动编排”的实现方法：首先调用DutyIntervalSet的blankIntervals操作得到未被安排的时间段",
      "然后遍历Employee集合",
      "找出未被安排的员工",
      "将这些未被安排的时间段和员工一对一匹配起来",
      "并调用insert方法插入到DutyIntervalSet中",
      "此外",
      "APP还拥有很好的健壮性",
      "能面对用户各种非法的、不符合格式的输入",
      "举例来说",
      "针对添加员工的操作",
      "存在各种非法的输入情况",
      "在APP中都得到了相应的解决",
      "并提示给用户",
      "操作系统的进程调度管理系统",
      "使用ProcessIntervalSet作为数据结构",
      "同时维护一个的Map存储进程和已执行时间的映射关系",
      "进入APP后，会打印一个菜单，告诉用户提供的一些功能",
      "根据用户选择的功能采取相应的操作",
      "其中选项1,2涉及对Map的增删；5",
      "6对应ProcessIntervalSet的intervals操作",
      "由于这些操作都是简单地使用一些函数，因此不再详细叙述",
      "这里介绍3,4的实现方法",
      "选项3：从时间点0开始进入一个循环",
      "当所有的进程都被执行完成后退出循环",
      "在循环中",
      "首先使用随机数（random.nextBoolean）决定是否调度进程",
      "如果决定不调度进程",
      "则闲置一段随机的时间（random.nextInt）；如果决定调度进程",
      "则随机选择一个未完成的进程（使用随机数选择进程的序号）并执行一段随机的时间（random.nextInt）",
      "执行结束后",
      "如果该进程的总执行时间已经落到最短执行时间和最长执行时间的区间内",
      "则该进程被执行完成",
      "然后从这个时间点开始进行下一轮的循环",
      "选项4：和选项3唯一的不同在于进程的选择不是随机的",
      "而是选择距离其最大执行时间差距最小的进程",
      "同样地",
      "APP拥有很好的健壮性",
      "能面对用户各种非法的、不符合格式的输入",
      "课表管理系统",
      "使用CourseIntervalSet作为数据结构",
      "同时维护一个Course的Map存储未被安排的课程以及对应的剩余学时数",
      "刚进入时APP",
      "会提示初始化一些信息",
      "包括：学期开始日期、总周数、以及一组课程信息",
      "初始化结束后，打印一个菜单，告诉用户提供的一些功能",
      "根据用户选择的功能采取相应的操作",
      "其中选项1,2涉及对Course映射的增删；3对应CourseIntervalSet的insert操作；4对应CourseIntervalSet的remove操作；5对应对Course映射的遍历以及显示；6,7对应API中操作的使用；8对应CourseIntervalSet的intervals操作",
      "由于这些操作都是简单地使用一些函数，因此不再详细叙述",
      "同样地",
      "APP拥有很好的健壮性",
      "能面对用户各种非法的、不符合格式的输入",
      "基于语法的数据读入",
      "首先对文件的格式进行分析",
      "文件总共包括三个部分",
      "分别是Employee、Period和Roster",
      "每个部分有自己独特的格式",
      "在假设没有空格、缩进和空行的情况下",
      "可以分别设计识别每个部分的正则表达式",
      "Employee部分的正则表达式：Period部分的正则表达式：Roster部分的正则表达式：对于整个文件",
      "由于三个部分出现的顺序是不定的",
      "即共有六种情况",
      "因此识别整个文件的正则表达式为：首先利用这个正则表达式判断文件的格式是否正确",
      "如果正确就抽取出每个部分",
      "利用Employee内部的格式抽取出员工信息：利用Period的格式抽取出时间段信息：利用Roster内部的格式抽取出排班信息：根据抽取出的信息",
      "就可以构造出一个排班表了",
      "在构造的同时判断一些错误",
      "如：员工信息重复、员工未定义、时间重叠等",
      "在APP中",
      "读入用户指定的文件",
      "并去除所有的空格、缩进、空行",
      "之后调用Parser解析信息",
      "在出现错误时提示给用户相应错误信息",
      "应对面临的新变化",
      "修改之前的DutyIntervalSet实现的是IntervalSet接口",
      "但是本次变化要求每个标签可以对应多个时间段",
      "因此要求DutyIntervalSet实现MulitIntervalSet接口",
      "同时还要保持不允许重叠的特征",
      "因此只需要修改DutyIntervalSet继承的装饰器类型以及实现的接口类型即可",
      "具体修改如图：修改前的代码：修改后的代码：由于DutyIntervalSet从实现IntervalSet接口变为实现MulitIntervalSet接口",
      "因此一些方法会发生变化",
      "例如不再支持start()和end()方法",
      "同时新增加了intervals()方法",
      "因此，在DutyRosterApp需要修改相应的实现方法",
      "举例来说",
      "对于APP中的可视化排班信息的功能",
      "需要遍历DutyIntervalSet中的信息",
      "之前的遍历方式直接使用labels()方法：但是",
      "修改之后需要使用intervals()方法：在其他地方也涉及这种变化",
      "就不一一列举了",
      "同时，需要修改测试代码保持测试的正确性",
      "除修改测试代码的变化",
      "一共修改大约50行代码",
      "花费时间较短",
      "说明之前的设计较为合理",
      "应对变化的能力比较强",
      "可维护性很好",
      "测试代码的修改大约也在50行左右",
      "由于使用了装饰器",
      "只需要将原来传入装饰器的MultiIntervalSet改为不能重叠的NonOverlapMultiIntervalSet即可",
      "如果不考虑测试代码的话",
      "真正修改的代码只有一行！说明之前的设计较为合理",
      "应对变化的能力比较强",
      "可维护性很好",
      "具体修改如图：修改前的代码（传入可重叠的MultiIntervalSet）：修改后的代码（传入不可重叠的NoOverlapMultiIntervalSet）：为了使得测试仍然保持正确",
      "需要修改原来的测试代码",
      "总共修改的代码量大约为50行",
      "花费时间较短",
      "Git",
      "仓库结构",
      "请在完成全部实验要求之后",
      "利用Git log指令或Git图形化客户端或GitHub上项目仓库的Insight页面",
      "给出",
      "你的仓库到目前为止的",
      "Object Graph",
      "尤其是区分清楚change分支和master分支所指向的位置",
      "使用git log指令",
      " 得到如下结果：可以看出",
      "Git仓库到目前为止的Object Graph有如下形式：实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "每次结束编程时，请向该表格中增加一行",
      "不要事后胡乱填写",
      "不要嫌烦",
      "该表格可帮助你汇总你在每个任务上付出的时间和精力",
      "发现自己不擅长的任务",
      "后续有意识的弥补",
      "时间段",
      "计划任务",
      "实际完成情况",
      "2021.6.28",
      "12:30-14:30",
      "设计IntervalSet接口并完成一个具体的实现类CommonIntervalSet",
      "编写测试",
      "2021.6.28",
      "14:30-17:00",
      "设计MultiIntervalSet接口并完成具体的实现类CommonMultiIntervalSet",
      "编写测试",
      "2021.6.28",
      "17:30-18:30",
      "设计IntervalSet和Common-MultiIntervalSet的装饰器",
      "2021.6.28",
      "18:30-19:30",
      "在有无空白的维度上",
      "设计NoBlankIntervalSet接口并完成具体实现类CommonNoBlankIntervalSet",
      "编写测试",
      "2021.6.28",
      "19:30-21:00",
      "在是否允许重叠的维度上",
      "设计实现不允许重叠的装饰类NoOverlapIntervalSet和NoOverlap-MultiIntervalSet",
      "编写测试",
      "2021.6.28",
      "21:30-22:30",
      "在周期性的维度上",
      "设计实现周期性的装饰类PeriodicIntervalSet和PeriodicMultiIntervalSet",
      "编写测试",
      "2021.6.29",
      "9:00-10:00",
      "实现Employee、Process、Course类",
      "编写测试",
      "2021.6.29",
      "10:00-12:30",
      "设计实现API，编写测试",
      "2021.6.29",
      "13:30-14:00",
      "实现DutyIntervalSet、Process-IntervalSet和CourseIntervalSet",
      "编写测试",
      "2021.6.29",
      "14:00-17:30",
      "实现DutyRosterApp",
      "测试健壮性时发现很多不足，延期一小时完成",
      "2021.6.29",
      "19:00-22:00",
      "实现CourseScheduleApp",
      "测试健壮性时发现很多不足，延期半小时完成",
      "2021.6.30",
      "9:00-12:00",
      "实现ProcessScheduleApp",
      "2021.6.30",
      "16:30-17:30",
      "学习正则表达式",
      "2021.6.30",
      "18:30-20:30",
      "设计实现解析器Parser，编写测试",
      "由于对正则表达式不太熟悉，延期半小时完成",
      "2021.6.30",
      "21:00-22:30",
      "向DutyRosterApp中加入解析文件功能",
      "2021.7.1",
      "9:00-10:00",
      "完善整个项目的注释（spec、AF、RI、safe from exposure、test strategy）",
      "2021.7.1",
      "10:30-11:30",
      "修改代码以面对新的变化",
      "实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "对装饰器不够熟悉，不知如何编写正确的装饰器以实现功能",
      "在网上查看其它应用使用装饰器的方法并加以总结",
      "逐渐熟悉装饰器的使用",
      "编写APP时遇到很多的健壮性问题",
      "仔细分析每个步骤中用户可能的所有输入",
      "针对任何非法情况都作出提示",
      "虽然很耗费时间，但效果很好",
      "不知如何设计正则表达式来抽取大量的文件信息",
      "在学习正则表达式语法的同时进行一些小的测试",
      "从小的正则表达式开始",
      "逐渐累积成复杂的正则表达式",
      "最终实现对文件的解析",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "设计ADT时一定要考虑得全面且清楚",
      "在最终决定实现方案后再编写代码",
      "否则在后面的应用实现中发现问题时只能再重新设计",
      "同时",
      "在编写APP时",
      "一定要事先考虑健壮性的问题",
      "不然",
      "在编写完代码之后进行测试时会遇到很多的健壮性问题",
      "这时再去修改就会使得代码很臃肿",
      "可读性变差",
      "出错的可能性更高",
      "针对以下方面的感受",
      "重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程",
      "你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用",
      "你是否体会到复用的好处？",
      "面向ADT的编程需要从实际中进行抽象",
      "并进行合理的设计",
      "有很好的可扩展性和可复用性；而直接面向应用场景编程只针对特定应用",
      "每次更换应用场景时都要重新编程",
      "扩展性很差",
      "只适合简单的应用场景",
      "本实验中设计一个ADT就可以应用到三个不同的场景",
      "大大缩短了开发时间",
      "重新思考Lab2中的问题：为ADT撰写复杂的specification, invariants, RI, AF",
      "时刻注意ADT是否有rep exposure",
      "这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？",
      "这些工作使得客户端了解各方法的功能但无法得知内部具体实现",
      "可以防止内部变量被客户端恶意修改",
      "时刻检查表示不变量",
      "保证安全性",
      "虽然这些工作有些麻烦",
      "但却是好的软件必须具备的",
      "因此我愿意在以后编程中坚持这么做",
      "同时",
      "在复杂的软件开发过程中",
      "好的注释可以节省大量阅读代码的时间",
      "使得开发时间大大降低",
      "之前你将别人提供的API用于自己的程序开发中",
      "本次实验你尝试着开发给别人使用的API",
      "是否能够体会到其中的难处和乐趣？",
      "由于API面向的场景是广泛的",
      "因此开发难度很大",
      "但是一旦开发一个好的API",
      "就可以在大量场合中应用",
      "大大提高代码的复用性",
      "你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令",
      "本次实验你开发了一个解析器",
      "使用语法和正则表达式去解析输入文件并据此构造对象",
      "你对语法驱动编程有何感受？",
      "语法驱动编程为实际应用提供了很大的便利",
      "用户无需繁琐地一行一行地输入信息",
      "而只需提供一个文件以及一定的语法规则即可",
      "而对于应用的开发者",
      "只需根据语法规则编写代码",
      "即使改变语法规则也可以很快地修改实现代码",
      "有很好的可维护性",
      "Lab1和Lab2的大部分工作都不是从0开始",
      "而是基于他人给出的设计方案和初始代码",
      "本次实验是你完全从0开始进行ADT的设计并用OOP实现",
      "经过五周之后",
      "你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？",
      "ADT的难度主要体现在抽象上",
      "一个好的ADT既不能过于具体，也不能过于抽象",
      "需要从大量应用场景中寻找共性，抽象的程度也很难把握",
      "对于这种情况",
      "只能反复的推敲",
      "比较不同设计方案的差异并选择最好的ADT设计方案",
      "“抽象”是计算机科学的核心概念之一",
      "也是ADT和OOP的精髓所在",
      "本实验的五个应用既不能完全抽象为同一个ADT",
      "也不是完全个性化",
      "如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、设计模式等技术完成最大程度的抽象和复用",
      "你有什么经验教训？",
      "接口、抽象类、类的抽象程度一定是逐渐降低的",
      "将所有应用的共性抽象为接口",
      "然后在抽象类以及类中添加新的特性",
      "通过接口的组合可以形成新的接口，并可以具备不同接口中的抽象",
      "类的继承也可以增加更具体的新的特性",
      "同时",
      "使用正确的设计模式可以使得代码的可复用性和可维护性最大化",
      "关于本实验的工作量、难度、deadline",
      "难度适中",
      "可以接受",
      "但是工作量很大",
      "尤其是APP的编写要花费很长时间",
      "虽然给了三周时间",
      "但是和其他课的实验、大作业、考试有重叠",
      "总体上时间还是很紧",
      "希望各课程的老师可以相互协调一下实验安排",
      "到目前为止你对《软件构造》课程的评价",
      "逐渐理解了软件构造过程中独有的思路和方法",
      "也逐渐适应了与之前完全不同的编程过程",
      "通过Lab3大量的代码训练，自己的编程水平也有了极大的提高"
    ],
    "codes": [],
    "date": "2021-07-02",
    "text": "2021年春季学期\n计算学部《软件构造》课程\nLab 3实验报告\n实验源码：\nhttps://github.com/1190200817/SC_Lab3\n1 实验目标概述··· 1\n2 实验环境配置··· 1\n3 实验过程··· 1\n3.1 待开发的三个应用场景··· 1\n3.2 面向可复用性和可维护性的设计：IntervalSet<L>· 2\n3.2.1 IntervalSet<L>的共性操作··· 2\n3.2.2 局部共性特征的设计方案··· 3\n3.2.3 面向各应用的IntervalSet子类型设计（个性化特征的设计方案）··· 4\n3.3 面向可复用性和可维护性的设计：MultiIntervalSet<L>· 7\n3.3.1 MultiIntervalSet<L>的共性操作··· 7\n3.3.2 局部共性特征的设计方案··· 7\n3.3.3 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）··· 9\n3.4 面向复用的设计：L· 11\n3.5 可复用API设计··· 13\n3.5.1 计算相似度··· 13\n3.5.2 计算时间冲突比例··· 14\n3.5.3 计算空闲时间比例··· 15\n3.6 应用设计与开发··· 15\n3.6.1 排班管理系统··· 15\n3.6.2 操作系统的进程调度管理系统··· 17\n3.6.3 课表管理系统··· 18\n3.7 基于语法的数据读入··· 18\n3.8 应对面临的新变化··· 20\n3.8.1 变化1· 20\n3.8.2 变化2· 21\n3.9 Git仓库结构··· 21\n4 实验进度记录··· 22\n5 实验过程中遇到的困难与解决途径··· 23\n6 实验过程中收获的经验、教训、感想··· 24\n6.1 实验过程中收获的经验和教训··· 24\n6.2 针对以下方面的感受··· 24\n实验目标概述\n本次实验覆盖课程第 2、3 章的内容，目标是编写具有可复用性和可维护性的软件，主要使用以下软件构造技术：\n子类型、泛型、多态、重写、重载\n继承、代理、组合\n语法驱动的编程、正则表达式\nAPI 设计、API 复用\n本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过 ADT 和泛型等抽象技术，开发一套可复用的 ADT 及其实现，充分考虑这些应用之间的相似性和差异性，使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。\n实验环境配置\nEclipse和Git在上一次实验中已经配置好了。本次实验无需额外配置环境。\n在这里给出你的GitHub Lab3仓库的URL地址（Lab3-学号）。\nhttps://github.com/ComputerScienceHIT/HIT-Lab3-1190200817\n实验过程\n请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\n待开发的三个应用场景\n简要介绍三个应用：\n①值班表管理，一个单位有 n 个员工，在某个时间段内安排值班。每天只能安排一个员工且不能出现无人值班的情况；每个员工需要安排在连续的几天内。值班表内需要记录员工的名字、职位、手机号码，以便于外界联系值班员。\n②操作系统进程调度管理，进程被调度在 CPU 上执行，操作系统决定在各个时段内执行哪个进程。操作系统可挂起某个正在执行的进程，在后续时刻可以恢复执行被挂起的进程。每个时间只能有一个进程在执行，其他进程处于休眠状态；一个进程的执行被分为多个时间段；在特定时刻，CPU 可以“闲置”；调度无规律，可看作是随机调度。\n③大学课表管理：课程需要特定的教室和特定的教师。假设各周的课表都是完全一样的，同样的课程安排将以“周”为单位进行周期性的重复，直到学期结束；一门课程每周可以出现 1 次，也可以安排多次，且由同一位教师承担并在同样的教室进行；允许课表中有空白时间段；同一个时间段内可以安排不同的课程；一位教师也可以承担课表中的多门课程。\n相同之处：都包含了具有不同特征的“时间段集合”对象。每个时间段对应一个对象标签。\n不同之处：有三个维度上的差异。①是否允许时间轴上有空白。在应用1中，不允许有空白；在应用2和应用3中，允许有空白。②是否允许不同的 interval 之间有重叠。在应用1和应用2中，不允许有重叠；在应用3中，允许有重叠。③是否包含周期性的时间段。应用 3 中以“一周”为单位重复某个课程，但应用1和应用2中不存在这种情况。\n面向可复用性和可维护性的设计：\nIntervalSet<L>\n该节是本实验的核心部分。\nIntervalSet<L>\n的共性操作\n这个ADT描述了一组在时间轴上分布的“时间段”，每个时间段附着一个特定的标签，且标签不重复。因此共性的方法包括：\n静态工厂方法empty()：创建一个空对象。\nvoid insert(long start, long end, L label)：在当前对象中插入新的时间段和标签。\nSet<L> labels()：获得当前对象中的标签集合。\nboolean remove(L label)：从当前对象中移除某个标签所关联的时间段。\nlong start (L label)：返回某个标签对应的时间段的开始时间。\nlong end (L label)：返回某个标签对应的时间段的结束时间。\nIntervalSet<L> copy()：返回这个对象的副本。\n局部共性特征的设计方案\n由于IntervalSet是一对一的结构，即一个标签对应一个时间段，因此可以使用Map作为内部的数据结构，定义为：\nprivate final Map<L, time> intervalMap = new HashMap<>();\n由于时间段是两个long型的整数构成的，因此可以定义一个辅助类time表示一个时间段。其中start是时间段的开始，end是时间段的结束，同时要求start一定大于0且start一定比end小。这里time实现了Comparable接口是为了满足下面MultiIntervalSet中的一些功能。\n对于empty()方法，直接返回一个具体实现类。\n对于insert()方法，首先判断非法条件（start<0和start>=end），然后判断Map中是否包含标签，若包含该标签，那只有在重复设置相同时间段时才合法，否则会抛出IntervalConflictException；若不包含该标签，就直接插入时间段。（注意，这里是允许不同标签之间存在Overlap的）\n对于labels()方法，直接返回Map中所有的键构成的集合即可。\n对于remove()方法，判断Map的键中是否存在该标签，若不存在，直接返回false；若存在，就在Map中删除该标签，并返回true。\n对于start()方法，判断Map的键中是否存在该标签，若不存在，直接返回-1，否则可以得到标签对应的时间段time，调用time的getStart()方法就可以得到时间段的开始时间并返回。\n对于end()方法，同上，但要调用time的getEnd()方法得到时间段的结束时间并返回。\n对于copy()方法，先新建一个空白的IntervalSet副本，然后遍历Map。将遍历得到的所有时间段和标签通过insert()方法插入到新的副本中，最后返回该副本。\n此外，还需要重写toString方法提供容易阅读的信息。\n面向各应用的\nIntervalSet子类型设计（个性化特征的设计方案）\n一、使用decorator装饰器的方法进行是否允许不同的 interval 之间有重叠以及周期性的维度的个性特征的设计。向装饰器中传入待装饰的IntervalSet，并在继承该装饰器的具体子类中实现相应的个性化功能。如下图，在装饰器IntervalSetDecorator中有属性intervalSet，是一个待装饰的IntervalSet类，而IntervalSetDecorator中的所有方法都调用intervalSet的相应方法。\n①不允许重叠的IntervalSet实现如下：\n首先NoOverlapIntervalSet继承装饰器IntervalSetDecorator，并实现IntervalSet接口。在NoOverlapIntervalSet中添加一个属性intervalMap记录添加的所有时间段。\n在重写的insert()方法中，首先判断新添加的时间段是否与已添加的时间段发生重叠，如果有，直接抛出异常；否则就调用未重写的父类的insert()方法进行插入。\n②周期性的IntervalSet实现如下：\n首先PeriodicIntervalSet继承装饰器IntervalSetDecorator，并实现IntervalSet接口。在PeriodicIntervalSet中添加一个属性period记录时间周期。\n在重写的insert()方法中，将开始时间和结束时间对周期取模后再调用未重写的父类的insert()方法进行插入。\n二、使用代理的方式进行是否允许时间轴上有空白这个维度的个性特征的设计。由于不允许空白相当于添加了新的方法，因此将这个特性抽象为一个接口NoBlankIntervalSet：\n接口中包含三个方法：blankIntervals()返回所有的空白时间段集合；getStart-Time()返回总的开始时间；getEndTime()返回总的结束时间。\n一个具体的不允许时间轴上有空白的IntervalSet只需要实现NoBlank-IntervalSet接口。具体实现类CommonNoBlankIntervalSet的实现如下：\n属性startTime是总的开始时间，endTime是总的结束时间。blankIntervals()的实现如图，首先将空白时间段设置为整个时间段，然后遍历所有的时间段，将这些时间段从空白时间段中去除，最后得到的就是所有的空白时间段。\n面向可复用性和可维护性的设计：\nMultiIntervalSet<L>\nMultiIntervalSet<L>\n的共性操作\n静态工厂方法empty()：创建一个空对象。\nMultiIntervalSet(IntervalSet<L> initial)：利用initial中包含的数据创建非空对象。\nvoid insert(long start, long end, L label)：在当前对象中插入新的时间段和标签。\nSet<L> labels()：获得当前对象中的标签集合。\nboolean remove(L label)：从当前对象中移除某个标签所关联的所有时间段。\nIntervalSet<Integer> intervals(L label)：从当前对象中获取与某个标签所关联的所有时间段。\n局部共性特征的设计方案\n由于要求必须使用 IntervalSet<L>作为其 rep 的一部分，因此选择IntervalSet<L>组成的List作为rep。一个IntervalSet中只存储某个标签对应的一个时间段，如果一个标签对应多个时间段，需要分散在不同的IntervalSet中。\n对于empty()方法，直接返回一个具体实现类。\n对于initial初始化方法，直接将传入的IntervalSet的副本作为rep的一个元素。\n对于insert()方法，首先判断非法情况。之后遍历IntervalSet列表得到标签对应的所有时间段，判断已存在的时间段和要增加的时间段是否存在重叠，如果重叠则抛出异常；若不重叠，就寻找某个不存在该标签的IntervalSet，将这个时间段插入该IntervalSet，如果列表中所有的IntervalSet都包含该标签，就需要新建一个空白的IntervaSet加入列表，再进行插入。\n对于labels()方法，可以直接返回第一个IntervalSet中的所有标签组成的集合。（因为插入时都是从头开始遍历的，因此不会存在某个标签出现在后面的IntervalSet而不在第一个IntervalSet中的情况）\n对于remove()方法，直接对每个IntervalSet调用remove()方法即可。\n对于intervals()方法，遍历IntervalSet列表得到标签对应的所有时间段，将时间段从小到大进行排序（前面time的实现中进行了说明）。然后将每个时间段以它的顺序作为标签插入到一个IntervalSet中并返回。\n此外，还需要重写toString方法提供容易阅读的信息。\n面向各应用的\nMultiIntervalSet子类型设计（个性化特征的设计方案）\n与3.2.3同理，使用decorator装饰器的方法进行是否允许不同的interval之间有重叠以及周期性的维度的个性特征的设计。向装饰器中传入待装饰的MultiIntervalSet，并在继承该装饰器的具体子类中实现相应的个性化功能。如下图，在装饰器MultiIntervalSetDecorator中有属性multiIntervalSet，是一个待装饰的MultiIntervalSet类，而MultiIntervalSetDecorator中的所有方法都调用multiIntervalSet的相应方法。\n①不允许重叠的MultiIntervalSet实现如下：\n首先NoOverlapMultiIntervalSet继承装饰器MultiIntervalSetDecorator，并实现MultiIntervalSet接口。\n在重写的insert()方法中，首先判断新添加的时间段是否与已添加的时间段发生重叠，如果有，直接抛出异常；否则就调用未重写的父类的insert()方法进行插入。\n②周期性的MultiIntervalSet实现如下：\n首先PeriodicMultiIntervalSet继承装饰器MultiIntervalSetDecorator，并实现MultiIntervalSet接口。在PeriodicMultiIntervalSet中添加一个属性period记录时间周期。\n在重写的insert()方法中，将开始时间和结束时间对周期取模后再调用未重写的父类的insert()方法进行插入。\n面向复用的设计：\n设计三个应用的不同标签，分别为“员工”（Employee）、“进程”（Process）、\n“课程”（Course）。并且它们都是immutable类。\n①对于Employee，具有的属性为：姓名、职务、手机号码。\n除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：只有三个属性均相同时才认为是相同的。\n②对于\nCourse，具有的属性为：课程 ID、课程名称、教师名字、地点。\n除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：只有四个属性均相同时才认为是相同的。\n此外，Course类实现了Comparable接口，这是为了APP中显示课程顺序的合理性。\n③对于Process，具有的属性为：进程 ID、进程名称、最短执行时间、最长执行时间。\n除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：进程ID相同时认为是相同的。\n可复用\nAPI设计\n计算相似度\n对于两个MultiIntervalSet：s1和s2，遍历s1中的标签，查看s2中是否存在相同的标签，如果不存在，则对相似度没有贡献；如果存在，那么这个标签在s1和s2中各有一个时间段的集合，计算这两个时间段集合的重合长度，将所有的重合长度加在一起除以MultiIntervalSet的时间跨度就是两个MultiIntervalSet的相似度。\n时间冲突比例\n对于IntervalSet来说，由于它是一个特殊的MultiIntervalSet，因此可以把它转换成MultiIntervalSet后再调用针对MultiIntervalSet的计算时间冲突比例的函数。\n对于MultiIntervalSet，维护一个冲突时间段的集合conflictTime，初始时为空。遍历set中的标签，判断该标签和其他标签的时间段是否存在重合，如果存在，就将冲突的时间段加入conflictTime。向conflictTime加入时间段也需要考虑重合的问题，集合中不能有重合的时间段，因此向conflictTime加入时间段时需要进行适当的合并。最后conflictTime中的时间长度除以总的时间跨度就是时间冲突比例。\n计算空闲时间比例\n对于IntervalSet来说，由于它是一个特殊的MultiIntervalSet，因此可以把它转换成MultiIntervalSet后再调用针对MultiIntervalSet的计算空闲时间比例的函数。\n对于MultiIntervalSet，原理类似于3.2.3中的blankIntervals()方法。维护一个空闲时间段的集合freeTime，初始时为整个时间段。遍历set中的所有时间段，并将其从freeTime中删去。最后freeTime中的时间长度除以总的时间跨度就是空闲比例。\n应用设计与开发\n利用上述设计和实现的ADT，实现手册里要求的各项功能。\n排班管理系统\n使用DutyIntervalSet作为数据结构，同时维护一个Employee的集合可以存储未被安排的员工。刚进入时APP，会提示初始化一些信息，包括：排班开始日期、结束日期以及一组员工信息。初始化结束后，打印一个菜单，告诉用户提供的一些功能。\n根据用户选择的功能采取相应的操作。其中选项\n1,2涉及对Employee集合的增删；3对应DutyIntervalSet的insert操作；4对应DutyIntervalSet的remove操作；5对应DutyIntervalSet的blankIntervals操作；7对应DutyIntervalSet的blankIntervals操作以及DutyIntervalSet的labels、start、end操作；8的操作见3.7节。由于这些操作都是简单地使用一些函数，因此不再详细叙述。这里只介绍“6：自动编排”的实现方法：首先调用DutyIntervalSet的blankIntervals操作得到未被安排的时间段，然后遍历Employee集合，找出未被安排的员工，将这些未被安排的时间段和员工一对一匹配起来，并调用insert方法插入到DutyIntervalSet中。\n此外，APP还拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。举例来说，针对添加员工的操作，存在各种非法的输入情况，在APP中都得到了相应的解决，并提示给用户。\n操作系统的进程调度管理系统\n使用ProcessIntervalSet作为数据结构，同时维护一个的Map存储进程和已执行时间的映射关系。进入APP后，会打印一个菜单，告诉用户提供的一些功能。\n根据用户选择的功能采取相应的操作。其中选项1,2涉及对Map的增删；5，6对应ProcessIntervalSet的intervals操作。由于这些操作都是简单地使用一些函数，因此不再详细叙述。这里介绍3,4的实现方法，选项3：从时间点0开始进入一个循环，当所有的进程都被执行完成后退出循环。在循环中，首先使用随机数（random.nextBoolean）决定是否调度进程，如果决定不调度进程，则闲置一段随机的时间（random.nextInt）；如果决定调度进程，则随机选择一个未完成的进程（使用随机数选择进程的序号）并执行一段随机的时间（random.nextInt），执行结束后，如果该进程的总执行时间已经落到最短执行时间和最长执行时间的区间内，则该进程被执行完成，然后从这个时间点开始进行下一轮的循环。选项4：和选项3唯一的不同在于进程的选择不是随机的，而是选择距离其最大执行时间差距最小的进程。\n同样地，APP拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。\n课表管理系统\n使用CourseIntervalSet作为数据结构，同时维护一个Course的Map存储未被安排的课程以及对应的剩余学时数。刚进入时APP，会提示初始化一些信息，包括：学期开始日期、总周数、以及一组课程信息。初始化结束后，打印一个菜单，告诉用户提供的一些功能。\n根据用户选择的功能采取相应的操作。其中选项1,2涉及对Course映射的增删；3对应CourseIntervalSet的insert操作；4对应CourseIntervalSet的remove操作；5对应对Course映射的遍历以及显示；6,7对应API中操作的使用；8对应CourseIntervalSet的intervals操作。由于这些操作都是简单地使用一些函数，因此不再详细叙述。\n同样地，APP拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。\n基于语法的数据读入\n首先对文件的格式进行分析，文件总共包括三个部分，分别是Employee、Period和Roster，每个部分有自己独特的格式。在假设没有空格、缩进和空行的情况下，可以分别设计识别每个部分的正则表达式。\nEmployee部分的正则表达式：\nPeriod部分的正则表达式：\nRoster部分的正则表达式：\n对于整个文件，由于三个部分出现的顺序是不定的，即共有六种情况，因此识别整个文件的正则表达式为：\n首先利用这个正则表达式判断文件的格式是否正确，如果正确就抽取出每个部分。\n利用Employee内部的格式抽取出员工信息：\n利用Period的格式抽取出时间段信息：\n利用Roster内部的格式抽取出排班信息：\n根据抽取出的信息，就可以构造出一个排班表了，在构造的同时判断一些错误，如：员工信息重复、员工未定义、时间重叠等。\n在APP中，读入用户指定的文件，并去除所有的空格、缩进、空行，之后调用Parser解析信息，在出现错误时提示给用户相应错误信息。\n应对面临的新变化\n修改之前的DutyIntervalSet实现的是IntervalSet接口，但是本次变化要求每个标签可以对应多个时间段，因此要求DutyIntervalSet实现MulitIntervalSet接口，同时还要保持不允许重叠的特征。因此只需要修改DutyIntervalSet继承的装饰器类型以及实现的接口类型即可。具体修改如图：\n修改前的代码：\n修改后的代码：\n由于DutyIntervalSet从实现IntervalSet接口变为实现MulitIntervalSet接口，因此一些方法会发生变化，例如不再支持start()和end()方法，同时新增加了intervals()方法。因此，在DutyRosterApp需要修改相应的实现方法。举例来说，对于APP中的可视化排班信息的功能，需要遍历DutyIntervalSet中的信息，之前的遍历方式直接使用labels()方法：\n但是，修改之后需要使用intervals()方法：\n在其他地方也涉及这种变化，就不一一列举了。同时，需要修改测试代码保持测试的正确性。\n除修改测试代码的变化，一共修改大约50行代码，花费时间较短，说明之前的设计较为合理，应对变化的能力比较强，可维护性很好。测试代码的修改大约也在50行左右。\n由于使用了装饰器，只需要将原来传入装饰器的MultiIntervalSet改为不能重叠的NonOverlapMultiIntervalSet即可。如果不考虑测试代码的话，真正修改的代码只有一行！说明之前的设计较为合理，应对变化的能力比较强，可维护性很好。具体修改如图：\n修改前的代码（传入可重叠的MultiIntervalSet）：\n修改后的代码（传入不可重叠的NoOverlapMultiIntervalSet）：\n为了使得测试仍然保持正确，需要修改原来的测试代码，总共修改的代码量大约为50行，花费时间较短。\nGit\n仓库结构\n请在完成全部实验要求之后，利用Git log指令或Git图形化客户端或GitHub上项目仓库的Insight页面，给出\n你的仓库到目前为止的\nObject Graph，尤其是区分清楚change分支和master分支所指向的位置。\n使用git log指令， 得到如下结果：\n可以看出，Git仓库到目前为止的Object Graph有如下形式：\n实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。\n不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。\n时间段\n计划任务\n实际完成情况\n2021.6.28\n12:30-14:30\n设计IntervalSet接口并完成一个具体的实现类CommonIntervalSet，编写测试\n2021.6.28\n14:30-17:00\n设计MultiIntervalSet接口并完成具体的实现类CommonMultiIntervalSet，编写测试\n2021.6.28\n17:30-18:30\n设计IntervalSet和Common-MultiIntervalSet的装饰器\n2021.6.28\n18:30-19:30\n在有无空白的维度上，设计NoBlankIntervalSet接口并完成具体实现类CommonNoBlankIntervalSet，编写测试\n2021.6.28\n19:30-21:00\n在是否允许重叠的维度上，设计实现不允许重叠的装饰类NoOverlapIntervalSet和NoOverlap-MultiIntervalSet，编写测试\n2021.6.28\n21:30-22:30\n在周期性的维度上，设计实现周期性的装饰类PeriodicIntervalSet和PeriodicMultiIntervalSet，编写测试\n2021.6.29\n9:00-10:00\n实现Employee、Process、Course类，编写测试\n2021.6.29\n10:00-12:30\n设计实现API，编写测试\n2021.6.29\n13:30-14:00\n实现DutyIntervalSet、Process-IntervalSet和CourseIntervalSet，编写测试\n2021.6.29\n14:00-17:30\n实现DutyRosterApp\n测试健壮性时发现很多不足，延期一小时完成\n2021.6.29\n19:00-22:00\n实现CourseScheduleApp\n测试健壮性时发现很多不足，延期半小时完成\n2021.6.30\n9:00-12:00\n实现ProcessScheduleApp\n2021.6.30\n16:30-17:30\n学习正则表达式\n2021.6.30\n18:30-20:30\n设计实现解析器Parser，编写测试\n由于对正则表达式不太熟悉，延期半小时完成\n2021.6.30\n21:00-22:30\n向DutyRosterApp中加入解析文件功能\n2021.7.1\n9:00-10:00\n完善整个项目的注释（spec、AF、RI、safe from exposure、test strategy）\n2021.7.1\n10:30-11:30\n修改代码以面对新的变化\n实验过程中遇到的困难与解决途径\n遇到的难点\n解决途径\n对装饰器不够熟悉，不知如何编写正确的装饰器以实现功能。\n在网上查看其它应用使用装饰器的方法并加以总结，逐渐熟悉装饰器的使用。\n编写APP时遇到很多的健壮性问题。\n仔细分析每个步骤中用户可能的所有输入，针对任何非法情况都作出提示。虽然很耗费时间，但效果很好。\n不知如何设计正则表达式来抽取大量的文件信息。\n在学习正则表达式语法的同时进行一些小的测试，从小的正则表达式开始，逐渐累积成复杂的正则表达式，最终实现对文件的解析。\n实验过程中收获的经验、教训、感想\n实验过程中收获的经验和教训\n设计ADT时一定要考虑得全面且清楚，在最终决定实现方案后再编写代码，否则在后面的应用实现中发现问题时只能再重新设计。同时，在编写APP时，一定要事先考虑健壮性的问题，不然，在编写完代码之后进行测试时会遇到很多的健壮性问题，这时再去修改就会使得代码很臃肿，可读性变差，出错的可能性更高。\n针对以下方面的感受\n重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用，你是否体会到复用的好处？\n面向ADT的编程需要从实际中进行抽象，并进行合理的设计，有很好的可扩展性和可复用性；而直接面向应用场景编程只针对特定应用，每次更换应用场景时都要重新编程，扩展性很差，只适合简单的应用场景。本实验中设计一个ADT就可以应用到三个不同的场景，大大缩短了开发时间。\n重新思考Lab2中的问题：为ADT撰写复杂的specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？\n这些工作使得客户端了解各方法的功能但无法得知内部具体实现，可以防止内部变量被客户端恶意修改，时刻检查表示不变量，保证安全性。虽然这些工作有些麻烦，但却是好的软件必须具备的，因此我愿意在以后编程中坚持这么做。同时，在复杂的软件开发过程中，好的注释可以节省大量阅读代码的时间，使得开发时间大大降低。\n之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？\n由于API面向的场景是广泛的，因此开发难度很大，但是一旦开发一个好的API，就可以在大量场合中应用，大大提高代码的复用性。\n你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？\n语法驱动编程为实际应用提供了很大的便利，用户无需繁琐地一行一行地输入信息，而只需提供一个文件以及一定的语法规则即可。而对于应用的开发者，只需根据语法规则编写代码，即使改变语法规则也可以很快地修改实现代码，有很好的可维护性。\nLab1和Lab2的大部分工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过五周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？\nADT的难度主要体现在抽象上。一个好的ADT既不能过于具体，也不能过于抽象。需要从大量应用场景中寻找共性，抽象的程度也很难把握。对于这种情况，只能反复的推敲，比较不同设计方案的差异并选择最好的ADT设计方案。\n“抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的五个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？\n接口、抽象类、类的抽象程度一定是逐渐降低的，将所有应用的共性抽象为接口，然后在抽象类以及类中添加新的特性。通过接口的组合可以形成新的接口，并可以具备不同接口中的抽象。类的继承也可以增加更具体的新的特性。同时，使用正确的设计模式可以使得代码的可复用性和可维护性最大化。\n关于本实验的工作量、难度、deadline。\n难度适中，可以接受，但是工作量很大，尤其是APP的编写要花费很长时间。虽然给了三周时间，但是和其他课的实验、大作业、考试有重叠，总体上时间还是很紧。希望各课程的老师可以相互协调一下实验安排。\n到目前为止你对《软件构造》课程的评价。\n逐渐理解了软件构造过程中独有的思路和方法，也逐渐适应了与之前完全不同的编程过程。通过Lab3大量的代码训练，自己的编程水平也有了极大的提高。\n"
  },
  {
    "head": "Java泛型的类型擦除",
    "paragraphs": [
      "为什么Java的泛型要使用类型擦除？",
      "从技术来说，Java完全可以不使用类型擦除而直接实现”真泛型”。然而，Java诞生的时候，是没有包括泛型的，10年之后，Java才想实现类似于C++模板的概念，即泛型。由于Java类库是非常宝贵的资源，因此必须保证向后兼容。如果要实现“真泛型”，不仅需要修改 JVM 的源代码，让 JVM 能正确读取和校验泛型信息；而且为了兼容，需要为原本不支持泛型的 API 都添加相应的泛型 API。这样的修改工作量是无法想象的。因此Java设计者采取了 “类型擦除” 这种机制作为折中的实现方式。",
      "什么是类型擦除？",
      "在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉，这个过程就称为类型擦除。",
      "我们以一个例子来验证Java的类型擦除机制。对于下面的代码，最后输出的结果为true。",
      "我们定义的两个列表，一个是",
      "String",
      "泛型，一个是",
      "Integer",
      "泛型，但是它们的",
      "getClass()",
      "方法得到的类信息居然是一样的。这说明泛型类型",
      "String",
      "Integer",
      "在运行之前就被擦除掉了，在运行时无法知道定义时的具体类型。",
      "在类型擦除后的实际类型是什么呢？根据上面所说的向后兼容，擦除后的实际类型应该能被之前没有泛型时的Java程序接受。因此Java将具体的类型擦除为原始类型。原始类型就是擦除泛型信息，最后在字节码中的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供。类型变量擦除时，使用其限定类型替换（无限定时用Object替换）。",
      "举例来说，如果我们定义下面这样一个带泛型的类：",
      "那类型擦除后，它的实际定义应该类似于：",
      "所有的泛型T都被替换为Object。",
      "类型擦除带来的问题",
      "1.运行时的类型检测问题：由于类型变量会在运行前被擦除掉，那如何检测到向ArrayList<String>中添加非String类型的对象这种类型错误呢？",
      "解决方法：利用编译器进行静态检查。编译器会先检查代码中的泛型类型，如果存在类型不匹配，会直接报错，只有在类型匹配时才能进行后续的类型擦除。比如：",
      "2.返回泛型类型的函数怎么办？所有的泛型类型都会被替换为原始类型，那返回泛型类型的函数实际上返回的是原始类型的对象，难道还需要手动的类型转化吗？",
      "解决方法：自动生成类型转换。",
      "ArrayList",
      "的get方法源代码如下：",
      "return",
      "之前，会根据泛型的类型进行强转。即使泛型信息会被擦除，但是会将",
      "(E) elementData[index]",
      "编译为",
      "(Date) elementData[index]",
      "。因此不需要自己手动进行强转，在类型擦除时会自动地在结果字节码中插入强制类型转换。",
      "3.不能使用泛型数组。如果我们假设在 Java 中可以创建泛型数组，那么看如下代码：",
      "Java的类型系统规定，子类数组是父类数组的子类，因此Object[] o = s;是正确的。如果我们假设可以创建泛型数组，那上述代码没有任何问题。但是最后一行代码将 List<Integer> 类型的对象赋给了List<String>类型的数组，这个问题在编译时无法发现，只能在运行时出现问题。然而，类型擦除机制要求编译器能够检测所有类型不匹配的问题。因此Java中禁止创建泛型数组，这样编译器就可以检测所有的类型不匹配问题。"
    ],
    "sentences": [
      "为什么Java的泛型要使用类型擦除？",
      "从技术来说",
      "Java完全可以不使用类型擦除而直接实现”真泛型”",
      "然而",
      "Java诞生的时候",
      "是没有包括泛型的",
      "10年之后",
      "Java才想实现类似于C++模板的概念",
      "即泛型",
      "由于Java类库是非常宝贵的资源，因此必须保证向后兼容",
      "如果要实现“真泛型”",
      "不仅需要修改 JVM 的源代码",
      "让 JVM 能正确读取和校验泛型信息；而且为了兼容",
      "需要为原本不支持泛型的 API 都添加相应的泛型 API",
      "这样的修改工作量是无法想象的",
      "因此Java设计者采取了 “类型擦除” 这种机制作为折中的实现方式",
      "什么是类型擦除？",
      "在生成的Java字节代码中是不包含泛型中的类型信息的",
      "使用泛型的时候加上的类型参数",
      "会被编译器在编译的时候去掉",
      "这个过程就称为类型擦除",
      "我们以一个例子来验证Java的类型擦除机制",
      "对于下面的代码，最后输出的结果为true",
      "我们定义的两个列表，一个是",
      "String",
      "泛型，一个是",
      "Integer",
      "泛型，但是它们的",
      "getClass()",
      "方法得到的类信息居然是一样的",
      "这说明泛型类型",
      "String",
      "Integer",
      "在运行之前就被擦除掉了，在运行时无法知道定义时的具体类型",
      "在类型擦除后的实际类型是什么呢？根据上面所说的向后兼容",
      "擦除后的实际类型应该能被之前没有泛型时的Java程序接受",
      "因此Java将具体的类型擦除为原始类型",
      "原始类型就是擦除泛型信息",
      "最后在字节码中的真正类型",
      "无论何时定义一个泛型",
      "相应的原始类型都会被自动提供",
      "类型变量擦除时",
      "使用其限定类型替换（无限定时用Object替换）",
      "举例来说",
      "如果我们定义下面这样一个带泛型的类：那类型擦除后",
      "它的实际定义应该类似于：所有的泛型T都被替换为Object",
      "类型擦除带来的问题",
      "1.运行时的类型检测问题：由于类型变量会在运行前被擦除掉",
      "那如何检测到向ArrayList<String>中添加非String类型的对象这种类型错误呢？",
      "解决方法：利用编译器进行静态检查",
      "编译器会先检查代码中的泛型类型",
      "如果存在类型不匹配",
      "会直接报错",
      "只有在类型匹配时才能进行后续的类型擦除",
      "比如：2.返回泛型类型的函数怎么办？所有的泛型类型都会被替换为原始类型",
      "那返回泛型类型的函数实际上返回的是原始类型的对象",
      "难道还需要手动的类型转化吗？",
      "解决方法：自动生成类型转换",
      "ArrayList",
      "的get方法源代码如下：return",
      "之前，会根据泛型的类型进行强转",
      "即使泛型信息会被擦除，但是会将",
      "(E) elementData[index]",
      "编译为",
      "(Date) elementData[index]",
      "因此不需要自己手动进行强转",
      "在类型擦除时会自动地在结果字节码中插入强制类型转换",
      "3.不能使用泛型数组",
      "如果我们假设在 Java 中可以创建泛型数组",
      "那么看如下代码：Java的类型系统规定",
      "子类数组是父类数组的子类",
      "因此Object[] o = s;是正确的",
      "如果我们假设可以创建泛型数组，那上述代码没有任何问题",
      "但是最后一行代码将 List<Integer> 类型的对象赋给了List<String>类型的数组",
      "这个问题在编译时无法发现",
      "只能在运行时出现问题",
      "然而，类型擦除机制要求编译器能够检测所有类型不匹配的问题",
      "因此Java中禁止创建泛型数组",
      "这样编译器就可以检测所有的类型不匹配问题"
    ],
    "codes": [
      "ArrayList<Integer> intergerList = new ArrayList<Integer>();\nArrayList<String> stringList = new ArrayList<String>(); \n\nSystem.out.println(intergerList.getClass() == stringList.getClass()); // true\n    ",
      "public class Node<T> {\n    private T data;\n    private Node<T> next;\n    public Node(T data, Node<T> next) {    \n        this.data = data;\n        this.next = next;\n    }\n    public T getData() {\n        return data; \n    }\n    // ...\n}\n",
      "public class Node {\n    private Object data;\n    private Node next;\n    public Node(Object data, Node next) {\n        this.data = data;\n        this.next = next;\n    }\n    public Object getData() { \n        return data; \n    }\n    // ...\n}",
      "List<Integer> myInts = new ArrayList<Integer>();\nmyInts.add(1);\nmyInts.add(2);\nList<Number> myNums = myInts;   // compiler error\nmyNums.add(3.14);",
      "static long sum(List<Number> numbers) {\n    long summation = 0;\n    for(Number number : numbers) {\n        summation += number.longValue();\n    }\n    return summation;\n}\n\nList<Integer> myInts = Arrays.asList(1,2,3,4,5);\nList<Long> myLongs = Arrays.asList(1L, 2L, 3L, 4L, 5L);\nList<Double> myDoubles = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\nsum(myInts); \nsum(myLongs);   // compiler error\nsum(myDoubles);\n",
      "public E get(int index) {  \n    RangeCheck(index);  \n    return (E) elementData[index];  \n}\n",
      "List<String>[] s = new ArrayList<String>[1];\nList<Integer> i = Arrays.asList(1);\nObject[] o = s;\no[0] = i"
    ],
    "date": "2021-07-05",
    "text": "为什么Java的泛型要使用类型擦除？\n从技术来说，Java完全可以不使用类型擦除而直接实现”真泛型”。然而，Java诞生的时候，是没有包括泛型的，10年之后，Java才想实现类似于C++模板的概念，即泛型。由于Java类库是非常宝贵的资源，因此必须保证向后兼容。如果要实现“真泛型”，不仅需要修改 JVM 的源代码，让 JVM 能正确读取和校验泛型信息；而且为了兼容，需要为原本不支持泛型的 API 都添加相应的泛型 API。这样的修改工作量是无法想象的。因此Java设计者采取了 “类型擦除” 这种机制作为折中的实现方式。\n什么是类型擦除？\n在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉，这个过程就称为类型擦除。\n我们以一个例子来验证Java的类型擦除机制。对于下面的代码，最后输出的结果为true。\n我们定义的两个列表，一个是\nString\n泛型，一个是\nInteger\n泛型，但是它们的\ngetClass()\n方法得到的类信息居然是一样的。这说明泛型类型\nString\nInteger\n在运行之前就被擦除掉了，在运行时无法知道定义时的具体类型。\n在类型擦除后的实际类型是什么呢？根据上面所说的向后兼容，擦除后的实际类型应该能被之前没有泛型时的Java程序接受。因此Java将具体的类型擦除为原始类型。原始类型就是擦除泛型信息，最后在字节码中的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供。类型变量擦除时，使用其限定类型替换（无限定时用Object替换）。\n举例来说，如果我们定义下面这样一个带泛型的类：\n那类型擦除后，它的实际定义应该类似于：\n所有的泛型T都被替换为Object。\n类型擦除带来的问题\n1.运行时的类型检测问题：由于类型变量会在运行前被擦除掉，那如何检测到向ArrayList<String>中添加非String类型的对象这种类型错误呢？\n解决方法：利用编译器进行静态检查。编译器会先检查代码中的泛型类型，如果存在类型不匹配，会直接报错，只有在类型匹配时才能进行后续的类型擦除。比如：\n2.返回泛型类型的函数怎么办？所有的泛型类型都会被替换为原始类型，那返回泛型类型的函数实际上返回的是原始类型的对象，难道还需要手动的类型转化吗？\n解决方法：自动生成类型转换。\nArrayList\n的get方法源代码如下：\nreturn\n之前，会根据泛型的类型进行强转。即使泛型信息会被擦除，但是会将\n(E) elementData[index]\n编译为\n(Date) elementData[index]\n。因此不需要自己手动进行强转，在类型擦除时会自动地在结果字节码中插入强制类型转换。\n3.不能使用泛型数组。如果我们假设在 Java 中可以创建泛型数组，那么看如下代码：\nJava的类型系统规定，子类数组是父类数组的子类，因此Object[] o = s;是正确的。如果我们假设可以创建泛型数组，那上述代码没有任何问题。但是最后一行代码将 List<Integer> 类型的对象赋给了List<String>类型的数组，这个问题在编译时无法发现，只能在运行时出现问题。然而，类型擦除机制要求编译器能够检测所有类型不匹配的问题。因此Java中禁止创建泛型数组，这样编译器就可以检测所有的类型不匹配问题。\n"
  },
  {
    "head": "哈工大软件构造Lab1",
    "paragraphs": [
      "Lab 1实验报告",
      "1 实验目标概述... 1",
      "2 实验环境配置... 1",
      "3 实验过程... 2",
      "3.1 Magic Squares. 2",
      "3.1.1 isLegalMagicSquare(). 2",
      "3.1.2 generateMagicSquare(). 3",
      "3.2 Turtle Graphics. 5",
      "3.2.1 Problem 1: Clone and import 5",
      "3.2.2 Problem 3: Turtle graphics and drawSquare. 5",
      "3.2.3 Problem 5: Drawing polygons. 6",
      "3.2.4 Problem 6: Calculating Bearings. 7",
      "3.2.5 Problem 7: Convex Hulls. 8",
      "3.2.6 Problem 8: Personal art 9",
      "3.2.7 Submitting. 10",
      "3.3 Social Network. 10",
      "3.3.1 设计/实现FriendshipGraph类... 10",
      "3.3.2 设计/实现Person类... 12",
      "3.3.3 设计/实现客户端代码main(). 13",
      "3.3.4 设计/实现测试用例... 13",
      "4 实验进度记录... 15",
      "5 实验过程中遇到的困难与解决途径... 16",
      "6 实验过程中收获的经验、教训、感想... 16",
      "6.1 实验过程中收获的经验和教训... 16",
      "6.2 针对以下方面的感受... 16",
      "实验目标概述",
      "本次实验通过求解三个问题，训练基本Java编程技能，能够利用Java OO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用 Git 作为代码配置管理的工具，学会 Git 的基本使用方法。",
      "⚫ 基本的 Java OO 编程",
      "⚫ 基于 Eclipse IDE 进行 Java 编程",
      "⚫ 基于 JUnit 的测试",
      "⚫ 基于 Git 的代码配置管理。",
      "实验环境配置",
      "在官网下载安装JDK，根据网上的步骤配置环境变量。",
      "在官网下载安装Eclipse，设置JRE以及其他preferences。新建一个Workspace，建立项目、包以及java源代码，Eclipse配置成功的结果如图。",
      "在官网下载Git并安装，设置用户名、邮箱等信息，Git配置成功的结果如图。",
      "GitHub Lab1仓库的URL地址：https://github.com/ComputerScienceHIT/HIT-Lab1-1190200817。",
      "实验过程",
      "请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。",
      "为了条理清晰，可根据需要在各节增加三级标题。",
      "Magic Squares",
      "主要任务：从txt文件中解析数据，并判断数据是否构成一个幻方，通过5个文件进行测试。同时阅读和改进产生幻方的代码，并进行测试。",
      "isLegalMagicSquare()",
      "首先，需要从txt文件中读出数据，读txt文件可以使用固定的格式，即使用BufferedReader并用try-resource语句处理异常。",
      "利用BufferedReader，每次可以从文件中读入一行字符串。由于txt文件以’\\t’分隔数据的，用String类的split方法可以将读入的字符串以’\\t’分隔，得到字符串数组，每个字符串数组都代表一个数。使用Integer.valueOf将分隔后的每个字符串解析为数字，同时需要捕获异常识别非法数据。",
      "所有数据都存在二维ArrayList中，获得每一行数据的个数以及总行数，判断是否为n*n的矩阵。分别计算每行、每列以及两个对角线上的数字之和，比较是否相等，并返回结果。如果出现各种特殊情况，输出错误提示信息并返回。",
      "generateMagicSquare()",
      "阅读generateMagicSquare()的代码，可以看出它是将1到",
      "填充到一个",
      "n*n",
      "的幻方中，这种方法是常用的填充幻方的方法。程序的流程图如下：",
      "但是，这种方法只能填充",
      "为奇数时的幻方。当",
      "为偶数时，函数产生异常java.lang.ArrayIndexOutOfBoundsException即填充过程中在row++时发生数组越界访问。并且当",
      "是负数时，不能有效处理非法输入，产生异常java.lang.NegativeArraySizeException即初始化了行列数为负数的数组。这导致了很差的健壮性。修改这个函数，当输入不合法时提示错误并退出。",
      "同时，当输入合法时，增加将结果写入文件的功能。和之前类似，使用BufferedWriter将数据写入文件。",
      "利用前面的 isLegalMagicSquare()函数，可以判断生成的文本文件确实符合 Magic Square。",
      "Turtle Graphics",
      "主要任务：根据函数的注释补全代码，实现一系列绘图可能用到的功能。包括画出正方形、计算正多边形的内角、计算对应内角的正多边形边数、计算绘图时的角度转移、计算凸包、以及绘制自己独特的图形。",
      "Problem 1: Clone and import",
      "使用git init初始化一个本地仓库，通过git clone将GitHub上的文件下载到这个仓库中。这时就可以利用IDE进行代码编写。每当认为某一个代码改进完成，可以让它成为一个新的版本时，利用git add添加相应代码，使用git commit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过git push origin master将本地仓库push到GitHub上。",
      "Problem 3: Turtle graphics and",
      "drawSquare",
      "绘制图形时要用到两个函数：forward和turn，分别实现前进和转向。绘制正方形时，只需要每次前进给定长度，然后转向90°，循环四次即可。",
      "代码：",
      "结果：",
      "Problem 5: Drawing polygons",
      "对于给定边数的正多边形，需要计算内角的度数来确定每次转向的度数。实现calculateRegularPolygonAngle()函数确定给定边数的正多边形的内角度数。直接通过公式可求出。",
      "和上面一样，每次前进给定长度，转向的角度为外角的度数，循环次数为边数。",
      "代码：",
      "结果（以正六边形为例）：",
      "最后还要实现给定内角度数，确定正多边形边数的函数。直接通过公式可求出。注意最后要将结果四舍五入才能返回整数。",
      "Problem 6: Calculating Bearings",
      "实现函数calculateBearingToPoint()以满足已知起点、终点和当前朝向时，应该转向的角度。计算起点和终点所连直线的斜率，利用atan函数得到最终的朝向的角度，它和当前朝向的差值就是需要转过的角度。",
      "通过调用calculateBearingToPoint()函数就可以计算经过一系列点时每次要转向的角度，进而实现calculateBearings()。已知初始朝向，按顺序在列表中取出两个点，调用calculateBearingToPoint()就可以得到这两个点之间需要转过的角。修改当前朝向为转向之后的角度，就可以进行下一次计算。需要注意，更新当前朝向后，如果角度超过360°，需要减去360°。",
      "Problem 7: Convex Hulls",
      "使用安德鲁算法求解凸包。首先判断特殊情况，如果顶点数小于等于2时，这些点都会是凸包中的，直接返回原点集。找到所有点中横坐标最大的点，有多个则选择纵坐标最小的点，把它作为基准点，这个点一定在凸包中。其他的点和这个点的连线与y轴正半轴存在夹角，按照夹角从小到大对其他顶点排序。维护一个栈，首先将基准点入栈。按顺序从排好序的顶点中取出一个，如果栈中的点数大于2，就取出栈顶的两个点。通过计算向量的内积判断栈顶的点是否应该在凸包中，如果不在，将栈顶的点弹出，继续判断；如果在，将取出的顶点入栈。如果栈中的点数小于2，直接将取出的顶点入栈。最后，栈中的点就是凸包中的点。代码如下：",
      "对于以上实现的代码，都通过了测试程序的测试。",
      "Problem 8: Personal art",
      "利用while循环绘制一个雪花图形，通过递推确定每次要转向的角度。",
      "代码：",
      "结果：",
      "Submitting",
      "当所有代码都修改完成并确认无误后，利用git add添加修改过的代码文件，使用git commit将本地文件加入到本地仓库，同时可以标注版本信息。通过git push origin master将本地仓库push到GitHub上，在GitHub上可以看到push之后的文件。",
      "Social Network",
      "主要任务：设计Person类和FriendshipGraph类来模拟一个社交网络，并实现社交网络中需要的一些简单功能，包括添加人、添加社交关系以及计算两个人之间的距离。同时，编写测试程序来检查实现的正确性。",
      "/实现FriendshipGraph类",
      "社交网络是一个图模型，FriendshipGraph类中要存储一个图，并且要支持各种功能。我在FriendshipGraph类中只存储图的顶点，而顶点之间的关系和某一个人有关，因此存储在Person类中。FriendshipGraph类的属性只有private HashSet<Person> vertex用来存储图的顶点，方法包括构造方法、private变量的getter和setter以及一些简单的功能,,。另外，由于名字是Person的属性，因此判断名字是否重复交给Person类实现。",
      "addVertex()向vertex集合中添加顶点，addEdge()在Person类的朋友集合中添加新的朋友，getDistance()利用广度优先搜索计算两个Person之间的最近距离。同时，在函数中判断一些非法情况。具体代码如下：",
      "构造函数",
      "getter和setter",
      "addVertex()",
      "addEdge()",
      "getDistance()",
      "/实现Person类",
      "Person类是对人的抽象，属性包括自己的名字和朋友集合。方法包括：内部private属性的getter和setter，构造函数，以及添加朋友的addFriend()。同时，为了判断重名，在Person类中重写hashCode()、equals()和toString()方法，使得每个Person实例有不同的名字，如果有两个同名Person添加到社交网络的集合中，集合只会保留一个。具体代码如下：",
      "addFrined()",
      "构造函数",
      "Getter和setter",
      "重写的hashCode,equals,toString",
      "/实现客户端代码main()",
      "按照给定的客户端代码实现。",
      "/实现测试用例",
      "对于addVertex()的测试：当调用addVertex()后，测试FriendshipGraph类中顶点集合vertex的大小。如果添加的人不重复，大小会加一，否则不变。",
      "当addVertex()添加人的名字重复时，程序会输出提示信息并退出。因此测试程序退出时的输出内容是否正确（在网上查阅资料得知，需要添加额外的代码以测试调用System.exit()的情况）。",
      "对于addEdge()的测试：当调用addEdge()后，测试添加朋友的Person类中朋友集合friend的大小。addEdge()两个参数对应的Person类中的friend集合大小都会加一。",
      "对于getDistance()的测试：建立一个社交网络，测试函数返回的结果和实际结果是否相同，需要覆盖距离是-1、0以及大于0的情况。",
      "测试结果：",
      "实验进度记录",
      "时间段",
      "实际完成情况",
      "2021-05-06",
      "20:30-21:30",
      "编写Social Network问题中的FriendshipGraph类和Person类",
      "main",
      "函数中进行测试",
      "按计划完成",
      "2021-05-07",
      "18:30-19:30",
      "编写isLegalMagicSquare()函数，并用1.txt~5.txt文件中的数据进行测试",
      "延期10分钟完成",
      "2021-05-07",
      "20:30-21:30",
      "分析generateMagicSquare()函数的功能并进行修改，用其产生的Magic Square测试isLegalMagicSquare()函数",
      "按计划完成",
      "2021-05-08",
      "14:00-17:00",
      "完成Turtle Graphics问题中的所有任务",
      "按计划完成",
      "2021-05-09",
      "18:30-19:00",
      "设计并编写addVertex(),addEdge()和getDistance()的单元测试",
      "按计划完成",
      "2021-05-11",
      "13:45-15:00",
      "使用Git管理仓库并push到GitHub",
      "延期20分钟完成",
      "实验过程中遇到的困难与解决途径",
      "遇到的困难",
      "解决途径",
      "用Git管理时无法合并到master分支",
      "查阅资料，发现命令行参数存在问题，修改后成功。",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "本次实验初次接触软件构造，在实验中，我明白了软件构造的基本流程，并且更加熟练地掌握Java语言。同时，对Git的学习和使用也让我懂得了软件管理的重要性。获得了一些使用Git和本地IDE进行软件构造的经验。同时，也获得了一些教训，一定要在编写代码之前考虑好类的构造，属性、方法的定义以及使用的数据结构，否则一旦出错可能需要重头再来；同时，在设计之前也要平衡不同的质量目标，不至于在代码编写结束后再耗费很大功夫重新修改。",
      "针对以下方面的感受",
      "Java编程语言是否对你的口味？",
      "是，面向对象的语言会更容易编写，同时Java也包含了更多常用的数据 结构和函数，可以节省编写代码的工作量。",
      "关于Eclipse IDE；",
      "Eclipse集成开发环境功能很强大，使得编写程序更加容易。",
      "关于Git和GitHub；",
      "虽然Git的指令有些难搞懂，但是用它管理项目是很方便的。GitHub上的资源很多，功能也很强，但就是访问速度太慢了。",
      "关于CMU和MIT的作业；",
      "难度适合，也让我们可以与国外名校接轨。",
      "关于本实验的工作量、难度、deadline；",
      "难度不大，但是工作有些繁琐，但deadline设置比较合理，可以按时完成。",
      "关于初接触“软件构造”课程；",
      "初次做软件构造的实验，我认为可以通过这个课程提升自己的编程能力并且培养一种全局观念，同时可以获得更多不同的能力。"
    ],
    "sentences": [
      "Lab 1实验报告",
      "1 实验目标概述... 1",
      "2 实验环境配置... 1",
      "3 实验过程... 2",
      "3.1 Magic Squares. 2",
      "3.1.1 isLegalMagicSquare(). 2",
      "3.1.2 generateMagicSquare(). 3",
      "3.2 Turtle Graphics. 5",
      "3.2.1 Problem 1: Clone and import 5",
      "3.2.2 Problem 3: Turtle graphics and drawSquare. 5",
      "3.2.3 Problem 5: Drawing polygons. 6",
      "3.2.4 Problem 6: Calculating Bearings. 7",
      "3.2.5 Problem 7: Convex Hulls. 8",
      "3.2.6 Problem 8: Personal art 9",
      "3.2.7 Submitting. 10",
      "3.3 Social Network. 10",
      "3.3.1 设计/实现FriendshipGraph类... 10",
      "3.3.2 设计/实现Person类... 12",
      "3.3.3 设计/实现客户端代码main(). 13",
      "3.3.4 设计/实现测试用例... 13",
      "4 实验进度记录... 15",
      "5 实验过程中遇到的困难与解决途径... 16",
      "6 实验过程中收获的经验、教训、感想... 16",
      "6.1 实验过程中收获的经验和教训... 16",
      "6.2 针对以下方面的感受... 16",
      "实验目标概述",
      "本次实验通过求解三个问题",
      "训练基本Java编程技能",
      "能够利用Java OO开发基本的功能模块",
      "能够阅读理解已有代码框架并根据功能需求补全代码",
      "能够为所开发的代码编写基本的测试程序并完成测试",
      "初步保证所开发代码的正确性",
      "另一方面",
      "利用 Git 作为代码配置管理的工具",
      "学会 Git 的基本使用方法",
      "⚫ 基本的 Java OO 编程",
      "⚫ 基于 Eclipse IDE 进行 Java 编程",
      "⚫ 基于 JUnit 的测试",
      "⚫ 基于 Git 的代码配置管理",
      "实验环境配置",
      "在官网下载安装JDK，根据网上的步骤配置环境变量",
      "在官网下载安装Eclipse",
      "设置JRE以及其他preferences",
      "新建一个Workspace",
      "建立项目、包以及java源代码",
      "Eclipse配置成功的结果如图",
      "在官网下载Git并安装",
      "设置用户名、邮箱等信息",
      "Git配置成功的结果如图",
      "GitHub Lab1仓库的URL地址：https://github.com/ComputerScienceHIT/HIT-Lab1-1190200817",
      "实验过程",
      "请仔细对照实验手册",
      "针对四个问题中的每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）",
      "为了条理清晰，可根据需要在各节增加三级标题",
      "Magic Squares",
      "主要任务：从txt文件中解析数据",
      "并判断数据是否构成一个幻方",
      "通过5个文件进行测试",
      "同时阅读和改进产生幻方的代码，并进行测试",
      "isLegalMagicSquare()",
      "首先",
      "需要从txt文件中读出数据",
      "读txt文件可以使用固定的格式",
      "即使用BufferedReader并用try-resource语句处理异常",
      "利用BufferedReader",
      "每次可以从文件中读入一行字符串",
      "由于txt文件以’\\t’分隔数据的",
      "用String类的split方法可以将读入的字符串以’\\t’分隔",
      "得到字符串数组",
      "每个字符串数组都代表一个数",
      "使用Integer.valueOf将分隔后的每个字符串解析为数字",
      "同时需要捕获异常识别非法数据",
      "所有数据都存在二维ArrayList中",
      "获得每一行数据的个数以及总行数",
      "判断是否为n*n的矩阵",
      "分别计算每行、每列以及两个对角线上的数字之和",
      "比较是否相等",
      "并返回结果",
      "如果出现各种特殊情况，输出错误提示信息并返回",
      "generateMagicSquare()",
      "阅读generateMagicSquare()的代码",
      "可以看出它是将1到",
      "填充到一个",
      "n*n",
      "的幻方中，这种方法是常用的填充幻方的方法",
      "程序的流程图如下：但是，这种方法只能填充",
      "为奇数时的幻方",
      "当",
      "为偶数时",
      "函数产生异常java.lang.ArrayIndexOutOfBoundsException即填充过程中在row++时发生数组越界访问",
      "并且当",
      "是负数时",
      "不能有效处理非法输入",
      "产生异常java.lang.NegativeArraySizeException即初始化了行列数为负数的数组",
      "这导致了很差的健壮性",
      "修改这个函数，当输入不合法时提示错误并退出",
      "同时，当输入合法时，增加将结果写入文件的功能",
      "和之前类似，使用BufferedWriter将数据写入文件",
      "利用前面的 isLegalMagicSquare()函数",
      "可以判断生成的文本文件确实符合 Magic Square",
      "Turtle Graphics",
      "主要任务：根据函数的注释补全代码",
      "实现一系列绘图可能用到的功能",
      "包括画出正方形、计算正多边形的内角、计算对应内角的正多边形边数、计算绘图时的角度转移、计算凸包、以及绘制自己独特的图形",
      "Problem 1: Clone and import",
      "使用git init初始化一个本地仓库",
      "通过git clone将GitHub上的文件下载到这个仓库中",
      "这时就可以利用IDE进行代码编写",
      "每当认为某一个代码改进完成",
      "可以让它成为一个新的版本时",
      "利用git add添加相应代码",
      "使用git commit将本地文件加入到本地仓库",
      "当所有的代码都修改完毕",
      "通过git push origin master将本地仓库push到GitHub上",
      "Problem 3: Turtle graphics and",
      "drawSquare",
      "绘制图形时要用到两个函数：forward和turn",
      "分别实现前进和转向",
      "绘制正方形时",
      "只需要每次前进给定长度",
      "然后转向90°",
      "循环四次即可",
      "代码：结果：Problem 5: Drawing polygons",
      "对于给定边数的正多边形",
      "需要计算内角的度数来确定每次转向的度数",
      "实现calculateRegularPolygonAngle()函数确定给定边数的正多边形的内角度数",
      "直接通过公式可求出",
      "和上面一样",
      "每次前进给定长度",
      "转向的角度为外角的度数",
      "循环次数为边数",
      "代码：结果（以正六边形为例）：最后还要实现给定内角度数",
      "确定正多边形边数的函数",
      "直接通过公式可求出",
      "注意最后要将结果四舍五入才能返回整数",
      "Problem 6: Calculating Bearings",
      "实现函数calculateBearingToPoint()以满足已知起点、终点和当前朝向时",
      "应该转向的角度",
      "计算起点和终点所连直线的斜率",
      "利用atan函数得到最终的朝向的角度",
      "它和当前朝向的差值就是需要转过的角度",
      "通过调用calculateBearingToPoint()函数就可以计算经过一系列点时每次要转向的角度",
      "进而实现calculateBearings()",
      "已知初始朝向",
      "按顺序在列表中取出两个点",
      "调用calculateBearingToPoint()就可以得到这两个点之间需要转过的角",
      "修改当前朝向为转向之后的角度，就可以进行下一次计算",
      "需要注意",
      "更新当前朝向后",
      "如果角度超过360°",
      "需要减去360°",
      "Problem 7: Convex Hulls",
      "使用安德鲁算法求解凸包",
      "首先判断特殊情况",
      "如果顶点数小于等于2时",
      "这些点都会是凸包中的",
      "直接返回原点集",
      "找到所有点中横坐标最大的点",
      "有多个则选择纵坐标最小的点",
      "把它作为基准点",
      "这个点一定在凸包中",
      "其他的点和这个点的连线与y轴正半轴存在夹角",
      "按照夹角从小到大对其他顶点排序",
      "维护一个栈，首先将基准点入栈",
      "按顺序从排好序的顶点中取出一个",
      "如果栈中的点数大于2",
      "就取出栈顶的两个点",
      "通过计算向量的内积判断栈顶的点是否应该在凸包中",
      "如果不在",
      "将栈顶的点弹出",
      "继续判断；如果在",
      "将取出的顶点入栈",
      "如果栈中的点数小于2，直接将取出的顶点入栈",
      "最后，栈中的点就是凸包中的点",
      "代码如下：对于以上实现的代码，都通过了测试程序的测试",
      "Problem 8: Personal art",
      "利用while循环绘制一个雪花图形",
      "通过递推确定每次要转向的角度",
      "代码：结果：Submitting",
      "当所有代码都修改完成并确认无误后",
      "利用git add添加修改过的代码文件",
      "使用git commit将本地文件加入到本地仓库",
      "同时可以标注版本信息",
      "通过git push origin master将本地仓库push到GitHub上",
      "在GitHub上可以看到push之后的文件",
      "Social Network",
      "主要任务：设计Person类和FriendshipGraph类来模拟一个社交网络",
      "并实现社交网络中需要的一些简单功能",
      "包括添加人、添加社交关系以及计算两个人之间的距离",
      "同时，编写测试程序来检查实现的正确性",
      "/实现FriendshipGraph类",
      "社交网络是一个图模型",
      "FriendshipGraph类中要存储一个图",
      "并且要支持各种功能",
      "我在FriendshipGraph类中只存储图的顶点",
      "而顶点之间的关系和某一个人有关",
      "因此存储在Person类中",
      "FriendshipGraph类的属性只有private HashSet<Person> vertex用来存储图的顶点",
      "方法包括构造方法、private变量的getter和setter以及一些简单的功能,,",
      "另外",
      "由于名字是Person的属性",
      "因此判断名字是否重复交给Person类实现",
      "addVertex()向vertex集合中添加顶点",
      "addEdge()在Person类的朋友集合中添加新的朋友",
      "getDistance()利用广度优先搜索计算两个Person之间的最近距离",
      "同时，在函数中判断一些非法情况",
      "具体代码如下：构造函数",
      "getter和setter",
      "addVertex()",
      "addEdge()",
      "getDistance()",
      "/实现Person类",
      "Person类是对人的抽象，属性包括自己的名字和朋友集合",
      "方法包括：内部private属性的getter和setter",
      "构造函数",
      "以及添加朋友的addFriend()",
      "同时",
      "为了判断重名",
      "在Person类中重写hashCode()、equals()和toString()方法",
      "使得每个Person实例有不同的名字",
      "如果有两个同名Person添加到社交网络的集合中",
      "集合只会保留一个",
      "具体代码如下：addFrined()",
      "构造函数",
      "Getter和setter",
      "重写的hashCode,equals,toString",
      "/实现客户端代码main()",
      "按照给定的客户端代码实现",
      "/实现测试用例",
      "对于addVertex()的测试：当调用addVertex()后",
      "测试FriendshipGraph类中顶点集合vertex的大小",
      "如果添加的人不重复，大小会加一，否则不变",
      "当addVertex()添加人的名字重复时",
      "程序会输出提示信息并退出",
      "因此测试程序退出时的输出内容是否正确（在网上查阅资料得知",
      "需要添加额外的代码以测试调用System.exit()的情况）",
      "对于addEdge()的测试：当调用addEdge()后",
      "测试添加朋友的Person类中朋友集合friend的大小",
      "addEdge()两个参数对应的Person类中的friend集合大小都会加一",
      "对于getDistance()的测试：建立一个社交网络",
      "测试函数返回的结果和实际结果是否相同",
      "需要覆盖距离是-1、0以及大于0的情况",
      "测试结果：实验进度记录",
      "时间段",
      "实际完成情况",
      "2021-05-06",
      "20:30-21:30",
      "编写Social Network问题中的FriendshipGraph类和Person类",
      "main",
      "函数中进行测试",
      "按计划完成",
      "2021-05-07",
      "18:30-19:30",
      "编写isLegalMagicSquare()函数",
      "并用1.txt~5.txt文件中的数据进行测试",
      "延期10分钟完成",
      "2021-05-07",
      "20:30-21:30",
      "分析generateMagicSquare()函数的功能并进行修改",
      "用其产生的Magic Square测试isLegalMagicSquare()函数",
      "按计划完成",
      "2021-05-08",
      "14:00-17:00",
      "完成Turtle Graphics问题中的所有任务",
      "按计划完成",
      "2021-05-09",
      "18:30-19:00",
      "设计并编写addVertex(),addEdge()和getDistance()的单元测试",
      "按计划完成",
      "2021-05-11",
      "13:45-15:00",
      "使用Git管理仓库并push到GitHub",
      "延期20分钟完成",
      "实验过程中遇到的困难与解决途径",
      "遇到的困难",
      "解决途径",
      "用Git管理时无法合并到master分支",
      "查阅资料，发现命令行参数存在问题，修改后成功",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "本次实验初次接触软件构造",
      "在实验中",
      "我明白了软件构造的基本流程",
      "并且更加熟练地掌握Java语言",
      "同时，对Git的学习和使用也让我懂得了软件管理的重要性",
      "获得了一些使用Git和本地IDE进行软件构造的经验",
      "同时",
      "也获得了一些教训",
      "一定要在编写代码之前考虑好类的构造",
      "属性、方法的定义以及使用的数据结构",
      "否则一旦出错可能需要重头再来；同时",
      "在设计之前也要平衡不同的质量目标",
      "不至于在代码编写结束后再耗费很大功夫重新修改",
      "针对以下方面的感受",
      "Java编程语言是否对你的口味？",
      "是",
      "面向对象的语言会更容易编写",
      "同时Java也包含了更多常用的数据 结构和函数",
      "可以节省编写代码的工作量",
      "关于Eclipse IDE；Eclipse集成开发环境功能很强大",
      "使得编写程序更加容易",
      "关于Git和GitHub；虽然Git的指令有些难搞懂",
      "但是用它管理项目是很方便的",
      "GitHub上的资源很多，功能也很强，但就是访问速度太慢了",
      "关于CMU和MIT的作业；难度适合",
      "也让我们可以与国外名校接轨",
      "关于本实验的工作量、难度、deadline；难度不大",
      "但是工作有些繁琐",
      "但deadline设置比较合理",
      "可以按时完成",
      "关于初接触“软件构造”课程；初次做软件构造的实验",
      "我认为可以通过这个课程提升自己的编程能力并且培养一种全局观念",
      "同时可以获得更多不同的能力"
    ],
    "codes": [
      "addVertex()",
      "addEdge()",
      "getDistance()"
    ],
    "date": "2021-05-30",
    "text": "Lab 1实验报告\n1 实验目标概述... 1\n2 实验环境配置... 1\n3 实验过程... 2\n3.1 Magic Squares. 2\n3.1.1 isLegalMagicSquare(). 2\n3.1.2 generateMagicSquare(). 3\n3.2 Turtle Graphics. 5\n3.2.1 Problem 1: Clone and import 5\n3.2.2 Problem 3: Turtle graphics and drawSquare. 5\n3.2.3 Problem 5: Drawing polygons. 6\n3.2.4 Problem 6: Calculating Bearings. 7\n3.2.5 Problem 7: Convex Hulls. 8\n3.2.6 Problem 8: Personal art 9\n3.2.7 Submitting. 10\n3.3 Social Network. 10\n3.3.1 设计/实现FriendshipGraph类... 10\n3.3.2 设计/实现Person类... 12\n3.3.3 设计/实现客户端代码main(). 13\n3.3.4 设计/实现测试用例... 13\n4 实验进度记录... 15\n5 实验过程中遇到的困难与解决途径... 16\n6 实验过程中收获的经验、教训、感想... 16\n6.1 实验过程中收获的经验和教训... 16\n6.2 针对以下方面的感受... 16\n实验目标概述\n本次实验通过求解三个问题，训练基本Java编程技能，能够利用Java OO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用 Git 作为代码配置管理的工具，学会 Git 的基本使用方法。\n⚫ 基本的 Java OO 编程\n⚫ 基于 Eclipse IDE 进行 Java 编程\n⚫ 基于 JUnit 的测试\n⚫ 基于 Git 的代码配置管理。\n实验环境配置\n在官网下载安装JDK，根据网上的步骤配置环境变量。\n在官网下载安装Eclipse，设置JRE以及其他preferences。新建一个Workspace，建立项目、包以及java源代码，Eclipse配置成功的结果如图。\n在官网下载Git并安装，设置用户名、邮箱等信息，Git配置成功的结果如图。\nGitHub Lab1仓库的URL地址：https://github.com/ComputerScienceHIT/HIT-Lab1-1190200817。\n实验过程\n请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。\n为了条理清晰，可根据需要在各节增加三级标题。\nMagic Squares\n主要任务：从txt文件中解析数据，并判断数据是否构成一个幻方，通过5个文件进行测试。同时阅读和改进产生幻方的代码，并进行测试。\nisLegalMagicSquare()\n首先，需要从txt文件中读出数据，读txt文件可以使用固定的格式，即使用BufferedReader并用try-resource语句处理异常。\n利用BufferedReader，每次可以从文件中读入一行字符串。由于txt文件以’\\t’分隔数据的，用String类的split方法可以将读入的字符串以’\\t’分隔，得到字符串数组，每个字符串数组都代表一个数。使用Integer.valueOf将分隔后的每个字符串解析为数字，同时需要捕获异常识别非法数据。\n所有数据都存在二维ArrayList中，获得每一行数据的个数以及总行数，判断是否为n*n的矩阵。分别计算每行、每列以及两个对角线上的数字之和，比较是否相等，并返回结果。如果出现各种特殊情况，输出错误提示信息并返回。\ngenerateMagicSquare()\n阅读generateMagicSquare()的代码，可以看出它是将1到\n填充到一个\nn*n\n的幻方中，这种方法是常用的填充幻方的方法。程序的流程图如下：\n但是，这种方法只能填充\n为奇数时的幻方。当\n为偶数时，函数产生异常java.lang.ArrayIndexOutOfBoundsException即填充过程中在row++时发生数组越界访问。并且当\n是负数时，不能有效处理非法输入，产生异常java.lang.NegativeArraySizeException即初始化了行列数为负数的数组。这导致了很差的健壮性。修改这个函数，当输入不合法时提示错误并退出。\n同时，当输入合法时，增加将结果写入文件的功能。和之前类似，使用BufferedWriter将数据写入文件。\n利用前面的 isLegalMagicSquare()函数，可以判断生成的文本文件确实符合 Magic Square。\nTurtle Graphics\n主要任务：根据函数的注释补全代码，实现一系列绘图可能用到的功能。包括画出正方形、计算正多边形的内角、计算对应内角的正多边形边数、计算绘图时的角度转移、计算凸包、以及绘制自己独特的图形。\nProblem 1: Clone and import\n使用git init初始化一个本地仓库，通过git clone将GitHub上的文件下载到这个仓库中。这时就可以利用IDE进行代码编写。每当认为某一个代码改进完成，可以让它成为一个新的版本时，利用git add添加相应代码，使用git commit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过git push origin master将本地仓库push到GitHub上。\nProblem 3: Turtle graphics and\ndrawSquare\n绘制图形时要用到两个函数：forward和turn，分别实现前进和转向。绘制正方形时，只需要每次前进给定长度，然后转向90°，循环四次即可。\n代码：\n结果：\nProblem 5: Drawing polygons\n对于给定边数的正多边形，需要计算内角的度数来确定每次转向的度数。实现calculateRegularPolygonAngle()函数确定给定边数的正多边形的内角度数。直接通过公式可求出。\n和上面一样，每次前进给定长度，转向的角度为外角的度数，循环次数为边数。\n代码：\n结果（以正六边形为例）：\n最后还要实现给定内角度数，确定正多边形边数的函数。直接通过公式可求出。注意最后要将结果四舍五入才能返回整数。\nProblem 6: Calculating Bearings\n实现函数calculateBearingToPoint()以满足已知起点、终点和当前朝向时，应该转向的角度。计算起点和终点所连直线的斜率，利用atan函数得到最终的朝向的角度，它和当前朝向的差值就是需要转过的角度。\n通过调用calculateBearingToPoint()函数就可以计算经过一系列点时每次要转向的角度，进而实现calculateBearings()。已知初始朝向，按顺序在列表中取出两个点，调用calculateBearingToPoint()就可以得到这两个点之间需要转过的角。修改当前朝向为转向之后的角度，就可以进行下一次计算。需要注意，更新当前朝向后，如果角度超过360°，需要减去360°。\nProblem 7: Convex Hulls\n使用安德鲁算法求解凸包。首先判断特殊情况，如果顶点数小于等于2时，这些点都会是凸包中的，直接返回原点集。找到所有点中横坐标最大的点，有多个则选择纵坐标最小的点，把它作为基准点，这个点一定在凸包中。其他的点和这个点的连线与y轴正半轴存在夹角，按照夹角从小到大对其他顶点排序。维护一个栈，首先将基准点入栈。按顺序从排好序的顶点中取出一个，如果栈中的点数大于2，就取出栈顶的两个点。通过计算向量的内积判断栈顶的点是否应该在凸包中，如果不在，将栈顶的点弹出，继续判断；如果在，将取出的顶点入栈。如果栈中的点数小于2，直接将取出的顶点入栈。最后，栈中的点就是凸包中的点。代码如下：\n对于以上实现的代码，都通过了测试程序的测试。\nProblem 8: Personal art\n利用while循环绘制一个雪花图形，通过递推确定每次要转向的角度。\n代码：\n结果：\nSubmitting\n当所有代码都修改完成并确认无误后，利用git add添加修改过的代码文件，使用git commit将本地文件加入到本地仓库，同时可以标注版本信息。通过git push origin master将本地仓库push到GitHub上，在GitHub上可以看到push之后的文件。\nSocial Network\n主要任务：设计Person类和FriendshipGraph类来模拟一个社交网络，并实现社交网络中需要的一些简单功能，包括添加人、添加社交关系以及计算两个人之间的距离。同时，编写测试程序来检查实现的正确性。\n/实现FriendshipGraph类\n社交网络是一个图模型，FriendshipGraph类中要存储一个图，并且要支持各种功能。我在FriendshipGraph类中只存储图的顶点，而顶点之间的关系和某一个人有关，因此存储在Person类中。FriendshipGraph类的属性只有private HashSet<Person> vertex用来存储图的顶点，方法包括构造方法、private变量的getter和setter以及一些简单的功能,,。另外，由于名字是Person的属性，因此判断名字是否重复交给Person类实现。\naddVertex()向vertex集合中添加顶点，addEdge()在Person类的朋友集合中添加新的朋友，getDistance()利用广度优先搜索计算两个Person之间的最近距离。同时，在函数中判断一些非法情况。具体代码如下：\n构造函数\ngetter和setter\naddVertex()\naddEdge()\ngetDistance()\n/实现Person类\nPerson类是对人的抽象，属性包括自己的名字和朋友集合。方法包括：内部private属性的getter和setter，构造函数，以及添加朋友的addFriend()。同时，为了判断重名，在Person类中重写hashCode()、equals()和toString()方法，使得每个Person实例有不同的名字，如果有两个同名Person添加到社交网络的集合中，集合只会保留一个。具体代码如下：\naddFrined()\n构造函数\nGetter和setter\n重写的hashCode,equals,toString\n/实现客户端代码main()\n按照给定的客户端代码实现。\n/实现测试用例\n对于addVertex()的测试：当调用addVertex()后，测试FriendshipGraph类中顶点集合vertex的大小。如果添加的人不重复，大小会加一，否则不变。\n当addVertex()添加人的名字重复时，程序会输出提示信息并退出。因此测试程序退出时的输出内容是否正确（在网上查阅资料得知，需要添加额外的代码以测试调用System.exit()的情况）。\n对于addEdge()的测试：当调用addEdge()后，测试添加朋友的Person类中朋友集合friend的大小。addEdge()两个参数对应的Person类中的friend集合大小都会加一。\n对于getDistance()的测试：建立一个社交网络，测试函数返回的结果和实际结果是否相同，需要覆盖距离是-1、0以及大于0的情况。\n测试结果：\n实验进度记录\n时间段\n实际完成情况\n2021-05-06\n20:30-21:30\n编写Social Network问题中的FriendshipGraph类和Person类\nmain\n函数中进行测试\n按计划完成\n2021-05-07\n18:30-19:30\n编写isLegalMagicSquare()函数，并用1.txt~5.txt文件中的数据进行测试\n延期10分钟完成\n2021-05-07\n20:30-21:30\n分析generateMagicSquare()函数的功能并进行修改，用其产生的Magic Square测试isLegalMagicSquare()函数\n按计划完成\n2021-05-08\n14:00-17:00\n完成Turtle Graphics问题中的所有任务\n按计划完成\n2021-05-09\n18:30-19:00\n设计并编写addVertex(),addEdge()和getDistance()的单元测试\n按计划完成\n2021-05-11\n13:45-15:00\n使用Git管理仓库并push到GitHub\n延期20分钟完成\n实验过程中遇到的困难与解决途径\n遇到的困难\n解决途径\n用Git管理时无法合并到master分支\n查阅资料，发现命令行参数存在问题，修改后成功。\n实验过程中收获的经验、教训、感想\n实验过程中收获的经验和教训\n本次实验初次接触软件构造，在实验中，我明白了软件构造的基本流程，并且更加熟练地掌握Java语言。同时，对Git的学习和使用也让我懂得了软件管理的重要性。获得了一些使用Git和本地IDE进行软件构造的经验。同时，也获得了一些教训，一定要在编写代码之前考虑好类的构造，属性、方法的定义以及使用的数据结构，否则一旦出错可能需要重头再来；同时，在设计之前也要平衡不同的质量目标，不至于在代码编写结束后再耗费很大功夫重新修改。\n针对以下方面的感受\nJava编程语言是否对你的口味？\n是，面向对象的语言会更容易编写，同时Java也包含了更多常用的数据 结构和函数，可以节省编写代码的工作量。\n关于Eclipse IDE；\nEclipse集成开发环境功能很强大，使得编写程序更加容易。\n关于Git和GitHub；\n虽然Git的指令有些难搞懂，但是用它管理项目是很方便的。GitHub上的资源很多，功能也很强，但就是访问速度太慢了。\n关于CMU和MIT的作业；\n难度适合，也让我们可以与国外名校接轨。\n关于本实验的工作量、难度、deadline；\n难度不大，但是工作有些繁琐，但deadline设置比较合理，可以按时完成。\n关于初接触“软件构造”课程；\n初次做软件构造的实验，我认为可以通过这个课程提升自己的编程能力并且培养一种全局观念，同时可以获得更多不同的能力。\n"
  },
  {
    "head": "Integer的自动装箱与比较问题",
    "paragraphs": [
      "问题引入",
      "Java使用==进行引用的比较，使用equals进行对象的比较。在多数情况下，都是使用==比较基本数据类型，而使用equals比较对象类型。但Java又为每个基本数据类型建立了相应的包装类，这使得相等的比较稍微复杂了一些，其中涉及自动装箱与拆箱的问题。同时，Integer的缓存机制使得比较情况更加复杂。因此，在这里分析一下Integer的自动装箱与比较问题。",
      "自动装箱",
      "自动拆箱和自动装箱是 java的语法糖之一，执行在编译期，会根据代码的语法决定是否进行拆箱和装箱动作。自动装箱使得定义基本数据类型的包装类时，可以直接使用=赋值，而不使用new，如：",
      "在编译时，会根据这种语法，决定进行装箱操作，实际上执行的语句调用了Interger的静态方法：",
      "在任何时候，如果涉及到从基本数据类型到其包装类的转换，编译器都会决定进行自动装箱。比如：",
      "由于map中值的类型为Integer，而put将int类型的值放到map中，自动装箱后的语句类似于：",
      "自动拆箱",
      "和自动装箱相反，如果将Integer类型的数据赋值给基本数据类型int，就会执行自动拆箱。如：",
      "在编译时，会根据这种语法，决定进行拆箱操作，实际上执行的语句调用了a的intValue方法：",
      "当Integer类型的对象和基本数据类型进行算术或关系运算时，Integer对象也会自动拆箱，比如：",
      "当执行Integer c = a + b;时，编译器发现一个Integer类型和一个int类型进行算术运算，决定对Integer类型进行拆箱。a+b运算的结果实际上是int类型的，将结果赋值给c时又会进行装箱操作。",
      "Integer的缓存机制",
      "Integer的缓存机制使得比较问题更加复杂。上面说过，自动装箱时调用了Integer.valueOf()，这个函数的源码为：",
      "其中IntegerCache.low=-128，IntegerCache.high=127。这说明valueOf的参数如果介于-128和127之间的话，会返回IntegerCache中的对象，否则会重新new一个对象并返回。",
      "Integer/int的比较",
      "1.两个int类型进行比较，直接使用==就好了。",
      "2.涉及Integer的比较，使用equals总不会出错。如果是两个Integer进行比较，equals当然比较的是各对象的值。如果是一个Integer和一个int比较，只能对Integer对象使用equals方法，这时会涉及自动装箱，比如：",
      "最后一条语句会让b自动装箱，但是equals比较的始终是对象的值，因此不会有问题",
      "3.涉及Integer的比较，如果使用==，情况会变得复杂。",
      "如果是一个Integer和一个int比较，前面说过会进行自动拆箱，Integer对象会变为int类型，相当于两个int的==比较，没有问题。",
      "如果是两个Integer进行比较，这里情况比较复杂。",
      "(1)只要有一个Integer是通过new产生的，一定会得到false。因为new会在堆中分配内存，而==比较的是引用，也就是比较内存地址，只要不是别名引用，一定会得到false",
      "(2)两个Integer都是直接赋值产生的，只有被缓存时才能得到true。根据上面valueOf的源码可知，如果值落在-128~127之间，会返回IntegerCache中的对象，对于下面的代码，a和b都指向IntegerCache中的同一对象，因此==会得到true",
      "(3)两个Integer都是直接赋值产生的，但未缓存，会得到false。根据valueOf的源码，如果值不在-128~127之间，会返回new的对象，这时和(1)完全一样。对于下面的代码，a和b都是new出的对象，==会得到false",
      "对于其他基本数据类型及其包装类，也涉及装箱、拆箱以及缓存的机制",
      "包装类型",
      "基本数据类型",
      "Byte",
      "byte",
      "-128~127",
      "Short",
      "short",
      "-128~127",
      "Character",
      "char",
      "0~127",
      "Integer",
      "int",
      "-128~127",
      "Long",
      "long",
      "-128~127",
      "Float",
      "float",
      "无缓存",
      "Double",
      "double",
      "无缓存",
      "可以看出比较的情况还是比较多的，但是如果只使用equals，就不会出现任何问题。因此涉及包装类对象之间值的比较，一定要用equals方法。这也是阿里Java开发手册编程规约中指出的：强制所有包装类对象之间值的比较，全部使用 equals 方法！"
    ],
    "sentences": [
      "问题引入",
      "Java使用==进行引用的比较",
      "使用equals进行对象的比较",
      "在多数情况下",
      "都是使用==比较基本数据类型",
      "而使用equals比较对象类型",
      "但Java又为每个基本数据类型建立了相应的包装类",
      "这使得相等的比较稍微复杂了一些",
      "其中涉及自动装箱与拆箱的问题",
      "同时，Integer的缓存机制使得比较情况更加复杂",
      "因此，在这里分析一下Integer的自动装箱与比较问题",
      "自动装箱",
      "自动拆箱和自动装箱是 java的语法糖之一",
      "执行在编译期",
      "会根据代码的语法决定是否进行拆箱和装箱动作",
      "自动装箱使得定义基本数据类型的包装类时",
      "可以直接使用=赋值",
      "而不使用new",
      "如：在编译时",
      "会根据这种语法",
      "决定进行装箱操作",
      "实际上执行的语句调用了Interger的静态方法：在任何时候",
      "如果涉及到从基本数据类型到其包装类的转换",
      "编译器都会决定进行自动装箱",
      "比如：由于map中值的类型为Integer",
      "而put将int类型的值放到map中",
      "自动装箱后的语句类似于：自动拆箱",
      "和自动装箱相反",
      "如果将Integer类型的数据赋值给基本数据类型int",
      "就会执行自动拆箱",
      "如：在编译时",
      "会根据这种语法",
      "决定进行拆箱操作",
      "实际上执行的语句调用了a的intValue方法：当Integer类型的对象和基本数据类型进行算术或关系运算时",
      "Integer对象也会自动拆箱",
      "比如：当执行Integer c = a + b;时",
      "编译器发现一个Integer类型和一个int类型进行算术运算",
      "决定对Integer类型进行拆箱",
      "a+b运算的结果实际上是int类型的",
      "将结果赋值给c时又会进行装箱操作",
      "Integer的缓存机制",
      "Integer的缓存机制使得比较问题更加复杂",
      "上面说过",
      "自动装箱时调用了Integer.valueOf()",
      "这个函数的源码为：其中IntegerCache.low=-128",
      "IntegerCache.high=127",
      "这说明valueOf的参数如果介于-128和127之间的话",
      "会返回IntegerCache中的对象",
      "否则会重新new一个对象并返回",
      "Integer/int的比较",
      "1.两个int类型进行比较，直接使用==就好了",
      "2.涉及Integer的比较，使用equals总不会出错",
      "如果是两个Integer进行比较",
      "equals当然比较的是各对象的值",
      "如果是一个Integer和一个int比较",
      "只能对Integer对象使用equals方法",
      "这时会涉及自动装箱",
      "比如：最后一条语句会让b自动装箱",
      "但是equals比较的始终是对象的值",
      "因此不会有问题",
      "3.涉及Integer的比较，如果使用==，情况会变得复杂",
      "如果是一个Integer和一个int比较",
      "前面说过会进行自动拆箱",
      "Integer对象会变为int类型",
      "相当于两个int的==比较",
      "没有问题",
      "如果是两个Integer进行比较，这里情况比较复杂",
      "(1)只要有一个Integer是通过new产生的",
      "一定会得到false",
      "因为new会在堆中分配内存",
      "而==比较的是引用",
      "也就是比较内存地址",
      "只要不是别名引用",
      "一定会得到false",
      "(2)两个Integer都是直接赋值产生的",
      "只有被缓存时才能得到true",
      "根据上面valueOf的源码可知",
      "如果值落在-128~127之间",
      "会返回IntegerCache中的对象",
      "对于下面的代码",
      "a和b都指向IntegerCache中的同一对象",
      "因此==会得到true",
      "(3)两个Integer都是直接赋值产生的",
      "但未缓存",
      "会得到false",
      "根据valueOf的源码",
      "如果值不在-128~127之间",
      "会返回new的对象",
      "这时和(1)完全一样",
      "对于下面的代码",
      "a和b都是new出的对象",
      "==会得到false",
      "对于其他基本数据类型及其包装类",
      "也涉及装箱、拆箱以及缓存的机制",
      "包装类型",
      "基本数据类型",
      "Byte",
      "byte",
      "-128~127",
      "Short",
      "short",
      "-128~127",
      "Character",
      "char",
      "0~127",
      "Integer",
      "int",
      "-128~127",
      "Long",
      "long",
      "-128~127",
      "Float",
      "float",
      "无缓存",
      "Double",
      "double",
      "无缓存",
      "可以看出比较的情况还是比较多的",
      "但是如果只使用equals",
      "就不会出现任何问题",
      "因此涉及包装类对象之间值的比较，一定要用equals方法",
      "这也是阿里Java开发手册编程规约中指出的：强制所有包装类对象之间值的比较",
      "全部使用 equals 方法！"
    ],
    "codes": [
      "Integer a = 5;",
      "Integer a = Integer.valueOf(128);",
      "Map<String,Integer> map = new HashMap<>();\nmap.put(\"a\", 1); ",
      "Map<String,Integer> map = new HashMap<>();\nmap.put(\"a\", Integer.valueOf(1)); ",
      "Integer a = new Integer(5);\nint b = a;",
      "Integer a = new Integer(5);\nint b = a.intValue();",
      "Integer a = new Integer(5);\nint b = 6;\nInteger c = a + b;",
      "public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n}",
      "Integer a = 5;\nint b = 5;\na.equals(b);",
      "Integer a = new Integer(5);\nInteger b = new Integer(5);\nInteger c = 5;\na == b // false\na == c // false\n",
      "Integer a = 5;\nInteger b = 5;\na == b // true\n",
      "Integer a = 128;\nInteger b = 128;\na == b // false",
      "Boolean",
      "boolean",
      "true,false"
    ],
    "date": "2021-06-13",
    "text": "问题引入\nJava使用==进行引用的比较，使用equals进行对象的比较。在多数情况下，都是使用==比较基本数据类型，而使用equals比较对象类型。但Java又为每个基本数据类型建立了相应的包装类，这使得相等的比较稍微复杂了一些，其中涉及自动装箱与拆箱的问题。同时，Integer的缓存机制使得比较情况更加复杂。因此，在这里分析一下Integer的自动装箱与比较问题。\n自动装箱\n自动拆箱和自动装箱是 java的语法糖之一，执行在编译期，会根据代码的语法决定是否进行拆箱和装箱动作。自动装箱使得定义基本数据类型的包装类时，可以直接使用=赋值，而不使用new，如：\n在编译时，会根据这种语法，决定进行装箱操作，实际上执行的语句调用了Interger的静态方法：\n在任何时候，如果涉及到从基本数据类型到其包装类的转换，编译器都会决定进行自动装箱。比如：\n由于map中值的类型为Integer，而put将int类型的值放到map中，自动装箱后的语句类似于：\n自动拆箱\n和自动装箱相反，如果将Integer类型的数据赋值给基本数据类型int，就会执行自动拆箱。如：\n在编译时，会根据这种语法，决定进行拆箱操作，实际上执行的语句调用了a的intValue方法：\n当Integer类型的对象和基本数据类型进行算术或关系运算时，Integer对象也会自动拆箱，比如：\n当执行Integer c = a + b;时，编译器发现一个Integer类型和一个int类型进行算术运算，决定对Integer类型进行拆箱。a+b运算的结果实际上是int类型的，将结果赋值给c时又会进行装箱操作。\nInteger的缓存机制\nInteger的缓存机制使得比较问题更加复杂。上面说过，自动装箱时调用了Integer.valueOf()，这个函数的源码为：\n其中IntegerCache.low=-128，IntegerCache.high=127。这说明valueOf的参数如果介于-128和127之间的话，会返回IntegerCache中的对象，否则会重新new一个对象并返回。\nInteger/int的比较\n1.两个int类型进行比较，直接使用==就好了。\n2.涉及Integer的比较，使用equals总不会出错。如果是两个Integer进行比较，equals当然比较的是各对象的值。如果是一个Integer和一个int比较，只能对Integer对象使用equals方法，这时会涉及自动装箱，比如：\n最后一条语句会让b自动装箱，但是equals比较的始终是对象的值，因此不会有问题\n3.涉及Integer的比较，如果使用==，情况会变得复杂。\n如果是一个Integer和一个int比较，前面说过会进行自动拆箱，Integer对象会变为int类型，相当于两个int的==比较，没有问题。\n如果是两个Integer进行比较，这里情况比较复杂。\n(1)只要有一个Integer是通过new产生的，一定会得到false。因为new会在堆中分配内存，而==比较的是引用，也就是比较内存地址，只要不是别名引用，一定会得到false\n(2)两个Integer都是直接赋值产生的，只有被缓存时才能得到true。根据上面valueOf的源码可知，如果值落在-128~127之间，会返回IntegerCache中的对象，对于下面的代码，a和b都指向IntegerCache中的同一对象，因此==会得到true\n(3)两个Integer都是直接赋值产生的，但未缓存，会得到false。根据valueOf的源码，如果值不在-128~127之间，会返回new的对象，这时和(1)完全一样。对于下面的代码，a和b都是new出的对象，==会得到false\n对于其他基本数据类型及其包装类，也涉及装箱、拆箱以及缓存的机制\n包装类型\n基本数据类型\nByte\nbyte\n-128~127\nShort\nshort\n-128~127\nCharacter\nchar\n0~127\nInteger\nint\n-128~127\nLong\nlong\n-128~127\nFloat\nfloat\n无缓存\nDouble\ndouble\n无缓存\n可以看出比较的情况还是比较多的，但是如果只使用equals，就不会出现任何问题。因此涉及包装类对象之间值的比较，一定要用equals方法。这也是阿里Java开发手册编程规约中指出的：强制所有包装类对象之间值的比较，全部使用 equals 方法！\n"
  },
  {
    "head": "正则表达式笔记",
    "paragraphs": [
      "基本语法跟形式语言课程中学的差不多，但java正则表达式的符号数量远远多于+，*，和连接。符号表网上可查，比较常用的有",
      "（图片资源来源网络）",
      "但实验中出现了一种特殊符号，好像是中文空格，它无法用\\s识别，只能复制粘贴到正则表达式中，所以一定要注意文件格式和其中的缩进形式。",
      "根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。不加\\\\有时编译器会报错，有时不会报错，这种情况下一定要注意，否则又浪费半天。"
    ],
    "sentences": [
      "基本语法跟形式语言课程中学的差不多",
      "但java正则表达式的符号数量远远多于+",
      "*",
      "和连接",
      "符号表网上可查，比较常用的有",
      "（图片资源来源网络）",
      "但实验中出现了一种特殊符号",
      "好像是中文空格",
      "它无法用\\s识别",
      "只能复制粘贴到正则表达式中",
      "所以一定要注意文件格式和其中的缩进形式",
      "根据 Java Language Specification 的要求",
      "Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义",
      "因此必须在字符串字面值中使用两个反斜线",
      "表示正则表达式受到保护",
      "不被 Java 字节码编译器解释",
      "不加\\\\有时编译器会报错",
      "有时不会报错",
      "这种情况下一定要注意",
      "否则又浪费半天"
    ],
    "codes": [],
    "date": "2021-06-29",
    "text": "基本语法跟形式语言课程中学的差不多，但java正则表达式的符号数量远远多于+，*，和连接。符号表网上可查，比较常用的有\n（图片资源来源网络）\n但实验中出现了一种特殊符号，好像是中文空格，它无法用\\s识别，只能复制粘贴到正则表达式中，所以一定要注意文件格式和其中的缩进形式。\n根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。不加\\\\有时编译器会报错，有时不会报错，这种情况下一定要注意，否则又浪费半天。\n"
  },
  {
    "head": "java自定义异常类",
    "paragraphs": [
      "java可以通过继承Exception的手段来进行自定义的异常类",
      "但只是这么写Eclipse会有warning存在，warning内容如下：",
      "出现这个warning的原因是：只要任何类别实现了Serializable这个接口的话，如果没有加入serialVersionUID，Eclipse都会给你warning提示，这个serialVersionUID为了让该类别 Serializable向后兼容。即版本升级时反序列化仍保持对象的唯一性；"
    ],
    "sentences": [
      "java可以通过继承Exception的手段来进行自定义的异常类",
      "但只是这么写Eclipse会有warning存在",
      "warning内容如下：出现这个warning的原因是：只要任何类别实现了Serializable这个接口的话",
      "如果没有加入serialVersionUID",
      "Eclipse都会给你warning提示",
      "这个serialVersionUID为了让该类别 Serializable向后兼容",
      "即版本升级时反序列化仍保持对象的唯一性；"
    ],
    "codes": [
      "public class IntervalConflictException extends Exception {//自定义的异常类\n\t\n\t/**\n\t * Make a new interval conflict exception with the given detail message\n\t * @param message the detail message\n\t */\n\tpublic IntervalConflictException(String message) {\n\t\tsuper(message);\n\t}\n\n}"
    ],
    "date": "2021-06-28",
    "text": "java可以通过继承Exception的手段来进行自定义的异常类\n但只是这么写Eclipse会有warning存在，warning内容如下：\n出现这个warning的原因是：只要任何类别实现了Serializable这个接口的话，如果没有加入serialVersionUID，Eclipse都会给你warning提示，这个serialVersionUID为了让该类别 Serializable向后兼容。即版本升级时反序列化仍保持对象的唯一性；\n"
  },
  {
    "head": "JUnit5中测试异常抛出的方法",
    "paragraphs": [
      "根据JUnit文档（http://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions）:",
      "说实话我没太明白什么个原理，先码后了解"
    ],
    "sentences": [
      "根据JUnit文档（http://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions）:说实话我没太明白什么个原理",
      "先码后了解"
    ],
    "codes": [
      "import static org.junit.jupiter.api.Assertions.assertThrows;\n\n...\n\n@Test\nvoid exceptionTesting() {\n    Executable closureContainingCodeToTest = () -> throw new IllegalArgumentException(\"a message\");\n\n    assertThrows(IllegalArgumentException.class, closureContainingCodeToTest, \"a message\");\n}"
    ],
    "date": "2021-06-29",
    "text": "根据JUnit文档（http://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions）:\n说实话我没太明白什么个原理，先码后了解\n"
  },
  {
    "head": "接口中的default方法",
    "paragraphs": [
      "复习的时候看到了interface还可以用default声明方法，学习了一下。Java8接口中也允许使用 default 关键字来定义并实现实例方法，这个应用有点类似于抽象类的功能。",
      "通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它。上一个小例子：",
      "输出结果："
    ],
    "sentences": [
      "复习的时候看到了interface还可以用default声明方法",
      "学习了一下",
      "Java8接口中也允许使用 default 关键字来定义并实现实例方法",
      "这个应用有点类似于抽象类的功能",
      "通过default方法",
      "在接口中统一实现某些功能",
      "无需在各个类中重复实现它",
      "上一个小例子：输出结果："
    ],
    "codes": [
      "package example;\n\ninterface IntefercaeExample {\n    default void showDefault(){\n        System.out.println(\"hello\");\n    }\n    static void showStatic(){\n        System.out.println(\"haha\");\n    }\n\n    //没有实现的抽象方法\n    void sayHi();\n}\nclass Sometry implements IntefercaeExample{\n    @Override\n    public void sayHi() {\n        System.out.println(\"Hi\");\n    }\n\n    public static void main(String[] args) {\n    \tIntefercaeExample.showStatic();\n        Sometry learnDefault = new Sometry();\n        //被Default所修饰的具体方法可以通过引用变量来调用\n        learnDefault.showDefault();\n        learnDefault.sayHi();\n}\n}"
    ],
    "date": "2021-07-05",
    "text": "复习的时候看到了interface还可以用default声明方法，学习了一下。Java8接口中也允许使用 default 关键字来定义并实现实例方法，这个应用有点类似于抽象类的功能。\n通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它。上一个小例子：\n输出结果：\n"
  },
  {
    "head": "lab3中去除读进来的文件缩进的方法",
    "paragraphs": [
      "首先，因为我先把整个文件用BufferReader给读成了一个String类型的量，因为String类型是immutable的，所以要新建一个String类型的临时变量来记录改变以后的内容；然后再用最笨的方法:String.replaceAll(\"\"，\"\");",
      "方法比较笨，但还是先记录在学习；代码就一句：",
      "（真不是在这水文章，这个当时的确调了一会，才把所有缩进都去掉）"
    ],
    "sentences": [
      "首先",
      "因为我先把整个文件用BufferReader给读成了一个String类型的量",
      "因为String类型是immutable的",
      "所以要新建一个String类型的临时变量来记录改变以后的内容；然后再用最笨的方法:String.replaceAll(\"\"",
      "\"\");方法比较笨",
      "但还是先记录在学习；代码就一句：（真不是在这水文章",
      "这个当时的确调了一会",
      "才把所有缩进都去掉）"
    ],
    "codes": [
      "String newfile =fileentry.replace(\"\\n\", \"\").replace(\"\\r\", \"\").replace(\"　\", \"\").replace(\" \", \"\");"
    ],
    "date": "2021-06-30",
    "text": "首先，因为我先把整个文件用BufferReader给读成了一个String类型的量，因为String类型是immutable的，所以要新建一个String类型的临时变量来记录改变以后的内容；然后再用最笨的方法:String.replaceAll(\"\"，\"\");\n方法比较笨，但还是先记录在学习；代码就一句：\n（真不是在这水文章，这个当时的确调了一会，才把所有缩进都去掉）\n"
  },
  {
    "head": "面向软件构造期末考试程序设计题的复习",
    "paragraphs": [
      "面向软件构造期末考试程序设计题的复习",
      "目录 1",
      "1 设计spec 1",
      "1.1 spec的重要性 1",
      "1.2 spec的结构 1",
      "1.3 spec中不能包含的部分 1",
      "2 ADT的设计 1",
      "2.1 RI 1",
      "2.2 表示泄露 2",
      "2.2 AF 2",
      "3 面向可维护性的设计模式 2",
      "3.1 Visitor 2",
      "3.2 Strategy策略模式 2",
      "3.3 Iterator迭代器模式 2",
      "3.4 Decorator装饰器模式 3",
      "3.5 Factory Method工厂模式 3",
      "3.6 Adapter适配器模式 3",
      "1 设计spec",
      "1.1 spec的重要性",
      "spec是程序员自己对所写的方法的规约，它规定了方法应该做什么，不应该做什么。spec时是测试优先编程的基础，因为程序员所编写的代码必定是符合spec的，否则就是不合格的，所以符合spec的代码也必然能通过根据spec所设计出的测试。同时，有了spec，客户端在使用所写的代码时就有所依据，客户端可以轻松的知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，而不必知道内部逻辑是怎么样的，大大节省了客户端使用自己的API时所需要的时间，并且降低了客户端对自己所编写的代码的误解。",
      "1.2 spec的结构",
      "方法的功能；",
      "前置条件，即方法参数的限制条件，使用@param说明每个参数的前置条件；",
      "后置条件，即当前置条件满足时，方法结束时必须满足的条件，使用@return说明正确的返回值，即后置条件；使用@throws说明出现什么样的错误情况会导致什么样的异常。",
      "1.3 spec中不能包含的部分",
      "spec不能暴露实现细节，不应该暴露局部变量，也不应该暴露私有的数据域，这些东西一旦暴露，就有可能给被非法的程序员利用，发现漏洞并实施攻击。",
      "【注】方法不应该改变输入参数的取值，如果改了，则必须在spec中做出说明。所以推荐使用immutable的对象，以及使用immutable类作为返回值类型。",
      "2 ADT的设计",
      "ADT的设计包括spec的设计、rep的设计以及implementation的设计，spec的设计上面已经提到，下面将介绍一些ADT相关的问题。",
      "2.1 RI",
      "Rep",
      "Invariant，即不变量集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。我们通常通过写checkRep()来随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。",
      "checkRep检查包括参数大小、参数是否为空、参数长度、参数中是否有",
      "2.2 表示泄露",
      "即client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。一般来说，方法中的变量如果是public的，那么很有可能会出现表示泄露。若某些getter函数并未采用防御式拷贝，则变量有可能被外部指针所引用，导致表示泄露。",
      "2.2 AF",
      "Abstraction",
      "Function，即从R空间到A空间存在一个映射，这个映射是一个满射，是将R中的每一个值解释为A中的一个值的映射。这个映射的解释函数就是AF。",
      "3 面向可维护性的设计模式",
      "3.1 Visitor",
      "对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。",
      "首先，设计相应扩展的Visitor接口，其中包括visit方法，该方法的参数为要扩展的方法类型，并且可复用。然后，设计一个CacuVisitor，实现Visitor接口中的方法，满足要扩展的功能条件。接着，在被扩展的方法中增加accept方法，即accept(Visitor",
      "visitor) { visitor.visit(this);",
      "}，即将自己传给visit。最后，在客户端调用accept(new CacuVisitor())即可。",
      "3.2 Strategy策略模式",
      "有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。",
      "首先，设计对应的扩展Strategy接口，接口中有相应的被扩展的方法select，该方法的参数与扩展前相同。然后，创建两个或多个不同的CacuStrategy方法，内部使用不同的策略来实现Strategy接口中的方法，分别满足原策略条件和要扩展的策略的功能条件。接着，在被扩展的方法参数中增加一个Strategy接口类型的参数，并将调用原策略方法的代码改为strategy.select(原参数)。最后，在客户端调用扩展方法时(原参数，new",
      "CacuStrategy)即可。",
      "3.3 Iterator迭代器模式",
      "客户端希望遍历被放入容器/集合类的一组ADT对象。",
      "实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。",
      "首先实现Iterator<遍历对象>的接口，然后实现iterator()方法，即public",
      "Iterator<遍历对象> iterator() { return new CacuIterator();}",
      "接着创建内部类来实现该接口：",
      "private class CacuIterator implements",
      "Iterator<Car>，在该类中要实现next()，hasNext()，remove()三个方法。",
      "3.4 Decorator装饰器模式",
      "每个子类实现不同的特性，因为这些特性都是多个维度上的个性化的特征，没办法做到在一个顶层的接口中完成所有特征的抽象，而且需要做到在各个维度上的特性的任意组合，此时光靠继承是没办法实现特性的组合的，如果要强行使用继承实现，那么面对的一个不可避免地问题是组合爆炸，因为每次继承只能扩展一个特性，多个特性就要多次继承实现，并且也不便于维护与扩展，而且会有大量的重复代码。",
      "首先创建一个类来实现接口的方法，然后再创建一个类，来继承刚刚创建的那个类，并在此类中添加修饰。可以在继承后的类中添加rep，即参数。",
      "3.5 Factory Method工厂模式",
      "解决的问题：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。",
      "定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。也可以通过直接定义静态工厂方法来创建子类实例。",
      "3.6 Adapter适配器模式",
      "将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。",
      "后续将继续添加。"
    ],
    "sentences": [
      "面向软件构造期末考试程序设计题的复习",
      "目录 1",
      "1 设计spec 1",
      "1.1 spec的重要性 1",
      "1.2 spec的结构 1",
      "1.3 spec中不能包含的部分 1",
      "2 ADT的设计 1",
      "2.1 RI 1",
      "2.2 表示泄露 2",
      "2.2 AF 2",
      "3 面向可维护性的设计模式 2",
      "3.1 Visitor 2",
      "3.2 Strategy策略模式 2",
      "3.3 Iterator迭代器模式 2",
      "3.4 Decorator装饰器模式 3",
      "3.5 Factory Method工厂模式 3",
      "3.6 Adapter适配器模式 3",
      "1 设计spec",
      "1.1 spec的重要性",
      "spec是程序员自己对所写的方法的规约",
      "它规定了方法应该做什么",
      "不应该做什么",
      "spec时是测试优先编程的基础",
      "因为程序员所编写的代码必定是符合spec的",
      "否则就是不合格的",
      "所以符合spec的代码也必然能通过根据spec所设计出的测试",
      "同时",
      "有了spec",
      "客户端在使用所写的代码时就有所依据",
      "客户端可以轻松的知道他需要为这个方法提供什么样的参数",
      "以及会得到什么样的结果",
      "而不必知道内部逻辑是怎么样的",
      "大大节省了客户端使用自己的API时所需要的时间",
      "并且降低了客户端对自己所编写的代码的误解",
      "1.2 spec的结构",
      "方法的功能；前置条件",
      "即方法参数的限制条件",
      "使用@param说明每个参数的前置条件；后置条件",
      "即当前置条件满足时",
      "方法结束时必须满足的条件",
      "使用@return说明正确的返回值",
      "即后置条件；使用@throws说明出现什么样的错误情况会导致什么样的异常",
      "1.3 spec中不能包含的部分",
      "spec不能暴露实现细节",
      "不应该暴露局部变量",
      "也不应该暴露私有的数据域",
      "这些东西一旦暴露",
      "就有可能给被非法的程序员利用",
      "发现漏洞并实施攻击",
      "【注】方法不应该改变输入参数的取值",
      "如果改了",
      "则必须在spec中做出说明",
      "所以推荐使用immutable的对象",
      "以及使用immutable类作为返回值类型",
      "2 ADT的设计",
      "ADT的设计包括spec的设计、rep的设计以及implementation的设计",
      "spec的设计上面已经提到",
      "下面将介绍一些ADT相关的问题",
      "2.1 RI",
      "Rep",
      "Invariant",
      "即不变量集合",
      "是R空间所有值的子集",
      "它包含了所有合法的表示值",
      "而只有满足RI的值",
      "才是合法值",
      "才会在A空间内有值与其对应",
      "我们通常通过写checkRep()来随时检查RI是否满足",
      "使用assert检查RI",
      "在所有的方法最好都加入调用这个检查方法",
      "checkRep()在检查时有可能耗费大量的时间影响性能",
      "所以只需要在开发阶段保留这部分",
      "checkRep检查包括参数大小、参数是否为空、参数长度、参数中是否有",
      "2.2 表示泄露",
      "即client可以拿到数据域的本身或别名",
      "一旦表示泄露",
      "client就有可能无意间改动数据",
      "而如果在设计中",
      "要求一个ADT是Immutable的",
      "而如果它出现了表示泄露",
      "就有可能违反Immutable的原则",
      "一般来说",
      "方法中的变量如果是public的",
      "那么很有可能会出现表示泄露",
      "若某些getter函数并未采用防御式拷贝",
      "则变量有可能被外部指针所引用",
      "导致表示泄露",
      "2.2 AF",
      "Abstraction",
      "Function",
      "即从R空间到A空间存在一个映射",
      "这个映射是一个满射",
      "是将R中的每一个值解释为A中的一个值的映射",
      "这个映射的解释函数就是AF",
      "3 面向可维护性的设计模式",
      "3.1 Visitor",
      "对特定类型的object的特定操作(visit)",
      "在运行时将二者动态绑定到一起",
      "该操作可以灵活更改",
      "无需更改被visit的类",
      "首先",
      "设计相应扩展的Visitor接口",
      "其中包括visit方法",
      "该方法的参数为要扩展的方法类型",
      "并且可复用",
      "然后",
      "设计一个CacuVisitor",
      "实现Visitor接口中的方法",
      "满足要扩展的功能条件",
      "接着",
      "在被扩展的方法中增加accept方法",
      "即accept(Visitor",
      "visitor) { visitor.visit(this);}",
      "即将自己传给visit",
      "最后",
      "在客户端调用accept(new CacuVisitor())即可",
      "3.2 Strategy策略模式",
      "有多种不同的算法来实现同一个任务",
      "但需要client根据需要动态切换算法",
      "而不是写死在代码里",
      "因此可以为不同的实现算法构造抽象接口",
      "利用delegation",
      "运行时动态传入client倾向的算法类实例",
      "首先",
      "设计对应的扩展Strategy接口",
      "接口中有相应的被扩展的方法select",
      "该方法的参数与扩展前相同",
      "然后",
      "创建两个或多个不同的CacuStrategy方法",
      "内部使用不同的策略来实现Strategy接口中的方法",
      "分别满足原策略条件和要扩展的策略的功能条件",
      "接着",
      "在被扩展的方法参数中增加一个Strategy接口类型的参数",
      "并将调用原策略方法的代码改为strategy.select(原参数)",
      "最后，在客户端调用扩展方法时(原参数，new",
      "CacuStrategy)即可",
      "3.3 Iterator迭代器模式",
      "客户端希望遍历被放入容器/集合类的一组ADT对象",
      "实现方式是在ADT类中实现Iterable接口",
      "该接口内部只有一个返回一个迭代器的方法",
      "然后创建一个迭代器类实现Iterator接口",
      "实现hasnext()、next()、remove()这三个方法",
      "首先实现Iterator<遍历对象>的接口",
      "然后实现iterator()方法",
      "即public",
      "Iterator<遍历对象> iterator() { return new CacuIterator();}",
      "接着创建内部类来实现该接口：private class CacuIterator implements",
      "Iterator<Car>",
      "在该类中要实现next()",
      "hasNext()",
      "remove()三个方法",
      "3.4 Decorator装饰器模式",
      "每个子类实现不同的特性",
      "因为这些特性都是多个维度上的个性化的特征",
      "没办法做到在一个顶层的接口中完成所有特征的抽象",
      "而且需要做到在各个维度上的特性的任意组合",
      "此时光靠继承是没办法实现特性的组合的",
      "如果要强行使用继承实现",
      "那么面对的一个不可避免地问题是组合爆炸",
      "因为每次继承只能扩展一个特性",
      "多个特性就要多次继承实现",
      "并且也不便于维护与扩展",
      "而且会有大量的重复代码",
      "首先创建一个类来实现接口的方法",
      "然后再创建一个类",
      "来继承刚刚创建的那个类",
      "并在此类中添加修饰",
      "可以在继承后的类中添加rep，即参数",
      "3.5 Factory Method工厂模式",
      "解决的问题：当client不知道要创建哪个具体类的实例",
      "或者不想在client代码中指明要具体创建的实例时",
      "用工厂方法",
      "定义一个用于创建对象的接口",
      "让其子类来决定实例化哪一个类",
      "从而使一个类的实例化延迟到其子类",
      "也可以通过直接定义静态工厂方法来创建子类实例",
      "3.6 Adapter适配器模式",
      "将某个类/接口转换为client期望的其他形式",
      "通过增加一个接口",
      "将已存在的子类封装起来",
      "client面向接口编程",
      "从而隐藏了具体子类",
      "因为Adaptee是不匹配客户端所需求的",
      "可能是参数上的",
      "所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作",
      "这就是Adapter",
      "它接受客户端的功能请求但是不会做具体的功能实现",
      "而是把客户端所提供的参数转换成Adaptee所接受的形式",
      "然后将任务委派给Adaptee完成",
      "后续将继续添加"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "面向软件构造期末考试程序设计题的复习\n目录 1\n1 设计spec 1\n1.1 spec的重要性 1\n1.2 spec的结构 1\n1.3 spec中不能包含的部分 1\n2 ADT的设计 1\n2.1 RI 1\n2.2 表示泄露 2\n2.2 AF 2\n3 面向可维护性的设计模式 2\n3.1 Visitor 2\n3.2 Strategy策略模式 2\n3.3 Iterator迭代器模式 2\n3.4 Decorator装饰器模式 3\n3.5 Factory Method工厂模式 3\n3.6 Adapter适配器模式 3\n1 设计spec\n1.1 spec的重要性\nspec是程序员自己对所写的方法的规约，它规定了方法应该做什么，不应该做什么。spec时是测试优先编程的基础，因为程序员所编写的代码必定是符合spec的，否则就是不合格的，所以符合spec的代码也必然能通过根据spec所设计出的测试。同时，有了spec，客户端在使用所写的代码时就有所依据，客户端可以轻松的知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，而不必知道内部逻辑是怎么样的，大大节省了客户端使用自己的API时所需要的时间，并且降低了客户端对自己所编写的代码的误解。\n1.2 spec的结构\n方法的功能；\n前置条件，即方法参数的限制条件，使用@param说明每个参数的前置条件；\n后置条件，即当前置条件满足时，方法结束时必须满足的条件，使用@return说明正确的返回值，即后置条件；使用@throws说明出现什么样的错误情况会导致什么样的异常。\n1.3 spec中不能包含的部分\nspec不能暴露实现细节，不应该暴露局部变量，也不应该暴露私有的数据域，这些东西一旦暴露，就有可能给被非法的程序员利用，发现漏洞并实施攻击。\n【注】方法不应该改变输入参数的取值，如果改了，则必须在spec中做出说明。所以推荐使用immutable的对象，以及使用immutable类作为返回值类型。\n2 ADT的设计\nADT的设计包括spec的设计、rep的设计以及implementation的设计，spec的设计上面已经提到，下面将介绍一些ADT相关的问题。\n2.1 RI\nRep\nInvariant，即不变量集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。我们通常通过写checkRep()来随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。\ncheckRep检查包括参数大小、参数是否为空、参数长度、参数中是否有\n2.2 表示泄露\n即client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。一般来说，方法中的变量如果是public的，那么很有可能会出现表示泄露。若某些getter函数并未采用防御式拷贝，则变量有可能被外部指针所引用，导致表示泄露。\n2.2 AF\nAbstraction\nFunction，即从R空间到A空间存在一个映射，这个映射是一个满射，是将R中的每一个值解释为A中的一个值的映射。这个映射的解释函数就是AF。\n3 面向可维护性的设计模式\n3.1 Visitor\n对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。\n首先，设计相应扩展的Visitor接口，其中包括visit方法，该方法的参数为要扩展的方法类型，并且可复用。然后，设计一个CacuVisitor，实现Visitor接口中的方法，满足要扩展的功能条件。接着，在被扩展的方法中增加accept方法，即accept(Visitor\nvisitor) { visitor.visit(this);\n}，即将自己传给visit。最后，在客户端调用accept(new CacuVisitor())即可。\n3.2 Strategy策略模式\n有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。\n首先，设计对应的扩展Strategy接口，接口中有相应的被扩展的方法select，该方法的参数与扩展前相同。然后，创建两个或多个不同的CacuStrategy方法，内部使用不同的策略来实现Strategy接口中的方法，分别满足原策略条件和要扩展的策略的功能条件。接着，在被扩展的方法参数中增加一个Strategy接口类型的参数，并将调用原策略方法的代码改为strategy.select(原参数)。最后，在客户端调用扩展方法时(原参数，new\nCacuStrategy)即可。\n3.3 Iterator迭代器模式\n客户端希望遍历被放入容器/集合类的一组ADT对象。\n实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。\n首先实现Iterator<遍历对象>的接口，然后实现iterator()方法，即public\nIterator<遍历对象> iterator() { return new CacuIterator();}\n接着创建内部类来实现该接口：\nprivate class CacuIterator implements\nIterator<Car>，在该类中要实现next()，hasNext()，remove()三个方法。\n3.4 Decorator装饰器模式\n每个子类实现不同的特性，因为这些特性都是多个维度上的个性化的特征，没办法做到在一个顶层的接口中完成所有特征的抽象，而且需要做到在各个维度上的特性的任意组合，此时光靠继承是没办法实现特性的组合的，如果要强行使用继承实现，那么面对的一个不可避免地问题是组合爆炸，因为每次继承只能扩展一个特性，多个特性就要多次继承实现，并且也不便于维护与扩展，而且会有大量的重复代码。\n首先创建一个类来实现接口的方法，然后再创建一个类，来继承刚刚创建的那个类，并在此类中添加修饰。可以在继承后的类中添加rep，即参数。\n3.5 Factory Method工厂模式\n解决的问题：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。\n定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。也可以通过直接定义静态工厂方法来创建子类实例。\n3.6 Adapter适配器模式\n将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。\n后续将继续添加。\n"
  },
  {
    "head": "Lab2中遇到的困难及相关知识",
    "paragraphs": [
      "Lab2中遇到的困难及相关知识",
      "1 对一些对象类型的不熟悉 1",
      "1.1 Queue 1",
      "1.2 Set 1",
      "1.3 List 2",
      "1.4 Map 2",
      "2 循环遍历 2",
      "2.1 普通for循环 3",
      "2.2 加强for循环 3",
      "2.3 迭代器Iterator 3",
      "总结 3",
      "1 对一些对象类型的不熟悉",
      "1.1 Queue",
      "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，有先进先出的特点。",
      "其常用方法如下：",
      "add()：将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回",
      "true，如果当前没有可用的空间，则抛出 IllegalStateException。",
      "element()：获取，但是不移除此队列的头。",
      "offer()：将指定的元素插入此队列（如果立即可行且不会违反容量制），当使用有容量限制的队列时，此方法通常要优于",
      "add(E)，后者可能无法插入元素，而只是抛出一个异常。",
      "peek()：获取但不移除此队列的头；如果此队列为空，则返回 null。",
      "poll()：获取并移除此队列的头，如果此队列为空，则返回 null",
      "remove()：获取并移除此队列的头。",
      "1.2 Set",
      "Set继承于Collection接口，是一个不允许出现重复元素，并且无序的集合。",
      "其常用方法如下：",
      "add( )： 向集合中添加元素",
      "clear( )：去掉集合中所有的元素",
      "contains( )：判断集合中是否包含某一个元素",
      "isEmpty( )：判断集合是否为空",
      "remove( )：从集合中去掉特定的对象",
      "size( )：返回集合的大小",
      "1.3 List",
      "List",
      "是一个接口，它继承于Collection的接口。它代表着有序的队列。当我们讨论List的时候，一般都和Set作比较。",
      "List中元素可以重复，并且是有序的（这里的有序指的是按照放入的顺序进行存储。如按照顺序把1，2，3存入List，那么，从List中遍历出来的顺序也是1，2，3）。而Set中的元素不可以重复，并且是无序的（从set中遍历出来的数据和放入顺序没有关系）。",
      "List的常用方法：",
      "add( )： 向List的指定位置插入元素",
      "get()：返回list中指定位置的元素",
      "set()：修改List中的某一指定位置的元素",
      "isEmpty( )：判断List是否为空",
      "remove( )：从List中去掉特定的对象",
      "size( )：返回List的大小",
      "1.4 Map",
      "Map是将键映射到值的对象的数据结构，一个映射不能包含重复的键，且每个键最多只能映射到一个值。",
      "Map的常用方法：",
      "put()：添加映射对",
      "get()：根据键来获取其映射的值",
      "containsKey()：判断Map中是否有指定键值",
      "containsValue()：判断Map中是否有指定的值",
      "remove()：从Map中去掉特定的对象",
      "keySet()：获得键的集合",
      "values()：获得值的集合",
      "isEmpty()：判断Map是否为空",
      "entrySet()：返回Map中的元素对",
      "2 循环遍历",
      "循环遍历中的加强for循环以及迭代器遍历是我之前没有用的循环遍历方式。",
      "2.1 普通for循环",
      "类似于for (int i = 0;i < n;i++)的循环遍历；",
      "2.2 加强for循环",
      "类似于for (String str : list)的循环遍历；",
      "值得注意的是，在加强for循环的过程中，只能观察被遍历的元素的值，并不能对其进行删除等操作，否则会发生意料之外的事情。",
      "2.3 迭代器Iterator",
      "例如如下程序：",
      "本章回顾了我在做Lab2时遇到的两个主要的困难以及与它们相关的知识。"
    ],
    "sentences": [
      "Lab2中遇到的困难及相关知识",
      "1 对一些对象类型的不熟悉 1",
      "1.1 Queue 1",
      "1.2 Set 1",
      "1.3 List 2",
      "1.4 Map 2",
      "2 循环遍历 2",
      "2.1 普通for循环 3",
      "2.2 加强for循环 3",
      "2.3 迭代器Iterator 3",
      "总结 3",
      "1 对一些对象类型的不熟悉",
      "1.1 Queue",
      "队列是一种特殊的线性表",
      "它只允许在表的前端进行删除操作",
      "而在表的后端进行插入操作",
      "有先进先出的特点",
      "其常用方法如下：add()：将指定的元素插入此队列（如果立即可行且不会违反容量限制）",
      "在成功时返回",
      "true",
      "如果当前没有可用的空间",
      "则抛出 IllegalStateException",
      "element()：获取，但是不移除此队列的头",
      "offer()：将指定的元素插入此队列（如果立即可行且不会违反容量制）",
      "当使用有容量限制的队列时",
      "此方法通常要优于",
      "add(E)，后者可能无法插入元素，而只是抛出一个异常",
      "peek()：获取但不移除此队列的头；如果此队列为空",
      "则返回 null",
      "poll()：获取并移除此队列的头",
      "如果此队列为空",
      "则返回 null",
      "remove()：获取并移除此队列的头",
      "1.2 Set",
      "Set继承于Collection接口",
      "是一个不允许出现重复元素",
      "并且无序的集合",
      "其常用方法如下：add( )： 向集合中添加元素",
      "clear( )：去掉集合中所有的元素",
      "contains( )：判断集合中是否包含某一个元素",
      "isEmpty( )：判断集合是否为空",
      "remove( )：从集合中去掉特定的对象",
      "size( )：返回集合的大小",
      "1.3 List",
      "List",
      "是一个接口，它继承于Collection的接口",
      "它代表着有序的队列",
      "当我们讨论List的时候，一般都和Set作比较",
      "List中元素可以重复",
      "并且是有序的（这里的有序指的是按照放入的顺序进行存储",
      "如按照顺序把1",
      "2",
      "3存入List",
      "那么",
      "从List中遍历出来的顺序也是1",
      "2",
      "3）",
      "而Set中的元素不可以重复",
      "并且是无序的（从set中遍历出来的数据和放入顺序没有关系）",
      "List的常用方法：add( )： 向List的指定位置插入元素",
      "get()：返回list中指定位置的元素",
      "set()：修改List中的某一指定位置的元素",
      "isEmpty( )：判断List是否为空",
      "remove( )：从List中去掉特定的对象",
      "size( )：返回List的大小",
      "1.4 Map",
      "Map是将键映射到值的对象的数据结构",
      "一个映射不能包含重复的键",
      "且每个键最多只能映射到一个值",
      "Map的常用方法：put()：添加映射对",
      "get()：根据键来获取其映射的值",
      "containsKey()：判断Map中是否有指定键值",
      "containsValue()：判断Map中是否有指定的值",
      "remove()：从Map中去掉特定的对象",
      "keySet()：获得键的集合",
      "values()：获得值的集合",
      "isEmpty()：判断Map是否为空",
      "entrySet()：返回Map中的元素对",
      "2 循环遍历",
      "循环遍历中的加强for循环以及迭代器遍历是我之前没有用的循环遍历方式",
      "2.1 普通for循环",
      "类似于for (int i = 0;i < n;i++)的循环遍历；2.2 加强for循环",
      "类似于for (String str : list)的循环遍历；值得注意的是",
      "在加强for循环的过程中",
      "只能观察被遍历的元素的值",
      "并不能对其进行删除等操作",
      "否则会发生意料之外的事情",
      "2.3 迭代器Iterator",
      "例如如下程序：本章回顾了我在做Lab2时遇到的两个主要的困难以及与它们相关的知识"
    ],
    "codes": [
      "Iterator<String> it = list.iterator();",
      "while(it.hasNext()){",
      "String x = it.next();",
      "if(x.equals(“del”)){",
      "it.remove();"
    ],
    "date": "2021-07-07",
    "text": "Lab2中遇到的困难及相关知识\n1 对一些对象类型的不熟悉 1\n1.1 Queue 1\n1.2 Set 1\n1.3 List 2\n1.4 Map 2\n2 循环遍历 2\n2.1 普通for循环 3\n2.2 加强for循环 3\n2.3 迭代器Iterator 3\n总结 3\n1 对一些对象类型的不熟悉\n1.1 Queue\n队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，有先进先出的特点。\n其常用方法如下：\nadd()：将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回\ntrue，如果当前没有可用的空间，则抛出 IllegalStateException。\nelement()：获取，但是不移除此队列的头。\noffer()：将指定的元素插入此队列（如果立即可行且不会违反容量制），当使用有容量限制的队列时，此方法通常要优于\nadd(E)，后者可能无法插入元素，而只是抛出一个异常。\npeek()：获取但不移除此队列的头；如果此队列为空，则返回 null。\npoll()：获取并移除此队列的头，如果此队列为空，则返回 null\nremove()：获取并移除此队列的头。\n1.2 Set\nSet继承于Collection接口，是一个不允许出现重复元素，并且无序的集合。\n其常用方法如下：\nadd( )： 向集合中添加元素\nclear( )：去掉集合中所有的元素\ncontains( )：判断集合中是否包含某一个元素\nisEmpty( )：判断集合是否为空\nremove( )：从集合中去掉特定的对象\nsize( )：返回集合的大小\n1.3 List\nList\n是一个接口，它继承于Collection的接口。它代表着有序的队列。当我们讨论List的时候，一般都和Set作比较。\nList中元素可以重复，并且是有序的（这里的有序指的是按照放入的顺序进行存储。如按照顺序把1，2，3存入List，那么，从List中遍历出来的顺序也是1，2，3）。而Set中的元素不可以重复，并且是无序的（从set中遍历出来的数据和放入顺序没有关系）。\nList的常用方法：\nadd( )： 向List的指定位置插入元素\nget()：返回list中指定位置的元素\nset()：修改List中的某一指定位置的元素\nisEmpty( )：判断List是否为空\nremove( )：从List中去掉特定的对象\nsize( )：返回List的大小\n1.4 Map\nMap是将键映射到值的对象的数据结构，一个映射不能包含重复的键，且每个键最多只能映射到一个值。\nMap的常用方法：\nput()：添加映射对\nget()：根据键来获取其映射的值\ncontainsKey()：判断Map中是否有指定键值\ncontainsValue()：判断Map中是否有指定的值\nremove()：从Map中去掉特定的对象\nkeySet()：获得键的集合\nvalues()：获得值的集合\nisEmpty()：判断Map是否为空\nentrySet()：返回Map中的元素对\n2 循环遍历\n循环遍历中的加强for循环以及迭代器遍历是我之前没有用的循环遍历方式。\n2.1 普通for循环\n类似于for (int i = 0;i < n;i++)的循环遍历；\n2.2 加强for循环\n类似于for (String str : list)的循环遍历；\n值得注意的是，在加强for循环的过程中，只能观察被遍历的元素的值，并不能对其进行删除等操作，否则会发生意料之外的事情。\n2.3 迭代器Iterator\n例如如下程序：\n本章回顾了我在做Lab2时遇到的两个主要的困难以及与它们相关的知识。\n"
  },
  {
    "head": "哈工大 软件构造Lab1的设计实现",
    "paragraphs": [
      "2021年春季学期",
      "计算学部《软件构造》课程",
      "Lab 1实验报告",
      "1. 实验目标概述 3",
      "2. 实验环境配置 3",
      "3. 实验过程 6",
      "3.1 Magic Squares 6",
      "3.1.1 isLegalMagicSquare() 6",
      "3.1.2 generateMagicSquare() 8",
      "3.2 Turtle Graphics 10",
      "3.2.1 Problem 1: Clone and import 10",
      "3.2.2 Problem 3: Turtle graphics and drawSquare 10",
      "3.2.3 Problem 5: Drawing polygons 11",
      "3.2.4 Problem 6: Calculating Bearings 11",
      "3.2.5 Problem 7: Convex Hulls 12",
      "3.2.6 Problem 8: Personal art 12",
      "3.2.7 Submitting 14",
      "3.3 Social Network 14",
      "3.3.1 设计/实现FriendshipGraph类 14",
      "3.3.2 设计/实现Person类 15",
      "3.3.3 设计/实现客户端代码main() 16",
      "3.3.4 设计/实现测试用例 17",
      "4. 实验进度记录 18",
      "5. 实验过程中遇到的困难与解决途径 19",
      "6. 实验过程中收获的经验、教训、感想 19",
      "6.1 实验过程中收获的经验和教训 19",
      "6.2 针对以下方面的感受 19",
      "实验目标概述",
      "本次实验通过求解三个问题，训练基本 Java 编程技能，能够利用 Java OO 开",
      "发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够",
      "为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。",
      "另一方面，利用 Git 作为代码配置管理的工具，学会 Git 的基本使用方法。",
      "⚫ 基本的 Java OO 编程",
      "⚫ 基于 Eclipse IDE 进行 Java 编程",
      "⚫ 基于 JUnit 的测试",
      "⚫ 基于 Git 的代码配置管理",
      "实验环境配置",
      "在这里给出你的GitHub Lab1仓库的URL地址。",
      "https://github.com/ComputerScienceHIT/HIT-Lab1-1190200828",
      "实验过程",
      "Magic Squares",
      "该任务的目标：设计isLegalMagicSquare()函数，判定给定的几个矩阵是否为magic",
      "square；将给定的生成奇数阶的magic",
      "square的generateMagicSquare()函数作为静态函数加入我的程序代码中，将生成的矩阵存入6.txt并调用isLegalMagicSquare()判断所生成的矩阵是否正确。该阶段涉及到文件读写操作、对某些特定函数的调用（例如split等）、对部分异常的处理（例如矩阵中有负数、浮点数，或是行列数不相等）等。",
      "isLegalMagicSquare()",
      "1.根据实验要求，我不能上来直接就去用magic矩阵的定义去判断其正确性，即每行每列每个对角线的元素和都相等；而是应该先判断给定的矩阵是否合理，即判断行列数是否相等、矩阵中是否有浮点数、负数等。由此，我的想法是设置一个整型变量n = 0，对于txt文件先按行读入，每读入一行n++，直到读完文件，此时n的值即为矩阵行数。然后，依旧是按行读入文件，每读入一行，将其存入String line中，并调用split(“\\t”)将其分割并存入String[] line_cut，比较行数n与line_cut.length，不相等则输出错误提示并返回false，后经过测试，当文件未用”\\t”进行分割时，也会导n != line_cut.length，因此在这里一并输出错误提示；然后判断line_cut中的每一个元素是否都是正整数，按位寻访line_cut，若出现某一位不在数字字符’0’-‘9’中，则输出错误提示并返回false。综上所述，即有如下代码：",
      "以上错误判断完毕后，将读入的文档存入矩阵magic中，并按照magic矩阵定义进行测试，若不符合magic矩阵定义，则返回false。注意，在此过程中，并未输出错误提示，表示矩阵本身不存在行列数不相等等错误。于是有以下代码：",
      "至此，isLegalMagicSquare()函数设计完毕；",
      "结果展示：",
      "generateMagicSquare()",
      "程序代码已经在ppt中给出，程序流程图如下：",
      "除该程序代码外，需对该函数的输入进行测试，以防输入为偶数或负数。该测试在我的main函数中完成，输入阶数为负数或偶数或输入阶数小于2时输出错误提示并予以重新输入，但是，如果输入根本并非整数，而是浮点数或字符时，则输出错误提示且不允许重新输入，于是有如下代码：",
      "除此之外，还需要在函数中加入文件写入操作，将产生的magic矩阵存入6.txt以便于main函数中测试其生成的magic矩阵的正确性，添加的代码如下：",
      "结果展示：",
      "Turtle Graphics",
      "该任务的目标：clone已有的程序后，利用turtle按照要求画图，主要需要修改及再编程的是TurtleSoup类，其中的一些函数编程时需要结合我们已有的数学几何知识、TurtleSoup类中的提示信息以及测试用的TurtleSoupTest类中的提示信息，最后可以发挥想象力进行自己的创作。",
      "Problem 1: Clone and import",
      "从github获取代码",
      "由于clone出现问题，找不到实验报告上给的那个链接，所以我进入该链接后，将代码逐个复制到我的程序类中。",
      "初始化本地仓库",
      "git init",
      "Problem 3: Turtle graphics and drawSquare",
      "该函数需要实现：已知边长，画出边长为指定数值的正方形。参数是海龟对象turtle和边长sideLength。",
      "循环执行，每次画笔直行sideLength距离，然后画笔方向旋转90度，循环执行4次后即可得到所需要的正方形，函数代码如下：",
      "结果展示（sideLength = 40）：",
      "Problem 5: Drawing polygons",
      "首先，要求计算已知正多边形边数的内角度，该计算由已知公式可以推导，因此相关函数代码如下：",
      "根据正方形的画法，只需要将画笔的转向角度设置为180 –",
      "内角度数，循环多边形边数次数即可。考虑到画笔转向既能是顺时针又能是逆时针，故在此声明：sides可为负数，且当sides为负整数时，代表着画笔将逆时针旋转，且旋转度数为180",
      "– 内角度数，并且取sides的绝对值为正多边形边数。函数代码如下：",
      "Problem 6: Calculating Bearings",
      "首先，已知起点和当前朝向角度，要求起点到终点需要转动的角度。根据几何运算，得函数代码如下：",
      "上述问题的扩展：此时有若干个点，要求从第一个点开始到第二个点，再从第二个点到第三个点……以此类推每次转向的角度。以起点为第一个点，循环n-1次，每次将第i+1号点设置为“终点”，通过上一个函数计算旋转角度并存储到List中，将下一次的“起点”用当前“终点”更新，继续循环。程序代码如下：",
      "Problem 7: Convex Hulls",
      "由凸包算法（CSDN（",
      "ConvexHull凸包算法之Gift-Wrapping_Innovative",
      "Workstation-CSDN博客",
      "）上查阅），可得该函数代码为：",
      "Problem 8: Personal art",
      "函数代码：",
      "结果展示：",
      "Submitting",
      "由于第一次提交时已经进行过初始化以及与我的云仓库的关联，本次提交中只需要添加文件、注释以及提交三个步骤。",
      "Social Network",
      "该任务的目标：设计一张社交网络无向图，连接互为朋友的人与人，并且能计算任意两人之间需要的最少的关联路径。于是，该问题为最短路径问题，而构建的图为无向无权图，所以利用DFS深度优先遍历即可得到两点间的最短路径。",
      "设计/实现FriendshipGraph类",
      "存储图中的人姓名的集合：",
      "addVertex()函数：首先判断Person",
      "p是否在图中，若已经存在于图中，则输出错误信息，程序结束；否则将p添加至person中。",
      "addEdge()函数：在a、b的朋友列表里分别加入彼此。",
      "getDistance()函数：DFS深度优先算法求最短路径",
      "设计/实现Person类",
      "Person类包括：",
      "Person()：包括这个人的名字p_name，这个人的朋友列表friends；",
      "IsFriendOf(Person p)：在p_name的朋友列表里加入p；",
      "设计/实现客户端代码main()",
      "由ppt给出：",
      "设计/实现测试用例",
      "思想：将a通过addVertex()函数加入testGraph1中，b不加入，因此，测试用例为a在testGraph1.person中，b不在；",
      "思想：将a、b通过addVertex()函数加入testGraph1中，调用addEdge()函数，在a、b加一条线，即关联在一起，那么，a、b的朋友列表将包含彼此，因此测试用例中，a在b.friends中，b也在a.friends中；",
      "思想：getDistance测试中应包括自己与自己、相互认识的两人、相互不认识但是有中间人关联的两人以及互不相干的两人；",
      "测试结果：",
      "至此，实验设计结束。"
    ],
    "sentences": [
      "2021年春季学期",
      "计算学部《软件构造》课程",
      "Lab 1实验报告",
      "1. 实验目标概述 3",
      "2. 实验环境配置 3",
      "3. 实验过程 6",
      "3.1 Magic Squares 6",
      "3.1.1 isLegalMagicSquare() 6",
      "3.1.2 generateMagicSquare() 8",
      "3.2 Turtle Graphics 10",
      "3.2.1 Problem 1: Clone and import 10",
      "3.2.2 Problem 3: Turtle graphics and drawSquare 10",
      "3.2.3 Problem 5: Drawing polygons 11",
      "3.2.4 Problem 6: Calculating Bearings 11",
      "3.2.5 Problem 7: Convex Hulls 12",
      "3.2.6 Problem 8: Personal art 12",
      "3.2.7 Submitting 14",
      "3.3 Social Network 14",
      "3.3.1 设计/实现FriendshipGraph类 14",
      "3.3.2 设计/实现Person类 15",
      "3.3.3 设计/实现客户端代码main() 16",
      "3.3.4 设计/实现测试用例 17",
      "4. 实验进度记录 18",
      "5. 实验过程中遇到的困难与解决途径 19",
      "6. 实验过程中收获的经验、教训、感想 19",
      "6.1 实验过程中收获的经验和教训 19",
      "6.2 针对以下方面的感受 19",
      "实验目标概述",
      "本次实验通过求解三个问题",
      "训练基本 Java 编程技能",
      "能够利用 Java OO 开",
      "发基本的功能模块",
      "能够阅读理解已有代码框架并根据功能需求补全代码",
      "能够",
      "为所开发的代码编写基本的测试程序并完成测试",
      "初步保证所开发代码的正确性",
      "另一方面",
      "利用 Git 作为代码配置管理的工具",
      "学会 Git 的基本使用方法",
      "⚫ 基本的 Java OO 编程",
      "⚫ 基于 Eclipse IDE 进行 Java 编程",
      "⚫ 基于 JUnit 的测试",
      "⚫ 基于 Git 的代码配置管理",
      "实验环境配置",
      "在这里给出你的GitHub Lab1仓库的URL地址",
      "https://github.com/ComputerScienceHIT/HIT-Lab1-1190200828",
      "实验过程",
      "Magic Squares",
      "该任务的目标：设计isLegalMagicSquare()函数",
      "判定给定的几个矩阵是否为magic",
      "square；将给定的生成奇数阶的magic",
      "square的generateMagicSquare()函数作为静态函数加入我的程序代码中",
      "将生成的矩阵存入6.txt并调用isLegalMagicSquare()判断所生成的矩阵是否正确",
      "该阶段涉及到文件读写操作、对某些特定函数的调用（例如split等）、对部分异常的处理（例如矩阵中有负数、浮点数",
      "或是行列数不相等）等",
      "isLegalMagicSquare()",
      "1.根据实验要求",
      "我不能上来直接就去用magic矩阵的定义去判断其正确性",
      "即每行每列每个对角线的元素和都相等；而是应该先判断给定的矩阵是否合理",
      "即判断行列数是否相等、矩阵中是否有浮点数、负数等",
      "由此",
      "我的想法是设置一个整型变量n = 0",
      "对于txt文件先按行读入",
      "每读入一行n++",
      "直到读完文件",
      "此时n的值即为矩阵行数",
      "然后",
      "依旧是按行读入文件",
      "每读入一行",
      "将其存入String line中",
      "并调用split(“\\t”)将其分割并存入String[] line_cut",
      "比较行数n与line_cut.length",
      "不相等则输出错误提示并返回false",
      "后经过测试",
      "当文件未用”\\t”进行分割时",
      "也会导n != line_cut.length",
      "因此在这里一并输出错误提示；然后判断line_cut中的每一个元素是否都是正整数",
      "按位寻访line_cut",
      "若出现某一位不在数字字符’0’-‘9’中",
      "则输出错误提示并返回false",
      "综上所述",
      "即有如下代码：以上错误判断完毕后",
      "将读入的文档存入矩阵magic中",
      "并按照magic矩阵定义进行测试",
      "若不符合magic矩阵定义",
      "则返回false",
      "注意",
      "在此过程中",
      "并未输出错误提示",
      "表示矩阵本身不存在行列数不相等等错误",
      "于是有以下代码：至此",
      "isLegalMagicSquare()函数设计完毕；结果展示：generateMagicSquare()",
      "程序代码已经在ppt中给出",
      "程序流程图如下：除该程序代码外",
      "需对该函数的输入进行测试",
      "以防输入为偶数或负数",
      "该测试在我的main函数中完成",
      "输入阶数为负数或偶数或输入阶数小于2时输出错误提示并予以重新输入",
      "但是",
      "如果输入根本并非整数",
      "而是浮点数或字符时",
      "则输出错误提示且不允许重新输入",
      "于是有如下代码：除此之外",
      "还需要在函数中加入文件写入操作",
      "将产生的magic矩阵存入6.txt以便于main函数中测试其生成的magic矩阵的正确性",
      "添加的代码如下：结果展示：Turtle Graphics",
      "该任务的目标：clone已有的程序后",
      "利用turtle按照要求画图",
      "主要需要修改及再编程的是TurtleSoup类",
      "其中的一些函数编程时需要结合我们已有的数学几何知识、TurtleSoup类中的提示信息以及测试用的TurtleSoupTest类中的提示信息",
      "最后可以发挥想象力进行自己的创作",
      "Problem 1: Clone and import",
      "从github获取代码",
      "由于clone出现问题",
      "找不到实验报告上给的那个链接",
      "所以我进入该链接后",
      "将代码逐个复制到我的程序类中",
      "初始化本地仓库",
      "git init",
      "Problem 3: Turtle graphics and drawSquare",
      "该函数需要实现：已知边长，画出边长为指定数值的正方形",
      "参数是海龟对象turtle和边长sideLength",
      "循环执行",
      "每次画笔直行sideLength距离",
      "然后画笔方向旋转90度",
      "循环执行4次后即可得到所需要的正方形",
      "函数代码如下：结果展示（sideLength = 40）：Problem 5: Drawing polygons",
      "首先",
      "要求计算已知正多边形边数的内角度",
      "该计算由已知公式可以推导",
      "因此相关函数代码如下：根据正方形的画法",
      "只需要将画笔的转向角度设置为180 –",
      "内角度数，循环多边形边数次数即可",
      "考虑到画笔转向既能是顺时针又能是逆时针",
      "故在此声明：sides可为负数",
      "且当sides为负整数时",
      "代表着画笔将逆时针旋转",
      "且旋转度数为180",
      "– 内角度数，并且取sides的绝对值为正多边形边数",
      "函数代码如下：Problem 6: Calculating Bearings",
      "首先，已知起点和当前朝向角度，要求起点到终点需要转动的角度",
      "根据几何运算",
      "得函数代码如下：上述问题的扩展：此时有若干个点",
      "要求从第一个点开始到第二个点",
      "再从第二个点到第三个点……以此类推每次转向的角度",
      "以起点为第一个点",
      "循环n-1次",
      "每次将第i+1号点设置为“终点”",
      "通过上一个函数计算旋转角度并存储到List中",
      "将下一次的“起点”用当前“终点”更新",
      "继续循环",
      "程序代码如下：Problem 7: Convex Hulls",
      "由凸包算法（CSDN（",
      "ConvexHull凸包算法之Gift-Wrapping_Innovative",
      "Workstation-CSDN博客",
      "）上查阅）",
      "可得该函数代码为：Problem 8: Personal art",
      "函数代码：结果展示：Submitting",
      "由于第一次提交时已经进行过初始化以及与我的云仓库的关联",
      "本次提交中只需要添加文件、注释以及提交三个步骤",
      "Social Network",
      "该任务的目标：设计一张社交网络无向图",
      "连接互为朋友的人与人",
      "并且能计算任意两人之间需要的最少的关联路径",
      "于是",
      "该问题为最短路径问题",
      "而构建的图为无向无权图",
      "所以利用DFS深度优先遍历即可得到两点间的最短路径",
      "设计/实现FriendshipGraph类",
      "存储图中的人姓名的集合：addVertex()函数：首先判断Person",
      "p是否在图中",
      "若已经存在于图中",
      "则输出错误信息",
      "程序结束；否则将p添加至person中",
      "addEdge()函数：在a、b的朋友列表里分别加入彼此",
      "getDistance()函数：DFS深度优先算法求最短路径",
      "设计/实现Person类",
      "Person类包括：Person()：包括这个人的名字p_name",
      "这个人的朋友列表friends；IsFriendOf(Person p)：在p_name的朋友列表里加入p；设计/实现客户端代码main()",
      "由ppt给出：设计/实现测试用例",
      "思想：将a通过addVertex()函数加入testGraph1中",
      "b不加入",
      "因此",
      "测试用例为a在testGraph1.person中",
      "b不在；思想：将a、b通过addVertex()函数加入testGraph1中",
      "调用addEdge()函数",
      "在a、b加一条线",
      "即关联在一起",
      "那么",
      "a、b的朋友列表将包含彼此",
      "因此测试用例中",
      "a在b.friends中",
      "b也在a.friends中；思想：getDistance测试中应包括自己与自己、相互认识的两人、相互不认识但是有中间人关联的两人以及互不相干的两人；测试结果：至此",
      "实验设计结束"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "2021年春季学期\n计算学部《软件构造》课程\nLab 1实验报告\n1. 实验目标概述 3\n2. 实验环境配置 3\n3. 实验过程 6\n3.1 Magic Squares 6\n3.1.1 isLegalMagicSquare() 6\n3.1.2 generateMagicSquare() 8\n3.2 Turtle Graphics 10\n3.2.1 Problem 1: Clone and import 10\n3.2.2 Problem 3: Turtle graphics and drawSquare 10\n3.2.3 Problem 5: Drawing polygons 11\n3.2.4 Problem 6: Calculating Bearings 11\n3.2.5 Problem 7: Convex Hulls 12\n3.2.6 Problem 8: Personal art 12\n3.2.7 Submitting 14\n3.3 Social Network 14\n3.3.1 设计/实现FriendshipGraph类 14\n3.3.2 设计/实现Person类 15\n3.3.3 设计/实现客户端代码main() 16\n3.3.4 设计/实现测试用例 17\n4. 实验进度记录 18\n5. 实验过程中遇到的困难与解决途径 19\n6. 实验过程中收获的经验、教训、感想 19\n6.1 实验过程中收获的经验和教训 19\n6.2 针对以下方面的感受 19\n实验目标概述\n本次实验通过求解三个问题，训练基本 Java 编程技能，能够利用 Java OO 开\n发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够\n为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。\n另一方面，利用 Git 作为代码配置管理的工具，学会 Git 的基本使用方法。\n⚫ 基本的 Java OO 编程\n⚫ 基于 Eclipse IDE 进行 Java 编程\n⚫ 基于 JUnit 的测试\n⚫ 基于 Git 的代码配置管理\n实验环境配置\n在这里给出你的GitHub Lab1仓库的URL地址。\nhttps://github.com/ComputerScienceHIT/HIT-Lab1-1190200828\n实验过程\nMagic Squares\n该任务的目标：设计isLegalMagicSquare()函数，判定给定的几个矩阵是否为magic\nsquare；将给定的生成奇数阶的magic\nsquare的generateMagicSquare()函数作为静态函数加入我的程序代码中，将生成的矩阵存入6.txt并调用isLegalMagicSquare()判断所生成的矩阵是否正确。该阶段涉及到文件读写操作、对某些特定函数的调用（例如split等）、对部分异常的处理（例如矩阵中有负数、浮点数，或是行列数不相等）等。\nisLegalMagicSquare()\n1.根据实验要求，我不能上来直接就去用magic矩阵的定义去判断其正确性，即每行每列每个对角线的元素和都相等；而是应该先判断给定的矩阵是否合理，即判断行列数是否相等、矩阵中是否有浮点数、负数等。由此，我的想法是设置一个整型变量n = 0，对于txt文件先按行读入，每读入一行n++，直到读完文件，此时n的值即为矩阵行数。然后，依旧是按行读入文件，每读入一行，将其存入String line中，并调用split(“\\t”)将其分割并存入String[] line_cut，比较行数n与line_cut.length，不相等则输出错误提示并返回false，后经过测试，当文件未用”\\t”进行分割时，也会导n != line_cut.length，因此在这里一并输出错误提示；然后判断line_cut中的每一个元素是否都是正整数，按位寻访line_cut，若出现某一位不在数字字符’0’-‘9’中，则输出错误提示并返回false。综上所述，即有如下代码：\n以上错误判断完毕后，将读入的文档存入矩阵magic中，并按照magic矩阵定义进行测试，若不符合magic矩阵定义，则返回false。注意，在此过程中，并未输出错误提示，表示矩阵本身不存在行列数不相等等错误。于是有以下代码：\n至此，isLegalMagicSquare()函数设计完毕；\n结果展示：\ngenerateMagicSquare()\n程序代码已经在ppt中给出，程序流程图如下：\n除该程序代码外，需对该函数的输入进行测试，以防输入为偶数或负数。该测试在我的main函数中完成，输入阶数为负数或偶数或输入阶数小于2时输出错误提示并予以重新输入，但是，如果输入根本并非整数，而是浮点数或字符时，则输出错误提示且不允许重新输入，于是有如下代码：\n除此之外，还需要在函数中加入文件写入操作，将产生的magic矩阵存入6.txt以便于main函数中测试其生成的magic矩阵的正确性，添加的代码如下：\n结果展示：\nTurtle Graphics\n该任务的目标：clone已有的程序后，利用turtle按照要求画图，主要需要修改及再编程的是TurtleSoup类，其中的一些函数编程时需要结合我们已有的数学几何知识、TurtleSoup类中的提示信息以及测试用的TurtleSoupTest类中的提示信息，最后可以发挥想象力进行自己的创作。\nProblem 1: Clone and import\n从github获取代码\n由于clone出现问题，找不到实验报告上给的那个链接，所以我进入该链接后，将代码逐个复制到我的程序类中。\n初始化本地仓库\ngit init\nProblem 3: Turtle graphics and drawSquare\n该函数需要实现：已知边长，画出边长为指定数值的正方形。参数是海龟对象turtle和边长sideLength。\n循环执行，每次画笔直行sideLength距离，然后画笔方向旋转90度，循环执行4次后即可得到所需要的正方形，函数代码如下：\n结果展示（sideLength = 40）：\nProblem 5: Drawing polygons\n首先，要求计算已知正多边形边数的内角度，该计算由已知公式可以推导，因此相关函数代码如下：\n根据正方形的画法，只需要将画笔的转向角度设置为180 –\n内角度数，循环多边形边数次数即可。考虑到画笔转向既能是顺时针又能是逆时针，故在此声明：sides可为负数，且当sides为负整数时，代表着画笔将逆时针旋转，且旋转度数为180\n– 内角度数，并且取sides的绝对值为正多边形边数。函数代码如下：\nProblem 6: Calculating Bearings\n首先，已知起点和当前朝向角度，要求起点到终点需要转动的角度。根据几何运算，得函数代码如下：\n上述问题的扩展：此时有若干个点，要求从第一个点开始到第二个点，再从第二个点到第三个点……以此类推每次转向的角度。以起点为第一个点，循环n-1次，每次将第i+1号点设置为“终点”，通过上一个函数计算旋转角度并存储到List中，将下一次的“起点”用当前“终点”更新，继续循环。程序代码如下：\nProblem 7: Convex Hulls\n由凸包算法（CSDN（\nConvexHull凸包算法之Gift-Wrapping_Innovative\nWorkstation-CSDN博客\n）上查阅），可得该函数代码为：\nProblem 8: Personal art\n函数代码：\n结果展示：\nSubmitting\n由于第一次提交时已经进行过初始化以及与我的云仓库的关联，本次提交中只需要添加文件、注释以及提交三个步骤。\nSocial Network\n该任务的目标：设计一张社交网络无向图，连接互为朋友的人与人，并且能计算任意两人之间需要的最少的关联路径。于是，该问题为最短路径问题，而构建的图为无向无权图，所以利用DFS深度优先遍历即可得到两点间的最短路径。\n设计/实现FriendshipGraph类\n存储图中的人姓名的集合：\naddVertex()函数：首先判断Person\np是否在图中，若已经存在于图中，则输出错误信息，程序结束；否则将p添加至person中。\naddEdge()函数：在a、b的朋友列表里分别加入彼此。\ngetDistance()函数：DFS深度优先算法求最短路径\n设计/实现Person类\nPerson类包括：\nPerson()：包括这个人的名字p_name，这个人的朋友列表friends；\nIsFriendOf(Person p)：在p_name的朋友列表里加入p；\n设计/实现客户端代码main()\n由ppt给出：\n设计/实现测试用例\n思想：将a通过addVertex()函数加入testGraph1中，b不加入，因此，测试用例为a在testGraph1.person中，b不在；\n思想：将a、b通过addVertex()函数加入testGraph1中，调用addEdge()函数，在a、b加一条线，即关联在一起，那么，a、b的朋友列表将包含彼此，因此测试用例中，a在b.friends中，b也在a.friends中；\n思想：getDistance测试中应包括自己与自己、相互认识的两人、相互不认识但是有中间人关联的两人以及互不相干的两人；\n测试结果：\n至此，实验设计结束。\n"
  },
  {
    "head": "哈工大软件构造 Lab2 设计实现",
    "paragraphs": [
      "2021年春季学期",
      "计算学部《软件构造》课程",
      "**Lab 2",
      "1 实验目标概述 3",
      "2 实验环境配置 3",
      "3 实验过程 5",
      "3.1 Poetic Walks 5",
      "3.1.1 Get the code and prepare Git repository 5",
      "3.1.2 Problem 1: Test Graph <String> 5",
      "3.1.3 Problem 2: Implement Graph <String> 6",
      "3.1.4 Problem 3: Implement generic Graph<L> 12",
      "3.1.5 Problem 4: Poetic walks 14",
      "3.1.6 使用Eclemma检查测试的代码覆盖度 16",
      "3.1.7 Before you’re done 16",
      "3.2 Re-implement the Social Network in Lab1 18",
      "3.2.1 FriendshipGraph类 18",
      "3.2.2 Person类 18",
      "3.2.3 客户端main() 19",
      "3.2.4 测试用例 19",
      "3.2.5 提交至Git仓库 20",
      "4 实验进度记录 21",
      "5 实验过程中遇到的困难与解决途径 22",
      "6 实验过程中收获的经验、教训、感想 22",
      "6.1 实验过程中收获的经验和教训 22",
      "6.2 针对以下方面的感受 22",
      "实验目标概述",
      "本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现",
      "ADT。具体来说：",
      "⚫ 针对给定的应用问题，从问题描述中识别所需的 ADT；",
      "⚫ 设计 ADT 规约（pre-condition、post-condition）并评估规约的质量；",
      "⚫ 根据 ADT 的规约设计测试用例；",
      "⚫ ADT 的泛型化；",
      "⚫ 根据规约设计 ADT 的多种不同的实现；针对每种实现，设计其表示",
      "（representation）、表示不变性（rep invariant）、抽象过程（abstraction",
      "function）",
      "⚫ 使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表 示泄露（rep",
      "exposure）；",
      "⚫ 测试 ADT 的实现并评估测试的覆盖度；",
      "⚫ 使用 ADT 及其实现，为应用问题开发程序；",
      "⚫ 在测试代码中，能够写出 testing strategy 并据此设计测试用例。",
      "实验环境配置",
      "IDEA自带代码覆盖率工具，只需右键单击测试文件，选择Run with Coverage即可：",
      "在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）：",
      "https://github.com/ComputerScienceHIT/HIT-Lab2-1190200828",
      "实验过程",
      "Poetic Walks",
      "此实验的目的是练习设计、测试和执行ADT。该阶段给出了一个图的接口，要求建立一个边图类一个点图类来分别继承自该图接口，在里面实现一系列方法并实现抽象数据型以完成poet。",
      "Get the code and prepare Git repository",
      "从GitHub获取该任务的代码：",
      "git clone",
      "https://github.com/rainywang/Spring2021_HITCS_SC_Lab2/",
      "在本地创建git仓库：",
      "在自己创建的本地仓库中，打开git bash输入然后与git远端仓库进行关联即可。",
      "Problem 1: Test Graph <String>",
      "思路：",
      "这是针对Graph<String>设计相应的测试策略，即对Graph<String>的每个方法进行测试。",
      "过程：",
      "下面的截图为接口Graph中的部分被方法测试策略，其中vertices()方法在add、set等方法的测试中已经测试过，因此不再单独测试：",
      "其他测试策略不再一一展示。",
      "Problem 2: Implement Graph <String>",
      "Implement ConcreteEdgesGraph",
      "Edge类的实现",
      "初始化构造方法：",
      "定义边起点source和边终点target，以及边权值weight。",
      "AF、RI、Safety：",
      "Edge中需要实现的方法：",
      "Edge：初始化构造方法，即初始化边的两个顶点和边权值；",
      "checkRep：检查表示不变性；",
      "getSource：返回边起点；",
      "getTarget：返回边终点；",
      "getWeight：返回边权值；",
      "toString：字符串形式描述一条边，形式为”Weight of the edge from",
      "source",
      "target",
      "weight",
      ".\\n”",
      "Edge类中各方法的测试策略：",
      "其他测试策略不再一一展示。",
      "测试结果：",
      "ConcreteEdgesGraph类的实现",
      "初始化构造方法：",
      "定义顶点集vertices和边表edges。",
      "AF、RI、Safety：",
      "ConcreteEdgesGraph中需要实现的方法(结合已设计的Graph测试用例)：",
      "ConcreteEdgesGraph：构造方法，不需要初始化变量；",
      "checkRep：检查表示不变性；",
      "add：添加一个顶点到顶点集vertices，不能重复加入；",
      "set：输入起点source、终点target和边权值weight，若起点或终点不在vertices内，则调用add将其加入。若weight",
      "< 0，则返回-1；当weight = 0时，若边存在，则删去该边；当weight >",
      "0时，若该边不存在，则将该边直接加入edges，否则应删去原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；",
      "remote：去除某一点以及与它有关的所有边；",
      "vertices：返回顶点集vertices；",
      "sources：输入终点，返回所有指向该点的起点及边的权值；",
      "targets：输入起点，返回该点指向的所有终点及边的权值；",
      "toString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。",
      "测试结果(包含Graph测试用例测试结果和toString的测试结果)：",
      "Implement ConcreteVerticesGraph",
      "Vertex类的实现",
      "初始化构造方法：",
      "定义图中点的名字vertex，Map",
      "sources用于存储指向点vertex的所有起点以及它们之间的边的权值，Map",
      "targets用于存储点vertex指向的所有终点以及它们之间边的权值。",
      "AF、RI、Safety：",
      "Vertex类中需要实现的方法：",
      "Vertex：初始化构造方法；",
      "checkRep：检查表示不变性；",
      "getVertex：返回点的名字；",
      "addSource：向sources中添加指向该点的起点及它们间边的权值。若weight <",
      "0，则返回-1；当weight = 0时，若该起点存在，则在sources中删去该起点；当weight",
      "0时，直接sources.put进行添加或者替换。改变了原边权值时，返回原边权值，边不存在则返回0；",
      "addTarget：向targets中添加该点指向的终点及它们间边的权值。操作与addSource相类似；",
      "getSources：返回sources；",
      "getTargets：返回targets；",
      "removeSource：从sources中删去一个指向该点的起点；",
      "removeTarget：从targets中删去一个该点指向的终点；",
      "toString：返回该点以及sources、targets。",
      "测试结果：",
      "ConcreteVerticesGraph类的实现",
      "初始化构造方法：",
      "定义顶点列表。",
      "AF、RI、Safety：",
      "ConcreteVerticesGraph类中需要实现的方法：",
      "ConcreteVerticesGraph：构造方法，不需要初始化变量；",
      "checkRep：检查表示不变性；",
      "add：初始化一个新的顶点并将其添加到到顶点列表vertices，若该点已经存在于图中，不能重复加入；",
      "set：输入起点source、终点target和边权值weight，若起点或终点不在vertices()内，则调用add方法将其加入。关于weight不同取值的操作于Vertice类的addSource、addTarget方法中完成；",
      "remote：去除某一点以及与它有关的所有边；",
      "vertices：返回顶点集vertices；",
      "sources：输入终点，返回所有指向该点的起点及边的权值；",
      "targets：输入起点，返回该点指向的所有终点及边的权值；",
      "toString：字符串形式输出图，每一个顶点的sources和targets的格式都与Vertex类中toString方法中的返回形式相同。",
      "测试结果：",
      "Problem 3: Implement generic Graph<L>",
      "Make the implementations generic",
      "将之前实现的类和方法均使用泛型实现即可，即将各类中一开始用String型定义的变量，如起点source、终点target等相关的String类型变量均换为L。",
      "接下来，按照IDEA的报错，将代码的其他位置的String替换为泛型L即可。",
      "Implement Graph.empty()",
      "返回一个Graph的具体实现即可。",
      "补充其他类型的标签：",
      "测试结果：",
      "Problem 4: Poetic walks",
      "Test GraphPoet",
      "GraphPoet类中GraphPoet与poem方法的测试策略及测试用例：",
      "【注】因为GraphPoet方法没有任何输出，图变量graph为private，所以无法直接测试该方法，所以直接测试两个方法；",
      "1_empty.txt：空白文件，图为空， b必定不存在，所以返回值与input一致；",
      "2_easy.txt：简单测试用文件，要插入的b均唯一",
      "3_difficult.txt：比较复杂的测试用文件，要插入的b不唯一",
      "GraphPoet类中toString方法的测试策略：",
      "【注】考虑到该方法的测试，将Graph的具体实现更改为边图类，因为边图类的toString输出比点图类输出简单，更易书写测试用例。",
      "Implement GraphPoet",
      "初始化构造方法：",
      "定义字符串构成的图graph。",
      "AF、RI、Safety：",
      "需要实现的方法：",
      "GraphPoet：先将文件corpus中的所有点读入，考虑到其中存在相同的点，集合Set并不适用，因此将所有点都读入列表。循环遍历列表，每次读入一前一后两个点作为起点和终点，建成一条边，其权值为该边在corpus中出现的次数；",
      "poem：生成poem，设计如下：",
      "toString：调用Graph接口中的toString方法，将整个图中所有点的指向转化为一条字符串输出。因为Graph接口的具体实现在设计测试文件时改为了边图类，所以输出格式即为边图类的toString方法的输出。",
      "Graph poetry slam",
      "在main函数中加入一个输出调用toString方法，运行结果如下：",
      "使用Eclemma检查测试的代码覆盖度",
      "Before you’re done",
      "如何通过Git提交当前版本到GitHub上你的Lab2仓库。",
      "git init",
      "https://github.com/ComputerScienceHIT/HIT-Lab2-1190200828",
      "git push origin master -u -m",
      "在这里给出你的项目的目录结构树状示意图：",
      "Re-implement the Social Network in Lab1",
      "用在Poetic",
      "Walks已经实现的Graph<L>来实现Lab1中的FriendshipGraph类的各个方法，使之能通过测试文件，并且运行main函数的结果与Lab1一致。",
      "FriendshipGraph类",
      "初始化构造方法：",
      "生成空图graph。",
      "AF、RI、Safety：",
      "FriendshipGraph类中要实现的方法：",
      "main：与Lab1一致；",
      "addVertex：向图中添加点，调用Graph类中的add即可；",
      "addEdge：向图中添加边，因为是无向图，调用两次Graph类中的set即可；",
      "getDistance：得到两点间的距离，利用DFS算法，通过调用Graph类中的sources等方法即可；",
      "getGraph：因为构造方法graph设置为为private，为方便测试，故设置该方法以返回graph。",
      "Person类",
      "初始化构造方法：",
      "定义人的名字name",
      "AF、RI、Safety：",
      "Person类中要实现的方法：",
      "Person：初始化构造方法，即初始化name；",
      "客户端main()",
      "将Lab1中的main直接复制过来即可，运行结果如下：",
      "该结果与Lab1中main的运行结果一致。",
      "测试用例",
      "测试用例与Lab1一致，新增方法getGraph在其他测试中已测试完毕，不再进行单独测试；",
      "测试结果(main无法参与测试，所以代码覆盖度较低)：",
      "提交至Git仓库",
      "提交过程同Poetic Walks；",
      "在这里给出你的项目的目录结构树状示意图。",
      "[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EHvUECld-1625645261706)(media/21c74acf10e1062c719496a9d029fc77.png)]",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "经过学习，对于Java的一些概念更加了解；",
      "对于Java中自带的一些方法还是很不熟悉，很多方法都要靠百度现场搜，以后会多加积累，多加练习；",
      "总是因为一些小错误而debug很长时间，以后要避免循环溢出等小错误；",
      "因为IDEA太聪明了，导致手写代码基本不可能，以后要多加记忆代码，加强手写代码能力。",
      "针对以下方面的感受",
      "面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？",
      "ADT的实现过程比较困难，但是一旦实现了ADT，后续工作就会变得十分简单；",
      "使用泛型和不使用泛型的编程，对你来说有何差异？",
      "本次实验来讲并没有什么差异，因为开始时未用泛型时，也没有用到与特定数据类型相关的方法；",
      "在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？",
      "优势：有目的的编程，有助于保证代码的正确性；",
      "暂时不适应；",
      "P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？",
      "提高代码效率，降低实现难度；",
      "P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？",
      "首先，P3不存在；其次，肯定不适应，因为P1都只是勉强能写；",
      "为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep",
      "exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "意义：防止内部变量被外部修改，提高代码安全性；",
      "我会尽量坚持，虽然繁琐，但可以提高代码安全性；",
      "关于本实验的工作量、难度、deadline。",
      "工作量比较大，主要体现在写代码、代码注释、测试策略以及实验报告的撰写；难度对我来说比较高，因为对Java还是不算熟悉，很多方法需要现查；ddl比较合理，毕竟三周时间，但很容易造成所有工作堆在最后完成，建议学习计算机系统实验，将整个实验分为几个具有联系的小型实验发布，每周一交；",
      "《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "Java是一个很聪明的语言，而IDEA也是一个很聪明的编程工具；",
      "实验中给出代码注释基本上都是英文，本次实验中，我的函数注释基本上也是用的英文，但是测试策略、代码注释还是中文，以后会慢慢改进。",
      "设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？",
      "首先，P3不存在；其次，肯定不适应，因为P1都只是勉强能写；",
      "为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep",
      "exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "意义：防止内部变量被外部修改，提高代码安全性；",
      "我会尽量坚持，虽然繁琐，但可以提高代码安全性；",
      "关于本实验的工作量、难度、deadline。",
      "工作量比较大，主要体现在写代码、代码注释、测试策略以及实验报告的撰写；难度对我来说比较高，因为对Java还是不算熟悉，很多方法需要现查；ddl比较合理，毕竟三周时间，但很容易造成所有工作堆在最后完成，建议学习计算机系统实验，将整个实验分为几个具有联系的小型实验发布，每周一交；",
      "《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "Java是一个很聪明的语言，而IDEA也是一个很聪明的编程工具；",
      "实验中给出代码注释基本上都是英文，本次实验中，我的函数注释基本上也是用的英文，但是测试策略、代码注释还是中文，以后会慢慢改进。"
    ],
    "sentences": [
      "2021年春季学期",
      "计算学部《软件构造》课程",
      "**Lab 2",
      "1 实验目标概述 3",
      "2 实验环境配置 3",
      "3 实验过程 5",
      "3.1 Poetic Walks 5",
      "3.1.1 Get the code and prepare Git repository 5",
      "3.1.2 Problem 1: Test Graph <String> 5",
      "3.1.3 Problem 2: Implement Graph <String> 6",
      "3.1.4 Problem 3: Implement generic Graph<L> 12",
      "3.1.5 Problem 4: Poetic walks 14",
      "3.1.6 使用Eclemma检查测试的代码覆盖度 16",
      "3.1.7 Before you’re done 16",
      "3.2 Re-implement the Social Network in Lab1 18",
      "3.2.1 FriendshipGraph类 18",
      "3.2.2 Person类 18",
      "3.2.3 客户端main() 19",
      "3.2.4 测试用例 19",
      "3.2.5 提交至Git仓库 20",
      "4 实验进度记录 21",
      "5 实验过程中遇到的困难与解决途径 22",
      "6 实验过程中收获的经验、教训、感想 22",
      "6.1 实验过程中收获的经验和教训 22",
      "6.2 针对以下方面的感受 22",
      "实验目标概述",
      "本次实验训练抽象数据类型（ADT）的设计、规约、测试",
      "并使用面向对象编程（OOP）技术实现",
      "ADT",
      "具体来说：⚫ 针对给定的应用问题",
      "从问题描述中识别所需的 ADT；⚫ 设计 ADT 规约（pre-condition、post-condition）并评估规约的质量；⚫ 根据 ADT 的规约设计测试用例；⚫ ADT 的泛型化；⚫ 根据规约设计 ADT 的多种不同的实现；针对每种实现",
      "设计其表示",
      "（representation）、表示不变性（rep invariant）、抽象过程（abstraction",
      "function）",
      "⚫ 使用 OOP 实现 ADT",
      "并判定表示不变性是否违反、各实现是否存在表 示泄露（rep",
      "exposure）；⚫ 测试 ADT 的实现并评估测试的覆盖度；⚫ 使用 ADT 及其实现",
      "为应用问题开发程序；⚫ 在测试代码中",
      "能够写出 testing strategy 并据此设计测试用例",
      "实验环境配置",
      "IDEA自带代码覆盖率工具",
      "只需右键单击测试文件",
      "选择Run with Coverage即可：在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）：https://github.com/ComputerScienceHIT/HIT-Lab2-1190200828",
      "实验过程",
      "Poetic Walks",
      "此实验的目的是练习设计、测试和执行ADT",
      "该阶段给出了一个图的接口",
      "要求建立一个边图类一个点图类来分别继承自该图接口",
      "在里面实现一系列方法并实现抽象数据型以完成poet",
      "Get the code and prepare Git repository",
      "从GitHub获取该任务的代码：git clone",
      "https://github.com/rainywang/Spring2021_HITCS_SC_Lab2/",
      "在本地创建git仓库：在自己创建的本地仓库中",
      "打开git bash输入然后与git远端仓库进行关联即可",
      "Problem 1: Test Graph <String>",
      "思路：这是针对Graph<String>设计相应的测试策略",
      "即对Graph<String>的每个方法进行测试",
      "过程：下面的截图为接口Graph中的部分被方法测试策略",
      "其中vertices()方法在add、set等方法的测试中已经测试过",
      "因此不再单独测试：其他测试策略不再一一展示",
      "Problem 2: Implement Graph <String>",
      "Implement ConcreteEdgesGraph",
      "Edge类的实现",
      "初始化构造方法：定义边起点source和边终点target",
      "以及边权值weight",
      "AF、RI、Safety：Edge中需要实现的方法：Edge：初始化构造方法",
      "即初始化边的两个顶点和边权值；checkRep：检查表示不变性；getSource：返回边起点；getTarget：返回边终点；getWeight：返回边权值；toString：字符串形式描述一条边",
      "形式为”Weight of the edge from",
      "source",
      "target",
      "weight",
      ".\\n”",
      "Edge类中各方法的测试策略：其他测试策略不再一一展示",
      "测试结果：ConcreteEdgesGraph类的实现",
      "初始化构造方法：定义顶点集vertices和边表edges",
      "AF、RI、Safety：ConcreteEdgesGraph中需要实现的方法(结合已设计的Graph测试用例)：ConcreteEdgesGraph：构造方法",
      "不需要初始化变量；checkRep：检查表示不变性；add：添加一个顶点到顶点集vertices",
      "不能重复加入；set：输入起点source、终点target和边权值weight",
      "若起点或终点不在vertices内",
      "则调用add将其加入",
      "若weight",
      "< 0",
      "则返回-1；当weight = 0时",
      "若边存在",
      "则删去该边；当weight >",
      "0时",
      "若该边不存在",
      "则将该边直接加入edges",
      "否则应删去原边后再将新的边和权值加入edges",
      "改变了原边权值时",
      "返回原边权值",
      "边不存在则返回0；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点",
      "返回所有指向该点的起点及边的权值；targets：输入起点",
      "返回该点指向的所有终点及边的权值；toString：字符串形式输出图",
      "每一条边的输出格式都与Edge类中toString方法中的返回形式相同",
      "测试结果(包含Graph测试用例测试结果和toString的测试结果)：Implement ConcreteVerticesGraph",
      "Vertex类的实现",
      "初始化构造方法：定义图中点的名字vertex，Map",
      "sources用于存储指向点vertex的所有起点以及它们之间的边的权值",
      "Map",
      "targets用于存储点vertex指向的所有终点以及它们之间边的权值",
      "AF、RI、Safety：Vertex类中需要实现的方法：Vertex：初始化构造方法；checkRep：检查表示不变性；getVertex：返回点的名字；addSource：向sources中添加指向该点的起点及它们间边的权值",
      "若weight <",
      "0",
      "则返回-1；当weight = 0时",
      "若该起点存在",
      "则在sources中删去该起点；当weight",
      "0时，直接sources.put进行添加或者替换",
      "改变了原边权值时",
      "返回原边权值",
      "边不存在则返回0；addTarget：向targets中添加该点指向的终点及它们间边的权值",
      "操作与addSource相类似；getSources：返回sources；getTargets：返回targets；removeSource：从sources中删去一个指向该点的起点；removeTarget：从targets中删去一个该点指向的终点；toString：返回该点以及sources、targets",
      "测试结果：ConcreteVerticesGraph类的实现",
      "初始化构造方法：定义顶点列表",
      "AF、RI、Safety：ConcreteVerticesGraph类中需要实现的方法：ConcreteVerticesGraph：构造方法",
      "不需要初始化变量；checkRep：检查表示不变性；add：初始化一个新的顶点并将其添加到到顶点列表vertices",
      "若该点已经存在于图中",
      "不能重复加入；set：输入起点source、终点target和边权值weight",
      "若起点或终点不在vertices()内",
      "则调用add方法将其加入",
      "关于weight不同取值的操作于Vertice类的addSource、addTarget方法中完成；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点",
      "返回所有指向该点的起点及边的权值；targets：输入起点",
      "返回该点指向的所有终点及边的权值；toString：字符串形式输出图",
      "每一个顶点的sources和targets的格式都与Vertex类中toString方法中的返回形式相同",
      "测试结果：Problem 3: Implement generic Graph<L>",
      "Make the implementations generic",
      "将之前实现的类和方法均使用泛型实现即可",
      "即将各类中一开始用String型定义的变量",
      "如起点source、终点target等相关的String类型变量均换为L",
      "接下来",
      "按照IDEA的报错",
      "将代码的其他位置的String替换为泛型L即可",
      "Implement Graph.empty()",
      "返回一个Graph的具体实现即可",
      "补充其他类型的标签：测试结果：Problem 4: Poetic walks",
      "Test GraphPoet",
      "GraphPoet类中GraphPoet与poem方法的测试策略及测试用例：【注】因为GraphPoet方法没有任何输出",
      "图变量graph为private",
      "所以无法直接测试该方法",
      "所以直接测试两个方法；1_empty.txt：空白文件",
      "图为空",
      " b必定不存在",
      "所以返回值与input一致；2_easy.txt：简单测试用文件",
      "要插入的b均唯一",
      "3_difficult.txt：比较复杂的测试用文件",
      "要插入的b不唯一",
      "GraphPoet类中toString方法的测试策略：【注】考虑到该方法的测试",
      "将Graph的具体实现更改为边图类",
      "因为边图类的toString输出比点图类输出简单",
      "更易书写测试用例",
      "Implement GraphPoet",
      "初始化构造方法：定义字符串构成的图graph",
      "AF、RI、Safety：需要实现的方法：GraphPoet：先将文件corpus中的所有点读入",
      "考虑到其中存在相同的点",
      "集合Set并不适用",
      "因此将所有点都读入列表",
      "循环遍历列表",
      "每次读入一前一后两个点作为起点和终点",
      "建成一条边",
      "其权值为该边在corpus中出现的次数；poem：生成poem",
      "设计如下：toString：调用Graph接口中的toString方法",
      "将整个图中所有点的指向转化为一条字符串输出",
      "因为Graph接口的具体实现在设计测试文件时改为了边图类",
      "所以输出格式即为边图类的toString方法的输出",
      "Graph poetry slam",
      "在main函数中加入一个输出调用toString方法",
      "运行结果如下：使用Eclemma检查测试的代码覆盖度",
      "Before you’re done",
      "如何通过Git提交当前版本到GitHub上你的Lab2仓库",
      "git init",
      "https://github.com/ComputerScienceHIT/HIT-Lab2-1190200828",
      "git push origin master -u -m",
      "在这里给出你的项目的目录结构树状示意图：Re-implement the Social Network in Lab1",
      "用在Poetic",
      "Walks已经实现的Graph<L>来实现Lab1中的FriendshipGraph类的各个方法",
      "使之能通过测试文件",
      "并且运行main函数的结果与Lab1一致",
      "FriendshipGraph类",
      "初始化构造方法：生成空图graph",
      "AF、RI、Safety：FriendshipGraph类中要实现的方法：main：与Lab1一致；addVertex：向图中添加点",
      "调用Graph类中的add即可；addEdge：向图中添加边",
      "因为是无向图",
      "调用两次Graph类中的set即可；getDistance：得到两点间的距离",
      "利用DFS算法",
      "通过调用Graph类中的sources等方法即可；getGraph：因为构造方法graph设置为为private",
      "为方便测试",
      "故设置该方法以返回graph",
      "Person类",
      "初始化构造方法：定义人的名字name",
      "AF、RI、Safety：Person类中要实现的方法：Person：初始化构造方法",
      "即初始化name；客户端main()",
      "将Lab1中的main直接复制过来即可",
      "运行结果如下：该结果与Lab1中main的运行结果一致",
      "测试用例",
      "测试用例与Lab1一致",
      "新增方法getGraph在其他测试中已测试完毕",
      "不再进行单独测试；测试结果(main无法参与测试",
      "所以代码覆盖度较低)：提交至Git仓库",
      "提交过程同Poetic Walks；在这里给出你的项目的目录结构树状示意图",
      "[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EHvUECld-1625645261706)(media/21c74acf10e1062c719496a9d029fc77.png)]",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "经过学习",
      "对于Java的一些概念更加了解；对于Java中自带的一些方法还是很不熟悉",
      "很多方法都要靠百度现场搜",
      "以后会多加积累",
      "多加练习；总是因为一些小错误而debug很长时间",
      "以后要避免循环溢出等小错误；因为IDEA太聪明了",
      "导致手写代码基本不可能",
      "以后要多加记忆代码",
      "加强手写代码能力",
      "针对以下方面的感受",
      "面向ADT的编程和直接面向应用场景编程",
      "你体会到二者有何差异？",
      "ADT的实现过程比较困难",
      "但是一旦实现了ADT",
      "后续工作就会变得十分简单；使用泛型和不使用泛型的编程",
      "对你来说有何差异？",
      "本次实验来讲并没有什么差异",
      "因为开始时未用泛型时",
      "也没有用到与特定数据类型相关的方法；在给出ADT的规约后就开始编写测试用例",
      "优势是什么？你是否能够适应这种测试方式？",
      "优势：有目的的编程",
      "有助于保证代码的正确性；暂时不适应；P1设计的ADT在多个应用场景下使用",
      "这种复用带来什么好处？",
      "提高代码效率",
      "降低实现难度；P3要求你从0开始设计ADT并使用它们完成一个具体应用",
      "你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系",
      "P3要求你自主设计这些内容",
      "你的感受如何？",
      "首先",
      "P3不存在；其次",
      "肯定不适应",
      "因为P1都只是勉强能写；为ADT撰写specification, invariants, RI, AF",
      "时刻注意ADT是否有rep",
      "exposure",
      "这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "意义：防止内部变量被外部修改",
      "提高代码安全性；我会尽量坚持",
      "虽然繁琐",
      "但可以提高代码安全性；关于本实验的工作量、难度、deadline",
      "工作量比较大",
      "主要体现在写代码、代码注释、测试策略以及实验报告的撰写；难度对我来说比较高",
      "因为对Java还是不算熟悉",
      "很多方法需要现查；ddl比较合理",
      "毕竟三周时间",
      "但很容易造成所有工作堆在最后完成",
      "建议学习计算机系统实验",
      "将整个实验分为几个具有联系的小型实验发布",
      "每周一交；《软件构造》课程进展到目前",
      "你对该课程有何体会和建议？",
      "Java是一个很聪明的语言",
      "而IDEA也是一个很聪明的编程工具；实验中给出代码注释基本上都是英文",
      "本次实验中",
      "我的函数注释基本上也是用的英文",
      "但是测试策略、代码注释还是中文",
      "以后会慢慢改进",
      "设计ADT并使用它们完成一个具体应用",
      "你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系",
      "P3要求你自主设计这些内容",
      "你的感受如何？",
      "首先",
      "P3不存在；其次",
      "肯定不适应",
      "因为P1都只是勉强能写；为ADT撰写specification, invariants, RI, AF",
      "时刻注意ADT是否有rep",
      "exposure",
      "这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "意义：防止内部变量被外部修改",
      "提高代码安全性；我会尽量坚持",
      "虽然繁琐",
      "但可以提高代码安全性；关于本实验的工作量、难度、deadline",
      "工作量比较大",
      "主要体现在写代码、代码注释、测试策略以及实验报告的撰写；难度对我来说比较高",
      "因为对Java还是不算熟悉",
      "很多方法需要现查；ddl比较合理",
      "毕竟三周时间",
      "但很容易造成所有工作堆在最后完成",
      "建议学习计算机系统实验",
      "将整个实验分为几个具有联系的小型实验发布",
      "每周一交；《软件构造》课程进展到目前",
      "你对该课程有何体会和建议？",
      "Java是一个很聪明的语言",
      "而IDEA也是一个很聪明的编程工具；实验中给出代码注释基本上都是英文",
      "本次实验中",
      "我的函数注释基本上也是用的英文",
      "但是测试策略、代码注释还是中文",
      "以后会慢慢改进"
    ],
    "codes": [
      "git init",
      "git add .",
      "git commit -m “First commit:Poetic Walks has been done”",
      "git remote add origin"
    ],
    "date": "2021-07-07",
    "text": "2021年春季学期\n计算学部《软件构造》课程\n**Lab 2\n1 实验目标概述 3\n2 实验环境配置 3\n3 实验过程 5\n3.1 Poetic Walks 5\n3.1.1 Get the code and prepare Git repository 5\n3.1.2 Problem 1: Test Graph <String> 5\n3.1.3 Problem 2: Implement Graph <String> 6\n3.1.4 Problem 3: Implement generic Graph<L> 12\n3.1.5 Problem 4: Poetic walks 14\n3.1.6 使用Eclemma检查测试的代码覆盖度 16\n3.1.7 Before you’re done 16\n3.2 Re-implement the Social Network in Lab1 18\n3.2.1 FriendshipGraph类 18\n3.2.2 Person类 18\n3.2.3 客户端main() 19\n3.2.4 测试用例 19\n3.2.5 提交至Git仓库 20\n4 实验进度记录 21\n5 实验过程中遇到的困难与解决途径 22\n6 实验过程中收获的经验、教训、感想 22\n6.1 实验过程中收获的经验和教训 22\n6.2 针对以下方面的感受 22\n实验目标概述\n本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现\nADT。具体来说：\n⚫ 针对给定的应用问题，从问题描述中识别所需的 ADT；\n⚫ 设计 ADT 规约（pre-condition、post-condition）并评估规约的质量；\n⚫ 根据 ADT 的规约设计测试用例；\n⚫ ADT 的泛型化；\n⚫ 根据规约设计 ADT 的多种不同的实现；针对每种实现，设计其表示\n（representation）、表示不变性（rep invariant）、抽象过程（abstraction\nfunction）\n⚫ 使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表 示泄露（rep\nexposure）；\n⚫ 测试 ADT 的实现并评估测试的覆盖度；\n⚫ 使用 ADT 及其实现，为应用问题开发程序；\n⚫ 在测试代码中，能够写出 testing strategy 并据此设计测试用例。\n实验环境配置\nIDEA自带代码覆盖率工具，只需右键单击测试文件，选择Run with Coverage即可：\n在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）：\nhttps://github.com/ComputerScienceHIT/HIT-Lab2-1190200828\n实验过程\nPoetic Walks\n此实验的目的是练习设计、测试和执行ADT。该阶段给出了一个图的接口，要求建立一个边图类一个点图类来分别继承自该图接口，在里面实现一系列方法并实现抽象数据型以完成poet。\nGet the code and prepare Git repository\n从GitHub获取该任务的代码：\ngit clone\nhttps://github.com/rainywang/Spring2021_HITCS_SC_Lab2/\n在本地创建git仓库：\n在自己创建的本地仓库中，打开git bash输入然后与git远端仓库进行关联即可。\nProblem 1: Test Graph <String>\n思路：\n这是针对Graph<String>设计相应的测试策略，即对Graph<String>的每个方法进行测试。\n过程：\n下面的截图为接口Graph中的部分被方法测试策略，其中vertices()方法在add、set等方法的测试中已经测试过，因此不再单独测试：\n其他测试策略不再一一展示。\nProblem 2: Implement Graph <String>\nImplement ConcreteEdgesGraph\nEdge类的实现\n初始化构造方法：\n定义边起点source和边终点target，以及边权值weight。\nAF、RI、Safety：\nEdge中需要实现的方法：\nEdge：初始化构造方法，即初始化边的两个顶点和边权值；\ncheckRep：检查表示不变性；\ngetSource：返回边起点；\ngetTarget：返回边终点；\ngetWeight：返回边权值；\ntoString：字符串形式描述一条边，形式为”Weight of the edge from\nsource\ntarget\nweight\n.\\n”\nEdge类中各方法的测试策略：\n其他测试策略不再一一展示。\n测试结果：\nConcreteEdgesGraph类的实现\n初始化构造方法：\n定义顶点集vertices和边表edges。\nAF、RI、Safety：\nConcreteEdgesGraph中需要实现的方法(结合已设计的Graph测试用例)：\nConcreteEdgesGraph：构造方法，不需要初始化变量；\ncheckRep：检查表示不变性；\nadd：添加一个顶点到顶点集vertices，不能重复加入；\nset：输入起点source、终点target和边权值weight，若起点或终点不在vertices内，则调用add将其加入。若weight\n< 0，则返回-1；当weight = 0时，若边存在，则删去该边；当weight >\n0时，若该边不存在，则将该边直接加入edges，否则应删去原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；\nremote：去除某一点以及与它有关的所有边；\nvertices：返回顶点集vertices；\nsources：输入终点，返回所有指向该点的起点及边的权值；\ntargets：输入起点，返回该点指向的所有终点及边的权值；\ntoString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。\n测试结果(包含Graph测试用例测试结果和toString的测试结果)：\nImplement ConcreteVerticesGraph\nVertex类的实现\n初始化构造方法：\n定义图中点的名字vertex，Map\nsources用于存储指向点vertex的所有起点以及它们之间的边的权值，Map\ntargets用于存储点vertex指向的所有终点以及它们之间边的权值。\nAF、RI、Safety：\nVertex类中需要实现的方法：\nVertex：初始化构造方法；\ncheckRep：检查表示不变性；\ngetVertex：返回点的名字；\naddSource：向sources中添加指向该点的起点及它们间边的权值。若weight <\n0，则返回-1；当weight = 0时，若该起点存在，则在sources中删去该起点；当weight\n0时，直接sources.put进行添加或者替换。改变了原边权值时，返回原边权值，边不存在则返回0；\naddTarget：向targets中添加该点指向的终点及它们间边的权值。操作与addSource相类似；\ngetSources：返回sources；\ngetTargets：返回targets；\nremoveSource：从sources中删去一个指向该点的起点；\nremoveTarget：从targets中删去一个该点指向的终点；\ntoString：返回该点以及sources、targets。\n测试结果：\nConcreteVerticesGraph类的实现\n初始化构造方法：\n定义顶点列表。\nAF、RI、Safety：\nConcreteVerticesGraph类中需要实现的方法：\nConcreteVerticesGraph：构造方法，不需要初始化变量；\ncheckRep：检查表示不变性；\nadd：初始化一个新的顶点并将其添加到到顶点列表vertices，若该点已经存在于图中，不能重复加入；\nset：输入起点source、终点target和边权值weight，若起点或终点不在vertices()内，则调用add方法将其加入。关于weight不同取值的操作于Vertice类的addSource、addTarget方法中完成；\nremote：去除某一点以及与它有关的所有边；\nvertices：返回顶点集vertices；\nsources：输入终点，返回所有指向该点的起点及边的权值；\ntargets：输入起点，返回该点指向的所有终点及边的权值；\ntoString：字符串形式输出图，每一个顶点的sources和targets的格式都与Vertex类中toString方法中的返回形式相同。\n测试结果：\nProblem 3: Implement generic Graph<L>\nMake the implementations generic\n将之前实现的类和方法均使用泛型实现即可，即将各类中一开始用String型定义的变量，如起点source、终点target等相关的String类型变量均换为L。\n接下来，按照IDEA的报错，将代码的其他位置的String替换为泛型L即可。\nImplement Graph.empty()\n返回一个Graph的具体实现即可。\n补充其他类型的标签：\n测试结果：\nProblem 4: Poetic walks\nTest GraphPoet\nGraphPoet类中GraphPoet与poem方法的测试策略及测试用例：\n【注】因为GraphPoet方法没有任何输出，图变量graph为private，所以无法直接测试该方法，所以直接测试两个方法；\n1_empty.txt：空白文件，图为空， b必定不存在，所以返回值与input一致；\n2_easy.txt：简单测试用文件，要插入的b均唯一\n3_difficult.txt：比较复杂的测试用文件，要插入的b不唯一\nGraphPoet类中toString方法的测试策略：\n【注】考虑到该方法的测试，将Graph的具体实现更改为边图类，因为边图类的toString输出比点图类输出简单，更易书写测试用例。\nImplement GraphPoet\n初始化构造方法：\n定义字符串构成的图graph。\nAF、RI、Safety：\n需要实现的方法：\nGraphPoet：先将文件corpus中的所有点读入，考虑到其中存在相同的点，集合Set并不适用，因此将所有点都读入列表。循环遍历列表，每次读入一前一后两个点作为起点和终点，建成一条边，其权值为该边在corpus中出现的次数；\npoem：生成poem，设计如下：\ntoString：调用Graph接口中的toString方法，将整个图中所有点的指向转化为一条字符串输出。因为Graph接口的具体实现在设计测试文件时改为了边图类，所以输出格式即为边图类的toString方法的输出。\nGraph poetry slam\n在main函数中加入一个输出调用toString方法，运行结果如下：\n使用Eclemma检查测试的代码覆盖度\nBefore you’re done\n如何通过Git提交当前版本到GitHub上你的Lab2仓库。\ngit init\nhttps://github.com/ComputerScienceHIT/HIT-Lab2-1190200828\ngit push origin master -u -m\n在这里给出你的项目的目录结构树状示意图：\nRe-implement the Social Network in Lab1\n用在Poetic\nWalks已经实现的Graph<L>来实现Lab1中的FriendshipGraph类的各个方法，使之能通过测试文件，并且运行main函数的结果与Lab1一致。\nFriendshipGraph类\n初始化构造方法：\n生成空图graph。\nAF、RI、Safety：\nFriendshipGraph类中要实现的方法：\nmain：与Lab1一致；\naddVertex：向图中添加点，调用Graph类中的add即可；\naddEdge：向图中添加边，因为是无向图，调用两次Graph类中的set即可；\ngetDistance：得到两点间的距离，利用DFS算法，通过调用Graph类中的sources等方法即可；\ngetGraph：因为构造方法graph设置为为private，为方便测试，故设置该方法以返回graph。\nPerson类\n初始化构造方法：\n定义人的名字name\nAF、RI、Safety：\nPerson类中要实现的方法：\nPerson：初始化构造方法，即初始化name；\n客户端main()\n将Lab1中的main直接复制过来即可，运行结果如下：\n该结果与Lab1中main的运行结果一致。\n测试用例\n测试用例与Lab1一致，新增方法getGraph在其他测试中已测试完毕，不再进行单独测试；\n测试结果(main无法参与测试，所以代码覆盖度较低)：\n提交至Git仓库\n提交过程同Poetic Walks；\n在这里给出你的项目的目录结构树状示意图。\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EHvUECld-1625645261706)(media/21c74acf10e1062c719496a9d029fc77.png)]\n实验过程中收获的经验、教训、感想\n实验过程中收获的经验和教训\n经过学习，对于Java的一些概念更加了解；\n对于Java中自带的一些方法还是很不熟悉，很多方法都要靠百度现场搜，以后会多加积累，多加练习；\n总是因为一些小错误而debug很长时间，以后要避免循环溢出等小错误；\n因为IDEA太聪明了，导致手写代码基本不可能，以后要多加记忆代码，加强手写代码能力。\n针对以下方面的感受\n面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？\nADT的实现过程比较困难，但是一旦实现了ADT，后续工作就会变得十分简单；\n使用泛型和不使用泛型的编程，对你来说有何差异？\n本次实验来讲并没有什么差异，因为开始时未用泛型时，也没有用到与特定数据类型相关的方法；\n在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？\n优势：有目的的编程，有助于保证代码的正确性；\n暂时不适应；\nP1设计的ADT在多个应用场景下使用，这种复用带来什么好处？\n提高代码效率，降低实现难度；\nP3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？\n首先，P3不存在；其次，肯定不适应，因为P1都只是勉强能写；\n为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep\nexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？\n意义：防止内部变量被外部修改，提高代码安全性；\n我会尽量坚持，虽然繁琐，但可以提高代码安全性；\n关于本实验的工作量、难度、deadline。\n工作量比较大，主要体现在写代码、代码注释、测试策略以及实验报告的撰写；难度对我来说比较高，因为对Java还是不算熟悉，很多方法需要现查；ddl比较合理，毕竟三周时间，但很容易造成所有工作堆在最后完成，建议学习计算机系统实验，将整个实验分为几个具有联系的小型实验发布，每周一交；\n《软件构造》课程进展到目前，你对该课程有何体会和建议？\nJava是一个很聪明的语言，而IDEA也是一个很聪明的编程工具；\n实验中给出代码注释基本上都是英文，本次实验中，我的函数注释基本上也是用的英文，但是测试策略、代码注释还是中文，以后会慢慢改进。\n设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？\n首先，P3不存在；其次，肯定不适应，因为P1都只是勉强能写；\n为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep\nexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？\n意义：防止内部变量被外部修改，提高代码安全性；\n我会尽量坚持，虽然繁琐，但可以提高代码安全性；\n关于本实验的工作量、难度、deadline。\n工作量比较大，主要体现在写代码、代码注释、测试策略以及实验报告的撰写；难度对我来说比较高，因为对Java还是不算熟悉，很多方法需要现查；ddl比较合理，毕竟三周时间，但很容易造成所有工作堆在最后完成，建议学习计算机系统实验，将整个实验分为几个具有联系的小型实验发布，每周一交；\n《软件构造》课程进展到目前，你对该课程有何体会和建议？\nJava是一个很聪明的语言，而IDEA也是一个很聪明的编程工具；\n实验中给出代码注释基本上都是英文，本次实验中，我的函数注释基本上也是用的英文，但是测试策略、代码注释还是中文，以后会慢慢改进。\n"
  },
  {
    "head": "Java面向对象的一些相关概念及设计实例",
    "paragraphs": [
      "Java面向对象的一些相关概念及设计实例",
      "1 面向对象的相关概念",
      "1.1 面向对象",
      "面向对象(Object",
      "Oriented)是软件开发方法，一种编程范式。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。",
      "1.2 面向对象的相关概念",
      "对象：",
      "对象是指具体的某一个事物，即在现实生活中能够看得见摸得着的事物。在面向对象程序设计中，对象所指的是计算机系统中的某一个成分。在面向对象程序设计中，对象包含两个含义，其中一个是数据，另外一个是动作。对象则是数据和动作的结合体。对象不仅能够进行操作，同时还能够及时记录下操作结果。类的实例化可生成对象，一个对象的生命周期包括三个阶段：生成、使用、消除。",
      "方法：",
      "方法是指对象能够进行的操作，即函数。方法是类中的定义函数，其具体的作用就是对对象进行描述操作。",
      "类是具有相同特性（数据元素）和行为（功能）的对象的抽象。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象，类实际上就是一种数据类型。在我的理解中，类就像是一个带有内置函数的C语言中的结构体。",
      "接口：",
      "在Java语言中,仅支持单一继承,即一个子类只能有一个直接的父类，然而在日常生活中，多继承的问题在所难免",
      "如电子书既是一种图书，同时又是一种多媒体，这种继承关系要求子类继承多个父类。这样就可能导致子类具有多种多样的方法和实现形式。所以Java",
      "不允许多继承，为了解决多继承的问题，Java 引入了接口的概念。 定义一个接口不能使用",
      "class 关键字，而是使用 interface 关健字。",
      "1.3 面向对象的核心特性",
      "继承性：",
      "继承简单地说就是一种层次模型，这种层次模型能够被重用。层次结构的上层具有通用性，但是下层结构则具有特殊性。在继承的过程中类则可以从最顶层的部分继承一些方法和变量。类除了可以继承以外同时还能够进行修改或者添加。通过这样的方式能够有效提高工作效率。",
      "封装性：",
      "封装是将数据和代码捆绑到一起，对象的某些数据和代码可以是私有的(private)，不能被外界访问，以此实现对数据和代码不同级别的访问权限。防止了程序相互依赖性而带来的变动影响，面向对象的封装比传统语言的封装更为清晰、更为有力。有效实现了两个目标：对数据和行为的包装和信息隐藏。",
      "多态性：",
      "多态是指不同事物具有不同表现形式的能力。多态机制使具有不同内部结构的对象可以共享相同的外部接口，通过这种方式减少代码的复杂度。一个接口，多种方式。",
      "2 面向对象的设计实例",
      "设计实例即Lab2中Graph接口以及其具体实现的子类。",
      "2.1 Graph接口",
      "/**",
      "* A mutable weighted directed graph with labeled vertices.",
      "* Vertices have distinct labels of an immutable type {@code L} when compared",
      "* Edges are directed and have a positive weight of type {@code int}.",
      "* <p>PS2 instructions: this is a required ADT interface.",
      "* You MUST NOT change the specifications or add additional methods.",
      "* @param <L> type of vertex labels in this graph, must be immutable",
      "public interface Graph<L> {",
      "/**",
      "* Create an empty graph.",
      "* @param <L> type of vertex labels in the graph, must be immutable",
      "* @return a new empty weighted directed graph",
      "public static <L> Graph<L> empty() {",
      "return new ConcreteEdgesGraph<L>();",
      "/**",
      "* Add a vertex to this graph.",
      "* @param vertex label for the new vertex",
      "* @return true if this graph did not already include a vertex with the",
      "* given label; otherwise false (and this graph is not modified)",
      "public boolean add(L vertex);",
      "/**",
      "* Add, change, or remove a weighted directed edge in this graph.",
      "* If weight is nonzero, add an edge or update the weight of that edge;",
      "* vertices with the given labels are added to the graph if they do not",
      "* @param source label of the source vertex",
      "* @param target label of the target vertex",
      "* @param weight nonnegative weight of the edge",
      "* @return the previous weight of the edge, or zero if there was no such",
      "* edge",
      "public int set(L source, L target, int weight);",
      "/**",
      "* Remove a vertex from this graph; any edges to or from the vertex are",
      "* also removed.",
      "* @param vertex label of the vertex to remove",
      "* @return true if this graph included a vertex with the given label;",
      "* otherwise false (and this graph is not modified)",
      "public boolean remove(L vertex);",
      "/**",
      "* Get all the vertices in this graph.",
      "* @return the set of labels of vertices in this graph",
      "public Set<L> vertices();",
      "/**",
      "* Get the source vertices with directed edges to a target vertex and the",
      "* weights of those edges.",
      "* @return a map where the key set is the set of labels of vertices such",
      "* that this graph includes an edge from that vertex to target, and",
      "* the value for each key is the (nonzero) weight of the edge from",
      "public Map<L, Integer> sources(L target);",
      "/**",
      "* Get the target vertices with directed edges from a source vertex and the",
      "* weights of those edges.",
      "* @return a map where the key set is the set of labels of vertices such",
      "* that this graph includes an edge from source to that vertex, and",
      "* the value for each key is the (nonzero) weight of the edge from",
      "public Map<L, Integer> targets(L source);",
      "2.2 具体实现",
      "AF、RI、Safety from rep exposure",
      "CheckRep：",
      "ConcreteEdgesGraph中需要实现的方法(将方法全部实现即可)：",
      "ConcreteEdgesGraph：构造方法，不需要初始化变量；",
      "checkRep：检查表示不变性；",
      "add：添加一个顶点到顶点集vertices，不能重复加入；",
      "set：输入起点source、终点target和边权值weight，若起点或终点不在vertices内，则调用add将其加入。若weight",
      "< 0，则返回-1；当weight = 0时，若边存在，则删去该边；当weight >",
      "0时，若该边不存在，则将该边直接加入edges，否则应删去原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；",
      "remote：去除某一点以及与它有关的所有边；",
      "vertices：返回顶点集vertices；",
      "sources：输入终点，返回所有指向该点的起点及边的权值；",
      "targets：输入起点，返回该点指向的所有终点及边的权值；",
      "toString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。",
      "原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；",
      "remote：去除某一点以及与它有关的所有边；",
      "vertices：返回顶点集vertices；",
      "sources：输入终点，返回所有指向该点的起点及边的权值；",
      "targets：输入起点，返回该点指向的所有终点及边的权值；",
      "toString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。"
    ],
    "sentences": [
      "Java面向对象的一些相关概念及设计实例",
      "1 面向对象的相关概念",
      "1.1 面向对象",
      "面向对象(Object",
      "Oriented)是软件开发方法，一种编程范式",
      "面向对象的概念和应用已超越了程序设计和软件开发",
      "扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域",
      "面向对象是一种对现实世界理解和抽象的方法",
      "是一种新兴的程序设计方法",
      "或者是一种新的程序设计规范(paradigm)",
      "其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计",
      "从现实世界中客观存在的事物（即对象）出发来构造软件系统",
      "并且在系统构造中尽可能运用人类的自然思维方式",
      "1.2 面向对象的相关概念",
      "对象：对象是指具体的某一个事物",
      "即在现实生活中能够看得见摸得着的事物",
      "在面向对象程序设计中，对象所指的是计算机系统中的某一个成分",
      "在面向对象程序设计中",
      "对象包含两个含义",
      "其中一个是数据",
      "另外一个是动作",
      "对象则是数据和动作的结合体",
      "对象不仅能够进行操作，同时还能够及时记录下操作结果",
      "类的实例化可生成对象",
      "一个对象的生命周期包括三个阶段：生成、使用、消除",
      "方法：方法是指对象能够进行的操作，即函数",
      "方法是类中的定义函数，其具体的作用就是对对象进行描述操作",
      "类是具有相同特性（数据元素）和行为（功能）的对象的抽象",
      "因此",
      "对象的抽象是类",
      "类的具体化就是对象",
      "也可以说类的实例是对象",
      "类实际上就是一种数据类型",
      "在我的理解中，类就像是一个带有内置函数的C语言中的结构体",
      "接口：在Java语言中,仅支持单一继承,即一个子类只能有一个直接的父类",
      "然而在日常生活中",
      "多继承的问题在所难免",
      "如电子书既是一种图书",
      "同时又是一种多媒体",
      "这种继承关系要求子类继承多个父类",
      "这样就可能导致子类具有多种多样的方法和实现形式",
      "所以Java",
      "不允许多继承",
      "为了解决多继承的问题",
      "Java 引入了接口的概念",
      " 定义一个接口不能使用",
      "class 关键字，而是使用 interface 关健字",
      "1.3 面向对象的核心特性",
      "继承性：继承简单地说就是一种层次模型，这种层次模型能够被重用",
      "层次结构的上层具有通用性，但是下层结构则具有特殊性",
      "在继承的过程中类则可以从最顶层的部分继承一些方法和变量",
      "类除了可以继承以外同时还能够进行修改或者添加",
      "通过这样的方式能够有效提高工作效率",
      "封装性：封装是将数据和代码捆绑到一起",
      "对象的某些数据和代码可以是私有的(private)",
      "不能被外界访问",
      "以此实现对数据和代码不同级别的访问权限",
      "防止了程序相互依赖性而带来的变动影响",
      "面向对象的封装比传统语言的封装更为清晰、更为有力",
      "有效实现了两个目标：对数据和行为的包装和信息隐藏",
      "多态性：多态是指不同事物具有不同表现形式的能力",
      "多态机制使具有不同内部结构的对象可以共享相同的外部接口",
      "通过这种方式减少代码的复杂度",
      "一个接口，多种方式",
      "2 面向对象的设计实例",
      "设计实例即Lab2中Graph接口以及其具体实现的子类",
      "2.1 Graph接口",
      "/**",
      "* A mutable weighted directed graph with labeled vertices.* Vertices have distinct labels of an immutable type {@code L} when compared",
      "* Edges are directed and have a positive weight of type {@code int}.* <p>PS2 instructions: this is a required ADT interface.* You MUST NOT change the specifications or add additional methods.* @param <L> type of vertex labels in this graph, must be immutable",
      "public interface Graph<L> {",
      "/**",
      "* Create an empty graph.* @param <L> type of vertex labels in the graph, must be immutable",
      "* @return a new empty weighted directed graph",
      "public static <L> Graph<L> empty() {",
      "return new ConcreteEdgesGraph<L>();/**",
      "* Add a vertex to this graph.* @param vertex label for the new vertex",
      "* @return true if this graph did not already include a vertex with the",
      "* given label; otherwise false (and this graph is not modified)",
      "public boolean add(L vertex);/**",
      "* Add, change, or remove a weighted directed edge in this graph.* If weight is nonzero, add an edge or update the weight of that edge;* vertices with the given labels are added to the graph if they do not",
      "* @param source label of the source vertex",
      "* @param target label of the target vertex",
      "* @param weight nonnegative weight of the edge",
      "* @return the previous weight of the edge, or zero if there was no such",
      "* edge",
      "public int set(L source, L target, int weight);/**",
      "* Remove a vertex from this graph; any edges to or from the vertex are",
      "* also removed.* @param vertex label of the vertex to remove",
      "* @return true if this graph included a vertex with the given label;* otherwise false (and this graph is not modified)",
      "public boolean remove(L vertex);/**",
      "* Get all the vertices in this graph.* @return the set of labels of vertices in this graph",
      "public Set<L> vertices();/**",
      "* Get the source vertices with directed edges to a target vertex and the",
      "* weights of those edges.* @return a map where the key set is the set of labels of vertices such",
      "* that this graph includes an edge from that vertex to target, and",
      "* the value for each key is the (nonzero) weight of the edge from",
      "public Map<L, Integer> sources(L target);/**",
      "* Get the target vertices with directed edges from a source vertex and the",
      "* weights of those edges.* @return a map where the key set is the set of labels of vertices such",
      "* that this graph includes an edge from source to that vertex, and",
      "* the value for each key is the (nonzero) weight of the edge from",
      "public Map<L, Integer> targets(L source);2.2 具体实现",
      "AF、RI、Safety from rep exposure",
      "CheckRep：ConcreteEdgesGraph中需要实现的方法(将方法全部实现即可)：ConcreteEdgesGraph：构造方法",
      "不需要初始化变量；checkRep：检查表示不变性；add：添加一个顶点到顶点集vertices",
      "不能重复加入；set：输入起点source、终点target和边权值weight",
      "若起点或终点不在vertices内",
      "则调用add将其加入",
      "若weight",
      "< 0",
      "则返回-1；当weight = 0时",
      "若边存在",
      "则删去该边；当weight >",
      "0时",
      "若该边不存在",
      "则将该边直接加入edges",
      "否则应删去原边后再将新的边和权值加入edges",
      "改变了原边权值时",
      "返回原边权值",
      "边不存在则返回0；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点",
      "返回所有指向该点的起点及边的权值；targets：输入起点",
      "返回该点指向的所有终点及边的权值；toString：字符串形式输出图",
      "每一条边的输出格式都与Edge类中toString方法中的返回形式相同",
      "原边后再将新的边和权值加入edges",
      "改变了原边权值时",
      "返回原边权值",
      "边不存在则返回0；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点",
      "返回所有指向该点的起点及边的权值；targets：输入起点",
      "返回该点指向的所有终点及边的权值；toString：字符串形式输出图",
      "每一条边的输出格式都与Edge类中toString方法中的返回形式相同"
    ],
    "codes": [
      "* using the {@link Object#equals(Object) equals} method.",
      "* already exist.",
      "* If weight is zero, remove the edge if it exists (the graph is not",
      "* otherwise modified).",
      "* @param target a label",
      "* the key to target",
      "* @param source a label",
      "* source to the key"
    ],
    "date": "2021-07-06",
    "text": "Java面向对象的一些相关概念及设计实例\n1 面向对象的相关概念\n1.1 面向对象\n面向对象(Object\nOriented)是软件开发方法，一种编程范式。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。\n1.2 面向对象的相关概念\n对象：\n对象是指具体的某一个事物，即在现实生活中能够看得见摸得着的事物。在面向对象程序设计中，对象所指的是计算机系统中的某一个成分。在面向对象程序设计中，对象包含两个含义，其中一个是数据，另外一个是动作。对象则是数据和动作的结合体。对象不仅能够进行操作，同时还能够及时记录下操作结果。类的实例化可生成对象，一个对象的生命周期包括三个阶段：生成、使用、消除。\n方法：\n方法是指对象能够进行的操作，即函数。方法是类中的定义函数，其具体的作用就是对对象进行描述操作。\n类是具有相同特性（数据元素）和行为（功能）的对象的抽象。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象，类实际上就是一种数据类型。在我的理解中，类就像是一个带有内置函数的C语言中的结构体。\n接口：\n在Java语言中,仅支持单一继承,即一个子类只能有一个直接的父类，然而在日常生活中，多继承的问题在所难免\n如电子书既是一种图书，同时又是一种多媒体，这种继承关系要求子类继承多个父类。这样就可能导致子类具有多种多样的方法和实现形式。所以Java\n不允许多继承，为了解决多继承的问题，Java 引入了接口的概念。 定义一个接口不能使用\nclass 关键字，而是使用 interface 关健字。\n1.3 面向对象的核心特性\n继承性：\n继承简单地说就是一种层次模型，这种层次模型能够被重用。层次结构的上层具有通用性，但是下层结构则具有特殊性。在继承的过程中类则可以从最顶层的部分继承一些方法和变量。类除了可以继承以外同时还能够进行修改或者添加。通过这样的方式能够有效提高工作效率。\n封装性：\n封装是将数据和代码捆绑到一起，对象的某些数据和代码可以是私有的(private)，不能被外界访问，以此实现对数据和代码不同级别的访问权限。防止了程序相互依赖性而带来的变动影响，面向对象的封装比传统语言的封装更为清晰、更为有力。有效实现了两个目标：对数据和行为的包装和信息隐藏。\n多态性：\n多态是指不同事物具有不同表现形式的能力。多态机制使具有不同内部结构的对象可以共享相同的外部接口，通过这种方式减少代码的复杂度。一个接口，多种方式。\n2 面向对象的设计实例\n设计实例即Lab2中Graph接口以及其具体实现的子类。\n2.1 Graph接口\n/**\n* A mutable weighted directed graph with labeled vertices.\n* Vertices have distinct labels of an immutable type {@code L} when compared\n* Edges are directed and have a positive weight of type {@code int}.\n* <p>PS2 instructions: this is a required ADT interface.\n* You MUST NOT change the specifications or add additional methods.\n* @param <L> type of vertex labels in this graph, must be immutable\npublic interface Graph<L> {\n/**\n* Create an empty graph.\n* @param <L> type of vertex labels in the graph, must be immutable\n* @return a new empty weighted directed graph\npublic static <L> Graph<L> empty() {\nreturn new ConcreteEdgesGraph<L>();\n/**\n* Add a vertex to this graph.\n* @param vertex label for the new vertex\n* @return true if this graph did not already include a vertex with the\n* given label; otherwise false (and this graph is not modified)\npublic boolean add(L vertex);\n/**\n* Add, change, or remove a weighted directed edge in this graph.\n* If weight is nonzero, add an edge or update the weight of that edge;\n* vertices with the given labels are added to the graph if they do not\n* @param source label of the source vertex\n* @param target label of the target vertex\n* @param weight nonnegative weight of the edge\n* @return the previous weight of the edge, or zero if there was no such\n* edge\npublic int set(L source, L target, int weight);\n/**\n* Remove a vertex from this graph; any edges to or from the vertex are\n* also removed.\n* @param vertex label of the vertex to remove\n* @return true if this graph included a vertex with the given label;\n* otherwise false (and this graph is not modified)\npublic boolean remove(L vertex);\n/**\n* Get all the vertices in this graph.\n* @return the set of labels of vertices in this graph\npublic Set<L> vertices();\n/**\n* Get the source vertices with directed edges to a target vertex and the\n* weights of those edges.\n* @return a map where the key set is the set of labels of vertices such\n* that this graph includes an edge from that vertex to target, and\n* the value for each key is the (nonzero) weight of the edge from\npublic Map<L, Integer> sources(L target);\n/**\n* Get the target vertices with directed edges from a source vertex and the\n* weights of those edges.\n* @return a map where the key set is the set of labels of vertices such\n* that this graph includes an edge from source to that vertex, and\n* the value for each key is the (nonzero) weight of the edge from\npublic Map<L, Integer> targets(L source);\n2.2 具体实现\nAF、RI、Safety from rep exposure\nCheckRep：\nConcreteEdgesGraph中需要实现的方法(将方法全部实现即可)：\nConcreteEdgesGraph：构造方法，不需要初始化变量；\ncheckRep：检查表示不变性；\nadd：添加一个顶点到顶点集vertices，不能重复加入；\nset：输入起点source、终点target和边权值weight，若起点或终点不在vertices内，则调用add将其加入。若weight\n< 0，则返回-1；当weight = 0时，若边存在，则删去该边；当weight >\n0时，若该边不存在，则将该边直接加入edges，否则应删去原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；\nremote：去除某一点以及与它有关的所有边；\nvertices：返回顶点集vertices；\nsources：输入终点，返回所有指向该点的起点及边的权值；\ntargets：输入起点，返回该点指向的所有终点及边的权值；\ntoString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。\n原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；\nremote：去除某一点以及与它有关的所有边；\nvertices：返回顶点集vertices；\nsources：输入终点，返回所有指向该点的起点及边的权值；\ntargets：输入起点，返回该点指向的所有终点及边的权值；\ntoString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。\n"
  },
  {
    "head": "学完哈工大软件构造的一点小心得",
    "paragraphs": [
      "其实这个课应该叫Java编程深入学习（笑",
      "写一点学习时感觉比较容易混淆的点，可能有错漏，大神轻喷",
      "final的修饰作用",
      "用来修饰一个引用",
      "如果引用为基本数据类型，则该引用为常量，该值无法修改；",
      "如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。",
      "如果引用时类的成员变量，则必须当场赋值，否则编译会报错。（或者在实例化类时，在构造函数将final修饰的成员变量全部赋值）",
      "总之就是固定了引用，使一个引用不能被改变，由于基本数据类型引用和数据是一一对应的，因此固定引用就是固定了数值。",
      "用来修饰一个方法",
      "当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。主要用于严格继承，子类无需重写父类中的方法",
      "用来修饰类",
      "当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。",
      "静态方法，静态变量（或者叫类方法，类变量），实例方法，实例变量",
      "概念：实例化，就是你新建一个对象的那个动作就叫实例化，实例方法和变量就是基于已经生成的对象的东西，而类方法和类变量不用实例化变量就可以使用（经典例子：Math.sin()），因为是每个类共有的东西，因此冠以类方法类变量的名称",
      "实例变量（instance variable）",
      "实例变量：或叫实例域、实例字段（instance field），或叫成员变量（member variable）。实例的变量，每个实例的变量可能不同。",
      "实例方法（instance method）",
      "实例方法：或叫成员方法（member method）。供实例用的方法，必须要先有实例，才能通过此实例调用实例方法。",
      "类变量（class variable）",
      "类变量：或叫静态域、静态字段（static field），或叫静态变量（static variable）。出现在这样的情况下：一个类的所有实例需要一个公有的属性，比如，一，统计实例个数；二，常量。类变量与类直接关联在一起。内存当中只有一个地方存放这个变量。任何实例都可以修改它的值（前提是它没有被final修饰符修饰，不然就是常量），但是，访问类变量并不需要实例，用类就可以操作了。",
      "类方法（class method）",
      "类方法（class method）：跟类变量的基本特点一样。供类用的方法，可以没有实例，直接通过类来调用类方法。",
      "从形式上看，类变量和类方法，比一般的变量和方法多了一个static修饰符。因为这个原因，类变量和类方法也被叫做静态变量和静态方法。",
      "使用方式",
      "实例方法可以直接访问实例变量，调用实例方法；",
      "实例方法可以直接访问类变量，调用类方法。但不推荐这么做，原因是不清晰，容易把类变量误认为是实例变量，把类方法误认为是实例方法（借助IDE，它会给出警告信息）；",
      "类方法可以直接调用类变量和类方法；",
      "类方法不能直接调用实例变量和实例方法；",
      "类方法里面不能使用“this”关键字，因为没有实例存在，“this”不知道引用哪个实例。",
      "public, protected,friendly,private",
      "直接上图",
      "作用域",
      "当前类",
      "同一package",
      "子孙类",
      "其他package",
      "public",
      "protected",
      "friendly(default)",
      "private",
      "override&overload",
      "override（重写）发生在子类和父类中。",
      "重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！",
      "重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。",
      "重写规则",
      "参数列表与被重写方法的参数列表必须完全相同。",
      "返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。",
      "访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。",
      "父类的成员方法只能被它的子类重写。",
      "声明为 final 的方法不能被重写。",
      "声明为 static 的方法不能被重写，但是能够被再次声明。",
      "子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。",
      "子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。",
      "重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。",
      "构造方法不能被重写。",
      "如果不能继承一个类，则不能重写该类的方法",
      "overload（重载）可以发生在一个类中，或者父类和子类中",
      "重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。",
      "每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。",
      "重载规则:",
      "被重载的方法必须改变参数列表(参数个数或类型不一样)；",
      "被重载的方法可以改变返回类型；",
      "被重载的方法可以改变访问修饰符；",
      "被重载的方法可以声明新的或更广的检查异常；",
      "方法能够在同一个类中或者在一个子类中被重载。",
      "无法以返回值类型作为重载函数的区分标准",
      "重写与重载之间的区别",
      "区别点",
      "重载方法",
      "重写方法",
      "参数列表",
      "必须修改",
      "一定不能修改",
      "返回类型",
      "可以修改",
      "一定不能修改",
      "可以修改",
      "可以减少或删除，一定不能抛出新的或者更广的异常",
      "可以修改",
      "一定不能做更严格的限制（可以降低限制）",
      "多态的三个方面",
      "Ad hoc polymorphism (特殊多态)：体现在overload上",
      "Parametric polymorphism (参数化多态)：体现在泛型上",
      "subtype polymorphism（子类型多态）：体现在继承上",
      "本质就是类，但是这些类已经实例化并存储在枚举列表中。枚举也可以有自己的构造方法，成员变量和成员方法。具体看",
      "https://blog.csdn.net/qq_35385687/article/details/90147104",
      "接口（静态方法和default方法）",
      "default方法",
      "：写在接口中，相当于正常的方法，可以写方法体，也可以正常使用。",
      "作用：由于修改接口需要修改接口所有相关的实现类，非常不利于开发维护，因此使用default给接口添加新的方法和实现，实现类会继承default方法，省去了重复开发的弊端。",
      "静态方法",
      "：类似类的静态方法，不用实例化对象就能直接调用。",
      "泛型通配符的一些小知识点",
      "具体看",
      "https://www.cnblogs.com/minikobe/p/11547220.html",
      "设计模式（工厂，适配器，装饰器，策略模式，模板模式，迭代器模式，访问者模式）",
      "工厂模式",
      "：将创建类的细节和逻辑与客户端隔离开。使用一个接口创建不同的子类。",
      "适配器模式",
      "：将一个接口转换为客户需要的另一个接口。",
      "假如客户现在使用的接口是A，而需要B的功能，但是B和A之间不兼容。这时候就可以创造适配器类，通过委托调用B的功能。然后修改A，若需要调用B的功能，则在A中委托生成适配器，间接调用B。",
      "缺点：使用过多类之间的关系会非常混乱，而且一个类只能使用一个适配器",
      "装饰器模式",
      "：动态地给一个对象添加一些额外的职责。",
      "假如客户现在使用的接口是A，需要一些功能可以灵活添加，则使用装饰器。首先构造一个抽象装饰类B实现接口A。但是抽象装饰类B并不具体实现装饰，而是委托调用装饰子类实现功能。接着我们写各种装饰子类，都继承自B，每个装饰类内部有具体的装饰功能。同时每个装饰子类中有一个构造函数，参数是最顶层的A。这意味这若要生成拥有多个特征的子类，只需在构造时每层嵌套一个装饰子类即可。",
      "策略模式",
      "：没啥好说的，就是全部是委托关系。类要使用的时候可以随意选择不同的策略类进行计算",
      "模板模式",
      "：类似给定程序框架，然后框架中的模块可以自定义。具体来说，给一个模板类，里面有一个表示方法逻辑关系的方法，在其中的不同方法的逻辑运行关系和流程是确定的，但是部分具体实现由于情况的不同而不同，这时我们可以通过子类继承该模板类，然后修改实现方法。",
      "注意，表示逻辑和流程的方法应该用final修饰，防止被子类更改。",
      "迭代器模式",
      "：以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。",
      "访问者模式",
      "：当需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中。",
      "具体操作，在被访问的类里面加一个对外提供接待访问者的接口，在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。",
      "在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT",
      "LSP原则：",
      "只要父类能出现的地方，子类就可以出现，并且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但反之，未要求。",
      "通俗点：子类可以扩展父类的功能，但不能改变父类原有的功能",
      "具体来说：",
      "子类可以实现父的抽象方法，但不能覆盖父类的非抽象方法",
      "覆盖或实现父类的方法时输入参数可以被放大，覆写或实现父类的方法时输出结果可以被缩小",
      "子类抛出的异常需要比父类具体",
      "实践中：",
      "在类中调用其它类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已违背了LSP",
      "如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。",
      "如果你的程序中出现了if/else之类对子类类型进行判断的条件，则说明类的设计已违背了LSP。",
      "CRP原则：",
      "软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。（能不用继承就不要用继承）",
      "委托（dependance, Composition, Aggregation）",
      "dependance：临时使用，在方法中new一个，使用完成后就抛弃",
      "composition：深入绑定，委派类作为该类的成员。",
      "aggregation：浅绑定，委派类作为该类某个方法的参数进行使用",
      "SOLID编程原则",
      "(SRP) The Single Responsibility Principle 单一责任原则",
      "当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。",
      "(OCP) The Open-Closed Principle 开放-封闭原则",
      "软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。",
      "(1)通过增加代码来扩展功能，而不是修改已经存在的代码。",
      "(2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。",
      "(3)OCP支持替换的服务，而不用修改客户模块。",
      "(LSP) The Liskov Substitution Principle Liskov替换原则",
      "客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。",
      "(DIP) The Dependency Inversion Principle 依赖转置原则",
      "(1).高层模块不要依赖低层模块；",
      "(2).高层和低层模块都要依赖于抽象；",
      "(3).抽象不要依赖于具体实现；",
      "(4).具体实现要依赖于抽象；",
      "(5).抽象和接口使模块之间的依赖分离",
      "(ISP) The Interface Segregation Principle 接口聚合原则",
      "不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。",
      "客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。"
    ],
    "sentences": [
      "其实这个课应该叫Java编程深入学习（笑",
      "写一点学习时感觉比较容易混淆的点，可能有错漏，大神轻喷",
      "final的修饰作用",
      "用来修饰一个引用",
      "如果引用为基本数据类型",
      "则该引用为常量",
      "该值无法修改；如果引用为引用数据类型",
      "比如对象、数组",
      "则该对象、数组本身可以修改",
      "但指向该对象或数组的地址的引用不能修改",
      "如果引用时类的成员变量，则必须当场赋值，否则编译会报错",
      "（或者在实例化类时",
      "在构造函数将final修饰的成员变量全部赋值）",
      "总之就是固定了引用",
      "使一个引用不能被改变",
      "由于基本数据类型引用和数据是一一对应的",
      "因此固定引用就是固定了数值",
      "用来修饰一个方法",
      "当使用final修饰方法时",
      "这个方法将成为最终方法",
      "无法被子类重写",
      "但是，该方法仍然可以被继承",
      "主要用于严格继承，子类无需重写父类中的方法",
      "用来修饰类",
      "当用final修改类时，该类成为最终类，无法被继承",
      "简称为“断子绝孙类”",
      "静态方法",
      "静态变量（或者叫类方法",
      "类变量）",
      "实例方法",
      "实例变量",
      "概念：实例化",
      "就是你新建一个对象的那个动作就叫实例化",
      "实例方法和变量就是基于已经生成的对象的东西",
      "而类方法和类变量不用实例化变量就可以使用（经典例子：Math.sin()）",
      "因为是每个类共有的东西",
      "因此冠以类方法类变量的名称",
      "实例变量（instance variable）",
      "实例变量：或叫实例域、实例字段（instance field）",
      "或叫成员变量（member variable）",
      "实例的变量，每个实例的变量可能不同",
      "实例方法（instance method）",
      "实例方法：或叫成员方法（member method）",
      "供实例用的方法，必须要先有实例，才能通过此实例调用实例方法",
      "类变量（class variable）",
      "类变量：或叫静态域、静态字段（static field）",
      "或叫静态变量（static variable）",
      "出现在这样的情况下：一个类的所有实例需要一个公有的属性",
      "比如",
      "一",
      "统计实例个数；二",
      "常量",
      "类变量与类直接关联在一起",
      "内存当中只有一个地方存放这个变量",
      "任何实例都可以修改它的值（前提是它没有被final修饰符修饰",
      "不然就是常量）",
      "但是",
      "访问类变量并不需要实例",
      "用类就可以操作了",
      "类方法（class method）",
      "类方法（class method）：跟类变量的基本特点一样",
      "供类用的方法，可以没有实例，直接通过类来调用类方法",
      "从形式上看",
      "类变量和类方法",
      "比一般的变量和方法多了一个static修饰符",
      "因为这个原因，类变量和类方法也被叫做静态变量和静态方法",
      "使用方式",
      "实例方法可以直接访问实例变量",
      "调用实例方法；实例方法可以直接访问类变量",
      "调用类方法",
      "但不推荐这么做",
      "原因是不清晰",
      "容易把类变量误认为是实例变量",
      "把类方法误认为是实例方法（借助IDE",
      "它会给出警告信息）；类方法可以直接调用类变量和类方法；类方法不能直接调用实例变量和实例方法；类方法里面不能使用“this”关键字",
      "因为没有实例存在",
      "“this”不知道引用哪个实例",
      "public, protected,friendly,private",
      "直接上图",
      "作用域",
      "当前类",
      "同一package",
      "子孙类",
      "其他package",
      "public",
      "protected",
      "friendly(default)",
      "private",
      "override&overload",
      "override（重写）发生在子类和父类中",
      "重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变",
      "即外壳不变，核心重写！",
      "重写的好处在于子类可以根据需要，定义特定于自己的行为",
      " 也就是说子类能够根据需要实现父类的方法",
      "重写规则",
      "参数列表与被重写方法的参数列表必须完全相同",
      "返回类型与被重写方法的返回类型可以不相同",
      "但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样",
      "java7 及更高版本可以不同）",
      "访问权限不能比父类中被重写的方法的访问权限更低",
      "例如：如果父类的一个方法被声明为 public",
      "那么在子类中重写该方法就不能声明为 protected",
      "父类的成员方法只能被它的子类重写",
      "声明为 final 的方法不能被重写",
      "声明为 static 的方法不能被重写，但是能够被再次声明",
      "子类和父类在同一个包中",
      "那么子类可以重写父类所有方法",
      "除了声明为 private 和 final 的方法",
      "子类和父类不在同一个包中",
      "那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法",
      "重写的方法能够抛出任何非强制异常",
      "无论被重写的方法是否抛出异常",
      "但是",
      "重写的方法不能抛出新的强制性异常",
      "或者比被重写方法声明的更广泛的强制性异常",
      "反之则可以",
      "构造方法不能被重写",
      "如果不能继承一个类，则不能重写该类的方法",
      "overload（重载）可以发生在一个类中，或者父类和子类中",
      "重载是在一个类里面，方法名字相同，而参数不同",
      "返回类型可以相同也可以不同",
      "每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表",
      "重载规则:被重载的方法必须改变参数列表(参数个数或类型不一样)；被重载的方法可以改变返回类型；被重载的方法可以改变访问修饰符；被重载的方法可以声明新的或更广的检查异常；方法能够在同一个类中或者在一个子类中被重载",
      "无法以返回值类型作为重载函数的区分标准",
      "重写与重载之间的区别",
      "区别点",
      "重载方法",
      "重写方法",
      "参数列表",
      "必须修改",
      "一定不能修改",
      "返回类型",
      "可以修改",
      "一定不能修改",
      "可以修改",
      "可以减少或删除，一定不能抛出新的或者更广的异常",
      "可以修改",
      "一定不能做更严格的限制（可以降低限制）",
      "多态的三个方面",
      "Ad hoc polymorphism (特殊多态)：体现在overload上",
      "Parametric polymorphism (参数化多态)：体现在泛型上",
      "subtype polymorphism（子类型多态）：体现在继承上",
      "本质就是类，但是这些类已经实例化并存储在枚举列表中",
      "枚举也可以有自己的构造方法，成员变量和成员方法",
      "具体看",
      "https://blog.csdn.net/qq_35385687/article/details/90147104",
      "接口（静态方法和default方法）",
      "default方法",
      "：写在接口中，相当于正常的方法，可以写方法体，也可以正常使用",
      "作用：由于修改接口需要修改接口所有相关的实现类",
      "非常不利于开发维护",
      "因此使用default给接口添加新的方法和实现",
      "实现类会继承default方法",
      "省去了重复开发的弊端",
      "静态方法",
      "：类似类的静态方法，不用实例化对象就能直接调用",
      "泛型通配符的一些小知识点",
      "具体看",
      "https://www.cnblogs.com/minikobe/p/11547220.html",
      "设计模式（工厂",
      "适配器",
      "装饰器",
      "策略模式",
      "模板模式",
      "迭代器模式",
      "访问者模式）",
      "工厂模式",
      "：将创建类的细节和逻辑与客户端隔离开",
      "使用一个接口创建不同的子类",
      "适配器模式",
      "：将一个接口转换为客户需要的另一个接口",
      "假如客户现在使用的接口是A",
      "而需要B的功能",
      "但是B和A之间不兼容",
      "这时候就可以创造适配器类，通过委托调用B的功能",
      "然后修改A",
      "若需要调用B的功能",
      "则在A中委托生成适配器",
      "间接调用B",
      "缺点：使用过多类之间的关系会非常混乱",
      "而且一个类只能使用一个适配器",
      "装饰器模式",
      "：动态地给一个对象添加一些额外的职责",
      "假如客户现在使用的接口是A",
      "需要一些功能可以灵活添加",
      "则使用装饰器",
      "首先构造一个抽象装饰类B实现接口A",
      "但是抽象装饰类B并不具体实现装饰",
      "而是委托调用装饰子类实现功能",
      "接着我们写各种装饰子类",
      "都继承自B",
      "每个装饰类内部有具体的装饰功能",
      "同时每个装饰子类中有一个构造函数，参数是最顶层的A",
      "这意味这若要生成拥有多个特征的子类",
      "只需在构造时每层嵌套一个装饰子类即可",
      "策略模式",
      "：没啥好说的，就是全部是委托关系",
      "类要使用的时候可以随意选择不同的策略类进行计算",
      "模板模式",
      "：类似给定程序框架，然后框架中的模块可以自定义",
      "具体来说",
      "给一个模板类",
      "里面有一个表示方法逻辑关系的方法",
      "在其中的不同方法的逻辑运行关系和流程是确定的",
      "但是部分具体实现由于情况的不同而不同",
      "这时我们可以通过子类继承该模板类",
      "然后修改实现方法",
      "注意",
      "表示逻辑和流程的方法应该用final修饰",
      "防止被子类更改",
      "迭代器模式",
      "：以遍历的方式访问集合数据而无需暴露其内部表示",
      "将“遍历”这项功能delegate到外部的iterator对象",
      "访问者模式",
      "：当需要对一个对象结构中的对象进行很多不同的并且不相关的操作",
      "而需要避免让这些操作\"污染\"这些对象的类",
      "使用访问者模式将这些封装到类中",
      "具体操作",
      "在被访问的类里面加一个对外提供接待访问者的接口",
      "在数据基础类里面有一个方法接受访问者",
      "将自身引用传入访问者",
      "在特定ADT上执行某种特定操作",
      "但该操作不在ADT内部实现",
      "而是delegate到独立的visitor对象",
      "客户端可灵活扩展/改变visitor的操作算法",
      "而不影响ADT",
      "LSP原则：只要父类能出现的地方",
      "子类就可以出现",
      "并且替换为子类也不会产生任何错误或异常",
      "使用者可能根本就不需要知道是父类还是子类",
      "但反之，未要求",
      "通俗点：子类可以扩展父类的功能，但不能改变父类原有的功能",
      "具体来说：子类可以实现父的抽象方法",
      "但不能覆盖父类的非抽象方法",
      "覆盖或实现父类的方法时输入参数可以被放大",
      "覆写或实现父类的方法时输出结果可以被缩小",
      "子类抛出的异常需要比父类具体",
      "实践中：在类中调用其它类时务必要使用父类或接口",
      "如果不能使用父类或接口",
      "则说明类的设计已违背了LSP",
      "如果子类不能完整地实现父类的方法",
      "或者父类的某些方法在子类中已经发生“畸变”",
      "则建议断开父子继承关系",
      "采用依赖、聚集、组合等关系代替继承",
      "如果你的程序中出现了if/else之类对子类类型进行判断的条件",
      "则说明类的设计已违背了LSP",
      "CRP原则：软件复用时",
      "要尽量先使用组合或者聚合等关联关系来实现",
      "其次才考虑使用继承关系来实现",
      "（能不用继承就不要用继承）",
      "委托（dependance, Composition, Aggregation）",
      "dependance：临时使用",
      "在方法中new一个",
      "使用完成后就抛弃",
      "composition：深入绑定，委派类作为该类的成员",
      "aggregation：浅绑定",
      "委派类作为该类某个方法的参数进行使用",
      "SOLID编程原则",
      "(SRP) The Single Responsibility Principle 单一责任原则",
      "当需要修改某个类的时候原因有且只有一个",
      "换句话说就是让一个类只做一种类型责任",
      "当这个类需要承当其他类型的责任的时候",
      "就需要分解这个类",
      " 类被修改的几率很大，因此应该专注于单一的功能",
      "如果你把多个功能放在同一个类中",
      "功能之间就形成了关联",
      "改变其中一个功能",
      "有可能中止另一个功能",
      "这时就需要新一轮的测试来避免可能出现的问题",
      "非常耗时耗力",
      "(OCP) The Open-Closed Principle 开放-封闭原则",
      "软件实体应该是可扩展，而不可修改的",
      "也就是说，对扩展是开放的，而对修改是封闭的",
      "这个原则是诸多面向对象编程原则中最抽象、最难理解的一个",
      "(1)通过增加代码来扩展功能，而不是修改已经存在的代码",
      "(2)若客户模块和服务模块遵循同一个接口来设计",
      "则客户模块可以不关心服务模块的类型",
      "服务模块可以方便扩展服务(代码)",
      "(3)OCP支持替换的服务，而不用修改客户模块",
      "(LSP) The Liskov Substitution Principle Liskov替换原则",
      "客户模块不应关心服务模块的是如何工作的；同样的接口模块之间",
      "可以在不知道服务模块代码的情况下",
      "进行替换",
      "即接口或父类出现的地方，实现接口的类或子类可以代入",
      "(DIP) The Dependency Inversion Principle 依赖转置原则",
      "(1).高层模块不要依赖低层模块；(2).高层和低层模块都要依赖于抽象；(3).抽象不要依赖于具体实现；(4).具体实现要依赖于抽象；(5).抽象和接口使模块之间的依赖分离",
      "(ISP) The Interface Segregation Principle 接口聚合原则",
      "不能强迫用户去依赖那些他们不使用的接口",
      "换句话说，使用多个专门的接口比使用单一的总接口总要好",
      "客户模块不应该依赖大的接口",
      "应该裁减为小的接口给客户模块使用",
      "以减少依赖性",
      "如Java中一个类实现多个接口",
      "不同的接口给不用的客户模块使用",
      "而不是提供给客户模块一个大的接口"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "其实这个课应该叫Java编程深入学习（笑\n写一点学习时感觉比较容易混淆的点，可能有错漏，大神轻喷\nfinal的修饰作用\n用来修饰一个引用\n如果引用为基本数据类型，则该引用为常量，该值无法修改；\n如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。\n如果引用时类的成员变量，则必须当场赋值，否则编译会报错。（或者在实例化类时，在构造函数将final修饰的成员变量全部赋值）\n总之就是固定了引用，使一个引用不能被改变，由于基本数据类型引用和数据是一一对应的，因此固定引用就是固定了数值。\n用来修饰一个方法\n当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。主要用于严格继承，子类无需重写父类中的方法\n用来修饰类\n当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。\n静态方法，静态变量（或者叫类方法，类变量），实例方法，实例变量\n概念：实例化，就是你新建一个对象的那个动作就叫实例化，实例方法和变量就是基于已经生成的对象的东西，而类方法和类变量不用实例化变量就可以使用（经典例子：Math.sin()），因为是每个类共有的东西，因此冠以类方法类变量的名称\n实例变量（instance variable）\n实例变量：或叫实例域、实例字段（instance field），或叫成员变量（member variable）。实例的变量，每个实例的变量可能不同。\n实例方法（instance method）\n实例方法：或叫成员方法（member method）。供实例用的方法，必须要先有实例，才能通过此实例调用实例方法。\n类变量（class variable）\n类变量：或叫静态域、静态字段（static field），或叫静态变量（static variable）。出现在这样的情况下：一个类的所有实例需要一个公有的属性，比如，一，统计实例个数；二，常量。类变量与类直接关联在一起。内存当中只有一个地方存放这个变量。任何实例都可以修改它的值（前提是它没有被final修饰符修饰，不然就是常量），但是，访问类变量并不需要实例，用类就可以操作了。\n类方法（class method）\n类方法（class method）：跟类变量的基本特点一样。供类用的方法，可以没有实例，直接通过类来调用类方法。\n从形式上看，类变量和类方法，比一般的变量和方法多了一个static修饰符。因为这个原因，类变量和类方法也被叫做静态变量和静态方法。\n使用方式\n实例方法可以直接访问实例变量，调用实例方法；\n实例方法可以直接访问类变量，调用类方法。但不推荐这么做，原因是不清晰，容易把类变量误认为是实例变量，把类方法误认为是实例方法（借助IDE，它会给出警告信息）；\n类方法可以直接调用类变量和类方法；\n类方法不能直接调用实例变量和实例方法；\n类方法里面不能使用“this”关键字，因为没有实例存在，“this”不知道引用哪个实例。\npublic, protected,friendly,private\n直接上图\n作用域\n当前类\n同一package\n子孙类\n其他package\npublic\nprotected\nfriendly(default)\nprivate\noverride&overload\noverride（重写）发生在子类和父类中。\n重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！\n重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。\n重写规则\n参数列表与被重写方法的参数列表必须完全相同。\n返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。\n访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。\n父类的成员方法只能被它的子类重写。\n声明为 final 的方法不能被重写。\n声明为 static 的方法不能被重写，但是能够被再次声明。\n子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。\n子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。\n重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n构造方法不能被重写。\n如果不能继承一个类，则不能重写该类的方法\noverload（重载）可以发生在一个类中，或者父类和子类中\n重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n重载规则:\n被重载的方法必须改变参数列表(参数个数或类型不一样)；\n被重载的方法可以改变返回类型；\n被重载的方法可以改变访问修饰符；\n被重载的方法可以声明新的或更广的检查异常；\n方法能够在同一个类中或者在一个子类中被重载。\n无法以返回值类型作为重载函数的区分标准\n重写与重载之间的区别\n区别点\n重载方法\n重写方法\n参数列表\n必须修改\n一定不能修改\n返回类型\n可以修改\n一定不能修改\n可以修改\n可以减少或删除，一定不能抛出新的或者更广的异常\n可以修改\n一定不能做更严格的限制（可以降低限制）\n多态的三个方面\nAd hoc polymorphism (特殊多态)：体现在overload上\nParametric polymorphism (参数化多态)：体现在泛型上\nsubtype polymorphism（子类型多态）：体现在继承上\n本质就是类，但是这些类已经实例化并存储在枚举列表中。枚举也可以有自己的构造方法，成员变量和成员方法。具体看\nhttps://blog.csdn.net/qq_35385687/article/details/90147104\n接口（静态方法和default方法）\ndefault方法\n：写在接口中，相当于正常的方法，可以写方法体，也可以正常使用。\n作用：由于修改接口需要修改接口所有相关的实现类，非常不利于开发维护，因此使用default给接口添加新的方法和实现，实现类会继承default方法，省去了重复开发的弊端。\n静态方法\n：类似类的静态方法，不用实例化对象就能直接调用。\n泛型通配符的一些小知识点\n具体看\nhttps://www.cnblogs.com/minikobe/p/11547220.html\n设计模式（工厂，适配器，装饰器，策略模式，模板模式，迭代器模式，访问者模式）\n工厂模式\n：将创建类的细节和逻辑与客户端隔离开。使用一个接口创建不同的子类。\n适配器模式\n：将一个接口转换为客户需要的另一个接口。\n假如客户现在使用的接口是A，而需要B的功能，但是B和A之间不兼容。这时候就可以创造适配器类，通过委托调用B的功能。然后修改A，若需要调用B的功能，则在A中委托生成适配器，间接调用B。\n缺点：使用过多类之间的关系会非常混乱，而且一个类只能使用一个适配器\n装饰器模式\n：动态地给一个对象添加一些额外的职责。\n假如客户现在使用的接口是A，需要一些功能可以灵活添加，则使用装饰器。首先构造一个抽象装饰类B实现接口A。但是抽象装饰类B并不具体实现装饰，而是委托调用装饰子类实现功能。接着我们写各种装饰子类，都继承自B，每个装饰类内部有具体的装饰功能。同时每个装饰子类中有一个构造函数，参数是最顶层的A。这意味这若要生成拥有多个特征的子类，只需在构造时每层嵌套一个装饰子类即可。\n策略模式\n：没啥好说的，就是全部是委托关系。类要使用的时候可以随意选择不同的策略类进行计算\n模板模式\n：类似给定程序框架，然后框架中的模块可以自定义。具体来说，给一个模板类，里面有一个表示方法逻辑关系的方法，在其中的不同方法的逻辑运行关系和流程是确定的，但是部分具体实现由于情况的不同而不同，这时我们可以通过子类继承该模板类，然后修改实现方法。\n注意，表示逻辑和流程的方法应该用final修饰，防止被子类更改。\n迭代器模式\n：以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。\n访问者模式\n：当需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中。\n具体操作，在被访问的类里面加一个对外提供接待访问者的接口，在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。\n在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT\nLSP原则：\n只要父类能出现的地方，子类就可以出现，并且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但反之，未要求。\n通俗点：子类可以扩展父类的功能，但不能改变父类原有的功能\n具体来说：\n子类可以实现父的抽象方法，但不能覆盖父类的非抽象方法\n覆盖或实现父类的方法时输入参数可以被放大，覆写或实现父类的方法时输出结果可以被缩小\n子类抛出的异常需要比父类具体\n实践中：\n在类中调用其它类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已违背了LSP\n如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。\n如果你的程序中出现了if/else之类对子类类型进行判断的条件，则说明类的设计已违背了LSP。\nCRP原则：\n软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。（能不用继承就不要用继承）\n委托（dependance, Composition, Aggregation）\ndependance：临时使用，在方法中new一个，使用完成后就抛弃\ncomposition：深入绑定，委派类作为该类的成员。\naggregation：浅绑定，委派类作为该类某个方法的参数进行使用\nSOLID编程原则\n(SRP) The Single Responsibility Principle 单一责任原则\n当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。\n(OCP) The Open-Closed Principle 开放-封闭原则\n软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。\n(1)通过增加代码来扩展功能，而不是修改已经存在的代码。\n(2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。\n(3)OCP支持替换的服务，而不用修改客户模块。\n(LSP) The Liskov Substitution Principle Liskov替换原则\n客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。\n(DIP) The Dependency Inversion Principle 依赖转置原则\n(1).高层模块不要依赖低层模块；\n(2).高层和低层模块都要依赖于抽象；\n(3).抽象不要依赖于具体实现；\n(4).具体实现要依赖于抽象；\n(5).抽象和接口使模块之间的依赖分离\n(ISP) The Interface Segregation Principle 接口聚合原则\n不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。\n客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。\n"
  },
  {
    "head": "First Blog",
    "paragraphs": [
      "没有什么内容，用来测试一下"
    ],
    "sentences": [
      "没有什么内容，用来测试一下"
    ],
    "codes": [],
    "date": "2021-05-07",
    "text": "没有什么内容，用来测试一下\n"
  },
  {
    "head": "对于装饰器模式的理解",
    "paragraphs": [
      "之前一直有个疑问，如果采用装饰器模式设计继承树，那客户端在调用的时候如何使用装饰器中的功能？原先理解的是客户端仍然只能查看接口，但接口带来的问题就是：子类添加的个性的方法无法体现在顶层的接口中，从而导致客户端无法使用子类的所有功能。",
      "例如:",
      "此时decorator无法调用b方法",
      "查看网上别人的代码后发现，装饰器模式的装饰应该只真对于自身，而不能被外界使用，即b方法应该被private修饰。"
    ],
    "sentences": [
      "之前一直有个疑问",
      "如果采用装饰器模式设计继承树",
      "那客户端在调用的时候如何使用装饰器中的功能？原先理解的是客户端仍然只能查看接口",
      "但接口带来的问题就是：子类添加的个性的方法无法体现在顶层的接口中",
      "从而导致客户端无法使用子类的所有功能",
      "例如:此时decorator无法调用b方法",
      "查看网上别人的代码后发现",
      "装饰器模式的装饰应该只真对于自身",
      "而不能被外界使用",
      "即b方法应该被private修饰"
    ],
    "codes": [
      "public interface A{\n\tpublic static A empty(){\n\t\treturn new A1();\n\t}\n\t\n\tpublic void a();\n}\n\npublic A1 implements A{\n\tpublic  A1(){}\n\t\n\t@Override\n\tpublic void a(){}\n}\n\npublic abstract Decorator implements  A{\n\tprotected A decoratedA;\n\t\n\tpublic Decorator(A a){\n\t\tdecoratedA = a;\n\t}\n\t\n\t@Override\n\tpublic void a(){\n\t\tdecoratedA.a();\n\t}\n}\n\npublic Decorator1 extends Decorator{\n\tpublic Decorator1(A a){\n\t\tsuper(a);\n\t}\n\n\tpublic void b(){};\n}\n\nA a = new A1();\nA decorator = new Decorator1(a);\n"
    ],
    "date": "2021-06-29",
    "text": "之前一直有个疑问，如果采用装饰器模式设计继承树，那客户端在调用的时候如何使用装饰器中的功能？原先理解的是客户端仍然只能查看接口，但接口带来的问题就是：子类添加的个性的方法无法体现在顶层的接口中，从而导致客户端无法使用子类的所有功能。\n例如:\n此时decorator无法调用b方法\n查看网上别人的代码后发现，装饰器模式的装饰应该只真对于自身，而不能被外界使用，即b方法应该被private修饰。\n"
  },
  {
    "head": "Lab2中关于equals方法的一个问题（尚未解决）",
    "paragraphs": [
      "lab2实验中要求不能有警告且不能用@SuppressWarnings取消警告。然而，在为包含泛型的可变类型写equals方法时，遇到了如下问题",
      "在类型转换时，编译器报警告：Type safety: Unchecked cast from Object to Graph。网上给出的方法均是使用@SuppressWarnings(“unchecked”)或者设置IDE来忽视该警告。是否有其他解决办法？"
    ],
    "sentences": [
      "lab2实验中要求不能有警告且不能用@SuppressWarnings取消警告",
      "然而",
      "在为包含泛型的可变类型写equals方法时",
      "遇到了如下问题",
      "在类型转换时",
      "编译器报警告：Type safety: Unchecked cast from Object to Graph",
      "网上给出的方法均是使用@SuppressWarnings(“unchecked”)或者设置IDE来忽视该警告",
      "是否有其他解决办法？"
    ],
    "codes": [
      "Class Graph<L>\n{\n\t@Override\n\tpublic boolean equals(Object obj)\n\t{\n\t\tif(obj == null)\n\t\t\treturn false;\n\t\tif(!(obj instanceof Graph))\n\t\t\treturn false;\n\t\tGraph<L> g = (Graph<L>) obj;\n\t}\n}\n"
    ],
    "date": "2021-07-07",
    "text": "lab2实验中要求不能有警告且不能用@SuppressWarnings取消警告。然而，在为包含泛型的可变类型写equals方法时，遇到了如下问题\n在类型转换时，编译器报警告：Type safety: Unchecked cast from Object to Graph。网上给出的方法均是使用@SuppressWarnings(“unchecked”)或者设置IDE来忽视该警告。是否有其他解决办法？\n"
  },
  {
    "head": "软件构造Lab3中关于时间相关类的设计",
    "paragraphs": [
      "在lab3中，不同的应用需要的时间格式不同，但IntervalSet接口统一采用了long类型作为时间点参数。为了能够使用IntervalSet接口，初步考虑使用一个时间类进行统一的转换。本来采用了Java自带的Date数据类型作为转换头，但由于Date中大部分的方法已经被舍弃了，无法作为解码器使用；除此之外，由于从给定日期到1900年1月1日的毫秒数过大，在课表APP中担心爆long，因此需要重新设计APP。最终人为定义了一个编解码器类，每个APP需要时调用作为编解码器将时间与long进行转换。排班与课表APP采用从1900年1月1日到给定时间的天数作为编码结果，保证了编码的连续性；其中课表可以将天数乘10转换为课时数，并且也保证了连续。"
    ],
    "sentences": [
      "在lab3中",
      "不同的应用需要的时间格式不同",
      "但IntervalSet接口统一采用了long类型作为时间点参数",
      "为了能够使用IntervalSet接口",
      "初步考虑使用一个时间类进行统一的转换",
      "本来采用了Java自带的Date数据类型作为转换头",
      "但由于Date中大部分的方法已经被舍弃了",
      "无法作为解码器使用；除此之外",
      "由于从给定日期到1900年1月1日的毫秒数过大",
      "在课表APP中担心爆long",
      "因此需要重新设计APP",
      "最终人为定义了一个编解码器类",
      "每个APP需要时调用作为编解码器将时间与long进行转换",
      "排班与课表APP采用从1900年1月1日到给定时间的天数作为编码结果",
      "保证了编码的连续性；其中课表可以将天数乘10转换为课时数",
      "并且也保证了连续"
    ],
    "codes": [
      "class DutyCodec\n{\n\tpublic DutyCodec() {}\n\t\n\t/**\n\t * Encode a date to a long integer\n\t * @param year the year of the date\n\t * @param month the month of the date\n\t * @param day the day of the date\n\t * @return a long integer indicates the code of the date\n\t */\n\tpublic long encode(int year, int month, int day) throws DateError\n\t{\n\t\tlong code = day - 1;\n\t\t\n\t\tif(year < 1900 || month <= 0 || day <= 0 || month > 12 || day > 31)\n\t\t\tthrow new DateError(\"Invalid date\");\n\t\tif(day == 31)\n\t\t\tif(month == 2 || month == 4 || month == 6 || month == 9 || month == 11)\n\t\t\t\tthrow new DateError(\"Invalid date\");\n\t\tif(month == 2 && day == 29)\n\t\t\tif(!(year % 4 == 0 && year % 100 != 0))\n\t\t\t\tthrow new DateError(\"Invalid date\");\n\t\t\n\t\tfor(int i = 1900; i < year; i++)\n\t\t{\n\t\t\tif((i % 4 == 0 && i % 100 != 0) || i % 400 == 0)\n\t\t\t\tcode += 366;\n\t\t\telse\n\t\t\t\tcode += 365;\n\t\t}\n\t\tfor(int i = 1; i < month; i++)\n\t\t{\n\t\t\tif(!(i == 2 || i == 4 || i == 6 || i == 9 || i == 11))\n\t\t\t\tcode += 31;\n\t\t\telse if(i != 2)\n\t\t\t\tcode += 30;\n\t\t\telse\n\t\t\t\tcode += ((i % 4 == 0 && i % 100 != 0) || i % 400 == 0) ? 29 : 28;\n\t\t}\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * Get the year from the code\n\t * @param code the code want to decode\n\t * @return a integer indicates the year\n\t */\n\tpublic int getYear(long code)\n\t{\n\t\tint year = 0;\n\t\tfor(year = 1900; code >= 0; year++)\n\t\t{\n\t\t\tif((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n\t\t\t\tcode -= 366;\n\t\t\telse\n\t\t\t\tcode -= 365;\n\t\t}\n\t\t\n\t\treturn year - 1;\n\t}\n\t\n\t/**\n\t * Get the month from the code\n\t * @param code the code want to decode\n\t * @return a integer indicates the month\n\t */\n\tpublic int getMonth(long code)\n\t{\n\t\tint year = 0;\n\t\tint month = 0;\n\t\tfor(year = 1900; code >= 0; year++)\n\t\t{\n\t\t\tif((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n\t\t\t\tcode -= 366;\n\t\t\telse\n\t\t\t\tcode -= 365;\n\t\t}\n\t\tyear--;\n\t\tcode += ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) ? 366 : 365;\n\t\t\n\t\tfor(month = 1; code >= 0; month++)\n\t\t{\n\t\t\tif(!(month == 2 || month == 4 || month == 6 || month == 9 || month == 11))\n\t\t\t\tcode -= 31;\n\t\t\telse if(month != 2)\n\t\t\t\tcode -= 30;\n\t\t\telse\n\t\t\t\tcode -= ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) ? 29 : 28;\n\t\t}\n\t\t\n\t\treturn month - 1;\n\t}\n\t\n\t/**\n\t * Get the day from the code\n\t * @param code the code want to decode\n\t * @return a integer indicates the day\n\t */\n\tpublic int getDay(long code)\n\t{\n\t\tint year = 0;\n\t\tint month = 0;\n\t\tfor(year = 1900; code >= 0; year++)\n\t\t{\n\t\t\tif((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n\t\t\t\tcode -= 366;\n\t\t\telse\n\t\t\t\tcode -= 365;\n\t\t}\n\t\tyear--;\n\t\tcode += ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) ? 366 : 365;\n\t\t\n\t\tfor(month = 1; code >= 0; month++)\n\t\t{\n\t\t\tif(!(month == 2 || month == 4 || month == 6 || month == 9 || month == 11))\n\t\t\t\tcode -= 31;\n\t\t\telse if(month != 2)\n\t\t\t\tcode -= 30;\n\t\t\telse\n\t\t\t\tcode -= ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) ? 29 : 28;\n\t\t}\n\t\tmonth--;\n\t\tif(!(month == 2 || month == 4 || month == 6 || month == 9 || month == 11))\n\t\t\tcode += 31;\n\t\telse if(month != 2)\n\t\t\tcode += 30;\n\t\telse\n\t\t\tcode += ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) ? 29 : 28;\n\t\t\n\t\treturn (int) code + 1;\n\t}\n}\n"
    ],
    "date": "2021-07-05",
    "text": "在lab3中，不同的应用需要的时间格式不同，但IntervalSet接口统一采用了long类型作为时间点参数。为了能够使用IntervalSet接口，初步考虑使用一个时间类进行统一的转换。本来采用了Java自带的Date数据类型作为转换头，但由于Date中大部分的方法已经被舍弃了，无法作为解码器使用；除此之外，由于从给定日期到1900年1月1日的毫秒数过大，在课表APP中担心爆long，因此需要重新设计APP。最终人为定义了一个编解码器类，每个APP需要时调用作为编解码器将时间与long进行转换。排班与课表APP采用从1900年1月1日到给定时间的天数作为编码结果，保证了编码的连续性；其中课表可以将天数乘10转换为课时数，并且也保证了连续。\n"
  },
  {
    "head": "信息安全课作业1：老师迷惑的打油诗",
    "paragraphs": [
      "2021/5/25",
      "网上除了老师的微博，上一届学长写的还不是这个作业，所以写下来造福下以后的学弟学妹，不要浪费时间在这上面",
      "声明：图片都是作业自带的，跟我没关系（真的）",
      "第一题",
      "“二八”妙龄写密码，看谁聪明“爱死他”。",
      "密文：766C7273626F76706A5E6F715F7271766C72706D626B71716C6C71666A62",
      "明文：youverysmartbutyouspenttootime",
      "思路：爱死它表示为ascii编码（能从密文看出来），而",
      "，所以这个是一个偏移量为3的凯撒密码（原因是后找的，实际是枚举0到10枚举出来的）",
      "第二题",
      "无题警示：",
      "锦瑟无端五十弦，一弦一柱思华年，",
      "千帆远眺蝴蝶梦，",
      "撩人眼。",
      "沧海月明珠有泪，蓝田日暖玉生烟，",
      "此情可待成追忆，他年",
      "泪涟涟。",
      "密文：24205 29992 26204 26799 36864 34685 34687",
      "明文：庄生晓梦迷蝴蝶",
      "思路：和上一题思路差不多，“万国马”就是Unicode，“饮酒”对应09，然后还是一个凯撒密码",
      "后面的题开始坑爹了起来",
      "网上找的能用的Des在线加密解密网页",
      "http://www.jsons.cn/desencrypt/",
      "第三题：黛丝打靶",
      "日落西山红霞飞，战士打靶把营归。",
      "五发中靶二十二，黛丝秘诀子弹飞。",
      "密文：U2FsdGVkX18HM4A1Xow2e412F0IMPUSDVw/lNeTEtwDYAjSHsx61CQ==",
      "明文：you are very clover",
      "思路：“黛丝”对应Des算法；“日落西山红霞飞，战士打靶把营归”是打靶归来的第一句，里面有句“mi so la mi so， la so mi do re”，对应的简谱为 35635,65312。而3+5+6+3+5=22，所以密钥是35635",
      "第四题：迷人的黛丝",
      "打靶通关密语",
      "日落西山红霞飞，战士打靶把营归。",
      "张三成绩二十二，李四十七把牛吹。",
      "我的成绩比你好，先后起来你悲催；",
      "美女黛丝抿嘴笑，再来一次子弹飞。",
      "密文：U2FsdGVkX1+YN8tsns+7jvoarVmsqg316iBBvFP3ZemnrYEOGsI6bH5CvIVFSN0Y",
      "px1ka4fSPGj7cDvg81wU8BlnJYoDdhvl83cBIQDHk0JQnpaKXU3ZRA==",
      "明文：You are amazing",
      "思路：这题大部分和上一题一样，3+5+6+3+5=22，6+5+3+1+2=17，但如果直接用这俩，不管怎么拼接都不行。“再来一次子弹飞”可以看出需要解密两次。",
      "第一层：第三句“我的成绩比你好，先后起来你悲催”是关键，原本以为是拼接35635和65312的顺序，结果半天搞不定，甚至考虑了数字的单调性是不是对应“先后”这俩字。结果密钥是65312-35635=29677得到字符串“xxaqdl(p25-12-bstring)U2FsdGVkX199XCqgBzG3McJ1NuWuuPclqBS9lekxPpE=”",
      "第二层：你看这字符串的开头啊：信息安全导论（xxaqdl）第二十五页（p25）第十二行（12）二进制数对应的字符串（bstring5），诶，孤零零一个01000011，第二层密钥就它了，解密时记得把xxaqdl(p25-12-bstring)去掉，后面的才是密文"
    ],
    "sentences": [
      "2021/5/25",
      "网上除了老师的微博",
      "上一届学长写的还不是这个作业",
      "所以写下来造福下以后的学弟学妹",
      "不要浪费时间在这上面",
      "声明：图片都是作业自带的，跟我没关系（真的）",
      "第一题",
      "“二八”妙龄写密码，看谁聪明“爱死他”",
      "密文：766C7273626F76706A5E6F715F7271766C72706D626B71716C6C71666A62",
      "明文：youverysmartbutyouspenttootime",
      "思路：爱死它表示为ascii编码（能从密文看出来），而",
      "",
      "所以这个是一个偏移量为3的凯撒密码（原因是后找的",
      "实际是枚举0到10枚举出来的）",
      "第二题",
      "无题警示：锦瑟无端五十弦",
      "一弦一柱思华年",
      "千帆远眺蝴蝶梦",
      "撩人眼",
      "沧海月明珠有泪，蓝田日暖玉生烟，此情可待成追忆，他年",
      "泪涟涟",
      "密文：24205 29992 26204 26799 36864 34685 34687",
      "明文：庄生晓梦迷蝴蝶",
      "思路：和上一题思路差不多",
      "“万国马”就是Unicode",
      "“饮酒”对应09",
      "然后还是一个凯撒密码",
      "后面的题开始坑爹了起来",
      "网上找的能用的Des在线加密解密网页",
      "http://www.jsons.cn/desencrypt/",
      "第三题：黛丝打靶",
      "日落西山红霞飞，战士打靶把营归",
      "五发中靶二十二，黛丝秘诀子弹飞",
      "密文：U2FsdGVkX18HM4A1Xow2e412F0IMPUSDVw/lNeTEtwDYAjSHsx61CQ==",
      "明文：you are very clover",
      "思路：“黛丝”对应Des算法；“日落西山红霞飞",
      "战士打靶把营归”是打靶归来的第一句",
      "里面有句“mi so la mi so",
      " la so mi do re”",
      "对应的简谱为 35635,65312",
      "而3+5+6+3+5=22，所以密钥是35635",
      "第四题：迷人的黛丝",
      "打靶通关密语",
      "日落西山红霞飞，战士打靶把营归",
      "张三成绩二十二，李四十七把牛吹",
      "我的成绩比你好",
      "先后起来你悲催；美女黛丝抿嘴笑",
      "再来一次子弹飞",
      "密文：U2FsdGVkX1+YN8tsns+7jvoarVmsqg316iBBvFP3ZemnrYEOGsI6bH5CvIVFSN0Y",
      "px1ka4fSPGj7cDvg81wU8BlnJYoDdhvl83cBIQDHk0JQnpaKXU3ZRA==",
      "明文：You are amazing",
      "思路：这题大部分和上一题一样",
      "3+5+6+3+5=22",
      "6+5+3+1+2=17",
      "但如果直接用这俩",
      "不管怎么拼接都不行",
      "“再来一次子弹飞”可以看出需要解密两次",
      "第一层：第三句“我的成绩比你好",
      "先后起来你悲催”是关键",
      "原本以为是拼接35635和65312的顺序",
      "结果半天搞不定",
      "甚至考虑了数字的单调性是不是对应“先后”这俩字",
      "结果密钥是65312-35635=29677得到字符串“xxaqdl(p25-12-bstring)U2FsdGVkX199XCqgBzG3McJ1NuWuuPclqBS9lekxPpE=”",
      "第二层：你看这字符串的开头啊：信息安全导论（xxaqdl）第二十五页（p25）第十二行（12）二进制数对应的字符串（bstring5）",
      "诶",
      "孤零零一个01000011",
      "第二层密钥就它了",
      "解密时记得把xxaqdl(p25-12-bstring)去掉",
      "后面的才是密文"
    ],
    "codes": [],
    "date": "2021-05-25",
    "text": "2021/5/25\n网上除了老师的微博，上一届学长写的还不是这个作业，所以写下来造福下以后的学弟学妹，不要浪费时间在这上面\n声明：图片都是作业自带的，跟我没关系（真的）\n第一题\n“二八”妙龄写密码，看谁聪明“爱死他”。\n密文：766C7273626F76706A5E6F715F7271766C72706D626B71716C6C71666A62\n明文：youverysmartbutyouspenttootime\n思路：爱死它表示为ascii编码（能从密文看出来），而\n，所以这个是一个偏移量为3的凯撒密码（原因是后找的，实际是枚举0到10枚举出来的）\n第二题\n无题警示：\n锦瑟无端五十弦，一弦一柱思华年，\n千帆远眺蝴蝶梦，\n撩人眼。\n沧海月明珠有泪，蓝田日暖玉生烟，\n此情可待成追忆，他年\n泪涟涟。\n密文：24205 29992 26204 26799 36864 34685 34687\n明文：庄生晓梦迷蝴蝶\n思路：和上一题思路差不多，“万国马”就是Unicode，“饮酒”对应09，然后还是一个凯撒密码\n后面的题开始坑爹了起来\n网上找的能用的Des在线加密解密网页\nhttp://www.jsons.cn/desencrypt/\n第三题：黛丝打靶\n日落西山红霞飞，战士打靶把营归。\n五发中靶二十二，黛丝秘诀子弹飞。\n密文：U2FsdGVkX18HM4A1Xow2e412F0IMPUSDVw/lNeTEtwDYAjSHsx61CQ==\n明文：you are very clover\n思路：“黛丝”对应Des算法；“日落西山红霞飞，战士打靶把营归”是打靶归来的第一句，里面有句“mi so la mi so， la so mi do re”，对应的简谱为 35635,65312。而3+5+6+3+5=22，所以密钥是35635\n第四题：迷人的黛丝\n打靶通关密语\n日落西山红霞飞，战士打靶把营归。\n张三成绩二十二，李四十七把牛吹。\n我的成绩比你好，先后起来你悲催；\n美女黛丝抿嘴笑，再来一次子弹飞。\n密文：U2FsdGVkX1+YN8tsns+7jvoarVmsqg316iBBvFP3ZemnrYEOGsI6bH5CvIVFSN0Y\npx1ka4fSPGj7cDvg81wU8BlnJYoDdhvl83cBIQDHk0JQnpaKXU3ZRA==\n明文：You are amazing\n思路：这题大部分和上一题一样，3+5+6+3+5=22，6+5+3+1+2=17，但如果直接用这俩，不管怎么拼接都不行。“再来一次子弹飞”可以看出需要解密两次。\n第一层：第三句“我的成绩比你好，先后起来你悲催”是关键，原本以为是拼接35635和65312的顺序，结果半天搞不定，甚至考虑了数字的单调性是不是对应“先后”这俩字。结果密钥是65312-35635=29677得到字符串“xxaqdl(p25-12-bstring)U2FsdGVkX199XCqgBzG3McJ1NuWuuPclqBS9lekxPpE=”\n第二层：你看这字符串的开头啊：信息安全导论（xxaqdl）第二十五页（p25）第十二行（12）二进制数对应的字符串（bstring5），诶，孤零零一个01000011，第二层密钥就它了，解密时记得把xxaqdl(p25-12-bstring)去掉，后面的才是密文\n"
  },
  {
    "head": "已学的UML类图的基本元素",
    "paragraphs": [
      "单个类",
      "Class",
      "+String public",
      "-String private",
      "#String protected",
      "~String default",
      "+Abstract() : String",
      "+Static() : String",
      "如图中类图所示",
      "+表示public修饰符",
      "-表示private修饰符",
      "#表示protected修饰符",
      "~表示默认包权限，即本包可见，外部包不可见",
      "斜体字表示抽象方法",
      "下划线表示静态方法",
      "类间关系",
      "图中所示有误，应用空心三角与实线表示继承关系",
      "图中所示有误，应用空心三角与虚线表示继承关系",
      "聚合（has a关系）",
      "用空心菱形与实线箭头表示，如图表示B 含有一个 A"
    ],
    "sentences": [
      "单个类",
      "Class",
      "+String public",
      "-String private",
      "#String protected",
      "~String default",
      "+Abstract() : String",
      "+Static() : String",
      "如图中类图所示",
      "+表示public修饰符",
      "-表示private修饰符",
      "#表示protected修饰符",
      "~表示默认包权限，即本包可见，外部包不可见",
      "斜体字表示抽象方法",
      "下划线表示静态方法",
      "类间关系",
      "图中所示有误，应用空心三角与实线表示继承关系",
      "图中所示有误，应用空心三角与虚线表示继承关系",
      "聚合（has a关系）",
      "用空心菱形与实线箭头表示，如图表示B 含有一个 A"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "单个类\nClass\n+String public\n-String private\n#String protected\n~String default\n+Abstract() : String\n+Static() : String\n如图中类图所示\n+表示public修饰符\n-表示private修饰符\n#表示protected修饰符\n~表示默认包权限，即本包可见，外部包不可见\n斜体字表示抽象方法\n下划线表示静态方法\n类间关系\n图中所示有误，应用空心三角与实线表示继承关系\n图中所示有误，应用空心三角与虚线表示继承关系\n聚合（has a关系）\n用空心菱形与实线箭头表示，如图表示B 含有一个 A\n"
  },
  {
    "head": "JUnit测试是否正常抛出错误",
    "paragraphs": [
      "在使用JUnit测试代码时，课程上将的只有assertEquals函数。然而，assertEquals函数的实现是调用了对象提供的equals方法来判断被测是否与参照相同，如果程序抛出错误，assertEquals函数就无法捕获",
      "会抛出错误，假设此时我们需要测试是否正常抛出了越界错误，就不能使用assertEquals函数进行测试",
      "因此，JUnit提供了一个fail函数来判断是否抛出了异常，其随try catch块一起共同使用",
      "此时若被测代码没有抛出异常，则会执行fail函数"
    ],
    "sentences": [
      "在使用JUnit测试代码时",
      "课程上将的只有assertEquals函数",
      "然而",
      "assertEquals函数的实现是调用了对象提供的equals方法来判断被测是否与参照相同",
      "如果程序抛出错误",
      "assertEquals函数就无法捕获",
      "会抛出错误",
      "假设此时我们需要测试是否正常抛出了越界错误",
      "就不能使用assertEquals函数进行测试",
      "因此",
      "JUnit提供了一个fail函数来判断是否抛出了异常",
      "其随try catch块一起共同使用",
      "此时若被测代码没有抛出异常，则会执行fail函数"
    ],
    "codes": [
      "New List<Integer> list = new ArrayList<>();\nassertEquals(1, list.get(0));\n",
      "try\n{\n\t//被测代码\n\tfail(\"缺了异常\")；\n}\ncatch(Exception e)\n{\n\tSystem.out.println(\"e.getMessage()\");\n}\n"
    ],
    "date": "2021-07-05",
    "text": "在使用JUnit测试代码时，课程上将的只有assertEquals函数。然而，assertEquals函数的实现是调用了对象提供的equals方法来判断被测是否与参照相同，如果程序抛出错误，assertEquals函数就无法捕获\n会抛出错误，假设此时我们需要测试是否正常抛出了越界错误，就不能使用assertEquals函数进行测试\n因此，JUnit提供了一个fail函数来判断是否抛出了异常，其随try catch块一起共同使用\n此时若被测代码没有抛出异常，则会执行fail函数\n"
  },
  {
    "head": "2021-07-07",
    "paragraphs": [
      "关于多态的一些内容",
      "重载的多态",
      "与overload相关，主要是多个不同实现的方法具有相同的名字，但每个方法之间的参数必须有所区分。重载多态对于客户端而言是方便的，不需要记住大量方法的名字，根据输入的参数不同，会在静态类型检查时自动匹配相应的方法。",
      "例如：",
      "三者虽然方法名相同，但参数类型不同，因此符合重载多态",
      "注意：",
      "这两个方法虽然返回值类型不一致，但参数类型是相同的，不构成重载",
      "参数的多态",
      "参数多态即我们通常所说的泛型，当具体使用的数据类型还不确定时可以使用，能够提高代码的适用范围。",
      "例如：",
      "L便是我们所用的一个替代具体数据类型的一个标识符",
      "当我们需要赋予其具体类型时，例如String",
      "只需将先前的L换成我们所要使用是数据类型即可",
      "子类型多态",
      "子类型多态的前提条件有以下几点：",
      "要存在继承关系。",
      "重写子类（override)",
      "父类要引用子类对象。",
      "Bestfriend继承了父类friend，而且重写了方法makefriend,二者都定义了一个成员变量a.",
      "测试：",
      "输出结果为;",
      "我们发现",
      "1.调用成员方法时，使用的是子类型中重写后的成员方法。",
      "2.父类和子类中出现同名的成员变量时，多态调用该变量时，会使用父类中成员变量"
    ],
    "sentences": [
      "关于多态的一些内容",
      "重载的多态",
      "与overload相关",
      "主要是多个不同实现的方法具有相同的名字",
      "但每个方法之间的参数必须有所区分",
      "重载多态对于客户端而言是方便的",
      "不需要记住大量方法的名字",
      "根据输入的参数不同",
      "会在静态类型检查时自动匹配相应的方法",
      "例如：三者虽然方法名相同，但参数类型不同，因此符合重载多态",
      "注意：这两个方法虽然返回值类型不一致",
      "但参数类型是相同的",
      "不构成重载",
      "参数的多态",
      "参数多态即我们通常所说的泛型",
      "当具体使用的数据类型还不确定时可以使用",
      "能够提高代码的适用范围",
      "例如：L便是我们所用的一个替代具体数据类型的一个标识符",
      "当我们需要赋予其具体类型时，例如String",
      "只需将先前的L换成我们所要使用是数据类型即可",
      "子类型多态",
      "子类型多态的前提条件有以下几点：要存在继承关系",
      "重写子类（override)",
      "父类要引用子类对象",
      "Bestfriend继承了父类friend",
      "而且重写了方法makefriend,二者都定义了一个成员变量a.测试：输出结果为;我们发现",
      "1.调用成员方法时，使用的是子类型中重写后的成员方法",
      "2.父类和子类中出现同名的成员变量时",
      "多态调用该变量时",
      "会使用父类中成员变量"
    ],
    "codes": [
      "    private void People(String name)\n    {\n    \t\n    }\n    private void People(String name,String tel)\n    {\n    \t\n    }\n    private void People(String name,String tel ,int age)\n    {\n    \t\n    }\n",
      "   private void People(String name,String tel ,int age)\n    {\n    \t\n    }\n    Private boolean People(String name,String tel ,int age)\n    {\n    \t\n    }\n",
      "public static<L>IntevalSet<L> empty()\n{\n}\n",
      " IntevalSet<String> a = IntevalSet.empty();\n",
      "public class friend {\n    int a=10;\n    public void makefriend()\n    {\n    \tSystem.out.println(\"make friend\");\n    }\n}\npublic class Bestfriend extends friend{\n    int a=9; \n       public void makefriend()\n       {\n    \t   System.out.println(\"make bestfriend\");\n       }\n}\n",
      "public static void main(String[] args) {\n    \tfriend f=new Bestfriend();//多态使用\n    \tf.makefriend();\n    \tSystem.out.println(f.a);\n    \t} \n",
      "make bestfriend\n10\n"
    ],
    "date": "2021-07-07",
    "text": "关于多态的一些内容\n重载的多态\n与overload相关，主要是多个不同实现的方法具有相同的名字，但每个方法之间的参数必须有所区分。重载多态对于客户端而言是方便的，不需要记住大量方法的名字，根据输入的参数不同，会在静态类型检查时自动匹配相应的方法。\n例如：\n三者虽然方法名相同，但参数类型不同，因此符合重载多态\n注意：\n这两个方法虽然返回值类型不一致，但参数类型是相同的，不构成重载\n参数的多态\n参数多态即我们通常所说的泛型，当具体使用的数据类型还不确定时可以使用，能够提高代码的适用范围。\n例如：\nL便是我们所用的一个替代具体数据类型的一个标识符\n当我们需要赋予其具体类型时，例如String\n只需将先前的L换成我们所要使用是数据类型即可\n子类型多态\n子类型多态的前提条件有以下几点：\n要存在继承关系。\n重写子类（override)\n父类要引用子类对象。\nBestfriend继承了父类friend，而且重写了方法makefriend,二者都定义了一个成员变量a.\n测试：\n输出结果为;\n我们发现\n1.调用成员方法时，使用的是子类型中重写后的成员方法。\n2.父类和子类中出现同名的成员变量时，多态调用该变量时，会使用父类中成员变量\n"
  },
  {
    "head": "2021-07-06",
    "paragraphs": [
      "#关于final关键字的一些内容",
      "修饰变量：",
      "final关系字修饰后的变量，其内存地址是不会发生变化的。",
      "例如：修饰基本数据类型",
      "由于string是immutable类型的变量，当改变a的值时，会将其指向一个新的内存空间，与final变量修饰相矛盾，报错。",
      "修饰引用数据类型，即对象",
      "此时的输出结果为：",
      "可以看到 b 的保留的某些值是可以正常更改的。但想进行下列操作时",
      "系统会报错，因为对象b和对象c 使用了final关键字来进行修饰，其指向的内存地址是不可以修改的。但对象内部值与对象的内存空间是不一样的，所以对象内部的值可以修改。",
      "修饰方法时",
      "final关键字修饰的方法是不能够重写的，并且某一个类中所有private方法都默认添加了final关键字",
      "修饰类时",
      "final关键字修饰的类是无法被继承的"
    ],
    "sentences": [
      "#关于final关键字的一些内容",
      "修饰变量：final关系字修饰后的变量",
      "其内存地址是不会发生变化的",
      "例如：修饰基本数据类型",
      "由于string是immutable类型的变量",
      "当改变a的值时",
      "会将其指向一个新的内存空间",
      "与final变量修饰相矛盾",
      "报错",
      "修饰引用数据类型，即对象",
      "此时的输出结果为：可以看到 b 的保留的某些值是可以正常更改的",
      "但想进行下列操作时",
      "系统会报错",
      "因为对象b和对象c 使用了final关键字来进行修饰",
      "其指向的内存地址是不可以修改的",
      "但对象内部值与对象的内存空间是不一样的",
      "所以对象内部的值可以修改",
      "修饰方法时",
      "final关键字修饰的方法是不能够重写的",
      "并且某一个类中所有private方法都默认添加了final关键字",
      "修饰类时",
      "final关键字修饰的类是无法被继承的"
    ],
    "codes": [
      "public final String a=\"kk\";\na=new String(\"tt\");//静态类型检查会报错\n",
      "    final Person b=new Person(\"b\",\"00000\");\n    final Person c=new Person(\"a\",\"11111\");\n    System.out.println(b.getname());\n    b.setname(\"c\");\n    System.out.println(b.getname());\n",
      "c=b;\n"
    ],
    "date": "2021-07-06",
    "text": "#关于final关键字的一些内容\n修饰变量：\nfinal关系字修饰后的变量，其内存地址是不会发生变化的。\n例如：修饰基本数据类型\n由于string是immutable类型的变量，当改变a的值时，会将其指向一个新的内存空间，与final变量修饰相矛盾，报错。\n修饰引用数据类型，即对象\n此时的输出结果为：\n可以看到 b 的保留的某些值是可以正常更改的。但想进行下列操作时\n系统会报错，因为对象b和对象c 使用了final关键字来进行修饰，其指向的内存地址是不可以修改的。但对象内部值与对象的内存空间是不一样的，所以对象内部的值可以修改。\n修饰方法时\nfinal关键字修饰的方法是不能够重写的，并且某一个类中所有private方法都默认添加了final关键字\n修饰类时\nfinal关键字修饰的类是无法被继承的\n"
  },
  {
    "head": "单词计数（python）",
    "paragraphs": [
      "使用python实现英文小说中简单的单词计数（去除标点、空格，忽略大小写），统计出现最频繁的50个单词。",
      "测试小说样例下载"
    ],
    "sentences": [
      "使用python实现英文小说中简单的单词计数（去除标点、空格",
      "忽略大小写）",
      "统计出现最频繁的50个单词",
      "测试小说样例下载"
    ],
    "codes": [
      "import re\n\nf=open('emma.txt')\n\nd={}\n\nfor line in f:\n    words=line.strip().lower().split()\n    words_new=[]\n    for word in words:\n        word_new=re.sub(r'[\\s+\\.\\!\\/_,$%^*(+\\\"\\']+|[+——！，。？、~@#￥%……&*（）]+', '', word) #过滤中英文标点\n        words_new.append(word_new)\n    for word in words_new:\n        if word in d:\n            d[word]+=1\n        else:\n            d[word]=1\n\nword_freq=sorted(d.items(),key=lambda x: x[1],reverse=True) #按出现次数从大到小排序\n\nprint(word_freq[:50]) #打印出现次数最多的前50个单词\n\nf.close()\n"
    ],
    "date": "2020-07-17",
    "text": "使用python实现英文小说中简单的单词计数（去除标点、空格，忽略大小写），统计出现最频繁的50个单词。\n测试小说样例下载\n"
  },
  {
    "head": "如何将Java中的Date类变成immutable类型",
    "paragraphs": [
      "想法一",
      "直接使用final对Date的对象进行修饰。",
      "但是Date是对象数据类型（Object types），当我们对这样的数据类型用final修饰时，它引用的对象是不能改变的，但是它指向的对象的值是可以改变的。",
      "上面代码是合法的，我们尽管使用了final来修饰Date类型的date对象，我们依然可以调用setYear方法来修改date里有关年份的属性。",
      "想法二",
      "写一个自己的MyDate类，在这个类中，实现Date类的基本功能，但是一切可能改变对象值的方法都不应该再出现（例如上面提到的setYear方法）。其实本质上就是在新的类里创建了一个Date类型的private对象，然后将需要实现的方法委托（Delegation）给Date类。"
    ],
    "sentences": [
      "想法一",
      "直接使用final对Date的对象进行修饰",
      "但是Date是对象数据类型（Object types）",
      "当我们对这样的数据类型用final修饰时",
      "它引用的对象是不能改变的",
      "但是它指向的对象的值是可以改变的",
      "上面代码是合法的",
      "我们尽管使用了final来修饰Date类型的date对象",
      "我们依然可以调用setYear方法来修改date里有关年份的属性",
      "想法二",
      "写一个自己的MyDate类",
      "在这个类中",
      "实现Date类的基本功能",
      "但是一切可能改变对象值的方法都不应该再出现（例如上面提到的setYear方法）",
      "其实本质上就是在新的类里创建了一个Date类型的private对象",
      "然后将需要实现的方法委托（Delegation）给Date类"
    ],
    "codes": [
      "final Date date = new Date();\ndate.setYear(2021); // allowed!\n",
      "import java.util.Date;\n \npublic class MyDate {\n\n    private Date date;\n \n    public MyDate() {\n        date = new Date();\n    }\n \n    public MyDate(long time) {\n        date = new Date(time);\n    }\n \n    public boolean after(MyDate when) {\n        return date.after(when.date);\n    }\n \n    public boolean before(Mydate when) {\n        return date.before(when.date);\n    }\n    // ...\n}\n"
    ],
    "date": "2021-07-03",
    "text": "想法一\n直接使用final对Date的对象进行修饰。\n但是Date是对象数据类型（Object types），当我们对这样的数据类型用final修饰时，它引用的对象是不能改变的，但是它指向的对象的值是可以改变的。\n上面代码是合法的，我们尽管使用了final来修饰Date类型的date对象，我们依然可以调用setYear方法来修改date里有关年份的属性。\n想法二\n写一个自己的MyDate类，在这个类中，实现Date类的基本功能，但是一切可能改变对象值的方法都不应该再出现（例如上面提到的setYear方法）。其实本质上就是在新的类里创建了一个Date类型的private对象，然后将需要实现的方法委托（Delegation）给Date类。\n"
  },
  {
    "head": "Python实现——实现逆向最大匹配分词算法，即从右向左扫描，找到最长的词并切分。",
    "paragraphs": [
      "题目内容：",
      "实现逆向最大匹配分词算法，即从右向左扫描，找到最长的词并切分。如句子“研究生命的起源”，逆向最大匹配分词算法的输出结果为“研究 生命 的 起源”。",
      "输入格式:",
      "第一行是以utf-8格式输入的词表，每个词之间以空格分隔。",
      "接下来是若干行以utf-8格式输入的中文句子。",
      "输出格式：",
      "以utf-8格式输出的逆向最大匹配的分词结果，每个词之间使用空格分隔。每个输入对应一行输出。",
      "输入样例：",
      "你 我 他 爱 北京 天安门 研究 研究生 命 生命 的 起源",
      "研究生命的起源",
      "我爱北京天安门",
      "输出样例：",
      "研究 生命 的 起源",
      "我 爱 北京 天安门",
      "注：以下是Python3.8的代码实现，如果要用Py2实现需要作相应修改。",
      "亦可参考博客：",
      "中文分词"
    ],
    "sentences": [
      "题目内容：实现逆向最大匹配分词算法",
      "即从右向左扫描",
      "找到最长的词并切分",
      "如句子“研究生命的起源”",
      "逆向最大匹配分词算法的输出结果为“研究 生命 的 起源”",
      "输入格式:第一行是以utf-8格式输入的词表",
      "每个词之间以空格分隔",
      "接下来是若干行以utf-8格式输入的中文句子",
      "输出格式：以utf-8格式输出的逆向最大匹配的分词结果",
      "每个词之间使用空格分隔",
      "每个输入对应一行输出",
      "输入样例：你 我 他 爱 北京 天安门 研究 研究生 命 生命 的 起源",
      "研究生命的起源",
      "我爱北京天安门",
      "输出样例：研究 生命 的 起源",
      "我 爱 北京 天安门",
      "注：以下是Python3.8的代码实现",
      "如果要用Py2实现需要作相应修改",
      "亦可参考博客：中文分词"
    ],
    "codes": [
      "#字典生成\ndef load_dic(s):\n    words=s.split()\n    word_dic=set()\n    max_length=1\n    for word in words:\n        word_dic.add(word)\n        if len(word)>max_length:\n            max_length=len(word)\n    return max_length, word_dic\n\n#逆向最大匹配分词\ndef fmm_word_seg(sentence, word_dic, max_length):\n    end=len(sentence)\n    words=[]\n    while end>0:\n        for begin in range(max(end-max_length, 0),end):\n            word=sentence[begin:end]\n            if word in word_dic or end==begin+1:\n                words.append(word)\n                break\n        end=begin\n    return words\n\nmax_len, word_dic=load_dic(input())\nfor line in sys.stdin:\n    words=fmm_word_seg(line, word_dic, max_len)\n    for i in range(len(words)-1,0,-1):\n        print (words[i],end=' ')\n    print (words[0])\n"
    ],
    "date": "2020-07-23",
    "text": "题目内容：\n实现逆向最大匹配分词算法，即从右向左扫描，找到最长的词并切分。如句子“研究生命的起源”，逆向最大匹配分词算法的输出结果为“研究 生命 的 起源”。\n输入格式:\n第一行是以utf-8格式输入的词表，每个词之间以空格分隔。\n接下来是若干行以utf-8格式输入的中文句子。\n输出格式：\n以utf-8格式输出的逆向最大匹配的分词结果，每个词之间使用空格分隔。每个输入对应一行输出。\n输入样例：\n你 我 他 爱 北京 天安门 研究 研究生 命 生命 的 起源\n研究生命的起源\n我爱北京天安门\n输出样例：\n研究 生命 的 起源\n我 爱 北京 天安门\n注：以下是Python3.8的代码实现，如果要用Py2实现需要作相应修改。\n亦可参考博客：\n中文分词\n"
  },
  {
    "head": "欧拉图的判定",
    "paragraphs": [
      "通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。而具有欧拉回路的无向图称为欧拉图。本文将通过C语言实现欧拉图的判定。用C语言程序完成欧拉图的判定，主要分为两步，分别是：判断每个顶点的度是否为偶数、判断图是否连通。具体代码如下：",
      "代码下载"
    ],
    "sentences": [
      "通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路",
      "而具有欧拉回路的无向图称为欧拉图",
      "本文将通过C语言实现欧拉图的判定",
      "用C语言程序完成欧拉图的判定",
      "主要分为两步",
      "分别是：判断每个顶点的度是否为偶数、判断图是否连通",
      "具体代码如下：代码下载"
    ],
    "codes": [
      "#include <stdio.h>\n#include <stdlib.h>\n\n#define maxn 500\nint a[maxn][maxn]={0},n;\n\nvoid input(void);               //输入邻接矩阵\nint Is_Even(void);              //判断是否每个点度数都为偶数\nint Warshall(void);             //判断是否连通\n\nint main()\n{\n    input();\n    if(Is_Even()&&Warshall()) printf(\"Yes\\n\"); else printf(\"No\\n\");\n    return 0;\n}\n\nvoid input(void)\n{\n    int i,j;\n    printf(\"请输入顶点个数：\");\n    scanf(\"%d\",&n);\n    printf(\"请输入图的邻接矩阵：\\n\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n}\nint Is_Even(void)\n{\n    int count,i,j;\n    for(i=0;i<n;i++)\n    {\n        count=0;\n        for(j=0;j<n;j++)\n        {\n            count+=a[i][j];\n        }\n        if (count%2) return 0;\n    }\n    return 1;\n}\n\nint Warshall(void)\n{\n    int i,j,k;\n    for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n        {\n            if(a[j][i]==1)\n            {\n                for(k=0;k<n;k++)\n                    a[j][k]=a[j][k]+a[i][k]-a[j][k]*a[i][k];\n            }\n        }\n    for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n            if(a[i][j]==0) return 0;\n    return 1;\n}\n\n"
    ],
    "date": "2020-07-12",
    "text": "通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。而具有欧拉回路的无向图称为欧拉图。本文将通过C语言实现欧拉图的判定。用C语言程序完成欧拉图的判定，主要分为两步，分别是：判断每个顶点的度是否为偶数、判断图是否连通。具体代码如下：\n代码下载\n"
  },
  {
    "head": "杨辉三角形（python）",
    "paragraphs": [
      "题目内容：",
      "帕斯卡三角形，又称杨辉三角形是二项式系数在三角形中的一种几何排列。帕斯卡三角形通常从第0行开始枚举，并且每一行的数字是上一行相邻两个数字的和。在第0行只写一个数字1，然后构造下一行的元素。将上一行中数字左侧上方和右侧上方的数值相加。如果左侧上方或者右侧上方的数字不存在，用0替代。下面给出6行的帕斯卡三角形：",
      "1 1",
      "1 2 1",
      "1 3 3 1",
      "1 4 6 4 1",
      "1 5 10 10 5 1",
      "编写程序，输入帕斯卡三角形的高度 n，然后生成和上面例子一样风格的三角形。",
      "输入格式:",
      "一个正整数 n",
      "输出格式：",
      "相应高度的帕斯卡三角形，两个数字之间有一个空格",
      "输入样例：",
      "输出样例：",
      "1 1",
      "1 2 1",
      "1 3 3 1",
      "1 4 6 4 1",
      "1 5 10 10 5 1"
    ],
    "sentences": [
      "题目内容：帕斯卡三角形",
      "又称杨辉三角形是二项式系数在三角形中的一种几何排列",
      "帕斯卡三角形通常从第0行开始枚举",
      "并且每一行的数字是上一行相邻两个数字的和",
      "在第0行只写一个数字1，然后构造下一行的元素",
      "将上一行中数字左侧上方和右侧上方的数值相加",
      "如果左侧上方或者右侧上方的数字不存在，用0替代",
      "下面给出6行的帕斯卡三角形：1 1",
      "1 2 1",
      "1 3 3 1",
      "1 4 6 4 1",
      "1 5 10 10 5 1",
      "编写程序",
      "输入帕斯卡三角形的高度 n",
      "然后生成和上面例子一样风格的三角形",
      "输入格式:一个正整数 n",
      "输出格式：相应高度的帕斯卡三角形，两个数字之间有一个空格",
      "输入样例：输出样例：1 1",
      "1 2 1",
      "1 3 3 1",
      "1 4 6 4 1",
      "1 5 10 10 5 1"
    ],
    "codes": [
      "import math\n\ndef C(m,n):\n    if m==0 or m==n:\n        return 1\n    else:\n        return math.factorial(n)//(math.factorial(m)*math.factorial(n-m))\n\nn=int(input())\nfor i in range(n):\n    print(' '*(n-1-i),end='')\n    for j in range(i+1):\n        print(C(j,i),end=' ')\n    print('\\n')\n"
    ],
    "date": "2020-07-17",
    "text": "题目内容：\n帕斯卡三角形，又称杨辉三角形是二项式系数在三角形中的一种几何排列。帕斯卡三角形通常从第0行开始枚举，并且每一行的数字是上一行相邻两个数字的和。在第0行只写一个数字1，然后构造下一行的元素。将上一行中数字左侧上方和右侧上方的数值相加。如果左侧上方或者右侧上方的数字不存在，用0替代。下面给出6行的帕斯卡三角形：\n1 1\n1 2 1\n1 3 3 1\n1 4 6 4 1\n1 5 10 10 5 1\n编写程序，输入帕斯卡三角形的高度 n，然后生成和上面例子一样风格的三角形。\n输入格式:\n一个正整数 n\n输出格式：\n相应高度的帕斯卡三角形，两个数字之间有一个空格\n输入样例：\n输出样例：\n1 1\n1 2 1\n1 3 3 1\n1 4 6 4 1\n1 5 10 10 5 1\n"
  },
  {
    "head": "QQ小程序更新数据库记录",
    "paragraphs": [
      "QQ小程序的云开发文档中有关于数据库更新数据的相关教程（",
      "），但是它存在着一个致命的缺陷——不能根据某个或某几个索引进行查找后更新相关记录的数据。但是这个功能其实是很常用的，下面是一种替代方法。",
      "思路：先通过某个索引查找相应记录，再将原记录删除；更新相应属性后，插入新的记录。",
      "首先是数据库的初始化：",
      "删除学号为123456的记录",
      "将相应属性进行更新后，插入新记录",
      "这样便可以替代实现根据索引进行查找后更新相应记录的功能。"
    ],
    "sentences": [
      "QQ小程序的云开发文档中有关于数据库更新数据的相关教程（",
      "）",
      "但是它存在着一个致命的缺陷——不能根据某个或某几个索引进行查找后更新相关记录的数据",
      "但是这个功能其实是很常用的，下面是一种替代方法",
      "思路：先通过某个索引查找相应记录",
      "再将原记录删除；更新相应属性后",
      "插入新的记录",
      "首先是数据库的初始化：删除学号为123456的记录",
      "将相应属性进行更新后，插入新记录",
      "这样便可以替代实现根据索引进行查找后更新相应记录的功能"
    ],
    "codes": [
      "const db = qq.cloud.database({\n            env: '自己创建的云环境ID'\n        });\nconst student = db.collection('student') //取名为\"student\"的集合索引\n",
      "student.where({\n    number:'123456'\n}).remove().then((res) => {\n    console.log('删除一条记录',res.data);\n});\n",
      "student.add({\n     data:{//这里一定要把所有属性都写出来\n         number:'123456',\n         name:'张三', //例：更改姓名属性\n     }\n}).then((res) => {\n     console.log('增加一条记录：',res.data);\n});\n"
    ],
    "date": "2021-02-02",
    "text": "QQ小程序的云开发文档中有关于数据库更新数据的相关教程（\n），但是它存在着一个致命的缺陷——不能根据某个或某几个索引进行查找后更新相关记录的数据。但是这个功能其实是很常用的，下面是一种替代方法。\n思路：先通过某个索引查找相应记录，再将原记录删除；更新相应属性后，插入新的记录。\n首先是数据库的初始化：\n删除学号为123456的记录\n将相应属性进行更新后，插入新记录\n这样便可以替代实现根据索引进行查找后更新相应记录的功能。\n"
  },
  {
    "head": "中文分词（python）",
    "paragraphs": [
      "今天研究了一下中文分词，下面用两种简单的算法（正向最大匹配分词算法和逆向最大匹配分词算法）实现。",
      "两种算法略有不同，但总体思路类似。对于不同的中文句子，两种算法可能有的适用，有的不适用。例如",
      "研究生命的起源",
      "这句话，使用正向最大匹配分词算法时，会被分成",
      "研究生 命 的 起源",
      "，但使用逆向最大匹配分词算法就可以得到正确结果。当然逆向最大匹配分词算法也不是对所有句子都适用。",
      "总的来看，两种算法都能一定程度上实现中文句子的分词，但都不完善，现阶段也没有百分百准确的分词算法，这一领域还有较大的研究空间。"
    ],
    "sentences": [
      "今天研究了一下中文分词",
      "下面用两种简单的算法（正向最大匹配分词算法和逆向最大匹配分词算法）实现",
      "两种算法略有不同，但总体思路类似",
      "对于不同的中文句子，两种算法可能有的适用，有的不适用",
      "例如",
      "研究生命的起源",
      "这句话，使用正向最大匹配分词算法时，会被分成",
      "研究生 命 的 起源",
      "，但使用逆向最大匹配分词算法就可以得到正确结果",
      "当然逆向最大匹配分词算法也不是对所有句子都适用",
      "总的来看",
      "两种算法都能一定程度上实现中文句子的分词",
      "但都不完善",
      "现阶段也没有百分百准确的分词算法",
      "这一领域还有较大的研究空间"
    ],
    "codes": [
      "#字典生成\ndef load_dic(filename):\n    f=open(filename,'r',encoding='utf-8')\n    word_dic=set()\n    max_length=1\n    for line in f:\n        word=line.strip()\n        word_dic.add(word)\n        if len(word)>max_length:\n            max_length=len(word)\n    return max_length, word_dic\n\n#正向最大匹配分词\ndef fmm_word_seg(sentence, word_dic, max_length):\n    begin=0\n    words=[]\n    while begin<len(sentence):\n        for end in range(min(begin+max_length, len(sentence)), begin, -1):\n            word=sentence[begin:end]\n            if word in word_dic or end==begin+1:\n                words.append(word)\n                break\n        begin=end\n    return words\n\nmax_len, word_dic=load_dic('lexicon.txt') #中文词汇库\nwords=fmm_word_seg(input(), word_dic, max_len)\nfor word in words:\n    print(word)\n",
      "#字典生成\ndef load_dic(s):\n    words=s.split()\n    word_dic=set()\n    max_length=1\n    for word in words:\n        word_dic.add(word)\n        if len(word)>max_length:\n            max_length=len(word)\n    return max_length, word_dic\n\n#逆向最大匹配分词\ndef fmm_word_seg(sentence, word_dic, max_length):\n    end=len(sentence)\n    words=[]\n    while end>0:\n        for begin in range(max(end-max_length, 0),end):\n            word=sentence[begin:end]\n            if word in word_dic or end==begin+1:\n                words.append(word)\n                break\n        end=begin\n    return words\n\nmax_len, word_dic=load_dic(input())\nwords=fmm_word_seg(input(), word_dic, max_len)\nfor i in range(len(words)-1,-1,-1):\n    print(words[i])  #逆序打印\n"
    ],
    "date": "2020-07-20",
    "text": "今天研究了一下中文分词，下面用两种简单的算法（正向最大匹配分词算法和逆向最大匹配分词算法）实现。\n两种算法略有不同，但总体思路类似。对于不同的中文句子，两种算法可能有的适用，有的不适用。例如\n研究生命的起源\n这句话，使用正向最大匹配分词算法时，会被分成\n研究生 命 的 起源\n，但使用逆向最大匹配分词算法就可以得到正确结果。当然逆向最大匹配分词算法也不是对所有句子都适用。\n总的来看，两种算法都能一定程度上实现中文句子的分词，但都不完善，现阶段也没有百分百准确的分词算法，这一领域还有较大的研究空间。\n"
  },
  {
    "head": "Java防御式拷贝方法小结",
    "paragraphs": [
      "为什么要用防御式拷贝",
      "在ADT中，常常会有一些Observer方法，用户可以通过这样的方法查看ADT的一些相关属性。用户在获得相关属性后，可能会对这些属性做一些修改，如果我们直接把ADT中的rep返回给用户，那么用户的修改就有可能对ADT产生巨大影响，从而导致程序出现一些意想不到的错误。而使用防御性拷贝就是为了避免类似情况的出现。",
      "其实，如果从更广义的角度看，不仅仅是出现返回值时有可能出现表示泄露，其实在构造函数里如果对用户输入的对象不进行有效的拷贝，用户之后的修改其实也可能对你设计的ADT产生影响，这时其实也需要进行防御性拷贝。",
      "以下面这个例子为例。",
      "在这个ADT中实际上是存在着一些表示泄露的风险的。",
      "在构造函数里，直接使用了",
      "lines = l;",
      "这样的语句，本意试想把输入的",
      "List<String> l",
      "拷贝给rep里的",
      "lines",
      "属性。但是由于List是对象数据类型，所以实际上此时",
      "line",
      "指向的是同一个对象，一旦客户端改变",
      "中的值，",
      "line",
      "也会跟着改变，这样是很危险的。",
      "在构造函数里，还出现了",
      "date = d;",
      "语句。Date是对象数据类型，一旦客户端改变",
      "中的值，",
      "date",
      "中的值也会跟着改变，这样是很危险的。",
      "getAllLines()",
      "方法中，直接把rep中的",
      "lines",
      "放回给了用户，这样用户可以随意修改返回的List，有可能会改变ADT中的rep，这也违反了表示独立性。",
      "解决：防御式拷贝",
      "关于防御式拷贝，主要的思路就是创建一个跟原来的对象一模一样的对象，并且这个新的对象不会受到原来对象的影响，也就是说它们是完全独立的。这里主要以List和Date这两个典型的mutable类型进行举例。",
      "List",
      "对于List，我们实际想要复制的是整个List里的所有对象，而不是指向这个List的指针。",
      "我们可以遍历原始List，再将List里的所有元素拷贝到新的List中，代码如下。",
      "最后的运行结果为",
      "list : [b, c]",
      "copylist : [a, b, c]",
      "可以看出这里成功实现了元素的拷贝，对原来List的改变不会影响新的List。",
      "但是这样的拷贝略显麻烦，下面的方法要简单一些。",
      "通过List对象的",
      "addAll()",
      "方法，实现List中元素的拷贝（俗称“深拷贝”）。",
      "Java中的一些其他的集合类（比如Set，Map等）也可以通过类似的方法实现防御式拷贝，进而避免外来的改变对ADT造成影响。",
      "而在Observer方法中，实际上也需要进行防御式拷贝，这里可以使用上面的方法将rep的拷贝返回给用户，也可以使用",
      "Collections.unmodifiableLis()",
      "对List对象进行修饰，修饰过的对象是不可变的。",
      "Date",
      "Date与List相比就要简单一些了，我们只需要创建一个新的Date对象，保证这个对象的值和原来的对象一样即可。",
      "下面是具体的代码实现。",
      "最后的运行结果为",
      "date : Sat Jan 24 11:33:20 CST 1970",
      "copydate : Tue Jul 06 16:57:15 CST 2021",
      "我们成功创建了两个完全独立的Date对象，这正是我们想要的。",
      "对于一些其他的对象，或是通过构造函数，或是通过一些",
      "set",
      "方法，我们都可以创建一个与原先对象一模一样的对象。",
      "以List和Date为例，本文主要介绍了Java中进行防御式拷贝的一些方法，并且说明了防御式拷贝的必要性。",
      "但是如果返回值本身的就是immutable类型的对象，实际上就不需要防御式拷贝了，因为这样的对象是不允许被改变的。所以，在日后的编程中，如果可以使用immutable类型的对象，就尽量使用，这样可以避免许多与表示泄露有关的麻烦。"
    ],
    "sentences": [
      "为什么要用防御式拷贝",
      "在ADT中",
      "常常会有一些Observer方法",
      "用户可以通过这样的方法查看ADT的一些相关属性",
      "用户在获得相关属性后",
      "可能会对这些属性做一些修改",
      "如果我们直接把ADT中的rep返回给用户",
      "那么用户的修改就有可能对ADT产生巨大影响",
      "从而导致程序出现一些意想不到的错误",
      "而使用防御性拷贝就是为了避免类似情况的出现",
      "其实",
      "如果从更广义的角度看",
      "不仅仅是出现返回值时有可能出现表示泄露",
      "其实在构造函数里如果对用户输入的对象不进行有效的拷贝",
      "用户之后的修改其实也可能对你设计的ADT产生影响",
      "这时其实也需要进行防御性拷贝",
      "以下面这个例子为例",
      "在这个ADT中实际上是存在着一些表示泄露的风险的",
      "在构造函数里，直接使用了",
      "lines = l;这样的语句，本意试想把输入的",
      "List<String> l",
      "拷贝给rep里的",
      "lines",
      "属性",
      "但是由于List是对象数据类型，所以实际上此时",
      "line",
      "指向的是同一个对象，一旦客户端改变",
      "中的值，line",
      "也会跟着改变，这样是很危险的",
      "在构造函数里，还出现了",
      "date = d;语句",
      "Date是对象数据类型，一旦客户端改变",
      "中的值，date",
      "中的值也会跟着改变，这样是很危险的",
      "getAllLines()",
      "方法中，直接把rep中的",
      "lines",
      "放回给了用户",
      "这样用户可以随意修改返回的List",
      "有可能会改变ADT中的rep",
      "这也违反了表示独立性",
      "解决：防御式拷贝",
      "关于防御式拷贝",
      "主要的思路就是创建一个跟原来的对象一模一样的对象",
      "并且这个新的对象不会受到原来对象的影响",
      "也就是说它们是完全独立的",
      "这里主要以List和Date这两个典型的mutable类型进行举例",
      "List",
      "对于List",
      "我们实际想要复制的是整个List里的所有对象",
      "而不是指向这个List的指针",
      "我们可以遍历原始List",
      "再将List里的所有元素拷贝到新的List中",
      "代码如下",
      "最后的运行结果为",
      "list : [b, c]",
      "copylist : [a, b, c]",
      "可以看出这里成功实现了元素的拷贝",
      "对原来List的改变不会影响新的List",
      "但是这样的拷贝略显麻烦，下面的方法要简单一些",
      "通过List对象的",
      "addAll()",
      "方法，实现List中元素的拷贝（俗称“深拷贝”）",
      "Java中的一些其他的集合类（比如Set",
      "Map等）也可以通过类似的方法实现防御式拷贝",
      "进而避免外来的改变对ADT造成影响",
      "而在Observer方法中",
      "实际上也需要进行防御式拷贝",
      "这里可以使用上面的方法将rep的拷贝返回给用户",
      "也可以使用",
      "Collections.unmodifiableLis()",
      "对List对象进行修饰，修饰过的对象是不可变的",
      "Date",
      "Date与List相比就要简单一些了",
      "我们只需要创建一个新的Date对象",
      "保证这个对象的值和原来的对象一样即可",
      "下面是具体的代码实现",
      "最后的运行结果为",
      "date : Sat Jan 24 11:33:20 CST 1970",
      "copydate : Tue Jul 06 16:57:15 CST 2021",
      "我们成功创建了两个完全独立的Date对象，这正是我们想要的",
      "对于一些其他的对象，或是通过构造函数，或是通过一些",
      "set",
      "方法，我们都可以创建一个与原先对象一模一样的对象",
      "以List和Date为例",
      "本文主要介绍了Java中进行防御式拷贝的一些方法",
      "并且说明了防御式拷贝的必要性",
      "但是如果返回值本身的就是immutable类型的对象",
      "实际上就不需要防御式拷贝了",
      "因为这样的对象是不允许被改变的",
      "所以",
      "在日后的编程中",
      "如果可以使用immutable类型的对象",
      "就尽量使用",
      "这样可以避免许多与表示泄露有关的麻烦"
    ],
    "codes": [
      "class Poem {\n\tpublic String title;\n\tpublic String author;\n\tprivate List<String> lines = new ArrayList<>();\n\tprivate Date date;\n\t// AF: 代表一首诗，包含四个属性：\n\t// title为诗的题目，\n\t// author为诗的作者，\n\t// lines为诗的文本行，\n\t// date为诗的发表日期\n\tpublic Poem(String t, String a, List<String> l, Date d) {\n\t\ttitle = t;\n\t\tauthor = a;\n\t\tlines = l;\n\t\tdate = d;\n\t}\n\tpublic void addOneLine(String newLine) {\n\t\tlines.add(newLine);\n\t}\n\t\n\t//..\t\n\n\tpublic List<String> getAllLines() {\n\t\treturn lines;\n\t}\n}\n",
      "class Test {\n\t\n\tpublic static void main(String[] args) {\n\t\tList<String> list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));\n\t\tList<String> copyList = new ArrayList<>();\n\t\tfor(int i=0; i<list.size(); i++) {\n\t\t\tcopyList.add(list.get(i));\n\t\t}\n\t\tlist.remove(0);\n\t\tSystem.out.println(\"list:\"+list.toString());\n\t\tSystem.out.println(\"copylist:\"+copyList.toString());\n\t}\n}\n",
      "class Test {\n\t\n\tpublic static void main(String[] args) {\n\t\tList<String> list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));\n\t\tList<String> copyList = new ArrayList<>();\n\t\tcopyList.addAll(list);\n\t\tlist.remove(0);\n\t\tSystem.out.println(\"list:\"+list.toString());\n\t\tSystem.out.println(\"copylist:\"+copyList.toString());\n\t}\n}\n",
      "class Test {\n\t\n\tpublic static void main(String[] args) {\n\t\tDate date = new Date();\n\t\tDate copyDate = new Date(date.getTime());\n\t\tdate.setTime(2000000000);\n\t\tSystem.out.println(\"date:\"+date.toString());\n\t\tSystem.out.println(\"copydate:\"+copyDate.toString());\n\t}\n}\n"
    ],
    "date": "2021-07-06",
    "text": "为什么要用防御式拷贝\n在ADT中，常常会有一些Observer方法，用户可以通过这样的方法查看ADT的一些相关属性。用户在获得相关属性后，可能会对这些属性做一些修改，如果我们直接把ADT中的rep返回给用户，那么用户的修改就有可能对ADT产生巨大影响，从而导致程序出现一些意想不到的错误。而使用防御性拷贝就是为了避免类似情况的出现。\n其实，如果从更广义的角度看，不仅仅是出现返回值时有可能出现表示泄露，其实在构造函数里如果对用户输入的对象不进行有效的拷贝，用户之后的修改其实也可能对你设计的ADT产生影响，这时其实也需要进行防御性拷贝。\n以下面这个例子为例。\n在这个ADT中实际上是存在着一些表示泄露的风险的。\n在构造函数里，直接使用了\nlines = l;\n这样的语句，本意试想把输入的\nList<String> l\n拷贝给rep里的\nlines\n属性。但是由于List是对象数据类型，所以实际上此时\nline\n指向的是同一个对象，一旦客户端改变\n中的值，\nline\n也会跟着改变，这样是很危险的。\n在构造函数里，还出现了\ndate = d;\n语句。Date是对象数据类型，一旦客户端改变\n中的值，\ndate\n中的值也会跟着改变，这样是很危险的。\ngetAllLines()\n方法中，直接把rep中的\nlines\n放回给了用户，这样用户可以随意修改返回的List，有可能会改变ADT中的rep，这也违反了表示独立性。\n解决：防御式拷贝\n关于防御式拷贝，主要的思路就是创建一个跟原来的对象一模一样的对象，并且这个新的对象不会受到原来对象的影响，也就是说它们是完全独立的。这里主要以List和Date这两个典型的mutable类型进行举例。\nList\n对于List，我们实际想要复制的是整个List里的所有对象，而不是指向这个List的指针。\n我们可以遍历原始List，再将List里的所有元素拷贝到新的List中，代码如下。\n最后的运行结果为\nlist : [b, c]\ncopylist : [a, b, c]\n可以看出这里成功实现了元素的拷贝，对原来List的改变不会影响新的List。\n但是这样的拷贝略显麻烦，下面的方法要简单一些。\n通过List对象的\naddAll()\n方法，实现List中元素的拷贝（俗称“深拷贝”）。\nJava中的一些其他的集合类（比如Set，Map等）也可以通过类似的方法实现防御式拷贝，进而避免外来的改变对ADT造成影响。\n而在Observer方法中，实际上也需要进行防御式拷贝，这里可以使用上面的方法将rep的拷贝返回给用户，也可以使用\nCollections.unmodifiableLis()\n对List对象进行修饰，修饰过的对象是不可变的。\nDate\nDate与List相比就要简单一些了，我们只需要创建一个新的Date对象，保证这个对象的值和原来的对象一样即可。\n下面是具体的代码实现。\n最后的运行结果为\ndate : Sat Jan 24 11:33:20 CST 1970\ncopydate : Tue Jul 06 16:57:15 CST 2021\n我们成功创建了两个完全独立的Date对象，这正是我们想要的。\n对于一些其他的对象，或是通过构造函数，或是通过一些\nset\n方法，我们都可以创建一个与原先对象一模一样的对象。\n以List和Date为例，本文主要介绍了Java中进行防御式拷贝的一些方法，并且说明了防御式拷贝的必要性。\n但是如果返回值本身的就是immutable类型的对象，实际上就不需要防御式拷贝了，因为这样的对象是不允许被改变的。所以，在日后的编程中，如果可以使用immutable类型的对象，就尽量使用，这样可以避免许多与表示泄露有关的麻烦。\n"
  },
  {
    "head": "关于boost多线程的小总结",
    "paragraphs": [
      "join",
      "一般来说，多线程的各个线程之间往往是相互联系的，一个线程停止，其他进程也没有继续进行下去的必要了。所以，一般只要在一个线程后面加.join()。但这并不是针对所有情况。比方说，如果两个线程之间没有联系，一个线程结束时，另一个线程不一定要同时结束，这样一来就要在两个线程后面都加上.join()。",
      "一般只在需要处理共享变量的时候加锁。加锁虽然能让线程之间互不影响，但如果加锁覆盖的范围太广，就会减慢整个多线程的速度。有时候，需要进行一些很耗时的操作（比如抓图），但操作的是共享变量，这时候怎么办呢？一个很好的解决方案是先用一个临时变量代替这个共享变量进行抓图，然后再把这个临时变量赋值给共享变量。此时，抓图操作是在加锁之前，赋值操作在加锁之后，而赋值是很快的操作。这样一来，既在使用共享变量时加了锁，又大大加快了程序的运行速度。",
      "一般通过key=cv::waitKey(1)语句等待按“q”进行结束，但这往往只能正常终止当前线程，别的线程是被打断的而不是正常结束。可以在进程中的while循环的条件里写一个开关变量，一旦按下“q”键就修改这个变量的值，让所有进程正常结束。"
    ],
    "sentences": [
      "join",
      "一般来说",
      "多线程的各个线程之间往往是相互联系的",
      "一个线程停止",
      "其他进程也没有继续进行下去的必要了",
      "所以，一般只要在一个线程后面加.join()",
      "但这并不是针对所有情况",
      "比方说",
      "如果两个线程之间没有联系",
      "一个线程结束时",
      "另一个线程不一定要同时结束",
      "这样一来就要在两个线程后面都加上.join()",
      "一般只在需要处理共享变量的时候加锁",
      "加锁虽然能让线程之间互不影响",
      "但如果加锁覆盖的范围太广",
      "就会减慢整个多线程的速度",
      "有时候",
      "需要进行一些很耗时的操作（比如抓图）",
      "但操作的是共享变量",
      "这时候怎么办呢？一个很好的解决方案是先用一个临时变量代替这个共享变量进行抓图",
      "然后再把这个临时变量赋值给共享变量",
      "此时",
      "抓图操作是在加锁之前",
      "赋值操作在加锁之后",
      "而赋值是很快的操作",
      "这样一来",
      "既在使用共享变量时加了锁",
      "又大大加快了程序的运行速度",
      "一般通过key=cv::waitKey(1)语句等待按“q”进行结束",
      "但这往往只能正常终止当前线程",
      "别的线程是被打断的而不是正常结束",
      "可以在进程中的while循环的条件里写一个开关变量",
      "一旦按下“q”键就修改这个变量的值",
      "让所有进程正常结束"
    ],
    "codes": [],
    "date": "2020-11-17",
    "text": "join\n一般来说，多线程的各个线程之间往往是相互联系的，一个线程停止，其他进程也没有继续进行下去的必要了。所以，一般只要在一个线程后面加.join()。但这并不是针对所有情况。比方说，如果两个线程之间没有联系，一个线程结束时，另一个线程不一定要同时结束，这样一来就要在两个线程后面都加上.join()。\n一般只在需要处理共享变量的时候加锁。加锁虽然能让线程之间互不影响，但如果加锁覆盖的范围太广，就会减慢整个多线程的速度。有时候，需要进行一些很耗时的操作（比如抓图），但操作的是共享变量，这时候怎么办呢？一个很好的解决方案是先用一个临时变量代替这个共享变量进行抓图，然后再把这个临时变量赋值给共享变量。此时，抓图操作是在加锁之前，赋值操作在加锁之后，而赋值是很快的操作。这样一来，既在使用共享变量时加了锁，又大大加快了程序的运行速度。\n一般通过key=cv::waitKey(1)语句等待按“q”进行结束，但这往往只能正常终止当前线程，别的线程是被打断的而不是正常结束。可以在进程中的while循环的条件里写一个开关变量，一旦按下“q”键就修改这个变量的值，让所有进程正常结束。\n"
  },
  {
    "head": "关于Java迭代器（Iterator）的思考",
    "paragraphs": [
      "Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。",
      "在我们使用",
      "去遍历集合中的所有元素时，其实就隐式地使用了迭代器（Iterator）。",
      "遍历集合的两种方法",
      "通常来说，遍历集合中的元素主要有以下两种方法。",
      "对于第二种方法来说，其实是显式地定义了一个Iterator类型的对象，它有iterator()方法，调用该方法可以获取一个迭代器。",
      "迭代器有三个基本操作，分别是 next 、hasNext 和 remove。",
      "调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。",
      "调用 it.hasNext() 用于检测集合中是否还有元素。",
      "调用 it.remove() 将迭代器返回的元素删除。",
      "Iterator是Java中的一个接口，位于java.util 包中，使用前需要引入它，语法格式如下：",
      "两种方法的比较",
      "下面，我们来比较一下这两种方法有何不同。",
      "我们先分别运行一下下面的两段代码。",
      "我们发现它们的运行结果是一样的。这样看它们好像没有什么差别，而且第一种写法要简单一些，代码量更少。",
      "删除元素",
      "下面我们比较一下当从集合中删除元素时，这两种写法的区别。",
      "当我们运行上面这段代码时，出现了报错。",
      "可以通过根据异常定位到报错的地方：",
      "当我们使用Java中的foreach循环时，其实编译器会根据list对象创建一个Iterator的迭代器。我们对list进行的增删操作的具体实现都必须经过Iterator。在Iterator创建的时候modCount被赋值给了expectedModCount，但是调用list的add和remove方法的时候不会同时自动增减expectedModCount，这样就导致两个count不相等，从而抛出异常。",
      "我们再试试下面这种写法。",
      "运行之后，出现了和上面一样的报错信息。与上一种写法相比，这里的Iterator被显式地定义出来了，但是同样出现了调用list的remove方法的时候不会同时自动增减expectedModCount的问题，这样就导致两个count不相等，从而抛出异常。",
      "那应该怎样在遍历List的同时删除元素呢，我们看一下下面这种写法。",
      "最后的运行结果如下：",
      "我们可以看到，这里成功的删除了以e结尾的两个字符串。为什么使用iter.remove()就可以成功删除List中的元素呢？这是因为在Iterator中的remove方法在删除元素后会自动调整迭代器指向的元素，也会自动增减expectedModCount的值，所以不会出现之前的报错。",
      "使用自己的迭代器",
      "上面我们都是使用的Java标准库里的Iterator接口，那能否定义自己的MyIterator类（接口）呢？",
      "答案是肯定的。并且在很多时候，为自己设计的抽象数据类型（ADT）增加一个迭代器是一个很不错的设计模式（Iterator Pattern），用户可以用之前已经非常熟悉的迭代器方法来遍历你设计的ADT中的元素。",
      "在Java的标准库中定义了一个Iterable接口，而实现该接口的集合对象是可遍历迭代的。",
      "这里的Ierator是迭代器的接口，也在Java标准库中有定义。基本结构如下。",
      "而所谓的Iterator pattern就是指让自己的集合类实现Iterable接口，并实现自己独特的Iterator迭代器(重写hasNext, next, remove方法)，允许客户端利用这个迭代器进行显式或隐式的迭代遍历。",
      "下面是一个实现样例。"
    ],
    "sentences": [
      "Java Iterator（迭代器）不是一个集合",
      "它是一种用于访问集合的方法",
      "可用于迭代 ArrayList 和 HashSet 等集合",
      "在我们使用",
      "去遍历集合中的所有元素时",
      "其实就隐式地使用了迭代器（Iterator）",
      "遍历集合的两种方法",
      "通常来说，遍历集合中的元素主要有以下两种方法",
      "对于第二种方法来说",
      "其实是显式地定义了一个Iterator类型的对象",
      "它有iterator()方法",
      "调用该方法可以获取一个迭代器",
      "迭代器有三个基本操作",
      "分别是 next 、hasNext 和 remove",
      "调用 it.next() 会返回迭代器的下一个元素",
      "并且更新迭代器的状态",
      "调用 it.hasNext() 用于检测集合中是否还有元素",
      "调用 it.remove() 将迭代器返回的元素删除",
      "Iterator是Java中的一个接口",
      "位于java.util 包中",
      "使用前需要引入它",
      "语法格式如下：两种方法的比较",
      "下面，我们来比较一下这两种方法有何不同",
      "我们先分别运行一下下面的两段代码",
      "我们发现它们的运行结果是一样的",
      "这样看它们好像没有什么差别",
      "而且第一种写法要简单一些",
      "代码量更少",
      "删除元素",
      "下面我们比较一下当从集合中删除元素时，这两种写法的区别",
      "当我们运行上面这段代码时，出现了报错",
      "可以通过根据异常定位到报错的地方：当我们使用Java中的foreach循环时",
      "其实编译器会根据list对象创建一个Iterator的迭代器",
      "我们对list进行的增删操作的具体实现都必须经过Iterator",
      "在Iterator创建的时候modCount被赋值给了expectedModCount",
      "但是调用list的add和remove方法的时候不会同时自动增减expectedModCount",
      "这样就导致两个count不相等",
      "从而抛出异常",
      "我们再试试下面这种写法",
      "运行之后，出现了和上面一样的报错信息",
      "与上一种写法相比",
      "这里的Iterator被显式地定义出来了",
      "但是同样出现了调用list的remove方法的时候不会同时自动增减expectedModCount的问题",
      "这样就导致两个count不相等",
      "从而抛出异常",
      "那应该怎样在遍历List的同时删除元素呢",
      "我们看一下下面这种写法",
      "最后的运行结果如下：我们可以看到",
      "这里成功的删除了以e结尾的两个字符串",
      "为什么使用iter.remove()就可以成功删除List中的元素呢？这是因为在Iterator中的remove方法在删除元素后会自动调整迭代器指向的元素",
      "也会自动增减expectedModCount的值",
      "所以不会出现之前的报错",
      "使用自己的迭代器",
      "上面我们都是使用的Java标准库里的Iterator接口",
      "那能否定义自己的MyIterator类（接口）呢？",
      "答案是肯定的",
      "并且在很多时候",
      "为自己设计的抽象数据类型（ADT）增加一个迭代器是一个很不错的设计模式（Iterator Pattern）",
      "用户可以用之前已经非常熟悉的迭代器方法来遍历你设计的ADT中的元素",
      "在Java的标准库中定义了一个Iterable接口",
      "而实现该接口的集合对象是可遍历迭代的",
      "这里的Ierator是迭代器的接口",
      "也在Java标准库中有定义",
      "基本结构如下",
      "而所谓的Iterator pattern就是指让自己的集合类实现Iterable接口",
      "并实现自己独特的Iterator迭代器(重写hasNext, next, remove方法)",
      "允许客户端利用这个迭代器进行显式或隐式的迭代遍历",
      "下面是一个实现样例"
    ],
    "codes": [
      "for(... : ...)\n",
      "//method1\nList<String> list = ...;\nfor(String str : list) {\n\tSystem.out.println(str);\n}\n",
      "//method2\nList<String> list = ...;\nIterator<String> iter = list.iterator();\nwhile(iter.hasNext()) {\n\tString str = iter.next();\n\tSystem.out.println(str);\n}\n",
      "import java.util.Iterator; // 引入 Iterator 类\n",
      "public class Test {\n\t\n\tpublic static void main(String[] args) {\n\t\tList<String> list = new ArrayList<String>(Arrays.asList(\"Apple\",\"Orange\",\"Peach\"));\n\t\t\n\t\tfor(String str : list) {\n\t\t\tSystem.out.println(str);\n\t\t}\n\t\t\n\t}\n}\n",
      "public class Test {\n\t\n\tpublic static void main(String[] args) {\n\t\tList<String> list = new ArrayList<String>(Arrays.asList(\"Apple\",\"Orange\",\"Peach\"));\n\t\t\n\t\tIterator<String> iter = list.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tString str = iter.next();\n\t\t\tSystem.out.println(str);\n\t\t}\n\t\t\n\t}\n}\n",
      "public class Test {\n\t\n\tpublic static void main(String[] args) {\n\t\tList<String> list = new ArrayList<String>(Arrays.asList(\"Apple\",\"Orange\",\"Peach\"));\n\t\t\n\t\tfor(String str : list) {\n\t\t\tlist.remove(str);\n\t\t}\n\t\t\n\t\tSystem.out.println(list);\n\t\t\n\t}\n}\n",
      "public class Test {\n\t\n\tpublic static void main(String[] args) {\n\t\tList<String> list = new ArrayList<String>(Arrays.asList(\"Apple\",\"Orange\",\"Peach\"));\n\t\t\n\t\tIterator<String> iter = list.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tString str = iter.next();\n\t\t\tlist.remove(str);\n\t\t}\n\t\t\n\t\tSystem.out.println(list);\n\t\t\n\t}\n}\n",
      "public class Test {\n\t\n\tpublic static void main(String[] args) {\n\t\tList<String> list = new ArrayList<String>(Arrays.asList(\"Apple\",\"Orange\",\"Peach\"));\n\t\t\n\t\tIterator<String> iter = list.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tString str = iter.next();\n\t\t\tif(str.endsWith(\"e\")) {\n\t\t\t\titer.remove();\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(list);\n\t\t\n\t}\n}\n",
      "//实现Iterable<E>接口\npublic class Pair<E> implements Iterable<E> {\n\tprivate final E first, second;\n\tpublic Pair(E f, E s) { first = f; second = s; }\n\t//重写iterator方法\n\t//返回自己的迭代器\n\tpublic Iterator<E> iterator() {\n\t\treturn new PairIterator();\n\t}\n\t//构建自己的Iterator\n\tprivate class PairIterator implements Iterator<E> {\n\t\tprivate boolean seenFirst = false, seenSecond = false;\n\t\t//Override hasNext方法\n\t\tpublic boolean hasNext() { return !seenSecond; }\n\t\t//Override next方法\n\t\tpublic E next() {\n\t\t\tif (!seenFirst) { seenFirst = true; return first; }\n\t\t\tif (!seenSecond) { seenSecond = true; return second; }\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\t//Override remove方法\n\t\t//这里不允许删除元素\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n"
    ],
    "date": "2021-07-03",
    "text": "Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。\n在我们使用\n去遍历集合中的所有元素时，其实就隐式地使用了迭代器（Iterator）。\n遍历集合的两种方法\n通常来说，遍历集合中的元素主要有以下两种方法。\n对于第二种方法来说，其实是显式地定义了一个Iterator类型的对象，它有iterator()方法，调用该方法可以获取一个迭代器。\n迭代器有三个基本操作，分别是 next 、hasNext 和 remove。\n调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。\n调用 it.hasNext() 用于检测集合中是否还有元素。\n调用 it.remove() 将迭代器返回的元素删除。\nIterator是Java中的一个接口，位于java.util 包中，使用前需要引入它，语法格式如下：\n两种方法的比较\n下面，我们来比较一下这两种方法有何不同。\n我们先分别运行一下下面的两段代码。\n我们发现它们的运行结果是一样的。这样看它们好像没有什么差别，而且第一种写法要简单一些，代码量更少。\n删除元素\n下面我们比较一下当从集合中删除元素时，这两种写法的区别。\n当我们运行上面这段代码时，出现了报错。\n可以通过根据异常定位到报错的地方：\n当我们使用Java中的foreach循环时，其实编译器会根据list对象创建一个Iterator的迭代器。我们对list进行的增删操作的具体实现都必须经过Iterator。在Iterator创建的时候modCount被赋值给了expectedModCount，但是调用list的add和remove方法的时候不会同时自动增减expectedModCount，这样就导致两个count不相等，从而抛出异常。\n我们再试试下面这种写法。\n运行之后，出现了和上面一样的报错信息。与上一种写法相比，这里的Iterator被显式地定义出来了，但是同样出现了调用list的remove方法的时候不会同时自动增减expectedModCount的问题，这样就导致两个count不相等，从而抛出异常。\n那应该怎样在遍历List的同时删除元素呢，我们看一下下面这种写法。\n最后的运行结果如下：\n我们可以看到，这里成功的删除了以e结尾的两个字符串。为什么使用iter.remove()就可以成功删除List中的元素呢？这是因为在Iterator中的remove方法在删除元素后会自动调整迭代器指向的元素，也会自动增减expectedModCount的值，所以不会出现之前的报错。\n使用自己的迭代器\n上面我们都是使用的Java标准库里的Iterator接口，那能否定义自己的MyIterator类（接口）呢？\n答案是肯定的。并且在很多时候，为自己设计的抽象数据类型（ADT）增加一个迭代器是一个很不错的设计模式（Iterator Pattern），用户可以用之前已经非常熟悉的迭代器方法来遍历你设计的ADT中的元素。\n在Java的标准库中定义了一个Iterable接口，而实现该接口的集合对象是可遍历迭代的。\n这里的Ierator是迭代器的接口，也在Java标准库中有定义。基本结构如下。\n而所谓的Iterator pattern就是指让自己的集合类实现Iterable接口，并实现自己独特的Iterator迭代器(重写hasNext, next, remove方法)，允许客户端利用这个迭代器进行显式或隐式的迭代遍历。\n下面是一个实现样例。\n"
  },
  {
    "head": "2021 春 软件构造 雨课堂选择题(3）（4)",
    "paragraphs": [
      "1.External quality factors：",
      "（1）正确性",
      "（2）健壮性",
      "（3）可扩展性",
      "（4）可复用性",
      "（5）兼容性",
      "（6）效率",
      "（7）可移植性",
      "（8）易用性",
      "（9）功能性",
      "2.敏捷开发特征：",
      "增量式过程",
      "迭代过程",
      "3.配置管理SCM",
      "①软件配置管理：用于追踪和控制软件的变化",
      "②SCI基本配置项：产生变化的基本单元",
      "③版本：为软件的任一特定时刻moment的形态指派一个唯一的编号，作为“身份标识”。",
      "④Git----集中式版本控制系统",
      "4.Git",
      "①.git ----- 本地的CMDB",
      "②工作目录-------本地文件系统",
      "③暂存区-----隔离工作目录和Git仓库",
      "④3种状态：已修改、已暂存、已提交",
      "⑤Git存储发生变化的文件（而非代码行），不变化的文件不重复存储。",
      "⑥将Github上的某个Git仓库设置为本地仓库的指令是：",
      "git pull aaa",
      "⑦将暂存区文件写入Git仓库的指令是：",
      "git commit -m “xxxx”",
      "5.Git 仓库的object graph"
    ],
    "sentences": [
      "1.External quality factors：（1）正确性",
      "（2）健壮性",
      "（3）可扩展性",
      "（4）可复用性",
      "（5）兼容性",
      "（6）效率",
      "（7）可移植性",
      "（8）易用性",
      "（9）功能性",
      "2.敏捷开发特征：增量式过程",
      "迭代过程",
      "3.配置管理SCM",
      "①软件配置管理：用于追踪和控制软件的变化",
      "②SCI基本配置项：产生变化的基本单元",
      "③版本：为软件的任一特定时刻moment的形态指派一个唯一的编号",
      "作为“身份标识”",
      "④Git----集中式版本控制系统",
      "4.Git",
      "①.git ----- 本地的CMDB",
      "②工作目录-------本地文件系统",
      "③暂存区-----隔离工作目录和Git仓库",
      "④3种状态：已修改、已暂存、已提交",
      "⑤Git存储发生变化的文件（而非代码行）",
      "不变化的文件不重复存储",
      "⑥将Github上的某个Git仓库设置为本地仓库的指令是：git pull aaa",
      "⑦将暂存区文件写入Git仓库的指令是：git commit -m “xxxx”",
      "5.Git 仓库的object graph"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "1.External quality factors：\n（1）正确性\n（2）健壮性\n（3）可扩展性\n（4）可复用性\n（5）兼容性\n（6）效率\n（7）可移植性\n（8）易用性\n（9）功能性\n2.敏捷开发特征：\n增量式过程\n迭代过程\n3.配置管理SCM\n①软件配置管理：用于追踪和控制软件的变化\n②SCI基本配置项：产生变化的基本单元\n③版本：为软件的任一特定时刻moment的形态指派一个唯一的编号，作为“身份标识”。\n④Git----集中式版本控制系统\n4.Git\n①.git ----- 本地的CMDB\n②工作目录-------本地文件系统\n③暂存区-----隔离工作目录和Git仓库\n④3种状态：已修改、已暂存、已提交\n⑤Git存储发生变化的文件（而非代码行），不变化的文件不重复存储。\n⑥将Github上的某个Git仓库设置为本地仓库的指令是：\ngit pull aaa\n⑦将暂存区文件写入Git仓库的指令是：\ngit commit -m “xxxx”\n5.Git 仓库的object graph\n"
  },
  {
    "head": "2021 春 软件构造 雨课堂选择题(1)",
    "paragraphs": [
      "String是不可变的数据类型，改变引用、不改变内容。",
      "浮点数在计算机里无法精确存储",
      "remove（int index）",
      "删除的是index处的数字",
      "删除后，数组的大小及其元素下标都会动态更改",
      "trim() //去除字符串的头尾空格"
    ],
    "sentences": [
      "String是不可变的数据类型，改变引用、不改变内容",
      "浮点数在计算机里无法精确存储",
      "remove（int index）",
      "删除的是index处的数字",
      "删除后，数组的大小及其元素下标都会动态更改",
      "trim() //去除字符串的头尾空格"
    ],
    "codes": [
      "Integer a = new Integer(3);\nInteger b = 3;\nint c =  3;\nSystem.out.println(\"a == b \"+ (a == b));\nSystem.out.println(\"b == c \"+ (b == c));\nSystem.out.println(\"a == c \"+ (a == c));\n",
      "String a = \"c\";\nString b = \"c\";\nSystem.out.println(\"a and b: \"+ (a == b));\n",
      "System.out.println(\"2.00 - 1.10  = \"+ (2.00 - 1.10));\n",
      "\tList<Integer> list = new ArrayList<>();\n\t\tfor(int i = -3; i < 3 ;i++){\n\t\t\tlist.add(i);\n\t\t}\n\t\tSystem.out.println(\"finish add \"+list);\n\t\t\n\t\tfor(int i = 0; i < 3;i++){\n\t\t\tlist.remove(i);\n\t\t}\n\t\tSystem.out.println(\"finish remove \" +list);\n\t\t\n",
      "String s = \"Hello\";\ns += \" World \";\ns.trim();\nSystem.out.println(s);\n"
    ],
    "date": "2021-07-07",
    "text": "String是不可变的数据类型，改变引用、不改变内容。\n浮点数在计算机里无法精确存储\nremove（int index）\n删除的是index处的数字\n删除后，数组的大小及其元素下标都会动态更改\ntrim() //去除字符串的头尾空格\n"
  },
  {
    "head": "Java 时间 年月日及其持续天数 用Date！！！",
    "paragraphs": [
      "软构lab3",
      "知道开始和结束日期的年月日，求持续天数",
      "getTimeInMillis()将其转化成long,表示从格林威治标准时间 1970 年 1 月 1 日的",
      "00:00:00.000到Calendar对象表示的时间之间的毫秒数",
      "以上方法十分离谱，快跑！！！",
      "2021-6-1到2021-6-5得到的时间是4",
      "但是！2021-6-30到2021-7-1得到的时间却是1",
      "如果涉及到月转换，就别用这个方法",
      "看了一番突然发现了问题所在：",
      "java里的Calendar不检查月份天数，它默认每个月都是31天。",
      "输出如下：",
      "？？？谁家2月有30号啊！！！！",
      "再见Calendar，我用Date去了",
      "新方法如下：",
      "nice"
    ],
    "sentences": [
      "软构lab3",
      "知道开始和结束日期的年月日，求持续天数",
      "getTimeInMillis()将其转化成long,表示从格林威治标准时间 1970 年 1 月 1 日的",
      "00:00:00.000到Calendar对象表示的时间之间的毫秒数",
      "以上方法十分离谱，快跑！！！",
      "2021-6-1到2021-6-5得到的时间是4",
      "但是！2021-6-30到2021-7-1得到的时间却是1",
      "如果涉及到月转换，就别用这个方法",
      "看了一番突然发现了问题所在：java里的Calendar不检查月份天数",
      "它默认每个月都是31天",
      "输出如下：？？？谁家2月有30号啊！！！！",
      "再见Calendar，我用Date去了",
      "新方法如下：nice"
    ],
    "codes": [
      "import java.util.Calendar;\n\npublic class Try {\n\tpublic static void main(String[] args) {\n\t\tCalendar startdate = Calendar.getInstance();\n\t\tCalendar enddate = Calendar.getInstance();\n\t\t\n\t\t//设置时间\n\t\tstartdate.set(2021,6,30);\n\t\tenddate.set(2021,7,2);\n\t\t\n\t\t//getTimeInMills()函数\n\t\tlong dura = enddate.getTimeInMillis() - startdate.getTimeInMillis();\n\t\t\n\t\t//输出检查\n\t\tSystem.out.println(startdate.get(Calendar.YEAR)+\"-\"+startdate.get(Calendar.MONTH)+\"-\"+startdate.get(Calendar.DATE));\n\t\tSystem.out.println(enddate.get(Calendar.YEAR)+\"-\"+enddate.get(Calendar.MONTH)+\"-\"+enddate.get(Calendar.DATE));\n\t\t\n\t\t//得到毫秒数\n\t\tSystem.out.println(dura);\n\t\t\n\t\t//得到天数\n\t\tSystem.out.println(dura/1000/60/60/24);\n\t}\n\n}\n\n",
      "\tpublic static String nyr(Calendar a) {\n\t\tString mystr = a.get(Calendar.YEAR)+\"-\"+a.get(Calendar.MONTH)+\"-\"+a.get(Calendar.DATE);\n\t\treturn mystr;\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tCalendar a = Calendar.getInstance();\n\t\ta.set(2021,2,28);\n\t\t\n\t\tSystem.out.println(nyr(a));\n\t\ta.add(Calendar.DATE, 1);\n\t\tSystem.out.println(nyr(a));\n\t\ta.add(Calendar.DATE, 1);\n\t\tSystem.out.println(nyr(a));\n\t\ta.add(Calendar.DATE, 1);\n\t\tSystem.out.println(nyr(a));\n\t\ta.add(Calendar.DATE, 1);\n\t\tSystem.out.println(nyr(a));\n\n\t}\n",
      "package test;\n\n//注意：引进的包是sql里的\nimport java.sql.Date;\nimport java.util.Calendar;\n\npublic class Try {\n\t//给日期加n天\n\tpublic static Date add_days(Date a,long day) {\n\t\tCalendar temp =  Calendar.getInstance();\n\t\ttemp.setTime(a);\n\t\ttemp.set(Calendar.DATE, temp.get(Calendar.DATE)+(int)day);\n\t\tDate mydate = new Date(temp.get(Calendar.YEAR)-1900,temp.get(Calendar.MONTH),temp.get(Calendar.DATE));\n\t\treturn mydate;\n\t}\n\t\n\t//计算两个日期之间的持续天数\n\tpublic static long getDuration(Date early,Date late) {\n\t\t//不必考虑日期的先后顺序，加个绝对值\n\t\tlong myDura = Math.abs(early.getTime() - late.getTime())/(1000*60*60*24);\n\t\treturn myDura;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t//奇妙的赋值方式\n\t\t//年份-1900，月份-1，日正常\n\t\tDate a = new Date(2021-1900,2-1,28);\n\t\tSystem.out.println( a.toString());\n\t\t\n\t\tSystem.out.println(\"---------测试：加方法是否跨月份----------\");\n\t\t\n\t\t//注意：Date是mutable的\n\t\ta = add_days(a, 1);\n\t\tSystem.out.println( a.toString());\n\t\t\n\t\ta = add_days(a, 1);\n\t\tSystem.out.println( a.toString());\n\t\t\n\t\ta = add_days(a, 1);\n\t\tSystem.out.println( a.toString());\n\t\t\n\t\t\n\t\tSystem.out.println(\"---------测试：两个日期之间的持续天数----------\");\n\t\t\n\t\tDate b = new Date(2021-1900,6-1,1);\n\t\tDate c = new Date(2021-1900,6-1,5);\n\t\tDate d = new Date(2021-1900,7-1,1);\n\t\t\n\t\tSystem.out.println(\"2021-6-1 到 2021-6-5 间隔 \"+getDuration(b, c)+\" 天\");\n\t\tSystem.out.println(\"2021-6-1 到 2021-7-1 间隔 \"+getDuration(d, b)+\" 天\");\n\n}\n"
    ],
    "date": "2021-06-30",
    "text": "软构lab3\n知道开始和结束日期的年月日，求持续天数\ngetTimeInMillis()将其转化成long,表示从格林威治标准时间 1970 年 1 月 1 日的\n00:00:00.000到Calendar对象表示的时间之间的毫秒数\n以上方法十分离谱，快跑！！！\n2021-6-1到2021-6-5得到的时间是4\n但是！2021-6-30到2021-7-1得到的时间却是1\n如果涉及到月转换，就别用这个方法\n看了一番突然发现了问题所在：\njava里的Calendar不检查月份天数，它默认每个月都是31天。\n输出如下：\n？？？谁家2月有30号啊！！！！\n再见Calendar，我用Date去了\n新方法如下：\nnice\n"
  },
  {
    "head": "2021 春 软件构造 雨课堂选择题(2)",
    "paragraphs": [
      "1.Memory dump 属于软件三维视图中的：",
      "Run-time、Code-level、Moment",
      "2.Execution stack trace 和 code snapshot 在软件三维度视图中的共性是：",
      "都是Run-time，code-level",
      "3.Code Churn 和 AST 分别是Build-time和period的视图",
      "4.Static linking（静态链接） 和 Dynamic linking（动态链接）的区别在于：",
      "①前者发生在构造阶段，后者发生在运行阶段。"
    ],
    "sentences": [
      "1.Memory dump 属于软件三维视图中的：Run-time、Code-level、Moment",
      "2.Execution stack trace 和 code snapshot 在软件三维度视图中的共性是：都是Run-time",
      "code-level",
      "3.Code Churn 和 AST 分别是Build-time和period的视图",
      "4.Static linking（静态链接） 和 Dynamic linking（动态链接）的区别在于：①前者发生在构造阶段",
      "后者发生在运行阶段"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "1.Memory dump 属于软件三维视图中的：\nRun-time、Code-level、Moment\n2.Execution stack trace 和 code snapshot 在软件三维度视图中的共性是：\n都是Run-time，code-level\n3.Code Churn 和 AST 分别是Build-time和period的视图\n4.Static linking（静态链接） 和 Dynamic linking（动态链接）的区别在于：\n①前者发生在构造阶段，后者发生在运行阶段。\n"
  },
  {
    "head": "2021 春 软件构造 雨课堂选择题(5)",
    "paragraphs": [
      "1.code review 代码评审",
      "2.static code analysis",
      "3.dynamic code analysis 动态分析：执行程序并观察现象，收集数据、分析不足",
      "4.profiling：对代码的运行时状态和性能进行度量，发现代码中存在的问题",
      "5.refactoring 重构 在不改变功能的前提下，优化代码"
    ],
    "sentences": [
      "1.code review 代码评审",
      "2.static code analysis",
      "3.dynamic code analysis 动态分析：执行程序并观察现象",
      "收集数据、分析不足",
      "4.profiling：对代码的运行时状态和性能进行度量",
      "发现代码中存在的问题",
      "5.refactoring 重构 在不改变功能的前提下",
      "优化代码"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "1.code review 代码评审\n2.static code analysis\n3.dynamic code analysis 动态分析：执行程序并观察现象，收集数据、分析不足\n4.profiling：对代码的运行时状态和性能进行度量，发现代码中存在的问题\n5.refactoring 重构 在不改变功能的前提下，优化代码\n"
  },
  {
    "head": "Git 学习笔记",
    "paragraphs": [
      "个人的学习笔记，用作以后复习。",
      "以下内容来源于尚硅谷：",
      "link",
      "1.Git 的常用命令",
      "1.1设置用户签名",
      "安装完成后只需要设置一次用户签名",
      "否则提交代码会报错",
      "小技巧：输入命令的前几个字母，点击tab键自动补全命令",
      "1.2基本操作",
      "先打开项目文件所在位置",
      "再打开bash",
      ".git 文件默认隐藏，不要修改它里面放的东西",
      "2.Git 的分支操作",
      "2.1 什么是分支",
      "一个项目，多个任务，我们对每个任务创建分支。在不同的分支上完成开发，这样就不会影响主分支。",
      "分支是可以改名的",
      "2.2 分支的操作",
      "2.3 合并时冲突的处理办法",
      "两个分支在同一文件同一位置有两套完全不同的修改",
      "人为决定谁去谁留",
      "直接vim打开冲突的文件，人为修改<<<===>>>之间的内容，再次添加到缓存区，提交即可",
      "但提交时不要加上filename.type",
      "3.GitHub 操作",
      "3.1创建远程创库",
      "3.2 本地分支和远程仓库",
      "3.3 GitHub团队内协作",
      "前提条件：加入团队",
      "得到了一个邀请的网页地址",
      "被邀请者需要进入这个网站，接受这个邀请"
    ],
    "sentences": [
      "个人的学习笔记，用作以后复习",
      "以下内容来源于尚硅谷：link",
      "1.Git 的常用命令",
      "1.1设置用户签名",
      "安装完成后只需要设置一次用户签名",
      "否则提交代码会报错",
      "小技巧：输入命令的前几个字母，点击tab键自动补全命令",
      "1.2基本操作",
      "先打开项目文件所在位置",
      "再打开bash",
      ".git 文件默认隐藏，不要修改它里面放的东西",
      "2.Git 的分支操作",
      "2.1 什么是分支",
      "一个项目，多个任务，我们对每个任务创建分支",
      "在不同的分支上完成开发，这样就不会影响主分支",
      "分支是可以改名的",
      "2.2 分支的操作",
      "2.3 合并时冲突的处理办法",
      "两个分支在同一文件同一位置有两套完全不同的修改",
      "人为决定谁去谁留",
      "直接vim打开冲突的文件",
      "人为修改<<<===>>>之间的内容",
      "再次添加到缓存区",
      "提交即可",
      "但提交时不要加上filename.type",
      "3.GitHub 操作",
      "3.1创建远程创库",
      "3.2 本地分支和远程仓库",
      "3.3 GitHub团队内协作",
      "前提条件：加入团队",
      "得到了一个邀请的网页地址",
      "被邀请者需要进入这个网站，接受这个邀请"
    ],
    "codes": [
      "git config --global user.name yourname\ngit config --global user.email youremailadd\n",
      "cat ~/.gitconfig  //查看设置好的用户\n{查看用户：c盘用户}\n{这个签名和其他的账号，如Github账号没有任何关系}\n",
      "git init //初始化本地库\n",
      "ll //查看文件\nll -a //查看隐藏文件\ncd/ //回到根目录\ncd.. //回到上一层目录\n",
      "git status //查看本地库状态\n//On branch master 在master分支\n",
      "git add filename #添加到暂存区，也就是追踪文件的过程\ngit add --all\n",
      "waring：LF will be replaced by CRLF in hello.txt\n这里是window里面的换行符LF被改成Linux下的换行符CRLF，不必在意这个警告\n",
      "//暂存区的文件可以删除\ngit rm --cached filename //只是从暂存区里删掉了，工作区里没有删除\ngit commit -m \"日志信息\" filename //提交到本地库\ngit reflog //查看版本信息\n//965c6a1 (HEAD -> master)……  //965c6a1版本号\ngit log //查看详细版本信息\ncat filename //显示filename里面的内容\n",
      "·只要有文件修改就可以查看状态\n·修改文件后再用git status 查看，发现modified信息\n·Git里按行来修改文件\n",
      "git reset --hard 版本号 //版本穿梭：认为新的版本不行，回到旧的版本\n//版本号用relog查看就可以\n",
      "git 切换版本用的是指针，不是记录很多个不同版本的文件（副本）\n\nHEAD指向的分支就是当前分支\n",
      "Master 主分支\nHot-fix 热修复分支\n",
      " git branch name   //创建分支\n git branch -v  //查看分支\n git branch -m old_name new_name\n git checkout name  //切换分支\n git merge name //把指定的分支合并到当前分支上 \n//注意：合并前得先切换到目标分支，再合并\n",
      "CONFLICT(content)：Merge conflict in filename.type\n",
      "git commit -m \"info\" \n",
      " git remote -v  //查看别名\n git remote add A B  //创建别名 将B重新起个名字，A\n git remote add git-demo http://……  //将网站叫做git-demo\n",
      "git push 别名 分支 //推送本地分支到远程仓库\n//不用别名，直接用网页链接也可以\n\n git pull 别名 分支 //拉取远程仓库到本地库\n\n git clone http://…… //克隆远程代码到本地\n/*\n克隆代码不需要登陆\n①拉取代码\n②自动初始化本地仓库\n③别名也创建好了\n*/\n",
      "在仓库创建者的账号里：setting-->manage access-->invite a collaborator-->输入账号\n"
    ],
    "date": "2021-06-09",
    "text": "个人的学习笔记，用作以后复习。\n以下内容来源于尚硅谷：\nlink\n1.Git 的常用命令\n1.1设置用户签名\n安装完成后只需要设置一次用户签名\n否则提交代码会报错\n小技巧：输入命令的前几个字母，点击tab键自动补全命令\n1.2基本操作\n先打开项目文件所在位置\n再打开bash\n.git 文件默认隐藏，不要修改它里面放的东西\n2.Git 的分支操作\n2.1 什么是分支\n一个项目，多个任务，我们对每个任务创建分支。在不同的分支上完成开发，这样就不会影响主分支。\n分支是可以改名的\n2.2 分支的操作\n2.3 合并时冲突的处理办法\n两个分支在同一文件同一位置有两套完全不同的修改\n人为决定谁去谁留\n直接vim打开冲突的文件，人为修改<<<===>>>之间的内容，再次添加到缓存区，提交即可\n但提交时不要加上filename.type\n3.GitHub 操作\n3.1创建远程创库\n3.2 本地分支和远程仓库\n3.3 GitHub团队内协作\n前提条件：加入团队\n得到了一个邀请的网页地址\n被邀请者需要进入这个网站，接受这个邀请\n"
  },
  {
    "head": "Java设计模式：装饰器模式（简易版）",
    "paragraphs": [
      "软构lab3",
      "这是个简单的例子",
      "我们假设要点一份菜。",
      "菜单里：",
      "①蔬菜",
      "②肉类",
      "现在我们为这个份菜增加装饰：",
      "①加辣椒",
      "②加量",
      "1.抽象构件角色：Dish",
      "这是一个接口",
      "2.具体实现：Meat 和 Vegetable",
      "Meat和Vegetable是对Dish的具体实现，用implements",
      "3.抽象装饰器DecoratorDish",
      "①这是一个抽象类，实现Dish，因此用implements",
      "②注意其成员属性：引用了Dish对象",
      "4.具体装饰AddPepper和Large",
      "①在这里实现要增加的新方法",
      "②注意构造器的写法，用了super",
      "5.测试"
    ],
    "sentences": [
      "软构lab3",
      "这是个简单的例子",
      "我们假设要点一份菜",
      "菜单里：①蔬菜",
      "②肉类",
      "现在我们为这个份菜增加装饰：①加辣椒",
      "②加量",
      "1.抽象构件角色：Dish",
      "这是一个接口",
      "2.具体实现：Meat 和 Vegetable",
      "Meat和Vegetable是对Dish的具体实现",
      "用implements",
      "3.抽象装饰器DecoratorDish",
      "①这是一个抽象类，实现Dish，因此用implements",
      "②注意其成员属性：引用了Dish对象",
      "4.具体装饰AddPepper和Large",
      "①在这里实现要增加的新方法",
      "②注意构造器的写法，用了super",
      "5.测试"
    ],
    "codes": [
      "package func;\n\npublic interface Dish {\n\tvoid orderdish(String msg);//点一份菜\n\t\n}\n\n",
      "package func;\n\npublic class Meat implements Dish{\n\n\t@Override\n\tpublic void orderdish(String msg) {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"你点了一份荤菜：\"+msg);\n\t}\n\n}\n\n",
      "package func;\n\npublic class Vegetable implements Dish{\n\n\t@Override\n\tpublic void orderdish(String msg) {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"你点了一份素菜：\"+msg);\n\t}\n\n}\n\n",
      "package decorator;\n\nimport func.Dish;\n\npublic abstract class DecoratorDish implements Dish{\n\t//要装饰的对象是  \n\tprivate Dish myDish;\n\t//构造器\n\tpublic DecoratorDish(Dish myDish) {\n\t\tthis.myDish = myDish;\n\t}\n\t\n\t//原先在Dish接口中的方法\n\tpublic void orderdish(String msg) {\n\t\tmyDish.orderdish(msg);\n\t}\n\n}\n\n",
      "package decorator;\nimport func.Dish;\n\npublic class Large extends DecoratorDish{\t\n\n\t//构造器\n\tpublic Large(Dish large_dish) {\n\t\tsuper(large_dish);\n\t}\n\t\n\t//点一份加大的菜\n\t@Override\n\tpublic void orderdish(String msg) {\n\t\tsuper.orderdish(msg);//原功能\n\t\tLargeDish();//新功能\n\t}\n\n\t//要增加的新的功能\n\tpublic void LargeDish() {\n\t\tSystem.out.println(\"备注：大份的\");\n\t}\n}\n\n",
      "package decorator;\n\nimport func.Dish;\n\npublic class AddPepper extends DecoratorDish{\n\t\n\t//构造器\n\tpublic  AddPepper(Dish pepper_dish) {\n\t\tsuper(pepper_dish);\n\n\t}\n\n\t//点一份加辣的菜\n\t@Override\n\tpublic void orderdish(String msg) {\n\t\tsuper.orderdish(msg);//原功能\n\t\tPepperDish();//新功能\n\t}\n\n\t\n\t//要增加的新的功能\n\tpublic void PepperDish() {\n\t\tSystem.out.println(\"备注：加辣的\");\n\t}\n\n\n}\n\n",
      "package test;\n\nimport decorator.AddPepper;\nimport decorator.Large;\nimport func.Vegetable;\nimport func.Dish;\nimport func.Meat;\n\npublic class testde {\n\tpublic static void main(String[] argv) {\n\t\tDish salad = new Vegetable();\n\t\tDish chicken= new Meat();\n\t\t\n\t\t\n\t\tSystem.out.println(\"-------原始的---------\");\n\t\tsalad.orderdish(\"沙拉\");\n\t\tchicken.orderdish(\"烤鸡\");\n\t\t\n\t\t//这里就是使用了装饰的\n\t\t//我们可以给Dish的具体实现类增加任意多的装饰\n\t\tDish large_salad = new Large(new Vegetable());\n\t\tDish pepper_chicken= new AddPepper(chicken);\n\t\tDish double_deco = new AddPepper(new Large(new Vegetable()));\n\t\t\n\t\tSystem.out.println(\"\\n-------加装饰的---------\");\n\t\tlarge_salad.orderdish(\"沙拉\");\n\t\tpepper_chicken.orderdish(\"烤鸡\");\n\t\tdouble_deco.orderdish(\"土豆泥\");\n\t\t\n\t}\n\n}\n\n"
    ],
    "date": "2021-07-02",
    "text": "软构lab3\n这是个简单的例子\n我们假设要点一份菜。\n菜单里：\n①蔬菜\n②肉类\n现在我们为这个份菜增加装饰：\n①加辣椒\n②加量\n1.抽象构件角色：Dish\n这是一个接口\n2.具体实现：Meat 和 Vegetable\nMeat和Vegetable是对Dish的具体实现，用implements\n3.抽象装饰器DecoratorDish\n①这是一个抽象类，实现Dish，因此用implements\n②注意其成员属性：引用了Dish对象\n4.具体装饰AddPepper和Large\n①在这里实现要增加的新方法\n②注意构造器的写法，用了super\n5.测试\n"
  },
  {
    "head": "Java 的 ArrayList小问题",
    "paragraphs": [
      "1.发现在new时，不是会自动初始化为null",
      "①在遍历时最好使用for-each方法，否则会出现越界异常",
      "②或者用size()来遍历也行",
      "2.发现remove后，元素下标会自动排好"
    ],
    "sentences": [
      "1.发现在new时，不是会自动初始化为null",
      "①在遍历时最好使用for-each方法，否则会出现越界异常",
      "②或者用size()来遍历也行",
      "2.发现remove后，元素下标会自动排好"
    ],
    "codes": [
      "import java.util.ArrayList;\n\npublic class Try {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tArrayList<String> mylist = new ArrayList<>();\n\t\t\n\t\tmylist.add(0, \"A\");\n\t\tmylist.add(1, \"A\");\n\t\t//注释掉，发现编译报错\n\t\t//mylist.add(2, \"NULL\");\n\t\tmylist.add(3, \"B\");\n\t\tfor(String i : mylist) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n\n}\n\n",
      "import java.util.ArrayList;\n\npublic class Try {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tArrayList<Integer> mylist = new ArrayList<>();\n\t\tfor(int i = 0;i<=4;i++) {\n\t\t\tmylist.add(i);\n\t\t}\n\t\t\n\t\tfor(int j :mylist) {\n\t\t\tSystem.out.println(j);\n\t\t}\n\t\t\n\t\tmylist.remove(1);\n\t\t\n\t\tSystem.out.println(mylist.indexOf(0));\n\t\tSystem.out.println(mylist.indexOf(2));\n\t\tSystem.out.println(mylist.indexOf(3));\n\t\tSystem.out.println(mylist.indexOf(4));\n\n\t}\n\n}\n"
    ],
    "date": "2021-06-30",
    "text": "1.发现在new时，不是会自动初始化为null\n①在遍历时最好使用for-each方法，否则会出现越界异常\n②或者用size()来遍历也行\n2.发现remove后，元素下标会自动排好\n"
  },
  {
    "head": "哈工大软件构造 第三次实验报告",
    "paragraphs": [
      "2021年春季学期计算学部《软件构造》课程",
      "Lab 3实验报告",
      "郭子正",
      "1190201117",
      "1936601",
      "电子邮件",
      "1190201117@stu.hit.edu.cn",
      "手机号码",
      "18102152791",
      "1 实验目标概述",
      "2 实验环境配置",
      "3 实验过程",
      "3.1 待开发的三个应用场景",
      "3.2 面向可复用性和可维护性的设计：IntervalSet<L>",
      "3.2.1 IntervalSet<L>的共性操作",
      "3.2.2 局部共性特征的设计方案",
      "3.2.3 面向各应用的IntervalSet子类型设计（个性化特征的设计方案）",
      "3.3 面向可复用性和可维护性的设计：MultiIntervalSet<L>",
      "3.3.1 MultiIntervalSet<L>的共性操作",
      "3.3.2 局部共性特征的设计方案",
      "3.3.3 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）",
      "3.4 面向复用的设计：L",
      "3.5 可复用API设计",
      "3.5.1 计算相似度",
      "3.5.2 计算时间冲突比例",
      "3.5.3 计算空闲时间比例",
      "3.6 应用设计与开发",
      "3.6.1 排班管理系统",
      "3.6.2 操作系统的进程调度管理系统",
      "3.6.3 课表管理系统",
      "3.7 基于语法的数据读入",
      "3.8 应对面临的新变化",
      "3.8.1 变化1",
      "3.8.2 变化2",
      "3.9 Git仓库结构",
      "4 实验进度记录",
      "5 实验过程中遇到的困难与解决途径",
      "6 实验过程中收获的经验、教训、感想",
      "6.1 实验过程中收获的经验和教训",
      "6.2 针对以下方面的感受",
      "1 实验目标概述",
      "本次实验覆盖课程第 2、3 章的内容，目标是编写具有可复用性和可维护性 的软件，主要使用以下软件构造技术:",
      "⚫ 子类型、泛型、多态、重写、重载⚫ 继承、代理、组合⚫ 语法驱动的编程、正则表达式⚫ API设计、API复用",
      "本次实验给定了三个具体应用(值班表管理、操作系统进程调度管理、大学课表管理)，学生不是直接针对每个应用分别编程实现，而是通过 ADT 和泛型等抽象技术，开发一套可复用的 ADT 及其实现，充分考虑这些应用之间的相似性和差异性，使ADT有更大程度的复用(可复用性)和更容易面向各种变化(可维护性)。",
      "2 实验环境配置",
      "简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。",
      "特别是要记录配置过程中遇到的问题和困难，以及如何解决的。",
      "点击实验指导中的链接，创建仓库，克隆到本地进行开发即可。",
      "在这里给出你的GitHub Lab3仓库的URL地址（Lab3-1190201117）。",
      "https://github.com/ComputerScienceHIT/HIT-Lab3-1190201117",
      "3 实验过程",
      "请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。",
      "3.1 待开发的三个应用场景",
      "DutyRosterApp：设计一个排班表。排班表不允许重叠。理论上也不允许有空白，但是这需要等到全部插入结束之后之后才能判断。",
      "ProcessSchedule：设计一个进程调度器，可以将进程执行时间分割并重新排列，模拟处理器的进程调度。进程之间不可以重叠。",
      "CourseSchedule：设计一个课程表，可以添加课程并选课，课程之间可以重叠。由于每周课程都相同，于是只需要关注一周的课程情况即可。",
      "分析三个应用场景的异同，理解需求：它们在哪些方面有共性、哪些方面有差异。",
      "共性：都需要一个管理时间区间的数据结构，可以向结构内插入新区间。每个区间都有一个标识。",
      "差异：有些情况下（排班表、进程调度）区间不允许重叠，而另外一些情况下（课表管理）区间可以重叠。",
      "3.2 面向可复用性和可维护性的设计：IntervalSet<L>",
      "该节是本实验的核心部分。",
      "3.2.1 IntervalSet<L>的共性操作",
      "插入新区间",
      "获取结构内所有区间的标志",
      "删除区间",
      "获取给定标志的区间的开始/结束时间（由于IntervalSet中不允许多个区间共享一个标记，所以这个操作的结果是唯一的）",
      "将区间按开始时间排序，返回排好序的列表",
      "计算冲突时间的比例",
      "计算空闲时间的比例",
      "获取/设置该数据结构存放区间的最早开始时间/最晚结束时间",
      "3.2.2 局部共性特征的设计方案",
      "CommonIntervalSet实现局部共性特征，个性特征使用装饰器模式拓展。CommonIntervalSet描述了最基本的区间集合。该ADT使用HashMap将区间的标志和区间信息（开始时间，结束时间，区间标志）联系起来，并且保存区间的最早开始时间/最晚结束时间。",
      "插入新区间/删除区间：直接修改HashMap即可。",
      "获取区间标志：直接访问HashMap中keySet即可。",
      "获取给定标志的区间的开始/结束时间：直接访问对应区间信息即可。",
      "将区间按开始时间排序，返回排好序的列表：重写比较器，利用标准库的算法。",
      "计算冲突/空闲时间的比例：扫描全部时间点，并查看相邻两个时间点之间是否有区间，再进行计算即可。",
      "获取/设置该数据结构存放区间的最早开始时间/最晚结束时间：直接访问ADT内保存的 信息即可。",
      "3.2.3 面向各应用的IntervalSet子类型设计（个性化特征的设计方案）",
      "添加一个装饰器NonOverlappableIntervalSet，可以禁止重叠区间。装饰器内只需要重写插入方法。每次插入时，扫描待插入区间对应的时间段，查看是否有其他区间已经占用了此时间段。",
      "面向排班表的类型设计DutyIntervalSet：增加了管理员工的功能以及随机生成排班表的功能。",
      "3.3 面向可复用性和可维护性的设计：MultiIntervalSet<L>",
      "3.3.1 MultiIntervalSet<L>的共性操作",
      "插入新区间",
      "获取结构内所有区间的标志",
      "删除区间",
      "获取给定标志的所有区间",
      "将区间按开始时间排序，返回排好序的列表",
      "计算冲突时间的比例",
      "计算空闲时间的比例",
      "获取/设置该数据结构存放区间的最早开始时间/最晚结束时间",
      "计算两个MultiIntervalSet的相似性",
      "3.3.2 局部共性特征的设计方案",
      "计算相似性:枚举所有时间点,查看在任意两个相邻时间点间两个ADT是否存储了具有相同标记的区间信息，若有则项结果中添加相应的值，否则继续查看下一个时间段。",
      "利用IntervalSet作为其rep，将标签标号作为IntervalSet内区间的标签进行操作。其他方法和IntervalSet中实现方案相同。",
      "3.3.3 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）",
      "进程调度ProcessIntervalSet：增加随机调度和最短进程优先的调度方法.",
      "模拟课表CourseIntervalSet : 增加添加课程、选课和获取课表的方法",
      "3.4 面向复用的设计：L",
      "将IntervalSet和MultiIntervalSet中标签的类型泛化，以适应不同场景。",
      "3.5 可复用API设计",
      "API设计在各ADT内部。",
      "3.5.1 计算相似度",
      "public double Similarity(MultiIntervalSet<L> set)",
      "枚举所有时间点,查看在任意两个相邻时间点间两个ADT是否存储了具有相同标记的区间信息，若有则项结果中添加相应的值，否则继续查看下一个时间段。",
      "3.5.2 计算时间冲突比例",
      "public double calcConflictRatio()",
      "扫描全部时间点，并查看相邻两个时间点之间是否有区间，再进行计算。",
      "3.5.3 计算空闲时间比例",
      "public double calcFreeTimeRatio()",
      "扫描全部时间点，并查看相邻两个时间点之间是否有区间，再进行计算。",
      "3.6 应用设计与开发",
      "利用上述设计和实现的ADT，实现手册里要求的各项功能。",
      "3.6.1 排班管理系统",
      "使用Calendar类管理日期，将日期转化成长整型进行存储，输出时再将长整数转化回日期进行输出。",
      "存储员工姓名和对应Employee信息的对照表，方便进行查找。由于不允许重名，所以这个方法是可行的。",
      "剩下的功能可以直接调用DutyIntervalSet中的方法直接实现。",
      "3.6.2 操作系统的进程调度管理系统",
      "将进程信息打包成Process类，作为ProcessIntervalSet的标签。所有功能均可以使用ProcessIntervalSet中的方法实现。注意在这个应用中区间的总长度是不断变长的。",
      "3.6.3 课表管理系统",
      "只需要管理一周的课程安排即可。将一周分成35个时间段，对应35个可能的上课时间。对这些时间分别编号并存进CourseIntervalSet即可。其余功能可以借助CourseIntervalSet中的方法完成。",
      "3.7 基于语法的数据读入",
      "修改“排班管理”应用以扩展该功能。",
      "只需利用正则表达式分析文本文件。具体如下：",
      "之后分别读取各组中的字符串即可。其中需要特殊判断Roster部分和Period部分可能的重合情况。",
      "3.8 应对面临的新变化",
      "3.8.1 变化1",
      "评估之前的设计是否可应对变化、代价如何、如何修改设计以应对变化",
      "可以应对变化，将排班表中的rep改为MultiIntervalSet即可。代价很小（两行代码）。",
      "3.8.2 变化2",
      "评估之前的设计是否可应对变化、代价如何、如何修改设计以应对变化",
      "可以应对变化。将MultiIntervalSet中rep的IntervalSet添加一层装饰器NonOverlappableIntervalSet即可。代价很小（三行代码）。",
      "3.9 Git仓库结构",
      "请在完成全部实验要求之后，利用Git log指令或Git图形化客户端或GitHub上项目仓库的Insight页面，给出你的仓库到目前为止的Object Graph，尤其是区分清楚change分支和master分支所指向的位置。",
      "4 实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。",
      "不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。",
      "时间段",
      "计划任务",
      "实际完成情况",
      "2021-06-28",
      "15:00-17:00",
      "设计装饰器结构，写IntervalSet相关测试用例",
      "完成，顺便实现了CommonIntervalSet",
      "2021-06-28",
      "19:00-20:00",
      "设计IntervalSet相关装饰器",
      "2021-06-30",
      "8:00-12:00",
      "设计CommonIntervalSet的接口，并完成测试和实现",
      "2021-07-01",
      "8:00-24:00",
      "完成DutyRoster",
      "发现代码需要重构，未完成",
      "2021-07-02",
      "13:00-17:00",
      "实现并调试DutyRoster",
      "2021-07-02",
      "19:00-21:00",
      "实现并调试Process",
      "2021-07-03",
      "9:00-14:30",
      "实现并调试Course",
      "5 实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "计算日期/处理日期相关数据",
      "使用Calendar类",
      "正则表达式匹配",
      "百度相关内容，请教同学",
      "6 实验过程中收获的经验、教训、感想",
      "6.1 实验过程中收获的经验和教训",
      "(1) 过早优化是万恶之源，会把代码结构弄乱，并且会不断重构。",
      "(2) 为了避免重构，需要在开发初期仔细设计好接口以及规范。尽量降低代码耦合度。",
      "6.2 针对以下方面的感受",
      "(1) 重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在三个不同的应用场景下使用，你是否体会到复用的好处？",
      "应用场景变化较多，需要考虑的情形较之于面向ADT编程要复杂。复用的好处在于可以减少代码量，提高开发效率和维护性。",
      "(2) 重新思考Lab2中的问题：为ADT撰写复杂的specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？",
      "意义：防止在复杂的应用场景中出现复杂且难以调试的错误。",
      "(3) 之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？",
      "难处在于需要精心设计API才可以使适用范围尽可能扩大。",
      "乐趣在于API可以带来效率提升。",
      "(4) 你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？",
      "语法驱动编程比起传统方式较为高效，可以快速准确地读入数据。",
      "(5) Lab1和Lab2的大部分工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过五周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？",
      "难度：设计规约。设计欠周的规约在后期会带来不便，且经常需要重新设计规约，将已有设计推翻重来。",
      "(6) “抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的五个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？",
      "经验：尽可能将共用方法放在上层，个性方法放在下层。",
      "教训：1.使用恰当的设计模式，不可滥用设计模式 2. 设计接口时考虑后期拓展的可能性，尽量避免不得不重构代码的情况。",
      "(7) 关于本实验的工作量、难度、deadline。",
      "如果是在平常情况下，工作量和难度均适中，但是实验所在的时间段临近期末，综合考虑来说时间非常不够用。",
      "(8) 到目前为止你对《软件构造》课程的评价。",
      "这门课讲了一些实用的编程技巧以及指导思想，对以后编程开发有帮助。但是课时被压缩之后内容不完整。"
    ],
    "sentences": [
      "2021年春季学期计算学部《软件构造》课程",
      "Lab 3实验报告",
      "郭子正",
      "1190201117",
      "1936601",
      "电子邮件",
      "1190201117@stu.hit.edu.cn",
      "手机号码",
      "18102152791",
      "1 实验目标概述",
      "2 实验环境配置",
      "3 实验过程",
      "3.1 待开发的三个应用场景",
      "3.2 面向可复用性和可维护性的设计：IntervalSet<L>",
      "3.2.1 IntervalSet<L>的共性操作",
      "3.2.2 局部共性特征的设计方案",
      "3.2.3 面向各应用的IntervalSet子类型设计（个性化特征的设计方案）",
      "3.3 面向可复用性和可维护性的设计：MultiIntervalSet<L>",
      "3.3.1 MultiIntervalSet<L>的共性操作",
      "3.3.2 局部共性特征的设计方案",
      "3.3.3 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）",
      "3.4 面向复用的设计：L",
      "3.5 可复用API设计",
      "3.5.1 计算相似度",
      "3.5.2 计算时间冲突比例",
      "3.5.3 计算空闲时间比例",
      "3.6 应用设计与开发",
      "3.6.1 排班管理系统",
      "3.6.2 操作系统的进程调度管理系统",
      "3.6.3 课表管理系统",
      "3.7 基于语法的数据读入",
      "3.8 应对面临的新变化",
      "3.8.1 变化1",
      "3.8.2 变化2",
      "3.9 Git仓库结构",
      "4 实验进度记录",
      "5 实验过程中遇到的困难与解决途径",
      "6 实验过程中收获的经验、教训、感想",
      "6.1 实验过程中收获的经验和教训",
      "6.2 针对以下方面的感受",
      "1 实验目标概述",
      "本次实验覆盖课程第 2、3 章的内容",
      "目标是编写具有可复用性和可维护性 的软件",
      "主要使用以下软件构造技术:⚫ 子类型、泛型、多态、重写、重载⚫ 继承、代理、组合⚫ 语法驱动的编程、正则表达式⚫ API设计、API复用",
      "本次实验给定了三个具体应用(值班表管理、操作系统进程调度管理、大学课表管理)",
      "学生不是直接针对每个应用分别编程实现",
      "而是通过 ADT 和泛型等抽象技术",
      "开发一套可复用的 ADT 及其实现",
      "充分考虑这些应用之间的相似性和差异性",
      "使ADT有更大程度的复用(可复用性)和更容易面向各种变化(可维护性)",
      "2 实验环境配置",
      "简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图",
      "特别是要记录配置过程中遇到的问题和困难，以及如何解决的",
      "点击实验指导中的链接，创建仓库，克隆到本地进行开发即可",
      "在这里给出你的GitHub Lab3仓库的URL地址（Lab3-1190201117）",
      "https://github.com/ComputerScienceHIT/HIT-Lab3-1190201117",
      "3 实验过程",
      "请仔细对照实验手册",
      "针对每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）",
      "3.1 待开发的三个应用场景",
      "DutyRosterApp：设计一个排班表",
      "排班表不允许重叠",
      "理论上也不允许有空白",
      "但是这需要等到全部插入结束之后之后才能判断",
      "ProcessSchedule：设计一个进程调度器",
      "可以将进程执行时间分割并重新排列",
      "模拟处理器的进程调度",
      "进程之间不可以重叠",
      "CourseSchedule：设计一个课程表",
      "可以添加课程并选课",
      "课程之间可以重叠",
      "由于每周课程都相同，于是只需要关注一周的课程情况即可",
      "分析三个应用场景的异同",
      "理解需求：它们在哪些方面有共性、哪些方面有差异",
      "共性：都需要一个管理时间区间的数据结构",
      "可以向结构内插入新区间",
      "每个区间都有一个标识",
      "差异：有些情况下（排班表、进程调度）区间不允许重叠",
      "而另外一些情况下（课表管理）区间可以重叠",
      "3.2 面向可复用性和可维护性的设计：IntervalSet<L>",
      "该节是本实验的核心部分",
      "3.2.1 IntervalSet<L>的共性操作",
      "插入新区间",
      "获取结构内所有区间的标志",
      "删除区间",
      "获取给定标志的区间的开始/结束时间（由于IntervalSet中不允许多个区间共享一个标记",
      "所以这个操作的结果是唯一的）",
      "将区间按开始时间排序，返回排好序的列表",
      "计算冲突时间的比例",
      "计算空闲时间的比例",
      "获取/设置该数据结构存放区间的最早开始时间/最晚结束时间",
      "3.2.2 局部共性特征的设计方案",
      "CommonIntervalSet实现局部共性特征",
      "个性特征使用装饰器模式拓展",
      "CommonIntervalSet描述了最基本的区间集合",
      "该ADT使用HashMap将区间的标志和区间信息（开始时间",
      "结束时间",
      "区间标志）联系起来",
      "并且保存区间的最早开始时间/最晚结束时间",
      "插入新区间/删除区间：直接修改HashMap即可",
      "获取区间标志：直接访问HashMap中keySet即可",
      "获取给定标志的区间的开始/结束时间：直接访问对应区间信息即可",
      "将区间按开始时间排序",
      "返回排好序的列表：重写比较器",
      "利用标准库的算法",
      "计算冲突/空闲时间的比例：扫描全部时间点",
      "并查看相邻两个时间点之间是否有区间",
      "再进行计算即可",
      "获取/设置该数据结构存放区间的最早开始时间/最晚结束时间：直接访问ADT内保存的 信息即可",
      "3.2.3 面向各应用的IntervalSet子类型设计（个性化特征的设计方案）",
      "添加一个装饰器NonOverlappableIntervalSet",
      "可以禁止重叠区间",
      "装饰器内只需要重写插入方法",
      "每次插入时",
      "扫描待插入区间对应的时间段",
      "查看是否有其他区间已经占用了此时间段",
      "面向排班表的类型设计DutyIntervalSet：增加了管理员工的功能以及随机生成排班表的功能",
      "3.3 面向可复用性和可维护性的设计：MultiIntervalSet<L>",
      "3.3.1 MultiIntervalSet<L>的共性操作",
      "插入新区间",
      "获取结构内所有区间的标志",
      "删除区间",
      "获取给定标志的所有区间",
      "将区间按开始时间排序，返回排好序的列表",
      "计算冲突时间的比例",
      "计算空闲时间的比例",
      "获取/设置该数据结构存放区间的最早开始时间/最晚结束时间",
      "计算两个MultiIntervalSet的相似性",
      "3.3.2 局部共性特征的设计方案",
      "计算相似性:枚举所有时间点,查看在任意两个相邻时间点间两个ADT是否存储了具有相同标记的区间信息",
      "若有则项结果中添加相应的值",
      "否则继续查看下一个时间段",
      "利用IntervalSet作为其rep",
      "将标签标号作为IntervalSet内区间的标签进行操作",
      "其他方法和IntervalSet中实现方案相同",
      "3.3.3 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）",
      "进程调度ProcessIntervalSet：增加随机调度和最短进程优先的调度方法.模拟课表CourseIntervalSet : 增加添加课程、选课和获取课表的方法",
      "3.4 面向复用的设计：L",
      "将IntervalSet和MultiIntervalSet中标签的类型泛化",
      "以适应不同场景",
      "3.5 可复用API设计",
      "API设计在各ADT内部",
      "3.5.1 计算相似度",
      "public double Similarity(MultiIntervalSet<L> set)",
      "枚举所有时间点,查看在任意两个相邻时间点间两个ADT是否存储了具有相同标记的区间信息",
      "若有则项结果中添加相应的值",
      "否则继续查看下一个时间段",
      "3.5.2 计算时间冲突比例",
      "public double calcConflictRatio()",
      "扫描全部时间点",
      "并查看相邻两个时间点之间是否有区间",
      "再进行计算",
      "3.5.3 计算空闲时间比例",
      "public double calcFreeTimeRatio()",
      "扫描全部时间点",
      "并查看相邻两个时间点之间是否有区间",
      "再进行计算",
      "3.6 应用设计与开发",
      "利用上述设计和实现的ADT，实现手册里要求的各项功能",
      "3.6.1 排班管理系统",
      "使用Calendar类管理日期",
      "将日期转化成长整型进行存储",
      "输出时再将长整数转化回日期进行输出",
      "存储员工姓名和对应Employee信息的对照表，方便进行查找",
      "由于不允许重名，所以这个方法是可行的",
      "剩下的功能可以直接调用DutyIntervalSet中的方法直接实现",
      "3.6.2 操作系统的进程调度管理系统",
      "将进程信息打包成Process类",
      "作为ProcessIntervalSet的标签",
      "所有功能均可以使用ProcessIntervalSet中的方法实现",
      "注意在这个应用中区间的总长度是不断变长的",
      "3.6.3 课表管理系统",
      "只需要管理一周的课程安排即可",
      "将一周分成35个时间段，对应35个可能的上课时间",
      "对这些时间分别编号并存进CourseIntervalSet即可",
      "其余功能可以借助CourseIntervalSet中的方法完成",
      "3.7 基于语法的数据读入",
      "修改“排班管理”应用以扩展该功能",
      "只需利用正则表达式分析文本文件",
      "具体如下：之后分别读取各组中的字符串即可",
      "其中需要特殊判断Roster部分和Period部分可能的重合情况",
      "3.8 应对面临的新变化",
      "3.8.1 变化1",
      "评估之前的设计是否可应对变化、代价如何、如何修改设计以应对变化",
      "可以应对变化",
      "将排班表中的rep改为MultiIntervalSet即可",
      "代价很小（两行代码）",
      "3.8.2 变化2",
      "评估之前的设计是否可应对变化、代价如何、如何修改设计以应对变化",
      "可以应对变化",
      "将MultiIntervalSet中rep的IntervalSet添加一层装饰器NonOverlappableIntervalSet即可",
      "代价很小（三行代码）",
      "3.9 Git仓库结构",
      "请在完成全部实验要求之后",
      "利用Git log指令或Git图形化客户端或GitHub上项目仓库的Insight页面",
      "给出你的仓库到目前为止的Object Graph",
      "尤其是区分清楚change分支和master分支所指向的位置",
      "4 实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "每次结束编程时，请向该表格中增加一行",
      "不要事后胡乱填写",
      "不要嫌烦",
      "该表格可帮助你汇总你在每个任务上付出的时间和精力",
      "发现自己不擅长的任务",
      "后续有意识的弥补",
      "时间段",
      "计划任务",
      "实际完成情况",
      "2021-06-28",
      "15:00-17:00",
      "设计装饰器结构，写IntervalSet相关测试用例",
      "完成，顺便实现了CommonIntervalSet",
      "2021-06-28",
      "19:00-20:00",
      "设计IntervalSet相关装饰器",
      "2021-06-30",
      "8:00-12:00",
      "设计CommonIntervalSet的接口",
      "并完成测试和实现",
      "2021-07-01",
      "8:00-24:00",
      "完成DutyRoster",
      "发现代码需要重构，未完成",
      "2021-07-02",
      "13:00-17:00",
      "实现并调试DutyRoster",
      "2021-07-02",
      "19:00-21:00",
      "实现并调试Process",
      "2021-07-03",
      "9:00-14:30",
      "实现并调试Course",
      "5 实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "计算日期/处理日期相关数据",
      "使用Calendar类",
      "正则表达式匹配",
      "百度相关内容，请教同学",
      "6 实验过程中收获的经验、教训、感想",
      "6.1 实验过程中收获的经验和教训",
      "(1) 过早优化是万恶之源，会把代码结构弄乱，并且会不断重构",
      "(2) 为了避免重构，需要在开发初期仔细设计好接口以及规范",
      "尽量降低代码耦合度",
      "6.2 针对以下方面的感受",
      "(1) 重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程",
      "你体会到二者有何差异？本实验设计的ADT在三个不同的应用场景下使用",
      "你是否体会到复用的好处？",
      "应用场景变化较多，需要考虑的情形较之于面向ADT编程要复杂",
      "复用的好处在于可以减少代码量，提高开发效率和维护性",
      "(2) 重新思考Lab2中的问题：为ADT撰写复杂的specification, invariants, RI, AF",
      "时刻注意ADT是否有rep exposure",
      "这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？",
      "意义：防止在复杂的应用场景中出现复杂且难以调试的错误",
      "(3) 之前你将别人提供的API用于自己的程序开发中",
      "本次实验你尝试着开发给别人使用的API",
      "是否能够体会到其中的难处和乐趣？",
      "难处在于需要精心设计API才可以使适用范围尽可能扩大",
      "乐趣在于API可以带来效率提升",
      "(4) 你之前在使用其他软件时",
      "应该体会过输入各种命令向系统发出指令",
      "本次实验你开发了一个解析器",
      "使用语法和正则表达式去解析输入文件并据此构造对象",
      "你对语法驱动编程有何感受？",
      "语法驱动编程比起传统方式较为高效，可以快速准确地读入数据",
      "(5) Lab1和Lab2的大部分工作都不是从0开始",
      "而是基于他人给出的设计方案和初始代码",
      "本次实验是你完全从0开始进行ADT的设计并用OOP实现",
      "经过五周之后",
      "你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？",
      "难度：设计规约",
      "设计欠周的规约在后期会带来不便",
      "且经常需要重新设计规约",
      "将已有设计推翻重来",
      "(6) “抽象”是计算机科学的核心概念之一",
      "也是ADT和OOP的精髓所在",
      "本实验的五个应用既不能完全抽象为同一个ADT",
      "也不是完全个性化",
      "如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、设计模式等技术完成最大程度的抽象和复用",
      "你有什么经验教训？",
      "经验：尽可能将共用方法放在上层，个性方法放在下层",
      "教训：1.使用恰当的设计模式",
      "不可滥用设计模式 2. 设计接口时考虑后期拓展的可能性",
      "尽量避免不得不重构代码的情况",
      "(7) 关于本实验的工作量、难度、deadline",
      "如果是在平常情况下",
      "工作量和难度均适中",
      "但是实验所在的时间段临近期末",
      "综合考虑来说时间非常不够用",
      "(8) 到目前为止你对《软件构造》课程的评价",
      "这门课讲了一些实用的编程技巧以及指导思想",
      "对以后编程开发有帮助",
      "但是课时被压缩之后内容不完整"
    ],
    "codes": [
      "String pEmployee = \"([a-zA-Z]+)\\\\{([a-zA-Z]+),(\\\\d{3}-\\\\d{4}-\\\\d{4})\\\\}\";",
      "String pPeriod = \"Period\\\\{(\\\\d{4})-(\\\\d{2})-(\\\\d{2}),(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\\\\}\";",
      "String pRoster = \"([a-zA-Z]+)\\\\{(\\\\d{4})-(\\\\d{2})-(\\\\d{2}),(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\\\\}\";",
      "Pattern patternEmployee = Pattern.compile(pEmployee);",
      "Pattern patternPeriod = Pattern.compile(pPeriod);",
      "Pattern patternRoster = Pattern.compile(pRoster);",
      "Matcher matcherEmployee = patternEmployee.matcher(buf);",
      "Matcher matcherPeriod = patternPeriod.matcher(buf);",
      "Matcher matcherRoster = patternRoster.matcher(buf);"
    ],
    "date": "2021-07-06",
    "text": "2021年春季学期计算学部《软件构造》课程\nLab 3实验报告\n郭子正\n1190201117\n1936601\n电子邮件\n1190201117@stu.hit.edu.cn\n手机号码\n18102152791\n1 实验目标概述\n2 实验环境配置\n3 实验过程\n3.1 待开发的三个应用场景\n3.2 面向可复用性和可维护性的设计：IntervalSet<L>\n3.2.1 IntervalSet<L>的共性操作\n3.2.2 局部共性特征的设计方案\n3.2.3 面向各应用的IntervalSet子类型设计（个性化特征的设计方案）\n3.3 面向可复用性和可维护性的设计：MultiIntervalSet<L>\n3.3.1 MultiIntervalSet<L>的共性操作\n3.3.2 局部共性特征的设计方案\n3.3.3 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）\n3.4 面向复用的设计：L\n3.5 可复用API设计\n3.5.1 计算相似度\n3.5.2 计算时间冲突比例\n3.5.3 计算空闲时间比例\n3.6 应用设计与开发\n3.6.1 排班管理系统\n3.6.2 操作系统的进程调度管理系统\n3.6.3 课表管理系统\n3.7 基于语法的数据读入\n3.8 应对面临的新变化\n3.8.1 变化1\n3.8.2 变化2\n3.9 Git仓库结构\n4 实验进度记录\n5 实验过程中遇到的困难与解决途径\n6 实验过程中收获的经验、教训、感想\n6.1 实验过程中收获的经验和教训\n6.2 针对以下方面的感受\n1 实验目标概述\n本次实验覆盖课程第 2、3 章的内容，目标是编写具有可复用性和可维护性 的软件，主要使用以下软件构造技术:\n⚫ 子类型、泛型、多态、重写、重载⚫ 继承、代理、组合⚫ 语法驱动的编程、正则表达式⚫ API设计、API复用\n本次实验给定了三个具体应用(值班表管理、操作系统进程调度管理、大学课表管理)，学生不是直接针对每个应用分别编程实现，而是通过 ADT 和泛型等抽象技术，开发一套可复用的 ADT 及其实现，充分考虑这些应用之间的相似性和差异性，使ADT有更大程度的复用(可复用性)和更容易面向各种变化(可维护性)。\n2 实验环境配置\n简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。\n特别是要记录配置过程中遇到的问题和困难，以及如何解决的。\n点击实验指导中的链接，创建仓库，克隆到本地进行开发即可。\n在这里给出你的GitHub Lab3仓库的URL地址（Lab3-1190201117）。\nhttps://github.com/ComputerScienceHIT/HIT-Lab3-1190201117\n3 实验过程\n请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\n3.1 待开发的三个应用场景\nDutyRosterApp：设计一个排班表。排班表不允许重叠。理论上也不允许有空白，但是这需要等到全部插入结束之后之后才能判断。\nProcessSchedule：设计一个进程调度器，可以将进程执行时间分割并重新排列，模拟处理器的进程调度。进程之间不可以重叠。\nCourseSchedule：设计一个课程表，可以添加课程并选课，课程之间可以重叠。由于每周课程都相同，于是只需要关注一周的课程情况即可。\n分析三个应用场景的异同，理解需求：它们在哪些方面有共性、哪些方面有差异。\n共性：都需要一个管理时间区间的数据结构，可以向结构内插入新区间。每个区间都有一个标识。\n差异：有些情况下（排班表、进程调度）区间不允许重叠，而另外一些情况下（课表管理）区间可以重叠。\n3.2 面向可复用性和可维护性的设计：IntervalSet<L>\n该节是本实验的核心部分。\n3.2.1 IntervalSet<L>的共性操作\n插入新区间\n获取结构内所有区间的标志\n删除区间\n获取给定标志的区间的开始/结束时间（由于IntervalSet中不允许多个区间共享一个标记，所以这个操作的结果是唯一的）\n将区间按开始时间排序，返回排好序的列表\n计算冲突时间的比例\n计算空闲时间的比例\n获取/设置该数据结构存放区间的最早开始时间/最晚结束时间\n3.2.2 局部共性特征的设计方案\nCommonIntervalSet实现局部共性特征，个性特征使用装饰器模式拓展。CommonIntervalSet描述了最基本的区间集合。该ADT使用HashMap将区间的标志和区间信息（开始时间，结束时间，区间标志）联系起来，并且保存区间的最早开始时间/最晚结束时间。\n插入新区间/删除区间：直接修改HashMap即可。\n获取区间标志：直接访问HashMap中keySet即可。\n获取给定标志的区间的开始/结束时间：直接访问对应区间信息即可。\n将区间按开始时间排序，返回排好序的列表：重写比较器，利用标准库的算法。\n计算冲突/空闲时间的比例：扫描全部时间点，并查看相邻两个时间点之间是否有区间，再进行计算即可。\n获取/设置该数据结构存放区间的最早开始时间/最晚结束时间：直接访问ADT内保存的 信息即可。\n3.2.3 面向各应用的IntervalSet子类型设计（个性化特征的设计方案）\n添加一个装饰器NonOverlappableIntervalSet，可以禁止重叠区间。装饰器内只需要重写插入方法。每次插入时，扫描待插入区间对应的时间段，查看是否有其他区间已经占用了此时间段。\n面向排班表的类型设计DutyIntervalSet：增加了管理员工的功能以及随机生成排班表的功能。\n3.3 面向可复用性和可维护性的设计：MultiIntervalSet<L>\n3.3.1 MultiIntervalSet<L>的共性操作\n插入新区间\n获取结构内所有区间的标志\n删除区间\n获取给定标志的所有区间\n将区间按开始时间排序，返回排好序的列表\n计算冲突时间的比例\n计算空闲时间的比例\n获取/设置该数据结构存放区间的最早开始时间/最晚结束时间\n计算两个MultiIntervalSet的相似性\n3.3.2 局部共性特征的设计方案\n计算相似性:枚举所有时间点,查看在任意两个相邻时间点间两个ADT是否存储了具有相同标记的区间信息，若有则项结果中添加相应的值，否则继续查看下一个时间段。\n利用IntervalSet作为其rep，将标签标号作为IntervalSet内区间的标签进行操作。其他方法和IntervalSet中实现方案相同。\n3.3.3 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）\n进程调度ProcessIntervalSet：增加随机调度和最短进程优先的调度方法.\n模拟课表CourseIntervalSet : 增加添加课程、选课和获取课表的方法\n3.4 面向复用的设计：L\n将IntervalSet和MultiIntervalSet中标签的类型泛化，以适应不同场景。\n3.5 可复用API设计\nAPI设计在各ADT内部。\n3.5.1 计算相似度\npublic double Similarity(MultiIntervalSet<L> set)\n枚举所有时间点,查看在任意两个相邻时间点间两个ADT是否存储了具有相同标记的区间信息，若有则项结果中添加相应的值，否则继续查看下一个时间段。\n3.5.2 计算时间冲突比例\npublic double calcConflictRatio()\n扫描全部时间点，并查看相邻两个时间点之间是否有区间，再进行计算。\n3.5.3 计算空闲时间比例\npublic double calcFreeTimeRatio()\n扫描全部时间点，并查看相邻两个时间点之间是否有区间，再进行计算。\n3.6 应用设计与开发\n利用上述设计和实现的ADT，实现手册里要求的各项功能。\n3.6.1 排班管理系统\n使用Calendar类管理日期，将日期转化成长整型进行存储，输出时再将长整数转化回日期进行输出。\n存储员工姓名和对应Employee信息的对照表，方便进行查找。由于不允许重名，所以这个方法是可行的。\n剩下的功能可以直接调用DutyIntervalSet中的方法直接实现。\n3.6.2 操作系统的进程调度管理系统\n将进程信息打包成Process类，作为ProcessIntervalSet的标签。所有功能均可以使用ProcessIntervalSet中的方法实现。注意在这个应用中区间的总长度是不断变长的。\n3.6.3 课表管理系统\n只需要管理一周的课程安排即可。将一周分成35个时间段，对应35个可能的上课时间。对这些时间分别编号并存进CourseIntervalSet即可。其余功能可以借助CourseIntervalSet中的方法完成。\n3.7 基于语法的数据读入\n修改“排班管理”应用以扩展该功能。\n只需利用正则表达式分析文本文件。具体如下：\n之后分别读取各组中的字符串即可。其中需要特殊判断Roster部分和Period部分可能的重合情况。\n3.8 应对面临的新变化\n3.8.1 变化1\n评估之前的设计是否可应对变化、代价如何、如何修改设计以应对变化\n可以应对变化，将排班表中的rep改为MultiIntervalSet即可。代价很小（两行代码）。\n3.8.2 变化2\n评估之前的设计是否可应对变化、代价如何、如何修改设计以应对变化\n可以应对变化。将MultiIntervalSet中rep的IntervalSet添加一层装饰器NonOverlappableIntervalSet即可。代价很小（三行代码）。\n3.9 Git仓库结构\n请在完成全部实验要求之后，利用Git log指令或Git图形化客户端或GitHub上项目仓库的Insight页面，给出你的仓库到目前为止的Object Graph，尤其是区分清楚change分支和master分支所指向的位置。\n4 实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。\n不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。\n时间段\n计划任务\n实际完成情况\n2021-06-28\n15:00-17:00\n设计装饰器结构，写IntervalSet相关测试用例\n完成，顺便实现了CommonIntervalSet\n2021-06-28\n19:00-20:00\n设计IntervalSet相关装饰器\n2021-06-30\n8:00-12:00\n设计CommonIntervalSet的接口，并完成测试和实现\n2021-07-01\n8:00-24:00\n完成DutyRoster\n发现代码需要重构，未完成\n2021-07-02\n13:00-17:00\n实现并调试DutyRoster\n2021-07-02\n19:00-21:00\n实现并调试Process\n2021-07-03\n9:00-14:30\n实现并调试Course\n5 实验过程中遇到的困难与解决途径\n遇到的难点\n解决途径\n计算日期/处理日期相关数据\n使用Calendar类\n正则表达式匹配\n百度相关内容，请教同学\n6 实验过程中收获的经验、教训、感想\n6.1 实验过程中收获的经验和教训\n(1) 过早优化是万恶之源，会把代码结构弄乱，并且会不断重构。\n(2) 为了避免重构，需要在开发初期仔细设计好接口以及规范。尽量降低代码耦合度。\n6.2 针对以下方面的感受\n(1) 重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在三个不同的应用场景下使用，你是否体会到复用的好处？\n应用场景变化较多，需要考虑的情形较之于面向ADT编程要复杂。复用的好处在于可以减少代码量，提高开发效率和维护性。\n(2) 重新思考Lab2中的问题：为ADT撰写复杂的specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？\n意义：防止在复杂的应用场景中出现复杂且难以调试的错误。\n(3) 之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？\n难处在于需要精心设计API才可以使适用范围尽可能扩大。\n乐趣在于API可以带来效率提升。\n(4) 你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？\n语法驱动编程比起传统方式较为高效，可以快速准确地读入数据。\n(5) Lab1和Lab2的大部分工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过五周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？\n难度：设计规约。设计欠周的规约在后期会带来不便，且经常需要重新设计规约，将已有设计推翻重来。\n(6) “抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的五个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？\n经验：尽可能将共用方法放在上层，个性方法放在下层。\n教训：1.使用恰当的设计模式，不可滥用设计模式 2. 设计接口时考虑后期拓展的可能性，尽量避免不得不重构代码的情况。\n(7) 关于本实验的工作量、难度、deadline。\n如果是在平常情况下，工作量和难度均适中，但是实验所在的时间段临近期末，综合考虑来说时间非常不够用。\n(8) 到目前为止你对《软件构造》课程的评价。\n这门课讲了一些实用的编程技巧以及指导思想，对以后编程开发有帮助。但是课时被压缩之后内容不完整。\n"
  },
  {
    "head": "Type safety: Unchecked cast from Object to...",
    "paragraphs": [
      "原本代码如下：",
      "会有警告。修改后在强制类型转换部分加入通配符’？’延迟类型决定，最后是",
      "问题解决。"
    ],
    "sentences": [
      "原本代码如下：会有警告",
      "修改后在强制类型转换部分加入通配符’？’延迟类型决定，最后是",
      "问题解决"
    ],
    "codes": [
      "Vertex<L> v = (Vertex<L>) obj;\nif(!v.getMyName().equals(this.vertexName))\n    return false;\n",
      "var v = (Vertex<?>) obj;\nif(!v.getMyName().equals(this.vertexName))\n    return false;\n"
    ],
    "date": "2021-06-06",
    "text": "原本代码如下：\n会有警告。修改后在强制类型转换部分加入通配符’？’延迟类型决定，最后是\n问题解决。\n"
  },
  {
    "head": "关于java中基本类型是不可变（immutable）的一些认识",
    "paragraphs": [
      "对immutable的认知，更强调对本体的看法。基本类型变量改变之后，变量相当于“换了一个东西”，新得到的结果与旧结果并无关系。而mutable的数据类型在部分改变之后，其作为整体仍然和改变之前保持一定关系（如某人更改姓名后，虽然姓名发生了更改，但和改名之前是同一个人）。"
    ],
    "sentences": [
      "对immutable的认知，更强调对本体的看法",
      "基本类型变量改变之后",
      "变量相当于“换了一个东西”",
      "新得到的结果与旧结果并无关系",
      "而mutable的数据类型在部分改变之后",
      "其作为整体仍然和改变之前保持一定关系（如某人更改姓名后",
      "虽然姓名发生了更改",
      "但和改名之前是同一个人）"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "对immutable的认知，更强调对本体的看法。基本类型变量改变之后，变量相当于“换了一个东西”，新得到的结果与旧结果并无关系。而mutable的数据类型在部分改变之后，其作为整体仍然和改变之前保持一定关系（如某人更改姓名后，虽然姓名发生了更改，但和改名之前是同一个人）。\n"
  },
  {
    "head": "关于HashSet.contains的实现",
    "paragraphs": [
      "其中labels返回一个HashSet。",
      "我们惊讶地发现输出如下：",
      "lalala0",
      "[lalala0, lololo0]",
      "false",
      "这说明intervalSet.labels().contains()不认为labelInADT是其中的成员。但是在程序中，我们已经重载过equals()方法。于是遇到了问题。",
      "解决办法：注意到HashSet也会利用hashCode方法比较成员，所以需要重写hashCode方法。",
      "添加之后问题迎刃而解。"
    ],
    "sentences": [
      "其中labels返回一个HashSet",
      "我们惊讶地发现输出如下：lalala0",
      "[lalala0, lololo0]",
      "false",
      "这说明intervalSet.labels().contains()不认为labelInADT是其中的成员",
      "但是在程序中，我们已经重载过equals()方法",
      "于是遇到了问题",
      "解决办法：注意到HashSet也会利用hashCode方法比较成员",
      "所以需要重写hashCode方法",
      "添加之后问题迎刃而解"
    ],
    "codes": [
      "程序的一部分如下：System.out.println(labelInADT);\nSystem.out.println(intervalSet.labels());\nSystem.out.println(intervalSet.labels().contains(labelInADT));\n",
      "\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash(label,id);\n\t}\n"
    ],
    "date": "2021-07-01",
    "text": "其中labels返回一个HashSet。\n我们惊讶地发现输出如下：\nlalala0\n[lalala0, lololo0]\nfalse\n这说明intervalSet.labels().contains()不认为labelInADT是其中的成员。但是在程序中，我们已经重载过equals()方法。于是遇到了问题。\n解决办法：注意到HashSet也会利用hashCode方法比较成员，所以需要重写hashCode方法。\n添加之后问题迎刃而解。\n"
  },
  {
    "head": "哈工大信息安全概论-坑爹的作业-异想天开",
    "paragraphs": [
      "非常坑爹的作业。希望学弟学妹们不要浪费时间在这个上面，多把精力放在有意义的工作上，实在不行多睡会觉也是好的。",
      "作业1，密码简单破译",
      "“二八”妙龄写密码，看谁聪明“爱死他”。密文：766C7273626F76706A5E6F715F7271766C72706D626B71716C6C71666A62y o u v e r y s m a r t b u t y o u s p e n t t o o t i m e二八=十六，爱死他=ASCII",
      "按十六进制查ascii表，移位得到。移动的位数比较小，尝试一下即可得到。",
      "作业2 唐诗谜 无题警示：锦瑟无端五十弦，一弦一柱思华年，千帆远眺蝴蝶梦，万国赛马撩人眼。沧海月明珠有泪，蓝田日暖玉生烟，此情可待成追忆，他年饮酒泪涟涟。密文：24205 29992 26204 26799 36864 34685 34687提示：一句唐诗明文是什么；庄生晓梦迷蝴蝶说说你的解题思路：万国马=万国码，饮酒=减9",
      "查Unicode表即可。作业3 黛丝打靶 密文：U2FsdGVkX18HM4A1Xow2e412F0IMPUSDVw/lNeTEtwDYAjSHsx61CQ== 日落西山红霞飞，战士打靶把营归。五发中靶二十二，黛丝秘诀子弹飞。明文是什么；you are very clever说说你的解题思路：战士打靶是一首歌，其中有一句",
      "mi so ra mi so, ra so mi do re",
      "写成简谱是35635，65312",
      "五发中靶二十二=五个数加起来为22，选35635黛丝=DES解密即可。",
      "注意：在线解密网站版本不一，使用http://www.jsons.cn/desencrypt/可以得到答案。作业4：迷人的黛丝 打靶通关密语日落西山红霞飞，战士打靶把营归。张三成绩二十二，李四十七把牛吹。我的成绩比你好，先后起来你悲催；美女黛丝抿嘴笑，再来一次子弹飞。密文：U2FsdGVkX1+YN8tsns+7jvoarVmsqg316iBBvFP3ZemnrYEOGsI6bH5CvIVFSN0Ypx1ka4fSPGj7cDvg81wU8BlnJYoDdhvl83cBIQDHk0JQnpaKXU3ZRA==明文是什么；You are amazing说说你的解题思路：先后悲催->作差->后-先->65312-35635=29677作为第一次密钥解得xxaqdl(p25-12-bstring)U2FsdGVkX199XCqgBzG3McJ1NuWuuPclqBS9lekxPpE=xxaqdl=信息安全导论 p25-12-bstring=第十二行的串=01000011第二次解密得到答案。"
    ],
    "sentences": [
      "非常坑爹的作业",
      "希望学弟学妹们不要浪费时间在这个上面",
      "多把精力放在有意义的工作上",
      "实在不行多睡会觉也是好的",
      "作业1，密码简单破译",
      "“二八”妙龄写密码，看谁聪明“爱死他”",
      "密文：766C7273626F76706A5E6F715F7271766C72706D626B71716C6C71666A62y o u v e r y s m a r t b u t y o u s p e n t t o o t i m e二八=十六",
      "爱死他=ASCII",
      "按十六进制查ascii表，移位得到",
      "移动的位数比较小，尝试一下即可得到",
      "作业2 唐诗谜 无题警示：锦瑟无端五十弦",
      "一弦一柱思华年",
      "千帆远眺蝴蝶梦",
      "万国赛马撩人眼",
      "沧海月明珠有泪",
      "蓝田日暖玉生烟",
      "此情可待成追忆",
      "他年饮酒泪涟涟",
      "密文：24205 29992 26204 26799 36864 34685 34687提示：一句唐诗明文是什么；庄生晓梦迷蝴蝶说说你的解题思路：万国马=万国码",
      "饮酒=减9",
      "查Unicode表即可",
      "作业3 黛丝打靶 密文：U2FsdGVkX18HM4A1Xow2e412F0IMPUSDVw/lNeTEtwDYAjSHsx61CQ== 日落西山红霞飞",
      "战士打靶把营归",
      "五发中靶二十二，黛丝秘诀子弹飞",
      "明文是什么；you are very clever说说你的解题思路：战士打靶是一首歌",
      "其中有一句",
      "mi so ra mi so, ra so mi do re",
      "写成简谱是35635，65312",
      "五发中靶二十二=五个数加起来为22",
      "选35635黛丝=DES解密即可",
      "注意：在线解密网站版本不一",
      "使用http://www.jsons.cn/desencrypt/可以得到答案",
      "作业4：迷人的黛丝 打靶通关密语日落西山红霞飞",
      "战士打靶把营归",
      "张三成绩二十二，李四十七把牛吹",
      "我的成绩比你好",
      "先后起来你悲催；美女黛丝抿嘴笑",
      "再来一次子弹飞",
      "密文：U2FsdGVkX1+YN8tsns+7jvoarVmsqg316iBBvFP3ZemnrYEOGsI6bH5CvIVFSN0Ypx1ka4fSPGj7cDvg81wU8BlnJYoDdhvl83cBIQDHk0JQnpaKXU3ZRA==明文是什么；You are amazing说说你的解题思路：先后悲催->作差->后-先->65312-35635=29677作为第一次密钥解得xxaqdl(p25-12-bstring)U2FsdGVkX199XCqgBzG3McJ1NuWuuPclqBS9lekxPpE=xxaqdl=信息安全导论 p25-12-bstring=第十二行的串=01000011第二次解密得到答案"
    ],
    "codes": [],
    "date": "2021-05-25",
    "text": "非常坑爹的作业。希望学弟学妹们不要浪费时间在这个上面，多把精力放在有意义的工作上，实在不行多睡会觉也是好的。\n作业1，密码简单破译\n“二八”妙龄写密码，看谁聪明“爱死他”。密文：766C7273626F76706A5E6F715F7271766C72706D626B71716C6C71666A62y o u v e r y s m a r t b u t y o u s p e n t t o o t i m e二八=十六，爱死他=ASCII\n按十六进制查ascii表，移位得到。移动的位数比较小，尝试一下即可得到。\n作业2 唐诗谜 无题警示：锦瑟无端五十弦，一弦一柱思华年，千帆远眺蝴蝶梦，万国赛马撩人眼。沧海月明珠有泪，蓝田日暖玉生烟，此情可待成追忆，他年饮酒泪涟涟。密文：24205 29992 26204 26799 36864 34685 34687提示：一句唐诗明文是什么；庄生晓梦迷蝴蝶说说你的解题思路：万国马=万国码，饮酒=减9\n查Unicode表即可。作业3 黛丝打靶 密文：U2FsdGVkX18HM4A1Xow2e412F0IMPUSDVw/lNeTEtwDYAjSHsx61CQ== 日落西山红霞飞，战士打靶把营归。五发中靶二十二，黛丝秘诀子弹飞。明文是什么；you are very clever说说你的解题思路：战士打靶是一首歌，其中有一句\nmi so ra mi so, ra so mi do re\n写成简谱是35635，65312\n五发中靶二十二=五个数加起来为22，选35635黛丝=DES解密即可。\n注意：在线解密网站版本不一，使用http://www.jsons.cn/desencrypt/可以得到答案。作业4：迷人的黛丝 打靶通关密语日落西山红霞飞，战士打靶把营归。张三成绩二十二，李四十七把牛吹。我的成绩比你好，先后起来你悲催；美女黛丝抿嘴笑，再来一次子弹飞。密文：U2FsdGVkX1+YN8tsns+7jvoarVmsqg316iBBvFP3ZemnrYEOGsI6bH5CvIVFSN0Ypx1ka4fSPGj7cDvg81wU8BlnJYoDdhvl83cBIQDHk0JQnpaKXU3ZRA==明文是什么；You are amazing说说你的解题思路：先后悲催->作差->后-先->65312-35635=29677作为第一次密钥解得xxaqdl(p25-12-bstring)U2FsdGVkX199XCqgBzG3McJ1NuWuuPclqBS9lekxPpE=xxaqdl=信息安全导论 p25-12-bstring=第十二行的串=01000011第二次解密得到答案。\n"
  },
  {
    "head": "哈工大软件构造 第二次实验报告",
    "paragraphs": [
      "2021年春季学期",
      "计算学部《软件构造》课程",
      "Lab 2实验报告",
      "郭子正",
      "1190201117",
      "1936601",
      "电子邮件",
      "1190201117@stu.hit.edu.cn",
      "手机号码",
      "18102152791",
      "2 实验环境配置",
      "3 实验过程",
      "3.1 Poetic Walks",
      "3.1.1 Get the code and prepare Git repository",
      "3.1.2 Problem 1: Test Graph <String>",
      "3.1.3 Problem 2: Implement Graph <String>",
      "3.1.3.1 Implement ConcreteEdgesGraph",
      "3.1.3.2 Implement ConcreteVerticesGraph",
      "3.1.4 Problem 3: Implement generic Graph<L>",
      "3.1.4.1 Make the implementations generic",
      "3.1.4.2 Implement Graph.empty()",
      "3.1.5 Problem 4: Poetic walks",
      "3.1.5.1 Test GraphPoet",
      "3.1.5.2 Implement GraphPoet",
      "3.1.5.3 Graph poetry slam",
      "3.1.6 使用Eclemma检查测试的代码覆盖度",
      "3.1.7 Before you’re done",
      "3.2 Re-implement the Social Network in Lab1",
      "3.2.1 FriendshipGraph类",
      "3.2.2 Person类",
      "3.2.3 客户端main()",
      "3.2.4 测试用例",
      "3.2.5 提交至Git仓库",
      "4 实验进度记录",
      "5 实验过程中遇到的困难与解决途径",
      "6 实验过程中收获的经验、教训、感想",
      "6.1 实验过程中收获的经验和教训",
      "6.2 针对以下方面的感受",
      "1 实验目标概述",
      "本次实验训练抽象数据类型(ADT)的设计、规约、测试，并使用面向对象 编程(OOP)技术实现 ADT。具体来说:",
      "⚫ 针对给定的应用问题，从问题描述中识别所需的 ADT;",
      "⚫ 设计 ADT 规约(pre-condition、post-condition)并评估规约的质量;",
      "⚫ 根据 ADT 的规约设计测试用例;",
      "⚫ ADT的泛型化;",
      "⚫ 根据规约设计 ADT 的多种不同的实现;针对每种实现，设计其表示",
      "(representation)、表示不变性(rep invariant)、抽象过程(abstraction",
      "function)",
      "⚫ 使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表",
      "示泄露(rep exposure);",
      "⚫ 测试 ADT 的实现并评估测试的覆盖度;",
      "⚫ 使用 ADT 及其实现，为应用问题开发程序;",
      "⚫ 在测试代码中，能够写出 testing strategy 并据此设计测试用例。",
      "2 实验环境配置",
      "简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。",
      "特别是要记录配置过程中遇到的问题和困难，以及如何解决的。",
      "由于无法访问MIT代码仓库，于是从实验指导上指定的地址下载代码。之后从GitHub克隆空项目到本地，将代码添加进工程。最初遇到错误，经检查发现是MIT练习题的文件路径和实验报告不一致、添加进工程时未完全更改导致的。",
      "在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）。",
      "3 实验过程",
      "请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。",
      "3.1 Poetic Walks",
      "利用前期建立好的Graph类实现一个小应用，先由给定的语料库建立一张有向图，再用另外给定的输入和建立好的图，根据题目要求生成新的文本。",
      "3.1.1 Get the code and prepare Git repository",
      "由于无法访问MIT的代码仓库，所以改从另外指定的地址下载。远程新建仓库之后，克隆到本地，并将下载的代码添加进去。用eclipse配置好开发环境即可。",
      "3.1.2 Problem 1: Test Graph <String>",
      "以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。",
      "写测试用例。每个测试方法都首先生成了一张图，再用各种方法进行测试。",
      "testAdd：新建一张图，每增添一个点都检测add()的返回值，并且用查看器检查是否真的增加了一个顶点。随机移除某些点再重新添加，重复添加某些点并查看这些情况下add()返回值是否符合预期，对图的修改是否达到预期。",
      "testSet()：随机设置边权，调用Set()时检查返回值是否符合预期、是否真的对边进行了修改（weight>0,weight<0，weight=0）,去除某些边、重复添加某些边再进行测试。",
      "testRemove()：建好图之后删除某些点（有些点删除不止一次），查看每次删除时函数的返回值，用查看器查看对图的修改是否符合预期。",
      "testVertices()，testSources()，testTargets()：动态维护答案，对图不断修改的同时对预期答案也不断修改，随时调用Vertices()查看图中顶点情况是否符合预期。",
      "3.1.3 Problem 2: Implement Graph <String>",
      "以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。",
      "3.1.3.1 Implement ConcreteEdgesGraph",
      "建立Edge类：",
      "SPEC,AF,RI,REP如下：",
      "主要维护起点、终点和权值。重写了toString，equals，hashCode方法。",
      "实现ConcreteEdgesGraph类：",
      "SPEC,AF,RI,REP如下：",
      "set实现思路：首先确定weight的值以确定行为，如果遇到非法输入直接返回0；如果weight=0且待删除的边的任意顶点不存在则什么也不干，返回0；如果weight>0，先删除旧边（没有则不删）再添加新边（如果顶点不在图中也自动添加）。",
      "remove实现思路：搜边并删除，没有则不删。",
      "source，targets实现思路：遍历edges并返回符合要求的边的相应顶点即可。",
      "3.1.3.2 Implement ConcreteVerticesGraph",
      "Vertex类实现思路：",
      "SPEC,AF,RI,REP如下：",
      "重写了toString，equals，hashCode方法。该类通过存放顶点名称和出边来存放顶点信息。",
      "ConcreteVerticesGraph类实现思路：",
      "SPEC,AF,RI,REP如下：",
      "add设计思路：直接添加顶点。",
      "set设计思路：非法输入直接返回；添加边时先保证顶点都在图中（如果不是先添加缺失的顶点），再修改这条边出发的源头（from）的出边信息。删除边时直接修改源头顶点的出边信息。",
      "remove设计思路和set设计思路有重叠，是它的一部分。",
      "sources设计思路：扫描全部顶点，找到符合要求的部分并输出。",
      "targets设计思路：直接返回传入顶点的出边信息即可。",
      "3.1.4 Problem 3: Implement generic Graph<L>",
      "3.1.4.1 Make the implementations generic",
      "将对应的String替换成L即可。",
      "3.1.4.2 Implement Graph.empty()",
      "3.1.5 Problem 4: Poetic walks",
      "3.1.5.1 Test GraphPoet",
      "测试几种情况：文件不存在、文件为空、文件只包含大写字母、只包含小写字母、正常的英文句子、全部为符号。",
      "3.1.5.2 Implement GraphPoet",
      "直接按题目要求模拟即可。建图时根据每个先后关系确定边，获取边的权值，再将对应边的权值加一。生成诗句时在图中搜寻对应边即可。如果有多个中间顶点满足权值加和最大的条件，任意取一个中间顶点即可。",
      "3.1.5.3 Graph poetry slam",
      "设计语料库，显示“三点几，饮茶先”。",
      "3.1.6 使用Eclemma检查测试的代码覆盖度",
      "3.1.7 Before you’re done",
      "请按照http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done的说明，检查你的程序。",
      "如何通过Git提交当前版本到GitHub上你的Lab2仓库。",
      "git add->commit->push",
      "在这里给出你的项目的目录结构树状示意图。",
      "3.2 Re-implement the Social Network in Lab1",
      "建立一个有向图模型表示人际关系。人与人之间的距离用有向图中从一 方到达另一方经过的最小边数确定。并且人们的名字不能重复。",
      "3.2.1 FriendshipGraph类",
      "直接保存人的集合和表示人际关系的有向图。用BFS来计算人与人之间的距离。",
      "3.2.2 Person类",
      "保存姓名，提供获取姓名的方法。",
      "3.2.3 客户端main()",
      "建立一张FriendshipGraph，运行实验一的样例。",
      "3.2.4 测试用例",
      "3.2.5 提交至Git仓库",
      "如何通过Git提交当前版本到GitHub上你的Lab3仓库。",
      "git add->commit->push",
      "在这里给出你的项目的目录结构树状示意图。",
      "4 实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。",
      "不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。",
      "时间段；",
      "计划任务",
      "实际完成情况",
      "2021-06-01",
      "13：45-15：00",
      "开始写Graph<String>测试用例",
      "完成一半",
      "2021-06-03",
      "22：45-23：00",
      "继续写Graph<String>测试用例",
      "按计划完成",
      "2021-06-04",
      "19:00-22:16",
      "写ConcreteEdgesGraph的测试用例，并实现这个类",
      "按计划完成",
      "2021-06-04",
      "22:30-24:00",
      "设计Vertex类的spec",
      "按计划完成",
      "2021-06-05",
      "10:00-18:39",
      "继续完成ConcreteEdgesGraph",
      "本应该很早就完成，结果写到后面发现spec设计有问题，推倒重写反复三次。最终完成。",
      "2021-06-05",
      "19:00-20:00",
      "完成3.1",
      "按计划完成",
      "2021-06-05",
      "22:00-24:00",
      "完成3.2",
      "发现不能有警告，但是equals方法用到了强制类型转换，而object转其他类似乎必定会警告，遂百思不得其解。十二点钟终于百度到答案。",
      "2021-06-06",
      "21:00-22:00",
      "完成MIT Problem Set上的题目",
      "按计划完成",
      "2021-06-08",
      "13：45-15：30",
      "完成剩下的内容",
      "按计划完成",
      "5 实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "object进行强制类型转换会弹出unchecked cast警告",
      "百度，虽然大多数答案都是互相抄的，还都不管用，但是终于找到了能用的方案",
      "无法识别某个文件夹是一个包",
      "问学长被骂之后发现，IDE设置中将该文件夹排除了。更改设置即可。",
      "6 实验过程中收获的经验、教训、感想",
      "6.1 实验过程中收获的经验和教训",
      "工程进行之初应详尽考虑并设计规约，以避免之后返工的情况。",
      "6.2 针对以下方面的感受",
      "(1) 面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？",
      "面向ADT编程更加灵活，可以适应不同场合，仅需要对代码进行微小改动。",
      "(2) 使用泛型和不使用泛型的编程，对你来说有何差异？",
      "使用泛型可以使ADT不依赖于实际类型，增大了ADT的适用范围，减小了工作量。",
      "(3) 在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？",
      "遵循了“早出错”原则，可以尽早发现错误并且改正，减小损失。我可以适应这种方式。",
      "(4) P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？",
      "这种复用可以减少开发成本：当ADT应用在不同场合时仅需要进行微小调整，从而降低开发成本；发现ADT出错时仅需要对ADT本身进行调整而无需对每个具体应用都进行改动，从而降低调试成本。",
      "(5) P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？",
      "除了没在实验指导里发现P3之外感觉都还好。",
      "(6) 为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "这些工作的给ADT定义了统一的内部规范，方便今后持续开发，防止忘记ADT最初设计的细节以及相应方法。时刻检查rep暴露可以提高安全性和稳定性。我愿意。",
      "(7) 关于本实验的工作量、难度、deadline。",
      "适中。",
      "(8) 《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "还是应该多写代码。"
    ],
    "sentences": [
      "2021年春季学期",
      "计算学部《软件构造》课程",
      "Lab 2实验报告",
      "郭子正",
      "1190201117",
      "1936601",
      "电子邮件",
      "1190201117@stu.hit.edu.cn",
      "手机号码",
      "18102152791",
      "2 实验环境配置",
      "3 实验过程",
      "3.1 Poetic Walks",
      "3.1.1 Get the code and prepare Git repository",
      "3.1.2 Problem 1: Test Graph <String>",
      "3.1.3 Problem 2: Implement Graph <String>",
      "3.1.3.1 Implement ConcreteEdgesGraph",
      "3.1.3.2 Implement ConcreteVerticesGraph",
      "3.1.4 Problem 3: Implement generic Graph<L>",
      "3.1.4.1 Make the implementations generic",
      "3.1.4.2 Implement Graph.empty()",
      "3.1.5 Problem 4: Poetic walks",
      "3.1.5.1 Test GraphPoet",
      "3.1.5.2 Implement GraphPoet",
      "3.1.5.3 Graph poetry slam",
      "3.1.6 使用Eclemma检查测试的代码覆盖度",
      "3.1.7 Before you’re done",
      "3.2 Re-implement the Social Network in Lab1",
      "3.2.1 FriendshipGraph类",
      "3.2.2 Person类",
      "3.2.3 客户端main()",
      "3.2.4 测试用例",
      "3.2.5 提交至Git仓库",
      "4 实验进度记录",
      "5 实验过程中遇到的困难与解决途径",
      "6 实验过程中收获的经验、教训、感想",
      "6.1 实验过程中收获的经验和教训",
      "6.2 针对以下方面的感受",
      "1 实验目标概述",
      "本次实验训练抽象数据类型(ADT)的设计、规约、测试",
      "并使用面向对象 编程(OOP)技术实现 ADT",
      "具体来说:⚫ 针对给定的应用问题",
      "从问题描述中识别所需的 ADT;⚫ 设计 ADT 规约(pre-condition、post-condition)并评估规约的质量;⚫ 根据 ADT 的规约设计测试用例;⚫ ADT的泛型化;⚫ 根据规约设计 ADT 的多种不同的实现;针对每种实现",
      "设计其表示",
      "(representation)、表示不变性(rep invariant)、抽象过程(abstraction",
      "function)",
      "⚫ 使用 OOP 实现 ADT",
      "并判定表示不变性是否违反、各实现是否存在表",
      "示泄露(rep exposure);⚫ 测试 ADT 的实现并评估测试的覆盖度;⚫ 使用 ADT 及其实现",
      "为应用问题开发程序;⚫ 在测试代码中",
      "能够写出 testing strategy 并据此设计测试用例",
      "2 实验环境配置",
      "简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图",
      "特别是要记录配置过程中遇到的问题和困难，以及如何解决的",
      "由于无法访问MIT代码仓库",
      "于是从实验指导上指定的地址下载代码",
      "之后从GitHub克隆空项目到本地，将代码添加进工程",
      "最初遇到错误",
      "经检查发现是MIT练习题的文件路径和实验报告不一致、添加进工程时未完全更改导致的",
      "在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）",
      "3 实验过程",
      "请仔细对照实验手册",
      "针对三个问题中的每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）",
      "3.1 Poetic Walks",
      "利用前期建立好的Graph类实现一个小应用",
      "先由给定的语料库建立一张有向图",
      "再用另外给定的输入和建立好的图",
      "根据题目要求生成新的文本",
      "3.1.1 Get the code and prepare Git repository",
      "由于无法访问MIT的代码仓库，所以改从另外指定的地址下载",
      "远程新建仓库之后，克隆到本地，并将下载的代码添加进去",
      "用eclipse配置好开发环境即可",
      "3.1.2 Problem 1: Test Graph <String>",
      "以下各部分",
      "请按照MIT页面上相应部分的要求",
      "逐项列出你的设计和实现思路/过程/结果",
      "写测试用例",
      "每个测试方法都首先生成了一张图，再用各种方法进行测试",
      "testAdd：新建一张图",
      "每增添一个点都检测add()的返回值",
      "并且用查看器检查是否真的增加了一个顶点",
      "随机移除某些点再重新添加",
      "重复添加某些点并查看这些情况下add()返回值是否符合预期",
      "对图的修改是否达到预期",
      "testSet()：随机设置边权",
      "调用Set()时检查返回值是否符合预期、是否真的对边进行了修改（weight>0,weight<0",
      "weight=0）,去除某些边、重复添加某些边再进行测试",
      "testRemove()：建好图之后删除某些点（有些点删除不止一次）",
      "查看每次删除时函数的返回值",
      "用查看器查看对图的修改是否符合预期",
      "testVertices()",
      "testSources()",
      "testTargets()：动态维护答案",
      "对图不断修改的同时对预期答案也不断修改",
      "随时调用Vertices()查看图中顶点情况是否符合预期",
      "3.1.3 Problem 2: Implement Graph <String>",
      "以下各部分",
      "请按照MIT页面上相应部分的要求",
      "逐项列出你的设计和实现思路/过程/结果",
      "3.1.3.1 Implement ConcreteEdgesGraph",
      "建立Edge类：SPEC,AF,RI,REP如下：主要维护起点、终点和权值",
      "重写了toString，equals，hashCode方法",
      "实现ConcreteEdgesGraph类：SPEC,AF,RI,REP如下：set实现思路：首先确定weight的值以确定行为",
      "如果遇到非法输入直接返回0；如果weight=0且待删除的边的任意顶点不存在则什么也不干",
      "返回0；如果weight>0",
      "先删除旧边（没有则不删）再添加新边（如果顶点不在图中也自动添加）",
      "remove实现思路：搜边并删除，没有则不删",
      "source",
      "targets实现思路：遍历edges并返回符合要求的边的相应顶点即可",
      "3.1.3.2 Implement ConcreteVerticesGraph",
      "Vertex类实现思路：SPEC,AF,RI,REP如下：重写了toString",
      "equals",
      "hashCode方法",
      "该类通过存放顶点名称和出边来存放顶点信息",
      "ConcreteVerticesGraph类实现思路：SPEC,AF,RI,REP如下：add设计思路：直接添加顶点",
      "set设计思路：非法输入直接返回；添加边时先保证顶点都在图中（如果不是先添加缺失的顶点）",
      "再修改这条边出发的源头（from）的出边信息",
      "删除边时直接修改源头顶点的出边信息",
      "remove设计思路和set设计思路有重叠，是它的一部分",
      "sources设计思路：扫描全部顶点",
      "找到符合要求的部分并输出",
      "targets设计思路：直接返回传入顶点的出边信息即可",
      "3.1.4 Problem 3: Implement generic Graph<L>",
      "3.1.4.1 Make the implementations generic",
      "将对应的String替换成L即可",
      "3.1.4.2 Implement Graph.empty()",
      "3.1.5 Problem 4: Poetic walks",
      "3.1.5.1 Test GraphPoet",
      "测试几种情况：文件不存在、文件为空、文件只包含大写字母、只包含小写字母、正常的英文句子、全部为符号",
      "3.1.5.2 Implement GraphPoet",
      "直接按题目要求模拟即可",
      "建图时根据每个先后关系确定边",
      "获取边的权值",
      "再将对应边的权值加一",
      "生成诗句时在图中搜寻对应边即可",
      "如果有多个中间顶点满足权值加和最大的条件",
      "任意取一个中间顶点即可",
      "3.1.5.3 Graph poetry slam",
      "设计语料库，显示“三点几，饮茶先”",
      "3.1.6 使用Eclemma检查测试的代码覆盖度",
      "3.1.7 Before you’re done",
      "请按照http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done的说明",
      "检查你的程序",
      "如何通过Git提交当前版本到GitHub上你的Lab2仓库",
      "git add->commit->push",
      "在这里给出你的项目的目录结构树状示意图",
      "3.2 Re-implement the Social Network in Lab1",
      "建立一个有向图模型表示人际关系",
      "人与人之间的距离用有向图中从一 方到达另一方经过的最小边数确定",
      "并且人们的名字不能重复",
      "3.2.1 FriendshipGraph类",
      "直接保存人的集合和表示人际关系的有向图",
      "用BFS来计算人与人之间的距离",
      "3.2.2 Person类",
      "保存姓名，提供获取姓名的方法",
      "3.2.3 客户端main()",
      "建立一张FriendshipGraph，运行实验一的样例",
      "3.2.4 测试用例",
      "3.2.5 提交至Git仓库",
      "如何通过Git提交当前版本到GitHub上你的Lab3仓库",
      "git add->commit->push",
      "在这里给出你的项目的目录结构树状示意图",
      "4 实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "每次结束编程时，请向该表格中增加一行",
      "不要事后胡乱填写",
      "不要嫌烦",
      "该表格可帮助你汇总你在每个任务上付出的时间和精力",
      "发现自己不擅长的任务",
      "后续有意识的弥补",
      "时间段；计划任务",
      "实际完成情况",
      "2021-06-01",
      "13：45-15：00",
      "开始写Graph<String>测试用例",
      "完成一半",
      "2021-06-03",
      "22：45-23：00",
      "继续写Graph<String>测试用例",
      "按计划完成",
      "2021-06-04",
      "19:00-22:16",
      "写ConcreteEdgesGraph的测试用例",
      "并实现这个类",
      "按计划完成",
      "2021-06-04",
      "22:30-24:00",
      "设计Vertex类的spec",
      "按计划完成",
      "2021-06-05",
      "10:00-18:39",
      "继续完成ConcreteEdgesGraph",
      "本应该很早就完成",
      "结果写到后面发现spec设计有问题",
      "推倒重写反复三次",
      "最终完成",
      "2021-06-05",
      "19:00-20:00",
      "完成3.1",
      "按计划完成",
      "2021-06-05",
      "22:00-24:00",
      "完成3.2",
      "发现不能有警告",
      "但是equals方法用到了强制类型转换",
      "而object转其他类似乎必定会警告",
      "遂百思不得其解",
      "十二点钟终于百度到答案",
      "2021-06-06",
      "21:00-22:00",
      "完成MIT Problem Set上的题目",
      "按计划完成",
      "2021-06-08",
      "13：45-15：30",
      "完成剩下的内容",
      "按计划完成",
      "5 实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "object进行强制类型转换会弹出unchecked cast警告",
      "百度",
      "虽然大多数答案都是互相抄的",
      "还都不管用",
      "但是终于找到了能用的方案",
      "无法识别某个文件夹是一个包",
      "问学长被骂之后发现，IDE设置中将该文件夹排除了",
      "更改设置即可",
      "6 实验过程中收获的经验、教训、感想",
      "6.1 实验过程中收获的经验和教训",
      "工程进行之初应详尽考虑并设计规约，以避免之后返工的情况",
      "6.2 针对以下方面的感受",
      "(1) 面向ADT的编程和直接面向应用场景编程",
      "你体会到二者有何差异？",
      "面向ADT编程更加灵活",
      "可以适应不同场合",
      "仅需要对代码进行微小改动",
      "(2) 使用泛型和不使用泛型的编程，对你来说有何差异？",
      "使用泛型可以使ADT不依赖于实际类型",
      "增大了ADT的适用范围",
      "减小了工作量",
      "(3) 在给出ADT的规约后就开始编写测试用例",
      "优势是什么？你是否能够适应这种测试方式？",
      "遵循了“早出错”原则，可以尽早发现错误并且改正，减小损失",
      "我可以适应这种方式",
      "(4) P1设计的ADT在多个应用场景下使用",
      "这种复用带来什么好处？",
      "这种复用可以减少开发成本：当ADT应用在不同场合时仅需要进行微小调整",
      "从而降低开发成本；发现ADT出错时仅需要对ADT本身进行调整而无需对每个具体应用都进行改动",
      "从而降低调试成本",
      "(5) P3要求你从0开始设计ADT并使用它们完成一个具体应用",
      "你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系",
      "P3要求你自主设计这些内容",
      "你的感受如何？",
      "除了没在实验指导里发现P3之外感觉都还好",
      "(6) 为ADT撰写specification, invariants, RI, AF",
      "时刻注意ADT是否有rep exposure",
      "这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "这些工作的给ADT定义了统一的内部规范",
      "方便今后持续开发",
      "防止忘记ADT最初设计的细节以及相应方法",
      "时刻检查rep暴露可以提高安全性和稳定性",
      "我愿意",
      "(7) 关于本实验的工作量、难度、deadline",
      "适中",
      "(8) 《软件构造》课程进展到目前",
      "你对该课程有何体会和建议？",
      "还是应该多写代码"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "2021年春季学期\n计算学部《软件构造》课程\nLab 2实验报告\n郭子正\n1190201117\n1936601\n电子邮件\n1190201117@stu.hit.edu.cn\n手机号码\n18102152791\n2 实验环境配置\n3 实验过程\n3.1 Poetic Walks\n3.1.1 Get the code and prepare Git repository\n3.1.2 Problem 1: Test Graph <String>\n3.1.3 Problem 2: Implement Graph <String>\n3.1.3.1 Implement ConcreteEdgesGraph\n3.1.3.2 Implement ConcreteVerticesGraph\n3.1.4 Problem 3: Implement generic Graph<L>\n3.1.4.1 Make the implementations generic\n3.1.4.2 Implement Graph.empty()\n3.1.5 Problem 4: Poetic walks\n3.1.5.1 Test GraphPoet\n3.1.5.2 Implement GraphPoet\n3.1.5.3 Graph poetry slam\n3.1.6 使用Eclemma检查测试的代码覆盖度\n3.1.7 Before you’re done\n3.2 Re-implement the Social Network in Lab1\n3.2.1 FriendshipGraph类\n3.2.2 Person类\n3.2.3 客户端main()\n3.2.4 测试用例\n3.2.5 提交至Git仓库\n4 实验进度记录\n5 实验过程中遇到的困难与解决途径\n6 实验过程中收获的经验、教训、感想\n6.1 实验过程中收获的经验和教训\n6.2 针对以下方面的感受\n1 实验目标概述\n本次实验训练抽象数据类型(ADT)的设计、规约、测试，并使用面向对象 编程(OOP)技术实现 ADT。具体来说:\n⚫ 针对给定的应用问题，从问题描述中识别所需的 ADT;\n⚫ 设计 ADT 规约(pre-condition、post-condition)并评估规约的质量;\n⚫ 根据 ADT 的规约设计测试用例;\n⚫ ADT的泛型化;\n⚫ 根据规约设计 ADT 的多种不同的实现;针对每种实现，设计其表示\n(representation)、表示不变性(rep invariant)、抽象过程(abstraction\nfunction)\n⚫ 使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表\n示泄露(rep exposure);\n⚫ 测试 ADT 的实现并评估测试的覆盖度;\n⚫ 使用 ADT 及其实现，为应用问题开发程序;\n⚫ 在测试代码中，能够写出 testing strategy 并据此设计测试用例。\n2 实验环境配置\n简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。\n特别是要记录配置过程中遇到的问题和困难，以及如何解决的。\n由于无法访问MIT代码仓库，于是从实验指导上指定的地址下载代码。之后从GitHub克隆空项目到本地，将代码添加进工程。最初遇到错误，经检查发现是MIT练习题的文件路径和实验报告不一致、添加进工程时未完全更改导致的。\n在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）。\n3 实验过程\n请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\n3.1 Poetic Walks\n利用前期建立好的Graph类实现一个小应用，先由给定的语料库建立一张有向图，再用另外给定的输入和建立好的图，根据题目要求生成新的文本。\n3.1.1 Get the code and prepare Git repository\n由于无法访问MIT的代码仓库，所以改从另外指定的地址下载。远程新建仓库之后，克隆到本地，并将下载的代码添加进去。用eclipse配置好开发环境即可。\n3.1.2 Problem 1: Test Graph <String>\n以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。\n写测试用例。每个测试方法都首先生成了一张图，再用各种方法进行测试。\ntestAdd：新建一张图，每增添一个点都检测add()的返回值，并且用查看器检查是否真的增加了一个顶点。随机移除某些点再重新添加，重复添加某些点并查看这些情况下add()返回值是否符合预期，对图的修改是否达到预期。\ntestSet()：随机设置边权，调用Set()时检查返回值是否符合预期、是否真的对边进行了修改（weight>0,weight<0，weight=0）,去除某些边、重复添加某些边再进行测试。\ntestRemove()：建好图之后删除某些点（有些点删除不止一次），查看每次删除时函数的返回值，用查看器查看对图的修改是否符合预期。\ntestVertices()，testSources()，testTargets()：动态维护答案，对图不断修改的同时对预期答案也不断修改，随时调用Vertices()查看图中顶点情况是否符合预期。\n3.1.3 Problem 2: Implement Graph <String>\n以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。\n3.1.3.1 Implement ConcreteEdgesGraph\n建立Edge类：\nSPEC,AF,RI,REP如下：\n主要维护起点、终点和权值。重写了toString，equals，hashCode方法。\n实现ConcreteEdgesGraph类：\nSPEC,AF,RI,REP如下：\nset实现思路：首先确定weight的值以确定行为，如果遇到非法输入直接返回0；如果weight=0且待删除的边的任意顶点不存在则什么也不干，返回0；如果weight>0，先删除旧边（没有则不删）再添加新边（如果顶点不在图中也自动添加）。\nremove实现思路：搜边并删除，没有则不删。\nsource，targets实现思路：遍历edges并返回符合要求的边的相应顶点即可。\n3.1.3.2 Implement ConcreteVerticesGraph\nVertex类实现思路：\nSPEC,AF,RI,REP如下：\n重写了toString，equals，hashCode方法。该类通过存放顶点名称和出边来存放顶点信息。\nConcreteVerticesGraph类实现思路：\nSPEC,AF,RI,REP如下：\nadd设计思路：直接添加顶点。\nset设计思路：非法输入直接返回；添加边时先保证顶点都在图中（如果不是先添加缺失的顶点），再修改这条边出发的源头（from）的出边信息。删除边时直接修改源头顶点的出边信息。\nremove设计思路和set设计思路有重叠，是它的一部分。\nsources设计思路：扫描全部顶点，找到符合要求的部分并输出。\ntargets设计思路：直接返回传入顶点的出边信息即可。\n3.1.4 Problem 3: Implement generic Graph<L>\n3.1.4.1 Make the implementations generic\n将对应的String替换成L即可。\n3.1.4.2 Implement Graph.empty()\n3.1.5 Problem 4: Poetic walks\n3.1.5.1 Test GraphPoet\n测试几种情况：文件不存在、文件为空、文件只包含大写字母、只包含小写字母、正常的英文句子、全部为符号。\n3.1.5.2 Implement GraphPoet\n直接按题目要求模拟即可。建图时根据每个先后关系确定边，获取边的权值，再将对应边的权值加一。生成诗句时在图中搜寻对应边即可。如果有多个中间顶点满足权值加和最大的条件，任意取一个中间顶点即可。\n3.1.5.3 Graph poetry slam\n设计语料库，显示“三点几，饮茶先”。\n3.1.6 使用Eclemma检查测试的代码覆盖度\n3.1.7 Before you’re done\n请按照http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done的说明，检查你的程序。\n如何通过Git提交当前版本到GitHub上你的Lab2仓库。\ngit add->commit->push\n在这里给出你的项目的目录结构树状示意图。\n3.2 Re-implement the Social Network in Lab1\n建立一个有向图模型表示人际关系。人与人之间的距离用有向图中从一 方到达另一方经过的最小边数确定。并且人们的名字不能重复。\n3.2.1 FriendshipGraph类\n直接保存人的集合和表示人际关系的有向图。用BFS来计算人与人之间的距离。\n3.2.2 Person类\n保存姓名，提供获取姓名的方法。\n3.2.3 客户端main()\n建立一张FriendshipGraph，运行实验一的样例。\n3.2.4 测试用例\n3.2.5 提交至Git仓库\n如何通过Git提交当前版本到GitHub上你的Lab3仓库。\ngit add->commit->push\n在这里给出你的项目的目录结构树状示意图。\n4 实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。\n不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。\n时间段；\n计划任务\n实际完成情况\n2021-06-01\n13：45-15：00\n开始写Graph<String>测试用例\n完成一半\n2021-06-03\n22：45-23：00\n继续写Graph<String>测试用例\n按计划完成\n2021-06-04\n19:00-22:16\n写ConcreteEdgesGraph的测试用例，并实现这个类\n按计划完成\n2021-06-04\n22:30-24:00\n设计Vertex类的spec\n按计划完成\n2021-06-05\n10:00-18:39\n继续完成ConcreteEdgesGraph\n本应该很早就完成，结果写到后面发现spec设计有问题，推倒重写反复三次。最终完成。\n2021-06-05\n19:00-20:00\n完成3.1\n按计划完成\n2021-06-05\n22:00-24:00\n完成3.2\n发现不能有警告，但是equals方法用到了强制类型转换，而object转其他类似乎必定会警告，遂百思不得其解。十二点钟终于百度到答案。\n2021-06-06\n21:00-22:00\n完成MIT Problem Set上的题目\n按计划完成\n2021-06-08\n13：45-15：30\n完成剩下的内容\n按计划完成\n5 实验过程中遇到的困难与解决途径\n遇到的难点\n解决途径\nobject进行强制类型转换会弹出unchecked cast警告\n百度，虽然大多数答案都是互相抄的，还都不管用，但是终于找到了能用的方案\n无法识别某个文件夹是一个包\n问学长被骂之后发现，IDE设置中将该文件夹排除了。更改设置即可。\n6 实验过程中收获的经验、教训、感想\n6.1 实验过程中收获的经验和教训\n工程进行之初应详尽考虑并设计规约，以避免之后返工的情况。\n6.2 针对以下方面的感受\n(1) 面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？\n面向ADT编程更加灵活，可以适应不同场合，仅需要对代码进行微小改动。\n(2) 使用泛型和不使用泛型的编程，对你来说有何差异？\n使用泛型可以使ADT不依赖于实际类型，增大了ADT的适用范围，减小了工作量。\n(3) 在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？\n遵循了“早出错”原则，可以尽早发现错误并且改正，减小损失。我可以适应这种方式。\n(4) P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？\n这种复用可以减少开发成本：当ADT应用在不同场合时仅需要进行微小调整，从而降低开发成本；发现ADT出错时仅需要对ADT本身进行调整而无需对每个具体应用都进行改动，从而降低调试成本。\n(5) P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？\n除了没在实验指导里发现P3之外感觉都还好。\n(6) 为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？\n这些工作的给ADT定义了统一的内部规范，方便今后持续开发，防止忘记ADT最初设计的细节以及相应方法。时刻检查rep暴露可以提高安全性和稳定性。我愿意。\n(7) 关于本实验的工作量、难度、deadline。\n适中。\n(8) 《软件构造》课程进展到目前，你对该课程有何体会和建议？\n还是应该多写代码。\n"
  },
  {
    "head": "Java Calendar类实现日期的操作",
    "paragraphs": [
      "根据年月获取月份第一天",
      "根据年月获取月份最后一天",
      "判断是否是当前年月"
    ],
    "sentences": [
      "根据年月获取月份第一天",
      "根据年月获取月份最后一天",
      "判断是否是当前年月"
    ],
    "codes": [
      "public static String getSDateOfMonth(String monthId) {\n    String SDate;\n    Calendar cal = Calendar.getInstance();\n    int year = cal.get(Calendar.YEAR);\n    int month = cal.get(Calendar.MONTH) + 1;\n    int y = Integer.parseInt(monthId.substring(0, 4));\n    int m = Integer.parseInt(monthId.substring(4, 6));\n    if (y == year && m == month) {\n      if (month < 10) {// 月份少于10\n        SDate = \"\" + year + \"-0\" + month + \"-01\";\n      } else {\n        SDate = \"\" + year + month + \"-01\";\n      }\n    } else {// 不是当前月\n      if (m < 10) {// 月份少于10\n        SDate = \"\" + y + \"-0\" + m + \"-01\";\n      } else {\n        SDate = \"\" + y + m + \"-01\";\n      }\n    }\n    return SDate;\n  };",
      "public static String getLastDayOfMonth(String monthId) {\n    int year = Integer.parseInt(monthId.substring(0, 4));\n    int month = Integer.parseInt(monthId.substring(4, 6));\n    Calendar cal = Calendar.getInstance();\n    // 设置年份\n    cal.set(Calendar.YEAR, year);\n    // 设置月份\n    cal.set(Calendar.MONTH, month - 1);\n    // 获取某月最大天数\n    int lastDay = cal.getActualMaximum(Calendar.DAY_OF_MONTH);\n    // 设置日历中月份的最大天数\n    cal.set(Calendar.DAY_OF_MONTH, lastDay);\n    // 格式化日期\n    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n    String lastDayOfMonth = sdf.format(cal.getTime());\n\n    return lastDayOfMonth;\n  };",
      "public static boolean isCurrentMonth(String month) {\n    Calendar cal = Calendar.getInstance();\n    int currentYear = cal.get(Calendar.YEAR);\n    int currentMonth = cal.get(Calendar.MONTH) + 1;\n    int y = Integer.parseInt(month.substring(0, 4));\n    int m = Integer.parseInt(month.substring(4, 6));\n    if (y == currentYear && m == currentMonth) {\n      return true;\n    }else{\n      return false;\n    }\n  };",
      "SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");  \n         \n        //获取前月的第一天 \n        Calendar   cal_1=Calendar.getInstance();//获取当前日期  \n        cal_1.add(Calendar.MONTH, -1); \n        cal_1.set(Calendar.DAY_OF_MONTH,1);//设置为1号,当前日期既为本月第一天  \n        firstDay = format.format(cal_1.getTime()); \n        System.out.println(\"-----1------firstDay:\"+firstDay);\n\n\n\n        //获取前月的最后一天 \n        Calendar cale = Calendar.getInstance();    \n        cale.set(Calendar.DAY_OF_MONTH,0);//设置为1号,当前日期既为本月第一天  \n        lastDay = format.format(cale.getTime()); \n        System.out.println(\"-----2------lastDay:\"+lastDay); \n         \n         \n        //获取当前月第一天： \n        Calendar c = Calendar.getInstance();     \n        c.add(Calendar.MONTH, 0); \n        c.set(Calendar.DAY_OF_MONTH,1);//设置为1号,当前日期既为本月第一天  \n        String first = format.format(c.getTime()); \n        System.out.println(\"===============first:\"+first); \n         \n        //获取当前月最后一天 \n        Calendar ca = Calendar.getInstance();     \n        ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));   \n        String last = format.format(ca.getTime()); \n        System.out.println(\"===============last:\"+last);"
    ],
    "date": "2021-07-02",
    "text": "根据年月获取月份第一天\n根据年月获取月份最后一天\n判断是否是当前年月\n"
  },
  {
    "head": "哈工大软件构造 第一次实验报告",
    "paragraphs": [
      "2021年春季学期",
      "计算学部《软件构造》课程",
      "Lab 1实验报告",
      "电子邮件",
      "手机号码",
      "1 实验目标概述.. 3",
      "2 实验环境配置.. 3",
      "3 实验过程.. 3",
      "3.1 Magic Squares 3",
      "3.1.1 isLegalMagicSquare() 4",
      "3.1.2 generateMagicSquare() 5",
      "3.2 Turtle Graphics 6",
      "3.2.1 Problem 1: Clone and import 7",
      "3.2.2 Problem 3: Turtle graphics and drawSquare. 7",
      "3.2.3 Problem 5: Drawing polygons 7",
      "3.2.4 Problem 6: Calculating Bearings 7",
      "3.2.5 Problem 7: Convex Hulls 8",
      "3.2.6 Problem 8: Personal art 9",
      "3.2.7 Submitting. 10",
      "3.3 Social Network 10",
      "3.3.1 设计/实现FriendshipGraph类.. 10",
      "3.3.2 设计/实现Person类... 11",
      "3.3.3 设计/实现客户端代码main() 11",
      "3.3.4 设计/实现测试用例.. 12",
      "4 实验进度记录.. 13",
      "5 实验过程中遇到的困难与解决途径... 14",
      "6 实验过程中收获的经验、教训、感想.. 15",
      "6.1 实验过程中收获的经验和教训.. 15",
      "6.2 针对以下方面的感受.. 15",
      "1 实验目标概述",
      "本次实验通过求解三个问题，训练基本的Java编程技能，能够利用Java OO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够 为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。 另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。",
      "2 实验环境配置",
      "简要陈述你配置本次实验所需开发、测试、运行环境的过程，必要时可以给出屏幕截图。",
      "特别是要记录配置过程中遇到的问题和困难，以及如何解决的。",
      "本次实验使用Eclipse完成。新建Java项目之后直接编写代码即可。当全部代码编写完毕之后将源文件复制到git本地仓库在推送到远程服务器。",
      "通过查找资料发现java的包名称需要和所在文件夹名称一致，代码文件中需要包含同名称的类。",
      "由于在使用git之前已经阅读过使用说明（https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93），所以并未遇到特别难以解决的问题。剩下的问题均能够通过在搜索引擎上搜索快速得到答案，故未全部详细记录。",
      "在这里给出你的GitHub Lab1仓库的URL地址。",
      "https://github.com/ComputerScienceHIT/HIT-Lab1-1190201117.git",
      "3 实验过程",
      "请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。",
      "为了条理清晰，可根据需要在各节增加三级标题。",
      "3.1 Magic Squares",
      "需要按照题目要求设计一个识别/生成幻方的程序。其中幻方的要求是每行、列、对角线元素之和都相同（注意，题目中说的是“usually distinct numbers”而非“distinct numbers”，因此全部元素都相同的方阵也可以看做是一个幻方）。",
      "程序需要从文件中读入幻方信息，并调用isLegalMagicSquare()方法。isLegalMagicSquare()接受需要读入的文件名，如果该文件中所存的数据构成一个幻方则返回true，否则返回false。",
      "3.1.1 isLegalMagicSquare()",
      "思路：首先按行读入文件内容，判断每行元素是否含有非法字符（数字间空格/其他字符等），并将每行内容存入矩阵。当输入合法后，比较行列数是否相同，再比较上一步所得矩阵的每行/列/对角线元素和，如果矩阵是方阵且元素和全部相等则返回true，否则返回false。",
      "过程：首先利用readArr()从缓存读入数据，并转化成矩阵",
      "然后检查输入是否为空，行列数是否相等",
      "最后判断元素和是否相等。",
      "利用BigInteger处理数据以防止整数过大造成溢出。",
      "3.1.2 generateMagicSquare()",
      "程序从第一行中间开始，向着右上斜线方向依次填满方格。流程图如下。",
      "3.2 Turtle Graphics",
      "根据提示补全代码，实现下列功能：",
      "1、画出正四边形。",
      "2、完成正多边形内角和外角的计算",
      "3、计算向量之间的夹角",
      "4、计算凸包",
      "5、绘制自己的图形",
      "3.2.1 Problem 1: Clone and import",
      "由于git服务器响应缓慢，clone操作无法正常进行。在github下载项目的zip包之后解压，在本地git init ，git remote add 远程仓库，git pull lab master之后即可同步本地与远程仓库，加入zip包中的文件之后再git add . ，git commit，git push lab master。至此项目导入完毕并和远程仓库保持一致。（这里远程仓库的名字叫lab）",
      "3.2.2 Problem 3: Turtle graphics and drawSquare",
      "顾名思义forward意为向前走，turn意为转向，分别向前走并转向四次即可画出正方形。",
      "3.2.3 Problem 5: Drawing polygons",
      "类似地，计算出每次转向角度再不断转向直行即可画出正多边形。",
      "分别补全下列代码",
      "首先计算转向角度，再画多边形。",
      "3.2.4 Problem 6: Calculating Bearings",
      "由于题目未说清要求，通过猜测，结合样例发现若干没有说清楚的细节如下：",
      "给定当前角度（可能是在某个坐标系内的参数，通过样例发现xOy坐标系中y轴正方向是0度的朝向），计算从当前位置转向下一位置需要转过的角度（只能按顺时针方向旋转）。",
      "问题可以通过余弦定理解决。",
      "如图所示，A,B分别是当前点和下一个点，AB长度是确定的。并且当前朝向AC方向。容易知道转过的角度是角A的大小。由于AC的长度不固定，所以可以取一个便于计算的值。用余弦定理可以得到结果。",
      "calculateBearings只需要对若干个点重复做calculateBearingToPoint()即可。",
      "3.2.5 Problem 7: Convex Hulls",
      "这里利用包礼物算法计算凸包。首先找到最左下方的点（这可以通过比较坐标得到），初始方向指向凸包外侧（不妨就设成x轴负方向即270度方向），每次循环找到从当前点出发到下一个点时，转动角度最小的那个（如果有两个及以上的点满足条件，选距离最远的那个），将这一点加入结果，更新当前点和当前朝向之后重复操作，直到转回初始的点。",
      "3.2.6 Problem 8: Personal art",
      "随便画些东西。这里画了一个多角形。每次更改朝向并画直线，一直到转够整数圈之后停止。翻了翻代码，发现DrawableTurtle第35行可以修改初始点位置，利用这个可以解决画出画布的问题。",
      "3.2.7 Submitting",
      "将代码加入本地文件夹后git add *，git commit -m“xxx”，git push lab master即可。（这里远程仓库的名字是lab）",
      "3.3 Social Network",
      "建立一个有向图模型表示人际关系。人与人之间的距离用有向图中从一方到达另一方经过的最小边数确定。并且人们的名字不能重复。",
      "3.3.1 设计/实现FriendshipGraph类",
      "类中的两个变量，name_list用来记录人名，p_list用来记录人。",
      "addEdge和addVertex分别加入边和顶点。addEdge判断端点是否存在，addVertex判断重名。",
      "getDistance用BFS来实现。",
      "3.3.2 设计/实现Person类",
      "_name存放自己的名字，friends存放好友列表。",
      "getFriend和setFriend函数分别获取好友和添加好友。",
      "3.3.3 设计/实现客户端代码main()",
      "根据实验手册得到如下代码：",
      "3.3.4 设计/实现测试用例",
      "测试addVertex和addEdge",
      "测试getDistance。",
      "测试结果。",
      "4 实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。",
      "不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。",
      "时间段",
      "实际完成情况",
      "2021-05-11",
      "13:45-15:30",
      "学习Java的基本语法，学会使用文件读写功能，并读取文件。",
      "按计划完成",
      "2021-05-12",
      "10:00-12:00",
      "将文件数据读入并转换成大整数，存储进二维可变长数组中；添加判断输入合法性的功能以及验证和是否相同的功能。",
      "按计划完成",
      "2021-05-13",
      "23:00-24:00",
      "修改读取文件的bug，测试了生成幻方的函数。",
      "按计划完成",
      "2021-05-14",
      "19:00-20:00",
      "完成至P2的问题6",
      "按计划完成",
      "2021-05-15",
      "19：00-20：00",
      "解决凸包，完成P2",
      "按计划完成",
      "2021-05-18",
      "13：45-15：30",
      "写完P3",
      "按计划完成",
      "2021-05-18",
      "19：00-20：00",
      "调试全部项目，完工",
      "按计划完成",
      "2021-05-22",
      "14：50-15：00",
      "写报告时发现代码有考虑不周之处，修改之",
      "按计划完成",
      "5 实验过程中遇到的困难与解决途径",
      "遇到的困难",
      "解决途径",
      "不会用java",
      "通过百度自学，问学长",
      "不会用git",
      "通过官方文档自学",
      "P3不会写测试用例",
      "参考P2代码，自己摸索，不行就百度",
      "6 实验过程中收获的经验、教训、感想",
      "6.1 实验过程中收获的经验和教训",
      "经验：学习了使用Java语言和git工具。",
      "教训：不要等到最后一天再写报告。",
      "6.2 针对以下方面的感受",
      "Java编程语言是否对你的口味？",
      "比较方便，但是不如C++自由（不可以直接修改内存）",
      "关于Eclipse IDE；",
      "中规中矩，有时感觉挺毒瘤（代码窗口不小心关掉之后找不到如何打开，只能重启）。当然，这是由于个人原因导致的。",
      "关于Git和GitHub；",
      "挺好用的工具，就是github访问太慢了且很玄学，不如换成gitee。",
      "关于CMU和MIT的作业；",
      "MIT的作业比较有新意，介绍了turtle（虽然是阉割版本），挺有意思。",
      "关于本实验的工作量、难度、deadline；",
      "都适中。",
      "关于初接触“软件构造”课程；",
      "与预期基本一致。"
    ],
    "sentences": [
      "2021年春季学期",
      "计算学部《软件构造》课程",
      "Lab 1实验报告",
      "电子邮件",
      "手机号码",
      "1 实验目标概述.. 3",
      "2 实验环境配置.. 3",
      "3 实验过程.. 3",
      "3.1 Magic Squares 3",
      "3.1.1 isLegalMagicSquare() 4",
      "3.1.2 generateMagicSquare() 5",
      "3.2 Turtle Graphics 6",
      "3.2.1 Problem 1: Clone and import 7",
      "3.2.2 Problem 3: Turtle graphics and drawSquare. 7",
      "3.2.3 Problem 5: Drawing polygons 7",
      "3.2.4 Problem 6: Calculating Bearings 7",
      "3.2.5 Problem 7: Convex Hulls 8",
      "3.2.6 Problem 8: Personal art 9",
      "3.2.7 Submitting. 10",
      "3.3 Social Network 10",
      "3.3.1 设计/实现FriendshipGraph类.. 10",
      "3.3.2 设计/实现Person类... 11",
      "3.3.3 设计/实现客户端代码main() 11",
      "3.3.4 设计/实现测试用例.. 12",
      "4 实验进度记录.. 13",
      "5 实验过程中遇到的困难与解决途径... 14",
      "6 实验过程中收获的经验、教训、感想.. 15",
      "6.1 实验过程中收获的经验和教训.. 15",
      "6.2 针对以下方面的感受.. 15",
      "1 实验目标概述",
      "本次实验通过求解三个问题",
      "训练基本的Java编程技能",
      "能够利用Java OO开发基本的功能模块",
      "能够阅读理解已有代码框架并根据功能需求补全代码",
      "能够 为所开发的代码编写基本的测试程序并完成测试",
      "初步保证所开发代码的正确性",
      " 另一方面",
      "利用Git作为代码配置管理的工具",
      "学会Git的基本使用方法",
      "2 实验环境配置",
      "简要陈述你配置本次实验所需开发、测试、运行环境的过程",
      "必要时可以给出屏幕截图",
      "特别是要记录配置过程中遇到的问题和困难，以及如何解决的",
      "本次实验使用Eclipse完成",
      "新建Java项目之后直接编写代码即可",
      "当全部代码编写完毕之后将源文件复制到git本地仓库在推送到远程服务器",
      "通过查找资料发现java的包名称需要和所在文件夹名称一致",
      "代码文件中需要包含同名称的类",
      "由于在使用git之前已经阅读过使用说明（https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93）",
      "所以并未遇到特别难以解决的问题",
      "剩下的问题均能够通过在搜索引擎上搜索快速得到答案",
      "故未全部详细记录",
      "在这里给出你的GitHub Lab1仓库的URL地址",
      "https://github.com/ComputerScienceHIT/HIT-Lab1-1190201117.git",
      "3 实验过程",
      "请仔细对照实验手册",
      "针对四个问题中的每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）",
      "为了条理清晰，可根据需要在各节增加三级标题",
      "3.1 Magic Squares",
      "需要按照题目要求设计一个识别/生成幻方的程序",
      "其中幻方的要求是每行、列、对角线元素之和都相同（注意",
      "题目中说的是“usually distinct numbers”而非“distinct numbers”",
      "因此全部元素都相同的方阵也可以看做是一个幻方）",
      "程序需要从文件中读入幻方信息",
      "并调用isLegalMagicSquare()方法",
      "isLegalMagicSquare()接受需要读入的文件名",
      "如果该文件中所存的数据构成一个幻方则返回true",
      "否则返回false",
      "3.1.1 isLegalMagicSquare()",
      "思路：首先按行读入文件内容",
      "判断每行元素是否含有非法字符（数字间空格/其他字符等）",
      "并将每行内容存入矩阵",
      "当输入合法后",
      "比较行列数是否相同",
      "再比较上一步所得矩阵的每行/列/对角线元素和",
      "如果矩阵是方阵且元素和全部相等则返回true",
      "否则返回false",
      "过程：首先利用readArr()从缓存读入数据，并转化成矩阵",
      "然后检查输入是否为空，行列数是否相等",
      "最后判断元素和是否相等",
      "利用BigInteger处理数据以防止整数过大造成溢出",
      "3.1.2 generateMagicSquare()",
      "程序从第一行中间开始，向着右上斜线方向依次填满方格",
      "流程图如下",
      "3.2 Turtle Graphics",
      "根据提示补全代码，实现下列功能：1、画出正四边形",
      "2、完成正多边形内角和外角的计算",
      "3、计算向量之间的夹角",
      "4、计算凸包",
      "5、绘制自己的图形",
      "3.2.1 Problem 1: Clone and import",
      "由于git服务器响应缓慢，clone操作无法正常进行",
      "在github下载项目的zip包之后解压",
      "在本地git init ",
      "git remote add 远程仓库",
      "git pull lab master之后即可同步本地与远程仓库",
      "加入zip包中的文件之后再git add . ",
      "git commit",
      "git push lab master",
      "至此项目导入完毕并和远程仓库保持一致",
      "（这里远程仓库的名字叫lab）",
      "3.2.2 Problem 3: Turtle graphics and drawSquare",
      "顾名思义forward意为向前走",
      "turn意为转向",
      "分别向前走并转向四次即可画出正方形",
      "3.2.3 Problem 5: Drawing polygons",
      "类似地，计算出每次转向角度再不断转向直行即可画出正多边形",
      "分别补全下列代码",
      "首先计算转向角度，再画多边形",
      "3.2.4 Problem 6: Calculating Bearings",
      "由于题目未说清要求",
      "通过猜测",
      "结合样例发现若干没有说清楚的细节如下：给定当前角度（可能是在某个坐标系内的参数",
      "通过样例发现xOy坐标系中y轴正方向是0度的朝向）",
      "计算从当前位置转向下一位置需要转过的角度（只能按顺时针方向旋转）",
      "问题可以通过余弦定理解决",
      "如图所示，A,B分别是当前点和下一个点，AB长度是确定的",
      "并且当前朝向AC方向",
      "容易知道转过的角度是角A的大小",
      "由于AC的长度不固定，所以可以取一个便于计算的值",
      "用余弦定理可以得到结果",
      "calculateBearings只需要对若干个点重复做calculateBearingToPoint()即可",
      "3.2.5 Problem 7: Convex Hulls",
      "这里利用包礼物算法计算凸包",
      "首先找到最左下方的点（这可以通过比较坐标得到）",
      "初始方向指向凸包外侧（不妨就设成x轴负方向即270度方向）",
      "每次循环找到从当前点出发到下一个点时",
      "转动角度最小的那个（如果有两个及以上的点满足条件",
      "选距离最远的那个）",
      "将这一点加入结果",
      "更新当前点和当前朝向之后重复操作",
      "直到转回初始的点",
      "3.2.6 Problem 8: Personal art",
      "随便画些东西",
      "这里画了一个多角形",
      "每次更改朝向并画直线，一直到转够整数圈之后停止",
      "翻了翻代码",
      "发现DrawableTurtle第35行可以修改初始点位置",
      "利用这个可以解决画出画布的问题",
      "3.2.7 Submitting",
      "将代码加入本地文件夹后git add *",
      "git commit -m“xxx”",
      "git push lab master即可",
      "（这里远程仓库的名字是lab）",
      "3.3 Social Network",
      "建立一个有向图模型表示人际关系",
      "人与人之间的距离用有向图中从一方到达另一方经过的最小边数确定",
      "并且人们的名字不能重复",
      "3.3.1 设计/实现FriendshipGraph类",
      "类中的两个变量",
      "name_list用来记录人名",
      "p_list用来记录人",
      "addEdge和addVertex分别加入边和顶点",
      "addEdge判断端点是否存在，addVertex判断重名",
      "getDistance用BFS来实现",
      "3.3.2 设计/实现Person类",
      "_name存放自己的名字，friends存放好友列表",
      "getFriend和setFriend函数分别获取好友和添加好友",
      "3.3.3 设计/实现客户端代码main()",
      "根据实验手册得到如下代码：3.3.4 设计/实现测试用例",
      "测试addVertex和addEdge",
      "测试getDistance",
      "测试结果",
      "4 实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "每次结束编程时，请向该表格中增加一行",
      "不要事后胡乱填写",
      "不要嫌烦",
      "该表格可帮助你汇总你在每个任务上付出的时间和精力",
      "发现自己不擅长的任务",
      "后续有意识的弥补",
      "时间段",
      "实际完成情况",
      "2021-05-11",
      "13:45-15:30",
      "学习Java的基本语法，学会使用文件读写功能，并读取文件",
      "按计划完成",
      "2021-05-12",
      "10:00-12:00",
      "将文件数据读入并转换成大整数",
      "存储进二维可变长数组中；添加判断输入合法性的功能以及验证和是否相同的功能",
      "按计划完成",
      "2021-05-13",
      "23:00-24:00",
      "修改读取文件的bug，测试了生成幻方的函数",
      "按计划完成",
      "2021-05-14",
      "19:00-20:00",
      "完成至P2的问题6",
      "按计划完成",
      "2021-05-15",
      "19：00-20：00",
      "解决凸包，完成P2",
      "按计划完成",
      "2021-05-18",
      "13：45-15：30",
      "写完P3",
      "按计划完成",
      "2021-05-18",
      "19：00-20：00",
      "调试全部项目，完工",
      "按计划完成",
      "2021-05-22",
      "14：50-15：00",
      "写报告时发现代码有考虑不周之处，修改之",
      "按计划完成",
      "5 实验过程中遇到的困难与解决途径",
      "遇到的困难",
      "解决途径",
      "不会用java",
      "通过百度自学，问学长",
      "不会用git",
      "通过官方文档自学",
      "P3不会写测试用例",
      "参考P2代码，自己摸索，不行就百度",
      "6 实验过程中收获的经验、教训、感想",
      "6.1 实验过程中收获的经验和教训",
      "经验：学习了使用Java语言和git工具",
      "教训：不要等到最后一天再写报告",
      "6.2 针对以下方面的感受",
      "Java编程语言是否对你的口味？",
      "比较方便，但是不如C++自由（不可以直接修改内存）",
      "关于Eclipse IDE；中规中矩",
      "有时感觉挺毒瘤（代码窗口不小心关掉之后找不到如何打开",
      "只能重启）",
      "当然，这是由于个人原因导致的",
      "关于Git和GitHub；挺好用的工具",
      "就是github访问太慢了且很玄学",
      "不如换成gitee",
      "关于CMU和MIT的作业；MIT的作业比较有新意",
      "介绍了turtle（虽然是阉割版本）",
      "挺有意思",
      "关于本实验的工作量、难度、deadline；都适中",
      "关于初接触“软件构造”课程；与预期基本一致"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "2021年春季学期\n计算学部《软件构造》课程\nLab 1实验报告\n电子邮件\n手机号码\n1 实验目标概述.. 3\n2 实验环境配置.. 3\n3 实验过程.. 3\n3.1 Magic Squares 3\n3.1.1 isLegalMagicSquare() 4\n3.1.2 generateMagicSquare() 5\n3.2 Turtle Graphics 6\n3.2.1 Problem 1: Clone and import 7\n3.2.2 Problem 3: Turtle graphics and drawSquare. 7\n3.2.3 Problem 5: Drawing polygons 7\n3.2.4 Problem 6: Calculating Bearings 7\n3.2.5 Problem 7: Convex Hulls 8\n3.2.6 Problem 8: Personal art 9\n3.2.7 Submitting. 10\n3.3 Social Network 10\n3.3.1 设计/实现FriendshipGraph类.. 10\n3.3.2 设计/实现Person类... 11\n3.3.3 设计/实现客户端代码main() 11\n3.3.4 设计/实现测试用例.. 12\n4 实验进度记录.. 13\n5 实验过程中遇到的困难与解决途径... 14\n6 实验过程中收获的经验、教训、感想.. 15\n6.1 实验过程中收获的经验和教训.. 15\n6.2 针对以下方面的感受.. 15\n1 实验目标概述\n本次实验通过求解三个问题，训练基本的Java编程技能，能够利用Java OO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够 为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。 另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。\n2 实验环境配置\n简要陈述你配置本次实验所需开发、测试、运行环境的过程，必要时可以给出屏幕截图。\n特别是要记录配置过程中遇到的问题和困难，以及如何解决的。\n本次实验使用Eclipse完成。新建Java项目之后直接编写代码即可。当全部代码编写完毕之后将源文件复制到git本地仓库在推送到远程服务器。\n通过查找资料发现java的包名称需要和所在文件夹名称一致，代码文件中需要包含同名称的类。\n由于在使用git之前已经阅读过使用说明（https://www.git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93），所以并未遇到特别难以解决的问题。剩下的问题均能够通过在搜索引擎上搜索快速得到答案，故未全部详细记录。\n在这里给出你的GitHub Lab1仓库的URL地址。\nhttps://github.com/ComputerScienceHIT/HIT-Lab1-1190201117.git\n3 实验过程\n请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。\n为了条理清晰，可根据需要在各节增加三级标题。\n3.1 Magic Squares\n需要按照题目要求设计一个识别/生成幻方的程序。其中幻方的要求是每行、列、对角线元素之和都相同（注意，题目中说的是“usually distinct numbers”而非“distinct numbers”，因此全部元素都相同的方阵也可以看做是一个幻方）。\n程序需要从文件中读入幻方信息，并调用isLegalMagicSquare()方法。isLegalMagicSquare()接受需要读入的文件名，如果该文件中所存的数据构成一个幻方则返回true，否则返回false。\n3.1.1 isLegalMagicSquare()\n思路：首先按行读入文件内容，判断每行元素是否含有非法字符（数字间空格/其他字符等），并将每行内容存入矩阵。当输入合法后，比较行列数是否相同，再比较上一步所得矩阵的每行/列/对角线元素和，如果矩阵是方阵且元素和全部相等则返回true，否则返回false。\n过程：首先利用readArr()从缓存读入数据，并转化成矩阵\n然后检查输入是否为空，行列数是否相等\n最后判断元素和是否相等。\n利用BigInteger处理数据以防止整数过大造成溢出。\n3.1.2 generateMagicSquare()\n程序从第一行中间开始，向着右上斜线方向依次填满方格。流程图如下。\n3.2 Turtle Graphics\n根据提示补全代码，实现下列功能：\n1、画出正四边形。\n2、完成正多边形内角和外角的计算\n3、计算向量之间的夹角\n4、计算凸包\n5、绘制自己的图形\n3.2.1 Problem 1: Clone and import\n由于git服务器响应缓慢，clone操作无法正常进行。在github下载项目的zip包之后解压，在本地git init ，git remote add 远程仓库，git pull lab master之后即可同步本地与远程仓库，加入zip包中的文件之后再git add . ，git commit，git push lab master。至此项目导入完毕并和远程仓库保持一致。（这里远程仓库的名字叫lab）\n3.2.2 Problem 3: Turtle graphics and drawSquare\n顾名思义forward意为向前走，turn意为转向，分别向前走并转向四次即可画出正方形。\n3.2.3 Problem 5: Drawing polygons\n类似地，计算出每次转向角度再不断转向直行即可画出正多边形。\n分别补全下列代码\n首先计算转向角度，再画多边形。\n3.2.4 Problem 6: Calculating Bearings\n由于题目未说清要求，通过猜测，结合样例发现若干没有说清楚的细节如下：\n给定当前角度（可能是在某个坐标系内的参数，通过样例发现xOy坐标系中y轴正方向是0度的朝向），计算从当前位置转向下一位置需要转过的角度（只能按顺时针方向旋转）。\n问题可以通过余弦定理解决。\n如图所示，A,B分别是当前点和下一个点，AB长度是确定的。并且当前朝向AC方向。容易知道转过的角度是角A的大小。由于AC的长度不固定，所以可以取一个便于计算的值。用余弦定理可以得到结果。\ncalculateBearings只需要对若干个点重复做calculateBearingToPoint()即可。\n3.2.5 Problem 7: Convex Hulls\n这里利用包礼物算法计算凸包。首先找到最左下方的点（这可以通过比较坐标得到），初始方向指向凸包外侧（不妨就设成x轴负方向即270度方向），每次循环找到从当前点出发到下一个点时，转动角度最小的那个（如果有两个及以上的点满足条件，选距离最远的那个），将这一点加入结果，更新当前点和当前朝向之后重复操作，直到转回初始的点。\n3.2.6 Problem 8: Personal art\n随便画些东西。这里画了一个多角形。每次更改朝向并画直线，一直到转够整数圈之后停止。翻了翻代码，发现DrawableTurtle第35行可以修改初始点位置，利用这个可以解决画出画布的问题。\n3.2.7 Submitting\n将代码加入本地文件夹后git add *，git commit -m“xxx”，git push lab master即可。（这里远程仓库的名字是lab）\n3.3 Social Network\n建立一个有向图模型表示人际关系。人与人之间的距离用有向图中从一方到达另一方经过的最小边数确定。并且人们的名字不能重复。\n3.3.1 设计/实现FriendshipGraph类\n类中的两个变量，name_list用来记录人名，p_list用来记录人。\naddEdge和addVertex分别加入边和顶点。addEdge判断端点是否存在，addVertex判断重名。\ngetDistance用BFS来实现。\n3.3.2 设计/实现Person类\n_name存放自己的名字，friends存放好友列表。\ngetFriend和setFriend函数分别获取好友和添加好友。\n3.3.3 设计/实现客户端代码main()\n根据实验手册得到如下代码：\n3.3.4 设计/实现测试用例\n测试addVertex和addEdge\n测试getDistance。\n测试结果。\n4 实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。\n不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。\n时间段\n实际完成情况\n2021-05-11\n13:45-15:30\n学习Java的基本语法，学会使用文件读写功能，并读取文件。\n按计划完成\n2021-05-12\n10:00-12:00\n将文件数据读入并转换成大整数，存储进二维可变长数组中；添加判断输入合法性的功能以及验证和是否相同的功能。\n按计划完成\n2021-05-13\n23:00-24:00\n修改读取文件的bug，测试了生成幻方的函数。\n按计划完成\n2021-05-14\n19:00-20:00\n完成至P2的问题6\n按计划完成\n2021-05-15\n19：00-20：00\n解决凸包，完成P2\n按计划完成\n2021-05-18\n13：45-15：30\n写完P3\n按计划完成\n2021-05-18\n19：00-20：00\n调试全部项目，完工\n按计划完成\n2021-05-22\n14：50-15：00\n写报告时发现代码有考虑不周之处，修改之\n按计划完成\n5 实验过程中遇到的困难与解决途径\n遇到的困难\n解决途径\n不会用java\n通过百度自学，问学长\n不会用git\n通过官方文档自学\nP3不会写测试用例\n参考P2代码，自己摸索，不行就百度\n6 实验过程中收获的经验、教训、感想\n6.1 实验过程中收获的经验和教训\n经验：学习了使用Java语言和git工具。\n教训：不要等到最后一天再写报告。\n6.2 针对以下方面的感受\nJava编程语言是否对你的口味？\n比较方便，但是不如C++自由（不可以直接修改内存）\n关于Eclipse IDE；\n中规中矩，有时感觉挺毒瘤（代码窗口不小心关掉之后找不到如何打开，只能重启）。当然，这是由于个人原因导致的。\n关于Git和GitHub；\n挺好用的工具，就是github访问太慢了且很玄学，不如换成gitee。\n关于CMU和MIT的作业；\nMIT的作业比较有新意，介绍了turtle（虽然是阉割版本），挺有意思。\n关于本实验的工作量、难度、deadline；\n都适中。\n关于初接触“软件构造”课程；\n与预期基本一致。\n"
  },
  {
    "head": "使用Calendar类的一点注意事项",
    "paragraphs": [
      "我们可以用如下代码计算两个日期之间相隔的天数：",
      "但是这行代码会随机出错。原因可能在于我们在这里使用了整数除法，会将结果舍去末尾的零。",
      "将代码用四舍五入进行舍入则会得到正确的结果："
    ],
    "sentences": [
      "我们可以用如下代码计算两个日期之间相隔的天数：但是这行代码会随机出错",
      "原因可能在于我们在这里使用了整数除法，会将结果舍去末尾的零",
      "将代码用四舍五入进行舍入则会得到正确的结果："
    ],
    "codes": [
      "(end_time.getTimeInMillis()-start_time.getTimeInMillis())/(3600*1000*24);\n",
      "Math.round((double)(end_time.getTimeInMillis()-start_time.getTimeInMillis())/(double)(3600*1000*24))\n"
    ],
    "date": "2021-07-02",
    "text": "我们可以用如下代码计算两个日期之间相隔的天数：\n但是这行代码会随机出错。原因可能在于我们在这里使用了整数除法，会将结果舍去末尾的零。\n将代码用四舍五入进行舍入则会得到正确的结果：\n"
  },
  {
    "head": "软件构造作业-使用eclipse内置的git工具",
    "paragraphs": [
      "在哈工大软件构造的几个实验（作业）中，均要求使用git管理项目配置。同时，建议使用eclipse IDE进行项目开发。如果使用eclipse自带的git插件，就不需要额外安装和使用git，在eclipse中一并管理，比较方便。本文将实例演示使用内置git工具管理项目的常用方法。",
      "步骤1 新建远程仓库",
      "在GitHub上创建远程仓库。软件构造课程的3个作业，只要点击链接，就可以自动生成仓库。在此我额外新建一个仓库作为演示。",
      "1.1 点击start a project",
      "1.2 填写仓库信息",
      "有仓库名和一些可选项。我选择添加README文件，因为如果仓库是空的，它不会生成默认分支，之后会有点麻烦。",
      "1.3 点击\"Create repository\"确认",
      "新建仓库完成后，应该看到这样的界面。",
      "1.4* 修改默认分支名为master",
      "点击分支按钮，再点 View all branches，再点击右侧的铅笔图标，则如下图所示。",
      "步骤2 在eclipse中引入项目",
      "2.1 从Git中引入",
      "打开eclipse，点击File->Import，选择Projects from Git (with smart import)，点击Next。",
      "2.2 选择Clone URI",
      "然后点击Next。",
      "2.3 填写相关信息",
      "先复制远程仓库的地址。",
      "再填写URI和自己的Github账号信息。Host和Repository Path会在填写URI后自动填写。勾选Store in Secure Store，就可以记住密码，以后不用每次输入。",
      "2.4 剩下的操作",
      "不断点击Next，再点Finish。完成的结果如下图。可以看到项目被引入工作空间了。",
      "2.5* 设置Java项目",
      "右键项目，选择Properties.",
      "选择Project Natures，Add Java，再点击OK和Apply and Close。",
      "再在build path中添加jdk和JUnit，具体操作略。",
      "步骤3 修改项目并提交到远程分支",
      "3.1 做出本地修改",
      "新建文件new，写入123.",
      "3.2 提交到本地仓库",
      "右键项目，选择Team->Commit...",
      "以下显示的是Git Staging。点击重叠的绿色加号，将修改放入stage。右侧是Commit Message。必须填入，否则不能提交。",
      "再点击右下角的Commit，即可提交。",
      "3.3 Push到远程仓库",
      "右键项目，选择Team->Push to Upstream",
      "Push成功后，会跳出如下窗口。",
      "也可以在commit步骤直接点击Commit and Push，一步到位。",
      "步骤4 创建和切换分支",
      "4.1 在远程仓库创建新分支change",
      "4.2 在本地仓库添加Upstream的分支",
      "右键->Team->Remote->Configure Fetch from Upstream...",
      "在Ref mappings中点击Add...，Source选择change，输入后会稍微加载一段时间。",
      "然后点击Next到Finish。",
      "4.3 新建并切换到本地分支change",
      "右键->Switch To->New Branch...",
      "填写name为change，完成。",
      "4.4 修改本地文件",
      "4.5 push到远程change分支",
      "先commit，然后设置Push Branch \"change\"...",
      "填入Branch名为change。",
      "再push就可以了。",
      "4.6 再切换回来",
      "步骤5 其它",
      "本文中没有提到的有fetch，pull，解决冲突等问题。这些在本学期的软件构造中用不到，但在实际的多人协作中很常用。以后有时间可能会讨论。"
    ],
    "sentences": [
      "在哈工大软件构造的几个实验（作业）中",
      "均要求使用git管理项目配置",
      "同时，建议使用eclipse IDE进行项目开发",
      "如果使用eclipse自带的git插件",
      "就不需要额外安装和使用git",
      "在eclipse中一并管理",
      "比较方便",
      "本文将实例演示使用内置git工具管理项目的常用方法",
      "步骤1 新建远程仓库",
      "在GitHub上创建远程仓库",
      "软件构造课程的3个作业，只要点击链接，就可以自动生成仓库",
      "在此我额外新建一个仓库作为演示",
      "1.1 点击start a project",
      "1.2 填写仓库信息",
      "有仓库名和一些可选项",
      "我选择添加README文件",
      "因为如果仓库是空的",
      "它不会生成默认分支",
      "之后会有点麻烦",
      "1.3 点击\"Create repository\"确认",
      "新建仓库完成后，应该看到这样的界面",
      "1.4* 修改默认分支名为master",
      "点击分支按钮",
      "再点 View all branches",
      "再点击右侧的铅笔图标",
      "则如下图所示",
      "步骤2 在eclipse中引入项目",
      "2.1 从Git中引入",
      "打开eclipse",
      "点击File->Import",
      "选择Projects from Git (with smart import)",
      "点击Next",
      "2.2 选择Clone URI",
      "然后点击Next",
      "2.3 填写相关信息",
      "先复制远程仓库的地址",
      "再填写URI和自己的Github账号信息",
      "Host和Repository Path会在填写URI后自动填写",
      "勾选Store in Secure Store",
      "就可以记住密码",
      "以后不用每次输入",
      "2.4 剩下的操作",
      "不断点击Next，再点Finish",
      "完成的结果如下图",
      "可以看到项目被引入工作空间了",
      "2.5* 设置Java项目",
      "右键项目",
      "选择Properties.选择Project Natures",
      "Add Java",
      "再点击OK和Apply and Close",
      "再在build path中添加jdk和JUnit，具体操作略",
      "步骤3 修改项目并提交到远程分支",
      "3.1 做出本地修改",
      "新建文件new，写入123.3.2 提交到本地仓库",
      "右键项目",
      "选择Team->Commit...以下显示的是Git Staging",
      "点击重叠的绿色加号，将修改放入stage",
      "右侧是Commit Message",
      "必须填入，否则不能提交",
      "再点击右下角的Commit，即可提交",
      "3.3 Push到远程仓库",
      "右键项目，选择Team->Push to Upstream",
      "Push成功后，会跳出如下窗口",
      "也可以在commit步骤直接点击Commit and Push",
      "一步到位",
      "步骤4 创建和切换分支",
      "4.1 在远程仓库创建新分支change",
      "4.2 在本地仓库添加Upstream的分支",
      "右键->Team->Remote->Configure Fetch from Upstream...在Ref mappings中点击Add...",
      "Source选择change",
      "输入后会稍微加载一段时间",
      "然后点击Next到Finish",
      "4.3 新建并切换到本地分支change",
      "右键->Switch To->New Branch...填写name为change",
      "完成",
      "4.4 修改本地文件",
      "4.5 push到远程change分支",
      "先commit",
      "然后设置Push Branch \"change\"...填入Branch名为change",
      "再push就可以了",
      "4.6 再切换回来",
      "步骤5 其它",
      "本文中没有提到的有fetch，pull，解决冲突等问题",
      "这些在本学期的软件构造中用不到，但在实际的多人协作中很常用",
      "以后有时间可能会讨论"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "在哈工大软件构造的几个实验（作业）中，均要求使用git管理项目配置。同时，建议使用eclipse IDE进行项目开发。如果使用eclipse自带的git插件，就不需要额外安装和使用git，在eclipse中一并管理，比较方便。本文将实例演示使用内置git工具管理项目的常用方法。\n步骤1 新建远程仓库\n在GitHub上创建远程仓库。软件构造课程的3个作业，只要点击链接，就可以自动生成仓库。在此我额外新建一个仓库作为演示。\n1.1 点击start a project\n1.2 填写仓库信息\n有仓库名和一些可选项。我选择添加README文件，因为如果仓库是空的，它不会生成默认分支，之后会有点麻烦。\n1.3 点击\"Create repository\"确认\n新建仓库完成后，应该看到这样的界面。\n1.4* 修改默认分支名为master\n点击分支按钮，再点 View all branches，再点击右侧的铅笔图标，则如下图所示。\n步骤2 在eclipse中引入项目\n2.1 从Git中引入\n打开eclipse，点击File->Import，选择Projects from Git (with smart import)，点击Next。\n2.2 选择Clone URI\n然后点击Next。\n2.3 填写相关信息\n先复制远程仓库的地址。\n再填写URI和自己的Github账号信息。Host和Repository Path会在填写URI后自动填写。勾选Store in Secure Store，就可以记住密码，以后不用每次输入。\n2.4 剩下的操作\n不断点击Next，再点Finish。完成的结果如下图。可以看到项目被引入工作空间了。\n2.5* 设置Java项目\n右键项目，选择Properties.\n选择Project Natures，Add Java，再点击OK和Apply and Close。\n再在build path中添加jdk和JUnit，具体操作略。\n步骤3 修改项目并提交到远程分支\n3.1 做出本地修改\n新建文件new，写入123.\n3.2 提交到本地仓库\n右键项目，选择Team->Commit...\n以下显示的是Git Staging。点击重叠的绿色加号，将修改放入stage。右侧是Commit Message。必须填入，否则不能提交。\n再点击右下角的Commit，即可提交。\n3.3 Push到远程仓库\n右键项目，选择Team->Push to Upstream\nPush成功后，会跳出如下窗口。\n也可以在commit步骤直接点击Commit and Push，一步到位。\n步骤4 创建和切换分支\n4.1 在远程仓库创建新分支change\n4.2 在本地仓库添加Upstream的分支\n右键->Team->Remote->Configure Fetch from Upstream...\n在Ref mappings中点击Add...，Source选择change，输入后会稍微加载一段时间。\n然后点击Next到Finish。\n4.3 新建并切换到本地分支change\n右键->Switch To->New Branch...\n填写name为change，完成。\n4.4 修改本地文件\n4.5 push到远程change分支\n先commit，然后设置Push Branch \"change\"...\n填入Branch名为change。\n再push就可以了。\n4.6 再切换回来\n步骤5 其它\n本文中没有提到的有fetch，pull，解决冲突等问题。这些在本学期的软件构造中用不到，但在实际的多人协作中很常用。以后有时间可能会讨论。\n"
  },
  {
    "head": "SC（三）",
    "paragraphs": [
      "重写（Override）和重载（Overload）",
      "重写（Override）",
      "重写是子类对父类允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。",
      "重写方法的spec保持不变/增强",
      "重写方法是子类对父类方法的修改/扩展，个性化过程",
      "final method不可被重写",
      "在运行时决定调用哪个方法",
      "重载（Overload）",
      "重载：在同一个类里面，相同的方法名，不同的参数列表。常见构造器的重载",
      "重载和重写是完全不同的，二者没有任何关系。",
      "参考资料：https://www.runoob.com/java/java-override-overload.html"
    ],
    "sentences": [
      "重写（Override）和重载（Overload）",
      "重写（Override）",
      "重写是子类对父类允许访问的方法的实现过程进行重新编写",
      "返回值和形参都不能改变",
      "重写方法的spec保持不变/增强",
      "重写方法是子类对父类方法的修改/扩展，个性化过程",
      "final method不可被重写",
      "在运行时决定调用哪个方法",
      "重载（Overload）",
      "重载：在同一个类里面，相同的方法名，不同的参数列表",
      "常见构造器的重载",
      "重载和重写是完全不同的，二者没有任何关系",
      "参考资料：https://www.runoob.com/java/java-override-overload.html"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "重写（Override）和重载（Overload）\n重写（Override）\n重写是子类对父类允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。\n重写方法的spec保持不变/增强\n重写方法是子类对父类方法的修改/扩展，个性化过程\nfinal method不可被重写\n在运行时决定调用哪个方法\n重载（Overload）\n重载：在同一个类里面，相同的方法名，不同的参数列表。常见构造器的重载\n重载和重写是完全不同的，二者没有任何关系。\n参考资料：https://www.runoob.com/java/java-override-overload.html\n"
  },
  {
    "head": "SC（四）",
    "paragraphs": [
      "两类ADT复用手段",
      "用于Class之间",
      "父类和子类之间的关系，通过extends产生继承关系",
      "子类可以直接访问父类中的非私有的属性和行为，无法继承父类中私有的内容",
      "一个类只能有一个直接父类，但多个类可以继承一个父类；可以多层继承，例如A -> B, B->C",
      "遵循LSP原则",
      "用于Object之间，运行时建立动态链接",
      "建立委派（rep 存储/不存储） -> 动态传入（client负责）-> 实际调用"
    ],
    "sentences": [
      "两类ADT复用手段",
      "用于Class之间",
      "父类和子类之间的关系，通过extends产生继承关系",
      "子类可以直接访问父类中的非私有的属性和行为",
      "无法继承父类中私有的内容",
      "一个类只能有一个直接父类",
      "但多个类可以继承一个父类；可以多层继承",
      "例如A -> B, B->C",
      "遵循LSP原则",
      "用于Object之间，运行时建立动态链接",
      "建立委派（rep 存储/不存储） -> 动态传入（client负责）-> 实际调用"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "两类ADT复用手段\n用于Class之间\n父类和子类之间的关系，通过extends产生继承关系\n子类可以直接访问父类中的非私有的属性和行为，无法继承父类中私有的内容\n一个类只能有一个直接父类，但多个类可以继承一个父类；可以多层继承，例如A -> B, B->C\n遵循LSP原则\n用于Object之间，运行时建立动态链接\n建立委派（rep 存储/不存储） -> 动态传入（client负责）-> 实际调用\n"
  },
  {
    "head": "SC（二）",
    "paragraphs": [
      "Iterator迭代器学习体会",
      "做Lab2的时候用到了，简单了解了一下Iterator的使用。",
      "Iterator可以遍历并选择列中的对象，在Java中只能单向移动",
      "（1）iterator()：返回一个Iterator。例：",
      "（2）next()：获得序列中的下一个元素。例：",
      "第一次调用Iterator的next()方法时，它返回序列的第一个元素。",
      "（3）hasNext()：检查序列中是否还有元素。例：",
      "(4) remove()：将迭代器新返回的元素删除"
    ],
    "sentences": [
      "Iterator迭代器学习体会",
      "做Lab2的时候用到了，简单了解了一下Iterator的使用",
      "Iterator可以遍历并选择列中的对象",
      "在Java中只能单向移动",
      "（1）iterator()：返回一个Iterator",
      "例：（2）next()：获得序列中的下一个元素",
      "例：第一次调用Iterator的next()方法时",
      "它返回序列的第一个元素",
      "（3）hasNext()：检查序列中是否还有元素",
      "例：(4) remove()：将迭代器新返回的元素删除"
    ],
    "codes": [
      "Iterator<Edge<L>> it = edges.iterator();\n",
      "Edge<L> a=it.next();\n",
      "while (it.hasNext()){\n            Edge<L> a=it.next();\n        }\n",
      "it.remove();\n",
      "Iterator<Edge<L>> it = edges.iterator();\n        while (it.hasNext()){\n            Edge<L> a=it.next();\n            if(){\n                flag = a.getWeight();\n                it.remove();\n                break;\n            }\n        }\n"
    ],
    "date": "2021-07-07",
    "text": "Iterator迭代器学习体会\n做Lab2的时候用到了，简单了解了一下Iterator的使用。\nIterator可以遍历并选择列中的对象，在Java中只能单向移动\n（1）iterator()：返回一个Iterator。例：\n（2）next()：获得序列中的下一个元素。例：\n第一次调用Iterator的next()方法时，它返回序列的第一个元素。\n（3）hasNext()：检查序列中是否还有元素。例：\n(4) remove()：将迭代器新返回的元素删除\n"
  },
  {
    "head": "关于Java中的异常处理控制流",
    "paragraphs": [
      "在软件构造实验中，我们使用java语言标准库的各种方法，时不时遇见Eclipse提示需要处理某某Exception。Eclipse一般会提示两种修改当前代码的方法以消除编译错误。一个是用try catch语句块包围可能抛出异常的代码，另一个是为当前正在编写的方法添加throws声明。两种方法是有区别，但是以前对此不清不楚。在做实验三的时候，因为代码需要，学习了一下，现在在这里记录一下。",
      "1. 对可能抛出异常的代码使用try-catch-finally语句包围。",
      "那些可能抛出异常的代码应该写在try中。",
      "catch可以有多个列在try后面，分别处理相应的异常。几个catch语句块是有顺序的，发生异常时从前往后寻找匹配异常的语句块。只会匹配并执行一个catch语句块，然后控制流离开catch们，继续往下执行（finally或方法中剩余内容），try中的剩余内容不会再执行了。",
      "若有两种异常需要处理，其中一个异常类型是另一个异常类型的子类型，那么子类型异常的特殊的处理得放在前面，对于其他父类型异常比较一般的处理就放在后面。如果",
      "catch(父类型异常){}",
      "catch(子类型异常){}",
      "之前，子类型异常的处理就总是会被截胡永远没机会执行了，会有编译错误提示这一点。",
      "finally语句块是总是要执行的内容，即有没有发生异常都要执行finally。finally理论上是保证只要执行了try，不管有没有执行catch，不管catch执行什么，finally语句块都执行。例如，catch中最后直接return，在真正离开本方法之前，还是会执行finally语句块，不过已经确定的返回值不会受到finally中相应赋值语句的影响。实际上有些情况会导致finally没机会执行，比如jvm进程已经在catch执行后结束了。",
      "2. 为当前方法添加throws声明。",
      "那些可能抛出异常的代码直接写在当前方法中即可。",
      "这会导致相应的异常转发到当前方法的调用者调用当前方法处抛出，由调用者决定如何处理。发生异常时，直接离开当前方法不再执行，控制流回到调用者调用这个方法的地方，并继续执行调用者方法中关于这个异常的处理逻辑。如果在调用链中每级方法都声明throws把异常处理推给上级，连main方法也如是，那么调用main方法的jvm内部逻辑会处理相关异常。",
      "实际上，关于异常处理还有很多细节。不过在实验三中知道这些就差不多了吧。。。"
    ],
    "sentences": [
      "在软件构造实验中",
      "我们使用java语言标准库的各种方法",
      "时不时遇见Eclipse提示需要处理某某Exception",
      "Eclipse一般会提示两种修改当前代码的方法以消除编译错误",
      "一个是用try catch语句块包围可能抛出异常的代码",
      "另一个是为当前正在编写的方法添加throws声明",
      "两种方法是有区别，但是以前对此不清不楚",
      "在做实验三的时候",
      "因为代码需要",
      "学习了一下",
      "现在在这里记录一下",
      "1. 对可能抛出异常的代码使用try-catch-finally语句包围",
      "那些可能抛出异常的代码应该写在try中",
      "catch可以有多个列在try后面，分别处理相应的异常",
      "几个catch语句块是有顺序的",
      "发生异常时从前往后寻找匹配异常的语句块",
      "只会匹配并执行一个catch语句块",
      "然后控制流离开catch们",
      "继续往下执行（finally或方法中剩余内容）",
      "try中的剩余内容不会再执行了",
      "若有两种异常需要处理",
      "其中一个异常类型是另一个异常类型的子类型",
      "那么子类型异常的特殊的处理得放在前面",
      "对于其他父类型异常比较一般的处理就放在后面",
      "如果",
      "catch(父类型异常){}",
      "catch(子类型异常){}",
      "之前",
      "子类型异常的处理就总是会被截胡永远没机会执行了",
      "会有编译错误提示这一点",
      "finally语句块是总是要执行的内容",
      "即有没有发生异常都要执行finally",
      "finally理论上是保证只要执行了try",
      "不管有没有执行catch",
      "不管catch执行什么",
      "finally语句块都执行",
      "例如",
      "catch中最后直接return",
      "在真正离开本方法之前",
      "还是会执行finally语句块",
      "不过已经确定的返回值不会受到finally中相应赋值语句的影响",
      "实际上有些情况会导致finally没机会执行",
      "比如jvm进程已经在catch执行后结束了",
      "2. 为当前方法添加throws声明",
      "那些可能抛出异常的代码直接写在当前方法中即可",
      "这会导致相应的异常转发到当前方法的调用者调用当前方法处抛出",
      "由调用者决定如何处理",
      "发生异常时",
      "直接离开当前方法不再执行",
      "控制流回到调用者调用这个方法的地方",
      "并继续执行调用者方法中关于这个异常的处理逻辑",
      "如果在调用链中每级方法都声明throws把异常处理推给上级",
      "连main方法也如是",
      "那么调用main方法的jvm内部逻辑会处理相关异常",
      "实际上，关于异常处理还有很多细节",
      "不过在实验三中知道这些就差不多了吧"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "在软件构造实验中，我们使用java语言标准库的各种方法，时不时遇见Eclipse提示需要处理某某Exception。Eclipse一般会提示两种修改当前代码的方法以消除编译错误。一个是用try catch语句块包围可能抛出异常的代码，另一个是为当前正在编写的方法添加throws声明。两种方法是有区别，但是以前对此不清不楚。在做实验三的时候，因为代码需要，学习了一下，现在在这里记录一下。\n1. 对可能抛出异常的代码使用try-catch-finally语句包围。\n那些可能抛出异常的代码应该写在try中。\ncatch可以有多个列在try后面，分别处理相应的异常。几个catch语句块是有顺序的，发生异常时从前往后寻找匹配异常的语句块。只会匹配并执行一个catch语句块，然后控制流离开catch们，继续往下执行（finally或方法中剩余内容），try中的剩余内容不会再执行了。\n若有两种异常需要处理，其中一个异常类型是另一个异常类型的子类型，那么子类型异常的特殊的处理得放在前面，对于其他父类型异常比较一般的处理就放在后面。如果\ncatch(父类型异常){}\ncatch(子类型异常){}\n之前，子类型异常的处理就总是会被截胡永远没机会执行了，会有编译错误提示这一点。\nfinally语句块是总是要执行的内容，即有没有发生异常都要执行finally。finally理论上是保证只要执行了try，不管有没有执行catch，不管catch执行什么，finally语句块都执行。例如，catch中最后直接return，在真正离开本方法之前，还是会执行finally语句块，不过已经确定的返回值不会受到finally中相应赋值语句的影响。实际上有些情况会导致finally没机会执行，比如jvm进程已经在catch执行后结束了。\n2. 为当前方法添加throws声明。\n那些可能抛出异常的代码直接写在当前方法中即可。\n这会导致相应的异常转发到当前方法的调用者调用当前方法处抛出，由调用者决定如何处理。发生异常时，直接离开当前方法不再执行，控制流回到调用者调用这个方法的地方，并继续执行调用者方法中关于这个异常的处理逻辑。如果在调用链中每级方法都声明throws把异常处理推给上级，连main方法也如是，那么调用main方法的jvm内部逻辑会处理相关异常。\n实际上，关于异常处理还有很多细节。不过在实验三中知道这些就差不多了吧。。。\n"
  },
  {
    "head": "关于Java中equals方法",
    "paragraphs": [
      "今天被这熟悉而又陌生的equals方法搞麻了。对于不可变类型，似乎还好，反正是不可变的，判断一下内容即可。主要是父类类型和子类类型之间做equals时，需要处理非常多的细节。但是把这种比较内容（也即是观察等价性）的想法用到可变类型上，可就掉坑里了。",
      "一般借java讲等价性，都会提到，java的容器类型都实现了观察等价性。由于容器都是mutable的，嵌套的HashSet<ArrayList<String>>会出bug：",
      "list并没有移除可是contains检测不到了。这是因为list被改变了，按其观察等价性的实现，hashcode也变了，contains计算哈希桶编号得到的不再是原来的那个保存着list的桶了，自然认为找不到list。麻了。",
      "在PPT上，关于这里，说java的观察等价性实现是不好的，应该使用行为等价性实现，即使用Object中引用等价性的实现。可是使用引用等价性完全不能反应这个ADT的任何特点，实际上没有任何意义。这样的equals实现无非是“不出bug”，并不能使它有意义地出现在HashSet中。在HashSet里出现两个地址不同但元素完全相同的东西看上去是荒谬的。目前java中的这些容器类型不能很好地容纳可变类型，主要还是在于不能随着元素变化自动调整容器自身，和equals怎样实现是没有关系的。无论是没有意义的引用等价性还是倒霉的观察等价性，都不能让容器正确地、反应ADT特性地容纳相关类型。搞坏了equals，再去弄一个same，similar之类的去判断ADT等价性属实麻了。",
      "最简单的规则还是禁止在容器中使用可变类型。实在需要在容器中使用可变类型，还是封装remove-add好一点。让equals做回自己吧。"
    ],
    "sentences": [
      "今天被这熟悉而又陌生的equals方法搞麻了",
      "对于不可变类型，似乎还好，反正是不可变的，判断一下内容即可",
      "主要是父类类型和子类类型之间做equals时",
      "需要处理非常多的细节",
      "但是把这种比较内容（也即是观察等价性）的想法用到可变类型上",
      "可就掉坑里了",
      "一般借java讲等价性",
      "都会提到",
      "java的容器类型都实现了观察等价性",
      "由于容器都是mutable的",
      "嵌套的HashSet<ArrayList<String>>会出bug：list并没有移除可是contains检测不到了",
      "这是因为list被改变了",
      "按其观察等价性的实现",
      "hashcode也变了",
      "contains计算哈希桶编号得到的不再是原来的那个保存着list的桶了",
      "自然认为找不到list",
      "麻了",
      "在PPT上",
      "关于这里",
      "说java的观察等价性实现是不好的",
      "应该使用行为等价性实现",
      "即使用Object中引用等价性的实现",
      "可是使用引用等价性完全不能反应这个ADT的任何特点",
      "实际上没有任何意义",
      "这样的equals实现无非是“不出bug”",
      "并不能使它有意义地出现在HashSet中",
      "在HashSet里出现两个地址不同但元素完全相同的东西看上去是荒谬的",
      "目前java中的这些容器类型不能很好地容纳可变类型",
      "主要还是在于不能随着元素变化自动调整容器自身",
      "和equals怎样实现是没有关系的",
      "无论是没有意义的引用等价性还是倒霉的观察等价性",
      "都不能让容器正确地、反应ADT特性地容纳相关类型",
      "搞坏了equals",
      "再去弄一个same",
      "similar之类的去判断ADT等价性属实麻了",
      "最简单的规则还是禁止在容器中使用可变类型",
      "实在需要在容器中使用可变类型",
      "还是封装remove-add好一点",
      "让equals做回自己吧"
    ],
    "codes": [
      "public static void main(String[] args) {\n    HashSet<ArrayList<String>> set = new HashSet<>();\n    ArrayList<String> list = new ArrayList<>();\n    list.add(\"A\");\n    set.add(list);\n    set.contains(list);  // return true\n    list.add(\"B\");\n    set.contains(list);  // return false\n}"
    ],
    "date": "2021-07-07",
    "text": "今天被这熟悉而又陌生的equals方法搞麻了。对于不可变类型，似乎还好，反正是不可变的，判断一下内容即可。主要是父类类型和子类类型之间做equals时，需要处理非常多的细节。但是把这种比较内容（也即是观察等价性）的想法用到可变类型上，可就掉坑里了。\n一般借java讲等价性，都会提到，java的容器类型都实现了观察等价性。由于容器都是mutable的，嵌套的HashSet<ArrayList<String>>会出bug：\nlist并没有移除可是contains检测不到了。这是因为list被改变了，按其观察等价性的实现，hashcode也变了，contains计算哈希桶编号得到的不再是原来的那个保存着list的桶了，自然认为找不到list。麻了。\n在PPT上，关于这里，说java的观察等价性实现是不好的，应该使用行为等价性实现，即使用Object中引用等价性的实现。可是使用引用等价性完全不能反应这个ADT的任何特点，实际上没有任何意义。这样的equals实现无非是“不出bug”，并不能使它有意义地出现在HashSet中。在HashSet里出现两个地址不同但元素完全相同的东西看上去是荒谬的。目前java中的这些容器类型不能很好地容纳可变类型，主要还是在于不能随着元素变化自动调整容器自身，和equals怎样实现是没有关系的。无论是没有意义的引用等价性还是倒霉的观察等价性，都不能让容器正确地、反应ADT特性地容纳相关类型。搞坏了equals，再去弄一个same，similar之类的去判断ADT等价性属实麻了。\n最简单的规则还是禁止在容器中使用可变类型。实在需要在容器中使用可变类型，还是封装remove-add好一点。让equals做回自己吧。\n"
  },
  {
    "head": "关于Java中方法的重写（Override）",
    "paragraphs": [
      "在java中，子类的非静态成员方法可以重写（Override）父类中的对应的方法。在使用父类引用调用相应的方法时，会根据运行时引用所指向的对象的实际类型动态调用子类或父类对应的方法，这就是多态了。软件构造课的考试题中有这样的题：",
      "考察什么是正确的重写。",
      "在java中，我们使用@Override注解让编译器为我们检查是否正确重写，编写子类时也是用IDE直接生成代码，因此有些细节就没有注意到，这里记录一下。",
      "0. 根据LSP规则，子类类型也是父类类型，需要父类类型的地方子类类型可以顶上去。因此，通过父类引用动态调用方法，调用的子类方法必须是兼容的。",
      "1. private方法不能参与重写。private完全是仅本类可见的，自然不能被其他类（包括子类、父类）感知，动态调用之类的显然也不行了。",
      "2. 子类方法或不throws任何异常，或throws父类方法所声明的那些异常。子类方法throws的异常类型可以是父类方法throws的异常类型的子类型，这很好理解，父类方法要求throws Exception，子类方法throws IOException，IOException也是EXception，因此子类方法满足了要求。",
      "3. 子类方法返回值类型必须也是父类方法返回值类型。也就是说，子类方法或返回一样的类型，或返回父类方法返回类型的子类型。这也很好理解，父类方法return Number，子类方法return Double，Double也是Number，因此子类方法满足了要求。",
      "理论上",
      "，根据LSP，还可以允许子类方法的参数类型是父类方法参数类型的父类型。即",
      "子类方法(List<?> scores)",
      "父类方法(ArrayList<?> scores)",
      "，因为ArrayList<?>也是List<?>，参数传递起来是兼容的。",
      "实际上",
      "，在java中不允许这种重写。这某种意义上说与java的另一个特性是有关的，即重载：java允许一系列同名但参数类型不完全相同的方法写在一个类，并在编译阶段根据实参类型确定某段代码中调用的一系列重载方法究竟是哪一个。如果允许前面说的这种重写，就会出现子类中可以有多个方法重写父类方法，这不是乱套了？因此java不允许这种重写。其实这一问题可以有多种方法解决，比如增加某种关键字，在子类中明确指定哪个方法重写父类的哪个方法，但是这样非常不简洁。实际上，java采用重写加重载可以达到类似的效果，即用",
      "子类方法(ArrayList<?> scores)",
      "父类方法(ArrayList<?> scores)",
      "，然后",
      "子类方法(ArrayList<?> scores)",
      "直接调用另一个重载",
      "子类方法(List<?> scores)",
      "，实际效果相当于",
      "子类方法(List<?> scores)",
      "父类方法(ArrayList<?> scores)"
    ],
    "sentences": [
      "在java中",
      "子类的非静态成员方法可以重写（Override）父类中的对应的方法",
      "在使用父类引用调用相应的方法时",
      "会根据运行时引用所指向的对象的实际类型动态调用子类或父类对应的方法",
      "这就是多态了",
      "软件构造课的考试题中有这样的题：考察什么是正确的重写",
      "在java中",
      "我们使用@Override注解让编译器为我们检查是否正确重写",
      "编写子类时也是用IDE直接生成代码",
      "因此有些细节就没有注意到",
      "这里记录一下",
      "0. 根据LSP规则",
      "子类类型也是父类类型",
      "需要父类类型的地方子类类型可以顶上去",
      "因此，通过父类引用动态调用方法，调用的子类方法必须是兼容的",
      "1. private方法不能参与重写",
      "private完全是仅本类可见的",
      "自然不能被其他类（包括子类、父类）感知",
      "动态调用之类的显然也不行了",
      "2. 子类方法或不throws任何异常",
      "或throws父类方法所声明的那些异常",
      "子类方法throws的异常类型可以是父类方法throws的异常类型的子类型",
      "这很好理解",
      "父类方法要求throws Exception",
      "子类方法throws IOException",
      "IOException也是EXception",
      "因此子类方法满足了要求",
      "3. 子类方法返回值类型必须也是父类方法返回值类型",
      "也就是说",
      "子类方法或返回一样的类型",
      "或返回父类方法返回类型的子类型",
      "这也很好理解",
      "父类方法return Number",
      "子类方法return Double",
      "Double也是Number",
      "因此子类方法满足了要求",
      "理论上",
      "",
      "根据LSP",
      "还可以允许子类方法的参数类型是父类方法参数类型的父类型",
      "即",
      "子类方法(List<?> scores)",
      "父类方法(ArrayList<?> scores)",
      "",
      "因为ArrayList<?>也是List<?>",
      "参数传递起来是兼容的",
      "实际上",
      "，在java中不允许这种重写",
      "这某种意义上说与java的另一个特性是有关的",
      "即重载：java允许一系列同名但参数类型不完全相同的方法写在一个类",
      "并在编译阶段根据实参类型确定某段代码中调用的一系列重载方法究竟是哪一个",
      "如果允许前面说的这种重写",
      "就会出现子类中可以有多个方法重写父类方法",
      "这不是乱套了？因此java不允许这种重写",
      "其实这一问题可以有多种方法解决",
      "比如增加某种关键字",
      "在子类中明确指定哪个方法重写父类的哪个方法",
      "但是这样非常不简洁",
      "实际上，java采用重写加重载可以达到类似的效果，即用",
      "子类方法(ArrayList<?> scores)",
      "父类方法(ArrayList<?> scores)",
      "，然后",
      "子类方法(ArrayList<?> scores)",
      "直接调用另一个重载",
      "子类方法(List<?> scores)",
      "，实际效果相当于",
      "子类方法(List<?> scores)",
      "父类方法(ArrayList<?> scores)"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "在java中，子类的非静态成员方法可以重写（Override）父类中的对应的方法。在使用父类引用调用相应的方法时，会根据运行时引用所指向的对象的实际类型动态调用子类或父类对应的方法，这就是多态了。软件构造课的考试题中有这样的题：\n考察什么是正确的重写。\n在java中，我们使用@Override注解让编译器为我们检查是否正确重写，编写子类时也是用IDE直接生成代码，因此有些细节就没有注意到，这里记录一下。\n0. 根据LSP规则，子类类型也是父类类型，需要父类类型的地方子类类型可以顶上去。因此，通过父类引用动态调用方法，调用的子类方法必须是兼容的。\n1. private方法不能参与重写。private完全是仅本类可见的，自然不能被其他类（包括子类、父类）感知，动态调用之类的显然也不行了。\n2. 子类方法或不throws任何异常，或throws父类方法所声明的那些异常。子类方法throws的异常类型可以是父类方法throws的异常类型的子类型，这很好理解，父类方法要求throws Exception，子类方法throws IOException，IOException也是EXception，因此子类方法满足了要求。\n3. 子类方法返回值类型必须也是父类方法返回值类型。也就是说，子类方法或返回一样的类型，或返回父类方法返回类型的子类型。这也很好理解，父类方法return Number，子类方法return Double，Double也是Number，因此子类方法满足了要求。\n理论上\n，根据LSP，还可以允许子类方法的参数类型是父类方法参数类型的父类型。即\n子类方法(List<?> scores)\n父类方法(ArrayList<?> scores)\n，因为ArrayList<?>也是List<?>，参数传递起来是兼容的。\n实际上\n，在java中不允许这种重写。这某种意义上说与java的另一个特性是有关的，即重载：java允许一系列同名但参数类型不完全相同的方法写在一个类，并在编译阶段根据实参类型确定某段代码中调用的一系列重载方法究竟是哪一个。如果允许前面说的这种重写，就会出现子类中可以有多个方法重写父类方法，这不是乱套了？因此java不允许这种重写。其实这一问题可以有多种方法解决，比如增加某种关键字，在子类中明确指定哪个方法重写父类的哪个方法，但是这样非常不简洁。实际上，java采用重写加重载可以达到类似的效果，即用\n子类方法(ArrayList<?> scores)\n父类方法(ArrayList<?> scores)\n，然后\n子类方法(ArrayList<?> scores)\n直接调用另一个重载\n子类方法(List<?> scores)\n，实际效果相当于\n子类方法(List<?> scores)\n父类方法(ArrayList<?> scores)\n"
  },
  {
    "head": "【软件构造】Maven的使用",
    "paragraphs": [
      "Maven是一个比较好用的配置管理工具。当你的程序需要多个配置项时，可以去他的官方网站，找到对应的版本，把对应的脚本粘贴到你的配置文件当中。它会自动下载。它还可以管理你程序的生命周期，无论你是要编译、生成文档、发布、测试、运行，你只需要配置好对应的脚本，运行脚本即可自动完成。",
      "1.首先，在工程的根目录下创建一个pom.xml",
      "2.配置依赖项，这一部分代码可以从",
      "https://mvnrepository.com/",
      "上查找。比如我们要引入log4j2、junit4的依赖",
      "3.配置源文件夹、测试文件夹，这一部分放进<build>标签中",
      "4.配置编译插件，放在<build><plugins>里，注意，maven默认的jdk版本是1.7，很多情况下需要改成1.8及以上版本",
      "5.配置其他部分的插件，要放进对应的标签中，比如这里的spotBugs插件",
      "6.要进行某些生命周期的操作，我们可以通过maven的命令行参数执行，也可用ide",
      "7.执行complile，可以看到对应的结果"
    ],
    "sentences": [
      "Maven是一个比较好用的配置管理工具",
      "当你的程序需要多个配置项时",
      "可以去他的官方网站",
      "找到对应的版本",
      "把对应的脚本粘贴到你的配置文件当中",
      "它会自动下载",
      "它还可以管理你程序的生命周期",
      "无论你是要编译、生成文档、发布、测试、运行",
      "你只需要配置好对应的脚本",
      "运行脚本即可自动完成",
      "1.首先，在工程的根目录下创建一个pom.xml",
      "2.配置依赖项，这一部分代码可以从",
      "https://mvnrepository.com/",
      "上查找",
      "比如我们要引入log4j2、junit4的依赖",
      "3.配置源文件夹、测试文件夹",
      "这一部分放进<build>标签中",
      "4.配置编译插件",
      "放在<build><plugins>里",
      "注意",
      "maven默认的jdk版本是1.7",
      "很多情况下需要改成1.8及以上版本",
      "5.配置其他部分的插件",
      "要放进对应的标签中",
      "比如这里的spotBugs插件",
      "6.要进行某些生命周期的操作",
      "我们可以通过maven的命令行参数执行",
      "也可用ide",
      "7.执行complile，可以看到对应的结果"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "Maven是一个比较好用的配置管理工具。当你的程序需要多个配置项时，可以去他的官方网站，找到对应的版本，把对应的脚本粘贴到你的配置文件当中。它会自动下载。它还可以管理你程序的生命周期，无论你是要编译、生成文档、发布、测试、运行，你只需要配置好对应的脚本，运行脚本即可自动完成。\n1.首先，在工程的根目录下创建一个pom.xml\n2.配置依赖项，这一部分代码可以从\nhttps://mvnrepository.com/\n上查找。比如我们要引入log4j2、junit4的依赖\n3.配置源文件夹、测试文件夹，这一部分放进<build>标签中\n4.配置编译插件，放在<build><plugins>里，注意，maven默认的jdk版本是1.7，很多情况下需要改成1.8及以上版本\n5.配置其他部分的插件，要放进对应的标签中，比如这里的spotBugs插件\n6.要进行某些生命周期的操作，我们可以通过maven的命令行参数执行，也可用ide\n7.执行complile，可以看到对应的结果\n"
  },
  {
    "head": "【软件构造】使用JUnit进行单元测试",
    "paragraphs": [
      "JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。",
      "1.可以书写一系列的测试方法，对项目所有的接口或者方法进行单元测试。",
      "2.启动后，自动化测试，并判断执行结果, 不需要人为的干预。",
      "3.只需要查看最后结果，就知道整个项目的方法接口是否通畅。",
      "4.每个单元测试用例相对独立，由Junit 启动，自动调用。不需要添加额外的调用语句。",
      "5.添加，删除，屏蔽测试方法，不影响其他的测试方法。 开源框架都对JUnit 有相应的支持。",
      "环境配置",
      "从官网",
      "http://www.junit.org",
      "下载 JUnit 最新版本的压缩文件。",
      "JUnit 断言",
      "Junit所有的断言都包含在 Assert 类中。",
      "这个类提供了很多有用的断言方法来编写测试用例。只有失败的断言才会被记录。Assert 类中的一些有用的方法列式如下：",
      "void assertEquals(boolean expected, boolean actual)",
      ":检查两个变量或者等式是否平衡",
      "void assertTrue(boolean expected, boolean actual)",
      ":检查条件为真",
      "void assertFalse(boolean condition)",
      ":检查条件为假",
      "void assertNotNull(Object object)",
      ":检查对象不为空",
      "void assertNull(Object object)",
      ":检查对象为空",
      "void assertSame(boolean condition)",
      ":assertSame() 方法检查两个相关对象是否指向同一个对象",
      "void assertNotSame(boolean condition)",
      ":assertNotSame() 方法检查两个相关对象是否不指向同一个对象",
      "void assertArrayEquals(expectedArray, resultArray)",
      ":assertArrayEquals() 方法检查两个数组是否相等",
      "JUnit 注解",
      "@Test",
      ":这个注释说明依附在 JUnit 的 public void 方法可以作为一个测试案例。",
      "@Before",
      ":有些测试在运行前需要创造几个相似的对象。在 public void 方法加该注释是因为该方法需要在 test 方法前运行。",
      "@After",
      ":如果你将外部资源在 Before 方法中分配，那么你需要在测试运行后释放他们。在 public void 方法加该注释是因为该方法需要在 test 方法后运行。",
      "@BeforeClass",
      ":在 public void 方法加该注释是因为该方法需要在类中所有方法前运行。",
      "@AfterClass",
      ":它将会使方法在所有测试结束后执行。这个可以用来进行清理活动。",
      "@Ignore",
      ":这个注释是用来忽略有关不需要执行的测试的。",
      "JUnit 加注解执行过程",
      "beforeClass()",
      ": 方法首先执行，并且只执行一次。",
      "afterClass()",
      ":方法最后执行，并且只执行一次。",
      "before()",
      ":方法针对每一个测试用例执行，但是是在执行测试用例之前。",
      "after()",
      ":方法针对每一个测试用例执行，但是是在执行测试用例之后。",
      "在 before() 方法和 after() 方法之间，执行每一个测试用例。",
      "JUnit 执行测试",
      "测试用例是使用 JUnitCore 类来执行的。JUnitCore 是运行测试的外观类。要从命令行运行测试，可以运行",
      "java org.junit.runner.JUnitCore",
      "。对于只有一次的测试运行，可以使用静态方法",
      "runClasses(Class[])",
      "JUnit 参数化测试",
      "Junit 4 引入了一个新的功能参数化测试。参数化测试允许开发人员使用不同的值反复运行同一个测试。你将遵循 5 个步骤来创建参数化测试。",
      "@RunWith(Parameterized.class)",
      "来注释 test 类。",
      "创建一个由",
      "@Parameters",
      "注释的公共的静态方法，它返回一个对象的集合(数组)来作为测试数据集合。",
      "创建一个公共的构造函数，它接受和一行测试数据相等同的东西。",
      "为每一列测试数据创建一个实例变量。",
      "用实例变量作为测试数据的来源来创建你的测试用例。",
      "一旦每一行数据出现测试用例将被调用。"
    ],
    "sentences": [
      "JUnit 是一个 Java 编程语言的单元测试框架",
      "JUnit 在测试驱动的开发方面有很重要的发展",
      "是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一",
      "1.可以书写一系列的测试方法",
      "对项目所有的接口或者方法进行单元测试",
      "2.启动后，自动化测试，并判断执行结果, 不需要人为的干预",
      "3.只需要查看最后结果，就知道整个项目的方法接口是否通畅",
      "4.每个单元测试用例相对独立，由Junit 启动，自动调用",
      "不需要添加额外的调用语句",
      "5.添加，删除，屏蔽测试方法，不影响其他的测试方法",
      " 开源框架都对JUnit 有相应的支持",
      "环境配置",
      "从官网",
      "http://www.junit.org",
      "下载 JUnit 最新版本的压缩文件",
      "JUnit 断言",
      "Junit所有的断言都包含在 Assert 类中",
      "这个类提供了很多有用的断言方法来编写测试用例",
      "只有失败的断言才会被记录",
      "Assert 类中的一些有用的方法列式如下：void assertEquals(boolean expected, boolean actual)",
      ":检查两个变量或者等式是否平衡",
      "void assertTrue(boolean expected, boolean actual)",
      ":检查条件为真",
      "void assertFalse(boolean condition)",
      ":检查条件为假",
      "void assertNotNull(Object object)",
      ":检查对象不为空",
      "void assertNull(Object object)",
      ":检查对象为空",
      "void assertSame(boolean condition)",
      ":assertSame() 方法检查两个相关对象是否指向同一个对象",
      "void assertNotSame(boolean condition)",
      ":assertNotSame() 方法检查两个相关对象是否不指向同一个对象",
      "void assertArrayEquals(expectedArray, resultArray)",
      ":assertArrayEquals() 方法检查两个数组是否相等",
      "JUnit 注解",
      "@Test",
      ":这个注释说明依附在 JUnit 的 public void 方法可以作为一个测试案例",
      "@Before",
      ":有些测试在运行前需要创造几个相似的对象",
      "在 public void 方法加该注释是因为该方法需要在 test 方法前运行",
      "@After",
      ":如果你将外部资源在 Before 方法中分配",
      "那么你需要在测试运行后释放他们",
      "在 public void 方法加该注释是因为该方法需要在 test 方法后运行",
      "@BeforeClass",
      ":在 public void 方法加该注释是因为该方法需要在类中所有方法前运行",
      "@AfterClass",
      ":它将会使方法在所有测试结束后执行",
      "这个可以用来进行清理活动",
      "@Ignore",
      ":这个注释是用来忽略有关不需要执行的测试的",
      "JUnit 加注解执行过程",
      "beforeClass()",
      ": 方法首先执行，并且只执行一次",
      "afterClass()",
      ":方法最后执行，并且只执行一次",
      "before()",
      ":方法针对每一个测试用例执行，但是是在执行测试用例之前",
      "after()",
      ":方法针对每一个测试用例执行，但是是在执行测试用例之后",
      "在 before() 方法和 after() 方法之间",
      "执行每一个测试用例",
      "JUnit 执行测试",
      "测试用例是使用 JUnitCore 类来执行的",
      "JUnitCore 是运行测试的外观类",
      "要从命令行运行测试，可以运行",
      "java org.junit.runner.JUnitCore",
      "对于只有一次的测试运行，可以使用静态方法",
      "runClasses(Class[])",
      "JUnit 参数化测试",
      "Junit 4 引入了一个新的功能参数化测试",
      "参数化测试允许开发人员使用不同的值反复运行同一个测试",
      "你将遵循 5 个步骤来创建参数化测试",
      "@RunWith(Parameterized.class)",
      "来注释 test 类",
      "创建一个由",
      "@Parameters",
      "注释的公共的静态方法",
      "它返回一个对象的集合(数组)来作为测试数据集合",
      "创建一个公共的构造函数，它接受和一行测试数据相等同的东西",
      "为每一列测试数据创建一个实例变量",
      "用实例变量作为测试数据的来源来创建你的测试用例",
      "一旦每一行数据出现测试用例将被调用"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。\n1.可以书写一系列的测试方法，对项目所有的接口或者方法进行单元测试。\n2.启动后，自动化测试，并判断执行结果, 不需要人为的干预。\n3.只需要查看最后结果，就知道整个项目的方法接口是否通畅。\n4.每个单元测试用例相对独立，由Junit 启动，自动调用。不需要添加额外的调用语句。\n5.添加，删除，屏蔽测试方法，不影响其他的测试方法。 开源框架都对JUnit 有相应的支持。\n环境配置\n从官网\nhttp://www.junit.org\n下载 JUnit 最新版本的压缩文件。\nJUnit 断言\nJunit所有的断言都包含在 Assert 类中。\n这个类提供了很多有用的断言方法来编写测试用例。只有失败的断言才会被记录。Assert 类中的一些有用的方法列式如下：\nvoid assertEquals(boolean expected, boolean actual)\n:检查两个变量或者等式是否平衡\nvoid assertTrue(boolean expected, boolean actual)\n:检查条件为真\nvoid assertFalse(boolean condition)\n:检查条件为假\nvoid assertNotNull(Object object)\n:检查对象不为空\nvoid assertNull(Object object)\n:检查对象为空\nvoid assertSame(boolean condition)\n:assertSame() 方法检查两个相关对象是否指向同一个对象\nvoid assertNotSame(boolean condition)\n:assertNotSame() 方法检查两个相关对象是否不指向同一个对象\nvoid assertArrayEquals(expectedArray, resultArray)\n:assertArrayEquals() 方法检查两个数组是否相等\nJUnit 注解\n@Test\n:这个注释说明依附在 JUnit 的 public void 方法可以作为一个测试案例。\n@Before\n:有些测试在运行前需要创造几个相似的对象。在 public void 方法加该注释是因为该方法需要在 test 方法前运行。\n@After\n:如果你将外部资源在 Before 方法中分配，那么你需要在测试运行后释放他们。在 public void 方法加该注释是因为该方法需要在 test 方法后运行。\n@BeforeClass\n:在 public void 方法加该注释是因为该方法需要在类中所有方法前运行。\n@AfterClass\n:它将会使方法在所有测试结束后执行。这个可以用来进行清理活动。\n@Ignore\n:这个注释是用来忽略有关不需要执行的测试的。\nJUnit 加注解执行过程\nbeforeClass()\n: 方法首先执行，并且只执行一次。\nafterClass()\n:方法最后执行，并且只执行一次。\nbefore()\n:方法针对每一个测试用例执行，但是是在执行测试用例之前。\nafter()\n:方法针对每一个测试用例执行，但是是在执行测试用例之后。\n在 before() 方法和 after() 方法之间，执行每一个测试用例。\nJUnit 执行测试\n测试用例是使用 JUnitCore 类来执行的。JUnitCore 是运行测试的外观类。要从命令行运行测试，可以运行\njava org.junit.runner.JUnitCore\n。对于只有一次的测试运行，可以使用静态方法\nrunClasses(Class[])\nJUnit 参数化测试\nJunit 4 引入了一个新的功能参数化测试。参数化测试允许开发人员使用不同的值反复运行同一个测试。你将遵循 5 个步骤来创建参数化测试。\n@RunWith(Parameterized.class)\n来注释 test 类。\n创建一个由\n@Parameters\n注释的公共的静态方法，它返回一个对象的集合(数组)来作为测试数据集合。\n创建一个公共的构造函数，它接受和一行测试数据相等同的东西。\n为每一列测试数据创建一个实例变量。\n用实例变量作为测试数据的来源来创建你的测试用例。\n一旦每一行数据出现测试用例将被调用。\n"
  },
  {
    "head": "【软件构造】Git的使用",
    "paragraphs": [
      "1.什么是Git?",
      "是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。",
      "2.目录结构",
      "假如现在有一个工程被git管理，它分为三个部分：本地工作区，本地版本库（CMDB）的远程版本库。其中本地版本库有一个暂存区。",
      "本地工作区就是你的工程所对应的本地文件夹",
      "本地版本库是工作区（本地文件夹）下的.git隐藏文件夹。",
      "远程版本库是你的工程在网络上的备份。",
      "3.文件",
      "文件时Git的基本配置项SCI（软件中发生变化的基本单元）",
      "当一个文件被创建或者修改时，它与本地版本库中的相应文件不一样了，此时它处于“已修改”状态。",
      "已修改的文件，可以通过git add命令，添加到暂存区，此时它处于“已暂存”状态。",
      "已暂存的文件，可以通过git commit，把暂存区的文件汇总成一个commit，然后提交到本地版本库，此时它处于“已提交“”状态。",
      "也可以通过git commit -a命令将已修改的文件提交commit。",
      "4.操作",
      "git status可以查看当前工作目录的状态。",
      "显示出来的文件总共有三种状态分别是",
      "1.已添加至暂存区，未提交的（add后未commit的文件）",
      "2.已修改，未暂存的",
      "3.为追踪到的文件",
      "git diff比较暂存区和工作区的文件的差异",
      "git diff HEAD可以查看某个commit中的文件和当前工作区中的文件的差别",
      "想要把本地的提交记录提交到远程，可以执行git push命令。",
      "如果要把远程的提交记录拉回到本地，可以执行git fetch命令。",
      "如果要把远程的工程下载到本地，可以执行git clone命令",
      "如果要把远程工程拉到本地，并且立即和自己的本地版本合并，可以用git pull命令。",
      "要撤销本地工作区到暂存区的更改，可以用git reset<file>",
      "要撤销commit，可以用git reset<commit>",
      "5.分支",
      "使用分支，相当于从现有的版本线上又分出来一条，可以加一些和以前不一样的版本分别管理，还可以合并，非常方便。",
      "一次只能在一个分支上工作，要跳转分支，需要git checkout <branch>",
      "要创建新分支，可以用git checkout -b <branch>",
      "如果两个分支有共同的祖先，在某个时刻可以把这个有共同祖先的分支和自己合并，命令是git merge <branch>",
      "6.总结（github官方的cheatsheet）",
      "安装Git",
      "GitHub提供了包含图形界面的桌面客户端，通过客户端可以完成大部分常用的仓库操作，同时可以自动更新Git的命令行版本，以适应新的场景。",
      "GitHub Desktop",
      "https://desktop.github.com/",
      "GitHub的Linux和POSIX版本可以在官方的Git SCM网站上获取。",
      "Git 全平台版",
      "http://git-scm.com",
      "配置工具",
      "对所有本地仓库的用户信息进行配置",
      "$ git config --global user.name \"[name]\"",
      "对你的commit操作设置关联的用户名",
      "$ git config --global user.email \"[email address]\"",
      "对你的commit操作设置关联的邮箱地址",
      "创建仓库",
      "创建一个新的仓库或者从一个现有的链接获取仓库",
      "$ git init [project-name]",
      "创建一个本地的仓库，并设置名字",
      "$ git clone [url]",
      "下载一个项目以及它所有的版本历史",
      "检查已有的编辑并执行commit操作",
      "$ git status",
      "列出所有新建或者更改的文件，这些文件需要被commit",
      "$ git diff",
      "展示那些没有暂存文件的差异",
      "$ git add [file]",
      "将文件进行快照处理用于版本控制",
      "$ git diff --staged",
      "展示暂存文件与最新版本之间的不同",
      "$ git reset [file]",
      "将文件移除暂存区，但是保留其内容",
      "$ git commit -m\"[descriptive message]\"",
      "将文件快照永久地记录在版本历史中",
      "批量更改",
      "命名一系列commit以及合并已完成的工作",
      "$ git branch",
      "列出当前仓库中所有的本地分支",
      "$ git branch [branch-name]",
      "建立一个新分支",
      "$ git checkout [branch-name]",
      "切换到一个特定的分支上并更新工作目录",
      "$ git merge [branch-name]",
      "合并特定分支的历史到当前分支",
      "$ git branch -d [branch-name]",
      "删除特定的分支",
      "重构文件",
      "重定位并移除版本文件",
      "$ git rm [file]",
      "从工作目录中删除文件并暂存此删除",
      "$ git rm --cached [file]",
      "从版本控制中移除文件，并在本地保存文件",
      "$ git mv [file-original] [file-renamed]",
      "改变文件名并准备commit",
      "保存临时更改",
      "暂存一些未完成的更改",
      "$ git stash",
      "临时存储所有修改的已跟踪文件",
      "$ git stash pop",
      "重新存储所有最近被stash的文件",
      "$ git stash list",
      "列出所有被stash的更改",
      "$ git stash drop",
      "放弃所有最近stash的更改",
      "查阅历史",
      "浏览并检查项目文件的发展",
      "$ git log",
      "列出当前分支的版本历史",
      "$ git log --follow [file]",
      "列出文件的版本历史，包括重命名",
      "$ git diff [first-branch]...[second-branch]",
      "展示两个不同分支之间的差异",
      "$ git show [commit]",
      "输出元数据以及特定commit的内容变化",
      "撤销commit",
      "擦除错误并更改历史",
      "$ git reset [commit]",
      "撤销所有",
      "[commit]",
      "后的的commit，在本地保存更改",
      "$ git reset --hard [commit]",
      "放弃所有更改并回到某个特定的commit",
      "同步更改",
      "注册一个远程的链接，交换仓库的版本历史",
      "$ git fetch [remote]",
      "下载远程仓库的所有历史",
      "$ git merge [remote]/[branch]",
      "合并远程分支到当前本地分支",
      "$ git push [remote] [branch]",
      "上传所有本地分支commit到GitHub上",
      "$ git pull",
      "下载书签历史并合并更改"
    ],
    "sentences": [
      "1.什么是Git?",
      "是一个开源的分布式版本控制系统",
      "可以有效、高速地处理从很小到非常大的项目版本管理",
      "2.目录结构",
      "假如现在有一个工程被git管理",
      "它分为三个部分：本地工作区",
      "本地版本库（CMDB）的远程版本库",
      "其中本地版本库有一个暂存区",
      "本地工作区就是你的工程所对应的本地文件夹",
      "本地版本库是工作区（本地文件夹）下的.git隐藏文件夹",
      "远程版本库是你的工程在网络上的备份",
      "3.文件",
      "文件时Git的基本配置项SCI（软件中发生变化的基本单元）",
      "当一个文件被创建或者修改时",
      "它与本地版本库中的相应文件不一样了",
      "此时它处于“已修改”状态",
      "已修改的文件",
      "可以通过git add命令",
      "添加到暂存区",
      "此时它处于“已暂存”状态",
      "已暂存的文件",
      "可以通过git commit",
      "把暂存区的文件汇总成一个commit",
      "然后提交到本地版本库",
      "此时它处于“已提交“”状态",
      "也可以通过git commit -a命令将已修改的文件提交commit",
      "4.操作",
      "git status可以查看当前工作目录的状态",
      "显示出来的文件总共有三种状态分别是",
      "1.已添加至暂存区，未提交的（add后未commit的文件）",
      "2.已修改，未暂存的",
      "3.为追踪到的文件",
      "git diff比较暂存区和工作区的文件的差异",
      "git diff HEAD可以查看某个commit中的文件和当前工作区中的文件的差别",
      "想要把本地的提交记录提交到远程，可以执行git push命令",
      "如果要把远程的提交记录拉回到本地",
      "可以执行git fetch命令",
      "如果要把远程的工程下载到本地，可以执行git clone命令",
      "如果要把远程工程拉到本地",
      "并且立即和自己的本地版本合并",
      "可以用git pull命令",
      "要撤销本地工作区到暂存区的更改",
      "可以用git reset<file>",
      "要撤销commit，可以用git reset<commit>",
      "5.分支",
      "使用分支",
      "相当于从现有的版本线上又分出来一条",
      "可以加一些和以前不一样的版本分别管理",
      "还可以合并",
      "非常方便",
      "一次只能在一个分支上工作",
      "要跳转分支",
      "需要git checkout <branch>",
      "要创建新分支",
      "可以用git checkout -b <branch>",
      "如果两个分支有共同的祖先",
      "在某个时刻可以把这个有共同祖先的分支和自己合并",
      "命令是git merge <branch>",
      "6.总结（github官方的cheatsheet）",
      "安装Git",
      "GitHub提供了包含图形界面的桌面客户端",
      "通过客户端可以完成大部分常用的仓库操作",
      "同时可以自动更新Git的命令行版本",
      "以适应新的场景",
      "GitHub Desktop",
      "https://desktop.github.com/",
      "GitHub的Linux和POSIX版本可以在官方的Git SCM网站上获取",
      "Git 全平台版",
      "http://git-scm.com",
      "配置工具",
      "对所有本地仓库的用户信息进行配置",
      "$ git config --global user.name \"[name]\"",
      "对你的commit操作设置关联的用户名",
      "$ git config --global user.email \"[email address]\"",
      "对你的commit操作设置关联的邮箱地址",
      "创建仓库",
      "创建一个新的仓库或者从一个现有的链接获取仓库",
      "$ git init [project-name]",
      "创建一个本地的仓库，并设置名字",
      "$ git clone [url]",
      "下载一个项目以及它所有的版本历史",
      "检查已有的编辑并执行commit操作",
      "$ git status",
      "列出所有新建或者更改的文件，这些文件需要被commit",
      "$ git diff",
      "展示那些没有暂存文件的差异",
      "$ git add [file]",
      "将文件进行快照处理用于版本控制",
      "$ git diff --staged",
      "展示暂存文件与最新版本之间的不同",
      "$ git reset [file]",
      "将文件移除暂存区，但是保留其内容",
      "$ git commit -m\"[descriptive message]\"",
      "将文件快照永久地记录在版本历史中",
      "批量更改",
      "命名一系列commit以及合并已完成的工作",
      "$ git branch",
      "列出当前仓库中所有的本地分支",
      "$ git branch [branch-name]",
      "建立一个新分支",
      "$ git checkout [branch-name]",
      "切换到一个特定的分支上并更新工作目录",
      "$ git merge [branch-name]",
      "合并特定分支的历史到当前分支",
      "$ git branch -d [branch-name]",
      "删除特定的分支",
      "重构文件",
      "重定位并移除版本文件",
      "$ git rm [file]",
      "从工作目录中删除文件并暂存此删除",
      "$ git rm --cached [file]",
      "从版本控制中移除文件，并在本地保存文件",
      "$ git mv [file-original] [file-renamed]",
      "改变文件名并准备commit",
      "保存临时更改",
      "暂存一些未完成的更改",
      "$ git stash",
      "临时存储所有修改的已跟踪文件",
      "$ git stash pop",
      "重新存储所有最近被stash的文件",
      "$ git stash list",
      "列出所有被stash的更改",
      "$ git stash drop",
      "放弃所有最近stash的更改",
      "查阅历史",
      "浏览并检查项目文件的发展",
      "$ git log",
      "列出当前分支的版本历史",
      "$ git log --follow [file]",
      "列出文件的版本历史，包括重命名",
      "$ git diff [first-branch]...[second-branch]",
      "展示两个不同分支之间的差异",
      "$ git show [commit]",
      "输出元数据以及特定commit的内容变化",
      "撤销commit",
      "擦除错误并更改历史",
      "$ git reset [commit]",
      "撤销所有",
      "[commit]",
      "后的的commit，在本地保存更改",
      "$ git reset --hard [commit]",
      "放弃所有更改并回到某个特定的commit",
      "同步更改",
      "注册一个远程的链接，交换仓库的版本历史",
      "$ git fetch [remote]",
      "下载远程仓库的所有历史",
      "$ git merge [remote]/[branch]",
      "合并远程分支到当前本地分支",
      "$ git push [remote] [branch]",
      "上传所有本地分支commit到GitHub上",
      "$ git pull",
      "下载书签历史并合并更改"
    ],
    "codes": [],
    "date": "2021-07-05",
    "text": "1.什么是Git?\n是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。\n2.目录结构\n假如现在有一个工程被git管理，它分为三个部分：本地工作区，本地版本库（CMDB）的远程版本库。其中本地版本库有一个暂存区。\n本地工作区就是你的工程所对应的本地文件夹\n本地版本库是工作区（本地文件夹）下的.git隐藏文件夹。\n远程版本库是你的工程在网络上的备份。\n3.文件\n文件时Git的基本配置项SCI（软件中发生变化的基本单元）\n当一个文件被创建或者修改时，它与本地版本库中的相应文件不一样了，此时它处于“已修改”状态。\n已修改的文件，可以通过git add命令，添加到暂存区，此时它处于“已暂存”状态。\n已暂存的文件，可以通过git commit，把暂存区的文件汇总成一个commit，然后提交到本地版本库，此时它处于“已提交“”状态。\n也可以通过git commit -a命令将已修改的文件提交commit。\n4.操作\ngit status可以查看当前工作目录的状态。\n显示出来的文件总共有三种状态分别是\n1.已添加至暂存区，未提交的（add后未commit的文件）\n2.已修改，未暂存的\n3.为追踪到的文件\ngit diff比较暂存区和工作区的文件的差异\ngit diff HEAD可以查看某个commit中的文件和当前工作区中的文件的差别\n想要把本地的提交记录提交到远程，可以执行git push命令。\n如果要把远程的提交记录拉回到本地，可以执行git fetch命令。\n如果要把远程的工程下载到本地，可以执行git clone命令\n如果要把远程工程拉到本地，并且立即和自己的本地版本合并，可以用git pull命令。\n要撤销本地工作区到暂存区的更改，可以用git reset<file>\n要撤销commit，可以用git reset<commit>\n5.分支\n使用分支，相当于从现有的版本线上又分出来一条，可以加一些和以前不一样的版本分别管理，还可以合并，非常方便。\n一次只能在一个分支上工作，要跳转分支，需要git checkout <branch>\n要创建新分支，可以用git checkout -b <branch>\n如果两个分支有共同的祖先，在某个时刻可以把这个有共同祖先的分支和自己合并，命令是git merge <branch>\n6.总结（github官方的cheatsheet）\n安装Git\nGitHub提供了包含图形界面的桌面客户端，通过客户端可以完成大部分常用的仓库操作，同时可以自动更新Git的命令行版本，以适应新的场景。\nGitHub Desktop\nhttps://desktop.github.com/\nGitHub的Linux和POSIX版本可以在官方的Git SCM网站上获取。\nGit 全平台版\nhttp://git-scm.com\n配置工具\n对所有本地仓库的用户信息进行配置\n$ git config --global user.name \"[name]\"\n对你的commit操作设置关联的用户名\n$ git config --global user.email \"[email address]\"\n对你的commit操作设置关联的邮箱地址\n创建仓库\n创建一个新的仓库或者从一个现有的链接获取仓库\n$ git init [project-name]\n创建一个本地的仓库，并设置名字\n$ git clone [url]\n下载一个项目以及它所有的版本历史\n检查已有的编辑并执行commit操作\n$ git status\n列出所有新建或者更改的文件，这些文件需要被commit\n$ git diff\n展示那些没有暂存文件的差异\n$ git add [file]\n将文件进行快照处理用于版本控制\n$ git diff --staged\n展示暂存文件与最新版本之间的不同\n$ git reset [file]\n将文件移除暂存区，但是保留其内容\n$ git commit -m\"[descriptive message]\"\n将文件快照永久地记录在版本历史中\n批量更改\n命名一系列commit以及合并已完成的工作\n$ git branch\n列出当前仓库中所有的本地分支\n$ git branch [branch-name]\n建立一个新分支\n$ git checkout [branch-name]\n切换到一个特定的分支上并更新工作目录\n$ git merge [branch-name]\n合并特定分支的历史到当前分支\n$ git branch -d [branch-name]\n删除特定的分支\n重构文件\n重定位并移除版本文件\n$ git rm [file]\n从工作目录中删除文件并暂存此删除\n$ git rm --cached [file]\n从版本控制中移除文件，并在本地保存文件\n$ git mv [file-original] [file-renamed]\n改变文件名并准备commit\n保存临时更改\n暂存一些未完成的更改\n$ git stash\n临时存储所有修改的已跟踪文件\n$ git stash pop\n重新存储所有最近被stash的文件\n$ git stash list\n列出所有被stash的更改\n$ git stash drop\n放弃所有最近stash的更改\n查阅历史\n浏览并检查项目文件的发展\n$ git log\n列出当前分支的版本历史\n$ git log --follow [file]\n列出文件的版本历史，包括重命名\n$ git diff [first-branch]...[second-branch]\n展示两个不同分支之间的差异\n$ git show [commit]\n输出元数据以及特定commit的内容变化\n撤销commit\n擦除错误并更改历史\n$ git reset [commit]\n撤销所有\n[commit]\n后的的commit，在本地保存更改\n$ git reset --hard [commit]\n放弃所有更改并回到某个特定的commit\n同步更改\n注册一个远程的链接，交换仓库的版本历史\n$ git fetch [remote]\n下载远程仓库的所有历史\n$ git merge [remote]/[branch]\n合并远程分支到当前本地分支\n$ git push [remote] [branch]\n上传所有本地分支commit到GitHub上\n$ git pull\n下载书签历史并合并更改\n"
  },
  {
    "head": "01软件构造的多维度视图和质量目标（软件构造）",
    "paragraphs": [
      "软件构造的多维视图",
      "三个维度",
      "（1）编程时&运行时",
      "（2）时间&时刻",
      "（3）微观和宏观",
      "从这三个维度来看待软件构造，那么在这写维度的组合下，我们更关注一些什么呢？下图或许能解答你的疑惑！",
      "如图中所展示的九个内容，在下面将一一做出说明。",
      "编程时的视图下",
      "对于微观上的视图（Code-level view），我们更加关注的是源代码：source code。在这个视图下，主要分析代码的逻辑组织，即源代码是怎样在基本的编程块，例如函数、类、方法、接口等，在这些的基础上的逻辑组织。",
      "对于宏观的视图（Component-level view），我们更加关注的则是整个工程的结构：architecture。此时，像文件、路径、包、库以及他们之间的相关性，则更加值得我们注意，换句话来说，在这个视图下，主要跟分析代码的物理组织。",
      "而在特定的时刻下，源代码和整体工程的特定形态也是我们分析代码的编程情况中必不可少的部分。",
      "最后，在一段时间内，也可以说是一定周期内（软件的开发呈现一定的周期性，这个问题之后或许会再来探讨），我们更关注的是发展和变化，在这段时间内修改的内容，添加的方法等等，而这些变化，人为的记录未免强人所难，这时，一个好的软件管理工具的使用能大大提高软件开发的效率，暂且按下不提。",
      "（1）Build-time，moment，code-level view",
      "源代码在代码各部分的基础上是怎样逻辑组织的，例如函数、类、方法、接口等，以及它们之间的关系。",
      "而这些又可以从三个层面来看待：词汇层面、语法层面（例如：Abstract Syntax Tree（AST））、以及语义层面（例如：Class Diagram）",
      "词汇层面",
      "即程序代码中使用的语句、字符串、以及变量以“近乎自然语言的风格+遵循特定的变成语法”的组织形式形成一种半结构化的源代码语言，这既方便了程序员的阅读，同时方便编译器的编译。",
      "如图，相信即使不懂Java语言，也能轻松看懂图中的代码做了一些什么事，而这样的组织结构，让不同的程序员在阅读他人的代码时节约时间。",
      "语法层面",
      "对于语法的层面，更加注重的是软件执行的过程，或者说是软件执行的算法流程。",
      "以图中左侧代码为例，构造出了AST（语法分析树），对应的就是程序执行的流程",
      "同样对于数据或者文件的操作也同样可以构造除AST来描述整个操作的流程。而AST的目的就是将程序彻底结构化，把源代码变成一棵树，对树做各种操作就是对源代码的修改。这应该怎么理解呢？",
      "以上图文件读取为例，在开发过程中，对读入文件的方式做出修改的话，只需要修改图中的①部分。这样结构分明的一棵树，便于修改的一种组织方式，对于我来说是没办法拒绝的。",
      "语义层面",
      "语义的含义是指源代码具体现实什么目标，例如：用UML来描述接口、类、属性、方法及它们之间的关系。而这些通常用图形化或者形式化的方法来表达“需求”和“设计”思想。如下图：",
      "该图相信可以清晰的表示人和学生、教授之间的关系，以及人与地址之间的关系。",
      "（2）Build-time, period, and code-level view",
      "主要关注的是编码时，代码的改变情况，即Code churn 代码变化，包括添加的行、文件的改进或删除、从一个版本到另一的版本的变化。",
      "而实现这些的管理，仅仅依靠自己是非常困难的，因此我们一般会使用一些版本控制工具。",
      "例如图中红色区域，就是该次修改的项目。更加清晰直观的表现出了变化的发生位置，设想这样一个场景，昨天保存的代码已经通过测试没有问题，而今天出现了bug，通过这样的版本控制工具就能尽快的定位到代码可能出错的位置。",
      "(3) Build-time, moment, and component-level view",
      "在这三个视图下，我们所关注的是代码的组织情况，简单来说就是在开发程序的时候会有很多的类、很多的文件，当然我们可以任意的放在工程里，但这样就会出现一个问题，如果想要对程序进行更改，那什么应该更改，什么不该更改这个问题就会需要耗费大量的时间去思考以及记录。一种好的组织方式就是利用模块化的方式来组织文件。比如功能类似的、完成某个功能的文件放在一个包里，这样上面的问题就迎刃而解了。",
      "如图中的ADT等。",
      "Library",
      "对于组织程序文件的时候，一种最简单的方法就是利用库函数（library）的形式来进行组织。在编程时，很多情况下，大部分的功能其实并不需要我们自己编写，大部分情况下我们可以调用第三方的库文件中的方法直接使用，就像使用编程指令一样使用库中的功能，例如：",
      "除了编辑阶段，在构建阶段也可以使用库文件，例如我们可以用maven提供的资源；在测试阶段很多的第三方库也为我们提供了便利。",
      "Linking with a library",
      "但库文件毕竟是第三方提供的，那么我们如何去使用这些库文件呢？",
      "回想一下刚开始使用java的时候，我们需要配置java环境以及资源目录，而这些工作就是为了在之后的代码编写过程中告诉程序库文件的位置。但仅仅找到是不够的，我们要做的第二步就是告诉程序怎么把库文件链接到程序中，链接的方式有两种，一种是静态链接，一种是动态链接。关于链接的内容可以参考学习《深入理解计算机系统》，在这里只作简单介绍。",
      "静态链接是将库被拷贝进入代码形成整体，执行的时候无需提供库文件，这种链接发生在构造阶段，当然这样做的坏处就是当库文件更新升级的升级后，程序中的库文件相关资源是不会发生改变的；",
      "而动态链接则是在程序运行时，通过地址动态的使用库文件中的资源，因此，在将程序打包发送时，不要忘记将用到的库文件一并打包发送给客户！",
      "如图是一个模块化的UML图，与代码级别不同的是，这个图不在将视线聚集在方法和类等之间的关系，而是例如图中shopping cart 和 orders之间。",
      "(4) Build-time, period, and component-level view",
      "在这些维度下，其实我们所关注的也是代码的改变情况，简单来说，也就是希望我们能够知道在这个阶段中，我们对这个代码做了什么改变。没错！还是版本控制工具！software configuration item ！比如说window在不同的阶段会有不同的版本，我们就希望能把它记录下来。",
      "例如图中，我们希望记录每个文件的不同的开发版本，而最后我们所发布的final version 实际上就是file1 的1.3 ，file 2 的1.2 ，以及file 3 的1.4 的版本。",
      "而版本控制工具除了记录的功能外，它还提供了另一个非常重要的功能，支持协同开发。通常一个大的工程，不可能由一个人甚至是几个人来完成，他有可能是由一个大的几十甚至几百人的团队来负责开发的，那么这个时候就需要协同工作，在工程的不同分支上开发完成部分功能以及对这些功能的集成。",
      "如上图，可能每个分支就是不同的模块的功能的开发，这样能够在一定程度上不影响别人的工作状况下独立的完成自己的工作。",
      "运行时的视图下",
      "运行时，程序被载入目标机器，开始执行",
      "在code-level view 的维度，我们关心的是逻辑实体，例如：对象、函数等，在内存中如何呈现？其实很简单，我们使用的java是一种面向对象的编程语言，在程序进行运行的时候，我们所关注的就是程序在某一个时间点到底有多少个对象，以及对象里面的值是什么样的。",
      "而在模块化的角度，我们更关注的是多个模块在运行时的配置是什么样的，即在软件层面，物理实体（OS 、network 、 hardware 等等）在物理硬件环境中如何呈现？目前很多的程序都是采用分布式的情况来进行配置的，什么的是分布式呢，简单来说，就是一个程序并不是就安装在一个机器上，而可能是被分割成了几部分，安装在了不同的机器上来进行运行的。",
      "在时刻视角下，我们可能更关注的是程序在内存中的情况，程序占用内存的空间有多大，程序在某个时间点生成了多少个对象。",
      "在时间或者周期的角度，我们关注的是这个程序在执行时到底需要多大的内存等问题。",
      "(5) Run-time, moment, and code-level view",
      "在当前视图下，我们关注的就是程序在某一个时间点到底有多少个对象，以及对象里面的值是什么样的。这时候我们引入一个snapshot diagram（代码快照图）来描述当前我们所关注的信息。",
      "如上两图，我们所关注的信息就一目了然了。而该图的含义与结构我们暂且按下不提。",
      "同样另外一个我们所使用的方法是memory dump（内存信息转储），这种工具科技方便的查看内存的使用情况。",
      "最常见的memory dump 工具相信我们都并不陌生",
      "任务管理器！它就能告诉我们在运行过程中，程序的一些内存占用信息。",
      "(6) Run-time, period and code-level view",
      "这个角度我们所看重的是代码的执行情况，这也可以通过一个UML图来表示，这时的UML图我们称之为运行视图，或者也可以称之为时序图，这个时序图就描述了在和层序运行的时候，多个类、多个方法之间是怎么进行调用的。",
      "当然我们还可以利用一些工具，例如一些列的tracing也就是追踪的工具，来了解到程序在执行的时候的一些信息，即用日志记录程序执行的调用次数。如下图：",
      "(7) Run-time, moment, and component-level view",
      "在这个维度下，我们从模块的角度来看待代码的组织情况，即程序在不同的机器或者单元上的配置情况，如下图：",
      "(8) Run-time, period, and component-level view",
      "在这最后一个维度下，我们关注的是整个系统的调用情况或系统的使用情况，我们可以通过日志文件从系统的层面上看待程序的使用情况，例如程序被调用、被挂起、程序结束等信息。如下图：",
      "将以上八个维度下的关注重点放在同一张表格中，我们就得到了本文讨论的内容：软件构造的多维度视图。表格中被红色框矿主的部分就是软件构造这门课会涉及的部分，而其他的知识点也推荐大家去了解知识点对应的内容。",
      "从不同的维度下看待软件构造，梳理了一遍之后，相信我们对如何构造使用工具来对软件进行监视和了解有了进一步的认识，当然还有如何构造一个好的软件也有了初步的判断，但更多的内容还需要之后慢慢探索。",
      "以上博文中的资料均引用自2021年春季学期软件构造课程（任课教师：王忠杰 感谢老师的倾囊相授！）中的内容，加上个人对其的稍许理解。",
      "欢迎各位相约探讨！"
    ],
    "sentences": [
      "软件构造的多维视图",
      "三个维度",
      "（1）编程时&运行时",
      "（2）时间&时刻",
      "（3）微观和宏观",
      "从这三个维度来看待软件构造",
      "那么在这写维度的组合下",
      "我们更关注一些什么呢？下图或许能解答你的疑惑！",
      "如图中所展示的九个内容，在下面将一一做出说明",
      "编程时的视图下",
      "对于微观上的视图（Code-level view）",
      "我们更加关注的是源代码：source code",
      "在这个视图下",
      "主要分析代码的逻辑组织",
      "即源代码是怎样在基本的编程块",
      "例如函数、类、方法、接口等",
      "在这些的基础上的逻辑组织",
      "对于宏观的视图（Component-level view）",
      "我们更加关注的则是整个工程的结构：architecture",
      "此时",
      "像文件、路径、包、库以及他们之间的相关性",
      "则更加值得我们注意",
      "换句话来说",
      "在这个视图下",
      "主要跟分析代码的物理组织",
      "而在特定的时刻下",
      "源代码和整体工程的特定形态也是我们分析代码的编程情况中必不可少的部分",
      "最后",
      "在一段时间内",
      "也可以说是一定周期内（软件的开发呈现一定的周期性",
      "这个问题之后或许会再来探讨）",
      "我们更关注的是发展和变化",
      "在这段时间内修改的内容",
      "添加的方法等等",
      "而这些变化",
      "人为的记录未免强人所难",
      "这时",
      "一个好的软件管理工具的使用能大大提高软件开发的效率",
      "暂且按下不提",
      "（1）Build-time",
      "moment",
      "code-level view",
      "源代码在代码各部分的基础上是怎样逻辑组织的",
      "例如函数、类、方法、接口等",
      "以及它们之间的关系",
      "而这些又可以从三个层面来看待：词汇层面、语法层面（例如：Abstract Syntax Tree（AST））、以及语义层面（例如：Class Diagram）",
      "词汇层面",
      "即程序代码中使用的语句、字符串、以及变量以“近乎自然语言的风格+遵循特定的变成语法”的组织形式形成一种半结构化的源代码语言",
      "这既方便了程序员的阅读",
      "同时方便编译器的编译",
      "如图",
      "相信即使不懂Java语言",
      "也能轻松看懂图中的代码做了一些什么事",
      "而这样的组织结构",
      "让不同的程序员在阅读他人的代码时节约时间",
      "语法层面",
      "对于语法的层面",
      "更加注重的是软件执行的过程",
      "或者说是软件执行的算法流程",
      "以图中左侧代码为例",
      "构造出了AST（语法分析树）",
      "对应的就是程序执行的流程",
      "同样对于数据或者文件的操作也同样可以构造除AST来描述整个操作的流程",
      "而AST的目的就是将程序彻底结构化",
      "把源代码变成一棵树",
      "对树做各种操作就是对源代码的修改",
      "这应该怎么理解呢？",
      "以上图文件读取为例",
      "在开发过程中",
      "对读入文件的方式做出修改的话",
      "只需要修改图中的①部分",
      "这样结构分明的一棵树",
      "便于修改的一种组织方式",
      "对于我来说是没办法拒绝的",
      "语义层面",
      "语义的含义是指源代码具体现实什么目标",
      "例如：用UML来描述接口、类、属性、方法及它们之间的关系",
      "而这些通常用图形化或者形式化的方法来表达“需求”和“设计”思想",
      "如下图：该图相信可以清晰的表示人和学生、教授之间的关系",
      "以及人与地址之间的关系",
      "（2）Build-time, period, and code-level view",
      "主要关注的是编码时",
      "代码的改变情况",
      "即Code churn 代码变化",
      "包括添加的行、文件的改进或删除、从一个版本到另一的版本的变化",
      "而实现这些的管理",
      "仅仅依靠自己是非常困难的",
      "因此我们一般会使用一些版本控制工具",
      "例如图中红色区域，就是该次修改的项目",
      "更加清晰直观的表现出了变化的发生位置",
      "设想这样一个场景",
      "昨天保存的代码已经通过测试没有问题",
      "而今天出现了bug",
      "通过这样的版本控制工具就能尽快的定位到代码可能出错的位置",
      "(3) Build-time, moment, and component-level view",
      "在这三个视图下",
      "我们所关注的是代码的组织情况",
      "简单来说就是在开发程序的时候会有很多的类、很多的文件",
      "当然我们可以任意的放在工程里",
      "但这样就会出现一个问题",
      "如果想要对程序进行更改",
      "那什么应该更改",
      "什么不该更改这个问题就会需要耗费大量的时间去思考以及记录",
      "一种好的组织方式就是利用模块化的方式来组织文件",
      "比如功能类似的、完成某个功能的文件放在一个包里",
      "这样上面的问题就迎刃而解了",
      "如图中的ADT等",
      "Library",
      "对于组织程序文件的时候",
      "一种最简单的方法就是利用库函数（library）的形式来进行组织",
      "在编程时",
      "很多情况下",
      "大部分的功能其实并不需要我们自己编写",
      "大部分情况下我们可以调用第三方的库文件中的方法直接使用",
      "就像使用编程指令一样使用库中的功能",
      "例如：除了编辑阶段",
      "在构建阶段也可以使用库文件",
      "例如我们可以用maven提供的资源；在测试阶段很多的第三方库也为我们提供了便利",
      "Linking with a library",
      "但库文件毕竟是第三方提供的，那么我们如何去使用这些库文件呢？",
      "回想一下刚开始使用java的时候",
      "我们需要配置java环境以及资源目录",
      "而这些工作就是为了在之后的代码编写过程中告诉程序库文件的位置",
      "但仅仅找到是不够的",
      "我们要做的第二步就是告诉程序怎么把库文件链接到程序中",
      "链接的方式有两种",
      "一种是静态链接",
      "一种是动态链接",
      "关于链接的内容可以参考学习《深入理解计算机系统》",
      "在这里只作简单介绍",
      "静态链接是将库被拷贝进入代码形成整体",
      "执行的时候无需提供库文件",
      "这种链接发生在构造阶段",
      "当然这样做的坏处就是当库文件更新升级的升级后",
      "程序中的库文件相关资源是不会发生改变的；而动态链接则是在程序运行时",
      "通过地址动态的使用库文件中的资源",
      "因此",
      "在将程序打包发送时",
      "不要忘记将用到的库文件一并打包发送给客户！",
      "如图是一个模块化的UML图",
      "与代码级别不同的是",
      "这个图不在将视线聚集在方法和类等之间的关系",
      "而是例如图中shopping cart 和 orders之间",
      "(4) Build-time, period, and component-level view",
      "在这些维度下",
      "其实我们所关注的也是代码的改变情况",
      "简单来说",
      "也就是希望我们能够知道在这个阶段中",
      "我们对这个代码做了什么改变",
      "没错！还是版本控制工具！software configuration item ！比如说window在不同的阶段会有不同的版本",
      "我们就希望能把它记录下来",
      "例如图中",
      "我们希望记录每个文件的不同的开发版本",
      "而最后我们所发布的final version 实际上就是file1 的1.3 ",
      "file 2 的1.2 ",
      "以及file 3 的1.4 的版本",
      "而版本控制工具除了记录的功能外",
      "它还提供了另一个非常重要的功能",
      "支持协同开发",
      "通常一个大的工程",
      "不可能由一个人甚至是几个人来完成",
      "他有可能是由一个大的几十甚至几百人的团队来负责开发的",
      "那么这个时候就需要协同工作",
      "在工程的不同分支上开发完成部分功能以及对这些功能的集成",
      "如上图",
      "可能每个分支就是不同的模块的功能的开发",
      "这样能够在一定程度上不影响别人的工作状况下独立的完成自己的工作",
      "运行时的视图下",
      "运行时，程序被载入目标机器，开始执行",
      "在code-level view 的维度",
      "我们关心的是逻辑实体",
      "例如：对象、函数等",
      "在内存中如何呈现？其实很简单",
      "我们使用的java是一种面向对象的编程语言",
      "在程序进行运行的时候",
      "我们所关注的就是程序在某一个时间点到底有多少个对象",
      "以及对象里面的值是什么样的",
      "而在模块化的角度",
      "我们更关注的是多个模块在运行时的配置是什么样的",
      "即在软件层面",
      "物理实体（OS 、network 、 hardware 等等）在物理硬件环境中如何呈现？目前很多的程序都是采用分布式的情况来进行配置的",
      "什么的是分布式呢",
      "简单来说",
      "就是一个程序并不是就安装在一个机器上",
      "而可能是被分割成了几部分",
      "安装在了不同的机器上来进行运行的",
      "在时刻视角下",
      "我们可能更关注的是程序在内存中的情况",
      "程序占用内存的空间有多大",
      "程序在某个时间点生成了多少个对象",
      "在时间或者周期的角度",
      "我们关注的是这个程序在执行时到底需要多大的内存等问题",
      "(5) Run-time, moment, and code-level view",
      "在当前视图下",
      "我们关注的就是程序在某一个时间点到底有多少个对象",
      "以及对象里面的值是什么样的",
      "这时候我们引入一个snapshot diagram（代码快照图）来描述当前我们所关注的信息",
      "如上两图，我们所关注的信息就一目了然了",
      "而该图的含义与结构我们暂且按下不提",
      "同样另外一个我们所使用的方法是memory dump（内存信息转储）",
      "这种工具科技方便的查看内存的使用情况",
      "最常见的memory dump 工具相信我们都并不陌生",
      "任务管理器！它就能告诉我们在运行过程中",
      "程序的一些内存占用信息",
      "(6) Run-time, period and code-level view",
      "这个角度我们所看重的是代码的执行情况",
      "这也可以通过一个UML图来表示",
      "这时的UML图我们称之为运行视图",
      "或者也可以称之为时序图",
      "这个时序图就描述了在和层序运行的时候",
      "多个类、多个方法之间是怎么进行调用的",
      "当然我们还可以利用一些工具",
      "例如一些列的tracing也就是追踪的工具",
      "来了解到程序在执行的时候的一些信息",
      "即用日志记录程序执行的调用次数",
      "如下图：(7) Run-time, moment, and component-level view",
      "在这个维度下",
      "我们从模块的角度来看待代码的组织情况",
      "即程序在不同的机器或者单元上的配置情况",
      "如下图：(8) Run-time, period, and component-level view",
      "在这最后一个维度下",
      "我们关注的是整个系统的调用情况或系统的使用情况",
      "我们可以通过日志文件从系统的层面上看待程序的使用情况",
      "例如程序被调用、被挂起、程序结束等信息",
      "如下图：将以上八个维度下的关注重点放在同一张表格中",
      "我们就得到了本文讨论的内容：软件构造的多维度视图",
      "表格中被红色框矿主的部分就是软件构造这门课会涉及的部分",
      "而其他的知识点也推荐大家去了解知识点对应的内容",
      "从不同的维度下看待软件构造",
      "梳理了一遍之后",
      "相信我们对如何构造使用工具来对软件进行监视和了解有了进一步的认识",
      "当然还有如何构造一个好的软件也有了初步的判断",
      "但更多的内容还需要之后慢慢探索",
      "以上博文中的资料均引用自2021年春季学期软件构造课程（任课教师：王忠杰 感谢老师的倾囊相授！）中的内容",
      "加上个人对其的稍许理解",
      "欢迎各位相约探讨！"
    ],
    "codes": [
      "System.out.println(\"Hello World\");\n"
    ],
    "date": "2021-07-07",
    "text": "软件构造的多维视图\n三个维度\n（1）编程时&运行时\n（2）时间&时刻\n（3）微观和宏观\n从这三个维度来看待软件构造，那么在这写维度的组合下，我们更关注一些什么呢？下图或许能解答你的疑惑！\n如图中所展示的九个内容，在下面将一一做出说明。\n编程时的视图下\n对于微观上的视图（Code-level view），我们更加关注的是源代码：source code。在这个视图下，主要分析代码的逻辑组织，即源代码是怎样在基本的编程块，例如函数、类、方法、接口等，在这些的基础上的逻辑组织。\n对于宏观的视图（Component-level view），我们更加关注的则是整个工程的结构：architecture。此时，像文件、路径、包、库以及他们之间的相关性，则更加值得我们注意，换句话来说，在这个视图下，主要跟分析代码的物理组织。\n而在特定的时刻下，源代码和整体工程的特定形态也是我们分析代码的编程情况中必不可少的部分。\n最后，在一段时间内，也可以说是一定周期内（软件的开发呈现一定的周期性，这个问题之后或许会再来探讨），我们更关注的是发展和变化，在这段时间内修改的内容，添加的方法等等，而这些变化，人为的记录未免强人所难，这时，一个好的软件管理工具的使用能大大提高软件开发的效率，暂且按下不提。\n（1）Build-time，moment，code-level view\n源代码在代码各部分的基础上是怎样逻辑组织的，例如函数、类、方法、接口等，以及它们之间的关系。\n而这些又可以从三个层面来看待：词汇层面、语法层面（例如：Abstract Syntax Tree（AST））、以及语义层面（例如：Class Diagram）\n词汇层面\n即程序代码中使用的语句、字符串、以及变量以“近乎自然语言的风格+遵循特定的变成语法”的组织形式形成一种半结构化的源代码语言，这既方便了程序员的阅读，同时方便编译器的编译。\n如图，相信即使不懂Java语言，也能轻松看懂图中的代码做了一些什么事，而这样的组织结构，让不同的程序员在阅读他人的代码时节约时间。\n语法层面\n对于语法的层面，更加注重的是软件执行的过程，或者说是软件执行的算法流程。\n以图中左侧代码为例，构造出了AST（语法分析树），对应的就是程序执行的流程\n同样对于数据或者文件的操作也同样可以构造除AST来描述整个操作的流程。而AST的目的就是将程序彻底结构化，把源代码变成一棵树，对树做各种操作就是对源代码的修改。这应该怎么理解呢？\n以上图文件读取为例，在开发过程中，对读入文件的方式做出修改的话，只需要修改图中的①部分。这样结构分明的一棵树，便于修改的一种组织方式，对于我来说是没办法拒绝的。\n语义层面\n语义的含义是指源代码具体现实什么目标，例如：用UML来描述接口、类、属性、方法及它们之间的关系。而这些通常用图形化或者形式化的方法来表达“需求”和“设计”思想。如下图：\n该图相信可以清晰的表示人和学生、教授之间的关系，以及人与地址之间的关系。\n（2）Build-time, period, and code-level view\n主要关注的是编码时，代码的改变情况，即Code churn 代码变化，包括添加的行、文件的改进或删除、从一个版本到另一的版本的变化。\n而实现这些的管理，仅仅依靠自己是非常困难的，因此我们一般会使用一些版本控制工具。\n例如图中红色区域，就是该次修改的项目。更加清晰直观的表现出了变化的发生位置，设想这样一个场景，昨天保存的代码已经通过测试没有问题，而今天出现了bug，通过这样的版本控制工具就能尽快的定位到代码可能出错的位置。\n(3) Build-time, moment, and component-level view\n在这三个视图下，我们所关注的是代码的组织情况，简单来说就是在开发程序的时候会有很多的类、很多的文件，当然我们可以任意的放在工程里，但这样就会出现一个问题，如果想要对程序进行更改，那什么应该更改，什么不该更改这个问题就会需要耗费大量的时间去思考以及记录。一种好的组织方式就是利用模块化的方式来组织文件。比如功能类似的、完成某个功能的文件放在一个包里，这样上面的问题就迎刃而解了。\n如图中的ADT等。\nLibrary\n对于组织程序文件的时候，一种最简单的方法就是利用库函数（library）的形式来进行组织。在编程时，很多情况下，大部分的功能其实并不需要我们自己编写，大部分情况下我们可以调用第三方的库文件中的方法直接使用，就像使用编程指令一样使用库中的功能，例如：\n除了编辑阶段，在构建阶段也可以使用库文件，例如我们可以用maven提供的资源；在测试阶段很多的第三方库也为我们提供了便利。\nLinking with a library\n但库文件毕竟是第三方提供的，那么我们如何去使用这些库文件呢？\n回想一下刚开始使用java的时候，我们需要配置java环境以及资源目录，而这些工作就是为了在之后的代码编写过程中告诉程序库文件的位置。但仅仅找到是不够的，我们要做的第二步就是告诉程序怎么把库文件链接到程序中，链接的方式有两种，一种是静态链接，一种是动态链接。关于链接的内容可以参考学习《深入理解计算机系统》，在这里只作简单介绍。\n静态链接是将库被拷贝进入代码形成整体，执行的时候无需提供库文件，这种链接发生在构造阶段，当然这样做的坏处就是当库文件更新升级的升级后，程序中的库文件相关资源是不会发生改变的；\n而动态链接则是在程序运行时，通过地址动态的使用库文件中的资源，因此，在将程序打包发送时，不要忘记将用到的库文件一并打包发送给客户！\n如图是一个模块化的UML图，与代码级别不同的是，这个图不在将视线聚集在方法和类等之间的关系，而是例如图中shopping cart 和 orders之间。\n(4) Build-time, period, and component-level view\n在这些维度下，其实我们所关注的也是代码的改变情况，简单来说，也就是希望我们能够知道在这个阶段中，我们对这个代码做了什么改变。没错！还是版本控制工具！software configuration item ！比如说window在不同的阶段会有不同的版本，我们就希望能把它记录下来。\n例如图中，我们希望记录每个文件的不同的开发版本，而最后我们所发布的final version 实际上就是file1 的1.3 ，file 2 的1.2 ，以及file 3 的1.4 的版本。\n而版本控制工具除了记录的功能外，它还提供了另一个非常重要的功能，支持协同开发。通常一个大的工程，不可能由一个人甚至是几个人来完成，他有可能是由一个大的几十甚至几百人的团队来负责开发的，那么这个时候就需要协同工作，在工程的不同分支上开发完成部分功能以及对这些功能的集成。\n如上图，可能每个分支就是不同的模块的功能的开发，这样能够在一定程度上不影响别人的工作状况下独立的完成自己的工作。\n运行时的视图下\n运行时，程序被载入目标机器，开始执行\n在code-level view 的维度，我们关心的是逻辑实体，例如：对象、函数等，在内存中如何呈现？其实很简单，我们使用的java是一种面向对象的编程语言，在程序进行运行的时候，我们所关注的就是程序在某一个时间点到底有多少个对象，以及对象里面的值是什么样的。\n而在模块化的角度，我们更关注的是多个模块在运行时的配置是什么样的，即在软件层面，物理实体（OS 、network 、 hardware 等等）在物理硬件环境中如何呈现？目前很多的程序都是采用分布式的情况来进行配置的，什么的是分布式呢，简单来说，就是一个程序并不是就安装在一个机器上，而可能是被分割成了几部分，安装在了不同的机器上来进行运行的。\n在时刻视角下，我们可能更关注的是程序在内存中的情况，程序占用内存的空间有多大，程序在某个时间点生成了多少个对象。\n在时间或者周期的角度，我们关注的是这个程序在执行时到底需要多大的内存等问题。\n(5) Run-time, moment, and code-level view\n在当前视图下，我们关注的就是程序在某一个时间点到底有多少个对象，以及对象里面的值是什么样的。这时候我们引入一个snapshot diagram（代码快照图）来描述当前我们所关注的信息。\n如上两图，我们所关注的信息就一目了然了。而该图的含义与结构我们暂且按下不提。\n同样另外一个我们所使用的方法是memory dump（内存信息转储），这种工具科技方便的查看内存的使用情况。\n最常见的memory dump 工具相信我们都并不陌生\n任务管理器！它就能告诉我们在运行过程中，程序的一些内存占用信息。\n(6) Run-time, period and code-level view\n这个角度我们所看重的是代码的执行情况，这也可以通过一个UML图来表示，这时的UML图我们称之为运行视图，或者也可以称之为时序图，这个时序图就描述了在和层序运行的时候，多个类、多个方法之间是怎么进行调用的。\n当然我们还可以利用一些工具，例如一些列的tracing也就是追踪的工具，来了解到程序在执行的时候的一些信息，即用日志记录程序执行的调用次数。如下图：\n(7) Run-time, moment, and component-level view\n在这个维度下，我们从模块的角度来看待代码的组织情况，即程序在不同的机器或者单元上的配置情况，如下图：\n(8) Run-time, period, and component-level view\n在这最后一个维度下，我们关注的是整个系统的调用情况或系统的使用情况，我们可以通过日志文件从系统的层面上看待程序的使用情况，例如程序被调用、被挂起、程序结束等信息。如下图：\n将以上八个维度下的关注重点放在同一张表格中，我们就得到了本文讨论的内容：软件构造的多维度视图。表格中被红色框矿主的部分就是软件构造这门课会涉及的部分，而其他的知识点也推荐大家去了解知识点对应的内容。\n从不同的维度下看待软件构造，梳理了一遍之后，相信我们对如何构造使用工具来对软件进行监视和了解有了进一步的认识，当然还有如何构造一个好的软件也有了初步的判断，但更多的内容还需要之后慢慢探索。\n以上博文中的资料均引用自2021年春季学期软件构造课程（任课教师：王忠杰 感谢老师的倾囊相授！）中的内容，加上个人对其的稍许理解。\n欢迎各位相约探讨！\n"
  },
  {
    "head": "2021-07-17",
    "paragraphs": [
      "python中禁止函数修改列表",
      "切片表示法 [:] 创建列表的副本",
      "具体如下：",
      "运行结果如下：",
      "禁止函数修改列表仅需修改函数传入参数的形式，如下：",
      "运行结果如下：",
      "Liu",
      "zhang",
      "比较上下两个函数调用：",
      "由上述可验证，无需修改函数，仅改变函数传入参数的形式，magicians -> magicians[:] ，即可禁止函数修改列表。"
    ],
    "sentences": [
      "python中禁止函数修改列表",
      "切片表示法 [:] 创建列表的副本",
      "具体如下：运行结果如下：禁止函数修改列表仅需修改函数传入参数的形式",
      "如下：运行结果如下：Liu",
      "zhang",
      "比较上下两个函数调用：由上述可验证",
      "无需修改函数",
      "仅改变函数传入参数的形式",
      "magicians -> magicians[:] ",
      "即可禁止函数修改列表"
    ],
    "codes": [
      "# 定义一个函数 show_magicians(new_magicians) 将传入的magicians列表打印出来；定义另一个函数 make_great(new_magicians) 添加 ‘The great ’ 在列表中各元素前\n'''\n将传入的magicians列表打印出来\n\n@param new_magicians 魔术师列表\n'''\ndef show_magicians(new_magicians):\n    for magician in new_magicians:\n        print(magician)\n\n\n'''\n添加 ‘The great ’ 在列表中各元素前\n\n@param new_magicians 魔术师列表\n@return new_magicians 已为个元素添加‘The great ’的列表\n'''\ndef make_great(new_magicians):\n    for i in range(len(new_magicians)):\n        new_magicians[i] = 'the Great ' + new_magicians[i]\n    return new_magicians\n\n\nmagicians = ['Liu', 'zhang', 'li']\nshow_magicians(make_great(magicians))\nshow_magicians(magicians)\n",
      "show_magicians(make_great(magicians[:]))  # 拷贝列表而非引用\nshow_magicians(magicians)\n",
      "show_magicians(make_great(magicians))\nshow_magicians(make_great(magicians[:]))  # 拷贝列表而非引用\n",
      "the Great Liu",
      "the Great zhang",
      "the Great li",
      "the Great Liu",
      "the Great zhang",
      "the Great li",
      "the Great Liu",
      "the Great zhang",
      "the Great li"
    ],
    "date": "2021-07-17",
    "text": "python中禁止函数修改列表\n切片表示法 [:] 创建列表的副本\n具体如下：\n运行结果如下：\n禁止函数修改列表仅需修改函数传入参数的形式，如下：\n运行结果如下：\nLiu\nzhang\n比较上下两个函数调用：\n由上述可验证，无需修改函数，仅改变函数传入参数的形式，magicians -> magicians[:] ，即可禁止函数修改列表。\n"
  },
  {
    "head": "软件构造(二)spec 规约",
    "paragraphs": [
      "spec 规约",
      "是使用者（client）和实现者（implementor）之间的妥协与契约，即是一种在使用时必须要遵循的要求的说明，也是一种在在实现时需要遵循的原则.",
      "一般书写在每一个类和每一方法前面.",
      "由@param、@throws、@return组成.",
      "约定俗成的规矩是使用者需要在满足前置条件的情况下，才能得到正确的结果.",
      "行为等价性:",
      "对于用户来讲, 提供的同一个spec，若都被满足了，那么就算做等价.",
      "所以重点就是要站在用户端看待问题，只要同一个spec被满足，则说明实现了相同的功能，即同一个spec所有实现是等价的.",
      "不能单看代码结果不一样,就说两个实现不等价.",
      "spec的强弱判断和比较方法:",
      "前置条件越弱, 后置条件越强, spec越强.(前者用户所需遵守规则少,后者用户得到的信息更详细)",
      "因为前置条件必须被满足，所以后置条件的比较是在前置假设成立的条件下进行的，在很多情况下，前置条件的限制使得后置条件从不同变为相同."
    ],
    "sentences": [
      "spec 规约",
      "是使用者（client）和实现者（implementor）之间的妥协与契约",
      "即是一种在使用时必须要遵循的要求的说明",
      "也是一种在在实现时需要遵循的原则.一般书写在每一个类和每一方法前面.由@param、@throws、@return组成.约定俗成的规矩是使用者需要在满足前置条件的情况下",
      "才能得到正确的结果.行为等价性:对于用户来讲, 提供的同一个spec",
      "若都被满足了",
      "那么就算做等价.所以重点就是要站在用户端看待问题",
      "只要同一个spec被满足",
      "则说明实现了相同的功能",
      "即同一个spec所有实现是等价的.不能单看代码结果不一样,就说两个实现不等价.spec的强弱判断和比较方法:前置条件越弱, 后置条件越强, spec越强.(前者用户所需遵守规则少,后者用户得到的信息更详细)",
      "因为前置条件必须被满足",
      "所以后置条件的比较是在前置假设成立的条件下进行的",
      "在很多情况下",
      "前置条件的限制使得后置条件从不同变为相同."
    ],
    "codes": [
      "\n/**\n\t * Insert a interval with its start, end, and label\n\t * Labeled intervals conflict if: they have the same label with different\n\t * intervals, or they have different labels with overlapping intervals.\n\t *\n\t * For example, if this set is { \"A\"=[0,10), \"B\"=[20,30) },\n\t * insert(\"A\"=[0,10)) has no effect\n\t * insert(\"A\"=[10,20)) throws IntervalConflictException\n\t * insert(\"B\"=[10,20)) throws IntervalConflictException\n\t * insert(\"C\"=[20,30)) throws IntervalConflictException\n\t * insert(\"D\"=[30,40)) adds \"D\"=[30,40)\n\t *\n\t * @param start the start of the interval(the low end of the interval)\n\t * @param end the end of the interval(the high end of the interval)\n\t * @param label the label to add\n\t * @throws IntervalConflictException -if the label is already existed,\n\t * and the start and end are not the same with the new ones;\n\t * or there's a existed interval whose range conflict with the new one.\n\t */\n"
    ],
    "date": "2021-07-06",
    "text": "spec 规约\n是使用者（client）和实现者（implementor）之间的妥协与契约，即是一种在使用时必须要遵循的要求的说明，也是一种在在实现时需要遵循的原则.\n一般书写在每一个类和每一方法前面.\n由@param、@throws、@return组成.\n约定俗成的规矩是使用者需要在满足前置条件的情况下，才能得到正确的结果.\n行为等价性:\n对于用户来讲, 提供的同一个spec，若都被满足了，那么就算做等价.\n所以重点就是要站在用户端看待问题，只要同一个spec被满足，则说明实现了相同的功能，即同一个spec所有实现是等价的.\n不能单看代码结果不一样,就说两个实现不等价.\nspec的强弱判断和比较方法:\n前置条件越弱, 后置条件越强, spec越强.(前者用户所需遵守规则少,后者用户得到的信息更详细)\n因为前置条件必须被满足，所以后置条件的比较是在前置假设成立的条件下进行的，在很多情况下，前置条件的限制使得后置条件从不同变为相同.\n"
  },
  {
    "head": "软件构造(五) 异常",
    "paragraphs": [
      "Checked异常、Unchecked异常：",
      "编译器可帮助检查你的程序是否已抛出或处理了可能的异常（checked异常）必须捕获并指定错误处理器handler，否则编译无法通过；类似于编程语言中的static type checking.",
      "Errors and Runtime Exceptions（unchecked异常）不需要在编译的时候用try…catch等机制处理.",
      "Checked异常的处理机制：声明、抛出、捕获、处理、清理现场、释放资源等：",
      "Declaring exceptions (throws) 声明“本方法可能会发生XX异常”",
      "Throwing an exception (throw) 抛出XX异常",
      "Catching an exception (try, catch, finally) 捕获并处理XX异常，不管程序是否碰到异常，finally都会被执行",
      "Unchecked异常也可以使用throws声明或try/catch进行捕获，但大多数时候是不需要的，也不应该这么做——掩耳盗铃，对发现的编程错误充耳不闻 当要决定是采用checked exception还是unchecked exception的时候，问一个问题：“如果这种异常一旦抛出，client会做怎样的补救？” 如果客户端可以通过其他的方法恢复异常，那么采用checked exception；",
      "如果客户端对出现的这种异常无能为力，那么采用unchecked exception；",
      "异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。错误可预料，但无法预防，但可以有手段从中恢复，此时使用checked exception。如果做不到这一点，则使用unchecked exception.",
      "自定义异常类",
      "如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛。子类型方法可以抛出更具体的异常，也可以不抛出任何异常。如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。"
    ],
    "sentences": [
      "Checked异常、Unchecked异常：编译器可帮助检查你的程序是否已抛出或处理了可能的异常（checked异常）必须捕获并指定错误处理器handler",
      "否则编译无法通过；类似于编程语言中的static type checking.Errors and Runtime Exceptions（unchecked异常）不需要在编译的时候用try…catch等机制处理.Checked异常的处理机制：声明、抛出、捕获、处理、清理现场、释放资源等：Declaring exceptions (throws) 声明“本方法可能会发生XX异常”",
      "Throwing an exception (throw) 抛出XX异常",
      "Catching an exception (try, catch, finally) 捕获并处理XX异常",
      "不管程序是否碰到异常",
      "finally都会被执行",
      "Unchecked异常也可以使用throws声明或try/catch进行捕获",
      "但大多数时候是不需要的",
      "也不应该这么做——掩耳盗铃",
      "对发现的编程错误充耳不闻 当要决定是采用checked exception还是unchecked exception的时候",
      "问一个问题：“如果这种异常一旦抛出",
      "client会做怎样的补救？” 如果客户端可以通过其他的方法恢复异常",
      "那么采用checked exception；如果客户端对出现的这种异常无能为力",
      "那么采用unchecked exception；异常出现的时候",
      "要做一些试图恢复它的动作而不要仅仅的打印它的信息",
      "错误可预料",
      "但无法预防",
      "但可以有手段从中恢复",
      "此时使用checked exception",
      "如果做不到这一点",
      "则使用unchecked exception.自定义异常类",
      "如果子类型中override了父类型中的函数",
      "那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛",
      "子类型方法可以抛出更具体的异常，也可以不抛出任何异常",
      "如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "Checked异常、Unchecked异常：\n编译器可帮助检查你的程序是否已抛出或处理了可能的异常（checked异常）必须捕获并指定错误处理器handler，否则编译无法通过；类似于编程语言中的static type checking.\nErrors and Runtime Exceptions（unchecked异常）不需要在编译的时候用try…catch等机制处理.\nChecked异常的处理机制：声明、抛出、捕获、处理、清理现场、释放资源等：\nDeclaring exceptions (throws) 声明“本方法可能会发生XX异常”\nThrowing an exception (throw) 抛出XX异常\nCatching an exception (try, catch, finally) 捕获并处理XX异常，不管程序是否碰到异常，finally都会被执行\nUnchecked异常也可以使用throws声明或try/catch进行捕获，但大多数时候是不需要的，也不应该这么做——掩耳盗铃，对发现的编程错误充耳不闻 当要决定是采用checked exception还是unchecked exception的时候，问一个问题：“如果这种异常一旦抛出，client会做怎样的补救？” 如果客户端可以通过其他的方法恢复异常，那么采用checked exception；\n如果客户端对出现的这种异常无能为力，那么采用unchecked exception；\n异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。错误可预料，但无法预防，但可以有手段从中恢复，此时使用checked exception。如果做不到这一点，则使用unchecked exception.\n自定义异常类\n如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛。子类型方法可以抛出更具体的异常，也可以不抛出任何异常。如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。\n"
  },
  {
    "head": "软件构造(一)src refspec master does not match any的解决方案",
    "paragraphs": [
      "在使用Git向Github上面push代码的时候,出现了",
      "的问题,查阅了很多博客的解决方法针对于我的这次提交都无法解决该问题.",
      "最后发现是在push的时候没有切换分支导致的. 只需要加入一句",
      "成功把分支切换成master分支,就可以解决这个error成功push项目代码啦!!!"
    ],
    "sentences": [
      "在使用Git向Github上面push代码的时候,出现了",
      "的问题,查阅了很多博客的解决方法针对于我的这次提交都无法解决该问题.最后发现是在push的时候没有切换分支导致的. 只需要加入一句",
      "成功把分支切换成master分支,就可以解决这个error成功push项目代码啦!!!"
    ],
    "codes": [
      "error: src refspec master does not match any.\n",
      "git checkout 分支名字\n"
    ],
    "date": "2021-06-20",
    "text": "在使用Git向Github上面push代码的时候,出现了\n的问题,查阅了很多博客的解决方法针对于我的这次提交都无法解决该问题.\n最后发现是在push的时候没有切换分支导致的. 只需要加入一句\n成功把分支切换成master分支,就可以解决这个error成功push项目代码啦!!!\n"
  },
  {
    "head": "软件构造(四) Override与Overload",
    "paragraphs": [
      "Override 重写",
      "重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。",
      "重写不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常, 也不能出现新的函数.",
      "在面向对象原则里，重写意味着可以重写任何现有方法。",
      "参数列表与被重写方法的参数列表必须完全相同。",
      "返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。",
      "访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。",
      "方法的重写规则",
      "1.父类的成员方法只能被它的子类重写。",
      "2.声明为 final 的方法不能被重写。",
      "3.声明为 static 的方法不能被重写，但是能够被再次声明。",
      "4.若子类和父类在同一个包中，那么子类可以重写除了声明为 private 和 final 的所有方法。",
      "5.若子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。",
      "6.重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。",
      "7.构造方法不能被重写。",
      "8.如果不能继承一个类，则不能重写该类的方法。",
      "当需要在子类中调用父类的被重写方法时，要使用",
      "super",
      "关键字。",
      "执行结果应为",
      "Overload 重载",
      "重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。",
      "每个重载的方法都必须有一个不一样的参数类型列表。",
      "最常用的地方就是",
      "构造函数",
      "的重载。",
      "重载的规则",
      "1.被重载的方法必须改变参数列表(参数个数或类型不一样)；",
      "2.被重载的方法可以改变返回类型；",
      "3.被重载的方法可以改变访问修饰符；",
      "4.被重载的方法可以声明新的或更广的检查异常；",
      "5.方法能够在同一个类中或者在一个子类中被重载。",
      "6.无法以返回值类型作为重载函数的区分标准。",
      "重写与重载的区别",
      "返回类型",
      "可减少删除,但不可抛出新的或更广的",
      "可以降低限制",
      "总的来说,Overload除了参数必须要改,其他都是可以改的,相当于一个同名函数,为了做区分当然要在参数上有区别啦,不然他怎么知道该调用哪一个qwqq; 而Override则可改范围很小, 参数,返回类型皆不可变, 是在原函数的框架内进行重写, 受到的限制明显大于Overload."
    ],
    "sentences": [
      "Override 重写",
      "重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变",
      "重写不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常, 也不能出现新的函数.在面向对象原则里",
      "重写意味着可以重写任何现有方法",
      "参数列表与被重写方法的参数列表必须完全相同",
      "返回类型与被重写方法的返回类型可以不相同",
      "但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样",
      "java7 及更高版本可以不同）",
      "访问权限不能比父类中被重写的方法的访问权限更低",
      "例如：如果父类的一个方法被声明为 public",
      "那么在子类中重写该方法就不能声明为 protected",
      "方法的重写规则",
      "1.父类的成员方法只能被它的子类重写",
      "2.声明为 final 的方法不能被重写",
      "3.声明为 static 的方法不能被重写",
      "但是能够被再次声明",
      "4.若子类和父类在同一个包中",
      "那么子类可以重写除了声明为 private 和 final 的所有方法",
      "5.若子类和父类不在同一个包中",
      "那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法",
      "6.重写的方法能够抛出任何非强制异常",
      "无论被重写的方法是否抛出异常",
      "但是",
      "重写的方法不能抛出新的强制性异常",
      "或者比被重写方法声明的更广泛的强制性异常",
      "反之则可以",
      "7.构造方法不能被重写",
      "8.如果不能继承一个类，则不能重写该类的方法",
      "当需要在子类中调用父类的被重写方法时，要使用",
      "super",
      "关键字",
      "执行结果应为",
      "Overload 重载",
      "重载是在一个类里面，方法名字相同，而参数不同",
      "返回类型可以相同也可以不同",
      "每个重载的方法都必须有一个不一样的参数类型列表",
      "最常用的地方就是",
      "构造函数",
      "的重载",
      "重载的规则",
      "1.被重载的方法必须改变参数列表(参数个数或类型不一样)；2.被重载的方法可以改变返回类型；3.被重载的方法可以改变访问修饰符；4.被重载的方法可以声明新的或更广的检查异常；5.方法能够在同一个类中或者在一个子类中被重载",
      "6.无法以返回值类型作为重载函数的区分标准",
      "重写与重载的区别",
      "返回类型",
      "可减少删除,但不可抛出新的或更广的",
      "可以降低限制",
      "总的来说,Overload除了参数必须要改,其他都是可以改的,相当于一个同名函数,为了做区分当然要在参数上有区别啦,不然他怎么知道该调用哪一个qwqq; 而Override则可改范围很小, 参数,返回类型皆不可变, 是在原函数的框架内进行重写, 受到的限制明显大于Overload."
    ],
    "codes": [
      "class Bird{\n   public void move(){\n      System.out.println(\"鸟儿可以叫\");\n   }\n}\n \nclass Cooing extends Bird{\n   public void move(){\n      super.move(); // 应用super类的方法\n      System.out.println(\"鸽子可以咕咕咕\");\n   }\n}\n \npublic class TestCooing{\n   public static void main(String args[]){\n \n      Bird b = new Cooing(); // Cooing 对象\n      b.move(); //执行 Cooing类的方法\n \n   }\n}\n",
      "鸟儿可以叫\n鸽子可以咕咕咕\n",
      "public void Cat(int age,String name){\n        System.out.println(\"name:\"+name+\"\\n\"+\"age:\"+age);\n    }   \n \npublic void Cat(String name,int age){\n        System.out.println(\"name:\"+name+\"\\n\"+\"age:\"+age);\n    }   \n"
    ],
    "date": "2021-07-07",
    "text": "Override 重写\n重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。\n重写不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常, 也不能出现新的函数.\n在面向对象原则里，重写意味着可以重写任何现有方法。\n参数列表与被重写方法的参数列表必须完全相同。\n返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。\n访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。\n方法的重写规则\n1.父类的成员方法只能被它的子类重写。\n2.声明为 final 的方法不能被重写。\n3.声明为 static 的方法不能被重写，但是能够被再次声明。\n4.若子类和父类在同一个包中，那么子类可以重写除了声明为 private 和 final 的所有方法。\n5.若子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。\n6.重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n7.构造方法不能被重写。\n8.如果不能继承一个类，则不能重写该类的方法。\n当需要在子类中调用父类的被重写方法时，要使用\nsuper\n关键字。\n执行结果应为\nOverload 重载\n重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n每个重载的方法都必须有一个不一样的参数类型列表。\n最常用的地方就是\n构造函数\n的重载。\n重载的规则\n1.被重载的方法必须改变参数列表(参数个数或类型不一样)；\n2.被重载的方法可以改变返回类型；\n3.被重载的方法可以改变访问修饰符；\n4.被重载的方法可以声明新的或更广的检查异常；\n5.方法能够在同一个类中或者在一个子类中被重载。\n6.无法以返回值类型作为重载函数的区分标准。\n重写与重载的区别\n返回类型\n可减少删除,但不可抛出新的或更广的\n可以降低限制\n总的来说,Overload除了参数必须要改,其他都是可以改的,相当于一个同名函数,为了做区分当然要在参数上有区别啦,不然他怎么知道该调用哪一个qwqq; 而Override则可改范围很小, 参数,返回类型皆不可变, 是在原函数的框架内进行重写, 受到的限制明显大于Overload.\n"
  },
  {
    "head": "软件构造(三) 正则表达式",
    "paragraphs": [
      "正则表达式语法",
      "将下一字符标记为特殊字符、文本、反向引用或八进制转义符。eg， n匹配字符 n。\\n 匹配换行符。",
      "零次或多次",
      "匹配前面的字符或子表达式(co*匹配c和coo)",
      "一次或多次",
      "匹配前面的字符或子表达式(co+不匹配c)",
      "零次或一次",
      "匹配前面的字符或子表达式",
      "匹配一个回车",
      "匹配任何空白字符,包括空格,制表,换页符",
      "匹配换行符",
      "数字字符匹配,等效于[0-9]",
      "非数字字符匹配,等效于[^0-9]",
      "匹配任意字类字符,等效于[A-Za-z0-9]",
      "匹配任意非字类字符,等效于[^A-Za-z0-9]",
      "匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与\"\\n\"或\"\\r\"之后的位置匹配。",
      "匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与\"\\n\"或\"\\r\"之前的位置匹配。",
      "[xyz]",
      "匹配包含的",
      "字符集",
      "[a-z]",
      "匹配指定范围内的任何字符[匹配a到z的范围内的任何小写字母]",
      "查找子串中是否包含了Cooing子串:",
      "在 Java 中，\\\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。",
      "Java 中正则表达式中需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\\\ 代表其他语言中的一个 \\，这也就是为什么表示一位数字的正则表达式是 \\\\d，而表示一个普通的反斜杠是 \\\\。"
    ],
    "sentences": [
      "正则表达式语法",
      "将下一字符标记为特殊字符、文本、反向引用或八进制转义符",
      "eg， n匹配字符 n",
      "\\n 匹配换行符",
      "零次或多次",
      "匹配前面的字符或子表达式(co*匹配c和coo)",
      "一次或多次",
      "匹配前面的字符或子表达式(co+不匹配c)",
      "零次或一次",
      "匹配前面的字符或子表达式",
      "匹配一个回车",
      "匹配任何空白字符,包括空格,制表,换页符",
      "匹配换行符",
      "数字字符匹配,等效于[0-9]",
      "非数字字符匹配,等效于[^0-9]",
      "匹配任意字类字符,等效于[A-Za-z0-9]",
      "匹配任意非字类字符,等效于[^A-Za-z0-9]",
      "匹配输入字符串开始的位置",
      "如果设置了 RegExp 对象的 Multiline 属性",
      "^ 还会与\"\\n\"或\"\\r\"之后的位置匹配",
      "匹配输入字符串结尾的位置",
      "如果设置了 RegExp 对象的 Multiline 属性",
      "$ 还会与\"\\n\"或\"\\r\"之前的位置匹配",
      "[xyz]",
      "匹配包含的",
      "字符集",
      "[a-z]",
      "匹配指定范围内的任何字符[匹配a到z的范围内的任何小写字母]",
      "查找子串中是否包含了Cooing子串:在 Java 中",
      "\\\\ 表示：我要插入一个正则表达式的反斜线",
      "所以其后的字符具有特殊的意义",
      "Java 中正则表达式中需要有两个反斜杠才能被解析为其他语言中的转义作用",
      "也可以简单的理解在 Java 的正则表达式中",
      "两个 \\\\ 代表其他语言中的一个 \\",
      "这也就是为什么表示一位数字的正则表达式是 \\\\d",
      "而表示一个普通的反斜杠是 \\\\"
    ],
    "codes": [
      "String pattern = \".*Cooing.*\";\nString content = \"qwqqqqCooingqwqqqqq\";\n\nboolean isMatch = Pattern.matches(pattern, content);\nSystem.out.println(\"字符串中是否包含了'Cooing'子串?\" + isMatch);\n"
    ],
    "date": "2021-07-07",
    "text": "正则表达式语法\n将下一字符标记为特殊字符、文本、反向引用或八进制转义符。eg， n匹配字符 n。\\n 匹配换行符。\n零次或多次\n匹配前面的字符或子表达式(co*匹配c和coo)\n一次或多次\n匹配前面的字符或子表达式(co+不匹配c)\n零次或一次\n匹配前面的字符或子表达式\n匹配一个回车\n匹配任何空白字符,包括空格,制表,换页符\n匹配换行符\n数字字符匹配,等效于[0-9]\n非数字字符匹配,等效于[^0-9]\n匹配任意字类字符,等效于[A-Za-z0-9]\n匹配任意非字类字符,等效于[^A-Za-z0-9]\n匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与\"\\n\"或\"\\r\"之后的位置匹配。\n匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与\"\\n\"或\"\\r\"之前的位置匹配。\n[xyz]\n匹配包含的\n字符集\n[a-z]\n匹配指定范围内的任何字符[匹配a到z的范围内的任何小写字母]\n查找子串中是否包含了Cooing子串:\n在 Java 中，\\\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。\nJava 中正则表达式中需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\\\ 代表其他语言中的一个 \\，这也就是为什么表示一位数字的正则表达式是 \\\\d，而表示一个普通的反斜杠是 \\\\。\n"
  },
  {
    "head": "  软件构造课程随笔--IDEA是如何帮你重写equals()方法的？",
    "paragraphs": [
      "IDEA是如何帮你重写equals()方法的？一. 写在前面",
      "在本软件构造课程的第8讲中，我们学习了如何判断两个对象的等价性，了解了什么是引用等价性(在Java中使用==符号判断)以及什么是",
      "行为等价性(在Java中使用equals()方法来判断)。以及对于immutable的对象，我们应当重写其继承自Object类的equals()方法和hashCode()方法，",
      "并且在其中实现观察等价性或者行为等价性(对immutable对象来说观察等价性就是行为等价性)；而对于mutable对象来说，最好是不对其",
      "继承自Object类的equals()方法和hashCode()方法进行重写，就让它用默认的==来实现行为等价性。",
      "在平时写Java代码的时候，相信大多数同学跟我一样，因为不论使用的IDE是IDEA还是Eclipse，都提供了自动重写equals()和hashCode()方法",
      "的快捷键，所以大家平时应该都不是自己手动重写equals()和hashCode()方法而是依靠IDE帮我们自动生成。这当然是不错的，毕竟",
      "现代IDE的一大工作就是尽可能减少程序员的工作量。不过，在开心的使用IDE的代码自动生成功能之前，我们还是需要仔细了解其原理，不然不管是",
      "期末考试还是以后面试，需要我们手写代码的时候，就露陷了。",
      "因此，本篇博客旨在向大家介绍IDE(以IDEA为例，Eclipse同理)是怎么帮我们重写equals()方法的。特别是考虑到",
      "调查身边同学，问他们是否了解IDE是如何自动生成equals()方法的时候，大家都不是很了解，就更加坚定了我要写一篇这样的博客的决心。希望能对大家有所帮助。",
      "在进入正文之前，首先给出本文中用来进行测试的三个类的代码，他们分别是父类SuperClass、子类SubClassA和SubClassB，代码分别如下：",
      "二. instanceof关键字",
      "在具体介绍IDE是如何自动生成equals()方法之前，首先需要介绍Java当中的一个运算符instanceof和一个方法getClass()方法，它们是IDE在实现",
      "equals()方法时可能会用到的。",
      "首先是instanceof运算符，它的语法为：a instanceof ClassA，其中：a是一个对象而不能是基本数据类型，ClassA是一个类的类名。",
      "当a是ClassA类的对象(包括a是ClassA的构造器构造出的对象，或者是ClassA的任何一个直接或者间接子类的对象，以及当ClassA是接口，a是该接口的实现类的对象等情况)",
      "的时候该运算结果为true，否则为false。",
      "我们来测试一下，测试代码如下，测试结果已经以注释的形式写在了源代码中：",
      "从上述测试结果中我们可以分析得到以下几点信息：",
      "①super1和super2、super3都是instanceof Object、也都是instanceof SuperClass，这是自然的，因为它们都是Object子类的对象，也都是SuperClass或者SuperClass子类的对象。",
      "②super1既不是instanceof SubClassA也不是instanceof SubClassB。注意到super1在定义的时候使用的是SuperClass的构造器，",
      "也就是说其运行时类型为SuperClass，这说明运行时类型为父类的对象并不是instanceof 子类，这是合理的。",
      "③super2是instanceof SubClassA但不是instanceof SubClassB，super3反之。注意到super2在定义的时候使用的是SubClassA的构造器，",
      "其运行时类型为SubClassA，所以super2 instanceof SubClassA == true。这再次说明instanceof在判断的时候使用的是运行时类型。",
      "④subA是instanceof Object，是instanceof SuperClass也是instanceof SubClassA，subB同理，",
      "也都是采用运行时类型判断的。",
      "⑤subA instance of SubClassB以及subB instance of SubClassA都出现了编译时报错，理由都是无法进行类型转换。这是因为",
      "语法a instanceof ClassA需要a满足a的静态类型必须可以转换为ClassA，也就是说a的静态类型必须和ClassA在继承树的同一条路径上。",
      "⑥Java规定当instanceof的左边为null的话，运算结果为false。",
      "以上便是对instanceof运算符的简单介绍。关于instanceof运算符的具体原理以及一些比较深奥的技术细节，可以参考",
      "这篇博客，里面有更详实的介绍。",
      "三. getClass()方法",
      "接着是getClass()方法，它是Object类中一个final public的方法，说明所有的Java类都会拥有该方法且不能重写，其作用为",
      "获得该对象的运行时类型。该方法由于涉及到Java反射的知识，我个人并未有很深的理解，因此这里只是通过一些简单的测试基本了解一下这个方法",
      "是干嘛的，至于更深入的技术细节，已经超出了软件构造课的范围了。",
      "我们来测试一下，测试代码如下，测试结果已经以注释的形式写在了源代码中：",
      "可以看到返回值表示的确实表示的是各个对象对应的运行时类。在本博客中，我们知道这一点就足够了。",
      "四. Object类里面的equals()方法的规约分析",
      "在重写Object类的equals()方法之前，我们当然需要了解并遵守其spec，让我们来看看它的spec：",
      "可以看到我们重写equals()方法的时候，重写后的equals()方法需要满足以下5条性质：",
      "①自反性",
      "②对称性",
      "③传递性",
      "④一致性",
      "⑤对于任何非null的对象x，x.equals(null)==true",
      "我们需要牢记这5点，在这篇博客剩下的部分，我们会时刻关注它们是否被满足。",
      "五. IDEA自动生成equals()方法的原理分析",
      "接下来我们正式进入对IDEA自动生成equals()方法的原理分析部分。以SuperClass为例，",
      "我们来看看其是如何帮我们自动生成equals()方法的：",
      "首先在SuperClass代码所在的页面按下相应快捷键(我在IDEA中设置为ctrl+shift+s)，会弹出一个如下图所示的菜单。",
      "选择其中的equals() and hashCode()点击进入如下图所示的窗口：",
      "在该窗口里有三个可选的部分：",
      "首先是选择Template模板，即选择按照什么样的代码风格来自动生成。",
      "可以看到有IDEA的默认选择模板和Java 7+可用的模板，其区别主要在于Java 7+引入了Objects工具类，",
      "里面提供的Objects.equals()和Objects.hash()两个静态方法可以用来很方便的重写Object类的equals()方法，鉴于课程使用的JDK环境为JDK 8及以上，",
      "所以就选择采用这种模板来重写了。",
      "第二个可选部分并不建议，正如其下方提示所言，这种实现可能会出现类似于违背之前我们所说的equals()方法的5条性质的结果。事实上，在该实现方式中，",
      "正是因为使用了instanceof运算符才导致可能出现不合预期的，之后我们来实际测试一下，这里我们先讲完让IDEA帮我们重写的完整操作步骤。",
      "第三个可选部分是采用相应的get方法获取属性的值，一般无特殊需求时按照默认不选择该选项即可。",
      "接下来按照再选择参与equals()方法判断的属性域，自动生成equals()代码只是简单地依次进行属性域的比较(基本数据类型用==，对象用Objects.equals())，",
      "如下图所示：",
      "再然后是选择参与hashCode()计算的属性域，一般默认且建议与参与equals()比较的属性域保持一致(为了保证equals的对象哈希值相同的规约)，",
      "如下图所示：",
      "最后是选择哪些对象属性域保证非null，一般不选，如下图所示：",
      "最终，若选择了使用instanceof关键字的生成方式的话，按照上述步骤IDEA为SuperClass、SubClassA重写的equals()方法如下：",
      "事实上，这种写法正如之前选择的时候IDEA的提示那样，会违反equals()方法的规约，让我们来看一看测试代码：",
      "可以看到，super1.equals(super2)==true但super2.equals(super1)==false违法了对称性的规约。",
      "这是因为重写Override是运行时才决定调用的具体是父类还是子类的equals()方法，此时super1的静态类型和动态类型都是为SuperClass，super1.equals(super2)",
      "调用的是SuperClass中的equals()方法，此时只比较name和elseSuperFiled两个属性域是否相同，super1和super2在这两个属性域是相同的，所以返回true。",
      "但是super2的静态类型为SuperClass，动态类型为SubClassA，super2.equals(super1)调用的是SubClassA的equals()方法，因为super2 instanceof SubClassA==false",
      "所以super2.equals(super1)的结果为false。同理super1.equals(subA)==true但subA.equals(super1)==false也是合运行时类型有关。",
      "综上得出结论：重写hashCode()的时候尽量不要使用instanceof关键字，而是选择getClass()式的重写方法。",
      "以下是IDEA采用getClass()实现SuperClass和SubClassA的equals()方法的代码：",
      "可以总结出其通用步骤为：",
      "①比较this与o是否引用相等，如果引用相等，当然直接返回true即可。",
      "②判断o是否为null或者其运行时类型是否与该对象的运行时类型不同，如果o为null或运行时类型不同则直接返回false。",
      "③先调用super的equals()方法比较，如果super部分不同直接返回false。",
      "④将o强制类型转换为当前类型。",
      "⑤比较o与当前对象的剩下的属性域。",
      "以上便是对IDEA如何帮我们生成equals()方法介绍，本篇随笔到此结束。感谢阅读，再见！"
    ],
    "sentences": [
      "IDEA是如何帮你重写equals()方法的？一. 写在前面",
      "在本软件构造课程的第8讲中",
      "我们学习了如何判断两个对象的等价性",
      "了解了什么是引用等价性(在Java中使用==符号判断)以及什么是",
      "行为等价性(在Java中使用equals()方法来判断)",
      "以及对于immutable的对象",
      "我们应当重写其继承自Object类的equals()方法和hashCode()方法",
      "并且在其中实现观察等价性或者行为等价性(对immutable对象来说观察等价性就是行为等价性)；而对于mutable对象来说",
      "最好是不对其",
      "继承自Object类的equals()方法和hashCode()方法进行重写",
      "就让它用默认的==来实现行为等价性",
      "在平时写Java代码的时候",
      "相信大多数同学跟我一样",
      "因为不论使用的IDE是IDEA还是Eclipse",
      "都提供了自动重写equals()和hashCode()方法",
      "的快捷键",
      "所以大家平时应该都不是自己手动重写equals()和hashCode()方法而是依靠IDE帮我们自动生成",
      "这当然是不错的，毕竟",
      "现代IDE的一大工作就是尽可能减少程序员的工作量",
      "不过",
      "在开心的使用IDE的代码自动生成功能之前",
      "我们还是需要仔细了解其原理",
      "不然不管是",
      "期末考试还是以后面试，需要我们手写代码的时候，就露陷了",
      "因此",
      "本篇博客旨在向大家介绍IDE(以IDEA为例",
      "Eclipse同理)是怎么帮我们重写equals()方法的",
      "特别是考虑到",
      "调查身边同学",
      "问他们是否了解IDE是如何自动生成equals()方法的时候",
      "大家都不是很了解",
      "就更加坚定了我要写一篇这样的博客的决心",
      "希望能对大家有所帮助",
      "在进入正文之前",
      "首先给出本文中用来进行测试的三个类的代码",
      "他们分别是父类SuperClass、子类SubClassA和SubClassB",
      "代码分别如下：二. instanceof关键字",
      "在具体介绍IDE是如何自动生成equals()方法之前",
      "首先需要介绍Java当中的一个运算符instanceof和一个方法getClass()方法",
      "它们是IDE在实现",
      "equals()方法时可能会用到的",
      "首先是instanceof运算符",
      "它的语法为：a instanceof ClassA",
      "其中：a是一个对象而不能是基本数据类型",
      "ClassA是一个类的类名",
      "当a是ClassA类的对象(包括a是ClassA的构造器构造出的对象",
      "或者是ClassA的任何一个直接或者间接子类的对象",
      "以及当ClassA是接口",
      "a是该接口的实现类的对象等情况)",
      "的时候该运算结果为true，否则为false",
      "我们来测试一下",
      "测试代码如下",
      "测试结果已经以注释的形式写在了源代码中：从上述测试结果中我们可以分析得到以下几点信息：①super1和super2、super3都是instanceof Object、也都是instanceof SuperClass",
      "这是自然的",
      "因为它们都是Object子类的对象",
      "也都是SuperClass或者SuperClass子类的对象",
      "②super1既不是instanceof SubClassA也不是instanceof SubClassB",
      "注意到super1在定义的时候使用的是SuperClass的构造器",
      "也就是说其运行时类型为SuperClass",
      "这说明运行时类型为父类的对象并不是instanceof 子类",
      "这是合理的",
      "③super2是instanceof SubClassA但不是instanceof SubClassB",
      "super3反之",
      "注意到super2在定义的时候使用的是SubClassA的构造器",
      "其运行时类型为SubClassA",
      "所以super2 instanceof SubClassA == true",
      "这再次说明instanceof在判断的时候使用的是运行时类型",
      "④subA是instanceof Object",
      "是instanceof SuperClass也是instanceof SubClassA",
      "subB同理",
      "也都是采用运行时类型判断的",
      "⑤subA instance of SubClassB以及subB instance of SubClassA都出现了编译时报错",
      "理由都是无法进行类型转换",
      "这是因为",
      "语法a instanceof ClassA需要a满足a的静态类型必须可以转换为ClassA",
      "也就是说a的静态类型必须和ClassA在继承树的同一条路径上",
      "⑥Java规定当instanceof的左边为null的话",
      "运算结果为false",
      "以上便是对instanceof运算符的简单介绍",
      "关于instanceof运算符的具体原理以及一些比较深奥的技术细节",
      "可以参考",
      "这篇博客，里面有更详实的介绍",
      "三. getClass()方法",
      "接着是getClass()方法",
      "它是Object类中一个final public的方法",
      "说明所有的Java类都会拥有该方法且不能重写",
      "其作用为",
      "获得该对象的运行时类型",
      "该方法由于涉及到Java反射的知识",
      "我个人并未有很深的理解",
      "因此这里只是通过一些简单的测试基本了解一下这个方法",
      "是干嘛的，至于更深入的技术细节，已经超出了软件构造课的范围了",
      "我们来测试一下",
      "测试代码如下",
      "测试结果已经以注释的形式写在了源代码中：可以看到返回值表示的确实表示的是各个对象对应的运行时类",
      "在本博客中，我们知道这一点就足够了",
      "四. Object类里面的equals()方法的规约分析",
      "在重写Object类的equals()方法之前",
      "我们当然需要了解并遵守其spec",
      "让我们来看看它的spec：可以看到我们重写equals()方法的时候",
      "重写后的equals()方法需要满足以下5条性质：①自反性",
      "②对称性",
      "③传递性",
      "④一致性",
      "⑤对于任何非null的对象x",
      "x.equals(null)==true",
      "我们需要牢记这5点",
      "在这篇博客剩下的部分",
      "我们会时刻关注它们是否被满足",
      "五. IDEA自动生成equals()方法的原理分析",
      "接下来我们正式进入对IDEA自动生成equals()方法的原理分析部分",
      "以SuperClass为例",
      "我们来看看其是如何帮我们自动生成equals()方法的：首先在SuperClass代码所在的页面按下相应快捷键(我在IDEA中设置为ctrl+shift+s)",
      "会弹出一个如下图所示的菜单",
      "选择其中的equals() and hashCode()点击进入如下图所示的窗口：在该窗口里有三个可选的部分：首先是选择Template模板",
      "即选择按照什么样的代码风格来自动生成",
      "可以看到有IDEA的默认选择模板和Java 7+可用的模板",
      "其区别主要在于Java 7+引入了Objects工具类",
      "里面提供的Objects.equals()和Objects.hash()两个静态方法可以用来很方便的重写Object类的equals()方法",
      "鉴于课程使用的JDK环境为JDK 8及以上",
      "所以就选择采用这种模板来重写了",
      "第二个可选部分并不建议",
      "正如其下方提示所言",
      "这种实现可能会出现类似于违背之前我们所说的equals()方法的5条性质的结果",
      "事实上",
      "在该实现方式中",
      "正是因为使用了instanceof运算符才导致可能出现不合预期的",
      "之后我们来实际测试一下",
      "这里我们先讲完让IDEA帮我们重写的完整操作步骤",
      "第三个可选部分是采用相应的get方法获取属性的值",
      "一般无特殊需求时按照默认不选择该选项即可",
      "接下来按照再选择参与equals()方法判断的属性域",
      "自动生成equals()代码只是简单地依次进行属性域的比较(基本数据类型用==",
      "对象用Objects.equals())",
      "如下图所示：再然后是选择参与hashCode()计算的属性域",
      "一般默认且建议与参与equals()比较的属性域保持一致(为了保证equals的对象哈希值相同的规约)",
      "如下图所示：最后是选择哪些对象属性域保证非null",
      "一般不选",
      "如下图所示：最终",
      "若选择了使用instanceof关键字的生成方式的话",
      "按照上述步骤IDEA为SuperClass、SubClassA重写的equals()方法如下：事实上",
      "这种写法正如之前选择的时候IDEA的提示那样",
      "会违反equals()方法的规约",
      "让我们来看一看测试代码：可以看到",
      "super1.equals(super2)==true但super2.equals(super1)==false违法了对称性的规约",
      "这是因为重写Override是运行时才决定调用的具体是父类还是子类的equals()方法",
      "此时super1的静态类型和动态类型都是为SuperClass",
      "super1.equals(super2)",
      "调用的是SuperClass中的equals()方法",
      "此时只比较name和elseSuperFiled两个属性域是否相同",
      "super1和super2在这两个属性域是相同的",
      "所以返回true",
      "但是super2的静态类型为SuperClass",
      "动态类型为SubClassA",
      "super2.equals(super1)调用的是SubClassA的equals()方法",
      "因为super2 instanceof SubClassA==false",
      "所以super2.equals(super1)的结果为false",
      "同理super1.equals(subA)==true但subA.equals(super1)==false也是合运行时类型有关",
      "综上得出结论：重写hashCode()的时候尽量不要使用instanceof关键字",
      "而是选择getClass()式的重写方法",
      "以下是IDEA采用getClass()实现SuperClass和SubClassA的equals()方法的代码：可以总结出其通用步骤为：①比较this与o是否引用相等",
      "如果引用相等",
      "当然直接返回true即可",
      "②判断o是否为null或者其运行时类型是否与该对象的运行时类型不同",
      "如果o为null或运行时类型不同则直接返回false",
      "③先调用super的equals()方法比较",
      "如果super部分不同直接返回false",
      "④将o强制类型转换为当前类型",
      "⑤比较o与当前对象的剩下的属性域",
      "以上便是对IDEA如何帮我们生成equals()方法介绍",
      "本篇随笔到此结束",
      "感谢阅读，再见！"
    ],
    "codes": [
      "//SuperClass类的代码\npublic class SuperClass {\n    String name;\n    int elseSuperFields;\n    \n    //superClass的构造器\n    public SuperClass(String name, int elseSuperFields) {\n        this.name = name;\n        this.elseSuperFields = elseSuperFields;\n    }\n}\n",
      "//SubClassA类的代码\npublic class SubClassA extends SuperClass {\n    //extends String name from SuperClass\n    //extends int elseSuperFields from SuperClass\n    int elseSubAFields;\n    \n    //SubClassA的构造器\n    public SubClassA(String name, int elseSuperFields, int elseSubAFields) {\n        super(name, elseSuperFields);\n        this.elseSubAFields = elseSubAFields;\n    }\n}\n",
      "//SubClassB类的代码\npublic class SubClassB extends SuperClass {\n    //extends String name from SuperClass\n    //extends int elseSuperFields from SuperClass\n    int elseSubBFields;\n    \n    //SubClassB的构造器\n    public SubClassB(String name, int elseSuperFields, int elseSubBFields) {\n        super(name, elseSuperFields);\n        this.elseSubBFields = elseSubBFields;\n    }\n}\n",
      "@Test\npublic void instanceTest() {\n    SuperClass super1 = new SuperClass(\"NAME\", 1);\n    SuperClass super2 = new SubClassA(\"NAME\", 1, 100);\n    SuperClass super3 = new SubClassB(\"NAME\", 1, 101);\n    SubClassA subA = new SubClassA(\"NAME\", 1, 102);\n    SubClassB subB = new SubClassB(\"NAME\", 1, 104);\n    System.out.println(super1 instanceof Object); //true\n    System.out.println(super1 instanceof SuperClass);//true\n    System.out.println(super1 instanceof SubClassA);//false\n    System.out.println(super1 instanceof SubClassB);//false\n    System.out.println(\"************************************\");\n    System.out.println(super2 instanceof Object);//true\n    System.out.println(super2 instanceof SuperClass);//true\n    System.out.println(super2 instanceof SubClassA);//true\n    System.out.println(super2 instanceof SubClassB);//false\n    System.out.println(\"************************************\");\n    System.out.println(super3 instanceof Object);//true\n    System.out.println(super3 instanceof SuperClass);//true\n    System.out.println(super3 instanceof SubClassA);//false\n    System.out.println(super3 instanceof SubClassB);//true\n    System.out.println(\"************************************\");\n    System.out.println(subA instanceof Object);//true\n    System.out.println(subA instanceof SuperClass);//true\n    System.out.println(subA instanceof SubClassA);//true\n    //System.out.println(subA instanceof SubClassB);  //编译报错：Inconvertible types; cannot cast 'UsedClasses.SubClassA' to 'UsedClasses.SubClassB'\n    System.out.println(\"************************************\");\n    System.out.println(subB instanceof Object);//true\n    System.out.println(subB instanceof SuperClass);//true\n    //System.out.println(subB instanceof SubClassA);//true\n    System.out.println(subB instanceof SubClassB);  //编译报错：Inconvertible types; cannot cast 'UsedClasses.SubClassB' to 'UsedClasses.SubClassA'\n    System.out.println(\"************************************\");\n    System.out.println(null instanceof Object);//false\n}\n",
      "@Test\npublic void getClassTest() {\n    SuperClass super1 = new SuperClass(\"NAME\", 1);\n    SuperClass super2 = new SubClassA(\"NAME\", 1, 100);\n    SuperClass super3 = new SubClassB(\"NAME\", 1, 101);\n    SubClassA subA = new SubClassA(\"NAME\", 1, 102);\n    SubClassB subB = new SubClassB(\"NAME\", 1, 103);\n    System.out.println(super1.getClass());\n    System.out.println(super2.getClass());\n    System.out.println(super3.getClass());\n    System.out.println(subA.getClass());\n    System.out.println(subB.getClass());\n    /*\n     * 测试结果，其中UsedClasses为包名\n     * class UsedClasses.SuperClass\n     * class UsedClasses.SubClassA\n     * class UsedClasses.SubClassB\n     * class UsedClasses.SubClassA\n     * class UsedClasses.SubClassB\n     */\n}\n",
      "public boolean equals(Object obj)\nIndicates whether some other object is \"equal to\" this one.\nThe equals method implements an equivalence relation on non-null object references:\n    * It is reflexive: for any non-null reference value x, x.equals(x) should return true.\n    * It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.\n    * It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.\n    * It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.\n    * For any non-null reference value x, x.equals(null) should return false.\nThe equals method for class Object implements the most discriminating possible equivalence relation on objects; \nthat is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true).\nNote that it is generally necessary to override the hashCode method whenever this method is overridden, \nso as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.\n",
      "//IDEA为SuperClass重写的equals()方法，instanceof运算符实现\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof SuperClass)) return false;\n    SuperClass that = (SuperClass) o;\n    return elseSuperFields == that.elseSuperFields && Objects.equals(name, that.name);\n}\n//IDEA为SubClassA重写的equals()方法，instanceof运算符实现\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof SubClassA)) return false;\n    if (!super.equals(o)) return false;\n    SubClassA subClassA = (SubClassA) o;\n    return elseSubAFields == subClassA.elseSubAFields;\n}\n",
      "@Test\npublic void equalsTest() {\n    SuperClass super1 = new SuperClass(\"NAME\", 1);\n    SuperClass super2 = new SubClassA(\"NAME\", 1, 101);\n    SubClassA subA = new SubClassA(\"NAME\", 1, 101);\n    System.out.println(super1.equals(super2));//true\n    System.out.println(super2.equals(super1));//false\n    System.out.println(super1.equals(subA));//true\n    System.out.println(subA.equals(super1));//false\n    System.out.println(super2.equals(subA));//true\n    System.out.println(subA.equals(super2));//true\n}\n",
      "//IDEA为SuperClass重写的equals()方法，getClass()实现\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    SuperClass that = (SuperClass) o;\n    return elseSuperFields == that.elseSuperFields && Objects.equals(name, that.name);\n}\n//IDEA为SubClassA重写的equals()方法，getClass()实现\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    SubClassA subClassA = (SubClassA) o;\n    return elseSubAFields == subClassA.elseSubAFields;\n}\n"
    ],
    "date": "2021-06-18",
    "text": "IDEA是如何帮你重写equals()方法的？一. 写在前面\n在本软件构造课程的第8讲中，我们学习了如何判断两个对象的等价性，了解了什么是引用等价性(在Java中使用==符号判断)以及什么是\n行为等价性(在Java中使用equals()方法来判断)。以及对于immutable的对象，我们应当重写其继承自Object类的equals()方法和hashCode()方法，\n并且在其中实现观察等价性或者行为等价性(对immutable对象来说观察等价性就是行为等价性)；而对于mutable对象来说，最好是不对其\n继承自Object类的equals()方法和hashCode()方法进行重写，就让它用默认的==来实现行为等价性。\n在平时写Java代码的时候，相信大多数同学跟我一样，因为不论使用的IDE是IDEA还是Eclipse，都提供了自动重写equals()和hashCode()方法\n的快捷键，所以大家平时应该都不是自己手动重写equals()和hashCode()方法而是依靠IDE帮我们自动生成。这当然是不错的，毕竟\n现代IDE的一大工作就是尽可能减少程序员的工作量。不过，在开心的使用IDE的代码自动生成功能之前，我们还是需要仔细了解其原理，不然不管是\n期末考试还是以后面试，需要我们手写代码的时候，就露陷了。\n因此，本篇博客旨在向大家介绍IDE(以IDEA为例，Eclipse同理)是怎么帮我们重写equals()方法的。特别是考虑到\n调查身边同学，问他们是否了解IDE是如何自动生成equals()方法的时候，大家都不是很了解，就更加坚定了我要写一篇这样的博客的决心。希望能对大家有所帮助。\n在进入正文之前，首先给出本文中用来进行测试的三个类的代码，他们分别是父类SuperClass、子类SubClassA和SubClassB，代码分别如下：\n二. instanceof关键字\n在具体介绍IDE是如何自动生成equals()方法之前，首先需要介绍Java当中的一个运算符instanceof和一个方法getClass()方法，它们是IDE在实现\nequals()方法时可能会用到的。\n首先是instanceof运算符，它的语法为：a instanceof ClassA，其中：a是一个对象而不能是基本数据类型，ClassA是一个类的类名。\n当a是ClassA类的对象(包括a是ClassA的构造器构造出的对象，或者是ClassA的任何一个直接或者间接子类的对象，以及当ClassA是接口，a是该接口的实现类的对象等情况)\n的时候该运算结果为true，否则为false。\n我们来测试一下，测试代码如下，测试结果已经以注释的形式写在了源代码中：\n从上述测试结果中我们可以分析得到以下几点信息：\n①super1和super2、super3都是instanceof Object、也都是instanceof SuperClass，这是自然的，因为它们都是Object子类的对象，也都是SuperClass或者SuperClass子类的对象。\n②super1既不是instanceof SubClassA也不是instanceof SubClassB。注意到super1在定义的时候使用的是SuperClass的构造器，\n也就是说其运行时类型为SuperClass，这说明运行时类型为父类的对象并不是instanceof 子类，这是合理的。\n③super2是instanceof SubClassA但不是instanceof SubClassB，super3反之。注意到super2在定义的时候使用的是SubClassA的构造器，\n其运行时类型为SubClassA，所以super2 instanceof SubClassA == true。这再次说明instanceof在判断的时候使用的是运行时类型。\n④subA是instanceof Object，是instanceof SuperClass也是instanceof SubClassA，subB同理，\n也都是采用运行时类型判断的。\n⑤subA instance of SubClassB以及subB instance of SubClassA都出现了编译时报错，理由都是无法进行类型转换。这是因为\n语法a instanceof ClassA需要a满足a的静态类型必须可以转换为ClassA，也就是说a的静态类型必须和ClassA在继承树的同一条路径上。\n⑥Java规定当instanceof的左边为null的话，运算结果为false。\n以上便是对instanceof运算符的简单介绍。关于instanceof运算符的具体原理以及一些比较深奥的技术细节，可以参考\n这篇博客，里面有更详实的介绍。\n三. getClass()方法\n接着是getClass()方法，它是Object类中一个final public的方法，说明所有的Java类都会拥有该方法且不能重写，其作用为\n获得该对象的运行时类型。该方法由于涉及到Java反射的知识，我个人并未有很深的理解，因此这里只是通过一些简单的测试基本了解一下这个方法\n是干嘛的，至于更深入的技术细节，已经超出了软件构造课的范围了。\n我们来测试一下，测试代码如下，测试结果已经以注释的形式写在了源代码中：\n可以看到返回值表示的确实表示的是各个对象对应的运行时类。在本博客中，我们知道这一点就足够了。\n四. Object类里面的equals()方法的规约分析\n在重写Object类的equals()方法之前，我们当然需要了解并遵守其spec，让我们来看看它的spec：\n可以看到我们重写equals()方法的时候，重写后的equals()方法需要满足以下5条性质：\n①自反性\n②对称性\n③传递性\n④一致性\n⑤对于任何非null的对象x，x.equals(null)==true\n我们需要牢记这5点，在这篇博客剩下的部分，我们会时刻关注它们是否被满足。\n五. IDEA自动生成equals()方法的原理分析\n接下来我们正式进入对IDEA自动生成equals()方法的原理分析部分。以SuperClass为例，\n我们来看看其是如何帮我们自动生成equals()方法的：\n首先在SuperClass代码所在的页面按下相应快捷键(我在IDEA中设置为ctrl+shift+s)，会弹出一个如下图所示的菜单。\n选择其中的equals() and hashCode()点击进入如下图所示的窗口：\n在该窗口里有三个可选的部分：\n首先是选择Template模板，即选择按照什么样的代码风格来自动生成。\n可以看到有IDEA的默认选择模板和Java 7+可用的模板，其区别主要在于Java 7+引入了Objects工具类，\n里面提供的Objects.equals()和Objects.hash()两个静态方法可以用来很方便的重写Object类的equals()方法，鉴于课程使用的JDK环境为JDK 8及以上，\n所以就选择采用这种模板来重写了。\n第二个可选部分并不建议，正如其下方提示所言，这种实现可能会出现类似于违背之前我们所说的equals()方法的5条性质的结果。事实上，在该实现方式中，\n正是因为使用了instanceof运算符才导致可能出现不合预期的，之后我们来实际测试一下，这里我们先讲完让IDEA帮我们重写的完整操作步骤。\n第三个可选部分是采用相应的get方法获取属性的值，一般无特殊需求时按照默认不选择该选项即可。\n接下来按照再选择参与equals()方法判断的属性域，自动生成equals()代码只是简单地依次进行属性域的比较(基本数据类型用==，对象用Objects.equals())，\n如下图所示：\n再然后是选择参与hashCode()计算的属性域，一般默认且建议与参与equals()比较的属性域保持一致(为了保证equals的对象哈希值相同的规约)，\n如下图所示：\n最后是选择哪些对象属性域保证非null，一般不选，如下图所示：\n最终，若选择了使用instanceof关键字的生成方式的话，按照上述步骤IDEA为SuperClass、SubClassA重写的equals()方法如下：\n事实上，这种写法正如之前选择的时候IDEA的提示那样，会违反equals()方法的规约，让我们来看一看测试代码：\n可以看到，super1.equals(super2)==true但super2.equals(super1)==false违法了对称性的规约。\n这是因为重写Override是运行时才决定调用的具体是父类还是子类的equals()方法，此时super1的静态类型和动态类型都是为SuperClass，super1.equals(super2)\n调用的是SuperClass中的equals()方法，此时只比较name和elseSuperFiled两个属性域是否相同，super1和super2在这两个属性域是相同的，所以返回true。\n但是super2的静态类型为SuperClass，动态类型为SubClassA，super2.equals(super1)调用的是SubClassA的equals()方法，因为super2 instanceof SubClassA==false\n所以super2.equals(super1)的结果为false。同理super1.equals(subA)==true但subA.equals(super1)==false也是合运行时类型有关。\n综上得出结论：重写hashCode()的时候尽量不要使用instanceof关键字，而是选择getClass()式的重写方法。\n以下是IDEA采用getClass()实现SuperClass和SubClassA的equals()方法的代码：\n可以总结出其通用步骤为：\n①比较this与o是否引用相等，如果引用相等，当然直接返回true即可。\n②判断o是否为null或者其运行时类型是否与该对象的运行时类型不同，如果o为null或运行时类型不同则直接返回false。\n③先调用super的equals()方法比较，如果super部分不同直接返回false。\n④将o强制类型转换为当前类型。\n⑤比较o与当前对象的剩下的属性域。\n以上便是对IDEA如何帮我们生成equals()方法介绍，本篇随笔到此结束。感谢阅读，再见！\n"
  },
  null,
  null,
  null,
  null,
  null,
  {
    "head": "软件构造-学习笔记9：可维护性的常见度量指标",
    "paragraphs": [
      "可维护性的常见度量指标",
      "指标：",
      "圈复杂度",
      "代码行数",
      "可维护性指数",
      "继承的层次数",
      "类之间的耦合度",
      "单元测试的覆盖度",
      "实际方法：",
      "继承的层次数",
      "类之间的耦合度",
      "单元测试的覆盖度",
      "聚合度与耦合度",
      "模块化编程：高内聚 & 低耦合",
      "Direct Mapping",
      "Few Interfaces",
      "尽可能",
      "的接口",
      "Small Interfaces",
      "尽可能",
      "的接口",
      "Explicit Interfaces",
      "Information Hiding"
    ],
    "sentences": [
      "可维护性的常见度量指标",
      "指标：圈复杂度",
      "代码行数",
      "可维护性指数",
      "继承的层次数",
      "类之间的耦合度",
      "单元测试的覆盖度",
      "实际方法：继承的层次数",
      "类之间的耦合度",
      "单元测试的覆盖度",
      "聚合度与耦合度",
      "模块化编程：高内聚 & 低耦合",
      "Direct Mapping",
      "Few Interfaces",
      "尽可能",
      "的接口",
      "Small Interfaces",
      "尽可能",
      "的接口",
      "Explicit Interfaces",
      "Information Hiding"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "可维护性的常见度量指标\n指标：\n圈复杂度\n代码行数\n可维护性指数\n继承的层次数\n类之间的耦合度\n单元测试的覆盖度\n实际方法：\n继承的层次数\n类之间的耦合度\n单元测试的覆盖度\n聚合度与耦合度\n模块化编程：高内聚 & 低耦合\nDirect Mapping\nFew Interfaces\n尽可能\n的接口\nSmall Interfaces\n尽可能\n的接口\nExplicit Interfaces\nInformation Hiding\n"
  },
  {
    "head": "软件构造-学习笔记2：解决在已经push至Github后，.gitignore文件无法生效的问题",
    "paragraphs": [
      "原因是：.gitignore只能忽略那些没有被纳入版本管理的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除，然后再提交：",
      "方法：打开Git Bash，进入你想删除本地缓存仓库的目录，之后执行：",
      "之后正常push，.gitignore文件即可正常生效。"
    ],
    "sentences": [
      "原因是：.gitignore只能忽略那些没有被纳入版本管理的文件",
      "如果某些文件已经被纳入了版本管理中",
      "则修改.gitignore是无效的",
      "那么解决方法就是先把本地缓存删除",
      "然后再提交：方法：打开Git Bash",
      "进入你想删除本地缓存仓库的目录",
      "之后执行：之后正常push",
      ".gitignore文件即可正常生效"
    ],
    "codes": [
      "git rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n"
    ],
    "date": "2021-05-18",
    "text": "原因是：.gitignore只能忽略那些没有被纳入版本管理的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除，然后再提交：\n方法：打开Git Bash，进入你想删除本地缓存仓库的目录，之后执行：\n之后正常push，.gitignore文件即可正常生效。\n"
  },
  {
    "head": "软件构造-学习笔记7：重载（overloading）和重写（overriding）的区别",
    "paragraphs": [
      "重载（overloading）和重写（overriding）的区别",
      "文章目录",
      "重载（overloading）和重写（overriding）的区别",
      "重载（overloading）",
      "重写（overriding）",
      "重载（overloading）",
      "重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。",
      "每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。",
      "最常用的地方就是构造器的重载。",
      "事实上，重载也可以针对同一函数针对不同传入类型进行设计，如在实验三中可以针对为IntervalSet和MultiIntervalSet进行重载，以展示出不同的行为。",
      "在一个类中，同名的方法有不同的参数列表，这是重载表现出的效果",
      "重载的参数列表一定要是不同的。这里的参数列表可以看做不同的对象。发生重载一定是在一个类中，重载是针对不同的对象有不同的操作。",
      "重载是实现多态的一种方式（编译阶段）",
      "重载对返回类型没有要求，但不能有两个同名同参数列表、返回类型不同的函数。",
      "重写（overriding）",
      "重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！",
      "重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。",
      "重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。",
      "在面向对象原则里，重写意味着可以重写任何现有方法。",
      "重写是发生在两个类之间，即子类对父类中的方法进行重新定义。但子类不可以改变父类方法的方法名，参数列表，返回类型（除非子类的返回值是它父类的返回值的子类）。",
      "重写也是实现多态的一种方式（运行阶段）",
      "重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常",
      "在重写方法中，对访问修饰符的限制，子类一定要大于父类（public>protected>default>private)"
    ],
    "sentences": [
      "重载（overloading）和重写（overriding）的区别",
      "文章目录",
      "重载（overloading）和重写（overriding）的区别",
      "重载（overloading）",
      "重写（overriding）",
      "重载（overloading）",
      "重载(overloading) 是在一个类里面",
      "方法名字相同",
      "而参数不同",
      "返回类型可以相同也可以不同",
      "每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表",
      "最常用的地方就是构造器的重载",
      "事实上",
      "重载也可以针对同一函数针对不同传入类型进行设计",
      "如在实验三中可以针对为IntervalSet和MultiIntervalSet进行重载",
      "以展示出不同的行为",
      "在一个类中，同名的方法有不同的参数列表，这是重载表现出的效果",
      "重载的参数列表一定要是不同的",
      "这里的参数列表可以看做不同的对象",
      "发生重载一定是在一个类中，重载是针对不同的对象有不同的操作",
      "重载是实现多态的一种方式（编译阶段）",
      "重载对返回类型没有要求",
      "但不能有两个同名同参数列表、返回类型不同的函数",
      "重写（overriding）",
      "重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变",
      "即外壳不变，核心重写！",
      "重写的好处在于子类可以根据需要，定义特定于自己的行为",
      " 也就是说子类能够根据需要实现父类的方法",
      "重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常",
      "例如： 父类的一个方法申明了一个检查异常 IOException",
      "但是在重写这个方法的时候不能抛出 Exception 异常",
      "因为 Exception 是 IOException 的父类",
      "只能抛出 IOException 的子类异常",
      "在面向对象原则里，重写意味着可以重写任何现有方法",
      "重写是发生在两个类之间，即子类对父类中的方法进行重新定义",
      "但子类不可以改变父类方法的方法名",
      "参数列表",
      "返回类型（除非子类的返回值是它父类的返回值的子类）",
      "重写也是实现多态的一种方式（运行阶段）",
      "重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常",
      "在重写方法中",
      "对访问修饰符的限制",
      "子类一定要大于父类（public>protected>default>private)"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "重载（overloading）和重写（overriding）的区别\n文章目录\n重载（overloading）和重写（overriding）的区别\n重载（overloading）\n重写（overriding）\n重载（overloading）\n重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n最常用的地方就是构造器的重载。\n事实上，重载也可以针对同一函数针对不同传入类型进行设计，如在实验三中可以针对为IntervalSet和MultiIntervalSet进行重载，以展示出不同的行为。\n在一个类中，同名的方法有不同的参数列表，这是重载表现出的效果\n重载的参数列表一定要是不同的。这里的参数列表可以看做不同的对象。发生重载一定是在一个类中，重载是针对不同的对象有不同的操作。\n重载是实现多态的一种方式（编译阶段）\n重载对返回类型没有要求，但不能有两个同名同参数列表、返回类型不同的函数。\n重写（overriding）\n重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！\n重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。\n重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。\n在面向对象原则里，重写意味着可以重写任何现有方法。\n重写是发生在两个类之间，即子类对父类中的方法进行重新定义。但子类不可以改变父类方法的方法名，参数列表，返回类型（除非子类的返回值是它父类的返回值的子类）。\n重写也是实现多态的一种方式（运行阶段）\n重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\n在重写方法中，对访问修饰符的限制，子类一定要大于父类（public>protected>default>private)\n"
  },
  {
    "head": "软件构造-学习笔记10：Try-Catch中finally的用法",
    "paragraphs": [
      "Try-Catch中finally的用法",
      "Java 中的 Finally 关键一般与try一起使用，在程序进入try块之后，无论程序是因为异常而中止或其它方式返回终止的，finally块的内容一定会被执行 。",
      "考题类型：判断try-catch块中多catch异常下的代码执行顺序：finally块中内容一定会执行。"
    ],
    "sentences": [
      "Try-Catch中finally的用法",
      "Java 中的 Finally 关键一般与try一起使用",
      "在程序进入try块之后",
      "无论程序是因为异常而中止或其它方式返回终止的",
      "finally块的内容一定会被执行 ",
      "考题类型：判断try-catch块中多catch异常下的代码执行顺序：finally块中内容一定会执行"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "Try-Catch中finally的用法\nJava 中的 Finally 关键一般与try一起使用，在程序进入try块之后，无论程序是因为异常而中止或其它方式返回终止的，finally块的内容一定会被执行 。\n考题类型：判断try-catch块中多catch异常下的代码执行顺序：finally块中内容一定会执行。\n"
  },
  {
    "head": "软件构造-学习笔记3：解决Selected Class file name ‘HelloWorld.Java‘ mapped to not java file type“”的问题",
    "paragraphs": [
      "原因：不小心创建了同名的文本文件，idea将其认定为模板存储在了File Types中，这时只需要打开：settings-Editor-File Types，在左侧边栏找到你报错的相关文件类型，将右下方的固定模板删去即可。"
    ],
    "sentences": [
      "原因：不小心创建了同名的文本文件",
      "idea将其认定为模板存储在了File Types中",
      "这时只需要打开：settings-Editor-File Types",
      "在左侧边栏找到你报错的相关文件类型",
      "将右下方的固定模板删去即可"
    ],
    "codes": [],
    "date": "2021-05-23",
    "text": "原因：不小心创建了同名的文本文件，idea将其认定为模板存储在了File Types中，这时只需要打开：settings-Editor-File Types，在左侧边栏找到你报错的相关文件类型，将右下方的固定模板删去即可。\n"
  },
  {
    "head": "软件构造-学习笔记1：解决使用IDEA通过HTTPS链接无法提交代码至github的问题",
    "paragraphs": [
      "解决使用IDEA通过HTTPS链接无法提交代码至github的问题",
      "一、初次尝试解决：",
      "首先是遇到了如图所示的报错：",
      "起初猜测是网络环境问题，之后尝试SCIENCE上网之后遇到新的报错：",
      "OpenSSL SSL_read: Connection was reset, errno 10054",
      "查阅前人经验得知：",
      "首先，造成这个错误很有可能是网络不稳定，连接超时导致的。",
      "当时给出的解决方式是在Git Bash中使用如下命令：",
      "据查看文档得知，该命令作用为解除git对SSL证书错误的的限制，这个错误并不重要是系统证书的问题，系统判断到这个行为会造成不良影响，所以进行了阻止，只要设置跳过SSL证书验证就可以了。",
      "初次使用确实有效，但似乎每次重启电脑后在push之前都需要输入该命令，十分麻烦。",
      "二、使用SSH",
      "参见文章",
      "GitHub如何配置SSH Key",
      "感谢博主 @前端向朔 的分享，配置成功后push过程顺利。"
    ],
    "sentences": [
      "解决使用IDEA通过HTTPS链接无法提交代码至github的问题",
      "一、初次尝试解决：首先是遇到了如图所示的报错：起初猜测是网络环境问题",
      "之后尝试SCIENCE上网之后遇到新的报错：OpenSSL SSL_read: Connection was reset, errno 10054",
      "查阅前人经验得知：首先",
      "造成这个错误很有可能是网络不稳定",
      "连接超时导致的",
      "当时给出的解决方式是在Git Bash中使用如下命令：据查看文档得知",
      "该命令作用为解除git对SSL证书错误的的限制",
      "这个错误并不重要是系统证书的问题",
      "系统判断到这个行为会造成不良影响",
      "所以进行了阻止",
      "只要设置跳过SSL证书验证就可以了",
      "初次使用确实有效",
      "但似乎每次重启电脑后在push之前都需要输入该命令",
      "十分麻烦",
      "二、使用SSH",
      "参见文章",
      "GitHub如何配置SSH Key",
      "感谢博主 @前端向朔 的分享，配置成功后push过程顺利"
    ],
    "codes": [
      "git config --global http.sslVerify \"false\"\n"
    ],
    "date": "2021-05-18",
    "text": "解决使用IDEA通过HTTPS链接无法提交代码至github的问题\n一、初次尝试解决：\n首先是遇到了如图所示的报错：\n起初猜测是网络环境问题，之后尝试SCIENCE上网之后遇到新的报错：\nOpenSSL SSL_read: Connection was reset, errno 10054\n查阅前人经验得知：\n首先，造成这个错误很有可能是网络不稳定，连接超时导致的。\n当时给出的解决方式是在Git Bash中使用如下命令：\n据查看文档得知，该命令作用为解除git对SSL证书错误的的限制，这个错误并不重要是系统证书的问题，系统判断到这个行为会造成不良影响，所以进行了阻止，只要设置跳过SSL证书验证就可以了。\n初次使用确实有效，但似乎每次重启电脑后在push之前都需要输入该命令，十分麻烦。\n二、使用SSH\n参见文章\nGitHub如何配置SSH Key\n感谢博主 @前端向朔 的分享，配置成功后push过程顺利。\n"
  },
  {
    "head": "软件构造-学习笔记5：一种处理整数时间点和字符型时间的方法",
    "paragraphs": [
      "Date和Calendar类的灵活使用",
      "注意DateFormat的使用，有助于这种转换。"
    ],
    "sentences": [
      "Date和Calendar类的灵活使用",
      "注意DateFormat的使用，有助于这种转换"
    ],
    "codes": [
      "public long daysBetween(String startTime,String endTime) throws ParseException {\n        SimpleDateFormat DateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n        Date date1 = DateFormat.parse(startTime);\n        Date date2 = DateFormat.parse(endTime);\n        Calendar cal = Calendar.getInstance();\n        cal.setTime(date1);\n        long time1 = cal.getTimeInMillis();\n        cal.setTime(date2);\n        long time2 = cal.getTimeInMillis();\n        long between_days=(time2-time1)/(1000*3600*24);\n        return Integer.parseInt(String.valueOf(between_days));\n    }\n",
      "public Date dateiswhat(long point) throws ParseException {\n        SimpleDateFormat DateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n        Date date1 = DateFormat.parse(startTime);\n        Calendar rightNow = Calendar.getInstance();\n        rightNow.setTime(date1);\n        rightNow.add(Calendar.DAY_OF_YEAR,(int)point);\n        Date DT=rightNow.getTime();\n        return DT;\n    }\n"
    ],
    "date": "2021-07-04",
    "text": "Date和Calendar类的灵活使用\n注意DateFormat的使用，有助于这种转换。\n"
  },
  {
    "head": "软件构造-学习笔记6：对于final关键字的理解",
    "paragraphs": [
      "在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。",
      "修饰类：",
      "当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被",
      "隐式地",
      "指定为final方法。",
      "修饰方法：",
      "使用final修饰方法时，说明这个方法不允许被重写、修改，相当于“锁定”。",
      "修饰变量：",
      "final成员变量表示常量，只能被赋值一次，赋值后值不再改变。当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。就如同Snap shot里的双箭头含义一样：不可以指向其他地方。在本质上是一个意思，因为对于引用类型说，引用的值是一个地址，final要求该值，即地址的值不发生变化。",
      "final修饰一个成员变量（属性），必须要显式的初始化。"
    ],
    "sentences": [
      "在Java中",
      "final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）",
      "修饰类：当用final修饰一个类时，表明这个类不能被继承",
      "也就是说",
      "如果一个类你永远不会让他被继承",
      "就可以用final进行修饰",
      "final类中的成员变量可以根据需要设为final",
      "但是要注意final类中的所有成员方法都会被",
      "隐式地",
      "指定为final方法",
      "修饰方法：使用final修饰方法时",
      "说明这个方法不允许被重写、修改",
      "相当于“锁定”",
      "修饰变量：final成员变量表示常量",
      "只能被赋值一次",
      "赋值后值不再改变",
      "当final修饰一个基本数据类型时",
      "表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时",
      "则在对其初始化之后便不能再让其指向其他对象了",
      "但该引用所指向的对象的内容是可以发生变化的",
      "就如同Snap shot里的双箭头含义一样：不可以指向其他地方",
      "在本质上是一个意思",
      "因为对于引用类型说",
      "引用的值是一个地址",
      "final要求该值",
      "即地址的值不发生变化",
      "final修饰一个成员变量（属性），必须要显式的初始化"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。\n修饰类：\n当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被\n隐式地\n指定为final方法。\n修饰方法：\n使用final修饰方法时，说明这个方法不允许被重写、修改，相当于“锁定”。\n修饰变量：\nfinal成员变量表示常量，只能被赋值一次，赋值后值不再改变。当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。就如同Snap shot里的双箭头含义一样：不可以指向其他地方。在本质上是一个意思，因为对于引用类型说，引用的值是一个地址，final要求该值，即地址的值不发生变化。\nfinal修饰一个成员变量（属性），必须要显式的初始化。\n"
  },
  {
    "head": "软件构造-学习笔记4：Javafor遍历是如何判断数据是不是list的最后一位",
    "paragraphs": [
      "Javafor遍历是如何判断数据是不是list的最后一位",
      "如果该表达式成立，则说明数据为list的最后一位"
    ],
    "sentences": [
      "Javafor遍历是如何判断数据是不是list的最后一位",
      "如果该表达式成立，则说明数据为list的最后一位"
    ],
    "codes": [
      "if(employees.size() - 1 == employees.indexOf(e)){\n"
    ],
    "date": "2021-07-04",
    "text": "Javafor遍历是如何判断数据是不是list的最后一位\n如果该表达式成立，则说明数据为list的最后一位\n"
  },
  {
    "head": "软件构造实验总结",
    "paragraphs": [
      "Lab1",
      "现在做完三个实验再回头看Lab1，发现真是基本没干什么，只是简单地熟悉了一下Java编程。",
      "P1：Magic Squares",
      "我遇到的问题主要是要实现从文本中读入数据并进行合法性判断的功能。通过上网查阅资料，最终学会了读操作，需要用到FileReader和BufferedReader。这是第一次的上网自学，当时还觉得挺了不起的，后来发现在编程过程中上网自学一些Java中的有关知识简直就是家常便饭。",
      "后续的数据操作此处不再描述，我当时的代码风格还是C的风格，比如使用大量一维数组、二维数组进行遍历查找，但在后面的实验中有逐渐改进，慢慢地习惯了使用List、使用迭代器等等。",
      "P2：Turtle Graphics",
      "这个任务是我第一次接触到的填空式的程序设计，形式很新颖，趣味性较强。",
      "任务要求主要就是参照给出的spec完成几个方法的实现，使得已有测试用例能通过（这也是在此门课程中首次接触到Junit测试）。每个待实现的方法其实都是一些简单的算法。值得一提的是一个求解凸包的问题，我的大致思路是先找到所有点当中的最左下角的点，然后遍历其他的点，找到能使得turtle旋转角度最小的点，移动到该点上，再用相同方法继续查找下一个点，以此类推，直到回到一开始选定的最左下角的点，说明已经找到了所有点当中在最外圈的点，也就得到了凸包。",
      "当我把一个到处是空白的框架逐渐丰满起来，测试用例也一个个通过的时候，还是很欣慰很有成就感的。",
      "P3：Social Network",
      "这个任务要求设计实现一个FriendshipGraph类来表示现实生活中的社交关系图，还要设计一个Person类来表示人，最后还要自己编写测试用例来对FriendshipGraph中的方法进行测试。当时觉得做了好多的工作，现在回头看只想一笑而过。",
      "在这个任务的完成过程中，我对ADT以及TDD有了一个最最基本的了解（虽然这时候还不知道这些名词），初次感受了一个比较完整的简易的程序设计流程。至于完整的设计流程，在Lab2和Lab3中逐渐揭开了神秘的面纱。",
      "Lab2",
      "从Lab2开始，总算是接触到这门课程的核心了——ADT和OOP，实验难度也有了明显提升。",
      "P1：Poetic Walks",
      "其实P1可以被分成两个部分，第一个部分是设计一套ADT，第二个部分是利用这个设计好的ADT来完成一个应用，也就是poetic walks。",
      "这个任务和Lab1的P2一样，也是填空，不过这次填的东西就多了。查看已经给出的Graph类，里面声明了一些方法，通过对每个方法的spec进行阅读，确定首先要做的就是划分等价类、写测试策略并设计测试用例。这其实就是TDD的一个体现，以前的编程中我都是直接完成实现，在这里按照要求应该先完成测试用例，这样能使方法在实现之后能立即得到测试，确保其正确性及健壮性，而且在设计测试用例的过程中，我们也能提前考虑各种特殊情况，在完成实现的时候加以注意。",
      "完成了测试用例，接下来就该实现Graph了。任务中要求了两种实现方式ConcreteEdgesGraph和ConcreteVerticesGraph，这就是对OOP中继承关系的体现了。两个类都是对抽象接口Graph的实现，只是两者的内部逻辑不一样，但对外表现出来的都是一样的，都能提供Graph中的方法。两者的测试用例也是一样的，都继承自Graph的测试用例，因为实现了相同的方法。",
      "在实现过程中，还涉及到了mutability/immutability说明、AF、RI、safety from rep exposure以及每个方法的spec，这些内容部分已经给出，但绝大部分仍需要自行添加完善。这些说明能使代码具有更加清晰的逻辑，既能帮助别人读懂自己的代码，又能方便日后查看代码时快速明白当初的想法，还能提醒自己时刻注意所写程序的正确性、安全性，保证不会在以后被客户端恶意操作，同时也可以清楚展示给客户端各个方法能实现什么功能，以及该怎么输入。",
      "接下来就进入了P1的第二个部分，应用ADT实现一个poetic walks的功能。还是一样的，先阅读spec了解清楚各个方法要实现的功能，设计相关的测试用例，然后再实现各方法，完善mutability/immutability说明、AF、RI、safety from rep exposure以及每个方法的spec。在实现各个方法的时候，由于已经设计好了ADT，所以能直接调用其中的方法，省去了很多工作。",
      "P2：Reimplement Social Network",
      "这个任务其实和P1的第二部分是一样的，就是用已设计的ADT来完成一个应用的实现，而这个实现正是在Lab1中完成过的社交关系图。有了Graph这个强有力的ADT，很快就能实现FriendshipGraph这个类。同样，mutability说明、AF、RI、safety from rep exposure以及每个方法的spec也是不可省略的。虽然这里只需要把Lab1的测试用例直接拿来用就行，但为了按照更标准的模板来，我还是划分等价类、写测试策略并设计测试用例，使得测试更加充分。",
      "到此，我在Lab2中初次体验了",
      "面向ADT的编程。不同于以往的直接面向应用场景的编程，面向ADT的编程是一种具有更长远眼光的做法，能在以后更加方便的实现更多具有相似性的应用；面向应用场景的编程虽然在短期看来很方便，但是可扩展性差，在遇到相似情景的时候，只能做大量重复工作，将相似的功能进行反复开发，效率较低。",
      "Lab3",
      "到了Lab3，就是整个三次实验的最高潮了，除了一份实验手册上的思路介绍，所有的东西都要自己设计与实现，是真正的从零开始。",
      "在Lab3里，要求实现三个应用——排班管理系统、操作系统进程调度管理系统和课表管理系统。对这三个应用进行分析，能发现它们均涉及到具有不同特征的“时间段集合”这种对象，为了提高软件的可复用性和可维护性，可以设计构造一套ADT。",
      "一开始我还比较迷茫，就参照着Lab2中设计Graph的那一套流程来进行。首先是设计IntervalSet，在实验手册的提示下，我确定了IntervalSet这个抽象接口中的方法，并完成了每个方法的spec。然后划分等价类、写测试策略并设计测试用例。接下来对IntervalSet这个接口进行实现，不同于Lab2的是，这里只用完成一个实现，即CommonIntervalSet。mutability说明、AF、RI和safety from rep exposure也是需要完成的。这样做下来，我也渐渐明白了设计流程。",
      "在IntervalSet的spec里面，提到里面的时间段的“标签”是不能重复的，这在排班管理系统里适用，但在操作系统进程调度管理系统和课表管理系统里就不适用了。于是，我们还要设计实现另一种“时间段集合”MultiIntervalSet，它允许不同时间段的标签“重复”。在实验里，我选择将其直接实现为具体的类，而没有设计相关的接口。和IntervalSet一样，MultiIntervalSet各个方法的设计与spec撰写、测试策略、测试用例、方法的具体实现、mutability说明、AF、RI和safety from rep exposure都得按顺序逐一实现。",
      "接下来就要对局部共性进行设计与实现了，这里将用到设计模式的相关知识，我最终选择的是装饰器模式。对于三个维度的特性——是否允许空白、是否允许重叠及是否需要周期性重复，将它们分别看做一层层装饰，逐一地加到原本的对象上。由于排班管理系统会基于IntervalSet来实现，而它要求不允许空白和不允许重叠的特性，我就为之设计了两个用来装饰的类NoBlankIntervalSet和NonOverlapIntervalSet，它们都继承同一个类IntervalSetDecorator，而这个类是对接口IntervalSet的一个实现。然后再将NoBlankIntervalSet和NonOverlapIntervalSet逐层装饰到IntervalSet上，就得到了用于排班管理系统的DutyIntervalSet。",
      "需要注意的是，NoBlankIntervalSet中添加了原IntervalSet中没有的方法checkNoBlank，为了能调用这个方法，在装饰的时候需要把它放在最外面的一层，并将对象声明为NoBlankIntervalSet而非IntervalSet。这样看来似乎有些打破装饰器模式，但我在查阅资料时发现这被称为半透明的装饰器模式，介于装饰器模式和适配器模式之间，允许对接口进行改变以增强功能。",
      "类似的思路，继续为基于MultiIntervalSet的操作系统进程调度管理系统和课表管理系统设计MultiIntervalSetDecorator类，注意它并不是实现MultiIntervalSet，因为MultiIntervalSet已经是具体的类，而非抽象接口。这样似乎又违背了装饰器模式，但是其思路是完全一致的。再设计并实现NonOverlapMultiIntervalSet、OverlapMultiIntervalSet和PeriodicMultiIntervalSet，并通过包装得到用于操作系统进程调度管理系统的ProcessIntervalSet和用于课表管理系统的CourseIntervalSet。同NoBlankIntervalSet一样，PeriodicMultiIntervalSet也属于半透明的装饰器模式。",
      "设计完三个面向应用的ADT，再追加三个immutable的类Employee、Process和Course，以及自主设计的API，我们的基础框架就整个完成了。运用这一套自主设计的ADT，我们已经能解决不少现实中的问题了。",
      "接下来的工作就是用已经开发好的ADT来完成一开始提到的三个应用——DutyRosterApp、ProcessScheduleApp和CourseScheduleApp。在已有的ADT的帮助下，每个应用中要求的功能都比较容易想到解决方案。几个小的问题，例如对日期的计算、随机执行时间的“随机”的实现等，在自学LocalDate和Random后都能很快解决。比较大的问题就是对于各种情况的分类讨论不够全面，总是会出现一些漏洞，导致手动测试的时候bug的花样繁多。我也在这段修改代码的长时间斗争中感受到了数学基础和算法设计的重要性，以后还得多多加强这方面的训练。",
      "实现完三个应用之后，还需要给排班表新增一个从文件读入初始化数据的功能，这不仅需要会读文件的操作，还要学会正则表达式的写法。于是我又继续上网找代码示例自学（不得不说自学能力真的太重要了！），参照着代码示例写出员工信息、排班信息和排班时间的正则表达式后，运用",
      "Pattern和Matcher，以正则表达式为模板，在文件输入里面进行匹配，获取需要的信息。一旦获取到信息，后续的初始化就很容易了。",
      "好不容易完成所有的功能，又要面临新的变换——排班管理系统要允许一个员工多时间的排班，课程管理系统不允许任何课程的重叠。但是还好我们是面向ADT的编程，在面对这些变化时是比较容易的，不用大量重复的工作，只需少量的修改。",
      "排班管理系统的变化，只需要新增一个NoBlankMultiIntervalSet类来继承MultiIntervalSetDecorator，再修改DutyIntervalSet，将其变成用NoBlankMultiIntervalSet和NonOverlapMultiIntervalSet装饰的MultiIntervalSet，最后修改DutyRosterApp中利用IntervalSet特性实现的少量代码即可。",
      "课表管理系统的变化更加简单，甚至不用新增类，只需修改CourseIntervalSet即可，将其装饰由OverlapMultiIntervalSet改变为NonOverlapMultiIntervalSet就完成了，几乎不用花时间。",
      "到此，软件构造的三个实验就都圆满结束了。我从一个毫无设计思维、只会一来就实现各种方法的小白，成长为了一个初步具有设计意识与习惯的软件构造初学者。期间，我体会了ADT与OOP的魅力，感受了面向ADT编程带来的良好的可维护性和可复用性，当然也经历了各种困难与崩溃。但是最终回顾整个过程时，收获颇丰，成就感十足，内心还是十分喜悦与欣慰的。",
      "关于Git",
      "在三次实验中，提交成果均用到了git，下面记录一下用到的几个指令：",
      "git init 创建一个本地git仓库",
      "git clone xxxx 克隆一个仓库中的代码",
      "git remote add origin xxxx 将本地仓库与远程仓库关联",
      "git remote -v 查看远程仓库相关信息",
      "git add (filename) 将工作区内容交到暂存区",
      "git commit -m \"xxxx\" 将暂存区内容提交到本地仓库",
      "git status 查看仓库状态",
      "git push -u origin master 将本地仓库内容提交到远程仓库上",
      "git checkout -b change 创建新的分支change",
      "git checkout master 切换回master分支",
      "关于在线build",
      "我使用的是GitHub上的在线build，在Actions目录下选择Java with Maven:",
      "选择后会自动生成maven.yml文件，将其中版本修改为指定版本（我用的jdk8)再提交即可：",
      "build的结果如下：",
      "注意在build之前要先提交一个pom.xml文件，否则可能会失败，文件内容如下（其中artifactId需根据每个仓库的仓库名进行修改）："
    ],
    "sentences": [
      "Lab1",
      "现在做完三个实验再回头看Lab1",
      "发现真是基本没干什么",
      "只是简单地熟悉了一下Java编程",
      "P1：Magic Squares",
      "我遇到的问题主要是要实现从文本中读入数据并进行合法性判断的功能",
      "通过上网查阅资料",
      "最终学会了读操作",
      "需要用到FileReader和BufferedReader",
      "这是第一次的上网自学",
      "当时还觉得挺了不起的",
      "后来发现在编程过程中上网自学一些Java中的有关知识简直就是家常便饭",
      "后续的数据操作此处不再描述",
      "我当时的代码风格还是C的风格",
      "比如使用大量一维数组、二维数组进行遍历查找",
      "但在后面的实验中有逐渐改进",
      "慢慢地习惯了使用List、使用迭代器等等",
      "P2：Turtle Graphics",
      "这个任务是我第一次接触到的填空式的程序设计",
      "形式很新颖",
      "趣味性较强",
      "任务要求主要就是参照给出的spec完成几个方法的实现",
      "使得已有测试用例能通过（这也是在此门课程中首次接触到Junit测试）",
      "每个待实现的方法其实都是一些简单的算法",
      "值得一提的是一个求解凸包的问题",
      "我的大致思路是先找到所有点当中的最左下角的点",
      "然后遍历其他的点",
      "找到能使得turtle旋转角度最小的点",
      "移动到该点上",
      "再用相同方法继续查找下一个点",
      "以此类推",
      "直到回到一开始选定的最左下角的点",
      "说明已经找到了所有点当中在最外圈的点",
      "也就得到了凸包",
      "当我把一个到处是空白的框架逐渐丰满起来",
      "测试用例也一个个通过的时候",
      "还是很欣慰很有成就感的",
      "P3：Social Network",
      "这个任务要求设计实现一个FriendshipGraph类来表示现实生活中的社交关系图",
      "还要设计一个Person类来表示人",
      "最后还要自己编写测试用例来对FriendshipGraph中的方法进行测试",
      "当时觉得做了好多的工作，现在回头看只想一笑而过",
      "在这个任务的完成过程中",
      "我对ADT以及TDD有了一个最最基本的了解（虽然这时候还不知道这些名词）",
      "初次感受了一个比较完整的简易的程序设计流程",
      "至于完整的设计流程",
      "在Lab2和Lab3中逐渐揭开了神秘的面纱",
      "Lab2",
      "从Lab2开始",
      "总算是接触到这门课程的核心了——ADT和OOP",
      "实验难度也有了明显提升",
      "P1：Poetic Walks",
      "其实P1可以被分成两个部分",
      "第一个部分是设计一套ADT",
      "第二个部分是利用这个设计好的ADT来完成一个应用",
      "也就是poetic walks",
      "这个任务和Lab1的P2一样",
      "也是填空",
      "不过这次填的东西就多了",
      "查看已经给出的Graph类",
      "里面声明了一些方法",
      "通过对每个方法的spec进行阅读",
      "确定首先要做的就是划分等价类、写测试策略并设计测试用例",
      "这其实就是TDD的一个体现",
      "以前的编程中我都是直接完成实现",
      "在这里按照要求应该先完成测试用例",
      "这样能使方法在实现之后能立即得到测试",
      "确保其正确性及健壮性",
      "而且在设计测试用例的过程中",
      "我们也能提前考虑各种特殊情况",
      "在完成实现的时候加以注意",
      "完成了测试用例，接下来就该实现Graph了",
      "任务中要求了两种实现方式ConcreteEdgesGraph和ConcreteVerticesGraph",
      "这就是对OOP中继承关系的体现了",
      "两个类都是对抽象接口Graph的实现",
      "只是两者的内部逻辑不一样",
      "但对外表现出来的都是一样的",
      "都能提供Graph中的方法",
      "两者的测试用例也是一样的",
      "都继承自Graph的测试用例",
      "因为实现了相同的方法",
      "在实现过程中",
      "还涉及到了mutability/immutability说明、AF、RI、safety from rep exposure以及每个方法的spec",
      "这些内容部分已经给出",
      "但绝大部分仍需要自行添加完善",
      "这些说明能使代码具有更加清晰的逻辑",
      "既能帮助别人读懂自己的代码",
      "又能方便日后查看代码时快速明白当初的想法",
      "还能提醒自己时刻注意所写程序的正确性、安全性",
      "保证不会在以后被客户端恶意操作",
      "同时也可以清楚展示给客户端各个方法能实现什么功能",
      "以及该怎么输入",
      "接下来就进入了P1的第二个部分",
      "应用ADT实现一个poetic walks的功能",
      "还是一样的",
      "先阅读spec了解清楚各个方法要实现的功能",
      "设计相关的测试用例",
      "然后再实现各方法",
      "完善mutability/immutability说明、AF、RI、safety from rep exposure以及每个方法的spec",
      "在实现各个方法的时候",
      "由于已经设计好了ADT",
      "所以能直接调用其中的方法",
      "省去了很多工作",
      "P2：Reimplement Social Network",
      "这个任务其实和P1的第二部分是一样的",
      "就是用已设计的ADT来完成一个应用的实现",
      "而这个实现正是在Lab1中完成过的社交关系图",
      "有了Graph这个强有力的ADT",
      "很快就能实现FriendshipGraph这个类",
      "同样",
      "mutability说明、AF、RI、safety from rep exposure以及每个方法的spec也是不可省略的",
      "虽然这里只需要把Lab1的测试用例直接拿来用就行",
      "但为了按照更标准的模板来",
      "我还是划分等价类、写测试策略并设计测试用例",
      "使得测试更加充分",
      "到此，我在Lab2中初次体验了",
      "面向ADT的编程",
      "不同于以往的直接面向应用场景的编程",
      "面向ADT的编程是一种具有更长远眼光的做法",
      "能在以后更加方便的实现更多具有相似性的应用；面向应用场景的编程虽然在短期看来很方便",
      "但是可扩展性差",
      "在遇到相似情景的时候",
      "只能做大量重复工作",
      "将相似的功能进行反复开发",
      "效率较低",
      "Lab3",
      "到了Lab3",
      "就是整个三次实验的最高潮了",
      "除了一份实验手册上的思路介绍",
      "所有的东西都要自己设计与实现",
      "是真正的从零开始",
      "在Lab3里",
      "要求实现三个应用——排班管理系统、操作系统进程调度管理系统和课表管理系统",
      "对这三个应用进行分析",
      "能发现它们均涉及到具有不同特征的“时间段集合”这种对象",
      "为了提高软件的可复用性和可维护性",
      "可以设计构造一套ADT",
      "一开始我还比较迷茫",
      "就参照着Lab2中设计Graph的那一套流程来进行",
      "首先是设计IntervalSet",
      "在实验手册的提示下",
      "我确定了IntervalSet这个抽象接口中的方法",
      "并完成了每个方法的spec",
      "然后划分等价类、写测试策略并设计测试用例",
      "接下来对IntervalSet这个接口进行实现",
      "不同于Lab2的是",
      "这里只用完成一个实现",
      "即CommonIntervalSet",
      "mutability说明、AF、RI和safety from rep exposure也是需要完成的",
      "这样做下来，我也渐渐明白了设计流程",
      "在IntervalSet的spec里面",
      "提到里面的时间段的“标签”是不能重复的",
      "这在排班管理系统里适用",
      "但在操作系统进程调度管理系统和课表管理系统里就不适用了",
      "于是",
      "我们还要设计实现另一种“时间段集合”MultiIntervalSet",
      "它允许不同时间段的标签“重复”",
      "在实验里，我选择将其直接实现为具体的类，而没有设计相关的接口",
      "和IntervalSet一样",
      "MultiIntervalSet各个方法的设计与spec撰写、测试策略、测试用例、方法的具体实现、mutability说明、AF、RI和safety from rep exposure都得按顺序逐一实现",
      "接下来就要对局部共性进行设计与实现了",
      "这里将用到设计模式的相关知识",
      "我最终选择的是装饰器模式",
      "对于三个维度的特性——是否允许空白、是否允许重叠及是否需要周期性重复",
      "将它们分别看做一层层装饰",
      "逐一地加到原本的对象上",
      "由于排班管理系统会基于IntervalSet来实现",
      "而它要求不允许空白和不允许重叠的特性",
      "我就为之设计了两个用来装饰的类NoBlankIntervalSet和NonOverlapIntervalSet",
      "它们都继承同一个类IntervalSetDecorator",
      "而这个类是对接口IntervalSet的一个实现",
      "然后再将NoBlankIntervalSet和NonOverlapIntervalSet逐层装饰到IntervalSet上",
      "就得到了用于排班管理系统的DutyIntervalSet",
      "需要注意的是",
      "NoBlankIntervalSet中添加了原IntervalSet中没有的方法checkNoBlank",
      "为了能调用这个方法",
      "在装饰的时候需要把它放在最外面的一层",
      "并将对象声明为NoBlankIntervalSet而非IntervalSet",
      "这样看来似乎有些打破装饰器模式",
      "但我在查阅资料时发现这被称为半透明的装饰器模式",
      "介于装饰器模式和适配器模式之间",
      "允许对接口进行改变以增强功能",
      "类似的思路",
      "继续为基于MultiIntervalSet的操作系统进程调度管理系统和课表管理系统设计MultiIntervalSetDecorator类",
      "注意它并不是实现MultiIntervalSet",
      "因为MultiIntervalSet已经是具体的类",
      "而非抽象接口",
      "这样似乎又违背了装饰器模式，但是其思路是完全一致的",
      "再设计并实现NonOverlapMultiIntervalSet、OverlapMultiIntervalSet和PeriodicMultiIntervalSet",
      "并通过包装得到用于操作系统进程调度管理系统的ProcessIntervalSet和用于课表管理系统的CourseIntervalSet",
      "同NoBlankIntervalSet一样",
      "PeriodicMultiIntervalSet也属于半透明的装饰器模式",
      "设计完三个面向应用的ADT",
      "再追加三个immutable的类Employee、Process和Course",
      "以及自主设计的API",
      "我们的基础框架就整个完成了",
      "运用这一套自主设计的ADT，我们已经能解决不少现实中的问题了",
      "接下来的工作就是用已经开发好的ADT来完成一开始提到的三个应用——DutyRosterApp、ProcessScheduleApp和CourseScheduleApp",
      "在已有的ADT的帮助下",
      "每个应用中要求的功能都比较容易想到解决方案",
      "几个小的问题",
      "例如对日期的计算、随机执行时间的“随机”的实现等",
      "在自学LocalDate和Random后都能很快解决",
      "比较大的问题就是对于各种情况的分类讨论不够全面",
      "总是会出现一些漏洞",
      "导致手动测试的时候bug的花样繁多",
      "我也在这段修改代码的长时间斗争中感受到了数学基础和算法设计的重要性",
      "以后还得多多加强这方面的训练",
      "实现完三个应用之后",
      "还需要给排班表新增一个从文件读入初始化数据的功能",
      "这不仅需要会读文件的操作",
      "还要学会正则表达式的写法",
      "于是我又继续上网找代码示例自学（不得不说自学能力真的太重要了！）",
      "参照着代码示例写出员工信息、排班信息和排班时间的正则表达式后",
      "运用",
      "Pattern和Matcher",
      "以正则表达式为模板",
      "在文件输入里面进行匹配",
      "获取需要的信息",
      "一旦获取到信息，后续的初始化就很容易了",
      "好不容易完成所有的功能",
      "又要面临新的变换——排班管理系统要允许一个员工多时间的排班",
      "课程管理系统不允许任何课程的重叠",
      "但是还好我们是面向ADT的编程",
      "在面对这些变化时是比较容易的",
      "不用大量重复的工作",
      "只需少量的修改",
      "排班管理系统的变化",
      "只需要新增一个NoBlankMultiIntervalSet类来继承MultiIntervalSetDecorator",
      "再修改DutyIntervalSet",
      "将其变成用NoBlankMultiIntervalSet和NonOverlapMultiIntervalSet装饰的MultiIntervalSet",
      "最后修改DutyRosterApp中利用IntervalSet特性实现的少量代码即可",
      "课表管理系统的变化更加简单",
      "甚至不用新增类",
      "只需修改CourseIntervalSet即可",
      "将其装饰由OverlapMultiIntervalSet改变为NonOverlapMultiIntervalSet就完成了",
      "几乎不用花时间",
      "到此，软件构造的三个实验就都圆满结束了",
      "我从一个毫无设计思维、只会一来就实现各种方法的小白",
      "成长为了一个初步具有设计意识与习惯的软件构造初学者",
      "期间",
      "我体会了ADT与OOP的魅力",
      "感受了面向ADT编程带来的良好的可维护性和可复用性",
      "当然也经历了各种困难与崩溃",
      "但是最终回顾整个过程时",
      "收获颇丰",
      "成就感十足",
      "内心还是十分喜悦与欣慰的",
      "关于Git",
      "在三次实验中",
      "提交成果均用到了git",
      "下面记录一下用到的几个指令：git init 创建一个本地git仓库",
      "git clone xxxx 克隆一个仓库中的代码",
      "git remote add origin xxxx 将本地仓库与远程仓库关联",
      "git remote -v 查看远程仓库相关信息",
      "git add (filename) 将工作区内容交到暂存区",
      "git commit -m \"xxxx\" 将暂存区内容提交到本地仓库",
      "git status 查看仓库状态",
      "git push -u origin master 将本地仓库内容提交到远程仓库上",
      "git checkout -b change 创建新的分支change",
      "git checkout master 切换回master分支",
      "关于在线build",
      "我使用的是GitHub上的在线build",
      "在Actions目录下选择Java with Maven:选择后会自动生成maven.yml文件",
      "将其中版本修改为指定版本（我用的jdk8)再提交即可：build的结果如下：注意在build之前要先提交一个pom.xml文件",
      "否则可能会失败",
      "文件内容如下（其中artifactId需根据每个仓库的仓库名进行修改）："
    ],
    "codes": [],
    "date": "2021-07-05",
    "text": "Lab1\n现在做完三个实验再回头看Lab1，发现真是基本没干什么，只是简单地熟悉了一下Java编程。\nP1：Magic Squares\n我遇到的问题主要是要实现从文本中读入数据并进行合法性判断的功能。通过上网查阅资料，最终学会了读操作，需要用到FileReader和BufferedReader。这是第一次的上网自学，当时还觉得挺了不起的，后来发现在编程过程中上网自学一些Java中的有关知识简直就是家常便饭。\n后续的数据操作此处不再描述，我当时的代码风格还是C的风格，比如使用大量一维数组、二维数组进行遍历查找，但在后面的实验中有逐渐改进，慢慢地习惯了使用List、使用迭代器等等。\nP2：Turtle Graphics\n这个任务是我第一次接触到的填空式的程序设计，形式很新颖，趣味性较强。\n任务要求主要就是参照给出的spec完成几个方法的实现，使得已有测试用例能通过（这也是在此门课程中首次接触到Junit测试）。每个待实现的方法其实都是一些简单的算法。值得一提的是一个求解凸包的问题，我的大致思路是先找到所有点当中的最左下角的点，然后遍历其他的点，找到能使得turtle旋转角度最小的点，移动到该点上，再用相同方法继续查找下一个点，以此类推，直到回到一开始选定的最左下角的点，说明已经找到了所有点当中在最外圈的点，也就得到了凸包。\n当我把一个到处是空白的框架逐渐丰满起来，测试用例也一个个通过的时候，还是很欣慰很有成就感的。\nP3：Social Network\n这个任务要求设计实现一个FriendshipGraph类来表示现实生活中的社交关系图，还要设计一个Person类来表示人，最后还要自己编写测试用例来对FriendshipGraph中的方法进行测试。当时觉得做了好多的工作，现在回头看只想一笑而过。\n在这个任务的完成过程中，我对ADT以及TDD有了一个最最基本的了解（虽然这时候还不知道这些名词），初次感受了一个比较完整的简易的程序设计流程。至于完整的设计流程，在Lab2和Lab3中逐渐揭开了神秘的面纱。\nLab2\n从Lab2开始，总算是接触到这门课程的核心了——ADT和OOP，实验难度也有了明显提升。\nP1：Poetic Walks\n其实P1可以被分成两个部分，第一个部分是设计一套ADT，第二个部分是利用这个设计好的ADT来完成一个应用，也就是poetic walks。\n这个任务和Lab1的P2一样，也是填空，不过这次填的东西就多了。查看已经给出的Graph类，里面声明了一些方法，通过对每个方法的spec进行阅读，确定首先要做的就是划分等价类、写测试策略并设计测试用例。这其实就是TDD的一个体现，以前的编程中我都是直接完成实现，在这里按照要求应该先完成测试用例，这样能使方法在实现之后能立即得到测试，确保其正确性及健壮性，而且在设计测试用例的过程中，我们也能提前考虑各种特殊情况，在完成实现的时候加以注意。\n完成了测试用例，接下来就该实现Graph了。任务中要求了两种实现方式ConcreteEdgesGraph和ConcreteVerticesGraph，这就是对OOP中继承关系的体现了。两个类都是对抽象接口Graph的实现，只是两者的内部逻辑不一样，但对外表现出来的都是一样的，都能提供Graph中的方法。两者的测试用例也是一样的，都继承自Graph的测试用例，因为实现了相同的方法。\n在实现过程中，还涉及到了mutability/immutability说明、AF、RI、safety from rep exposure以及每个方法的spec，这些内容部分已经给出，但绝大部分仍需要自行添加完善。这些说明能使代码具有更加清晰的逻辑，既能帮助别人读懂自己的代码，又能方便日后查看代码时快速明白当初的想法，还能提醒自己时刻注意所写程序的正确性、安全性，保证不会在以后被客户端恶意操作，同时也可以清楚展示给客户端各个方法能实现什么功能，以及该怎么输入。\n接下来就进入了P1的第二个部分，应用ADT实现一个poetic walks的功能。还是一样的，先阅读spec了解清楚各个方法要实现的功能，设计相关的测试用例，然后再实现各方法，完善mutability/immutability说明、AF、RI、safety from rep exposure以及每个方法的spec。在实现各个方法的时候，由于已经设计好了ADT，所以能直接调用其中的方法，省去了很多工作。\nP2：Reimplement Social Network\n这个任务其实和P1的第二部分是一样的，就是用已设计的ADT来完成一个应用的实现，而这个实现正是在Lab1中完成过的社交关系图。有了Graph这个强有力的ADT，很快就能实现FriendshipGraph这个类。同样，mutability说明、AF、RI、safety from rep exposure以及每个方法的spec也是不可省略的。虽然这里只需要把Lab1的测试用例直接拿来用就行，但为了按照更标准的模板来，我还是划分等价类、写测试策略并设计测试用例，使得测试更加充分。\n到此，我在Lab2中初次体验了\n面向ADT的编程。不同于以往的直接面向应用场景的编程，面向ADT的编程是一种具有更长远眼光的做法，能在以后更加方便的实现更多具有相似性的应用；面向应用场景的编程虽然在短期看来很方便，但是可扩展性差，在遇到相似情景的时候，只能做大量重复工作，将相似的功能进行反复开发，效率较低。\nLab3\n到了Lab3，就是整个三次实验的最高潮了，除了一份实验手册上的思路介绍，所有的东西都要自己设计与实现，是真正的从零开始。\n在Lab3里，要求实现三个应用——排班管理系统、操作系统进程调度管理系统和课表管理系统。对这三个应用进行分析，能发现它们均涉及到具有不同特征的“时间段集合”这种对象，为了提高软件的可复用性和可维护性，可以设计构造一套ADT。\n一开始我还比较迷茫，就参照着Lab2中设计Graph的那一套流程来进行。首先是设计IntervalSet，在实验手册的提示下，我确定了IntervalSet这个抽象接口中的方法，并完成了每个方法的spec。然后划分等价类、写测试策略并设计测试用例。接下来对IntervalSet这个接口进行实现，不同于Lab2的是，这里只用完成一个实现，即CommonIntervalSet。mutability说明、AF、RI和safety from rep exposure也是需要完成的。这样做下来，我也渐渐明白了设计流程。\n在IntervalSet的spec里面，提到里面的时间段的“标签”是不能重复的，这在排班管理系统里适用，但在操作系统进程调度管理系统和课表管理系统里就不适用了。于是，我们还要设计实现另一种“时间段集合”MultiIntervalSet，它允许不同时间段的标签“重复”。在实验里，我选择将其直接实现为具体的类，而没有设计相关的接口。和IntervalSet一样，MultiIntervalSet各个方法的设计与spec撰写、测试策略、测试用例、方法的具体实现、mutability说明、AF、RI和safety from rep exposure都得按顺序逐一实现。\n接下来就要对局部共性进行设计与实现了，这里将用到设计模式的相关知识，我最终选择的是装饰器模式。对于三个维度的特性——是否允许空白、是否允许重叠及是否需要周期性重复，将它们分别看做一层层装饰，逐一地加到原本的对象上。由于排班管理系统会基于IntervalSet来实现，而它要求不允许空白和不允许重叠的特性，我就为之设计了两个用来装饰的类NoBlankIntervalSet和NonOverlapIntervalSet，它们都继承同一个类IntervalSetDecorator，而这个类是对接口IntervalSet的一个实现。然后再将NoBlankIntervalSet和NonOverlapIntervalSet逐层装饰到IntervalSet上，就得到了用于排班管理系统的DutyIntervalSet。\n需要注意的是，NoBlankIntervalSet中添加了原IntervalSet中没有的方法checkNoBlank，为了能调用这个方法，在装饰的时候需要把它放在最外面的一层，并将对象声明为NoBlankIntervalSet而非IntervalSet。这样看来似乎有些打破装饰器模式，但我在查阅资料时发现这被称为半透明的装饰器模式，介于装饰器模式和适配器模式之间，允许对接口进行改变以增强功能。\n类似的思路，继续为基于MultiIntervalSet的操作系统进程调度管理系统和课表管理系统设计MultiIntervalSetDecorator类，注意它并不是实现MultiIntervalSet，因为MultiIntervalSet已经是具体的类，而非抽象接口。这样似乎又违背了装饰器模式，但是其思路是完全一致的。再设计并实现NonOverlapMultiIntervalSet、OverlapMultiIntervalSet和PeriodicMultiIntervalSet，并通过包装得到用于操作系统进程调度管理系统的ProcessIntervalSet和用于课表管理系统的CourseIntervalSet。同NoBlankIntervalSet一样，PeriodicMultiIntervalSet也属于半透明的装饰器模式。\n设计完三个面向应用的ADT，再追加三个immutable的类Employee、Process和Course，以及自主设计的API，我们的基础框架就整个完成了。运用这一套自主设计的ADT，我们已经能解决不少现实中的问题了。\n接下来的工作就是用已经开发好的ADT来完成一开始提到的三个应用——DutyRosterApp、ProcessScheduleApp和CourseScheduleApp。在已有的ADT的帮助下，每个应用中要求的功能都比较容易想到解决方案。几个小的问题，例如对日期的计算、随机执行时间的“随机”的实现等，在自学LocalDate和Random后都能很快解决。比较大的问题就是对于各种情况的分类讨论不够全面，总是会出现一些漏洞，导致手动测试的时候bug的花样繁多。我也在这段修改代码的长时间斗争中感受到了数学基础和算法设计的重要性，以后还得多多加强这方面的训练。\n实现完三个应用之后，还需要给排班表新增一个从文件读入初始化数据的功能，这不仅需要会读文件的操作，还要学会正则表达式的写法。于是我又继续上网找代码示例自学（不得不说自学能力真的太重要了！），参照着代码示例写出员工信息、排班信息和排班时间的正则表达式后，运用\nPattern和Matcher，以正则表达式为模板，在文件输入里面进行匹配，获取需要的信息。一旦获取到信息，后续的初始化就很容易了。\n好不容易完成所有的功能，又要面临新的变换——排班管理系统要允许一个员工多时间的排班，课程管理系统不允许任何课程的重叠。但是还好我们是面向ADT的编程，在面对这些变化时是比较容易的，不用大量重复的工作，只需少量的修改。\n排班管理系统的变化，只需要新增一个NoBlankMultiIntervalSet类来继承MultiIntervalSetDecorator，再修改DutyIntervalSet，将其变成用NoBlankMultiIntervalSet和NonOverlapMultiIntervalSet装饰的MultiIntervalSet，最后修改DutyRosterApp中利用IntervalSet特性实现的少量代码即可。\n课表管理系统的变化更加简单，甚至不用新增类，只需修改CourseIntervalSet即可，将其装饰由OverlapMultiIntervalSet改变为NonOverlapMultiIntervalSet就完成了，几乎不用花时间。\n到此，软件构造的三个实验就都圆满结束了。我从一个毫无设计思维、只会一来就实现各种方法的小白，成长为了一个初步具有设计意识与习惯的软件构造初学者。期间，我体会了ADT与OOP的魅力，感受了面向ADT编程带来的良好的可维护性和可复用性，当然也经历了各种困难与崩溃。但是最终回顾整个过程时，收获颇丰，成就感十足，内心还是十分喜悦与欣慰的。\n关于Git\n在三次实验中，提交成果均用到了git，下面记录一下用到的几个指令：\ngit init 创建一个本地git仓库\ngit clone xxxx 克隆一个仓库中的代码\ngit remote add origin xxxx 将本地仓库与远程仓库关联\ngit remote -v 查看远程仓库相关信息\ngit add (filename) 将工作区内容交到暂存区\ngit commit -m \"xxxx\" 将暂存区内容提交到本地仓库\ngit status 查看仓库状态\ngit push -u origin master 将本地仓库内容提交到远程仓库上\ngit checkout -b change 创建新的分支change\ngit checkout master 切换回master分支\n关于在线build\n我使用的是GitHub上的在线build，在Actions目录下选择Java with Maven:\n选择后会自动生成maven.yml文件，将其中版本修改为指定版本（我用的jdk8)再提交即可：\nbuild的结果如下：\n注意在build之前要先提交一个pom.xml文件，否则可能会失败，文件内容如下（其中artifactId需根据每个仓库的仓库名进行修改）：\n"
  },
  {
    "head": "Java中的ArrayList和LinkedList",
    "paragraphs": [
      "在Java中，我们经常使用到List这个类。这个类有多种实现，本文将着重分析其中最为常见的两个实现方式ArrayList和LinkedList。",
      "其实从名字就不难猜到，ArrayList是基于数组的实现方式，LinkedList是基于链表的实现方式，但我们最好还是通过查看源代码进行更具体的分析。",
      "首先查看两者的rep和creator部分：",
      "ArrayLIst:",
      "从上面的代码中，我们能看到ArrayList确实采用了基于数组的实现方式，rep中有用于记录List长度的size，还有三种形式的数组：",
      "1）EMPTY_ELEMENTDATA是用于构造空数组的；",
      "2）DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是用于构造空数组的，但它与EMPTY_ELEMENTDATA是有区别的，当之后出现第一个元素加入该数组时，它会扩展为大小为DEFAULT_CAPACITY（默认设置为10）的一个数组，即它在首次增加元素时对数组增加的长度有要求；",
      "3）elementData是真正用来存储List中所有元素的数组，若它等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则会在出现第一个元素加入该数组时，扩展为大小为DEFAULT_CAPACITY（默认设置为10）的一个数组。",
      "接下来再看看ArrayList的creator，发现同样有三种方式：",
      "1）传入一个int型参数initialCapacity，这个参数指定List的初始长度。若参数大于0，则直接将elementData设置为大小为initialCapacity的数组；若参数等于0，则将elementData设置为EMPTY_ELEMENTDATA这个空数组；其余情况下，将会抛出异常；",
      "2）不传入参数，则直接将elementData设置为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，可在之后加入第一个元素时再进行扩展；",
      "3）传入一个Collection，将按照Collection的iterator给定的顺序将元素放入数组，再将数组赋值给elementData（要进行类的检查，若Collection不是ArrayList，会先进行转换），若Collection为空，将elementData设置为EMPTY_ELEMENTDATA这个空数组。",
      "LinkedList:",
      "从上面的代码中，我们能看到LinkedList也确实采用了基于链表的实现方式（而且是双向链表）——rep中有记录List长度的size，还有List中第一个和最后一个结点first和last。值得一提的是，Java中没有指针，但这里的实现原理类似于指针，不过是借助结点Node实现的，所以我们还是将LinkedList看做链表。",
      "LinkedList的creator也比ArrayList简单，有两种：一种不传入参数的，创建空链表；一种传入一个Collection，将按照Collection的iterator给定的顺序将元素创建链表。",
      "然后看一下最基本的增加单个元素的操作：",
      "ArrayList:",
      "发现有两种增加元素的方式：",
      "1）不指定位置，会在请求增加一个长度之后，直接加在List最后；",
      "2）指定位置，先检查位置参数index的合法性，若合法再请求增加一个长度，将插入位置后面的元素依次向后挪动一个位置，最后将要增加的元素插入指定位置。",
      "LinkedList:",
      "可以看见LinkedList直接将元素放入新的结点，并加在List的末尾。",
      "再看一下删减单个元素的操作：",
      "ArrayList:",
      "与增加方法对应，同样是两种删减方法：一种按参数index查找（需要检查参数合法性），一种按元素查找，若能找到，则需要将删除位置后面的元素依次向前挪动一个位置，把原本的最后一个元素置为null，再将List的长度减1。",
      "LinkedList:",
      "按元素查找，若能找到，则需要将删除位置前面和后面的结点（如果都有的话）链接起来，否则只需要修改单个结点的“指针”即可。",
      "到此我们可以得出结论，ArrayList是基于数组的实现方式，LinkedList是基于链表的实现方式。结合源代码分析，我们还能发现在增删元素时，LinkedList性能会更好，因为不会涉及到移动元素，而ArrayList需要大量移动元素的操作。这启示我们在需要频繁修改List中元素的情境下，可以优先考虑LinkedList。"
    ],
    "sentences": [
      "在Java中，我们经常使用到List这个类",
      "这个类有多种实现",
      "本文将着重分析其中最为常见的两个实现方式ArrayList和LinkedList",
      "其实从名字就不难猜到",
      "ArrayList是基于数组的实现方式",
      "LinkedList是基于链表的实现方式",
      "但我们最好还是通过查看源代码进行更具体的分析",
      "首先查看两者的rep和creator部分：ArrayLIst:从上面的代码中",
      "我们能看到ArrayList确实采用了基于数组的实现方式",
      "rep中有用于记录List长度的size",
      "还有三种形式的数组：1）EMPTY_ELEMENTDATA是用于构造空数组的；2）DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是用于构造空数组的",
      "但它与EMPTY_ELEMENTDATA是有区别的",
      "当之后出现第一个元素加入该数组时",
      "它会扩展为大小为DEFAULT_CAPACITY（默认设置为10）的一个数组",
      "即它在首次增加元素时对数组增加的长度有要求；3）elementData是真正用来存储List中所有元素的数组",
      "若它等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA",
      "则会在出现第一个元素加入该数组时",
      "扩展为大小为DEFAULT_CAPACITY（默认设置为10）的一个数组",
      "接下来再看看ArrayList的creator",
      "发现同样有三种方式：1）传入一个int型参数initialCapacity",
      "这个参数指定List的初始长度",
      "若参数大于0",
      "则直接将elementData设置为大小为initialCapacity的数组；若参数等于0",
      "则将elementData设置为EMPTY_ELEMENTDATA这个空数组；其余情况下",
      "将会抛出异常；2）不传入参数",
      "则直接将elementData设置为DEFAULTCAPACITY_EMPTY_ELEMENTDATA",
      "可在之后加入第一个元素时再进行扩展；3）传入一个Collection",
      "将按照Collection的iterator给定的顺序将元素放入数组",
      "再将数组赋值给elementData（要进行类的检查",
      "若Collection不是ArrayList",
      "会先进行转换）",
      "若Collection为空",
      "将elementData设置为EMPTY_ELEMENTDATA这个空数组",
      "LinkedList:从上面的代码中",
      "我们能看到LinkedList也确实采用了基于链表的实现方式（而且是双向链表）——rep中有记录List长度的size",
      "还有List中第一个和最后一个结点first和last",
      "值得一提的是",
      "Java中没有指针",
      "但这里的实现原理类似于指针",
      "不过是借助结点Node实现的",
      "所以我们还是将LinkedList看做链表",
      "LinkedList的creator也比ArrayList简单",
      "有两种：一种不传入参数的",
      "创建空链表；一种传入一个Collection",
      "将按照Collection的iterator给定的顺序将元素创建链表",
      "然后看一下最基本的增加单个元素的操作：ArrayList:发现有两种增加元素的方式：1）不指定位置",
      "会在请求增加一个长度之后",
      "直接加在List最后；2）指定位置",
      "先检查位置参数index的合法性",
      "若合法再请求增加一个长度",
      "将插入位置后面的元素依次向后挪动一个位置",
      "最后将要增加的元素插入指定位置",
      "LinkedList:可以看见LinkedList直接将元素放入新的结点",
      "并加在List的末尾",
      "再看一下删减单个元素的操作：ArrayList:与增加方法对应",
      "同样是两种删减方法：一种按参数index查找（需要检查参数合法性）",
      "一种按元素查找",
      "若能找到",
      "则需要将删除位置后面的元素依次向前挪动一个位置",
      "把原本的最后一个元素置为null",
      "再将List的长度减1",
      "LinkedList:按元素查找",
      "若能找到",
      "则需要将删除位置前面和后面的结点（如果都有的话）链接起来",
      "否则只需要修改单个结点的“指针”即可",
      "到此我们可以得出结论",
      "ArrayList是基于数组的实现方式",
      "LinkedList是基于链表的实现方式",
      "结合源代码分析",
      "我们还能发现在增删元素时",
      "LinkedList性能会更好",
      "因为不会涉及到移动元素",
      "而ArrayList需要大量移动元素的操作",
      "这启示我们在需要频繁修改List中元素的情境下",
      "可以优先考虑LinkedList"
    ],
    "codes": [
      "    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * Default initial capacity.\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * Shared empty array instance used for empty instances.\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    /**\n     * Shared empty array instance used for default sized empty instances. We\n     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n     * first element is added.\n     */\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer. Any\n     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * The size of the ArrayList (the number of elements it contains).\n     *\n     * @serial\n     */\n    private int size;\n\n    /**\n     * Constructs an empty list with the specified initial capacity.\n     *\n     * @param  initialCapacity  the initial capacity of the list\n     * @throws IllegalArgumentException if the specified initial capacity\n     *         is negative\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     * Constructs an empty list with an initial capacity of ten.\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * Constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection's\n     * iterator.\n     *\n     * @param c the collection whose elements are to be placed into this list\n     * @throws NullPointerException if the specified collection is null\n     */\n    public ArrayList(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        if ((size = a.length) != 0) {\n            if (c.getClass() == ArrayList.class) {\n                elementData = a;\n            } else {\n                elementData = Arrays.copyOf(a, size, Object[].class);\n            }\n        } else {\n            // replace with empty array.\n            elementData = EMPTY_ELEMENTDATA;\n        }\n    }",
      "    transient int size = 0;\n\n    /**\n     * Pointer to first node.\n     * Invariant: (first == null && last == null) ||\n     *            (first.prev == null && first.item != null)\n     */\n    transient Node<E> first;\n\n    /**\n     * Pointer to last node.\n     * Invariant: (first == null && last == null) ||\n     *            (last.next == null && last.item != null)\n     */\n    transient Node<E> last;\n\n    /**\n     * Constructs an empty list.\n     */\n    public LinkedList() {\n    }\n\n    /**\n     * Constructs a list containing the elements of the specified\n     * collection, in the order they are returned by the collection's\n     * iterator.\n     *\n     * @param  c the collection whose elements are to be placed into this list\n     * @throws NullPointerException if the specified collection is null\n     */\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n\n    private static class Node<E> {\n        E item;\n        Node<E> next;\n        Node<E> prev;\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }",
      "    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return <tt>true</tt> (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n\n    /**\n     * Inserts the specified element at the specified position in this\n     * list. Shifts the element currently at that position (if any) and\n     * any subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }",
      "    /**\n     * Appends the specified element to the end of this list.\n     *\n     * <p>This method is equivalent to {@link #addLast}.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n\n    /**\n     * Links e as last element.\n     */\n    void linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }",
      "    /**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their\n     * indices).\n     *\n     * @param index the index of the element to be removed\n     * @return the element that was removed from the list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n\n    /**\n     * Removes the first occurrence of the specified element from this list,\n     * if it is present.  If the list does not contain the element, it is\n     * unchanged.  More formally, removes the element with the lowest index\n     * <tt>i</tt> such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n     * (if such an element exists).  Returns <tt>true</tt> if this list\n     * contained the specified element (or equivalently, if this list\n     * changed as a result of the call).\n     *\n     * @param o element to be removed from this list, if present\n     * @return <tt>true</tt> if this list contained the specified element\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    /*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */\n    private void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }",
      "    /**\n     * Removes the first occurrence of the specified element from this list,\n     * if it is present.  If this list does not contain the element, it is\n     * unchanged.  More formally, removes the element with the lowest index\n     * {@code i} such that\n     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n     * (if such an element exists).  Returns {@code true} if this list\n     * contained the specified element (or equivalently, if this list\n     * changed as a result of the call).\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if this list contained the specified element\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Unlinks non-null node x.\n     */\n    E unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;\n        final Node<E> prev = x.prev;\n\n        if (prev == null) {\n            first = next;\n        } else {\n            prev.next = next;\n            x.prev = null;\n        }\n\n        if (next == null) {\n            last = prev;\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }"
    ],
    "date": "2021-06-25",
    "text": "在Java中，我们经常使用到List这个类。这个类有多种实现，本文将着重分析其中最为常见的两个实现方式ArrayList和LinkedList。\n其实从名字就不难猜到，ArrayList是基于数组的实现方式，LinkedList是基于链表的实现方式，但我们最好还是通过查看源代码进行更具体的分析。\n首先查看两者的rep和creator部分：\nArrayLIst:\n从上面的代码中，我们能看到ArrayList确实采用了基于数组的实现方式，rep中有用于记录List长度的size，还有三种形式的数组：\n1）EMPTY_ELEMENTDATA是用于构造空数组的；\n2）DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是用于构造空数组的，但它与EMPTY_ELEMENTDATA是有区别的，当之后出现第一个元素加入该数组时，它会扩展为大小为DEFAULT_CAPACITY（默认设置为10）的一个数组，即它在首次增加元素时对数组增加的长度有要求；\n3）elementData是真正用来存储List中所有元素的数组，若它等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则会在出现第一个元素加入该数组时，扩展为大小为DEFAULT_CAPACITY（默认设置为10）的一个数组。\n接下来再看看ArrayList的creator，发现同样有三种方式：\n1）传入一个int型参数initialCapacity，这个参数指定List的初始长度。若参数大于0，则直接将elementData设置为大小为initialCapacity的数组；若参数等于0，则将elementData设置为EMPTY_ELEMENTDATA这个空数组；其余情况下，将会抛出异常；\n2）不传入参数，则直接将elementData设置为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，可在之后加入第一个元素时再进行扩展；\n3）传入一个Collection，将按照Collection的iterator给定的顺序将元素放入数组，再将数组赋值给elementData（要进行类的检查，若Collection不是ArrayList，会先进行转换），若Collection为空，将elementData设置为EMPTY_ELEMENTDATA这个空数组。\nLinkedList:\n从上面的代码中，我们能看到LinkedList也确实采用了基于链表的实现方式（而且是双向链表）——rep中有记录List长度的size，还有List中第一个和最后一个结点first和last。值得一提的是，Java中没有指针，但这里的实现原理类似于指针，不过是借助结点Node实现的，所以我们还是将LinkedList看做链表。\nLinkedList的creator也比ArrayList简单，有两种：一种不传入参数的，创建空链表；一种传入一个Collection，将按照Collection的iterator给定的顺序将元素创建链表。\n然后看一下最基本的增加单个元素的操作：\nArrayList:\n发现有两种增加元素的方式：\n1）不指定位置，会在请求增加一个长度之后，直接加在List最后；\n2）指定位置，先检查位置参数index的合法性，若合法再请求增加一个长度，将插入位置后面的元素依次向后挪动一个位置，最后将要增加的元素插入指定位置。\nLinkedList:\n可以看见LinkedList直接将元素放入新的结点，并加在List的末尾。\n再看一下删减单个元素的操作：\nArrayList:\n与增加方法对应，同样是两种删减方法：一种按参数index查找（需要检查参数合法性），一种按元素查找，若能找到，则需要将删除位置后面的元素依次向前挪动一个位置，把原本的最后一个元素置为null，再将List的长度减1。\nLinkedList:\n按元素查找，若能找到，则需要将删除位置前面和后面的结点（如果都有的话）链接起来，否则只需要修改单个结点的“指针”即可。\n到此我们可以得出结论，ArrayList是基于数组的实现方式，LinkedList是基于链表的实现方式。结合源代码分析，我们还能发现在增删元素时，LinkedList性能会更好，因为不会涉及到移动元素，而ArrayList需要大量移动元素的操作。这启示我们在需要频繁修改List中元素的情境下，可以优先考虑LinkedList。\n"
  },
  {
    "head": "Arrays.asList后对结果进行remove操作导致UnsupportedOperationException的解决方法",
    "paragraphs": [
      "问题描述：",
      "最近在完成实验的过程中，我想要将一个字符串数组转换为一个List，从而方便后续对其中元素进行检查，删除掉一部分非法元素。简单上网搜索资料以后，我发现了可以使用Arrays.asList的操作，将一个字符串数组转化为List，示例代码如下：",
      "但是当我使用这个方法完成代码，进行JUnit测试的时候却不能通过，查看Failure Trace时在这段代码处发现了UnsupportedOperationException的报错：",
      "原因分析:",
      "我们首先查看一下Arrays.asList的源码（按住\"Ctrl\"键，将鼠标指到\"asList\"上，即可选择查看其源码）：",
      "可以看到该方法返回的是一个ArrayList，继续查看这个ArrayList的源码，发现它并不是java.util.ArrayList的ArrayList，而是java.util.Arrays内部自己所包含的ArrayList。而这个内部类，继承了AbstractList类，没有重写remove方法：",
      "再继续查看一下AbstractList类的源码，我们会发现它的remove方法被直接定义为了“throw new UnsupportedOperationException();”：",
      "到这里就完美破案了，进行Arrays.asList的操作得到的是一个java.util.Arrays内部自己所包含的ArrayList，而它的remove方法继承的是AbstractList类中的remove方法，当我们试图对Arrays.asList的结果进行remove操作时，就会抛出UnsupportedOperationException。",
      "解决方案：",
      "新建一个",
      "java.util.ArrayList的ArrayList："
    ],
    "sentences": [
      "问题描述：最近在完成实验的过程中",
      "我想要将一个字符串数组转换为一个List",
      "从而方便后续对其中元素进行检查",
      "删除掉一部分非法元素",
      "简单上网搜索资料以后",
      "我发现了可以使用Arrays.asList的操作",
      "将一个字符串数组转化为List",
      "示例代码如下：但是当我使用这个方法完成代码",
      "进行JUnit测试的时候却不能通过",
      "查看Failure Trace时在这段代码处发现了UnsupportedOperationException的报错：原因分析:我们首先查看一下Arrays.asList的源码（按住\"Ctrl\"键",
      "将鼠标指到\"asList\"上",
      "即可选择查看其源码）：可以看到该方法返回的是一个ArrayList",
      "继续查看这个ArrayList的源码",
      "发现它并不是java.util.ArrayList的ArrayList",
      "而是java.util.Arrays内部自己所包含的ArrayList",
      "而这个内部类",
      "继承了AbstractList类",
      "没有重写remove方法：再继续查看一下AbstractList类的源码",
      "我们会发现它的remove方法被直接定义为了“throw new UnsupportedOperationException();”：到这里就完美破案了",
      "进行Arrays.asList的操作得到的是一个java.util.Arrays内部自己所包含的ArrayList",
      "而它的remove方法继承的是AbstractList类中的remove方法",
      "当我们试图对Arrays.asList的结果进行remove操作时",
      "就会抛出UnsupportedOperationException",
      "解决方案：新建一个",
      "java.util.ArrayList的ArrayList："
    ],
    "codes": [
      "    String[] s = {\"aa\",\"bb\",\"cc\"};\n    List<String> strlist = Arrays.asList(s);",
      "    /**\n     * Returns a fixed-size list backed by the specified array.  (Changes to\n     * the returned list \"write through\" to the array.)  This method acts\n     * as bridge between array-based and collection-based APIs, in\n     * combination with {@link Collection#toArray}.  The returned list is\n     * serializable and implements {@link RandomAccess}.\n     *\n     * <p>This method also provides a convenient way to create a fixed-size\n     * list initialized to contain several elements:\n     * <pre>\n     *     List&lt;String&gt; stooges = Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\n     * </pre>\n     *\n     * @param <T> the class of the objects in the array\n     * @param a the array by which the list will be backed\n     * @return a list view of the specified array\n     */\n    @SafeVarargs\n    @SuppressWarnings(\"varargs\")\n    public static <T> List<T> asList(T... a) {\n        return new ArrayList<>(a);\n    }",
      "    /**\n     * @serial include\n     */\n    private static class ArrayList<E> extends AbstractList<E>\n        implements RandomAccess, java.io.Serializable\n    {\n        private static final long serialVersionUID = -2764017481108945198L;\n        private final E[] a;\n\n        ArrayList(E[] array) {\n            a = Objects.requireNonNull(array);\n        }\n\n        @Override\n        public int size() {\n            return a.length;\n        }\n\n        @Override\n        public Object[] toArray() {\n            return a.clone();\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T[] toArray(T[] a) {\n            int size = size();\n            if (a.length < size)\n                return Arrays.copyOf(this.a, size,\n                                     (Class<? extends T[]>) a.getClass());\n            System.arraycopy(this.a, 0, a, 0, size);\n            if (a.length > size)\n                a[size] = null;\n            return a;\n        }\n\n        @Override\n        public E get(int index) {\n            return a[index];\n        }\n\n        @Override\n        public E set(int index, E element) {\n            E oldValue = a[index];\n            a[index] = element;\n            return oldValue;\n        }\n\n        @Override\n        public int indexOf(Object o) {\n            E[] a = this.a;\n            if (o == null) {\n                for (int i = 0; i < a.length; i++)\n                    if (a[i] == null)\n                        return i;\n            } else {\n                for (int i = 0; i < a.length; i++)\n                    if (o.equals(a[i]))\n                        return i;\n            }\n            return -1;\n        }\n\n        @Override\n        public boolean contains(Object o) {\n            return indexOf(o) != -1;\n        }\n\n        @Override\n        public Spliterator<E> spliterator() {\n            return Spliterators.spliterator(a, Spliterator.ORDERED);\n        }\n\n        @Override\n        public void forEach(Consumer<? super E> action) {\n            Objects.requireNonNull(action);\n            for (E e : a) {\n                action.accept(e);\n            }\n        }\n\n        @Override\n        public void replaceAll(UnaryOperator<E> operator) {\n            Objects.requireNonNull(operator);\n            E[] a = this.a;\n            for (int i = 0; i < a.length; i++) {\n                a[i] = operator.apply(a[i]);\n            }\n        }\n\n        @Override\n        public void sort(Comparator<? super E> c) {\n            Arrays.sort(a, c);\n        }\n    }",
      "    /**\n     * {@inheritDoc}\n     *\n     * <p>This implementation always throws an\n     * {@code UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException {@inheritDoc}\n     * @throws IndexOutOfBoundsException     {@inheritDoc}\n     */\n    public E remove(int index) {\n        throw new UnsupportedOperationException();\n    }",
      "    List<String> inputword = Arrays.asList(input.split(\" \"));\n    List<String> inputwords = new ArrayList<>();\n    inputwords.addAll(inputword);"
    ],
    "date": "2021-06-17",
    "text": "问题描述：\n最近在完成实验的过程中，我想要将一个字符串数组转换为一个List，从而方便后续对其中元素进行检查，删除掉一部分非法元素。简单上网搜索资料以后，我发现了可以使用Arrays.asList的操作，将一个字符串数组转化为List，示例代码如下：\n但是当我使用这个方法完成代码，进行JUnit测试的时候却不能通过，查看Failure Trace时在这段代码处发现了UnsupportedOperationException的报错：\n原因分析:\n我们首先查看一下Arrays.asList的源码（按住\"Ctrl\"键，将鼠标指到\"asList\"上，即可选择查看其源码）：\n可以看到该方法返回的是一个ArrayList，继续查看这个ArrayList的源码，发现它并不是java.util.ArrayList的ArrayList，而是java.util.Arrays内部自己所包含的ArrayList。而这个内部类，继承了AbstractList类，没有重写remove方法：\n再继续查看一下AbstractList类的源码，我们会发现它的remove方法被直接定义为了“throw new UnsupportedOperationException();”：\n到这里就完美破案了，进行Arrays.asList的操作得到的是一个java.util.Arrays内部自己所包含的ArrayList，而它的remove方法继承的是AbstractList类中的remove方法，当我们试图对Arrays.asList的结果进行remove操作时，就会抛出UnsupportedOperationException。\n解决方案：\n新建一个\njava.util.ArrayList的ArrayList：\n"
  },
  {
    "head": "设计模式之装饰器模式（Decorator）",
    "paragraphs": [
      "在设计继承树的时候，我们会选择将最基础最普遍的方法（共性方法）放入最顶层的接口中去实现，而将各个特殊的方法（个性方法）在底层的具体子类中去实现。",
      "对于一些局部共性（即一些类有，一些类没有的方法），我们可以选择使用装饰器模式。本文接下来将会对装饰器模式进行简单介绍。",
      "装饰器模式",
      "装饰器模式是设计模式中常见的一种，它以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。示意图如下：",
      "在装饰器模式中的角色有：",
      "抽象构件角色(Component)：给出一个抽象接口，以规范将要实现功能扩展的对象。",
      "具体构件角色(ConcreteComponent)：定义一个将要实现功能扩展的类。",
      "装饰角色(Decorator)：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。",
      "具体装饰角色(ConcreteDecorator)：负责给构件对象实现扩展的功能。",
      "如果只有一个具体构件角色，那么可以考虑去掉抽象构件角色，把装饰角色作为一个具体构件角色的子类。示意图如下：",
      "如果只有一个具体装饰角色，那么还可以把装饰角色和具体装饰角色合并成一个类。示意图如下：",
      "透明性要求",
      "装饰器模式对客户端的透明性，要求程序不要声明一个ConcreteComponent类型或者ConcreteDecorator类型的变量，而应当声明一个Component类型的变量。示例代码如下：",
      "如下示例代码是错误的：",
      "半透明的装饰器模式",
      "如果能满足透明性的要求，则是纯粹的装饰器模式，它要求在不改变接口的前提下扩展功能。但是在实际的功能扩展中，往往需要创建新的方法，这就导致了“半透明”的装饰器模式的出现。即允许装饰器模式改变接口以实现功能扩展。这意味着客户端可以声明ConcreteDecorator类型的变量，从而调用在ConcreteDecorator类中才有的方法，示例代码如下：",
      "半透明的装饰器模式是介于装饰器模式和适配器模式之间的。装饰器模式不改变类的接口，通过改写方法来扩展类的功能。适配器模式并不扩展类的功能，但是会改变类的接口，以便和目标接口相符合。半透明的装饰器模式应用更广，也称做半装饰器、半适配器模式。",
      "对比继承关系",
      "再把装饰器模式和继承关系对比分析一下，两者都是要扩展类的功能，但是装饰器模式比继承关系更具灵活性。装饰器模式允许动态地决定增加或是删除扩展的功能，按照需求自由地进行扩展性能的组合；而继承关系是静态的，事先就要全部写好，在扩展性能较多的时候，会遇到“组合爆炸”的尴尬处境。但是在扩展性能较多的情况下，装饰器模式也有一定弊端，就是复杂程度较高，显得较为臃肿冗余。"
    ],
    "sentences": [
      "在设计继承树的时候",
      "我们会选择将最基础最普遍的方法（共性方法）放入最顶层的接口中去实现",
      "而将各个特殊的方法（个性方法）在底层的具体子类中去实现",
      "对于一些局部共性（即一些类有",
      "一些类没有的方法）",
      "我们可以选择使用装饰器模式",
      "本文接下来将会对装饰器模式进行简单介绍",
      "装饰器模式",
      "装饰器模式是设计模式中常见的一种",
      "它以对客户端透明的方式扩展对象的功能",
      "是继承关系的一个替代方案",
      "示意图如下：在装饰器模式中的角色有：抽象构件角色(Component)：给出一个抽象接口",
      "以规范将要实现功能扩展的对象",
      "具体构件角色(ConcreteComponent)：定义一个将要实现功能扩展的类",
      "装饰角色(Decorator)：持有一个构件(Component)对象的实例",
      "并定义一个与抽象构件接口一致的接口",
      "具体装饰角色(ConcreteDecorator)：负责给构件对象实现扩展的功能",
      "如果只有一个具体构件角色",
      "那么可以考虑去掉抽象构件角色",
      "把装饰角色作为一个具体构件角色的子类",
      "示意图如下：如果只有一个具体装饰角色",
      "那么还可以把装饰角色和具体装饰角色合并成一个类",
      "示意图如下：透明性要求",
      "装饰器模式对客户端的透明性",
      "要求程序不要声明一个ConcreteComponent类型或者ConcreteDecorator类型的变量",
      "而应当声明一个Component类型的变量",
      "示例代码如下：如下示例代码是错误的：半透明的装饰器模式",
      "如果能满足透明性的要求",
      "则是纯粹的装饰器模式",
      "它要求在不改变接口的前提下扩展功能",
      "但是在实际的功能扩展中",
      "往往需要创建新的方法",
      "这就导致了“半透明”的装饰器模式的出现",
      "即允许装饰器模式改变接口以实现功能扩展",
      "这意味着客户端可以声明ConcreteDecorator类型的变量",
      "从而调用在ConcreteDecorator类中才有的方法",
      "示例代码如下：半透明的装饰器模式是介于装饰器模式和适配器模式之间的",
      "装饰器模式不改变类的接口，通过改写方法来扩展类的功能",
      "适配器模式并不扩展类的功能",
      "但是会改变类的接口",
      "以便和目标接口相符合",
      "半透明的装饰器模式应用更广，也称做半装饰器、半适配器模式",
      "对比继承关系",
      "再把装饰器模式和继承关系对比分析一下",
      "两者都是要扩展类的功能",
      "但是装饰器模式比继承关系更具灵活性",
      "装饰器模式允许动态地决定增加或是删除扩展的功能",
      "按照需求自由地进行扩展性能的组合；而继承关系是静态的",
      "事先就要全部写好",
      "在扩展性能较多的时候",
      "会遇到“组合爆炸”的尴尬处境",
      "但是在扩展性能较多的情况下",
      "装饰器模式也有一定弊端",
      "就是复杂程度较高",
      "显得较为臃肿冗余"
    ],
    "codes": [
      "public interface Component {\n    \n    public void sampleOperation();\n    \n}\n\npublic class ConcreteComponent implements Component {\n\n    @Override\n    public void sampleOperation() {\n        ...\n    }\n\n}\n\npublic class Decorator implements Component{\n    private Component component;\n    \n    public Decorator(Component component){\n        //delegation\n        this.component = component;\n    }\n\n    @Override\n    public void sampleOperation() {\n        component.sampleOperation();\n    }\n    \n}\n\npublic class ConcreteDecoratorA extends Decorator {\n\n    public ConcreteDecoratorA(Component component) {\n        super(component);\n    }\n    \n    @Override\n    public void sampleOperation() {\n　　　　　super.sampleOperation();\n         //实现功能扩展...\n    }\n}\n\npublic class ConcreteDecoratorB extends Decorator {\n\n    public ConcreteDecoratorB(Component component) {\n        super(component);\n    }\n    \n    @Override\n    public void sampleOperation() {\n　　　　  super.sampleOperation();\n         //实现功能扩展...\n    }\n}",
      "Component componet = new ConcreteComponent();\nComponent concretedecoratorA = new ConcreteDecoratorA(component);",
      "ConcreteComponent componet = new ConcreteComponent();\nConcreteDecoratorA concretedecoratorA = new ConcreteDecoratorA(component);",
      "Component componet = new ConcreteComponent();\nConcreteDecoratorA concretedecoratorA = new ConcreteDecoratorA(component);\nconcretedecoratorA.methodA();"
    ],
    "date": "2021-06-30",
    "text": "在设计继承树的时候，我们会选择将最基础最普遍的方法（共性方法）放入最顶层的接口中去实现，而将各个特殊的方法（个性方法）在底层的具体子类中去实现。\n对于一些局部共性（即一些类有，一些类没有的方法），我们可以选择使用装饰器模式。本文接下来将会对装饰器模式进行简单介绍。\n装饰器模式\n装饰器模式是设计模式中常见的一种，它以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。示意图如下：\n在装饰器模式中的角色有：\n抽象构件角色(Component)：给出一个抽象接口，以规范将要实现功能扩展的对象。\n具体构件角色(ConcreteComponent)：定义一个将要实现功能扩展的类。\n装饰角色(Decorator)：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。\n具体装饰角色(ConcreteDecorator)：负责给构件对象实现扩展的功能。\n如果只有一个具体构件角色，那么可以考虑去掉抽象构件角色，把装饰角色作为一个具体构件角色的子类。示意图如下：\n如果只有一个具体装饰角色，那么还可以把装饰角色和具体装饰角色合并成一个类。示意图如下：\n透明性要求\n装饰器模式对客户端的透明性，要求程序不要声明一个ConcreteComponent类型或者ConcreteDecorator类型的变量，而应当声明一个Component类型的变量。示例代码如下：\n如下示例代码是错误的：\n半透明的装饰器模式\n如果能满足透明性的要求，则是纯粹的装饰器模式，它要求在不改变接口的前提下扩展功能。但是在实际的功能扩展中，往往需要创建新的方法，这就导致了“半透明”的装饰器模式的出现。即允许装饰器模式改变接口以实现功能扩展。这意味着客户端可以声明ConcreteDecorator类型的变量，从而调用在ConcreteDecorator类中才有的方法，示例代码如下：\n半透明的装饰器模式是介于装饰器模式和适配器模式之间的。装饰器模式不改变类的接口，通过改写方法来扩展类的功能。适配器模式并不扩展类的功能，但是会改变类的接口，以便和目标接口相符合。半透明的装饰器模式应用更广，也称做半装饰器、半适配器模式。\n对比继承关系\n再把装饰器模式和继承关系对比分析一下，两者都是要扩展类的功能，但是装饰器模式比继承关系更具灵活性。装饰器模式允许动态地决定增加或是删除扩展的功能，按照需求自由地进行扩展性能的组合；而继承关系是静态的，事先就要全部写好，在扩展性能较多的时候，会遇到“组合爆炸”的尴尬处境。但是在扩展性能较多的情况下，装饰器模式也有一定弊端，就是复杂程度较高，显得较为臃肿冗余。\n"
  },
  {
    "head": "软件构造主要知识点总结",
    "paragraphs": [
      "软件构造基础",
      "软件构造的多维度视图",
      "三个维度（build time--run time;moment--period;code level--component level）和八个视图",
      "软件构造各阶段活动",
      "质量因素",
      "外部质量因素影响用户，内部质量因素影响软件本身和它的开发者，外部质量取决于内部质量。",
      "外部质量因素：正确性、健壮性、可扩展性、可复用性、兼容性、时空性能、可移植性、易用性、功能性、及时性、可验证性、完整性、可修复性、经济性等",
      "内部质量因素：可读性、可理解性、简洁性、大小等",
      "各质量因素往往不能同时满足，需要折中，但正确性永远不能与其他质量因素折中。",
      "SCM与VCS",
      "软件配置管理(SCM)追踪和控制软件的变化，软件中发生变化的基本单元，如文件，被称为软件配置项(SCI)。当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。",
      "版本控制系统(VCS)有三种：本地版本控制系统（存储在本地）、集中式版本控制系统（存储在服务器）、分布式版本控制系统（同时存储在本地和服务器）。",
      "Git",
      "四个区域及基本指令：",
      "分支的创建与合并：",
      "ADT与OOP",
      "数据类型",
      "基本数据类型：如int、long、boolean、double、char等",
      "对象数据类型：如String、BigInteger等",
      "基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。",
      "类型检查",
      "静态类型检查：在编译阶段进行类型检查，避免将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误等。",
      "动态类型检查：在运行阶段才会进行类型检查，例如非法的参数值、非法的返回值、越界、空指针等。",
      "静态类型检查是关于数据类型的检查，而动态类型检查是关于值的检查。",
      "Mutability/Immutability",
      "不变对象：一旦被创建，始终指向同一个值/引用，会产生大量拷贝（需要垃圾回收）",
      "可变对象：拥有方法可以修改自己的值/引用，效率更高但不够安全（但可通过防御式拷贝解决）",
      "关于final",
      "final类无法派生子类",
      "final变量无法改变值/引用",
      "final方无法被子类override",
      "Snapshot diagram",
      "基本类型:",
      "对象类型:",
      "mutable对象，单线椭圆:",
      "immutable对象，双线椭圆:",
      "可变的引用，单线箭头；不可变的引用，双线箭头：",
      "specification",
      "规约(spec)是程序与客户端达成的一致，给程序员和用户双方都确定了责任，调用时双方都要遵守。规约能",
      "隔离“变化”，无需通知客户端；提高代码效率；解耦，客户端不需了解具体实现等。",
      "前置条件(precondition)：对客户端的约束，在使用方法时必须满足的条件,使用@param annotation说明。",
      "后置条件(postcondition)：对开发者的约束，方法结束时必须满足的条件，使用@return annotation说明返回值的要求，使用@throws annotation说明出现异常时的处理。",
      "更强的spec意味着更放松的前置条件和更严格的后置条件。可以用更强的spec去替换弱的spec。越强的spec，意味着implementor的自由度越小、责任越重，而client的责任越轻。",
      "ADT的四种操作类型",
      "Creators构造器：用于创建一个新的对象。",
      "Producers生产器：用于使用一个已存在的对象产生一个新的对象。",
      "Observers观察器：不对数据做任何改动，查看一个已存在的对象的各个值。",
      "Mutators变值器：用于改变对象的属性。",
      "测试creators, producers, and mutators：调用observers来观察这些 operations的结果是否满足spec。",
      "测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。",
      "风险：如果被依赖的其他方法有错误，可能导致被测试方法的测试结果失效。",
      "ADT各特性",
      "表示独立性(Representation Independence)：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。",
      "不变量(Invariants)：与程序运行无关，在任何时候都应该满足的一些条件，例如immutability。",
      "表示空间",
      "和抽象空间",
      "：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。",
      "表示不变性(RI)：某个具体的“表示”是否是“合法的”;也可看作所有表示值的一个子集，包含了所有合法的表示值;也可看作一个条件，描述了什么是“合法”的表示值。",
      "抽象函数(AF)：表示空间R和抽象空间A之间映射关系的函数，即如何去解释R中的每一个值为A中的每一个值。",
      "表示泄漏的安全声明(safety from rep exposure)：给出代码并未对外泄露其内部表示的理由。",
      "接口、抽象类、具体类",
      "接口与类用于定义和实现ADT，接口确定ADT的规约，类对ADT进行具体实现。接口之间可以继承和扩展；一个类可以实现多个接口，从而具备多个接口中的方法；一个接口可以有多种实现类；接口中不应提供构造函数（不可被实例化），但允许静态方法和default方法实现；类中必须实现所继承接口的所有方法，允许添加新的方法。抽象类介于接口和具体类之间，比接口具体，比具体类抽象。",
      "继承与Override",
      "子类可以继承父类的成员变量和方法。",
      "严格继承：子类只能添加新方法，无法重写父类中的方法，如父类中的方法使用了final关键字限定。",
      "重写(override)：子类的方法覆盖了父类的方法。重写的方法应该与父类方法有相同的方法名和参数，只有这样编译器才会判定为重写的方法。使用@Override annotation强制检查是否重写了父类中的方法。",
      "多态与Overload",
      "三种多态：特殊多态、参数化多态、子类型多态",
      "特殊多态与重载",
      "重载(overload)即多个方法具有同样的名字，但有不同的参数列表或返回值类型。参数列表必须不同，返回值类型、可见性、异常可相同也可不同。重载不仅发生在类内，也可发生在父类与子类之间。",
      "注意：override是在运行阶段决定的，而overload是在编译阶段决定的。",
      "参数化多态与泛型编程",
      "使用泛型参数代替具体的类型。运行时泛型消失，用具体类型代替。通配符\"?\"只在使用泛型的时候出现，不能在定义中出现。",
      "子类型多态",
      "“B是A的子类型”意味着每一个B都是A，从规约的角度说是“每个B都满足A的规约”。使用instanceof可以检查一个对象在运行时的实际类型。",
      "等价性",
      "引用等价性：使用==进行判断，是否等价取决于指向的地址是否相同。基本数据类型必须使用这种办法判断等价性。",
      "对象等价性：使用equals()进行判断。对于对象类型，使用这种办法来判断等价性，如果只用==则是在判断两个对象的ID(内存里的同一空间)是否相等。",
      "equals()与hashCode()",
      "不可变对象的equals()与hashCode()方法继承Object中的方法。在Object中，equals()的实现为",
      "，而hashCode()的实现为返回内存地址。这往往不是程序员想要的，所以这两个方法需要重写。注意重写的时候不要写成重载，参数类型仍然应该是Object。",
      "可变对象的等价性",
      "观察等价性：指在不改变状态的情况下，两个mutable对象是否看起来一致。",
      "行为等价性：指调用对象的任何方法都展示出一致的结果。",
      "对可变类型来说，人们往往倾向于实现严格的观察等价性，但在有些时候，观察等价性可能导致bug，甚至可能破坏RI。例如：如果某个mutable的对象包含在Set集合类中，当其发生改变后，集合类的行为不确定。",
      "可变类型等价设计实现行为等价性即可，无需重写equals()和hashCode()（与不可变类型要求相反），如果要判断两个可变对象是否看起来一致，最好定义一个新方法。",
      "面向可复用性和可维护性的软件构造",
      "面向复用编程(programming for reuse)：开发可以复用的软件",
      "基于复用编程(programming with reuse)：复用已有的软件开发",
      "源代码层面：方法和语句",
      "模块层面：类和接口",
      "库层面：API",
      "架构层面：框架",
      "LSP",
      "子类型多态：客户端可用统一的方式处理不同类型的对象。",
      "Liskov替换原则内容：",
      "协变：",
      "逆变：",
      "泛型类型是不支持协变的，如ArrayList<String> 是List<String>的子类型，但List<String>不是List<Object>的子类型。这是因为发生了类型擦除，运行时就不存在泛型了，所有的泛型都被替换为具体的类型。",
      "但是在实际使用的过程中是存在能够处理不同的类型的泛型的需求的，如定义一个方法参数是List<E>类型的，但是要适应不同的类型的E，于是可使用通配符\"?\"来解决这个需求。",
      "委派/委托(delegation)：一个对象请求另一个对象的功能。",
      "如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，也就是说一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。",
      "委托发生在object层面，而继承发生在class层面。",
      "CRP",
      "利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。组合就是多个不同方面的delegation的结合。",
      "SOLID设计原则",
      "单一责任原则(SRP)：不应该有多于1个原因让你的ADT发生变化，否则就应拆分开。",
      "开放-封闭原则(OCP)：对扩展性的开放，对修改的封闭。",
      "Liskov替换原则(LSP)：子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异。",
      "接口分割原则(ISP)：不能强迫客户端依赖于它们不需要的接口——只提供必需的接口。客户端不应依赖于它们不需要的方法，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的端口。",
      "依赖转置原则(DIP) ：具体模块应依赖于抽象模块，但抽象模块不应依赖于具体模块。换句话说：委托的时候要通过接口建立联系，而非具体子类。",
      "设计模式",
      "创建型模式（工厂方法模式）、结构型模式（适配器模式、装饰器模式）、行为类模式（策略模式、模板模式、迭代器模式、参观者模式）",
      "共性样式1：只使用继承",
      "例子：",
      "共性样式2：继承+委派",
      "例子：",
      "面向健壮性与正确性的软件构造",
      "健壮性与正确性",
      "健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常。",
      "正确性：程序按照spec加以执行的能力，是最重要的质量指标。",
      "Error/Runtime异常、其他异常",
      "Error：与代码无关，程序员通常无能为力，一旦发生，想办法让程序优雅的结束。也可以通过对外部环境的配置解决问题，如用户输入错误、设备错误、物理限制等。",
      "Exception：一定是程序导致的问题，可以捕获、可以处理。",
      "由于程序员对Error通常无法预料无法解决，因此重点关注可被解决的Exception",
      "Checked异常、Unchecked异常",
      "黑盒测试",
      "黑盒测试用于检查程序是否符合规约，不关心内部实现细节。理想情况是用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误。",
      "等价类划分",
      "针对每个输入数据需要满足的约束条件划分等价类，从等价类中导出测试用例。",
      "边界值分析方法",
      "大量的错误发生在输入域的“边界”而非中央，边界值分析方法是对等价类划分方法的补充。故可在等价类划分时，将边界作为等价类之一加入考虑。",
      "等价类覆盖的方式",
      "笛卡尔积：全覆盖，多个划分维度上的多个取值，要组合起来，每个组合都要有一个用例。测试完备，但用例数量多，测试代价高。",
      "覆盖每个取值：每个维度的每个取值至少被1个测试用例覆盖一次即可，测试用例少，代价低，但测试覆盖度未必高。",
      "白盒测试",
      "白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例。通常由开发人员完成，一般较早执行。",
      "独立/基本路径测试：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试用例使每一条基本路径被至少覆盖1次。"
    ],
    "sentences": [
      "软件构造基础",
      "软件构造的多维度视图",
      "三个维度（build time--run time;moment--period;code level--component level）和八个视图",
      "软件构造各阶段活动",
      "质量因素",
      "外部质量因素影响用户",
      "内部质量因素影响软件本身和它的开发者",
      "外部质量取决于内部质量",
      "外部质量因素：正确性、健壮性、可扩展性、可复用性、兼容性、时空性能、可移植性、易用性、功能性、及时性、可验证性、完整性、可修复性、经济性等",
      "内部质量因素：可读性、可理解性、简洁性、大小等",
      "各质量因素往往不能同时满足",
      "需要折中",
      "但正确性永远不能与其他质量因素折中",
      "SCM与VCS",
      "软件配置管理(SCM)追踪和控制软件的变化",
      "软件中发生变化的基本单元",
      "如文件",
      "被称为软件配置项(SCI)",
      "当软件在开发过程中达到了一个稳定的状态",
      "如可以对外发布的状态",
      "此时的文件组成了基线(Baseline)",
      "为了存储各配置项随时间变化的信息和基线信息",
      "就有一个数据库来管理这些内容",
      "即配置管理数据库(CMDB)",
      "版本控制系统(VCS)有三种：本地版本控制系统（存储在本地）、集中式版本控制系统（存储在服务器）、分布式版本控制系统（同时存储在本地和服务器）",
      "Git",
      "四个区域及基本指令：分支的创建与合并：ADT与OOP",
      "数据类型",
      "基本数据类型：如int、long、boolean、double、char等",
      "对象数据类型：如String、BigInteger等",
      "基本类型被包装为对象类型",
      "通常只有在定义集合的时候使用",
      "其他情况下尽量避免使用",
      "基本类型和对象类型之间一般可以自动转换",
      "类型检查",
      "静态类型检查：在编译阶段进行类型检查",
      "避免将错误带入到运行阶段",
      "可以提高程序的正确性/健壮性",
      "例如语法错误、类名/函数名错误",
      "参数类型或数目错误、返回值类型错误等",
      "动态类型检查：在运行阶段才会进行类型检查",
      "例如非法的参数值、非法的返回值、越界、空指针等",
      "静态类型检查是关于数据类型的检查",
      "而动态类型检查是关于值的检查",
      "Mutability/Immutability",
      "不变对象：一旦被创建",
      "始终指向同一个值/引用",
      "会产生大量拷贝（需要垃圾回收）",
      "可变对象：拥有方法可以修改自己的值/引用",
      "效率更高但不够安全（但可通过防御式拷贝解决）",
      "关于final",
      "final类无法派生子类",
      "final变量无法改变值/引用",
      "final方无法被子类override",
      "Snapshot diagram",
      "基本类型:对象类型:mutable对象",
      "单线椭圆:immutable对象",
      "双线椭圆:可变的引用",
      "单线箭头；不可变的引用",
      "双线箭头：specification",
      "规约(spec)是程序与客户端达成的一致",
      "给程序员和用户双方都确定了责任",
      "调用时双方都要遵守",
      "规约能",
      "隔离“变化”",
      "无需通知客户端；提高代码效率；解耦",
      "客户端不需了解具体实现等",
      "前置条件(precondition)：对客户端的约束",
      "在使用方法时必须满足的条件,使用@param annotation说明",
      "后置条件(postcondition)：对开发者的约束",
      "方法结束时必须满足的条件",
      "使用@return annotation说明返回值的要求",
      "使用@throws annotation说明出现异常时的处理",
      "更强的spec意味着更放松的前置条件和更严格的后置条件",
      "可以用更强的spec去替换弱的spec",
      "越强的spec",
      "意味着implementor的自由度越小、责任越重",
      "而client的责任越轻",
      "ADT的四种操作类型",
      "Creators构造器：用于创建一个新的对象",
      "Producers生产器：用于使用一个已存在的对象产生一个新的对象",
      "Observers观察器：不对数据做任何改动",
      "查看一个已存在的对象的各个值",
      "Mutators变值器：用于改变对象的属性",
      "测试creators, producers, and mutators：调用observers来观察这些 operations的结果是否满足spec",
      "测试observers：调用creators, producers, and mutators等方法产生或改变对象",
      "来看结果是否正确",
      "风险：如果被依赖的其他方法有错误",
      "可能导致被测试方法的测试结果失效",
      "ADT各特性",
      "表示独立性(Representation Independence)：client使用ADT时无需考虑其内部如何实现",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "不变量(Invariants)：与程序运行无关",
      "在任何时候都应该满足的一些条件",
      "例如immutability",
      "表示空间",
      "和抽象空间",
      "：R空间是ADT的内部表示的空间",
      "A空间是ADT能够表示的存在于实际当中的对象",
      "ADT的开发者关注的是R空间，client关注的是A空间",
      "表示不变性(RI)：某个具体的“表示”是否是“合法的”;也可看作所有表示值的一个子集",
      "包含了所有合法的表示值;也可看作一个条件",
      "描述了什么是“合法”的表示值",
      "抽象函数(AF)：表示空间R和抽象空间A之间映射关系的函数",
      "即如何去解释R中的每一个值为A中的每一个值",
      "表示泄漏的安全声明(safety from rep exposure)：给出代码并未对外泄露其内部表示的理由",
      "接口、抽象类、具体类",
      "接口与类用于定义和实现ADT",
      "接口确定ADT的规约",
      "类对ADT进行具体实现",
      "接口之间可以继承和扩展；一个类可以实现多个接口",
      "从而具备多个接口中的方法；一个接口可以有多种实现类；接口中不应提供构造函数（不可被实例化）",
      "但允许静态方法和default方法实现；类中必须实现所继承接口的所有方法",
      "允许添加新的方法",
      "抽象类介于接口和具体类之间，比接口具体，比具体类抽象",
      "继承与Override",
      "子类可以继承父类的成员变量和方法",
      "严格继承：子类只能添加新方法",
      "无法重写父类中的方法",
      "如父类中的方法使用了final关键字限定",
      "重写(override)：子类的方法覆盖了父类的方法",
      "重写的方法应该与父类方法有相同的方法名和参数",
      "只有这样编译器才会判定为重写的方法",
      "使用@Override annotation强制检查是否重写了父类中的方法",
      "多态与Overload",
      "三种多态：特殊多态、参数化多态、子类型多态",
      "特殊多态与重载",
      "重载(overload)即多个方法具有同样的名字",
      "但有不同的参数列表或返回值类型",
      "参数列表必须不同，返回值类型、可见性、异常可相同也可不同",
      "重载不仅发生在类内，也可发生在父类与子类之间",
      "注意：override是在运行阶段决定的",
      "而overload是在编译阶段决定的",
      "参数化多态与泛型编程",
      "使用泛型参数代替具体的类型",
      "运行时泛型消失，用具体类型代替",
      "通配符\"?\"只在使用泛型的时候出现，不能在定义中出现",
      "子类型多态",
      "“B是A的子类型”意味着每一个B都是A",
      "从规约的角度说是“每个B都满足A的规约”",
      "使用instanceof可以检查一个对象在运行时的实际类型",
      "等价性",
      "引用等价性：使用==进行判断",
      "是否等价取决于指向的地址是否相同",
      "基本数据类型必须使用这种办法判断等价性",
      "对象等价性：使用equals()进行判断",
      "对于对象类型",
      "使用这种办法来判断等价性",
      "如果只用==则是在判断两个对象的ID(内存里的同一空间)是否相等",
      "equals()与hashCode()",
      "不可变对象的equals()与hashCode()方法继承Object中的方法",
      "在Object中，equals()的实现为",
      "，而hashCode()的实现为返回内存地址",
      "这往往不是程序员想要的，所以这两个方法需要重写",
      "注意重写的时候不要写成重载，参数类型仍然应该是Object",
      "可变对象的等价性",
      "观察等价性：指在不改变状态的情况下",
      "两个mutable对象是否看起来一致",
      "行为等价性：指调用对象的任何方法都展示出一致的结果",
      "对可变类型来说",
      "人们往往倾向于实现严格的观察等价性",
      "但在有些时候",
      "观察等价性可能导致bug",
      "甚至可能破坏RI",
      "例如：如果某个mutable的对象包含在Set集合类中",
      "当其发生改变后",
      "集合类的行为不确定",
      "可变类型等价设计实现行为等价性即可",
      "无需重写equals()和hashCode()（与不可变类型要求相反）",
      "如果要判断两个可变对象是否看起来一致",
      "最好定义一个新方法",
      "面向可复用性和可维护性的软件构造",
      "面向复用编程(programming for reuse)：开发可以复用的软件",
      "基于复用编程(programming with reuse)：复用已有的软件开发",
      "源代码层面：方法和语句",
      "模块层面：类和接口",
      "库层面：API",
      "架构层面：框架",
      "LSP",
      "子类型多态：客户端可用统一的方式处理不同类型的对象",
      "Liskov替换原则内容：协变：逆变：泛型类型是不支持协变的",
      "如ArrayList<String> 是List<String>的子类型",
      "但List<String>不是List<Object>的子类型",
      "这是因为发生了类型擦除",
      "运行时就不存在泛型了",
      "所有的泛型都被替换为具体的类型",
      "但是在实际使用的过程中是存在能够处理不同的类型的泛型的需求的",
      "如定义一个方法参数是List<E>类型的",
      "但是要适应不同的类型的E",
      "于是可使用通配符\"?\"来解决这个需求",
      "委派/委托(delegation)：一个对象请求另一个对象的功能",
      "如果子类只需要复用父类中的一小部分方法",
      "可以不需要使用继承",
      "而是通过委派机制来实现",
      "也就是说一个类不需要继承另一个类的全部方法",
      "通过委托机制调用部分方法",
      "从而避免大量无用的方法",
      "委托发生在object层面，而继承发生在class层面",
      "CRP",
      "利用delegation的机制",
      "将功能的具体实现与调用分离",
      "在实现中又通过接口的继承树实现功能的不同实现方法",
      "而在调用类中只需要创建具体的子类型然后调用即可",
      "组合就是多个不同方面的delegation的结合",
      "SOLID设计原则",
      "单一责任原则(SRP)：不应该有多于1个原因让你的ADT发生变化",
      "否则就应拆分开",
      "开放-封闭原则(OCP)：对扩展性的开放，对修改的封闭",
      "Liskov替换原则(LSP)：子类型必须能够替换其基类型",
      "派生类必须能够通过其基类的接口使用",
      "客户端无需了解二者之间的差异",
      "接口分割原则(ISP)：不能强迫客户端依赖于它们不需要的接口——只提供必需的接口",
      "客户端不应依赖于它们不需要的方法",
      "不同的接口向不同的客户端提供服务",
      "客户端只访问自己所需要的端口",
      "依赖转置原则(DIP) ：具体模块应依赖于抽象模块",
      "但抽象模块不应依赖于具体模块",
      "换句话说：委托的时候要通过接口建立联系，而非具体子类",
      "设计模式",
      "创建型模式（工厂方法模式）、结构型模式（适配器模式、装饰器模式）、行为类模式（策略模式、模板模式、迭代器模式、参观者模式）",
      "共性样式1：只使用继承",
      "例子：共性样式2：继承+委派",
      "例子：面向健壮性与正确性的软件构造",
      "健壮性与正确性",
      "健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常",
      "正确性：程序按照spec加以执行的能力，是最重要的质量指标",
      "Error/Runtime异常、其他异常",
      "Error：与代码无关",
      "程序员通常无能为力",
      "一旦发生",
      "想办法让程序优雅的结束",
      "也可以通过对外部环境的配置解决问题",
      "如用户输入错误、设备错误、物理限制等",
      "Exception：一定是程序导致的问题，可以捕获、可以处理",
      "由于程序员对Error通常无法预料无法解决",
      "因此重点关注可被解决的Exception",
      "Checked异常、Unchecked异常",
      "黑盒测试",
      "黑盒测试用于检查程序是否符合规约，不关心内部实现细节",
      "理想情况是用尽可能少的测试用例",
      "尽快运行",
      "并尽可能大的发现程序的错误",
      "等价类划分",
      "针对每个输入数据需要满足的约束条件划分等价类",
      "从等价类中导出测试用例",
      "边界值分析方法",
      "大量的错误发生在输入域的“边界”而非中央",
      "边界值分析方法是对等价类划分方法的补充",
      "故可在等价类划分时，将边界作为等价类之一加入考虑",
      "等价类覆盖的方式",
      "笛卡尔积：全覆盖",
      "多个划分维度上的多个取值",
      "要组合起来",
      "每个组合都要有一个用例",
      "测试完备，但用例数量多，测试代价高",
      "覆盖每个取值：每个维度的每个取值至少被1个测试用例覆盖一次即可",
      "测试用例少",
      "代价低",
      "但测试覆盖度未必高",
      "白盒测试",
      "白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例",
      "通常由开发人员完成，一般较早执行",
      "独立/基本路径测试：对程序所有执行路径进行等价类划分",
      "找出有代表性的最简单的路径(例如循环只需执行1次)",
      "设计测试用例使每一条基本路径被至少覆盖1次"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "软件构造基础\n软件构造的多维度视图\n三个维度（build time--run time;moment--period;code level--component level）和八个视图\n软件构造各阶段活动\n质量因素\n外部质量因素影响用户，内部质量因素影响软件本身和它的开发者，外部质量取决于内部质量。\n外部质量因素：正确性、健壮性、可扩展性、可复用性、兼容性、时空性能、可移植性、易用性、功能性、及时性、可验证性、完整性、可修复性、经济性等\n内部质量因素：可读性、可理解性、简洁性、大小等\n各质量因素往往不能同时满足，需要折中，但正确性永远不能与其他质量因素折中。\nSCM与VCS\n软件配置管理(SCM)追踪和控制软件的变化，软件中发生变化的基本单元，如文件，被称为软件配置项(SCI)。当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。\n版本控制系统(VCS)有三种：本地版本控制系统（存储在本地）、集中式版本控制系统（存储在服务器）、分布式版本控制系统（同时存储在本地和服务器）。\nGit\n四个区域及基本指令：\n分支的创建与合并：\nADT与OOP\n数据类型\n基本数据类型：如int、long、boolean、double、char等\n对象数据类型：如String、BigInteger等\n基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。\n类型检查\n静态类型检查：在编译阶段进行类型检查，避免将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误等。\n动态类型检查：在运行阶段才会进行类型检查，例如非法的参数值、非法的返回值、越界、空指针等。\n静态类型检查是关于数据类型的检查，而动态类型检查是关于值的检查。\nMutability/Immutability\n不变对象：一旦被创建，始终指向同一个值/引用，会产生大量拷贝（需要垃圾回收）\n可变对象：拥有方法可以修改自己的值/引用，效率更高但不够安全（但可通过防御式拷贝解决）\n关于final\nfinal类无法派生子类\nfinal变量无法改变值/引用\nfinal方无法被子类override\nSnapshot diagram\n基本类型:\n对象类型:\nmutable对象，单线椭圆:\nimmutable对象，双线椭圆:\n可变的引用，单线箭头；不可变的引用，双线箭头：\nspecification\n规约(spec)是程序与客户端达成的一致，给程序员和用户双方都确定了责任，调用时双方都要遵守。规约能\n隔离“变化”，无需通知客户端；提高代码效率；解耦，客户端不需了解具体实现等。\n前置条件(precondition)：对客户端的约束，在使用方法时必须满足的条件,使用@param annotation说明。\n后置条件(postcondition)：对开发者的约束，方法结束时必须满足的条件，使用@return annotation说明返回值的要求，使用@throws annotation说明出现异常时的处理。\n更强的spec意味着更放松的前置条件和更严格的后置条件。可以用更强的spec去替换弱的spec。越强的spec，意味着implementor的自由度越小、责任越重，而client的责任越轻。\nADT的四种操作类型\nCreators构造器：用于创建一个新的对象。\nProducers生产器：用于使用一个已存在的对象产生一个新的对象。\nObservers观察器：不对数据做任何改动，查看一个已存在的对象的各个值。\nMutators变值器：用于改变对象的属性。\n测试creators, producers, and mutators：调用observers来观察这些 operations的结果是否满足spec。\n测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。\n风险：如果被依赖的其他方法有错误，可能导致被测试方法的测试结果失效。\nADT各特性\n表示独立性(Representation Independence)：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。\n不变量(Invariants)：与程序运行无关，在任何时候都应该满足的一些条件，例如immutability。\n表示空间\n和抽象空间\n：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。\n表示不变性(RI)：某个具体的“表示”是否是“合法的”;也可看作所有表示值的一个子集，包含了所有合法的表示值;也可看作一个条件，描述了什么是“合法”的表示值。\n抽象函数(AF)：表示空间R和抽象空间A之间映射关系的函数，即如何去解释R中的每一个值为A中的每一个值。\n表示泄漏的安全声明(safety from rep exposure)：给出代码并未对外泄露其内部表示的理由。\n接口、抽象类、具体类\n接口与类用于定义和实现ADT，接口确定ADT的规约，类对ADT进行具体实现。接口之间可以继承和扩展；一个类可以实现多个接口，从而具备多个接口中的方法；一个接口可以有多种实现类；接口中不应提供构造函数（不可被实例化），但允许静态方法和default方法实现；类中必须实现所继承接口的所有方法，允许添加新的方法。抽象类介于接口和具体类之间，比接口具体，比具体类抽象。\n继承与Override\n子类可以继承父类的成员变量和方法。\n严格继承：子类只能添加新方法，无法重写父类中的方法，如父类中的方法使用了final关键字限定。\n重写(override)：子类的方法覆盖了父类的方法。重写的方法应该与父类方法有相同的方法名和参数，只有这样编译器才会判定为重写的方法。使用@Override annotation强制检查是否重写了父类中的方法。\n多态与Overload\n三种多态：特殊多态、参数化多态、子类型多态\n特殊多态与重载\n重载(overload)即多个方法具有同样的名字，但有不同的参数列表或返回值类型。参数列表必须不同，返回值类型、可见性、异常可相同也可不同。重载不仅发生在类内，也可发生在父类与子类之间。\n注意：override是在运行阶段决定的，而overload是在编译阶段决定的。\n参数化多态与泛型编程\n使用泛型参数代替具体的类型。运行时泛型消失，用具体类型代替。通配符\"?\"只在使用泛型的时候出现，不能在定义中出现。\n子类型多态\n“B是A的子类型”意味着每一个B都是A，从规约的角度说是“每个B都满足A的规约”。使用instanceof可以检查一个对象在运行时的实际类型。\n等价性\n引用等价性：使用==进行判断，是否等价取决于指向的地址是否相同。基本数据类型必须使用这种办法判断等价性。\n对象等价性：使用equals()进行判断。对于对象类型，使用这种办法来判断等价性，如果只用==则是在判断两个对象的ID(内存里的同一空间)是否相等。\nequals()与hashCode()\n不可变对象的equals()与hashCode()方法继承Object中的方法。在Object中，equals()的实现为\n，而hashCode()的实现为返回内存地址。这往往不是程序员想要的，所以这两个方法需要重写。注意重写的时候不要写成重载，参数类型仍然应该是Object。\n可变对象的等价性\n观察等价性：指在不改变状态的情况下，两个mutable对象是否看起来一致。\n行为等价性：指调用对象的任何方法都展示出一致的结果。\n对可变类型来说，人们往往倾向于实现严格的观察等价性，但在有些时候，观察等价性可能导致bug，甚至可能破坏RI。例如：如果某个mutable的对象包含在Set集合类中，当其发生改变后，集合类的行为不确定。\n可变类型等价设计实现行为等价性即可，无需重写equals()和hashCode()（与不可变类型要求相反），如果要判断两个可变对象是否看起来一致，最好定义一个新方法。\n面向可复用性和可维护性的软件构造\n面向复用编程(programming for reuse)：开发可以复用的软件\n基于复用编程(programming with reuse)：复用已有的软件开发\n源代码层面：方法和语句\n模块层面：类和接口\n库层面：API\n架构层面：框架\nLSP\n子类型多态：客户端可用统一的方式处理不同类型的对象。\nLiskov替换原则内容：\n协变：\n逆变：\n泛型类型是不支持协变的，如ArrayList<String> 是List<String>的子类型，但List<String>不是List<Object>的子类型。这是因为发生了类型擦除，运行时就不存在泛型了，所有的泛型都被替换为具体的类型。\n但是在实际使用的过程中是存在能够处理不同的类型的泛型的需求的，如定义一个方法参数是List<E>类型的，但是要适应不同的类型的E，于是可使用通配符\"?\"来解决这个需求。\n委派/委托(delegation)：一个对象请求另一个对象的功能。\n如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，也就是说一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。\n委托发生在object层面，而继承发生在class层面。\nCRP\n利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。组合就是多个不同方面的delegation的结合。\nSOLID设计原则\n单一责任原则(SRP)：不应该有多于1个原因让你的ADT发生变化，否则就应拆分开。\n开放-封闭原则(OCP)：对扩展性的开放，对修改的封闭。\nLiskov替换原则(LSP)：子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异。\n接口分割原则(ISP)：不能强迫客户端依赖于它们不需要的接口——只提供必需的接口。客户端不应依赖于它们不需要的方法，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的端口。\n依赖转置原则(DIP) ：具体模块应依赖于抽象模块，但抽象模块不应依赖于具体模块。换句话说：委托的时候要通过接口建立联系，而非具体子类。\n设计模式\n创建型模式（工厂方法模式）、结构型模式（适配器模式、装饰器模式）、行为类模式（策略模式、模板模式、迭代器模式、参观者模式）\n共性样式1：只使用继承\n例子：\n共性样式2：继承+委派\n例子：\n面向健壮性与正确性的软件构造\n健壮性与正确性\n健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常。\n正确性：程序按照spec加以执行的能力，是最重要的质量指标。\nError/Runtime异常、其他异常\nError：与代码无关，程序员通常无能为力，一旦发生，想办法让程序优雅的结束。也可以通过对外部环境的配置解决问题，如用户输入错误、设备错误、物理限制等。\nException：一定是程序导致的问题，可以捕获、可以处理。\n由于程序员对Error通常无法预料无法解决，因此重点关注可被解决的Exception\nChecked异常、Unchecked异常\n黑盒测试\n黑盒测试用于检查程序是否符合规约，不关心内部实现细节。理想情况是用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误。\n等价类划分\n针对每个输入数据需要满足的约束条件划分等价类，从等价类中导出测试用例。\n边界值分析方法\n大量的错误发生在输入域的“边界”而非中央，边界值分析方法是对等价类划分方法的补充。故可在等价类划分时，将边界作为等价类之一加入考虑。\n等价类覆盖的方式\n笛卡尔积：全覆盖，多个划分维度上的多个取值，要组合起来，每个组合都要有一个用例。测试完备，但用例数量多，测试代价高。\n覆盖每个取值：每个维度的每个取值至少被1个测试用例覆盖一次即可，测试用例少，代价低，但测试覆盖度未必高。\n白盒测试\n白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例。通常由开发人员完成，一般较早执行。\n独立/基本路径测试：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试用例使每一条基本路径被至少覆盖1次。\n"
  },
  {
    "head": "HIT软构lab2中GraphPoet的一种实现",
    "paragraphs": [
      "首先是第一个方法GraphPoet的实现",
      "首先将输入的文本提取到字符串text中，再用spilt方法进行处理，spilt仅根据空格切分即可，标点符号不能切割。因为单词后面接上标点符号有助于对上下文的判断，比如Hi, nice to meet you. 如果将标点符号切割掉，就会将Hi这个单词与nice形成前后文，这不是我们所需要的。同时，我们生成诗句时也需要保留原标点符号。",
      "然后是poet实现",
      "我的思路是将input中的词先spilt分词，然后将前后两个词放入循环，若查找到存在桥，就将桥加入输出字符串中"
    ],
    "sentences": [
      "首先是第一个方法GraphPoet的实现",
      "首先将输入的文本提取到字符串text中",
      "再用spilt方法进行处理",
      "spilt仅根据空格切分即可",
      "标点符号不能切割",
      "因为单词后面接上标点符号有助于对上下文的判断",
      "比如Hi, nice to meet you. 如果将标点符号切割掉",
      "就会将Hi这个单词与nice形成前后文",
      "这不是我们所需要的",
      "同时，我们生成诗句时也需要保留原标点符号",
      "然后是poet实现",
      "我的思路是将input中的词先spilt分词",
      "然后将前后两个词放入循环",
      "若查找到存在桥",
      "就将桥加入输出字符串中"
    ],
    "codes": [
      "public GraphPoet(File corpus) throws IOException {\n    \tBufferedReader br = new BufferedReader(new FileReader(corpus));\n    \tString line;\n    \tString front, next;\n    \tint temp;\n    \tString fulltxt = \"\";\n    \twhile((line = br.readLine()) != null) {\n    \t\tfulltxt = fulltxt + line + \" \";//得到全文\n    \t}\n    \tbr.close();\n    \tfulltxt = fulltxt.toLowerCase();//大写转小写   \t\n    \tString[] wordset = fulltxt.split(\" \");//将句子以各种分句符号或空格划分，得到单词集合\n    \tfor(int i = 0; i < wordset.length - 1; i++) {\n    \t\tfront = wordset[i];\n    \t\tnext = wordset[i + 1];\n    \t\tif(!graph.vertices().contains(front) || !graph.targets(front).containsKey(next)) {//若front不在点集中或不含到next的边则添加一条边\n    \t\t\tgraph.set(front, next, 1);\n    \t\t\tcontinue;\n    \t\t}\n    \t\tif(graph.targets(front).containsKey(next)) {//若已有该边则weight++\n    \t\t\ttemp = graph.targets(front).get(next) + 1;\n    \t\t\tgraph.set(front, next, temp);\n    \t\t\tcontinue;\n    \t\t}\n    \t}\n    \tcheckRep();\n        //throw new RuntimeException(\"not implemented\");\n    }\n",
      "public String poem(String input) {\n    \tString[] wordset = input.split(\" \");//把input分词\n    \tString str = wordset[0];\n    \tSet<String> frontset = new HashSet<>();\n    \tSet<String> nextset = new HashSet<>();\n    \tint temp = 0;\n    \tString tempstr;\n    \tfor(int i = 1; i < wordset.length; i++) {\n    \t\ttempstr = \"\";\n    \t\ttemp = 0;\n    \t\tfrontset = graph.targets(wordset[i - 1].toLowerCase()).keySet();//将wordset中的第i-1位的顶点的targets中所有顶点的label赋值给frontset\n    \t\tnextset = graph.sources(wordset[i].toLowerCase()).keySet();//将wordset中的第i位的顶点的sources中所有顶点的label赋值给frontset\n    \t\tfor(String front:frontset ) {    \t//遍历寻找两个词之间是否存在“桥梁”\t\t\n    \t\t\tfor(String next:nextset) {\n    \t\t\t\tif(front == next) {\n    \t\t\t\t\ttemp ++;\n    \t\t\t\t\ttempstr = front;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tif(temp == 1) {//若两词之间有且只有一条长度为1的桥\n    \t\t\tstr = str + \" \" + tempstr + \" \" + wordset[i];\n    \t\t\tcontinue;\n    \t\t}\n    \t\tstr = str + \" \" + wordset[i];\n    \t}\n    \tcheckRep();\n    \treturn str;\n        //throw new RuntimeException(\"not implemented\");\n    }\n"
    ],
    "date": "2021-07-06",
    "text": "首先是第一个方法GraphPoet的实现\n首先将输入的文本提取到字符串text中，再用spilt方法进行处理，spilt仅根据空格切分即可，标点符号不能切割。因为单词后面接上标点符号有助于对上下文的判断，比如Hi, nice to meet you. 如果将标点符号切割掉，就会将Hi这个单词与nice形成前后文，这不是我们所需要的。同时，我们生成诗句时也需要保留原标点符号。\n然后是poet实现\n我的思路是将input中的词先spilt分词，然后将前后两个词放入循环，若查找到存在桥，就将桥加入输出字符串中\n"
  },
  {
    "head": "HIT软件构造MultiIntervalSet中数据结构的设计",
    "paragraphs": [
      "我在MultiIntervalSet中设计了两个子类",
      "一个为Nper(命名没有实际意义），用来存储label以及一个time类的链表，用以存储对一个目标的多次排班或调度",
      "第二个子类为time，用以储存单次调度的起始时间与终止时间",
      "说回MultiIntervalSet",
      "主要的数据结构为<Nper>的链表multilabels，每一个Nper中都会存储一个L label以及对其的调度表timelist。",
      "此种设计的好处就是，当需要取出对某个进程的调度信息（或某门课程的排课信息）时，只需要找到一次相应的Nper就可以调出他的所有时间调度。而对timelist插入时间时会进行排序（time的insert函数），timelist中根据index的大小顺序存储调度发生的时间。当所需调用时会更加的方便且清晰"
    ],
    "sentences": [
      "我在MultiIntervalSet中设计了两个子类",
      "一个为Nper(命名没有实际意义）",
      "用来存储label以及一个time类的链表",
      "用以存储对一个目标的多次排班或调度",
      "第二个子类为time，用以储存单次调度的起始时间与终止时间",
      "说回MultiIntervalSet",
      "主要的数据结构为<Nper>的链表multilabels",
      "每一个Nper中都会存储一个L label以及对其的调度表timelist",
      "此种设计的好处就是",
      "当需要取出对某个进程的调度信息（或某门课程的排课信息）时",
      "只需要找到一次相应的Nper就可以调出他的所有时间调度",
      "而对timelist插入时间时会进行排序（time的insert函数）",
      "timelist中根据index的大小顺序存储调度发生的时间",
      "当所需调用时会更加的方便且清晰"
    ],
    "codes": [
      "class Nper<L>{\n\tprivate L label;\n\tprivate LinkedList<time> timelist = new LinkedList<time>();\n\tpublic Nper(L Nlabel, long Nstart, long Nend) {\n\t\tthis.label = Nlabel;\n\t\ttime Ntime = new time(Nstart, Nend);\n\t\ttimelist.add(Ntime);\n\t}\n}\n",
      "class time{\n\tprivate long start;\n\tprivate long end;\n\tpublic time(long Nstart, long Nend) {\n\t\tthis.start = Nstart;\n\t\tthis.end = Nend;\n\t}\n}\n",
      "protected LinkedList<Nper<L>> multilabels = new LinkedList<Nper<L>>();\n"
    ],
    "date": "2021-07-05",
    "text": "我在MultiIntervalSet中设计了两个子类\n一个为Nper(命名没有实际意义），用来存储label以及一个time类的链表，用以存储对一个目标的多次排班或调度\n第二个子类为time，用以储存单次调度的起始时间与终止时间\n说回MultiIntervalSet\n主要的数据结构为<Nper>的链表multilabels，每一个Nper中都会存储一个L label以及对其的调度表timelist。\n此种设计的好处就是，当需要取出对某个进程的调度信息（或某门课程的排课信息）时，只需要找到一次相应的Nper就可以调出他的所有时间调度。而对timelist插入时间时会进行排序（time的insert函数），timelist中根据index的大小顺序存储调度发生的时间。当所需调用时会更加的方便且清晰\n"
  },
  {
    "head": "HIT软件构造lab3中DutyRosterApp中函数isfull()的实现",
    "paragraphs": [
      "HIT软件构造lab3中DutyRosterApp中函数isfull()的实现",
      "首先该函数的需求是用户可随时检查当前排班是否已满（即所有时间段都已被安排了特定员工值班）、若未满，则展示给用户哪些时间段未安排、未安排的时间段占总时间段的比例。",
      "用户输入的时间一般为xx年xx月xx日，我们需要通过函数",
      "LocalDate.of(int year, int month, int day)来将输入的年月日转化为大小为输入日期到1970年1月1日之间的天数的整形数，通过此函数得到排班开始日期startdate， 排班结束日期enddate",
      "首先创建一个大小为排班日期的boolean数组timelist",
      "然后通过遍历所有有有排班的员工，将有排班的时间段赋值为true",
      "其中worker类为员工，包含员工信息",
      "处理完此数组后再次进行循环来输出空闲时间段设置count计数器来记录空闲时间的数量，flag为判断位",
      "循环中，若当前块为空且flag为0，将此块设置为空闲时间段的起点（加上startdate）继续遍历，碰到第一个非空闲块时将flag设回0，并将空闲时间段结尾段设为j-1+enddate并输出LocalDate.ofEpochDay(sparestart) + “->” + LocalDate.ofEpochDay(spareend)",
      "LocalDate.ofEpochDay()为将天数转回日期",
      "最后输出空白占比count/period（若count为0则不输出）"
    ],
    "sentences": [
      "HIT软件构造lab3中DutyRosterApp中函数isfull()的实现",
      "首先该函数的需求是用户可随时检查当前排班是否已满（即所有时间段都已被安排了特定员工值班）、若未满",
      "则展示给用户哪些时间段未安排、未安排的时间段占总时间段的比例",
      "用户输入的时间一般为xx年xx月xx日，我们需要通过函数",
      "LocalDate.of(int year, int month, int day)来将输入的年月日转化为大小为输入日期到1970年1月1日之间的天数的整形数",
      "通过此函数得到排班开始日期startdate",
      " 排班结束日期enddate",
      "首先创建一个大小为排班日期的boolean数组timelist",
      "然后通过遍历所有有有排班的员工",
      "将有排班的时间段赋值为true",
      "其中worker类为员工，包含员工信息",
      "处理完此数组后再次进行循环来输出空闲时间段设置count计数器来记录空闲时间的数量",
      "flag为判断位",
      "循环中",
      "若当前块为空且flag为0",
      "将此块设置为空闲时间段的起点（加上startdate）继续遍历",
      "碰到第一个非空闲块时将flag设回0",
      "并将空闲时间段结尾段设为j-1+enddate并输出LocalDate.ofEpochDay(sparestart) + “->” + LocalDate.ofEpochDay(spareend)",
      "LocalDate.ofEpochDay()为将天数转回日期",
      "最后输出空白占比count/period（若count为0则不输出）"
    ],
    "codes": [
      "period = enddate - startdate;\nboolean[] timelist = new boolean[(int)period];\n",
      "for(worker p : schedule.labels()) {\n\t\t\tstart = p.getstart();\n\t\t\tend = p.getend();\n\t\t\tfor(long i = start - startdate; i < end - startdate; i++) {\n\t\t\t\ttimelist[(int)i] = true;\n\t\t\t}\n\t\t}\n",
      "for(int j = 0; j < (int)period; j++) {\n\t\t\tif(timelist[j] == false) {\n\t\t\t\tcount++;\n\t\t\t\tif(flag == 0) {\n\t\t\t\t\tsparestart = j + startdate;\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(flag == 1) {\n\t\t\t\t\tspareend = j + startdate -1;\n\t\t\t\t\tSystem.out.println(LocalDate.ofEpochDay(sparestart) + \"->\" + LocalDate.ofEpochDay(spareend));\n\t\t\t\t\tflag = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n"
    ],
    "date": "2021-07-02",
    "text": "HIT软件构造lab3中DutyRosterApp中函数isfull()的实现\n首先该函数的需求是用户可随时检查当前排班是否已满（即所有时间段都已被安排了特定员工值班）、若未满，则展示给用户哪些时间段未安排、未安排的时间段占总时间段的比例。\n用户输入的时间一般为xx年xx月xx日，我们需要通过函数\nLocalDate.of(int year, int month, int day)来将输入的年月日转化为大小为输入日期到1970年1月1日之间的天数的整形数，通过此函数得到排班开始日期startdate， 排班结束日期enddate\n首先创建一个大小为排班日期的boolean数组timelist\n然后通过遍历所有有有排班的员工，将有排班的时间段赋值为true\n其中worker类为员工，包含员工信息\n处理完此数组后再次进行循环来输出空闲时间段设置count计数器来记录空闲时间的数量，flag为判断位\n循环中，若当前块为空且flag为0，将此块设置为空闲时间段的起点（加上startdate）继续遍历，碰到第一个非空闲块时将flag设回0，并将空闲时间段结尾段设为j-1+enddate并输出LocalDate.ofEpochDay(sparestart) + “->” + LocalDate.ofEpochDay(spareend)\nLocalDate.ofEpochDay()为将天数转回日期\n最后输出空白占比count/period（若count为0则不输出）\n"
  },
  {
    "head": "软件构造——关于lab3对于时间的处理",
    "paragraphs": [
      "本人最近完成了lab3的实验。在完成dutyroster类（排班表）时，需要对时间进行恰当的处理。因为面向现实生活时，必须要考虑不同年份、不同月份对计算时间差天数的处理。我在完成这次实验时也是产生了很大的困扰，最终在室友的帮助下，我利用java的localDate类实现了很好的处理。",
      "下面介绍一下localDate类，我们直接用一组代码来理解：",
      "通过上面的代码，可以对localDate有简单的理解。",
      "在lab3中，我通过(endDate.toEpochDay() - startDate.toEpochDay())的表达式，来间接获得了起止天数差。"
    ],
    "sentences": [
      "本人最近完成了lab3的实验",
      "在完成dutyroster类（排班表）时",
      "需要对时间进行恰当的处理",
      "因为面向现实生活时",
      "必须要考虑不同年份、不同月份对计算时间差天数的处理",
      "我在完成这次实验时也是产生了很大的困扰",
      "最终在室友的帮助下",
      "我利用java的localDate类实现了很好的处理",
      "下面介绍一下localDate类",
      "我们直接用一组代码来理解：通过上面的代码",
      "可以对localDate有简单的理解",
      "在lab3中",
      "我通过(endDate.toEpochDay() - startDate.toEpochDay())的表达式",
      "来间接获得了起止天数差"
    ],
    "codes": [
      "        LocalDate localDate = LocalDate.now()；\n        System.out.println(\"localDate=\"+localDate);         //localDate=2021-07-05 ，直接获取当天的信息      \n        System.out.println(\"localDate=\"+localDate.getDayOfWeek().getValue());         //获取星期几\n        System.out.println(\"localDate=\"+localDate.get(ChronoField.ALIGNED_WEEK_OF_MONTH));         //获取当前月的第几周\n        System.out.println(localDate.getDayOfYear());            //获取本年中截止到今天已经过去的天数\n \n        System.out.println(localDate.with(TemporalAdjusters.firstDayOfMonth()));  //得到所在月的第一天\n        System.out.println(localDate.withDayOfMonth(3));  //得到所在月的第三天\n        System.out.println(localDate.with(TemporalAdjusters.lastDayOfMonth()));  //得到所在月的最后一天\n        System.out.println(localDate.plusDays(10));  //得到10天后的日期"
    ],
    "date": "2021-07-05",
    "text": "本人最近完成了lab3的实验。在完成dutyroster类（排班表）时，需要对时间进行恰当的处理。因为面向现实生活时，必须要考虑不同年份、不同月份对计算时间差天数的处理。我在完成这次实验时也是产生了很大的困扰，最终在室友的帮助下，我利用java的localDate类实现了很好的处理。\n下面介绍一下localDate类，我们直接用一组代码来理解：\n通过上面的代码，可以对localDate有简单的理解。\n在lab3中，我通过(endDate.toEpochDay() - startDate.toEpochDay())的表达式，来间接获得了起止天数差。\n"
  },
  {
    "head": "软件构造——关于一个github提交错误原因的解决办法",
    "paragraphs": [
      "笔者在完成lab2时还是周六的晚上，但当第二天修改好实验报告准备提交时，已经是晚上十点了，距离截止时间还有不到两个小时的时候，发现github提交时出现了错误！",
      "当我按照git提交流程一步一步的做到了",
      "git commit -m \"提交信息\"",
      "时，没有出现任何问题，但是当我最后即将",
      "git push xxxx master",
      "时，发现出现了网络问题，无法连接至github，这是一个很常见的问题，只需要重新提交几次就可以提交成功了，但是，我十分手欠地新建了一个文件夹，将原文件夹的数据拷贝过去。并在新文件夹中重新建立git仓库，重新提交。",
      "于是当到了最后一步",
      "git push xxxx master",
      "时，出现了新的问题：git显示无法提交，这显然不是网络的问题，原因是我在原文件夹提交了commit信息，会导致无法再次提交文件，只有在原文件夹将文件成功push上传，才能提交其他文件。",
      "于是，正在我焦头烂额的时候，我的室友给了我指导，他让我找回到原来的文件夹，在原文件夹里重新提交了好几次，最终上传成功。",
      "当然，对这个问题，还有其他的解决方法：需要用到pull命令：",
      "git pull --rebase xxxx master （xxxx为你的仓库名）",
      "该命令会把个人仓库里的所有文件下载到你的新本地仓库中。"
    ],
    "sentences": [
      "笔者在完成lab2时还是周六的晚上",
      "但当第二天修改好实验报告准备提交时",
      "已经是晚上十点了",
      "距离截止时间还有不到两个小时的时候",
      "发现github提交时出现了错误！",
      "当我按照git提交流程一步一步的做到了",
      "git commit -m \"提交信息\"",
      "时，没有出现任何问题，但是当我最后即将",
      "git push xxxx master",
      "时",
      "发现出现了网络问题",
      "无法连接至github",
      "这是一个很常见的问题",
      "只需要重新提交几次就可以提交成功了",
      "但是",
      "我十分手欠地新建了一个文件夹",
      "将原文件夹的数据拷贝过去",
      "并在新文件夹中重新建立git仓库，重新提交",
      "于是当到了最后一步",
      "git push xxxx master",
      "时",
      "出现了新的问题：git显示无法提交",
      "这显然不是网络的问题",
      "原因是我在原文件夹提交了commit信息",
      "会导致无法再次提交文件",
      "只有在原文件夹将文件成功push上传",
      "才能提交其他文件",
      "于是",
      "正在我焦头烂额的时候",
      "我的室友给了我指导",
      "他让我找回到原来的文件夹",
      "在原文件夹里重新提交了好几次",
      "最终上传成功",
      "当然",
      "对这个问题",
      "还有其他的解决方法：需要用到pull命令：git pull --rebase xxxx master （xxxx为你的仓库名）",
      "该命令会把个人仓库里的所有文件下载到你的新本地仓库中"
    ],
    "codes": [],
    "date": "2021-07-02",
    "text": "笔者在完成lab2时还是周六的晚上，但当第二天修改好实验报告准备提交时，已经是晚上十点了，距离截止时间还有不到两个小时的时候，发现github提交时出现了错误！\n当我按照git提交流程一步一步的做到了\ngit commit -m \"提交信息\"\n时，没有出现任何问题，但是当我最后即将\ngit push xxxx master\n时，发现出现了网络问题，无法连接至github，这是一个很常见的问题，只需要重新提交几次就可以提交成功了，但是，我十分手欠地新建了一个文件夹，将原文件夹的数据拷贝过去。并在新文件夹中重新建立git仓库，重新提交。\n于是当到了最后一步\ngit push xxxx master\n时，出现了新的问题：git显示无法提交，这显然不是网络的问题，原因是我在原文件夹提交了commit信息，会导致无法再次提交文件，只有在原文件夹将文件成功push上传，才能提交其他文件。\n于是，正在我焦头烂额的时候，我的室友给了我指导，他让我找回到原来的文件夹，在原文件夹里重新提交了好几次，最终上传成功。\n当然，对这个问题，还有其他的解决方法：需要用到pull命令：\ngit pull --rebase xxxx master （xxxx为你的仓库名）\n该命令会把个人仓库里的所有文件下载到你的新本地仓库中。\n"
  },
  {
    "head": "软件构造——关于java的正则表达式",
    "paragraphs": [
      "笔者在完成lab3时，正则表达式实在是造成了很大的困扰，下面就来简单介绍一下java中的正则表达式。",
      "一个字符串其实就是一个简单的正则表达式，例如",
      "Hello World",
      "正则表达式匹配 \"Hello World\" 字符串。而“.”（点号）也是一个正则表达式，它匹配任何一个字符如：\"0\" 或 \"a\"。",
      "java.util.regex 包主要包括以下三个类：",
      "Pattern 类：",
      "pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。",
      "Matcher 类：",
      "Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。",
      "PatternSyntaxException：",
      "PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。",
      "在 Java 中，“\\\\” 表示：",
      "我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。",
      "在 Java 中，正则表达式中需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个\\\\代表其他语言中的一个\\，这也就是为什么表示一位数字的正则表达式是\\\\d，而表示一个普通的反斜杠是\\\\。其实，类比一下C语言可以很好理解这一部分。",
      "对于正则表达式的语法，网上有很多的参考资料，本文只是对正则表达式的匹配方式进行简单介绍，这里就不多赘述。",
      "下面介绍Matcher类的方法，参考https://www.runoob.com/java/java-regular-expressions.html",
      "索引方法",
      "索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：",
      "方法及说明",
      "public int start()",
      "返回以前匹配的初始索引。",
      "public int start(int group)",
      "返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引",
      "public int end()",
      "返回最后匹配字符之后的偏移量。",
      "public int end(int group)",
      "返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。",
      "查找方法",
      "查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：",
      "方法及说明",
      "public boolean lookingAt()",
      "尝试将从区域开头开始的输入序列与该模式匹配。",
      "public boolean find()",
      "尝试查找与该模式匹配的输入序列的下一个子序列。",
      "public boolean find(int start",
      "重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。",
      "public boolean matches()",
      "尝试将整个区域与模式匹配。",
      "替换方法",
      "替换方法是替换输入字符串里文本的方法：",
      "方法及说明",
      "public Matcher appendReplacement(StringBuffer sb, String replacement)",
      "实现非终端添加和替换步骤。",
      "public StringBuffer appendTail(StringBuffer sb)",
      "实现终端添加和替换步骤。",
      "public String replaceAll(String replacement)",
      "替换模式与给定替换字符串相匹配的输入序列的每个子序列。",
      "public String replaceFirst(String replacement)",
      "替换模式与给定替换字符串匹配的输入序列的第一个子序列。",
      "public static String quoteReplacement(String s)",
      "返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。"
    ],
    "sentences": [
      "笔者在完成lab3时",
      "正则表达式实在是造成了很大的困扰",
      "下面就来简单介绍一下java中的正则表达式",
      "一个字符串其实就是一个简单的正则表达式，例如",
      "Hello World",
      "正则表达式匹配 \"Hello World\" 字符串",
      "而“.”（点号）也是一个正则表达式",
      "它匹配任何一个字符如：\"0\" 或 \"a\"",
      "java.util.regex 包主要包括以下三个类：Pattern 类：pattern 对象是一个正则表达式的编译表示",
      "Pattern 类没有公共构造方法",
      "要创建一个 Pattern 对象",
      "你必须首先调用其公共静态编译方法",
      "它返回一个 Pattern 对象",
      "该方法接受一个正则表达式作为它的第一个参数",
      "Matcher 类：Matcher 对象是对输入字符串进行解释和匹配操作的引擎",
      "与Pattern 类一样，Matcher 也没有公共构造方法",
      "你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象",
      "PatternSyntaxException：PatternSyntaxException 是一个非强制异常类",
      "它表示一个正则表达式模式中的语法错误",
      "在 Java 中",
      "“\\\\” 表示：我要插入一个正则表达式的反斜线",
      "所以其后的字符具有特殊的意义",
      "在 Java 中",
      "正则表达式中需要有两个反斜杠才能被解析为其他语言中的转义作用",
      "也可以简单的理解在 Java 的正则表达式中",
      "两个\\\\代表其他语言中的一个\\",
      "这也就是为什么表示一位数字的正则表达式是\\\\d",
      "而表示一个普通的反斜杠是\\\\",
      "其实，类比一下C语言可以很好理解这一部分",
      "对于正则表达式的语法",
      "网上有很多的参考资料",
      "本文只是对正则表达式的匹配方式进行简单介绍",
      "这里就不多赘述",
      "下面介绍Matcher类的方法",
      "参考https://www.runoob.com/java/java-regular-expressions.html",
      "索引方法",
      "索引方法提供了有用的索引值",
      "精确表明输入字符串中在哪能找到匹配：方法及说明",
      "public int start()",
      "返回以前匹配的初始索引",
      "public int start(int group)",
      "返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引",
      "public int end()",
      "返回最后匹配字符之后的偏移量",
      "public int end(int group)",
      "返回在以前的匹配操作期间",
      "由给定组所捕获子序列的最后字符之后的偏移量",
      "查找方法",
      "查找方法用来检查输入字符串并返回一个布尔值",
      "表示是否找到该模式：方法及说明",
      "public boolean lookingAt()",
      "尝试将从区域开头开始的输入序列与该模式匹配",
      "public boolean find()",
      "尝试查找与该模式匹配的输入序列的下一个子序列",
      "public boolean find(int start",
      "重置此匹配器",
      "然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列",
      "public boolean matches()",
      "尝试将整个区域与模式匹配",
      "替换方法",
      "替换方法是替换输入字符串里文本的方法：方法及说明",
      "public Matcher appendReplacement(StringBuffer sb, String replacement)",
      "实现非终端添加和替换步骤",
      "public StringBuffer appendTail(StringBuffer sb)",
      "实现终端添加和替换步骤",
      "public String replaceAll(String replacement)",
      "替换模式与给定替换字符串相匹配的输入序列的每个子序列",
      "public String replaceFirst(String replacement)",
      "替换模式与给定替换字符串匹配的输入序列的第一个子序列",
      "public static String quoteReplacement(String s)",
      "返回指定字符串的字面替换字符串",
      "这个方法返回一个字符串",
      "就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作"
    ],
    "codes": [],
    "date": "2021-07-03",
    "text": "笔者在完成lab3时，正则表达式实在是造成了很大的困扰，下面就来简单介绍一下java中的正则表达式。\n一个字符串其实就是一个简单的正则表达式，例如\nHello World\n正则表达式匹配 \"Hello World\" 字符串。而“.”（点号）也是一个正则表达式，它匹配任何一个字符如：\"0\" 或 \"a\"。\njava.util.regex 包主要包括以下三个类：\nPattern 类：\npattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。\nMatcher 类：\nMatcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。\nPatternSyntaxException：\nPatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n在 Java 中，“\\\\” 表示：\n我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。\n在 Java 中，正则表达式中需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个\\\\代表其他语言中的一个\\，这也就是为什么表示一位数字的正则表达式是\\\\d，而表示一个普通的反斜杠是\\\\。其实，类比一下C语言可以很好理解这一部分。\n对于正则表达式的语法，网上有很多的参考资料，本文只是对正则表达式的匹配方式进行简单介绍，这里就不多赘述。\n下面介绍Matcher类的方法，参考https://www.runoob.com/java/java-regular-expressions.html\n索引方法\n索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：\n方法及说明\npublic int start()\n返回以前匹配的初始索引。\npublic int start(int group)\n返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引\npublic int end()\n返回最后匹配字符之后的偏移量。\npublic int end(int group)\n返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。\n查找方法\n查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：\n方法及说明\npublic boolean lookingAt()\n尝试将从区域开头开始的输入序列与该模式匹配。\npublic boolean find()\n尝试查找与该模式匹配的输入序列的下一个子序列。\npublic boolean find(int start\n重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。\npublic boolean matches()\n尝试将整个区域与模式匹配。\n替换方法\n替换方法是替换输入字符串里文本的方法：\n方法及说明\npublic Matcher appendReplacement(StringBuffer sb, String replacement)\n实现非终端添加和替换步骤。\npublic StringBuffer appendTail(StringBuffer sb)\n实现终端添加和替换步骤。\npublic String replaceAll(String replacement)\n替换模式与给定替换字符串相匹配的输入序列的每个子序列。\npublic String replaceFirst(String replacement)\n替换模式与给定替换字符串匹配的输入序列的第一个子序列。\npublic static String quoteReplacement(String s)\n返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。\n"
  },
  {
    "head": "软件构造——关于git指令复习的进一步理解",
    "paragraphs": [
      "笔者在前几天简单描述了我在lab2用git提交时出现的一个问题。今天我在复习软件构造课程时，读到了git作为SCM工具的简单应用，看见了这样的一张图：",
      "我们提交实验时最常用的方法就是首先",
      "git add <文件>",
      "然后 git commit -m “提交信息”",
      "最后git push URL 分支",
      "实际上，这在上面的图中就是前三个步骤。而我在lab2中遇到的问题就是重复了第三步，在不同的local repository（本地仓库上）进行git push，从而无法成功提交。当时我的解决方法就是找到了第一次进行提交的本地仓库，随后提交成功。另外一种解决办法就是git pull，上图中的黄颜色的指令就是将远程仓库上的所有文件全部清空并下载到本地工作区。清空了全部内容，下一次的提交也就一定会成功了。"
    ],
    "sentences": [
      "笔者在前几天简单描述了我在lab2用git提交时出现的一个问题",
      "今天我在复习软件构造课程时",
      "读到了git作为SCM工具的简单应用",
      "看见了这样的一张图：我们提交实验时最常用的方法就是首先",
      "git add <文件>",
      "然后 git commit -m “提交信息”",
      "最后git push URL 分支",
      "实际上，这在上面的图中就是前三个步骤",
      "而我在lab2中遇到的问题就是重复了第三步",
      "在不同的local repository（本地仓库上）进行git push",
      "从而无法成功提交",
      "当时我的解决方法就是找到了第一次进行提交的本地仓库",
      "随后提交成功",
      "另外一种解决办法就是git pull",
      "上图中的黄颜色的指令就是将远程仓库上的所有文件全部清空并下载到本地工作区",
      "清空了全部内容，下一次的提交也就一定会成功了"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "笔者在前几天简单描述了我在lab2用git提交时出现的一个问题。今天我在复习软件构造课程时，读到了git作为SCM工具的简单应用，看见了这样的一张图：\n我们提交实验时最常用的方法就是首先\ngit add <文件>\n然后 git commit -m “提交信息”\n最后git push URL 分支\n实际上，这在上面的图中就是前三个步骤。而我在lab2中遇到的问题就是重复了第三步，在不同的local repository（本地仓库上）进行git push，从而无法成功提交。当时我的解决方法就是找到了第一次进行提交的本地仓库，随后提交成功。另外一种解决办法就是git pull，上图中的黄颜色的指令就是将远程仓库上的所有文件全部清空并下载到本地工作区。清空了全部内容，下一次的提交也就一定会成功了。\n"
  },
  {
    "head": "软件构造——在Eclipse中进行JUnit测试",
    "paragraphs": [
      "本人完成了学期的所有实验后，想起来在完成lab1时，对如何进行Junit测试没搞清楚，所以在这里详细记录一下JUnit测试的具体步骤。",
      "首先右键工作项目，并选中最下面的properties；",
      "然后在Java Build Path中选中Class Path，并点击右侧的add liabrary",
      "选择自己想要的JUnit版本，点击Finish",
      "对想要测试的类新建测试用例，右键该类选择new后选择JUnit Test Case",
      "在接下来的页面上要勾选setup点击next，并给自己想要进行测试的方法打勾。",
      "点击Finish，即可看到生成的测试用例，之后就可以自己进行编写改动。"
    ],
    "sentences": [
      "本人完成了学期的所有实验后",
      "想起来在完成lab1时",
      "对如何进行Junit测试没搞清楚",
      "所以在这里详细记录一下JUnit测试的具体步骤",
      "首先右键工作项目",
      "并选中最下面的properties；然后在Java Build Path中选中Class Path",
      "并点击右侧的add liabrary",
      "选择自己想要的JUnit版本，点击Finish",
      "对想要测试的类新建测试用例",
      "右键该类选择new后选择JUnit Test Case",
      "在接下来的页面上要勾选setup点击next",
      "并给自己想要进行测试的方法打勾",
      "点击Finish",
      "即可看到生成的测试用例",
      "之后就可以自己进行编写改动"
    ],
    "codes": [],
    "date": "2021-07-04",
    "text": "本人完成了学期的所有实验后，想起来在完成lab1时，对如何进行Junit测试没搞清楚，所以在这里详细记录一下JUnit测试的具体步骤。\n首先右键工作项目，并选中最下面的properties；\n然后在Java Build Path中选中Class Path，并点击右侧的add liabrary\n选择自己想要的JUnit版本，点击Finish\n对想要测试的类新建测试用例，右键该类选择new后选择JUnit Test Case\n在接下来的页面上要勾选setup点击next，并给自己想要进行测试的方法打勾。\n点击Finish，即可看到生成的测试用例，之后就可以自己进行编写改动。\n"
  },
  {
    "head": "软件构造学习笔记——数据类型与类型检验",
    "paragraphs": [
      "数据类型",
      "基本数据类型:只有值，没有ID (与其他值无法区分)在栈中分配内存代价低 不可变",
      "int,long,boolean,double,char",
      "对象数据类型:既有ID，也有值在堆中分配内存代价昂贵 可变\\不可变",
      "String,BigInteger",
      "对象类型形成层次结构：继承关系（extends）",
      "同样的操作名可用于不同 的数据类型",
      "类型转换",
      "Mutability与Immutability",
      "改变一个变量：将该变 量指向另一个值的存储空间",
      "改变一个变量的值：将 该变量当前指向的值的存储空间中写入一个新的值。",
      "Immutability 不变性",
      "不变性：重要设计原则",
      "不变数据类型：一旦被创建，其值不能改变",
      "如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变",
      "final：final类无法派生子类final变量无法改变值/引用final方法无法被子类重写",
      "不变对象：一旦被创建，始终指向同一个值/引用",
      "可变对象：拥有方法可以修改自己的值/引用",
      "String是不可变的",
      "StringBuilder是可变的",
      "使用 不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，不可变类型更“安全”， 在其他质量指标上表现更好",
      "可变类型最少化拷贝以提高效率，使用可变数据类型，可获得更好的性能",
      "Snapshot",
      "用于描述程序运行时的内部状态，便于程序员之间的交流，刻画各类变量随时间变化，解释设计思路",
      "基本类型的值",
      "对象类型的值",
      "不可变对象：用双线椭圆",
      "不可变的引用：用双线箭头",
      "引用是不可变的，但指向的值却可以是可变的，可变的引用，也可指向不可变的值"
    ],
    "sentences": [
      "数据类型",
      "基本数据类型:只有值",
      "没有ID (与其他值无法区分)在栈中分配内存代价低 不可变",
      "int,long,boolean,double,char",
      "对象数据类型:既有ID",
      "也有值在堆中分配内存代价昂贵 可变\\不可变",
      "String,BigInteger",
      "对象类型形成层次结构：继承关系（extends）",
      "同样的操作名可用于不同 的数据类型",
      "类型转换",
      "Mutability与Immutability",
      "改变一个变量：将该变 量指向另一个值的存储空间",
      "改变一个变量的值：将 该变量当前指向的值的存储空间中写入一个新的值",
      "Immutability 不变性",
      "不变性：重要设计原则",
      "不变数据类型：一旦被创建，其值不能改变",
      "如果是引用类型",
      "也可以是不变的：一旦确定其指向的对象",
      "不能再被改变",
      "final：final类无法派生子类final变量无法改变值/引用final方法无法被子类重写",
      "不变对象：一旦被创建，始终指向同一个值/引用",
      "可变对象：拥有方法可以修改自己的值/引用",
      "String是不可变的",
      "StringBuilder是可变的",
      "使用 不可变类型",
      "对其频繁修改会产生大量的临时拷贝(需要垃圾回收)",
      "不可变类型更“安全”",
      " 在其他质量指标上表现更好",
      "可变类型最少化拷贝以提高效率",
      "使用可变数据类型",
      "可获得更好的性能",
      "Snapshot",
      "用于描述程序运行时的内部状态",
      "便于程序员之间的交流",
      "刻画各类变量随时间变化",
      "解释设计思路",
      "基本类型的值",
      "对象类型的值",
      "不可变对象：用双线椭圆",
      "不可变的引用：用双线箭头",
      "引用是不可变的",
      "但指向的值却可以是可变的",
      "可变的引用",
      "也可指向不可变的值"
    ],
    "codes": [
      "int a = 2; // a = 2",
      "double a = 2; // a = 2.0 (Implicit)",
      "int a = (int) 18.7; // a = 18 double",
      "a = (double)2/3; // a = 0.6666…"
    ],
    "date": "2021-07-06",
    "text": "数据类型\n基本数据类型:只有值，没有ID (与其他值无法区分)在栈中分配内存代价低 不可变\nint,long,boolean,double,char\n对象数据类型:既有ID，也有值在堆中分配内存代价昂贵 可变\\不可变\nString,BigInteger\n对象类型形成层次结构：继承关系（extends）\n同样的操作名可用于不同 的数据类型\n类型转换\nMutability与Immutability\n改变一个变量：将该变 量指向另一个值的存储空间\n改变一个变量的值：将 该变量当前指向的值的存储空间中写入一个新的值。\nImmutability 不变性\n不变性：重要设计原则\n不变数据类型：一旦被创建，其值不能改变\n如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变\nfinal：final类无法派生子类final变量无法改变值/引用final方法无法被子类重写\n不变对象：一旦被创建，始终指向同一个值/引用\n可变对象：拥有方法可以修改自己的值/引用\nString是不可变的\nStringBuilder是可变的\n使用 不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，不可变类型更“安全”， 在其他质量指标上表现更好\n可变类型最少化拷贝以提高效率，使用可变数据类型，可获得更好的性能\nSnapshot\n用于描述程序运行时的内部状态，便于程序员之间的交流，刻画各类变量随时间变化，解释设计思路\n基本类型的值\n对象类型的值\n不可变对象：用双线椭圆\n不可变的引用：用双线箭头\n引用是不可变的，但指向的值却可以是可变的，可变的引用，也可指向不可变的值\n"
  },
  {
    "head": "软件构造学习笔记——软件构造过程",
    "paragraphs": [
      "传统软件进程模型",
      "基础类型：线性过程、迭代过程",
      "瀑布过程：线性推进 阶段划分清楚 整体推进 无迭代 管理简单 无法适应需求 增加/变化",
      "增量过程：线性推进 增量式（多个瀑布的串行）无迭代 比较容易适应需求的增加",
      "V字模型：",
      "原型过程：迭代过程",
      "螺旋模型 ：非常复杂的过程。多轮迭代基本遵循瀑布模式 每轮迭代有明确的目标 遵循“原型”过 程，进行严格的风险分析 方可进入下一轮迭代",
      "敏捷开发",
      "通过快速迭代和小规模的持续改进，以快速适应变化。",
      "Agile = 增量 + 迭代，每次迭代处理一个小规模增量",
      "极限的用户参与",
      "极限的小步骤迭代",
      "极限的确认/验证",
      "软件配置管理 (SCM) 和版本控制系统 (VCS)",
      "软件配置管理：追踪和控制软件的变化",
      "软件配置项（SCI）：软件中发生变化的基本单元（例如：文件）",
      "基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本）",
      "CMDB：配置管理数据库 存储软件的各配置项随时间发生变化的信息 +基线",
      "Versioning 版本控制",
      "版本：为软件的任一特定时刻（Moment）的形态指 派一个唯一的编号，作为“身份标识”",
      "古老的版本控制方法：通过复制文件并修改文件名",
      "仓库：即于SCM中的CMDB",
      "工作拷贝：在开发者本地机器上的一份项目拷贝",
      "文件：一个独立的配置项",
      "版本：在某个特定时间点的所有文件的共同状态",
      "变化：即code churn，两个版本之间的差异",
      "HEAD：程序员正在其上工作的版本",
      "版本控制系统（VCS）",
      "本地版本控制系统： 仓库存储于开发者本地机器，无法共享和协作",
      "集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作",
      "分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器",
      "Git as an example of SCM tool",
      "本地的CMDB",
      "工作目录：本地文件系统",
      "暂存区：隔离工作目录和Git仓库"
    ],
    "sentences": [
      "传统软件进程模型",
      "基础类型：线性过程、迭代过程",
      "瀑布过程：线性推进 阶段划分清楚 整体推进 无迭代 管理简单 无法适应需求 增加/变化",
      "增量过程：线性推进 增量式（多个瀑布的串行）无迭代 比较容易适应需求的增加",
      "V字模型：原型过程：迭代过程",
      "螺旋模型 ：非常复杂的过程",
      "多轮迭代基本遵循瀑布模式 每轮迭代有明确的目标 遵循“原型”过 程",
      "进行严格的风险分析 方可进入下一轮迭代",
      "敏捷开发",
      "通过快速迭代和小规模的持续改进，以快速适应变化",
      "Agile = 增量 + 迭代，每次迭代处理一个小规模增量",
      "极限的用户参与",
      "极限的小步骤迭代",
      "极限的确认/验证",
      "软件配置管理 (SCM) 和版本控制系统 (VCS)",
      "软件配置管理：追踪和控制软件的变化",
      "软件配置项（SCI）：软件中发生变化的基本单元（例如：文件）",
      "基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本）",
      "CMDB：配置管理数据库 存储软件的各配置项随时间发生变化的信息 +基线",
      "Versioning 版本控制",
      "版本：为软件的任一特定时刻（Moment）的形态指 派一个唯一的编号",
      "作为“身份标识”",
      "古老的版本控制方法：通过复制文件并修改文件名",
      "仓库：即于SCM中的CMDB",
      "工作拷贝：在开发者本地机器上的一份项目拷贝",
      "文件：一个独立的配置项",
      "版本：在某个特定时间点的所有文件的共同状态",
      "变化：即code churn，两个版本之间的差异",
      "HEAD：程序员正在其上工作的版本",
      "版本控制系统（VCS）",
      "本地版本控制系统： 仓库存储于开发者本地机器，无法共享和协作",
      "集中式版本控制系统：仓库存储于独立的服务器",
      "支持多开发者之间的协作",
      "分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器",
      "Git as an example of SCM tool",
      "本地的CMDB",
      "工作目录：本地文件系统",
      "暂存区：隔离工作目录和Git仓库"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "传统软件进程模型\n基础类型：线性过程、迭代过程\n瀑布过程：线性推进 阶段划分清楚 整体推进 无迭代 管理简单 无法适应需求 增加/变化\n增量过程：线性推进 增量式（多个瀑布的串行）无迭代 比较容易适应需求的增加\nV字模型：\n原型过程：迭代过程\n螺旋模型 ：非常复杂的过程。多轮迭代基本遵循瀑布模式 每轮迭代有明确的目标 遵循“原型”过 程，进行严格的风险分析 方可进入下一轮迭代\n敏捷开发\n通过快速迭代和小规模的持续改进，以快速适应变化。\nAgile = 增量 + 迭代，每次迭代处理一个小规模增量\n极限的用户参与\n极限的小步骤迭代\n极限的确认/验证\n软件配置管理 (SCM) 和版本控制系统 (VCS)\n软件配置管理：追踪和控制软件的变化\n软件配置项（SCI）：软件中发生变化的基本单元（例如：文件）\n基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本）\nCMDB：配置管理数据库 存储软件的各配置项随时间发生变化的信息 +基线\nVersioning 版本控制\n版本：为软件的任一特定时刻（Moment）的形态指 派一个唯一的编号，作为“身份标识”\n古老的版本控制方法：通过复制文件并修改文件名\n仓库：即于SCM中的CMDB\n工作拷贝：在开发者本地机器上的一份项目拷贝\n文件：一个独立的配置项\n版本：在某个特定时间点的所有文件的共同状态\n变化：即code churn，两个版本之间的差异\nHEAD：程序员正在其上工作的版本\n版本控制系统（VCS）\n本地版本控制系统： 仓库存储于开发者本地机器，无法共享和协作\n集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作\n分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器\nGit as an example of SCM tool\n本地的CMDB\n工作目录：本地文件系统\n暂存区：隔离工作目录和Git仓库\n"
  },
  {
    "head": "软件构造Lab3记录",
    "paragraphs": [
      "实验3，学期末时间太紧了，不然过程应该是挺快乐的",
      "实验环境配置",
      "实验过程",
      "3.1",
      "待开发的三个应用场景",
      "3.2",
      "面向可复用性和可维护性的设计：",
      "IntervalSet<L>",
      "3.2.1",
      "IntervalSet<L>",
      "的共性操作",
      "3.2.2",
      "局部共性特征的设计方案",
      "3.2.3",
      "面向各应用的",
      "IntervalSet",
      "子类型设计（个性化特征的设计方案）",
      "3.3",
      "面向可复用性和可维护性的设计：",
      "MultiIntervalSet<L>",
      "3.3.1",
      "MultiIntervalSet<L>",
      "的共性操作",
      "3.3.2",
      "局部共性特征的设计方案",
      "3.3.3",
      "面向各应用的",
      "MultiIntervalSet",
      "子类型设计（个性化特征的设计方案）",
      "3.4",
      "面向复用的设计：",
      "3.5",
      "可复用",
      "API",
      "3.5.1",
      "计算相似度",
      "3.5.2",
      "计算时间冲突比例",
      "3.5.3",
      "计算空闲时间比例",
      "3.6",
      "应用设计与开发",
      "3.6.1",
      "排班管理系统",
      "3.6.2",
      "操作系统的进程调度管理系统",
      "3.6.3",
      "课表管理系统",
      "3.7",
      "基于语法的数据读入",
      "3.8",
      "应对面临的新变化",
      "3.8.1",
      "3.8.2",
      "3.9 Git",
      "仓库结构",
      "实验进度记录",
      "实验过程中遇到的困难与解决途径",
      "实验过程中收获的经验、教训、感想",
      "6.1",
      "实验过程中收获的经验和教训",
      "6.2",
      "针对以下方面的感受",
      "实验目标概述",
      "本次实验覆盖课程第 2、3 章的内容，目标是编写具有可复用性和可维护性",
      "的软件，主要使用以下软件构造技术：",
      "子类型、泛型、多态、重写、重载",
      "继承、代理、组合",
      "语法驱动的编程、正则表达式",
      "API",
      "设计、API 复用",
      "本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过 ADT 和泛型等抽象技术，开发一套可复用的 ADT 及其实现，充分考虑这些应用之间的相似性和差异性，使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。",
      "实验环境配置",
      "在这里给出你的",
      "GitHub Lab3",
      "仓库的",
      "URL",
      "地址（",
      "HIT-Lab3-",
      "学号）。",
      "实验过程",
      "请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。",
      "待开发的三个应用场景",
      "（1）值班表管理（DutyRoster）：一个单位有 n 个员工，在某个时间段内（例如寒假 1 月 10 日到 3 月 6 日期间），每天只能安排唯一一个员工在单位值班，且不能出现某天无人值班的情况；每个员工若被安排值班 m 天（m>1），那么需要安排在连续的 m 天内。值班表内需要记录员工的名字、职位、手机号码，以便于外界联系值班员。",
      "（2）操作系统进程调度管理（ProcessSchedule）：考虑计算机上有一个单核CPU，多个进程被操作系统创建出来，它们被调度在 CPU 上执行，由操作系统决定在各个时段内执行哪个线程。操作系统可挂起某个正在执行的进程，在后续时刻可以恢复执行被挂起的进程。可知：每个时间只能有一个进程在执行，其他进程处于休眠状态；一个进程的执行被分为多个时间段；在特定时刻，CPU 可以“闲置”，意即操作系统没有调度执行任何进程；操作系统对进程的调度无规律，可看作是随机调度。",
      "（2）大学课表管理（CourseSchedule）：针对某个班级，假设其各周的课表都是完全一样的（意即同样的课程安排将以“周”为单位进行周期性的重复，直到学期结束）；一门课程每周可以出现 1 次，也可以安排多次（例如每周一和周三的“软件构造”）且由同一位教师承担并在同样的教室进行；允许课表中有空白时间段（未安排任何课程）；考虑到不同学生的选课情况不同，同一个时间段内可以安排不同的课程（例如周一上午 3-4 节的“计算方法”和“软件构造”）；一位教师也可以承担课表中的多门课程。",
      "面向可复用性和可维护性的设计：",
      "IntervalSet<L>",
      "该节是本实验的核心部分。",
      "IntervalSet<L>的共性操作",
      "insert",
      "分配一个时间段给一个新的标签",
      "labels",
      "获取已分配的标签集",
      "remove",
      "移除某标签的已分配时间段",
      "start",
      "获取某标签的时间段开始时间",
      "end",
      "获取某标签的时间段结束时间",
      "局部共性特征的设计方案",
      "IntervalSet<L>类的设计：",
      "创建一个Interval<L>类，每个Interval对象保存一个标签和其分配的唯一时间段",
      "通过继承decorator的子类实现各种个性化特征设计",
      "无重叠IntervalSet<L>：",
      "遍历每个时间段检查是否有重叠部分",
      "2.非空IntervalSet<L>：",
      "当输入完成后使用函数checkNoBlank检查，该函数返回总时间轴上未分配的时间，当已经非空时返回空集",
      "3.周期性IntervalSet<L>：",
      "周期性并无太多特殊性，其求模、取偏移等过程在具体的应用场景中实现，不新建额外的类",
      "面向可复用性和可维护性的设计：MultiIntervalSet<L>",
      "MultiIntervalSet<L>的共性操作",
      "insert",
      "分配一个时间段给一个已保存的标签",
      "addlabel",
      "添加一个新的标签",
      "labels",
      "获取已分配的标签集",
      "remove",
      "移除某标签的所有已分配时间段",
      "starts",
      "获取某标签的所有时间段开始时间",
      "ends",
      "获取某标签的所有时间段结束时间",
      "delete",
      "删除一个未分配时间的标签",
      "局部共性特征的设计方案",
      "创建Intervals<L>，以复用IntervalSet<L>的代码，每个Intervals<L>对象保存了一个标签和其分配的所有时间段，用IntervalSet<Integer>表示",
      "add",
      "为该标签分配一个时间段",
      "delete",
      "删除该标签的所有时间段",
      "getNum",
      "返回该标签分配的时间段个数",
      "getLabel",
      "返回标签名",
      "getStarts",
      "获取某标签的所有时间段开始时间",
      "getEnds",
      "获取某标签的所有时间段结束时间",
      "toString",
      "复用IntervalSet<L>中的toStirng方法",
      "对于MultiIntervalSet<L>中各方法的实现：",
      "insert：复用insert代码，向label对应的Intervals<L>分配一个时间段，并使num+1",
      "labels：遍历List<Intervals<L>>，返回所有label构成的集",
      "remove：遍历List<Intervals<L>>，移除对应的label中的所有时间段",
      "starts：遍历List<Intervals<L>>，找到对应label的Intervals<L>，遍历其intervalSet，返回每个时间段的intervalSet.start",
      "ends：遍历List<Intervals<L>>，找到对应label的Intervals<L>，遍历其intervalSet，返回每个时间段的intervalSet.end",
      "delete：检查对应label的Intervals<L>的num是否为0，是则从intervalsets中移除该对象",
      "MultiIntervalSet<L>结构如下：",
      "面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）",
      "无重叠：",
      "与IntervalSet<L>类似，相对复杂一些",
      "与IntervalSet<L>同理，调整遍历策略即可",
      "面向复用的设计：L",
      "对于三个实际应用，三个label分别是：",
      "Emploee：",
      "Process",
      "Course",
      "对于每个label，重写其equals方法，只要某一唯一特征相同就返回true，如课程ID、进程ID、员工姓名（员工姓名唯一是实验手册要求，实际应用中不可能这样设计）",
      "可复用API设计",
      "三个API原理基本相同，策略是首先建立一个包含所有时间的List（即从开始到结束），多重遍历IntervalSet中的时间段并检查其特定条件，将符合条件的时间点从List中移除，根据List的剩余长度返回特征值，该方法时间复杂度较高，但考虑到三个应用没有太大的数据量，其实可以接受",
      "计算相似度",
      "计算时间冲突比例",
      "计算空闲时间比例",
      "应用设计与开发",
      "利用上述设计和实现的",
      "ADT",
      "，实现手册里要求的各项功能。",
      "应用系统已配备操作界面和文字描述，功能基本复用了上述类中的方法",
      "排班管理系统",
      "基本使用上述ADT实现，用户首先输入起止时间以确定范围，然后将Employee类看作IntervalSet中的label，进行相应操作，由于CommonIntervalSet类只保存已分配时间段的label，所以单独创建一个List用来存储总的职员表，在删除员工时应遍历检查其是否在IntervalSet.label中，不在即没有排班时才可以删除员工信息，时间表示上，程序的前端输入输出均使用直观的LocalDate类表示，即yyyy-mm-dd，在后端信息处理时则使用日期转换的大纪元日表示（距离某特定日期的天数，long类型），便于信息处理",
      "添加排班记录，下图也体现了本系统的日期转换、输入模式等",
      "添加员工信息的方法不对IntervalSet进行操作",
      "删除员工时应检查其是否存在排班",
      "对值班记录是否排满的检查直接复用了上述非空IntervalSet的检查方法",
      "对于实验手册要求的随机排班功能，经实践发现如果完全随机排班，大概率出现排班时间不均的情况，甚至有时会一个人值所有班，这是不合理的，所以本系统采用了根据需值班天数和总员工数取每人需要值班的平均天数，但随机选择值班顺序的方法，这样可以尽可能公平地值班，该方法代码较长，可以在系统中进行测试，报告中不截图了",
      "不过有一点需要注意，根据这种取平均值的方法，由于舍入问题，需要检查在只剩一人没有排班时，应将剩余天数都排给他，这会让他比别人多值最多人数-1天的班，通常这是可以接受的",
      "主界面代码及操作截图：",
      "操作系统的进程调度管理系统",
      "进程管理系统使用MultiIntervalSet类和其无重叠子类实现，MultiIntervalSet类中可以存储未分配时间段的标签，所以不需要单独存储进程目录了，需要注意本程序禁止进程ID为0，现实中0号进程是系统进程，而在本系统中做此限制的原因会在后面提到",
      "本系统需要实现的功能比较少，主要使用了三个方法：",
      "随机进程调度randomSchedule()",
      "在此采用的方法是通过进程ID随机选择目标，若目标已经完成则重新随机，手册中要求了系统空置的情况，为了模拟这种情况，我们额外添加了一个进程ID为0的进程，名为idle，这也是我们限制用户添加的进程ID的原因，这样在随机数取到0时就代表系统空置了，为了避免随机数取到特别大的数，我们限制空置时间为1到10的随机数，对于运行时间，我们取选择的目标程序的最长运行时间减去进程已运行时间（保存在Process类中）以内的随机一个正整数，通过MultiIntervalSet表示各个进程在时间轴上的运行记录，若运行后该进程运行时间达到最短运行时间，则标记其已经完成，之后不再选择，并且使计数器+1，当计数器等于进程数时停止系统",
      "最短优先进程调度shortestSchedule()",
      "该系统通过遍历选出longest – runningtime最小的进程作为目标即可，运行时间选择策略与上一个方法相同，区别是这种调度模式不再有系统空置的情况了",
      "可视化处理visualization()",
      "本方法在系统调度完成之后通过保存的MultiIntervalSet复现系统调度过程到用户指定的时刻，并标注各进程的状态，包括：pause暂停，stop终止（完成），running 运行中，只有在用户指定时刻正在运行的进程是running状态",
      "课表管理系统",
      "写到这里时我发现前面的代码可以进行大量复用了，所以第三个App虽然内容不少但反而没有用大量时间",
      "对于该系统的时间表示，由于周期性的特点我们在MultiIntervalSet中只保存0到34这段时间，从周一第一节开始，每个点代表一节课（2学时）",
      "在排课分配时，每排一节课将该课程的已分配学时+2（保存在Course类中），当已分配满周学时时不可再为该课程排课",
      "对于查询课表功能的实现，由于时间轴上保存的是抽象化的0到34表示上课时间，而用户输入的是yyyy-mm-dd格式的日期查询当天课程，所以需要进行转换，这里使用了Localdate中的getDayOfWeek()方法，该方法可以计算某日期当天是星期几，再根据星期几决定偏移量，比如星期一从0开始，星期二从5开始…从偏移量开始往后的五节课程，就是当天的课表，遍历MultiIntervalSet，将符合时间的课程输出即可",
      "对于计算每周空闲时间和重复时间比例的功能，简单复用APIs.java中的方法即可实现",
      "应对面临的新变化",
      "变化1",
      "值班表的改变相对比较复杂，因为我早期的设计思路有一些问题，IntervalSet和MultiIntervalSet的方法不方便相互改变，需要改动一些客户端的方法才能实现值班表从单一表到多重表的改动，代价偏大",
      "变化2",
      "课表系统因为不涉及多重表和单一表的转换，所以改动比较简单，只需再decorator中新增一种无重叠MultiIntervalSet并应用到客户端中即可，代价比较小",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "针对以下方面的感受",
      "重新思考",
      "Lab2",
      "中的问题：面向",
      "ADT",
      "的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的",
      "ADT",
      "在五个不同的应用场景下使用，你是否体会到复用的好处？",
      "面向ADT的编程可以使代码具有更好的可复用型，让ADT可以面向多种相似的应用场所，大量提高编程效率",
      "重新思考",
      "Lab2",
      "中的问题：为",
      "ADT",
      "撰写复杂的",
      "specification, invariants, RI, AF",
      "，时刻注意",
      "ADT",
      "是否有",
      "rep exposure",
      "，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？",
      "让ADT更加准确，愿意",
      "之前你将别人提供的",
      "API",
      "用于自己的程序开发中，本次实验你尝试着开发给别人使用的",
      "API",
      "，是否能够体会到其中的难处和乐趣？",
      "难处体会到了，乐趣很难说",
      "你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？",
      "第一次接触，有点复杂",
      "Lab1",
      "Lab2",
      "的工作都不是从",
      "开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从",
      "开始进行",
      "ADT",
      "的设计并用",
      "OOP",
      "实现，经过三周之后，你感觉“设计",
      "ADT",
      "的难度主要体现在哪些地方？你是如何克服的？",
      "难度主要体现在自己的设计要足够严谨，如果有功能的遗漏，后续的补救工作是灾难性的，反复思考，确认自己的设计可以应对相应场合",
      "抽象”是计算机科学的核心概念之一，也是",
      "ADT",
      "OOP",
      "的精髓所在。本实验的三个应用既不能完全抽象为同一个",
      "ADT",
      "，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、委派、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？",
      "模块化的设计思路能够大大减轻工作量，但需要时间来熟悉这种模式",
      "关于本实验的工作量、难度、",
      "deadline",
      "下周就要进行考试了，你对《软件构造》课程总体评价如何？",
      "面向更多实际应用，比较有意义"
    ],
    "sentences": [
      "实验3，学期末时间太紧了，不然过程应该是挺快乐的",
      "实验环境配置",
      "实验过程",
      "3.1",
      "待开发的三个应用场景",
      "3.2",
      "面向可复用性和可维护性的设计：IntervalSet<L>",
      "3.2.1",
      "IntervalSet<L>",
      "的共性操作",
      "3.2.2",
      "局部共性特征的设计方案",
      "3.2.3",
      "面向各应用的",
      "IntervalSet",
      "子类型设计（个性化特征的设计方案）",
      "3.3",
      "面向可复用性和可维护性的设计：MultiIntervalSet<L>",
      "3.3.1",
      "MultiIntervalSet<L>",
      "的共性操作",
      "3.3.2",
      "局部共性特征的设计方案",
      "3.3.3",
      "面向各应用的",
      "MultiIntervalSet",
      "子类型设计（个性化特征的设计方案）",
      "3.4",
      "面向复用的设计：3.5",
      "可复用",
      "API",
      "3.5.1",
      "计算相似度",
      "3.5.2",
      "计算时间冲突比例",
      "3.5.3",
      "计算空闲时间比例",
      "3.6",
      "应用设计与开发",
      "3.6.1",
      "排班管理系统",
      "3.6.2",
      "操作系统的进程调度管理系统",
      "3.6.3",
      "课表管理系统",
      "3.7",
      "基于语法的数据读入",
      "3.8",
      "应对面临的新变化",
      "3.8.1",
      "3.8.2",
      "3.9 Git",
      "仓库结构",
      "实验进度记录",
      "实验过程中遇到的困难与解决途径",
      "实验过程中收获的经验、教训、感想",
      "6.1",
      "实验过程中收获的经验和教训",
      "6.2",
      "针对以下方面的感受",
      "实验目标概述",
      "本次实验覆盖课程第 2、3 章的内容",
      "目标是编写具有可复用性和可维护性",
      "的软件",
      "主要使用以下软件构造技术：子类型、泛型、多态、重写、重载",
      "继承、代理、组合",
      "语法驱动的编程、正则表达式",
      "API",
      "设计、API 复用",
      "本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理）",
      "学生不是直接针对每个应用分别编程实现",
      "而是通过 ADT 和泛型等抽象技术",
      "开发一套可复用的 ADT 及其实现",
      "充分考虑这些应用之间的相似性和差异性",
      "使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）",
      "实验环境配置",
      "在这里给出你的",
      "GitHub Lab3",
      "仓库的",
      "URL",
      "地址（",
      "HIT-Lab3-",
      "学号）",
      "实验过程",
      "请仔细对照实验手册",
      "针对每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）",
      "待开发的三个应用场景",
      "（1）值班表管理（DutyRoster）：一个单位有 n 个员工",
      "在某个时间段内（例如寒假 1 月 10 日到 3 月 6 日期间）",
      "每天只能安排唯一一个员工在单位值班",
      "且不能出现某天无人值班的情况；每个员工若被安排值班 m 天（m>1）",
      "那么需要安排在连续的 m 天内",
      "值班表内需要记录员工的名字、职位、手机号码",
      "以便于外界联系值班员",
      "（2）操作系统进程调度管理（ProcessSchedule）：考虑计算机上有一个单核CPU",
      "多个进程被操作系统创建出来",
      "它们被调度在 CPU 上执行",
      "由操作系统决定在各个时段内执行哪个线程",
      "操作系统可挂起某个正在执行的进程",
      "在后续时刻可以恢复执行被挂起的进程",
      "可知：每个时间只能有一个进程在执行",
      "其他进程处于休眠状态；一个进程的执行被分为多个时间段；在特定时刻",
      "CPU 可以“闲置”",
      "意即操作系统没有调度执行任何进程；操作系统对进程的调度无规律",
      "可看作是随机调度",
      "（2）大学课表管理（CourseSchedule）：针对某个班级",
      "假设其各周的课表都是完全一样的（意即同样的课程安排将以“周”为单位进行周期性的重复",
      "直到学期结束）；一门课程每周可以出现 1 次",
      "也可以安排多次（例如每周一和周三的“软件构造”）且由同一位教师承担并在同样的教室进行；允许课表中有空白时间段（未安排任何课程）；考虑到不同学生的选课情况不同",
      "同一个时间段内可以安排不同的课程（例如周一上午 3-4 节的“计算方法”和“软件构造”）；一位教师也可以承担课表中的多门课程",
      "面向可复用性和可维护性的设计：IntervalSet<L>",
      "该节是本实验的核心部分",
      "IntervalSet<L>的共性操作",
      "insert",
      "分配一个时间段给一个新的标签",
      "labels",
      "获取已分配的标签集",
      "remove",
      "移除某标签的已分配时间段",
      "start",
      "获取某标签的时间段开始时间",
      "end",
      "获取某标签的时间段结束时间",
      "局部共性特征的设计方案",
      "IntervalSet<L>类的设计：创建一个Interval<L>类",
      "每个Interval对象保存一个标签和其分配的唯一时间段",
      "通过继承decorator的子类实现各种个性化特征设计",
      "无重叠IntervalSet<L>：遍历每个时间段检查是否有重叠部分",
      "2.非空IntervalSet<L>：当输入完成后使用函数checkNoBlank检查",
      "该函数返回总时间轴上未分配的时间",
      "当已经非空时返回空集",
      "3.周期性IntervalSet<L>：周期性并无太多特殊性",
      "其求模、取偏移等过程在具体的应用场景中实现",
      "不新建额外的类",
      "面向可复用性和可维护性的设计：MultiIntervalSet<L>",
      "MultiIntervalSet<L>的共性操作",
      "insert",
      "分配一个时间段给一个已保存的标签",
      "addlabel",
      "添加一个新的标签",
      "labels",
      "获取已分配的标签集",
      "remove",
      "移除某标签的所有已分配时间段",
      "starts",
      "获取某标签的所有时间段开始时间",
      "ends",
      "获取某标签的所有时间段结束时间",
      "delete",
      "删除一个未分配时间的标签",
      "局部共性特征的设计方案",
      "创建Intervals<L>",
      "以复用IntervalSet<L>的代码",
      "每个Intervals<L>对象保存了一个标签和其分配的所有时间段",
      "用IntervalSet<Integer>表示",
      "add",
      "为该标签分配一个时间段",
      "delete",
      "删除该标签的所有时间段",
      "getNum",
      "返回该标签分配的时间段个数",
      "getLabel",
      "返回标签名",
      "getStarts",
      "获取某标签的所有时间段开始时间",
      "getEnds",
      "获取某标签的所有时间段结束时间",
      "toString",
      "复用IntervalSet<L>中的toStirng方法",
      "对于MultiIntervalSet<L>中各方法的实现：insert：复用insert代码",
      "向label对应的Intervals<L>分配一个时间段",
      "并使num+1",
      "labels：遍历List<Intervals<L>>",
      "返回所有label构成的集",
      "remove：遍历List<Intervals<L>>",
      "移除对应的label中的所有时间段",
      "starts：遍历List<Intervals<L>>",
      "找到对应label的Intervals<L>",
      "遍历其intervalSet",
      "返回每个时间段的intervalSet.start",
      "ends：遍历List<Intervals<L>>",
      "找到对应label的Intervals<L>",
      "遍历其intervalSet",
      "返回每个时间段的intervalSet.end",
      "delete：检查对应label的Intervals<L>的num是否为0",
      "是则从intervalsets中移除该对象",
      "MultiIntervalSet<L>结构如下：面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）",
      "无重叠：与IntervalSet<L>类似，相对复杂一些",
      "与IntervalSet<L>同理，调整遍历策略即可",
      "面向复用的设计：L",
      "对于三个实际应用",
      "三个label分别是：Emploee：Process",
      "Course",
      "对于每个label",
      "重写其equals方法",
      "只要某一唯一特征相同就返回true",
      "如课程ID、进程ID、员工姓名（员工姓名唯一是实验手册要求",
      "实际应用中不可能这样设计）",
      "可复用API设计",
      "三个API原理基本相同",
      "策略是首先建立一个包含所有时间的List（即从开始到结束）",
      "多重遍历IntervalSet中的时间段并检查其特定条件",
      "将符合条件的时间点从List中移除",
      "根据List的剩余长度返回特征值",
      "该方法时间复杂度较高",
      "但考虑到三个应用没有太大的数据量",
      "其实可以接受",
      "计算相似度",
      "计算时间冲突比例",
      "计算空闲时间比例",
      "应用设计与开发",
      "利用上述设计和实现的",
      "ADT",
      "，实现手册里要求的各项功能",
      "应用系统已配备操作界面和文字描述",
      "功能基本复用了上述类中的方法",
      "排班管理系统",
      "基本使用上述ADT实现",
      "用户首先输入起止时间以确定范围",
      "然后将Employee类看作IntervalSet中的label",
      "进行相应操作",
      "由于CommonIntervalSet类只保存已分配时间段的label",
      "所以单独创建一个List用来存储总的职员表",
      "在删除员工时应遍历检查其是否在IntervalSet.label中",
      "不在即没有排班时才可以删除员工信息",
      "时间表示上",
      "程序的前端输入输出均使用直观的LocalDate类表示",
      "即yyyy-mm-dd",
      "在后端信息处理时则使用日期转换的大纪元日表示（距离某特定日期的天数",
      "long类型）",
      "便于信息处理",
      "添加排班记录，下图也体现了本系统的日期转换、输入模式等",
      "添加员工信息的方法不对IntervalSet进行操作",
      "删除员工时应检查其是否存在排班",
      "对值班记录是否排满的检查直接复用了上述非空IntervalSet的检查方法",
      "对于实验手册要求的随机排班功能",
      "经实践发现如果完全随机排班",
      "大概率出现排班时间不均的情况",
      "甚至有时会一个人值所有班",
      "这是不合理的",
      "所以本系统采用了根据需值班天数和总员工数取每人需要值班的平均天数",
      "但随机选择值班顺序的方法",
      "这样可以尽可能公平地值班",
      "该方法代码较长",
      "可以在系统中进行测试",
      "报告中不截图了",
      "不过有一点需要注意",
      "根据这种取平均值的方法",
      "由于舍入问题",
      "需要检查在只剩一人没有排班时",
      "应将剩余天数都排给他",
      "这会让他比别人多值最多人数-1天的班",
      "通常这是可以接受的",
      "主界面代码及操作截图：操作系统的进程调度管理系统",
      "进程管理系统使用MultiIntervalSet类和其无重叠子类实现",
      "MultiIntervalSet类中可以存储未分配时间段的标签",
      "所以不需要单独存储进程目录了",
      "需要注意本程序禁止进程ID为0",
      "现实中0号进程是系统进程",
      "而在本系统中做此限制的原因会在后面提到",
      "本系统需要实现的功能比较少",
      "主要使用了三个方法：随机进程调度randomSchedule()",
      "在此采用的方法是通过进程ID随机选择目标",
      "若目标已经完成则重新随机",
      "手册中要求了系统空置的情况",
      "为了模拟这种情况",
      "我们额外添加了一个进程ID为0的进程",
      "名为idle",
      "这也是我们限制用户添加的进程ID的原因",
      "这样在随机数取到0时就代表系统空置了",
      "为了避免随机数取到特别大的数",
      "我们限制空置时间为1到10的随机数",
      "对于运行时间",
      "我们取选择的目标程序的最长运行时间减去进程已运行时间（保存在Process类中）以内的随机一个正整数",
      "通过MultiIntervalSet表示各个进程在时间轴上的运行记录",
      "若运行后该进程运行时间达到最短运行时间",
      "则标记其已经完成",
      "之后不再选择",
      "并且使计数器+1",
      "当计数器等于进程数时停止系统",
      "最短优先进程调度shortestSchedule()",
      "该系统通过遍历选出longest – runningtime最小的进程作为目标即可",
      "运行时间选择策略与上一个方法相同",
      "区别是这种调度模式不再有系统空置的情况了",
      "可视化处理visualization()",
      "本方法在系统调度完成之后通过保存的MultiIntervalSet复现系统调度过程到用户指定的时刻",
      "并标注各进程的状态",
      "包括：pause暂停",
      "stop终止（完成）",
      "running 运行中",
      "只有在用户指定时刻正在运行的进程是running状态",
      "课表管理系统",
      "写到这里时我发现前面的代码可以进行大量复用了",
      "所以第三个App虽然内容不少但反而没有用大量时间",
      "对于该系统的时间表示",
      "由于周期性的特点我们在MultiIntervalSet中只保存0到34这段时间",
      "从周一第一节开始",
      "每个点代表一节课（2学时）",
      "在排课分配时",
      "每排一节课将该课程的已分配学时+2（保存在Course类中）",
      "当已分配满周学时时不可再为该课程排课",
      "对于查询课表功能的实现",
      "由于时间轴上保存的是抽象化的0到34表示上课时间",
      "而用户输入的是yyyy-mm-dd格式的日期查询当天课程",
      "所以需要进行转换",
      "这里使用了Localdate中的getDayOfWeek()方法",
      "该方法可以计算某日期当天是星期几",
      "再根据星期几决定偏移量",
      "比如星期一从0开始",
      "星期二从5开始…从偏移量开始往后的五节课程",
      "就是当天的课表",
      "遍历MultiIntervalSet",
      "将符合时间的课程输出即可",
      "对于计算每周空闲时间和重复时间比例的功能",
      "简单复用APIs.java中的方法即可实现",
      "应对面临的新变化",
      "变化1",
      "值班表的改变相对比较复杂",
      "因为我早期的设计思路有一些问题",
      "IntervalSet和MultiIntervalSet的方法不方便相互改变",
      "需要改动一些客户端的方法才能实现值班表从单一表到多重表的改动",
      "代价偏大",
      "变化2",
      "课表系统因为不涉及多重表和单一表的转换",
      "所以改动比较简单",
      "只需再decorator中新增一种无重叠MultiIntervalSet并应用到客户端中即可",
      "代价比较小",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "针对以下方面的感受",
      "重新思考",
      "Lab2",
      "中的问题：面向",
      "ADT",
      "的编程和直接面向应用场景编程",
      "你体会到二者有何差异？本实验设计的",
      "ADT",
      "在五个不同的应用场景下使用，你是否体会到复用的好处？",
      "面向ADT的编程可以使代码具有更好的可复用型",
      "让ADT可以面向多种相似的应用场所",
      "大量提高编程效率",
      "重新思考",
      "Lab2",
      "中的问题：为",
      "ADT",
      "撰写复杂的",
      "specification, invariants, RI, AF",
      "，时刻注意",
      "ADT",
      "是否有",
      "rep exposure",
      "，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？",
      "让ADT更加准确，愿意",
      "之前你将别人提供的",
      "API",
      "用于自己的程序开发中，本次实验你尝试着开发给别人使用的",
      "API",
      "，是否能够体会到其中的难处和乐趣？",
      "难处体会到了，乐趣很难说",
      "你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令",
      "本次实验你开发了一个解析器",
      "使用语法和正则表达式去解析输入文件并据此构造对象",
      "你对语法驱动编程有何感受？",
      "第一次接触，有点复杂",
      "Lab1",
      "Lab2",
      "的工作都不是从",
      "开始，而是基于他人给出的设计方案和初始代码",
      "本次实验是你完全从",
      "开始进行",
      "ADT",
      "的设计并用",
      "OOP",
      "实现，经过三周之后，你感觉“设计",
      "ADT",
      "的难度主要体现在哪些地方？你是如何克服的？",
      "难度主要体现在自己的设计要足够严谨",
      "如果有功能的遗漏",
      "后续的补救工作是灾难性的",
      "反复思考",
      "确认自己的设计可以应对相应场合",
      "抽象”是计算机科学的核心概念之一，也是",
      "ADT",
      "OOP",
      "的精髓所在",
      "本实验的三个应用既不能完全抽象为同一个",
      "ADT",
      "",
      "也不是完全个性化",
      "如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、委派、设计模式等技术完成最大程度的抽象和复用",
      "你有什么经验教训？",
      "模块化的设计思路能够大大减轻工作量，但需要时间来熟悉这种模式",
      "关于本实验的工作量、难度、deadline",
      "下周就要进行考试了，你对《软件构造》课程总体评价如何？",
      "面向更多实际应用，比较有意义"
    ],
    "codes": [],
    "date": "2021-07-05",
    "text": "实验3，学期末时间太紧了，不然过程应该是挺快乐的\n实验环境配置\n实验过程\n3.1\n待开发的三个应用场景\n3.2\n面向可复用性和可维护性的设计：\nIntervalSet<L>\n3.2.1\nIntervalSet<L>\n的共性操作\n3.2.2\n局部共性特征的设计方案\n3.2.3\n面向各应用的\nIntervalSet\n子类型设计（个性化特征的设计方案）\n3.3\n面向可复用性和可维护性的设计：\nMultiIntervalSet<L>\n3.3.1\nMultiIntervalSet<L>\n的共性操作\n3.3.2\n局部共性特征的设计方案\n3.3.3\n面向各应用的\nMultiIntervalSet\n子类型设计（个性化特征的设计方案）\n3.4\n面向复用的设计：\n3.5\n可复用\nAPI\n3.5.1\n计算相似度\n3.5.2\n计算时间冲突比例\n3.5.3\n计算空闲时间比例\n3.6\n应用设计与开发\n3.6.1\n排班管理系统\n3.6.2\n操作系统的进程调度管理系统\n3.6.3\n课表管理系统\n3.7\n基于语法的数据读入\n3.8\n应对面临的新变化\n3.8.1\n3.8.2\n3.9 Git\n仓库结构\n实验进度记录\n实验过程中遇到的困难与解决途径\n实验过程中收获的经验、教训、感想\n6.1\n实验过程中收获的经验和教训\n6.2\n针对以下方面的感受\n实验目标概述\n本次实验覆盖课程第 2、3 章的内容，目标是编写具有可复用性和可维护性\n的软件，主要使用以下软件构造技术：\n子类型、泛型、多态、重写、重载\n继承、代理、组合\n语法驱动的编程、正则表达式\nAPI\n设计、API 复用\n本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过 ADT 和泛型等抽象技术，开发一套可复用的 ADT 及其实现，充分考虑这些应用之间的相似性和差异性，使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。\n实验环境配置\n在这里给出你的\nGitHub Lab3\n仓库的\nURL\n地址（\nHIT-Lab3-\n学号）。\n实验过程\n请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\n待开发的三个应用场景\n（1）值班表管理（DutyRoster）：一个单位有 n 个员工，在某个时间段内（例如寒假 1 月 10 日到 3 月 6 日期间），每天只能安排唯一一个员工在单位值班，且不能出现某天无人值班的情况；每个员工若被安排值班 m 天（m>1），那么需要安排在连续的 m 天内。值班表内需要记录员工的名字、职位、手机号码，以便于外界联系值班员。\n（2）操作系统进程调度管理（ProcessSchedule）：考虑计算机上有一个单核CPU，多个进程被操作系统创建出来，它们被调度在 CPU 上执行，由操作系统决定在各个时段内执行哪个线程。操作系统可挂起某个正在执行的进程，在后续时刻可以恢复执行被挂起的进程。可知：每个时间只能有一个进程在执行，其他进程处于休眠状态；一个进程的执行被分为多个时间段；在特定时刻，CPU 可以“闲置”，意即操作系统没有调度执行任何进程；操作系统对进程的调度无规律，可看作是随机调度。\n（2）大学课表管理（CourseSchedule）：针对某个班级，假设其各周的课表都是完全一样的（意即同样的课程安排将以“周”为单位进行周期性的重复，直到学期结束）；一门课程每周可以出现 1 次，也可以安排多次（例如每周一和周三的“软件构造”）且由同一位教师承担并在同样的教室进行；允许课表中有空白时间段（未安排任何课程）；考虑到不同学生的选课情况不同，同一个时间段内可以安排不同的课程（例如周一上午 3-4 节的“计算方法”和“软件构造”）；一位教师也可以承担课表中的多门课程。\n面向可复用性和可维护性的设计：\nIntervalSet<L>\n该节是本实验的核心部分。\nIntervalSet<L>的共性操作\ninsert\n分配一个时间段给一个新的标签\nlabels\n获取已分配的标签集\nremove\n移除某标签的已分配时间段\nstart\n获取某标签的时间段开始时间\nend\n获取某标签的时间段结束时间\n局部共性特征的设计方案\nIntervalSet<L>类的设计：\n创建一个Interval<L>类，每个Interval对象保存一个标签和其分配的唯一时间段\n通过继承decorator的子类实现各种个性化特征设计\n无重叠IntervalSet<L>：\n遍历每个时间段检查是否有重叠部分\n2.非空IntervalSet<L>：\n当输入完成后使用函数checkNoBlank检查，该函数返回总时间轴上未分配的时间，当已经非空时返回空集\n3.周期性IntervalSet<L>：\n周期性并无太多特殊性，其求模、取偏移等过程在具体的应用场景中实现，不新建额外的类\n面向可复用性和可维护性的设计：MultiIntervalSet<L>\nMultiIntervalSet<L>的共性操作\ninsert\n分配一个时间段给一个已保存的标签\naddlabel\n添加一个新的标签\nlabels\n获取已分配的标签集\nremove\n移除某标签的所有已分配时间段\nstarts\n获取某标签的所有时间段开始时间\nends\n获取某标签的所有时间段结束时间\ndelete\n删除一个未分配时间的标签\n局部共性特征的设计方案\n创建Intervals<L>，以复用IntervalSet<L>的代码，每个Intervals<L>对象保存了一个标签和其分配的所有时间段，用IntervalSet<Integer>表示\nadd\n为该标签分配一个时间段\ndelete\n删除该标签的所有时间段\ngetNum\n返回该标签分配的时间段个数\ngetLabel\n返回标签名\ngetStarts\n获取某标签的所有时间段开始时间\ngetEnds\n获取某标签的所有时间段结束时间\ntoString\n复用IntervalSet<L>中的toStirng方法\n对于MultiIntervalSet<L>中各方法的实现：\ninsert：复用insert代码，向label对应的Intervals<L>分配一个时间段，并使num+1\nlabels：遍历List<Intervals<L>>，返回所有label构成的集\nremove：遍历List<Intervals<L>>，移除对应的label中的所有时间段\nstarts：遍历List<Intervals<L>>，找到对应label的Intervals<L>，遍历其intervalSet，返回每个时间段的intervalSet.start\nends：遍历List<Intervals<L>>，找到对应label的Intervals<L>，遍历其intervalSet，返回每个时间段的intervalSet.end\ndelete：检查对应label的Intervals<L>的num是否为0，是则从intervalsets中移除该对象\nMultiIntervalSet<L>结构如下：\n面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）\n无重叠：\n与IntervalSet<L>类似，相对复杂一些\n与IntervalSet<L>同理，调整遍历策略即可\n面向复用的设计：L\n对于三个实际应用，三个label分别是：\nEmploee：\nProcess\nCourse\n对于每个label，重写其equals方法，只要某一唯一特征相同就返回true，如课程ID、进程ID、员工姓名（员工姓名唯一是实验手册要求，实际应用中不可能这样设计）\n可复用API设计\n三个API原理基本相同，策略是首先建立一个包含所有时间的List（即从开始到结束），多重遍历IntervalSet中的时间段并检查其特定条件，将符合条件的时间点从List中移除，根据List的剩余长度返回特征值，该方法时间复杂度较高，但考虑到三个应用没有太大的数据量，其实可以接受\n计算相似度\n计算时间冲突比例\n计算空闲时间比例\n应用设计与开发\n利用上述设计和实现的\nADT\n，实现手册里要求的各项功能。\n应用系统已配备操作界面和文字描述，功能基本复用了上述类中的方法\n排班管理系统\n基本使用上述ADT实现，用户首先输入起止时间以确定范围，然后将Employee类看作IntervalSet中的label，进行相应操作，由于CommonIntervalSet类只保存已分配时间段的label，所以单独创建一个List用来存储总的职员表，在删除员工时应遍历检查其是否在IntervalSet.label中，不在即没有排班时才可以删除员工信息，时间表示上，程序的前端输入输出均使用直观的LocalDate类表示，即yyyy-mm-dd，在后端信息处理时则使用日期转换的大纪元日表示（距离某特定日期的天数，long类型），便于信息处理\n添加排班记录，下图也体现了本系统的日期转换、输入模式等\n添加员工信息的方法不对IntervalSet进行操作\n删除员工时应检查其是否存在排班\n对值班记录是否排满的检查直接复用了上述非空IntervalSet的检查方法\n对于实验手册要求的随机排班功能，经实践发现如果完全随机排班，大概率出现排班时间不均的情况，甚至有时会一个人值所有班，这是不合理的，所以本系统采用了根据需值班天数和总员工数取每人需要值班的平均天数，但随机选择值班顺序的方法，这样可以尽可能公平地值班，该方法代码较长，可以在系统中进行测试，报告中不截图了\n不过有一点需要注意，根据这种取平均值的方法，由于舍入问题，需要检查在只剩一人没有排班时，应将剩余天数都排给他，这会让他比别人多值最多人数-1天的班，通常这是可以接受的\n主界面代码及操作截图：\n操作系统的进程调度管理系统\n进程管理系统使用MultiIntervalSet类和其无重叠子类实现，MultiIntervalSet类中可以存储未分配时间段的标签，所以不需要单独存储进程目录了，需要注意本程序禁止进程ID为0，现实中0号进程是系统进程，而在本系统中做此限制的原因会在后面提到\n本系统需要实现的功能比较少，主要使用了三个方法：\n随机进程调度randomSchedule()\n在此采用的方法是通过进程ID随机选择目标，若目标已经完成则重新随机，手册中要求了系统空置的情况，为了模拟这种情况，我们额外添加了一个进程ID为0的进程，名为idle，这也是我们限制用户添加的进程ID的原因，这样在随机数取到0时就代表系统空置了，为了避免随机数取到特别大的数，我们限制空置时间为1到10的随机数，对于运行时间，我们取选择的目标程序的最长运行时间减去进程已运行时间（保存在Process类中）以内的随机一个正整数，通过MultiIntervalSet表示各个进程在时间轴上的运行记录，若运行后该进程运行时间达到最短运行时间，则标记其已经完成，之后不再选择，并且使计数器+1，当计数器等于进程数时停止系统\n最短优先进程调度shortestSchedule()\n该系统通过遍历选出longest – runningtime最小的进程作为目标即可，运行时间选择策略与上一个方法相同，区别是这种调度模式不再有系统空置的情况了\n可视化处理visualization()\n本方法在系统调度完成之后通过保存的MultiIntervalSet复现系统调度过程到用户指定的时刻，并标注各进程的状态，包括：pause暂停，stop终止（完成），running 运行中，只有在用户指定时刻正在运行的进程是running状态\n课表管理系统\n写到这里时我发现前面的代码可以进行大量复用了，所以第三个App虽然内容不少但反而没有用大量时间\n对于该系统的时间表示，由于周期性的特点我们在MultiIntervalSet中只保存0到34这段时间，从周一第一节开始，每个点代表一节课（2学时）\n在排课分配时，每排一节课将该课程的已分配学时+2（保存在Course类中），当已分配满周学时时不可再为该课程排课\n对于查询课表功能的实现，由于时间轴上保存的是抽象化的0到34表示上课时间，而用户输入的是yyyy-mm-dd格式的日期查询当天课程，所以需要进行转换，这里使用了Localdate中的getDayOfWeek()方法，该方法可以计算某日期当天是星期几，再根据星期几决定偏移量，比如星期一从0开始，星期二从5开始…从偏移量开始往后的五节课程，就是当天的课表，遍历MultiIntervalSet，将符合时间的课程输出即可\n对于计算每周空闲时间和重复时间比例的功能，简单复用APIs.java中的方法即可实现\n应对面临的新变化\n变化1\n值班表的改变相对比较复杂，因为我早期的设计思路有一些问题，IntervalSet和MultiIntervalSet的方法不方便相互改变，需要改动一些客户端的方法才能实现值班表从单一表到多重表的改动，代价偏大\n变化2\n课表系统因为不涉及多重表和单一表的转换，所以改动比较简单，只需再decorator中新增一种无重叠MultiIntervalSet并应用到客户端中即可，代价比较小\n实验过程中收获的经验、教训、感想\n实验过程中收获的经验和教训\n针对以下方面的感受\n重新思考\nLab2\n中的问题：面向\nADT\n的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的\nADT\n在五个不同的应用场景下使用，你是否体会到复用的好处？\n面向ADT的编程可以使代码具有更好的可复用型，让ADT可以面向多种相似的应用场所，大量提高编程效率\n重新思考\nLab2\n中的问题：为\nADT\n撰写复杂的\nspecification, invariants, RI, AF\n，时刻注意\nADT\n是否有\nrep exposure\n，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？\n让ADT更加准确，愿意\n之前你将别人提供的\nAPI\n用于自己的程序开发中，本次实验你尝试着开发给别人使用的\nAPI\n，是否能够体会到其中的难处和乐趣？\n难处体会到了，乐趣很难说\n你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？\n第一次接触，有点复杂\nLab1\nLab2\n的工作都不是从\n开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从\n开始进行\nADT\n的设计并用\nOOP\n实现，经过三周之后，你感觉“设计\nADT\n的难度主要体现在哪些地方？你是如何克服的？\n难度主要体现在自己的设计要足够严谨，如果有功能的遗漏，后续的补救工作是灾难性的，反复思考，确认自己的设计可以应对相应场合\n抽象”是计算机科学的核心概念之一，也是\nADT\nOOP\n的精髓所在。本实验的三个应用既不能完全抽象为同一个\nADT\n，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、委派、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？\n模块化的设计思路能够大大减轻工作量，但需要时间来熟悉这种模式\n关于本实验的工作量、难度、\ndeadline\n下周就要进行考试了，你对《软件构造》课程总体评价如何？\n面向更多实际应用，比较有意义\n"
  },
  {
    "head": "HIT软件构造Lab2记录",
    "paragraphs": [
      "本次实验初看让人有点摸不着头脑，先根据模板写测试再编程的顺序在之前完全没见过，但熟悉之后发现效率很高，思路也更清晰，nice",
      "实验环境配置",
      "实验过程",
      "3.1 Poetic Walks",
      "3.1.1 Get the code and prepare Git repository",
      "3.1.2 Problem 1: Test",
      "Graph <String>",
      "3.1.3 Problem 2: Implement",
      "Graph <String>",
      "3.1.3.1 Implement",
      "ConcreteEdgesGraph",
      "3.1.3.2 Implement",
      "ConcreteVerticesGraph",
      "3.1.4 Problem 3: Implement generic",
      "Graph<L>",
      "3.1.4.1 Make the implementations generic",
      "3.1.4.2 Implement",
      "Graph.empty()",
      "3.1.5 Problem 4: Poetic walks",
      "3.1.5.1 Test",
      "GraphPoet",
      "3.1.5.2 Implement",
      "GraphPoet",
      "3.1.5.3 Graph poetry slam",
      "3.1.6",
      "Eclemma",
      "检查测试的代码覆盖度",
      "3.1.7 Before you’re done",
      "3.2 Re-implement the Social Network in Lab1",
      "3.2.1",
      "FriendshipGraph",
      "3.2.2",
      "Person",
      "3.2.3",
      "客户端",
      "main()",
      "3.2.4",
      "测试用例",
      "3.2.5",
      "提交至",
      "Git",
      "实验进度记录",
      "实验过程中遇到的困难与解决途径",
      "实验过程中收获的经验、教训、感想",
      "6.1",
      "实验过程中收获的经验和教训",
      "6.2",
      "针对以下方面的感受",
      "1.实验目标概述",
      "本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说：",
      "l 针对给定的应用问题，从问题描述中识别所需的ADT；",
      "l 设计ADT 规约（pre-condition、post-condition）并评估规约的质量；",
      "l 根据ADT 的规约设计测试用例；",
      "l ADT的泛型化；",
      "l 根据规约设计ADT 的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）",
      "l 使用OOP 实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；",
      "l 测试ADT 的实现并评估测试的覆盖度；",
      "l 使用ADT 及其实现，为应用问题开发程序；",
      "l 在测试代码中，能够写出testing strategy 并据此设计测试用例。",
      "2.实验环境配置",
      "IDEA",
      "中自带覆盖率测试插件，故无需添加",
      "在这里给出你的",
      "GitHub Lab2",
      "仓库的",
      "URL",
      "地址（",
      "Lab2-",
      "学号）。",
      "https://github.com/ComputerScienceHIT/HIT-Lab2-1190201517",
      "3.实验过程",
      "3.1",
      "Poetic Walks",
      "题目给出了一个graph接口，要求我们完成两个描述图的类，其中一个以边为主体，一个以点为主体，并按要求实现接口中的各种方法，最后使用完成的图抽象数据类型完成诗歌生成的功能",
      "3.1.1",
      "Get the code and prepare Git repository",
      "通过控制台命令建立本地git仓库，并用clone指令通过给出的url地址下载指定代码包到git仓库中",
      "3.1.2",
      "Problem 1: Test Graph <String>",
      "思路：首先根据接口的功能描述完成测试程序，测试程序应分别测试接口中给出的各个方法",
      "add",
      "：对于点已存在和未存在的情况分别测试，检查输入的点是否在图中。",
      "set",
      "：考虑多种情况：边不存在时添加，边已存在时覆盖并返回原权重，权重为0时删除边，权重为负时报错。",
      "remove",
      "：点不存在时返回false，点存在时移除该点并返回true，移除后应检查与该点有关的边是否也被移除",
      "vertices",
      "：检查点的添加和移除后是否均能正确返回点集",
      "sources",
      "和targets：检查添加、移除边后能否正确返回源点集和终点集",
      "3.1.3",
      "Problem 2: Implement Graph <L>",
      "3.1.3.1",
      "Implement ConcreteEdgesGraph",
      "建立ConcreteEdgesGraph类和Egde类，Egde类表示边的状态，ConcreteEdgesGraph类实现接口功能，其中各方法功能如下表：",
      "Edge：",
      "checkRep",
      "检查不变性",
      "getSource",
      "返回起始点",
      "getTarget",
      "返回终止点",
      "getWeight",
      "返回权重",
      "toString",
      "按“起始点-权重>终止点”的格式返回表示该边的字符串",
      "ConcreteEdgesGraph：",
      "checkRep",
      "检查不变性",
      "add",
      "向图中添加一个点，点的名称不可重复",
      "set",
      "向图中添加一条边，若边存在则覆盖旧边并返回旧边权重，边不存在则新建并返回0，当输入权重为0时移除该边，权重为负时报错",
      "remove",
      "移除一个点和该点连接的边，成功移除返回true，边不存在返回false",
      "vertices",
      "返回图的所有点构成的集合",
      "sources",
      "返回图中所有作为起始点的点和其边构成的集合",
      "targets",
      "返回图中所有作为终止点的点和其边构成的集合",
      "toString",
      "将图中所有边转化为字符串返回，顺序按照边添加的顺序",
      "3.1.3.2",
      "Implement ConcreteVerticesGraph",
      "建立ConcreteVerticesGraph类和Vertex类，Vertex类表示点及其连接状态，ConcreteVerticesGraph类实现接口功能，其中各方法功能如下表：",
      "Vertex：",
      "checkRep",
      "检查不变性",
      "getVertex",
      "返回该点名称",
      "getSources",
      "返回指向该点的点集",
      "getTargets",
      "返回该点指向的点集",
      "addSources\\removeSources",
      "添加、删除指向该点的边",
      "addTargets\\removeTargets",
      "添加、删除该点指向的边",
      "toString",
      "按“起始点-权重>终止点”的格式返回表示该边的字符串",
      "ConcreteVerticGraph：",
      "checkRep",
      "检查不变性",
      "add",
      "向图中添加一个点，点的名称不可重复",
      "set",
      "向图中添加一条边，若边存在则覆盖旧边并返回旧边权重，边不存在则新建并返回0，当输入权重为0时移除该边，权重为负时报错",
      "remove",
      "移除一个点和该点连接的边，成功移除返回true，边不存在返回false",
      "vertices",
      "返回图的所有点构成的集合",
      "sources",
      "返回图中所有作为起始点的点和其边构成的集合",
      "targets",
      "返回图中所有作为终止点的点和其边构成的集合",
      "toString",
      "将图中所有边转化为字符串返回，顺序按照点添加的顺序，每个点按边添加顺序输出以该点为起始点的边",
      "3.1.4",
      "Problem 4: Poetic walks",
      "本题要求使用上述图结构，用给定的文件为文本集，连接集合中相邻的词，构建这样的图后，对任意词组成的的字符串，若串中任意两词间在图中存在一个“桥”，就将该桥插入字符串中。",
      "3.1.4.1",
      "Test GraphPoet",
      "根据题目要求，需要对图的构建、字符串的插入进行测试，分情况需测试空文件、标准文件和多行文件的读入、多种权值比较的情况",
      "3.1.4.2",
      "Implement GraphPoet",
      "思路：读入文件时，按空格将文件内容按单词拆分为字符串数组，并按上述结构存入图中作为点集，并以此将相邻的单词连接，每一次相邻使权重加一。",
      "对字符串进行插入时，检查以当前词指向的点中是否有指向下一个词的点，在所有符合条件的点中将权重和最高的点插入两词之间，按此规则遍历字符串并输出结果",
      "3.1.4.5",
      "使用Eclemma检查测试的代码覆盖度",
      "3.2",
      "Re-implement the Social Network in Lab1",
      "和Lab1中的FriendshipGraph类问题类似，只需将其中方法使用本次饰演的Graph结构实现即可",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "本次实验遇到了时间规划不合理导致任务积压的问题，下次应为实验分配更合理的时间准备",
      "针对以下方面的感受",
      "1.面向",
      "ADT",
      "的编程和直接面向应用场景编程，你体会到二者有何差异？",
      "面向ADT编程时任务更加模块化，更好理清思路，对项目管理也有很大帮助",
      "2.使用泛型和不使用泛型的编程，对你来说有何差异？",
      "使用泛型编程可以增加程序的泛用性，但因为此前用的不多，有些不熟悉，需要时间理解",
      "3.在给出",
      "ADT",
      "的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？",
      "使测试不受程序影响，更具客观准确性，目前还不太适应",
      "4.P1",
      "设计的",
      "ADT",
      "在多个应用场景下使用，这种复用带来什么好处？",
      "提高了工作效率，使代码具备复用性",
      "5.为",
      "ADT",
      "specification, invariants, RI, AF",
      "，时刻注意",
      "ADT",
      "是否有",
      "rep exposure",
      "，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "保证了代码的安全性",
      "6.关于本实验的工作量、、",
      "deadline",
      "适中，很合适",
      "7.《软件构造》课程进展难度到目前，你对该课程有何体会和建议？",
      "这门课程更多偏向于实际应用中的项目管理、软件开发等方面，更贴近实际而不是理论"
    ],
    "sentences": [
      "本次实验初看让人有点摸不着头脑",
      "先根据模板写测试再编程的顺序在之前完全没见过",
      "但熟悉之后发现效率很高",
      "思路也更清晰",
      "nice",
      "实验环境配置",
      "实验过程",
      "3.1 Poetic Walks",
      "3.1.1 Get the code and prepare Git repository",
      "3.1.2 Problem 1: Test",
      "Graph <String>",
      "3.1.3 Problem 2: Implement",
      "Graph <String>",
      "3.1.3.1 Implement",
      "ConcreteEdgesGraph",
      "3.1.3.2 Implement",
      "ConcreteVerticesGraph",
      "3.1.4 Problem 3: Implement generic",
      "Graph<L>",
      "3.1.4.1 Make the implementations generic",
      "3.1.4.2 Implement",
      "Graph.empty()",
      "3.1.5 Problem 4: Poetic walks",
      "3.1.5.1 Test",
      "GraphPoet",
      "3.1.5.2 Implement",
      "GraphPoet",
      "3.1.5.3 Graph poetry slam",
      "3.1.6",
      "Eclemma",
      "检查测试的代码覆盖度",
      "3.1.7 Before you’re done",
      "3.2 Re-implement the Social Network in Lab1",
      "3.2.1",
      "FriendshipGraph",
      "3.2.2",
      "Person",
      "3.2.3",
      "客户端",
      "main()",
      "3.2.4",
      "测试用例",
      "3.2.5",
      "提交至",
      "Git",
      "实验进度记录",
      "实验过程中遇到的困难与解决途径",
      "实验过程中收获的经验、教训、感想",
      "6.1",
      "实验过程中收获的经验和教训",
      "6.2",
      "针对以下方面的感受",
      "1.实验目标概述",
      "本次实验训练抽象数据类型（ADT）的设计、规约、测试",
      "并使用面向对象编程（OOP）技术实现ADT",
      "具体来说：l 针对给定的应用问题",
      "从问题描述中识别所需的ADT；l 设计ADT 规约（pre-condition、post-condition）并评估规约的质量；l 根据ADT 的规约设计测试用例；l ADT的泛型化；l 根据规约设计ADT 的多种不同的实现；针对每种实现",
      "设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）",
      "l 使用OOP 实现ADT",
      "并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；l 测试ADT 的实现并评估测试的覆盖度；l 使用ADT 及其实现",
      "为应用问题开发程序；l 在测试代码中",
      "能够写出testing strategy 并据此设计测试用例",
      "2.实验环境配置",
      "IDEA",
      "中自带覆盖率测试插件，故无需添加",
      "在这里给出你的",
      "GitHub Lab2",
      "仓库的",
      "URL",
      "地址（",
      "Lab2-",
      "学号）",
      "https://github.com/ComputerScienceHIT/HIT-Lab2-1190201517",
      "3.实验过程",
      "3.1",
      "Poetic Walks",
      "题目给出了一个graph接口",
      "要求我们完成两个描述图的类",
      "其中一个以边为主体",
      "一个以点为主体",
      "并按要求实现接口中的各种方法",
      "最后使用完成的图抽象数据类型完成诗歌生成的功能",
      "3.1.1",
      "Get the code and prepare Git repository",
      "通过控制台命令建立本地git仓库",
      "并用clone指令通过给出的url地址下载指定代码包到git仓库中",
      "3.1.2",
      "Problem 1: Test Graph <String>",
      "思路：首先根据接口的功能描述完成测试程序",
      "测试程序应分别测试接口中给出的各个方法",
      "add",
      "：对于点已存在和未存在的情况分别测试，检查输入的点是否在图中",
      "set",
      "：考虑多种情况：边不存在时添加",
      "边已存在时覆盖并返回原权重",
      "权重为0时删除边",
      "权重为负时报错",
      "remove",
      "：点不存在时返回false",
      "点存在时移除该点并返回true",
      "移除后应检查与该点有关的边是否也被移除",
      "vertices",
      "：检查点的添加和移除后是否均能正确返回点集",
      "sources",
      "和targets：检查添加、移除边后能否正确返回源点集和终点集",
      "3.1.3",
      "Problem 2: Implement Graph <L>",
      "3.1.3.1",
      "Implement ConcreteEdgesGraph",
      "建立ConcreteEdgesGraph类和Egde类",
      "Egde类表示边的状态",
      "ConcreteEdgesGraph类实现接口功能",
      "其中各方法功能如下表：Edge：checkRep",
      "检查不变性",
      "getSource",
      "返回起始点",
      "getTarget",
      "返回终止点",
      "getWeight",
      "返回权重",
      "toString",
      "按“起始点-权重>终止点”的格式返回表示该边的字符串",
      "ConcreteEdgesGraph：checkRep",
      "检查不变性",
      "add",
      "向图中添加一个点，点的名称不可重复",
      "set",
      "向图中添加一条边",
      "若边存在则覆盖旧边并返回旧边权重",
      "边不存在则新建并返回0",
      "当输入权重为0时移除该边",
      "权重为负时报错",
      "remove",
      "移除一个点和该点连接的边",
      "成功移除返回true",
      "边不存在返回false",
      "vertices",
      "返回图的所有点构成的集合",
      "sources",
      "返回图中所有作为起始点的点和其边构成的集合",
      "targets",
      "返回图中所有作为终止点的点和其边构成的集合",
      "toString",
      "将图中所有边转化为字符串返回，顺序按照边添加的顺序",
      "3.1.3.2",
      "Implement ConcreteVerticesGraph",
      "建立ConcreteVerticesGraph类和Vertex类",
      "Vertex类表示点及其连接状态",
      "ConcreteVerticesGraph类实现接口功能",
      "其中各方法功能如下表：Vertex：checkRep",
      "检查不变性",
      "getVertex",
      "返回该点名称",
      "getSources",
      "返回指向该点的点集",
      "getTargets",
      "返回该点指向的点集",
      "addSources\\removeSources",
      "添加、删除指向该点的边",
      "addTargets\\removeTargets",
      "添加、删除该点指向的边",
      "toString",
      "按“起始点-权重>终止点”的格式返回表示该边的字符串",
      "ConcreteVerticGraph：checkRep",
      "检查不变性",
      "add",
      "向图中添加一个点，点的名称不可重复",
      "set",
      "向图中添加一条边",
      "若边存在则覆盖旧边并返回旧边权重",
      "边不存在则新建并返回0",
      "当输入权重为0时移除该边",
      "权重为负时报错",
      "remove",
      "移除一个点和该点连接的边",
      "成功移除返回true",
      "边不存在返回false",
      "vertices",
      "返回图的所有点构成的集合",
      "sources",
      "返回图中所有作为起始点的点和其边构成的集合",
      "targets",
      "返回图中所有作为终止点的点和其边构成的集合",
      "toString",
      "将图中所有边转化为字符串返回",
      "顺序按照点添加的顺序",
      "每个点按边添加顺序输出以该点为起始点的边",
      "3.1.4",
      "Problem 4: Poetic walks",
      "本题要求使用上述图结构",
      "用给定的文件为文本集",
      "连接集合中相邻的词",
      "构建这样的图后",
      "对任意词组成的的字符串",
      "若串中任意两词间在图中存在一个“桥”",
      "就将该桥插入字符串中",
      "3.1.4.1",
      "Test GraphPoet",
      "根据题目要求",
      "需要对图的构建、字符串的插入进行测试",
      "分情况需测试空文件、标准文件和多行文件的读入、多种权值比较的情况",
      "3.1.4.2",
      "Implement GraphPoet",
      "思路：读入文件时",
      "按空格将文件内容按单词拆分为字符串数组",
      "并按上述结构存入图中作为点集",
      "并以此将相邻的单词连接",
      "每一次相邻使权重加一",
      "对字符串进行插入时",
      "检查以当前词指向的点中是否有指向下一个词的点",
      "在所有符合条件的点中将权重和最高的点插入两词之间",
      "按此规则遍历字符串并输出结果",
      "3.1.4.5",
      "使用Eclemma检查测试的代码覆盖度",
      "3.2",
      "Re-implement the Social Network in Lab1",
      "和Lab1中的FriendshipGraph类问题类似",
      "只需将其中方法使用本次饰演的Graph结构实现即可",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "本次实验遇到了时间规划不合理导致任务积压的问题",
      "下次应为实验分配更合理的时间准备",
      "针对以下方面的感受",
      "1.面向",
      "ADT",
      "的编程和直接面向应用场景编程，你体会到二者有何差异？",
      "面向ADT编程时任务更加模块化",
      "更好理清思路",
      "对项目管理也有很大帮助",
      "2.使用泛型和不使用泛型的编程，对你来说有何差异？",
      "使用泛型编程可以增加程序的泛用性",
      "但因为此前用的不多",
      "有些不熟悉",
      "需要时间理解",
      "3.在给出",
      "ADT",
      "的规约后就开始编写测试用例",
      "优势是什么？你是否能够适应这种测试方式？",
      "使测试不受程序影响，更具客观准确性，目前还不太适应",
      "4.P1",
      "设计的",
      "ADT",
      "在多个应用场景下使用，这种复用带来什么好处？",
      "提高了工作效率，使代码具备复用性",
      "5.为",
      "ADT",
      "specification, invariants, RI, AF",
      "，时刻注意",
      "ADT",
      "是否有",
      "rep exposure",
      "，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "保证了代码的安全性",
      "6.关于本实验的工作量、、deadline",
      "适中，很合适",
      "7.《软件构造》课程进展难度到目前",
      "你对该课程有何体会和建议？",
      "这门课程更多偏向于实际应用中的项目管理、软件开发等方面",
      "更贴近实际而不是理论"
    ],
    "codes": [],
    "date": "2021-05-06",
    "text": "本次实验初看让人有点摸不着头脑，先根据模板写测试再编程的顺序在之前完全没见过，但熟悉之后发现效率很高，思路也更清晰，nice\n实验环境配置\n实验过程\n3.1 Poetic Walks\n3.1.1 Get the code and prepare Git repository\n3.1.2 Problem 1: Test\nGraph <String>\n3.1.3 Problem 2: Implement\nGraph <String>\n3.1.3.1 Implement\nConcreteEdgesGraph\n3.1.3.2 Implement\nConcreteVerticesGraph\n3.1.4 Problem 3: Implement generic\nGraph<L>\n3.1.4.1 Make the implementations generic\n3.1.4.2 Implement\nGraph.empty()\n3.1.5 Problem 4: Poetic walks\n3.1.5.1 Test\nGraphPoet\n3.1.5.2 Implement\nGraphPoet\n3.1.5.3 Graph poetry slam\n3.1.6\nEclemma\n检查测试的代码覆盖度\n3.1.7 Before you’re done\n3.2 Re-implement the Social Network in Lab1\n3.2.1\nFriendshipGraph\n3.2.2\nPerson\n3.2.3\n客户端\nmain()\n3.2.4\n测试用例\n3.2.5\n提交至\nGit\n实验进度记录\n实验过程中遇到的困难与解决途径\n实验过程中收获的经验、教训、感想\n6.1\n实验过程中收获的经验和教训\n6.2\n针对以下方面的感受\n1.实验目标概述\n本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说：\nl 针对给定的应用问题，从问题描述中识别所需的ADT；\nl 设计ADT 规约（pre-condition、post-condition）并评估规约的质量；\nl 根据ADT 的规约设计测试用例；\nl ADT的泛型化；\nl 根据规约设计ADT 的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）\nl 使用OOP 实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；\nl 测试ADT 的实现并评估测试的覆盖度；\nl 使用ADT 及其实现，为应用问题开发程序；\nl 在测试代码中，能够写出testing strategy 并据此设计测试用例。\n2.实验环境配置\nIDEA\n中自带覆盖率测试插件，故无需添加\n在这里给出你的\nGitHub Lab2\n仓库的\nURL\n地址（\nLab2-\n学号）。\nhttps://github.com/ComputerScienceHIT/HIT-Lab2-1190201517\n3.实验过程\n3.1\nPoetic Walks\n题目给出了一个graph接口，要求我们完成两个描述图的类，其中一个以边为主体，一个以点为主体，并按要求实现接口中的各种方法，最后使用完成的图抽象数据类型完成诗歌生成的功能\n3.1.1\nGet the code and prepare Git repository\n通过控制台命令建立本地git仓库，并用clone指令通过给出的url地址下载指定代码包到git仓库中\n3.1.2\nProblem 1: Test Graph <String>\n思路：首先根据接口的功能描述完成测试程序，测试程序应分别测试接口中给出的各个方法\nadd\n：对于点已存在和未存在的情况分别测试，检查输入的点是否在图中。\nset\n：考虑多种情况：边不存在时添加，边已存在时覆盖并返回原权重，权重为0时删除边，权重为负时报错。\nremove\n：点不存在时返回false，点存在时移除该点并返回true，移除后应检查与该点有关的边是否也被移除\nvertices\n：检查点的添加和移除后是否均能正确返回点集\nsources\n和targets：检查添加、移除边后能否正确返回源点集和终点集\n3.1.3\nProblem 2: Implement Graph <L>\n3.1.3.1\nImplement ConcreteEdgesGraph\n建立ConcreteEdgesGraph类和Egde类，Egde类表示边的状态，ConcreteEdgesGraph类实现接口功能，其中各方法功能如下表：\nEdge：\ncheckRep\n检查不变性\ngetSource\n返回起始点\ngetTarget\n返回终止点\ngetWeight\n返回权重\ntoString\n按“起始点-权重>终止点”的格式返回表示该边的字符串\nConcreteEdgesGraph：\ncheckRep\n检查不变性\nadd\n向图中添加一个点，点的名称不可重复\nset\n向图中添加一条边，若边存在则覆盖旧边并返回旧边权重，边不存在则新建并返回0，当输入权重为0时移除该边，权重为负时报错\nremove\n移除一个点和该点连接的边，成功移除返回true，边不存在返回false\nvertices\n返回图的所有点构成的集合\nsources\n返回图中所有作为起始点的点和其边构成的集合\ntargets\n返回图中所有作为终止点的点和其边构成的集合\ntoString\n将图中所有边转化为字符串返回，顺序按照边添加的顺序\n3.1.3.2\nImplement ConcreteVerticesGraph\n建立ConcreteVerticesGraph类和Vertex类，Vertex类表示点及其连接状态，ConcreteVerticesGraph类实现接口功能，其中各方法功能如下表：\nVertex：\ncheckRep\n检查不变性\ngetVertex\n返回该点名称\ngetSources\n返回指向该点的点集\ngetTargets\n返回该点指向的点集\naddSources\\removeSources\n添加、删除指向该点的边\naddTargets\\removeTargets\n添加、删除该点指向的边\ntoString\n按“起始点-权重>终止点”的格式返回表示该边的字符串\nConcreteVerticGraph：\ncheckRep\n检查不变性\nadd\n向图中添加一个点，点的名称不可重复\nset\n向图中添加一条边，若边存在则覆盖旧边并返回旧边权重，边不存在则新建并返回0，当输入权重为0时移除该边，权重为负时报错\nremove\n移除一个点和该点连接的边，成功移除返回true，边不存在返回false\nvertices\n返回图的所有点构成的集合\nsources\n返回图中所有作为起始点的点和其边构成的集合\ntargets\n返回图中所有作为终止点的点和其边构成的集合\ntoString\n将图中所有边转化为字符串返回，顺序按照点添加的顺序，每个点按边添加顺序输出以该点为起始点的边\n3.1.4\nProblem 4: Poetic walks\n本题要求使用上述图结构，用给定的文件为文本集，连接集合中相邻的词，构建这样的图后，对任意词组成的的字符串，若串中任意两词间在图中存在一个“桥”，就将该桥插入字符串中。\n3.1.4.1\nTest GraphPoet\n根据题目要求，需要对图的构建、字符串的插入进行测试，分情况需测试空文件、标准文件和多行文件的读入、多种权值比较的情况\n3.1.4.2\nImplement GraphPoet\n思路：读入文件时，按空格将文件内容按单词拆分为字符串数组，并按上述结构存入图中作为点集，并以此将相邻的单词连接，每一次相邻使权重加一。\n对字符串进行插入时，检查以当前词指向的点中是否有指向下一个词的点，在所有符合条件的点中将权重和最高的点插入两词之间，按此规则遍历字符串并输出结果\n3.1.4.5\n使用Eclemma检查测试的代码覆盖度\n3.2\nRe-implement the Social Network in Lab1\n和Lab1中的FriendshipGraph类问题类似，只需将其中方法使用本次饰演的Graph结构实现即可\n实验过程中收获的经验、教训、感想\n实验过程中收获的经验和教训\n本次实验遇到了时间规划不合理导致任务积压的问题，下次应为实验分配更合理的时间准备\n针对以下方面的感受\n1.面向\nADT\n的编程和直接面向应用场景编程，你体会到二者有何差异？\n面向ADT编程时任务更加模块化，更好理清思路，对项目管理也有很大帮助\n2.使用泛型和不使用泛型的编程，对你来说有何差异？\n使用泛型编程可以增加程序的泛用性，但因为此前用的不多，有些不熟悉，需要时间理解\n3.在给出\nADT\n的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？\n使测试不受程序影响，更具客观准确性，目前还不太适应\n4.P1\n设计的\nADT\n在多个应用场景下使用，这种复用带来什么好处？\n提高了工作效率，使代码具备复用性\n5.为\nADT\nspecification, invariants, RI, AF\n，时刻注意\nADT\n是否有\nrep exposure\n，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？\n保证了代码的安全性\n6.关于本实验的工作量、、\ndeadline\n适中，很合适\n7.《软件构造》课程进展难度到目前，你对该课程有何体会和建议？\n这门课程更多偏向于实际应用中的项目管理、软件开发等方面，更贴近实际而不是理论\n"
  },
  {
    "head": "HIT软件构造Lab1记录",
    "paragraphs": [
      "实验环境配置",
      "实验过程",
      "3.1 Magic Squares",
      "3.1.1",
      "isLegalMagicSquare()",
      "3.1.2",
      "generateMagicSquare()",
      "3.2 Turtle Graphics",
      "3.2.1 Problem 1: Clone and import",
      "3.2.2 Problem 3: Turtle graphics and",
      "drawSquare",
      "3.2.3 Problem 5: Drawing polygons",
      "3.2.4 Problem 6: Calculating Bearings",
      "3.2.5 Problem 7: Convex Hulls",
      "3.2.6 Problem 8: Personal art",
      "3.2.7 Submitting",
      "3.3 Social Network",
      "3.3.1",
      "FriendshipGraph",
      "3.3.2",
      "Person",
      "3.3.3",
      "实现客户端代码",
      "main()",
      "3.3.4",
      "实现测试用例",
      "实验进度记录",
      "实验过程中遇到的困难与解决途径",
      "实验过程中收获的经验、教训、感想",
      "6.1",
      "实验过程中收获的经验和教训",
      "6.2",
      "针对以下方面的感受",
      "实验目标概述",
      "本次实验通过求解三个问题，训练基本 Java 编程技能，能够利用 Java OO 开",
      "发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够",
      "为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。",
      "另一方面，利用 Git 作为代码配置管理的工具，学会 Git 的基本使用方法。",
      "基本的 Java OO 编程",
      "基于 Eclipse IDE 进行 Java 编程",
      "基于 JUnit 的测试",
      "基于 Git 的代码配置管理",
      "实验环境配置",
      "本实验使用了IDEA而不是pdf中给出的eclipse作为ide，不过还是通过pdf中给出的链接安装了eclipse，不过没有使用，在git官网下载了git，并在IDEA中下载了git和Junit插件，安装过程中并未出现困难",
      "GitHub Lab1",
      "仓库的",
      "URL",
      "地址：",
      "https://github.com/ComputerScienceHIT/HIT-Lab1-1190201517",
      "实验过程",
      "请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。",
      "为了条理清晰，可根据需要在各节增加三级标题。",
      "Magic Squares",
      "幻方：对一个行列数相等的矩阵，若其每一行之和、每一列之和以及对角线之和都相等，则其为一个幻方（Magic Square）",
      "要求一：",
      "设计一个程序来判断五个文件中的矩阵是否为MagicSquare，其中文件保存的矩阵需以\\t分割每个数字。若是返回true，若不是或文件有错误则输出false并输出错误原因。",
      "要求二：",
      "设计一个函数来生成一个给定大小的MagicSquare，并存入到文件6.txt中，并用要求一中的和函数判断其是否为符合定义的MagicSquare。",
      "isLegalMagicSquare()",
      "对于读入的文件，构建二维数组存储其中的数字，读入过程中即可检查其行列是否相等、是否均为正整数，是否由\\t分割等，若不符合定义则弹出报错终止程序。因为使用",
      "Integer.valueOf存入数组，在读取到空格时会报错，以此检验数字是否由\\t分割",
      "读入完毕后，对于得到的二维数组，计算其各行、列以及两对角线之和并依次比较，一旦发现不相等就跳出循环并返回false，若最终没有发现不相等，则返回true。",
      "generateMagicSquare()",
      "生成magicsquare的函数已经在手册中给出，因此我们只需检查输入的n是否合法（正奇数），不合法是终止函数返回false，合法时生成、写入文件并返回true。之后在用要求一的函数检验生成的文件即可。",
      "Turtle Graphics",
      "根据要求，我们要按照注释补全给定程序中缺失的特定功能的函数，来实现一个绘图工具，其能够实现绘制正多边形、计算正多边形内角、计算偏角等功能。",
      "Problem 1: Clone and import",
      "从给定链接下载P2的文件包并导入项目中。",
      "Problem 3: Turtle graphics and drawSquare、",
      "通过已经给出的转向和前进指令来绘制正方形",
      "Problem 5: Drawing polygons",
      "绘制指定边数和边长的正多边形",
      "Problem 6: Calculating Bearings",
      "通过给定朝向和点集，计算改变朝向的偏角值集",
      "Problem 7: Convex Hulls",
      "利用BFS算法计算给定点集的凸包",
      "Problem 8: Personal art",
      "Submitting",
      "通过IDEA的git插件，输入url提交至自己的github仓库中",
      "Social Network",
      "通过Person和FriendshipGraph两个类，用FriendshipGraph模拟Person对象间的社交关系，实现对社交网络的模拟，并实现计算两个Person之间的最短社交距离的功能。",
      "设计/实现FriendshipGraph类",
      "存储网络中的person以及person的全部name",
      "加入新用户时，检测是否有重名，若重名终止程序",
      "通过person类中的操作实现addEdge",
      "使用有向图的BFS算法计算两点的最短距离。",
      "主函数部分实现了手册中给出的代码",
      "运行结果：",
      "设计/实现Person类",
      "Person类代码如下",
      "Person类包含了用户姓名以及人际关系，通过List保存每个对象的朋友以表现朋友关系，因此通过向List中添加元素实现addFriend的功能。",
      "设计/实现客户端代码main()",
      "设计/实现测试用例",
      "通过三个测试用例，检验程序的添加用户、添加用户关系、计算最短距离三个功能",
      "实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。",
      "不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。",
      "时间段",
      "实际完成情况",
      "2021-05-11",
      "13:45-15:30",
      "大致学习实验内容，编写问题",
      "isLegalMagicSquare",
      "按计划完成",
      "2021-05-20",
      "完成P1及P2全部内容",
      "超过凌晨几小时",
      "2021-05-23",
      "完成剩余内容并整理学习到内容",
      "实验过程中遇到的困难与解决途径",
      "遇到的困难",
      "解决途径",
      "对java掌握不熟练，很多方法、函数需要查阅资料，浪费了很多时间",
      "努力学习java，掌握基本代码方式",
      "对github不太了解，不清楚仓库、clone等功能是如何运作的",
      "查阅各种资料，实践理解功能",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "大概了解了java的代码、项目管理、git的版本控制、以及github的共享体系",
      "针对以下方面的感受",
      "Java",
      "编程语言是否对你的口味？",
      "还可以，有时不够直观，但整体上功能更多，比c更灵活",
      "Eclipse IDE",
      "没有使用，习惯使用IDEA，今后会补充这方面的不足",
      "Git",
      "GitHub",
      "用得不太好，但也还行",
      "CMU",
      "MIT",
      "的作业；",
      "很有创意，给我提供了很多思路",
      "关于本实验的工作量、难度、",
      "deadline",
      "难度很适合作为第一次实验",
      "关于初接触“软件构造”课程；",
      "有很多不习惯的地方，但是一一克服后感觉收获颇丰"
    ],
    "sentences": [
      "实验环境配置",
      "实验过程",
      "3.1 Magic Squares",
      "3.1.1",
      "isLegalMagicSquare()",
      "3.1.2",
      "generateMagicSquare()",
      "3.2 Turtle Graphics",
      "3.2.1 Problem 1: Clone and import",
      "3.2.2 Problem 3: Turtle graphics and",
      "drawSquare",
      "3.2.3 Problem 5: Drawing polygons",
      "3.2.4 Problem 6: Calculating Bearings",
      "3.2.5 Problem 7: Convex Hulls",
      "3.2.6 Problem 8: Personal art",
      "3.2.7 Submitting",
      "3.3 Social Network",
      "3.3.1",
      "FriendshipGraph",
      "3.3.2",
      "Person",
      "3.3.3",
      "实现客户端代码",
      "main()",
      "3.3.4",
      "实现测试用例",
      "实验进度记录",
      "实验过程中遇到的困难与解决途径",
      "实验过程中收获的经验、教训、感想",
      "6.1",
      "实验过程中收获的经验和教训",
      "6.2",
      "针对以下方面的感受",
      "实验目标概述",
      "本次实验通过求解三个问题",
      "训练基本 Java 编程技能",
      "能够利用 Java OO 开",
      "发基本的功能模块",
      "能够阅读理解已有代码框架并根据功能需求补全代码",
      "能够",
      "为所开发的代码编写基本的测试程序并完成测试",
      "初步保证所开发代码的正确性",
      "另一方面",
      "利用 Git 作为代码配置管理的工具",
      "学会 Git 的基本使用方法",
      "基本的 Java OO 编程",
      "基于 Eclipse IDE 进行 Java 编程",
      "基于 JUnit 的测试",
      "基于 Git 的代码配置管理",
      "实验环境配置",
      "本实验使用了IDEA而不是pdf中给出的eclipse作为ide",
      "不过还是通过pdf中给出的链接安装了eclipse",
      "不过没有使用",
      "在git官网下载了git",
      "并在IDEA中下载了git和Junit插件",
      "安装过程中并未出现困难",
      "GitHub Lab1",
      "仓库的",
      "URL",
      "地址：https://github.com/ComputerScienceHIT/HIT-Lab1-1190201517",
      "实验过程",
      "请仔细对照实验手册",
      "针对四个问题中的每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）",
      "为了条理清晰，可根据需要在各节增加三级标题",
      "Magic Squares",
      "幻方：对一个行列数相等的矩阵",
      "若其每一行之和、每一列之和以及对角线之和都相等",
      "则其为一个幻方（Magic Square）",
      "要求一：设计一个程序来判断五个文件中的矩阵是否为MagicSquare",
      "其中文件保存的矩阵需以\\t分割每个数字",
      "若是返回true",
      "若不是或文件有错误则输出false并输出错误原因",
      "要求二：设计一个函数来生成一个给定大小的MagicSquare",
      "并存入到文件6.txt中",
      "并用要求一中的和函数判断其是否为符合定义的MagicSquare",
      "isLegalMagicSquare()",
      "对于读入的文件",
      "构建二维数组存储其中的数字",
      "读入过程中即可检查其行列是否相等、是否均为正整数",
      "是否由\\t分割等",
      "若不符合定义则弹出报错终止程序",
      "因为使用",
      "Integer.valueOf存入数组",
      "在读取到空格时会报错",
      "以此检验数字是否由\\t分割",
      "读入完毕后",
      "对于得到的二维数组",
      "计算其各行、列以及两对角线之和并依次比较",
      "一旦发现不相等就跳出循环并返回false",
      "若最终没有发现不相等",
      "则返回true",
      "generateMagicSquare()",
      "生成magicsquare的函数已经在手册中给出",
      "因此我们只需检查输入的n是否合法（正奇数）",
      "不合法是终止函数返回false",
      "合法时生成、写入文件并返回true",
      "之后在用要求一的函数检验生成的文件即可",
      "Turtle Graphics",
      "根据要求",
      "我们要按照注释补全给定程序中缺失的特定功能的函数",
      "来实现一个绘图工具",
      "其能够实现绘制正多边形、计算正多边形内角、计算偏角等功能",
      "Problem 1: Clone and import",
      "从给定链接下载P2的文件包并导入项目中",
      "Problem 3: Turtle graphics and drawSquare、通过已经给出的转向和前进指令来绘制正方形",
      "Problem 5: Drawing polygons",
      "绘制指定边数和边长的正多边形",
      "Problem 6: Calculating Bearings",
      "通过给定朝向和点集，计算改变朝向的偏角值集",
      "Problem 7: Convex Hulls",
      "利用BFS算法计算给定点集的凸包",
      "Problem 8: Personal art",
      "Submitting",
      "通过IDEA的git插件",
      "输入url提交至自己的github仓库中",
      "Social Network",
      "通过Person和FriendshipGraph两个类",
      "用FriendshipGraph模拟Person对象间的社交关系",
      "实现对社交网络的模拟",
      "并实现计算两个Person之间的最短社交距离的功能",
      "设计/实现FriendshipGraph类",
      "存储网络中的person以及person的全部name",
      "加入新用户时，检测是否有重名，若重名终止程序",
      "通过person类中的操作实现addEdge",
      "使用有向图的BFS算法计算两点的最短距离",
      "主函数部分实现了手册中给出的代码",
      "运行结果：设计/实现Person类",
      "Person类代码如下",
      "Person类包含了用户姓名以及人际关系",
      "通过List保存每个对象的朋友以表现朋友关系",
      "因此通过向List中添加元素实现addFriend的功能",
      "设计/实现客户端代码main()",
      "设计/实现测试用例",
      "通过三个测试用例",
      "检验程序的添加用户、添加用户关系、计算最短距离三个功能",
      "实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "每次结束编程时，请向该表格中增加一行",
      "不要事后胡乱填写",
      "不要嫌烦",
      "该表格可帮助你汇总你在每个任务上付出的时间和精力",
      "发现自己不擅长的任务",
      "后续有意识的弥补",
      "时间段",
      "实际完成情况",
      "2021-05-11",
      "13:45-15:30",
      "大致学习实验内容，编写问题",
      "isLegalMagicSquare",
      "按计划完成",
      "2021-05-20",
      "完成P1及P2全部内容",
      "超过凌晨几小时",
      "2021-05-23",
      "完成剩余内容并整理学习到内容",
      "实验过程中遇到的困难与解决途径",
      "遇到的困难",
      "解决途径",
      "对java掌握不熟练",
      "很多方法、函数需要查阅资料",
      "浪费了很多时间",
      "努力学习java，掌握基本代码方式",
      "对github不太了解",
      "不清楚仓库、clone等功能是如何运作的",
      "查阅各种资料，实践理解功能",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "大概了解了java的代码、项目管理、git的版本控制、以及github的共享体系",
      "针对以下方面的感受",
      "Java",
      "编程语言是否对你的口味？",
      "还可以，有时不够直观，但整体上功能更多，比c更灵活",
      "Eclipse IDE",
      "没有使用，习惯使用IDEA，今后会补充这方面的不足",
      "Git",
      "GitHub",
      "用得不太好，但也还行",
      "CMU",
      "MIT",
      "的作业；很有创意，给我提供了很多思路",
      "关于本实验的工作量、难度、deadline",
      "难度很适合作为第一次实验",
      "关于初接触“软件构造”课程；有很多不习惯的地方",
      "但是一一克服后感觉收获颇丰"
    ],
    "codes": [],
    "date": "2021-06-23",
    "text": "实验环境配置\n实验过程\n3.1 Magic Squares\n3.1.1\nisLegalMagicSquare()\n3.1.2\ngenerateMagicSquare()\n3.2 Turtle Graphics\n3.2.1 Problem 1: Clone and import\n3.2.2 Problem 3: Turtle graphics and\ndrawSquare\n3.2.3 Problem 5: Drawing polygons\n3.2.4 Problem 6: Calculating Bearings\n3.2.5 Problem 7: Convex Hulls\n3.2.6 Problem 8: Personal art\n3.2.7 Submitting\n3.3 Social Network\n3.3.1\nFriendshipGraph\n3.3.2\nPerson\n3.3.3\n实现客户端代码\nmain()\n3.3.4\n实现测试用例\n实验进度记录\n实验过程中遇到的困难与解决途径\n实验过程中收获的经验、教训、感想\n6.1\n实验过程中收获的经验和教训\n6.2\n针对以下方面的感受\n实验目标概述\n本次实验通过求解三个问题，训练基本 Java 编程技能，能够利用 Java OO 开\n发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够\n为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。\n另一方面，利用 Git 作为代码配置管理的工具，学会 Git 的基本使用方法。\n基本的 Java OO 编程\n基于 Eclipse IDE 进行 Java 编程\n基于 JUnit 的测试\n基于 Git 的代码配置管理\n实验环境配置\n本实验使用了IDEA而不是pdf中给出的eclipse作为ide，不过还是通过pdf中给出的链接安装了eclipse，不过没有使用，在git官网下载了git，并在IDEA中下载了git和Junit插件，安装过程中并未出现困难\nGitHub Lab1\n仓库的\nURL\n地址：\nhttps://github.com/ComputerScienceHIT/HIT-Lab1-1190201517\n实验过程\n请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。\n为了条理清晰，可根据需要在各节增加三级标题。\nMagic Squares\n幻方：对一个行列数相等的矩阵，若其每一行之和、每一列之和以及对角线之和都相等，则其为一个幻方（Magic Square）\n要求一：\n设计一个程序来判断五个文件中的矩阵是否为MagicSquare，其中文件保存的矩阵需以\\t分割每个数字。若是返回true，若不是或文件有错误则输出false并输出错误原因。\n要求二：\n设计一个函数来生成一个给定大小的MagicSquare，并存入到文件6.txt中，并用要求一中的和函数判断其是否为符合定义的MagicSquare。\nisLegalMagicSquare()\n对于读入的文件，构建二维数组存储其中的数字，读入过程中即可检查其行列是否相等、是否均为正整数，是否由\\t分割等，若不符合定义则弹出报错终止程序。因为使用\nInteger.valueOf存入数组，在读取到空格时会报错，以此检验数字是否由\\t分割\n读入完毕后，对于得到的二维数组，计算其各行、列以及两对角线之和并依次比较，一旦发现不相等就跳出循环并返回false，若最终没有发现不相等，则返回true。\ngenerateMagicSquare()\n生成magicsquare的函数已经在手册中给出，因此我们只需检查输入的n是否合法（正奇数），不合法是终止函数返回false，合法时生成、写入文件并返回true。之后在用要求一的函数检验生成的文件即可。\nTurtle Graphics\n根据要求，我们要按照注释补全给定程序中缺失的特定功能的函数，来实现一个绘图工具，其能够实现绘制正多边形、计算正多边形内角、计算偏角等功能。\nProblem 1: Clone and import\n从给定链接下载P2的文件包并导入项目中。\nProblem 3: Turtle graphics and drawSquare、\n通过已经给出的转向和前进指令来绘制正方形\nProblem 5: Drawing polygons\n绘制指定边数和边长的正多边形\nProblem 6: Calculating Bearings\n通过给定朝向和点集，计算改变朝向的偏角值集\nProblem 7: Convex Hulls\n利用BFS算法计算给定点集的凸包\nProblem 8: Personal art\nSubmitting\n通过IDEA的git插件，输入url提交至自己的github仓库中\nSocial Network\n通过Person和FriendshipGraph两个类，用FriendshipGraph模拟Person对象间的社交关系，实现对社交网络的模拟，并实现计算两个Person之间的最短社交距离的功能。\n设计/实现FriendshipGraph类\n存储网络中的person以及person的全部name\n加入新用户时，检测是否有重名，若重名终止程序\n通过person类中的操作实现addEdge\n使用有向图的BFS算法计算两点的最短距离。\n主函数部分实现了手册中给出的代码\n运行结果：\n设计/实现Person类\nPerson类代码如下\nPerson类包含了用户姓名以及人际关系，通过List保存每个对象的朋友以表现朋友关系，因此通过向List中添加元素实现addFriend的功能。\n设计/实现客户端代码main()\n设计/实现测试用例\n通过三个测试用例，检验程序的添加用户、添加用户关系、计算最短距离三个功能\n实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。\n不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。\n时间段\n实际完成情况\n2021-05-11\n13:45-15:30\n大致学习实验内容，编写问题\nisLegalMagicSquare\n按计划完成\n2021-05-20\n完成P1及P2全部内容\n超过凌晨几小时\n2021-05-23\n完成剩余内容并整理学习到内容\n实验过程中遇到的困难与解决途径\n遇到的困难\n解决途径\n对java掌握不熟练，很多方法、函数需要查阅资料，浪费了很多时间\n努力学习java，掌握基本代码方式\n对github不太了解，不清楚仓库、clone等功能是如何运作的\n查阅各种资料，实践理解功能\n实验过程中收获的经验、教训、感想\n实验过程中收获的经验和教训\n大概了解了java的代码、项目管理、git的版本控制、以及github的共享体系\n针对以下方面的感受\nJava\n编程语言是否对你的口味？\n还可以，有时不够直观，但整体上功能更多，比c更灵活\nEclipse IDE\n没有使用，习惯使用IDEA，今后会补充这方面的不足\nGit\nGitHub\n用得不太好，但也还行\nCMU\nMIT\n的作业；\n很有创意，给我提供了很多思路\n关于本实验的工作量、难度、\ndeadline\n难度很适合作为第一次实验\n关于初接触“软件构造”课程；\n有很多不习惯的地方，但是一一克服后感觉收获颇丰\n"
  },
  {
    "head": "软件构造学习笔记——软件构造的多维度视图",
    "paragraphs": [
      "Build-time:软件的构造阶段。",
      "Code-level:代码的逻辑组织。源代码如何被方法、函数、类和接口等底层模块组织起来，以及其中代码之间的依赖关系。",
      "Component-level：代码的物理组织。代码块之间的关系，如文件、包等。",
      "Moment view:特定时刻的软件形态。",
      "Period view:软件形态随时间的变化。",
      "(1) Build-time, moment, and code-level view",
      "词汇层面：Lexical-oriented source code",
      "半结构化：近乎自然语言的 风格+遵循特定的编程语法",
      "语法层面：Syntax-oriented program structure: e.g., Abstract Syntax Tree (AST)",
      "AST：彻底结构化，将 源代码变为一棵树， 对树做各种操作=对源代码的修改",
      "语义层面：Semantics-oriented program structure: e.g., Class Diagram",
      "语义：源代码具体 想实现什么目标？ 源代码—>现实世界",
      "用于表达“需求” 和“设计”思想， 再转化成code",
      "通常是图形化或形式化的",
      "(2) Build-time, period, and code-level view",
      "Code churn 代码变化: Lines added, modified or deleted to a file from one version to another",
      "(3) Build-time, moment, and component-level view",
      "关注库（这里指静态链接库）和包，库有这几种来源：操作系统提供的库、编程语言提供的库、第三方公司提供的库以及自己积累的库。",
      "开发者像使用编程语言指令一样使用库中的功能",
      "操作系统提供的库",
      "编程语言提供的库第三方公司提供的库",
      "你自己积累的库",
      "(4) Build-time, period, and component-level view",
      "各项软件实体随时间如何变化",
      "Version Control System (VCS)",
      "(5) Run-time, moment, and code-level view",
      "代码快照图：描述程序运行时内存 里变量层面的状态",
      "(6) Run-time, period and code-level view",
      "用日志方式记录程序执行的调用次序",
      "(7) Run-time, moment, and component-level view",
      "Deployment diagram in UML",
      "(8) Run-time, period, and component-level view",
      "事件日志：系统层面"
    ],
    "sentences": [
      "Build-time:软件的构造阶段",
      "Code-level:代码的逻辑组织",
      "源代码如何被方法、函数、类和接口等底层模块组织起来",
      "以及其中代码之间的依赖关系",
      "Component-level：代码的物理组织",
      "代码块之间的关系，如文件、包等",
      "Moment view:特定时刻的软件形态",
      "Period view:软件形态随时间的变化",
      "(1) Build-time, moment, and code-level view",
      "词汇层面：Lexical-oriented source code",
      "半结构化：近乎自然语言的 风格+遵循特定的编程语法",
      "语法层面：Syntax-oriented program structure: e.g., Abstract Syntax Tree (AST)",
      "AST：彻底结构化",
      "将 源代码变为一棵树",
      " 对树做各种操作=对源代码的修改",
      "语义层面：Semantics-oriented program structure: e.g., Class Diagram",
      "语义：源代码具体 想实现什么目标？ 源代码—>现实世界",
      "用于表达“需求” 和“设计”思想， 再转化成code",
      "通常是图形化或形式化的",
      "(2) Build-time, period, and code-level view",
      "Code churn 代码变化: Lines added, modified or deleted to a file from one version to another",
      "(3) Build-time, moment, and component-level view",
      "关注库（这里指静态链接库）和包",
      "库有这几种来源：操作系统提供的库、编程语言提供的库、第三方公司提供的库以及自己积累的库",
      "开发者像使用编程语言指令一样使用库中的功能",
      "操作系统提供的库",
      "编程语言提供的库第三方公司提供的库",
      "你自己积累的库",
      "(4) Build-time, period, and component-level view",
      "各项软件实体随时间如何变化",
      "Version Control System (VCS)",
      "(5) Run-time, moment, and code-level view",
      "代码快照图：描述程序运行时内存 里变量层面的状态",
      "(6) Run-time, period and code-level view",
      "用日志方式记录程序执行的调用次序",
      "(7) Run-time, moment, and component-level view",
      "Deployment diagram in UML",
      "(8) Run-time, period, and component-level view",
      "事件日志：系统层面"
    ],
    "codes": [],
    "date": "2021-07-05",
    "text": "Build-time:软件的构造阶段。\nCode-level:代码的逻辑组织。源代码如何被方法、函数、类和接口等底层模块组织起来，以及其中代码之间的依赖关系。\nComponent-level：代码的物理组织。代码块之间的关系，如文件、包等。\nMoment view:特定时刻的软件形态。\nPeriod view:软件形态随时间的变化。\n(1) Build-time, moment, and code-level view\n词汇层面：Lexical-oriented source code\n半结构化：近乎自然语言的 风格+遵循特定的编程语法\n语法层面：Syntax-oriented program structure: e.g., Abstract Syntax Tree (AST)\nAST：彻底结构化，将 源代码变为一棵树， 对树做各种操作=对源代码的修改\n语义层面：Semantics-oriented program structure: e.g., Class Diagram\n语义：源代码具体 想实现什么目标？ 源代码—>现实世界\n用于表达“需求” 和“设计”思想， 再转化成code\n通常是图形化或形式化的\n(2) Build-time, period, and code-level view\nCode churn 代码变化: Lines added, modified or deleted to a file from one version to another\n(3) Build-time, moment, and component-level view\n关注库（这里指静态链接库）和包，库有这几种来源：操作系统提供的库、编程语言提供的库、第三方公司提供的库以及自己积累的库。\n开发者像使用编程语言指令一样使用库中的功能\n操作系统提供的库\n编程语言提供的库第三方公司提供的库\n你自己积累的库\n(4) Build-time, period, and component-level view\n各项软件实体随时间如何变化\nVersion Control System (VCS)\n(5) Run-time, moment, and code-level view\n代码快照图：描述程序运行时内存 里变量层面的状态\n(6) Run-time, period and code-level view\n用日志方式记录程序执行的调用次序\n(7) Run-time, moment, and component-level view\nDeployment diagram in UML\n(8) Run-time, period, and component-level view\n事件日志：系统层面\n"
  },
  {
    "head": "Faster Than Light",
    "paragraphs": [
      "超越光速",
      "你是否向往过过星爵那紧张刺激的星际之旅？",
      "游戏简介那么现在你有这样一个机会了！驾驶自己的飞船，装配武器，召集船员，升级科技，击败星际舰队。游戏可解锁20+艘不同的飞船，可玩性极高。想来一场迷你却精致的太空冒险？《超越光速》，你值得拥有！",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: rr3h"
    ],
    "sentences": [
      "超越光速",
      "你是否向往过过星爵那紧张刺激的星际之旅？",
      "游戏简介那么现在你有这样一个机会了！驾驶自己的飞船",
      "装配武器",
      "召集船员",
      "升级科技",
      "击败星际舰队",
      "游戏可解锁20+艘不同的飞船，可玩性极高",
      "想来一场迷你却精致的太空冒险？《超越光速》，你值得拥有！",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: rr3h"
    ],
    "codes": [],
    "date": "2018-04-07",
    "text": "超越光速\n你是否向往过过星爵那紧张刺激的星际之旅？\n游戏简介那么现在你有这样一个机会了！驾驶自己的飞船，装配武器，召集船员，升级科技，击败星际舰队。游戏可解锁20+艘不同的飞船，可玩性极高。想来一场迷你却精致的太空冒险？《超越光速》，你值得拥有！\n游戏截图\n下载方式[百度网盘 for Windows]密码: rr3h\n"
  },
  {
    "head": "Risk of Rain",
    "paragraphs": [
      "雨中冒险",
      "孤独者的冒险",
      "游戏简介由于飞船失事，玩家降落在一个陌生的星球上；为了生存，玩家必须与当地生物进行搏斗；生存竞争，适者生存。 游戏的背景设置为远山、星空、海洋、黑夜、云海；偌大的屏幕中央，由几个像素组成的玩家不紧不慢的行进；加上略有动感又略显复古的配乐，将孤独浪人的气氛渲染的恰到好处。 我想这或许就是孤独体现的最好方式：一个人，做一件事，直到地老天荒。 或许才接触到这款游戏的时候，它并不会给你留下深刻的印象；但经过几场游玩后，它一定能让你为之痴迷。",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: yhvc"
    ],
    "sentences": [
      "雨中冒险",
      "孤独者的冒险",
      "游戏简介由于飞船失事",
      "玩家降落在一个陌生的星球上；为了生存",
      "玩家必须与当地生物进行搏斗；生存竞争",
      "适者生存",
      " 游戏的背景设置为远山、星空、海洋、黑夜、云海；偌大的屏幕中央",
      "由几个像素组成的玩家不紧不慢的行进；加上略有动感又略显复古的配乐",
      "将孤独浪人的气氛渲染的恰到好处",
      " 我想这或许就是孤独体现的最好方式：一个人",
      "做一件事",
      "直到地老天荒",
      " 或许才接触到这款游戏的时候",
      "它并不会给你留下深刻的印象；但经过几场游玩后",
      "它一定能让你为之痴迷",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: yhvc"
    ],
    "codes": [],
    "date": "2018-04-04",
    "text": "雨中冒险\n孤独者的冒险\n游戏简介由于飞船失事，玩家降落在一个陌生的星球上；为了生存，玩家必须与当地生物进行搏斗；生存竞争，适者生存。 游戏的背景设置为远山、星空、海洋、黑夜、云海；偌大的屏幕中央，由几个像素组成的玩家不紧不慢的行进；加上略有动感又略显复古的配乐，将孤独浪人的气氛渲染的恰到好处。 我想这或许就是孤独体现的最好方式：一个人，做一件事，直到地老天荒。 或许才接触到这款游戏的时候，它并不会给你留下深刻的印象；但经过几场游玩后，它一定能让你为之痴迷。\n游戏截图\n下载方式[百度网盘 for Windows]密码: yhvc\n"
  },
  {
    "head": "Ronin",
    "paragraphs": [
      "“复仇这盘菜，凉了最好吃。” ——唐·柯里昂",
      "游戏简介《浪人》讲述的是小女孩年幼时父亲便被杀害，长大后为父亲报仇的故事。 浪人的画面采用美式漫画风格，线条明朗，动作流畅，打击感强。配乐紧张，富有节奏，很容易将玩家带入到那个血雨腥风的仇杀之路。游戏拥有独特的操作机制，将动作游戏与回合制大胆结合，创造出新颖的游戏玩法，是前所未有的游戏体验。",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: 5q36"
    ],
    "sentences": [
      "“复仇这盘菜，凉了最好吃",
      "” ——唐·柯里昂",
      "游戏简介《浪人》讲述的是小女孩年幼时父亲便被杀害",
      "长大后为父亲报仇的故事",
      " 浪人的画面采用美式漫画风格，线条明朗，动作流畅，打击感强",
      "配乐紧张，富有节奏，很容易将玩家带入到那个血雨腥风的仇杀之路",
      "游戏拥有独特的操作机制",
      "将动作游戏与回合制大胆结合",
      "创造出新颖的游戏玩法",
      "是前所未有的游戏体验",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: 5q36"
    ],
    "codes": [],
    "date": "2018-04-04",
    "text": "“复仇这盘菜，凉了最好吃。” ——唐·柯里昂\n游戏简介《浪人》讲述的是小女孩年幼时父亲便被杀害，长大后为父亲报仇的故事。 浪人的画面采用美式漫画风格，线条明朗，动作流畅，打击感强。配乐紧张，富有节奏，很容易将玩家带入到那个血雨腥风的仇杀之路。游戏拥有独特的操作机制，将动作游戏与回合制大胆结合，创造出新颖的游戏玩法，是前所未有的游戏体验。\n游戏截图\n下载方式[百度网盘 for Windows]密码: 5q36\n"
  },
  {
    "head": "Dead Cells",
    "paragraphs": [
      "死亡细胞",
      "”生存还是死亡？这是一个问题” ——莎士比亚",
      "游戏简介《死亡细胞》一经上架，便被誉为2D版《黑魂》。游戏难度高，人物动作流畅，打击感极强。如果你是一个动作游戏的爱好者，并且想找个机会好好爽一番，那么《死亡细胞》绝对是你的不二之选。",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: hmmj"
    ],
    "sentences": [
      "死亡细胞",
      "”生存还是死亡？这是一个问题” ——莎士比亚",
      "游戏简介《死亡细胞》一经上架，便被誉为2D版《黑魂》",
      "游戏难度高，人物动作流畅，打击感极强",
      "如果你是一个动作游戏的爱好者",
      "并且想找个机会好好爽一番",
      "那么《死亡细胞》绝对是你的不二之选",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: hmmj"
    ],
    "codes": [],
    "date": "2018-04-04",
    "text": "死亡细胞\n”生存还是死亡？这是一个问题” ——莎士比亚\n游戏简介《死亡细胞》一经上架，便被誉为2D版《黑魂》。游戏难度高，人物动作流畅，打击感极强。如果你是一个动作游戏的爱好者，并且想找个机会好好爽一番，那么《死亡细胞》绝对是你的不二之选。\n游戏截图\n下载方式[百度网盘 for Windows]密码: hmmj\n"
  },
  {
    "head": "Faster Than Light",
    "paragraphs": [
      "超越光速",
      "你是否向往过过星爵那紧张刺激的星际之旅？",
      "游戏简介那么现在你有这样一个机会了！驾驶自己的飞船，装配武器，召集船员，升级科技，击败星际舰队。游戏可解锁20+艘不同的飞船，可玩性极高。想来一场迷你却精致的太空冒险？《超越光速》，你值得拥有！",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: rr3h"
    ],
    "sentences": [
      "超越光速",
      "你是否向往过过星爵那紧张刺激的星际之旅？",
      "游戏简介那么现在你有这样一个机会了！驾驶自己的飞船",
      "装配武器",
      "召集船员",
      "升级科技",
      "击败星际舰队",
      "游戏可解锁20+艘不同的飞船，可玩性极高",
      "想来一场迷你却精致的太空冒险？《超越光速》，你值得拥有！",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: rr3h"
    ],
    "codes": [],
    "date": "2018-04-07",
    "text": "超越光速\n你是否向往过过星爵那紧张刺激的星际之旅？\n游戏简介那么现在你有这样一个机会了！驾驶自己的飞船，装配武器，召集船员，升级科技，击败星际舰队。游戏可解锁20+艘不同的飞船，可玩性极高。想来一场迷你却精致的太空冒险？《超越光速》，你值得拥有！\n游戏截图\n下载方式[百度网盘 for Windows]密码: rr3h\n"
  },
  {
    "head": "Dead Cells",
    "paragraphs": [
      "死亡细胞",
      "”生存还是死亡？这是一个问题” ——莎士比亚",
      "游戏简介《死亡细胞》一经上架，便被誉为2D版《黑魂》。游戏难度高，人物动作流畅，打击感极强。如果你是一个动作游戏的爱好者，并且想找个机会好好爽一番，那么《死亡细胞》绝对是你的不二之选。",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: hmmj"
    ],
    "sentences": [
      "死亡细胞",
      "”生存还是死亡？这是一个问题” ——莎士比亚",
      "游戏简介《死亡细胞》一经上架，便被誉为2D版《黑魂》",
      "游戏难度高，人物动作流畅，打击感极强",
      "如果你是一个动作游戏的爱好者",
      "并且想找个机会好好爽一番",
      "那么《死亡细胞》绝对是你的不二之选",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: hmmj"
    ],
    "codes": [],
    "date": "2018-04-04",
    "text": "死亡细胞\n”生存还是死亡？这是一个问题” ——莎士比亚\n游戏简介《死亡细胞》一经上架，便被誉为2D版《黑魂》。游戏难度高，人物动作流畅，打击感极强。如果你是一个动作游戏的爱好者，并且想找个机会好好爽一番，那么《死亡细胞》绝对是你的不二之选。\n游戏截图\n下载方式[百度网盘 for Windows]密码: hmmj\n"
  },
  {
    "head": "Ronin",
    "paragraphs": [
      "“复仇这盘菜，凉了最好吃。” ——唐·柯里昂",
      "游戏简介《浪人》讲述的是小女孩年幼时父亲便被杀害，长大后为父亲报仇的故事。 浪人的画面采用美式漫画风格，线条明朗，动作流畅，打击感强。配乐紧张，富有节奏，很容易将玩家带入到那个血雨腥风的仇杀之路。游戏拥有独特的操作机制，将动作游戏与回合制大胆结合，创造出新颖的游戏玩法，是前所未有的游戏体验。",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: 5q36"
    ],
    "sentences": [
      "“复仇这盘菜，凉了最好吃",
      "” ——唐·柯里昂",
      "游戏简介《浪人》讲述的是小女孩年幼时父亲便被杀害",
      "长大后为父亲报仇的故事",
      " 浪人的画面采用美式漫画风格，线条明朗，动作流畅，打击感强",
      "配乐紧张，富有节奏，很容易将玩家带入到那个血雨腥风的仇杀之路",
      "游戏拥有独特的操作机制",
      "将动作游戏与回合制大胆结合",
      "创造出新颖的游戏玩法",
      "是前所未有的游戏体验",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: 5q36"
    ],
    "codes": [],
    "date": "2018-04-04",
    "text": "“复仇这盘菜，凉了最好吃。” ——唐·柯里昂\n游戏简介《浪人》讲述的是小女孩年幼时父亲便被杀害，长大后为父亲报仇的故事。 浪人的画面采用美式漫画风格，线条明朗，动作流畅，打击感强。配乐紧张，富有节奏，很容易将玩家带入到那个血雨腥风的仇杀之路。游戏拥有独特的操作机制，将动作游戏与回合制大胆结合，创造出新颖的游戏玩法，是前所未有的游戏体验。\n游戏截图\n下载方式[百度网盘 for Windows]密码: 5q36\n"
  },
  {
    "head": "Risk of Rain",
    "paragraphs": [
      "雨中冒险",
      "孤独者的冒险",
      "游戏简介由于飞船失事，玩家降落在一个陌生的星球上；为了生存，玩家必须与当地生物进行搏斗；生存竞争，适者生存。 游戏的背景设置为远山、星空、海洋、黑夜、云海；偌大的屏幕中央，由几个像素组成的玩家不紧不慢的行进；加上略有动感又略显复古的配乐，将孤独浪人的气氛渲染的恰到好处。 我想这或许就是孤独体现的最好方式：一个人，做一件事，直到地老天荒。 或许才接触到这款游戏的时候，它并不会给你留下深刻的印象；但经过几场游玩后，它一定能让你为之痴迷。",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: yhvc"
    ],
    "sentences": [
      "雨中冒险",
      "孤独者的冒险",
      "游戏简介由于飞船失事",
      "玩家降落在一个陌生的星球上；为了生存",
      "玩家必须与当地生物进行搏斗；生存竞争",
      "适者生存",
      " 游戏的背景设置为远山、星空、海洋、黑夜、云海；偌大的屏幕中央",
      "由几个像素组成的玩家不紧不慢的行进；加上略有动感又略显复古的配乐",
      "将孤独浪人的气氛渲染的恰到好处",
      " 我想这或许就是孤独体现的最好方式：一个人",
      "做一件事",
      "直到地老天荒",
      " 或许才接触到这款游戏的时候",
      "它并不会给你留下深刻的印象；但经过几场游玩后",
      "它一定能让你为之痴迷",
      "游戏截图",
      "下载方式[百度网盘 for Windows]密码: yhvc"
    ],
    "codes": [],
    "date": "2018-04-04",
    "text": "雨中冒险\n孤独者的冒险\n游戏简介由于飞船失事，玩家降落在一个陌生的星球上；为了生存，玩家必须与当地生物进行搏斗；生存竞争，适者生存。 游戏的背景设置为远山、星空、海洋、黑夜、云海；偌大的屏幕中央，由几个像素组成的玩家不紧不慢的行进；加上略有动感又略显复古的配乐，将孤独浪人的气氛渲染的恰到好处。 我想这或许就是孤独体现的最好方式：一个人，做一件事，直到地老天荒。 或许才接触到这款游戏的时候，它并不会给你留下深刻的印象；但经过几场游玩后，它一定能让你为之痴迷。\n游戏截图\n下载方式[百度网盘 for Windows]密码: yhvc\n"
  },
  {
    "head": "关于软件构造的多维度视图的总结",
    "paragraphs": [
      "这部分是在软件构造课上学习的，属于记忆性内容，在此作出一个总结",
      "按状态划分：构造时视图（build-time） 运行时视图（run-time）",
      "按动态性划分：时刻视图（moment） 阶段视图（period）",
      "按构造对象的层次划分：代码视图（code） 构件视图（component）",
      "下面为一些举例：",
      "Source code(源代码):bulild-time moment code",
      "AST(抽象语法树):build-time moment code",
      "Interiace-Class-Attribute-Method(内部类属性方法):build-time moment code",
      "Code Snapshot(代码快照):run-time moment code",
      "Memory dump(内存转储):run-time moment code",
      "Package(包):build-time moment component",
      "File(文件):build-time moment component",
      "Static Linking(静态链接):build-time moment component",
      "Test Case(测试用例):build-time moment component",
      "Build Script(构建脚本):build-time moment component",
      "Package(封装):run-time moment component",
      "Library(程序库):run-time moment component",
      "Dynamic linking(动态链接):run-time moment component",
      "Configuration(配置):run-time moment component",
      "Database(数据库):run-time moment component",
      "Middleware(中间软件):run-time moment component",
      "Network(网络):run-time moment component",
      "Hardware(计算机硬件):run-time moment component",
      "Code Churn(代码变化):build-time period code",
      "Execution Stack Trace(执行堆栈跟踪):run-time period code",
      "Concurrent multi-threads(并发多线程):run-time period code",
      "Configuration Item(配置项):build-time period component",
      "Version(版本):build-time period component",
      "Event log(事件日志):run-time period component",
      "Multi-processes(多进程):run-time period component",
      "Distributed processes(分布式进程):run-time period component",
      "Procedure Call Graph(过程调用图):run-time period code&component",
      "Message Graph(消息图):run-time period code&component"
    ],
    "sentences": [
      "这部分是在软件构造课上学习的",
      "属于记忆性内容",
      "在此作出一个总结",
      "按状态划分：构造时视图（build-time） 运行时视图（run-time）",
      "按动态性划分：时刻视图（moment） 阶段视图（period）",
      "按构造对象的层次划分：代码视图（code） 构件视图（component）",
      "下面为一些举例：Source code(源代码):bulild-time moment code",
      "AST(抽象语法树):build-time moment code",
      "Interiace-Class-Attribute-Method(内部类属性方法):build-time moment code",
      "Code Snapshot(代码快照):run-time moment code",
      "Memory dump(内存转储):run-time moment code",
      "Package(包):build-time moment component",
      "File(文件):build-time moment component",
      "Static Linking(静态链接):build-time moment component",
      "Test Case(测试用例):build-time moment component",
      "Build Script(构建脚本):build-time moment component",
      "Package(封装):run-time moment component",
      "Library(程序库):run-time moment component",
      "Dynamic linking(动态链接):run-time moment component",
      "Configuration(配置):run-time moment component",
      "Database(数据库):run-time moment component",
      "Middleware(中间软件):run-time moment component",
      "Network(网络):run-time moment component",
      "Hardware(计算机硬件):run-time moment component",
      "Code Churn(代码变化):build-time period code",
      "Execution Stack Trace(执行堆栈跟踪):run-time period code",
      "Concurrent multi-threads(并发多线程):run-time period code",
      "Configuration Item(配置项):build-time period component",
      "Version(版本):build-time period component",
      "Event log(事件日志):run-time period component",
      "Multi-processes(多进程):run-time period component",
      "Distributed processes(分布式进程):run-time period component",
      "Procedure Call Graph(过程调用图):run-time period code&component",
      "Message Graph(消息图):run-time period code&component"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "这部分是在软件构造课上学习的，属于记忆性内容，在此作出一个总结\n按状态划分：构造时视图（build-time） 运行时视图（run-time）\n按动态性划分：时刻视图（moment） 阶段视图（period）\n按构造对象的层次划分：代码视图（code） 构件视图（component）\n下面为一些举例：\nSource code(源代码):bulild-time moment code\nAST(抽象语法树):build-time moment code\nInteriace-Class-Attribute-Method(内部类属性方法):build-time moment code\nCode Snapshot(代码快照):run-time moment code\nMemory dump(内存转储):run-time moment code\nPackage(包):build-time moment component\nFile(文件):build-time moment component\nStatic Linking(静态链接):build-time moment component\nTest Case(测试用例):build-time moment component\nBuild Script(构建脚本):build-time moment component\nPackage(封装):run-time moment component\nLibrary(程序库):run-time moment component\nDynamic linking(动态链接):run-time moment component\nConfiguration(配置):run-time moment component\nDatabase(数据库):run-time moment component\nMiddleware(中间软件):run-time moment component\nNetwork(网络):run-time moment component\nHardware(计算机硬件):run-time moment component\nCode Churn(代码变化):build-time period code\nExecution Stack Trace(执行堆栈跟踪):run-time period code\nConcurrent multi-threads(并发多线程):run-time period code\nConfiguration Item(配置项):build-time period component\nVersion(版本):build-time period component\nEvent log(事件日志):run-time period component\nMulti-processes(多进程):run-time period component\nDistributed processes(分布式进程):run-time period component\nProcedure Call Graph(过程调用图):run-time period code&component\nMessage Graph(消息图):run-time period code&component\n"
  },
  {
    "head": "正则表达式条件匹配的基本语法",
    "paragraphs": [
      "条件匹配在正则表达式中十分重要，下面简单根据我的了解介绍一些：",
      "?(A)B 表示只有当A存在时才会匹配B",
      "下面的代码验证：",
      "上述为A不存在B存在的情况，结果为不匹配",
      "上述为AB都存在的情况结果为匹配",
      "?(A)B|C 若A存在，匹配B，否则，匹配C",
      "下面的代码验证：",
      "上述为A存在的情况，结果为匹配",
      "上述为A不存在的情况，结果为匹配"
    ],
    "sentences": [
      "条件匹配在正则表达式中十分重要",
      "下面简单根据我的了解介绍一些：?(A)B 表示只有当A存在时才会匹配B",
      "下面的代码验证：上述为A不存在B存在的情况，结果为不匹配",
      "上述为AB都存在的情况结果为匹配",
      "?(A)B|C 若A存在，匹配B，否则，匹配C",
      "下面的代码验证：上述为A存在的情况，结果为匹配",
      "上述为A不存在的情况，结果为匹配"
    ],
    "codes": [
      "        String pattern=\"/?(A)B\";\n\t\tString str=\"B\";\n\t\tPattern p=Pattern.compile(pattern);\n\t\tMatcher m=p.matcher(str);\n\t\tboolean result=m.matches();\n\t\tif(result) {\n\t\t\tSystem.out.println(\"匹配\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"不匹配\");\n\t\t}",
      "        String pattern=\"/?(A)B\";\n\t\tString str=\"AB\";\n\t\tPattern p=Pattern.compile(pattern);\n\t\tMatcher m=p.matcher(str);\n\t\tboolean result=m.matches();\n\t\tif(result) {\n\t\t\tSystem.out.println(\"匹配\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"不匹配\");\n\t\t}",
      "        String pattern=\"/?(A)B|C\";\n\t\tString str=\"AB\";\n\t\tPattern p=Pattern.compile(pattern);\n\t\tMatcher m=p.matcher(str);\n\t\tboolean result=m.matches();\n\t\tif(result) {\n\t\t\tSystem.out.println(\"匹配\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"不匹配\");\n\t\t}",
      "String pattern=\"/?(A)B|C\";\n\t\tString str=\"C\";\n\t\tPattern p=Pattern.compile(pattern);\n\t\tMatcher m=p.matcher(str);\n\t\tboolean result=m.matches();\n\t\tif(result) {\n\t\t\tSystem.out.println(\"匹配\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"不匹配\");\n\t\t}"
    ],
    "date": "2021-07-06",
    "text": "条件匹配在正则表达式中十分重要，下面简单根据我的了解介绍一些：\n?(A)B 表示只有当A存在时才会匹配B\n下面的代码验证：\n上述为A不存在B存在的情况，结果为不匹配\n上述为AB都存在的情况结果为匹配\n?(A)B|C 若A存在，匹配B，否则，匹配C\n下面的代码验证：\n上述为A存在的情况，结果为匹配\n上述为A不存在的情况，结果为匹配\n"
  },
  {
    "head": "java中List的遍历方法",
    "paragraphs": [
      "在做实验写代码时，List集合的遍历是经常要用到的",
      "经过课上的讲解与课后的相关学习，总结如下：",
      "首先在遍历之前创造一个List如下：",
      "第一种方法：for循环遍历",
      "理解起来最为简单，利用for循环，设置循环内的局部变量通过get方法对List遍历。",
      "第二种方法：增强型for循环遍历",
      "for(数据类型 变量名：容器对象){",
      "第三种方法：迭代器：",
      "通过集合对象获得迭代器对象",
      "利用while循环遍历",
      "利用hasNext()方法判断是否终止",
      "利用next()获取元素",
      "三种方法的结果都如下：",
      "可见三种方法都正确实现了List的遍历。"
    ],
    "sentences": [
      "在做实验写代码时，List集合的遍历是经常要用到的",
      "经过课上的讲解与课后的相关学习",
      "总结如下：首先在遍历之前创造一个List如下：第一种方法：for循环遍历",
      "理解起来最为简单",
      "利用for循环",
      "设置循环内的局部变量通过get方法对List遍历",
      "第二种方法：增强型for循环遍历",
      "for(数据类型 变量名：容器对象){",
      "第三种方法：迭代器：通过集合对象获得迭代器对象",
      "利用while循环遍历",
      "利用hasNext()方法判断是否终止",
      "利用next()获取元素",
      "三种方法的结果都如下：可见三种方法都正确实现了List的遍历"
    ],
    "codes": [
      "List<String> list=new ArrayList<>();\n\t\tlist.add(\"H\");\n\t\tlist.add(\"u\");\n\t\tlist.add(\"i\");\n\t\tlist.add(\"Y\");\n\t\tlist.add(\"i\");",
      "for(int i=0;i<list.size();i++)\n\t\t{\n\t\t\tSystem.out.println(list.get(i));\n\t\t}",
      "for(String s:list) {\n\t\t\tSystem.out.println(s);\n\t\t}",
      "Iterator<String> iter=list.iterator();\n\t\twhile(iter.hasNext()) {\n\t\t\tString s=iter.next();\n\t\t\tSystem.out.println(s);\n\t\t}"
    ],
    "date": "2021-06-23",
    "text": "在做实验写代码时，List集合的遍历是经常要用到的\n经过课上的讲解与课后的相关学习，总结如下：\n首先在遍历之前创造一个List如下：\n第一种方法：for循环遍历\n理解起来最为简单，利用for循环，设置循环内的局部变量通过get方法对List遍历。\n第二种方法：增强型for循环遍历\nfor(数据类型 变量名：容器对象){\n第三种方法：迭代器：\n通过集合对象获得迭代器对象\n利用while循环遍历\n利用hasNext()方法判断是否终止\n利用next()获取元素\n三种方法的结果都如下：\n可见三种方法都正确实现了List的遍历。\n"
  },
  {
    "head": "有关java等价性问题 == 误用",
    "paragraphs": [
      "在一次实验的test阶段，测试文件总是不通过，最后发现我是犯了等价性方面的错误：",
      "在判断两个字符串是否相等时错误的使用==，将其改为equals()方法解决了问题。",
      "后来在经课上听讲与课后调查了解到：",
      "==是在判断两个对象是否指向内存里的同一段空间。",
      "equals是将此字符串与指定的对象进行比较。当且仅当参数不为NULL并且是表示与此",
      "对象相同的字符序列的字符串对象时，结果才为true。",
      "就这个问题简化验证：将字符串s1与s2，利用==与equals()分别判断",
      "结果如下：可以看出==判断为false，利用equals()判断为true。",
      "这里让我想起了一道以前的课堂的一道题可以加深对==的理解：",
      "答案为Flase;True",
      " a为创建的Integer对象，b是自动装箱产生的Integer对象，其地址不同，故第一个为false。",
      "c为int类型，int与Integer比较时，Integer会进行拆箱，相当于两个int进行比较，故第二个为true。",
      " 通过以上测试可以看出：在判断相等的大部分情况下，我们在代码中的本意是equals()，",
      "而不是==，这点不难理解，故在编写代码时一定要注意。"
    ],
    "sentences": [
      "在一次实验的test阶段",
      "测试文件总是不通过",
      "最后发现我是犯了等价性方面的错误：在判断两个字符串是否相等时错误的使用==",
      "将其改为equals()方法解决了问题",
      "后来在经课上听讲与课后调查了解到：==是在判断两个对象是否指向内存里的同一段空间",
      "equals是将此字符串与指定的对象进行比较",
      "当且仅当参数不为NULL并且是表示与此",
      "对象相同的字符序列的字符串对象时，结果才为true",
      "就这个问题简化验证：将字符串s1与s2",
      "利用==与equals()分别判断",
      "结果如下：可以看出==判断为false",
      "利用equals()判断为true",
      "这里让我想起了一道以前的课堂的一道题可以加深对==的理解：答案为Flase;True",
      " a为创建的Integer对象",
      "b是自动装箱产生的Integer对象",
      "其地址不同",
      "故第一个为false",
      "c为int类型",
      "int与Integer比较时",
      "Integer会进行拆箱",
      "相当于两个int进行比较",
      "故第二个为true",
      " 通过以上测试可以看出：在判断相等的大部分情况下",
      "我们在代码中的本意是equals()",
      "而不是==",
      "这点不难理解",
      "故在编写代码时一定要注意"
    ],
    "codes": [
      "        String s1=\"Hui\";\n\t\tString s2=new String(s1);\n\t\tif(s1==s2) {\n\t\t\tSystem.out.println(\"==:T\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"==:F\");\n\t\t}\n\t\tif(s1.equals(s2)) {\n\t\t\tSystem.out.println(\"equals:T\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"equals:F\");\n\t\t}"
    ],
    "date": "2021-06-23",
    "text": "在一次实验的test阶段，测试文件总是不通过，最后发现我是犯了等价性方面的错误：\n在判断两个字符串是否相等时错误的使用==，将其改为equals()方法解决了问题。\n后来在经课上听讲与课后调查了解到：\n==是在判断两个对象是否指向内存里的同一段空间。\nequals是将此字符串与指定的对象进行比较。当且仅当参数不为NULL并且是表示与此\n对象相同的字符序列的字符串对象时，结果才为true。\n就这个问题简化验证：将字符串s1与s2，利用==与equals()分别判断\n结果如下：可以看出==判断为false，利用equals()判断为true。\n这里让我想起了一道以前的课堂的一道题可以加深对==的理解：\n答案为Flase;True\n a为创建的Integer对象，b是自动装箱产生的Integer对象，其地址不同，故第一个为false。\nc为int类型，int与Integer比较时，Integer会进行拆箱，相当于两个int进行比较，故第二个为true。\n 通过以上测试可以看出：在判断相等的大部分情况下，我们在代码中的本意是equals()，\n而不是==，这点不难理解，故在编写代码时一定要注意。\n"
  },
  {
    "head": "assertEquals判断两个double是否相等的方法",
    "paragraphs": [
      "在我们写测试用例时，难免要对各种数据类型是否相等进行判断。前几天在对两个double类型利",
      "用aseertEquals进行判断时，遇到了下面的问题：精简化问题如下：",
      "在这个例子中double类型h与y的值都为0.1，但assertEquals测试没通过，同时有一条warning",
      "The method assertEquals(double, double) from the type Assert is deprecated",
      "这条warning的意思是类型Assert中的方法assertEquals（double，double）已弃用。",
      "其实我们都直到浮点型的存储形式，因为浮点数的范围和精度有限，所有直接判断两个double类",
      "型是否相等是不合理的，以此我们利用下面的方法解决这个问题：",
      "java中提供了解决double判断的方法其中assertEquals的第一个参数为预期值，第二个参数为实",
      "际值，第三个参数为偏差。当预期值与实际值之间的差值在偏差的范围内则判为相等，否则会抛出",
      "错误。"
    ],
    "sentences": [
      "在我们写测试用例时，难免要对各种数据类型是否相等进行判断",
      "前几天在对两个double类型利",
      "用aseertEquals进行判断时",
      "遇到了下面的问题：精简化问题如下：在这个例子中double类型h与y的值都为0.1",
      "但assertEquals测试没通过",
      "同时有一条warning",
      "The method assertEquals(double, double) from the type Assert is deprecated",
      "这条warning的意思是类型Assert中的方法assertEquals（double",
      "double）已弃用",
      "其实我们都直到浮点型的存储形式",
      "因为浮点数的范围和精度有限",
      "所有直接判断两个double类",
      "型是否相等是不合理的",
      "以此我们利用下面的方法解决这个问题：java中提供了解决double判断的方法其中assertEquals的第一个参数为预期值",
      "第二个参数为实",
      "际值，第三个参数为偏差",
      "当预期值与实际值之间的差值在偏差的范围内则判为相等",
      "否则会抛出",
      "错误"
    ],
    "codes": [],
    "date": "2021-07-03",
    "text": "在我们写测试用例时，难免要对各种数据类型是否相等进行判断。前几天在对两个double类型利\n用aseertEquals进行判断时，遇到了下面的问题：精简化问题如下：\n在这个例子中double类型h与y的值都为0.1，但assertEquals测试没通过，同时有一条warning\nThe method assertEquals(double, double) from the type Assert is deprecated\n这条warning的意思是类型Assert中的方法assertEquals（double，double）已弃用。\n其实我们都直到浮点型的存储形式，因为浮点数的范围和精度有限，所有直接判断两个double类\n型是否相等是不合理的，以此我们利用下面的方法解决这个问题：\njava中提供了解决double判断的方法其中assertEquals的第一个参数为预期值，第二个参数为实\n际值，第三个参数为偏差。当预期值与实际值之间的差值在偏差的范围内则判为相等，否则会抛出\n错误。\n"
  },
  {
    "head": "Java 抽象与接口",
    "paragraphs": [
      "抽象函数/抽象类",
      "抽象函数：",
      "表达概念而无法实现具体代码的函数。",
      "抽象类：表达概念而无法构造出实体的类。",
      "抽象函数只有函数头而没有实现，它的实现由子类提供",
      "有抽象函数的类一定是抽象类，允许声明没有抽象方法的抽象类。",
      "非抽象类不能包含抽象函数，如果一个抽象父类的子类不能实现所有的抽象方法，它必须声明为抽象的。",
      "抽象类不能用new制造对象，但是可以定义变量；可以定义它的构造方法，可在子类的构造方法中调用。",
      "任何继承了抽象类的非抽象类的对象可以付给这个变量",
      "接口的定义",
      "1.接口是纯抽象类。",
      "所有成员函数都是抽象函数",
      "所有成员变量都是 public static final",
      "2.接口规定了里面有什么，但不管里面有什么。",
      "3.接口不能被实例化，只能被类实现，或者被其他接口扩展。",
      "4.关键字",
      "interface表明其后紧跟的是接口名",
      "extends表明继承自哪些父接口",
      "访问权限控制符",
      "public表明任意类和接口均可使用这个接口；",
      "缺省修饰符表明只有与该接口定义在同一个包中的类和接口才可以使用这个接口。",
      "接口的实现",
      "类用extends，接口用implements",
      "类可以实现多个接口",
      "接口可以继承接口，但不能继承类",
      "接口不能实现接口",
      "面向接口的编程方式",
      "设计程序时需要先定义接口，再利用接口去实现类",
      "任何需要在函数间传入传出的一定是接口"
    ],
    "sentences": [
      "抽象函数/抽象类",
      "抽象函数：表达概念而无法实现具体代码的函数",
      "抽象类：表达概念而无法构造出实体的类",
      "抽象函数只有函数头而没有实现，它的实现由子类提供",
      "有抽象函数的类一定是抽象类，允许声明没有抽象方法的抽象类",
      "非抽象类不能包含抽象函数",
      "如果一个抽象父类的子类不能实现所有的抽象方法",
      "它必须声明为抽象的",
      "抽象类不能用new制造对象",
      "但是可以定义变量；可以定义它的构造方法",
      "可在子类的构造方法中调用",
      "任何继承了抽象类的非抽象类的对象可以付给这个变量",
      "接口的定义",
      "1.接口是纯抽象类",
      "所有成员函数都是抽象函数",
      "所有成员变量都是 public static final",
      "2.接口规定了里面有什么，但不管里面有什么",
      "3.接口不能被实例化，只能被类实现，或者被其他接口扩展",
      "4.关键字",
      "interface表明其后紧跟的是接口名",
      "extends表明继承自哪些父接口",
      "访问权限控制符",
      "public表明任意类和接口均可使用这个接口；缺省修饰符表明只有与该接口定义在同一个包中的类和接口才可以使用这个接口",
      "接口的实现",
      "类用extends，接口用implements",
      "类可以实现多个接口",
      "接口可以继承接口，但不能继承类",
      "接口不能实现接口",
      "面向接口的编程方式",
      "设计程序时需要先定义接口，再利用接口去实现类",
      "任何需要在函数间传入传出的一定是接口"
    ],
    "codes": [],
    "date": "2021-06-29",
    "text": "抽象函数/抽象类\n抽象函数：\n表达概念而无法实现具体代码的函数。\n抽象类：表达概念而无法构造出实体的类。\n抽象函数只有函数头而没有实现，它的实现由子类提供\n有抽象函数的类一定是抽象类，允许声明没有抽象方法的抽象类。\n非抽象类不能包含抽象函数，如果一个抽象父类的子类不能实现所有的抽象方法，它必须声明为抽象的。\n抽象类不能用new制造对象，但是可以定义变量；可以定义它的构造方法，可在子类的构造方法中调用。\n任何继承了抽象类的非抽象类的对象可以付给这个变量\n接口的定义\n1.接口是纯抽象类。\n所有成员函数都是抽象函数\n所有成员变量都是 public static final\n2.接口规定了里面有什么，但不管里面有什么。\n3.接口不能被实例化，只能被类实现，或者被其他接口扩展。\n4.关键字\ninterface表明其后紧跟的是接口名\nextends表明继承自哪些父接口\n访问权限控制符\npublic表明任意类和接口均可使用这个接口；\n缺省修饰符表明只有与该接口定义在同一个包中的类和接口才可以使用这个接口。\n接口的实现\n类用extends，接口用implements\n类可以实现多个接口\n接口可以继承接口，但不能继承类\n接口不能实现接口\n面向接口的编程方式\n设计程序时需要先定义接口，再利用接口去实现类\n任何需要在函数间传入传出的一定是接口\n"
  },
  {
    "head": "Java ADT 设计总结",
    "paragraphs": [
      "ADT",
      "ADT是抽象数据类型（Abstract Data Type）的缩写。ADT是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。",
      "下面介绍有关表示的几个概念:",
      "抽象函数(AbstractFunction,AF)",
      "表示不变量(Representation Invariant,RI)",
      "表示独立性（Representation Independence)",
      "（1）抽象函数(AbstractFunction,AF)",
      "表示域（称为R）包含的是值具体的实现实体。抽象域（称为A）包含类型设计时支持使用的值。抽象函数是表示值到其对应的抽象值的映射——AF: R->A。",
      "（2）表示不变量(Representation Invariant,RI)",
      "要求注明抽象值的合法区域，并说明合法或者不合法的原因。其中最基本的表示不变量的就是可变与不可变性（mutable/immutable）。",
      "记录不变量是为了保持程序的“正确性”，防止发生错误。",
      "（3）表示独立性（Representation Independence)",
      "说一个ADT有良好的表示独立性，就是说client使用ADT是无需考虑其内部如何实现的，ADT内部表示的变化不应影响外部spec和客户端。所有的操作的使用方法和效果都要在spec中说清楚，规定好输入的约束条件和输出的正确性和安全性。"
    ],
    "sentences": [
      "ADT",
      "ADT是抽象数据类型（Abstract Data Type）的缩写",
      "ADT是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型",
      "下面介绍有关表示的几个概念:抽象函数(AbstractFunction,AF)",
      "表示不变量(Representation Invariant,RI)",
      "表示独立性（Representation Independence)",
      "（1）抽象函数(AbstractFunction,AF)",
      "表示域（称为R）包含的是值具体的实现实体",
      "抽象域（称为A）包含类型设计时支持使用的值",
      "抽象函数是表示值到其对应的抽象值的映射——AF: R->A",
      "（2）表示不变量(Representation Invariant,RI)",
      "要求注明抽象值的合法区域，并说明合法或者不合法的原因",
      "其中最基本的表示不变量的就是可变与不可变性（mutable/immutable）",
      "记录不变量是为了保持程序的“正确性”，防止发生错误",
      "（3）表示独立性（Representation Independence)",
      "说一个ADT有良好的表示独立性",
      "就是说client使用ADT是无需考虑其内部如何实现的",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "所有的操作的使用方法和效果都要在spec中说清楚",
      "规定好输入的约束条件和输出的正确性和安全性"
    ],
    "codes": [],
    "date": "2021-06-28",
    "text": "ADT\nADT是抽象数据类型（Abstract Data Type）的缩写。ADT是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。\n下面介绍有关表示的几个概念:\n抽象函数(AbstractFunction,AF)\n表示不变量(Representation Invariant,RI)\n表示独立性（Representation Independence)\n（1）抽象函数(AbstractFunction,AF)\n表示域（称为R）包含的是值具体的实现实体。抽象域（称为A）包含类型设计时支持使用的值。抽象函数是表示值到其对应的抽象值的映射——AF: R->A。\n（2）表示不变量(Representation Invariant,RI)\n要求注明抽象值的合法区域，并说明合法或者不合法的原因。其中最基本的表示不变量的就是可变与不可变性（mutable/immutable）。\n记录不变量是为了保持程序的“正确性”，防止发生错误。\n（3）表示独立性（Representation Independence)\n说一个ADT有良好的表示独立性，就是说client使用ADT是无需考虑其内部如何实现的，ADT内部表示的变化不应影响外部spec和客户端。所有的操作的使用方法和效果都要在spec中说清楚，规定好输入的约束条件和输出的正确性和安全性。\n"
  },
  {
    "head": "Java中关于Queue的一部分操作",
    "paragraphs": [
      "队列是一个先进先出的数据结构，具有一些相似度较高的操作。在软件构造课程过程中，一些实际的操作在编写时，却触发了一些异常。下面记录一下自己遇到的问题。",
      "1.关于add()与offer()的差别",
      "add()与offer()都是向队列中添加一个元素。差别在于队列满时的添加操作。",
      "查看add()的API如下：",
      "查看offer()的API如下：",
      "如图，差别在于，add()是抛出异常让你处理，而offer是返回false。",
      "2.关于poll()与remove()的差别",
      "poll()和remove()都是从队首获取元素，并将该元素从队列中移除。差别在于队列为空时的操作。",
      "查看poll()的API如下：",
      "查看remove()的API如下：",
      "如图，差别在于，poll()会返回null，而remove()会抛出异常。"
    ],
    "sentences": [
      "队列是一个先进先出的数据结构，具有一些相似度较高的操作",
      "在软件构造课程过程中",
      "一些实际的操作在编写时",
      "却触发了一些异常",
      "下面记录一下自己遇到的问题",
      "1.关于add()与offer()的差别",
      "add()与offer()都是向队列中添加一个元素",
      "差别在于队列满时的添加操作",
      "查看add()的API如下：查看offer()的API如下：如图",
      "差别在于",
      "add()是抛出异常让你处理",
      "而offer是返回false",
      "2.关于poll()与remove()的差别",
      "poll()和remove()都是从队首获取元素",
      "并将该元素从队列中移除",
      "差别在于队列为空时的操作",
      "查看poll()的API如下：查看remove()的API如下：如图",
      "差别在于",
      "poll()会返回null",
      "而remove()会抛出异常"
    ],
    "codes": [],
    "date": "2021-06-24",
    "text": "队列是一个先进先出的数据结构，具有一些相似度较高的操作。在软件构造课程过程中，一些实际的操作在编写时，却触发了一些异常。下面记录一下自己遇到的问题。\n1.关于add()与offer()的差别\nadd()与offer()都是向队列中添加一个元素。差别在于队列满时的添加操作。\n查看add()的API如下：\n查看offer()的API如下：\n如图，差别在于，add()是抛出异常让你处理，而offer是返回false。\n2.关于poll()与remove()的差别\npoll()和remove()都是从队首获取元素，并将该元素从队列中移除。差别在于队列为空时的操作。\n查看poll()的API如下：\n查看remove()的API如下：\n如图，差别在于，poll()会返回null，而remove()会抛出异常。\n"
  },
  {
    "head": "java.lang.IllegalStateException: No match found 的错误解决方法",
    "paragraphs": [
      "在java中编写正则表达式时，程序报错：java.lang.IllegalStateException: No match found",
      "找到错误是因为在执行分组捕获的时候，没有先进行匹配操作，及find()。",
      "下面是从程序中截出来的一段代码，目的是检测一段表达式：",
      "但是发现在处理另外一段表达式的时候还是会有java.lang.IllegalStateException: No match found 的提示，其中发现问题出现在一句话：",
      "要求的正则表达式中是不含数字的，但是当检测带有数字的表达式时还是会报错，后来发现正确的形式应该为：",
      "这样问题就解决了。"
    ],
    "sentences": [
      "在java中编写正则表达式时",
      "程序报错：java.lang.IllegalStateException: No match found",
      "找到错误是因为在执行分组捕获的时候",
      "没有先进行匹配操作",
      "及find()",
      "下面是从程序中截出来的一段代码",
      "目的是检测一段表达式：但是发现在处理另外一段表达式的时候还是会有java.lang.IllegalStateException: No match found 的提示",
      "其中发现问题出现在一句话：要求的正则表达式中是不含数字的",
      "但是当检测带有数字的表达式时还是会报错",
      "后来发现正确的形式应该为：这样问题就解决了"
    ],
    "codes": [
      "Pattern pattern = Pattern.compile(\"Employee\\\\{\\\\s*(([a-z|A-Z]+\\\\{[^{}]*}\\\\s*)*)}\");\nMatcher m = pattern.matcher(fileContent);\nm.find();\nString employees = m.group(1);\n",
      "Employee{ \n　ZhangSan{Manger,139-0451-0000}\n　LiSi{Secretary,151-0101-0000}\n　WangWu{Associate Dean,177-2021-0301}\n　ZhaoLiua{Professor,138-1920-3912}\n　ZhaoLiub{Lecturer,138-1921-3912}\n　ZhaoLiuc{Professor,138-1922-3912}\n}",
      "ZhaoLiu1{Professor,138-1920-3912}",
      "while( m.find() ){\n    String employees = m.group(1);\n}"
    ],
    "date": "2021-07-06",
    "text": "在java中编写正则表达式时，程序报错：java.lang.IllegalStateException: No match found\n找到错误是因为在执行分组捕获的时候，没有先进行匹配操作，及find()。\n下面是从程序中截出来的一段代码，目的是检测一段表达式：\n但是发现在处理另外一段表达式的时候还是会有java.lang.IllegalStateException: No match found 的提示，其中发现问题出现在一句话：\n要求的正则表达式中是不含数字的，但是当检测带有数字的表达式时还是会报错，后来发现正确的形式应该为：\n这样问题就解决了。\n"
  },
  {
    "head": "Java多维度视图的总结",
    "paragraphs": [
      "软件构造中第一章的最主要的内容应该就是软件的多维视图。可以以三个相互正交的维度划分：",
      "按状态划分：构造时视图（build-time）运行时视图（run-time）",
      "按动态性划分：时刻视图（moment）阶段视图（period）",
      "按构造对象的层次划分：代码视图（code）组件视图（component）",
      "软件的多维视图从构造-运行、代码层-组件层、时刻-阶段这三对对应的属性来刻画了各种可能出现的状态和过程。而软件构造的过程正伴随着这些视图的转换。"
    ],
    "sentences": [
      "软件构造中第一章的最主要的内容应该就是软件的多维视图",
      "可以以三个相互正交的维度划分：按状态划分：构造时视图（build-time）运行时视图（run-time）",
      "按动态性划分：时刻视图（moment）阶段视图（period）",
      "按构造对象的层次划分：代码视图（code）组件视图（component）",
      "软件的多维视图从构造-运行、代码层-组件层、时刻-阶段这三对对应的属性来刻画了各种可能出现的状态和过程",
      "而软件构造的过程正伴随着这些视图的转换"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "软件构造中第一章的最主要的内容应该就是软件的多维视图。可以以三个相互正交的维度划分：\n按状态划分：构造时视图（build-time）运行时视图（run-time）\n按动态性划分：时刻视图（moment）阶段视图（period）\n按构造对象的层次划分：代码视图（code）组件视图（component）\n软件的多维视图从构造-运行、代码层-组件层、时刻-阶段这三对对应的属性来刻画了各种可能出现的状态和过程。而软件构造的过程正伴随着这些视图的转换。\n"
  },
  {
    "head": "2021-07-05",
    "paragraphs": [
      "软件构造之关于git的使用",
      "前言：",
      "本人软件构造课需要在github中获取提供的一些程序框架，并且需要持续的上传代码和报告更新github的个人仓库，所以需要用到一些git的基本操作以及技巧，所以利用这个机会在这里分享一下git学习和使用的收获与心得体会。",
      "创建版本库：",
      "默认已经安装好git了，首先，选择一个合适的地方，创建一个空目录，示例代码如下：",
      "$ mkdir ruanjiangouzao",
      "$ cd ruanjiangouzao",
      "$ pwd",
      "其中ruanjiangouzao为你起的仓库的名字（当然具体要按照实验要求HIT-Lab？-学号），pwd的目的是显示当前目录。",
      "然后通过git init命令把这个目录变成Git可以管理的仓库：",
      "$ git init",
      "添加远程仓库：",
      "建立好本地仓库后就需要与实验给出的远程仓库建立联系，由于软件构造的实验都实现给学生梦创建好了仓库，所以我们不需要在Github中创建新的仓库了，需要登上自己Lab的仓库改一下仓库名字变成规定的形式，然后保存下来仓库的地址并把main分支修改成master分支就好了。",
      "接下啦在本地仓库文件夹下运行",
      "$ git remote add origin git@github.com:刚才保存的实验地址.git（没有http这些前缀的）",
      "接下来就是往github仓库中上传相关的代码和文件啦。这里建议先克隆下来实验的仓库到本地仓库在进行后续上传。",
      "从远程库克隆：",
      "加粗样式",
      "在本地仓库文件夹里执行如下命令克隆下来远程库：",
      "$ git clone git@github.com:刚才保存的实验地址.git（没有http这些前缀的）",
      "向远程仓库中push：",
      "$ git add .",
      "$ git commit -m “随便起个名字”",
      "$ git push origin master",
      "第一行add是添加要上传的文件，. 是添加该文件夹中所有的文件；第二行是为了给这个版本的提交起一个名字；第三行是把选中的内容推送到master分支上去。",
      "当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：",
      "The authenticity of host ‘github.com (xx.xx.xx.xx)’ can’t be established.",
      "RSA key fingerprint is xx.xx.xx.xx.xx.",
      "Are you sure you want to continue connecting (yes/no)?",
      "这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。",
      "Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：",
      "Warning: Permanently added ‘github.com’ (RSA) to the list of known hosts.",
      "这个警告只会出现一次，后面的操作就不会有任何警告了。",
      "添加新的分支change：",
      "Lab3中要求修改原来的设计以应对一些变化，在确保之前的开发已经commit到Git仓库，然后创建新分支“change”，在该分支上完成一些功能的变化。",
      "第一行创建change新分支；第三行在该分支上提交软件构造的Lab新代码；第四行切换回master分支。",
      "Tips：",
      "正常方法连接github极不稳定，请切记不要赶在ddl前几分钟拼命提交。",
      "即使显示如\"everything is update\"这种反馈也不要轻信，尽量自己打开仓库看一眼。",
      "仓库名字一定要按照要求起，一定记得把main改成master，不然真的会不被读取到。",
      "ddl一定要遵守。",
      "参考资料：",
      "廖雪峰git教程",
      "lab-3 reusability and maintainability oriented programming v3"
    ],
    "sentences": [
      "软件构造之关于git的使用",
      "前言：本人软件构造课需要在github中获取提供的一些程序框架",
      "并且需要持续的上传代码和报告更新github的个人仓库",
      "所以需要用到一些git的基本操作以及技巧",
      "所以利用这个机会在这里分享一下git学习和使用的收获与心得体会",
      "创建版本库：默认已经安装好git了",
      "首先",
      "选择一个合适的地方",
      "创建一个空目录",
      "示例代码如下：$ mkdir ruanjiangouzao",
      "$ cd ruanjiangouzao",
      "$ pwd",
      "其中ruanjiangouzao为你起的仓库的名字（当然具体要按照实验要求HIT-Lab？-学号）",
      "pwd的目的是显示当前目录",
      "然后通过git init命令把这个目录变成Git可以管理的仓库：$ git init",
      "添加远程仓库：建立好本地仓库后就需要与实验给出的远程仓库建立联系",
      "由于软件构造的实验都实现给学生梦创建好了仓库",
      "所以我们不需要在Github中创建新的仓库了",
      "需要登上自己Lab的仓库改一下仓库名字变成规定的形式",
      "然后保存下来仓库的地址并把main分支修改成master分支就好了",
      "接下啦在本地仓库文件夹下运行",
      "$ git remote add origin git@github.com:刚才保存的实验地址.git（没有http这些前缀的）",
      "接下来就是往github仓库中上传相关的代码和文件啦",
      "这里建议先克隆下来实验的仓库到本地仓库在进行后续上传",
      "从远程库克隆：加粗样式",
      "在本地仓库文件夹里执行如下命令克隆下来远程库：$ git clone git@github.com:刚才保存的实验地址.git（没有http这些前缀的）",
      "向远程仓库中push：$ git add .$ git commit -m “随便起个名字”",
      "$ git push origin master",
      "第一行add是添加要上传的文件",
      ". 是添加该文件夹中所有的文件；第二行是为了给这个版本的提交起一个名字；第三行是把选中的内容推送到master分支上去",
      "当你第一次使用Git的clone或者push命令连接GitHub时",
      "会得到一个警告：The authenticity of host ‘github.com (xx.xx.xx.xx)’ can’t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?",
      "这是因为Git使用SSH连接",
      "而SSH连接在第一次验证GitHub服务器的Key时",
      "需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器",
      "输入yes回车即可",
      "Git会输出一个警告",
      "告诉你已经把GitHub的Key添加到本机的一个信任列表里了：Warning: Permanently added ‘github.com’ (RSA) to the list of known hosts.这个警告只会出现一次",
      "后面的操作就不会有任何警告了",
      "添加新的分支change：Lab3中要求修改原来的设计以应对一些变化",
      "在确保之前的开发已经commit到Git仓库",
      "然后创建新分支“change”",
      "在该分支上完成一些功能的变化",
      "第一行创建change新分支；第三行在该分支上提交软件构造的Lab新代码；第四行切换回master分支",
      "Tips：正常方法连接github极不稳定",
      "请切记不要赶在ddl前几分钟拼命提交",
      "即使显示如\"everything is update\"这种反馈也不要轻信",
      "尽量自己打开仓库看一眼",
      "仓库名字一定要按照要求起",
      "一定记得把main改成master",
      "不然真的会不被读取到",
      "ddl一定要遵守",
      "参考资料：廖雪峰git教程",
      "lab-3 reusability and maintainability oriented programming v3"
    ],
    "codes": [
      "$ git checkout -b change",
      "$ git add *",
      "$ git commit -m “change”",
      "$ git checkout master"
    ],
    "date": "2021-07-05",
    "text": "软件构造之关于git的使用\n前言：\n本人软件构造课需要在github中获取提供的一些程序框架，并且需要持续的上传代码和报告更新github的个人仓库，所以需要用到一些git的基本操作以及技巧，所以利用这个机会在这里分享一下git学习和使用的收获与心得体会。\n创建版本库：\n默认已经安装好git了，首先，选择一个合适的地方，创建一个空目录，示例代码如下：\n$ mkdir ruanjiangouzao\n$ cd ruanjiangouzao\n$ pwd\n其中ruanjiangouzao为你起的仓库的名字（当然具体要按照实验要求HIT-Lab？-学号），pwd的目的是显示当前目录。\n然后通过git init命令把这个目录变成Git可以管理的仓库：\n$ git init\n添加远程仓库：\n建立好本地仓库后就需要与实验给出的远程仓库建立联系，由于软件构造的实验都实现给学生梦创建好了仓库，所以我们不需要在Github中创建新的仓库了，需要登上自己Lab的仓库改一下仓库名字变成规定的形式，然后保存下来仓库的地址并把main分支修改成master分支就好了。\n接下啦在本地仓库文件夹下运行\n$ git remote add origin git@github.com:刚才保存的实验地址.git（没有http这些前缀的）\n接下来就是往github仓库中上传相关的代码和文件啦。这里建议先克隆下来实验的仓库到本地仓库在进行后续上传。\n从远程库克隆：\n加粗样式\n在本地仓库文件夹里执行如下命令克隆下来远程库：\n$ git clone git@github.com:刚才保存的实验地址.git（没有http这些前缀的）\n向远程仓库中push：\n$ git add .\n$ git commit -m “随便起个名字”\n$ git push origin master\n第一行add是添加要上传的文件，. 是添加该文件夹中所有的文件；第二行是为了给这个版本的提交起一个名字；第三行是把选中的内容推送到master分支上去。\n当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：\nThe authenticity of host ‘github.com (xx.xx.xx.xx)’ can’t be established.\nRSA key fingerprint is xx.xx.xx.xx.xx.\nAre you sure you want to continue connecting (yes/no)?\n这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。\nGit会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：\nWarning: Permanently added ‘github.com’ (RSA) to the list of known hosts.\n这个警告只会出现一次，后面的操作就不会有任何警告了。\n添加新的分支change：\nLab3中要求修改原来的设计以应对一些变化，在确保之前的开发已经commit到Git仓库，然后创建新分支“change”，在该分支上完成一些功能的变化。\n第一行创建change新分支；第三行在该分支上提交软件构造的Lab新代码；第四行切换回master分支。\nTips：\n正常方法连接github极不稳定，请切记不要赶在ddl前几分钟拼命提交。\n即使显示如\"everything is update\"这种反馈也不要轻信，尽量自己打开仓库看一眼。\n仓库名字一定要按照要求起，一定记得把main改成master，不然真的会不被读取到。\nddl一定要遵守。\n参考资料：\n廖雪峰git教程\nlab-3 reusability and maintainability oriented programming v3\n"
  },
  {
    "head": "2021-07-06",
    "paragraphs": [
      "软件构造之关于OOP的一些感悟",
      "Object-Oriented Programming面向对象的编程",
      "1. 类：",
      "类的定义包括“成员变量”的定义和“方法”的定义:成员变量用于描述该类型对象共同的数据结构，方法用于描述对象的行为，封装对象的功能。类定义完成后，对象的创建可通过new关键字创建，创建对象的过程通常被称为实例化。",
      "2. 对象：",
      "为了能够对实例化对象进行访问控制，需要用一个特殊的变量—引用。引用类型变量可以存放该类对象的地址信息，通常称为“指向该类的对象”。当一个引用类型变量指向该类的对象时，就可以通过这个变量对对象实施访问。除8种基本类型之外，用类、接口、数组等声明的变量都称为引用类型变量，简称“引用”。通过引用就可以访问对象的成员变量和调用方法。",
      "3. 继承：",
      "子类继承自父类。一般通用的属性和方法都放在父类，子类继承后也有这些属性和方法，并可以添加自己的属性和方法。一个类只能继承一个父类。继承不仅让代码变得简洁，还增加了代码的可重用性，拓展，修改。子类的构造方法必须通过super关键字调用父类的构造方法。如果子类的构造方法没有调用父类的构造方法，编译器会自动加入对父类无参构造的调用。override：当子类对象的重写方法被调用时（无论是通过子类的引用还是父类的引用 调用），运行的都是子类重写后的方法。这里注意一下override和overload的一些区别：overload是指在一个类中定义多个方法名相同参数列表不同的方法，在编译时根据参数个数和类型来决定绑定哪个方法；override是指在子类中定义和父类完全相同的方法，在运行时根据对象的类型不同（不是引用类型）来调用不同的版本。",
      "4. 封装：",
      "修饰符 本类 同一个包中的类 子类 其他类",
      "public 可以访问 可以访问 可以访问 可以访问",
      "protected 可以访问 可以访问 可以访问 不能访问",
      "默认 可以访问 可以访问 不能访问 不能访问",
      "private 可以访问 不能访问 不能访问 不能访问",
      "真的，这个图就很重要，默认这个其实也是default（我这么看的）",
      "5. 多态：",
      "多态是在继承的基础上实现的。多态的三要素：继承、重写和父类引用指向子类对象。父类引用指向不同子类对象时，调用相同的方法，呈现出不同的行为就是类多态特性。多态可以分为编译时多态和运行时多态。一个类型的引用在指向不同的对象时会有不同的实现；当然同样一个对象，造型成不同的类型时，也会有不同的功能。另外关注一下instanceof关键字，为了避免ClassCastException，可以通过instanceof关键字判读某个引用指向的对象是否可以强制为某类型。",
      "以上是本人学习了OOP之后结合课件和CSDN上的一些文章总结的结果，侵删，仅供参考和作为课程感悟用途。"
    ],
    "sentences": [
      "软件构造之关于OOP的一些感悟",
      "Object-Oriented Programming面向对象的编程",
      "1. 类：类的定义包括“成员变量”的定义和“方法”的定义:成员变量用于描述该类型对象共同的数据结构",
      "方法用于描述对象的行为",
      "封装对象的功能",
      "类定义完成后",
      "对象的创建可通过new关键字创建",
      "创建对象的过程通常被称为实例化",
      "2. 对象：为了能够对实例化对象进行访问控制",
      "需要用一个特殊的变量—引用",
      "引用类型变量可以存放该类对象的地址信息",
      "通常称为“指向该类的对象”",
      "当一个引用类型变量指向该类的对象时",
      "就可以通过这个变量对对象实施访问",
      "除8种基本类型之外",
      "用类、接口、数组等声明的变量都称为引用类型变量",
      "简称“引用”",
      "通过引用就可以访问对象的成员变量和调用方法",
      "3. 继承：子类继承自父类",
      "一般通用的属性和方法都放在父类",
      "子类继承后也有这些属性和方法",
      "并可以添加自己的属性和方法",
      "一个类只能继承一个父类",
      "继承不仅让代码变得简洁，还增加了代码的可重用性，拓展，修改",
      "子类的构造方法必须通过super关键字调用父类的构造方法",
      "如果子类的构造方法没有调用父类的构造方法",
      "编译器会自动加入对父类无参构造的调用",
      "override：当子类对象的重写方法被调用时（无论是通过子类的引用还是父类的引用 调用）",
      "运行的都是子类重写后的方法",
      "这里注意一下override和overload的一些区别：overload是指在一个类中定义多个方法名相同参数列表不同的方法",
      "在编译时根据参数个数和类型来决定绑定哪个方法；override是指在子类中定义和父类完全相同的方法",
      "在运行时根据对象的类型不同（不是引用类型）来调用不同的版本",
      "4. 封装：修饰符 本类 同一个包中的类 子类 其他类",
      "public 可以访问 可以访问 可以访问 可以访问",
      "protected 可以访问 可以访问 可以访问 不能访问",
      "默认 可以访问 可以访问 不能访问 不能访问",
      "private 可以访问 不能访问 不能访问 不能访问",
      "真的",
      "这个图就很重要",
      "默认这个其实也是default（我这么看的）",
      "5. 多态：多态是在继承的基础上实现的",
      "多态的三要素：继承、重写和父类引用指向子类对象",
      "父类引用指向不同子类对象时",
      "调用相同的方法",
      "呈现出不同的行为就是类多态特性",
      "多态可以分为编译时多态和运行时多态",
      "一个类型的引用在指向不同的对象时会有不同的实现；当然同样一个对象",
      "造型成不同的类型时",
      "也会有不同的功能",
      "另外关注一下instanceof关键字",
      "为了避免ClassCastException",
      "可以通过instanceof关键字判读某个引用指向的对象是否可以强制为某类型",
      "以上是本人学习了OOP之后结合课件和CSDN上的一些文章总结的结果",
      "侵删",
      "仅供参考和作为课程感悟用途"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "软件构造之关于OOP的一些感悟\nObject-Oriented Programming面向对象的编程\n1. 类：\n类的定义包括“成员变量”的定义和“方法”的定义:成员变量用于描述该类型对象共同的数据结构，方法用于描述对象的行为，封装对象的功能。类定义完成后，对象的创建可通过new关键字创建，创建对象的过程通常被称为实例化。\n2. 对象：\n为了能够对实例化对象进行访问控制，需要用一个特殊的变量—引用。引用类型变量可以存放该类对象的地址信息，通常称为“指向该类的对象”。当一个引用类型变量指向该类的对象时，就可以通过这个变量对对象实施访问。除8种基本类型之外，用类、接口、数组等声明的变量都称为引用类型变量，简称“引用”。通过引用就可以访问对象的成员变量和调用方法。\n3. 继承：\n子类继承自父类。一般通用的属性和方法都放在父类，子类继承后也有这些属性和方法，并可以添加自己的属性和方法。一个类只能继承一个父类。继承不仅让代码变得简洁，还增加了代码的可重用性，拓展，修改。子类的构造方法必须通过super关键字调用父类的构造方法。如果子类的构造方法没有调用父类的构造方法，编译器会自动加入对父类无参构造的调用。override：当子类对象的重写方法被调用时（无论是通过子类的引用还是父类的引用 调用），运行的都是子类重写后的方法。这里注意一下override和overload的一些区别：overload是指在一个类中定义多个方法名相同参数列表不同的方法，在编译时根据参数个数和类型来决定绑定哪个方法；override是指在子类中定义和父类完全相同的方法，在运行时根据对象的类型不同（不是引用类型）来调用不同的版本。\n4. 封装：\n修饰符 本类 同一个包中的类 子类 其他类\npublic 可以访问 可以访问 可以访问 可以访问\nprotected 可以访问 可以访问 可以访问 不能访问\n默认 可以访问 可以访问 不能访问 不能访问\nprivate 可以访问 不能访问 不能访问 不能访问\n真的，这个图就很重要，默认这个其实也是default（我这么看的）\n5. 多态：\n多态是在继承的基础上实现的。多态的三要素：继承、重写和父类引用指向子类对象。父类引用指向不同子类对象时，调用相同的方法，呈现出不同的行为就是类多态特性。多态可以分为编译时多态和运行时多态。一个类型的引用在指向不同的对象时会有不同的实现；当然同样一个对象，造型成不同的类型时，也会有不同的功能。另外关注一下instanceof关键字，为了避免ClassCastException，可以通过instanceof关键字判读某个引用指向的对象是否可以强制为某类型。\n以上是本人学习了OOP之后结合课件和CSDN上的一些文章总结的结果，侵删，仅供参考和作为课程感悟用途。\n"
  },
  {
    "head": "2021-07-06",
    "paragraphs": [
      "软件构造之ADT的一些感悟",
      "前言：",
      "抽象数据类型和表示独立性是我们能够将如何在程序中使用数据与数据结构本身的特定形式分离开。设计良好的抽象数据结构，通过封装来避免客户端获取数据内部表示，避免潜在的bug，起到在client和implementer之间建立防火墙的作用。",
      "抽象类型：",
      "强调“作用于数据上的操作”，程序员和用户无需关心数据如何具体存储的，秩序设计或使用操作即可。可以说，ADT是由操作定义的，于其内部如何实现无关。",
      "可变与不可变数据类型：可变数据类型的对象提供了可改变其内部数据的值 的操作，而不可变数据类型的操作不改变内部值，而实构造新的对象。举例而言，StringBuilder是String的可变版本，但这两个的Java类型肯定不相同，不能相互转换。",
      "抽象类型的操作：",
      "一个抽象类型包括构造器、生产器、观察器和变值器（改变对象属性的方法）。其中：构造器的可能实现为构造函数或静态函数，后者被称为一个工厂方法。变值器通常返回void，意味着改变了对象内部的某些状态（当然变值器也可以返回非空类型）。",
      "设计一个抽象类：",
      "设计简洁、一致的操作；2. 要足以支持客户对数据多做的所有操作需要，且用操作满足用户需要的难度要低；3. 要么抽象要么具体，不要混合。",
      "表示独立性：",
      "表示独立性指用户在使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。除非ADT的操作指明了具体的pre和post-condition，否则不能改变ADT的内部表示，可以看作spec规定了client和implementer之间的契约。代表独立性的魅力在于，某函数的现有客户端只依赖于它的公共方法的规约，而不是它的私有字段，我们可以在不检查和更改所有的客户端代码的情况下进行此更改。",
      "测试一个ADT：",
      "调用观察器观察剩下三个操作的结果是否满足spec，反过来，调用这三个操作等方法产生或改变对象，看结果是否正确来测试观察器。",
      "变量：",
      "由ADT负责不变量，与客户端的任何行为无关。因为我们总要假设有客户端由恶意地破坏ADT的不变量，所以需要不变量保持程序的正确性并且易发现错误。一旦发生表示泄露，不仅影响不变性，也影响表示独立性，即无法在不影响客户端地情况下改变其内部表示。防御式拷贝：对可变对象进行复制，避免将引用泄露给rep，确保类不变量在任何输入中存储，以最小化可变性。通常，我们检查所有ADT的陈宗座参数和返回类型，如果任何类型是可变的，则确保我们的实现不会返回对其表示的直接引用。最好的办法就是使用不可变的类型，彻底表示表示泄露。",
      "AF与RI：",
      "AT（抽象函数），表示R和A之间映射关系的函数，即如何去结视R中的每一个值为A中的每一个值。RI（表示不变性），表示某个具体的“表示”是否是“合法的”。"
    ],
    "sentences": [
      "软件构造之ADT的一些感悟",
      "前言：抽象数据类型和表示独立性是我们能够将如何在程序中使用数据与数据结构本身的特定形式分离开",
      "设计良好的抽象数据结构",
      "通过封装来避免客户端获取数据内部表示",
      "避免潜在的bug",
      "起到在client和implementer之间建立防火墙的作用",
      "抽象类型：强调“作用于数据上的操作”",
      "程序员和用户无需关心数据如何具体存储的",
      "秩序设计或使用操作即可",
      "可以说，ADT是由操作定义的，于其内部如何实现无关",
      "可变与不可变数据类型：可变数据类型的对象提供了可改变其内部数据的值 的操作",
      "而不可变数据类型的操作不改变内部值",
      "而实构造新的对象",
      "举例而言",
      "StringBuilder是String的可变版本",
      "但这两个的Java类型肯定不相同",
      "不能相互转换",
      "抽象类型的操作：一个抽象类型包括构造器、生产器、观察器和变值器（改变对象属性的方法）",
      "其中：构造器的可能实现为构造函数或静态函数",
      "后者被称为一个工厂方法",
      "变值器通常返回void",
      "意味着改变了对象内部的某些状态（当然变值器也可以返回非空类型）",
      "设计一个抽象类：设计简洁、一致的操作；2. 要足以支持客户对数据多做的所有操作需要",
      "且用操作满足用户需要的难度要低；3. 要么抽象要么具体",
      "不要混合",
      "表示独立性：表示独立性指用户在使用ADT时无需考虑其内部如何实现",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "除非ADT的操作指明了具体的pre和post-condition",
      "否则不能改变ADT的内部表示",
      "可以看作spec规定了client和implementer之间的契约",
      "代表独立性的魅力在于",
      "某函数的现有客户端只依赖于它的公共方法的规约",
      "而不是它的私有字段",
      "我们可以在不检查和更改所有的客户端代码的情况下进行此更改",
      "测试一个ADT：调用观察器观察剩下三个操作的结果是否满足spec",
      "反过来",
      "调用这三个操作等方法产生或改变对象",
      "看结果是否正确来测试观察器",
      "变量：由ADT负责不变量，与客户端的任何行为无关",
      "因为我们总要假设有客户端由恶意地破坏ADT的不变量",
      "所以需要不变量保持程序的正确性并且易发现错误",
      "一旦发生表示泄露",
      "不仅影响不变性",
      "也影响表示独立性",
      "即无法在不影响客户端地情况下改变其内部表示",
      "防御式拷贝：对可变对象进行复制",
      "避免将引用泄露给rep",
      "确保类不变量在任何输入中存储",
      "以最小化可变性",
      "通常",
      "我们检查所有ADT的陈宗座参数和返回类型",
      "如果任何类型是可变的",
      "则确保我们的实现不会返回对其表示的直接引用",
      "最好的办法就是使用不可变的类型，彻底表示表示泄露",
      "AF与RI：AT（抽象函数）",
      "表示R和A之间映射关系的函数",
      "即如何去结视R中的每一个值为A中的每一个值",
      "RI（表示不变性），表示某个具体的“表示”是否是“合法的”"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "软件构造之ADT的一些感悟\n前言：\n抽象数据类型和表示独立性是我们能够将如何在程序中使用数据与数据结构本身的特定形式分离开。设计良好的抽象数据结构，通过封装来避免客户端获取数据内部表示，避免潜在的bug，起到在client和implementer之间建立防火墙的作用。\n抽象类型：\n强调“作用于数据上的操作”，程序员和用户无需关心数据如何具体存储的，秩序设计或使用操作即可。可以说，ADT是由操作定义的，于其内部如何实现无关。\n可变与不可变数据类型：可变数据类型的对象提供了可改变其内部数据的值 的操作，而不可变数据类型的操作不改变内部值，而实构造新的对象。举例而言，StringBuilder是String的可变版本，但这两个的Java类型肯定不相同，不能相互转换。\n抽象类型的操作：\n一个抽象类型包括构造器、生产器、观察器和变值器（改变对象属性的方法）。其中：构造器的可能实现为构造函数或静态函数，后者被称为一个工厂方法。变值器通常返回void，意味着改变了对象内部的某些状态（当然变值器也可以返回非空类型）。\n设计一个抽象类：\n设计简洁、一致的操作；2. 要足以支持客户对数据多做的所有操作需要，且用操作满足用户需要的难度要低；3. 要么抽象要么具体，不要混合。\n表示独立性：\n表示独立性指用户在使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。除非ADT的操作指明了具体的pre和post-condition，否则不能改变ADT的内部表示，可以看作spec规定了client和implementer之间的契约。代表独立性的魅力在于，某函数的现有客户端只依赖于它的公共方法的规约，而不是它的私有字段，我们可以在不检查和更改所有的客户端代码的情况下进行此更改。\n测试一个ADT：\n调用观察器观察剩下三个操作的结果是否满足spec，反过来，调用这三个操作等方法产生或改变对象，看结果是否正确来测试观察器。\n变量：\n由ADT负责不变量，与客户端的任何行为无关。因为我们总要假设有客户端由恶意地破坏ADT的不变量，所以需要不变量保持程序的正确性并且易发现错误。一旦发生表示泄露，不仅影响不变性，也影响表示独立性，即无法在不影响客户端地情况下改变其内部表示。防御式拷贝：对可变对象进行复制，避免将引用泄露给rep，确保类不变量在任何输入中存储，以最小化可变性。通常，我们检查所有ADT的陈宗座参数和返回类型，如果任何类型是可变的，则确保我们的实现不会返回对其表示的直接引用。最好的办法就是使用不可变的类型，彻底表示表示泄露。\nAF与RI：\nAT（抽象函数），表示R和A之间映射关系的函数，即如何去结视R中的每一个值为A中的每一个值。RI（表示不变性），表示某个具体的“表示”是否是“合法的”。\n"
  },
  {
    "head": "2021-07-07",
    "paragraphs": [
      "软件构造之知识点总结1、3",
      "1. 软件构造的多维度视图",
      "1.1 By phases: build - and run-time views 按阶段划分：构造时/运行时视图",
      "1.2 By dynamics: moment and period views 按动态划分：时刻/阶段视图",
      "1.3 By levels: code and component views 按构造对象的层次划分：代码/构件视图",
      "2. 软件构造的阶段划分、各阶段的构造活动",
      "阶段1：build-time，构造活动为design、refactoring、build、version control、evolution",
      "阶段2：dumping、debug testing、build install deploy、profiling、tracing、logging",
      "3. 内部/外部的质量标准",
      "外部质量因素影响用户，内部质量因素影响软件本身和它的开发者，外部质量取决于内部质量。包括：正确性，健壮性，可扩展性，可复用性，保持设计的同构性，有效性，可移植性，易用性，功能性，及时性等等",
      "4. 软件配置管理SCM与版本控制系统VCS",
      "软件配置管理：追踪和控制软件的条件",
      "版本控制系统：本地版本控制系统：仓库存储于开发者本地机器无法共享和协作；",
      "集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作",
      "分布式版本控制系统：仓库存储与独立的服务器+每个开发者的本地机器",
      "5. Git的结构",
      "git仓库分为三部分：本地的CMDB、工作目录：本地文件系统",
      "以上为1、3的知识点文字总结，为本人针对软件构造学习所做，侵删"
    ],
    "sentences": [
      "软件构造之知识点总结1、3",
      "1. 软件构造的多维度视图",
      "1.1 By phases: build - and run-time views 按阶段划分：构造时/运行时视图",
      "1.2 By dynamics: moment and period views 按动态划分：时刻/阶段视图",
      "1.3 By levels: code and component views 按构造对象的层次划分：代码/构件视图",
      "2. 软件构造的阶段划分、各阶段的构造活动",
      "阶段1：build-time",
      "构造活动为design、refactoring、build、version control、evolution",
      "阶段2：dumping、debug testing、build install deploy、profiling、tracing、logging",
      "3. 内部/外部的质量标准",
      "外部质量因素影响用户",
      "内部质量因素影响软件本身和它的开发者",
      "外部质量取决于内部质量",
      "包括：正确性",
      "健壮性",
      "可扩展性",
      "可复用性",
      "保持设计的同构性",
      "有效性",
      "可移植性",
      "易用性",
      "功能性",
      "及时性等等",
      "4. 软件配置管理SCM与版本控制系统VCS",
      "软件配置管理：追踪和控制软件的条件",
      "版本控制系统：本地版本控制系统：仓库存储于开发者本地机器无法共享和协作；集中式版本控制系统：仓库存储于独立的服务器",
      "支持多开发者之间的协作",
      "分布式版本控制系统：仓库存储与独立的服务器+每个开发者的本地机器",
      "5. Git的结构",
      "git仓库分为三部分：本地的CMDB、工作目录：本地文件系统",
      "以上为1、3的知识点文字总结",
      "为本人针对软件构造学习所做",
      "侵删"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "软件构造之知识点总结1、3\n1. 软件构造的多维度视图\n1.1 By phases: build - and run-time views 按阶段划分：构造时/运行时视图\n1.2 By dynamics: moment and period views 按动态划分：时刻/阶段视图\n1.3 By levels: code and component views 按构造对象的层次划分：代码/构件视图\n2. 软件构造的阶段划分、各阶段的构造活动\n阶段1：build-time，构造活动为design、refactoring、build、version control、evolution\n阶段2：dumping、debug testing、build install deploy、profiling、tracing、logging\n3. 内部/外部的质量标准\n外部质量因素影响用户，内部质量因素影响软件本身和它的开发者，外部质量取决于内部质量。包括：正确性，健壮性，可扩展性，可复用性，保持设计的同构性，有效性，可移植性，易用性，功能性，及时性等等\n4. 软件配置管理SCM与版本控制系统VCS\n软件配置管理：追踪和控制软件的条件\n版本控制系统：本地版本控制系统：仓库存储于开发者本地机器无法共享和协作；\n集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作\n分布式版本控制系统：仓库存储与独立的服务器+每个开发者的本地机器\n5. Git的结构\ngit仓库分为三部分：本地的CMDB、工作目录：本地文件系统\n以上为1、3的知识点文字总结，为本人针对软件构造学习所做，侵删\n"
  },
  {
    "head": "2021-07-07",
    "paragraphs": [
      "软件构造之关于委派delegation的一些感悟",
      "1. delegate的含义：",
      "委派模式（Delegate）是面向对象设计模式中常用的一种模式。这种模式的原理为类B和类A是两个互相没有任何关系的类，B具有和A一模一样的方法和属性；并且调用B中的方法，属性就是调用A中同名的方法和属性。B好像就是一个受A授权委托的中介。第三方的代码不需要知道A的存在，也不需要和A发生直接的联系，通过B就可以直接使用A的功能，这样既能够使用到A的各种公能，又能够很好的将A保护起来了。",
      "2. delegate的类型：",
      "2.1 A use B：B类对象在A类中出现，但是是以局部变量或是方法参数的形式出现的。A类中并没有B类的对象作为域。一般称这种delegation为临时性的delegation。",
      "2.2 A has B：B类对象在A类中出现，B类的对象是A类的域之一。B类对象通过A类对象的constructor方法或其它方法从外部输入A类对象。A has B有两种情况：Association为A类对象和B类对象之间并没有从属关系；Aggregation为A类对象由B类聚合而成，但是B类可以脱离A类单独存在。一般称这种delegation为永久性的delegation。",
      "2.3 A ispartof B： B类对象在A类中出现，B类的对象是A类的域之一。B类对象在A类对象内创建。B类对象不能脱离A类对象独立存在。一般称这种delegation为永久性的delegation。",
      "3. delegate的使用场景：",
      "在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。",
      "4. 静态delegate：",
      "代理者的代码由程序员自己或通过一些自动化工具生成固定的代码再对其进行编译，代码运行前代理类的class编译文件就已经存在。",
      "5. 动态gelegate：",
      "通过反射机制动态的生成代理者的对象，代理谁只有在执行时才知道。java提供了一个便捷的动态代理接口InvocationHandler,实现该接口需要重写invoke()方法。实现动态代理包括三步：1 新建委托类；2 实现InvocationHandler接口，这是负责连接代理类和委托类的中间类必须实现的接口；3 通过Proxy类创建代理类对象。",
      "以上关于delegate的一些感悟是基于课程学习和csdn的一些文章得来，用于课程总结感悟，侵删。"
    ],
    "sentences": [
      "软件构造之关于委派delegation的一些感悟",
      "1. delegate的含义：委派模式（Delegate）是面向对象设计模式中常用的一种模式",
      "这种模式的原理为类B和类A是两个互相没有任何关系的类",
      "B具有和A一模一样的方法和属性；并且调用B中的方法",
      "属性就是调用A中同名的方法和属性",
      "B好像就是一个受A授权委托的中介",
      "第三方的代码不需要知道A的存在",
      "也不需要和A发生直接的联系",
      "通过B就可以直接使用A的功能",
      "这样既能够使用到A的各种公能",
      "又能够很好的将A保护起来了",
      "2. delegate的类型：2.1 A use B：B类对象在A类中出现",
      "但是是以局部变量或是方法参数的形式出现的",
      "A类中并没有B类的对象作为域",
      "一般称这种delegation为临时性的delegation",
      "2.2 A has B：B类对象在A类中出现",
      "B类的对象是A类的域之一",
      "B类对象通过A类对象的constructor方法或其它方法从外部输入A类对象",
      "A has B有两种情况：Association为A类对象和B类对象之间并没有从属关系；Aggregation为A类对象由B类聚合而成",
      "但是B类可以脱离A类单独存在",
      "一般称这种delegation为永久性的delegation",
      "2.3 A ispartof B： B类对象在A类中出现",
      "B类的对象是A类的域之一",
      "B类对象在A类对象内创建",
      "B类对象不能脱离A类对象独立存在",
      "一般称这种delegation为永久性的delegation",
      "3. delegate的使用场景：在某些情况下",
      "我们不希望或是不能直接访问对象 A",
      "而是通过访问一个中介对象 B",
      "由 B 去访问 A 达成目的",
      "这种方式我们就称为代理",
      "这里对象 A 所属类我们称为委托类",
      "也称为被代理类",
      "对象 B 所属类称为代理类",
      "4. 静态delegate：代理者的代码由程序员自己或通过一些自动化工具生成固定的代码再对其进行编译",
      "代码运行前代理类的class编译文件就已经存在",
      "5. 动态gelegate：通过反射机制动态的生成代理者的对象",
      "代理谁只有在执行时才知道",
      "java提供了一个便捷的动态代理接口InvocationHandler,实现该接口需要重写invoke()方法",
      "实现动态代理包括三步：1 新建委托类；2 实现InvocationHandler接口",
      "这是负责连接代理类和委托类的中间类必须实现的接口；3 通过Proxy类创建代理类对象",
      "以上关于delegate的一些感悟是基于课程学习和csdn的一些文章得来",
      "用于课程总结感悟",
      "侵删"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "软件构造之关于委派delegation的一些感悟\n1. delegate的含义：\n委派模式（Delegate）是面向对象设计模式中常用的一种模式。这种模式的原理为类B和类A是两个互相没有任何关系的类，B具有和A一模一样的方法和属性；并且调用B中的方法，属性就是调用A中同名的方法和属性。B好像就是一个受A授权委托的中介。第三方的代码不需要知道A的存在，也不需要和A发生直接的联系，通过B就可以直接使用A的功能，这样既能够使用到A的各种公能，又能够很好的将A保护起来了。\n2. delegate的类型：\n2.1 A use B：B类对象在A类中出现，但是是以局部变量或是方法参数的形式出现的。A类中并没有B类的对象作为域。一般称这种delegation为临时性的delegation。\n2.2 A has B：B类对象在A类中出现，B类的对象是A类的域之一。B类对象通过A类对象的constructor方法或其它方法从外部输入A类对象。A has B有两种情况：Association为A类对象和B类对象之间并没有从属关系；Aggregation为A类对象由B类聚合而成，但是B类可以脱离A类单独存在。一般称这种delegation为永久性的delegation。\n2.3 A ispartof B： B类对象在A类中出现，B类的对象是A类的域之一。B类对象在A类对象内创建。B类对象不能脱离A类对象独立存在。一般称这种delegation为永久性的delegation。\n3. delegate的使用场景：\n在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。\n4. 静态delegate：\n代理者的代码由程序员自己或通过一些自动化工具生成固定的代码再对其进行编译，代码运行前代理类的class编译文件就已经存在。\n5. 动态gelegate：\n通过反射机制动态的生成代理者的对象，代理谁只有在执行时才知道。java提供了一个便捷的动态代理接口InvocationHandler,实现该接口需要重写invoke()方法。实现动态代理包括三步：1 新建委托类；2 实现InvocationHandler接口，这是负责连接代理类和委托类的中间类必须实现的接口；3 通过Proxy类创建代理类对象。\n以上关于delegate的一些感悟是基于课程学习和csdn的一些文章得来，用于课程总结感悟，侵删。\n"
  },
  {
    "head": "软件构造之知识总结--软件构造基础后六讲",
    "paragraphs": [
      "软件构造后六讲知识点",
      "一点在ppt时认为重要的知识点，以及个人的一些理解如下："
    ],
    "sentences": [
      "软件构造后六讲知识点",
      "一点在ppt时认为重要的知识点，以及个人的一些理解如下："
    ],
    "codes": [],
    "date": "2021-06-29",
    "text": "软件构造后六讲知识点\n一点在ppt时认为重要的知识点，以及个人的一些理解如下：\n"
  },
  {
    "head": "软件构造之知识总结--软件构造基础前六讲",
    "paragraphs": [
      "软件构造前六讲知识点整理",
      "在看ppt时的一些重点整理，和自己个人的一些理解如下："
    ],
    "sentences": [
      "软件构造前六讲知识点整理",
      "在看ppt时的一些重点整理，和自己个人的一些理解如下："
    ],
    "codes": [],
    "date": "2021-05-06",
    "text": "软件构造前六讲知识点整理\n在看ppt时的一些重点整理，和自己个人的一些理解如下：\n"
  },
  {
    "head": "软件构造--immutability mutability的区别简述",
    "paragraphs": [
      "最后阶段还是对可变性这里不是很理解，在这总结一下：",
      "Immutability 不变性，是key design principle",
      "不变数据类型：一旦被创建，其值就不能被改变",
      "String是典型的不变类型，每次改变的时候实际上都是new了一个新的String。",
      "对比之下，StringBuilder是字符串的可变类，修改的时候不会创建新的变量。",
      "对于所有的数据类型来说，常见的不变类包括全部的基础类型和他们的包装类(Integer等），以及String和BigInteger这样的对象类。其余的Object类都是可变的。对于像set,list等容器来说，由于他们有add,remove这样的mutator函数，它们在创建之后都是可以被改变的，所以他们都是可变的。若想把他们变成不可变的可以借用collaction里的wrapper把他们变成undefinedset等，程序就会使你的set、list无法再执行mutator，也就是不可变。在这种情况下如果我们还调用mutator的话会在动态检查中被发现并抛出异常。",
      "所有的不变类都是没有mutator的。",
      "同样我们除了数据类型的不变性，还有引用的不变性。数据类型的不变性指一个数据被创建出来之后便不能被改变，而引用的不变性则指当一个变量引用另一个变量之后，这个变量不可以再引用别的变量，即x=y后不能执行x=z。要想实现引用的不变性需要我们用final去修饰变量。"
    ],
    "sentences": [
      "最后阶段还是对可变性这里不是很理解",
      "在这总结一下：Immutability 不变性",
      "是key design principle",
      "不变数据类型：一旦被创建，其值就不能被改变",
      "String是典型的不变类型",
      "每次改变的时候实际上都是new了一个新的String",
      "对比之下",
      "StringBuilder是字符串的可变类",
      "修改的时候不会创建新的变量",
      "对于所有的数据类型来说",
      "常见的不变类包括全部的基础类型和他们的包装类(Integer等）",
      "以及String和BigInteger这样的对象类",
      "其余的Object类都是可变的",
      "对于像set,list等容器来说",
      "由于他们有add,remove这样的mutator函数",
      "它们在创建之后都是可以被改变的",
      "所以他们都是可变的",
      "若想把他们变成不可变的可以借用collaction里的wrapper把他们变成undefinedset等",
      "程序就会使你的set、list无法再执行mutator",
      "也就是不可变",
      "在这种情况下如果我们还调用mutator的话会在动态检查中被发现并抛出异常",
      "所有的不变类都是没有mutator的",
      "同样我们除了数据类型的不变性，还有引用的不变性",
      "数据类型的不变性指一个数据被创建出来之后便不能被改变",
      "而引用的不变性则指当一个变量引用另一个变量之后",
      "这个变量不可以再引用别的变量",
      "即x=y后不能执行x=z",
      "要想实现引用的不变性需要我们用final去修饰变量"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "最后阶段还是对可变性这里不是很理解，在这总结一下：\nImmutability 不变性，是key design principle\n不变数据类型：一旦被创建，其值就不能被改变\nString是典型的不变类型，每次改变的时候实际上都是new了一个新的String。\n对比之下，StringBuilder是字符串的可变类，修改的时候不会创建新的变量。\n对于所有的数据类型来说，常见的不变类包括全部的基础类型和他们的包装类(Integer等），以及String和BigInteger这样的对象类。其余的Object类都是可变的。对于像set,list等容器来说，由于他们有add,remove这样的mutator函数，它们在创建之后都是可以被改变的，所以他们都是可变的。若想把他们变成不可变的可以借用collaction里的wrapper把他们变成undefinedset等，程序就会使你的set、list无法再执行mutator，也就是不可变。在这种情况下如果我们还调用mutator的话会在动态检查中被发现并抛出异常。\n所有的不变类都是没有mutator的。\n同样我们除了数据类型的不变性，还有引用的不变性。数据类型的不变性指一个数据被创建出来之后便不能被改变，而引用的不变性则指当一个变量引用另一个变量之后，这个变量不可以再引用别的变量，即x=y后不能执行x=z。要想实现引用的不变性需要我们用final去修饰变量。\n"
  },
  {
    "head": "软件构造--关于等价性和override的一点理解和总结",
    "paragraphs": [
      "在老师上课的ppt中，关于等价性和override overload方面还是有一点迷糊，所以来梳理一下，总结一下。其实也不是总结，就是分享一下这个菜鸡的心理路程。",
      "在刚刚理解到时觉得是正确的，但下课后和室友讨论时，又不太能理解这个重载和重写的区别。",
      "在没有学习这节课前，我是觉得这个考的不就是1+1=2吗，怎么会不相等，甚至不知道为什么要写一个hashcode。实践出真知，见下图：",
      "（写的时候变量名就随便写了，不太严谨见谅）",
      "答案是false，其实也不出意料，一般都是又特点的题老师才能专门提出来。但我还是觉得hashcode能有什么用，于是给他注释了：",
      "答案当然还是false，同时我也想是不是object的问题（这里可以看出来本人的基础知识叭太行），这里这样改不改其实都是一样的不会影响答案。",
      "于是我按照老师给的方法来进行",
      "还是不对，这是为什么呢，我们安装这个想法来说应该是对的，我就发现，我并没有理解到为什么要这么写。",
      "其实这里是对hashset的equals函数的override，同时必须要有hashcode的override，而hashset的equals的参数是object，而我这里把参数改变了，就变成了重载，当然就比较是错误的，因为根本没有将自己写的这个类给加载进去，比较还是按照hashset最原来的方式比较（必须是同一个才行）。这里就是我没有理解将equals的参数写错了。",
      "改正如下：",
      "注意重写和重载的区别："
    ],
    "sentences": [
      "在老师上课的ppt中",
      "关于等价性和override overload方面还是有一点迷糊",
      "所以来梳理一下",
      "总结一下",
      "其实也不是总结，就是分享一下这个菜鸡的心理路程",
      "在刚刚理解到时觉得是正确的",
      "但下课后和室友讨论时",
      "又不太能理解这个重载和重写的区别",
      "在没有学习这节课前",
      "我是觉得这个考的不就是1+1=2吗",
      "怎么会不相等",
      "甚至不知道为什么要写一个hashcode",
      "实践出真知",
      "见下图：（写的时候变量名就随便写了",
      "不太严谨见谅）",
      "答案是false",
      "其实也不出意料",
      "一般都是又特点的题老师才能专门提出来",
      "但我还是觉得hashcode能有什么用",
      "于是给他注释了：答案当然还是false",
      "同时我也想是不是object的问题（这里可以看出来本人的基础知识叭太行）",
      "这里这样改不改其实都是一样的不会影响答案",
      "于是我按照老师给的方法来进行",
      "还是不对",
      "这是为什么呢",
      "我们安装这个想法来说应该是对的",
      "我就发现",
      "我并没有理解到为什么要这么写",
      "其实这里是对hashset的equals函数的override",
      "同时必须要有hashcode的override",
      "而hashset的equals的参数是object",
      "而我这里把参数改变了",
      "就变成了重载",
      "当然就比较是错误的",
      "因为根本没有将自己写的这个类给加载进去",
      "比较还是按照hashset最原来的方式比较（必须是同一个才行）",
      "这里就是我没有理解将equals的参数写错了",
      "改正如下：注意重写和重载的区别："
    ],
    "codes": [],
    "date": "2021-06-13",
    "text": "在老师上课的ppt中，关于等价性和override overload方面还是有一点迷糊，所以来梳理一下，总结一下。其实也不是总结，就是分享一下这个菜鸡的心理路程。\n在刚刚理解到时觉得是正确的，但下课后和室友讨论时，又不太能理解这个重载和重写的区别。\n在没有学习这节课前，我是觉得这个考的不就是1+1=2吗，怎么会不相等，甚至不知道为什么要写一个hashcode。实践出真知，见下图：\n（写的时候变量名就随便写了，不太严谨见谅）\n答案是false，其实也不出意料，一般都是又特点的题老师才能专门提出来。但我还是觉得hashcode能有什么用，于是给他注释了：\n答案当然还是false，同时我也想是不是object的问题（这里可以看出来本人的基础知识叭太行），这里这样改不改其实都是一样的不会影响答案。\n于是我按照老师给的方法来进行\n还是不对，这是为什么呢，我们安装这个想法来说应该是对的，我就发现，我并没有理解到为什么要这么写。\n其实这里是对hashset的equals函数的override，同时必须要有hashcode的override，而hashset的equals的参数是object，而我这里把参数改变了，就变成了重载，当然就比较是错误的，因为根本没有将自己写的这个类给加载进去，比较还是按照hashset最原来的方式比较（必须是同一个才行）。这里就是我没有理解将equals的参数写错了。\n改正如下：\n注意重写和重载的区别：\n"
  },
  {
    "head": "Day 1 实验课 Java的环境配置与Java数组",
    "paragraphs": [
      "面向对象的程序设计语言• 特点：- 简单性简化c++ 内存模型等- 面向对象- 安全性",
      "c++与Java的引用不是一回事javac（编译器）；Java（解释器）",
      "数组越界？",
      "Content 3 Java程序的数组",
      "实验目的：",
      "1、掌握并灵活运用一维数组，理解数组是容器",
      "2、掌握数组的赋值与复制",
      "实验内容：",
      "1、任意输入1到100间的整数，以0结束，然后计算每个数出现的次数",
      "2、定义两个数组a和b，并初始化，执行a=b后输出a和b",
      "3、定义两个数组a，并初始化，复制数组a",
      "View Code",
      "补充：如果在print的时候直接print(i+a[i])的话会将二者相加后输出，所以要实现并排输出的话要使用print(i+\"\"+a[i])",
      "Content 4 可选题：多项式加法"
    ],
    "sentences": [
      "面向对象的程序设计语言• 特点：- 简单性简化c++ 内存模型等- 面向对象- 安全性",
      "c++与Java的引用不是一回事javac（编译器）；Java（解释器）",
      "数组越界？",
      "Content 3 Java程序的数组",
      "实验目的：1、掌握并灵活运用一维数组，理解数组是容器",
      "2、掌握数组的赋值与复制",
      "实验内容：1、任意输入1到100间的整数",
      "以0结束",
      "然后计算每个数出现的次数",
      "2、定义两个数组a和b，并初始化，执行a=b后输出a和b",
      "3、定义两个数组a，并初始化，复制数组a",
      "View Code",
      "补充：如果在print的时候直接print(i+a[i])的话会将二者相加后输出",
      "所以要实现并排输出的话要使用print(i+\"\"+a[i])",
      "Content 4 可选题：多项式加法"
    ],
    "codes": [
      " 1 package hello;\n 2 \n 3 import java.util.Scanner;\n 4 \n 5 public class Hellojava {\n 6     public static void main(String[] args) {\n 7         \n 8         Scanner in =  new Scanner(System.in);\n 9 \n10         int[] a = new int [100];\n11         int x;\n12         x = in.nextInt();\n13         while(x!=0)\n14         {\n15             a[x-1]++;\n16             x=in.nextInt();\n17         }\n18         for(int i=0;i<a.length;i++)\n19         {\n20             if(a[i]!=0)\n21                 System.out.print(i+1+\" \"+a[i]);\n22         }\n23         \n24     }\n25 }",
      " 1 package hello;\n 2 \n 3 public class test1 {\n 4 \n 5     public static void main(String[] args) {\n 6         // TODO Auto-generated method stub\n 7         int[] a= {1,2,3,4,5};\n 8         int[] b=a;\n 9         b[0]++;\n10         for(int i=0;i<a.length;i++)\n11         {\n12             System.out.println(a[i]);\n13         }\n14     }\n15 \n16 }",
      "2\n2\n3\n4\n5",
      " 1 package hello;\n 2 \n 3 public class test2 {\n 4 \n 5     public static void main(String[] args) {\n 6         // TODO Auto-generated method stub\n 7         int[] a = {1,2,3,4,5,6,7,8,9,0};\n 8         int[] b = new int [10];\n 9         for(int i=0;i<a.length;i++)\n10         {\n11             b[i]=a[i];\n12         }\n13         a[0]=6;\n14         for(int i=0;i<b.length;i++)\n15         {\n16             System.out.println(b[i]);\n17         }\n18     }\n19 \n20 }",
      "1\n2\n3\n4\n5\n6\n7\n8\n9\n0",
      " 1 package hello;\n 2 \n 3 import java.util.Scanner;\n 4 \n 5 public class test3 {\n 6 \n 7     public static void main(String[] args) {\n 8         // TODO Auto-generated method stub\n 9         Scanner in = new Scanner(System.in);\n10         int[] a = new int [100];\n11         int x,y,q,p;\n12         x = in.nextInt();\n13         y = in.nextInt();\n14         q=x;\n15         a[q]=y;\n16         while(x>0)\n17         {\n18             a[x]=y;\n19             x = in.nextInt();\n20             y = in.nextInt();\n21         }\n22         a[0]=y;\n23         x = in.nextInt();\n24         y = in.nextInt();\n25         if(x>q)\n26         {\n27             q=x;\n28             a[q]=y;\n29         }\n30         while(x>0)\n31         {\n32             a[x]+=y;\n33             x = in.nextInt();\n34             y = in.nextInt();\n35         }\n36         a[0]+=y;\n37         System.out.print(a[q]+\"x\"+q);\n38         for(int i=q-1;i>0;i--)\n39         {\n40             if(a[i]!=0)\n41             {\n42                 if(a[i]>0)\n43                     System.out.print(\"+\");\n44                 System.out.print(a[i]+\"x\");\n45                 if(i!=1)\n46                     System.out.print(i);\n47             }\n48         }\n49         if(a[0]>0)\n50         {\n51             System.out.print(\"+\"+a[0]);\n52         }else if(a[0]<0){\n53             System.out.print(a[0]);\n54         }\n55     }\n56 \n57 }"
    ],
    "date": "2020-07-01",
    "text": "面向对象的程序设计语言• 特点：- 简单性简化c++ 内存模型等- 面向对象- 安全性\nc++与Java的引用不是一回事javac（编译器）；Java（解释器）\n数组越界？\nContent 3 Java程序的数组\n实验目的：\n1、掌握并灵活运用一维数组，理解数组是容器\n2、掌握数组的赋值与复制\n实验内容：\n1、任意输入1到100间的整数，以0结束，然后计算每个数出现的次数\n2、定义两个数组a和b，并初始化，执行a=b后输出a和b\n3、定义两个数组a，并初始化，复制数组a\nView Code\n补充：如果在print的时候直接print(i+a[i])的话会将二者相加后输出，所以要实现并排输出的话要使用print(i+\"\"+a[i])\nContent 4 可选题：多项式加法\n"
  },
  {
    "head": "关于AF、RI",
    "paragraphs": [
      "思考一下两个值域之间的关系︰",
      "表示域(space of representation values)里面包含的是值具体的实现实体。在简单的情况下，一个抽象类型只需要实现为单个的对象，但是更常见的情况是使用一个很多对象的网络。",
      "抽象域里面包含的则是类型设计时支持使用的值。这些值是由表示域\"抽象/想象\"出来的，也是使用者关注的。例如，一个无限整数对象的抽象域是整个整数域，但是它的实现域可能是一个由原始整数类型〈有限)组成的数组实现的，而使用者只关注抽象域。",
      "但是，实现者是非常\"在意\"表示域(和抽象域）)的，因为实现者的责任就是实现表示域到抽象域的转换（映射)。",
      "选择用字符串来表示一个字符集合︰",
      "如上图所示，表示域R包含的是我们的实现实体（字符串)，而抽象域里面是抽象类型表示的字符集合，我们用箭头表示这两个域之间的映射关系。这里要注意几点︰",
      "·每一个抽象值都是由表示值映射而来。我们之前说过实现抽象类型的意义在于支持对于抽象值的操作，即我们需要能够创建和管理所有的抽象值，因此它们也必须是可表示的。",
      "·一些抽象值是被多个表示值映射而来的。这是因为表示方法并不是固定的，我们可以灵活的表示一个抽象值。",
      "·不是所有的表示值都能映射到抽象域中。在上面这个例子中，\"abbc\"就没有被映射。因为我们已经确定了表示值的字符串中不能含有重复的字符—―这样我们的remove方法就能在遇到第一个对应字符的时候停止，因为我们知道没有重复的字符。",
      "由于我们不可能对每一个映射一一解释，为了描述这种对应关系和这两个域，我们再定义两个概念∶抽象函数abstraction function是表示值到其对应的抽象值的映射∶",
      "AF :R →A",
      "快照图中的箭头表示的就是抽象函数，可以看出，这种映射是满射，但不一定是单射(不一定是双射)。表示不变量rep invariant是表示值到布尔值的映射︰",
      "Rl:R - boolean",
      "对于表示值r，当且仅当r被AF映射到了A，Rl(r)为真。换句话说，RI告诉了我们哪些表示值是\"良好组织\"的(能够去表示A中的抽象值)，在下图中，绿色表示的就是Rl(r)为真的部分，AF只在这个子集上有定义。",
      "对同一个定义域，有不同的表示不变量",
      "总之，一个ADT的实现不仅是选择表示域(规格说明)和抽象域〈具体实现)，同时也要决定哪一些表示值是合法的(表示不变量)，合法表示会被怎么解释/映射(抽象函数)。"
    ],
    "sentences": [
      "思考一下两个值域之间的关系︰",
      "表示域(space of representation values)里面包含的是值具体的实现实体",
      "在简单的情况下",
      "一个抽象类型只需要实现为单个的对象",
      "但是更常见的情况是使用一个很多对象的网络",
      "抽象域里面包含的则是类型设计时支持使用的值",
      "这些值是由表示域\"抽象/想象\"出来的，也是使用者关注的",
      "例如",
      "一个无限整数对象的抽象域是整个整数域",
      "但是它的实现域可能是一个由原始整数类型〈有限)组成的数组实现的",
      "而使用者只关注抽象域",
      "但是",
      "实现者是非常\"在意\"表示域(和抽象域）)的",
      "因为实现者的责任就是实现表示域到抽象域的转换（映射)",
      "选择用字符串来表示一个字符集合︰",
      "如上图所示",
      "表示域R包含的是我们的实现实体（字符串)",
      "而抽象域里面是抽象类型表示的字符集合",
      "我们用箭头表示这两个域之间的映射关系",
      "这里要注意几点︰",
      "·每一个抽象值都是由表示值映射而来",
      "我们之前说过实现抽象类型的意义在于支持对于抽象值的操作",
      "即我们需要能够创建和管理所有的抽象值",
      "因此它们也必须是可表示的",
      "·一些抽象值是被多个表示值映射而来的",
      "这是因为表示方法并不是固定的，我们可以灵活的表示一个抽象值",
      "·不是所有的表示值都能映射到抽象域中",
      "在上面这个例子中，\"abbc\"就没有被映射",
      "因为我们已经确定了表示值的字符串中不能含有重复的字符—―这样我们的remove方法就能在遇到第一个对应字符的时候停止",
      "因为我们知道没有重复的字符",
      "由于我们不可能对每一个映射一一解释",
      "为了描述这种对应关系和这两个域",
      "我们再定义两个概念∶抽象函数abstraction function是表示值到其对应的抽象值的映射∶",
      "AF :R →A",
      "快照图中的箭头表示的就是抽象函数",
      "可以看出",
      "这种映射是满射",
      "但不一定是单射(不一定是双射)",
      "表示不变量rep invariant是表示值到布尔值的映射︰",
      "Rl:R - boolean",
      "对于表示值r，当且仅当r被AF映射到了A，Rl(r)为真",
      "换句话说",
      "RI告诉了我们哪些表示值是\"良好组织\"的(能够去表示A中的抽象值)",
      "在下图中",
      "绿色表示的就是Rl(r)为真的部分",
      "AF只在这个子集上有定义",
      "对同一个定义域，有不同的表示不变量",
      "总之",
      "一个ADT的实现不仅是选择表示域(规格说明)和抽象域〈具体实现)",
      "同时也要决定哪一些表示值是合法的(表示不变量)",
      "合法表示会被怎么解释/映射(抽象函数)"
    ],
    "codes": [
      "public class charset {\nprivate string s;...\n}",
      "public class Charset {\nprivate string s;ll Rep invariant :\nl ls.length( ) is even\nl ls[0]<= s[1]<= ... <= s[s.length( )-1]l l Abstraction function:\nllAF( s) = union of { c \\ s[2i]<= c<= s[2i+1] }l /\nfor all 0<= i < s.length( )/2\n...\n}"
    ],
    "date": "2021-07-07",
    "text": "思考一下两个值域之间的关系︰\n表示域(space of representation values)里面包含的是值具体的实现实体。在简单的情况下，一个抽象类型只需要实现为单个的对象，但是更常见的情况是使用一个很多对象的网络。\n抽象域里面包含的则是类型设计时支持使用的值。这些值是由表示域\"抽象/想象\"出来的，也是使用者关注的。例如，一个无限整数对象的抽象域是整个整数域，但是它的实现域可能是一个由原始整数类型〈有限)组成的数组实现的，而使用者只关注抽象域。\n但是，实现者是非常\"在意\"表示域(和抽象域）)的，因为实现者的责任就是实现表示域到抽象域的转换（映射)。\n选择用字符串来表示一个字符集合︰\n如上图所示，表示域R包含的是我们的实现实体（字符串)，而抽象域里面是抽象类型表示的字符集合，我们用箭头表示这两个域之间的映射关系。这里要注意几点︰\n·每一个抽象值都是由表示值映射而来。我们之前说过实现抽象类型的意义在于支持对于抽象值的操作，即我们需要能够创建和管理所有的抽象值，因此它们也必须是可表示的。\n·一些抽象值是被多个表示值映射而来的。这是因为表示方法并不是固定的，我们可以灵活的表示一个抽象值。\n·不是所有的表示值都能映射到抽象域中。在上面这个例子中，\"abbc\"就没有被映射。因为我们已经确定了表示值的字符串中不能含有重复的字符—―这样我们的remove方法就能在遇到第一个对应字符的时候停止，因为我们知道没有重复的字符。\n由于我们不可能对每一个映射一一解释，为了描述这种对应关系和这两个域，我们再定义两个概念∶抽象函数abstraction function是表示值到其对应的抽象值的映射∶\nAF :R →A\n快照图中的箭头表示的就是抽象函数，可以看出，这种映射是满射，但不一定是单射(不一定是双射)。表示不变量rep invariant是表示值到布尔值的映射︰\nRl:R - boolean\n对于表示值r，当且仅当r被AF映射到了A，Rl(r)为真。换句话说，RI告诉了我们哪些表示值是\"良好组织\"的(能够去表示A中的抽象值)，在下图中，绿色表示的就是Rl(r)为真的部分，AF只在这个子集上有定义。\n对同一个定义域，有不同的表示不变量\n总之，一个ADT的实现不仅是选择表示域(规格说明)和抽象域〈具体实现)，同时也要决定哪一些表示值是合法的(表示不变量)，合法表示会被怎么解释/映射(抽象函数)。\n"
  },
  {
    "head": "Java正则表达式的元字符",
    "paragraphs": [
      "Lab3需要对字符串进行匹配，这里整理了一下元字符：",
      "1.限定符",
      "2.选择匹配符",
      "3.分组组合和反向引用符",
      "4.特殊字符",
      "5.字符匹配符",
      "6.定位符",
      "转义号",
      "可接受的字符列表",
      "[^]",
      "不可接受的字符列表",
      "连字符",
      "匹配除\\n以外任意字符",
      "\\\\d",
      "匹配单个数字字符",
      "\\\\D",
      "匹配单个非数字字符",
      "\\\\w",
      "匹配单个数字、大小写字母字符",
      "匹配单个非数字、大小写字母字符",
      "匹配“|”之前或之后的表达式",
      "指定的字符重复0/n次",
      "指定的字符重复1/n次",
      "指定的字符重复0/1次",
      "｛n｝",
      "只能输入n个字符",
      "｛n,｝",
      "指定至少n个匹配",
      "｛n,m｝",
      "指定至少n个但不多于m个匹配",
      "指定开始字符",
      "指定结束字符",
      "\\\\b",
      "匹配目标字符串的边界",
      "\\bB",
      "匹配目标字符串的非边界",
      "匹配换页符",
      "匹配换行符",
      "匹配回车"
    ],
    "sentences": [
      "Lab3需要对字符串进行匹配",
      "这里整理了一下元字符：1.限定符",
      "2.选择匹配符",
      "3.分组组合和反向引用符",
      "4.特殊字符",
      "5.字符匹配符",
      "6.定位符",
      "转义号",
      "可接受的字符列表",
      "[^]",
      "不可接受的字符列表",
      "连字符",
      "匹配除\\n以外任意字符",
      "\\\\d",
      "匹配单个数字字符",
      "\\\\D",
      "匹配单个非数字字符",
      "\\\\w",
      "匹配单个数字、大小写字母字符",
      "匹配单个非数字、大小写字母字符",
      "匹配“|”之前或之后的表达式",
      "指定的字符重复0/n次",
      "指定的字符重复1/n次",
      "指定的字符重复0/1次",
      "｛n｝",
      "只能输入n个字符",
      "｛n,｝",
      "指定至少n个匹配",
      "｛n,m｝",
      "指定至少n个但不多于m个匹配",
      "指定开始字符",
      "指定结束字符",
      "\\\\b",
      "匹配目标字符串的边界",
      "\\bB",
      "匹配目标字符串的非边界",
      "匹配换页符",
      "匹配换行符",
      "匹配回车"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "Lab3需要对字符串进行匹配，这里整理了一下元字符：\n1.限定符\n2.选择匹配符\n3.分组组合和反向引用符\n4.特殊字符\n5.字符匹配符\n6.定位符\n转义号\n可接受的字符列表\n[^]\n不可接受的字符列表\n连字符\n匹配除\\n以外任意字符\n\\\\d\n匹配单个数字字符\n\\\\D\n匹配单个非数字字符\n\\\\w\n匹配单个数字、大小写字母字符\n匹配单个非数字、大小写字母字符\n匹配“|”之前或之后的表达式\n指定的字符重复0/n次\n指定的字符重复1/n次\n指定的字符重复0/1次\n｛n｝\n只能输入n个字符\n｛n,｝\n指定至少n个匹配\n｛n,m｝\n指定至少n个但不多于m个匹配\n指定开始字符\n指定结束字符\n\\\\b\n匹配目标字符串的边界\n\\bB\n匹配目标字符串的非边界\n匹配换页符\n匹配换行符\n匹配回车\n"
  },
  {
    "head": "Lab1中turtle凸包算法的实现",
    "paragraphs": [
      "lab1中P2要求实现：给定一组点，计算凸包，即包含一组输入点中的所有点的最小凸集。使用Jarvis步进法，思路：纵坐标最小的那个点一定是凸包上的点，比如下面中的P0。从P0开始，按逆时针的方向，逐个找凸包上的点，每前进一步找到一个点，所以叫作步进法。利用夹角。假设现在已经找到P0,P1,P2了，要找下一个点：剩下的点分别和P2组成向量，设这个向量与向量P1P2的夹角为 β 。当 β 最小时就是所要求的下一个点了，此处为P3。"
    ],
    "sentences": [
      "lab1中P2要求实现：给定一组点",
      "计算凸包",
      "即包含一组输入点中的所有点的最小凸集",
      "使用Jarvis步进法",
      "思路：纵坐标最小的那个点一定是凸包上的点",
      "比如下面中的P0",
      "从P0开始",
      "按逆时针的方向",
      "逐个找凸包上的点",
      "每前进一步找到一个点",
      "所以叫作步进法",
      "利用夹角",
      "假设现在已经找到P0,P1,P2了",
      "要找下一个点：剩下的点分别和P2组成向量",
      "设这个向量与向量P1P2的夹角为 β ",
      "当 β 最小时就是所要求的下一个点了，此处为P3"
    ],
    "codes": [
      "public static Set<Point> convexHull(Set<Point> points) {\n    \tif (points.size() <= 2) {\n    \t    return points;\n    \t}\n    \tSet<Point> convexHullPoints = new HashSet<Point>();\n    \tPoint a = new Point(Double.MAX_VALUE, Double.MAX_VALUE);\n    \tfor (Point i : points) {\n    \t    if (i.y() < a.y())\n    \t\ta = i;\n    \t}\n    \tPoint curPoint = a, minPoint = null, lastPoint = a;\n    \tdouble x1 = 0.0, y1 = -1.0;\n    \tdo {\n    \t    convexHullPoints.add(curPoint);\n    \t    double minTheta = Double.MAX_VALUE, x2 = 0.0, y2 = 0.0;\n    \t    for (Point i : points) {\n    \t\tif ((!convexHullPoints.contains(i) || i == a) && (i != lastPoint)) {\n    \t\t    double x3 = i.x() - curPoint.x(), y3 = i.y() - curPoint.y();\n    \t\t    double Theta = Math\n    \t\t\t    .acos((x1 * x3 + y1 * y3) / Math.sqrt(x1 * x1 + y1 * y1) / Math.sqrt(x3 * x3 + y3 * y3));\n    \t\t    if (Theta < minTheta || (Theta == minTheta && x3 * x3 + y3 * y3 > Math.pow(i.x() - minPoint.x(), 2)\n    \t\t\t    + Math.pow(i.y() - minPoint.y(), 2))) {\n    \t\t\tminPoint = i;\n    \t\t\tminTheta = Theta;\n    \t\t\tx2 = x3;\n    \t\t\ty2 = y3;\n    \t\t    }\n    \t\t}\n    \t    }\n    \t    x1 = x2;\n    \t    y1 = y2;\n    \t    lastPoint = curPoint;\n    \t    curPoint = minPoint;\n    \t} while (curPoint != a);\n    \treturn convexHullPoints;\n        }"
    ],
    "date": "2021-07-07",
    "text": "lab1中P2要求实现：给定一组点，计算凸包，即包含一组输入点中的所有点的最小凸集。使用Jarvis步进法，思路：纵坐标最小的那个点一定是凸包上的点，比如下面中的P0。从P0开始，按逆时针的方向，逐个找凸包上的点，每前进一步找到一个点，所以叫作步进法。利用夹角。假设现在已经找到P0,P1,P2了，要找下一个点：剩下的点分别和P2组成向量，设这个向量与向量P1P2的夹角为 β 。当 β 最小时就是所要求的下一个点了，此处为P3。\n"
  },
  {
    "head": "Java设计模式-装饰器模式",
    "paragraphs": [
      "对于开发中不同级别的管理员，如何在管理员这个实体的基础上动态的去设置他们的权限范围呢？我们把权限当作一种挂饰，这种挂饰放在不同的管理员身上就代表他们是什么管理员，那么这种挂饰如何放到管理员身上呢？这就需要装饰器模式了。看一下概念：",
      "装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。",
      "这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。",
      "首先定义一个管理员接口，实现这个接口证明你就是一个管理员：",
      "基础管理员：",
      "需要写一个装饰器负责把权限装饰到这个现有的管理员身上。首先肯定要有这个管理员的实例(对象)，所以这个装饰器的构造器中我们要传入一个管理员，其次如果想不破坏管理员的原有结构功能，那么我们肯定要实现管理员这个接口，放入传入具体管理员实例的方法，这样才能保证结构和功能：",
      "通过装饰器，把权限这个挂饰挂在管理员身上，以此来形成负责不同模块的管理员工。这里我们来实现两个挂饰：写挂饰中挂饰通过装饰器去挂，那么我们肯定要继承这个装饰器，在重写它的方法中动态的增加权限。",
      "优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。",
      "缺点：多层装饰比较复杂。"
    ],
    "sentences": [
      "对于开发中不同级别的管理员",
      "如何在管理员这个实体的基础上动态的去设置他们的权限范围呢？我们把权限当作一种挂饰",
      "这种挂饰放在不同的管理员身上就代表他们是什么管理员",
      "那么这种挂饰如何放到管理员身上呢？这就需要装饰器模式了",
      "看一下概念：装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能",
      "同时又不改变其结构",
      "这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装",
      "这种模式创建了一个装饰类",
      "用来包装原有的类",
      "并在保持类方法签名完整性的前提下",
      "提供了额外的功能",
      "首先定义一个管理员接口",
      "实现这个接口证明你就是一个管理员：基础管理员：需要写一个装饰器负责把权限装饰到这个现有的管理员身上",
      "首先肯定要有这个管理员的实例(对象)",
      "所以这个装饰器的构造器中我们要传入一个管理员",
      "其次如果想不破坏管理员的原有结构功能",
      "那么我们肯定要实现管理员这个接口",
      "放入传入具体管理员实例的方法",
      "这样才能保证结构和功能：通过装饰器",
      "把权限这个挂饰挂在管理员身上",
      "以此来形成负责不同模块的管理员工",
      "这里我们来实现两个挂饰：写挂饰中挂饰通过装饰器去挂",
      "那么我们肯定要继承这个装饰器",
      "在重写它的方法中动态的增加权限",
      "优点：装饰类和被装饰类可以独立发展",
      "不会相互耦合",
      "装饰模式是继承的一个替代模式",
      "装饰模式可以动态扩展一个实现类的功能",
      "缺点：多层装饰比较复杂"
    ],
    "codes": [
      "interface Component {\n    void identity();\n}",
      "class Administrator implements Component {\n\n    @Override\n    public void identity() {\n        System.out.println(\"无权限管理员\");\n    }\n}",
      "class Decorator implements Component {\n    protected Component component;\n    public Decorator(Component component) {\n        this.component = component;\n    }\n\n    @Override\n    public void identity() {\n        component.identity();\n    }\n}",
      "class DeA extends Decorator {\n\n    public DeA(Component component) {\n        super(component);\n    }\n\n    @Override\n    public void identity() {\n        this.component.identity();\n        personnelFile();\n    }\n\n    public void  personnelFile() {\n        System.out.println(\"负责A\");\n    }\n\n\n}\n\nclass DeB extends Decorator {\n\n    public DeB(Component component) {\n        super(component);\n    }\n\n    public void administration() {\n        System.out.println(\"负责B\");\n    }\n    @Override\n    public void identity() {\n        this.component.identity();\n        administration();\n    }\n\n}"
    ],
    "date": "2021-07-07",
    "text": "对于开发中不同级别的管理员，如何在管理员这个实体的基础上动态的去设置他们的权限范围呢？我们把权限当作一种挂饰，这种挂饰放在不同的管理员身上就代表他们是什么管理员，那么这种挂饰如何放到管理员身上呢？这就需要装饰器模式了。看一下概念：\n装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。\n这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n首先定义一个管理员接口，实现这个接口证明你就是一个管理员：\n基础管理员：\n需要写一个装饰器负责把权限装饰到这个现有的管理员身上。首先肯定要有这个管理员的实例(对象)，所以这个装饰器的构造器中我们要传入一个管理员，其次如果想不破坏管理员的原有结构功能，那么我们肯定要实现管理员这个接口，放入传入具体管理员实例的方法，这样才能保证结构和功能：\n通过装饰器，把权限这个挂饰挂在管理员身上，以此来形成负责不同模块的管理员工。这里我们来实现两个挂饰：写挂饰中挂饰通过装饰器去挂，那么我们肯定要继承这个装饰器，在重写它的方法中动态的增加权限。\n优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n缺点：多层装饰比较复杂。\n"
  },
  {
    "head": "Java8中的stream(一点点)",
    "paragraphs": [
      "Stream是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。不会去存储对象",
      "创建Steam：",
      "由数组创建流，通过Arrays中的静态方法 stream() 创建数据源",
      "static < T> Stream< T> stream(T[] array): 返回一个流。",
      "由数组创建流，通过Arrays中的静态方法 stream() 创建数据源",
      "static < T> Stream< T> stream(T[] array): 返回一个流。",
      "Stream中间操作：",
      "筛选与切片：",
      "1.filter(Predicate p) 接收 Lambda表达式 ， 从流中排除某些元素",
      "2.distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去 除重复元素",
      "3.limit(long maxSize) 截断流，使其元素不超过给定数量",
      "4.skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素 不足 n 个，则返回一个空流。与 limit(n) 互补",
      "映射：",
      "1.map(Function f) 接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素",
      "2.mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream",
      "3.mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream",
      "排序：",
      "1.sorted() 产生一个新流，其中按自然顺序排序",
      "2.sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序",
      "应用：",
      "这里控制台会输出ID等于3的那条数据,在我们输出list的时候，我们发现list的数据并没有收到改变。"
    ],
    "sentences": [
      "Stream是数据渠道",
      "用于操作数据源(集合、数组等)所生成的元素序列",
      "不会去存储对象",
      "创建Steam：由数组创建流",
      "通过Arrays中的静态方法 stream() 创建数据源",
      "static < T> Stream< T> stream(T[] array): 返回一个流",
      "由数组创建流",
      "通过Arrays中的静态方法 stream() 创建数据源",
      "static < T> Stream< T> stream(T[] array): 返回一个流",
      "Stream中间操作：筛选与切片：1.filter(Predicate p) 接收 Lambda表达式 ",
      " 从流中排除某些元素",
      "2.distinct() 筛选",
      "通过流所生成元素的 hashCode() 和 equals() 去 除重复元素",
      "3.limit(long maxSize) 截断流",
      "使其元素不超过给定数量",
      "4.skip(long n) 跳过元素",
      "返回一个扔掉了前 n 个元素的流",
      "若流中元素 不足 n 个，则返回一个空流",
      "与 limit(n) 互补",
      "映射：1.map(Function f) 接收一个函数作为参数",
      "该函数会被应用到每个元 素上",
      "并将其映射成一个新的元素",
      "2.mapToDouble(ToDoubleFunction f) 接收一个函数作为参数",
      "该函数会被应用到每个元 素上",
      "产生一个新的 DoubleStream",
      "3.mapToInt(ToIntFunction f) 接收一个函数作为参数",
      "该函数会被应用到每个元 素上",
      "产生一个新的 IntStream",
      "排序：1.sorted() 产生一个新流，其中按自然顺序排序",
      "2.sorted(Comparator comp) 产生一个新流",
      "其中按比较器顺序排序",
      "应用：这里控制台会输出ID等于3的那条数据,在我们输出list的时候",
      "我们发现list的数据并没有收到改变"
    ],
    "codes": [
      "public void stream() {\n        List<StreamObject> list = new ArrayList();\n        Stream<StreamObject> stream = list.stream();\n        Stream<StreamObject> stream1 = list.parallelStream();\n    }",
      "public void stream2() {\n        Integer[] integer = new Integer[20];\n        Stream<Integer> stream = Arrays.stream(integer);\n    }",
      "​\n    public static void test() {\n        List<StreamObject> list = Arrays.asList(\n                new StreamObject(1, \"学\", \"习\", \"烂\"),\n                new StreamObject(2, \"学\", \"习\", \"烂\"),\n                new StreamObject(2, \"学\", \"习\", \"烂\"),\n                new StreamObject(3, \"学\", \"习\", \"烂\")\n        );\n        Stream<StreamObject> stream = \n        list.stream()\n        .filter(StreamObject::method)\n        .distinct()\n        .limit(2)\n        .skip(1);\n        stream.forEach(System.out::println);\n        System.out.println(list);\n             \n       \n        }\n\n​"
    ],
    "date": "2021-07-07",
    "text": "Stream是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。不会去存储对象\n创建Steam：\n由数组创建流，通过Arrays中的静态方法 stream() 创建数据源\nstatic < T> Stream< T> stream(T[] array): 返回一个流。\n由数组创建流，通过Arrays中的静态方法 stream() 创建数据源\nstatic < T> Stream< T> stream(T[] array): 返回一个流。\nStream中间操作：\n筛选与切片：\n1.filter(Predicate p) 接收 Lambda表达式 ， 从流中排除某些元素\n2.distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去 除重复元素\n3.limit(long maxSize) 截断流，使其元素不超过给定数量\n4.skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素 不足 n 个，则返回一个空流。与 limit(n) 互补\n映射：\n1.map(Function f) 接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素\n2.mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream\n3.mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream\n排序：\n1.sorted() 产生一个新流，其中按自然顺序排序\n2.sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序\n应用：\n这里控制台会输出ID等于3的那条数据,在我们输出list的时候，我们发现list的数据并没有收到改变。\n"
  },
  {
    "head": "对象和对象的引用",
    "paragraphs": [
      "复习的时候突然被对象和对象的引用搞懵了。搜了一圈，终于搞明白了。",
      "先建立一个类",
      "然后用这个类new一个对象",
      "右边的“new Test”，是创建一个Test对象。",
      "而左边的“Test t”创建了一个Test类引用变量，是用来指向Test对象的对象引用。",
      "也可以写成：",
      "也可以多个对象引用指向一个对象",
      "参考原文：",
      "https://blog.csdn.net/qq_26805137/article/details/52945688",
      "牛(｡◕ˇ∀ˇ◕)"
    ],
    "sentences": [
      "复习的时候突然被对象和对象的引用搞懵了",
      "搜了一圈，终于搞明白了",
      "先建立一个类",
      "然后用这个类new一个对象",
      "右边的“new Test”，是创建一个Test对象",
      "而左边的“Test t”创建了一个Test类引用变量",
      "是用来指向Test对象的对象引用",
      "也可以写成：也可以多个对象引用指向一个对象",
      "参考原文：https://blog.csdn.net/qq_26805137/article/details/52945688",
      "牛(｡◕ˇ∀ˇ◕)"
    ],
    "codes": [
      " public class Test{\n    //默认构造方法\n    public Test{\n    }\n}\n",
      "Test t = new Test();\n",
      "Test t;//创建对象引用\nt = /*将对象引用指向对象*/new Test();//创建对象",
      "//一个对象引用可以指向一个对象\nTest t；//一个对象引用\nTest = new Test();//一个对象引用指向一个对象\n",
      "Test t1，t2，t3;//创建多个对象引用\nt1 = new Test();\nt2 = t1;\nt3 = t2;//创建对象，并被多个对象引用指向\n"
    ],
    "date": "2021-07-07",
    "text": "复习的时候突然被对象和对象的引用搞懵了。搜了一圈，终于搞明白了。\n先建立一个类\n然后用这个类new一个对象\n右边的“new Test”，是创建一个Test对象。\n而左边的“Test t”创建了一个Test类引用变量，是用来指向Test对象的对象引用。\n也可以写成：\n也可以多个对象引用指向一个对象\n参考原文：\nhttps://blog.csdn.net/qq_26805137/article/details/52945688\n牛(｡◕ˇ∀ˇ◕)\n"
  },
  {
    "head": "【新人】编写JUnit测试类有自定义类cannot be resolved to a type",
    "paragraphs": [
      "今天在编写某实验的测试代码时，尝试实例化对象时出现了Edge cannot be resolved to a type的",
      "错误。但这个类是有的，也已经import过了，就很令人费解。",
      "后来请教了同学，了解到是项目的结构出了问题。之前的结构是这样的：",
      "可以看到测试文件都是放在P1文件夹下，它们的package写的都是P1.graph/P1.poet，而src里的源文件都没有放在P1里，其package为graph/poet。",
      "同学说，将测试文件与源文件的包名保持一致，这样测试代码就相当于可以直接看到源文件里的东西了。",
      "于是我将结构进行修改：",
      "果然通过了，同时还省去了一部分import。",
      "非常的好用。",
      "后续再学习学习原理。"
    ],
    "sentences": [
      "今天在编写某实验的测试代码时",
      "尝试实例化对象时出现了Edge cannot be resolved to a type的",
      "错误",
      "但这个类是有的，也已经import过了，就很令人费解",
      "后来请教了同学，了解到是项目的结构出了问题",
      "之前的结构是这样的：可以看到测试文件都是放在P1文件夹下",
      "它们的package写的都是P1.graph/P1.poet",
      "而src里的源文件都没有放在P1里",
      "其package为graph/poet",
      "同学说",
      "将测试文件与源文件的包名保持一致",
      "这样测试代码就相当于可以直接看到源文件里的东西了",
      "于是我将结构进行修改：果然通过了",
      "同时还省去了一部分import",
      "非常的好用",
      "后续再学习学习原理"
    ],
    "codes": [],
    "date": "2021-05-29",
    "text": "今天在编写某实验的测试代码时，尝试实例化对象时出现了Edge cannot be resolved to a type的\n错误。但这个类是有的，也已经import过了，就很令人费解。\n后来请教了同学，了解到是项目的结构出了问题。之前的结构是这样的：\n可以看到测试文件都是放在P1文件夹下，它们的package写的都是P1.graph/P1.poet，而src里的源文件都没有放在P1里，其package为graph/poet。\n同学说，将测试文件与源文件的包名保持一致，这样测试代码就相当于可以直接看到源文件里的东西了。\n于是我将结构进行修改：\n果然通过了，同时还省去了一部分import。\n非常的好用。\n后续再学习学习原理。\n"
  },
  {
    "head": "在Eclipse中使用git传本地仓库到远程仓库",
    "paragraphs": [
      "在后两次课程实验中，我都是使用Eclipse中的git操作上传代码到GitHub，现在课程结束了，我简单记录一下。",
      "1、首先打开一个项目，右击，点击Team——>Share Project",
      "2、选择Git",
      "3、在该界面创建本地仓库",
      "4、再次右键项目，Team——>Commit",
      "5、在1处填写提交信息，2处选择提交文件，完成后点击Commit and push",
      "6、在这里填写远程仓库的URL等信息。传Github在Authentication处填写用户名和密码",
      "7、填写完成后继续，点击Finish即可。",
      "之后每当有改动或增加内容，右键项目Team——>Commit，重复一波即可，非常的方便，非常的银杏。",
      "更多操作可以移步这里：",
      "https://www.jianshu.com/p/acb00e4c7301"
    ],
    "sentences": [
      "在后两次课程实验中",
      "我都是使用Eclipse中的git操作上传代码到GitHub",
      "现在课程结束了",
      "我简单记录一下",
      "1、首先打开一个项目",
      "右击",
      "点击Team——>Share Project",
      "2、选择Git",
      "3、在该界面创建本地仓库",
      "4、再次右键项目，Team——>Commit",
      "5、在1处填写提交信息",
      "2处选择提交文件",
      "完成后点击Commit and push",
      "6、在这里填写远程仓库的URL等信息",
      "传Github在Authentication处填写用户名和密码",
      "7、填写完成后继续，点击Finish即可",
      "之后每当有改动或增加内容",
      "右键项目Team——>Commit",
      "重复一波即可",
      "非常的方便",
      "非常的银杏",
      "更多操作可以移步这里：https://www.jianshu.com/p/acb00e4c7301"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "在后两次课程实验中，我都是使用Eclipse中的git操作上传代码到GitHub，现在课程结束了，我简单记录一下。\n1、首先打开一个项目，右击，点击Team——>Share Project\n2、选择Git\n3、在该界面创建本地仓库\n4、再次右键项目，Team——>Commit\n5、在1处填写提交信息，2处选择提交文件，完成后点击Commit and push\n6、在这里填写远程仓库的URL等信息。传Github在Authentication处填写用户名和密码\n7、填写完成后继续，点击Finish即可。\n之后每当有改动或增加内容，右键项目Team——>Commit，重复一波即可，非常的方便，非常的银杏。\n更多操作可以移步这里：\nhttps://www.jianshu.com/p/acb00e4c7301\n"
  },
  {
    "head": "2021-06-30",
    "paragraphs": [
      "引出：子类可以继承父类的字段、属性和方法，使用“继承”可以较大程度地复用代码。在使用继承时，务必要确定代码中定义的“父类”和“子类”确实存在客观的“父子关系”，而不要去做“为了代码复用而使用继承”的事情，这是舍本逐末的做法，也是滥用继承的体现。滥用继承会破坏类之间客观存在的关系，也会模糊代码所体现的语义。",
      "委派和继承都是为了提高代码的复用性，只是方式不同。",
      "委派：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象。",
      "继承：利用extends来扩展一个基类。",
      "（1）Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。示例代码：",
      "（2）Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。示例代码：",
      "（3）Composition: 更强的association，但难以变化。也就是以下代码Association中的法二。",
      "（4）Aggregation: 更弱的association，可动态变化。也就是以下代码Association中的法一。",
      "参考文献：https://blog.csdn.net/weixin_44940258"
    ],
    "sentences": [
      "引出：子类可以继承父类的字段、属性和方法",
      "使用“继承”可以较大程度地复用代码",
      "在使用继承时",
      "务必要确定代码中定义的“父类”和“子类”确实存在客观的“父子关系”",
      "而不要去做“为了代码复用而使用继承”的事情",
      "这是舍本逐末的做法",
      "也是滥用继承的体现",
      "滥用继承会破坏类之间客观存在的关系，也会模糊代码所体现的语义",
      "委派和继承都是为了提高代码的复用性，只是方式不同",
      "委派：一个对象请求另一个对象的功能",
      "捕获一个操作并将其发送到另一个对象",
      "继承：利用extends来扩展一个基类",
      "（1）Association：关联关系",
      "永久性的delegation",
      "被delegation的对象保存在rep中",
      "该对象的类型被永久的与此ADT绑定在了一起",
      "示例代码：（2）Dependency：依赖关系",
      "临时性的delegation",
      "把被delegation的对象以参数方式传入",
      "只有在需要的时候才建立与被委派类的联系",
      "而当方法结束的时候这种关系也就随之断开了",
      "示例代码：（3）Composition: 更强的association",
      "但难以变化",
      "也就是以下代码Association中的法二",
      "（4）Aggregation: 更弱的association",
      "可动态变化",
      "也就是以下代码Association中的法一",
      "参考文献：https://blog.csdn.net/weixin_44940258"
    ],
    "codes": [
      "\t\t\t\t\t\t软件构造Delegation\n",
      "interface Flyable {\n\tpublic void fly();\n}\ninterface Quackable {\n\tpublic void quack();\n}\nclass FlyWithWings implements Flyable{\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\"fly with wings\");\n\t}\n}\nclass Quack implements Quackable{\n\t@Override\n\tpublic void quack() {\n\t\tSystem.out.println(\"quack like duck\");\n\t}\n}\ninterface Ducklike extends Flyable,Quackable{\n\n}\npublic class Duck implements Ducklike {\n\t//delegation\n\tFlyable flyBehavior;\n\tQuackable quackBehavior;\n\n\t//设置delegation对象实例\n\tpublic void setFlyBehavior(Flyable flyBehavior) {\n\t\tthis.flyBehavior = flyBehavior;\n\t}\n\n\tpublic void setQuackBehavior(Quackable quackBehavior) {\n\t\tthis.quackBehavior = quackBehavior;\n\t}\n\n\t//通过delegation实现具体行为\n\t@Override\n\tpublic void fly() {\n\t\tthis.flyBehavior.fly();\n\t}\n\n\t@Override\n\tpublic void quack() {\n\t\tthis.quackBehavior.quack();\n\t}\n\n}\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tFlyable f = new FlyWithWings();\n\t\tQuackable q = new Quack();\n\t\tDuck d = new Duck();\n\t\td.setFlyBehavior(f);\n\t\td.setQuackBehavior(q);\n\t\td.fly();\n\t\td.quack();\n\t}\n}\n",
      "public interface Study {\n\tint study(String content);\n}\nclass StudyInClass implements Study{\n\t@Override\n\tpublic int study(String content) {\t\n\t\treturn 1;\n\t}\n}\nclass StudyByMooc implements Study{\n\t@Override\n\tpublic int study(String content) {\n\t\treturn 2;\n\t}\t\n}\nclass Student{\n\tprivate String name;\n\tprivate Map<String,Integer> scores = new HashMap<String, Integer>();\n\t\n\tpublic Map<String, Integer> getScores() {\n\t\treturn scores;\n\t}\n\t//AF:name为学生名字，scores中的key为学科名字，value为学生成绩\n\t//RI:学生成绩范围为[0,100]\n\tpublic Student(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getFinalScore() {\n\t\tint total = 0;\n\t\tfor(String content:scores.keySet()) {\n\t\t\ttotal += scores.get(content);\n\t\t}\n\t\treturn total;\n\t}\n\t//建立临时性的delegation关系\n\tpublic int study(String content,Study method) {\n\t\tSystem.out.print(content + \":\\t\");\n\t\treturn method.study(content);\n\t}\n\tpublic void getScore(String content,Study method) {\n\t\tint score = method.study(content);\n\t\tscores.put(content, score);\n\t}\n\tpublic static void main(String[] args) {\n\t\tStudy inClass = new StudyInClass();\n\t\tStudy byMooc = new StudyByMooc();\n\t\tStudent Wu = new Student(\"wyf\");\n\t\t\n\t\tWu.study(\"软件构造\", inClass);\n\t\tWu.getScore(\"软件构造\", inClass);\n\t\tSystem.out.println(Wu.getScores().get(\"软件构造\"));\n\t\tWu.study(\"计算机系统\", byMooc);\n\t\tWu.getScore(\"计算机系统\", byMooc);\n\t\tSystem.out.println(Wu.getScores().get(\"计算机系统\"));\n\t\t\n\t\tSystem.out.println(\"总成绩：\" + Wu.getFinalScore());\n\t}\n",
      "//法一：在构造方法中传入参数绑定\nFlyable f = new FlyWithWings();\nDuck d = new Duck(f);\nd.fly();\nclass Duck {\n\tFlyable f; //这个必须由构造方法传入参数绑定\n\tpublic Duck(Flyable f) { this.f = f; }\n    public void fly(){ f.fly(); }\n}\n//法二：在rep或构造方法中直接写死\nDuck d = new Duck();\nd.fly();\nclass Duck {\n    //这两种实现方式的效果是相同的\n\tFlyable f = new FlyWithWings(); //写死在rep中\n\tpublic Duck() { f = new FlyWithWings(); } //写死在构造方法中\n\tpublic void fly(){ f.fly(); }\n}\n\n"
    ],
    "date": "2021-06-30",
    "text": "引出：子类可以继承父类的字段、属性和方法，使用“继承”可以较大程度地复用代码。在使用继承时，务必要确定代码中定义的“父类”和“子类”确实存在客观的“父子关系”，而不要去做“为了代码复用而使用继承”的事情，这是舍本逐末的做法，也是滥用继承的体现。滥用继承会破坏类之间客观存在的关系，也会模糊代码所体现的语义。\n委派和继承都是为了提高代码的复用性，只是方式不同。\n委派：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象。\n继承：利用extends来扩展一个基类。\n（1）Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。示例代码：\n（2）Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。示例代码：\n（3）Composition: 更强的association，但难以变化。也就是以下代码Association中的法二。\n（4）Aggregation: 更弱的association，可动态变化。也就是以下代码Association中的法一。\n参考文献：https://blog.csdn.net/weixin_44940258\n"
  },
  {
    "head": "2021-06-29",
    "paragraphs": [
      "正确性与线程安全性之间的关系非常类似于在描述 ACID(原子性、一致性、独立性和持久性)事务时使用的一致性与独立性之间的关系：从特定线程的角度看，由不同线程所执行的对象操作是先后(虽然顺序不定)而不是并行执行的。",
      "线程安全的四中策略总结：",
      "1.Confinement:限制可变变量共享，线程之间不共享mutable数据类型，将可变数据限制在单一进程内部，避免竞争，不让其他进程直接读写该数据。局部变量总是线程安全的，但如果局部变量是一个对象引用，若该对指向象是可变对象，则必须确定该对象也是线程confine 的，不能有其他线程也该对象的引用。",
      "2.Immutablity不可变数据类型：使用不可变数据类型和不可变引用，避免多线程之间的竞争，不可变数据类型通常是线程安全的，如果ADT使用了可变类型，需要通过加锁机制来保证线程安全。",
      "更强的不变性定义如下:",
      "1.没有改变数据的操作。（不要提供setter方法等）",
      "2.所有字段均为private和final。",
      "3.没有表示泄露。",
      "4.表示中的任何可变对象都不能发生变化。",
      "5.不允许子类重写方法（直接声明为final类，或者使构造方法私有，使用工厂方法构造实例）",
      "但是注意：如果是引用，任然必须保证指向的对象是不可变的。",
      "3.Using Threadsafe Data Types：使用线程安全的数据类型，如果必须要使用mutable 的数据类型在多线程之间共享收据，要使用线性安全的数据类型，所有的集合类都不是线程安全的，Java提供了装饰器模式。",
      "4.同步和锁：防止线程在同一时间访问同一数据，程序员之间负责多线程之间对mutale数据的共享操作，通过同步策略，避免多线程同时访问数据",
      "使用锁机制。获得对数据的独家mutate权力。其他线程被阻塞，不能访问。",
      "Monitor Pattern：用ADT之间左lock，对所有方法都加锁，把synchronized放到方法声明里和把方法体外套一个symchronized一样，Locking principle：任何共享的mutable变量必须被lock所保护，多个变量组合必须被同一个锁保护，同步机制给性能带来很大的影响。",
      "死锁：多个线程相互竞争lock，相互等待对方释放lock",
      "解决方案1：lock ordering。",
      "解决方案2：使用上级对象上锁。",
      "线程安全的意义：线程安全， 是指变量或方法( 这些变量或方法是多线程共享的) 可以在多线程的环境下被安全有效的访问。这说明了两方面的问题:",
      "(1)可以从多个线程中调用， 无需调用方有任何操作;",
      "(2)可以同时被多个线程调用， 无需线程之不必要的交互。"
    ],
    "sentences": [
      "正确性与线程安全性之间的关系非常类似于在描述 ACID(原子性、一致性、独立性和持久性)事务时使用的一致性与独立性之间的关系：从特定线程的角度看",
      "由不同线程所执行的对象操作是先后(虽然顺序不定)而不是并行执行的",
      "线程安全的四中策略总结：1.Confinement:限制可变变量共享",
      "线程之间不共享mutable数据类型",
      "将可变数据限制在单一进程内部",
      "避免竞争",
      "不让其他进程直接读写该数据",
      "局部变量总是线程安全的",
      "但如果局部变量是一个对象引用",
      "若该对指向象是可变对象",
      "则必须确定该对象也是线程confine 的",
      "不能有其他线程也该对象的引用",
      "2.Immutablity不可变数据类型：使用不可变数据类型和不可变引用",
      "避免多线程之间的竞争",
      "不可变数据类型通常是线程安全的",
      "如果ADT使用了可变类型",
      "需要通过加锁机制来保证线程安全",
      "更强的不变性定义如下:1.没有改变数据的操作",
      "（不要提供setter方法等）",
      "2.所有字段均为private和final",
      "3.没有表示泄露",
      "4.表示中的任何可变对象都不能发生变化",
      "5.不允许子类重写方法（直接声明为final类",
      "或者使构造方法私有",
      "使用工厂方法构造实例）",
      "但是注意：如果是引用，任然必须保证指向的对象是不可变的",
      "3.Using Threadsafe Data Types：使用线程安全的数据类型",
      "如果必须要使用mutable 的数据类型在多线程之间共享收据",
      "要使用线性安全的数据类型",
      "所有的集合类都不是线程安全的",
      "Java提供了装饰器模式",
      "4.同步和锁：防止线程在同一时间访问同一数据",
      "程序员之间负责多线程之间对mutale数据的共享操作",
      "通过同步策略",
      "避免多线程同时访问数据",
      "使用锁机制",
      "获得对数据的独家mutate权力",
      "其他线程被阻塞，不能访问",
      "Monitor Pattern：用ADT之间左lock",
      "对所有方法都加锁",
      "把synchronized放到方法声明里和把方法体外套一个symchronized一样",
      "Locking principle：任何共享的mutable变量必须被lock所保护",
      "多个变量组合必须被同一个锁保护",
      "同步机制给性能带来很大的影响",
      "死锁：多个线程相互竞争lock，相互等待对方释放lock",
      "解决方案1：lock ordering",
      "解决方案2：使用上级对象上锁",
      "线程安全的意义：线程安全",
      " 是指变量或方法( 这些变量或方法是多线程共享的) 可以在多线程的环境下被安全有效的访问",
      "这说明了两方面的问题:(1)可以从多个线程中调用",
      " 无需调用方有任何操作;(2)可以同时被多个线程调用",
      " 无需线程之不必要的交互"
    ],
    "codes": [
      "\t\t\t\t\t\t\t\t软件构造线程安全\n\t\t\t\t\t\t\t\t\n线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。\n多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。或者说：一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题。\n线程安全问题大多是由全局变量及静态变量引起的，局部变量逃逸也可能导致线程安全问题。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。类要成为线程安全的，首先必须在单线程环境中有正确的行为。如果一个类实现正确(这是说它符合规格说明的另一种方式)，那么没有一种对这个类的对象的操作序列(读或者写公共字段以及调用公共方法)可以让对象处于无效状态，观察到对象处于无效状态、或者违反类的任何不可变量、前置条件或者后置条件的情况。此外，一个类要成为线程安全的，在被多个线程访问时，不管运行时环境执行这些线程有什么样的时序安排或者交错，它必须仍然有如上所述的正确行为，并且在调用的代码中没有任何额外的同步。其效果就是，在所有线程看来，对于线程安全对象的操作是以固定的、全局一致的顺序发生的。\n"
    ],
    "date": "2021-06-30",
    "text": "正确性与线程安全性之间的关系非常类似于在描述 ACID(原子性、一致性、独立性和持久性)事务时使用的一致性与独立性之间的关系：从特定线程的角度看，由不同线程所执行的对象操作是先后(虽然顺序不定)而不是并行执行的。\n线程安全的四中策略总结：\n1.Confinement:限制可变变量共享，线程之间不共享mutable数据类型，将可变数据限制在单一进程内部，避免竞争，不让其他进程直接读写该数据。局部变量总是线程安全的，但如果局部变量是一个对象引用，若该对指向象是可变对象，则必须确定该对象也是线程confine 的，不能有其他线程也该对象的引用。\n2.Immutablity不可变数据类型：使用不可变数据类型和不可变引用，避免多线程之间的竞争，不可变数据类型通常是线程安全的，如果ADT使用了可变类型，需要通过加锁机制来保证线程安全。\n更强的不变性定义如下:\n1.没有改变数据的操作。（不要提供setter方法等）\n2.所有字段均为private和final。\n3.没有表示泄露。\n4.表示中的任何可变对象都不能发生变化。\n5.不允许子类重写方法（直接声明为final类，或者使构造方法私有，使用工厂方法构造实例）\n但是注意：如果是引用，任然必须保证指向的对象是不可变的。\n3.Using Threadsafe Data Types：使用线程安全的数据类型，如果必须要使用mutable 的数据类型在多线程之间共享收据，要使用线性安全的数据类型，所有的集合类都不是线程安全的，Java提供了装饰器模式。\n4.同步和锁：防止线程在同一时间访问同一数据，程序员之间负责多线程之间对mutale数据的共享操作，通过同步策略，避免多线程同时访问数据\n使用锁机制。获得对数据的独家mutate权力。其他线程被阻塞，不能访问。\nMonitor Pattern：用ADT之间左lock，对所有方法都加锁，把synchronized放到方法声明里和把方法体外套一个symchronized一样，Locking principle：任何共享的mutable变量必须被lock所保护，多个变量组合必须被同一个锁保护，同步机制给性能带来很大的影响。\n死锁：多个线程相互竞争lock，相互等待对方释放lock\n解决方案1：lock ordering。\n解决方案2：使用上级对象上锁。\n线程安全的意义：线程安全， 是指变量或方法( 这些变量或方法是多线程共享的) 可以在多线程的环境下被安全有效的访问。这说明了两方面的问题:\n(1)可以从多个线程中调用， 无需调用方有任何操作;\n(2)可以同时被多个线程调用， 无需线程之不必要的交互。\n"
  },
  {
    "head": "git 逻辑梳理",
    "paragraphs": [
      "1.大致分为但各区域",
      "workspace stage(标记文件) local repository remote repository",
      "-git add-> -git commit-> -git push->",
      "2.发生冲突时（对一个文件进行了不同修改）",
      "两个个branch不能再进行合并",
      "3.fetch直接从远端拷贝下来，相同文件覆盖",
      "4.对于没有冲突的不同文件，可以进行merge",
      "5.git pull = fetch + merge"
    ],
    "sentences": [
      "1.大致分为但各区域",
      "workspace stage(标记文件) local repository remote repository",
      "-git add-> -git commit-> -git push->",
      "2.发生冲突时（对一个文件进行了不同修改）",
      "两个个branch不能再进行合并",
      "3.fetch直接从远端拷贝下来，相同文件覆盖",
      "4.对于没有冲突的不同文件，可以进行merge",
      "5.git pull = fetch + merge"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "1.大致分为但各区域\nworkspace stage(标记文件) local repository remote repository\n-git add-> -git commit-> -git push->\n2.发生冲突时（对一个文件进行了不同修改）\n两个个branch不能再进行合并\n3.fetch直接从远端拷贝下来，相同文件覆盖\n4.对于没有冲突的不同文件，可以进行merge\n5.git pull = fetch + merge\n"
  },
  {
    "head": "几种重要的设计模式的便于记忆归纳",
    "paragraphs": [
      "适配器：把所有拉进来，根据情况执行",
      "装饰器：把要装饰的拉进来，再添点操作",
      "模版：抽象类，空三个，写一个用这三个，这三个在子类中实现",
      "策略：一个类引用另一种策略类，执行策略类中的操作，策略类可以换",
      "访问者：访问者类引用多个被访问者类，判断后输出判断结果"
    ],
    "sentences": [
      "适配器：把所有拉进来，根据情况执行",
      "装饰器：把要装饰的拉进来，再添点操作",
      "模版：抽象类，空三个，写一个用这三个，这三个在子类中实现",
      "策略：一个类引用另一种策略类",
      "执行策略类中的操作",
      "策略类可以换",
      "访问者：访问者类引用多个被访问者类，判断后输出判断结果"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "适配器：把所有拉进来，根据情况执行\n装饰器：把要装饰的拉进来，再添点操作\n模版：抽象类，空三个，写一个用这三个，这三个在子类中实现\n策略：一个类引用另一种策略类，执行策略类中的操作，策略类可以换\n访问者：访问者类引用多个被访问者类，判断后输出判断结果\n"
  },
  {
    "head": "最短路（4）--差分约束",
    "paragraphs": [
      "差分约束的实质就是把多种约束连起来，比如x-y <= a和y-z <= b，把他们连起来就成了x-z <= a+b，这样很容易就可以想到",
      "把x-y看成一条由x指向y，权值为a的边，那么对于一堆约束条件，就可以转化为求最短路或最长路的问题",
      "对于不同的一堆约束条件，有：",
      "如果约束条件形如x-y <= a，则实际问题为求差的最大值，操作是求最短路",
      "如果约束条件形如x-y >= a，则实际问题为求差的最小值，操作是求最长路",
      "（此处较难理解，需要用到数学中交并集的知识）",
      "解释：",
      "对于一堆约束条件建立的如下的图：",
      "两种约束条件原理类似，拿<=举例：",
      "可见，算出1和3的关系有两钟解，一种是<=4， 另一种是<=3，但是，因为要满足所有的约束条件，所以对于1和3的最大差值，只能取两个取值范围的交集，即<=3，这就使最短路",
      "举例：POJ3159（模板题）",
      "*题目大意：",
      "把糖分给n个小朋友，总共有m个约束条件，表示编号为i,j的小朋友之间分到的糖果数之差不大于一个值，求分完后第n个小朋友和第1个小朋友之间的最大差值*",
      "完全是模板题，直接上代码（SPFA）",
      " 这道题是我做过的最恶心的一道题，不能用queue，只能用stack就不说啥了，竟然连cin都不能用，只能用scanf。。。。白白浪费了我一个小时的时间，气的我想当场砸电脑"
    ],
    "sentences": [
      "差分约束的实质就是把多种约束连起来",
      "比如x-y <= a和y-z <= b",
      "把他们连起来就成了x-z <= a+b",
      "这样很容易就可以想到",
      "把x-y看成一条由x指向y",
      "权值为a的边",
      "那么对于一堆约束条件",
      "就可以转化为求最短路或最长路的问题",
      "对于不同的一堆约束条件",
      "有：如果约束条件形如x-y <= a",
      "则实际问题为求差的最大值",
      "操作是求最短路",
      "如果约束条件形如x-y >= a",
      "则实际问题为求差的最小值",
      "操作是求最长路",
      "（此处较难理解，需要用到数学中交并集的知识）",
      "解释：对于一堆约束条件建立的如下的图：两种约束条件原理类似",
      "拿<=举例：可见",
      "算出1和3的关系有两钟解",
      "一种是<=4",
      " 另一种是<=3",
      "但是",
      "因为要满足所有的约束条件",
      "所以对于1和3的最大差值",
      "只能取两个取值范围的交集",
      "即<=3",
      "这就使最短路",
      "举例：POJ3159（模板题）",
      "*题目大意：把糖分给n个小朋友",
      "总共有m个约束条件",
      "表示编号为i,j的小朋友之间分到的糖果数之差不大于一个值",
      "求分完后第n个小朋友和第1个小朋友之间的最大差值*",
      "完全是模板题，直接上代码（SPFA）",
      " 这道题是我做过的最恶心的一道题",
      "不能用queue",
      "只能用stack就不说啥了",
      "竟然连cin都不能用",
      "只能用scanf",
      "白白浪费了我一个小时的时间，气的我想当场砸电脑"
    ],
    "codes": [
      "//poj3159\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 30000 + 10;\nconst int MAXM = 150000 + 10;\nconst int INF = 0x3f3f3f3f;\nint n, m;\nstack<int> q;\nint d[MAXN], vis[MAXN];\n\nstruct edge      \n{\n    int to, next, w;\n} e[MAXM];\nint head[MAXN], cnt;\nvoid add(int u, int v, int w)\n{\n    e[++cnt].next = head[u];\n    head[u] = cnt;\n    e[cnt].to = v; \n    e[cnt].w = w;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 1; i <= m; i++)\n    {\n        int u, v, w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        add(u, v, w);\n    }\n\n    for(int i = 1; i <= n; i++)\n        d[i] = INF;\n    d[1] = 0;\n    q.push(1); vis[1] = 1;\n\n    while(!q.empty())\n    {\n        int u = q.top(); \n        int v, w;\n        q.pop(); \n        vis[u] = 0;\n        for(int i = head[u]; i; i = e[i].next)\n        {\n            v = e[i].to;\n            w = e[i].w;\n            if(d[v] > d[u] + w)\n            {\n                d[v] = d[u] + w;\n                if(!vis[v]) {q.push(v); vis[v] = 1;}\n            }\n        }\n\n    }\n\n    printf(\"%d\\n\",d[n]);\n    return 0;\n}"
    ],
    "date": "2017-05-13",
    "text": "差分约束的实质就是把多种约束连起来，比如x-y <= a和y-z <= b，把他们连起来就成了x-z <= a+b，这样很容易就可以想到\n把x-y看成一条由x指向y，权值为a的边，那么对于一堆约束条件，就可以转化为求最短路或最长路的问题\n对于不同的一堆约束条件，有：\n如果约束条件形如x-y <= a，则实际问题为求差的最大值，操作是求最短路\n如果约束条件形如x-y >= a，则实际问题为求差的最小值，操作是求最长路\n（此处较难理解，需要用到数学中交并集的知识）\n解释：\n对于一堆约束条件建立的如下的图：\n两种约束条件原理类似，拿<=举例：\n可见，算出1和3的关系有两钟解，一种是<=4， 另一种是<=3，但是，因为要满足所有的约束条件，所以对于1和3的最大差值，只能取两个取值范围的交集，即<=3，这就使最短路\n举例：POJ3159（模板题）\n*题目大意：\n把糖分给n个小朋友，总共有m个约束条件，表示编号为i,j的小朋友之间分到的糖果数之差不大于一个值，求分完后第n个小朋友和第1个小朋友之间的最大差值*\n完全是模板题，直接上代码（SPFA）\n 这道题是我做过的最恶心的一道题，不能用queue，只能用stack就不说啥了，竟然连cin都不能用，只能用scanf。。。。白白浪费了我一个小时的时间，气的我想当场砸电脑\n"
  },
  {
    "head": "CODEVS 1134 noip2011 铺地毯",
    "paragraphs": [
      "懒得用结构体"
    ],
    "sentences": [
      "懒得用结构体"
    ],
    "codes": [
      "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 10000 + 10;\nint a[MAXN], b[MAXN], g[MAXN], k[MAXN];\nint main()\n{\n\tint n;\n\tint x, y;\n\tint ans = -1;\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i] >> b[i] >> g[i] >> k[i];\n\tcin >> x >> y;\n\t\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i])\n\t\t\tans = i;\n\t}\n\t\n\tcout << ans;\n\treturn 0;\n}"
    ],
    "date": "2016-07-02",
    "text": "懒得用结构体\n"
  },
  {
    "head": "静态工厂方法的实例理解",
    "paragraphs": [
      "先上例子",
      "主要思路为在接口中定义一个静态的函数，可以直接初始化一个任意的实现类",
      "这样在多个实现类的情况下，在具体调用过程中可以不管具体实现操作，直接初始化接口的特定实现类",
      "在每个实现类中特性化地实现构造函数即可"
    ],
    "sentences": [
      "先上例子",
      "主要思路为在接口中定义一个静态的函数",
      "可以直接初始化一个任意的实现类",
      "这样在多个实现类的情况下",
      "在具体调用过程中可以不管具体实现操作",
      "直接初始化接口的特定实现类",
      "在每个实现类中特性化地实现构造函数即可"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "先上例子\n主要思路为在接口中定义一个静态的函数，可以直接初始化一个任意的实现类\n这样在多个实现类的情况下，在具体调用过程中可以不管具体实现操作，直接初始化接口的特定实现类\n在每个实现类中特性化地实现构造函数即可\n"
  },
  {
    "head": "set的基本用法",
    "paragraphs": [
      "set是一棵红黑树，在一些操作上十分高效，还具有许多priority_queue没有的功能",
      "下面是基本用法",
      "很多用到set时需要进行",
      "重载运算符",
      "，用法如下"
    ],
    "sentences": [
      "set是一棵红黑树",
      "在一些操作上十分高效",
      "还具有许多priority_queue没有的功能",
      "下面是基本用法",
      "很多用到set时需要进行",
      "重载运算符",
      "，用法如下"
    ],
    "codes": [
      "//set\n#include<set>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nset<int> s;\n\nint main()\n{\n    int n; \n    cin >> n;\n    for(int i = 1; i <= n; i++)\n    {\n        int t; \n        cin >> t;\n        s.insert(t);\n    }\n\n\n//遍历：   \n    set<int>::iterator it;    //正向迭代器 \n    for(it = s.begin(); it != s.end(); it++)    //正向遍历（即由小到大输出） \n        cout << *it << \" \";\n\n    cout << endl;\n\n    set<int>::reverse_iterator rit;    //反向迭代器 \n    for(rit = s.rbegin(); rit != s.rend(); rit++)    //反向遍历（即由大到小输出） \n        cout << *rit << \" \";\n\n//元素的删除：可以删除迭代器上的元素，等于某键值的元素，区间上的元素和清空集合\n    it = s.begin();\n    for(int i = 1; i <= 2; i++)\n        s.erase(it++);\n\n    for(it = s.begin(); it != s.end(); it++)    \n        cout << *it << \" \";\n    cout << endl;\n\n    s.clear();\n    for(it = s.begin(); it != s.end(); it++)    \n        cout << *it << \" \";\n    cout << endl;\n\n//元素的检索： 用s.find()，如果找到，则返回迭代器位置，否则返回s.end();\n    s.insert(5);\n    cout << *s.find(5) << endl;\n    if(s.find(20) == s.end()) cout << \"NO\";\n\n\n    return 0;\n}\n",
      "//set\n#include<set>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstruct mycmp        //当set中的元素不是结构体时 \n{\n    bool operator () (const int &a, const int &b)\n    {\n        return a%10 < b%10;\n    }\n};\nset<int, mycmp> s1;\n\nstruct point\n{\n    int x, y;\n    bool operator < (const point &a) const      //当set中的元素是结构体时,直接写在结构体中 \n    {\n        return x < a.x;     //按照x从小到大排序 \n    }\n};\nset<point> s2;\n\nint main()\n{\n    int n; cin >> n;\n    for(int i = 1; i <= n; i++)\n    {\n        int t; cin >> t; s1.insert(t);\n    }\n\n    set<int, mycmp>::iterator it1;\n\n    for(it1 = s1.begin(); it1 != s1.end(); it1++)\n        cout << *it1 <<  \" \";\n    cout << endl;\n\n    for(int i = 1; i <= n; i++)\n    {\n        point t;\n        cin >> t.x >> t.y;\n        s2.insert(t);\n    }\n    set<point>::iterator it2;\n    for(it2 = s2.begin(); it2 != s2.end(); it2++)\n        cout << (*it2).x << \" \";\n\n\n    return 0;\n}"
    ],
    "date": "2017-05-14",
    "text": "set是一棵红黑树，在一些操作上十分高效，还具有许多priority_queue没有的功能\n下面是基本用法\n很多用到set时需要进行\n重载运算符\n，用法如下\n"
  },
  {
    "head": "二分图（1）--染色问题",
    "paragraphs": [
      "题目大意：给定一个连通图，让你对它进行染色，总共黑白两种颜色，相邻两个节点不能是同一种颜色，问是否可以染",
      "解析：",
      "二分图：对于一个无向连通图，如果可以把所有点分成不相交的两部分，使所有边的起点和终点分别在两个部分内，称为二分图",
      "（即不能有边的起点和终点在一个部分内）",
      "转化为本题",
      "即为不能有边的起点和终点是同一种颜色",
      "代码实现：",
      "定义数组color[]，1表示白色，2表示黑色，0表示未访问",
      "用dfs，对于dfs(u)，遍历它的所有v，如果有v访问过并且与他同色，返回false",
      "对于未访问过的v,对他染色并dfs(v)，如果dfs(v)不成功dfs(u)也不成功"
    ],
    "sentences": [
      "题目大意：给定一个连通图",
      "让你对它进行染色",
      "总共黑白两种颜色",
      "相邻两个节点不能是同一种颜色",
      "问是否可以染",
      "解析：二分图：对于一个无向连通图",
      "如果可以把所有点分成不相交的两部分",
      "使所有边的起点和终点分别在两个部分内",
      "称为二分图",
      "（即不能有边的起点和终点在一个部分内）",
      "转化为本题",
      "即为不能有边的起点和终点是同一种颜色",
      "代码实现：定义数组color[]",
      "1表示白色",
      "2表示黑色",
      "0表示未访问",
      "用dfs",
      "对于dfs(u)",
      "遍历它的所有v",
      "如果有v访问过并且与他同色",
      "返回false",
      "对于未访问过的v,对他染色并dfs(v)",
      "如果dfs(v)不成功dfs(u)也不成功"
    ],
    "codes": [
      "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 1000 + 10;\nint color[MAXN];\nint n, m;\n\nint head[MAXN], cnt;\nstruct edge\n{\n    int to, next;\n} e[MAXN];\nvoid add(int u, int v)\n{\n    e[++cnt].next = head[u];\n    head[u] = cnt;\n    e[cnt].to = v;\n}\n\nbool erfen(int u)\n{\n    for(int i = head[u]; i; i = e[i].next)\n    {\n        int v = e[i].to;\n        if(color[u] == color[v]) return false;\n        if(!color[v])\n        {\n            color[v] = 3 - color[u];\n            if(!erfen(v)) return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    cin >> n >> m;\n    for(int i = 1; i <= m; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        add(u, v); add(v, u);\n    }\n\n    color[1] = 1;\n    if(erfen(1)) cout << \"YES\";\n    else cout << \"NO\";\n\n    return 0;\n}"
    ],
    "date": "2017-05-14",
    "text": "题目大意：给定一个连通图，让你对它进行染色，总共黑白两种颜色，相邻两个节点不能是同一种颜色，问是否可以染\n解析：\n二分图：对于一个无向连通图，如果可以把所有点分成不相交的两部分，使所有边的起点和终点分别在两个部分内，称为二分图\n（即不能有边的起点和终点在一个部分内）\n转化为本题\n即为不能有边的起点和终点是同一种颜色\n代码实现：\n定义数组color[]，1表示白色，2表示黑色，0表示未访问\n用dfs，对于dfs(u)，遍历它的所有v，如果有v访问过并且与他同色，返回false\n对于未访问过的v,对他染色并dfs(v)，如果dfs(v)不成功dfs(u)也不成功\n"
  },
  {
    "head": "Idea Test文件无法正常与运行文件链接 newInstanceWithCaller",
    "paragraphs": [
      "在编写完@Test代码测试程序时无法正常运行，出现如下问题",
      "这里可能是因为两个程序没有指定在一个package内，或者命名相同但测试文件夹指定不同",
      "可以在检查开头的package interval",
      "或者右键单击test文件夹，选择mark directory as选项"
    ],
    "sentences": [
      "在编写完@Test代码测试程序时无法正常运行，出现如下问题",
      "这里可能是因为两个程序没有指定在一个package内",
      "或者命名相同但测试文件夹指定不同",
      "可以在检查开头的package interval",
      "或者右键单击test文件夹",
      "选择mark directory as选项"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "在编写完@Test代码测试程序时无法正常运行，出现如下问题\n这里可能是因为两个程序没有指定在一个package内，或者命名相同但测试文件夹指定不同\n可以在检查开头的package interval\n或者右键单击test文件夹，选择mark directory as选项\n"
  },
  {
    "head": "无向图的割顶和桥",
    "paragraphs": [
      "给定一个无向连通图，有以下定义：",
      "：如果去掉一个节点，可以把这个无向连通图变成两个连通图，称其为割顶",
      "：同理，如果去掉一条边，可以把这个连通图变成两个，称其为桥",
      "求割顶和桥：",
      "令一个点为根，从这个点开始dfs",
      "用pre表示时间戳，每搜到一个还未搜到的点，标记搜到他的时间",
      "用low[]表示一个点可以连接的时间最早的点，而",
      "如果这个值还没有它的父亲的时间早或等于他父亲的时间，那么这个点的父亲一定是割顶",
      "如图（出自《算法竞赛入门经典训练指南》–刘汝佳）",
      "而如果这个值严格大于他父亲的时间，则连接他父亲和他的的这条边一定是桥",
      "如果一个点没有父亲，且只有一个儿子，那么他是根且一定不是割顶"
    ],
    "sentences": [
      "给定一个无向连通图",
      "有以下定义：：如果去掉一个节点",
      "可以把这个无向连通图变成两个连通图",
      "称其为割顶",
      "：同理，如果去掉一条边，可以把这个连通图变成两个，称其为桥",
      "求割顶和桥：令一个点为根，从这个点开始dfs",
      "用pre表示时间戳，每搜到一个还未搜到的点，标记搜到他的时间",
      "用low[]表示一个点可以连接的时间最早的点，而",
      "如果这个值还没有它的父亲的时间早或等于他父亲的时间",
      "那么这个点的父亲一定是割顶",
      "如图（出自《算法竞赛入门经典训练指南》–刘汝佳）",
      "而如果这个值严格大于他父亲的时间",
      "则连接他父亲和他的的这条边一定是桥",
      "如果一个点没有父亲，且只有一个儿子，那么他是根且一定不是割顶"
    ],
    "codes": [
      "//无向连通图的割顶与桥 \n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 1000 + 10;\nint n, m;\nint iscut[MAXN];    //是否为割顶\nint isbri[MAXN];    //是否为桥 \nint tim;\nint low[MAXN], pre[MAXN];\n\nint head[MAXN], cnt;\nstruct edge\n{\n    int to, next, num;\n} e[MAXN];\nvoid add(int u, int v, int y)\n{\n    e[++cnt].next = head[u];\n    head[u] = cnt;\n    e[cnt].to = v;\n    e[cnt].num = y;\n}\n\nint dfs(int u, int fa)\n{\n    int lowu = pre[u] = ++tim;\n    int child = 0;\n    for(int i = head[u]; i; i = e[i].next)\n    {\n        int v = e[i].to;\n        if(!pre[v])\n        {\n            child++;\n            int lowv = dfs(v, u);\n            lowu = min(lowu, lowv);    //用其子节点的low更新low值\n            if(lowv >= pre[u])    //如果v点的后代只能连到v自己，则该边为桥，且u为割顶，若还可以连到u，则u仍为割顶且该边不为桥 \n            {\n                if(lowv > pre[u]) isbri[e[i].num] = true;\n                iscut[u] = true;\n            } //{iscut[u] = true; isbri[e[i].num] = true;}\n        }\n        else if(pre[v] < pre[u] && v != fa) lowu = min(lowu, pre[v]);   //从他连到其父亲的边不是反向边，如果删除他父亲是不能连通的，重点\n    }\n    if(fa <= 0 && child == 1) iscut[u] = 0;  //如果u为根且只有一个儿子，不是割顶 \n    low[u] = lowu;\n    return low[u];\n}\n\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    for(int i = 1; i <= m; i++)\n    {\n        int u, v; cin >> u >> v;\n        add(u, v, i); add(v, u, i);\n    }\n\n\n\n    dfs(1, 0);\n\n    for(int i = 1; i <= n; i++)\n        if(iscut[i]) cout << i << \" \";\n\n    cout << endl;\n    for(int i = 1; i <= m; i++)\n        if(isbri[i]) cout << i << \" \";\n\n    return 0;\n}"
    ],
    "date": "2017-05-15",
    "text": "给定一个无向连通图，有以下定义：\n：如果去掉一个节点，可以把这个无向连通图变成两个连通图，称其为割顶\n：同理，如果去掉一条边，可以把这个连通图变成两个，称其为桥\n求割顶和桥：\n令一个点为根，从这个点开始dfs\n用pre表示时间戳，每搜到一个还未搜到的点，标记搜到他的时间\n用low[]表示一个点可以连接的时间最早的点，而\n如果这个值还没有它的父亲的时间早或等于他父亲的时间，那么这个点的父亲一定是割顶\n如图（出自《算法竞赛入门经典训练指南》–刘汝佳）\n而如果这个值严格大于他父亲的时间，则连接他父亲和他的的这条边一定是桥\n如果一个点没有父亲，且只有一个儿子，那么他是根且一定不是割顶\n"
  },
  {
    "head": "ADT设计时不可变性的保持",
    "paragraphs": [
      "分两种情况，属性为不可变和可变",
      "1. 例如一个ADT Graph，不能直接使用Graph.lenth （lenth为Graph中的一个属性），应该使用Graph.getLength()",
      "int length为不可变（基本数据类型都为不可变），可以直接return",
      "2.如果ADT的field中有如下定义",
      "Date是一个可变类型，那么我们使用修改函数进行修改时，需要返回一个新的修改的对象，而非对其直接进行修改",
      "无论可变不可变，return的一定是immutable的"
    ],
    "sentences": [
      "分两种情况，属性为不可变和可变",
      "1. 例如一个ADT Graph",
      "不能直接使用Graph.lenth （lenth为Graph中的一个属性）",
      "应该使用Graph.getLength()",
      "int length为不可变（基本数据类型都为不可变）",
      "可以直接return",
      "2.如果ADT的field中有如下定义",
      "Date是一个可变类型",
      "那么我们使用修改函数进行修改时",
      "需要返回一个新的修改的对象",
      "而非对其直接进行修改",
      "无论可变不可变，return的一定是immutable的"
    ],
    "codes": [
      "public int getLength() {\n    return this.length\n}",
      "public class Graph {\n    Date date;\n    int length;\n}"
    ],
    "date": "2021-07-07",
    "text": "分两种情况，属性为不可变和可变\n1. 例如一个ADT Graph，不能直接使用Graph.lenth （lenth为Graph中的一个属性），应该使用Graph.getLength()\nint length为不可变（基本数据类型都为不可变），可以直接return\n2.如果ADT的field中有如下定义\nDate是一个可变类型，那么我们使用修改函数进行修改时，需要返回一个新的修改的对象，而非对其直接进行修改\n无论可变不可变，return的一定是immutable的\n"
  },
  {
    "head": "Havel-Hakimi定理",
    "paragraphs": [
      "Havel定理是用来判断是否成图的，对于一个点的序列，现在已知每个点的度，要求判定是否可以按要求组成一个图",
      "判定过程：",
      "把所有点按照度的大小从大到小排序",
      "对首元素的度为s1，则删除该元素，把他后面的s1个元素的度都-1，然后重新排序",
      "不断重复这个循环，如果过程中有点的度变成了-1，则不能成图，如果最后所有点的度都为0，则可以成图",
      "可以在给点的度-1的时候把s1和后面的连起来，就可以输出图了",
      "例题：POJ1659（模板题，要输出图）",
      "（时间关系暂时不做）"
    ],
    "sentences": [
      "Havel定理是用来判断是否成图的",
      "对于一个点的序列",
      "现在已知每个点的度",
      "要求判定是否可以按要求组成一个图",
      "判定过程：把所有点按照度的大小从大到小排序",
      "对首元素的度为s1",
      "则删除该元素",
      "把他后面的s1个元素的度都-1",
      "然后重新排序",
      "不断重复这个循环",
      "如果过程中有点的度变成了-1",
      "则不能成图",
      "如果最后所有点的度都为0",
      "则可以成图",
      "可以在给点的度-1的时候把s1和后面的连起来，就可以输出图了",
      "例题：POJ1659（模板题，要输出图）",
      "（时间关系暂时不做）"
    ],
    "codes": [
      "//Havel-Hakimi\nbool Havel()\n{\n    for(int i = 1; i < n; i++)\n    {\n        sort(s+i, s+1+n, cmp);\n        if(i + s[i] >= n) return false;   //如果改点的度大于所剩的点，无法成图 \n        int u = s[i];\n        for(int j = i+1; j <= i+u; j++)\n        {\n            s[j]--;\n            if(s[j] < 0) return false;\n        }\n    }\n    if(s[n-1] != 0) return false;\n    return true;\n}"
    ],
    "date": "2017-05-13",
    "text": "Havel定理是用来判断是否成图的，对于一个点的序列，现在已知每个点的度，要求判定是否可以按要求组成一个图\n判定过程：\n把所有点按照度的大小从大到小排序\n对首元素的度为s1，则删除该元素，把他后面的s1个元素的度都-1，然后重新排序\n不断重复这个循环，如果过程中有点的度变成了-1，则不能成图，如果最后所有点的度都为0，则可以成图\n可以在给点的度-1的时候把s1和后面的连起来，就可以输出图了\n例题：POJ1659（模板题，要输出图）\n（时间关系暂时不做）\n"
  },
  {
    "head": "2-sat问题",
    "paragraphs": [
      "2-sat问题：",
      "给定一堆约束条件，每个都形如“xi为真/假或xj为真/假”，即：xi为真/假和xj为真/假中必有一个成立，现在问是否可以全部满足",
      "思路：",
      "可以把xi为真看成两个节点：2i, 2i+1（因为2i^1=2i+1，可以互相转化）",
      "假如说约束条件为“xi为真或xj为假”，那么2i表示“xi为真”为真，2i+1表示“xi为真”为假；2j表示“xj为假”为真，2j+1表示”xj为假“为假",
      "由2j+1为真可以推出2i为真，同理，由2i+1可以推出2j为真",
      "所以，可以从2j+1到2i；2i+1到2j连两条有向边",
      "对于起点u，可以假设他为真，并对他进行深搜，如果过程中发现有点的两个结点都为真，则不能",
      "再假设他为假，再深搜，如果他还是不能，则不能建图",
      "例题：",
      "有n架飞机要着陆，每个都可以选择早着陆或晚着陆，请安排着陆方式，要求着陆时间差值的最小值最大",
      "思路：”最小值最大“可以用二分，问题即可转化成着陆时间差值不大于mid是否成立，所以着陆时间小于mid的两个点，至多有一个成立，",
      "等价于这两个点的补至少有一个成立",
      "，这样就转化为了2-sat",
      "代码：（调了一个上午，参考刘汝佳《算法竞赛入门经典训练指南》）"
    ],
    "sentences": [
      "2-sat问题：给定一堆约束条件",
      "每个都形如“xi为真/假或xj为真/假”",
      "即：xi为真/假和xj为真/假中必有一个成立",
      "现在问是否可以全部满足",
      "思路：可以把xi为真看成两个节点：2i, 2i+1（因为2i^1=2i+1",
      "可以互相转化）",
      "假如说约束条件为“xi为真或xj为假”",
      "那么2i表示“xi为真”为真",
      "2i+1表示“xi为真”为假；2j表示“xj为假”为真",
      "2j+1表示”xj为假“为假",
      "由2j+1为真可以推出2i为真",
      "同理",
      "由2i+1可以推出2j为真",
      "所以，可以从2j+1到2i；2i+1到2j连两条有向边",
      "对于起点u",
      "可以假设他为真",
      "并对他进行深搜",
      "如果过程中发现有点的两个结点都为真",
      "则不能",
      "再假设他为假，再深搜，如果他还是不能，则不能建图",
      "例题：有n架飞机要着陆",
      "每个都可以选择早着陆或晚着陆",
      "请安排着陆方式",
      "要求着陆时间差值的最小值最大",
      "思路：”最小值最大“可以用二分",
      "问题即可转化成着陆时间差值不大于mid是否成立",
      "所以着陆时间小于mid的两个点",
      "至多有一个成立",
      "等价于这两个点的补至少有一个成立",
      "，这样就转化为了2-sat",
      "代码：（调了一个上午",
      "参考刘汝佳《算法竞赛入门经典训练指南》）"
    ],
    "codes": [
      "#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 2000 + 10;\n\n\nstruct twosat\n{\n    vector<int> G[MAXN*2];\n    bool mark[MAXN*2];\n    int s[MAXN*2], c;\n    int n;  //外面的n \n\n    bool dfs(int u)\n    {\n        if(mark[u^1]) return false;\n        if(mark[u]) return true;\n        mark[u] = true;\n        s[c++] = u;\n        for(int i = 0; i < G[u].size(); i++)\n        {\n            int v = G[u][i];\n            if(!dfs(v)) return false;\n        }\n        return true;\n    }\n\n    void init(int n)\n    {\n        this->n/*这个是外面的n*/ = n; //将外面的n赋值为里面的n\n        for(int i = 0; i < 2*n; i++)  G[i].clear();\n        memset(mark, 0, sizeof(mark));\n    }\n\n    void add(int x, int xval, int y, int yval)   //x == xval or y == yval\n    {\n        x = 2 * x + xval;   //2i\n        y = 2 * y + yval;   //2j\n        G[x^1].push_back(y);\n        G[y^1].push_back(x);\n    }\n\n    bool solve()\n    {\n        for(int i = 0; i < 2*n; i += 2)\n            if(!mark[i] && !mark[i+1])\n            {\n                c = 0;\n                if(!dfs(i)) \n                {\n                    while(c > 0) mark[s[--c]] = false; //如果深搜它不成功，则所有的假设都错误\n                    if(!dfs(i+1)) return false;   //如果假设他为真假都不对，不能成图 \n                }\n            }\n        return true;\n    }\n};\n\ntwosat solver;\n\nint t[MAXN][2], n;\n\nbool test(int mid)\n{\n    solver.init(n);    \n    for(int i = 0; i < n; i++) for(int a = 0; a <= 1; a++)\n        for(int j = i + 1; j < n; j++) for(int b = 0; b <= 1; b++)\n        {\n            if(abs(t[i][a] - t[j][b]) < mid) solver.add(i, a^1, j, b^1);\n        } \n    return solver.solve();\n}\n\nint main()\n{\n    cin >> n;\n    int l = 0, r = 0;\n    for(int i = 0; i < n; i++) for(int a = 0; a <= 1; a++)\n    {\n        cin >> t[i][a];\n        r = max(r, t[i][a]);\n    }\n\n    while(l < r)\n    {\n        int mid = l + (r-l+1)/2;    //令相邻两个着陆时间都 大于等于mid  //时间差小于mid的两个时间不能同时满足\n\n        if(test(mid)) l = mid; else r = mid-1;\n    }\n\n    cout << l;\n    return 0;\n\n\n}\n\n\n\n\n"
    ],
    "date": "2017-05-15",
    "text": "2-sat问题：\n给定一堆约束条件，每个都形如“xi为真/假或xj为真/假”，即：xi为真/假和xj为真/假中必有一个成立，现在问是否可以全部满足\n思路：\n可以把xi为真看成两个节点：2i, 2i+1（因为2i^1=2i+1，可以互相转化）\n假如说约束条件为“xi为真或xj为假”，那么2i表示“xi为真”为真，2i+1表示“xi为真”为假；2j表示“xj为假”为真，2j+1表示”xj为假“为假\n由2j+1为真可以推出2i为真，同理，由2i+1可以推出2j为真\n所以，可以从2j+1到2i；2i+1到2j连两条有向边\n对于起点u，可以假设他为真，并对他进行深搜，如果过程中发现有点的两个结点都为真，则不能\n再假设他为假，再深搜，如果他还是不能，则不能建图\n例题：\n有n架飞机要着陆，每个都可以选择早着陆或晚着陆，请安排着陆方式，要求着陆时间差值的最小值最大\n思路：”最小值最大“可以用二分，问题即可转化成着陆时间差值不大于mid是否成立，所以着陆时间小于mid的两个点，至多有一个成立，\n等价于这两个点的补至少有一个成立\n，这样就转化为了2-sat\n代码：（调了一个上午，参考刘汝佳《算法竞赛入门经典训练指南》）\n"
  },
  {
    "head": "java练手：万年历",
    "paragraphs": [
      "clock：",
      "int i,j;",
      "for(; ; )",
      "0||i%4",
      "0&&i%100!=0)",
      "if(j",
      "day=new Display(29);",
      "else if(j",
      "1||j",
      "3||j",
      "5||j",
      "7||j",
      "8||j",
      "10||j",
      "12)",
      "day=new Display(31);",
      "else",
      "day=new Display(30);",
      "else",
      "if(j",
      "day=new Display(28);",
      "else if(j",
      "1||j",
      "3||j",
      "5||j",
      "7||j",
      "8||j",
      "10||j",
      "12)",
      "day=new Display(31);",
      "else",
      "day=new Display(30);",
      "second.increase();",
      "if (second.getValue() == 0)",
      "miniute.increase();",
      "if (miniute.getValue() == 0)",
      "hour.increase();",
      "if(hour.getValue() == 0)",
      "day.increase();",
      "if(day.getValue() == 0)",
      "month.increase();",
      "if(month.getValue() == 0)",
      "year.increase();",
      "System.out.printf(\"%04d:%02d:%02d:%02d:%02d:%02d\\n\", year.getValue(),month.getValue(),day.getValue(),hour.getValue(), miniute.getValue(),second.getValue());"
    ],
    "sentences": [
      "clock：int i,j;for(; ; )",
      "0||i%4",
      "0&&i%100!=0)",
      "if(j",
      "day=new Display(29);else if(j",
      "1||j",
      "3||j",
      "5||j",
      "7||j",
      "8||j",
      "10||j",
      "12)",
      "day=new Display(31);else",
      "day=new Display(30);else",
      "if(j",
      "day=new Display(28);else if(j",
      "1||j",
      "3||j",
      "5||j",
      "7||j",
      "8||j",
      "10||j",
      "12)",
      "day=new Display(31);else",
      "day=new Display(30);second.increase();if (second.getValue() == 0)",
      "miniute.increase();if (miniute.getValue() == 0)",
      "hour.increase();if(hour.getValue() == 0)",
      "day.increase();if(day.getValue() == 0)",
      "month.increase();if(month.getValue() == 0)",
      "year.increase();System.out.printf(\"%04d:%02d:%02d:%02d:%02d:%02d\\n\", year.getValue(),month.getValue(),day.getValue(),hour.getValue(), miniute.getValue(),second.getValue());"
    ],
    "codes": [
      "}\n",
      "private int value=0;\nprivate int limit=0;\n\npublic Display(int limit)\n{\n\tthis.limit = limit;\n}\n\npublic void increase()\n{\n\tvalue++;\n\tif (value == limit)\n\t{\n\t\tvalue = 0;\n\t}\n}\n\npublic int getValue()\n{\n\treturn value;\n}\n",
      "package wannianli;",
      "public class Clock {",
      "private Display hour = new Display(24);",
      "private Display miniute= new Display(60);",
      "private Display second= new Display(60);",
      "private Display year= new Display(9999);",
      "private Display month= new Display(12);",
      "private Display day;",
      "public void start()",
      "i=year.getValue();",
      "j=month.getValue();",
      "if(i%400",
      "public static void main(String[] args) {",
      "Clock c = new Clock();",
      "c.start();",
      "display",
      "package wannianli;",
      "public class Display {"
    ],
    "date": "2021-07-07",
    "text": "clock：\nint i,j;\nfor(; ; )\n0||i%4\n0&&i%100!=0)\nif(j\nday=new Display(29);\nelse if(j\n1||j\n3||j\n5||j\n7||j\n8||j\n10||j\n12)\nday=new Display(31);\nelse\nday=new Display(30);\nelse\nif(j\nday=new Display(28);\nelse if(j\n1||j\n3||j\n5||j\n7||j\n8||j\n10||j\n12)\nday=new Display(31);\nelse\nday=new Display(30);\nsecond.increase();\nif (second.getValue() == 0)\nminiute.increase();\nif (miniute.getValue() == 0)\nhour.increase();\nif(hour.getValue() == 0)\nday.increase();\nif(day.getValue() == 0)\nmonth.increase();\nif(month.getValue() == 0)\nyear.increase();\nSystem.out.printf(\"%04d:%02d:%02d:%02d:%02d:%02d\\n\", year.getValue(),month.getValue(),day.getValue(),hour.getValue(), miniute.getValue(),second.getValue());\n"
  },
  {
    "head": "java练手：城市之间距离",
    "paragraphs": [],
    "sentences": [],
    "codes": [
      "public static void main(String[] args) {\n\tArrayList<String>hs=new ArrayList<String>();\n\tScanner in=new Scanner(System.in);\n\tString str;\n\tint n=0;\n\tSystem.out.println(\"请输入城市\");\n\tfor(;;)\n\t{\n\t\tstr=in.next();\n\t\tString s=\"###\";\n\t\tif(str.equals(s))\n\t\t{\n\t\t\tSystem.out.println(\"城市输入结束\");\n\t\t\tbreak;\n\t\t}//若输入“###”表示城市输入结束\n\t\ths.add(str);\n\t\tn++;\n\t}//循环读入城市并存入容器hs中\n\tint [][] a=new int[n][n];\n\tScanner in2= new Scanner(System.in);\n\tSystem.out.println(\"请输入距离\");\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\ta[i][j]=in2.nextInt();\n\t\t}\n\t}//将距离矩阵读入，存入二维数组a中\n\tSystem.out.println(\"结束输入距离\");\n\tString str1,str2;\n\tScanner in3= new Scanner(System.in);\n\tSystem.out.println(\"请输入两个城市\");\n\tstr1=in3.next();//读入第一个要比较的城市\n\tstr2=in3.next();//读入第二个要比较的城市\n\tint q=0,w=0;\n\tfor(int m=0;m<n;m++)\n\t{\n\t\tif(hs.get(m).equals(str1))\n\t\t{\n\t\t\tq=m;//记录下第一个城市在容器中位置，即矩阵横坐标\n\t\t\tbreak;\n\t\t}\n\t}//寻找第一个输入的城市在容器中的第几位\n\tfor(int m=0;m<n;m++)\n\t{\n\t\tif(hs.get(m).equals(str2))\n\t\t{\n\t\t\tw=m;//记录下第二个城市在容器中位置，即矩阵纵坐标\n\t\t\tbreak;\n\t\t}\n\t}//寻找第二个输入的城市在容器中的第几位\n\tSystem.out.println(\"输出距离：\"+a[q][w]);//矩阵第i行第j列表示第i个城市与第j个城市之间的距离\n}\n",
      "package java4;",
      "import java.util.ArrayList;",
      "import java.util.Scanner;",
      "public class a {"
    ],
    "date": "2021-07-07",
    "text": ""
  },
  {
    "head": "java中map相关知识和操作",
    "paragraphs": [
      "Map",
      "概述：",
      "Map用于保存具有映射关系的数据，Map集合里保存着两组值，一组用于保存Map的ley，另一组保存着Map的value。",
      "Map集合的功能概述",
      "a:添加功能",
      "put(K key,V value).",
      "b:删除功能",
      "void clear();",
      "value remove(key);",
      "c:判断功能",
      "d:获取功能",
      "value get(key);",
      "int size();//存在即返回键值，否则返回NULL，可以通过返回值来确定是否包含指定键，获取键值对的个数。",
      "e:长度功能",
      "int size()：返回集合中的键值对的对数",
      "f:取出所有元素",
      "先获取map集合中的键存放进set集合中。通过Set集合的迭代器取出Set集合中键， 通过map的get(key)方法获取键对应的值。",
      "g:Map下常用的子类：",
      "Hashtable：内部结构是哈希表。是同步的。不允许键和值为null。",
      "其内部子类Properties：用来存储键值对型的配置信息。",
      "HashMap：内部结构是哈希表，是不同步的。",
      "TreeMap：内部结构是二叉树。是不同步的，可以对Map中的键进行排序。"
    ],
    "sentences": [
      "Map",
      "概述：Map用于保存具有映射关系的数据",
      "Map集合里保存着两组值",
      "一组用于保存Map的ley",
      "另一组保存着Map的value",
      "Map集合的功能概述",
      "a:添加功能",
      "put(K key,V value).b:删除功能",
      "void clear();value remove(key);c:判断功能",
      "d:获取功能",
      "value get(key);int size();//存在即返回键值",
      "否则返回NULL",
      "可以通过返回值来确定是否包含指定键",
      "获取键值对的个数",
      "e:长度功能",
      "int size()：返回集合中的键值对的对数",
      "f:取出所有元素",
      "先获取map集合中的键存放进set集合中",
      "通过Set集合的迭代器取出Set集合中键",
      " 通过map的get(key)方法获取键对应的值",
      "g:Map下常用的子类：Hashtable：内部结构是哈希表",
      "是同步的",
      "不允许键和值为null",
      "其内部子类Properties：用来存储键值对型的配置信息",
      "HashMap：内部结构是哈希表，是不同步的",
      "TreeMap：内部结构是二叉树",
      "是不同步的，可以对Map中的键进行排序"
    ],
    "codes": [
      "boolean containsKey(key);",
      "boolean containsValue(value);",
      "boolean isEmpty()；"
    ],
    "date": "2021-07-07",
    "text": "Map\n概述：\nMap用于保存具有映射关系的数据，Map集合里保存着两组值，一组用于保存Map的ley，另一组保存着Map的value。\nMap集合的功能概述\na:添加功能\nput(K key,V value).\nb:删除功能\nvoid clear();\nvalue remove(key);\nc:判断功能\nd:获取功能\nvalue get(key);\nint size();//存在即返回键值，否则返回NULL，可以通过返回值来确定是否包含指定键，获取键值对的个数。\ne:长度功能\nint size()：返回集合中的键值对的对数\nf:取出所有元素\n先获取map集合中的键存放进set集合中。通过Set集合的迭代器取出Set集合中键， 通过map的get(key)方法获取键对应的值。\ng:Map下常用的子类：\nHashtable：内部结构是哈希表。是同步的。不允许键和值为null。\n其内部子类Properties：用来存储键值对型的配置信息。\nHashMap：内部结构是哈希表，是不同步的。\nTreeMap：内部结构是二叉树。是不同步的，可以对Map中的键进行排序。\n"
  },
  {
    "head": "关于git的一些知识",
    "paragraphs": [
      "1.git的一些命令",
      "添加文件：git add xx.xx",
      "提交文件：git commit -m “message”",
      "push到远程仓库：git push origin master",
      "从远程仓库pull：git pull origin master",
      "新建分支：git checkout -b branch_name",
      "切换分支：git checkout branch_name or git checkout master",
      "选择一个分支与当前分支合并：git merge branch_name2（之前已有指令git checkout branch_name1）",
      "2.使用git提交作业的时候，记得检查名字。若名字不对，进入settings里边修改。以实验2为例：",
      "3.初次接触git的时候，我们会比较迷茫。我们应该先学会如何配置git，通过网上的相关教程。有些教程存在错误，我们在多次检查之后，如果依然行不通，我们应该换一个教程。第一次配置的时候，我在同学的帮助下才完成。然后我们应该了解git的相关指令。记住指令，我们才能将写好的代码上传。",
      "4.分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。",
      "Git的功能特性：",
      "从一般开发者的角度来看，git有以下功能：",
      "1、从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。",
      "2、在自己的机器上根据不同的开发目的，创建分支，修改代码。",
      "3、在单机上自己创建的分支上提交代码。",
      "4、在单机上合并分支。",
      "5、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。",
      "6、生成补丁（patch），把补丁发送给主开发者。",
      "7、看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。",
      "8、一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。",
      "从主开发者的角度（假设主开发者不用开发代码）看，git有以下功能：",
      "1、查看邮件或者通过其它方式查看一般开发者的提交状态。",
      "2、打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。",
      "3、向公共服务器提交结果，然后通知所有开发人员。",
      "优点：",
      "适合分布式开发，强调个体。",
      "公共服务器压力和数据量都不会太大。",
      "速度快、灵活。",
      "任意两个开发者之间可以很容易的解决冲突。",
      "离线工作。",
      "缺点：",
      "学习周期相对而言比较长。",
      "不符合常规思维。",
      "代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。"
    ],
    "sentences": [
      "1.git的一些命令",
      "添加文件：git add xx.xx",
      "提交文件：git commit -m “message”",
      "push到远程仓库：git push origin master",
      "从远程仓库pull：git pull origin master",
      "新建分支：git checkout -b branch_name",
      "切换分支：git checkout branch_name or git checkout master",
      "选择一个分支与当前分支合并：git merge branch_name2（之前已有指令git checkout branch_name1）",
      "2.使用git提交作业的时候，记得检查名字",
      "若名字不对，进入settings里边修改",
      "以实验2为例：3.初次接触git的时候，我们会比较迷茫",
      "我们应该先学会如何配置git，通过网上的相关教程",
      "有些教程存在错误",
      "我们在多次检查之后",
      "如果依然行不通",
      "我们应该换一个教程",
      "第一次配置的时候，我在同学的帮助下才完成",
      "然后我们应该了解git的相关指令",
      "记住指令，我们才能将写好的代码上传",
      "4.分布式相比于集中式的最大区别在于开发者可以提交到本地",
      "每个开发者通过克隆（git clone）",
      "在本地机器上拷贝一个完整的Git仓库",
      "Git的功能特性：从一般开发者的角度来看",
      "git有以下功能：1、从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上",
      "2、在自己的机器上根据不同的开发目的，创建分支，修改代码",
      "3、在单机上自己创建的分支上提交代码",
      "4、在单机上合并分支",
      "5、把服务器上最新版的代码fetch下来",
      "然后跟自己的主分支合并",
      "6、生成补丁（patch），把补丁发送给主开发者",
      "7、看主开发者的反馈",
      "如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突）",
      "就会要求他们先解决冲突",
      "然后再由其中一个人提交",
      "如果主开发者可以自己解决，或者没有冲突，就通过",
      "8、一般开发者之间解决冲突的方法",
      "开发者之间可以使用pull 命令解决冲突",
      "解决完冲突之后再向主开发者提交补丁",
      "从主开发者的角度（假设主开发者不用开发代码）看",
      "git有以下功能：1、查看邮件或者通过其它方式查看一般开发者的提交状态",
      "2、打上补丁",
      "解决冲突（可以自己解决",
      "也可以要求开发者之间解决以后再重新提交",
      "如果是开源项目",
      "还要决定哪些补丁有用",
      "哪些不用）",
      "3、向公共服务器提交结果，然后通知所有开发人员",
      "优点：适合分布式开发，强调个体",
      "公共服务器压力和数据量都不会太大",
      "速度快、灵活",
      "任意两个开发者之间可以很容易的解决冲突",
      "离线工作",
      "缺点：学习周期相对而言比较长",
      "不符合常规思维",
      "代码保密性差",
      "一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "1.git的一些命令\n添加文件：git add xx.xx\n提交文件：git commit -m “message”\npush到远程仓库：git push origin master\n从远程仓库pull：git pull origin master\n新建分支：git checkout -b branch_name\n切换分支：git checkout branch_name or git checkout master\n选择一个分支与当前分支合并：git merge branch_name2（之前已有指令git checkout branch_name1）\n2.使用git提交作业的时候，记得检查名字。若名字不对，进入settings里边修改。以实验2为例：\n3.初次接触git的时候，我们会比较迷茫。我们应该先学会如何配置git，通过网上的相关教程。有些教程存在错误，我们在多次检查之后，如果依然行不通，我们应该换一个教程。第一次配置的时候，我在同学的帮助下才完成。然后我们应该了解git的相关指令。记住指令，我们才能将写好的代码上传。\n4.分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。\nGit的功能特性：\n从一般开发者的角度来看，git有以下功能：\n1、从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。\n2、在自己的机器上根据不同的开发目的，创建分支，修改代码。\n3、在单机上自己创建的分支上提交代码。\n4、在单机上合并分支。\n5、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。\n6、生成补丁（patch），把补丁发送给主开发者。\n7、看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。\n8、一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。\n从主开发者的角度（假设主开发者不用开发代码）看，git有以下功能：\n1、查看邮件或者通过其它方式查看一般开发者的提交状态。\n2、打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。\n3、向公共服务器提交结果，然后通知所有开发人员。\n优点：\n适合分布式开发，强调个体。\n公共服务器压力和数据量都不会太大。\n速度快、灵活。\n任意两个开发者之间可以很容易的解决冲突。\n离线工作。\n缺点：\n学习周期相对而言比较长。\n不符合常规思维。\n代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。\n"
  },
  {
    "head": "java中ArrayList相关应用",
    "paragraphs": [
      "初始化：",
      "1.动态初始化（指定长度）：数据类型[] 数组名称 = new 数据类型（数据长度）",
      "2.静态初始化（指定内容）：数据类型[]数组名称 = new 数据类型[]{元素1，元素2…}",
      "添加：",
      "获取集合元素：",
      "删除集合中的元素：",
      "System.out.println(“删除的是：”+a);",
      "获取集合长度",
      "System.out.println(“ArrayList集合长度：”+size);"
    ],
    "sentences": [
      "初始化：1.动态初始化（指定长度）：数据类型[] 数组名称 = new 数据类型（数据长度）",
      "2.静态初始化（指定内容）：数据类型[]数组名称 = new 数据类型[]{元素1",
      "元素2…}",
      "添加：获取集合元素：删除集合中的元素：System.out.println(“删除的是：”+a);获取集合长度",
      "System.out.println(“ArrayList集合长度：”+size);"
    ],
    "codes": [
      "ArrayList arrayList = new ArrayList();",
      "arrayList.add(“0”);",
      "arrayList.add(“1”);",
      "ArrayList arrayList = new ArrayList();",
      "arrayList.add(“0”);",
      "arrayList.add(“1”);",
      "arrayList.add(“2”);",
      "String a = arrayList.get(1);",
      "String b = arrayList.get(2);",
      "System.out.println(a);",
      "System.out.println(b);",
      "ArrayList arrayList = new ArrayList();",
      "arrayList.add(“0”);",
      "arrayList.add(“1”);",
      "arrayList.add(“2”);//先创建",
      "String a = arrayList.remove(3);",
      "ArrayList arrayList = new ArrayList();",
      "arrayList.add(“0”);",
      "arrayList.add(“1”);",
      "arrayList.add(“2”);//创建ArrayList集合",
      "int size = arrayList.size();"
    ],
    "date": "2021-07-07",
    "text": "初始化：\n1.动态初始化（指定长度）：数据类型[] 数组名称 = new 数据类型（数据长度）\n2.静态初始化（指定内容）：数据类型[]数组名称 = new 数据类型[]{元素1，元素2…}\n添加：\n获取集合元素：\n删除集合中的元素：\nSystem.out.println(“删除的是：”+a);\n获取集合长度\nSystem.out.println(“ArrayList集合长度：”+size);\n"
  },
  {
    "head": "面向对象编程",
    "paragraphs": [
      "面向对象(Object Oriented)是一种编程范式。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。面向对象与面向过程相对，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。",
      "面向对象的性质",
      "（1）对象唯一性",
      "每个对象都有自身唯一的标识，通过这种标识，可找到相应的对象。在对象的整个生命期中，它的标识都不改变，不同的对象不能有相同的标识。",
      "（2）抽象性",
      "抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。",
      "（3）继承性",
      "继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。",
      "继承性是面向对象程序设计语言不同于其它语言的最重要的特点，是其他语言所没有的。",
      "在类层次中，子类只继承一个父类的数据结构和方法，则称为单重继承。",
      "在类层次中，子类继承了多个父类的数据结构和方法，则称为多重继承。",
      "多重继承，JAVA、VB、NET、Objective-C均仅支持单继承，注意在C++多重继承时，需小心二义性。",
      "在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重用性。",
      "采用继承性，提供了类的规范的等级结构。通过类的继承关系，使公共的特性能够共享，提高了软件的重用性。",
      "（4）多态性",
      "多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。",
      "多态性允许每个对象以适合自身的方式去响应共同的消息。",
      "多态性增强了软件的灵活性和重用性。"
    ],
    "sentences": [
      "面向对象(Object Oriented)是一种编程范式",
      "面向对象是一种对现实世界理解和抽象的方法",
      "是计算机编程技术发展到一定阶段后的产物",
      "面向对象与面向过程相对",
      "面向对象方法",
      "把相关的数据和方法组织为一个整体来看待",
      "从更高的层次来进行系统建模",
      "更贴近事物的自然运行模式",
      "面向对象的性质",
      "（1）对象唯一性",
      "每个对象都有自身唯一的标识，通过这种标识，可找到相应的对象",
      "在对象的整个生命期中",
      "它的标识都不改变",
      "不同的对象不能有相同的标识",
      "（2）抽象性",
      "抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类",
      "一个类就是这样一种抽象",
      "它反映了与应用有关的重要性质",
      "而忽略其他一些无关内容",
      "任何类的划分都是主观的，但必须与具体的应用有关",
      "（3）继承性",
      "继承性是子类自动共享父类数据结构和方法的机制",
      "这是类之间的一种关系",
      "在定义和实现一个类的时候",
      "可以在一个已经存在的类的基础之上来进行",
      "把这个已经存在的类所定义的内容作为自己的内容",
      "并加入若干新的内容",
      "继承性是面向对象程序设计语言不同于其它语言的最重要的特点",
      "是其他语言所没有的",
      "在类层次中",
      "子类只继承一个父类的数据结构和方法",
      "则称为单重继承",
      "在类层次中",
      "子类继承了多个父类的数据结构和方法",
      "则称为多重继承",
      "多重继承",
      "JAVA、VB、NET、Objective-C均仅支持单继承",
      "注意在C++多重继承时",
      "需小心二义性",
      "在软件开发中",
      "类的继承性使所建立的软件具有开放性、可扩充性",
      "这是信息组织与分类的行之有效的方法",
      "它简化了对象、类的创建工作量",
      "增加了代码的可重用性",
      "采用继承性，提供了类的规范的等级结构",
      "通过类的继承关系，使公共的特性能够共享，提高了软件的重用性",
      "（4）多态性",
      "多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果",
      "不同的对象",
      "收到同一消息可以产生不同的结果",
      "这种现象称为多态性",
      "多态性允许每个对象以适合自身的方式去响应共同的消息",
      "多态性增强了软件的灵活性和重用性"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "面向对象(Object Oriented)是一种编程范式。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。面向对象与面向过程相对，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。\n面向对象的性质\n（1）对象唯一性\n每个对象都有自身唯一的标识，通过这种标识，可找到相应的对象。在对象的整个生命期中，它的标识都不改变，不同的对象不能有相同的标识。\n（2）抽象性\n抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。\n（3）继承性\n继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。\n继承性是面向对象程序设计语言不同于其它语言的最重要的特点，是其他语言所没有的。\n在类层次中，子类只继承一个父类的数据结构和方法，则称为单重继承。\n在类层次中，子类继承了多个父类的数据结构和方法，则称为多重继承。\n多重继承，JAVA、VB、NET、Objective-C均仅支持单继承，注意在C++多重继承时，需小心二义性。\n在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重用性。\n采用继承性，提供了类的规范的等级结构。通过类的继承关系，使公共的特性能够共享，提高了软件的重用性。\n（4）多态性\n多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。\n多态性允许每个对象以适合自身的方式去响应共同的消息。\n多态性增强了软件的灵活性和重用性。\n"
  },
  {
    "head": "软件构造lab2",
    "paragraphs": [
      "实验目标概述",
      "根据实验手册简要撰写。",
      "针对给定的应用问题，从问题描述中识别所需的",
      "ADT",
      "ADT",
      "规约（",
      "pre-condition",
      "post-condition",
      "）并评估规约的质量；",
      "ADT",
      "的规约设计测试用例；",
      "ADT",
      "的泛型化；",
      "根据规约设计",
      "ADT",
      "的多种不同的实现；针对每种实现，设计其表示（",
      "representation",
      "）、表示不变性（",
      "rep invariant",
      "）、抽象过程（",
      "abstraction function",
      "OOP",
      "ADT",
      "，并判定表示不变性是否违反、各实现是否存在表示泄露（",
      "repexposure",
      "ADT",
      "的实现并评估测试的覆盖度；",
      "ADT",
      "及其实现，为应用问题开发程序；",
      "在测试代码中，能够写出",
      "testing strategy",
      "并据此设计测试用例。",
      "实验环境配置",
      "简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。",
      "特别是要记录配置过程中遇到的问题和困难，以及如何解决的。",
      "安装配置",
      "EclEmma",
      "在这里给出你的",
      "GitHub Lab2",
      "仓库的",
      "URL",
      "地址（",
      "Lab2-",
      "学号）。",
      "实验过程",
      "请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。",
      "Poetic Walks",
      "在这里简要概述你对该任务的理解。",
      "实现并测试具有标记顶点的",
      "Graph",
      "。然后实现一个使用单词的图生成诗歌的类",
      "Get the code and prepare Git repository",
      "如何从",
      "GitHub",
      "获取该任务的代码、在本地创建",
      "git",
      "仓库、使用",
      "git",
      "管理本地开发。",
      "从实验指南中发布的链接上直接下载获取",
      "Problem 1: Test Graph <String>",
      "以下各部分，请按照",
      "MIT",
      "页面上相应部分的要求，逐项列出你的设计和实现思路",
      "结果。",
      "testadd():",
      "测试能不能加入新顶点",
      "testSet():",
      "测试能不能加入一条新边",
      "testRemove():",
      "在图中加入一条边，然后删除某顶点，测试这条边是否还存在",
      "testVertices():",
      "向图中加入顶点测试集合是否正确",
      "testsSources():",
      "向图中加入顶点和边测试是否返回源头点和权重",
      "testTargets():",
      "向图中加入顶点和边测试测试某顶点相连是否正确",
      "Problem 2: Implement Graph <String>",
      "以下各部分，请按照",
      "MIT",
      "页面上相应部分的要求，逐项列出你的设计和实现思路",
      "结果。",
      "Implement ConcreteEdgesGraph",
      "Edge：用source表示源点，target表示目标点，weight表示权重，编写get以上三种数据，然后检查是否存在非法数据",
      "Implement ConcreteVerticesGraph",
      "Vertex",
      "：用vertexname表示顶点，map存储与改点有关的数据，check检查是否存在空顶点。",
      "Problem 3: Implement generic Graph<L>",
      "Make the implementations generic",
      "搜索所有的string并将其转换为L",
      "Implement ",
      "conctreteedgesgraph",
      "（）实现",
      "借助测试用例实现功能",
      "Implement GraphPoet",
      "从文本中获得单词图，返回处理好的字符串",
      "Graph poetry slam",
      "使用Eclemma检查测试的代码覆盖度",
      "Before you’re done",
      "请按照",
      "C:\\Users\\a\\Downloads\\before_youre_done",
      "http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done",
      "的说明，检查你的程序。",
      "如何通过",
      "Git",
      "提交当前版本到",
      "GitHub",
      "上你的",
      "Lab2",
      "仓库。",
      "在这里给出你的项目的目录结构树状示意图。",
      "Re-implement the Social Network in Lab1",
      "在这里简要概述你对该任务的理解。",
      "在定义了Graph的情况下，实现friendshipgraph类",
      "FriendshipGraph类",
      "给出你的设计和实现思路",
      "结果。",
      "用Graph表示人物关系",
      "Addvertex",
      "（）添加顶点",
      "Getdistance",
      "（）寻找最短路径并返回路径长度",
      "Person类",
      "给出你的设计和实现思路",
      "结果。",
      "Name",
      "表示顶点名字。",
      "Distance",
      "表示最短距离。",
      "Map",
      "存储所有相连顶点及其权重",
      "List",
      "存储所有相连顶点",
      "Check",
      "检查是否有重复级和空元素",
      "客户端main()",
      "给出你的设计和实现思路",
      "结果。",
      "由lab1实验指南可得",
      "测试用例",
      "给出你的设计和实现思路",
      "结果。",
      "提交至Git仓库",
      "如何通过",
      "Git",
      "提交当前版本到",
      "GitHub",
      "上你的",
      "Lab3",
      "仓库。",
      "在这里给出你的项目的目录结构树状示意图。",
      "实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。",
      "不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。",
      "时间段",
      "计划任务",
      "实际完成情况",
      "2021/6/5",
      "19:00-22:00",
      "3.1",
      "2021/6/7",
      "19:00-22:00",
      "3.2",
      "粗糙完成",
      "2021/6/13",
      "12:00-16:00",
      "修改bug，完成报告",
      "实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "函数较为复杂，编写过程中多次出现问题",
      "继续练习，熟练编写技巧",
      "分析图中关系时顺序混乱",
      "从头理头绪",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "丰富了对于不同类的理解和应用，进一步提高了编程和算法能力",
      "针对以下方面的感受",
      "ADT",
      "的编程和直接面向应用场景编程，你体会到二者有何差异？",
      "ADT",
      "能够复用数据结构和一系列方法，让代码更加清晰",
      "使用泛型和不使用泛型的编程，对你来说有何差异？",
      "泛型更方便但限制条件多",
      "在给出",
      "ADT",
      "的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？",
      "在一边实现具体类时可以一边测试，利于修改",
      "设计的",
      "ADT",
      "在多个应用场景下使用，这种复用带来什么好处？",
      "能够提高效率",
      "要求你从",
      "开始设计",
      "ADT",
      "并使用它们完成一个具体应用，你是否已适应从具体应用场景到",
      "ADT",
      "的“抽象映射”？相比起",
      "给出了",
      "ADT",
      "非常明确的",
      "rep",
      "和方法、",
      "ADT",
      "之间的逻辑关系，",
      "要求你自主设计这些内容，你的感受如何？",
      "还没理解透彻，仍感到一些困难",
      "ADT",
      "specification, invariants, RI, AF",
      "，时刻注意",
      "ADT",
      "是否有",
      "rep exposure",
      "，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "使开发者能够注意步骤，避免编程混乱",
      "关于本实验的工作量、难度、",
      "deadline",
      "工作量比较大，需要比较长的时间",
      "《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "学会了如何提高效率，实现更好的编译",
      "实验目标概述",
      "根据实验手册简要撰写。",
      "针对给定的应用问题，从问题描述中识别所需的",
      "ADT",
      "ADT",
      "规约（",
      "pre-condition",
      "post-condition",
      "）并评估规约的质量；",
      "ADT",
      "的规约设计测试用例；",
      "ADT",
      "的泛型化；",
      "根据规约设计",
      "ADT",
      "的多种不同的实现；针对每种实现，设计其表示（",
      "representation",
      "）、表示不变性（",
      "rep invariant",
      "）、抽象过程（",
      "abstraction function",
      "OOP",
      "ADT",
      "，并判定表示不变性是否违反、各实现是否存在表示泄露（",
      "repexposure",
      "ADT",
      "的实现并评估测试的覆盖度；",
      "ADT",
      "及其实现，为应用问题开发程序；",
      "在测试代码中，能够写出",
      "testing strategy",
      "并据此设计测试用例。",
      "实验环境配置",
      "简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。",
      "特别是要记录配置过程中遇到的问题和困难，以及如何解决的。",
      "安装配置",
      "EclEmma",
      "在这里给出你的",
      "GitHub Lab2",
      "仓库的",
      "URL",
      "地址（",
      "Lab2-",
      "学号）。",
      "实验过程",
      "请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。",
      "Poetic Walks",
      "在这里简要概述你对该任务的理解。",
      "实现并测试具有标记顶点的",
      "Graph",
      "。然后实现一个使用单词的图生成诗歌的类",
      "Get the code and prepare Git repository",
      "如何从",
      "GitHub",
      "获取该任务的代码、在本地创建",
      "git",
      "仓库、使用",
      "git",
      "管理本地开发。",
      "从实验指南中发布的链接上直接下载获取",
      "Problem 1: Test Graph <String>",
      "以下各部分，请按照",
      "MIT",
      "页面上相应部分的要求，逐项列出你的设计和实现思路",
      "结果。",
      "testadd():",
      "测试能不能加入新顶点",
      "testSet():",
      "测试能不能加入一条新边",
      "testRemove():",
      "在图中加入一条边，然后删除某顶点，测试这条边是否还存在",
      "testVertices():",
      "向图中加入顶点测试集合是否正确",
      "testsSources():",
      "向图中加入顶点和边测试是否返回源头点和权重",
      "testTargets():",
      "向图中加入顶点和边测试测试某顶点相连是否正确",
      "Problem 2: Implement Graph <String>",
      "以下各部分，请按照",
      "MIT",
      "页面上相应部分的要求，逐项列出你的设计和实现思路",
      "结果。",
      "Implement ConcreteEdgesGraph",
      "Edge：用source表示源点，target表示目标点，weight表示权重，编写get以上三种数据，然后检查是否存在非法数据",
      "Implement ConcreteVerticesGraph",
      "Vertex",
      "：用vertexname表示顶点，map存储与改点有关的数据，check检查是否存在空顶点。",
      "Problem 3: Implement generic Graph<L>",
      "Make the implementations generic",
      "搜索所有的string并将其转换为L",
      "Implement Graph.empty()",
      "conctreteedgesgraph",
      "（）实现",
      "Graph.empty()",
      "借助测试用例实现功能",
      "Implement GraphPoet",
      "从文本中获得单词图，返回处理好的字符串",
      "Graph poetry slam",
      "使用Eclemma检查测试的代码覆盖度",
      "Before you’re done",
      "请按照",
      "C:\\Users\\a\\Downloads\\before_youre_done",
      "http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done",
      "的说明，检查你的程序。",
      "如何通过",
      "Git",
      "提交当前版本到",
      "GitHub",
      "上你的",
      "Lab2",
      "仓库。",
      "在这里给出你的项目的目录结构树状示意图。",
      "Re-implement the Social Network in Lab1",
      "在这里简要概述你对该任务的理解。",
      "在定义了Graph的情况下，实现friendshipgraph类",
      "FriendshipGraph类",
      "给出你的设计和实现思路",
      "结果。",
      "用Graph表示人物关系",
      "Addvertex",
      "（）添加顶点",
      "Getdistance",
      "（）寻找最短路径并返回路径长度",
      "Person类",
      "给出你的设计和实现思路",
      "结果。",
      "Name",
      "表示顶点名字。",
      "Distance",
      "表示最短距离。",
      "Map",
      "存储所有相连顶点及其权重",
      "List",
      "存储所有相连顶点",
      "Check",
      "检查是否有重复级和空元素",
      "客户端main()",
      "给出你的设计和实现思路",
      "结果。",
      "由lab1实验指南可得",
      "测试用例",
      "给出你的设计和实现思路",
      "结果。",
      "提交至Git仓库",
      "如何通过",
      "Git",
      "提交当前版本到",
      "GitHub",
      "上你的",
      "Lab3",
      "仓库。",
      "在这里给出你的项目的目录结构树状示意图。",
      "实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。",
      "不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。",
      "时间段",
      "计划任务",
      "实际完成情况",
      "2021/6/5",
      "19:00-22:00",
      "3.1",
      "2021/6/7",
      "19:00-22:00",
      "3.2",
      "粗糙完成",
      "2021/6/13",
      "12:00-16:00",
      "修改bug，完成报告",
      "实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "函数较为复杂，编写过程中多次出现问题",
      "继续练习，熟练编写技巧",
      "分析图中关系时顺序混乱",
      "从头理头绪",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "丰富了对于不同类的理解和应用，进一步提高了编程和算法能力",
      "针对以下方面的感受",
      "ADT",
      "的编程和直接面向应用场景编程，你体会到二者有何差异？",
      "ADT",
      "能够复用数据结构和一系列方法，让代码更加清晰",
      "使用泛型和不使用泛型的编程，对你来说有何差异？",
      "泛型更方便但限制条件多",
      "在给出",
      "ADT",
      "的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？",
      "在一边实现具体类时可以一边测试，利于修改",
      "设计的",
      "ADT",
      "在多个应用场景下使用，这种复用带来什么好处？",
      "能够提高效率",
      "要求你从",
      "开始设计",
      "ADT",
      "并使用它们完成一个具体应用，你是否已适应从具体应用场景到",
      "ADT",
      "的“抽象映射”？相比起",
      "给出了",
      "ADT",
      "非常明确的",
      "rep",
      "和方法、",
      "ADT",
      "之间的逻辑关系，",
      "要求你自主设计这些内容，你的感受如何？",
      "还没理解透彻，仍感到一些困难",
      "ADT",
      "specification, invariants, RI, AF",
      "，时刻注意",
      "ADT",
      "是否有",
      "rep exposure",
      "，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "使开发者能够注意步骤，避免编程混乱",
      "关于本实验的工作量、难度、",
      "deadline",
      "工作量比较大，需要比较长的时间",
      "《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "学会了如何提高效率，实现更好的编译"
    ],
    "sentences": [
      "实验目标概述",
      "根据实验手册简要撰写",
      "针对给定的应用问题，从问题描述中识别所需的",
      "ADT",
      "ADT",
      "规约（",
      "pre-condition",
      "post-condition",
      "）并评估规约的质量；ADT",
      "的规约设计测试用例；ADT",
      "的泛型化；根据规约设计",
      "ADT",
      "的多种不同的实现；针对每种实现，设计其表示（",
      "representation",
      "）、表示不变性（",
      "rep invariant",
      "）、抽象过程（",
      "abstraction function",
      "OOP",
      "ADT",
      "，并判定表示不变性是否违反、各实现是否存在表示泄露（",
      "repexposure",
      "ADT",
      "的实现并评估测试的覆盖度；ADT",
      "及其实现，为应用问题开发程序；在测试代码中，能够写出",
      "testing strategy",
      "并据此设计测试用例",
      "实验环境配置",
      "简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图",
      "特别是要记录配置过程中遇到的问题和困难，以及如何解决的",
      "安装配置",
      "EclEmma",
      "在这里给出你的",
      "GitHub Lab2",
      "仓库的",
      "URL",
      "地址（",
      "Lab2-",
      "学号）",
      "实验过程",
      "请仔细对照实验手册",
      "针对三个问题中的每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）",
      "Poetic Walks",
      "在这里简要概述你对该任务的理解",
      "实现并测试具有标记顶点的",
      "Graph",
      "然后实现一个使用单词的图生成诗歌的类",
      "Get the code and prepare Git repository",
      "如何从",
      "GitHub",
      "获取该任务的代码、在本地创建",
      "git",
      "仓库、使用",
      "git",
      "管理本地开发",
      "从实验指南中发布的链接上直接下载获取",
      "Problem 1: Test Graph <String>",
      "以下各部分，请按照",
      "MIT",
      "页面上相应部分的要求，逐项列出你的设计和实现思路",
      "结果",
      "testadd():测试能不能加入新顶点",
      "testSet():测试能不能加入一条新边",
      "testRemove():在图中加入一条边",
      "然后删除某顶点",
      "测试这条边是否还存在",
      "testVertices():向图中加入顶点测试集合是否正确",
      "testsSources():向图中加入顶点和边测试是否返回源头点和权重",
      "testTargets():向图中加入顶点和边测试测试某顶点相连是否正确",
      "Problem 2: Implement Graph <String>",
      "以下各部分，请按照",
      "MIT",
      "页面上相应部分的要求，逐项列出你的设计和实现思路",
      "结果",
      "Implement ConcreteEdgesGraph",
      "Edge：用source表示源点",
      "target表示目标点",
      "weight表示权重",
      "编写get以上三种数据",
      "然后检查是否存在非法数据",
      "Implement ConcreteVerticesGraph",
      "Vertex",
      "：用vertexname表示顶点",
      "map存储与改点有关的数据",
      "check检查是否存在空顶点",
      "Problem 3: Implement generic Graph<L>",
      "Make the implementations generic",
      "搜索所有的string并将其转换为L",
      "Implement ",
      "conctreteedgesgraph",
      "（）实现",
      "借助测试用例实现功能",
      "Implement GraphPoet",
      "从文本中获得单词图，返回处理好的字符串",
      "Graph poetry slam",
      "使用Eclemma检查测试的代码覆盖度",
      "Before you’re done",
      "请按照",
      "C:\\Users\\a\\Downloads\\before_youre_done",
      "http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done",
      "的说明，检查你的程序",
      "如何通过",
      "Git",
      "提交当前版本到",
      "GitHub",
      "上你的",
      "Lab2",
      "仓库",
      "在这里给出你的项目的目录结构树状示意图",
      "Re-implement the Social Network in Lab1",
      "在这里简要概述你对该任务的理解",
      "在定义了Graph的情况下",
      "实现friendshipgraph类",
      "FriendshipGraph类",
      "给出你的设计和实现思路",
      "结果",
      "用Graph表示人物关系",
      "Addvertex",
      "（）添加顶点",
      "Getdistance",
      "（）寻找最短路径并返回路径长度",
      "Person类",
      "给出你的设计和实现思路",
      "结果",
      "Name",
      "表示顶点名字",
      "Distance",
      "表示最短距离",
      "Map",
      "存储所有相连顶点及其权重",
      "List",
      "存储所有相连顶点",
      "Check",
      "检查是否有重复级和空元素",
      "客户端main()",
      "给出你的设计和实现思路",
      "结果",
      "由lab1实验指南可得",
      "测试用例",
      "给出你的设计和实现思路",
      "结果",
      "提交至Git仓库",
      "如何通过",
      "Git",
      "提交当前版本到",
      "GitHub",
      "上你的",
      "Lab3",
      "仓库",
      "在这里给出你的项目的目录结构树状示意图",
      "实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "每次结束编程时，请向该表格中增加一行",
      "不要事后胡乱填写",
      "不要嫌烦",
      "该表格可帮助你汇总你在每个任务上付出的时间和精力",
      "发现自己不擅长的任务",
      "后续有意识的弥补",
      "时间段",
      "计划任务",
      "实际完成情况",
      "2021/6/5",
      "19:00-22:00",
      "3.1",
      "2021/6/7",
      "19:00-22:00",
      "3.2",
      "粗糙完成",
      "2021/6/13",
      "12:00-16:00",
      "修改bug，完成报告",
      "实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "函数较为复杂，编写过程中多次出现问题",
      "继续练习，熟练编写技巧",
      "分析图中关系时顺序混乱",
      "从头理头绪",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "丰富了对于不同类的理解和应用，进一步提高了编程和算法能力",
      "针对以下方面的感受",
      "ADT",
      "的编程和直接面向应用场景编程，你体会到二者有何差异？",
      "ADT",
      "能够复用数据结构和一系列方法，让代码更加清晰",
      "使用泛型和不使用泛型的编程，对你来说有何差异？",
      "泛型更方便但限制条件多",
      "在给出",
      "ADT",
      "的规约后就开始编写测试用例",
      "优势是什么？你是否能够适应这种测试方式？",
      "在一边实现具体类时可以一边测试，利于修改",
      "设计的",
      "ADT",
      "在多个应用场景下使用，这种复用带来什么好处？",
      "能够提高效率",
      "要求你从",
      "开始设计",
      "ADT",
      "并使用它们完成一个具体应用，你是否已适应从具体应用场景到",
      "ADT",
      "的“抽象映射”？相比起",
      "给出了",
      "ADT",
      "非常明确的",
      "rep",
      "和方法、ADT",
      "之间的逻辑关系，要求你自主设计这些内容，你的感受如何？",
      "还没理解透彻，仍感到一些困难",
      "ADT",
      "specification, invariants, RI, AF",
      "，时刻注意",
      "ADT",
      "是否有",
      "rep exposure",
      "，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "使开发者能够注意步骤，避免编程混乱",
      "关于本实验的工作量、难度、deadline",
      "工作量比较大，需要比较长的时间",
      "《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "学会了如何提高效率，实现更好的编译",
      "实验目标概述",
      "根据实验手册简要撰写",
      "针对给定的应用问题，从问题描述中识别所需的",
      "ADT",
      "ADT",
      "规约（",
      "pre-condition",
      "post-condition",
      "）并评估规约的质量；ADT",
      "的规约设计测试用例；ADT",
      "的泛型化；根据规约设计",
      "ADT",
      "的多种不同的实现；针对每种实现，设计其表示（",
      "representation",
      "）、表示不变性（",
      "rep invariant",
      "）、抽象过程（",
      "abstraction function",
      "OOP",
      "ADT",
      "，并判定表示不变性是否违反、各实现是否存在表示泄露（",
      "repexposure",
      "ADT",
      "的实现并评估测试的覆盖度；ADT",
      "及其实现，为应用问题开发程序；在测试代码中，能够写出",
      "testing strategy",
      "并据此设计测试用例",
      "实验环境配置",
      "简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图",
      "特别是要记录配置过程中遇到的问题和困难，以及如何解决的",
      "安装配置",
      "EclEmma",
      "在这里给出你的",
      "GitHub Lab2",
      "仓库的",
      "URL",
      "地址（",
      "Lab2-",
      "学号）",
      "实验过程",
      "请仔细对照实验手册",
      "针对三个问题中的每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）",
      "Poetic Walks",
      "在这里简要概述你对该任务的理解",
      "实现并测试具有标记顶点的",
      "Graph",
      "然后实现一个使用单词的图生成诗歌的类",
      "Get the code and prepare Git repository",
      "如何从",
      "GitHub",
      "获取该任务的代码、在本地创建",
      "git",
      "仓库、使用",
      "git",
      "管理本地开发",
      "从实验指南中发布的链接上直接下载获取",
      "Problem 1: Test Graph <String>",
      "以下各部分，请按照",
      "MIT",
      "页面上相应部分的要求，逐项列出你的设计和实现思路",
      "结果",
      "testadd():测试能不能加入新顶点",
      "testSet():测试能不能加入一条新边",
      "testRemove():在图中加入一条边",
      "然后删除某顶点",
      "测试这条边是否还存在",
      "testVertices():向图中加入顶点测试集合是否正确",
      "testsSources():向图中加入顶点和边测试是否返回源头点和权重",
      "testTargets():向图中加入顶点和边测试测试某顶点相连是否正确",
      "Problem 2: Implement Graph <String>",
      "以下各部分，请按照",
      "MIT",
      "页面上相应部分的要求，逐项列出你的设计和实现思路",
      "结果",
      "Implement ConcreteEdgesGraph",
      "Edge：用source表示源点",
      "target表示目标点",
      "weight表示权重",
      "编写get以上三种数据",
      "然后检查是否存在非法数据",
      "Implement ConcreteVerticesGraph",
      "Vertex",
      "：用vertexname表示顶点",
      "map存储与改点有关的数据",
      "check检查是否存在空顶点",
      "Problem 3: Implement generic Graph<L>",
      "Make the implementations generic",
      "搜索所有的string并将其转换为L",
      "Implement Graph.empty()",
      "conctreteedgesgraph",
      "（）实现",
      "Graph.empty()",
      "借助测试用例实现功能",
      "Implement GraphPoet",
      "从文本中获得单词图，返回处理好的字符串",
      "Graph poetry slam",
      "使用Eclemma检查测试的代码覆盖度",
      "Before you’re done",
      "请按照",
      "C:\\Users\\a\\Downloads\\before_youre_done",
      "http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done",
      "的说明，检查你的程序",
      "如何通过",
      "Git",
      "提交当前版本到",
      "GitHub",
      "上你的",
      "Lab2",
      "仓库",
      "在这里给出你的项目的目录结构树状示意图",
      "Re-implement the Social Network in Lab1",
      "在这里简要概述你对该任务的理解",
      "在定义了Graph的情况下",
      "实现friendshipgraph类",
      "FriendshipGraph类",
      "给出你的设计和实现思路",
      "结果",
      "用Graph表示人物关系",
      "Addvertex",
      "（）添加顶点",
      "Getdistance",
      "（）寻找最短路径并返回路径长度",
      "Person类",
      "给出你的设计和实现思路",
      "结果",
      "Name",
      "表示顶点名字",
      "Distance",
      "表示最短距离",
      "Map",
      "存储所有相连顶点及其权重",
      "List",
      "存储所有相连顶点",
      "Check",
      "检查是否有重复级和空元素",
      "客户端main()",
      "给出你的设计和实现思路",
      "结果",
      "由lab1实验指南可得",
      "测试用例",
      "给出你的设计和实现思路",
      "结果",
      "提交至Git仓库",
      "如何通过",
      "Git",
      "提交当前版本到",
      "GitHub",
      "上你的",
      "Lab3",
      "仓库",
      "在这里给出你的项目的目录结构树状示意图",
      "实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "每次结束编程时，请向该表格中增加一行",
      "不要事后胡乱填写",
      "不要嫌烦",
      "该表格可帮助你汇总你在每个任务上付出的时间和精力",
      "发现自己不擅长的任务",
      "后续有意识的弥补",
      "时间段",
      "计划任务",
      "实际完成情况",
      "2021/6/5",
      "19:00-22:00",
      "3.1",
      "2021/6/7",
      "19:00-22:00",
      "3.2",
      "粗糙完成",
      "2021/6/13",
      "12:00-16:00",
      "修改bug，完成报告",
      "实验过程中遇到的困难与解决途径",
      "遇到的难点",
      "解决途径",
      "函数较为复杂，编写过程中多次出现问题",
      "继续练习，熟练编写技巧",
      "分析图中关系时顺序混乱",
      "从头理头绪",
      "实验过程中收获的经验、教训、感想",
      "实验过程中收获的经验和教训",
      "丰富了对于不同类的理解和应用，进一步提高了编程和算法能力",
      "针对以下方面的感受",
      "ADT",
      "的编程和直接面向应用场景编程，你体会到二者有何差异？",
      "ADT",
      "能够复用数据结构和一系列方法，让代码更加清晰",
      "使用泛型和不使用泛型的编程，对你来说有何差异？",
      "泛型更方便但限制条件多",
      "在给出",
      "ADT",
      "的规约后就开始编写测试用例",
      "优势是什么？你是否能够适应这种测试方式？",
      "在一边实现具体类时可以一边测试，利于修改",
      "设计的",
      "ADT",
      "在多个应用场景下使用，这种复用带来什么好处？",
      "能够提高效率",
      "要求你从",
      "开始设计",
      "ADT",
      "并使用它们完成一个具体应用，你是否已适应从具体应用场景到",
      "ADT",
      "的“抽象映射”？相比起",
      "给出了",
      "ADT",
      "非常明确的",
      "rep",
      "和方法、ADT",
      "之间的逻辑关系，要求你自主设计这些内容，你的感受如何？",
      "还没理解透彻，仍感到一些困难",
      "ADT",
      "specification, invariants, RI, AF",
      "，时刻注意",
      "ADT",
      "是否有",
      "rep exposure",
      "，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "使开发者能够注意步骤，避免编程混乱",
      "关于本实验的工作量、难度、deadline",
      "工作量比较大，需要比较长的时间",
      "《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "学会了如何提高效率，实现更好的编译"
    ],
    "codes": [
      "Graph.empty()",
      "Problem 4: Poetic walks",
      "Test GraphPoet",
      "Git add",
      "Git commit -m “xxxx”",
      "Git push origin master",
      "Graph.empty()",
      "Problem 4: Poetic walks",
      "Test GraphPoet",
      "Git add",
      "Git commit -m “xxxx”",
      "Git push origin master"
    ],
    "date": "2021-07-06",
    "text": "实验目标概述\n根据实验手册简要撰写。\n针对给定的应用问题，从问题描述中识别所需的\nADT\nADT\n规约（\npre-condition\npost-condition\n）并评估规约的质量；\nADT\n的规约设计测试用例；\nADT\n的泛型化；\n根据规约设计\nADT\n的多种不同的实现；针对每种实现，设计其表示（\nrepresentation\n）、表示不变性（\nrep invariant\n）、抽象过程（\nabstraction function\nOOP\nADT\n，并判定表示不变性是否违反、各实现是否存在表示泄露（\nrepexposure\nADT\n的实现并评估测试的覆盖度；\nADT\n及其实现，为应用问题开发程序；\n在测试代码中，能够写出\ntesting strategy\n并据此设计测试用例。\n实验环境配置\n简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。\n特别是要记录配置过程中遇到的问题和困难，以及如何解决的。\n安装配置\nEclEmma\n在这里给出你的\nGitHub Lab2\n仓库的\nURL\n地址（\nLab2-\n学号）。\n实验过程\n请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\nPoetic Walks\n在这里简要概述你对该任务的理解。\n实现并测试具有标记顶点的\nGraph\n。然后实现一个使用单词的图生成诗歌的类\nGet the code and prepare Git repository\n如何从\nGitHub\n获取该任务的代码、在本地创建\ngit\n仓库、使用\ngit\n管理本地开发。\n从实验指南中发布的链接上直接下载获取\nProblem 1: Test Graph <String>\n以下各部分，请按照\nMIT\n页面上相应部分的要求，逐项列出你的设计和实现思路\n结果。\ntestadd():\n测试能不能加入新顶点\ntestSet():\n测试能不能加入一条新边\ntestRemove():\n在图中加入一条边，然后删除某顶点，测试这条边是否还存在\ntestVertices():\n向图中加入顶点测试集合是否正确\ntestsSources():\n向图中加入顶点和边测试是否返回源头点和权重\ntestTargets():\n向图中加入顶点和边测试测试某顶点相连是否正确\nProblem 2: Implement Graph <String>\n以下各部分，请按照\nMIT\n页面上相应部分的要求，逐项列出你的设计和实现思路\n结果。\nImplement ConcreteEdgesGraph\nEdge：用source表示源点，target表示目标点，weight表示权重，编写get以上三种数据，然后检查是否存在非法数据\nImplement ConcreteVerticesGraph\nVertex\n：用vertexname表示顶点，map存储与改点有关的数据，check检查是否存在空顶点。\nProblem 3: Implement generic Graph<L>\nMake the implementations generic\n搜索所有的string并将其转换为L\nImplement \nconctreteedgesgraph\n（）实现\n借助测试用例实现功能\nImplement GraphPoet\n从文本中获得单词图，返回处理好的字符串\nGraph poetry slam\n使用Eclemma检查测试的代码覆盖度\nBefore you’re done\n请按照\nC:\\Users\\a\\Downloads\\before_youre_done\nhttp://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done\n的说明，检查你的程序。\n如何通过\nGit\n提交当前版本到\nGitHub\n上你的\nLab2\n仓库。\n在这里给出你的项目的目录结构树状示意图。\nRe-implement the Social Network in Lab1\n在这里简要概述你对该任务的理解。\n在定义了Graph的情况下，实现friendshipgraph类\nFriendshipGraph类\n给出你的设计和实现思路\n结果。\n用Graph表示人物关系\nAddvertex\n（）添加顶点\nGetdistance\n（）寻找最短路径并返回路径长度\nPerson类\n给出你的设计和实现思路\n结果。\nName\n表示顶点名字。\nDistance\n表示最短距离。\nMap\n存储所有相连顶点及其权重\nList\n存储所有相连顶点\nCheck\n检查是否有重复级和空元素\n客户端main()\n给出你的设计和实现思路\n结果。\n由lab1实验指南可得\n测试用例\n给出你的设计和实现思路\n结果。\n提交至Git仓库\n如何通过\nGit\n提交当前版本到\nGitHub\n上你的\nLab3\n仓库。\n在这里给出你的项目的目录结构树状示意图。\n实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。\n不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。\n时间段\n计划任务\n实际完成情况\n2021/6/5\n19:00-22:00\n3.1\n2021/6/7\n19:00-22:00\n3.2\n粗糙完成\n2021/6/13\n12:00-16:00\n修改bug，完成报告\n实验过程中遇到的困难与解决途径\n遇到的难点\n解决途径\n函数较为复杂，编写过程中多次出现问题\n继续练习，熟练编写技巧\n分析图中关系时顺序混乱\n从头理头绪\n实验过程中收获的经验、教训、感想\n实验过程中收获的经验和教训\n丰富了对于不同类的理解和应用，进一步提高了编程和算法能力\n针对以下方面的感受\nADT\n的编程和直接面向应用场景编程，你体会到二者有何差异？\nADT\n能够复用数据结构和一系列方法，让代码更加清晰\n使用泛型和不使用泛型的编程，对你来说有何差异？\n泛型更方便但限制条件多\n在给出\nADT\n的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？\n在一边实现具体类时可以一边测试，利于修改\n设计的\nADT\n在多个应用场景下使用，这种复用带来什么好处？\n能够提高效率\n要求你从\n开始设计\nADT\n并使用它们完成一个具体应用，你是否已适应从具体应用场景到\nADT\n的“抽象映射”？相比起\n给出了\nADT\n非常明确的\nrep\n和方法、\nADT\n之间的逻辑关系，\n要求你自主设计这些内容，你的感受如何？\n还没理解透彻，仍感到一些困难\nADT\nspecification, invariants, RI, AF\n，时刻注意\nADT\n是否有\nrep exposure\n，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？\n使开发者能够注意步骤，避免编程混乱\n关于本实验的工作量、难度、\ndeadline\n工作量比较大，需要比较长的时间\n《软件构造》课程进展到目前，你对该课程有何体会和建议？\n学会了如何提高效率，实现更好的编译\n实验目标概述\n根据实验手册简要撰写。\n针对给定的应用问题，从问题描述中识别所需的\nADT\nADT\n规约（\npre-condition\npost-condition\n）并评估规约的质量；\nADT\n的规约设计测试用例；\nADT\n的泛型化；\n根据规约设计\nADT\n的多种不同的实现；针对每种实现，设计其表示（\nrepresentation\n）、表示不变性（\nrep invariant\n）、抽象过程（\nabstraction function\nOOP\nADT\n，并判定表示不变性是否违反、各实现是否存在表示泄露（\nrepexposure\nADT\n的实现并评估测试的覆盖度；\nADT\n及其实现，为应用问题开发程序；\n在测试代码中，能够写出\ntesting strategy\n并据此设计测试用例。\n实验环境配置\n简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。\n特别是要记录配置过程中遇到的问题和困难，以及如何解决的。\n安装配置\nEclEmma\n在这里给出你的\nGitHub Lab2\n仓库的\nURL\n地址（\nLab2-\n学号）。\n实验过程\n请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\nPoetic Walks\n在这里简要概述你对该任务的理解。\n实现并测试具有标记顶点的\nGraph\n。然后实现一个使用单词的图生成诗歌的类\nGet the code and prepare Git repository\n如何从\nGitHub\n获取该任务的代码、在本地创建\ngit\n仓库、使用\ngit\n管理本地开发。\n从实验指南中发布的链接上直接下载获取\nProblem 1: Test Graph <String>\n以下各部分，请按照\nMIT\n页面上相应部分的要求，逐项列出你的设计和实现思路\n结果。\ntestadd():\n测试能不能加入新顶点\ntestSet():\n测试能不能加入一条新边\ntestRemove():\n在图中加入一条边，然后删除某顶点，测试这条边是否还存在\ntestVertices():\n向图中加入顶点测试集合是否正确\ntestsSources():\n向图中加入顶点和边测试是否返回源头点和权重\ntestTargets():\n向图中加入顶点和边测试测试某顶点相连是否正确\nProblem 2: Implement Graph <String>\n以下各部分，请按照\nMIT\n页面上相应部分的要求，逐项列出你的设计和实现思路\n结果。\nImplement ConcreteEdgesGraph\nEdge：用source表示源点，target表示目标点，weight表示权重，编写get以上三种数据，然后检查是否存在非法数据\nImplement ConcreteVerticesGraph\nVertex\n：用vertexname表示顶点，map存储与改点有关的数据，check检查是否存在空顶点。\nProblem 3: Implement generic Graph<L>\nMake the implementations generic\n搜索所有的string并将其转换为L\nImplement Graph.empty()\nconctreteedgesgraph\n（）实现\nGraph.empty()\n借助测试用例实现功能\nImplement GraphPoet\n从文本中获得单词图，返回处理好的字符串\nGraph poetry slam\n使用Eclemma检查测试的代码覆盖度\nBefore you’re done\n请按照\nC:\\Users\\a\\Downloads\\before_youre_done\nhttp://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done\n的说明，检查你的程序。\n如何通过\nGit\n提交当前版本到\nGitHub\n上你的\nLab2\n仓库。\n在这里给出你的项目的目录结构树状示意图。\nRe-implement the Social Network in Lab1\n在这里简要概述你对该任务的理解。\n在定义了Graph的情况下，实现friendshipgraph类\nFriendshipGraph类\n给出你的设计和实现思路\n结果。\n用Graph表示人物关系\nAddvertex\n（）添加顶点\nGetdistance\n（）寻找最短路径并返回路径长度\nPerson类\n给出你的设计和实现思路\n结果。\nName\n表示顶点名字。\nDistance\n表示最短距离。\nMap\n存储所有相连顶点及其权重\nList\n存储所有相连顶点\nCheck\n检查是否有重复级和空元素\n客户端main()\n给出你的设计和实现思路\n结果。\n由lab1实验指南可得\n测试用例\n给出你的设计和实现思路\n结果。\n提交至Git仓库\n如何通过\nGit\n提交当前版本到\nGitHub\n上你的\nLab3\n仓库。\n在这里给出你的项目的目录结构树状示意图。\n实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。\n不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。\n时间段\n计划任务\n实际完成情况\n2021/6/5\n19:00-22:00\n3.1\n2021/6/7\n19:00-22:00\n3.2\n粗糙完成\n2021/6/13\n12:00-16:00\n修改bug，完成报告\n实验过程中遇到的困难与解决途径\n遇到的难点\n解决途径\n函数较为复杂，编写过程中多次出现问题\n继续练习，熟练编写技巧\n分析图中关系时顺序混乱\n从头理头绪\n实验过程中收获的经验、教训、感想\n实验过程中收获的经验和教训\n丰富了对于不同类的理解和应用，进一步提高了编程和算法能力\n针对以下方面的感受\nADT\n的编程和直接面向应用场景编程，你体会到二者有何差异？\nADT\n能够复用数据结构和一系列方法，让代码更加清晰\n使用泛型和不使用泛型的编程，对你来说有何差异？\n泛型更方便但限制条件多\n在给出\nADT\n的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？\n在一边实现具体类时可以一边测试，利于修改\n设计的\nADT\n在多个应用场景下使用，这种复用带来什么好处？\n能够提高效率\n要求你从\n开始设计\nADT\n并使用它们完成一个具体应用，你是否已适应从具体应用场景到\nADT\n的“抽象映射”？相比起\n给出了\nADT\n非常明确的\nrep\n和方法、\nADT\n之间的逻辑关系，\n要求你自主设计这些内容，你的感受如何？\n还没理解透彻，仍感到一些困难\nADT\nspecification, invariants, RI, AF\n，时刻注意\nADT\n是否有\nrep exposure\n，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？\n使开发者能够注意步骤，避免编程混乱\n关于本实验的工作量、难度、\ndeadline\n工作量比较大，需要比较长的时间\n《软件构造》课程进展到目前，你对该课程有何体会和建议？\n学会了如何提高效率，实现更好的编译\n"
  },
  {
    "head": "ArrayList LinkList效率对比",
    "paragraphs": [
      "由于老师上课的时候讲到了ArrayList LinkList效率不同，于是课下查找资料，并写了一个二者效率对比的小代码。",
      "首先通过查找资料我了解到：1. LinkedList和ArrayList的差别主要来自于Array和LinkedList数据结构的不同。ArrayList是基于数组实现的，LinkedList是基于双链表实现的。另外LinkedList类不仅是List接口的实现类，可以根据索引来随机访问集合中的元素，除此之外，LinkedList还实现了Deque接口，它代表一个双向队列，因此LinkedList可以作为双向队列 ，栈和List集合使用。",
      "2. 因为Array是基于索引的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。",
      "3. 相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引。",
      "4. LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。",
      "首先我们测试ArrayList LinkList增加新的内容时效率上的区别。代码如下：",
      "测试结果为：",
      "可以看出array比link快。可能是因为在不修改指针的时候，在往数据末尾新增的时候速度还是比LinkList速度快。",
      "然后测试插入操作：",
      "结果为：",
      "可以看出link确实比array快很多，因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。"
    ],
    "sentences": [
      "由于老师上课的时候讲到了ArrayList LinkList效率不同",
      "于是课下查找资料",
      "并写了一个二者效率对比的小代码",
      "首先通过查找资料我了解到：1. LinkedList和ArrayList的差别主要来自于Array和LinkedList数据结构的不同",
      "ArrayList是基于数组实现的",
      "LinkedList是基于双链表实现的",
      "另外LinkedList类不仅是List接口的实现类",
      "可以根据索引来随机访问集合中的元素",
      "除此之外",
      "LinkedList还实现了Deque接口",
      "它代表一个双向队列",
      "因此LinkedList可以作为双向队列 ",
      "栈和List集合使用",
      "2. 因为Array是基于索引的数据结构",
      "它使用索引在数组中搜索和读取数据是很快的",
      "可以直接返回数组中index位置的元素",
      "因此在随机访问集合元素上有较好的性能",
      "Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的",
      "因为这需要移动数组中插入位置之后的的所有元素",
      "3. 相对于ArrayList",
      "LinkedList的随机访问集合元素时性能较差",
      "因为需要在双向列表中找到要index的位置",
      "再返回；但在插入",
      "删除操作是更快的",
      "因为LinkedList不像ArrayList一样",
      "不需要改变数组的大小",
      "也不需要在数组装满的时候要将所有的数据重新装入一个新的数组",
      "这是ArrayList最坏的一种情况",
      "时间复杂度是O(n)",
      "而LinkedList中插入或删除的时间复杂度仅为O(1)",
      "ArrayList在插入数据时还需要更新索引",
      "4. LinkedList需要更多的内存",
      "因为ArrayList的每个索引的位置是实际的数据",
      "而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置",
      "首先我们测试ArrayList LinkList增加新的内容时效率上的区别",
      "代码如下：测试结果为：可以看出array比link快",
      "可能是因为在不修改指针的时候",
      "在往数据末尾新增的时候速度还是比LinkList速度快",
      "然后测试插入操作：结果为：可以看出link确实比array快很多",
      "因为LinkedList不像ArrayList一样",
      "不需要改变数组的大小",
      "也不需要在数组装满的时候要将所有的数据重新装入一个新的数组",
      "这是ArrayList最坏的一种情况",
      "时间复杂度是O(n)",
      "而LinkedList中插入或删除的时间复杂度仅为O(1)"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "由于老师上课的时候讲到了ArrayList LinkList效率不同，于是课下查找资料，并写了一个二者效率对比的小代码。\n首先通过查找资料我了解到：1. LinkedList和ArrayList的差别主要来自于Array和LinkedList数据结构的不同。ArrayList是基于数组实现的，LinkedList是基于双链表实现的。另外LinkedList类不仅是List接口的实现类，可以根据索引来随机访问集合中的元素，除此之外，LinkedList还实现了Deque接口，它代表一个双向队列，因此LinkedList可以作为双向队列 ，栈和List集合使用。\n2. 因为Array是基于索引的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。\n3. 相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引。\n4. LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。\n首先我们测试ArrayList LinkList增加新的内容时效率上的区别。代码如下：\n测试结果为：\n可以看出array比link快。可能是因为在不修改指针的时候，在往数据末尾新增的时候速度还是比LinkList速度快。\n然后测试插入操作：\n结果为：\n可以看出link确实比array快很多，因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。\n"
  },
  {
    "head": "软件构造笔记（四）：Spec、AF和RI",
    "paragraphs": [
      "本文将介绍一些关于ADT设计中Spec、AF和RI的细节。由于内容较为细碎，为了加强理解，特将该部分知识点列出来，进行简单归纳总结。",
      "一. Spec",
      "刚开始接触软件构造时，关于规约Spec的概念便已经有所接触，但真正开始逐步认识还是在实验中设计规约的时候。",
      "（一）含义",
      "Spec是程序员在设计ADT时对自己所写方法的规约，它规定了方法应该做什么，不应该做什么。而在接下来的设计中，测试用例的编写就需要依靠Spec的描述，因为程序员所编写的代码必定是符合spec的，否则就是不合格的。同时，有了Spec的存在，客户端在使用代码时就会有所依据，好的Spec可以大大节省客户端使用自己的API时所需要的时间，并且大大降低了客户端对自己所编写的代码的误解。",
      "（二）内容及评判标准",
      "Spec的主要内容分为以下三部分：",
      "1. 前置条件precondition：这是对客户端的约束，是用户在使用方法时必须满足的条件。在Java中一般使用声明@param说明每个参数的前置条件。",
      "2. 后置条件postcondition：这是对开发者的约束，也是方法结束时设计者必须满足的内容。在Java中一般使用如下两种声明，其内容及用途如下：",
      "@return：对后置条件的说明，一般为返回值；",
      "@throws：说明出现异常的时候会发生什么，一般为异常处理方式。",
      "（三）Spec强弱",
      "若想要Spec变强，可以采用如下方式：",
      "1. 更宽松的前置条件",
      "2. 更严格的后置条件",
      "如果是用椭圆在图中对不同的Spec强弱进行表示，则越小（包含的结果的点越少）的椭圆，其Spec越强，",
      "此处我们可以理解为：椭圆的大小代表了开发者的自由度。",
      "（四）注意事项",
      "程序员应该通过Spec让客户端轻松地知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，",
      "但不应该让用户知道方法的内部逻辑是怎么样的",
      "，以避免恶意用户对代码结构的破坏。",
      "二. AF和RI",
      "由于AF和RI之间存在映射关系，因此可以将两者放在一起进行讨论。",
      "（一）含义",
      "RI：Rep Invariant。其中Invariant是不变量的意思，是ADT的功能中任何时候都应该满足的一些条件。",
      "AF：Abstraction Function。代表抽象函数。",
      "（二）具体表示",
      "AF和RI中的A和R分别代表两个空间：R是内部表示的空间，是开发者关注的内容；而A是ADT能表示的存在于实际的对象，一般是由客户所关注的。",
      "而AF就是从R空间到A空间的一个映射，作为解释函数，",
      "对A空间的每一个对象，在R空间中都至少由一种属性或类型与之对应，因此该映射是一个满射",
      "而RI是一个集合，是R空间中所有值的子集，包含了所有合法的表示值。checkRep()方法就是用来随时检查RI是否被满足的。",
      "此处附上自己在lab2中写过的AF、RI，以及Safety from rep exposure的描述：",
      "（三）注意事项",
      "RI、AF存在如下关系：",
      "相同的R可能存在不同的RI；",
      "即使是同样的R、 RI，也可以根据解释不同，而获得不同的AF；",
      "两个ADT有相同的rep和相同的AF，但其R也不—定相同。",
      "不应该给client看的内容有AF、RI、Rep exposure safety argument、testing strategy、Rep、Implementation和Test cases等等，留给client的只有Spec",
      "本文主要解释了一些ADT设计中关于Spec、AF和RI的含义、内容、注意事项等内容。其细节部分相对琐碎，但是在实际应用中非常重要，因此应该牢记，并在日后有需求的时候活学活用。"
    ],
    "sentences": [
      "本文将介绍一些关于ADT设计中Spec、AF和RI的细节",
      "由于内容较为细碎",
      "为了加强理解",
      "特将该部分知识点列出来",
      "进行简单归纳总结",
      "一. Spec",
      "刚开始接触软件构造时",
      "关于规约Spec的概念便已经有所接触",
      "但真正开始逐步认识还是在实验中设计规约的时候",
      "（一）含义",
      "Spec是程序员在设计ADT时对自己所写方法的规约",
      "它规定了方法应该做什么",
      "不应该做什么",
      "而在接下来的设计中",
      "测试用例的编写就需要依靠Spec的描述",
      "因为程序员所编写的代码必定是符合spec的",
      "否则就是不合格的",
      "同时",
      "有了Spec的存在",
      "客户端在使用代码时就会有所依据",
      "好的Spec可以大大节省客户端使用自己的API时所需要的时间",
      "并且大大降低了客户端对自己所编写的代码的误解",
      "（二）内容及评判标准",
      "Spec的主要内容分为以下三部分：1. 前置条件precondition：这是对客户端的约束",
      "是用户在使用方法时必须满足的条件",
      "在Java中一般使用声明@param说明每个参数的前置条件",
      "2. 后置条件postcondition：这是对开发者的约束",
      "也是方法结束时设计者必须满足的内容",
      "在Java中一般使用如下两种声明",
      "其内容及用途如下：@return：对后置条件的说明",
      "一般为返回值；@throws：说明出现异常的时候会发生什么",
      "一般为异常处理方式",
      "（三）Spec强弱",
      "若想要Spec变强，可以采用如下方式：1. 更宽松的前置条件",
      "2. 更严格的后置条件",
      "如果是用椭圆在图中对不同的Spec强弱进行表示",
      "则越小（包含的结果的点越少）的椭圆",
      "其Spec越强",
      "此处我们可以理解为：椭圆的大小代表了开发者的自由度",
      "（四）注意事项",
      "程序员应该通过Spec让客户端轻松地知道他需要为这个方法提供什么样的参数",
      "以及会得到什么样的结果",
      "但不应该让用户知道方法的内部逻辑是怎么样的",
      "，以避免恶意用户对代码结构的破坏",
      "二. AF和RI",
      "由于AF和RI之间存在映射关系",
      "因此可以将两者放在一起进行讨论",
      "（一）含义",
      "RI：Rep Invariant",
      "其中Invariant是不变量的意思",
      "是ADT的功能中任何时候都应该满足的一些条件",
      "AF：Abstraction Function",
      "代表抽象函数",
      "（二）具体表示",
      "AF和RI中的A和R分别代表两个空间：R是内部表示的空间",
      "是开发者关注的内容；而A是ADT能表示的存在于实际的对象",
      "一般是由客户所关注的",
      "而AF就是从R空间到A空间的一个映射",
      "作为解释函数",
      "对A空间的每一个对象",
      "在R空间中都至少由一种属性或类型与之对应",
      "因此该映射是一个满射",
      "而RI是一个集合",
      "是R空间中所有值的子集",
      "包含了所有合法的表示值",
      "checkRep()方法就是用来随时检查RI是否被满足的",
      "此处附上自己在lab2中写过的AF、RI",
      "以及Safety from rep exposure的描述：（三）注意事项",
      "RI、AF存在如下关系：相同的R可能存在不同的RI；即使是同样的R、 RI",
      "也可以根据解释不同",
      "而获得不同的AF；两个ADT有相同的rep和相同的AF",
      "但其R也不—定相同",
      "不应该给client看的内容有AF、RI、Rep exposure safety argument、testing strategy、Rep、Implementation和Test cases等等",
      "留给client的只有Spec",
      "本文主要解释了一些ADT设计中关于Spec、AF和RI的含义、内容、注意事项等内容",
      "其细节部分相对琐碎",
      "但是在实际应用中非常重要",
      "因此应该牢记",
      "并在日后有需求的时候活学活用"
    ],
    "codes": [
      "// Abstraction function:\n    // AF(vertices) = 点集\n    // Representation invariant:\n    // 无重复点\n    // Safety from rep exposure:\n    // private final List<Vertex<L>> vertices"
    ],
    "date": "2021-07-07",
    "text": "本文将介绍一些关于ADT设计中Spec、AF和RI的细节。由于内容较为细碎，为了加强理解，特将该部分知识点列出来，进行简单归纳总结。\n一. Spec\n刚开始接触软件构造时，关于规约Spec的概念便已经有所接触，但真正开始逐步认识还是在实验中设计规约的时候。\n（一）含义\nSpec是程序员在设计ADT时对自己所写方法的规约，它规定了方法应该做什么，不应该做什么。而在接下来的设计中，测试用例的编写就需要依靠Spec的描述，因为程序员所编写的代码必定是符合spec的，否则就是不合格的。同时，有了Spec的存在，客户端在使用代码时就会有所依据，好的Spec可以大大节省客户端使用自己的API时所需要的时间，并且大大降低了客户端对自己所编写的代码的误解。\n（二）内容及评判标准\nSpec的主要内容分为以下三部分：\n1. 前置条件precondition：这是对客户端的约束，是用户在使用方法时必须满足的条件。在Java中一般使用声明@param说明每个参数的前置条件。\n2. 后置条件postcondition：这是对开发者的约束，也是方法结束时设计者必须满足的内容。在Java中一般使用如下两种声明，其内容及用途如下：\n@return：对后置条件的说明，一般为返回值；\n@throws：说明出现异常的时候会发生什么，一般为异常处理方式。\n（三）Spec强弱\n若想要Spec变强，可以采用如下方式：\n1. 更宽松的前置条件\n2. 更严格的后置条件\n如果是用椭圆在图中对不同的Spec强弱进行表示，则越小（包含的结果的点越少）的椭圆，其Spec越强，\n此处我们可以理解为：椭圆的大小代表了开发者的自由度。\n（四）注意事项\n程序员应该通过Spec让客户端轻松地知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，\n但不应该让用户知道方法的内部逻辑是怎么样的\n，以避免恶意用户对代码结构的破坏。\n二. AF和RI\n由于AF和RI之间存在映射关系，因此可以将两者放在一起进行讨论。\n（一）含义\nRI：Rep Invariant。其中Invariant是不变量的意思，是ADT的功能中任何时候都应该满足的一些条件。\nAF：Abstraction Function。代表抽象函数。\n（二）具体表示\nAF和RI中的A和R分别代表两个空间：R是内部表示的空间，是开发者关注的内容；而A是ADT能表示的存在于实际的对象，一般是由客户所关注的。\n而AF就是从R空间到A空间的一个映射，作为解释函数，\n对A空间的每一个对象，在R空间中都至少由一种属性或类型与之对应，因此该映射是一个满射\n而RI是一个集合，是R空间中所有值的子集，包含了所有合法的表示值。checkRep()方法就是用来随时检查RI是否被满足的。\n此处附上自己在lab2中写过的AF、RI，以及Safety from rep exposure的描述：\n（三）注意事项\nRI、AF存在如下关系：\n相同的R可能存在不同的RI；\n即使是同样的R、 RI，也可以根据解释不同，而获得不同的AF；\n两个ADT有相同的rep和相同的AF，但其R也不—定相同。\n不应该给client看的内容有AF、RI、Rep exposure safety argument、testing strategy、Rep、Implementation和Test cases等等，留给client的只有Spec\n本文主要解释了一些ADT设计中关于Spec、AF和RI的含义、内容、注意事项等内容。其细节部分相对琐碎，但是在实际应用中非常重要，因此应该牢记，并在日后有需求的时候活学活用。\n"
  },
  {
    "head": "软件构造lab2回顾",
    "paragraphs": [
      "临近期末考试，开始对知识点进行整理，对课程布置的实验进行回顾。经过反复对比，感觉还是动手实验对知识获取的帮助最大，逐步解决问题的过程让自己对课上知识的理解更深入了一些。Lab2这一部分的的主要内容是ADT和OOP，实验目的也是抽象数据型的实现，以及面向对象编程。以下是对Lab2这一实验过程中遇到的一些事物做的简单回顾，课程中涉及到的其他重要知识点将在以后慢慢总结。",
      "一. 实验目标概述",
      "本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现 ADT。具体来说：",
      "针对给定的应用问题，从问题描述中识别所需的 ADT；",
      "设计 ADT 规约（pre-condition、post-condition）并评估规约的质量；",
      "根据 ADT 的规约设计测试用例；",
      "ADT",
      "的泛型化；",
      "根据规约设计 ADT 的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）",
      "使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；",
      "测试 ADT 的实现并评估测试的覆盖度；",
      "使用 ADT 及其实现，为应用问题开发程序；",
      "在测试代码中，能够写出 testing strategy 并据此设计测试用例。",
      "二. 涉及到的一些知识",
      "（一）代码覆盖度测试",
      "实验中主要采用Eclemma对测试用例的覆盖度进行测试，在eclipse上的使用方式如下：",
      "1.准备好要测试的代码和测试用例；",
      "2.右键项目->选择Coverage As->Java Application，便可以完成覆盖度测试。显示结果将给出各测试用例的覆盖度，如图所示：",
      "打开被测试的类，其中代码背景颜色被涂成红色的部分即为未覆盖的部分，注意对项目进行覆盖度测试时，只有当被测试的代码覆盖完整时，才会显示绿色，因此未被测试的类中的代码也会一并标记为红色。",
      "（二）对象的存储--对象容器",
      "用来盛装对象的工具，其特点不只在于能够对某一类对象进行存储，而且Java对每一种容器本身也提供了不少相应的方法，使得对象容器使用起来将要简单很多。",
      "1.对象列表",
      "示例如下：",
      "对象列表ArrayList是一个有顺序的列表，其下标索引从0开始。对象在该列表中的存储是有序的，因此与集合Set不同，我们可以通过下标对ArrayList中的元素进行访问。它的优点在于随机访问元素快，但是在中间插入和移除比较慢。",
      "实验中用到的除了基本的size等方法，以下几种方法让我印象较为深刻：",
      "add(int index, Object element)：在列表的指定位置插入指定元素。",
      "set(int i, Object element)：将索引i位置元素替换为元素element并返回被替换的元素。",
      "个人认为，对象列表和C语言中的数组类似，既可以直接操作、寻找对象，也可以通过下标进行操作，但其元素的个数不固定，长度可变，操作时更加灵活。",
      "2.集合容器",
      "示例如下：",
      "Set和数学中集合的概念类似，元素具有唯一性和无序性。所以Set最常用的就是测试归属性，很容易的询问出某个对象是否存在Set中。而若是要获得确定元素顺序的集合，可以用treeset来进行存储。",
      "Set具有和Collection完全一样的接口，继承相应的方法但没有额外的功能，只是表现的行为不同。",
      "3.哈希表",
      "示例如下：",
      "Map接口就像图表，关键字与关键字的值具有对应关系。类似于日常使用的字典，它根据键的hashCode值存储数据，也就是键-值对的方式存储，因此大多数情况下可以通过键名直接定位到它的值。Map具有很快的访问速度，但其遍历顺序却是不确定的。 注意HashMap最多只允许一条记录的键为null，允许多条记录的值为null。",
      "HashMap很特别的特点就是，我们可以根据关键字和关键字的值分别对表中的对象进行寻找、修改等操作。",
      "（三）遍历访问容器中的对象--迭代器",
      "Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。它是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。",
      "迭代器的使用使不可变数据型对象容器的遍历等操作变得更加方便，比如删除操作。",
      "迭代器的两个基本操作是 next 、hasNext 和 remove：方法it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态；方法hasNext() 会返回布尔值，用于检测集合中是否还有元素；而方法remove()的用途则是将迭代器返回的元素删除。",
      "以下是写实验时设计的一个使用迭代器实现的方法：",
      "实验2中还有很多较为核心的内容没有列出，文章只给出了一些Java语法及测试的使用方法，一些其他重要的内容将在以后总结。"
    ],
    "sentences": [
      "临近期末考试，开始对知识点进行整理，对课程布置的实验进行回顾",
      "经过反复对比",
      "感觉还是动手实验对知识获取的帮助最大",
      "逐步解决问题的过程让自己对课上知识的理解更深入了一些",
      "Lab2这一部分的的主要内容是ADT和OOP",
      "实验目的也是抽象数据型的实现",
      "以及面向对象编程",
      "以下是对Lab2这一实验过程中遇到的一些事物做的简单回顾",
      "课程中涉及到的其他重要知识点将在以后慢慢总结",
      "一. 实验目标概述",
      "本次实验训练抽象数据类型（ADT）的设计、规约、测试",
      "并使用面向对象编程（OOP）技术实现 ADT",
      "具体来说：针对给定的应用问题",
      "从问题描述中识别所需的 ADT；设计 ADT 规约（pre-condition、post-condition）并评估规约的质量；根据 ADT 的规约设计测试用例；ADT",
      "的泛型化；根据规约设计 ADT 的多种不同的实现；针对每种实现",
      "设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）",
      "使用 OOP 实现 ADT",
      "并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；测试 ADT 的实现并评估测试的覆盖度；使用 ADT 及其实现",
      "为应用问题开发程序；在测试代码中",
      "能够写出 testing strategy 并据此设计测试用例",
      "二. 涉及到的一些知识",
      "（一）代码覆盖度测试",
      "实验中主要采用Eclemma对测试用例的覆盖度进行测试",
      "在eclipse上的使用方式如下：1.准备好要测试的代码和测试用例；2.右键项目->选择Coverage As->Java Application",
      "便可以完成覆盖度测试",
      "显示结果将给出各测试用例的覆盖度",
      "如图所示：打开被测试的类",
      "其中代码背景颜色被涂成红色的部分即为未覆盖的部分",
      "注意对项目进行覆盖度测试时",
      "只有当被测试的代码覆盖完整时",
      "才会显示绿色",
      "因此未被测试的类中的代码也会一并标记为红色",
      "（二）对象的存储--对象容器",
      "用来盛装对象的工具",
      "其特点不只在于能够对某一类对象进行存储",
      "而且Java对每一种容器本身也提供了不少相应的方法",
      "使得对象容器使用起来将要简单很多",
      "1.对象列表",
      "示例如下：对象列表ArrayList是一个有顺序的列表",
      "其下标索引从0开始",
      "对象在该列表中的存储是有序的",
      "因此与集合Set不同",
      "我们可以通过下标对ArrayList中的元素进行访问",
      "它的优点在于随机访问元素快，但是在中间插入和移除比较慢",
      "实验中用到的除了基本的size等方法",
      "以下几种方法让我印象较为深刻：add(int index, Object element)：在列表的指定位置插入指定元素",
      "set(int i, Object element)：将索引i位置元素替换为元素element并返回被替换的元素",
      "个人认为",
      "对象列表和C语言中的数组类似",
      "既可以直接操作、寻找对象",
      "也可以通过下标进行操作",
      "但其元素的个数不固定",
      "长度可变",
      "操作时更加灵活",
      "2.集合容器",
      "示例如下：Set和数学中集合的概念类似",
      "元素具有唯一性和无序性",
      "所以Set最常用的就是测试归属性",
      "很容易的询问出某个对象是否存在Set中",
      "而若是要获得确定元素顺序的集合",
      "可以用treeset来进行存储",
      "Set具有和Collection完全一样的接口",
      "继承相应的方法但没有额外的功能",
      "只是表现的行为不同",
      "3.哈希表",
      "示例如下：Map接口就像图表，关键字与关键字的值具有对应关系",
      "类似于日常使用的字典",
      "它根据键的hashCode值存储数据",
      "也就是键-值对的方式存储",
      "因此大多数情况下可以通过键名直接定位到它的值",
      "Map具有很快的访问速度，但其遍历顺序却是不确定的",
      " 注意HashMap最多只允许一条记录的键为null",
      "允许多条记录的值为null",
      "HashMap很特别的特点就是",
      "我们可以根据关键字和关键字的值分别对表中的对象进行寻找、修改等操作",
      "（三）遍历访问容器中的对象--迭代器",
      "Java Iterator（迭代器）不是一个集合",
      "它是一种用于访问集合的方法",
      "可用于迭代 ArrayList 和 HashSet 等集合",
      "它是 Java 迭代器最简单的实现",
      "ListIterator 是 Collection API 中的接口",
      " 它扩展了 Iterator 接口",
      "迭代器的使用使不可变数据型对象容器的遍历等操作变得更加方便",
      "比如删除操作",
      "迭代器的两个基本操作是 next 、hasNext 和 remove：方法it.next() 会返回迭代器的下一个元素",
      "并且更新迭代器的状态；方法hasNext() 会返回布尔值",
      "用于检测集合中是否还有元素；而方法remove()的用途则是将迭代器返回的元素删除",
      "以下是写实验时设计的一个使用迭代器实现的方法：实验2中还有很多较为核心的内容没有列出",
      "文章只给出了一些Java语法及测试的使用方法",
      "一些其他重要的内容将在以后总结"
    ],
    "codes": [
      "ArrayList<String> l = new ArrayList<String>()",
      "Set<String> set = new HashSet<String>();",
      "Map<String, Integer> m = new HashMap<String, Integer>();",
      "@Override public boolean remove(L vertex) {\n    \tIterator<Vertex<L>> V = vertices.iterator();\n    \twhile(V.hasNext()) {\n    \t\tVertex<L> v = V.next();\n    \t\tif(v.Getname().equals(vertex)) {//remove the vertex itself\n    \t\t\tV.remove();\n    \t\t\tcheckRep();\n    \t\t\treturn true;\n    \t\t}\n    \t\telse {\n    \t\t\tif (v.Getsources().containsKey(vertex)) {//remove the vertex from related maps(as source)\n\t\t\t\t\tv.removesource(vertex);\n\t\t\t\t}\n\t\t\t\tif (v.Gettargets().containsKey(vertex)) {//remove the vertex from related maps(as target)\n\t\t\t\t\tv.removetarget(vertex);\n\t\t\t\t}\n    \t\t}\n    \t}\n    \tcheckRep();\n    \treturn false;\n    }"
    ],
    "date": "2021-07-06",
    "text": "临近期末考试，开始对知识点进行整理，对课程布置的实验进行回顾。经过反复对比，感觉还是动手实验对知识获取的帮助最大，逐步解决问题的过程让自己对课上知识的理解更深入了一些。Lab2这一部分的的主要内容是ADT和OOP，实验目的也是抽象数据型的实现，以及面向对象编程。以下是对Lab2这一实验过程中遇到的一些事物做的简单回顾，课程中涉及到的其他重要知识点将在以后慢慢总结。\n一. 实验目标概述\n本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现 ADT。具体来说：\n针对给定的应用问题，从问题描述中识别所需的 ADT；\n设计 ADT 规约（pre-condition、post-condition）并评估规约的质量；\n根据 ADT 的规约设计测试用例；\nADT\n的泛型化；\n根据规约设计 ADT 的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）\n使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；\n测试 ADT 的实现并评估测试的覆盖度；\n使用 ADT 及其实现，为应用问题开发程序；\n在测试代码中，能够写出 testing strategy 并据此设计测试用例。\n二. 涉及到的一些知识\n（一）代码覆盖度测试\n实验中主要采用Eclemma对测试用例的覆盖度进行测试，在eclipse上的使用方式如下：\n1.准备好要测试的代码和测试用例；\n2.右键项目->选择Coverage As->Java Application，便可以完成覆盖度测试。显示结果将给出各测试用例的覆盖度，如图所示：\n打开被测试的类，其中代码背景颜色被涂成红色的部分即为未覆盖的部分，注意对项目进行覆盖度测试时，只有当被测试的代码覆盖完整时，才会显示绿色，因此未被测试的类中的代码也会一并标记为红色。\n（二）对象的存储--对象容器\n用来盛装对象的工具，其特点不只在于能够对某一类对象进行存储，而且Java对每一种容器本身也提供了不少相应的方法，使得对象容器使用起来将要简单很多。\n1.对象列表\n示例如下：\n对象列表ArrayList是一个有顺序的列表，其下标索引从0开始。对象在该列表中的存储是有序的，因此与集合Set不同，我们可以通过下标对ArrayList中的元素进行访问。它的优点在于随机访问元素快，但是在中间插入和移除比较慢。\n实验中用到的除了基本的size等方法，以下几种方法让我印象较为深刻：\nadd(int index, Object element)：在列表的指定位置插入指定元素。\nset(int i, Object element)：将索引i位置元素替换为元素element并返回被替换的元素。\n个人认为，对象列表和C语言中的数组类似，既可以直接操作、寻找对象，也可以通过下标进行操作，但其元素的个数不固定，长度可变，操作时更加灵活。\n2.集合容器\n示例如下：\nSet和数学中集合的概念类似，元素具有唯一性和无序性。所以Set最常用的就是测试归属性，很容易的询问出某个对象是否存在Set中。而若是要获得确定元素顺序的集合，可以用treeset来进行存储。\nSet具有和Collection完全一样的接口，继承相应的方法但没有额外的功能，只是表现的行为不同。\n3.哈希表\n示例如下：\nMap接口就像图表，关键字与关键字的值具有对应关系。类似于日常使用的字典，它根据键的hashCode值存储数据，也就是键-值对的方式存储，因此大多数情况下可以通过键名直接定位到它的值。Map具有很快的访问速度，但其遍历顺序却是不确定的。 注意HashMap最多只允许一条记录的键为null，允许多条记录的值为null。\nHashMap很特别的特点就是，我们可以根据关键字和关键字的值分别对表中的对象进行寻找、修改等操作。\n（三）遍历访问容器中的对象--迭代器\nJava Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。它是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。\n迭代器的使用使不可变数据型对象容器的遍历等操作变得更加方便，比如删除操作。\n迭代器的两个基本操作是 next 、hasNext 和 remove：方法it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态；方法hasNext() 会返回布尔值，用于检测集合中是否还有元素；而方法remove()的用途则是将迭代器返回的元素删除。\n以下是写实验时设计的一个使用迭代器实现的方法：\n实验2中还有很多较为核心的内容没有列出，文章只给出了一些Java语法及测试的使用方法，一些其他重要的内容将在以后总结。\n"
  },
  {
    "head": "软件构造笔记（三）：关于等价性的个人理解",
    "paragraphs": [
      "前两篇博客中介绍了自己软件构造的第二次、第三次实验内容及心得体会，本文将介绍一些软件构造学习过程中遇到的一部分知识点难点，剩余的内容将在随后补充。",
      "一. 引用等价性和对象等价性",
      "（一）引用等价性==：",
      "该比较符号比较的内容是索引，它测试的是指向相等，如果两个索引指向同一块存储区域，那它们就是相等的。对于基本数据类型，我们只能使用这种方式进行比较，若相同，结果为true；否则为false。",
      "（二）对象等价性：equals()：",
      "这是一种方法，比较的是对象的内容，用来测试对象的值是否相等，复合数据类型和对象都通过这种方式进行比较。",
      "总结：当对两个同类型对象进行比较时，这两种比较方式的结果不一定相同，当我们比较引用等价性时，除非是同一个new出来的对象，否则结果为false。而当我们比较对象等价性时，则会根据对象内容及重写情况比较，若无重写则结果会等同于双等号比较。",
      "二. hashCode()方法",
      "（一）对于不可变类型：",
      "equals()应该比较抽象值是否相等。这和equals()比较行为等价性是一样的。",
      "hashcode()应该将抽象值映射为整数。",
      "不可变类型需同时重写equals()和hashcode()。",
      "（二）对于可变类型：",
      "equals()应该比较索引，就像==一样。同样的，这也是比较行为相等性。",
      "hashcode()应该将索引映射为整数。",
      "所以可变类型不用重写这两个方法，直接继承Object中的即可。",
      "三. 观察等价性与行为等价性：",
      "（一）观察等价性：",
      "两个索引在不改变各自对象状态的前提下不能被区分。即通过只调用observer，producer和creator中的方法，它测试的是这两个索引在当前程序状态下“看起来”相等。",
      "（二）行为等价性：",
      "两个索引在任何代码的情况下都不能被区分，即使有一个对象调用了改造者，它测试的是两个对象是否会在未来的所有状态下“行为”相等。",
      "从前在实验里会常常用到equals()，但是没有注重过equals()的具体应用场景和重写。而在不够理解等价性的定义时候，我使用的方法多为，直接加条件判断，把需要判断相等即等于对象相等的变量直接放入条件判断语句，这正是比较观察等价性的一种体现，而以后对于可变数据型，定义新的方法就等同于使用条件语句判断，对于不可变数据类型，重写也就是注重对象中的“一部分”是等价的，就可满足条件。",
      "此外，观察等价性与行为等价性的区分是可变数据类型特有的对象等价性区分特征，这里也需要注意一下。"
    ],
    "sentences": [
      "前两篇博客中介绍了自己软件构造的第二次、第三次实验内容及心得体会",
      "本文将介绍一些软件构造学习过程中遇到的一部分知识点难点",
      "剩余的内容将在随后补充",
      "一. 引用等价性和对象等价性",
      "（一）引用等价性==：该比较符号比较的内容是索引",
      "它测试的是指向相等",
      "如果两个索引指向同一块存储区域",
      "那它们就是相等的",
      "对于基本数据类型",
      "我们只能使用这种方式进行比较",
      "若相同",
      "结果为true；否则为false",
      "（二）对象等价性：equals()：这是一种方法",
      "比较的是对象的内容",
      "用来测试对象的值是否相等",
      "复合数据类型和对象都通过这种方式进行比较",
      "总结：当对两个同类型对象进行比较时",
      "这两种比较方式的结果不一定相同",
      "当我们比较引用等价性时",
      "除非是同一个new出来的对象",
      "否则结果为false",
      "而当我们比较对象等价性时",
      "则会根据对象内容及重写情况比较",
      "若无重写则结果会等同于双等号比较",
      "二. hashCode()方法",
      "（一）对于不可变类型：equals()应该比较抽象值是否相等",
      "这和equals()比较行为等价性是一样的",
      "hashcode()应该将抽象值映射为整数",
      "不可变类型需同时重写equals()和hashcode()",
      "（二）对于可变类型：equals()应该比较索引",
      "就像==一样",
      "同样的，这也是比较行为相等性",
      "hashcode()应该将索引映射为整数",
      "所以可变类型不用重写这两个方法，直接继承Object中的即可",
      "三. 观察等价性与行为等价性：（一）观察等价性：两个索引在不改变各自对象状态的前提下不能被区分",
      "即通过只调用observer",
      "producer和creator中的方法",
      "它测试的是这两个索引在当前程序状态下“看起来”相等",
      "（二）行为等价性：两个索引在任何代码的情况下都不能被区分",
      "即使有一个对象调用了改造者",
      "它测试的是两个对象是否会在未来的所有状态下“行为”相等",
      "从前在实验里会常常用到equals()",
      "但是没有注重过equals()的具体应用场景和重写",
      "而在不够理解等价性的定义时候",
      "我使用的方法多为",
      "直接加条件判断",
      "把需要判断相等即等于对象相等的变量直接放入条件判断语句",
      "这正是比较观察等价性的一种体现",
      "而以后对于可变数据型",
      "定义新的方法就等同于使用条件语句判断",
      "对于不可变数据类型",
      "重写也就是注重对象中的“一部分”是等价的",
      "就可满足条件",
      "此外",
      "观察等价性与行为等价性的区分是可变数据类型特有的对象等价性区分特征",
      "这里也需要注意一下"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "前两篇博客中介绍了自己软件构造的第二次、第三次实验内容及心得体会，本文将介绍一些软件构造学习过程中遇到的一部分知识点难点，剩余的内容将在随后补充。\n一. 引用等价性和对象等价性\n（一）引用等价性==：\n该比较符号比较的内容是索引，它测试的是指向相等，如果两个索引指向同一块存储区域，那它们就是相等的。对于基本数据类型，我们只能使用这种方式进行比较，若相同，结果为true；否则为false。\n（二）对象等价性：equals()：\n这是一种方法，比较的是对象的内容，用来测试对象的值是否相等，复合数据类型和对象都通过这种方式进行比较。\n总结：当对两个同类型对象进行比较时，这两种比较方式的结果不一定相同，当我们比较引用等价性时，除非是同一个new出来的对象，否则结果为false。而当我们比较对象等价性时，则会根据对象内容及重写情况比较，若无重写则结果会等同于双等号比较。\n二. hashCode()方法\n（一）对于不可变类型：\nequals()应该比较抽象值是否相等。这和equals()比较行为等价性是一样的。\nhashcode()应该将抽象值映射为整数。\n不可变类型需同时重写equals()和hashcode()。\n（二）对于可变类型：\nequals()应该比较索引，就像==一样。同样的，这也是比较行为相等性。\nhashcode()应该将索引映射为整数。\n所以可变类型不用重写这两个方法，直接继承Object中的即可。\n三. 观察等价性与行为等价性：\n（一）观察等价性：\n两个索引在不改变各自对象状态的前提下不能被区分。即通过只调用observer，producer和creator中的方法，它测试的是这两个索引在当前程序状态下“看起来”相等。\n（二）行为等价性：\n两个索引在任何代码的情况下都不能被区分，即使有一个对象调用了改造者，它测试的是两个对象是否会在未来的所有状态下“行为”相等。\n从前在实验里会常常用到equals()，但是没有注重过equals()的具体应用场景和重写。而在不够理解等价性的定义时候，我使用的方法多为，直接加条件判断，把需要判断相等即等于对象相等的变量直接放入条件判断语句，这正是比较观察等价性的一种体现，而以后对于可变数据型，定义新的方法就等同于使用条件语句判断，对于不可变数据类型，重写也就是注重对象中的“一部分”是等价的，就可满足条件。\n此外，观察等价性与行为等价性的区分是可变数据类型特有的对象等价性区分特征，这里也需要注意一下。\n"
  },
  {
    "head": "软件构造lab3心得",
    "paragraphs": [
      "经过前后两周时间的调试和反复修改，终于完成了lab3实验指导手册中的内容(当然不一定很完善)。简单写一下心得，梳理一下自己实验中的收获，以及实验过程给我带来的新体会。外加临近期末考试，需要对知识点进行整理，对课程布置的实验进行回顾，因此决定写一篇博客，记录一下lab3给我带来的收获。",
      "一. 实验目标概述",
      "该实验的目标是编写具有可复用性和可维护性的软件，主要使用以下软件构造技术：",
      "子类型、泛型、多态、重写、重载；",
      "继承、代理、组合；",
      "语法驱动的编程、正则表达式；",
      "API",
      "设计、API 复用；",
      "本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过 ADT 和泛型等抽象技术，开发一套可复用的 ADT 及其实现，充分考虑这些应用之间的相似性和差异性，使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。",
      "二. 实验中遇到的一些知识",
      "（一）委派(delegation)",
      "该实验设计过程中主要涉及到了委派的思想，用于提高代码的可复用性。",
      "委托的含义：当我们设计ADT时，若遇到一个对象需要另一个对象的功能时，便可以让新对象捕获该对象，并可以在另一对象中对其进行功能调用，这个过程便是委托。",
      "在使用委派时，过程涉及到的类A和类B是两个没有任何关系的类，而B具有和A一模一样的方法和属性；当我们调用B中的方法时，调用B中的属性就等价于调用A中同名的方法和属性。此时B如同得到A授权委派的中介。调用B类的代码不需要知道A的存在，也不会和A发生直接的联系，而通过B就可以直接使用A的功能，这样的模式，既能够使代码使用到A的各种属性及功能，又能够很好地将A保护起来。",
      "委派与继承的操作过程相似，都是对某一个类进行复用，但两者实际上存在较大差异：继承是在一个现有类的基础上去构建一个新的类，而这个构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承（非父类私有）的属性和方法。如果想声明一个类继承另一个类，需要使用extends关键字。而委派的双方往往是关联不大的两个类，一般当想要调用一个类中的少部分属性或方法时，便可以采用委派的方法。而当多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要对那个类进行继承即可。",
      "比如说，水果的榨汁过程需要工厂的操作，是因为水果自己不具有榨汁的功能，因此我们可以把水果交给工厂类中的方法进行处理，这便是委托的过程。",
      "而水果成熟后，会从生长的植株上下落，这种下落的行为在水果中很常见，苹果、梨也有下落的行为，因此便可以在水果类中写下这种行为，然后在苹果类中通过extends获得这个方法的复用，这便是继承的过程。",
      "（二）Decorator装饰器模式",
      "Lab3中，自己对三个应用类的设计其实是采用了第五种方案，不过在实验设计完成以后又通过查阅资料对另外五种设计方案进行了简单的了解，感觉第六种方案更加简便，因此在这里介绍一下Decorator设计模式。",
      "为了让每一个子类实现不同的特性，采用Decorator设计模式，为对象增加不同侧面的不同特性。该设计模式的原理如下：",
      "首先从接口派生出子类，并在子类中定义一个父类接口，将其作为delegation的对象。这个过程类似于子类型自己到自己(该接口的其他子类)的委派。这两个类都是同一个接口的子类。",
      "使用装饰类，通过一层一层反复装饰，最终得到的对象可以拥有任意不同特性的组合，我觉得这就是Decorator模式最精妙的地方，只要ADT设计得当，复用后使用起来将会非常简便。而装饰的顺序并不会影响到对象的最终结果拥有哪些特性，唯一的影响在于最终得到的是哪个类型的对象，即最后一次装饰的特性决定了最终得到哪个具体类型的对象。",
      "三. 自己在实现过程中遇到的困难及解决过程",
      "实验刚开始进行的时候，我曾经犯过一个很低级的错误，就是将interface写在了class类中，后来通过对lab1、lab2中涉及到复用的代码进行查看才发现自己的错误所在。个人认为，interface和class在层次上可以是并列关系，接口类似于类，但其成员都没有执行方式，它只是方法、属性等内容的组合。",
      "实验3中还有很多较为核心的内容没有列出，文章只给出了一些Java语法及ADT复用的原理及使用方法，一些其他重要的内容将在以后总结。"
    ],
    "sentences": [
      "经过前后两周时间的调试和反复修改",
      "终于完成了lab3实验指导手册中的内容(当然不一定很完善)",
      "简单写一下心得",
      "梳理一下自己实验中的收获",
      "以及实验过程给我带来的新体会",
      "外加临近期末考试",
      "需要对知识点进行整理",
      "对课程布置的实验进行回顾",
      "因此决定写一篇博客",
      "记录一下lab3给我带来的收获",
      "一. 实验目标概述",
      "该实验的目标是编写具有可复用性和可维护性的软件",
      "主要使用以下软件构造技术：子类型、泛型、多态、重写、重载；继承、代理、组合；语法驱动的编程、正则表达式；API",
      "设计、API 复用；本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理）",
      "学生不是直接针对每个应用分别编程实现",
      "而是通过 ADT 和泛型等抽象技术",
      "开发一套可复用的 ADT 及其实现",
      "充分考虑这些应用之间的相似性和差异性",
      "使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）",
      "二. 实验中遇到的一些知识",
      "（一）委派(delegation)",
      "该实验设计过程中主要涉及到了委派的思想",
      "用于提高代码的可复用性",
      "委托的含义：当我们设计ADT时",
      "若遇到一个对象需要另一个对象的功能时",
      "便可以让新对象捕获该对象",
      "并可以在另一对象中对其进行功能调用",
      "这个过程便是委托",
      "在使用委派时",
      "过程涉及到的类A和类B是两个没有任何关系的类",
      "而B具有和A一模一样的方法和属性；当我们调用B中的方法时",
      "调用B中的属性就等价于调用A中同名的方法和属性",
      "此时B如同得到A授权委派的中介",
      "调用B类的代码不需要知道A的存在",
      "也不会和A发生直接的联系",
      "而通过B就可以直接使用A的功能",
      "这样的模式",
      "既能够使代码使用到A的各种属性及功能",
      "又能够很好地将A保护起来",
      "委派与继承的操作过程相似",
      "都是对某一个类进行复用",
      "但两者实际上存在较大差异：继承是在一个现有类的基础上去构建一个新的类",
      "而这个构建出来的新类被称作子类",
      "现有类被称作父类",
      "子类会自动拥有父类所有可继承（非父类私有）的属性和方法",
      "如果想声明一个类继承另一个类，需要使用extends关键字",
      "而委派的双方往往是关联不大的两个类",
      "一般当想要调用一个类中的少部分属性或方法时",
      "便可以采用委派的方法",
      "而当多个类中存在相同属性和行为时",
      "将这些内容抽取到单独一个类中",
      "那么多个类无需再定义这些属性和行为",
      "只要对那个类进行继承即可",
      "比如说",
      "水果的榨汁过程需要工厂的操作",
      "是因为水果自己不具有榨汁的功能",
      "因此我们可以把水果交给工厂类中的方法进行处理",
      "这便是委托的过程",
      "而水果成熟后",
      "会从生长的植株上下落",
      "这种下落的行为在水果中很常见",
      "苹果、梨也有下落的行为",
      "因此便可以在水果类中写下这种行为",
      "然后在苹果类中通过extends获得这个方法的复用",
      "这便是继承的过程",
      "（二）Decorator装饰器模式",
      "Lab3中",
      "自己对三个应用类的设计其实是采用了第五种方案",
      "不过在实验设计完成以后又通过查阅资料对另外五种设计方案进行了简单的了解",
      "感觉第六种方案更加简便",
      "因此在这里介绍一下Decorator设计模式",
      "为了让每一个子类实现不同的特性",
      "采用Decorator设计模式",
      "为对象增加不同侧面的不同特性",
      "该设计模式的原理如下：首先从接口派生出子类",
      "并在子类中定义一个父类接口",
      "将其作为delegation的对象",
      "这个过程类似于子类型自己到自己(该接口的其他子类)的委派",
      "这两个类都是同一个接口的子类",
      "使用装饰类",
      "通过一层一层反复装饰",
      "最终得到的对象可以拥有任意不同特性的组合",
      "我觉得这就是Decorator模式最精妙的地方",
      "只要ADT设计得当",
      "复用后使用起来将会非常简便",
      "而装饰的顺序并不会影响到对象的最终结果拥有哪些特性",
      "唯一的影响在于最终得到的是哪个类型的对象",
      "即最后一次装饰的特性决定了最终得到哪个具体类型的对象",
      "三. 自己在实现过程中遇到的困难及解决过程",
      "实验刚开始进行的时候",
      "我曾经犯过一个很低级的错误",
      "就是将interface写在了class类中",
      "后来通过对lab1、lab2中涉及到复用的代码进行查看才发现自己的错误所在",
      "个人认为",
      "interface和class在层次上可以是并列关系",
      "接口类似于类",
      "但其成员都没有执行方式",
      "它只是方法、属性等内容的组合",
      "实验3中还有很多较为核心的内容没有列出",
      "文章只给出了一些Java语法及ADT复用的原理及使用方法",
      "一些其他重要的内容将在以后总结"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "经过前后两周时间的调试和反复修改，终于完成了lab3实验指导手册中的内容(当然不一定很完善)。简单写一下心得，梳理一下自己实验中的收获，以及实验过程给我带来的新体会。外加临近期末考试，需要对知识点进行整理，对课程布置的实验进行回顾，因此决定写一篇博客，记录一下lab3给我带来的收获。\n一. 实验目标概述\n该实验的目标是编写具有可复用性和可维护性的软件，主要使用以下软件构造技术：\n子类型、泛型、多态、重写、重载；\n继承、代理、组合；\n语法驱动的编程、正则表达式；\nAPI\n设计、API 复用；\n本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过 ADT 和泛型等抽象技术，开发一套可复用的 ADT 及其实现，充分考虑这些应用之间的相似性和差异性，使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。\n二. 实验中遇到的一些知识\n（一）委派(delegation)\n该实验设计过程中主要涉及到了委派的思想，用于提高代码的可复用性。\n委托的含义：当我们设计ADT时，若遇到一个对象需要另一个对象的功能时，便可以让新对象捕获该对象，并可以在另一对象中对其进行功能调用，这个过程便是委托。\n在使用委派时，过程涉及到的类A和类B是两个没有任何关系的类，而B具有和A一模一样的方法和属性；当我们调用B中的方法时，调用B中的属性就等价于调用A中同名的方法和属性。此时B如同得到A授权委派的中介。调用B类的代码不需要知道A的存在，也不会和A发生直接的联系，而通过B就可以直接使用A的功能，这样的模式，既能够使代码使用到A的各种属性及功能，又能够很好地将A保护起来。\n委派与继承的操作过程相似，都是对某一个类进行复用，但两者实际上存在较大差异：继承是在一个现有类的基础上去构建一个新的类，而这个构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承（非父类私有）的属性和方法。如果想声明一个类继承另一个类，需要使用extends关键字。而委派的双方往往是关联不大的两个类，一般当想要调用一个类中的少部分属性或方法时，便可以采用委派的方法。而当多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要对那个类进行继承即可。\n比如说，水果的榨汁过程需要工厂的操作，是因为水果自己不具有榨汁的功能，因此我们可以把水果交给工厂类中的方法进行处理，这便是委托的过程。\n而水果成熟后，会从生长的植株上下落，这种下落的行为在水果中很常见，苹果、梨也有下落的行为，因此便可以在水果类中写下这种行为，然后在苹果类中通过extends获得这个方法的复用，这便是继承的过程。\n（二）Decorator装饰器模式\nLab3中，自己对三个应用类的设计其实是采用了第五种方案，不过在实验设计完成以后又通过查阅资料对另外五种设计方案进行了简单的了解，感觉第六种方案更加简便，因此在这里介绍一下Decorator设计模式。\n为了让每一个子类实现不同的特性，采用Decorator设计模式，为对象增加不同侧面的不同特性。该设计模式的原理如下：\n首先从接口派生出子类，并在子类中定义一个父类接口，将其作为delegation的对象。这个过程类似于子类型自己到自己(该接口的其他子类)的委派。这两个类都是同一个接口的子类。\n使用装饰类，通过一层一层反复装饰，最终得到的对象可以拥有任意不同特性的组合，我觉得这就是Decorator模式最精妙的地方，只要ADT设计得当，复用后使用起来将会非常简便。而装饰的顺序并不会影响到对象的最终结果拥有哪些特性，唯一的影响在于最终得到的是哪个类型的对象，即最后一次装饰的特性决定了最终得到哪个具体类型的对象。\n三. 自己在实现过程中遇到的困难及解决过程\n实验刚开始进行的时候，我曾经犯过一个很低级的错误，就是将interface写在了class类中，后来通过对lab1、lab2中涉及到复用的代码进行查看才发现自己的错误所在。个人认为，interface和class在层次上可以是并列关系，接口类似于类，但其成员都没有执行方式，它只是方法、属性等内容的组合。\n实验3中还有很多较为核心的内容没有列出，文章只给出了一些Java语法及ADT复用的原理及使用方法，一些其他重要的内容将在以后总结。\n"
  },
  {
    "head": "HIT软件构造笔记二",
    "paragraphs": [
      "HIT软件构造笔记二",
      "1.1.1Software Lifecycle and Configuration Management",
      "1、Software Development Lifecycle软件开发生命周期(SDLC)：从无到有，从有到好",
      "静态测试：肉眼检查。",
      "动态测试：用测试用例进行实际测试。",
      "2、传统软件过程模型：基本类型有线性过程(Linear)和迭代过程(Iterative)",
      "目前存在的模型有瀑布过程(waterfall)，增量过程(incremental)，V字模型(V-model)，原型过程(prototyping)，螺旋模型(spiral)。",
      "3、敏捷开发：Agile = 增量 + 迭代",
      "通过快速迭代和小规模的持续改进，以快速适应变化，每次迭代处理一个小规模增量",
      "4、极限编程：XP",
      "1.1.2 软件配置管理(SCM)和版本控制系统(VCS)",
      "软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被称为软件配置项(SCI)。",
      "当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。",
      "为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。",
      "VCS分为三种：",
      "1、本地版本控制系统（无法协作）存储在本地",
      "2、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）",
      "3、存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。",
      "1.1.3 Git",
      "创建：git init",
      "暂存：git add",
      "提交：git commit -m “commit message”",
      "链接：git remote add origin",
      "推送：git push -u origin master",
      "创建分支：git checkout -b",
      "切换分支：git checkout",
      "合并分支：git merge",
      "删除分支：git branch -d",
      "git中的四个区域：workspace、staging area、Local repository、Remote repository",
      "git的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。",
      "git单个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。",
      "传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。",
      "关于分支的合并：对于合并操作来说，如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的指针移到做过更改分支的指针的位置。",
      "而如果两个分支都做了更改，那么就找到更改的共同的祖先节点，以祖先节点为开始，将两个分支所有做出的更改都放在一起，在工作分支上形成一个新的节点",
      "删除分支时，只是删除了分支指针，并没有删除在该分支上的commit。",
      "2.1 General process of software construction",
      "通常软件构造过程",
      "(1) Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。",
      "(2) Code review、Static code analysis：可以使用工具来发现bug，如CheckStyle, SpotBugs。",
      "(3) Testing：测试，单元测试、集成测试、系统测试…",
      "(4) Debugging：调试",
      "(5) Dynamic code analysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分",
      "(6) Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化",
      "(7)Build：chapter 2",
      "2. 狭义的软件构造过程(Build)",
      "这是一个借助于工具，将软件构造过程中大的各阶段的活动自动化的过程，尽可能地脱离人工，以提高构造效率。",
      "常用的工具：Jenkins、Make、Ant、Maven、Gradle、Eclipse IDE",
      "利用工具完成项目的自动化构建、测试、打包release等功能，完成build time–>run time。"
    ],
    "sentences": [
      "HIT软件构造笔记二",
      "1.1.1Software Lifecycle and Configuration Management",
      "1、Software Development Lifecycle软件开发生命周期(SDLC)：从无到有",
      "从有到好",
      "静态测试：肉眼检查",
      "动态测试：用测试用例进行实际测试",
      "2、传统软件过程模型：基本类型有线性过程(Linear)和迭代过程(Iterative)",
      "目前存在的模型有瀑布过程(waterfall)",
      "增量过程(incremental)",
      "V字模型(V-model)",
      "原型过程(prototyping)",
      "螺旋模型(spiral)",
      "3、敏捷开发：Agile = 增量 + 迭代",
      "通过快速迭代和小规模的持续改进",
      "以快速适应变化",
      "每次迭代处理一个小规模增量",
      "4、极限编程：XP",
      "1.1.2 软件配置管理(SCM)和版本控制系统(VCS)",
      "软件配置管理是为了追踪和控制软件的变化",
      "而软件中发生变化的基本单元",
      "如文件",
      "就被称为软件配置项(SCI)",
      "当软件在开发过程中达到了一个稳定的状态",
      "如可以对外发布的状态",
      "此时的文件组成了基线(Baseline)",
      "为了存储各配置项随时间变化的信息和基线信息",
      "就有一个数据库来管理这些内容",
      "即配置管理数据库(CMDB)",
      "VCS分为三种：1、本地版本控制系统（无法协作）存储在本地",
      "2、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）",
      "3、存储在服务器上、分布式版本控制系统（解决了前两者的问题",
      "代价是存储空间）同时存储在本地和服务器",
      "1.1.3 Git",
      "创建：git init",
      "暂存：git add",
      "提交：git commit -m “commit message”",
      "链接：git remote add origin",
      "推送：git push -u origin master",
      "创建分支：git checkout -b",
      "切换分支：git checkout",
      "合并分支：git merge",
      "删除分支：git branch -d",
      "git中的四个区域：workspace、staging area、Local repository、Remote repository",
      "git的存储结构是一张有向无环图",
      "每次commit在图上会增加一个新的节点",
      "并将HEAD指向这个节点",
      "通常一个子节点有一个父节点",
      "当一个父节点有多个子节点时表明创建了分支",
      "一个子节点有多个父节点时表明进行分支合并",
      "git单个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter",
      "而在每个tree中",
      "包含所有文件的信息",
      "对于每个文件指针",
      "如果文件变化了",
      "则指向变化后的新文件",
      "如果没有变化",
      "则指向上次提交的文件",
      "不做重复存储",
      "传统VCS存储的是文件每个版本之间的变化",
      "这种办法的优点是存储空间较小",
      "但由于存储的只是变化",
      "取出指定时期的文件要先取出原文件",
      "再取出变化内容",
      "最后做合并形成新文件",
      "所以取出文件的时间复杂度较高",
      "git存储的则是文件",
      "所以取出特定版本的文件比较方便",
      "但是代价的是空间复杂度较高",
      "关于分支的合并：对于合并操作来说",
      "如果是把一个做了更改的分支合并到一个未作更改的分支",
      "那么就将未作更改的分支的指针移到做过更改分支的指针的位置",
      "而如果两个分支都做了更改",
      "那么就找到更改的共同的祖先节点",
      "以祖先节点为开始",
      "将两个分支所有做出的更改都放在一起",
      "在工作分支上形成一个新的节点",
      "删除分支时",
      "只是删除了分支指针",
      "并没有删除在该分支上的commit",
      "2.1 General process of software construction",
      "通常软件构造过程",
      "(1) Programming：有编程语言",
      "也有建模语言",
      "如UML",
      "还有配置语言",
      "如XML、JSON",
      "(2) Code review、Static code analysis：可以使用工具来发现bug",
      "如CheckStyle, SpotBugs",
      "(3) Testing：测试，单元测试、集成测试、系统测试…",
      "(4) Debugging：调试",
      "(5) Dynamic code analysis/profiling：在程序运行的过程中查看并发现问题",
      "本课程不涉及这部分",
      "(6) Refactoring：重构不改变功能",
      "只是处于更容易维护的目的对代码优化",
      "(7)Build：chapter 2",
      "2. 狭义的软件构造过程(Build)",
      "这是一个借助于工具",
      "将软件构造过程中大的各阶段的活动自动化的过程",
      "尽可能地脱离人工",
      "以提高构造效率",
      "常用的工具：Jenkins、Make、Ant、Maven、Gradle、Eclipse IDE",
      "利用工具完成项目的自动化构建、测试、打包release等功能",
      "完成build time–>run time"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "HIT软件构造笔记二\n1.1.1Software Lifecycle and Configuration Management\n1、Software Development Lifecycle软件开发生命周期(SDLC)：从无到有，从有到好\n静态测试：肉眼检查。\n动态测试：用测试用例进行实际测试。\n2、传统软件过程模型：基本类型有线性过程(Linear)和迭代过程(Iterative)\n目前存在的模型有瀑布过程(waterfall)，增量过程(incremental)，V字模型(V-model)，原型过程(prototyping)，螺旋模型(spiral)。\n3、敏捷开发：Agile = 增量 + 迭代\n通过快速迭代和小规模的持续改进，以快速适应变化，每次迭代处理一个小规模增量\n4、极限编程：XP\n1.1.2 软件配置管理(SCM)和版本控制系统(VCS)\n软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被称为软件配置项(SCI)。\n当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。\n为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。\nVCS分为三种：\n1、本地版本控制系统（无法协作）存储在本地\n2、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）\n3、存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。\n1.1.3 Git\n创建：git init\n暂存：git add\n提交：git commit -m “commit message”\n链接：git remote add origin\n推送：git push -u origin master\n创建分支：git checkout -b\n切换分支：git checkout\n合并分支：git merge\n删除分支：git branch -d\ngit中的四个区域：workspace、staging area、Local repository、Remote repository\ngit的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。\ngit单个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。\n传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。\n关于分支的合并：对于合并操作来说，如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的指针移到做过更改分支的指针的位置。\n而如果两个分支都做了更改，那么就找到更改的共同的祖先节点，以祖先节点为开始，将两个分支所有做出的更改都放在一起，在工作分支上形成一个新的节点\n删除分支时，只是删除了分支指针，并没有删除在该分支上的commit。\n2.1 General process of software construction\n通常软件构造过程\n(1) Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。\n(2) Code review、Static code analysis：可以使用工具来发现bug，如CheckStyle, SpotBugs。\n(3) Testing：测试，单元测试、集成测试、系统测试…\n(4) Debugging：调试\n(5) Dynamic code analysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分\n(6) Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化\n(7)Build：chapter 2\n2. 狭义的软件构造过程(Build)\n这是一个借助于工具，将软件构造过程中大的各阶段的活动自动化的过程，尽可能地脱离人工，以提高构造效率。\n常用的工具：Jenkins、Make、Ant、Maven、Gradle、Eclipse IDE\n利用工具完成项目的自动化构建、测试、打包release等功能，完成build time–>run time。\n"
  },
  {
    "head": "HIT软件构造lab1心得",
    "paragraphs": [
      "1实验目标概述",
      "本次实验通过求解三个问题，训练基本 Java 编程技能，能够利用 Java OO 开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用 Git 作为代码配置管理的工具，学会 Git 的基本使用方法。",
      "基本的 Java OO 编程",
      "基于 Eclipse IDE 进行 Java 编程",
      "基于 JUnit 的测试",
      "基于 Git 的代码配置管理",
      "2实验环境配置",
      "安装Eclipse、JDK和Git",
      "1、在配置Eclipse时，通过Window–Preferences–Java–Installed JREs–添加已安装好的jdk的路径，配置jdk",
      "2、学习了一些Git指令，如3.2 Problrm 2 中初始化一个本地仓库，并将Lab1 push到本地仓库中。",
      "3、学习了Junit测试project，在要使用Junit的project名上，右键–properties–java build path–libraries–Add External JARs–点击Junit包。在3.2和3.3中书写并使用Junit进行测试。",
      "3实验过程",
      "请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。",
      "为了条理清晰，可根据需要在各节增加三级标题。",
      "3.1Magic Squares",
      "该任务有两个要求：",
      "1、实现从txt文本中读取数据并保存，判断其是否为魔方阵",
      "2、创建一个阶数为n，且n为奇数的魔方阵，并根据1的代码判断这个魔方阵是否满足定义。在给出的代码中添加注释，并将创建出的魔方阵保存到6.txt文本中，当程序异常时,“优雅的”退出——函数输出 false 结束，并非非法退出。",
      "3.1.1isLegalMagicSquare()",
      "1、该函数：boolean isLegalMagicSquare(String fileName)接受一个文件名，并且返回一个布尔结果（True/False),通过文件名+文件相对路径，函数读取文本中的数据，保存在一个二维数组中，进行判断该文本中的数据是否为魔方阵。",
      "2、在函数：void main(String[] args) throws IOException中定义fileName并传输给isLegalMagicSquare，通过 “src/P1/” + fileName 找到文本文件。",
      "3、首先将数据按行存储在一个可动态修改的数组中，并且通过“\\t”分隔符将数据存入一个二维数组中。",
      "4、对存入的数据进行判断：",
      "（1）判断文本中的数据是否合理：",
      "①判断文本中数据是否重复；",
      "②判断文本中数据是否均大于0；",
      "③判断数据中是否含有小数；",
      "④判断是否有文按“\\t”分割存储的数据；",
      "（2）判断数据是否满足每行、列和两条对角线之和均相等。",
      "3.1.2generateMagicSquare()",
      "函数注释：",
      "第0行中间，放置1。",
      "向当前位置的右上方放置下一个数；若下一个位置超出数组下标范围，则将魔方阵沿行、列方向看成环形，下标再从0开始计数",
      "若当前放置数是n的倍数，表示一条对角线已满，则下一个位置是本列的下一行",
      "采用二维数组存放幻方阵，元素下标i，j沿行、列方向看成环形变化规律如下：",
      "i = （i-1+n）%n； //向上一行",
      "j = （j+1）%n； //向右一列",
      "1、在调用函数generateMagicSquare()前，先对输入的n值进行判断，将大于0且是奇数的n传输到函数中。",
      "2、首先构造出n*n的魔方阵",
      "3、将魔方阵写入6.txt中",
      "4、输出生成的魔方阵",
      "5、调用函数IsLegalMagicSquare()判断6.txt中的数据是否是魔方阵",
      "6、结果",
      "关于异常产生的分析:",
      "此时数组下标为负值,输入的n为负值循环时数组下标为负，所以产生异常。",
      "3.2Turtle Graphics",
      "获取turtle包，熟悉Turtle Gragpics的各种函数接口，调用已有的函数，实现java语言的绘图功能，并用java给出的.Math库里的函数实现一些简单的计算功能。",
      "3.2.1Problem 1: Clone and import",
      "3.2.1.1从GitHub获取该任务的代码",
      "https://github.com/rainywang/Spring2021_HITCS_SC_Lab1/tree/master/P2获取代码。将turtle包和rules包存入本地文件夹中，在Eclipse中，File–import–General–File system–Browse…–找到本地文件夹并将turtle包和rules包复制到eclipse-workspace/TurtleGragphics.java/src/中，完成将实验需要的库导入。",
      "3.2.1.2在本地创建Git仓库：",
      "右键Project TurtleGragphics.java–Team–Share Project…–Git–next–Finish",
      "3.2.1.3使用git管理本地开发。",
      "右键Project TurtleGragphics.java–Team->commit->Staged Changes->Commit Message->Commit(推到本地仓库)",
      "3.2.2Problem 3: Turtle graphics and drawSquare",
      "3.2.2.1提供两个函数",
      "forward(units) ：",
      "在当前方向上按单位像素移动turtlre，其中单位是一个整数。按照最初的标志惯例，turtle从朝上开始。",
      "turn(degrees) :",
      "更改当前朝向，向右顺时针旋转，其中度数是double型。",
      "3.2.2.2",
      "调用forward()、turn()函数，画正方形，需要顺时针旋转90°前进sideLength,循环4次",
      "下图为边长sideLength为100的正方形",
      "3.2.3Problem 5: Drawing polygons",
      "3.2.3.1已知正多边形边数sides，求内角的度数",
      "由数学公式推导得 内角度数=(double)((sides-2)*180.0/sides)",
      "运行TurtleSoupTest中的Junit测试calculateRegularPolygonAngle()：右键TurtleSoupTest.java–Run as–1 JUnit Test",
      "3.2.3.2 drawRegularPolygon(Turtle, int, int)，已知正多边形的内角、边数、边长，画出这个正多边形（转动的角度=180°- 内角）",
      "Main函数，在main中输入得到正多边形的边数和边长",
      "3.2.3.3 示例",
      "边长为50的正六边形",
      "边长为60的正八边形",
      "3.2.4Problem 6: Calculating Bearings",
      "3.2.4.1calculateBearingToPoint(double, int, int, int, int)计算turtle从当前位置和朝向到终点顺时针需要转过的角",
      "首先计算过两点的线段与x轴正方向形成的夹角，这里使用了Main.atan(x,y)函数，在与currentBearing相减，此时要注意：",
      "1、判断起点和终点是否重合",
      "2、夹角和turtle转过的角度范围都是[0.0,360.0）",
      "3、turtle朝向是上，而x轴正方向是向右，turtle是顺时针旋转（角度由小到大），坐标轴是逆时针旋转（角度由小到大）。所以currentBearing要减去90再取相反数。即currentBearing = 90 - currentBearing。",
      "Junit测试",
      "3.2.4.2public static List calculateBearings(List xCoords, List yCoords)",
      "该函数使用List 存放每次调用calculateBearingToPoint返回的值，依次对相邻节点调用calculateBearingToPoint，在下一次循环，这一次的终点会被覆盖为下一次的起点，假设初始的起点为（0，0），总共由n个点，则有n-1次调用，在for循环中i=1，所以共循环n-2次。",
      "Junit测试",
      "3.2.5Problem 7: Convex Hulls",
      "算法：边界漫游法",
      "时间复杂度：T（n）= O（n^2）",
      "1、首先遍历所有的点，找到最左下角的点",
      "2、以找到的点为基点，y轴正向为目前偏移角，开始依次找顺势针转角最小的点， 记录这个点并将它加入到凸包集合中，以这次的偏向角累加上之前的角度度作为下一次 的目前偏向角。",
      "3、循环直到再次遇到最左下角为止退出",
      "Junit测试",
      "3.2.6Problem 8: Personal art",
      "3.2.7Submitting",
      "如何通过Git提交当前版本到GitHub上你的Lab1仓库。",
      "3.3Social Network",
      "熟悉和掌握java中的数据结构类型，本项目要求我们掌握图的遍历，求两点之间的最短路径。",
      "利用图来实现人与人之间的关系，并能任意计算出人与人之间的情况（有无联系），基于FriendshipGraph类和Person类",
      "3.3.1设计/实现FriendshipGraph类",
      "FriendshipGraph类中包含图中所有点，每个点代表了一个Person，包含Person之间的边，并且可以计算两点之间的距离",
      "1、addVertex（）对Person名字进行判重：用哈希集合记录下所有Person的名字，当有新的Person加入时则判断是否已经在集合中。",
      "2、addEdge（）将两个Person之间进行联系，在图中，两个点之间的有向边表示两个Person之间有联系，而联系是双向的，所以在计算边数时需要加两个方向的边。",
      "3、getDistance（），计算任意两个Person之间的距离，若没有任何联系则输出-1。使用BFS算法。",
      "3.3.2设计/实现Person类",
      "给出将每个人对应到一个Person上，并保存名字，调用每个Person姓名和朋友列表",
      "3.3.3设计/实现客户端代码main()",
      "由Lab1手册得：",
      "结果为：",
      "3.3.4设计/实现测试用例",
      "3.3.4.1addVertexTest()函数",
      "调用addVertex（）函数，添加一个人，并判断Person中最后一个是不是这个人",
      "3.3.4.23.3.4.2addEdgeTest()",
      "调用addEdge（）函数，给两个人添加联系，并判断xw中的朋友最后一个人是不是wy",
      "3.3.4.3getDistanceTest()",
      "调用getDistance（）函数，增加了a,b,c三人，并添加关系，判断与我们添加的关系是否一致",
      "Junit测试：",
      "4实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。",
      "不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。",
      "日期 时间段 任务 实际完成情况",
      "2021-05-11 13:30-15:30 编写3.1.1 isLegalMagicSquare() 按计划完成",
      "2021-05-12 16：00-20：00 编写generateMagicSquare()，",
      "完成3.1 延期1小时完成",
      "2021-05-16 13：00-20：00 3.2 Problem1-Problem6 按计划完成",
      "2021-05-18 13:30-17:30 3.2 Problem7 按计划完成",
      "2021-05-19 16：00-20：00 3.2 完成 按计划完成",
      "2021-05-20 16：00-22：00 3.3 3.3.1FriendshipGraph类 按计划完成",
      "2021-05-21 18：00-23：00 3.3.2设计/实现Person类 按计划完成",
      "2021-05-22 8：00-15：30 3.3完成 延期1小时完成",
      "2021-05-23 8：00-14：00 完成Lab1实验报告 按计划完成",
      "5实验过程中遇到的困难与解决途径",
      "遇到的困难 解决途径",
      "Junit测试",
      "在3.2中test开始处是规定好的文件格式，添加Junit4后即可测试，在3.3中自己写测试的时候没有注意格式导致不成功，在与3.2中对比后，成功写出了可以进行junit测试的test.java文件",
      "凸包问题难以解决",
      "通过查询资料得到许多解决凸包问题的算法",
      "6实验过程中收获的经验、教训、感想",
      "6.1实验过程中收获的经验和教训",
      "6.2针对以下方面的感受",
      "(1)Java编程语言是否对你的口味？",
      "第一次接触java，对其中的许多函数还不了解，只能从头开始学习。使用c语言完成的一些非常复杂的数据结构在java库中已经存在，对使用非常方便，这次实验让我受益匪浅。",
      "(2)关于Eclipse IDE；",
      "初次使用Eclipse，许多操作并不了解，而网络上对它的细致的、系统的描述也比较少，只能通过一点点查询来了解java文件运行出错时可能的原因。让我比较印象深刻的是，eclipse对可能为空的字符串非常严格，只有在判断其不为空时，才能继续运行。",
      "(3)关于Git和GitHub；",
      "Git之前从未接触过,它可以在本地构建仓库更新版本，对Github也是知之甚少,这次实验我也只是学会创建了一个账号。",
      "(4)关于CMU和MIT的作业；",
      "全英文让我理解起来比较困难，只能反复的读题去理解题意",
      "(5)关于本实验的工作量、难度、deadline；",
      "对于初次接触java语言的我来说，有些吃力，deadline比较合理，因为平时周末基本没有课，没有实验的话可能也不会起早。",
      "(6)关于初接触“软件构造”课程；",
      "之前没有系统的了解过这门课程，但经过这几周的学习，让我对它愈发感兴趣起来。"
    ],
    "sentences": [
      "1实验目标概述",
      "本次实验通过求解三个问题",
      "训练基本 Java 编程技能",
      "能够利用 Java OO 开发基本的功能模块",
      "能够阅读理解已有代码框架并根据功能需求补全代码",
      "能够为所开发的代码编写基本的测试程序并完成测试",
      "初步保证所开发代码的正确性",
      "另一方面",
      "利用 Git 作为代码配置管理的工具",
      "学会 Git 的基本使用方法",
      "基本的 Java OO 编程",
      "基于 Eclipse IDE 进行 Java 编程",
      "基于 JUnit 的测试",
      "基于 Git 的代码配置管理",
      "2实验环境配置",
      "安装Eclipse、JDK和Git",
      "1、在配置Eclipse时",
      "通过Window–Preferences–Java–Installed JREs–添加已安装好的jdk的路径",
      "配置jdk",
      "2、学习了一些Git指令",
      "如3.2 Problrm 2 中初始化一个本地仓库",
      "并将Lab1 push到本地仓库中",
      "3、学习了Junit测试project",
      "在要使用Junit的project名上",
      "右键–properties–java build path–libraries–Add External JARs–点击Junit包",
      "在3.2和3.3中书写并使用Junit进行测试",
      "3实验过程",
      "请仔细对照实验手册",
      "针对四个问题中的每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）",
      "为了条理清晰，可根据需要在各节增加三级标题",
      "3.1Magic Squares",
      "该任务有两个要求：1、实现从txt文本中读取数据并保存",
      "判断其是否为魔方阵",
      "2、创建一个阶数为n",
      "且n为奇数的魔方阵",
      "并根据1的代码判断这个魔方阵是否满足定义",
      "在给出的代码中添加注释",
      "并将创建出的魔方阵保存到6.txt文本中",
      "当程序异常时,“优雅的”退出——函数输出 false 结束",
      "并非非法退出",
      "3.1.1isLegalMagicSquare()",
      "1、该函数：boolean isLegalMagicSquare(String fileName)接受一个文件名",
      "并且返回一个布尔结果（True/False),通过文件名+文件相对路径",
      "函数读取文本中的数据",
      "保存在一个二维数组中",
      "进行判断该文本中的数据是否为魔方阵",
      "2、在函数：void main(String[] args) throws IOException中定义fileName并传输给isLegalMagicSquare",
      "通过 “src/P1/” + fileName 找到文本文件",
      "3、首先将数据按行存储在一个可动态修改的数组中",
      "并且通过“\\t”分隔符将数据存入一个二维数组中",
      "4、对存入的数据进行判断：（1）判断文本中的数据是否合理：①判断文本中数据是否重复；②判断文本中数据是否均大于0；③判断数据中是否含有小数；④判断是否有文按“\\t”分割存储的数据；（2）判断数据是否满足每行、列和两条对角线之和均相等",
      "3.1.2generateMagicSquare()",
      "函数注释：第0行中间，放置1",
      "向当前位置的右上方放置下一个数；若下一个位置超出数组下标范围",
      "则将魔方阵沿行、列方向看成环形",
      "下标再从0开始计数",
      "若当前放置数是n的倍数",
      "表示一条对角线已满",
      "则下一个位置是本列的下一行",
      "采用二维数组存放幻方阵",
      "元素下标i",
      "j沿行、列方向看成环形变化规律如下：i = （i-1+n）%n； //向上一行",
      "j = （j+1）%n； //向右一列",
      "1、在调用函数generateMagicSquare()前",
      "先对输入的n值进行判断",
      "将大于0且是奇数的n传输到函数中",
      "2、首先构造出n*n的魔方阵",
      "3、将魔方阵写入6.txt中",
      "4、输出生成的魔方阵",
      "5、调用函数IsLegalMagicSquare()判断6.txt中的数据是否是魔方阵",
      "6、结果",
      "关于异常产生的分析:此时数组下标为负值,输入的n为负值循环时数组下标为负",
      "所以产生异常",
      "3.2Turtle Graphics",
      "获取turtle包",
      "熟悉Turtle Gragpics的各种函数接口",
      "调用已有的函数",
      "实现java语言的绘图功能",
      "并用java给出的.Math库里的函数实现一些简单的计算功能",
      "3.2.1Problem 1: Clone and import",
      "3.2.1.1从GitHub获取该任务的代码",
      "https://github.com/rainywang/Spring2021_HITCS_SC_Lab1/tree/master/P2获取代码",
      "将turtle包和rules包存入本地文件夹中",
      "在Eclipse中",
      "File–import–General–File system–Browse…–找到本地文件夹并将turtle包和rules包复制到eclipse-workspace/TurtleGragphics.java/src/中",
      "完成将实验需要的库导入",
      "3.2.1.2在本地创建Git仓库：右键Project TurtleGragphics.java–Team–Share Project…–Git–next–Finish",
      "3.2.1.3使用git管理本地开发",
      "右键Project TurtleGragphics.java–Team->commit->Staged Changes->Commit Message->Commit(推到本地仓库)",
      "3.2.2Problem 3: Turtle graphics and drawSquare",
      "3.2.2.1提供两个函数",
      "forward(units) ：在当前方向上按单位像素移动turtlre",
      "其中单位是一个整数",
      "按照最初的标志惯例，turtle从朝上开始",
      "turn(degrees) :更改当前朝向",
      "向右顺时针旋转",
      "其中度数是double型",
      "3.2.2.2",
      "调用forward()、turn()函数",
      "画正方形",
      "需要顺时针旋转90°前进sideLength,循环4次",
      "下图为边长sideLength为100的正方形",
      "3.2.3Problem 5: Drawing polygons",
      "3.2.3.1已知正多边形边数sides，求内角的度数",
      "由数学公式推导得 内角度数=(double)((sides-2)*180.0/sides)",
      "运行TurtleSoupTest中的Junit测试calculateRegularPolygonAngle()：右键TurtleSoupTest.java–Run as–1 JUnit Test",
      "3.2.3.2 drawRegularPolygon(Turtle, int, int)",
      "已知正多边形的内角、边数、边长",
      "画出这个正多边形（转动的角度=180°- 内角）",
      "Main函数，在main中输入得到正多边形的边数和边长",
      "3.2.3.3 示例",
      "边长为50的正六边形",
      "边长为60的正八边形",
      "3.2.4Problem 6: Calculating Bearings",
      "3.2.4.1calculateBearingToPoint(double, int, int, int, int)计算turtle从当前位置和朝向到终点顺时针需要转过的角",
      "首先计算过两点的线段与x轴正方向形成的夹角",
      "这里使用了Main.atan(x,y)函数",
      "在与currentBearing相减",
      "此时要注意：1、判断起点和终点是否重合",
      "2、夹角和turtle转过的角度范围都是[0.0,360.0）",
      "3、turtle朝向是上",
      "而x轴正方向是向右",
      "turtle是顺时针旋转（角度由小到大）",
      "坐标轴是逆时针旋转（角度由小到大）",
      "所以currentBearing要减去90再取相反数",
      "即currentBearing = 90 - currentBearing",
      "Junit测试",
      "3.2.4.2public static List calculateBearings(List xCoords, List yCoords)",
      "该函数使用List 存放每次调用calculateBearingToPoint返回的值",
      "依次对相邻节点调用calculateBearingToPoint",
      "在下一次循环",
      "这一次的终点会被覆盖为下一次的起点",
      "假设初始的起点为（0",
      "0）",
      "总共由n个点",
      "则有n-1次调用",
      "在for循环中i=1",
      "所以共循环n-2次",
      "Junit测试",
      "3.2.5Problem 7: Convex Hulls",
      "算法：边界漫游法",
      "时间复杂度：T（n）= O（n^2）",
      "1、首先遍历所有的点，找到最左下角的点",
      "2、以找到的点为基点",
      "y轴正向为目前偏移角",
      "开始依次找顺势针转角最小的点",
      " 记录这个点并将它加入到凸包集合中",
      "以这次的偏向角累加上之前的角度度作为下一次 的目前偏向角",
      "3、循环直到再次遇到最左下角为止退出",
      "Junit测试",
      "3.2.6Problem 8: Personal art",
      "3.2.7Submitting",
      "如何通过Git提交当前版本到GitHub上你的Lab1仓库",
      "3.3Social Network",
      "熟悉和掌握java中的数据结构类型",
      "本项目要求我们掌握图的遍历",
      "求两点之间的最短路径",
      "利用图来实现人与人之间的关系",
      "并能任意计算出人与人之间的情况（有无联系）",
      "基于FriendshipGraph类和Person类",
      "3.3.1设计/实现FriendshipGraph类",
      "FriendshipGraph类中包含图中所有点",
      "每个点代表了一个Person",
      "包含Person之间的边",
      "并且可以计算两点之间的距离",
      "1、addVertex（）对Person名字进行判重：用哈希集合记录下所有Person的名字",
      "当有新的Person加入时则判断是否已经在集合中",
      "2、addEdge（）将两个Person之间进行联系",
      "在图中",
      "两个点之间的有向边表示两个Person之间有联系",
      "而联系是双向的",
      "所以在计算边数时需要加两个方向的边",
      "3、getDistance（）",
      "计算任意两个Person之间的距离",
      "若没有任何联系则输出-1",
      "使用BFS算法",
      "3.3.2设计/实现Person类",
      "给出将每个人对应到一个Person上",
      "并保存名字",
      "调用每个Person姓名和朋友列表",
      "3.3.3设计/实现客户端代码main()",
      "由Lab1手册得：结果为：3.3.4设计/实现测试用例",
      "3.3.4.1addVertexTest()函数",
      "调用addVertex（）函数",
      "添加一个人",
      "并判断Person中最后一个是不是这个人",
      "3.3.4.23.3.4.2addEdgeTest()",
      "调用addEdge（）函数",
      "给两个人添加联系",
      "并判断xw中的朋友最后一个人是不是wy",
      "3.3.4.3getDistanceTest()",
      "调用getDistance（）函数",
      "增加了a,b,c三人",
      "并添加关系",
      "判断与我们添加的关系是否一致",
      "Junit测试：4实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "每次结束编程时，请向该表格中增加一行",
      "不要事后胡乱填写",
      "不要嫌烦",
      "该表格可帮助你汇总你在每个任务上付出的时间和精力",
      "发现自己不擅长的任务",
      "后续有意识的弥补",
      "日期 时间段 任务 实际完成情况",
      "2021-05-11 13:30-15:30 编写3.1.1 isLegalMagicSquare() 按计划完成",
      "2021-05-12 16：00-20：00 编写generateMagicSquare()",
      "完成3.1 延期1小时完成",
      "2021-05-16 13：00-20：00 3.2 Problem1-Problem6 按计划完成",
      "2021-05-18 13:30-17:30 3.2 Problem7 按计划完成",
      "2021-05-19 16：00-20：00 3.2 完成 按计划完成",
      "2021-05-20 16：00-22：00 3.3 3.3.1FriendshipGraph类 按计划完成",
      "2021-05-21 18：00-23：00 3.3.2设计/实现Person类 按计划完成",
      "2021-05-22 8：00-15：30 3.3完成 延期1小时完成",
      "2021-05-23 8：00-14：00 完成Lab1实验报告 按计划完成",
      "5实验过程中遇到的困难与解决途径",
      "遇到的困难 解决途径",
      "Junit测试",
      "在3.2中test开始处是规定好的文件格式",
      "添加Junit4后即可测试",
      "在3.3中自己写测试的时候没有注意格式导致不成功",
      "在与3.2中对比后",
      "成功写出了可以进行junit测试的test.java文件",
      "凸包问题难以解决",
      "通过查询资料得到许多解决凸包问题的算法",
      "6实验过程中收获的经验、教训、感想",
      "6.1实验过程中收获的经验和教训",
      "6.2针对以下方面的感受",
      "(1)Java编程语言是否对你的口味？",
      "第一次接触java",
      "对其中的许多函数还不了解",
      "只能从头开始学习",
      "使用c语言完成的一些非常复杂的数据结构在java库中已经存在",
      "对使用非常方便",
      "这次实验让我受益匪浅",
      "(2)关于Eclipse IDE；初次使用Eclipse",
      "许多操作并不了解",
      "而网络上对它的细致的、系统的描述也比较少",
      "只能通过一点点查询来了解java文件运行出错时可能的原因",
      "让我比较印象深刻的是",
      "eclipse对可能为空的字符串非常严格",
      "只有在判断其不为空时",
      "才能继续运行",
      "(3)关于Git和GitHub；Git之前从未接触过,它可以在本地构建仓库更新版本",
      "对Github也是知之甚少,这次实验我也只是学会创建了一个账号",
      "(4)关于CMU和MIT的作业；全英文让我理解起来比较困难",
      "只能反复的读题去理解题意",
      "(5)关于本实验的工作量、难度、deadline；对于初次接触java语言的我来说",
      "有些吃力",
      "deadline比较合理",
      "因为平时周末基本没有课",
      "没有实验的话可能也不会起早",
      "(6)关于初接触“软件构造”课程；之前没有系统的了解过这门课程",
      "但经过这几周的学习",
      "让我对它愈发感兴趣起来"
    ],
    "codes": [
      "数组越界,原因是在生成函数中,i<=square,计算机面对非整数时常用的方法是向下取整,输入奇数时col = n / 2的值会向下取整,而square = n*n,所以此时i即使=square,数组也不会越界,而如果输入为偶数时,当i = square时就会发生越界 ,原因是在下标为n的数组中放入了大于n个的数据\n"
    ],
    "date": "2021-07-06",
    "text": "1实验目标概述\n本次实验通过求解三个问题，训练基本 Java 编程技能，能够利用 Java OO 开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用 Git 作为代码配置管理的工具，学会 Git 的基本使用方法。\n基本的 Java OO 编程\n基于 Eclipse IDE 进行 Java 编程\n基于 JUnit 的测试\n基于 Git 的代码配置管理\n2实验环境配置\n安装Eclipse、JDK和Git\n1、在配置Eclipse时，通过Window–Preferences–Java–Installed JREs–添加已安装好的jdk的路径，配置jdk\n2、学习了一些Git指令，如3.2 Problrm 2 中初始化一个本地仓库，并将Lab1 push到本地仓库中。\n3、学习了Junit测试project，在要使用Junit的project名上，右键–properties–java build path–libraries–Add External JARs–点击Junit包。在3.2和3.3中书写并使用Junit进行测试。\n3实验过程\n请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。\n为了条理清晰，可根据需要在各节增加三级标题。\n3.1Magic Squares\n该任务有两个要求：\n1、实现从txt文本中读取数据并保存，判断其是否为魔方阵\n2、创建一个阶数为n，且n为奇数的魔方阵，并根据1的代码判断这个魔方阵是否满足定义。在给出的代码中添加注释，并将创建出的魔方阵保存到6.txt文本中，当程序异常时,“优雅的”退出——函数输出 false 结束，并非非法退出。\n3.1.1isLegalMagicSquare()\n1、该函数：boolean isLegalMagicSquare(String fileName)接受一个文件名，并且返回一个布尔结果（True/False),通过文件名+文件相对路径，函数读取文本中的数据，保存在一个二维数组中，进行判断该文本中的数据是否为魔方阵。\n2、在函数：void main(String[] args) throws IOException中定义fileName并传输给isLegalMagicSquare，通过 “src/P1/” + fileName 找到文本文件。\n3、首先将数据按行存储在一个可动态修改的数组中，并且通过“\\t”分隔符将数据存入一个二维数组中。\n4、对存入的数据进行判断：\n（1）判断文本中的数据是否合理：\n①判断文本中数据是否重复；\n②判断文本中数据是否均大于0；\n③判断数据中是否含有小数；\n④判断是否有文按“\\t”分割存储的数据；\n（2）判断数据是否满足每行、列和两条对角线之和均相等。\n3.1.2generateMagicSquare()\n函数注释：\n第0行中间，放置1。\n向当前位置的右上方放置下一个数；若下一个位置超出数组下标范围，则将魔方阵沿行、列方向看成环形，下标再从0开始计数\n若当前放置数是n的倍数，表示一条对角线已满，则下一个位置是本列的下一行\n采用二维数组存放幻方阵，元素下标i，j沿行、列方向看成环形变化规律如下：\ni = （i-1+n）%n； //向上一行\nj = （j+1）%n； //向右一列\n1、在调用函数generateMagicSquare()前，先对输入的n值进行判断，将大于0且是奇数的n传输到函数中。\n2、首先构造出n*n的魔方阵\n3、将魔方阵写入6.txt中\n4、输出生成的魔方阵\n5、调用函数IsLegalMagicSquare()判断6.txt中的数据是否是魔方阵\n6、结果\n关于异常产生的分析:\n此时数组下标为负值,输入的n为负值循环时数组下标为负，所以产生异常。\n3.2Turtle Graphics\n获取turtle包，熟悉Turtle Gragpics的各种函数接口，调用已有的函数，实现java语言的绘图功能，并用java给出的.Math库里的函数实现一些简单的计算功能。\n3.2.1Problem 1: Clone and import\n3.2.1.1从GitHub获取该任务的代码\nhttps://github.com/rainywang/Spring2021_HITCS_SC_Lab1/tree/master/P2获取代码。将turtle包和rules包存入本地文件夹中，在Eclipse中，File–import–General–File system–Browse…–找到本地文件夹并将turtle包和rules包复制到eclipse-workspace/TurtleGragphics.java/src/中，完成将实验需要的库导入。\n3.2.1.2在本地创建Git仓库：\n右键Project TurtleGragphics.java–Team–Share Project…–Git–next–Finish\n3.2.1.3使用git管理本地开发。\n右键Project TurtleGragphics.java–Team->commit->Staged Changes->Commit Message->Commit(推到本地仓库)\n3.2.2Problem 3: Turtle graphics and drawSquare\n3.2.2.1提供两个函数\nforward(units) ：\n在当前方向上按单位像素移动turtlre，其中单位是一个整数。按照最初的标志惯例，turtle从朝上开始。\nturn(degrees) :\n更改当前朝向，向右顺时针旋转，其中度数是double型。\n3.2.2.2\n调用forward()、turn()函数，画正方形，需要顺时针旋转90°前进sideLength,循环4次\n下图为边长sideLength为100的正方形\n3.2.3Problem 5: Drawing polygons\n3.2.3.1已知正多边形边数sides，求内角的度数\n由数学公式推导得 内角度数=(double)((sides-2)*180.0/sides)\n运行TurtleSoupTest中的Junit测试calculateRegularPolygonAngle()：右键TurtleSoupTest.java–Run as–1 JUnit Test\n3.2.3.2 drawRegularPolygon(Turtle, int, int)，已知正多边形的内角、边数、边长，画出这个正多边形（转动的角度=180°- 内角）\nMain函数，在main中输入得到正多边形的边数和边长\n3.2.3.3 示例\n边长为50的正六边形\n边长为60的正八边形\n3.2.4Problem 6: Calculating Bearings\n3.2.4.1calculateBearingToPoint(double, int, int, int, int)计算turtle从当前位置和朝向到终点顺时针需要转过的角\n首先计算过两点的线段与x轴正方向形成的夹角，这里使用了Main.atan(x,y)函数，在与currentBearing相减，此时要注意：\n1、判断起点和终点是否重合\n2、夹角和turtle转过的角度范围都是[0.0,360.0）\n3、turtle朝向是上，而x轴正方向是向右，turtle是顺时针旋转（角度由小到大），坐标轴是逆时针旋转（角度由小到大）。所以currentBearing要减去90再取相反数。即currentBearing = 90 - currentBearing。\nJunit测试\n3.2.4.2public static List calculateBearings(List xCoords, List yCoords)\n该函数使用List 存放每次调用calculateBearingToPoint返回的值，依次对相邻节点调用calculateBearingToPoint，在下一次循环，这一次的终点会被覆盖为下一次的起点，假设初始的起点为（0，0），总共由n个点，则有n-1次调用，在for循环中i=1，所以共循环n-2次。\nJunit测试\n3.2.5Problem 7: Convex Hulls\n算法：边界漫游法\n时间复杂度：T（n）= O（n^2）\n1、首先遍历所有的点，找到最左下角的点\n2、以找到的点为基点，y轴正向为目前偏移角，开始依次找顺势针转角最小的点， 记录这个点并将它加入到凸包集合中，以这次的偏向角累加上之前的角度度作为下一次 的目前偏向角。\n3、循环直到再次遇到最左下角为止退出\nJunit测试\n3.2.6Problem 8: Personal art\n3.2.7Submitting\n如何通过Git提交当前版本到GitHub上你的Lab1仓库。\n3.3Social Network\n熟悉和掌握java中的数据结构类型，本项目要求我们掌握图的遍历，求两点之间的最短路径。\n利用图来实现人与人之间的关系，并能任意计算出人与人之间的情况（有无联系），基于FriendshipGraph类和Person类\n3.3.1设计/实现FriendshipGraph类\nFriendshipGraph类中包含图中所有点，每个点代表了一个Person，包含Person之间的边，并且可以计算两点之间的距离\n1、addVertex（）对Person名字进行判重：用哈希集合记录下所有Person的名字，当有新的Person加入时则判断是否已经在集合中。\n2、addEdge（）将两个Person之间进行联系，在图中，两个点之间的有向边表示两个Person之间有联系，而联系是双向的，所以在计算边数时需要加两个方向的边。\n3、getDistance（），计算任意两个Person之间的距离，若没有任何联系则输出-1。使用BFS算法。\n3.3.2设计/实现Person类\n给出将每个人对应到一个Person上，并保存名字，调用每个Person姓名和朋友列表\n3.3.3设计/实现客户端代码main()\n由Lab1手册得：\n结果为：\n3.3.4设计/实现测试用例\n3.3.4.1addVertexTest()函数\n调用addVertex（）函数，添加一个人，并判断Person中最后一个是不是这个人\n3.3.4.23.3.4.2addEdgeTest()\n调用addEdge（）函数，给两个人添加联系，并判断xw中的朋友最后一个人是不是wy\n3.3.4.3getDistanceTest()\n调用getDistance（）函数，增加了a,b,c三人，并添加关系，判断与我们添加的关系是否一致\nJunit测试：\n4实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。\n不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。\n日期 时间段 任务 实际完成情况\n2021-05-11 13:30-15:30 编写3.1.1 isLegalMagicSquare() 按计划完成\n2021-05-12 16：00-20：00 编写generateMagicSquare()，\n完成3.1 延期1小时完成\n2021-05-16 13：00-20：00 3.2 Problem1-Problem6 按计划完成\n2021-05-18 13:30-17:30 3.2 Problem7 按计划完成\n2021-05-19 16：00-20：00 3.2 完成 按计划完成\n2021-05-20 16：00-22：00 3.3 3.3.1FriendshipGraph类 按计划完成\n2021-05-21 18：00-23：00 3.3.2设计/实现Person类 按计划完成\n2021-05-22 8：00-15：30 3.3完成 延期1小时完成\n2021-05-23 8：00-14：00 完成Lab1实验报告 按计划完成\n5实验过程中遇到的困难与解决途径\n遇到的困难 解决途径\nJunit测试\n在3.2中test开始处是规定好的文件格式，添加Junit4后即可测试，在3.3中自己写测试的时候没有注意格式导致不成功，在与3.2中对比后，成功写出了可以进行junit测试的test.java文件\n凸包问题难以解决\n通过查询资料得到许多解决凸包问题的算法\n6实验过程中收获的经验、教训、感想\n6.1实验过程中收获的经验和教训\n6.2针对以下方面的感受\n(1)Java编程语言是否对你的口味？\n第一次接触java，对其中的许多函数还不了解，只能从头开始学习。使用c语言完成的一些非常复杂的数据结构在java库中已经存在，对使用非常方便，这次实验让我受益匪浅。\n(2)关于Eclipse IDE；\n初次使用Eclipse，许多操作并不了解，而网络上对它的细致的、系统的描述也比较少，只能通过一点点查询来了解java文件运行出错时可能的原因。让我比较印象深刻的是，eclipse对可能为空的字符串非常严格，只有在判断其不为空时，才能继续运行。\n(3)关于Git和GitHub；\nGit之前从未接触过,它可以在本地构建仓库更新版本，对Github也是知之甚少,这次实验我也只是学会创建了一个账号。\n(4)关于CMU和MIT的作业；\n全英文让我理解起来比较困难，只能反复的读题去理解题意\n(5)关于本实验的工作量、难度、deadline；\n对于初次接触java语言的我来说，有些吃力，deadline比较合理，因为平时周末基本没有课，没有实验的话可能也不会起早。\n(6)关于初接触“软件构造”课程；\n之前没有系统的了解过这门课程，但经过这几周的学习，让我对它愈发感兴趣起来。\n"
  },
  {
    "head": "HIT软件构造五",
    "paragraphs": [
      "HIT软件构造笔记五",
      "Object-Oriented Programming",
      "1、Interface接口",
      "接口可以实现静态方法，使用 static 关键字。",
      "通过static关键字可以实现静态工厂方法，从而将接口的实现类封装，实现对外信息隐藏。",
      "接口中也允许使用 default 关键字来定义并实现实例方法，这个应用有点类似于抽象类的功能。",
      "通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它。",
      "2、继承和重写",
      "子类覆写的方法的可见性要大于等于父类，因为子类的对象应可以转型为父类对象，可见性的降低就会出现错误。同理，子类抛出的异常必须是父类的子集。",
      " 覆写的方法是在运行时判断类型来调用的，因此以new构造的类型为准。",
      " 在子类中,用super关键字来调用父类的各种方法，用的最多的是构造方法。",
      "3.、多态",
      "三种多态：特殊多态、参数化多态、子类型多态",
      "特殊多态:一个方法可以有多个同名的实现(方法重载)。要求参数列表必须有不同的地方，其他的并没有要求，总之就是把重载的方法看作和之前完全不同的方法。",
      "参数化多态:一个类型名字可以代表多个类型(泛型化编程)。",
      "子类型/包含多态:一个变量名字可以代表多个类的实例。",
      "4.ADT与OOP中的等价性",
      "判断等价性的方法",
      "①利用数学上等价的定义:满足自反性，对称性和传递性。",
      "②利用AF来定义ADT的等价判断，如果两个值的AF映射值相同，则说明他们等价。",
      "③在调用者角度，如果调用两个对象的所有任意操作，效果都完全一样，那么则说明他们等价。",
      "”与equals",
      "对于“",
      "”,代表着判断两个对象的地址空间是不是在同一个位置，也被称为引用等价性；而equals则代表着判断两个对象的内容，也被称为对象等价性。",
      " object类的equals默认为判断两者的地址空间是不是在同一位置。总的来说，对于基本数据类型，我们应该用“==”，而对于对象数据类型，我们应该用equals判断(当然，要根据需要判断是否应该覆写)，当然，我们要明确知道我们写的方法是覆写还是重载。",
      " 除了写equals方法，尽量不要用instanceof和getclass()，因为他们不符合OOP的思想，不是好的书写风格。",
      "hashcode与equals",
      "hashcode方法就类似于数据结构中的哈希函数一样，功能就是把一个个对象映射到一个地址(也就是桶)。默认的方式是按照地址映射，一般地址不同则值不同。",
      " 当我们使用HashSet等类似的数据结构的时候，这时再进行寻找时，就如同正常哈希表一样了，是通过判断哈希值是否相等先进行判断，哈希值相同是equals成立的前提，也是首先判断的方法。此时如果我们只重写equals而不重写hashcode，则hashcode还是默认的按地址算出一个值，一般而言只要地址不同则哈希值就不同了，导致了我们equals方法看似失效。",
      " 综上，equals()应满足如下条件：首先满足等价性(数学意义上)，其次保证在不被修改的情况下，每次调用的结果应该相同，同时要处理对象为null的情况还有如果这个类使用了哈希表进行查询(比如放入了HashSet中)，则也要覆写hashcode方法。",
      "可变类型的等价性：",
      "观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致。调用Observer方法表现出相同的结果。约等于对象等价性。",
      "行为等价性：调用对象的任何方法都展示出一致的结果。包括mutator、producer、observer。约等于引用等价性。",
      "equals()和hashCode()",
      "所以，对可变类型，实现行为等价性即可，也就是说，只有指向同样内存空间的对象才是相等的。所以对可变类型来说，无需重写这两个函数，直接继承Object的equals()和hashCode()即可。",
      "5.装箱及其等价性",
      " 在使用集合类时，我们前面也提到过，会进行隐式的装箱操作。因此，装箱完毕后，如果是两个不同对象，即使是整数的装箱，使用“==”进行判断也会返回false，要进行equals的覆写。",
      " 但是下面有一个特例，那就是如果是-128到127之间的整数，进行两次装箱操作，那得到的地址是一样的(得益于java的缓存机制)。当然，上面也是要求只装箱，不能为两次new的操作，不然肯定地址值不同。"
    ],
    "sentences": [
      "HIT软件构造笔记五",
      "Object-Oriented Programming",
      "1、Interface接口",
      "接口可以实现静态方法，使用 static 关键字",
      "通过static关键字可以实现静态工厂方法",
      "从而将接口的实现类封装",
      "实现对外信息隐藏",
      "接口中也允许使用 default 关键字来定义并实现实例方法",
      "这个应用有点类似于抽象类的功能",
      "通过default方法",
      "在接口中统一实现某些功能",
      "无需在各个类中重复实现它",
      "2、继承和重写",
      "子类覆写的方法的可见性要大于等于父类",
      "因为子类的对象应可以转型为父类对象",
      "可见性的降低就会出现错误",
      "同理，子类抛出的异常必须是父类的子集",
      " 覆写的方法是在运行时判断类型来调用的",
      "因此以new构造的类型为准",
      " 在子类中,用super关键字来调用父类的各种方法",
      "用的最多的是构造方法",
      "3.、多态",
      "三种多态：特殊多态、参数化多态、子类型多态",
      "特殊多态:一个方法可以有多个同名的实现(方法重载)",
      "要求参数列表必须有不同的地方",
      "其他的并没有要求",
      "总之就是把重载的方法看作和之前完全不同的方法",
      "参数化多态:一个类型名字可以代表多个类型(泛型化编程)",
      "子类型/包含多态:一个变量名字可以代表多个类的实例",
      "4.ADT与OOP中的等价性",
      "判断等价性的方法",
      "①利用数学上等价的定义:满足自反性，对称性和传递性",
      "②利用AF来定义ADT的等价判断",
      "如果两个值的AF映射值相同",
      "则说明他们等价",
      "③在调用者角度",
      "如果调用两个对象的所有任意操作",
      "效果都完全一样",
      "那么则说明他们等价",
      "”与equals",
      "对于“",
      "”,代表着判断两个对象的地址空间是不是在同一个位置",
      "也被称为引用等价性；而equals则代表着判断两个对象的内容",
      "也被称为对象等价性",
      " object类的equals默认为判断两者的地址空间是不是在同一位置",
      "总的来说",
      "对于基本数据类型",
      "我们应该用“==”",
      "而对于对象数据类型",
      "我们应该用equals判断(当然",
      "要根据需要判断是否应该覆写)",
      "当然",
      "我们要明确知道我们写的方法是覆写还是重载",
      " 除了写equals方法",
      "尽量不要用instanceof和getclass()",
      "因为他们不符合OOP的思想",
      "不是好的书写风格",
      "hashcode与equals",
      "hashcode方法就类似于数据结构中的哈希函数一样",
      "功能就是把一个个对象映射到一个地址(也就是桶)",
      "默认的方式是按照地址映射，一般地址不同则值不同",
      " 当我们使用HashSet等类似的数据结构的时候",
      "这时再进行寻找时",
      "就如同正常哈希表一样了",
      "是通过判断哈希值是否相等先进行判断",
      "哈希值相同是equals成立的前提",
      "也是首先判断的方法",
      "此时如果我们只重写equals而不重写hashcode",
      "则hashcode还是默认的按地址算出一个值",
      "一般而言只要地址不同则哈希值就不同了",
      "导致了我们equals方法看似失效",
      " 综上",
      "equals()应满足如下条件：首先满足等价性(数学意义上)",
      "其次保证在不被修改的情况下",
      "每次调用的结果应该相同",
      "同时要处理对象为null的情况还有如果这个类使用了哈希表进行查询(比如放入了HashSet中)",
      "则也要覆写hashcode方法",
      "可变类型的等价性：观察等价性：在不改变状态的情况下",
      "两个mutable对象是否看起来一致",
      "调用Observer方法表现出相同的结果",
      "约等于对象等价性",
      "行为等价性：调用对象的任何方法都展示出一致的结果",
      "包括mutator、producer、observer",
      "约等于引用等价性",
      "equals()和hashCode()",
      "所以",
      "对可变类型",
      "实现行为等价性即可",
      "也就是说",
      "只有指向同样内存空间的对象才是相等的",
      "所以对可变类型来说",
      "无需重写这两个函数",
      "直接继承Object的equals()和hashCode()即可",
      "5.装箱及其等价性",
      " 在使用集合类时，我们前面也提到过，会进行隐式的装箱操作",
      "因此",
      "装箱完毕后",
      "如果是两个不同对象",
      "即使是整数的装箱",
      "使用“==”进行判断也会返回false",
      "要进行equals的覆写",
      " 但是下面有一个特例",
      "那就是如果是-128到127之间的整数",
      "进行两次装箱操作",
      "那得到的地址是一样的(得益于java的缓存机制)",
      "当然",
      "上面也是要求只装箱",
      "不能为两次new的操作",
      "不然肯定地址值不同"
    ],
    "codes": [],
    "date": "2021-06-30",
    "text": "HIT软件构造笔记五\nObject-Oriented Programming\n1、Interface接口\n接口可以实现静态方法，使用 static 关键字。\n通过static关键字可以实现静态工厂方法，从而将接口的实现类封装，实现对外信息隐藏。\n接口中也允许使用 default 关键字来定义并实现实例方法，这个应用有点类似于抽象类的功能。\n通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它。\n2、继承和重写\n子类覆写的方法的可见性要大于等于父类，因为子类的对象应可以转型为父类对象，可见性的降低就会出现错误。同理，子类抛出的异常必须是父类的子集。\n 覆写的方法是在运行时判断类型来调用的，因此以new构造的类型为准。\n 在子类中,用super关键字来调用父类的各种方法，用的最多的是构造方法。\n3.、多态\n三种多态：特殊多态、参数化多态、子类型多态\n特殊多态:一个方法可以有多个同名的实现(方法重载)。要求参数列表必须有不同的地方，其他的并没有要求，总之就是把重载的方法看作和之前完全不同的方法。\n参数化多态:一个类型名字可以代表多个类型(泛型化编程)。\n子类型/包含多态:一个变量名字可以代表多个类的实例。\n4.ADT与OOP中的等价性\n判断等价性的方法\n①利用数学上等价的定义:满足自反性，对称性和传递性。\n②利用AF来定义ADT的等价判断，如果两个值的AF映射值相同，则说明他们等价。\n③在调用者角度，如果调用两个对象的所有任意操作，效果都完全一样，那么则说明他们等价。\n”与equals\n对于“\n”,代表着判断两个对象的地址空间是不是在同一个位置，也被称为引用等价性；而equals则代表着判断两个对象的内容，也被称为对象等价性。\n object类的equals默认为判断两者的地址空间是不是在同一位置。总的来说，对于基本数据类型，我们应该用“==”，而对于对象数据类型，我们应该用equals判断(当然，要根据需要判断是否应该覆写)，当然，我们要明确知道我们写的方法是覆写还是重载。\n 除了写equals方法，尽量不要用instanceof和getclass()，因为他们不符合OOP的思想，不是好的书写风格。\nhashcode与equals\nhashcode方法就类似于数据结构中的哈希函数一样，功能就是把一个个对象映射到一个地址(也就是桶)。默认的方式是按照地址映射，一般地址不同则值不同。\n 当我们使用HashSet等类似的数据结构的时候，这时再进行寻找时，就如同正常哈希表一样了，是通过判断哈希值是否相等先进行判断，哈希值相同是equals成立的前提，也是首先判断的方法。此时如果我们只重写equals而不重写hashcode，则hashcode还是默认的按地址算出一个值，一般而言只要地址不同则哈希值就不同了，导致了我们equals方法看似失效。\n 综上，equals()应满足如下条件：首先满足等价性(数学意义上)，其次保证在不被修改的情况下，每次调用的结果应该相同，同时要处理对象为null的情况还有如果这个类使用了哈希表进行查询(比如放入了HashSet中)，则也要覆写hashcode方法。\n可变类型的等价性：\n观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致。调用Observer方法表现出相同的结果。约等于对象等价性。\n行为等价性：调用对象的任何方法都展示出一致的结果。包括mutator、producer、observer。约等于引用等价性。\nequals()和hashCode()\n所以，对可变类型，实现行为等价性即可，也就是说，只有指向同样内存空间的对象才是相等的。所以对可变类型来说，无需重写这两个函数，直接继承Object的equals()和hashCode()即可。\n5.装箱及其等价性\n 在使用集合类时，我们前面也提到过，会进行隐式的装箱操作。因此，装箱完毕后，如果是两个不同对象，即使是整数的装箱，使用“==”进行判断也会返回false，要进行equals的覆写。\n 但是下面有一个特例，那就是如果是-128到127之间的整数，进行两次装箱操作，那得到的地址是一样的(得益于java的缓存机制)。当然，上面也是要求只装箱，不能为两次new的操作，不然肯定地址值不同。\n"
  },
  {
    "head": "HIT软件构造lab3心得",
    "paragraphs": [
      "1实验目标概述",
      "本次实验覆盖课程第 2、3 章的内容，目标是编写具有可复用性和可维护性",
      "的软件，主要使用以下软件构造技术：",
      "子类型、泛型、多态、重写、重载",
      "继承、代理、组合",
      "语法驱动的编程、正则表达式",
      "API 设计、API 复用",
      "本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学",
      "课表管理），学生不是直接针对每个应用分别编程实现，而是通过 ADT 和泛型等",
      "抽象技术，开发一套可复用的 ADT 及其实现，充分考虑这些应用之间的相似性",
      "和差异性，使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可",
      "维护性）。",
      "2实验环境配置",
      "Eclipse与git",
      "在这里给出你的GitHub Lab3仓库的URL地址（HIT-Lab3-学号）。",
      "https://github.com/ComputerScienceHIT/HIT-Lab3-1190202013",
      "3实验过程",
      "请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。",
      "3.1待开发的三个应用场景",
      "3.1.1值班表管理",
      "要求：1、每天只有一个员工值班；",
      "2、不能出现某天无人值班的情况；",
      "3、任意两个员工值班时间不能重叠；",
      "4、记录员工值班日期、名字、职位、手机号码；",
      "3.1.2操作系统进程调度管理",
      "要求：1、同一个进程可以在多个不同时间段内多次执行；",
      "2、多个进程执行时的时间段不可重叠；",
      "3、在特定时刻，时间轴上没有进程在执行，即“闲置”；",
      "4、操作系统对进程调度是随机的；",
      "3.1.3大学课表管理",
      "要求：1、课表中有多个课程排课；",
      "2、同一时间段可以有不同的课程（学生选课不同）",
      "3、同一课程每周可以出现一次，也可以安排多次；",
      "4、课表中允许有空白时间段（未安排任何课程）；",
      "5、同一课程由同一位老师在同一教室进行；",
      "6、一位老师可以承担课表中的多门课程；",
      "7、课表具有周期性（T=7days）；",
      "三个应用的共性与差异：",
      "三个APP均与时间段有关，值班表要求一人只能对应一个时间段，进程与课表管理要求一个对象课可以对应多个时间段。在值班表和进程中，要求各个时间段不能重叠，而课表允许有重叠。在值班表中要求不能有空白的时间段，课表必须具有周期行等等。",
      "3.2面向可复用性和可维护性的设计：IntervalSet",
      "该节是本实验的核心部分。",
      "3.2.1IntervalSet的共性操作",
      "1、IntervalSet empty()：创建一个空对象，返回创建的空对象；",
      "2、void insert(long start, long end, L label)：插入新时间段，start,end分别表示开始时间和结束时间，label是时间段标签，当存在此标签或者时间段被占用时输出异常；",
      "3、Set labels()：获得当前对象中标签集合",
      "4、boolean remove(L label)：从当前对象中移除某个标签label所关联的标签，若集合中没有找到指定标签则返回false，否则返回true，即成功移除；",
      "5、long start(L label):返回标签label对应时间段的开始时间",
      "6、long end(L label)：返回标签label对应时间段的结束时间",
      "7、boolean checkLegal() ;检查当前程序的合法性",
      "8、void clear():清空当前时间段集合中的所有时间段",
      "9、读取时间段集合链表 LinkedList<Interval> readIntervalSet();",
      "3.2.2局部共性特征的设计方案",
      "采用报告3.4.2中的方案6使用decorator模式进行局部共性特征设计方案。 定义一个装饰器抽象类Decorator继承自IntervalSet接口",
      "下面设立多个子类分别继承自Decorator抽象类。三个局部共性特征为",
      "1、是否允许时间重叠",
      "2、是否允许时间段中有空隙",
      "3、是否允许时间循环呈周期变化",
      "可以看出这三个特征的区别在于插入方法和检查程序合法性两个方法上，因此在子类中分别对这两个函数进行重写即可",
      "3.2.3面向各应用的IntervalSet子类型设计（个性化特征的设计方案）",
      "由于在值班表管理中要求n名员工的值班时间段必须相连，无空白时间段，所以DutyIntervalSet与之前设计的不允许时间冲突和不允许各个时间段中有空白时间段，和之前实现的子类功能高度重合，因此直接继承即可。",
      "noGapIntervalSet中增加了判断某个时间段中是否有循环或者空白时间段的方法boolean checkLegal()。该方法中将时间段集合链表LinkedList<Interval>中的时间段依次遍历，如果出现了当前遍历时间段开始时间大于上一个时间段的结束时间的情况，说明有空白，返回false，否则返回true。",
      "noOverlappingIntervalSet通过对insert函数进行重写，保证原集合内时间段之间不发生重叠。在每次加入新时间段时，判断新加入时间段与集合中原有所有时间段的位置关系。如果出现重合，则输出异常，否则可以加入原集合。",
      "3.3面向可复用性和可维护性的设计：MultiIntervalSet",
      "3.3.1MultiIntervalSet的共性操作",
      "1、IntervalSet empty()：创建一个空对象，empty()或不带任何参数的构造函数 ，返回创建的空对象",
      "2、MultiIntervalSet(IntervalSet initial)：创建一个非空对象，利用initial中包含的数据创建非空对象，返回创建的非空对象",
      "3、void insert(long start, long end, L label):在当前对象中插入新的时间段和标签;",
      "4、Set labels():获得当前对象中的标签集合：",
      "5、boolean remove(L label):从当前对象中移除某个标签所关联的所有时间段",
      "6、IntervalSetintervals(L label):从当前对象中获取与某个标签所关联的所有时间段：，返回结果表达为IntervalSet的形式，其中的时间段按开始时间从小到大的次序排列。",
      "7、getMap():返回当前的时间段集合",
      "8、boolean checkLegal():检查合法性",
      "9、清空当前的时间段集合",
      "3.3.2局部共性特征的设计方案",
      "针对multiIntervalSet同样面临着是否允许空隙，是否允许时间冲突，是否允许周期循环的三个问题，同样采用方案6的装饰器设计模式，重写multiIntervalSet的insert方法和checkLegal方法，设计出不同功能的子类。",
      "3.3.3面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）",
      "面对进程调度的应用设计一个ProcessIntervalSet，这个个性化特征为可以有空隙，但是时间不允许重叠，因此这个类继承自上面实现的无周期，不重叠，可以有间隙的装饰子类，因为需要设计成可视化，所以在这个子类中增加两个show方法，可以查看当前所有的进程调度，也可以查看单独的进程被调度的情况。 面对课程表安排的应用设计一个CourseIntervalSet类，由于插入课程时希望通过星期 几和开始上课的时间进行插入，因此在这个子类中需要增加能够将周数和开始上课的时间对应成时间段的开始时间和结束时间的方法，同时，这个课程表也需要可视化读入，所以增加一个获得具体星期的课表的方法。",
      "3.4面向复用的设计：L",
      "所有的ADT都采用泛型L，L必须是immutable类型的变量。如针对每个应用设计的类Employee、Process、Course等",
      "3.5可复用API设计",
      "将方法写在单独的APIs.java中，采用委派方式",
      "3.5.1计算相似度",
      "针对multiIntervalSet的计算相似度的方法，可以计算两个时间段集合的相似度。两个时间段集合的相似度是通过相似时间/总时间计算的，而相似时间则要求时间段和标签完全一样的时候才叫有效的相似时间。 维护两个IntervalSet，标签使用Integer类型，然后将multi的时间段集合 转换成普通的时间段集合，这样将每个时间段按照开始时间的先后顺序插入其中。这样还可以顺便计算出来两个时间段集合的最长持续时间是多少。然后通过for循环，遍历两个时间段集合的每个时间段，统计有效时间，由此计算出相似度结果。",
      "首先分析相似度的计算：",
      "我们以实验指导的例子为例：",
      "首先我们可以得出对于第一个MultiIntervalSet中标签A，其对应的区域有两个地方[0,5)和[20，25)，而在第二个MultiIntervalSet中标签A，其对应的区域有一个为[20,35)，而由于不同标签的相似度，只存在于相同的标签对应的时间段，因此我们可以计算出相似度。Similar ratio = 15/35=0.42857。 在介绍方法前，首先简述求相似度的辅助函数：",
      "1.public static long getStartTimerShaft(MultiIntervalSet s) 获得MultiIntervalSet的最早的时间",
      "2.public static long getEndTimeShaft(MultiIntervalSet s) 获得MultiIntervalSet的最晚的时间",
      "3.public static double intervalLength(Set s1) 计算s1中的所有时间段的时间的长度",
      "4.public static Set similarIntervals(IntervalSet s1, IntervalSet s2) 求s1与s2的重合时间段，其中参数为由MultiIntervalSet的label对应的多个Interval构成的Interval， Integer为从小到大的顺序。",
      "3.5.2计算时间冲突比例",
      "时间冲突比例应为计算一个MultiIntervalSet类型中所有labels对应的时间段存在重叠的部分。 首先将所有的label映射到Boolean类型，即可认为当前是否已经遍历过该标签。初始化时候，将label对应的Boolean都设置为false。 在循环MultiIntervalSet中所有标签时，依次将每一个设置为true，表示遍历完成。通过双层循环实现对label的遍历，在遍历一个标签时，若发现另一个标签与其相同或已访问过，则跳过，否则通过调用simlarIntervals函数和intervals函数，检查label标签对应的时间段与待检查标签中是否有相同的部分，若有，则累加，即为冲突时间。 总时间通过对每一个label对应时间段求和即可得。 冲突事件/总时间即为时间冲突比例。",
      "3.5.3计算空闲时间比例",
      "首先通过3.5.1中叙述的getStartTimerShaft(MultiIntervalSET)函数，获得MultiIntervalSet的最早的时间点，再通过getEndTimerShaft(MultiIntervalSET)函数，即可获得MultiIntervalSet的最晚的时间点。 此时即可计算总的时间。 首先将开头时间和结束时间放入Set中，即可得到此时对应的Interval的集合，开始时候，只有一个Interval，代表从头到结尾。 通过对MultiIntervalSet中的labels遍历，依次得到每个label对应的时间段。 当得到每个时间段后，将Set中的包含当前label对应的时间段的时间段拆分成，不包括不包括label的时间段的部分，并将原Interval删除，将新拆分的Intervals放入Set中，最后调用intervalLength函数，即可计算Set中的时间间隔的总长度。 通过空闲时间/总时间即可计算出空闲时间比例。",
      "3.6应用设计与开发",
      "利用上述设计和实现的ADT，实现手册里要求的各项功能。",
      "3.6.1排班管理系统",
      "针对排班管理系统，所需完成的功能为：",
      "Step 1 设定排班开始日期、结束日期，具体到年月日即可。",
      "Step 2 增加一组员工，包括他们各自的姓名、职务、手机号码，并可随时删除某些员工。如果某个员工已经被编排进排班表，那么他不能被删除，必须将其排班信息删掉之后才能删除该员工。员工信息一旦设定则无法修改。",
      "Step 3 可手工选择某个员工、某个时间段（以“日”为单位，最小1天，可以是多天），向排班表增加一条排班记录，该步骤可重复执行多次。在该过程中，用户可随时检查当前排班是否已满（即所有时间段都已被安排了特定员工值班）、若未满，则展示给用户哪些时间段未安排、未安排的时间段占总时间段的比例。",
      "Step 4 除了上一步骤中手工安排，也可采用自动编排的方法，随机生成排班表。 Step 5 可视化展示任意时刻的排班表。可视化要直观明了，可自行设计。 其中step4的自动编排方法秉持着平均的原则，计算出一共要安排多少天，然后用天数除以员工数量，再最后处理剩余的没有安排上的部分，从而完成自动的安排。 如果在自动安排之前已经手动插入了一些安排，那么就清空列表后再进行自动编排",
      "3.6.2操作系统的进程调度管理系统",
      "针对操作系统的进程调度管理系统，所需完成的功能为：",
      "Step 1 增加一组进程，输入每个进程的ID、名称、最短执行时间、最长执行时间；进程一旦设定无法再修改其信息。",
      "Step 2 当前时刻（设定为0）启动模拟调度，随机选择某个尚未执行结束的进程在CPU上执行（执行过程中其他进程不能被执行），并在该进程最大时间之前的任意时刻停止执行，如果本次及其之前的累积执行时间已落到[最短执行时间，最长执行时间]的区间内，则该进程被设定为“执行结束”。重复上述过程，直到所有进程都达到“执行结束”状态。在每次选择时，也可“不执行任何进程”，并在后续随机选定的时间点再次进行进程选择。",
      "Step 3 上一步骤是“随机选择进程”的模拟策略，还可以实现“最短进程优先”的模拟策略：每次选择进程的时候，优先选择距离其最大执行时间差距最小的进程。",
      "Step 4 可视化展示当前时刻之前的进程调度结果，以及当前时刻正在执行的进程。可视化的形式要直观明了，可自行设计。 添加一组进程后，可以启动系统模拟进程调度。进程调度有两种调度策略，一个是随机调度，一个是最短进程优先策略。在这里都采取随机数的方式进行随机调度，同时加入无进程的情况。 在随机进程选择中采用平均随机，即每次从未完成的进程中选择一个，并执行随机数的时间，然后进行下一次随机选择进程，直到所有进程都达到执行时间为止。而最短进程优先策略则增加随机数的产生范围，多余的随机数都指向最短时间的进程，这样最短时间的进程就会被更容易调度。",
      "欢迎界面",
      "输入1",
      "功能为添加进程。",
      "输入2",
      "输入5",
      "3.6.3课表管理系统",
      "针对课表管理系统，所需完成的功能为：",
      "Step 1 设定学期开始日期（年月日）和总周数（例如18）；",
      "Step 2 增加一组课程，每门课程的信息包括：课程ID、课程名称、教师名字、地点、周学时数（偶数）；",
      "Step 3 手工选择某个课程、上课时间（只能是8-10时、10-12时、13-15时、15-17时、19-21时），为其安排一次课，每次课的时间长度为2小时；可重复安排，直到达到周学时数目时该课程不能再安排；",
      "Step 4 上步骤过程中，随时可查看哪些课程没安排、当前每周的空闲时间比例、重复时间比例；",
      "Step 5 因为课程是周期性的，用户可查看本学期内任意一天的课表结果。 每次课的时间长度为2小时，且只有固定的几个时间段可以上课，因此可以根据星期几和上课的开始时间确定唯一的上课时间，在此通过一个转换即可做到。将weekday*24再加上开始上课的时间，就能确定唯一的上课时间。",
      "简要分析，我们需要一个一个标签对应多个时间段的数据类型，因此选择MultiIntervalSet类型。",
      "CourseScheduleApp运行如下：",
      "课表目录",
      "更新课表信息",
      "添加课程",
      "设置课程上课时间",
      "查看未安排的课程",
      "查看设置完成的课程",
      "3.7基于语法的数据读入",
      "修改“排班管理”应用以扩展该功能。",
      "该模块主要采用正则表达式处理从文件中读入的字符串。 根据提供的文件的格式确定正则表达式，然后通过正则表达式的语法获取每一行的信息。",
      "用每一个正则表达式去匹配每一行，如果匹配上了就获取相应的信息进行处理即可。",
      "在匹配确认格式匹配后，将所读入的内容转化为值班表。 具体运行结果如下： 当读入test1.txt时，具体运行结果如下所示：",
      "3.8应对面临的新变化",
      "3.8.1变化1",
      "代价并不大。只需将值班表中使用的没有空时间段改为允许有空隙，并修改查看排版信息的遍历时所用到的intervalset中的函数（start,end），变为multi-intervalset中的函数（intervals）即可。",
      "同时，由于一个员工可以占据多段时间，随机排班的功能也需要进行修改。新的排版方式是对每一天进行遍历，每一天都随机选择一个员工。",
      "3.8.2变化2",
      "代价很小。只需要再套一层NoOverlapIntervalSet的装饰器就足以应对变化。",
      "3.9Git仓库结构",
      "请在完成全部实验要求之后，利用Git log指令或Git图形化客户端或GitHub上项目仓库的Insight页面，给出你的仓库到目前为止的Object Graph，尤其是区分清楚change分支和master分支所指向的位置。",
      "4实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。",
      "不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。",
      "日期 时间段 计划任务 实际完成情况",
      "2021.06.27 10:00-20:00 完成IntervalSet接口和CommonIntervalSet实例 按时完成",
      "2021.06.28 13:00-15:00 重构CommonIntervalSet代码 按时完成",
      "2021.06.28 16：00-19：00 完成MultiIntervalSet接口和Common实例 未完成",
      "2021.06.28 21：00-23：00 完成MultiIntervalSet接口和Common实例 按时完成",
      "2021.06.29 9：00-13：00 完成dutyIntervalSet设计和值班表app 未完成",
      "2021.06.29 15：00-19：00 完成dutyIntervalSet设计和值班表app 按时完成",
      "2021.06.30 7：00-13：00 完成装饰类的书写 按时完成",
      "2021.06.30 15：00-23：00 完成具体类的书写并实现进程调度 按时完成",
      "2021.07.01 7：00-15：00 完成课程表安排和APIs类 按时完成",
      "2021.07.02 7：00-16：00 完成应对变化及代价 按时完成",
      "2021.07.03 7：00-18;00 完成报告 按时完成",
      "5实验过程中遇到的困难与解决途径",
      "遇到的难点 解决途径",
      "产生随机数不会",
      "网络搜索",
      "如何对日期进行处理",
      "网络搜索，了解了Date等方法可以进行日期运算",
      "6实验过程中收获的经验、教训、感想",
      "6.1实验过程中收获的经验和教训",
      "对代码复用的体会更加深刻了",
      "6.2针对以下方面的感受",
      "(1)重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用，你是否体会到复用的好处？",
      "复用在一定程度上增加了代码的难度，但另一方面复用大量的减少了代码量。复用更考察了抽象能力，将不同的场景的共同点抽象成抽象ADT。",
      "(2)重新思考Lab2中的问题：为ADT撰写复杂的specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？",
      "保证了正确性与安全性，并将一直坚持。",
      "(3)之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？",
      "开发API难处体会比较深刻，乐趣没有难处深刻。",
      "(4)你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？",
      "匹配过程更加实用。",
      "(5)Lab1和Lab2的工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过三周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？",
      "抽象出相同的地方，勤于思考。",
      "(6)“抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的三个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、委派、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？",
      "先写接口考虑好应用场景，并写测试，进而不断完善代码。",
      "(7)关于本实验的工作量、难度、deadline。",
      "工作量过大、难度过大、deadline过紧。",
      "(8)下周就要进行考试了，你对《软件构造》课程总体评价如何？",
      "对我编程起到了很大的作用，让我了解到如何编出更好的代码。"
    ],
    "sentences": [
      "1实验目标概述",
      "本次实验覆盖课程第 2、3 章的内容",
      "目标是编写具有可复用性和可维护性",
      "的软件",
      "主要使用以下软件构造技术：子类型、泛型、多态、重写、重载",
      "继承、代理、组合",
      "语法驱动的编程、正则表达式",
      "API 设计、API 复用",
      "本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学",
      "课表管理）",
      "学生不是直接针对每个应用分别编程实现",
      "而是通过 ADT 和泛型等",
      "抽象技术",
      "开发一套可复用的 ADT 及其实现",
      "充分考虑这些应用之间的相似性",
      "和差异性",
      "使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可",
      "维护性）",
      "2实验环境配置",
      "Eclipse与git",
      "在这里给出你的GitHub Lab3仓库的URL地址（HIT-Lab3-学号）",
      "https://github.com/ComputerScienceHIT/HIT-Lab3-1190202013",
      "3实验过程",
      "请仔细对照实验手册",
      "针对每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）",
      "3.1待开发的三个应用场景",
      "3.1.1值班表管理",
      "要求：1、每天只有一个员工值班；2、不能出现某天无人值班的情况；3、任意两个员工值班时间不能重叠；4、记录员工值班日期、名字、职位、手机号码；3.1.2操作系统进程调度管理",
      "要求：1、同一个进程可以在多个不同时间段内多次执行；2、多个进程执行时的时间段不可重叠；3、在特定时刻",
      "时间轴上没有进程在执行",
      "即“闲置”；4、操作系统对进程调度是随机的；3.1.3大学课表管理",
      "要求：1、课表中有多个课程排课；2、同一时间段可以有不同的课程（学生选课不同）",
      "3、同一课程每周可以出现一次",
      "也可以安排多次；4、课表中允许有空白时间段（未安排任何课程）；5、同一课程由同一位老师在同一教室进行；6、一位老师可以承担课表中的多门课程；7、课表具有周期性（T=7days）；三个应用的共性与差异：三个APP均与时间段有关",
      "值班表要求一人只能对应一个时间段",
      "进程与课表管理要求一个对象课可以对应多个时间段",
      "在值班表和进程中，要求各个时间段不能重叠，而课表允许有重叠",
      "在值班表中要求不能有空白的时间段，课表必须具有周期行等等",
      "3.2面向可复用性和可维护性的设计：IntervalSet",
      "该节是本实验的核心部分",
      "3.2.1IntervalSet的共性操作",
      "1、IntervalSet empty()：创建一个空对象",
      "返回创建的空对象；2、void insert(long start, long end, L label)：插入新时间段",
      "start,end分别表示开始时间和结束时间",
      "label是时间段标签",
      "当存在此标签或者时间段被占用时输出异常；3、Set labels()：获得当前对象中标签集合",
      "4、boolean remove(L label)：从当前对象中移除某个标签label所关联的标签",
      "若集合中没有找到指定标签则返回false",
      "否则返回true",
      "即成功移除；5、long start(L label):返回标签label对应时间段的开始时间",
      "6、long end(L label)：返回标签label对应时间段的结束时间",
      "7、boolean checkLegal() ;检查当前程序的合法性",
      "8、void clear():清空当前时间段集合中的所有时间段",
      "9、读取时间段集合链表 LinkedList<Interval> readIntervalSet();3.2.2局部共性特征的设计方案",
      "采用报告3.4.2中的方案6使用decorator模式进行局部共性特征设计方案",
      " 定义一个装饰器抽象类Decorator继承自IntervalSet接口",
      "下面设立多个子类分别继承自Decorator抽象类",
      "三个局部共性特征为",
      "1、是否允许时间重叠",
      "2、是否允许时间段中有空隙",
      "3、是否允许时间循环呈周期变化",
      "可以看出这三个特征的区别在于插入方法和检查程序合法性两个方法上",
      "因此在子类中分别对这两个函数进行重写即可",
      "3.2.3面向各应用的IntervalSet子类型设计（个性化特征的设计方案）",
      "由于在值班表管理中要求n名员工的值班时间段必须相连",
      "无空白时间段",
      "所以DutyIntervalSet与之前设计的不允许时间冲突和不允许各个时间段中有空白时间段",
      "和之前实现的子类功能高度重合",
      "因此直接继承即可",
      "noGapIntervalSet中增加了判断某个时间段中是否有循环或者空白时间段的方法boolean checkLegal()",
      "该方法中将时间段集合链表LinkedList<Interval>中的时间段依次遍历",
      "如果出现了当前遍历时间段开始时间大于上一个时间段的结束时间的情况",
      "说明有空白",
      "返回false",
      "否则返回true",
      "noOverlappingIntervalSet通过对insert函数进行重写",
      "保证原集合内时间段之间不发生重叠",
      "在每次加入新时间段时",
      "判断新加入时间段与集合中原有所有时间段的位置关系",
      "如果出现重合，则输出异常，否则可以加入原集合",
      "3.3面向可复用性和可维护性的设计：MultiIntervalSet",
      "3.3.1MultiIntervalSet的共性操作",
      "1、IntervalSet empty()：创建一个空对象",
      "empty()或不带任何参数的构造函数 ",
      "返回创建的空对象",
      "2、MultiIntervalSet(IntervalSet initial)：创建一个非空对象",
      "利用initial中包含的数据创建非空对象",
      "返回创建的非空对象",
      "3、void insert(long start, long end, L label):在当前对象中插入新的时间段和标签;4、Set labels():获得当前对象中的标签集合：5、boolean remove(L label):从当前对象中移除某个标签所关联的所有时间段",
      "6、IntervalSetintervals(L label):从当前对象中获取与某个标签所关联的所有时间段：",
      "返回结果表达为IntervalSet的形式",
      "其中的时间段按开始时间从小到大的次序排列",
      "7、getMap():返回当前的时间段集合",
      "8、boolean checkLegal():检查合法性",
      "9、清空当前的时间段集合",
      "3.3.2局部共性特征的设计方案",
      "针对multiIntervalSet同样面临着是否允许空隙",
      "是否允许时间冲突",
      "是否允许周期循环的三个问题",
      "同样采用方案6的装饰器设计模式",
      "重写multiIntervalSet的insert方法和checkLegal方法",
      "设计出不同功能的子类",
      "3.3.3面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）",
      "面对进程调度的应用设计一个ProcessIntervalSet",
      "这个个性化特征为可以有空隙",
      "但是时间不允许重叠",
      "因此这个类继承自上面实现的无周期",
      "不重叠",
      "可以有间隙的装饰子类",
      "因为需要设计成可视化",
      "所以在这个子类中增加两个show方法",
      "可以查看当前所有的进程调度",
      "也可以查看单独的进程被调度的情况",
      " 面对课程表安排的应用设计一个CourseIntervalSet类",
      "由于插入课程时希望通过星期 几和开始上课的时间进行插入",
      "因此在这个子类中需要增加能够将周数和开始上课的时间对应成时间段的开始时间和结束时间的方法",
      "同时",
      "这个课程表也需要可视化读入",
      "所以增加一个获得具体星期的课表的方法",
      "3.4面向复用的设计：L",
      "所有的ADT都采用泛型L",
      "L必须是immutable类型的变量",
      "如针对每个应用设计的类Employee、Process、Course等",
      "3.5可复用API设计",
      "将方法写在单独的APIs.java中，采用委派方式",
      "3.5.1计算相似度",
      "针对multiIntervalSet的计算相似度的方法",
      "可以计算两个时间段集合的相似度",
      "两个时间段集合的相似度是通过相似时间/总时间计算的",
      "而相似时间则要求时间段和标签完全一样的时候才叫有效的相似时间",
      " 维护两个IntervalSet",
      "标签使用Integer类型",
      "然后将multi的时间段集合 转换成普通的时间段集合",
      "这样将每个时间段按照开始时间的先后顺序插入其中",
      "这样还可以顺便计算出来两个时间段集合的最长持续时间是多少",
      "然后通过for循环",
      "遍历两个时间段集合的每个时间段",
      "统计有效时间",
      "由此计算出相似度结果",
      "首先分析相似度的计算：我们以实验指导的例子为例：首先我们可以得出对于第一个MultiIntervalSet中标签A",
      "其对应的区域有两个地方[0,5)和[20",
      "25)",
      "而在第二个MultiIntervalSet中标签A",
      "其对应的区域有一个为[20,35)",
      "而由于不同标签的相似度",
      "只存在于相同的标签对应的时间段",
      "因此我们可以计算出相似度",
      "Similar ratio = 15/35=0.42857",
      " 在介绍方法前",
      "首先简述求相似度的辅助函数：1.public static long getStartTimerShaft(MultiIntervalSet s) 获得MultiIntervalSet的最早的时间",
      "2.public static long getEndTimeShaft(MultiIntervalSet s) 获得MultiIntervalSet的最晚的时间",
      "3.public static double intervalLength(Set s1) 计算s1中的所有时间段的时间的长度",
      "4.public static Set similarIntervals(IntervalSet s1, IntervalSet s2) 求s1与s2的重合时间段",
      "其中参数为由MultiIntervalSet的label对应的多个Interval构成的Interval",
      " Integer为从小到大的顺序",
      "3.5.2计算时间冲突比例",
      "时间冲突比例应为计算一个MultiIntervalSet类型中所有labels对应的时间段存在重叠的部分",
      " 首先将所有的label映射到Boolean类型",
      "即可认为当前是否已经遍历过该标签",
      "初始化时候",
      "将label对应的Boolean都设置为false",
      " 在循环MultiIntervalSet中所有标签时",
      "依次将每一个设置为true",
      "表示遍历完成",
      "通过双层循环实现对label的遍历",
      "在遍历一个标签时",
      "若发现另一个标签与其相同或已访问过",
      "则跳过",
      "否则通过调用simlarIntervals函数和intervals函数",
      "检查label标签对应的时间段与待检查标签中是否有相同的部分",
      "若有",
      "则累加",
      "即为冲突时间",
      " 总时间通过对每一个label对应时间段求和即可得",
      " 冲突事件/总时间即为时间冲突比例",
      "3.5.3计算空闲时间比例",
      "首先通过3.5.1中叙述的getStartTimerShaft(MultiIntervalSET)函数",
      "获得MultiIntervalSet的最早的时间点",
      "再通过getEndTimerShaft(MultiIntervalSET)函数",
      "即可获得MultiIntervalSet的最晚的时间点",
      " 此时即可计算总的时间",
      " 首先将开头时间和结束时间放入Set中",
      "即可得到此时对应的Interval的集合",
      "开始时候",
      "只有一个Interval",
      "代表从头到结尾",
      " 通过对MultiIntervalSet中的labels遍历",
      "依次得到每个label对应的时间段",
      " 当得到每个时间段后",
      "将Set中的包含当前label对应的时间段的时间段拆分成",
      "不包括不包括label的时间段的部分",
      "并将原Interval删除",
      "将新拆分的Intervals放入Set中",
      "最后调用intervalLength函数",
      "即可计算Set中的时间间隔的总长度",
      " 通过空闲时间/总时间即可计算出空闲时间比例",
      "3.6应用设计与开发",
      "利用上述设计和实现的ADT，实现手册里要求的各项功能",
      "3.6.1排班管理系统",
      "针对排班管理系统",
      "所需完成的功能为：Step 1 设定排班开始日期、结束日期",
      "具体到年月日即可",
      "Step 2 增加一组员工",
      "包括他们各自的姓名、职务、手机号码",
      "并可随时删除某些员工",
      "如果某个员工已经被编排进排班表",
      "那么他不能被删除",
      "必须将其排班信息删掉之后才能删除该员工",
      "员工信息一旦设定则无法修改",
      "Step 3 可手工选择某个员工、某个时间段（以“日”为单位",
      "最小1天",
      "可以是多天）",
      "向排班表增加一条排班记录",
      "该步骤可重复执行多次",
      "在该过程中",
      "用户可随时检查当前排班是否已满（即所有时间段都已被安排了特定员工值班）、若未满",
      "则展示给用户哪些时间段未安排、未安排的时间段占总时间段的比例",
      "Step 4 除了上一步骤中手工安排",
      "也可采用自动编排的方法",
      "随机生成排班表",
      " Step 5 可视化展示任意时刻的排班表",
      "可视化要直观明了，可自行设计",
      " 其中step4的自动编排方法秉持着平均的原则",
      "计算出一共要安排多少天",
      "然后用天数除以员工数量",
      "再最后处理剩余的没有安排上的部分",
      "从而完成自动的安排",
      " 如果在自动安排之前已经手动插入了一些安排",
      "那么就清空列表后再进行自动编排",
      "3.6.2操作系统的进程调度管理系统",
      "针对操作系统的进程调度管理系统",
      "所需完成的功能为：Step 1 增加一组进程",
      "输入每个进程的ID、名称、最短执行时间、最长执行时间；进程一旦设定无法再修改其信息",
      "Step 2 当前时刻（设定为0）启动模拟调度",
      "随机选择某个尚未执行结束的进程在CPU上执行（执行过程中其他进程不能被执行）",
      "并在该进程最大时间之前的任意时刻停止执行",
      "如果本次及其之前的累积执行时间已落到[最短执行时间",
      "最长执行时间]的区间内",
      "则该进程被设定为“执行结束”",
      "重复上述过程，直到所有进程都达到“执行结束”状态",
      "在每次选择时",
      "也可“不执行任何进程”",
      "并在后续随机选定的时间点再次进行进程选择",
      "Step 3 上一步骤是“随机选择进程”的模拟策略",
      "还可以实现“最短进程优先”的模拟策略：每次选择进程的时候",
      "优先选择距离其最大执行时间差距最小的进程",
      "Step 4 可视化展示当前时刻之前的进程调度结果",
      "以及当前时刻正在执行的进程",
      "可视化的形式要直观明了，可自行设计",
      " 添加一组进程后，可以启动系统模拟进程调度",
      "进程调度有两种调度策略",
      "一个是随机调度",
      "一个是最短进程优先策略",
      "在这里都采取随机数的方式进行随机调度，同时加入无进程的情况",
      " 在随机进程选择中采用平均随机",
      "即每次从未完成的进程中选择一个",
      "并执行随机数的时间",
      "然后进行下一次随机选择进程",
      "直到所有进程都达到执行时间为止",
      "而最短进程优先策略则增加随机数的产生范围",
      "多余的随机数都指向最短时间的进程",
      "这样最短时间的进程就会被更容易调度",
      "欢迎界面",
      "输入1",
      "功能为添加进程",
      "输入2",
      "输入5",
      "3.6.3课表管理系统",
      "针对课表管理系统",
      "所需完成的功能为：Step 1 设定学期开始日期（年月日）和总周数（例如18）；Step 2 增加一组课程",
      "每门课程的信息包括：课程ID、课程名称、教师名字、地点、周学时数（偶数）；Step 3 手工选择某个课程、上课时间（只能是8-10时、10-12时、13-15时、15-17时、19-21时）",
      "为其安排一次课",
      "每次课的时间长度为2小时；可重复安排",
      "直到达到周学时数目时该课程不能再安排；Step 4 上步骤过程中",
      "随时可查看哪些课程没安排、当前每周的空闲时间比例、重复时间比例；Step 5 因为课程是周期性的",
      "用户可查看本学期内任意一天的课表结果",
      " 每次课的时间长度为2小时",
      "且只有固定的几个时间段可以上课",
      "因此可以根据星期几和上课的开始时间确定唯一的上课时间",
      "在此通过一个转换即可做到",
      "将weekday*24再加上开始上课的时间",
      "就能确定唯一的上课时间",
      "简要分析",
      "我们需要一个一个标签对应多个时间段的数据类型",
      "因此选择MultiIntervalSet类型",
      "CourseScheduleApp运行如下：课表目录",
      "更新课表信息",
      "添加课程",
      "设置课程上课时间",
      "查看未安排的课程",
      "查看设置完成的课程",
      "3.7基于语法的数据读入",
      "修改“排班管理”应用以扩展该功能",
      "该模块主要采用正则表达式处理从文件中读入的字符串",
      " 根据提供的文件的格式确定正则表达式",
      "然后通过正则表达式的语法获取每一行的信息",
      "用每一个正则表达式去匹配每一行",
      "如果匹配上了就获取相应的信息进行处理即可",
      "在匹配确认格式匹配后，将所读入的内容转化为值班表",
      " 具体运行结果如下： 当读入test1.txt时",
      "具体运行结果如下所示：3.8应对面临的新变化",
      "3.8.1变化1",
      "代价并不大",
      "只需将值班表中使用的没有空时间段改为允许有空隙",
      "并修改查看排版信息的遍历时所用到的intervalset中的函数（start,end）",
      "变为multi-intervalset中的函数（intervals）即可",
      "同时",
      "由于一个员工可以占据多段时间",
      "随机排班的功能也需要进行修改",
      "新的排版方式是对每一天进行遍历，每一天都随机选择一个员工",
      "3.8.2变化2",
      "代价很小",
      "只需要再套一层NoOverlapIntervalSet的装饰器就足以应对变化",
      "3.9Git仓库结构",
      "请在完成全部实验要求之后",
      "利用Git log指令或Git图形化客户端或GitHub上项目仓库的Insight页面",
      "给出你的仓库到目前为止的Object Graph",
      "尤其是区分清楚change分支和master分支所指向的位置",
      "4实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "每次结束编程时，请向该表格中增加一行",
      "不要事后胡乱填写",
      "不要嫌烦",
      "该表格可帮助你汇总你在每个任务上付出的时间和精力",
      "发现自己不擅长的任务",
      "后续有意识的弥补",
      "日期 时间段 计划任务 实际完成情况",
      "2021.06.27 10:00-20:00 完成IntervalSet接口和CommonIntervalSet实例 按时完成",
      "2021.06.28 13:00-15:00 重构CommonIntervalSet代码 按时完成",
      "2021.06.28 16：00-19：00 完成MultiIntervalSet接口和Common实例 未完成",
      "2021.06.28 21：00-23：00 完成MultiIntervalSet接口和Common实例 按时完成",
      "2021.06.29 9：00-13：00 完成dutyIntervalSet设计和值班表app 未完成",
      "2021.06.29 15：00-19：00 完成dutyIntervalSet设计和值班表app 按时完成",
      "2021.06.30 7：00-13：00 完成装饰类的书写 按时完成",
      "2021.06.30 15：00-23：00 完成具体类的书写并实现进程调度 按时完成",
      "2021.07.01 7：00-15：00 完成课程表安排和APIs类 按时完成",
      "2021.07.02 7：00-16：00 完成应对变化及代价 按时完成",
      "2021.07.03 7：00-18;00 完成报告 按时完成",
      "5实验过程中遇到的困难与解决途径",
      "遇到的难点 解决途径",
      "产生随机数不会",
      "网络搜索",
      "如何对日期进行处理",
      "网络搜索，了解了Date等方法可以进行日期运算",
      "6实验过程中收获的经验、教训、感想",
      "6.1实验过程中收获的经验和教训",
      "对代码复用的体会更加深刻了",
      "6.2针对以下方面的感受",
      "(1)重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程",
      "你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用",
      "你是否体会到复用的好处？",
      "复用在一定程度上增加了代码的难度",
      "但另一方面复用大量的减少了代码量",
      "复用更考察了抽象能力，将不同的场景的共同点抽象成抽象ADT",
      "(2)重新思考Lab2中的问题：为ADT撰写复杂的specification, invariants, RI, AF",
      "时刻注意ADT是否有rep exposure",
      "这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？",
      "保证了正确性与安全性，并将一直坚持",
      "(3)之前你将别人提供的API用于自己的程序开发中",
      "本次实验你尝试着开发给别人使用的API",
      "是否能够体会到其中的难处和乐趣？",
      "开发API难处体会比较深刻，乐趣没有难处深刻",
      "(4)你之前在使用其他软件时",
      "应该体会过输入各种命令向系统发出指令",
      "本次实验你开发了一个解析器",
      "使用语法和正则表达式去解析输入文件并据此构造对象",
      "你对语法驱动编程有何感受？",
      "匹配过程更加实用",
      "(5)Lab1和Lab2的工作都不是从0开始",
      "而是基于他人给出的设计方案和初始代码",
      "本次实验是你完全从0开始进行ADT的设计并用OOP实现",
      "经过三周之后",
      "你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？",
      "抽象出相同的地方，勤于思考",
      "(6)“抽象”是计算机科学的核心概念之一",
      "也是ADT和OOP的精髓所在",
      "本实验的三个应用既不能完全抽象为同一个ADT",
      "也不是完全个性化",
      "如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、委派、设计模式等技术完成最大程度的抽象和复用",
      "你有什么经验教训？",
      "先写接口考虑好应用场景，并写测试，进而不断完善代码",
      "(7)关于本实验的工作量、难度、deadline",
      "工作量过大、难度过大、deadline过紧",
      "(8)下周就要进行考试了，你对《软件构造》课程总体评价如何？",
      "对我编程起到了很大的作用，让我了解到如何编出更好的代码"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "1实验目标概述\n本次实验覆盖课程第 2、3 章的内容，目标是编写具有可复用性和可维护性\n的软件，主要使用以下软件构造技术：\n子类型、泛型、多态、重写、重载\n继承、代理、组合\n语法驱动的编程、正则表达式\nAPI 设计、API 复用\n本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学\n课表管理），学生不是直接针对每个应用分别编程实现，而是通过 ADT 和泛型等\n抽象技术，开发一套可复用的 ADT 及其实现，充分考虑这些应用之间的相似性\n和差异性，使 ADT 有更大程度的复用（可复用性）和更容易面向各种变化（可\n维护性）。\n2实验环境配置\nEclipse与git\n在这里给出你的GitHub Lab3仓库的URL地址（HIT-Lab3-学号）。\nhttps://github.com/ComputerScienceHIT/HIT-Lab3-1190202013\n3实验过程\n请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\n3.1待开发的三个应用场景\n3.1.1值班表管理\n要求：1、每天只有一个员工值班；\n2、不能出现某天无人值班的情况；\n3、任意两个员工值班时间不能重叠；\n4、记录员工值班日期、名字、职位、手机号码；\n3.1.2操作系统进程调度管理\n要求：1、同一个进程可以在多个不同时间段内多次执行；\n2、多个进程执行时的时间段不可重叠；\n3、在特定时刻，时间轴上没有进程在执行，即“闲置”；\n4、操作系统对进程调度是随机的；\n3.1.3大学课表管理\n要求：1、课表中有多个课程排课；\n2、同一时间段可以有不同的课程（学生选课不同）\n3、同一课程每周可以出现一次，也可以安排多次；\n4、课表中允许有空白时间段（未安排任何课程）；\n5、同一课程由同一位老师在同一教室进行；\n6、一位老师可以承担课表中的多门课程；\n7、课表具有周期性（T=7days）；\n三个应用的共性与差异：\n三个APP均与时间段有关，值班表要求一人只能对应一个时间段，进程与课表管理要求一个对象课可以对应多个时间段。在值班表和进程中，要求各个时间段不能重叠，而课表允许有重叠。在值班表中要求不能有空白的时间段，课表必须具有周期行等等。\n3.2面向可复用性和可维护性的设计：IntervalSet\n该节是本实验的核心部分。\n3.2.1IntervalSet的共性操作\n1、IntervalSet empty()：创建一个空对象，返回创建的空对象；\n2、void insert(long start, long end, L label)：插入新时间段，start,end分别表示开始时间和结束时间，label是时间段标签，当存在此标签或者时间段被占用时输出异常；\n3、Set labels()：获得当前对象中标签集合\n4、boolean remove(L label)：从当前对象中移除某个标签label所关联的标签，若集合中没有找到指定标签则返回false，否则返回true，即成功移除；\n5、long start(L label):返回标签label对应时间段的开始时间\n6、long end(L label)：返回标签label对应时间段的结束时间\n7、boolean checkLegal() ;检查当前程序的合法性\n8、void clear():清空当前时间段集合中的所有时间段\n9、读取时间段集合链表 LinkedList<Interval> readIntervalSet();\n3.2.2局部共性特征的设计方案\n采用报告3.4.2中的方案6使用decorator模式进行局部共性特征设计方案。 定义一个装饰器抽象类Decorator继承自IntervalSet接口\n下面设立多个子类分别继承自Decorator抽象类。三个局部共性特征为\n1、是否允许时间重叠\n2、是否允许时间段中有空隙\n3、是否允许时间循环呈周期变化\n可以看出这三个特征的区别在于插入方法和检查程序合法性两个方法上，因此在子类中分别对这两个函数进行重写即可\n3.2.3面向各应用的IntervalSet子类型设计（个性化特征的设计方案）\n由于在值班表管理中要求n名员工的值班时间段必须相连，无空白时间段，所以DutyIntervalSet与之前设计的不允许时间冲突和不允许各个时间段中有空白时间段，和之前实现的子类功能高度重合，因此直接继承即可。\nnoGapIntervalSet中增加了判断某个时间段中是否有循环或者空白时间段的方法boolean checkLegal()。该方法中将时间段集合链表LinkedList<Interval>中的时间段依次遍历，如果出现了当前遍历时间段开始时间大于上一个时间段的结束时间的情况，说明有空白，返回false，否则返回true。\nnoOverlappingIntervalSet通过对insert函数进行重写，保证原集合内时间段之间不发生重叠。在每次加入新时间段时，判断新加入时间段与集合中原有所有时间段的位置关系。如果出现重合，则输出异常，否则可以加入原集合。\n3.3面向可复用性和可维护性的设计：MultiIntervalSet\n3.3.1MultiIntervalSet的共性操作\n1、IntervalSet empty()：创建一个空对象，empty()或不带任何参数的构造函数 ，返回创建的空对象\n2、MultiIntervalSet(IntervalSet initial)：创建一个非空对象，利用initial中包含的数据创建非空对象，返回创建的非空对象\n3、void insert(long start, long end, L label):在当前对象中插入新的时间段和标签;\n4、Set labels():获得当前对象中的标签集合：\n5、boolean remove(L label):从当前对象中移除某个标签所关联的所有时间段\n6、IntervalSetintervals(L label):从当前对象中获取与某个标签所关联的所有时间段：，返回结果表达为IntervalSet的形式，其中的时间段按开始时间从小到大的次序排列。\n7、getMap():返回当前的时间段集合\n8、boolean checkLegal():检查合法性\n9、清空当前的时间段集合\n3.3.2局部共性特征的设计方案\n针对multiIntervalSet同样面临着是否允许空隙，是否允许时间冲突，是否允许周期循环的三个问题，同样采用方案6的装饰器设计模式，重写multiIntervalSet的insert方法和checkLegal方法，设计出不同功能的子类。\n3.3.3面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）\n面对进程调度的应用设计一个ProcessIntervalSet，这个个性化特征为可以有空隙，但是时间不允许重叠，因此这个类继承自上面实现的无周期，不重叠，可以有间隙的装饰子类，因为需要设计成可视化，所以在这个子类中增加两个show方法，可以查看当前所有的进程调度，也可以查看单独的进程被调度的情况。 面对课程表安排的应用设计一个CourseIntervalSet类，由于插入课程时希望通过星期 几和开始上课的时间进行插入，因此在这个子类中需要增加能够将周数和开始上课的时间对应成时间段的开始时间和结束时间的方法，同时，这个课程表也需要可视化读入，所以增加一个获得具体星期的课表的方法。\n3.4面向复用的设计：L\n所有的ADT都采用泛型L，L必须是immutable类型的变量。如针对每个应用设计的类Employee、Process、Course等\n3.5可复用API设计\n将方法写在单独的APIs.java中，采用委派方式\n3.5.1计算相似度\n针对multiIntervalSet的计算相似度的方法，可以计算两个时间段集合的相似度。两个时间段集合的相似度是通过相似时间/总时间计算的，而相似时间则要求时间段和标签完全一样的时候才叫有效的相似时间。 维护两个IntervalSet，标签使用Integer类型，然后将multi的时间段集合 转换成普通的时间段集合，这样将每个时间段按照开始时间的先后顺序插入其中。这样还可以顺便计算出来两个时间段集合的最长持续时间是多少。然后通过for循环，遍历两个时间段集合的每个时间段，统计有效时间，由此计算出相似度结果。\n首先分析相似度的计算：\n我们以实验指导的例子为例：\n首先我们可以得出对于第一个MultiIntervalSet中标签A，其对应的区域有两个地方[0,5)和[20，25)，而在第二个MultiIntervalSet中标签A，其对应的区域有一个为[20,35)，而由于不同标签的相似度，只存在于相同的标签对应的时间段，因此我们可以计算出相似度。Similar ratio = 15/35=0.42857。 在介绍方法前，首先简述求相似度的辅助函数：\n1.public static long getStartTimerShaft(MultiIntervalSet s) 获得MultiIntervalSet的最早的时间\n2.public static long getEndTimeShaft(MultiIntervalSet s) 获得MultiIntervalSet的最晚的时间\n3.public static double intervalLength(Set s1) 计算s1中的所有时间段的时间的长度\n4.public static Set similarIntervals(IntervalSet s1, IntervalSet s2) 求s1与s2的重合时间段，其中参数为由MultiIntervalSet的label对应的多个Interval构成的Interval， Integer为从小到大的顺序。\n3.5.2计算时间冲突比例\n时间冲突比例应为计算一个MultiIntervalSet类型中所有labels对应的时间段存在重叠的部分。 首先将所有的label映射到Boolean类型，即可认为当前是否已经遍历过该标签。初始化时候，将label对应的Boolean都设置为false。 在循环MultiIntervalSet中所有标签时，依次将每一个设置为true，表示遍历完成。通过双层循环实现对label的遍历，在遍历一个标签时，若发现另一个标签与其相同或已访问过，则跳过，否则通过调用simlarIntervals函数和intervals函数，检查label标签对应的时间段与待检查标签中是否有相同的部分，若有，则累加，即为冲突时间。 总时间通过对每一个label对应时间段求和即可得。 冲突事件/总时间即为时间冲突比例。\n3.5.3计算空闲时间比例\n首先通过3.5.1中叙述的getStartTimerShaft(MultiIntervalSET)函数，获得MultiIntervalSet的最早的时间点，再通过getEndTimerShaft(MultiIntervalSET)函数，即可获得MultiIntervalSet的最晚的时间点。 此时即可计算总的时间。 首先将开头时间和结束时间放入Set中，即可得到此时对应的Interval的集合，开始时候，只有一个Interval，代表从头到结尾。 通过对MultiIntervalSet中的labels遍历，依次得到每个label对应的时间段。 当得到每个时间段后，将Set中的包含当前label对应的时间段的时间段拆分成，不包括不包括label的时间段的部分，并将原Interval删除，将新拆分的Intervals放入Set中，最后调用intervalLength函数，即可计算Set中的时间间隔的总长度。 通过空闲时间/总时间即可计算出空闲时间比例。\n3.6应用设计与开发\n利用上述设计和实现的ADT，实现手册里要求的各项功能。\n3.6.1排班管理系统\n针对排班管理系统，所需完成的功能为：\nStep 1 设定排班开始日期、结束日期，具体到年月日即可。\nStep 2 增加一组员工，包括他们各自的姓名、职务、手机号码，并可随时删除某些员工。如果某个员工已经被编排进排班表，那么他不能被删除，必须将其排班信息删掉之后才能删除该员工。员工信息一旦设定则无法修改。\nStep 3 可手工选择某个员工、某个时间段（以“日”为单位，最小1天，可以是多天），向排班表增加一条排班记录，该步骤可重复执行多次。在该过程中，用户可随时检查当前排班是否已满（即所有时间段都已被安排了特定员工值班）、若未满，则展示给用户哪些时间段未安排、未安排的时间段占总时间段的比例。\nStep 4 除了上一步骤中手工安排，也可采用自动编排的方法，随机生成排班表。 Step 5 可视化展示任意时刻的排班表。可视化要直观明了，可自行设计。 其中step4的自动编排方法秉持着平均的原则，计算出一共要安排多少天，然后用天数除以员工数量，再最后处理剩余的没有安排上的部分，从而完成自动的安排。 如果在自动安排之前已经手动插入了一些安排，那么就清空列表后再进行自动编排\n3.6.2操作系统的进程调度管理系统\n针对操作系统的进程调度管理系统，所需完成的功能为：\nStep 1 增加一组进程，输入每个进程的ID、名称、最短执行时间、最长执行时间；进程一旦设定无法再修改其信息。\nStep 2 当前时刻（设定为0）启动模拟调度，随机选择某个尚未执行结束的进程在CPU上执行（执行过程中其他进程不能被执行），并在该进程最大时间之前的任意时刻停止执行，如果本次及其之前的累积执行时间已落到[最短执行时间，最长执行时间]的区间内，则该进程被设定为“执行结束”。重复上述过程，直到所有进程都达到“执行结束”状态。在每次选择时，也可“不执行任何进程”，并在后续随机选定的时间点再次进行进程选择。\nStep 3 上一步骤是“随机选择进程”的模拟策略，还可以实现“最短进程优先”的模拟策略：每次选择进程的时候，优先选择距离其最大执行时间差距最小的进程。\nStep 4 可视化展示当前时刻之前的进程调度结果，以及当前时刻正在执行的进程。可视化的形式要直观明了，可自行设计。 添加一组进程后，可以启动系统模拟进程调度。进程调度有两种调度策略，一个是随机调度，一个是最短进程优先策略。在这里都采取随机数的方式进行随机调度，同时加入无进程的情况。 在随机进程选择中采用平均随机，即每次从未完成的进程中选择一个，并执行随机数的时间，然后进行下一次随机选择进程，直到所有进程都达到执行时间为止。而最短进程优先策略则增加随机数的产生范围，多余的随机数都指向最短时间的进程，这样最短时间的进程就会被更容易调度。\n欢迎界面\n输入1\n功能为添加进程。\n输入2\n输入5\n3.6.3课表管理系统\n针对课表管理系统，所需完成的功能为：\nStep 1 设定学期开始日期（年月日）和总周数（例如18）；\nStep 2 增加一组课程，每门课程的信息包括：课程ID、课程名称、教师名字、地点、周学时数（偶数）；\nStep 3 手工选择某个课程、上课时间（只能是8-10时、10-12时、13-15时、15-17时、19-21时），为其安排一次课，每次课的时间长度为2小时；可重复安排，直到达到周学时数目时该课程不能再安排；\nStep 4 上步骤过程中，随时可查看哪些课程没安排、当前每周的空闲时间比例、重复时间比例；\nStep 5 因为课程是周期性的，用户可查看本学期内任意一天的课表结果。 每次课的时间长度为2小时，且只有固定的几个时间段可以上课，因此可以根据星期几和上课的开始时间确定唯一的上课时间，在此通过一个转换即可做到。将weekday*24再加上开始上课的时间，就能确定唯一的上课时间。\n简要分析，我们需要一个一个标签对应多个时间段的数据类型，因此选择MultiIntervalSet类型。\nCourseScheduleApp运行如下：\n课表目录\n更新课表信息\n添加课程\n设置课程上课时间\n查看未安排的课程\n查看设置完成的课程\n3.7基于语法的数据读入\n修改“排班管理”应用以扩展该功能。\n该模块主要采用正则表达式处理从文件中读入的字符串。 根据提供的文件的格式确定正则表达式，然后通过正则表达式的语法获取每一行的信息。\n用每一个正则表达式去匹配每一行，如果匹配上了就获取相应的信息进行处理即可。\n在匹配确认格式匹配后，将所读入的内容转化为值班表。 具体运行结果如下： 当读入test1.txt时，具体运行结果如下所示：\n3.8应对面临的新变化\n3.8.1变化1\n代价并不大。只需将值班表中使用的没有空时间段改为允许有空隙，并修改查看排版信息的遍历时所用到的intervalset中的函数（start,end），变为multi-intervalset中的函数（intervals）即可。\n同时，由于一个员工可以占据多段时间，随机排班的功能也需要进行修改。新的排版方式是对每一天进行遍历，每一天都随机选择一个员工。\n3.8.2变化2\n代价很小。只需要再套一层NoOverlapIntervalSet的装饰器就足以应对变化。\n3.9Git仓库结构\n请在完成全部实验要求之后，利用Git log指令或Git图形化客户端或GitHub上项目仓库的Insight页面，给出你的仓库到目前为止的Object Graph，尤其是区分清楚change分支和master分支所指向的位置。\n4实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。\n不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。\n日期 时间段 计划任务 实际完成情况\n2021.06.27 10:00-20:00 完成IntervalSet接口和CommonIntervalSet实例 按时完成\n2021.06.28 13:00-15:00 重构CommonIntervalSet代码 按时完成\n2021.06.28 16：00-19：00 完成MultiIntervalSet接口和Common实例 未完成\n2021.06.28 21：00-23：00 完成MultiIntervalSet接口和Common实例 按时完成\n2021.06.29 9：00-13：00 完成dutyIntervalSet设计和值班表app 未完成\n2021.06.29 15：00-19：00 完成dutyIntervalSet设计和值班表app 按时完成\n2021.06.30 7：00-13：00 完成装饰类的书写 按时完成\n2021.06.30 15：00-23：00 完成具体类的书写并实现进程调度 按时完成\n2021.07.01 7：00-15：00 完成课程表安排和APIs类 按时完成\n2021.07.02 7：00-16：00 完成应对变化及代价 按时完成\n2021.07.03 7：00-18;00 完成报告 按时完成\n5实验过程中遇到的困难与解决途径\n遇到的难点 解决途径\n产生随机数不会\n网络搜索\n如何对日期进行处理\n网络搜索，了解了Date等方法可以进行日期运算\n6实验过程中收获的经验、教训、感想\n6.1实验过程中收获的经验和教训\n对代码复用的体会更加深刻了\n6.2针对以下方面的感受\n(1)重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用，你是否体会到复用的好处？\n复用在一定程度上增加了代码的难度，但另一方面复用大量的减少了代码量。复用更考察了抽象能力，将不同的场景的共同点抽象成抽象ADT。\n(2)重新思考Lab2中的问题：为ADT撰写复杂的specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？\n保证了正确性与安全性，并将一直坚持。\n(3)之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？\n开发API难处体会比较深刻，乐趣没有难处深刻。\n(4)你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？\n匹配过程更加实用。\n(5)Lab1和Lab2的工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过三周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？\n抽象出相同的地方，勤于思考。\n(6)“抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的三个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、委派、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？\n先写接口考虑好应用场景，并写测试，进而不断完善代码。\n(7)关于本实验的工作量、难度、deadline。\n工作量过大、难度过大、deadline过紧。\n(8)下周就要进行考试了，你对《软件构造》课程总体评价如何？\n对我编程起到了很大的作用，让我了解到如何编出更好的代码。\n"
  },
  {
    "head": "HIT软件构造笔记四",
    "paragraphs": [
      "HIT软件构造笔记四",
      "Abstract Data Type (ADT)",
      "1.ADT的操作：",
      "Creators create new objects of the type. 构造器",
      "Producers create new objects from old objects of the type. 生产器",
      "Observers take objects of the abstract type and return objects of a different type. 观察器",
      "Mutators change objects. 变值器，改变对象属性的方法",
      "2.ADT的设计法则",
      "法则1：操作要简洁，一致。对于复杂的操作，应该拆分成多个简单操作的叠加，以此提高内聚性。",
      " 法则2：操作要全面(即需要的功能要可以实现)，且为用户提供方便的操作。",
      " 法则3：要不是针对抽象，要不是针对具体，不要两者混合。因此面向具体应用的类型不应该有通用方法，面向通用的类型也不该有具体方法。",
      "3.ADT的测试",
      "总的来说，对构造器、生产器、变值器的测试要用观察器检查；对观察器的测试要用其他三类方法来产生或构造对象。但这样的风险是，可能会产生互相依赖的现象，导致无法找到真正的错误原因。",
      " 解决方案：新创建一些方法来解除这些耦合，或者是把一部分私有方法改为公有方法，测试完后再换回私有。或者如果对于小型程序，只要测试结果都是正确的，也就可以解决问题。",
      "4.不变量与抽象函数",
      "Rep Invariant(RI) and Abstraction Function(AF)",
      "Invariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件",
      "两个空间 R 和 A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。",
      "Abstraction Function：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。",
      "Rep Invariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。",
      "5.AF，RI和表示泄露安全说明的文档化",
      "这些都是写在代码的注释中，而非规约中。要给出理由，证明代码并未对外泄露其内部表示，比如字段全部为private，还有对可变字段的处理等等。",
      " 可用表示不变量来代替一些前置条件。"
    ],
    "sentences": [
      "HIT软件构造笔记四",
      "Abstract Data Type (ADT)",
      "1.ADT的操作：Creators create new objects of the type. 构造器",
      "Producers create new objects from old objects of the type. 生产器",
      "Observers take objects of the abstract type and return objects of a different type. 观察器",
      "Mutators change objects. 变值器",
      "改变对象属性的方法",
      "2.ADT的设计法则",
      "法则1：操作要简洁，一致",
      "对于复杂的操作，应该拆分成多个简单操作的叠加，以此提高内聚性",
      " 法则2：操作要全面(即需要的功能要可以实现)",
      "且为用户提供方便的操作",
      " 法则3：要不是针对抽象，要不是针对具体，不要两者混合",
      "因此面向具体应用的类型不应该有通用方法",
      "面向通用的类型也不该有具体方法",
      "3.ADT的测试",
      "总的来说",
      "对构造器、生产器、变值器的测试要用观察器检查；对观察器的测试要用其他三类方法来产生或构造对象",
      "但这样的风险是",
      "可能会产生互相依赖的现象",
      "导致无法找到真正的错误原因",
      " 解决方案：新创建一些方法来解除这些耦合",
      "或者是把一部分私有方法改为公有方法",
      "测试完后再换回私有",
      "或者如果对于小型程序",
      "只要测试结果都是正确的",
      "也就可以解决问题",
      "4.不变量与抽象函数",
      "Rep Invariant(RI) and Abstraction Function(AF)",
      "Invariants：不变量",
      "与程序运行无关",
      "在任何时候都应该满足的一些条件",
      "两个空间 R 和 A：R空间是ADT的内部表示的空间",
      "A空间是ADT能够表示的存在于实际当中的对象",
      "ADT的开发者关注的是R空间，client关注的是A空间",
      "Abstraction Function：从R空间到A空间存在一个映射",
      "这个映射是一个满射",
      "这个映射将R中的每一个值解释为A中的一个值",
      "这个解释函数就是AF",
      "Rep Invariant：这是一个集合",
      "是R空间所有值的子集",
      "它包含了所有合法的表示值",
      "而只有满足RI的值",
      "才是合法值",
      "才会在A空间内有值与其对应",
      "5.AF，RI和表示泄露安全说明的文档化",
      "这些都是写在代码的注释中，而非规约中",
      "要给出理由",
      "证明代码并未对外泄露其内部表示",
      "比如字段全部为private",
      "还有对可变字段的处理等等",
      " 可用表示不变量来代替一些前置条件"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "HIT软件构造笔记四\nAbstract Data Type (ADT)\n1.ADT的操作：\nCreators create new objects of the type. 构造器\nProducers create new objects from old objects of the type. 生产器\nObservers take objects of the abstract type and return objects of a different type. 观察器\nMutators change objects. 变值器，改变对象属性的方法\n2.ADT的设计法则\n法则1：操作要简洁，一致。对于复杂的操作，应该拆分成多个简单操作的叠加，以此提高内聚性。\n 法则2：操作要全面(即需要的功能要可以实现)，且为用户提供方便的操作。\n 法则3：要不是针对抽象，要不是针对具体，不要两者混合。因此面向具体应用的类型不应该有通用方法，面向通用的类型也不该有具体方法。\n3.ADT的测试\n总的来说，对构造器、生产器、变值器的测试要用观察器检查；对观察器的测试要用其他三类方法来产生或构造对象。但这样的风险是，可能会产生互相依赖的现象，导致无法找到真正的错误原因。\n 解决方案：新创建一些方法来解除这些耦合，或者是把一部分私有方法改为公有方法，测试完后再换回私有。或者如果对于小型程序，只要测试结果都是正确的，也就可以解决问题。\n4.不变量与抽象函数\nRep Invariant(RI) and Abstraction Function(AF)\nInvariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件\n两个空间 R 和 A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。\nAbstraction Function：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。\nRep Invariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。\n5.AF，RI和表示泄露安全说明的文档化\n这些都是写在代码的注释中，而非规约中。要给出理由，证明代码并未对外泄露其内部表示，比如字段全部为private，还有对可变字段的处理等等。\n 可用表示不变量来代替一些前置条件。\n"
  },
  {
    "head": "HIT软件构造笔记三",
    "paragraphs": [
      "HIT软件构造笔记三",
      "1.1Data Type and Type Checking",
      "编程语言的数据类型",
      "基本数据类型(int、boolean、char、byte、double、long)，Immutable，在栈中分配内存，代价也比较低",
      "对象数据类型(String、Integer等)。Immutable/Mutable，分配的内存都在堆中，代价相对昂贵",
      "基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。",
      "2.类型检查",
      "静态类型语言(Java)可执行静态类型检查，在编译阶段进行类型检查，这意味着避免了将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误都可以在静态类型检查时发现；",
      "动态类型语言(python)只有动态类型检查，在运行阶段才会进行类型检查，例如非法的参数值 (最典型的NULL引用)、非法的返回值、越界等等。",
      "3.Mutability和Immutability",
      "Immutability：不变性，一个重要的设计原则，设计ADT时尽量保证这个原则。",
      "Immutable types：不可变的数据类型，当实例对象被创建以后，该对象的值就不可变化了，也就是该ADT中不能有mutator方法。",
      "可变对象的优点：虽然mutable类型由于指向的是同一个存储区域，所以更改对象的内容后会在意想不到的位置产生意想不到的变化，所以更推荐使用Imutable的数据类型，但是使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，比如依次将 ‘a’~‘z’ 连接到一个空字符串上，就会产生25个临时拷贝，而使用可变类型则最少化拷贝以提高效率。",
      "使用可变数据类型，可获得更好的性能。但是在质量指标中，性能的优先级较低，所以即使mutable类型有这个优点也更倾向于选择imutable的类型。",
      "4.Snapshot diagram",
      "基本类型的值",
      "对象类型的值：mutable对象，单线圈；immutable对象，双线圈；可变的引用，单线箭头；不可变的引用，双线箭头",
      "5.集合类型",
      "List",
      "Set",
      "Map",
      "1.2 Designing Specification",
      "1、Spec的用处；",
      "没规约，没法写程序；即使写出来，也不知道对错；",
      "规约是程序与客户端之间达成的一致；",
      "Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守；",
      "很多bug来自于双方之间的误解， 不写下来，那么不同开发者的理解就可能不同；",
      "没有规约，难以定位错误；",
      "精确的规约，有助于区分责任；",
      "客户端无需阅读调用函数的代码，只需理解spec即可",
      "2、Spec的结构：",
      "precondition前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "使用@param annotation说明每个参数的前置条件",
      "postcondition后置条件：对开发者的约束，方法结束时必须满足的条件",
      "使用@return annotation说明后置条件",
      "使用@throws annotation说明出现异常的时候会发生什么",
      "在方法声明中使用static等关键字声明，可据此进行静态类型检查",
      "当客户端满足前置条件的时候，结果必须满足后置条件；当前置条件不满足的时候，方法内部可以做任何事情，但作为开发者，应该尽量让程序做到fail fast。",
      "3、Spec的评判标准：spec变强的要求是更宽松的前置条件+更严格的后置条件，在这种情况下，就可以用变强了的spec去替换原来的spec。越强的规约，意味着implementor的自由度和责任越重，而client的责任越轻。",
      "用椭圆表示spec的强度，大椭圆表示更弱的spec，小椭圆表示更强的spec，椭圆的大小表示的是开发者的自由度，小椭圆有更强的后置和更弱的前置，因此所包含的结果的点就少，所以就小。"
    ],
    "sentences": [
      "HIT软件构造笔记三",
      "1.1Data Type and Type Checking",
      "编程语言的数据类型",
      "基本数据类型(int、boolean、char、byte、double、long)",
      "Immutable",
      "在栈中分配内存",
      "代价也比较低",
      "对象数据类型(String、Integer等)",
      "Immutable/Mutable",
      "分配的内存都在堆中",
      "代价相对昂贵",
      "基本类型被包装为对象类型",
      "通常只有在定义集合的时候使用",
      "其他情况下尽量避免使用",
      "基本类型和对象类型之间一般可以自动转换",
      "2.类型检查",
      "静态类型语言(Java)可执行静态类型检查",
      "在编译阶段进行类型检查",
      "这意味着避免了将错误带入到运行阶段",
      "可以提高程序的正确性/健壮性",
      "例如语法错误、类名/函数名错误",
      "参数类型或数目错误、返回值类型错误都可以在静态类型检查时发现；动态类型语言(python)只有动态类型检查",
      "在运行阶段才会进行类型检查",
      "例如非法的参数值 (最典型的NULL引用)、非法的返回值、越界等等",
      "3.Mutability和Immutability",
      "Immutability：不变性",
      "一个重要的设计原则",
      "设计ADT时尽量保证这个原则",
      "Immutable types：不可变的数据类型",
      "当实例对象被创建以后",
      "该对象的值就不可变化了",
      "也就是该ADT中不能有mutator方法",
      "可变对象的优点：虽然mutable类型由于指向的是同一个存储区域",
      "所以更改对象的内容后会在意想不到的位置产生意想不到的变化",
      "所以更推荐使用Imutable的数据类型",
      "但是使用不可变类型",
      "对其频繁修改会产生大量的临时拷贝(需要垃圾回收)",
      "比如依次将 ‘a’~‘z’ 连接到一个空字符串上",
      "就会产生25个临时拷贝",
      "而使用可变类型则最少化拷贝以提高效率",
      "使用可变数据类型，可获得更好的性能",
      "但是在质量指标中",
      "性能的优先级较低",
      "所以即使mutable类型有这个优点也更倾向于选择imutable的类型",
      "4.Snapshot diagram",
      "基本类型的值",
      "对象类型的值：mutable对象",
      "单线圈；immutable对象",
      "双线圈；可变的引用",
      "单线箭头；不可变的引用",
      "双线箭头",
      "5.集合类型",
      "List",
      "Set",
      "Map",
      "1.2 Designing Specification",
      "1、Spec的用处；没规约",
      "没法写程序；即使写出来",
      "也不知道对错；规约是程序与客户端之间达成的一致；Spec给“供需双方”都确定了责任",
      "在调用的时候双方都要遵守；很多bug来自于双方之间的误解",
      " 不写下来",
      "那么不同开发者的理解就可能不同；没有规约",
      "难以定位错误；精确的规约",
      "有助于区分责任；客户端无需阅读调用函数的代码",
      "只需理解spec即可",
      "2、Spec的结构：precondition前置条件：对客户端的约束",
      "在使用方法时必须满足的条件",
      "使用@param annotation说明每个参数的前置条件",
      "postcondition后置条件：对开发者的约束",
      "方法结束时必须满足的条件",
      "使用@return annotation说明后置条件",
      "使用@throws annotation说明出现异常的时候会发生什么",
      "在方法声明中使用static等关键字声明",
      "可据此进行静态类型检查",
      "当客户端满足前置条件的时候",
      "结果必须满足后置条件；当前置条件不满足的时候",
      "方法内部可以做任何事情",
      "但作为开发者",
      "应该尽量让程序做到fail fast",
      "3、Spec的评判标准：spec变强的要求是更宽松的前置条件+更严格的后置条件",
      "在这种情况下",
      "就可以用变强了的spec去替换原来的spec",
      "越强的规约",
      "意味着implementor的自由度和责任越重",
      "而client的责任越轻",
      "用椭圆表示spec的强度",
      "大椭圆表示更弱的spec",
      "小椭圆表示更强的spec",
      "椭圆的大小表示的是开发者的自由度",
      "小椭圆有更强的后置和更弱的前置",
      "因此所包含的结果的点就少",
      "所以就小"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "HIT软件构造笔记三\n1.1Data Type and Type Checking\n编程语言的数据类型\n基本数据类型(int、boolean、char、byte、double、long)，Immutable，在栈中分配内存，代价也比较低\n对象数据类型(String、Integer等)。Immutable/Mutable，分配的内存都在堆中，代价相对昂贵\n基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。\n2.类型检查\n静态类型语言(Java)可执行静态类型检查，在编译阶段进行类型检查，这意味着避免了将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误都可以在静态类型检查时发现；\n动态类型语言(python)只有动态类型检查，在运行阶段才会进行类型检查，例如非法的参数值 (最典型的NULL引用)、非法的返回值、越界等等。\n3.Mutability和Immutability\nImmutability：不变性，一个重要的设计原则，设计ADT时尽量保证这个原则。\nImmutable types：不可变的数据类型，当实例对象被创建以后，该对象的值就不可变化了，也就是该ADT中不能有mutator方法。\n可变对象的优点：虽然mutable类型由于指向的是同一个存储区域，所以更改对象的内容后会在意想不到的位置产生意想不到的变化，所以更推荐使用Imutable的数据类型，但是使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，比如依次将 ‘a’~‘z’ 连接到一个空字符串上，就会产生25个临时拷贝，而使用可变类型则最少化拷贝以提高效率。\n使用可变数据类型，可获得更好的性能。但是在质量指标中，性能的优先级较低，所以即使mutable类型有这个优点也更倾向于选择imutable的类型。\n4.Snapshot diagram\n基本类型的值\n对象类型的值：mutable对象，单线圈；immutable对象，双线圈；可变的引用，单线箭头；不可变的引用，双线箭头\n5.集合类型\nList\nSet\nMap\n1.2 Designing Specification\n1、Spec的用处；\n没规约，没法写程序；即使写出来，也不知道对错；\n规约是程序与客户端之间达成的一致；\nSpec给“供需双方”都确定了责任，在调用的时候双方都要遵守；\n很多bug来自于双方之间的误解， 不写下来，那么不同开发者的理解就可能不同；\n没有规约，难以定位错误；\n精确的规约，有助于区分责任；\n客户端无需阅读调用函数的代码，只需理解spec即可\n2、Spec的结构：\nprecondition前置条件：对客户端的约束，在使用方法时必须满足的条件\n使用@param annotation说明每个参数的前置条件\npostcondition后置条件：对开发者的约束，方法结束时必须满足的条件\n使用@return annotation说明后置条件\n使用@throws annotation说明出现异常的时候会发生什么\n在方法声明中使用static等关键字声明，可据此进行静态类型检查\n当客户端满足前置条件的时候，结果必须满足后置条件；当前置条件不满足的时候，方法内部可以做任何事情，但作为开发者，应该尽量让程序做到fail fast。\n3、Spec的评判标准：spec变强的要求是更宽松的前置条件+更严格的后置条件，在这种情况下，就可以用变强了的spec去替换原来的spec。越强的规约，意味着implementor的自由度和责任越重，而client的责任越轻。\n用椭圆表示spec的强度，大椭圆表示更弱的spec，小椭圆表示更强的spec，椭圆的大小表示的是开发者的自由度，小椭圆有更强的后置和更弱的前置，因此所包含的结果的点就少，所以就小。\n"
  },
  {
    "head": "HIT软件构造lab2实验心得",
    "paragraphs": [
      "HIT软件构造lab2实验心得",
      "1实验目标概述",
      "本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说：",
      "针对给定的应用问题，从问题描述中识别所需的ADT；",
      "设计ADT规约（pre-condition、post-condition）并评估规约的质量；",
      "根据ADT的规约设计测试用例；",
      "ADT的泛型化；",
      "根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function） 使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；",
      "测试ADT的实现并评估测试的覆盖度；",
      "使用ADT及其实现，为应用问题开发程序；",
      "测试代码中，能够写出testing strategy并据此设计测试用例。",
      "2实验环境配置",
      "根据实验手册中的网址，在eclipse中：help – Eclipse Marketplace – search – EclEmma Java Code Coverage – install 安装成功",
      "URL地址：",
      "https://github.com/ComputerScienceHIT/HIT-Lab2-1190202013",
      "3实验过程",
      "请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。",
      "3.1Poetic Walks",
      "MIT指导页面链接：http://web.mit.edu/6.031/www/sp17/psets/ps2/",
      "该问题已经提供了ADT大体框架，graph的接口，要求我们建立一个边图类ConcreteEdgesGraph、一个点图类ConcreteVerticesGraph实现graph接口，实现抽象数据型，完成poet的工作。Graph接口要求实现add（添加新节点），set（添加新边），remove（移除节点），vertices（获得所有的节点集合），sources（target）获得以target为目标节点的边的起始节点，targes(source)获得以source为起始节点的边的目标节点。",
      "Poet：假设存在一条由a到b的有向边，构造有向图，再给定一句子，如果句子中两个相邻单词在有向图中有一个中间单词，则将该单词插入到a与b中间，若存在多个中间单词，则插入权重最大的那个",
      "3.1.1Get the code and prepare Git repository",
      "如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。",
      "网址：https://github.com/rainywang/Spring2020_HITCS_SC_Lab2/tree/master/P1",
      "gitbash直接执行git clone https://github.com/rainywang/Spring2020_HITCS_SC_Lab2.git下载工程文件",
      "git clone https://github.com/ComputerScienceHIT/Lab2-1190202013.git",
      "本地仓库建好",
      "3.1.2Problem 1: Test Graph",
      " 以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。",
      "针对Graph设计测试策略，编写测试用例主要利用等价类划分的思想进行测试。",
      "过程：用String类为Graph编写测试用例。共需编写六个函数的测试用例：add, set, remove, vertices, sources, targets。add, set, remove属于mutator；vertices, sources, targets属于observer。如下所示，为所有方法的测试策略",
      "将Graph中的empty()方法修改为：",
      "并对GraphStaticTest进行JUnit测试，如下：",
      "用String类为Graph编写测试用例。共需编写六个函数的测试用例：add, set, remove, vertices, sources, targets。add, set, remove属于mutator；vertices, sources, targets属于observer",
      "在coverage中查看覆盖率如下",
      "3.1.3Problem 2: Implement Graph",
      " 分别实现两个实现类ConcreteEgesGraph和ConcreteVerticesGraph，需标注创建的每一个类的AF和RI，如何防止表示泄露。使用函数checkRep来检验是否符合RI，重写toString函数以便输出该类信息。",
      "3.1.3.1Implement ConcreteEdgesGraph",
      "3.1.3.1.1实现Edge:",
      "1、EDGE中的字段包括边的起始节点、目标节点和边权值，定义为私有类型变量，信息对外界隐藏，使用final是其值不可变，防止外部对内部引用使其泄露。",
      "2、实现Edge需要实现的方法：",
      "Fileds 作用",
      "private final L source 起始节点",
      "private final L target 目标节点",
      "private final int weight 边权值",
      "Method 作用",
      "Edge 初始化构造方法，初始化边的起始节点和目标节点和边权值",
      "checkRep() 检查表示不变性，两点不为null且权值非负",
      "getsource() 返回有向边起始节点",
      "gettarget() 返回有向边目标节点",
      "getweight() 返回边权值",
      "@Override toString() 使用@Override注释toString以确保正确覆盖Object方法的toString方法",
      "3、AF、RI和Safety from rep exposure",
      "4、Edge测试策略：",
      "3.1.3.1.2实现ConcreteEdgesGraph类：",
      "1、ConcreteEdgesGraph字段中包括顶点set表和边list表，定义私有类型的表如下图所示：",
      "2、实现ConcreteEdgesGraph需要实现的方法：",
      "Method 作用",
      "private void checkRep() 检查表示不变性，edges长度是大于0的实数，有起始的节点",
      "public boolean add(L vertex) 调用vertices.add，其返回结果为boolean且满足spec定义。",
      "public int set(L source, L target, int weight) 前置条件要求weight>=0，如果weight<0，输出提示信息。在weight>=0的条件下，对图的边表进行遍历，若存在顶点为source，终点为target的边，保存这条边原本的权值，否则设为0。如果weight>0，则将这条边及顶点加入或者修改原有边的权值；如果weight=0，删除这条边。返回原本的权值。",
      "public boolean remove(L vertex) 从vertices中删去，传入的参数vertex点，遍历edges，寻找是否有边的起点或者是终点是该vertex，删去。注意在使用迭代器遍历时要使用iterator.remove方法保证安全。",
      "public Set vertices() 返回vertices集合",
      "public Map<L, Integer> sources(L target) 根据传入的target参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。",
      "public Map<L, Integer> targets(L source) 根据传入的source参数寻找以source为起点的边。实现同上",
      "public String toString() 将整个图中所有点的指向转化为一条字符串输出",
      "3、AF,RI和Safety from rep exposure",
      "4、测试策略：继承Graph的测试策略，并增加toString的测试",
      "测试结果如下：",
      "检查覆盖率：",
      "3.1.3.2Implement ConcreteVerticesGraph",
      "3.1.3.2.1实现Vertex：",
      "1、字段中应当包括点的名字，点的源点表Map，点的终点表Map，定义私有类型的表",
      "Filed 作用",
      "private L name 节点名字",
      "private Map<L,Integer> sources 所有以name为目标节点的边，<起始节点name,边的权重>",
      "private Map<L,Integer> targets 所有以name为起始节点的边，<目标节点name,边的权重>",
      "2、在Vertex需要实现的方法:",
      "Interface 作用",
      "private void checkRep() 检查表示不变性，每个边的权值应该大于0",
      "public L getname) 返回该节点的name",
      "public Map<L,Integer> getsources() 根据传入的targets参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。",
      "public Map<L,Integer> gettargets() 根据传入的sources参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。",
      "public int addsource(L newsource,int weight) 加入一条以source为起点，当前顶点为终点的边，即将source, weight加入sources",
      "public int addtarget(L newtarget,int weight) 加入一条以当前点为起点，当前target为终点的边，即将target, weight加入targets",
      "public int removesource(L newsource) 在源点表中删除某起始点，并返回旧的边长",
      "public int removetarget(L newtarget) 在终点表中删除某终点，并返回旧的边长",
      "public String toString() 得到一个点的字符串表示",
      "3、AF,RI和Safety from rep exposure：",
      "4、测试策略：",
      "3.1.3.2.2实现ConcreteVerticeGraph:",
      "1、ConcreteVerticesGraph的字段为Vertex构成的List，定义私有类型的表：",
      "2、在ConcreteVerticesGraph需要实现的方法：",
      "Method 实现思路",
      "private void checkRep() 检查表示不变性，vertices中没有重复点",
      "public boolean add(L vertex) 检查输入满足vertex!=null，添加一个顶点进入点表中",
      "public int set(L source, L target, int weight) 输入source，target，weight，分别为边的起点、终点和权值。若权值为负，返回-1。若权值为正且新边已经存在，则除去原边并添加新边。若权值为正且新边不存在，则直接添加新边。若权值为0且新边已经存在，则出去原边。只要改变了原边权值，都返回原边权值，没有权值则返回0",
      "public boolean remove(L vertex) 除去某个点及与它相邻的所有边。只需要遍历vertices，寻找是否有与待删除点相同的名字的点直接删去即可，如果名字不相同，则在该点的源点表和终点表中寻找删去即可，使用迭代器实现。",
      "public Set vertices 返回所有的点集",
      "public Map<L, Integer> sources(L target) 输入一个终点，返回与它相连的所有边和起点构成的Map",
      "public Map<L, Integer> targets(L source) 输入一个起点，返回与它相连的所有边和终点构成为的Map",
      "public String toString() 将整个图中所有点的指向转化为一条字符串输出",
      "3、AF,RI和Safety from rep exposure如下图：",
      "4、测试策略：继承Graph的测试策略并增加toString的测试",
      "测试结果：",
      "检查覆盖率：",
      "3.1.4 Problem 3: Implement generic Graph：",
      "3.1.4.1 Make the implementations generic",
      "将所有String改为L，并且Edge需改为Edge，Vertex需改为Vertex。",
      "3.1.4.2 Implement Graph.empty()",
      "选择ConcreteEdgesGraph作为Graph.empty()的实现类，返回new ConcreteEdgesGraph",
      "测试策略：",
      "测试结果：",
      "覆盖率：",
      "3.1.5 Problem 4: Poetic walks",
      "任务要求我们实现一个类，利用之前实现的图结构，能够将语料库转化为该种图结构，并且在图中搜索，完成对输入的诗句的句子进行扩充。",
      "3.1.5.1 Test GraphPoet",
      "测试策略：",
      "GraphPoet()考虑到了输入文件是否存在、文件中含有多个连续空格、大小写、换行符、空行、标点符号、重复的词以及连续的词或词组等特殊情况，依此设计测试用例；",
      "poem()图中没有的词、相邻的两个词、两个词之间的路径经过多个词的情况不作改变；存在两个词在图中有一条只经过一个桥接词的路径；存在两个词在图中有多条只经过一个桥接词的路径。",
      "具体实现读入一系列满足要求的文件：",
      "测试结果为：",
      "测试覆盖率为：",
      "3.1.5.2 Implement GraphPoet",
      "1、构造器GraphPoet(File corpus)",
      "一行一行读入文件，以空格为界将词分开存入列表，以每两个连续的词作为顶点，这两个顶点之间有边，记录两个词连续出现的次数作为边权。",
      "观察器poem(String input)",
      "输入需要进行扩充的字符串，声明声明一个StringBuilder保存，每次读取一个词，当前词作为source，下一个词作为target，然后在garph中寻找source的终点表中是否有与target的源点表中相同的元素，并且找到权值最大的和的点加入source和target之间，返回扩充后的字符串。",
      "Checkrep",
      "检查是否符合RI：图中每个词都不是空，不含有空格和换行符，都是小写，每个词都有边与之相连。",
      "toString",
      "调用ConcreteEdgesGraph中的toString方法，将整个图中所有点的指向转化为一条字符串输出",
      "2、 AF,RI和Safety from rep exposure如下图：",
      "3.1.5.3 Graph poetry slam",
      "运行main函数如下输出：",
      "3.1.6 Before you’re done",
      "如何通过Git提交当前版本到GitHub上你的Lab2仓库。",
      "在这里给出你的项目的目录结构树状示意图。",
      "3.2Re-implement the Social Network in Lab1",
      "这次实验要求我们基于Poetic Walks中定义的Graph及其两种实现（本人使用的是ConcreteVerticesGraph），实现Lab1中Social NetWorek中的各种功能，并且尽可能复用ConcreteVerticesGraph中已经实现的方法，然后运行提供的main()和执行Lab1中的Junit测试用例，使之正常运行。",
      "3.2.1 FriendshipGraph类",
      "(1).FriendshipGraph的字段为Person构成的ConcreteEdgesGraph，定义私有类型的表如下图所示：",
      "(2).在FriendshipGraph需要实现的方法如下图所示：",
      "FriendshipGraph 构造方法",
      "addVertex 在图中增加新Person，只需要调用ConcreteEdgesGraph中的add即可：",
      "addEdge 为某个人增加朋友,a为这个人，b为增加的朋友,直接调用ConcreteEdgesGraph中的set即可：",
      "getallprople 直接返回即可：",
      "getDistance 遍历顶点以及其sources，根据广度优先算法，构建队列。将起点先加入队列，然后每次从队头弹出一个点，将其sources中还未在队列中的顶点压入队尾，直到遍历到终点。在这个过程中记录起点距每个点的距离即可。若直到队空也没有遍历到终点，则返回-1。",
      "main 复制Lab1的即可",
      "(3).AF,RI和Safety from rep exposure如下图：",
      "3.2.2 Person类",
      "(1).FriendshipGraph的字段为Person构成的ConcreteEdgesGraph，定义私有类型的表如下图所示：",
      "(2).在FriendshipGraph需要实现的方法如下图所示：",
      "Person 没有重复名字则加入，构造方法",
      "getmyname 返回本人名字，直接返回即可",
      "(3).AF,RI和Safety from rep exposure如下图：",
      "3.2.3 客户端main()",
      "复制Lab1 3.3中的main运行后如下：",
      "3.2.4 测试用例",
      "测试策略：",
      "与Lab1的测试策略相同：",
      "测试结果：",
      "检查覆盖率：(需要提前注释main()函数)：",
      "3.2.4 提交至Git仓库",
      "如何通过Git提交当前版本到GitHub上你的Lab2仓库。",
      "与提交P1相似",
      "在这里给出你的项目的目录结构树状示意图。",
      "4实验进度记录",
      "请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。",
      "每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。",
      "不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。",
      "日期 时间段 计划任务 实际完成情况",
      "5.25 13:00-22:30 完成P1边图类 完成",
      "5.26 15：30-23：30 完成P1点图类 完成",
      "5.28 15：30-20：00 GraphPoet和poem 未按计划完成",
      "5.29 13：00-16：30 Poem 完成",
      "6.3 15：30-20：00 修改完善测试用例 完成",
      "6.4 14：30-19：30 FriendshipGraph 完成",
      "6.10 15：30-16：00 完善测试用例 完成",
      "6.11 13：00-16：00 完善报告 完成",
      "5实验过程中遇到的困难与解决途径",
      "遇到的难点 解决途径",
      "换成泛型后很多警告",
      "Git二次提交",
      "不太会使用git二次提交文件，所以重新增加 master 重新push",
      "6实验过程中收获的经验、教训、感想",
      "6.1实验过程中收获的经验和教训",
      "在自行设计多种类来实现功能的情况下，自己设计的很多类之间有很多重复和矛盾的部分，很多关系弄不清楚",
      "6.2针对以下方面的感受",
      "(1)面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？",
      "答：面向ADT需要考虑底层实现，而面向应用场景无需了解ADT如何实现各种功能，直接调用即可。",
      "(2)使用泛型和不使用泛型的编程，对你来说有何差异？",
      "答：使用泛型应用范围更广，但设计的时候需要考虑不能应用某一类型内部的方法；不使用泛型应用范围窄，但设计时可以应用某一特定类型包装好的方法。",
      "(3)在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？",
      "答：能够保证代码的正确性，及时修改。不适应。",
      "(4)P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？",
      "答：可以提高代码的利用率，减少重复。",
      "(5)P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？",
      "答：适应方式就是在应用场景时只考虑应用场景，“忘记”ADT内部的具体实现方式。自主实现感觉需要自己考虑的东西变多了。",
      "(6)为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "答：保证程序的安全性和健壮性。可能很难坚持。",
      "(7)关于本实验的工作量、难度、deadline。",
      "答：感觉工作量还挺多的。",
      "(8)《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "答：实验和课堂上的理论结合非常紧密。"
    ],
    "sentences": [
      "HIT软件构造lab2实验心得",
      "1实验目标概述",
      "本次实验训练抽象数据类型（ADT）的设计、规约、测试",
      "并使用面向对象编程（OOP）技术实现ADT",
      "具体来说：针对给定的应用问题",
      "从问题描述中识别所需的ADT；设计ADT规约（pre-condition、post-condition）并评估规约的质量；根据ADT的规约设计测试用例；ADT的泛型化；根据规约设计ADT的多种不同的实现；针对每种实现",
      "设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function） 使用OOP实现ADT",
      "并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；测试ADT的实现并评估测试的覆盖度；使用ADT及其实现",
      "为应用问题开发程序；测试代码中",
      "能够写出testing strategy并据此设计测试用例",
      "2实验环境配置",
      "根据实验手册中的网址",
      "在eclipse中：help – Eclipse Marketplace – search – EclEmma Java Code Coverage – install 安装成功",
      "URL地址：https://github.com/ComputerScienceHIT/HIT-Lab2-1190202013",
      "3实验过程",
      "请仔细对照实验手册",
      "针对三个问题中的每一项任务",
      "在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路",
      "可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）",
      "3.1Poetic Walks",
      "MIT指导页面链接：http://web.mit.edu/6.031/www/sp17/psets/ps2/",
      "该问题已经提供了ADT大体框架",
      "graph的接口",
      "要求我们建立一个边图类ConcreteEdgesGraph、一个点图类ConcreteVerticesGraph实现graph接口",
      "实现抽象数据型",
      "完成poet的工作",
      "Graph接口要求实现add（添加新节点）",
      "set（添加新边）",
      "remove（移除节点）",
      "vertices（获得所有的节点集合）",
      "sources（target）获得以target为目标节点的边的起始节点",
      "targes(source)获得以source为起始节点的边的目标节点",
      "Poet：假设存在一条由a到b的有向边",
      "构造有向图",
      "再给定一句子",
      "如果句子中两个相邻单词在有向图中有一个中间单词",
      "则将该单词插入到a与b中间",
      "若存在多个中间单词",
      "则插入权重最大的那个",
      "3.1.1Get the code and prepare Git repository",
      "如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发",
      "网址：https://github.com/rainywang/Spring2020_HITCS_SC_Lab2/tree/master/P1",
      "gitbash直接执行git clone https://github.com/rainywang/Spring2020_HITCS_SC_Lab2.git下载工程文件",
      "git clone https://github.com/ComputerScienceHIT/Lab2-1190202013.git",
      "本地仓库建好",
      "3.1.2Problem 1: Test Graph",
      " 以下各部分",
      "请按照MIT页面上相应部分的要求",
      "逐项列出你的设计和实现思路/过程/结果",
      "针对Graph设计测试策略",
      "编写测试用例主要利用等价类划分的思想进行测试",
      "过程：用String类为Graph编写测试用例",
      "共需编写六个函数的测试用例：add, set, remove, vertices, sources, targets",
      "add, set, remove属于mutator；vertices, sources, targets属于observer",
      "如下所示，为所有方法的测试策略",
      "将Graph中的empty()方法修改为：并对GraphStaticTest进行JUnit测试",
      "如下：用String类为Graph编写测试用例",
      "共需编写六个函数的测试用例：add, set, remove, vertices, sources, targets",
      "add, set, remove属于mutator；vertices, sources, targets属于observer",
      "在coverage中查看覆盖率如下",
      "3.1.3Problem 2: Implement Graph",
      " 分别实现两个实现类ConcreteEgesGraph和ConcreteVerticesGraph",
      "需标注创建的每一个类的AF和RI",
      "如何防止表示泄露",
      "使用函数checkRep来检验是否符合RI",
      "重写toString函数以便输出该类信息",
      "3.1.3.1Implement ConcreteEdgesGraph",
      "3.1.3.1.1实现Edge:1、EDGE中的字段包括边的起始节点、目标节点和边权值",
      "定义为私有类型变量",
      "信息对外界隐藏",
      "使用final是其值不可变",
      "防止外部对内部引用使其泄露",
      "2、实现Edge需要实现的方法：Fileds 作用",
      "private final L source 起始节点",
      "private final L target 目标节点",
      "private final int weight 边权值",
      "Method 作用",
      "Edge 初始化构造方法",
      "初始化边的起始节点和目标节点和边权值",
      "checkRep() 检查表示不变性",
      "两点不为null且权值非负",
      "getsource() 返回有向边起始节点",
      "gettarget() 返回有向边目标节点",
      "getweight() 返回边权值",
      "@Override toString() 使用@Override注释toString以确保正确覆盖Object方法的toString方法",
      "3、AF、RI和Safety from rep exposure",
      "4、Edge测试策略：3.1.3.1.2实现ConcreteEdgesGraph类：1、ConcreteEdgesGraph字段中包括顶点set表和边list表",
      "定义私有类型的表如下图所示：2、实现ConcreteEdgesGraph需要实现的方法：Method 作用",
      "private void checkRep() 检查表示不变性",
      "edges长度是大于0的实数",
      "有起始的节点",
      "public boolean add(L vertex) 调用vertices.add",
      "其返回结果为boolean且满足spec定义",
      "public int set(L source, L target, int weight) 前置条件要求weight>=0",
      "如果weight<0",
      "输出提示信息",
      "在weight>=0的条件下",
      "对图的边表进行遍历",
      "若存在顶点为source",
      "终点为target的边",
      "保存这条边原本的权值",
      "否则设为0",
      "如果weight>0",
      "则将这条边及顶点加入或者修改原有边的权值；如果weight=0",
      "删除这条边",
      "返回原本的权值",
      "public boolean remove(L vertex) 从vertices中删去",
      "传入的参数vertex点",
      "遍历edges",
      "寻找是否有边的起点或者是终点是该vertex",
      "删去",
      "注意在使用迭代器遍历时要使用iterator.remove方法保证安全",
      "public Set vertices() 返回vertices集合",
      "public Map<L, Integer> sources(L target) 根据传入的target参数寻找以targe为终点的边",
      "返回一个键值对为（点，权重）的map",
      "public Map<L, Integer> targets(L source) 根据传入的source参数寻找以source为起点的边",
      "实现同上",
      "public String toString() 将整个图中所有点的指向转化为一条字符串输出",
      "3、AF,RI和Safety from rep exposure",
      "4、测试策略：继承Graph的测试策略",
      "并增加toString的测试",
      "测试结果如下：检查覆盖率：3.1.3.2Implement ConcreteVerticesGraph",
      "3.1.3.2.1实现Vertex：1、字段中应当包括点的名字",
      "点的源点表Map",
      "点的终点表Map",
      "定义私有类型的表",
      "Filed 作用",
      "private L name 节点名字",
      "private Map<L,Integer> sources 所有以name为目标节点的边",
      "<起始节点name,边的权重>",
      "private Map<L,Integer> targets 所有以name为起始节点的边",
      "<目标节点name,边的权重>",
      "2、在Vertex需要实现的方法:Interface 作用",
      "private void checkRep() 检查表示不变性",
      "每个边的权值应该大于0",
      "public L getname) 返回该节点的name",
      "public Map<L,Integer> getsources() 根据传入的targets参数寻找以targe为终点的边",
      "返回一个键值对为（点，权重）的map",
      "public Map<L,Integer> gettargets() 根据传入的sources参数寻找以targe为终点的边",
      "返回一个键值对为（点，权重）的map",
      "public int addsource(L newsource,int weight) 加入一条以source为起点",
      "当前顶点为终点的边",
      "即将source, weight加入sources",
      "public int addtarget(L newtarget,int weight) 加入一条以当前点为起点",
      "当前target为终点的边",
      "即将target, weight加入targets",
      "public int removesource(L newsource) 在源点表中删除某起始点",
      "并返回旧的边长",
      "public int removetarget(L newtarget) 在终点表中删除某终点",
      "并返回旧的边长",
      "public String toString() 得到一个点的字符串表示",
      "3、AF,RI和Safety from rep exposure：4、测试策略：3.1.3.2.2实现ConcreteVerticeGraph:1、ConcreteVerticesGraph的字段为Vertex构成的List",
      "定义私有类型的表：2、在ConcreteVerticesGraph需要实现的方法：Method 实现思路",
      "private void checkRep() 检查表示不变性",
      "vertices中没有重复点",
      "public boolean add(L vertex) 检查输入满足vertex!=null",
      "添加一个顶点进入点表中",
      "public int set(L source, L target, int weight) 输入source",
      "target",
      "weight",
      "分别为边的起点、终点和权值",
      "若权值为负，返回-1",
      "若权值为正且新边已经存在，则除去原边并添加新边",
      "若权值为正且新边不存在，则直接添加新边",
      "若权值为0且新边已经存在，则出去原边",
      "只要改变了原边权值，都返回原边权值，没有权值则返回0",
      "public boolean remove(L vertex) 除去某个点及与它相邻的所有边",
      "只需要遍历vertices",
      "寻找是否有与待删除点相同的名字的点直接删去即可",
      "如果名字不相同",
      "则在该点的源点表和终点表中寻找删去即可",
      "使用迭代器实现",
      "public Set vertices 返回所有的点集",
      "public Map<L, Integer> sources(L target) 输入一个终点",
      "返回与它相连的所有边和起点构成的Map",
      "public Map<L, Integer> targets(L source) 输入一个起点",
      "返回与它相连的所有边和终点构成为的Map",
      "public String toString() 将整个图中所有点的指向转化为一条字符串输出",
      "3、AF,RI和Safety from rep exposure如下图：4、测试策略：继承Graph的测试策略并增加toString的测试",
      "测试结果：检查覆盖率：3.1.4 Problem 3: Implement generic Graph：3.1.4.1 Make the implementations generic",
      "将所有String改为L",
      "并且Edge需改为Edge",
      "Vertex需改为Vertex",
      "3.1.4.2 Implement Graph.empty()",
      "选择ConcreteEdgesGraph作为Graph.empty()的实现类",
      "返回new ConcreteEdgesGraph",
      "测试策略：测试结果：覆盖率：3.1.5 Problem 4: Poetic walks",
      "任务要求我们实现一个类",
      "利用之前实现的图结构",
      "能够将语料库转化为该种图结构",
      "并且在图中搜索",
      "完成对输入的诗句的句子进行扩充",
      "3.1.5.1 Test GraphPoet",
      "测试策略：GraphPoet()考虑到了输入文件是否存在、文件中含有多个连续空格、大小写、换行符、空行、标点符号、重复的词以及连续的词或词组等特殊情况",
      "依此设计测试用例；poem()图中没有的词、相邻的两个词、两个词之间的路径经过多个词的情况不作改变；存在两个词在图中有一条只经过一个桥接词的路径；存在两个词在图中有多条只经过一个桥接词的路径",
      "具体实现读入一系列满足要求的文件：测试结果为：测试覆盖率为：3.1.5.2 Implement GraphPoet",
      "1、构造器GraphPoet(File corpus)",
      "一行一行读入文件",
      "以空格为界将词分开存入列表",
      "以每两个连续的词作为顶点",
      "这两个顶点之间有边",
      "记录两个词连续出现的次数作为边权",
      "观察器poem(String input)",
      "输入需要进行扩充的字符串",
      "声明声明一个StringBuilder保存",
      "每次读取一个词",
      "当前词作为source",
      "下一个词作为target",
      "然后在garph中寻找source的终点表中是否有与target的源点表中相同的元素",
      "并且找到权值最大的和的点加入source和target之间",
      "返回扩充后的字符串",
      "Checkrep",
      "检查是否符合RI：图中每个词都不是空",
      "不含有空格和换行符",
      "都是小写",
      "每个词都有边与之相连",
      "toString",
      "调用ConcreteEdgesGraph中的toString方法",
      "将整个图中所有点的指向转化为一条字符串输出",
      "2、 AF,RI和Safety from rep exposure如下图：3.1.5.3 Graph poetry slam",
      "运行main函数如下输出：3.1.6 Before you’re done",
      "如何通过Git提交当前版本到GitHub上你的Lab2仓库",
      "在这里给出你的项目的目录结构树状示意图",
      "3.2Re-implement the Social Network in Lab1",
      "这次实验要求我们基于Poetic Walks中定义的Graph及其两种实现（本人使用的是ConcreteVerticesGraph）",
      "实现Lab1中Social NetWorek中的各种功能",
      "并且尽可能复用ConcreteVerticesGraph中已经实现的方法",
      "然后运行提供的main()和执行Lab1中的Junit测试用例",
      "使之正常运行",
      "3.2.1 FriendshipGraph类",
      "(1).FriendshipGraph的字段为Person构成的ConcreteEdgesGraph",
      "定义私有类型的表如下图所示：(2).在FriendshipGraph需要实现的方法如下图所示：FriendshipGraph 构造方法",
      "addVertex 在图中增加新Person",
      "只需要调用ConcreteEdgesGraph中的add即可：addEdge 为某个人增加朋友,a为这个人",
      "b为增加的朋友,直接调用ConcreteEdgesGraph中的set即可：getallprople 直接返回即可：getDistance 遍历顶点以及其sources",
      "根据广度优先算法",
      "构建队列",
      "将起点先加入队列",
      "然后每次从队头弹出一个点",
      "将其sources中还未在队列中的顶点压入队尾",
      "直到遍历到终点",
      "在这个过程中记录起点距每个点的距离即可",
      "若直到队空也没有遍历到终点，则返回-1",
      "main 复制Lab1的即可",
      "(3).AF,RI和Safety from rep exposure如下图：3.2.2 Person类",
      "(1).FriendshipGraph的字段为Person构成的ConcreteEdgesGraph",
      "定义私有类型的表如下图所示：(2).在FriendshipGraph需要实现的方法如下图所示：Person 没有重复名字则加入",
      "构造方法",
      "getmyname 返回本人名字，直接返回即可",
      "(3).AF,RI和Safety from rep exposure如下图：3.2.3 客户端main()",
      "复制Lab1 3.3中的main运行后如下：3.2.4 测试用例",
      "测试策略：与Lab1的测试策略相同：测试结果：检查覆盖率：(需要提前注释main()函数)：3.2.4 提交至Git仓库",
      "如何通过Git提交当前版本到GitHub上你的Lab2仓库",
      "与提交P1相似",
      "在这里给出你的项目的目录结构树状示意图",
      "4实验进度记录",
      "请使用表格方式记录你的进度情况",
      "以超过半小时的连续编程时间为一行",
      "每次结束编程时，请向该表格中增加一行",
      "不要事后胡乱填写",
      "不要嫌烦",
      "该表格可帮助你汇总你在每个任务上付出的时间和精力",
      "发现自己不擅长的任务",
      "后续有意识的弥补",
      "日期 时间段 计划任务 实际完成情况",
      "5.25 13:00-22:30 完成P1边图类 完成",
      "5.26 15：30-23：30 完成P1点图类 完成",
      "5.28 15：30-20：00 GraphPoet和poem 未按计划完成",
      "5.29 13：00-16：30 Poem 完成",
      "6.3 15：30-20：00 修改完善测试用例 完成",
      "6.4 14：30-19：30 FriendshipGraph 完成",
      "6.10 15：30-16：00 完善测试用例 完成",
      "6.11 13：00-16：00 完善报告 完成",
      "5实验过程中遇到的困难与解决途径",
      "遇到的难点 解决途径",
      "换成泛型后很多警告",
      "Git二次提交",
      "不太会使用git二次提交文件",
      "所以重新增加 master 重新push",
      "6实验过程中收获的经验、教训、感想",
      "6.1实验过程中收获的经验和教训",
      "在自行设计多种类来实现功能的情况下",
      "自己设计的很多类之间有很多重复和矛盾的部分",
      "很多关系弄不清楚",
      "6.2针对以下方面的感受",
      "(1)面向ADT的编程和直接面向应用场景编程",
      "你体会到二者有何差异？",
      "答：面向ADT需要考虑底层实现",
      "而面向应用场景无需了解ADT如何实现各种功能",
      "直接调用即可",
      "(2)使用泛型和不使用泛型的编程，对你来说有何差异？",
      "答：使用泛型应用范围更广",
      "但设计的时候需要考虑不能应用某一类型内部的方法；不使用泛型应用范围窄",
      "但设计时可以应用某一特定类型包装好的方法",
      "(3)在给出ADT的规约后就开始编写测试用例",
      "优势是什么？你是否能够适应这种测试方式？",
      "答：能够保证代码的正确性，及时修改",
      "不适应",
      "(4)P1设计的ADT在多个应用场景下使用",
      "这种复用带来什么好处？",
      "答：可以提高代码的利用率，减少重复",
      "(5)P3要求你从0开始设计ADT并使用它们完成一个具体应用",
      "你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系",
      "P3要求你自主设计这些内容",
      "你的感受如何？",
      "答：适应方式就是在应用场景时只考虑应用场景",
      "“忘记”ADT内部的具体实现方式",
      "自主实现感觉需要自己考虑的东西变多了",
      "(6)为ADT撰写specification, invariants, RI, AF",
      "时刻注意ADT是否有rep exposure",
      "这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？",
      "答：保证程序的安全性和健壮性",
      "可能很难坚持",
      "(7)关于本实验的工作量、难度、deadline",
      "答：感觉工作量还挺多的",
      "(8)《软件构造》课程进展到目前，你对该课程有何体会和建议？",
      "答：实验和课堂上的理论结合非常紧密"
    ],
    "codes": [
      "按照提示增加<>\n"
    ],
    "date": "2021-07-06",
    "text": "HIT软件构造lab2实验心得\n1实验目标概述\n本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说：\n针对给定的应用问题，从问题描述中识别所需的ADT；\n设计ADT规约（pre-condition、post-condition）并评估规约的质量；\n根据ADT的规约设计测试用例；\nADT的泛型化；\n根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function） 使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；\n测试ADT的实现并评估测试的覆盖度；\n使用ADT及其实现，为应用问题开发程序；\n测试代码中，能够写出testing strategy并据此设计测试用例。\n2实验环境配置\n根据实验手册中的网址，在eclipse中：help – Eclipse Marketplace – search – EclEmma Java Code Coverage – install 安装成功\nURL地址：\nhttps://github.com/ComputerScienceHIT/HIT-Lab2-1190202013\n3实验过程\n请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\n3.1Poetic Walks\nMIT指导页面链接：http://web.mit.edu/6.031/www/sp17/psets/ps2/\n该问题已经提供了ADT大体框架，graph的接口，要求我们建立一个边图类ConcreteEdgesGraph、一个点图类ConcreteVerticesGraph实现graph接口，实现抽象数据型，完成poet的工作。Graph接口要求实现add（添加新节点），set（添加新边），remove（移除节点），vertices（获得所有的节点集合），sources（target）获得以target为目标节点的边的起始节点，targes(source)获得以source为起始节点的边的目标节点。\nPoet：假设存在一条由a到b的有向边，构造有向图，再给定一句子，如果句子中两个相邻单词在有向图中有一个中间单词，则将该单词插入到a与b中间，若存在多个中间单词，则插入权重最大的那个\n3.1.1Get the code and prepare Git repository\n如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。\n网址：https://github.com/rainywang/Spring2020_HITCS_SC_Lab2/tree/master/P1\ngitbash直接执行git clone https://github.com/rainywang/Spring2020_HITCS_SC_Lab2.git下载工程文件\ngit clone https://github.com/ComputerScienceHIT/Lab2-1190202013.git\n本地仓库建好\n3.1.2Problem 1: Test Graph\n 以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。\n针对Graph设计测试策略，编写测试用例主要利用等价类划分的思想进行测试。\n过程：用String类为Graph编写测试用例。共需编写六个函数的测试用例：add, set, remove, vertices, sources, targets。add, set, remove属于mutator；vertices, sources, targets属于observer。如下所示，为所有方法的测试策略\n将Graph中的empty()方法修改为：\n并对GraphStaticTest进行JUnit测试，如下：\n用String类为Graph编写测试用例。共需编写六个函数的测试用例：add, set, remove, vertices, sources, targets。add, set, remove属于mutator；vertices, sources, targets属于observer\n在coverage中查看覆盖率如下\n3.1.3Problem 2: Implement Graph\n 分别实现两个实现类ConcreteEgesGraph和ConcreteVerticesGraph，需标注创建的每一个类的AF和RI，如何防止表示泄露。使用函数checkRep来检验是否符合RI，重写toString函数以便输出该类信息。\n3.1.3.1Implement ConcreteEdgesGraph\n3.1.3.1.1实现Edge:\n1、EDGE中的字段包括边的起始节点、目标节点和边权值，定义为私有类型变量，信息对外界隐藏，使用final是其值不可变，防止外部对内部引用使其泄露。\n2、实现Edge需要实现的方法：\nFileds 作用\nprivate final L source 起始节点\nprivate final L target 目标节点\nprivate final int weight 边权值\nMethod 作用\nEdge 初始化构造方法，初始化边的起始节点和目标节点和边权值\ncheckRep() 检查表示不变性，两点不为null且权值非负\ngetsource() 返回有向边起始节点\ngettarget() 返回有向边目标节点\ngetweight() 返回边权值\n@Override toString() 使用@Override注释toString以确保正确覆盖Object方法的toString方法\n3、AF、RI和Safety from rep exposure\n4、Edge测试策略：\n3.1.3.1.2实现ConcreteEdgesGraph类：\n1、ConcreteEdgesGraph字段中包括顶点set表和边list表，定义私有类型的表如下图所示：\n2、实现ConcreteEdgesGraph需要实现的方法：\nMethod 作用\nprivate void checkRep() 检查表示不变性，edges长度是大于0的实数，有起始的节点\npublic boolean add(L vertex) 调用vertices.add，其返回结果为boolean且满足spec定义。\npublic int set(L source, L target, int weight) 前置条件要求weight>=0，如果weight<0，输出提示信息。在weight>=0的条件下，对图的边表进行遍历，若存在顶点为source，终点为target的边，保存这条边原本的权值，否则设为0。如果weight>0，则将这条边及顶点加入或者修改原有边的权值；如果weight=0，删除这条边。返回原本的权值。\npublic boolean remove(L vertex) 从vertices中删去，传入的参数vertex点，遍历edges，寻找是否有边的起点或者是终点是该vertex，删去。注意在使用迭代器遍历时要使用iterator.remove方法保证安全。\npublic Set vertices() 返回vertices集合\npublic Map<L, Integer> sources(L target) 根据传入的target参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。\npublic Map<L, Integer> targets(L source) 根据传入的source参数寻找以source为起点的边。实现同上\npublic String toString() 将整个图中所有点的指向转化为一条字符串输出\n3、AF,RI和Safety from rep exposure\n4、测试策略：继承Graph的测试策略，并增加toString的测试\n测试结果如下：\n检查覆盖率：\n3.1.3.2Implement ConcreteVerticesGraph\n3.1.3.2.1实现Vertex：\n1、字段中应当包括点的名字，点的源点表Map，点的终点表Map，定义私有类型的表\nFiled 作用\nprivate L name 节点名字\nprivate Map<L,Integer> sources 所有以name为目标节点的边，<起始节点name,边的权重>\nprivate Map<L,Integer> targets 所有以name为起始节点的边，<目标节点name,边的权重>\n2、在Vertex需要实现的方法:\nInterface 作用\nprivate void checkRep() 检查表示不变性，每个边的权值应该大于0\npublic L getname) 返回该节点的name\npublic Map<L,Integer> getsources() 根据传入的targets参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。\npublic Map<L,Integer> gettargets() 根据传入的sources参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。\npublic int addsource(L newsource,int weight) 加入一条以source为起点，当前顶点为终点的边，即将source, weight加入sources\npublic int addtarget(L newtarget,int weight) 加入一条以当前点为起点，当前target为终点的边，即将target, weight加入targets\npublic int removesource(L newsource) 在源点表中删除某起始点，并返回旧的边长\npublic int removetarget(L newtarget) 在终点表中删除某终点，并返回旧的边长\npublic String toString() 得到一个点的字符串表示\n3、AF,RI和Safety from rep exposure：\n4、测试策略：\n3.1.3.2.2实现ConcreteVerticeGraph:\n1、ConcreteVerticesGraph的字段为Vertex构成的List，定义私有类型的表：\n2、在ConcreteVerticesGraph需要实现的方法：\nMethod 实现思路\nprivate void checkRep() 检查表示不变性，vertices中没有重复点\npublic boolean add(L vertex) 检查输入满足vertex!=null，添加一个顶点进入点表中\npublic int set(L source, L target, int weight) 输入source，target，weight，分别为边的起点、终点和权值。若权值为负，返回-1。若权值为正且新边已经存在，则除去原边并添加新边。若权值为正且新边不存在，则直接添加新边。若权值为0且新边已经存在，则出去原边。只要改变了原边权值，都返回原边权值，没有权值则返回0\npublic boolean remove(L vertex) 除去某个点及与它相邻的所有边。只需要遍历vertices，寻找是否有与待删除点相同的名字的点直接删去即可，如果名字不相同，则在该点的源点表和终点表中寻找删去即可，使用迭代器实现。\npublic Set vertices 返回所有的点集\npublic Map<L, Integer> sources(L target) 输入一个终点，返回与它相连的所有边和起点构成的Map\npublic Map<L, Integer> targets(L source) 输入一个起点，返回与它相连的所有边和终点构成为的Map\npublic String toString() 将整个图中所有点的指向转化为一条字符串输出\n3、AF,RI和Safety from rep exposure如下图：\n4、测试策略：继承Graph的测试策略并增加toString的测试\n测试结果：\n检查覆盖率：\n3.1.4 Problem 3: Implement generic Graph：\n3.1.4.1 Make the implementations generic\n将所有String改为L，并且Edge需改为Edge，Vertex需改为Vertex。\n3.1.4.2 Implement Graph.empty()\n选择ConcreteEdgesGraph作为Graph.empty()的实现类，返回new ConcreteEdgesGraph\n测试策略：\n测试结果：\n覆盖率：\n3.1.5 Problem 4: Poetic walks\n任务要求我们实现一个类，利用之前实现的图结构，能够将语料库转化为该种图结构，并且在图中搜索，完成对输入的诗句的句子进行扩充。\n3.1.5.1 Test GraphPoet\n测试策略：\nGraphPoet()考虑到了输入文件是否存在、文件中含有多个连续空格、大小写、换行符、空行、标点符号、重复的词以及连续的词或词组等特殊情况，依此设计测试用例；\npoem()图中没有的词、相邻的两个词、两个词之间的路径经过多个词的情况不作改变；存在两个词在图中有一条只经过一个桥接词的路径；存在两个词在图中有多条只经过一个桥接词的路径。\n具体实现读入一系列满足要求的文件：\n测试结果为：\n测试覆盖率为：\n3.1.5.2 Implement GraphPoet\n1、构造器GraphPoet(File corpus)\n一行一行读入文件，以空格为界将词分开存入列表，以每两个连续的词作为顶点，这两个顶点之间有边，记录两个词连续出现的次数作为边权。\n观察器poem(String input)\n输入需要进行扩充的字符串，声明声明一个StringBuilder保存，每次读取一个词，当前词作为source，下一个词作为target，然后在garph中寻找source的终点表中是否有与target的源点表中相同的元素，并且找到权值最大的和的点加入source和target之间，返回扩充后的字符串。\nCheckrep\n检查是否符合RI：图中每个词都不是空，不含有空格和换行符，都是小写，每个词都有边与之相连。\ntoString\n调用ConcreteEdgesGraph中的toString方法，将整个图中所有点的指向转化为一条字符串输出\n2、 AF,RI和Safety from rep exposure如下图：\n3.1.5.3 Graph poetry slam\n运行main函数如下输出：\n3.1.6 Before you’re done\n如何通过Git提交当前版本到GitHub上你的Lab2仓库。\n在这里给出你的项目的目录结构树状示意图。\n3.2Re-implement the Social Network in Lab1\n这次实验要求我们基于Poetic Walks中定义的Graph及其两种实现（本人使用的是ConcreteVerticesGraph），实现Lab1中Social NetWorek中的各种功能，并且尽可能复用ConcreteVerticesGraph中已经实现的方法，然后运行提供的main()和执行Lab1中的Junit测试用例，使之正常运行。\n3.2.1 FriendshipGraph类\n(1).FriendshipGraph的字段为Person构成的ConcreteEdgesGraph，定义私有类型的表如下图所示：\n(2).在FriendshipGraph需要实现的方法如下图所示：\nFriendshipGraph 构造方法\naddVertex 在图中增加新Person，只需要调用ConcreteEdgesGraph中的add即可：\naddEdge 为某个人增加朋友,a为这个人，b为增加的朋友,直接调用ConcreteEdgesGraph中的set即可：\ngetallprople 直接返回即可：\ngetDistance 遍历顶点以及其sources，根据广度优先算法，构建队列。将起点先加入队列，然后每次从队头弹出一个点，将其sources中还未在队列中的顶点压入队尾，直到遍历到终点。在这个过程中记录起点距每个点的距离即可。若直到队空也没有遍历到终点，则返回-1。\nmain 复制Lab1的即可\n(3).AF,RI和Safety from rep exposure如下图：\n3.2.2 Person类\n(1).FriendshipGraph的字段为Person构成的ConcreteEdgesGraph，定义私有类型的表如下图所示：\n(2).在FriendshipGraph需要实现的方法如下图所示：\nPerson 没有重复名字则加入，构造方法\ngetmyname 返回本人名字，直接返回即可\n(3).AF,RI和Safety from rep exposure如下图：\n3.2.3 客户端main()\n复制Lab1 3.3中的main运行后如下：\n3.2.4 测试用例\n测试策略：\n与Lab1的测试策略相同：\n测试结果：\n检查覆盖率：(需要提前注释main()函数)：\n3.2.4 提交至Git仓库\n如何通过Git提交当前版本到GitHub上你的Lab2仓库。\n与提交P1相似\n在这里给出你的项目的目录结构树状示意图。\n4实验进度记录\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。\n不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。\n日期 时间段 计划任务 实际完成情况\n5.25 13:00-22:30 完成P1边图类 完成\n5.26 15：30-23：30 完成P1点图类 完成\n5.28 15：30-20：00 GraphPoet和poem 未按计划完成\n5.29 13：00-16：30 Poem 完成\n6.3 15：30-20：00 修改完善测试用例 完成\n6.4 14：30-19：30 FriendshipGraph 完成\n6.10 15：30-16：00 完善测试用例 完成\n6.11 13：00-16：00 完善报告 完成\n5实验过程中遇到的困难与解决途径\n遇到的难点 解决途径\n换成泛型后很多警告\nGit二次提交\n不太会使用git二次提交文件，所以重新增加 master 重新push\n6实验过程中收获的经验、教训、感想\n6.1实验过程中收获的经验和教训\n在自行设计多种类来实现功能的情况下，自己设计的很多类之间有很多重复和矛盾的部分，很多关系弄不清楚\n6.2针对以下方面的感受\n(1)面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？\n答：面向ADT需要考虑底层实现，而面向应用场景无需了解ADT如何实现各种功能，直接调用即可。\n(2)使用泛型和不使用泛型的编程，对你来说有何差异？\n答：使用泛型应用范围更广，但设计的时候需要考虑不能应用某一类型内部的方法；不使用泛型应用范围窄，但设计时可以应用某一特定类型包装好的方法。\n(3)在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？\n答：能够保证代码的正确性，及时修改。不适应。\n(4)P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？\n答：可以提高代码的利用率，减少重复。\n(5)P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？\n答：适应方式就是在应用场景时只考虑应用场景，“忘记”ADT内部的具体实现方式。自主实现感觉需要自己考虑的东西变多了。\n(6)为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？\n答：保证程序的安全性和健壮性。可能很难坚持。\n(7)关于本实验的工作量、难度、deadline。\n答：感觉工作量还挺多的。\n(8)《软件构造》课程进展到目前，你对该课程有何体会和建议？\n答：实验和课堂上的理论结合非常紧密。\n"
  },
  {
    "head": "HIT软件构造笔记一",
    "paragraphs": [
      "软件构造复习笔记一",
      "1.1软件构造过程中的多维度视图",
      "1、多维度视图",
      "(1) Build-time, moment, and code-level view 关注的是源码的组织情况，可在词汇（源码）、语法（抽象语法树）、语义（类图）三个层面分别分析。",
      "(2) Build-time, period, and code-level view 关注的是代码的变化（Code churn代码变化）",
      "(3) Build-time, moment, and component-level view 关注的是包/库，而且是静态链接库",
      "(4) Build-time, period, and component-level view 关注代码的更迭，与(2)中不同的是，这个维度下更关注文件版本的变化，而不是具体语句的变化（2中关注的是哪一行代码被修改了）",
      "(5) Run-time, moment, and code-level view 关注的是程序在某个时间点内存中的情况，如代码快照图(Code Snapshot)、内存信息转储(Memory dump)。",
      "(6) Run-time, period and code-level view 关注的是代码的执行情况，执行跟踪",
      "(7) Run-time, moment, and component-level view 关注的也是包/库，但却是在代码执行过程中的情况，如动态链接库",
      "(8) Run-time, period, and component-level view 关注的是系统的使用情况，使用日志查看",
      "2、视图之间的联系",
      "代码是一个从无到有的过程，也就空集 -> Code，而有了代码之后程序必定会随着代码行的增加而逐步完善，最后被封装，也就是Code->Component这个过程。当程序构建成功后需要运行，也就是Build-time->Run-time，最后我们还可能需要多次修改调整程序，或者记录程序版本变化，也就需要Moment->Period维度的转变。",
      "1.2 Quality Objectives of Software Construction",
      "软件系统的质量",
      "外部质量因素",
      "（1）正确性",
      "正确性是软件产品能够正确的执行任务的能力，是首要的质量目标。保证正确性的途径是有条件的。",
      "一个软件系统设计多个层面，所以不可能仅仅靠每个构件和属性的正确性来保证整体的正确性，各层之间是相互依赖的。",
      "（2）健壮性",
      "健壮性是软件系统对异常情况做出适当反应的能力。",
      "健壮性补充了正确性。",
      "正确性解决了系统在其规范所涵盖的情况下的行为；",
      "健壮性描述了在该规范之外发生的事情。",
      "健壮性是确保如果出现此类情况，系统不会导致灾难性事件；它应生成适当的错误消息，干净地终止执行，或进入所谓的“优雅降级”模式。",
      "健壮性同异常情况相关，异常或非异常取决于程序的规格说明，异常情况是程序的规格说明中没有涉及的部分。",
      "判断是否异常是异常的标准，不取决于客观的正确标准，而取决于程序的规格说明。",
      "（3）可扩展性",
      "可扩展性是指软件易于调整以适应变化的能力。可扩展性同规模密切相关，越大越难以扩展。",
      "软件是易变的，需要可扩展性。",
      "传统方法最初冻结需求，假设没有变化，因此难以适应变化",
      "两个提高可扩展性的原则：",
      "简单的体系结构总是比复杂的体系更容易适应变化。",
      "模块自治性越强，变化时对其余模块影响越小。",
      "（4）重用性",
      "软件经常遇到相似的模式，利用共性，避免重复实现。",
      "（5）兼容性",
      "兼容性是指软件元素易于与其他的组合。因为我们的软件并非运行在真空中，但难点在于不同的软件有不同的设定。所以，解决兼容性的关键是标准性，例如规定文件格式、数据结构、用户接口等。更通用的方法是通过协议来实现更通用的兼容性。",
      "（6）效率",
      "效率是软件系统对硬件资源尽可能少的需求的能力，但前提是软件的正确性，并且需要与其他目标进行权衡。",
      "（7）可移植性",
      "可移植性是指便于将软件产品转移到各种硬件和软件环境。",
      "（8）易用性",
      "用户可以轻松掌握软件的使用，也包括安装、运行和监控的容易度 。既方便初学者入门，也不影响熟练的用户直接使用。一个关键是结构要简洁，理解用户，换位思考，站在用户的角度设计软件。",
      "（9）功能性",
      "增加功能的同时也要防止陷入“蠕变特性”，即程序设计中一种不 适宜的趋势，即软件开发者增加越来越多的功能，企图跟上竞争，其 结果是程序极为复杂、不灵活、占用过多的磁盘空间 。过多的新功能容易带来一 致性的缺失，影响易用性 。",
      "在质量提升技术的帮助下，可以在整个项目中保持质量水平不变，而不仅仅 是功能性。",
      "（10）及时性",
      "及时性是指软件系统能够在用户需要时或者需要需要之前发布",
      "内部质量因素",
      "圈复杂度：用来衡量一个模块判定结构的复杂程度 。",
      "耦合度：设计中追求高内聚和低耦合。",
      "可读性、易理解性、清晰度、复杂度、体积",
      "内部质量因素通常用作外部质量因素的部分度量。",
      "正确性是绝不能与其他质量因素折中的！！！"
    ],
    "sentences": [
      "软件构造复习笔记一",
      "1.1软件构造过程中的多维度视图",
      "1、多维度视图",
      "(1) Build-time, moment, and code-level view 关注的是源码的组织情况",
      "可在词汇（源码）、语法（抽象语法树）、语义（类图）三个层面分别分析",
      "(2) Build-time, period, and code-level view 关注的是代码的变化（Code churn代码变化）",
      "(3) Build-time, moment, and component-level view 关注的是包/库",
      "而且是静态链接库",
      "(4) Build-time, period, and component-level view 关注代码的更迭",
      "与(2)中不同的是",
      "这个维度下更关注文件版本的变化",
      "而不是具体语句的变化（2中关注的是哪一行代码被修改了）",
      "(5) Run-time, moment, and code-level view 关注的是程序在某个时间点内存中的情况",
      "如代码快照图(Code Snapshot)、内存信息转储(Memory dump)",
      "(6) Run-time, period and code-level view 关注的是代码的执行情况",
      "执行跟踪",
      "(7) Run-time, moment, and component-level view 关注的也是包/库",
      "但却是在代码执行过程中的情况",
      "如动态链接库",
      "(8) Run-time, period, and component-level view 关注的是系统的使用情况",
      "使用日志查看",
      "2、视图之间的联系",
      "代码是一个从无到有的过程",
      "也就空集 -> Code",
      "而有了代码之后程序必定会随着代码行的增加而逐步完善",
      "最后被封装",
      "也就是Code->Component这个过程",
      "当程序构建成功后需要运行",
      "也就是Build-time->Run-time",
      "最后我们还可能需要多次修改调整程序",
      "或者记录程序版本变化",
      "也就需要Moment->Period维度的转变",
      "1.2 Quality Objectives of Software Construction",
      "软件系统的质量",
      "外部质量因素",
      "（1）正确性",
      "正确性是软件产品能够正确的执行任务的能力，是首要的质量目标",
      "保证正确性的途径是有条件的",
      "一个软件系统设计多个层面",
      "所以不可能仅仅靠每个构件和属性的正确性来保证整体的正确性",
      "各层之间是相互依赖的",
      "（2）健壮性",
      "健壮性是软件系统对异常情况做出适当反应的能力",
      "健壮性补充了正确性",
      "正确性解决了系统在其规范所涵盖的情况下的行为；健壮性描述了在该规范之外发生的事情",
      "健壮性是确保如果出现此类情况",
      "系统不会导致灾难性事件；它应生成适当的错误消息",
      "干净地终止执行",
      "或进入所谓的“优雅降级”模式",
      "健壮性同异常情况相关",
      "异常或非异常取决于程序的规格说明",
      "异常情况是程序的规格说明中没有涉及的部分",
      "判断是否异常是异常的标准",
      "不取决于客观的正确标准",
      "而取决于程序的规格说明",
      "（3）可扩展性",
      "可扩展性是指软件易于调整以适应变化的能力",
      "可扩展性同规模密切相关，越大越难以扩展",
      "软件是易变的，需要可扩展性",
      "传统方法最初冻结需求，假设没有变化，因此难以适应变化",
      "两个提高可扩展性的原则：简单的体系结构总是比复杂的体系更容易适应变化",
      "模块自治性越强，变化时对其余模块影响越小",
      "（4）重用性",
      "软件经常遇到相似的模式，利用共性，避免重复实现",
      "（5）兼容性",
      "兼容性是指软件元素易于与其他的组合",
      "因为我们的软件并非运行在真空中",
      "但难点在于不同的软件有不同的设定",
      "所以",
      "解决兼容性的关键是标准性",
      "例如规定文件格式、数据结构、用户接口等",
      "更通用的方法是通过协议来实现更通用的兼容性",
      "（6）效率",
      "效率是软件系统对硬件资源尽可能少的需求的能力",
      "但前提是软件的正确性",
      "并且需要与其他目标进行权衡",
      "（7）可移植性",
      "可移植性是指便于将软件产品转移到各种硬件和软件环境",
      "（8）易用性",
      "用户可以轻松掌握软件的使用，也包括安装、运行和监控的容易度 ",
      "既方便初学者入门，也不影响熟练的用户直接使用",
      "一个关键是结构要简洁",
      "理解用户",
      "换位思考",
      "站在用户的角度设计软件",
      "（9）功能性",
      "增加功能的同时也要防止陷入“蠕变特性”",
      "即程序设计中一种不 适宜的趋势",
      "即软件开发者增加越来越多的功能",
      "企图跟上竞争",
      "其 结果是程序极为复杂、不灵活、占用过多的磁盘空间 ",
      "过多的新功能容易带来一 致性的缺失，影响易用性 ",
      "在质量提升技术的帮助下",
      "可以在整个项目中保持质量水平不变",
      "而不仅仅 是功能性",
      "（10）及时性",
      "及时性是指软件系统能够在用户需要时或者需要需要之前发布",
      "内部质量因素",
      "圈复杂度：用来衡量一个模块判定结构的复杂程度 ",
      "耦合度：设计中追求高内聚和低耦合",
      "可读性、易理解性、清晰度、复杂度、体积",
      "内部质量因素通常用作外部质量因素的部分度量",
      "正确性是绝不能与其他质量因素折中的！！！"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "软件构造复习笔记一\n1.1软件构造过程中的多维度视图\n1、多维度视图\n(1) Build-time, moment, and code-level view 关注的是源码的组织情况，可在词汇（源码）、语法（抽象语法树）、语义（类图）三个层面分别分析。\n(2) Build-time, period, and code-level view 关注的是代码的变化（Code churn代码变化）\n(3) Build-time, moment, and component-level view 关注的是包/库，而且是静态链接库\n(4) Build-time, period, and component-level view 关注代码的更迭，与(2)中不同的是，这个维度下更关注文件版本的变化，而不是具体语句的变化（2中关注的是哪一行代码被修改了）\n(5) Run-time, moment, and code-level view 关注的是程序在某个时间点内存中的情况，如代码快照图(Code Snapshot)、内存信息转储(Memory dump)。\n(6) Run-time, period and code-level view 关注的是代码的执行情况，执行跟踪\n(7) Run-time, moment, and component-level view 关注的也是包/库，但却是在代码执行过程中的情况，如动态链接库\n(8) Run-time, period, and component-level view 关注的是系统的使用情况，使用日志查看\n2、视图之间的联系\n代码是一个从无到有的过程，也就空集 -> Code，而有了代码之后程序必定会随着代码行的增加而逐步完善，最后被封装，也就是Code->Component这个过程。当程序构建成功后需要运行，也就是Build-time->Run-time，最后我们还可能需要多次修改调整程序，或者记录程序版本变化，也就需要Moment->Period维度的转变。\n1.2 Quality Objectives of Software Construction\n软件系统的质量\n外部质量因素\n（1）正确性\n正确性是软件产品能够正确的执行任务的能力，是首要的质量目标。保证正确性的途径是有条件的。\n一个软件系统设计多个层面，所以不可能仅仅靠每个构件和属性的正确性来保证整体的正确性，各层之间是相互依赖的。\n（2）健壮性\n健壮性是软件系统对异常情况做出适当反应的能力。\n健壮性补充了正确性。\n正确性解决了系统在其规范所涵盖的情况下的行为；\n健壮性描述了在该规范之外发生的事情。\n健壮性是确保如果出现此类情况，系统不会导致灾难性事件；它应生成适当的错误消息，干净地终止执行，或进入所谓的“优雅降级”模式。\n健壮性同异常情况相关，异常或非异常取决于程序的规格说明，异常情况是程序的规格说明中没有涉及的部分。\n判断是否异常是异常的标准，不取决于客观的正确标准，而取决于程序的规格说明。\n（3）可扩展性\n可扩展性是指软件易于调整以适应变化的能力。可扩展性同规模密切相关，越大越难以扩展。\n软件是易变的，需要可扩展性。\n传统方法最初冻结需求，假设没有变化，因此难以适应变化\n两个提高可扩展性的原则：\n简单的体系结构总是比复杂的体系更容易适应变化。\n模块自治性越强，变化时对其余模块影响越小。\n（4）重用性\n软件经常遇到相似的模式，利用共性，避免重复实现。\n（5）兼容性\n兼容性是指软件元素易于与其他的组合。因为我们的软件并非运行在真空中，但难点在于不同的软件有不同的设定。所以，解决兼容性的关键是标准性，例如规定文件格式、数据结构、用户接口等。更通用的方法是通过协议来实现更通用的兼容性。\n（6）效率\n效率是软件系统对硬件资源尽可能少的需求的能力，但前提是软件的正确性，并且需要与其他目标进行权衡。\n（7）可移植性\n可移植性是指便于将软件产品转移到各种硬件和软件环境。\n（8）易用性\n用户可以轻松掌握软件的使用，也包括安装、运行和监控的容易度 。既方便初学者入门，也不影响熟练的用户直接使用。一个关键是结构要简洁，理解用户，换位思考，站在用户的角度设计软件。\n（9）功能性\n增加功能的同时也要防止陷入“蠕变特性”，即程序设计中一种不 适宜的趋势，即软件开发者增加越来越多的功能，企图跟上竞争，其 结果是程序极为复杂、不灵活、占用过多的磁盘空间 。过多的新功能容易带来一 致性的缺失，影响易用性 。\n在质量提升技术的帮助下，可以在整个项目中保持质量水平不变，而不仅仅 是功能性。\n（10）及时性\n及时性是指软件系统能够在用户需要时或者需要需要之前发布\n内部质量因素\n圈复杂度：用来衡量一个模块判定结构的复杂程度 。\n耦合度：设计中追求高内聚和低耦合。\n可读性、易理解性、清晰度、复杂度、体积\n内部质量因素通常用作外部质量因素的部分度量。\n正确性是绝不能与其他质量因素折中的！！！\n"
  },
  {
    "head": "HIT软件构造笔记六",
    "paragraphs": [
      "HIT软件构造笔记六",
      "一.可复用性的度量、形态与外部表现",
      "1.可复用性的评估",
      "评估的方面：复用的频繁性、复用的代价 (适配)",
      "一个有高可复用性的代码应该有如下特点：小、简单；与标准兼容；灵活可变；可扩展；泛型、参数化；模块化；变化的局部性；稳定；丰富的文档和帮助。",
      "2、复用的层面",
      "两种复用的方式：白盒复用和黑盒复用。黑盒复用就类似于调用API接口，或者方法等等；白盒复用是直接得到想要复用的源代码(或其他内容)等等，然后自己根据需要进行修改。",
      "根据复用内容的结构从小到大，分为如下四种复用。",
      "(1).源代码级别的复用:这个是最底层的复用，就是简单的复制粘贴修改。",
      "(2).模块级复用:以class作为最基本的单元，复用的方式有继承和委托，其中委托的耦合度明显低于继承。",
      "(3).类库级重用:相当于把一系列的class进行了打包，类似于第三方库的调用。",
      "(4).框架级复用:在框架的基础上，填充自己的代码，形成完整系统。(其实就类似于一些实验中，给出了很多代码，要求我们填入一些自己的代码)",
      "二．面向复用的软件构造技术",
      "1、LSP与泛型中的运用",
      "Liskov替换原则，从实际设计的角度来说，这个原则其实就是对子类型的约束：要求子类型对象完全可以当作父类型的对象来使用，其中就包括了规约的前置条件不能强化，后置条件不能弱化，要保持不变量等等。",
      "下面介绍协变与异变的概念。",
      "协变：子类对父类方法的覆写中，异常、返回值的类型是父类方法中返回值的类型的子类型，就称之为协变。",
      "逆变：顾名思义，与协变恰恰相反。",
      "因此为了复合Liskov替换原则，我们要求如果有变化的话，那异常，返回值必须是协变，参数必须是异变(当然，在java语言中参数的异变或协变导致方法不再是覆写，而是重载)。",
      "java中的泛型是类型不变的，如下图所示，是十分经典的例子。如果想进行协变或逆变，则需要使用通配符，例如List<? extends Number>是List < Number>的子类型，但是不论如何都要确保一个List中的元素都是一种类型的(尽管多种元素都可以放入)。",
      "2、委托与组合",
      "委派/委托：一个对象请求另一个对象的功能。",
      "四种委派方式：",
      "①Dependency：依赖关系，临时性的delegation",
      "②Association：关联关系，永久性的delegation。",
      "③Composition: 更强的association，但难以变化。",
      "④Aggregation: 更弱的association，可动态变化。",
      "组合：利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。",
      "3、框架framework",
      "黑盒框架：通过实现特定接口进行框架扩展，采用的是delegation机制达到这种目的，通常采用的设计模式是策略模式(Strategy)和观察者模式(Observer)",
      "白盒框架：通过继承和重写实现功能的扩展，通常的设计模式是模板模式(Template Method)。"
    ],
    "sentences": [
      "HIT软件构造笔记六",
      "一.可复用性的度量、形态与外部表现",
      "1.可复用性的评估",
      "评估的方面：复用的频繁性、复用的代价 (适配)",
      "一个有高可复用性的代码应该有如下特点：小、简单；与标准兼容；灵活可变；可扩展；泛型、参数化；模块化；变化的局部性；稳定；丰富的文档和帮助",
      "2、复用的层面",
      "两种复用的方式：白盒复用和黑盒复用",
      "黑盒复用就类似于调用API接口",
      "或者方法等等；白盒复用是直接得到想要复用的源代码(或其他内容)等等",
      "然后自己根据需要进行修改",
      "根据复用内容的结构从小到大，分为如下四种复用",
      "(1).源代码级别的复用:这个是最底层的复用",
      "就是简单的复制粘贴修改",
      "(2).模块级复用:以class作为最基本的单元",
      "复用的方式有继承和委托",
      "其中委托的耦合度明显低于继承",
      "(3).类库级重用:相当于把一系列的class进行了打包",
      "类似于第三方库的调用",
      "(4).框架级复用:在框架的基础上",
      "填充自己的代码",
      "形成完整系统",
      "(其实就类似于一些实验中",
      "给出了很多代码",
      "要求我们填入一些自己的代码)",
      "二．面向复用的软件构造技术",
      "1、LSP与泛型中的运用",
      "Liskov替换原则",
      "从实际设计的角度来说",
      "这个原则其实就是对子类型的约束：要求子类型对象完全可以当作父类型的对象来使用",
      "其中就包括了规约的前置条件不能强化",
      "后置条件不能弱化",
      "要保持不变量等等",
      "下面介绍协变与异变的概念",
      "协变：子类对父类方法的覆写中",
      "异常、返回值的类型是父类方法中返回值的类型的子类型",
      "就称之为协变",
      "逆变：顾名思义，与协变恰恰相反",
      "因此为了复合Liskov替换原则",
      "我们要求如果有变化的话",
      "那异常",
      "返回值必须是协变",
      "参数必须是异变(当然",
      "在java语言中参数的异变或协变导致方法不再是覆写",
      "而是重载)",
      "java中的泛型是类型不变的，如下图所示，是十分经典的例子",
      "如果想进行协变或逆变",
      "则需要使用通配符",
      "例如List<? extends Number>是List < Number>的子类型",
      "但是不论如何都要确保一个List中的元素都是一种类型的(尽管多种元素都可以放入)",
      "2、委托与组合",
      "委派/委托：一个对象请求另一个对象的功能",
      "四种委派方式：①Dependency：依赖关系",
      "临时性的delegation",
      "②Association：关联关系",
      "永久性的delegation",
      "③Composition: 更强的association",
      "但难以变化",
      "④Aggregation: 更弱的association",
      "可动态变化",
      "组合：利用delegation的机制",
      "将功能的具体实现与调用分离",
      "在实现中又通过接口的继承树实现功能的不同实现方法",
      "而在调用类中只需要创建具体的子类型然后调用即可",
      "3、框架framework",
      "黑盒框架：通过实现特定接口进行框架扩展",
      "采用的是delegation机制达到这种目的",
      "通常采用的设计模式是策略模式(Strategy)和观察者模式(Observer)",
      "白盒框架：通过继承和重写实现功能的扩展",
      "通常的设计模式是模板模式(Template Method)"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "HIT软件构造笔记六\n一.可复用性的度量、形态与外部表现\n1.可复用性的评估\n评估的方面：复用的频繁性、复用的代价 (适配)\n一个有高可复用性的代码应该有如下特点：小、简单；与标准兼容；灵活可变；可扩展；泛型、参数化；模块化；变化的局部性；稳定；丰富的文档和帮助。\n2、复用的层面\n两种复用的方式：白盒复用和黑盒复用。黑盒复用就类似于调用API接口，或者方法等等；白盒复用是直接得到想要复用的源代码(或其他内容)等等，然后自己根据需要进行修改。\n根据复用内容的结构从小到大，分为如下四种复用。\n(1).源代码级别的复用:这个是最底层的复用，就是简单的复制粘贴修改。\n(2).模块级复用:以class作为最基本的单元，复用的方式有继承和委托，其中委托的耦合度明显低于继承。\n(3).类库级重用:相当于把一系列的class进行了打包，类似于第三方库的调用。\n(4).框架级复用:在框架的基础上，填充自己的代码，形成完整系统。(其实就类似于一些实验中，给出了很多代码，要求我们填入一些自己的代码)\n二．面向复用的软件构造技术\n1、LSP与泛型中的运用\nLiskov替换原则，从实际设计的角度来说，这个原则其实就是对子类型的约束：要求子类型对象完全可以当作父类型的对象来使用，其中就包括了规约的前置条件不能强化，后置条件不能弱化，要保持不变量等等。\n下面介绍协变与异变的概念。\n协变：子类对父类方法的覆写中，异常、返回值的类型是父类方法中返回值的类型的子类型，就称之为协变。\n逆变：顾名思义，与协变恰恰相反。\n因此为了复合Liskov替换原则，我们要求如果有变化的话，那异常，返回值必须是协变，参数必须是异变(当然，在java语言中参数的异变或协变导致方法不再是覆写，而是重载)。\njava中的泛型是类型不变的，如下图所示，是十分经典的例子。如果想进行协变或逆变，则需要使用通配符，例如List<? extends Number>是List < Number>的子类型，但是不论如何都要确保一个List中的元素都是一种类型的(尽管多种元素都可以放入)。\n2、委托与组合\n委派/委托：一个对象请求另一个对象的功能。\n四种委派方式：\n①Dependency：依赖关系，临时性的delegation\n②Association：关联关系，永久性的delegation。\n③Composition: 更强的association，但难以变化。\n④Aggregation: 更弱的association，可动态变化。\n组合：利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。\n3、框架framework\n黑盒框架：通过实现特定接口进行框架扩展，采用的是delegation机制达到这种目的，通常采用的设计模式是策略模式(Strategy)和观察者模式(Observer)\n白盒框架：通过继承和重写实现功能的扩展，通常的设计模式是模板模式(Template Method)。\n"
  },
  {
    "head": "哈工大软件构造Lab3（继承不同父类时返回值类型不同带来的比较问题，提高代码的可复用性）",
    "paragraphs": [
      "在实验三中，我们写了两个接口",
      "IntervalSet<L>",
      "MultiIntervalSet<L>",
      "我们定义了时间段类Interval",
      "在Interval中保存的是一个时间段的开始时间与结束时间",
      "对于两个接口，写了相应的实现",
      "CommonIntervalSet<L>",
      "CommonIntervalSet所实现的主要功能是管理标签L到时间段Interval的映射关系。每个标签L只能对应一个时间段。",
      "如：在安排值班时间时，每个人只安排一个时间段。",
      "在CommonIntervalSet<L>中，我们给出了一种方法，得到标签L label对应的时间段",
      "CommonMultiIntervalSet<L>",
      "CommonMultiIntervalSet实现的功能是管理标签L到时间段集合IntervalSet<Integer>的映射关系。IntervalSet<Integer>即第一个接口，这里我们是用Integer类型代替抽象数据类型。每个标签L映射到一个时间段集合，即每个标签可以对应多个时间段。",
      "如：进程执行时，执行时间并不是连续的，因此一个进程可能对应多个时间段。",
      "在MultiCommonIntervalSet<L>中，我们给出了一种方法，得到标签L label对应的时间段的集合IntervalSet<Integer>",
      "介绍完前提，我们开始介绍本次实验中遇到的问题。",
      "我们需要设计一个值班表排表的APP，DutyRosterSet",
      "我们需要实现两种APP",
      "第一种：同一个员工可以在两个不连续的时间段值班",
      "第二种：同一个员工的值班时间必须是连续的",
      "很明显，对于第一种APP，我们应该继承CommonIntervalSet<L>类；对于第二种，我们应该继承CommonMultiIntervalSet<L>类",
      "在DutyRosterSet中，我们需要实现以下功能",
      "给定标签L label，以及时间段Interval time",
      "我们要判断label是否指向时间段label",
      "我们已经从CommonIntervalSet<L>和CommonMultiIntervalSet<L>中分别继承了",
      "此时，就给我们代码的实现带来了一定的问题。",
      "当我们调用getInterval（label）的时候，由于继承的类不同，所返回的返回值的类型也不同，由于我们无法直接判断返回值是一个时间段的类型Interval，还是时间段集合IntervalSet<Integer>。这给我们判断标签label是否指向时间段time造成了很大困难。",
      "因此，当已经实现第一种APP后，如果想实现第二种APP，此时我们不仅需要将继承的类由CommonIntervalSet<L>更改为CommonMultiIntervalSet<L>，还需要修改代码，这与我们要求尽可能高的复用性的要求相矛盾。",
      "接下来，我们介绍一下针对这种问题的解决方案",
      "2种方法，其实大同小异，都简单的写了一下",
      "为了提高代码的可复用性，使我们可以更方便的根据不同要求，修改更少的代码。",
      "我们考虑将判断的过程放入父类",
      "第一种：保留差异性，在不同的父类中实现的方法，需要传入不同的参数",
      "在CommonIntervalSet<L>中添加以下方法",
      "在CommonMultiIntervalSet<L>中添加以下方法",
      "此时，我们再判断标签label是否指向时间段time的时候，只需要调用",
      "belong（time，getInterval（label））",
      "由于在CommonIntervalSet<L>中，getInterval（label）返回的是Interval类型，而belong（，）要传入的参数正是Interval型",
      "而在CommonMultiIntervalSet<L>中，getInterval（label）返回的是IntervalSet<Integer>类型，而belong（，）要传入的参数则是IntervalSet<Integer>型，此时分别对应相等",
      "此种方法既解决了继承不同父类时返回值不同的问题，同时也保留了部分差异性，当我们所需实现的APP对某些差异性有针对性的要求时，可以使用此方法",
      "第二种：直接使用同样的接口",
      "在CommonIntervalSet<L>和CommonMultiIntervalSet<L>中添加同样的方法",
      "此时，我们要判断label是否指向时间段time，只需要调用",
      "belong（time，label）",
      "这种方法就消除了差异性的问题，使代码有了更高的可复用性",
      "同时，因为消除了差异性，只保留了共性的部分，使其他程序员在使用我们设计的接口时，更简单易懂",
      "个人还是比较倾向于第二种方法的，毕竟我们写接口就是为了抽象出共性的东西，让我们可以更方便的反复利用",
      "总结：",
      "为了提高可复用性，应尽量减少继承不同父类时出现的返回值类型不同的问题，减少其个性的方法，增加其共性的方法，针对不同要求有不同实现，然后通过相同的接口，可以让我们的代码具有更好的可复用性"
    ],
    "sentences": [
      "在实验三中，我们写了两个接口",
      "IntervalSet<L>",
      "MultiIntervalSet<L>",
      "我们定义了时间段类Interval",
      "在Interval中保存的是一个时间段的开始时间与结束时间",
      "对于两个接口，写了相应的实现",
      "CommonIntervalSet<L>",
      "CommonIntervalSet所实现的主要功能是管理标签L到时间段Interval的映射关系",
      "每个标签L只能对应一个时间段",
      "如：在安排值班时间时，每个人只安排一个时间段",
      "在CommonIntervalSet<L>中",
      "我们给出了一种方法",
      "得到标签L label对应的时间段",
      "CommonMultiIntervalSet<L>",
      "CommonMultiIntervalSet实现的功能是管理标签L到时间段集合IntervalSet<Integer>的映射关系",
      "IntervalSet<Integer>即第一个接口",
      "这里我们是用Integer类型代替抽象数据类型",
      "每个标签L映射到一个时间段集合，即每个标签可以对应多个时间段",
      "如：进程执行时",
      "执行时间并不是连续的",
      "因此一个进程可能对应多个时间段",
      "在MultiCommonIntervalSet<L>中",
      "我们给出了一种方法",
      "得到标签L label对应的时间段的集合IntervalSet<Integer>",
      "介绍完前提，我们开始介绍本次实验中遇到的问题",
      "我们需要设计一个值班表排表的APP",
      "DutyRosterSet",
      "我们需要实现两种APP",
      "第一种：同一个员工可以在两个不连续的时间段值班",
      "第二种：同一个员工的值班时间必须是连续的",
      "很明显",
      "对于第一种APP",
      "我们应该继承CommonIntervalSet<L>类；对于第二种",
      "我们应该继承CommonMultiIntervalSet<L>类",
      "在DutyRosterSet中，我们需要实现以下功能",
      "给定标签L label，以及时间段Interval time",
      "我们要判断label是否指向时间段label",
      "我们已经从CommonIntervalSet<L>和CommonMultiIntervalSet<L>中分别继承了",
      "此时，就给我们代码的实现带来了一定的问题",
      "当我们调用getInterval（label）的时候",
      "由于继承的类不同",
      "所返回的返回值的类型也不同",
      "由于我们无法直接判断返回值是一个时间段的类型Interval",
      "还是时间段集合IntervalSet<Integer>",
      "这给我们判断标签label是否指向时间段time造成了很大困难",
      "因此",
      "当已经实现第一种APP后",
      "如果想实现第二种APP",
      "此时我们不仅需要将继承的类由CommonIntervalSet<L>更改为CommonMultiIntervalSet<L>",
      "还需要修改代码",
      "这与我们要求尽可能高的复用性的要求相矛盾",
      "接下来，我们介绍一下针对这种问题的解决方案",
      "2种方法，其实大同小异，都简单的写了一下",
      "为了提高代码的可复用性",
      "使我们可以更方便的根据不同要求",
      "修改更少的代码",
      "我们考虑将判断的过程放入父类",
      "第一种：保留差异性",
      "在不同的父类中实现的方法",
      "需要传入不同的参数",
      "在CommonIntervalSet<L>中添加以下方法",
      "在CommonMultiIntervalSet<L>中添加以下方法",
      "此时",
      "我们再判断标签label是否指向时间段time的时候",
      "只需要调用",
      "belong（time",
      "getInterval（label））",
      "由于在CommonIntervalSet<L>中",
      "getInterval（label）返回的是Interval类型",
      "而belong（",
      "）要传入的参数正是Interval型",
      "而在CommonMultiIntervalSet<L>中",
      "getInterval（label）返回的是IntervalSet<Integer>类型",
      "而belong（",
      "）要传入的参数则是IntervalSet<Integer>型",
      "此时分别对应相等",
      "此种方法既解决了继承不同父类时返回值不同的问题",
      "同时也保留了部分差异性",
      "当我们所需实现的APP对某些差异性有针对性的要求时",
      "可以使用此方法",
      "第二种：直接使用同样的接口",
      "在CommonIntervalSet<L>和CommonMultiIntervalSet<L>中添加同样的方法",
      "此时，我们要判断label是否指向时间段time，只需要调用",
      "belong（time，label）",
      "这种方法就消除了差异性的问题，使代码有了更高的可复用性",
      "同时",
      "因为消除了差异性",
      "只保留了共性的部分",
      "使其他程序员在使用我们设计的接口时",
      "更简单易懂",
      "个人还是比较倾向于第二种方法的",
      "毕竟我们写接口就是为了抽象出共性的东西",
      "让我们可以更方便的反复利用",
      "总结：为了提高可复用性",
      "应尽量减少继承不同父类时出现的返回值类型不同的问题",
      "减少其个性的方法",
      "增加其共性的方法",
      "针对不同要求有不同实现",
      "然后通过相同的接口",
      "可以让我们的代码具有更好的可复用性"
    ],
    "codes": [
      "private final long start;\nprivate final long end;",
      "private final Map<L,Interval> intervals = new HashMap<>();",
      "public Interval getInterval(L label) ",
      "private final Map<L,IntervalSet<Integer>> intervals= new HashMap<>();",
      "public IntervalSet<Integer> getInterval(L label) ",
      "public class DutyRosterSet extends CommonMultiIntervalSet<Employee> implements IDutyRosterSet\npublic class DutyRosterSet extends CommonIntervalSet<Employee> implements IDutyRosterSet",
      "public Interval getInterval(L label) ",
      "public IntervalSet<Integer> getInterval(L label) \n",
      "public boolean belong(Interval a, Interval b)",
      "public boolean belong(Interval t, IntervalSet<Integer> set)",
      "public boolean belong(Interval t, L label)"
    ],
    "date": "2021-07-06",
    "text": "在实验三中，我们写了两个接口\nIntervalSet<L>\nMultiIntervalSet<L>\n我们定义了时间段类Interval\n在Interval中保存的是一个时间段的开始时间与结束时间\n对于两个接口，写了相应的实现\nCommonIntervalSet<L>\nCommonIntervalSet所实现的主要功能是管理标签L到时间段Interval的映射关系。每个标签L只能对应一个时间段。\n如：在安排值班时间时，每个人只安排一个时间段。\n在CommonIntervalSet<L>中，我们给出了一种方法，得到标签L label对应的时间段\nCommonMultiIntervalSet<L>\nCommonMultiIntervalSet实现的功能是管理标签L到时间段集合IntervalSet<Integer>的映射关系。IntervalSet<Integer>即第一个接口，这里我们是用Integer类型代替抽象数据类型。每个标签L映射到一个时间段集合，即每个标签可以对应多个时间段。\n如：进程执行时，执行时间并不是连续的，因此一个进程可能对应多个时间段。\n在MultiCommonIntervalSet<L>中，我们给出了一种方法，得到标签L label对应的时间段的集合IntervalSet<Integer>\n介绍完前提，我们开始介绍本次实验中遇到的问题。\n我们需要设计一个值班表排表的APP，DutyRosterSet\n我们需要实现两种APP\n第一种：同一个员工可以在两个不连续的时间段值班\n第二种：同一个员工的值班时间必须是连续的\n很明显，对于第一种APP，我们应该继承CommonIntervalSet<L>类；对于第二种，我们应该继承CommonMultiIntervalSet<L>类\n在DutyRosterSet中，我们需要实现以下功能\n给定标签L label，以及时间段Interval time\n我们要判断label是否指向时间段label\n我们已经从CommonIntervalSet<L>和CommonMultiIntervalSet<L>中分别继承了\n此时，就给我们代码的实现带来了一定的问题。\n当我们调用getInterval（label）的时候，由于继承的类不同，所返回的返回值的类型也不同，由于我们无法直接判断返回值是一个时间段的类型Interval，还是时间段集合IntervalSet<Integer>。这给我们判断标签label是否指向时间段time造成了很大困难。\n因此，当已经实现第一种APP后，如果想实现第二种APP，此时我们不仅需要将继承的类由CommonIntervalSet<L>更改为CommonMultiIntervalSet<L>，还需要修改代码，这与我们要求尽可能高的复用性的要求相矛盾。\n接下来，我们介绍一下针对这种问题的解决方案\n2种方法，其实大同小异，都简单的写了一下\n为了提高代码的可复用性，使我们可以更方便的根据不同要求，修改更少的代码。\n我们考虑将判断的过程放入父类\n第一种：保留差异性，在不同的父类中实现的方法，需要传入不同的参数\n在CommonIntervalSet<L>中添加以下方法\n在CommonMultiIntervalSet<L>中添加以下方法\n此时，我们再判断标签label是否指向时间段time的时候，只需要调用\nbelong（time，getInterval（label））\n由于在CommonIntervalSet<L>中，getInterval（label）返回的是Interval类型，而belong（，）要传入的参数正是Interval型\n而在CommonMultiIntervalSet<L>中，getInterval（label）返回的是IntervalSet<Integer>类型，而belong（，）要传入的参数则是IntervalSet<Integer>型，此时分别对应相等\n此种方法既解决了继承不同父类时返回值不同的问题，同时也保留了部分差异性，当我们所需实现的APP对某些差异性有针对性的要求时，可以使用此方法\n第二种：直接使用同样的接口\n在CommonIntervalSet<L>和CommonMultiIntervalSet<L>中添加同样的方法\n此时，我们要判断label是否指向时间段time，只需要调用\nbelong（time，label）\n这种方法就消除了差异性的问题，使代码有了更高的可复用性\n同时，因为消除了差异性，只保留了共性的部分，使其他程序员在使用我们设计的接口时，更简单易懂\n个人还是比较倾向于第二种方法的，毕竟我们写接口就是为了抽象出共性的东西，让我们可以更方便的反复利用\n总结：\n为了提高可复用性，应尽量减少继承不同父类时出现的返回值类型不同的问题，减少其个性的方法，增加其共性的方法，针对不同要求有不同实现，然后通过相同的接口，可以让我们的代码具有更好的可复用性\n"
  },
  {
    "head": "用Java集合类实现图的广度优先算法",
    "paragraphs": [
      "用Java集合类实现图的广度优先算法",
      "第一次Java实验，就碰到了要求实现无向图两点间距离计算的题目。被迫拾起了数据结构的知识。",
      "刚刚着手学习Java编程语言，加上之前数据结构的知识也都还给老师，就算还记得，也不知道怎样用Java实现图的结构与算法啊QAQ",
      "没办法，最后硬着头皮，用Java集合类勉强写出来了。",
      "过程可能要麻烦很多，我相信肯定也被很多人写过，不过我实在太懒了，也没有搜过相关文章。如果实现过程中有问题，还请大佬指出。",
      "先给出题目条件吧。这里要存储的点是一个自定义的Person类，当然，你也可以使用任何的其他对象。",
      "我用一个HashMap对象graph来存储我的图。这里，Person是图中的每一个顶点，Set<Person>中存放的是每一个和Person相邻接的顶点。",
      "添加顶点与添加边的方法比较简单，不具体写出来了，简述一下吧。",
      "函数addVertex(Person name)将Person类name加入graph中，并为name新建一个集合，加入name在graph中映射到的值里。",
      "函数addEdge(Person name1, Person name2)则分别将name1加入name2映射到的集合graph.get(name2)中，将name2加入到name1映射到的集合graph.get(name1)中。",
      "接下来，就是用集合实现广度优先算法来获取距离了。话不多说，先给出代码。",
      "首先，我们要保证这两个点在图中确实存在，然后我们再进行下一步。",
      "用distance标记两人之间的距离，这里用了另一个HashMap对象search标记一个顶点是否被访问过邻接点。",
      "用HashSet存储name1可达的顶点（我们从name1出发，搜索name2）。",
      "如果一个顶点Person的邻接点被存入了set中，我们就把Person映射到的值标记为1，反之，如果点Person的邻接点还没有被存入set，我们将Person映射到的值标记为0。",
      "下面我们正式开始。",
      "首先我们将name1加入set，并将映射（set，0）写入哈希表search，因为此时我们仅仅是将name1写入了set，并没有将set的邻接点写入set。",
      "接下来就要进入循环了，循环条件为search.containsValue(0)，也就是说在set中，存在着一些点，它们的邻接点还没有被添加进set中，此时我们可以继续添加这些点。",
      "循环开始，我们先判断了name2是否存在于set中（不排除name2等于name1的可能），如果name2已存在于set中，返回distance（name2等于name1时，distance为0）。",
      "接下来，我再次new了一个HashSet的集合。",
      "friend存储的是这一轮循环过程中，将要被添加到set中的点，因为set需要遍历，担心直接添加进set中会引起混乱（这个我并没有进行实验，感兴趣的可以尝试一下），但是用个friend缓冲一下，就不会遇到这种问题了。",
      "接下来，开始遍历set，依次从set中取出元素，如果这个元素被search标记为0，即它的邻接点并未被添加（我们暂时不考虑邻接点有哪些，有可能其实它的邻接点已经全部被添加进set中了，但是我们是不知道的，我们必须通过再添加一次，来保证不产生遗漏，Set类就像数学中的集合一样，会帮我们去掉重复的元素），我们将它映射到的集合添加到friend中（即将所有邻接点加入friend中）并将这个元素重新标记为1。",
      "全部遍历完成后，我们再将集合friend并入到集合set中。",
      "紧接着，我们再一次遍历set集合，如果set中存在元素，在search中不存在（即前一轮遍历得到的friend中存在着新的，原set中不存在的元素，被加入到了set中），则将此元素添加到search中，并使其映射到0。",
      "遍历完成后，distance加1，即在原先已遍历到的顶点的前提上再次前进了一节。",
      "接下来，继续进行最外层的循环。如果set中存在被标记为0的元素，则继续进行前面的步骤。",
      "如果不存在被标记为0的元素，则说明上一轮的搜索并没有增加新的元素，我们已经完全搜索了name1可达的节点，这应该是图的一个连通子图。如果name2存在于这个子图中，由于新一轮搜索并没有增加新的标记为0的节点，也就是说在之前一轮的循环结束，set中就已经包含了这个连通子图，而在上一轮的循环中，显然如果存在name2，那么在if条件的判断时就应该已经返回了结果。因此，name2是不存在这个连通子图中的，也就是说name1无法到达name2，于是，我们返回一个-1。",
      "有点啰嗦，写的有点多，希望大佬们不要见怪。"
    ],
    "sentences": [
      "用Java集合类实现图的广度优先算法",
      "第一次Java实验",
      "就碰到了要求实现无向图两点间距离计算的题目",
      "被迫拾起了数据结构的知识",
      "刚刚着手学习Java编程语言",
      "加上之前数据结构的知识也都还给老师",
      "就算还记得",
      "也不知道怎样用Java实现图的结构与算法啊QAQ",
      "没办法，最后硬着头皮，用Java集合类勉强写出来了",
      "过程可能要麻烦很多",
      "我相信肯定也被很多人写过",
      "不过我实在太懒了",
      "也没有搜过相关文章",
      "如果实现过程中有问题，还请大佬指出",
      "先给出题目条件吧",
      "这里要存储的点是一个自定义的Person类",
      "当然",
      "你也可以使用任何的其他对象",
      "我用一个HashMap对象graph来存储我的图",
      "这里",
      "Person是图中的每一个顶点",
      "Set<Person>中存放的是每一个和Person相邻接的顶点",
      "添加顶点与添加边的方法比较简单，不具体写出来了，简述一下吧",
      "函数addVertex(Person name)将Person类name加入graph中",
      "并为name新建一个集合",
      "加入name在graph中映射到的值里",
      "函数addEdge(Person name1, Person name2)则分别将name1加入name2映射到的集合graph.get(name2)中",
      "将name2加入到name1映射到的集合graph.get(name1)中",
      "接下来，就是用集合实现广度优先算法来获取距离了",
      "话不多说，先给出代码",
      "首先，我们要保证这两个点在图中确实存在，然后我们再进行下一步",
      "用distance标记两人之间的距离",
      "这里用了另一个HashMap对象search标记一个顶点是否被访问过邻接点",
      "用HashSet存储name1可达的顶点（我们从name1出发",
      "搜索name2）",
      "如果一个顶点Person的邻接点被存入了set中",
      "我们就把Person映射到的值标记为1",
      "反之",
      "如果点Person的邻接点还没有被存入set",
      "我们将Person映射到的值标记为0",
      "下面我们正式开始",
      "首先我们将name1加入set",
      "并将映射（set",
      "0）写入哈希表search",
      "因为此时我们仅仅是将name1写入了set",
      "并没有将set的邻接点写入set",
      "接下来就要进入循环了",
      "循环条件为search.containsValue(0)",
      "也就是说在set中",
      "存在着一些点",
      "它们的邻接点还没有被添加进set中",
      "此时我们可以继续添加这些点",
      "循环开始",
      "我们先判断了name2是否存在于set中（不排除name2等于name1的可能）",
      "如果name2已存在于set中",
      "返回distance（name2等于name1时",
      "distance为0）",
      "接下来，我再次new了一个HashSet的集合",
      "friend存储的是这一轮循环过程中",
      "将要被添加到set中的点",
      "因为set需要遍历",
      "担心直接添加进set中会引起混乱（这个我并没有进行实验",
      "感兴趣的可以尝试一下）",
      "但是用个friend缓冲一下",
      "就不会遇到这种问题了",
      "接下来",
      "开始遍历set",
      "依次从set中取出元素",
      "如果这个元素被search标记为0",
      "即它的邻接点并未被添加（我们暂时不考虑邻接点有哪些",
      "有可能其实它的邻接点已经全部被添加进set中了",
      "但是我们是不知道的",
      "我们必须通过再添加一次",
      "来保证不产生遗漏",
      "Set类就像数学中的集合一样",
      "会帮我们去掉重复的元素）",
      "我们将它映射到的集合添加到friend中（即将所有邻接点加入friend中）并将这个元素重新标记为1",
      "全部遍历完成后，我们再将集合friend并入到集合set中",
      "紧接着",
      "我们再一次遍历set集合",
      "如果set中存在元素",
      "在search中不存在（即前一轮遍历得到的friend中存在着新的",
      "原set中不存在的元素",
      "被加入到了set中）",
      "则将此元素添加到search中",
      "并使其映射到0",
      "遍历完成后",
      "distance加1",
      "即在原先已遍历到的顶点的前提上再次前进了一节",
      "接下来，继续进行最外层的循环",
      "如果set中存在被标记为0的元素，则继续进行前面的步骤",
      "如果不存在被标记为0的元素",
      "则说明上一轮的搜索并没有增加新的元素",
      "我们已经完全搜索了name1可达的节点",
      "这应该是图的一个连通子图",
      "如果name2存在于这个子图中",
      "由于新一轮搜索并没有增加新的标记为0的节点",
      "也就是说在之前一轮的循环结束",
      "set中就已经包含了这个连通子图",
      "而在上一轮的循环中",
      "显然如果存在name2",
      "那么在if条件的判断时就应该已经返回了结果",
      "因此",
      "name2是不存在这个连通子图中的",
      "也就是说name1无法到达name2",
      "于是",
      "我们返回一个-1",
      "有点啰嗦，写的有点多，希望大佬们不要见怪"
    ],
    "codes": [
      "Map<Person,Set<Person>> graph = new HashMap<Person,Set<Person>>();",
      "boolean addVertex(Person name)\nvoid addEdge(Person name1,Person name2)",
      "int getDistance(Person name1,Person name2)\n\t{\n\t\tint distance = 0;\n\t\tif(graph.containsKey(name1)&&graph.containsKey(name2))    //有这两个人\n\t\t{\n\t\t\tMap<Person,Integer> search = new HashMap<Person,Integer>();  //search标记邻接点是否被访问过\n\t\t\tSet<Person> set = new HashSet<Person>();   //已经遍历到的全部点的集合set\n\t\t\tset.add(name1);\n\t\t\tsearch.put(name1,0);\n\t\t\twhile(search.containsValue(0))    //存在没有遍历的点\n\t\t\t{\n\t\t\t\tif(set.contains(name2))      //已经搜索到了name2\n\t\t\t\t{\n\t\t\t\t\treturn distance;\n\t\t\t\t}\n\t\t\t\tSet<Person> friend = new HashSet<Person>();  //新一轮遍历到的全部点的集合\n\t\t\t\tIterator<Person> it = set.iterator();     //遍历全部点的集合\n\t\t\t\twhile(it.hasNext())\n\t\t\t\t{\n\t\t\t\t\tPerson x = it.next();       //从set中依次取出\n\t\t\t\t\tif(search.get(x) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfriend.addAll(graph.get(x));   //将x的邻接的点全部添加到集合friend中\n\t\t\t\t\t\tsearch.put(x, 1);     //标记x的邻接点已访问\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset.addAll(friend);       //将新集合并入原集合set\n\t\t\t\tit = set.iterator();\n\t\t\t\twhile(it.hasNext())       //遍历集合set\n\t\t\t\t{\n\t\t\t\t\tPerson x = it.next();\n\t\t\t\t\tif(search.containsKey(x) == false)     //存在search中未加入的新点\n\t\t\t\t\t{\n\t\t\t\t\t\tsearch.put(x, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdistance = distance + 1;     //完成一次搜索，距离加1\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(\"error!根本没这人\");\n\t\t\tSystem.exit(0);\n\t\t}\n\t\treturn distance;\n\t}",
      "Map<Person,Integer> search = new HashMap<Person,Integer>();",
      "Set<Person> set = new HashSet<Person>();",
      "Set<Person> friend = new HashSet<Person>();"
    ],
    "date": "2021-05-23",
    "text": "用Java集合类实现图的广度优先算法\n第一次Java实验，就碰到了要求实现无向图两点间距离计算的题目。被迫拾起了数据结构的知识。\n刚刚着手学习Java编程语言，加上之前数据结构的知识也都还给老师，就算还记得，也不知道怎样用Java实现图的结构与算法啊QAQ\n没办法，最后硬着头皮，用Java集合类勉强写出来了。\n过程可能要麻烦很多，我相信肯定也被很多人写过，不过我实在太懒了，也没有搜过相关文章。如果实现过程中有问题，还请大佬指出。\n先给出题目条件吧。这里要存储的点是一个自定义的Person类，当然，你也可以使用任何的其他对象。\n我用一个HashMap对象graph来存储我的图。这里，Person是图中的每一个顶点，Set<Person>中存放的是每一个和Person相邻接的顶点。\n添加顶点与添加边的方法比较简单，不具体写出来了，简述一下吧。\n函数addVertex(Person name)将Person类name加入graph中，并为name新建一个集合，加入name在graph中映射到的值里。\n函数addEdge(Person name1, Person name2)则分别将name1加入name2映射到的集合graph.get(name2)中，将name2加入到name1映射到的集合graph.get(name1)中。\n接下来，就是用集合实现广度优先算法来获取距离了。话不多说，先给出代码。\n首先，我们要保证这两个点在图中确实存在，然后我们再进行下一步。\n用distance标记两人之间的距离，这里用了另一个HashMap对象search标记一个顶点是否被访问过邻接点。\n用HashSet存储name1可达的顶点（我们从name1出发，搜索name2）。\n如果一个顶点Person的邻接点被存入了set中，我们就把Person映射到的值标记为1，反之，如果点Person的邻接点还没有被存入set，我们将Person映射到的值标记为0。\n下面我们正式开始。\n首先我们将name1加入set，并将映射（set，0）写入哈希表search，因为此时我们仅仅是将name1写入了set，并没有将set的邻接点写入set。\n接下来就要进入循环了，循环条件为search.containsValue(0)，也就是说在set中，存在着一些点，它们的邻接点还没有被添加进set中，此时我们可以继续添加这些点。\n循环开始，我们先判断了name2是否存在于set中（不排除name2等于name1的可能），如果name2已存在于set中，返回distance（name2等于name1时，distance为0）。\n接下来，我再次new了一个HashSet的集合。\nfriend存储的是这一轮循环过程中，将要被添加到set中的点，因为set需要遍历，担心直接添加进set中会引起混乱（这个我并没有进行实验，感兴趣的可以尝试一下），但是用个friend缓冲一下，就不会遇到这种问题了。\n接下来，开始遍历set，依次从set中取出元素，如果这个元素被search标记为0，即它的邻接点并未被添加（我们暂时不考虑邻接点有哪些，有可能其实它的邻接点已经全部被添加进set中了，但是我们是不知道的，我们必须通过再添加一次，来保证不产生遗漏，Set类就像数学中的集合一样，会帮我们去掉重复的元素），我们将它映射到的集合添加到friend中（即将所有邻接点加入friend中）并将这个元素重新标记为1。\n全部遍历完成后，我们再将集合friend并入到集合set中。\n紧接着，我们再一次遍历set集合，如果set中存在元素，在search中不存在（即前一轮遍历得到的friend中存在着新的，原set中不存在的元素，被加入到了set中），则将此元素添加到search中，并使其映射到0。\n遍历完成后，distance加1，即在原先已遍历到的顶点的前提上再次前进了一节。\n接下来，继续进行最外层的循环。如果set中存在被标记为0的元素，则继续进行前面的步骤。\n如果不存在被标记为0的元素，则说明上一轮的搜索并没有增加新的元素，我们已经完全搜索了name1可达的节点，这应该是图的一个连通子图。如果name2存在于这个子图中，由于新一轮搜索并没有增加新的标记为0的节点，也就是说在之前一轮的循环结束，set中就已经包含了这个连通子图，而在上一轮的循环中，显然如果存在name2，那么在if条件的判断时就应该已经返回了结果。因此，name2是不存在这个连通子图中的，也就是说name1无法到达name2，于是，我们返回一个-1。\n有点啰嗦，写的有点多，希望大佬们不要见怪。\n"
  },
  {
    "head": "正则表达式中的元字符",
    "paragraphs": [
      "在软件构造实验三中，我们为排班表应用添加了一个从文本中读取排班信息的功能",
      "文本中给出的信息在格式上可能是错误的，如果我们直接拿来使用的话，当我们在后续的对文本信息进行解析的过程中，可能会出现很多不必要的麻烦",
      "通过使用正则表达式，在对文本内容解析之前，先筛除掉格式错误的文本文件，可以很大程度上减少我们后续过程中的工作量",
      "我总结了一下常用的正则表达式的元字符，并简单介绍了一下它们的含义",
      "正则表达式中的元字符",
      "元字符",
      "正则表达式中的写法",
      "\".\"",
      "代表任意一个字符",
      "\"\\\\d\"",
      "代表0~9的任意一个数字",
      "\"\\\\D\"",
      "代表任意一个非数字字符",
      "\"\\\\s\"",
      "代表空白字符。如‘\\t’、‘\\n’",
      "\\\\S",
      "\"\\\\S\"",
      "代表非空白字符",
      "\"\\\\w\"",
      "代表可用作标识符的字符（不包括‘$’）",
      "\"\\\\W\"",
      "代表不可用于标识符的字符",
      "\\p{Lower}",
      "\\\\p{Lower}",
      "代表小写字母{a~z}",
      "\\p{Upper}",
      "\\\\p{Upper}",
      "代表大写字母{A~Z}",
      "\\p{ASCII}",
      "\\\\p{ASCII}",
      "ASCII字符",
      "\\p{Alpha}",
      "\\\\p{Alpha}",
      "字母字符",
      "\\p{Digit}",
      "\\\\p{Digit}",
      "十进制数字",
      "\\p{Alnum}",
      "\\\\p{Alnum}",
      "数字或字母字符",
      "\\p{Punct}",
      "\\\\p{Punct}",
      "标点符号",
      "\\p{Graph}",
      "\\\\p{Graph}",
      "可见字符",
      "\\p{Print}",
      "\\\\p{Print}",
      "可打印字符",
      "\\p{Blank}",
      "\\\\p{Blank}",
      "空格或制表符",
      "\\p{Cntrl}",
      "\\\\p{Cntrl}",
      "控制字符",
      "资料来源：《Java从入门到精通》，清华大学出版社，2019年10月第1版"
    ],
    "sentences": [
      "在软件构造实验三中",
      "我们为排班表应用添加了一个从文本中读取排班信息的功能",
      "文本中给出的信息在格式上可能是错误的",
      "如果我们直接拿来使用的话",
      "当我们在后续的对文本信息进行解析的过程中",
      "可能会出现很多不必要的麻烦",
      "通过使用正则表达式",
      "在对文本内容解析之前",
      "先筛除掉格式错误的文本文件",
      "可以很大程度上减少我们后续过程中的工作量",
      "我总结了一下常用的正则表达式的元字符",
      "并简单介绍了一下它们的含义",
      "正则表达式中的元字符",
      "元字符",
      "正则表达式中的写法",
      "\".\"",
      "代表任意一个字符",
      "\"\\\\d\"",
      "代表0~9的任意一个数字",
      "\"\\\\D\"",
      "代表任意一个非数字字符",
      "\"\\\\s\"",
      "代表空白字符",
      "如‘\\t’、‘\\n’",
      "\\\\S",
      "\"\\\\S\"",
      "代表非空白字符",
      "\"\\\\w\"",
      "代表可用作标识符的字符（不包括‘$’）",
      "\"\\\\W\"",
      "代表不可用于标识符的字符",
      "\\p{Lower}",
      "\\\\p{Lower}",
      "代表小写字母{a~z}",
      "\\p{Upper}",
      "\\\\p{Upper}",
      "代表大写字母{A~Z}",
      "\\p{ASCII}",
      "\\\\p{ASCII}",
      "ASCII字符",
      "\\p{Alpha}",
      "\\\\p{Alpha}",
      "字母字符",
      "\\p{Digit}",
      "\\\\p{Digit}",
      "十进制数字",
      "\\p{Alnum}",
      "\\\\p{Alnum}",
      "数字或字母字符",
      "\\p{Punct}",
      "\\\\p{Punct}",
      "标点符号",
      "\\p{Graph}",
      "\\\\p{Graph}",
      "可见字符",
      "\\p{Print}",
      "\\\\p{Print}",
      "可打印字符",
      "\\p{Blank}",
      "\\\\p{Blank}",
      "空格或制表符",
      "\\p{Cntrl}",
      "\\\\p{Cntrl}",
      "控制字符",
      "资料来源：《Java从入门到精通》",
      "清华大学出版社",
      "2019年10月第1版"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "在软件构造实验三中，我们为排班表应用添加了一个从文本中读取排班信息的功能\n文本中给出的信息在格式上可能是错误的，如果我们直接拿来使用的话，当我们在后续的对文本信息进行解析的过程中，可能会出现很多不必要的麻烦\n通过使用正则表达式，在对文本内容解析之前，先筛除掉格式错误的文本文件，可以很大程度上减少我们后续过程中的工作量\n我总结了一下常用的正则表达式的元字符，并简单介绍了一下它们的含义\n正则表达式中的元字符\n元字符\n正则表达式中的写法\n\".\"\n代表任意一个字符\n\"\\\\d\"\n代表0~9的任意一个数字\n\"\\\\D\"\n代表任意一个非数字字符\n\"\\\\s\"\n代表空白字符。如‘\\t’、‘\\n’\n\\\\S\n\"\\\\S\"\n代表非空白字符\n\"\\\\w\"\n代表可用作标识符的字符（不包括‘$’）\n\"\\\\W\"\n代表不可用于标识符的字符\n\\p{Lower}\n\\\\p{Lower}\n代表小写字母{a~z}\n\\p{Upper}\n\\\\p{Upper}\n代表大写字母{A~Z}\n\\p{ASCII}\n\\\\p{ASCII}\nASCII字符\n\\p{Alpha}\n\\\\p{Alpha}\n字母字符\n\\p{Digit}\n\\\\p{Digit}\n十进制数字\n\\p{Alnum}\n\\\\p{Alnum}\n数字或字母字符\n\\p{Punct}\n\\\\p{Punct}\n标点符号\n\\p{Graph}\n\\\\p{Graph}\n可见字符\n\\p{Print}\n\\\\p{Print}\n可打印字符\n\\p{Blank}\n\\\\p{Blank}\n空格或制表符\n\\p{Cntrl}\n\\\\p{Cntrl}\n控制字符\n资料来源：《Java从入门到精通》，清华大学出版社，2019年10月第1版\n"
  },
  {
    "head": "Java编程语言中类的继承",
    "paragraphs": [
      "在软件构造实验3中，我们多次用到了继承的思想",
      "继承是面向对象的开发过程中的一个非常重要的概念，通过继承，我们可以使用之前定义的成员方法和成员变量，经过简单的程序编码就可以在已有类的基础上增加新的功能。",
      "Java程序设计语言通过继承机制，在现有类的基础上定义一个新的类，并在原有类的基础上添加新的方法或修改原有方法，从而提高编程效率、减少错误概率。",
      "继承是通过关键字extends来声明的，其格式为：",
      "[修饰符] class 类名 extends 父类名",
      "bird类继承了animal类，即animal类是bird类的直接父类（或直接超类），bird是animal类的直接子类。",
      "我们简单的编写animal类，使它作为bird类的父类",
      "我们用eclipse创建子类时，在指定包、类名的同时，还可以指定继承的超类（父类）和实现的接口。",
      "我们可以在Superclass中输入或选择我们要继承的父类。",
      "eclipse自动为我们生成了代码。",
      "此时，eclipse向我们报错，因为我们在父类中写了一个构造方法，eclipse提醒我们为子类添加构造方法。",
      "我们选择让eclipse自动添加构造方法，得到了如下代码。",
      "我们编写一个program来验证一下，子类bird是否继承了animal的成员方法与成员变量",
      "运行结果如下"
    ],
    "sentences": [
      "在软件构造实验3中，我们多次用到了继承的思想",
      "继承是面向对象的开发过程中的一个非常重要的概念",
      "通过继承",
      "我们可以使用之前定义的成员方法和成员变量",
      "经过简单的程序编码就可以在已有类的基础上增加新的功能",
      "Java程序设计语言通过继承机制",
      "在现有类的基础上定义一个新的类",
      "并在原有类的基础上添加新的方法或修改原有方法",
      "从而提高编程效率、减少错误概率",
      "继承是通过关键字extends来声明的",
      "其格式为：[修饰符] class 类名 extends 父类名",
      "bird类继承了animal类",
      "即animal类是bird类的直接父类（或直接超类）",
      "bird是animal类的直接子类",
      "我们简单的编写animal类，使它作为bird类的父类",
      "我们用eclipse创建子类时",
      "在指定包、类名的同时",
      "还可以指定继承的超类（父类）和实现的接口",
      "我们可以在Superclass中输入或选择我们要继承的父类",
      "eclipse自动为我们生成了代码",
      "此时",
      "eclipse向我们报错",
      "因为我们在父类中写了一个构造方法",
      "eclipse提醒我们为子类添加构造方法",
      "我们选择让eclipse自动添加构造方法，得到了如下代码",
      "我们编写一个program来验证一下",
      "子类bird是否继承了animal的成员方法与成员变量",
      "运行结果如下"
    ],
    "codes": [
      "public class bird extends animal {\n\n}",
      "public class animal {\n\t\n\tpublic boolean live;\n\tpublic String name;\n\tpublic final boolean canFly;\n\t\n\tpublic animal(boolean canFly)\n\t{\n\t\tthis.canFly = canFly;\n\t}\n\t\n\tpublic void getName()\n\t{\n\t\tSystem.out.println(name);\n\t}\n}",
      "package P1;\n\npublic class bird extends animal {\n\n}\n",
      "package P1;\n\npublic class bird extends animal {\n\n\tpublic bird(boolean canFly) {\n\t\tsuper(canFly);\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n}\n",
      "package P1;\n\npublic class program {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tbird eagle = new bird(true);\n\t\teagle.name = \"Eagle\";\n\t\teagle.live = true;\n\t\teagle.getName();\n\t}\n\n}"
    ],
    "date": "2021-07-07",
    "text": "在软件构造实验3中，我们多次用到了继承的思想\n继承是面向对象的开发过程中的一个非常重要的概念，通过继承，我们可以使用之前定义的成员方法和成员变量，经过简单的程序编码就可以在已有类的基础上增加新的功能。\nJava程序设计语言通过继承机制，在现有类的基础上定义一个新的类，并在原有类的基础上添加新的方法或修改原有方法，从而提高编程效率、减少错误概率。\n继承是通过关键字extends来声明的，其格式为：\n[修饰符] class 类名 extends 父类名\nbird类继承了animal类，即animal类是bird类的直接父类（或直接超类），bird是animal类的直接子类。\n我们简单的编写animal类，使它作为bird类的父类\n我们用eclipse创建子类时，在指定包、类名的同时，还可以指定继承的超类（父类）和实现的接口。\n我们可以在Superclass中输入或选择我们要继承的父类。\neclipse自动为我们生成了代码。\n此时，eclipse向我们报错，因为我们在父类中写了一个构造方法，eclipse提醒我们为子类添加构造方法。\n我们选择让eclipse自动添加构造方法，得到了如下代码。\n我们编写一个program来验证一下，子类bird是否继承了animal的成员方法与成员变量\n运行结果如下\n"
  },
  {
    "head": "Java中final修饰符与类型检查",
    "paragraphs": [
      "文章目录",
      "一、类型检查",
      "1.静态类型检查",
      "2.动态类型检查",
      "二、可变数据类型和不可变数据类型",
      "1.可变数据类型",
      "2.不可变数据类型",
      "final修饰符",
      "修饰可变类型",
      "修饰不可变类型",
      "最近在复习，感觉类型检查那部分细节比较多，final修饰符也会涉及到类型检查，所以就把这两个知识点综合起来总结一下。",
      "一、类型检查",
      "1.静态类型检查",
      "Java是一种静态类型的语言。",
      "----所有变量的类型在编译的时候就已经知道了，然后编译器也会导出所有表达式的类型。",
      "----如果a和b为int类型，那么编译器会推断a+b也是int类型。",
      "----eclipse环境会在你写代码的时候就做这些事情，所以你在写代码的时候就会发现eclipse可能报出一些错误。",
      "----",
      "静态类型检查在编译阶段进行。",
      "在编译阶段发现错误，避免了将错误带到运行阶段，可提高程序正确性。",
      "一般是类型相关的错误。如语法错误，类名、函数名错误，参数数目、类型错误，返回值类型错误。",
      "在eclipse中输入这段代码时，在第二个n处会有红色波浪线，因为和C不一样，Java的判断语句内必须的boolean类型的。所以编译器在编译阶段就会报错。",
      "2.动态类型检查",
      "在像python这样的动态类型语言中，这种检查推迟到运行时候。",
      "----",
      "在运行阶段进行类型检查。",
      "一般的错误有非法的参数值，非法的返回值，越界，空指针。",
      "在eclipse中输入这段代码，没有运行时，不会报错。但运行后会抛出异常：Exception in thread “main” java.lang.ArithmeticException: / by zero。这是在运行阶段进行检查的动态类型检查。",
      "二、可变数据类型和不可变数据类型",
      "1.可变数据类型",
      "可变数据类型是当改变一个变量的值时，将该变量当前指向的值的存储空间中写入一个新的值。",
      "比如StringBuilder是一种可变的数据类型。",
      "其内部的过程可以由这个图来表示：",
      "2.不可变数据类型",
      "不可变数据类型是改变一个变量，将该变量指向令一个值的存储空间。",
      "比如String是一种不可变的数据类型。",
      "其内部的过程可以由这个图来表示：",
      "final修饰符",
      "用final修饰class可以阻止被继承；修饰method可以阻止被子类重写；修饰field可以阻止被重新赋值；修饰局部变量也可以阻止被重新赋值。",
      "下面主要讨论final分别修饰可变和不可变数据类型与静态类型检查的情况。",
      "修饰可变类型",
      "以StringBuilder为例。",
      "这段代码没有任何问题，代码快照图和上文可变数据类型的图相同。依然是同一个空间，只是空间里的值不同了。",
      "这段代码在第二个sb处就会有红色波浪线，因为有final修饰，无法改变变量指向的对象。对于可变数据类型，final使得变量无法改变其引用。",
      "修饰不可变类型",
      "以String为例。",
      "和上文的图相同，String是不可变的数据类型，无法修改值，只能重新创建一个空间。这段代码就想要重新创造一个空间，这个空间里面的内容是“ab”，然后让s指向这个空间。显然会报错，因为有final修饰，s无法改变其指向。所以说，对于不可变数据类型，一旦被创建，其值不能改变。"
    ],
    "sentences": [
      "文章目录",
      "一、类型检查",
      "1.静态类型检查",
      "2.动态类型检查",
      "二、可变数据类型和不可变数据类型",
      "1.可变数据类型",
      "2.不可变数据类型",
      "final修饰符",
      "修饰可变类型",
      "修饰不可变类型",
      "最近在复习",
      "感觉类型检查那部分细节比较多",
      "final修饰符也会涉及到类型检查",
      "所以就把这两个知识点综合起来总结一下",
      "一、类型检查",
      "1.静态类型检查",
      "Java是一种静态类型的语言",
      "----所有变量的类型在编译的时候就已经知道了",
      "然后编译器也会导出所有表达式的类型",
      "----如果a和b为int类型",
      "那么编译器会推断a+b也是int类型",
      "----eclipse环境会在你写代码的时候就做这些事情",
      "所以你在写代码的时候就会发现eclipse可能报出一些错误",
      "----",
      "静态类型检查在编译阶段进行",
      "在编译阶段发现错误",
      "避免了将错误带到运行阶段",
      "可提高程序正确性",
      "一般是类型相关的错误",
      "如语法错误",
      "类名、函数名错误",
      "参数数目、类型错误",
      "返回值类型错误",
      "在eclipse中输入这段代码时",
      "在第二个n处会有红色波浪线",
      "因为和C不一样",
      "Java的判断语句内必须的boolean类型的",
      "所以编译器在编译阶段就会报错",
      "2.动态类型检查",
      "在像python这样的动态类型语言中，这种检查推迟到运行时候",
      "----",
      "在运行阶段进行类型检查",
      "一般的错误有非法的参数值，非法的返回值，越界，空指针",
      "在eclipse中输入这段代码，没有运行时，不会报错",
      "但运行后会抛出异常：Exception in thread “main” java.lang.ArithmeticException: / by zero",
      "这是在运行阶段进行检查的动态类型检查",
      "二、可变数据类型和不可变数据类型",
      "1.可变数据类型",
      "可变数据类型是当改变一个变量的值时",
      "将该变量当前指向的值的存储空间中写入一个新的值",
      "比如StringBuilder是一种可变的数据类型",
      "其内部的过程可以由这个图来表示：2.不可变数据类型",
      "不可变数据类型是改变一个变量，将该变量指向令一个值的存储空间",
      "比如String是一种不可变的数据类型",
      "其内部的过程可以由这个图来表示：final修饰符",
      "用final修饰class可以阻止被继承；修饰method可以阻止被子类重写；修饰field可以阻止被重新赋值；修饰局部变量也可以阻止被重新赋值",
      "下面主要讨论final分别修饰可变和不可变数据类型与静态类型检查的情况",
      "修饰可变类型",
      "以StringBuilder为例",
      "这段代码没有任何问题，代码快照图和上文可变数据类型的图相同",
      "依然是同一个空间，只是空间里的值不同了",
      "这段代码在第二个sb处就会有红色波浪线",
      "因为有final修饰",
      "无法改变变量指向的对象",
      "对于可变数据类型，final使得变量无法改变其引用",
      "修饰不可变类型",
      "以String为例",
      "和上文的图相同",
      "String是不可变的数据类型",
      "无法修改值",
      "只能重新创建一个空间",
      "这段代码就想要重新创造一个空间",
      "这个空间里面的内容是“ab”",
      "然后让s指向这个空间",
      "显然会报错，因为有final修饰，s无法改变其指向",
      "所以说，对于不可变数据类型，一旦被创建，其值不能改变"
    ],
    "codes": [
      "int n=1;\nif (n) n++;\n",
      "int a=1,b=0;\nSystem.out.println(a/b);\n",
      "StringBuilder sb=new StringBuilder(\"a\");\nsb.append(\"b\");\n",
      "String s=\"a\";\ns=s.concat(\"b\");\n",
      "final StringBuilder sb=new StringBuilder(\"a\");\nsb.append(\"b\");\n",
      "final StringBuilder sb=new StringBuilder(\"a\");\nsb=new StringBuilder(\"ab\");\n",
      "final String s=\"a\";\ns=s.concat(\"b\");\n"
    ],
    "date": "2021-07-01",
    "text": "文章目录\n一、类型检查\n1.静态类型检查\n2.动态类型检查\n二、可变数据类型和不可变数据类型\n1.可变数据类型\n2.不可变数据类型\nfinal修饰符\n修饰可变类型\n修饰不可变类型\n最近在复习，感觉类型检查那部分细节比较多，final修饰符也会涉及到类型检查，所以就把这两个知识点综合起来总结一下。\n一、类型检查\n1.静态类型检查\nJava是一种静态类型的语言。\n----所有变量的类型在编译的时候就已经知道了，然后编译器也会导出所有表达式的类型。\n----如果a和b为int类型，那么编译器会推断a+b也是int类型。\n----eclipse环境会在你写代码的时候就做这些事情，所以你在写代码的时候就会发现eclipse可能报出一些错误。\n----\n静态类型检查在编译阶段进行。\n在编译阶段发现错误，避免了将错误带到运行阶段，可提高程序正确性。\n一般是类型相关的错误。如语法错误，类名、函数名错误，参数数目、类型错误，返回值类型错误。\n在eclipse中输入这段代码时，在第二个n处会有红色波浪线，因为和C不一样，Java的判断语句内必须的boolean类型的。所以编译器在编译阶段就会报错。\n2.动态类型检查\n在像python这样的动态类型语言中，这种检查推迟到运行时候。\n----\n在运行阶段进行类型检查。\n一般的错误有非法的参数值，非法的返回值，越界，空指针。\n在eclipse中输入这段代码，没有运行时，不会报错。但运行后会抛出异常：Exception in thread “main” java.lang.ArithmeticException: / by zero。这是在运行阶段进行检查的动态类型检查。\n二、可变数据类型和不可变数据类型\n1.可变数据类型\n可变数据类型是当改变一个变量的值时，将该变量当前指向的值的存储空间中写入一个新的值。\n比如StringBuilder是一种可变的数据类型。\n其内部的过程可以由这个图来表示：\n2.不可变数据类型\n不可变数据类型是改变一个变量，将该变量指向令一个值的存储空间。\n比如String是一种不可变的数据类型。\n其内部的过程可以由这个图来表示：\nfinal修饰符\n用final修饰class可以阻止被继承；修饰method可以阻止被子类重写；修饰field可以阻止被重新赋值；修饰局部变量也可以阻止被重新赋值。\n下面主要讨论final分别修饰可变和不可变数据类型与静态类型检查的情况。\n修饰可变类型\n以StringBuilder为例。\n这段代码没有任何问题，代码快照图和上文可变数据类型的图相同。依然是同一个空间，只是空间里的值不同了。\n这段代码在第二个sb处就会有红色波浪线，因为有final修饰，无法改变变量指向的对象。对于可变数据类型，final使得变量无法改变其引用。\n修饰不可变类型\n以String为例。\n和上文的图相同，String是不可变的数据类型，无法修改值，只能重新创建一个空间。这段代码就想要重新创造一个空间，这个空间里面的内容是“ab”，然后让s指向这个空间。显然会报错，因为有final修饰，s无法改变其指向。所以说，对于不可变数据类型，一旦被创建，其值不能改变。\n"
  },
  {
    "head": "python中将一个每个元素都是字符串类型的list拼接成一个字符串",
    "paragraphs": [
      "l就是’12345‘了。很简单，也很方便。"
    ],
    "sentences": [
      "l就是’12345‘了",
      "很简单，也很方便"
    ],
    "codes": [
      "l=['1','2','3','4','5']\nl=''.join(l)\n"
    ],
    "date": "2021-07-20",
    "text": "l就是’12345‘了。很简单，也很方便。\n"
  },
  {
    "head": "学习了Java中ADT的等价性的一些收获",
    "paragraphs": [
      "这里写自定义目录标题",
      "等价关系",
      "对象的等价性",
      "equals函数",
      "hashCode函数",
      "可变类型的等价性",
      "对equals和hashCode的总结",
      "最近在软件构造课里学习了Java中ADT的等价性，希望能够通过写博客这种方式来总结一下，加强理解。",
      "等价关系",
      "之前在集合论与图论中学过关系，等价关系需要满足三个性质，自反性、对称性、传递性。",
      "对于一个集合T，这个集合的某一个关系可以定义为其笛卡尔积的子集，即关系R",
      "\\subseteq",
      "\\times",
      "T。下面看看等价关系的三个性质。",
      "自反性",
      "\\forall",
      "\\in",
      "T, t R t.",
      "对称性",
      "\\forall",
      "u,v",
      "\\in",
      "T, if u R v, then v R u.",
      "传递性",
      "\\forall",
      "u,v,w",
      "\\in",
      "T, if u R v, and v R w, then u R w.",
      "对象的等价性",
      "注：这里的对象指的都是不可变(immutable)的，如果是可变的，直接用Object类里的函数即可。",
      "老师上课举的例子我觉得对我的启示比较大，两个对象是否等价，需要比较的不应该是它们内部的属性，而是属性经过AF(abstraction function)映射后是结果，即AF(rep1)是否等于AF(rep2)。其中rep1和req2分别是待比较的两个对象的属性列表。",
      "例子如下：",
      "这是一个表示时间的类，如果要比较两个Duration对象的等价性，判断两个属性是否相等显然是不合理的，比如",
      "这两个对象虽然内部的属性不同，但表示的意义都是62秒，所以应该等价。这里就可以用函数getLength()来判断了，如果返回值相等，则等价。",
      "在这里需要约束class里面的方法。对于两个等价的对象，执行同一观察器（observer）函数，返回的结果也要一样。例如有一个class的结构如下：",
      "这个isAllLowercase函数就是错误的。比如\"abc\"和\"ABC\"，有AF，都映射到集合{a,b,c}，但这个函数的返回值不同。",
      "equals函数",
      "首先看一下Object类中的equals函数。",
      "对于这个缺省的equals函数，我的理解是判断两个对象是否指向同一个内存空间（不太确定），所以一般来说，对于自己编写的类，需要以上文的原则重写这个函数。",
      "重写函数的代码基本如下：",
      "注意，这里的参数必须是Object型。这是因为这是对父类函数的重写（override），参数列表必须相同，如果参数类型不同，那是重载（overload）。比如说我们把equals函数写成下面的格式：public boolean equals(Duration)，则如果调用函数传入的参数类型是Duration，当然默认调用是我们写的这个函数，但如果参数是其他的类型，因为类型不匹配，所以会调用父类的equals函数，发生错误。",
      "hashCode函数",
      "这个函数的功能是将对象映射到一个常数。看一下Object类中的hashCode函数。",
      "这个函数的默认实现是返回它的内存地址。重写这个函数的规则和equals相似，都是由AF决定的。如果两个对象等价，则它们的hashCode返回值一定相等。对于上面的例子Duration这个类，重写的一种方法为：",
      "可变类型的等价性",
      "这里引出了两个概念，观察等价性和行为等价性。",
      "观察等价性",
      "在不改变状态的情况下，两个mutable对象是否看起来一致。",
      "行为等价性",
      "调用对象的任何方法都展示出一致的结果。",
      "对于不可变类型来说，这两种等价性是等价的，不可变类型没有变化器（mutator）方法。",
      "对于可变类型，往往使用观察等价性来判断，但有时用观察等价性会出现bug。",
      "当我们编写一个可变类型时，实现行为等价性即可，equals函数和hashCode函数，不需要重写，直接继承Object的两个方法就行了。当然如果一定要判断两个可变类型“看起来”是否一致，可以定义一个新的方法来判断。",
      "对equals和hashCode的总结",
      "对于不可变类型",
      "必须重写这两个方法，保证行为等价性，行为等价性等价于观察等价性。",
      "对于可变类型",
      "不需要重写，保证行为等价性。",
      "最后，本人新手，恳请斧正。"
    ],
    "sentences": [
      "这里写自定义目录标题",
      "等价关系",
      "对象的等价性",
      "equals函数",
      "hashCode函数",
      "可变类型的等价性",
      "对equals和hashCode的总结",
      "最近在软件构造课里学习了Java中ADT的等价性",
      "希望能够通过写博客这种方式来总结一下",
      "加强理解",
      "等价关系",
      "之前在集合论与图论中学过关系",
      "等价关系需要满足三个性质",
      "自反性、对称性、传递性",
      "对于一个集合T",
      "这个集合的某一个关系可以定义为其笛卡尔积的子集",
      "即关系R",
      "\\subseteq",
      "\\times",
      "T",
      "下面看看等价关系的三个性质",
      "自反性",
      "\\forall",
      "\\in",
      "T, t R t.对称性",
      "\\forall",
      "u,v",
      "\\in",
      "T, if u R v, then v R u.传递性",
      "\\forall",
      "u,v,w",
      "\\in",
      "T, if u R v, and v R w, then u R w.对象的等价性",
      "注：这里的对象指的都是不可变(immutable)的",
      "如果是可变的",
      "直接用Object类里的函数即可",
      "老师上课举的例子我觉得对我的启示比较大",
      "两个对象是否等价",
      "需要比较的不应该是它们内部的属性",
      "而是属性经过AF(abstraction function)映射后是结果",
      "即AF(rep1)是否等于AF(rep2)",
      "其中rep1和req2分别是待比较的两个对象的属性列表",
      "例子如下：这是一个表示时间的类",
      "如果要比较两个Duration对象的等价性",
      "判断两个属性是否相等显然是不合理的",
      "比如",
      "这两个对象虽然内部的属性不同",
      "但表示的意义都是62秒",
      "所以应该等价",
      "这里就可以用函数getLength()来判断了",
      "如果返回值相等",
      "则等价",
      "在这里需要约束class里面的方法",
      "对于两个等价的对象",
      "执行同一观察器（observer）函数",
      "返回的结果也要一样",
      "例如有一个class的结构如下：这个isAllLowercase函数就是错误的",
      "比如\"abc\"和\"ABC\"",
      "有AF",
      "都映射到集合{a,b,c}",
      "但这个函数的返回值不同",
      "equals函数",
      "首先看一下Object类中的equals函数",
      "对于这个缺省的equals函数",
      "我的理解是判断两个对象是否指向同一个内存空间（不太确定）",
      "所以一般来说",
      "对于自己编写的类",
      "需要以上文的原则重写这个函数",
      "重写函数的代码基本如下：注意，这里的参数必须是Object型",
      "这是因为这是对父类函数的重写（override）",
      "参数列表必须相同",
      "如果参数类型不同",
      "那是重载（overload）",
      "比如说我们把equals函数写成下面的格式：public boolean equals(Duration)",
      "则如果调用函数传入的参数类型是Duration",
      "当然默认调用是我们写的这个函数",
      "但如果参数是其他的类型",
      "因为类型不匹配",
      "所以会调用父类的equals函数",
      "发生错误",
      "hashCode函数",
      "这个函数的功能是将对象映射到一个常数",
      "看一下Object类中的hashCode函数",
      "这个函数的默认实现是返回它的内存地址",
      "重写这个函数的规则和equals相似，都是由AF决定的",
      "如果两个对象等价，则它们的hashCode返回值一定相等",
      "对于上面的例子Duration这个类",
      "重写的一种方法为：可变类型的等价性",
      "这里引出了两个概念，观察等价性和行为等价性",
      "观察等价性",
      "在不改变状态的情况下，两个mutable对象是否看起来一致",
      "行为等价性",
      "调用对象的任何方法都展示出一致的结果",
      "对于不可变类型来说",
      "这两种等价性是等价的",
      "不可变类型没有变化器（mutator）方法",
      "对于可变类型",
      "往往使用观察等价性来判断",
      "但有时用观察等价性会出现bug",
      "当我们编写一个可变类型时",
      "实现行为等价性即可",
      "equals函数和hashCode函数",
      "不需要重写",
      "直接继承Object的两个方法就行了",
      "当然如果一定要判断两个可变类型“看起来”是否一致",
      "可以定义一个新的方法来判断",
      "对equals和hashCode的总结",
      "对于不可变类型",
      "必须重写这两个方法",
      "保证行为等价性",
      "行为等价性等价于观察等价性",
      "对于可变类型",
      "不需要重写，保证行为等价性",
      "最后，本人新手，恳请斧正"
    ],
    "codes": [
      "public class Duration {\n\tprivate final mins;\n\tprivate final secs;\n\t// rep invariant:\n\t//    mins >= 0, secs >= 0\n\t// abstraction function:\n\t//    represents a span of time of mins minutes and secs seconds\n\t/** Make a duration lasting for m minutes and s seconds. */\n\tpublic Duration(int m,int s) {\n\t\tmins=m;\n\t\tsecs=s;\n\t}\n\t/** @return length of this duration in seconds */\n\tpublic long getLength() {\n\t\treturn mins*60+secs;\n\t}\n}\n",
      "Duration d1=new Duration(1,2);\nDuration d2=new Duration(0,62);\n",
      "class LetterSet {\n\tprivate String s;\n\t//Abstraction function:\n\t//\tAF(s) = the subset of the letters {a...z} that are found in s\n\t//\t(ignoring alphabetic case and non-letters)\t\n\t\n\t/** @return true if and only if all the letters in this set are lowercase */\n\tpublic boolean isAllLowercase() {...}\n}\n",
      "public class Object() {\n\t...\n\tpublic boolean equals(Object that) {\n    \treturn this == that;\n\t}\t\n}\n",
      "@Override\npublic boolean equals(Object o) {\n\tif (!(o instanceof Duration)) return false;\n\tDuration that = (Duration) o;\n\treturn this.getLength() == that.getLength();\n}\n",
      "public class Object {\n\t...\n\tpublic boolean equals(Object that) {return this == that; }\n\tpublic int hashCode() {return /* the memory address of this */;}\n}\n",
      "@Override\npublic int hashCode() {\n\treturn (int) getLength();\n}\n"
    ],
    "date": "2021-06-02",
    "text": "这里写自定义目录标题\n等价关系\n对象的等价性\nequals函数\nhashCode函数\n可变类型的等价性\n对equals和hashCode的总结\n最近在软件构造课里学习了Java中ADT的等价性，希望能够通过写博客这种方式来总结一下，加强理解。\n等价关系\n之前在集合论与图论中学过关系，等价关系需要满足三个性质，自反性、对称性、传递性。\n对于一个集合T，这个集合的某一个关系可以定义为其笛卡尔积的子集，即关系R\n\\subseteq\n\\times\nT。下面看看等价关系的三个性质。\n自反性\n\\forall\n\\in\nT, t R t.\n对称性\n\\forall\nu,v\n\\in\nT, if u R v, then v R u.\n传递性\n\\forall\nu,v,w\n\\in\nT, if u R v, and v R w, then u R w.\n对象的等价性\n注：这里的对象指的都是不可变(immutable)的，如果是可变的，直接用Object类里的函数即可。\n老师上课举的例子我觉得对我的启示比较大，两个对象是否等价，需要比较的不应该是它们内部的属性，而是属性经过AF(abstraction function)映射后是结果，即AF(rep1)是否等于AF(rep2)。其中rep1和req2分别是待比较的两个对象的属性列表。\n例子如下：\n这是一个表示时间的类，如果要比较两个Duration对象的等价性，判断两个属性是否相等显然是不合理的，比如\n这两个对象虽然内部的属性不同，但表示的意义都是62秒，所以应该等价。这里就可以用函数getLength()来判断了，如果返回值相等，则等价。\n在这里需要约束class里面的方法。对于两个等价的对象，执行同一观察器（observer）函数，返回的结果也要一样。例如有一个class的结构如下：\n这个isAllLowercase函数就是错误的。比如\"abc\"和\"ABC\"，有AF，都映射到集合{a,b,c}，但这个函数的返回值不同。\nequals函数\n首先看一下Object类中的equals函数。\n对于这个缺省的equals函数，我的理解是判断两个对象是否指向同一个内存空间（不太确定），所以一般来说，对于自己编写的类，需要以上文的原则重写这个函数。\n重写函数的代码基本如下：\n注意，这里的参数必须是Object型。这是因为这是对父类函数的重写（override），参数列表必须相同，如果参数类型不同，那是重载（overload）。比如说我们把equals函数写成下面的格式：public boolean equals(Duration)，则如果调用函数传入的参数类型是Duration，当然默认调用是我们写的这个函数，但如果参数是其他的类型，因为类型不匹配，所以会调用父类的equals函数，发生错误。\nhashCode函数\n这个函数的功能是将对象映射到一个常数。看一下Object类中的hashCode函数。\n这个函数的默认实现是返回它的内存地址。重写这个函数的规则和equals相似，都是由AF决定的。如果两个对象等价，则它们的hashCode返回值一定相等。对于上面的例子Duration这个类，重写的一种方法为：\n可变类型的等价性\n这里引出了两个概念，观察等价性和行为等价性。\n观察等价性\n在不改变状态的情况下，两个mutable对象是否看起来一致。\n行为等价性\n调用对象的任何方法都展示出一致的结果。\n对于不可变类型来说，这两种等价性是等价的，不可变类型没有变化器（mutator）方法。\n对于可变类型，往往使用观察等价性来判断，但有时用观察等价性会出现bug。\n当我们编写一个可变类型时，实现行为等价性即可，equals函数和hashCode函数，不需要重写，直接继承Object的两个方法就行了。当然如果一定要判断两个可变类型“看起来”是否一致，可以定义一个新的方法来判断。\n对equals和hashCode的总结\n对于不可变类型\n必须重写这两个方法，保证行为等价性，行为等价性等价于观察等价性。\n对于可变类型\n不需要重写，保证行为等价性。\n最后，本人新手，恳请斧正。\n"
  },
  {
    "head": "初学Iterator迭代器设计模式",
    "paragraphs": [
      "初学迭代器设计模式，一直不怎么理解，希望通过写篇博客加强理解。",
      "我的理解是，迭代器设计模式可以解决这个问题。如果我有一个自已定义的类，这个类有当作容器的功能，比如里面有一个属性是Set，然后我想要遍历被放入这个容器类的一组ADT对象，而无需关注容器的具体类型，这时就可以使用迭代器设计模式了。",
      "我们需要关注两个接口，Iterable和Iterator。这两个接口的大致结构如下：",
      "让自己的集合类实现Iterable接口，并实现自己独特的Iterator迭代器（hasNext,next,remove），允许客户端利用这个迭代器进行显示或隐式的迭代遍历：",
      "下面看一个具体的例子。比如我们要造一个停车场ParkingField，这是一个接口，它的实现类是ConcreteParkingField。然后车位的类叫Lot，停进去的东西有汽车，摩托车等，所以有一个接口Parkable。下面看看怎么实现迭代器。",
      "我们首先需要给停车场这个容器提供遍历的功能，所以用ParkingField继承接口Iterable，再用ConcreteParkingField实现ParkingField。r然后需要提供一个迭代器，用ParkingIterator来实现接口Iterator。代码框架大致如下（里面的方法和属性不是重点，所以我把大部分的属性用…代替，重点是和迭代器相关的东西）：",
      "ParkingField继承接口Iterable",
      "ConcreteParkingField实现接口ParkingField",
      "ParkingIterator来实现接口Iterator",
      "注意，正常情况下Iterator的泛型应该是Parkable，为了不给ParkingField和client泄露Parkable，改成了String。",
      "总的来说，迭代器模式让数据处理逻辑和内部数据管理分离，用一种更安全的方式进行遍历。此外，还可以还可以控制内部数据的顺序，这上面的例子中，于ParkingIterator的构造方法中加入一个排序即可。",
      "以上，如有错误，恳请斧正。"
    ],
    "sentences": [
      "初学迭代器设计模式，一直不怎么理解，希望通过写篇博客加强理解",
      "我的理解是，迭代器设计模式可以解决这个问题",
      "如果我有一个自已定义的类",
      "这个类有当作容器的功能",
      "比如里面有一个属性是Set",
      "然后我想要遍历被放入这个容器类的一组ADT对象",
      "而无需关注容器的具体类型",
      "这时就可以使用迭代器设计模式了",
      "我们需要关注两个接口，Iterable和Iterator",
      "这两个接口的大致结构如下：让自己的集合类实现Iterable接口",
      "并实现自己独特的Iterator迭代器（hasNext,next,remove）",
      "允许客户端利用这个迭代器进行显示或隐式的迭代遍历：下面看一个具体的例子",
      "比如我们要造一个停车场ParkingField",
      "这是一个接口",
      "它的实现类是ConcreteParkingField",
      "然后车位的类叫Lot",
      "停进去的东西有汽车",
      "摩托车等",
      "所以有一个接口Parkable",
      "下面看看怎么实现迭代器",
      "我们首先需要给停车场这个容器提供遍历的功能",
      "所以用ParkingField继承接口Iterable",
      "再用ConcreteParkingField实现ParkingField",
      "r然后需要提供一个迭代器",
      "用ParkingIterator来实现接口Iterator",
      "代码框架大致如下（里面的方法和属性不是重点",
      "所以我把大部分的属性用…代替",
      "重点是和迭代器相关的东西）：ParkingField继承接口Iterable",
      "ConcreteParkingField实现接口ParkingField",
      "ParkingIterator来实现接口Iterator",
      "注意",
      "正常情况下Iterator的泛型应该是Parkable",
      "为了不给ParkingField和client泄露Parkable",
      "改成了String",
      "总的来说",
      "迭代器模式让数据处理逻辑和内部数据管理分离",
      "用一种更安全的方式进行遍历",
      "此外",
      "还可以还可以控制内部数据的顺序",
      "这上面的例子中",
      "于ParkingIterator的构造方法中加入一个排序即可",
      "以上，如有错误，恳请斧正"
    ],
    "codes": [
      "public interface Iterable<T> {\n\t...\n\tIterator<T> iterator();\n}\n",
      "public interface Iterator<E> {\n\tboolean hasNext();\n\tE next();\n\tvoid remove();\n}\n",
      "for (E e : collection) {...}\n\nIterator<E> iter=collection.iterator();\nwhile (iter.hasNext()) {...}\n",
      "public interface ParkingField extends Iterable<String> {\n\n\tpublic static ParkingField create(int[] nos, int[] widths) throws Exception {\n\t\treturn new ConcreteParkingField(nos, widths);\n\t}\n\t\n\tpublic static ParkingField create(Map<Integer, Integer> lots) throws Exception {\n\t\treturn new ConcreteParkingField(lots);\n\t}\n\t\n\tpublic void parking(String type, String plate, int width, int num, String[] extraRegistrationInfo) throws Exception;\n\n\tpublic void parking(String type, String plate, int width, String[] extraRegistrationInfo);\n\n\tpublic double depart(String plate) throws Exception;\n\t\n\tpublic Map<Integer, String> status();\n\t\n\tpublic int getNumberOfLots();\n\t\n\tpublic boolean isLotInParkingField(int num, int width);\n\t\n\tpublic boolean isEmpty();\n\n\tint getLotWidth(int num) throws Exception;\n\n}\n",
      "public class ConcreteParkingField implements ParkingField {\n\tprivate final ...\n\tprivate final Map<Lot, Parkable> status = new HashMap<>();\n\tprivate final ...\n\t\n\tpublic ConcreteParkingField(Map<Integer, Integer> lotsInfo) throws Exception {...}\n\t\n\tpublic ConcreteParkingField(int[] nos, int[] widths) {...}\n\t\n\t@Override\n\tpublic void parking(String type, String plate, int width, int num, String[] extraRegistrationInfo) throws Exception {...}\n\t\n\t@Override\n\tpublic void parking(String type, String plate, int width, String[] extraRegistrationInfo) {...}\n\t\n\t@Override\n\tpublic double depart(String plate) throws Exception {...}\n\t\n\t@Override\n\tpublic Map<Integer, String> status() {...}\n\t\n\t@Override\n\tpublic int getNumberOfLots() {...}\n\t\n\t@Override\n\tpublic boolean isLotInParkingField(int num, int width) {...}\n\t\n\t@Override\n\tpublic boolean isEmpty() {...}\n\t\n\t@Override\n\tpublic int getLotWidth(int num) throws Exception {...}\n\t\n\t@Override\n\tpublic String toString() {...}\n\t// 重点是这个。。。返回一个迭代器\n\t@Override\n\tpublic Iterator<String> iterator() {\n\t\treturn new ParkingIterator(this.status);\n\t}\n",
      "public class ParkingIterator implements Iterator<String> {\n\n\tprivate final ...\n\tprivate final ...\n\tprivate int count = 0;\n\n\tpublic ParkingIterator(...) {\n\t\t...\n\t}\n\n\t@Override\n\tpublic boolean hasNext() {\n\t\treturn count < ....size();\n\t}\n\n\t@Override\n\tpublic String next() {\n\t\t...\n\t\tcount ++;\n\t\t...\n\t}\n\n\t@Override\n\tpublic void remove() {\n\t\t...\n\t}\n\n}\n"
    ],
    "date": "2021-07-07",
    "text": "初学迭代器设计模式，一直不怎么理解，希望通过写篇博客加强理解。\n我的理解是，迭代器设计模式可以解决这个问题。如果我有一个自已定义的类，这个类有当作容器的功能，比如里面有一个属性是Set，然后我想要遍历被放入这个容器类的一组ADT对象，而无需关注容器的具体类型，这时就可以使用迭代器设计模式了。\n我们需要关注两个接口，Iterable和Iterator。这两个接口的大致结构如下：\n让自己的集合类实现Iterable接口，并实现自己独特的Iterator迭代器（hasNext,next,remove），允许客户端利用这个迭代器进行显示或隐式的迭代遍历：\n下面看一个具体的例子。比如我们要造一个停车场ParkingField，这是一个接口，它的实现类是ConcreteParkingField。然后车位的类叫Lot，停进去的东西有汽车，摩托车等，所以有一个接口Parkable。下面看看怎么实现迭代器。\n我们首先需要给停车场这个容器提供遍历的功能，所以用ParkingField继承接口Iterable，再用ConcreteParkingField实现ParkingField。r然后需要提供一个迭代器，用ParkingIterator来实现接口Iterator。代码框架大致如下（里面的方法和属性不是重点，所以我把大部分的属性用…代替，重点是和迭代器相关的东西）：\nParkingField继承接口Iterable\nConcreteParkingField实现接口ParkingField\nParkingIterator来实现接口Iterator\n注意，正常情况下Iterator的泛型应该是Parkable，为了不给ParkingField和client泄露Parkable，改成了String。\n总的来说，迭代器模式让数据处理逻辑和内部数据管理分离，用一种更安全的方式进行遍历。此外，还可以还可以控制内部数据的顺序，这上面的例子中，于ParkingIterator的构造方法中加入一个排序即可。\n以上，如有错误，恳请斧正。\n"
  },
  {
    "head": "Java中的列举Enumerations",
    "paragraphs": [
      "复习的时候发现Java中的Enumerations这个类型以前好像没有见过，感觉有时候还是挺有用的，所以就来记录一下。",
      "根据我的理解，Enumerations就是一个类class，但是里面可以自定义一些常用的对象。比如说我有一个课程（Course）类，然后我经常使用的对象有math，Chinese，English这三门课程，所以就可以把这三种对象定义在Enumerations里面。",
      "像这样，我定义了一个Enumerations，里面有三个常用的对象，math，Chinese，English。如果想要调用其中一个也很容易，如下：",
      "这样，m就是math这个对象了。",
      "另外，还可以遍历这些对象，像这样：",
      "后来又发现一点，不要轻易修改里面属性的值。比如现在我把Course修改如下，让它变成一个mutable的ADT，就是把studyHours前面的final修饰符去掉，然后增加了一个修改studyHours的方法setStudyHours。",
      "然后我尝试修改属性的值：",
      "结果输出都是4。这就说明第一句的m=Course.math应该是让m指向math的空间，然后修改m的studyHours后，这个空间里的studyHours就会发生变化，所以Enumerations里面的math对象也就变化了。",
      "因此我觉得对于Enumerations，还是使用immutable的数据类型为好。"
    ],
    "sentences": [
      "复习的时候发现Java中的Enumerations这个类型以前好像没有见过",
      "感觉有时候还是挺有用的",
      "所以就来记录一下",
      "根据我的理解",
      "Enumerations就是一个类class",
      "但是里面可以自定义一些常用的对象",
      "比如说我有一个课程（Course）类",
      "然后我经常使用的对象有math",
      "Chinese",
      "English这三门课程",
      "所以就可以把这三种对象定义在Enumerations里面",
      "像这样",
      "我定义了一个Enumerations",
      "里面有三个常用的对象",
      "math",
      "Chinese",
      "English",
      "如果想要调用其中一个也很容易",
      "如下：这样",
      "m就是math这个对象了",
      "另外",
      "还可以遍历这些对象",
      "像这样：后来又发现一点",
      "不要轻易修改里面属性的值",
      "比如现在我把Course修改如下",
      "让它变成一个mutable的ADT",
      "就是把studyHours前面的final修饰符去掉",
      "然后增加了一个修改studyHours的方法setStudyHours",
      "然后我尝试修改属性的值：结果输出都是4",
      "这就说明第一句的m=Course.math应该是让m指向math的空间",
      "然后修改m的studyHours后",
      "这个空间里的studyHours就会发生变化",
      "所以Enumerations里面的math对象也就变化了",
      "因此我觉得对于Enumerations",
      "还是使用immutable的数据类型为好"
    ],
    "codes": [
      "public enum Course {\n\tmath(\"math\",6,\"m\"),Chinese(\"Chinese\",4,\"c\"),English(\"English\",4,\"e\");\n\t\n\tprivate final String courseName;\n\tprivate final int studyHours;\n\tprivate final String teacherName;\n\t\n\tCourse(String courseName,int studyHours,String teacherName) {\n\t\tthis.courseName=courseName;\n\t\tthis.studyHours=studyHours;\n\t\tthis.teacherName=teacherName;\n\t}\n\t\n\tpublic String getCourseName() {\n\t\treturn this.courseName;\n\t}\n\t\n\tpublic String getTeacherName() {\n\t\treturn this.teacherName;\n\t}\n\t\n\tpublic int getStudyHours() {\n\t\treturn this.studyHours;\n\t}\n}\n",
      "Course m=Course.math;\nSystem.out.println(m.getTeacherName());\n",
      "for (Course p : Course.values()) {\n\tSystem.out.println(p.getCourseName());\n}\n",
      "public enum Course {\n\tmath(\"math\",6,\"m\"),Chinese(\"Chinese\",4,\"c\"),English(\"English\",4,\"e\");\n\t\n\tprivate final String courseName;\n\tprivate int studyHours;\n\tprivate final String teacherName;\n\t\n\tCourse(String courseName,int studyHours,String teacherName) {\n\t\tthis.courseName=courseName;\n\t\tthis.studyHours=studyHours;\n\t\tthis.teacherName=teacherName;\n\t}\n\t\n\tpublic String getCourseName() {\n\t\treturn this.courseName;\n\t}\n\t\n\tpublic String getTeacherName() {\n\t\treturn this.teacherName;\n\t}\n\t\n\tpublic int getStudyHours() {\n\t\treturn this.studyHours;\n\t}\n\t\n\tpublic void setStudyHours(int hours) {\n\t\tthis.studyHours=hours;\n\t}\n}\n",
      "public static void main(String[] args) {\n\tCourse m=Course.math;\n\tm.setStudyHours(4);\n\tSystem.out.println(m.getStudyHours());\n\tSystem.out.println(Course.math.getStudyHours());\n}\n"
    ],
    "date": "2021-07-02",
    "text": "复习的时候发现Java中的Enumerations这个类型以前好像没有见过，感觉有时候还是挺有用的，所以就来记录一下。\n根据我的理解，Enumerations就是一个类class，但是里面可以自定义一些常用的对象。比如说我有一个课程（Course）类，然后我经常使用的对象有math，Chinese，English这三门课程，所以就可以把这三种对象定义在Enumerations里面。\n像这样，我定义了一个Enumerations，里面有三个常用的对象，math，Chinese，English。如果想要调用其中一个也很容易，如下：\n这样，m就是math这个对象了。\n另外，还可以遍历这些对象，像这样：\n后来又发现一点，不要轻易修改里面属性的值。比如现在我把Course修改如下，让它变成一个mutable的ADT，就是把studyHours前面的final修饰符去掉，然后增加了一个修改studyHours的方法setStudyHours。\n然后我尝试修改属性的值：\n结果输出都是4。这就说明第一句的m=Course.math应该是让m指向math的空间，然后修改m的studyHours后，这个空间里的studyHours就会发生变化，所以Enumerations里面的math对象也就变化了。\n因此我觉得对于Enumerations，还是使用immutable的数据类型为好。\n"
  },
  {
    "head": "python中列表中的元素转字符串",
    "paragraphs": [
      "假如有一个列表** l=[1,2,3,4,5] **，现在想把其中的每个元素都转成字符串形式",
      "这样：",
      "结果为[‘1’,‘2’,‘3’,‘4’,‘5’]"
    ],
    "sentences": [
      "假如有一个列表** l=[1,2,3,4,5] **",
      "现在想把其中的每个元素都转成字符串形式",
      "这样：结果为[‘1’,‘2’,‘3’,‘4’,‘5’]"
    ],
    "codes": [
      "l=[1,2,3,4,5]\nl=[str(x) for x in l]\n"
    ],
    "date": "2021-07-20",
    "text": "假如有一个列表** l=[1,2,3,4,5] **，现在想把其中的每个元素都转成字符串形式\n这样：\n结果为[‘1’,‘2’,‘3’,‘4’,‘5’]\n"
  },
  {
    "head": "Java中类的继承时调用方法的小细节",
    "paragraphs": [
      "我在复习备考时发现自己对部分细节还是不熟悉，所以写篇博客记录一下，希望能够帮到大家。",
      "首先我写了三个类，animal，dog，husky。",
      "代码如下，非常简单。",
      "我们创建对象时，有三组，共六种方式：",
      "第一个",
      "这里显然只能这样调用，输出结果是eat 100和run 100没有疑问。",
      "第二个",
      "可以看到，虽然dog类中run方法的参数类型是String，但这里只支持int的参数，也就是父类animal的run方法。这是因为这种定义方法，编译器将b静态解析成animal类，所以只能调用animal中的方法。运行一下试试",
      "输出结果为：eat 200 （换行）run 100。",
      "可以看到，eat方法虽然静态解析成animal中的方法，但运行时还是dog的eat方法。run方法，因为参数是int型，所以运行时只能调用animal的run方法。",
      "第三个",
      "正如刚才所说，静态检查下是animal的方法。",
      "输出结果为eat 200（换行）run 300。husky中只重写了run方法，所以调用eat时默认运行的是父类dog的eat方法，而调用run方法就是husky的run方法。",
      "第四个",
      "dog d=new dog();比较容易， 就不再阐述了。",
      "第五个",
      "这里的静态解析，将e解析成dog类，可以调用dog类中的方法和其父类animal类中的方法。",
      "输出结果为eat 200（换行）run 300（换行）run 200。因为husky中没有些eat，所以这里调用的是父类dog中的eat。然后husky中有run(int p)，所以参数为int时调用husky中的run。参数为String时向父类搜索，调用dog中的run。",
      "第六个",
      "husky f=new husky();",
      "这种情况类似于上一种。",
      "结果也和上面一种一样，这里就不解释了。",
      "以上内容全部是个人通过代码实验出来的，如果有误，恳请斧正。"
    ],
    "sentences": [
      "我在复习备考时发现自己对部分细节还是不熟悉",
      "所以写篇博客记录一下",
      "希望能够帮到大家",
      "首先我写了三个类，animal，dog，husky",
      "代码如下，非常简单",
      "我们创建对象时，有三组，共六种方式：第一个",
      "这里显然只能这样调用",
      "输出结果是eat 100和run 100没有疑问",
      "第二个",
      "可以看到",
      "虽然dog类中run方法的参数类型是String",
      "但这里只支持int的参数",
      "也就是父类animal的run方法",
      "这是因为这种定义方法",
      "编译器将b静态解析成animal类",
      "所以只能调用animal中的方法",
      "运行一下试试",
      "输出结果为：eat 200 （换行）run 100",
      "可以看到",
      "eat方法虽然静态解析成animal中的方法",
      "但运行时还是dog的eat方法",
      "run方法",
      "因为参数是int型",
      "所以运行时只能调用animal的run方法",
      "第三个",
      "正如刚才所说，静态检查下是animal的方法",
      "输出结果为eat 200（换行）run 300",
      "husky中只重写了run方法",
      "所以调用eat时默认运行的是父类dog的eat方法",
      "而调用run方法就是husky的run方法",
      "第四个",
      "dog d=new dog();比较容易， 就不再阐述了",
      "第五个",
      "这里的静态解析",
      "将e解析成dog类",
      "可以调用dog类中的方法和其父类animal类中的方法",
      "输出结果为eat 200（换行）run 300（换行）run 200",
      "因为husky中没有些eat",
      "所以这里调用的是父类dog中的eat",
      "然后husky中有run(int p)",
      "所以参数为int时调用husky中的run",
      "参数为String时向父类搜索，调用dog中的run",
      "第六个",
      "husky f=new husky();这种情况类似于上一种",
      "结果也和上面一种一样，这里就不解释了",
      "以上内容全部是个人通过代码实验出来的，如果有误，恳请斧正"
    ],
    "codes": [
      "public class animal {\n\n\tpublic void eat() {\n\t\tSystem.out.println(\"eat 100\");\n\t}\n\t\n\tpublic void run(int p) {\n\t\tSystem.out.println(\"run 100\");\n\t}\n}\n",
      "public class dog extends animal {\n\n\tpublic void eat() {\n\t\tSystem.out.println(\"eat 200\");\n\t}\n\t\n\tpublic void run(String p) {\n\t\tSystem.out.println(\"run 200\");\n\t}\n\t\n}\n",
      "public class husky extends dog {\n\n\tpublic void run(int p) {\n\t\tSystem.out.println(\"run 300\");\n\t}\n\t\n}\n",
      "animal a=new animal();\nanimal b=new dog();\nanimal c=new husky();\n\ndog d=new dog();\ndog e=new husky();\n\nhusky f=new husky();\n",
      "animal a=new animal();\na.eat();\na.run(0);\n",
      "animal b=new dog();\nb.eat();\nb.run(0);\n",
      "animal c=new husky();\nc.eat();\nc.run(0);\n",
      "dog e=new husky();\ne.eat();\ne.run(0);\ne.run(\"0\");\n",
      "husky f=new husky();\nf.eat();\nf.run(0);\nf.run(\"0\");\n"
    ],
    "date": "2021-07-07",
    "text": "我在复习备考时发现自己对部分细节还是不熟悉，所以写篇博客记录一下，希望能够帮到大家。\n首先我写了三个类，animal，dog，husky。\n代码如下，非常简单。\n我们创建对象时，有三组，共六种方式：\n第一个\n这里显然只能这样调用，输出结果是eat 100和run 100没有疑问。\n第二个\n可以看到，虽然dog类中run方法的参数类型是String，但这里只支持int的参数，也就是父类animal的run方法。这是因为这种定义方法，编译器将b静态解析成animal类，所以只能调用animal中的方法。运行一下试试\n输出结果为：eat 200 （换行）run 100。\n可以看到，eat方法虽然静态解析成animal中的方法，但运行时还是dog的eat方法。run方法，因为参数是int型，所以运行时只能调用animal的run方法。\n第三个\n正如刚才所说，静态检查下是animal的方法。\n输出结果为eat 200（换行）run 300。husky中只重写了run方法，所以调用eat时默认运行的是父类dog的eat方法，而调用run方法就是husky的run方法。\n第四个\ndog d=new dog();比较容易， 就不再阐述了。\n第五个\n这里的静态解析，将e解析成dog类，可以调用dog类中的方法和其父类animal类中的方法。\n输出结果为eat 200（换行）run 300（换行）run 200。因为husky中没有些eat，所以这里调用的是父类dog中的eat。然后husky中有run(int p)，所以参数为int时调用husky中的run。参数为String时向父类搜索，调用dog中的run。\n第六个\nhusky f=new husky();\n这种情况类似于上一种。\n结果也和上面一种一样，这里就不解释了。\n以上内容全部是个人通过代码实验出来的，如果有误，恳请斧正。\n"
  },
  {
    "head": "软件构造（四）Eclipse报错：A JNI error has occurred, please check your installation and try again.",
    "paragraphs": [
      "如果出现这个问题，并且正常java安装没问题可能主要的问题是Eclipse中设置的Compiler版本和JRE 不一致。如果不一致哪怕重新装多少遍jdk估计也没辙。",
      "JRE的版本，在工程目录中就可以直接看到，而Compiler的版本，可以右键选中工程project图标，然后选择properties — Java Compiler 在右边可以看到编译器版本是9，并且可以在下拉栏中修改。",
      "而我的Library版本是 jdk 1.8，所以需要将编译器版本也修改到1.8.",
      "在properties — Java Build Path中也可以对library remove和add的方式进行更换"
    ],
    "sentences": [
      "如果出现这个问题",
      "并且正常java安装没问题可能主要的问题是Eclipse中设置的Compiler版本和JRE 不一致",
      "如果不一致哪怕重新装多少遍jdk估计也没辙",
      "JRE的版本",
      "在工程目录中就可以直接看到",
      "而Compiler的版本",
      "可以右键选中工程project图标",
      "然后选择properties — Java Compiler 在右边可以看到编译器版本是9",
      "并且可以在下拉栏中修改",
      "而我的Library版本是 jdk 1.8",
      "所以需要将编译器版本也修改到1.8.在properties — Java Build Path中也可以对library remove和add的方式进行更换"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "如果出现这个问题，并且正常java安装没问题可能主要的问题是Eclipse中设置的Compiler版本和JRE 不一致。如果不一致哪怕重新装多少遍jdk估计也没辙。\nJRE的版本，在工程目录中就可以直接看到，而Compiler的版本，可以右键选中工程project图标，然后选择properties — Java Compiler 在右边可以看到编译器版本是9，并且可以在下拉栏中修改。\n而我的Library版本是 jdk 1.8，所以需要将编译器版本也修改到1.8.\n在properties — Java Build Path中也可以对library remove和add的方式进行更换\n"
  },
  {
    "head": "软件构造（二）checkRep遍历迭代器时死循环可能是因为assert没有设置开启",
    "paragraphs": [
      "第一次写checkRep的时候写成类似上面的格式，结果发现运行的时候如果It1.next的key为null，结果就会死循环，不能从while中退出。",
      "后来发现是一个很愚蠢的错误。在eclipse中assert功能是默认关闭的，需要自己在设置中打开。",
      "在新版本的eclipse中从菜单栏打开Run-Run Configurations…",
      "然后再在右边找到Arguments，在下面VM arguments里输入-ea，点击Run，就能解决问题。"
    ],
    "sentences": [
      "第一次写checkRep的时候写成类似上面的格式",
      "结果发现运行的时候如果It1.next的key为null",
      "结果就会死循环",
      "不能从while中退出",
      "后来发现是一个很愚蠢的错误",
      "在eclipse中assert功能是默认关闭的",
      "需要自己在设置中打开",
      "在新版本的eclipse中从菜单栏打开Run-Run Configurations…",
      "然后再在右边找到Arguments",
      "在下面VM arguments里输入-ea",
      "点击Run",
      "就能解决问题"
    ],
    "codes": [
      "private void checkRep() {\n\t\tIterator<String> It1 = set.iterator();\n\t\twhile (It1.hasNext()) {\n\t\t\tassert It1.next()!=null;\n\t\t}\n\n\t}"
    ],
    "date": "2021-07-05",
    "text": "第一次写checkRep的时候写成类似上面的格式，结果发现运行的时候如果It1.next的key为null，结果就会死循环，不能从while中退出。\n后来发现是一个很愚蠢的错误。在eclipse中assert功能是默认关闭的，需要自己在设置中打开。\n在新版本的eclipse中从菜单栏打开Run-Run Configurations…\n然后再在右边找到Arguments，在下面VM arguments里输入-ea，点击Run，就能解决问题。\n"
  },
  {
    "head": "下载OpenHarmony源码问题总结",
    "paragraphs": [
      "linux下注册和获取公钥的方法：",
      "ssh-keygen -t rsa -C \"xxxx@xx.com\"",
      "cat ~/.ssh/id_rsa.pub",
      "下载码云repo时候显示权限不够，可以申请root权限，sudo -i之后再执行。",
      "repo sync-c之后执行到最后远端意外断了，需要安装git-lfs",
      "显示/usr/bin/env/\"python\"没有那个文件或目录，但是python 3.8已经安装，可以将已有的python3复制为python。在该文件夹下。sudoln-s/usr/bin/python3/usr/bin/python",
      "如果代码下载到root文件夹下，可以用sudo nautilus打开",
      "源码大概10G，需要预留足够的空间。",
      "方便的全套教程：",
      "https://blog.csdn.net/wen381951203/article/details/109601800"
    ],
    "sentences": [
      "linux下注册和获取公钥的方法：ssh-keygen -t rsa -C \"xxxx@xx.com\"",
      "cat ~/.ssh/id_rsa.pub",
      "下载码云repo时候显示权限不够",
      "可以申请root权限",
      "sudo -i之后再执行",
      "repo sync-c之后执行到最后远端意外断了",
      "需要安装git-lfs",
      "显示/usr/bin/env/\"python\"没有那个文件或目录",
      "但是python 3.8已经安装",
      "可以将已有的python3复制为python",
      "在该文件夹下",
      "sudoln-s/usr/bin/python3/usr/bin/python",
      "如果代码下载到root文件夹下",
      "可以用sudo nautilus打开",
      "源码大概10G，需要预留足够的空间",
      "方便的全套教程：https://blog.csdn.net/wen381951203/article/details/109601800"
    ],
    "codes": [],
    "date": "2021-07-14",
    "text": "linux下注册和获取公钥的方法：\nssh-keygen -t rsa -C \"xxxx@xx.com\"\ncat ~/.ssh/id_rsa.pub\n下载码云repo时候显示权限不够，可以申请root权限，sudo -i之后再执行。\nrepo sync-c之后执行到最后远端意外断了，需要安装git-lfs\n显示/usr/bin/env/\"python\"没有那个文件或目录，但是python 3.8已经安装，可以将已有的python3复制为python。在该文件夹下。sudoln-s/usr/bin/python3/usr/bin/python\n如果代码下载到root文件夹下，可以用sudo nautilus打开\n源码大概10G，需要预留足够的空间。\n方便的全套教程：\nhttps://blog.csdn.net/wen381951203/article/details/109601800\n"
  },
  {
    "head": "软件构造（一）java根据类属性生成hash值的方法",
    "paragraphs": [
      "在写实验利用HashSet.contains进行判断当前对象在集合中是否存在的时候，需要判断该对象的hash值是否存在。这个时候需要override对象的hashCode方法。",
      "假设对象所在的类大致如下：",
      "我们需要根据这些属性的值生成hash值。只有当这些属性的值相等的时候散列值相等，可以采用object.hash方法。"
    ],
    "sentences": [
      "在写实验利用HashSet.contains进行判断当前对象在集合中是否存在的时候",
      "需要判断该对象的hash值是否存在",
      "这个时候需要override对象的hashCode方法",
      "假设对象所在的类大致如下：我们需要根据这些属性的值生成hash值",
      "只有当这些属性的值相等的时候散列值相等",
      "可以采用object.hash方法"
    ],
    "codes": [
      "public class Course {\n\tprivate long ID;\n\tprivate String name;\n\tprivate String teacherName;\n\tprivate String location;\n\tprivate long Class_hours;\n}",
      "public class Course {\n\tprivate long ID;\n\tprivate String name;\n\tprivate String teacherName;\n\tprivate String location;\n\tprivate long Class_hours;\n\n\n    @Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash(ID, name, teacherName, location Class_hours);\n\t}\n}"
    ],
    "date": "2021-07-05",
    "text": "在写实验利用HashSet.contains进行判断当前对象在集合中是否存在的时候，需要判断该对象的hash值是否存在。这个时候需要override对象的hashCode方法。\n假设对象所在的类大致如下：\n我们需要根据这些属性的值生成hash值。只有当这些属性的值相等的时候散列值相等，可以采用object.hash方法。\n"
  },
  {
    "head": "软件构造（三）JAVA中 ArrayList对自定义类的自然排序",
    "paragraphs": [
      "在做软件构造lab3实验的时候，为了想让时间段，按照起始时间的大小从低到高排序，尝试了比较器。",
      "但是发现sort处出现了这样的错误信息。",
      "后阅读Comparator.naturalOrder()的spec，发现要求自定义类必须实现Comparable的接口才能使用Comparator.naturalOrder()来进行自然排序，同理Comparator.reverseOrder()也是一样。",
      "于是对代码修改以实现Comparable",
      "同理在sort中传入参数Comparator.reverseOrder()也可以实现逆向排序。",
      "实际上ArrayList.sort传入的那个参数是一个比较器，并利用compare函数进行sort。所以我们也可以通过自己写compare函数来实现想要的比较方法，例如想进行逆向排序,就直接向sort传一个参数，要求他实现Comparator接口，并Ovrride compare方法使得反向排序即可"
    ],
    "sentences": [
      "在做软件构造lab3实验的时候",
      "为了想让时间段",
      "按照起始时间的大小从低到高排序",
      "尝试了比较器",
      "但是发现sort处出现了这样的错误信息",
      "后阅读Comparator.naturalOrder()的spec",
      "发现要求自定义类必须实现Comparable的接口才能使用Comparator.naturalOrder()来进行自然排序",
      "同理Comparator.reverseOrder()也是一样",
      "于是对代码修改以实现Comparable",
      "同理在sort中传入参数Comparator.reverseOrder()也可以实现逆向排序",
      "实际上ArrayList.sort传入的那个参数是一个比较器",
      "并利用compare函数进行sort",
      "所以我们也可以通过自己写compare函数来实现想要的比较方法",
      "例如想进行逆向排序,就直接向sort传一个参数",
      "要求他实现Comparator接口",
      "并Ovrride compare方法使得反向排序即可"
    ],
    "codes": [
      "public class timeBlock implements Comparator{\n\tprivate long begin;\n\tprivate long end;\n\n\tpublic timeBlock(long begin, long end){\n\t\t\n\t\tthis.begin=begin;\n\t\tthis.end=end;\n\t}\n\t\n\tpublic long getBegin() {\n\t\treturn this.begin;\n\t}\n\tpublic long getEnd() {\n\t\treturn this.end;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(\"+this.begin+\"->\"+this.end+\")\";\n\t}\n\n\t@Override\n\tpublic int compare(Object o1, Object o2) {\n\t\tif(((timeBlock)o1).getBegin()>((timeBlock)o2).getBegin())\n\t\t\treturn 1;\n\t\telse if (((timeBlock)o1).getBegin()<((timeBlock)o2).getBegin())\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}\n\n\npublic class Main2 {\n\t\n\tSet<String> set=new HashSet<>();\n\n\tpublic static void main(String[] args) {\n\t\tList<timeBlock> set=new ArrayList<>();\n\t\ttimeBlock a=new timeBlock(4,10);\n\t\ttimeBlock b=new timeBlock(2,15);\n\t\ttimeBlock c=new timeBlock(15,19);\n\t\tset.add(a);\n\t\tset.add(b);\n\t\tset.add(c);\n\t\tset.sort(Comparator.naturalOrder());\n\t\tSystem.out.println(set);\n\t}\n}",
      "public class timeBlock2 implements Comparable<Object>{\n\tprivate long begin;\n\tprivate long end;\n\t//20210622151943\n\t/**\n\t * for build a timeBlock\n\t * @param begin positive\n\t * @param end\tshould be larger than begin\n\t */\n\tpublic timeBlock2(long begin, long end){\n\t\t\n\t\tthis.begin=begin;\n\t\tthis.end=end;\n\t}\n\t\n\tpublic long getBegin() {\n\t\treturn this.begin;\n\t}\n\tpublic long getEnd() {\n\t\treturn this.end;\n\t}\n\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(\"+this.begin+\"->\"+this.end+\")\";\n\t}\n\n\n\n\t@Override\n\tpublic int compareTo(Object o) {\n\t\tif(this.begin<((timeBlock2)o).getBegin())\n\t\t\treturn -1;\n\t\telse if(this.begin>((timeBlock2)o).getBegin())\n\t\t\treturn 1;\n\t\telse if(this.end<((timeBlock2)o).getEnd())\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n}\n\npublic class Main2 {\n\t\n\tSet<String> set=new HashSet<>();\n\n\tpublic static void main(String[] args) {\n\t\tList<timeBlock2> set=new ArrayList<>();\n\t\ttimeBlock2 a=new timeBlock2(4,10);\n\t\ttimeBlock2 b=new timeBlock2(2,15);\n\t\ttimeBlock2 c=new timeBlock2(15,19);\n\t\tset.add(a);\n\t\tset.add(b);\n\t\tset.add(c);\n\t\tset.sort(Comparator.naturalOrder());\n\t\tSystem.out.println(set);\n\t}\n}",
      "public class timeBlock implements Comparator{\n\tprivate long begin;\n\tprivate long end;\n\n\tpublic timeBlock(long begin, long end){\n\t\t\n\t\tthis.begin=begin;\n\t\tthis.end=end;\n\t}\n\t\n\tpublic long getBegin() {\n\t\treturn this.begin;\n\t}\n\tpublic long getEnd() {\n\t\treturn this.end;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(\"+this.begin+\"->\"+this.end+\")\";\n\t}\n\n\t@Override\n\tpublic int compare(Object o1, Object o2) {\n\t\tif(((timeBlock)o1).getBegin()>((timeBlock)o2).getBegin())\n\t\t\treturn -1;\n\t\telse if (((timeBlock)o1).getBegin()<((timeBlock)o2).getBegin())\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}\n\npublic class Main2 {\n\t\n\tSet<String> set=new HashSet<>();\n\n\tpublic static void main(String[] args) {\n\t\tList<timeBlock> set=new ArrayList<>();\n\t\ttimeBlock a=new timeBlock(4,10);\n\t\ttimeBlock b=new timeBlock(2,15);\n\t\ttimeBlock c=new timeBlock(15,19);\n\t\tset.add(a);\n\t\tset.add(b);\n\t\tset.add(c);\n\t\tset.sort(new timeBlock(0,1));\n\t\tSystem.out.println(set);\n\t}\n}"
    ],
    "date": "2021-07-06",
    "text": "在做软件构造lab3实验的时候，为了想让时间段，按照起始时间的大小从低到高排序，尝试了比较器。\n但是发现sort处出现了这样的错误信息。\n后阅读Comparator.naturalOrder()的spec，发现要求自定义类必须实现Comparable的接口才能使用Comparator.naturalOrder()来进行自然排序，同理Comparator.reverseOrder()也是一样。\n于是对代码修改以实现Comparable\n同理在sort中传入参数Comparator.reverseOrder()也可以实现逆向排序。\n实际上ArrayList.sort传入的那个参数是一个比较器，并利用compare函数进行sort。所以我们也可以通过自己写compare函数来实现想要的比较方法，例如想进行逆向排序,就直接向sort传一个参数，要求他实现Comparator接口，并Ovrride compare方法使得反向排序即可\n"
  },
  {
    "head": "软件构造（五）java中private public protected static final关键字的作用",
    "paragraphs": [
      "private",
      "private关键字，只有在本类之中可以被直接修改。",
      "protected",
      "如果一个类中变量或方法有修饰字protected，同一类、同一包可以使用。不同包的类要使用，必须是该类的子类才能存取变量或调用。",
      "public",
      "任何类和对象都可以引用。",
      "注：如果前面不加public，private和final，那么只能被同包内的类和对象引用。",
      "static",
      "static修饰的类成员变量和类成员方法，只能被类调用，将作为类变量，可以不依靠创建对象来调用。比如静态工厂方法可以用来生成对象。但是该类的某一特定对象，也可以通过this.访问类的静态变量和静态方法。",
      "static无法方法内的局部变量。",
      "final",
      "final修饰的变量：不能修改引用。",
      "例如：对于immutable的类型，如int，String。不允许修改变量的值。",
      "对于mutable的类型，如ArrayList，可以继续向其中添加或者修改元素，但是不能将新的ArrayList赋值给变量，否则会在编译阶段报错。",
      "当用final作用于类的成员变量时，成员变量必须在定义时或者构造器中进行初始化赋值。",
      "final修饰的方法：不能被Override",
      "final修饰的类：不能被继承。final类中的成员方法将被视作final类型。",
      "参考和引用：",
      "https://blog.csdn.net/findaway123/article/details/7604676",
      "https://blog.csdn.net/u012723673/article/details/80580011"
    ],
    "sentences": [
      "private",
      "private关键字，只有在本类之中可以被直接修改",
      "protected",
      "如果一个类中变量或方法有修饰字protected",
      "同一类、同一包可以使用",
      "不同包的类要使用，必须是该类的子类才能存取变量或调用",
      "public",
      "任何类和对象都可以引用",
      "注：如果前面不加public",
      "private和final",
      "那么只能被同包内的类和对象引用",
      "static",
      "static修饰的类成员变量和类成员方法",
      "只能被类调用",
      "将作为类变量",
      "可以不依靠创建对象来调用",
      "比如静态工厂方法可以用来生成对象",
      "但是该类的某一特定对象",
      "也可以通过this.访问类的静态变量和静态方法",
      "static无法方法内的局部变量",
      "final",
      "final修饰的变量：不能修改引用",
      "例如：对于immutable的类型，如int，String",
      "不允许修改变量的值",
      "对于mutable的类型",
      "如ArrayList",
      "可以继续向其中添加或者修改元素",
      "但是不能将新的ArrayList赋值给变量",
      "否则会在编译阶段报错",
      "当用final作用于类的成员变量时",
      "成员变量必须在定义时或者构造器中进行初始化赋值",
      "final修饰的方法：不能被Override",
      "final修饰的类：不能被继承",
      "final类中的成员方法将被视作final类型",
      "参考和引用：https://blog.csdn.net/findaway123/article/details/7604676",
      "https://blog.csdn.net/u012723673/article/details/80580011"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "private\nprivate关键字，只有在本类之中可以被直接修改。\nprotected\n如果一个类中变量或方法有修饰字protected，同一类、同一包可以使用。不同包的类要使用，必须是该类的子类才能存取变量或调用。\npublic\n任何类和对象都可以引用。\n注：如果前面不加public，private和final，那么只能被同包内的类和对象引用。\nstatic\nstatic修饰的类成员变量和类成员方法，只能被类调用，将作为类变量，可以不依靠创建对象来调用。比如静态工厂方法可以用来生成对象。但是该类的某一特定对象，也可以通过this.访问类的静态变量和静态方法。\nstatic无法方法内的局部变量。\nfinal\nfinal修饰的变量：不能修改引用。\n例如：对于immutable的类型，如int，String。不允许修改变量的值。\n对于mutable的类型，如ArrayList，可以继续向其中添加或者修改元素，但是不能将新的ArrayList赋值给变量，否则会在编译阶段报错。\n当用final作用于类的成员变量时，成员变量必须在定义时或者构造器中进行初始化赋值。\nfinal修饰的方法：不能被Override\nfinal修饰的类：不能被继承。final类中的成员方法将被视作final类型。\n参考和引用：\nhttps://blog.csdn.net/findaway123/article/details/7604676\nhttps://blog.csdn.net/u012723673/article/details/80580011\n"
  },
  {
    "head": "软件构造复习笔记（一）",
    "paragraphs": [
      "软件构造复习：",
      "软件构造的多维度视图和质量目标",
      "1.按阶段划分：构造时/运行时视图 （phases：build-/run-time views）",
      "按动态性划分：时刻/阶段视图（moment/period views）",
      "按构造对象的层次划分 ：代码/构件视图（levels: code/component views）",
      "2.软件构造：在不同视图间转换",
      "3.五个关键的质量目标：",
      "(1)容易理解：understandability 可理解性.",
      "(2)准备好改变：maintainability and adaptability 可维护性和适应性",
      "(3)发展的成本低：design with/for reuse reusability 可复用性",
      "(4)健壮性",
      "(5)表现？Performance",
      "一．多维度软件视图",
      "1.Software = Program +Data +Documents",
      "软件 = 程序 +数据 +文档",
      "2.Software = Modules(Components ) + Data/Control Flows",
      "软件 = 模块（构件） + 数据流/控制流",
      "时刻 时间段",
      "代码 构件 代码 构件",
      "构造时 源代码 静态链接 code churn 配置项",
      "抽象语法树 包、库、 版本",
      "接口-类-属性 文件、测试用例",
      "–方法 、构造脚本",
      "（类图） （构件图）",
      "代码 构件 代码 构件",
      "运行时 代码快照 动态链接 并行多线程 事件日志",
      "内存转储 包、库、 执行时栈轨迹 多进程、",
      "配置、中间件、 分布式进程",
      "网络、数据库",
      "1）构造时视图",
      "1.代码层面：",
      "代码的逻辑组织： 接口、类、方法、函数",
      "构件层面：",
      "代码的物理组织：库、包、目录、文件",
      "时刻：特定时刻软件形态",
      "时间段：软件形态随时间变化",
      "2.Build-time/moment/code:",
      "三种相互关联的形式：",
      "词汇层面:半结构化的",
      "语法层面:（AST）彻底结构化，将源代码变为一棵树",
      "语义层面:表达需求和设计思想",
      "Build-time/period/code:",
      "Code churn 代码变化",
      "Build-time/moment/component:",
      "源代码-文件-（目录）-包-构件-子系统-库",
      "3.库：操作系统提供的/编程语言提供的/第三方提供的/自己积累的",
      "4.静态链接：在静态链接里、库是单个对象文件的集合。",
      "Build进程时，如果一个函数被需要，链接工具会把它从库里抽取出来，复制到可执行文件中，执行的时候就是代码的一部分了，不再需要库文件。",
      "静态链接发生在构造阶段（build time）",
      "可执行文件被加载到机器上时静态链接就结束了，；最终的可执行文件被创建之后，就不能再从库中分离程序。",
      "（UML是统一软件建模语言；VCS版本控制系统；SCI软件配置项）",
      "2）运行时视图",
      "1.运行时：程序被载入目标文件，开始执行",
      "代码层面：逻辑实体在内存中如何呈现",
      "构件层面：物理实体在物理硬件环境中如何呈现",
      "2.一个库不能直接在机器上加载执行，必须先连接到可执行文件",
      "3.Native Machine Code(原生机器码）：CPU可以直接理解，最快的执行代码的方法",
      "4.Full Program Interpretation （程序完全解释执行）",
      "5.Interpreted Byte Codes （解释型字节码）：",
      "（JVM ：java 虚拟机）",
      "6.动态链接：",
      "库文件在build阶段不被加入可执行文件，只做出标记；运行时，根据标记装载库值内存；发布软件时，需要把所有动态库也复制给用户",
      "优点：更新库的版本不需要重新创建可执行文件；许多操作系统值上传一份副本到内存，然后分享",
      "7.分布式程序的运行态：需要多个运行程序，分别不属于多个计算机物理环境",
      "8.Run-time/moment/code:",
      "代码快照：程序运行时内存里变量层面的状态",
      "内存信息转储：进程因为某些原因终止时，在内存里存一个它的内容的副本",
      "Run-time/period/code:",
      "执行跟踪：用日志方式记录程序执行的调用次序",
      "Run-time/Period/component:",
      "日志（系统层面）"
    ],
    "sentences": [
      "软件构造复习：软件构造的多维度视图和质量目标",
      "1.按阶段划分：构造时/运行时视图 （phases：build-/run-time views）",
      "按动态性划分：时刻/阶段视图（moment/period views）",
      "按构造对象的层次划分 ：代码/构件视图（levels: code/component views）",
      "2.软件构造：在不同视图间转换",
      "3.五个关键的质量目标：(1)容易理解：understandability 可理解性.(2)准备好改变：maintainability and adaptability 可维护性和适应性",
      "(3)发展的成本低：design with/for reuse reusability 可复用性",
      "(4)健壮性",
      "(5)表现？Performance",
      "一．多维度软件视图",
      "1.Software = Program +Data +Documents",
      "软件 = 程序 +数据 +文档",
      "2.Software = Modules(Components ) + Data/Control Flows",
      "软件 = 模块（构件） + 数据流/控制流",
      "时刻 时间段",
      "代码 构件 代码 构件",
      "构造时 源代码 静态链接 code churn 配置项",
      "抽象语法树 包、库、 版本",
      "接口-类-属性 文件、测试用例",
      "–方法 、构造脚本",
      "（类图） （构件图）",
      "代码 构件 代码 构件",
      "运行时 代码快照 动态链接 并行多线程 事件日志",
      "内存转储 包、库、 执行时栈轨迹 多进程、配置、中间件、 分布式进程",
      "网络、数据库",
      "1）构造时视图",
      "1.代码层面：代码的逻辑组织： 接口、类、方法、函数",
      "构件层面：代码的物理组织：库、包、目录、文件",
      "时刻：特定时刻软件形态",
      "时间段：软件形态随时间变化",
      "2.Build-time/moment/code:三种相互关联的形式：词汇层面:半结构化的",
      "语法层面:（AST）彻底结构化，将源代码变为一棵树",
      "语义层面:表达需求和设计思想",
      "Build-time/period/code:Code churn 代码变化",
      "Build-time/moment/component:源代码-文件-（目录）-包-构件-子系统-库",
      "3.库：操作系统提供的/编程语言提供的/第三方提供的/自己积累的",
      "4.静态链接：在静态链接里、库是单个对象文件的集合",
      "Build进程时",
      "如果一个函数被需要",
      "链接工具会把它从库里抽取出来",
      "复制到可执行文件中",
      "执行的时候就是代码的一部分了",
      "不再需要库文件",
      "静态链接发生在构造阶段（build time）",
      "可执行文件被加载到机器上时静态链接就结束了",
      "；最终的可执行文件被创建之后",
      "就不能再从库中分离程序",
      "（UML是统一软件建模语言；VCS版本控制系统；SCI软件配置项）",
      "2）运行时视图",
      "1.运行时：程序被载入目标文件，开始执行",
      "代码层面：逻辑实体在内存中如何呈现",
      "构件层面：物理实体在物理硬件环境中如何呈现",
      "2.一个库不能直接在机器上加载执行，必须先连接到可执行文件",
      "3.Native Machine Code(原生机器码）：CPU可以直接理解",
      "最快的执行代码的方法",
      "4.Full Program Interpretation （程序完全解释执行）",
      "5.Interpreted Byte Codes （解释型字节码）：（JVM ：java 虚拟机）",
      "6.动态链接：库文件在build阶段不被加入可执行文件",
      "只做出标记；运行时",
      "根据标记装载库值内存；发布软件时",
      "需要把所有动态库也复制给用户",
      "优点：更新库的版本不需要重新创建可执行文件；许多操作系统值上传一份副本到内存",
      "然后分享",
      "7.分布式程序的运行态：需要多个运行程序",
      "分别不属于多个计算机物理环境",
      "8.Run-time/moment/code:代码快照：程序运行时内存里变量层面的状态",
      "内存信息转储：进程因为某些原因终止时",
      "在内存里存一个它的内容的副本",
      "Run-time/period/code:执行跟踪：用日志方式记录程序执行的调用次序",
      "Run-time/Period/component:日志（系统层面）"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "软件构造复习：\n软件构造的多维度视图和质量目标\n1.按阶段划分：构造时/运行时视图 （phases：build-/run-time views）\n按动态性划分：时刻/阶段视图（moment/period views）\n按构造对象的层次划分 ：代码/构件视图（levels: code/component views）\n2.软件构造：在不同视图间转换\n3.五个关键的质量目标：\n(1)容易理解：understandability 可理解性.\n(2)准备好改变：maintainability and adaptability 可维护性和适应性\n(3)发展的成本低：design with/for reuse reusability 可复用性\n(4)健壮性\n(5)表现？Performance\n一．多维度软件视图\n1.Software = Program +Data +Documents\n软件 = 程序 +数据 +文档\n2.Software = Modules(Components ) + Data/Control Flows\n软件 = 模块（构件） + 数据流/控制流\n时刻 时间段\n代码 构件 代码 构件\n构造时 源代码 静态链接 code churn 配置项\n抽象语法树 包、库、 版本\n接口-类-属性 文件、测试用例\n–方法 、构造脚本\n（类图） （构件图）\n代码 构件 代码 构件\n运行时 代码快照 动态链接 并行多线程 事件日志\n内存转储 包、库、 执行时栈轨迹 多进程、\n配置、中间件、 分布式进程\n网络、数据库\n1）构造时视图\n1.代码层面：\n代码的逻辑组织： 接口、类、方法、函数\n构件层面：\n代码的物理组织：库、包、目录、文件\n时刻：特定时刻软件形态\n时间段：软件形态随时间变化\n2.Build-time/moment/code:\n三种相互关联的形式：\n词汇层面:半结构化的\n语法层面:（AST）彻底结构化，将源代码变为一棵树\n语义层面:表达需求和设计思想\nBuild-time/period/code:\nCode churn 代码变化\nBuild-time/moment/component:\n源代码-文件-（目录）-包-构件-子系统-库\n3.库：操作系统提供的/编程语言提供的/第三方提供的/自己积累的\n4.静态链接：在静态链接里、库是单个对象文件的集合。\nBuild进程时，如果一个函数被需要，链接工具会把它从库里抽取出来，复制到可执行文件中，执行的时候就是代码的一部分了，不再需要库文件。\n静态链接发生在构造阶段（build time）\n可执行文件被加载到机器上时静态链接就结束了，；最终的可执行文件被创建之后，就不能再从库中分离程序。\n（UML是统一软件建模语言；VCS版本控制系统；SCI软件配置项）\n2）运行时视图\n1.运行时：程序被载入目标文件，开始执行\n代码层面：逻辑实体在内存中如何呈现\n构件层面：物理实体在物理硬件环境中如何呈现\n2.一个库不能直接在机器上加载执行，必须先连接到可执行文件\n3.Native Machine Code(原生机器码）：CPU可以直接理解，最快的执行代码的方法\n4.Full Program Interpretation （程序完全解释执行）\n5.Interpreted Byte Codes （解释型字节码）：\n（JVM ：java 虚拟机）\n6.动态链接：\n库文件在build阶段不被加入可执行文件，只做出标记；运行时，根据标记装载库值内存；发布软件时，需要把所有动态库也复制给用户\n优点：更新库的版本不需要重新创建可执行文件；许多操作系统值上传一份副本到内存，然后分享\n7.分布式程序的运行态：需要多个运行程序，分别不属于多个计算机物理环境\n8.Run-time/moment/code:\n代码快照：程序运行时内存里变量层面的状态\n内存信息转储：进程因为某些原因终止时，在内存里存一个它的内容的副本\nRun-time/period/code:\n执行跟踪：用日志方式记录程序执行的调用次序\nRun-time/Period/component:\n日志（系统层面）\n"
  },
  {
    "head": "java泛型理解",
    "paragraphs": [
      "java泛型理解",
      "泛型在java中经常使用，有很重要的作用，在做软件构造的实验，我对泛型的理解不是很深，但随着了解和运用越来越多，理解也就加深了，这里记录一下学习的理解",
      "什么是泛型？",
      "泛型，即“参数化类型”，是对java语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样，泛型的本质是为了参数化类型，在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型，在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。",
      "对于常见的泛型模式，推荐的泛型类型变量有：",
      "E：元素（element），多用于java集合框架",
      "K：关键字（Key）",
      "N：数字（Number）",
      "T：类型（Type）",
      "V：值（value）",
      "T和T的区别：T是tpye的首字母缩写；T表示“返回值”是一个泛型，传入什么类型，就返回什么类型，而单独的“T\"表示限制传入的参数类型",
      "举个例子说明泛型的作用",
      "运行程序，崩溃",
      "原因是ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。",
      "我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。",
      "泛型的特性",
      "泛型只在编译阶段有效",
      "。看下面的代码：",
      "输出结果：D/泛型测试: 类型相同。",
      "通过上面的例子可以证明，在编译之后程序",
      "会采取去泛型化",
      "的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。",
      "对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。",
      "泛型如何使用",
      "泛型有三种使用方式，分别为：泛型类，泛型接口，泛型方法",
      "1.泛型类",
      "泛型类型用于类的定义中，最典型的是各种容器类，如：List，Set，Map",
      "泛型的基本写法：",
      "举个例子：",
      "那如何使用呢",
      "结果：",
      "2.泛型接口",
      "泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：",
      "当实现泛型接口的类，未传入泛型实参时：",
      "当实现泛型接口的类，传入泛型实参时：",
      "3.泛型方法",
      "泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。",
      "假设需要实现这样一个方法：该方法负责将一个 Object 数组的所有元素添加到一个 Collection 集合中。考虑采用如下代码来实现该方法：",
      "上面定义的方法没有任何问题，关键在于方法中的c 参数，它的数据类型是 Collection。正如前面介绍的，Collection 不是 Collection 的子类型—所以这个方法的功能很有限，它只能将 Object[] 数组的元素复制到元素为 Object （Object 的子类不行）的Collection 集合中，即下面代码会引起问题。",
      "可见上面方法的参数类型不可以使用 Collection，",
      "使用通配符 Collection<?> 也不行，因为Java 不允许把对象放进一个未知类型的集合里。",
      "为解决这个问题，可以使用泛型方法，在声明方法时定义一个或多个类型形参。泛型用法格式如下：",
      "该泛型方法的方法签名比普通方法的方法签名多了类型形参声明，类型形参声明以尖括号括起来，多个类型形参直接以逗号（，）隔开，所有的类型形参声明放在方法修饰符和返回值类型之间。",
      "采用支持泛型的方法，就可以将上面的 fromArrayToCollection 方法改写为如下形式",
      "可以看到Object被替换成了T，而且在修饰符和返回值中间加了",
      "下面代码示范了完整用法",
      "上面程序调用了一个泛型方法，该泛型方法中定义了一个 T 类型形参，这个 T 类型形参就可以在该方法内当成普通类型使用。与接口、类声明中定义的类型参数不同的是，方法声明中定义的形参只能在该方法内使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。",
      "与类，接口中泛型参数不同的是，方法中的泛型参数无须显式传入实际类型参数，如上面程序所示，当程序调用 fromArrayToCollection() 方法时，无须在调用该方法前传入String、Object 等类型，但系统依然可以知道类型参数的数据类型，因为编译器根据实参推断类型实参的值，它通常推断出最直接的类型参数。"
    ],
    "sentences": [
      "java泛型理解",
      "泛型在java中经常使用",
      "有很重要的作用",
      "在做软件构造的实验",
      "我对泛型的理解不是很深",
      "但随着了解和运用越来越多",
      "理解也就加深了",
      "这里记录一下学习的理解",
      "什么是泛型？",
      "泛型",
      "即“参数化类型”",
      "是对java语言的类型系统的一种扩展",
      "以支持创建可以按类型进行参数化的类",
      "可以把类型参数看作是使用参数化类型时指定的类型的一个占位符",
      "就像方法的形式参数是运行时传递的值的占位符一样",
      "泛型的本质是为了参数化类型",
      "在不创建新的类型的情况下",
      "通过泛型指定的不同类型来控制形参具体限制的类型",
      "在泛型使用过程中",
      "操作的数据类型被指定为一个参数",
      "这种参数类型可以用在类、接口和方法中",
      "分别被称为泛型类、泛型接口、泛型方法",
      "对于常见的泛型模式",
      "推荐的泛型类型变量有：E：元素（element）",
      "多用于java集合框架",
      "K：关键字（Key）",
      "N：数字（Number）",
      "T：类型（Type）",
      "V：值（value）",
      "T和T的区别：T是tpye的首字母缩写；T表示“返回值”是一个泛型",
      "传入什么类型",
      "就返回什么类型",
      "而单独的“T\"表示限制传入的参数类型",
      "举个例子说明泛型的作用",
      "运行程序，崩溃",
      "原因是ArrayList可以存放任意类型",
      "例子中添加了一个String类型",
      "添加了一个Integer类型",
      "再使用时都以String的方式使用",
      "因此程序崩溃了",
      "为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生",
      "我们将第一行声明初始化list的代码更改一下",
      "编译器会在编译阶段就能够帮我们发现类似这样的问题",
      "泛型的特性",
      "泛型只在编译阶段有效",
      "看下面的代码：输出结果：D/泛型测试: 类型相同",
      "通过上面的例子可以证明，在编译之后程序",
      "会采取去泛型化",
      "的措施",
      "也就是说Java中的泛型，只在编译阶段有效",
      "在编译过程中",
      "正确检验泛型结果后",
      "会将泛型的相关信息擦出",
      "并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法",
      "也就是说，泛型信息不会进入到运行时阶段",
      "对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型",
      "实际上都是相同的基本类型",
      "泛型如何使用",
      "泛型有三种使用方式，分别为：泛型类，泛型接口，泛型方法",
      "1.泛型类",
      "泛型类型用于类的定义中",
      "最典型的是各种容器类",
      "如：List",
      "Set",
      "Map",
      "泛型的基本写法：举个例子：那如何使用呢",
      "结果：2.泛型接口",
      "泛型接口与泛型类的定义及使用基本相同",
      "泛型接口常被用在各种类的生产器中",
      "可以看一个例子：当实现泛型接口的类",
      "未传入泛型实参时：当实现泛型接口的类",
      "传入泛型实参时：3.泛型方法",
      "泛型类",
      "是在实例化类的时候指明泛型的具体类型；泛型方法",
      "是在调用方法的时候指明泛型的具体类型 ",
      "假设需要实现这样一个方法：该方法负责将一个 Object 数组的所有元素添加到一个 Collection 集合中",
      "考虑采用如下代码来实现该方法：上面定义的方法没有任何问题",
      "关键在于方法中的c 参数",
      "它的数据类型是 Collection",
      "正如前面介绍的",
      "Collection 不是 Collection 的子类型—所以这个方法的功能很有限",
      "它只能将 Object[] 数组的元素复制到元素为 Object （Object 的子类不行）的Collection 集合中",
      "即下面代码会引起问题",
      "可见上面方法的参数类型不可以使用 Collection",
      "使用通配符 Collection<?> 也不行",
      "因为Java 不允许把对象放进一个未知类型的集合里",
      "为解决这个问题",
      "可以使用泛型方法",
      "在声明方法时定义一个或多个类型形参",
      "泛型用法格式如下：该泛型方法的方法签名比普通方法的方法签名多了类型形参声明",
      "类型形参声明以尖括号括起来",
      "多个类型形参直接以逗号（",
      "）隔开",
      "所有的类型形参声明放在方法修饰符和返回值类型之间",
      "采用支持泛型的方法",
      "就可以将上面的 fromArrayToCollection 方法改写为如下形式",
      "可以看到Object被替换成了T",
      "而且在修饰符和返回值中间加了",
      "下面代码示范了完整用法",
      "上面程序调用了一个泛型方法",
      "该泛型方法中定义了一个 T 类型形参",
      "这个 T 类型形参就可以在该方法内当成普通类型使用",
      "与接口、类声明中定义的类型参数不同的是",
      "方法声明中定义的形参只能在该方法内使用",
      "而接口、类声明中定义的类型形参则可以在整个接口、类中使用",
      "与类",
      "接口中泛型参数不同的是",
      "方法中的泛型参数无须显式传入实际类型参数",
      "如上面程序所示",
      "当程序调用 fromArrayToCollection() 方法时",
      "无须在调用该方法前传入String、Object 等类型",
      "但系统依然可以知道类型参数的数据类型",
      "因为编译器根据实参推断类型实参的值",
      "它通常推断出最直接的类型参数"
    ],
    "codes": [
      "List arrayList = new ArrayList();\narrayList.add(\"aaaa\");\narrayList.add(100);\n\nfor(int i = 0; i< arrayList.size();i++){\n    String item = (String)arrayList.get(i);\n    Log.d(\"泛型测试\",\"item = \" + item);\n}\n",
      "java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n",
      "List<String> arrayList = new ArrayList<String>();\n...\n//arrayList.add(100); 在编译阶段，编译器就会报错\n",
      "List<String> stringArrayList = new ArrayList<String>();\nList<Integer> integerArrayList = new ArrayList<Integer>();\n\nClass classStringArrayList = stringArrayList.getClass();\nClass classIntegerArrayList = integerArrayList.getClass();\n\nif(classStringArrayList.equals(classIntegerArrayList)){\n    Log.d(\"泛型测试\",\"类型相同\");\n}\n",
      "class 类名称 <泛型标识：可以随便写任意标识号，标识指定的泛型的类型>{\n  private 泛型标识 /*（成员变量类型）*/ var; \n  .....\n  }\n}\n",
      "/*T的类型由外部指定*/\npublic class Example<T>{\n    private key;\n    \n    public Example(T key){\n        this.key = key\n    }\n    \n    public T getkey(){\n        return key\n    }\n}\n",
      "//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型\n//传入的实参类型需与泛型的类型参数类型相同，即为Integer.\nExample<Integer> genericInteger = new Example<Integer>(123456);\n\n//传入的实参类型需与泛型的类型参数类型相同，即为String.\nExample<String> genericString = new Example<String>(\"key_vlaue\");\nLog.d(\"泛型测试\",\"key is \" + genericInteger.getKey());\nLog.d(\"泛型测试\",\"key is \" + genericString.getKey());\n",
      "泛型测试: key is 123456\n泛型测试: key is key_vlaue\n",
      "//定义一个接口\npublic interface Gen<T>{\n    public T next()\n}\n",
      "/**\n * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中\n * 即：class FruitGenerator<T> implements Gen<T>{\n * 如果不声明泛型，如：class FruitGenerator implements Generator<T>，编译器会报错：\"Unknown class\"\n */\nclass FruitGenerator<T> implements Gen<T>{\n    @Override\n    public T next() {\n        return null;\n    }\n}\n",
      "/**\n * 传入泛型实参时：\n * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator<T>\n * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。\n * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型\n * 即：Generator<T>，public T next();中的的T都要替换成传入的String类型。\n */\npublic class FruitGenerator implements Generator<String> {\n\n    private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"};\n\n    @Override\n    public String next() {\n        Random rand = new Random();\n        return fruits[rand.nextInt(3)];\n    }\n}\n",
      "static void fromArrayToCollection(Object[] a, Collection<Object> c){\n    for(Object o:a){\n        c.add(o);\n    }\n}\n",
      "String[] strArr = {\"a\", \"b\"};\nList<String> strList = new ArrayList<>();\n//Collection<String>会报错，Collection<String>不能当做/Collection<Object>使用\n",
      "修饰符 <T，S> 返回值类型 方法名(形参列表){\n\t//方法体\n}\n",
      "static <T> void fromArrayToCollection(T[] a, Collection<T> c){\n    for(Object o:a){\n        c.add(o);\n    }\n}\n",
      "static <T> void fromArrayToCollection(T[] a, Collection<T> c){\n    for(Object o:a){\n        c.add(o);\n    }\n}\n\npublic static void main(Sting[] args){\n    Object[] oa = new Object[100];\n    Collection<Object> co = new ArrayList<>();\n    fromArrayToCollection(oa, co)\n        \n    String[] sa = new String[100];\n    Collection<String> cs = new ArrayList<>();\n    fromArrayToCollection(sa, cs)\n    \n    Integer[] ia = new Integer[100];\n    Collection<Integer> co = new ArrayList<>();\n    fromArrayToCollection(ia, ci)\n    \n}\n"
    ],
    "date": "2021-07-06",
    "text": "java泛型理解\n泛型在java中经常使用，有很重要的作用，在做软件构造的实验，我对泛型的理解不是很深，但随着了解和运用越来越多，理解也就加深了，这里记录一下学习的理解\n什么是泛型？\n泛型，即“参数化类型”，是对java语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样，泛型的本质是为了参数化类型，在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型，在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n对于常见的泛型模式，推荐的泛型类型变量有：\nE：元素（element），多用于java集合框架\nK：关键字（Key）\nN：数字（Number）\nT：类型（Type）\nV：值（value）\nT和T的区别：T是tpye的首字母缩写；T表示“返回值”是一个泛型，传入什么类型，就返回什么类型，而单独的“T\"表示限制传入的参数类型\n举个例子说明泛型的作用\n运行程序，崩溃\n原因是ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。\n我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。\n泛型的特性\n泛型只在编译阶段有效\n。看下面的代码：\n输出结果：D/泛型测试: 类型相同。\n通过上面的例子可以证明，在编译之后程序\n会采取去泛型化\n的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。\n对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。\n泛型如何使用\n泛型有三种使用方式，分别为：泛型类，泛型接口，泛型方法\n1.泛型类\n泛型类型用于类的定义中，最典型的是各种容器类，如：List，Set，Map\n泛型的基本写法：\n举个例子：\n那如何使用呢\n结果：\n2.泛型接口\n泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：\n当实现泛型接口的类，未传入泛型实参时：\n当实现泛型接口的类，传入泛型实参时：\n3.泛型方法\n泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。\n假设需要实现这样一个方法：该方法负责将一个 Object 数组的所有元素添加到一个 Collection 集合中。考虑采用如下代码来实现该方法：\n上面定义的方法没有任何问题，关键在于方法中的c 参数，它的数据类型是 Collection。正如前面介绍的，Collection 不是 Collection 的子类型—所以这个方法的功能很有限，它只能将 Object[] 数组的元素复制到元素为 Object （Object 的子类不行）的Collection 集合中，即下面代码会引起问题。\n可见上面方法的参数类型不可以使用 Collection，\n使用通配符 Collection<?> 也不行，因为Java 不允许把对象放进一个未知类型的集合里。\n为解决这个问题，可以使用泛型方法，在声明方法时定义一个或多个类型形参。泛型用法格式如下：\n该泛型方法的方法签名比普通方法的方法签名多了类型形参声明，类型形参声明以尖括号括起来，多个类型形参直接以逗号（，）隔开，所有的类型形参声明放在方法修饰符和返回值类型之间。\n采用支持泛型的方法，就可以将上面的 fromArrayToCollection 方法改写为如下形式\n可以看到Object被替换成了T，而且在修饰符和返回值中间加了\n下面代码示范了完整用法\n上面程序调用了一个泛型方法，该泛型方法中定义了一个 T 类型形参，这个 T 类型形参就可以在该方法内当成普通类型使用。与接口、类声明中定义的类型参数不同的是，方法声明中定义的形参只能在该方法内使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。\n与类，接口中泛型参数不同的是，方法中的泛型参数无须显式传入实际类型参数，如上面程序所示，当程序调用 fromArrayToCollection() 方法时，无须在调用该方法前传入String、Object 等类型，但系统依然可以知道类型参数的数据类型，因为编译器根据实参推断类型实参的值，它通常推断出最直接的类型参数。\n"
  },
  {
    "head": "用git把本地文件推送到远程仓库",
    "paragraphs": [
      "要把实验的项目交到GitHub上，因为用git提交的问题之前一直有点迷糊，今天再整理一下",
      "一.先提交到本地仓库",
      "1.之前的git bash已经安装好了，检查一下名字和地址，",
      "可以看到已经完成了绑定",
      "2.创建一个空目录并将它设置为当前目录",
      "用pwd查看当前目录，看到当前目录已经设置成labs了",
      "本地已经创建了一个labs空目录",
      "（这里注意windows目录里不能有中文）",
      "3.把目录初始化为仓库",
      "4.把eclipse的项目文件一到这个目录下",
      "这里这个报错是说，要把我文件里的所有LF换行符换成CRLF换行符，这个主要是因为 不同操作系统的换行符不一样，如果是跨平台开发的话要执行 git config core.sutocrlf false ,因为我们就交到GitHub上，所以就简单忽略这个警告就行了。",
      "5.把文件提交到仓库",
      "二.再提交到远程仓库",
      "1.添加远程库，就是在GitHub上建立一个仓库，我这里就是统一要求的仓库",
      "这里wyq-cloud的地方应该是你的GitHub的用户名，labs的地方应该是你的仓库名",
      "你也可以用另一种办法：使用SSH key",
      "命令应该是：",
      "$ git remote add origin SSH key",
      "这个SSH key从GitHub上得到：",
      "进入你的仓库主页，在下载代码的地方",
      "有一个SSH 把它复制下来，粘贴到SSH key的地方就行了",
      "（如果你这个命令用错了，添加了一个不存在的远程仓库，后面推送本地库内容会报错：",
      "你可以删掉刚才那个库：",
      "然后重新添加远程库）",
      "2.把本地库的内容推送到远程库",
      "远程库里就有这些文件里，在master分支里",
      "参考：",
      "https://blog.csdn.net/weixin_42152081/article/details/80558282?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162526935516780261942725%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162526935516780261942725&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2",
      "all",
      "top_positive~default-1-80558282.first_rank_v2_pc_rank_v29&utm_term=git&spm=1018.2226.3001.4187"
    ],
    "sentences": [
      "要把实验的项目交到GitHub上",
      "因为用git提交的问题之前一直有点迷糊",
      "今天再整理一下",
      "一.先提交到本地仓库",
      "1.之前的git bash已经安装好了",
      "检查一下名字和地址",
      "可以看到已经完成了绑定",
      "2.创建一个空目录并将它设置为当前目录",
      "用pwd查看当前目录，看到当前目录已经设置成labs了",
      "本地已经创建了一个labs空目录",
      "（这里注意windows目录里不能有中文）",
      "3.把目录初始化为仓库",
      "4.把eclipse的项目文件一到这个目录下",
      "这里这个报错是说",
      "要把我文件里的所有LF换行符换成CRLF换行符",
      "这个主要是因为 不同操作系统的换行符不一样",
      "如果是跨平台开发的话要执行 git config core.sutocrlf false ,因为我们就交到GitHub上",
      "所以就简单忽略这个警告就行了",
      "5.把文件提交到仓库",
      "二.再提交到远程仓库",
      "1.添加远程库",
      "就是在GitHub上建立一个仓库",
      "我这里就是统一要求的仓库",
      "这里wyq-cloud的地方应该是你的GitHub的用户名",
      "labs的地方应该是你的仓库名",
      "你也可以用另一种办法：使用SSH key",
      "命令应该是：$ git remote add origin SSH key",
      "这个SSH key从GitHub上得到：进入你的仓库主页",
      "在下载代码的地方",
      "有一个SSH 把它复制下来，粘贴到SSH key的地方就行了",
      "（如果你这个命令用错了",
      "添加了一个不存在的远程仓库",
      "后面推送本地库内容会报错：你可以删掉刚才那个库：然后重新添加远程库）",
      "2.把本地库的内容推送到远程库",
      "远程库里就有这些文件里，在master分支里",
      "参考：https://blog.csdn.net/weixin_42152081/article/details/80558282?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162526935516780261942725%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162526935516780261942725&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2",
      "all",
      "top_positive~default-1-80558282.first_rank_v2_pc_rank_v29&utm_term=git&spm=1018.2226.3001.4187"
    ],
    "codes": [],
    "date": "2021-07-04",
    "text": "要把实验的项目交到GitHub上，因为用git提交的问题之前一直有点迷糊，今天再整理一下\n一.先提交到本地仓库\n1.之前的git bash已经安装好了，检查一下名字和地址，\n可以看到已经完成了绑定\n2.创建一个空目录并将它设置为当前目录\n用pwd查看当前目录，看到当前目录已经设置成labs了\n本地已经创建了一个labs空目录\n（这里注意windows目录里不能有中文）\n3.把目录初始化为仓库\n4.把eclipse的项目文件一到这个目录下\n这里这个报错是说，要把我文件里的所有LF换行符换成CRLF换行符，这个主要是因为 不同操作系统的换行符不一样，如果是跨平台开发的话要执行 git config core.sutocrlf false ,因为我们就交到GitHub上，所以就简单忽略这个警告就行了。\n5.把文件提交到仓库\n二.再提交到远程仓库\n1.添加远程库，就是在GitHub上建立一个仓库，我这里就是统一要求的仓库\n这里wyq-cloud的地方应该是你的GitHub的用户名，labs的地方应该是你的仓库名\n你也可以用另一种办法：使用SSH key\n命令应该是：\n$ git remote add origin SSH key\n这个SSH key从GitHub上得到：\n进入你的仓库主页，在下载代码的地方\n有一个SSH 把它复制下来，粘贴到SSH key的地方就行了\n（如果你这个命令用错了，添加了一个不存在的远程仓库，后面推送本地库内容会报错：\n你可以删掉刚才那个库：\n然后重新添加远程库）\n2.把本地库的内容推送到远程库\n远程库里就有这些文件里，在master分支里\n参考：\nhttps://blog.csdn.net/weixin_42152081/article/details/80558282?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162526935516780261942725%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162526935516780261942725&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2\nall\ntop_positive~default-1-80558282.first_rank_v2_pc_rank_v29&utm_term=git&spm=1018.2226.3001.4187\n"
  },
  {
    "head": "ADT and OOP 复习总结(一)",
    "paragraphs": [
      "ADT and OOP 复习总结（一）",
      "软件构造的理论基础——ADT(抽象数据类型)",
      "软件构造的技术基础——OOP(面向对象编程)",
      "章节目标",
      "1.Types in java",
      "基本数据类型",
      "对象引用数据类型",
      "根据Java约定，基础数据类型为小写，而对象类型以大写字母开头。",
      "基础数据类型",
      "对象引用类型",
      "int, long, byte, short, char,float, double, boolean",
      "Classes, interfaces, arrays, enums,annotations",
      "只有值，没有ID (与其他值无法区分)",
      "既有ID，也有值",
      "Immutable 不可变的",
      "Some mutable, some not 可变/不可变",
      "On stack, exist only when in use 在栈中分配内存",
      "On heap, garbage collected 在堆中分配内存",
      "无法实现表达的统一",
      "Unity of expression with generics",
      "Dirt cheap 代价低",
      "More costly代价昂贵",
      "将基本数据类型封装为对象类型",
      "Boolean, Integer, Short, Long, Character, Float, Double",
      "通常是在定义容器类型的时候使用它们（容器类型操作的元素要求是",
      "对象类型，所以需要对基本数据类型进行包装，转换为对象类型），",
      "一般情况下，尽量避免使用（会降低性能）",
      "操作符",
      "java不支持操作符重载",
      "，虽然java里的String可以使用\"+\"进行连接，貌似进行了运算符重载，但其实不是，这是JVM进行的处理，JVM编译的时候会构建一个StringBuilder，然后调用了append方法将字符串连接起来，这和C++的运算符重载有本质的不同",
      "2.静态与动态数据类型检查",
      "java是静态类型语言，类型检查在运行前就进行了，在像Python这样的动态类型语言中，这种检查会被推迟到运行时（当程序运行时）",
      "检查类型",
      "静态检查",
      "动态检查",
      "不检查",
      "在程序运行之前就会自动发现这个错误",
      "执行代码时会自动发现错误",
      "该语言根本不能帮助您查找错误。你必须自己注意，否则就会得到错误的答案",
      "可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性",
      "静态检查往往是关于类型的，这些错误与变量所具有的特定值无关。",
      "关于“值”的检查",
      "检查类容：Syntax errors ，Wrong names，Wrong number of arguments ，Wrong argument types，Wrong return types ，Illegal argument values，Unrepresentable return values ，Out-of-range indexes，Calling a method on a null object reference",
      "3.可变性和不可变性",
      "改变一个变量：将该变量指向另一个值的存储空间。",
      "改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。",
      "重要设计原则：不变性，",
      "变化是“罪恶”，但程序不能没有变化",
      "尽可能避免变化，以避免副作用",
      "不变数据类型：一旦被创建，其值不能改变",
      "如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变指向其他对象",
      "4.快照图",
      "用于描述程序运行时的内部状态",
      "便于程序员之间的交流",
      "便于刻画各类变量随时间变化",
      "便于解释设计思路",
      "具体看课件上的图，怎么画解释的很清楚，这里不多赘述。",
      "5.复杂数据类型",
      "Implementations of",
      "List",
      "Set",
      "and",
      "Map",
      "列表、集合和图的实现",
      "– List: ArrayList and LinkedList",
      "迭代器",
      "迭代器是一个对象，它遍历一组元素并逐个返回元素 ，for(…:…)形式的遍历，调用的是被遍历对象所实现的迭代器",
      "迭代器（iterator）的两个方法：",
      "– hasNext() tests whether the iterator has reached the end of the collection",
      "用法如下：",
      "空引用的危害",
      "在Java中，对对象和数组的引用也可以接受特殊值Null，这意味着该引用不指向对象。空值是Java类型系统中一个不幸的漏洞。",
      "基本数据类型不能为空，编译器将拒绝这样的带有静态错误的尝试：",
      "int size = null; //illegal",
      "无法调用任何方法或使用具有这些引用之一的任何字段（抛出Null指针异常）",
      "null与空字符串“”或空数组不相同",
      "在参数和返回值中隐式地不允许使用空值。如果一个方法允许一个参数的空值，它应该显式地声明它，或者如果它可能因此返回一个空值，它应该显式地声明它。但这些通常都不是什么好主意。避免设置为空。"
    ],
    "sentences": [
      "ADT and OOP 复习总结（一）",
      "软件构造的理论基础——ADT(抽象数据类型)",
      "软件构造的技术基础——OOP(面向对象编程)",
      "章节目标",
      "1.Types in java",
      "基本数据类型",
      "对象引用数据类型",
      "根据Java约定",
      "基础数据类型为小写",
      "而对象类型以大写字母开头",
      "基础数据类型",
      "对象引用类型",
      "int, long, byte, short, char,float, double, boolean",
      "Classes, interfaces, arrays, enums,annotations",
      "只有值，没有ID (与其他值无法区分)",
      "既有ID，也有值",
      "Immutable 不可变的",
      "Some mutable, some not 可变/不可变",
      "On stack, exist only when in use 在栈中分配内存",
      "On heap, garbage collected 在堆中分配内存",
      "无法实现表达的统一",
      "Unity of expression with generics",
      "Dirt cheap 代价低",
      "More costly代价昂贵",
      "将基本数据类型封装为对象类型",
      "Boolean, Integer, Short, Long, Character, Float, Double",
      "通常是在定义容器类型的时候使用它们（容器类型操作的元素要求是",
      "对象类型",
      "所以需要对基本数据类型进行包装",
      "转换为对象类型）",
      "一般情况下",
      "尽量避免使用（会降低性能）",
      "操作符",
      "java不支持操作符重载",
      "",
      "虽然java里的String可以使用\"+\"进行连接",
      "貌似进行了运算符重载",
      "但其实不是",
      "这是JVM进行的处理",
      "JVM编译的时候会构建一个StringBuilder",
      "然后调用了append方法将字符串连接起来",
      "这和C++的运算符重载有本质的不同",
      "2.静态与动态数据类型检查",
      "java是静态类型语言",
      "类型检查在运行前就进行了",
      "在像Python这样的动态类型语言中",
      "这种检查会被推迟到运行时（当程序运行时）",
      "检查类型",
      "静态检查",
      "动态检查",
      "不检查",
      "在程序运行之前就会自动发现这个错误",
      "执行代码时会自动发现错误",
      "该语言根本不能帮助您查找错误",
      "你必须自己注意，否则就会得到错误的答案",
      "可在编译阶段发现错误",
      "避免了将错误带入到运行阶段",
      "可提高程序正确性/健壮性",
      "静态检查往往是关于类型的，这些错误与变量所具有的特定值无关",
      "关于“值”的检查",
      "检查类容：Syntax errors ",
      "Wrong names",
      "Wrong number of arguments ",
      "Wrong argument types",
      "Wrong return types ",
      "Illegal argument values",
      "Unrepresentable return values ",
      "Out-of-range indexes",
      "Calling a method on a null object reference",
      "3.可变性和不可变性",
      "改变一个变量：将该变量指向另一个值的存储空间",
      "改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值",
      "重要设计原则：不变性，变化是“罪恶”，但程序不能没有变化",
      "尽可能避免变化，以避免副作用",
      "不变数据类型：一旦被创建，其值不能改变",
      "如果是引用类型",
      "也可以是不变的：一旦确定其指向的对象",
      "不能再被改变指向其他对象",
      "4.快照图",
      "用于描述程序运行时的内部状态",
      "便于程序员之间的交流",
      "便于刻画各类变量随时间变化",
      "便于解释设计思路",
      "具体看课件上的图，怎么画解释的很清楚，这里不多赘述",
      "5.复杂数据类型",
      "Implementations of",
      "List",
      "Set",
      "and",
      "Map",
      "列表、集合和图的实现",
      "– List: ArrayList and LinkedList",
      "迭代器",
      "迭代器是一个对象",
      "它遍历一组元素并逐个返回元素 ",
      "for(…:…)形式的遍历",
      "调用的是被遍历对象所实现的迭代器",
      "迭代器（iterator）的两个方法：– hasNext() tests whether the iterator has reached the end of the collection",
      "用法如下：空引用的危害",
      "在Java中",
      "对对象和数组的引用也可以接受特殊值Null",
      "这意味着该引用不指向对象",
      "空值是Java类型系统中一个不幸的漏洞",
      "基本数据类型不能为空",
      "编译器将拒绝这样的带有静态错误的尝试：int size = null; //illegal",
      "无法调用任何方法或使用具有这些引用之一的任何字段（抛出Null指针异常）",
      "null与空字符串“”或空数组不相同",
      "在参数和返回值中隐式地不允许使用空值",
      "如果一个方法允许一个参数的空值",
      "它应该显式地声明它",
      "或者如果它可能因此返回一个空值",
      "它应该显式地声明它",
      "但这些通常都不是什么好主意",
      "避免设置为空"
    ],
    "codes": [
      "1. Get to know basic knowledge about data type, and static and \ndynamic type checking in programming language, especially in Java. \n——静态/动态类型检查\n2. Understand mutability and mutable objects ——可变/不变的数据类型\n3. Identify aliasing and understand the dangers of mutability \n——可变数据类型的危险性\n4. Use immutability to improve correctness, clarity and changeability \n——不变数据类型的优越性\n5. Use snapshot diagram to demonstrate the state of specific time \nduring a program’s execution. ——用Snapshot图理解数据类型\n6. Use Arrays, Collections and Enum to deal with complex data types \n——用集合类表达复杂数据类型\n7. Know the harm of Null references and avoid it\n——了解空引用的危害，并避免使用它\n",
      "– int (for integers like 5 and -200, but limited to the range ± 2^31, or \nroughly ± 2 billion)\n– long (for larger integers up to ± 2^63)\n– boolean (for true or false)\n– double (for floating-point numbers, which represent a subset of the real \nnumbers)\n– char (for single characters like 'A' and '$' )\n",
      "– String represents a sequence of characters.\n– BigInteger represents an integer of arbitrary size.\n",
      " - Assignment: = \n – Addition: + \n – Subtraction: - \n – Multiplication: * \n – Division: /\n",
      "int[] a = new int[100];\n– indexing: a[2]\n– assignment: a[2]=0\n– length: a.length\n",
      "List<Integer> list = new ArrayList<Integer>();\n– indexing: list.get(2)\n– assignment: list.set(2, 0)\n– length: list.size()\nNote 1: List is an interface.列表是一个接口\nNote 2: members in a Listmust be an object.列表的成员必须是对象数据类型    \n",
      "集合是包含零或多个唯一对象的无序集合。\n\n– s1.contains(e) test if the set contains an element\n– s1.containsAll(s2)test whether s1 ⊇ s2\n– s1.removeAll(s2) remove s2 from s1\n\nSet is an abstract interface 集合是一个抽象接口\n",
      "A Map is similar to a dictionary (key-value)\n– map.put(key, val) add the mapping key → val\n– map.get(key) get the value for a key\n– map.containsKey(key) test whether the map has a key\n– map.remove(key) delete a mapping\n Map is an abstract interface\n",
      "List<String> firstNames = new ArrayList<String>();\nList<String> lastNames = new LinkedList<String>();\nList<String> firstNames = new ArrayList<>();\nList<String> lastNames = new LinkedList<>();\nSet<Integer> numbers = new HashSet<>();\nMap<String,Turtle> turtles = new HashMap<>();\n",
      "List<String> lst = new ArrayList<String>();\nIterator iter = lst.iterator();\nwhile(iter.hasNext()){\n    String str = iter.next();\n    System.out.println(str);\n}\n",
      "– Set: HashSet",
      "– Map: HashMap",
      "– next() returns the next element in the collection — this is a",
      "mutator",
      "method!"
    ],
    "date": "2021-07-07",
    "text": "ADT and OOP 复习总结（一）\n软件构造的理论基础——ADT(抽象数据类型)\n软件构造的技术基础——OOP(面向对象编程)\n章节目标\n1.Types in java\n基本数据类型\n对象引用数据类型\n根据Java约定，基础数据类型为小写，而对象类型以大写字母开头。\n基础数据类型\n对象引用类型\nint, long, byte, short, char,float, double, boolean\nClasses, interfaces, arrays, enums,annotations\n只有值，没有ID (与其他值无法区分)\n既有ID，也有值\nImmutable 不可变的\nSome mutable, some not 可变/不可变\nOn stack, exist only when in use 在栈中分配内存\nOn heap, garbage collected 在堆中分配内存\n无法实现表达的统一\nUnity of expression with generics\nDirt cheap 代价低\nMore costly代价昂贵\n将基本数据类型封装为对象类型\nBoolean, Integer, Short, Long, Character, Float, Double\n通常是在定义容器类型的时候使用它们（容器类型操作的元素要求是\n对象类型，所以需要对基本数据类型进行包装，转换为对象类型），\n一般情况下，尽量避免使用（会降低性能）\n操作符\njava不支持操作符重载\n，虽然java里的String可以使用\"+\"进行连接，貌似进行了运算符重载，但其实不是，这是JVM进行的处理，JVM编译的时候会构建一个StringBuilder，然后调用了append方法将字符串连接起来，这和C++的运算符重载有本质的不同\n2.静态与动态数据类型检查\njava是静态类型语言，类型检查在运行前就进行了，在像Python这样的动态类型语言中，这种检查会被推迟到运行时（当程序运行时）\n检查类型\n静态检查\n动态检查\n不检查\n在程序运行之前就会自动发现这个错误\n执行代码时会自动发现错误\n该语言根本不能帮助您查找错误。你必须自己注意，否则就会得到错误的答案\n可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性\n静态检查往往是关于类型的，这些错误与变量所具有的特定值无关。\n关于“值”的检查\n检查类容：Syntax errors ，Wrong names，Wrong number of arguments ，Wrong argument types，Wrong return types ，Illegal argument values，Unrepresentable return values ，Out-of-range indexes，Calling a method on a null object reference\n3.可变性和不可变性\n改变一个变量：将该变量指向另一个值的存储空间。\n改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。\n重要设计原则：不变性，\n变化是“罪恶”，但程序不能没有变化\n尽可能避免变化，以避免副作用\n不变数据类型：一旦被创建，其值不能改变\n如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变指向其他对象\n4.快照图\n用于描述程序运行时的内部状态\n便于程序员之间的交流\n便于刻画各类变量随时间变化\n便于解释设计思路\n具体看课件上的图，怎么画解释的很清楚，这里不多赘述。\n5.复杂数据类型\nImplementations of\nList\nSet\nand\nMap\n列表、集合和图的实现\n– List: ArrayList and LinkedList\n迭代器\n迭代器是一个对象，它遍历一组元素并逐个返回元素 ，for(…:…)形式的遍历，调用的是被遍历对象所实现的迭代器\n迭代器（iterator）的两个方法：\n– hasNext() tests whether the iterator has reached the end of the collection\n用法如下：\n空引用的危害\n在Java中，对对象和数组的引用也可以接受特殊值Null，这意味着该引用不指向对象。空值是Java类型系统中一个不幸的漏洞。\n基本数据类型不能为空，编译器将拒绝这样的带有静态错误的尝试：\nint size = null; //illegal\n无法调用任何方法或使用具有这些引用之一的任何字段（抛出Null指针异常）\nnull与空字符串“”或空数组不相同\n在参数和返回值中隐式地不允许使用空值。如果一个方法允许一个参数的空值，它应该显式地声明它，或者如果它可能因此返回一个空值，它应该显式地声明它。但这些通常都不是什么好主意。避免设置为空。\n"
  },
  {
    "head": "java接口(Interface)学习笔记",
    "paragraphs": [
      "java接口(Interface)学习笔记",
      "接口(Interface)，在java编程语言中是一个抽象类型，是",
      "抽象方法的集合",
      "，通常用interface来声明，一个类可以通过继承接口的方式，从而来继承接口的抽象方法。",
      "一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为",
      "需要注意的是，接口并不是类，编写接口的方式和类很相似，但是他们属于不同的概念，类描述对象的属性和方法，接口则包含要实现的方法。",
      "如下面这是一个典型的类",
      "接口与类相似点：",
      "一个接口可以有多个方法。",
      "接口文件保存在 .java 结尾的文件中，文件名使用接口名。",
      "接口的字节码文件保存在 .class 结尾的文件中。",
      "接口相应的字节码文件必须在与包名称相匹配的目录结构中。",
      "接口与类的区别：",
      "接口不能用于实例化对象。",
      "接口没有构造方法。",
      "接口中所有的方法必须是抽象方法。",
      "不能包含成员变量",
      "，除了 static 和 final 变量。",
      "接口不是被类继承了，而是要被类实现。",
      "接口支持多继承。",
      "抽象类和接口的区别",
      "抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。",
      "抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是",
      "public static final",
      "类型的。",
      "接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。",
      "一个类只能继承一个抽象类，而一个类却可以实现多个接口。",
      "接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。总而言之，",
      "实现接口的类除非是抽象类，否则该类要定义接口中的所有方法",
      "接口的声明语法格式如下",
      "下面是个接口声明的简单例子",
      "接口有以下特性：",
      "接口是",
      "隐式抽象",
      "的，当声明一个接口的时候，不必使用",
      "abstract",
      "关键字。",
      "接口中每一个方法也是",
      "隐式抽象",
      "的，声明时同样不需要",
      "abstract",
      "关键字。",
      "接口中的方法",
      "都是公有的",
      "接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。",
      "接口的实现",
      "当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。",
      "类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。",
      "实现一个接口的语法，可以使用这个公式：",
      "实例(",
      "抽象类实现接口",
      "抽象类和接口都是java中用来实现多态的方法，在java一般的用法中，如果要用普通类来实现接口，则必须实现该接口中的所有方法，这样就会导致需要实现多余的方法；",
      "采用抽象类来实现方法，可以实现该接口中的部分方法，而且当其他类继承该抽象类时，只需要实现抽象类中未实现的方法即可。",
      "抽象类B只实现了接口A中的方法a、b，",
      "当类C继承类B时，只需要实现B中为实现的接口c即可。",
      "一般情况下，类C中的方法a、b都是调用父类B的方法a、b。",
      "接口代码",
      "抽象父类",
      "子类：",
      "实例(普通类类实现一个接口)",
      "需要实现接口中的所有方法",
      "实例(普通类实现多个接口)",
      "如现在有两个接口如下",
      "那么一个类可以一并实现上面两个接口",
      "重写接口中声明的方法时，需要注意以下规则：",
      "类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。",
      "类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。",
      "如果实现接口的类是抽象类，那么就没必要实现该接口的方法。",
      "在实现接口的时候，也要注意一些规则：",
      "一个类可以同时实现多个接口。",
      "一个类只能继承一个类，但是能实现多个接口。",
      "一个接口能继承另一个接口，这和类之间的继承比较相似。",
      "接口的继承(extends关键字)",
      "java类的多继承是不合法，但接口是支持多继承的。",
      "语法如下",
      "如现在有两个接口如下",
      "那么第三个接口可以同时继承上面两个接口",
      "实现类，A类实现了Interface3，需要将Interface3的方法和它继承的Interface1和Interface2的方法一并实现。"
    ],
    "sentences": [
      "java接口(Interface)学习笔记",
      "接口(Interface)",
      "在java编程语言中是一个抽象类型",
      "是",
      "抽象方法的集合",
      "",
      "通常用interface来声明",
      "一个类可以通过继承接口的方式",
      "从而来继承接口的抽象方法",
      "一个接口只有方法的特征没有方法的实现",
      "因此这些方法可以在不同的地方被不同的类实现",
      "而这些实现可以具有不同的行为",
      "需要注意的是",
      "接口并不是类",
      "编写接口的方式和类很相似",
      "但是他们属于不同的概念",
      "类描述对象的属性和方法",
      "接口则包含要实现的方法",
      "如下面这是一个典型的类",
      "接口与类相似点：一个接口可以有多个方法",
      "接口文件保存在 .java 结尾的文件中，文件名使用接口名",
      "接口的字节码文件保存在 .class 结尾的文件中",
      "接口相应的字节码文件必须在与包名称相匹配的目录结构中",
      "接口与类的区别：接口不能用于实例化对象",
      "接口没有构造方法",
      "接口中所有的方法必须是抽象方法",
      "不能包含成员变量",
      "，除了 static 和 final 变量",
      "接口不是被类继承了，而是要被类实现",
      "接口支持多继承",
      "抽象类和接口的区别",
      "抽象类中的方法可以有方法体",
      "就是能实现方法的具体功能",
      "但是接口中的方法不行",
      "抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是",
      "public static final",
      "类型的",
      "接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)",
      "而抽象类是可以有静态代码块和静态方法",
      "一个类只能继承一个抽象类，而一个类却可以实现多个接口",
      "接口无法被实例化，但是可以被实现",
      "一个实现接口的类",
      "必须实现接口内所描述的所有方法",
      "否则就必须声明为抽象类",
      "另外",
      "在 Java 中",
      "接口类型可用来声明一个变量",
      "他们可以成为一个空指针",
      "或是被绑定在一个以此接口实现的对象",
      "总而言之",
      "实现接口的类除非是抽象类",
      "否则该类要定义接口中的所有方法",
      "接口的声明语法格式如下",
      "下面是个接口声明的简单例子",
      "接口有以下特性：接口是",
      "隐式抽象",
      "的，当声明一个接口的时候，不必使用",
      "abstract",
      "关键字",
      "接口中每一个方法也是",
      "隐式抽象",
      "的，声明时同样不需要",
      "abstract",
      "关键字",
      "接口中的方法",
      "都是公有的",
      "接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图",
      "接口的实现",
      "当类实现接口的时候，类要实现接口中所有的方法",
      "否则，类必须声明为抽象的类",
      "类使用implements关键字实现接口",
      "在类声明中，Implements关键字放在class声明后面",
      "实现一个接口的语法，可以使用这个公式：实例(",
      "抽象类实现接口",
      "抽象类和接口都是java中用来实现多态的方法",
      "在java一般的用法中",
      "如果要用普通类来实现接口",
      "则必须实现该接口中的所有方法",
      "这样就会导致需要实现多余的方法；采用抽象类来实现方法",
      "可以实现该接口中的部分方法",
      "而且当其他类继承该抽象类时",
      "只需要实现抽象类中未实现的方法即可",
      "抽象类B只实现了接口A中的方法a、b",
      "当类C继承类B时",
      "只需要实现B中为实现的接口c即可",
      "一般情况下，类C中的方法a、b都是调用父类B的方法a、b",
      "接口代码",
      "抽象父类",
      "子类：实例(普通类类实现一个接口)",
      "需要实现接口中的所有方法",
      "实例(普通类实现多个接口)",
      "如现在有两个接口如下",
      "那么一个类可以一并实现上面两个接口",
      "重写接口中声明的方法时",
      "需要注意以下规则：类在实现接口的方法时",
      "不能抛出强制性异常",
      "只能在接口中",
      "或者继承接口的抽象类中抛出该强制性异常",
      "类在重写方法时要保持一致的方法名",
      "并且应该保持相同或者相兼容的返回值类型",
      "如果实现接口的类是抽象类，那么就没必要实现该接口的方法",
      "在实现接口的时候",
      "也要注意一些规则：一个类可以同时实现多个接口",
      "一个类只能继承一个类，但是能实现多个接口",
      "一个接口能继承另一个接口，这和类之间的继承比较相似",
      "接口的继承(extends关键字)",
      "java类的多继承是不合法，但接口是支持多继承的",
      "语法如下",
      "如现在有两个接口如下",
      "那么第三个接口可以同时继承上面两个接口",
      "实现类",
      "A类实现了Interface3",
      "需要将Interface3的方法和它继承的Interface1和Interface2的方法一并实现"
    ],
    "codes": [
      "public class Dog{\n    //类的属性,接口的属性只能是final static的属性，不能是变量\n    String name;\n    int size;\n    String colour;\n    int age;\n    \n    //类的构造函数，接口没有构造函数\n    public Dog(String name){\n        this.name = name;\n        \n    }\n    \n    /*类的方法 方法有方法体，而接口的方法是抽象的，不能有方法体，必须由要实现它的类来定义这些方法*/\n    void setSize(int size){\n        this.size;\n    }\n    void setColour(String colour){\n        this.colour = colour;\n    }\n    void setAge(int age){\n        this.age = age;\n    }\n}\n",
      "[可见度] interface 接口名称 [extends 其他的接口名] {\n        // 声明变量\n        // 抽象方法\n}\n",
      "public interface NameOfInterface\n{\n   //任何类型 final, static 字段\n   //抽象方法\n}\n",
      "interface Animal{\n    public void eat();\n    public void travel();\n}\n",
      "...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...\n",
      "public interface Action {\n    public void jump();\n    public void eat();\n    public void run();\n}\n",
      "public abstract class Animal implements Action{\n    public String name;\n    public int age;\n \n    public Animal() {\n    }\n \n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public abstract void fly();\n    @Override\n    public void jump() {\n        System.out.println(name+\"在跳高\");\n    }\n    \n    //没有实现public void run()和public void eat();\n\n}\n",
      "public class Cat extends Animal /*implements Jumpping*/ {\n    public Cat() {\n    }\n \n    public Cat(String name, int age) {\n        super(name, age);\n    }\n    \n    //只需实现了抽象类的抽象方法public abstract void fly();\n    public void fly() {\n        System.out.println(\"猫在飞\");\n    }\n    public static void main(String args[]){\n        Cat cat = new Cat(\"wyq\", 12);\n        cat.fly;\n        cat.jump();//can run, ok!\n        cat.fly();//can run, ok!\n        cat.run();//会报错，抽象父类中并没有实现这个方法\n        \n    }\n}\n",
      "public class Dog implements Animal{\n    //类的属性,接口的属性只能是final static的属性，不能是变量\n    String name;\n    int size;\n    String colour;\n    int age;\n    \n    //类的构造函数，接口没有构造函数\n    public Dog(String name){\n        this.name = name;\n        \n    }\n    \n    /*类的方法 方法有方法体，而接口的方法是抽象的，不能有方法体，必须由要实现它的类来定义这些方法*/\n    void setSize(int size){\n        this.size;\n    }\n    void setColour(String colour){\n        this.colour = colour;\n    }\n    void setAge(int age){\n        this.age = age;\n    }\n    \n    /*需要实现的接口的方法*/\n    @Override\n    public void eat(){\n        System.out.println(\"Dog eats\");\n    }\n    @Override\n    public void travel(){\n        System.out.println(\"Dog travels\");\n    }\n\n \n   public static void main(String args[]){\n      Dog dog = new Dog(\"wyq\");\n      dog.eat();\n      dog.travel();\n   }\n}\n",
      "public interface Interface1{\n    public void method1();\n}\n",
      "public interface Interface2{\n    public void method2();\n}\n",
      "public class A implements Interface1, Interface2{\n    public A(){\n        \n    }\n    @Override\n    public void method1(){\n        System.out.println(\"method1\");  \n    }\n    @Override\n    public void method2(){\n        System.out.println(\"method2\");  \n    }\n}\n",
      "...extends 接口名称, 其他接口名称, 其他接口名称..., ... ...\n",
      "public interface Interface1{\n    public void method1();\n}\n",
      "public interface Interface2{\n    public void method2();\n}\n",
      "public interface Interface3 extends Interface1, Interface2{\n    public void method3();\n}\n",
      "public class A implements Interface3{\n    @Override\n    public void method1(){\n        System.out.println(\"method1\");  \n    }\n    @Override\n    public void method2(){\n        System.out.println(\"method2\");  \n    }\n    @Override\n    public void method3(){\n        System.out.println(\"method3\");  \n    }\n    public static void main(String[] args) {  \n        method1();\n        method2();\n        method3();\n    }  \n    \n}\n"
    ],
    "date": "2021-07-06",
    "text": "java接口(Interface)学习笔记\n接口(Interface)，在java编程语言中是一个抽象类型，是\n抽象方法的集合\n，通常用interface来声明，一个类可以通过继承接口的方式，从而来继承接口的抽象方法。\n一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为\n需要注意的是，接口并不是类，编写接口的方式和类很相似，但是他们属于不同的概念，类描述对象的属性和方法，接口则包含要实现的方法。\n如下面这是一个典型的类\n接口与类相似点：\n一个接口可以有多个方法。\n接口文件保存在 .java 结尾的文件中，文件名使用接口名。\n接口的字节码文件保存在 .class 结尾的文件中。\n接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n接口与类的区别：\n接口不能用于实例化对象。\n接口没有构造方法。\n接口中所有的方法必须是抽象方法。\n不能包含成员变量\n，除了 static 和 final 变量。\n接口不是被类继承了，而是要被类实现。\n接口支持多继承。\n抽象类和接口的区别\n抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是\npublic static final\n类型的。\n接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。总而言之，\n实现接口的类除非是抽象类，否则该类要定义接口中的所有方法\n接口的声明语法格式如下\n下面是个接口声明的简单例子\n接口有以下特性：\n接口是\n隐式抽象\n的，当声明一个接口的时候，不必使用\nabstract\n关键字。\n接口中每一个方法也是\n隐式抽象\n的，声明时同样不需要\nabstract\n关键字。\n接口中的方法\n都是公有的\n接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。\n接口的实现\n当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。\n类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。\n实现一个接口的语法，可以使用这个公式：\n实例(\n抽象类实现接口\n抽象类和接口都是java中用来实现多态的方法，在java一般的用法中，如果要用普通类来实现接口，则必须实现该接口中的所有方法，这样就会导致需要实现多余的方法；\n采用抽象类来实现方法，可以实现该接口中的部分方法，而且当其他类继承该抽象类时，只需要实现抽象类中未实现的方法即可。\n抽象类B只实现了接口A中的方法a、b，\n当类C继承类B时，只需要实现B中为实现的接口c即可。\n一般情况下，类C中的方法a、b都是调用父类B的方法a、b。\n接口代码\n抽象父类\n子类：\n实例(普通类类实现一个接口)\n需要实现接口中的所有方法\n实例(普通类实现多个接口)\n如现在有两个接口如下\n那么一个类可以一并实现上面两个接口\n重写接口中声明的方法时，需要注意以下规则：\n类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。\n类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。\n如果实现接口的类是抽象类，那么就没必要实现该接口的方法。\n在实现接口的时候，也要注意一些规则：\n一个类可以同时实现多个接口。\n一个类只能继承一个类，但是能实现多个接口。\n一个接口能继承另一个接口，这和类之间的继承比较相似。\n接口的继承(extends关键字)\njava类的多继承是不合法，但接口是支持多继承的。\n语法如下\n如现在有两个接口如下\n那么第三个接口可以同时继承上面两个接口\n实现类，A类实现了Interface3，需要将Interface3的方法和它继承的Interface1和Interface2的方法一并实现。\n"
  },
  {
    "head": "NLP小任务实战01-语义表示",
    "paragraphs": [
      "将一段语料进行语义表示,不是一件容易的事情.",
      "本文通过SVD,实现初步的语义表示任务",
      "本次任务的代码与语料我都放在自己的github仓库里面了",
      "仓库地址:",
      "https://github.com/HIT1190202126/Nlp-trail",
      "语料是春季学期上秦老师的选修课时老师给的关于蒙牛的一个语料",
      "长这样",
      "我们主要关心语料里面语义的表示",
      "一.语料的预处理",
      "首先,获取语料,并利用正则,删去没有意义的句子",
      "最后,对获取的中文语句,利用jieba进行分词",
      "二.文档转独热",
      "三.进行SVD分解",
      "四.进行检验",
      "取出文档里面的一些句子,看看大致是否符合相似度:",
      "蒙牛很牛",
      "蒙牛 挺牛的",
      "我不是蒙牛、没你想象那么纯。–要不要这么讽刺啊？蒙牛好尴尬。。。",
      "相似度利用余弦相似度进行计算",
      "代码:",
      "计算出来的结果:",
      "蒙牛很牛和 蒙牛挺牛的 相似度:0.64",
      "蒙牛挺牛的 和 我不是蒙牛、没你想象那么纯。–要不要这么讽刺啊？蒙牛好尴尬。。。相似度 0.29",
      "这种传统的方法初步实现了语义表示的任务,不过有待完善,详情参见下一篇博客->",
      "利用NNLM的模型对语义进行表示"
    ],
    "sentences": [
      "将一段语料进行语义表示,不是一件容易的事情.本文通过SVD,实现初步的语义表示任务",
      "本次任务的代码与语料我都放在自己的github仓库里面了",
      "仓库地址:https://github.com/HIT1190202126/Nlp-trail",
      "语料是春季学期上秦老师的选修课时老师给的关于蒙牛的一个语料",
      "长这样",
      "我们主要关心语料里面语义的表示",
      "一.语料的预处理",
      "首先,获取语料,并利用正则,删去没有意义的句子",
      "最后,对获取的中文语句,利用jieba进行分词",
      "二.文档转独热",
      "三.进行SVD分解",
      "四.进行检验",
      "取出文档里面的一些句子,看看大致是否符合相似度:蒙牛很牛",
      "蒙牛 挺牛的",
      "我不是蒙牛、没你想象那么纯",
      "–要不要这么讽刺啊？蒙牛好尴尬",
      "相似度利用余弦相似度进行计算",
      "代码:计算出来的结果:蒙牛很牛和 蒙牛挺牛的 相似度:0.64",
      "蒙牛挺牛的 和 我不是蒙牛、没你想象那么纯",
      "–要不要这么讽刺啊？蒙牛好尴尬",
      "相似度 0.29",
      "这种传统的方法初步实现了语义表示的任务,不过有待完善,详情参见下一篇博客->",
      "利用NNLM的模型对语义进行表示"
    ],
    "codes": [
      "# 读取文档转字符串,并对字符串进行分词\ndef getFILE(name):\n    f=open(name,\"r\",encoding='utf-8')\n    line=f.readline()\n    line=line[:-1]\n    A=[]\n    while line:\n        line=f.readline()\n        str=line\n        str=re.sub(\"(-)?[0-9]\\t\",\"\",str)\n        listJieba = jieba.lcut(str)  # 对句子进行分词\n        A.append(listJieba)\n        line=line[:-1]\n    f.close()\n    return  A\n",
      "# 制造one-hot向量\ndef getOneHot(partitionStr):\n    global OneHot\n    OneHot = []\n    for sentence in partitionStr:\n        for word0 in sentence:\n            if not (word0 in OneHot):\n                OneHot.append(word0)\n    return  OneHot\n    \n#对partitionStr里面的句子进行挨个转换,\ndef convert(wordList,partionStr):\n    M_rol= len(partionStr)  #行\n    M_col= len(wordList)    #列\n    retM=np.zeros((M_rol,M_col))\n    i=0\n    for sentence in partitionStr:\n        for word0 in sentence:\n            retM[i][wordList.index(word0)]=retM[i][wordList.index(word0)]+1\n        i=i+1\n    print(np.shape(retM))\n    return  retM\n\n\n",
      "OH = getOneHot(partitionStr)\nM0 = convert(OH, partitionStr)\nnp.save(\"M0.npy\", M0)\nprint(\"进行svd\")\nU, s, vh = np.linalg.svd(M0,full_matrices=1)\nprint(s)\n#取前100维的进行计算\nprint(np.shape(U))\ns=np.diag(s)\nprint(np.shape(s))\nprint(np.shape(vh))\n#k=100\nk=100\nkk=s[0:k,0:k]\nprint(np.shape(kk))\nback=np.dot(U[:,:k],kk)\nback=np.dot(back,vh[:k,:])\n#print(back)\nnp.save(\"svd-result.npy\",back)\n\n",
      "result=np.load(\"svd-result.npy\")\nvec1=result[1,:]#蒙牛很牛\nvec2=result[10,:]#蒙牛 挺牛的\nvec3=result[0,:]#我不是蒙牛、没你想象那么纯。--要不要这么讽刺啊？蒙牛好尴尬。。。\n\nsim1=np.sum(vec1*vec2)/(np.linalg.norm(vec1)*np.linalg.norm(vec2))\nprint(sim1)\nsim2=np.sum(vec3*vec2)/(np.linalg.norm(vec3)*np.linalg.norm(vec2))\nprint(sim2)\n\n"
    ],
    "date": "2021-07-15",
    "text": "将一段语料进行语义表示,不是一件容易的事情.\n本文通过SVD,实现初步的语义表示任务\n本次任务的代码与语料我都放在自己的github仓库里面了\n仓库地址:\nhttps://github.com/HIT1190202126/Nlp-trail\n语料是春季学期上秦老师的选修课时老师给的关于蒙牛的一个语料\n长这样\n我们主要关心语料里面语义的表示\n一.语料的预处理\n首先,获取语料,并利用正则,删去没有意义的句子\n最后,对获取的中文语句,利用jieba进行分词\n二.文档转独热\n三.进行SVD分解\n四.进行检验\n取出文档里面的一些句子,看看大致是否符合相似度:\n蒙牛很牛\n蒙牛 挺牛的\n我不是蒙牛、没你想象那么纯。–要不要这么讽刺啊？蒙牛好尴尬。。。\n相似度利用余弦相似度进行计算\n代码:\n计算出来的结果:\n蒙牛很牛和 蒙牛挺牛的 相似度:0.64\n蒙牛挺牛的 和 我不是蒙牛、没你想象那么纯。–要不要这么讽刺啊？蒙牛好尴尬。。。相似度 0.29\n这种传统的方法初步实现了语义表示的任务,不过有待完善,详情参见下一篇博客->\n利用NNLM的模型对语义进行表示\n"
  },
  {
    "head": "利用Prim算法解决最小生成树",
    "paragraphs": [
      "最小生成树",
      "定义：图G的生成子图T，如果满足：",
      "（1）是树（去掉任意边，图不联通）",
      "（2）边的权值之和最小",
      "则T叫做最小生成树",
      "求解策略：贪心算法",
      "约束：1.只是图里面的边 2.正好|V|-1条边 3.没有圈",
      "这里，有两种算法",
      "首先介绍Prim-小树长大算法",
      "每次从已经建立好的树外面，找到一个距离现在的树最近的点，然后把它联上树，问题解决。",
      "实现的方式，类似Dijkstra算法的搜索可以将算法的时间复杂度降到O(V*V)的数量级",
      "利用dists[]数组，找一个最近的点，每次更新距离树的距离",
      "例子：",
      "08-图7 公路村村通 (30分)",
      "现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。",
      "输入格式:",
      "输入数据包括城镇数目正整数",
      "（≤1000）和候选道路数目",
      "（≤3",
      "）；随后的",
      "行对应",
      "条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到",
      "编号。",
      "输出格式:",
      "输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。",
      "输入样例:",
      "输出样例:",
      "这题就是求最小生成树的权重，在加边时，进行累加操作就可以了。",
      "我一开始是盲搜最近的边，没有进行优化，结果时间复杂度到了O(v^3),后来发现这不是Prim正统思想。",
      "后来的代码见下："
    ],
    "sentences": [
      "最小生成树",
      "定义：图G的生成子图T",
      "如果满足：（1）是树（去掉任意边",
      "图不联通）",
      "（2）边的权值之和最小",
      "则T叫做最小生成树",
      "求解策略：贪心算法",
      "约束：1.只是图里面的边 2.正好|V|-1条边 3.没有圈",
      "这里，有两种算法",
      "首先介绍Prim-小树长大算法",
      "每次从已经建立好的树外面",
      "找到一个距离现在的树最近的点",
      "然后把它联上树",
      "问题解决",
      "实现的方式",
      "类似Dijkstra算法的搜索可以将算法的时间复杂度降到O(V*V)的数量级",
      "利用dists[]数组，找一个最近的点，每次更新距离树的距离",
      "例子：08-图7 公路村村通 (30分)",
      "现有村落间道路的统计数据表中",
      "列出了有可能建设成标准公路的若干条道路的成本",
      "求使每个村落都有公路连通所需要的最低成本",
      "输入格式:输入数据包括城镇数目正整数",
      "（≤1000）和候选道路数目",
      "（≤3",
      "）；随后的",
      "行对应",
      "条道路",
      "每行给出3个正整数",
      "分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本",
      "为简单起见，城镇从1到",
      "编号",
      "输出格式:输出村村通需要的最低成本",
      "如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路",
      "输入样例:输出样例:这题就是求最小生成树的权重",
      "在加边时",
      "进行累加操作就可以了",
      "我一开始是盲搜最近的边",
      "没有进行优化",
      "结果时间复杂度到了O(v^3),后来发现这不是Prim正统思想",
      "后来的代码见下："
    ],
    "codes": [
      "6 15\n1 2 5\n1 3 3\n1 4 7\n1 5 4\n1 6 2\n2 3 4\n2 4 6\n2 5 2\n2 6 6\n3 4 6\n3 5 1\n3 6 1\n4 5 10\n4 6 8\n5 6 3\n",
      "12\n",
      "#include <iostream>\n#define inf 9999999\n\nusing namespace std;\nstruct way\n{\n    int price;\n    /* data */\n} graph[5300][5300];\nint N,M;\nint intree[5300];\nint dists[5300];\nint cost;\nvoid ini()\n{\n    cin>>N>>M;\n    int i,x,y,c;\n    for(i=1;i<=M;i++)\n    {\n        cin>>x>>y>>c;\n        graph[x][y].price=c;\n        graph[y][x].price=c;\n    }\n}\nint near_by_intree(int n)\n{\n    int i;\n    for(i=1;i<=N;i++)\n    {\n        if(graph[i][n].price!=0&&intree[i]==0){\n            return 0;\n        }\n    }\n    return 1;\n}\nint find_dmin()\n{\n    int i;\n    int md=inf-8,loca=-1;\n    for(i=1;i<=N;i++)\n    {\n        if(intree[i]==0&&dists[i]<md)\n        {\n            md=dists[i];\n            loca=i;\n        }\n    }\n    if(loca==-1)\n    {\n        return -1;\n    }\n    else\n    {\n        cost+=md;\n        return loca;\n    }\n}\nint miner(int a,int b)\n{\n    if(a>b){\n        return b;\n    }\n    else\n    {\n        return a;\n    }\n\n}\n\nint prim(int start)\n{\n    intree[start]=0;\n    int p=start;\n    int i,j,k;\n    for(i=0;i<N+1;i++)\n    {\n        dists[i]=inf;\n    }\n    dists[start]=0;\n    while (1)\n    {\n        p=find_dmin();\n        if(p==-1)\n        {\n            break;\n        }\n        intree[p]=1;\n        for(i=1;i<=N;i++)\n        {\n            if(graph[i][p].price!=0&&intree[i]==0)\n            {\n                dists[i]=miner(graph[i][p].price,dists[i]);\n            }\n        }\n\n    }\n    for(i=1;i<=N;i++)\n    {\n        if(intree[i]==0)\n        {\n            cout<<\"-1\";\n            return 0;\n        }\n    }\n    cout<<cost;\n}\nint main()\n{\n    ini();\n    int i,j;\n    int pri[20000];\n    prim(1);\n\n\n}\n\n"
    ],
    "date": "2020-08-09",
    "text": "最小生成树\n定义：图G的生成子图T，如果满足：\n（1）是树（去掉任意边，图不联通）\n（2）边的权值之和最小\n则T叫做最小生成树\n求解策略：贪心算法\n约束：1.只是图里面的边 2.正好|V|-1条边 3.没有圈\n这里，有两种算法\n首先介绍Prim-小树长大算法\n每次从已经建立好的树外面，找到一个距离现在的树最近的点，然后把它联上树，问题解决。\n实现的方式，类似Dijkstra算法的搜索可以将算法的时间复杂度降到O(V*V)的数量级\n利用dists[]数组，找一个最近的点，每次更新距离树的距离\n例子：\n08-图7 公路村村通 (30分)\n现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。\n输入格式:\n输入数据包括城镇数目正整数\n（≤1000）和候选道路数目\n（≤3\n）；随后的\n行对应\n条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到\n编号。\n输出格式:\n输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。\n输入样例:\n输出样例:\n这题就是求最小生成树的权重，在加边时，进行累加操作就可以了。\n我一开始是盲搜最近的边，没有进行优化，结果时间复杂度到了O(v^3),后来发现这不是Prim正统思想。\n后来的代码见下：\n"
  },
  {
    "head": "哈工大2021软件构造实验3心得(1)-进行GUI设计",
    "paragraphs": [
      "哈工大2021软件构造实验3心得(1)-进行GUI设计",
      "最近,笔者完成下窝工的软构实验三.在完成过程中,有很多坑想要记录一下.",
      "顺便方便一下后来的窝工学子.",
      "此Blog主要讨论如何在Eclipse里面写出一个GUI",
      "WindowBulider介绍",
      "来自应用商店的介绍:",
      "WindowBuilder is composed of SWT Designer and Swing Designer and makes it very easy to create Java GUI applications without spending a lot of time writing code. Use the WYSIWYG visual designer and layout tools to create simple forms to complex windows; the Java code will be generated for you. Easily add controls using drag-and-drop, add event handlers to your controls, change various properties of controls using a property editor, internationalize your app, and much more.",
      "下面我们来介绍一下怎么来进行安装:",
      "WindowBuilder的安装",
      "我们直接用最简单的方法,在Eclipse的商店里面装,但是,这个网站由于某种原因,它比较慢,所以,我们选择了",
      "换镜像",
      "Eclipse镜像配置",
      "工欲善其事，必先利其器",
      ",秉承着这样一个原则,我们首先对Eclipse的镜像进行配置.",
      "(1)打开Window 里面的preference界面",
      "(2)直接搜sites关键词进入Available Software Sites",
      "然后把里面的把这里链接里面的",
      "http://download.eclipse.org/ 替换为 http://mirrors.ustc.edu.cn/eclipse",
      "即把它自己的源,更新为清华镜像",
      "比如说以AmaterasUML为例:",
      "如果想进一步的探讨换镜像,可以参考大佬的博客,呐,链接在这.",
      "https://blog.csdn.net/weixin_44543145/article/details/95637057",
      "Eclipse安装WindowBuilder",
      "直接进入Help里面的Marketplace",
      "然后进去直接搜索WindowBuilder",
      "点击Install,直接安装就可以了.",
      "可以发现,切了镜像以后灰常快.",
      "在Eclipse里面设计一个简易的可以传参的GUI",
      "首先,在新建项目里面直接new一个other的新类",
      "然后,点击Jframe进行建立",
      "给它写个名字",
      "点击Finish直接开工.",
      "创建完成以后,可以发现",
      "屏幕里面,有菜单,可以进行自由切换,是源代码模式,还是Design模式",
      "进入Design模式,发现,可以进行图形化编程,即,我们在Design里面进行的操作,将会被以代码的形式转到Sourse里面",
      "下面,我们将进行设计一个最简单的可以传参的GUI",
      "把JTextField,拖到窗口里面.",
      "发现窗口里面多了项textField",
      "然后,在里面进行更改其text内容与属性",
      "右边的窗口也变了",
      "回到Sourse视窗,进行代码的重构",
      "发现,在这里面,存在一个一一对应的\"你好世界\"串,于是,我们将其进行替换为要对方法进行传入的参数即可",
      "更改如下",
      "然后,在main函数里面进行传入特定参数即可实现调用",
      "可以在Design里面对窗口进行个性化",
      "比如换字体",
      "以上就是利用Eclipse 从无到有,设计一个可传参的GUI的过程,",
      "谢谢大家."
    ],
    "sentences": [
      "哈工大2021软件构造实验3心得(1)-进行GUI设计",
      "最近,笔者完成下窝工的软构实验三.在完成过程中,有很多坑想要记录一下.顺便方便一下后来的窝工学子.此Blog主要讨论如何在Eclipse里面写出一个GUI",
      "WindowBulider介绍",
      "来自应用商店的介绍:WindowBuilder is composed of SWT Designer and Swing Designer and makes it very easy to create Java GUI applications without spending a lot of time writing code. Use the WYSIWYG visual designer and layout tools to create simple forms to complex windows; the Java code will be generated for you. Easily add controls using drag-and-drop, add event handlers to your controls, change various properties of controls using a property editor, internationalize your app, and much more.下面我们来介绍一下怎么来进行安装:WindowBuilder的安装",
      "我们直接用最简单的方法,在Eclipse的商店里面装,但是,这个网站由于某种原因,它比较慢,所以,我们选择了",
      "换镜像",
      "Eclipse镜像配置",
      "工欲善其事，必先利其器",
      ",秉承着这样一个原则,我们首先对Eclipse的镜像进行配置.(1)打开Window 里面的preference界面",
      "(2)直接搜sites关键词进入Available Software Sites",
      "然后把里面的把这里链接里面的",
      "http://download.eclipse.org/ 替换为 http://mirrors.ustc.edu.cn/eclipse",
      "即把它自己的源,更新为清华镜像",
      "比如说以AmaterasUML为例:如果想进一步的探讨换镜像,可以参考大佬的博客,呐,链接在这.https://blog.csdn.net/weixin_44543145/article/details/95637057",
      "Eclipse安装WindowBuilder",
      "直接进入Help里面的Marketplace",
      "然后进去直接搜索WindowBuilder",
      "点击Install,直接安装就可以了.可以发现,切了镜像以后灰常快.在Eclipse里面设计一个简易的可以传参的GUI",
      "首先,在新建项目里面直接new一个other的新类",
      "然后,点击Jframe进行建立",
      "给它写个名字",
      "点击Finish直接开工.创建完成以后,可以发现",
      "屏幕里面,有菜单,可以进行自由切换,是源代码模式,还是Design模式",
      "进入Design模式,发现,可以进行图形化编程,即,我们在Design里面进行的操作,将会被以代码的形式转到Sourse里面",
      "下面,我们将进行设计一个最简单的可以传参的GUI",
      "把JTextField,拖到窗口里面.发现窗口里面多了项textField",
      "然后,在里面进行更改其text内容与属性",
      "右边的窗口也变了",
      "回到Sourse视窗,进行代码的重构",
      "发现,在这里面,存在一个一一对应的\"你好世界\"串,于是,我们将其进行替换为要对方法进行传入的参数即可",
      "更改如下",
      "然后,在main函数里面进行传入特定参数即可实现调用",
      "可以在Design里面对窗口进行个性化",
      "比如换字体",
      "以上就是利用Eclipse 从无到有,设计一个可传参的GUI的过程,谢谢大家."
    ],
    "codes": [
      "\t//更改后\n\t/**\n\t * Create the frame.\n\t */\n\tpublic JFab(String argS) {\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetBounds(100, 100, 450, 300);\n\t\tcontentPane = new JPanel();\n\t\tcontentPane.setBorder(new EmptyBorder(5, 5, 5, 5));\n\t\tcontentPane.setLayout(new BorderLayout(0, 0));\n\t\tsetContentPane(contentPane);\n\t\t\n\t\ttextField = new JTextField();\n\t\ttextField.setText(argS);\n\t\tcontentPane.add(textField, BorderLayout.CENTER);\n\t\ttextField.setColumns(10);\n\t}\n}\n\n"
    ],
    "date": "2021-06-12",
    "text": "哈工大2021软件构造实验3心得(1)-进行GUI设计\n最近,笔者完成下窝工的软构实验三.在完成过程中,有很多坑想要记录一下.\n顺便方便一下后来的窝工学子.\n此Blog主要讨论如何在Eclipse里面写出一个GUI\nWindowBulider介绍\n来自应用商店的介绍:\nWindowBuilder is composed of SWT Designer and Swing Designer and makes it very easy to create Java GUI applications without spending a lot of time writing code. Use the WYSIWYG visual designer and layout tools to create simple forms to complex windows; the Java code will be generated for you. Easily add controls using drag-and-drop, add event handlers to your controls, change various properties of controls using a property editor, internationalize your app, and much more.\n下面我们来介绍一下怎么来进行安装:\nWindowBuilder的安装\n我们直接用最简单的方法,在Eclipse的商店里面装,但是,这个网站由于某种原因,它比较慢,所以,我们选择了\n换镜像\nEclipse镜像配置\n工欲善其事，必先利其器\n,秉承着这样一个原则,我们首先对Eclipse的镜像进行配置.\n(1)打开Window 里面的preference界面\n(2)直接搜sites关键词进入Available Software Sites\n然后把里面的把这里链接里面的\nhttp://download.eclipse.org/ 替换为 http://mirrors.ustc.edu.cn/eclipse\n即把它自己的源,更新为清华镜像\n比如说以AmaterasUML为例:\n如果想进一步的探讨换镜像,可以参考大佬的博客,呐,链接在这.\nhttps://blog.csdn.net/weixin_44543145/article/details/95637057\nEclipse安装WindowBuilder\n直接进入Help里面的Marketplace\n然后进去直接搜索WindowBuilder\n点击Install,直接安装就可以了.\n可以发现,切了镜像以后灰常快.\n在Eclipse里面设计一个简易的可以传参的GUI\n首先,在新建项目里面直接new一个other的新类\n然后,点击Jframe进行建立\n给它写个名字\n点击Finish直接开工.\n创建完成以后,可以发现\n屏幕里面,有菜单,可以进行自由切换,是源代码模式,还是Design模式\n进入Design模式,发现,可以进行图形化编程,即,我们在Design里面进行的操作,将会被以代码的形式转到Sourse里面\n下面,我们将进行设计一个最简单的可以传参的GUI\n把JTextField,拖到窗口里面.\n发现窗口里面多了项textField\n然后,在里面进行更改其text内容与属性\n右边的窗口也变了\n回到Sourse视窗,进行代码的重构\n发现,在这里面,存在一个一一对应的\"你好世界\"串,于是,我们将其进行替换为要对方法进行传入的参数即可\n更改如下\n然后,在main函数里面进行传入特定参数即可实现调用\n可以在Design里面对窗口进行个性化\n比如换字体\n以上就是利用Eclipse 从无到有,设计一个可传参的GUI的过程,\n谢谢大家.\n"
  },
  {
    "head": "哈工大2021软件构造实验3心得(2)在Junit里面对命令行程序的单元测试",
    "paragraphs": [
      "笔者最近完成了窝工软件构造里面的Lab3",
      "写了一个针对命令行交互的小程序.",
      "不过,在进行测试时遇到了一丢丢小麻烦",
      "即,怎么来对一个对命令行交互的程序进行测试",
      "在<<阿里巴巴Java开发规范>>里面有这样的一句话",
      "我们作为一名系统学习了软件构造的学生,如果仅仅是向大一那样,通过纯手敲的方法,来对一个小软件进行测试,那就有点low了.",
      "于是,我们采用Junit的方法,利用它,进行软件的单元测试",
      "关键:对Java的输入输出进行重定向",
      "首先,我们需要记录下默认的Java输入输出流:",
      "然后,我们需要手动设置输出流,即,将程序的输出,从屏幕转到我们想要的地方",
      "同时,我们还需要手动设置输入流,将键盘输入转成从文件里面进行输入",
      "然后,就可以开始进行跑我们的程序了",
      "跑完以后,我们直接取出标准输出,转String进行检查",
      "最后,复位标准输入输出",
      "以上就是利用Junit对在命令行程序进行check的步骤,谢谢大家"
    ],
    "sentences": [
      "笔者最近完成了窝工软件构造里面的Lab3",
      "写了一个针对命令行交互的小程序.不过,在进行测试时遇到了一丢丢小麻烦",
      "即,怎么来对一个对命令行交互的程序进行测试",
      "在<<阿里巴巴Java开发规范>>里面有这样的一句话",
      "我们作为一名系统学习了软件构造的学生,如果仅仅是向大一那样,通过纯手敲的方法,来对一个小软件进行测试,那就有点low了.于是,我们采用Junit的方法,利用它,进行软件的单元测试",
      "关键:对Java的输入输出进行重定向",
      "首先,我们需要记录下默认的Java输入输出流:然后,我们需要手动设置输出流,即,将程序的输出,从屏幕转到我们想要的地方",
      "同时,我们还需要手动设置输入流,将键盘输入转成从文件里面进行输入",
      "然后,就可以开始进行跑我们的程序了",
      "跑完以后,我们直接取出标准输出,转String进行检查",
      "最后,复位标准输入输出",
      "以上就是利用Junit对在命令行程序进行check的步骤,谢谢大家"
    ],
    "codes": [
      "【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执\n行过程必须完全自动化才有意义。\n\n输出结果需要人工检查的测试不是一个好的单元测试。单元 测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。\n\n【强制】单元测试是可以重复执行的，不能受到外界环境的影响。\n\n说明:单元测试通常会被放到持续集成中，每次有代码check in时单元测试都会被执行。\n\n如 果单测对外部环境(网络、服务、中间件等)有依赖，容易导致持续集成机制的不可用。\n\n正例:为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring 这样的 DI 框架注入一个本地(内存)实现或者 Mock 实现。\n",
      "\t\t// 记录标准流\n\t\tfinal InputStream oInputStream = System.in;\n\t\tfinal PrintStream oOutputStream = System.out;\n\n",
      "\t\t// 设置输出流\n\t\tfinal ByteArrayOutputStream BoutputStream = new ByteArrayOutputStream();\n\t\tSystem.setOut(new PrintStream(BoutputStream));\n\t\tFileInputStream FinputStream = null;\n",
      "\t\ttry {\n\t\t\tFinputStream = new FileInputStream(\"test/CMD/P0.txt\");\n\t\t\tSystem.setIn(FinputStream);\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n",
      "\t\t//这是我的命令行应用程序\n\t\tProcessScheduleAppCmd PSAC = new ProcessScheduleAppCmd();\n\t\tPSAC.run();\n",
      " \t\tString cmdOutsString=BoutputStream.toString();\n\t\tassertEquals(true,cmdOutsString.contains(\"进行随机模拟\"));\n\t\t//...这里面省略无数assertequal语句\n\t\tassertEquals(true, cmdOutsString.contains(\"是否已经结束：true\"));\n",
      "\t\t\n\t\tSystem.setIn(oInputStream);\n\t\tSystem.setOut(oOutputStream);\n\n"
    ],
    "date": "2021-06-12",
    "text": "笔者最近完成了窝工软件构造里面的Lab3\n写了一个针对命令行交互的小程序.\n不过,在进行测试时遇到了一丢丢小麻烦\n即,怎么来对一个对命令行交互的程序进行测试\n在<<阿里巴巴Java开发规范>>里面有这样的一句话\n我们作为一名系统学习了软件构造的学生,如果仅仅是向大一那样,通过纯手敲的方法,来对一个小软件进行测试,那就有点low了.\n于是,我们采用Junit的方法,利用它,进行软件的单元测试\n关键:对Java的输入输出进行重定向\n首先,我们需要记录下默认的Java输入输出流:\n然后,我们需要手动设置输出流,即,将程序的输出,从屏幕转到我们想要的地方\n同时,我们还需要手动设置输入流,将键盘输入转成从文件里面进行输入\n然后,就可以开始进行跑我们的程序了\n跑完以后,我们直接取出标准输出,转String进行检查\n最后,复位标准输入输出\n以上就是利用Junit对在命令行程序进行check的步骤,谢谢大家\n"
  },
  {
    "head": "数学建模1-评价类问题",
    "paragraphs": [
      "数学建模-评价类问题",
      "问题的引入：",
      "假设小明同学高考结束，准备选择EE或者是CS里面的一个，现在，我们需要帮助小明做出符合数学的抉择。",
      "（其实是一类问题，问题本身是非数学的，再比如，你母亲和女友同时落水，你准备救哪一个，但是，我们需要根据我们所学的数学知识，做出抉择）",
      "那么我们就打分吧。",
      "一个显然的想法：确定好打分指标，然后，对每个方案进行打分。",
      "但是，问题在于，怎么打分？毕竟，打分这事，有点主观性过强。",
      "所以，接下来，介绍的，评价类算法，就是告诉我们，怎么打分。",
      "首先上场的是层次分析法",
      "简单的介绍：",
      "（此处引用他人的博客。。）",
      "说白了，就是几步，我画了个流程图来概括其大致思路。",
      "根据问题，确定目标层",
      "根据文献（自己的推测？）确定准则层与决策层（个数小于15）",
      "然后两两确定，写出判断矩阵，再进行一致性检验，",
      "在一致性检验通过的时候，求解权重",
      "（P.S这种方法，也可以进行判断比较并确定其它评价方法里面准则的权重）（套娃？？）",
      "然后上场的，是TOPSIS方法（优劣解距离法）",
      "上种方法评价的决策层不能太多，否则，差异太大",
      "如果我们已经得到了数据，那么，层次分析法就显得太主观了，引入数据来分析，更加客观。",
      "此处再次引用他人博客",
      "基本的思路",
      "对指标进行分类：",
      "极大（小）型指标：越大（小）越好",
      "中间（区间）型：居中（某一个区间）就好",
      "然后极小型（中间型）转极大型",
      "标准化消去指标间的量纲",
      "最后进行归一化：",
      "（抽象的来看，就是导出评价对象在评价域这个向量空间里面，与我们最大（小）值向量的距离，并以此来进行排序）",
      "导出与最大/最小",
      "所以，",
      "方法的核心就是：对我们手中所得到的数据进行处理，找出指标，处理掉指标的量纲影响，确定一个评价空间，在这个向量空间里面，找出每一个对象距离最大值与最小值的距离。",
      "二话不说，上流程图：",
      "在TOPSIS方法里面，每个指标对应的权重，是可以根据层次分析法进行赋值的，不过，这种方法主观性太强了。还有一种方法，也可以对指标进行赋值",
      "熵权法",
      "指标的变异程度越小，反应的信息量越小，对应的权值应该越低",
      "而概率越大的事件，其信息量应该越少，概率越小，信息量应该越多。",
      "基本原理：引用他人博客",
      "基本的流程:",
      "1）数据处理，归一化",
      "2）计算信息熵",
      "3）计算权重",
      "换一种角度，还有方法进行评价-模糊综合评价",
      "其实，所有的评价类问题的方法，抽象的来看，说的都是一个东西。",
      "定义：",
      "因素集：所研究的问题，可以从多个角度看，因素集，即问题空间中的一组基。",
      "评语集：将问题空间里面的元素经映射后，对应的结果（值域）。",
      "权重集：各因素集元素在某一次至评语集映射中所占权重。",
      "我们在评价类问题里面需要解决的要做的：把论域中的对象对应至评语集中指定的评语。不同的评价类方法，就是不同的映射。将论域V里面的问题，映射到我们的评价域U。",
      "上面的比较抽象，其实简单的来说，就是对某一特定对象给出一个评价。或者，将把评价换成方案。",
      "那么，回到原点，什么是模糊综合评价？",
      "简单的来说，就是引入模糊数学里面的概念，通过",
      "隶属函数（模糊）/模糊统计法",
      "，确定好各因素在评语集里面所占的份量，最后，赋予权重，找最大的权值的评语作为我们的结论。",
      "详细的解说：",
      "别人的博客",
      "我对上述过程画了一张图来帮助理解。"
    ],
    "sentences": [
      "数学建模-评价类问题",
      "问题的引入：假设小明同学高考结束",
      "准备选择EE或者是CS里面的一个",
      "现在",
      "我们需要帮助小明做出符合数学的抉择",
      "（其实是一类问题",
      "问题本身是非数学的",
      "再比如",
      "你母亲和女友同时落水",
      "你准备救哪一个",
      "但是",
      "我们需要根据我们所学的数学知识",
      "做出抉择）",
      "那么我们就打分吧",
      "一个显然的想法：确定好打分指标，然后，对每个方案进行打分",
      "但是，问题在于，怎么打分？毕竟，打分这事，有点主观性过强",
      "所以，接下来，介绍的，评价类算法，就是告诉我们，怎么打分",
      "首先上场的是层次分析法",
      "简单的介绍：（此处引用他人的博客",
      "）",
      "说白了，就是几步，我画了个流程图来概括其大致思路",
      "根据问题，确定目标层",
      "根据文献（自己的推测？）确定准则层与决策层（个数小于15）",
      "然后两两确定",
      "写出判断矩阵",
      "再进行一致性检验",
      "在一致性检验通过的时候",
      "求解权重",
      "（P.S这种方法",
      "也可以进行判断比较并确定其它评价方法里面准则的权重）（套娃？？）",
      "然后上场的，是TOPSIS方法（优劣解距离法）",
      "上种方法评价的决策层不能太多，否则，差异太大",
      "如果我们已经得到了数据",
      "那么",
      "层次分析法就显得太主观了",
      "引入数据来分析",
      "更加客观",
      "此处再次引用他人博客",
      "基本的思路",
      "对指标进行分类：极大（小）型指标：越大（小）越好",
      "中间（区间）型：居中（某一个区间）就好",
      "然后极小型（中间型）转极大型",
      "标准化消去指标间的量纲",
      "最后进行归一化：（抽象的来看",
      "就是导出评价对象在评价域这个向量空间里面",
      "与我们最大（小）值向量的距离",
      "并以此来进行排序）",
      "导出与最大/最小",
      "所以",
      "方法的核心就是：对我们手中所得到的数据进行处理",
      "找出指标",
      "处理掉指标的量纲影响",
      "确定一个评价空间",
      "在这个向量空间里面",
      "找出每一个对象距离最大值与最小值的距离",
      "二话不说",
      "上流程图：在TOPSIS方法里面",
      "每个指标对应的权重",
      "是可以根据层次分析法进行赋值的",
      "不过",
      "这种方法主观性太强了",
      "还有一种方法，也可以对指标进行赋值",
      "熵权法",
      "指标的变异程度越小，反应的信息量越小，对应的权值应该越低",
      "而概率越大的事件，其信息量应该越少，概率越小，信息量应该越多",
      "基本原理：引用他人博客",
      "基本的流程:1）数据处理，归一化",
      "2）计算信息熵",
      "3）计算权重",
      "换一种角度，还有方法进行评价-模糊综合评价",
      "其实，所有的评价类问题的方法，抽象的来看，说的都是一个东西",
      "定义：因素集：所研究的问题",
      "可以从多个角度看",
      "因素集",
      "即问题空间中的一组基",
      "评语集：将问题空间里面的元素经映射后，对应的结果（值域）",
      "权重集：各因素集元素在某一次至评语集映射中所占权重",
      "我们在评价类问题里面需要解决的要做的：把论域中的对象对应至评语集中指定的评语",
      "不同的评价类方法，就是不同的映射",
      "将论域V里面的问题，映射到我们的评价域U",
      "上面的比较抽象",
      "其实简单的来说",
      "就是对某一特定对象给出一个评价",
      "或者，将把评价换成方案",
      "那么，回到原点，什么是模糊综合评价？",
      "简单的来说，就是引入模糊数学里面的概念，通过",
      "隶属函数（模糊）/模糊统计法",
      "",
      "确定好各因素在评语集里面所占的份量",
      "最后",
      "赋予权重",
      "找最大的权值的评语作为我们的结论",
      "详细的解说：别人的博客",
      "我对上述过程画了一张图来帮助理解"
    ],
    "codes": [],
    "date": "2020-08-10",
    "text": "数学建模-评价类问题\n问题的引入：\n假设小明同学高考结束，准备选择EE或者是CS里面的一个，现在，我们需要帮助小明做出符合数学的抉择。\n（其实是一类问题，问题本身是非数学的，再比如，你母亲和女友同时落水，你准备救哪一个，但是，我们需要根据我们所学的数学知识，做出抉择）\n那么我们就打分吧。\n一个显然的想法：确定好打分指标，然后，对每个方案进行打分。\n但是，问题在于，怎么打分？毕竟，打分这事，有点主观性过强。\n所以，接下来，介绍的，评价类算法，就是告诉我们，怎么打分。\n首先上场的是层次分析法\n简单的介绍：\n（此处引用他人的博客。。）\n说白了，就是几步，我画了个流程图来概括其大致思路。\n根据问题，确定目标层\n根据文献（自己的推测？）确定准则层与决策层（个数小于15）\n然后两两确定，写出判断矩阵，再进行一致性检验，\n在一致性检验通过的时候，求解权重\n（P.S这种方法，也可以进行判断比较并确定其它评价方法里面准则的权重）（套娃？？）\n然后上场的，是TOPSIS方法（优劣解距离法）\n上种方法评价的决策层不能太多，否则，差异太大\n如果我们已经得到了数据，那么，层次分析法就显得太主观了，引入数据来分析，更加客观。\n此处再次引用他人博客\n基本的思路\n对指标进行分类：\n极大（小）型指标：越大（小）越好\n中间（区间）型：居中（某一个区间）就好\n然后极小型（中间型）转极大型\n标准化消去指标间的量纲\n最后进行归一化：\n（抽象的来看，就是导出评价对象在评价域这个向量空间里面，与我们最大（小）值向量的距离，并以此来进行排序）\n导出与最大/最小\n所以，\n方法的核心就是：对我们手中所得到的数据进行处理，找出指标，处理掉指标的量纲影响，确定一个评价空间，在这个向量空间里面，找出每一个对象距离最大值与最小值的距离。\n二话不说，上流程图：\n在TOPSIS方法里面，每个指标对应的权重，是可以根据层次分析法进行赋值的，不过，这种方法主观性太强了。还有一种方法，也可以对指标进行赋值\n熵权法\n指标的变异程度越小，反应的信息量越小，对应的权值应该越低\n而概率越大的事件，其信息量应该越少，概率越小，信息量应该越多。\n基本原理：引用他人博客\n基本的流程:\n1）数据处理，归一化\n2）计算信息熵\n3）计算权重\n换一种角度，还有方法进行评价-模糊综合评价\n其实，所有的评价类问题的方法，抽象的来看，说的都是一个东西。\n定义：\n因素集：所研究的问题，可以从多个角度看，因素集，即问题空间中的一组基。\n评语集：将问题空间里面的元素经映射后，对应的结果（值域）。\n权重集：各因素集元素在某一次至评语集映射中所占权重。\n我们在评价类问题里面需要解决的要做的：把论域中的对象对应至评语集中指定的评语。不同的评价类方法，就是不同的映射。将论域V里面的问题，映射到我们的评价域U。\n上面的比较抽象，其实简单的来说，就是对某一特定对象给出一个评价。或者，将把评价换成方案。\n那么，回到原点，什么是模糊综合评价？\n简单的来说，就是引入模糊数学里面的概念，通过\n隶属函数（模糊）/模糊统计法\n，确定好各因素在评语集里面所占的份量，最后，赋予权重，找最大的权值的评语作为我们的结论。\n详细的解说：\n别人的博客\n我对上述过程画了一张图来帮助理解。\n"
  },
  {
    "head": "五种基于委托(delegation)设计模式的场景+代码分析",
    "paragraphs": [
      "笔者在复习哈工大软件构造的设计模式时,对最基本的五种设计模式,展开了探讨",
      "当然,借着编程操作的机会,也练习了一下正则匹配,防御式编程参数检查等一些软构课上教的",
      "(要考的)",
      "下面是五种基本的设计模式试用场景",
      "工厂方法",
      "装饰器模式",
      "适配器模式",
      "迭代器模式",
      "访问者模式",
      "工厂方法",
      "基本介绍",
      "通过工厂类,将客户端与client进行隔离开",
      "场景:",
      "假如我们要为一个游戏写NPC,考虑到NPC以后的种类会很多,所以,应该建议采用工厂方法而不是new,对NPC进行创建",
      "装饰器模式",
      "场景:",
      "假如我们的游戏需要对NPC进行包装",
      "穿上了防弹衣可以防弹",
      "穿上雨衣可以防雨",
      "穿上了翅膀可以飞",
      "客户需要构造穿着雨衣的鸟人和穿着防弹衣的鸟人",
      "那么可以这样构造",
      "输出:",
      "具体的UML类图",
      "适配器模式",
      ": 假如我们由一个算法的黑盒子,只能够接受浮点数据为输入,以整形数为输出.而我们现在向用户提供的接口是字符串为输入,字符串为输出.这个时候,需要我们利用适配器,对类进行适配.",
      "注意:",
      "我们需要对前置条件的参数进行检查,同时,也需要检查后置条件是否满足.",
      "采取的思路",
      ":前面的前置,利用正则进行检查,抛出UncheckedException.后面的用assert 来进行判定,判定后置条件是否满足.",
      ":一个合法的浮点数,长什么样子?",
      "不是0003.14这样子的,这样子太丑了",
      "可以没有小数点,但是如果有小数点,我们需要对后面的数位进行判定",
      "我们写正则的时候,需要体现对思考的check",
      "输出:",
      "迭代器模式",
      "场景:",
      "假如我们向用户提供一个List的抽象,用户可以从头进行顺序遍历到尾部.",
      "List需要满足其类型是Number的子类",
      "结果:",
      "访问者模式",
      "场景:",
      "假如我们已经写好了一个数组的类.考虑到未来的扩展,我们留存了一个accept的方法来允许visitor对其进行访问",
      "现在目标逐渐明确,",
      "1.用一个visitor来进行访问数组,求平均值",
      "2.用一个visitor来访问数组,求总和",
      "3,用一个visitor来访问数组,求向量的模长",
      "默认数组是int类型的",
      "数组接口的实现代码",
      "三种访问者的实现代码:",
      "主函数",
      "输出:",
      "UML图:",
      "可以发现,访问者与被访问者互相依赖",
      "根据王忠杰老师所言:这五种设计模式,均是对委托(两颗继承树)的变形与拓展.",
      "在动手操作之后,发现老师说的,还真是蛮有道理的,脑海里对基本的设计模式的UML图有一个基本的映像,动手操作起来,还真是不难的.",
      "以上便是这篇博客的全部内容.",
      "谢谢."
    ],
    "sentences": [
      "笔者在复习哈工大软件构造的设计模式时,对最基本的五种设计模式,展开了探讨",
      "当然,借着编程操作的机会,也练习了一下正则匹配,防御式编程参数检查等一些软构课上教的",
      "(要考的)",
      "下面是五种基本的设计模式试用场景",
      "工厂方法",
      "装饰器模式",
      "适配器模式",
      "迭代器模式",
      "访问者模式",
      "工厂方法",
      "基本介绍",
      "通过工厂类,将客户端与client进行隔离开",
      "场景:假如我们要为一个游戏写NPC,考虑到NPC以后的种类会很多,所以,应该建议采用工厂方法而不是new,对NPC进行创建",
      "装饰器模式",
      "场景:假如我们的游戏需要对NPC进行包装",
      "穿上了防弹衣可以防弹",
      "穿上雨衣可以防雨",
      "穿上了翅膀可以飞",
      "客户需要构造穿着雨衣的鸟人和穿着防弹衣的鸟人",
      "那么可以这样构造",
      "输出:具体的UML类图",
      "适配器模式",
      ": 假如我们由一个算法的黑盒子,只能够接受浮点数据为输入,以整形数为输出.而我们现在向用户提供的接口是字符串为输入,字符串为输出.这个时候,需要我们利用适配器,对类进行适配.注意:我们需要对前置条件的参数进行检查,同时,也需要检查后置条件是否满足.采取的思路",
      ":前面的前置,利用正则进行检查,抛出UncheckedException.后面的用assert 来进行判定,判定后置条件是否满足.:一个合法的浮点数,长什么样子?",
      "不是0003.14这样子的,这样子太丑了",
      "可以没有小数点,但是如果有小数点,我们需要对后面的数位进行判定",
      "我们写正则的时候,需要体现对思考的check",
      "输出:迭代器模式",
      "场景:假如我们向用户提供一个List的抽象,用户可以从头进行顺序遍历到尾部.List需要满足其类型是Number的子类",
      "结果:访问者模式",
      "场景:假如我们已经写好了一个数组的类.考虑到未来的扩展,我们留存了一个accept的方法来允许visitor对其进行访问",
      "现在目标逐渐明确,1.用一个visitor来进行访问数组,求平均值",
      "2.用一个visitor来访问数组,求总和",
      "3,用一个visitor来访问数组,求向量的模长",
      "默认数组是int类型的",
      "数组接口的实现代码",
      "三种访问者的实现代码:主函数",
      "输出:UML图:可以发现,访问者与被访问者互相依赖",
      "根据王忠杰老师所言:这五种设计模式,均是对委托(两颗继承树)的变形与拓展.在动手操作之后,发现老师说的,还真是蛮有道理的,脑海里对基本的设计模式的UML图有一个基本的映像,动手操作起来,还真是不难的.以上便是这篇博客的全部内容.谢谢."
    ],
    "codes": [
      "//main\npublic class CM {\n\tpublic static void main(String []args) {\n\t\tPerson P=PersonFactory.createPeron(\"M\");//由静态工厂方法调用\n\t\tSystem.out.print(P.getName());\n\t\t\n\t}\t\n}\n//NPC\npublic class Person {\n\tprivate final String name;\n\tpublic Person(String N) {\n\t\tthis.name=N;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n}\n//NPC的工厂方法:\npackage Factory;\n\npublic class PersonFactory {\n\t//普通工厂\n\tpublic Person CreatPerson(String n) {\n\t\treturn new Person(n);\n\t}\n\t//静态工厂方法\n\tpublic static Person createPeron(String n)\n\t{\n\t\treturn new Person(n);\n\t}\n}\n\n\n",
      "//human 的接口\npublic interface Human {\n\t/**\n\t * 进行互动的行为\n\t */\n\tpublic void action();\n}\n//human的实现基类\npublic class ConcreteHuman implements Human{\n\n\t@Override\n\tpublic void action() {\n\t\tSystem.out.println(\"我是Human\");\n\t}\n\t\n}\n\n/**\n * 装饰类基类\n */\npublic class BasicDecorator implements Human {\n\tprivate final Human h0;\n\n\tpublic BasicDecorator(Human h1) {\n\t\tif (h1 == null) {//进行参数的检查\n\t\t\tthrow new NullPointerException();//runTimeException\n\t\t}\n\t\th0 = h1;\n\t}\n\n\t@Override\n\tpublic void action() {\n\t\th0.action();\n\t}\n}\n\n//三种装饰器\npublic class RaincoatHuman extends BasicDecorator {\n\n\tpublic RaincoatHuman(Human h1) {\n\t\tsuper(h1);\n\t}\n\n\t@Override\n\tpublic void action() {\n\t\tSystem.out.println(\"这人穿了雨衣\");\n\t\tsuper.action();\n\t}\n\n}\npublic class FlyableHuman extends BasicDecorator {\n\n\tpublic FlyableHuman(Human h1) {\n\t\tsuper(h1);\n\t}\n\n\t@Override\n\tpublic void action() {\n\t\tSystem.out.println(\"这人长了翅膀可以飞\");\n\t\tsuper.action();\n\t}\n\n}\npublic class BullyProfHuman extends BasicDecorator {\n\n\tpublic BullyProfHuman(Human h1) {\n\t\tsuper(h1);\n\t}\n\n\t@Override\n\tpublic void action() {\n\t\tSystem.out.println(\"这人刀枪不入\");\n\t\tsuper.action();\n\t}\n}\n//main函数\n\tpublic static void main(String[] args) {\n\t\t// 穿着雨衣的鸟人\n\t\tHuman H0 = new RaincoatHuman(new FlyableHuman(new ConcreteHuman()));\n\t\tH0.action();\n\t\t// 穿着防弹衣的鸟人\n\t\tHuman H1 = new BullyProfHuman(new FlyableHuman(new ConcreteHuman()));\n\t\tH1.action();\n\n\t}\n\n",
      "//假如我们由一个黑盒:\n/**\n * 年份久远的黑盒,可以work\n */\npublic class OldBlackBox {\n\tpublic int getAnswer(double d0) {\n\t\tSystem.out.println(\"计算中...\");\n\t\treturn 888;\n\t}\n}\n//我们向用户承诺了一个API接口\npublic interface APIUserInterface {\n\t/**\n\t * 我们的API 向用户提供的方法\n\t * \n\t * @param 以小数形式的字符串,必须为合法的小数,如为非0098.xxx格式(大于一的,前方不能含有0)\n\t * @return 字符串形式的整形数888\n\t */\n\tpublic String APIWork(String input);\n}\n//现在我们对这个进行适配\n\npublic class Adapter implements APIUserInterface {\n\n\t@Override\n\tpublic String APIWork(String input) {\n\t\t// 进行检查前置条件是否合法\n\t\tif (!input.matches(\"([1-9][\\\\d]*|[0-9])(\\\\.[\\\\d]+)?\")) //运用正则\n        {\n\t\t\tthrow new IllegalArgumentException(\"输入数据:\" + input + \"不是合法的浮点数\");\n\t\t}\n\t\tSystem.out.println(\"你输入了:\" + input);\n\t\t// Delegate 黑盒进行计算\n\t\tOldBlackBox OBB = new OldBlackBox();\n\t\tDouble d0 = Double.valueOf(input);\n\t\tInteger i = OBB.getAnswer(d0);\n\t\tString RET = i.toString();\n\t\t// 检查后置条件是否合法\n\t\tassert RET.equals(\"888\");\n\t\treturn RET;\n\t}\n}\n\n//用户代码:\n\tpublic static void main(String[] args) {\n\t\tAPIUserInterface APIU = new Adapter();\n\t\tSystem.out.println(APIU.APIWork(\"996\"));\n\t\tSystem.out.println(\"--------------\");\n\t\tSystem.out.println(APIU.APIWork(\"18.47\"));\n\t\tSystem.out.println(\"--------------\");\n\t\tSystem.out.println(APIU.APIWork(\"18..47\"));\n\n\t}\n\n",
      "//直接写了一个数组\n\npublic class UniqueList<L extends Number> implements Iterable {\n\tprivate final List<L> L0;\n\n\tpublic UniqueList() {\n\t\tL0 = new ArrayList<>();\n\t}\n\n\tpublic void add(L ll) {\n\t\tL0.add(ll);\n\t}\n\n\t// 按照王老师的做法,这里可以直接在类里面写迭代器,这样,就可以直接访问类里面的信息\n\tprivate class UniqueIterator<L> implements Iterator<Object> {\n\t\tprivate final List<L> myL = new ArrayList(L0);\n\n\t\tprivate int current = 0;\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn current < myL.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new ArrayIndexOutOfBoundsException(\"你访问第\" + (1 + current) + \"个(1~n)元素,导致数组越界\");\n\t\t\t}\n\t\t\tL lo = myL.get(current);\n\t\t\tcurrent++;\n\t\t\treturn lo;\n\t\t}\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException(\"删除元素并没有得到支持\");\n\t\t}\n\t}\n\t@Override\n\tpublic Iterator<L> iterator() {\n\t\treturn new UniqueIterator();\n\t}\n\n}\n\n//客户端\npublic static void main(String[] args) {\n\t\tUniqueList<Integer> UL = new UniqueList<Integer>();\n\t\tUL.add(5);\n\t\tUL.add(4);\n\t\tUL.add(3);\n\t\tUL.add(2);\n\t\tUL.add(1);\n\t\tIterator<Integer> uli = UL.iterator();\n\t\twhile (uli.hasNext()) {\n\t\t\tSystem.out.println(uli.next());\n\t\t}\n\t\tuli.next();//试图访问越界\n    \n",
      "//我们的数组接口\npublic interface ListInterface0 extends Iterable {\n\n\t/**\n\t * 获取idx位置的元素\n\t * \n\t * @param idx 合法的位置\n\t * @return idx位置的元素\n\t */\n\tpublic int getElement(int idx);\n\n\t/**\n\t * 添加元素\n\t * \n\t * @param val 添加的元素\n\t */\n\tpublic void addElement(int val);\n\n\t/**\n\t * 接受访问者v0的扩展\n\t * \n\t * @param v0 访问者\n\t */\n\tpublic void accept(Visitor v0);\n}\n\n//我们的访问者接口\npublic interface Visitor {\n\t/**\n\t * 对列表进行访问\n\t * \n\t * @param L0\n\t */\n\tpublic void visit(ListInterface0 L0);\n}\n",
      "public class List2 implements ListInterface0 {\n\tprivate final List<Integer> L0 = new ArrayList<>();\n\n\t@Override\n\tpublic int getElement(int idx) {\n\t\treturn L0.get(idx);\n\t}\n\n\t@Override\n\tpublic void addElement(int val) {\n\t\tL0.add(val);\n\n\t}\n\n\t// 按照王老师的做法,这里可以直接在类里面写迭代器,这样,就可以直接访问类里面的信息\n\tprivate class UniqueIterator<L> implements Iterator<Object> {\n\t\tprivate final List<L> myL = new ArrayList(L0);\n\n\t\tprivate int current = 0;\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn current < myL.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new ArrayIndexOutOfBoundsException(\"你访问第\" + (1 + current) + \"个(1~n)元素,导致数组越界\");\n\t\t\t}\n\t\t\tL lo = myL.get(current);\n\t\t\tcurrent++;\n\t\t\treturn lo;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException(\"删除元素并没有得到支持\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic Iterator<Integer> iterator() {\n\t\treturn new UniqueIterator();\n\t}\n\n\t@Override\n\tpublic void accept(Visitor v0) {\n\t\tv0.visit(this);\n\t}\n\n}\n\n",
      "//平均值访问者\npublic class MeanVisitor implements Visitor {\n\n\t@Override\n\tpublic void visit(ListInterface0 L0) {\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\tIterator<Integer> ii = L0.iterator();\n\t\twhile (ii.hasNext()) {\n\t\t\tsum += ii.next();\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(\"平均值为:\" + (double) ((double) sum / i));\n\t}\n\n}\n//总和访问者\n\npublic class SumVisitor implements Visitor {\n\n\t@Override\n\tpublic void visit(ListInterface0 L0) {\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\tIterator<Integer> ii = L0.iterator();\n\t\twhile (ii.hasNext()) {\n\t\t\tsum += ii.next();\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(\"总和为:\" + (sum));\n\t}\n\n}\n//向量长度访问者\n\npublic class VecLength implements Visitor {\n\n\t@Override\n\tpublic void visit(ListInterface0 L0) {\n\t\tint sum = 0;\n\t\tIterator<Integer> ii = L0.iterator();\n\t\twhile (ii.hasNext()) {\n\t\t\tint t = ii.next();\n\t\t\tsum += (t * t);\n\t\t}\n\t\tSystem.out.println(\"向量长度为:\" + (sum));\n\t}\n\n}\n\n\n",
      "public static void main(String[] args) {\n\t\tListInterface0 L2 = new List2();\n\t\tL2.addElement(5);\n\t\tL2.addElement(4);\n\t\tL2.addElement(3);\n\t\tL2.addElement(2);\n\t\tL2.addElement(2);\n\t\tL2.accept(new MeanVisitor());\n\t\tL2.accept(new SumVisitor());\n\t\tL2.accept(new VecLength());\n\t}\n"
    ],
    "date": "2021-07-01",
    "text": "笔者在复习哈工大软件构造的设计模式时,对最基本的五种设计模式,展开了探讨\n当然,借着编程操作的机会,也练习了一下正则匹配,防御式编程参数检查等一些软构课上教的\n(要考的)\n下面是五种基本的设计模式试用场景\n工厂方法\n装饰器模式\n适配器模式\n迭代器模式\n访问者模式\n工厂方法\n基本介绍\n通过工厂类,将客户端与client进行隔离开\n场景:\n假如我们要为一个游戏写NPC,考虑到NPC以后的种类会很多,所以,应该建议采用工厂方法而不是new,对NPC进行创建\n装饰器模式\n场景:\n假如我们的游戏需要对NPC进行包装\n穿上了防弹衣可以防弹\n穿上雨衣可以防雨\n穿上了翅膀可以飞\n客户需要构造穿着雨衣的鸟人和穿着防弹衣的鸟人\n那么可以这样构造\n输出:\n具体的UML类图\n适配器模式\n: 假如我们由一个算法的黑盒子,只能够接受浮点数据为输入,以整形数为输出.而我们现在向用户提供的接口是字符串为输入,字符串为输出.这个时候,需要我们利用适配器,对类进行适配.\n注意:\n我们需要对前置条件的参数进行检查,同时,也需要检查后置条件是否满足.\n采取的思路\n:前面的前置,利用正则进行检查,抛出UncheckedException.后面的用assert 来进行判定,判定后置条件是否满足.\n:一个合法的浮点数,长什么样子?\n不是0003.14这样子的,这样子太丑了\n可以没有小数点,但是如果有小数点,我们需要对后面的数位进行判定\n我们写正则的时候,需要体现对思考的check\n输出:\n迭代器模式\n场景:\n假如我们向用户提供一个List的抽象,用户可以从头进行顺序遍历到尾部.\nList需要满足其类型是Number的子类\n结果:\n访问者模式\n场景:\n假如我们已经写好了一个数组的类.考虑到未来的扩展,我们留存了一个accept的方法来允许visitor对其进行访问\n现在目标逐渐明确,\n1.用一个visitor来进行访问数组,求平均值\n2.用一个visitor来访问数组,求总和\n3,用一个visitor来访问数组,求向量的模长\n默认数组是int类型的\n数组接口的实现代码\n三种访问者的实现代码:\n主函数\n输出:\nUML图:\n可以发现,访问者与被访问者互相依赖\n根据王忠杰老师所言:这五种设计模式,均是对委托(两颗继承树)的变形与拓展.\n在动手操作之后,发现老师说的,还真是蛮有道理的,脑海里对基本的设计模式的UML图有一个基本的映像,动手操作起来,还真是不难的.\n以上便是这篇博客的全部内容.\n谢谢.\n"
  },
  {
    "head": "一篇通俗易懂的ADT介绍",
    "paragraphs": [
      "最近笔者通过哈工大的软件构造课程,学习了抽象数据类型.",
      "我们,将通过打比方的形式,通俗易懂的给大家讲明白ADT是谁,为什么要有这个东西,以及,怎么构建它",
      "ADT:抽象数据类型",
      "定义:抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。",
      "按照MIT的说法,ADT可以用下面的这幅图来进行描述:",
      "直观的看,ADT就是一道墙,将内在的表示与外部的使用进行隔离这种隔离,通过接口进行的间接访问,降低了代码块与块之间的耦合性.",
      "下面的两个比喻,形象生动的说明了ADT是干什么的,为什么这么重要:",
      "就像盖房子,我们写的软件代码,java里面一个个的Class,就像很多的***普通的砖头***,我们并不需要他们每一个都那么的独领风骚,我们需要每一块砖头都长得差不多,标准一致,这样可以进行将砖头进行千百次的堆砌.同时,我们需要一块砖头如果觉得它存在质量问题,我们可以马上用另一块相似的砖头进行代替.",
      "就像军舰里面的***水密隔舱***,通过一层一层的将船与外面的大海进行隔离,那么如果一侧因为中弹而进水,将防水门一关,进水将不会影响到军舰的其余部分.",
      "为了能够造出更规则统一的砖头(水隔舱),无数计算机领域的巨佬,研究出ADT这样的指导思想,帮助外面更好的,造出统一而又安全的砖头.",
      "可变与不可变数据类型",
      "还是使用砖头来作比方:",
      "如果我们想要自己用砖头搭建起来的房子是可以平稳存在的,那么,我们就首先得要求这个砖头,它是稳定的.",
      "不可变数据类型就像是一块死砖头,它不会因为外界的操作而改变自己的属性,可以说这个砖头,它是死的.我们就可以依靠这个砖头来作房子的地基.从而使房子四平八稳.",
      "比如说,上图的字符串String,就是",
      "不可变",
      "的,它如果对其进行操作,会直接返回新的一个对象",
      "那么,如果我们的代码里面用了可变的数据类型,它会带来什么后果呢?",
      "直接给外界你内部的属性的指针,让外界直接对内部属性进行修改.导致一些很阴间的bug.",
      "比如:神不知鬼不觉的,数据结构内部属性的值一下子就变了…",
      "所以,正如大厦的地基必须要用混凝土和坚实的砖石来打,程序内部所依靠的数据类型,最好是采用不可变的数据类型",
      "Spec 规约",
      "假如我们是来给别人家房子的施工队,在出发之前,一般都是要和雇主甲方爸爸签一个文书的,这个就是规约",
      "Spec",
      "这个spec,它通过规定双方的责任,也就是产品问题,找谁说理去.",
      "细分为两大类:",
      "前置条件:",
      "如果产品坏了,这个责任在用户.",
      "后置条件:",
      "如果产品坏了,这个责任在施工队.",
      "在我们写Java程序时,其实,也有这样的一个spec要去完成",
      "它长这样:",
      "不难发现里面的前置与后置可以大致分下:",
      "它就像一个防火墙,隔绝开了用户与程序内部的表示.",
      "换一种视角 数据->操作",
      "如果我们对之前学的数据结构与算法换一种视角来看,我们的数据结构其实可以被一组操作进行刻画.",
      "比如说,以我手里的茶杯为例",
      "它作为一名普普通通的茶杯,它可以用以下操作来刻画",
      "我们作为21世纪的消费者,是不需要了解这个茶杯它是用硅酸盐组成的.然后里面添加了什么样子的化学物质来进行塑性等待的细节.我们使用的,只是它给我们的",
      "两个方法:喝茶,倒茶.",
      "ADT也一样,我们给外界的",
      "是一组操作,而非内部的表示.",
      "四大er,四种方法",
      "具体来说,这些操作可以细分为四大方法:",
      "以杯具的一生为例:",
      "构造器 : 凭空直接给你造出一个茶杯",
      "生产器 : 放入一个白色的茶杯,与一些颜料,给你返回一个黑色的茶杯",
      "观察器 : 看下茶杯是否为空的,里面的茶叶是什么品种的.",
      "变值器 : 放入一个空茶杯,返回一个打满了茶水的茶杯.",
      "来一点数学: 抽象函数AbstractFunction",
      "我们上面说了这么多,其实可以用一个简单的数学映射加以描述",
      "AF(内在表示) ==> 抽象值",
      "程序员需要利用号内在的表示值,同时编写程序,来进行映射,向外界提供观测,修改抽象值的接口.",
      "这便是抽象.",
      "通过抽象,隐藏底层复杂的实现细节,将间接,可靠一致的抽象操作提供给外界,从而达到降低系统整体的耦合度的效果.",
      "底层的实现细节就是R空间.而用户关注的空间,或者说,我们给用户呈现的空间,就是A空间,即抽象空间.",
      "下面就是一个例子,通过抽象函数,我们将字符串映射到了集合空间A里面.",
      "左边的R,是Representation,即数据表示.这个,便如我们施工队的比方,是我们房子下面的地基.",
      "这个地基,必须要稳,否则房子本身就是不稳定的,有害于人民群众的财产安全.",
      "所以,我们作为ADT的编写者,有责任去做点事情,来确保这个房子是稳定的.",
      "体现为:",
      "RI 表示不变量",
      "还是以集合为例,我们用按顺序排列的字母来队这个集合进行表示,所有串里面的字符排列,必须是升序的.",
      "这个升序,就是RI,它对表示空间进行了划分,将我们用到的合法的值,映射为true,其余为false",
      "用函数的角度来说",
      "RI(表示)==>{true,false}",
      "我们还可以在代码里面对这个进行检查,因为只要我们的表示什么时候被RI给映射到了false,那么就意味着,我们的代码出bug了…",
      "上述内容便是ADT的一些介绍,谢谢大家."
    ],
    "sentences": [
      "最近笔者通过哈工大的软件构造课程,学习了抽象数据类型.我们,将通过打比方的形式,通俗易懂的给大家讲明白ADT是谁,为什么要有这个东西,以及,怎么构建它",
      "ADT:抽象数据类型",
      "定义:抽象数据类型（Abstract Data Type",
      "ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型",
      "抽象数据类型是间接定义的",
      "通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）",
      "按照MIT的说法,ADT可以用下面的这幅图来进行描述:直观的看,ADT就是一道墙,将内在的表示与外部的使用进行隔离这种隔离,通过接口进行的间接访问,降低了代码块与块之间的耦合性.下面的两个比喻,形象生动的说明了ADT是干什么的,为什么这么重要:就像盖房子,我们写的软件代码,java里面一个个的Class,就像很多的***普通的砖头***,我们并不需要他们每一个都那么的独领风骚,我们需要每一块砖头都长得差不多,标准一致,这样可以进行将砖头进行千百次的堆砌.同时,我们需要一块砖头如果觉得它存在质量问题,我们可以马上用另一块相似的砖头进行代替.就像军舰里面的***水密隔舱***,通过一层一层的将船与外面的大海进行隔离,那么如果一侧因为中弹而进水,将防水门一关,进水将不会影响到军舰的其余部分.为了能够造出更规则统一的砖头(水隔舱),无数计算机领域的巨佬,研究出ADT这样的指导思想,帮助外面更好的,造出统一而又安全的砖头.可变与不可变数据类型",
      "还是使用砖头来作比方:如果我们想要自己用砖头搭建起来的房子是可以平稳存在的,那么,我们就首先得要求这个砖头,它是稳定的.不可变数据类型就像是一块死砖头,它不会因为外界的操作而改变自己的属性,可以说这个砖头,它是死的.我们就可以依靠这个砖头来作房子的地基.从而使房子四平八稳.比如说,上图的字符串String,就是",
      "不可变",
      "的,它如果对其进行操作,会直接返回新的一个对象",
      "那么,如果我们的代码里面用了可变的数据类型,它会带来什么后果呢?",
      "直接给外界你内部的属性的指针,让外界直接对内部属性进行修改.导致一些很阴间的bug.比如:神不知鬼不觉的,数据结构内部属性的值一下子就变了…",
      "所以,正如大厦的地基必须要用混凝土和坚实的砖石来打,程序内部所依靠的数据类型,最好是采用不可变的数据类型",
      "Spec 规约",
      "假如我们是来给别人家房子的施工队,在出发之前,一般都是要和雇主甲方爸爸签一个文书的,这个就是规约",
      "Spec",
      "这个spec,它通过规定双方的责任,也就是产品问题,找谁说理去.细分为两大类:前置条件:如果产品坏了,这个责任在用户.后置条件:如果产品坏了,这个责任在施工队.在我们写Java程序时,其实,也有这样的一个spec要去完成",
      "它长这样:不难发现里面的前置与后置可以大致分下:它就像一个防火墙,隔绝开了用户与程序内部的表示.换一种视角 数据->操作",
      "如果我们对之前学的数据结构与算法换一种视角来看,我们的数据结构其实可以被一组操作进行刻画.比如说,以我手里的茶杯为例",
      "它作为一名普普通通的茶杯,它可以用以下操作来刻画",
      "我们作为21世纪的消费者,是不需要了解这个茶杯它是用硅酸盐组成的.然后里面添加了什么样子的化学物质来进行塑性等待的细节.我们使用的,只是它给我们的",
      "两个方法:喝茶,倒茶.ADT也一样,我们给外界的",
      "是一组操作,而非内部的表示.四大er,四种方法",
      "具体来说,这些操作可以细分为四大方法:以杯具的一生为例:构造器 : 凭空直接给你造出一个茶杯",
      "生产器 : 放入一个白色的茶杯,与一些颜料,给你返回一个黑色的茶杯",
      "观察器 : 看下茶杯是否为空的,里面的茶叶是什么品种的.变值器 : 放入一个空茶杯,返回一个打满了茶水的茶杯.来一点数学: 抽象函数AbstractFunction",
      "我们上面说了这么多,其实可以用一个简单的数学映射加以描述",
      "AF(内在表示) ==> 抽象值",
      "程序员需要利用号内在的表示值,同时编写程序,来进行映射,向外界提供观测,修改抽象值的接口.这便是抽象.通过抽象,隐藏底层复杂的实现细节,将间接,可靠一致的抽象操作提供给外界,从而达到降低系统整体的耦合度的效果.底层的实现细节就是R空间.而用户关注的空间,或者说,我们给用户呈现的空间,就是A空间,即抽象空间.下面就是一个例子,通过抽象函数,我们将字符串映射到了集合空间A里面.左边的R,是Representation,即数据表示.这个,便如我们施工队的比方,是我们房子下面的地基.这个地基,必须要稳,否则房子本身就是不稳定的,有害于人民群众的财产安全.所以,我们作为ADT的编写者,有责任去做点事情,来确保这个房子是稳定的.体现为:RI 表示不变量",
      "还是以集合为例,我们用按顺序排列的字母来队这个集合进行表示,所有串里面的字符排列,必须是升序的.这个升序,就是RI,它对表示空间进行了划分,将我们用到的合法的值,映射为true,其余为false",
      "用函数的角度来说",
      "RI(表示)==>{true,false}",
      "我们还可以在代码里面对这个进行检查,因为只要我们的表示什么时候被RI给映射到了false,那么就意味着,我们的代码出bug了…",
      "上述内容便是ADT的一些介绍,谢谢大家."
    ],
    "codes": [
      "/**\n * @return the first day of spring this year\n */\npublic static Date startOfSpring() {\n    return askGroundhog();\n}\n********************************************\n// somewhere else in the code...\npublic static void partyPlanning() {\n    Date partyDate = startOfSpring();\n    // ...\n}\n/**\n * @return the first day of spring this year\n */\npublic static Date startOfSpring() {\n    if (groundhogAnswer == null) {\n        groundhogAnswer = askGroundhog();\n    }\n    return groundhogAnswer;\n}\nprivate static Date groundhogAnswer = null;\n**********************************************\n// somewhere else in the code...\npublic static void partyPlanning() {\n    // let's have a party one month after spring starts!\n    Date partyDate = startOfSpring();\n    partyDate.setMonth(partyDate.getMonth() + 1);\n    // ... uh-oh. what just happened?\n}\n\n",
      "/**\n * Find a value in an array.\n * @param arr array to search, requires that val occurs exactly once\n *            in arr\n * @param val value to search for\n * @return index i such that arr[i] = val\n */\nstatic int find(int[] arr, int val)\n",
      "前置条件\n@param arr array to search, requires that val occurs exactly once in arr\n@param val value to search for\nfind(int[] arr, int val)\n后置\nFind a value in an array.\n@return index i such that arr[i] = val\n",
      "class TeaCup{\n\t/**\n\t* 喝茶\n\t*/\n\tpublic Drink(){};\n\t/**\n\t* 倒茶\n\t*/\n\tpublic Fill(Water Tea){};\n}\n"
    ],
    "date": "2021-06-27",
    "text": "最近笔者通过哈工大的软件构造课程,学习了抽象数据类型.\n我们,将通过打比方的形式,通俗易懂的给大家讲明白ADT是谁,为什么要有这个东西,以及,怎么构建它\nADT:抽象数据类型\n定义:抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。\n按照MIT的说法,ADT可以用下面的这幅图来进行描述:\n直观的看,ADT就是一道墙,将内在的表示与外部的使用进行隔离这种隔离,通过接口进行的间接访问,降低了代码块与块之间的耦合性.\n下面的两个比喻,形象生动的说明了ADT是干什么的,为什么这么重要:\n就像盖房子,我们写的软件代码,java里面一个个的Class,就像很多的***普通的砖头***,我们并不需要他们每一个都那么的独领风骚,我们需要每一块砖头都长得差不多,标准一致,这样可以进行将砖头进行千百次的堆砌.同时,我们需要一块砖头如果觉得它存在质量问题,我们可以马上用另一块相似的砖头进行代替.\n就像军舰里面的***水密隔舱***,通过一层一层的将船与外面的大海进行隔离,那么如果一侧因为中弹而进水,将防水门一关,进水将不会影响到军舰的其余部分.\n为了能够造出更规则统一的砖头(水隔舱),无数计算机领域的巨佬,研究出ADT这样的指导思想,帮助外面更好的,造出统一而又安全的砖头.\n可变与不可变数据类型\n还是使用砖头来作比方:\n如果我们想要自己用砖头搭建起来的房子是可以平稳存在的,那么,我们就首先得要求这个砖头,它是稳定的.\n不可变数据类型就像是一块死砖头,它不会因为外界的操作而改变自己的属性,可以说这个砖头,它是死的.我们就可以依靠这个砖头来作房子的地基.从而使房子四平八稳.\n比如说,上图的字符串String,就是\n不可变\n的,它如果对其进行操作,会直接返回新的一个对象\n那么,如果我们的代码里面用了可变的数据类型,它会带来什么后果呢?\n直接给外界你内部的属性的指针,让外界直接对内部属性进行修改.导致一些很阴间的bug.\n比如:神不知鬼不觉的,数据结构内部属性的值一下子就变了…\n所以,正如大厦的地基必须要用混凝土和坚实的砖石来打,程序内部所依靠的数据类型,最好是采用不可变的数据类型\nSpec 规约\n假如我们是来给别人家房子的施工队,在出发之前,一般都是要和雇主甲方爸爸签一个文书的,这个就是规约\nSpec\n这个spec,它通过规定双方的责任,也就是产品问题,找谁说理去.\n细分为两大类:\n前置条件:\n如果产品坏了,这个责任在用户.\n后置条件:\n如果产品坏了,这个责任在施工队.\n在我们写Java程序时,其实,也有这样的一个spec要去完成\n它长这样:\n不难发现里面的前置与后置可以大致分下:\n它就像一个防火墙,隔绝开了用户与程序内部的表示.\n换一种视角 数据->操作\n如果我们对之前学的数据结构与算法换一种视角来看,我们的数据结构其实可以被一组操作进行刻画.\n比如说,以我手里的茶杯为例\n它作为一名普普通通的茶杯,它可以用以下操作来刻画\n我们作为21世纪的消费者,是不需要了解这个茶杯它是用硅酸盐组成的.然后里面添加了什么样子的化学物质来进行塑性等待的细节.我们使用的,只是它给我们的\n两个方法:喝茶,倒茶.\nADT也一样,我们给外界的\n是一组操作,而非内部的表示.\n四大er,四种方法\n具体来说,这些操作可以细分为四大方法:\n以杯具的一生为例:\n构造器 : 凭空直接给你造出一个茶杯\n生产器 : 放入一个白色的茶杯,与一些颜料,给你返回一个黑色的茶杯\n观察器 : 看下茶杯是否为空的,里面的茶叶是什么品种的.\n变值器 : 放入一个空茶杯,返回一个打满了茶水的茶杯.\n来一点数学: 抽象函数AbstractFunction\n我们上面说了这么多,其实可以用一个简单的数学映射加以描述\nAF(内在表示) ==> 抽象值\n程序员需要利用号内在的表示值,同时编写程序,来进行映射,向外界提供观测,修改抽象值的接口.\n这便是抽象.\n通过抽象,隐藏底层复杂的实现细节,将间接,可靠一致的抽象操作提供给外界,从而达到降低系统整体的耦合度的效果.\n底层的实现细节就是R空间.而用户关注的空间,或者说,我们给用户呈现的空间,就是A空间,即抽象空间.\n下面就是一个例子,通过抽象函数,我们将字符串映射到了集合空间A里面.\n左边的R,是Representation,即数据表示.这个,便如我们施工队的比方,是我们房子下面的地基.\n这个地基,必须要稳,否则房子本身就是不稳定的,有害于人民群众的财产安全.\n所以,我们作为ADT的编写者,有责任去做点事情,来确保这个房子是稳定的.\n体现为:\nRI 表示不变量\n还是以集合为例,我们用按顺序排列的字母来队这个集合进行表示,所有串里面的字符排列,必须是升序的.\n这个升序,就是RI,它对表示空间进行了划分,将我们用到的合法的值,映射为true,其余为false\n用函数的角度来说\nRI(表示)==>{true,false}\n我们还可以在代码里面对这个进行检查,因为只要我们的表示什么时候被RI给映射到了false,那么就意味着,我们的代码出bug了…\n上述内容便是ADT的一些介绍,谢谢大家.\n"
  },
  {
    "head": "归并排序-动手操作练习",
    "paragraphs": [
      "归并排序",
      "其实思想不难，体现分治的思想，时间复杂度O(nlogn)",
      "主要是实现起来的细节。",
      "首先是最基础的归并函数",
      "然后是体现递归分治的函数（基准情形：左边下标L，大于等于右下标R时，直接PASS）",
      "最后是函数接口的设计",
      "这里，申请tempa[]数组",
      "体现效率的地方：tempa[]数组只用申请一遍，提高运行效率",
      "实际操作代码见下："
    ],
    "sentences": [
      "归并排序",
      "其实思想不难，体现分治的思想，时间复杂度O(nlogn)",
      "主要是实现起来的细节",
      "首先是最基础的归并函数",
      "然后是体现递归分治的函数（基准情形：左边下标L",
      "大于等于右下标R时",
      "直接PASS）",
      "最后是函数接口的设计",
      "这里，申请tempa[]数组",
      "体现效率的地方：tempa[]数组只用申请一遍，提高运行效率",
      "实际操作代码见下："
    ],
    "codes": [
      "#include <iostream>\nusing namespace std;\n\nvoid mmerge(int L,int R,int Rend,int a[],int tempa[])//传入5个参数，利用相邻归并的特性，计算Lend与元素个数\n{\n    int lend=R-1;\n    int elements=Rend-L+1;\n    int temp=L;\n    while(L<=lend&&R<=Rend)//赋值\n    {\n        if(a[R]<=a[L]){\n\n            tempa[temp++]=a[R++];\n        }\n        else\n        {\n            tempa[temp++]=a[L++];\n        }\n    }\n    while(L<=lend)//1.基本上就是上个循环里面的，可以省时间CV 2.两个while只进行一遍\n    {\n        tempa[temp++]=a[L++];\n    }\n    while(R<=Rend)\n    {\n        tempa[temp++]=a[R++];\n    }\n    for(int i=0;i<elements;i++,Rend--)//利用Rend还没变，从后往前，赋值\n    {\n       a[Rend]=tempa[Rend];\n    }\n}\n\nvoid merge_sort(int L,int R,int a[],int tempa[])\n{\n    int center;\n    if(L<R)//在 L<R 时才需要处理\n    {\n        center=(L+R)/2;\n        merge_sort(L,center,a,tempa);//递归左边\n        merge_sort(center+1,R,a,tempa);//右边\n        mmerge(L,center+1,R,a,tempa);//合并\n    }\n}\n\nvoid merge_init(int a[],int n)\n{\n    int *tempa=new int[n];//如果C，应进行检查是否为空\n    merge_sort(0,n-1,a,tempa);\n}\n\nint main()\n{\n    int i,n;\n    cin>>n;\n    int *a=new int[n];\n    for(i=0;i<n;i++)\n    {\n        cin>>a[i];\n    }\n    merge_init(a,n);\n    for(i=0;i<n-1;i++)\n    {\n        cout<<a[i]<<\" \";\n    }cout<<a[i];\n\n\n}\n\n\n\n\n"
    ],
    "date": "2020-08-10",
    "text": "归并排序\n其实思想不难，体现分治的思想，时间复杂度O(nlogn)\n主要是实现起来的细节。\n首先是最基础的归并函数\n然后是体现递归分治的函数（基准情形：左边下标L，大于等于右下标R时，直接PASS）\n最后是函数接口的设计\n这里，申请tempa[]数组\n体现效率的地方：tempa[]数组只用申请一遍，提高运行效率\n实际操作代码见下：\n"
  },
  {
    "head": "哈工大软件构造-设计模式学习心得",
    "paragraphs": [
      "设计模式",
      "设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。 使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性",
      "一:总纲",
      "按照王老师的体系,23种设计模式,看上去很多,但万变不离其宗.一切设计模式,均是离不开这两张图.",
      "具体来说,就如下两种:",
      "1. 只有继承关系的:",
      "DIP:依赖倒转原则,细节应当依赖于抽象，抽象不应当依赖于细节。",
      "OCP:开闭原则,软件实体应当对扩展开放，对修改关闭.",
      "特点:",
      "只有一颗继承树",
      "在设计模式里面的体现:",
      "模板方法",
      ":比如,我写了一个白盒框架,现在要往里面加东西,我希望用户来进行手动添加,那么,我给用户一个接口,下面的子类型实现是可以进行任意安排的.",
      "2. 继承+委托(delegation)",
      "特点:两颗继承树",
      "通过另一组继承树,对内在的实现进行了隐藏,具体的体现比如说:Factory方法,Adapter方法,装饰器模式,等等.",
      "对于装饰器来说,可以认为这两颗树均是自己,通过自己对自己进行委托,进行功能的附加.",
      "下面,我们来具体的对王老师上课所授的7种设计模式展开具体分析:",
      "二:具体的7种设计模式",
      "2.1 工厂方法:",
      "用户是通过工厂类来得到新的对象,而不是通过new运算符来得到新的对象",
      "正如船舶里面的水隔舱,工厂类对对象的创建与用户进行了隔离.对于用户而言,它是不知道它的要的产品具体叫什么,这个提供产品的事情,已经被工厂所取代.如果我们需要对功能进行修改的话,只需要动工厂的new的对象,客户端的程序实质上,是稳定的.",
      "2.2 适配器模式",
      "考虑下列情形:",
      "假如我们在进行一个机器学习的项目,我们的核心算法,它需要提供一个numpy形式的矩阵,而我们的数据采集器,返回的矩阵,是一个excel文件.",
      "这个时候,我们就需要一个适配器,帮我们干活了",
      "它通过委托与接口,在二者之间建立了如下的桥梁;",
      "2.3 装饰器模式",
      "人靠衣装,在街上走,你会看到有穿T恤的,穿长袖夹克的,有穿背心的各种各样的人.",
      "那么,如果要建立这样的关系的话,我们是可以通过继承来组合,也可以通过建立装饰器来进行委托.",
      "如果是组合的话,问题会越来越麻烦.",
      "设想,假如一开始所有人都穿T恤,那么到后来,秋天了,大家穿长袖的,有可能是里面套了一个背心,也有可能是里面传了一件毛衣,那么我们都用继承来进行处理的话,这个组合树,将会越来越大.问题很大!",
      "这就是",
      "组合爆炸",
      "所以,正确的做法是,让类学会穿衣服.不同的衣服,展现出不同的特性.有不同的功能",
      "为每一个特性构造子类,并通过委派机制,添加到对象上.",
      "基类实现最原始的功能,然后每一个装饰类实现一部分,逐层的去委派实现.",
      "2.4策略模式",
      "考虑如下的场景:",
      "假如我们在写一个文本翻译的APP,用户输入文本,我们对其进行翻译.",
      "我们一开始是采用SVD分解对文本进行词嵌入.后来,竞争对手纷纷采用了BERT来进行词嵌入,效果比我们好很多.那么,我们也想要用BERT来进行,不过由于考虑到以后的扩展,我们决定将词嵌入,放到一个方法类里面去进行.",
      "即这里的策略类.",
      "策略模式:",
      "存在多种算法来处理同一个任务,但client需要根据需要动态切换算法.",
      "我们可以为不同的实现算法构造抽象接口.利用委托,在运行时,动态传入Client倾向的算法类的实例.",
      "其UML图如下;",
      "2.5 模板模式",
      "还是我们的文本翻译APP.",
      "众所周知,NLP文本翻译任务,包含以下几个基本步骤:",
      "文本预处理->文本词嵌入->Seq2Seq的生成",
      "我们可以把这几个步骤抽出来作为模板,子类在继承时,进行实现.",
      "让子类分别实现我们的模板里面的方法,预处理,词嵌入,文本生成.",
      "他们,作事情的步骤时一样的,但具体的方法不同.让共性的步骤在公共实现.差异化的在子类实现.",
      "2.6 迭代器模式",
      "用途:我们给外界用户的往往是一个黑箱,如果用户有想要逛逛的需求的话,我们便要在既维护内在表示的基础上,又满足外界用户的需求.",
      "在Java里面已经提供了下面的接口:",
      "Iterable接口:实现这个的集合对象是可遍历的",
      "Iterator接口:迭代器,实现这个的是可以进行显示/隐式的进行迭代的.",
      "2.7 Visitor模式",
      "简单点说:就是预留扩展点,以便日后的扩展",
      "为我们的对象的特定Visit,运行时进行动态的绑定.操作可以灵活更改的.方便以后操作.",
      "以上就是对于设计模式的一些总结与思考,谢谢."
    ],
    "sentences": [
      "设计模式",
      "设计模式",
      "即Design Patterns",
      "是指在软件设计中",
      "被反复使用的一种代码设计经验",
      " 使用设计模式的目的是为了可重用代码",
      "提高代码的可扩展性和可维护性",
      "一:总纲",
      "按照王老师的体系,23种设计模式,看上去很多,但万变不离其宗.一切设计模式,均是离不开这两张图.具体来说,就如下两种:1. 只有继承关系的:DIP:依赖倒转原则,细节应当依赖于抽象",
      "抽象不应当依赖于细节",
      "OCP:开闭原则,软件实体应当对扩展开放",
      "对修改关闭.特点:只有一颗继承树",
      "在设计模式里面的体现:模板方法",
      ":比如,我写了一个白盒框架,现在要往里面加东西,我希望用户来进行手动添加,那么,我给用户一个接口,下面的子类型实现是可以进行任意安排的.2. 继承+委托(delegation)",
      "特点:两颗继承树",
      "通过另一组继承树,对内在的实现进行了隐藏,具体的体现比如说:Factory方法,Adapter方法,装饰器模式,等等.对于装饰器来说,可以认为这两颗树均是自己,通过自己对自己进行委托,进行功能的附加.下面,我们来具体的对王老师上课所授的7种设计模式展开具体分析:二:具体的7种设计模式",
      "2.1 工厂方法:用户是通过工厂类来得到新的对象,而不是通过new运算符来得到新的对象",
      "正如船舶里面的水隔舱,工厂类对对象的创建与用户进行了隔离.对于用户而言,它是不知道它的要的产品具体叫什么,这个提供产品的事情,已经被工厂所取代.如果我们需要对功能进行修改的话,只需要动工厂的new的对象,客户端的程序实质上,是稳定的.2.2 适配器模式",
      "考虑下列情形:假如我们在进行一个机器学习的项目,我们的核心算法,它需要提供一个numpy形式的矩阵,而我们的数据采集器,返回的矩阵,是一个excel文件.这个时候,我们就需要一个适配器,帮我们干活了",
      "它通过委托与接口,在二者之间建立了如下的桥梁;2.3 装饰器模式",
      "人靠衣装,在街上走,你会看到有穿T恤的,穿长袖夹克的,有穿背心的各种各样的人.那么,如果要建立这样的关系的话,我们是可以通过继承来组合,也可以通过建立装饰器来进行委托.如果是组合的话,问题会越来越麻烦.设想,假如一开始所有人都穿T恤,那么到后来,秋天了,大家穿长袖的,有可能是里面套了一个背心,也有可能是里面传了一件毛衣,那么我们都用继承来进行处理的话,这个组合树,将会越来越大.问题很大!",
      "这就是",
      "组合爆炸",
      "所以,正确的做法是,让类学会穿衣服.不同的衣服,展现出不同的特性.有不同的功能",
      "为每一个特性构造子类,并通过委派机制,添加到对象上.基类实现最原始的功能,然后每一个装饰类实现一部分,逐层的去委派实现.2.4策略模式",
      "考虑如下的场景:假如我们在写一个文本翻译的APP,用户输入文本,我们对其进行翻译.我们一开始是采用SVD分解对文本进行词嵌入.后来,竞争对手纷纷采用了BERT来进行词嵌入,效果比我们好很多.那么,我们也想要用BERT来进行,不过由于考虑到以后的扩展,我们决定将词嵌入,放到一个方法类里面去进行.即这里的策略类.策略模式:存在多种算法来处理同一个任务,但client需要根据需要动态切换算法.我们可以为不同的实现算法构造抽象接口.利用委托,在运行时,动态传入Client倾向的算法类的实例.其UML图如下;2.5 模板模式",
      "还是我们的文本翻译APP.众所周知,NLP文本翻译任务,包含以下几个基本步骤:文本预处理->文本词嵌入->Seq2Seq的生成",
      "我们可以把这几个步骤抽出来作为模板,子类在继承时,进行实现.让子类分别实现我们的模板里面的方法,预处理,词嵌入,文本生成.他们,作事情的步骤时一样的,但具体的方法不同.让共性的步骤在公共实现.差异化的在子类实现.2.6 迭代器模式",
      "用途:我们给外界用户的往往是一个黑箱,如果用户有想要逛逛的需求的话,我们便要在既维护内在表示的基础上,又满足外界用户的需求.在Java里面已经提供了下面的接口:Iterable接口:实现这个的集合对象是可遍历的",
      "Iterator接口:迭代器,实现这个的是可以进行显示/隐式的进行迭代的.2.7 Visitor模式",
      "简单点说:就是预留扩展点,以便日后的扩展",
      "为我们的对象的特定Visit,运行时进行动态的绑定.操作可以灵活更改的.方便以后操作.以上就是对于设计模式的一些总结与思考,谢谢."
    ],
    "codes": [
      "\n常规情况\nProduct A=new ProductA();\n\n工厂方法\nProduct B=ProductFactory.ProduceA();\n"
    ],
    "date": "2021-06-27",
    "text": "设计模式\n设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。 使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性\n一:总纲\n按照王老师的体系,23种设计模式,看上去很多,但万变不离其宗.一切设计模式,均是离不开这两张图.\n具体来说,就如下两种:\n1. 只有继承关系的:\nDIP:依赖倒转原则,细节应当依赖于抽象，抽象不应当依赖于细节。\nOCP:开闭原则,软件实体应当对扩展开放，对修改关闭.\n特点:\n只有一颗继承树\n在设计模式里面的体现:\n模板方法\n:比如,我写了一个白盒框架,现在要往里面加东西,我希望用户来进行手动添加,那么,我给用户一个接口,下面的子类型实现是可以进行任意安排的.\n2. 继承+委托(delegation)\n特点:两颗继承树\n通过另一组继承树,对内在的实现进行了隐藏,具体的体现比如说:Factory方法,Adapter方法,装饰器模式,等等.\n对于装饰器来说,可以认为这两颗树均是自己,通过自己对自己进行委托,进行功能的附加.\n下面,我们来具体的对王老师上课所授的7种设计模式展开具体分析:\n二:具体的7种设计模式\n2.1 工厂方法:\n用户是通过工厂类来得到新的对象,而不是通过new运算符来得到新的对象\n正如船舶里面的水隔舱,工厂类对对象的创建与用户进行了隔离.对于用户而言,它是不知道它的要的产品具体叫什么,这个提供产品的事情,已经被工厂所取代.如果我们需要对功能进行修改的话,只需要动工厂的new的对象,客户端的程序实质上,是稳定的.\n2.2 适配器模式\n考虑下列情形:\n假如我们在进行一个机器学习的项目,我们的核心算法,它需要提供一个numpy形式的矩阵,而我们的数据采集器,返回的矩阵,是一个excel文件.\n这个时候,我们就需要一个适配器,帮我们干活了\n它通过委托与接口,在二者之间建立了如下的桥梁;\n2.3 装饰器模式\n人靠衣装,在街上走,你会看到有穿T恤的,穿长袖夹克的,有穿背心的各种各样的人.\n那么,如果要建立这样的关系的话,我们是可以通过继承来组合,也可以通过建立装饰器来进行委托.\n如果是组合的话,问题会越来越麻烦.\n设想,假如一开始所有人都穿T恤,那么到后来,秋天了,大家穿长袖的,有可能是里面套了一个背心,也有可能是里面传了一件毛衣,那么我们都用继承来进行处理的话,这个组合树,将会越来越大.问题很大!\n这就是\n组合爆炸\n所以,正确的做法是,让类学会穿衣服.不同的衣服,展现出不同的特性.有不同的功能\n为每一个特性构造子类,并通过委派机制,添加到对象上.\n基类实现最原始的功能,然后每一个装饰类实现一部分,逐层的去委派实现.\n2.4策略模式\n考虑如下的场景:\n假如我们在写一个文本翻译的APP,用户输入文本,我们对其进行翻译.\n我们一开始是采用SVD分解对文本进行词嵌入.后来,竞争对手纷纷采用了BERT来进行词嵌入,效果比我们好很多.那么,我们也想要用BERT来进行,不过由于考虑到以后的扩展,我们决定将词嵌入,放到一个方法类里面去进行.\n即这里的策略类.\n策略模式:\n存在多种算法来处理同一个任务,但client需要根据需要动态切换算法.\n我们可以为不同的实现算法构造抽象接口.利用委托,在运行时,动态传入Client倾向的算法类的实例.\n其UML图如下;\n2.5 模板模式\n还是我们的文本翻译APP.\n众所周知,NLP文本翻译任务,包含以下几个基本步骤:\n文本预处理->文本词嵌入->Seq2Seq的生成\n我们可以把这几个步骤抽出来作为模板,子类在继承时,进行实现.\n让子类分别实现我们的模板里面的方法,预处理,词嵌入,文本生成.\n他们,作事情的步骤时一样的,但具体的方法不同.让共性的步骤在公共实现.差异化的在子类实现.\n2.6 迭代器模式\n用途:我们给外界用户的往往是一个黑箱,如果用户有想要逛逛的需求的话,我们便要在既维护内在表示的基础上,又满足外界用户的需求.\n在Java里面已经提供了下面的接口:\nIterable接口:实现这个的集合对象是可遍历的\nIterator接口:迭代器,实现这个的是可以进行显示/隐式的进行迭代的.\n2.7 Visitor模式\n简单点说:就是预留扩展点,以便日后的扩展\n为我们的对象的特定Visit,运行时进行动态的绑定.操作可以灵活更改的.方便以后操作.\n以上就是对于设计模式的一些总结与思考,谢谢.\n"
  },
  {
    "head": "最短路径问题学习心得",
    "paragraphs": [
      "最短路径问题（浙大MOOC学习笔记）",
      "单源最短路（时间最短，路程最短，边的个数。。。）：源点固定的",
      "无权图",
      "有权图",
      "多源最短路：任意两个顶点之间",
      "无权图的单源最短路",
      "就是一次B F S，借助队列，很好实现",
      "当然了，我们需要把BFS里面的Visitied 改一下，改为源点到各个点的最短距离dist",
      "（初始化：正无穷，负无穷，-1）（与visitied的作用类似）",
      "还有一个细节，我们需要用一个数组path，来存储路径",
      "path存什么？",
      "前一个顶点！",
      "我们最后求解结束以后，从V点倒推到原点，利用堆栈，可以很好的实现反向。",
      "伪码如下：",
      "这种方法的时间复杂度应该是O（V+E)",
      "有权图的单源最短路",
      "（首先声明：图里面没有负值圈，因为会挂,也暂时没有负边）",
      "与无权图的算法的类似之处：路径的长度是依次递增的。",
      "Dijkstra算法的基本描述",
      "设V为点集，E为带权值的边集，v0 为原点，那么，我们进行如下的操作：",
      "每次更新集合V的划分V1， V2 （其中V1是已经确定最短距离的点集）V2是待确定的点集",
      "我们要做的：从V2里面取一个与v0距离最短的点p，放到V1里面。",
      "更新所有与p邻接的点的与v0距离（即考虑以p作为中介顶点带来的影响）",
      "若V2为空集，结束",
      "算法细节的简化版证明",
      "最短路径一定仅经过V1里面的顶点",
      "pf：如果在V2里面存在顶点m，使得V1- m-p的长度小于V1-p，那么由于路径长度是从小到大递增的，导出m-V1的距离，小于p-V1，m应该在先于p出现在V1里面，矛盾!",
      "每次p收到V1里面后，仅对V2里面与p邻接的点进行更新就可以了",
      "pf：因为V1里面的点的距离已经是最短了，无需更新，而V2里面的点，由于p的最短距离的确定，会影响与p邻接的顶点与v0的已知最短距离，所以，更新与p邻接的顶点。",
      "dist[W]=min(dist[W],dist[p]+<p,W>)",
      "算法的实现细节",
      "V1 与V2的划分，我们利用collected数组实现",
      "距离的存储我们利用dist数组实现，初始化应该利用正无穷",
      "path[W]=V ，来存路径。",
      "伪码描述:",
      "有权图的多源最短路",
      "引入floyd算法",
      "其中，如果想要导出路径，我们利用path来解决问题",
      "i-j经过k",
      "所以，找i-j转化为i-k与k-j",
      "问题解决",
      "最后，咱还得那几道题目来检验下自己的水平：",
      "第一题哈利波特的考试",
      "07-图4 哈利·波特的考试 (25分)",
      "哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。",
      "现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。",
      "输入格式:",
      "输入说明：输入第1行给出两个正整数",
      "(≤100)和",
      "，其中",
      "是考试涉及的动物总数，",
      "是用于直接变形的魔咒条数。为简单起见，我们将动物按1~",
      "编号。随后",
      "行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。",
      "输出格式:",
      "输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。",
      "输入样例:",
      "输出样例:",
      "蛮简单的，直接floyd一遍，找出每行最小，再找出所有的最小",
      "代码见下：",
      "练习2旅游规划",
      "（居然一遍编译就AC了，233333）",
      "蛮简单，把正常的Dij算法里面的path变成money，问题就结束了。。。",
      "07-图6 旅游规划 (25分)",
      "有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。",
      "输入格式:",
      "输入说明：输入数据的第1行给出4个正整数",
      "，其中",
      "（2≤",
      "≤500）是城市的个数，顺便假设城市的编号为0~(",
      "−1)；",
      "是高速公路的条数；",
      "是出发地的城市编号；",
      "是目的地的城市编号。随后的",
      "行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。",
      "输出格式:",
      "在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。",
      "输入样例:",
      "输出样例:",
      "代码如下："
    ],
    "sentences": [
      "最短路径问题（浙大MOOC学习笔记）",
      "单源最短路（时间最短，路程最短，边的个数",
      "）：源点固定的",
      "无权图",
      "有权图",
      "多源最短路：任意两个顶点之间",
      "无权图的单源最短路",
      "就是一次B F S，借助队列，很好实现",
      "当然了",
      "我们需要把BFS里面的Visitied 改一下",
      "改为源点到各个点的最短距离dist",
      "（初始化：正无穷",
      "负无穷",
      "-1）（与visitied的作用类似）",
      "还有一个细节，我们需要用一个数组path，来存储路径",
      "path存什么？",
      "前一个顶点！",
      "我们最后求解结束以后",
      "从V点倒推到原点",
      "利用堆栈",
      "可以很好的实现反向",
      "伪码如下：这种方法的时间复杂度应该是O（V+E)",
      "有权图的单源最短路",
      "（首先声明：图里面没有负值圈，因为会挂,也暂时没有负边）",
      "与无权图的算法的类似之处：路径的长度是依次递增的",
      "Dijkstra算法的基本描述",
      "设V为点集",
      "E为带权值的边集",
      "v0 为原点",
      "那么",
      "我们进行如下的操作：每次更新集合V的划分V1",
      " V2 （其中V1是已经确定最短距离的点集）V2是待确定的点集",
      "我们要做的：从V2里面取一个与v0距离最短的点p",
      "放到V1里面",
      "更新所有与p邻接的点的与v0距离（即考虑以p作为中介顶点带来的影响）",
      "若V2为空集，结束",
      "算法细节的简化版证明",
      "最短路径一定仅经过V1里面的顶点",
      "pf：如果在V2里面存在顶点m",
      "使得V1- m-p的长度小于V1-p",
      "那么由于路径长度是从小到大递增的",
      "导出m-V1的距离",
      "小于p-V1",
      "m应该在先于p出现在V1里面",
      "矛盾!",
      "每次p收到V1里面后",
      "仅对V2里面与p邻接的点进行更新就可以了",
      "pf：因为V1里面的点的距离已经是最短了",
      "无需更新",
      "而V2里面的点",
      "由于p的最短距离的确定",
      "会影响与p邻接的顶点与v0的已知最短距离",
      "所以",
      "更新与p邻接的顶点",
      "dist[W]=min(dist[W],dist[p]+<p,W>)",
      "算法的实现细节",
      "V1 与V2的划分，我们利用collected数组实现",
      "距离的存储我们利用dist数组实现，初始化应该利用正无穷",
      "path[W]=V ，来存路径",
      "伪码描述:有权图的多源最短路",
      "引入floyd算法",
      "其中，如果想要导出路径，我们利用path来解决问题",
      "i-j经过k",
      "所以，找i-j转化为i-k与k-j",
      "问题解决",
      "最后",
      "咱还得那几道题目来检验下自己的水平：第一题哈利波特的考试",
      "07-图4 哈利·波特的考试 (25分)",
      "哈利·波特要考试了，他需要你的帮助",
      "这门课学的是用魔咒将一种动物变成另一种动物的本事",
      "例如将猫变成老鼠的魔咒是haha",
      "将老鼠变成鱼的魔咒是hehe等等",
      "反方向变化的魔咒就是简单地将原来的魔咒倒过来念",
      "例如ahah可以将老鼠变成猫",
      "另外",
      "如果想把猫变成鱼",
      "可以通过念一个直接魔咒lalala",
      "也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe",
      "现在哈利·波特的手里有一本教材",
      "里面列出了所有的变形魔咒和能变的动物",
      "老师允许他自己带一只动物去考场",
      "要考察他把这只动物变成任意一只指定动物的本事",
      "于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼",
      "则显然哈利·波特应该带鼠去",
      "因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去",
      "则至少需要念6个字符才能把猫变成鱼；同理",
      "带鱼去也不是最好的选择",
      "输入格式:输入说明：输入第1行给出两个正整数",
      "(≤100)和",
      "，其中",
      "是考试涉及的动物总数，是用于直接变形的魔咒条数",
      "为简单起见，我们将动物按1~",
      "编号",
      "随后",
      "行",
      "每行给出了3个正整数",
      "分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)",
      "数字之间用空格分隔",
      "输出格式:输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度",
      "中间以空格分隔",
      "如果只带1只动物是不可能完成所有变形要求的，则输出0",
      "如果有若干只动物都可以备选，则输出编号最小的那只",
      "输入样例:输出样例:蛮简单的",
      "直接floyd一遍",
      "找出每行最小",
      "再找出所有的最小",
      "代码见下：练习2旅游规划",
      "（居然一遍编译就AC了，233333）",
      "蛮简单",
      "把正常的Dij算法里面的path变成money",
      "问题就结束了",
      "07-图6 旅游规划 (25分)",
      "有了一张自驾旅游路线图",
      "你会知道城市间的高速公路长度、以及该公路要收取的过路费",
      "现在需要你写一个程序",
      "帮助前来咨询的游客找一条出发地和目的地之间的最短路径",
      "如果有若干条路径都是最短的，那么需要输出最便宜的一条路径",
      "输入格式:输入说明：输入数据的第1行给出4个正整数",
      "，其中",
      "（2≤",
      "≤500）是城市的个数，顺便假设城市的编号为0~(",
      "−1)；是高速公路的条数；是出发地的城市编号；是目的地的城市编号",
      "随后的",
      "行中",
      "每行给出一条高速公路的信息",
      "分别是：城市1、城市2、高速公路长度、收费额",
      "中间用空格分开",
      "数字均为整数且不超过500",
      "输入保证解的存在",
      "输出格式:在一行里输出路径的长度和收费总额",
      "数字间以空格分隔",
      "输出结尾不能有多余空格",
      "输入样例:输出样例:代码如下："
    ],
    "codes": [
      "void Unweighted ( Vertex S ) \n{ Enqueue(S, Q);\n  while(!IsEmpty(Q)){\n    V = Dequeue(Q); \n    for ( V 的每个邻接点 W )\n      if ( dist[W] == -1  ) {\n        dist[W] = dist[V]+1;\n        path[W] = V;\n        Enqueue(W, Q);\n      }\n  }\n}\n",
      "void Dijkstra( Vertex s )\n{ while (1) {\n    V = 未收录顶点中dist最小者;\n    if ( 这样的V不存在 )\n      break; \n    collected[V] = true;\n    for ( V 的每个邻接点 W )\n      if ( collected[W] == false ) \n    if ( dist[V]+E<V,W> < dist[W] ) {\n         dist[W] = dist[V] + E<V,W> ;\n         path[W] = V;\n    }\n  }\n}\n",
      "for(i=1; i<=v; i++)\n    {\n        for(j=1;j<=v;j++)\n        {D[i][j]=g[i][j];}//初始化D（-1）\n    }\n\n    for(k=1; k<=v; k++)\n    {\n        for(i=1; i<=v; i++)\n        {\n            for(j=1; j<=v; j++)\n            {\n                if((D[i][k]+D[k][j])<D[i][j])\n                {\n                    D[i][j]=D[i][k]+D[k][j];\n                }\n            }\n        }\n    }\n",
      "6 11\n3 4 70\n1 2 1\n5 4 50\n2 6 50\n5 6 60\n1 3 70\n4 6 60\n3 6 80\n5 1 100\n2 4 60\n5 2 80\n",
      "4 70\n",
      "#include <iostream>\n#include <queue>\n#include <stdio.h>\n#define MAXVALUE 99999\nusing namespace std;\nint g[120][120];\nint v,e;\nvoid start()\n{\n    cin>>v>>e;\n    int i,j,x,y,value;\n    for(i=0; i<e; i++)\n    {\n        cin>>x>>y>>value;\n        g[x][y]=value;\n        g[y][x]=value;\n    }\n    for(x=1; x<=v; x++)\n    {\n        for(y=1; y<=v; y++)\n        {\n            if(g[x][y]==0)\n            {\n                g[x][y]=MAXVALUE;\n            }\n        }\n    }\n\n}\n\nvoid floyd()\n{\n    int i,j,k,n;\n    int D[120][120];\n    for(i=1; i<=v; i++)\n    {\n        for(j=1;j<=v;j++)\n        {D[i][j]=g[i][j];}//初始化D（-1）\n    }\n\n    for(k=1; k<=v; k++)\n    {\n        for(i=1; i<=v; i++)\n        {\n            for(j=1; j<=v; j++)\n            {\n                if((D[i][k]+D[k][j])<D[i][j])\n                {\n                    D[i][j]=D[i][k]+D[k][j];\n                }\n            }\n        }\n    }\n    int animals[120],tempmax;\n    for(i=1; i<=v; i++)\n    {\n        tempmax=0;\n        for(j=1; j<=v; j++)\n        {\n            if(i!=j)\n            {\n                if(D[i][j]>tempmax)\n                {\n                    tempmax=D[i][j];\n                }\n            }\n        }\n        animals[i]=tempmax;\n    }\n\n    int minvalue=MAXVALUE,minloca=-1,temp;\n    for(i=1; i<=v; i++)\n    {\n        if(minvalue>animals[i])\n        {\n            minvalue=animals[i];\n            minloca=i;\n        }\n    }\n    if(minloca==-1)\n    {\n        cout<<\"0\";\n    }\n    else\n    {\n        cout<<minloca<<\" \"<<minvalue;\n    }\n}\n\n\n\nint main()\n{\n    start();\n    floyd();\n}\n\n\n",
      "4 5 0 3\n0 1 1 20\n1 3 2 30\n0 3 4 10\n0 2 2 20\n2 3 1 20\n",
      "3 40\n",
      "#include <iostream>\n#define inf 9999999\n\nusing namespace std;\nstruct way\n{\n    int lenth;\n    int price;\n    /* data */\n} graph[530][530];\nint N,M,S,D;\nint money[530];\nint dist[530];\nint collect[530];\nvoid ini()\n{\n    cin>>N>>M>>S>>D;\n    int i;\n    int x,y,l,p;\n    for(i=0;i<M;i++)\n    {\n        cin>>x>>y>>l>>p;\n        graph[x][y].lenth=l;\n        graph[x][y].price=p;\n        graph[y][x].lenth=l;\n        graph[y][x].price=p;\n    }\n}\nint find_mindist()\n{\n    int i,tem=inf-5,rem=-1;\n    for(i=0;i<N;i++)\n    {\n        if(dist[i]<tem&&collect[i]==0)\n        {\n            tem=dist[i];\n            rem=i;\n        }\n    }\n    return rem;\n}\nint min(int a,int b)\n{\n    if(a<b)\n    {return a;}\n    else\n    {\n        return b;\n    }\n\n}\nvoid da()\n{\n    int i,j,k;\n    int p;\n    for(i=0;i<N;i++)\n    {\n        dist[i]=inf;\n    }\n    dist[S]=0;\n    money[S]=0;\n    while (1)\n    {\n        p=find_mindist();\n        if(p==-1)\n        {\n            break;\n        }\n        else\n        {\n            collect[p]=1;\n            for(i=0;i<N;i++)\n            {\n                if(graph[p][i].lenth!=0&&collect[i]==0)\n                {\n                    if ((graph[p][i].lenth+dist[p])<dist[i])\n                     {\n                            dist[i]=graph[p][i].lenth+dist[p];\n\n                            money[i]=money[p]+graph[p][i].price;\n                    }\n                    if ((graph[p][i].lenth+dist[p])==dist[i]&&money[i]>(money[p]+graph[p][i].price))\n                    {\n\n                        dist[i]=graph[p][i].lenth+dist[p];\n\n                        money[i]=money[p]+graph[p][i].price;\n                    }\n                }\n            }\n        }\n    }\n    cout<<dist[D]<<\" \"<<money[D];\n}\n\n\nint main()\n{\n    ini();\n    da();\n\n\n}\n\n"
    ],
    "date": "2020-08-09",
    "text": "最短路径问题（浙大MOOC学习笔记）\n单源最短路（时间最短，路程最短，边的个数。。。）：源点固定的\n无权图\n有权图\n多源最短路：任意两个顶点之间\n无权图的单源最短路\n就是一次B F S，借助队列，很好实现\n当然了，我们需要把BFS里面的Visitied 改一下，改为源点到各个点的最短距离dist\n（初始化：正无穷，负无穷，-1）（与visitied的作用类似）\n还有一个细节，我们需要用一个数组path，来存储路径\npath存什么？\n前一个顶点！\n我们最后求解结束以后，从V点倒推到原点，利用堆栈，可以很好的实现反向。\n伪码如下：\n这种方法的时间复杂度应该是O（V+E)\n有权图的单源最短路\n（首先声明：图里面没有负值圈，因为会挂,也暂时没有负边）\n与无权图的算法的类似之处：路径的长度是依次递增的。\nDijkstra算法的基本描述\n设V为点集，E为带权值的边集，v0 为原点，那么，我们进行如下的操作：\n每次更新集合V的划分V1， V2 （其中V1是已经确定最短距离的点集）V2是待确定的点集\n我们要做的：从V2里面取一个与v0距离最短的点p，放到V1里面。\n更新所有与p邻接的点的与v0距离（即考虑以p作为中介顶点带来的影响）\n若V2为空集，结束\n算法细节的简化版证明\n最短路径一定仅经过V1里面的顶点\npf：如果在V2里面存在顶点m，使得V1- m-p的长度小于V1-p，那么由于路径长度是从小到大递增的，导出m-V1的距离，小于p-V1，m应该在先于p出现在V1里面，矛盾!\n每次p收到V1里面后，仅对V2里面与p邻接的点进行更新就可以了\npf：因为V1里面的点的距离已经是最短了，无需更新，而V2里面的点，由于p的最短距离的确定，会影响与p邻接的顶点与v0的已知最短距离，所以，更新与p邻接的顶点。\ndist[W]=min(dist[W],dist[p]+<p,W>)\n算法的实现细节\nV1 与V2的划分，我们利用collected数组实现\n距离的存储我们利用dist数组实现，初始化应该利用正无穷\npath[W]=V ，来存路径。\n伪码描述:\n有权图的多源最短路\n引入floyd算法\n其中，如果想要导出路径，我们利用path来解决问题\ni-j经过k\n所以，找i-j转化为i-k与k-j\n问题解决\n最后，咱还得那几道题目来检验下自己的水平：\n第一题哈利波特的考试\n07-图4 哈利·波特的考试 (25分)\n哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。\n现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。\n输入格式:\n输入说明：输入第1行给出两个正整数\n(≤100)和\n，其中\n是考试涉及的动物总数，\n是用于直接变形的魔咒条数。为简单起见，我们将动物按1~\n编号。随后\n行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。\n输出格式:\n输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。\n输入样例:\n输出样例:\n蛮简单的，直接floyd一遍，找出每行最小，再找出所有的最小\n代码见下：\n练习2旅游规划\n（居然一遍编译就AC了，233333）\n蛮简单，把正常的Dij算法里面的path变成money，问题就结束了。。。\n07-图6 旅游规划 (25分)\n有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。\n输入格式:\n输入说明：输入数据的第1行给出4个正整数\n，其中\n（2≤\n≤500）是城市的个数，顺便假设城市的编号为0~(\n−1)；\n是高速公路的条数；\n是出发地的城市编号；\n是目的地的城市编号。随后的\n行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。\n输出格式:\n在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。\n输入样例:\n输出样例:\n代码如下：\n"
  },
  {
    "head": "拓扑排序以及其C++实现",
    "paragraphs": [
      "拓扑排序",
      "啥是拓扑排序？",
      "直观理解就是在AOE/AOV网络里面，把图的一种先后顺序，对图进行遍历",
      "进行的算法也不难",
      "直接每次选取入度为0的点，进行入队",
      "然后每次出队一个，并对其邻接的顶点进行度的减一操作。",
      "如果出队的顶点数小于总的顶点数，那么，表明存在圈",
      "所以，该算法也能用于有向图的圈的判定问题。",
      "咱们利用一道例题说明：",
      "08-图8 How Long Does It Take (25分)",
      "Given the relations of all the activities of a project, you are supposed to find the earliest completion time of the project.",
      "Input Specification:",
      "Each input file contains one test case. Each case starts with a line containing two positive integers",
      "(≤100), the number of activity check points (hence it is assumed that the check points are numbered from 0 to",
      "−1), and",
      ", the number of activities. Then",
      "lines follow, each gives the description of an activity. For the",
      "-th activity, three non-negative numbers are given:",
      "S[i]",
      "E[i]",
      ", and",
      "L[i]",
      ", where",
      "S[i]",
      "is the index of the starting check point,",
      "E[i]",
      "of the ending check point, and",
      "L[i]",
      "the lasting time of the activity. The numbers in a line are separated by a space.",
      "Output Specification:",
      "For each test case, if the scheduling is possible, print in a line its earliest completion time; or simply output “Impossible”.",
      "题目的大致意思，就是：每项工作，用图G里面的边进行表示，节点表示任务结束（AOE/activity on edge网络），求最小完成时间",
      "我们需要做的，实现之前的拓扑排序算法",
      "对于最短时间，我们只需要弄一个数组earlist，每次入度减一时，进行最大的更新操作",
      "PS：一开始，没看清楚权重为0的边，表明我们在对图的初始化时，要当心。调试程序真的是让人头秃啊。。。。。",
      "代码见下："
    ],
    "sentences": [
      "拓扑排序",
      "啥是拓扑排序？",
      "直观理解就是在AOE/AOV网络里面",
      "把图的一种先后顺序",
      "对图进行遍历",
      "进行的算法也不难",
      "直接每次选取入度为0的点，进行入队",
      "然后每次出队一个，并对其邻接的顶点进行度的减一操作",
      "如果出队的顶点数小于总的顶点数，那么，表明存在圈",
      "所以，该算法也能用于有向图的圈的判定问题",
      "咱们利用一道例题说明：08-图8 How Long Does It Take (25分)",
      "Given the relations of all the activities of a project, you are supposed to find the earliest completion time of the project.Input Specification:Each input file contains one test case. Each case starts with a line containing two positive integers",
      "(≤100), the number of activity check points (hence it is assumed that the check points are numbered from 0 to",
      "−1), and",
      ", the number of activities. Then",
      "lines follow, each gives the description of an activity. For the",
      "-th activity, three non-negative numbers are given:S[i]",
      "E[i]",
      ", and",
      "L[i]",
      ", where",
      "S[i]",
      "is the index of the starting check point,E[i]",
      "of the ending check point, and",
      "L[i]",
      "the lasting time of the activity. The numbers in a line are separated by a space.Output Specification:For each test case, if the scheduling is possible, print in a line its earliest completion time; or simply output “Impossible”.题目的大致意思",
      "就是：每项工作",
      "用图G里面的边进行表示",
      "节点表示任务结束（AOE/activity on edge网络）",
      "求最小完成时间",
      "我们需要做的，实现之前的拓扑排序算法",
      "对于最短时间",
      "我们只需要弄一个数组earlist",
      "每次入度减一时",
      "进行最大的更新操作",
      "PS：一开始",
      "没看清楚权重为0的边",
      "表明我们在对图的初始化时",
      "要当心",
      "调试程序真的是让人头秃啊",
      "代码见下："
    ],
    "codes": [
      "9 12\n0 1 6\n0 2 4\n0 3 5\n1 4 1\n2 4 1\n3 5 2\n5 4 0\n4 6 9\n4 7 7\n5 7 4\n6 8 2\n7 8 4\n",
      "18\n",
      "4 5\n0 1 1\n0 2 2\n2 1 3\n1 3 4\n3 2 5\n",
      "Impossible\n",
      "#include <iostream>\n#include <queue>\n#define inf 9999999\nint n, m;\nint graph[200][200];\nint ru_du[200];\n\nusing namespace std;\nvoid ini()\n{\n\n    cin>>n>>m;\n    int i, j, k, x, y;\n    for(i=0;i<200;i++)\n    {\n        for(j=0;j<200;j++)\n        {\n            graph[i][j]=-100;\n        }\n    }\n\n    for (i=0; i<m; i++)\n    {\n        cin>>x>>y;\n        cin>>k;\n        graph[x][y]=k;\n        ru_du[y]++;\n    }\n}\n\nint maxx(int a,int b)\n{\n    if(a>b)\n    {\n        return a;\n    }\n    else\n    {\n        return b;\n    }\n\n}\nvoid slove()\n{\n   queue <int> qq;\n   int i,j,k;\n   for(i=0;i<n;i++)\n   {\n       if(ru_du[i]==0)\n       {\n           qq.push(i);\n       }\n   }\n   int counnt=0;\n   int earlist[2000]={0};\n   while (!qq.empty())\n   {\n       int t=qq.front();\n        qq.pop();\n        counnt++;\n       for(i=0;i<n;i++)\n       {\n           if(graph[t][i]!=-100)\n           {\n               ru_du[i]--;\n               earlist[i]=maxx(earlist[i],earlist[t]+graph[t][i]);\n                if(ru_du[i]==0)\n                {\n                    qq.push(i);\n                }\n            }\n       }\n   }\n\n    if(counnt!=n)\n    {\n        cout<<\"Impossible\";\n        return;\n    }\n    else\n    {\n        int t=0;\n        for(i=0;i<n;i++)\n        {\n            t=maxx(earlist[i],t);\n        }\n        cout<<t;\n        return;\n    }\n\n\n\n\n\n}\n\n\nint main()\n{\n    ini();\n\n    slove();\n}\n\n\n\n",
      "Sample Input 1:",
      "Sample Output 1:",
      "Sample Input 2:",
      "Sample Output 2:"
    ],
    "date": "2020-08-10",
    "text": "拓扑排序\n啥是拓扑排序？\n直观理解就是在AOE/AOV网络里面，把图的一种先后顺序，对图进行遍历\n进行的算法也不难\n直接每次选取入度为0的点，进行入队\n然后每次出队一个，并对其邻接的顶点进行度的减一操作。\n如果出队的顶点数小于总的顶点数，那么，表明存在圈\n所以，该算法也能用于有向图的圈的判定问题。\n咱们利用一道例题说明：\n08-图8 How Long Does It Take (25分)\nGiven the relations of all the activities of a project, you are supposed to find the earliest completion time of the project.\nInput Specification:\nEach input file contains one test case. Each case starts with a line containing two positive integers\n(≤100), the number of activity check points (hence it is assumed that the check points are numbered from 0 to\n−1), and\n, the number of activities. Then\nlines follow, each gives the description of an activity. For the\n-th activity, three non-negative numbers are given:\nS[i]\nE[i]\n, and\nL[i]\n, where\nS[i]\nis the index of the starting check point,\nE[i]\nof the ending check point, and\nL[i]\nthe lasting time of the activity. The numbers in a line are separated by a space.\nOutput Specification:\nFor each test case, if the scheduling is possible, print in a line its earliest completion time; or simply output “Impossible”.\n题目的大致意思，就是：每项工作，用图G里面的边进行表示，节点表示任务结束（AOE/activity on edge网络），求最小完成时间\n我们需要做的，实现之前的拓扑排序算法\n对于最短时间，我们只需要弄一个数组earlist，每次入度减一时，进行最大的更新操作\nPS：一开始，没看清楚权重为0的边，表明我们在对图的初始化时，要当心。调试程序真的是让人头秃啊。。。。。\n代码见下：\n"
  },
  {
    "head": "Java 源码探究学习(一) 论List(更新中)",
    "paragraphs": [
      "Java 源码探究学习(一) 论List(更新中)",
      "前言:由于笔者于哈工大学习软件构造时,王老师上课抛出了一个小任务,即,从Java的源码里面来学习它的ADT的思想.所以,笔者希望通过写一点点博客,进行探究",
      "一.LinkedList的探究",
      "首先,我们进入linkedlist的源码,进行粗略的看看,首先,看看这个实现的spec,通过加批注的方式进行学习.",
      "再往下面看,发现当年作者写的checkRep",
      "即,从这里我们可以看到作者的表示不变量即",
      "要么,size是0,链表里面没有元素;first",
      "last",
      "null",
      "要么,first的前面与last的后面,都是null",
      "更新中…"
    ],
    "sentences": [
      "Java 源码探究学习(一) 论List(更新中)",
      "前言:由于笔者于哈工大学习软件构造时,王老师上课抛出了一个小任务,即,从Java的源码里面来学习它的ADT的思想.所以,笔者希望通过写一点点博客,进行探究",
      "一.LinkedList的探究",
      "首先,我们进入linkedlist的源码,进行粗略的看看,首先,看看这个实现的spec,通过加批注的方式进行学习.再往下面看,发现当年作者写的checkRep",
      "即,从这里我们可以看到作者的表示不变量即",
      "要么,size是0,链表里面没有元素;first",
      "last",
      "null",
      "要么,first的前面与last的后面,都是null",
      "更新中…"
    ],
    "codes": [
      "\n     首先介绍,这个链表,实现了List与Deque,允许所有的元素.\n /**\n * Doubly-linked list implementation of the {@code List} and {@code Deque}\n * interfaces.  Implements all optional list operations, and permits all\n * elements (including {@code null}).\n *\n \t\n * <p>All of the operations perform as could be expected for a doubly-linked\n * list.  Operations that index into the list will traverse the list from\n * the beginning or the end, whichever is closer to the specified index.\n **/\n \tPercondition:\n \t通过加粗的话,设定前置条件,这个实现不是 synchronized.的\n /*\n * <p><strong>Note that this implementation is not synchronized.</strong>\n * If multiple threads access a linked list concurrently, and at least\n * one of the threads modifies the list structurally, it <i>must</i> be\n * synchronized externally.  (A structural modification is any operation\n * that adds or deletes one or more elements; merely setting the value of\n * an element is not a structural modification.)  This is typically\n * accomplished by synchronizing on some object that naturally\n * encapsulates the list.\n *\n * If no such object exists, the list should be \"wrapped\" using the\n * {@link Collections#synchronizedList Collections.synchronizedList}\n * method.  This is best done at creation time, to prevent accidental\n * unsynchronized access to the list:<pre>\n *   List list = Collections.synchronizedList(new LinkedList(...));</pre>\n **/\n \tPostcondition:\n \t对后置条件进行说明:\n    \t说明本类里面方法的返回值,同时提到了failfast,即针对每种不满足情况,抛出的异常\n /* <p>The iterators returned by this class's {@code iterator} and\n * {@code listIterator} methods are <i>fail-fast</i>: if the list is\n * structurally modified at any time after the iterator is created, in\n * any way except through the Iterator's own {@code remove} or\n * {@code add} methods, the iterator will throw a {@link\n * ConcurrentModificationException}.  Thus, in the face of concurrent\n * modification, the iterator fails quickly and cleanly, rather than\n * risking arbitrary, non-deterministic behavior at an undetermined\n * time in the future.\n *\n * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed\n * as it is, generally speaking, impossible to make any hard guarantees in the\n * presence of unsynchronized concurrent modification.  Fail-fast iterators\n * throw {@code ConcurrentModificationException} on a best-effort basis.\n * Therefore, it would be wrong to write a program that depended on this\n * exception for its correctness:   <i>the fail-fast behavior of iterators\n * should be used only to detect bugs.</i>\n *\n * <p>This class is a member of the\n * <a href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\">\n * Java Collections Framework</a>.\n **/\n 下面是对作者进行了介绍,膜拜一下大佬...\n /*\n * @author  Josh Bloch\n * @see     List\n * @see     ArrayList\n * @since 1.2\n * @param <E> the type of elements held in this collection\n */\n"
    ],
    "date": "2021-05-26",
    "text": "Java 源码探究学习(一) 论List(更新中)\n前言:由于笔者于哈工大学习软件构造时,王老师上课抛出了一个小任务,即,从Java的源码里面来学习它的ADT的思想.所以,笔者希望通过写一点点博客,进行探究\n一.LinkedList的探究\n首先,我们进入linkedlist的源码,进行粗略的看看,首先,看看这个实现的spec,通过加批注的方式进行学习.\n再往下面看,发现当年作者写的checkRep\n即,从这里我们可以看到作者的表示不变量即\n要么,size是0,链表里面没有元素;first\nlast\nnull\n要么,first的前面与last的后面,都是null\n更新中…\n"
  },
  {
    "head": "软件构造复习笔记(3)",
    "paragraphs": [
      "注：文章中带有 * 的标题表示往年考试中出现过相应考点",
      "文章目录",
      "第七章 面向对象的编程(OOP)",
      "1 基本概念：对象、类、属性、方法*",
      "2 接口和枚举*",
      "4 封装和信息隐藏*",
      "5 继承和重写*",
      "Overriding*",
      "抽象类",
      "6 多态、子类型、重载*",
      "9 动态分派",
      "10 一些Java中的重要对象方法*",
      "11 设计好的类*",
      "12 OOP历史",
      "第八章 ADT和OOP中的“等价性”",
      "1 等价关系*",
      "2 不可变类型的等价性",
      "3 == 和 equal()*",
      "4 实现equal()",
      "5 对象契约*",
      "6 可变类型的等价性",
      "7 自动封装和等价性",
      "第九章 面向复用的软件构造技术",
      "1 什么是软件复用",
      "2 如何度量可复用性",
      "3 可重用部件的等级和形态",
      "5 设计可复用类*",
      "Liskov替代原则(LSP)*",
      "委派和组成*",
      "6 设计系统级可复用API库和框架",
      "第七章 面向对象的编程(OOP)",
      "1 基本概念：对象、类、属性、方法*",
      "对象：是状态和行为的组合",
      "状态 - 对象中所包含的数据 - 类中的实例变量",
      "行为 - 对象所支持的行为 - 类中的实例方法",
      "类：每个对象都属于某个类，方法定义了类型和实现",
      "类成员变量：一个和类相关而非类的实例相关的变量 - 静态成员变量",
      "类方法：之和类相关的方法 - 静态方法",
      "注：本节为基础知识，需要掌握",
      "2 接口和枚举*",
      "接口(Interface)：一个方法声明的列表，不包含方法体，可以由类实现",
      "接口间可以继承和扩展",
      "一个类可以实现多个接口(从而具备了多个接口中的方法)",
      "一个接口可以有多种实现类",
      "接口 - 确定ADT规范，类 - 实现ADT",
      "可以不需要接口直接使用类作为ADT，既有ADT定义也有ADT实现",
      "但实际中更倾向于使用接口来定义变量",
      "打破了抽象边界，接口定义中没有包含constructor，也无法保证所有实现类中都包含了同样名字的constructor。",
      "故而，客户端需要知道该接口的某个具体实现类的名字。可以提供静态工厂方法而非构造函数来向客户端提供具体实现类。",
      "接口中每个方法都需要在所有实现它的类中实现",
      "可以通过default关键字修饰方法，在接口中统一实现某些功能，无需在各个类中重复实现它",
      "以增量式的为接口增加额外的功能而不破坏已实现的类",
      "枚举：",
      "注：本节了解一下接口就行了",
      "4 封装和信息隐藏*",
      "信息隐藏：区分模块设计好坏的唯一最重要的因素是它对其他模块隐藏内部数据和其他实现细节的程度，设计良好的代码应该能隐藏全部实现细节",
      "通过接口进行信息隐藏：",
      "1.使用接口类型声明变量",
      "2.客户端仅使用接口中定义的方法",
      "3.客户端代码无法直接访问属性",
      "权限修饰符：",
      "private：只能在类内部进行使用",
      "protected：可以在其子类及同个包中的其他类中使用",
      "public：在所有类中都可以使用",
      "信息隐藏策略：",
      "1.认真设计API",
      "2.只提供客户端需要的功能，其他所有成员都应该是private的",
      "3.你可以在不破坏客户端的情况下将任何一个private成员修饰为public",
      "注：本节需要了解权限修饰符的功能",
      "5 继承和重写*",
      "Overriding*",
      "可重写的方法：未加final修饰的方法都可以在子类中重写，即在子类中将该方法重写实现，重写的方法有着和原方法完全相同的声明，实际执行时调用哪个方法，在运行时决定",
      "严格继承：子类只能添加新的方法，无法重写超类中的方法",
      "如果一个方法不能被重写，那它一定以final修饰",
      "通产override的方法都需要在方法声明前添加@override",
      "final作用：",
      "1.变量 - 使变量在初始化后不能再改变取值",
      "2.方法 - 避免子类中重写该方法",
      "3.类 - 避免该类被继承",
      "重写时，可以使用super()复用父类中函数的功能，并在后续代码中进行拓展",
      "重写时，不要改变原方法的本意",
      "抽象类",
      "抽象方法：存在有声明，但没有实现的方法，这个方法由abstract关键字修饰",
      "抽象类：存在至少一个抽象方法的类，该类必须由abstract关键字修饰，抽象类不能被实例化",
      "接口可以被认为是只有抽象方法的抽象类",
      "如果某些操作是所有子类型都共有，但彼此有差别，可以在父类型中设计抽象方法，在各子类型中重写。",
      "所有子类型完全相同的操作，放在父类型中实现，子类型中无需重写。",
      "有些子类型有而其他子类型无的操作，不要在父类型中定义和实现，而应在特定子类型中实现。",
      "注：继承、重写是重要概念，必须掌握",
      "6 多态、子类型、重载*",
      "三种多态类型：",
      "特殊多态 - 函数重载",
      "参数化多态 - 泛型",
      "子类型多态、包含多态 - 多个子类继承某父类",
      "重载(Overload)：多个方法具有同样的名字，但有不同的参数列表或返回值类型",
      "价值：方便客户端使用，客户端可用不同的参数列表，调用同样的函数",
      "重载时一种静态多态：进行静态类型检查，根据参数列表进行最佳匹配，在编译阶段时决定要具体执行哪个方法",
      "重载规则：",
      "1.必须有不同的参数列表",
      "2.可以有相同/不同的返回值类型",
      "3.可以有相同/不同的权限修饰符",
      "4.可以有新的或更广泛的检查异常",
      "5.可以在同一个类内重载，也可以在子类中重载",
      "重写(Override)则是在运行时进行动态检查，根据内存中对象的具体类型来调用对应方法",
      "泛型：以泛型方式定义函数和类型，以便基于运行时传递的参数工作，即允许静态类型化而不完全指定类型。",
      "泛型编程：是一种编程风格，其中数据类型和函数用稍后指定的类型编写，然后在需要时对作为参数提供的特定类型进行实例化。",
      "类型变量：未指定的变量类型",
      "泛型类：类定义中包含了类型变量",
      "泛型接口：接口定义中包含了类型变量",
      "泛型方法：方法定义中包含了类型变量",
      "泛型的其他性质：",
      "子类型：若B是A的子类型，意味着每一个B类型的变量都可以被当作A类型",
      "B是A的子类型当且仅当B的Spec至少和A一样强，子类型的规约不能弱化父类型的规约",
      "子类型多态：不同类型的对象可以统一的处理而无需区分",
      "注：重载、重写应该掌握，泛型应该了解一下，子类型多态需要注意对子类型spec的要求",
      "9 动态分派",
      "动态分派：确定要在运行时调用的方法，即在运行时解析对已覆盖或多态方法的调用",
      "静态分派：重载的方法使用静态绑定绑定，而重载的方法在运行时使用动态绑定绑定。",
      "10 一些Java中的重要对象方法*",
      "equals方法：当两个对象等价时返回true，应满足对称、自反、传递的性质",
      "hashCode方法：返回在哈希映射中使用的哈希代码",
      "toString方法：返回一个可打印的字符串表示",
      "注：应重点关注equal方法",
      "11 设计好的类*",
      "不可变类的优点：简单、固有线程安全、可以自由共享、不需要防御拷贝、优秀的构建块",
      "如何写不可变类：",
      "1.不提供任何mutator",
      "2.确保方法都不会被重写",
      "3.使所有变量均被final修饰",
      "4.使所有变量均被private修饰",
      "5.确保任何可变类型的组成部分的安全性(避免表示泄露)",
      "6.实现toString()、hashCode()、equals()等方法",
      "注：需要学会怎么设计不可变的类",
      "12 OOP历史",
      "第八章 ADT和OOP中的“等价性”",
      "1 等价关系*",
      "ADT是对数据的抽象，体现为一组对数据的操作",
      "抽象函数AF：内部表示->抽象表示",
      "基于抽象函数AF定义ADT的等价操作",
      "等价关系：自反、对称、传递",
      "注：需要理解什么是等价关系",
      "2 不可变类型的等价性",
      "如果AF映射到相同的结果，则等价",
      "站在外部观察者的角度，对两个对象调用任何相同的操作，都会得到相同的结果，则认为两个对象是等价的，反之亦然",
      "3 == 和 equal()*",
      "== 运算符比较的是对象的引用，两个对象指向同一个内存空间时，则说明这两个对象具有引用等价性",
      "equal()方法比较的是对象的内容，即对象等价性",
      "在自定义ADT时，需要重写Object的equals()",
      "== 通常用于对基本数据类型判断是否相等，equal()用于判断对象类型是否等价",
      "注：需要了解如何区分两者区别",
      "4 实现equal()",
      "在Object中缺省equals()是在判断引用等价性，所以一般需要重写",
      "equal方法如果接受的参数不是Object类型则实现不是override而是overload",
      "instanceof运算符可以判断某一变量所指向内存是否属于某各类型(动态检查)",
      "5 对象契约*",
      "equal方法满足的契约：",
      "1.等价关系：自反、对称、传递",
      "2.除非对象被修改了，否则调用多次equals应有同样的结果",
      "3.对于非null引用x，x.equals(null)应返回false",
      "4.等价的对象，其hashCode()的结果必须相同",
      "哈希表：",
      "等价的对象必须有相同的hashCode，但不等价的对象也可以有相同的hashCode，不够性能会变差",
      "重载hashCode()：",
      "注：主要关注equals()方法",
      "6 可变类型的等价性",
      "观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致",
      "行为等价性：调用对象的任何方法都展示出一致的结果，可以认为就是引用等价性",
      "对可变类型来说，往往倾向于实现严格的观察等价性，但有时候观察等价性可能导致bug，甚至可能破坏RI",
      "在hashSet等类型中，其内部的可变数据类型发生改变时，hashCode会改变，导致hashSet的contains方法会判断集合中改变过的内容不属于集合",
      "7 自动封装和等价性",
      "第九章 面向复用的软件构造技术",
      "1 什么是软件复用",
      "软件复用是使用现有软件组件实现或更新软件系统的过程",
      "软件复用的两个视角：",
      "1.面向复用编程(Creation)：开发出可复用的软件",
      "2.基于复用编程(Use)：利用已有的可复用软件搭建应用系统",
      "复用好处：",
      "1.降低成本和开发时间",
      "2.经过充分测试，可靠、稳定",
      "3.标准化，在不同应用中保持一致",
      "2 如何度量可复用性",
      "从以下几个角度度量：",
      "1.复用的机会有多频繁？复用的场合有多少？",
      "2.复用的代价有多大？",
      "3 可重用部件的等级和形态",
      "最主要的复用是在代码层面，但软件构造过程中的任何实体都可能被复用 - 需求、设计/规约、数据、测试用例、文档",
      "白盒复用：源代码可见，可修改和拓展 - 复制已有代码到正在开发的系统，进行修改",
      "优点：可定制化程度高",
      "缺点：对其修改增加了软件的复杂度，且需要对其内部充分的了解",
      "黑盒复用：源代码不可见，不能修改 - 只能通过API接口来使用，无法修改代码",
      "优点：简单、清晰",
      "缺点：适应性差些",
      "复用一个类的方法：",
      "1.继承：子类可以对父类中的属性、方法等进行复用",
      "2.委派：在一个类中使用其他类的方法来实现自己的功能",
      "框架：一组具体类、抽象类、及其之间的连接关系",
      "开发者根据framework的规约，填充自己的代码进去，形成完整系统",
      "白盒框架：通过代码层面的继承进行框架拓展",
      "黑盒框架：通过实现特定接口/delegation进行框架拓展",
      "5 设计可复用类*",
      "Liskov替代原则(LSP)*",
      "子类型多态：客户端可用统一的方式处理不同类型的对象",
      "在Java中的编译器强制执行的规则：",
      "1.子类型可以增加方法，但不可以删",
      "2.子类型中需要实现抽象类型中的所有未实现方法",
      "3.子类型中重写的方法必须返回相同的类型或其子类型(满足协变)",
      "4.子类型中重写的方法必须接收相同的参数类型(满足逆变)",
      "5.子类型中重写的方法不能抛出额外的异常",
      "LSP原则：子类方法必须相比于父类方法有着相同或更强的不变量，相同或更弱的前置条件，相同或更强的后置条件，才能使子类无条件地可以替代父类。",
      "LSP是子类型关系的一个特殊定义，称为（强）行为子类型",
      "LSP依赖于以下限制：",
      "1.前置条件不能强化",
      "2.后置条件不能弱化",
      "3.不变量要保持",
      "4.子类型方法参数：逆变",
      "5.子类型方法返回值：协变",
      "6.异常类型：协变",
      "协变：随着父类型到子类型越来越具体，对于返回值类型而言，不变或变得更具体，异常的类型也是如此",
      "逆变：随着父类型到子类型越来越具体，参数类型会相反地变化，要不变或者越来越抽象",
      "(目前Java中这种情况会被视作overload)",
      "数组是协变的：根据Java的子类型规则，一个类型T的数组可以容纳类型T和其子类型的变量",
      "泛型不是协变的，ArrayList是List的子类型，但List不是类型List的泛型",
      "泛型中的通配符：",
      "委派和组成*",
      "以排序为例，如果你的ADT需要比较大小，或者要放入Collections或Array进行排序，可实现Comparator接口构建比较器并override compare方法或者实现Comparable接口拓展ADT并override compareTo方法(不需要构建新的Comparator类，比较代码防止ADT内部)",
      "上述例子中，Comparator属于delegation，而Comparable不属于delegation",
      "委派：一个对象请求另一个对象的功能，委派是代码复用的一种常见形式",
      "显式委派：将发送对象传递给接收对象",
      "隐式委派：通过成员查找规则",
      "委派模式：通过运动时动态绑定，实现对其他类中代码的动态复用",
      "委派和继承：",
      "继承通过拓展基类来添加新操作或重写某操作",
      "委派通过捕捉某个行为，并将其发送给另一个对象",
      "很多设计模式都使用两者组合",
      "如果子类只需要复用父类中的一小部分方法，则可以不需要使用继承，而是通过委派机制来实现",
      "一个类不需要继承另一个类的全部方法时，可以通过委派机制调用部分方法，从而避免大量无用方法",
      "委托发生在object层面，而继承发生在class层面",
      "组合复用原则(CRP)：类应该通过其组合（通过包含实现所需功能的其他类的实例）来实现代码重用，而不是从基类或父类继承来实现多态行为和代码重用。",
      "CRP原则的思路：",
      "1.使用接口定义系统必须对外展示的不同侧面的行为",
      "2.接口之间通过extends实现行为的扩展（接口组合）",
      "3.类implements 组合接口，从而规避了复杂的继承关系",
      "delegation的类型：",
      "1.Dependency:临时性的delegation(作为方法的参数使用)",
      "Dependency：对象需要其他对象（供应者）才能实现的临时关系",
      "2.Assosiation:永久性的delegation(作为对象的属性使用)",
      "Assosiation：对象类之间的持久关系，允许一个对象实例代表另一个对象实例执行操作。",
      "3.Composition:更强的assosiation，但难以变化(属性通过内部各方法进行初始化、修改等)",
      "Composition：是一种将简单的对象或数据类型组合成更复杂的数据类型的方法",
      "4.Aggregation:更弱的assosiation，可动态变化(属性通过外部方法进行修改)",
      "Aggregation：对象存在于另一个外部，在外部创建，因此它作为参数传递给解释器。",
      "这四种类型都支持一对多的delegation",
      "注：本节为重点，需要理解LSP、CRP、继承、委派等概念的含义，并会分析及写相应代码",
      "6 设计系统级可复用API库和框架",
      "库：提供可复用功能的类和方法的集合"
    ],
    "sentences": [
      "注：文章中带有 * 的标题表示往年考试中出现过相应考点",
      "文章目录",
      "第七章 面向对象的编程(OOP)",
      "1 基本概念：对象、类、属性、方法*",
      "2 接口和枚举*",
      "4 封装和信息隐藏*",
      "5 继承和重写*",
      "Overriding*",
      "抽象类",
      "6 多态、子类型、重载*",
      "9 动态分派",
      "10 一些Java中的重要对象方法*",
      "11 设计好的类*",
      "12 OOP历史",
      "第八章 ADT和OOP中的“等价性”",
      "1 等价关系*",
      "2 不可变类型的等价性",
      "3 == 和 equal()*",
      "4 实现equal()",
      "5 对象契约*",
      "6 可变类型的等价性",
      "7 自动封装和等价性",
      "第九章 面向复用的软件构造技术",
      "1 什么是软件复用",
      "2 如何度量可复用性",
      "3 可重用部件的等级和形态",
      "5 设计可复用类*",
      "Liskov替代原则(LSP)*",
      "委派和组成*",
      "6 设计系统级可复用API库和框架",
      "第七章 面向对象的编程(OOP)",
      "1 基本概念：对象、类、属性、方法*",
      "对象：是状态和行为的组合",
      "状态 - 对象中所包含的数据 - 类中的实例变量",
      "行为 - 对象所支持的行为 - 类中的实例方法",
      "类：每个对象都属于某个类，方法定义了类型和实现",
      "类成员变量：一个和类相关而非类的实例相关的变量 - 静态成员变量",
      "类方法：之和类相关的方法 - 静态方法",
      "注：本节为基础知识，需要掌握",
      "2 接口和枚举*",
      "接口(Interface)：一个方法声明的列表",
      "不包含方法体",
      "可以由类实现",
      "接口间可以继承和扩展",
      "一个类可以实现多个接口(从而具备了多个接口中的方法)",
      "一个接口可以有多种实现类",
      "接口 - 确定ADT规范，类 - 实现ADT",
      "可以不需要接口直接使用类作为ADT",
      "既有ADT定义也有ADT实现",
      "但实际中更倾向于使用接口来定义变量",
      "打破了抽象边界",
      "接口定义中没有包含constructor",
      "也无法保证所有实现类中都包含了同样名字的constructor",
      "故而，客户端需要知道该接口的某个具体实现类的名字",
      "可以提供静态工厂方法而非构造函数来向客户端提供具体实现类",
      "接口中每个方法都需要在所有实现它的类中实现",
      "可以通过default关键字修饰方法",
      "在接口中统一实现某些功能",
      "无需在各个类中重复实现它",
      "以增量式的为接口增加额外的功能而不破坏已实现的类",
      "枚举：注：本节了解一下接口就行了",
      "4 封装和信息隐藏*",
      "信息隐藏：区分模块设计好坏的唯一最重要的因素是它对其他模块隐藏内部数据和其他实现细节的程度",
      "设计良好的代码应该能隐藏全部实现细节",
      "通过接口进行信息隐藏：1.使用接口类型声明变量",
      "2.客户端仅使用接口中定义的方法",
      "3.客户端代码无法直接访问属性",
      "权限修饰符：private：只能在类内部进行使用",
      "protected：可以在其子类及同个包中的其他类中使用",
      "public：在所有类中都可以使用",
      "信息隐藏策略：1.认真设计API",
      "2.只提供客户端需要的功能",
      "其他所有成员都应该是private的",
      "3.你可以在不破坏客户端的情况下将任何一个private成员修饰为public",
      "注：本节需要了解权限修饰符的功能",
      "5 继承和重写*",
      "Overriding*",
      "可重写的方法：未加final修饰的方法都可以在子类中重写",
      "即在子类中将该方法重写实现",
      "重写的方法有着和原方法完全相同的声明",
      "实际执行时调用哪个方法",
      "在运行时决定",
      "严格继承：子类只能添加新的方法，无法重写超类中的方法",
      "如果一个方法不能被重写，那它一定以final修饰",
      "通产override的方法都需要在方法声明前添加@override",
      "final作用：1.变量 - 使变量在初始化后不能再改变取值",
      "2.方法 - 避免子类中重写该方法",
      "3.类 - 避免该类被继承",
      "重写时",
      "可以使用super()复用父类中函数的功能",
      "并在后续代码中进行拓展",
      "重写时，不要改变原方法的本意",
      "抽象类",
      "抽象方法：存在有声明",
      "但没有实现的方法",
      "这个方法由abstract关键字修饰",
      "抽象类：存在至少一个抽象方法的类",
      "该类必须由abstract关键字修饰",
      "抽象类不能被实例化",
      "接口可以被认为是只有抽象方法的抽象类",
      "如果某些操作是所有子类型都共有",
      "但彼此有差别",
      "可以在父类型中设计抽象方法",
      "在各子类型中重写",
      "所有子类型完全相同的操作，放在父类型中实现，子类型中无需重写",
      "有些子类型有而其他子类型无的操作",
      "不要在父类型中定义和实现",
      "而应在特定子类型中实现",
      "注：继承、重写是重要概念，必须掌握",
      "6 多态、子类型、重载*",
      "三种多态类型：特殊多态 - 函数重载",
      "参数化多态 - 泛型",
      "子类型多态、包含多态 - 多个子类继承某父类",
      "重载(Overload)：多个方法具有同样的名字",
      "但有不同的参数列表或返回值类型",
      "价值：方便客户端使用",
      "客户端可用不同的参数列表",
      "调用同样的函数",
      "重载时一种静态多态：进行静态类型检查",
      "根据参数列表进行最佳匹配",
      "在编译阶段时决定要具体执行哪个方法",
      "重载规则：1.必须有不同的参数列表",
      "2.可以有相同/不同的返回值类型",
      "3.可以有相同/不同的权限修饰符",
      "4.可以有新的或更广泛的检查异常",
      "5.可以在同一个类内重载，也可以在子类中重载",
      "重写(Override)则是在运行时进行动态检查",
      "根据内存中对象的具体类型来调用对应方法",
      "泛型：以泛型方式定义函数和类型",
      "以便基于运行时传递的参数工作",
      "即允许静态类型化而不完全指定类型",
      "泛型编程：是一种编程风格",
      "其中数据类型和函数用稍后指定的类型编写",
      "然后在需要时对作为参数提供的特定类型进行实例化",
      "类型变量：未指定的变量类型",
      "泛型类：类定义中包含了类型变量",
      "泛型接口：接口定义中包含了类型变量",
      "泛型方法：方法定义中包含了类型变量",
      "泛型的其他性质：子类型：若B是A的子类型",
      "意味着每一个B类型的变量都可以被当作A类型",
      "B是A的子类型当且仅当B的Spec至少和A一样强",
      "子类型的规约不能弱化父类型的规约",
      "子类型多态：不同类型的对象可以统一的处理而无需区分",
      "注：重载、重写应该掌握",
      "泛型应该了解一下",
      "子类型多态需要注意对子类型spec的要求",
      "9 动态分派",
      "动态分派：确定要在运行时调用的方法",
      "即在运行时解析对已覆盖或多态方法的调用",
      "静态分派：重载的方法使用静态绑定绑定",
      "而重载的方法在运行时使用动态绑定绑定",
      "10 一些Java中的重要对象方法*",
      "equals方法：当两个对象等价时返回true",
      "应满足对称、自反、传递的性质",
      "hashCode方法：返回在哈希映射中使用的哈希代码",
      "toString方法：返回一个可打印的字符串表示",
      "注：应重点关注equal方法",
      "11 设计好的类*",
      "不可变类的优点：简单、固有线程安全、可以自由共享、不需要防御拷贝、优秀的构建块",
      "如何写不可变类：1.不提供任何mutator",
      "2.确保方法都不会被重写",
      "3.使所有变量均被final修饰",
      "4.使所有变量均被private修饰",
      "5.确保任何可变类型的组成部分的安全性(避免表示泄露)",
      "6.实现toString()、hashCode()、equals()等方法",
      "注：需要学会怎么设计不可变的类",
      "12 OOP历史",
      "第八章 ADT和OOP中的“等价性”",
      "1 等价关系*",
      "ADT是对数据的抽象，体现为一组对数据的操作",
      "抽象函数AF：内部表示->抽象表示",
      "基于抽象函数AF定义ADT的等价操作",
      "等价关系：自反、对称、传递",
      "注：需要理解什么是等价关系",
      "2 不可变类型的等价性",
      "如果AF映射到相同的结果，则等价",
      "站在外部观察者的角度",
      "对两个对象调用任何相同的操作",
      "都会得到相同的结果",
      "则认为两个对象是等价的",
      "反之亦然",
      "3 == 和 equal()*",
      "== 运算符比较的是对象的引用",
      "两个对象指向同一个内存空间时",
      "则说明这两个对象具有引用等价性",
      "equal()方法比较的是对象的内容，即对象等价性",
      "在自定义ADT时，需要重写Object的equals()",
      "== 通常用于对基本数据类型判断是否相等",
      "equal()用于判断对象类型是否等价",
      "注：需要了解如何区分两者区别",
      "4 实现equal()",
      "在Object中缺省equals()是在判断引用等价性",
      "所以一般需要重写",
      "equal方法如果接受的参数不是Object类型则实现不是override而是overload",
      "instanceof运算符可以判断某一变量所指向内存是否属于某各类型(动态检查)",
      "5 对象契约*",
      "equal方法满足的契约：1.等价关系：自反、对称、传递",
      "2.除非对象被修改了，否则调用多次equals应有同样的结果",
      "3.对于非null引用x",
      "x.equals(null)应返回false",
      "4.等价的对象，其hashCode()的结果必须相同",
      "哈希表：等价的对象必须有相同的hashCode",
      "但不等价的对象也可以有相同的hashCode",
      "不够性能会变差",
      "重载hashCode()：注：主要关注equals()方法",
      "6 可变类型的等价性",
      "观察等价性：在不改变状态的情况下",
      "两个mutable对象是否看起来一致",
      "行为等价性：调用对象的任何方法都展示出一致的结果",
      "可以认为就是引用等价性",
      "对可变类型来说",
      "往往倾向于实现严格的观察等价性",
      "但有时候观察等价性可能导致bug",
      "甚至可能破坏RI",
      "在hashSet等类型中",
      "其内部的可变数据类型发生改变时",
      "hashCode会改变",
      "导致hashSet的contains方法会判断集合中改变过的内容不属于集合",
      "7 自动封装和等价性",
      "第九章 面向复用的软件构造技术",
      "1 什么是软件复用",
      "软件复用是使用现有软件组件实现或更新软件系统的过程",
      "软件复用的两个视角：1.面向复用编程(Creation)：开发出可复用的软件",
      "2.基于复用编程(Use)：利用已有的可复用软件搭建应用系统",
      "复用好处：1.降低成本和开发时间",
      "2.经过充分测试，可靠、稳定",
      "3.标准化，在不同应用中保持一致",
      "2 如何度量可复用性",
      "从以下几个角度度量：1.复用的机会有多频繁？复用的场合有多少？",
      "2.复用的代价有多大？",
      "3 可重用部件的等级和形态",
      "最主要的复用是在代码层面",
      "但软件构造过程中的任何实体都可能被复用 - 需求、设计/规约、数据、测试用例、文档",
      "白盒复用：源代码可见",
      "可修改和拓展 - 复制已有代码到正在开发的系统",
      "进行修改",
      "优点：可定制化程度高",
      "缺点：对其修改增加了软件的复杂度，且需要对其内部充分的了解",
      "黑盒复用：源代码不可见",
      "不能修改 - 只能通过API接口来使用",
      "无法修改代码",
      "优点：简单、清晰",
      "缺点：适应性差些",
      "复用一个类的方法：1.继承：子类可以对父类中的属性、方法等进行复用",
      "2.委派：在一个类中使用其他类的方法来实现自己的功能",
      "框架：一组具体类、抽象类、及其之间的连接关系",
      "开发者根据framework的规约",
      "填充自己的代码进去",
      "形成完整系统",
      "白盒框架：通过代码层面的继承进行框架拓展",
      "黑盒框架：通过实现特定接口/delegation进行框架拓展",
      "5 设计可复用类*",
      "Liskov替代原则(LSP)*",
      "子类型多态：客户端可用统一的方式处理不同类型的对象",
      "在Java中的编译器强制执行的规则：1.子类型可以增加方法",
      "但不可以删",
      "2.子类型中需要实现抽象类型中的所有未实现方法",
      "3.子类型中重写的方法必须返回相同的类型或其子类型(满足协变)",
      "4.子类型中重写的方法必须接收相同的参数类型(满足逆变)",
      "5.子类型中重写的方法不能抛出额外的异常",
      "LSP原则：子类方法必须相比于父类方法有着相同或更强的不变量",
      "相同或更弱的前置条件",
      "相同或更强的后置条件",
      "才能使子类无条件地可以替代父类",
      "LSP是子类型关系的一个特殊定义，称为（强）行为子类型",
      "LSP依赖于以下限制：1.前置条件不能强化",
      "2.后置条件不能弱化",
      "3.不变量要保持",
      "4.子类型方法参数：逆变",
      "5.子类型方法返回值：协变",
      "6.异常类型：协变",
      "协变：随着父类型到子类型越来越具体",
      "对于返回值类型而言",
      "不变或变得更具体",
      "异常的类型也是如此",
      "逆变：随着父类型到子类型越来越具体",
      "参数类型会相反地变化",
      "要不变或者越来越抽象",
      "(目前Java中这种情况会被视作overload)",
      "数组是协变的：根据Java的子类型规则",
      "一个类型T的数组可以容纳类型T和其子类型的变量",
      "泛型不是协变的",
      "ArrayList是List的子类型",
      "但List不是类型List的泛型",
      "泛型中的通配符：委派和组成*",
      "以排序为例",
      "如果你的ADT需要比较大小",
      "或者要放入Collections或Array进行排序",
      "可实现Comparator接口构建比较器并override compare方法或者实现Comparable接口拓展ADT并override compareTo方法(不需要构建新的Comparator类",
      "比较代码防止ADT内部)",
      "上述例子中",
      "Comparator属于delegation",
      "而Comparable不属于delegation",
      "委派：一个对象请求另一个对象的功能",
      "委派是代码复用的一种常见形式",
      "显式委派：将发送对象传递给接收对象",
      "隐式委派：通过成员查找规则",
      "委派模式：通过运动时动态绑定，实现对其他类中代码的动态复用",
      "委派和继承：继承通过拓展基类来添加新操作或重写某操作",
      "委派通过捕捉某个行为，并将其发送给另一个对象",
      "很多设计模式都使用两者组合",
      "如果子类只需要复用父类中的一小部分方法",
      "则可以不需要使用继承",
      "而是通过委派机制来实现",
      "一个类不需要继承另一个类的全部方法时",
      "可以通过委派机制调用部分方法",
      "从而避免大量无用方法",
      "委托发生在object层面，而继承发生在class层面",
      "组合复用原则(CRP)：类应该通过其组合（通过包含实现所需功能的其他类的实例）来实现代码重用",
      "而不是从基类或父类继承来实现多态行为和代码重用",
      "CRP原则的思路：1.使用接口定义系统必须对外展示的不同侧面的行为",
      "2.接口之间通过extends实现行为的扩展（接口组合）",
      "3.类implements 组合接口",
      "从而规避了复杂的继承关系",
      "delegation的类型：1.Dependency:临时性的delegation(作为方法的参数使用)",
      "Dependency：对象需要其他对象（供应者）才能实现的临时关系",
      "2.Assosiation:永久性的delegation(作为对象的属性使用)",
      "Assosiation：对象类之间的持久关系",
      "允许一个对象实例代表另一个对象实例执行操作",
      "3.Composition:更强的assosiation",
      "但难以变化(属性通过内部各方法进行初始化、修改等)",
      "Composition：是一种将简单的对象或数据类型组合成更复杂的数据类型的方法",
      "4.Aggregation:更弱的assosiation",
      "可动态变化(属性通过外部方法进行修改)",
      "Aggregation：对象存在于另一个外部",
      "在外部创建",
      "因此它作为参数传递给解释器",
      "这四种类型都支持一对多的delegation",
      "注：本节为重点",
      "需要理解LSP、CRP、继承、委派等概念的含义",
      "并会分析及写相应代码",
      "6 设计系统级可复用API库和框架",
      "库：提供可复用功能的类和方法的集合"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "注：文章中带有 * 的标题表示往年考试中出现过相应考点\n文章目录\n第七章 面向对象的编程(OOP)\n1 基本概念：对象、类、属性、方法*\n2 接口和枚举*\n4 封装和信息隐藏*\n5 继承和重写*\nOverriding*\n抽象类\n6 多态、子类型、重载*\n9 动态分派\n10 一些Java中的重要对象方法*\n11 设计好的类*\n12 OOP历史\n第八章 ADT和OOP中的“等价性”\n1 等价关系*\n2 不可变类型的等价性\n3 == 和 equal()*\n4 实现equal()\n5 对象契约*\n6 可变类型的等价性\n7 自动封装和等价性\n第九章 面向复用的软件构造技术\n1 什么是软件复用\n2 如何度量可复用性\n3 可重用部件的等级和形态\n5 设计可复用类*\nLiskov替代原则(LSP)*\n委派和组成*\n6 设计系统级可复用API库和框架\n第七章 面向对象的编程(OOP)\n1 基本概念：对象、类、属性、方法*\n对象：是状态和行为的组合\n状态 - 对象中所包含的数据 - 类中的实例变量\n行为 - 对象所支持的行为 - 类中的实例方法\n类：每个对象都属于某个类，方法定义了类型和实现\n类成员变量：一个和类相关而非类的实例相关的变量 - 静态成员变量\n类方法：之和类相关的方法 - 静态方法\n注：本节为基础知识，需要掌握\n2 接口和枚举*\n接口(Interface)：一个方法声明的列表，不包含方法体，可以由类实现\n接口间可以继承和扩展\n一个类可以实现多个接口(从而具备了多个接口中的方法)\n一个接口可以有多种实现类\n接口 - 确定ADT规范，类 - 实现ADT\n可以不需要接口直接使用类作为ADT，既有ADT定义也有ADT实现\n但实际中更倾向于使用接口来定义变量\n打破了抽象边界，接口定义中没有包含constructor，也无法保证所有实现类中都包含了同样名字的constructor。\n故而，客户端需要知道该接口的某个具体实现类的名字。可以提供静态工厂方法而非构造函数来向客户端提供具体实现类。\n接口中每个方法都需要在所有实现它的类中实现\n可以通过default关键字修饰方法，在接口中统一实现某些功能，无需在各个类中重复实现它\n以增量式的为接口增加额外的功能而不破坏已实现的类\n枚举：\n注：本节了解一下接口就行了\n4 封装和信息隐藏*\n信息隐藏：区分模块设计好坏的唯一最重要的因素是它对其他模块隐藏内部数据和其他实现细节的程度，设计良好的代码应该能隐藏全部实现细节\n通过接口进行信息隐藏：\n1.使用接口类型声明变量\n2.客户端仅使用接口中定义的方法\n3.客户端代码无法直接访问属性\n权限修饰符：\nprivate：只能在类内部进行使用\nprotected：可以在其子类及同个包中的其他类中使用\npublic：在所有类中都可以使用\n信息隐藏策略：\n1.认真设计API\n2.只提供客户端需要的功能，其他所有成员都应该是private的\n3.你可以在不破坏客户端的情况下将任何一个private成员修饰为public\n注：本节需要了解权限修饰符的功能\n5 继承和重写*\nOverriding*\n可重写的方法：未加final修饰的方法都可以在子类中重写，即在子类中将该方法重写实现，重写的方法有着和原方法完全相同的声明，实际执行时调用哪个方法，在运行时决定\n严格继承：子类只能添加新的方法，无法重写超类中的方法\n如果一个方法不能被重写，那它一定以final修饰\n通产override的方法都需要在方法声明前添加@override\nfinal作用：\n1.变量 - 使变量在初始化后不能再改变取值\n2.方法 - 避免子类中重写该方法\n3.类 - 避免该类被继承\n重写时，可以使用super()复用父类中函数的功能，并在后续代码中进行拓展\n重写时，不要改变原方法的本意\n抽象类\n抽象方法：存在有声明，但没有实现的方法，这个方法由abstract关键字修饰\n抽象类：存在至少一个抽象方法的类，该类必须由abstract关键字修饰，抽象类不能被实例化\n接口可以被认为是只有抽象方法的抽象类\n如果某些操作是所有子类型都共有，但彼此有差别，可以在父类型中设计抽象方法，在各子类型中重写。\n所有子类型完全相同的操作，放在父类型中实现，子类型中无需重写。\n有些子类型有而其他子类型无的操作，不要在父类型中定义和实现，而应在特定子类型中实现。\n注：继承、重写是重要概念，必须掌握\n6 多态、子类型、重载*\n三种多态类型：\n特殊多态 - 函数重载\n参数化多态 - 泛型\n子类型多态、包含多态 - 多个子类继承某父类\n重载(Overload)：多个方法具有同样的名字，但有不同的参数列表或返回值类型\n价值：方便客户端使用，客户端可用不同的参数列表，调用同样的函数\n重载时一种静态多态：进行静态类型检查，根据参数列表进行最佳匹配，在编译阶段时决定要具体执行哪个方法\n重载规则：\n1.必须有不同的参数列表\n2.可以有相同/不同的返回值类型\n3.可以有相同/不同的权限修饰符\n4.可以有新的或更广泛的检查异常\n5.可以在同一个类内重载，也可以在子类中重载\n重写(Override)则是在运行时进行动态检查，根据内存中对象的具体类型来调用对应方法\n泛型：以泛型方式定义函数和类型，以便基于运行时传递的参数工作，即允许静态类型化而不完全指定类型。\n泛型编程：是一种编程风格，其中数据类型和函数用稍后指定的类型编写，然后在需要时对作为参数提供的特定类型进行实例化。\n类型变量：未指定的变量类型\n泛型类：类定义中包含了类型变量\n泛型接口：接口定义中包含了类型变量\n泛型方法：方法定义中包含了类型变量\n泛型的其他性质：\n子类型：若B是A的子类型，意味着每一个B类型的变量都可以被当作A类型\nB是A的子类型当且仅当B的Spec至少和A一样强，子类型的规约不能弱化父类型的规约\n子类型多态：不同类型的对象可以统一的处理而无需区分\n注：重载、重写应该掌握，泛型应该了解一下，子类型多态需要注意对子类型spec的要求\n9 动态分派\n动态分派：确定要在运行时调用的方法，即在运行时解析对已覆盖或多态方法的调用\n静态分派：重载的方法使用静态绑定绑定，而重载的方法在运行时使用动态绑定绑定。\n10 一些Java中的重要对象方法*\nequals方法：当两个对象等价时返回true，应满足对称、自反、传递的性质\nhashCode方法：返回在哈希映射中使用的哈希代码\ntoString方法：返回一个可打印的字符串表示\n注：应重点关注equal方法\n11 设计好的类*\n不可变类的优点：简单、固有线程安全、可以自由共享、不需要防御拷贝、优秀的构建块\n如何写不可变类：\n1.不提供任何mutator\n2.确保方法都不会被重写\n3.使所有变量均被final修饰\n4.使所有变量均被private修饰\n5.确保任何可变类型的组成部分的安全性(避免表示泄露)\n6.实现toString()、hashCode()、equals()等方法\n注：需要学会怎么设计不可变的类\n12 OOP历史\n第八章 ADT和OOP中的“等价性”\n1 等价关系*\nADT是对数据的抽象，体现为一组对数据的操作\n抽象函数AF：内部表示->抽象表示\n基于抽象函数AF定义ADT的等价操作\n等价关系：自反、对称、传递\n注：需要理解什么是等价关系\n2 不可变类型的等价性\n如果AF映射到相同的结果，则等价\n站在外部观察者的角度，对两个对象调用任何相同的操作，都会得到相同的结果，则认为两个对象是等价的，反之亦然\n3 == 和 equal()*\n== 运算符比较的是对象的引用，两个对象指向同一个内存空间时，则说明这两个对象具有引用等价性\nequal()方法比较的是对象的内容，即对象等价性\n在自定义ADT时，需要重写Object的equals()\n== 通常用于对基本数据类型判断是否相等，equal()用于判断对象类型是否等价\n注：需要了解如何区分两者区别\n4 实现equal()\n在Object中缺省equals()是在判断引用等价性，所以一般需要重写\nequal方法如果接受的参数不是Object类型则实现不是override而是overload\ninstanceof运算符可以判断某一变量所指向内存是否属于某各类型(动态检查)\n5 对象契约*\nequal方法满足的契约：\n1.等价关系：自反、对称、传递\n2.除非对象被修改了，否则调用多次equals应有同样的结果\n3.对于非null引用x，x.equals(null)应返回false\n4.等价的对象，其hashCode()的结果必须相同\n哈希表：\n等价的对象必须有相同的hashCode，但不等价的对象也可以有相同的hashCode，不够性能会变差\n重载hashCode()：\n注：主要关注equals()方法\n6 可变类型的等价性\n观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致\n行为等价性：调用对象的任何方法都展示出一致的结果，可以认为就是引用等价性\n对可变类型来说，往往倾向于实现严格的观察等价性，但有时候观察等价性可能导致bug，甚至可能破坏RI\n在hashSet等类型中，其内部的可变数据类型发生改变时，hashCode会改变，导致hashSet的contains方法会判断集合中改变过的内容不属于集合\n7 自动封装和等价性\n第九章 面向复用的软件构造技术\n1 什么是软件复用\n软件复用是使用现有软件组件实现或更新软件系统的过程\n软件复用的两个视角：\n1.面向复用编程(Creation)：开发出可复用的软件\n2.基于复用编程(Use)：利用已有的可复用软件搭建应用系统\n复用好处：\n1.降低成本和开发时间\n2.经过充分测试，可靠、稳定\n3.标准化，在不同应用中保持一致\n2 如何度量可复用性\n从以下几个角度度量：\n1.复用的机会有多频繁？复用的场合有多少？\n2.复用的代价有多大？\n3 可重用部件的等级和形态\n最主要的复用是在代码层面，但软件构造过程中的任何实体都可能被复用 - 需求、设计/规约、数据、测试用例、文档\n白盒复用：源代码可见，可修改和拓展 - 复制已有代码到正在开发的系统，进行修改\n优点：可定制化程度高\n缺点：对其修改增加了软件的复杂度，且需要对其内部充分的了解\n黑盒复用：源代码不可见，不能修改 - 只能通过API接口来使用，无法修改代码\n优点：简单、清晰\n缺点：适应性差些\n复用一个类的方法：\n1.继承：子类可以对父类中的属性、方法等进行复用\n2.委派：在一个类中使用其他类的方法来实现自己的功能\n框架：一组具体类、抽象类、及其之间的连接关系\n开发者根据framework的规约，填充自己的代码进去，形成完整系统\n白盒框架：通过代码层面的继承进行框架拓展\n黑盒框架：通过实现特定接口/delegation进行框架拓展\n5 设计可复用类*\nLiskov替代原则(LSP)*\n子类型多态：客户端可用统一的方式处理不同类型的对象\n在Java中的编译器强制执行的规则：\n1.子类型可以增加方法，但不可以删\n2.子类型中需要实现抽象类型中的所有未实现方法\n3.子类型中重写的方法必须返回相同的类型或其子类型(满足协变)\n4.子类型中重写的方法必须接收相同的参数类型(满足逆变)\n5.子类型中重写的方法不能抛出额外的异常\nLSP原则：子类方法必须相比于父类方法有着相同或更强的不变量，相同或更弱的前置条件，相同或更强的后置条件，才能使子类无条件地可以替代父类。\nLSP是子类型关系的一个特殊定义，称为（强）行为子类型\nLSP依赖于以下限制：\n1.前置条件不能强化\n2.后置条件不能弱化\n3.不变量要保持\n4.子类型方法参数：逆变\n5.子类型方法返回值：协变\n6.异常类型：协变\n协变：随着父类型到子类型越来越具体，对于返回值类型而言，不变或变得更具体，异常的类型也是如此\n逆变：随着父类型到子类型越来越具体，参数类型会相反地变化，要不变或者越来越抽象\n(目前Java中这种情况会被视作overload)\n数组是协变的：根据Java的子类型规则，一个类型T的数组可以容纳类型T和其子类型的变量\n泛型不是协变的，ArrayList是List的子类型，但List不是类型List的泛型\n泛型中的通配符：\n委派和组成*\n以排序为例，如果你的ADT需要比较大小，或者要放入Collections或Array进行排序，可实现Comparator接口构建比较器并override compare方法或者实现Comparable接口拓展ADT并override compareTo方法(不需要构建新的Comparator类，比较代码防止ADT内部)\n上述例子中，Comparator属于delegation，而Comparable不属于delegation\n委派：一个对象请求另一个对象的功能，委派是代码复用的一种常见形式\n显式委派：将发送对象传递给接收对象\n隐式委派：通过成员查找规则\n委派模式：通过运动时动态绑定，实现对其他类中代码的动态复用\n委派和继承：\n继承通过拓展基类来添加新操作或重写某操作\n委派通过捕捉某个行为，并将其发送给另一个对象\n很多设计模式都使用两者组合\n如果子类只需要复用父类中的一小部分方法，则可以不需要使用继承，而是通过委派机制来实现\n一个类不需要继承另一个类的全部方法时，可以通过委派机制调用部分方法，从而避免大量无用方法\n委托发生在object层面，而继承发生在class层面\n组合复用原则(CRP)：类应该通过其组合（通过包含实现所需功能的其他类的实例）来实现代码重用，而不是从基类或父类继承来实现多态行为和代码重用。\nCRP原则的思路：\n1.使用接口定义系统必须对外展示的不同侧面的行为\n2.接口之间通过extends实现行为的扩展（接口组合）\n3.类implements 组合接口，从而规避了复杂的继承关系\ndelegation的类型：\n1.Dependency:临时性的delegation(作为方法的参数使用)\nDependency：对象需要其他对象（供应者）才能实现的临时关系\n2.Assosiation:永久性的delegation(作为对象的属性使用)\nAssosiation：对象类之间的持久关系，允许一个对象实例代表另一个对象实例执行操作。\n3.Composition:更强的assosiation，但难以变化(属性通过内部各方法进行初始化、修改等)\nComposition：是一种将简单的对象或数据类型组合成更复杂的数据类型的方法\n4.Aggregation:更弱的assosiation，可动态变化(属性通过外部方法进行修改)\nAggregation：对象存在于另一个外部，在外部创建，因此它作为参数传递给解释器。\n这四种类型都支持一对多的delegation\n注：本节为重点，需要理解LSP、CRP、继承、委派等概念的含义，并会分析及写相应代码\n6 设计系统级可复用API库和框架\n库：提供可复用功能的类和方法的集合\n"
  },
  {
    "head": "软件构造复习笔记(2)",
    "paragraphs": [
      "注：文章中带有 * 的标题表示往年考试中出现过相应考点",
      "文章目录",
      "第四章 数据类型与类型检验",
      "1 编程语言中的数据类型*",
      "2 静态、动态类型检查*",
      "3 可变性、不可变性*",
      "4 Snapshot diagram*",
      "5 复杂数据类型-Arrays和Collections*",
      "6 有用的不可变数据类型*",
      "第五章 设计规约",
      "1 编程语言中的函数、方法*",
      "2 规约：面向交流编程*",
      "行为等价性",
      "规约结构 - 前置条件和后置条件*",
      "3 设计规约*",
      "规约性质*",
      "规约图",
      "设计好的规约*",
      "第六章 抽象数据类型(ADT)",
      "1 抽象与用户定义的类型",
      "2 对类型和操作进行分类*",
      "3 抽象数据类型例子",
      "4 设计一个抽象类型*",
      "5 表示独立性",
      "6 对ADT的测试",
      "7 不变量*",
      "8 表示不变性和抽象函数*",
      "9 有益的可变性",
      "10 记录AF、RI、以及防止表示泄露的方法*",
      "11 ADT不变量替代前置条件",
      "第四章 数据类型与类型检验",
      "1 编程语言中的数据类型*",
      "基本数据类型： int、boolean等",
      "对象数据类型：String、Integer等",
      "注：本节简单看看就行了，考也是大题里穿插考",
      "2 静态、动态类型检查*",
      "静态类型语言：在编译阶段进行类型检查",
      "动态类型语言：在运行阶段进行类型检查",
      "静态类型检查 >> 动态 >> 无检查",
      "静态类型检查：可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性",
      "静态检查：关于“类型”的检查，不考虑值",
      "动态检查：关于“值”的检查",
      "注：本节看一遍就行了，需要知道怎么找错，就考过选择，",
      "3 可变性、不可变性*",
      "改变一个变量：将该变量指向另一个值的存储空间",
      "改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。",
      "尽可能避免变化，以避免副作用",
      "不变性：重要设计原则",
      "不变数据类型：一旦被创建，其值不能改变，使用final关键字修饰，如果是引用类型，也可以是不变的，即一旦确定其指向的对象，指向不能再被改变",
      "如果编译器无法确定final变量不会改变，就提示错误，这也是静态类型检查的一部分。",
      "尽量使用final变量作为方法的输入参数、作为局部变量。",
      "注意：",
      "1.final类无法派生子类",
      "2.final变量无法改变值/引用",
      "3.final方法无法被子类重写",
      "不变对象：一旦被创建，始终指向同一个值/引用(这个对象内部的各个属性都不能修改)",
      "可变对象：拥有方法可以修改自己的值/引用",
      "Immutable数据类型例子：String",
      "String类型不可变，所以一个String对象在其生命周期中只能有一个值",
      "为了向一个String对象末尾添加元素，将重新创建一个新的String对象",
      "Mutable数据类型例子：StringBuilder",
      "StringBuilder有插入、删除、替代字符等方法修改对象内部的值因此它是可变数据类型",
      "String和StringBuilder区别：",
      "当只有一个引用指向该值时，没有区别",
      "有多个引用的时候，差异就出现了",
      "可变数据类型的优点：",
      "1.使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)",
      "2.可变类型最少化拷贝以提高效率",
      "3.使用可变数据类型，可获得更好的性能",
      "4.可变数据类型也适合于在多个模块之间共享数据",
      "可变数据类型的风险：",
      "传递可变值时，函数可能超过spec的范畴，因为它可能会改变输入参数的值",
      "返回可变值时，后续对返回值的操作可能会影响全局变量的值",
      "解决方案：",
      "1.通过防御式拷贝，给客户端返回一个副本",
      "2.安全地使用可变类型：局部变量，不会涉及共享；同一时间只有一个引用",
      "注：本节需要掌握怎么区分可变和不可变数据类型，还得会画相应的snapshot diagram",
      "4 Snapshot diagram*",
      "作用：用于描述程序运行时的内部状态",
      "画法：",
      "注：本节经常在大题中考如何画snapshot diagram，需要会画",
      "5 复杂数据类型-Arrays和Collections*",
      "数组：数组定长，一旦被创建，其长度不可改变",
      "列表：List是类型T的可变长序列",
      "数组和List的迭代：",
      "集合：零个或多个唯一对象的无序集合",
      "映射：类似与字典，使用键值对存储，一个键只能对应一个值",
      "List、Set、Map都是接口，使用时需要用其具体实现类ArrayList、HashSet、HashMap等",
      "迭代器：",
      "可变数据类型使用迭代器时，不可添加元素，若想删除元素，必须调用对应迭代器的remove方法。",
      "注：本节是大题的基本知识，应该掌握",
      "6 有用的不可变数据类型*",
      "基本类型及其封装对象类型都是不可变的",
      "Collections类中有将可变Collections转化为不可变类型的方法：",
      "其参数为要转化的Collection，这种包装器得到的结果是不可变的，只能看",
      "但是这种“不可变”是在运行阶段获得的，编译阶段无法据此进行静态检查",
      "注：本节考过选择题，看看就行了",
      "第五章 设计规约",
      "1 编程语言中的函数、方法*",
      "方法：",
      "参数类型是否匹配，在静态类型检查阶段完成",
      "返回值类型是否匹配，也在静态类型检查阶段完成",
      "方法是程序的\"积木\"，可以被独立开发、测试、复用",
      "使用方法的客户端，无需了解方法内部具体如何工作 - “抽象”",
      "完整方法示例：",
      "注：大题一定会考写方法，学过编程语言的应该都会，看看就行了",
      "2 规约：面向交流编程*",
      "例子，JAVA API文档：",
      "把对某个变量所做出的假设写下来，例如，假定某一变量必须指向Integer",
      "final关键字也算假设，它定义了不可改变的设计决策",
      "为什么要写出假设？一，自己记不住 二，别人看不懂",
      "代码中蕴含的“设计决策” - 给编译器读",
      "注释形式的“设计决策” - 给自己和别人读",
      "没规约，没法写程序，即使写出来，也不知道对错",
      "规约也是程序与客户端之间达成的一致",
      "Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守",
      "很多bug来自于双方间的误解",
      "不写下来，那么不同开发者的理解可能就不同",
      "没有规约，难以定位错误",
      "规约优点：",
      "1.精确的规约，有助于区分责任",
      "2.客户端无需阅读调用函数的代码，只需理解spec即可",
      "例子：",
      "规约可以隔离“变化”，无需通知客户端",
      "规约也可以提高代码效率",
      "规约也扮演了用户和实现者之间的防火墙，用户不需要了解具体实现",
      "规约只讲“能做什么”，不讲“怎么实现”",
      "行为等价性",
      "行为等价性：两个事物是否可以相互替换",
      "要站在客户端的视角看待行为等价性",
      "根据规约判断是否行为等价，如果两个函数符合这个规约，那他们对于这个规约而言就等价",
      "规约结构 - 前置条件和后置条件*",
      "前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "后置条件：对开发者的约束，方法结束时必须满足的条件",
      "契约：如果前置条件满足了，后置条件必须满足，若前置条件不满足，则方法可以做任何事情",
      "静态类型声明是一种规约，可据此进行静态类型检查。方法前的注释也是一种规约，但需人工判定其是否满足",
      "除非在后置条件里声明过，否则方法内部不应该改变输入参数",
      "应尽量遵循此规则，尽量不设计mutating的spec，否则容易引发bug",
      "原因：程序中可以有多个变量指向用一个可变对象(别名)，无法强迫类的实现体和客户端不保存可变变量的别名",
      "注：本节只需要看一遍就行，可能考选择",
      "3 设计规约*",
      "规约性质*",
      "规约的三条性质：确定性、陈述性、强度",
      "强度：",
      "当规约S2相比S1的前置条件更弱，后置条件更强时，则称规约S2的强度强于S1，就可以用S2替代S1",
      "Spec变强：更放松的前置条件 + 更严格的后置条件",
      "例子：",
      "确定性：",
      "明确的规约：给定一个满足前置条件的输入，其输出是唯一的、明确的",
      "欠定的规约：同一个输入可以有多个输出",
      "非确定的规约：同一个输入，多次执行时得到的输出可能不同",
      "欠定通常可认为等价于非确定，但欠定的规约通常有确定的实现",
      "陈述性：",
      "操作式规约：给出方法进行的一系列步骤，例如伪代码",
      "声明式规约： 没有内部实现的描述，只有“初 - 终”状态",
      "声明式规约更有价值，通常不使用操作式规约，内部实现的细节通常放在实现体内部注释中",
      "规约图",
      "设计好的规约*",
      "好的规约应该易于阅读，应该有以下几个性质：",
      "1.内聚的：Spec描述的功能应单一、简单、易理解",
      "2.信息丰富的：不能让客户端产生理解的歧义",
      "3.足够健壮的：开发者应尽可能考虑各种特殊情况，在后置条件中给出处理措施",
      "4.足够虚弱的：太强的spec在很多特殊情况下难以达到，给开发者增加了实现的难度",
      "5.使用抽象类型：在规约里使用抽象类型，可以给方法的实现体与客户端更大的自由度",
      "6.前置后置条件选取：",
      "*注：本节主要需要重点掌握怎么写spec以及spec的前置、后置条件强度的比较等 *",
      "第六章 抽象数据类型(ADT)",
      "1 抽象与用户定义的类型",
      "除了编程语言所提供的基本数据类型和对象数据类型，程序员可定义自己的数据类型",
      "数据抽象：由一组操作所刻画的数据结构，而非传统意义上关注数据的具体表示",
      "抽象类型：强调“作用于数据上的操作”，程序员和客户端无需关心数据如何具体存储，只需设计/使用操作即可。",
      "一个抽象数据类型由它的操作所定义，与其内部实现无关",
      "2 对类型和操作进行分类*",
      "对类型的分类：",
      "可变类型的对象：提供了可改变其内部数据的值的操作",
      "不可变数据类型：其操作不改变内部值，而是构造新的对象",
      "对操作的分类：",
      "构造器(Creator)：创造ADT的新对象",
      "生产器(Producer)：提供ADT以前的对象创造新的对象",
      "观察器(Observer)：获取抽象类型的对象，并返回不同类型的对象",
      "变值器(Mutator)：改变对象属性的方法",
      "构造器可能实现为构造函数或静态函数，实施为静态函数的通常被称作工厂方法",
      "变值器通常返回void，如果返回值为void，则必然意味着它改变了对象的某些内部状态",
      "变值器也可能返回非空类型，例如返回boolean，判断操作是否成功",
      "注：本节需要掌握如何判断某一方法有可能属于哪种，建议关注一下静态工厂方法",
      "3 抽象数据类型例子",
      "4 设计一个抽象类型*",
      "设计好的ADT，靠“经验法则”，提供一组操作，设计其行为规约spec",
      "以下是几个设计规则：",
      "1.设计简洁、一致的操作",
      "2.要足以支持客户端对数据所做的所有操作需要，且用操作满足客户端需要的难度要低",
      "3.要么抽象、要么具体，不要混合 - 要么针对抽象设计，要么针对具体应用的设计",
      "注：本节内容理解就行，考试必考ADT设计",
      "5 表示独立性",
      "表示独立性(RI)：客户端使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端",
      "除非ADT的操作指明了具体的前置和后置条件，否则不能改变ADT的内部表示 - spec规定了客户端和实现者之间的契约",
      "6 对ADT的测试",
      "测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；",
      "测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。",
      "风险：如果被依赖的其他方法有错误，可能导致被测试方法的测试结果失效。",
      "7 不变量*",
      "不变量(invariants)：在任何时候都是true",
      "由ADT来负责其不变量，与client端的任何行为无关",
      "为什么需要不变量：保持程序的“正确性”，容易发现错误",
      "总是要假设客户端有“恶意”破坏ADT的不变量",
      "除非迫不得已，否则不要把希望寄托于客户端上，ADT有责任保证自己的invariants，并避免“表示泄露”。",
      "最好的办法就是使用immutable的类型，彻底避免表示泄露",
      "保持不变性和避免表示泄漏，是ADT最重要的一个Invariant！",
      "注：本节简单理解一下就行了",
      "8 表示不变性和抽象函数*",
      "抽象值构成的空间：用户端看到和使用的值",
      "ADT开发者关注表示空间R，client关注抽象空间A",
      "抽象函数：R和A之间映射关系的函数，即如何去解释R中每一个值为A中的每一个值",
      "抽象函数性质：",
      "1.满射：每一个抽象值都必须被某个表示值所映射",
      "2.未必单射：某个抽象值可能由超过一个表示值映射",
      "3.未必双射：不是所有表示值都需要有映射，R中部分值并非合法的，在A中无映射值",
      "RI : R → boolean",
      "表示不变性(RI通常指的是这个)：某个具体的“表示”是否是“合法的”",
      "也可以将RI看作：所有表示值的一个子集，包含了所有合法的表示值",
      "也可将RI看作：一个条件，描述了什么是“合法”的表示值",
      "RI和AF都是作为注释写在代码中的，通常写在rep下方",
      "不同的内部表示，需要设计不同的AF和RI，即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。",
      "编写过程：选择某种特定的表示方式R，进而指定某个子集是“合法”的(RI)，并为该子集中的每个值做出“解释”(AF)——即如何映射到抽象空间中的值。",
      "在实现中通常有一个checkRep方法，在所有可能改变rep的方法内检查RI是否被满足",
      "注：本节比较重要，需要理解",
      "9 有益的可变性",
      "对immutable的ADT来说，它在A空间的abstract value应是不变的，但其内部表示的R空间中的取值则可以是变化的。",
      "这种mutation只是改变了R值，并未改变A值，对client来说，是immutable的 “AF并非单射”，从一个R值变成了另一个R值",
      "但这并不代表在immutable的类中就可以随意出现mutator！",
      "10 记录AF、RI、以及防止表示泄露的方法*",
      "在代码中用注释形式记录AF和RI以及防止表示泄露的方法，其内容是客户端不可见的",
      "要精确的记录RI：rep中的所有fields何为有效",
      "要精确记录AF：如何解释每一个R值",
      "表示泄漏的安全声明：给出理由，证明代码并未对外泄露其内部表示——自证清白",
      "具体措施：",
      "ADT的规约里只能使用client可见的内容来撰写，包括参数、返回值、异常等。",
      "如果规约里需要提及“值”，只能使用A空间中的“值“。",
      "ADT的规约里也不应谈及任何内部表示的细节，以及R空间中的任何值",
      "ADT的内部表示(私有属性)对外部都应严格不可见",
      "表示泄漏的风险：一旦泄露，ADT内部表示可能会在程序的任何位置发生改变（而不是限制在ADT内部），从而无法确保ADT的不变量是否能够始终保持为true。",
      "导致表示泄露的代码：",
      "1.直接将内部rep的别名作为返回值输出",
      "2.直接用rep作为外部可变对象的别名",
      "3.内部rep未用private修饰",
      "如何构建不变性：",
      "1.在对象的初始状态不变量为true，在对象发生变化时，不变量也要为true",
      "2.构造器和生产器在创建对象时要确保不变量为true",
      "3.变值器和观察器在执行时必须保持不变性",
      "4.在每个方法return之前，用checkRep()检查不变量是否得以保持。",
      "注：本节内容需要会读AF/RI，并会判断什么情况下RI可能不满足，以及知道哪些行为会导致表示泄露",
      "11 ADT不变量替代前置条件",
      "用ADT不变量取代复杂的Precondition，相当于将复杂的precondition封装到了ADT内部。"
    ],
    "sentences": [
      "注：文章中带有 * 的标题表示往年考试中出现过相应考点",
      "文章目录",
      "第四章 数据类型与类型检验",
      "1 编程语言中的数据类型*",
      "2 静态、动态类型检查*",
      "3 可变性、不可变性*",
      "4 Snapshot diagram*",
      "5 复杂数据类型-Arrays和Collections*",
      "6 有用的不可变数据类型*",
      "第五章 设计规约",
      "1 编程语言中的函数、方法*",
      "2 规约：面向交流编程*",
      "行为等价性",
      "规约结构 - 前置条件和后置条件*",
      "3 设计规约*",
      "规约性质*",
      "规约图",
      "设计好的规约*",
      "第六章 抽象数据类型(ADT)",
      "1 抽象与用户定义的类型",
      "2 对类型和操作进行分类*",
      "3 抽象数据类型例子",
      "4 设计一个抽象类型*",
      "5 表示独立性",
      "6 对ADT的测试",
      "7 不变量*",
      "8 表示不变性和抽象函数*",
      "9 有益的可变性",
      "10 记录AF、RI、以及防止表示泄露的方法*",
      "11 ADT不变量替代前置条件",
      "第四章 数据类型与类型检验",
      "1 编程语言中的数据类型*",
      "基本数据类型： int、boolean等",
      "对象数据类型：String、Integer等",
      "注：本节简单看看就行了，考也是大题里穿插考",
      "2 静态、动态类型检查*",
      "静态类型语言：在编译阶段进行类型检查",
      "动态类型语言：在运行阶段进行类型检查",
      "静态类型检查 >> 动态 >> 无检查",
      "静态类型检查：可在编译阶段发现错误",
      "避免了将错误带入到运行阶段",
      "可提高程序正确性/健壮性",
      "静态检查：关于“类型”的检查，不考虑值",
      "动态检查：关于“值”的检查",
      "注：本节看一遍就行了",
      "需要知道怎么找错",
      "就考过选择",
      "3 可变性、不可变性*",
      "改变一个变量：将该变量指向另一个值的存储空间",
      "改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值",
      "尽可能避免变化，以避免副作用",
      "不变性：重要设计原则",
      "不变数据类型：一旦被创建",
      "其值不能改变",
      "使用final关键字修饰",
      "如果是引用类型",
      "也可以是不变的",
      "即一旦确定其指向的对象",
      "指向不能再被改变",
      "如果编译器无法确定final变量不会改变",
      "就提示错误",
      "这也是静态类型检查的一部分",
      "尽量使用final变量作为方法的输入参数、作为局部变量",
      "注意：1.final类无法派生子类",
      "2.final变量无法改变值/引用",
      "3.final方法无法被子类重写",
      "不变对象：一旦被创建",
      "始终指向同一个值/引用(这个对象内部的各个属性都不能修改)",
      "可变对象：拥有方法可以修改自己的值/引用",
      "Immutable数据类型例子：String",
      "String类型不可变",
      "所以一个String对象在其生命周期中只能有一个值",
      "为了向一个String对象末尾添加元素",
      "将重新创建一个新的String对象",
      "Mutable数据类型例子：StringBuilder",
      "StringBuilder有插入、删除、替代字符等方法修改对象内部的值因此它是可变数据类型",
      "String和StringBuilder区别：当只有一个引用指向该值时",
      "没有区别",
      "有多个引用的时候，差异就出现了",
      "可变数据类型的优点：1.使用不可变类型",
      "对其频繁修改会产生大量的临时拷贝(需要垃圾回收)",
      "2.可变类型最少化拷贝以提高效率",
      "3.使用可变数据类型，可获得更好的性能",
      "4.可变数据类型也适合于在多个模块之间共享数据",
      "可变数据类型的风险：传递可变值时",
      "函数可能超过spec的范畴",
      "因为它可能会改变输入参数的值",
      "返回可变值时，后续对返回值的操作可能会影响全局变量的值",
      "解决方案：1.通过防御式拷贝，给客户端返回一个副本",
      "2.安全地使用可变类型：局部变量",
      "不会涉及共享；同一时间只有一个引用",
      "注：本节需要掌握怎么区分可变和不可变数据类型",
      "还得会画相应的snapshot diagram",
      "4 Snapshot diagram*",
      "作用：用于描述程序运行时的内部状态",
      "画法：注：本节经常在大题中考如何画snapshot diagram",
      "需要会画",
      "5 复杂数据类型-Arrays和Collections*",
      "数组：数组定长，一旦被创建，其长度不可改变",
      "列表：List是类型T的可变长序列",
      "数组和List的迭代：集合：零个或多个唯一对象的无序集合",
      "映射：类似与字典，使用键值对存储，一个键只能对应一个值",
      "List、Set、Map都是接口",
      "使用时需要用其具体实现类ArrayList、HashSet、HashMap等",
      "迭代器：可变数据类型使用迭代器时",
      "不可添加元素",
      "若想删除元素",
      "必须调用对应迭代器的remove方法",
      "注：本节是大题的基本知识，应该掌握",
      "6 有用的不可变数据类型*",
      "基本类型及其封装对象类型都是不可变的",
      "Collections类中有将可变Collections转化为不可变类型的方法：其参数为要转化的Collection",
      "这种包装器得到的结果是不可变的",
      "只能看",
      "但是这种“不可变”是在运行阶段获得的",
      "编译阶段无法据此进行静态检查",
      "注：本节考过选择题，看看就行了",
      "第五章 设计规约",
      "1 编程语言中的函数、方法*",
      "方法：参数类型是否匹配，在静态类型检查阶段完成",
      "返回值类型是否匹配，也在静态类型检查阶段完成",
      "方法是程序的\"积木\"，可以被独立开发、测试、复用",
      "使用方法的客户端，无需了解方法内部具体如何工作 - “抽象”",
      "完整方法示例：注：大题一定会考写方法",
      "学过编程语言的应该都会",
      "看看就行了",
      "2 规约：面向交流编程*",
      "例子",
      "JAVA API文档：把对某个变量所做出的假设写下来",
      "例如",
      "假定某一变量必须指向Integer",
      "final关键字也算假设，它定义了不可改变的设计决策",
      "为什么要写出假设？一，自己记不住 二，别人看不懂",
      "代码中蕴含的“设计决策” - 给编译器读",
      "注释形式的“设计决策” - 给自己和别人读",
      "没规约，没法写程序，即使写出来，也不知道对错",
      "规约也是程序与客户端之间达成的一致",
      "Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守",
      "很多bug来自于双方间的误解",
      "不写下来，那么不同开发者的理解可能就不同",
      "没有规约，难以定位错误",
      "规约优点：1.精确的规约，有助于区分责任",
      "2.客户端无需阅读调用函数的代码，只需理解spec即可",
      "例子：规约可以隔离“变化”，无需通知客户端",
      "规约也可以提高代码效率",
      "规约也扮演了用户和实现者之间的防火墙，用户不需要了解具体实现",
      "规约只讲“能做什么”，不讲“怎么实现”",
      "行为等价性",
      "行为等价性：两个事物是否可以相互替换",
      "要站在客户端的视角看待行为等价性",
      "根据规约判断是否行为等价",
      "如果两个函数符合这个规约",
      "那他们对于这个规约而言就等价",
      "规约结构 - 前置条件和后置条件*",
      "前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "后置条件：对开发者的约束，方法结束时必须满足的条件",
      "契约：如果前置条件满足了",
      "后置条件必须满足",
      "若前置条件不满足",
      "则方法可以做任何事情",
      "静态类型声明是一种规约，可据此进行静态类型检查",
      "方法前的注释也是一种规约，但需人工判定其是否满足",
      "除非在后置条件里声明过，否则方法内部不应该改变输入参数",
      "应尽量遵循此规则",
      "尽量不设计mutating的spec",
      "否则容易引发bug",
      "原因：程序中可以有多个变量指向用一个可变对象(别名)",
      "无法强迫类的实现体和客户端不保存可变变量的别名",
      "注：本节只需要看一遍就行，可能考选择",
      "3 设计规约*",
      "规约性质*",
      "规约的三条性质：确定性、陈述性、强度",
      "强度：当规约S2相比S1的前置条件更弱",
      "后置条件更强时",
      "则称规约S2的强度强于S1",
      "就可以用S2替代S1",
      "Spec变强：更放松的前置条件 + 更严格的后置条件",
      "例子：确定性：明确的规约：给定一个满足前置条件的输入",
      "其输出是唯一的、明确的",
      "欠定的规约：同一个输入可以有多个输出",
      "非确定的规约：同一个输入，多次执行时得到的输出可能不同",
      "欠定通常可认为等价于非确定，但欠定的规约通常有确定的实现",
      "陈述性：操作式规约：给出方法进行的一系列步骤，例如伪代码",
      "声明式规约： 没有内部实现的描述，只有“初 - 终”状态",
      "声明式规约更有价值",
      "通常不使用操作式规约",
      "内部实现的细节通常放在实现体内部注释中",
      "规约图",
      "设计好的规约*",
      "好的规约应该易于阅读",
      "应该有以下几个性质：1.内聚的：Spec描述的功能应单一、简单、易理解",
      "2.信息丰富的：不能让客户端产生理解的歧义",
      "3.足够健壮的：开发者应尽可能考虑各种特殊情况",
      "在后置条件中给出处理措施",
      "4.足够虚弱的：太强的spec在很多特殊情况下难以达到",
      "给开发者增加了实现的难度",
      "5.使用抽象类型：在规约里使用抽象类型",
      "可以给方法的实现体与客户端更大的自由度",
      "6.前置后置条件选取：*注：本节主要需要重点掌握怎么写spec以及spec的前置、后置条件强度的比较等 *",
      "第六章 抽象数据类型(ADT)",
      "1 抽象与用户定义的类型",
      "除了编程语言所提供的基本数据类型和对象数据类型",
      "程序员可定义自己的数据类型",
      "数据抽象：由一组操作所刻画的数据结构",
      "而非传统意义上关注数据的具体表示",
      "抽象类型：强调“作用于数据上的操作”",
      "程序员和客户端无需关心数据如何具体存储",
      "只需设计/使用操作即可",
      "一个抽象数据类型由它的操作所定义，与其内部实现无关",
      "2 对类型和操作进行分类*",
      "对类型的分类：可变类型的对象：提供了可改变其内部数据的值的操作",
      "不可变数据类型：其操作不改变内部值，而是构造新的对象",
      "对操作的分类：构造器(Creator)：创造ADT的新对象",
      "生产器(Producer)：提供ADT以前的对象创造新的对象",
      "观察器(Observer)：获取抽象类型的对象",
      "并返回不同类型的对象",
      "变值器(Mutator)：改变对象属性的方法",
      "构造器可能实现为构造函数或静态函数",
      "实施为静态函数的通常被称作工厂方法",
      "变值器通常返回void",
      "如果返回值为void",
      "则必然意味着它改变了对象的某些内部状态",
      "变值器也可能返回非空类型",
      "例如返回boolean",
      "判断操作是否成功",
      "注：本节需要掌握如何判断某一方法有可能属于哪种",
      "建议关注一下静态工厂方法",
      "3 抽象数据类型例子",
      "4 设计一个抽象类型*",
      "设计好的ADT",
      "靠“经验法则”",
      "提供一组操作",
      "设计其行为规约spec",
      "以下是几个设计规则：1.设计简洁、一致的操作",
      "2.要足以支持客户端对数据所做的所有操作需要",
      "且用操作满足客户端需要的难度要低",
      "3.要么抽象、要么具体",
      "不要混合 - 要么针对抽象设计",
      "要么针对具体应用的设计",
      "注：本节内容理解就行，考试必考ADT设计",
      "5 表示独立性",
      "表示独立性(RI)：客户端使用ADT时无需考虑其内部如何实现",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "除非ADT的操作指明了具体的前置和后置条件",
      "否则不能改变ADT的内部表示 - spec规定了客户端和实现者之间的契约",
      "6 对ADT的测试",
      "测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；测试observers：调用creators, producers, and mutators等方法产生或改变对象",
      "来看结果是否正确",
      "风险：如果被依赖的其他方法有错误",
      "可能导致被测试方法的测试结果失效",
      "7 不变量*",
      "不变量(invariants)：在任何时候都是true",
      "由ADT来负责其不变量，与client端的任何行为无关",
      "为什么需要不变量：保持程序的“正确性”，容易发现错误",
      "总是要假设客户端有“恶意”破坏ADT的不变量",
      "除非迫不得已",
      "否则不要把希望寄托于客户端上",
      "ADT有责任保证自己的invariants",
      "并避免“表示泄露”",
      "最好的办法就是使用immutable的类型，彻底避免表示泄露",
      "保持不变性和避免表示泄漏",
      "是ADT最重要的一个Invariant！",
      "注：本节简单理解一下就行了",
      "8 表示不变性和抽象函数*",
      "抽象值构成的空间：用户端看到和使用的值",
      "ADT开发者关注表示空间R，client关注抽象空间A",
      "抽象函数：R和A之间映射关系的函数",
      "即如何去解释R中每一个值为A中的每一个值",
      "抽象函数性质：1.满射：每一个抽象值都必须被某个表示值所映射",
      "2.未必单射：某个抽象值可能由超过一个表示值映射",
      "3.未必双射：不是所有表示值都需要有映射",
      "R中部分值并非合法的",
      "在A中无映射值",
      "RI : R → boolean",
      "表示不变性(RI通常指的是这个)：某个具体的“表示”是否是“合法的”",
      "也可以将RI看作：所有表示值的一个子集",
      "包含了所有合法的表示值",
      "也可将RI看作：一个条件，描述了什么是“合法”的表示值",
      "RI和AF都是作为注释写在代码中的，通常写在rep下方",
      "不同的内部表示",
      "需要设计不同的AF和RI",
      "即使是同样的R、同样的RI",
      "也可能有不同的AF",
      "即“解释不同”",
      "编写过程：选择某种特定的表示方式R",
      "进而指定某个子集是“合法”的(RI)",
      "并为该子集中的每个值做出“解释”(AF)——即如何映射到抽象空间中的值",
      "在实现中通常有一个checkRep方法",
      "在所有可能改变rep的方法内检查RI是否被满足",
      "注：本节比较重要，需要理解",
      "9 有益的可变性",
      "对immutable的ADT来说",
      "它在A空间的abstract value应是不变的",
      "但其内部表示的R空间中的取值则可以是变化的",
      "这种mutation只是改变了R值",
      "并未改变A值",
      "对client来说",
      "是immutable的 “AF并非单射”",
      "从一个R值变成了另一个R值",
      "但这并不代表在immutable的类中就可以随意出现mutator！",
      "10 记录AF、RI、以及防止表示泄露的方法*",
      "在代码中用注释形式记录AF和RI以及防止表示泄露的方法",
      "其内容是客户端不可见的",
      "要精确的记录RI：rep中的所有fields何为有效",
      "要精确记录AF：如何解释每一个R值",
      "表示泄漏的安全声明：给出理由",
      "证明代码并未对外泄露其内部表示——自证清白",
      "具体措施：ADT的规约里只能使用client可见的内容来撰写",
      "包括参数、返回值、异常等",
      "如果规约里需要提及“值”，只能使用A空间中的“值“",
      "ADT的规约里也不应谈及任何内部表示的细节",
      "以及R空间中的任何值",
      "ADT的内部表示(私有属性)对外部都应严格不可见",
      "表示泄漏的风险：一旦泄露",
      "ADT内部表示可能会在程序的任何位置发生改变（而不是限制在ADT内部）",
      "从而无法确保ADT的不变量是否能够始终保持为true",
      "导致表示泄露的代码：1.直接将内部rep的别名作为返回值输出",
      "2.直接用rep作为外部可变对象的别名",
      "3.内部rep未用private修饰",
      "如何构建不变性：1.在对象的初始状态不变量为true",
      "在对象发生变化时",
      "不变量也要为true",
      "2.构造器和生产器在创建对象时要确保不变量为true",
      "3.变值器和观察器在执行时必须保持不变性",
      "4.在每个方法return之前",
      "用checkRep()检查不变量是否得以保持",
      "注：本节内容需要会读AF/RI",
      "并会判断什么情况下RI可能不满足",
      "以及知道哪些行为会导致表示泄露",
      "11 ADT不变量替代前置条件",
      "用ADT不变量取代复杂的Precondition",
      "相当于将复杂的precondition封装到了ADT内部"
    ],
    "codes": [
      "Collections.unmodifiableList",
      "Collections.unmodifiableSet",
      "Collections.unmodifiableMap"
    ],
    "date": "2021-07-06",
    "text": "注：文章中带有 * 的标题表示往年考试中出现过相应考点\n文章目录\n第四章 数据类型与类型检验\n1 编程语言中的数据类型*\n2 静态、动态类型检查*\n3 可变性、不可变性*\n4 Snapshot diagram*\n5 复杂数据类型-Arrays和Collections*\n6 有用的不可变数据类型*\n第五章 设计规约\n1 编程语言中的函数、方法*\n2 规约：面向交流编程*\n行为等价性\n规约结构 - 前置条件和后置条件*\n3 设计规约*\n规约性质*\n规约图\n设计好的规约*\n第六章 抽象数据类型(ADT)\n1 抽象与用户定义的类型\n2 对类型和操作进行分类*\n3 抽象数据类型例子\n4 设计一个抽象类型*\n5 表示独立性\n6 对ADT的测试\n7 不变量*\n8 表示不变性和抽象函数*\n9 有益的可变性\n10 记录AF、RI、以及防止表示泄露的方法*\n11 ADT不变量替代前置条件\n第四章 数据类型与类型检验\n1 编程语言中的数据类型*\n基本数据类型： int、boolean等\n对象数据类型：String、Integer等\n注：本节简单看看就行了，考也是大题里穿插考\n2 静态、动态类型检查*\n静态类型语言：在编译阶段进行类型检查\n动态类型语言：在运行阶段进行类型检查\n静态类型检查 >> 动态 >> 无检查\n静态类型检查：可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性\n静态检查：关于“类型”的检查，不考虑值\n动态检查：关于“值”的检查\n注：本节看一遍就行了，需要知道怎么找错，就考过选择，\n3 可变性、不可变性*\n改变一个变量：将该变量指向另一个值的存储空间\n改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。\n尽可能避免变化，以避免副作用\n不变性：重要设计原则\n不变数据类型：一旦被创建，其值不能改变，使用final关键字修饰，如果是引用类型，也可以是不变的，即一旦确定其指向的对象，指向不能再被改变\n如果编译器无法确定final变量不会改变，就提示错误，这也是静态类型检查的一部分。\n尽量使用final变量作为方法的输入参数、作为局部变量。\n注意：\n1.final类无法派生子类\n2.final变量无法改变值/引用\n3.final方法无法被子类重写\n不变对象：一旦被创建，始终指向同一个值/引用(这个对象内部的各个属性都不能修改)\n可变对象：拥有方法可以修改自己的值/引用\nImmutable数据类型例子：String\nString类型不可变，所以一个String对象在其生命周期中只能有一个值\n为了向一个String对象末尾添加元素，将重新创建一个新的String对象\nMutable数据类型例子：StringBuilder\nStringBuilder有插入、删除、替代字符等方法修改对象内部的值因此它是可变数据类型\nString和StringBuilder区别：\n当只有一个引用指向该值时，没有区别\n有多个引用的时候，差异就出现了\n可变数据类型的优点：\n1.使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)\n2.可变类型最少化拷贝以提高效率\n3.使用可变数据类型，可获得更好的性能\n4.可变数据类型也适合于在多个模块之间共享数据\n可变数据类型的风险：\n传递可变值时，函数可能超过spec的范畴，因为它可能会改变输入参数的值\n返回可变值时，后续对返回值的操作可能会影响全局变量的值\n解决方案：\n1.通过防御式拷贝，给客户端返回一个副本\n2.安全地使用可变类型：局部变量，不会涉及共享；同一时间只有一个引用\n注：本节需要掌握怎么区分可变和不可变数据类型，还得会画相应的snapshot diagram\n4 Snapshot diagram*\n作用：用于描述程序运行时的内部状态\n画法：\n注：本节经常在大题中考如何画snapshot diagram，需要会画\n5 复杂数据类型-Arrays和Collections*\n数组：数组定长，一旦被创建，其长度不可改变\n列表：List是类型T的可变长序列\n数组和List的迭代：\n集合：零个或多个唯一对象的无序集合\n映射：类似与字典，使用键值对存储，一个键只能对应一个值\nList、Set、Map都是接口，使用时需要用其具体实现类ArrayList、HashSet、HashMap等\n迭代器：\n可变数据类型使用迭代器时，不可添加元素，若想删除元素，必须调用对应迭代器的remove方法。\n注：本节是大题的基本知识，应该掌握\n6 有用的不可变数据类型*\n基本类型及其封装对象类型都是不可变的\nCollections类中有将可变Collections转化为不可变类型的方法：\n其参数为要转化的Collection，这种包装器得到的结果是不可变的，只能看\n但是这种“不可变”是在运行阶段获得的，编译阶段无法据此进行静态检查\n注：本节考过选择题，看看就行了\n第五章 设计规约\n1 编程语言中的函数、方法*\n方法：\n参数类型是否匹配，在静态类型检查阶段完成\n返回值类型是否匹配，也在静态类型检查阶段完成\n方法是程序的\"积木\"，可以被独立开发、测试、复用\n使用方法的客户端，无需了解方法内部具体如何工作 - “抽象”\n完整方法示例：\n注：大题一定会考写方法，学过编程语言的应该都会，看看就行了\n2 规约：面向交流编程*\n例子，JAVA API文档：\n把对某个变量所做出的假设写下来，例如，假定某一变量必须指向Integer\nfinal关键字也算假设，它定义了不可改变的设计决策\n为什么要写出假设？一，自己记不住 二，别人看不懂\n代码中蕴含的“设计决策” - 给编译器读\n注释形式的“设计决策” - 给自己和别人读\n没规约，没法写程序，即使写出来，也不知道对错\n规约也是程序与客户端之间达成的一致\nSpec给“供需双方”都确定了责任，在调用的时候双方都要遵守\n很多bug来自于双方间的误解\n不写下来，那么不同开发者的理解可能就不同\n没有规约，难以定位错误\n规约优点：\n1.精确的规约，有助于区分责任\n2.客户端无需阅读调用函数的代码，只需理解spec即可\n例子：\n规约可以隔离“变化”，无需通知客户端\n规约也可以提高代码效率\n规约也扮演了用户和实现者之间的防火墙，用户不需要了解具体实现\n规约只讲“能做什么”，不讲“怎么实现”\n行为等价性\n行为等价性：两个事物是否可以相互替换\n要站在客户端的视角看待行为等价性\n根据规约判断是否行为等价，如果两个函数符合这个规约，那他们对于这个规约而言就等价\n规约结构 - 前置条件和后置条件*\n前置条件：对客户端的约束，在使用方法时必须满足的条件\n后置条件：对开发者的约束，方法结束时必须满足的条件\n契约：如果前置条件满足了，后置条件必须满足，若前置条件不满足，则方法可以做任何事情\n静态类型声明是一种规约，可据此进行静态类型检查。方法前的注释也是一种规约，但需人工判定其是否满足\n除非在后置条件里声明过，否则方法内部不应该改变输入参数\n应尽量遵循此规则，尽量不设计mutating的spec，否则容易引发bug\n原因：程序中可以有多个变量指向用一个可变对象(别名)，无法强迫类的实现体和客户端不保存可变变量的别名\n注：本节只需要看一遍就行，可能考选择\n3 设计规约*\n规约性质*\n规约的三条性质：确定性、陈述性、强度\n强度：\n当规约S2相比S1的前置条件更弱，后置条件更强时，则称规约S2的强度强于S1，就可以用S2替代S1\nSpec变强：更放松的前置条件 + 更严格的后置条件\n例子：\n确定性：\n明确的规约：给定一个满足前置条件的输入，其输出是唯一的、明确的\n欠定的规约：同一个输入可以有多个输出\n非确定的规约：同一个输入，多次执行时得到的输出可能不同\n欠定通常可认为等价于非确定，但欠定的规约通常有确定的实现\n陈述性：\n操作式规约：给出方法进行的一系列步骤，例如伪代码\n声明式规约： 没有内部实现的描述，只有“初 - 终”状态\n声明式规约更有价值，通常不使用操作式规约，内部实现的细节通常放在实现体内部注释中\n规约图\n设计好的规约*\n好的规约应该易于阅读，应该有以下几个性质：\n1.内聚的：Spec描述的功能应单一、简单、易理解\n2.信息丰富的：不能让客户端产生理解的歧义\n3.足够健壮的：开发者应尽可能考虑各种特殊情况，在后置条件中给出处理措施\n4.足够虚弱的：太强的spec在很多特殊情况下难以达到，给开发者增加了实现的难度\n5.使用抽象类型：在规约里使用抽象类型，可以给方法的实现体与客户端更大的自由度\n6.前置后置条件选取：\n*注：本节主要需要重点掌握怎么写spec以及spec的前置、后置条件强度的比较等 *\n第六章 抽象数据类型(ADT)\n1 抽象与用户定义的类型\n除了编程语言所提供的基本数据类型和对象数据类型，程序员可定义自己的数据类型\n数据抽象：由一组操作所刻画的数据结构，而非传统意义上关注数据的具体表示\n抽象类型：强调“作用于数据上的操作”，程序员和客户端无需关心数据如何具体存储，只需设计/使用操作即可。\n一个抽象数据类型由它的操作所定义，与其内部实现无关\n2 对类型和操作进行分类*\n对类型的分类：\n可变类型的对象：提供了可改变其内部数据的值的操作\n不可变数据类型：其操作不改变内部值，而是构造新的对象\n对操作的分类：\n构造器(Creator)：创造ADT的新对象\n生产器(Producer)：提供ADT以前的对象创造新的对象\n观察器(Observer)：获取抽象类型的对象，并返回不同类型的对象\n变值器(Mutator)：改变对象属性的方法\n构造器可能实现为构造函数或静态函数，实施为静态函数的通常被称作工厂方法\n变值器通常返回void，如果返回值为void，则必然意味着它改变了对象的某些内部状态\n变值器也可能返回非空类型，例如返回boolean，判断操作是否成功\n注：本节需要掌握如何判断某一方法有可能属于哪种，建议关注一下静态工厂方法\n3 抽象数据类型例子\n4 设计一个抽象类型*\n设计好的ADT，靠“经验法则”，提供一组操作，设计其行为规约spec\n以下是几个设计规则：\n1.设计简洁、一致的操作\n2.要足以支持客户端对数据所做的所有操作需要，且用操作满足客户端需要的难度要低\n3.要么抽象、要么具体，不要混合 - 要么针对抽象设计，要么针对具体应用的设计\n注：本节内容理解就行，考试必考ADT设计\n5 表示独立性\n表示独立性(RI)：客户端使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端\n除非ADT的操作指明了具体的前置和后置条件，否则不能改变ADT的内部表示 - spec规定了客户端和实现者之间的契约\n6 对ADT的测试\n测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；\n测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。\n风险：如果被依赖的其他方法有错误，可能导致被测试方法的测试结果失效。\n7 不变量*\n不变量(invariants)：在任何时候都是true\n由ADT来负责其不变量，与client端的任何行为无关\n为什么需要不变量：保持程序的“正确性”，容易发现错误\n总是要假设客户端有“恶意”破坏ADT的不变量\n除非迫不得已，否则不要把希望寄托于客户端上，ADT有责任保证自己的invariants，并避免“表示泄露”。\n最好的办法就是使用immutable的类型，彻底避免表示泄露\n保持不变性和避免表示泄漏，是ADT最重要的一个Invariant！\n注：本节简单理解一下就行了\n8 表示不变性和抽象函数*\n抽象值构成的空间：用户端看到和使用的值\nADT开发者关注表示空间R，client关注抽象空间A\n抽象函数：R和A之间映射关系的函数，即如何去解释R中每一个值为A中的每一个值\n抽象函数性质：\n1.满射：每一个抽象值都必须被某个表示值所映射\n2.未必单射：某个抽象值可能由超过一个表示值映射\n3.未必双射：不是所有表示值都需要有映射，R中部分值并非合法的，在A中无映射值\nRI : R → boolean\n表示不变性(RI通常指的是这个)：某个具体的“表示”是否是“合法的”\n也可以将RI看作：所有表示值的一个子集，包含了所有合法的表示值\n也可将RI看作：一个条件，描述了什么是“合法”的表示值\nRI和AF都是作为注释写在代码中的，通常写在rep下方\n不同的内部表示，需要设计不同的AF和RI，即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。\n编写过程：选择某种特定的表示方式R，进而指定某个子集是“合法”的(RI)，并为该子集中的每个值做出“解释”(AF)——即如何映射到抽象空间中的值。\n在实现中通常有一个checkRep方法，在所有可能改变rep的方法内检查RI是否被满足\n注：本节比较重要，需要理解\n9 有益的可变性\n对immutable的ADT来说，它在A空间的abstract value应是不变的，但其内部表示的R空间中的取值则可以是变化的。\n这种mutation只是改变了R值，并未改变A值，对client来说，是immutable的 “AF并非单射”，从一个R值变成了另一个R值\n但这并不代表在immutable的类中就可以随意出现mutator！\n10 记录AF、RI、以及防止表示泄露的方法*\n在代码中用注释形式记录AF和RI以及防止表示泄露的方法，其内容是客户端不可见的\n要精确的记录RI：rep中的所有fields何为有效\n要精确记录AF：如何解释每一个R值\n表示泄漏的安全声明：给出理由，证明代码并未对外泄露其内部表示——自证清白\n具体措施：\nADT的规约里只能使用client可见的内容来撰写，包括参数、返回值、异常等。\n如果规约里需要提及“值”，只能使用A空间中的“值“。\nADT的规约里也不应谈及任何内部表示的细节，以及R空间中的任何值\nADT的内部表示(私有属性)对外部都应严格不可见\n表示泄漏的风险：一旦泄露，ADT内部表示可能会在程序的任何位置发生改变（而不是限制在ADT内部），从而无法确保ADT的不变量是否能够始终保持为true。\n导致表示泄露的代码：\n1.直接将内部rep的别名作为返回值输出\n2.直接用rep作为外部可变对象的别名\n3.内部rep未用private修饰\n如何构建不变性：\n1.在对象的初始状态不变量为true，在对象发生变化时，不变量也要为true\n2.构造器和生产器在创建对象时要确保不变量为true\n3.变值器和观察器在执行时必须保持不变性\n4.在每个方法return之前，用checkRep()检查不变量是否得以保持。\n注：本节内容需要会读AF/RI，并会判断什么情况下RI可能不满足，以及知道哪些行为会导致表示泄露\n11 ADT不变量替代前置条件\n用ADT不变量取代复杂的Precondition，相当于将复杂的precondition封装到了ADT内部。\n"
  },
  {
    "head": "软件构造复习笔记(1)",
    "paragraphs": [
      "注：文章中带有",
      "的标题表示往年考试中出现过相应考点",
      "文章目录",
      "第一章 软件构造的多维度视图和质量目标",
      "1 多维度软件视图*",
      "Build-time view - 构造阶段 - 编写代码过程",
      "Runtime view - 运行阶段 - 程序运行过程",
      "2 软件构造：视图间的转换",
      "3 软件系统的质量属性*",
      "外部质量因素*",
      "内部质量因素",
      "4 软件构造五大关键质量目标",
      "第二章 软件测试与测试优先的编程",
      "1 软件测试*",
      "2 测试用例",
      "3 测试优先的编程*",
      "4 单元测试",
      "5 使用JUnit的自动单元测试",
      "6 黑盒测试*",
      "等价类划分",
      "边界值分析",
      "两个极端的划分覆盖策略",
      "7 白盒测试",
      "8 测试的覆盖度*",
      "9 自动测试和回归测试",
      "10 测试策略*",
      "第三章 软件构造过程与配置管理",
      "1 软件开发生命周期(SDLC)",
      "2 传统软件流程模型![在这里插入图片描述](https://img-blog.csdnimg.cn/20210705212556877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dzAxMDAwMTM0,size_16,color_FFFFFF,t_70)",
      "3 敏捷开发",
      "4 软件配置管理(SCM)和版本控制系统(VCS)*",
      "5 SCM工具例子：Git*",
      "6 软件构造的总体流程",
      "第一章 软件构造的多维度视图和质量目标",
      "1 多维度软件视图*",
      "Build-time view - 构造阶段 - 编写代码过程",
      "Code-level view - 代码的逻辑组织 - 函数、类、方法、接口等",
      "Component-level view - 代码的物理组织 - 文件、路径、包、库等",
      "Moment view - 特定时刻的软件形态 - 特定时间",
      "Period view - 软件形态随时间的变化 - 一段时间",
      "Runtime view - 运行阶段 - 程序运行过程",
      "Code-level view - 逻辑实体在内存中如何呈现 - 内存状态",
      "Component - level view - 物理实体在物理硬件环境中如何呈现 - 物理环境",
      "Moment view - 逻辑/物理实体在内存/硬件环境中特定的形态如何 - 特定时间",
      "Period view - 逻辑/物理实体在内存/硬件环境中的形态随时间如何变化 - 一段时间",
      "上述三类view共构成八种具体情况",
      "代码快照图(Snapshot diagram)：描述程序运行时内存里变量层面的状态",
      "注：本节需要记住各操作对应八种维度中的哪个",
      "2 软件构造：视图间的转换",
      "3 软件系统的质量属性*",
      "外部质量因素*",
      "外部质量因素：例如使用的速度或难易程度等质量，其在软件产品中的存在或缺失可以被其用户检测到",
      "外部质量因素影响用户",
      "外部质量因素包括：",
      "1.正确性：程序能按照预先定义的规约执行，正确性是最重要的质量指标。",
      "每一层保证自己的正确性，同时假设其下层是正确的。",
      "2.健壮性：针对异常情况的处理，出现异常时不要崩溃",
      "3.可拓展性：为了应对未来可能的变化",
      "4.可复用性：一次开发，多次使用",
      "5.兼容性：不同的软件系统之间相互可容易的集成",
      "6.高效性：性能毫无意义，除非有足够的正确性，过早优化时万恶之源",
      "7.可移植性：软件可方便的在不同的技术环境之间移植",
      "8.易用性：容易学、安装、操作、监控",
      "9.功能性：提供未来可能需要的功能，每增加一小点功能，都确保其他质量属性不受到损失",
      "10.及时性：用户需要前，软件系统能及时发布",
      "11.其他：可验证性、完整性、可修复性、经济性",
      "注：本节只需要记住几个外部特性即可",
      "内部质量因素",
      "内部质量因素：适用于软件产品的其他质量，如模块化或可读性，是内部因素",
      "内部质量因素影响软件本身和它的开发者",
      "复杂性是几乎任何外部质量因素的敌人！",
      "内部质量因素通常用作外部质量因素的部分测量。",
      "只有外部质量重要，但外部质量取决于内部质量。",
      "正确的软件开发过程中，开发者应该将不同质量因素之间如何做出折中的设",
      "计决策和标准明确的写下来",
      "虽然需要折中，但“正确性”绝不能与其他质量因素折中。",
      "最重要的几个质量因素：",
      "正确性、健壮性 - 可靠",
      "可拓展性、可复用性 - 模块化",
      "4 软件构造五大关键质量目标",
      "可理解性：",
      "可复用性：",
      "可维护性和可适应性：",
      "健壮性：",
      "性能表现：",
      "第二章 软件测试与测试优先的编程",
      "1 软件测试*",
      "软件测试：提高软件质量的重要手段，用来寻找程序bug、检查程序是否满足使用要求，确认程序是否到达可用级别(用户需求)。关注系统的某一侧面的质量特性。",
      "测试跟其他活动的目标相反：破坏、证错",
      "即使是最好的测试程序也无法达到100%无错误，再好的测试也无法证明系统里不存在错误。",
      "好的测试：能发现错误、不冗余、最佳特性、别太复杂也别太简单",
      "测试层次：",
      "静态测试：不需要运行程序，例如检查代码",
      "动态测试：描述代码的动态行为，需要运行在给定的集合或测试集合上",
      "测试与调试：测试 - 发现是否存在错误，调试 - 识别错误根源，消除错误",
      "白盒测试：对程序内部代码结构的测试",
      "黑盒测试：对程序外部表现出来的行为的测试",
      "注：本节只考过选择题，而且比较简单，简单看一遍就行了",
      "2 测试用例",
      "测试用例：输入+执行条件+期望结果",
      "好的测试用例的特性：最可能发现错误、不重复、不冗余、最有效、即不简单也不复杂",
      "3 测试优先的编程*",
      "在写代码前写测试用例",
      "过程：",
      "1.先写spec",
      "2.再写符合spec的测试用例",
      "3.写代码、执行测试、有问题再改、再执行测试用例、直到通过它",
      "Spec：描述函数的输入和输出行为",
      "它给出了参数的类型和对它们的任何附加约束条件。",
      "它也给出了返回值类型以及返回值如何与输入相关联",
      "在代码中，规范由方法声明和上面描述它所做什么的注释组成。",
      "注：本节内容需要理解Spec是什么",
      "4 单元测试",
      "单元测试：针对软件的最小单元模型开展测试，隔离各个模块，容易定位错误和调试",
      "对每个函数的spec编写测试用例，每个测试都应该包括一组预期结果",
      "5 使用JUnit的自动单元测试",
      "需要记住的方法：assertEquals、assertTrue、assertFalse",
      "6 黑盒测试*",
      "黑盒测试：用于检查代码的功能，不关心内部实现细节",
      "黑盒测试寻找以下类型的错误：",
      "1.不正确或缺失的函数",
      "2.接口错误",
      "3.数据结构或外部数据库使用错误",
      "4.行为错误",
      "5.初始化和终止错误",
      "黑盒测试的测试用例：为了检查程序是否符合规约，用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误",
      "等价类划分",
      "基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。",
      "针对每个输入数据需要满足的约束条件，划分等价类",
      "每个等价类代表着对输入约束加以满足/违反的有效/无效数据的集合",
      "基于的假设：相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为测试用例即可",
      "边界值分析",
      "大量的错误发生在输入域的“边界”而非中央",
      "边界值分析方法是对等价类划分方法的补充，在等价类划分时，将边界作为等价类之一加入考虑",
      "两个极端的划分覆盖策略",
      "笛卡尔积：全覆盖",
      "多个划分维度上的多个取值，要组合起来，每个组合都要有一个用例",
      "并非所有组合情况都可能",
      "测试完备，但用例数量多，测试代价高",
      "覆盖每个取值：最少一次即可",
      "每个维度的每个取值至少被1个测试用例覆盖一次即可",
      "测试用例少，代价低，但测试覆盖度未必高",
      "注：本节容易考根据spec写测试用例",
      "7 白盒测试",
      "黑盒测试完全从函数spec导出测试用例，不考虑函数内部实现",
      "白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例",
      "白盒测试一般较早执行",
      "独立/基本路径测试：对程序所有执行路径进行等价类划",
      "分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试",
      "用例使每一条基本路径被至少覆盖1次。",
      "8 测试的覆盖度*",
      "代码覆盖度：已有的测试用例有多大程度覆盖了被测程序",
      "代码覆盖度越低，测试越不充分，但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高",
      "常用工具：EclEmma",
      "注：本节只在选择题的某个选项中考过EclEmma",
      "9 自动测试和回归测试",
      "自动测试：自动调用被测函数、自动判定测试结果、自动计算覆盖度",
      "只是“测试用例的自动执行”，并非“自动生成测试用例”",
      "回归测试：一旦程序被修改，重新执行之前的所有测试",
      "一旦发现bug，要马上写一个可重现该bug的测试用例，并将其加入测试库",
      "常用工具：Continuous Integration、Travis CI",
      "10 测试策略*",
      "测试策略(根据什么来选择测试用例)非常重要，需要在程序中显式记录下来",
      "目的：在代码评审过程中，其他人可以理解你的测试，并判断你的测试是否足够充分",
      "注：本节需要学会怎么写测试策略",
      "第三章 软件构造过程与配置管理",
      "1 软件开发生命周期(SDLC)",
      "2 传统软件流程模型",
      "3 敏捷开发",
      "敏捷开发：通过快速迭代和小规模的持续改进，以快速适应变化。",
      "Agile = 增量 + 迭代",
      "每次迭代处理一个小规模增量",
      "4 软件配置管理(SCM)和版本控制系统(VCS)*",
      "软件配置管理：追踪和控制软件的变化",
      "软件配置项(SCI)：软件中发生变化的基本单元（例如：文件）",
      "基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本）",
      "配置管理数据库(CMDB)：存储软件的各配置项随时间发生变化的信息+基线",
      "版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识”",
      "仓库：即于SCM中的CMDB",
      "工作拷贝：在开发者本地机器上的一份项目拷贝",
      "文件：一个独立的配置项",
      "版本：在某个特定时间点的所有文件的共同状态",
      "变化：即code churn，两个版本之间的差异",
      "HEAD：程序员正在其上工作的版本",
      "本地版本控制系统：仓库存储于开发者本地机器无法共享和协作",
      "集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作",
      "分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器",
      "注：本节只在选择题中考过SCI、SCM的概念",
      "5 SCM工具例子：Git*",
      "Git视图：",
      "Git仓库包括以下三个部分：",
      ".git文件：本地的CMDB",
      "工作目录：本地文件系统",
      "暂存区：隔离工作目录和Git仓库",
      "每个文件都处于下列三种状态之一：",
      "Modified：已修改",
      "Staged：已暂存",
      "Committed：已提交",
      "Git的对象图：",
      "Git存储发生变化的文件本身，而不是变化的代码行",
      "文件未发生变化，则后续多个版本始终指向同一个文件",
      "文件发生变化了，存储两份不同的文件，两个版本指向不同的文件",
      "git push、git pull：向/从远程服务器发送/接受对象图",
      "分支、合并：",
      "git checkout -b A 新建分支A",
      "git checkout -d A 删除分支A",
      "git checkout A 切换到分支A",
      "git merge A 将当前分支与A合并",
      "注：本节考过git所对应的SCM各部分、git的指令等",
      "6 软件构造的总体流程"
    ],
    "sentences": [
      "注：文章中带有",
      "的标题表示往年考试中出现过相应考点",
      "文章目录",
      "第一章 软件构造的多维度视图和质量目标",
      "1 多维度软件视图*",
      "Build-time view - 构造阶段 - 编写代码过程",
      "Runtime view - 运行阶段 - 程序运行过程",
      "2 软件构造：视图间的转换",
      "3 软件系统的质量属性*",
      "外部质量因素*",
      "内部质量因素",
      "4 软件构造五大关键质量目标",
      "第二章 软件测试与测试优先的编程",
      "1 软件测试*",
      "2 测试用例",
      "3 测试优先的编程*",
      "4 单元测试",
      "5 使用JUnit的自动单元测试",
      "6 黑盒测试*",
      "等价类划分",
      "边界值分析",
      "两个极端的划分覆盖策略",
      "7 白盒测试",
      "8 测试的覆盖度*",
      "9 自动测试和回归测试",
      "10 测试策略*",
      "第三章 软件构造过程与配置管理",
      "1 软件开发生命周期(SDLC)",
      "2 传统软件流程模型![在这里插入图片描述](https://img-blog.csdnimg.cn/20210705212556877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dzAxMDAwMTM0,size_16,color_FFFFFF,t_70)",
      "3 敏捷开发",
      "4 软件配置管理(SCM)和版本控制系统(VCS)*",
      "5 SCM工具例子：Git*",
      "6 软件构造的总体流程",
      "第一章 软件构造的多维度视图和质量目标",
      "1 多维度软件视图*",
      "Build-time view - 构造阶段 - 编写代码过程",
      "Code-level view - 代码的逻辑组织 - 函数、类、方法、接口等",
      "Component-level view - 代码的物理组织 - 文件、路径、包、库等",
      "Moment view - 特定时刻的软件形态 - 特定时间",
      "Period view - 软件形态随时间的变化 - 一段时间",
      "Runtime view - 运行阶段 - 程序运行过程",
      "Code-level view - 逻辑实体在内存中如何呈现 - 内存状态",
      "Component - level view - 物理实体在物理硬件环境中如何呈现 - 物理环境",
      "Moment view - 逻辑/物理实体在内存/硬件环境中特定的形态如何 - 特定时间",
      "Period view - 逻辑/物理实体在内存/硬件环境中的形态随时间如何变化 - 一段时间",
      "上述三类view共构成八种具体情况",
      "代码快照图(Snapshot diagram)：描述程序运行时内存里变量层面的状态",
      "注：本节需要记住各操作对应八种维度中的哪个",
      "2 软件构造：视图间的转换",
      "3 软件系统的质量属性*",
      "外部质量因素*",
      "外部质量因素：例如使用的速度或难易程度等质量",
      "其在软件产品中的存在或缺失可以被其用户检测到",
      "外部质量因素影响用户",
      "外部质量因素包括：1.正确性：程序能按照预先定义的规约执行",
      "正确性是最重要的质量指标",
      "每一层保证自己的正确性，同时假设其下层是正确的",
      "2.健壮性：针对异常情况的处理，出现异常时不要崩溃",
      "3.可拓展性：为了应对未来可能的变化",
      "4.可复用性：一次开发，多次使用",
      "5.兼容性：不同的软件系统之间相互可容易的集成",
      "6.高效性：性能毫无意义",
      "除非有足够的正确性",
      "过早优化时万恶之源",
      "7.可移植性：软件可方便的在不同的技术环境之间移植",
      "8.易用性：容易学、安装、操作、监控",
      "9.功能性：提供未来可能需要的功能",
      "每增加一小点功能",
      "都确保其他质量属性不受到损失",
      "10.及时性：用户需要前，软件系统能及时发布",
      "11.其他：可验证性、完整性、可修复性、经济性",
      "注：本节只需要记住几个外部特性即可",
      "内部质量因素",
      "内部质量因素：适用于软件产品的其他质量",
      "如模块化或可读性",
      "是内部因素",
      "内部质量因素影响软件本身和它的开发者",
      "复杂性是几乎任何外部质量因素的敌人！",
      "内部质量因素通常用作外部质量因素的部分测量",
      "只有外部质量重要，但外部质量取决于内部质量",
      "正确的软件开发过程中",
      "开发者应该将不同质量因素之间如何做出折中的设",
      "计决策和标准明确的写下来",
      "虽然需要折中，但“正确性”绝不能与其他质量因素折中",
      "最重要的几个质量因素：正确性、健壮性 - 可靠",
      "可拓展性、可复用性 - 模块化",
      "4 软件构造五大关键质量目标",
      "可理解性：可复用性：可维护性和可适应性：健壮性：性能表现：第二章 软件测试与测试优先的编程",
      "1 软件测试*",
      "软件测试：提高软件质量的重要手段",
      "用来寻找程序bug、检查程序是否满足使用要求",
      "确认程序是否到达可用级别(用户需求)",
      "关注系统的某一侧面的质量特性",
      "测试跟其他活动的目标相反：破坏、证错",
      "即使是最好的测试程序也无法达到100%无错误",
      "再好的测试也无法证明系统里不存在错误",
      "好的测试：能发现错误、不冗余、最佳特性、别太复杂也别太简单",
      "测试层次：静态测试：不需要运行程序，例如检查代码",
      "动态测试：描述代码的动态行为",
      "需要运行在给定的集合或测试集合上",
      "测试与调试：测试 - 发现是否存在错误",
      "调试 - 识别错误根源",
      "消除错误",
      "白盒测试：对程序内部代码结构的测试",
      "黑盒测试：对程序外部表现出来的行为的测试",
      "注：本节只考过选择题，而且比较简单，简单看一遍就行了",
      "2 测试用例",
      "测试用例：输入+执行条件+期望结果",
      "好的测试用例的特性：最可能发现错误、不重复、不冗余、最有效、即不简单也不复杂",
      "3 测试优先的编程*",
      "在写代码前写测试用例",
      "过程：1.先写spec",
      "2.再写符合spec的测试用例",
      "3.写代码、执行测试、有问题再改、再执行测试用例、直到通过它",
      "Spec：描述函数的输入和输出行为",
      "它给出了参数的类型和对它们的任何附加约束条件",
      "它也给出了返回值类型以及返回值如何与输入相关联",
      "在代码中，规范由方法声明和上面描述它所做什么的注释组成",
      "注：本节内容需要理解Spec是什么",
      "4 单元测试",
      "单元测试：针对软件的最小单元模型开展测试",
      "隔离各个模块",
      "容易定位错误和调试",
      "对每个函数的spec编写测试用例",
      "每个测试都应该包括一组预期结果",
      "5 使用JUnit的自动单元测试",
      "需要记住的方法：assertEquals、assertTrue、assertFalse",
      "6 黑盒测试*",
      "黑盒测试：用于检查代码的功能，不关心内部实现细节",
      "黑盒测试寻找以下类型的错误：1.不正确或缺失的函数",
      "2.接口错误",
      "3.数据结构或外部数据库使用错误",
      "4.行为错误",
      "5.初始化和终止错误",
      "黑盒测试的测试用例：为了检查程序是否符合规约",
      "用尽可能少的测试用例",
      "尽快运行",
      "并尽可能大的发现程序的错误",
      "等价类划分",
      "基于等价类划分的测试：将被测函数的输入域划分为等价类",
      "从等价类中导出测试用例",
      "针对每个输入数据需要满足的约束条件，划分等价类",
      "每个等价类代表着对输入约束加以满足/违反的有效/无效数据的集合",
      "基于的假设：相似的输入，将会展示相似的行为",
      "故可从每个等价类中选一个代表作为测试用例即可",
      "边界值分析",
      "大量的错误发生在输入域的“边界”而非中央",
      "边界值分析方法是对等价类划分方法的补充",
      "在等价类划分时",
      "将边界作为等价类之一加入考虑",
      "两个极端的划分覆盖策略",
      "笛卡尔积：全覆盖",
      "多个划分维度上的多个取值，要组合起来，每个组合都要有一个用例",
      "并非所有组合情况都可能",
      "测试完备，但用例数量多，测试代价高",
      "覆盖每个取值：最少一次即可",
      "每个维度的每个取值至少被1个测试用例覆盖一次即可",
      "测试用例少，代价低，但测试覆盖度未必高",
      "注：本节容易考根据spec写测试用例",
      "7 白盒测试",
      "黑盒测试完全从函数spec导出测试用例，不考虑函数内部实现",
      "白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例",
      "白盒测试一般较早执行",
      "独立/基本路径测试：对程序所有执行路径进行等价类划",
      "分",
      "找出有代表性的最简单的路径(例如循环只需执行1次)",
      "设计测试",
      "用例使每一条基本路径被至少覆盖1次",
      "8 测试的覆盖度*",
      "代码覆盖度：已有的测试用例有多大程度覆盖了被测程序",
      "代码覆盖度越低",
      "测试越不充分",
      "但要做到很高的代码覆盖度",
      "需要更多的测试用例",
      "测试代价高",
      "常用工具：EclEmma",
      "注：本节只在选择题的某个选项中考过EclEmma",
      "9 自动测试和回归测试",
      "自动测试：自动调用被测函数、自动判定测试结果、自动计算覆盖度",
      "只是“测试用例的自动执行”，并非“自动生成测试用例”",
      "回归测试：一旦程序被修改，重新执行之前的所有测试",
      "一旦发现bug",
      "要马上写一个可重现该bug的测试用例",
      "并将其加入测试库",
      "常用工具：Continuous Integration、Travis CI",
      "10 测试策略*",
      "测试策略(根据什么来选择测试用例)非常重要",
      "需要在程序中显式记录下来",
      "目的：在代码评审过程中",
      "其他人可以理解你的测试",
      "并判断你的测试是否足够充分",
      "注：本节需要学会怎么写测试策略",
      "第三章 软件构造过程与配置管理",
      "1 软件开发生命周期(SDLC)",
      "2 传统软件流程模型",
      "3 敏捷开发",
      "敏捷开发：通过快速迭代和小规模的持续改进，以快速适应变化",
      "Agile = 增量 + 迭代",
      "每次迭代处理一个小规模增量",
      "4 软件配置管理(SCM)和版本控制系统(VCS)*",
      "软件配置管理：追踪和控制软件的变化",
      "软件配置项(SCI)：软件中发生变化的基本单元（例如：文件）",
      "基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本）",
      "配置管理数据库(CMDB)：存储软件的各配置项随时间发生变化的信息+基线",
      "版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号",
      "作为“身份标识”",
      "仓库：即于SCM中的CMDB",
      "工作拷贝：在开发者本地机器上的一份项目拷贝",
      "文件：一个独立的配置项",
      "版本：在某个特定时间点的所有文件的共同状态",
      "变化：即code churn，两个版本之间的差异",
      "HEAD：程序员正在其上工作的版本",
      "本地版本控制系统：仓库存储于开发者本地机器无法共享和协作",
      "集中式版本控制系统：仓库存储于独立的服务器",
      "支持多开发者之间的协作",
      "分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器",
      "注：本节只在选择题中考过SCI、SCM的概念",
      "5 SCM工具例子：Git*",
      "Git视图：Git仓库包括以下三个部分：.git文件：本地的CMDB",
      "工作目录：本地文件系统",
      "暂存区：隔离工作目录和Git仓库",
      "每个文件都处于下列三种状态之一：Modified：已修改",
      "Staged：已暂存",
      "Committed：已提交",
      "Git的对象图：Git存储发生变化的文件本身",
      "而不是变化的代码行",
      "文件未发生变化，则后续多个版本始终指向同一个文件",
      "文件发生变化了，存储两份不同的文件，两个版本指向不同的文件",
      "git push、git pull：向/从远程服务器发送/接受对象图",
      "分支、合并：git checkout -b A 新建分支A",
      "git checkout -d A 删除分支A",
      "git checkout A 切换到分支A",
      "git merge A 将当前分支与A合并",
      "注：本节考过git所对应的SCM各部分、git的指令等",
      "6 软件构造的总体流程"
    ],
    "codes": [],
    "date": "2021-07-05",
    "text": "注：文章中带有\n的标题表示往年考试中出现过相应考点\n文章目录\n第一章 软件构造的多维度视图和质量目标\n1 多维度软件视图*\nBuild-time view - 构造阶段 - 编写代码过程\nRuntime view - 运行阶段 - 程序运行过程\n2 软件构造：视图间的转换\n3 软件系统的质量属性*\n外部质量因素*\n内部质量因素\n4 软件构造五大关键质量目标\n第二章 软件测试与测试优先的编程\n1 软件测试*\n2 测试用例\n3 测试优先的编程*\n4 单元测试\n5 使用JUnit的自动单元测试\n6 黑盒测试*\n等价类划分\n边界值分析\n两个极端的划分覆盖策略\n7 白盒测试\n8 测试的覆盖度*\n9 自动测试和回归测试\n10 测试策略*\n第三章 软件构造过程与配置管理\n1 软件开发生命周期(SDLC)\n2 传统软件流程模型![在这里插入图片描述](https://img-blog.csdnimg.cn/20210705212556877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dzAxMDAwMTM0,size_16,color_FFFFFF,t_70)\n3 敏捷开发\n4 软件配置管理(SCM)和版本控制系统(VCS)*\n5 SCM工具例子：Git*\n6 软件构造的总体流程\n第一章 软件构造的多维度视图和质量目标\n1 多维度软件视图*\nBuild-time view - 构造阶段 - 编写代码过程\nCode-level view - 代码的逻辑组织 - 函数、类、方法、接口等\nComponent-level view - 代码的物理组织 - 文件、路径、包、库等\nMoment view - 特定时刻的软件形态 - 特定时间\nPeriod view - 软件形态随时间的变化 - 一段时间\nRuntime view - 运行阶段 - 程序运行过程\nCode-level view - 逻辑实体在内存中如何呈现 - 内存状态\nComponent - level view - 物理实体在物理硬件环境中如何呈现 - 物理环境\nMoment view - 逻辑/物理实体在内存/硬件环境中特定的形态如何 - 特定时间\nPeriod view - 逻辑/物理实体在内存/硬件环境中的形态随时间如何变化 - 一段时间\n上述三类view共构成八种具体情况\n代码快照图(Snapshot diagram)：描述程序运行时内存里变量层面的状态\n注：本节需要记住各操作对应八种维度中的哪个\n2 软件构造：视图间的转换\n3 软件系统的质量属性*\n外部质量因素*\n外部质量因素：例如使用的速度或难易程度等质量，其在软件产品中的存在或缺失可以被其用户检测到\n外部质量因素影响用户\n外部质量因素包括：\n1.正确性：程序能按照预先定义的规约执行，正确性是最重要的质量指标。\n每一层保证自己的正确性，同时假设其下层是正确的。\n2.健壮性：针对异常情况的处理，出现异常时不要崩溃\n3.可拓展性：为了应对未来可能的变化\n4.可复用性：一次开发，多次使用\n5.兼容性：不同的软件系统之间相互可容易的集成\n6.高效性：性能毫无意义，除非有足够的正确性，过早优化时万恶之源\n7.可移植性：软件可方便的在不同的技术环境之间移植\n8.易用性：容易学、安装、操作、监控\n9.功能性：提供未来可能需要的功能，每增加一小点功能，都确保其他质量属性不受到损失\n10.及时性：用户需要前，软件系统能及时发布\n11.其他：可验证性、完整性、可修复性、经济性\n注：本节只需要记住几个外部特性即可\n内部质量因素\n内部质量因素：适用于软件产品的其他质量，如模块化或可读性，是内部因素\n内部质量因素影响软件本身和它的开发者\n复杂性是几乎任何外部质量因素的敌人！\n内部质量因素通常用作外部质量因素的部分测量。\n只有外部质量重要，但外部质量取决于内部质量。\n正确的软件开发过程中，开发者应该将不同质量因素之间如何做出折中的设\n计决策和标准明确的写下来\n虽然需要折中，但“正确性”绝不能与其他质量因素折中。\n最重要的几个质量因素：\n正确性、健壮性 - 可靠\n可拓展性、可复用性 - 模块化\n4 软件构造五大关键质量目标\n可理解性：\n可复用性：\n可维护性和可适应性：\n健壮性：\n性能表现：\n第二章 软件测试与测试优先的编程\n1 软件测试*\n软件测试：提高软件质量的重要手段，用来寻找程序bug、检查程序是否满足使用要求，确认程序是否到达可用级别(用户需求)。关注系统的某一侧面的质量特性。\n测试跟其他活动的目标相反：破坏、证错\n即使是最好的测试程序也无法达到100%无错误，再好的测试也无法证明系统里不存在错误。\n好的测试：能发现错误、不冗余、最佳特性、别太复杂也别太简单\n测试层次：\n静态测试：不需要运行程序，例如检查代码\n动态测试：描述代码的动态行为，需要运行在给定的集合或测试集合上\n测试与调试：测试 - 发现是否存在错误，调试 - 识别错误根源，消除错误\n白盒测试：对程序内部代码结构的测试\n黑盒测试：对程序外部表现出来的行为的测试\n注：本节只考过选择题，而且比较简单，简单看一遍就行了\n2 测试用例\n测试用例：输入+执行条件+期望结果\n好的测试用例的特性：最可能发现错误、不重复、不冗余、最有效、即不简单也不复杂\n3 测试优先的编程*\n在写代码前写测试用例\n过程：\n1.先写spec\n2.再写符合spec的测试用例\n3.写代码、执行测试、有问题再改、再执行测试用例、直到通过它\nSpec：描述函数的输入和输出行为\n它给出了参数的类型和对它们的任何附加约束条件。\n它也给出了返回值类型以及返回值如何与输入相关联\n在代码中，规范由方法声明和上面描述它所做什么的注释组成。\n注：本节内容需要理解Spec是什么\n4 单元测试\n单元测试：针对软件的最小单元模型开展测试，隔离各个模块，容易定位错误和调试\n对每个函数的spec编写测试用例，每个测试都应该包括一组预期结果\n5 使用JUnit的自动单元测试\n需要记住的方法：assertEquals、assertTrue、assertFalse\n6 黑盒测试*\n黑盒测试：用于检查代码的功能，不关心内部实现细节\n黑盒测试寻找以下类型的错误：\n1.不正确或缺失的函数\n2.接口错误\n3.数据结构或外部数据库使用错误\n4.行为错误\n5.初始化和终止错误\n黑盒测试的测试用例：为了检查程序是否符合规约，用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误\n等价类划分\n基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。\n针对每个输入数据需要满足的约束条件，划分等价类\n每个等价类代表着对输入约束加以满足/违反的有效/无效数据的集合\n基于的假设：相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为测试用例即可\n边界值分析\n大量的错误发生在输入域的“边界”而非中央\n边界值分析方法是对等价类划分方法的补充，在等价类划分时，将边界作为等价类之一加入考虑\n两个极端的划分覆盖策略\n笛卡尔积：全覆盖\n多个划分维度上的多个取值，要组合起来，每个组合都要有一个用例\n并非所有组合情况都可能\n测试完备，但用例数量多，测试代价高\n覆盖每个取值：最少一次即可\n每个维度的每个取值至少被1个测试用例覆盖一次即可\n测试用例少，代价低，但测试覆盖度未必高\n注：本节容易考根据spec写测试用例\n7 白盒测试\n黑盒测试完全从函数spec导出测试用例，不考虑函数内部实现\n白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例\n白盒测试一般较早执行\n独立/基本路径测试：对程序所有执行路径进行等价类划\n分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试\n用例使每一条基本路径被至少覆盖1次。\n8 测试的覆盖度*\n代码覆盖度：已有的测试用例有多大程度覆盖了被测程序\n代码覆盖度越低，测试越不充分，但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高\n常用工具：EclEmma\n注：本节只在选择题的某个选项中考过EclEmma\n9 自动测试和回归测试\n自动测试：自动调用被测函数、自动判定测试结果、自动计算覆盖度\n只是“测试用例的自动执行”，并非“自动生成测试用例”\n回归测试：一旦程序被修改，重新执行之前的所有测试\n一旦发现bug，要马上写一个可重现该bug的测试用例，并将其加入测试库\n常用工具：Continuous Integration、Travis CI\n10 测试策略*\n测试策略(根据什么来选择测试用例)非常重要，需要在程序中显式记录下来\n目的：在代码评审过程中，其他人可以理解你的测试，并判断你的测试是否足够充分\n注：本节需要学会怎么写测试策略\n第三章 软件构造过程与配置管理\n1 软件开发生命周期(SDLC)\n2 传统软件流程模型\n3 敏捷开发\n敏捷开发：通过快速迭代和小规模的持续改进，以快速适应变化。\nAgile = 增量 + 迭代\n每次迭代处理一个小规模增量\n4 软件配置管理(SCM)和版本控制系统(VCS)*\n软件配置管理：追踪和控制软件的变化\n软件配置项(SCI)：软件中发生变化的基本单元（例如：文件）\n基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本）\n配置管理数据库(CMDB)：存储软件的各配置项随时间发生变化的信息+基线\n版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识”\n仓库：即于SCM中的CMDB\n工作拷贝：在开发者本地机器上的一份项目拷贝\n文件：一个独立的配置项\n版本：在某个特定时间点的所有文件的共同状态\n变化：即code churn，两个版本之间的差异\nHEAD：程序员正在其上工作的版本\n本地版本控制系统：仓库存储于开发者本地机器无法共享和协作\n集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作\n分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器\n注：本节只在选择题中考过SCI、SCM的概念\n5 SCM工具例子：Git*\nGit视图：\nGit仓库包括以下三个部分：\n.git文件：本地的CMDB\n工作目录：本地文件系统\n暂存区：隔离工作目录和Git仓库\n每个文件都处于下列三种状态之一：\nModified：已修改\nStaged：已暂存\nCommitted：已提交\nGit的对象图：\nGit存储发生变化的文件本身，而不是变化的代码行\n文件未发生变化，则后续多个版本始终指向同一个文件\n文件发生变化了，存储两份不同的文件，两个版本指向不同的文件\ngit push、git pull：向/从远程服务器发送/接受对象图\n分支、合并：\ngit checkout -b A 新建分支A\ngit checkout -d A 删除分支A\ngit checkout A 切换到分支A\ngit merge A 将当前分支与A合并\n注：本节考过git所对应的SCM各部分、git的指令等\n6 软件构造的总体流程\n"
  },
  {
    "head": "软件构造复习笔记(4)",
    "paragraphs": [
      "注：文章中带有 * 的标题表示往年考试中出现过相应考点",
      "文章目录",
      "第十章 面向可维护性的构造技术",
      "1 软件可维护性和演化",
      "2 可维护性的指标",
      "3 模块化设计和模块化原则",
      "4 OO设计原则：SOLID*",
      "单一责任原则(SRP)",
      "开放-封闭原则(OCP)",
      "Liskov替换原则(LSP)",
      "接口隔离原则(ISP)",
      "依赖转置原则(DIP)",
      "5 语法驱动的构造*",
      "语法的构成要素",
      "语法中的运算*",
      "语法中的递归",
      "分析树",
      "正则语法和正则表达式*",
      "第十一章 面向可复用性和可维护性的设计模式",
      "1 创建模式*",
      "2 结构模式*",
      "适配器模式(Adapter Pattern)",
      "装饰器模式(Decorator)",
      "3 行为模式*",
      "策略模式(Strategy)",
      "模板模式(Template Method)",
      "迭代器模式(Iterator)",
      "访问器模式(Visitor)",
      "4 设计模式的共性与差异*",
      "第十二章 面向正确性与健壮性的软件构造",
      "1 什么是健壮性和正确性？",
      "2 如何量度健壮性和正确性",
      "3 Java中的Error和Exception*",
      "4 异常处理*",
      "5 断言",
      "6 防御式编程",
      "7 SpotBugs工具",
      "第十章 面向可维护性的构造技术",
      "1 软件可维护性和演化",
      "软件维护：修复错误、改善性能",
      "主要步骤：",
      "1.测试所做的修改",
      "2.回归测试",
      "3.记录变化",
      "除了修复问题，修改中不能引入新的故障",
      "最大的问题：修改后没有足够的文档记录和测试",
      "软件可维护性的类型：",
      "软件演化：对软件进行持续的更新，软件的大部分成本来自于维护阶段",
      "软件维护不仅仅是运维工程师的工作，而是从设计和开发阶段就开始了",
      "在设计与开发阶段就要考虑将来的可维护性",
      "面向可维护性的构造技术：",
      "1.模块化设计",
      "2.OO设计原则",
      "3.OO设计模式",
      "4.基于状态的构造技术",
      "5.表驱动的构造技术",
      "6.基于语法的构造技术",
      "2 可维护性的指标",
      "可维护性：软件系统或组件易于修改以纠正故障、提高性能或其他属性，或适应已改变的环境”。",
      "可拓展性：软件设计/实施考虑到未来的增长，可拓展性被视为扩展系统能力和实施扩展所需努力水平的系统衡量。",
      "灵活性：软件根据用户需求、外部技术和社会环境等而轻松改变的能力。",
      "可适应性：交互系统（自适应系统）的能力，可以根据获取的用户及其环境信息来适应个别用户的行为。",
      "可管理性：监控和维护软件系统的效率和容易，以保持系统运行、安全和平稳运行。",
      "支持性：基于包括质量文档、诊断信息和知识渊博的技术人员的资源，在部署后软件如何有效地运行。",
      "Halstead Volume:基于源代码中（不同的）运算符和操作数数量的复合度量。",
      "3 模块化设计和模块化原则",
      "目的：将系统划分为模块，并用一种模块内高内聚，模块间低耦合的方式分配各模块的职责",
      "模块化降低了程序员在任何时候都必须处理的总复杂性，做到分离关注点和信息隐藏",
      "评估模块性的五个标准：",
      "1.可分解性(Decomposability)：较大的组件是否已分解为较小的组件",
      "2.可组合性(Composability)：较大的组件是否可以由较小的组件构成",
      "3.可理解性(Understandability)：组件是否可以单独理解",
      "4.可持续性(Continuity)：对规约的小改变是否只影响本地优先数量的组件",
      "5.出现异常之后的保护(Protection)：运行时异常的影响是否局限于少量的相关组件",
      "五个模块化设计的规则：",
      "1.直接映射(Direct Mapping)",
      "2.尽可能少的接口(Few Interfaces)",
      "3.尽可能小的接口(Small Interfaces)",
      "4.显式接口(Explicit Interfaces)",
      "5.信息隐藏(Information Hiding)",
      "耦合性：耦合是衡量模块之间依赖关系的度量方法",
      "模块间耦合性程度由模块之间的接口数量和每个接口的复杂性决定(复杂性由通信的类型决定)",
      "内聚性：是衡量模块功能或责任的紧密相关的标准，如果一个模块的所有元素都在朝着相同的目标工作，那么该模块就具有很高的内聚性",
      "好的设计需要高内聚，低耦合，但有时需要折中，耦合程度高时，内聚内聚程度倾向于变低，反之亦然",
      "4 OO设计原则：SOLID*",
      "SOLID：五大类的设计原则",
      "The Single Responsibility Principle 单一责任原则(SRP)",
      "The Open-Closed Principle 开放-封闭原则(OCP)",
      "The Liskov Substitution Principle Liskov替换原则(LSP)",
      "The Dependency Inversion Principle 依赖转置原则(DIP)",
      "The Interface Segregation Principle 接口聚合原则(ISP)",
      "单一责任原则(SRP)",
      "SRP:不应该有多于1个原因让你的ADT发生变化，否则就拆分开；一个类，一个责任",
      "责任：变化的原因",
      "如果一个类包含了多个责任，那么将引起不良后果：",
      "1.引入额外的包，占据资源",
      "2.导致频繁的重新配置、部署等",
      "开放-封闭原则(OCP)",
      "开放：对拓展性的开发，模块的行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化",
      "封闭：对修改的封闭，模块自身的代码是不应被修改的；扩展模块行为的一般途径是修改模块的内部实现；如果一个模块不能被修改，那么它通常被认为是具有固定的行为",
      "关键的解决方案：抽象技术",
      "“软件实体（类、模块、功能等）。应该开放扩展，但关闭修改”，即使用继承和组合/委托更改类的行为",
      "Liskov替换原则(LSP)",
      "LSP：子类型必须能够替换其基类型",
      "派生类必须能够通过其基类的接口使用，客户端无需了解两者之间的差异",
      "接口隔离原则(ISP)",
      "ISP：不能强迫客户端依赖于他们不需要的接口，只提供必需的接口",
      "不要用许多方法污染接口，避免臃肿的接口，客户端不应该被强迫依赖他们不需要的方法",
      "接口属于客户端，而不是体系结构",
      "接口臃肿的类是接口不够聚合的类，胖接口可以分解为多个小接口；不同的接口向不同的客户端提供服务；客户端只访问自己所需要的接口",
      "图示：",
      "依赖转置原则(DIP)",
      "DIP：抽象的模块不应该依赖于具体的模块，具体的模块应该依赖于抽象的",
      "大部分的接口和抽象都应该被使用",
      "delegation时，要通过接口建立联系，而非具体子类",
      "注：本节SOLID五个原则都应该了解",
      "5 语法驱动的构造*",
      "语法的构成要素",
      "有一类应用，从外部读取文本数据，在应用中做进一步处理。",
      "特定的，字节或字符序列应该有如下特性：",
      "1.输入文件有特定格式，程序需读取文件并从中抽取正确的内容",
      "2.从网络上传输过来的信息，遵循特定的协议",
      "3.用户在命令行输入的指令，遵循特定的格式",
      "4.内存中存储的字符串，也有格式需要",
      "通常使用语法分析来判断字符串是否合法，并解析成程序里使用的数据结构，且这个数据通常是一个递归的数据结构",
      "一个语法定义了一个字符串集合",
      "语法中的文字字符串被称作终止节点，他们是语法解析树的叶节点，无法再向下扩展，通常被表示为字符串",
      "一个语法由一个产生式节点的集合描述，其中每一个产生式都定义了一个非终止节点，并遵循特定规则，利用操作符、终止节点和其他非终止节点，构造新的字符串，非终止节点是树中表示字符串的内部节点",
      "一个语法中的产生式有如下形式：",
      "nonterminal ::= expression of terminals, nonterminals, and operators",
      "根节点：是一个语法中的非终止节点，语法识别出的字符串集合中都是与根节点匹配的字符串",
      "语法中的运算*",
      "三种基本语法运算：",
      "连接(Concatenation) - x::= y z - x匹配y后接z的字符串",
      "重复(Repetition) - x::=y* - x匹配零个或多个y",
      "选择(Union) - x::= y | z - x要么匹配y要么匹配z",
      "运算优先级：",
      "1.通常情况下，前缀运算符*, ?, +有最高的运算优先度",
      "2.连接其次",
      "3.选择优先度最低",
      "但圆括号可以被用作修改优先级，括号内的优先运算",
      "其他语法运算符：",
      "可选(Optional) - x ::= y+ - x要么是y要么为空",
      "一次或多次出现 - x ::= y+ - x是一个或多个y的连接",
      "一个字符类 - x ::= […] - 表示包含方括号中列出的任何字符的长度为1的字符串,例如",
      "x ::= [a-c] 等价于 x ::= ‘a’ | ‘b’ | ‘c’",
      "一个倒置的字符类 - x ::= [^…] - 表示包含括号中未列出的任何字符的长度为1的字符串，例如",
      "x ::= [^a-c] 等价于 x ::= ‘d’ | ‘e’ | ‘f’ | …",
      "语法中的递归",
      "分析树",
      "分析树：根据语法匹配将一个字符串生成一个能显示字符串中的各部分如何和语法中各部分联系起来的树",
      "树的叶节点标记着终止符号，代表已经被分析完的字符串部分，如果从左到右将叶节点连接，将获得原字符串",
      "正则语法和正则表达式*",
      "正则语法：简化之后可以表达为一个产生式而不包含任何非终止节点",
      "正则表达式：终端和运算符的约简表达式可以写成一种更紧凑的形式，称为正则表达式。",
      "正则表达式会去掉了终端周围的引号以及终端和运算符之间的空格，因此它只由终端字符、用于分组的括号和运算符字符组成。",
      "一些正则表达式的运算：",
      ". - 任意字符",
      "\\d - 任意数字",
      "\\s - 任意空白符",
      "\\w 任意有意义的字符，相当于[a-zA-Z_0-9]",
      ". ( ) * + … - 表示反斜杠后的字符",
      "注：本节只需要学会正则表达式即可",
      "第十一章 面向可复用性和可维护性的设计模式",
      "1 创建模式*",
      "工厂方法，也被称作虚拟构造器，当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。",
      "可以定义一个用于创建对象的接口，让其子类来决定实例化哪个类，从而使一个类的实例化延迟到其子类",
      "带有工厂方法的类也可以实现其他功能",
      "有新的具体产品类加入时，可以在工厂类里修改过增加新的工厂函数(OCP)，不会影响客户端代码",
      "客户端使用工厂方法来创建实例，得到的实例的类型是抽象接口而非具体类",
      "根据类型决定创建哪个具体产品",
      "优点：",
      "消除了将特定于应用程序的类绑定到代码的需要。",
      "代码仅处理产品接口，因此它可以处理任何用户定义的具体产品",
      "潜在缺点：",
      "客户可能必须创建构造类的子类，以便他们可以创建特定的产品。",
      "注：本节了解一下就行",
      "2 结构模式*",
      "适配器模式(Adapter Pattern)",
      "将某个类/接口转换为客户端期望的其他形式，适配器使由于不相容的接口导致本不能一起使用的类可以一起使用。一般通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。",
      "装饰器模式(Decorator)",
      "装饰器用于为对象添加不同侧面的特性，对于每一个特性构造子类，通过委派机制增加到对象上",
      "装饰器使用了子类型和委派",
      "Collections.unmodifiedSet等通过装饰器实现，修改原数据依然会导致所得到的添加特性后的对象改变",
      "客户端需要一个具有多种特性的object，可以通过一层一层的装饰来实现",
      "注：本节需要简单理解一下",
      "3 行为模式*",
      "策略模式(Strategy)",
      "问题：有多种不同的算法来实现同一个任务，但需要客户端根据需要动态切换算法，而不是写死在代码中",
      "实现方法：为不同的实现算法构造抽象接口，利用delegation，运行时动态传入客户端倾向的算法实例",
      "优点：",
      "易于扩展到新的算法实现",
      "将算法与客户端上下文进行分离",
      "模板模式(Template Method)",
      "问题：做事情的步骤一样，但具体方法不同",
      "实现方法：共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现",
      "模板模式使用继承和重写方法组合的策略来实现",
      "迭代器模式(Iterator)",
      "问题：客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型",
      "解决方案：一种专为迭代的策略模式",
      "作用：",
      "1.隐藏底层容器的内部实现",
      "2.支持具有统一接口的多个遍历策略",
      "3.易于更改容器类型",
      "4.促进项目各部分之间的沟通",
      "Iterable接口：实现该接口的集合对象是可迭代遍历的",
      "Iterator接口：迭代器",
      "迭代器模式：让自己的集合实现Iterable接口，并实现自己的独特Iterator迭代器，允许客户端利用这个迭代器进行显示或隐式的迭代遍历：",
      "访问器模式(Visitor)",
      "Visitor pattern：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类",
      "本质上：将数据和作用于数据上的某种/些特定操作分离开",
      "效果：为ADT预留一个将来可拓展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT",
      "只要更换visitor的具体实现，即可切换算法",
      "注：本节内容都比较重要，需要会根据各种设计模式写代码",
      "4 设计模式的共性与差异*",
      "共性样式1：只使用继承，不使用委派",
      "核心思路OCP/DIP，依赖反转，客户端只依赖“抽象”，不能依赖于”具体“",
      "发生变化时最好是扩展，而非修改",
      "代表：Adaptor、Template",
      "共性样式2：",
      "注：本节需要理解",
      "第十二章 面向正确性与健壮性的软件构造",
      "1 什么是健壮性和正确性？",
      "健壮性(Robustness)：系统在不正常输入或不正常外部环境下仍能够表现正常的程度",
      "面向健壮性的编程：",
      "1.处理未期望的行为和错误终止",
      "2.即使终止执行，也要准确/无歧义的向用户展示全面的错误信息",
      "3.错误信息有助于debug",
      "健壮性原则：",
      "1.总是假定用户恶意，假定自己的代码可能失败",
      "2.把用户想象成白痴，可能输入任何东西",
      "3.对别人宽容点，对自己狠一点",
      "对自己的代码要保守，对用户的行为要开放",
      "健壮性编程的原则：",
      "1.封闭实现细节，限定用户的恶意行为",
      "2.考虑极端情况，没有不可能",
      "正确性(Correctness)：程序按照spec加以执行的能力，是最重要的质量指标",
      "正确性 - 永不给用户错误的结构",
      "健壮性 - 尽可能保持软件运行而不是总是退出",
      "正确性倾向于直接报错(error)，健壮性则倾向于容错(fault-tolerance)",
      "健壮性：让用户变得更容易：出错也可以容忍，程序内部已有容错机制",
      "正确性：让开发者变得更容易：用户输入错误（不满足precondition的调用），直接结束。",
      "对外的接口，倾向于健壮；对内的实现，倾向于正确",
      "安全关键型应用程序相比于健壮性倾向于支持正确性",
      "消费者的应用程序相比于正确性倾向于支持健壮性",
      "可靠性(Reliability)：系统在规定条件下执行其所需功能的能力 - 故障之间的平均时间长度。",
      "Reliability = Robustness + Correctness",
      "提高健壮性和正确性的步骤：",
      "0.使用断言、防御性编程、代码审查、正式验证等来编写具有健壮性和正确性的代码",
      "1.观察故障症状（内存转储、堆栈跟踪、执行日志、测试）",
      "2.识别潜在的故障（错误定位、调试）",
      "3.修复错误（代码修订）",
      "2 如何量度健壮性和正确性",
      "外部观察角度：",
      "Mean time between failures 平均失效间隔时间(MTBF)：系统运行过程中系统固有故障之间的预期运行时间。",
      "MTBF描述了可修复系统的两次故障之间的预期时间，而 mean time to failure 平均故障时间(MTTF)表示不可修复系统的预期故障时间。",
      "内部观察角度：",
      "残余缺陷率：每千行代码中遗留的bug数量",
      "3 Java中的Error和Exception*",
      "内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结果",
      "异常：程序的问题，可以捕获、可以处理",
      "Error种类：用户输入错误、设备错误、物理限制",
      "大多数情况下，Error不需要被实例化",
      "注：本节了解一下就行",
      "4 异常处理*",
      "使用try - catch结构",
      "异常：程序执行中的非正常时间，程序无法再按预想的流程执行",
      "Exception会将错误信息传递给上层调用者，并报告”案发现场“的信息",
      "Exception可以是return之外的第二种退出途径 - 当找不到异常处理程序时，整个系统会完全退出",
      "异常可以被分为RuntimeException和其他类型",
      "运行时异常：由程序员在代码中处理不当造成，是程序源代码中引入的故障造成的，如果在代码中提前进行验证，则这些故障就可以避免",
      "其他异常：由外部原因造成，是程序员无法完全控制的外在问题所导致的，即使在代码中提前加以验证(文件是否存在等)，也无法完全避免失效发生",
      "当异常产生时，要么异常处理程序处理了异常，要么会告诉编译器无法处理该异常，并在命令行中输出错误信息。编译器可以帮助检查程序是否已经抛出或处理了可能的异常。",
      "Error和RuntimeException并不被编译器进行检查，",
      "RuntimeException不需要在编译时用try catch等机制处理，但执行时可能会导致程序失败，代表程序中的潜在bug - 类似动态检查",
      "而其他Exception则必须捕获并指定错误处理程序，否则编译无法通过 - 类似静态类型检查",
      "Java中异常处理的关键字：try、catch、finally、throws、throw",
      "throws：表明方法会抛出XX异常",
      "throw：抛出XX异常",
      "try、catch、finally：捕获并处理XX异常",
      "Unchecked异常也可以使用throws声明或try/catch进行捕获，但大多数时候是不需要的，也不应该这么做 - 掩耳盗铃，对发现的编程错误充耳不闻",
      "如果客户端可以通过其他的方法恢复异常，那么采用checked exception；",
      "如果客户端对出现的这种异常无能为力，那么采用unchecked exception；",
      "异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息",
      "“异常”也是方法和client端之间spec的一部分，在post-condition中刻画",
      "对于checked exception，需要在方法声明后加throws XX异常",
      "程序员必须在方法的spec中明确写清本方法会抛出的所有checked exception，以便于调用该方法的client加以处理",
      "而unchecked exception则不需要",
      "若一个程序内部某方法可能抛出某checked exception，则要么它内部有该异常的处理程序，要么它也声明会抛出异常，将异常移交给调用它的方法处理。若没有处理程序来处理checked exception，程序将终止运行",
      "程序员不应抛出Error，Error通常只指虚拟机或动态库的错误",
      "子类型多态相关：",
      "1.如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛",
      "2.子类型方法可以抛出更具体的异常，也可以不抛出任何异常",
      "3.如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。",
      "抛出异常方法：",
      "流程：",
      "1.找到到一个能表达错误的Exception类/或者构造一个新的Exception类",
      "2.构造Exception类的实例，将错误信息写入",
      "3.抛出它",
      "一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码",
      "构造异常类：",
      "对于checked exception，只需要继承Exception类",
      "对于unchecked exception，只需要继承RuntimeException类",
      "异常处理程序：",
      "若某段代码中可能抛出异常，可以将这段代码包含在try代码块内，并使用catch捕获其抛出的各种异常。若在各catch代码段后有finally代码段，程序会在执行完catch代码段后执行finally代码段，另外，没有抛出异常时finally代码段也会被执行。",
      "finally代码段通常用于清理异常发生前曾申请过的资源",
      "重新抛出异常：catch代码段中也可以抛出异常",
      "目的：更改exception的类型，更方便客户端获取错误信息并处理",
      "调用栈追踪：",
      "注：本节需要学会ava中的两类异常，并掌握他们区别，并掌握异常抛出、处理等相关代码的编写，还需要了解异常处理观察者控制的转移路径，以及异常导致程序退出时显示的的方法调用栈含义",
      "5 断言",
      "断言：当不满足前提条件时，此代码通过抛出断言错误异常来终止程序。调用者的错误的影响无法传播。检查前置条件是防御式编程的一种典型形式",
      "为什么要断言：",
      "在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误。",
      "断言即是对代码中程序员所做假设的文档化，也不会影响运行时性能",
      "(在实际使用时，assertion都会被disabled)",
      "断言为了程序正确性，使用断言处理“绝不应该发生”的情况，如果来自于自己",
      "所写的其他代码，可以使用断言来帮助发现错误",
      "异常为了程序健壮性，使用异常来处理你“预料到可以发生”的不正常情况，如果参数来",
      "自于外部（不受自己控制），使用异常处理",
      "6 防御式编程",
      "防御性编程是一种防御性设计的形式，旨在确保一块软件在不可预见的情况下的持续功能。",
      "7 SpotBugs工具",
      "SpotBugs是一个使用静态分析来查找Java代码中的bug的程序"
    ],
    "sentences": [
      "注：文章中带有 * 的标题表示往年考试中出现过相应考点",
      "文章目录",
      "第十章 面向可维护性的构造技术",
      "1 软件可维护性和演化",
      "2 可维护性的指标",
      "3 模块化设计和模块化原则",
      "4 OO设计原则：SOLID*",
      "单一责任原则(SRP)",
      "开放-封闭原则(OCP)",
      "Liskov替换原则(LSP)",
      "接口隔离原则(ISP)",
      "依赖转置原则(DIP)",
      "5 语法驱动的构造*",
      "语法的构成要素",
      "语法中的运算*",
      "语法中的递归",
      "分析树",
      "正则语法和正则表达式*",
      "第十一章 面向可复用性和可维护性的设计模式",
      "1 创建模式*",
      "2 结构模式*",
      "适配器模式(Adapter Pattern)",
      "装饰器模式(Decorator)",
      "3 行为模式*",
      "策略模式(Strategy)",
      "模板模式(Template Method)",
      "迭代器模式(Iterator)",
      "访问器模式(Visitor)",
      "4 设计模式的共性与差异*",
      "第十二章 面向正确性与健壮性的软件构造",
      "1 什么是健壮性和正确性？",
      "2 如何量度健壮性和正确性",
      "3 Java中的Error和Exception*",
      "4 异常处理*",
      "5 断言",
      "6 防御式编程",
      "7 SpotBugs工具",
      "第十章 面向可维护性的构造技术",
      "1 软件可维护性和演化",
      "软件维护：修复错误、改善性能",
      "主要步骤：1.测试所做的修改",
      "2.回归测试",
      "3.记录变化",
      "除了修复问题，修改中不能引入新的故障",
      "最大的问题：修改后没有足够的文档记录和测试",
      "软件可维护性的类型：软件演化：对软件进行持续的更新",
      "软件的大部分成本来自于维护阶段",
      "软件维护不仅仅是运维工程师的工作",
      "而是从设计和开发阶段就开始了",
      "在设计与开发阶段就要考虑将来的可维护性",
      "面向可维护性的构造技术：1.模块化设计",
      "2.OO设计原则",
      "3.OO设计模式",
      "4.基于状态的构造技术",
      "5.表驱动的构造技术",
      "6.基于语法的构造技术",
      "2 可维护性的指标",
      "可维护性：软件系统或组件易于修改以纠正故障、提高性能或其他属性",
      "或适应已改变的环境”",
      "可拓展性：软件设计/实施考虑到未来的增长",
      "可拓展性被视为扩展系统能力和实施扩展所需努力水平的系统衡量",
      "灵活性：软件根据用户需求、外部技术和社会环境等而轻松改变的能力",
      "可适应性：交互系统（自适应系统）的能力",
      "可以根据获取的用户及其环境信息来适应个别用户的行为",
      "可管理性：监控和维护软件系统的效率和容易",
      "以保持系统运行、安全和平稳运行",
      "支持性：基于包括质量文档、诊断信息和知识渊博的技术人员的资源",
      "在部署后软件如何有效地运行",
      "Halstead Volume:基于源代码中（不同的）运算符和操作数数量的复合度量",
      "3 模块化设计和模块化原则",
      "目的：将系统划分为模块",
      "并用一种模块内高内聚",
      "模块间低耦合的方式分配各模块的职责",
      "模块化降低了程序员在任何时候都必须处理的总复杂性",
      "做到分离关注点和信息隐藏",
      "评估模块性的五个标准：1.可分解性(Decomposability)：较大的组件是否已分解为较小的组件",
      "2.可组合性(Composability)：较大的组件是否可以由较小的组件构成",
      "3.可理解性(Understandability)：组件是否可以单独理解",
      "4.可持续性(Continuity)：对规约的小改变是否只影响本地优先数量的组件",
      "5.出现异常之后的保护(Protection)：运行时异常的影响是否局限于少量的相关组件",
      "五个模块化设计的规则：1.直接映射(Direct Mapping)",
      "2.尽可能少的接口(Few Interfaces)",
      "3.尽可能小的接口(Small Interfaces)",
      "4.显式接口(Explicit Interfaces)",
      "5.信息隐藏(Information Hiding)",
      "耦合性：耦合是衡量模块之间依赖关系的度量方法",
      "模块间耦合性程度由模块之间的接口数量和每个接口的复杂性决定(复杂性由通信的类型决定)",
      "内聚性：是衡量模块功能或责任的紧密相关的标准",
      "如果一个模块的所有元素都在朝着相同的目标工作",
      "那么该模块就具有很高的内聚性",
      "好的设计需要高内聚",
      "低耦合",
      "但有时需要折中",
      "耦合程度高时",
      "内聚内聚程度倾向于变低",
      "反之亦然",
      "4 OO设计原则：SOLID*",
      "SOLID：五大类的设计原则",
      "The Single Responsibility Principle 单一责任原则(SRP)",
      "The Open-Closed Principle 开放-封闭原则(OCP)",
      "The Liskov Substitution Principle Liskov替换原则(LSP)",
      "The Dependency Inversion Principle 依赖转置原则(DIP)",
      "The Interface Segregation Principle 接口聚合原则(ISP)",
      "单一责任原则(SRP)",
      "SRP:不应该有多于1个原因让你的ADT发生变化",
      "否则就拆分开；一个类",
      "一个责任",
      "责任：变化的原因",
      "如果一个类包含了多个责任",
      "那么将引起不良后果：1.引入额外的包",
      "占据资源",
      "2.导致频繁的重新配置、部署等",
      "开放-封闭原则(OCP)",
      "开放：对拓展性的开发",
      "模块的行为应是可扩展的",
      "从而该模块可表现出新的行为以满足需求的变化",
      "封闭：对修改的封闭",
      "模块自身的代码是不应被修改的；扩展模块行为的一般途径是修改模块的内部实现；如果一个模块不能被修改",
      "那么它通常被认为是具有固定的行为",
      "关键的解决方案：抽象技术",
      "“软件实体（类、模块、功能等）",
      "应该开放扩展",
      "但关闭修改”",
      "即使用继承和组合/委托更改类的行为",
      "Liskov替换原则(LSP)",
      "LSP：子类型必须能够替换其基类型",
      "派生类必须能够通过其基类的接口使用",
      "客户端无需了解两者之间的差异",
      "接口隔离原则(ISP)",
      "ISP：不能强迫客户端依赖于他们不需要的接口",
      "只提供必需的接口",
      "不要用许多方法污染接口",
      "避免臃肿的接口",
      "客户端不应该被强迫依赖他们不需要的方法",
      "接口属于客户端，而不是体系结构",
      "接口臃肿的类是接口不够聚合的类",
      "胖接口可以分解为多个小接口；不同的接口向不同的客户端提供服务；客户端只访问自己所需要的接口",
      "图示：依赖转置原则(DIP)",
      "DIP：抽象的模块不应该依赖于具体的模块",
      "具体的模块应该依赖于抽象的",
      "大部分的接口和抽象都应该被使用",
      "delegation时，要通过接口建立联系，而非具体子类",
      "注：本节SOLID五个原则都应该了解",
      "5 语法驱动的构造*",
      "语法的构成要素",
      "有一类应用，从外部读取文本数据，在应用中做进一步处理",
      "特定的",
      "字节或字符序列应该有如下特性：1.输入文件有特定格式",
      "程序需读取文件并从中抽取正确的内容",
      "2.从网络上传输过来的信息，遵循特定的协议",
      "3.用户在命令行输入的指令，遵循特定的格式",
      "4.内存中存储的字符串，也有格式需要",
      "通常使用语法分析来判断字符串是否合法",
      "并解析成程序里使用的数据结构",
      "且这个数据通常是一个递归的数据结构",
      "一个语法定义了一个字符串集合",
      "语法中的文字字符串被称作终止节点",
      "他们是语法解析树的叶节点",
      "无法再向下扩展",
      "通常被表示为字符串",
      "一个语法由一个产生式节点的集合描述",
      "其中每一个产生式都定义了一个非终止节点",
      "并遵循特定规则",
      "利用操作符、终止节点和其他非终止节点",
      "构造新的字符串",
      "非终止节点是树中表示字符串的内部节点",
      "一个语法中的产生式有如下形式：nonterminal ::= expression of terminals, nonterminals, and operators",
      "根节点：是一个语法中的非终止节点",
      "语法识别出的字符串集合中都是与根节点匹配的字符串",
      "语法中的运算*",
      "三种基本语法运算：连接(Concatenation) - x::= y z - x匹配y后接z的字符串",
      "重复(Repetition) - x::=y* - x匹配零个或多个y",
      "选择(Union) - x::= y | z - x要么匹配y要么匹配z",
      "运算优先级：1.通常情况下",
      "前缀运算符*, ?, +有最高的运算优先度",
      "2.连接其次",
      "3.选择优先度最低",
      "但圆括号可以被用作修改优先级，括号内的优先运算",
      "其他语法运算符：可选(Optional) - x ::= y+ - x要么是y要么为空",
      "一次或多次出现 - x ::= y+ - x是一个或多个y的连接",
      "一个字符类 - x ::= […] - 表示包含方括号中列出的任何字符的长度为1的字符串,例如",
      "x ::= [a-c] 等价于 x ::= ‘a’ | ‘b’ | ‘c’",
      "一个倒置的字符类 - x ::= [^…] - 表示包含括号中未列出的任何字符的长度为1的字符串",
      "例如",
      "x ::= [^a-c] 等价于 x ::= ‘d’ | ‘e’ | ‘f’ | …",
      "语法中的递归",
      "分析树",
      "分析树：根据语法匹配将一个字符串生成一个能显示字符串中的各部分如何和语法中各部分联系起来的树",
      "树的叶节点标记着终止符号",
      "代表已经被分析完的字符串部分",
      "如果从左到右将叶节点连接",
      "将获得原字符串",
      "正则语法和正则表达式*",
      "正则语法：简化之后可以表达为一个产生式而不包含任何非终止节点",
      "正则表达式：终端和运算符的约简表达式可以写成一种更紧凑的形式",
      "称为正则表达式",
      "正则表达式会去掉了终端周围的引号以及终端和运算符之间的空格",
      "因此它只由终端字符、用于分组的括号和运算符字符组成",
      "一些正则表达式的运算：. - 任意字符",
      "\\d - 任意数字",
      "\\s - 任意空白符",
      "\\w 任意有意义的字符，相当于[a-zA-Z_0-9]",
      ". ( ) * + … - 表示反斜杠后的字符",
      "注：本节只需要学会正则表达式即可",
      "第十一章 面向可复用性和可维护性的设计模式",
      "1 创建模式*",
      "工厂方法",
      "也被称作虚拟构造器",
      "当client不知道要创建哪个具体类的实例",
      "或者不想在client代码中指明要具体创建的实例时",
      "用工厂方法",
      "可以定义一个用于创建对象的接口",
      "让其子类来决定实例化哪个类",
      "从而使一个类的实例化延迟到其子类",
      "带有工厂方法的类也可以实现其他功能",
      "有新的具体产品类加入时",
      "可以在工厂类里修改过增加新的工厂函数(OCP)",
      "不会影响客户端代码",
      "客户端使用工厂方法来创建实例",
      "得到的实例的类型是抽象接口而非具体类",
      "根据类型决定创建哪个具体产品",
      "优点：消除了将特定于应用程序的类绑定到代码的需要",
      "代码仅处理产品接口，因此它可以处理任何用户定义的具体产品",
      "潜在缺点：客户可能必须创建构造类的子类",
      "以便他们可以创建特定的产品",
      "注：本节了解一下就行",
      "2 结构模式*",
      "适配器模式(Adapter Pattern)",
      "将某个类/接口转换为客户端期望的其他形式",
      "适配器使由于不相容的接口导致本不能一起使用的类可以一起使用",
      "一般通过增加一个接口",
      "将已存在的子类封装起来",
      "客户端面向接口编程",
      "从而隐藏了具体子类",
      "装饰器模式(Decorator)",
      "装饰器用于为对象添加不同侧面的特性",
      "对于每一个特性构造子类",
      "通过委派机制增加到对象上",
      "装饰器使用了子类型和委派",
      "Collections.unmodifiedSet等通过装饰器实现",
      "修改原数据依然会导致所得到的添加特性后的对象改变",
      "客户端需要一个具有多种特性的object",
      "可以通过一层一层的装饰来实现",
      "注：本节需要简单理解一下",
      "3 行为模式*",
      "策略模式(Strategy)",
      "问题：有多种不同的算法来实现同一个任务",
      "但需要客户端根据需要动态切换算法",
      "而不是写死在代码中",
      "实现方法：为不同的实现算法构造抽象接口",
      "利用delegation",
      "运行时动态传入客户端倾向的算法实例",
      "优点：易于扩展到新的算法实现",
      "将算法与客户端上下文进行分离",
      "模板模式(Template Method)",
      "问题：做事情的步骤一样，但具体方法不同",
      "实现方法：共性的步骤在抽象类内公共实现",
      "差异化的步骤在各个子类中实现",
      "模板模式使用继承和重写方法组合的策略来实现",
      "迭代器模式(Iterator)",
      "问题：客户端希望遍历被放入容器/集合类的一组ADT对象",
      "无需关心容器的具体类型",
      "解决方案：一种专为迭代的策略模式",
      "作用：1.隐藏底层容器的内部实现",
      "2.支持具有统一接口的多个遍历策略",
      "3.易于更改容器类型",
      "4.促进项目各部分之间的沟通",
      "Iterable接口：实现该接口的集合对象是可迭代遍历的",
      "Iterator接口：迭代器",
      "迭代器模式：让自己的集合实现Iterable接口",
      "并实现自己的独特Iterator迭代器",
      "允许客户端利用这个迭代器进行显示或隐式的迭代遍历：访问器模式(Visitor)",
      "Visitor pattern：对特定类型的object的特定操作(visit)",
      "在运行时将二者动态绑定到一起",
      "该操作可以灵活更改",
      "无需更改被visit的类",
      "本质上：将数据和作用于数据上的某种/些特定操作分离开",
      "效果：为ADT预留一个将来可拓展功能的“接入点”",
      "外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT",
      "只要更换visitor的具体实现，即可切换算法",
      "注：本节内容都比较重要，需要会根据各种设计模式写代码",
      "4 设计模式的共性与差异*",
      "共性样式1：只使用继承，不使用委派",
      "核心思路OCP/DIP",
      "依赖反转",
      "客户端只依赖“抽象”",
      "不能依赖于”具体“",
      "发生变化时最好是扩展，而非修改",
      "代表：Adaptor、Template",
      "共性样式2：注：本节需要理解",
      "第十二章 面向正确性与健壮性的软件构造",
      "1 什么是健壮性和正确性？",
      "健壮性(Robustness)：系统在不正常输入或不正常外部环境下仍能够表现正常的程度",
      "面向健壮性的编程：1.处理未期望的行为和错误终止",
      "2.即使终止执行，也要准确/无歧义的向用户展示全面的错误信息",
      "3.错误信息有助于debug",
      "健壮性原则：1.总是假定用户恶意，假定自己的代码可能失败",
      "2.把用户想象成白痴，可能输入任何东西",
      "3.对别人宽容点，对自己狠一点",
      "对自己的代码要保守，对用户的行为要开放",
      "健壮性编程的原则：1.封闭实现细节，限定用户的恶意行为",
      "2.考虑极端情况，没有不可能",
      "正确性(Correctness)：程序按照spec加以执行的能力",
      "是最重要的质量指标",
      "正确性 - 永不给用户错误的结构",
      "健壮性 - 尽可能保持软件运行而不是总是退出",
      "正确性倾向于直接报错(error)",
      "健壮性则倾向于容错(fault-tolerance)",
      "健壮性：让用户变得更容易：出错也可以容忍",
      "程序内部已有容错机制",
      "正确性：让开发者变得更容易：用户输入错误（不满足precondition的调用）",
      "直接结束",
      "对外的接口，倾向于健壮；对内的实现，倾向于正确",
      "安全关键型应用程序相比于健壮性倾向于支持正确性",
      "消费者的应用程序相比于正确性倾向于支持健壮性",
      "可靠性(Reliability)：系统在规定条件下执行其所需功能的能力 - 故障之间的平均时间长度",
      "Reliability = Robustness + Correctness",
      "提高健壮性和正确性的步骤：0.使用断言、防御性编程、代码审查、正式验证等来编写具有健壮性和正确性的代码",
      "1.观察故障症状（内存转储、堆栈跟踪、执行日志、测试）",
      "2.识别潜在的故障（错误定位、调试）",
      "3.修复错误（代码修订）",
      "2 如何量度健壮性和正确性",
      "外部观察角度：Mean time between failures 平均失效间隔时间(MTBF)：系统运行过程中系统固有故障之间的预期运行时间",
      "MTBF描述了可修复系统的两次故障之间的预期时间",
      "而 mean time to failure 平均故障时间(MTTF)表示不可修复系统的预期故障时间",
      "内部观察角度：残余缺陷率：每千行代码中遗留的bug数量",
      "3 Java中的Error和Exception*",
      "内部错误：程序员通常无能为力",
      "一旦发生",
      "想办法让程序优雅的结果",
      "异常：程序的问题，可以捕获、可以处理",
      "Error种类：用户输入错误、设备错误、物理限制",
      "大多数情况下，Error不需要被实例化",
      "注：本节了解一下就行",
      "4 异常处理*",
      "使用try - catch结构",
      "异常：程序执行中的非正常时间，程序无法再按预想的流程执行",
      "Exception会将错误信息传递给上层调用者",
      "并报告”案发现场“的信息",
      "Exception可以是return之外的第二种退出途径 - 当找不到异常处理程序时",
      "整个系统会完全退出",
      "异常可以被分为RuntimeException和其他类型",
      "运行时异常：由程序员在代码中处理不当造成",
      "是程序源代码中引入的故障造成的",
      "如果在代码中提前进行验证",
      "则这些故障就可以避免",
      "其他异常：由外部原因造成",
      "是程序员无法完全控制的外在问题所导致的",
      "即使在代码中提前加以验证(文件是否存在等)",
      "也无法完全避免失效发生",
      "当异常产生时",
      "要么异常处理程序处理了异常",
      "要么会告诉编译器无法处理该异常",
      "并在命令行中输出错误信息",
      "编译器可以帮助检查程序是否已经抛出或处理了可能的异常",
      "Error和RuntimeException并不被编译器进行检查",
      "RuntimeException不需要在编译时用try catch等机制处理",
      "但执行时可能会导致程序失败",
      "代表程序中的潜在bug - 类似动态检查",
      "而其他Exception则必须捕获并指定错误处理程序",
      "否则编译无法通过 - 类似静态类型检查",
      "Java中异常处理的关键字：try、catch、finally、throws、throw",
      "throws：表明方法会抛出XX异常",
      "throw：抛出XX异常",
      "try、catch、finally：捕获并处理XX异常",
      "Unchecked异常也可以使用throws声明或try/catch进行捕获",
      "但大多数时候是不需要的",
      "也不应该这么做 - 掩耳盗铃",
      "对发现的编程错误充耳不闻",
      "如果客户端可以通过其他的方法恢复异常",
      "那么采用checked exception；如果客户端对出现的这种异常无能为力",
      "那么采用unchecked exception；异常出现的时候",
      "要做一些试图恢复它的动作而不要仅仅的打印它的信息",
      "“异常”也是方法和client端之间spec的一部分",
      "在post-condition中刻画",
      "对于checked exception",
      "需要在方法声明后加throws XX异常",
      "程序员必须在方法的spec中明确写清本方法会抛出的所有checked exception",
      "以便于调用该方法的client加以处理",
      "而unchecked exception则不需要",
      "若一个程序内部某方法可能抛出某checked exception",
      "则要么它内部有该异常的处理程序",
      "要么它也声明会抛出异常",
      "将异常移交给调用它的方法处理",
      "若没有处理程序来处理checked exception",
      "程序将终止运行",
      "程序员不应抛出Error",
      "Error通常只指虚拟机或动态库的错误",
      "子类型多态相关：1.如果子类型中override了父类型中的函数",
      "那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛",
      "2.子类型方法可以抛出更具体的异常，也可以不抛出任何异常",
      "3.如果父类型的方法未抛出异常",
      "那么子类型的方法也不能抛出异常",
      "抛出异常方法：流程：1.找到到一个能表达错误的Exception类/或者构造一个新的Exception类",
      "2.构造Exception类的实例，将错误信息写入",
      "3.抛出它",
      "一旦抛出异常",
      "方法不会再将控制权返回给调用它的client",
      "因此也无需考虑返回错误代码",
      "构造异常类：对于checked exception",
      "只需要继承Exception类",
      "对于unchecked exception",
      "只需要继承RuntimeException类",
      "异常处理程序：若某段代码中可能抛出异常",
      "可以将这段代码包含在try代码块内",
      "并使用catch捕获其抛出的各种异常",
      "若在各catch代码段后有finally代码段",
      "程序会在执行完catch代码段后执行finally代码段",
      "另外",
      "没有抛出异常时finally代码段也会被执行",
      "finally代码段通常用于清理异常发生前曾申请过的资源",
      "重新抛出异常：catch代码段中也可以抛出异常",
      "目的：更改exception的类型",
      "更方便客户端获取错误信息并处理",
      "调用栈追踪：注：本节需要学会ava中的两类异常",
      "并掌握他们区别",
      "并掌握异常抛出、处理等相关代码的编写",
      "还需要了解异常处理观察者控制的转移路径",
      "以及异常导致程序退出时显示的的方法调用栈含义",
      "5 断言",
      "断言：当不满足前提条件时",
      "此代码通过抛出断言错误异常来终止程序",
      "调用者的错误的影响无法传播",
      "检查前置条件是防御式编程的一种典型形式",
      "为什么要断言：在开发阶段的代码中嵌入",
      "检验某些“假设”是否成立",
      "若成立，表明程序运行正常，否则表明存在错误",
      "断言即是对代码中程序员所做假设的文档化，也不会影响运行时性能",
      "(在实际使用时，assertion都会被disabled)",
      "断言为了程序正确性",
      "使用断言处理“绝不应该发生”的情况",
      "如果来自于自己",
      "所写的其他代码，可以使用断言来帮助发现错误",
      "异常为了程序健壮性",
      "使用异常来处理你“预料到可以发生”的不正常情况",
      "如果参数来",
      "自于外部（不受自己控制），使用异常处理",
      "6 防御式编程",
      "防御性编程是一种防御性设计的形式",
      "旨在确保一块软件在不可预见的情况下的持续功能",
      "7 SpotBugs工具",
      "SpotBugs是一个使用静态分析来查找Java代码中的bug的程序"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "注：文章中带有 * 的标题表示往年考试中出现过相应考点\n文章目录\n第十章 面向可维护性的构造技术\n1 软件可维护性和演化\n2 可维护性的指标\n3 模块化设计和模块化原则\n4 OO设计原则：SOLID*\n单一责任原则(SRP)\n开放-封闭原则(OCP)\nLiskov替换原则(LSP)\n接口隔离原则(ISP)\n依赖转置原则(DIP)\n5 语法驱动的构造*\n语法的构成要素\n语法中的运算*\n语法中的递归\n分析树\n正则语法和正则表达式*\n第十一章 面向可复用性和可维护性的设计模式\n1 创建模式*\n2 结构模式*\n适配器模式(Adapter Pattern)\n装饰器模式(Decorator)\n3 行为模式*\n策略模式(Strategy)\n模板模式(Template Method)\n迭代器模式(Iterator)\n访问器模式(Visitor)\n4 设计模式的共性与差异*\n第十二章 面向正确性与健壮性的软件构造\n1 什么是健壮性和正确性？\n2 如何量度健壮性和正确性\n3 Java中的Error和Exception*\n4 异常处理*\n5 断言\n6 防御式编程\n7 SpotBugs工具\n第十章 面向可维护性的构造技术\n1 软件可维护性和演化\n软件维护：修复错误、改善性能\n主要步骤：\n1.测试所做的修改\n2.回归测试\n3.记录变化\n除了修复问题，修改中不能引入新的故障\n最大的问题：修改后没有足够的文档记录和测试\n软件可维护性的类型：\n软件演化：对软件进行持续的更新，软件的大部分成本来自于维护阶段\n软件维护不仅仅是运维工程师的工作，而是从设计和开发阶段就开始了\n在设计与开发阶段就要考虑将来的可维护性\n面向可维护性的构造技术：\n1.模块化设计\n2.OO设计原则\n3.OO设计模式\n4.基于状态的构造技术\n5.表驱动的构造技术\n6.基于语法的构造技术\n2 可维护性的指标\n可维护性：软件系统或组件易于修改以纠正故障、提高性能或其他属性，或适应已改变的环境”。\n可拓展性：软件设计/实施考虑到未来的增长，可拓展性被视为扩展系统能力和实施扩展所需努力水平的系统衡量。\n灵活性：软件根据用户需求、外部技术和社会环境等而轻松改变的能力。\n可适应性：交互系统（自适应系统）的能力，可以根据获取的用户及其环境信息来适应个别用户的行为。\n可管理性：监控和维护软件系统的效率和容易，以保持系统运行、安全和平稳运行。\n支持性：基于包括质量文档、诊断信息和知识渊博的技术人员的资源，在部署后软件如何有效地运行。\nHalstead Volume:基于源代码中（不同的）运算符和操作数数量的复合度量。\n3 模块化设计和模块化原则\n目的：将系统划分为模块，并用一种模块内高内聚，模块间低耦合的方式分配各模块的职责\n模块化降低了程序员在任何时候都必须处理的总复杂性，做到分离关注点和信息隐藏\n评估模块性的五个标准：\n1.可分解性(Decomposability)：较大的组件是否已分解为较小的组件\n2.可组合性(Composability)：较大的组件是否可以由较小的组件构成\n3.可理解性(Understandability)：组件是否可以单独理解\n4.可持续性(Continuity)：对规约的小改变是否只影响本地优先数量的组件\n5.出现异常之后的保护(Protection)：运行时异常的影响是否局限于少量的相关组件\n五个模块化设计的规则：\n1.直接映射(Direct Mapping)\n2.尽可能少的接口(Few Interfaces)\n3.尽可能小的接口(Small Interfaces)\n4.显式接口(Explicit Interfaces)\n5.信息隐藏(Information Hiding)\n耦合性：耦合是衡量模块之间依赖关系的度量方法\n模块间耦合性程度由模块之间的接口数量和每个接口的复杂性决定(复杂性由通信的类型决定)\n内聚性：是衡量模块功能或责任的紧密相关的标准，如果一个模块的所有元素都在朝着相同的目标工作，那么该模块就具有很高的内聚性\n好的设计需要高内聚，低耦合，但有时需要折中，耦合程度高时，内聚内聚程度倾向于变低，反之亦然\n4 OO设计原则：SOLID*\nSOLID：五大类的设计原则\nThe Single Responsibility Principle 单一责任原则(SRP)\nThe Open-Closed Principle 开放-封闭原则(OCP)\nThe Liskov Substitution Principle Liskov替换原则(LSP)\nThe Dependency Inversion Principle 依赖转置原则(DIP)\nThe Interface Segregation Principle 接口聚合原则(ISP)\n单一责任原则(SRP)\nSRP:不应该有多于1个原因让你的ADT发生变化，否则就拆分开；一个类，一个责任\n责任：变化的原因\n如果一个类包含了多个责任，那么将引起不良后果：\n1.引入额外的包，占据资源\n2.导致频繁的重新配置、部署等\n开放-封闭原则(OCP)\n开放：对拓展性的开发，模块的行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化\n封闭：对修改的封闭，模块自身的代码是不应被修改的；扩展模块行为的一般途径是修改模块的内部实现；如果一个模块不能被修改，那么它通常被认为是具有固定的行为\n关键的解决方案：抽象技术\n“软件实体（类、模块、功能等）。应该开放扩展，但关闭修改”，即使用继承和组合/委托更改类的行为\nLiskov替换原则(LSP)\nLSP：子类型必须能够替换其基类型\n派生类必须能够通过其基类的接口使用，客户端无需了解两者之间的差异\n接口隔离原则(ISP)\nISP：不能强迫客户端依赖于他们不需要的接口，只提供必需的接口\n不要用许多方法污染接口，避免臃肿的接口，客户端不应该被强迫依赖他们不需要的方法\n接口属于客户端，而不是体系结构\n接口臃肿的类是接口不够聚合的类，胖接口可以分解为多个小接口；不同的接口向不同的客户端提供服务；客户端只访问自己所需要的接口\n图示：\n依赖转置原则(DIP)\nDIP：抽象的模块不应该依赖于具体的模块，具体的模块应该依赖于抽象的\n大部分的接口和抽象都应该被使用\ndelegation时，要通过接口建立联系，而非具体子类\n注：本节SOLID五个原则都应该了解\n5 语法驱动的构造*\n语法的构成要素\n有一类应用，从外部读取文本数据，在应用中做进一步处理。\n特定的，字节或字符序列应该有如下特性：\n1.输入文件有特定格式，程序需读取文件并从中抽取正确的内容\n2.从网络上传输过来的信息，遵循特定的协议\n3.用户在命令行输入的指令，遵循特定的格式\n4.内存中存储的字符串，也有格式需要\n通常使用语法分析来判断字符串是否合法，并解析成程序里使用的数据结构，且这个数据通常是一个递归的数据结构\n一个语法定义了一个字符串集合\n语法中的文字字符串被称作终止节点，他们是语法解析树的叶节点，无法再向下扩展，通常被表示为字符串\n一个语法由一个产生式节点的集合描述，其中每一个产生式都定义了一个非终止节点，并遵循特定规则，利用操作符、终止节点和其他非终止节点，构造新的字符串，非终止节点是树中表示字符串的内部节点\n一个语法中的产生式有如下形式：\nnonterminal ::= expression of terminals, nonterminals, and operators\n根节点：是一个语法中的非终止节点，语法识别出的字符串集合中都是与根节点匹配的字符串\n语法中的运算*\n三种基本语法运算：\n连接(Concatenation) - x::= y z - x匹配y后接z的字符串\n重复(Repetition) - x::=y* - x匹配零个或多个y\n选择(Union) - x::= y | z - x要么匹配y要么匹配z\n运算优先级：\n1.通常情况下，前缀运算符*, ?, +有最高的运算优先度\n2.连接其次\n3.选择优先度最低\n但圆括号可以被用作修改优先级，括号内的优先运算\n其他语法运算符：\n可选(Optional) - x ::= y+ - x要么是y要么为空\n一次或多次出现 - x ::= y+ - x是一个或多个y的连接\n一个字符类 - x ::= […] - 表示包含方括号中列出的任何字符的长度为1的字符串,例如\nx ::= [a-c] 等价于 x ::= ‘a’ | ‘b’ | ‘c’\n一个倒置的字符类 - x ::= [^…] - 表示包含括号中未列出的任何字符的长度为1的字符串，例如\nx ::= [^a-c] 等价于 x ::= ‘d’ | ‘e’ | ‘f’ | …\n语法中的递归\n分析树\n分析树：根据语法匹配将一个字符串生成一个能显示字符串中的各部分如何和语法中各部分联系起来的树\n树的叶节点标记着终止符号，代表已经被分析完的字符串部分，如果从左到右将叶节点连接，将获得原字符串\n正则语法和正则表达式*\n正则语法：简化之后可以表达为一个产生式而不包含任何非终止节点\n正则表达式：终端和运算符的约简表达式可以写成一种更紧凑的形式，称为正则表达式。\n正则表达式会去掉了终端周围的引号以及终端和运算符之间的空格，因此它只由终端字符、用于分组的括号和运算符字符组成。\n一些正则表达式的运算：\n. - 任意字符\n\\d - 任意数字\n\\s - 任意空白符\n\\w 任意有意义的字符，相当于[a-zA-Z_0-9]\n. ( ) * + … - 表示反斜杠后的字符\n注：本节只需要学会正则表达式即可\n第十一章 面向可复用性和可维护性的设计模式\n1 创建模式*\n工厂方法，也被称作虚拟构造器，当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。\n可以定义一个用于创建对象的接口，让其子类来决定实例化哪个类，从而使一个类的实例化延迟到其子类\n带有工厂方法的类也可以实现其他功能\n有新的具体产品类加入时，可以在工厂类里修改过增加新的工厂函数(OCP)，不会影响客户端代码\n客户端使用工厂方法来创建实例，得到的实例的类型是抽象接口而非具体类\n根据类型决定创建哪个具体产品\n优点：\n消除了将特定于应用程序的类绑定到代码的需要。\n代码仅处理产品接口，因此它可以处理任何用户定义的具体产品\n潜在缺点：\n客户可能必须创建构造类的子类，以便他们可以创建特定的产品。\n注：本节了解一下就行\n2 结构模式*\n适配器模式(Adapter Pattern)\n将某个类/接口转换为客户端期望的其他形式，适配器使由于不相容的接口导致本不能一起使用的类可以一起使用。一般通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。\n装饰器模式(Decorator)\n装饰器用于为对象添加不同侧面的特性，对于每一个特性构造子类，通过委派机制增加到对象上\n装饰器使用了子类型和委派\nCollections.unmodifiedSet等通过装饰器实现，修改原数据依然会导致所得到的添加特性后的对象改变\n客户端需要一个具有多种特性的object，可以通过一层一层的装饰来实现\n注：本节需要简单理解一下\n3 行为模式*\n策略模式(Strategy)\n问题：有多种不同的算法来实现同一个任务，但需要客户端根据需要动态切换算法，而不是写死在代码中\n实现方法：为不同的实现算法构造抽象接口，利用delegation，运行时动态传入客户端倾向的算法实例\n优点：\n易于扩展到新的算法实现\n将算法与客户端上下文进行分离\n模板模式(Template Method)\n问题：做事情的步骤一样，但具体方法不同\n实现方法：共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现\n模板模式使用继承和重写方法组合的策略来实现\n迭代器模式(Iterator)\n问题：客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型\n解决方案：一种专为迭代的策略模式\n作用：\n1.隐藏底层容器的内部实现\n2.支持具有统一接口的多个遍历策略\n3.易于更改容器类型\n4.促进项目各部分之间的沟通\nIterable接口：实现该接口的集合对象是可迭代遍历的\nIterator接口：迭代器\n迭代器模式：让自己的集合实现Iterable接口，并实现自己的独特Iterator迭代器，允许客户端利用这个迭代器进行显示或隐式的迭代遍历：\n访问器模式(Visitor)\nVisitor pattern：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类\n本质上：将数据和作用于数据上的某种/些特定操作分离开\n效果：为ADT预留一个将来可拓展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT\n只要更换visitor的具体实现，即可切换算法\n注：本节内容都比较重要，需要会根据各种设计模式写代码\n4 设计模式的共性与差异*\n共性样式1：只使用继承，不使用委派\n核心思路OCP/DIP，依赖反转，客户端只依赖“抽象”，不能依赖于”具体“\n发生变化时最好是扩展，而非修改\n代表：Adaptor、Template\n共性样式2：\n注：本节需要理解\n第十二章 面向正确性与健壮性的软件构造\n1 什么是健壮性和正确性？\n健壮性(Robustness)：系统在不正常输入或不正常外部环境下仍能够表现正常的程度\n面向健壮性的编程：\n1.处理未期望的行为和错误终止\n2.即使终止执行，也要准确/无歧义的向用户展示全面的错误信息\n3.错误信息有助于debug\n健壮性原则：\n1.总是假定用户恶意，假定自己的代码可能失败\n2.把用户想象成白痴，可能输入任何东西\n3.对别人宽容点，对自己狠一点\n对自己的代码要保守，对用户的行为要开放\n健壮性编程的原则：\n1.封闭实现细节，限定用户的恶意行为\n2.考虑极端情况，没有不可能\n正确性(Correctness)：程序按照spec加以执行的能力，是最重要的质量指标\n正确性 - 永不给用户错误的结构\n健壮性 - 尽可能保持软件运行而不是总是退出\n正确性倾向于直接报错(error)，健壮性则倾向于容错(fault-tolerance)\n健壮性：让用户变得更容易：出错也可以容忍，程序内部已有容错机制\n正确性：让开发者变得更容易：用户输入错误（不满足precondition的调用），直接结束。\n对外的接口，倾向于健壮；对内的实现，倾向于正确\n安全关键型应用程序相比于健壮性倾向于支持正确性\n消费者的应用程序相比于正确性倾向于支持健壮性\n可靠性(Reliability)：系统在规定条件下执行其所需功能的能力 - 故障之间的平均时间长度。\nReliability = Robustness + Correctness\n提高健壮性和正确性的步骤：\n0.使用断言、防御性编程、代码审查、正式验证等来编写具有健壮性和正确性的代码\n1.观察故障症状（内存转储、堆栈跟踪、执行日志、测试）\n2.识别潜在的故障（错误定位、调试）\n3.修复错误（代码修订）\n2 如何量度健壮性和正确性\n外部观察角度：\nMean time between failures 平均失效间隔时间(MTBF)：系统运行过程中系统固有故障之间的预期运行时间。\nMTBF描述了可修复系统的两次故障之间的预期时间，而 mean time to failure 平均故障时间(MTTF)表示不可修复系统的预期故障时间。\n内部观察角度：\n残余缺陷率：每千行代码中遗留的bug数量\n3 Java中的Error和Exception*\n内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结果\n异常：程序的问题，可以捕获、可以处理\nError种类：用户输入错误、设备错误、物理限制\n大多数情况下，Error不需要被实例化\n注：本节了解一下就行\n4 异常处理*\n使用try - catch结构\n异常：程序执行中的非正常时间，程序无法再按预想的流程执行\nException会将错误信息传递给上层调用者，并报告”案发现场“的信息\nException可以是return之外的第二种退出途径 - 当找不到异常处理程序时，整个系统会完全退出\n异常可以被分为RuntimeException和其他类型\n运行时异常：由程序员在代码中处理不当造成，是程序源代码中引入的故障造成的，如果在代码中提前进行验证，则这些故障就可以避免\n其他异常：由外部原因造成，是程序员无法完全控制的外在问题所导致的，即使在代码中提前加以验证(文件是否存在等)，也无法完全避免失效发生\n当异常产生时，要么异常处理程序处理了异常，要么会告诉编译器无法处理该异常，并在命令行中输出错误信息。编译器可以帮助检查程序是否已经抛出或处理了可能的异常。\nError和RuntimeException并不被编译器进行检查，\nRuntimeException不需要在编译时用try catch等机制处理，但执行时可能会导致程序失败，代表程序中的潜在bug - 类似动态检查\n而其他Exception则必须捕获并指定错误处理程序，否则编译无法通过 - 类似静态类型检查\nJava中异常处理的关键字：try、catch、finally、throws、throw\nthrows：表明方法会抛出XX异常\nthrow：抛出XX异常\ntry、catch、finally：捕获并处理XX异常\nUnchecked异常也可以使用throws声明或try/catch进行捕获，但大多数时候是不需要的，也不应该这么做 - 掩耳盗铃，对发现的编程错误充耳不闻\n如果客户端可以通过其他的方法恢复异常，那么采用checked exception；\n如果客户端对出现的这种异常无能为力，那么采用unchecked exception；\n异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息\n“异常”也是方法和client端之间spec的一部分，在post-condition中刻画\n对于checked exception，需要在方法声明后加throws XX异常\n程序员必须在方法的spec中明确写清本方法会抛出的所有checked exception，以便于调用该方法的client加以处理\n而unchecked exception则不需要\n若一个程序内部某方法可能抛出某checked exception，则要么它内部有该异常的处理程序，要么它也声明会抛出异常，将异常移交给调用它的方法处理。若没有处理程序来处理checked exception，程序将终止运行\n程序员不应抛出Error，Error通常只指虚拟机或动态库的错误\n子类型多态相关：\n1.如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛\n2.子类型方法可以抛出更具体的异常，也可以不抛出任何异常\n3.如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。\n抛出异常方法：\n流程：\n1.找到到一个能表达错误的Exception类/或者构造一个新的Exception类\n2.构造Exception类的实例，将错误信息写入\n3.抛出它\n一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码\n构造异常类：\n对于checked exception，只需要继承Exception类\n对于unchecked exception，只需要继承RuntimeException类\n异常处理程序：\n若某段代码中可能抛出异常，可以将这段代码包含在try代码块内，并使用catch捕获其抛出的各种异常。若在各catch代码段后有finally代码段，程序会在执行完catch代码段后执行finally代码段，另外，没有抛出异常时finally代码段也会被执行。\nfinally代码段通常用于清理异常发生前曾申请过的资源\n重新抛出异常：catch代码段中也可以抛出异常\n目的：更改exception的类型，更方便客户端获取错误信息并处理\n调用栈追踪：\n注：本节需要学会ava中的两类异常，并掌握他们区别，并掌握异常抛出、处理等相关代码的编写，还需要了解异常处理观察者控制的转移路径，以及异常导致程序退出时显示的的方法调用栈含义\n5 断言\n断言：当不满足前提条件时，此代码通过抛出断言错误异常来终止程序。调用者的错误的影响无法传播。检查前置条件是防御式编程的一种典型形式\n为什么要断言：\n在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误。\n断言即是对代码中程序员所做假设的文档化，也不会影响运行时性能\n(在实际使用时，assertion都会被disabled)\n断言为了程序正确性，使用断言处理“绝不应该发生”的情况，如果来自于自己\n所写的其他代码，可以使用断言来帮助发现错误\n异常为了程序健壮性，使用异常来处理你“预料到可以发生”的不正常情况，如果参数来\n自于外部（不受自己控制），使用异常处理\n6 防御式编程\n防御性编程是一种防御性设计的形式，旨在确保一块软件在不可预见的情况下的持续功能。\n7 SpotBugs工具\nSpotBugs是一个使用静态分析来查找Java代码中的bug的程序\n"
  },
  {
    "head": "java设计模式--对象适配器模式",
    "paragraphs": [
      "一、适配器模式（Adapter Pattern)的思想",
      "二、适配器模式中的三个角色",
      "三、对象适配器模式",
      "适配器模式的优点",
      "一、适配器模式（Adapter Pattern)的思想",
      "思想：把一个类/接口转换为客户端期望的形式。",
      "这样做的好处：",
      "1.使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。",
      "2.通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。",
      "二、适配器模式中的三个角色",
      "目标(Target):",
      "客户端期待得到的接口。",
      "源(Adaptee):",
      "需要被适配的接口。",
      "适配器(Adapter)",
      "：连接目标和源，把源接口转换成期待的目标接口。",
      "适配器模式包括3种形式：类适配器模式、对象适配器模式、接口适配器模式。本文主要介绍对象适配器。",
      "三、对象适配器模式",
      "在对象适配器模式中，目标ITarget是一个与客户端需求匹配的接口，适配器Adapter和源Adaptee之间是委派关系（delegation）。",
      "以下面的代码为例：",
      "客户端想调用LegacyRectangle中的方法，画出一个长方形。这个例子中LegacyRectangle类就是源。但是客户端想要传入的是左上角的顶点和右下角的顶点，而源Adaptee中的方法需要的参数是左上角的顶点，以及宽和高，出现了不适配。",
      "此时通过对象适配器模式，先增加一个接口shape ，这个接口与客户端的要求适配。（客户端对抽象接口编程，与LegacyRectangle隔离）",
      "再用一个Rectangle类实现shape接口，此时Rectangle充当的是Adapter的角色，通过与LegacyRectangle类建立委派关系完成display方法的实现。",
      "此时客户端的代码实现如下：",
      "可以看到，通过适配器Rectangle, 解决了LegacyRectangle与客户端期望形式不匹配的问题，实现了代码的复用。",
      "适配器模式的优点",
      "代码复用",
      "：使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。可以复用已经实现的类的功能。",
      "：通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。"
    ],
    "sentences": [
      "一、适配器模式（Adapter Pattern)的思想",
      "二、适配器模式中的三个角色",
      "三、对象适配器模式",
      "适配器模式的优点",
      "一、适配器模式（Adapter Pattern)的思想",
      "思想：把一个类/接口转换为客户端期望的形式",
      "这样做的好处：1.使原本因接口不匹配而无法在一起工作的两个类能够在一起工作",
      "2.通过增加一个接口",
      "将已存在的子类封装起来",
      "客户端面向接口编程",
      "从而隐藏了具体子类",
      "二、适配器模式中的三个角色",
      "目标(Target):客户端期待得到的接口",
      "源(Adaptee):需要被适配的接口",
      "适配器(Adapter)",
      "：连接目标和源，把源接口转换成期待的目标接口",
      "适配器模式包括3种形式：类适配器模式、对象适配器模式、接口适配器模式",
      "本文主要介绍对象适配器",
      "三、对象适配器模式",
      "在对象适配器模式中",
      "目标ITarget是一个与客户端需求匹配的接口",
      "适配器Adapter和源Adaptee之间是委派关系（delegation）",
      "以下面的代码为例：客户端想调用LegacyRectangle中的方法",
      "画出一个长方形",
      "这个例子中LegacyRectangle类就是源",
      "但是客户端想要传入的是左上角的顶点和右下角的顶点",
      "而源Adaptee中的方法需要的参数是左上角的顶点",
      "以及宽和高",
      "出现了不适配",
      "此时通过对象适配器模式",
      "先增加一个接口shape ",
      "这个接口与客户端的要求适配",
      "（客户端对抽象接口编程",
      "与LegacyRectangle隔离）",
      "再用一个Rectangle类实现shape接口",
      "此时Rectangle充当的是Adapter的角色",
      "通过与LegacyRectangle类建立委派关系完成display方法的实现",
      "此时客户端的代码实现如下：可以看到",
      "通过适配器Rectangle, 解决了LegacyRectangle与客户端期望形式不匹配的问题",
      "实现了代码的复用",
      "适配器模式的优点",
      "代码复用",
      "：使原本因接口不匹配而无法在一起工作的两个类能够在一起工作",
      "可以复用已经实现的类的功能",
      "：通过增加一个接口",
      "将已存在的子类封装起来",
      "客户端面向接口编程",
      "从而隐藏了具体子类"
    ],
    "codes": [
      "class Client {\n    public display() {\n        new LegacyRectangle().display(x1, y1, x2, y2);//客户端想要传入左上角的顶点和右下角的顶点\n    }\n}                                                     \n",
      "class LegacyRectangle {\n    void display(int x1, int y1, int w, int h) {\n        ...                                          //源Adaptee中的方法需要的参数是左上角的顶点，以及宽和高\n    }\n}",
      "interface Shape \n{\n    void display(int x1, int y1, int x2, int y2);\n}",
      "class Rectangle implements Shape {\n    void display(int x1, int y1, int x2, int y2) {\n        new LegacyRectangle().display(x1, y1, x2-x1, y2-y1);    //通过委派完成display\n    }\n}\n",
      "class Client{\n    Shape shape = new Rectangle();    //客户端对抽象接口编程，与LegacyRectangle隔离\n    public display() {\n        shape.display(x1, y1, x2, y2);\n    }\n}\n"
    ],
    "date": "2021-07-01",
    "text": "一、适配器模式（Adapter Pattern)的思想\n二、适配器模式中的三个角色\n三、对象适配器模式\n适配器模式的优点\n一、适配器模式（Adapter Pattern)的思想\n思想：把一个类/接口转换为客户端期望的形式。\n这样做的好处：\n1.使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。\n2.通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。\n二、适配器模式中的三个角色\n目标(Target):\n客户端期待得到的接口。\n源(Adaptee):\n需要被适配的接口。\n适配器(Adapter)\n：连接目标和源，把源接口转换成期待的目标接口。\n适配器模式包括3种形式：类适配器模式、对象适配器模式、接口适配器模式。本文主要介绍对象适配器。\n三、对象适配器模式\n在对象适配器模式中，目标ITarget是一个与客户端需求匹配的接口，适配器Adapter和源Adaptee之间是委派关系（delegation）。\n以下面的代码为例：\n客户端想调用LegacyRectangle中的方法，画出一个长方形。这个例子中LegacyRectangle类就是源。但是客户端想要传入的是左上角的顶点和右下角的顶点，而源Adaptee中的方法需要的参数是左上角的顶点，以及宽和高，出现了不适配。\n此时通过对象适配器模式，先增加一个接口shape ，这个接口与客户端的要求适配。（客户端对抽象接口编程，与LegacyRectangle隔离）\n再用一个Rectangle类实现shape接口，此时Rectangle充当的是Adapter的角色，通过与LegacyRectangle类建立委派关系完成display方法的实现。\n此时客户端的代码实现如下：\n可以看到，通过适配器Rectangle, 解决了LegacyRectangle与客户端期望形式不匹配的问题，实现了代码的复用。\n适配器模式的优点\n代码复用\n：使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。可以复用已经实现的类的功能。\n：通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。\n"
  },
  {
    "head": "软件构造（规约的强弱）",
    "paragraphs": [
      "一、什么是规约（spec)",
      "二、规约的强弱",
      "1.以下面的代码为例",
      "2.Note",
      "一、什么是规约（spec)",
      "规约是写在方法前面的注释，用来解释方法的功能、参数、返回值等",
      "为什么要为每个方法写规约？",
      "1.精确的规约，有助于区分责任",
      "2.客户端无需阅读调用函数的代码，只需理解spec即可",
      "3.规约可以隔离“变化”，无需通知客户端",
      "规约的结构：",
      "1.对方法的解释",
      "2.前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "3.后置条件：对开发者的约束，方法结束时必须满足的条件",
      "二、规约的强弱",
      "定义：规格说明S2强于（等于）规格说明S1，如果：",
      "S2的前置条件",
      "或等价于S1的",
      "S2的后置条件",
      "或等于S1的后置条件。",
      "即：spec变强意味着 更放松的前置条件+更严格的后置条件",
      "1.以下面的代码为例",
      "版本1中，对find方法的规约中，前置条件中规定val在数组a中出现有且仅有一次",
      "再看版本2",
      "此时前置条件规定val应该出现至少一次，因此前置条件变弱了，所以spec更强了",
      "再看版本3",
      "和版本2比，在满足前置条件的情况下，后置条件变强了，所以spec更强了",
      "2.Note",
      "需要注意的是，两个spec S1和S2比较时，一定要在",
      "满足前置条件",
      "的情况下比较后置条件的强弱",
      "看下面这个例子",
      "单看后置条件，S2的后置条件比S1更强，但是在满足S1的前置条件，即满足val在数组a中至少出现一次的条件时，其实S2的后置条件与S1相比并没有变化。前置条件更弱，后置条件不变，因此S2比S1更弱了。"
    ],
    "sentences": [
      "一、什么是规约（spec)",
      "二、规约的强弱",
      "1.以下面的代码为例",
      "2.Note",
      "一、什么是规约（spec)",
      "规约是写在方法前面的注释，用来解释方法的功能、参数、返回值等",
      "为什么要为每个方法写规约？",
      "1.精确的规约，有助于区分责任",
      "2.客户端无需阅读调用函数的代码，只需理解spec即可",
      "3.规约可以隔离“变化”，无需通知客户端",
      "规约的结构：1.对方法的解释",
      "2.前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "3.后置条件：对开发者的约束，方法结束时必须满足的条件",
      "二、规约的强弱",
      "定义：规格说明S2强于（等于）规格说明S1",
      "如果：S2的前置条件",
      "或等价于S1的",
      "S2的后置条件",
      "或等于S1的后置条件",
      "即：spec变强意味着 更放松的前置条件+更严格的后置条件",
      "1.以下面的代码为例",
      "版本1中",
      "对find方法的规约中",
      "前置条件中规定val在数组a中出现有且仅有一次",
      "再看版本2",
      "此时前置条件规定val应该出现至少一次",
      "因此前置条件变弱了",
      "所以spec更强了",
      "再看版本3",
      "和版本2比",
      "在满足前置条件的情况下",
      "后置条件变强了",
      "所以spec更强了",
      "2.Note",
      "需要注意的是，两个spec S1和S2比较时，一定要在",
      "满足前置条件",
      "的情况下比较后置条件的强弱",
      "看下面这个例子",
      "单看后置条件",
      "S2的后置条件比S1更强",
      "但是在满足S1的前置条件",
      "即满足val在数组a中至少出现一次的条件时",
      "其实S2的后置条件与S1相比并没有变化",
      "前置条件更弱，后置条件不变，因此S2比S1更弱了"
    ],
    "codes": [],
    "date": "2021-04-30",
    "text": "一、什么是规约（spec)\n二、规约的强弱\n1.以下面的代码为例\n2.Note\n一、什么是规约（spec)\n规约是写在方法前面的注释，用来解释方法的功能、参数、返回值等\n为什么要为每个方法写规约？\n1.精确的规约，有助于区分责任\n2.客户端无需阅读调用函数的代码，只需理解spec即可\n3.规约可以隔离“变化”，无需通知客户端\n规约的结构：\n1.对方法的解释\n2.前置条件：对客户端的约束，在使用方法时必须满足的条件\n3.后置条件：对开发者的约束，方法结束时必须满足的条件\n二、规约的强弱\n定义：规格说明S2强于（等于）规格说明S1，如果：\nS2的前置条件\n或等价于S1的\nS2的后置条件\n或等于S1的后置条件。\n即：spec变强意味着 更放松的前置条件+更严格的后置条件\n1.以下面的代码为例\n版本1中，对find方法的规约中，前置条件中规定val在数组a中出现有且仅有一次\n再看版本2\n此时前置条件规定val应该出现至少一次，因此前置条件变弱了，所以spec更强了\n再看版本3\n和版本2比，在满足前置条件的情况下，后置条件变强了，所以spec更强了\n2.Note\n需要注意的是，两个spec S1和S2比较时，一定要在\n满足前置条件\n的情况下比较后置条件的强弱\n看下面这个例子\n单看后置条件，S2的后置条件比S1更强，但是在满足S1的前置条件，即满足val在数组a中至少出现一次的条件时，其实S2的后置条件与S1相比并没有变化。前置条件更弱，后置条件不变，因此S2比S1更弱了。\n"
  },
  {
    "head": "Java 中的等价性",
    "paragraphs": [
      "一、相等（Equality）",
      "二、==与equals()",
      "1.==",
      "2.equals",
      "3.总结",
      "三、不可变类型的等价性",
      "一、相等（Equality）",
      "我们可以从三个角度来看待ADT中的相等：",
      "1.从ADT中的抽象函数AF（abstract function）：如果AF(a)=AF(b)，我们就说a和b相等。",
      "2.从关系的角度",
      "等价关系是指对于关系E ⊆ T x T ，它满足：",
      "自反性: E(t,t) ∀ t ∈ T",
      "对称性: E(t,u) ⇒ E(u,t)",
      "传递性: E(t,u) ∧ E(u,v) ⇒ E(t,v)",
      "3.从外部观察者角度：对两个对象调用任何相同的操作，都会得到相同的结果，则认为这两个对象是等价的。",
      "二、==与equals()",
      "Java有两种判断相等的操作：==和equals",
      "1.==",
      "==比较的是引用，也就是说，测试的是",
      "引用等价性",
      "。如果两个索引指向同一块存储区域，那它们就是==的。",
      "2.equals",
      "equals()操作比较对象内容，也就是测试的是",
      "对象等价性",
      "在自定义ADT时，需要重写Object的equals()",
      "3.总结",
      "使用：",
      "对基本数据类型，使用==判定相等",
      "对对象类型，使用equals()。如果用==，是在判断两个对象身份标识ID是否相等（即是否指向内存里的同一段空间）",
      "三、不可变类型的等价性",
      "在Object中实现的缺省equals()是在判断引用等价性，实现如下",
      "重写与重载",
      "在方法签名中犯一个错误很容易，并且当您打算覆盖它时重载一个方法。",
      "只要你的意图是在你的超类中重写一个方法，就应该使用Java的批注@Override。",
      "通过这个注解，Java编译器将检查超类中是否存在具有相同签名的方法，如果签名中出现错误，则会给出编译器错误。",
      "相等应该满足等价关系（自反、对称、传递）。",
      "相等和哈希必须互相一致，以便让使用哈希表的数据结构（例如",
      "HashSet",
      "HashMap",
      "）正常工作。",
      "抽象函数是不可变类型相等的比较基础。",
      "索引是可变类型相等的比较基础。这也是确保相等一致性和保护哈希表不变量的唯一方法。"
    ],
    "sentences": [
      "一、相等（Equality）",
      "二、==与equals()",
      "1.==",
      "2.equals",
      "3.总结",
      "三、不可变类型的等价性",
      "一、相等（Equality）",
      "我们可以从三个角度来看待ADT中的相等：1.从ADT中的抽象函数AF（abstract function）：如果AF(a)=AF(b)",
      "我们就说a和b相等",
      "2.从关系的角度",
      "等价关系是指对于关系E ⊆ T x T ",
      "它满足：自反性: E(t,t) ∀ t ∈ T",
      "对称性: E(t,u) ⇒ E(u,t)",
      "传递性: E(t,u) ∧ E(u,v) ⇒ E(t,v)",
      "3.从外部观察者角度：对两个对象调用任何相同的操作",
      "都会得到相同的结果",
      "则认为这两个对象是等价的",
      "二、==与equals()",
      "Java有两种判断相等的操作：==和equals",
      "1.==",
      "==比较的是引用，也就是说，测试的是",
      "引用等价性",
      "如果两个索引指向同一块存储区域，那它们就是==的",
      "2.equals",
      "equals()操作比较对象内容，也就是测试的是",
      "对象等价性",
      "在自定义ADT时，需要重写Object的equals()",
      "3.总结",
      "使用：对基本数据类型，使用==判定相等",
      "对对象类型，使用equals()",
      "如果用==",
      "是在判断两个对象身份标识ID是否相等（即是否指向内存里的同一段空间）",
      "三、不可变类型的等价性",
      "在Object中实现的缺省equals()是在判断引用等价性",
      "实现如下",
      "重写与重载",
      "在方法签名中犯一个错误很容易",
      "并且当您打算覆盖它时重载一个方法",
      "只要你的意图是在你的超类中重写一个方法",
      "就应该使用Java的批注@Override",
      "通过这个注解",
      "Java编译器将检查超类中是否存在具有相同签名的方法",
      "如果签名中出现错误",
      "则会给出编译器错误",
      "相等应该满足等价关系（自反、对称、传递）",
      "相等和哈希必须互相一致，以便让使用哈希表的数据结构（例如",
      "HashSet",
      "HashMap",
      "）正常工作",
      "抽象函数是不可变类型相等的比较基础",
      "索引是可变类型相等的比较基础",
      "这也是确保相等一致性和保护哈希表不变量的唯一方法"
    ],
    "codes": [
      "public class Object {\n    ...\n    public boolean equals(Object that) {\n        return this == that;\n    }\n}"
    ],
    "date": "2021-07-06",
    "text": "一、相等（Equality）\n二、==与equals()\n1.==\n2.equals\n3.总结\n三、不可变类型的等价性\n一、相等（Equality）\n我们可以从三个角度来看待ADT中的相等：\n1.从ADT中的抽象函数AF（abstract function）：如果AF(a)=AF(b)，我们就说a和b相等。\n2.从关系的角度\n等价关系是指对于关系E ⊆ T x T ，它满足：\n自反性: E(t,t) ∀ t ∈ T\n对称性: E(t,u) ⇒ E(u,t)\n传递性: E(t,u) ∧ E(u,v) ⇒ E(t,v)\n3.从外部观察者角度：对两个对象调用任何相同的操作，都会得到相同的结果，则认为这两个对象是等价的。\n二、==与equals()\nJava有两种判断相等的操作：==和equals\n1.==\n==比较的是引用，也就是说，测试的是\n引用等价性\n。如果两个索引指向同一块存储区域，那它们就是==的。\n2.equals\nequals()操作比较对象内容，也就是测试的是\n对象等价性\n在自定义ADT时，需要重写Object的equals()\n3.总结\n使用：\n对基本数据类型，使用==判定相等\n对对象类型，使用equals()。如果用==，是在判断两个对象身份标识ID是否相等（即是否指向内存里的同一段空间）\n三、不可变类型的等价性\n在Object中实现的缺省equals()是在判断引用等价性，实现如下\n重写与重载\n在方法签名中犯一个错误很容易，并且当您打算覆盖它时重载一个方法。\n只要你的意图是在你的超类中重写一个方法，就应该使用Java的批注@Override。\n通过这个注解，Java编译器将检查超类中是否存在具有相同签名的方法，如果签名中出现错误，则会给出编译器错误。\n相等应该满足等价关系（自反、对称、传递）。\n相等和哈希必须互相一致，以便让使用哈希表的数据结构（例如\nHashSet\nHashMap\n）正常工作。\n抽象函数是不可变类型相等的比较基础。\n索引是可变类型相等的比较基础。这也是确保相等一致性和保护哈希表不变量的唯一方法。\n"
  },
  {
    "head": "软件构造学习4（以ArrayList和LinkedList为例理解表示独立性 rep independence)",
    "paragraphs": [
      "一、什么是表示独立性（Representation Independence）",
      "二、以List为例",
      "1.ArrayList",
      "2.LinkedList",
      "3.总结",
      "三、表示独立性的重要性",
      "一、什么是表示独立性（Representation Independence）",
      "表示独立性",
      "：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端（除非ADT的操作指明了具体的pre-和post-condition，否则不能改变ADT的内部表示）",
      "二、以List为例",
      "List接口继承collection接口，添加了插入、删除、查找等方法。其实现有两种，但 List 提供的操作表现的内容与其用LinkedList还是Array无关",
      "1.ArrayList",
      "内部表示如下，可以看到使用了数组实现",
      "当增加元素到列表结尾时，实现如下",
      "可以看到如果ArrayList容量满足需求时，add()其实就是直接对数组进行赋值，因此性能很高。",
      "2.LinkedList",
      "内部表示如下，使用了双向链表数据结构",
      "当增加元素到列表结尾时，实现如下",
      "LinkedList由于使用了链表结构，每次元素的增加都需要新建一个node对象，并进行插入操作，很多情况下会对性能会有所影响。",
      "3.总结",
      "可以看到，不同的内部表示会影响方法的性能，但是client使用List时无需考虑其内部如何实现，使用时都是通过list.add(),list.remove()等进行操作，与其用LinkedList还是Array无关。",
      "三、表示独立性的重要性",
      "下面的代码是一个破坏了表示独立性的例子",
      "在Family类中使用的内部表示是List<Person> ， 当客户端使用下面的方式访问家庭成员时，就破坏了表示独立性",
      "当Family中修改代码，将内部表示改变为Set<Person>后，",
      "客户端的代码就不能适应变化。但是根据表示独立性，ADT内部表示的变化不应影响外部spec和客户端，因此正确的实现应该如下"
    ],
    "sentences": [
      "一、什么是表示独立性（Representation Independence）",
      "二、以List为例",
      "1.ArrayList",
      "2.LinkedList",
      "3.总结",
      "三、表示独立性的重要性",
      "一、什么是表示独立性（Representation Independence）",
      "表示独立性",
      "：client使用ADT时无需考虑其内部如何实现",
      "ADT内部表示的变化不应影响外部spec和客户端（除非ADT的操作指明了具体的pre-和post-condition",
      "否则不能改变ADT的内部表示）",
      "二、以List为例",
      "List接口继承collection接口",
      "添加了插入、删除、查找等方法",
      "其实现有两种",
      "但 List 提供的操作表现的内容与其用LinkedList还是Array无关",
      "1.ArrayList",
      "内部表示如下，可以看到使用了数组实现",
      "当增加元素到列表结尾时，实现如下",
      "可以看到如果ArrayList容量满足需求时",
      "add()其实就是直接对数组进行赋值",
      "因此性能很高",
      "2.LinkedList",
      "内部表示如下，使用了双向链表数据结构",
      "当增加元素到列表结尾时，实现如下",
      "LinkedList由于使用了链表结构",
      "每次元素的增加都需要新建一个node对象",
      "并进行插入操作",
      "很多情况下会对性能会有所影响",
      "3.总结",
      "可以看到",
      "不同的内部表示会影响方法的性能",
      "但是client使用List时无需考虑其内部如何实现",
      "使用时都是通过list.add(),list.remove()等进行操作",
      "与其用LinkedList还是Array无关",
      "三、表示独立性的重要性",
      "下面的代码是一个破坏了表示独立性的例子",
      "在Family类中使用的内部表示是List<Person> ",
      " 当客户端使用下面的方式访问家庭成员时",
      "就破坏了表示独立性",
      "当Family中修改代码",
      "将内部表示改变为Set<Person>后",
      "客户端的代码就不能适应变化",
      "但是根据表示独立性",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "因此正确的实现应该如下"
    ],
    "codes": [
      "  \n    E get(int index);\n \n  \n    E set(int index, E element);\n \n  \n    void add(int index, E element);\n \n   \n    E remove(int index);\n \n \n    int indexOf(Object o);\n \n   \n    int lastIndexOf(Object o);\n \n \n    ListIterator<E> listIterator();\n \n    ListIterator<E> listIterator(int index);\n \n  \n    List<E> subList(int fromIndex, int toIndex);",
      "private transient Object[] elementData ; //支撑数组\nprivate int size ;\n   ",
      " public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // 确保内部数组有足够的空间\n        elementData[size++] = e; //将元素加入到数组的末尾\n        return true;\n }",
      "private transient Entry<E> header = new Entry<E>(null, null, null);\nprivate transient int size = 0;",
      "\n    void linkLast(E e) {\n        final Node<E> l = last;\n\n        //构建一个新节点newNode\n        final Node<E> newNode = new Node<>(l, e, null);\n\n        //将newNode作为尾节点\n        last = newNode;\n      \n        if (l == null)\n            first = newNode; \n        else  \n            l.next = newNode;\n        size++;\n        modCount++;\n    }",
      "/**\n * Represents a family that lives in a household together.\n * A family always has at least one person in it.\n * Families are mutable.\n */\nclass Family {\n    public List<Person> people;\n    public List<Person> getMembers() {\n        return people;\n    }\n}",
      "void client1(Family f) {\n    Person baby = f.people.get(f.people.size()-1);\n     ... \n    }\n}",
      "class Family {\n    Set<Person> p;\n    List<Person> getMembers() {\n        return new ArrayList<>(p);\n    }\n}\n",
      "void client2(Family f) {\n    Person anybody = f.getMember().get(0);\n     ... \n    }\n}"
    ],
    "date": "2021-07-06",
    "text": "一、什么是表示独立性（Representation Independence）\n二、以List为例\n1.ArrayList\n2.LinkedList\n3.总结\n三、表示独立性的重要性\n一、什么是表示独立性（Representation Independence）\n表示独立性\n：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端（除非ADT的操作指明了具体的pre-和post-condition，否则不能改变ADT的内部表示）\n二、以List为例\nList接口继承collection接口，添加了插入、删除、查找等方法。其实现有两种，但 List 提供的操作表现的内容与其用LinkedList还是Array无关\n1.ArrayList\n内部表示如下，可以看到使用了数组实现\n当增加元素到列表结尾时，实现如下\n可以看到如果ArrayList容量满足需求时，add()其实就是直接对数组进行赋值，因此性能很高。\n2.LinkedList\n内部表示如下，使用了双向链表数据结构\n当增加元素到列表结尾时，实现如下\nLinkedList由于使用了链表结构，每次元素的增加都需要新建一个node对象，并进行插入操作，很多情况下会对性能会有所影响。\n3.总结\n可以看到，不同的内部表示会影响方法的性能，但是client使用List时无需考虑其内部如何实现，使用时都是通过list.add(),list.remove()等进行操作，与其用LinkedList还是Array无关。\n三、表示独立性的重要性\n下面的代码是一个破坏了表示独立性的例子\n在Family类中使用的内部表示是List<Person> ， 当客户端使用下面的方式访问家庭成员时，就破坏了表示独立性\n当Family中修改代码，将内部表示改变为Set<Person>后，\n客户端的代码就不能适应变化。但是根据表示独立性，ADT内部表示的变化不应影响外部spec和客户端，因此正确的实现应该如下\n"
  },
  {
    "head": "软件构造学习笔记2（Delegation 委派）",
    "paragraphs": [
      "软件构造学习笔记",
      "一、什么是Delegation（委派）",
      "二、不同类型的委派",
      "1.Dependency: 临时性的delegation",
      "2.Association: 永久性的delegation",
      "3.Composition: 更强的association，但难以变化",
      "4.Aggregation: 更弱的association，可动态变化",
      "三、总结",
      "1.委派过程",
      "2.委派与继承",
      "学习委派机制（Delegation）时遇到一些困惑，因此查阅相关资料，结合课件和课堂笔记整理一下知识点。以下内容是个人理解，如果有不正确的地方欢迎大家指出。",
      "一、什么是Delegation（委派）",
      "委派：一个对象请求另一个对象的功能，于是捕获操作并发送给另一对象，进行功能调用。是复用的一种常见形式。",
      "与继承（Inheritance）的区别：“委托”发生在object层面，运行时建立联系，而“继承”发生在class层面",
      "二、不同类型的委派",
      "1.Dependency: 临时性的delegation",
      "两个类之间的这种暂时性的关系叫做“use-a\"关系。",
      "以下面的代码为例，Duck d想要请求FlyWithWings f的功能，实现fly方法，在临时性的委派关系中，不需要将委托对象f存储为Duck类中的字段，只需在d.fly(f)中动态传入f，并在fly方法中通过f.fly()完成实际调用。",
      "2.Association: 永久性的delegation",
      "这是类之间的永久关系，属于has-a的关系。这种关系允许一个对象实例a让另一个对象实例b为它自己做事。",
      "这种关系是结构化的，它指定了一种对象与另一种对象相关联，不指定行为。可以将下面的Composition/Aggregation看作是Association的两种具体形态。",
      "3.Composition: 更强的association，但难以变化",
      "这种关系是”a-part-of “关系，一个类将另一个类作为属性或实例变量",
      "这种关系中，若对象d销毁了，则委派对象f也没有了存在的意义",
      "4.Aggregation: 更弱的association，可动态变化",
      "这种关系是“has-a”的关系",
      "以下面的代码为例，将另一个外部对象f ，以参数形式传递给Duck类中的构造方法或其他特定方法（如本例中的setBehavior方法）",
      "这种类型与Composition的不同在于：",
      "1.委托的对象可以动态变化，例如运行下面这段代码",
      "输出结果为",
      "2.对象d销毁后，对象f和f2依然可以独立存在",
      "三、总结",
      "1.委派过程",
      "通过以上分析，委派过程可以大致总结为以下三步：",
      "1.建立委派",
      "2.动态传入",
      "3.实际调用",
      "2.委派与继承",
      "“委托”发生在object层面，而“继承”发生在class层面。如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，从而避免大量无用的方法。",
      "例如在上述开发场景中，fly的具体实现可以有很多种（如FlyWithWings,CanNotFly)，且Duck中的fly方式也有可能发生变化，因此设计时如果设计成Duck extends FlyableAnimal将会造成很多不便，而使用委派机制更加合适，更加灵活。"
    ],
    "sentences": [
      "软件构造学习笔记",
      "一、什么是Delegation（委派）",
      "二、不同类型的委派",
      "1.Dependency: 临时性的delegation",
      "2.Association: 永久性的delegation",
      "3.Composition: 更强的association",
      "但难以变化",
      "4.Aggregation: 更弱的association",
      "可动态变化",
      "三、总结",
      "1.委派过程",
      "2.委派与继承",
      "学习委派机制（Delegation）时遇到一些困惑",
      "因此查阅相关资料",
      "结合课件和课堂笔记整理一下知识点",
      "以下内容是个人理解，如果有不正确的地方欢迎大家指出",
      "一、什么是Delegation（委派）",
      "委派：一个对象请求另一个对象的功能",
      "于是捕获操作并发送给另一对象",
      "进行功能调用",
      "是复用的一种常见形式",
      "与继承（Inheritance）的区别：“委托”发生在object层面",
      "运行时建立联系",
      "而“继承”发生在class层面",
      "二、不同类型的委派",
      "1.Dependency: 临时性的delegation",
      "两个类之间的这种暂时性的关系叫做“use-a\"关系",
      "以下面的代码为例",
      "Duck d想要请求FlyWithWings f的功能",
      "实现fly方法",
      "在临时性的委派关系中",
      "不需要将委托对象f存储为Duck类中的字段",
      "只需在d.fly(f)中动态传入f",
      "并在fly方法中通过f.fly()完成实际调用",
      "2.Association: 永久性的delegation",
      "这是类之间的永久关系，属于has-a的关系",
      "这种关系允许一个对象实例a让另一个对象实例b为它自己做事",
      "这种关系是结构化的",
      "它指定了一种对象与另一种对象相关联",
      "不指定行为",
      "可以将下面的Composition/Aggregation看作是Association的两种具体形态",
      "3.Composition: 更强的association",
      "但难以变化",
      "这种关系是”a-part-of “关系",
      "一个类将另一个类作为属性或实例变量",
      "这种关系中，若对象d销毁了，则委派对象f也没有了存在的意义",
      "4.Aggregation: 更弱的association",
      "可动态变化",
      "这种关系是“has-a”的关系",
      "以下面的代码为例",
      "将另一个外部对象f ",
      "以参数形式传递给Duck类中的构造方法或其他特定方法（如本例中的setBehavior方法）",
      "这种类型与Composition的不同在于：1.委托的对象可以动态变化",
      "例如运行下面这段代码",
      "输出结果为",
      "2.对象d销毁后，对象f和f2依然可以独立存在",
      "三、总结",
      "1.委派过程",
      "通过以上分析，委派过程可以大致总结为以下三步：1.建立委派",
      "2.动态传入",
      "3.实际调用",
      "2.委派与继承",
      "“委托”发生在object层面",
      "而“继承”发生在class层面",
      "如果子类只需要复用父类中的一小部分方法",
      "可以不需要使用继承",
      "而是通过委派机制来实现",
      "从而避免大量无用的方法",
      "例如在上述开发场景中",
      "fly的具体实现可以有很多种（如FlyWithWings,CanNotFly)",
      "且Duck中的fly方式也有可能发生变化",
      "因此设计时如果设计成Duck extends FlyableAnimal将会造成很多不便",
      "而使用委派机制更加合适",
      "更加灵活"
    ],
    "codes": [
      "public class FlyWithWings implements Flyable {\n\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\"Wings\");\n\t}\n\n}",
      "class Duck {\n//不需要将委托的类存储为Duck类中的字段\n  void fly(Flyable f) {\n    f.fly();\n  }\n}\n\n",
      "Flyable f = new FlyWithWings();\nDuck d = new Duck();\nd.fly(f);//将f动态传入d中\n\n",
      "class Duck {\n\t\n\tFlyWithWings f;  \n   \n    //...\n}",
      "class FlyWithWings implements Flyable { \n  @Override\n  public void fly() {\n    System.out.println(\"fly with wings\");\n  }\n}\n\nclass Duck {\n  Flyable f = new FlyWithWings();//一个类把另一个类作为自己的属性或实例变量\n  void fly() {\n    f.fly();\n  }\n}\nDuck d = new Duck();\nd.fly();\n",
      "public class CannotFly implements Flyable{\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\"Can not fly\");\n\t}\n\n}\n",
      "class Duck {\n\t\n\tFlyable f;\n\t\n\tDuck(Flyable f) {\n\t\tthis.f = f;\n\t}\n\t\n\tvoid setFlyBehavior(Flyable f) {\n\t\tthis.f = f;\n\t}\n\t\n\tvoid fly() {\n\t\tf.fly();\n\t}\n\t\n}\n\n",
      "Flyable f = new FlyWithWings();\nDuck d = new Duck(f);//将另一个外部对象f ，以参数形式传递给Duck类的构造方法\nd.fly();\n\t\t\nFlyable f2 = new CannotFly();\nd.setFlyBehavior(f2);//委托的对象可以动态改变\nd.fly();",
      "class Duck {\n\t\n\t//Flyable f;   //可以将委托对象f存储在rep中，也可以不存储\n   \n    void fly() {   //运行时建立关系\n        f.fly();\n    }\n}\n\t\n\t",
      "Duck d = new Duck(f);//将另一个外部对象f ，以参数形式传递给Duck类的构造方法\n\nd.setFlyBehavior(f);//或传入其他特定方法\n",
      "d.fly();",
      "Use(A use B)",
      "Association(A has B)",
      "Composition/aggregation(A owns B)"
    ],
    "date": "2021-06-17",
    "text": "软件构造学习笔记\n一、什么是Delegation（委派）\n二、不同类型的委派\n1.Dependency: 临时性的delegation\n2.Association: 永久性的delegation\n3.Composition: 更强的association，但难以变化\n4.Aggregation: 更弱的association，可动态变化\n三、总结\n1.委派过程\n2.委派与继承\n学习委派机制（Delegation）时遇到一些困惑，因此查阅相关资料，结合课件和课堂笔记整理一下知识点。以下内容是个人理解，如果有不正确的地方欢迎大家指出。\n一、什么是Delegation（委派）\n委派：一个对象请求另一个对象的功能，于是捕获操作并发送给另一对象，进行功能调用。是复用的一种常见形式。\n与继承（Inheritance）的区别：“委托”发生在object层面，运行时建立联系，而“继承”发生在class层面\n二、不同类型的委派\n1.Dependency: 临时性的delegation\n两个类之间的这种暂时性的关系叫做“use-a\"关系。\n以下面的代码为例，Duck d想要请求FlyWithWings f的功能，实现fly方法，在临时性的委派关系中，不需要将委托对象f存储为Duck类中的字段，只需在d.fly(f)中动态传入f，并在fly方法中通过f.fly()完成实际调用。\n2.Association: 永久性的delegation\n这是类之间的永久关系，属于has-a的关系。这种关系允许一个对象实例a让另一个对象实例b为它自己做事。\n这种关系是结构化的，它指定了一种对象与另一种对象相关联，不指定行为。可以将下面的Composition/Aggregation看作是Association的两种具体形态。\n3.Composition: 更强的association，但难以变化\n这种关系是”a-part-of “关系，一个类将另一个类作为属性或实例变量\n这种关系中，若对象d销毁了，则委派对象f也没有了存在的意义\n4.Aggregation: 更弱的association，可动态变化\n这种关系是“has-a”的关系\n以下面的代码为例，将另一个外部对象f ，以参数形式传递给Duck类中的构造方法或其他特定方法（如本例中的setBehavior方法）\n这种类型与Composition的不同在于：\n1.委托的对象可以动态变化，例如运行下面这段代码\n输出结果为\n2.对象d销毁后，对象f和f2依然可以独立存在\n三、总结\n1.委派过程\n通过以上分析，委派过程可以大致总结为以下三步：\n1.建立委派\n2.动态传入\n3.实际调用\n2.委派与继承\n“委托”发生在object层面，而“继承”发生在class层面。如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，从而避免大量无用的方法。\n例如在上述开发场景中，fly的具体实现可以有很多种（如FlyWithWings,CanNotFly)，且Duck中的fly方式也有可能发生变化，因此设计时如果设计成Duck extends FlyableAnimal将会造成很多不便，而使用委派机制更加合适，更加灵活。\n"
  },
  {
    "head": "软件构造——关于mutable与immutable",
    "paragraphs": [
      "1.immutable与mutable类的定义",
      "mutable类：",
      "定义比较简单，创建之后，该对象拥有可以更改其值/引用的方法",
      "immutable类：",
      "immutable类是指这个类的实例一旦创建完成后，就不能改变其成员变量值，也就是不能改变对象的状态。首先，类需要声明为final，保证其不可以被继承,所有成员变量定义为private final,不提供改变成员变量的Mutators方法 ，通过构造器初始化成员变量，如果构造器传入了引用数据类型需要进行防御式拷贝。",
      "2.Java中常见的mutable和immutable类",
      "常见的immutable类",
      "String：",
      "一个String总是表示一个相同的字符串。由于String是immutable的，一旦创建，一个String类总是含有相同的值。想要改变值，java会创建一个新的String类。",
      "基本类型及其封装对象类型：",
      "基本类型：byte、short、int、long、float、double、char、boolean与封装类：Byte, Short, Integer, Long, Float, Double,Character, Boolean,",
      "Scanner",
      "常见的扫描器",
      "Iterator",
      "迭代器转换为",
      "Scala",
      "迭代器",
      "Collections.unmodifiableList/Map/Set()",
      "方法处理后的集合",
      "常见的mutable类",
      "StringBuilder：",
      "StringBuilder是mutable类型的一个例子。它有删除部分字符串，插入或替换字符等方法。这个类有改变对象值的方法，而不仅仅是返回新值。",
      "StringBuffer",
      "常见的",
      "Map",
      "HashMap",
      "Java 中的常见的大多数迭代器",
      "Iterator",
      "3.mutable与immutable的优劣",
      "使用immutable，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)。",
      "mutable最少化拷贝以提高效率。因此，使用可变数据类型，可获得更好的性能。也适合于在多个模块之间共享数据。",
      "4.mutable与immutable的差异例子",
      "5.使用final",
      "可以这么理解：在java中引用变量的组成分为两部分：",
      "引用哪个对象",
      "那个对象的值",
      "immutable就是",
      "那个对象的值",
      "不会改变，但",
      "引用哪个对象",
      "会改变。",
      "mutable就是两者都能改变。",
      "而如果在一个引用变量前使用final修饰，则会导致",
      "引用哪个对象",
      "不会发生改变。",
      "在snap diagram中，表现为指针变成双线。"
    ],
    "sentences": [
      "1.immutable与mutable类的定义",
      "mutable类：定义比较简单",
      "创建之后",
      "该对象拥有可以更改其值/引用的方法",
      "immutable类：immutable类是指这个类的实例一旦创建完成后",
      "就不能改变其成员变量值",
      "也就是不能改变对象的状态",
      "首先",
      "类需要声明为final",
      "保证其不可以被继承,所有成员变量定义为private final,不提供改变成员变量的Mutators方法 ",
      "通过构造器初始化成员变量",
      "如果构造器传入了引用数据类型需要进行防御式拷贝",
      "2.Java中常见的mutable和immutable类",
      "常见的immutable类",
      "String：一个String总是表示一个相同的字符串",
      "由于String是immutable的",
      "一旦创建",
      "一个String类总是含有相同的值",
      "想要改变值，java会创建一个新的String类",
      "基本类型及其封装对象类型：基本类型：byte、short、int、long、float、double、char、boolean与封装类：Byte, Short, Integer, Long, Float, Double,Character, Boolean,Scanner",
      "常见的扫描器",
      "Iterator",
      "迭代器转换为",
      "Scala",
      "迭代器",
      "Collections.unmodifiableList/Map/Set()",
      "方法处理后的集合",
      "常见的mutable类",
      "StringBuilder：StringBuilder是mutable类型的一个例子",
      "它有删除部分字符串，插入或替换字符等方法",
      "这个类有改变对象值的方法，而不仅仅是返回新值",
      "StringBuffer",
      "常见的",
      "Map",
      "HashMap",
      "Java 中的常见的大多数迭代器",
      "Iterator",
      "3.mutable与immutable的优劣",
      "使用immutable",
      "对其频繁修改会产生大量的临时拷贝(需要垃圾回收)",
      "mutable最少化拷贝以提高效率",
      "因此，使用可变数据类型，可获得更好的性能",
      "也适合于在多个模块之间共享数据",
      "4.mutable与immutable的差异例子",
      "5.使用final",
      "可以这么理解：在java中引用变量的组成分为两部分：引用哪个对象",
      "那个对象的值",
      "immutable就是",
      "那个对象的值",
      "不会改变，但",
      "引用哪个对象",
      "会改变",
      "mutable就是两者都能改变",
      "而如果在一个引用变量前使用final修饰，则会导致",
      "引用哪个对象",
      "不会发生改变",
      "在snap diagram中，表现为指针变成双线"
    ],
    "codes": [],
    "date": "2021-07-01",
    "text": "1.immutable与mutable类的定义\nmutable类：\n定义比较简单，创建之后，该对象拥有可以更改其值/引用的方法\nimmutable类：\nimmutable类是指这个类的实例一旦创建完成后，就不能改变其成员变量值，也就是不能改变对象的状态。首先，类需要声明为final，保证其不可以被继承,所有成员变量定义为private final,不提供改变成员变量的Mutators方法 ，通过构造器初始化成员变量，如果构造器传入了引用数据类型需要进行防御式拷贝。\n2.Java中常见的mutable和immutable类\n常见的immutable类\nString：\n一个String总是表示一个相同的字符串。由于String是immutable的，一旦创建，一个String类总是含有相同的值。想要改变值，java会创建一个新的String类。\n基本类型及其封装对象类型：\n基本类型：byte、short、int、long、float、double、char、boolean与封装类：Byte, Short, Integer, Long, Float, Double,Character, Boolean,\nScanner\n常见的扫描器\nIterator\n迭代器转换为\nScala\n迭代器\nCollections.unmodifiableList/Map/Set()\n方法处理后的集合\n常见的mutable类\nStringBuilder：\nStringBuilder是mutable类型的一个例子。它有删除部分字符串，插入或替换字符等方法。这个类有改变对象值的方法，而不仅仅是返回新值。\nStringBuffer\n常见的\nMap\nHashMap\nJava 中的常见的大多数迭代器\nIterator\n3.mutable与immutable的优劣\n使用immutable，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)。\nmutable最少化拷贝以提高效率。因此，使用可变数据类型，可获得更好的性能。也适合于在多个模块之间共享数据。\n4.mutable与immutable的差异例子\n5.使用final\n可以这么理解：在java中引用变量的组成分为两部分：\n引用哪个对象\n那个对象的值\nimmutable就是\n那个对象的值\n不会改变，但\n引用哪个对象\n会改变。\nmutable就是两者都能改变。\n而如果在一个引用变量前使用final修饰，则会导致\n引用哪个对象\n不会发生改变。\n在snap diagram中，表现为指针变成双线。\n"
  },
  {
    "head": "软件构造——关于设计模式",
    "paragraphs": [
      "1.设计模式",
      "在软件构造的学习中，我们学习了几种设计模式，这里做出一个汇总和分类。",
      "创建型模式",
      "结构型模式",
      "行为类模式",
      "2.创建型模式",
      "(1).工厂方法模式",
      "当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。",
      "定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。",
      "3.结构型模式",
      "(1).适配器模式",
      "将某个类/接口转换为client期望的其他形式。",
      "通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。",
      "(2).装饰器模式",
      "装饰者模式用每个子类实现不同的特性，在我们需要大量有重复属性但是同时又有特定属性的时候，使用单纯地继承委托等方法可能会造成组合爆炸、大量代码重复等等问题。而装饰器模式能很好地解决这个问题。",
      "其问题是为对象增加不同侧面的特性，解决方式是对每一个特性构造子类，通过委派机制增加到对象上，其工作原理是以递归的方式实现，接口：定义装饰物执行的公共操作，起始对象，在其基础上增加功能(装饰)，将通用的方法放到此对象中。Decorator抽象类是所有装饰类的基类，里面包含的成员变量component指向了被装饰的对象。",
      "3.行为类模式",
      "(1).策略模式",
      "有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。",
      "为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。",
      "(2).模板模式",
      "有些问题做事情的步骤一样，但具体方法不同。",
      "共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。",
      "(3).迭代器模式",
      "客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型。",
      "也就是说，不管对象被放进哪里，都应该提供同样的遍历方式。",
      "Iterator pattern：让自己的集合类实现Iterable接口，并实现自己的独特Iterator迭代器(hasNext, next, remove)，允许客户端利用这个迭代器进行显式或隐式的迭代遍历。",
      "(4).访问者模式",
      "对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。",
      "本质上：将数据和作用于数据上的某种/些特定操作分离开来。",
      "为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT。"
    ],
    "sentences": [
      "1.设计模式",
      "在软件构造的学习中",
      "我们学习了几种设计模式",
      "这里做出一个汇总和分类",
      "创建型模式",
      "结构型模式",
      "行为类模式",
      "2.创建型模式",
      "(1).工厂方法模式",
      "当client不知道要创建哪个具体类的实例",
      "或者不想在client代码中指明要具体创建的实例时",
      "用工厂方法",
      "定义一个用于创建对象的接口",
      "让其子类来决定实例化哪一个类",
      "从而使一个类的实例化延迟到其子类",
      "3.结构型模式",
      "(1).适配器模式",
      "将某个类/接口转换为client期望的其他形式",
      "通过增加一个接口",
      "将已存在的子类封装起来",
      "client面向接口编程",
      "从而隐藏了具体子类",
      "(2).装饰器模式",
      "装饰者模式用每个子类实现不同的特性",
      "在我们需要大量有重复属性但是同时又有特定属性的时候",
      "使用单纯地继承委托等方法可能会造成组合爆炸、大量代码重复等等问题",
      "而装饰器模式能很好地解决这个问题",
      "其问题是为对象增加不同侧面的特性",
      "解决方式是对每一个特性构造子类",
      "通过委派机制增加到对象上",
      "其工作原理是以递归的方式实现",
      "接口：定义装饰物执行的公共操作",
      "起始对象",
      "在其基础上增加功能(装饰)",
      "将通用的方法放到此对象中",
      "Decorator抽象类是所有装饰类的基类",
      "里面包含的成员变量component指向了被装饰的对象",
      "3.行为类模式",
      "(1).策略模式",
      "有多种不同的算法来实现同一个任务",
      "但需要client根据需要动态切换算法",
      "而不是写死在代码里",
      "为不同的实现算法构造抽象接口",
      "利用delegation",
      "运行时动态传入client倾向的算法类实例",
      "(2).模板模式",
      "有些问题做事情的步骤一样，但具体方法不同",
      "共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现",
      "使用继承和重写实现模板模式",
      "(3).迭代器模式",
      "客户端希望遍历被放入容器/集合类的一组ADT对象",
      "无需关心容器的具体类型",
      "也就是说，不管对象被放进哪里，都应该提供同样的遍历方式",
      "Iterator pattern：让自己的集合类实现Iterable接口",
      "并实现自己的独特Iterator迭代器(hasNext, next, remove)",
      "允许客户端利用这个迭代器进行显式或隐式的迭代遍历",
      "(4).访问者模式",
      "对特定类型的object的特定操作(visit)",
      "在运行时将二者动态绑定到一起",
      "该操作可以灵活更改",
      "无需更改被visit的类",
      "本质上：将数据和作用于数据上的某种/些特定操作分离开来",
      "为ADT预留一个将来可扩展功能的“接入点”",
      "外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT"
    ],
    "codes": [],
    "date": "2021-07-04",
    "text": "1.设计模式\n在软件构造的学习中，我们学习了几种设计模式，这里做出一个汇总和分类。\n创建型模式\n结构型模式\n行为类模式\n2.创建型模式\n(1).工厂方法模式\n当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。\n定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。\n3.结构型模式\n(1).适配器模式\n将某个类/接口转换为client期望的其他形式。\n通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。\n(2).装饰器模式\n装饰者模式用每个子类实现不同的特性，在我们需要大量有重复属性但是同时又有特定属性的时候，使用单纯地继承委托等方法可能会造成组合爆炸、大量代码重复等等问题。而装饰器模式能很好地解决这个问题。\n其问题是为对象增加不同侧面的特性，解决方式是对每一个特性构造子类，通过委派机制增加到对象上，其工作原理是以递归的方式实现，接口：定义装饰物执行的公共操作，起始对象，在其基础上增加功能(装饰)，将通用的方法放到此对象中。Decorator抽象类是所有装饰类的基类，里面包含的成员变量component指向了被装饰的对象。\n3.行为类模式\n(1).策略模式\n有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。\n为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。\n(2).模板模式\n有些问题做事情的步骤一样，但具体方法不同。\n共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。\n(3).迭代器模式\n客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型。\n也就是说，不管对象被放进哪里，都应该提供同样的遍历方式。\nIterator pattern：让自己的集合类实现Iterable接口，并实现自己的独特Iterator迭代器(hasNext, next, remove)，允许客户端利用这个迭代器进行显式或隐式的迭代遍历。\n(4).访问者模式\n对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。\n本质上：将数据和作用于数据上的某种/些特定操作分离开来。\n为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT。\n"
  },
  {
    "head": "软件构造——关于RI与AF",
    "paragraphs": [
      "1.基本概念",
      "以PPT为依据整理一下主要概念：",
      "表示独立性（Representation independent）",
      "：client使用ADT时无需考虑其内部如何实现，ADT内部的变化不应影响外部spec和客户端。",
      "不变量（Invariant）",
      "：程序的一个属性，对于程序的每一个可能的运行时状态，它总是为真。例如：immutability就是一个典型的“不变量”。",
      "表示域（R）",
      "：包含的是值具体的实现实体的空间。一般情况下ADT的表示比较简单，有些时候需要复杂表示。",
      "抽象域（A）",
      "：包含的是类型设计时支持使用的值的空间。这些值是由表示域“抽象/想象”出来的，也是使用者关注的。",
      "抽象函数（Abstraction function）",
      "：R和A之间映射关系的函数。AF：R→A",
      "表示不变量（Rep invariant）",
      "：将表示空间的值映射到布尔值。RI : R → boolean",
      "Safety from Rep Exposure",
      "：防止表示泄露的方法",
      "2.实际运用",
      "在代码编写中，我们一般会在一个Class开头写下注释，内容包含：AF，RI和Safety from Rep Exposure。",
      "以下面的代码为例：",
      "可以看到，在开头的注释里就包含了这三部分。",
      "其中，AF就是说明将一个抽象的东西，表示成程序可以表示的东西。在这里，我们将一张图G表示为G中所有的点v的集合。",
      "RI就是对所有表示值的一个子集，包含了所有合法的表示值 。也可以看做：一个条件，描述了什么是“合法”的表示值。在这里，我们对所有点v做出了要求。",
      "Safety from Rep Exposure就是对安全性的策略。在这里，我们保证所有field都是private，每个method返回的都是变量的赋值，点的元素都是immutable的。",
      "3.保护不变量",
      "如何保护表示不变量呢，一般情况下有如下几种做法：",
      "通过私有变量来保护",
      "通过防御式拷贝防止泄露",
      "写规格说明（通常无用）",
      "使用Collections.unmodifiableList()这类方法来返回不变量"
    ],
    "sentences": [
      "1.基本概念",
      "以PPT为依据整理一下主要概念：表示独立性（Representation independent）",
      "：client使用ADT时无需考虑其内部如何实现",
      "ADT内部的变化不应影响外部spec和客户端",
      "不变量（Invariant）",
      "：程序的一个属性",
      "对于程序的每一个可能的运行时状态",
      "它总是为真",
      "例如：immutability就是一个典型的“不变量”",
      "表示域（R）",
      "：包含的是值具体的实现实体的空间",
      "一般情况下ADT的表示比较简单，有些时候需要复杂表示",
      "抽象域（A）",
      "：包含的是类型设计时支持使用的值的空间",
      "这些值是由表示域“抽象/想象”出来的，也是使用者关注的",
      "抽象函数（Abstraction function）",
      "：R和A之间映射关系的函数",
      "AF：R→A",
      "表示不变量（Rep invariant）",
      "：将表示空间的值映射到布尔值",
      "RI : R → boolean",
      "Safety from Rep Exposure",
      "：防止表示泄露的方法",
      "2.实际运用",
      "在代码编写中",
      "我们一般会在一个Class开头写下注释",
      "内容包含：AF",
      "RI和Safety from Rep Exposure",
      "以下面的代码为例：可以看到，在开头的注释里就包含了这三部分",
      "其中，AF就是说明将一个抽象的东西，表示成程序可以表示的东西",
      "在这里，我们将一张图G表示为G中所有的点v的集合",
      "RI就是对所有表示值的一个子集，包含了所有合法的表示值 ",
      "也可以看做：一个条件，描述了什么是“合法”的表示值",
      "在这里，我们对所有点v做出了要求",
      "Safety from Rep Exposure就是对安全性的策略",
      "在这里",
      "我们保证所有field都是private",
      "每个method返回的都是变量的赋值",
      "点的元素都是immutable的",
      "3.保护不变量",
      "如何保护表示不变量呢",
      "一般情况下有如下几种做法：通过私有变量来保护",
      "通过防御式拷贝防止泄露",
      "写规格说明（通常无用）",
      "使用Collections.unmodifiableList()这类方法来返回不变量"
    ],
    "codes": [],
    "date": "2021-07-02",
    "text": "1.基本概念\n以PPT为依据整理一下主要概念：\n表示独立性（Representation independent）\n：client使用ADT时无需考虑其内部如何实现，ADT内部的变化不应影响外部spec和客户端。\n不变量（Invariant）\n：程序的一个属性，对于程序的每一个可能的运行时状态，它总是为真。例如：immutability就是一个典型的“不变量”。\n表示域（R）\n：包含的是值具体的实现实体的空间。一般情况下ADT的表示比较简单，有些时候需要复杂表示。\n抽象域（A）\n：包含的是类型设计时支持使用的值的空间。这些值是由表示域“抽象/想象”出来的，也是使用者关注的。\n抽象函数（Abstraction function）\n：R和A之间映射关系的函数。AF：R→A\n表示不变量（Rep invariant）\n：将表示空间的值映射到布尔值。RI : R → boolean\nSafety from Rep Exposure\n：防止表示泄露的方法\n2.实际运用\n在代码编写中，我们一般会在一个Class开头写下注释，内容包含：AF，RI和Safety from Rep Exposure。\n以下面的代码为例：\n可以看到，在开头的注释里就包含了这三部分。\n其中，AF就是说明将一个抽象的东西，表示成程序可以表示的东西。在这里，我们将一张图G表示为G中所有的点v的集合。\nRI就是对所有表示值的一个子集，包含了所有合法的表示值 。也可以看做：一个条件，描述了什么是“合法”的表示值。在这里，我们对所有点v做出了要求。\nSafety from Rep Exposure就是对安全性的策略。在这里，我们保证所有field都是private，每个method返回的都是变量的赋值，点的元素都是immutable的。\n3.保护不变量\n如何保护表示不变量呢，一般情况下有如下几种做法：\n通过私有变量来保护\n通过防御式拷贝防止泄露\n写规格说明（通常无用）\n使用Collections.unmodifiableList()这类方法来返回不变量\n"
  },
  {
    "head": "软件构造——关于面向对象设计原则",
    "paragraphs": [
      "1.五大原则",
      "我们在学习面向可维护性的构造技术时，学习了面向对象设计的五大原则，掌握这些原则能帮助我们更好的理解面向对象的概念，也能更好的理解设计模式。",
      "2.SRP 单一责任原则",
      "不应该有多于1个原因让你的ADT发生变化，否则就拆分开。",
      "单一职责原则的优点：",
      "类的复杂性降低，实现什么职责都有明确的定义；",
      "逻辑变得简单，类的可读性提高了，而且，因为逻辑简单，代码的可维护性也提高了；",
      "变更的风险降低，因为只会在单一的类中的修改。",
      "3.OCP 开放-封闭原则",
      "分为两部分。",
      "对扩展性的开放：模块的行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化。",
      "对修改的封闭：模块自身的代码是不应被修改的，扩展模块行为的一般途径是修改模块的内部实现，如果一个模块不能被修改，那么它通常被认为是具有固定的行为。",
      "4.LSP Liskov替换原则",
      "子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异。",
      "简单概括：",
      "只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何异常",
      "。 但是反过来就不行了，因为子类可以扩展父类没有的功能，同时子类还不能改变父类原有的功能。",
      "具体来说：",
      "子类型可以增加方法，但不可删除。",
      "子类型需要实现抽象类型中的所有未实现方法。",
      "子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance的参数。",
      "子类型中重写的方法必须使用同样类型的参数或者符合contra-variance的参数。",
      "子类型中重写的方法不能抛出额外的异常。",
      "5.ISP 接口隔离原则",
      "不能强迫客户端依赖于它们不需要的接口：只提供必需的接口。",
      "意思就是客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，这就需要对接口进行细化，保证接口的纯洁性。换成另一种说法就是，类间的依赖关系应该建立在最小的接口上，也就是建立单一的接口。",
      "6.DIP 依赖转置原则",
      "抽象的模块不应依赖于具体的模块，具体应依赖于抽象。",
      "在Java语言中，抽象就是指接口或抽象类，两者都不能被实例化；而细节就是实现接口或继承抽象类产生的类，也就是可以被实例化的实现类。依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的，这就是俗称的面向接口编程。"
    ],
    "sentences": [
      "1.五大原则",
      "我们在学习面向可维护性的构造技术时",
      "学习了面向对象设计的五大原则",
      "掌握这些原则能帮助我们更好的理解面向对象的概念",
      "也能更好的理解设计模式",
      "2.SRP 单一责任原则",
      "不应该有多于1个原因让你的ADT发生变化，否则就拆分开",
      "单一职责原则的优点：类的复杂性降低",
      "实现什么职责都有明确的定义；逻辑变得简单",
      "类的可读性提高了",
      "而且",
      "因为逻辑简单",
      "代码的可维护性也提高了；变更的风险降低",
      "因为只会在单一的类中的修改",
      "3.OCP 开放-封闭原则",
      "分为两部分",
      "对扩展性的开放：模块的行为应是可扩展的",
      "从而该模块可表现出新的行为以满足需求的变化",
      "对修改的封闭：模块自身的代码是不应被修改的",
      "扩展模块行为的一般途径是修改模块的内部实现",
      "如果一个模块不能被修改",
      "那么它通常被认为是具有固定的行为",
      "4.LSP Liskov替换原则",
      "子类型必须能够替换其基类型",
      "派生类必须能够通过其基类的接口使用",
      "客户端无需了解二者之间的差异",
      "简单概括：只要父类能出现的地方子类就可以出现",
      "而且替换为子类也不会产生任何异常",
      " 但是反过来就不行了",
      "因为子类可以扩展父类没有的功能",
      "同时子类还不能改变父类原有的功能",
      "具体来说：子类型可以增加方法，但不可删除",
      "子类型需要实现抽象类型中的所有未实现方法",
      "子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance的参数",
      "子类型中重写的方法必须使用同样类型的参数或者符合contra-variance的参数",
      "子类型中重写的方法不能抛出额外的异常",
      "5.ISP 接口隔离原则",
      "不能强迫客户端依赖于它们不需要的接口：只提供必需的接口",
      "意思就是客户端需要什么接口就提供什么接口",
      "把不需要的接口剔除掉",
      "这就需要对接口进行细化",
      "保证接口的纯洁性",
      "换成另一种说法就是",
      "类间的依赖关系应该建立在最小的接口上",
      "也就是建立单一的接口",
      "6.DIP 依赖转置原则",
      "抽象的模块不应依赖于具体的模块，具体应依赖于抽象",
      "在Java语言中",
      "抽象就是指接口或抽象类",
      "两者都不能被实例化；而细节就是实现接口或继承抽象类产生的类",
      "也就是可以被实例化的实现类",
      "依赖倒置原则是指模块间的依赖是通过抽象来发生的",
      "实现类之间不发生直接的依赖关系",
      "其依赖关系是通过接口是来实现的",
      "这就是俗称的面向接口编程"
    ],
    "codes": [],
    "date": "2021-07-03",
    "text": "1.五大原则\n我们在学习面向可维护性的构造技术时，学习了面向对象设计的五大原则，掌握这些原则能帮助我们更好的理解面向对象的概念，也能更好的理解设计模式。\n2.SRP 单一责任原则\n不应该有多于1个原因让你的ADT发生变化，否则就拆分开。\n单一职责原则的优点：\n类的复杂性降低，实现什么职责都有明确的定义；\n逻辑变得简单，类的可读性提高了，而且，因为逻辑简单，代码的可维护性也提高了；\n变更的风险降低，因为只会在单一的类中的修改。\n3.OCP 开放-封闭原则\n分为两部分。\n对扩展性的开放：模块的行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化。\n对修改的封闭：模块自身的代码是不应被修改的，扩展模块行为的一般途径是修改模块的内部实现，如果一个模块不能被修改，那么它通常被认为是具有固定的行为。\n4.LSP Liskov替换原则\n子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异。\n简单概括：\n只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何异常\n。 但是反过来就不行了，因为子类可以扩展父类没有的功能，同时子类还不能改变父类原有的功能。\n具体来说：\n子类型可以增加方法，但不可删除。\n子类型需要实现抽象类型中的所有未实现方法。\n子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance的参数。\n子类型中重写的方法必须使用同样类型的参数或者符合contra-variance的参数。\n子类型中重写的方法不能抛出额外的异常。\n5.ISP 接口隔离原则\n不能强迫客户端依赖于它们不需要的接口：只提供必需的接口。\n意思就是客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，这就需要对接口进行细化，保证接口的纯洁性。换成另一种说法就是，类间的依赖关系应该建立在最小的接口上，也就是建立单一的接口。\n6.DIP 依赖转置原则\n抽象的模块不应依赖于具体的模块，具体应依赖于抽象。\n在Java语言中，抽象就是指接口或抽象类，两者都不能被实例化；而细节就是实现接口或继承抽象类产生的类，也就是可以被实例化的实现类。依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的，这就是俗称的面向接口编程。\n"
  },
  {
    "head": "软件构造——关于等价性",
    "paragraphs": [
      "关于等价性",
      "在学到ADT的等价性的时候，有三条基本原则，即：自反、传递、对称。",
      "其中，自反和对称往往是满足的，但传递常常出现一些问题。比如，在课堂上就出现了这样一个例子：",
      "显然，这个equals()不满足于传递性，问题就出现所谓的误差值CLOCK_SKEW上。由于误差值在传递的过程中会不断累加，从而导致了最终超过可容忍的误差值的情况。",
      "但这种设置误差值的方法是经常使用的，比如在ACM的很多计算几何题目中，就大量采用了误差值的方法。以二维为例：设一个误差值eps（通常很小），对两点A(x1,y1)和B(x2,y2)，当这两点间距离",
      "dis(A,B)=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2} \\leq eps",
      "时，将A与B视为同一点。",
      "这个方法是非常实用的，因为它很好地解决了计算机浮点运算中精度误差的问题。但这样的代价就是破坏了等价关系的传递性。",
      "从某种意义上来说，我们经常不得不对程序的实用性与准确性进行取舍，这一点在等价性关系上展现得很好。",
      "解决方案",
      "那么，有没有既满足实用性，又满足等价性的解决方案呢？我有一个初步的想法。",
      "以一维线段为例：设左端点为0，右端点为10。将其等距地划分为n段，则每个区间形成了一个等价类。",
      "equals(A,B)：当A和B在同一个区间内时，认为A和B是等价的。否则A和B不等价。",
      "显然，这个equals()是满足等价性的三个原则的：A与B等价，B与C等价，则说明ABC在同一组内，那么A与C等价。",
      "这个equals()是运用了分块算法的想法：块内统一管理。但面对块间的情况时，equals()就不能发挥作用了：只要A与B在不同的块内，哪怕",
      "dis(A,B) \\leq esp",
      "，A与B也不等价。这就是对实用性的牺牲。",
      "同时，我们发现n要尽量的大。",
      "上图中分别为n=2和n=5的情况，显然n=5的情况中equals()更为精准，不容易出现跨块的情况。",
      "改进方案",
      "正如数学上的插值法所说明的：当等距的方法到达瓶颈后，不妨试一下不等距的情况。",
      "由于我们开发的是软件，面对的是实际情况的数据，而实际情况的数据又一般具有一些规律，如：符合正态分布。因此我们可以根据数据的分布情况来改变分块的策略。",
      "不妨假设输入数据满足正态分布：",
      "对上图进行改造：",
      "可以看到2、3两条线段中都是n=5，但是由于数据常常出现在中间部分，两头的数据会较少，因此线段3改变了策略，将端点设置在了{1,2,8,9}。"
    ],
    "sentences": [
      "关于等价性",
      "在学到ADT的等价性的时候",
      "有三条基本原则",
      "即：自反、传递、对称",
      "其中，自反和对称往往是满足的，但传递常常出现一些问题",
      "比如",
      "在课堂上就出现了这样一个例子：显然",
      "这个equals()不满足于传递性",
      "问题就出现所谓的误差值CLOCK_SKEW上",
      "由于误差值在传递的过程中会不断累加",
      "从而导致了最终超过可容忍的误差值的情况",
      "但这种设置误差值的方法是经常使用的",
      "比如在ACM的很多计算几何题目中",
      "就大量采用了误差值的方法",
      "以二维为例：设一个误差值eps（通常很小）",
      "对两点A(x1,y1)和B(x2,y2)",
      "当这两点间距离",
      "dis(A,B)=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2} \\leq eps",
      "时，将A与B视为同一点",
      "这个方法是非常实用的",
      "因为它很好地解决了计算机浮点运算中精度误差的问题",
      "但这样的代价就是破坏了等价关系的传递性",
      "从某种意义上来说",
      "我们经常不得不对程序的实用性与准确性进行取舍",
      "这一点在等价性关系上展现得很好",
      "解决方案",
      "那么",
      "有没有既满足实用性",
      "又满足等价性的解决方案呢？我有一个初步的想法",
      "以一维线段为例：设左端点为0，右端点为10",
      "将其等距地划分为n段，则每个区间形成了一个等价类",
      "equals(A,B)：当A和B在同一个区间内时",
      "认为A和B是等价的",
      "否则A和B不等价",
      "显然",
      "这个equals()是满足等价性的三个原则的：A与B等价",
      "B与C等价",
      "则说明ABC在同一组内",
      "那么A与C等价",
      "这个equals()是运用了分块算法的想法：块内统一管理",
      "但面对块间的情况时",
      "equals()就不能发挥作用了：只要A与B在不同的块内",
      "哪怕",
      "dis(A,B) \\leq esp",
      "，A与B也不等价",
      "这就是对实用性的牺牲",
      "同时，我们发现n要尽量的大",
      "上图中分别为n=2和n=5的情况",
      "显然n=5的情况中equals()更为精准",
      "不容易出现跨块的情况",
      "改进方案",
      "正如数学上的插值法所说明的：当等距的方法到达瓶颈后",
      "不妨试一下不等距的情况",
      "由于我们开发的是软件",
      "面对的是实际情况的数据",
      "而实际情况的数据又一般具有一些规律",
      "如：符合正态分布",
      "因此我们可以根据数据的分布情况来改变分块的策略",
      "不妨假设输入数据满足正态分布：对上图进行改造：可以看到2、3两条线段中都是n=5",
      "但是由于数据常常出现在中间部分",
      "两头的数据会较少",
      "因此线段3改变了策略",
      "将端点设置在了{1,2,8,9}"
    ],
    "codes": [],
    "date": "2021-06-30",
    "text": "关于等价性\n在学到ADT的等价性的时候，有三条基本原则，即：自反、传递、对称。\n其中，自反和对称往往是满足的，但传递常常出现一些问题。比如，在课堂上就出现了这样一个例子：\n显然，这个equals()不满足于传递性，问题就出现所谓的误差值CLOCK_SKEW上。由于误差值在传递的过程中会不断累加，从而导致了最终超过可容忍的误差值的情况。\n但这种设置误差值的方法是经常使用的，比如在ACM的很多计算几何题目中，就大量采用了误差值的方法。以二维为例：设一个误差值eps（通常很小），对两点A(x1,y1)和B(x2,y2)，当这两点间距离\ndis(A,B)=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2} \\leq eps\n时，将A与B视为同一点。\n这个方法是非常实用的，因为它很好地解决了计算机浮点运算中精度误差的问题。但这样的代价就是破坏了等价关系的传递性。\n从某种意义上来说，我们经常不得不对程序的实用性与准确性进行取舍，这一点在等价性关系上展现得很好。\n解决方案\n那么，有没有既满足实用性，又满足等价性的解决方案呢？我有一个初步的想法。\n以一维线段为例：设左端点为0，右端点为10。将其等距地划分为n段，则每个区间形成了一个等价类。\nequals(A,B)：当A和B在同一个区间内时，认为A和B是等价的。否则A和B不等价。\n显然，这个equals()是满足等价性的三个原则的：A与B等价，B与C等价，则说明ABC在同一组内，那么A与C等价。\n这个equals()是运用了分块算法的想法：块内统一管理。但面对块间的情况时，equals()就不能发挥作用了：只要A与B在不同的块内，哪怕\ndis(A,B) \\leq esp\n，A与B也不等价。这就是对实用性的牺牲。\n同时，我们发现n要尽量的大。\n上图中分别为n=2和n=5的情况，显然n=5的情况中equals()更为精准，不容易出现跨块的情况。\n改进方案\n正如数学上的插值法所说明的：当等距的方法到达瓶颈后，不妨试一下不等距的情况。\n由于我们开发的是软件，面对的是实际情况的数据，而实际情况的数据又一般具有一些规律，如：符合正态分布。因此我们可以根据数据的分布情况来改变分块的策略。\n不妨假设输入数据满足正态分布：\n对上图进行改造：\n可以看到2、3两条线段中都是n=5，但是由于数据常常出现在中间部分，两头的数据会较少，因此线段3改变了策略，将端点设置在了{1,2,8,9}。\n"
  },
  {
    "head": "GraphPoet翻译",
    "paragraphs": [
      "一个基于图的诗歌派生器。",
      "GraphPoet由文本语料库初始化，它用这个语料库来派生一个单词亲和图",
      "word affinity graph",
      "。单词",
      "words",
      "用图中的顶点",
      "vertices",
      "表示。单词是不包括空格和换行符的不区分大小写的非空字符串，它们在语料库中由空格、换行符或EOF分隔。图中的各边表示邻接的数量：从w1到w2的边的权重定义为语料库中“w2”紧跟在“w1”后面的次数。",
      "举个栗子，给定这个语料库:",
      "Hello, HELLO, hello, goodye!",
      "生成的图应该包含两条边：",
      "(“hello,”) -> (“hello,”) 权重为2",
      "(“hello,”) -> (“goodbye!”) 权重为1",
      "两个点表示为不区分大小写的 “hello,” 和 “goodbye!”",
      "给定输入字符串，GraphPoet通过尝试在输入中的每对相邻单词之间插入一个桥接词",
      "bridge word",
      "来生成一首诗。单词由语料库中的单词定义和分隔。输入词“w1”和“w2”之间的桥接词“b”使得w1->b->w2成为一条包含两条边的路径，满足在这个诗人(GraphPoet)的单词亲和图中的所有从w1到w2的包括两条边路径中，具有最大权重。如果没有这样的路径，则不会插入桥接词。在输出的诗句中，输入词保留了原来的大小写，而桥词则是小写。诗中每个字之间的空白是一个空格，开头和结尾没有空格。",
      "再举个栗子，给定这个语料库：",
      "This is a test of the Mugar Omni Theater sound system.",
      "对于这个输入：",
      "Test the system.",
      "输出的诗句将会是：",
      "Test of the system.",
      "说明：这是一个有要求的ADT类，并且你",
      "弱化要求的规约",
      "specifications",
      "。但是，你",
      "强化规约，也",
      "添加额外方法。你",
      "在你的属性",
      "rep",
      "中使用Graph类，但是除此之外这个类的实现取决于你。",
      "Constructor Summary",
      "GraphPoet",
      "File",
      "corpus)",
      "使用从corpus生成的图创建一个新的诗人。",
      "Method Summary",
      "String",
      "poem",
      "String",
      "input)",
      "生成一首诗。",
      "从java.lang.Object类继承的方法",
      "equals",
      "getClass",
      "hashCode",
      "notifyAll",
      "toString",
      "wait",
      "wait",
      "wait",
      "使用从corpus生成的图创建一个新的诗人。",
      "parameters",
      "corpus - 生成诗人的单词亲和图的文本文件",
      "Throws",
      "IOException - 如果无法找到或无法读corpus文件",
      "Method Detail",
      "POEM",
      "public String poem(String input)",
      "派生一首诗。",
      "Parameters",
      "input - 派生一首诗的源字符串",
      "Returns",
      "poem - (如上文所说)",
      "声明：翻译自MIT6.031的",
      "GraphPoet(Problem Set 2: Poetic Walks)",
      "仅供个人学习",
      "个人水平有限，如有疏漏和错误恳请批评指正"
    ],
    "sentences": [
      "一个基于图的诗歌派生器",
      "GraphPoet由文本语料库初始化",
      "它用这个语料库来派生一个单词亲和图",
      "word affinity graph",
      "单词",
      "words",
      "用图中的顶点",
      "vertices",
      "表示",
      "单词是不包括空格和换行符的不区分大小写的非空字符串",
      "它们在语料库中由空格、换行符或EOF分隔",
      "图中的各边表示邻接的数量：从w1到w2的边的权重定义为语料库中“w2”紧跟在“w1”后面的次数",
      "举个栗子",
      "给定这个语料库:Hello, HELLO, hello, goodye!",
      "生成的图应该包含两条边：(“hello,”) -> (“hello,”) 权重为2",
      "(“hello,”) -> (“goodbye!”) 权重为1",
      "两个点表示为不区分大小写的 “hello,” 和 “goodbye!”",
      "给定输入字符串",
      "GraphPoet通过尝试在输入中的每对相邻单词之间插入一个桥接词",
      "bridge word",
      "来生成一首诗",
      "单词由语料库中的单词定义和分隔",
      "输入词“w1”和“w2”之间的桥接词“b”使得w1->b->w2成为一条包含两条边的路径",
      "满足在这个诗人(GraphPoet)的单词亲和图中的所有从w1到w2的包括两条边路径中",
      "具有最大权重",
      "如果没有这样的路径，则不会插入桥接词",
      "在输出的诗句中，输入词保留了原来的大小写，而桥词则是小写",
      "诗中每个字之间的空白是一个空格，开头和结尾没有空格",
      "再举个栗子",
      "给定这个语料库：This is a test of the Mugar Omni Theater sound system.对于这个输入：Test the system.输出的诗句将会是：Test of the system.说明：这是一个有要求的ADT类",
      "并且你",
      "弱化要求的规约",
      "specifications",
      "但是，你",
      "强化规约，也",
      "添加额外方法",
      "你",
      "在你的属性",
      "rep",
      "中使用Graph类，但是除此之外这个类的实现取决于你",
      "Constructor Summary",
      "GraphPoet",
      "File",
      "corpus)",
      "使用从corpus生成的图创建一个新的诗人",
      "Method Summary",
      "String",
      "poem",
      "String",
      "input)",
      "生成一首诗",
      "从java.lang.Object类继承的方法",
      "equals",
      "getClass",
      "hashCode",
      "notifyAll",
      "toString",
      "wait",
      "wait",
      "wait",
      "使用从corpus生成的图创建一个新的诗人",
      "parameters",
      "corpus - 生成诗人的单词亲和图的文本文件",
      "Throws",
      "IOException - 如果无法找到或无法读corpus文件",
      "Method Detail",
      "POEM",
      "public String poem(String input)",
      "派生一首诗",
      "Parameters",
      "input - 派生一首诗的源字符串",
      "Returns",
      "poem - (如上文所说)",
      "声明：翻译自MIT6.031的",
      "GraphPoet(Problem Set 2: Poetic Walks)",
      "仅供个人学习",
      "个人水平有限，如有疏漏和错误恳请批评指正"
    ],
    "codes": [
      "Class GraphPoet",
      "java.lang.Object",
      "poet.GraphPoet",
      "public class",
      "GraphPoet",
      "extends Object",
      "Constructor Detail",
      "GRAPHPOET",
      "public GraphPoet(File corpus) throws IOException"
    ],
    "date": "2021-07-07",
    "text": "一个基于图的诗歌派生器。\nGraphPoet由文本语料库初始化，它用这个语料库来派生一个单词亲和图\nword affinity graph\n。单词\nwords\n用图中的顶点\nvertices\n表示。单词是不包括空格和换行符的不区分大小写的非空字符串，它们在语料库中由空格、换行符或EOF分隔。图中的各边表示邻接的数量：从w1到w2的边的权重定义为语料库中“w2”紧跟在“w1”后面的次数。\n举个栗子，给定这个语料库:\nHello, HELLO, hello, goodye!\n生成的图应该包含两条边：\n(“hello,”) -> (“hello,”) 权重为2\n(“hello,”) -> (“goodbye!”) 权重为1\n两个点表示为不区分大小写的 “hello,” 和 “goodbye!”\n给定输入字符串，GraphPoet通过尝试在输入中的每对相邻单词之间插入一个桥接词\nbridge word\n来生成一首诗。单词由语料库中的单词定义和分隔。输入词“w1”和“w2”之间的桥接词“b”使得w1->b->w2成为一条包含两条边的路径，满足在这个诗人(GraphPoet)的单词亲和图中的所有从w1到w2的包括两条边路径中，具有最大权重。如果没有这样的路径，则不会插入桥接词。在输出的诗句中，输入词保留了原来的大小写，而桥词则是小写。诗中每个字之间的空白是一个空格，开头和结尾没有空格。\n再举个栗子，给定这个语料库：\nThis is a test of the Mugar Omni Theater sound system.\n对于这个输入：\nTest the system.\n输出的诗句将会是：\nTest of the system.\n说明：这是一个有要求的ADT类，并且你\n弱化要求的规约\nspecifications\n。但是，你\n强化规约，也\n添加额外方法。你\n在你的属性\nrep\n中使用Graph类，但是除此之外这个类的实现取决于你。\nConstructor Summary\nGraphPoet\nFile\ncorpus)\n使用从corpus生成的图创建一个新的诗人。\nMethod Summary\nString\npoem\nString\ninput)\n生成一首诗。\n从java.lang.Object类继承的方法\nequals\ngetClass\nhashCode\nnotifyAll\ntoString\nwait\nwait\nwait\n使用从corpus生成的图创建一个新的诗人。\nparameters\ncorpus - 生成诗人的单词亲和图的文本文件\nThrows\nIOException - 如果无法找到或无法读corpus文件\nMethod Detail\nPOEM\npublic String poem(String input)\n派生一首诗。\nParameters\ninput - 派生一首诗的源字符串\nReturns\npoem - (如上文所说)\n声明：翻译自MIT6.031的\nGraphPoet(Problem Set 2: Poetic Walks)\n仅供个人学习\n个人水平有限，如有疏漏和错误恳请批评指正\n"
  },
  {
    "head": "Java 为什么不采用 360 垃圾清理来进行垃圾回收呢？",
    "paragraphs": [
      "Java垃圾回收机制",
      "什么是垃圾回收（GC）",
      "垃圾回收，顾名思义，便是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。在 Java 虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。",
      "Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。它从一系列 GC Roots 出发，边标记边探索所有被引用的对象。",
      "判断对象死亡的方法",
      "引用计数法:",
      "它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。",
      "引用计数法的具体实现是这样子的：",
      "如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。",
      "引用计数法的弊端：",
      "除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。",
      "可达性分析算法:",
      "可达性分析算法的实质在于将一系列 **GC Roots** 作为初始的**存活对象合集（live set）**，然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。",
      "什么是 GC Roots 呢？",
      "我们可以暂时理解为由堆外指向堆内的引用，",
      "一般而言，GC Roots 包括（但不限于）如下几种：",
      "- Java 方法栈桢中的局部变量；",
      "- 已加载类的静态变量；",
      "JNI handles",
      "- 已启动且未停止的 Java 线程。",
      "- 可达性分析优点：解决循环引用问题",
      "可达性分析可以解决引用计数法所不能解决的循环引用问题。",
      "举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 出发无法到达 a 或者 b，那么可达性分析便不会将它们加入存活对象合集之中。",
      "- 可达性分析算法的问题",
      "虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。",
      "比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。",
      "误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。",
      "漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。",
      "垃圾收集算法",
      "清除（sweep",
      "把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。",
      "清除这种回收方式的优点是原理极其简单。",
      "但是清除有两个缺点：",
      "一是会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。",
      "二是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。",
      "压缩（compact）:",
      "把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。",
      "这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。",
      "复制（copy）：",
      "把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。",
      "复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。",
      "垃圾收集器",
      "Serial收集器",
      "Serial收集器是最基本的、历史最悠久的收集器，曾经是JDK 1.3.1之前虚拟机的新生代收集的唯一选择。Serial这个名字揭示了这是一个单线程的垃圾收集器，特点如下：",
      "仅仅使用一个线程完成垃圾收集工作；",
      "在垃圾收集时必须暂停其他所有的工作线程，知道垃圾收集结束；",
      "Stop the World是在用户不可见情况下执行的，会造成某些应用响应变慢；",
      "使用复制算法；",
      "ParNew收集器",
      "ParNew收集器其实是Serial收集器的多线程版本，与Serial不同的地方就是在垃圾收集过程中使用多个线程，剩下的所有行为包括控制参数、收集算法、Stop the World、对象分配规则和回收策略等都一样。ParNew收集器也使用复制算法。",
      "Parallel Scavenge收集器",
      "Parallel Scavenge收集器和ParNew类似，是一个新生代收集器，使用复制算法，又是并行的多线程收集器。不过和ParNew不同的是，Parallel Scavenge收集器的关注点不同。",
      "CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的则是达到一个可控制的吞吐量。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+运行垃圾收集时间）。如果虚拟机一共运行100分钟，垃圾收集运行了1分钟，那么吞吐量就是99%。",
      "停顿时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。",
      "Parallel Scavenge收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。",
      "MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能在给定时间内完成垃圾收集。不过垃圾收集时间的缩短是以牺牲吞吐量和新生代空间为代价的，短的垃圾收集时间会导致更加频繁的垃圾收集行为，从而导致吞吐量的降低。",
      "Serial Old收集器",
      "Serial Old是Serial的老年版本，在Serial的工作流程图中可以看到，Serial Old收集器也是一个单线程收集器，使用“标记-整理”算法。这个收集器主要给Client模式下的虚拟机使用。如果在Serve模式下，它有两个用途：一个是在JDK 1.5之前的版本中与Parallel Scavenge收集器搭配使用；另一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。这个收集器的工作流程在Serial的后半部分有所体现。",
      "Parallel Old收集器",
      "Parallel Old收集器是Parallel Scavenge收集器的老年版本，它也使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6开始提供。",
      "CMS收集器",
      "CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。在重视响应速度和用户体验的应用中，CMS应用很多。",
      "CMS收集器使用“标记-清除”算法，运作过程比较复杂，分为4个步骤：",
      "初始标记（CMS initial mark）",
      "并发标记（CMS Concurrent mark）",
      "重新标记（CMS remark）",
      "并发清除（CMS Concurrent Sweep）",
      "G1收集器",
      "G1（Garbage first）收集器是最先进的收集器之一，是面向服务端的垃圾收集器。与其他收集器相比，G1收集器有如下优点：",
      "并行与并发：有些收集器需要停顿的过程G1仍然可以通过并发的方式让用户程序继续执行；",
      "分代收集：可以不使用其他收集器配合管理整个Java堆；",
      "空间整合：使用标记-整理算法，不产生内存碎片；",
      "可预测的停顿：G1除了降低停顿外，还能建立可预测的停顿时间模型；",
      "G1中也有分代的概念，不过使用G1收集器时，Java堆的内存布局与其他收集器有很大的差别，它将整个Java堆划分为多个大小相等的独立区域（Region），G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要的时间的经验值），在后台维护一个优先列表，每次优先收集价值最大的那个Region。这样就保证了在有限的时间内尽可能提高效率。",
      "G1收集器的大致步骤如下：",
      "初始标记（Initial mark）",
      "并发标记（Concurrent mark）",
      "最终标记（Final mark）",
      "筛选回收（Live Data Counting and Evacuation）",
      "回到标题",
      "360 垃圾清理的目标和 Java GC 的目标是不同的。",
      "360 清理的目标集中在文件系统里无用的垃圾，而 GC 的目标集中在内存里不需要再用到的数据。"
    ],
    "sentences": [
      "Java垃圾回收机制",
      "什么是垃圾回收（GC）",
      "垃圾回收",
      "顾名思义",
      "便是将已经分配出去的",
      "但却不再使用的内存回收回来",
      "以便能够再次分配",
      "在 Java 虚拟机的语境下",
      "垃圾指的是死亡的对象所占据的堆空间",
      "Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象",
      "它从一系列 GC Roots 出发",
      "边标记边探索所有被引用的对象",
      "判断对象死亡的方法",
      "引用计数法:它的做法是为每个对象添加一个引用计数器",
      "用来统计指向该对象的引用个数",
      "一旦某个对象的引用计数器为 0",
      "则说明该对象已经死亡",
      "便可以被回收了",
      "引用计数法的具体实现是这样子的：如果有一个引用",
      "被赋值为某一对象",
      "那么将该对象的引用计数器 +1",
      "如果一个指向某一对象的引用",
      "被赋值为其他值",
      "那么将该对象的引用计数器 -1",
      "也就是说",
      "我们需要截获所有的引用更新操作",
      "并且相应地增减目标对象的引用计数器",
      "引用计数法的弊端：除了需要额外的空间来存储计数器",
      "以及繁琐的更新操作",
      "引用计数法还有一个重大的漏洞",
      "那便是无法处理循环引用对象",
      "可达性分析算法:可达性分析算法的实质在于将一系列 **GC Roots** 作为初始的**存活对象合集（live set）**",
      "然后从该合集出发",
      "探索所有能够被该集合引用到的对象",
      "并将其加入到该集合中",
      "这个过程我们也称之为标记（mark）",
      "最终，未被探索到的对象便是死亡的，是可以回收的",
      "什么是 GC Roots 呢？",
      "我们可以暂时理解为由堆外指向堆内的引用",
      "一般而言",
      "GC Roots 包括（但不限于）如下几种：- Java 方法栈桢中的局部变量；- 已加载类的静态变量；JNI handles",
      "- 已启动且未停止的 Java 线程",
      "- 可达性分析优点：解决循环引用问题",
      "可达性分析可以解决引用计数法所不能解决的循环引用问题",
      "举例来说",
      "即便对象 a 和 b 相互引用",
      "只要从 GC Roots 出发无法到达 a 或者 b",
      "那么可达性分析便不会将它们加入存活对象合集之中",
      "- 可达性分析算法的问题",
      "虽然可达性分析的算法本身很简明",
      "但是在实践中还是有不少其他问题需要解决的",
      "比如说",
      "在多线程环境下",
      "其他线程可能会更新已经访问过的对象中的引用",
      "从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）",
      "误报并没有什么伤害",
      "Java 虚拟机至多损失了部分垃圾回收的机会",
      "漏报则比较麻烦",
      "因为垃圾回收器可能回收事实上仍被引用的对象内存",
      "一旦从原引用访问已经被回收了的对象",
      "则很有可能会直接导致 Java 虚拟机崩溃",
      "垃圾收集算法",
      "清除（sweep",
      "把死亡对象所占据的内存标记为空闲内存",
      "并记录在一个空闲列表（free list）之中",
      "当需要新建对象时",
      "内存管理模块便会从该空闲列表中寻找空闲内存",
      "并划分给新建的对象",
      "清除这种回收方式的优点是原理极其简单",
      "但是清除有两个缺点：一是会造成内存碎片",
      "由于 Java 虚拟机的堆中对象必须是连续分布的",
      "因此可能出现总空闲内存足够",
      "但是无法分配的极端情况",
      "二是分配效率较低",
      "如果是一块连续的内存空间",
      "那么我们可以通过指针加法（pointer bumping）来做分配",
      "而对于空闲列表",
      "Java 虚拟机则需要逐个访问列表中的项",
      "来查找能够放入新建对象的空闲内存",
      "压缩（compact）:把存活的对象聚集到内存区域的起始位置",
      "从而留下一段连续的内存空间",
      "这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销",
      "复制（copy）：把内存区域分为两等分",
      "分别用两个指针 from 和 to 来维护",
      "并且只是用 from 指针指向的内存区域来分配内存",
      "当发生垃圾回收时",
      "便把存活的对象复制到 to 指针指向的内存区域中",
      "并且交换 from 指针和 to 指针的内容",
      "复制这种回收方式同样能够解决内存碎片化的问题",
      "但是它的缺点也极其明显",
      "即堆空间的使用效率极其低下",
      "垃圾收集器",
      "Serial收集器",
      "Serial收集器是最基本的、历史最悠久的收集器",
      "曾经是JDK 1.3.1之前虚拟机的新生代收集的唯一选择",
      "Serial这个名字揭示了这是一个单线程的垃圾收集器",
      "特点如下：仅仅使用一个线程完成垃圾收集工作；在垃圾收集时必须暂停其他所有的工作线程",
      "知道垃圾收集结束；Stop the World是在用户不可见情况下执行的",
      "会造成某些应用响应变慢；使用复制算法；ParNew收集器",
      "ParNew收集器其实是Serial收集器的多线程版本",
      "与Serial不同的地方就是在垃圾收集过程中使用多个线程",
      "剩下的所有行为包括控制参数、收集算法、Stop the World、对象分配规则和回收策略等都一样",
      "ParNew收集器也使用复制算法",
      "Parallel Scavenge收集器",
      "Parallel Scavenge收集器和ParNew类似",
      "是一个新生代收集器",
      "使用复制算法",
      "又是并行的多线程收集器",
      "不过和ParNew不同的是",
      "Parallel Scavenge收集器的关注点不同",
      "CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间",
      "而Parallel Scavenge收集器的目的则是达到一个可控制的吞吐量",
      "吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值",
      "即吞吐量=运行用户代码时间/（运行用户代码时间+运行垃圾收集时间）",
      "如果虚拟机一共运行100分钟",
      "垃圾收集运行了1分钟",
      "那么吞吐量就是99%",
      "停顿时间越短就越适合与用户交互的程序",
      "良好的响应速度能提升用户体验",
      "而高吞吐量则可以高效的利用CPU时间",
      "尽快完成程序的运算任务",
      "主要适合在后台运算而不需要太多交互的任务",
      "Parallel Scavenge收集器提供了两个参数来精确控制吞吐量",
      "分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数",
      "MaxGCPauseMillis参数允许的值是一个大于0的毫秒数",
      "收集器将尽可能在给定时间内完成垃圾收集",
      "不过垃圾收集时间的缩短是以牺牲吞吐量和新生代空间为代价的",
      "短的垃圾收集时间会导致更加频繁的垃圾收集行为",
      "从而导致吞吐量的降低",
      "Serial Old收集器",
      "Serial Old是Serial的老年版本",
      "在Serial的工作流程图中可以看到",
      "Serial Old收集器也是一个单线程收集器",
      "使用“标记-整理”算法",
      "这个收集器主要给Client模式下的虚拟机使用",
      "如果在Serve模式下",
      "它有两个用途：一个是在JDK 1.5之前的版本中与Parallel Scavenge收集器搭配使用；另一个就是作为CMS收集器的后备预案",
      "在并发收集发生Concurrent Mode Failure时使用",
      "这个收集器的工作流程在Serial的后半部分有所体现",
      "Parallel Old收集器",
      "Parallel Old收集器是Parallel Scavenge收集器的老年版本",
      "它也使用多线程和“标记-整理”算法",
      "这个收集器是在JDK 1.6开始提供",
      "CMS收集器",
      "CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器",
      "在重视响应速度和用户体验的应用中，CMS应用很多",
      "CMS收集器使用“标记-清除”算法",
      "运作过程比较复杂",
      "分为4个步骤：初始标记（CMS initial mark）",
      "并发标记（CMS Concurrent mark）",
      "重新标记（CMS remark）",
      "并发清除（CMS Concurrent Sweep）",
      "G1收集器",
      "G1（Garbage first）收集器是最先进的收集器之一",
      "是面向服务端的垃圾收集器",
      "与其他收集器相比",
      "G1收集器有如下优点：并行与并发：有些收集器需要停顿的过程G1仍然可以通过并发的方式让用户程序继续执行；分代收集：可以不使用其他收集器配合管理整个Java堆；空间整合：使用标记-整理算法",
      "不产生内存碎片；可预测的停顿：G1除了降低停顿外",
      "还能建立可预测的停顿时间模型；G1中也有分代的概念",
      "不过使用G1收集器时",
      "Java堆的内存布局与其他收集器有很大的差别",
      "它将整个Java堆划分为多个大小相等的独立区域（Region）",
      "G1收集器之所以能建立可预测的停顿时间模型",
      "是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集",
      "G1跟踪各个Region里垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要的时间的经验值）",
      "在后台维护一个优先列表",
      "每次优先收集价值最大的那个Region",
      "这样就保证了在有限的时间内尽可能提高效率",
      "G1收集器的大致步骤如下：初始标记（Initial mark）",
      "并发标记（Concurrent mark）",
      "最终标记（Final mark）",
      "筛选回收（Live Data Counting and Evacuation）",
      "回到标题",
      "360 垃圾清理的目标和 Java GC 的目标是不同的",
      "360 清理的目标集中在文件系统里无用的垃圾",
      "而 GC 的目标集中在内存里不需要再用到的数据"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "Java垃圾回收机制\n什么是垃圾回收（GC）\n垃圾回收，顾名思义，便是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。在 Java 虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。\nJava 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。它从一系列 GC Roots 出发，边标记边探索所有被引用的对象。\n判断对象死亡的方法\n引用计数法:\n它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。\n引用计数法的具体实现是这样子的：\n如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。\n引用计数法的弊端：\n除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。\n可达性分析算法:\n可达性分析算法的实质在于将一系列 **GC Roots** 作为初始的**存活对象合集（live set）**，然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。\n什么是 GC Roots 呢？\n我们可以暂时理解为由堆外指向堆内的引用，\n一般而言，GC Roots 包括（但不限于）如下几种：\n- Java 方法栈桢中的局部变量；\n- 已加载类的静态变量；\nJNI handles\n- 已启动且未停止的 Java 线程。\n- 可达性分析优点：解决循环引用问题\n可达性分析可以解决引用计数法所不能解决的循环引用问题。\n举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 出发无法到达 a 或者 b，那么可达性分析便不会将它们加入存活对象合集之中。\n- 可达性分析算法的问题\n虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。\n比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。\n误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。\n漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。\n垃圾收集算法\n清除（sweep\n把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。\n清除这种回收方式的优点是原理极其简单。\n但是清除有两个缺点：\n一是会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。\n二是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。\n压缩（compact）:\n把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。\n这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。\n复制（copy）：\n把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。\n复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。\n垃圾收集器\nSerial收集器\nSerial收集器是最基本的、历史最悠久的收集器，曾经是JDK 1.3.1之前虚拟机的新生代收集的唯一选择。Serial这个名字揭示了这是一个单线程的垃圾收集器，特点如下：\n仅仅使用一个线程完成垃圾收集工作；\n在垃圾收集时必须暂停其他所有的工作线程，知道垃圾收集结束；\nStop the World是在用户不可见情况下执行的，会造成某些应用响应变慢；\n使用复制算法；\nParNew收集器\nParNew收集器其实是Serial收集器的多线程版本，与Serial不同的地方就是在垃圾收集过程中使用多个线程，剩下的所有行为包括控制参数、收集算法、Stop the World、对象分配规则和回收策略等都一样。ParNew收集器也使用复制算法。\nParallel Scavenge收集器\nParallel Scavenge收集器和ParNew类似，是一个新生代收集器，使用复制算法，又是并行的多线程收集器。不过和ParNew不同的是，Parallel Scavenge收集器的关注点不同。\nCMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的则是达到一个可控制的吞吐量。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+运行垃圾收集时间）。如果虚拟机一共运行100分钟，垃圾收集运行了1分钟，那么吞吐量就是99%。\n停顿时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\nParallel Scavenge收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。\nMaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能在给定时间内完成垃圾收集。不过垃圾收集时间的缩短是以牺牲吞吐量和新生代空间为代价的，短的垃圾收集时间会导致更加频繁的垃圾收集行为，从而导致吞吐量的降低。\nSerial Old收集器\nSerial Old是Serial的老年版本，在Serial的工作流程图中可以看到，Serial Old收集器也是一个单线程收集器，使用“标记-整理”算法。这个收集器主要给Client模式下的虚拟机使用。如果在Serve模式下，它有两个用途：一个是在JDK 1.5之前的版本中与Parallel Scavenge收集器搭配使用；另一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。这个收集器的工作流程在Serial的后半部分有所体现。\nParallel Old收集器\nParallel Old收集器是Parallel Scavenge收集器的老年版本，它也使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6开始提供。\nCMS收集器\nCMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。在重视响应速度和用户体验的应用中，CMS应用很多。\nCMS收集器使用“标记-清除”算法，运作过程比较复杂，分为4个步骤：\n初始标记（CMS initial mark）\n并发标记（CMS Concurrent mark）\n重新标记（CMS remark）\n并发清除（CMS Concurrent Sweep）\nG1收集器\nG1（Garbage first）收集器是最先进的收集器之一，是面向服务端的垃圾收集器。与其他收集器相比，G1收集器有如下优点：\n并行与并发：有些收集器需要停顿的过程G1仍然可以通过并发的方式让用户程序继续执行；\n分代收集：可以不使用其他收集器配合管理整个Java堆；\n空间整合：使用标记-整理算法，不产生内存碎片；\n可预测的停顿：G1除了降低停顿外，还能建立可预测的停顿时间模型；\nG1中也有分代的概念，不过使用G1收集器时，Java堆的内存布局与其他收集器有很大的差别，它将整个Java堆划分为多个大小相等的独立区域（Region），G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要的时间的经验值），在后台维护一个优先列表，每次优先收集价值最大的那个Region。这样就保证了在有限的时间内尽可能提高效率。\nG1收集器的大致步骤如下：\n初始标记（Initial mark）\n并发标记（Concurrent mark）\n最终标记（Final mark）\n筛选回收（Live Data Counting and Evacuation）\n回到标题\n360 垃圾清理的目标和 Java GC 的目标是不同的。\n360 清理的目标集中在文件系统里无用的垃圾，而 GC 的目标集中在内存里不需要再用到的数据。\n"
  },
  {
    "head": "Java 集合类 总结",
    "paragraphs": [
      "在编写java程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！",
      "java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等。",
      "Collection接口",
      "Collection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。",
      "在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。",
      "List接口",
      "List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。",
      "2.1 ArrayList",
      "ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。",
      "size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。",
      "ArrayList擅长于随机访问。同时ArrayList是非同步的。",
      "2.2 LinkedList",
      "同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。",
      "由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。",
      "与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(...));",
      "2.3 Vector",
      "与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。",
      "2.4 Stack Stack",
      "继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。。",
      "Set接口",
      "Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。",
      "3.1 EnumSet 是枚举的专用Set。所有的元素都是枚举类型。",
      "3.2 HashSet HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。",
      "Map接口",
      "Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。",
      "4.1 HashMap 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。",
      "4.2 TreeMap 键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口",
      "4.3 HashTable 也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低",
      "Queue接口",
      "队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。"
    ],
    "sentences": [
      "在编写java程序中",
      "我们最常用的除了八种基本数据类型",
      "String对象外还有一个集合类",
      "在我们的的程序中到处充斥着集合类的身影！",
      "java中集合大家族的成员实在是太丰富了",
      "有常用的ArrayList、HashMap、HashSet",
      "也有不常用的Stack、Queue",
      "有线程安全的Vector、HashTable",
      "也有线程不安全的LinkedList、TreeMap等等",
      "Collection接口",
      "Collection接口是最基本的集合接口",
      "它不提供直接的实现",
      "Java SDK提供的类都是继承自Collection的“子接口”如List和Set",
      "Collection所代表的是一种规则",
      "它所包含的元素都必须遵循一条或者多条规则",
      "如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列",
      "有些支持排序但是有些则不支持",
      "在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数",
      "一个是无参",
      "用于创建一个空的Collection",
      "一个是带有Collection参数的有参构造函数",
      "用于创建一个新的Collection",
      "这个新的Collection与传入进来的Collection具备相同的元素",
      "List接口",
      "List接口为Collection直接接口",
      "List所代表的是有序的Collection",
      "即它用某种特定的插入顺序来维护元素顺序",
      "用户可以对列表中每个元素的插入位置进行精确地控制",
      "同时可以根据元素的整数索引（在列表中的位置）访问元素",
      "并搜索列表中的元素",
      "实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack",
      "2.1 ArrayList",
      "ArrayList是一个动态数组，也是我们最常用的集合",
      "它允许任何符合规则的元素插入甚至包括null",
      "每一个ArrayList都有一个初始容量（10）",
      "该容量代表了数组的大小",
      "随着容器中的元素不断增加，容器的大小也会随着增加",
      "在每次向容器中增加元素的同时都会进行容量检查",
      "当快溢出时",
      "就会进行扩容操作",
      "所以如果我们明确所插入元素的多少",
      "最好指定一个初始容量值",
      "避免过多的进行扩容操作而浪费时间、效率",
      "size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行",
      "add 操作以分摊的固定时间运行",
      "也就是说",
      "添加 n 个元素需要 O(n) 时间（由于要考虑到扩容",
      "所以这不只是添加元素会带来分摊固定时间开销那样简单）",
      "ArrayList擅长于随机访问",
      "同时ArrayList是非同步的",
      "2.2 LinkedList",
      "同样实现List接口的LinkedList与ArrayList不同",
      "ArrayList是一个动态数组",
      "而LinkedList是一个双向链表",
      "所以它除了有ArrayList的基本操作方法外还额外提供了get",
      "remove",
      "insert方法在LinkedList的首部或尾部",
      "由于实现的方式不同",
      "LinkedList不能随机访问",
      "它所有的操作都是要按照双重链表的需要执行",
      "在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）",
      "这样做的好处就是可以通过较低的代价在List中进行插入和删除操作",
      "与ArrayList一样，LinkedList也是非同步的",
      "如果多个线程同时访问一个List，则必须自己实现访问同步",
      "一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(...));2.3 Vector",
      "与ArrayList相似，但是Vector是同步的",
      "所以说Vector是线程安全的动态数组",
      "它的操作与ArrayList几乎一样",
      "2.4 Stack Stack",
      "继承自Vector，实现一个后进先出的堆栈",
      "Stack提供5个额外的方法使得Vector得以被当作堆栈使用",
      "基本的push和pop 方法",
      "还有peek方法得到栈顶的元素",
      "empty方法测试堆栈是否为空",
      "search方法检测一个元素在堆栈中的位置",
      "Stack刚创建后是空栈",
      "Set接口",
      "Set是一种不包括重复元素的Collection",
      "它维持它自己的内部排序，所以随机访问没有任何意义",
      "与List一样，它同样运行null的存在但是仅有一个",
      "由于Set接口的特殊性",
      "所有传入Set集合中的元素都必须不同",
      "同时要注意任何可变对象",
      "如果在对集合中元素进行操作时",
      "导致e1.equals(e2)==true",
      "则必定会产生某些问题",
      "实现了Set接口的集合有：EnumSet、HashSet、TreeSet",
      "3.1 EnumSet 是枚举的专用Set",
      "所有的元素都是枚举类型",
      "3.2 HashSet HashSet堪称查询速度最快的集合",
      "因为其内部是以HashCode来实现的",
      "它内部元素的顺序是由哈希码来决定的",
      "所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变",
      "Map接口",
      "Map与List、Set接口不同",
      "它是由一系列键值对组成的集合",
      "提供了key到Value的映射",
      "同时它也没有继承Collection",
      "在Map中它保证了key与value之间的一一对应关系",
      "也就是说一个key对应一个value",
      "所以它不能存在相同的key值",
      "当然value值可以相同",
      "实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap",
      "4.1 HashMap 以哈希表数据结构实现",
      "查找对象时通过哈希函数计算其位置",
      "它是为快速查询而设计的",
      "其内部定义了一个hash表数组（Entry[] table）",
      "元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引",
      "如果有冲突",
      "则使用散列链表的形式将所有相同哈希地址的元素串起来",
      "可能通过查看HashMap.Entry的源码它是一个单链表结构",
      "4.2 TreeMap 键以某种排序规则排序",
      "内部以red-black（红-黑）树数据结构实现",
      "实现了SortedMap接口",
      "4.3 HashTable 也是以哈希表数据结构实现的",
      "解决冲突时与HashMap也一样也是采用了散列链表的形式",
      "不过性能比HashMap要低",
      "Queue接口",
      "队列",
      "它主要分为两大类",
      "一类是阻塞式队列",
      "队列满了以后再插入元素则会抛出异常",
      "主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue",
      "另一种队列则是双端队列",
      "支持在头、尾两端插入和移除元素",
      "主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "在编写java程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！\njava中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等。\nCollection接口\nCollection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。\n在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。\nList接口\nList接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。\n2.1 ArrayList\nArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。\nsize、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。\nArrayList擅长于随机访问。同时ArrayList是非同步的。\n2.2 LinkedList\n同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。\n由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。\n与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(...));\n2.3 Vector\n与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。\n2.4 Stack Stack\n继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。。\nSet接口\nSet是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。\n3.1 EnumSet 是枚举的专用Set。所有的元素都是枚举类型。\n3.2 HashSet HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。\nMap接口\nMap与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。\n4.1 HashMap 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。\n4.2 TreeMap 键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口\n4.3 HashTable 也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低\nQueue接口\n队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。\n"
  },
  {
    "head": "软件构造-关于图",
    "paragraphs": [
      "一些概念：",
      "1.连通图与连通分量",
      "连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。",
      "连通分量：非连通图中的各个连通子图称为该图的连通分量。",
      "2.邻接矩阵",
      "邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。",
      "3.邻接表",
      "邻接表是图的一种链式存储表示方法。它是改进后的\"邻接矩阵\"，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。",
      "1.顶点类：",
      "在非常抽象的图的问题中，知识简单的把顶点编号，从0->n-1,不需要任何变量类型来存储顶点，因为他们的用处来自于他们之间的相互关系，但大多数情况下，顶点表示某个真实世界的对象。顶点对象能放在数组中，然后用下标指示。",
      "package com.cn.graph;",
      "/**",
      "* 图的顶点类",
      "* @author Administrator",
      "2.深度优先搜索",
      "找到一个起始点---本例为顶点A,需要做三件事情，首先访问该节点，然后把该点放入栈中，以便记住它，最后标记该点，这样就不会再访问它了。",
      "package com.cn.graph;",
      "/**",
      "* 深度优先实现的图",
      "* @author Administrator",
      "theStack = new StackX();",
      "public void addVertex(char lab){",
      "vertexList[nVerts ++] = new Vertex(lab);",
      "public void displayVertex(int v){",
      "System.out.print(vertexList[v].lable+\" \");",
      "else{",
      "vertexList[i].wasvisited = false;",
      "for (int i = 0; i < nVerts; i++)",
      "3.广度优先",
      "首先访问起始顶点的所有邻接点，然后再访问较远的区域，用队列来实现它。（A是起始点，所以访问它，并标记为当前顶点，然后应用规则）。",
      "package com.cn.graph;",
      "/**",
      "* 图的广度优先搜索---队列类",
      "* @author Administrator",
      "public boolean isEmpty(){",
      "return (rear + 1 == front || front + SIZE - 1 == rear);"
    ],
    "sentences": [
      "一些概念：1.连通图与连通分量",
      "连通图：对无向图而言",
      "任意两个顶点之间都存在一条无向路径",
      "则称该无向图为连通图",
      " 对有向图而言",
      "若图中任意两个顶点之间都存在一条有向路径",
      "则称该有向图为强连通图",
      "连通分量：非连通图中的各个连通子图称为该图的连通分量",
      "2.邻接矩阵",
      "邻接矩阵是指用矩阵来表示图",
      "它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)",
      "3.邻接表",
      "邻接表是图的一种链式存储表示方法",
      "它是改进后的\"邻接矩阵\"",
      "它的缺点是不方便判断两个顶点之间是否有边",
      "但是相对邻接矩阵来说更省空间",
      "1.顶点类：在非常抽象的图的问题中",
      "知识简单的把顶点编号",
      "从0->n-1,不需要任何变量类型来存储顶点",
      "因为他们的用处来自于他们之间的相互关系",
      "但大多数情况下",
      "顶点表示某个真实世界的对象",
      "顶点对象能放在数组中，然后用下标指示",
      "package com.cn.graph;/**",
      "* 图的顶点类",
      "* @author Administrator",
      "2.深度优先搜索",
      "找到一个起始点---本例为顶点A,需要做三件事情",
      "首先访问该节点",
      "然后把该点放入栈中",
      "以便记住它",
      "最后标记该点",
      "这样就不会再访问它了",
      "package com.cn.graph;/**",
      "* 深度优先实现的图",
      "* @author Administrator",
      "theStack = new StackX();public void addVertex(char lab){",
      "vertexList[nVerts ++] = new Vertex(lab);public void displayVertex(int v){",
      "System.out.print(vertexList[v].lable+\" \");else{",
      "vertexList[i].wasvisited = false;for (int i = 0; i < nVerts; i++)",
      "3.广度优先",
      "首先访问起始顶点的所有邻接点",
      "然后再访问较远的区域",
      "用队列来实现它",
      "（A是起始点，所以访问它，并标记为当前顶点，然后应用规则）",
      "package com.cn.graph;/**",
      "* 图的广度优先搜索---队列类",
      "* @author Administrator",
      "public boolean isEmpty(){",
      "return (rear + 1 == front || front + SIZE - 1 == rear);"
    ],
    "codes": [
      "public class Vertex {",
      "public char lable;",
      "public boolean wasvisited;",
      "public Vertex(char lab){",
      "lable = lab;",
      "wasvisited = false;",
      "public class Graph {",
      "private final int MAX_VERTS = 20;",
      "private Vertex[] vertexList;",
      "private int adjMat[][];",
      "public int nVerts;",
      "private StackX theStack;",
      "public Graph(){",
      "vertexList = new Vertex[MAX_VERTS];",
      "adjMat = new int[MAX_VERTS][MAX_VERTS];",
      "nVerts = 0;",
      "for (int i = 0; i < MAX_VERTS; i++) {",
      "for (int j = 0; j < MAX_VERTS; j++) {",
      "adjMat[i][j] = 0;",
      "public void addEdage(int start,int end){",
      "adjMat[start][end] = 1;",
      "adjMat[end][start] = 1;",
      "public void dfs(){",
      "vertexList[0].wasvisited = true;",
      "displayVertex(0);",
      "theStack.push(0);",
      "while (! theStack.isEmpty()){",
      "int v = getAdjUnvisitedVertex(theStack.peek());",
      "if (v == -1)",
      "theStack.pop();",
      "vertexList[v].wasvisited = true;",
      "displayVertex(v);",
      "theStack.push(v);",
      "public int getAdjUnvisitedVertex(int v){",
      "for (int i = 0; i < nVerts; i++)",
      "if (adjMat[v][i] == 1 && vertexList[i].wasvisited == false)",
      "return i;",
      "return -1;",
      "public class Queue {",
      "private final int SIZE = 20;",
      "private int queueArray[];",
      "private int front;",
      "private int rear;",
      "public Queue(){",
      "queueArray = new int[SIZE];",
      "front = 0;",
      "rear = -1;",
      "public void insert(int j){",
      "if (rear == SIZE - 1)",
      "rear = -1;",
      "queueArray[++ rear] = j;",
      "public int remove(){",
      "int temp = queueArray[front ++];",
      "if (front == SIZE)",
      "front = 0;",
      "return temp;"
    ],
    "date": "2021-07-07",
    "text": "一些概念：\n1.连通图与连通分量\n连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。\n连通分量：非连通图中的各个连通子图称为该图的连通分量。\n2.邻接矩阵\n邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。\n3.邻接表\n邻接表是图的一种链式存储表示方法。它是改进后的\"邻接矩阵\"，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。\n1.顶点类：\n在非常抽象的图的问题中，知识简单的把顶点编号，从0->n-1,不需要任何变量类型来存储顶点，因为他们的用处来自于他们之间的相互关系，但大多数情况下，顶点表示某个真实世界的对象。顶点对象能放在数组中，然后用下标指示。\npackage com.cn.graph;\n/**\n* 图的顶点类\n* @author Administrator\n2.深度优先搜索\n找到一个起始点---本例为顶点A,需要做三件事情，首先访问该节点，然后把该点放入栈中，以便记住它，最后标记该点，这样就不会再访问它了。\npackage com.cn.graph;\n/**\n* 深度优先实现的图\n* @author Administrator\ntheStack = new StackX();\npublic void addVertex(char lab){\nvertexList[nVerts ++] = new Vertex(lab);\npublic void displayVertex(int v){\nSystem.out.print(vertexList[v].lable+\" \");\nelse{\nvertexList[i].wasvisited = false;\nfor (int i = 0; i < nVerts; i++)\n3.广度优先\n首先访问起始顶点的所有邻接点，然后再访问较远的区域，用队列来实现它。（A是起始点，所以访问它，并标记为当前顶点，然后应用规则）。\npackage com.cn.graph;\n/**\n* 图的广度优先搜索---队列类\n* @author Administrator\npublic boolean isEmpty(){\nreturn (rear + 1 == front || front + SIZE - 1 == rear);\n"
  },
  {
    "head": "卸载AVG（Antivirus Free）的一个途径 Windows",
    "paragraphs": [
      "1.打开设置界面，找到应用：",
      "2. 选择：应用与功能，找到AVG并点击，选择卸载即可。",
      "博主在用CCleaner的时候稀里糊涂装了一个AVG，找到其安装目录后发现无法删除，会出现报错：需要administrators权限才能更改。网上的更改方法又不好用，使用了命令行、安全模式都无法删除，但使用这个简单的方法很轻易地卸载了。希望有帮助。"
    ],
    "sentences": [
      "1.打开设置界面",
      "找到应用：2. 选择：应用与功能",
      "找到AVG并点击",
      "选择卸载即可",
      "博主在用CCleaner的时候稀里糊涂装了一个AVG",
      "找到其安装目录后发现无法删除",
      "会出现报错：需要administrators权限才能更改",
      "网上的更改方法又不好用",
      "使用了命令行、安全模式都无法删除",
      "但使用这个简单的方法很轻易地卸载了",
      "希望有帮助"
    ],
    "codes": [],
    "date": "2021-07-21",
    "text": "1.打开设置界面，找到应用：\n2. 选择：应用与功能，找到AVG并点击，选择卸载即可。\n博主在用CCleaner的时候稀里糊涂装了一个AVG，找到其安装目录后发现无法删除，会出现报错：需要administrators权限才能更改。网上的更改方法又不好用，使用了命令行、安全模式都无法删除，但使用这个简单的方法很轻易地卸载了。希望有帮助。\n"
  },
  {
    "head": "软件构造内容简单梳理",
    "paragraphs": [
      "1.多维度视图与质量目标",
      "1.多维度视图与质量目标",
      "1.1 三维度八视图",
      "Moment",
      "Period",
      ", AST,",
      "Execution stack trace,",
      "Concurrent multi-threads",
      "Procedure Call Graph,",
      "Message Graph (Sequence Diagram)",
      "Event log, Multi-processes,",
      "Distributed processes",
      "Procedure Call Graph,",
      "Message Graph (Sequence Diagram)",
      "1.2质量目标",
      "1.2.1五个关键的质量目标",
      "1.Elegant and beautiful code：代容易理解。",
      "2.Design for/with reuse：提高代码的可复用性。",
      "3.Low complexity：高内聚低耦合。",
      "4.Robustness and correctness：健壮性和正确性。",
      "5.Performance and efficiency：提升性能。",
      "1.2.2内部&外部质量因素",
      "内部：",
      "代码行数(LOC)、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小。",
      "外部：",
      "Correctness（正确性），Robustness（鲁棒性），Extendibility（易扩展性）， Reusability（复用性），Compatibility（兼容性）， Efficiency（效率）， Portability（可移植性）， Ease of use（易用性），Functionality（功能性），Timeliness（时效性），Verifiability (可验证性)，Integrity (完整性)，Repairability (可修复性)，Economy (经济性)等。",
      "2.软件构造的过程与工具",
      "2.软件构造的过程与工具",
      "2.1 SCM,VCS,Git",
      "2.1.1 SCM(软件配置管理)",
      "软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被成为软件配置项(SCI)。",
      "当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。",
      "为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。",
      "2.1.2 VCM（版本控制系统）",
      "VCS分为三种：本地版本控制系统（无法协作）存储在本地、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。",
      "2.1.3Git",
      "指令：",
      "创建：git init",
      "暂存：git add <filename>",
      "提交：git commit -m “commit message”",
      "链接：git remote add origin <URL>",
      "推送：git push- u origin master",
      "创建分支：git checkout -b <branch name>",
      "切换分支：git checkout <branch name>",
      "合并分支：git merge <branch name>",
      "删除分支：git branch -d <branch name>",
      "注意，git的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。",
      "2.2 软件构造过程",
      "1. Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。",
      "2. Code review、Static code analysis：可以使用工具来发现bug，如CheckStyle, SpotBugs。",
      "3. Testing：测试，单元测试、集成测试、系统测试…",
      "4. Debugging：调试",
      "5. Dynamic code analysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分",
      "6. Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化",
      "7. Build：第2部分",
      "3.ADT&OOP",
      "3.ADT&OOP",
      "3.1 Spec",
      "3.1.1 Spec的结构",
      "precondition前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "使用@param annotation说明每个参数的前置条件",
      "postcondition后置条件：对开发者的约束，方法结束时必须满足的条件",
      "使用@return annotation说明后置条件",
      "抛出异常：",
      "使用@throws annotation说明出现异常的时候会发生什么",
      "在方法声明中使用static等关键字声明，可据此进行静态类型检查",
      "3.1.2 Spec的强弱",
      "更强的Spec：前置条件变弱，后置条件变强，强的Spec可以替换弱的。",
      "3.2 ADT",
      "3.2.1ADT的操作",
      "Creators构造器：用于使用 new 关键字创建一个新的对象。还有一种方法是静态方法，如Arrays.asList()、String.valueOf(Object Obj)等。",
      "Producers生产器：用于使用一个存在的对象产生一个新的对象，例如String.concat()就是使用已存在的字符串构造出一个新的对象，而且不会改动原先存在的对象。",
      "Observers观察器：不对数据做任何改动，只是查看一个已经存在的对象的各个值，如List.size()、所有的getter方法等。",
      "Mutators变值器：用于改变对象属性的方法，如List.add()。mutator通常返回void，因为它不需要对外界做出反应，只是对ADT的数据域做了更改；mutator也可能返回非空，比如返回boolean表示修改成败等。",
      "3.2.2.设计ADT",
      "设计一个好的ADT需要靠开发者的经验来设计它的操作的spec，设计一个ADT要遵循下面三个原则：（1）设计简洁一致的操作（2）要足以支持client所需要的对数据的所有操作，且用操作的难度要低（3）要么抽象要么具体，不要混合——要么针对抽象设计，要么针对具体应用的设计。",
      "实现一个ADT的三个部分：specification、representation、implementation",
      "Representation Independence 表示独立性",
      "client不应该知道内部的数据域是怎么实现的，最好client只能通过ADT提供的getter方法获得ADT存储的数据。",
      "client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。其目的一个是为了便于未来的升级和维护，当内部发生变化的时候不会影响到client。",
      "3.2.3测试ADT",
      "因为测试相当于client使用ADT，所以它也不能直接访问ADT内部的数据域，所以只能调用其他方法去测试被测试的方法。",
      "针对creator：构造对象之后，用observer去观察是否正确",
      "针对observer：用其他三类方法构造对象，然后调用被测observer，判断观察结果是否正确",
      "针对producer：produce新对象之后，用observer判断结果是否正确",
      "Rep Invariant(RI) and Abstraction Function(AF)",
      "Invariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件",
      "两个空间 R 和 A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。",
      "Abstraction Function：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。",
      "Rep Invariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。",
      "相同的R空间有肯能会有不同的RI。",
      "即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。",
      "checkRep()：用于随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。",
      "表示泄露：client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。",
      "3.3 OOP",
      "3.3.1继承与重写",
      "子类可以继承父类的数据域和方法。",
      "严格继承：子类只能添加新方法，无法重写超类中的方法。原因：父类中的方法使用了final关键字限定。",
      "重写：子类的方法覆盖了父类的方法。重写的方法应该与父类方法有相同的签名，只有这样编译器才会判定为重写的方法。使用@Override annotation强制检查是否重写了超类中的方法。",
      "3.3.2 多态",
      "三种多态：特殊多态、参数化多态、子类型多态",
      "特殊多态：功能重载",
      "重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型。参数列表必须不同，返回值类型、可见性、异常均为可以相同也可不同。重载不仅可以发生在类内，也可发生在父类与子类之间。",
      "父类与子类之间发生重载的例子如下。这两个情况都不能编译成功，以为无论是a还是h，他们的运行时类型都是Animal，而不是通过new创建的具体类型。",
      "参数化多态：泛型",
      "使用泛型参数代替具体的类型。作为一个泛型接口，当实现的时候可以实现一个具有具体类型的子类型，也可以实现一个具有泛型接口的实现类。",
      "子类型多态",
      "终极目的：不同类型的对象可以统一处理而无需区分。",
      "遵循的设计原则：LSP",
      "4.复用",
      "4.复用",
      "4.1 四个复用层面",
      "1.源代码层面的复用",
      "可以在网络上寻找自己需要的代码，但要注意开发商用的软件不能直接复制开源的代码，避免引起法律纠纷。",
      "2.模块层面的复用",
      "通过继承 (Inheritance) 的方式复用父类的代码，同时也可override父类中已存在的方法。",
      "另一个复用的方法是 委托(delegation)，详见下一小节(4.2)。",
      "3.库层面的复用",
      "通过导入库来调用库中的API完成复用。除了导入本地库，也可以通过导入部署在网络上的库来完成复用，如 Web Services / Restful APIs",
      "4.架构层面的复用",
      "框架：一组具体类、抽象类、及其之间的连接关系。开发者可以根据spec填充自己的代码从而形成完整的系统。开发者根据Framework预留的接口所写的程序，而Framework作为主程序加以执行，执行过程中调用开发者所写的程序。关于框架详见下一小节4.2.3。",
      "黑盒框架：通过实现特定接口/delegation进行框架扩展",
      "白盒框架：通过代码层面的继承进行框架扩展",
      "4.2 LSP",
      "4.2.1LSP",
      "Liskov Substitution Principle中子类重写父类的方法应该满足的条件：",
      "编译器在静态类型检查时强制满足的条件",
      "子类型可以增加方法，但不可删除",
      "子类型需要实现抽象类型中的所有未实现方法",
      "子类型中重写的方法返回值必须与父类相同或符合co-variance(协变)",
      "子类型中重写的方法必须使用同样类型的参数或者符合contra-variance(逆变)的参数",
      "子类型中重写的方法不能抛出额外的异常",
      "还应该满足的条件",
      "更强的不变量 (RI)",
      "更弱的前置条件",
      "更强的后置条件",
      "关于返回值的类型，应该保持不变或者变得更具体，也就是与派生的方向一致。",
      "所抛出的异常的类型也是如此。",
      "4.2.2.4种委派方式",
      "1.Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。",
      "2.Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。",
      "3.Composition: 更强的association，但难以变化。",
      "4.Aggregation: 更弱的association，可动态变化。",
      "4.3.6种经典复用模式",
      "1.Adapter适配器模式",
      "目的是将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。",
      "因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。",
      "2.Decorator装饰器模式",
      "装饰器模式的原理是从接口派生出子类，然后在子类中定义一个父类接口然后将其作为delegation的对象，也就是说：",
      "自己到自己的委派",
      "。这里第一个自己指的是子类型本身，第二个自己是指该接口的其他子类，由于他们两个是同一个接口的子类，所以可以称为自己到自己的委派。",
      "3.Facade外观模式",
      "客户端在调用的API时候会以固定的方式调用一系列的方法，而为了简化客户端的使用，便于客户端的学习使用、解耦，所以需要",
      "提供一个统一的接口来取代一系列小接口调用，对复杂系统做了一个封装",
      "4.Strategy策略模式",
      "有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，",
      "利用delegation，运行时动态传入client倾向的算法类实例",
      "5.Template Method模板模式",
      "做事情的步骤一样，但具体方法不同，因此共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。",
      "在模板中，实现了一个固定执行一系列操作的方法，这个方法使用final关键字做了限定，不能再被子类重写，因此，子类只能通过重写该方法调用的那些尚未实现的方法。",
      "6.Iterator迭代器模式",
      "客户端希望遍历被放入容器/集合类的一组ADT对象，而无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式",
      "实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。",
      "5.可维护性",
      "5.可维护性",
      "5.1 SOLID设计原则",
      "1.(SRP) The Single Responsibility Principle --------- 单一责任原则",
      "尽可能地将功能分割，以达到",
      "不应该有多于一个原因让你的ADT发生变化",
      "的目的，否则就要拆分开。如果多个责任（功能）放在一个类中就有可能在未来某一个功能发生变化的时候影响到整个类，从而影响到整个程序的很大一部分实现（需要全部重新编译打包部署）。",
      "2.(OCP) The Open-Closed Principle ------------------- 开放-封闭原则",
      "在未来对功能进行修改或者扩展的时候，要遵循尽量不去改动已有的代码而是扩展出新的类然后调用新的类的原则。",
      "典型的违反OCP的例子是大量的使用 if-else / switch-case 语句，这给维护造成了极大的麻烦。所以应对的方法是让客户端传入接口的不同子类型，而在ADT中只需要统一的调用接口中共有的方法即可。",
      "3.(LSP) The Liskov Substitution PrincipleLiskov ---- 替换原则",
      "子类型必须能够替换其基类型。",
      "4.(DIP) The Dependency Inversion Principle -------- 依赖转置原则",
      "具体的模块应该依赖于抽象的模块，但抽象的模块不应依赖于具体的模块。",
      "5.(ISP) The Interface Segregation Principle ---------- 接口隔离原则",
      "大接口分解为多个小的接口。",
      "5.2可维护性的设计模式",
      "1. Factory Method 工厂方法",
      "当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。",
      "定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。",
      "当然也可以通过直接定义静态工厂方法来创建子类实例。",
      "2. Abstract Factory 抽象工厂",
      "当client需要的是多个具有固定搭配的类的组合，如A和B两个系列的类，A1搭配B1，A2搭配B2，于是，就要用抽象工厂对其做一次封装。",
      "定义一个用于创建对象的接口，让其子类来决定实例化哪一组类，从而使类与类之间的搭配对于client来说固定了。",
      "本质上，Abstract Factory是把多类产品的factory method组合在一起",
      "3. Proxy 代理模式",
      "某个对象比较“敏感”/“私密”/“贵重”，不希望被client直接访问到，故设置proxy，在二者之间建立防火墙。",
      "创建一个代理类，它接受client的功能请求，然后把功能请求转发 (delegate) 给实现类，类似于Adapter模式。",
      "4. Observer 观察者模式",
      "5. Visitor",
      "对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。",
      "为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT",
      "本质上是将数据和作用于数据上的某种/些特定操作分离开来。",
      "6. 共性和差异",
      "Proxy vs. Adaptor",
      "Adapter：目的是消除不兼容，目的是B以客户端期望的统一的方式与A建立起联系。",
      "Proxy：目的是隔离对复杂对象的访问，降低难度/代价，定位在“访问/使用行为”",
      "Visitor vs. Iterator",
      "Iterator：目的是以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。",
      "Visitor： 在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT",
      "Strategy vs. visitor",
      "同：二者都是通过delegation建立两个对象的动态联系",
      "Visitor：强调是的外部定义某种对ADT的操作，该操作于ADT自身关系不大（只是访问ADT），故ADT内部只需要开放accept(visitor)即可，client通过它设定visitor操作并在外部调用。",
      "visitor是站在外部client的角度，灵活增加对ADT的各种不同操作（哪怕ADT没实现该操作）。",
      "Strategy：强调是对ADT内部某些要实现的功能的相应算法的灵活替换。这些算法是ADT功能的重要组成部分，只不过是delegate到外部strategy类而已。",
      "strategy是站在内部ADT的角度，灵活变化对其内部功能的不同配置。",
      "6.正确性&健壮性",
      "6.正确性&健壮性",
      "6.1并发",
      "并发编程有两种模式：",
      "共享内存：在内存中读写共享数据，某一时刻执行在不同处理器上的同一程序共享内存里的数据；",
      "消息传递：通过channel交换消息，A把消息发给B，B把执行结果发给A",
      "6.2线程安全",
      "1.Confinement",
      "限制数据共享，将可变数据限制在单一线程内部，不允许任何线程直接读写该数据。",
      "核心思想：线程之间不共享mutable数据类型。",
      "避免使用全局数据，而是使用局部数据。如果使用全局的mutable的数据，就有可能造成竞争条件。",
      "2. Immutability",
      "共享不可变数据，使用不可变数据类型和不可变引用，避免多线程之间的race condition，因为不可变数据通常是线程安全的。",
      "大家都只是读取它的值，而不能对它做出更改，所以它是线程安全的。",
      "不可变类型要满足的条件：",
      "没有mutator方法",
      "所有的数据域都是private和final的",
      "没有表示泄露",
      "rep中的mutable的数据没有任何改变",
      "3.Using Threadsafe Data Types",
      "共享线程安全的可变数据，如果必须要用mutable的数据类型在多线程之间共享数据，要使用线程安全的数据类型。",
      "在JDK中的类，文档中明确指明了是否threadsafe。",
      "一般来说，JDK同时提供两个相同功能的类，一个是threadsafe，另一个不是 (threadsafe的类一般性能上受影响)。例如：",
      "StringBuffer vs. StringBuilder",
      "StringBuffer是线程安全的，可被安全的用于多线程。",
      "StringBuilder是线程不安全的，但它的运行速度要比StringBuffer更快。",
      "4: Locks and Synchronization",
      "同步机制：通过锁的机制共享线程不安全的可变数据，变并行为串行。",
      "6.3锁、同步",
      "6.3.1锁",
      "Lock是Java语言提供的内嵌机制。在Java中，任何对象都可以作为锁。可以创建一个没有意义的对象",
      "Object lock = new Object();",
      "作为锁来使用，而拥有lock的线程可独占式的执行该部分代码。",
      "6.3.2同步",
      "程序员来负责多线程之间对mutable数据的共享操作，通过“同步”策略，避免多线程同时访问数据。",
      "使用锁机制，获得对数据的独家mutation权，其他线程被阻塞，不得访问。",
      "当A线程申请了A锁时，它获得了对数据的独家修改访问权限，B线程再想访问时，就必须申请A锁的使用权限，这就要等A线程执行结束释放锁时候再获得。"
    ],
    "sentences": [
      "1.多维度视图与质量目标",
      "1.多维度视图与质量目标",
      "1.1 三维度八视图",
      "Moment",
      "Period",
      ", AST,Execution stack trace,Concurrent multi-threads",
      "Procedure Call Graph,Message Graph (Sequence Diagram)",
      "Event log, Multi-processes,Distributed processes",
      "Procedure Call Graph,Message Graph (Sequence Diagram)",
      "1.2质量目标",
      "1.2.1五个关键的质量目标",
      "1.Elegant and beautiful code：代容易理解",
      "2.Design for/with reuse：提高代码的可复用性",
      "3.Low complexity：高内聚低耦合",
      "4.Robustness and correctness：健壮性和正确性",
      "5.Performance and efficiency：提升性能",
      "1.2.2内部&外部质量因素",
      "内部：代码行数(LOC)、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小",
      "外部：Correctness（正确性）",
      "Robustness（鲁棒性）",
      "Extendibility（易扩展性）",
      " Reusability（复用性）",
      "Compatibility（兼容性）",
      " Efficiency（效率）",
      " Portability（可移植性）",
      " Ease of use（易用性）",
      "Functionality（功能性）",
      "Timeliness（时效性）",
      "Verifiability (可验证性)",
      "Integrity (完整性)",
      "Repairability (可修复性)",
      "Economy (经济性)等",
      "2.软件构造的过程与工具",
      "2.软件构造的过程与工具",
      "2.1 SCM,VCS,Git",
      "2.1.1 SCM(软件配置管理)",
      "软件配置管理是为了追踪和控制软件的变化",
      "而软件中发生变化的基本单元",
      "如文件",
      "就被成为软件配置项(SCI)",
      "当软件在开发过程中达到了一个稳定的状态",
      "如可以对外发布的状态",
      "此时的文件组成了基线(Baseline)",
      "为了存储各配置项随时间变化的信息和基线信息",
      "就有一个数据库来管理这些内容",
      "即配置管理数据库(CMDB)",
      "2.1.2 VCM（版本控制系统）",
      "VCS分为三种：本地版本控制系统（无法协作）存储在本地、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）存储在服务器上、分布式版本控制系统（解决了前两者的问题",
      "代价是存储空间）同时存储在本地和服务器",
      "2.1.3Git",
      "指令：创建：git init",
      "暂存：git add <filename>",
      "提交：git commit -m “commit message”",
      "链接：git remote add origin <URL>",
      "推送：git push- u origin master",
      "创建分支：git checkout -b <branch name>",
      "切换分支：git checkout <branch name>",
      "合并分支：git merge <branch name>",
      "删除分支：git branch -d <branch name>",
      "注意",
      "git的存储结构是一张有向无环图",
      "每次commit在图上会增加一个新的节点",
      "并将HEAD指向这个节点",
      "通常一个子节点有一个父节点",
      "当一个父节点有多个子节点时表明创建了分支",
      "一个子节点有多个父节点时表明进行分支合并",
      "传统VCS存储的是文件每个版本之间的变化",
      "这种办法的优点是存储空间较小",
      "但由于存储的只是变化",
      "取出指定时期的文件要先取出原文件",
      "再取出变化内容",
      "最后做合并形成新文件",
      "所以取出文件的时间复杂度较高",
      "git存储的则是文件",
      "所以取出特定版本的文件比较方便",
      "但是代价的是空间复杂度较高",
      "2.2 软件构造过程",
      "1. Programming：有编程语言",
      "也有建模语言",
      "如UML",
      "还有配置语言",
      "如XML、JSON",
      "2. Code review、Static code analysis：可以使用工具来发现bug",
      "如CheckStyle, SpotBugs",
      "3. Testing：测试，单元测试、集成测试、系统测试…",
      "4. Debugging：调试",
      "5. Dynamic code analysis/profiling：在程序运行的过程中查看并发现问题",
      "本课程不涉及这部分",
      "6. Refactoring：重构不改变功能",
      "只是处于更容易维护的目的对代码优化",
      "7. Build：第2部分",
      "3.ADT&OOP",
      "3.ADT&OOP",
      "3.1 Spec",
      "3.1.1 Spec的结构",
      "precondition前置条件：对客户端的约束",
      "在使用方法时必须满足的条件",
      "使用@param annotation说明每个参数的前置条件",
      "postcondition后置条件：对开发者的约束",
      "方法结束时必须满足的条件",
      "使用@return annotation说明后置条件",
      "抛出异常：使用@throws annotation说明出现异常的时候会发生什么",
      "在方法声明中使用static等关键字声明",
      "可据此进行静态类型检查",
      "3.1.2 Spec的强弱",
      "更强的Spec：前置条件变弱",
      "后置条件变强",
      "强的Spec可以替换弱的",
      "3.2 ADT",
      "3.2.1ADT的操作",
      "Creators构造器：用于使用 new 关键字创建一个新的对象",
      "还有一种方法是静态方法",
      "如Arrays.asList()、String.valueOf(Object Obj)等",
      "Producers生产器：用于使用一个存在的对象产生一个新的对象",
      "例如String.concat()就是使用已存在的字符串构造出一个新的对象",
      "而且不会改动原先存在的对象",
      "Observers观察器：不对数据做任何改动",
      "只是查看一个已经存在的对象的各个值",
      "如List.size()、所有的getter方法等",
      "Mutators变值器：用于改变对象属性的方法",
      "如List.add()",
      "mutator通常返回void",
      "因为它不需要对外界做出反应",
      "只是对ADT的数据域做了更改；mutator也可能返回非空",
      "比如返回boolean表示修改成败等",
      "3.2.2.设计ADT",
      "设计一个好的ADT需要靠开发者的经验来设计它的操作的spec",
      "设计一个ADT要遵循下面三个原则：（1）设计简洁一致的操作（2）要足以支持client所需要的对数据的所有操作",
      "且用操作的难度要低（3）要么抽象要么具体",
      "不要混合——要么针对抽象设计",
      "要么针对具体应用的设计",
      "实现一个ADT的三个部分：specification、representation、implementation",
      "Representation Independence 表示独立性",
      "client不应该知道内部的数据域是怎么实现的",
      "最好client只能通过ADT提供的getter方法获得ADT存储的数据",
      "client使用ADT时无需考虑其内部如何实现",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "其目的一个是为了便于未来的升级和维护",
      "当内部发生变化的时候不会影响到client",
      "3.2.3测试ADT",
      "因为测试相当于client使用ADT",
      "所以它也不能直接访问ADT内部的数据域",
      "所以只能调用其他方法去测试被测试的方法",
      "针对creator：构造对象之后",
      "用observer去观察是否正确",
      "针对observer：用其他三类方法构造对象",
      "然后调用被测observer",
      "判断观察结果是否正确",
      "针对producer：produce新对象之后",
      "用observer判断结果是否正确",
      "Rep Invariant(RI) and Abstraction Function(AF)",
      "Invariants：不变量",
      "与程序运行无关",
      "在任何时候都应该满足的一些条件",
      "两个空间 R 和 A：R空间是ADT的内部表示的空间",
      "A空间是ADT能够表示的存在于实际当中的对象",
      "ADT的开发者关注的是R空间，client关注的是A空间",
      "Abstraction Function：从R空间到A空间存在一个映射",
      "这个映射是一个满射",
      "这个映射将R中的每一个值解释为A中的一个值",
      "这个解释函数就是AF",
      "Rep Invariant：这是一个集合",
      "是R空间所有值的子集",
      "它包含了所有合法的表示值",
      "而只有满足RI的值",
      "才是合法值",
      "才会在A空间内有值与其对应",
      "相同的R空间有肯能会有不同的RI",
      "即使是同样的R、同样的RI",
      "也可能有不同的AF",
      "即“解释不同”",
      "checkRep()：用于随时检查RI是否满足",
      "使用assert检查RI",
      "在所有的方法最好都加入调用这个检查方法",
      "checkRep()在检查时有可能耗费大量的时间影响性能",
      "所以只需要在开发阶段保留这部分",
      "表示泄露：client可以拿到数据域的本身或别名",
      "一旦表示泄露",
      "client就有可能无意间改动数据",
      "而如果在设计中",
      "要求一个ADT是Immutable的",
      "而如果它出现了表示泄露",
      "就有可能违反Immutable的原则",
      "3.3 OOP",
      "3.3.1继承与重写",
      "子类可以继承父类的数据域和方法",
      "严格继承：子类只能添加新方法，无法重写超类中的方法",
      "原因：父类中的方法使用了final关键字限定",
      "重写：子类的方法覆盖了父类的方法",
      "重写的方法应该与父类方法有相同的签名",
      "只有这样编译器才会判定为重写的方法",
      "使用@Override annotation强制检查是否重写了超类中的方法",
      "3.3.2 多态",
      "三种多态：特殊多态、参数化多态、子类型多态",
      "特殊多态：功能重载",
      "重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型",
      "参数列表必须不同",
      "返回值类型、可见性、异常均为可以相同也可不同",
      "重载不仅可以发生在类内，也可发生在父类与子类之间",
      "父类与子类之间发生重载的例子如下",
      "这两个情况都不能编译成功",
      "以为无论是a还是h",
      "他们的运行时类型都是Animal",
      "而不是通过new创建的具体类型",
      "参数化多态：泛型",
      "使用泛型参数代替具体的类型",
      "作为一个泛型接口",
      "当实现的时候可以实现一个具有具体类型的子类型",
      "也可以实现一个具有泛型接口的实现类",
      "子类型多态",
      "终极目的：不同类型的对象可以统一处理而无需区分",
      "遵循的设计原则：LSP",
      "4.复用",
      "4.复用",
      "4.1 四个复用层面",
      "1.源代码层面的复用",
      "可以在网络上寻找自己需要的代码",
      "但要注意开发商用的软件不能直接复制开源的代码",
      "避免引起法律纠纷",
      "2.模块层面的复用",
      "通过继承 (Inheritance) 的方式复用父类的代码",
      "同时也可override父类中已存在的方法",
      "另一个复用的方法是 委托(delegation)",
      "详见下一小节(4.2)",
      "3.库层面的复用",
      "通过导入库来调用库中的API完成复用",
      "除了导入本地库",
      "也可以通过导入部署在网络上的库来完成复用",
      "如 Web Services / Restful APIs",
      "4.架构层面的复用",
      "框架：一组具体类、抽象类、及其之间的连接关系",
      "开发者可以根据spec填充自己的代码从而形成完整的系统",
      "开发者根据Framework预留的接口所写的程序",
      "而Framework作为主程序加以执行",
      "执行过程中调用开发者所写的程序",
      "关于框架详见下一小节4.2.3",
      "黑盒框架：通过实现特定接口/delegation进行框架扩展",
      "白盒框架：通过代码层面的继承进行框架扩展",
      "4.2 LSP",
      "4.2.1LSP",
      "Liskov Substitution Principle中子类重写父类的方法应该满足的条件：编译器在静态类型检查时强制满足的条件",
      "子类型可以增加方法，但不可删除",
      "子类型需要实现抽象类型中的所有未实现方法",
      "子类型中重写的方法返回值必须与父类相同或符合co-variance(协变)",
      "子类型中重写的方法必须使用同样类型的参数或者符合contra-variance(逆变)的参数",
      "子类型中重写的方法不能抛出额外的异常",
      "还应该满足的条件",
      "更强的不变量 (RI)",
      "更弱的前置条件",
      "更强的后置条件",
      "关于返回值的类型",
      "应该保持不变或者变得更具体",
      "也就是与派生的方向一致",
      "所抛出的异常的类型也是如此",
      "4.2.2.4种委派方式",
      "1.Dependency：依赖关系",
      "临时性的delegation",
      "把被delegation的对象以参数方式传入",
      "只有在需要的时候才建立与被委派类的联系",
      "而当方法结束的时候这种关系也就随之断开了",
      "2.Association：关联关系",
      "永久性的delegation",
      "被delegation的对象保存在rep中",
      "该对象的类型被永久的与此ADT绑定在了一起",
      "3.Composition: 更强的association",
      "但难以变化",
      "4.Aggregation: 更弱的association",
      "可动态变化",
      "4.3.6种经典复用模式",
      "1.Adapter适配器模式",
      "目的是将某个类/接口转换为client期望的其他形式",
      "通过增加一个接口",
      "将已存在的子类封装起来",
      "client面向接口编程",
      "从而隐藏了具体子类",
      "因为Adaptee是不匹配客户端所需求的",
      "可能是参数上的",
      "所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作",
      "这就是Adapter",
      "它接受客户端的功能请求但是不会做具体的功能实现",
      "而是把客户端所提供的参数转换成Adaptee所接受的形式",
      "然后将任务委派给Adaptee完成",
      "2.Decorator装饰器模式",
      "装饰器模式的原理是从接口派生出子类",
      "然后在子类中定义一个父类接口然后将其作为delegation的对象",
      "也就是说：自己到自己的委派",
      "这里第一个自己指的是子类型本身",
      "第二个自己是指该接口的其他子类",
      "由于他们两个是同一个接口的子类",
      "所以可以称为自己到自己的委派",
      "3.Facade外观模式",
      "客户端在调用的API时候会以固定的方式调用一系列的方法",
      "而为了简化客户端的使用",
      "便于客户端的学习使用、解耦",
      "所以需要",
      "提供一个统一的接口来取代一系列小接口调用",
      "对复杂系统做了一个封装",
      "4.Strategy策略模式",
      "有多种不同的算法来实现同一个任务",
      "但需要client根据需要动态切换算法",
      "而不是写死在代码里",
      "因此可以为不同的实现算法构造抽象接口",
      "利用delegation",
      "运行时动态传入client倾向的算法类实例",
      "5.Template Method模板模式",
      "做事情的步骤一样",
      "但具体方法不同",
      "因此共性的步骤在抽象类内公共实现",
      "差异化的步骤在各个子类中实现",
      "使用继承和重写实现模板模式",
      "在模板中",
      "实现了一个固定执行一系列操作的方法",
      "这个方法使用final关键字做了限定",
      "不能再被子类重写",
      "因此",
      "子类只能通过重写该方法调用的那些尚未实现的方法",
      "6.Iterator迭代器模式",
      "客户端希望遍历被放入容器/集合类的一组ADT对象",
      "而无需关心容器的具体类型",
      "也就是说",
      "不管对象被放进哪里",
      "都应该提供同样的遍历方式",
      "实现方式是在ADT类中实现Iterable接口",
      "该接口内部只有一个返回一个迭代器的方法",
      "然后创建一个迭代器类实现Iterator接口",
      "实现hasnext()、next()、remove()这三个方法",
      "5.可维护性",
      "5.可维护性",
      "5.1 SOLID设计原则",
      "1.(SRP) The Single Responsibility Principle --------- 单一责任原则",
      "尽可能地将功能分割，以达到",
      "不应该有多于一个原因让你的ADT发生变化",
      "的目的，否则就要拆分开",
      "如果多个责任（功能）放在一个类中就有可能在未来某一个功能发生变化的时候影响到整个类",
      "从而影响到整个程序的很大一部分实现（需要全部重新编译打包部署）",
      "2.(OCP) The Open-Closed Principle ------------------- 开放-封闭原则",
      "在未来对功能进行修改或者扩展的时候",
      "要遵循尽量不去改动已有的代码而是扩展出新的类然后调用新的类的原则",
      "典型的违反OCP的例子是大量的使用 if-else / switch-case 语句",
      "这给维护造成了极大的麻烦",
      "所以应对的方法是让客户端传入接口的不同子类型",
      "而在ADT中只需要统一的调用接口中共有的方法即可",
      "3.(LSP) The Liskov Substitution PrincipleLiskov ---- 替换原则",
      "子类型必须能够替换其基类型",
      "4.(DIP) The Dependency Inversion Principle -------- 依赖转置原则",
      "具体的模块应该依赖于抽象的模块",
      "但抽象的模块不应依赖于具体的模块",
      "5.(ISP) The Interface Segregation Principle ---------- 接口隔离原则",
      "大接口分解为多个小的接口",
      "5.2可维护性的设计模式",
      "1. Factory Method 工厂方法",
      "当client不知道要创建哪个具体类的实例",
      "或者不想在client代码中指明要具体创建的实例时",
      "用工厂方法",
      "定义一个用于创建对象的接口",
      "让其子类来决定实例化哪一个类",
      "从而使一个类的实例化延迟到其子类",
      "当然也可以通过直接定义静态工厂方法来创建子类实例",
      "2. Abstract Factory 抽象工厂",
      "当client需要的是多个具有固定搭配的类的组合",
      "如A和B两个系列的类",
      "A1搭配B1",
      "A2搭配B2",
      "于是",
      "就要用抽象工厂对其做一次封装",
      "定义一个用于创建对象的接口",
      "让其子类来决定实例化哪一组类",
      "从而使类与类之间的搭配对于client来说固定了",
      "本质上",
      "Abstract Factory是把多类产品的factory method组合在一起",
      "3. Proxy 代理模式",
      "某个对象比较“敏感”/“私密”/“贵重”",
      "不希望被client直接访问到",
      "故设置proxy",
      "在二者之间建立防火墙",
      "创建一个代理类",
      "它接受client的功能请求",
      "然后把功能请求转发 (delegate) 给实现类",
      "类似于Adapter模式",
      "4. Observer 观察者模式",
      "5. Visitor",
      "对特定类型的object的特定操作(visit)",
      "在运行时将二者动态绑定到一起",
      "该操作可以灵活更改",
      "无需更改被visit的类",
      "为ADT预留一个将来可扩展功能的“接入点”",
      "外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT",
      "本质上是将数据和作用于数据上的某种/些特定操作分离开来",
      "6. 共性和差异",
      "Proxy vs. Adaptor",
      "Adapter：目的是消除不兼容",
      "目的是B以客户端期望的统一的方式与A建立起联系",
      "Proxy：目的是隔离对复杂对象的访问",
      "降低难度/代价",
      "定位在“访问/使用行为”",
      "Visitor vs. Iterator",
      "Iterator：目的是以遍历的方式访问集合数据而无需暴露其内部表示",
      "将“遍历”这项功能delegate到外部的iterator对象",
      "Visitor： 在特定ADT上执行某种特定操作",
      "但该操作不在ADT内部实现",
      "而是delegate到独立的visitor对象",
      "客户端可灵活扩展/改变visitor的操作算法",
      "而不影响ADT",
      "Strategy vs. visitor",
      "同：二者都是通过delegation建立两个对象的动态联系",
      "Visitor：强调是的外部定义某种对ADT的操作",
      "该操作于ADT自身关系不大（只是访问ADT）",
      "故ADT内部只需要开放accept(visitor)即可",
      "client通过它设定visitor操作并在外部调用",
      "visitor是站在外部client的角度",
      "灵活增加对ADT的各种不同操作（哪怕ADT没实现该操作）",
      "Strategy：强调是对ADT内部某些要实现的功能的相应算法的灵活替换",
      "这些算法是ADT功能的重要组成部分",
      "只不过是delegate到外部strategy类而已",
      "strategy是站在内部ADT的角度",
      "灵活变化对其内部功能的不同配置",
      "6.正确性&健壮性",
      "6.正确性&健壮性",
      "6.1并发",
      "并发编程有两种模式：共享内存：在内存中读写共享数据",
      "某一时刻执行在不同处理器上的同一程序共享内存里的数据；消息传递：通过channel交换消息",
      "A把消息发给B",
      "B把执行结果发给A",
      "6.2线程安全",
      "1.Confinement",
      "限制数据共享",
      "将可变数据限制在单一线程内部",
      "不允许任何线程直接读写该数据",
      "核心思想：线程之间不共享mutable数据类型",
      "避免使用全局数据，而是使用局部数据",
      "如果使用全局的mutable的数据，就有可能造成竞争条件",
      "2. Immutability",
      "共享不可变数据",
      "使用不可变数据类型和不可变引用",
      "避免多线程之间的race condition",
      "因为不可变数据通常是线程安全的",
      "大家都只是读取它的值，而不能对它做出更改，所以它是线程安全的",
      "不可变类型要满足的条件：没有mutator方法",
      "所有的数据域都是private和final的",
      "没有表示泄露",
      "rep中的mutable的数据没有任何改变",
      "3.Using Threadsafe Data Types",
      "共享线程安全的可变数据",
      "如果必须要用mutable的数据类型在多线程之间共享数据",
      "要使用线程安全的数据类型",
      "在JDK中的类，文档中明确指明了是否threadsafe",
      "一般来说",
      "JDK同时提供两个相同功能的类",
      "一个是threadsafe",
      "另一个不是 (threadsafe的类一般性能上受影响)",
      "例如：StringBuffer vs. StringBuilder",
      "StringBuffer是线程安全的，可被安全的用于多线程",
      "StringBuilder是线程不安全的",
      "但它的运行速度要比StringBuffer更快",
      "4: Locks and Synchronization",
      "同步机制：通过锁的机制共享线程不安全的可变数据，变并行为串行",
      "6.3锁、同步",
      "6.3.1锁",
      "Lock是Java语言提供的内嵌机制",
      "在Java中，任何对象都可以作为锁",
      "可以创建一个没有意义的对象",
      "Object lock = new Object();作为锁来使用",
      "而拥有lock的线程可独占式的执行该部分代码",
      "6.3.2同步",
      "程序员来负责多线程之间对mutable数据的共享操作",
      "通过“同步”策略",
      "避免多线程同时访问数据",
      "使用锁机制",
      "获得对数据的独家mutation权",
      "其他线程被阻塞",
      "不得访问",
      "当A线程申请了A锁时",
      "它获得了对数据的独家修改访问权限",
      "B线程再想访问时",
      "就必须申请A锁的使用权限",
      "这就要等A线程执行结束释放锁时候再获得"
    ],
    "codes": [
      "Code-level",
      "Component-level",
      "Code-level",
      "Component-level",
      "Build-time",
      "Source code",
      "Interface-Class-Attribute-Method",
      "(Class Diagram)",
      "Package, File, Static Linking, Library, Test Case,",
      "Build Script (Component Diagram)",
      "Code Churn",
      "Configuration Item, Version",
      "Run-time",
      "Code Snapshot,",
      "Memory dump",
      "Package, Library, Dynamic linking, Configuration,",
      "Database, Middleware, Network,",
      "Hardware (Deployment Diagram)"
    ],
    "date": "2021-07-07",
    "text": "1.多维度视图与质量目标\n1.多维度视图与质量目标\n1.1 三维度八视图\nMoment\nPeriod\n, AST,\nExecution stack trace,\nConcurrent multi-threads\nProcedure Call Graph,\nMessage Graph (Sequence Diagram)\nEvent log, Multi-processes,\nDistributed processes\nProcedure Call Graph,\nMessage Graph (Sequence Diagram)\n1.2质量目标\n1.2.1五个关键的质量目标\n1.Elegant and beautiful code：代容易理解。\n2.Design for/with reuse：提高代码的可复用性。\n3.Low complexity：高内聚低耦合。\n4.Robustness and correctness：健壮性和正确性。\n5.Performance and efficiency：提升性能。\n1.2.2内部&外部质量因素\n内部：\n代码行数(LOC)、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小。\n外部：\nCorrectness（正确性），Robustness（鲁棒性），Extendibility（易扩展性）， Reusability（复用性），Compatibility（兼容性）， Efficiency（效率）， Portability（可移植性）， Ease of use（易用性），Functionality（功能性），Timeliness（时效性），Verifiability (可验证性)，Integrity (完整性)，Repairability (可修复性)，Economy (经济性)等。\n2.软件构造的过程与工具\n2.软件构造的过程与工具\n2.1 SCM,VCS,Git\n2.1.1 SCM(软件配置管理)\n软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被成为软件配置项(SCI)。\n当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。\n为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。\n2.1.2 VCM（版本控制系统）\nVCS分为三种：本地版本控制系统（无法协作）存储在本地、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。\n2.1.3Git\n指令：\n创建：git init\n暂存：git add <filename>\n提交：git commit -m “commit message”\n链接：git remote add origin <URL>\n推送：git push- u origin master\n创建分支：git checkout -b <branch name>\n切换分支：git checkout <branch name>\n合并分支：git merge <branch name>\n删除分支：git branch -d <branch name>\n注意，git的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。\n2.2 软件构造过程\n1. Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。\n2. Code review、Static code analysis：可以使用工具来发现bug，如CheckStyle, SpotBugs。\n3. Testing：测试，单元测试、集成测试、系统测试…\n4. Debugging：调试\n5. Dynamic code analysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分\n6. Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化\n7. Build：第2部分\n3.ADT&OOP\n3.ADT&OOP\n3.1 Spec\n3.1.1 Spec的结构\nprecondition前置条件：对客户端的约束，在使用方法时必须满足的条件\n使用@param annotation说明每个参数的前置条件\npostcondition后置条件：对开发者的约束，方法结束时必须满足的条件\n使用@return annotation说明后置条件\n抛出异常：\n使用@throws annotation说明出现异常的时候会发生什么\n在方法声明中使用static等关键字声明，可据此进行静态类型检查\n3.1.2 Spec的强弱\n更强的Spec：前置条件变弱，后置条件变强，强的Spec可以替换弱的。\n3.2 ADT\n3.2.1ADT的操作\nCreators构造器：用于使用 new 关键字创建一个新的对象。还有一种方法是静态方法，如Arrays.asList()、String.valueOf(Object Obj)等。\nProducers生产器：用于使用一个存在的对象产生一个新的对象，例如String.concat()就是使用已存在的字符串构造出一个新的对象，而且不会改动原先存在的对象。\nObservers观察器：不对数据做任何改动，只是查看一个已经存在的对象的各个值，如List.size()、所有的getter方法等。\nMutators变值器：用于改变对象属性的方法，如List.add()。mutator通常返回void，因为它不需要对外界做出反应，只是对ADT的数据域做了更改；mutator也可能返回非空，比如返回boolean表示修改成败等。\n3.2.2.设计ADT\n设计一个好的ADT需要靠开发者的经验来设计它的操作的spec，设计一个ADT要遵循下面三个原则：（1）设计简洁一致的操作（2）要足以支持client所需要的对数据的所有操作，且用操作的难度要低（3）要么抽象要么具体，不要混合——要么针对抽象设计，要么针对具体应用的设计。\n实现一个ADT的三个部分：specification、representation、implementation\nRepresentation Independence 表示独立性\nclient不应该知道内部的数据域是怎么实现的，最好client只能通过ADT提供的getter方法获得ADT存储的数据。\nclient使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。其目的一个是为了便于未来的升级和维护，当内部发生变化的时候不会影响到client。\n3.2.3测试ADT\n因为测试相当于client使用ADT，所以它也不能直接访问ADT内部的数据域，所以只能调用其他方法去测试被测试的方法。\n针对creator：构造对象之后，用observer去观察是否正确\n针对observer：用其他三类方法构造对象，然后调用被测observer，判断观察结果是否正确\n针对producer：produce新对象之后，用observer判断结果是否正确\nRep Invariant(RI) and Abstraction Function(AF)\nInvariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件\n两个空间 R 和 A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。\nAbstraction Function：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。\nRep Invariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。\n相同的R空间有肯能会有不同的RI。\n即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。\ncheckRep()：用于随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。\n表示泄露：client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。\n3.3 OOP\n3.3.1继承与重写\n子类可以继承父类的数据域和方法。\n严格继承：子类只能添加新方法，无法重写超类中的方法。原因：父类中的方法使用了final关键字限定。\n重写：子类的方法覆盖了父类的方法。重写的方法应该与父类方法有相同的签名，只有这样编译器才会判定为重写的方法。使用@Override annotation强制检查是否重写了超类中的方法。\n3.3.2 多态\n三种多态：特殊多态、参数化多态、子类型多态\n特殊多态：功能重载\n重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型。参数列表必须不同，返回值类型、可见性、异常均为可以相同也可不同。重载不仅可以发生在类内，也可发生在父类与子类之间。\n父类与子类之间发生重载的例子如下。这两个情况都不能编译成功，以为无论是a还是h，他们的运行时类型都是Animal，而不是通过new创建的具体类型。\n参数化多态：泛型\n使用泛型参数代替具体的类型。作为一个泛型接口，当实现的时候可以实现一个具有具体类型的子类型，也可以实现一个具有泛型接口的实现类。\n子类型多态\n终极目的：不同类型的对象可以统一处理而无需区分。\n遵循的设计原则：LSP\n4.复用\n4.复用\n4.1 四个复用层面\n1.源代码层面的复用\n可以在网络上寻找自己需要的代码，但要注意开发商用的软件不能直接复制开源的代码，避免引起法律纠纷。\n2.模块层面的复用\n通过继承 (Inheritance) 的方式复用父类的代码，同时也可override父类中已存在的方法。\n另一个复用的方法是 委托(delegation)，详见下一小节(4.2)。\n3.库层面的复用\n通过导入库来调用库中的API完成复用。除了导入本地库，也可以通过导入部署在网络上的库来完成复用，如 Web Services / Restful APIs\n4.架构层面的复用\n框架：一组具体类、抽象类、及其之间的连接关系。开发者可以根据spec填充自己的代码从而形成完整的系统。开发者根据Framework预留的接口所写的程序，而Framework作为主程序加以执行，执行过程中调用开发者所写的程序。关于框架详见下一小节4.2.3。\n黑盒框架：通过实现特定接口/delegation进行框架扩展\n白盒框架：通过代码层面的继承进行框架扩展\n4.2 LSP\n4.2.1LSP\nLiskov Substitution Principle中子类重写父类的方法应该满足的条件：\n编译器在静态类型检查时强制满足的条件\n子类型可以增加方法，但不可删除\n子类型需要实现抽象类型中的所有未实现方法\n子类型中重写的方法返回值必须与父类相同或符合co-variance(协变)\n子类型中重写的方法必须使用同样类型的参数或者符合contra-variance(逆变)的参数\n子类型中重写的方法不能抛出额外的异常\n还应该满足的条件\n更强的不变量 (RI)\n更弱的前置条件\n更强的后置条件\n关于返回值的类型，应该保持不变或者变得更具体，也就是与派生的方向一致。\n所抛出的异常的类型也是如此。\n4.2.2.4种委派方式\n1.Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。\n2.Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。\n3.Composition: 更强的association，但难以变化。\n4.Aggregation: 更弱的association，可动态变化。\n4.3.6种经典复用模式\n1.Adapter适配器模式\n目的是将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。\n因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。\n2.Decorator装饰器模式\n装饰器模式的原理是从接口派生出子类，然后在子类中定义一个父类接口然后将其作为delegation的对象，也就是说：\n自己到自己的委派\n。这里第一个自己指的是子类型本身，第二个自己是指该接口的其他子类，由于他们两个是同一个接口的子类，所以可以称为自己到自己的委派。\n3.Facade外观模式\n客户端在调用的API时候会以固定的方式调用一系列的方法，而为了简化客户端的使用，便于客户端的学习使用、解耦，所以需要\n提供一个统一的接口来取代一系列小接口调用，对复杂系统做了一个封装\n4.Strategy策略模式\n有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，\n利用delegation，运行时动态传入client倾向的算法类实例\n5.Template Method模板模式\n做事情的步骤一样，但具体方法不同，因此共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。\n在模板中，实现了一个固定执行一系列操作的方法，这个方法使用final关键字做了限定，不能再被子类重写，因此，子类只能通过重写该方法调用的那些尚未实现的方法。\n6.Iterator迭代器模式\n客户端希望遍历被放入容器/集合类的一组ADT对象，而无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式\n实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。\n5.可维护性\n5.可维护性\n5.1 SOLID设计原则\n1.(SRP) The Single Responsibility Principle --------- 单一责任原则\n尽可能地将功能分割，以达到\n不应该有多于一个原因让你的ADT发生变化\n的目的，否则就要拆分开。如果多个责任（功能）放在一个类中就有可能在未来某一个功能发生变化的时候影响到整个类，从而影响到整个程序的很大一部分实现（需要全部重新编译打包部署）。\n2.(OCP) The Open-Closed Principle ------------------- 开放-封闭原则\n在未来对功能进行修改或者扩展的时候，要遵循尽量不去改动已有的代码而是扩展出新的类然后调用新的类的原则。\n典型的违反OCP的例子是大量的使用 if-else / switch-case 语句，这给维护造成了极大的麻烦。所以应对的方法是让客户端传入接口的不同子类型，而在ADT中只需要统一的调用接口中共有的方法即可。\n3.(LSP) The Liskov Substitution PrincipleLiskov ---- 替换原则\n子类型必须能够替换其基类型。\n4.(DIP) The Dependency Inversion Principle -------- 依赖转置原则\n具体的模块应该依赖于抽象的模块，但抽象的模块不应依赖于具体的模块。\n5.(ISP) The Interface Segregation Principle ---------- 接口隔离原则\n大接口分解为多个小的接口。\n5.2可维护性的设计模式\n1. Factory Method 工厂方法\n当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。\n定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。\n当然也可以通过直接定义静态工厂方法来创建子类实例。\n2. Abstract Factory 抽象工厂\n当client需要的是多个具有固定搭配的类的组合，如A和B两个系列的类，A1搭配B1，A2搭配B2，于是，就要用抽象工厂对其做一次封装。\n定义一个用于创建对象的接口，让其子类来决定实例化哪一组类，从而使类与类之间的搭配对于client来说固定了。\n本质上，Abstract Factory是把多类产品的factory method组合在一起\n3. Proxy 代理模式\n某个对象比较“敏感”/“私密”/“贵重”，不希望被client直接访问到，故设置proxy，在二者之间建立防火墙。\n创建一个代理类，它接受client的功能请求，然后把功能请求转发 (delegate) 给实现类，类似于Adapter模式。\n4. Observer 观察者模式\n5. Visitor\n对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。\n为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT\n本质上是将数据和作用于数据上的某种/些特定操作分离开来。\n6. 共性和差异\nProxy vs. Adaptor\nAdapter：目的是消除不兼容，目的是B以客户端期望的统一的方式与A建立起联系。\nProxy：目的是隔离对复杂对象的访问，降低难度/代价，定位在“访问/使用行为”\nVisitor vs. Iterator\nIterator：目的是以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。\nVisitor： 在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT\nStrategy vs. visitor\n同：二者都是通过delegation建立两个对象的动态联系\nVisitor：强调是的外部定义某种对ADT的操作，该操作于ADT自身关系不大（只是访问ADT），故ADT内部只需要开放accept(visitor)即可，client通过它设定visitor操作并在外部调用。\nvisitor是站在外部client的角度，灵活增加对ADT的各种不同操作（哪怕ADT没实现该操作）。\nStrategy：强调是对ADT内部某些要实现的功能的相应算法的灵活替换。这些算法是ADT功能的重要组成部分，只不过是delegate到外部strategy类而已。\nstrategy是站在内部ADT的角度，灵活变化对其内部功能的不同配置。\n6.正确性&健壮性\n6.正确性&健壮性\n6.1并发\n并发编程有两种模式：\n共享内存：在内存中读写共享数据，某一时刻执行在不同处理器上的同一程序共享内存里的数据；\n消息传递：通过channel交换消息，A把消息发给B，B把执行结果发给A\n6.2线程安全\n1.Confinement\n限制数据共享，将可变数据限制在单一线程内部，不允许任何线程直接读写该数据。\n核心思想：线程之间不共享mutable数据类型。\n避免使用全局数据，而是使用局部数据。如果使用全局的mutable的数据，就有可能造成竞争条件。\n2. Immutability\n共享不可变数据，使用不可变数据类型和不可变引用，避免多线程之间的race condition，因为不可变数据通常是线程安全的。\n大家都只是读取它的值，而不能对它做出更改，所以它是线程安全的。\n不可变类型要满足的条件：\n没有mutator方法\n所有的数据域都是private和final的\n没有表示泄露\nrep中的mutable的数据没有任何改变\n3.Using Threadsafe Data Types\n共享线程安全的可变数据，如果必须要用mutable的数据类型在多线程之间共享数据，要使用线程安全的数据类型。\n在JDK中的类，文档中明确指明了是否threadsafe。\n一般来说，JDK同时提供两个相同功能的类，一个是threadsafe，另一个不是 (threadsafe的类一般性能上受影响)。例如：\nStringBuffer vs. StringBuilder\nStringBuffer是线程安全的，可被安全的用于多线程。\nStringBuilder是线程不安全的，但它的运行速度要比StringBuffer更快。\n4: Locks and Synchronization\n同步机制：通过锁的机制共享线程不安全的可变数据，变并行为串行。\n6.3锁、同步\n6.3.1锁\nLock是Java语言提供的内嵌机制。在Java中，任何对象都可以作为锁。可以创建一个没有意义的对象\nObject lock = new Object();\n作为锁来使用，而拥有lock的线程可独占式的执行该部分代码。\n6.3.2同步\n程序员来负责多线程之间对mutable数据的共享操作，通过“同步”策略，避免多线程同时访问数据。\n使用锁机制，获得对数据的独家mutation权，其他线程被阻塞，不得访问。\n当A线程申请了A锁时，它获得了对数据的独家修改访问权限，B线程再想访问时，就必须申请A锁的使用权限，这就要等A线程执行结束释放锁时候再获得。\n"
  },
  {
    "head": "浅谈Java的继承",
    "paragraphs": [
      "中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物，同理，波斯猫和巴厘猫继承自猫，这些动物之间会形成一个继承体系",
      "在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。",
      "继承的用法：",
      "在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。通过 extends 关键字让类与类之间产生继承关系。多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。多个类可以称为子类，单独这个类称为父类或者超类。",
      "注意事项：",
      "子类可以直接访问父类中的非私有的属性和行为。",
      "子类无法继承父类中私有的内容。",
      "父类怎么来的？共性不断向上抽取而来的。",
      "Java只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类。",
      "继承的优点：1.",
      "继承的出现提高了代码的复用性。",
      "继承的出现让类与类之间产生了关系，提供了多态的前提。",
      "继承的特点：1",
      "在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类，2",
      "多个类可以继承一个父类。3.",
      "在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。例如下面这种情况是允许的。4",
      "在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。"
    ],
    "sentences": [
      "中",
      "继承描述的是事物之间的所属关系",
      "通过继承可以使多种事物之间形成一种关系体系",
      "例如猫和狗都属于动物",
      "程序中便可以描述为猫和狗继承自动物",
      "同理",
      "波斯猫和巴厘猫继承自猫",
      "这些动物之间会形成一个继承体系",
      "在Java中",
      "类的继承是指在一个现有类的基础上去构建一个新的类",
      "构建出来的新类被称作子类",
      "现有类被称作父类",
      "子类会自动拥有父类所有可继承的属性和方法",
      "继承的用法：在程序中",
      "如果想声明一个类继承另一个类",
      "需要使用extends关键字",
      "通过 extends 关键字让类与类之间产生继承关系",
      "多个类中存在相同属性和行为时",
      "将这些内容抽取到单独一个类中",
      "那么多个类无需再定义这些属性和行为",
      "只要继承那个类即可",
      "多个类可以称为子类，单独这个类称为父类或者超类",
      "注意事项：子类可以直接访问父类中的非私有的属性和行为",
      "子类无法继承父类中私有的内容",
      "父类怎么来的？共性不断向上抽取而来的",
      "Java只支持单继承，不支持多继承",
      "一个类只能有一个父类，不可以有多个父类",
      "继承的优点：1.继承的出现提高了代码的复用性",
      "继承的出现让类与类之间产生了关系，提供了多态的前提",
      "继承的特点：1",
      "在Java中",
      "类只支持单继承",
      "不允许多重继承",
      "也就是说一个类只能有一个直接父类",
      "2",
      "多个类可以继承一个父类",
      "3.在Java中",
      "多层继承是可以的",
      "即一个类的父类可以再去继承另外的父类",
      "例如C类继承自B类",
      "而B类又可以去继承A类",
      "这时",
      "C类也可称作A类的子类",
      "例如下面这种情况是允许的",
      "4",
      "在Java中",
      "子类和父类是一种相对概念",
      "也就是说一个类是某个类父类的同时",
      "也可以是另一个类的子类"
    ],
    "codes": [
      "\nclass Person{\n    String name;\n    int age ;\n}\nclass Student extends Person{//此处运用了继承的思想，将class继承\n    void study(){\n        System.out.println(\"student study...\" + age);\n    }\n}\n\nclass ExtendDemo{\n    public static void main(String[] args){\n        Student s = new Student();\n        s. name = \"zhangsan\" ;\n        s. age = 20;\n        s.study();\n       \n    }\n\n}"
    ],
    "date": "2021-07-02",
    "text": "中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物，同理，波斯猫和巴厘猫继承自猫，这些动物之间会形成一个继承体系\n在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。\n继承的用法：\n在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。通过 extends 关键字让类与类之间产生继承关系。多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。多个类可以称为子类，单独这个类称为父类或者超类。\n注意事项：\n子类可以直接访问父类中的非私有的属性和行为。\n子类无法继承父类中私有的内容。\n父类怎么来的？共性不断向上抽取而来的。\nJava只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类。\n继承的优点：1.\n继承的出现提高了代码的复用性。\n继承的出现让类与类之间产生了关系，提供了多态的前提。\n继承的特点：1\n在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类，2\n多个类可以继承一个父类。3.\n在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。例如下面这种情况是允许的。4\n在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。\n"
  },
  {
    "head": "对于重载，重写的理解",
    "paragraphs": [
      "重载概念：",
      "在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。",
      "调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。",
      "重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。",
      "重载的规则：",
      "1）、必须具有不同的参数列表；",
      "2）、可以有不同的返回类型，只要参数列表不同就可以了；",
      "3）、可以有不同的访问修饰符；",
      "4）、可以抛出不同的异常；",
      "重载和重写（覆盖）的特点：",
      "Override 特点",
      "1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；",
      "2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；",
      "3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；",
      "4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。",
      "2.Overload 特点",
      "1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）；",
      "2、不能通过访问权限、返回类型、抛出的异常进行重载；",
      "3、方法的异常类型和数目不会对重载造成影响；",
      "4、对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。"
    ],
    "sentences": [
      "重载概念：在同一个类中",
      "允许存在一个以上的同名方法",
      "只要它们的参数个数或者参数类型不同即可",
      "方法重载是让类以统一的方式处理不同类型数据的一种手段",
      "多个同名函数同时存在，具有不同的参数个数/类型",
      "Java的方法重载",
      "就是在类中可以创建多个方法",
      "它们具有相同的名字",
      "但具有不同的参数和不同的定义",
      "调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性",
      "重载的时候",
      "方法名要一样",
      "但是参数类型和个数不一样",
      "返回值类型可以相同也可以不相同",
      "无法以返回型别作为重载函数的区分标准",
      "父类方法被默认修饰时",
      "只能在同一包中",
      "被其子类被重写",
      "如果不在同一包则不能重写",
      "重载的规则：1）、必须具有不同的参数列表；2）、可以有不同的返回类型",
      "只要参数列表不同就可以了；3）、可以有不同的访问修饰符；4）、可以抛出不同的异常；重载和重写（覆盖）的特点：Override 特点",
      "1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配",
      "才能达到覆盖的效果；2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致",
      "或者是其子类；4、被覆盖的方法不能为private",
      "否则在其子类中只是新定义了一个方法",
      "并没有对其进行覆盖",
      "2.Overload 特点",
      "1、在使用重载时只能通过不同的参数样式",
      "例如",
      "不同的参数类型",
      "不同的参数个数",
      "不同的参数顺序（当然",
      "同一方法内的几个参数类型必须不一样",
      "例如可以是fun(int, float)",
      " 但是不能为fun(int, int)）；2、不能通过访问权限、返回类型、抛出的异常进行重载；3、方法的异常类型和数目不会对重载造成影响；4、对于继承来说",
      "如果某一方法在父类中是访问权限是priavte",
      "那么就不能在子类对其进行重载",
      "如果定义的话",
      "也只是定义了一个新方法",
      "而不会达到重载的效果"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "重载概念：\n在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。\n调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。\n重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。\n重载的规则：\n1）、必须具有不同的参数列表；\n2）、可以有不同的返回类型，只要参数列表不同就可以了；\n3）、可以有不同的访问修饰符；\n4）、可以抛出不同的异常；\n重载和重写（覆盖）的特点：\nOverride 特点\n1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；\n2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；\n3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；\n4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。\n2.Overload 特点\n1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）；\n2、不能通过访问权限、返回类型、抛出的异常进行重载；\n3、方法的异常类型和数目不会对重载造成影响；\n4、对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。\n"
  },
  {
    "head": "类与对象的基本概念",
    "paragraphs": [
      "类与对象时整个面向对象中最基础的组成单元。",
      "类：是抽象的概念集合，表示的是一个共性的产物，类之中定义的是属性和行为（方法）；",
      "类是定义对象形式的模板，指定了数据以及操作数据的代码。",
      "Java中使用类的规范来构造对象，而对象是类的实例。",
      "类是逻辑抽象的，只有类的实例——对象才是内存中的物理表示。",
      "类一般都包含方法和变量，通过class创建类。",
      "对象：对象是一种个性的表示，表示一个独立的个体，每个对象拥有自己独立的属性，依靠属性来区分不同对象。",
      "对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：",
      "1.声明：声明一个对象，包括对象名称和对象类型。",
      "2.实例化：使用关键字 new 来创建一个对象。",
      "3.初始化：使用 new 创建对象时，会调用构造方法初始化对象。",
      "可以一句话来总结出类和对象的区别：类是对象的模板，对象是类的实例。类只有通过对象才可以使用，而在开发之中应该先产生类，之后再产生对象。类不能直接使用，对象是可以直接使用的。"
    ],
    "sentences": [
      "类与对象时整个面向对象中最基础的组成单元",
      "类：是抽象的概念集合",
      "表示的是一个共性的产物",
      "类之中定义的是属性和行为（方法）；类是定义对象形式的模板",
      "指定了数据以及操作数据的代码",
      "Java中使用类的规范来构造对象，而对象是类的实例",
      "类是逻辑抽象的，只有类的实例——对象才是内存中的物理表示",
      "类一般都包含方法和变量，通过class创建类",
      "对象：对象是一种个性的表示",
      "表示一个独立的个体",
      "每个对象拥有自己独立的属性",
      "依靠属性来区分不同对象",
      "对象是根据类创建的",
      "在Java中，使用关键字 new 来创建一个新的对象",
      "创建对象需要以下三步：1.声明：声明一个对象",
      "包括对象名称和对象类型",
      "2.实例化：使用关键字 new 来创建一个对象",
      "3.初始化：使用 new 创建对象时",
      "会调用构造方法初始化对象",
      "可以一句话来总结出类和对象的区别：类是对象的模板",
      "对象是类的实例",
      "类只有通过对象才可以使用",
      "而在开发之中应该先产生类",
      "之后再产生对象",
      "类不能直接使用，对象是可以直接使用的"
    ],
    "codes": [
      "//类由class创建\npublic  class  Person{\t\n    public  Person(){\n\t\tSystem.out.println(\"热烈庆祝中国共产党成立一百周年\");\n\t}\n\t\n}",
      "\npublic class Puppy{                \n   public String name_;\n   public Supper(String name)\n   {     \n      name_=name;\n   }\n   public static void main(String[] args)\n   {\n      Supper mySupper = new Supper( \"tommy\" );     // 这条语句将创建一个Puppy对象\n   }\n}"
    ],
    "date": "2021-06-30",
    "text": "类与对象时整个面向对象中最基础的组成单元。\n类：是抽象的概念集合，表示的是一个共性的产物，类之中定义的是属性和行为（方法）；\n类是定义对象形式的模板，指定了数据以及操作数据的代码。\nJava中使用类的规范来构造对象，而对象是类的实例。\n类是逻辑抽象的，只有类的实例——对象才是内存中的物理表示。\n类一般都包含方法和变量，通过class创建类。\n对象：对象是一种个性的表示，表示一个独立的个体，每个对象拥有自己独立的属性，依靠属性来区分不同对象。\n对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：\n1.声明：声明一个对象，包括对象名称和对象类型。\n2.实例化：使用关键字 new 来创建一个对象。\n3.初始化：使用 new 创建对象时，会调用构造方法初始化对象。\n可以一句话来总结出类和对象的区别：类是对象的模板，对象是类的实例。类只有通过对象才可以使用，而在开发之中应该先产生类，之后再产生对象。类不能直接使用，对象是可以直接使用的。\n"
  },
  {
    "head": "面向对象编程的特点",
    "paragraphs": [
      "对于初学Java的新手来说，Java的面向对象问题比较难理解，今天我就对此问题谈一谈自己所学到的知识。",
      "Java面向对象编程作为一种编程思想，有三大特性，封装，继承，多态。次三类特性可以说是决定面向对象编程的根本，只有对此概念有一定的理解，才能学好Java语言。",
      "1. 封装",
      "把客观事物封装成抽象的类，并且把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。也就是说，抽象数据类型对数据信息以及对数据的操作进行打包，将其变成一个不可分割的实体在这个实体内部，我们对数据进行隐藏和保密，只留下一些接口供外部调用。",
      "简而言之，一个类就是一个封装了数据以及操作代码的实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。",
      "封装类似于黑箱操作。一个具体复杂的对象有很多的属性和方法，有些需要公开，有些不需要公开，就好比一个具体的人的信息，有些是public，有些是private，而有些是protecred，别人问到的时候对于怎么样的信息都有不同的态度。根据与这个人的关系来回答问题，封装的结果是输出结果，不问过程。",
      "比如我们将一个房子看做是一个对象，里面的漂亮的装饰，也有实用的家具，这都是该房子的私有属性，但是家是属于私人的，不可以被他人随意观看或出入，封装就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设，同时不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。",
      "2.继承",
      "继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。在本职上是特殊和一般的关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。",
      "Java的继承属性避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围——在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。",
      "继承的原则：1.能够继承父类的public和protected成员变量，不能够继承父类的private11成员变量。2.对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承。3.对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。",
      "3.多态",
      "相比于封装和继承，Java多态是三大特性中比较难的一个，封装和继承最后归结于多态， 多态指的是类和类的关系，两个类由继承关系，存在有方法的重写，故而可以在调用时有父类引用指向子类对象。自己对于多态的理解还不够深刻，故而分享的不是很多，敬请见谅。"
    ],
    "sentences": [
      "对于初学Java的新手来说",
      "Java的面向对象问题比较难理解",
      "今天我就对此问题谈一谈自己所学到的知识",
      "Java面向对象编程作为一种编程思想",
      "有三大特性",
      "封装",
      "继承",
      "多态",
      "次三类特性可以说是决定面向对象编程的根本",
      "只有对此概念有一定的理解",
      "才能学好Java语言",
      "1. 封装",
      "把客观事物封装成抽象的类",
      "并且把自己的数据和方法只让可信的类或者对象操作",
      "对不可信的进行信息隐藏",
      "也就是说",
      "抽象数据类型对数据信息以及对数据的操作进行打包",
      "将其变成一个不可分割的实体在这个实体内部",
      "我们对数据进行隐藏和保密",
      "只留下一些接口供外部调用",
      "简而言之，一个类就是一个封装了数据以及操作代码的实体",
      "在一个对象内部",
      "某些代码或某些数据可以是私有的",
      "不能被外界访问",
      "通过这种方式",
      "对象对内部数据提供了不同级别的保护",
      "以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分",
      "封装隐藏了类的内部实现机制",
      "可以在不影响使用的情况下改变类的内部结构",
      "同时也保护了数据",
      "对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法",
      "封装类似于黑箱操作",
      "一个具体复杂的对象有很多的属性和方法",
      "有些需要公开",
      "有些不需要公开",
      "就好比一个具体的人的信息",
      "有些是public",
      "有些是private",
      "而有些是protecred",
      "别人问到的时候对于怎么样的信息都有不同的态度",
      "根据与这个人的关系来回答问题，封装的结果是输出结果，不问过程",
      "比如我们将一个房子看做是一个对象",
      "里面的漂亮的装饰",
      "也有实用的家具",
      "这都是该房子的私有属性",
      "但是家是属于私人的",
      "不可以被他人随意观看或出入",
      "封装就是存在那个遮挡的墙",
      "我们既能够有自己的隐私而且我们可以随意的更改里面的摆设",
      "同时不会影响到其他的",
      "但是如果没有门窗",
      "一个包裹的严严实实的黑盒子",
      "又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景",
      "所以说门窗就是房子对象留给外界访问的接口",
      "2.继承",
      "继承是从已有的类中派生出新的类",
      "新的类能吸收已有类的数据属性和行为",
      "并能扩展新的能力",
      "在本职上是特殊和一般的关系",
      "子类继承父类",
      "表明子类是一种特殊的父类",
      "并且具有父类所不具有的一些属性或方法",
      "从多种实现类中抽象出一个基类",
      "使其具备多种实现类的共同特性",
      "当实现类用extends关键字继承了基类（父类）后",
      "实现类就具备了这些相同的属性",
      "Java的继承属性避免了对一般类和特殊类之间共同特征进行的重复描述",
      "通过继承可以清晰地表达每一项共同特征所适应的概念范围——在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象",
      "运用继承原则使得系统模型比较简练也比较清晰",
      "继承的原则：1.能够继承父类的public和protected成员变量",
      "不能够继承父类的private11成员变量",
      "2.对于父类的包访问权限成员变量",
      "如果子类和父类在同一个包下",
      "则子类能够继承",
      "3.对于子类可以继承的父类成员变量",
      "如果在子类中出现了同名称的成员变量",
      "则会发生隐藏现象",
      "即子类的成员变量会屏蔽掉父类的同名成员变量",
      "如果要在子类中访问父类中同名成员变量",
      "需要使用super关键字来进行引用",
      "3.多态",
      "相比于封装和继承",
      "Java多态是三大特性中比较难的一个",
      "封装和继承最后归结于多态",
      " 多态指的是类和类的关系",
      "两个类由继承关系",
      "存在有方法的重写",
      "故而可以在调用时有父类引用指向子类对象",
      "自己对于多态的理解还不够深刻，故而分享的不是很多，敬请见谅"
    ],
    "codes": [],
    "date": "2021-06-23",
    "text": "对于初学Java的新手来说，Java的面向对象问题比较难理解，今天我就对此问题谈一谈自己所学到的知识。\nJava面向对象编程作为一种编程思想，有三大特性，封装，继承，多态。次三类特性可以说是决定面向对象编程的根本，只有对此概念有一定的理解，才能学好Java语言。\n1. 封装\n把客观事物封装成抽象的类，并且把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。也就是说，抽象数据类型对数据信息以及对数据的操作进行打包，将其变成一个不可分割的实体在这个实体内部，我们对数据进行隐藏和保密，只留下一些接口供外部调用。\n简而言之，一个类就是一个封装了数据以及操作代码的实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。\n封装类似于黑箱操作。一个具体复杂的对象有很多的属性和方法，有些需要公开，有些不需要公开，就好比一个具体的人的信息，有些是public，有些是private，而有些是protecred，别人问到的时候对于怎么样的信息都有不同的态度。根据与这个人的关系来回答问题，封装的结果是输出结果，不问过程。\n比如我们将一个房子看做是一个对象，里面的漂亮的装饰，也有实用的家具，这都是该房子的私有属性，但是家是属于私人的，不可以被他人随意观看或出入，封装就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设，同时不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。\n2.继承\n继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。在本职上是特殊和一般的关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。\nJava的继承属性避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围——在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。\n继承的原则：1.能够继承父类的public和protected成员变量，不能够继承父类的private11成员变量。2.对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承。3.对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。\n3.多态\n相比于封装和继承，Java多态是三大特性中比较难的一个，封装和继承最后归结于多态， 多态指的是类和类的关系，两个类由继承关系，存在有方法的重写，故而可以在调用时有父类引用指向子类对象。自己对于多态的理解还不够深刻，故而分享的不是很多，敬请见谅。\n"
  },
  {
    "head": "Java注释的简单理解",
    "paragraphs": [
      "每种编程语言的语法规范中都包含了注释的规则，从早期的C到近些年的Python大体上各种语言的注释要求都类似。良好的注释习惯会让别人很轻松地阅读你的代码，同时，也让自己的编程过程中的想法有了准确的记录，下面就我最近学习的Java语言，与大家分享一下我的理解。",
      "在Java中有3种类型的注释，分别是单行注释、多行注释和文档注释。",
      "1.单行注释",
      "单行注释的作用是注释一行代码。它是使用双斜线（//）标注的，注释的内容放在“//”的后面。",
      "2.多行注释",
      "如果我们想同时注释连续的多行代码，可以使用多个单行注释。但是这种方式太过繁琐，我们可以直接使用多行注释的方式。多行注释的作用是注释连续的多行内容。它把注释的内容放在“/*”开始，“*/”结束的区域内。这其中的一切内容均属于注释部分，不用做代码处理。",
      "3.文档注释",
      "单行注释和多行注释是大多数程序语言共有的，Java语言在二者之上还有自己独有的文档注释。文档注释的好处是将分离的代码和注释连接起来，保证代码与注释内容可以同时更新。除此之外，文档注释还可以生成API文档。",
      "文档注释以“/**”开始，“*/”结束，中间的内容全部都是文档注释。",
      "不过，要想保证代码与注释同时更新，仅使用“/** ”、“*/”这两个符号是不够的，还要使用到文档注释的标签，也可以称为“标记”。文档注释的标记是什么、完整的文档注释应该怎么编写、如何将文档注释生成API见“2.文档注释生成API文档”。下面是3种注释的示例。"
    ],
    "sentences": [
      "每种编程语言的语法规范中都包含了注释的规则",
      "从早期的C到近些年的Python大体上各种语言的注释要求都类似",
      "良好的注释习惯会让别人很轻松地阅读你的代码",
      "同时",
      "也让自己的编程过程中的想法有了准确的记录",
      "下面就我最近学习的Java语言",
      "与大家分享一下我的理解",
      "在Java中有3种类型的注释",
      "分别是单行注释、多行注释和文档注释",
      "1.单行注释",
      "单行注释的作用是注释一行代码",
      "它是使用双斜线（//）标注的，注释的内容放在“//”的后面",
      "2.多行注释",
      "如果我们想同时注释连续的多行代码，可以使用多个单行注释",
      "但是这种方式太过繁琐，我们可以直接使用多行注释的方式",
      "多行注释的作用是注释连续的多行内容",
      "它把注释的内容放在“/*”开始，“*/”结束的区域内",
      "这其中的一切内容均属于注释部分，不用做代码处理",
      "3.文档注释",
      "单行注释和多行注释是大多数程序语言共有的",
      "Java语言在二者之上还有自己独有的文档注释",
      "文档注释的好处是将分离的代码和注释连接起来",
      "保证代码与注释内容可以同时更新",
      "除此之外，文档注释还可以生成API文档",
      "文档注释以“/**”开始",
      "“*/”结束",
      "中间的内容全部都是文档注释",
      "不过",
      "要想保证代码与注释同时更新",
      "仅使用“/** ”、“*/”这两个符号是不够的",
      "还要使用到文档注释的标签",
      "也可以称为“标记”",
      "文档注释的标记是什么、完整的文档注释应该怎么编写、如何将文档注释生成API见“2.文档注释生成API文档”",
      "下面是3种注释的示例"
    ],
    "codes": [
      "//注释内容",
      "/* 多\n   行\n   注\n   释\n*/",
      "/**\n文档注释\n*/",
      "\npackage study._cqf;\n/**\n * 主题：Java中的注释\n *\n * @author Congqiufeng\n * \n */\n \npublic class study {\n\t/**\n\t * 【文档注释】\n\t * @param 字符串数组\n\t * @return void类型\n\t */\n\tpublic static void main(String[] args) {\n\t\t/*\n\t\t * 【多行注释】\n\t\t * System类字段out\n\t\t */\n\t\tSystem.out.println(\"Hello World!\");//【单行注释】输出内容为Hello World!\n\t}\n}\n\n"
    ],
    "date": "2021-07-04",
    "text": "每种编程语言的语法规范中都包含了注释的规则，从早期的C到近些年的Python大体上各种语言的注释要求都类似。良好的注释习惯会让别人很轻松地阅读你的代码，同时，也让自己的编程过程中的想法有了准确的记录，下面就我最近学习的Java语言，与大家分享一下我的理解。\n在Java中有3种类型的注释，分别是单行注释、多行注释和文档注释。\n1.单行注释\n单行注释的作用是注释一行代码。它是使用双斜线（//）标注的，注释的内容放在“//”的后面。\n2.多行注释\n如果我们想同时注释连续的多行代码，可以使用多个单行注释。但是这种方式太过繁琐，我们可以直接使用多行注释的方式。多行注释的作用是注释连续的多行内容。它把注释的内容放在“/*”开始，“*/”结束的区域内。这其中的一切内容均属于注释部分，不用做代码处理。\n3.文档注释\n单行注释和多行注释是大多数程序语言共有的，Java语言在二者之上还有自己独有的文档注释。文档注释的好处是将分离的代码和注释连接起来，保证代码与注释内容可以同时更新。除此之外，文档注释还可以生成API文档。\n文档注释以“/**”开始，“*/”结束，中间的内容全部都是文档注释。\n不过，要想保证代码与注释同时更新，仅使用“/** ”、“*/”这两个符号是不够的，还要使用到文档注释的标签，也可以称为“标记”。文档注释的标记是什么、完整的文档注释应该怎么编写、如何将文档注释生成API见“2.文档注释生成API文档”。下面是3种注释的示例。\n"
  },
  {
    "head": "软件构造复习笔记5",
    "paragraphs": [
      "OOP",
      "set.contains(list); //false!",
      "//甚至还有如下神奇的事情",
      "for(List l: set)",
      "set.contains(l); //false",
      "小心：如果某个mutable的对象包含在Set集合类中，当其发生改变后，集合类的行为不确定。",
      "在JDK中，不同的mutable类使用不同的等价性标准：",
      "Date.equals()、List.equals()实现的是观察等价性。",
      "StringBuilder.equals()实现的是行为等价性，它的equals()方法实际上是直接继承自Object类。",
      "equals()和hashCode()",
      "所以，对可变类型，实现行为等价性即可，也就是说，只有指向同样内存空间的对象才是相等的。所以对可变类型来说，无需重写这两个函数，直接继承Object的equals()和hashCode()即可。",
      "自动封装",
      "手动封装的结果：",
      "自动封装的结果：",
      "a.get(“c”) == b.get(“c”); //false，get获得的是Integer，并不会自动转换成原始的int",
      "a.get(“c”).equals(b.get(“c”)); //true",
      "特殊情况：",
      "Map<String, Integer> a = new HashMap<>(), b = new HashMap<>();",
      "原因：JVM为-128~127分配的空间位于常量池中，所以即使被自动封装成了对象类型也可以用==判断相等。",
      "/* 仅限于上面的方式创建的对象，通过new创建的对象不行 */",
      "Integer x = new Integer(2);",
      "Integer y = new Integer(2);"
    ],
    "sentences": [
      "OOP",
      "set.contains(list); //false!",
      "//甚至还有如下神奇的事情",
      "for(List l: set)",
      "set.contains(l); //false",
      "小心：如果某个mutable的对象包含在Set集合类中",
      "当其发生改变后",
      "集合类的行为不确定",
      "在JDK中",
      "不同的mutable类使用不同的等价性标准：Date.equals()、List.equals()实现的是观察等价性",
      "StringBuilder.equals()实现的是行为等价性",
      "它的equals()方法实际上是直接继承自Object类",
      "equals()和hashCode()",
      "所以",
      "对可变类型",
      "实现行为等价性即可",
      "也就是说",
      "只有指向同样内存空间的对象才是相等的",
      "所以对可变类型来说",
      "无需重写这两个函数",
      "直接继承Object的equals()和hashCode()即可",
      "自动封装",
      "手动封装的结果：自动封装的结果：a.get(“c”) == b.get(“c”); //false",
      "get获得的是Integer",
      "并不会自动转换成原始的int",
      "a.get(“c”).equals(b.get(“c”)); //true",
      "特殊情况：Map<String, Integer> a = new HashMap<>(), b = new HashMap<>();原因：JVM为-128~127分配的空间位于常量池中",
      "所以即使被自动封装成了对象类型也可以用==判断相等",
      "/* 仅限于上面的方式创建的对象",
      "通过new创建的对象不行 */",
      "Integer x = new Integer(2);Integer y = new Integer(2);"
    ],
    "codes": [
      "Integer x = new Integer(3);",
      "Integer y = new Integer(3);",
      "x.equals(y); //true",
      "x == y; //false",
      "(int) x == (int) y; //true",
      "Map<String, Integer> a = new HashMap<>(), b = new HashMap<>();",
      "a.put(“c”, 130); //被自动转换成了Integer",
      "b.put(“c”, 130);",
      "a.put(“c”, 1);",
      "b.put(“c”, 1);",
      "a.get(“a”) == b.get(“a”); //true",
      "Integer x = 2;",
      "Integer y = 2;",
      "x == y; //true"
    ],
    "date": "2021-07-07",
    "text": "OOP\nset.contains(list); //false!\n//甚至还有如下神奇的事情\nfor(List l: set)\nset.contains(l); //false\n小心：如果某个mutable的对象包含在Set集合类中，当其发生改变后，集合类的行为不确定。\n在JDK中，不同的mutable类使用不同的等价性标准：\nDate.equals()、List.equals()实现的是观察等价性。\nStringBuilder.equals()实现的是行为等价性，它的equals()方法实际上是直接继承自Object类。\nequals()和hashCode()\n所以，对可变类型，实现行为等价性即可，也就是说，只有指向同样内存空间的对象才是相等的。所以对可变类型来说，无需重写这两个函数，直接继承Object的equals()和hashCode()即可。\n自动封装\n手动封装的结果：\n自动封装的结果：\na.get(“c”) == b.get(“c”); //false，get获得的是Integer，并不会自动转换成原始的int\na.get(“c”).equals(b.get(“c”)); //true\n特殊情况：\nMap<String, Integer> a = new HashMap<>(), b = new HashMap<>();\n原因：JVM为-128~127分配的空间位于常量池中，所以即使被自动封装成了对象类型也可以用==判断相等。\n/* 仅限于上面的方式创建的对象，通过new创建的对象不行 */\nInteger x = new Integer(2);\nInteger y = new Integer(2);\n"
  },
  {
    "head": "软件构造复习笔记4",
    "paragraphs": [
      "数据类型与类型检验",
      "编程语言的数据类型",
      "在Java中，数据类型分为基本数据类型(int、boolean、char等)和对象数据类型(String、Integer等)。所有的基本数据类型都是Immutable的，而且在栈中分配内存，代价也比较低。而对象数据类型有的是Immutable的，有的是Mutable的，分配的内存都在堆中，代价相对昂贵。因此在能使用基本类型的情况下尽量使用基本数据类型，降低代价。",
      "对象数据类型是OOP的核心，由于对象数据类型存在继承(extends)机制，因此在OOP中可以更好的复用代码。",
      "基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。",
      "2. 类型检查",
      "静态类型语言可执行静态类型检查，在编译阶段进行类型检查，这意味着避免了将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误都可以在静态类型检查时发现；动态类型语言(python)只有动态类型检查，在运行阶段才会进行类型检查，例如非法的参数值 (最典型的NULL引用)、非法的返回值、越界等等。（简言之编程时就会报错）",
      "静态类型检查是关于数据类型的检查，它不会关心具体的值，而动态类型检查是关于值的检查。",
      "例如int n=1.1在静态类型检查的时候就会报错，但double a=0; double b=2/a;只有在运行之后，执行动态类型检查的时候才会报告除零错。",
      "3.关于不可变性",
      "改变变量：使变量指向存储着另一个值的空间",
      "改变变量的值：变量指向的空间不变，变化的是存储的内容。",
      "Immutability：不变性，一个重要的设计原则，设计ADT时尽量保证这个原则。",
      "Immutable types：不可变的数据类型，当实例对象被创建以后，该对象的值就不可变化了，也就是该ADT中不能有mutator方法。",
      "在编写程序的时候使用final关键字可以保证该变量不可再被改变，但不能保证该变量的值不变。所以，尽量使用final变量作为方法的输入参数、作为局部变量。",
      "final类无法派生子类",
      "final变量无法改变值/引用",
      "final方无法被子类override(重写)",
      "比较immutable和mutable",
      "不变对象：一旦被创建，始终指向同一个值/引用",
      "可变对象：拥有方法可以修改自己的值/引用",
      "可变对象的优点：虽然mutable类型由于指向的是同一个存储区域，所以更改对象的内容后会在意想不到的位置产生意想不到的变化，所以更推荐使用Imutable的数据类型，但是使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，比如依次将 ‘a’~‘z’ 连接到一个空字符串上，就会产生25个临时拷贝，而使用可变类型则最少化拷贝以提高效率。",
      "使用可变数据类型，可获得更好的性能。但是在质量指标中，性能的优先级较低，所以即使mutable类型有这个优点也更倾向于选择imutable的类型。",
      "也适合于在多个模块之间共享数据。在这里强烈不推荐使用Global variables。",
      "设计规范",
      "为什么要写注释？",
      "因为单靠代码自己无法把开发者的设计决策全部清晰直观地表现出来，如 final 关键字本身就是一种设计决策，开发者很容易理解，但这个的只要目的不是为了给人读，是为了给编译器读，如果未来程序员对这个部分做了什么改动，编译器可以很快的在静态代码分析中就能发现错误，避免错误带入后面的开发中，而只有注释，才能够让其他人清晰的看到这部分干了什么，甚至是怎么实现的等等信息。",
      "为什么要写spec？",
      "spec是程序员自己对所写的方法的规约，它规定了方法应该做什么，不应该做什么，有了spec就可以编写测试用例了，因为程序员所编写的代码必定是符合spec的，否则就是不合格的，符合spec的代码也必然能通过根据spec所设计出的测试。同时，有了spec，客户端在使用所写的代码时就有所依据，客户端可以轻松的知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，而不必知道内部逻辑是怎么样的，大大节省了客户端使用自己的API时所需要的时间，并且大大降低了客户端对自己所编写的代码的误解。",
      "而且，拥有精确的spec，有助于区分责任，很容易地就可以找到是哪一部分的代码出了问题。",
      "最后，由于客户端并不需要了解内部的实现也就意味着你可以在满足spec的大前期下对实现方法进行任意的改动而不需要告知客户端，因为无论你怎么改，只要满足spec，在客户端看来，你的行为 (作用) 都是相同的。",
      "spec的结构",
      "precondition前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "使用@param annotation说明每个参数的前置条件",
      "postcondition后置条件：对开发者的约束，方法结束时必须满足的条件",
      "使用@return annotation说明后置条件",
      "使用@throws annotation说明出现异常的时候会发生什么",
      "在方法声明中使用static等关键字声明，可据此进行静态类型检查",
      "当客户端满足前置条件的时候，结果必须满足后置条件；当前置条件不满足的时候，方法内部可以做任何事情，但作为开发者，应该尽量让程序做到fail fast。",
      "spec不能有什么？",
      "spec不能暴露实现细节，不应该暴露局部变量，也不应该暴露私有的数据域，这些东西一旦暴露，就有可能给被非法的程序员利用，发现漏洞并实施攻击。",
      "注意：方法不应该改变输入参数的取值，如果改了，则必须在spec中做出说明。所以不推荐使用mutable的对象。另外，我们无法强迫类的实现体和客户端不保存可变变量的“别名”，因此，如果直接返回本来的mutable对象，客户端可能修改它的值造成内部实现的错误，同样，如果返回了的是原来mutable对象的拷贝，虽然内部不用再担心客户端的更改影响到自己，但客户端无法知道内部是否保留了被返回的拷贝的别名，因此双方无法完全的信任彼此，故而不推荐使用mutable类作为返回值类型。",
      "spec的评判标准",
      "评判哪个规约更好的三个方面：规约的确定性、规约的陈述性、规约的强度",
      "重点是规约的强度的判断，spec变强的要求是更宽松的前置条件+更严格的后置条件，在这种情况下，就可以用变强了的spec去替换原来的spec。越强的规约，意味着实现者的自由度和责任越重，而客户的责任越轻。",
      "强的spec可以替换弱的spec，这一点会在第4章的LSP中得到应用",
      "用椭圆表示spec的强度",
      "如下图，大椭圆表示更弱的spec，小椭圆表示更强的spec，椭圆的大小表示的是开发者的自由度，小椭圆有更强的后置和更弱的前置，因此所包含的结果的点就少，所以就小。",
      "ADT",
      "ADT的操作",
      "Creators构造器：用于使用 new 关键字创建一个新的对象。还有一种方法是静态方法，如Arrays.asList()、String.valueOf(Object Obj)等。",
      "Producers生产器：用于使用一个存在的对象产生一个新的对象，例如String.concat()就是使用已存在的字符串构造出一个新的对象，而且不会改动原先存在的对象。",
      "Observers观察器：不对数据做任何改动，只是查看一个已经存在的对象的各个值，如List.size()、所有的getter方法等。",
      "Mutators变值器：用于改变对象属性的方法，如List.add()。mutator通常返回void，因为它不需要对外界做出反应，只是对ADT的数据域做了更改；mutator也可能返回非空，比如返回boolean表示修改成败等。",
      "设计ADT",
      "设计一个好的ADT需要靠开发者的经验来设计它的操作的spec，设计一个ADT要遵循下面三个原则：（1）设计简洁一致的操作（2）要足以支持client所需要的对数据的所有操作，且用操作的难度要低（3）要么抽象要么具体，不要混合——要么针对抽象设计，要么针对具体应用的设计。",
      "实现一个ADT的三个部分：specification、representation、implementation",
      "Representation Independence 表示独立性",
      "client不应该知道内部的数据域是怎么实现的，最好client只能通过ADT提供的getter方法获得ADT存储的数据。",
      "client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。其目的一个是为了便于未来的升级和维护，当内部发生变化的时候不会影响到client。",
      "测试ADT",
      "因为测试相当于client使用ADT，所以它也不能直接访问ADT内部的数据域，所以只能调用其他方法去测试被测试的方法。",
      "针对creator：构造对象之后，用observer去观察是否正确",
      "针对observer：用其他三类方法构造对象，然后调用被测observer，判断观察结果是否正确",
      "针对producer：produce新对象之后，用observer判断结果是否正确",
      "Rep Invariant(RI) and Abstraction Function(AF)",
      "Invariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件",
      "两个空间 R 和 A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。",
      "Abstraction Function：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。",
      "Rep Invariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。",
      "相同的R空间有肯能会有不同的RI。",
      "即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。",
      "checkRep()：用于随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。",
      "表示泄露：client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。",
      "Documenting the AF, RI, and Safety from Rep Exposure",
      "在代码中用注释的形式记录AF（如何解释每个R值）和RI（rep中哪些数据是有效的）。"
    ],
    "sentences": [
      "数据类型与类型检验",
      "编程语言的数据类型",
      "在Java中",
      "数据类型分为基本数据类型(int、boolean、char等)和对象数据类型(String、Integer等)",
      "所有的基本数据类型都是Immutable的",
      "而且在栈中分配内存",
      "代价也比较低",
      "而对象数据类型有的是Immutable的",
      "有的是Mutable的",
      "分配的内存都在堆中",
      "代价相对昂贵",
      "因此在能使用基本类型的情况下尽量使用基本数据类型，降低代价",
      "对象数据类型是OOP的核心",
      "由于对象数据类型存在继承(extends)机制",
      "因此在OOP中可以更好的复用代码",
      "基本类型被包装为对象类型",
      "通常只有在定义集合的时候使用",
      "其他情况下尽量避免使用",
      "基本类型和对象类型之间一般可以自动转换",
      "2. 类型检查",
      "静态类型语言可执行静态类型检查",
      "在编译阶段进行类型检查",
      "这意味着避免了将错误带入到运行阶段",
      "可以提高程序的正确性/健壮性",
      "例如语法错误、类名/函数名错误",
      "参数类型或数目错误、返回值类型错误都可以在静态类型检查时发现；动态类型语言(python)只有动态类型检查",
      "在运行阶段才会进行类型检查",
      "例如非法的参数值 (最典型的NULL引用)、非法的返回值、越界等等",
      "（简言之编程时就会报错）",
      "静态类型检查是关于数据类型的检查",
      "它不会关心具体的值",
      "而动态类型检查是关于值的检查",
      "例如int n=1.1在静态类型检查的时候就会报错",
      "但double a=0; double b=2/a;只有在运行之后",
      "执行动态类型检查的时候才会报告除零错",
      "3.关于不可变性",
      "改变变量：使变量指向存储着另一个值的空间",
      "改变变量的值：变量指向的空间不变，变化的是存储的内容",
      "Immutability：不变性",
      "一个重要的设计原则",
      "设计ADT时尽量保证这个原则",
      "Immutable types：不可变的数据类型",
      "当实例对象被创建以后",
      "该对象的值就不可变化了",
      "也就是该ADT中不能有mutator方法",
      "在编写程序的时候使用final关键字可以保证该变量不可再被改变",
      "但不能保证该变量的值不变",
      "所以，尽量使用final变量作为方法的输入参数、作为局部变量",
      "final类无法派生子类",
      "final变量无法改变值/引用",
      "final方无法被子类override(重写)",
      "比较immutable和mutable",
      "不变对象：一旦被创建，始终指向同一个值/引用",
      "可变对象：拥有方法可以修改自己的值/引用",
      "可变对象的优点：虽然mutable类型由于指向的是同一个存储区域",
      "所以更改对象的内容后会在意想不到的位置产生意想不到的变化",
      "所以更推荐使用Imutable的数据类型",
      "但是使用不可变类型",
      "对其频繁修改会产生大量的临时拷贝(需要垃圾回收)",
      "比如依次将 ‘a’~‘z’ 连接到一个空字符串上",
      "就会产生25个临时拷贝",
      "而使用可变类型则最少化拷贝以提高效率",
      "使用可变数据类型，可获得更好的性能",
      "但是在质量指标中",
      "性能的优先级较低",
      "所以即使mutable类型有这个优点也更倾向于选择imutable的类型",
      "也适合于在多个模块之间共享数据",
      "在这里强烈不推荐使用Global variables",
      "设计规范",
      "为什么要写注释？",
      "因为单靠代码自己无法把开发者的设计决策全部清晰直观地表现出来",
      "如 final 关键字本身就是一种设计决策",
      "开发者很容易理解",
      "但这个的只要目的不是为了给人读",
      "是为了给编译器读",
      "如果未来程序员对这个部分做了什么改动",
      "编译器可以很快的在静态代码分析中就能发现错误",
      "避免错误带入后面的开发中",
      "而只有注释",
      "才能够让其他人清晰的看到这部分干了什么",
      "甚至是怎么实现的等等信息",
      "为什么要写spec？",
      "spec是程序员自己对所写的方法的规约",
      "它规定了方法应该做什么",
      "不应该做什么",
      "有了spec就可以编写测试用例了",
      "因为程序员所编写的代码必定是符合spec的",
      "否则就是不合格的",
      "符合spec的代码也必然能通过根据spec所设计出的测试",
      "同时",
      "有了spec",
      "客户端在使用所写的代码时就有所依据",
      "客户端可以轻松的知道他需要为这个方法提供什么样的参数",
      "以及会得到什么样的结果",
      "而不必知道内部逻辑是怎么样的",
      "大大节省了客户端使用自己的API时所需要的时间",
      "并且大大降低了客户端对自己所编写的代码的误解",
      "而且",
      "拥有精确的spec",
      "有助于区分责任",
      "很容易地就可以找到是哪一部分的代码出了问题",
      "最后",
      "由于客户端并不需要了解内部的实现也就意味着你可以在满足spec的大前期下对实现方法进行任意的改动而不需要告知客户端",
      "因为无论你怎么改",
      "只要满足spec",
      "在客户端看来",
      "你的行为 (作用) 都是相同的",
      "spec的结构",
      "precondition前置条件：对客户端的约束",
      "在使用方法时必须满足的条件",
      "使用@param annotation说明每个参数的前置条件",
      "postcondition后置条件：对开发者的约束",
      "方法结束时必须满足的条件",
      "使用@return annotation说明后置条件",
      "使用@throws annotation说明出现异常的时候会发生什么",
      "在方法声明中使用static等关键字声明",
      "可据此进行静态类型检查",
      "当客户端满足前置条件的时候",
      "结果必须满足后置条件；当前置条件不满足的时候",
      "方法内部可以做任何事情",
      "但作为开发者",
      "应该尽量让程序做到fail fast",
      "spec不能有什么？",
      "spec不能暴露实现细节",
      "不应该暴露局部变量",
      "也不应该暴露私有的数据域",
      "这些东西一旦暴露",
      "就有可能给被非法的程序员利用",
      "发现漏洞并实施攻击",
      "注意：方法不应该改变输入参数的取值",
      "如果改了",
      "则必须在spec中做出说明",
      "所以不推荐使用mutable的对象",
      "另外",
      "我们无法强迫类的实现体和客户端不保存可变变量的“别名”",
      "因此",
      "如果直接返回本来的mutable对象",
      "客户端可能修改它的值造成内部实现的错误",
      "同样",
      "如果返回了的是原来mutable对象的拷贝",
      "虽然内部不用再担心客户端的更改影响到自己",
      "但客户端无法知道内部是否保留了被返回的拷贝的别名",
      "因此双方无法完全的信任彼此",
      "故而不推荐使用mutable类作为返回值类型",
      "spec的评判标准",
      "评判哪个规约更好的三个方面：规约的确定性、规约的陈述性、规约的强度",
      "重点是规约的强度的判断",
      "spec变强的要求是更宽松的前置条件+更严格的后置条件",
      "在这种情况下",
      "就可以用变强了的spec去替换原来的spec",
      "越强的规约，意味着实现者的自由度和责任越重，而客户的责任越轻",
      "强的spec可以替换弱的spec",
      "这一点会在第4章的LSP中得到应用",
      "用椭圆表示spec的强度",
      "如下图",
      "大椭圆表示更弱的spec",
      "小椭圆表示更强的spec",
      "椭圆的大小表示的是开发者的自由度",
      "小椭圆有更强的后置和更弱的前置",
      "因此所包含的结果的点就少",
      "所以就小",
      "ADT",
      "ADT的操作",
      "Creators构造器：用于使用 new 关键字创建一个新的对象",
      "还有一种方法是静态方法",
      "如Arrays.asList()、String.valueOf(Object Obj)等",
      "Producers生产器：用于使用一个存在的对象产生一个新的对象",
      "例如String.concat()就是使用已存在的字符串构造出一个新的对象",
      "而且不会改动原先存在的对象",
      "Observers观察器：不对数据做任何改动",
      "只是查看一个已经存在的对象的各个值",
      "如List.size()、所有的getter方法等",
      "Mutators变值器：用于改变对象属性的方法",
      "如List.add()",
      "mutator通常返回void",
      "因为它不需要对外界做出反应",
      "只是对ADT的数据域做了更改；mutator也可能返回非空",
      "比如返回boolean表示修改成败等",
      "设计ADT",
      "设计一个好的ADT需要靠开发者的经验来设计它的操作的spec",
      "设计一个ADT要遵循下面三个原则：（1）设计简洁一致的操作（2）要足以支持client所需要的对数据的所有操作",
      "且用操作的难度要低（3）要么抽象要么具体",
      "不要混合——要么针对抽象设计",
      "要么针对具体应用的设计",
      "实现一个ADT的三个部分：specification、representation、implementation",
      "Representation Independence 表示独立性",
      "client不应该知道内部的数据域是怎么实现的",
      "最好client只能通过ADT提供的getter方法获得ADT存储的数据",
      "client使用ADT时无需考虑其内部如何实现",
      "ADT内部表示的变化不应影响外部spec和客户端",
      "其目的一个是为了便于未来的升级和维护",
      "当内部发生变化的时候不会影响到client",
      "测试ADT",
      "因为测试相当于client使用ADT",
      "所以它也不能直接访问ADT内部的数据域",
      "所以只能调用其他方法去测试被测试的方法",
      "针对creator：构造对象之后",
      "用observer去观察是否正确",
      "针对observer：用其他三类方法构造对象",
      "然后调用被测observer",
      "判断观察结果是否正确",
      "针对producer：produce新对象之后",
      "用observer判断结果是否正确",
      "Rep Invariant(RI) and Abstraction Function(AF)",
      "Invariants：不变量",
      "与程序运行无关",
      "在任何时候都应该满足的一些条件",
      "两个空间 R 和 A：R空间是ADT的内部表示的空间",
      "A空间是ADT能够表示的存在于实际当中的对象",
      "ADT的开发者关注的是R空间，client关注的是A空间",
      "Abstraction Function：从R空间到A空间存在一个映射",
      "这个映射是一个满射",
      "这个映射将R中的每一个值解释为A中的一个值",
      "这个解释函数就是AF",
      "Rep Invariant：这是一个集合",
      "是R空间所有值的子集",
      "它包含了所有合法的表示值",
      "而只有满足RI的值",
      "才是合法值",
      "才会在A空间内有值与其对应",
      "相同的R空间有肯能会有不同的RI",
      "即使是同样的R、同样的RI",
      "也可能有不同的AF",
      "即“解释不同”",
      "checkRep()：用于随时检查RI是否满足",
      "使用assert检查RI",
      "在所有的方法最好都加入调用这个检查方法",
      "checkRep()在检查时有可能耗费大量的时间影响性能",
      "所以只需要在开发阶段保留这部分",
      "表示泄露：client可以拿到数据域的本身或别名",
      "一旦表示泄露",
      "client就有可能无意间改动数据",
      "而如果在设计中",
      "要求一个ADT是Immutable的",
      "而如果它出现了表示泄露",
      "就有可能违反Immutable的原则",
      "Documenting the AF, RI, and Safety from Rep Exposure",
      "在代码中用注释的形式记录AF（如何解释每个R值）和RI（rep中哪些数据是有效的）"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "数据类型与类型检验\n编程语言的数据类型\n在Java中，数据类型分为基本数据类型(int、boolean、char等)和对象数据类型(String、Integer等)。所有的基本数据类型都是Immutable的，而且在栈中分配内存，代价也比较低。而对象数据类型有的是Immutable的，有的是Mutable的，分配的内存都在堆中，代价相对昂贵。因此在能使用基本类型的情况下尽量使用基本数据类型，降低代价。\n对象数据类型是OOP的核心，由于对象数据类型存在继承(extends)机制，因此在OOP中可以更好的复用代码。\n基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。\n2. 类型检查\n静态类型语言可执行静态类型检查，在编译阶段进行类型检查，这意味着避免了将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误都可以在静态类型检查时发现；动态类型语言(python)只有动态类型检查，在运行阶段才会进行类型检查，例如非法的参数值 (最典型的NULL引用)、非法的返回值、越界等等。（简言之编程时就会报错）\n静态类型检查是关于数据类型的检查，它不会关心具体的值，而动态类型检查是关于值的检查。\n例如int n=1.1在静态类型检查的时候就会报错，但double a=0; double b=2/a;只有在运行之后，执行动态类型检查的时候才会报告除零错。\n3.关于不可变性\n改变变量：使变量指向存储着另一个值的空间\n改变变量的值：变量指向的空间不变，变化的是存储的内容。\nImmutability：不变性，一个重要的设计原则，设计ADT时尽量保证这个原则。\nImmutable types：不可变的数据类型，当实例对象被创建以后，该对象的值就不可变化了，也就是该ADT中不能有mutator方法。\n在编写程序的时候使用final关键字可以保证该变量不可再被改变，但不能保证该变量的值不变。所以，尽量使用final变量作为方法的输入参数、作为局部变量。\nfinal类无法派生子类\nfinal变量无法改变值/引用\nfinal方无法被子类override(重写)\n比较immutable和mutable\n不变对象：一旦被创建，始终指向同一个值/引用\n可变对象：拥有方法可以修改自己的值/引用\n可变对象的优点：虽然mutable类型由于指向的是同一个存储区域，所以更改对象的内容后会在意想不到的位置产生意想不到的变化，所以更推荐使用Imutable的数据类型，但是使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，比如依次将 ‘a’~‘z’ 连接到一个空字符串上，就会产生25个临时拷贝，而使用可变类型则最少化拷贝以提高效率。\n使用可变数据类型，可获得更好的性能。但是在质量指标中，性能的优先级较低，所以即使mutable类型有这个优点也更倾向于选择imutable的类型。\n也适合于在多个模块之间共享数据。在这里强烈不推荐使用Global variables。\n设计规范\n为什么要写注释？\n因为单靠代码自己无法把开发者的设计决策全部清晰直观地表现出来，如 final 关键字本身就是一种设计决策，开发者很容易理解，但这个的只要目的不是为了给人读，是为了给编译器读，如果未来程序员对这个部分做了什么改动，编译器可以很快的在静态代码分析中就能发现错误，避免错误带入后面的开发中，而只有注释，才能够让其他人清晰的看到这部分干了什么，甚至是怎么实现的等等信息。\n为什么要写spec？\nspec是程序员自己对所写的方法的规约，它规定了方法应该做什么，不应该做什么，有了spec就可以编写测试用例了，因为程序员所编写的代码必定是符合spec的，否则就是不合格的，符合spec的代码也必然能通过根据spec所设计出的测试。同时，有了spec，客户端在使用所写的代码时就有所依据，客户端可以轻松的知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，而不必知道内部逻辑是怎么样的，大大节省了客户端使用自己的API时所需要的时间，并且大大降低了客户端对自己所编写的代码的误解。\n而且，拥有精确的spec，有助于区分责任，很容易地就可以找到是哪一部分的代码出了问题。\n最后，由于客户端并不需要了解内部的实现也就意味着你可以在满足spec的大前期下对实现方法进行任意的改动而不需要告知客户端，因为无论你怎么改，只要满足spec，在客户端看来，你的行为 (作用) 都是相同的。\nspec的结构\nprecondition前置条件：对客户端的约束，在使用方法时必须满足的条件\n使用@param annotation说明每个参数的前置条件\npostcondition后置条件：对开发者的约束，方法结束时必须满足的条件\n使用@return annotation说明后置条件\n使用@throws annotation说明出现异常的时候会发生什么\n在方法声明中使用static等关键字声明，可据此进行静态类型检查\n当客户端满足前置条件的时候，结果必须满足后置条件；当前置条件不满足的时候，方法内部可以做任何事情，但作为开发者，应该尽量让程序做到fail fast。\nspec不能有什么？\nspec不能暴露实现细节，不应该暴露局部变量，也不应该暴露私有的数据域，这些东西一旦暴露，就有可能给被非法的程序员利用，发现漏洞并实施攻击。\n注意：方法不应该改变输入参数的取值，如果改了，则必须在spec中做出说明。所以不推荐使用mutable的对象。另外，我们无法强迫类的实现体和客户端不保存可变变量的“别名”，因此，如果直接返回本来的mutable对象，客户端可能修改它的值造成内部实现的错误，同样，如果返回了的是原来mutable对象的拷贝，虽然内部不用再担心客户端的更改影响到自己，但客户端无法知道内部是否保留了被返回的拷贝的别名，因此双方无法完全的信任彼此，故而不推荐使用mutable类作为返回值类型。\nspec的评判标准\n评判哪个规约更好的三个方面：规约的确定性、规约的陈述性、规约的强度\n重点是规约的强度的判断，spec变强的要求是更宽松的前置条件+更严格的后置条件，在这种情况下，就可以用变强了的spec去替换原来的spec。越强的规约，意味着实现者的自由度和责任越重，而客户的责任越轻。\n强的spec可以替换弱的spec，这一点会在第4章的LSP中得到应用\n用椭圆表示spec的强度\n如下图，大椭圆表示更弱的spec，小椭圆表示更强的spec，椭圆的大小表示的是开发者的自由度，小椭圆有更强的后置和更弱的前置，因此所包含的结果的点就少，所以就小。\nADT\nADT的操作\nCreators构造器：用于使用 new 关键字创建一个新的对象。还有一种方法是静态方法，如Arrays.asList()、String.valueOf(Object Obj)等。\nProducers生产器：用于使用一个存在的对象产生一个新的对象，例如String.concat()就是使用已存在的字符串构造出一个新的对象，而且不会改动原先存在的对象。\nObservers观察器：不对数据做任何改动，只是查看一个已经存在的对象的各个值，如List.size()、所有的getter方法等。\nMutators变值器：用于改变对象属性的方法，如List.add()。mutator通常返回void，因为它不需要对外界做出反应，只是对ADT的数据域做了更改；mutator也可能返回非空，比如返回boolean表示修改成败等。\n设计ADT\n设计一个好的ADT需要靠开发者的经验来设计它的操作的spec，设计一个ADT要遵循下面三个原则：（1）设计简洁一致的操作（2）要足以支持client所需要的对数据的所有操作，且用操作的难度要低（3）要么抽象要么具体，不要混合——要么针对抽象设计，要么针对具体应用的设计。\n实现一个ADT的三个部分：specification、representation、implementation\nRepresentation Independence 表示独立性\nclient不应该知道内部的数据域是怎么实现的，最好client只能通过ADT提供的getter方法获得ADT存储的数据。\nclient使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。其目的一个是为了便于未来的升级和维护，当内部发生变化的时候不会影响到client。\n测试ADT\n因为测试相当于client使用ADT，所以它也不能直接访问ADT内部的数据域，所以只能调用其他方法去测试被测试的方法。\n针对creator：构造对象之后，用observer去观察是否正确\n针对observer：用其他三类方法构造对象，然后调用被测observer，判断观察结果是否正确\n针对producer：produce新对象之后，用observer判断结果是否正确\nRep Invariant(RI) and Abstraction Function(AF)\nInvariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件\n两个空间 R 和 A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。\nAbstraction Function：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。\nRep Invariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。\n相同的R空间有肯能会有不同的RI。\n即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。\ncheckRep()：用于随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。\n表示泄露：client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。\nDocumenting the AF, RI, and Safety from Rep Exposure\n在代码中用注释的形式记录AF（如何解释每个R值）和RI（rep中哪些数据是有效的）。\n"
  },
  {
    "head": "软件构造复习笔记3",
    "paragraphs": [
      "1.软件开发生命周期",
      "1.从无到有；从有到好",
      "2.传统软件过程模型：基本类型有线性过程(Linear)和迭代过程(Iterative)，目前存在的模型有瀑布过程(waterfall)，增量过程(incremental)，V字模型(V-model)，原型过程(prototyping)，螺旋模型(spiral)。",
      "3.敏捷开发：Agile = 增量 + 迭代",
      "将任务划分成一个个小规模的任务，因此较小的团队也能够适应大规模软件的开发。在每个小步骤的迭代中，用户可以参与开发，软件可以随时修正，质量因此得到了保证。因此，敏捷开发是一次次小迭代，将任务细分成一个个小任务，在每个小任务上完成迭代。",
      "4.极限编程：关注于测试驱动的开发(TDD)，自动化构建、持续集成、持续交付。",
      "（迭代：开发出来之后由用户试用/评审，发现问题反馈给开发者，开发者修改原有的实现，继续交给用户评审。循环往复这个过程，直到用户满意为止。时间代价高，但开发质量也高。",
      "2.软件配置管理(SCM)和版本控制系统(VCS)",
      "软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被成为软件配置项(SCI)。",
      "当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。",
      "为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。",
      "VCS：本地版本控制系统（无法协作）存储在本地、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。",
      "（基线：软件持续变化过程中的“稳定时刻”）",
      "版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识”",
      "3.git",
      "创建：git init",
      "暂存：git add",
      "提交：git commit -m “commit message”",
      "链接：git remote add origin",
      "推送：git push- u origin master",
      "创建分支：git checkout -b",
      "切换分支：git checkout",
      "合并分支：git merge",
      "删除分支：git branch -d",
      "git中的四个区域：workspace、staging area、Local repository、Remote repository",
      "git的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。",
      "git单个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。",
      "传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。",
      "关于分支的合并：对于合并操作来说，如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的指针移到做过更改分支的指针的位置。",
      "通常软件构造过程",
      "(1) Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。",
      "(2) Code review、Static code analysis：可以使用工具来发现bug，如CheckStyle, SpotBugs。",
      "(3) Testing：测试，单元测试、集成测试、系统测试…",
      "(4) Debugging：调试",
      "(5) Dynamic code analysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分",
      "(6) Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化",
      "(7) Build：第2部分",
      "狭义的软件构造过程(Build)",
      "这是一个借助于工具，将软件构造过程中大的各阶段的活动自动化的过程，尽可能地脱离人工，以提高构造效率。",
      "常用的工具：Jenkins、Make、Ant、Maven、Gradle",
      "利用工具完成项目的自动化构建、测试、打包release等功能，完成build time–>run time。"
    ],
    "sentences": [
      "1.软件开发生命周期",
      "1.从无到有；从有到好",
      "2.传统软件过程模型：基本类型有线性过程(Linear)和迭代过程(Iterative)",
      "目前存在的模型有瀑布过程(waterfall)",
      "增量过程(incremental)",
      "V字模型(V-model)",
      "原型过程(prototyping)",
      "螺旋模型(spiral)",
      "3.敏捷开发：Agile = 增量 + 迭代",
      "将任务划分成一个个小规模的任务",
      "因此较小的团队也能够适应大规模软件的开发",
      "在每个小步骤的迭代中",
      "用户可以参与开发",
      "软件可以随时修正",
      "质量因此得到了保证",
      "因此",
      "敏捷开发是一次次小迭代",
      "将任务细分成一个个小任务",
      "在每个小任务上完成迭代",
      "4.极限编程：关注于测试驱动的开发(TDD)",
      "自动化构建、持续集成、持续交付",
      "（迭代：开发出来之后由用户试用/评审",
      "发现问题反馈给开发者",
      "开发者修改原有的实现",
      "继续交给用户评审",
      "循环往复这个过程，直到用户满意为止",
      "时间代价高，但开发质量也高",
      "2.软件配置管理(SCM)和版本控制系统(VCS)",
      "软件配置管理是为了追踪和控制软件的变化",
      "而软件中发生变化的基本单元",
      "如文件",
      "就被成为软件配置项(SCI)",
      "当软件在开发过程中达到了一个稳定的状态",
      "如可以对外发布的状态",
      "此时的文件组成了基线(Baseline)",
      "为了存储各配置项随时间变化的信息和基线信息",
      "就有一个数据库来管理这些内容",
      "即配置管理数据库(CMDB)",
      "VCS：本地版本控制系统（无法协作）存储在本地、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）存储在服务器上、分布式版本控制系统（解决了前两者的问题",
      "代价是存储空间）同时存储在本地和服务器",
      "（基线：软件持续变化过程中的“稳定时刻”）",
      "版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号",
      "作为“身份标识”",
      "3.git",
      "创建：git init",
      "暂存：git add",
      "提交：git commit -m “commit message”",
      "链接：git remote add origin",
      "推送：git push- u origin master",
      "创建分支：git checkout -b",
      "切换分支：git checkout",
      "合并分支：git merge",
      "删除分支：git branch -d",
      "git中的四个区域：workspace、staging area、Local repository、Remote repository",
      "git的存储结构是一张有向无环图",
      "每次commit在图上会增加一个新的节点",
      "并将HEAD指向这个节点",
      "通常一个子节点有一个父节点",
      "当一个父节点有多个子节点时表明创建了分支",
      "一个子节点有多个父节点时表明进行分支合并",
      "git单个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter",
      "而在每个tree中",
      "包含所有文件的信息",
      "对于每个文件指针",
      "如果文件变化了",
      "则指向变化后的新文件",
      "如果没有变化",
      "则指向上次提交的文件",
      "不做重复存储",
      "传统VCS存储的是文件每个版本之间的变化",
      "这种办法的优点是存储空间较小",
      "但由于存储的只是变化",
      "取出指定时期的文件要先取出原文件",
      "再取出变化内容",
      "最后做合并形成新文件",
      "所以取出文件的时间复杂度较高",
      "git存储的则是文件",
      "所以取出特定版本的文件比较方便",
      "但是代价的是空间复杂度较高",
      "关于分支的合并：对于合并操作来说",
      "如果是把一个做了更改的分支合并到一个未作更改的分支",
      "那么就将未作更改的分支的指针移到做过更改分支的指针的位置",
      "通常软件构造过程",
      "(1) Programming：有编程语言",
      "也有建模语言",
      "如UML",
      "还有配置语言",
      "如XML、JSON",
      "(2) Code review、Static code analysis：可以使用工具来发现bug",
      "如CheckStyle, SpotBugs",
      "(3) Testing：测试，单元测试、集成测试、系统测试…",
      "(4) Debugging：调试",
      "(5) Dynamic code analysis/profiling：在程序运行的过程中查看并发现问题",
      "本课程不涉及这部分",
      "(6) Refactoring：重构不改变功能",
      "只是处于更容易维护的目的对代码优化",
      "(7) Build：第2部分",
      "狭义的软件构造过程(Build)",
      "这是一个借助于工具",
      "将软件构造过程中大的各阶段的活动自动化的过程",
      "尽可能地脱离人工",
      "以提高构造效率",
      "常用的工具：Jenkins、Make、Ant、Maven、Gradle",
      "利用工具完成项目的自动化构建、测试、打包release等功能",
      "完成build time–>run time"
    ],
    "codes": [],
    "date": "2021-07-03",
    "text": "1.软件开发生命周期\n1.从无到有；从有到好\n2.传统软件过程模型：基本类型有线性过程(Linear)和迭代过程(Iterative)，目前存在的模型有瀑布过程(waterfall)，增量过程(incremental)，V字模型(V-model)，原型过程(prototyping)，螺旋模型(spiral)。\n3.敏捷开发：Agile = 增量 + 迭代\n将任务划分成一个个小规模的任务，因此较小的团队也能够适应大规模软件的开发。在每个小步骤的迭代中，用户可以参与开发，软件可以随时修正，质量因此得到了保证。因此，敏捷开发是一次次小迭代，将任务细分成一个个小任务，在每个小任务上完成迭代。\n4.极限编程：关注于测试驱动的开发(TDD)，自动化构建、持续集成、持续交付。\n（迭代：开发出来之后由用户试用/评审，发现问题反馈给开发者，开发者修改原有的实现，继续交给用户评审。循环往复这个过程，直到用户满意为止。时间代价高，但开发质量也高。\n2.软件配置管理(SCM)和版本控制系统(VCS)\n软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被成为软件配置项(SCI)。\n当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。\n为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。\nVCS：本地版本控制系统（无法协作）存储在本地、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。\n（基线：软件持续变化过程中的“稳定时刻”）\n版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识”\n3.git\n创建：git init\n暂存：git add\n提交：git commit -m “commit message”\n链接：git remote add origin\n推送：git push- u origin master\n创建分支：git checkout -b\n切换分支：git checkout\n合并分支：git merge\n删除分支：git branch -d\ngit中的四个区域：workspace、staging area、Local repository、Remote repository\ngit的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。\ngit单个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。\n传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。\n关于分支的合并：对于合并操作来说，如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的指针移到做过更改分支的指针的位置。\n通常软件构造过程\n(1) Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。\n(2) Code review、Static code analysis：可以使用工具来发现bug，如CheckStyle, SpotBugs。\n(3) Testing：测试，单元测试、集成测试、系统测试…\n(4) Debugging：调试\n(5) Dynamic code analysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分\n(6) Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化\n(7) Build：第2部分\n狭义的软件构造过程(Build)\n这是一个借助于工具，将软件构造过程中大的各阶段的活动自动化的过程，尽可能地脱离人工，以提高构造效率。\n常用的工具：Jenkins、Make、Ant、Maven、Gradle\n利用工具完成项目的自动化构建、测试、打包release等功能，完成build time–>run time。\n"
  },
  {
    "head": "软件构造复习笔记8",
    "paragraphs": [
      "可维护性",
      "可维护性的指标",
      "软件维护的类型：纠错性维护(25%)、适应性维护(21%)、完善性维护(50%)、预防性维护(4%)",
      "可维护性(Maintainability)、可扩展性(Extensibility)、灵活性(Flexibility)、可适应性(Adaptability)、可管理性(Manageability)、支持性(Supportability)这些指的都是可维护性。",
      "评判可维护性的一些方面：",
      "设计结构足够简单；",
      "模块之间松散耦合；",
      "模块内部高度聚合；",
      "不要使用了非常深的继承树，尽量使用delegation替代继承；",
      "代码的圈复杂度不能太高；",
      "不存在重复代码",
      "2. 模块化设计原则",
      "目的：高内聚低耦合；分离关注点 (通过delegation等机制分离功能)；信息隐藏 (避免表示泄露、静态工厂方法等等)",
      "评估模块化的五个标准：",
      "可分解性 (Decomposability)：让复杂的功能分解成一个个ADT完成",
      "可组合性 (Composability)：让一个个ADT组合完成复杂的功能",
      "可理解性 (Understandability)：OOP是面向世界上存在的事物编程，所以容易被理解",
      "可持续性 (Continuity)：发生变化时使得受影响范围最小",
      "出现异常之后的保护 (Protection)：出现异常后使得受影响范围最小",
      "模块化设计的五个原则：",
      "Direct Mapping (直接映射)",
      "Few Interfaces (尽可能少的接口)",
      "Small Interfaces (尽可能小的接口)",
      "Explicit Interfaces (显式接口)",
      "Information Hiding (信息隐藏)",
      "高内聚低耦合",
      "高内聚：模块内部的功能之间的联系要紧密，无关的功能之间要分离成不同的模块",
      "低耦合：模块之间的关系要越松散越好",
      "SOLID设计原则",
      "SOLID原则：",
      "(SRP) The Single Responsibility Principle --------- 单一责任原则",
      "(OCP) The Open-Closed Principle ------------------- 开放-封闭原则",
      "(LSP) The Liskov Substitution PrincipleLiskov ---- 替换原则",
      "(DIP) The Dependency Inversion Principle -------- 依赖转置原则",
      "(ISP) The Interface Segregation Principle ---------- 接口隔离原则",
      "单一责任原则(SRP)",
      "一个类，一个责任",
      "尽可能地将功能分割，以达到不应该有多于一个原因让你的ADT发生变化的目的，否则就要拆分开。如果多个责任（功能）放在一个类中就有可能在未来某一个功能发生变化的时候影响到整个类，从而影响到整个程序的很大一部分实现（需要全部重新编译打包部署）。",
      "开放-封闭原则(OCP)",
      "对扩展性的开放，对修改的封闭",
      "在未来对功能进行修改或者扩展的时候，要遵循尽量不去改动已有的代码而是扩展出新的类然后调用新的类的原则。",
      "典型的违反OCP的例子是大量的使用 if-else / switch-case 语句，这给维护造成了极大的麻烦。所以应对的方法是让客户端传入接口的不同子类型，而在ADT中只需要统一的调用接口中共有的方法即可。",
      "替换原则(LSP)",
      "子类型必须能够替换其基类型",
      "代价是失去了子类型扩展出的功能。",
      "依赖转置原则(DIP)",
      "具体的模块应该依赖于抽象的模块，但抽象的模块不应依赖于具体的模块",
      "使用接口隔离应用层和实现层，client面向接口编程。",
      "接口隔离原则(ISP)",
      "大接口分解为多个小的接口",
      "客户端不应依赖于它们不需要的方法，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的接口",
      "面向可维护性的编程",
      "Factory Method 工厂方法",
      "解决的问题：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。",
      "定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。",
      "当然也可以通过直接定义静态工厂方法来创建子类实例。",
      "Abstract Factory 抽象工厂",
      "解决的问题：当client需要的是多个具有固定搭配的类的组合，如A和B两个系列的类，A1搭配B1，A2搭配B2，于是，就要用抽象工厂对其做一次封装。",
      "定义一个用于创建对象的接口，让其子类来决定实例化哪一组类，从而使类与类之间的搭配对于client来说固定了。",
      "本质上，Abstract Factory是把多类产品的factory method组合在一起",
      "Proxy 代理模式",
      "解决的问题：某个对象比较“敏感”/“私密”/“贵重”，不希望被client直接访问到，故设置proxy，在二者之间建立防火墙。",
      "创建一个代理类，它接受client的功能请求，然后把功能请求转发 (delegate) 给实现类，类似于Adapter模式。",
      "4. Observer 观察者模式",
      "解决的问题：“粉丝”对“偶像”感兴趣，希望随时得知偶像的一举一动。",
      "粉丝到偶像那里注册，偶像一旦有新闻发生，就推送给已注册的粉丝（回调callback粉丝的特定功能）。这是一个双向delegate的关系，",
      "5. Visitor",
      "解决的问题：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。",
      "为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT"
    ],
    "sentences": [
      "可维护性",
      "可维护性的指标",
      "软件维护的类型：纠错性维护(25%)、适应性维护(21%)、完善性维护(50%)、预防性维护(4%)",
      "可维护性(Maintainability)、可扩展性(Extensibility)、灵活性(Flexibility)、可适应性(Adaptability)、可管理性(Manageability)、支持性(Supportability)这些指的都是可维护性",
      "评判可维护性的一些方面：设计结构足够简单；模块之间松散耦合；模块内部高度聚合；不要使用了非常深的继承树",
      "尽量使用delegation替代继承；代码的圈复杂度不能太高；不存在重复代码",
      "2. 模块化设计原则",
      "目的：高内聚低耦合；分离关注点 (通过delegation等机制分离功能)；信息隐藏 (避免表示泄露、静态工厂方法等等)",
      "评估模块化的五个标准：可分解性 (Decomposability)：让复杂的功能分解成一个个ADT完成",
      "可组合性 (Composability)：让一个个ADT组合完成复杂的功能",
      "可理解性 (Understandability)：OOP是面向世界上存在的事物编程",
      "所以容易被理解",
      "可持续性 (Continuity)：发生变化时使得受影响范围最小",
      "出现异常之后的保护 (Protection)：出现异常后使得受影响范围最小",
      "模块化设计的五个原则：Direct Mapping (直接映射)",
      "Few Interfaces (尽可能少的接口)",
      "Small Interfaces (尽可能小的接口)",
      "Explicit Interfaces (显式接口)",
      "Information Hiding (信息隐藏)",
      "高内聚低耦合",
      "高内聚：模块内部的功能之间的联系要紧密",
      "无关的功能之间要分离成不同的模块",
      "低耦合：模块之间的关系要越松散越好",
      "SOLID设计原则",
      "SOLID原则：(SRP) The Single Responsibility Principle --------- 单一责任原则",
      "(OCP) The Open-Closed Principle ------------------- 开放-封闭原则",
      "(LSP) The Liskov Substitution PrincipleLiskov ---- 替换原则",
      "(DIP) The Dependency Inversion Principle -------- 依赖转置原则",
      "(ISP) The Interface Segregation Principle ---------- 接口隔离原则",
      "单一责任原则(SRP)",
      "一个类，一个责任",
      "尽可能地将功能分割",
      "以达到不应该有多于一个原因让你的ADT发生变化的目的",
      "否则就要拆分开",
      "如果多个责任（功能）放在一个类中就有可能在未来某一个功能发生变化的时候影响到整个类",
      "从而影响到整个程序的很大一部分实现（需要全部重新编译打包部署）",
      "开放-封闭原则(OCP)",
      "对扩展性的开放，对修改的封闭",
      "在未来对功能进行修改或者扩展的时候",
      "要遵循尽量不去改动已有的代码而是扩展出新的类然后调用新的类的原则",
      "典型的违反OCP的例子是大量的使用 if-else / switch-case 语句",
      "这给维护造成了极大的麻烦",
      "所以应对的方法是让客户端传入接口的不同子类型",
      "而在ADT中只需要统一的调用接口中共有的方法即可",
      "替换原则(LSP)",
      "子类型必须能够替换其基类型",
      "代价是失去了子类型扩展出的功能",
      "依赖转置原则(DIP)",
      "具体的模块应该依赖于抽象的模块",
      "但抽象的模块不应依赖于具体的模块",
      "使用接口隔离应用层和实现层，client面向接口编程",
      "接口隔离原则(ISP)",
      "大接口分解为多个小的接口",
      "客户端不应依赖于它们不需要的方法",
      "不同的接口向不同的客户端提供服务",
      "客户端只访问自己所需要的接口",
      "面向可维护性的编程",
      "Factory Method 工厂方法",
      "解决的问题：当client不知道要创建哪个具体类的实例",
      "或者不想在client代码中指明要具体创建的实例时",
      "用工厂方法",
      "定义一个用于创建对象的接口",
      "让其子类来决定实例化哪一个类",
      "从而使一个类的实例化延迟到其子类",
      "当然也可以通过直接定义静态工厂方法来创建子类实例",
      "Abstract Factory 抽象工厂",
      "解决的问题：当client需要的是多个具有固定搭配的类的组合",
      "如A和B两个系列的类",
      "A1搭配B1",
      "A2搭配B2",
      "于是",
      "就要用抽象工厂对其做一次封装",
      "定义一个用于创建对象的接口",
      "让其子类来决定实例化哪一组类",
      "从而使类与类之间的搭配对于client来说固定了",
      "本质上",
      "Abstract Factory是把多类产品的factory method组合在一起",
      "Proxy 代理模式",
      "解决的问题：某个对象比较“敏感”/“私密”/“贵重”",
      "不希望被client直接访问到",
      "故设置proxy",
      "在二者之间建立防火墙",
      "创建一个代理类",
      "它接受client的功能请求",
      "然后把功能请求转发 (delegate) 给实现类",
      "类似于Adapter模式",
      "4. Observer 观察者模式",
      "解决的问题：“粉丝”对“偶像”感兴趣",
      "希望随时得知偶像的一举一动",
      "粉丝到偶像那里注册",
      "偶像一旦有新闻发生",
      "就推送给已注册的粉丝（回调callback粉丝的特定功能）",
      "这是一个双向delegate的关系，5. Visitor",
      "解决的问题：对特定类型的object的特定操作(visit)",
      "在运行时将二者动态绑定到一起",
      "该操作可以灵活更改",
      "无需更改被visit的类",
      "为ADT预留一个将来可扩展功能的“接入点”",
      "外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "可维护性\n可维护性的指标\n软件维护的类型：纠错性维护(25%)、适应性维护(21%)、完善性维护(50%)、预防性维护(4%)\n可维护性(Maintainability)、可扩展性(Extensibility)、灵活性(Flexibility)、可适应性(Adaptability)、可管理性(Manageability)、支持性(Supportability)这些指的都是可维护性。\n评判可维护性的一些方面：\n设计结构足够简单；\n模块之间松散耦合；\n模块内部高度聚合；\n不要使用了非常深的继承树，尽量使用delegation替代继承；\n代码的圈复杂度不能太高；\n不存在重复代码\n2. 模块化设计原则\n目的：高内聚低耦合；分离关注点 (通过delegation等机制分离功能)；信息隐藏 (避免表示泄露、静态工厂方法等等)\n评估模块化的五个标准：\n可分解性 (Decomposability)：让复杂的功能分解成一个个ADT完成\n可组合性 (Composability)：让一个个ADT组合完成复杂的功能\n可理解性 (Understandability)：OOP是面向世界上存在的事物编程，所以容易被理解\n可持续性 (Continuity)：发生变化时使得受影响范围最小\n出现异常之后的保护 (Protection)：出现异常后使得受影响范围最小\n模块化设计的五个原则：\nDirect Mapping (直接映射)\nFew Interfaces (尽可能少的接口)\nSmall Interfaces (尽可能小的接口)\nExplicit Interfaces (显式接口)\nInformation Hiding (信息隐藏)\n高内聚低耦合\n高内聚：模块内部的功能之间的联系要紧密，无关的功能之间要分离成不同的模块\n低耦合：模块之间的关系要越松散越好\nSOLID设计原则\nSOLID原则：\n(SRP) The Single Responsibility Principle --------- 单一责任原则\n(OCP) The Open-Closed Principle ------------------- 开放-封闭原则\n(LSP) The Liskov Substitution PrincipleLiskov ---- 替换原则\n(DIP) The Dependency Inversion Principle -------- 依赖转置原则\n(ISP) The Interface Segregation Principle ---------- 接口隔离原则\n单一责任原则(SRP)\n一个类，一个责任\n尽可能地将功能分割，以达到不应该有多于一个原因让你的ADT发生变化的目的，否则就要拆分开。如果多个责任（功能）放在一个类中就有可能在未来某一个功能发生变化的时候影响到整个类，从而影响到整个程序的很大一部分实现（需要全部重新编译打包部署）。\n开放-封闭原则(OCP)\n对扩展性的开放，对修改的封闭\n在未来对功能进行修改或者扩展的时候，要遵循尽量不去改动已有的代码而是扩展出新的类然后调用新的类的原则。\n典型的违反OCP的例子是大量的使用 if-else / switch-case 语句，这给维护造成了极大的麻烦。所以应对的方法是让客户端传入接口的不同子类型，而在ADT中只需要统一的调用接口中共有的方法即可。\n替换原则(LSP)\n子类型必须能够替换其基类型\n代价是失去了子类型扩展出的功能。\n依赖转置原则(DIP)\n具体的模块应该依赖于抽象的模块，但抽象的模块不应依赖于具体的模块\n使用接口隔离应用层和实现层，client面向接口编程。\n接口隔离原则(ISP)\n大接口分解为多个小的接口\n客户端不应依赖于它们不需要的方法，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的接口\n面向可维护性的编程\nFactory Method 工厂方法\n解决的问题：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。\n定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。\n当然也可以通过直接定义静态工厂方法来创建子类实例。\nAbstract Factory 抽象工厂\n解决的问题：当client需要的是多个具有固定搭配的类的组合，如A和B两个系列的类，A1搭配B1，A2搭配B2，于是，就要用抽象工厂对其做一次封装。\n定义一个用于创建对象的接口，让其子类来决定实例化哪一组类，从而使类与类之间的搭配对于client来说固定了。\n本质上，Abstract Factory是把多类产品的factory method组合在一起\nProxy 代理模式\n解决的问题：某个对象比较“敏感”/“私密”/“贵重”，不希望被client直接访问到，故设置proxy，在二者之间建立防火墙。\n创建一个代理类，它接受client的功能请求，然后把功能请求转发 (delegate) 给实现类，类似于Adapter模式。\n4. Observer 观察者模式\n解决的问题：“粉丝”对“偶像”感兴趣，希望随时得知偶像的一举一动。\n粉丝到偶像那里注册，偶像一旦有新闻发生，就推送给已注册的粉丝（回调callback粉丝的特定功能）。这是一个双向delegate的关系，\n5. Visitor\n解决的问题：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。\n为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT\n"
  },
  {
    "head": "软件构造复习笔记7",
    "paragraphs": [
      "面向复用编程",
      "面向复用编程(programming for reuse)：开发可以复用的软件",
      "基于复用编程(programming with reuse)：复用已有的软件开发",
      "为了降低成本和开发时间，提出了面向复用的编程，所有面向复用的代码都应该经过充分的测试，以保证它的可靠性和稳定性（不能在未来使用的时候发现一堆bug，那就白干了），而因为它是面向复用的，所以在不同的应用里可以保持一致的表现，也就是说对此功能做了标准化。",
      "可复用性的评估",
      "评估的方面：复用的频繁性、复用的代价 (适配)",
      "一个有高可复用性的代码应该有如下特点：小、简单；与标准兼容；灵活可变；可扩展；泛型、参数化；模块化；变化的局部性；稳定；丰富的文档和帮助。",
      "复用的层面",
      "最主要的复用是在代码层面，这也是我们所关注的，但软件构造过程中的任何实体都可能被复用（需求、spec、数据、测试用例、文档等等）",
      "源代码层面：方法、语句…",
      "模块层面：ADT (类和接口)",
      "库层面：API，如.jar文件",
      "架构层面：框架",
      "复用分为白盒复用和黑盒复用，白盒复用意味着源码是可见的，对我们来说意义不是很大，更多的是源码不可见的黑盒复用，只有这样才能隔离客户端和ADT的内部实现。",
      "源代码层面的复用",
      "可以在网络上寻找自己需要的代码，但要注意开发商用的软件不能直接复制开源的代码，避免引起法律纠纷。",
      "模块层面的复用",
      "通过继承 (Inheritance) 的方式复用父类的代码，同时也可override父类中已存在的方法。",
      "另一个复用的方法是 委托(delegation)，详见下一小节(4.2)。",
      "库层面的复用",
      "通过导入库来调用库中的API完成复用。",
      "除了导入本地库，也可以通过导入部署在网络上的库来完成复用，如 Web Services / Restful APIs",
      "架构层面的复用",
      "框架：一组具体类、抽象类、及其之间的连接关系。开发者可以根据spec填充自己的代码从而形成完整的系统。开发者根据Framework预留的接口所写的程序，而Framework作为主程序加以执行，执行过程中调用开发者所写的程序。关于框架详见下一小节4.2.3。",
      "黑盒框架：通过实现特定接口/delegation进行框架扩展",
      "白盒框架：通过代码层面的继承进行框架扩展",
      "Liskov替换原则(LSP)",
      "子类型多态",
      "子类型多态：客户端可用统一的方式处理不同类型的对象。例子类对象取代父类对象而不会产生任何问题。",
      "LSP",
      "Liskov Substitution Principle中子类重写父类的方法应该满足的条件：",
      "编译器在静态类型检查时强制满足的条件",
      "子类型可以增加方法，但不可删除",
      "子类型需要实现抽象类型中的所有未实现方法",
      "子类型中重写的方法返回值必须与父类相同或符合co-variance(协变)",
      "子类型中重写的方法必须使用同样类型的参数或者符合contra-variance(逆变)的参数",
      "子类型中重写的方法不能抛出额外的异常",
      "还应该满足的条件",
      "更强的不变量 (RI)",
      "更弱的前置条件",
      "更强的后置条件",
      "关于返回值的类型，应该保持不变或者变得更具体，也就是与派生的方向一致。",
      "所抛出的异常的类型也是如此。",
      "关于参数的类型，应该保持不变或者变得更抽象，也就是与派生的方向相反。",
      "class T {",
      "void c(String s) { … }",
      "类型擦除(泛型中的LSP)",
      "泛型类型是不支持协变的，如ArrayList 是List的子类型，但List不是List的子类型。这是因为发生了类型擦除，运行时就不存在泛型了，所有的泛型都被替换为具体的类型。",
      "但是在实际使用的过程中是存在能够处理不同的类型的泛型的需求的，如定义一个方法参数是List类型的，但是要适应不同的类型的E，于是可使用通配符?来解决这个需求。",
      "组合与委托",
      "委派/委托：一个对象请求另一个对象的功能。",
      "一个使用Comparator接口实现delegation的例子：",
      "实现比较功能还有另一种方式，让ADT实现Comparable接口然后override该接口的comparaTo()方法，但是这种方法就不再是delegation了。",
      "选择继承还是委派？",
      "如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，也就是说一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。",
      "委托发生在object层面(朋友关系)，而继承发生在class层面(父子关系)",
      "四种委派方式",
      "Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。",
      "//如果要让鸭子用其他方式叫(或飞)只需更换new的q(f)的类型即可",
      "//no field to keep Flyable object",
      "public void fly(Flyable f) { f.fly(); } //让这个鸭子以f的方式飞",
      "public void quack(Quackable q) { q.quack() }; //让鸭子以q的方式叫",
      "Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。",
      "//法一：在构造方法中传入参数绑定",
      "//法二：在rep或构造方法中直接写死",
      "//这两种实现方式的效果是相同的",
      "Composition: 更强的association，但难以变化。也就是Association中的法二。",
      "Aggregation: 更弱的association，可动态变化。也就是Association中的法一。",
      "上面所说的都是一对一的delegation，也存在一对多的delegation，只需要在rep中保存所有被委派的对象即可。",
      "组合 Composite Reuse Principle(CRP)",
      "利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。组合就是多个不同方面的delegation的结合。",
      "接口的具体子类型又可以通过静态工厂方法隐藏。",
      "抽象层是不会轻易发生变化的，会发生变化的只有底层的具体的子类型，而具体功能的变化（实现不同的功能）也是在最底层，所以抽象层是稳定的。而在具体层，两个子类之间的委派关系就有可能是稳定的也有可能是动态的，这取决于需求和设计者的设计决策。",
      "上图中所存在的子类与父类的替换只有在满足LSP的前提下才能存在，不满足LSP就没有这种delegation机制了。",
      "六种设计模式：Adapter、Decorator、Facade、Strategy、Template method、Iterator",
      "Adapter适配器模式",
      "目的是将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。",
      "因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。",
      "Decorator装饰器模式",
      "你即将开始无限套娃之旅",
      "每个子类实现不同的特性，因为这些特性都是多个维度上的个性化的特征，没办法做到在一个顶层的接口中完成所有特征的抽象，而且需要做到在各个维度上的特性的任意组合，此时光靠继承是没办法实现特性的组合的，如果要强行使用继承实现，那么面对的一个不可避免地问题是组合爆炸，因为每次继承只能扩展一个特性，多个特性就要多次继承实现，并且也不便于维护与扩展，而且会有大量的重复代码。",
      "因此，提出了Decorator设计模式，为对象增加不同侧面的不同特性。",
      "装饰器模式的原理是从接口派生出子类，然后在子类中定义一个父类接口然后将其作为delegation的对象，也就是说：自己到自己的委派。这里第一个自己指的是子类型本身，第二个自己是指该接口的其他子类，由于他们两个是同一个接口的子类，所以可以称为自己到自己的委派。",
      "下图中，Component是一个接口，接口中是公共的特性，ConcreteComponent是这个接口的基本实现，没有任何个性。Decorator是接口的一个抽象实现，它解决了委派关系的建立问题，从它派生出的诸多子类可以实现各个单独的特性而不必考虑所需要的其他特性如何在本类中实现，这些问题都通过delegation机制交给了其他子类完成。",
      "如果你没看懂，不要担心，看看下面的例子吧",
      "一个使用装饰器模式设计的例子",
      "//Stack接口，定义了所有的Stack共性的基础的功能",
      "//最基础的类，啥个性也没有的Stack，只有共性的实现",
      "public class ArrayStack implements Stack {",
      "… //rep",
      "//装饰器类，可以是一个抽象类，用于扩展出有各个特性方面的各个子类",
      "stack.push(e); //通过delegation完成任务",
      "public Item pop() {",
      "return stack.pop(); //通过delegation完成任务",
      "//一个有撤销特性功能的子类",
      "public void push(Item e) {",
      "public void undo() {",
      "//implement decorator behaviors on stack",
      "使用装饰类，通过一层一层的装饰，让得到的对象最终能够拥有任意不同特性的组合，这才是decorator模式最精妙的地方。而且装饰的顺序是不会影响到对象的最终结果拥有哪些特性的，影响到的唯一地方在于最终得到的是哪个类型的对象，也就是最后一次装饰的特性决定了最终得到哪个具体类型的对象。",
      "简直神来之笔",
      "// 先创建出一个基础类对象",
      "Stack s = new ArrayStack();",
      "// 利用UndoStack中继承到的自己到自己的委派建立起从UndoStack到ArrayStack的delegation关系",
      "// 这样，UndoStack也就能够实现最基础的功能，并且自身也实现了个性化的功能",
      "Stack us = new UndoStack(s);",
      "// 通过一层层的装饰实现各个维度的不同功能",
      "Stack ss = new SecureStack(new SynchronizedStack(us));",
      "JDK中装饰器模式的应用：static List unmodifiableList(List list)、static Set synchronizedSet(Set set);",
      "Facade外观模式",
      "客户端在调用的API时候会以固定的方式调用一系列的方法，而为了简化客户端的使用，便于客户端的学习使用、解耦，所以需要提供一个统一的接口来取代一系列小接口调用，对复杂系统做了一个封装。",
      "经过封装得到的一个方法通常是静态方法，因为客户端可以直接调用这个方法而没必要new一个对象。",
      "Strategy策略模式",
      "有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。",
      "ConcreatestrategyA和ConcreateStrategyB是Strategy接口的两种不同的实现，客户端在运行时可选择任意一种来完成功能。在方法中只需要留出一个Strategy接口类型的参数，客户端选择具体类型后传入即可。",
      "Template Method模板模式",
      "做事情的步骤一样，但具体方法不同，因此共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。",
      "在模板中，实现了一个固定执行一系列操作的方法，这个方法使用final关键字做了限定，不能再被子类重写，因此，子类只能通过重写该方法调用的那些尚未实现的方法。",
      "在上一节中提到的白盒框架就是用这种技术实现的",
      "Iterator迭代器模式",
      "客户端希望遍历被放入容器/集合类的一组ADT对象，而无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式",
      "实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。",
      "一个迭代器的实例：",
      "public void remove() {",
      "throw new UnsupportedOperationException();",
      "//使用隐式方法迭代"
    ],
    "sentences": [
      "面向复用编程",
      "面向复用编程(programming for reuse)：开发可以复用的软件",
      "基于复用编程(programming with reuse)：复用已有的软件开发",
      "为了降低成本和开发时间",
      "提出了面向复用的编程",
      "所有面向复用的代码都应该经过充分的测试",
      "以保证它的可靠性和稳定性（不能在未来使用的时候发现一堆bug",
      "那就白干了）",
      "而因为它是面向复用的",
      "所以在不同的应用里可以保持一致的表现",
      "也就是说对此功能做了标准化",
      "可复用性的评估",
      "评估的方面：复用的频繁性、复用的代价 (适配)",
      "一个有高可复用性的代码应该有如下特点：小、简单；与标准兼容；灵活可变；可扩展；泛型、参数化；模块化；变化的局部性；稳定；丰富的文档和帮助",
      "复用的层面",
      "最主要的复用是在代码层面",
      "这也是我们所关注的",
      "但软件构造过程中的任何实体都可能被复用（需求、spec、数据、测试用例、文档等等）",
      "源代码层面：方法、语句…",
      "模块层面：ADT (类和接口)",
      "库层面：API，如.jar文件",
      "架构层面：框架",
      "复用分为白盒复用和黑盒复用",
      "白盒复用意味着源码是可见的",
      "对我们来说意义不是很大",
      "更多的是源码不可见的黑盒复用",
      "只有这样才能隔离客户端和ADT的内部实现",
      "源代码层面的复用",
      "可以在网络上寻找自己需要的代码",
      "但要注意开发商用的软件不能直接复制开源的代码",
      "避免引起法律纠纷",
      "模块层面的复用",
      "通过继承 (Inheritance) 的方式复用父类的代码",
      "同时也可override父类中已存在的方法",
      "另一个复用的方法是 委托(delegation)",
      "详见下一小节(4.2)",
      "库层面的复用",
      "通过导入库来调用库中的API完成复用",
      "除了导入本地库",
      "也可以通过导入部署在网络上的库来完成复用",
      "如 Web Services / Restful APIs",
      "架构层面的复用",
      "框架：一组具体类、抽象类、及其之间的连接关系",
      "开发者可以根据spec填充自己的代码从而形成完整的系统",
      "开发者根据Framework预留的接口所写的程序",
      "而Framework作为主程序加以执行",
      "执行过程中调用开发者所写的程序",
      "关于框架详见下一小节4.2.3",
      "黑盒框架：通过实现特定接口/delegation进行框架扩展",
      "白盒框架：通过代码层面的继承进行框架扩展",
      "Liskov替换原则(LSP)",
      "子类型多态",
      "子类型多态：客户端可用统一的方式处理不同类型的对象",
      "例子类对象取代父类对象而不会产生任何问题",
      "LSP",
      "Liskov Substitution Principle中子类重写父类的方法应该满足的条件：编译器在静态类型检查时强制满足的条件",
      "子类型可以增加方法，但不可删除",
      "子类型需要实现抽象类型中的所有未实现方法",
      "子类型中重写的方法返回值必须与父类相同或符合co-variance(协变)",
      "子类型中重写的方法必须使用同样类型的参数或者符合contra-variance(逆变)的参数",
      "子类型中重写的方法不能抛出额外的异常",
      "还应该满足的条件",
      "更强的不变量 (RI)",
      "更弱的前置条件",
      "更强的后置条件",
      "关于返回值的类型",
      "应该保持不变或者变得更具体",
      "也就是与派生的方向一致",
      "所抛出的异常的类型也是如此",
      "关于参数的类型",
      "应该保持不变或者变得更抽象",
      "也就是与派生的方向相反",
      "class T {",
      "void c(String s) { … }",
      "类型擦除(泛型中的LSP)",
      "泛型类型是不支持协变的",
      "如ArrayList 是List的子类型",
      "但List不是List的子类型",
      "这是因为发生了类型擦除",
      "运行时就不存在泛型了",
      "所有的泛型都被替换为具体的类型",
      "但是在实际使用的过程中是存在能够处理不同的类型的泛型的需求的",
      "如定义一个方法参数是List类型的",
      "但是要适应不同的类型的E",
      "于是可使用通配符?来解决这个需求",
      "组合与委托",
      "委派/委托：一个对象请求另一个对象的功能",
      "一个使用Comparator接口实现delegation的例子：实现比较功能还有另一种方式",
      "让ADT实现Comparable接口然后override该接口的comparaTo()方法",
      "但是这种方法就不再是delegation了",
      "选择继承还是委派？",
      "如果子类只需要复用父类中的一小部分方法",
      "可以不需要使用继承",
      "而是通过委派机制来实现",
      "也就是说一个类不需要继承另一个类的全部方法",
      "通过委托机制调用部分方法",
      "从而避免大量无用的方法",
      "委托发生在object层面(朋友关系)",
      "而继承发生在class层面(父子关系)",
      "四种委派方式",
      "Dependency：依赖关系，临时性的delegation",
      "把被delegation的对象以参数方式传入",
      "只有在需要的时候才建立与被委派类的联系",
      "而当方法结束的时候这种关系也就随之断开了",
      "//如果要让鸭子用其他方式叫(或飞)只需更换new的q(f)的类型即可",
      "//no field to keep Flyable object",
      "public void fly(Flyable f) { f.fly(); } //让这个鸭子以f的方式飞",
      "public void quack(Quackable q) { q.quack() }; //让鸭子以q的方式叫",
      "Association：关联关系",
      "永久性的delegation",
      "被delegation的对象保存在rep中",
      "该对象的类型被永久的与此ADT绑定在了一起",
      "//法一：在构造方法中传入参数绑定",
      "//法二：在rep或构造方法中直接写死",
      "//这两种实现方式的效果是相同的",
      "Composition: 更强的association",
      "但难以变化",
      "也就是Association中的法二",
      "Aggregation: 更弱的association",
      "可动态变化",
      "也就是Association中的法一",
      "上面所说的都是一对一的delegation",
      "也存在一对多的delegation",
      "只需要在rep中保存所有被委派的对象即可",
      "组合 Composite Reuse Principle(CRP)",
      "利用delegation的机制",
      "将功能的具体实现与调用分离",
      "在实现中又通过接口的继承树实现功能的不同实现方法",
      "而在调用类中只需要创建具体的子类型然后调用即可",
      "组合就是多个不同方面的delegation的结合",
      "接口的具体子类型又可以通过静态工厂方法隐藏",
      "抽象层是不会轻易发生变化的",
      "会发生变化的只有底层的具体的子类型",
      "而具体功能的变化（实现不同的功能）也是在最底层",
      "所以抽象层是稳定的",
      "而在具体层",
      "两个子类之间的委派关系就有可能是稳定的也有可能是动态的",
      "这取决于需求和设计者的设计决策",
      "上图中所存在的子类与父类的替换只有在满足LSP的前提下才能存在",
      "不满足LSP就没有这种delegation机制了",
      "六种设计模式：Adapter、Decorator、Facade、Strategy、Template method、Iterator",
      "Adapter适配器模式",
      "目的是将某个类/接口转换为client期望的其他形式",
      "通过增加一个接口",
      "将已存在的子类封装起来",
      "client面向接口编程",
      "从而隐藏了具体子类",
      "因为Adaptee是不匹配客户端所需求的",
      "可能是参数上的",
      "所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作",
      "这就是Adapter",
      "它接受客户端的功能请求但是不会做具体的功能实现",
      "而是把客户端所提供的参数转换成Adaptee所接受的形式",
      "然后将任务委派给Adaptee完成",
      "Decorator装饰器模式",
      "你即将开始无限套娃之旅",
      "每个子类实现不同的特性",
      "因为这些特性都是多个维度上的个性化的特征",
      "没办法做到在一个顶层的接口中完成所有特征的抽象",
      "而且需要做到在各个维度上的特性的任意组合",
      "此时光靠继承是没办法实现特性的组合的",
      "如果要强行使用继承实现",
      "那么面对的一个不可避免地问题是组合爆炸",
      "因为每次继承只能扩展一个特性",
      "多个特性就要多次继承实现",
      "并且也不便于维护与扩展",
      "而且会有大量的重复代码",
      "因此",
      "提出了Decorator设计模式",
      "为对象增加不同侧面的不同特性",
      "装饰器模式的原理是从接口派生出子类",
      "然后在子类中定义一个父类接口然后将其作为delegation的对象",
      "也就是说：自己到自己的委派",
      "这里第一个自己指的是子类型本身",
      "第二个自己是指该接口的其他子类",
      "由于他们两个是同一个接口的子类",
      "所以可以称为自己到自己的委派",
      "下图中",
      "Component是一个接口",
      "接口中是公共的特性",
      "ConcreteComponent是这个接口的基本实现",
      "没有任何个性",
      "Decorator是接口的一个抽象实现",
      "它解决了委派关系的建立问题",
      "从它派生出的诸多子类可以实现各个单独的特性而不必考虑所需要的其他特性如何在本类中实现",
      "这些问题都通过delegation机制交给了其他子类完成",
      "如果你没看懂，不要担心，看看下面的例子吧",
      "一个使用装饰器模式设计的例子",
      "//Stack接口，定义了所有的Stack共性的基础的功能",
      "//最基础的类，啥个性也没有的Stack，只有共性的实现",
      "public class ArrayStack implements Stack {",
      "… //rep",
      "//装饰器类",
      "可以是一个抽象类",
      "用于扩展出有各个特性方面的各个子类",
      "stack.push(e); //通过delegation完成任务",
      "public Item pop() {",
      "return stack.pop(); //通过delegation完成任务",
      "//一个有撤销特性功能的子类",
      "public void push(Item e) {",
      "public void undo() {",
      "//implement decorator behaviors on stack",
      "使用装饰类",
      "通过一层一层的装饰",
      "让得到的对象最终能够拥有任意不同特性的组合",
      "这才是decorator模式最精妙的地方",
      "而且装饰的顺序是不会影响到对象的最终结果拥有哪些特性的",
      "影响到的唯一地方在于最终得到的是哪个类型的对象",
      "也就是最后一次装饰的特性决定了最终得到哪个具体类型的对象",
      "简直神来之笔",
      "// 先创建出一个基础类对象",
      "Stack s = new ArrayStack();// 利用UndoStack中继承到的自己到自己的委派建立起从UndoStack到ArrayStack的delegation关系",
      "// 这样",
      "UndoStack也就能够实现最基础的功能",
      "并且自身也实现了个性化的功能",
      "Stack us = new UndoStack(s);// 通过一层层的装饰实现各个维度的不同功能",
      "Stack ss = new SecureStack(new SynchronizedStack(us));JDK中装饰器模式的应用：static List unmodifiableList(List list)、static Set synchronizedSet(Set set);Facade外观模式",
      "客户端在调用的API时候会以固定的方式调用一系列的方法",
      "而为了简化客户端的使用",
      "便于客户端的学习使用、解耦",
      "所以需要提供一个统一的接口来取代一系列小接口调用",
      "对复杂系统做了一个封装",
      "经过封装得到的一个方法通常是静态方法",
      "因为客户端可以直接调用这个方法而没必要new一个对象",
      "Strategy策略模式",
      "有多种不同的算法来实现同一个任务",
      "但需要client根据需要动态切换算法",
      "而不是写死在代码里",
      "因此可以为不同的实现算法构造抽象接口",
      "利用delegation",
      "运行时动态传入client倾向的算法类实例",
      "ConcreatestrategyA和ConcreateStrategyB是Strategy接口的两种不同的实现",
      "客户端在运行时可选择任意一种来完成功能",
      "在方法中只需要留出一个Strategy接口类型的参数",
      "客户端选择具体类型后传入即可",
      "Template Method模板模式",
      "做事情的步骤一样",
      "但具体方法不同",
      "因此共性的步骤在抽象类内公共实现",
      "差异化的步骤在各个子类中实现",
      "使用继承和重写实现模板模式",
      "在模板中",
      "实现了一个固定执行一系列操作的方法",
      "这个方法使用final关键字做了限定",
      "不能再被子类重写",
      "因此",
      "子类只能通过重写该方法调用的那些尚未实现的方法",
      "在上一节中提到的白盒框架就是用这种技术实现的",
      "Iterator迭代器模式",
      "客户端希望遍历被放入容器/集合类的一组ADT对象",
      "而无需关心容器的具体类型",
      "也就是说",
      "不管对象被放进哪里",
      "都应该提供同样的遍历方式",
      "实现方式是在ADT类中实现Iterable接口",
      "该接口内部只有一个返回一个迭代器的方法",
      "然后创建一个迭代器类实现Iterator接口",
      "实现hasnext()、next()、remove()这三个方法",
      "一个迭代器的实例：public void remove() {",
      "throw new UnsupportedOperationException();//使用隐式方法迭代"
    ],
    "codes": [
      "class T {",
      "Object a() { … }",
      "void b() throws Throwable {…}",
      "class S extends T {",
      "@Override //返回值从Object协变成了String，这是符合重写的语法的",
      "String a() { … }",
      "@Override //抛出的异常从Throwable协变成了IOException，这也是符合重写的语法的",
      "void b() throws IOException {…}",
      "class S extends T {",
      "@Override //虽然按照LSP这是合法的，但是在java语法中，不当作override，而是overload",
      "void c(Object s) { … }",
      "public class Edge {",
      "Vertex s, t;",
      "double weight;",
      "public class EdgeComparator implements Comparator{",
      "@Override public int compare(Edge o1, Edge o2) {",
      "if(… > …) return 1;",
      "else if (… < …) return -1;",
      "else return 0;",
      "public void sort(List edges) {",
      "Comparator comp = new EdgeComparator();",
      "Collections.sort(edges, comp); //把比较的功能分离出来单独委派给了一个类",
      "Flyable f = new FlyWithWings(); //使用翅膀飞行的飞行方式",
      "Quackable q = new Quack(); //鸭叫声的叫声",
      "Duck d = new Duck(); //一只鸭子",
      "d.fly(f); //让鸭子飞",
      "d.quack(q); //让鸭子叫",
      "class Duck {",
      "Flyable f = new FlyWithWings();",
      "Duck d = new Duck(f);",
      "d.fly();",
      "class Duck {",
      "Flyable f; //这个必须由构造方法传入参数绑定",
      "public Duck(Flyable f) { this.f = f; }",
      "public void fly(){ f.fly(); }",
      "Duck d = new Duck();",
      "d.fly();",
      "class Duck {",
      "Flyable f = new FlyWithWings(); //写死在rep中",
      "public Duck() { f = new FlyWithWings(); } //写死在构造方法中",
      "public void fly(){ f.fly(); }",
      "interface Stack {",
      "void push(Item e);",
      "Item pop();",
      "public ArrayStack() {…}",
      "public void push(Item e) {…}",
      "public Item pop() { … }",
      "public abstract class StackDecorator implements Stack {",
      "protected final Stack stack; //用来保存delegation关系的rep",
      "public StackDecorator(Stack stack) {",
      "this.stack = stack; //建立稳定的delegation关系",
      "public class UndoStack extends StackDecorator implements Stack {",
      "private final UndoLog log = new UndoLog();",
      "public UndoStack(Stack stack) {",
      "super(stack); //调用父类的构造方法建立delegation关系",
      "public void push(Item e) {",
      "log.append(UndoLog.PUSH, e); //实现个性化的功能",
      "super.push(e); //共性的功能通过调用父类的实现来完成",
      "public class Pair implements Iterable {",
      "private final E first, second;",
      "public Pair(E f, E s) { first = f; second = s; }",
      "public Iterator iterator() {",
      "return new PairIterator();",
      "private class PairIterator implements Iterator {",
      "private boolean seenFirst = false, seenSecond = false;",
      "public boolean hasNext() { return !seenSecond; }",
      "public E next() {",
      "if (!seenFirst) { seenFirst = true; return first; }",
      "if (!seenSecond) { seenSecond = true; return second; }",
      "throw new NoSuchElementException();",
      "public static void main(String[] args){",
      "Pair pair = new Pair(“foo”, “bar”);",
      "for (String s : pair) { … }"
    ],
    "date": "2021-07-07",
    "text": "面向复用编程\n面向复用编程(programming for reuse)：开发可以复用的软件\n基于复用编程(programming with reuse)：复用已有的软件开发\n为了降低成本和开发时间，提出了面向复用的编程，所有面向复用的代码都应该经过充分的测试，以保证它的可靠性和稳定性（不能在未来使用的时候发现一堆bug，那就白干了），而因为它是面向复用的，所以在不同的应用里可以保持一致的表现，也就是说对此功能做了标准化。\n可复用性的评估\n评估的方面：复用的频繁性、复用的代价 (适配)\n一个有高可复用性的代码应该有如下特点：小、简单；与标准兼容；灵活可变；可扩展；泛型、参数化；模块化；变化的局部性；稳定；丰富的文档和帮助。\n复用的层面\n最主要的复用是在代码层面，这也是我们所关注的，但软件构造过程中的任何实体都可能被复用（需求、spec、数据、测试用例、文档等等）\n源代码层面：方法、语句…\n模块层面：ADT (类和接口)\n库层面：API，如.jar文件\n架构层面：框架\n复用分为白盒复用和黑盒复用，白盒复用意味着源码是可见的，对我们来说意义不是很大，更多的是源码不可见的黑盒复用，只有这样才能隔离客户端和ADT的内部实现。\n源代码层面的复用\n可以在网络上寻找自己需要的代码，但要注意开发商用的软件不能直接复制开源的代码，避免引起法律纠纷。\n模块层面的复用\n通过继承 (Inheritance) 的方式复用父类的代码，同时也可override父类中已存在的方法。\n另一个复用的方法是 委托(delegation)，详见下一小节(4.2)。\n库层面的复用\n通过导入库来调用库中的API完成复用。\n除了导入本地库，也可以通过导入部署在网络上的库来完成复用，如 Web Services / Restful APIs\n架构层面的复用\n框架：一组具体类、抽象类、及其之间的连接关系。开发者可以根据spec填充自己的代码从而形成完整的系统。开发者根据Framework预留的接口所写的程序，而Framework作为主程序加以执行，执行过程中调用开发者所写的程序。关于框架详见下一小节4.2.3。\n黑盒框架：通过实现特定接口/delegation进行框架扩展\n白盒框架：通过代码层面的继承进行框架扩展\nLiskov替换原则(LSP)\n子类型多态\n子类型多态：客户端可用统一的方式处理不同类型的对象。例子类对象取代父类对象而不会产生任何问题。\nLSP\nLiskov Substitution Principle中子类重写父类的方法应该满足的条件：\n编译器在静态类型检查时强制满足的条件\n子类型可以增加方法，但不可删除\n子类型需要实现抽象类型中的所有未实现方法\n子类型中重写的方法返回值必须与父类相同或符合co-variance(协变)\n子类型中重写的方法必须使用同样类型的参数或者符合contra-variance(逆变)的参数\n子类型中重写的方法不能抛出额外的异常\n还应该满足的条件\n更强的不变量 (RI)\n更弱的前置条件\n更强的后置条件\n关于返回值的类型，应该保持不变或者变得更具体，也就是与派生的方向一致。\n所抛出的异常的类型也是如此。\n关于参数的类型，应该保持不变或者变得更抽象，也就是与派生的方向相反。\nclass T {\nvoid c(String s) { … }\n类型擦除(泛型中的LSP)\n泛型类型是不支持协变的，如ArrayList 是List的子类型，但List不是List的子类型。这是因为发生了类型擦除，运行时就不存在泛型了，所有的泛型都被替换为具体的类型。\n但是在实际使用的过程中是存在能够处理不同的类型的泛型的需求的，如定义一个方法参数是List类型的，但是要适应不同的类型的E，于是可使用通配符?来解决这个需求。\n组合与委托\n委派/委托：一个对象请求另一个对象的功能。\n一个使用Comparator接口实现delegation的例子：\n实现比较功能还有另一种方式，让ADT实现Comparable接口然后override该接口的comparaTo()方法，但是这种方法就不再是delegation了。\n选择继承还是委派？\n如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，也就是说一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。\n委托发生在object层面(朋友关系)，而继承发生在class层面(父子关系)\n四种委派方式\nDependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。\n//如果要让鸭子用其他方式叫(或飞)只需更换new的q(f)的类型即可\n//no field to keep Flyable object\npublic void fly(Flyable f) { f.fly(); } //让这个鸭子以f的方式飞\npublic void quack(Quackable q) { q.quack() }; //让鸭子以q的方式叫\nAssociation：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。\n//法一：在构造方法中传入参数绑定\n//法二：在rep或构造方法中直接写死\n//这两种实现方式的效果是相同的\nComposition: 更强的association，但难以变化。也就是Association中的法二。\nAggregation: 更弱的association，可动态变化。也就是Association中的法一。\n上面所说的都是一对一的delegation，也存在一对多的delegation，只需要在rep中保存所有被委派的对象即可。\n组合 Composite Reuse Principle(CRP)\n利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。组合就是多个不同方面的delegation的结合。\n接口的具体子类型又可以通过静态工厂方法隐藏。\n抽象层是不会轻易发生变化的，会发生变化的只有底层的具体的子类型，而具体功能的变化（实现不同的功能）也是在最底层，所以抽象层是稳定的。而在具体层，两个子类之间的委派关系就有可能是稳定的也有可能是动态的，这取决于需求和设计者的设计决策。\n上图中所存在的子类与父类的替换只有在满足LSP的前提下才能存在，不满足LSP就没有这种delegation机制了。\n六种设计模式：Adapter、Decorator、Facade、Strategy、Template method、Iterator\nAdapter适配器模式\n目的是将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。\n因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。\nDecorator装饰器模式\n你即将开始无限套娃之旅\n每个子类实现不同的特性，因为这些特性都是多个维度上的个性化的特征，没办法做到在一个顶层的接口中完成所有特征的抽象，而且需要做到在各个维度上的特性的任意组合，此时光靠继承是没办法实现特性的组合的，如果要强行使用继承实现，那么面对的一个不可避免地问题是组合爆炸，因为每次继承只能扩展一个特性，多个特性就要多次继承实现，并且也不便于维护与扩展，而且会有大量的重复代码。\n因此，提出了Decorator设计模式，为对象增加不同侧面的不同特性。\n装饰器模式的原理是从接口派生出子类，然后在子类中定义一个父类接口然后将其作为delegation的对象，也就是说：自己到自己的委派。这里第一个自己指的是子类型本身，第二个自己是指该接口的其他子类，由于他们两个是同一个接口的子类，所以可以称为自己到自己的委派。\n下图中，Component是一个接口，接口中是公共的特性，ConcreteComponent是这个接口的基本实现，没有任何个性。Decorator是接口的一个抽象实现，它解决了委派关系的建立问题，从它派生出的诸多子类可以实现各个单独的特性而不必考虑所需要的其他特性如何在本类中实现，这些问题都通过delegation机制交给了其他子类完成。\n如果你没看懂，不要担心，看看下面的例子吧\n一个使用装饰器模式设计的例子\n//Stack接口，定义了所有的Stack共性的基础的功能\n//最基础的类，啥个性也没有的Stack，只有共性的实现\npublic class ArrayStack implements Stack {\n… //rep\n//装饰器类，可以是一个抽象类，用于扩展出有各个特性方面的各个子类\nstack.push(e); //通过delegation完成任务\npublic Item pop() {\nreturn stack.pop(); //通过delegation完成任务\n//一个有撤销特性功能的子类\npublic void push(Item e) {\npublic void undo() {\n//implement decorator behaviors on stack\n使用装饰类，通过一层一层的装饰，让得到的对象最终能够拥有任意不同特性的组合，这才是decorator模式最精妙的地方。而且装饰的顺序是不会影响到对象的最终结果拥有哪些特性的，影响到的唯一地方在于最终得到的是哪个类型的对象，也就是最后一次装饰的特性决定了最终得到哪个具体类型的对象。\n简直神来之笔\n// 先创建出一个基础类对象\nStack s = new ArrayStack();\n// 利用UndoStack中继承到的自己到自己的委派建立起从UndoStack到ArrayStack的delegation关系\n// 这样，UndoStack也就能够实现最基础的功能，并且自身也实现了个性化的功能\nStack us = new UndoStack(s);\n// 通过一层层的装饰实现各个维度的不同功能\nStack ss = new SecureStack(new SynchronizedStack(us));\nJDK中装饰器模式的应用：static List unmodifiableList(List list)、static Set synchronizedSet(Set set);\nFacade外观模式\n客户端在调用的API时候会以固定的方式调用一系列的方法，而为了简化客户端的使用，便于客户端的学习使用、解耦，所以需要提供一个统一的接口来取代一系列小接口调用，对复杂系统做了一个封装。\n经过封装得到的一个方法通常是静态方法，因为客户端可以直接调用这个方法而没必要new一个对象。\nStrategy策略模式\n有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。\nConcreatestrategyA和ConcreateStrategyB是Strategy接口的两种不同的实现，客户端在运行时可选择任意一种来完成功能。在方法中只需要留出一个Strategy接口类型的参数，客户端选择具体类型后传入即可。\nTemplate Method模板模式\n做事情的步骤一样，但具体方法不同，因此共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。\n在模板中，实现了一个固定执行一系列操作的方法，这个方法使用final关键字做了限定，不能再被子类重写，因此，子类只能通过重写该方法调用的那些尚未实现的方法。\n在上一节中提到的白盒框架就是用这种技术实现的\nIterator迭代器模式\n客户端希望遍历被放入容器/集合类的一组ADT对象，而无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式\n实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。\n一个迭代器的实例：\npublic void remove() {\nthrow new UnsupportedOperationException();\n//使用隐式方法迭代\n"
  },
  {
    "head": "软件构造复习笔记",
    "paragraphs": [
      "软件构造课程复习笔记1",
      "1.软件构造中的多维度视图",
      "2.视图间的转换",
      "3.软件系统的质量",
      "由于在之前的夏季小学期选择的课程并非java，因此在java方面投放了部分精力自学。博客整理的开始时间较晚，请见谅。现在开始对软件构造课程进行复习和整理。（主要基于对课件的阅读以及课堂知识的整理）",
      "1.软件构造中的多维度视图",
      "Moment维度是指程序在某一个时刻的表现，而Period维度指程序在一段时间内的表现；",
      "Build-time维度是指程序在编码阶段的表现，而Run-time维度关注程序在运行时的表现；",
      "Code-level维度在程序代码的语句层面，Component-level维度指程序一段代码：一个包，一个库",
      "Build-time views：",
      "code-level view 关注源代码的逻辑组织情况，结构，方法等",
      "component-level view 关注源代码的物理组织，如库，包，文件等等是如何链接组织起来的",
      "(1) Build-time, moment, and code-level view 关注的是源码的组织情况，可在词汇层面（源码）、语法层面（抽象语法树）、语义层面（类图）三个层面分别分析。",
      "AST：抽象语法树（abstract syntax code，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，这所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节，比如说，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。抽象语法树并不依赖于源语言的语法，也就是说语法分析阶段所采用的上下文无文文法，因为在写文法时，经常会对文法进行等价的转换（消除左递归，回溯，二义性等），这样会给文法分析引入一些多余的成分，对后续阶段造成不利影响，甚至会使合个阶段变得混乱。因些，很多编译器经常要独立地构造语法分析树，为前端，后端建立一个清晰的接口。（初始理解就是关于将源代码结构表示为树）",
      "AST：彻底结构化，将源代码变为一棵树，对树做各种操作==对源代码的修改",
      "(2) Build-time, period, and code-level view 关注的是代码的变化（Code churn代码变化）",
      "(3) Build-time, moment, and component-level view 关注的是包/库：静态链接库（课件里有一些关于库的知识）",
      "(4) Build-time, period, and component-level view 关注代码版本的更迭，而不是具体语句的变化，这里与2不同",
      "Run-time views",
      "区分了动态链接和静态链接",
      "(5) Run-time, moment, and code-level view 关注的是程序在某个时间点内存中的情况，如代码快照图(Code Snapshot)、内存转储(Memory dump)。",
      "(6) Run-time, period and code-level view 关注的是代码的执行情况，执行跟踪",
      "(7) Run-time, moment, and component-level view 关注的也是包/库，但却是在代码执行过程中的情况，如动态链接库",
      "(8) Run-time, period, and component-level view 关注的是系统的使用情况，使用日志查看",
      "2.视图间的转换",
      "Build-time维度：写出代码的维度。",
      "moment+Code-level维度，写出了一些零散代码",
      "此时随着时间的推移，代码删删改改，就属于Period+Code-level了，",
      "而代码越写越多成为了一个包，甚至形成了一个库，于是就属于moment+Component-level维度了（包含了代码间的物理联系），Period+Component-level：库文件由于需求的变化发生了变化，",
      "代码写好了，投入运行，进入Run-time维度，",
      "观察的如果是某一句代码的执行后结果，那就是moment+Code-level维度",
      "，但如果看的是代码执行的轨迹，那就是Period+Code-level维度，",
      "而如果看的是一个库文件的连接情况等，那就是moment+Component-level维度，",
      "如果看的是线程或进程的执行过程，也就是通过日志等手段查看一段时间内系统都做了什么事情，",
      "那么就是Period+Component-level。",
      "3.软件系统的质量",
      "外部质量因素（影响用户）",
      "External 1: Correctness（正确性）",
      "，正确就是按照预先定义的“规约”执行，这是软件开发最重要质量指标，一个可用的软件一定是正确的，所以首要保证软件的正确性，其他的都可以做妥协、让步，但只有这一项不可妥协。",
      "通过测试和调试可以发现和消除不正确。",
      "防御式编程可以在写程序时就保证正确性。",
      "形式化方法：通过形式化验证发现问题。",
      "External 2: Robustness（健壮性）",
      "，是针对异常情况的处理，对正确性的补充。出现规约定义之外的情形的时候，软件要做出恰当的反应，不要崩溃。",
      "External 3: Extendibility（可扩展性）",
      "，要便于软件功能的增加/扩展（ADT、OOP、留下一个Visitor），应对变化，降低未来修改软件时的成本，",
      "External 4: Reusability（可复用性）",
      "，在异性之间尽可能地寻找共性，以便于未来可以直接使用现在写的这段代码。这样可以降低软件地开发成本。进行一次开发，多次使用。发现共性。",
      "External 5: Compatibility（兼容性）",
      "，在不同的环境下都是可用的，不同的软件系统之间相互可容易的集成。（保持设计的同构性）",
      "External 6: Efficiency（效率）",
      "，不要过早的优化，性能在没有正确性保障的条件下是没有意义的。",
      "External 7: Portability（可移植性）",
      "，软件可方便的在不同的技术环境之间移植。",
      "External 8: Ease of use（易用性）",
      "，学习成本低，结构简单、清晰，易于使用。（对用户而言）",
      "External 9: Functionality（功能性）",
      "，功能过多会导致易用性的降低。主要功能要首要提升质量。",
      "External 10: Timeliness（时效性）",
      "，软件要能够在交付时间之前完成开发交给使用者。",
      "External 10++: Other qualities，Verifiability (可验证性)，Integrity (完整性)，Repairability (可修复性)，Economy (经济性)。",
      "内部质量因素（影响软件本身以及开发者）",
      "代码行数、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小",
      "折中、妥协",
      "完整性与易用性;经济性与功能性；效率与可移植性；效率与可复用性；经济与可复用性；经济性与可扩展性",
      "这些质量属性之间往往不能兼得，当某一项满足的足够好的时候有可能其他项的表现极差，因而需要做权衡，使得各部分的表现都较好，在某些特定要求下也可以放弃优化其他项而做到某一项的极致，这需要靠开发者的经验积累来判断。",
      "正确性决不能折中。",
      "在OOP开发中，通过封装、模块化、组件、抽象、分散、错误处理、信息隐藏、框架、接口等技术来尽可能地满足上述地质量因素，提高软件的开发质量。",
      "2. 五个关键的质量指标",
      "Elegant and beautiful code：代码要容易理解，通过统一变量/方法的命名标准、代码的风格、注释、包组织结构、必要时重构代码等方式让代码尽可能的容易理解。",
      "Design for/with reuse：ADT/OOP、接口、继承(Overload、Override)、多态、泛型、框架等技术可用于提高代码的可复用性。",
      "Low complexity：当复杂度较低的时候，代码就容易被扩展新的功能，所以要高内聚低耦合，遵从SOLID原则、OO设计模式、使用VCS控制代码版本",
      "Robustness and correctness：使用测试驱动的开发、异常处理、Assertion机制、防御式编程等技术保证程序的健壮性和正确性。",
      "Performance and efficiency：使用设计模式、并行/多线程等技术提升性能。"
    ],
    "sentences": [
      "软件构造课程复习笔记1",
      "1.软件构造中的多维度视图",
      "2.视图间的转换",
      "3.软件系统的质量",
      "由于在之前的夏季小学期选择的课程并非java",
      "因此在java方面投放了部分精力自学",
      "博客整理的开始时间较晚，请见谅",
      "现在开始对软件构造课程进行复习和整理",
      "（主要基于对课件的阅读以及课堂知识的整理）",
      "1.软件构造中的多维度视图",
      "Moment维度是指程序在某一个时刻的表现",
      "而Period维度指程序在一段时间内的表现；Build-time维度是指程序在编码阶段的表现",
      "而Run-time维度关注程序在运行时的表现；Code-level维度在程序代码的语句层面",
      "Component-level维度指程序一段代码：一个包",
      "一个库",
      "Build-time views：code-level view 关注源代码的逻辑组织情况",
      "结构",
      "方法等",
      "component-level view 关注源代码的物理组织",
      "如库",
      "包",
      "文件等等是如何链接组织起来的",
      "(1) Build-time, moment, and code-level view 关注的是源码的组织情况",
      "可在词汇层面（源码）、语法层面（抽象语法树）、语义层面（类图）三个层面分别分析",
      "AST：抽象语法树（abstract syntax code",
      "AST）是源代码的抽象语法结构的树状表示",
      "树上的每个节点都表示源代码中的一种结构",
      "这所以说是抽象的",
      "是因为抽象语法树并不会表示出真实语法出现的每一个细节",
      "比如说",
      "嵌套括号被隐含在树的结构中",
      "并没有以节点的形式呈现",
      "抽象语法树并不依赖于源语言的语法",
      "也就是说语法分析阶段所采用的上下文无文文法",
      "因为在写文法时",
      "经常会对文法进行等价的转换（消除左递归",
      "回溯",
      "二义性等）",
      "这样会给文法分析引入一些多余的成分",
      "对后续阶段造成不利影响",
      "甚至会使合个阶段变得混乱",
      "因些",
      "很多编译器经常要独立地构造语法分析树",
      "为前端",
      "后端建立一个清晰的接口",
      "（初始理解就是关于将源代码结构表示为树）",
      "AST：彻底结构化",
      "将源代码变为一棵树",
      "对树做各种操作==对源代码的修改",
      "(2) Build-time, period, and code-level view 关注的是代码的变化（Code churn代码变化）",
      "(3) Build-time, moment, and component-level view 关注的是包/库：静态链接库（课件里有一些关于库的知识）",
      "(4) Build-time, period, and component-level view 关注代码版本的更迭",
      "而不是具体语句的变化",
      "这里与2不同",
      "Run-time views",
      "区分了动态链接和静态链接",
      "(5) Run-time, moment, and code-level view 关注的是程序在某个时间点内存中的情况",
      "如代码快照图(Code Snapshot)、内存转储(Memory dump)",
      "(6) Run-time, period and code-level view 关注的是代码的执行情况",
      "执行跟踪",
      "(7) Run-time, moment, and component-level view 关注的也是包/库",
      "但却是在代码执行过程中的情况",
      "如动态链接库",
      "(8) Run-time, period, and component-level view 关注的是系统的使用情况",
      "使用日志查看",
      "2.视图间的转换",
      "Build-time维度：写出代码的维度",
      "moment+Code-level维度，写出了一些零散代码",
      "此时随着时间的推移",
      "代码删删改改",
      "就属于Period+Code-level了",
      "而代码越写越多成为了一个包",
      "甚至形成了一个库",
      "于是就属于moment+Component-level维度了（包含了代码间的物理联系）",
      "Period+Component-level：库文件由于需求的变化发生了变化",
      "代码写好了",
      "投入运行",
      "进入Run-time维度",
      "观察的如果是某一句代码的执行后结果",
      "那就是moment+Code-level维度",
      "",
      "但如果看的是代码执行的轨迹",
      "那就是Period+Code-level维度",
      "而如果看的是一个库文件的连接情况等",
      "那就是moment+Component-level维度",
      "如果看的是线程或进程的执行过程",
      "也就是通过日志等手段查看一段时间内系统都做了什么事情",
      "那么就是Period+Component-level",
      "3.软件系统的质量",
      "外部质量因素（影响用户）",
      "External 1: Correctness（正确性）",
      "",
      "正确就是按照预先定义的“规约”执行",
      "这是软件开发最重要质量指标",
      "一个可用的软件一定是正确的",
      "所以首要保证软件的正确性",
      "其他的都可以做妥协、让步",
      "但只有这一项不可妥协",
      "通过测试和调试可以发现和消除不正确",
      "防御式编程可以在写程序时就保证正确性",
      "形式化方法：通过形式化验证发现问题",
      "External 2: Robustness（健壮性）",
      "，是针对异常情况的处理，对正确性的补充",
      "出现规约定义之外的情形的时候，软件要做出恰当的反应，不要崩溃",
      "External 3: Extendibility（可扩展性）",
      "",
      "要便于软件功能的增加/扩展（ADT、OOP、留下一个Visitor）",
      "应对变化",
      "降低未来修改软件时的成本",
      "External 4: Reusability（可复用性）",
      "",
      "在异性之间尽可能地寻找共性",
      "以便于未来可以直接使用现在写的这段代码",
      "这样可以降低软件地开发成本",
      "进行一次开发，多次使用",
      "发现共性",
      "External 5: Compatibility（兼容性）",
      "",
      "在不同的环境下都是可用的",
      "不同的软件系统之间相互可容易的集成",
      "（保持设计的同构性）",
      "External 6: Efficiency（效率）",
      "，不要过早的优化，性能在没有正确性保障的条件下是没有意义的",
      "External 7: Portability（可移植性）",
      "，软件可方便的在不同的技术环境之间移植",
      "External 8: Ease of use（易用性）",
      "，学习成本低，结构简单、清晰，易于使用",
      "（对用户而言）",
      "External 9: Functionality（功能性）",
      "，功能过多会导致易用性的降低",
      "主要功能要首要提升质量",
      "External 10: Timeliness（时效性）",
      "，软件要能够在交付时间之前完成开发交给使用者",
      "External 10++: Other qualities",
      "Verifiability (可验证性)",
      "Integrity (完整性)",
      "Repairability (可修复性)",
      "Economy (经济性)",
      "内部质量因素（影响软件本身以及开发者）",
      "代码行数、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小",
      "折中、妥协",
      "完整性与易用性;经济性与功能性；效率与可移植性；效率与可复用性；经济与可复用性；经济性与可扩展性",
      "这些质量属性之间往往不能兼得",
      "当某一项满足的足够好的时候有可能其他项的表现极差",
      "因而需要做权衡",
      "使得各部分的表现都较好",
      "在某些特定要求下也可以放弃优化其他项而做到某一项的极致",
      "这需要靠开发者的经验积累来判断",
      "正确性决不能折中",
      "在OOP开发中",
      "通过封装、模块化、组件、抽象、分散、错误处理、信息隐藏、框架、接口等技术来尽可能地满足上述地质量因素",
      "提高软件的开发质量",
      "2. 五个关键的质量指标",
      "Elegant and beautiful code：代码要容易理解",
      "通过统一变量/方法的命名标准、代码的风格、注释、包组织结构、必要时重构代码等方式让代码尽可能的容易理解",
      "Design for/with reuse：ADT/OOP、接口、继承(Overload、Override)、多态、泛型、框架等技术可用于提高代码的可复用性",
      "Low complexity：当复杂度较低的时候",
      "代码就容易被扩展新的功能",
      "所以要高内聚低耦合",
      "遵从SOLID原则、OO设计模式、使用VCS控制代码版本",
      "Robustness and correctness：使用测试驱动的开发、异常处理、Assertion机制、防御式编程等技术保证程序的健壮性和正确性",
      "Performance and efficiency：使用设计模式、并行/多线程等技术提升性能"
    ],
    "codes": [],
    "date": "2021-06-15",
    "text": "软件构造课程复习笔记1\n1.软件构造中的多维度视图\n2.视图间的转换\n3.软件系统的质量\n由于在之前的夏季小学期选择的课程并非java，因此在java方面投放了部分精力自学。博客整理的开始时间较晚，请见谅。现在开始对软件构造课程进行复习和整理。（主要基于对课件的阅读以及课堂知识的整理）\n1.软件构造中的多维度视图\nMoment维度是指程序在某一个时刻的表现，而Period维度指程序在一段时间内的表现；\nBuild-time维度是指程序在编码阶段的表现，而Run-time维度关注程序在运行时的表现；\nCode-level维度在程序代码的语句层面，Component-level维度指程序一段代码：一个包，一个库\nBuild-time views：\ncode-level view 关注源代码的逻辑组织情况，结构，方法等\ncomponent-level view 关注源代码的物理组织，如库，包，文件等等是如何链接组织起来的\n(1) Build-time, moment, and code-level view 关注的是源码的组织情况，可在词汇层面（源码）、语法层面（抽象语法树）、语义层面（类图）三个层面分别分析。\nAST：抽象语法树（abstract syntax code，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，这所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节，比如说，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。抽象语法树并不依赖于源语言的语法，也就是说语法分析阶段所采用的上下文无文文法，因为在写文法时，经常会对文法进行等价的转换（消除左递归，回溯，二义性等），这样会给文法分析引入一些多余的成分，对后续阶段造成不利影响，甚至会使合个阶段变得混乱。因些，很多编译器经常要独立地构造语法分析树，为前端，后端建立一个清晰的接口。（初始理解就是关于将源代码结构表示为树）\nAST：彻底结构化，将源代码变为一棵树，对树做各种操作==对源代码的修改\n(2) Build-time, period, and code-level view 关注的是代码的变化（Code churn代码变化）\n(3) Build-time, moment, and component-level view 关注的是包/库：静态链接库（课件里有一些关于库的知识）\n(4) Build-time, period, and component-level view 关注代码版本的更迭，而不是具体语句的变化，这里与2不同\nRun-time views\n区分了动态链接和静态链接\n(5) Run-time, moment, and code-level view 关注的是程序在某个时间点内存中的情况，如代码快照图(Code Snapshot)、内存转储(Memory dump)。\n(6) Run-time, period and code-level view 关注的是代码的执行情况，执行跟踪\n(7) Run-time, moment, and component-level view 关注的也是包/库，但却是在代码执行过程中的情况，如动态链接库\n(8) Run-time, period, and component-level view 关注的是系统的使用情况，使用日志查看\n2.视图间的转换\nBuild-time维度：写出代码的维度。\nmoment+Code-level维度，写出了一些零散代码\n此时随着时间的推移，代码删删改改，就属于Period+Code-level了，\n而代码越写越多成为了一个包，甚至形成了一个库，于是就属于moment+Component-level维度了（包含了代码间的物理联系），Period+Component-level：库文件由于需求的变化发生了变化，\n代码写好了，投入运行，进入Run-time维度，\n观察的如果是某一句代码的执行后结果，那就是moment+Code-level维度\n，但如果看的是代码执行的轨迹，那就是Period+Code-level维度，\n而如果看的是一个库文件的连接情况等，那就是moment+Component-level维度，\n如果看的是线程或进程的执行过程，也就是通过日志等手段查看一段时间内系统都做了什么事情，\n那么就是Period+Component-level。\n3.软件系统的质量\n外部质量因素（影响用户）\nExternal 1: Correctness（正确性）\n，正确就是按照预先定义的“规约”执行，这是软件开发最重要质量指标，一个可用的软件一定是正确的，所以首要保证软件的正确性，其他的都可以做妥协、让步，但只有这一项不可妥协。\n通过测试和调试可以发现和消除不正确。\n防御式编程可以在写程序时就保证正确性。\n形式化方法：通过形式化验证发现问题。\nExternal 2: Robustness（健壮性）\n，是针对异常情况的处理，对正确性的补充。出现规约定义之外的情形的时候，软件要做出恰当的反应，不要崩溃。\nExternal 3: Extendibility（可扩展性）\n，要便于软件功能的增加/扩展（ADT、OOP、留下一个Visitor），应对变化，降低未来修改软件时的成本，\nExternal 4: Reusability（可复用性）\n，在异性之间尽可能地寻找共性，以便于未来可以直接使用现在写的这段代码。这样可以降低软件地开发成本。进行一次开发，多次使用。发现共性。\nExternal 5: Compatibility（兼容性）\n，在不同的环境下都是可用的，不同的软件系统之间相互可容易的集成。（保持设计的同构性）\nExternal 6: Efficiency（效率）\n，不要过早的优化，性能在没有正确性保障的条件下是没有意义的。\nExternal 7: Portability（可移植性）\n，软件可方便的在不同的技术环境之间移植。\nExternal 8: Ease of use（易用性）\n，学习成本低，结构简单、清晰，易于使用。（对用户而言）\nExternal 9: Functionality（功能性）\n，功能过多会导致易用性的降低。主要功能要首要提升质量。\nExternal 10: Timeliness（时效性）\n，软件要能够在交付时间之前完成开发交给使用者。\nExternal 10++: Other qualities，Verifiability (可验证性)，Integrity (完整性)，Repairability (可修复性)，Economy (经济性)。\n内部质量因素（影响软件本身以及开发者）\n代码行数、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小\n折中、妥协\n完整性与易用性;经济性与功能性；效率与可移植性；效率与可复用性；经济与可复用性；经济性与可扩展性\n这些质量属性之间往往不能兼得，当某一项满足的足够好的时候有可能其他项的表现极差，因而需要做权衡，使得各部分的表现都较好，在某些特定要求下也可以放弃优化其他项而做到某一项的极致，这需要靠开发者的经验积累来判断。\n正确性决不能折中。\n在OOP开发中，通过封装、模块化、组件、抽象、分散、错误处理、信息隐藏、框架、接口等技术来尽可能地满足上述地质量因素，提高软件的开发质量。\n2. 五个关键的质量指标\nElegant and beautiful code：代码要容易理解，通过统一变量/方法的命名标准、代码的风格、注释、包组织结构、必要时重构代码等方式让代码尽可能的容易理解。\nDesign for/with reuse：ADT/OOP、接口、继承(Overload、Override)、多态、泛型、框架等技术可用于提高代码的可复用性。\nLow complexity：当复杂度较低的时候，代码就容易被扩展新的功能，所以要高内聚低耦合，遵从SOLID原则、OO设计模式、使用VCS控制代码版本\nRobustness and correctness：使用测试驱动的开发、异常处理、Assertion机制、防御式编程等技术保证程序的健壮性和正确性。\nPerformance and efficiency：使用设计模式、并行/多线程等技术提升性能。\n"
  },
  {
    "head": "软件测试复习笔记",
    "paragraphs": [
      "软件测试与测试优先的编程",
      "对软件测试进行复习。",
      "即使是最好的测试也无法达到百分之百的无错。",
      "好的测试",
      "：能发现错误。",
      "不冗余；最佳特性；别太复杂也别太简单。",
      "Testing levels",
      "：单元测试（函数级别）；集成测试（包，类，等等）；系统测试（最终测试）。",
      "静态测试；静态测试通常是隐含的，作为校对，加上当编程工具/文本编辑器检查源代码结构或编译器(预编译程序)检查语法和数据流作为静态程序分析。（没有实际运行）",
      "动态测试：动态测试描述了对代码的动态行为的测试，它实际上是用给定的一组测试用例来执行编程代码。-动态测试可以在程序100%完成之前开始，以便测试特定部分的代码，并应用于离散的函数或模块。-这方面的典型技术是使用存根/驱动程序或从调试器环境执行。",
      "先测试，在调试。",
      "白盒测试",
      "：对程序内代码结构的测试",
      "黑盒测试",
      "黑盒测试",
      "##对程序外部行为进行的测试。",
      "想要进行好的测试，就要抱着想要另其出错的态度。",
      "测试用例",
      "测试用例：输入+执行条件+期望结果",
      "测试用例是为特定目标而开发的，例如执行特定的程序路径或验证对特定需求的遵从性。",
      "测试用例可能只是您对程序提出的一个问题。运行测试的目的是获取信息，例如，程序是否通过测试。测试用例是质量保证的基石，而测试用例是为了验证产品的质量和行为而开发的。",
      "测试优先的编程",
      "先写spec（规约）",
      "再写符合spec的测试用例",
      "测试，修改，通过。",
      "先写测试更为方便。",
      "单元测试",
      "针对软件的最小单元模型进行测试",
      "Junit测试",
      "junit是一个单元测试框架。",
      "junit单元检测仪@test为注释",
      "利用断言等方法进行检测，",
      "1.assertEquals",
      "测试两个对象是否相等，该断言不能用于数组的比较，数组的比较用assertArrayEquals",
      "2.assertArrayEquals",
      "测试两个数组是否相等",
      "3.assertTrue，assertFalse",
      "assertTrue和assertFalse用于测试boolean变量的值为true还是false",
      "4.assertNull，assertNotNull",
      "assertNull和assertNotNull用于测试变量的值是否为null",
      "5.assertSame，assertNotSame",
      "assertSame和assertNotSame用于测试两个对象的引用是否相同",
      "6.assertThat",
      "assertSame和assertNotSame用于测试两个对象的引用是否相同",
      "黑盒测试",
      "检查程序是否符合规约",
      "通过分区选择测试用例",
      "基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。",
      "针对每个输入数据需要满足的约束条件，划分等价类",
      "代码覆盖度",
      "代码覆盖度：已有的测试用例有多大程度覆盖了被测程序",
      "码覆盖度越低，测试越不充分但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高"
    ],
    "sentences": [
      "软件测试与测试优先的编程",
      "对软件测试进行复习",
      "即使是最好的测试也无法达到百分之百的无错",
      "好的测试",
      "：能发现错误",
      "不冗余；最佳特性；别太复杂也别太简单",
      "Testing levels",
      "：单元测试（函数级别）；集成测试（包",
      "类",
      "等等）；系统测试（最终测试）",
      "静态测试；静态测试通常是隐含的",
      "作为校对",
      "加上当编程工具/文本编辑器检查源代码结构或编译器(预编译程序)检查语法和数据流作为静态程序分析",
      "（没有实际运行）",
      "动态测试：动态测试描述了对代码的动态行为的测试",
      "它实际上是用给定的一组测试用例来执行编程代码",
      "-动态测试可以在程序100%完成之前开始",
      "以便测试特定部分的代码",
      "并应用于离散的函数或模块",
      "-这方面的典型技术是使用存根/驱动程序或从调试器环境执行",
      "先测试，在调试",
      "白盒测试",
      "：对程序内代码结构的测试",
      "黑盒测试",
      "黑盒测试",
      "##对程序外部行为进行的测试",
      "想要进行好的测试，就要抱着想要另其出错的态度",
      "测试用例",
      "测试用例：输入+执行条件+期望结果",
      "测试用例是为特定目标而开发的",
      "例如执行特定的程序路径或验证对特定需求的遵从性",
      "测试用例可能只是您对程序提出的一个问题",
      "运行测试的目的是获取信息，例如，程序是否通过测试",
      "测试用例是质量保证的基石",
      "而测试用例是为了验证产品的质量和行为而开发的",
      "测试优先的编程",
      "先写spec（规约）",
      "再写符合spec的测试用例",
      "测试，修改，通过",
      "先写测试更为方便",
      "单元测试",
      "针对软件的最小单元模型进行测试",
      "Junit测试",
      "junit是一个单元测试框架",
      "junit单元检测仪@test为注释",
      "利用断言等方法进行检测，1.assertEquals",
      "测试两个对象是否相等",
      "该断言不能用于数组的比较",
      "数组的比较用assertArrayEquals",
      "2.assertArrayEquals",
      "测试两个数组是否相等",
      "3.assertTrue，assertFalse",
      "assertTrue和assertFalse用于测试boolean变量的值为true还是false",
      "4.assertNull，assertNotNull",
      "assertNull和assertNotNull用于测试变量的值是否为null",
      "5.assertSame，assertNotSame",
      "assertSame和assertNotSame用于测试两个对象的引用是否相同",
      "6.assertThat",
      "assertSame和assertNotSame用于测试两个对象的引用是否相同",
      "黑盒测试",
      "检查程序是否符合规约",
      "通过分区选择测试用例",
      "基于等价类划分的测试：将被测函数的输入域划分为等价类",
      "从等价类中导出测试用例",
      "针对每个输入数据需要满足的约束条件，划分等价类",
      "代码覆盖度",
      "代码覆盖度：已有的测试用例有多大程度覆盖了被测程序",
      "码覆盖度越低",
      "测试越不充分但要做到很高的代码覆盖度",
      "需要更多的测试用例",
      "测试代价高"
    ],
    "codes": [],
    "date": "2021-07-02",
    "text": "软件测试与测试优先的编程\n对软件测试进行复习。\n即使是最好的测试也无法达到百分之百的无错。\n好的测试\n：能发现错误。\n不冗余；最佳特性；别太复杂也别太简单。\nTesting levels\n：单元测试（函数级别）；集成测试（包，类，等等）；系统测试（最终测试）。\n静态测试；静态测试通常是隐含的，作为校对，加上当编程工具/文本编辑器检查源代码结构或编译器(预编译程序)检查语法和数据流作为静态程序分析。（没有实际运行）\n动态测试：动态测试描述了对代码的动态行为的测试，它实际上是用给定的一组测试用例来执行编程代码。-动态测试可以在程序100%完成之前开始，以便测试特定部分的代码，并应用于离散的函数或模块。-这方面的典型技术是使用存根/驱动程序或从调试器环境执行。\n先测试，在调试。\n白盒测试\n：对程序内代码结构的测试\n黑盒测试\n黑盒测试\n##对程序外部行为进行的测试。\n想要进行好的测试，就要抱着想要另其出错的态度。\n测试用例\n测试用例：输入+执行条件+期望结果\n测试用例是为特定目标而开发的，例如执行特定的程序路径或验证对特定需求的遵从性。\n测试用例可能只是您对程序提出的一个问题。运行测试的目的是获取信息，例如，程序是否通过测试。测试用例是质量保证的基石，而测试用例是为了验证产品的质量和行为而开发的。\n测试优先的编程\n先写spec（规约）\n再写符合spec的测试用例\n测试，修改，通过。\n先写测试更为方便。\n单元测试\n针对软件的最小单元模型进行测试\nJunit测试\njunit是一个单元测试框架。\njunit单元检测仪@test为注释\n利用断言等方法进行检测，\n1.assertEquals\n测试两个对象是否相等，该断言不能用于数组的比较，数组的比较用assertArrayEquals\n2.assertArrayEquals\n测试两个数组是否相等\n3.assertTrue，assertFalse\nassertTrue和assertFalse用于测试boolean变量的值为true还是false\n4.assertNull，assertNotNull\nassertNull和assertNotNull用于测试变量的值是否为null\n5.assertSame，assertNotSame\nassertSame和assertNotSame用于测试两个对象的引用是否相同\n6.assertThat\nassertSame和assertNotSame用于测试两个对象的引用是否相同\n黑盒测试\n检查程序是否符合规约\n通过分区选择测试用例\n基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。\n针对每个输入数据需要满足的约束条件，划分等价类\n代码覆盖度\n代码覆盖度：已有的测试用例有多大程度覆盖了被测程序\n码覆盖度越低，测试越不充分但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高\n"
  },
  {
    "head": "java集合类List的用法",
    "paragraphs": [
      "为什么出现集合类",
      "面对对象语言对事物的体现就是以对象的形式，所以方便多个对象的操作。Java提供了集合类",
      "数组和集合的区别：",
      "A：长度区别",
      "数组的长度固定",
      "集合长度可变",
      "B：数组中可以存储基本数据类型",
      "集合只能存储对象",
      "集合类的特点：",
      "集合只能存储对象，集合长度是可变的，集合可以存储不同类型的对象",
      "不同的需求，java数据提供了不同的集合类，java提供了很多个集合类，但它们的数据结构不同，它们肯定有共性的内容（存储，获取，判断等）通过不断的向上提取、得到一个集合的继承体系结构",
      "分析：",
      "从具体到抽象",
      "实现：",
      "从平常抽象到具体",
      "使用：",
      "数据结构：数据的存储方式",
      "//集合一",
      "//集合二",
      "//只要包含所有元素，才是包含",
      "System.out.println(\"containsAll:\"+c.containsAll(c1));",
      "//c.clear();移除所有元素",
      "//boolean contains(remove o)//移除一个元素",
      "System.out.println(\"remove\"+c.remove(\"你好\"));",
      "System.out.println(\"c:\"+c);"
    ],
    "sentences": [
      "为什么出现集合类",
      "面对对象语言对事物的体现就是以对象的形式",
      "所以方便多个对象的操作",
      "Java提供了集合类",
      "数组和集合的区别：A：长度区别",
      "数组的长度固定",
      "集合长度可变",
      "B：数组中可以存储基本数据类型",
      "集合只能存储对象",
      "集合类的特点：集合只能存储对象",
      "集合长度是可变的",
      "集合可以存储不同类型的对象",
      "不同的需求",
      "java数据提供了不同的集合类",
      "java提供了很多个集合类",
      "但它们的数据结构不同",
      "它们肯定有共性的内容（存储",
      "获取",
      "判断等）通过不断的向上提取、得到一个集合的继承体系结构",
      "分析：从具体到抽象",
      "实现：从平常抽象到具体",
      "使用：数据结构：数据的存储方式",
      "//集合一",
      "//集合二",
      "//只要包含所有元素，才是包含",
      "System.out.println(\"containsAll:\"+c.containsAll(c1));//c.clear();移除所有元素",
      "//boolean contains(remove o)//移除一个元素",
      "System.out.println(\"remove\"+c.remove(\"你好\"));System.out.println(\"c:\"+c);"
    ],
    "codes": [
      "        //添加一个集合的元素\n        System.out.println(\"addAll:\"+c.addAll(c1));\n\n        System.out.println(\"removeAll:\"+c.remove(c1));\n        //只要有一个元素被移除了，就返回true\n",
      "import java.util.ArrayList;",
      "import java.util.Collection;",
      "public class Text10{",
      "public static void main(String[] args) {",
      "Collection c = new ArrayList();",
      "c.add(\"1\");",
      "c.add(\"3\");",
      "c.add(\"你好\");",
      "c.add(\"加油\");",
      "Collection c1 = new ArrayList();",
      "c1.add(\"1\");",
      "c1.add(\"2\");",
      "c1.add(\"努力\");",
      "c1.add(\"勤奋\");"
    ],
    "date": "2021-08-13",
    "text": "为什么出现集合类\n面对对象语言对事物的体现就是以对象的形式，所以方便多个对象的操作。Java提供了集合类\n数组和集合的区别：\nA：长度区别\n数组的长度固定\n集合长度可变\nB：数组中可以存储基本数据类型\n集合只能存储对象\n集合类的特点：\n集合只能存储对象，集合长度是可变的，集合可以存储不同类型的对象\n不同的需求，java数据提供了不同的集合类，java提供了很多个集合类，但它们的数据结构不同，它们肯定有共性的内容（存储，获取，判断等）通过不断的向上提取、得到一个集合的继承体系结构\n分析：\n从具体到抽象\n实现：\n从平常抽象到具体\n使用：\n数据结构：数据的存储方式\n//集合一\n//集合二\n//只要包含所有元素，才是包含\nSystem.out.println(\"containsAll:\"+c.containsAll(c1));\n//c.clear();移除所有元素\n//boolean contains(remove o)//移除一个元素\nSystem.out.println(\"remove\"+c.remove(\"你好\"));\nSystem.out.println(\"c:\"+c);\n"
  },
  {
    "head": "eclipse使用过程中遇到的问题合集（持续更新中......）",
    "paragraphs": [
      "问题1 JUnit项目无法正确运行",
      "问题2JUnit配置问题",
      "问题3在外部修改了文件后无法在eclipse中读取和运行",
      "问题1 JUnit项目无法正确运行",
      "解决方法",
      "方法一：将测试代码文件暂时放入src文件夹中才能执行，在test文件夹中不能执行。",
      "方法二：外部创建的文件夹是普通文件夹，而不是sourcefolder，因此需要在eclipse中创建sourcefile，在这个文件夹中再建立package，再建立.java即可运行。",
      "问题2JUnit配置问题",
      "解决方法",
      "应该在classPath导入库",
      "注意是在Classpath中加入JUnit库，而不是在Modulepath中加入。",
      "问题3在外部修改了文件后无法在eclipse中读取和运行",
      "解决方法在eclipse中删除该文件（注意不要删除磁盘文件），然后点击",
      "Open projects from file system,再点击Directory，选中自己要导入的java文件夹即可。"
    ],
    "sentences": [
      "问题1 JUnit项目无法正确运行",
      "问题2JUnit配置问题",
      "问题3在外部修改了文件后无法在eclipse中读取和运行",
      "问题1 JUnit项目无法正确运行",
      "解决方法",
      "方法一：将测试代码文件暂时放入src文件夹中才能执行",
      "在test文件夹中不能执行",
      "方法二：外部创建的文件夹是普通文件夹",
      "而不是sourcefolder",
      "因此需要在eclipse中创建sourcefile",
      "在这个文件夹中再建立package",
      "再建立.java即可运行",
      "问题2JUnit配置问题",
      "解决方法",
      "应该在classPath导入库",
      "注意是在Classpath中加入JUnit库",
      "而不是在Modulepath中加入",
      "问题3在外部修改了文件后无法在eclipse中读取和运行",
      "解决方法在eclipse中删除该文件（注意不要删除磁盘文件）",
      "然后点击",
      "Open projects from file system,再点击Directory",
      "选中自己要导入的java文件夹即可"
    ],
    "codes": [],
    "date": "2021-04-29",
    "text": "问题1 JUnit项目无法正确运行\n问题2JUnit配置问题\n问题3在外部修改了文件后无法在eclipse中读取和运行\n问题1 JUnit项目无法正确运行\n解决方法\n方法一：将测试代码文件暂时放入src文件夹中才能执行，在test文件夹中不能执行。\n方法二：外部创建的文件夹是普通文件夹，而不是sourcefolder，因此需要在eclipse中创建sourcefile，在这个文件夹中再建立package，再建立.java即可运行。\n问题2JUnit配置问题\n解决方法\n应该在classPath导入库\n注意是在Classpath中加入JUnit库，而不是在Modulepath中加入。\n问题3在外部修改了文件后无法在eclipse中读取和运行\n解决方法在eclipse中删除该文件（注意不要删除磁盘文件），然后点击\nOpen projects from file system,再点击Directory，选中自己要导入的java文件夹即可。\n"
  },
  {
    "head": "Java中的List类的contains和indexOf方法的区别",
    "paragraphs": [
      "问题：",
      "在对List类的使用中，有一次使用到了contains和indexOf方法，而出现预期以外的错误，考虑到List中的元素都为引用类型，因此想知道List的contains和indexOf方法的结果是否与引用对象相关。",
      "代码实例如下：",
      "运行结果如下：",
      "由此可见，如果List的泛型重写了equals方法，则contains和indexOf方法都可以正常工作，而不需要要求参数为List中的同一个引用对象，只需要值相同即可。",
      "而将equals去掉之后，其他代码不变，发现结果如下：",
      "发现contains和indexOf方法都判定newa这个对象不在peoples这个List中。",
      "如果再将此行改为：",
      "运行结果如下：",
      "结果再一次正确。",
      "总结：",
      "contains和indexOf方法是一致的。",
      "如果希望值相同就可以在List中找到，则需要重写List<L>的L中的equals方法。",
      "如果希望引用相同，则不可以重写L中的equals方法。"
    ],
    "sentences": [
      "问题：在对List类的使用中",
      "有一次使用到了contains和indexOf方法",
      "而出现预期以外的错误",
      "考虑到List中的元素都为引用类型",
      "因此想知道List的contains和indexOf方法的结果是否与引用对象相关",
      "代码实例如下：运行结果如下：由此可见",
      "如果List的泛型重写了equals方法",
      "则contains和indexOf方法都可以正常工作",
      "而不需要要求参数为List中的同一个引用对象",
      "只需要值相同即可",
      "而将equals去掉之后",
      "其他代码不变",
      "发现结果如下：发现contains和indexOf方法都判定newa这个对象不在peoples这个List中",
      "如果再将此行改为：运行结果如下：结果再一次正确",
      "总结：contains和indexOf方法是一致的",
      "如果希望值相同就可以在List中找到",
      "则需要重写List<L>的L中的equals方法",
      "如果希望引用相同，则不可以重写L中的equals方法"
    ],
    "codes": [
      "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Temp \n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tlist.add(String.valueOf(i));\n\t\t}\n\t\t//使用contains\n\t\tSystem.out.println(list.contains(\"5\"));\n\t\t//使用indexOf\n\t\tSystem.out.println(list.indexOf(\"5\"));\n\t\tSystem.out.println(list.indexOf(new String(\"5\")));\n\t\t\n\t\tList<People> peoples = new ArrayList<People>();\n\t\tPeople a  = new People(\"a\");\n\t\tPeople b  = new People(\"b\");\n\t\tPeople newa  = new People(\"a\");\n\t\tpeoples.add(a);\n\t\tpeoples.add(b);\n\t\t//使用contains\n\t\tSystem.out.println(peoples.contains(newa));\n\t\t//使用indexOf\n\t\tSystem.out.println(peoples.indexOf(newa));\n\t}\n}\nclass People{\n\tprivate String name;\n\t\n\t/**\n\t * @param name\n\t */\n\tpublic People(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((name == null) ? 0 : name.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPeople other = (People) obj;\n\t\tif (name == null) {\n\t\t\tif (other.name != null)\n\t\t\t\treturn false;\n\t\t} else if (!name.equals(other.name))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @return the name\n\t */\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n}",
      "//使用contains\nSystem.out.println(peoples.contains(a));\n//使用indexOf\nSystem.out.println(peoples.indexOf(a));"
    ],
    "date": "2021-05-31",
    "text": "问题：\n在对List类的使用中，有一次使用到了contains和indexOf方法，而出现预期以外的错误，考虑到List中的元素都为引用类型，因此想知道List的contains和indexOf方法的结果是否与引用对象相关。\n代码实例如下：\n运行结果如下：\n由此可见，如果List的泛型重写了equals方法，则contains和indexOf方法都可以正常工作，而不需要要求参数为List中的同一个引用对象，只需要值相同即可。\n而将equals去掉之后，其他代码不变，发现结果如下：\n发现contains和indexOf方法都判定newa这个对象不在peoples这个List中。\n如果再将此行改为：\n运行结果如下：\n结果再一次正确。\n总结：\ncontains和indexOf方法是一致的。\n如果希望值相同就可以在List中找到，则需要重写List<L>的L中的equals方法。\n如果希望引用相同，则不可以重写L中的equals方法。\n"
  },
  {
    "head": "python中list简介及实现",
    "paragraphs": [
      "list为python中的常用数据类型，其为python中内建类，继承自object。接下来全面介绍list的常见方法及自己实现类list功能的类",
      "创建空list",
      "创建并初始化list",
      "实现list类",
      "这里采用链表进行实现。LinkedList包含size,start,end等属性和Node类，其中size表示包含Node节点的个数，start为开始节点，end为结束节点。Node类包含pre,next,data属性，pre的值为前一个Node节点,next的值为后一个节点，data中为放入的数据信息",
      "列表（list）是最常用的Python数据类型，它可以作为一个方括号内的逗号分割值出现。",
      "List中的数据项不需要具有相同的类型，可以进行的操作包括索引（第一个索引是0，第二个索引是1，以此类推）、切片、加、乘、检查成员等。",
      "创建一个列表，只要把逗号分割的不同的数据项使用方括号括起来即可，如下所示：",
      "可以对列表的数据项进行修改或更新，也可以使用append()方法来添加列表项。",
      "这篇文章介绍了Python中list是如何实现的。",
      "在Python中list特别有用。让我们来看下list的内部是如何实现的。",
      "来看下面简单的程序，在list中添加一些整数并将他们打印出来。",
      "正如你所看到的，list是可以迭代的。",
      "List对象的C结构",
      "Python中list是用下边的C语言的结构来表示的。ob_item是用来保存元素的指针数组，allocated是ob_item预先分配的内存总容量"
    ],
    "sentences": [
      "list为python中的常用数据类型",
      "其为python中内建类",
      "继承自object",
      "接下来全面介绍list的常见方法及自己实现类list功能的类",
      "创建空list",
      "创建并初始化list",
      "实现list类",
      "这里采用链表进行实现",
      "LinkedList包含size,start,end等属性和Node类",
      "其中size表示包含Node节点的个数",
      "start为开始节点",
      "end为结束节点",
      "Node类包含pre,next,data属性",
      "pre的值为前一个Node节点,next的值为后一个节点",
      "data中为放入的数据信息",
      "列表（list）是最常用的Python数据类型",
      "它可以作为一个方括号内的逗号分割值出现",
      "List中的数据项不需要具有相同的类型",
      "可以进行的操作包括索引（第一个索引是0",
      "第二个索引是1",
      "以此类推）、切片、加、乘、检查成员等",
      "创建一个列表",
      "只要把逗号分割的不同的数据项使用方括号括起来即可",
      "如下所示：可以对列表的数据项进行修改或更新",
      "也可以使用append()方法来添加列表项",
      "这篇文章介绍了Python中list是如何实现的",
      "在Python中list特别有用",
      "让我们来看下list的内部是如何实现的",
      "来看下面简单的程序，在list中添加一些整数并将他们打印出来",
      "正如你所看到的，list是可以迭代的",
      "List对象的C结构",
      "Python中list是用下边的C语言的结构来表示的",
      "ob_item是用来保存元素的指针数组",
      "allocated是ob_item预先分配的内存总容量"
    ],
    "codes": [
      "list1 = ['a','b','c',123] #比较常用，类型可以不一致\n \nlist2 = list(list1) #传入的为可迭代对象，如set，tuple，generator\n \nlist3 = [i for i in range(10)] # 列表生成器\n \nlist4 = [x for x in range(10) if x % 2 == 0] # 生成偶数\n \nlist5 = [0] * 5 # 生成 [0, 0, 0, 0, 0]\n",
      "list1 = ['physics', 'chemistry', 1997, 2000]\nlist2 = [1,2,3,4,5]\nlist3 = [\"a\", \"b\", \"c\", \"d\"]\n",
      "list1 = [x for x in range(0,10,2)]\n  \n   # 方法一\n   for i in range(len(list1)):\n       print(list1[i], end=' ')\n   \n   # 方法二\n   for x in list1:\n       print(x, end=' ')\n   \n   # 方法三\n   for ind,value in enumerate(list1):\n       print(ind, value, sep='=', end = ' ')\n",
      "typedef struct {\n    PyObject_VAR_HEAD\n    PyObject **ob_item;\n    Py_ssize_t allocated;\n} PyListObject;\n"
    ],
    "date": "2021-08-12",
    "text": "list为python中的常用数据类型，其为python中内建类，继承自object。接下来全面介绍list的常见方法及自己实现类list功能的类\n创建空list\n创建并初始化list\n实现list类\n这里采用链表进行实现。LinkedList包含size,start,end等属性和Node类，其中size表示包含Node节点的个数，start为开始节点，end为结束节点。Node类包含pre,next,data属性，pre的值为前一个Node节点,next的值为后一个节点，data中为放入的数据信息\n列表（list）是最常用的Python数据类型，它可以作为一个方括号内的逗号分割值出现。\nList中的数据项不需要具有相同的类型，可以进行的操作包括索引（第一个索引是0，第二个索引是1，以此类推）、切片、加、乘、检查成员等。\n创建一个列表，只要把逗号分割的不同的数据项使用方括号括起来即可，如下所示：\n可以对列表的数据项进行修改或更新，也可以使用append()方法来添加列表项。\n这篇文章介绍了Python中list是如何实现的。\n在Python中list特别有用。让我们来看下list的内部是如何实现的。\n来看下面简单的程序，在list中添加一些整数并将他们打印出来。\n正如你所看到的，list是可以迭代的。\nList对象的C结构\nPython中list是用下边的C语言的结构来表示的。ob_item是用来保存元素的指针数组，allocated是ob_item预先分配的内存总容量\n"
  },
  {
    "head": "Git将文件提交到远程仓库",
    "paragraphs": [
      "本文主要是对git的提交做了一个整理，对于git的起步的安装以及初始化等不再赘述，默认git已经安装完成可以使用。",
      "注意，文中尖括号表示可变的部分，url表示链接地址",
      "一、获取git仓库",
      "1.Git前如果不是在目标文件夹中使用git，那么可以通过cd指令如：",
      "或者是在目标文件夹右键空白位置打开菜单栏里打开git bash直接就在当前目标文件夹下。",
      "$ git init",
      "该命令在目标文件夹下创建一个名为",
      ".git",
      "的子目录，这个子目录含有你初始化的git仓库中的必须文件，这些文件是git仓库的骨干。",
      "$ git clone <url>",
      "获得一份已经存在的git仓库的拷贝，将git仓库上的文件拷贝到你的本地并且在目录下初始化一个.git文件夹。",
      "$ git add .",
      "(别忘了add后有个空格且有个.)",
      "$ git commit -m “<name>”",
      "将目标文件夹中的文件进行版本控制，并初步提交到本地git仓库。",
      "二、git 远程仓库的使用",
      "$ git remote -v",
      "查看远程仓库,会显示需要读写远程操作使用的git 保存的简写以及其对应的URL",
      "（Ps: git clone 命令货去的git仓库会添加有远程仓库）",
      "$ git remote add <name> <url>",
      "添加一个新的远程git仓库",
      "$ git branch <name>",
      "在本地建立一个新的分支（比如master分支）",
      "$ git checkout <name>",
      "切换到<name>的分支上",
      "（这部分不是很重要，创建新分支时使用）",
      "$ git push <remote> <branch>",
      "（这个指令也可以将新建的分支push到远程仓库上）",
      "$ git push origin <name>",
      "将本地的<name>分支推送到远程仓库上",
      "$ git push origin <branch>:<branch>",
      "前一个为本地仓库分支名， 后一个为远程仓库的分支名，将本地分支指定推送到远程仓库的某个分支上。",
      "5.Ps：远程仓库的重命名和移除",
      "重命名：",
      "$ git remote rename <prename> <newname>",
      "$ git remote remove <name>",
      "注意分支切换之后会改变HEAD的指向，会指向当前所在的分支，如果进行本地仓库的commit，会导致head指向的分支和head操作自动向前移动，其他分支并没有，会留在切换之前commit的历史，那么这样就可以对项目做出分叉。",
      "7.更多参考资料https://git-scm.com/book/zh/v2"
    ],
    "sentences": [
      "本文主要是对git的提交做了一个整理",
      "对于git的起步的安装以及初始化等不再赘述",
      "默认git已经安装完成可以使用",
      "注意，文中尖括号表示可变的部分，url表示链接地址",
      "一、获取git仓库",
      "1.Git前如果不是在目标文件夹中使用git",
      "那么可以通过cd指令如：或者是在目标文件夹右键空白位置打开菜单栏里打开git bash直接就在当前目标文件夹下",
      "$ git init",
      "该命令在目标文件夹下创建一个名为",
      ".git",
      "的子目录",
      "这个子目录含有你初始化的git仓库中的必须文件",
      "这些文件是git仓库的骨干",
      "$ git clone <url>",
      "获得一份已经存在的git仓库的拷贝",
      "将git仓库上的文件拷贝到你的本地并且在目录下初始化一个.git文件夹",
      "$ git add .(别忘了add后有个空格且有个.)",
      "$ git commit -m “<name>”",
      "将目标文件夹中的文件进行版本控制，并初步提交到本地git仓库",
      "二、git 远程仓库的使用",
      "$ git remote -v",
      "查看远程仓库,会显示需要读写远程操作使用的git 保存的简写以及其对应的URL",
      "（Ps: git clone 命令货去的git仓库会添加有远程仓库）",
      "$ git remote add <name> <url>",
      "添加一个新的远程git仓库",
      "$ git branch <name>",
      "在本地建立一个新的分支（比如master分支）",
      "$ git checkout <name>",
      "切换到<name>的分支上",
      "（这部分不是很重要，创建新分支时使用）",
      "$ git push <remote> <branch>",
      "（这个指令也可以将新建的分支push到远程仓库上）",
      "$ git push origin <name>",
      "将本地的<name>分支推送到远程仓库上",
      "$ git push origin <branch>:<branch>",
      "前一个为本地仓库分支名",
      " 后一个为远程仓库的分支名",
      "将本地分支指定推送到远程仓库的某个分支上",
      "5.Ps：远程仓库的重命名和移除",
      "重命名：$ git remote rename <prename> <newname>",
      "$ git remote remove <name>",
      "注意分支切换之后会改变HEAD的指向",
      "会指向当前所在的分支",
      "如果进行本地仓库的commit",
      "会导致head指向的分支和head操作自动向前移动",
      "其他分支并没有",
      "会留在切换之前commit的历史",
      "那么这样就可以对项目做出分叉",
      "7.更多参考资料https://git-scm.com/book/zh/v2"
    ],
    "codes": [
      "$ cd /home/user/my_project (linux)",
      "$ cd /User/user/my_project (macOS)",
      "$ cd /c/user/my_prject (Windows)"
    ],
    "date": "2021-07-06",
    "text": "本文主要是对git的提交做了一个整理，对于git的起步的安装以及初始化等不再赘述，默认git已经安装完成可以使用。\n注意，文中尖括号表示可变的部分，url表示链接地址\n一、获取git仓库\n1.Git前如果不是在目标文件夹中使用git，那么可以通过cd指令如：\n或者是在目标文件夹右键空白位置打开菜单栏里打开git bash直接就在当前目标文件夹下。\n$ git init\n该命令在目标文件夹下创建一个名为\n.git\n的子目录，这个子目录含有你初始化的git仓库中的必须文件，这些文件是git仓库的骨干。\n$ git clone <url>\n获得一份已经存在的git仓库的拷贝，将git仓库上的文件拷贝到你的本地并且在目录下初始化一个.git文件夹。\n$ git add .\n(别忘了add后有个空格且有个.)\n$ git commit -m “<name>”\n将目标文件夹中的文件进行版本控制，并初步提交到本地git仓库。\n二、git 远程仓库的使用\n$ git remote -v\n查看远程仓库,会显示需要读写远程操作使用的git 保存的简写以及其对应的URL\n（Ps: git clone 命令货去的git仓库会添加有远程仓库）\n$ git remote add <name> <url>\n添加一个新的远程git仓库\n$ git branch <name>\n在本地建立一个新的分支（比如master分支）\n$ git checkout <name>\n切换到<name>的分支上\n（这部分不是很重要，创建新分支时使用）\n$ git push <remote> <branch>\n（这个指令也可以将新建的分支push到远程仓库上）\n$ git push origin <name>\n将本地的<name>分支推送到远程仓库上\n$ git push origin <branch>:<branch>\n前一个为本地仓库分支名， 后一个为远程仓库的分支名，将本地分支指定推送到远程仓库的某个分支上。\n5.Ps：远程仓库的重命名和移除\n重命名：\n$ git remote rename <prename> <newname>\n$ git remote remove <name>\n注意分支切换之后会改变HEAD的指向，会指向当前所在的分支，如果进行本地仓库的commit，会导致head指向的分支和head操作自动向前移动，其他分支并没有，会留在切换之前commit的历史，那么这样就可以对项目做出分叉。\n7.更多参考资料https://git-scm.com/book/zh/v2\n"
  },
  {
    "head": "数据类型学习笔记",
    "paragraphs": [
      "数据类型：一组值，并且包括可以对齐所做的操作",
      "变量：用特定数据类型定义可以存储满足类型约束的值",
      "基本数据类型：int; long; Boolean; double; char;",
      "对象数据类型：String; BigInteger;",
      "基础类型一般是 只有值，没有ID（与其他值无法区分） 是不可边的，在栈中分配内存，代价一般较低",
      "对象引用类型：（如classes,interfaces,arrays等）既有自己的ID也有值，分为可变和不可变的，在堆中分配内存，代价一般很昂贵。",
      "对象引用类型能形成层次结构：",
      "比如：继承关系（extends）",
      "可以将基础类型包装为对象引用类型（一般是定义一个集合）",
      "操作符：+ - * / 等运算； 重载：操作符可用于不同数据类型",
      "静态/动态类型检查",
      "静态类型，在编译阶段进行类型检查",
      "语法错误；类名/函数名错误；参数数目错误；参数类型错误；返回值类型错误",
      "动态类型：在运行阶段进行类型检查。",
      "非法的参数值；非法的返回值；越界；空指针",
      "可变/不可变数据类型",
      "改变变量：将该变量指向另一个值的存储空间",
      "改变变量值：将该变量当前指向值的存储空间清除后写入一个新的值",
      "所以在改变变量值的过程中的变化可能产生副作用。",
      "不变性：",
      "不变数据类型：一旦被创建，其值不能改变，包括引用类型，确定其指向的对象就不能再改变。（java中采用final变量作为方法的输入参数和局部变量）",
      "不变对象：一旦被创建，始终指向同一个值（引用）",
      "可变对象：在一些方法下可以修改自己的值/引用",
      "要注意程序中哪些参数在程序始终不发生改变。也尽量避免改变",
      "不可变：需要频繁的修改和产生大量临时的拷贝（需要进行垃圾回收）",
      "可变：减少拷贝提高效率",
      "不可变类型更加安全。",
      "在引用参数时需要注意数据发生的变化，以防发生冒险"
    ],
    "sentences": [
      "数据类型：一组值，并且包括可以对齐所做的操作",
      "变量：用特定数据类型定义可以存储满足类型约束的值",
      "基本数据类型：int; long; Boolean; double; char;对象数据类型：String; BigInteger;基础类型一般是 只有值",
      "没有ID（与其他值无法区分） 是不可边的",
      "在栈中分配内存",
      "代价一般较低",
      "对象引用类型：（如classes,interfaces,arrays等）既有自己的ID也有值",
      "分为可变和不可变的",
      "在堆中分配内存",
      "代价一般很昂贵",
      "对象引用类型能形成层次结构：比如：继承关系（extends）",
      "可以将基础类型包装为对象引用类型（一般是定义一个集合）",
      "操作符：+ - * / 等运算； 重载：操作符可用于不同数据类型",
      "静态/动态类型检查",
      "静态类型，在编译阶段进行类型检查",
      "语法错误；类名/函数名错误；参数数目错误；参数类型错误；返回值类型错误",
      "动态类型：在运行阶段进行类型检查",
      "非法的参数值；非法的返回值；越界；空指针",
      "可变/不可变数据类型",
      "改变变量：将该变量指向另一个值的存储空间",
      "改变变量值：将该变量当前指向值的存储空间清除后写入一个新的值",
      "所以在改变变量值的过程中的变化可能产生副作用",
      "不变性：不变数据类型：一旦被创建",
      "其值不能改变",
      "包括引用类型",
      "确定其指向的对象就不能再改变",
      "（java中采用final变量作为方法的输入参数和局部变量）",
      "不变对象：一旦被创建，始终指向同一个值（引用）",
      "可变对象：在一些方法下可以修改自己的值/引用",
      "要注意程序中哪些参数在程序始终不发生改变",
      "也尽量避免改变",
      "不可变：需要频繁的修改和产生大量临时的拷贝（需要进行垃圾回收）",
      "可变：减少拷贝提高效率",
      "不可变类型更加安全",
      "在引用参数时需要注意数据发生的变化，以防发生冒险"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "数据类型：一组值，并且包括可以对齐所做的操作\n变量：用特定数据类型定义可以存储满足类型约束的值\n基本数据类型：int; long; Boolean; double; char;\n对象数据类型：String; BigInteger;\n基础类型一般是 只有值，没有ID（与其他值无法区分） 是不可边的，在栈中分配内存，代价一般较低\n对象引用类型：（如classes,interfaces,arrays等）既有自己的ID也有值，分为可变和不可变的，在堆中分配内存，代价一般很昂贵。\n对象引用类型能形成层次结构：\n比如：继承关系（extends）\n可以将基础类型包装为对象引用类型（一般是定义一个集合）\n操作符：+ - * / 等运算； 重载：操作符可用于不同数据类型\n静态/动态类型检查\n静态类型，在编译阶段进行类型检查\n语法错误；类名/函数名错误；参数数目错误；参数类型错误；返回值类型错误\n动态类型：在运行阶段进行类型检查。\n非法的参数值；非法的返回值；越界；空指针\n可变/不可变数据类型\n改变变量：将该变量指向另一个值的存储空间\n改变变量值：将该变量当前指向值的存储空间清除后写入一个新的值\n所以在改变变量值的过程中的变化可能产生副作用。\n不变性：\n不变数据类型：一旦被创建，其值不能改变，包括引用类型，确定其指向的对象就不能再改变。（java中采用final变量作为方法的输入参数和局部变量）\n不变对象：一旦被创建，始终指向同一个值（引用）\n可变对象：在一些方法下可以修改自己的值/引用\n要注意程序中哪些参数在程序始终不发生改变。也尽量避免改变\n不可变：需要频繁的修改和产生大量临时的拷贝（需要进行垃圾回收）\n可变：减少拷贝提高效率\n不可变类型更加安全。\n在引用参数时需要注意数据发生的变化，以防发生冒险\n"
  },
  {
    "head": "spec学习笔记",
    "paragraphs": [
      "设计规约",
      "目标：方法的规约",
      "前置/后置条件",
      "欠定规约，非确定规约",
      "陈述式、操作式规约",
      "规约强度及其比较",
      "如何写出好的规约",
      "“方法”是程序的“积木”，可以被独立开发、测试和复用，需要抽象",
      "代码中蕴含的“设计决策”：给编译器度",
      "注释中蕴含的“设计决策”：给自己和别人读",
      "规约给“供需双方”都确定了责任，在调用时候双方都要遵守。",
      "前置条件和后置条件",
      "前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "后置条件：对开发者的约束，方法结束时必须满足的条件",
      "契约：前置条件满足，后置条件必须满足",
      "可以加入@requires 和 @ effects",
      "规约的评价",
      "规约的确定性；规约的陈述性；规约的强度",
      "前置条件和后置条件的切分考虑",
      "强的规约，放松的前置条件和更严格的后置。",
      "欠定规约：同一个输入有多个输出",
      "非确定规约：同一个输入，多次执行时的输出可能不同",
      "操作式规约：伪代码",
      "声明式规约：没有内部实现描述，只有“初-终”",
      "/**"
    ],
    "sentences": [
      "设计规约",
      "目标：方法的规约",
      "前置/后置条件",
      "欠定规约，非确定规约",
      "陈述式、操作式规约",
      "规约强度及其比较",
      "如何写出好的规约",
      "“方法”是程序的“积木”",
      "可以被独立开发、测试和复用",
      "需要抽象",
      "代码中蕴含的“设计决策”：给编译器度",
      "注释中蕴含的“设计决策”：给自己和别人读",
      "规约给“供需双方”都确定了责任，在调用时候双方都要遵守",
      "前置条件和后置条件",
      "前置条件：对客户端的约束，在使用方法时必须满足的条件",
      "后置条件：对开发者的约束，方法结束时必须满足的条件",
      "契约：前置条件满足，后置条件必须满足",
      "可以加入@requires 和 @ effects",
      "规约的评价",
      "规约的确定性；规约的陈述性；规约的强度",
      "前置条件和后置条件的切分考虑",
      "强的规约，放松的前置条件和更严格的后置",
      "欠定规约：同一个输入有多个输出",
      "非确定规约：同一个输入，多次执行时的输出可能不同",
      "操作式规约：伪代码",
      "声明式规约：没有内部实现描述，只有“初-终”",
      "/**"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "设计规约\n目标：方法的规约\n前置/后置条件\n欠定规约，非确定规约\n陈述式、操作式规约\n规约强度及其比较\n如何写出好的规约\n“方法”是程序的“积木”，可以被独立开发、测试和复用，需要抽象\n代码中蕴含的“设计决策”：给编译器度\n注释中蕴含的“设计决策”：给自己和别人读\n规约给“供需双方”都确定了责任，在调用时候双方都要遵守。\n前置条件和后置条件\n前置条件：对客户端的约束，在使用方法时必须满足的条件\n后置条件：对开发者的约束，方法结束时必须满足的条件\n契约：前置条件满足，后置条件必须满足\n可以加入@requires 和 @ effects\n规约的评价\n规约的确定性；规约的陈述性；规约的强度\n前置条件和后置条件的切分考虑\n强的规约，放松的前置条件和更严格的后置。\n欠定规约：同一个输入有多个输出\n非确定规约：同一个输入，多次执行时的输出可能不同\n操作式规约：伪代码\n声明式规约：没有内部实现描述，只有“初-终”\n/**\n"
  },
  {
    "head": "test测试学习笔记",
    "paragraphs": [
      "Software testing",
      "（1）提高软件质量的重要手段",
      "（2）确认是否达到用户需求",
      "（3）关注系统的某一侧面的质量特性",
      "当然也要注意，无论什么样的测试，质量有多高的测试，也无法达到100%的没有错误",
      "（4）残留缺陷率（每一千行代码交付后留存的bug）",
      "典型工业软件1-10 defects/kloc",
      "高质量的验证0.1-1 defects/kloc（java库）",
      "非常高的安全关键认证0.01-0.1 defects/kloc (重要的航天控件等)",
      "（5）什么是高质量的测试",
      "*能发现错误",
      "*不冗余",
      "*最佳的品类",
      "*别太复杂也别太简单",
      "（6）测试的等级",
      "单元测试->集成测试->系统测试->验收测试",
      "单元测试：验证特定代码部分功能的测试，功能级别",
      "集成测试：多个程序员或者编程团队创建的两个/多个类、包等的组合执行",
      "系统测试：测试一个完整集成的系统，是否满足要求，在最终配置中执行",
      "回归测试：回到上一层级的测试。一旦程序被修改，重新执行之前的所有测试",
      "（7）其他测试种类",
      "（8）静态测试和动态测试",
      "静态测试是隐式的，用编程工具和文本检查源代码结构和编译器",
      "检查语法和数据流（用眼睛看）",
      "动态测试可在程序未完成时候进行，测试特定的代码部分。",
      "（9）测试和调试（debug）",
      "测试：发现是否存在错误",
      "调试，识别错误根源，根除错误。",
      "（10）白盒测试和黑盒测试",
      "白盒测试：对程序内部代码结构的测试，程序内部代码可见",
      "黑盒测试：对程序外部表现出来的行为的测试，并不需要看到程序内部代码",
      "test case（测试用例）",
      "1）测试用例={测试输入+执行条件+期望的结果}",
      "2）写测试->组织测试用例->执行测试用例->获取状态和报告",
      "3. 测试优先编程",
      "1）先写spec->写符合spec的测试用例->写代码、执行测试、有问题再改、再执行。",
      "2）先写测试会节省大量调试时间",
      "3）test-driven development",
      "在测试中完善。",
      "4．Junit",
      "1）assertEquals() 期望值和运行值的比较",
      "2）assertTrue()",
      "3）assertFalse()",
      "4）另外",
      "注意@Test的标识，表示这是一个测试",
      "5. 黑盒测试",
      "黑盒测试：检查代码的功能但不关心其内部结构",
      "从规约（程序的规范和需求）出发",
      "测试用例完全由spec导出",
      "6. 等价类划分和边界值分析方法",
      "按输入域进行划分",
      "对称，传递，自反",
      "从数值范围，长度，要求等进行划分",
      "主要是考虑边界问题，输入数据的特殊情况，进行边界值的分析方法",
      "程序在边界可能发生一些“突变”",
      "7. 白盒测试",
      "需要考虑内部的细节，俺炸程序执行的路径设计测试用例",
      "对所有执行的路径进行等价类划分，找出代表性的最简单路径、每条基本路径至少覆盖一次",
      "8. 覆盖度",
      "测试用例多大程度覆盖了被测程序，覆盖度越低，测试越不充分",
      "路径＞分支＞语句 （难度和效果）",
      "测试策略：testing strategy"
    ],
    "sentences": [
      "Software testing",
      "（1）提高软件质量的重要手段",
      "（2）确认是否达到用户需求",
      "（3）关注系统的某一侧面的质量特性",
      "当然也要注意",
      "无论什么样的测试",
      "质量有多高的测试",
      "也无法达到100%的没有错误",
      "（4）残留缺陷率（每一千行代码交付后留存的bug）",
      "典型工业软件1-10 defects/kloc",
      "高质量的验证0.1-1 defects/kloc（java库）",
      "非常高的安全关键认证0.01-0.1 defects/kloc (重要的航天控件等)",
      "（5）什么是高质量的测试",
      "*能发现错误",
      "*不冗余",
      "*最佳的品类",
      "*别太复杂也别太简单",
      "（6）测试的等级",
      "单元测试->集成测试->系统测试->验收测试",
      "单元测试：验证特定代码部分功能的测试，功能级别",
      "集成测试：多个程序员或者编程团队创建的两个/多个类、包等的组合执行",
      "系统测试：测试一个完整集成的系统",
      "是否满足要求",
      "在最终配置中执行",
      "回归测试：回到上一层级的测试",
      "一旦程序被修改，重新执行之前的所有测试",
      "（7）其他测试种类",
      "（8）静态测试和动态测试",
      "静态测试是隐式的，用编程工具和文本检查源代码结构和编译器",
      "检查语法和数据流（用眼睛看）",
      "动态测试可在程序未完成时候进行，测试特定的代码部分",
      "（9）测试和调试（debug）",
      "测试：发现是否存在错误",
      "调试，识别错误根源，根除错误",
      "（10）白盒测试和黑盒测试",
      "白盒测试：对程序内部代码结构的测试，程序内部代码可见",
      "黑盒测试：对程序外部表现出来的行为的测试",
      "并不需要看到程序内部代码",
      "test case（测试用例）",
      "1）测试用例={测试输入+执行条件+期望的结果}",
      "2）写测试->组织测试用例->执行测试用例->获取状态和报告",
      "3. 测试优先编程",
      "1）先写spec->写符合spec的测试用例->写代码、执行测试、有问题再改、再执行",
      "2）先写测试会节省大量调试时间",
      "3）test-driven development",
      "在测试中完善",
      "4．Junit",
      "1）assertEquals() 期望值和运行值的比较",
      "2）assertTrue()",
      "3）assertFalse()",
      "4）另外",
      "注意@Test的标识，表示这是一个测试",
      "5. 黑盒测试",
      "黑盒测试：检查代码的功能但不关心其内部结构",
      "从规约（程序的规范和需求）出发",
      "测试用例完全由spec导出",
      "6. 等价类划分和边界值分析方法",
      "按输入域进行划分",
      "对称，传递，自反",
      "从数值范围，长度，要求等进行划分",
      "主要是考虑边界问题，输入数据的特殊情况，进行边界值的分析方法",
      "程序在边界可能发生一些“突变”",
      "7. 白盒测试",
      "需要考虑内部的细节，俺炸程序执行的路径设计测试用例",
      "对所有执行的路径进行等价类划分",
      "找出代表性的最简单路径、每条基本路径至少覆盖一次",
      "8. 覆盖度",
      "测试用例多大程度覆盖了被测程序，覆盖度越低，测试越不充分",
      "路径＞分支＞语句 （难度和效果）",
      "测试策略：testing strategy"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "Software testing\n（1）提高软件质量的重要手段\n（2）确认是否达到用户需求\n（3）关注系统的某一侧面的质量特性\n当然也要注意，无论什么样的测试，质量有多高的测试，也无法达到100%的没有错误\n（4）残留缺陷率（每一千行代码交付后留存的bug）\n典型工业软件1-10 defects/kloc\n高质量的验证0.1-1 defects/kloc（java库）\n非常高的安全关键认证0.01-0.1 defects/kloc (重要的航天控件等)\n（5）什么是高质量的测试\n*能发现错误\n*不冗余\n*最佳的品类\n*别太复杂也别太简单\n（6）测试的等级\n单元测试->集成测试->系统测试->验收测试\n单元测试：验证特定代码部分功能的测试，功能级别\n集成测试：多个程序员或者编程团队创建的两个/多个类、包等的组合执行\n系统测试：测试一个完整集成的系统，是否满足要求，在最终配置中执行\n回归测试：回到上一层级的测试。一旦程序被修改，重新执行之前的所有测试\n（7）其他测试种类\n（8）静态测试和动态测试\n静态测试是隐式的，用编程工具和文本检查源代码结构和编译器\n检查语法和数据流（用眼睛看）\n动态测试可在程序未完成时候进行，测试特定的代码部分。\n（9）测试和调试（debug）\n测试：发现是否存在错误\n调试，识别错误根源，根除错误。\n（10）白盒测试和黑盒测试\n白盒测试：对程序内部代码结构的测试，程序内部代码可见\n黑盒测试：对程序外部表现出来的行为的测试，并不需要看到程序内部代码\ntest case（测试用例）\n1）测试用例={测试输入+执行条件+期望的结果}\n2）写测试->组织测试用例->执行测试用例->获取状态和报告\n3. 测试优先编程\n1）先写spec->写符合spec的测试用例->写代码、执行测试、有问题再改、再执行。\n2）先写测试会节省大量调试时间\n3）test-driven development\n在测试中完善。\n4．Junit\n1）assertEquals() 期望值和运行值的比较\n2）assertTrue()\n3）assertFalse()\n4）另外\n注意@Test的标识，表示这是一个测试\n5. 黑盒测试\n黑盒测试：检查代码的功能但不关心其内部结构\n从规约（程序的规范和需求）出发\n测试用例完全由spec导出\n6. 等价类划分和边界值分析方法\n按输入域进行划分\n对称，传递，自反\n从数值范围，长度，要求等进行划分\n主要是考虑边界问题，输入数据的特殊情况，进行边界值的分析方法\n程序在边界可能发生一些“突变”\n7. 白盒测试\n需要考虑内部的细节，俺炸程序执行的路径设计测试用例\n对所有执行的路径进行等价类划分，找出代表性的最简单路径、每条基本路径至少覆盖一次\n8. 覆盖度\n测试用例多大程度覆盖了被测程序，覆盖度越低，测试越不充分\n路径＞分支＞语句 （难度和效果）\n测试策略：testing strategy\n"
  },
  {
    "head": "Junit断言（assert）",
    "paragraphs": [
      "void assertArrayEquals(expectedArray, actualArray) 检查两个数组是否相等",
      "void assertEquals(Object expected, Object actual) 检查两个变量（可以为布尔值，可以为文本，也可以为数据）或等式是否平衡",
      "void assertTrue(Boolean condition) 检查为真",
      "void assertFalse(Boolean condition) 检查为假",
      "void assertNotNull(Object object) 检查对象不为空",
      "void assertNull(Object object) 检查对象为空",
      "void assertSame(Object object, Object object) 检查两个对象是否为相同的引用",
      "void assertNotSame(Object object, Object object) 检查两个对象是否为不同的引用",
      "void assertThat(Object object, condition)",
      "9.主要都是前一个待测数据是否符合后面的条件，条件有",
      "/*一般匹配符*/",
      "allOf() 接下来的所有条件必须都成立",
      "anyOf() 接下来的所有条件至少一个成立",
      "anything() 不管如何，永远成立",
      "is() 与is括号中给出的object相等则通过",
      "not() 与not括号中给出的object不等则通过",
      "/*数据匹配符*/",
      "CloseTo() 前面的数据在括号中给出的范围之内，括号给出（n, a）表示n±a 的范围内",
      "GreaterThan() 前面的数据大于括号内的数据",
      "LessThan() 前面的数据小于括号内的数据",
      "EqualTo() 前面的数据等于括号内的数据，相当于equals方法",
      "/*字符串匹配符*/",
      "containsString() 前面的数据中包含指定字符串",
      "startsWith() 前面的数据是指定字符串开头",
      "endsWith() 前面的数据是指定字符串结尾",
      "/*集合匹配符*/",
      "hasItem() 集合中含有指定元素",
      "hasEntry() 含有指定的键对",
      "hasKey() 含指定键",
      "hasValue() 含指定值"
    ],
    "sentences": [
      "void assertArrayEquals(expectedArray, actualArray) 检查两个数组是否相等",
      "void assertEquals(Object expected, Object actual) 检查两个变量（可以为布尔值",
      "可以为文本",
      "也可以为数据）或等式是否平衡",
      "void assertTrue(Boolean condition) 检查为真",
      "void assertFalse(Boolean condition) 检查为假",
      "void assertNotNull(Object object) 检查对象不为空",
      "void assertNull(Object object) 检查对象为空",
      "void assertSame(Object object, Object object) 检查两个对象是否为相同的引用",
      "void assertNotSame(Object object, Object object) 检查两个对象是否为不同的引用",
      "void assertThat(Object object, condition)",
      "9.主要都是前一个待测数据是否符合后面的条件，条件有",
      "/*一般匹配符*/",
      "allOf() 接下来的所有条件必须都成立",
      "anyOf() 接下来的所有条件至少一个成立",
      "anything() 不管如何，永远成立",
      "is() 与is括号中给出的object相等则通过",
      "not() 与not括号中给出的object不等则通过",
      "/*数据匹配符*/",
      "CloseTo() 前面的数据在括号中给出的范围之内",
      "括号给出（n, a）表示n±a 的范围内",
      "GreaterThan() 前面的数据大于括号内的数据",
      "LessThan() 前面的数据小于括号内的数据",
      "EqualTo() 前面的数据等于括号内的数据",
      "相当于equals方法",
      "/*字符串匹配符*/",
      "containsString() 前面的数据中包含指定字符串",
      "startsWith() 前面的数据是指定字符串开头",
      "endsWith() 前面的数据是指定字符串结尾",
      "/*集合匹配符*/",
      "hasItem() 集合中含有指定元素",
      "hasEntry() 含有指定的键对",
      "hasKey() 含指定键",
      "hasValue() 含指定值"
    ],
    "codes": [],
    "date": "2021-07-07",
    "text": "void assertArrayEquals(expectedArray, actualArray) 检查两个数组是否相等\nvoid assertEquals(Object expected, Object actual) 检查两个变量（可以为布尔值，可以为文本，也可以为数据）或等式是否平衡\nvoid assertTrue(Boolean condition) 检查为真\nvoid assertFalse(Boolean condition) 检查为假\nvoid assertNotNull(Object object) 检查对象不为空\nvoid assertNull(Object object) 检查对象为空\nvoid assertSame(Object object, Object object) 检查两个对象是否为相同的引用\nvoid assertNotSame(Object object, Object object) 检查两个对象是否为不同的引用\nvoid assertThat(Object object, condition)\n9.主要都是前一个待测数据是否符合后面的条件，条件有\n/*一般匹配符*/\nallOf() 接下来的所有条件必须都成立\nanyOf() 接下来的所有条件至少一个成立\nanything() 不管如何，永远成立\nis() 与is括号中给出的object相等则通过\nnot() 与not括号中给出的object不等则通过\n/*数据匹配符*/\nCloseTo() 前面的数据在括号中给出的范围之内，括号给出（n, a）表示n±a 的范围内\nGreaterThan() 前面的数据大于括号内的数据\nLessThan() 前面的数据小于括号内的数据\nEqualTo() 前面的数据等于括号内的数据，相当于equals方法\n/*字符串匹配符*/\ncontainsString() 前面的数据中包含指定字符串\nstartsWith() 前面的数据是指定字符串开头\nendsWith() 前面的数据是指定字符串结尾\n/*集合匹配符*/\nhasItem() 集合中含有指定元素\nhasEntry() 含有指定的键对\nhasKey() 含指定键\nhasValue() 含指定值\n"
  },
  {
    "head": "spec简单例子",
    "paragraphs": [
      "总是让我们写spec 但是究竟该怎么写，那么我们通过例子来看。",
      "比如我们碰到以下代码让我们对他写spec",
      "方法getSomeLines（）返回诗的第start行到第end行的文本，我们需要针对该方法设计spec，充分考虑健壮性。",
      "我们就可以根据代码写出如此的比较简单的spec。"
    ],
    "sentences": [
      "总是让我们写spec 但是究竟该怎么写，那么我们通过例子来看",
      "比如我们碰到以下代码让我们对他写spec",
      "方法getSomeLines（）返回诗的第start行到第end行的文本",
      "我们需要针对该方法设计spec",
      "充分考虑健壮性",
      "我们就可以根据代码写出如此的比较简单的spec"
    ],
    "codes": [
      "public List<String> getSomeLines(int start,int end){\n    List<String> some = new ArrayList<>();\n    for(int i = start; i < end ; i++){\n        some.add(lines.get(i));\n    return some;\n    }\n}",
      "/**\n *@Param start  start需要大于等于0并且小于总行数\n *@Param end    end需要大于start并且小于等于总行数\n *@return       返回从start行到end行之间的行列表\n *@throws Nolines 没有行抛出异常\n *@throws BoundException start和end不符合规范\n */"
    ],
    "date": "2021-07-07",
    "text": "总是让我们写spec 但是究竟该怎么写，那么我们通过例子来看。\n比如我们碰到以下代码让我们对他写spec\n方法getSomeLines（）返回诗的第start行到第end行的文本，我们需要针对该方法设计spec，充分考虑健壮性。\n我们就可以根据代码写出如此的比较简单的spec。\n"
  },
  {
    "head": "JAVA异常处理",
    "paragraphs": [
      "在上一个博客里面我们有涉及到类似下面的句式，那么它究竟是干什么的以及怎么用。",
      "下面我们来探讨一下：",
      "作为看这篇博客的你来讲，代码肯定是很熟悉的东西了，并且人为操作的东西总是有漏洞，体现在代码上面就是异常，错误等。",
      "为此Java提供了异常处理机制来帮助我们检查可能出现的错误。",
      "假设我们运行以下代码：",
      "那么程序就会出现下面的异常，不能正常运行",
      "其中他说的是ArithmeticException：/by zero 直接描述给我们是因为在算术表达式中1/0 0作为除数出现，这不符合我们正常的算术表达式，不能继续执行，异常提前退出。",
      "为了保证能够让程序有效的进行，我们需要对发生的异常进行相应的处理。因为当异常产生之后，如果不做任何处理的情况下，程序就会把被终止。",
      "再假设我们运行上面的例子，我们已知Integer.parseInt是将非字符型转换为int型，匹配我们定义的code_age。但是运行之后程序会出现以下异常：",
      "和上一次不同，这次报出的是NumberFormatException也就是字符转数字异常。执行转换代码的时候异常终止。",
      "既然我们已经知道了报出异常，那么如何捕捉异常呢？",
      "这就涉及到我们本次主要介绍的东西",
      "那么我们把刚才的代码套入try catch里面",
      "运行结果如下：",
      "虽然还是会报错但是我们的程序不会停止运行。",
      "当在try里面遇到会报错的代码的时候，编译器就会自动去catch里面运行，运行完catch里面之后继续运行接下来的代码也就是System.out.println(\"程序执行完毕\");这不会导致程序因为异常而终止。",
      "另外finally语块是完整的try-catch不可缺少的，无论是否执行try-catch是否顺利执行，都会执行fanally。",
      "抛出异常：",
      "有throws 和throw两种方法",
      "运行结果如下：",
      "我们定义了一个负数数组，但是我们可以通过throws关键字抛出异常，不让我们看到异常语句。",
      "另外throw一般用于方法体中，程序在执行到throw语句的时候立刻终止，后面语句不再执行。感兴趣的童鞋可以搜索查看哦"
    ],
    "sentences": [
      "在上一个博客里面我们有涉及到类似下面的句式",
      "那么它究竟是干什么的以及怎么用",
      "下面我们来探讨一下：作为看这篇博客的你来讲",
      "代码肯定是很熟悉的东西了",
      "并且人为操作的东西总是有漏洞",
      "体现在代码上面就是异常",
      "错误等",
      "为此Java提供了异常处理机制来帮助我们检查可能出现的错误",
      "假设我们运行以下代码：那么程序就会出现下面的异常",
      "不能正常运行",
      "其中他说的是ArithmeticException：/by zero 直接描述给我们是因为在算术表达式中1/0 0作为除数出现",
      "这不符合我们正常的算术表达式",
      "不能继续执行",
      "异常提前退出",
      "为了保证能够让程序有效的进行",
      "我们需要对发生的异常进行相应的处理",
      "因为当异常产生之后",
      "如果不做任何处理的情况下",
      "程序就会把被终止",
      "再假设我们运行上面的例子",
      "我们已知Integer.parseInt是将非字符型转换为int型",
      "匹配我们定义的code_age",
      "但是运行之后程序会出现以下异常：和上一次不同",
      "这次报出的是NumberFormatException也就是字符转数字异常",
      "执行转换代码的时候异常终止",
      "既然我们已经知道了报出异常，那么如何捕捉异常呢？",
      "这就涉及到我们本次主要介绍的东西",
      "那么我们把刚才的代码套入try catch里面",
      "运行结果如下：虽然还是会报错但是我们的程序不会停止运行",
      "当在try里面遇到会报错的代码的时候",
      "编译器就会自动去catch里面运行",
      "运行完catch里面之后继续运行接下来的代码也就是System.out.println(\"程序执行完毕\");这不会导致程序因为异常而终止",
      "另外finally语块是完整的try-catch不可缺少的",
      "无论是否执行try-catch是否顺利执行",
      "都会执行fanally",
      "抛出异常：有throws 和throw两种方法",
      "运行结果如下：我们定义了一个负数数组",
      "但是我们可以通过throws关键字抛出异常",
      "不让我们看到异常语句",
      "另外throw一般用于方法体中",
      "程序在执行到throw语句的时候立刻终止",
      "后面语句不再执行",
      "感兴趣的童鞋可以搜索查看哦"
    ],
    "codes": [
      "try{\n\n.....\n\n}catch(Exception e)\n{\n.....\n}",
      "public class test {\n\n\tpublic static void main(String[] args) {\n\t\tint result;\n\t\tresult = 1/0;\n\t\tSystem.out.println(result);\n\n\t}\n\n}",
      "public class test {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tString str = new String(\"csdnyyds\");\n\t\tSystem.out.println(str);\n\t\tint code_age = Integer.parseInt(str);\n\t\tSystem.out.println(code_age);\n\t}\n\n}\n",
      "try{\n    ...\n}catch(Exception1 e){\n        对Exception1的处理\n}\ncatch(Exception2 e){\n        对Exception2的处理\n}\n...\nfinally{\n        程序块\n}",
      "public class test {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\ttry{\n\t\t\tString str = new String(\"csdnyyds\");\n\t\t\tSystem.out.println(str);\n\t\t\tint code_age = Integer.parseInt(str);\n\t\t\tSystem.out.println(code_age);\n\t\t}catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"程序执行完毕\");\n\t}\n\n}\n",
      "//已知代码会发生负数数组异常的前提下我们可以：\npublic class test {\n\tstatic void pop()throws NegativeArraySizeException{\n\t\tint[] array = new int[-10];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\ttry{\n\t\t\tpop();\n\t\t}catch(NegativeArraySizeException e) {\n\t\t\tSystem.out.println(\"pop()方法抛出异常\");\n\t\t}\n\t}\n\n}\n"
    ],
    "date": "2021-06-23",
    "text": "在上一个博客里面我们有涉及到类似下面的句式，那么它究竟是干什么的以及怎么用。\n下面我们来探讨一下：\n作为看这篇博客的你来讲，代码肯定是很熟悉的东西了，并且人为操作的东西总是有漏洞，体现在代码上面就是异常，错误等。\n为此Java提供了异常处理机制来帮助我们检查可能出现的错误。\n假设我们运行以下代码：\n那么程序就会出现下面的异常，不能正常运行\n其中他说的是ArithmeticException：/by zero 直接描述给我们是因为在算术表达式中1/0 0作为除数出现，这不符合我们正常的算术表达式，不能继续执行，异常提前退出。\n为了保证能够让程序有效的进行，我们需要对发生的异常进行相应的处理。因为当异常产生之后，如果不做任何处理的情况下，程序就会把被终止。\n再假设我们运行上面的例子，我们已知Integer.parseInt是将非字符型转换为int型，匹配我们定义的code_age。但是运行之后程序会出现以下异常：\n和上一次不同，这次报出的是NumberFormatException也就是字符转数字异常。执行转换代码的时候异常终止。\n既然我们已经知道了报出异常，那么如何捕捉异常呢？\n这就涉及到我们本次主要介绍的东西\n那么我们把刚才的代码套入try catch里面\n运行结果如下：\n虽然还是会报错但是我们的程序不会停止运行。\n当在try里面遇到会报错的代码的时候，编译器就会自动去catch里面运行，运行完catch里面之后继续运行接下来的代码也就是System.out.println(\"程序执行完毕\");这不会导致程序因为异常而终止。\n另外finally语块是完整的try-catch不可缺少的，无论是否执行try-catch是否顺利执行，都会执行fanally。\n抛出异常：\n有throws 和throw两种方法\n运行结果如下：\n我们定义了一个负数数组，但是我们可以通过throws关键字抛出异常，不让我们看到异常语句。\n另外throw一般用于方法体中，程序在执行到throw语句的时候立刻终止，后面语句不再执行。感兴趣的童鞋可以搜索查看哦\n"
  },
  {
    "head": "Java的继承",
    "paragraphs": [
      "类的继承",
      "类的继承，在我理解中有点类似父进程和子进程。",
      "首先继承的基本思想就是基于某个父类进行扩展，得到一个新的子类，子类可以继承父类原有的属性和方法，相应地，也可以增加原来父类所不具有的属性和方法，或者直接重写父类中的方法。",
      "举个例子，例如正方形，是特殊的四边形，因为正方形是四个边都相等的四边形，可以说正方形继承了四边形类。这时，正方形继承了平行四边形所有具有的属性和方法，以及可以基于四边形类所增加的新的平行四边形类的属性和方法。",
      "举例：",
      "该例子中定义了两个类，其中Test2类继承Test类，可以说Test类为Test2类的父类，Test2为Test的子类。在子类中可以连同初始化父类构造方法来完成子类初始化操作，既可以在子类的构造方法中用super()语句调用父类的构造方法，也可以在子类中使用super关键字调用父类的成员方法等。但是对于父类中的private方法，子类没有权限调用它，只可以调用父类中修饰符为public或者protected的成员方法。例如子类构造方法中可以使用super关键字调用父类的doSomething()方法，因为doSomething方法修饰符为protected。同时在子类中也可以定义一些新的方法，如子类的doSomethingnew（）方法。",
      "继承并不只是扩展父类的功能，还可以重写父类的成员方法。重写还可以成为覆盖，就是在子类中讲父类的成员方法的名称保留，重写成员方法的实现内容，更改成员方法的存储权限，或是修改成员方法的返回类型。",
      "在继承中还有一种特殊的重写方式，子类与父类的成员方法返回值，方法名称，参数类型及个数完全相同，唯一不同你的就是方法实现内容，这种特殊重写方式被称为重构。",
      "创建Subroutine类和两个父类，分别为Parent和SubParent。这三个类的继承关系是Subroutine类继承Subparent类，而Subparent类继承Parent类。分别在这三个类的构造方法中输出构造方法名称来验证继承关系。",
      "Eclipse输出如下",
      "调用父类的Parent()构造方法",
      "调用子类的SubParent()构造方法",
      "调用子类的Subroutine()构造方法",
      "运行结果可以看出，在子类Subroutine的主方法中只调用子类的构造方法实例化子类对象，并且在子类构造方法中没有调用父类构造方法的任何语句，但是在实例化子类对象时它相应调用了父类的构造方法。在这个结果中可以看到调用构造方法的顺序，首先是顶级父类，然后是上一级父类，最后才是子类。也就是说，实例化子类对象时首先要实例化父类对象，然后在实例化子类对象，所以在子类构造方法访问父类的构造方法去，父类已经完成实例化操作。"
    ],
    "sentences": [
      "类的继承",
      "类的继承，在我理解中有点类似父进程和子进程",
      "首先继承的基本思想就是基于某个父类进行扩展",
      "得到一个新的子类",
      "子类可以继承父类原有的属性和方法",
      "相应地",
      "也可以增加原来父类所不具有的属性和方法",
      "或者直接重写父类中的方法",
      "举个例子",
      "例如正方形",
      "是特殊的四边形",
      "因为正方形是四个边都相等的四边形",
      "可以说正方形继承了四边形类",
      "这时",
      "正方形继承了平行四边形所有具有的属性和方法",
      "以及可以基于四边形类所增加的新的平行四边形类的属性和方法",
      "举例：该例子中定义了两个类",
      "其中Test2类继承Test类",
      "可以说Test类为Test2类的父类",
      "Test2为Test的子类",
      "在子类中可以连同初始化父类构造方法来完成子类初始化操作",
      "既可以在子类的构造方法中用super()语句调用父类的构造方法",
      "也可以在子类中使用super关键字调用父类的成员方法等",
      "但是对于父类中的private方法",
      "子类没有权限调用它",
      "只可以调用父类中修饰符为public或者protected的成员方法",
      "例如子类构造方法中可以使用super关键字调用父类的doSomething()方法",
      "因为doSomething方法修饰符为protected",
      "同时在子类中也可以定义一些新的方法",
      "如子类的doSomethingnew（）方法",
      "继承并不只是扩展父类的功能，还可以重写父类的成员方法",
      "重写还可以成为覆盖",
      "就是在子类中讲父类的成员方法的名称保留",
      "重写成员方法的实现内容",
      "更改成员方法的存储权限",
      "或是修改成员方法的返回类型",
      "在继承中还有一种特殊的重写方式",
      "子类与父类的成员方法返回值",
      "方法名称",
      "参数类型及个数完全相同",
      "唯一不同你的就是方法实现内容",
      "这种特殊重写方式被称为重构",
      "创建Subroutine类和两个父类",
      "分别为Parent和SubParent",
      "这三个类的继承关系是Subroutine类继承Subparent类",
      "而Subparent类继承Parent类",
      "分别在这三个类的构造方法中输出构造方法名称来验证继承关系",
      "Eclipse输出如下",
      "调用父类的Parent()构造方法",
      "调用子类的SubParent()构造方法",
      "调用子类的Subroutine()构造方法",
      "运行结果可以看出",
      "在子类Subroutine的主方法中只调用子类的构造方法实例化子类对象",
      "并且在子类构造方法中没有调用父类构造方法的任何语句",
      "但是在实例化子类对象时它相应调用了父类的构造方法",
      "在这个结果中可以看到调用构造方法的顺序",
      "首先是顶级父类",
      "然后是上一级父类",
      "最后才是子类",
      "也就是说",
      "实例化子类对象时首先要实例化父类对象",
      "然后在实例化子类对象",
      "所以在子类构造方法访问父类的构造方法去",
      "父类已经完成实例化操作"
    ],
    "codes": [
      "public class Test {\n\tpublic Test() {\t\t\t\t\t//构造方法\n\t\t//something..\n\t}\n\tprotected void doSomething() {\t//成员方法\n\t\t//something..\n\t}\n\tprotected Test dolt() {\t\t\t//方法返回值类型为Test类型\n\t\treturn new Test();\n\t}\n}\nclass Test2 extends Test{\t\t\t//继承父类\n\tpublic Test2() {\t\t\t\t//构造方法\n\t\tsuper();\t\t\t\t\t//调用父类构造方法\n\t\tsuper.doSomething();\t\t//调用父类成员方法\n\t}\n\tpublic void doSomethingnew() {\t//新增方法\n\t\t//something..\n\t}\n\tpublic void doSomething() {\t\t//重写父类方法\n\t\t//somenewsentence..\n\t}\n\tprotected Test2 dolt() { \t\t//重写父类方法，方法返回类型为Test2类型\n\t\treturn new Test2();\n\t}\n}",
      "public class Parent {\n\tParent(){\t\t\t\t\t\n\t\tSystem.out.println(\"调用父类的Parent()构造方法\");\n\t}\n}\nclass SubParent extends Parent{\n\tSubParent(){\n\t\tSystem.out.println(\"调用子类的SubParent()构造方法\");\n\t}\n}\npublic class Subroutine extends SubParent{\n\tpublic Subroutine() {\n\t\tSystem.out.println(\"调用子类的Subroutine()构造方法\");\n\t\t// TODO 自动生成的构造函数存根\n\t}\n\tpublic static void main(String[] args) {\n\t\tSubroutine s = new Subroutine();\n\t}\n}"
    ],
    "date": "2021-06-29",
    "text": "类的继承\n类的继承，在我理解中有点类似父进程和子进程。\n首先继承的基本思想就是基于某个父类进行扩展，得到一个新的子类，子类可以继承父类原有的属性和方法，相应地，也可以增加原来父类所不具有的属性和方法，或者直接重写父类中的方法。\n举个例子，例如正方形，是特殊的四边形，因为正方形是四个边都相等的四边形，可以说正方形继承了四边形类。这时，正方形继承了平行四边形所有具有的属性和方法，以及可以基于四边形类所增加的新的平行四边形类的属性和方法。\n举例：\n该例子中定义了两个类，其中Test2类继承Test类，可以说Test类为Test2类的父类，Test2为Test的子类。在子类中可以连同初始化父类构造方法来完成子类初始化操作，既可以在子类的构造方法中用super()语句调用父类的构造方法，也可以在子类中使用super关键字调用父类的成员方法等。但是对于父类中的private方法，子类没有权限调用它，只可以调用父类中修饰符为public或者protected的成员方法。例如子类构造方法中可以使用super关键字调用父类的doSomething()方法，因为doSomething方法修饰符为protected。同时在子类中也可以定义一些新的方法，如子类的doSomethingnew（）方法。\n继承并不只是扩展父类的功能，还可以重写父类的成员方法。重写还可以成为覆盖，就是在子类中讲父类的成员方法的名称保留，重写成员方法的实现内容，更改成员方法的存储权限，或是修改成员方法的返回类型。\n在继承中还有一种特殊的重写方式，子类与父类的成员方法返回值，方法名称，参数类型及个数完全相同，唯一不同你的就是方法实现内容，这种特殊重写方式被称为重构。\n创建Subroutine类和两个父类，分别为Parent和SubParent。这三个类的继承关系是Subroutine类继承Subparent类，而Subparent类继承Parent类。分别在这三个类的构造方法中输出构造方法名称来验证继承关系。\nEclipse输出如下\n调用父类的Parent()构造方法\n调用子类的SubParent()构造方法\n调用子类的Subroutine()构造方法\n运行结果可以看出，在子类Subroutine的主方法中只调用子类的构造方法实例化子类对象，并且在子类构造方法中没有调用父类构造方法的任何语句，但是在实例化子类对象时它相应调用了父类的构造方法。在这个结果中可以看到调用构造方法的顺序，首先是顶级父类，然后是上一级父类，最后才是子类。也就是说，实例化子类对象时首先要实例化父类对象，然后在实例化子类对象，所以在子类构造方法访问父类的构造方法去，父类已经完成实例化操作。\n"
  },
  {
    "head": "Java类与类的构造方法以及this关键字",
    "paragraphs": [
      "构造一个类我们需要设定",
      "一个成员方法可以有参数，这个参数可以是对象，也可以是基本数据类型的变量，同时成员方法有返回值和不返回任何值的选择，如果需要返回值，就需要在方法体中使用return关键字，return之后这个方法执行就会被终止。",
      "但是注意返回值一定要与成员方法的返回值类型一样。",
      "权限修饰符：",
      "访问包位置",
      "private",
      "protected",
      "public",
      "同包其他类或子类",
      "不可见",
      "其他包的类或子类",
      "不可见",
      "不可见",
      "默认访问权限：",
      "当我们创建如下没有权限修饰符的类时：",
      "默认修饰符，就是只有一个包内的其他类和子类可以对该类进行访问，而AnyClass类中的doEverything方法被修饰为public权限，但它会跟从Anything的权限。Java语言规定，类的权限设定会约束类成员的权限设定，所以即使把public换成任何诸如private或者没有，效果都是一样的。",
      "this关键字",
      "最开始学的时候对这个this关键字很不熟悉，不知道到底在指代什么。",
      "那么我在此举几个例子",
      "一般而言，类似这种定义我们会发现两个name一个是全局变量，一个是形参，那么当我们想要修改全局变量的时候我们不清楚究竟有没有改变全局变量，因为往往我们都希望通过参数来改变全局变量。",
      "再看另一种用法",
      "此时的应用就是方法的返回值。",
      "类的构造方法：",
      "构造方法的特点：",
      "构造方法没有返回值，构造方法的名称要与本类的名称相同。",
      "book是方法的名称",
      "例子：",
      "看倒定义了两个构造方法，在无参构造方法中可以使用this关键字调用有参的构造方法。但使用这种方式需要注意的是只可以在无参构造方法中的第一句使用this调用有参构造方法。"
    ],
    "sentences": [
      "构造一个类我们需要设定",
      "一个成员方法可以有参数",
      "这个参数可以是对象",
      "也可以是基本数据类型的变量",
      "同时成员方法有返回值和不返回任何值的选择",
      "如果需要返回值",
      "就需要在方法体中使用return关键字",
      "return之后这个方法执行就会被终止",
      "但是注意返回值一定要与成员方法的返回值类型一样",
      "权限修饰符：访问包位置",
      "private",
      "protected",
      "public",
      "同包其他类或子类",
      "不可见",
      "其他包的类或子类",
      "不可见",
      "不可见",
      "默认访问权限：当我们创建如下没有权限修饰符的类时：默认修饰符",
      "就是只有一个包内的其他类和子类可以对该类进行访问",
      "而AnyClass类中的doEverything方法被修饰为public权限",
      "但它会跟从Anything的权限",
      "Java语言规定",
      "类的权限设定会约束类成员的权限设定",
      "所以即使把public换成任何诸如private或者没有",
      "效果都是一样的",
      "this关键字",
      "最开始学的时候对这个this关键字很不熟悉",
      "不知道到底在指代什么",
      "那么我在此举几个例子",
      "一般而言",
      "类似这种定义我们会发现两个name一个是全局变量",
      "一个是形参",
      "那么当我们想要修改全局变量的时候我们不清楚究竟有没有改变全局变量",
      "因为往往我们都希望通过参数来改变全局变量",
      "再看另一种用法",
      "此时的应用就是方法的返回值",
      "类的构造方法：构造方法的特点：构造方法没有返回值",
      "构造方法的名称要与本类的名称相同",
      "book是方法的名称",
      "例子：看倒定义了两个构造方法",
      "在无参构造方法中可以使用this关键字调用有参的构造方法",
      "但使用这种方式需要注意的是只可以在无参构造方法中的第一句使用this调用有参构造方法"
    ],
    "codes": [
      "权限修饰符 返回值类型 方法名(参数类型 参数名)\n{\n    ...//方法体\n    return 返回值;\n}",
      "class Anything{\n    public void doEverything(){\n    ..//方法体\n    }\n}",
      "private void setName(String name){\n    this.name = name;\n}",
      "public Book getBook(){\n    return this; //返回Book类引用\n}    ",
      "public book(){\n    ... //构造方法体\n}",
      "public class Anything{\n    public Anything{\n        this(\"this 调用有参构造方法\");       //定义无参构造方法\n        System.out.println(\"无参构造方法\");  //使用this调用有参构造方法\n    }\n    public Anything(String name){\n        System.out.println(\"有参构造方法\");  //定义有参构造方法\n    }\n}"
    ],
    "date": "2021-07-03",
    "text": "构造一个类我们需要设定\n一个成员方法可以有参数，这个参数可以是对象，也可以是基本数据类型的变量，同时成员方法有返回值和不返回任何值的选择，如果需要返回值，就需要在方法体中使用return关键字，return之后这个方法执行就会被终止。\n但是注意返回值一定要与成员方法的返回值类型一样。\n权限修饰符：\n访问包位置\nprivate\nprotected\npublic\n同包其他类或子类\n不可见\n其他包的类或子类\n不可见\n不可见\n默认访问权限：\n当我们创建如下没有权限修饰符的类时：\n默认修饰符，就是只有一个包内的其他类和子类可以对该类进行访问，而AnyClass类中的doEverything方法被修饰为public权限，但它会跟从Anything的权限。Java语言规定，类的权限设定会约束类成员的权限设定，所以即使把public换成任何诸如private或者没有，效果都是一样的。\nthis关键字\n最开始学的时候对这个this关键字很不熟悉，不知道到底在指代什么。\n那么我在此举几个例子\n一般而言，类似这种定义我们会发现两个name一个是全局变量，一个是形参，那么当我们想要修改全局变量的时候我们不清楚究竟有没有改变全局变量，因为往往我们都希望通过参数来改变全局变量。\n再看另一种用法\n此时的应用就是方法的返回值。\n类的构造方法：\n构造方法的特点：\n构造方法没有返回值，构造方法的名称要与本类的名称相同。\nbook是方法的名称\n例子：\n看倒定义了两个构造方法，在无参构造方法中可以使用this关键字调用有参的构造方法。但使用这种方式需要注意的是只可以在无参构造方法中的第一句使用this调用有参构造方法。\n"
  },
  {
    "head": "如何对HashMap进行排序",
    "paragraphs": [
      "问题描述",
      "这个问题从字面上看会有点奇怪，毕竟HashMap是按哈希值存储元素的，每个元素的位置是固定的，所以无法像list一样可以通过索引值list.get(i)去获取元素，由于位置由哈希值确定，也谈不上排序。",
      "但是，问题就在于确实会遇到一些情形，比如我定义了一个map对象",
      "map是由学生类作为key，整型类作为value的，我的toString函数里面，希望它能够按照Integer（实际意义为分数）的大小进行排序，并返回一个按顺序排列的字符串。",
      "比如下面这个map",
      "打印map.toString()的结果",
      "既不是按照插入顺序，也不是按照我们预期的value大小顺序排列。",
      "所以说直接return map.toString()肯定是不行的，那我怎么能够构造一个字符串表示map，而且是按value大小排列的呢？",
      "解决方案",
      "方法①",
      "首先网上有一些大佬的博客都介绍了用Java8的Streams进行排序，",
      "比如：",
      "输完这行代码，然后直接运行，就会神奇地发现控制台打印出了按value顺序排列的map",
      "然而，这种方法虽然很舒服，但是不能解决我的这个所面临的问题，它不能变成一个可返回的字符串，而是直接打印了出来。",
      "方法②",
      "仍然使用Java8的Streams进行排序，同时借助了LinkedHashMap",
      "这时候，我们打印一下sortedMap",
      "输出结果：",
      "这方法也很舒适，直接调用内置方法，就可以排序了，而且只需改一下参数就能按key排序或者是降序排序，十分快捷。",
      "但是，有时候人就比较作，或者面临的情况很specific，比如说，我不希望这个返回的字符串是xx(Student) = xx(成绩)这种形式输出，但是我们知道，map这种类型的toString就是{key1=value1, key2=value2…}，如果跑到人家库里面的去改写方法，这不太好…或者自己重新写一个类继承map后又重写toString，会比较麻烦。",
      "所以就有了下面这种比较原始的方法，看上去会比之前两个多花点时间，但是结果上灵活性会更强。",
      "方法③",
      "这个方法，说起来很直观，一看就懂，一般也能想到，我称之为“土办法”，也就是定义两个列表，keylist和valuelist，然后按value值对valuelist排序，交换valuelist中元素的同时交换keylist中的元素。也就是同时排序的思想。",
      "同时排序使得将原有map分解为：两个索引值对应的list，那么我们就可以按大小顺序对list中的值操作，灵活性会比较高。",
      "打印一下s，输出结果：",
      "参考链接",
      "如何对HashMap进行排序"
    ],
    "sentences": [
      "问题描述",
      "这个问题从字面上看会有点奇怪",
      "毕竟HashMap是按哈希值存储元素的",
      "每个元素的位置是固定的",
      "所以无法像list一样可以通过索引值list.get(i)去获取元素",
      "由于位置由哈希值确定",
      "也谈不上排序",
      "但是",
      "问题就在于确实会遇到一些情形",
      "比如我定义了一个map对象",
      "map是由学生类作为key",
      "整型类作为value的",
      "我的toString函数里面",
      "希望它能够按照Integer（实际意义为分数）的大小进行排序",
      "并返回一个按顺序排列的字符串",
      "比如下面这个map",
      "打印map.toString()的结果",
      "既不是按照插入顺序",
      "也不是按照我们预期的value大小顺序排列",
      "所以说直接return map.toString()肯定是不行的",
      "那我怎么能够构造一个字符串表示map",
      "而且是按value大小排列的呢？",
      "解决方案",
      "方法①",
      "首先网上有一些大佬的博客都介绍了用Java8的Streams进行排序",
      "比如：输完这行代码",
      "然后直接运行",
      "就会神奇地发现控制台打印出了按value顺序排列的map",
      "然而",
      "这种方法虽然很舒服",
      "但是不能解决我的这个所面临的问题",
      "它不能变成一个可返回的字符串",
      "而是直接打印了出来",
      "方法②",
      "仍然使用Java8的Streams进行排序",
      "同时借助了LinkedHashMap",
      "这时候，我们打印一下sortedMap",
      "输出结果：这方法也很舒适",
      "直接调用内置方法",
      "就可以排序了",
      "而且只需改一下参数就能按key排序或者是降序排序",
      "十分快捷",
      "但是",
      "有时候人就比较作",
      "或者面临的情况很specific",
      "比如说",
      "我不希望这个返回的字符串是xx(Student) = xx(成绩)这种形式输出",
      "但是我们知道",
      "map这种类型的toString就是{key1=value1, key2=value2…}",
      "如果跑到人家库里面的去改写方法",
      "这不太好…或者自己重新写一个类继承map后又重写toString",
      "会比较麻烦",
      "所以就有了下面这种比较原始的方法",
      "看上去会比之前两个多花点时间",
      "但是结果上灵活性会更强",
      "方法③",
      "这个方法",
      "说起来很直观",
      "一看就懂",
      "一般也能想到",
      "我称之为“土办法”",
      "也就是定义两个列表",
      "keylist和valuelist",
      "然后按value值对valuelist排序",
      "交换valuelist中元素的同时交换keylist中的元素",
      "也就是同时排序的思想",
      "同时排序使得将原有map分解为：两个索引值对应的list",
      "那么我们就可以按大小顺序对list中的值操作",
      "灵活性会比较高",
      "打印一下s，输出结果：参考链接",
      "如何对HashMap进行排序"
    ],
    "codes": [
      "Map<Student, Integer> map = new HashMap<>();\n",
      "\t\tMap<Student, Integer> map = new HashMap<>();\n\t\tStudent a = new Student(\"a\");\n\t\tStudent b = new Student(\"b\");\n\t\tStudent c = new Student(\"c\");\n\t\tmap.put(a, 78);\n\t\tmap.put(c,60);\n\t\tmap.put(b,99);\n",
      "{[Student name:a]=78, [Student name:b]=99, [Student name:c]=60}\n",
      "map.entrySet().stream().sorted((e1, e2) -> e1.getValue().compareTo(e2.getValue())).forEach(System.out::println);\n",
      "Map<Student, Integer> sortedMap = map.entrySet()\n\t            .stream()\n\t            .sorted(Map.Entry.comparingByValue())\n\t            .collect(Collectors\n\t              .toMap(Map.Entry::getKey,\n\t                     Map.Entry::getValue,\n\t                     (e1, e2) -> e1,\n\t                     LinkedHashMap::new));\n",
      "String s = sortedMap.toString();\nSystem.out.println(s);\n",
      "\t\tString s = \"{\";\n\t\t\n\t\tList<Student> keylist = new ArrayList<>();\n\t\tList<Integer> valuelist = new ArrayList<>();\n\t\tfor(Map.Entry<Student, Integer> entry : map.entrySet()) {\n\t\t\tkeylist.add(entry.getKey());\n\t\t\tvaluelist.add(entry.getValue());\n\t\t}//初始化keylist和valuelist\n\t\t\n\t\tfor(int i=0; i<valuelist.size(); i++) {\n\t\t\tint minpos = i;\n\t\t\tInteger min = valuelist.get(i);\n\t\t\tfor(int j=i+1; j<valuelist.size(); j++) {\n\t\t\t\tif(valuelist.get(j).compareTo(min)<0) {\n\t\t\t\t\tminpos = j;\n\t\t\t\t\tmin = valuelist.get(j);\n\t\t\t\t} \n\t\t\t}//选择排序（按值排序）\n\t\t\tif(minpos!=i) {\n\t\t\t\tInteger temp = valuelist.get(i);\n\t\t\t\tvaluelist.set(i, min);\n\t\t\t\tvaluelist.set(minpos, temp);//valuelist排序\n\t\t\t\tStudent templ = keylist.get(i);\n\t\t\t\tkeylist.set(i, keylist.get(minpos));\n\t\t\t\tkeylist.set(minpos, templ);//同时排序keylist\n\t\t\t}\n\t\t}\n\t\t\n\t\t//个性化操作\n\t\tfor(int i=0; i<keylist.size(); i++) {\n\t\t\ts += keylist.get(i)+\" \\t对应成绩=\";\n\t\t\ts += valuelist.get(i);\n\t\t\tif(i < keylist.size()-1) s+=\",\\n\";\n\t\t}\n\t\ts+=\"}\";\n"
    ],
    "date": "2021-07-06",
    "text": "问题描述\n这个问题从字面上看会有点奇怪，毕竟HashMap是按哈希值存储元素的，每个元素的位置是固定的，所以无法像list一样可以通过索引值list.get(i)去获取元素，由于位置由哈希值确定，也谈不上排序。\n但是，问题就在于确实会遇到一些情形，比如我定义了一个map对象\nmap是由学生类作为key，整型类作为value的，我的toString函数里面，希望它能够按照Integer（实际意义为分数）的大小进行排序，并返回一个按顺序排列的字符串。\n比如下面这个map\n打印map.toString()的结果\n既不是按照插入顺序，也不是按照我们预期的value大小顺序排列。\n所以说直接return map.toString()肯定是不行的，那我怎么能够构造一个字符串表示map，而且是按value大小排列的呢？\n解决方案\n方法①\n首先网上有一些大佬的博客都介绍了用Java8的Streams进行排序，\n比如：\n输完这行代码，然后直接运行，就会神奇地发现控制台打印出了按value顺序排列的map\n然而，这种方法虽然很舒服，但是不能解决我的这个所面临的问题，它不能变成一个可返回的字符串，而是直接打印了出来。\n方法②\n仍然使用Java8的Streams进行排序，同时借助了LinkedHashMap\n这时候，我们打印一下sortedMap\n输出结果：\n这方法也很舒适，直接调用内置方法，就可以排序了，而且只需改一下参数就能按key排序或者是降序排序，十分快捷。\n但是，有时候人就比较作，或者面临的情况很specific，比如说，我不希望这个返回的字符串是xx(Student) = xx(成绩)这种形式输出，但是我们知道，map这种类型的toString就是{key1=value1, key2=value2…}，如果跑到人家库里面的去改写方法，这不太好…或者自己重新写一个类继承map后又重写toString，会比较麻烦。\n所以就有了下面这种比较原始的方法，看上去会比之前两个多花点时间，但是结果上灵活性会更强。\n方法③\n这个方法，说起来很直观，一看就懂，一般也能想到，我称之为“土办法”，也就是定义两个列表，keylist和valuelist，然后按value值对valuelist排序，交换valuelist中元素的同时交换keylist中的元素。也就是同时排序的思想。\n同时排序使得将原有map分解为：两个索引值对应的list，那么我们就可以按大小顺序对list中的值操作，灵活性会比较高。\n打印一下s，输出结果：\n参考链接\n如何对HashMap进行排序\n"
  },
  {
    "head": "Java_如何编写自己的泛型类",
    "paragraphs": [
      "泛型，即",
      "参数化类型",
      "，类似于方法中将",
      "参数化，泛型是将原来定义的具体的",
      "参数化。",
      "使用泛型的需求",
      "Java中为什么要使用泛型，是因为泛型使用起来非常之方便，泛型类/方法针对于面向",
      "的开发。当我们想让一个类/方法同时",
      "于多种数据类型，这将大大省去我们编写重复代码的时间。",
      "举一个常见的例子说明：",
      "其中List接口以及类ArrayList均使用了泛型，从而可以构造出接收以类型Integer, String为参数的list；",
      "所以下面的add操作中可以用不同类型的变量作为参数（用泛型可以省去重载方法的开销）：",
      "分别输出为[1, 2][a, b]",
      "泛型应用场景",
      "可以看到，除了部分底层的实现类，上层的类/抽象类/接口基本都是用泛型实现的，用泛型实现能够很好地进行复用，比如这里的L可以是Employee，Course，Process，从而派生出三个具体子类DutyIntervalSet，CourseIntervalSet，ProcessIntervalSet。",
      "下面我们将以上图为例介绍如何编写一个自己的泛型类。",
      "如何编写自己的泛型类",
      "我们以MultiIntervalSet为例进行分析：",
      "编写面向泛型的类时需要注意以下几点：",
      "①泛型类的声明：需要在类名后加上",
      "<L>",
      "②需要用到泛型的地方，全部用",
      "③只能对定义为泛型的变量做一些",
      "通用的操作",
      "对于一个L label的泛型变量label，可以对它进行list.add(label)，set.contains(label)等操作，由于它在具体传入的时候已经变成了一个具体的类。但是想要显式地调用它自己的方法只能调用如下几种（此时感觉label就是一个原始的Object类）：",
      "要小心，不要代入某个具体的类型，调用它特有的方法；",
      "所以这也是泛型的一个局限性，对于通用的操作可以复用，但如果要用到某个具体类的方法，则不能将该类型作为参数传递。",
      "④泛型类中可以有非泛型方法，也可以有非泛型的成员变量。",
      "这点很好理解，泛型类中不一定每个方法都需要用到泛型，用到泛型时才是泛型方法；同时泛型类中当然也可以有具体类型的成员变量。",
      "最后给出一个泛型方法的例子",
      "总之，写泛型类的时候要保持平常心，将",
      "当作一个普通的类型去编写代码，开始时不要因为觉得",
      "的写法陌生，而不敢对它进行操作，或者不愿意自定义泛型类/方法。",
      "补充介绍：类型通配符",
      "类型通配符一般是使用",
      "代替具体的类型参数。例如",
      "List<?>",
      "在逻辑上是",
      "List<String>",
      "List<Integer>",
      "等所有List<具体类型实参>的父类。",
      "①在某些情况下，我们必须使用到类型通配符，否则静态编译时会报错：",
      "比如：重写equals函数时用到",
      "instanceof",
      "运算符",
      "编译报错：Cannot perform instanceof check against parameterized type Edge. Use the form Edge<?> instead since further generic type information will be erased at runtime",
      "修改为下图所示，编译通过。",
      "②类型通配符还可以用于特定的情形",
      "比如限定类型的上/下限：",
      "List<? extends Number>",
      "限定接收类型的上限为Number，接受Number及其下层子类类型",
      "List<? super Number>",
      "限定接收类型的下限为Number，接受Number及其三层父类类型，如 Object 类型的实例。"
    ],
    "sentences": [
      "泛型，即",
      "参数化类型",
      "，类似于方法中将",
      "参数化，泛型是将原来定义的具体的",
      "参数化",
      "使用泛型的需求",
      "Java中为什么要使用泛型",
      "是因为泛型使用起来非常之方便",
      "泛型类/方法针对于面向",
      "的开发",
      "当我们想让一个类/方法同时",
      "于多种数据类型，这将大大省去我们编写重复代码的时间",
      "举一个常见的例子说明：其中List接口以及类ArrayList均使用了泛型",
      "从而可以构造出接收以类型Integer, String为参数的list；所以下面的add操作中可以用不同类型的变量作为参数（用泛型可以省去重载方法的开销）：分别输出为[1, 2][a, b]",
      "泛型应用场景",
      "可以看到",
      "除了部分底层的实现类",
      "上层的类/抽象类/接口基本都是用泛型实现的",
      "用泛型实现能够很好地进行复用",
      "比如这里的L可以是Employee",
      "Course",
      "Process",
      "从而派生出三个具体子类DutyIntervalSet",
      "CourseIntervalSet",
      "ProcessIntervalSet",
      "下面我们将以上图为例介绍如何编写一个自己的泛型类",
      "如何编写自己的泛型类",
      "我们以MultiIntervalSet为例进行分析：编写面向泛型的类时需要注意以下几点：①泛型类的声明：需要在类名后加上",
      "<L>",
      "②需要用到泛型的地方，全部用",
      "③只能对定义为泛型的变量做一些",
      "通用的操作",
      "对于一个L label的泛型变量label",
      "可以对它进行list.add(label)",
      "set.contains(label)等操作",
      "由于它在具体传入的时候已经变成了一个具体的类",
      "但是想要显式地调用它自己的方法只能调用如下几种（此时感觉label就是一个原始的Object类）：要小心",
      "不要代入某个具体的类型",
      "调用它特有的方法；所以这也是泛型的一个局限性",
      "对于通用的操作可以复用",
      "但如果要用到某个具体类的方法",
      "则不能将该类型作为参数传递",
      "④泛型类中可以有非泛型方法，也可以有非泛型的成员变量",
      "这点很好理解",
      "泛型类中不一定每个方法都需要用到泛型",
      "用到泛型时才是泛型方法；同时泛型类中当然也可以有具体类型的成员变量",
      "最后给出一个泛型方法的例子",
      "总之，写泛型类的时候要保持平常心，将",
      "当作一个普通的类型去编写代码，开始时不要因为觉得",
      "的写法陌生，而不敢对它进行操作，或者不愿意自定义泛型类/方法",
      "补充介绍：类型通配符",
      "类型通配符一般是使用",
      "代替具体的类型参数",
      "例如",
      "List<?>",
      "在逻辑上是",
      "List<String>",
      "List<Integer>",
      "等所有List<具体类型实参>的父类",
      "①在某些情况下",
      "我们必须使用到类型通配符",
      "否则静态编译时会报错：比如：重写equals函数时用到",
      "instanceof",
      "运算符",
      "编译报错：Cannot perform instanceof check against parameterized type Edge. Use the form Edge<?> instead since further generic type information will be erased at runtime",
      "修改为下图所示，编译通过",
      "②类型通配符还可以用于特定的情形",
      "比如限定类型的上/下限：List<? extends Number>",
      "限定接收类型的上限为Number",
      "接受Number及其下层子类类型",
      "List<? super Number>",
      "限定接收类型的下限为Number",
      "接受Number及其三层父类类型",
      "如 Object 类型的实例"
    ],
    "codes": [
      "List<Integer> ilist = new ArrayList<Integer>();\nList<String>  slist = new ArrayList<String>();\n",
      "ilist.add(1);\nilist.add(2);\nSystem.out.println(ilist);\n",
      "slist.add(\"a\");\nslist.add(\"b\");\nSystem.out.println(slist);\n",
      "public class MultiIntervalSet<L> implements IMultiIntervalSet<L>\n",
      "protected final Set<L> elabel = new HashSet<>();\nprotected final Map<L, List<Interval>> emap = new HashMap<>();\n",
      "protected final Set<L> elabel = new HashSet<>();\nprotected final Map<L, List<Interval>> emap = new HashMap<>();\nprotected Interval duration;\n",
      "public boolean remove(L label) {\n\t\tif(!elabel.contains(label)) return false;\n\t\telse {\n\t\t\temap.remove(label);\n\t\t\telabel.remove(label);\n\t\t\tcheckRep();\n\t\t\treturn true;\n\t\t}\n\t}\n",
      "@Override public boolean equals(Object obj) {\n    \tif(obj instanceof Edge<L>) {\n\t\t\tEdge<L> e = (Edge<L>)obj;\n\t\t//...后续逻辑省略\t\n",
      "if(obj instanceof Edge<?>) {\n\t\t\tEdge<?> e = (Edge<?>)obj;\n"
    ],
    "date": "2021-07-06",
    "text": "泛型，即\n参数化类型\n，类似于方法中将\n参数化，泛型是将原来定义的具体的\n参数化。\n使用泛型的需求\nJava中为什么要使用泛型，是因为泛型使用起来非常之方便，泛型类/方法针对于面向\n的开发。当我们想让一个类/方法同时\n于多种数据类型，这将大大省去我们编写重复代码的时间。\n举一个常见的例子说明：\n其中List接口以及类ArrayList均使用了泛型，从而可以构造出接收以类型Integer, String为参数的list；\n所以下面的add操作中可以用不同类型的变量作为参数（用泛型可以省去重载方法的开销）：\n分别输出为[1, 2][a, b]\n泛型应用场景\n可以看到，除了部分底层的实现类，上层的类/抽象类/接口基本都是用泛型实现的，用泛型实现能够很好地进行复用，比如这里的L可以是Employee，Course，Process，从而派生出三个具体子类DutyIntervalSet，CourseIntervalSet，ProcessIntervalSet。\n下面我们将以上图为例介绍如何编写一个自己的泛型类。\n如何编写自己的泛型类\n我们以MultiIntervalSet为例进行分析：\n编写面向泛型的类时需要注意以下几点：\n①泛型类的声明：需要在类名后加上\n<L>\n②需要用到泛型的地方，全部用\n③只能对定义为泛型的变量做一些\n通用的操作\n对于一个L label的泛型变量label，可以对它进行list.add(label)，set.contains(label)等操作，由于它在具体传入的时候已经变成了一个具体的类。但是想要显式地调用它自己的方法只能调用如下几种（此时感觉label就是一个原始的Object类）：\n要小心，不要代入某个具体的类型，调用它特有的方法；\n所以这也是泛型的一个局限性，对于通用的操作可以复用，但如果要用到某个具体类的方法，则不能将该类型作为参数传递。\n④泛型类中可以有非泛型方法，也可以有非泛型的成员变量。\n这点很好理解，泛型类中不一定每个方法都需要用到泛型，用到泛型时才是泛型方法；同时泛型类中当然也可以有具体类型的成员变量。\n最后给出一个泛型方法的例子\n总之，写泛型类的时候要保持平常心，将\n当作一个普通的类型去编写代码，开始时不要因为觉得\n的写法陌生，而不敢对它进行操作，或者不愿意自定义泛型类/方法。\n补充介绍：类型通配符\n类型通配符一般是使用\n代替具体的类型参数。例如\nList<?>\n在逻辑上是\nList<String>\nList<Integer>\n等所有List<具体类型实参>的父类。\n①在某些情况下，我们必须使用到类型通配符，否则静态编译时会报错：\n比如：重写equals函数时用到\ninstanceof\n运算符\n编译报错：Cannot perform instanceof check against parameterized type Edge. Use the form Edge<?> instead since further generic type information will be erased at runtime\n修改为下图所示，编译通过。\n②类型通配符还可以用于特定的情形\n比如限定类型的上/下限：\nList<? extends Number>\n限定接收类型的上限为Number，接受Number及其下层子类类型\nList<? super Number>\n限定接收类型的下限为Number，接受Number及其三层父类类型，如 Object 类型的实例。\n"
  },
  {
    "head": "取消Pytorch警告",
    "paragraphs": [
      "问题描述",
      "在训练模型过程中，打印损失函数值的过程中如果出现很多如下警告信息，非常影响观感和对比。",
      "警告信息为：UserWarning: size_average and reduce args will be deprecated,please use reduction=‘mean’ instead. warnings.warn(warning.format(ret))",
      "为pytorch不同版本进行更新迭代时引起的警告，某些参数被取代了",
      "更多细节参考",
      "Pytorch版本代码修正",
      "解决方案",
      "其它损失函数更改方法类似",
      "更改后效果：没了警告看着就很舒适",
      "注：此处如果使用如下代码来取消全文警告，仍然会打印警告信息。",
      "更多问题修正参考",
      "更多pytorch不同版本进行更新迭代时引起的警告，在下面这个链接中总结了对应的修正方法。",
      "Pytorch版本代码修正"
    ],
    "sentences": [
      "问题描述",
      "在训练模型过程中",
      "打印损失函数值的过程中如果出现很多如下警告信息",
      "非常影响观感和对比",
      "警告信息为：UserWarning: size_average and reduce args will be deprecated,please use reduction=‘mean’ instead. warnings.warn(warning.format(ret))",
      "为pytorch不同版本进行更新迭代时引起的警告",
      "某些参数被取代了",
      "更多细节参考",
      "Pytorch版本代码修正",
      "解决方案",
      "其它损失函数更改方法类似",
      "更改后效果：没了警告看着就很舒适",
      "注：此处如果使用如下代码来取消全文警告，仍然会打印警告信息",
      "更多问题修正参考",
      "更多pytorch不同版本进行更新迭代时引起的警告",
      "在下面这个链接中总结了对应的修正方法",
      "Pytorch版本代码修正"
    ],
    "codes": [
      "criterion = torch.nn.BCELoss(size_average=True)\n改为：\ncriterion = torch.nn.BCELoss(reduction='mean')\n",
      "criterion = torch.nn.BCELoss(size_average=False)\n改为：\ncriterion = torch.nn.BCELoss(reduction='sum')\n",
      "import warnings\nwarnings.filterwarnings(\"ignore\")\n"
    ],
    "date": "2021-07-26",
    "text": "问题描述\n在训练模型过程中，打印损失函数值的过程中如果出现很多如下警告信息，非常影响观感和对比。\n警告信息为：UserWarning: size_average and reduce args will be deprecated,please use reduction=‘mean’ instead. warnings.warn(warning.format(ret))\n为pytorch不同版本进行更新迭代时引起的警告，某些参数被取代了\n更多细节参考\nPytorch版本代码修正\n解决方案\n其它损失函数更改方法类似\n更改后效果：没了警告看着就很舒适\n注：此处如果使用如下代码来取消全文警告，仍然会打印警告信息。\n更多问题修正参考\n更多pytorch不同版本进行更新迭代时引起的警告，在下面这个链接中总结了对应的修正方法。\nPytorch版本代码修正\n"
  },
  {
    "head": "如何用Junit测试",
    "paragraphs": [
      "文章目录",
      "导入JUnit的包",
      "新建一个Junit测试类",
      "测试用例",
      "运行测试类",
      "导入JUnit的包",
      "右键点击java项目→Build Path → Configure Build Path",
      "Add Library → JUnit",
      "选择Junit的版本→ Finish → Apply and close",
      "新建一个Junit测试类",
      "在java包上点击右键→New→Other（讲道理熟悉了以后，直接new一个普通的class，再自己导入junit包和这个操作也是一样的）",
      "选择Junit Test Case",
      "给测试类取名，选择class under test",
      "点击Finish",
      "测试用例",
      "测试策略",
      "（划分等价类，或者用边界值分析的思想）",
      "测试方法前用",
      "@Test",
      "assertTrue(),assertFalse(),assertEquals(预期值，测试值)",
      "等方法对结果进行测试",
      "需要测试抛出异常的方法，",
      "@Test(expected=xxx异常.class)",
      "运行测试类",
      "右键点击测试类 → Run As → JUnit Test",
      "绿色表示测试通过，如果是红色或者蓝色则测试失败，需要根据报错提示对源代码修改。"
    ],
    "sentences": [
      "文章目录",
      "导入JUnit的包",
      "新建一个Junit测试类",
      "测试用例",
      "运行测试类",
      "导入JUnit的包",
      "右键点击java项目→Build Path → Configure Build Path",
      "Add Library → JUnit",
      "选择Junit的版本→ Finish → Apply and close",
      "新建一个Junit测试类",
      "在java包上点击右键→New→Other（讲道理熟悉了以后",
      "直接new一个普通的class",
      "再自己导入junit包和这个操作也是一样的）",
      "选择Junit Test Case",
      "给测试类取名，选择class under test",
      "点击Finish",
      "测试用例",
      "测试策略",
      "（划分等价类，或者用边界值分析的思想）",
      "测试方法前用",
      "@Test",
      "assertTrue(),assertFalse(),assertEquals(预期值",
      "测试值)",
      "等方法对结果进行测试",
      "需要测试抛出异常的方法",
      "@Test(expected=xxx异常.class)",
      "运行测试类",
      "右键点击测试类 → Run As → JUnit Test",
      "绿色表示测试通过",
      "如果是红色或者蓝色则测试失败",
      "需要根据报错提示对源代码修改"
    ],
    "codes": [
      "//insert():\n//测试策略\n//插入标签在时间集合中(非法插入);\n//插入标签不在集合中:插入时间不合法(end < start);插入时间合法（合法插入）\n@Test\npublic void testInsert() {\n\tIntervalSet<Employee> iset = emptyInstance(20210101, 20210305);\n\tlong start = 20210101;\n\tlong end = 20210203;\n\tEmployee label1 = new Employee(\"a\", \"manager\", 18846451368L);\n\tEmployee label2 = new Employee(\"b\", \"worker\", 16548751663L);\n\tassertTrue(iset.insert(start, end, label1));//合法插入\n\tassertTrue(iset.labels().contains(label1));\n\tSystem.out.println(\"预期插入出错测试方法：testInsert()\");\n\tassertFalse(iset.insert(start+1, end+1, label1));//标签重复\n\tassertFalse(iset.insert(end, start, label2));//插入时间不合法，起始时间>终止时间\n}\n",
      " @Test(expected = IntervalBlankException.class)\n\tpublic void testBlank() throws IntervalBlankException {\n\t\tlong pstart = 20210110L;\n\t\tlong pend = 20210306L;\n\t\tDutyIntervalSet diset = new DutyIntervalSet(new CommonIntervalSet1<Employee>(pstart, pend));\n\t\tEmployee a = new Employee(\"ZhangSan\", \"Manager\", 13904510000L);\n\t\tdiset.insert(20210112L, 20210131L, a);\n\t\tdiset.checkifBlank();//预期结果：调用checkifBlank方法抛出IntervalBlankException的异常\n\t}\n"
    ],
    "date": "2021-07-06",
    "text": "文章目录\n导入JUnit的包\n新建一个Junit测试类\n测试用例\n运行测试类\n导入JUnit的包\n右键点击java项目→Build Path → Configure Build Path\nAdd Library → JUnit\n选择Junit的版本→ Finish → Apply and close\n新建一个Junit测试类\n在java包上点击右键→New→Other（讲道理熟悉了以后，直接new一个普通的class，再自己导入junit包和这个操作也是一样的）\n选择Junit Test Case\n给测试类取名，选择class under test\n点击Finish\n测试用例\n测试策略\n（划分等价类，或者用边界值分析的思想）\n测试方法前用\n@Test\nassertTrue(),assertFalse(),assertEquals(预期值，测试值)\n等方法对结果进行测试\n需要测试抛出异常的方法，\n@Test(expected=xxx异常.class)\n运行测试类\n右键点击测试类 → Run As → JUnit Test\n绿色表示测试通过，如果是红色或者蓝色则测试失败，需要根据报错提示对源代码修改。\n"
  },
  {
    "head": "GPT模型中的计算",
    "paragraphs": [
      "计算步骤",
      "模型框架",
      "Embedding",
      "多层transformer的block (12层)",
      "拿到两个输出端结果",
      "计算损失",
      "反向传播",
      "更新参数",
      "下面主要介绍上述步骤中的",
      "Embedding和",
      "transformer的block层",
      "Embedding",
      "Embedding层就是以one hot为输入、中间层节点为字向量维数的全连接层。而这个全连接层的参数，就是一个“字向量表”。实现text输入维度的变换。",
      "Embedding操作（此处指text embedding）实际上是一个查表操作，one hot型的矩阵相乘，就像是相当于查表，于是它直接用查表作为操作，而不写成矩阵再运算，这大大降低了运算量。再次强调，降低了运算量不是因为词向量的出现，而是因为把one hot型的矩阵运算简化为了查表操作。",
      "代码部分",
      "包括text embed和position embed",
      "text embed",
      "text embed部分调用nn.Embedding，构造词/段向量矩阵，查表实现降维。",
      "position embed",
      "position embed则是初始化一个包含输入序列长度作为维度的矩阵，然后作为参数训练学习位置信息。",
      "Transformer的block层",
      "由右上图知，GPT包含的block和Transformer的Decoder比较像，每个block包含两个子层：",
      "Sublayer1：Masked Multi-Head Attention（mask多头注意力层）",
      "Sublayer2：Feed Forward Network（FFN层）",
      "每一个子层后均有残差连接和归一化操作",
      "sublayer1：mask多头注意力层",
      "输入:",
      "q, k, v, mask",
      "计算注意力(如下图左所示)：",
      "Linear(矩阵乘法)",
      "Scaled Dot-Product Attention",
      "Concat(多个注意力的结果)",
      "Linear(矩阵乘法)",
      "残差连接和归一化操作：",
      "Dropout操作 → 残差连接 → 层归一化操作",
      "我们以上图中的左图介绍整个注意力层的计算过程",
      "矩阵乘法",
      "将输入的Q，K，V与矩阵作乘法，得到新的Q，K，V",
      "Scaled Dot-Product Attention",
      "这个操作名字看起来很长，实际上是 点乘+缩放+mask(可选)+Softmax+点乘 来计算注意力值的过程",
      "第一步：Q与K的转置进行点乘，计算Q和K的相似度",
      "第二步：缩放，除以一个比例因子",
      "第三步：Mask矩阵中一部分值（可选，GPT中有此操作）",
      "第四步：Softmax，转化为每个token的概率",
      "第五步：Softmax后的矩阵值点乘V值，每个value通过概率加权，得到注意力分数。",
      "补充：",
      "Mask操作：masked_fill_(mask, value)",
      "掩码操作，用value填充tensor中与mask中值为1位置相对应的元素。mask的形状必须与要填充的tensor形状一致。（这里采用-inf填充，从而softmax之后变成0，相当于看不见后面的词）",
      "transformer中的mask操作",
      "mask后可视化矩阵：",
      "直观理解是每个词只能看到它之前的词（因为目的就是要预测未来的词嘛，要是看到了就不用预测了）",
      "Concat操作",
      "综合多个注意力头的结果，实际上是对矩阵做变换：permute，reshape操作，视具体情况降维。（如下图红框中所示）",
      "矩阵乘法",
      "一个Linear层，对注意力结果线性变换",
      "整个mask多头注意力层的代码",
      "注意到，最后进行了残差连接和归一化操作，包括：",
      "Dropout操作",
      "残差连接",
      "层归一化操作",
      "sublayer2：FFN前馈网络",
      "主要是一个多层感知机结构",
      "线性层（矩阵乘法）",
      "relu函数激活",
      "线性层（矩阵乘法）",
      "之后同样进行了残差连接和归一化操作，包括：",
      "Dropout操作",
      "残差连接",
      "层归一化操作"
    ],
    "sentences": [
      "计算步骤",
      "模型框架",
      "Embedding",
      "多层transformer的block (12层)",
      "拿到两个输出端结果",
      "计算损失",
      "反向传播",
      "更新参数",
      "下面主要介绍上述步骤中的",
      "Embedding和",
      "transformer的block层",
      "Embedding",
      "Embedding层就是以one hot为输入、中间层节点为字向量维数的全连接层",
      "而这个全连接层的参数，就是一个“字向量表”",
      "实现text输入维度的变换",
      "Embedding操作（此处指text embedding）实际上是一个查表操作",
      "one hot型的矩阵相乘",
      "就像是相当于查表",
      "于是它直接用查表作为操作",
      "而不写成矩阵再运算",
      "这大大降低了运算量",
      "再次强调",
      "降低了运算量不是因为词向量的出现",
      "而是因为把one hot型的矩阵运算简化为了查表操作",
      "代码部分",
      "包括text embed和position embed",
      "text embed",
      "text embed部分调用nn.Embedding",
      "构造词/段向量矩阵",
      "查表实现降维",
      "position embed",
      "position embed则是初始化一个包含输入序列长度作为维度的矩阵",
      "然后作为参数训练学习位置信息",
      "Transformer的block层",
      "由右上图知",
      "GPT包含的block和Transformer的Decoder比较像",
      "每个block包含两个子层：Sublayer1：Masked Multi-Head Attention（mask多头注意力层）",
      "Sublayer2：Feed Forward Network（FFN层）",
      "每一个子层后均有残差连接和归一化操作",
      "sublayer1：mask多头注意力层",
      "输入:q, k, v, mask",
      "计算注意力(如下图左所示)：Linear(矩阵乘法)",
      "Scaled Dot-Product Attention",
      "Concat(多个注意力的结果)",
      "Linear(矩阵乘法)",
      "残差连接和归一化操作：Dropout操作 → 残差连接 → 层归一化操作",
      "我们以上图中的左图介绍整个注意力层的计算过程",
      "矩阵乘法",
      "将输入的Q，K，V与矩阵作乘法，得到新的Q，K，V",
      "Scaled Dot-Product Attention",
      "这个操作名字看起来很长",
      "实际上是 点乘+缩放+mask(可选)+Softmax+点乘 来计算注意力值的过程",
      "第一步：Q与K的转置进行点乘，计算Q和K的相似度",
      "第二步：缩放，除以一个比例因子",
      "第三步：Mask矩阵中一部分值（可选，GPT中有此操作）",
      "第四步：Softmax，转化为每个token的概率",
      "第五步：Softmax后的矩阵值点乘V值",
      "每个value通过概率加权",
      "得到注意力分数",
      "补充：Mask操作：masked_fill_(mask, value)",
      "掩码操作",
      "用value填充tensor中与mask中值为1位置相对应的元素",
      "mask的形状必须与要填充的tensor形状一致",
      "（这里采用-inf填充",
      "从而softmax之后变成0",
      "相当于看不见后面的词）",
      "transformer中的mask操作",
      "mask后可视化矩阵：直观理解是每个词只能看到它之前的词（因为目的就是要预测未来的词嘛",
      "要是看到了就不用预测了）",
      "Concat操作",
      "综合多个注意力头的结果",
      "实际上是对矩阵做变换：permute",
      "reshape操作",
      "视具体情况降维",
      "（如下图红框中所示）",
      "矩阵乘法",
      "一个Linear层，对注意力结果线性变换",
      "整个mask多头注意力层的代码",
      "注意到",
      "最后进行了残差连接和归一化操作",
      "包括：Dropout操作",
      "残差连接",
      "层归一化操作",
      "sublayer2：FFN前馈网络",
      "主要是一个多层感知机结构",
      "线性层（矩阵乘法）",
      "relu函数激活",
      "线性层（矩阵乘法）",
      "之后同样进行了残差连接和归一化操作，包括：Dropout操作",
      "残差连接",
      "层归一化操作"
    ],
    "codes": [
      " def input_emb(self,seqs, segs):\n        # device = next(self.parameters()).device\n        # self.position_emb = self.position_emb.to(device)\n        return self.word_emb(seqs) + self.segment_emb(segs) + self.position_emb\n",
      "self.word_emb = nn.Embedding(n_vocab,model_dim)\nself.word_emb.weight.data.normal_(0,0.1)\n\nself.segment_emb = nn.Embedding(num_embeddings= max_seg, embedding_dim=model_dim)\nself.segment_emb.weight.data.normal_(0,0.1)\n",
      "self.position_emb = torch.empty(1,max_len,model_dim)\nnn.init.kaiming_normal_(self.position_emb,mode='fan_out', nonlinearity='relu')\nself.position_emb = nn.Parameter(self.position_emb)\n",
      "context = torch.matmul(self.attention,v)    # [n, num_head, step, head_dim]\ncontext = context.permute(0,2,1,3)          # [n, step, num_head, head_dim]\ncontext = context.reshape((context.shape[0], context.shape[1],-1))  \nreturn context  # [n, step, model_dim]\n",
      "def forward(self,q,k,v,mask,training):\n        # residual connect\n        residual = q\n        dim_per_head= self.head_dim\n        num_heads = self.n_head\n        batch_size = q.size(0)\n\n        # 1.线性变换，linear projection\n        key = self.wk(k)    # [n, step, num_heads * head_dim]\n        value = self.wv(v)  # [n, step, num_heads * head_dim]\n        query = self.wq(q)  # [n, step, num_heads * head_dim]\n\n        # split by head\n        query = self.split_heads(query)       # [n, n_head, q_step, h_dim]\n        key = self.split_heads(key)\n        value = self.split_heads(value)  # [n, h, step, h_dim]\n        \n        #2.3 Scaled Dot-Product Attention计算注意力分数 + Concat连接多头注意力\n        context = self.scaled_dot_product_attention(query,key, value, mask)    # [n, q_step, h*dv]\n        \n        #4.Linear层，对注意力结果线性变换\n        o = self.o_dense(context)   # [n, step, dim]\n        \n        #残差连接和归一化操作\n        o = self.o_drop(o)\n        o = self.layer_norm(residual+o)\n        return o\n",
      "class PositionWiseFFN(nn.Module):\n    def __init__(self,model_dim, dropout = 0.0):\n        super().__init__()\n        dff = model_dim*4\n        self.l = nn.Linear(model_dim,dff)\n        self.o = nn.Linear(dff,model_dim)\n        self.dropout = nn.Dropout(dropout)\n        self.layer_norm = nn.LayerNorm(model_dim)\n\n    def forward(self,x):\n        #1.2.线性层 + relu\n        o = relu(self.l(x))\n        #3.线性层\n        o = self.o(o)\n        #4.dropout\n        o = self.dropout(o)\n\t\t#5.6.残差连接 + 层归一化\n        o = self.layer_norm(x + o)\n        return o    # [n, step, dim]\n"
    ],
    "date": "2021-08-16",
    "text": "计算步骤\n模型框架\nEmbedding\n多层transformer的block (12层)\n拿到两个输出端结果\n计算损失\n反向传播\n更新参数\n下面主要介绍上述步骤中的\nEmbedding和\ntransformer的block层\nEmbedding\nEmbedding层就是以one hot为输入、中间层节点为字向量维数的全连接层。而这个全连接层的参数，就是一个“字向量表”。实现text输入维度的变换。\nEmbedding操作（此处指text embedding）实际上是一个查表操作，one hot型的矩阵相乘，就像是相当于查表，于是它直接用查表作为操作，而不写成矩阵再运算，这大大降低了运算量。再次强调，降低了运算量不是因为词向量的出现，而是因为把one hot型的矩阵运算简化为了查表操作。\n代码部分\n包括text embed和position embed\ntext embed\ntext embed部分调用nn.Embedding，构造词/段向量矩阵，查表实现降维。\nposition embed\nposition embed则是初始化一个包含输入序列长度作为维度的矩阵，然后作为参数训练学习位置信息。\nTransformer的block层\n由右上图知，GPT包含的block和Transformer的Decoder比较像，每个block包含两个子层：\nSublayer1：Masked Multi-Head Attention（mask多头注意力层）\nSublayer2：Feed Forward Network（FFN层）\n每一个子层后均有残差连接和归一化操作\nsublayer1：mask多头注意力层\n输入:\nq, k, v, mask\n计算注意力(如下图左所示)：\nLinear(矩阵乘法)\nScaled Dot-Product Attention\nConcat(多个注意力的结果)\nLinear(矩阵乘法)\n残差连接和归一化操作：\nDropout操作 → 残差连接 → 层归一化操作\n我们以上图中的左图介绍整个注意力层的计算过程\n矩阵乘法\n将输入的Q，K，V与矩阵作乘法，得到新的Q，K，V\nScaled Dot-Product Attention\n这个操作名字看起来很长，实际上是 点乘+缩放+mask(可选)+Softmax+点乘 来计算注意力值的过程\n第一步：Q与K的转置进行点乘，计算Q和K的相似度\n第二步：缩放，除以一个比例因子\n第三步：Mask矩阵中一部分值（可选，GPT中有此操作）\n第四步：Softmax，转化为每个token的概率\n第五步：Softmax后的矩阵值点乘V值，每个value通过概率加权，得到注意力分数。\n补充：\nMask操作：masked_fill_(mask, value)\n掩码操作，用value填充tensor中与mask中值为1位置相对应的元素。mask的形状必须与要填充的tensor形状一致。（这里采用-inf填充，从而softmax之后变成0，相当于看不见后面的词）\ntransformer中的mask操作\nmask后可视化矩阵：\n直观理解是每个词只能看到它之前的词（因为目的就是要预测未来的词嘛，要是看到了就不用预测了）\nConcat操作\n综合多个注意力头的结果，实际上是对矩阵做变换：permute，reshape操作，视具体情况降维。（如下图红框中所示）\n矩阵乘法\n一个Linear层，对注意力结果线性变换\n整个mask多头注意力层的代码\n注意到，最后进行了残差连接和归一化操作，包括：\nDropout操作\n残差连接\n层归一化操作\nsublayer2：FFN前馈网络\n主要是一个多层感知机结构\n线性层（矩阵乘法）\nrelu函数激活\n线性层（矩阵乘法）\n之后同样进行了残差连接和归一化操作，包括：\nDropout操作\n残差连接\n层归一化操作\n"
  },
  {
    "head": "多维软件视角——三维度八视图",
    "paragraphs": [
      "多维软件视角",
      "三个维度：",
      "阶段：Build（构造阶段），Run（运行阶段）",
      "层次：代码层面，构件层面",
      "时间：时刻，一段时间",
      "视角一： Build-time, moment, and code-level view",
      "词汇层面：",
      "源代码",
      "语法层面：抽象语法树（",
      "AST",
      "，Abstract Syntax Tree）",
      "语义层面：",
      "视角二： Build-time, period, and code-level view",
      "Code churn",
      "：代码变化（一段时间）",
      "视角三： Build-time, moment, and component-level view",
      "源代码被物理地组织成",
      "文件（File）",
      "，这些文件又被目录组织起来；",
      "被封装到",
      "包（Package）",
      "中，逻辑上构成组件和子系统",
      "可重用模块以",
      "库（Library）",
      "的形式出现",
      "静态链接",
      "发生在构造阶段，静态链接时，库被拷贝进入代码形成整体，执行的时候无需提供库文件",
      "视角四： Build-time, period, and component-level view",
      "Software Configuration Item (",
      "SCI",
      "，配置项)",
      "Version(",
      "视角五： Run-time, moment, and code-level view",
      "Snapshot diagram",
      ":代码快照图（描述程序",
      "时内存里变量层面的状态）",
      "Memory dump",
      "(内存信息转储)",
      "视角六： Run-time, period and code-level view",
      "Execution tracing",
      "执行跟踪",
      "用日志方式记录程序执行的调用次序（代码层面）",
      "视角七： Run-time, moment, and component-level view",
      "Deployment diagram（",
      "部署图",
      "视角八： Run-time, period, and component-level view",
      "Event Log",
      "：事件日志，构件/系统层面"
    ],
    "sentences": [
      "多维软件视角",
      "三个维度：阶段：Build（构造阶段），Run（运行阶段）",
      "层次：代码层面，构件层面",
      "时间：时刻，一段时间",
      "视角一： Build-time, moment, and code-level view",
      "词汇层面：源代码",
      "语法层面：抽象语法树（",
      "AST",
      "，Abstract Syntax Tree）",
      "语义层面：视角二： Build-time, period, and code-level view",
      "Code churn",
      "：代码变化（一段时间）",
      "视角三： Build-time, moment, and component-level view",
      "源代码被物理地组织成",
      "文件（File）",
      "，这些文件又被目录组织起来；被封装到",
      "包（Package）",
      "中，逻辑上构成组件和子系统",
      "可重用模块以",
      "库（Library）",
      "的形式出现",
      "静态链接",
      "发生在构造阶段",
      "静态链接时",
      "库被拷贝进入代码形成整体",
      "执行的时候无需提供库文件",
      "视角四： Build-time, period, and component-level view",
      "Software Configuration Item (",
      "SCI",
      "，配置项)",
      "Version(",
      "视角五： Run-time, moment, and code-level view",
      "Snapshot diagram",
      ":代码快照图（描述程序",
      "时内存里变量层面的状态）",
      "Memory dump",
      "(内存信息转储)",
      "视角六： Run-time, period and code-level view",
      "Execution tracing",
      "执行跟踪",
      "用日志方式记录程序执行的调用次序（代码层面）",
      "视角七： Run-time, moment, and component-level view",
      "Deployment diagram（",
      "部署图",
      "视角八： Run-time, period, and component-level view",
      "Event Log",
      "：事件日志，构件/系统层面"
    ],
    "codes": [],
    "date": "2021-07-06",
    "text": "多维软件视角\n三个维度：\n阶段：Build（构造阶段），Run（运行阶段）\n层次：代码层面，构件层面\n时间：时刻，一段时间\n视角一： Build-time, moment, and code-level view\n词汇层面：\n源代码\n语法层面：抽象语法树（\nAST\n，Abstract Syntax Tree）\n语义层面：\n视角二： Build-time, period, and code-level view\nCode churn\n：代码变化（一段时间）\n视角三： Build-time, moment, and component-level view\n源代码被物理地组织成\n文件（File）\n，这些文件又被目录组织起来；\n被封装到\n包（Package）\n中，逻辑上构成组件和子系统\n可重用模块以\n库（Library）\n的形式出现\n静态链接\n发生在构造阶段，静态链接时，库被拷贝进入代码形成整体，执行的时候无需提供库文件\n视角四： Build-time, period, and component-level view\nSoftware Configuration Item (\nSCI\n，配置项)\nVersion(\n视角五： Run-time, moment, and code-level view\nSnapshot diagram\n:代码快照图（描述程序\n时内存里变量层面的状态）\nMemory dump\n(内存信息转储)\n视角六： Run-time, period and code-level view\nExecution tracing\n执行跟踪\n用日志方式记录程序执行的调用次序（代码层面）\n视角七： Run-time, moment, and component-level view\nDeployment diagram（\n部署图\n视角八： Run-time, period, and component-level view\nEvent Log\n：事件日志，构件/系统层面\n"
  },
  {
    "head": "Java中的重载（Overload）机制详解及与重写（Override）的区别",
    "paragraphs": [
      "文章目录",
      "重载的定义",
      "重载的好处",
      "重载是一种静态多态",
      "重载的规则",
      "重载举例",
      "重载与重写的区别",
      "重载的定义",
      "重载：多个方法具有",
      "的名字，但有",
      "不同的",
      "参数列表",
      "重载的好处",
      "方便client（客户端）调用，client可用不同的参数列表，调用同样的函数",
      "比如想要定义加法的方法， 让它可以计算不同类型的数之和，有不同类型的返回值，可以如下定义：",
      "如果没有重载机制，那么想要定义两个具有相同/相似功能的方法，必须用不同函数名加以区分，如add1,add2，去定义和记住这些方法名字，对开发者和使用者都是一种负担。",
      "重载是一种静态多态",
      "重载是一种静态多态，根据参数列表进行最佳匹配，做静态类型检查，在编译阶段时决定要具体执行哪个方法。",
      "与之相反，重写方法则是在运行时进行动态检查。",
      "关于这一点，首先需要明白两个概念：",
      "绑定：将调用的名字与实际的方法名字联系起来（可能很多个）",
      "分派：具体执行哪个方法（early binding → static dispatch）",
      "提前/静态绑定（Early/Static binding）",
      "每当一个方法的绑定发生时，所绑定的类型由编译器在编译时确定，然后绑定发生。",
      "推迟/动态绑定（Late/Dynamic binding）",
      "在重写父类和子类具有相同的方法时，对象的类型决定了要执行的方法。 对象的类型在运行时确定。",
      "分派原理",
      "发生阶段",
      "应用场景",
      "静态分派",
      "根据变量的静态类型",
      "编译期（不由Java虚拟机执行）",
      "Overload",
      "动态分派",
      "根据变量的动态类型",
      "运行期（由Java虚拟机执行）",
      "Override",
      "Overload方法：",
      "提前绑定和静态分派",
      "编译阶段即可确定要执行哪个具体操作。这个主要是针对多态性而言的。笔者理解为，如果发生了继承的情况，子类重载了父类的方法，由于参数列表不同，编译阶段可以很快检查并绑定到对应的方法，所以采取了这种early binding+static dispatch的机制。",
      "Override方法:",
      "推迟绑定和动态分派",
      "如果子类重写了父类的方法，编译阶段不知道对象类型，需要进行推迟绑定，在运行阶段决定具体执行哪个方法。",
      "如果这一点不理解可以暂时跳过，但需要了解在哪个阶段进行检查与确定执行方法。即重载方法在",
      "时做静态类型检查，决定执行哪一个方法；而重写方法在",
      "时进行动态检查，并决定执行哪个方法。",
      "重载的规则",
      "必须有不同的参数列表",
      "可以有相同/不同的返回值类型",
      "可以有相同/不同的访问权限(public/private/protected)",
      "可以声明新的异常",
      "可以在同一个类内重载，也可在子类中重载",
      "注意到，重载规则中最重要的也是最本质的是",
      "第一条规则",
      "重载方法的",
      "参数列表必须改变",
      "，指的是",
      "参数个数/参数类型",
      "发生改变",
      "方法2即为方法1的重载方法，方法3、4均不是方法1的重载方法，参数列表（指参数类型和参数个数）与方法1相同",
      "方法3仅仅改变了参数变量名称，没有改变参数类型和个数",
      "方法4只是改变了方法返回类型，也没有改变参数列表",
      "重载举例",
      "下面我们来看一组子类重载父类方法的例子，加深我们的理解。",
      "，可以子类中重载，也可在同一个类内重载（像前述add方法可以放在同一个类中）；并不是像重写一样必须发生在父类和子类之间。",
      "首先定义两个类Animal和Horse，Horse类中重载了Animal中的eat方法，需要传入一个字符串变量",
      "我们进行如下测试",
      "输出结果：undefined，调用Animal中的无参eat方法",
      "输出结果：undefined，调用Horse类中继承的无参eat方法",
      "输出结果：undefined，由于没有参数，调用了Animal类中的无参eat方法",
      "输出结果：Apples，调用Horse类中有参方法",
      "编译报错：The method eat() in the type Animal is not applicable for the arguments (String)，Animal类中没有带参数的eat方法，这里也再次说明了重载是一种静态多态，在编译时期进行静态检查。",
      "编译报错：The method eat() in the type Animal is not applicable for the arguments (String)，Animal类中没有带参数的eat方法，尽管ah2具有多态性，但重载方法基于early binding和静态分派，编译时会做静态检查，到Animal的方法里去找带参数的eat，如果找到然后进行绑定，但是显然此处静态检查是出错的（找不到带参数的eat），所以编译报错。",
      "重载与重写的区别",
      "重载（Overload）",
      "重写（Override）",
      "参数列表",
      "必须改变",
      "必须不变",
      "返回值类型",
      "可以改变",
      "必须不变",
      "可以改变",
      "要么不抛出异常，要么抛出与父类方法相同的异常或该异常的子类",
      "访问权限",
      "可以改变",
      "子类的方法的访问权限不能小于父类",
      "引用类型确定选择哪个重载版本（基于声明的参数类型），在编译时发生",
      "对象类型（堆上实际实例的类型）决定了选择哪个方法，发生在运行时"
    ],
    "sentences": [
      "文章目录",
      "重载的定义",
      "重载的好处",
      "重载是一种静态多态",
      "重载的规则",
      "重载举例",
      "重载与重写的区别",
      "重载的定义",
      "重载：多个方法具有",
      "的名字，但有",
      "不同的",
      "参数列表",
      "重载的好处",
      "方便client（客户端）调用",
      "client可用不同的参数列表",
      "调用同样的函数",
      "比如想要定义加法的方法",
      " 让它可以计算不同类型的数之和",
      "有不同类型的返回值",
      "可以如下定义：如果没有重载机制",
      "那么想要定义两个具有相同/相似功能的方法",
      "必须用不同函数名加以区分",
      "如add1,add2",
      "去定义和记住这些方法名字",
      "对开发者和使用者都是一种负担",
      "重载是一种静态多态",
      "重载是一种静态多态",
      "根据参数列表进行最佳匹配",
      "做静态类型检查",
      "在编译阶段时决定要具体执行哪个方法",
      "与之相反，重写方法则是在运行时进行动态检查",
      "关于这一点",
      "首先需要明白两个概念：绑定：将调用的名字与实际的方法名字联系起来（可能很多个）",
      "分派：具体执行哪个方法（early binding → static dispatch）",
      "提前/静态绑定（Early/Static binding）",
      "每当一个方法的绑定发生时",
      "所绑定的类型由编译器在编译时确定",
      "然后绑定发生",
      "推迟/动态绑定（Late/Dynamic binding）",
      "在重写父类和子类具有相同的方法时",
      "对象的类型决定了要执行的方法",
      " 对象的类型在运行时确定",
      "分派原理",
      "发生阶段",
      "应用场景",
      "静态分派",
      "根据变量的静态类型",
      "编译期（不由Java虚拟机执行）",
      "Overload",
      "动态分派",
      "根据变量的动态类型",
      "运行期（由Java虚拟机执行）",
      "Override",
      "Overload方法：提前绑定和静态分派",
      "编译阶段即可确定要执行哪个具体操作",
      "这个主要是针对多态性而言的",
      "笔者理解为",
      "如果发生了继承的情况",
      "子类重载了父类的方法",
      "由于参数列表不同",
      "编译阶段可以很快检查并绑定到对应的方法",
      "所以采取了这种early binding+static dispatch的机制",
      "Override方法:推迟绑定和动态分派",
      "如果子类重写了父类的方法",
      "编译阶段不知道对象类型",
      "需要进行推迟绑定",
      "在运行阶段决定具体执行哪个方法",
      "如果这一点不理解可以暂时跳过",
      "但需要了解在哪个阶段进行检查与确定执行方法",
      "即重载方法在",
      "时做静态类型检查，决定执行哪一个方法；而重写方法在",
      "时进行动态检查，并决定执行哪个方法",
      "重载的规则",
      "必须有不同的参数列表",
      "可以有相同/不同的返回值类型",
      "可以有相同/不同的访问权限(public/private/protected)",
      "可以声明新的异常",
      "可以在同一个类内重载，也可在子类中重载",
      "注意到，重载规则中最重要的也是最本质的是",
      "第一条规则",
      "重载方法的",
      "参数列表必须改变",
      "，指的是",
      "参数个数/参数类型",
      "发生改变",
      "方法2即为方法1的重载方法",
      "方法3、4均不是方法1的重载方法",
      "参数列表（指参数类型和参数个数）与方法1相同",
      "方法3仅仅改变了参数变量名称，没有改变参数类型和个数",
      "方法4只是改变了方法返回类型，也没有改变参数列表",
      "重载举例",
      "下面我们来看一组子类重载父类方法的例子，加深我们的理解",
      "",
      "可以子类中重载",
      "也可在同一个类内重载（像前述add方法可以放在同一个类中）；并不是像重写一样必须发生在父类和子类之间",
      "首先定义两个类Animal和Horse",
      "Horse类中重载了Animal中的eat方法",
      "需要传入一个字符串变量",
      "我们进行如下测试",
      "输出结果：undefined",
      "调用Animal中的无参eat方法",
      "输出结果：undefined",
      "调用Horse类中继承的无参eat方法",
      "输出结果：undefined",
      "由于没有参数",
      "调用了Animal类中的无参eat方法",
      "输出结果：Apples，调用Horse类中有参方法",
      "编译报错：The method eat() in the type Animal is not applicable for the arguments (String)",
      "Animal类中没有带参数的eat方法",
      "这里也再次说明了重载是一种静态多态",
      "在编译时期进行静态检查",
      "编译报错：The method eat() in the type Animal is not applicable for the arguments (String)",
      "Animal类中没有带参数的eat方法",
      "尽管ah2具有多态性",
      "但重载方法基于early binding和静态分派",
      "编译时会做静态检查",
      "到Animal的方法里去找带参数的eat",
      "如果找到然后进行绑定",
      "但是显然此处静态检查是出错的（找不到带参数的eat）",
      "所以编译报错",
      "重载与重写的区别",
      "重载（Overload）",
      "重写（Override）",
      "参数列表",
      "必须改变",
      "必须不变",
      "返回值类型",
      "可以改变",
      "必须不变",
      "可以改变",
      "要么不抛出异常，要么抛出与父类方法相同的异常或该异常的子类",
      "访问权限",
      "可以改变",
      "子类的方法的访问权限不能小于父类",
      "引用类型确定选择哪个重载版本（基于声明的参数类型）",
      "在编译时发生",
      "对象类型（堆上实际实例的类型）决定了选择哪个方法",
      "发生在运行时"
    ],
    "codes": [
      "public int add(int x, int y) {\n\t\treturn x + y;\n\t}\npublic double add(double x, double y) {\n\t\treturn x + y;\n\t}\n",
      "//方法1（原方法）\npublic void changeSize(int size, String name, float pattern) { }\n//方法2\npublic void changeSize(int size, String name) { }\n//方法3\npublic void changeSize(int length, String pattern, float size){ }\n//方法4\npublic boolean changeSize(int size, String name, float pattern) { }\n",
      "public class Animal {\n\tpublic void eat() {\n\t\tSystem.out.println(\"undefined\");\n\t}\n}\n\nclass Horse extends Animal{\n\tpublic void eat(String food) {\n\t\tSystem.out.println(food);\n\t}\n}\n",
      "//测试1\nAnimal a = new Animal();\na.eat();\n",
      "//测试2\nHorse h = new Horse();\nh.eat();\n",
      "//测试3\nAnimal ah = new Horse();\nah.eat();\n",
      "//测试4\nHorse he = new Horse();\nhe.eat(\"Apples\");\n",
      "//测试5\nAnimal a2 = new Animal();\na2.eat(\"treats\");\n",
      "//测试6\nAnimal ah2 = new Horse();\n\t\tah2.eat(\"Carrots\");\n"
    ],
    "date": "2021-06-30",
    "text": "文章目录\n重载的定义\n重载的好处\n重载是一种静态多态\n重载的规则\n重载举例\n重载与重写的区别\n重载的定义\n重载：多个方法具有\n的名字，但有\n不同的\n参数列表\n重载的好处\n方便client（客户端）调用，client可用不同的参数列表，调用同样的函数\n比如想要定义加法的方法， 让它可以计算不同类型的数之和，有不同类型的返回值，可以如下定义：\n如果没有重载机制，那么想要定义两个具有相同/相似功能的方法，必须用不同函数名加以区分，如add1,add2，去定义和记住这些方法名字，对开发者和使用者都是一种负担。\n重载是一种静态多态\n重载是一种静态多态，根据参数列表进行最佳匹配，做静态类型检查，在编译阶段时决定要具体执行哪个方法。\n与之相反，重写方法则是在运行时进行动态检查。\n关于这一点，首先需要明白两个概念：\n绑定：将调用的名字与实际的方法名字联系起来（可能很多个）\n分派：具体执行哪个方法（early binding → static dispatch）\n提前/静态绑定（Early/Static binding）\n每当一个方法的绑定发生时，所绑定的类型由编译器在编译时确定，然后绑定发生。\n推迟/动态绑定（Late/Dynamic binding）\n在重写父类和子类具有相同的方法时，对象的类型决定了要执行的方法。 对象的类型在运行时确定。\n分派原理\n发生阶段\n应用场景\n静态分派\n根据变量的静态类型\n编译期（不由Java虚拟机执行）\nOverload\n动态分派\n根据变量的动态类型\n运行期（由Java虚拟机执行）\nOverride\nOverload方法：\n提前绑定和静态分派\n编译阶段即可确定要执行哪个具体操作。这个主要是针对多态性而言的。笔者理解为，如果发生了继承的情况，子类重载了父类的方法，由于参数列表不同，编译阶段可以很快检查并绑定到对应的方法，所以采取了这种early binding+static dispatch的机制。\nOverride方法:\n推迟绑定和动态分派\n如果子类重写了父类的方法，编译阶段不知道对象类型，需要进行推迟绑定，在运行阶段决定具体执行哪个方法。\n如果这一点不理解可以暂时跳过，但需要了解在哪个阶段进行检查与确定执行方法。即重载方法在\n时做静态类型检查，决定执行哪一个方法；而重写方法在\n时进行动态检查，并决定执行哪个方法。\n重载的规则\n必须有不同的参数列表\n可以有相同/不同的返回值类型\n可以有相同/不同的访问权限(public/private/protected)\n可以声明新的异常\n可以在同一个类内重载，也可在子类中重载\n注意到，重载规则中最重要的也是最本质的是\n第一条规则\n重载方法的\n参数列表必须改变\n，指的是\n参数个数/参数类型\n发生改变\n方法2即为方法1的重载方法，方法3、4均不是方法1的重载方法，参数列表（指参数类型和参数个数）与方法1相同\n方法3仅仅改变了参数变量名称，没有改变参数类型和个数\n方法4只是改变了方法返回类型，也没有改变参数列表\n重载举例\n下面我们来看一组子类重载父类方法的例子，加深我们的理解。\n，可以子类中重载，也可在同一个类内重载（像前述add方法可以放在同一个类中）；并不是像重写一样必须发生在父类和子类之间。\n首先定义两个类Animal和Horse，Horse类中重载了Animal中的eat方法，需要传入一个字符串变量\n我们进行如下测试\n输出结果：undefined，调用Animal中的无参eat方法\n输出结果：undefined，调用Horse类中继承的无参eat方法\n输出结果：undefined，由于没有参数，调用了Animal类中的无参eat方法\n输出结果：Apples，调用Horse类中有参方法\n编译报错：The method eat() in the type Animal is not applicable for the arguments (String)，Animal类中没有带参数的eat方法，这里也再次说明了重载是一种静态多态，在编译时期进行静态检查。\n编译报错：The method eat() in the type Animal is not applicable for the arguments (String)，Animal类中没有带参数的eat方法，尽管ah2具有多态性，但重载方法基于early binding和静态分派，编译时会做静态检查，到Animal的方法里去找带参数的eat，如果找到然后进行绑定，但是显然此处静态检查是出错的（找不到带参数的eat），所以编译报错。\n重载与重写的区别\n重载（Overload）\n重写（Override）\n参数列表\n必须改变\n必须不变\n返回值类型\n可以改变\n必须不变\n可以改变\n要么不抛出异常，要么抛出与父类方法相同的异常或该异常的子类\n访问权限\n可以改变\n子类的方法的访问权限不能小于父类\n引用类型确定选择哪个重载版本（基于声明的参数类型），在编译时发生\n对象类型（堆上实际实例的类型）决定了选择哪个方法，发生在运行时\n"
  },
  {
    "head": "GPT模型总结【模型结构及计算过程_详细说明】",
    "paragraphs": [
      "GPT模型",
      "GPT模型：生成式预训练模型（Generative Pre-Training）",
      "总体结构：",
      "无监督的预训练",
      "有监督的下游任务精调",
      "核心结构：中间部分主要由12个Transformer Decoder的block堆叠而成",
      "下面这张图更直观地反映了模型的整体结构：",
      "模型描述",
      "GPT 使用",
      "Transformer",
      "的 Decoder 结构，并对 Transformer Decoder 进行了一些改动，原本的 Decoder 包含了两个 Multi-Head Attention 结构，GPT 只保留了 Mask Multi-Head Attention，如下图所示。",
      "（很多资料上说类似于decoder结构，因为采用了decoder的mask机制，不过抛开这一点，其实感觉和encoder会更像，所以实现时有时反而是调encoder实现",
      "莫烦Python GPT实现代码",
      "对比原有transformer的结构",
      "阶段描述",
      "预训练阶段：",
      "预训练阶段为文本预测，即根据已有的历史词预测当前时刻的词，7-2,7-3,7-4三个式子对应之前的GPT结构图，输出P(x)为输出，每个词被预测到的概率，再利用7-1式，计算最大似然函数，据此构造损失函数，即可以对该语言模型进行优化。",
      "下游任务精调阶段",
      "损失函数",
      "下游任务与上游任务损失的线性组合",
      "计算过程：",
      "Embedding",
      "多层transformer的block",
      "拿到两个输出端结果",
      "计算损失",
      "反向传播",
      "更新参数",
      "一个具体的GPT实例代码：",
      "可以看到GPT模型的forward函数中，首先进行Embedding操作，然后经过12层transformer的block中进行运算，然后分别经过两个线性变换得到最终计算值（一个用于文本预测，一个用于任务分类器），代码与最开始展示的模型结构图保持一致。",
      "参考：莫烦Python GPT实现代码",
      "下面我们着重关注计算步骤2, 3",
      "计算细节：",
      "【Embedding层】：",
      "查表操作",
      "Embedding层就是以one hot为输入、中间层节点为字向量维数的全连接层。而这个全连接层的参数，就是一个“字向量表”。",
      "one hot型的矩阵相乘，就像是相当于查表，于是它直接用查表作为操作，而不写成矩阵再运算，这大大降低了运算量。再次强调，降低了运算量不是因为词向量的出现，而是因为把one hot型的矩阵运算简化为了查表操作。",
      "【GPT中类似transformer的decoder层】：",
      "每个decoder层包含两个子层",
      "sublayer1: mask的多头注意力层",
      "sublayer2: ffn (feed-forward network)前馈网络（多层感知机）",
      "sublayer1：mask的多头注意力层",
      "输入:",
      "q, k, v, mask",
      "计算注意力：",
      "Linear(矩阵乘法)→Scaled Dot-Product Attention→Concat(多个注意力的结果, reshape )→Linear(矩阵乘法)",
      "残差连接和归一化操作：",
      "Dropout操作→残差连接→层归一化操作",
      "计算过程：",
      "下面这段内容介绍了计算注意力的整体过程：",
      "分解说明：",
      "Mask Multi-head Attention",
      "1.矩阵乘法：",
      "将输入的q,k,v进行变换",
      "2.Scaled Dot-Product Attention",
      "主要就是进行attention的计算以及mask的操作",
      "Mask操作：masked_fill_(mask, value)",
      "掩码操作，用value填充tensor中与mask中值为1位置相对应的元素。mask的形状必须与要填充的tensor形状一致。（这里采用-inf填充，从而softmax之后变成0，相当于看不见后面的词）",
      "transformer中的mask操作",
      "mask后可视化矩阵：",
      "直观理解是每个词只能看到它之前的词（因为目的就是要预测未来的词嘛，要是看到了就不用预测了）",
      "3.Concat操作：",
      "综合多个注意力头的结果，实际上是对矩阵做变换：permute，reshape操作，降维。（如下图红框中所示）",
      "4.矩阵乘法：一个Linear层，对注意力结果线性变换",
      "整个mask多头注意力层的",
      "注意到：上述代码中后面几行是对注意力结果进行",
      "残差连接和归一化操作",
      "下说明这一过程：",
      "残差连接和归一化操作：",
      "5.Dropout层",
      "6.矩阵加法",
      "7.层归一化",
      "批量归一化是不同训练数据之间对单个神经元的归一化，层归一化是单个训练数据对某一层所有神经元之间的归一化。",
      "输入归一化、批量归一化(BN)与层归一化(LN)",
      "代码展示",
      "sublayer2: ffn (feed-forward network)前馈网络",
      "1.线性层（矩阵乘法）",
      "2.relu函数激活",
      "3.线性层（矩阵乘法）",
      "4.Dropout操作",
      "5.层归一化",
      "【线性层】：",
      "多层block的输出结果放到两个线性层中进行变换，比较简单，不做赘述。",
      "补充：注意力层流程图示",
      "参考资料",
      "1.参考论文：Radford et al. 《Improving Language Undersatnding by Generative Pre-Training\"》",
      "2.参考书籍：《自然语言处理 基于预训练模型的方法》车万翔,郭江,崔一鸣",
      "3.本文中代码来源：",
      "莫烦Python GPT实现代码",
      "4.其它参考链接（博文中已提到部分）：",
      "word embedding计算过程剖析",
      "Transformer的矩阵维度分析和Mask详解"
    ],
    "sentences": [
      "GPT模型",
      "GPT模型：生成式预训练模型（Generative Pre-Training）",
      "总体结构：无监督的预训练",
      "有监督的下游任务精调",
      "核心结构：中间部分主要由12个Transformer Decoder的block堆叠而成",
      "下面这张图更直观地反映了模型的整体结构：模型描述",
      "GPT 使用",
      "Transformer",
      "的 Decoder 结构",
      "并对 Transformer Decoder 进行了一些改动",
      "原本的 Decoder 包含了两个 Multi-Head Attention 结构",
      "GPT 只保留了 Mask Multi-Head Attention",
      "如下图所示",
      "（很多资料上说类似于decoder结构",
      "因为采用了decoder的mask机制",
      "不过抛开这一点",
      "其实感觉和encoder会更像",
      "所以实现时有时反而是调encoder实现",
      "莫烦Python GPT实现代码",
      "对比原有transformer的结构",
      "阶段描述",
      "预训练阶段：预训练阶段为文本预测",
      "即根据已有的历史词预测当前时刻的词",
      "7-2,7-3,7-4三个式子对应之前的GPT结构图",
      "输出P(x)为输出",
      "每个词被预测到的概率",
      "再利用7-1式",
      "计算最大似然函数",
      "据此构造损失函数",
      "即可以对该语言模型进行优化",
      "下游任务精调阶段",
      "损失函数",
      "下游任务与上游任务损失的线性组合",
      "计算过程：Embedding",
      "多层transformer的block",
      "拿到两个输出端结果",
      "计算损失",
      "反向传播",
      "更新参数",
      "一个具体的GPT实例代码：可以看到GPT模型的forward函数中",
      "首先进行Embedding操作",
      "然后经过12层transformer的block中进行运算",
      "然后分别经过两个线性变换得到最终计算值（一个用于文本预测",
      "一个用于任务分类器）",
      "代码与最开始展示的模型结构图保持一致",
      "参考：莫烦Python GPT实现代码",
      "下面我们着重关注计算步骤2, 3",
      "计算细节：【Embedding层】：查表操作",
      "Embedding层就是以one hot为输入、中间层节点为字向量维数的全连接层",
      "而这个全连接层的参数，就是一个“字向量表”",
      "one hot型的矩阵相乘",
      "就像是相当于查表",
      "于是它直接用查表作为操作",
      "而不写成矩阵再运算",
      "这大大降低了运算量",
      "再次强调",
      "降低了运算量不是因为词向量的出现",
      "而是因为把one hot型的矩阵运算简化为了查表操作",
      "【GPT中类似transformer的decoder层】：每个decoder层包含两个子层",
      "sublayer1: mask的多头注意力层",
      "sublayer2: ffn (feed-forward network)前馈网络（多层感知机）",
      "sublayer1：mask的多头注意力层",
      "输入:q, k, v, mask",
      "计算注意力：Linear(矩阵乘法)→Scaled Dot-Product Attention→Concat(多个注意力的结果, reshape )→Linear(矩阵乘法)",
      "残差连接和归一化操作：Dropout操作→残差连接→层归一化操作",
      "计算过程：下面这段内容介绍了计算注意力的整体过程：分解说明：Mask Multi-head Attention",
      "1.矩阵乘法：将输入的q,k,v进行变换",
      "2.Scaled Dot-Product Attention",
      "主要就是进行attention的计算以及mask的操作",
      "Mask操作：masked_fill_(mask, value)",
      "掩码操作",
      "用value填充tensor中与mask中值为1位置相对应的元素",
      "mask的形状必须与要填充的tensor形状一致",
      "（这里采用-inf填充",
      "从而softmax之后变成0",
      "相当于看不见后面的词）",
      "transformer中的mask操作",
      "mask后可视化矩阵：直观理解是每个词只能看到它之前的词（因为目的就是要预测未来的词嘛",
      "要是看到了就不用预测了）",
      "3.Concat操作：综合多个注意力头的结果",
      "实际上是对矩阵做变换：permute",
      "reshape操作",
      "降维",
      "（如下图红框中所示）",
      "4.矩阵乘法：一个Linear层，对注意力结果线性变换",
      "整个mask多头注意力层的",
      "注意到：上述代码中后面几行是对注意力结果进行",
      "残差连接和归一化操作",
      "下说明这一过程：残差连接和归一化操作：5.Dropout层",
      "6.矩阵加法",
      "7.层归一化",
      "批量归一化是不同训练数据之间对单个神经元的归一化",
      "层归一化是单个训练数据对某一层所有神经元之间的归一化",
      "输入归一化、批量归一化(BN)与层归一化(LN)",
      "代码展示",
      "sublayer2: ffn (feed-forward network)前馈网络",
      "1.线性层（矩阵乘法）",
      "2.relu函数激活",
      "3.线性层（矩阵乘法）",
      "4.Dropout操作",
      "5.层归一化",
      "【线性层】：多层block的输出结果放到两个线性层中进行变换",
      "比较简单",
      "不做赘述",
      "补充：注意力层流程图示",
      "参考资料",
      "1.参考论文：Radford et al. 《Improving Language Undersatnding by Generative Pre-Training\"》",
      "2.参考书籍：《自然语言处理 基于预训练模型的方法》车万翔,郭江,崔一鸣",
      "3.本文中代码来源：莫烦Python GPT实现代码",
      "4.其它参考链接（博文中已提到部分）：word embedding计算过程剖析",
      "Transformer的矩阵维度分析和Mask详解"
    ],
    "codes": [],
    "date": "2021-08-12",
    "text": "GPT模型\nGPT模型：生成式预训练模型（Generative Pre-Training）\n总体结构：\n无监督的预训练\n有监督的下游任务精调\n核心结构：中间部分主要由12个Transformer Decoder的block堆叠而成\n下面这张图更直观地反映了模型的整体结构：\n模型描述\nGPT 使用\nTransformer\n的 Decoder 结构，并对 Transformer Decoder 进行了一些改动，原本的 Decoder 包含了两个 Multi-Head Attention 结构，GPT 只保留了 Mask Multi-Head Attention，如下图所示。\n（很多资料上说类似于decoder结构，因为采用了decoder的mask机制，不过抛开这一点，其实感觉和encoder会更像，所以实现时有时反而是调encoder实现\n莫烦Python GPT实现代码\n对比原有transformer的结构\n阶段描述\n预训练阶段：\n预训练阶段为文本预测，即根据已有的历史词预测当前时刻的词，7-2,7-3,7-4三个式子对应之前的GPT结构图，输出P(x)为输出，每个词被预测到的概率，再利用7-1式，计算最大似然函数，据此构造损失函数，即可以对该语言模型进行优化。\n下游任务精调阶段\n损失函数\n下游任务与上游任务损失的线性组合\n计算过程：\nEmbedding\n多层transformer的block\n拿到两个输出端结果\n计算损失\n反向传播\n更新参数\n一个具体的GPT实例代码：\n可以看到GPT模型的forward函数中，首先进行Embedding操作，然后经过12层transformer的block中进行运算，然后分别经过两个线性变换得到最终计算值（一个用于文本预测，一个用于任务分类器），代码与最开始展示的模型结构图保持一致。\n参考：莫烦Python GPT实现代码\n下面我们着重关注计算步骤2, 3\n计算细节：\n【Embedding层】：\n查表操作\nEmbedding层就是以one hot为输入、中间层节点为字向量维数的全连接层。而这个全连接层的参数，就是一个“字向量表”。\none hot型的矩阵相乘，就像是相当于查表，于是它直接用查表作为操作，而不写成矩阵再运算，这大大降低了运算量。再次强调，降低了运算量不是因为词向量的出现，而是因为把one hot型的矩阵运算简化为了查表操作。\n【GPT中类似transformer的decoder层】：\n每个decoder层包含两个子层\nsublayer1: mask的多头注意力层\nsublayer2: ffn (feed-forward network)前馈网络（多层感知机）\nsublayer1：mask的多头注意力层\n输入:\nq, k, v, mask\n计算注意力：\nLinear(矩阵乘法)→Scaled Dot-Product Attention→Concat(多个注意力的结果, reshape )→Linear(矩阵乘法)\n残差连接和归一化操作：\nDropout操作→残差连接→层归一化操作\n计算过程：\n下面这段内容介绍了计算注意力的整体过程：\n分解说明：\nMask Multi-head Attention\n1.矩阵乘法：\n将输入的q,k,v进行变换\n2.Scaled Dot-Product Attention\n主要就是进行attention的计算以及mask的操作\nMask操作：masked_fill_(mask, value)\n掩码操作，用value填充tensor中与mask中值为1位置相对应的元素。mask的形状必须与要填充的tensor形状一致。（这里采用-inf填充，从而softmax之后变成0，相当于看不见后面的词）\ntransformer中的mask操作\nmask后可视化矩阵：\n直观理解是每个词只能看到它之前的词（因为目的就是要预测未来的词嘛，要是看到了就不用预测了）\n3.Concat操作：\n综合多个注意力头的结果，实际上是对矩阵做变换：permute，reshape操作，降维。（如下图红框中所示）\n4.矩阵乘法：一个Linear层，对注意力结果线性变换\n整个mask多头注意力层的\n注意到：上述代码中后面几行是对注意力结果进行\n残差连接和归一化操作\n下说明这一过程：\n残差连接和归一化操作：\n5.Dropout层\n6.矩阵加法\n7.层归一化\n批量归一化是不同训练数据之间对单个神经元的归一化，层归一化是单个训练数据对某一层所有神经元之间的归一化。\n输入归一化、批量归一化(BN)与层归一化(LN)\n代码展示\nsublayer2: ffn (feed-forward network)前馈网络\n1.线性层（矩阵乘法）\n2.relu函数激活\n3.线性层（矩阵乘法）\n4.Dropout操作\n5.层归一化\n【线性层】：\n多层block的输出结果放到两个线性层中进行变换，比较简单，不做赘述。\n补充：注意力层流程图示\n参考资料\n1.参考论文：Radford et al. 《Improving Language Undersatnding by Generative Pre-Training\"》\n2.参考书籍：《自然语言处理 基于预训练模型的方法》车万翔,郭江,崔一鸣\n3.本文中代码来源：\n莫烦Python GPT实现代码\n4.其它参考链接（博文中已提到部分）：\nword embedding计算过程剖析\nTransformer的矩阵维度分析和Mask详解\n"
  },
  {
    "head": "java中的final",
    "paragraphs": [
      "java中的final",
      "java中的final关键字可以用来声明变量、方法、类。主要起到的作用就是达到引用不可变的效果。具体分别介绍如下：",
      "1.1 final变量",
      "被final修饰的变量在赋值之后引用关系就确定了，也就是不能对于基本数据类型来说不可以另赋新值，对于对象数据类型来说不能为这个变量指派一个新的对象。也就是类似于以下语句都是会在静态检查的时候报错的：",
      "那么仔细考虑来看，如果我们指定的一个变量是immutable的，那么就意味着如果用final修饰，在初始化之后这个变量就不可以修改了，如果是mutable的话，内部的值还可以修改但是不可以改变引用关系。",
      "那么是不是意味着如果在我们定义的ADT内部如果我们用final修饰了一个immutable的变量的时候就不用担心表示泄露了呢？事实上不是这样的，如果在这种情况下存在表示泄露可能会存在使用者分析运行时内存的具体情况判断ADT内部一些实现功能的危险，也就是说即使使用了final，还是需要注意表示泄露的问题。",
      "1.2 final方法",
      "下面这段话摘自《Java编程思想》第四版第143页：",
      "也就是说，如果一个方法使用了final修饰，那么这个方法将不再能被子类重写。需要注意的是由于重写首先建立在继承的关系上，如果父类中一个final方法是private的，子类自然无法访问，那么子类中定义相同的方法名和参数是不会报错的，但是这时候不再是重写关系。例如如下代码是不会报错的",
      "但是可以发现的是如果我们去掉注释的话IDE会直接在注释那一行下报错，显示没有这个方法。这是由于静态检查阶段p的类型还是Person，而Person的decison方法是private的，不可访问，因此静态检查报错。",
      "1.3 final类",
      "与上面两类类似，如果使用final修饰类的话，那么这个类是不可以被继承的。",
      "2.final一些实例",
      "2.1 final变量与普通变量",
      "很重要的一点就是final变量的指向已经不可变了，因此可以看下面这个例子",
      "输出如下：",
      "这个结果让我困惑了一段时间，查阅了资料之后有了一定的了解。接下来对于每一个结果进行分析。",
      "首先需要明确的就是对于这种直接通过双引号\"\"声明字符串的方式, 虚拟机首先会到字符串常量池中查找该字符串是否已经存在，如果存在会",
      "直接返回该引用",
      ", 如果不存在则会在堆内存中创建该字符串对象, 然后到字符串常量池中注册该字符串。",
      "也就是说a和b和c事实上是指向同一段地址的，因此a==b和a==c成立。",
      "接下来分析一下a==g为什么是false的。这是因为g是在运行的时候才分配的一段地址，因此和a的地址是不一致的，因此返回false。",
      "那么为什么a==f就是对的呢？这是因为d是由final修饰的，在静态编译的时候就当做常量使用，因此f的地址是在常量池中分配的，和a是指向一段地址的，因此a==f成立。"
    ],
    "sentences": [
      "java中的final",
      "java中的final关键字可以用来声明变量、方法、类",
      "主要起到的作用就是达到引用不可变的效果",
      "具体分别介绍如下：1.1 final变量",
      "被final修饰的变量在赋值之后引用关系就确定了",
      "也就是不能对于基本数据类型来说不可以另赋新值",
      "对于对象数据类型来说不能为这个变量指派一个新的对象",
      "也就是类似于以下语句都是会在静态检查的时候报错的：那么仔细考虑来看",
      "如果我们指定的一个变量是immutable的",
      "那么就意味着如果用final修饰",
      "在初始化之后这个变量就不可以修改了",
      "如果是mutable的话",
      "内部的值还可以修改但是不可以改变引用关系",
      "那么是不是意味着如果在我们定义的ADT内部如果我们用final修饰了一个immutable的变量的时候就不用担心表示泄露了呢？事实上不是这样的",
      "如果在这种情况下存在表示泄露可能会存在使用者分析运行时内存的具体情况判断ADT内部一些实现功能的危险",
      "也就是说即使使用了final",
      "还是需要注意表示泄露的问题",
      "1.2 final方法",
      "下面这段话摘自《Java编程思想》第四版第143页：也就是说",
      "如果一个方法使用了final修饰",
      "那么这个方法将不再能被子类重写",
      "需要注意的是由于重写首先建立在继承的关系上",
      "如果父类中一个final方法是private的",
      "子类自然无法访问",
      "那么子类中定义相同的方法名和参数是不会报错的",
      "但是这时候不再是重写关系",
      "例如如下代码是不会报错的",
      "但是可以发现的是如果我们去掉注释的话IDE会直接在注释那一行下报错",
      "显示没有这个方法",
      "这是由于静态检查阶段p的类型还是Person",
      "而Person的decison方法是private的",
      "不可访问",
      "因此静态检查报错",
      "1.3 final类",
      "与上面两类类似",
      "如果使用final修饰类的话",
      "那么这个类是不可以被继承的",
      "2.final一些实例",
      "2.1 final变量与普通变量",
      "很重要的一点就是final变量的指向已经不可变了",
      "因此可以看下面这个例子",
      "输出如下：这个结果让我困惑了一段时间",
      "查阅了资料之后有了一定的了解",
      "接下来对于每一个结果进行分析",
      "首先需要明确的就是对于这种直接通过双引号\"\"声明字符串的方式, 虚拟机首先会到字符串常量池中查找该字符串是否已经存在",
      "如果存在会",
      "直接返回该引用",
      ", 如果不存在则会在堆内存中创建该字符串对象, 然后到字符串常量池中注册该字符串",
      "也就是说a和b和c事实上是指向同一段地址的",
      "因此a==b和a==c成立",
      "接下来分析一下a==g为什么是false的",
      "这是因为g是在运行的时候才分配的一段地址",
      "因此和a的地址是不一致的",
      "因此返回false",
      "那么为什么a==f就是对的呢？这是因为d是由final修饰的",
      "在静态编译的时候就当做常量使用",
      "因此f的地址是在常量池中分配的",
      "和a是指向一段地址的",
      "因此a==f成立"
    ],
    "codes": [
      " final int a=1;\n a=2;\n final String s=\"GOOGLE\";\n s=\"BAIDU\";\n",
      " “使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的\n 含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用\n 。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java\n 版本中，不需要使用final方法进行这些优化了。“\n",
      "public class Person {\n    \n     private final void decision() {\n        System.out.println(\"父类\");\n    }\n}\npublic class concretePerson extends Person{\n    public void decision(){\n        System.out.println(\"子类\");\n    }\n    public static void main(String[] args) {\n        Person p=new concretePerson();\n        //p.decision();\n    }\n}\n",
      " public static void main(String[] args) {\n        String a=\"helloworld\";\n        String b=\"helloworld\";\n        String c=\"hello\"+\"world\";\n        final String d=\"hello\";\n        String e=\"hello\";\n        String f=d+\"world\";\n        String g=e+\"world\";\n        System.out.println(a==b);\n        System.out.println(a==c);\n        System.out.println(d==e);\n        System.out.println(a==f);\n        System.out.println(a==g);\n    }\n",
      "true\ntrue\ntrue\ntrue\nfalse\n"
    ],
    "date": "2021-07-07",
    "text": "java中的final\njava中的final关键字可以用来声明变量、方法、类。主要起到的作用就是达到引用不可变的效果。具体分别介绍如下：\n1.1 final变量\n被final修饰的变量在赋值之后引用关系就确定了，也就是不能对于基本数据类型来说不可以另赋新值，对于对象数据类型来说不能为这个变量指派一个新的对象。也就是类似于以下语句都是会在静态检查的时候报错的：\n那么仔细考虑来看，如果我们指定的一个变量是immutable的，那么就意味着如果用final修饰，在初始化之后这个变量就不可以修改了，如果是mutable的话，内部的值还可以修改但是不可以改变引用关系。\n那么是不是意味着如果在我们定义的ADT内部如果我们用final修饰了一个immutable的变量的时候就不用担心表示泄露了呢？事实上不是这样的，如果在这种情况下存在表示泄露可能会存在使用者分析运行时内存的具体情况判断ADT内部一些实现功能的危险，也就是说即使使用了final，还是需要注意表示泄露的问题。\n1.2 final方法\n下面这段话摘自《Java编程思想》第四版第143页：\n也就是说，如果一个方法使用了final修饰，那么这个方法将不再能被子类重写。需要注意的是由于重写首先建立在继承的关系上，如果父类中一个final方法是private的，子类自然无法访问，那么子类中定义相同的方法名和参数是不会报错的，但是这时候不再是重写关系。例如如下代码是不会报错的\n但是可以发现的是如果我们去掉注释的话IDE会直接在注释那一行下报错，显示没有这个方法。这是由于静态检查阶段p的类型还是Person，而Person的decison方法是private的，不可访问，因此静态检查报错。\n1.3 final类\n与上面两类类似，如果使用final修饰类的话，那么这个类是不可以被继承的。\n2.final一些实例\n2.1 final变量与普通变量\n很重要的一点就是final变量的指向已经不可变了，因此可以看下面这个例子\n输出如下：\n这个结果让我困惑了一段时间，查阅了资料之后有了一定的了解。接下来对于每一个结果进行分析。\n首先需要明确的就是对于这种直接通过双引号\"\"声明字符串的方式, 虚拟机首先会到字符串常量池中查找该字符串是否已经存在，如果存在会\n直接返回该引用\n, 如果不存在则会在堆内存中创建该字符串对象, 然后到字符串常量池中注册该字符串。\n也就是说a和b和c事实上是指向同一段地址的，因此a==b和a==c成立。\n接下来分析一下a==g为什么是false的。这是因为g是在运行的时候才分配的一段地址，因此和a的地址是不一致的，因此返回false。\n那么为什么a==f就是对的呢？这是因为d是由final修饰的，在静态编译的时候就当做常量使用，因此f的地址是在常量池中分配的，和a是指向一段地址的，因此a==f成立。\n"
  },
  {
    "head": "Eclipse使用基本教程一（安装、JDK配置）",
    "paragraphs": [
      "1.Eclipse安装",
      "下载官方链接：https://www.eclipse.org/downloads/",
      "点击红框中的Download Packages，进入如下页面：",
      "根据使用的系统选择第一项中的Eclipse版本即可，后续只需要按照提示内容安装即可，不再赘述。",
      "2.JDK安装",
      "2.1下载",
      "由于我们需要进行java开发，因此需要下载并配置JDK，具体方法如下：",
      "官方下载链接：https://www.oracle.com/java/technologies/javase-downloads.html",
      "如果使用官方链接直接点击Download,选择合适的版本即可。如果觉得官方链接太慢可以使用如下链接：",
      "华为云镜像：https://repo.huaweicloud.com/java/jdk/，进入之后选择合适的版本和系统即可。",
      "2.2安装",
      "点击下载好的exe文件，出现如下安装指引",
      "点击下一步后出现如下页面，可以点击修改，更改安装地址，例如本人改为E:\\JDK\\JDK8，之后点击下一步等待安装即可。",
      "由于本人安装的是JDK8，因此还需要安装JRE（如果是JDK10后的版本无此过程），安装完成后，会弹出JRE安装界面，如下：",
      "等待JRE安装完成即可。",
      "2.3环境变量配置",
      "在Win10系统中演示，其他系统同理。",
      "打开系统属性界面（如果找不到直接在设置界面的搜索框中搜索变量，选择编辑系统变量选项即可）",
      "点击环境变量，进入如下界面，点击新建或编辑即可操作",
      "由于本人电脑上已经配置了JDK11，因此JAVA_HOME等已经创建，第一次配置时新建即可。",
      "1.新建JAVA_HOME，将其设置为JDK安装目录。",
      "2.新建Path（如果已有的话再末尾添加即可），添加一项，为",
      "%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;",
      "3.新建CLASSPATH，设置为",
      ".;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar（注意开头有一个点）",
      "如果进行到这一步，那么JDK已经安装完成，可以进行验证。首先win+R打开如下面板：",
      "进入cmd，输入javac，出现如下内容：",
      "如果需要查看JDK版本，使用java -version命令，出现如下信息：",
      "这就意味着JDK安装完成。",
      "这是Eclipse配置java项目的第一步，下一个教程将展示如何开始第一个java程序，并使用Junit进行测试。"
    ],
    "sentences": [
      "1.Eclipse安装",
      "下载官方链接：https://www.eclipse.org/downloads/",
      "点击红框中的Download Packages",
      "进入如下页面：根据使用的系统选择第一项中的Eclipse版本即可",
      "后续只需要按照提示内容安装即可",
      "不再赘述",
      "2.JDK安装",
      "2.1下载",
      "由于我们需要进行java开发",
      "因此需要下载并配置JDK",
      "具体方法如下：官方下载链接：https://www.oracle.com/java/technologies/javase-downloads.html",
      "如果使用官方链接直接点击Download,选择合适的版本即可",
      "如果觉得官方链接太慢可以使用如下链接：华为云镜像：https://repo.huaweicloud.com/java/jdk/",
      "进入之后选择合适的版本和系统即可",
      "2.2安装",
      "点击下载好的exe文件，出现如下安装指引",
      "点击下一步后出现如下页面",
      "可以点击修改",
      "更改安装地址",
      "例如本人改为E:\\JDK\\JDK8",
      "之后点击下一步等待安装即可",
      "由于本人安装的是JDK8",
      "因此还需要安装JRE（如果是JDK10后的版本无此过程）",
      "安装完成后",
      "会弹出JRE安装界面",
      "如下：等待JRE安装完成即可",
      "2.3环境变量配置",
      "在Win10系统中演示，其他系统同理",
      "打开系统属性界面（如果找不到直接在设置界面的搜索框中搜索变量",
      "选择编辑系统变量选项即可）",
      "点击环境变量，进入如下界面，点击新建或编辑即可操作",
      "由于本人电脑上已经配置了JDK11",
      "因此JAVA_HOME等已经创建",
      "第一次配置时新建即可",
      "1.新建JAVA_HOME，将其设置为JDK安装目录",
      "2.新建Path（如果已有的话再末尾添加即可），添加一项，为",
      "%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;3.新建CLASSPATH",
      "设置为",
      ".;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar（注意开头有一个点）",
      "如果进行到这一步，那么JDK已经安装完成，可以进行验证",
      "首先win+R打开如下面板：进入cmd",
      "输入javac",
      "出现如下内容：如果需要查看JDK版本",
      "使用java -version命令",
      "出现如下信息：这就意味着JDK安装完成",
      "这是Eclipse配置java项目的第一步",
      "下一个教程将展示如何开始第一个java程序",
      "并使用Junit进行测试"
    ],
    "codes": [],
    "date": "2021-05-24",
    "text": "1.Eclipse安装\n下载官方链接：https://www.eclipse.org/downloads/\n点击红框中的Download Packages，进入如下页面：\n根据使用的系统选择第一项中的Eclipse版本即可，后续只需要按照提示内容安装即可，不再赘述。\n2.JDK安装\n2.1下载\n由于我们需要进行java开发，因此需要下载并配置JDK，具体方法如下：\n官方下载链接：https://www.oracle.com/java/technologies/javase-downloads.html\n如果使用官方链接直接点击Download,选择合适的版本即可。如果觉得官方链接太慢可以使用如下链接：\n华为云镜像：https://repo.huaweicloud.com/java/jdk/，进入之后选择合适的版本和系统即可。\n2.2安装\n点击下载好的exe文件，出现如下安装指引\n点击下一步后出现如下页面，可以点击修改，更改安装地址，例如本人改为E:\\JDK\\JDK8，之后点击下一步等待安装即可。\n由于本人安装的是JDK8，因此还需要安装JRE（如果是JDK10后的版本无此过程），安装完成后，会弹出JRE安装界面，如下：\n等待JRE安装完成即可。\n2.3环境变量配置\n在Win10系统中演示，其他系统同理。\n打开系统属性界面（如果找不到直接在设置界面的搜索框中搜索变量，选择编辑系统变量选项即可）\n点击环境变量，进入如下界面，点击新建或编辑即可操作\n由于本人电脑上已经配置了JDK11，因此JAVA_HOME等已经创建，第一次配置时新建即可。\n1.新建JAVA_HOME，将其设置为JDK安装目录。\n2.新建Path（如果已有的话再末尾添加即可），添加一项，为\n%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n3.新建CLASSPATH，设置为\n.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar（注意开头有一个点）\n如果进行到这一步，那么JDK已经安装完成，可以进行验证。首先win+R打开如下面板：\n进入cmd，输入javac，出现如下内容：\n如果需要查看JDK版本，使用java -version命令，出现如下信息：\n这就意味着JDK安装完成。\n这是Eclipse配置java项目的第一步，下一个教程将展示如何开始第一个java程序，并使用Junit进行测试。\n"
  },
  {
    "head": "RuntimeError: Can only calculate the mean of floating types. Got Long instead. 解决",
    "paragraphs": [
      "最近在使用pytorch搭建一个网络的时候遇到一个问题，使用torch.mean计算行或者列的平均值的时候，由于之前的tensor中全是int型，程序出现了标题中的报错，因此解决方法如下：将需要计算的tensor使用.float()函数转换成float型，示例代码如下：",
      "注意：dim=0按行求平均，dim=1按列求平均，视情况使用"
    ],
    "sentences": [
      "最近在使用pytorch搭建一个网络的时候遇到一个问题",
      "使用torch.mean计算行或者列的平均值的时候",
      "由于之前的tensor中全是int型",
      "程序出现了标题中的报错",
      "因此解决方法如下：将需要计算的tensor使用.float()函数转换成float型",
      "示例代码如下：注意：dim=0按行求平均",
      "dim=1按列求平均",
      "视情况使用"
    ],
    "codes": [
      "import torch\na=torch.tensor([[1,2,3],[2,3,4]])\nprint(torch.mean(a.float(),dim=0))\n"
    ],
    "date": "2021-08-07",
    "text": "最近在使用pytorch搭建一个网络的时候遇到一个问题，使用torch.mean计算行或者列的平均值的时候，由于之前的tensor中全是int型，程序出现了标题中的报错，因此解决方法如下：将需要计算的tensor使用.float()函数转换成float型，示例代码如下：\n注意：dim=0按行求平均，dim=1按列求平均，视情况使用\n"
  },
  {
    "head": "List的浅拷贝和深拷贝",
    "paragraphs": [
      "List的拷贝",
      "在写实验的时候发现List的常见的复制方式复制完后的结果居然不是和原List无关的，查阅资料之后记录这一情况。",
      "首先展示一下我发现问题的一个简化示例：",
      "输出结果如下：",
      "可以发现，a居然跟随着b的变化一起变化了，这显然和我们的设计要求不一致，接下来就来看看List的复制的几种情况。",
      "1.浅拷贝",
      "我们上面展示的这种方法就是浅拷贝的一种，可以说是我日常复制List的时候最常用的。顾名思义，浅拷贝将原List和拷贝List中的元素指向同一个地址，要是刚好这个元素的类型是mutable的，那么就会出现上述情况，修改b结果把a也给修改了。以下是浅拷贝的几种不同的方式",
      "1.1 遍历循环复制",
      "也就是上述代码展示的了，不再赘述。",
      "1.2 使用List实现类的构造方法",
      "如下代码展示，其实和遍历复制本质相同，只是使用了构造方法。",
      "我们可以分析一下ArrayList的源码，就可以发现事实上它是利用了一个叫做copyOf的函数实现的构造函数的主要功能，构造函数源码如下：",
      "我们可以继续分析copyOf函数的源码，发现调用了一个System.arraycopy的函数，copyOf源码如下：",
      "继续看System.arraycopy的源码，这是一个naive函数，那就不继续分析了，关键在于这个函数实现的功能就是实现数组之间的复制，而且由调用这一方法的构造函数也是浅拷贝的一种。",
      "1.3 list.addAll()",
      "使用方法：",
      "源码如下：",
      "通过简单查看其源码发现和构造函数的复制函数方法没什么两样，不再赘述。",
      "1.4 System.arraycopy()",
      "不再赘述，和上面一样，调用方法参见addAll源码即可。",
      "1.5 使用Stream的方式copy",
      "使用方法：",
      "2.List深拷贝",
      "和浅拷贝不同，那么显然深拷贝就是a与b的元素指向不同的地址，因此a与b内容相同，但是修改的时候互不影响，这才是我们在大多数情况下比较符合我们要求的拷贝方法。以下两种方法参考博客：https://blog.csdn.net/qq_35507234/article/details/85070429",
      "2.1 使用序列化方法",
      "2.2 clone方法",
      "3. 使用场景",
      "很显然，在没有特殊情况的时候使用浅拷贝绰绰有余，例如List中的元素如果是String，那么使用浅拷贝并不会存在a与b同时修改的情况，这是因为String是Immutable的，例如我们对b这个List中的某一个String进行修改，那么这个String会指向一段新的地址，而a的相同位置的元素指向原来的地址不变，因此不存在同步变化的情况，使用浅拷贝即可。",
      "但是如果我们真的需要使用一个元素是mutable类型的List的话，而且这个List还有可能在多处被复制使用的话就需要考虑深拷贝了。例如文章最开始那个例子，如果List的元素是自定义的Person类，而且这是一个mutable的ADT，那么使用浅拷贝可能存在风险。"
    ],
    "sentences": [
      "List的拷贝",
      "在写实验的时候发现List的常见的复制方式复制完后的结果居然不是和原List无关的",
      "查阅资料之后记录这一情况",
      "首先展示一下我发现问题的一个简化示例：输出结果如下：可以发现",
      "a居然跟随着b的变化一起变化了",
      "这显然和我们的设计要求不一致",
      "接下来就来看看List的复制的几种情况",
      "1.浅拷贝",
      "我们上面展示的这种方法就是浅拷贝的一种",
      "可以说是我日常复制List的时候最常用的",
      "顾名思义",
      "浅拷贝将原List和拷贝List中的元素指向同一个地址",
      "要是刚好这个元素的类型是mutable的",
      "那么就会出现上述情况",
      "修改b结果把a也给修改了",
      "以下是浅拷贝的几种不同的方式",
      "1.1 遍历循环复制",
      "也就是上述代码展示的了，不再赘述",
      "1.2 使用List实现类的构造方法",
      "如下代码展示，其实和遍历复制本质相同，只是使用了构造方法",
      "我们可以分析一下ArrayList的源码",
      "就可以发现事实上它是利用了一个叫做copyOf的函数实现的构造函数的主要功能",
      "构造函数源码如下：我们可以继续分析copyOf函数的源码",
      "发现调用了一个System.arraycopy的函数",
      "copyOf源码如下：继续看System.arraycopy的源码",
      "这是一个naive函数",
      "那就不继续分析了",
      "关键在于这个函数实现的功能就是实现数组之间的复制",
      "而且由调用这一方法的构造函数也是浅拷贝的一种",
      "1.3 list.addAll()",
      "使用方法：源码如下：通过简单查看其源码发现和构造函数的复制函数方法没什么两样",
      "不再赘述",
      "1.4 System.arraycopy()",
      "不再赘述，和上面一样，调用方法参见addAll源码即可",
      "1.5 使用Stream的方式copy",
      "使用方法：2.List深拷贝",
      "和浅拷贝不同",
      "那么显然深拷贝就是a与b的元素指向不同的地址",
      "因此a与b内容相同",
      "但是修改的时候互不影响",
      "这才是我们在大多数情况下比较符合我们要求的拷贝方法",
      "以下两种方法参考博客：https://blog.csdn.net/qq_35507234/article/details/85070429",
      "2.1 使用序列化方法",
      "2.2 clone方法",
      "3. 使用场景",
      "很显然",
      "在没有特殊情况的时候使用浅拷贝绰绰有余",
      "例如List中的元素如果是String",
      "那么使用浅拷贝并不会存在a与b同时修改的情况",
      "这是因为String是Immutable的",
      "例如我们对b这个List中的某一个String进行修改",
      "那么这个String会指向一段新的地址",
      "而a的相同位置的元素指向原来的地址不变",
      "因此不存在同步变化的情况",
      "使用浅拷贝即可",
      "但是如果我们真的需要使用一个元素是mutable类型的List的话",
      "而且这个List还有可能在多处被复制使用的话就需要考虑深拷贝了",
      "例如文章最开始那个例子",
      "如果List的元素是自定义的Person类",
      "而且这是一个mutable的ADT",
      "那么使用浅拷贝可能存在风险"
    ],
    "codes": [
      "public class Person {\n    private String name;\n    private int age;\n    public Person(String name,int age)\n    {\n        this.name=name;\n        this.age=age;\n    }\n    public void setAge(int age)\n    {\n        this.age=age;\n    }\n    @Override\n    public String toString()\n    {\n        return this.name+this.age;\n    }\n    public static void main(String[]argv)\n    {\n        List<Person> a = new ArrayList<>();\n        Person p1=new Person(\"john\",20);\n        Person p2=new Person(\"jack\",30);\n        a.add(p1);\n        a.add(p2);\n        List<Person> b = new ArrayList<>();\n        for(int i=0;i<a.size();i++)\n        {\n            b.add(a.get(i));\n        }\n        System.out.println(\"刚复制完时：\");\n        System.out.println(\"a:\"+a.toString());\n        System.out.println(\"b:\"+b.toString());\n        b.get(1).setAge(40);\n        System.out.println(\"修改b之后：\");\n        System.out.println(\"a:\"+a.toString());\n        System.out.println(\"b:\"+b.toString());\n    }\n\n}\n",
      "刚复制完时：\na:[john20, jack30]\nb:[john20, jack30]\n修改b之后：\na:[john20, jack40]\nb:[john20, jack40]\n",
      "List<Person> b = new ArrayList<>(a);\n",
      "  public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n",
      "public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n        @SuppressWarnings(\"unchecked\")\n        T[] copy = ((Object)newType == (Object)Object[].class)\n            ? (T[]) new Object[newLength]\n            : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n        System.arraycopy(original, 0, copy, 0,\n                         Math.min(original.length, newLength));\n        return copy;\n    }\n",
      "List<Person> a = new ArrayList<>();\n        Person p1=new Person(\"john\",20);\n        Person p2=new Person(\"jack\",30);\n        a.add(p1);\n        a.add(p2);\n        List<Person> b = new ArrayList<>();\n        b.addAll(a);\n",
      "public boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n",
      "List<Person> b = a.stream().collect(Collectors.toList());\n",
      "public static <T> List<T> deepCopy(List<T> src) throws IOException, ClassNotFoundException {  \n    ByteArrayOutputStream byteOut = new ByteArrayOutputStream();  \n    ObjectOutputStream out = new ObjectOutputStream(byteOut);  \n    out.writeObject(src);  \n \n    ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());  \n    ObjectInputStream in = new ObjectInputStream(byteIn);  \n    @SuppressWarnings(\"unchecked\")  \n    List<T> dest = (List<T>) in.readObject();  \n    return dest;  \n}  \n \nList<Person> destList=deepCopy(srcList);  //调用该方法\n",
      "public class A implements Cloneable {   \n    public String name[];   \n \n    public A(){   \n        name=new String[2];   \n    }   \n \n    public Object clone() {   \n        A o = null;   \n        try {   \n            o = (A) super.clone();   \n        } catch (CloneNotSupportedException e) {   \n            e.printStackTrace();   \n        }   \n        return o;   \n    }   \n}  \nfor(int i=0;i<n;i+=){\ncopy.add((A)src.get(i).clone());\n}\n"
    ],
    "date": "2021-07-06",
    "text": "List的拷贝\n在写实验的时候发现List的常见的复制方式复制完后的结果居然不是和原List无关的，查阅资料之后记录这一情况。\n首先展示一下我发现问题的一个简化示例：\n输出结果如下：\n可以发现，a居然跟随着b的变化一起变化了，这显然和我们的设计要求不一致，接下来就来看看List的复制的几种情况。\n1.浅拷贝\n我们上面展示的这种方法就是浅拷贝的一种，可以说是我日常复制List的时候最常用的。顾名思义，浅拷贝将原List和拷贝List中的元素指向同一个地址，要是刚好这个元素的类型是mutable的，那么就会出现上述情况，修改b结果把a也给修改了。以下是浅拷贝的几种不同的方式\n1.1 遍历循环复制\n也就是上述代码展示的了，不再赘述。\n1.2 使用List实现类的构造方法\n如下代码展示，其实和遍历复制本质相同，只是使用了构造方法。\n我们可以分析一下ArrayList的源码，就可以发现事实上它是利用了一个叫做copyOf的函数实现的构造函数的主要功能，构造函数源码如下：\n我们可以继续分析copyOf函数的源码，发现调用了一个System.arraycopy的函数，copyOf源码如下：\n继续看System.arraycopy的源码，这是一个naive函数，那就不继续分析了，关键在于这个函数实现的功能就是实现数组之间的复制，而且由调用这一方法的构造函数也是浅拷贝的一种。\n1.3 list.addAll()\n使用方法：\n源码如下：\n通过简单查看其源码发现和构造函数的复制函数方法没什么两样，不再赘述。\n1.4 System.arraycopy()\n不再赘述，和上面一样，调用方法参见addAll源码即可。\n1.5 使用Stream的方式copy\n使用方法：\n2.List深拷贝\n和浅拷贝不同，那么显然深拷贝就是a与b的元素指向不同的地址，因此a与b内容相同，但是修改的时候互不影响，这才是我们在大多数情况下比较符合我们要求的拷贝方法。以下两种方法参考博客：https://blog.csdn.net/qq_35507234/article/details/85070429\n2.1 使用序列化方法\n2.2 clone方法\n3. 使用场景\n很显然，在没有特殊情况的时候使用浅拷贝绰绰有余，例如List中的元素如果是String，那么使用浅拷贝并不会存在a与b同时修改的情况，这是因为String是Immutable的，例如我们对b这个List中的某一个String进行修改，那么这个String会指向一段新的地址，而a的相同位置的元素指向原来的地址不变，因此不存在同步变化的情况，使用浅拷贝即可。\n但是如果我们真的需要使用一个元素是mutable类型的List的话，而且这个List还有可能在多处被复制使用的话就需要考虑深拷贝了。例如文章最开始那个例子，如果List的元素是自定义的Person类，而且这是一个mutable的ADT，那么使用浅拷贝可能存在风险。\n"
  },
  {
    "head": "java中的==和equals的区别",
    "paragraphs": [
      "==和equals的区别",
      "之前在做软件构造实验的时候遇到了应该使用==还是equals判断相等的情况，结合上课讲的内容和查阅的资料在此记录二者的相同点和区别，如有不正确的地方请批评指正。",
      "1. 相同点",
      "很显然二者的相同点就是都是用来判断两个元素是否相同的，只是使用的方式以及判断的方法不同。",
      "2.不同点",
      "首先，最大的区别就是==是一个运算符而equals是一个函数，这是二者本质上的不同，当然，在使用的时候这不是我们需要考虑的重点。在使用的时候我们需要考虑的是：",
      "1.对于一些基本数据类型例如byte，int等只能使用==，表示对于数值或者是基本数据类型值的比较，由于这些都是基本数据类型，因此不存在使用equals函数来比较的必要",
      "2.对于一些复合数据类型，如果我们使用==来表示比较比较两个元素的话我们比较的是他们的存放地址的相同与否，也就是如果们new了两个复合数据类型，尽管它们内部的值可能是相同的，但是比较结果是不相同的，很显然在大多数时候这都是不符合我们的使用要求的。",
      "3.对于复合数据类型，使用的equals都是继承自java的Object类，在不进行override的情况下比较的还是存放地址，因为Object中默认是使用==实现这个函数的，可以通过override来重写，定义我们需要的比较方式，例如Interger，Date，String等复合数据类型内部都进行了重写，不再是比较存放的地址位置。",
      "具体例子",
      "代码：",
      "4.关于重写equals",
      "一般来说，如果我们定义的一个ADT我们希望它是immutable类型的时候我们需要重写equals，这是因为很可能存在使用这个ADT，new出的两个实体由于存放的位置不同而无法使用==比较是否相等，这时候就需要重写equals，而mutable类型的ADT一般不需要重写equals方法。"
    ],
    "sentences": [
      "==和equals的区别",
      "之前在做软件构造实验的时候遇到了应该使用==还是equals判断相等的情况",
      "结合上课讲的内容和查阅的资料在此记录二者的相同点和区别",
      "如有不正确的地方请批评指正",
      "1. 相同点",
      "很显然二者的相同点就是都是用来判断两个元素是否相同的",
      "只是使用的方式以及判断的方法不同",
      "2.不同点",
      "首先",
      "最大的区别就是==是一个运算符而equals是一个函数",
      "这是二者本质上的不同",
      "当然",
      "在使用的时候这不是我们需要考虑的重点",
      "在使用的时候我们需要考虑的是：1.对于一些基本数据类型例如byte",
      "int等只能使用==",
      "表示对于数值或者是基本数据类型值的比较",
      "由于这些都是基本数据类型",
      "因此不存在使用equals函数来比较的必要",
      "2.对于一些复合数据类型",
      "如果我们使用==来表示比较比较两个元素的话我们比较的是他们的存放地址的相同与否",
      "也就是如果们new了两个复合数据类型",
      "尽管它们内部的值可能是相同的",
      "但是比较结果是不相同的",
      "很显然在大多数时候这都是不符合我们的使用要求的",
      "3.对于复合数据类型",
      "使用的equals都是继承自java的Object类",
      "在不进行override的情况下比较的还是存放地址",
      "因为Object中默认是使用==实现这个函数的",
      "可以通过override来重写",
      "定义我们需要的比较方式",
      "例如Interger",
      "Date",
      "String等复合数据类型内部都进行了重写",
      "不再是比较存放的地址位置",
      "具体例子",
      "代码：4.关于重写equals",
      "一般来说",
      "如果我们定义的一个ADT我们希望它是immutable类型的时候我们需要重写equals",
      "这是因为很可能存在使用这个ADT",
      "new出的两个实体由于存放的位置不同而无法使用==比较是否相等",
      "这时候就需要重写equals",
      "而mutable类型的ADT一般不需要重写equals方法"
    ],
    "codes": [
      " //基本数据类型的比较\n        int test1 = 10;\n        int test2 = 10;\n        System.out.println(test1 == test2);   //true\n        //引用数据类型的比较\n        String s1 = \"test\";\n        String s2 = \"test\";\n        System.out.println(s1 == s2);        //true\n        System.out.println(s1.equals(s2));    //true\n        //String类中==与equals的比较\n        String s3 = new String(\"test\");     \n        String s4 = new String(\"test\");\n        System.out.println(s3 == s4);        //false\n        System.out.println(s3.equals(s4));    //true\n        //非String类中==与equals类型的比较\n\n"
    ],
    "date": "2021-06-30",
    "text": "==和equals的区别\n之前在做软件构造实验的时候遇到了应该使用==还是equals判断相等的情况，结合上课讲的内容和查阅的资料在此记录二者的相同点和区别，如有不正确的地方请批评指正。\n1. 相同点\n很显然二者的相同点就是都是用来判断两个元素是否相同的，只是使用的方式以及判断的方法不同。\n2.不同点\n首先，最大的区别就是==是一个运算符而equals是一个函数，这是二者本质上的不同，当然，在使用的时候这不是我们需要考虑的重点。在使用的时候我们需要考虑的是：\n1.对于一些基本数据类型例如byte，int等只能使用==，表示对于数值或者是基本数据类型值的比较，由于这些都是基本数据类型，因此不存在使用equals函数来比较的必要\n2.对于一些复合数据类型，如果我们使用==来表示比较比较两个元素的话我们比较的是他们的存放地址的相同与否，也就是如果们new了两个复合数据类型，尽管它们内部的值可能是相同的，但是比较结果是不相同的，很显然在大多数时候这都是不符合我们的使用要求的。\n3.对于复合数据类型，使用的equals都是继承自java的Object类，在不进行override的情况下比较的还是存放地址，因为Object中默认是使用==实现这个函数的，可以通过override来重写，定义我们需要的比较方式，例如Interger，Date，String等复合数据类型内部都进行了重写，不再是比较存放的地址位置。\n具体例子\n代码：\n4.关于重写equals\n一般来说，如果我们定义的一个ADT我们希望它是immutable类型的时候我们需要重写equals，这是因为很可能存在使用这个ADT，new出的两个实体由于存放的位置不同而无法使用==比较是否相等，这时候就需要重写equals，而mutable类型的ADT一般不需要重写equals方法。\n"
  },
  {
    "head": "软件构造的三维度八视图",
    "paragraphs": [
      "软件构造的三维度八视图",
      "软件构造的三维度八视图是在软件的构造和后期维护过程中的一个概念，其实就是软件构造应该如何构造的问题，事实上，“软件构造”就可以看做是三维度八视图之间的相互切换的过程。在此对于这三维度和八视图进行简要的归纳总结。",
      "三维度八视图的英文版图如下：",
      "中文翻译版如下：",
      "以下是我对三维度八视图的理解，如有不正确请批评指正：",
      "1.三维度",
      "首先时刻和阶段这一维度较好理解，就是指是在某一个时刻或者是一段时间内进行观察得到的结果。",
      "而代码和构件这一维度来看，很显然，代码层面就是指直接与源代码相关的部分而构件层面更多的指这个项目使用的一些外部的配置、库等信息。",
      "编译与运行时这一维度也较好理解，不过多赘述",
      "2.八视图",
      "个人感觉这八个视图事实上和计算机系统中很多知识是重叠的，由于这学期刚好两门课都学，因此尝试从不同角度对八视图进行解释。",
      "2.1编译时——时刻——代码",
      "很显然，这一部分如果需要对应于计算机系统中的编译过程，在c语言中由gcc完成，在java中由JDK完成这一过程，与这一过程密切相关的就是源代码，也就是日常最常接触到的，其次就是语法分析数，这是由编译器产生的一棵树，主要是对程序进行词义分析、语法分析等工作，语法分析树这一部分知识可以见形式语言与自动机或编译原理课程。一棵c语言语法分析树示例如下：",
      "2.2 编译时——时刻——构件",
      "显然，这一部分对应于静态链接的过程，在c语言链接过程中使用链接器（ld）将文件转化为可执行目标文件，在java中这一流程类似，也是将外部的包等代码中使用的外部的包信息与代码文件进行链接。",
      "2.3 编译时——阶段——代码",
      "这一阶段事实上对应于源代码的一个变化的过程，主要体现的是对于源代码不断地修改，很好理解。",
      "2.4 编译时——阶段——构件",
      "首先，对应于配置项的变化，配置项的解释就是：软件生存周期各个阶段活动的产物经审批后即可称之为软件",
      "配置项",
      "。也就是在源代码变化之后生成了多个部件，我们可能有了这个软件的不同零件，将其组合起来之后就是整个软件；其次就是版本控制，这一点很好理解，处于维护、功能升级等不同原因，软件总会不断推出新版本，这些版本表现的就是软件的一个演变过程。",
      "github为我们每一个项目维护的一个提交历史记录就可以看成是这一阶段的一个简单示例",
      "2.5 运行时——时刻——代码",
      "这一阶段对应于在运行中代码的变化，主要表示的就是例如在运行时某一时刻某个变量的值是什么样的，事实上我们对于程序打断点调试的时候看的就是这一个视图的内容。",
      "2.6 运行时——时刻——构建",
      "很显然，这一阶段对应于动态链接，可以简单理解成在加载的时候再对使用的一些外部构件进行的链接；除了动态链接之外，这一视图对应的很重要的一部分是类似于在运行时使用数据库这种情况，数据库并没有嵌入软件，而是在软件运行时某个时刻请求数据库的信息。",
      "2.7 运行时——阶段——代码",
      "这一部分可以看成是在程序运行过程中栈的信息的一个展示，最明显的一个展示就是java程序报错的时候出现的报错信息，这就是在java运行过程中与某个报错相关的栈的信息的展示，一个简单的例子如下图所示：",
      "2.8 运行时——阶段——构件",
      "这一阶段主要对应于事件日志这一类信息，其事实上就是构件层面上的代码运行过程中的栈信息，但是它并没有2.7中栈信息内容那么繁多，其主要记录代码运行过程中的重要的事件的发生信息。",
      "以上就是我对于三维度八视图的一些理解，如有错误或不足希望批评指正。"
    ],
    "sentences": [
      "软件构造的三维度八视图",
      "软件构造的三维度八视图是在软件的构造和后期维护过程中的一个概念",
      "其实就是软件构造应该如何构造的问题",
      "事实上",
      "“软件构造”就可以看做是三维度八视图之间的相互切换的过程",
      "在此对于这三维度和八视图进行简要的归纳总结",
      "三维度八视图的英文版图如下：中文翻译版如下：以下是我对三维度八视图的理解",
      "如有不正确请批评指正：1.三维度",
      "首先时刻和阶段这一维度较好理解",
      "就是指是在某一个时刻或者是一段时间内进行观察得到的结果",
      "而代码和构件这一维度来看",
      "很显然",
      "代码层面就是指直接与源代码相关的部分而构件层面更多的指这个项目使用的一些外部的配置、库等信息",
      "编译与运行时这一维度也较好理解，不过多赘述",
      "2.八视图",
      "个人感觉这八个视图事实上和计算机系统中很多知识是重叠的",
      "由于这学期刚好两门课都学",
      "因此尝试从不同角度对八视图进行解释",
      "2.1编译时——时刻——代码",
      "很显然",
      "这一部分如果需要对应于计算机系统中的编译过程",
      "在c语言中由gcc完成",
      "在java中由JDK完成这一过程",
      "与这一过程密切相关的就是源代码",
      "也就是日常最常接触到的",
      "其次就是语法分析数",
      "这是由编译器产生的一棵树",
      "主要是对程序进行词义分析、语法分析等工作",
      "语法分析树这一部分知识可以见形式语言与自动机或编译原理课程",
      "一棵c语言语法分析树示例如下：2.2 编译时——时刻——构件",
      "显然",
      "这一部分对应于静态链接的过程",
      "在c语言链接过程中使用链接器（ld）将文件转化为可执行目标文件",
      "在java中这一流程类似",
      "也是将外部的包等代码中使用的外部的包信息与代码文件进行链接",
      "2.3 编译时——阶段——代码",
      "这一阶段事实上对应于源代码的一个变化的过程",
      "主要体现的是对于源代码不断地修改",
      "很好理解",
      "2.4 编译时——阶段——构件",
      "首先",
      "对应于配置项的变化",
      "配置项的解释就是：软件生存周期各个阶段活动的产物经审批后即可称之为软件",
      "配置项",
      "也就是在源代码变化之后生成了多个部件",
      "我们可能有了这个软件的不同零件",
      "将其组合起来之后就是整个软件；其次就是版本控制",
      "这一点很好理解",
      "处于维护、功能升级等不同原因",
      "软件总会不断推出新版本",
      "这些版本表现的就是软件的一个演变过程",
      "github为我们每一个项目维护的一个提交历史记录就可以看成是这一阶段的一个简单示例",
      "2.5 运行时——时刻——代码",
      "这一阶段对应于在运行中代码的变化",
      "主要表示的就是例如在运行时某一时刻某个变量的值是什么样的",
      "事实上我们对于程序打断点调试的时候看的就是这一个视图的内容",
      "2.6 运行时——时刻——构建",
      "很显然",
      "这一阶段对应于动态链接",
      "可以简单理解成在加载的时候再对使用的一些外部构件进行的链接；除了动态链接之外",
      "这一视图对应的很重要的一部分是类似于在运行时使用数据库这种情况",
      "数据库并没有嵌入软件",
      "而是在软件运行时某个时刻请求数据库的信息",
      "2.7 运行时——阶段——代码",
      "这一部分可以看成是在程序运行过程中栈的信息的一个展示",
      "最明显的一个展示就是java程序报错的时候出现的报错信息",
      "这就是在java运行过程中与某个报错相关的栈的信息的展示",
      "一个简单的例子如下图所示：2.8 运行时——阶段——构件",
      "这一阶段主要对应于事件日志这一类信息",
      "其事实上就是构件层面上的代码运行过程中的栈信息",
      "但是它并没有2.7中栈信息内容那么繁多",
      "其主要记录代码运行过程中的重要的事件的发生信息",
      "以上就是我对于三维度八视图的一些理解",
      "如有错误或不足希望批评指正"
    ],
    "codes": [],
    "date": "2021-06-29",
    "text": "软件构造的三维度八视图\n软件构造的三维度八视图是在软件的构造和后期维护过程中的一个概念，其实就是软件构造应该如何构造的问题，事实上，“软件构造”就可以看做是三维度八视图之间的相互切换的过程。在此对于这三维度和八视图进行简要的归纳总结。\n三维度八视图的英文版图如下：\n中文翻译版如下：\n以下是我对三维度八视图的理解，如有不正确请批评指正：\n1.三维度\n首先时刻和阶段这一维度较好理解，就是指是在某一个时刻或者是一段时间内进行观察得到的结果。\n而代码和构件这一维度来看，很显然，代码层面就是指直接与源代码相关的部分而构件层面更多的指这个项目使用的一些外部的配置、库等信息。\n编译与运行时这一维度也较好理解，不过多赘述\n2.八视图\n个人感觉这八个视图事实上和计算机系统中很多知识是重叠的，由于这学期刚好两门课都学，因此尝试从不同角度对八视图进行解释。\n2.1编译时——时刻——代码\n很显然，这一部分如果需要对应于计算机系统中的编译过程，在c语言中由gcc完成，在java中由JDK完成这一过程，与这一过程密切相关的就是源代码，也就是日常最常接触到的，其次就是语法分析数，这是由编译器产生的一棵树，主要是对程序进行词义分析、语法分析等工作，语法分析树这一部分知识可以见形式语言与自动机或编译原理课程。一棵c语言语法分析树示例如下：\n2.2 编译时——时刻——构件\n显然，这一部分对应于静态链接的过程，在c语言链接过程中使用链接器（ld）将文件转化为可执行目标文件，在java中这一流程类似，也是将外部的包等代码中使用的外部的包信息与代码文件进行链接。\n2.3 编译时——阶段——代码\n这一阶段事实上对应于源代码的一个变化的过程，主要体现的是对于源代码不断地修改，很好理解。\n2.4 编译时——阶段——构件\n首先，对应于配置项的变化，配置项的解释就是：软件生存周期各个阶段活动的产物经审批后即可称之为软件\n配置项\n。也就是在源代码变化之后生成了多个部件，我们可能有了这个软件的不同零件，将其组合起来之后就是整个软件；其次就是版本控制，这一点很好理解，处于维护、功能升级等不同原因，软件总会不断推出新版本，这些版本表现的就是软件的一个演变过程。\ngithub为我们每一个项目维护的一个提交历史记录就可以看成是这一阶段的一个简单示例\n2.5 运行时——时刻——代码\n这一阶段对应于在运行中代码的变化，主要表示的就是例如在运行时某一时刻某个变量的值是什么样的，事实上我们对于程序打断点调试的时候看的就是这一个视图的内容。\n2.6 运行时——时刻——构建\n很显然，这一阶段对应于动态链接，可以简单理解成在加载的时候再对使用的一些外部构件进行的链接；除了动态链接之外，这一视图对应的很重要的一部分是类似于在运行时使用数据库这种情况，数据库并没有嵌入软件，而是在软件运行时某个时刻请求数据库的信息。\n2.7 运行时——阶段——代码\n这一部分可以看成是在程序运行过程中栈的信息的一个展示，最明显的一个展示就是java程序报错的时候出现的报错信息，这就是在java运行过程中与某个报错相关的栈的信息的展示，一个简单的例子如下图所示：\n2.8 运行时——阶段——构件\n这一阶段主要对应于事件日志这一类信息，其事实上就是构件层面上的代码运行过程中的栈信息，但是它并没有2.7中栈信息内容那么繁多，其主要记录代码运行过程中的重要的事件的发生信息。\n以上就是我对于三维度八视图的一些理解，如有错误或不足希望批评指正。\n"
  },
  {
    "head": "解决numpy.ndarray size changed, may indicate binary incompatibility.报错",
    "paragraphs": [
      "目前正在学习使用一个python包的使用，运行示例代码过程中出现了numpy.ndarray size changed, may indicate binary incompatibility报错。如下图所示：",
      "实测只需要将numpy更新为最新版本（本人更新为1.20.2）即可解决问题。其中pip过程中可能提示tensorflow与最新版本的numpy不匹配，如下图：",
      "经测试暂时未发现tensorflow运行出现问题。"
    ],
    "sentences": [
      "目前正在学习使用一个python包的使用",
      "运行示例代码过程中出现了numpy.ndarray size changed, may indicate binary incompatibility报错",
      "如下图所示：实测只需要将numpy更新为最新版本（本人更新为1.20.2）即可解决问题",
      "其中pip过程中可能提示tensorflow与最新版本的numpy不匹配",
      "如下图：经测试暂时未发现tensorflow运行出现问题"
    ],
    "codes": [],
    "date": "2021-04-19",
    "text": "目前正在学习使用一个python包的使用，运行示例代码过程中出现了numpy.ndarray size changed, may indicate binary incompatibility报错。如下图所示：\n实测只需要将numpy更新为最新版本（本人更新为1.20.2）即可解决问题。其中pip过程中可能提示tensorflow与最新版本的numpy不匹配，如下图：\n经测试暂时未发现tensorflow运行出现问题。\n"
  },
  {
    "head": "网络正常但Chrome不能上网的解决方法",
    "paragraphs": [
      "最近经常发生网络正常，但是Chrome无法连接网络的情况，记录解决方法：",
      "1.在Chrome的设置中打开电脑的代理设置：",
      "2.将自动检测打开之后点击保存：",
      "3.如果本来就是开着的可以尝试关闭之后再打开，点击保存。",
      "4.注意最后将Chrome浏览器关闭再重新打开，就可以正常上网了。"
    ],
    "sentences": [
      "最近经常发生网络正常",
      "但是Chrome无法连接网络的情况",
      "记录解决方法：1.在Chrome的设置中打开电脑的代理设置：2.将自动检测打开之后点击保存：3.如果本来就是开着的可以尝试关闭之后再打开",
      "点击保存",
      "4.注意最后将Chrome浏览器关闭再重新打开",
      "就可以正常上网了"
    ],
    "codes": [],
    "date": "2021-06-27",
    "text": "最近经常发生网络正常，但是Chrome无法连接网络的情况，记录解决方法：\n1.在Chrome的设置中打开电脑的代理设置：\n2.将自动检测打开之后点击保存：\n3.如果本来就是开着的可以尝试关闭之后再打开，点击保存。\n4.注意最后将Chrome浏览器关闭再重新打开，就可以正常上网了。\n"
  },
  {
    "head": "leetcode面试题 17.16. 按摩师c++",
    "paragraphs": [
      "leetcode面试题 17.16. 按摩师c++",
      "一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。",
      "注意：本题相对原题稍作改动",
      "示例 1：",
      "输入： [1,2,3,1]",
      "输出： 4",
      "解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。",
      "示例 2：",
      "输入： [2,7,9,3,1]",
      "输出： 12",
      "解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。",
      "示例 3：",
      "输入： [2,1,4,5,3,1,1,3]",
      "输出： 12",
      "解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。",
      "本题和爬楼梯等问题实质相同，分析可看",
      "leetcode198. 打家劫舍c++"
    ],
    "sentences": [
      "leetcode面试题 17.16. 按摩师c++",
      "一个有名的按摩师会收到源源不断的预约请求",
      "每个预约都可以选择接或不接",
      "在每次预约服务之间要有休息时间，因此她不能接受相邻的预约",
      "给定一个预约请求序列",
      "替按摩师找到最优的预约集合（总预约时间最长）",
      "返回总的分钟数",
      "注意：本题相对原题稍作改动",
      "示例 1：输入： [1,2,3,1]",
      "输出： 4",
      "解释： 选择 1 号预约和 3 号预约",
      "总时长 = 1 + 3 = 4",
      "示例 2：输入： [2,7,9,3,1]",
      "输出： 12",
      "解释： 选择 1 号预约、 3 号预约和 5 号预约",
      "总时长 = 2 + 9 + 1 = 12",
      "示例 3：输入： [2,1,4,5,3,1,1,3]",
      "输出： 12",
      "解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约",
      "总时长 = 2 + 4 + 3 + 3 = 12",
      "本题和爬楼梯等问题实质相同，分析可看",
      "leetcode198. 打家劫舍c++"
    ],
    "codes": [
      "来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/the-masseuse-lcci\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n",
      "class Solution {\npublic:\n    int massage(vector<int>& nums) {\n         int n=nums.size();\n         vector<int>dp(n+1);\n         if(n==0)return 0;\n         else if(n==1)return nums[0];\n         else\n        {\n            dp[0]=nums[0];\n            dp[1]=max(nums[0],nums[1]);\n            for(int i=2;i<n;i++)\n            {\n                dp[i]=max(dp[i-1],dp[i-2]+nums[i]);\n            }\n            return dp[n-1];\n        }\n    }\n};\n"
    ],
    "date": "2020-06-20",
    "text": "leetcode面试题 17.16. 按摩师c++\n一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。\n注意：本题相对原题稍作改动\n示例 1：\n输入： [1,2,3,1]\n输出： 4\n解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。\n示例 2：\n输入： [2,7,9,3,1]\n输出： 12\n解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。\n示例 3：\n输入： [2,1,4,5,3,1,1,3]\n输出： 12\n解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。\n本题和爬楼梯等问题实质相同，分析可看\nleetcode198. 打家劫舍c++\n"
  },
  {
    "head": "leetcode121.买卖股票的最佳时机c++",
    "paragraphs": [
      "leetcode121.买卖股票的最佳时机c++",
      "给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。",
      "如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。",
      "注意：你不能在买入股票前卖出股票。",
      "示例 1:",
      "输入: [7,1,5,3,6,4]",
      "输出: 5",
      "解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。",
      "注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。",
      "经尝试，本题采用遍历的做法超出时间限制，那么考虑采用动态规划的做法降低时间复杂度。"
    ],
    "sentences": [
      "leetcode121.买卖股票的最佳时机c++",
      "给定一个数组",
      "它的第 i 个元素是一支给定股票第 i 天的价格",
      "如果你最多只允许完成一笔交易（即买入和卖出一支股票一次）",
      "设计一个算法来计算你所能获取的最大利润",
      "注意：你不能在买入股票前卖出股票",
      "示例 1:输入: [7,1,5,3,6,4]",
      "输出: 5",
      "解释: 在第 2 天（股票价格 = 1）的时候买入",
      "在第 5 天（股票价格 = 6）的时候卖出",
      "最大利润 = 6-1 = 5 ",
      "注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时",
      "你不能在买入前卖出股票",
      "经尝试",
      "本题采用遍历的做法超出时间限制",
      "那么考虑采用动态规划的做法降低时间复杂度"
    ],
    "codes": [
      " 来源：力扣（LeetCode）\n 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n",
      "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty())return 0;       \n        else\n        {\n            int n=prices.size(),profit=0,minnum=prices[0];\n            for(int i=0;i<n;i++)\n            {\n               minnum=min(prices[i],minnum);\n               profit=max(profit,prices[i]-minnum);\n            }\n       return profit;\n        }\n    }\n};\n"
    ],
    "date": "2020-06-22",
    "text": "leetcode121.买卖股票的最佳时机c++\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n注意：你不能在买入股票前卖出股票。\n示例 1:\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n经尝试，本题采用遍历的做法超出时间限制，那么考虑采用动态规划的做法降低时间复杂度。\n"
  },
  {
    "head": "immutable和mutable",
    "paragraphs": [
      "immutable和mutable",
      "复习到了这一部分，记录一下immutable和mutable的性质与区别。",
      "1. 优缺点比较",
      "首先先把二者的优缺点列出来：",
      "优缺点",
      "immutable",
      "mutable",
      "由于内部数据不可变，所以对其频发修改会产生大量的临时拷贝，浪费空间",
      "可变类型由于其内部数据可变，所以其风险更大",
      "内部数据的不可变导致其更加安全，可以用作多线程的共享对象而不必考虑同步问题",
      "可变类型会减少数据的拷贝次数，从而其效率 要高于immutable",
      "2.各自的定义",
      "immutable：一个immutable的对象其值在指定了之后就不可再改变，如果试图修改其内部的值会新建一个新的地址保存新的值。",
      "mutable：一个mutable的对象其值在指定了之后还是可以修改的。",
      "3.举例",
      "在编程语言中这个概念是通用的，以下使用java来举例。",
      "首先，java中很典型的一个immutable的对象就是String。当对String完成初始化之后，String指向的这一段地址的内容就固定了，如果为这个String赋另外一个值，将会给这个String赋一段新的地址，这个新地址中存着新值，如果旧的地址将没有其他对象指向它，将等待回收。以下使用一个SnapShot图来表示这个过程。",
      "而mutable的一个例子就是List，java中的List、set、Map等对象都是可变的，这一点从它们都存在类似于add的方法就可以看出。mutable在改变值的时候不改变地址，而是直接修改原本地址中的值。",
      "4.优缺点分析",
      "每一种对象的存在和使用都是存在其合理性的。以下为两种对象使用过程中的优缺点分析。",
      "4.1 immutable",
      "对于immutable来说，优点十分明显，就是它指向的地址的内容是不可变的，也就不存在两个对象都指向一个地址的时候其中一个对象无法知道另外一个对象是否对这个地址的内容进行修改。也就是说，immutable在很大程度上保证了多线程的时候的正确性。但是缺点同样十分明显，就是每一次修改都要进行一次复制，可能会产生很大的时间开销，同时会产生大量的需要回收的垃圾。例如对于如下代码片段：",
      "对于第一个i来说进行了n次插入意味着复制了n次，也就是这个过程中时间复杂度是O(n^2)的，而这只是一个最简单的一层循环。",
      "4.2 mutable",
      "mutable由于其指向地址内容可变，因此每次修改的时候不需要复制，因此其开销比immutable小很多。但是其缺点就在于如果多个变量指向同一段地址的时候，其中一个对象对于地址内容的修改会影响到其他所有的变量的值，这种影响很有可能导致程序出错，例如如下代码片段：",
      "其中List是一个Mutable的对象，因此a，zoo.animals,b都指向了同一段内存空间，任何一个内容的修改都会造成三个值一起发生变化，因此main函数的输出如下：",
      "很显然这种输出在很大可能性下不是我们想要的，因此使用mutable是存在风险的。",
      "5.使用场景",
      "尽可能使用不可变的对象和不可变的引用。如果可以肯定某一段地址空间只会由一个对象指向，可以考虑使用mutable对象，但是使用的时候一定要注意不要产生多个对象修改一段空间内值的情况。"
    ],
    "sentences": [
      "immutable和mutable",
      "复习到了这一部分",
      "记录一下immutable和mutable的性质与区别",
      "1. 优缺点比较",
      "首先先把二者的优缺点列出来：优缺点",
      "immutable",
      "mutable",
      "由于内部数据不可变",
      "所以对其频发修改会产生大量的临时拷贝",
      "浪费空间",
      "可变类型由于其内部数据可变，所以其风险更大",
      "内部数据的不可变导致其更加安全",
      "可以用作多线程的共享对象而不必考虑同步问题",
      "可变类型会减少数据的拷贝次数",
      "从而其效率 要高于immutable",
      "2.各自的定义",
      "immutable：一个immutable的对象其值在指定了之后就不可再改变",
      "如果试图修改其内部的值会新建一个新的地址保存新的值",
      "mutable：一个mutable的对象其值在指定了之后还是可以修改的",
      "3.举例",
      "在编程语言中这个概念是通用的，以下使用java来举例",
      "首先",
      "java中很典型的一个immutable的对象就是String",
      "当对String完成初始化之后",
      "String指向的这一段地址的内容就固定了",
      "如果为这个String赋另外一个值",
      "将会给这个String赋一段新的地址",
      "这个新地址中存着新值",
      "如果旧的地址将没有其他对象指向它",
      "将等待回收",
      "以下使用一个SnapShot图来表示这个过程",
      "而mutable的一个例子就是List",
      "java中的List、set、Map等对象都是可变的",
      "这一点从它们都存在类似于add的方法就可以看出",
      "mutable在改变值的时候不改变地址",
      "而是直接修改原本地址中的值",
      "4.优缺点分析",
      "每一种对象的存在和使用都是存在其合理性的",
      "以下为两种对象使用过程中的优缺点分析",
      "4.1 immutable",
      "对于immutable来说",
      "优点十分明显",
      "就是它指向的地址的内容是不可变的",
      "也就不存在两个对象都指向一个地址的时候其中一个对象无法知道另外一个对象是否对这个地址的内容进行修改",
      "也就是说",
      "immutable在很大程度上保证了多线程的时候的正确性",
      "但是缺点同样十分明显",
      "就是每一次修改都要进行一次复制",
      "可能会产生很大的时间开销",
      "同时会产生大量的需要回收的垃圾",
      "例如对于如下代码片段：对于第一个i来说进行了n次插入意味着复制了n次",
      "也就是这个过程中时间复杂度是O(n^2)的",
      "而这只是一个最简单的一层循环",
      "4.2 mutable",
      "mutable由于其指向地址内容可变",
      "因此每次修改的时候不需要复制",
      "因此其开销比immutable小很多",
      "但是其缺点就在于如果多个变量指向同一段地址的时候",
      "其中一个对象对于地址内容的修改会影响到其他所有的变量的值",
      "这种影响很有可能导致程序出错",
      "例如如下代码片段：其中List是一个Mutable的对象",
      "因此a",
      "zoo.animals,b都指向了同一段内存空间",
      "任何一个内容的修改都会造成三个值一起发生变化",
      "因此main函数的输出如下：很显然这种输出在很大可能性下不是我们想要的",
      "因此使用mutable是存在风险的",
      "5.使用场景",
      "尽可能使用不可变的对象和不可变的引用",
      "如果可以肯定某一段地址空间只会由一个对象指向",
      "可以考虑使用mutable对象",
      "但是使用的时候一定要注意不要产生多个对象修改一段空间内值的情况"
    ],
    "codes": [
      " public void test(int n)\n    {\n        String s=\"\";\n        for(int i=0;i<n;i++)\n        {\n            s.concat(String.valueOf(i));\n        }\n    }\n",
      "public class Zoo {\n    private List<String> animals;\n    public Zoo(List<String> animals) {\n        this.animals = animals;\n    }\n    public List<String> getAnimals() {\n        return this.animals;\n    }\n    public static void main(String[]argv)\n    {\n        List<String> a = new ArrayList<>();\n        a.addAll(Arrays.asList(\"lion\", \"tiger\", \"bear\"));\n        Zoo zoo = new Zoo(a);\n        a.add(\"zebra\");\n        System.out.println(a);\n        System.out.println(zoo.getAnimals());\n        List<String> b = zoo.getAnimals();\n        b.add(\"flamingo\");\n        System.out.println(a);\n    }\n}\n"
    ],
    "date": "2021-07-05",
    "text": "immutable和mutable\n复习到了这一部分，记录一下immutable和mutable的性质与区别。\n1. 优缺点比较\n首先先把二者的优缺点列出来：\n优缺点\nimmutable\nmutable\n由于内部数据不可变，所以对其频发修改会产生大量的临时拷贝，浪费空间\n可变类型由于其内部数据可变，所以其风险更大\n内部数据的不可变导致其更加安全，可以用作多线程的共享对象而不必考虑同步问题\n可变类型会减少数据的拷贝次数，从而其效率 要高于immutable\n2.各自的定义\nimmutable：一个immutable的对象其值在指定了之后就不可再改变，如果试图修改其内部的值会新建一个新的地址保存新的值。\nmutable：一个mutable的对象其值在指定了之后还是可以修改的。\n3.举例\n在编程语言中这个概念是通用的，以下使用java来举例。\n首先，java中很典型的一个immutable的对象就是String。当对String完成初始化之后，String指向的这一段地址的内容就固定了，如果为这个String赋另外一个值，将会给这个String赋一段新的地址，这个新地址中存着新值，如果旧的地址将没有其他对象指向它，将等待回收。以下使用一个SnapShot图来表示这个过程。\n而mutable的一个例子就是List，java中的List、set、Map等对象都是可变的，这一点从它们都存在类似于add的方法就可以看出。mutable在改变值的时候不改变地址，而是直接修改原本地址中的值。\n4.优缺点分析\n每一种对象的存在和使用都是存在其合理性的。以下为两种对象使用过程中的优缺点分析。\n4.1 immutable\n对于immutable来说，优点十分明显，就是它指向的地址的内容是不可变的，也就不存在两个对象都指向一个地址的时候其中一个对象无法知道另外一个对象是否对这个地址的内容进行修改。也就是说，immutable在很大程度上保证了多线程的时候的正确性。但是缺点同样十分明显，就是每一次修改都要进行一次复制，可能会产生很大的时间开销，同时会产生大量的需要回收的垃圾。例如对于如下代码片段：\n对于第一个i来说进行了n次插入意味着复制了n次，也就是这个过程中时间复杂度是O(n^2)的，而这只是一个最简单的一层循环。\n4.2 mutable\nmutable由于其指向地址内容可变，因此每次修改的时候不需要复制，因此其开销比immutable小很多。但是其缺点就在于如果多个变量指向同一段地址的时候，其中一个对象对于地址内容的修改会影响到其他所有的变量的值，这种影响很有可能导致程序出错，例如如下代码片段：\n其中List是一个Mutable的对象，因此a，zoo.animals,b都指向了同一段内存空间，任何一个内容的修改都会造成三个值一起发生变化，因此main函数的输出如下：\n很显然这种输出在很大可能性下不是我们想要的，因此使用mutable是存在风险的。\n5.使用场景\n尽可能使用不可变的对象和不可变的引用。如果可以肯定某一段地址空间只会由一个对象指向，可以考虑使用mutable对象，但是使用的时候一定要注意不要产生多个对象修改一段空间内值的情况。\n"
  },
  {
    "head": "Amazon数据集网址",
    "paragraphs": [
      "在构建知识图谱的时候大多需要使用Amazon的数据集，在此记录Amazon数据集网址。",
      "2014版：http://snap.stanford.edu/data/amazon/productGraph/",
      "2018版：http://deepyeti.ucsd.edu/jianmo/amazon/index.html",
      "两个版本略有不同，可以按需使用"
    ],
    "sentences": [
      "在构建知识图谱的时候大多需要使用Amazon的数据集",
      "在此记录Amazon数据集网址",
      "2014版：http://snap.stanford.edu/data/amazon/productGraph/",
      "2018版：http://deepyeti.ucsd.edu/jianmo/amazon/index.html",
      "两个版本略有不同，可以按需使用"
    ],
    "codes": [],
    "date": "2021-05-07",
    "text": "在构建知识图谱的时候大多需要使用Amazon的数据集，在此记录Amazon数据集网址。\n2014版：http://snap.stanford.edu/data/amazon/productGraph/\n2018版：http://deepyeti.ucsd.edu/jianmo/amazon/index.html\n两个版本略有不同，可以按需使用\n"
  },
  {
    "head": "leetcode392.判断子序列c++",
    "paragraphs": [
      "题目：",
      "给定字符串 s 和 t ，判断 s 是否为 t 的子序列。",
      "你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。",
      "字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。",
      "这一题可以采用动态规划的方式来写，总体来看比较简单"
    ],
    "sentences": [
      "题目：给定字符串 s 和 t ",
      "判断 s 是否为 t 的子序列",
      "你可以认为 s 和 t 中仅包含英文小写字母",
      "字符串 t 可能会很长（长度 ~= 500,000）",
      "而 s 是个短字符串（长度 <=100）",
      "字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串",
      "如",
      "\"ace\"是\"abcde\"的一个子序列",
      "而\"aec\"不是）",
      "这一题可以采用动态规划的方式来写，总体来看比较简单"
    ],
    "codes": [
      "                                                 来源：力扣（LeetCode）\n",
      "class Solution {\npublic:\n   bool isSubsequence(string s, string t) {\n       int i=0,j=0;\n       while(i<s.length()&&j<t.length())\n       {\n           if(s[i]==t[j])i++;\n           j++;//注意这里没有else，不管是否匹配j都要加1；\n       }\n       if(i==s.length())return true;\n       else return false;\n   }\n};\n"
    ],
    "date": "2020-06-10",
    "text": "题目：\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n这一题可以采用动态规划的方式来写，总体来看比较简单\n"
  },
  {
    "head": "Leetcode1025除数博弈c++",
    "paragraphs": [
      "Leetcode1025除数博弈",
      "题目：",
      "爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。",
      "最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：",
      "选出任一 x，满足 0 < x < N 且 N % x == 0 。",
      "用 N - x 替换黑板上的数字 N 。",
      "如果玩家无法执行这些操作，就会输掉游戏。",
      "只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。",
      "来源：力扣（LeetCode）",
      "我们可以简单列举一下当N取较小值时的情况",
      "N=1时，爱丽丝无法操作，返回false",
      "N=2时，爱丽丝取1，鲍勃无法操作，返回true",
      "N=3时，爱丽丝取1，鲍勃取1，爱丽丝无法操作，返回false",
      "N=4时，爱丽丝取1，鲍勃取1，爱丽丝取1，鲍勃无法操作，返回true",
      "至此，我们可以大胆猜测当N取偶数时爱丽丝胜利，N取奇数时爱丽丝失败。那么是否正确呢？",
      "以下进行简单证明：",
      "当N取偶数时，爱丽丝总可以取一个奇数因子，从而返回给鲍勃一个奇数，最终会返回N=2的形式，爱丽丝获胜",
      "当N取奇数时，爱丽丝只能返回鲍勃一个偶数或无法操作，则最终会返回N=3的形式，爱丽丝失败",
      "代码展示"
    ],
    "sentences": [
      "Leetcode1025除数博弈",
      "题目：爱丽丝和鲍勃一起玩游戏，他们轮流行动",
      "爱丽丝先手开局",
      "最初，黑板上有一个数字 N ",
      "在每个玩家的回合",
      "玩家需要执行以下操作：选出任一 x",
      "满足 0 < x < N 且 N % x == 0 ",
      "用 N - x 替换黑板上的数字 N ",
      "如果玩家无法执行这些操作，就会输掉游戏",
      "只有在爱丽丝在游戏中取得胜利时才返回 True",
      "否则返回 false",
      "假设两个玩家都以最佳状态参与游戏",
      "来源：力扣（LeetCode）",
      "我们可以简单列举一下当N取较小值时的情况",
      "N=1时，爱丽丝无法操作，返回false",
      "N=2时，爱丽丝取1，鲍勃无法操作，返回true",
      "N=3时",
      "爱丽丝取1",
      "鲍勃取1",
      "爱丽丝无法操作",
      "返回false",
      "N=4时",
      "爱丽丝取1",
      "鲍勃取1",
      "爱丽丝取1",
      "鲍勃无法操作",
      "返回true",
      "至此",
      "我们可以大胆猜测当N取偶数时爱丽丝胜利",
      "N取奇数时爱丽丝失败",
      "那么是否正确呢？",
      "以下进行简单证明：当N取偶数时",
      "爱丽丝总可以取一个奇数因子",
      "从而返回给鲍勃一个奇数",
      "最终会返回N=2的形式",
      "爱丽丝获胜",
      "当N取奇数时",
      "爱丽丝只能返回鲍勃一个偶数或无法操作",
      "则最终会返回N=3的形式",
      "爱丽丝失败",
      "代码展示"
    ],
    "codes": [
      "class Solution {\npublic:\n    bool divisorGame(int N) {\n         return N%2==0;\n    }\n};\n"
    ],
    "date": "2020-06-11",
    "text": "Leetcode1025除数博弈\n题目：\n爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。\n最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：\n选出任一 x，满足 0 < x < N 且 N % x == 0 。\n用 N - x 替换黑板上的数字 N 。\n如果玩家无法执行这些操作，就会输掉游戏。\n只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。\n来源：力扣（LeetCode）\n我们可以简单列举一下当N取较小值时的情况\nN=1时，爱丽丝无法操作，返回false\nN=2时，爱丽丝取1，鲍勃无法操作，返回true\nN=3时，爱丽丝取1，鲍勃取1，爱丽丝无法操作，返回false\nN=4时，爱丽丝取1，鲍勃取1，爱丽丝取1，鲍勃无法操作，返回true\n至此，我们可以大胆猜测当N取偶数时爱丽丝胜利，N取奇数时爱丽丝失败。那么是否正确呢？\n以下进行简单证明：\n当N取偶数时，爱丽丝总可以取一个奇数因子，从而返回给鲍勃一个奇数，最终会返回N=2的形式，爱丽丝获胜\n当N取奇数时，爱丽丝只能返回鲍勃一个偶数或无法操作，则最终会返回N=3的形式，爱丽丝失败\n代码展示\n"
  },
  {
    "head": "最优贸易 题解 c++实现",
    "paragraphs": [
      "题目描述",
      "C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个 城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分 为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。",
      "C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价 格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。",
      "商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息 之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城 市的标号从 1~ n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的 过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方 式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另 一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定 这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。",
      "假设 C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路 为单向通行，双向箭头表示这条道路为双向通行。 C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个 城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分 为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。 C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价 格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息 之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城 市的标号从 1~ n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的 过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方 式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另 一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定 这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设 C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路 为单向通行，双向箭头表示这条道路为双向通行。",
      "假设 1~n 号城市的水晶球价格分别为 4，3，5，6，1。 阿龙可以选择如下一条线路：1->2->3->5，并在 2 号城市以 3 的价格买入水晶球，在 3 号城市以 5 的价格卖出水晶球，赚取的旅费数为 2。 阿龙也可以选择如下一条线路 1->4->5->4->5，并在第 1 次到达 5 号城市时以 1 的价格 买入水晶球，在第 2 次到达 4 号城市时以 6 的价格卖出水晶球，赚取的旅费数为 5。",
      "现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号 以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。",
      "输入格式",
      "第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的 数目。",
      "第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城 市的商品价格。",
      "接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。如果 z=1， 表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市 y 之间的双向道路。",
      "输出格式",
      "共 1 行，包含 1 个整数，表示最多能赚取的旅费。如果没有进行贸易， 则输出 0。",
      "样例数据",
      "input",
      "5 5",
      "4 3 5 6 1",
      "1 2 1",
      "1 4 1",
      "2 3 2",
      "3 5 1",
      "4 5 2",
      "output",
      "这一题主要思路就是找到在一条路径上的最大最小值，将其相减就是所求的收益。需要注意的是，最大值需要在最小值之后，那么很容易想到从前往后一次dijkstra求出最小值，从后往前一次dijkstra求出最大值，但是，这样是有问题的。由于对于一个顶点加入集合之后，dijkstra就不再更新该节点，我们不妨看一下下面这种情况，其中加粗的为该点的价格。",
      "其测试样例为",
      "正确的输出应为8，但是正反两次dijkstra结果是6，这是由于1、2、3结点之间的更新出现一定问题，导致后续出现一定问题。那么这题可以采用正反两次SPFA算法就可以解决啦。以下是正确代码（在洛谷AC，且测试过一定的自己使用的样例）"
    ],
    "sentences": [
      "题目描述",
      "C 国有 n 个大城市和 m 条道路",
      "每条道路连接这 n 个城市中的某两个城市",
      "任意两个 城市之间最多只有一条道路直接相连",
      "这 m 条道路中有一部分为单向通行的道路",
      "一部分 为双向通行的道路",
      "双向通行的道路在统计条数时也计为 1 条",
      "C 国幅员辽阔",
      "各地的资源分布情况各不相同",
      "这就导致了同一种商品在不同城市的价 格不一定相同",
      "但是，同一种商品在同一个城市的买入价和卖出价始终是相同的",
      "商人阿龙来到 C 国旅游",
      "当他得知同一种商品在不同城市的价格可能会不同这一信息 之后",
      "便决定在旅游的同时",
      "利用商品在不同城市中的差价赚回一点旅费",
      "设 C 国 n 个城 市的标号从 1~ n",
      "阿龙决定从 1 号城市出发",
      "并最终在 n 号城市结束自己的旅行",
      "在旅游的 过程中",
      "任何城市可以重复经过多次",
      "但不要求经过所有 n 个城市",
      "阿龙通过这样的贸易方 式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球",
      "并在之后经过的另 一个城市卖出这个水晶球",
      "用赚取的差价当做旅费",
      "由于阿龙主要是来 C 国旅游",
      "他决定 这个贸易只进行最多一次",
      "当然",
      "在赚不到差价的情况下他就无需进行贸易",
      "假设 C 国有 5 个大城市",
      "城市的编号和道路连接情况如下图",
      "单向箭头表示这条道路 为单向通行",
      "双向箭头表示这条道路为双向通行",
      " C 国有 n 个大城市和 m 条道路",
      "每条道路连接这 n 个城市中的某两个城市",
      "任意两个 城市之间最多只有一条道路直接相连",
      "这 m 条道路中有一部分为单向通行的道路",
      "一部分 为双向通行的道路",
      "双向通行的道路在统计条数时也计为 1 条",
      " C 国幅员辽阔",
      "各地的资源分布情况各不相同",
      "这就导致了同一种商品在不同城市的价 格不一定相同",
      "但是，同一种商品在同一个城市的买入价和卖出价始终是相同的",
      " 商人阿龙来到 C 国旅游",
      "当他得知同一种商品在不同城市的价格可能会不同这一信息 之后",
      "便决定在旅游的同时",
      "利用商品在不同城市中的差价赚回一点旅费",
      "设 C 国 n 个城 市的标号从 1~ n",
      "阿龙决定从 1 号城市出发",
      "并最终在 n 号城市结束自己的旅行",
      "在旅游的 过程中",
      "任何城市可以重复经过多次",
      "但不要求经过所有 n 个城市",
      "阿龙通过这样的贸易方 式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球",
      "并在之后经过的另 一个城市卖出这个水晶球",
      "用赚取的差价当做旅费",
      "由于阿龙主要是来 C 国旅游",
      "他决定 这个贸易只进行最多一次",
      "当然",
      "在赚不到差价的情况下他就无需进行贸易",
      " 假设 C 国有 5 个大城市",
      "城市的编号和道路连接情况如下图",
      "单向箭头表示这条道路 为单向通行",
      "双向箭头表示这条道路为双向通行",
      "假设 1~n 号城市的水晶球价格分别为 4，3，5，6，1",
      " 阿龙可以选择如下一条线路：1->2->3->5",
      "并在 2 号城市以 3 的价格买入水晶球",
      "在 3 号城市以 5 的价格卖出水晶球",
      "赚取的旅费数为 2",
      " 阿龙也可以选择如下一条线路 1->4->5->4->5",
      "并在第 1 次到达 5 号城市时以 1 的价格 买入水晶球",
      "在第 2 次到达 4 号城市时以 6 的价格卖出水晶球",
      "赚取的旅费数为 5",
      "现在给出 n 个城市的水晶球价格",
      "m 条道路的信息（每条道路所连接的两个城市的编号 以及该条道路的通行情况）",
      "请你告诉阿龙，他最多能赚取多少旅费",
      "输入格式",
      "第一行包含 2 个正整数 n 和 m",
      "中间用一个空格隔开",
      "分别表示城市的数目和道路的 数目",
      "第二行 n 个正整数",
      "每两个整数之间用一个空格隔开",
      "按标号顺序分别表示这 n 个城 市的商品价格",
      "接下来 m 行",
      "每行有 3 个正整数",
      "x",
      "y",
      "z",
      "每两个整数之间用一个空格隔开",
      "如果 z=1",
      " 表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2",
      "表示这条道路为城市 x 和城市 y 之间的双向道路",
      "输出格式",
      "共 1 行，包含 1 个整数，表示最多能赚取的旅费",
      "如果没有进行贸易， 则输出 0",
      "样例数据",
      "input",
      "5 5",
      "4 3 5 6 1",
      "1 2 1",
      "1 4 1",
      "2 3 2",
      "3 5 1",
      "4 5 2",
      "output",
      "这一题主要思路就是找到在一条路径上的最大最小值",
      "将其相减就是所求的收益",
      "需要注意的是",
      "最大值需要在最小值之后",
      "那么很容易想到从前往后一次dijkstra求出最小值",
      "从后往前一次dijkstra求出最大值",
      "但是",
      "这样是有问题的",
      "由于对于一个顶点加入集合之后",
      "dijkstra就不再更新该节点",
      "我们不妨看一下下面这种情况",
      "其中加粗的为该点的价格",
      "其测试样例为",
      "正确的输出应为8",
      "但是正反两次dijkstra结果是6",
      "这是由于1、2、3结点之间的更新出现一定问题",
      "导致后续出现一定问题",
      "那么这题可以采用正反两次SPFA算法就可以解决啦",
      "以下是正确代码（在洛谷AC，且测试过一定的自己使用的样例）"
    ],
    "codes": [
      "9 10 \n4 3 2 1 5 7 8 9 6 \n1 2 1 \n2 3 1 \n3 4 1 \n4 2 1 \n2 5 1 \n5 6 1 \n6 7 1 \n7 8 1 \n8 6 1 \n6 9 1 \n",
      "#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define INF 1000000\n#define N 1000005\nusing namespace std;\nint dis1[N]={0},dis2[N]={0},vis[N];\nvector<int> edge1[N],edge2[N];//分别是正向和反向建图\nint n,m;//分别表示城市数和道路数\nint price[N]={0};\nvoid read()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>price[i];\n    }\n    int u,v,k;\n    for(int i=1;i<=m;i++)\n    {\n        cin>>u>>v>>k;\n        edge1[u].push_back(v);\n        edge2[v].push_back(u);\n        if(k>1)\n        {\n            edge1[v].push_back(u);\n            edge2[u].push_back(v);\n        } \n    }\n}\nvoid SPFA1()\n{\n    memset(dis1,INF,sizeof(dis1));\n    memset(vis,0,sizeof(vis));\n    queue<int>Q;\n    Q.push(1);\n    vis[1]=1;\n    while(!Q.empty())\n    {\n        int temp=Q.front();\n        Q.pop();\n        dis1[temp]=min(dis1[temp],price[temp]);\n        for(int i=0;i<edge1[temp].size();i++)\n        {\n            int v=edge1[temp][i];\n            if(dis1[temp]<dis1[v])\n            {\n              dis1[v]=dis1[temp];\n               if (!vis[v]) \n               {\n                   vis[v]=1;\n                   Q.push(v);\n               }\n            }   \n        }\n        vis[temp]=0; //关键步骤    \n    }\n}\nvoid SPFA2()\n{\n    memset(dis2,0,sizeof(dis2));\n    memset(vis,0,sizeof(vis));\n    queue<int>Q;\n    Q.push(n);\n    vis[n]=1;\n    while(!Q.empty())\n    {\n        int temp=Q.front();\n        Q.pop();\n        dis2[temp]=max(dis2[temp],price[temp]);\n        for(int i=0;i<edge2[temp].size();i++)\n        {\n            int v=edge2[temp][i];\n            if(dis2[temp]>dis2[v])\n            {\n                dis2[v]=dis2[temp];\n                if (!vis[v]) \n                {\n                    vis[v]=1;\n                    Q.push(v);\n                }\n            } \n        }\n        vis[temp]=0;\n    }\n}\nint main()\n{\n    int res=0;\n    read();\n    SPFA1();\n    SPFA2();\n    for(int i=1;i<=n;i++)\n    {\n        res=max(res,dis2[i]-dis1[i]);\n    }\n    cout<<res<<endl; \n    system(\"pause\");\n    return 0;\n}\n\n",
      "\n"
    ],
    "date": "2020-11-22",
    "text": "题目描述\nC 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个 城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分 为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。\nC 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价 格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。\n商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息 之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城 市的标号从 1~ n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的 过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方 式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另 一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定 这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。\n假设 C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路 为单向通行，双向箭头表示这条道路为双向通行。 C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个 城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分 为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。 C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价 格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息 之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城 市的标号从 1~ n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的 过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方 式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另 一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定 这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设 C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路 为单向通行，双向箭头表示这条道路为双向通行。\n假设 1~n 号城市的水晶球价格分别为 4，3，5，6，1。 阿龙可以选择如下一条线路：1->2->3->5，并在 2 号城市以 3 的价格买入水晶球，在 3 号城市以 5 的价格卖出水晶球，赚取的旅费数为 2。 阿龙也可以选择如下一条线路 1->4->5->4->5，并在第 1 次到达 5 号城市时以 1 的价格 买入水晶球，在第 2 次到达 4 号城市时以 6 的价格卖出水晶球，赚取的旅费数为 5。\n现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号 以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。\n输入格式\n第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的 数目。\n第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城 市的商品价格。\n接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。如果 z=1， 表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市 y 之间的双向道路。\n输出格式\n共 1 行，包含 1 个整数，表示最多能赚取的旅费。如果没有进行贸易， 则输出 0。\n样例数据\ninput\n5 5\n4 3 5 6 1\n1 2 1\n1 4 1\n2 3 2\n3 5 1\n4 5 2\noutput\n这一题主要思路就是找到在一条路径上的最大最小值，将其相减就是所求的收益。需要注意的是，最大值需要在最小值之后，那么很容易想到从前往后一次dijkstra求出最小值，从后往前一次dijkstra求出最大值，但是，这样是有问题的。由于对于一个顶点加入集合之后，dijkstra就不再更新该节点，我们不妨看一下下面这种情况，其中加粗的为该点的价格。\n其测试样例为\n正确的输出应为8，但是正反两次dijkstra结果是6，这是由于1、2、3结点之间的更新出现一定问题，导致后续出现一定问题。那么这题可以采用正反两次SPFA算法就可以解决啦。以下是正确代码（在洛谷AC，且测试过一定的自己使用的样例）\n"
  },
  {
    "head": "leetcode1139. 最大的以 1 为边界的正方形c++",
    "paragraphs": [
      "leetcode1139. 最大的以 1 为边界的正方形c++",
      "给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。",
      "提示：",
      "1 <= grid.length <= 100",
      "1 <= grid[0].length <= 100",
      "grid[i][j] 为 0 或 1",
      "这道题的解决可以从一个点开始向它的周围进行遍历，寻找符合题意的最大正方形。在代码实现中是通过定义一个点是正方形的右下点，求出可能的最大正方形之后在可能值中求得最优解。"
    ],
    "sentences": [
      "leetcode1139. 最大的以 1 为边界的正方形c++",
      "给你一个由若干 0 和 1 组成的二维网格 grid",
      "请你找出边界全部由 1 组成的最大 正方形 子网格",
      "并返回该子网格中的元素数量",
      "如果不存在，则返回 0",
      "提示：1 <= grid.length <= 100",
      "1 <= grid[0].length <= 100",
      "grid[i][j] 为 0 或 1",
      "这道题的解决可以从一个点开始向它的周围进行遍历",
      "寻找符合题意的最大正方形",
      "在代码实现中是通过定义一个点是正方形的右下点",
      "求出可能的最大正方形之后在可能值中求得最优解"
    ],
    "codes": [
      "示例 1：\n输入：grid = [[1,1,1],[1,0,1],[1,1,1]]\n输出：9\n示例 2：\n输入：grid = [[1,1,0,0]]\n输出：1\n",
      "来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/largest-1-bordered-square\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n",
      "class Solution {\npublic:\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        int length=grid.size(),width=grid[0].size();\n        int left[length][width];//某点左边连续1的个数\n        int up[length][width];//某点上方连续1的个数\n        for(int i=0;i<length;i++)\n        {\n            for(int j=0;j<width;j++)\n            {\n                if(j&&grid[i][j-1])left[i][j]=left[i][j-1]+grid[i][j];\n                else left[i][j]=grid[i][j];\n                if (i && grid[i-1][j]) up[i][j] = up[i-1][j] + grid[i][j];\n                else up[i][j] = grid[i][j];\n            }\n        }\n        int res=0;\n        for(int i=0;i<length;i++)\n        {\n            for(int j=0;j<width;j++)\n            {\n                if(grid[i][j])\n                {\n                    int len=min(left[i][j],up[i][j]);//可能的最大值\n                    while(res<len)\n                    {\n                        if(up[i][j-len+1]>=len&&left[i-len+1][j]>=len)//判断可能正方形的左下点和右上点是否符合提议\n                        {\n                            res=len;\n                            break;\n                        }\n                        len--;//缩小可能正方形的大小\n                    } \n                }\n            }\n        }\n        return res*res;\n\n    }\n};\n"
    ],
    "date": "2020-06-24",
    "text": "leetcode1139. 最大的以 1 为边界的正方形c++\n给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。\n提示：\n1 <= grid.length <= 100\n1 <= grid[0].length <= 100\ngrid[i][j] 为 0 或 1\n这道题的解决可以从一个点开始向它的周围进行遍历，寻找符合题意的最大正方形。在代码实现中是通过定义一个点是正方形的右下点，求出可能的最大正方形之后在可能值中求得最优解。\n"
  },
  {
    "head": "【lab2】关于Equals和HashCode重写",
    "paragraphs": [
      "为什么要重写Equals和HashCode？",
      "每当我们定义一个immutable类的时候，就应该考虑重写其Equals和HashCode",
      "一个immutable类，创造两个对象A,B; A和B有着一模一样的内容，但是由于内存地址的不同，我们用\"==“或者是缺省的equals(内部实现还是”= =\")，是不能够得出他们相等的。",
      "如果要想他们在外界看来是一样的，那就要重写类中的equals函数，而HashCode也应该随之重写。",
      "因为：如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同",
      "ref",
      "对于mutable的类，我们不必管Equals和HashCode，直接使用默认的即可",
      "如何重写Equals和HashCode？",
      "例子：",
      "[reference :]",
      "重写hashcode方法 | Tanthen",
      "HashMap什么时候重写hashcode和equals方法，为什么需要重写_Keith003的博客-CSDN博客",
      "为什么使用HashMap需要重写hashcode和equals方法？_hxt的博客-CSDN博客_为什么要重写hashcode和equals方法",
      "Java中hashCode的作用"
    ],
    "sentences": [
      "为什么要重写Equals和HashCode？",
      "每当我们定义一个immutable类的时候",
      "就应该考虑重写其Equals和HashCode",
      "一个immutable类",
      "创造两个对象A,B; A和B有着一模一样的内容",
      "但是由于内存地址的不同",
      "我们用\"==“或者是缺省的equals(内部实现还是”= =\")",
      "是不能够得出他们相等的",
      "如果要想他们在外界看来是一样的",
      "那就要重写类中的equals函数",
      "而HashCode也应该随之重写",
      "因为：如果两个对象相同",
      "就是适用于equals(java.lang.Object) 方法",
      "那么这两个对象的hashCode一定要相同",
      "ref",
      "对于mutable的类",
      "我们不必管Equals和HashCode",
      "直接使用默认的即可",
      "如何重写Equals和HashCode？",
      "例子：[reference :]",
      "重写hashcode方法 | Tanthen",
      "HashMap什么时候重写hashcode和equals方法",
      "为什么需要重写_Keith003的博客-CSDN博客",
      "为什么使用HashMap需要重写hashcode和equals方法？_hxt的博客-CSDN博客_为什么要重写hashcode和equals方法",
      "Java中hashCode的作用"
    ],
    "codes": [
      "    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || this.getClass() != obj.getClass()) return false;\n        Person person = (Person) obj;\n        return name.equals(person.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n"
    ],
    "date": "2021-06-09",
    "text": "为什么要重写Equals和HashCode？\n每当我们定义一个immutable类的时候，就应该考虑重写其Equals和HashCode\n一个immutable类，创造两个对象A,B; A和B有着一模一样的内容，但是由于内存地址的不同，我们用\"==“或者是缺省的equals(内部实现还是”= =\")，是不能够得出他们相等的。\n如果要想他们在外界看来是一样的，那就要重写类中的equals函数，而HashCode也应该随之重写。\n因为：如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同\nref\n对于mutable的类，我们不必管Equals和HashCode，直接使用默认的即可\n如何重写Equals和HashCode？\n例子：\n[reference :]\n重写hashcode方法 | Tanthen\nHashMap什么时候重写hashcode和equals方法，为什么需要重写_Keith003的博客-CSDN博客\n为什么使用HashMap需要重写hashcode和equals方法？_hxt的博客-CSDN博客_为什么要重写hashcode和equals方法\nJava中hashCode的作用\n"
  },
  {
    "head": "【lab2】Safety from rep exposure",
    "paragraphs": [
      "简单来说，一个主类有属性和方法两种成分，这里的主类是指用户直接使用的类，需要做到以下两点",
      "1、将类中所有的属性（变量）定义为private类型，",
      "目的是不让用户得到你的内部属性",
      "2、方法或者返回immutable data，或者返回本应该返回的mutable data的副本，或者返回一个不可修改的mutable data",
      "1、尽量使用immutable数据类型，比如能使用String就不使用StringBuilder，能使用Instance就不使用Data",
      "2、为了创造mutable data的副本，可以进行defensive copy。可以在主类方法中构造然后返回，但是推荐方法是使用mutable数据类型的clone，假如该mutable数据类型是自己写的类，那么推荐在类中写一个clone的方法",
      "3、使用Collections.unmodifiableSet等方法",
      "这里需要注意的是第二个方面，如果想要返回一个Collection类的数据，有人说我创建了一个Collection类，向里面添加数据后，不管数据怎样，都算defensive copy了，但是如果数据是mutable类型，那么就不算defensive copy，因为Collection类储存的是地址，尽管new了一个hashSet或者hashMap，但是没有真正的对mutable数据进行defensive copy。",
      "————————————————",
      "版权声明：本文为CSDN博主「djd566」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。",
      "原文链接：https://blog.csdn.net/djd566/article/details/79749757"
    ],
    "sentences": [
      "简单来说",
      "一个主类有属性和方法两种成分",
      "这里的主类是指用户直接使用的类",
      "需要做到以下两点",
      "1、将类中所有的属性（变量）定义为private类型",
      "目的是不让用户得到你的内部属性",
      "2、方法或者返回immutable data",
      "或者返回本应该返回的mutable data的副本",
      "或者返回一个不可修改的mutable data",
      "1、尽量使用immutable数据类型",
      "比如能使用String就不使用StringBuilder",
      "能使用Instance就不使用Data",
      "2、为了创造mutable data的副本",
      "可以进行defensive copy",
      "可以在主类方法中构造然后返回",
      "但是推荐方法是使用mutable数据类型的clone",
      "假如该mutable数据类型是自己写的类",
      "那么推荐在类中写一个clone的方法",
      "3、使用Collections.unmodifiableSet等方法",
      "这里需要注意的是第二个方面",
      "如果想要返回一个Collection类的数据",
      "有人说我创建了一个Collection类",
      "向里面添加数据后",
      "不管数据怎样",
      "都算defensive copy了",
      "但是如果数据是mutable类型",
      "那么就不算defensive copy",
      "因为Collection类储存的是地址",
      "尽管new了一个hashSet或者hashMap",
      "但是没有真正的对mutable数据进行defensive copy",
      "————————————————",
      "版权声明：本文为CSDN博主「djd566」的原创文章",
      "遵循CC 4.0 BY-SA版权协议",
      "转载请附上原文出处链接及本声明",
      "原文链接：https://blog.csdn.net/djd566/article/details/79749757"
    ],
    "codes": [],
    "date": "2021-06-09",
    "text": "简单来说，一个主类有属性和方法两种成分，这里的主类是指用户直接使用的类，需要做到以下两点\n1、将类中所有的属性（变量）定义为private类型，\n目的是不让用户得到你的内部属性\n2、方法或者返回immutable data，或者返回本应该返回的mutable data的副本，或者返回一个不可修改的mutable data\n1、尽量使用immutable数据类型，比如能使用String就不使用StringBuilder，能使用Instance就不使用Data\n2、为了创造mutable data的副本，可以进行defensive copy。可以在主类方法中构造然后返回，但是推荐方法是使用mutable数据类型的clone，假如该mutable数据类型是自己写的类，那么推荐在类中写一个clone的方法\n3、使用Collections.unmodifiableSet等方法\n这里需要注意的是第二个方面，如果想要返回一个Collection类的数据，有人说我创建了一个Collection类，向里面添加数据后，不管数据怎样，都算defensive copy了，但是如果数据是mutable类型，那么就不算defensive copy，因为Collection类储存的是地址，尽管new了一个hashSet或者hashMap，但是没有真正的对mutable数据进行defensive copy。\n————————————————\n版权声明：本文为CSDN博主「djd566」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/djd566/article/details/79749757\n"
  },
  {
    "head": "【lab2】defensive copy",
    "paragraphs": [
      "How to Defensive Copy",
      "方法返回一个mutable的数据类型",
      "without defensive copy:",
      "这种observer则会造成类中参数被改变的风险。",
      "with defensive copy:",
      "对于抽象类型",
      "lab2中给出的 L 是一个不知道类型的抽象数据类型，但是spec中有明确讲到必须是immutable的",
      "@param",
      "type of vertex labels in",
      "this",
      "graph",
      "must be immutable",
      "所以我们在接口设计的时候不需要刻意实现防御式拷贝。"
    ],
    "sentences": [
      "How to Defensive Copy",
      "方法返回一个mutable的数据类型",
      "without defensive copy:这种observer则会造成类中参数被改变的风险",
      "with defensive copy:对于抽象类型",
      "lab2中给出的 L 是一个不知道类型的抽象数据类型",
      "但是spec中有明确讲到必须是immutable的",
      "@param",
      "type of vertex labels in",
      "this",
      "graph",
      "must be immutable",
      "所以我们在接口设计的时候不需要刻意实现防御式拷贝"
    ],
    "codes": [
      "public Name getName(){\n       return name;\n}\n",
      "public Name getName(){\n    return new Name(name.toString());\n}\n",
      "* @param <L> type of vertex labels in this graph, must be immutable\n"
    ],
    "date": "2021-06-09",
    "text": "How to Defensive Copy\n方法返回一个mutable的数据类型\nwithout defensive copy:\n这种observer则会造成类中参数被改变的风险。\nwith defensive copy:\n对于抽象类型\nlab2中给出的 L 是一个不知道类型的抽象数据类型，但是spec中有明确讲到必须是immutable的\n@param\ntype of vertex labels in\nthis\ngraph\nmust be immutable\n所以我们在接口设计的时候不需要刻意实现防御式拷贝。\n"
  },
  {
    "head": "《PyTorch深度学习实践》学习笔记 【1】",
    "paragraphs": [
      "《PyTorch深度学习实践》学习笔记 【1】",
      "学习资源：",
      "《PyTorch深度学习实践》完结合集",
      "一. 绪论",
      "1. 人工智能的发展历程",
      "Rule—Based： 基于规则（如经典的积分计算）",
      "Classic machine learning : 手动提取特征，使用特征",
      "representation learning ： 自动提取特征",
      "维度的诅咒",
      "： (参数空间搜索组合爆炸)",
      "解决方法",
      "：使用更少的更有代表性的参数。",
      "DeepLearning：",
      "将特征提取和特征函数训练两个过程结合起来，也称之为",
      "End2End",
      "（端到端）",
      "2. 经典的机器学习方法（见图）",
      "3. SVM的兴衰",
      "SVM的局限性：",
      "手工提取特征的限制；面对大数据处理效果不佳；更多无特征的数据出现；",
      "DeepLearning出现后，效果比SVM更好",
      "4. 神经网络的发展历史",
      "人工神经网络（Artificial Neural Networks，简写为ANNs）也简称为神经网络（NNs）或称作连接模型（Connection Model），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。",
      "神经网络是通过对人脑的基本单元——神经元的建模和联接，探索模拟人脑神经系统功能的模型，并研制一种具有学习、联想、记忆和模式识别等智能信息处理功能的人工系统。神经网络的一个重要特性是它能够从环境中学习，并把学习的结果分布存储于网络的突触连接中。神经网络的学习是一个过程，在其所处环境的激励下，相继给网络输入一些样本模式，并按照一定的规则（学习算法）调整网络各层的权值矩阵，待网络各层权值都收敛到一定值，学习过程结束。然后我们就可以用生成的神经网络来对真实数据做分类。",
      "神经网络的发展，是自底向上的，模块化的，随着基本块能力的增强，能解决的问题也越来越多。",
      "深度学习的发展动力：模块的搭建更加方便， 数据的获取更容易，算力一直在发展。",
      "6. 常用工具",
      "7. Pytorch的安装",
      "Pytorch cpu版本安装教程（附加GPU版本安装教程）"
    ],
    "sentences": [
      "《PyTorch深度学习实践》学习笔记 【1】",
      "学习资源：《PyTorch深度学习实践》完结合集",
      "一. 绪论",
      "1. 人工智能的发展历程",
      "Rule—Based： 基于规则（如经典的积分计算）",
      "Classic machine learning : 手动提取特征",
      "使用特征",
      "representation learning ： 自动提取特征",
      "维度的诅咒",
      "： (参数空间搜索组合爆炸)",
      "解决方法",
      "：使用更少的更有代表性的参数",
      "DeepLearning：将特征提取和特征函数训练两个过程结合起来",
      "也称之为",
      "End2End",
      "（端到端）",
      "2. 经典的机器学习方法（见图）",
      "3. SVM的兴衰",
      "SVM的局限性：手工提取特征的限制；面对大数据处理效果不佳；更多无特征的数据出现；DeepLearning出现后",
      "效果比SVM更好",
      "4. 神经网络的发展历史",
      "人工神经网络（Artificial Neural Networks",
      "简写为ANNs）也简称为神经网络（NNs）或称作连接模型（Connection Model）",
      "它是一种模仿动物神经网络行为特征",
      "进行分布式并行信息处理的算法数学模型",
      "这种网络依靠系统的复杂程度",
      "通过调整内部大量节点之间相互连接的关系",
      "从而达到处理信息的目的",
      "神经网络是通过对人脑的基本单元——神经元的建模和联接",
      "探索模拟人脑神经系统功能的模型",
      "并研制一种具有学习、联想、记忆和模式识别等智能信息处理功能的人工系统",
      "神经网络的一个重要特性是它能够从环境中学习",
      "并把学习的结果分布存储于网络的突触连接中",
      "神经网络的学习是一个过程",
      "在其所处环境的激励下",
      "相继给网络输入一些样本模式",
      "并按照一定的规则（学习算法）调整网络各层的权值矩阵",
      "待网络各层权值都收敛到一定值",
      "学习过程结束",
      "然后我们就可以用生成的神经网络来对真实数据做分类",
      "神经网络的发展",
      "是自底向上的",
      "模块化的",
      "随着基本块能力的增强",
      "能解决的问题也越来越多",
      "深度学习的发展动力：模块的搭建更加方便",
      " 数据的获取更容易",
      "算力一直在发展",
      "6. 常用工具",
      "7. Pytorch的安装",
      "Pytorch cpu版本安装教程（附加GPU版本安装教程）"
    ],
    "codes": [],
    "date": "2021-08-14",
    "text": "《PyTorch深度学习实践》学习笔记 【1】\n学习资源：\n《PyTorch深度学习实践》完结合集\n一. 绪论\n1. 人工智能的发展历程\nRule—Based： 基于规则（如经典的积分计算）\nClassic machine learning : 手动提取特征，使用特征\nrepresentation learning ： 自动提取特征\n维度的诅咒\n： (参数空间搜索组合爆炸)\n解决方法\n：使用更少的更有代表性的参数。\nDeepLearning：\n将特征提取和特征函数训练两个过程结合起来，也称之为\nEnd2End\n（端到端）\n2. 经典的机器学习方法（见图）\n3. SVM的兴衰\nSVM的局限性：\n手工提取特征的限制；面对大数据处理效果不佳；更多无特征的数据出现；\nDeepLearning出现后，效果比SVM更好\n4. 神经网络的发展历史\n人工神经网络（Artificial Neural Networks，简写为ANNs）也简称为神经网络（NNs）或称作连接模型（Connection Model），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。\n神经网络是通过对人脑的基本单元——神经元的建模和联接，探索模拟人脑神经系统功能的模型，并研制一种具有学习、联想、记忆和模式识别等智能信息处理功能的人工系统。神经网络的一个重要特性是它能够从环境中学习，并把学习的结果分布存储于网络的突触连接中。神经网络的学习是一个过程，在其所处环境的激励下，相继给网络输入一些样本模式，并按照一定的规则（学习算法）调整网络各层的权值矩阵，待网络各层权值都收敛到一定值，学习过程结束。然后我们就可以用生成的神经网络来对真实数据做分类。\n神经网络的发展，是自底向上的，模块化的，随着基本块能力的增强，能解决的问题也越来越多。\n深度学习的发展动力：模块的搭建更加方便， 数据的获取更容易，算力一直在发展。\n6. 常用工具\n7. Pytorch的安装\nPytorch cpu版本安装教程（附加GPU版本安装教程）\n"
  },
  {
    "head": "【总结】ADT",
    "paragraphs": [
      "ADT 总结",
      "1. ADT的内容",
      "属性（名词）",
      "rep",
      "内部数据结构",
      "不可见",
      "方法（动词）",
      "Spec规约",
      "impl实现",
      "方法，功能",
      "Spec可见",
      "impl不可见",
      "对外部只有接口，封装后用户不关心内部",
      "1.1 ADT的内部方法可以大致分为以下四类",
      "creator构造器",
      "初始化，新建一个ADT对象",
      "producer生产器",
      "比如 String.concat() 能够返回一个新的对象, 不改变内部数据",
      "observer观察器",
      "Eg: .size() 看内部东西，不改变内部数据",
      "mutator变值器",
      "Eg. Add() 修改内部数据",
      "大部分返回void / bool",
      "mutable",
      "类型才有！",
      "1.2 表示独立性",
      "内部变化后，外部不因此受影响",
      "为什么内部会变化(impl)？（优化性能，多种实现）",
      "内部变化一定要遵循spec! (测试用例就是根据spec写的）",
      "对于客户端，只能见到spec，无法看见rep和impl",
      "比如：List 可以有两种实现方式：",
      "但是从外部看来，调用方法并没有差异（比如.Add() 、 .remove() 方法是一样的）",
      "内部rep应该是private而不是public",
      "用户端使用的API 不应该因为内部rep实现的改变而瘫痪",
      "1.3 表示泄漏/ rep exposure：",
      "个人理解：client获取到了你内部变量/获取到了你的内部实现方法（本来不应该看到的，给人看到了！）",
      "如何避免表示泄漏：",
      "全部属性private",
      "对于mutable类型",
      "Collection.unmodifiable.wraped) （解决拷贝空间问题）",
      "防御式拷贝（返回一个拷贝后的新的对象）",
      "尽可能用immutable数据类型",
      "1.4 如何测试一个ADT的方法（测试用例）",
      "adt的四种方法、",
      "c/p/m 用observer查看属性",
      "O 先用c/p 造出，再调用o",
      "代码覆盖率无须100%",
      "2. ADT的不变性",
      "“始终保持为真的一组条件”",
      "2.1 抽象空间A ,实际空间R",
      "抽象空间A：用户看到的值;(Abstract)",
      "实际空间R：内部维系的值(Realization)",
      "A中的值，一定能够在R中至少找到一个值与之对应(满射）",
      "（但是不是单射不一定）",
      "2.2 AF RI 概念",
      "AF（abstract function）",
      "抽象函数",
      "（就是A --R之间的函数）",
      "抽象函数是表示从表示空间到抽象空间映射的函数比如：我存了一个graph图来表示人际关系",
      "AF(graph)=现实中的人际关系图",
      "RI（rep invariant）",
      "表示不变量",
      "表示不变量将表示变量值映射成一个布尔值。",
      "简单来说，就是一个条件，判断内部元素是否合法。",
      "比如：我要求图graph不为空，那么RI中就是“图不为空”这个条件。",
      "Checkrep():",
      "满足条件，合法； 不满足，非法！",
      "使得属性都满足RI为true",
      "每个方法返回之前调用",
      "用Assert +表达式",
      "False: throw AssertErro(直接退出！违反了RI，程序没有必要继续错误地执行）",
      "调用时机：",
      "C/P/M 最后一行返回之前。",
      "O 按道理来说不会改变RI，但是防止粗心，也需要在最后写一个。",
      "每次都调用，增加复杂度？",
      "开关！",
      "-ea 开发的时候，打开assert",
      "-da 交付的时候， 关闭assert",
      "[参考：AF RI 的概念](",
      "表示不变量（Representation Invariant）与抽象函数（Abstract Function） - siren27 - 博客园 (cnblogs.com)",
      "unmodifiableList 返回一个只能看不能改的方法",
      "3.ADT的设计流程",
      "设计一组方法（C/T/M/O） 以及spec",
      "TDD 测试用例 （根据spec）",
      "选择Rep（内部数据结构）/并impl",
      "设计RI （比如 边的权值不为负，点不能为空）",
      "设计AF （R—>A) （比如 边对应 人际关系）",
      "RI/AF 的注释",
      "怎么避免表示泄漏？（mutable与immutable都要考虑）",
      "4.ADT如何保持表示不变性",
      "对于immutable，只要保证没有/M",
      "对于RI：checkRep()",
      "无表示泄漏！（见1.3）"
    ],
    "sentences": [
      "ADT 总结",
      "1. ADT的内容",
      "属性（名词）",
      "rep",
      "内部数据结构",
      "不可见",
      "方法（动词）",
      "Spec规约",
      "impl实现",
      "方法，功能",
      "Spec可见",
      "impl不可见",
      "对外部只有接口，封装后用户不关心内部",
      "1.1 ADT的内部方法可以大致分为以下四类",
      "creator构造器",
      "初始化，新建一个ADT对象",
      "producer生产器",
      "比如 String.concat() 能够返回一个新的对象, 不改变内部数据",
      "observer观察器",
      "Eg: .size() 看内部东西，不改变内部数据",
      "mutator变值器",
      "Eg. Add() 修改内部数据",
      "大部分返回void / bool",
      "mutable",
      "类型才有！",
      "1.2 表示独立性",
      "内部变化后，外部不因此受影响",
      "为什么内部会变化(impl)？（优化性能，多种实现）",
      "内部变化一定要遵循spec! (测试用例就是根据spec写的）",
      "对于客户端，只能见到spec，无法看见rep和impl",
      "比如：List 可以有两种实现方式：但是从外部看来",
      "调用方法并没有差异（比如.Add() 、 .remove() 方法是一样的）",
      "内部rep应该是private而不是public",
      "用户端使用的API 不应该因为内部rep实现的改变而瘫痪",
      "1.3 表示泄漏/ rep exposure：个人理解：client获取到了你内部变量/获取到了你的内部实现方法（本来不应该看到的",
      "给人看到了！）",
      "如何避免表示泄漏：全部属性private",
      "对于mutable类型",
      "Collection.unmodifiable.wraped) （解决拷贝空间问题）",
      "防御式拷贝（返回一个拷贝后的新的对象）",
      "尽可能用immutable数据类型",
      "1.4 如何测试一个ADT的方法（测试用例）",
      "adt的四种方法、c/p/m 用observer查看属性",
      "O 先用c/p 造出，再调用o",
      "代码覆盖率无须100%",
      "2. ADT的不变性",
      "“始终保持为真的一组条件”",
      "2.1 抽象空间A ,实际空间R",
      "抽象空间A：用户看到的值;(Abstract)",
      "实际空间R：内部维系的值(Realization)",
      "A中的值，一定能够在R中至少找到一个值与之对应(满射）",
      "（但是不是单射不一定）",
      "2.2 AF RI 概念",
      "AF（abstract function）",
      "抽象函数",
      "（就是A --R之间的函数）",
      "抽象函数是表示从表示空间到抽象空间映射的函数比如：我存了一个graph图来表示人际关系",
      "AF(graph)=现实中的人际关系图",
      "RI（rep invariant）",
      "表示不变量",
      "表示不变量将表示变量值映射成一个布尔值",
      "简单来说，就是一个条件，判断内部元素是否合法",
      "比如：我要求图graph不为空",
      "那么RI中就是“图不为空”这个条件",
      "Checkrep():满足条件，合法； 不满足，非法！",
      "使得属性都满足RI为true",
      "每个方法返回之前调用",
      "用Assert +表达式",
      "False: throw AssertErro(直接退出！违反了RI",
      "程序没有必要继续错误地执行）",
      "调用时机：C/P/M 最后一行返回之前",
      "O 按道理来说不会改变RI，但是防止粗心，也需要在最后写一个",
      "每次都调用，增加复杂度？",
      "开关！",
      "-ea 开发的时候，打开assert",
      "-da 交付的时候， 关闭assert",
      "[参考：AF RI 的概念](",
      "表示不变量（Representation Invariant）与抽象函数（Abstract Function） - siren27 - 博客园 (cnblogs.com)",
      "unmodifiableList 返回一个只能看不能改的方法",
      "3.ADT的设计流程",
      "设计一组方法（C/T/M/O） 以及spec",
      "TDD 测试用例 （根据spec）",
      "选择Rep（内部数据结构）/并impl",
      "设计RI （比如 边的权值不为负，点不能为空）",
      "设计AF （R—>A) （比如 边对应 人际关系）",
      "RI/AF 的注释",
      "怎么避免表示泄漏？（mutable与immutable都要考虑）",
      "4.ADT如何保持表示不变性",
      "对于immutable，只要保证没有/M",
      "对于RI：checkRep()",
      "无表示泄漏！（见1.3）"
    ],
    "codes": [
      "  a. new()\n\n  b. 静态工厂：graph.empty()\n",
      "List a =New arrayList\n\nList b = New linkeList\n"
    ],
    "date": "2021-06-09",
    "text": "ADT 总结\n1. ADT的内容\n属性（名词）\nrep\n内部数据结构\n不可见\n方法（动词）\nSpec规约\nimpl实现\n方法，功能\nSpec可见\nimpl不可见\n对外部只有接口，封装后用户不关心内部\n1.1 ADT的内部方法可以大致分为以下四类\ncreator构造器\n初始化，新建一个ADT对象\nproducer生产器\n比如 String.concat() 能够返回一个新的对象, 不改变内部数据\nobserver观察器\nEg: .size() 看内部东西，不改变内部数据\nmutator变值器\nEg. Add() 修改内部数据\n大部分返回void / bool\nmutable\n类型才有！\n1.2 表示独立性\n内部变化后，外部不因此受影响\n为什么内部会变化(impl)？（优化性能，多种实现）\n内部变化一定要遵循spec! (测试用例就是根据spec写的）\n对于客户端，只能见到spec，无法看见rep和impl\n比如：List 可以有两种实现方式：\n但是从外部看来，调用方法并没有差异（比如.Add() 、 .remove() 方法是一样的）\n内部rep应该是private而不是public\n用户端使用的API 不应该因为内部rep实现的改变而瘫痪\n1.3 表示泄漏/ rep exposure：\n个人理解：client获取到了你内部变量/获取到了你的内部实现方法（本来不应该看到的，给人看到了！）\n如何避免表示泄漏：\n全部属性private\n对于mutable类型\nCollection.unmodifiable.wraped) （解决拷贝空间问题）\n防御式拷贝（返回一个拷贝后的新的对象）\n尽可能用immutable数据类型\n1.4 如何测试一个ADT的方法（测试用例）\nadt的四种方法、\nc/p/m 用observer查看属性\nO 先用c/p 造出，再调用o\n代码覆盖率无须100%\n2. ADT的不变性\n“始终保持为真的一组条件”\n2.1 抽象空间A ,实际空间R\n抽象空间A：用户看到的值;(Abstract)\n实际空间R：内部维系的值(Realization)\nA中的值，一定能够在R中至少找到一个值与之对应(满射）\n（但是不是单射不一定）\n2.2 AF RI 概念\nAF（abstract function）\n抽象函数\n（就是A --R之间的函数）\n抽象函数是表示从表示空间到抽象空间映射的函数比如：我存了一个graph图来表示人际关系\nAF(graph)=现实中的人际关系图\nRI（rep invariant）\n表示不变量\n表示不变量将表示变量值映射成一个布尔值。\n简单来说，就是一个条件，判断内部元素是否合法。\n比如：我要求图graph不为空，那么RI中就是“图不为空”这个条件。\nCheckrep():\n满足条件，合法； 不满足，非法！\n使得属性都满足RI为true\n每个方法返回之前调用\n用Assert +表达式\nFalse: throw AssertErro(直接退出！违反了RI，程序没有必要继续错误地执行）\n调用时机：\nC/P/M 最后一行返回之前。\nO 按道理来说不会改变RI，但是防止粗心，也需要在最后写一个。\n每次都调用，增加复杂度？\n开关！\n-ea 开发的时候，打开assert\n-da 交付的时候， 关闭assert\n[参考：AF RI 的概念](\n表示不变量（Representation Invariant）与抽象函数（Abstract Function） - siren27 - 博客园 (cnblogs.com)\nunmodifiableList 返回一个只能看不能改的方法\n3.ADT的设计流程\n设计一组方法（C/T/M/O） 以及spec\nTDD 测试用例 （根据spec）\n选择Rep（内部数据结构）/并impl\n设计RI （比如 边的权值不为负，点不能为空）\n设计AF （R—>A) （比如 边对应 人际关系）\nRI/AF 的注释\n怎么避免表示泄漏？（mutable与immutable都要考虑）\n4.ADT如何保持表示不变性\n对于immutable，只要保证没有/M\n对于RI：checkRep()\n无表示泄漏！（见1.3）\n"
  },
  {
    "head": "《PyTorch深度学习实践》学习笔记 【2】",
    "paragraphs": [
      "《PyTorch深度学习实践》学习笔记 【2】",
      "学习资源：",
      "《PyTorch深度学习实践》完结合集",
      "二、线性模型",
      "2.1 概念：",
      "2.1.1",
      "数据集和测试集",
      "数据集拿到后一般划分为两部分，训练集和测试集，然后使用训练集的数据来训练模型，用测试集上的误差作为最终模型在应对现实场景中的泛化误差。",
      "一般来说，测试集在训练的时候是不能偷看的。",
      "我们可以使用训练集的数据来训练模型，然后用测试集上的误差作为最终模型在应对现实场景中的泛化误差。有了测试集，我们想要验证模型的最终效果，只需将训练好的模型在测试集上计算误差，即可认为此误差即为泛化误差的近似，我们只需让我们训练好的模型在测试集上的误差最小即可。",
      "为了使得模型在现实生活中更有效，我们要使用的数据集要尽可能真实。",
      "2.1.2 过拟合与泛化",
      "下面拿小猫图像识别做例子，说明一下",
      "过拟合",
      "的概念；",
      "过拟合： 在训练集上匹配度很好，但是太过了，把噪声什么的也学进来了。",
      "泛化能力： 对于没见过的图像也能进行识别，这是我们所需要的。",
      "2.1.3",
      "开发集",
      "有时候无法看到测试集，我们又人为地把数据集划分一部分出来作为验证评估，称为“开发集”。",
      "2.1.4 监督学习和非监督学习",
      "有监督学习方法必须要有训练集与测试样本。在训练集中找规律，而对测试样本使用这种规律。而非监督学习没有训练集，只有一组数据，在该组数据集内寻找规律。",
      "有监督学习的方法就是识别事物，识别的结果表现在给待识别数据加上了标签。因此训练样本集必须由带标签的样本组成。而非监督学习方法只有要分析的数据集的本身，预先没有什么标签。如果发现数据集呈现某种聚集性，则可按自然的聚集性分类，但不予以某种预先分类标签对上号为目的。",
      "2.2 线性回归",
      "2.2.1 线性模型",
      "如 y= kx+b ，我们训练的结果就是k和b的值",
      "2.2.2 损失函数",
      "误差函数",
      "平均平方误差（MSE）",
      "损失函数的值越小，代表拟合的效果越好。",
      "2.3 课上实验【1】",
      "课上代码：",
      "import",
      "numpy",
      "import",
      "matplotlib",
      "pyplot",
      "plt",
      "x_data",
      "1.0",
      "2.0",
      "3.0",
      "y_data",
      "2.0",
      "4.0",
      "6.0",
      "#线性模型",
      "def",
      "forward",
      "return",
      "#损失函数",
      "def",
      "loss",
      "y_pred",
      "forward",
      "return",
      "y_pred",
      "y_pred",
      "#迭代取值，计算每个w取值下的x，y，y_pred,loss_val",
      "w_list",
      "mse_list",
      "for",
      "arange",
      "0.0",
      "4.1",
      "0.1",
      "print",
      "'w='",
      "l_sum",
      "for",
      "x_val",
      "y_val",
      "zip",
      "x_data",
      "y_data",
      "y_pred_val",
      "forward",
      "x_val",
      "loss_val",
      "loss",
      "x_val",
      "y_val",
      "l_sum",
      "loss_val",
      "print",
      "'\\t'",
      "x_val",
      "y_val",
      "y_pred_val",
      "loss_val",
      "print",
      "'MSE='",
      "l_sum",
      "w_list",
      "append",
      "mse_list",
      "append",
      "l_sum",
      "##画图",
      "plt",
      "plot",
      "w_list",
      "mse_list",
      "plt",
      "ylabel",
      "'Loss'",
      "plt",
      "xlabel",
      "'w'",
      "plt",
      "show",
      "结果：",
      "2.4 作业【1】：",
      "Matplotlib3D作图-plot_surface(), .contourf(), plt.colorbar()",
      "代码：",
      "import",
      "numpy",
      "import",
      "matplotlib",
      "pyplot",
      "plt",
      "from",
      "mpl_toolkits",
      "mplot3d",
      "import",
      "Axes3D",
      "from",
      "matplotlib",
      "import",
      "x_data",
      "1.0",
      "2.0",
      "3.0",
      "y_data",
      "2.0",
      "4.0",
      "6.0",
      "#线性模型",
      "def",
      "forward",
      "return",
      "#损失函数",
      "def",
      "loss",
      "y_pred",
      "forward",
      "return",
      "y_pred",
      "y_pred",
      "def",
      "mse",
      "l_sum",
      "for",
      "x_val",
      "y_val",
      "zip",
      "x_data",
      "y_data",
      "y_pred_val",
      "forward",
      "x_val",
      "loss_val",
      "loss",
      "x_val",
      "y_val",
      "l_sum",
      "loss_val",
      "print",
      "'\\t'",
      "x_val",
      "y_val",
      "y_pred_val",
      "loss_val",
      "print",
      "'MSE='",
      "l_sum",
      "return",
      "l_sum",
      "#迭代取值，计算每个w取值下的x，y，y_pred,loss_val",
      "mse_list",
      "##画图",
      "##定义网格化数据",
      "b_list",
      "arange",
      "0.1",
      "w_list",
      "arange",
      "0.1",
      "##生成网格化数据",
      "meshgrid",
      "b_list",
      "w_list",
      "sparse",
      "False",
      "indexing",
      "'xy'",
      "##每个点的对应高度",
      "mse",
      "fig",
      "plt",
      "figure",
      "Axes3D",
      "fig",
      "plot_surface",
      "rstride",
      "cstride",
      "cmap",
      "viridis",
      "plt",
      "show",
      "结果："
    ],
    "sentences": [
      "《PyTorch深度学习实践》学习笔记 【2】",
      "学习资源：《PyTorch深度学习实践》完结合集",
      "二、线性模型",
      "2.1 概念：2.1.1",
      "数据集和测试集",
      "数据集拿到后一般划分为两部分",
      "训练集和测试集",
      "然后使用训练集的数据来训练模型",
      "用测试集上的误差作为最终模型在应对现实场景中的泛化误差",
      "一般来说，测试集在训练的时候是不能偷看的",
      "我们可以使用训练集的数据来训练模型",
      "然后用测试集上的误差作为最终模型在应对现实场景中的泛化误差",
      "有了测试集",
      "我们想要验证模型的最终效果",
      "只需将训练好的模型在测试集上计算误差",
      "即可认为此误差即为泛化误差的近似",
      "我们只需让我们训练好的模型在测试集上的误差最小即可",
      "为了使得模型在现实生活中更有效",
      "我们要使用的数据集要尽可能真实",
      "2.1.2 过拟合与泛化",
      "下面拿小猫图像识别做例子，说明一下",
      "过拟合",
      "的概念；过拟合： 在训练集上匹配度很好",
      "但是太过了",
      "把噪声什么的也学进来了",
      "泛化能力： 对于没见过的图像也能进行识别，这是我们所需要的",
      "2.1.3",
      "开发集",
      "有时候无法看到测试集",
      "我们又人为地把数据集划分一部分出来作为验证评估",
      "称为“开发集”",
      "2.1.4 监督学习和非监督学习",
      "有监督学习方法必须要有训练集与测试样本",
      "在训练集中找规律，而对测试样本使用这种规律",
      "而非监督学习没有训练集，只有一组数据，在该组数据集内寻找规律",
      "有监督学习的方法就是识别事物",
      "识别的结果表现在给待识别数据加上了标签",
      "因此训练样本集必须由带标签的样本组成",
      "而非监督学习方法只有要分析的数据集的本身，预先没有什么标签",
      "如果发现数据集呈现某种聚集性",
      "则可按自然的聚集性分类",
      "但不予以某种预先分类标签对上号为目的",
      "2.2 线性回归",
      "2.2.1 线性模型",
      "如 y= kx+b ，我们训练的结果就是k和b的值",
      "2.2.2 损失函数",
      "误差函数",
      "平均平方误差（MSE）",
      "损失函数的值越小，代表拟合的效果越好",
      "2.3 课上实验【1】",
      "课上代码：import",
      "numpy",
      "import",
      "matplotlib",
      "pyplot",
      "plt",
      "x_data",
      "1.0",
      "2.0",
      "3.0",
      "y_data",
      "2.0",
      "4.0",
      "6.0",
      "#线性模型",
      "def",
      "forward",
      "return",
      "#损失函数",
      "def",
      "loss",
      "y_pred",
      "forward",
      "return",
      "y_pred",
      "y_pred",
      "#迭代取值",
      "计算每个w取值下的x",
      "y",
      "y_pred,loss_val",
      "w_list",
      "mse_list",
      "for",
      "arange",
      "0.0",
      "4.1",
      "0.1",
      "print",
      "'w='",
      "l_sum",
      "for",
      "x_val",
      "y_val",
      "zip",
      "x_data",
      "y_data",
      "y_pred_val",
      "forward",
      "x_val",
      "loss_val",
      "loss",
      "x_val",
      "y_val",
      "l_sum",
      "loss_val",
      "print",
      "'\\t'",
      "x_val",
      "y_val",
      "y_pred_val",
      "loss_val",
      "print",
      "'MSE='",
      "l_sum",
      "w_list",
      "append",
      "mse_list",
      "append",
      "l_sum",
      "##画图",
      "plt",
      "plot",
      "w_list",
      "mse_list",
      "plt",
      "ylabel",
      "'Loss'",
      "plt",
      "xlabel",
      "'w'",
      "plt",
      "show",
      "结果：2.4 作业【1】：Matplotlib3D作图-plot_surface(), .contourf(), plt.colorbar()",
      "代码：import",
      "numpy",
      "import",
      "matplotlib",
      "pyplot",
      "plt",
      "from",
      "mpl_toolkits",
      "mplot3d",
      "import",
      "Axes3D",
      "from",
      "matplotlib",
      "import",
      "x_data",
      "1.0",
      "2.0",
      "3.0",
      "y_data",
      "2.0",
      "4.0",
      "6.0",
      "#线性模型",
      "def",
      "forward",
      "return",
      "#损失函数",
      "def",
      "loss",
      "y_pred",
      "forward",
      "return",
      "y_pred",
      "y_pred",
      "def",
      "mse",
      "l_sum",
      "for",
      "x_val",
      "y_val",
      "zip",
      "x_data",
      "y_data",
      "y_pred_val",
      "forward",
      "x_val",
      "loss_val",
      "loss",
      "x_val",
      "y_val",
      "l_sum",
      "loss_val",
      "print",
      "'\\t'",
      "x_val",
      "y_val",
      "y_pred_val",
      "loss_val",
      "print",
      "'MSE='",
      "l_sum",
      "return",
      "l_sum",
      "#迭代取值",
      "计算每个w取值下的x",
      "y",
      "y_pred,loss_val",
      "mse_list",
      "##画图",
      "##定义网格化数据",
      "b_list",
      "arange",
      "0.1",
      "w_list",
      "arange",
      "0.1",
      "##生成网格化数据",
      "meshgrid",
      "b_list",
      "w_list",
      "sparse",
      "False",
      "indexing",
      "'xy'",
      "##每个点的对应高度",
      "mse",
      "fig",
      "plt",
      "figure",
      "Axes3D",
      "fig",
      "plot_surface",
      "rstride",
      "cstride",
      "cmap",
      "viridis",
      "plt",
      "show",
      "结果："
    ],
    "codes": [
      "import numpy as np\nimport matplotlib.pyplot as plt;\nx_data = [1.0, 2.0, 3.0]\ny_data = [2.0, 4.0, 6.0]\n\n#线性模型\ndef forward(x):\n    return x * w\n\n#损失函数\ndef loss(x, y):\n    y_pred = forward(x)\n    return (y_pred - y) * (y_pred - y)\n\n#迭代取值，计算每个w取值下的x，y，y_pred,loss_val\nw_list = []\nmse_list = []\nfor w in np.arange(0.0, 4.1, 0.1):\n    print('w=', w)\n    l_sum = 0\n    for x_val, y_val in zip(x_data, y_data):\n        y_pred_val = forward(x_val)\n        loss_val = loss(x_val, y_val)\n        l_sum += loss_val\n        print('\\t', x_val, y_val, y_pred_val, loss_val)\n    print('MSE=', l_sum / 3)\n    w_list.append(w)\n    mse_list.append(l_sum / 3)\n\n##画图\nplt.plot(w_list, mse_list)\nplt.ylabel('Loss')\nplt.xlabel('w')\nplt.show()\n",
      "import numpy as np\nimport matplotlib.pyplot as plt;\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom matplotlib import cm\n\nx_data = [1.0, 2.0, 3.0]\ny_data = [2.0, 4.0, 6.0]\n\n#线性模型\ndef forward(x,w,b):\n    return x * w+ b\n\n#损失函数\ndef loss(x, y,w,b):\n    y_pred = forward(x,w,b)\n    return (y_pred - y) * (y_pred - y)\n\n\ndef mse(w,b):\n    l_sum = 0\n    for x_val, y_val in zip(x_data, y_data):\n        y_pred_val = forward(x_val,w,b)\n        loss_val = loss(x_val, y_val,w,b)\n        l_sum += loss_val\n        print('\\t', x_val, y_val, y_pred_val, loss_val)\n    print('MSE=', l_sum / 3)\n    return  l_sum/3\n\n#迭代取值，计算每个w取值下的x，y，y_pred,loss_val\nmse_list = []\n\n\n\n##画图\n\n##定义网格化数据\nb_list=np.arange(-30,30,0.1)\nw_list=np.arange(-30,30,0.1);\n\n##生成网格化数据\nxx, yy = np.meshgrid(b_list, w_list,sparse=False, indexing='xy')\n\n##每个点的对应高度\nzz=mse(xx,yy)\n\nfig = plt.figure()\nax = Axes3D(fig)\nax.plot_surface(xx, yy, zz, rstride=1, cstride=1, cmap=cm.viridis)\nplt.show()\n"
    ],
    "date": "2021-08-14",
    "text": "《PyTorch深度学习实践》学习笔记 【2】\n学习资源：\n《PyTorch深度学习实践》完结合集\n二、线性模型\n2.1 概念：\n2.1.1\n数据集和测试集\n数据集拿到后一般划分为两部分，训练集和测试集，然后使用训练集的数据来训练模型，用测试集上的误差作为最终模型在应对现实场景中的泛化误差。\n一般来说，测试集在训练的时候是不能偷看的。\n我们可以使用训练集的数据来训练模型，然后用测试集上的误差作为最终模型在应对现实场景中的泛化误差。有了测试集，我们想要验证模型的最终效果，只需将训练好的模型在测试集上计算误差，即可认为此误差即为泛化误差的近似，我们只需让我们训练好的模型在测试集上的误差最小即可。\n为了使得模型在现实生活中更有效，我们要使用的数据集要尽可能真实。\n2.1.2 过拟合与泛化\n下面拿小猫图像识别做例子，说明一下\n过拟合\n的概念；\n过拟合： 在训练集上匹配度很好，但是太过了，把噪声什么的也学进来了。\n泛化能力： 对于没见过的图像也能进行识别，这是我们所需要的。\n2.1.3\n开发集\n有时候无法看到测试集，我们又人为地把数据集划分一部分出来作为验证评估，称为“开发集”。\n2.1.4 监督学习和非监督学习\n有监督学习方法必须要有训练集与测试样本。在训练集中找规律，而对测试样本使用这种规律。而非监督学习没有训练集，只有一组数据，在该组数据集内寻找规律。\n有监督学习的方法就是识别事物，识别的结果表现在给待识别数据加上了标签。因此训练样本集必须由带标签的样本组成。而非监督学习方法只有要分析的数据集的本身，预先没有什么标签。如果发现数据集呈现某种聚集性，则可按自然的聚集性分类，但不予以某种预先分类标签对上号为目的。\n2.2 线性回归\n2.2.1 线性模型\n如 y= kx+b ，我们训练的结果就是k和b的值\n2.2.2 损失函数\n误差函数\n平均平方误差（MSE）\n损失函数的值越小，代表拟合的效果越好。\n2.3 课上实验【1】\n课上代码：\nimport\nnumpy\nimport\nmatplotlib\npyplot\nplt\nx_data\n1.0\n2.0\n3.0\ny_data\n2.0\n4.0\n6.0\n#线性模型\ndef\nforward\nreturn\n#损失函数\ndef\nloss\ny_pred\nforward\nreturn\ny_pred\ny_pred\n#迭代取值，计算每个w取值下的x，y，y_pred,loss_val\nw_list\nmse_list\nfor\narange\n0.0\n4.1\n0.1\nprint\n'w='\nl_sum\nfor\nx_val\ny_val\nzip\nx_data\ny_data\ny_pred_val\nforward\nx_val\nloss_val\nloss\nx_val\ny_val\nl_sum\nloss_val\nprint\n'\\t'\nx_val\ny_val\ny_pred_val\nloss_val\nprint\n'MSE='\nl_sum\nw_list\nappend\nmse_list\nappend\nl_sum\n##画图\nplt\nplot\nw_list\nmse_list\nplt\nylabel\n'Loss'\nplt\nxlabel\n'w'\nplt\nshow\n结果：\n2.4 作业【1】：\nMatplotlib3D作图-plot_surface(), .contourf(), plt.colorbar()\n代码：\nimport\nnumpy\nimport\nmatplotlib\npyplot\nplt\nfrom\nmpl_toolkits\nmplot3d\nimport\nAxes3D\nfrom\nmatplotlib\nimport\nx_data\n1.0\n2.0\n3.0\ny_data\n2.0\n4.0\n6.0\n#线性模型\ndef\nforward\nreturn\n#损失函数\ndef\nloss\ny_pred\nforward\nreturn\ny_pred\ny_pred\ndef\nmse\nl_sum\nfor\nx_val\ny_val\nzip\nx_data\ny_data\ny_pred_val\nforward\nx_val\nloss_val\nloss\nx_val\ny_val\nl_sum\nloss_val\nprint\n'\\t'\nx_val\ny_val\ny_pred_val\nloss_val\nprint\n'MSE='\nl_sum\nreturn\nl_sum\n#迭代取值，计算每个w取值下的x，y，y_pred,loss_val\nmse_list\n##画图\n##定义网格化数据\nb_list\narange\n0.1\nw_list\narange\n0.1\n##生成网格化数据\nmeshgrid\nb_list\nw_list\nsparse\nFalse\nindexing\n'xy'\n##每个点的对应高度\nmse\nfig\nplt\nfigure\nAxes3D\nfig\nplot_surface\nrstride\ncstride\ncmap\nviridis\nplt\nshow\n结果：\n"
  },
  {
    "head": "2021-06-06 ADT 总结",
    "paragraphs": [
      "ADT 总结",
      "1. ADT的内容",
      "属性（名词）",
      "rep",
      "内部数据结构",
      "不可见",
      "方法（动词）",
      "Spec规约",
      "impl实现",
      "方法，功能",
      "Spec可见",
      "impl不可见",
      "对外部只有接口，封装后用户不关心内部",
      "1.1 ADT的内部方法可以大致分为以下四类",
      "creator构造器",
      "初始化，新建一个ADT对象",
      "producer生产器",
      "比如 String.concat() 能够返回一个新的对象, 不改变内部数据",
      "observer观察器",
      "Eg: .size() 看内部东西，不改变内部数据",
      "mutator变值器",
      "Eg. Add() 修改内部数据",
      "大部分返回void / bool",
      "mutable",
      "类型才有！",
      "1.2 表示独立性",
      "内部变化后，外部不因此受影响",
      "为什么内部会变化(impl)？（优化性能，多种实现）",
      "内部变化一定要遵循spec! (测试用例就是根据spec写的）",
      "对于客户端，只能见到spec，无法看见rep和impl",
      "比如：List 可以有两种实现方式：",
      "但是从外部看来，调用方法并没有差异（比如.Add() 、 .remove() 方法是一样的）",
      "内部rep应该是private而不是public",
      "用户端使用的API 不应该因为内部rep实现的改变而瘫痪",
      "1.3 表示泄漏/ rep exposure：",
      "个人理解：client获取到了你内部变量/获取到了你的内部实现方法（本来不应该看到的，给人看到了！）",
      "如何避免表示泄漏：",
      "全部属性private",
      "对于mutable类型",
      "Collection.unmodifiable.wraped) （解决拷贝空间问题）",
      "防御式拷贝（返回一个拷贝后的新的对象）",
      "尽可能用immutable数据类型",
      "1.4 如何测试一个ADT的方法（测试用例）",
      "adt的四种方法、",
      "c/p/m 用observer查看属性",
      "O 先用c/p 造出，再调用o",
      "代码覆盖率无须100%",
      "2. ADT的不变性",
      "“始终保持为真的一组条件”",
      "2.1 抽象空间A ,实际空间R",
      "抽象空间A：用户看到的值;(Abstract)",
      "实际空间R：内部维系的值(Realization)",
      "A中的值，一定能够在R中至少找到一个值与之对应(满射）",
      "（但是不是单射不一定）",
      "2.2 AF RI 概念",
      "AF（abstract function）",
      "抽象函数",
      "（就是A --R之间的函数）",
      "抽象函数是表示从表示空间到抽象空间映射的函数比如：我存了一个graph图来表示人际关系",
      "AF(graph)=现实中的人际关系图",
      "RI（rep invariant）",
      "表示不变量",
      "表示不变量将表示变量值映射成一个布尔值。",
      "简单来说，就是一个条件，判断内部元素是否合法。",
      "比如：我要求图graph不为空，那么RI中就是“图不为空”这个条件。",
      "Checkrep():",
      "满足条件，合法； 不满足，非法！",
      "使得属性都满足RI为true",
      "每个方法返回之前调用",
      "用Assert +表达式",
      "False: throw AssertErro(直接退出！违反了RI，程序没有必要继续错误地执行）",
      "调用时机：",
      "C/P/M 最后一行返回之前。",
      "O 按道理来说不会改变RI，但是防止粗心，也需要在最后写一个。",
      "每次都调用，增加复杂度？",
      "开关！",
      "-ea 开发的时候，打开assert",
      "-da 交付的时候， 关闭assert",
      "参考：AF RI 的概念",
      "unmodifiableList 返回一个只能看不能改的方法",
      "3.ADT的设计流程",
      "设计一组方法（C/T/M/O） 以及spec",
      "TDD 测试用例 （根据spec）",
      "选择Rep（内部数据结构）/并impl",
      "设计RI （比如 边的权值不为负，点不能为空）",
      "设计AF （R—>A) （比如 边对应 人际关系）",
      "RI/AF 的注释",
      "是为了提醒自己怎么避免表示泄漏（mutable与immutable都要考虑）",
      "4.ADT如何保持表示不变性",
      "对于immutable，只要保证没有/M",
      "对于RI：checkRep()",
      "无表示泄漏！（见1.3）"
    ],
    "sentences": [
      "ADT 总结",
      "1. ADT的内容",
      "属性（名词）",
      "rep",
      "内部数据结构",
      "不可见",
      "方法（动词）",
      "Spec规约",
      "impl实现",
      "方法，功能",
      "Spec可见",
      "impl不可见",
      "对外部只有接口，封装后用户不关心内部",
      "1.1 ADT的内部方法可以大致分为以下四类",
      "creator构造器",
      "初始化，新建一个ADT对象",
      "producer生产器",
      "比如 String.concat() 能够返回一个新的对象, 不改变内部数据",
      "observer观察器",
      "Eg: .size() 看内部东西，不改变内部数据",
      "mutator变值器",
      "Eg. Add() 修改内部数据",
      "大部分返回void / bool",
      "mutable",
      "类型才有！",
      "1.2 表示独立性",
      "内部变化后，外部不因此受影响",
      "为什么内部会变化(impl)？（优化性能，多种实现）",
      "内部变化一定要遵循spec! (测试用例就是根据spec写的）",
      "对于客户端，只能见到spec，无法看见rep和impl",
      "比如：List 可以有两种实现方式：但是从外部看来",
      "调用方法并没有差异（比如.Add() 、 .remove() 方法是一样的）",
      "内部rep应该是private而不是public",
      "用户端使用的API 不应该因为内部rep实现的改变而瘫痪",
      "1.3 表示泄漏/ rep exposure：个人理解：client获取到了你内部变量/获取到了你的内部实现方法（本来不应该看到的",
      "给人看到了！）",
      "如何避免表示泄漏：全部属性private",
      "对于mutable类型",
      "Collection.unmodifiable.wraped) （解决拷贝空间问题）",
      "防御式拷贝（返回一个拷贝后的新的对象）",
      "尽可能用immutable数据类型",
      "1.4 如何测试一个ADT的方法（测试用例）",
      "adt的四种方法、c/p/m 用observer查看属性",
      "O 先用c/p 造出，再调用o",
      "代码覆盖率无须100%",
      "2. ADT的不变性",
      "“始终保持为真的一组条件”",
      "2.1 抽象空间A ,实际空间R",
      "抽象空间A：用户看到的值;(Abstract)",
      "实际空间R：内部维系的值(Realization)",
      "A中的值，一定能够在R中至少找到一个值与之对应(满射）",
      "（但是不是单射不一定）",
      "2.2 AF RI 概念",
      "AF（abstract function）",
      "抽象函数",
      "（就是A --R之间的函数）",
      "抽象函数是表示从表示空间到抽象空间映射的函数比如：我存了一个graph图来表示人际关系",
      "AF(graph)=现实中的人际关系图",
      "RI（rep invariant）",
      "表示不变量",
      "表示不变量将表示变量值映射成一个布尔值",
      "简单来说，就是一个条件，判断内部元素是否合法",
      "比如：我要求图graph不为空",
      "那么RI中就是“图不为空”这个条件",
      "Checkrep():满足条件，合法； 不满足，非法！",
      "使得属性都满足RI为true",
      "每个方法返回之前调用",
      "用Assert +表达式",
      "False: throw AssertErro(直接退出！违反了RI",
      "程序没有必要继续错误地执行）",
      "调用时机：C/P/M 最后一行返回之前",
      "O 按道理来说不会改变RI，但是防止粗心，也需要在最后写一个",
      "每次都调用，增加复杂度？",
      "开关！",
      "-ea 开发的时候，打开assert",
      "-da 交付的时候， 关闭assert",
      "参考：AF RI 的概念",
      "unmodifiableList 返回一个只能看不能改的方法",
      "3.ADT的设计流程",
      "设计一组方法（C/T/M/O） 以及spec",
      "TDD 测试用例 （根据spec）",
      "选择Rep（内部数据结构）/并impl",
      "设计RI （比如 边的权值不为负，点不能为空）",
      "设计AF （R—>A) （比如 边对应 人际关系）",
      "RI/AF 的注释",
      "是为了提醒自己怎么避免表示泄漏（mutable与immutable都要考虑）",
      "4.ADT如何保持表示不变性",
      "对于immutable，只要保证没有/M",
      "对于RI：checkRep()",
      "无表示泄漏！（见1.3）"
    ],
    "codes": [
      "  a. new()\n\n  b. 静态工厂：graph.empty()\n",
      "List a =New arrayList\n\nList b = New linkeList\n"
    ],
    "date": "2021-06-06",
    "text": "ADT 总结\n1. ADT的内容\n属性（名词）\nrep\n内部数据结构\n不可见\n方法（动词）\nSpec规约\nimpl实现\n方法，功能\nSpec可见\nimpl不可见\n对外部只有接口，封装后用户不关心内部\n1.1 ADT的内部方法可以大致分为以下四类\ncreator构造器\n初始化，新建一个ADT对象\nproducer生产器\n比如 String.concat() 能够返回一个新的对象, 不改变内部数据\nobserver观察器\nEg: .size() 看内部东西，不改变内部数据\nmutator变值器\nEg. Add() 修改内部数据\n大部分返回void / bool\nmutable\n类型才有！\n1.2 表示独立性\n内部变化后，外部不因此受影响\n为什么内部会变化(impl)？（优化性能，多种实现）\n内部变化一定要遵循spec! (测试用例就是根据spec写的）\n对于客户端，只能见到spec，无法看见rep和impl\n比如：List 可以有两种实现方式：\n但是从外部看来，调用方法并没有差异（比如.Add() 、 .remove() 方法是一样的）\n内部rep应该是private而不是public\n用户端使用的API 不应该因为内部rep实现的改变而瘫痪\n1.3 表示泄漏/ rep exposure：\n个人理解：client获取到了你内部变量/获取到了你的内部实现方法（本来不应该看到的，给人看到了！）\n如何避免表示泄漏：\n全部属性private\n对于mutable类型\nCollection.unmodifiable.wraped) （解决拷贝空间问题）\n防御式拷贝（返回一个拷贝后的新的对象）\n尽可能用immutable数据类型\n1.4 如何测试一个ADT的方法（测试用例）\nadt的四种方法、\nc/p/m 用observer查看属性\nO 先用c/p 造出，再调用o\n代码覆盖率无须100%\n2. ADT的不变性\n“始终保持为真的一组条件”\n2.1 抽象空间A ,实际空间R\n抽象空间A：用户看到的值;(Abstract)\n实际空间R：内部维系的值(Realization)\nA中的值，一定能够在R中至少找到一个值与之对应(满射）\n（但是不是单射不一定）\n2.2 AF RI 概念\nAF（abstract function）\n抽象函数\n（就是A --R之间的函数）\n抽象函数是表示从表示空间到抽象空间映射的函数比如：我存了一个graph图来表示人际关系\nAF(graph)=现实中的人际关系图\nRI（rep invariant）\n表示不变量\n表示不变量将表示变量值映射成一个布尔值。\n简单来说，就是一个条件，判断内部元素是否合法。\n比如：我要求图graph不为空，那么RI中就是“图不为空”这个条件。\nCheckrep():\n满足条件，合法； 不满足，非法！\n使得属性都满足RI为true\n每个方法返回之前调用\n用Assert +表达式\nFalse: throw AssertErro(直接退出！违反了RI，程序没有必要继续错误地执行）\n调用时机：\nC/P/M 最后一行返回之前。\nO 按道理来说不会改变RI，但是防止粗心，也需要在最后写一个。\n每次都调用，增加复杂度？\n开关！\n-ea 开发的时候，打开assert\n-da 交付的时候， 关闭assert\n参考：AF RI 的概念\nunmodifiableList 返回一个只能看不能改的方法\n3.ADT的设计流程\n设计一组方法（C/T/M/O） 以及spec\nTDD 测试用例 （根据spec）\n选择Rep（内部数据结构）/并impl\n设计RI （比如 边的权值不为负，点不能为空）\n设计AF （R—>A) （比如 边对应 人际关系）\nRI/AF 的注释\n是为了提醒自己怎么避免表示泄漏（mutable与immutable都要考虑）\n4.ADT如何保持表示不变性\n对于immutable，只要保证没有/M\n对于RI：checkRep()\n无表示泄漏！（见1.3）\n"
  },
  {
    "head": "148. 排序链表 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。",
    "paragraphs": [
      "快慢指针 找中点//slow：（5个停在3,10个停在5）",
      "后面那一种查找中点的方式更加简单，巧妙之处在于“fast=head->next;\""
    ],
    "sentences": [
      "快慢指针 找中点//slow：（5个停在3,10个停在5）",
      "后面那一种查找中点的方式更加简单",
      "巧妙之处在于“fast=head->next;\""
    ],
    "codes": [
      "class Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        if(head==NULL||head->next==NULL)\n        return head;\n        \n        // /*快慢指针 查找剧中节点*/\n        // ListNode* fast=head, *slow=head;\n        //      ListNode* tmp=head;\n        // while(fast!=nullptr&&fast->next!=nullptr){\n        //    tmp=slow;\n        //    fast=fast->next->next;\n        //    slow=slow->next;\n        // }\n        // tmp->next=NULL;\n        // ListNode* left=sortList(head);\n        // ListNode* right=sortList(slow);\n\n\n    ListNode* fast=head->next,* slow=head;\n    while(fast&&fast->next){\n        fast=fast->next->next;\n        slow=slow->next;\n    }\n    ListNode* pre=slow->next;\n        slow->next=NULL;\n    ListNode* left=sortList(head);\n    ListNode* right=sortList(pre);\n       return merge(left,right);\n    }\n",
      " ListNode* merge(ListNode* left, ListNode* right)\n       { ListNode* result=new ListNode(0);\n        ListNode* cur=result;\n    while(left!=NULL&&right!=NULL){\n            if(left->val<right->val)\n            {\n                cur->next=left;\n                cur=cur->next;\n                left=left->next;\n            } \n             else{\n                cur->next=right;\n                cur=cur->next;\n                right=right->next;\n            }\n        }\n        if(left!=NULL){\n            cur->next=left;\n        }\n        if(right!=NULL){\n            cur->next=right;\n        }\n        //  cur->next=(left==NULL? right:left);\n        return result->next;\n    }\n"
    ],
    "date": "2020-10-21",
    "text": "快慢指针 找中点//slow：（5个停在3,10个停在5）\n后面那一种查找中点的方式更加简单，巧妙之处在于“fast=head->next;\"\n"
  },
  {
    "head": "Vmware共享目录消失（绝对有用！）",
    "paragraphs": [
      "查看是否已经挂载",
      "2. 如果没有挂载",
      "再次查看"
    ],
    "sentences": [
      "查看是否已经挂载",
      "2. 如果没有挂载",
      "再次查看"
    ],
    "codes": [
      "vmware-hgfsclient\n",
      "先umount卸下\n",
      "sudo umount /mnt/hgfs\n",
      "然后在重新挂上去\n",
      "sudo vmhgfs-fuse .host:/ /mnt/hgfs\n",
      "vmware-hgfsclient\n"
    ],
    "date": "2021-07-09",
    "text": "查看是否已经挂载\n2. 如果没有挂载\n再次查看\n"
  },
  {
    "head": "【lab2】如何创建可变类&不可变类",
    "paragraphs": [
      "如何创建可变类&不可变类",
      "可变类和不可变类(Mutable and Immutable Objects)",
      "可变类和不可变类的区别： 是否有mutator方法（是否可以更改属性）",
      "可变类和不可变类(Mutable and Immutable Objects)的初步定义：",
      "可变类：当你获得这个类的一个实例引用时，你可以改变这个实例的内容。",
      "不可变类：当你获得这个类的一个实例引用时，你不可以改变这个实例的内容。不可变类的实例一但创建，其内在成员变量的值就不能被修改。",
      "举个例子：String和StringBuilder，String是immutable的，每次对于String对象的修改都将产生一个新的String对象，而原来的对象保持不变，而StringBuilder是mutable，因为每次对于它的对象的修改都作用于该对象本身，并没有产生新的对象。",
      "如何创建一个自己的不可变类：",
      "a. 所有属性都是private final",
      "b. 不提供对成员的改变方法，例如：也就是王老师上课说的",
      "“immutable类不能有mutator的方法”",
      "c. 确保所有的方法不会被重载。手段有两种：使用final Class(强不可变类)，或者将所有类方法加上final(弱不可变类)。",
      "d. 确保类不能被继承：",
      "将类声明为final, 或者使用静态工厂并声明构造器为private。",
      "静态工厂能保证对象创造时的唯一性；并且由于命名不是固定的，更能清楚地表达意思。",
      "(如果类可以被继承会破坏类的不可变性机制，只要继承类覆盖父类的方法并且继承类可以改变成员变量值，那么一旦子类以父类的形式出现时，不能保证当前类是否可变。)",
      "如果某一个类成员不是原始变量(primitive)或者不可变类，必须通过在成员初始化(in)或者get方法(out)时通过深度clone方法，来确保类的不可变。",
      "reference: 可变类与不可变类的区别",
      "reference: JAVA - 可变对象与不可变对象",
      "优质reference：[Java] 如何实现一个不可变类（Immutable class）"
    ],
    "sentences": [
      "如何创建可变类&不可变类",
      "可变类和不可变类(Mutable and Immutable Objects)",
      "可变类和不可变类的区别： 是否有mutator方法（是否可以更改属性）",
      "可变类和不可变类(Mutable and Immutable Objects)的初步定义：可变类：当你获得这个类的一个实例引用时",
      "你可以改变这个实例的内容",
      "不可变类：当你获得这个类的一个实例引用时",
      "你不可以改变这个实例的内容",
      "不可变类的实例一但创建，其内在成员变量的值就不能被修改",
      "举个例子：String和StringBuilder",
      "String是immutable的",
      "每次对于String对象的修改都将产生一个新的String对象",
      "而原来的对象保持不变",
      "而StringBuilder是mutable",
      "因为每次对于它的对象的修改都作用于该对象本身",
      "并没有产生新的对象",
      "如何创建一个自己的不可变类：a. 所有属性都是private final",
      "b. 不提供对成员的改变方法，例如：也就是王老师上课说的",
      "“immutable类不能有mutator的方法”",
      "c. 确保所有的方法不会被重载",
      "手段有两种：使用final Class(强不可变类)",
      "或者将所有类方法加上final(弱不可变类)",
      "d. 确保类不能被继承：将类声明为final, 或者使用静态工厂并声明构造器为private",
      "静态工厂能保证对象创造时的唯一性；并且由于命名不是固定的",
      "更能清楚地表达意思",
      "(如果类可以被继承会破坏类的不可变性机制",
      "只要继承类覆盖父类的方法并且继承类可以改变成员变量值",
      "那么一旦子类以父类的形式出现时",
      "不能保证当前类是否可变",
      ")",
      "如果某一个类成员不是原始变量(primitive)或者不可变类",
      "必须通过在成员初始化(in)或者get方法(out)时通过深度clone方法",
      "来确保类的不可变",
      "reference: 可变类与不可变类的区别",
      "reference: JAVA - 可变对象与不可变对象",
      "优质reference：[Java] 如何实现一个不可变类（Immutable class）"
    ],
    "codes": [],
    "date": "2021-06-09",
    "text": "如何创建可变类&不可变类\n可变类和不可变类(Mutable and Immutable Objects)\n可变类和不可变类的区别： 是否有mutator方法（是否可以更改属性）\n可变类和不可变类(Mutable and Immutable Objects)的初步定义：\n可变类：当你获得这个类的一个实例引用时，你可以改变这个实例的内容。\n不可变类：当你获得这个类的一个实例引用时，你不可以改变这个实例的内容。不可变类的实例一但创建，其内在成员变量的值就不能被修改。\n举个例子：String和StringBuilder，String是immutable的，每次对于String对象的修改都将产生一个新的String对象，而原来的对象保持不变，而StringBuilder是mutable，因为每次对于它的对象的修改都作用于该对象本身，并没有产生新的对象。\n如何创建一个自己的不可变类：\na. 所有属性都是private final\nb. 不提供对成员的改变方法，例如：也就是王老师上课说的\n“immutable类不能有mutator的方法”\nc. 确保所有的方法不会被重载。手段有两种：使用final Class(强不可变类)，或者将所有类方法加上final(弱不可变类)。\nd. 确保类不能被继承：\n将类声明为final, 或者使用静态工厂并声明构造器为private。\n静态工厂能保证对象创造时的唯一性；并且由于命名不是固定的，更能清楚地表达意思。\n(如果类可以被继承会破坏类的不可变性机制，只要继承类覆盖父类的方法并且继承类可以改变成员变量值，那么一旦子类以父类的形式出现时，不能保证当前类是否可变。)\n如果某一个类成员不是原始变量(primitive)或者不可变类，必须通过在成员初始化(in)或者get方法(out)时通过深度clone方法，来确保类的不可变。\nreference: 可变类与不可变类的区别\nreference: JAVA - 可变对象与不可变对象\n优质reference：[Java] 如何实现一个不可变类（Immutable class）\n"
  },
  {
    "head": "ubuntu 下无法看到共享文件夹",
    "paragraphs": [
      "无法看到mnt/hgfs/后的共享文件夹",
      "sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000"
    ],
    "sentences": [
      "无法看到mnt/hgfs/后的共享文件夹",
      "sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000"
    ],
    "codes": [],
    "date": "2021-05-02",
    "text": "无法看到mnt/hgfs/后的共享文件夹\nsudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000\n"
  },
  {
    "head": "【总结】Obj & Spec",
    "paragraphs": [
      "SPEC",
      "Object",
      "属性/数据",
      "可变的",
      "不可变的",
      "Spec",
      "Spec:",
      "定义： 双方的“合同”/”防火墙“（外部不可见）",
      "基本结构：",
      "前置条件（对参数的约束，对客户端的约束）",
      "后置条件（对返回值的约束，对开发者的约束）",
      "原则：",
      "前置满足---->后置必须满足 前置满足—>？(fail fine)",
      "Spec是给客户端看的，不要把程序内部暴露出来",
      "强度：",
      "stronger（对客户端更加友好/易使用，对开发者要求更高/难设计/实现方式更少）：",
      "前置条件更弱 , 后置条件更强（在前置条件一样的情况下）",
      "【注：看PPT的几个例子】",
      "下面情况不可比较强度：",
      "前置变弱 且 前置相同时，后置变弱",
      "当不可比较的时候，两个spec无法替代另一个",
      "当可以比较的时候，可以用stronger的条件代替weaker的条件",
      "Spec 的强度：",
      "A>b:",
      "可以用A取代b",
      "preA <= preb",
      "更弱的前置条件",
      "postA>=postb (以b的pre为准）",
      "更强的后置条件",
      "更强的spec",
      "实现自由度小，难于开发",
      "易于使用",
      "ven图：更大的圈代表更大的实现自由度，spec强度更低",
      "可以让后置条件减弱：Throw error",
      "参数检查的代价：",
      "代价高： 不实现，写在pre-condition中",
      "代价低：检查，直接在post中抛出异常"
    ],
    "sentences": [
      "SPEC",
      "Object",
      "属性/数据",
      "可变的",
      "不可变的",
      "Spec",
      "Spec:定义： 双方的“合同”/”防火墙“（外部不可见）",
      "基本结构：前置条件（对参数的约束，对客户端的约束）",
      "后置条件（对返回值的约束，对开发者的约束）",
      "原则：前置满足---->后置必须满足 前置满足—>？(fail fine)",
      "Spec是给客户端看的，不要把程序内部暴露出来",
      "强度：stronger（对客户端更加友好/易使用",
      "对开发者要求更高/难设计/实现方式更少）：前置条件更弱 , 后置条件更强（在前置条件一样的情况下）",
      "【注：看PPT的几个例子】",
      "下面情况不可比较强度：前置变弱 且 前置相同时，后置变弱",
      "当不可比较的时候，两个spec无法替代另一个",
      "当可以比较的时候",
      "可以用stronger的条件代替weaker的条件",
      "Spec 的强度：A>b:可以用A取代b",
      "preA <= preb",
      "更弱的前置条件",
      "postA>=postb (以b的pre为准）",
      "更强的后置条件",
      "更强的spec",
      "实现自由度小，难于开发",
      "易于使用",
      "ven图：更大的圈代表更大的实现自由度，spec强度更低",
      "可以让后置条件减弱：Throw error",
      "参数检查的代价：代价高： 不实现",
      "写在pre-condition中",
      "代价低：检查，直接在post中抛出异常"
    ],
    "codes": [],
    "date": "2021-06-09",
    "text": "SPEC\nObject\n属性/数据\n可变的\n不可变的\nSpec\nSpec:\n定义： 双方的“合同”/”防火墙“（外部不可见）\n基本结构：\n前置条件（对参数的约束，对客户端的约束）\n后置条件（对返回值的约束，对开发者的约束）\n原则：\n前置满足---->后置必须满足 前置满足—>？(fail fine)\nSpec是给客户端看的，不要把程序内部暴露出来\n强度：\nstronger（对客户端更加友好/易使用，对开发者要求更高/难设计/实现方式更少）：\n前置条件更弱 , 后置条件更强（在前置条件一样的情况下）\n【注：看PPT的几个例子】\n下面情况不可比较强度：\n前置变弱 且 前置相同时，后置变弱\n当不可比较的时候，两个spec无法替代另一个\n当可以比较的时候，可以用stronger的条件代替weaker的条件\nSpec 的强度：\nA>b:\n可以用A取代b\npreA <= preb\n更弱的前置条件\npostA>=postb (以b的pre为准）\n更强的后置条件\n更强的spec\n实现自由度小，难于开发\n易于使用\nven图：更大的圈代表更大的实现自由度，spec强度更低\n可以让后置条件减弱：Throw error\n参数检查的代价：\n代价高： 不实现，写在pre-condition中\n代价低：检查，直接在post中抛出异常\n"
  },
  {
    "head": "【lab2】关于构造器非法参数的问题",
    "paragraphs": [
      "结论： 如果判断条件非法，直接抛出异常",
      "参考网址",
      "下面直接截取详细内容：",
      "If the program ever executes a statement like:",
      "Java stops the program and signals the",
      "error",
      "through the constructed instance of the",
      "???Exception",
      "(where the ??? are replaced by the name of whichever particular exception is desired). For our purposes, this will simply terminate the program and print the given error message."
    ],
    "sentences": [
      "结论： 如果判断条件非法，直接抛出异常",
      "参考网址",
      "下面直接截取详细内容：If the program ever executes a statement like:Java stops the program and signals the",
      "error",
      "through the constructed instance of the",
      "???Exception",
      "(where the ??? are replaced by the name of whichever particular exception is desired). For our purposes, this will simply terminate the program and print the given error message."
    ],
    "codes": [
      "throw new IllegalArgumentException(\"Wrong!\");\n",
      "throw new ???Exception(\"… message …\");"
    ],
    "date": "2021-06-09",
    "text": "结论： 如果判断条件非法，直接抛出异常\n参考网址\n下面直接截取详细内容：\nIf the program ever executes a statement like:\nJava stops the program and signals the\nerror\nthrough the constructed instance of the\n???Exception\n(where the ??? are replaced by the name of whichever particular exception is desired). For our purposes, this will simply terminate the program and print the given error message.\n"
  },
  {
    "head": "Software Construction lab 2：总结",
    "paragraphs": [
      "Software Construction lab 2",
      "junit测试代码覆盖率：",
      "代码覆盖率可以使用IDEA自带的工具",
      "[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wTShgQvr-1622905245128)(E:\\Typora_info\\pong\\image-20210605214220642.png)]",
      "整体设计流程：",
      "写Spec",
      "根据Spec完成测试用例",
      "实现Graph",
      "防止内存泄漏的方法",
      "checkRep()的意义",
      "我们定义的每一个对象，都要遵循规约，而checkRep()就是我们检查对象内部属性是否合法的方法。",
      "调用时机：应该在所有方法的最后一行/返回前 调用checkRep() ,不必担心影响程序速度，可以关掉。",
      "读取TXT文件",
      "使用BuffererReader.继承Reader类",
      "way2:使用FileInputStream类",
      "java异常捕获",
      "java异常捕获"
    ],
    "sentences": [
      "Software Construction lab 2",
      "junit测试代码覆盖率：代码覆盖率可以使用IDEA自带的工具",
      "[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wTShgQvr-1622905245128)(E:\\Typora_info\\pong\\image-20210605214220642.png)]",
      "整体设计流程：写Spec",
      "根据Spec完成测试用例",
      "实现Graph",
      "防止内存泄漏的方法",
      "checkRep()的意义",
      "我们定义的每一个对象",
      "都要遵循规约",
      "而checkRep()就是我们检查对象内部属性是否合法的方法",
      "调用时机：应该在所有方法的最后一行/返回前 调用checkRep() ,不必担心影响程序速度",
      "可以关掉",
      "读取TXT文件",
      "使用BuffererReader.继承Reader类",
      "way2:使用FileInputStream类",
      "java异常捕获",
      "java异常捕获"
    ],
    "codes": [
      "1. 内部变量尽量使用immutable的，并设置为私有属性\n2. 对于返回值，如果是mutable数据类型，一定要使用防御式拷贝\n3. 必要时加上final关键字 \n",
      "public void fileRead() throws Exception {\n        File file = new File(\"D:\\\\test.txt\");//定义一个file对象，用来初始化FileReader\n        FileReader reader = new FileReader(file);//定义一个fileReader对象，用来初始化BufferedReader\n        BufferedReader bReader = new BufferedReader(reader);//new一个BufferedReader对象，将文件内容读取到缓存\n        StringBuilder sb = new StringBuilder();//定义一个字符串缓存，将字符串存放缓存中\n        String s = \"\";\n        while ((s =bReader.readLine()) != null) {//逐行读取文件内容，不读取换行符和末尾的空格\n            sb.append(s + \"\\n\");//将读取的字符串添加换行符后累加存放在缓存中\n            System.out.println(s);\n        }\n        bReader.close();\n        String str = sb.toString();\n        System.out.println(str );\n    }\n",
      "private static String getTemplateContent() throws Exception{\n    File file = new File(\"D:\\\\test.txt\");\n    if(!file.exists()){\n        return null;\n    }\n    FileInputStream inputStream = new FileInputStream(file);\n    int length = inputStream.available();\n    byte bytes[] = new byte[length];\n    inputStream.read(bytes);\n    inputStream.close();\n    String str =new String(bytes, StandardCharsets.UTF_8);\n    return str ;\n}\n",
      "try{\n    d = Double.parseDouble(bidPrice);\n}catch (Exception e){\n    e.printStackTrace();\n    //            方法也抛出了异常，交由调用者处理  \n    throw new AuctionException(\"这是由throw关键字抛出的异常\");\n}\n\n\ntry{\n    at.bid(\"abc\");\n}catch (AuctionException ae){\n    System.err.println(ae.getMessage());\n}\n"
    ],
    "date": "2021-06-05",
    "text": "Software Construction lab 2\njunit测试代码覆盖率：\n代码覆盖率可以使用IDEA自带的工具\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wTShgQvr-1622905245128)(E:\\Typora_info\\pong\\image-20210605214220642.png)]\n整体设计流程：\n写Spec\n根据Spec完成测试用例\n实现Graph\n防止内存泄漏的方法\ncheckRep()的意义\n我们定义的每一个对象，都要遵循规约，而checkRep()就是我们检查对象内部属性是否合法的方法。\n调用时机：应该在所有方法的最后一行/返回前 调用checkRep() ,不必担心影响程序速度，可以关掉。\n读取TXT文件\n使用BuffererReader.继承Reader类\nway2:使用FileInputStream类\njava异常捕获\njava异常捕获\n"
  },
  {
    "head": "正则表达式在Java语言程序编程时如何从文件中读取数据并运用",
    "paragraphs": [
      "正则表达式在Java语言程序编程时如何从文件中读取数据并运用",
      "1.读取文件",
      "读取文件的方式有很多，这里我简单地使用字符串标明路径，通过路径创建文件型变量（File）。",
      "这时我们能够从文件以字符串的形式读取内容，通过相关的正则表达式来判断内容是否正确。",
      "2.转换文件信息",
      "我们无法直接从文件里获取数据给程序中的变量，因此我们要暂时存储数据",
      "这里为了保证文件读取后转换为String类型时其内容的结构不变（如果你使用过正则语言表达式，你会发现空格是很恶心的东西），所以我们使用Scanner.nextLine()来成行地读取数据。",
      "3.再次提取信息",
      "这是一段很经典的正则语言匹配代码，parser为字符串类型变量，它表示的是正则语言表达式；而m可以看作是正则表达式在s中索引内容parser的一个方法概括,m.find()代表正则表达式找到了一个匹配的对象，此时如果再m.find()的话正则表达式会去寻找下一个匹配的对象（这一点和next()很像）。在这里要注意的是m.group()返回的是m.find()找到的对象，这就意味着，如果开始时没有m.find()，m.group()是不起作用的；同时，如果只进行一次m.find()，无论输出多少次m.group()都只是最靠近的一次m.find()找到的内容。",
      "4.提取变量内容",
      "在这里，比如说我想提取一段时间，文本内容是",
      "这里我们进行一下简单约束，我们可以设计一个正则语言把时间提取出来",
      "通过我上述的代码完全可以获得",
      "我们再精确提取时间",
      "此时变量数据便提取了出来。"
    ],
    "sentences": [
      "正则表达式在Java语言程序编程时如何从文件中读取数据并运用",
      "1.读取文件",
      "读取文件的方式有很多",
      "这里我简单地使用字符串标明路径",
      "通过路径创建文件型变量（File）",
      "这时我们能够从文件以字符串的形式读取内容",
      "通过相关的正则表达式来判断内容是否正确",
      "2.转换文件信息",
      "我们无法直接从文件里获取数据给程序中的变量",
      "因此我们要暂时存储数据",
      "这里为了保证文件读取后转换为String类型时其内容的结构不变（如果你使用过正则语言表达式",
      "你会发现空格是很恶心的东西）",
      "所以我们使用Scanner.nextLine()来成行地读取数据",
      "3.再次提取信息",
      "这是一段很经典的正则语言匹配代码",
      "parser为字符串类型变量",
      "它表示的是正则语言表达式；而m可以看作是正则表达式在s中索引内容parser的一个方法概括,m.find()代表正则表达式找到了一个匹配的对象",
      "此时如果再m.find()的话正则表达式会去寻找下一个匹配的对象（这一点和next()很像）",
      "在这里要注意的是m.group()返回的是m.find()找到的对象",
      "这就意味着",
      "如果开始时没有m.find()",
      "m.group()是不起作用的；同时",
      "如果只进行一次m.find()",
      "无论输出多少次m.group()都只是最靠近的一次m.find()找到的内容",
      "4.提取变量内容",
      "在这里，比如说我想提取一段时间，文本内容是",
      "这里我们进行一下简单约束",
      "我们可以设计一个正则语言把时间提取出来",
      "通过我上述的代码完全可以获得",
      "我们再精确提取时间",
      "此时变量数据便提取了出来"
    ],
    "codes": [
      "String filepath=\"src/txt/test.txt\";\nFile file=new File(filepath);\nScanner fileread =new Scanner(file);\n",
      "String text=\"\";\nwhile(fileread.hasNext()) {\n\ttext+=fileread.nextLine();\n    text+=\"\\n\";\n}\nfileread.close();\n",
      "String s;\n......\nPattern pattern=Pattern.compile(String parser);\nMatcher m=pattern.matcher(s);\nwhile(m.find()){\n\tSystem.out.println(m.group());\n}\n",
      "......\n{2021-01-01,2021-02-03}\n......\n",
      "parser=\"//{20[0-9][0-9]-[0-9][0-9]-[0-9][0-9],20[0-9][0-9]-[0-9][0-9]-[0-9][0-9]//}\";\n",
      "String message=m.group();\n",
      "int year1, year2, month1, month2, day1, day2;\nPattern Year=pattern.compile(\"20[0-9][0-9]\");\nPattern Month=pattern.compile(\"[0-9][0-9]\");\nPattern Day=pattern.compile(\"[0-9][0-9]\");\nMatcher year=Year.matcher(message);\nMatcher month=Month.matcher(message);\nMatcher day=Day.matcher(message);\nyear.find();//**2021**-01-01,2021-02-03\nyear1=Integer.parseInt(year.group());\nyear.find();//2021-01-01,**2021**-02-03\nyear2=Integer.parseInt(year.group());\nmonth.find();//**20**21-01-01,2021-02-03\nmonth.find();//20**21**-01-01,2021-02-03\nmonth.find();//2021-**01**-01,2021-02-03\nmonth1=Integer.parseInt(month.group());\nmonth.find();//2021-01-**01**,2021-02-03\nmonth.find();//2021-01-01,**20**21-02-03\nmonth.find();//2021-01-01,20**21**-02-03\nmonth.find();//2021-01-01,2021-**02**-03\nmonth2=Integer.parseInt(month.group());\nday.find();//**20**21-01-01,2021-02-03\nday.find();//20**21**-01-01,2021-02-03\nday.find();//2021-**01**-01,2021-02-03\nday.find();//2021-01-**01**,2021-02-03\nday1=Integer.parseInt(day.group());\nday.find();//2021-01-01,**20**21-02-03\nday.find();//2021-01-01,20**21**-02-03\nday.find();//2021-01-01,2021-**02**-03\nday.find();//2021-01-01,2021-02-**03**\nday2=Integer.parseInt(day.group());\n"
    ],
    "date": "2021-07-04",
    "text": "正则表达式在Java语言程序编程时如何从文件中读取数据并运用\n1.读取文件\n读取文件的方式有很多，这里我简单地使用字符串标明路径，通过路径创建文件型变量（File）。\n这时我们能够从文件以字符串的形式读取内容，通过相关的正则表达式来判断内容是否正确。\n2.转换文件信息\n我们无法直接从文件里获取数据给程序中的变量，因此我们要暂时存储数据\n这里为了保证文件读取后转换为String类型时其内容的结构不变（如果你使用过正则语言表达式，你会发现空格是很恶心的东西），所以我们使用Scanner.nextLine()来成行地读取数据。\n3.再次提取信息\n这是一段很经典的正则语言匹配代码，parser为字符串类型变量，它表示的是正则语言表达式；而m可以看作是正则表达式在s中索引内容parser的一个方法概括,m.find()代表正则表达式找到了一个匹配的对象，此时如果再m.find()的话正则表达式会去寻找下一个匹配的对象（这一点和next()很像）。在这里要注意的是m.group()返回的是m.find()找到的对象，这就意味着，如果开始时没有m.find()，m.group()是不起作用的；同时，如果只进行一次m.find()，无论输出多少次m.group()都只是最靠近的一次m.find()找到的内容。\n4.提取变量内容\n在这里，比如说我想提取一段时间，文本内容是\n这里我们进行一下简单约束，我们可以设计一个正则语言把时间提取出来\n通过我上述的代码完全可以获得\n我们再精确提取时间\n此时变量数据便提取了出来。\n"
  },
  {
    "head": "HIT软件构造---Git工具使用遇见的问题",
    "paragraphs": [
      "HIT软件构造",
      "--------Git工具使用小记",
      "==HIT软件构造==--------Git工具使用小记",
      "==校园网==登录不上github",
      "==git==常见指令（只列平常用的多的，其他建帮助手册）",
      "记录一些在使用git时遇见的==奇怪问题==",
      "校园网",
      "登录不上github",
      "只能说太离谱了，不翻墙登不上github，被针对了？",
      "git",
      "常见指令（只列平常用的多的，其他建帮助手册）",
      "1.git init:",
      "初始化一个本地git仓库",
      "2.git clone [url]:",
      "将[url]处的远程仓库拷贝到本地",
      "3.git add * :",
      "将当前文件下的所有文件（*代表所有文件）提交到暂存区",
      "4.git commit -m \" \" :",
      "提交暂存区的文件到本地仓库 \" \"内记录一些本次提交的信息",
      "5.git push origin master:master :",
      "这个指令更一般化的形式是 git push 远程主机名 远程分支名 本地分支名，可以将本地仓库的文件提交到远程仓库（github、gitee等）",
      "6.git fetch:",
      "将远程仓库的某分支拉取到本地仓库",
      "7.git merge：",
      "合并分支",
      "8.git pull：",
      "相当于git fetch + git merge：将远程仓库直接拉取并和本地仓库合并",
      "记录一些在使用git时遇见的",
      "奇怪问题",
      "1.fetch、pull、push、clone时遇到",
      "Failed to connect to github.com port 443: Timed out",
      "的错误",
      "而且还时有时没有的，把人整蒙了。",
      "在翻墙时会自动打开使用代理服务器这一项，导致连接不到github的端口，所以我们把这一项取消，并选中上面的",
      "自动检测",
      "如图所示，这样就不会出现timeout的错误了。",
      "2.main和master的问题",
      "以往github默认分支名字时master，但是到2020年之后github官方将默认名字改为了main。但是老师明确说明要将代码提交到master分支，所以我们要建立一个master分支，再将其提交上去。"
    ],
    "sentences": [
      "HIT软件构造",
      "--------Git工具使用小记",
      "==HIT软件构造==--------Git工具使用小记",
      "==校园网==登录不上github",
      "==git==常见指令（只列平常用的多的，其他建帮助手册）",
      "记录一些在使用git时遇见的==奇怪问题==",
      "校园网",
      "登录不上github",
      "只能说太离谱了，不翻墙登不上github，被针对了？",
      "git",
      "常见指令（只列平常用的多的，其他建帮助手册）",
      "1.git init:初始化一个本地git仓库",
      "2.git clone [url]:将[url]处的远程仓库拷贝到本地",
      "3.git add * :将当前文件下的所有文件（*代表所有文件）提交到暂存区",
      "4.git commit -m \" \" :提交暂存区的文件到本地仓库 \" \"内记录一些本次提交的信息",
      "5.git push origin master:master :这个指令更一般化的形式是 git push 远程主机名 远程分支名 本地分支名",
      "可以将本地仓库的文件提交到远程仓库（github、gitee等）",
      "6.git fetch:将远程仓库的某分支拉取到本地仓库",
      "7.git merge：合并分支",
      "8.git pull：相当于git fetch + git merge：将远程仓库直接拉取并和本地仓库合并",
      "记录一些在使用git时遇见的",
      "奇怪问题",
      "1.fetch、pull、push、clone时遇到",
      "Failed to connect to github.com port 443: Timed out",
      "的错误",
      "而且还时有时没有的，把人整蒙了",
      "在翻墙时会自动打开使用代理服务器这一项",
      "导致连接不到github的端口",
      "所以我们把这一项取消",
      "并选中上面的",
      "自动检测",
      "如图所示，这样就不会出现timeout的错误了",
      "2.main和master的问题",
      "以往github默认分支名字时master",
      "但是到2020年之后github官方将默认名字改为了main",
      "但是老师明确说明要将代码提交到master分支",
      "所以我们要建立一个master分支",
      "再将其提交上去"
    ],
    "codes": [],
    "date": "2021-05-19",
    "text": "HIT软件构造\n--------Git工具使用小记\n==HIT软件构造==--------Git工具使用小记\n==校园网==登录不上github\n==git==常见指令（只列平常用的多的，其他建帮助手册）\n记录一些在使用git时遇见的==奇怪问题==\n校园网\n登录不上github\n只能说太离谱了，不翻墙登不上github，被针对了？\ngit\n常见指令（只列平常用的多的，其他建帮助手册）\n1.git init:\n初始化一个本地git仓库\n2.git clone [url]:\n将[url]处的远程仓库拷贝到本地\n3.git add * :\n将当前文件下的所有文件（*代表所有文件）提交到暂存区\n4.git commit -m \" \" :\n提交暂存区的文件到本地仓库 \" \"内记录一些本次提交的信息\n5.git push origin master:master :\n这个指令更一般化的形式是 git push 远程主机名 远程分支名 本地分支名，可以将本地仓库的文件提交到远程仓库（github、gitee等）\n6.git fetch:\n将远程仓库的某分支拉取到本地仓库\n7.git merge：\n合并分支\n8.git pull：\n相当于git fetch + git merge：将远程仓库直接拉取并和本地仓库合并\n记录一些在使用git时遇见的\n奇怪问题\n1.fetch、pull、push、clone时遇到\nFailed to connect to github.com port 443: Timed out\n的错误\n而且还时有时没有的，把人整蒙了。\n在翻墙时会自动打开使用代理服务器这一项，导致连接不到github的端口，所以我们把这一项取消，并选中上面的\n自动检测\n如图所示，这样就不会出现timeout的错误了。\n2.main和master的问题\n以往github默认分支名字时master，但是到2020年之后github官方将默认名字改为了main。但是老师明确说明要将代码提交到master分支，所以我们要建立一个master分支，再将其提交上去。\n"
  },
  {
    "head": "面向可复用性的软件构造",
    "paragraphs": [
      "一.复用的等级和形态",
      "源代码级别的复用：复制粘贴",
      "模块级别的复用：类与接口",
      "库级别的复用：API和包",
      "二.复用的类型",
      "白盒复用：复制并修改一段代码。可以对代码的功能进行定制，但是愮指导代码内部的实现逻辑，增加了软件的复杂度。",
      "黑盒复用：不能直接看到源代码，只是利用别人提供的API，更加简单，但是适用性差。",
      "三.源代码级别的复用",
      "粘贴代码",
      "四.模块级别的复用：类与接口",
      "继承：",
      "设计继承树",
      "可能会重写一堆方法（@Override）",
      "extend",
      "是类级别的复用",
      "代理：",
      "显式代理：传递对象给需要使用这些功能的对象",
      "隐式代理：将某个对象定义为这个对象的成员，去调用其方法",
      "是对象级别的复用",
      "五.库级别的复用：API和包",
      "库：开发者构造软件，去调用库中的功能",
      "框架：可以复用的骨架代码，可以定制功能到某个应用。框架作为主程序去执行，执行过程中调用开发者自己写的程序",
      "六.框架级别的复用",
      "框架：一组抽象类和具体类，以及他们之间的关系。开发者根据框架的规约，填充一些自己的代码进去，形成完整的代码",
      "白盒框架：通过继承进行框架的扩展",
      "黑盒框架：通过实现特定的接口、或者通过dialing来进行扩展",
      "七.行为子类型和LSP原则",
      "子类型多态：客户端可以用统一的方式来处理不同类型的对象。使用父类的地方，都可以无条件用子类来代替。",
      "静态类型检查（即编译器对子类型的要求）：",
      "子类型可以添加方法，但是不可以删除",
      "子类型需要实现抽象类型中的所有未实现的方法",
      "子类型中重写的方法必须有相同或子类型的返回值候符合协变的返回值",
      "子类中重写的方法必须使用同样类型的参数或者符合逆变的参数",
      "子类型中重写的方法不能抛出额外的异常",
      "总结：",
      "更强的不变量、更弱的前置条件、更强的后置条件",
      "协变：",
      "返回值的类型和异常的类型要更加具体。",
      "逆变：",
      "参数类型要更加抽象。",
      "理论上是这样的，但是目前java还不支持这样，还是会将其当作overload而不是override看待。",
      "但是泛型中的参数不能这样理解，协变后的泛型不是原类型的子类型：",
      "List<Integer>不是List<Number>的子类型。",
      "也就是说Myclass<A>和Myclass<B>没有任何关系，无论A和B是否有关系。",
      "泛型中的通配符",
      "List<?>是一个不知道什么类型的列表",
      "使用通配符的典型场景：",
      "你实现的方法可以通过使用Object类的方法来实现",
      "当你的方法在泛型类中不依赖参数的类型时，如List.size,List.clear等",
      "List<Object>很可能使错误的用法，而正确的用法使List<>?>",
      "通配符下界：<? super A>，A的父类和自己都可以传入",
      "通配符下界：<? extends A>，A的子类和自己都可以传入",
      "List<Number>是List<？>的子类型",
      "List<Number>是List<？extends Object>的子类型",
      "List<Object>是List<？super String>的子类型",
      "八.委派（delegation）",
      "Interface Comparator<T>",
      "int compare(T o1, T o2)",
      "如果ADT需要实现比较大小的操作，或着要放入Collections或Arrays中进行排序，实现Comparator接口并重写compare方法",
      "Interface Comparable<T>",
      "让ADT实现Comparable接口，然后override compareTo方法",
      "区别：不用构建新的Comparator类，比较代码放在ADT内部",
      "委派（delegation）：一个对象请求另一个对象的功能，通过运行时动态绑定，实现对其他类中代码的复用",
      "显示委派：将对象作为参数传入",
      "隐式委派：放入实现类的内部",
      "client—calls—>Receiver—delegates to—>delegate",
      "问题：如果子类中只需要复用父类中的一小部分代码，那么就不需要继承，继承是没有意义的，而是需要动态请求一个对象，通过委派来实现代码的复用，避免大量无用的复用",
      "Composite over inheritance principle（CRP）：组合比继承更好，has_a、use_a比is_a更好。",
      "代理的类型：",
      "use：",
      "临时性的delegation，通过参数传入，方法运行完，两者就彻底脱离关系了",
      "association：",
      "永久性的delegation，在rep中定义一个属性存储要请求的对象，通过构造方法传参构造，但是传入后就不能修改了，就固定住了",
      "composition：",
      "更强的association，直接在写ADT的时候就将类型固定好了，不能通过传参设定，难以变化，可以理解为is_part_of",
      "Aggregation：",
      "更弱的association：不仅可以通过构造方法传参构造，还可以在后续的客户端代码处，通过特殊的设定方法，随时改变属性。"
    ],
    "sentences": [
      "一.复用的等级和形态",
      "源代码级别的复用：复制粘贴",
      "模块级别的复用：类与接口",
      "库级别的复用：API和包",
      "二.复用的类型",
      "白盒复用：复制并修改一段代码",
      "可以对代码的功能进行定制",
      "但是愮指导代码内部的实现逻辑",
      "增加了软件的复杂度",
      "黑盒复用：不能直接看到源代码",
      "只是利用别人提供的API",
      "更加简单",
      "但是适用性差",
      "三.源代码级别的复用",
      "粘贴代码",
      "四.模块级别的复用：类与接口",
      "继承：设计继承树",
      "可能会重写一堆方法（@Override）",
      "extend",
      "是类级别的复用",
      "代理：显式代理：传递对象给需要使用这些功能的对象",
      "隐式代理：将某个对象定义为这个对象的成员，去调用其方法",
      "是对象级别的复用",
      "五.库级别的复用：API和包",
      "库：开发者构造软件，去调用库中的功能",
      "框架：可以复用的骨架代码，可以定制功能到某个应用",
      "框架作为主程序去执行，执行过程中调用开发者自己写的程序",
      "六.框架级别的复用",
      "框架：一组抽象类和具体类，以及他们之间的关系",
      "开发者根据框架的规约，填充一些自己的代码进去，形成完整的代码",
      "白盒框架：通过继承进行框架的扩展",
      "黑盒框架：通过实现特定的接口、或者通过dialing来进行扩展",
      "七.行为子类型和LSP原则",
      "子类型多态：客户端可以用统一的方式来处理不同类型的对象",
      "使用父类的地方，都可以无条件用子类来代替",
      "静态类型检查（即编译器对子类型的要求）：子类型可以添加方法",
      "但是不可以删除",
      "子类型需要实现抽象类型中的所有未实现的方法",
      "子类型中重写的方法必须有相同或子类型的返回值候符合协变的返回值",
      "子类中重写的方法必须使用同样类型的参数或者符合逆变的参数",
      "子类型中重写的方法不能抛出额外的异常",
      "总结：更强的不变量、更弱的前置条件、更强的后置条件",
      "协变：返回值的类型和异常的类型要更加具体",
      "逆变：参数类型要更加抽象",
      "理论上是这样的",
      "但是目前java还不支持这样",
      "还是会将其当作overload而不是override看待",
      "但是泛型中的参数不能这样理解",
      "协变后的泛型不是原类型的子类型：List<Integer>不是List<Number>的子类型",
      "也就是说Myclass<A>和Myclass<B>没有任何关系",
      "无论A和B是否有关系",
      "泛型中的通配符",
      "List<?>是一个不知道什么类型的列表",
      "使用通配符的典型场景：你实现的方法可以通过使用Object类的方法来实现",
      "当你的方法在泛型类中不依赖参数的类型时",
      "如List.size,List.clear等",
      "List<Object>很可能使错误的用法",
      "而正确的用法使List<>?>",
      "通配符下界：<? super A>，A的父类和自己都可以传入",
      "通配符下界：<? extends A>",
      "A的子类和自己都可以传入",
      "List<Number>是List<？>的子类型",
      "List<Number>是List<？extends Object>的子类型",
      "List<Object>是List<？super String>的子类型",
      "八.委派（delegation）",
      "Interface Comparator<T>",
      "int compare(T o1, T o2)",
      "如果ADT需要实现比较大小的操作",
      "或着要放入Collections或Arrays中进行排序",
      "实现Comparator接口并重写compare方法",
      "Interface Comparable<T>",
      "让ADT实现Comparable接口",
      "然后override compareTo方法",
      "区别：不用构建新的Comparator类",
      "比较代码放在ADT内部",
      "委派（delegation）：一个对象请求另一个对象的功能",
      "通过运行时动态绑定",
      "实现对其他类中代码的复用",
      "显示委派：将对象作为参数传入",
      "隐式委派：放入实现类的内部",
      "client—calls—>Receiver—delegates to—>delegate",
      "问题：如果子类中只需要复用父类中的一小部分代码",
      "那么就不需要继承",
      "继承是没有意义的",
      "而是需要动态请求一个对象",
      "通过委派来实现代码的复用",
      "避免大量无用的复用",
      "Composite over inheritance principle（CRP）：组合比继承更好",
      "has_a、use_a比is_a更好",
      "代理的类型：use：临时性的delegation",
      "通过参数传入",
      "方法运行完",
      "两者就彻底脱离关系了",
      "association：永久性的delegation",
      "在rep中定义一个属性存储要请求的对象",
      "通过构造方法传参构造",
      "但是传入后就不能修改了",
      "就固定住了",
      "composition：更强的association",
      "直接在写ADT的时候就将类型固定好了",
      "不能通过传参设定",
      "难以变化",
      "可以理解为is_part_of",
      "Aggregation：更弱的association：不仅可以通过构造方法传参构造",
      "还可以在后续的客户端代码处",
      "通过特殊的设定方法",
      "随时改变属性"
    ],
    "codes": [
      "Object-->String\nThrowable-->IOException\n",
      "String-->Object\n"
    ],
    "date": "2021-06-27",
    "text": "一.复用的等级和形态\n源代码级别的复用：复制粘贴\n模块级别的复用：类与接口\n库级别的复用：API和包\n二.复用的类型\n白盒复用：复制并修改一段代码。可以对代码的功能进行定制，但是愮指导代码内部的实现逻辑，增加了软件的复杂度。\n黑盒复用：不能直接看到源代码，只是利用别人提供的API，更加简单，但是适用性差。\n三.源代码级别的复用\n粘贴代码\n四.模块级别的复用：类与接口\n继承：\n设计继承树\n可能会重写一堆方法（@Override）\nextend\n是类级别的复用\n代理：\n显式代理：传递对象给需要使用这些功能的对象\n隐式代理：将某个对象定义为这个对象的成员，去调用其方法\n是对象级别的复用\n五.库级别的复用：API和包\n库：开发者构造软件，去调用库中的功能\n框架：可以复用的骨架代码，可以定制功能到某个应用。框架作为主程序去执行，执行过程中调用开发者自己写的程序\n六.框架级别的复用\n框架：一组抽象类和具体类，以及他们之间的关系。开发者根据框架的规约，填充一些自己的代码进去，形成完整的代码\n白盒框架：通过继承进行框架的扩展\n黑盒框架：通过实现特定的接口、或者通过dialing来进行扩展\n七.行为子类型和LSP原则\n子类型多态：客户端可以用统一的方式来处理不同类型的对象。使用父类的地方，都可以无条件用子类来代替。\n静态类型检查（即编译器对子类型的要求）：\n子类型可以添加方法，但是不可以删除\n子类型需要实现抽象类型中的所有未实现的方法\n子类型中重写的方法必须有相同或子类型的返回值候符合协变的返回值\n子类中重写的方法必须使用同样类型的参数或者符合逆变的参数\n子类型中重写的方法不能抛出额外的异常\n总结：\n更强的不变量、更弱的前置条件、更强的后置条件\n协变：\n返回值的类型和异常的类型要更加具体。\n逆变：\n参数类型要更加抽象。\n理论上是这样的，但是目前java还不支持这样，还是会将其当作overload而不是override看待。\n但是泛型中的参数不能这样理解，协变后的泛型不是原类型的子类型：\nList<Integer>不是List<Number>的子类型。\n也就是说Myclass<A>和Myclass<B>没有任何关系，无论A和B是否有关系。\n泛型中的通配符\nList<?>是一个不知道什么类型的列表\n使用通配符的典型场景：\n你实现的方法可以通过使用Object类的方法来实现\n当你的方法在泛型类中不依赖参数的类型时，如List.size,List.clear等\nList<Object>很可能使错误的用法，而正确的用法使List<>?>\n通配符下界：<? super A>，A的父类和自己都可以传入\n通配符下界：<? extends A>，A的子类和自己都可以传入\nList<Number>是List<？>的子类型\nList<Number>是List<？extends Object>的子类型\nList<Object>是List<？super String>的子类型\n八.委派（delegation）\nInterface Comparator<T>\nint compare(T o1, T o2)\n如果ADT需要实现比较大小的操作，或着要放入Collections或Arrays中进行排序，实现Comparator接口并重写compare方法\nInterface Comparable<T>\n让ADT实现Comparable接口，然后override compareTo方法\n区别：不用构建新的Comparator类，比较代码放在ADT内部\n委派（delegation）：一个对象请求另一个对象的功能，通过运行时动态绑定，实现对其他类中代码的复用\n显示委派：将对象作为参数传入\n隐式委派：放入实现类的内部\nclient—calls—>Receiver—delegates to—>delegate\n问题：如果子类中只需要复用父类中的一小部分代码，那么就不需要继承，继承是没有意义的，而是需要动态请求一个对象，通过委派来实现代码的复用，避免大量无用的复用\nComposite over inheritance principle（CRP）：组合比继承更好，has_a、use_a比is_a更好。\n代理的类型：\nuse：\n临时性的delegation，通过参数传入，方法运行完，两者就彻底脱离关系了\nassociation：\n永久性的delegation，在rep中定义一个属性存储要请求的对象，通过构造方法传参构造，但是传入后就不能修改了，就固定住了\ncomposition：\n更强的association，直接在写ADT的时候就将类型固定好了，不能通过传参设定，难以变化，可以理解为is_part_of\nAggregation：\n更弱的association：不仅可以通过构造方法传参构造，还可以在后续的客户端代码处，通过特殊的设定方法，随时改变属性。\n"
  },
  {
    "head": "java中的泛型中的静态方法",
    "paragraphs": [
      "泛型方法",
      "泛型方法就是要在权限符和返回值之间声明泛型，通常用L、V、E、T、K等字母，然后就可以在这个方法的内部将其看作一种方法类型了",
      "在实验中遇到的问题",
      "本以是想用静态工厂方法定义一个初始化的方法，但是发信并不能使用类定义的泛型。",
      "静态方法不能直接使用类定义的泛型，也就是说如果要在静态方法中使用泛型的话，就必须将其声明为泛型方法。",
      "查阅的材料",
      "https://www.cnblogs.com/coprince/p/8603492.html"
    ],
    "sentences": [
      "泛型方法",
      "泛型方法就是要在权限符和返回值之间声明泛型",
      "通常用L、V、E、T、K等字母",
      "然后就可以在这个方法的内部将其看作一种方法类型了",
      "在实验中遇到的问题",
      "本以是想用静态工厂方法定义一个初始化的方法",
      "但是发信并不能使用类定义的泛型",
      "静态方法不能直接使用类定义的泛型",
      "也就是说如果要在静态方法中使用泛型的话",
      "就必须将其声明为泛型方法",
      "查阅的材料",
      "https://www.cnblogs.com/coprince/p/8603492.html"
    ],
    "codes": [
      "public static <L> IntervalSet<L> empty() throws Exception{\n\t\tthrow new RuntimeException();\n\t}\n"
    ],
    "date": "2021-06-15",
    "text": "泛型方法\n泛型方法就是要在权限符和返回值之间声明泛型，通常用L、V、E、T、K等字母，然后就可以在这个方法的内部将其看作一种方法类型了\n在实验中遇到的问题\n本以是想用静态工厂方法定义一个初始化的方法，但是发信并不能使用类定义的泛型。\n静态方法不能直接使用类定义的泛型，也就是说如果要在静态方法中使用泛型的话，就必须将其声明为泛型方法。\n查阅的材料\nhttps://www.cnblogs.com/coprince/p/8603492.html\n"
  },
  {
    "head": "HIT软件构造----Reading 6: Specifications（from MIT SoftwareConstruction）",
    "paragraphs": [
      "Specifications",
      "原文链接",
      "http://web.mit.edu/6.031/www/sp20/classes/06-specifications/",
      "Introduction",
      "The specification acts as a contract: the implementer is responsible for meeting the contract, and a client that uses the method can rely on the contract.",
      "同老师上课讲法，spec就是客户端和开发者之间的合同，开发者必须按照合同实现方法，用户必须按照合同去使用方法。",
      "本文将讨论",
      "preconditions、postconditions、exceptions",
      "三个重要概念",
      "Java needed for this reading",
      "需要我们了解exception的概念",
      "try、catch的用法",
      "很简单的基本概念，用过java的同学应该都知道。",
      "Behavioral equivalence",
      "所谓的行为等价性：whether we could substitute one implementation for the other。即我们是否可以用一段代码去代替另一段代码。",
      "如下面两个小例子：",
      "两个方法都是在一个数组中寻找是否存在某个数，如果存在则返回下标，如果不存在则返回-1。",
      "我们的问题是：是否能够用方法2来代替方法1呢？即这两个方法是否具有行为等价性呢？",
      "答案是不能的，如果有待查找的数字多次出现在了这个数组中，第一个方法会返回第一次出现时的下标，第二个方法会返回最小或者最大的下标，取决于谁更加靠近端点。",
      "而如果我们加上一个限定条件：只有一个待寻找的数存在在数组当中的话，那么两个方法的返回值就是唯一的，在这个条件的约束下，两个方法具有行为等价性。",
      "行为等价性的定义是从客户端的角度来说的，如果一个方法能够替换另一个，则两方法具有行为等价性。",
      "博客中给出的习题，复习时均应阅读：",
      "spec和test（test-first-programming）一定要先写好",
      "两句很有启发的话：",
      "strong precondition hides their potential differences in behavior.",
      "前置条件太强的话，会盖住潜在的行为不同性，两个看起来不同的方法在很强的前置条件下会具有行为等价性。",
      "== a weak postcondition permits their differences in behavior==",
      "前置条件太弱，就会允许一些行为上的差异，但是两方法仍具有行为等价性。",
      "Why specifications?",
      "spec可以帮助我们使程序更好理解，我们要了解一个方法能干什么，只读spec即可，不必费心神去读源代码。也可以帮助我们更快的确定bug的位置。",
      "spec不仅像用户和实现者之间的合同，也像用户和实现者之间的防火墙。",
      "implementer可以用任何的数据结构和算法来实现spec要求的功能，而不必将细节暴露给客户端。",
      "这样的防火墙带来的好处就是将客户端和实现者解耦（decoupling）。",
      "Specification structure",
      "spec的构成：",
      "1.方法名，参数类型，返回值类型，抛出异常的类型",
      "2.requires（pre）",
      "3.effects（post）",
      "满足precodition是客户端的义务。",
      "而满足postcondition是实现者的义务。",
      "参数类型和requires都是precondition。",
      "返回值类型和抛出异常的类型和effects都是postcondition。",
      "前置条件满足，后置条件必须满足",
      "前置条件不满足，后置条件随意，实现者可以做任何事（即使是不道德的事情）",
      "When our precondition is violated, the client has a bug. We can make that bug easier to find and fix by failing fast, even though we are not obligated to do so.",
      "自律的要求（即使没有任何人要求我们这么做）：抛出异常，fail fast（让程序尽快死掉），检查bug。",
      "Specifications in Java",
      "@param",
      "@return",
      "@throw",
      "用这样的语法可以自动生成帮助手册。",
      "spec的注释第一行两个星号",
      "不用加参数类型或着返回值类型",
      "没有@requires 和 @effects这样的关键字",
      "** 什么是spce不应该说的： **",
      "局部变量，私有属性，算法实现的任何细节，实现者应该保证细节对读代码的人不可见。",
      "Do not allow null references",
      "原始类型不能被赋值为null：（8种primitives）",
      "byte、short、int、long、float、double、boolean、char。",
      "你无法访问null对象的任何属性和方法。例如 String name = null;",
      "name.length() -----------------> throws NullPointException",
      "null通常是危险的，所以spec除非显示说明可以接受null，否则null是不能做为参数和返回值的。",
      "所以默认任何spec都有一个precondition：参数不能是null，也都有一个postcondition：返回值不能是null！！！",
      "Avoid null !!!",
      "建议显示的使用@NonNull关键字来说明禁止出现null，这样编译器就会自动检查。",
      "void也是一个值，如果返回类型是void，只能用return;",
      "null.length()会导致NullPointerException",
      "关键：只要没提参数或者返回值可以是null，就默认不能是null。",
      "Include emptiness",
      "null和emptiness的差别：",
      "null和空串的差别，类似于形式语言与自动机那门课中，",
      "\\phi 和\\epsilon",
      "的区别。",
      "List.of()返回一个空列表。",
      "只要没说可以用null，就绝对不能用null。",
      "前件不成立，后件无条件成立。",
      "Testing and specifications",
      "Testing units",
      "集成测试：一个测试用例结合各个模块的功能。",
      "不应该使测试用例违反前置条件，否则测试没有意义。",
      "如果编译器能检查出某种错误，那么它不应该被写入spec，那是多余的。",
      "Specifications for mutating methods",
      "后置条件存在的side-effects，可能会修改某个内部的值。",
      "pre必须限制list1不等于list2，否则有可能算法无法停止。",
      "就像null如果不特殊说明就被禁止出现在参数和返回值中一样，mutation不特殊说明也被禁止出现在参数和返回值中。",
      "Exceptions",
      "出现不应该出现的情况时，以往的程序员往往返回一个特殊值，如-1，null，9/9/99等，然而这样时有问题的，我们不仅容易忘了这么做，而且还会导致我们无法发现程序中存在的bug。",
      "Java的异常处理机制，提供以下两种做法:",
      "用throw抛出异常",
      "用try catch 处理异常",
      "例题：",
      "try必须跟catch或者finally，否则静态检车都过不去。",
      "try和catch会把变量的作用域分开，在try中声明的变量到这个大括号外面就直接被释放了，不再存在，不能对它赋值或者引用。",
      "空的catch体是一个很坏的编程习惯，尽量不要这么去做。它捕获了异常，但又什么都不做，让程序继续执行下去。",
      "chained exception，将原来捕获的异常作为新的异常的构造器的参数传入，构造一个新的异常，然后继续抛出。",
      "Checked and unchecked exceptions",
      "从上一个部分可以看出异常机制的两个重要理由：特殊的返回值和bug检测。有这样一通用的规则：用checked exceptions来标识特殊值，用unchecked exceptions来标识bug。",
      "checked exceptions:需要在函数声明中写throw XXXXException，这样编译器就会进行静态检查。",
      "Exception之下有一支全是checked exception",
      "RuntimeException下面全是unchecked exception",
      "当用catch，你最好用最细分的exception类型，而不是简单的用Exception或者RuntimeException，可能会影响静态检查或者隐藏bug。",
      "unchecked的exception最好不要抛出来，而是直接打印信息，方便我们找到bug所在。",
      "checked的exception要抛给上一层，告诉我们需要处理特殊值了（情况不符合）。抛出的异常就类似于我们以往的编程工作中所写的函数所返回的特殊值（例如遇到找不到的情况就返回-1，并在main函数中检测这个特殊值）。",
      "可以把抛特殊值等价于抛异常。",
      "Error是Unchecked Exception，但是error不是exception的子类，所以无法被try，catch捕获。而且直接自动打印栈信息。",
      "checked exception：@throws 和 throws都要写",
      "unchecked exception：只用写@throws"
    ],
    "sentences": [
      "Specifications",
      "原文链接",
      "http://web.mit.edu/6.031/www/sp20/classes/06-specifications/",
      "Introduction",
      "The specification acts as a contract: the implementer is responsible for meeting the contract, and a client that uses the method can rely on the contract.同老师上课讲法",
      "spec就是客户端和开发者之间的合同",
      "开发者必须按照合同实现方法",
      "用户必须按照合同去使用方法",
      "本文将讨论",
      "preconditions、postconditions、exceptions",
      "三个重要概念",
      "Java needed for this reading",
      "需要我们了解exception的概念",
      "try、catch的用法",
      "很简单的基本概念，用过java的同学应该都知道",
      "Behavioral equivalence",
      "所谓的行为等价性：whether we could substitute one implementation for the other",
      "即我们是否可以用一段代码去代替另一段代码",
      "如下面两个小例子：两个方法都是在一个数组中寻找是否存在某个数",
      "如果存在则返回下标",
      "如果不存在则返回-1",
      "我们的问题是：是否能够用方法2来代替方法1呢？即这两个方法是否具有行为等价性呢？",
      "答案是不能的",
      "如果有待查找的数字多次出现在了这个数组中",
      "第一个方法会返回第一次出现时的下标",
      "第二个方法会返回最小或者最大的下标",
      "取决于谁更加靠近端点",
      "而如果我们加上一个限定条件：只有一个待寻找的数存在在数组当中的话",
      "那么两个方法的返回值就是唯一的",
      "在这个条件的约束下",
      "两个方法具有行为等价性",
      "行为等价性的定义是从客户端的角度来说的",
      "如果一个方法能够替换另一个",
      "则两方法具有行为等价性",
      "博客中给出的习题",
      "复习时均应阅读：spec和test（test-first-programming）一定要先写好",
      "两句很有启发的话：strong precondition hides their potential differences in behavior.前置条件太强的话",
      "会盖住潜在的行为不同性",
      "两个看起来不同的方法在很强的前置条件下会具有行为等价性",
      "== a weak postcondition permits their differences in behavior==",
      "前置条件太弱",
      "就会允许一些行为上的差异",
      "但是两方法仍具有行为等价性",
      "Why specifications?",
      "spec可以帮助我们使程序更好理解",
      "我们要了解一个方法能干什么",
      "只读spec即可",
      "不必费心神去读源代码",
      "也可以帮助我们更快的确定bug的位置",
      "spec不仅像用户和实现者之间的合同",
      "也像用户和实现者之间的防火墙",
      "implementer可以用任何的数据结构和算法来实现spec要求的功能",
      "而不必将细节暴露给客户端",
      "这样的防火墙带来的好处就是将客户端和实现者解耦（decoupling）",
      "Specification structure",
      "spec的构成：1.方法名",
      "参数类型",
      "返回值类型",
      "抛出异常的类型",
      "2.requires（pre）",
      "3.effects（post）",
      "满足precodition是客户端的义务",
      "而满足postcondition是实现者的义务",
      "参数类型和requires都是precondition",
      "返回值类型和抛出异常的类型和effects都是postcondition",
      "前置条件满足，后置条件必须满足",
      "前置条件不满足",
      "后置条件随意",
      "实现者可以做任何事（即使是不道德的事情）",
      "When our precondition is violated, the client has a bug. We can make that bug easier to find and fix by failing fast, even though we are not obligated to do so.自律的要求（即使没有任何人要求我们这么做）：抛出异常",
      "fail fast（让程序尽快死掉）",
      "检查bug",
      "Specifications in Java",
      "@param",
      "@return",
      "@throw",
      "用这样的语法可以自动生成帮助手册",
      "spec的注释第一行两个星号",
      "不用加参数类型或着返回值类型",
      "没有@requires 和 @effects这样的关键字",
      "** 什么是spce不应该说的： **",
      "局部变量",
      "私有属性",
      "算法实现的任何细节",
      "实现者应该保证细节对读代码的人不可见",
      "Do not allow null references",
      "原始类型不能被赋值为null：（8种primitives）",
      "byte、short、int、long、float、double、boolean、char",
      "你无法访问null对象的任何属性和方法",
      "例如 String name = null;name.length() -----------------> throws NullPointException",
      "null通常是危险的",
      "所以spec除非显示说明可以接受null",
      "否则null是不能做为参数和返回值的",
      "所以默认任何spec都有一个precondition：参数不能是null",
      "也都有一个postcondition：返回值不能是null！！！",
      "Avoid null !!!",
      "建议显示的使用@NonNull关键字来说明禁止出现null",
      "这样编译器就会自动检查",
      "void也是一个值",
      "如果返回类型是void",
      "只能用return;null.length()会导致NullPointerException",
      "关键：只要没提参数或者返回值可以是null",
      "就默认不能是null",
      "Include emptiness",
      "null和emptiness的差别：null和空串的差别",
      "类似于形式语言与自动机那门课中",
      "\\phi 和\\epsilon",
      "的区别",
      "List.of()返回一个空列表",
      "只要没说可以用null，就绝对不能用null",
      "前件不成立，后件无条件成立",
      "Testing and specifications",
      "Testing units",
      "集成测试：一个测试用例结合各个模块的功能",
      "不应该使测试用例违反前置条件，否则测试没有意义",
      "如果编译器能检查出某种错误",
      "那么它不应该被写入spec",
      "那是多余的",
      "Specifications for mutating methods",
      "后置条件存在的side-effects",
      "可能会修改某个内部的值",
      "pre必须限制list1不等于list2",
      "否则有可能算法无法停止",
      "就像null如果不特殊说明就被禁止出现在参数和返回值中一样",
      "mutation不特殊说明也被禁止出现在参数和返回值中",
      "Exceptions",
      "出现不应该出现的情况时",
      "以往的程序员往往返回一个特殊值",
      "如-1",
      "null",
      "9/9/99等",
      "然而这样时有问题的",
      "我们不仅容易忘了这么做",
      "而且还会导致我们无法发现程序中存在的bug",
      "Java的异常处理机制",
      "提供以下两种做法:用throw抛出异常",
      "用try catch 处理异常",
      "例题：try必须跟catch或者finally",
      "否则静态检车都过不去",
      "try和catch会把变量的作用域分开",
      "在try中声明的变量到这个大括号外面就直接被释放了",
      "不再存在",
      "不能对它赋值或者引用",
      "空的catch体是一个很坏的编程习惯，尽量不要这么去做",
      "它捕获了异常，但又什么都不做，让程序继续执行下去",
      "chained exception",
      "将原来捕获的异常作为新的异常的构造器的参数传入",
      "构造一个新的异常",
      "然后继续抛出",
      "Checked and unchecked exceptions",
      "从上一个部分可以看出异常机制的两个重要理由：特殊的返回值和bug检测",
      "有这样一通用的规则：用checked exceptions来标识特殊值",
      "用unchecked exceptions来标识bug",
      "checked exceptions:需要在函数声明中写throw XXXXException",
      "这样编译器就会进行静态检查",
      "Exception之下有一支全是checked exception",
      "RuntimeException下面全是unchecked exception",
      "当用catch",
      "你最好用最细分的exception类型",
      "而不是简单的用Exception或者RuntimeException",
      "可能会影响静态检查或者隐藏bug",
      "unchecked的exception最好不要抛出来",
      "而是直接打印信息",
      "方便我们找到bug所在",
      "checked的exception要抛给上一层",
      "告诉我们需要处理特殊值了（情况不符合）",
      "抛出的异常就类似于我们以往的编程工作中所写的函数所返回的特殊值（例如遇到找不到的情况就返回-1",
      "并在main函数中检测这个特殊值）",
      "可以把抛特殊值等价于抛异常",
      "Error是Unchecked Exception",
      "但是error不是exception的子类",
      "所以无法被try",
      "catch捕获",
      "而且直接自动打印栈信息",
      "checked exception：@throws 和 throws都要写",
      "unchecked exception：只用写@throws"
    ],
    "codes": [
      "static int find(int[] arr, int val) {\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] == val) return i;\n    }\n    return -1;\n}\n",
      "static int find(int[] arr, int val) {\n    for (int i = 0, j = arr.length-1; i <= j; i++, j--) {\n        if (arr[i] == val) return i;\n        if (arr[j] == val) return j;\n    }\n    return -1;\n}\n",
      "static int find(int[] arr, int val)\n\nrequires:\nval occurs exactly once in arr\neffects:\nreturns index i such that arr[i] = val\n",
      "IndexOutOfBoundsException\nNullPointException\nArithmeticException\nNumberFormatException\n",
      "Summary",
      "Safe from bugs",
      "Easy to understand",
      "Ready for change"
    ],
    "date": "2021-05-24",
    "text": "Specifications\n原文链接\nhttp://web.mit.edu/6.031/www/sp20/classes/06-specifications/\nIntroduction\nThe specification acts as a contract: the implementer is responsible for meeting the contract, and a client that uses the method can rely on the contract.\n同老师上课讲法，spec就是客户端和开发者之间的合同，开发者必须按照合同实现方法，用户必须按照合同去使用方法。\n本文将讨论\npreconditions、postconditions、exceptions\n三个重要概念\nJava needed for this reading\n需要我们了解exception的概念\ntry、catch的用法\n很简单的基本概念，用过java的同学应该都知道。\nBehavioral equivalence\n所谓的行为等价性：whether we could substitute one implementation for the other。即我们是否可以用一段代码去代替另一段代码。\n如下面两个小例子：\n两个方法都是在一个数组中寻找是否存在某个数，如果存在则返回下标，如果不存在则返回-1。\n我们的问题是：是否能够用方法2来代替方法1呢？即这两个方法是否具有行为等价性呢？\n答案是不能的，如果有待查找的数字多次出现在了这个数组中，第一个方法会返回第一次出现时的下标，第二个方法会返回最小或者最大的下标，取决于谁更加靠近端点。\n而如果我们加上一个限定条件：只有一个待寻找的数存在在数组当中的话，那么两个方法的返回值就是唯一的，在这个条件的约束下，两个方法具有行为等价性。\n行为等价性的定义是从客户端的角度来说的，如果一个方法能够替换另一个，则两方法具有行为等价性。\n博客中给出的习题，复习时均应阅读：\nspec和test（test-first-programming）一定要先写好\n两句很有启发的话：\nstrong precondition hides their potential differences in behavior.\n前置条件太强的话，会盖住潜在的行为不同性，两个看起来不同的方法在很强的前置条件下会具有行为等价性。\n== a weak postcondition permits their differences in behavior==\n前置条件太弱，就会允许一些行为上的差异，但是两方法仍具有行为等价性。\nWhy specifications?\nspec可以帮助我们使程序更好理解，我们要了解一个方法能干什么，只读spec即可，不必费心神去读源代码。也可以帮助我们更快的确定bug的位置。\nspec不仅像用户和实现者之间的合同，也像用户和实现者之间的防火墙。\nimplementer可以用任何的数据结构和算法来实现spec要求的功能，而不必将细节暴露给客户端。\n这样的防火墙带来的好处就是将客户端和实现者解耦（decoupling）。\nSpecification structure\nspec的构成：\n1.方法名，参数类型，返回值类型，抛出异常的类型\n2.requires（pre）\n3.effects（post）\n满足precodition是客户端的义务。\n而满足postcondition是实现者的义务。\n参数类型和requires都是precondition。\n返回值类型和抛出异常的类型和effects都是postcondition。\n前置条件满足，后置条件必须满足\n前置条件不满足，后置条件随意，实现者可以做任何事（即使是不道德的事情）\nWhen our precondition is violated, the client has a bug. We can make that bug easier to find and fix by failing fast, even though we are not obligated to do so.\n自律的要求（即使没有任何人要求我们这么做）：抛出异常，fail fast（让程序尽快死掉），检查bug。\nSpecifications in Java\n@param\n@return\n@throw\n用这样的语法可以自动生成帮助手册。\nspec的注释第一行两个星号\n不用加参数类型或着返回值类型\n没有@requires 和 @effects这样的关键字\n** 什么是spce不应该说的： **\n局部变量，私有属性，算法实现的任何细节，实现者应该保证细节对读代码的人不可见。\nDo not allow null references\n原始类型不能被赋值为null：（8种primitives）\nbyte、short、int、long、float、double、boolean、char。\n你无法访问null对象的任何属性和方法。例如 String name = null;\nname.length() -----------------> throws NullPointException\nnull通常是危险的，所以spec除非显示说明可以接受null，否则null是不能做为参数和返回值的。\n所以默认任何spec都有一个precondition：参数不能是null，也都有一个postcondition：返回值不能是null！！！\nAvoid null !!!\n建议显示的使用@NonNull关键字来说明禁止出现null，这样编译器就会自动检查。\nvoid也是一个值，如果返回类型是void，只能用return;\nnull.length()会导致NullPointerException\n关键：只要没提参数或者返回值可以是null，就默认不能是null。\nInclude emptiness\nnull和emptiness的差别：\nnull和空串的差别，类似于形式语言与自动机那门课中，\n\\phi 和\\epsilon\n的区别。\nList.of()返回一个空列表。\n只要没说可以用null，就绝对不能用null。\n前件不成立，后件无条件成立。\nTesting and specifications\nTesting units\n集成测试：一个测试用例结合各个模块的功能。\n不应该使测试用例违反前置条件，否则测试没有意义。\n如果编译器能检查出某种错误，那么它不应该被写入spec，那是多余的。\nSpecifications for mutating methods\n后置条件存在的side-effects，可能会修改某个内部的值。\npre必须限制list1不等于list2，否则有可能算法无法停止。\n就像null如果不特殊说明就被禁止出现在参数和返回值中一样，mutation不特殊说明也被禁止出现在参数和返回值中。\nExceptions\n出现不应该出现的情况时，以往的程序员往往返回一个特殊值，如-1，null，9/9/99等，然而这样时有问题的，我们不仅容易忘了这么做，而且还会导致我们无法发现程序中存在的bug。\nJava的异常处理机制，提供以下两种做法:\n用throw抛出异常\n用try catch 处理异常\n例题：\ntry必须跟catch或者finally，否则静态检车都过不去。\ntry和catch会把变量的作用域分开，在try中声明的变量到这个大括号外面就直接被释放了，不再存在，不能对它赋值或者引用。\n空的catch体是一个很坏的编程习惯，尽量不要这么去做。它捕获了异常，但又什么都不做，让程序继续执行下去。\nchained exception，将原来捕获的异常作为新的异常的构造器的参数传入，构造一个新的异常，然后继续抛出。\nChecked and unchecked exceptions\n从上一个部分可以看出异常机制的两个重要理由：特殊的返回值和bug检测。有这样一通用的规则：用checked exceptions来标识特殊值，用unchecked exceptions来标识bug。\nchecked exceptions:需要在函数声明中写throw XXXXException，这样编译器就会进行静态检查。\nException之下有一支全是checked exception\nRuntimeException下面全是unchecked exception\n当用catch，你最好用最细分的exception类型，而不是简单的用Exception或者RuntimeException，可能会影响静态检查或者隐藏bug。\nunchecked的exception最好不要抛出来，而是直接打印信息，方便我们找到bug所在。\nchecked的exception要抛给上一层，告诉我们需要处理特殊值了（情况不符合）。抛出的异常就类似于我们以往的编程工作中所写的函数所返回的特殊值（例如遇到找不到的情况就返回-1，并在main函数中检测这个特殊值）。\n可以把抛特殊值等价于抛异常。\nError是Unchecked Exception，但是error不是exception的子类，所以无法被try，catch捕获。而且直接自动打印栈信息。\nchecked exception：@throws 和 throws都要写\nunchecked exception：只用写@throws\n"
  },
  {
    "head": "Java正则表达式的使用",
    "paragraphs": [
      "写在前面",
      "学过形式语言与自动机的小伙伴对regex应该都不陌生了，我们简单的回顾几个离散中的概念，",
      "(a)^{*}",
      "代表的是克林闭包，代表a可以重复",
      "(0, \\infty)",
      "次，而",
      "(a)^{+}",
      "代表正闭包，说明a最少出现一次。",
      "Java中regex的应用",
      "如果想匹配一段特定的串，直接输入即可",
      "数字：\\d 或者 [0-9]",
      "字母：\\w 或者 [a-zA-Z]",
      "空白：\\s",
      "重复0次以上：*",
      "重复1次以上：+",
      "0次或1次：？",
      "其他都用处不大，可以大概找手册看一遍，知道有那些东西，用的时候再去查就可以。",
      "Attention：在java 正则表达式中\\代表反斜杠，所以转义字符前的那个斜杠要输入\\才行，也就是说如果我们要去比配数字，我们要使用\\\\d+，而不是\\d+",
      "实际用法",
      "字符串本身就有一个",
      "matches",
      "我们随意选举一个字符串对象实验，可以发现matches方法返回的是一个Boolean值，如果能够匹配给出的regex就返回true，这就是",
      "最简单也是最实用",
      "的方法了。",
      "更加复杂的用法",
      "前面的matches方法已经非常使用了，但是有时候我们需要从大型的文本中去匹配一些对象，此时matches方法就不好使了，所以我们需要结合java提供的Pattern和Matcher类来对文本进行读取。",
      "我们首先使用文本读取的方法将字符串读入到一个字符串对象中。",
      "现生成一个Pattern对象，注意，这个对象只能由工厂方法创建即:",
      "然后再括号内输入你想要的正则表达式即可。",
      "接下来创建一个matcher对象，matcher对象的创建是根据之前我们已经创建的Pattern对象直接创建的：",
      "其参数是我们想要匹配的文本，即我们之前从文本文件中读取的字符串，我们将其输入在括号中即可。",
      "接下来主要有三个方法：",
      "matches：只有整个字符串都符合regex，才返回true",
      "lookingAt：从串的最前面开始匹配，有能够匹配的上的，就返回true",
      "find：只要整个串中有匹配的地方，就返回true",
      "当我们用以上三个方法找到对应的匹配时，用**",
      "m.group()",
      "**方法就可以得到匹配的字符串啦。这就是regex最简单的应用了。"
    ],
    "sentences": [
      "写在前面",
      "学过形式语言与自动机的小伙伴对regex应该都不陌生了",
      "我们简单的回顾几个离散中的概念",
      "(a)^{*}",
      "代表的是克林闭包，代表a可以重复",
      "(0, \\infty)",
      "次，而",
      "(a)^{+}",
      "代表正闭包，说明a最少出现一次",
      "Java中regex的应用",
      "如果想匹配一段特定的串，直接输入即可",
      "数字：\\d 或者 [0-9]",
      "字母：\\w 或者 [a-zA-Z]",
      "空白：\\s",
      "重复0次以上：*",
      "重复1次以上：+",
      "0次或1次：？",
      "其他都用处不大",
      "可以大概找手册看一遍",
      "知道有那些东西",
      "用的时候再去查就可以",
      "Attention：在java 正则表达式中\\代表反斜杠",
      "所以转义字符前的那个斜杠要输入\\才行",
      "也就是说如果我们要去比配数字",
      "我们要使用\\\\d+",
      "而不是\\d+",
      "实际用法",
      "字符串本身就有一个",
      "matches",
      "我们随意选举一个字符串对象实验",
      "可以发现matches方法返回的是一个Boolean值",
      "如果能够匹配给出的regex就返回true",
      "这就是",
      "最简单也是最实用",
      "的方法了",
      "更加复杂的用法",
      "前面的matches方法已经非常使用了",
      "但是有时候我们需要从大型的文本中去匹配一些对象",
      "此时matches方法就不好使了",
      "所以我们需要结合java提供的Pattern和Matcher类来对文本进行读取",
      "我们首先使用文本读取的方法将字符串读入到一个字符串对象中",
      "现生成一个Pattern对象",
      "注意",
      "这个对象只能由工厂方法创建即:然后再括号内输入你想要的正则表达式即可",
      "接下来创建一个matcher对象",
      "matcher对象的创建是根据之前我们已经创建的Pattern对象直接创建的：其参数是我们想要匹配的文本",
      "即我们之前从文本文件中读取的字符串",
      "我们将其输入在括号中即可",
      "接下来主要有三个方法：matches：只有整个字符串都符合regex",
      "才返回true",
      "lookingAt：从串的最前面开始匹配",
      "有能够匹配的上的",
      "就返回true",
      "find：只要整个串中有匹配的地方，就返回true",
      "当我们用以上三个方法找到对应的匹配时，用**",
      "m.group()",
      "**方法就可以得到匹配的字符串啦",
      "这就是regex最简单的应用了"
    ],
    "codes": [
      "Pattern regex = Pattern.compile()\n"
    ],
    "date": "2021-07-02",
    "text": "写在前面\n学过形式语言与自动机的小伙伴对regex应该都不陌生了，我们简单的回顾几个离散中的概念，\n(a)^{*}\n代表的是克林闭包，代表a可以重复\n(0, \\infty)\n次，而\n(a)^{+}\n代表正闭包，说明a最少出现一次。\nJava中regex的应用\n如果想匹配一段特定的串，直接输入即可\n数字：\\d 或者 [0-9]\n字母：\\w 或者 [a-zA-Z]\n空白：\\s\n重复0次以上：*\n重复1次以上：+\n0次或1次：？\n其他都用处不大，可以大概找手册看一遍，知道有那些东西，用的时候再去查就可以。\nAttention：在java 正则表达式中\\代表反斜杠，所以转义字符前的那个斜杠要输入\\才行，也就是说如果我们要去比配数字，我们要使用\\\\d+，而不是\\d+\n实际用法\n字符串本身就有一个\nmatches\n我们随意选举一个字符串对象实验，可以发现matches方法返回的是一个Boolean值，如果能够匹配给出的regex就返回true，这就是\n最简单也是最实用\n的方法了。\n更加复杂的用法\n前面的matches方法已经非常使用了，但是有时候我们需要从大型的文本中去匹配一些对象，此时matches方法就不好使了，所以我们需要结合java提供的Pattern和Matcher类来对文本进行读取。\n我们首先使用文本读取的方法将字符串读入到一个字符串对象中。\n现生成一个Pattern对象，注意，这个对象只能由工厂方法创建即:\n然后再括号内输入你想要的正则表达式即可。\n接下来创建一个matcher对象，matcher对象的创建是根据之前我们已经创建的Pattern对象直接创建的：\n其参数是我们想要匹配的文本，即我们之前从文本文件中读取的字符串，我们将其输入在括号中即可。\n接下来主要有三个方法：\nmatches：只有整个字符串都符合regex，才返回true\nlookingAt：从串的最前面开始匹配，有能够匹配的上的，就返回true\nfind：只要整个串中有匹配的地方，就返回true\n当我们用以上三个方法找到对应的匹配时，用**\nm.group()\n**方法就可以得到匹配的字符串啦。这就是regex最简单的应用了。\n"
  },
  {
    "head": "停车场管理系统-----软件构造习题课代码分析",
    "paragraphs": [
      "题目描述：",
      "软件框架：",
      "ADT设计：",
      "静态工厂方法",
      "创建一个新的停车场。",
      "停车：",
      "驶离停车场：",
      "停车场状态:",
      "以上是核心方法，其他辅助性的方法不再说明。",
      "方法的实现都十分简单，并不是软件构造课的主要内容，故对其逻辑不一一说明。",
      "面向复用的设计：",
      "相机场等，本质上和停车场的功能完全一样，所以我们设计的ADT如果有很好的复用性的话，只需经过少量的扩展，就可以实现一个更加复杂的场景下的类。",
      "我们首先将Car扩展成Parkable，即停放的东西不止可以是车，还可以是飞机、摩托车等。",
      "针对Parkable，设计一组方法来描述其行为。",
      "为了避免在客户端代码使用new操作，我们使用静态工厂方法来代替new操作。",
      "接着，针对各种交通工具进行方法的实现。",
      "如，Car类：",
      "工厂方法：",
      "针对不同的类，提供工厂方法来创建实例对象，将对象类型作为一个参数，定义到工厂方法中去，String type，这样，在每次创建时根据不同的类型来创建不同类型的实例。",
      "State设计模式：",
      "创建State接口，实现两个状态，一种是停着（parking)，一种是在路上（depart）",
      "让Parkable拥有一个属性State，能够管理自己的状态。",
      "Decorator设计模式：",
      "建立一个用于装饰的基础类ComplexParkingField，实现ParkingField接口，其中的所",
      "有方法都delegate到未装饰之前的对象。",
      "然后，建立一个具体装饰类ParkingFieldWithCompany，也实现ParkingField接口，继",
      "承自ComplexParkingField类，增加了rep（公司信息），对需要变化的方法进行扩展",
      "（使用super.xxx()调用基础功能）。修改构造函数，增加company参数。",
      "visitor设计模式：",
      "扩展其他功能：",
      "考虑将来对 ParkingField 的功能扩展。例如要扩展的一个功能是统计停车场当前时刻占",
      "用比例(=已停车的车位数量总车位数)。",
      "建立 visitor 接口 ParkingVisitor，只有一个方法 double visit(parkingField",
      "pf)。",
      "建立其子类 PercentageVisitor，实现该 visit 方法，调用 pf 的方法获得 pf 的内",
      "部表示，进行计算。",
      "在 ParkingField 接口中增加 accept(ParkingVisitor pv)方法，其实现很简单：",
      "pv.visit(this)。",
      "如果还有其他功能，可以继续定义visitor进行扩展。"
    ],
    "sentences": [
      "题目描述：软件框架：ADT设计：静态工厂方法",
      "创建一个新的停车场",
      "停车：驶离停车场：停车场状态:以上是核心方法",
      "其他辅助性的方法不再说明",
      "方法的实现都十分简单",
      "并不是软件构造课的主要内容",
      "故对其逻辑不一一说明",
      "面向复用的设计：相机场等",
      "本质上和停车场的功能完全一样",
      "所以我们设计的ADT如果有很好的复用性的话",
      "只需经过少量的扩展",
      "就可以实现一个更加复杂的场景下的类",
      "我们首先将Car扩展成Parkable",
      "即停放的东西不止可以是车",
      "还可以是飞机、摩托车等",
      "针对Parkable，设计一组方法来描述其行为",
      "为了避免在客户端代码使用new操作",
      "我们使用静态工厂方法来代替new操作",
      "接着，针对各种交通工具进行方法的实现",
      "如",
      "Car类：工厂方法：针对不同的类",
      "提供工厂方法来创建实例对象",
      "将对象类型作为一个参数",
      "定义到工厂方法中去",
      "String type",
      "这样",
      "在每次创建时根据不同的类型来创建不同类型的实例",
      "State设计模式：创建State接口",
      "实现两个状态",
      "一种是停着（parking)",
      "一种是在路上（depart）",
      "让Parkable拥有一个属性State，能够管理自己的状态",
      "Decorator设计模式：建立一个用于装饰的基础类ComplexParkingField",
      "实现ParkingField接口",
      "其中的所",
      "有方法都delegate到未装饰之前的对象",
      "然后",
      "建立一个具体装饰类ParkingFieldWithCompany",
      "也实现ParkingField接口",
      "继",
      "承自ComplexParkingField类",
      "增加了rep（公司信息）",
      "对需要变化的方法进行扩展",
      "（使用super.xxx()调用基础功能）",
      "修改构造函数，增加company参数",
      "visitor设计模式：扩展其他功能：考虑将来对 ParkingField 的功能扩展",
      "例如要扩展的一个功能是统计停车场当前时刻占",
      "用比例(=已停车的车位数量总车位数)",
      "建立 visitor 接口 ParkingVisitor",
      "只有一个方法 double visit(parkingField",
      "pf)",
      "建立其子类 PercentageVisitor",
      "实现该 visit 方法",
      "调用 pf 的方法获得 pf 的内",
      "部表示，进行计算",
      "在 ParkingField 接口中增加 accept(ParkingVisitor pv)方法",
      "其实现很简单：pv.visit(this)",
      "如果还有其他功能，可以继续定义visitor进行扩展"
    ],
    "codes": [
      "\t/**\n\t * 创建一个新的停车场\n\t * \n\t * @param nos 各停车位的编号，均为自然数，且无重复\n\t * @param widths 各停车位的宽度，包含的元素数量=nos中元素数量 且>=5 \n\t * @return 一个停车场对象，包含了widths.length个车位，各车位的宽度与nos中相应数字一致，且各车位上均未有停车\n\t * @throws 如果违反nos和widths不合法\n\t */\n\tpublic static ParkingField create(int[] nos, int[] widths) throws Exception {\n\t\treturn new ConcreteParkingField(nos, widths);\n\t}\n",
      "/**\n\t   * 在某个停车位上停车\n\t   * 车牌号为plate的车辆，之前没停在车场，执行后停在了车位号为num的车位上，该车位宽度大于车宽度\n\t   * 其他车位的状态不变\n\t * \n\t * @param plate  要停进来的车辆车牌号，not null\n\t * @param width  车的宽度，自然数\n\t * @param num \t  指定的停车位编号，自然数\n\t * @throws 如果plate车已经停在该停车场，或者num车位已被其他车占用，或者num车位宽度不超过width，或者num并不是合法车位\n\t */\n\tpublic void parking(String type, String plate, int width, int num, String[] extraRegistrationInfo) throws Exception;\n",
      "\t/**\n\t   * 将汽车驶离停车场，plate车原来占用的车位空出来了，计算出本次停车的费用（半小时10元，不足半小时按半小时计算）\n\t * \n\t * @param plate 待驶离的车辆，not null\n\t * @return 本次停车的费用（精确计算得到）\n\t * @throws plate车并没有停在本车场\n\t */\n\tpublic double depart(String plate) throws Exception;\n",
      "\t/**\n\t   * 返回当前停车场每个车位的状态（空，或被某车占用）\n\t * \n\t * @return Key为停车位的编号，Value为该车位上的车辆车牌号。如果停车位上无车辆，则对应的Value为“”\n\t */\n\tpublic Map<Integer, String> status();\n",
      "public interface Parkable {\n\n\tpublic int getWidth();\n\tpublic String getPlate();\n\t\n\tpublic double getPricingUnit();\n\tpublic double getPrice();\n\t\n\tpublic State getState();\n\tpublic void setState(State state);\n\t\n\tpublic static Parkable create(String type, String plate, int width, String[] extraRegistrationInfo) throws Exception {\n\t\treturn new ParkableFactory().create(type, plate, width, extraRegistrationInfo);\n\t}\t\n}\n",
      "\tpublic static Parkable create(String type, String plate, int width, String[] extraRegistrationInfo) throws Exception {\n\t\treturn new ParkableFactory().create(type, plate, width, extraRegistrationInfo);\n\t}\t\n",
      "public class Car extends ConcreteParkable {\n\n\tprivate final DriverRegistration dr = new DriverRegistration();\n\n\tpublic Car(String plate, int width) {\n\t\tsuper(plate, width);\n\t\tpricingUnit = 30;\n\t\tprice = 10;\n\t}\n\n\tpublic void registerDriver(String name) {\n\t\tdr.registerDriver(name);\n\t}\n\n\tpublic String getDriverInfo() {\n\t\treturn dr.getDriverInfo();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Car \" + super.toString();\n\t}\n}\n",
      "public Parkable create(String type, String plate, int width, String[] extraRegistrationInfo) throws Exception {\n\t\tif (type.equals(\"car\")) {\n\t\t\tCar c = new Car(plate, width);\n\t\t\tc.registerDriver(extraRegistrationInfo[0]);\n\t\t\treturn c;\n\t\t} else if (type.equals(\"motor\")) {\n\t\t\tMotor m = new Motor(plate, width);\n\t\t\tm.registerDriver(extraRegistrationInfo[0]);\n\t\t\treturn m;\n\t\t} else if (type.equals(\"plane\")) {\n\t\t\tPlane p = new Plane(plate, width);\n\t\t\tCalendar c = Calendar.getInstance();\n\t\t\t//根据extraRegistrationInfo[1]字符串设置c的值\n\t\t\tp.registerAirport(extraRegistrationInfo[0], c);\n\t\t\treturn p;\n\t\t}\n\t\telse\n\t\t\tthrow new Exception(\"Illegal type\");\n\t}\n",
      "\tprivate String company;\n\n\tprivate void checkRep() {\n\t\tassert company != null && company.length() > 0;\n\t}\n\n\tpublic ParkingFieldWithCompany(ParkingField pf, String company) {\n\t\tsuper(pf);\n\t\tthis.company = company;\n\n\t\tcheckRep();\n\t}\n\n\t@Override\n\tpublic void parking(String type, String plate, int width, int num, String[] extraRegistrationInfo)\n\t\t\tthrows Exception {\n\n\t\tsuper.parking(type, plate, width, num, extraRegistrationInfo);\n\t\tSystem.out.println(\"-------\" + plate + \", \" + this.company + \" welcome to parking\");\n\t}\n",
      "public interface ParkingVisitor {\n\n\tpublic double visit(ParkingField pf);\n\n}\n"
    ],
    "date": "2021-06-27",
    "text": "题目描述：\n软件框架：\nADT设计：\n静态工厂方法\n创建一个新的停车场。\n停车：\n驶离停车场：\n停车场状态:\n以上是核心方法，其他辅助性的方法不再说明。\n方法的实现都十分简单，并不是软件构造课的主要内容，故对其逻辑不一一说明。\n面向复用的设计：\n相机场等，本质上和停车场的功能完全一样，所以我们设计的ADT如果有很好的复用性的话，只需经过少量的扩展，就可以实现一个更加复杂的场景下的类。\n我们首先将Car扩展成Parkable，即停放的东西不止可以是车，还可以是飞机、摩托车等。\n针对Parkable，设计一组方法来描述其行为。\n为了避免在客户端代码使用new操作，我们使用静态工厂方法来代替new操作。\n接着，针对各种交通工具进行方法的实现。\n如，Car类：\n工厂方法：\n针对不同的类，提供工厂方法来创建实例对象，将对象类型作为一个参数，定义到工厂方法中去，String type，这样，在每次创建时根据不同的类型来创建不同类型的实例。\nState设计模式：\n创建State接口，实现两个状态，一种是停着（parking)，一种是在路上（depart）\n让Parkable拥有一个属性State，能够管理自己的状态。\nDecorator设计模式：\n建立一个用于装饰的基础类ComplexParkingField，实现ParkingField接口，其中的所\n有方法都delegate到未装饰之前的对象。\n然后，建立一个具体装饰类ParkingFieldWithCompany，也实现ParkingField接口，继\n承自ComplexParkingField类，增加了rep（公司信息），对需要变化的方法进行扩展\n（使用super.xxx()调用基础功能）。修改构造函数，增加company参数。\nvisitor设计模式：\n扩展其他功能：\n考虑将来对 ParkingField 的功能扩展。例如要扩展的一个功能是统计停车场当前时刻占\n用比例(=已停车的车位数量总车位数)。\n建立 visitor 接口 ParkingVisitor，只有一个方法 double visit(parkingField\npf)。\n建立其子类 PercentageVisitor，实现该 visit 方法，调用 pf 的方法获得 pf 的内\n部表示，进行计算。\n在 ParkingField 接口中增加 accept(ParkingVisitor pv)方法，其实现很简单：\npv.visit(this)。\n如果还有其他功能，可以继续定义visitor进行扩展。\n"
  },
  {
    "head": "EclEmma的安装与使用----HIT软件构造",
    "paragraphs": [
      "EclEmma",
      "EclEmma是一个软件测试工具，可以查看代码的调用情况，也可以检查测试用例代码执行的覆盖率。",
      "直接打开Eclipse，在商店里面搜索安装。",
      "安装好后左上角有一个coverage按钮。",
      "运行即可：",
      "这是其中一段代码的示例，绿色说明覆盖的比较好，黄色差一等，红色最差。",
      "可以在弹出来的coverage栏查看覆盖率。"
    ],
    "sentences": [
      "EclEmma",
      "EclEmma是一个软件测试工具",
      "可以查看代码的调用情况",
      "也可以检查测试用例代码执行的覆盖率",
      "直接打开Eclipse，在商店里面搜索安装",
      "安装好后左上角有一个coverage按钮",
      "运行即可：这是其中一段代码的示例",
      "绿色说明覆盖的比较好",
      "黄色差一等",
      "红色最差",
      "可以在弹出来的coverage栏查看覆盖率"
    ],
    "codes": [],
    "date": "2021-05-31",
    "text": "EclEmma\nEclEmma是一个软件测试工具，可以查看代码的调用情况，也可以检查测试用例代码执行的覆盖率。\n直接打开Eclipse，在商店里面搜索安装。\n安装好后左上角有一个coverage按钮。\n运行即可：\n这是其中一段代码的示例，绿色说明覆盖的比较好，黄色差一等，红色最差。\n可以在弹出来的coverage栏查看覆盖率。\n"
  },
  {
    "head": "HIT软件构造----保姆级Gradle安装教程（10分钟入门）",
    "paragraphs": [
      "Gradle安装教程",
      "官网：",
      "https://gradle.org/",
      "首先安装Gradle，我们打开官网，点击install gradle",
      "在prerequisites中发现，需要jdk在1.8以上（现在也没人用老版本了把哈哈）",
      "下面一堆英文，不想看的同学光看楼主所说的就可以了：",
      "翻到下面，点击这个蓝色Download",
      "随便选一个版本，然后点击binary-only，",
      "将这个zip文件随便下载到任何一个地方：",
      "然后将它解压：",
      "完全不用像官网说的放在c盘，随便放哪都行，但是要记住它。",
      "接着我们添加环境变量：",
      "这个过程有过开发经验的同学应该都很熟悉把，具体的就是右键此电脑–》属性–》高级系统设置–》环境变量–》在系统变量中找到Path：",
      "点击编辑，新建，浏览，找到刚才解压的地方：",
      "选择Gradle目录下的gradle-7.0.2目录下的bin，添加即可。",
      "接下来打开cmd，输入gradle -v进行验证，出现以上信息说明你的安装大功告成啦！",
      "如上图，可以直接在eclipse和idea中安装插件，楼主使用的是eclipse，所以我们点击eclipse。",
      "进入到下面这个网址：",
      "https://www.vogella.com/tutorials/EclipseGradle/article.html",
      "根据介绍我们可以知道，最简单的方法就是进入eclipse，然后在商店里下载即可。",
      "工具栏中点Help，然后选最下面的",
      "Eclipse Marketplace",
      "搜索Buildship Gradle，安装即可。",
      "如果是新建一个Gradle工程的话，直接在新建工程的地方创建即可：File–>new–>other",
      "然后选择Gradle即可：",
      "由于楼主的工程是已经创建好了，所以需要用另一种方式来添加Gradle配置：",
      "在工程名处右键单击，选择",
      "Configure",
      "，然后选择",
      "Add Gradle Nature"
    ],
    "sentences": [
      "Gradle安装教程",
      "官网：https://gradle.org/",
      "首先安装Gradle",
      "我们打开官网",
      "点击install gradle",
      "在prerequisites中发现",
      "需要jdk在1.8以上（现在也没人用老版本了把哈哈）",
      "下面一堆英文",
      "不想看的同学光看楼主所说的就可以了：翻到下面",
      "点击这个蓝色Download",
      "随便选一个版本",
      "然后点击binary-only",
      "将这个zip文件随便下载到任何一个地方：然后将它解压：完全不用像官网说的放在c盘",
      "随便放哪都行",
      "但是要记住它",
      "接着我们添加环境变量：这个过程有过开发经验的同学应该都很熟悉把",
      "具体的就是右键此电脑–》属性–》高级系统设置–》环境变量–》在系统变量中找到Path：点击编辑",
      "新建",
      "浏览",
      "找到刚才解压的地方：选择Gradle目录下的gradle-7.0.2目录下的bin",
      "添加即可",
      "接下来打开cmd",
      "输入gradle -v进行验证",
      "出现以上信息说明你的安装大功告成啦！",
      "如上图",
      "可以直接在eclipse和idea中安装插件",
      "楼主使用的是eclipse",
      "所以我们点击eclipse",
      "进入到下面这个网址：https://www.vogella.com/tutorials/EclipseGradle/article.html",
      "根据介绍我们可以知道",
      "最简单的方法就是进入eclipse",
      "然后在商店里下载即可",
      "工具栏中点Help，然后选最下面的",
      "Eclipse Marketplace",
      "搜索Buildship Gradle，安装即可",
      "如果是新建一个Gradle工程的话",
      "直接在新建工程的地方创建即可：File–>new–>other",
      "然后选择Gradle即可：由于楼主的工程是已经创建好了",
      "所以需要用另一种方式来添加Gradle配置：在工程名处右键单击",
      "选择",
      "Configure",
      "，然后选择",
      "Add Gradle Nature"
    ],
    "codes": [],
    "date": "2021-05-24",
    "text": "Gradle安装教程\n官网：\nhttps://gradle.org/\n首先安装Gradle，我们打开官网，点击install gradle\n在prerequisites中发现，需要jdk在1.8以上（现在也没人用老版本了把哈哈）\n下面一堆英文，不想看的同学光看楼主所说的就可以了：\n翻到下面，点击这个蓝色Download\n随便选一个版本，然后点击binary-only，\n将这个zip文件随便下载到任何一个地方：\n然后将它解压：\n完全不用像官网说的放在c盘，随便放哪都行，但是要记住它。\n接着我们添加环境变量：\n这个过程有过开发经验的同学应该都很熟悉把，具体的就是右键此电脑–》属性–》高级系统设置–》环境变量–》在系统变量中找到Path：\n点击编辑，新建，浏览，找到刚才解压的地方：\n选择Gradle目录下的gradle-7.0.2目录下的bin，添加即可。\n接下来打开cmd，输入gradle -v进行验证，出现以上信息说明你的安装大功告成啦！\n如上图，可以直接在eclipse和idea中安装插件，楼主使用的是eclipse，所以我们点击eclipse。\n进入到下面这个网址：\nhttps://www.vogella.com/tutorials/EclipseGradle/article.html\n根据介绍我们可以知道，最简单的方法就是进入eclipse，然后在商店里下载即可。\n工具栏中点Help，然后选最下面的\nEclipse Marketplace\n搜索Buildship Gradle，安装即可。\n如果是新建一个Gradle工程的话，直接在新建工程的地方创建即可：File–>new–>other\n然后选择Gradle即可：\n由于楼主的工程是已经创建好了，所以需要用另一种方式来添加Gradle配置：\n在工程名处右键单击，选择\nConfigure\n，然后选择\nAdd Gradle Nature\n"
  },
  {
    "head": "Java学习笔记-HashMap（1）",
    "paragraphs": [
      "HashMap与Node JDK中为我们提供了HashMap这一数据结构，声明如下， public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable 它本质上是一个哈希表，且可以在常数时间内完成get和put操作。HashMap采用的是数组+链表的实现 数组中的每个桶都存储了一个<Key, Value>键值对结点。这种结点Java 8以上被称作Node。每个Node结点都会保存自己的hash、key和value，源码如下：",
      "初始情况下，数组中的所有位置都为空。用put方法插入时，会用Key的hashCode方法计算其哈希值，作为哈希表中的index。如果index对应的「桶」（即数组位置）已经被占用了，且新插入的键值对的键与那个位置上的已有键都不同，就说明发生了冲突。遇到这种情况，就在已有节点上往下挂一个新节点，存储新的键值对。这样，就形成了链表结构。可以看到，Node类中还有一成员next，它就是指向同一桶内下一个键值对的引用。get方法查找时，找到Key对应的桶后，就从头遍历链表，找到相应的键值对结点，获得其Value并返回。 键值对的加入 扩容resize 扩容是动态数据结构常用的控制大小的方式。最著名的例子莫过于C++中的vector。一般来说，数据结构类会设定两个常数值和，功能分别是： 是装载因子，当存储的数据项的数量超过当前容量的比例时，就将新建一个数组，但容量扩大一倍。然后，把原数组的内容重新哈希到经过扩容的新数组中去。注意，这里不能直接拷贝过去，因为index的计算是跟HashMap的大小相关的： index = hash(Key) & (Length - 1) 这个公式的设计是非常巧妙的。我们发现，键值对的新位置要么是在原位置，要么是在原位置的基础上再移动2次幂个的位置。这样，在扩充HashMap的时候，就不用真的把每个键值对的index都重新算一遍了，大幅提升了时间效率。 一般设为的一半，称为数据量的下界。它表示数据项的数量低于当前容量的比例时，就把容量缩小为原先的一半。 对于HashMap来说，初始的值是0.75。 头插还是尾插 一个需要注意的细节是，Java 8之前，插入新结点时，都是优先在头部插入，因为作者认为新插入的键值对更有可能被先访问到，因此头部插入的时间效率可能更高。但是，Java 8及之后，HashMap的实现就改成了从尾部插入。为何要做这样的改变呢？ 原因其实相当微妙。下面是Java 7的HashMap在扩容时调用的transfer方法，用于将原数组中的内容转移到扩容后的新数组中去。 `"
    ],
    "sentences": [
      "HashMap与Node JDK中为我们提供了HashMap这一数据结构",
      "声明如下",
      " public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable 它本质上是一个哈希表",
      "且可以在常数时间内完成get和put操作",
      "HashMap采用的是数组+链表的实现 数组中的每个桶都存储了一个<Key, Value>键值对结点",
      "这种结点Java 8以上被称作Node",
      "每个Node结点都会保存自己的hash、key和value",
      "源码如下：初始情况下",
      "数组中的所有位置都为空",
      "用put方法插入时",
      "会用Key的hashCode方法计算其哈希值",
      "作为哈希表中的index",
      "如果index对应的「桶」（即数组位置）已经被占用了",
      "且新插入的键值对的键与那个位置上的已有键都不同",
      "就说明发生了冲突",
      "遇到这种情况，就在已有节点上往下挂一个新节点，存储新的键值对",
      "这样，就形成了链表结构",
      "可以看到",
      "Node类中还有一成员next",
      "它就是指向同一桶内下一个键值对的引用",
      "get方法查找时",
      "找到Key对应的桶后",
      "就从头遍历链表",
      "找到相应的键值对结点",
      "获得其Value并返回",
      " 键值对的加入 扩容resize 扩容是动态数据结构常用的控制大小的方式",
      "最著名的例子莫过于C++中的vector",
      "一般来说",
      "数据结构类会设定两个常数值和",
      "功能分别是： 是装载因子",
      "当存储的数据项的数量超过当前容量的比例时",
      "就将新建一个数组",
      "但容量扩大一倍",
      "然后，把原数组的内容重新哈希到经过扩容的新数组中去",
      "注意",
      "这里不能直接拷贝过去",
      "因为index的计算是跟HashMap的大小相关的： index = hash(Key) & (Length - 1) 这个公式的设计是非常巧妙的",
      "我们发现",
      "键值对的新位置要么是在原位置",
      "要么是在原位置的基础上再移动2次幂个的位置",
      "这样",
      "在扩充HashMap的时候",
      "就不用真的把每个键值对的index都重新算一遍了",
      "大幅提升了时间效率",
      " 一般设为的一半，称为数据量的下界",
      "它表示数据项的数量低于当前容量的比例时",
      "就把容量缩小为原先的一半",
      " 对于HashMap来说，初始的值是0.75",
      " 头插还是尾插 一个需要注意的细节是",
      "Java 8之前",
      "插入新结点时",
      "都是优先在头部插入",
      "因为作者认为新插入的键值对更有可能被先访问到",
      "因此头部插入的时间效率可能更高",
      "但是",
      "Java 8及之后",
      "HashMap的实现就改成了从尾部插入",
      "为何要做这样的改变呢？ 原因其实相当微妙",
      "下面是Java 7的HashMap在扩容时调用的transfer方法",
      "用于将原数组中的内容转移到扩容后的新数组中去",
      " `"
    ],
    "codes": [
      "/**\n     * Basic hash bin node, used for most entries.\n*/\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        ...\n    }\n\n    public final K getKey()        { return key; }\n    public final V getValue()      { return value; }\n    public final String toString() { return key + \"=\" + value; }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n\n    public final V setValue(V newValue) {\n        ...\n    }\n\n    public final boolean equals(Object o) {\n        ...\n    }\n}",
      "void transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n    for (Entry<K,V> e : table) {\n        while(null != e) {\n            Entry<K,V> next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            // 头插法\n            // 把自己的next置为新桶的头元素\n            e.next = newTable[i];\n            // 把新桶的头元素置为自己\n            newTable[i] = e;\n            // 继续遍历原桶中的下一个元素\n            e = next;\n        }\n    }\n}"
    ],
    "date": "2021-06-21",
    "text": "HashMap与Node JDK中为我们提供了HashMap这一数据结构，声明如下， public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable 它本质上是一个哈希表，且可以在常数时间内完成get和put操作。HashMap采用的是数组+链表的实现 数组中的每个桶都存储了一个<Key, Value>键值对结点。这种结点Java 8以上被称作Node。每个Node结点都会保存自己的hash、key和value，源码如下：\n初始情况下，数组中的所有位置都为空。用put方法插入时，会用Key的hashCode方法计算其哈希值，作为哈希表中的index。如果index对应的「桶」（即数组位置）已经被占用了，且新插入的键值对的键与那个位置上的已有键都不同，就说明发生了冲突。遇到这种情况，就在已有节点上往下挂一个新节点，存储新的键值对。这样，就形成了链表结构。可以看到，Node类中还有一成员next，它就是指向同一桶内下一个键值对的引用。get方法查找时，找到Key对应的桶后，就从头遍历链表，找到相应的键值对结点，获得其Value并返回。 键值对的加入 扩容resize 扩容是动态数据结构常用的控制大小的方式。最著名的例子莫过于C++中的vector。一般来说，数据结构类会设定两个常数值和，功能分别是： 是装载因子，当存储的数据项的数量超过当前容量的比例时，就将新建一个数组，但容量扩大一倍。然后，把原数组的内容重新哈希到经过扩容的新数组中去。注意，这里不能直接拷贝过去，因为index的计算是跟HashMap的大小相关的： index = hash(Key) & (Length - 1) 这个公式的设计是非常巧妙的。我们发现，键值对的新位置要么是在原位置，要么是在原位置的基础上再移动2次幂个的位置。这样，在扩充HashMap的时候，就不用真的把每个键值对的index都重新算一遍了，大幅提升了时间效率。 一般设为的一半，称为数据量的下界。它表示数据项的数量低于当前容量的比例时，就把容量缩小为原先的一半。 对于HashMap来说，初始的值是0.75。 头插还是尾插 一个需要注意的细节是，Java 8之前，插入新结点时，都是优先在头部插入，因为作者认为新插入的键值对更有可能被先访问到，因此头部插入的时间效率可能更高。但是，Java 8及之后，HashMap的实现就改成了从尾部插入。为何要做这样的改变呢？ 原因其实相当微妙。下面是Java 7的HashMap在扩容时调用的transfer方法，用于将原数组中的内容转移到扩容后的新数组中去。 `\n"
  },
  {
    "head": "关于在保证健壮性的前提下，高效实现命令行交互程序的一些思考",
    "paragraphs": [
      "关于在保证健壮性的前提下，高效实现命令行交互程序的一些思考",
      "在本学期《软件构造》课程的三个实验中，都涉及命令行交互程序的开发，以实验三为尤，需要面向三个场景开发三个不同的交互程序。本人在完成实验三的过程中，在前面ADT的设计和扩展中并没有花费太多时间，但是在设计交互程序时，为了追求一些程序的健壮性，牺牲了实现效率，投入了大量的时间。",
      "在实验后的期末复习期间，我对设计模式和软件健壮性进行了一些思考，最终发现我当初在设计方法上存在着一些问题，因而导致效率很低，因此在本文中用它作为例子来探讨高效实现命令行终端交互程序的方法。",
      "先开发框架，再分别进行个性化实现。",
      "首先，这三个程序在用户交互流程上存在着极大的相似性：",
      "它们都是先输入一组Label信息，再进行一些关于时间段的增删改查，并且都需要打印信息。",
      "既然主体流程是一致的，我们就可以利用template设计模式来进行开发：",
      "大致框架如下：",
      "这个框架也是可扩展功能的，比如如果我们想给任务1多加一个从文本文件读入解析语法的功能，只需在choose里多开一个分支，然后实现这个功能即可。",
      "而由于所有程序的第一个功能都是与用户进行命令行交互，所以这里将function1做了进一步的分解。",
      "将数据读入与数据处理分离，保证健壮性的同时提高复用性。",
      "这三个程序不仅在流程层面有着相似性，在数据读入的处理上也有着相似性，而数据读入是程序健壮性的关键，在这方面去抽象提炼一些共性的操作有助于提高开发效率。",
      "首先抛出我们要解决的问题：在命令行交互程序中，我们通常要不断地要求用户输入，直到输入信息合法，这个逻辑虽然很简单，但是一旦程序的输入量多起来，输入的参数变得复杂，这种检查就会消耗大量的编码时间。",
      "不过，我在编码时，注意到了Date的读入十分简单：这是我对读取Date的设计：",
      "它的实现非常简洁，得益于fmt.parse(String)函数：它将一个字符串解析为一个Date，如果格式错误则抛出ParseException异常，直到用户格式正确。我们沿用这种思路，为我们的三个Label设计这样的读入函数：",
      "这里用Pair举例，首先假定我们已经设计了Pair的接收String[] args的构造方法，那么，类似的，getNextPair的设计变得十分简单：",
      "我们的Pair是一个int和String的pair，且要求String非空，于是我们可以这样编写构造方法：",
      "注意到在这里我们通过重抛出的方式将异常类型统一为MyParseException，方便外部方法的接收。",
      "到了这里，只要是对于一个需要被整行读取，切割，然后分别按参数解析的类型（不论它实验三的一个Label，还是用户输入的一个查询操作），我们都有了一个统一的外部框架来保证格式正确地进行读取，这样一来我们实现了输入和处理数据的分离，使得开发效率变高。",
      "一个问题",
      "尽管此时我们已经能够处理各种类型的读入，但问题是每于一个新类型XXX，我们就要重写一遍getNextXXX，而这些getNext的代码基本都是重复的。是否有方法来提高复用性呢？",
      "很容易想到，这种情形，可以利用模板/策略的设计模式，但是有一个最大的问题，就是返回类型：如果我们想把getNext抽象出来，那么它的返回类型就应该是众多可读取类型的父类。那么这个类型就很难再包含我们要读的类型的具体信息，因而就失去了意义。除非我们使用强制转换，而这又违反了OOP的一些原则。",
      "下面是我按照直接的想法，用template模式写出来的一个实现方案，在一处用到了从父类到子类的强转。",
      "客户端可以这样继承并调用："
    ],
    "sentences": [
      "关于在保证健壮性的前提下，高效实现命令行交互程序的一些思考",
      "在本学期《软件构造》课程的三个实验中",
      "都涉及命令行交互程序的开发",
      "以实验三为尤",
      "需要面向三个场景开发三个不同的交互程序",
      "本人在完成实验三的过程中",
      "在前面ADT的设计和扩展中并没有花费太多时间",
      "但是在设计交互程序时",
      "为了追求一些程序的健壮性",
      "牺牲了实现效率",
      "投入了大量的时间",
      "在实验后的期末复习期间",
      "我对设计模式和软件健壮性进行了一些思考",
      "最终发现我当初在设计方法上存在着一些问题",
      "因而导致效率很低",
      "因此在本文中用它作为例子来探讨高效实现命令行终端交互程序的方法",
      "先开发框架，再分别进行个性化实现",
      "首先",
      "这三个程序在用户交互流程上存在着极大的相似性：它们都是先输入一组Label信息",
      "再进行一些关于时间段的增删改查",
      "并且都需要打印信息",
      "既然主体流程是一致的",
      "我们就可以利用template设计模式来进行开发：大致框架如下：这个框架也是可扩展功能的",
      "比如如果我们想给任务1多加一个从文本文件读入解析语法的功能",
      "只需在choose里多开一个分支",
      "然后实现这个功能即可",
      "而由于所有程序的第一个功能都是与用户进行命令行交互",
      "所以这里将function1做了进一步的分解",
      "将数据读入与数据处理分离，保证健壮性的同时提高复用性",
      "这三个程序不仅在流程层面有着相似性",
      "在数据读入的处理上也有着相似性",
      "而数据读入是程序健壮性的关键",
      "在这方面去抽象提炼一些共性的操作有助于提高开发效率",
      "首先抛出我们要解决的问题：在命令行交互程序中",
      "我们通常要不断地要求用户输入",
      "直到输入信息合法",
      "这个逻辑虽然很简单",
      "但是一旦程序的输入量多起来",
      "输入的参数变得复杂",
      "这种检查就会消耗大量的编码时间",
      "不过",
      "我在编码时",
      "注意到了Date的读入十分简单：这是我对读取Date的设计：它的实现非常简洁",
      "得益于fmt.parse(String)函数：它将一个字符串解析为一个Date",
      "如果格式错误则抛出ParseException异常",
      "直到用户格式正确",
      "我们沿用这种思路",
      "为我们的三个Label设计这样的读入函数：这里用Pair举例",
      "首先假定我们已经设计了Pair的接收String[] args的构造方法",
      "那么",
      "类似的",
      "getNextPair的设计变得十分简单：我们的Pair是一个int和String的pair",
      "且要求String非空",
      "于是我们可以这样编写构造方法：注意到在这里我们通过重抛出的方式将异常类型统一为MyParseException",
      "方便外部方法的接收",
      "到了这里",
      "只要是对于一个需要被整行读取",
      "切割",
      "然后分别按参数解析的类型（不论它实验三的一个Label",
      "还是用户输入的一个查询操作）",
      "我们都有了一个统一的外部框架来保证格式正确地进行读取",
      "这样一来我们实现了输入和处理数据的分离",
      "使得开发效率变高",
      "一个问题",
      "尽管此时我们已经能够处理各种类型的读入",
      "但问题是每于一个新类型XXX",
      "我们就要重写一遍getNextXXX",
      "而这些getNext的代码基本都是重复的",
      "是否有方法来提高复用性呢？",
      "很容易想到",
      "这种情形",
      "可以利用模板/策略的设计模式",
      "但是有一个最大的问题",
      "就是返回类型：如果我们想把getNext抽象出来",
      "那么它的返回类型就应该是众多可读取类型的父类",
      "那么这个类型就很难再包含我们要读的类型的具体信息",
      "因而就失去了意义",
      "除非我们使用强制转换，而这又违反了OOP的一些原则",
      "下面是我按照直接的想法",
      "用template模式写出来的一个实现方案",
      "在一处用到了从父类到子类的强转",
      "客户端可以这样继承并调用："
    ],
    "codes": [
      "public abstract class AbstractFramework {\n    \n\t/**\n\t * 所有子程序遵循一致的框架主流程，不可被重写。\n\t */\n\tpublic final void mainOrder() {\n\t\tinit();\n\t\tint op = choose();\n\t\tswitch (op) {\n\t\tcase 1:\n\t\t\tfunction1();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfunction2();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tfunction3();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprivate void function1() {\n\t\tinputLabels();\n\t\tinteract();\n\t}\n\t\n\tprotected abstract void init();\n\tprotected abstract int choose();\n\tprotected abstract void inputLabels();\n\tprotected abstract void interact();\n\tprotected abstract void function2();\n\tprotected abstract void function3();\n\t\n\t// ...\n\n}\n",
      "private static Date nextDate(Scanner sc) {\n    while(true) {\n        String str = sc.nextLine();\n        try {\n            Date date = fmt.parse(str);\n            return date;\n        } catch (ParseException e) {\n            System.out.println(\"date format error: yyyy-MM-DD\");\n        }\n    }\n}\n",
      "private String[] split(String line) {\n    String[] args = line.split(\",\");\n    for(int i = 0; i < args.length; i++)\n        args[i] = args[i].strip();\n    return args;\n}\n\nprivate Pair getNextPair(Scanner sc) {\n    while(true) {\n        String line = sc.nextLine();\n        try {\n            return new Pair(split(line));\n        } catch (MyParseException e) {\n            info();\n        }\n    }\n}\n",
      "private final int a;\nprivate final String b; // 要求b非空\n\npublic Pair(String[] args) throws MyParseException {\n    if(args.length != 2) throw new MyParseException();\n    try {\n        a = Integer.parseInt(args[0]);\n    } catch (NumberFormatException e) {\n        throw new MyParseException();\n    }\n    if(args[1].length() == 0) throw new MyParseException();\n    else {\n        b = args[1];\n    }\n}\n",
      "import java.util.Scanner;\n// template 模式的 抽象类：Reader\npublic abstract class Reader {\n\t\n\tprivate String[] split(String line) {\n\t\tString[] args = line.split(\",\");\n\t\tfor(int i = 0; i < args.length; i++)\n\t\t\targs[i] = args[i].strip();\n\t\treturn args;\n\t}\n\t\n\tpublic Object getNext(Scanner sc) {\n\t\twhile(true) {\n\t        String line = sc.nextLine();\n\t        try {\n\t            Object res = parse(split(line));\n\t            return res;\n\t        } catch (MyParseException e) {\n\t            info();\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * 将args解析为一个Object，并进行格式错误检查\n\t * @param args 参数列表\n\t * @return 解析后的Object\n\t * @throws ParseException 如果有格式错误或不满足约束条件，抛出\n\t */\n\tprotected abstract Object parse(String[] args) throws MyParseException;\n\t\n\tprotected abstract void info();\n}\n\n",
      "import java.util.Scanner;\n\nclass PairReader extends Reader {\n\t\n\t@Override\n\tprotected Pair parse(String[] args) throws MyParseException { // 将parse功能委托到Pair的构造器上\n\t\treturn new Pair(args); \n\t}\n\n\t@Override\n\tprotected void info() { // 提示用户格式信息\n\t\tSystem.out.println(\"format: a, b. a is an interger, len of b > 0\");\n\t}\n\t\n\t@Override\n\tpublic Pair getNext(Scanner sc) {\n\t\treturn (Pair) super.getNext(sc); // !! 强转\n\t}\n\t\n}\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPair pr = new PairReader().getNext(sc);\n\t\tpr.show();\n\t}\n}\n"
    ],
    "date": "2021-07-07",
    "text": "关于在保证健壮性的前提下，高效实现命令行交互程序的一些思考\n在本学期《软件构造》课程的三个实验中，都涉及命令行交互程序的开发，以实验三为尤，需要面向三个场景开发三个不同的交互程序。本人在完成实验三的过程中，在前面ADT的设计和扩展中并没有花费太多时间，但是在设计交互程序时，为了追求一些程序的健壮性，牺牲了实现效率，投入了大量的时间。\n在实验后的期末复习期间，我对设计模式和软件健壮性进行了一些思考，最终发现我当初在设计方法上存在着一些问题，因而导致效率很低，因此在本文中用它作为例子来探讨高效实现命令行终端交互程序的方法。\n先开发框架，再分别进行个性化实现。\n首先，这三个程序在用户交互流程上存在着极大的相似性：\n它们都是先输入一组Label信息，再进行一些关于时间段的增删改查，并且都需要打印信息。\n既然主体流程是一致的，我们就可以利用template设计模式来进行开发：\n大致框架如下：\n这个框架也是可扩展功能的，比如如果我们想给任务1多加一个从文本文件读入解析语法的功能，只需在choose里多开一个分支，然后实现这个功能即可。\n而由于所有程序的第一个功能都是与用户进行命令行交互，所以这里将function1做了进一步的分解。\n将数据读入与数据处理分离，保证健壮性的同时提高复用性。\n这三个程序不仅在流程层面有着相似性，在数据读入的处理上也有着相似性，而数据读入是程序健壮性的关键，在这方面去抽象提炼一些共性的操作有助于提高开发效率。\n首先抛出我们要解决的问题：在命令行交互程序中，我们通常要不断地要求用户输入，直到输入信息合法，这个逻辑虽然很简单，但是一旦程序的输入量多起来，输入的参数变得复杂，这种检查就会消耗大量的编码时间。\n不过，我在编码时，注意到了Date的读入十分简单：这是我对读取Date的设计：\n它的实现非常简洁，得益于fmt.parse(String)函数：它将一个字符串解析为一个Date，如果格式错误则抛出ParseException异常，直到用户格式正确。我们沿用这种思路，为我们的三个Label设计这样的读入函数：\n这里用Pair举例，首先假定我们已经设计了Pair的接收String[] args的构造方法，那么，类似的，getNextPair的设计变得十分简单：\n我们的Pair是一个int和String的pair，且要求String非空，于是我们可以这样编写构造方法：\n注意到在这里我们通过重抛出的方式将异常类型统一为MyParseException，方便外部方法的接收。\n到了这里，只要是对于一个需要被整行读取，切割，然后分别按参数解析的类型（不论它实验三的一个Label，还是用户输入的一个查询操作），我们都有了一个统一的外部框架来保证格式正确地进行读取，这样一来我们实现了输入和处理数据的分离，使得开发效率变高。\n一个问题\n尽管此时我们已经能够处理各种类型的读入，但问题是每于一个新类型XXX，我们就要重写一遍getNextXXX，而这些getNext的代码基本都是重复的。是否有方法来提高复用性呢？\n很容易想到，这种情形，可以利用模板/策略的设计模式，但是有一个最大的问题，就是返回类型：如果我们想把getNext抽象出来，那么它的返回类型就应该是众多可读取类型的父类。那么这个类型就很难再包含我们要读的类型的具体信息，因而就失去了意义。除非我们使用强制转换，而这又违反了OOP的一些原则。\n下面是我按照直接的想法，用template模式写出来的一个实现方案，在一处用到了从父类到子类的强转。\n客户端可以这样继承并调用：\n"
  },
  {
    "head": "一些区间无重和问题",
    "paragraphs": [
      "区间无重和问题：",
      "问题描述：",
      "对于一个有序数组 \\(a[1…n]\\) ，希望\\(O(\\lg n)\\)地查询任意区间 \\([l, r]\\) 中元素之和，且重复元素只加一次。",
      "解决方法：",
      "对于每个点上的元素，我们额外维护一个前向指针 \\(prev\\)，指向它左方最近一个与之具有相同值的元素。",
      "有了前向指针，对于任一区间\\([l, r]\\)，显然只需遍历一遍，将所有满足 \\(prev < l\\) 的元素累加，即可得到答案。",
      "接下来思考如何优化这个过程，观察答案的式子：",
      "\\[\\sum_{prev_i < l} {a_i}",
      "\\]我们发现，如果将结点按照 \\(prev\\) 关键字排序，那么答案就是一个前缀和，因此我们可以在排序后预处理出前缀和，然后二分查找得到答案。",
      "还有区间查询的问题未解决，自然想到线段树：对树上每一个结点作预处理，将其对应区间内的元素进行排序并记录前缀和；对区间\\([L, R]\\)查询时，只需对线段树上所有子区间二分查找出 \\(prev < L\\) 的前缀和，然后合并答案即可。时间复杂度\\(O(n \\lg^2n)\\)，空间复杂度\\(O(n\\lg n)\\)。",
      "缺点：不支持在线增删",
      "重新考虑这个问题，我们要在线地查询",
      "\\[\\sum_{prev_i < L} \\sum_{L \\leq i \\leq R} a_i",
      "\\]直接一个树状数组套线段树就可以解决了，写起来甚至比上一个方法简单）",
      "有一些题目，层层剥开后，就发现就是一个无重和/积问题。",
      "另外，将 \\(a_i\\) 设置为 \\(1\\)，答案就是区间中去重元素个数。",
      "例1：codeforces 1422 F",
      "刚才说的第一种方法就是从这学的。。",
      "问题描述：给一个正整数序列，每个元素不超过2*1e5，强制在线查询给定区间的LCM。",
      "分析：在素因数分解后，若干个数的LCM即为各个素因子幂次取max，然而，素数太多了，不能这么干，真的不能吗？",
      "注意到 \\(n\\) 至多只有一个大于 \\(\\sqrt n\\) 的素因子，其余素因子都是不超过 \\(\\sqrt n\\) 的，所以我们先对 450 以下的素因子建立线段树维护区间最大幂次，将这些小的素因子提出后，每一位剩下的只能是 1 或者 素数。问题就转化为对一个素数序列动态查询区间LCM了，而素数们的LCM，不就是去重积吗？",
      "例2：codeforces 1436 E",
      "分析：求一个有序数组的所有子段（一段连续的元素）的Mex的Mex，问题看着很吓人，不过我们首先注意到 \\(1 \\leq a_i \\leq n\\)，这说明所有子段的Mex一定位于\\([1, n + 1]\\)中，所以我们可以令 \\(x\\) 从 \\(1\\) 遍历到 \\(n + 1\\)，逐步检验是否存在一个子段的Mex为 \\(x\\)。",
      "任何一个Mex为 \\(x\\) 的子段一定不包含 \\(x\\)，而在不含 \\(x\\) 的条件下，子段当然越大越有可能满足条件，考虑 \\(x\\) 会将序列分为若干不含 \\(x\\) 的极大子段，只需对这些极大子段逐一验证即可，在 \\(x\\) 遍历的过程中，总共会出现 \\(O(n)\\) 个极大子段，如何快速地处理每个子段呢？",
      "对不含 \\(x\\) 的子段进行验证，其实就是判断它是否含有 \\(1\\) 到 \\(x - 1\\) 的所有值，我们希望它等价于 “区间元素个数为 \\(x - 1\\)（去重） ”，为此，只需要在每次遍历完 \\(x\\) 后，再把所有值为 \\(x\\) 的元素放入树套树。这样就能 \\(O(\\lg n)\\) 地处理每个极大子段了。"
    ],
    "sentences": [
      "区间无重和问题：问题描述：对于一个有序数组 \\(a[1…n]\\) ",
      "希望\\(O(\\lg n)\\)地查询任意区间 \\([l, r]\\) 中元素之和",
      "且重复元素只加一次",
      "解决方法：对于每个点上的元素",
      "我们额外维护一个前向指针 \\(prev\\)",
      "指向它左方最近一个与之具有相同值的元素",
      "有了前向指针",
      "对于任一区间\\([l, r]\\)",
      "显然只需遍历一遍",
      "将所有满足 \\(prev < l\\) 的元素累加",
      "即可得到答案",
      "接下来思考如何优化这个过程",
      "观察答案的式子：\\[\\sum_{prev_i < l} {a_i}",
      "\\]我们发现",
      "如果将结点按照 \\(prev\\) 关键字排序",
      "那么答案就是一个前缀和",
      "因此我们可以在排序后预处理出前缀和",
      "然后二分查找得到答案",
      "还有区间查询的问题未解决",
      "自然想到线段树：对树上每一个结点作预处理",
      "将其对应区间内的元素进行排序并记录前缀和；对区间\\([L, R]\\)查询时",
      "只需对线段树上所有子区间二分查找出 \\(prev < L\\) 的前缀和",
      "然后合并答案即可",
      "时间复杂度\\(O(n \\lg^2n)\\)",
      "空间复杂度\\(O(n\\lg n)\\)",
      "缺点：不支持在线增删",
      "重新考虑这个问题，我们要在线地查询",
      "\\[\\sum_{prev_i < L} \\sum_{L \\leq i \\leq R} a_i",
      "\\]直接一个树状数组套线段树就可以解决了",
      "写起来甚至比上一个方法简单）",
      "有一些题目，层层剥开后，就发现就是一个无重和/积问题",
      "另外",
      "将 \\(a_i\\) 设置为 \\(1\\)",
      "答案就是区间中去重元素个数",
      "例1：codeforces 1422 F",
      "刚才说的第一种方法就是从这学的",
      "问题描述：给一个正整数序列",
      "每个元素不超过2*1e5",
      "强制在线查询给定区间的LCM",
      "分析：在素因数分解后",
      "若干个数的LCM即为各个素因子幂次取max",
      "然而",
      "素数太多了",
      "不能这么干",
      "真的不能吗？",
      "注意到 \\(n\\) 至多只有一个大于 \\(\\sqrt n\\) 的素因子",
      "其余素因子都是不超过 \\(\\sqrt n\\) 的",
      "所以我们先对 450 以下的素因子建立线段树维护区间最大幂次",
      "将这些小的素因子提出后",
      "每一位剩下的只能是 1 或者 素数",
      "问题就转化为对一个素数序列动态查询区间LCM了",
      "而素数们的LCM",
      "不就是去重积吗？",
      "例2：codeforces 1436 E",
      "分析：求一个有序数组的所有子段（一段连续的元素）的Mex的Mex",
      "问题看着很吓人",
      "不过我们首先注意到 \\(1 \\leq a_i \\leq n\\)",
      "这说明所有子段的Mex一定位于\\([1, n + 1]\\)中",
      "所以我们可以令 \\(x\\) 从 \\(1\\) 遍历到 \\(n + 1\\)",
      "逐步检验是否存在一个子段的Mex为 \\(x\\)",
      "任何一个Mex为 \\(x\\) 的子段一定不包含 \\(x\\)",
      "而在不含 \\(x\\) 的条件下",
      "子段当然越大越有可能满足条件",
      "考虑 \\(x\\) 会将序列分为若干不含 \\(x\\) 的极大子段",
      "只需对这些极大子段逐一验证即可",
      "在 \\(x\\) 遍历的过程中",
      "总共会出现 \\(O(n)\\) 个极大子段",
      "如何快速地处理每个子段呢？",
      "对不含 \\(x\\) 的子段进行验证",
      "其实就是判断它是否含有 \\(1\\) 到 \\(x - 1\\) 的所有值",
      "我们希望它等价于 “区间元素个数为 \\(x - 1\\)（去重） ”",
      "为此",
      "只需要在每次遍历完 \\(x\\) 后",
      "再把所有值为 \\(x\\) 的元素放入树套树",
      "这样就能 \\(O(\\lg n)\\) 地处理每个极大子段了"
    ],
    "codes": [],
    "date": "2020-11-03",
    "text": "区间无重和问题：\n问题描述：\n对于一个有序数组 \\(a[1…n]\\) ，希望\\(O(\\lg n)\\)地查询任意区间 \\([l, r]\\) 中元素之和，且重复元素只加一次。\n解决方法：\n对于每个点上的元素，我们额外维护一个前向指针 \\(prev\\)，指向它左方最近一个与之具有相同值的元素。\n有了前向指针，对于任一区间\\([l, r]\\)，显然只需遍历一遍，将所有满足 \\(prev < l\\) 的元素累加，即可得到答案。\n接下来思考如何优化这个过程，观察答案的式子：\n\\[\\sum_{prev_i < l} {a_i}\n\\]我们发现，如果将结点按照 \\(prev\\) 关键字排序，那么答案就是一个前缀和，因此我们可以在排序后预处理出前缀和，然后二分查找得到答案。\n还有区间查询的问题未解决，自然想到线段树：对树上每一个结点作预处理，将其对应区间内的元素进行排序并记录前缀和；对区间\\([L, R]\\)查询时，只需对线段树上所有子区间二分查找出 \\(prev < L\\) 的前缀和，然后合并答案即可。时间复杂度\\(O(n \\lg^2n)\\)，空间复杂度\\(O(n\\lg n)\\)。\n缺点：不支持在线增删\n重新考虑这个问题，我们要在线地查询\n\\[\\sum_{prev_i < L} \\sum_{L \\leq i \\leq R} a_i\n\\]直接一个树状数组套线段树就可以解决了，写起来甚至比上一个方法简单）\n有一些题目，层层剥开后，就发现就是一个无重和/积问题。\n另外，将 \\(a_i\\) 设置为 \\(1\\)，答案就是区间中去重元素个数。\n例1：codeforces 1422 F\n刚才说的第一种方法就是从这学的。。\n问题描述：给一个正整数序列，每个元素不超过2*1e5，强制在线查询给定区间的LCM。\n分析：在素因数分解后，若干个数的LCM即为各个素因子幂次取max，然而，素数太多了，不能这么干，真的不能吗？\n注意到 \\(n\\) 至多只有一个大于 \\(\\sqrt n\\) 的素因子，其余素因子都是不超过 \\(\\sqrt n\\) 的，所以我们先对 450 以下的素因子建立线段树维护区间最大幂次，将这些小的素因子提出后，每一位剩下的只能是 1 或者 素数。问题就转化为对一个素数序列动态查询区间LCM了，而素数们的LCM，不就是去重积吗？\n例2：codeforces 1436 E\n分析：求一个有序数组的所有子段（一段连续的元素）的Mex的Mex，问题看着很吓人，不过我们首先注意到 \\(1 \\leq a_i \\leq n\\)，这说明所有子段的Mex一定位于\\([1, n + 1]\\)中，所以我们可以令 \\(x\\) 从 \\(1\\) 遍历到 \\(n + 1\\)，逐步检验是否存在一个子段的Mex为 \\(x\\)。\n任何一个Mex为 \\(x\\) 的子段一定不包含 \\(x\\)，而在不含 \\(x\\) 的条件下，子段当然越大越有可能满足条件，考虑 \\(x\\) 会将序列分为若干不含 \\(x\\) 的极大子段，只需对这些极大子段逐一验证即可，在 \\(x\\) 遍历的过程中，总共会出现 \\(O(n)\\) 个极大子段，如何快速地处理每个子段呢？\n对不含 \\(x\\) 的子段进行验证，其实就是判断它是否含有 \\(1\\) 到 \\(x - 1\\) 的所有值，我们希望它等价于 “区间元素个数为 \\(x - 1\\)（去重） ”，为此，只需要在每次遍历完 \\(x\\) 后，再把所有值为 \\(x\\) 的元素放入树套树。这样就能 \\(O(\\lg n)\\) 地处理每个极大子段了。\n"
  },
  {
    "head": "      Hello World    ",
    "paragraphs": [
      "Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.",
      "Hello HexoQuick StartCreate a new post",
      "谢谢你请我吃糖果",
      "支付宝"
    ],
    "sentences": [
      "Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Hello HexoQuick StartCreate a new post",
      "谢谢你请我吃糖果",
      "支付宝"
    ],
    "codes": [
      "",
      "$ hexo server\n",
      "$ hexo generate\n",
      "$ hexo deploy\n",
      "",
      "More info: Writing",
      "Run server",
      "More info: Server",
      "Generate static files",
      "More info: Generating",
      "Deploy to remote sites",
      "More info: Deployment"
    ],
    "date": "2021-07-18",
    "text": "Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nHello HexoQuick StartCreate a new post\n谢谢你请我吃糖果\n支付宝\n"
  },
  {
    "head": "      深度学习基础知识    ",
    "paragraphs": [
      "dropout. Dropout简介1.1 Dropout出现的原因在机器学习的模型中，如果模型的参数太多，而训练样本又太少，训练出来的模型很容易产生过拟合的现象。在训练神经网络的时候经常会遇到过拟合的问题，过拟合具体表现在：模型在训练数据上损失函数较小，预测准确率较高；但是在测试数据上损失函数比较大，预测准确率较低。",
      "过拟合是很多机器学习的通病。如果模型过拟合，那么得到的模型几乎不能用。为了解决过拟合问题，一般会采用模型集成的方法，即训练多个模型进行组合。此时，训练模型费时就成为一个很大的问题，不仅训练多个模型费时，测试多个模型也是很费时。",
      "综上所述，训练深度神经网络的时候，总是会遇到两大缺点：",
      "容易过拟合",
      "Dropout可以比较有效的缓解过拟合的发生，在一定程度上达到正则化的效果。",
      "1.2 什么是Dropout在2012年，Hinton在其论文《Improving neural networks by preventing co-adaptation of feature detectors》中提出Dropout。当一个复杂的前馈神经网络被训练在小的数据集时，容易造成过拟合。为了防止过拟合，可以通过阻止特征检测器的共同作用来提高神经网络的性能。",
      "在2012年，Alex、Hinton在其论文《ImageNet Classification with Deep Convolutional Neural Networks》中用到了Dropout算法，用于防止过拟合。并且，这篇论文提到的AlexNet网络模型引爆了神经网络应用热潮，并赢得了2012年图像识别大赛冠军，使得CNN成为图像分类上的核心算法模型。",
      "随后，又有一些关于Dropout的文章《Dropout:A Simple Way to Prevent Neural Networks from Overfitting》、《Improving Neural Networks with Dropout》、《Dropout as data augmentation》。",
      "从上面的论文中，我们能感受到Dropout在深度学习中的重要性。那么，到底什么是Dropout呢？",
      "Dropout可以作为训练深度神经网络的一种trick供选择。在每个训练批次中，通过忽略一半的特征检测器（让一半的隐层节点值为0），可以明显地减少过拟合现象。这种方式可以减少特征检测器（隐层节点）间的相互作用，检测器相互作用是指某些检测器依赖其他检测器才能发挥作用。",
      "Dropout说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征，如图1所示。",
      "2. Dropout工作流程及使用2.1 Dropout具体工作流程假设我们要训练这样一个神经网络，如图2所示。",
      "输入是x输出是y，正常的流程是：我们首先把x通过网络前向传播，然后把误差反向传播以决定如何更新参数让网络进行学习。使用Dropout之后，过程变成如下：",
      "首先随机（临时）删掉网络中一半的隐藏神经元，输入输出神经元保持不变（图3中虚线为部分临时被删除的神经元）",
      "然后把输入x通过修改后的网络前向传播，然后把得到的损失结果通过修改的网络反向传播。一小批训练样本执行完这个过程后，在没有被删除的神经元上按照随机梯度下降法更新对应的参数（w，b）。",
      "然后继续重复这一过程：",
      "恢复被删掉的神经元（此时被删除的神经元保持原样，而没有被删除的神经元已经有所更新）",
      "从隐藏层神经元中随机选择一个一半大小的子集临时删除掉（备份被删除神经元的参数）。",
      "对一小批训练样本，先前向传播然后反向传播损失并根据随机梯度下降法更新参数（w，b） （没有被删除的那一部分参数得到更新，删除的神经元参数保持被删除前的结果）。",
      "不断重复这一过程。",
      "Dropout在神经网络中的使用Dropout的具体工作流程上面已经详细的介绍过了，但是具体怎么让某些神经元以一定的概率停止工作（就是被删除掉）？代码层面如何实现呢？",
      "下面，我们具体讲解一下Dropout代码层面的一些公式推导及代码实现思路。",
      "（1）在训练模型阶段",
      "无可避免的，在训练网络的每个单元都要添加一道概率流程。对应的公式变化如下：",
      "没有Dropout的网络计算公式：",
      "采用Dropout的网络计算公式：",
      "上面公式中Bernoulli函数是为了生成概率r向量，也就是随机生成一个0、1的向量,其实就是一个概率为p的0，1分布。",
      "代码层面实现让某个神经元以概率p停止工作，其实就是让它的激活函数值以概率p变为0。比如我们某一层网络神经元的个数为1000个，其激活函数输出值为$y_1,y_2,…,y_{1000}$，我们dropout比率选择0.4，那么这一层神经元经过dropout后，1000个神经元中会有大约400个的值被置为0。",
      "注意： 经过上面屏蔽掉某些神经元，使其激活函数值为0以后，我们还需要对向量$y_1,y_2,…,y_{1000}$进行缩放，也就是乘以1/(1-p)。如果你在训练的时候，经过置0后，没有对$y_1,y_2,…,y_{1000}$进行缩放（rescale），那么在测试的时候，就需要对权重进行缩放，操作如下。",
      "（2）在测试模型阶段",
      "预测模型的时候，每一个神经单元的权重参数要乘以概率p。测试阶段Dropout公式：$w_{test}^{(l)}=pW^{(l)}$",
      "3. 为什么说Dropout可以解决过拟合？",
      "取平均的作用： 先回到标准的模型即没有dropout，我们用相同的训练数据去训练5个不同的神经网络，一般会得到5个不同的结果，此时我们可以采用 “5个结果取均值”或者“多数取胜的投票策略”去决定最终结果。例如3个网络判断结果为数字9,那么很有可能真正的结果就是数字9，其它两个网络给出了错误结果。这种“综合起来取平均”的策略通常可以有效防止过拟合问题。因为不同的网络可能产生不同的过拟合，取平均则有可能让一些“相反的”拟合互相抵消。dropout掉不同的隐藏神经元就类似在训练不同的网络，随机删掉一半隐藏神经元导致网络结构已经不同，整个dropout过程就相当于对很多个不同的神经网络取平均。而不同的网络产生不同的过拟合，一些互为“反向”的拟合相互抵消就可以达到整体上减少过拟合。",
      "减少神经元之间复杂的共适应关系： 因为dropout程序导致两个神经元不一定每次都在一个dropout网络中出现。这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况 。迫使网络去学习更加鲁棒的特征 ，这些特征在其它的神经元的随机子集中也存在。换句话说假如我们的神经网络是在做出某种预测，它不应该对一些特定的线索片段太过敏感，即使丢失特定的线索，它也应该可以从众多其它线索中学习一些共同的特征。从这个角度看dropout就有点像L1，L2正则，减少权重使得网络对丢失特定神经元连接的鲁棒性提高。",
      "Dropout类似于性别在生物进化中的角色：物种为了生存往往会倾向于适应这种环境，环境突变则会导致物种难以做出及时反应，性别的出现可以繁衍出适应新环境的变种，有效的阻止过拟合，即避免环境改变时物种可能面临的灭绝。",
      "4.pytorch中的DropoutTORCH.NN.FUNCTIONAL.DROPOUT",
      "SOURCE",
      "参数:",
      "p – probability of an element to be zeroed. Default: 0.5(元素被归零的概率。默认值:0.5)",
      "training – apply dropout if is True. Default: True(如果为True，则应用dropout。默认值:True)",
      "inplace – If set to True, will do this operation in-place. Default: False(如果设置为True，将原地in_place执行此操作。默认值:False)",
      "一些激活函数ReLUReLU的表达式为$ReLU(x) = max(0, x)$",
      "它及其导函数图像为",
      "Softmax",
      "谢谢你请我吃糖果",
      "支付宝"
    ],
    "sentences": [
      "dropout. Dropout简介1.1 Dropout出现的原因在机器学习的模型中",
      "如果模型的参数太多",
      "而训练样本又太少",
      "训练出来的模型很容易产生过拟合的现象",
      "在训练神经网络的时候经常会遇到过拟合的问题",
      "过拟合具体表现在：模型在训练数据上损失函数较小",
      "预测准确率较高；但是在测试数据上损失函数比较大",
      "预测准确率较低",
      "过拟合是很多机器学习的通病",
      "如果模型过拟合，那么得到的模型几乎不能用",
      "为了解决过拟合问题",
      "一般会采用模型集成的方法",
      "即训练多个模型进行组合",
      "此时",
      "训练模型费时就成为一个很大的问题",
      "不仅训练多个模型费时",
      "测试多个模型也是很费时",
      "综上所述",
      "训练深度神经网络的时候",
      "总是会遇到两大缺点：容易过拟合",
      "Dropout可以比较有效的缓解过拟合的发生",
      "在一定程度上达到正则化的效果",
      "1.2 什么是Dropout在2012年",
      "Hinton在其论文《Improving neural networks by preventing co-adaptation of feature detectors》中提出Dropout",
      "当一个复杂的前馈神经网络被训练在小的数据集时，容易造成过拟合",
      "为了防止过拟合",
      "可以通过阻止特征检测器的共同作用来提高神经网络的性能",
      "在2012年",
      "Alex、Hinton在其论文《ImageNet Classification with Deep Convolutional Neural Networks》中用到了Dropout算法",
      "用于防止过拟合",
      "并且",
      "这篇论文提到的AlexNet网络模型引爆了神经网络应用热潮",
      "并赢得了2012年图像识别大赛冠军",
      "使得CNN成为图像分类上的核心算法模型",
      "随后",
      "又有一些关于Dropout的文章《Dropout:A Simple Way to Prevent Neural Networks from Overfitting》、《Improving Neural Networks with Dropout》、《Dropout as data augmentation》",
      "从上面的论文中",
      "我们能感受到Dropout在深度学习中的重要性",
      "那么，到底什么是Dropout呢？",
      "Dropout可以作为训练深度神经网络的一种trick供选择",
      "在每个训练批次中",
      "通过忽略一半的特征检测器（让一半的隐层节点值为0）",
      "可以明显地减少过拟合现象",
      "这种方式可以减少特征检测器（隐层节点）间的相互作用",
      "检测器相互作用是指某些检测器依赖其他检测器才能发挥作用",
      "Dropout说的简单一点就是：我们在前向传播的时候",
      "让某个神经元的激活值以一定的概率p停止工作",
      "这样可以使模型泛化性更强",
      "因为它不会太依赖某些局部的特征",
      "如图1所示",
      "2. Dropout工作流程及使用2.1 Dropout具体工作流程假设我们要训练这样一个神经网络",
      "如图2所示",
      "输入是x输出是y",
      "正常的流程是：我们首先把x通过网络前向传播",
      "然后把误差反向传播以决定如何更新参数让网络进行学习",
      "使用Dropout之后",
      "过程变成如下：首先随机（临时）删掉网络中一半的隐藏神经元",
      "输入输出神经元保持不变（图3中虚线为部分临时被删除的神经元）",
      "然后把输入x通过修改后的网络前向传播",
      "然后把得到的损失结果通过修改的网络反向传播",
      "一小批训练样本执行完这个过程后",
      "在没有被删除的神经元上按照随机梯度下降法更新对应的参数（w",
      "b）",
      "然后继续重复这一过程：恢复被删掉的神经元（此时被删除的神经元保持原样",
      "而没有被删除的神经元已经有所更新）",
      "从隐藏层神经元中随机选择一个一半大小的子集临时删除掉（备份被删除神经元的参数）",
      "对一小批训练样本",
      "先前向传播然后反向传播损失并根据随机梯度下降法更新参数（w",
      "b） （没有被删除的那一部分参数得到更新",
      "删除的神经元参数保持被删除前的结果）",
      "不断重复这一过程",
      "Dropout在神经网络中的使用Dropout的具体工作流程上面已经详细的介绍过了",
      "但是具体怎么让某些神经元以一定的概率停止工作（就是被删除掉）？代码层面如何实现呢？",
      "下面",
      "我们具体讲解一下Dropout代码层面的一些公式推导及代码实现思路",
      "（1）在训练模型阶段",
      "无可避免的，在训练网络的每个单元都要添加一道概率流程",
      "对应的公式变化如下：没有Dropout的网络计算公式：采用Dropout的网络计算公式：上面公式中Bernoulli函数是为了生成概率r向量",
      "也就是随机生成一个0、1的向量,其实就是一个概率为p的0",
      "1分布",
      "代码层面实现让某个神经元以概率p停止工作",
      "其实就是让它的激活函数值以概率p变为0",
      "比如我们某一层网络神经元的个数为1000个",
      "其激活函数输出值为$y_1,y_2,…,y_{1000}$",
      "我们dropout比率选择0.4",
      "那么这一层神经元经过dropout后",
      "1000个神经元中会有大约400个的值被置为0",
      "注意： 经过上面屏蔽掉某些神经元",
      "使其激活函数值为0以后",
      "我们还需要对向量$y_1,y_2,…,y_{1000}$进行缩放",
      "也就是乘以1/(1-p)",
      "如果你在训练的时候",
      "经过置0后",
      "没有对$y_1,y_2,…,y_{1000}$进行缩放（rescale）",
      "那么在测试的时候",
      "就需要对权重进行缩放",
      "操作如下",
      "（2）在测试模型阶段",
      "预测模型的时候，每一个神经单元的权重参数要乘以概率p",
      "测试阶段Dropout公式：$w_{test}^{(l)}=pW^{(l)}$",
      "3. 为什么说Dropout可以解决过拟合？",
      "取平均的作用： 先回到标准的模型即没有dropout",
      "我们用相同的训练数据去训练5个不同的神经网络",
      "一般会得到5个不同的结果",
      "此时我们可以采用 “5个结果取均值”或者“多数取胜的投票策略”去决定最终结果",
      "例如3个网络判断结果为数字9,那么很有可能真正的结果就是数字9",
      "其它两个网络给出了错误结果",
      "这种“综合起来取平均”的策略通常可以有效防止过拟合问题",
      "因为不同的网络可能产生不同的过拟合",
      "取平均则有可能让一些“相反的”拟合互相抵消",
      "dropout掉不同的隐藏神经元就类似在训练不同的网络",
      "随机删掉一半隐藏神经元导致网络结构已经不同",
      "整个dropout过程就相当于对很多个不同的神经网络取平均",
      "而不同的网络产生不同的过拟合",
      "一些互为“反向”的拟合相互抵消就可以达到整体上减少过拟合",
      "减少神经元之间复杂的共适应关系： 因为dropout程序导致两个神经元不一定每次都在一个dropout网络中出现",
      "这样权值的更新不再依赖于有固定关系的隐含节点的共同作用",
      "阻止了某些特征仅仅在其它特定特征下才有效果的情况 ",
      "迫使网络去学习更加鲁棒的特征 ",
      "这些特征在其它的神经元的随机子集中也存在",
      "换句话说假如我们的神经网络是在做出某种预测",
      "它不应该对一些特定的线索片段太过敏感",
      "即使丢失特定的线索",
      "它也应该可以从众多其它线索中学习一些共同的特征",
      "从这个角度看dropout就有点像L1",
      "L2正则",
      "减少权重使得网络对丢失特定神经元连接的鲁棒性提高",
      "Dropout类似于性别在生物进化中的角色：物种为了生存往往会倾向于适应这种环境",
      "环境突变则会导致物种难以做出及时反应",
      "性别的出现可以繁衍出适应新环境的变种",
      "有效的阻止过拟合",
      "即避免环境改变时物种可能面临的灭绝",
      "4.pytorch中的DropoutTORCH.NN.FUNCTIONAL.DROPOUT",
      "SOURCE",
      "参数:p – probability of an element to be zeroed. Default: 0.5(元素被归零的概率",
      "默认值:0.5)",
      "training – apply dropout if is True. Default: True(如果为True",
      "则应用dropout",
      "默认值:True)",
      "inplace – If set to True, will do this operation in-place. Default: False(如果设置为True",
      "将原地in_place执行此操作",
      "默认值:False)",
      "一些激活函数ReLUReLU的表达式为$ReLU(x) = max(0, x)$",
      "它及其导函数图像为",
      "Softmax",
      "谢谢你请我吃糖果",
      "支付宝"
    ],
    "codes": [
      "",
      "",
      ""
    ],
    "date": "2021-08-11",
    "text": "dropout. Dropout简介1.1 Dropout出现的原因在机器学习的模型中，如果模型的参数太多，而训练样本又太少，训练出来的模型很容易产生过拟合的现象。在训练神经网络的时候经常会遇到过拟合的问题，过拟合具体表现在：模型在训练数据上损失函数较小，预测准确率较高；但是在测试数据上损失函数比较大，预测准确率较低。\n过拟合是很多机器学习的通病。如果模型过拟合，那么得到的模型几乎不能用。为了解决过拟合问题，一般会采用模型集成的方法，即训练多个模型进行组合。此时，训练模型费时就成为一个很大的问题，不仅训练多个模型费时，测试多个模型也是很费时。\n综上所述，训练深度神经网络的时候，总是会遇到两大缺点：\n容易过拟合\nDropout可以比较有效的缓解过拟合的发生，在一定程度上达到正则化的效果。\n1.2 什么是Dropout在2012年，Hinton在其论文《Improving neural networks by preventing co-adaptation of feature detectors》中提出Dropout。当一个复杂的前馈神经网络被训练在小的数据集时，容易造成过拟合。为了防止过拟合，可以通过阻止特征检测器的共同作用来提高神经网络的性能。\n在2012年，Alex、Hinton在其论文《ImageNet Classification with Deep Convolutional Neural Networks》中用到了Dropout算法，用于防止过拟合。并且，这篇论文提到的AlexNet网络模型引爆了神经网络应用热潮，并赢得了2012年图像识别大赛冠军，使得CNN成为图像分类上的核心算法模型。\n随后，又有一些关于Dropout的文章《Dropout:A Simple Way to Prevent Neural Networks from Overfitting》、《Improving Neural Networks with Dropout》、《Dropout as data augmentation》。\n从上面的论文中，我们能感受到Dropout在深度学习中的重要性。那么，到底什么是Dropout呢？\nDropout可以作为训练深度神经网络的一种trick供选择。在每个训练批次中，通过忽略一半的特征检测器（让一半的隐层节点值为0），可以明显地减少过拟合现象。这种方式可以减少特征检测器（隐层节点）间的相互作用，检测器相互作用是指某些检测器依赖其他检测器才能发挥作用。\nDropout说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征，如图1所示。\n2. Dropout工作流程及使用2.1 Dropout具体工作流程假设我们要训练这样一个神经网络，如图2所示。\n输入是x输出是y，正常的流程是：我们首先把x通过网络前向传播，然后把误差反向传播以决定如何更新参数让网络进行学习。使用Dropout之后，过程变成如下：\n首先随机（临时）删掉网络中一半的隐藏神经元，输入输出神经元保持不变（图3中虚线为部分临时被删除的神经元）\n然后把输入x通过修改后的网络前向传播，然后把得到的损失结果通过修改的网络反向传播。一小批训练样本执行完这个过程后，在没有被删除的神经元上按照随机梯度下降法更新对应的参数（w，b）。\n然后继续重复这一过程：\n恢复被删掉的神经元（此时被删除的神经元保持原样，而没有被删除的神经元已经有所更新）\n从隐藏层神经元中随机选择一个一半大小的子集临时删除掉（备份被删除神经元的参数）。\n对一小批训练样本，先前向传播然后反向传播损失并根据随机梯度下降法更新参数（w，b） （没有被删除的那一部分参数得到更新，删除的神经元参数保持被删除前的结果）。\n不断重复这一过程。\nDropout在神经网络中的使用Dropout的具体工作流程上面已经详细的介绍过了，但是具体怎么让某些神经元以一定的概率停止工作（就是被删除掉）？代码层面如何实现呢？\n下面，我们具体讲解一下Dropout代码层面的一些公式推导及代码实现思路。\n（1）在训练模型阶段\n无可避免的，在训练网络的每个单元都要添加一道概率流程。对应的公式变化如下：\n没有Dropout的网络计算公式：\n采用Dropout的网络计算公式：\n上面公式中Bernoulli函数是为了生成概率r向量，也就是随机生成一个0、1的向量,其实就是一个概率为p的0，1分布。\n代码层面实现让某个神经元以概率p停止工作，其实就是让它的激活函数值以概率p变为0。比如我们某一层网络神经元的个数为1000个，其激活函数输出值为$y_1,y_2,…,y_{1000}$，我们dropout比率选择0.4，那么这一层神经元经过dropout后，1000个神经元中会有大约400个的值被置为0。\n注意： 经过上面屏蔽掉某些神经元，使其激活函数值为0以后，我们还需要对向量$y_1,y_2,…,y_{1000}$进行缩放，也就是乘以1/(1-p)。如果你在训练的时候，经过置0后，没有对$y_1,y_2,…,y_{1000}$进行缩放（rescale），那么在测试的时候，就需要对权重进行缩放，操作如下。\n（2）在测试模型阶段\n预测模型的时候，每一个神经单元的权重参数要乘以概率p。测试阶段Dropout公式：$w_{test}^{(l)}=pW^{(l)}$\n3. 为什么说Dropout可以解决过拟合？\n取平均的作用： 先回到标准的模型即没有dropout，我们用相同的训练数据去训练5个不同的神经网络，一般会得到5个不同的结果，此时我们可以采用 “5个结果取均值”或者“多数取胜的投票策略”去决定最终结果。例如3个网络判断结果为数字9,那么很有可能真正的结果就是数字9，其它两个网络给出了错误结果。这种“综合起来取平均”的策略通常可以有效防止过拟合问题。因为不同的网络可能产生不同的过拟合，取平均则有可能让一些“相反的”拟合互相抵消。dropout掉不同的隐藏神经元就类似在训练不同的网络，随机删掉一半隐藏神经元导致网络结构已经不同，整个dropout过程就相当于对很多个不同的神经网络取平均。而不同的网络产生不同的过拟合，一些互为“反向”的拟合相互抵消就可以达到整体上减少过拟合。\n减少神经元之间复杂的共适应关系： 因为dropout程序导致两个神经元不一定每次都在一个dropout网络中出现。这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况 。迫使网络去学习更加鲁棒的特征 ，这些特征在其它的神经元的随机子集中也存在。换句话说假如我们的神经网络是在做出某种预测，它不应该对一些特定的线索片段太过敏感，即使丢失特定的线索，它也应该可以从众多其它线索中学习一些共同的特征。从这个角度看dropout就有点像L1，L2正则，减少权重使得网络对丢失特定神经元连接的鲁棒性提高。\nDropout类似于性别在生物进化中的角色：物种为了生存往往会倾向于适应这种环境，环境突变则会导致物种难以做出及时反应，性别的出现可以繁衍出适应新环境的变种，有效的阻止过拟合，即避免环境改变时物种可能面临的灭绝。\n4.pytorch中的DropoutTORCH.NN.FUNCTIONAL.DROPOUT\nSOURCE\n参数:\np – probability of an element to be zeroed. Default: 0.5(元素被归零的概率。默认值:0.5)\ntraining – apply dropout if is True. Default: True(如果为True，则应用dropout。默认值:True)\ninplace – If set to True, will do this operation in-place. Default: False(如果设置为True，将原地in_place执行此操作。默认值:False)\n一些激活函数ReLUReLU的表达式为$ReLU(x) = max(0, x)$\n它及其导函数图像为\nSoftmax\n谢谢你请我吃糖果\n支付宝\n"
  },
  {
    "head": "      泛型、通配符    ",
    "paragraphs": [
      "泛型参数化多态：当代码编写时没有提到任何特定的类型，因此可以透明地用于任何数量的新类型。在面向对象的编程中，这通常被称为泛型编程。",
      "当一个函数在一系列类型上都一致地能运行时，我们可以得到参数多态性；这些类型通常表现出一些共同的结构。它能够以泛型方式定义函数和类型，以便基于运行时传递的参数来工作，即允许在不完全指定类型的情况下进行静态类型检查。",
      "泛型编程是一种编程风格，其中数据类型用稍后指定的类型编写，然后在需要时为参数提供的特定类型进行实例化。",
      "类型变量类型变量是不限定的标识符类型变量，也叫做类型参数。它们由泛型类声明、泛型接口声明、泛型方法声明。",
      "出于规范的目的，建议用单个大写字母来代表类型参数。常见的如：",
      "T 代表Type，即一般的任何类。",
      "E 代表 Element 的意思，或者 Exception 异常的意思。",
      "K 代表 Key 的意思。",
      "V 代表 Value 的意思，通常与 K 一起配合使用。",
      "泛型类如果一个类声明了一个或多个类型变量，则它是一个泛型类。",
      "泛型类：其定义中包含一个或多个作为参数的类型变量，而这些类型变量被称为类的类型参数。",
      "泛型类示例",
      "泛型接口泛型接口与泛型类是类似的，只需要把类换成接口即可。",
      "泛型方法如果方法声明中带有类型变量，称为泛型方法",
      "这些类型变量称为该方法的形式类型参数。形式类型参数列表的形式与类或接口的类型参数列表相同。",
      "泛型方法与泛型类稍有不同的地方是，类型参数也就是尖括号那一部分是写在返回值前面的。$$中的 T 被称为类型参数，而方法中的 T 被称为参数化类型，它不是运行时真正的参数。",
      "泛型方法示例：",
      "值得注意的是，泛型方法和泛型类是可以共存的。也就是说泛型类中可以有泛型方法，而泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的，泛型方法始终以自己定义的类型参数为准。",
      "类型擦除在编译代码后，编译器将丢弃类型参数的类型信息；因此，此类型信息在运行时不可用。这个过程被称为类型擦除类型擦除。",
      "类型擦除：如果类型参数无界，则将通用类型中的所有类型参数替换为它们的边界或对象。因此，生成的字节码只包含普通的类、接口和方法。",
      "假设这是你写的代码",
      "通配符通配符的出现是为了指定泛型中的类型范围。",
      "既然有了泛型，为何要出现一个通配符呢？",
      "我认为通配符提高了对不同类型的容器以一种相同的方式进行访问，也就是提升了一种只读的能力。",
      "考虑以下代码：",
      "上面这段代码告诉我们一个存放元素类型是Integer的列表并不是一个存放元素类型是Number的列表的子类，即使Integer类型是Number的子类。",
      "但是有些时候，我们希望以一种统一的方式访问Number类型及其子类型（如Integer、Double）的容器",
      "此时如果我们想要往sum方法中传Number子类型的容器编译器将会报错。",
      "解决方案——使用通配符",
      "通配符有 3 种形式。",
      "<?>被称作无限定的通配符。 可以匹配任意类型",
      "<? super T>被称作有下限的通配符。",
      "List<Integer>与List<? super Integer>",
      "前者只匹配Integer类型的列表，而后者与任何类型为Integer的父类的列表匹配，如Integer、Number和Object。",
      "<? extends T>被称作有上限的通配符。类似上面2的定义",
      "可以通过两幅图更好的理解通配符，图一中List<?>可以视作List<Number>,List<Integer>的父类与之匹配图二的关系更为复杂，但只要根据我们所说的规则也是很容易理解的。",
      "最后回到之前的那个问题，我们只需要需改参数列表，使用通配符即可解决",
      "此时sum可以传入任何存放Number及其子类型的列表。",
      "谢谢你请我吃糖果",
      "支付宝"
    ],
    "sentences": [
      "泛型参数化多态：当代码编写时没有提到任何特定的类型",
      "因此可以透明地用于任何数量的新类型",
      "在面向对象的编程中，这通常被称为泛型编程",
      "当一个函数在一系列类型上都一致地能运行时",
      "我们可以得到参数多态性；这些类型通常表现出一些共同的结构",
      "它能够以泛型方式定义函数和类型",
      "以便基于运行时传递的参数来工作",
      "即允许在不完全指定类型的情况下进行静态类型检查",
      "泛型编程是一种编程风格",
      "其中数据类型用稍后指定的类型编写",
      "然后在需要时为参数提供的特定类型进行实例化",
      "类型变量类型变量是不限定的标识符类型变量，也叫做类型参数",
      "它们由泛型类声明、泛型接口声明、泛型方法声明",
      "出于规范的目的，建议用单个大写字母来代表类型参数",
      "常见的如：T 代表Type，即一般的任何类",
      "E 代表 Element 的意思",
      "或者 Exception 异常的意思",
      "K 代表 Key 的意思",
      "V 代表 Value 的意思，通常与 K 一起配合使用",
      "泛型类如果一个类声明了一个或多个类型变量，则它是一个泛型类",
      "泛型类：其定义中包含一个或多个作为参数的类型变量",
      "而这些类型变量被称为类的类型参数",
      "泛型类示例",
      "泛型接口泛型接口与泛型类是类似的，只需要把类换成接口即可",
      "泛型方法如果方法声明中带有类型变量，称为泛型方法",
      "这些类型变量称为该方法的形式类型参数",
      "形式类型参数列表的形式与类或接口的类型参数列表相同",
      "泛型方法与泛型类稍有不同的地方是",
      "类型参数也就是尖括号那一部分是写在返回值前面的",
      "$$中的 T 被称为类型参数",
      "而方法中的 T 被称为参数化类型",
      "它不是运行时真正的参数",
      "泛型方法示例：值得注意的是，泛型方法和泛型类是可以共存的",
      "也就是说泛型类中可以有泛型方法",
      "而泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的",
      "泛型方法始终以自己定义的类型参数为准",
      "类型擦除在编译代码后",
      "编译器将丢弃类型参数的类型信息；因此",
      "此类型信息在运行时不可用",
      "这个过程被称为类型擦除类型擦除",
      "类型擦除：如果类型参数无界",
      "则将通用类型中的所有类型参数替换为它们的边界或对象",
      "因此，生成的字节码只包含普通的类、接口和方法",
      "假设这是你写的代码",
      "通配符通配符的出现是为了指定泛型中的类型范围",
      "既然有了泛型，为何要出现一个通配符呢？",
      "我认为通配符提高了对不同类型的容器以一种相同的方式进行访问",
      "也就是提升了一种只读的能力",
      "考虑以下代码：上面这段代码告诉我们一个存放元素类型是Integer的列表并不是一个存放元素类型是Number的列表的子类",
      "即使Integer类型是Number的子类",
      "但是有些时候",
      "我们希望以一种统一的方式访问Number类型及其子类型（如Integer、Double）的容器",
      "此时如果我们想要往sum方法中传Number子类型的容器编译器将会报错",
      "解决方案——使用通配符",
      "通配符有 3 种形式",
      "<?>被称作无限定的通配符",
      " 可以匹配任意类型",
      "<? super T>被称作有下限的通配符",
      "List<Integer>与List<? super Integer>",
      "前者只匹配Integer类型的列表",
      "而后者与任何类型为Integer的父类的列表匹配",
      "如Integer、Number和Object",
      "<? extends T>被称作有上限的通配符",
      "类似上面2的定义",
      "可以通过两幅图更好的理解通配符",
      "图一中List<?>可以视作List<Number>,List<Integer>的父类与之匹配图二的关系更为复杂",
      "但只要根据我们所说的规则也是很容易理解的",
      "最后回到之前的那个问题",
      "我们只需要需改参数列表",
      "使用通配符即可解决",
      "此时sum可以传入任何存放Number及其子类型的列表",
      "谢谢你请我吃糖果",
      "支付宝"
    ],
    "codes": [
      "    T t;\n    E e;\n    }\n    }\n}\n",
      "    }\n}\n//调用时不需要特别的指定类型，泛型方法会根据参数类型进行推断\n",
      "    }\n    }\n}\n编译代码后，类将会变为\n``` java\n    }\n    }\n// ...\n}\n个人认为，参数机制提供了一种静态类型检查，当你设定好了类型参数之后，编译器将会对代码进行静态类型检查。编译之后，类型信息都被擦除。\n",
      "",
      "        summation += number.longValue();\n    }\n}\n",
      "        summation += number.longValue();\n    }\n}\n",
      ""
    ],
    "date": "2021-07-06",
    "text": "泛型参数化多态：当代码编写时没有提到任何特定的类型，因此可以透明地用于任何数量的新类型。在面向对象的编程中，这通常被称为泛型编程。\n当一个函数在一系列类型上都一致地能运行时，我们可以得到参数多态性；这些类型通常表现出一些共同的结构。它能够以泛型方式定义函数和类型，以便基于运行时传递的参数来工作，即允许在不完全指定类型的情况下进行静态类型检查。\n泛型编程是一种编程风格，其中数据类型用稍后指定的类型编写，然后在需要时为参数提供的特定类型进行实例化。\n类型变量类型变量是不限定的标识符类型变量，也叫做类型参数。它们由泛型类声明、泛型接口声明、泛型方法声明。\n出于规范的目的，建议用单个大写字母来代表类型参数。常见的如：\nT 代表Type，即一般的任何类。\nE 代表 Element 的意思，或者 Exception 异常的意思。\nK 代表 Key 的意思。\nV 代表 Value 的意思，通常与 K 一起配合使用。\n泛型类如果一个类声明了一个或多个类型变量，则它是一个泛型类。\n泛型类：其定义中包含一个或多个作为参数的类型变量，而这些类型变量被称为类的类型参数。\n泛型类示例\n泛型接口泛型接口与泛型类是类似的，只需要把类换成接口即可。\n泛型方法如果方法声明中带有类型变量，称为泛型方法\n这些类型变量称为该方法的形式类型参数。形式类型参数列表的形式与类或接口的类型参数列表相同。\n泛型方法与泛型类稍有不同的地方是，类型参数也就是尖括号那一部分是写在返回值前面的。$$中的 T 被称为类型参数，而方法中的 T 被称为参数化类型，它不是运行时真正的参数。\n泛型方法示例：\n值得注意的是，泛型方法和泛型类是可以共存的。也就是说泛型类中可以有泛型方法，而泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的，泛型方法始终以自己定义的类型参数为准。\n类型擦除在编译代码后，编译器将丢弃类型参数的类型信息；因此，此类型信息在运行时不可用。这个过程被称为类型擦除类型擦除。\n类型擦除：如果类型参数无界，则将通用类型中的所有类型参数替换为它们的边界或对象。因此，生成的字节码只包含普通的类、接口和方法。\n假设这是你写的代码\n通配符通配符的出现是为了指定泛型中的类型范围。\n既然有了泛型，为何要出现一个通配符呢？\n我认为通配符提高了对不同类型的容器以一种相同的方式进行访问，也就是提升了一种只读的能力。\n考虑以下代码：\n上面这段代码告诉我们一个存放元素类型是Integer的列表并不是一个存放元素类型是Number的列表的子类，即使Integer类型是Number的子类。\n但是有些时候，我们希望以一种统一的方式访问Number类型及其子类型（如Integer、Double）的容器\n此时如果我们想要往sum方法中传Number子类型的容器编译器将会报错。\n解决方案——使用通配符\n通配符有 3 种形式。\n<?>被称作无限定的通配符。 可以匹配任意类型\n<? super T>被称作有下限的通配符。\nList<Integer>与List<? super Integer>\n前者只匹配Integer类型的列表，而后者与任何类型为Integer的父类的列表匹配，如Integer、Number和Object。\n<? extends T>被称作有上限的通配符。类似上面2的定义\n可以通过两幅图更好的理解通配符，图一中List<?>可以视作List<Number>,List<Integer>的父类与之匹配图二的关系更为复杂，但只要根据我们所说的规则也是很容易理解的。\n最后回到之前的那个问题，我们只需要需改参数列表，使用通配符即可解决\n此时sum可以传入任何存放Number及其子类型的列表。\n谢谢你请我吃糖果\n支付宝\n"
  },
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null
]