第1篇文章[1]
程序人生-Hello’sP2P 计算机系统 大作业 摘要 hello.c,每个计算机人程序路上的第一步。预处理、编译、汇编、链接、进程管理、存储管理、IO管理 它最为简单，却是每个计算机程序运行的点点缩影。Hello.c是用高级语言C编写的，我们要经过预处理，编译，汇编等过程，才能作为机器能读懂的机器代码储存在磁盘中。Hello现在的状态叫程序（Program），用户通过shell，调用一系列函数将hello运行在内存中。他是通过一种叫做进程（Process）的抽象来实现的。理解这些简单之下的过程与作用，能加深对计算机系统的深刻认识，以及学习过程疑问的逐步解答。以“hello一生”，走进计算机的故事。 关键词：编译管理；进程链接；hello;计算机系统分析； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-4- 1.1Hello简介-4- 1.2环境与工具-4- 1.3中间结果-4- 1.4本章小结-4- 第2章预处理-5- 2.1预处理的概念与作用-5- 2.2在Ubuntu下预处理的命令-5- 2.3Hello的预处理结果解析-5- 2.4本章小结-5- 第3章编译-6- 3.1编译的概念与作用-6- 3.2在Ubuntu下编译的命令-6- 3.3Hello的编译结果解析-6- 3.4本章小结-6- 第4章汇编-7- 4.1汇编的概念与作用-7- 4.2在Ubuntu下汇编的命令-7- 4.3可重定位目标elf格式-7- 4.4Hello.o的结果解析-7- 4.5本章小结-7- 第5章链接-8- 5.1链接的概念与作用-8- 5.2在Ubuntu下链接的命令-8- 5.3可执行目标文件hello的格式-8- 5.4hello的虚拟地址空间-8- 5.5链接的重定位过程分析-8- 5.6hello的执行流程-8- 5.7Hello的动态链接分析-8- 5.8本章小结-9- 第6章hello进程管理-10- 6.1进程的概念与作用-10- 6.2简述壳Shell-bash的作用与处理流程-10- 6.3Hello的fork进程创建过程-10- 6.4Hello的execve过程-10- 6.5Hello的进程执行-10- 6.6hello的异常与信号处理-10- 6.7本章小结-10- 第7章hello的存储管理-11- 7.1hello的存储器地址空间-11- 7.2Intel逻辑地址到线性地址的变换-段式管理-11- 7.3Hello的线性地址到物理地址的变换-页式管理-11- 7.4TLB与四级页表支持下的VA到PA的变换-11- 7.5三级Cache支持下的物理内存访问-11- 7.6hello进程fork时的内存映射-11- 7.7hello进程execve时的内存映射-11- 7.8缺页故障与缺页中断处理-11- 7.9动态存储分配管理-11- 7.10本章小结-12- 第8章hello的IO管理-13- 8.1Linux的IO设备管理方法-13- 8.2简述UnixIO接口及其函数-13- 8.3printf的实现分析-13- 8.4getchar的实现分析-13- 8.5本章小结-13- 结论-14- 附件-15- 参考文献-16- 第1章概述 1.1 Hello简介 P2P的过程:在linux中，hello.c经过cpp的预处理、ccl的编译、as的汇编、ld的链接最终成为可执行目标程序hello，在shell中键入启动命令后，shell为其fork，产生子进程，于是hello便从Program成为Process。 020的过程: shell为其execve，映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数执行目标代码，CPU为运行的hello分配时间片执行逻辑控制流。当程序运行结束后，shell父进程负责回收hello进程，内核删除相关数据结构。 1.2环境与工具 硬件环境：IntelG4560 x64CPU, 16GRAM 软件环境：Ubuntu18.04.3 开发与调试工具：vim，gcc，ld，edb，readelf，HexEdit 1.3中间结果 [if!supportLists]1. [endif]hello.i：hello.c预处理之后的文件 [if!supportLists]2. [endif]hello.s：编译之后的汇编文件 [if!supportLists]3. [endif]hello.o：汇编之后的目标执行 [if!supportLists]4. [endif]hello：链接实现的可执行目标文件 [if!supportLists]5. [endif]helloo.elf：hello.o的ELF格式 [if!supportLists]6. [endif]hello.elf：hello的ELF格式 1.4本章小结 本章主要简单介绍了hello的p2p，020过程，列出了本次实验信息：环境、中间结果。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 概念： 程序设计领域中，预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。典型地，由预处理器(preprocessor)对程序源代码文本进行处理，得到的结果再由编译器核心进一步编译。 作用： 1.对相关命令或语句的含义和功能作具体分析。 3.用实际值替换用#define定义的字符串 4.根据#if后面的条件决定需要编译的代码 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 预编译实现了： 1.将所有的#define删除，并展开所有的宏定义； 2.处理所有的预编译指令，例如：#if,#elif,#else,#endif; 3.处理#include预编译指令，将被包含的文件插入到预编译指令的位置； 4.添加行号信息文件名信息，便于调试； 5.删除所有的注释：///**/; 2.4本章小结 hello.c预处理生成hello.i,生成.i文件。 包括（1）去注释（2）宏替换（3）头文件展开（4）条件编译 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序 作用：将c语言文件变为汇编语言文件 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.3.1.数据：在执行main程序时首先将栈底指针入栈，同时令栈顶指针值等于栈底指针值，完成栈的初始化。然后通过减少栈顶指针值在栈中获得空间。此时的argc与argv[]存放在寄存器edi和rsi中，通过两个mov操作，将参数值进栈，从而完成了参数的传递。 常量 变量(全局(无)/局部) 向函数传递参数值、数组、指针 argc为图中-20(%rbp) 变量i 3.3.2赋值 将i赋值为0 3.3.3类型转换 调用atoi函数将字符串转为整型 3.3.4算术操作 对局部变量i累加 3.3.5关系操作 判断argc与4是否相等 判断i是否小于等于7 3.3.6数组/指针/结构操作 对argv数组进行操作，数组在存储空间中申请的是连续的内存。 3.3.7函数操作 终止程序 从键盘输入内读取字符串 打印到屏幕 字符串转为整型 need-to-insert-img 休眠 清除回车 3.3.8for循环 若参数个数为4，则跳转到.L2。此时进入for循环。for循环的控制变量为局部变量i，且初值为0的i满足i<8时进入循环。.L2将i的初值赋值为0，跳转到.L3。循环开始前执行.L3的第一条cmp语句，满足条件进入循环体，在汇编代码中的体现为跳转到.L4。在.L4中，调用了printf函数，通过main创建的栈为其传递参数到寄存器rdx和rsi中。然后调用sleep函数。注意到sleep函数中的参数为atoi函数，则首先需要执行atoi函数。仍是利用已经存储在栈中的argv数组，将所需值送入寄存器rdi，执行atoi后，返回值存储在寄存器eax中。再将其送入寄存器edi，则参数值成功传入sleep中，一次循环进行完成，将循环控制变量i的值+1，进入新一轮循环。当i的值等于8时，循环停止。 3.4本章小结 第三章主要还是详细分析编译器对hello.c的具体操作与生成的.s文件，了解各个数据和操作类型如何进行表示与实现。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编器将.s汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，它包含程序的指令编码。这个过程称为汇编，亦即汇编的作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 hello.o是可重定位文件，节头大小为64字节，数量为13，字符串表索引节头为12 4.4Hello.o的结果解析 从总体流程看，hello.s与hello.o的总体流程相同。从hello.o的反汇编文件可以看出每行十六进制数代表着一个指令操作，存在一一对应的关系。机器语言由二进制数构成，分为操作数和操作码。每条01序列构成的指令都有不同的含义。例如，对于一条机器指令，有些序列代表寄存器的编号。将操作码与代表寄存器的序列结合后生成新的01序列，此时看来会有机器语言中的操作数与汇编语言不一致的现象。其本质是机器语言的指令结合了操作码。hello.s文件中使用标志来进行分支转移，如指令jmp.L2。而在hello.o反汇编得到的文件中，则采用了相对寻址方式进行分支转移操作。.函数调用：hello.o反汇编文件中调用函数的操作为“call下条指令的地址”，在hello.s中则是“call函数名”。因为hello.c中调用的函数都是库函数，在进行下一步链接后才能最终确定其地址，所以在汇编时将call指令后的地址设置为0，等待链接。 主要差别如下： 1.反汇编代码跳转指令的操作数使用的不是段名称，所以在汇编成机器语言之后是确定的地址。2.在.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。 4.5本章小结 第四章解释了hello.s到hello.o的汇编过程，并使用readelf与objdump工具对hello.o的ELF文件分析与反汇编之后与hello.s的比较，表现了汇编语言到机器语言的转换。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。 5.2在Ubuntu下链接的命令 ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 1.读取ELF文件头 2.显示程序头表 3.读取头节表 5.4hello的虚拟地址空间 Type存储段的类型 特殊节的类型 VirtAddr首字节的虚拟地址 PhysAddr首字节的物理地址 Align对齐方式 为2的整数幂 FileSiz文件中所占的字节数 MemSiz存储器中所占字节数 5.5链接的重定位过程分析 hello相对于hello.o有如下不同： 1.hello相对hello.o多了很多的节类似于.init,.plt等 2.hello.o中的相对偏移地址到了hello中变成了虚拟内存地址 3.hello中相对hello.o增加了许多的外部链接来的函数。 4.hello.o中跳转以及函数调用的地址在hello中都被更换成了虚拟内存地址。 重定位： 在hello到hello.o中，首先是重定位节和符号定义，链接器将所有输入到hello中相同类型的节合并为同一类型的新的聚合节。 然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每一个符号。 当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 然后是重定位节中的符号引用，链接器会修改hello中的代码节和数据节中对每一个符号的引用，使得他们指向正确的运行地址。 5.6hello的执行流程 ld-2.27.so!_dl_start ld-2.27.so!_dl_init hello!_start libc-2.27.so!__libc_start_main -libc-2.27.so!__cxa_atexit -libc-2.27.so!__libc_csu_init hello!_init libc-2.27.so!_setjmp -libc-2.27.so!_sigsetjmp –libc-2.27.so!__sigjmp_save hello!main hello!puts@plt hello!exit@plt hello!printf@plt hello!atoi@plt hello!sleep@plt hello!getchar@plt ld-2.27.so!_dl_runtime_resolve_xsave-ld-2.27.so!_dl_fixup –ld-2.27.so!_dl_lookup_symbol_x libc-2.27.so!exit 5.7Hello的动态链接分析 (图5.6调用dl_init之前) （图5.7调用之后） 5.8本章小结 在本章中主要介绍了链接的概念与作用、hello的ELF格式，分析了hello的虚拟地址空间、重定位过程、执行流程、动态链接过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中的程序的实例，每一个进程都有它自己的地址空间，一般情况下，包括文本区域、数据区域、和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储区着活动过程调用的指令和本地变量。 6.2简述壳Shell-bash的作用与处理流程 Shell的作用： Shell是指一种应用程序，Shell应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 命令别名和快捷键 查看系统当中的别名自定义别名删除别名将别名写入环境变量配置文件则会永久生效 6.3Hello的fork进程创建过程 （图6.1fork（）创建进程） 6.4Hello的execve过程 1.使用execve就是一次系统调用，首先要做的将新的可执行文件的绝对路径从调用者（用户空间）拷贝到系统空间中。 2.在得到可执行文件路径后，就找到可执行文件打开，由于操作系统已经为可执行文件设置了一个数据结构，就初始化这个数据结构，保存一个可执行文件必要的信息。 3.可执行文件不是真正上能够自己运行的，需要有代理人来代理。在系统内核中有一个formats队列，循环遍历这个队列，看看现在被初始化的这个数据结构是哪个代理人可以代理的。如果没有就继续查看数据结构中的信息。按照系统配置了是否可以动态加载模块，加载一次模块，再循环遍历看是否有代理人前来认领。 4.找到正确的代理人后，代理人首先要做的就是放弃以前从父进程继承来的资源。 6.5Hello的进程执行 用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 6.6hello的异常与信号处理 运行时按下ctrl-C，hello进程终止，并向父进程发送SIGINT（进程终止）信号，由父进程负责完成子进程的回收 运行时按下ctrl-Z，子进程暂时挂起，向父进程发出SIGSTOP信号。此时子进程并不会被回收。当其收到特定信号时，会继续执行。执行结束后进程终止，向父进程发送SIGINT信号，被父进程回收 ctrl+z后jobs ctrl+z后pstree 运行过程中的无关输入被缓存到stdin，并随着printf指令被输出到结果 6.7本章小结 在本章中，阐明了进程的定义与作用，介绍了Shell的一般处理流程，调用fork创建新进程，调用execve执行hello，hello的进程执行，hello的异常与信号处理。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 1.物理地址 用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。 [if!supportLists]2. [endif]虚拟内存 例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000-1那个地址元素； 例如，要调用某个函数main（），代码不是callA，而是call0x0811111111，也就是说，函数A的地址已经被定下来了。没有这样的“转换”，没有虚拟地址的概念，这样做是根本行不通的。 3.逻辑地址 逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。以上例，我们说的连接器为A分配的0x08111111这个地址就是逻辑地址。 “一个逻辑地址，是由一个段标识符加上一个指定段内相对地址的偏移量，表示为[段标识符：段内偏移量]，也就是说，上例中那个0x08111111，应该表示为[A的代码段标识符:0x08111111]，这样，才完整一些” [if!supportLists]3. [endif]线性地址 跟逻辑地址类似，它也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件页式内存的转换前地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 机器语言指令中出现的内存地址，都是逻辑地址，需要转换成线性地址，再经过MMU(CPU中的内存管理单元)转换成物理地址才能够被访问到。 在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值 7.3Hello的线性地址到物理地址的变换-页式管理 通过分页机制，具体的说，就是通过页表查找来对应物理地址。 准确的说分页是CPU提供的一种机制，Linux只是根据这种机制的规则，利用它实现了内存管理。 在保护模式下，控制寄存器CR0的最高位PG位控制着分页管理机制是否生效，如果PG=1，分页机制生效，需通过页表查找才能把线性地址转换物理地址。如果PG=0，则分页机制无效，线性地址就直接做为物理地址。 分页的基本原理是把内存划分成大小固定的若干单元，每个单元称为一页（page），每页包含4k字节的地址空间（为简化分析，我们不考虑扩展分页的情况）。这样每一页的起始地址都是4k字节对齐的。为了能转换成物理地址，我们需要给CPU提供当前任务的线性地址转物理地址的查找表，即页表(pagetable)。注意，为了实现每个任务的平坦的虚拟内存，每个任务都有自己的页目录表和页表。 为了节约页表占用的内存空间，x86将线性地址通过页目录表和页表两级查找转换成物理地址。 32位的线性地址被分成3个部分： 最高10位 Directory 页目录表偏移量，中间10位 Table是页表偏移量，最低12位Offset是物理页内的字节偏移量。 页目录表的大小为4k（刚好是一个页的大小），包含1024项，每个项4字节（32位），项目里存储的内容就是页表的物理地址。如果页目录表中的页表尚未分配，则物理地址填0。 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 当fork函数被shell调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。并且创建hello进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。 execve函数执行了以下几个操作： 1.删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2.映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3.映射共享区域。 4.设置程序计数器（PC）。execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 1、当内存管理单元（MMU）中确实没有创建虚拟物理页映射关系，并且在该虚拟地址之后再没有当前进程的线性区（vma）的时候，可以肯定这是一个编码错误，这将杀掉该进程； 2、当MMU中确实没有创建虚拟页物理页映射关系，并且在该虚拟地址之后存在当前进程的线性区vma的时候，这很可能是缺页中断，并且可能是栈溢出导致的缺页中断； 3、当使用malloc/mmap等希望访问物理空间的库函数/系统调用后，由于linux并未真正给新创建的vma映射物理页，此时若先进行写操作，将和2产生缺页中断的情况一样；若先进行读操作虽然也会产生缺页异常，将被映射给默认的零页，等再进行写操作时，仍会产生缺页中断，这次必须分配1物理页了，进入写时复制的流程； 4、当使用fork等系统调用创建子进程时，子进程不论有无自己的vma，它的vma都有对于物理页的映射，但它们共同映射的这些物理页属性为只读，即linux并未给子进程真正分配物理页，当父子进程任何一方要写相应物理页时，导致缺页中断的写时复制； 7.9动态存储分配管理 1）首次适应：首次适应策略要求空闲区按其起始地址从小到大排列，当某一用户作业要求装入内存时，存储分配程序从起始地址最小的空间区开始扫描，直到找到满足该作业要求的空闲区为止。 2）循环首次适应：在查找空闲区时，不再每次从链首开始查找，而是从上一次找到的空闲区的下一个空闲区开始查找，直到找到一个能满足要求的空闲区为止，并从中划出一块与请求大小相等的内存空间分给该作业。 3）最佳适应：该策略总是把满足要求，又使最小的空闲区分配给请求作业，即在空闲区表中，按空闲区的大小从小到大排列，建立索引，当用户作业请求内存空间时，从索引表中找到第一个满足该作业的空闲区分给它。 4）最差适应：该策略总是把最大的空闲区分配给请求作业，空闲区表（空闲区链）中的空闲分区要按大小从大到小进行排序，自表头开始查找到第一个满足要求的空闲分区分配给作业。 7.10本章小结 本章主要介绍了hello的存储器地址空间、intel的段式管理、hello的页式管理，以intelCore7在指定环境下介绍了VA到PA的变换、物理内存访问，还介绍了hello进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 （第7章 2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 1.read和write函数，例子用法如下，第一个参数为文件描述符fd,位于stdio.h中 read(STDIN_FILENO,buf,BUFFSIZE); write(STDOUT_FILENO,buf,BUFFSIZE); 常用方式 while((n=read(STDIN_FILENO,buf,BUFFSIZE))!=n) { if(write(STDOUT_FILENO,buf,n)!=n) perror("writeerror"); } 其中STDIN_FILENO要求unistd.h 2.getc和putc函数，例子用法如下 while((c=getc(stdin))!=EOF) if(putc(c,stdout)==EOF) perror("error"); 3.fgets(buf,MAXSIZE,stdin); 从标准输入读入一次读一行，返回buf，以换行符结束，后面跟一个空字符 如果读到文件末尾，返回一个null指针 8.3printf的实现分析 C语言中，参数压栈的方向是从右往左。也就是说，当调用printf函数的适合，先是最右边的参数入栈。 fmt是一个指针，这个指针指向第一个const参数（constchar*fmt)中的第一个元素。fmt也是个变量，它的位置，是在栈上分配的，它也有地址。 对于一个char*类型的变量，它入栈的是指针，而不是这个char*型变量。 sys_call: ;ecx中是要打印出的元素个数 ;ebx中的是要打印的buf字符数组中的第一个元素 ;这个函数的功能就是不断的打印出字符，直到遇到：'\0' ;[gs:edi]对应的是0x80000h：0采用直接写显存的方法显示字符串 xorsi,si movah,0Fh moval,[ebx+si] cmpal,'\0' je.end mov[gs:edi],ax incsi loop: sys_call .end: ret 无论如何printf()函数都不能确定参数 究竟在什么地方结束，也就是说，它不知道参数的个数。它只会根据format中的打印格式的数目依次打印堆栈中参数format后面地址的内容。这样就存在一个可能的缓冲区溢出问题。。 8.4getchar的实现分析 #define getchar() getc(stdin)。getchar有一个int型的返回值.当程序调用getchar时.程序就等着用户按键.用户输入的字符被存放在键盘缓冲区中.直到用户按回车为止(回车字符也放在缓冲区中).当用户键入回车之后,getchar才开始从stdin流中每次读入一个字符.getchar函数的返回值是用户输入的第一个字符的ASCII码,如出错返回-1,且将用户输入的字符回显到屏幕.如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取.也就是说,后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键. 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法、UnixIO接口及其函数，分析了printf函数和getchar函数。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 1.编写，通过editor将代码键入hello.c 2.预处理，将hello.c调用的所有外部的库展开合并到一个hello.i文件中 3.编译，将hello.i编译成为汇编文件hello.s 4.汇编，将hello.s会变成为可重定位目标文件hello.o 5.链接，将hello.o与可重定位目标文件和动态链接库链接成为可执行目标程序hello 6.运行：在shell中输入./hello1170300127 wumenglin 7.创建子进程：shell进程调用fork为其创建子进程 8.运行程序：shell调用execve，execve调用启动加载器，加映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数。 9.执行指令：CPU为其分配时间片，在一个时间片中，hello享有CPU资源，顺序执行自己的控制逻辑流 10.访问内存：MMU将程序中使用的虚拟内存地址通过页表映射成物理地址。 11.动态申请内存：printf会调用malloc向动态内存分配器申请堆中的内存。 12.信号：如果运行途中键入ctr-cctr-z则调用shell的信号处理函数分别停止、挂起。 13.结束：shell父进程回收子进程，内核删除为这个进程创建的所有数据结构。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.c源代码 hello.c预处理得到的修改了的源程序 hello.i编译后生成的hello.s hello.s汇编后生成的hello.o hello.o使用objdump反汇编得到的结果 hello.o与动态库链接得到的hello可执行文件 hello.elf hello的ELF格式 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1]林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42. [2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999. [3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998 [1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL]. Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/ collection/anatmorp. （参考文献0分，缺失-1分）
第2篇文章[5]
软件构造实验心得（二） 
第3篇文章[5]
软件构造实验心得（四） 
第4篇文章[5]
软件构造实验心得（一） 从软件构造这门课中，我学到了很多编程知识而这门课的四个实验，静下心来做，更是能令人获益匪浅下面分享出我的实验报告，供其他同学们参考 
第5篇文章[5]
软件构造实验心得（三）
第6篇文章[3]
spfa+多源转单源前向星模板 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constintmaxn=2*1e5; constllinf=1e12; structedge{ intto; llw; intnext; }e[4*maxn+5]; structnode{ intto; llw; booloperator<(nodea)const{ returnw>a.w; } }; inthead[maxn+10]; inttot=0; lld[maxn+10]; lla[maxn+10]; boolvis[maxn+10]; intn,m; voidadd(intx,inty,llw) { e[tot].to=y,e[tot].next=head[x],e[tot].w=w,head[x]=tot++; e[tot].to=x,e[tot].next=head[y],e[tot].w=w,head[y]=tot++; } voidinit() { scanf("%d%d",&n,&m); memset(vis,0,sizeof(vis)); memset(head,-1,sizeof(head)); d[0]=0; a[0]=0; intx,y; llw; for(inti=1;i<=m;i++) { scanf("%d%d%lld",&x,&y,&w); add(x,y,2*w); } for(inti=1;i<=n;i++) scanf("%lld",&a[i]); for(inti=1;i<=n;i++) { d[i]=inf; add(0,i,a[i]); } } voidspfa() { priority_queue<node>q; q.push((node){0,0}); while(!q.empty()) { nodex=q.top(); q.pop(); intnow=x.to; if(vis[now])continue; vis[now]=1; for(inti=head[now];i!=-1;i=e[i].next) { llw=e[i].w; intnow2=e[i].to; if(d[now]+w<d[now2]) { d[now2]=d[now]+w; q.push((node){now2,d[now2]}); } } } } intmain() { //freopen("in.txt","r",stdin); init(); spfa(); for(inti=1;i<=n;i++) printf("%lld",d[i]); return0; } 
第7篇文章[0]
Java软件构造SoftwareConstruction(四） 第三次实验相关 关于Java自带类Date与Calendar的使用关于正则表达式 关于Java自带类Date与Calendar的使用 Dated=newDate();//创建一个代表系统当前日期 d=Date(2021-1900,7-1,1);//创建一个代表2021.7.1日期的Date，注意参数的设置 //获取年月日方法如下 intyear=d.getYear()+1900; intmonth=d.getMonth()+1; intdate=d.getDate(); 然后就发现这小破玩意基本被更厉害的Calendar替代了QAQ这里再介绍关于Calendar的使用Calendar是一个抽象类，且加上了protected修饰，所以要用其getInstance方法来构造 Calendars=Calendar.getInstance();//默认当前日期 s.set(2021,7-1,1);//调用set来设置，如此设置为2021.7.1 //获取日期要用Calendar自带的常数来进行获取 //获得年月日 intyear=s.get(Calendar.YEAR); intmonth=s.get(Calendar.MONTH)+1; intdate=s.get(Calendar.DATE); 关于正则表达式 首先要注意的是，在java中\表示插入一个正则表达式的反斜线，其后的字符具有特殊的意义一些常用的匹配为 字符说明+一次或多次匹配前面的字符或子表达式。?零次或一次匹配前面的字符或子表达式。*零次或多次匹配前面的字符或子表达式。{n}n是非负整数。正好匹配n次。x或符号y匹配x或y。[xyz]字符集。匹配包含的任一字符。[a-z]字符范围。匹配指定范围内的任何字符。\d数字字符匹配。等效于[0-9]。 对于模式匹配的基本操作为 Stringcontent="asdjdsfjsdlf13213asakd.,[l[12"; Patternpattern=Pattern.compile("[a-z]{3}"); Matchermatcher=pattern.matcher(content); if(matcher.find()){ System.out.println("YES"); } 
第8篇文章[0]
Java软件构造SoftwareConstruction（五） 第三次实验相关 关于Scanner与java.util.NoSuchElementException关于正则表达式（续）关于捕获组 关于gitcheckout 关于Scanner与java.util.NoSuchElementException 一次关闭（System.in)后则永久关闭，再次打开会出现java.util.NoSuchElementException错误。 关于正则表达式（续） 注意大括号属于特殊字符需要加\{来匹配 关于捕获组 捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。特殊的组group(0)代表整个表达式。下列代码为捕获一个,152-1234-1234}中152-1234-1234电话号的实例 Stringphone=newString(); pattern=Pattern.compile(",(\\d{3}-\\d{4}-\\d{4})\\}"); matcher=pattern.matcher(content); if(matcher.find()==true){ phone=matcher.group(1); } elsereturnfalse; 关于gitcheckout git创建新分支的操作为 gitbranchbranchName 切换到新分支的操作为 gitcheckoutbranchName 将这两个操作合并在一起为 gitcheckout-bbranchName 在切换分支是是对当前HEAD指针指向的变化下图为本次实验分支指向的变化 
第9篇文章[4]
辛普森公式之求椭圆面积 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constdoubleeps=1e-7; doublea,b; doublef(doublex) { returnb*sqrt(1-x*x/(a*a)); } doublesimpson(doublel,doubler) { doublemid=(l+r)/2; return(r-l)*(f(l)+f(r)+4*f(mid))/6; } doublesolve(doublel,doubler) { doublemid=(l+r)/2; if(fabs(simpson(l,r)-simpson(l,mid)-simpson(mid,r))<=eps) { returnsimpson(l,r); } returnsolve(l,mid)+solve(mid,r); } intmain() { intt; scanf("%d",&t); doublel,r; while(t--) { scanf("%lf%lf%lf%lf",&a,&b,&l,&r); printf("%.3lf\n",2*solve(l,r)); } } 
第10篇文章[0]
Java软件构造（七） 杂项总结 抽象类适配器内聚和耦合表示泄露default方法LSP和JAVAset与mutable黑盒与白盒最后的最后 抽象类 在多种设计模式中，均有采用继承抽象类来复用代码，同时进行委派实现个性化的操作 适配器 设计模式中最不擅长的一种模式，这是一种结构型模式，是直接进行委派不适配是，增加接口在适配器子类中进行转换适配和隐藏之前委派的一种模式。 内聚和耦合 高内聚低耦合是软件工程的重要概念，描述的功能应该是单一、简单、易理解且模块化的。 表示泄露 不仅影响不变性，也影响表示独立性，检查时从public-private、外部参数赋值给可变属性，返回值为可变属性等几个方面来进行检查。 default方法 通过其在接口中统一实现某些功能。无需在各个类中重复实现它，增量式增加而不破坏原来的类。 LSP和JAVA 子类型方法参数的逆变，在实际运行中算为overloadQAQ。同时Arrays也是协变的。Generics不是协变的。 set与mutable mutable对象在set集合类中发生改变后，集合类行为不确定。 黑盒与白盒 白盒着眼于代码，黑盒着眼于模块，如白盒测试和黑盒测试，一个需要检查代码，一个只关注最后行为，白盒复用源代码可见，黑盒复用源代码不可见，白盒框架代码层面的继承，黑盒框架是实现特定接口/delegation进行框架扩展。 最后的最后 明天就是期末考试了，越复习越觉得之前写的代码还有很多很多可以修改的地方，想着时间再多一点，再尽善尽美一些。日升不滞哇，总会有遗憾，但遗憾是完善的过程，所以不能停止思考，更不能停止书写代码，不断前行，朝着理想的彼岸，绝对的理念进发。 
第11篇文章[3]
字符串（马拉车+KMP+Tries树模板） 马拉车 voidmanacher() { intpos=0,r=0; for(inti=0;i<n;i++) { if(i<r)p[i]=min(p[2*pos-i],r-i); elsep[i]=1; while(s2[i-p[i]]==s2[i+p[i]])p[i]++; if(i+p[i]>r)r=i+p[i],pos=i; } } voidinit() { scanf("%s",s); n=strlen(s); intcnt=0; s2[0]='#'; for(inti=0;i<n;i++) { s2[++cnt]=s[i]; s2[++cnt]='#'; } n=cnt; } 异或Tries树 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constintmaxn=3200005; intTries[maxn][2]; intcnt[maxn]; inttot; intn,m; voidinit() { memset(cnt,0,sizeof(cnt)); memset(Tries,0,sizeof(Tries)); tot=0; } voidinsert(intx) { intnow=0; for(inti=31;i>=0;i--) { if(x&(1<<i)) { if(Tries[now][1]==0) Tries[now][1]=++tot; now=Tries[now][1]; } else { if(Tries[now][0]==0) Tries[now][0]=++tot; now=Tries[now][0]; } } } voidsolve(intx) { intnow=0; intans=0; for(inti=31;i>=0;i--) { if(x&(1<<i)) { //printf("%d%d\n",i,x); if(Tries[now][0]) { now=Tries[now][0]; } else now=Tries[now][1],ans+=(1<<i); } else { if(Tries[now][1]) { ans+=(1<<i); now=Tries[now][1]; } else now=Tries[now][0]; } } printf("%d\n",ans); } intmain() { //freopen("in.txt","r",stdin); intt; scanf("%d",&t); for(inti=1;i<=t;i++) { scanf("%d%d",&n,&m); intx; init(); for(intj=1;j<=n;j++) { scanf("%d",&x); insert(x); } printf("Case#%d:\n",i); for(intj=1;j<=m;j++) { scanf("%d",&x); solve(x); } } return0; } KMP，Codefroces1137BCampSchedule #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; chars[500005]; chars2[500005]; intnextt[500005]; intn,n2; stringans; voidgetc() { inti; intj=-1; nextt[0]=-1; for(i=0;i<n2;) if(j==-1||s2[i]==s2[j])nextt[++i]=++j; elsej=nextt[j]; } intmain() { //freopen("in.txt","r",stdin); scanf("%s",s); scanf("%s",s2); intnum1=0,num0=0; n=strlen(s); n2=strlen(s2); getc(); for(inti=0;i<n;i++) if(s[i]=='1')num1++; elsenum0++; intcnt=0; if(n<n2) { cout<<s<<endl; return0; } while(num1>0&&num0>0) { if(s2[cnt]=='0') { if(num0>0) { num0--; ans+='0'; cnt++; } else break; } else { if(num1>0) { num1--; ans+='1'; cnt++; } else break; } if(cnt==n2) cnt=nextt[cnt]; } while(num0)num0--,ans+='0'; while(num1)num1--,ans+='1'; cout<<ans<<endl; return0; } 写的好乱好杂 自己水平好低 有时间来改改吧 
第12篇文章[0]
Java软件构造Softwareconstruction(三) 第三次实验部分及相关课程学习 相关课程可复用性四个层次上的可复用性LSP原则LiskovSubstitutionPrinciple委派delegation 可维护性5个设计原则SOLIDSRPOCPISPDIP 面向可维护性和可复用性的设计模式创建型模式StructuralpatternsBehavioralpatterns 第三次实验关于github 相关课程 可复用性 四个层次上的可复用性 代码层次，模块层次：类/接口，库层次：API/包，系统层次：框架 LSP原则LiskovSubstitutionPrinciple 子类型多态：客户端可用统一的方式处理不同类型的对象Sameorstrongerinvariants更强的不变量Sameorweakerpreconditions更弱的前置条件Sameorstrongerpostconditions更强的后置条件所以子类型方法参数为逆变，子类型返回值为协变，异常类型为协变协变即为越来越具体，逆变即为越来越抽象 委派delegation 委派：一个对象请求另一个对象的功能委派模式：通过运行时动态绑定，实现对其他类中代码的动态复用当子类只需要复用父类的一部分方法时，就可以不需要使用继承，而用委派机制来实现，同时一个类不需要继承另一个类的全部方法，就通过委派机制调用部分方法。委派的三种类型是，Use，Association，Composition/aggregation 可维护性 5个设计原则SOLID SRP:单一责任原则OCP:开放-封闭原则LSP:Liskov替换原则DIP：依赖转置原则ISP：接口聚合原则 SRP 不应该有多于1个原因让你的ADT发生变化，否则就拆分开 OCP 模块的行为可扩展，模块的代码不应该修改，解决方案：抽象技术 ISP 不能强迫客户端依赖于他们不需要接口，只提供必要接口 DIP 抽象的模块不应依赖于具体的模块 面向可维护性和可复用性的设计模式 创建型模式 工厂方法模式：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 Structuralpatterns 适配器模式：通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。装饰器模式：当特性需要组合时，对每一个特性构造子类，通过委派机制增加到对象上，就像穿一层又一层的衣服 Behavioralpatterns 策略模式：有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里模板模式：做事情的步骤一样，但具体方法不同，共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。迭代器模式：客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型visitor模式：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT。 第三次实验 关于github github在一开始的时候抽风了QAQ，所以一直没有创建仓库，等github好了的时候再创建仓库pull的时候发现查询后发现出现这个问题是因为本地仓库和远程仓库变成独立两个仓库了（一开始没有clone仓库）pull命令后紧接着使用–allow-unrelated-history选项来解决问题。 
第13篇文章[3]
tarjan求最小加入边而为ebcc模板 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constintmaxn=1e4; constllinf=1e8; intcnt,top,num,tot; intn,r; intdeg[maxn+5]; intdfn[maxn+5],low[maxn+5],vis[maxn+5],s[maxn+5],color[maxn+5]; structedge{ intto,next; }e[2*maxn+5]; inthead[maxn+5]; voidinit() { memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(vis,0,sizeof(vis)); memset(deg,0,sizeof(deg)); memset(head,-1,sizeof(head)); cnt=0; top=0; num=0; tot=0; } voidtarjan(intx,intfa) { dfn[x]=low[x]=++cnt; vis[x]=1; s[++top]=x; for(inti=head[x];i!=-1;i=e[i].next) { intv=e[i].to; if(!dfn[v]) { tarjan(v,x); low[x]=min(low[x],low[v]); } elseif(vis[v]&&v!=fa) { low[x]=min(low[x],low[v]); } } if(low[x]==dfn[x]) { color[x]=++num; vis[x]=0; while(s[top]!=x) { //printf("%d%d\n",x,s[top]); color[s[top]]=num; vis[s[top--]]=0; } top--; } } voidadd(intu,intv) { e[tot].to=v,e[tot].next=head[u],head[u]=tot++; } intmain() { //freopen("in.txt","r",stdin); scanf("%d%d",&n,&r); init(); intx,y; for(inti=1;i<=r;i++) { scanf("%d%d",&x,&y); add(x,y); add(y,x); } for(inti=1;i<=n;i++) if(!dfn[i]) tarjan(i,0); //printf("%d\n",num); for(inti=1;i<=n;i++) for(intj=head[i];j!=-1;j=e[j].next) { x=e[j].to; if(color[x]!=color[i]) { deg[color[x]]++,deg[color[i]]++; } } intans=0; for(inti=1;i<=num;i++) if(deg[i]==2)ans++; printf("%d\n",(ans+1)/2); return0; } 
第14篇文章[3]
一些细节 引用参数的数组降价 优先队列的缺省定义 动态规划的边界条件 c++的全局变量，慎 关于memset造成MLE的问题，AC自动机！ 双目运算符的优先级！！ 
第15篇文章[0]
软件构造JavaSoftware(二） 第二次实验与相关课程总结 课程总结抽象数据类型可变数据类型不可变数据类型operationsofanabstracttype表示独立性测试抽象数据类型不变量AbstractionFunction 面向对象接口Interface重载与重写抽象类泛型 第二次实验总结关于测试优先关于Safetyfromrepexposure和Representationinvariant关于文件读入总结 课程总结 抽象数据类型 抽象数据类型与表示独立性：如何设计良好的抽象数据结构，通过封装来避免客户端获取数据的内部表示（即“表示泄露”），避免潜在的bug 在client和implementer之间建立“防火墙” 可变数据类型 可变类型的对象：提供了可改变其内部数据的值的操作，例如List 不可变数据类型 不变数据类型：其操作不改变内部值，而是构造新的对象，例如int,String operationsofanabstracttype 构造器：可能实现为构造函数或静态函数变值器：改变对象属性的方法，通常返回为void观察器：观察对象属性，如Thesize()methodofList生产器：从旧的对象中创建一个新的对象，如concat()methodofString 表示独立性 client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。 测试抽象数据类型 测试creators,producers,andmutators：调用observers来观察这些operations的结果是否满足spec；测试observers：调用creators,producers,andmutators等方法产生或改变对象，来看结果是否正确。 不变量 immutability是典型的不变量。immutable的抽象数据类型不能有变值器。对于一些属性不变量，采用privatefinal进行修饰，同时采用防御式编程来保证其不变性。 AbstractionFunction 由表示空间映射到抽象空间称为AF。ADT开发者关注表示空间R，client关注抽象空间A，它是满射但未必单射，也未必双射。 面向对象 接口Interface Interface和Class:定义和实现ADT接口之间可以继承与扩展一个类可以实现多个接口一个接口可以有多种实现类接口中只确定ADT规约而不具体实现方法，实际当中更倾向于使用接口来定义变量。使用接口来完成信息隐藏，客户端仅使用接口中定义方法，客户端无法直接访问属性。 重载与重写 关于重写/覆盖：若超类中加了final修饰则无法重载，重写的函数的具体使用是在运行时决定，重写的函数参数与原函数相同。关于重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型，方便client调用，client可用不同的参数列表，调用同样的函数，重载函数是在编译时进行的静态类型检查。 抽象类 介于接口与类之间，如果某些操作是所有子类型都共有，但彼此有差别，可以在父类型中设计抽象方法，在各子类型中重写 泛型 泛型是一种类型变量，泛型类，泛型接口，泛型方法，其定义中包含了类型变量 第二次实验总结 关于测试优先 设计测试样例时避免重复造轮子，看似写了很多行测试样例，但却没有实际发现错误，同时对于equals和==这部分测试要多留心。 关于Safetyfromrepexposure和Representationinvariant 对于表示的独立性采用checkRep来进行检查，checkRep使用assert语句如assertvertices2.equals(vertices);对于表示泄露的预防，所有属性都采用privatefinal修饰，并且都采用Collections.unmodifiableSet或者new一个新值来进行防御式拷贝。 关于文件读入 在第一次实验中采用了一种文件读入方法，这里采用另一种文件读入打开文件输入流，用scanner按行读入，然后采用分隔符或正则语言进行匹配 InputStreamis=newFileInputStream(corpus); Scannerscan=newScanner(is); while(scan.hasNext()){ List<String>inputString=Arrays.asList(scan.nextLine().split("")); Iterator<String>it=inputString.iterator(); StringlastString=newString(); StringnowString=newString(); while(it.hasNext()){ lastString=nowString; nowString=it.next(); nowString=nowString.toLowerCase(); graph.add(nowString); intnowWeight; if(lastString.isEmpty()==false){ nowWeight=graph.set(lastString,nowString,0); graph.set(lastString,nowString,nowWeight+1); Map<String,Integer>targets=graph.targets(lastString); } } } 总结 没学习那些概念之前，做实验稍显吃力，学习了之后发现不过按图索骥，实现起来又较为简单 
第16篇文章[6]
poj1220numberbaseconversion高精度进制转换java c++和java两种来写，感觉java写着要顺一些，虽然代码存在很多java的错误习惯，还是贴一下，所以一定要好好学java啊orz importjava.math.BigDecimal; importjava.math.BigInteger; importjava.util.Scanner; importjava.util.*; importjava.text.*; importjava.io.*; publicclassMain{ publicstaticintgetint(charch) { if(Character.isDigit(ch))return(ch-'0'); elseif(Character.isUpperCase(ch))return(ch-'A'+10); elsereturn(ch-'a'+36); } publicstaticchargetchar(inti) { if(i>=0&&i<=9)return(char)(i+'0'); elseif(i>=10&&i<=35)return(char)(i-10+'A'); elsereturn(char)(i-36+'a'); } publicstaticvoidmain(String[]args){ Scannercin=newScanner(newBufferedInputStream(System.in)); intt=cin.nextInt(); while(t--!=0) { Strings; Stringans=newString(); intbase1,base2; base1=cin.nextInt(); base2=cin.nextInt(); s=cin.next(); BigIntegerresult=BigInteger.valueOf(0); for(inti=0;i<s.length();i++) { result=result.multiply(result.valueOf(base1)).add(result.valueOf(getint(s.charAt(i)))); } while(!result.equals(BigInteger.ZERO)) { ans=getchar(result.mod(result.valueOf(base2)).intValue())+ans; result=result.divide(result.valueOf(base2)); } if(ans.length()==0)ans+='0'; System.out.println(base1+""+s+'\n'+base2+''+ans); System.out.println(); } } } c++呢就是从从第i次开始，(i=1,2,3 )每一次都从首位开始枚举字符串，不断地求商取对应进制的模，求出来对应进制第i位上的数，直至结束。 
第17篇文章[3]
kruscal+lca模板求最小值 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constintmaxn=1e4; constllinf=1e8; intt; intn,m,w; intf[maxn+5][20]; inthead[maxn+5]; intfa[maxn+5]; intdp[maxn+5][20]; structnode{ intfrom,to,w; booloperator<(nodea)const{ returnw>a.w; } }e2[5*maxn+5]; structedge{ intto,w,next; }e[10*maxn+5]; inttot=0; intdep[maxn+5]; voidadd(intx,inty,intw) { e[tot].to=y,e[tot].w=w,e[tot].next=head[x],head[x]=tot++; e[tot].to=x,e[tot].w=w,e[tot].next=head[y],head[y]=tot++; } intfind(intx) { if(fa[x]==x)returnx; returnfa[x]=find(fa[x]); } booljudge(intx,inty) { returnfind(x)==find(y); } voidmerge(intx,inty) { x=find(x),y=find(y); fa[x]=y; } voidkruscal() { sort(e2+1,e2+1+m); for(inti=1;i<=m;i++) { intu=e2[i].from; intv=e2[i].to; if(judge(u,v))continue; add(u,v,e2[i].w); merge(u,v); } } voiddfs(intx,intfather,intw) { dep[x]=dep[father]+1; f[x][0]=father; dp[x][0]=w; for(inti=1;i<=19;i++) { if(f[x][i-1]==0)break; f[x][i]=f[f[x][i-1]][i-1]; dp[x][i]=min(dp[x][i-1],dp[f[x][i-1]][i-1]); } for(inti=head[x];i!=-1;i=e[i].next) { intv=e[i].to; //printf("%d%d%d\n",x,v,i); if(v==father)continue; dfs(v,x,e[i].w); } } intlca(intu,intv) { intans=inf; if(dep[u]<dep[v])swap(u,v); for(inti=19;i>=0;i--) { if(dep[f[u][i]]>=dep[v]) { ans=min(ans,dp[u][i]); u=f[u][i]; } } if(u==v)returnans; for(inti=19;i>=0;i--) { if(f[u][i]!=f[v][i]) { ans=min(ans,dp[u][i]); ans=min(ans,dp[v][i]); u=f[u][i]; v=f[v][i]; } } //printf("%d%d\n",u,v); ans=min(ans,dp[u][0]); ans=min(ans,dp[v][0]); returnans; } intmain() { //freopen("in.txt","r",stdin); scanf("%d%d",&n,&m); memset(head,-1,sizeof(head)); memset(f,0,sizeof(f)); for(inti=1;i<=n;i++) fa[i]=i; for(inti=1;i<=m;i++) { scanf("%d%d%d",&e2[i].from,&e2[i].to,&e2[i].w); } kruscal(); dep[0]=0; for(inti=1;i<=n;i++) if(fa[i]==i) dfs(i,0,0); intx,y,q; scanf("%d",&q); for(inti=1;i<=q;i++) { scanf("%d%d",&x,&y); if(!judge(x,y))printf("-1\n"); else printf("%d\n",lca(x,y)); } return0; } 
第18篇文章[0]
Java软件构造SoftwareConstruction（一） Java软件构造SoftwareConstruction（一） 文章目录 Java软件构造SoftwareConstruction（一） 前言第一节课内容自我总结第一次实验git操作java读入命令行读入文件读入 一些总结 前言 已经做好学习信息安全专业的准备，那么在学习这门课程时，也就有了自己在心中定下的要求。课上也提到本课内容及其丰富，虽然压缩了一些学时，但内容没有减少太多。也许未来会有些痛苦吧：），但现在站在山脚下的我，窥不见山的全貌，也难体会爬山的苦累。那么就只是爬山就好了，功不唐捐罢，积跬步至千里罢，进一步有进一步的欢喜罢，不管山有多高，只是不停爬山罢。也许有一天能一览众山小，能守得云开见月明，而我记录下这些足迹，告诉自己这些太远的路，是因为什么而出发。 第一节课内容自我总结 第一次实验 git操作 使用gitremote的操作来链接远程仓库采用的较多的操作分别为` gitremote//列出当前远程分支 gitremote-v//列出当前远程分支带url的信息 gitremoteaddorigin@git.com:~~~~~//以ssh的方式，本地远程分支命名为origin来连接仓库 gitremotermorigin//删除本地指定为origin的远程地址 gitadd.//将文件添加至暂存区 gitcommit-m""//将暂存区内容上传至本地仓库,-m后接备注信息 gitpushoriginmaster//上传至远程仓库，后两项为远程仓库名和分支名 java读入 命令行读入 一开始采用如下方法判断 publicstaticintcommand_line_input(intcitations[]){ intpaper_num=0;//初始化数组长度 Scannerscan=newScanner(System.in);//创造输入流对象 while(scan.hasNextInt()){ citations[paper_num++]=scan.nextInt();//读入论文 if(citations[paper_num-1]<0){//当论文引用量小于0时为非法输入 illegal_input(); scan.close(); return-1; } }`在这里插入代码片` if(scan.hasNext()){//若读入了非整型数字，同样为非法操作 illegal_input(); scan.close(); return-1; } scan.close(); returnpaper_num; } 后发现，while(scan.hasNextInt())无法处理读入回车停止的问题，于是采用先读入一行字符串后转换为int的形式进行 publicstaticintcommand_line_input(intcitations[]){ Scannerscan=newScanner(System.in);//创造输入流对象 Stringcitations_string[]=null;//初始化读入字符串 citations_string=scan.nextLine().split("");//读入带空格字符串 scan.close(); intpaper_num=citations_string.length;//初始化数组长度 citations=newint[paper_num]; for(inti=0;i<paper_num;i++){ try{ citations[i]=Integer.valueOf(citations_string[i]); } catch(Exceptione){//遇到不是数字的情况输出非法信息 illegal_input(); return-1; } if(citations[i]<0){ illegal_input();//引用量小于0也输出非法信息 return-1; } } returnpaper_num; } 文件读入 首先是关于File类的一些基础性问题，在引用绝对路径时，注意不同操作系统文件路径分隔符不同的问题，采用File.separator来解决此类问题，即 Filefile=newFile("d:"+File.seprator+"xx.txt"); 也可以用相对路径的方法新建File对象，根目录为project的根文件夹 Filefile=newFile(""src"+File.separator+"test"+File.separator+"input.txt"); 对于文件读入问题，可新建一个字节输入流，然后再读入即可 InputStreamis=newFileInputStream("src"+File.separator+"test"+File.separator+"input.txt"); Scannerfile_scan=newScanner(is); 一些总结 java的数组为引用传递 
第19篇文章[3]
AC自动机模板 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> #definefr(i,a,b)for(inti=a;i<=b;i++) usingnamespacestd; typedeflonglongll; constintmaxn=100005; inttries[500005][26]; intcnt[500005]; intfail[500005]; inttot=0; intn; charx[1000005]; voidinsert() { intl=strlen(x); intnow=0; for(inti=0;i<l;i++) { intw=x[i]-'a'; if(!tries[now][w]) tries[now][w]=++tot; now=tries[now][w]; } cnt[now]++; } voidgetf() { queue<int>q; for(inti=0;i<26;i++) { if(tries[0][i]) { fail[tries[0][i]]=0; q.push(tries[0][i]); } } while(!q.empty()) { intfront=q.front(); q.pop(); for(inti=0;i<26;i++) { if(tries[front][i]) { fail[tries[front][i]]=tries[fail[front]][i]; q.push(tries[front][i]); } else tries[front][i]=tries[fail[front]][i]; } } } intquery() { intl=strlen(x); intnow=0; intans=0; for(inti=0;i<l;i++) { intw=x[i]-'a'; now=tries[now][w]; for(intj=now;j!=0&&cnt[j]!=-1;j=fail[j]) { ans+=cnt[j]; cnt[j]=-1; } } returnans; } intmain() { //freopen("in.txt","r",stdin); intt; scanf("%d",&t); while(t--) { memset(cnt,0,sizeof(cnt)); memset(tries,0,sizeof(tries)); tot=0; fail[0]=0; scanf("%d",&n); for(inti=1;i<=n;i++) { scanf("%s",x); insert(); } getf(); scanf("%s",x); //cout<<x<<endl; printf("%d\n",query()); } return0; } 
第20篇文章[0]
Java软件构造Softwareconstruction（六） 复习与思考 软件构造的多维度视图和质量目标多维度视图具体某些重要视图 质量目标外部质量因素内部质量因素五大质量目标 软件构造的多维度视图和质量目标 该部分是该怎样以全面的眼光/模型/视图来看待软件系统的，搞清楚构造对象是什么，如何刻画，并学会构造过程中应考虑的质量指标，理解清楚如何构造对象才算好。 多维度视图 按阶段划分：构造时/运行时视图按动态性划分:时刻/阶段视图按构造对象层次划分：代码/构件视图关于多维度视图的整体表现如下图所示对于这副图的理解，个人认为首先掌握好代码与构件视图的区别，构件永远是高于代码层面的变化，如包，文件，配置，版本，日志，进程等等。然后掌握运行与构造时视图的区别，构造时都是关于文件本身不涉及执行时的变化，运行时则是关于栈，变量，内存信息等的一些执行时变化，至于时刻和阶段视图的区分则是一个时间点和一个时间段的区别，如一个时间点的sourcecode是具体怎样的和一个时间段的codechurn代码变化是怎么样的。 具体某些重要视图 (1)Build-time,moment,andcode-levelview：词汇层面:sourcecode语法层面:AST(半结构化的语言彻底结构化成一棵树)语义层面：ClassDiagram(图形化形式化的实现具体目标的结构)(2)Build-time,period,andcode-levelviewCodechurn代码变化(3)Build-time,moment,andcomponent-levelview文件，包，库等等，注意静态链接在构造时，动态链接在运行时(4)Build-time,period,andcomponent-levelviewSCI配置项和版本（基线和版本）(5)Run-time,moment,andcode-levelviewCodeSnapshot:描述程序运行时内存里变量层面的状态(6)Run-time,periodandcode-levelviewExecutiontracing执行跟踪 质量目标 分为外部质量因素与内部质量因素，外部质量因素影响用户，内部质量因素影响软件和它本身开发者，外部质量取决于内部质量。 外部质量因素 正确性：最重要的质量指标健壮性：针对异常情况的处理，这里对异常情况的定义为未被specification覆盖的情况即为“异常情况”！可扩展性：对软件的规约进行修改，是否足够容易可复用性：一次开发，多次使用，不要重复造轮子！！兼容性：不同的软件系统之间相互可容易的集成性能：性能毫无意义，除非有足够的正确性，过早的优化是万恶之源！！改变算法思想！可移植性：软件可方便的在不同的技术环境之间移植易用性：字面意思Functionality：每增加一小点功能，都确保其他质量属性不受到损失Timeliness：在用户想要其前则发布… 内部质量因素 ReadabilityUnderstandabilityClearnessSize 五大质量目标 
第21篇文章[1]
2021HITCSAPP大作业程序人生-Hello’sP2P 目录 摘要第1章概述1.1HELLO简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2在Ubuntu下编译的命令3.3Hello的编译结果解析3.3.1编译后生成文件3.3.2数据处理解析3.3.3操作符解析3.3.4控制转移解析3.3.5函数操作解析 3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令4.3可重定位目标elf格式4.3.1 ELF头4.3.2 节头部表4.3.3 重定位节4.3.4 符号表 4.4Hello.o的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式5.4hello的虚拟地址空间5.5链接的重定位过程分析5.6hello的执行流程5.7Hello的动态链接分析5.8本章小结 第6章hello进程管理6.1进程的概念与作用6.2简述壳Shell-bash的作用与处理流程6.3Hello的fork进程创建过程6.4Hello的execve过程6.5Hello的进程执行6.6hello的异常与信号处理6.7本章小结 第7章hello的存储管理7.1hello的存储器地址空间7.2Intel逻辑地址到线性地址的变换-段式管理7.3Hello的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.5三级Cache支持下的物理内存访问7.6hello进程fork时的内存映射7.7hello进程execve时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章hello的IO管理8.1Linux的IO设备管理方法8.2简述UnixIO接口及其函数8.3printf的实现分析8.4getchar的实现分析8.5本章小结 结论附件参考文献 摘要 本论文对hello运行的一生进行了深入地分析，在Ubuntu下通过从hello文件的诞生再到加载hello的进程并回收这一连串的过程来梳理与回顾整个CSAPP课程的脉络与知识，并对这个过程进行进一步的分析去深入地理解计算机系统。关键词：hello；文件；进程；计算机系统 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 第1章概述 1.1HELLO简介 Hello的P2P是一个从高级C语言程序开始到一个运行的进程的过程，由hello.c（源程序）经过预处理器(ccp)变成hello.i（修改了的源程序），再经过编译器(ccl)变成hello.s（汇编程序），再经过汇编器(as)生成hello.o（可重定位目标程序）最后由链接器(ld)生成hello（可执行目标程序）。经过这预处理、编译、汇编、链接四个步骤后，最后Linux系统再由shell加载运行hello程序，为它fork或是execve进程，完成从FromProgramtoProcess的P2P过程。 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk软件环境：Windows1064位；Vmware11；Ubuntu16.04LTS64位开发工具：VisualStudio201064位以上；GDB/OBJDUMP；DDD/EDB 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。中间结果文件文件作用使用时期hello.c本次大实验使用的程序整个过程hello.i预处理后得到的文本文件第二章-预处理hello.s编译后的文本文件第三章-编译hello.o汇编后得到的可重定位目标文件（二进制）第四章-汇编helloo.asm反汇编hello.o得到的文本文件第四章-汇编helloo.elfhello.o的elf文件第四章-汇编hello链接后得到的可执行目标文件（二进制）第五章-链接hello.elfhello的elf文件第五章-链接hello.asmhello的反汇编文件第五章-链接 1.4本章小结 本章对整个实验的全部过程进行了一个基本的概述，介绍了其P2P，O2O的两个过程，同时展示出本次实验所需的环境和工具，列举出编写本论文生成的所有中间结果文件及其作用。（第1章0.5分） 第2章预处理 2.1预处理的概念与作用 预处理的概念：编译之前进行的处理，在程序编译之前，预处理器根据以字符#开头的命令，修改原始的c程序。预处理的作用：展开#起始行的内容，并直接插入程序文本中以便调用。使用的预处理名称及意义如图2-1所示。 图2-1预处理名称及意义同时，预处理还会把代码中的注释去掉。 2.2在Ubuntu下预处理的命令 预处理的命令为gcc-ohello.i-Ehello.c。其中-E是对hello.c进行预处理命令，-o是对输入结果进行导入操作，这里即是将输入结果导入到hello.i。 图2-2预处理命令 2.3Hello的预处理结果解析 预处理后生成文件结果如图2-3所示 图2-3预处理后生成文件结果hello.c中文本共28行，有注释，有头文件。 图2-4hello.c文本经过预处理后共3074行，其中删除了注释，并将头文件中的stdio.hunistd.hstdlib.h展开，将所有内容放入hello.i文本中。 图2-5hello.i文本 2.4本章小结 预处理阶段，预处理器将#后代码行展开，并删除注释，gcc预处理的命令为gcc-ohello.i-Ehello.c。如此进行使得hello完成P2P的一步，为后续编译阶段打下基础。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的概念：编译器将预处理后的代码进行词法语法分析语义检查及优化后翻译成汇编语言程序。编译的作用：将不同的高级语言程序翻译成机器更好理解更通用的低级汇编语言文本。注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序。 3.2在Ubuntu下编译的命令 编译的命令为gcc-ohello.s-Shello.i其中-S是对hello.i进行编译命令，-o是对输入结果进行导入操作，这里即是将输入结果导入到hello.s。 图3-1编译的命令 3.3Hello的编译结果解析 3.3.1编译后生成文件 编译后生成文件结果如图3-2所示图3-2编译后生成文件结果 3.3.2数据处理解析 1.全局变量 图3-4全局变量在hello.c的初始化只有一个全局变量sleepsecs，大小为4字节，要求也要4字节对齐。 图3-5全局变量sleepsecssleepsecs进行了初始化所以其位于.rodata节中，同时因赋值时sleepsecs时int型对于浮点数2.5发生隐式类型转换，故实际赋值为2。图3-6全局变量sleepsecs 2.局部变量局部变量存放在寄存器或栈中，此处存放在栈-4(%rbp)里。 图3-7局部变量在hello.c的赋值 图3-8局部变量的赋值 3.形式参数 图3-9hello.c定义的形式参数前6个形式参数存放在寄存器rdi，rsi，rdx，rcx，r8，r9中，其后的参数放入栈中的参数构造区。在根据图3-7中hello.c中对argv[1],argv[2]的调用以及argc!=3的表达式，定位到hello.s中的调用，得到argc,argv[]先是位于rdi,rsi中后放入栈中。 图3-10形式参数在hello.s中的调用 4.常量字符串 图3-11hello.c中部分常量字符串常量字符串分别位于hello.s的.LC0和.LC1中。 图3-12hello.s中的字符串常量采用如图3-13的方式调用用lea指令加载具体存储地址到rdi寄存器中。 图3-13字符串常量的调用 3.3.3操作符解析 1.赋值操作符对于hello.c中的赋值操作符，均采用图3-8所示mov方式将其赋值给具体寄存器或内存位置，从而赋值给寄存器或内存位置对应参数，而对于mov后缀代码定义为赋值的字节大小。而对于赋值过程中的类型转换及初值问题于3.3.2中全局变量已有解释。 图3-14代码后缀定义2.逗号操作符逗号操作符在hello.c中当作顺序点用，对于图3-9用逗号隔开的形式参数，所位于栈中位置按一定规则排列，如图3-10所示，逗号前面的argc位于栈更低地址更高的位置，argv位于栈更高地址更低的位置。3.算术操作符对于i++操作在hello.s中的汇编代码如图3-16所示 图3-15hello.ci++操作 图3-16hello.s对应汇编代码4.关系操作符对于argc!=3和i<10这样的比较操作，在hello.s中用cmp将具体变量与立即数进行比较。 图3-17hello.s中的比较操作5.数组操作对于char*argv[]这样的数组引用，在hello.s中由图3-10得知其位于一段连续的栈中，从地址-32(%rbp)获得数组首地址后，分别加16和加8，获得argv[2],argv[1]。 3.3.4控制转移解析 对于argv!=3就执行图3-11操作，以及对i<10就继续循环的操作在hello.s中是通过cmp操作设置条件码然后根据条件采取对应jump操作到具体目标。 图3-18hello.s设置条件码并跳转 3.3.5函数操作解析 1.参数操作对于函数参数的构建是前6个参数存放在寄存器rdi，rsi，rdx，rcx，r8，r9中，其后的参数放入栈中的参数构造区。例如如图3-10main函数参数的传递，又如图3-19中寄存器rdi,rsi传递给print函数两个参数，rdi传递给sleep一个参数,rdi传递给exit一个函数 图3-19hello.s中对print函数两个参数和sleep函数一个参数传递 2.函数调用及信息如图3-19所示对于函数的调用在hello.s中采取call的汇编代码指令，包括图3-21亦是对getchar()函数调用。同时对于hello.c定义的主函数main还有关于其全局函数的信息解释。 图3-20main函数的信息 图3-21调用getchar函数3.函数返回值hello.s中的函数返回值均保存在寄存器rax中，如图3-21main函数返回0. 图3-22main函数返回值的信息 3.4本章小结 阐述了编译过程的概念与作用，用gcc的命令实现了从预处理后文件到生成汇编代码程序，并深入地解析了hello.s中各部分数据操作的含义。（第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编的概念：汇编器(as)将汇编语言程序翻译成机器语言指令，把这些指令打包成可重定位目标程序。汇编的作用：将汇编代码转换成计算机可识别的二进制文件。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。 4.2在Ubuntu下汇编的命令 汇编的命令为gcc-ohello.o-chello.s其中-c是对hello.s进行汇编命令，-o是对输入结果进行导入操作，这里即是将输入结果导入到hello.o。 图4-1汇编命令 4.3可重定位目标elf格式 ELF格式如图4-2所示 图4-2ELF格式 图4-3ELF头与节头 4.3.1 ELF头 ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，节头部表中条目的大小和数量等。 4.3.2 节头部表 节头部表则描述了各节的名称、大小、类型、地址、偏移量、对齐、读写属性等等信息。 4.3.3 重定位节 图4-4重定位节信息.rela.text是.text中重定位目标列表，链接器把这个目标文件和其他文件组合时，需要修改这些位置。同时下方每一行对应一个重定位条目，指出了每个符号的节偏移量，重定位类型，信息，符号值，对应的符号名称，和进行重定位时地址计算的加数。hello.o重定位条目包括以及只读数据节，各类函数，以及全局变量sleepsecs。.rela.eh_frame则是eh_frame节的重定位信息。 4.3.4 符号表 图4-5符号表信息Value表示节中偏移量，Size表示大小，Type表示为函数还是数据，Bind表示是否为全局的，如sleepsecs为全局变量，大小为4字节 4.4Hello.o的结果解析 图4-6hello.o反汇编结果反汇编后与hello.s进行比较后发现hello.s中的立即数均为十进制，而反汇编后的为十六进制数，同时分支转移函数调用时反汇编call指令接的是具体值，汇编代码中直接接的函数名。同时反汇编中没有.L0.L1等目标位置，对于条件跳转直接接的地址值。剩余部分机器语言二进制指令对应反汇编代码与hello.s中基本一致。 4.5本章小结 介绍了汇编的概念和作用，采用gcc命令将hello.s汇编成hello.o，同时深入地分析了汇编后的ELF格式与信息，并且对hello.o进行了反汇编并于hello.s的汇编代码进行比较。（第4章1分） 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接的作用：把必要的系统目标文件组合起来生成一个可执行目标文件。注意：这儿的链接是指从hello.o到hello生成过程。 5.2在Ubuntu下链接的命令 Ubuntu下链接的命令为:ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/lib/x86_64-linux-gnu/crt1.o/lib/x86_64-linux-gnu/crti.o/lib/x86_64-linux-gnu/libc.so/lib/x86_64-linux-gnu/crtn.ohello.o 图5-1链接命令使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 5.3可执行目标文件hello的格式 5.3.1ELF头对比图4-3我们可以发现，类型变成了可执行文件，节头增加至了27个。 图5-2ELF头 5.3.2节头部表对比图4-3我们可以发现，节头部表仍旧描述了各节的名称、大小、类型、地址、偏移量、对齐、读写属性等等信息。但增加了诸如.plt这般新的节。这里给出部分常见节的解释.init:程序初始化代码调用.text:已编译的机器代码.rodata:只读数据.plt过程链接表（ProcedureLinkageTable），包含动态链接器调用从共享库导入的函数所必须的相关代码。.data:已初始的全局和静态C变量.got节保存全局偏移表。它和.plt节一起提供了对导入的共享库函数访问的入口。.rela.dyn：动态重定位表.rela.plt：.plt节的重定位条目.gnu.hash：gnu的扩展符号hash表.eh_frame：程序执行错误时的指令.dynsym节保存共享库导入的动态符号信息。.dynstr保存动态符号字符串表，存放一系列字符串，代表了符号的名称，以空字符作为终止符。.gnu.version：符号版本.gnu.version_r：符号引用版本.bss:为初始化的全局和静态C变量及初始化为0的全局和静态变量.symtab:符号表，存放程序中定义和引用的函数和全局变量的信息.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。 图5-3节头部表5.3.3程序头hello的程序头表是一个结构数组。每种结构都描述了系统准备程序执行所需的段或其他信息。目标文件段包含一个或多个节。该程序头内共八个段，包含各段的类型，偏移量，读写属性，虚拟地址，物理地址，对齐要求，内存大小等信息。其中程序包含八个段：1.PHDR:指定程序头表在文件及程序内存映像中的位置和大小。2.INTERP:指定要作为解释程序调用的以空字符结尾的路径名的位置和大小。对于动态可执行文件，必须设置此类型。3.LOAD:指定可装入段，通过p_filesz和p_memsz进行描述。文件中的字节会映射到内存段的起始位置。4.DYNAMIC:指定动态链接信息。5.NOTE:指定辅助信息的位置和大小。6.GNU_PROPERTY:7.GNU_STACK:权限标志，标志栈是否是可执行的。8.GNU_RELRO:指定在重定位结束之后那些内存区域是需要设置只读。 图5-4程序头5.3.4段节与动态链接节信息段节中包含各段的符号名字，同时动态链接节各共享库引入的节中的名称类型。 图5-5段节和动态链接节5.3.5重定位节信息重定位节信息与4.3.3相同，只是增加了两个新的重定位符号__libc_start_main@GLIBC_2.2.5和__gmon_start__。 图5-6重定位节信息5.3.6符号表信息符号表信息与4.3.4中相同，只是增加了许多新的符号。 图5-7符号表信息 5.4hello的虚拟地址空间 图5-8edb查看虚拟地址空间可以看到虚拟空间从0x400000开始与图5-4中的LOAD段对应，其中地址0x400040与PHDR段对应，其中地址0x4002e0与INTERP对应，地址0x400300与NOTE和GNU_PROPERTY段对应，地址0x403e50与GNU_RELRO和DYNAMIC段对应。 5.5链接的重定位过程分析 图5-9objdump-d-rhello分析得到此时反汇编得到的程序包含链接函数的汇编代码，并且都取重定位后确定的地址为跳转目标，地址不再从0开始，不同区域有着不同的虚拟地址。重定位常用方法为重定位PC相对引用和重定位PC绝对引用。此处我们选取printf函数进行分析，得知main函数口的地址为0x401185结合图4-4printf的偏移量为0x5e，得到运行时地址为0x4011e3，同时得知printf函数的地址0x401090,0x401090–0x4011e3–0x4（重定位时的加数）转换为小端序的计算结果为0xa8feffff与objdumpprintf函数结果相同。 图5-10objdumpprintf函数结果 5.6hello的执行流程 其调用与跳转的各个子程序名如下：_dl_start_dl_init_start_libc_start_main__libc_csu_init_initmain_GI_IO_puts__GI_exit_fini 图5-11执行过程部分callfrom截图 5.7Hello的动态链接分析 dl_init调用之前直接进入函数对应的PLT中，接着PLT指令通过对应的GOT指令进行间接跳转，由于每个GOT指令初始时都指向他对应的PLT条目的第二条指令，所以这个间接跳转只是简单的把控制传回PLT条目的下一条指令。接着把函数的ID入栈PLT跳转到PLT[0]，PLT[0]再将动态链接器的一个参数入栈，然后间接跳转到动态链接器中。动态链接器依据两个栈条目确定函数的运行位置，重写对应的GOT条目，再把控制传给函数。在dl_init调用之后，GOT表中存放的就是对应的函数的地址。我们根据.got.plt地址发现存储的got基本为零。 图5-12dl_init调用之前调用后有新地址生成。 图5-13dl_init调用之后 5.8本章小结 本章介绍了链接的概念和作用，采用ld命令进行了动态链接，分析了链接可执行文件hello的ELF格式，节头部信息等等，并与hello.o文件对应比较，然后分析了hello的虚拟空间分布以及如何进行重定位，获取了hello从头到尾运行的子程序，最后对hello进行了动态链接分析。（第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的概念：一个执行中程序的实例。进程的作用：提供一种抽象使得我们的程序好像是系统当中当前唯一运行的程序一样。我们的程序就好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们的指令。最后我们程序中的代码和数据好像是系统内存中的唯一对象。 6.2简述壳Shell-bash的作用与处理流程 shell的作用:在交互方式下解释从命令行输入的命令，执行一系列读/求值步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并表用户运行程序。shell的处理流程：首先shell打印一个命令行提示符，等待用户在stdin上输入命令行，待输入命令行并回车后，解析这个以空格分隔的命令行参数，并构造最终会传递给execve的argv向量，同时若最后一个参数是’&’字符，表示应该在后台执行，否则应该在前台执行。解析完命令行后，开始检查第一个命令行参数是否是一个内置的shell命令。是则立即解释，否则shell创建一个子进程，并在子进程执行所请求程序，若是在后台运行则shell返回顶部，等待下一个命令行，否则shell等待作业终止再开始下一轮迭代。 6.3Hello的fork进程创建过程 我们根据shell的处理流程，在当前目录下打开shell输入./hello1190100612冯梓峻运行，shell作为父进程，通过fork函数创建一个新的运行的子进程hello。Hello子进程几乎但不完全与父进程相同，hello进程得到与父进程用户级虚拟空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库、以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，Hello进程可以读写父进程中打开的任何文件。父进程和Hello进程最大的区别在于它们有不同的PID。 图6-1hello的fork进程 6.4Hello的execve过程 如果采用execve函数来加载hello进程的话，输入参数为当前hello所在目录文件名，且带上参数列表和当前环境变量列表，同时进行上下文切换，调用启动代码，将控制传递给新程序的主函数，并不返回。 图6-2execve函数 图6-3上下文切换 6.5Hello的进程执行 当我们执行hello进程的时候，首先因未设置模式位而运行在用户模式下，同时内核会该进程维护一个上下文，即内核重新新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构。同时因为shell本身进程和其他进程与hello进程的运行时间有重叠，故他们是在并发的运行，每个进程都有它独立的逻辑控制流。而此时我们考虑由不是hello的时间片到执行hello进程的时间片时，首先进行如图6-3的上下文切换，由内核的调度器来进行调度hello进程抢占当前进程，它首先保存当前进程的上下文，然后恢复hello被抢占所保存的上下文，最后将控制传递给这个新的上下文。然后我们考虑hello进程的执行过程，在hello输出后，调用sleep函数使整个进程休眠2秒，此刻发生上下文转换，运行其他进程，两秒后hello重新抢占进程，如此运行9次。随后遇见getchar()函数会读一个文件(read)，触发一个陷阱，此时hello进程将控制传递给内核模式下的陷阱处理程序，处理程序再返回到hello进程的下一条指令，直至最后程序终止。结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 hello正常执行时Hello进程在执行中，遇见getchar()函数会读一个文件(read)，触发一个陷阱，此时hello进程将控制传递给内核模式下的陷阱处理程序，处理程序再返回到hello进程的下一条指令。同时遇见sleep函数时，亦会触发陷阱，处理方法与上述相同。最后进程会执行exit指令也是一个陷阱终止进程，并向父进程发送一个SIGCHLD信号。Ctrl-ZHello进程执行时遇见Ctrl-z后进程收到一个中断，同时收到一个SIGSTOP信号，整个进程停止。此时psjobspstreefgkill各命令运行结果如下。 图6-4ps与jobs命令 图6-5jobs命令fg命令发送一个SIGCONT信号给hello进程，使得hello进程在前台继续运行。 图6-6fg命令最后用kill命令发送一个SIGKILL信号杀死进程。 图6-7kill命令3.Ctrl-c命令Ctrl-c发送一个SIGINT信号给hello进程，最终hello进程终止。 图6-8ctrl-c命令 6.7本章小结 本章阐述了进程的概念与作用以及壳Shell-bash的作用与处理流程，同时深入地分析并理解了hello的fork和execve过程，同时理解了有关上下文信息、进程时间片，进程调度的过程，用户态与核心态转换等等诸多概念的理解过程，同时对hello进程的执行过程的异常和信号处理，以及外部造成的异常和信号处理有了更多的了解和认识。（第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：在有地址变换功能的计算机中,访问指令给出的地址(操作数)叫逻辑地址，是CPU的段内偏移地址，由两个地址分量构成，一个为段基值，另一个为偏移量。线性地址：是逻辑地址到物理地址变换之间的中间层，在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。虚拟地址：指的就是线性地址。物理地址：地址存储器中存储单元对应实际地址称物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 因CPU不支持分页机制，所以逻辑地址到线性地址的转换采用段式管理。48位逻辑地址前16位为段选择符，段选择符又分为索引，TI，RPL，其中索引为描述符表的索引，TI是0则在GDT全局描述符表中寻找，为1则在LDT局部描述符表中寻找。RPL则是段的级别。通过索引找到段基址后与后32位段内偏移量相加就是线性地址值。 图7-1段选择符 图7-2段式管理流程 7.3Hello的线性地址到物理地址的变换-页式管理 线性地址即虚拟地址，VM系统通过将虚拟内存分割位虚拟页，类似地，物理内存被分割为物理页，大小都为P字节，由于DRAM不命中昂贵的时间代价，虚拟页往往很大，于是我们采用页式管理来进行从线性地址到物理地址的变换。虚拟地址VA分为p位的VPO（虚拟页面偏移量），和(n-p)位的VPN（虚拟页号），MMU(地址管理单元)利用VPN来选择适当的PTE。如，VPN0选择PTE0，VPN1选择PTE1，以此类推。然后将页表条目中物理页号和虚拟地址中的VPO串联起来，就得到相应的物理地址。注意因为物理页面和虚拟页面都是P字节的，所以虚拟页偏移量和物理页偏移量都是相同的。 图7-3页表的地址翻译 7.4TLB与四级页表支持下的VA到PA的变换 TLB称为翻译后备缓冲器，是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB的组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号提取出来。如图T=2^t个组，索引则由VPN的t个最低位组成，而TLB标记由VPN剩下的位组成。TLB命中的步骤为，CPU产生虚拟地址MMU从TLB中取出对应PTE然后翻译成物理地址发送给高速缓存/主存，随后返回数据字给CPU，不命中时则必须从L1缓存中取出相应PTE。 图7-4虚拟地址中用以访问TLB的组成成分 图7-5TLB命中和不命中操作图 而这里我们采用COREi7地址翻译下运行的四级页表下VA到PA的变换：我们可以发现，36位VPN被划分成了4个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含Ll页表的物理地址。VPN1提供到一个LlPET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 图7-6如图为四级页表支持下VA到PA的变换 7.5三级Cache支持下的物理内存访问 三级Cache支持下的物理内存访问。 图7-7三级Cache支持下的物理内存访问 当我们获取了物理地址PA后，PA分为CT(高速缓存标记)，CI(高速缓存索引)，CO(缓冲块内的字节偏移量)三部分。首先对于当前PA根据CI在L1cache查找索引然后根据高速缓存标记CT判断是否在组内存在该块，若存在该块且标记位为1则命中，再根据CO获取块偏移后结果，将该结果返回给CPU。若不命中则按照相同的查找策略按L2cache、L3cache、主存这样以此向下查找下去，找到相应块后，若上一层组内缓存有空闲块则将它写入空闲块中，否则则采用相应策略选取牺牲块用找到的块将其替换，替换到L1后返回结果。 7.6hello进程fork时的内存映射 当shell先调用fork函数时，内核会为新进程创建如下组织的数据结构，同时分配给它一个唯一的PID。这个数据结构首先是一个任务结构task_struct。任务结构中的一个条目指向mm_struct,它描述了虚拟内存的当前状态。两个字段分别是pgd和mmap,其中pgd指向第一级页表(页全局目录)的基址,而mmp指向一个vm_area_structs(区域结构)的链表,其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时,就将pgd存放在CR3控制寄存器中。为了我们的目的,一个具体区域的区域结构包含下面的字段:vm_start:指向这个区域的起始处。vm_end:指向这个区域的结束处。vm_prot:描述这个区域内包含的所有页的读写许可权限。vm_flags:描述这个区域内的页面是与其他进程共享的,还是这个进程私有的(还描述了其他一些信息).vm_next:指向链表中下一个区域结构。 图7-8虚拟内存的组织为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。将两个进程中的每个页面都标记为已读，并将两个区域结构都标记为私有的写时复制。当fork在新进程中返回时,新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时,写时复制机制就会创建新页面,因此,也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 在fork一个新进程后shell调用execve加载并运行hello可执行文件，按如下几个步骤进行，先是删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。然后映射私有区域。为hello程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和data区。bss区域是请求二进制零的,映射到匿名文件,其大小包含在hello中。栈和堆区域也是请求二进制零的,初始长度为零。 图7-9加载器映射的地址空间再然后是映射共享区域。如果hello程序与共享对象(或目标)链接,比如标准C库1ibc.so,那么这些对象都是动态链接到这个程序的,然后再映射到用户虚拟地址空间中共享区域内。最后设置程序计数器(PC)。execve做的最后一件事情就是设置当前进程上下文中的程序计数器,使之指向代码区域的入口点。下一次调度这个进程时,它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 7.8缺页故障与缺页中断处理 当MMU在试图翻译某个虚拟地址A时，触发一个缺页。这个异常导致控制转入到内核的缺页处理程序，处理程序随后就执行下面的步骤。首先判断虚拟地址是否合法，即缺页处理程序搜索区域结构的链表将其与vm_start与vm_end作比较，不合法则触发段错误故障，从而终止进程。然后判断进程是否有读写该页面的权限，如对只读页面进行写操作这样不合法的访问，触发一个保护异常，终止进程。最后内核知道缺页是对合法的虚拟地址进行合法的操作造成的，那么它开始选择一个牺牲页面，若其被修改过，就交换出去，换入新的页面并更新页表。缺页处理程序返回则重新启动引起缺页指令，再次发送A到MMU后可正常翻译。 图7-10缺页处理 7.9动态存储分配管理 Hello的Printf会调用malloc，下面简述动态内存管理的基本方法与策略：动态内存分配器维护着一个进程的虚拟内存区域，称为堆(heap)。假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。而对于分配器采用的数据结构，分为带边界标签的隐式空闲链表和带边界标签的显示空闲链表。带边界标签的隐式空闲链表是由一个字的头部、有效载荷，以及有效载荷、可能的一些额外的填充组成。同时还在块的结尾处添加一个脚部（边界标记），其中脚部就是头部的一个副本。而显式的链表则在隐式链表的基础下增添一个pred（前驱）和succ（后继）指针。在确定了分配器的数据结构后，我们开始考虑内存管理的方法，首先对于放置分配块的策略，常见的策略有：首次适配、下一次适配、最佳适配。首次适配是从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配则是从上一次查询结束地方开始搜索。最佳适配则是检查每一个空闲块，选择适合所需的空闲块。找到匹配空闲块，则根据空间大小匹配选择整个空闲块还是分割空闲块，对于显示链表来说，分割后的空闲块采用后进先出的顺序或是按照地址顺序来维护链表。若没有足够大的空闲块来放置，则向内核请求额外的堆内存，转化为一个大的空闲块来放置。而当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻，则根据前后块的边界标记判断它是否是空闲块，是空闲块则将其合并为一个更大的空闲块。至此动态内存管理的基本方法与策略介绍完毕。 7.10本章小结 本章首先介绍了逻辑地址、线性地址、虚拟地址、物理地址的概念，随后分析了从逻辑地址到线性地址的段式管理，再介绍了从线性地址到物理地址的页式管理，介绍了TLB对虚拟地址寻找物理地址的加速，同时介绍了TLB缓存查找不命中时，通过四级页表节约内存空间来进行从VA到PA的转换。随后介绍了hello进程fork时和execve时的内存映射，对翻译虚拟地址时的缺页故障和缺页故障处理程序进行了探讨，最后简述了动态内存管理的基本方法与策略。（第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件文件的类型如下：普通文件：包含任意数据，应用程序通常要区分文本文件和二进制文件，文本文件只含有ASCII或Unicode字符；二进制文件是所有其他的文件。对内核而言，这二者没有区别。目录：目录是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。套接字：是用来和另一个进程进行跨网络通信的文件。设备管理：unixio接口输入和输出以一种的统一且一致的方式来执行。 打开文件。应用程序通过要求内核打开相应文件，内核返回一个小的非负整数，称为描述符。改变当前文件位置。对于每个打开的文件，内核保持一个位置k，初始为0。读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。关闭文件。当应用完成对文件的访问，就通知内核关闭这个文件。 8.2简述UnixIO接口及其函数 1.打开和关闭文件intopen(char*filename,intflags,mode_tmode);open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。出错则返回-1。Flags指明进程打算如何访问这个文件，mode参数指定新文件的访问权限位。intclose(intfd);进程通过调用close关闭一个打开的文件。关闭一个已关闭的描述符会出错。2.读和写文件ssize_tread(intfd,void*buf,size_tn);read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。ssize_twrite(intfd,constvoid*buf,size_tn);write函数从内存位置buf复制之多n个字节到描述符fd的当前文件位置。同样我们可以采用RIO包进行健壮的读取读写。下为RIO无缓冲的输入输出函数。 图8-1无缓冲的输入输出函数Rio_readn函数从描述符fd的当前文件位置最多传送n个字节到内存位置usrbuf，rio_writen类似。当这两个函数被一个应用信号处理程序的返回中断，每个函数都会手动地重启read或write。下为RIO带缓冲的输入函数 图8-2RIO带缓冲的输入函数 Rio_readlineb函数从文件rp读出下一个文本行，将它复制到内存位置usrbuf，并且用NULL字符来结束这个文本行。其最多都maxlen-1个字节，超过的文本行被截断，并用一个NULL字符结束。Rio_reandnb函数从文件rp最多读n个字节到内存位置usrbuf。3.读取文件元数据 图8-3读取文件元数据函数 Stat函数以一个文件名作为输入，并填写数据到如图8-4所示的数据结构里，fstat函数类似，只是以文件描述符作为输入。 图8-4stat数据结构4.读取目录内容 图8-5返回目录流指针函数 函数opendir以路径名为参数，返回指向目录流的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。 图8-6readdir函数 每次对readdir的调用返回的都是指向流dirp中下一个目录项的指针，或者，如果没有更多目录项则返回NULL。如果出错则返回NULL并设置error。 图8-7closedir函数 函数closedir关闭流并释放其所有的资源。 8.3printf的实现分析 首先我们查看printf的源码图8-8printf源码 发现定义了一个va_list类型查看它的定义typedefcharva_list发现是一个字符指针，(char)(&fmt)+4)表示的是…中的第一个参数。2.随后查看vsprintf函数的源码 图8-9vsprintf源码vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。3.反汇编查看write函数 图8-10反汇编write函数给几个寄存器传递了几个参数，然后一个intINT_VECTOR_SYS_CALL表示要通过系统来调用sys_call这个函数。4.sys_call函数 图8-11sys_call的实现它的功能是显示格式化了的字符串。将要输出的字符串从总线复制到显卡的显存中。5.字符显示驱动子程序：字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。6.显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 图8-10getchar函数内容 当调用getchar函数时，getchar调用一个read系统函数，文件描述符为0，所以是从标准输入流中读入，因此触发一个异常，进入键盘中断处理子程序，进程控制转给终端输入，而当从键盘输入字符时，接受按键扫描码转成ascii码，保存到系统的键盘缓冲区，直到接受到回车键才返回。随后控制返回给getchar函数，getchar函数返回内存位置的第一个元素。 8.5本章小结 本章是对hello中的I/O管理的总结，介绍了设备的模型化文件的概念，并介绍了IO的设备管理方法。随后对I/O打开和关闭、读写、读取元数据、目录等基本函数做了介绍。深入分析了hello中printf和getchar函数的I/O实现。（第8章1分） 结论 一开始hello.c是一个程序文本文件，经过预处理器cpp读取头文件后修改生成了hello.i源程序，再经过编译器ccl翻译成汇编语言得到汇编程序hello.s，然后经过汇编器as翻译成机器语言程序hello.o，最后经过链接器ld链接生成可执行目标程序hello。然后运行shell并fork一个子进程，调用execve函数在当前进程的上下文加载并运行hello程序，该进程映射它的虚拟空间到文件，运行的过程当中伴随着虚拟地址到物理地址的转换，调用的函数与I/O设备紧密结合，当进程的一切终止时，被shell所回收，内核清除掉它的痕迹。至此hello一生结束，计算机系统的课程也告一段落。几百页书籍的翻看，成百上千小时的学习，最后凝结在hello这短短的一生，计算机系统就是这般，晦涩难懂到渐入佳境，书越读越薄，最后便是大道至简。回顾学习，还是有许多地方没来的及深入学习，还有很多实验能够进一步优化和进步，还有很多细节没来的及分析。有收获，也有遗憾，希望自己能在未来进一步的学习，真正做到计算机系统的融会贯通。（结论0分，缺失-1分，根据内容酌情加分） 附件 中间结果文件文件作用使用时期hello.c本次大实验使用的程序整个过程hello.i预处理后得到的文本文件第二章-预处理hello.s编译后的文本文件第三章-编译hello.o汇编后得到的可重定位目标文件（二进制）第四章-汇编helloo.asm反汇编hello.o得到的文本文件第四章-汇编helloo.elfhello.o的elf文件第四章-汇编hello链接后得到的可执行目标文件（二进制）第五章-链接hello.elfhello的elf文件第五章-链接hello.asmhello的反汇编文件第五章-链接 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等[1]链接程序和库指南[N/OL]https://docs.oracle.com/cd/E38902_01/html/E38861/chapter6-83432[2]用gcc编译c语言程序以及其编译过程[N/OL]https://blog.csdn.net/weixin_33755847/article/details/89697445[3]Linux下可视化反汇编工具EDB基本操作知识[N/OL]https://blog.csdn.net/hahalidaxin/article/details/84442132[3]通俗理解CPU中物理地址、逻辑地址、线性地址、虚拟地址、有效地址的区别[N/OL]https://blog.csdn.net/mzjmzjmzjmzj/article/details/84713351[4]printf函数实现的深入剖析[N/OL]https://www.cnblogs.com/pianist/p/3315801.html[5]RandalE.Bryant,DavidR.O’Hallaon.深入理解计算机系统.第三版.北京市：机械工业出版社[M].2018：1-737（参考文献0分，缺失-1分） 
第22篇文章[3]
线段树&树状数组模板 线段树模板 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> #definefr(i,a,b)for(inti=a;i<=b;i++) usingnamespacestd; typedeflonglongll; constintmaxn=100005; intn,q; lltree[4*maxn+1]; lllz[4*maxn+1]; voidbuild(intnode,intl,intr) { if(l==r) { scanf("%lld",&tree[node]); return; } intmid=(l+r)>>1; build(node*2,l,mid); build(node*2+1,mid+1,r); tree[node]=tree[node*2]+tree[node*2+1]; } voidupdate(intnode,intl,intr,intindex) { if(l==r) { tree[node]=index; return; } intmid=(l+r)>>1; if(index<=mid) update(node*2,l,mid,index); else update(node*2+1,mid+1,r,index); tree[node]=tree[node*2]+tree[node*2+1]; } voidpush_down(intnode,intl,intr) { if(l==r) { lz[node]=0; return; } if(lz[node]) { intmid=(l+r)>>1; tree[2*node]+=(mid-l+1)*lz[node]; tree[2*node+1]+=(r-mid)*lz[node]; lz[2*node]+=lz[node]; lz[2*node+1]+=lz[node]; lz[node]=0; } } voidupdate_range(intnode,intl,intr,intL,intR,intadd) { if(l>=L&&R>=r) { lz[node]+=add; tree[node]+=(r-l+1)*add; return; } push_down(node,l,r); intmid=(l+r)>>1; if(mid>=L) update_range(node*2,l,mid,L,R,add); if(mid<R) update_range(node*2+1,mid+1,r,L,R,add); tree[node]=tree[node*2]+tree[node*2+1]; } llquery_range(intnode,intl,intr,intL,intR) { if(l>=L&&R>=r)returntree[node]; push_down(node,l,r); intmid=(l+r)>>1; llsum=0; if(mid>=L) sum+=query_range(node*2,l,mid,L,R); if(mid<R) sum+=query_range(node*2+1,mid+1,r,L,R); returnsum; } intmain() { //freopen("in.txt","r",stdin); scanf("%d",&n); build(1,1,n); memset(lz,0,sizeof(lz)); return0; } 板子敲错两遍就离谱  树状数组模板 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constintmaxn=500005; intC[maxn]; intlowbit(intx) { return(-x)&x; } voidinsert(inti,intw) { while(i<=n) { C[i]+=w; i+=lowbit(i); } } intquery(inti) { intsum=0; while(i>=1) { sum+=C[i]; i-=lowbit(i); } returnsum; } intmain() { //freopen("in.txt","r",stdin); return0; } 果然树状数组好敲很多哇QAQ 
第23篇文章[3]
高精度压位模板 #include<cstdio> #include<iostream> #include<cstdlib> #include<cstring> #include<algorithm> #include<queue> #defineinf1000000000] #definep9//注意乘法压位过大 usingnamespacestd; void_scanf(int&x){ charch=getchar(); boolf=0; x=0; while(!isdigit(ch)){ if(ch=='-')f=1; ch=getchar(); } while(isdigit(ch))x=10*x+ch-'0',ch=getchar(); if(f)x=-x; } void_scanf(int&a,int&b){ _scanf(a); _scanf(b); } structbign{ intz[25],len; bign(){ memset(z,0,sizeof(z)); len=0; } bign(intx){ *this=x; } bignoperator=(intx){ chars[25]; sprintf(s,"%d",x); *this=s; } bignoperator=(char*s){ intlen=strlen(s); intcur=0; bigna; charw[25]; while(len>0){ while(len>=p){ strcpy(w,s+len-p); a.z[cur++]=atoi(w); len-=p; } if(len>0){ strcpy(w,s); w[len]='\0'; a.z[cur++]=atoi(w); len=0; } } a.len=cur; *this=a; } friendbignoperator+(bigna,bignb){ bignc; intlen=max(a.len,b.len)+1; for(inti=0;i<=len-1;i++){ c.z[i]=a.z[i]+b.z[i]; } for(inti=0;i<=len-1;i++) c.z[i+1]+=c.z[i]/1000000000,c.z[i]%=1000000000; while(c.z[len-1]==0&&len>1)len--; c.len=len; returnc; } }; voidbignout(bigna){ intlen=a.len; printf("%d",a.z[len-1]); for(inti=len-2;i>=0;i--) printf("%0*d",p,a.z[i]); } 
第24篇文章[0]
软件构造课程总结（4） 软件构造课程总结（4） 这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。 1.对象、类、属性和方法Instance多个栈、static一个栈2.接口和枚举接口确定ADT规约，类用来实现ADT倾向于使用接口来定义变量。接口中一般没有constructor3.通过接口来写代码先写一个接口publicinterfaceMyString，再写一个实现pulicclassSimplyMyStringimplementsMyString，其中使用@override重写方法，而在接口中只出现方法。客户端需要知道某个具体实现类的名字来建立接口。静态工厂方法：直接在接口中实现建立。4.default方法接口的通用方法 5.继承和重写：6.继承严格继承：不能重写如果不想子类重写，则加上final关键字7.重写使用super来调用父类型的方法抽象方法，不同的子类型各自重写静态类型检查8.多态9.泛型 
第25篇文章[0]
软件构造课程总结（2） 软件构造课程总结（2） 这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。 第四章、数据类型与类型检验 1.程序中的数据类型 数据类型范围基本数据类型和对象数据类型。 基本数据类型：int,long,byte,short,char,float,double,boolean只有值，没有ID均为不可变类型在栈中分配内存 对象数据类型：又值也有ID在堆中分配内存 对象数据类型的结构：有继承关系有操作符有重载 2.可变和不可变类型一句话来说，可变数据类型在内存中的值是可以变化的，而不可变数据类型在内存中的值是不能变化的，如果要改变变量，则需要重新分配一块内存，在这个内存中赋值，并且将指针到这块新的内存。在创造变量的时候加上final关键字可以使得变量变为不可变类型。比如String是一种不可变类型，则以下代码会在内存中发生这样的变化：Strings=“a”;s=s.concat(“b”);先创造一个字符串"a"，将s指向这块内存。然后创造一个字符串"ab"，将s的指针改为这块内存。 不可变类型与可变类型在遇到多个引用的时候会存在差异。 不可变类型需要垃圾回收，但比较安全。可变类型不需要垃圾回收，速度比较快，但是不那么安全。可变类型需要防御式拷贝进行保护。 第五章、数据类型与类型检验 1.spec一句话来说，spec描述了函数的作用，以及前置条件（对输入的限制）和后置条件（对输出的要求）。 2.spec的强度一句话来说，前置条件越弱，后置条件越强，spec就越强。 
第26篇文章[0]
软件构造课程总结（3） 软件构造课程总结（3） 这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。 第六章、ADT 1.表示独立性：通过封装来阻止用户访问程序内部2.抽象函数AF3.表示不变量RI4.数据抽象：强调作用于数据上的操作，在java中使用类的方法5.可变数据类型和不可变数据类型：改变时，前者改变内存中数值，后者构造一个新对象6.四种方法：creators、producers、observes、mutators7.creators：构造函数或者静态函数，或者工厂方法8.mutators：通常返回void9.int是immutable没有构造器mutators，而String是immutable所以也没有构造器mutators10.list是mutable，存在构造器mutators，比如add()11.抽象类型设计Ⅰ.简洁一致的操作Ⅱ.面向用户需求，满足所有需要且尽量简洁Ⅲ.要么抽象要么具体。12.表示独立性内部实现对与用户无关例子：MyString要点：不能让用户访问到类体（使用private表示、observers使用保护式拷贝）13.测试ADT同样是测试四个部分：creators、producers、observes、mutators主要测试返回值和操作结果14.不变量程序中始终保持不变的属性，比如一个家庭类当中，人数总是大于0的。15.RI（RepInvariant）开发者关注R，client关注I三种关系：满射、非单射、非双射AF：抽象函数，R到A的映射R中存在非法值，这时在A中无映射RI中元素合法的子集16.AF一个R到A的映射总结一下RI和AF：RI是输入的约束条件，AF是输入到输出的函数 
第27篇文章[0]
软件构造课程总结（1） 软件构造课程总结（1） 这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。 第一章、软件构造的多篇维度视图和质量目标 1.软件构造的多重视图：这一小节主要讲述了软件构造的三视图维度，分别从时间点还是时间段（MomentorPeriod）、构建还是运行（Build-timeorRun-time）以及代码的逻辑结构和物理结构（Code-levelorComponent-level）讲述了软件构造。 下面是一些比较重要的知识点：1.Code-level：代码的逻辑结构2.Component-level：代码的物理结构3.Momentview：特定时刻的软件形态4.Periodview：软件形态随时间的变化5.三种形式：词汇层面，语法层面，语义层面6.AST：语法分析树，在编译原理中十分重要7.语义：源代码的目标8.源代码：现实世界的代码9.CodeChurn：结构随着版本的变化的改变10.Library：库文件，存在静态链接和动态链接两种形式11.UML：类图12.Codesnapshot：描述程序运行时内存中变量层面的状态。13.Memorydump：记录运行时的内存信息14.Log：日志 2.软件构造的质量这一小节讲述了软件构造时衡量软件质量的几个标准：1.正确性：按照软件的规约spec正确的执行。正确性也是最重要的质量标准。几个保证正确性的方法：①测试，将详细在第二节中讲解②防御式编程：相关的知识有防御式拷贝，权限的使用（private关键字）③checkRep()函数的编写：在程序中我们可以编写一个检查程序，这个方法将时时刻刻检查我们类型中的不变量是否正确。 2.健壮性健壮性是指程序在遇到不符合spec的规定时仍然能够正确的处理，比如返回异常报错 3.可扩展性我们有时候需要对软件的规约进行修改、拓展，是否足够容易？这里就需要我们增强程序的可扩展性。一个可扩展性好的程序可以针对用户的需求扩大进行快速的迭代。 4.可复用性一次开发，多次使用。 5.兼容性 6.同构性 7.性能 8.可移植性 9.易用性 10.及时性 等等。。 我们在编写程序的时候需要对以上这些标准进行衡量，从而构建出一个最能满足客户需求的程序。比如，通常正确性是程序的第一位，而在性能和可扩展性、可复用性的衡量上，则需要根据客户的需求进行设计。______ 第二章、软件测试和测试优先的编程 这一章主要讲述了如何进行程序测试和测试优先编程的思想。我们测试程序，应该抱着找出错误的决心，这是我们测试的第一要义。测试程序主要有两个要点：①等价类基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。我们需要针对每个输入数据需要满足的约束条件，划分等价类。而每个等价类代表着对输入约束加以满足或违反的有效或无效数据的集合。而由于等价类的特性，我们只需要从等价类中选择一个来测试即可。例子：n是正奇数：正数：>0、<0奇数：奇数、偶数奇数隐含着整数：整数、非整数或者：输入的学号no需满足的条件：长度为10位：10、>10、<10以118开头：以此开头、以其他开头之后两位数应为03/36/37：03、36、37、其他②边界测试在工程师进行测试时，发现错误往往出现在边界情况上，比如在上面的例子中，n=0就是一个边界情况。边界值分析方法是对等价类划分方法的补充。通过边界测试，可以让我们更好的测试出错误。 ______ 第三章、软件构造过程和配置管理 这一章主要介绍了两个重要知识点：敏捷开发和git的结构和使用①敏捷开发敏捷开发主要通过快速迭代和小规模的持续改进，以快速适应变化。在2001年AgileManifesto发表敏捷宣言。Agile=增量+迭代每次迭代处理一个小规模增量 ②git1.git的层次结构：工作目录workspace、暂存区staging、仓库localrepository和远程仓库remoterepository（通常是github）。所有的操作就在这四个层次上进行。2.git中文件的结构：我们使用一个树结构来描述git的文件结构：每个commit指向一个父亲；多个commit指向同一个父亲：分支；一个commit指向两个父亲：合并 以上是我总结的一到三章的重点知识。 
第28篇文章[0]
软件构造课程总结（5） 软件构造课程总结（5） 这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。 第八章、ADT和OOP中的等价性 1.根据AF来判断2.equals()重写Object的方法3.Hash的特别方法4.可变类型的等价性观察等价性（可能有bug）行为等价性（看内存位置，直接用Object的==） 第十一章、面向可复用性和可维护性的设计方式 关键词：工厂方法、adapter、decorator、strategy、templatemethod、iterator、visitor设计模式：强调类、对象之间的交互关系，有创建型模式、结构性模式、行为类模式①创建型模式；工厂方法模式：一句话：通过接口实现creatorAdapter模式：略Decorator模式：对每一个特性构造子类，使用委派机制增加到对象上 2020期末考试考点总结： ①checkRep，用assert对precondition进行合法性检查方法一：正则表达式方法二：String转为整数，小数②表示泄露③snapshot书写④健壮性处理：异常和防御式编程⑤测试：等价类划分和边界值测试⑥线程安全threadsafe⑦AF和RI，spec中precondition强度的比较⑧设计模式之模板模式（可扩展性）⑨委派⑩LSP结构外部质量属性、git、安全性 
第29篇文章[3]
HDU-4460FriendChains（邻接表&BFS） 小白日记.2HDU-4460FriendChains 题目大意：如果两个人互为朋友则距离为一，距离可累加，求一群人中任意两个人之间的最短距离的最大值。 常见的BFS利用邻接表剪枝 代码如下： #include<iostream> #include<stdio.h> #include<string.h> #include<queue> #include<iostream> #include<string> #include<map> usingnamespacestd; map<string,int>m; vector<int>gx[1007]; intcc[1007]; intk=0,ok=0,N; structnode{ intp; intt; }; voidBfs(intx) { memset(cc,0,sizeof(cc)); queue<node>q; nodenow,next; now.p=x; now.t=0; q.push(now); cc[x]=1; while(!q.empty()){ now=q.front(); q.pop(); for(inti=0;i<gx[now.p].size();i++){//利用邻接表简化代码 intj=gx[now.p][i]; if(cc[j]==0){ next.p=j; next.t=now.t+1; q.push(next); cc[j]=1;//查重剪枝 k=max(k,next.t); } } } for(inti=0;i<N;i++){ if(cc[i]==0){ ok=1; } } } intmain() { intc; stringstr; while(cin>>N&&N){ ok=0; k=0; m.clear(); for(inti=0;i<N;i++){//初始化 gx[i].clear(); } for(inti=0;i<N;i++){ cin>>str; m[str]=i;//将字符串映射为数字 } cin>>c; while(c--){ inta1,a2; cin>>str; a1=m[str]; cin>>str; a2=m[str]; gx[a1].push_back(a2); gx[a2].push_back(a1);//建立邻接表 } for(inti=0;i<N;i++){ Bfs(i); if(ok==1)break; } if(ok==1) cout<<-1<<endl; else cout<<k<<endl; } return0; } 总结与收获：1.邻接表的使用2.map将字符串映射为数字3.初始化 
第30篇文章[3]
HDU1240Asteroids!（三维BFS） #小白日记.1HDU1240Asteroids! 题目大意：三维空间的走迷宫。注意题目中x，y，z坐标的定义。 比较常规的BFS题目需要用到三维数组 下面是代码： #include<iostream> #include<stdio.h> #include<string.h> #include<queue> #include<iostream> #include<string> usingnamespacestd; charmaze[11][11][11];//地图 intN,ax,ay,az,bx,by,bz,ok; structnode{ intx,y,z; intt;//第几步 }; intwlk[6][3]={{0,0,1},{0,0,-1},{0,1,0},{0,-1,0},{1,0,0},{-1,0,0}};//六个方向行走 intJudge(intx,inty,intz){//判断是否可以走 if(x>=0&&x<N&&y>=0&&y<N&&z>=0&&z<N&&maze[x][y][z]=='O') return1; elsereturn0; } voidBfs() { ok=0; nodenow,next; queue<node>q; now.x=ax; now.y=ay; now.z=az; now.t=0; maze[ax][ay][az]='X'; q.push(now); while(!q.empty()){ now=q.front(); q.pop(); if(now.x==bx&&now.y==by&&now.z==bz){ ok=1; cout<<N<<""<<now.t<<endl; break; } next.t++; for(inti=0;i<6;i++){ next.x=now.x+wlk[i][0]; next.y=now.y+wlk[i][1]; next.z=now.z+wlk[i][2]; next.t=now.t+1;// if(Judge(next.x,next.y,next.z)){ //cout<<next.x<<""<<next.y<<""<<next.z<<""<<next.t<<""<<endl;// maze[next.x][next.y][next.z]='X'; q.push(next); } } } } intmain() { stringstr; while(cin>>str){ cin>>N; for(inti=0;i<N;i++){ for(intj=0;j<N;j++){ for(intk=0;k<N;k++){ cin>>maze[i][j][k]; } } } cin>>ay>>az>>ax>>by>>bz>>bx; cin>>str; Bfs(); if(ok==0) cout<<"NOROUTE"<<endl; } return0; } 总结与收获：1.struct定义三位点与步数的应用。2.wlk数组的使用，可以简化代码。3.剪枝，注意初始位置。4.Judge函数的应用。 
第31篇文章[1]
Ubuntu--用GCC编译helloworld的c程序 安装好Ubuntu之后，最重要的就是用Linux系统进行编译，在查找了许多资料之后，终于能够运行出一个helloworld的c程序了，以下是编译的过程演示 1.安装gcc编译器 打开命令行快捷键：ctrl+alt+T只有安装了gcc才能进行编译，所以安装gcc是第一步。 （1）首先更新包列表：sudoaptupdate输入密码时不会显示密码，输入之后直接按回车就可以了 （2）安装软件包：sudoaptinstallbuild-essential这个软件包已经包含了gcc、g++等（或者可以输入sudoapt-getinstallgcc/g++,分别安装gcc和g++） （3）安装之后验证gcc版本：gcc--version 引用https://www.linuxidc.com/Linux/2019-06/159059.htm 2.创建helloworld程序 vi编辑器是Linux系统下标准的编辑器 （1）通过vim创建一个文档demo1.c：（2）进入下面这个页面之后无法进行编辑，因为目前还是命令行模式（3）输入i之后进入插入模式，可以开始进行编辑：（4)输入相应的程序注意：按下esc键，输入：wq！保存文件，这里一定要做！！！按回车键，输入ls键验证文件是否保存 3.运行helloworld程序 确定c文件存在后，使用命令gccc文件名-o生成的可执行文件名(例：gccdemo1.c-odemo1)。输入编译命令后，如果没显示什么信息，就意味编译成功了编译成功后，再用ls命令查看一下可执行文件是否有生成最后再运行一下可执行文件，可以看到，正确输出语句：HelloWorld！ 引用：https://zhidao.baidu.com/question/2202210069320880548.html 
第32篇文章[0]
软件构造笔记（八）---PPT第四讲 数据类型与类型检查 数据类型静态/动态类型检查静态类型检查原理种类 动态类型检查种类 两者关系 可变/不变的数据类型不变的数据类型finalString特点 可变的数据类型StringBuilder特点解决可变类型不安全的方法 Snapshot理解数据类型 数据类型 基本数据类型/对象数据类型 静态/动态类型检查 静态类型检查 原理 可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性。 Java是静态类型语言，所有变量的类型在编译时(在程序运行之前)都是已知的，因此编译器也可以推导出所有表达式的类型。如果a和b被声明为int型，那么编译器得出a+b也是int型。 比如，如果输入"a"*“b”，尝试将两个字符串相乘，然后静态类型检查将在编程时捕获此错误，而不是在执行期间等待到达该行。 种类 1.Syntaxerrors语法错误2.Wrongnames类名/函数名错误：比如Math.sine(2)，正确的名字是sin3.Wrongnumberofarguments参数数目错误，比如Math.sin(30,20).4.Wrongargumenttypes参数类型错误,likeMath.sin(“30”).5.Wrongreturntypes返回值类型错误,likereturn“30”，但是这个函数应该返回int 动态类型检查 种类 1.Illegalargumentvalues非法的参数值：例如，整数表达式x/y只有在y实际上为零时才错误;否则它的工作原理。在这个表达式中，除以0不是静态误差，而是动态误差。2.Unrepresentablereturnvalues非法的返回值：当特定的返回值不能在类型中表示时。3.Out-of-rangeindexes越界：在字符串上使用负数或太大的索引。4.Callingamethodonanullobjectreference.空指针 两者关系 静态检查倾向于与变量的特定值无关的类型和错误有关。静态类型保证一个变量会有这个集合中的一些值，但是我们直到运行时才知道它的确切值。因此，如果错误只会由某些值引起，如除0或索引超出范围，那么编译器不会引发关于它的静态错误。 相比之下，动态检查往往是关于特定值引起的错误。 静态检查：关于“类型”的检查，不考虑值动态检查：关于“值”的检查 可变/不变的数据类型 改变一个变量：将该变量指向另一个值的存储空间改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。 不变的数据类型 不变对象：一旦被创建，始终指向同一个值/引用如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变 final finalinta=5;1.final类无法派生子类2.final变量无法改变值/引用3.final方法无法被子类重写 String 特点 缺点：使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)优点：安全 可变的数据类型 可变对象：拥有方法可以修改自己的值/引用 StringBuilder 特点 优点：可变类型最少化拷贝以提高效率缺点：不安全比如 publicstaticintsum(List<Integer>list){ intsum=0; for(intx:list){ sum+=x; } returnsum; } publicstaticintsumAbsolute(List<Integer>list){ for(inti=0;i<list.size();i++){ list.set(i,Math.abs(list.get(i))); } returnsum(list); } publicstaticvoidmain(String[]args){ List<Integer>myData=Arrays.asList(-5,-3,-2); System.out.println(sumAbsolute(myData)); System.out.println(sum(myData)); } 最后输出结果为1010因为可变类型导致list的值发生变化 解决可变类型不安全的方法 进行防御式拷贝 Snapshot理解数据类型 基本类型对象类型对象值是一个按其类型标记的圆。可变对象不可变对象：用双线椭圆Strings=“a”;s=s+“b”;不可变的引用：用双线箭头 
第33篇文章[3]
力扣---数组专题I(简单) 题目名称 1.867--转置矩阵--简单2.面试题17.10.主要元素3.977-有序数组的平方4.628-三个数的最大乘积5.219-存在重复元素II6.228-汇总区间7.1-两数之和8.167-两数之和II-输入有序数组 1.867–转置矩阵–简单 (1)题目条件：（2）题解： 该题的目的是对已知矩阵进行转置，由于矩阵的行数和列数可能不相等，对于一个m行n列的矩阵，利用vector创建一个n行m列的空矩阵res，进行赋值操作，res[j][i]=matrix[i][j]。 classSolution{ public: vector<vector<int>>transpose(vector<vector<int>>&matrix){ intm=matrix.size(),n=matrix[0].size(); vector<vector<int>>res(n,vector<int>(m)); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ res[j][i]=matrix[i][j]; } } returnres; } }; 2.面试题17.10.主要元素 （1）题目条件：（2）题解： 摩尔投票法:在网上看到了一个形象的比喻，多个候选人要选举总统，如果其中一个人获得选票比其他人加起来的还多，那么即使进行一对一的比拼，最后剩下的还是这个人。 算法步骤：I.遍历数组元素，从第一个元素开始，计数器初始设置为0，st设置为数组第一个元素II.遇到与st相同的元素时，count加1，否则，count减一。若count=0时，st更换为现在的元素III.最后重新遍历一遍数组，看st的数量是否超过数组元素的一半，若超过一半，则返回该元素，否则返回-1. classSolution{ public: intmajorityElement(vector<int>&nums){ intn=nums.size(); if(n==0)return-1; intst=nums[0],count=0; for(inti=0;i<n;i++){ if(nums[i]==st){ count++; } else{ count--; if(count<=0){ st=nums[i]; count=1; } } } count=0; for(inti=0;i<n;i++){ if(st==nums[i])count++; } if(count>n/2)returnst; elsereturn-1; } }; 排序方法： 将数组从小到大排序，若某个元素数量超过数组元素个数一半，数组最中间的元素一定是该元素。 classSolution{ public: intmajorityElement(vector<int>&nums){ intn=nums.size(); if(n==0)return-1; sort(nums.begin(),nums.end());//对数组从小到大排序 intmid=nums[n/2]; intcount=0;//设置计数器 for(inti=0;i<n;i++){ if(mid==nums[i])count++; } if(count>n/2)returnmid; elsereturn-1; } }; 3.977-有序数组的平方 （1）题目条件：（2）解题方法： 暴力算法 先将数组元素都平方，然后将数组重新排序 classSolution{ public: vector<int>sortedSquares(vector<int>&nums){ intn=nums.size(); for(inti=0;i<n;i++){ nums[i]=nums[i]*nums[i]; } sort(nums.begin(),nums.end()); returnnums; } }; 双指针 题目条件给出数组是非递减顺序排列的，对于正数来说，平方之后顺序不变，对于负数来说，平方之后顺序反转，所以平方后的最大值出现在数组开头或者结尾，最小值出现在数组中间。 classSolution{ public: vector<int>sortedSquares(vector<int>&nums){ intn=nums.size()-1; inti,j; vector<int>ans(nums.size(),0); for(i=0,j=nums.size()-1;i<=j;){ if(nums[i]*nums[i]<nums[j]*nums[j]){ ans[n--]=nums[j]*nums[j]; j--; } else{ ans[n--]=nums[i]*nums[i]; i++; } } returnans; } }; 4.628-三个数的最大乘积 （1）题目条件：（2）题解： 最大值可能出现的情况只有两种，一种是三个全是正数，即数组最大的三个正数，另一种是两个负数一个正数，最小的两个负数和最大的一个正数 排序法 classSolution{ public: intmaximumProduct(vector<int>&nums){ sort(nums.begin(),nums.end()); intn=nums.size(); returnmax(nums[0]*nums[1]*nums[n-1],nums[n-3]*nums[n-2]*nums[n-1]); } }; 非排序法 是要找到最大的三个值和最小的两个值就可以了 classSolution{ public: intmaximumProduct(vector<int>&nums){ intn=nums.size(); intmax1=-1000,max2=-1000,max3=-1000;//第一、第二、第三大的数 intmin1=1000,min2=1000;//第一、第二小的数 for(inti=0;i<n;i++){ if(nums[i]>=max1){//大于最大的数 max3=max2;max2=max1;max1=nums[i]; } elseif(nums[i]>=max2){//在max1和max2之间 max3=max2;max2=nums[i]; } elseif(nums[i]>=max3){//在max2和max3之间 max3=nums[i]; } if(nums[i]<=min1){//比最小值还小 min2=min1;min1=nums[i]; } elseif(nums[i]<=min2){//在min1和min2之间 min2=nums[i]; } } returnmax(min1*min2*max1,max3*max2*max1); } }; 5.219-存在重复元素II （1）题目条件：（2）题解： 哈希表HashSet，HashSet继承于set类，set类的元素都是唯一的。算法步骤：i.构造一个哈希表set，让哈希表的长度始终为kii.遍历整个数组，看遍历的元素是否已经存在于set集合中了，若在集合中，则返回true，若没在集合中，则将该元素加入哈希表，若哈希表的长度超过k，则将最先加入的元素移除 解法说明：https://leetcode-cn.com/problems/contains-duplicate-ii/solution/hua-jie-suan-fa-219-cun-zai-zhong-fu-yuan-su-ii-by/ classSolution{ publicbooleancontainsNearbyDuplicate(int[]nums,intk){ HashSet<Integer>set=newHashSet<>(); for(inti=0;i<nums.length;i++){ if(set.contains(nums[i]))returntrue; set.add(nums[i]); if(set.size()>k){ set.remove(nums[i-k]); } } returnfalse; } } 6.228-汇总区间 （1）题目条件：（2）题解： 代码注意事项i.while(i<n&&nums[i-1]+1==nums[i])要先写i<n，因为若数组只有一个元素，则i<n是错误的直接不进行循环，但若是先写后面的条件，由于nums[i]不存在，所以会报错（这个问题找了好久）ii.c++中存在string类，将数字转换成字符可以使用to_string函数，在后面添加元素可以用append函数 classSolution{ public: vector<string>summaryRanges(vector<int>&nums){ inti=0; vector<string>ret; intn=nums.size(); while(i<n){ intlow=i; i++; while(i<n&&nums[i-1]+1==nums[i]){ i++; } inthigh=i-1; stringtemp=to_string(nums[low]); if(low<high){//证明存在一个区间 temp.append("->"); temp.append(to_string(nums[high])); } ret.push_back(temp); } returnret; } }; 7.1-两数之和 （1）题目条件： （2）题解： 暴力枚举 classSolution{ public: vector<int>twoSum(vector<int>&nums,inttarget){ intn=nums.size(); for(inti=0;i<n;i++){ intj=i+1; while(j<n){ if(nums[i]+nums[j]==target){ returnvector<int>{i,j}; } else{ j++; } } } returnvector<int>{-1,-1}; } }; 哈希表 classSolution{ publicint[]twoSum(int[]nums,inttarget){ Map<Integer,Integer>map=newHashMap<>(); for(inti=0;i<nums.length;i++){ if(map.containsKey(target-nums[i])){ returnnewint[]{map.get(target-nums[i]),i}; } map.put(nums[i],i); } returnnewint[]{-1,-1}; } } 8.167-两数之和II-输入有序数组 （1）题目条件： （2）题解：利用数组有序的条件 二分查找固定第一个值，寻找第二个值的时候用二分查找的方法能缩短查找时间，提高效率。 classSolution{ public: vector<int>twoSum(vector<int>&numbers,inttarget){ intn=numbers.size(); for(inti=0;i<n;i++){ intlow=i+1,high=n-1; while(low<=high){ intmid=(high-low)/2+low; if(numbers[mid]==target-numbers[i]){ return{i+1,mid+1}; } elseif(numbers[mid]>target-numbers[i]){ high=mid-1; } else{ low=mid+1; } } } return{-1,-1}; } }; 双指针初始时将两个指针放在数组两侧，sum为两个指针指向数据之和若sum==target，则找到唯一解若sum<target，左指针向右移，增大sum若sum>target，右指针向左移，减小sum classSolution{ public: vector<int>twoSum(vector<int>&numbers,inttarget){ intlow=0,high=numbers.size()-1; while(low<high){ intsum=numbers[low]+numbers[high]; if(sum==target){ return{low+1,high+1}; } elseif(sum>target){ high--; } else{ low++; } } return{-1,-1}; } }; ``` 
第34篇文章[0]
软件构造笔记（二） 面向复用的软件构造技术 一.复用基本概念（一）复用编程：（二）四类复用级别： 二.LSP--LiskovSubstitutionPrinciple（一）内容：（二）协变：（三）逆变： 三.Delegation 一.复用基本概念 （一）复用编程： 1.programmingforreuse面向复用编程：开发出可复用的软件2.programmingwithreuse基于复用编程：利用已有的可复用软件搭建应用系统 （二）四类复用级别： 1.源代码级别的复用2.模块级别的复用：类、抽象类、接口3.库级别的复用：API、包4.系统级别的复用：框架 二.LSP–LiskovSubstitutionPrinciple （一）内容： 1.前置条件不能强化2.后置条件不能弱化3.不变量要保持4.子类型方法参数：逆变5.子类型方法返回值：协变 （二）协变： 1.返回值类型：不变或变得更具体2.异常类型：不变或变得更具体3.举例：（1）返回值类型 classT{//父类 Objecta(){ } } classSextendsT{//子类 @Override Stringa(){ } } （2）异常值类型 classT{//父类 voidbthrowsThrowable{ } } classSextendsT{//子类 @Override voidbthrowsIOException{ } } （三）逆变： 1.参数类型：要相反的变化，要不变或越来越抽象2.举例：(会报错，目前Java把这种形式看作overload） classT{//父类 voidc(Strings){ } } classSextendsT{//子类 @Override voidc(Objects){ } } 三.Delegation 1.委派：一个对象请求另一个对象的功能2.定义类时不用extends比如：privateGraphgraph=Graph.empty()3.使用条件：子类只需要复用父类中的一小部分方法4.建立delegation步骤：（1）永久保存delegation关系：List<Student>ls;（2）建立delegation关系：this.ls.add(s);（3）逐个delegate：通过for循环实现5.举例来讲： classProfessor{ List<Student>ls; voidenroll(Students){ this.ls.add(s); } voidevalute(){ doublescore=0; for(Students:ls) score+=s.evaluate(this); } } 
第35篇文章[1]
gcc常用命令行编译指令 1.gcc-Esource_file.c -E，只执行到预编译。直接输出预编译结果。 2.gcc-Ssource_file.c -S，只执行到源代码到汇编代码的转换，输出汇编代码。 3.gcc-csource_file.c -c，只执行到编译，输出目标文件。 4.gcc(-E/S/c/)source_file.c-ooutput_filename -o,指定输出文件名，可以配合以上三种标签使用。-o参数可以被省略。这种情况下编译器将使用以下默认名称输出：-E：预编译结果将被输出到标准输出端口（通常是显示器）-S：生成名为source_file.s的汇编代码-c：生成名为source_file.o的目标文件。无标签情况：生成名为a.out的可执行文件。 5.gcc-gsource_file.c -g，生成供调试用的可执行文件，可以在gdb中运行。由于文件中包含了调试信息因此运行效率很低，且文件也大不少。这里可以用strip命令重新将文件中debug信息删除。这是会发现生成的文件甚至比正常编译的输出更小了，这是因为strip把原先正常编译中的一些额外信息（如函数名之类）也删除了。用法为stripa.out 6.gcc-ssource_file.c -s,直接生成与运用strip同样效果的可执行文件（删除了所有符号信息）。 7.gcc-Osource_file.c -O（大写的字母O），编译器对代码进行自动优化编译，输出效率更高的可执行文件。-O后面还可以跟上数字指定优化级别，如：gcc-O2source_file.c数字越大，越加优化。但是通常情况下，自动的东西都不是太聪明，太大的优化级别可能会使生成的文件产生一系列的bug。一般可选择2；3会有一定风险。 8.gcc-Wallsource_file.c -W，在编译中开启一些额外的警告（warning）信息。-Wall，将所有的警告信息全开。 9.gccsource_file.c-L/path/to/lib-lxxx-I/path/to/include -l,指定所使用到的函数库，本例中链接器会尝试链接名为libxxx.a的函数库。-L，指定函数库所在的文件夹，本例中链接器会尝试搜索/path/to/lib文件夹。-I,指定头文件所在的文件夹，本例中预编译器会尝试搜索/path/to/include文件夹。 示例：在linux下已经创建了一个hello.c文件(1)hello.c-->hello.i:gcc-Ehello.c-ohello.i(预编译的结果)(2)hello.i-->hello.s:gcc-Shello.c-ohello.s(产生汇编代码）(3)hello.s-->hello.o:gcc-chello.s-ohello.o(4)hello.o-->hello.out:gcchello.c-ohello.out 原文链接：https://blog.csdn.net/zhubaohua_bupt/article/details/52763639 
第36篇文章[0]
软件构造笔记（七）---PPT第三讲 软件配置管理SCM与版本控制系统VCS 软件配置管理SCM基本概念 版本控制系统VCS分类本地版本控制系统集中式版本控制系统分布式版本控制系统 Git工具操作可视化ObjectGraph 存储文件基本操作gitcommitgitpushgit分支/合并 软件配置管理SCM 基本概念 1.SCM：追踪和控制软件的变化2.SCI软件配置项：软件中发生变化的基本单元，如文件3.baseline基线：软件持续变化过程中的稳定时刻，如对外发布的版本4.CMDB：配置管理数据库 版本控制系统VCS 分类 本地版本控制系统 仓库存储于开发者本地机器，无法共享和协作 集中式版本控制系统 仓库存储于独立的服务器，支持多开发者之间的协作 分布式版本控制系统 仓库存储于独立的服务器+每个开发者的本地机器 Git工具 操作可视化 workspace：工作区staging：暂存区 ObjectGraph 特点：（1）A->B表示在版本B的基础上作出变化，形成了版本A（2）每个commit指向一个父亲（3）多个commit指向同一个父亲：分支（4）一个commit指向两个父亲：合并 存储文件 Git存储发生变化的文件（而非代码行），不变化的文件不重复存储 基本操作 gitcommit gitpush git分支/合并 开始gitcheckout–biss53：创建名为iss53的新分支，即创建一个指针指向当前位置gitcommit：由于此时在iss53分支上，所以只对该分支进行操作，提交文件后，将iss53指针向后移动一步，master指针不变下面的操作同理，切换到master分支，创建新分支：hotfix，在该分支进行提交切换到master分支，将其与hotfix分支进行合并，合并结果就是两个指针指向同一处-d代表删除hotfix分支若要合并master与iss53分支最终结果： 
第37篇文章[0]
软件构造笔记（六）---PPT第一讲 多维度视图和质量目标 多维度试图Build-time1.build-time\moment\code-levelview2.build-time\period\code-levelview3.build-time\moment\component-levelview4.build-time\period\component-levelview Run-time1.run-time\moment\code-levelview2.run-time\period\code-levelview3.run-time\moment\component-levelview4.run-time\period\component-levelview 视图维度的转换 质量目标外部质量因素内部质量因素两者关系 多维度试图 按阶段划分：构造时/运行时按动态性划分：时刻/阶段按构造对象的层次划分：代码/构件 Build-time 1.build-time\moment\code-levelview 1.词汇层面：Lexical-orientedsourcecode2.语法层面：AST3.语义层面：ClassDiagram 2.build-time\period\code-levelview Codechurn：代码变化 3.build-time\moment\component-levelview Package\File\StaticLinking\Library 4.build-time\period\component-levelview ConfigurationItem(配置项)\Version(版本) Run-time 1.run-time\moment\code-levelview Snapshotdiagram代码快照图\MemoryDump内存信息转储 2.run-time\period\code-levelview Executionstacktrace执行跟踪：用日志方式记录程序执行的调用次序 3.run-time\moment\component-levelview Dynamiclinking等 4.run-time\period\component-levelview Eventlog：事件日志 视图维度的转换 质量目标 外部质量因素 影响用户1.正确性：发现不正确、消除不正确2.健壮性：针对异常情况的处理3.可扩展性：对spec的修改是否足够容易4.可复用性：一次开发，多次使用5.兼容性：不同软件系统之间相互可容易的集成6.性能：与其他质量属性折中7.可移植性：软件在不同的技术环境之间移植8.易用性：容易学、安装、操作9.功能性10.及时性 内部质量因素 影响软件本身和它的开发者1.可读性2.易理解性3.清晰性4.大小 两者关系 外部质量取决于内部质量 
第38篇文章[1]
CSAPP--DataLab 目录 前言1.bitXor2.tmin3.isTmax4.allOddBits5.negate6.isAsciiDigit7.conditional8.isLessOrEqual9.logicalNeg10.howManyBits11.floatScale212.floatFloat2Int13.floatPower2 前言 在看完csapp第二章之后，上网找了配套的lab做，发现难度不是一般的大，附上实验链接：csapp实验网站，直接点Self-StudyHandout就可以下载实验的资料，做实验之前要先把前面的README之类的先都看一遍，看一下实验要求 1.bitXor //1 /* *bitXor-x^yusingonly~and& *Example:bitXor(4,5)=1 *Legalops:~& *Maxops:14 *Rating:1 */ 题目条件：手动实现异或 x&y能够得到x、y都为1的位，(~x&~y)能够得到x、y都为0的位，由于异或是两者相同取零，所以要对两者都取反，即~(~x&~y)&~(x&y)，可能还比较懵，举例说明一下 intbitXor(intx,inty){ return~(~x&~y)&~(x&y); } 2.tmin /* *tmin-returnminimumtwo'scomplementinteger *Legalops:!~&^|+<<>> *Maxops:4 *Rating:1 */ 题目条件：返回TMin TMin是符号位为1，其余位都是0，通过移位操作即可实现，1<<31是将第31位的1移到第一位，其余位用零填补 inttmin(void){ return1<<31; } 3.isTmax /* *isTmax-returns1ifxisthemaximum,two'scomplementnumber, *and0otherwise *Legalops:!~&^|+ *Maxops:10 *Rating:1 */ 题目条件：如果1是TMax，则返回1，否则返回0 TMin是符号位为1，其余位都是0，TMax是~(1<<31)，x与TMax取异或，之后再取反，即可得到结果 intisTmax(intx){ return!(x^(~(1<<31))); } 4.allOddBits /* *allOddBits-return1ifallodd-numberedbitsinwordsetto1 *wherebitsarenumberedfrom0(leastsignificant)to31(mostsignificant) *ExamplesallOddBits(0xFFFFFFFD)=0,allOddBits(0xAAAAAAAA)=1 *Legalops:!~&^|+<<>> *Maxops:12 *Rating:2 */ 题目条件：如果奇数位值都为1，则返回1，否则返回0 可以通过掩码的方式，得到奇数位的值，同时将偶数位设置为0将wall设置为0xAA，则前8位满足奇数位为1，偶数位为0，通过移位得到了wall=0xAAAAAAAA，将x与wall相与，得到x的奇数位的值，再将其与wall相异或，看奇数位是否仍为1（这里存在一点疑问，本来我是想要直接将wall设置成0xAAAAAAAA，但是网上的答案都是通过移位实现的，感觉应该没什么区别吧…） intallOddBits(intx){ intwall=0xAA; wall=wall+(wall<<8)+(wall<<16)+(wall<<24) return!(wall^(x&wall)); } 5.negate /* *negate-return-x *Example:negate(1)=-1. *Legalops:!~&^|+<<>> *Maxops:5 *Rating:2 */ **题目条件：得到值的非** 根据csapp书上的公式，-x=~x+1即可求解 intnegate(intx){ return(~x+1); } 6.isAsciiDigit /* *isAsciiDigit-return1if0x30<=x<=0x39(ASCIIcodesforcharacters'0'to'9') *Example:isAsciiDigit(0x35)=1. *isAsciiDigit(0x3a)=0. *isAsciiDigit(0x05)=0. *Legalops:!~&^|+<<>> *Maxops:15 *Rating:3 */ 题目条件：如果x值在0x30到0x39之间，则返回1，否则返回0 与边界值进行比较，如果在0x30和0x39之间，左右两边的符号位都为0，向右移动31位之后仍为0，若是不满这个条件，则左右两边或的结果是全为1，取反之后得到零 intisAsciiDigit(intx){ return!(((x-0x30)>>31)|((0x39-x)>>31)); } 7.conditional /* *conditional-sameasx?y:z *Example:conditional(2,4,5)=4 *Legalops:!~&^|+<<>> *Maxops:16 *Rating:3 */ 题目条件：如果x为真，返回y，如果不为真，则返回z 此题解法十分巧妙，将x化为布尔值，也就是说，x为0时，布尔值为0x00…00，x为其他值时，布尔值为0x00…01。对x的布尔值取反加1，当x为0，val全为0，当x不为0时，val全为1利用或运算，当val取1时，返回y，当val取0时，返回z intconditional(intx,inty,intz){ intval=~(!!x)+1; return(val&y)|(~val&z); } 8.isLessOrEqual /* *isLessOrEqual-ifx<=ythenreturn1,elsereturn0 *Example:isLessOrEqual(4,5)=1. *Legalops:!~&^|+<<>> *Maxops:24 *Rating:3 */ 题目条件：如果x<=y，则返回1，否则返回0 分情况讨论：如果x、y符号位相同，则比较x-y的值即可如果符号位不同，x符号位为0时返回0，x符号位为1时返回1 如果x和y符号位相同，则val1=0，若x<=y，则val2全1，若x>y,则val2全0若符号位不同，则val1=1利用位或表达式得到val2和val3的值 intisLessOrEqual(intx,inty){ intval1=(x<<31)+(y<<31); intval2=!((y+~x+1)>>31); intval3=(x>>31)&1; return(val1&val3)|(~val1&val2)； } 9.logicalNeg /* *logicalNeg-implementthe!operator,usingallof *thelegaloperatorsexcept! *Examples:logicalNeg(3)=0,logicalNeg(0)=1 *Legalops:~&^|+<<>> *Maxops:12 *Rating:4 */ 题目条件：实现x逻辑非 0的非是1，其他值的非都是0如果x为0，x|x的符号位是0，向右移31位再加1能得到1，而其他的值与自身的复数进行或操作的符号位为1，向右移31位再加1能得到0 intlogicalNeg(intx){ return(x|(~x+1))>>31+1; }  剩下的等之后再补充吧，感觉前面的还是挺难想的，先把题目放在这里了 10.howManyBits /*howManyBits-returntheminimumnumberofbitsrequiredtorepresentxin *two'scomplement *Examples:howManyBits(12)=5 *howManyBits(298)=10 *howManyBits(-5)=4 *howManyBits(0)=1 *howManyBits(-1)=1 *howManyBits(0x80000000)=32 *Legalops:!~&^|+<<>> *Maxops:90 *Rating:4 */ inthowManyBits(intx){ return0; } 11.floatScale2 /* *floatScale2-Returnbit-levelequivalentofexpression2*ffor *floatingpointargumentf. *Boththeargumentandresultarepassedasunsignedint's,but *theyaretobeinterpretedasthebit-levelrepresentationof *single-precisionfloatingpointvalues. *WhenargumentisNaN,returnargument *Legalops:Anyinteger/unsignedoperationsincl.||,&&.alsoif,while *Maxops:30 *Rating:4 */ 题目条件： unsignedfloatScale2(unsigneduf){ return2; } 12.floatFloat2Int /* *floatFloat2Int-Returnbit-levelequivalentofexpression(int)f *forfloatingpointargumentf. *Argumentispassedasunsignedint,but *itistobeinterpretedasthebit-levelrepresentationofa *single-precisionfloatingpointvalue. *Anythingoutofrange(includingNaNandinfinity)shouldreturn *0x80000000u. *Legalops:Anyinteger/unsignedoperationsincl.||,&&.alsoif,while *Maxops:30 *Rating:4 */ intfloatFloat2Int(unsigneduf){ return2; } 13.floatPower2 /* *floatPower2-Returnbit-levelequivalentoftheexpression2.0^x *(2.0raisedtothepowerx)forany32-bitintegerx. * *Theunsignedvaluethatisreturnedshouldhavetheidenticalbit *representationasthesingle-precisionfloating-pointnumber2.0^x. *Iftheresultistoosmalltoberepresentedasadenorm,return *0.Iftoolarge,return+INF. * *Legalops:Anyinteger/unsignedoperationsincl.||,&&.Alsoif,while *Maxops:30 *Rating:4 */ unsignedfloatPower2(intx){ return2; } 参考：1.https://www.cnblogs.com/panhz/p/13450085.html2.https://zhuanlan.zhihu.com/p/149689152 
第39篇文章[0]
软件构造笔记（十）---PPT第六讲 抽象数据类型ADT ADT操作的四种类型Creator构造器Producer生产器Observer观察器Mutator变值器测试四种类型 ADT特性表示独立性RepresentationIndependence不变量InvariantsAF和RI两个空间抽象函数AF表示不变量RI 总结 抽象类型：强调“作用于数据上的操作”，程序员和client无需关心数据如何具体存储的，只需设计/使用操作即可。 可变类型的对象：提供了可改变其内部数据的值的操作不变数据类型：其操作不改变内部值，而是构造新的对象 ADT操作的四种类型 Creator构造器 1.构造器创建该类型的新对象。2.构造器可以接受一个对象作为参数，但不能接受正在构造的类型的对象。3.可能实现为构造函数或静态函数 Producer生产器 生产器从该类型的旧对象创建新对象例如，String的concat()方法是一个生成器:它接受两个字符串并生成一个表示它们的连接的新字符串。 Observer观察器 观察器接受抽象类型的对象并返回不同类型的对象。例如，List的size()方法返回一个int。 Mutator变值器 1.变值器是改变对象属性的方法例如，List的add()方法通过在列表的末尾添加一个元素来改变列表。2.变值器通常返回void，如果返回值为void，则必然意味着它改变了对象的某些内部状态；变值器也可能返回非空类型 测试四种类型 1.测试creators,producers,andmutators：调用observers来观察这些operations的结果是否满足spec；2.测试observers：调用creators,producers,andmutators等方法产生或改变对象，来看结果是否正确。 ADT特性 表示独立性RepresentationIndependence client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。例如，List提供的操作与列表是作为链表还是以数组表示无关。违反表示独立性的例子：函数直接调用内部rep的方法进行实现，也就是只有知道内部实现才能进行如下调用，所以破坏了独立性下图中能看出右边修改后的例子调用getMembers()函数，调用的方法是返回值List的get方法，而不是内部实现的set的方法。换句话说，外部实现只需要关注外部已知的内容，而不需要关注内部的实现，保持了很好的独立性 不变量Invariants 由ADT来负责其不变量，与client端的任何行为无关为什么需要表示不变量？举例来说这是一个不可变的ADT，但由于字段都定义为public，既可以被外部访问，所以客户端可以直接对字段进行操作，对安全性有威胁。这被称为表示泄露representationexposure：这意味着类之外的代码可以直接修改字段。不仅影响不变性，也影响了表示独立性：无法在不影响客户端的情况下改变其内部表示首先进行第一步修改，将字段修饰为privatefinalprivate和public关键字指示哪些字段和方法只能在类内部访问，哪些字段和方法可以从类外部访问。final关键字还有助于保证该不可变类型的字段在对象构造后不会被重新赋值。但是还是存在一些问题，retweetLater应该返回另一条信息，但却是一个小时之后才返回，所以Tweet的不变性被破坏了，原因是该方法泄露了对可变对象的引用。解决方法：进行防御式拷贝 另外一个例子这个代码会导致date都为23因为Date()是可变类型，在每次调用时，Tweet都指向相同的Date()对象解决方法：防御式拷贝注意：通常，应该仔细检查所有ADT操作的参数类型和返回类型。如果任何类型是可变的，请确保不会返回对其表示的直接引用。因为这样做会造成表示泄露。 AF和RI 表示不变量RepInvariant和抽象函数AbstractionFunction 两个空间 表示值(代表值)的空间由实际实现实体的值组成。抽象值构成的空间：client看到和使用的值。ADT开发者关注表示空间R，client关注抽象空间A 抽象函数AF 抽象函数：R和A之间映射关系的函数，即如何去解释R中的每一个值为A中的每一个值。关系：AF:R->A R中的部分值并非合法的，在A中无映射值1.每个抽象值都被一些代表值映射到（满射）2.一些抽象值被多个代表值映射到（未必单射）3.并不是所有的rep值都被映射（未必双射） 表示不变量RI RI:R->boolean表示不变性RI：某个具体的“表示”是否是“合法的”也可将RI看作：所有表示值的一个子集，包含了所有合法的表示值也可将RI看作：一个条件，描述了什么是“合法”的表示值 下图是AF和RI的书写选择某种特定的表示方式R，进而指定某个子集是“合法”的(RI)，并为该子集中的每个值做出“解释”(AF) 即如何映射到抽象空间中的值。 总结 设计ADT：(1)选择R和A；(2)RI 合法的表示值；(3)如何解释合法的表示值 映射AF做出具体的解释：每个repvalue如何映射到abstractvalue 
第40篇文章[0]
软件构造笔记（三） 判断ADT中的等价性 一.引用等价性==二.对象等价性equals 前言：在很多场景下，需要判定两个对象是否“相等”，本文主要讨论==和equals的区别。 一.引用等价性== 对基本数据类型，使用==判定相等 二.对象等价性equals 1.对对象类型，使用equals判定相等2.equals的实现： publicclassObject{   publicbooleanequals(Objectthat){ returnthis==that;//在对象等价性的判断是用引用等价性实现的 } } 一般来说，这个equals的实现通常不是程序员所期待的，所以一般需要重写 3.错误示例： publicclassDuration{   publicbooleanequals(Durationthat){ returnthis.getLength()==that.getLength() } } Durationd1=newDuration(1,2); Durationd2=newDuration(1,2); Objecto2=d2; d1.equals(d2);//结果为true d1.equals(o2);//结果为false d2是Duration类型，所以传入参数时实现的是Duration中的equals，即判断长度相等，所以结果为true；而o2是Object类型，所以传入参数时实现的是Object中的equals，即通过引用等价性进行判断，由于d1和o2是两个不同的对象，所以结果为false. ！！原因是上面equals的实现并不是重写，而是重载，因为改变了参数的类型。 4.重写equals的方法 @Override publicboolwanequals(Objectthat){ returnthatinstanceofDuration&&this.sameValue((Duration)that); } privatebooleansameValue(Durationthat){ returnthis.getLength==that.getLength(); } 5.对于可变类型的等价性实现行为等价性即可，而且无需重写equals和hashcode两个函数 
第41篇文章[0]
软件构造笔记（九）---PPT第五讲 设计规约 行为等价性规约前置/后置条件设计规约规约的强度 行为等价性 举例来说：站在客户的角度，下面两个函数行为是否等价分情况：1.当val缺失时，findFirst返回arr的长度，findLast返回-12.当val出现两次时，findFirst返回较低的索引，findLast返回较高的索引。3.但是当val恰好出现在数组的一个下标处时，这两个方法的行为是相同的。当它们调用这个方法时，它们将传入一个包含一个元素val的arr。对于这样的客户端，这两个方法是相同的。 所以，其实现在没有办法准确定义这两个函数行为是否等价。但如果我们设计一个spec规约，根据规约判定两个函数是否等价，能看出来，上述两个函数满足改规约，所以函数等价如何判断行为等价性：1.单纯的看实现代码，并不足以判定不同的implmentation是否是“行为等价的”。2.需要根据代码的spec（开发者与client之间形成的contract）判定行为等价性。3.在编写代码之前，需要弄清楚spec如何协商形成、如何撰写。 规约前置/后置条件 1.前置条件：对客户端的约束，在使用方法时必须满足的条件2.后置条件：对开发者的约束，方法结束时必须满足的条件3.契约：如果前置条件满足了，后置条件必须满足。如果前置条件不满足，则方法可做任何事情。4.设计特点：参数由@param子句描述，结果由@return和@throws子句描述。尽可能将前置条件放入@param中，将后置条件放入@return和@throws中。5.方法的说明可以讨论方法的参数和返回值，但绝不应该讨论方法的局部变量或方法类的私有字段。6.可变方法的spec：前两种都是可变方法，会修改传入的参数，但是除非在后置条件里声明过，否则方法内部不应该改变输入参数。应尽量遵循此规则，尽量不设计mutating的spec，否则就容易引发bugs。 设计规约 规约的强度 1.存在规约S1和S2，判断是否可以用S2替代S1若满足条件：S2的前置条件更弱、后置条件更强，则证明S2>=S1，可以用S2代替S1spec变强：更放松的前置条件+更严格的后置条件越强的规约，意味着implementor的自由度和责任越重，而client的责任越轻。2.举例：（1）前置条件变弱，后置条件不变判断后置条件是要在满足第一个函数的前置条件的前提下，能发现后置条件相同（2）前置条件和后置条件都变弱了，无法判断 
第42篇文章[0]
软件构造笔记（十一）---PPT第七讲 面向对象的编程 静态/实例方法接口接口和类静态工厂方法default三个关键字 重写Override重载Overrload泛型 静态/实例方法 静态变量/方法：与类关联的变量，而不是与类的实例关联的变量。若将方法与类关联，则为静态方法 要引用类变量和方法，可以用句点(’.’)将类的名称和类方法或类变量的名称连接起来 实例变量/方法：不是类方法或类变量的方法和变量称为实例方法或实例变量。 要引用实例方法和变量，必须引用来自类实例的方法和变量。 总结：类变量和类方法与一个类关联，并且每个类只出现一次。使用它们不需要创建对象。 实例方法和变量在一个类的每个实例中出现一次。静态方法不与类的任何特定实例相关联，而实例方法(声明时不使用Static关键字)必须在特定对象上调用。举例来说：注意：1.静态方法只能调用静态变量2.实例方法既可以调用静态变量，也可以调用正常变量3.main函数中调用static变量：使用类+方法名称调用两者对比： 接口 接口和类 Interface和Class:定义和实现ADT接口：确定ADT规约；类：实现ADT 1.接口之间可以继承与扩展2.一个类可以实现多个接口（从而具备了多个接口中的方法）3.一个接口可以有多种实现类4.也可以不需要接口直接使用类作为ADT，既有ADT定义也有ADT实现，实际中更倾向于使用接口来定义变量 静态工厂方法 设MyString是接口，FastMyString是实现MyString接口的类实现过程出现了问题：1.打破了抽象边界，接口定义中没有包含constructor，也无法保证所有实现类中都包含了同样名字的constructor。2.故而，客户端需要知道该接口的某个具体实现类的名字修改策略：使用静态工厂方法，可以避免使用具体实现类的名字 default 接口中的每个方法在所有类中都要实现；通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它；以增量式的为接口增加额外的功能而不破坏已实现的类 三个关键字 private：只能在声明类中访问protected：可从声明类的子类(以及包内)访问public：可以任意访问 重写Override 重写是在运行时决定执行哪个方法使用final关键字的方法不能在子类中被重写重写的函数：完全同样的signature实际执行时调用哪个方法，运行时决定如果父类的一个对象被用来调用该方法，则父类中的版本将被执行;如果使用子类的对象来调用该方法，则执行子类中的版本 父类型中的被重写函数体不为空：意味着对其大多数子类型来说，该方法是可以被直接复用的。对某些子类型来说，有特殊性，故重写父类型中的函数，实现自己的特殊要求如果父类型中的某个函数实现体为空，意味着其所有子类型都需要这个功能，但各有差异，没有共性，在每个子类中均需要重写。重写之后，利用super()复用了父类型中函数的功能，并对其进行了扩展子类的构造方法若要继承父类，则应该放在构造函数的第一步 重载Overrload 重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型价值：方便client调用，client可用不同的参数列表，调用同样的函数重载是在编译阶段时决定要具体执行哪个方法，即静态检查时决定特点：1.不同的参数列表2.相同/不同的返回值类型3.相同/不同的public/private/protected4.可以声明异常5.可以在同一个类内重载，也可在子类中重载 举例来说：定义如下的类若判断条件如下，会产生异常，原因是由于重载方法是在编译时检查，ah2此时还是Animal类型，所以应用的eat方法不应该传入参数以下两种声明方式就不会出错第一个调用Animal类中的方法第二个调用Horse类中的方法，传入参数另一个例子如下Animal若是接口，则可以按照3的方式进行调用两者的区别与联系： 泛型 泛型接口的实现方法1.泛型接口、非泛型实现类2.泛型接口、泛型实现类 
第43篇文章[1]
CSAPP练习题3.4 题目条件 src_t*sp;dest_t*dp;sp和dp的值分别存储在寄存器%rdi和寄存器%rsi中，表中每个表项应实现两条指令，第一条是从内存中读数，做适当的转换，并设置寄存器%rax的适当部分。第二条指令是要把%rax的适当部分写到内存。在这两种情况下，寄存器的部分可以是%rax,%eax,%ax或%al。当执行强制类型转换既涉及大小变化又涉及C语言中符号变化时，操作应先改变大小 要求实现：*dp=(dest_t)*sp; src_tdest_t指令longlongcharintcharunsignedunsignedcharlongintcharunsignedunsignedcharcharshort 这个转换比较繁琐，但是根据csapp书上图3-4、图3-5、图3-6的知识点就能完成相应的转换，下面来一行一行的进行推导 1.long-->long long是8个字节，8个字节的转换用movq，存储器是64位，所以用%rax。 读取8字节：movq(%rdi),%rax存储8字节：movq%rax,(%rsi) 2.char-->int char是1个字节，int是4个字节，并且是有符号数，进行符号扩展，movs是符号扩展，由于要扩展到4字节，所以用movsbl。4个字节的存储器用%eax。 读1个字节并进行符号扩展：movsbl(%rdi),%eax存储4字节：movl%eax,(%rsi) 3.char-->unsigned char是1个字节，unsigned是4个字节，已知当执行强制类型转换既涉及大小变化又涉及C语言中符号变化时，操作应先改变大小，所以先将char转换为int，选择符号扩展，存储器选用%eax。 读1个字节并进行符号扩展：movsbl(%rdi),%eax存储4字节：movl%eax,(%rsi) 4.unsignedchar-->long unsignedchar是1个字节，long是8个字节，应先改变大小，将char转换为long，由于char是无符号数，所以进行零扩展，选择movzbq，存储器选择%rax。 读1个字节并进行零扩展：movzbq(%rdi),%rax存储8字节：movq%rax,(%rsi) 这道题第一条指令的答案是movzbl(%rdi),%eax，之前上网查好像是与cpu有关，但是我没太弄懂，感觉按原理来说应该是我上面的答案 5.int-->char int是4个字节，char是1个字节，所以先将int的值从内存复制到存储器中，在从存储器中存低位字节即可。 读4个字节：movl(%rdi),%eax存低位字节：movb%al,(%rsi) 6.unsigned-->unsignedchar 这个与第五个是一样的原理，就不复述了。 读4个字节：movl(%rdi),%eax存低位字节：movb%al,(%rsi) 7.char-->short char是1个字节，short是2个字节，由于是有符号数，所以进行符号扩展，存储器选择%ax。 读1个字节并进行符号扩展：movsbw(%rdi),%ax存两个字节：movw%ax,(%rsi) 
第44篇文章[0]
软件构造笔记（十二）---PPT第八讲 ADT和OOP中的等价性 前言引用等价性对象等价性equals()函数hashcode()函数 观察等价性行为等价性总结 前言 等价性的划分：不可变对象的引用等价性==和对象等价性equals()可变对象的观察等价性和行为等价性 引用等价性 ==操作符比较引用。它测试引用相等。两个引用是==如果它们指向内存中的相同存储。在快照图中，如果两个引用的箭头指向同一个对象气泡，则它们为==。==对基本数据类型，使用==判定相等 对象等价性 equals()函数 equals()操作比较对象内容 换句话说，对象相等。对对象类型，使用equals() 正常的equals()方法：在Object中实现的缺省equals()是在判断引用等价性，所以应该重写equals()方法错误重写：这是Overload，不是重写正确重写：一个更好的方法去实现equals() hashcode()函数 等价的对象必须有相同的hashCode根据上面描述的Duration类，在修改equals()函数之后，d1.equals(d2)=true，但是输出hashCode()的值发现两者的哈希值不同修改方法：为对象的每个组件计算一个散列代码，用于确定是否相等(通常通过调用每个组件的hashCode方法)，然后组合这些散列代码，并进行一些算术操作。对于Duration，这很容易，因为类的抽象值已经是一个整数值: 观察等价性 当不能通过不改变对象状态的观察来区分它们时，也就是说，只调用observer、producer和creator方法。这通常被严格地称为观察等价性，因为它测试两个对象在程序的当前状态下是否“看起来”相同。观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致对可变类型来说，往往倾向于实现严格的观察等价性 实现观察等价性的缺陷： 行为等价性 当它们不能通过任何观察来区分时，甚至状态也会改变。这种解释允许调用两个对象上的任何方法，包括mutators。这被称为行为平等，因为它测试两个物体在当前状态和所有未来状态下是否会“表现”相同。行为等价性：调用对象的任何方法都展示出一致的结果 对可变类型，实现行为等价性即可。也就是说，只有指向同样内存空间的objects，才是相等的。所以对可变类型来说，无需重写equals()andhashCode()这两个函数，直接继承Object的两个方法即可。如果一定要判断两个可变对象看起来是否一致，最好定义一个新的方法。 总结 1.对于不可变对象：equals()应该比较抽象值。这就相当于说equals()应该提供行为平等。hashCode()应该将抽象值映射为整数。所以，不可变类型必须重写equals()和hashcode()函数2.对于可变对象：equals()应该比较引用，就像==一样。同样，这就相当于说equals()应该提供行为平等。hashCode()应该将引用映射为一个整数。所以，可变类型不需要重写equals()和hashcode()函数 
第45篇文章[0]
软件构造笔记（十五）--PPT第十一讲 面向可复用性和可维护性的设计模式 Creationalpatterns创建型模式Structuralpatterns结构型模式Adapter适配器模式Decorator装饰器模式 Behavioralpatterns行为类模式Strategy策略模式TemplateMethod模板模式IteratorVisitor 设计模式的对比共性模式1共性模式2 Creationalpatterns创建型模式 工厂方法模式 当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。 定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。比如静态工厂方法： Structuralpatterns结构型模式 Adapter适配器模式 1.内容：将某个类/接口转换为client期望的其他形式，通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。2.举例：设置一个接口Shape，通过具体子类Rectangle实现display方法，但由于这个方法不是我们所期望的，我们需要通过一个适配器来实现内部的方法，并在Rectangle内部进行调用，这样可以通过接口封装内部实现 Decorator装饰器模式 本节内容引用：https://www.cnblogs.com/yxlaisj/p/10446504.html 1.用每个子类实现不同的特性，为对象增加不同侧面的特性，对每一个特性构造子类，通过委派机制增加到对象上。使用subtypinganddelegation2.举例：咖啡接口，获取价格和配料 /** *咖啡 */ interfaceCoffee{ /**获取价格*/ doublegetCost(); /**获取配料*/ StringgetIngredients(); } 原味咖啡类，实现咖啡接口，配料中只有咖啡 /** *原味咖啡 */ classSimpleCoffeeimplementsCoffee{ @Override publicdoublegetCost(){ return1; } @Override publicStringgetIngredients(){ return"Coffee"; } } 咖啡对象的装饰器类，同样实现Coffee接口，定义一个Coffe对象的引用，在构造器中进行初始化。并且将getCost（）和getIntegredients()方法转发给被装饰对象。 /** *咖啡的"装饰器"，可以给咖啡添加各种"配料" */ abstractclassCoffeeDecoratorimplementsCoffee{ protectedfinalCoffeedecoratedCoffee; /** *在构造方法中，初始化咖啡对象的引用 */ publicCoffeeDecorator(Coffeecoffee){ decoratedCoffee=coffee; } /** *装饰器父类中直接转发"请求"至引用对象 */ publicdoublegetCost(){ returndecoratedCoffee.getCost(); } publicStringgetIngredients(){ returndecoratedCoffee.getIngredients(); } } 具体的装饰器类，负责往咖啡中“添加”牛奶，注意看getCost（）方法和getIngredients()方法，可以在转发请求之前或者之后，增加功能。 /** *此装饰类混合"牛奶"到原味咖啡中 */ classWithMilkextendsCoffeeDecorator{ publicWithMilk(Coffeecoffee){ super(coffee); } @Override publicdoublegetCost(){ doubleadditionalCost=0.5; returnsuper.getCost()+additionalCost; } @Override publicStringgetIngredients(){ StringadditionalIngredient="milk"; returnsuper.getIngredients()+","+additionalIngredient; } } 另一个具体装饰器类，用来给咖啡加糖，一样的逻辑。 classWithSugarextendsCoffeeDecorator{ publicWithSugar(Coffeecoffee){ super(coffee); } @Override publicdoublegetCost(){ returnsuper.getCost()+1; } @Override publicStringgetIngredients(){ returnsuper.getIngredients()+",Sugar"; } } 客户端使用装饰器模式 publicclassDecoratorDemo{ staticvoidprint(Coffeec){ System.out.println("花费了:"+c.getCost()); System.out.println("配料:"+c.getIngredients()); System.out.println("============"); } publicstaticvoidmain(String[]args){ //原味咖啡 Coffeec=newSimpleCoffee(); print(c); //增加牛奶的咖啡 c=newWithMilk(c); print(c); //再加一点糖 c=newWithSugar(c); print(c); } } Behavioralpatterns行为类模式 Strategy策略模式 1.内容：有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里，为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。2.实现方式：3.举例：下图两个pay()方法的实现就是模板模式 TemplateMethod模板模式 1.问题：一些客户端共享相同的算法，但在细节上有所不同，例如，一个算法由可定制的部分和不变的部分组成。公共步骤不应在子类中重复，但需要重用。解决方法：共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现使用继承和重写实现模板模式2.举例：具体代码：抽象类的实现： Iterator 客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式 Visitor 1.内容：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。本质上：将数据和作用于数据上的某种/些特定操作分离开来。为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码，可以在不改变ADT本身的情况下通过delegation接入ADT 2.举例： VisitorvsIterator迭代器：以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。Visitor：在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT VisitorvsStrategy二者都是通过delegation建立两个对象的动态联系但是Visitor强调是的外部定义某种对ADT的操作，该操作于ADT自身关系不大（只是访问ADT），故ADT内部只需要开放accept(visitor)即可，client通过它设定visitor操作并在外部调用。而Strategy则强调是对ADT内部某些要实现的功能的相应算法的灵活替换。这些算法是ADT功能的重要组成部分，只不过是delegate到外部strategy类而已。区别：visitor是站在外部client的角度，灵活增加对ADT的各种不同操作（哪怕ADT没实现该操作），strategy则是站在内部ADT的角度，灵活变化对其内部功能的不同配置。 设计模式的对比 共性模式1 对于Adapter适用场合：你已经有了一个类，但其方法与目前client的需求不一致。根据OCP原则，不能改这个类，所以扩展一个adaptor和一个统一接口。对于模板模式：适用场合：有共性的算法流程，但算法各步骤有不同的实现，典型的“将共性提升至超类型，将个性保留在子类型” 共性模式2 对于Strategy：对于Iterator对于工厂方法：对于Visitor： 
第46篇文章[0]
工厂方法--笔记四 工厂方法 使用原因示例衣服工厂抽象类工厂定义了统一行为，具体类来实现具体行为调用代码 使用原因 当client不知道要创建哪个具体类的实例，或不想再client代码中指明要具体创建的实例时，用工厂方法。定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 示例 小A要开两个工厂做衣服，分别做短袖和长袖 衣服工厂抽象类 publicabstractclassClothesFactory(){ publicabstractClothmakeClothes(); } 工厂定义了统一行为，具体类来实现具体行为 短袖实现类 publicclassshortSleeveFactoryextendsClothesFactory{ @Override publicClothmakeClothes(){ returnnewshortSleeve(); } } 长袖实现类 publicclasslongSleeveFactoryextendsClothesFactory{ @Override publicClothmakeClothes{ returnnewlongSleeve(); } } 调用代码 publicclassMain{ publicstaticvoidmain(String[]args){ //短袖 ClothesFactoryshort=newshortSleeveFactory(); short.makeClothes.make(); //长袖 ClothesFactorylong=newlongSleeveFactory(); long.makeClothes.make(); 
第47篇文章[0]
软件构造笔记（十四）---PPT第十讲 面向可维护性的构造技术 OO设计原则：SOLID(SRP)TheSingleResponsibilityPrinciple(OCP)TheOpen-ClosedPrinciple(LSP)TheLiskovSubstitutionPrinciple(ISP)TheInterfaceSegregationPrinciple(DIP)TheDependencyInversionPrinciple OO设计原则：SOLID (SRP)TheSingleResponsibilityPrinciple SRP–单一责任原则1.内容：不应有多于1个的原因使得一个类发生变化，即一个类，一个责任2.举例： (OCP)TheOpen-ClosedPrinciple OCP–开放-封闭原则1.对扩展性的开放：这意味着模块的行为可以被扩展。当应用程序的需求发生变化时，或者满足新应用程序的需求时，我们可以使模块以新的不同的方式运行。2.对修改的封闭：但模块自身的代码是不应被修改的，扩展模块行为的一般途径是修改模块的内部实现，如果一个模块不能被修改，那么它通常被认为是具有固定的行为。3.实现方式：第一种：如果有多种类型的Server，那么针对每一种新出现的Server，不得不修改Server类的内部具体实现。不推荐使用第二种：通过构造一个抽象的Server类：AbstractServer，该抽象类中包含针对所有类型的Server都通用的代码，从而实现了对修改的封闭；当出现新的Server类型时，只需从该抽象类中派生出具体的子类ConcreteServer即可，从而支持了对扩展的开放。4.举例：左边：如果要修改m_type的值，则要修改内部代码实现，破坏对修改的封闭。右边：如果要修改m_type的值，只需要增加额外的类进行实现就可以，其他无关的类都不做改动，满足OCP原则 (LSP)TheLiskovSubstitutionPrinciple LSP–Liskov替换原则子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异 (ISP)TheInterfaceSegregationPrinciple ISP–接口隔离原则1.“胖”接口具有很多缺点：不够聚合胖接口可分解为多个小的接口，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的端口。2.举例：这是一个不好的实现方式，RobotWorker不需要实现eat()方法，但由于接口中包含两个方法，所以都要实现，不满足ISP原则。修改方式如下：将上述两个接口分离，实现类时只实现需要功能的接口即可。 (DIP)TheDependencyInversionPrinciple DIP–依赖转置原则1.抽象的模块不应依赖于具体的模块，具体应依赖于抽象举个例子：下面的实现是通过接口而不是具体类实现的2.实现方法：不推荐的方法：上层client的代码中直接嵌入了对下层具体实现机制的调用满足DIP的方法：上层client的代码面向抽象接口编程，隔离对下层具体实现机制的直接接触再举个例子：delegation要通过接口实现，而不是具体子类 
第48篇文章[]
软件构造笔记（五） Java面向对象编程 静态变量、静态方法1.静态变量2.静态方法 接口和类1.接口2.使用静态工厂方法可以避免客户知道具体子类名称使用default关键字 静态变量、静态方法 1.静态变量 静态变量是属于类的，而不是属于类创建的对象 publicstaticintnum; publicstaticStrings; 2.静态方法 静态方法只能访问类的静态变量或调用类的静态方法。静态方法通常作为工具方法使用，当其被其它类使用时，不需要创建类的实例 classDifference{ publicstaticvoidmain(String[]args){ display(); Differencet=newDifference(); t.show(); } //静态方法 staticvoiddisplay(){ System.out.println("Amazing!"); } //普通方法 voicshow(){ System.out.println("Awesome!"); } 接口和类 1.接口 1.接口之间可以继承和扩展2.一个类可以实现多个接口3.一个接口可以有多种实现类 2.使用静态工厂方法可以避免客户知道具体子类名称 举例来说 publicclassFastMyStringimplementsMyString{   } 客户端具体实现时 MyStrings=newFastMyString(true);//知道具体实现类的名字 为了避免这种情况发生 publicinterfaceMyString{ //在接口里定义子类返回 publicstaticMyStringvalueOf(booleanb){ returnnewFastMyString(true); } } MyStrings=MyString.valueOf(true); 使用default关键字 在接口统一实现某些功能，无需在各个类中重复使用它 publicinterfaceExample{ defaultintmethod1(inta){ } staticintmethod2(intb){ } publicintmethod3(); } publicclassCimplementsExample{ @Override publicintmethod3(){ } publicstaticvoidmain(String[]args){ Example.method2(2); Cc=newC(); c.method1(1); c.method3(); } } 
第49篇文章[]
软件构造笔记（一） 笔记一 Java基本知识一.String、StringBuilder、StringBuffer类二.Map类基本用法 多维度视图和质量目标总结一.描述软件系统的三个维度二.AST三.质量属性 Java基本知识 一.String、StringBuilder、StringBuffer类 运行速度：StringBuilder>StringBuffer>String 原因：String是字符串常量，StringBuilder和StringBuffer是字符串变量，String对象一旦创建之后该对象是不可更改的，但后两者是可以更改的 publicclassWelcome{ publicstaticvoidmain(String[]args){ Stringstr="abc"; System.out.println(str); str=str+"de"; System.out.println(str); } } 在本例中，首先在第8行创建一个String对象str赋值为"abc"，在第10行，JVM又创建了一个新的对象名为str，把原来的str值和"de"加起来赋值给新的str，原来的str就会被JVM垃圾回收机制给回收掉了。所以Java中String对象进行的操作实际上是一个不断创建新的对象并将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，若以速度比String快很多 二.Map类基本用法 Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。Map中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过建可以找对所对应的值。Collection中的集合称为单列集合，Map中的集合称为双列集合。 Map集合遍历键值对方式 利用迭代器进行遍历 publicclassWelcome{ publicstaticvoidmain(String[]args){ //创建map对象 Map<String,String>map=newHashMap<>(); //向map对象中添加元素 map.put("age","18"); map.put("name","Mary"); map.put("hobby","piano"); //获取map中键元素 Set<String>keySet=map.keySet(); //利用迭代器遍历元素 Iterator<String>it=keySet.iterator(); while(it.hasNext()){ //得到每一个key Stringkey=it.next(); //得到每一个key对应的value Stringvalue=map.get(key); System.out.println(key+"="+value); } } } 利用foreach进行遍历 publicclassWelcome{ publicstaticvoidmain(String[]args){ //创建map对象 Map<String,String>map=newHashMap<>(); //向map对象中添加元素 map.put("age","18"); map.put("name","Mary"); map.put("hobby","piano"); //获取map中键元素 Set<String>keySet=map.keySet(); //利用foreach进行遍历 for(Stringkey:keySet){ Stringvalue=map.get(key); System.out.println(key+"="+value); } } } 多维度视图和质量目标总结 一.描述软件系统的三个维度 Byphases:build-andrun-timeviewsBydynamics:momentandperiodviewsBylevel:codeandcomponentviews 二.AST 1.Javasource：首先，提供一些源代码进行解析。此源代码可以在项目中以Java文件的式提供，也可以直接以char[]包含Java源代码的形式提供。2.Parse：解析在1处描述的源代码。该步骤所需的全部由类提供org.eclipse.jdt.core.dom.ASTParser。3.该抽象语法树是步骤2的结果。它是一个树模型，完全代表在步骤1中提供的源。如果需要，解析器还会计算并包括称为“绑定”的其他符号解析信息。4.ManipulatingtheAST：如果需要更改第3点的AST，可以通过两种方式完成：(1)通过直接修改AST。(2)通过在单独的协议中记录修改。5.Writingchangesback：如果进行了更改，则需要将其应用于1提供的源代码。6.IDocument：是步骤1的源代码的包装，在第5步需要 三.质量属性 1.Externalqualityfactors(1)Correctness:按照预先定义的“规约”执行，是最重要的质量指标(2)Robustness:针对异常情况的处理，出现规约定义之外的清醒的时候，软件要做出恰当的反应(3)Extendibility:对软件的规约进行修改是否足够容易(4)Reusability:是软件可用于构建许多不同应用程序的能力，一次开发，多次使用(5)Compatibility:不同的软件系统之间相互可容易的集成(6)Efficiency:软件的性能效率(7)Protability:软件可方便的在不同的技术环境之间移植(8)Easeofuse:容易学、安装、操作、监控(9)Functionality:系统提供可能性的范围(10)Timeliness:指软件系统在用户使用时或使用之前是否能及时发布另外，还有很多其他的外部质量属性 2.Internalqualityfactors*(1)Readability(2)Understandability(3)Clearness(4)Size 3.Fivekeyqualityobjectivesofsoftwareconstruction(1)Easytounderstand:elegantandbeautifulcode/understandability(2)Readyforchange:maintainabilityandadaptability(3)Cheapfordevelop:designfor/withreuse:reusability(4)Safefrombugs:robustness–Efficienttorun:performance 参考文献 https://www.cnblogs.com/weibanggang/p/9455926.htmlhttps://blog.csdn.net/qq_29373285/article/details/81487594https://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/index.html#bib-example-project 
第50篇文章[]
软件构造笔记（十三）---PPT第九讲 面向复用的软件构造技术 LSP原则-Liskov替换原则协变Co-variance通配符逆变Contra-variance 比较Comparator<T>Comparable<T> Delegation委派CRP委派的四种形式 白盒框架黑盒框架 LSP原则-Liskov替换原则 一.基本内容（子类型多态）1.子类型可以增加方法，但不可删2.子类型需要实现抽象类型中的所有未实现方法3.子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance的参数4.子类型中重写的方法必须使用同样类型的参数或者符合contra-variance的参数5.子类型中重写的方法不能抛出额外的异常6.子类方法具有更强的不变量7.子类方法具有更弱的前置条件8.子类方法具有更强的后置条件 二.实例1.具有更强的不变量2.更弱的前置条件和更强的后置条件3.不符合条件的方法，调用GraphicProgram中的scaleW方法可能会导致h不等于w，破坏表示不变性4.不兼容的spec：三.满足条件1.前置条件不能强化2.后置条件不能弱化3.不变量要保持4.子类型方法参数：逆变5.子类型方法的返回值：协变6.异常类型：协变 协变Co-variance 父类型->子类型：越来越具体specific返回值类型：不变或变得更具体异常的类型：不变或变得更具体对于子类，更特定的类可能有更特定的返回类型为子类型的方法声明的每个异常都应该是为超类型的方法声明的某些异常的子类型。数组是协变的给定Java的子类型规则，T类型的数组[]可以包含T类型的元素或T的任何子类型。泛型不是协变的Box<Integer>不是Box<Number>的子类型，即使Integer是Number的子类型。给定两个具体类型A和B(例如，Number和Integer)，无论A和B是否相关，MyClass<A>与MyClass<B>没有关系。MyClass<A>和MyClass<B>的共同父类是Object。 通配符 一.使用通配符(?)指定无限制通配符类型，例如List<?>二.如下情况通常使用通配符：1.编写一个可以使用Object类中提供的功能实现的方法。2.当代码在泛型类中使用不依赖于类型参数的方法时。例如,List.size或List.clear。实际上，Class<?>之所以如此常用，是因为Class中的大多数方法不依赖于T。三.上下界1.低有界通配符<?superA>List<Interger>只匹配Integer类型的列表List<?superInteger>匹配Integer的超类型的任何类型的列表，如Integer、Number和Object。2.上有界通配符<?extendsA>总结来说 逆变Contra-variance 父类型->子类型：越来越具体specific参数类型：要相反的变化，要不变或越来越抽象 比较 Comparator<T> 若ADT需要比较大小，可实现Comparator接口并overridecompare()函数举例来说 //首先实现一个Edge类 publicclassEdge{ doubleweight; publicEdge(doublew){ weight=w; } publicdoublegetWeight(){ returnweight; } publicStringtoString(){ return"权重为"+weight; } } publicstaticvoidmain(String[]args){ List<Edge>list=newLinkedList<>(); list.add(newEdge(5.0)); list.add(newEdge(4.5)); list.add(newEdge(3.9)); list.add(newEdge(8.7)); //使用Comparator接口进行比较 Collections.sort(list,newComparator<Edge>(){ @Override publicintcompare(Edgeo1,Edgeo2){ if(o1.getWeight()>o2.getWeight())return1; elsereturn-1; } }); System.out.println(list); } 输出结果 Comparable<T> 另一种方法：让ADT实现Comparable接口，然后overridecompareTo()方法与Comparator的区别：不需要构建新的Comparator类，比较代码放在ADT内部。举例来说 //实现Comparable接口，重写compareTo方法 publicclassEdgeimplementsComparable<Edge>{ doubleweight; publicEdge(doublew){ weight=w; } publicdoublegetWeight(){ returnweight; } publicStringtoString(){ return"权重为"+weight; } @Override publicintcompareTo(Edgeo){ if(this.getWeight()>o.getWeight())return1; elsereturn-1; } } publicstaticvoidmain(String[]args){ Edge[]edge=newEdge[]{ newEdge(5.0), newEdge(4.5), newEdge(3.9), newEdge(8.7) }; Arrays.sort(edge);//使用Arrays.sort()方法进行排序 System.out.println(Arrays.toString(edge)); } Delegation委派 委派/委托：一个对象请求另一个对象的功能与继承的区别继承:通过新操作或重写操作来扩展基类。委派:捕获一个操作并将其发送给另一个对象。如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现。一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。 尽量用delegation代替inheritance CRP 类应该通过它们的组合(通过包含实现所需功能的其他类的实例)来实现多态行为和代码重用，而不是从基类或父类继承。组合一个对象可以做什么(has_a或use_a)比扩展它是什么(is_a)要好。“委托”发生在object层面，而“继承”发生在class层面举例：使用CRP原则实现使用接口实现公共的方法但不同的实现通过接口的组合定义行为的组合，从组合接口中派生具体类，在类中进行委派，可以通过委派实现对象实例和方法的调用 委派的四种形式 1.Dependency:临时性的delegation使用类的最简单形式是调用它的方法;两个类之间的这种形式的关系称为“use-a”关系，在这种关系中，一个类利用另一个类，而没有实际将它作为属性合并。例如，它可以是一个参数，也可以在方法中本地使用。依赖关系:一个对象的实现需要其他对象(供应商)的临时关系。2.Association:永久性的delegation关联:对象类之间的持久关系，允许一个对象实例导致另一个对象实例代表它执行一个操作。has_a:一个类有另一个类作为属性/实例变量-这种关系是结构性的，因为它指定了一种对象连接到另一种对象，而不代表行为。3.Composition:更强的association，但难以变化组合是一种将简单对象或数据类型组合成更复杂的对象或数据类型的方法。is_part_of:一个类有另一个类作为属性/实例变量。4.Aggregation:更弱的association，可动态变化聚合:对象存在于另一个对象之外，在另一个对象之外创建，因此它被作为参数传递给构造函数。总结 白盒框架 通过subclassing和overriding方法扩展1.允许每个非私有方法的扩展2.需要理解超类的实现3.一次只有一个扩展4.一起编译5.通常是所谓的开发框架 黑盒框架 通过委派和接口组合实现方法1.允许在接口中公开功能的扩展2.只需要了解接口3.多个插件4.经常提供更多的模块化5.独立的部署6.通常是所谓的终端用户框架，平台 总结 
第51篇文章[1]
HIThello的一生---2021大作业 程序人生-Hello’sP2P 摘要第1章：概述1.1HELLO简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在UBUNTU下预处理的命令2.3HELLO的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2在UBUNTU下编译的命令3.3HELLO的编译结果解析3.3.1数据3.3.2赋值3.3.3关系操作3.3.4算术操作3.3.5函数操作 3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在UBUNTU下汇编的命令4.3可重定位目标ELF格式4.4HELLO.O的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在UBUNTU下链接的命令5.3可执行目标文件HELLO的格式5.4HELLO的虚拟地址空间5.5链接的重定位过程分析5.6HELLO的执行流程5.7HELLO的动态链接分析5.8本章小结 第6章HELLO进程管理6.1进程的概念与作用6.2简述壳SHELL-BASH的作用与处理流程6.3HELLO的FORK进程创建过程6.4HELLO的EXECVE过程6.5HELLO的进程执行6.6HELLO的异常与信号处理6.7本章小结 第7章HELLO的存储管理7.1HELLO的存储器地址空间7.2INTEL逻辑地址到线性地址的变换-段式管理7.3HELLO的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.5三级CACHE支持下的物理内存访问7.6HELLO进程FORK时的内存映射7.7HELLO进程EXECVE时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章HELLO的IO管理8.1LINUX的IO设备管理方法8.2简述UNIXIO接口及其函数8.3PRINTF的实现分析8.4GETCHAR的实现分析8.5本章小结 结论附件参考文献 摘要 本文以hello.c程序为源程序，首先对该程序进行预处理，得到hello.i，之后对得到的文件进行编译，得到汇编文件hello.s，再之后对得到的文件进行汇编，得到可重定位目标文件hello.o，最终通过与其他文件链接，得到一个可执行文件hello。在得到这些文件之后，分别对其内容进行了分析。 得到可执行文件之后，在linux系统下进行进程管理分析，包括进程的执行过程与信号的异常处理。另外，通过了解虚拟内存的概念，也在本文中描述了程序是如何在内存中存储的，比如通过线性地址到物理地址的变换，比如通过cache高速缓存机制。存储时也会发生缺页故障，本文也描述了缺页中断处理操作与动态存储分配。 IO管理也是必不可少的。本文在最后一章中描述了Linux的IO设备管理方法，包括文件的不同类型以及unixio接口的操作，还描述了io接口的不同函数、printf函数的实现以及getchar函数的实现。关键词：链接；操作系统;IO管理；汇编语言；shell；程序的生命周期；进程； 第1章：概述 1.1HELLO简介 1.P2P(FromProgramtoProcess) 首先创建一个hello.c文件(Program)，依次对该文件进行预处理(hello.i)、编译(hello.s)、汇编(hello.o)、链接(hello)，形成一个可执行文件（二进制文件）。得到可执行文件之后，OS（进程管理）通过shell新建一个进程，还可以通过fork函数创建一个子进程，分配相应的内存资源，使用execve函数加载进程，完成P2P过程。2.020(FromZero-0toZero-0) 计算机存储结构层层递进，下一级作为上一级的缓存，并通过cache加快传输数据的速度。对hello的数据进行处理时，将数据从磁盘加载到CPU寄存器。处理hello时，通过TLB、分级页表等机制，将程序映射到虚拟内存，在开始运行时载入物理内存，多样的信号处理机制能应对程序产生异常的情况。操作系统将IO设备都抽象成了文件，实现程序能够间接调用硬件完成输入输出。hello执行完成后shell回收hello进程，并且内核会从系统中删除hello的所有痕迹，实现020过程。 1.2环境与工具 一.硬件环境： X64CPU;2.60GHz;8.00GBRAM;476.81GBDisk二.软件环境： Windows1064位操作系统;Vmware15.0.4;Ubuntu18.01三.开发工具： Codeblocks17.12;vim/gcc/g++；objdump；gdb；edb；hexedit 1.3中间结果 1.hello.i：hello.c预处理之后的文本文件2.hello.s：hello.i编译之后得到的汇编文件（文本文件）3.hello.o：hello.s汇编之后得到的可重定位目标文件（二进制文件）4.hello1：用于测试sleepsecs的可执行目标文件5.helloo.elf：可重定位目标文件的elf文件6.hello：hello.c的可执行目标文件7.hello.elf：可执行目标文件的elf文件8.helloosection.txt：可重定位目标文件的重定位信息（链接的重定位过程分析）9.hellosection.txt：可执行目标文件的重定位信息（链接的重定位过程分析） 1.4本章小结 本章是对这个大作业的一个概述，首先描述了对这个大作业的理解，即hello简介，然后描述了完成作业需要的环境要求，在完成大作业后，将所输出的中间结果的文件完整列出。 第2章预处理 2.1预处理的概念与作用 1.概念：在编译之前的命令，在C/C++中处理源文件中以”#”开头的预编译命令。2.作用：（1）删除”#define”并展开所定义的宏（2）处理所有条件预编译指令，如”#if”,“#ifdef”,“#endif”等（3）插入头文件到”#include”处，可以递归方式进行处理（4）删除所有的注释”//”和”/**/”（5）添加行号和文件名标识，以便编译时编译器产生调试用的行号信息（6）保留所有”pragma”编译指令经过预编译处理后，得到的是预处理文件（如hello.i），文件还是一个可读的文本文件，但不包含任何宏定义 2.2在UBUNTU下预处理的命令 1.利用gcc-m64-no-pie-fno-PIC-Ehello.c>hello.i生成预处理文件hello.i 2.生成hello.i文件 部分文件内容： 2.3HELLO的预处理结果解析 hello.c头文件如下： hello.i文件较长，共3105行，存储了头文件中的所有内容比如下面截取了部分库在计算机中的存储位置 还有对一些数据结构和函数的声明： 2.4本章小结 本章了解了预处理的概念及作用，能够运用gcc-E的指令生成xxx.o预处理文件，并能直观了解预处理文件的内容，为下一步编译做好准备 第3章编译 3.1编译的概念与作用 1.概念：编译是利用编译程序从源语言编写的源程序产生目标程序的过程，一般通过编译程序来实现。将某一种程序设计语言写的程序翻译成等价的另一种语言的程序的程序，称之为编译程序。2.作用：编译程序把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。(1)词法分析 词法分析的任务是对由字符组成的单词进行处理，从左至右逐个字符地对源程序进行扫描，产生一个个的单词符号，把作为字符串的源程序改造成为单词符号串的中间程序。执行词法分析的程序称为词法分析程序或扫描器。(2)语法分析 编译程序的语法分析器以单词符号作为输入，分析单词符号串是否形成符合语法规则的语法单位，如表达式、赋值、循环等，最后看是否构成一个符合要求的程序，按该语言使用的语法规则分析检查每条语句是否有正确的逻辑结构，程序是最终的一个语法单位。编译程序的语法规则可用上下文无关文法来刻画。(3)中间代码 中间代码是源程序的一种内部表示，或称中间语言。中间代码的作用是可使编译程序的结构在逻辑上更为简单明确，特别是可使目标代码的优化比较容易实现中间代码，即为中间语言程序。(4)代码优化 代码优化是指对程序进行多种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。所谓等价，是指不改变程序的运行结果。所谓有效，主要指目标代码运行时间较短，以及占用的存储空间较小。这种变换称为优化。(5)目标代码 目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。 3.2在UBUNTU下编译的命令 1.用gcc-m64-no-pie-fno-PIC-Shello.i>hello.s 2.生成hello.s文件 3.文件部分内容： 3.3HELLO的编译结果解析 3.3.1数据 1.全局变量：intsleepsecs=2.5 已初始化的全局变量sleepsecs，在.text节中声明为全局变量，在.data节，设置对齐方式是4个字节，类型是“object”，大小占4个字节。输出sleepsecs发现值为2，在文件中存在隐式的类型转换 2.局部变量：inti；局部变量分配在栈中，本题位于-4(%rbp)，先将i赋值为零，之后每次循环与9作比较 3.main函数参数：intmain(intargc,char*argv[]) argc占4个字节，所以是movl，argv[]是指针，占8个字节，所以是movq，并且下一步是将argc与3进行比较4.数组：argv[] argv[]作为main函数的第二个参数传进去，被分配在-32(%rbp)位置处，argv指针指向一段连续的、已经被分配好的内存空间 对printf语句的调用如下，连续两次调用argv数组，并用%rax保存两次调用的值 5.字符串：第一个字符串输出，汇编代码如下： 可以看出，汉字在Linux下使用UTF-8编码格式，每个汉字占3个字节 第二个字符串输出，声明在main函数中 3.3.2赋值 1.全局变量 已初始化的全局变量sleepsecs位于.data节，未初始化的全局变量位于.bss节，且不占任何实际磁盘空间2.局部变量：for(i=0;i<10;i++) 通过mov指令进行赋值操作，根据不同数据类型增添不同后缀 3.3.3关系操作 1.不等于：if(argc!=3) 2.小于：for(i=0;i<10;i++) 关系操作通过cmp指令实现，得到的结果一般与跳转指令相结合，跳转到相应的位置 3.3.4算术操作 自增操作：i++通过add指令可以实现加1操作 3.3.5函数操作 （1）函数传递：intmain(intargc,char*argv[])，argc存储在%edi，argv[]存储在%rsi，局部变量存放在栈中，所以刚开始将%rsp-32，分配32个字节 （2）函数调用：通过call指令调用函数，puts()、exit()、printf()、sleep()、main()、getchar()，将PC设置为要跳转的地址，将当前地址的下一行地址作为返回地址压入栈中 （3）函数返回通过leave和ret指令结束函数，实现return0：释放分配的栈空间，并弹出调用函数%rbp值作为PC地址，进行跳转，结束调用函数 3.4本章小结 本章了解了编译的概念和作用，在Ubuntu下实现编译操作，并得到编译文件hello.s，分析hello.s文件了解C语言数据与操作是如何在汇编语言中实现的，比如不同类型的数据、赋值、类型转换、算术操作、关系操作、函数操作、数组、控制转移是如何在汇编语言中实现的。 第4章汇编 4.1汇编的概念与作用 1.概念： 汇编语言，即第二代计算机语言，用一些容易理解和记忆的字母，单词来代替一个特定的指令，比如：用“ADD”代表数字逻辑上的加减，“MOV”代表数据传递等等。汇编代码文件（由汇编指令构成）称为汇编语言源程序。汇编程序用来将汇编语言源程序转换为机器指令序列。汇编指令和机器指令一一对应，前者是后者的符号表示。2.作用： 比起机器语言，汇编语言具有更高的机器相关性，更加便于记忆和书写，但又同时保留了机器语言高速度和高效率的特点。汇编语言仍是面向机器的语言，很难从其代码上理解程序设计意图，设计出来的程序不易被移植，故不像其他大多数的高级计算机语言一样被广泛应用。所以在高级语言高度发展的今天，它通常被用在底层，通常是程序优化或硬件操作的场合。 4.2在UBUNTU下汇编的命令 通过gcc-m64-no-pie-fno-PIC-chello.s>hello.o 生成hello.o文件 4.3可重定位目标ELF格式 通过readelf-ahello.o>helloo.elf生成包含ELF头文件和节头表的文件helloo.elf ELF头信息格式 （1）Magic：ELF文件的魔数，加载或读取文件时，可用魔数确认文件类型是否正确（2）Class：ELF版本（3）Data：2进制补码，小端法（4）Type：REL可重定位目标文件（5）没有程序头表，且虚拟内存从0开始存储（6）节头表大小为64*13 2.节头表（1）Address：可重定位目标文件中，每个可装入节的起始地址总是0（2）Offset：相对于起始位置的偏移，对于.bss节无意义（3）Align：节的对齐要求（4）Flags：节标志，该节在虚拟空间中的访问属性3…rela.text节重定位节该节中存储了重定位的相关信息 4.4HELLO.O的结果解析 利用objdump-d-rhello.o分析反汇编代码得到反汇编 分析：1.两种基本的重定位类型R_X86_64_32绝对地址R_X86_64_PC32PC相对地址2.分支转移： 不再使用段名称如.L2，而是具体地址，重定位前的序号代表从第几个字节开始被重定位，比如下图是从第16个字节开始重定位 下图是hello.s的文件信息，能够看出左边没有数字序列，hello.o冒号左边数字代表运行时机器指令的位置，冒号右边的数字序列代表每一行汇编语句代表的机器指令 3.函数调用call指令 在hello.s文件中call指令后直接接函数名称，因为编译成汇编语言时，是不确定函数的调用位置的；而在hello.o文件中，call后面接的是下一条指令的地址，因为在hello.c中调用的函数都是共享库的函数，需要通过链接才能确定最终地址。 4.5本章小结 本章中了解了汇编的概念与作用，在Ubuntu中通过gcc指令生成汇编文件，另外生成了可重定位elf文件，了解elf头文件信息、节头表、重定位表各个表项代表的含义，分析了hello.o与hello.s文件的不同，找出汇编语言与机器语言的映射关系，因为是一一对应的，但还是在某些地方有所不同，这些都进行了一定的了解。 第5章链接 5.1链接的概念与作用 1.概念：在构建大型程序的时候,为了方便代码管理,会根据不同的功能把代码分为多个片段(或模块)并存储在不同的文件中,在代码执行时需要把这些代码模块合并成一个单一的可执行文件,这个合并过程叫链接2.作用：将多个可重定位目标文件合并生成可执行目标文件 5.2在UBUNTU下链接的命令 输入命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o得到hello文件 5.3可执行目标文件HELLO的格式 生成hello.elf文件：通过readelf-ahello>hello.elf指令，生成hello.elf文件分析文件内容1.ELF头信息表 信息与可重定位目标文件的ELF头信息表基本相同，有几处不同（1）Type：EXEC代表可执行文件（2）头文件入口地址不为零（3）有程序头表 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。2.节头表： 基本信息与可重定位目标文件中的节头表基本相同 5.4HELLO的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，能够从DataDump中看出hello的起始地址为0x00400000，结束地址为0x00400ff0 分析程序头表： （1）代码段第一个LOAD是只读代码段第二个LOAD是读写代码段（2）PHDR程序头表 5.5链接的重定位过程分析 利用objdump-d-rhello命令生成两个文件，便于比较 分析hello与hello.o的不同（1）hello以init节开始 （2）hello中多了不同函数的汇编代码 （3）hello地址为真实储存地址hello.o中main初始地址显示为0，因为是虚拟内存首地址（4）函数跳转指令hello中是call+首地址调用该函数 hello.o是call+main偏移量 （5）重定位信息hello.o文件15、1a、24所在行后面的零都是需要重定位的信息，在没有重定位之前，后面都初始化为0 重定位之后，hello文件中能够看出bf后面四个字节、e8后面四个字节都是重定位后的信息，通过公式转移目标地址=PC+偏移地址进行计算 5.6HELLO的执行流程 程序名称载入：_dl_start_dl_init开始执行：_start_libc_start_main_init执行main：_main_printf_exit_sleep_getchar_dl_runtime_resolve_xsave_dl_fixup_dl_lookup_symbol_x退出：exit 5.7HELLO的动态链接分析 在edb调试之后我们发现原先0x00600a10开始的global_offset表是全0的状态，在执行过_dl_init之后被赋上了相应的偏移量的值。这说明dl_init操作是给程序赋上当前执行的内存地址偏移量，这是初始化hello程序的一步。 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 5.8本章小结 本章介绍了链接的概念和作用，在Ubuntu下生成链接文件，通过gcc命令生成ELF可执行目标文件，了解了ELF头信息、节头表、程序头表等各项代表的含义，了解虚拟空间的大小，分析了重定位前后文件的变化，函数的执行过程与链接过程 第6章HELLO进程管理 6.1进程的概念与作用 1.概念：进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。2.作用：在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 6.2简述壳SHELL-BASH的作用与处理流程 1.Shell：一般我们是用图形界面和命令去控制计算机，真正能够控制计算机硬件（CPU、内存、显示器等）的只有操作系统内核（Kernel），由于安全、复杂、繁琐等原因，用户不能直接接触内核，需要另外再开发一个程序，让用户直接使用这个程序；该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核，内核和用户之间就多了一层“中间代理”，Shell其实就是一种脚本语言，也是一个可以用来连接内核和用户的软件，我们编写完源码后不用编译，直接运行源码即可。2.常用的Shell：bash由GNU组织开发，sh是UNIX上的标准shell，是第一个流行的Shell，bash保持了对shshell的兼容性，是各种Linux发行版默认配置的shell。现在sh已经基本被bash代替，bash是sh的扩展补充，但是也有些是不兼容的，大多数情况下区别不大，特殊场景可以使用bash代替sh。3.处理流程：（1）读取用户的输入（2）分析输入内容，获得输入参数（3）如果是内核命令则直接执行，否则调用相应的程序执行命令（4）在程序运行期间，shell需要监视键盘的输入内容，并且做出相应的反应 6.3HELLO的FORK进程创建过程 当在shell中输入一条命令时，shell会判断是否是内核命令，如果是内核命令则直接执行，否则shell进程会以自己为模板（即父进程），创建（fork）一个新的进程。这个新建的进程对shell中输入的命令进行处理，即调用exec()这一系统调用来执行shell中输入的命令，处理完之后新进程结束自己的生命，等待shell进程进行回收。 新创建的父进程和子进程内容相同，虚拟地址相同，但是是完全独立的，并且拥有不同的PID。 6.4HELLO的EXECVE过程 （1）通过pid=fork()函数创建一个新进程后，判断pid的值，若pid=0，则该进程为新创建的子进程（2）子进程通过系统调用execve()函数将新程序加载到子进程的内存空间中，execve()函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量envp（3）只有当出现错误时，例如找不到filename，execve才会返回到调用程序；一般情况下，execve调用一次并从不返回，加载filename后，调用启动代码，启动代码设置栈，并将控制传递给新程序的主函数，主函数有如下原型：intmain(intargc,char**argv,char**envp);（4）当main开始执行时，用户栈的组织结构如下： 举例来说： 在shell(shell也是一个进程)中执行最简单的HelloWorld程序。它也是首先调用execve()这个系统调用的，下面用strace跟踪下执行HelloWorld的过程，我们可以看到第一步执行的是execve()。 6.5HELLO的进程执行 1.基本概念：（1）并发：多个流并发地执行的一般现象（2）多任务（时间分片）：一个进程和其它进程轮流运行的概念（3）上下文：内核为每个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态（4）调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程2.如下程序进行上下文切换，其中sleepsecs=2.5 sleep函数的作用是将一个进程挂起一段指定的时间，如果请求的时间量已经到了，sleep返回零。 6.6HELLO的异常与信号处理 1.ctrl+Z： 输入ctrl+Z后，会发送一个SIGTSTP信号到前台进程组中的每个进程，默认情况下，是停止（挂起）前台作业。在图中能看到还有hello进程未结束。 2.fg命令： fg命令是让挂起的程序继续运行，下图能看出在输出6次字符串后输入ctrl+z让程序挂起，输入fg后继续运行输出十次结束 3.ctrl+C 输入ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程，默认情况下，是终止前台作业。下图通过ps能看到hello进程已经结束。 4.jobs jobs命令可以用来查看当前终端放入后台的工作，工作管理的名字也来源于jobs命令。下图通过jobs能看到被挂起的程序。 5.pstree：进程树，把各个进程通过树型连接起来 6.kill命令： 通过ps查看进程号为2778的进程未终止，kill-s向固定进程发送信号，比如下图24信号SIGXCPU，代表CPU时间限制超出，fg继续运行输出错误信息。 6.7本章小结 在本节中，了解了进程的概念和作用，能运用fork创建进程，execve执行进程，了解了不同信号的作用，并能在linux下使用，能通过运用不同的命令了解前台作业和后台作业的基本信息。 第7章HELLO的存储管理 7.1HELLO的存储器地址空间 1.物理地址：用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚按发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示，也可以简单的理解为实际上内存上的地址。2.虚拟地址/线性地址：虚拟地址：虚拟地址并不真实存在于计算机中。每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间。理论上，虚拟空间受物理内存大小的限制，如给有4GB内存，那么虚拟地址空间的地址范围就应该是0x00000000~0xFFFFFFFF。每个进程都有自己独立的虚拟地址空间。这样每个进程都能访问自己的地址空间，这样做到了有效的隔离。3.逻辑地址：包含在机器语言指令中用来指定一个操作数或一条指令的地址，这种寻址方式在80x86著名的分段结构中表现得尤为具体，它促使windows程序员把程序分成若干段。每个逻辑地址都由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。例如我们常说的结构体中某个参数的地址其实就相当于：结构体首地址+偏移量。逻辑地址是相对于应用程序而言的。 7.2INTEL逻辑地址到线性地址的变换-段式管理 逻辑地址是程序源码编译后所形成的跟实际内存没有直接联系的地址，即在不同的机器上，使用相同的编译器来编译同一个源程序，则其逻辑地址是相同的，但是相同的逻辑地址，在不同的机器上运行，其生成的线性地址又不相同，因为把逻辑地址转换成线性地址的公式是：线性地址=段基址*16+偏移的逻辑地址，而段基址由于不同的机器其任务不同，其所分配的段基址（线性地址）也会不相同，因此，其线性地址会不同。 即使，对于转换后线性地址相同的逻辑地址，也因为在不同的任务中，而不同的任务有不同的页目录表和页表把线性地址转换成物理地址，因此，也不会有相同的物理地址冲突。 注意的是，源码编译后生成的地址，只是偏移的地址，而形成逻辑地址的[段基址:偏移地址]中的段基址，是在生成任务时才定下来的，也就是说，[段基址:偏移地址]只有在进程中才会用到，在程序中只有偏移地址的概念。 7.3HELLO的线性地址到物理地址的变换-页式管理 1.基本概念（1）线性地址：是进程使用的地址，虚拟的地址。人为抽象出一大片地址空间给进程使用，为了方便32位地址总线存取，linux内核定义为了4G。（2）物理地址：是采用32位总线存取物理内存某个字节时，地址总线上电位的高低。分页单元将线性地址转换成物理地址。2.两种变换：CPU通过地址来访问内存中的单元，地址有虚拟地址和物理地址之分，如果CPU没有MMU，或者有MMU但没有启用，CPU核在取指令或访问内存时发出的地址将直接传到CPU芯片的外部地址引脚上，直接被内存芯片接收，这称为物理地址. 如果CPU启用了MMU，CPU核发出的地址将被MMU截获，从CPU到MMU的地址称为虚拟地址，而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将虚拟地址映射成物理地址，如下图所示。，利用TLB加速地址翻译，TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。 3.具体过程：将虚拟地址分为VPN(虚拟页号)和VPO(虚拟页偏移)，TLB是利用VPN的位进行虚拟寻址的，VPN分为TLBI(组索引)和TLBT(标记)。将物理地址分为PPN(物理页面)和PPO(物理页偏移)，然后再进行划分，分为CO(块偏移)、CI(组索引)、CT(标记)。VPO与PPO相对应，VPN对应页表中的某一项，通过PTE查找到对应的PPN，将PPN和PPO连在一起即为物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 一般来讲，能通过VPN中TLB找到PPN是最好的，但也可能出现缺页的情况，在TLB中无法找到对应的PPN，则要访问内存，在页表中寻找PPN。 将虚拟地址划分为4个VPN和1个VPO，每个VPNi都是到第i级页表的索引，为了构造物理地址，在能够确定PPN之前，MMU必须访问4个PTE，和只有一级到页表结构一样，PPO和VPO是相同的。 7.5三级CACHE支持下的物理内存访问 将物理地址分为三部分，分为CO(块偏移)、CI(组索引)、CT(标记)，根据CI找到组索引，找到标记相同的位置，最后通过块偏移找到对应位置。若未找到，则到二级或三级cache下寻找。 7.6HELLO进程FORK时的内存映射 1.基本概念：（1）mm_struct（内存描述符）：描述了一个进程的整个虚拟内存空间（2）vm_area_struct（区域结构描述符）：描述了进程的虚拟内存空间的一个区间2.映射过程：（1）当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID（2）创建当前进程的mm_struct,vm_area_struct和页表的原样副本（3）将两个进程的每个页面都标记为只读页面（4）两个进程的每个vm_area_struct都标记为私有，这样就只能在写入时复制。 7.7HELLO进程EXECVE时的内存映射 1.加载并运行程序步骤：（1）删除已存在的用户区域（2）映射私有区域：为新程序的代码、数据、bss和栈区域创建新的区域结构。（3）映射共享区域（4）设置程序计数器PC2.加载器映射用户地址空间区域： 7.8缺页故障与缺页中断处理 1.缺页故障：（1）段错误：首先，先判断这个缺页的虚拟地址是否合法，那么遍历所有的合法区域结构，如果这个虚拟地址对所有的区域结构都无法匹配，那么就返回一个段错误（segmentfault）（2）非法访问：接着查看这个地址的权限，判断一下进程是否有读写改这个地址的权限。（3）如果不是上面两种情况那就是正常缺页，那就选择一个页面牺牲然后换入新的页面并更新到页表。 2.缺页处理： 处理器将虚拟地址发送给MMU2-3)MMU使用内存中的页表生成PTE地址有效位为零,因此MMU触发缺页异常缺页处理程序确定物理内存中牺牲页(若页面被修改，则换出到磁盘)缺页处理程序调入新的页面，并更新内存中的PTE缺页处理程序返回到原来进程，再次执行缺页的指令 7.9动态存储分配管理 1.程序员使用动态内存分配器（比如malloc）获得虚拟内存，动态内存分配器维护着一个进程的虚拟内存区域，称为堆 2.分配器（1）概念：分配器将堆视为一组不同大小的块(blocks)的集合来维护，每个块要么是已分配的，要么是空闲的。（2）分配器的类型a.显式分配器:要求应用显式地释放任何已分配的快例如，C语言中的malloc和freeb.隐式分配器:应用检测到已分配块不再被程序所使用，就释放这个块比如Java，ML和Lisp等高级语言中的垃圾收集(garbagecollection)3.malloc程序包#include<stdlib.h>（1）void*malloc(size_tsize)1）成功:返回已分配块的指针，块大小至少size字节，对齐方式依赖编译模式：8字节（32位模式），16字节（64位模式）Ifsize==0,returnsNULL2）出错:返回NULL(0)，同时设置errno（2）voidfree(void*p)将p指向的块返回到可用内存池，p必须malloc、realloc或calloc已分配块的起始地址（3）Otherfunctionscalloc:malloc的另一版本，将已分配块初始化为0.realloc:改变之前分配块的大小.sbrk:分配器隐含地扩展或收缩堆4.记录空闲块方法：（1）隐式空闲链表：通过头部中的大小字段 隐含地连接所有块 （2）显式空闲链表：在空闲块中使用指针 （3）分离空闲链表：按照大小分类，构成不同大小的空闲链表（4）块按大小排序：在每个空闲块中使用一个带指针的平衡树，并使用长度作为权值 7.10本章小结 通过本章的学习，了解了虚拟地址、物理地址、线性地址、逻辑地址的概念，也了解了地址之间的转化关系，比如从虚拟地址转换到物理地址是需要通过地址翻译机制实现的。学习内存映射，掌握fork函数、execve函数的内存映射。还学习了缺页的种类与处理步骤，以及处理空闲块的方法。 第8章HELLO的IO管理 8.1LINUX的IO设备管理方法 1.设备的模型化：文件文件类型：（1）普通文件：包含任意数据，应用程序通常包含文本文件和二进制文件。（2）目录：包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录（3）套接字：用来与另一个进程进行跨网络通信的文件（4）命名通道（5）符号链接（6）字符和块设备2.设备管理：unixio接口（1）打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个IO设备。Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）、标准错误（描述符为2）（2）改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量。（3）读写文件：读操作是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。写操作是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。（4）关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件，作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。 8.2简述UNIXIO接口及其函数 一.打开和关闭文件1.open()函数：打开一个已存在的文件或者创建一个新文件 将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符。若出错，则返回-1。flags参数指明了进程打算如何访问这个文件。mode参数制定了新文件的访问权限位。 2.close()函数：关闭一个已打开的文件，若关闭一个已关闭的描述符会出错，返回-1. 二.读和写文件1.read()函数：若成功则为读的字节数，若EOF则为0，若出错为-1read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。 2.write()函数：若成功则为写的字节数，若出错则为-1write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 三.改变当前文件位置调用lseek函数改变当前文件位置 8.3PRINTF的实现分析 一.printf函数体内容： 二.分析函数体：1.形参列表中的“…”：可变参数的写法，当传递参数的个数不确定时，就用这种方式表示。2.va_listarg=(va_list)((char*)(&fmt)+4);（1）va_list：是一个字符指针（2）((char*)(&fmt)+4)：表示的是…中的第一个参数fmt是一个指针，指向第一个const参数(constcharfmt)的第一个元素，它是在栈上进行分配的，有地址。char类型的变量，入栈的是指针而不是该变量，所以得到的也是一个固定的值所以将得到的值转换成va_list类型可以得到第一个参数的地址。3.i=vsprintf(buf,fmt,arg);（1）vsprintf函数原型： （2）函数功能：接受确定输出格式的格式字符串fmt，用格式字符串对个数变化的参数进行格式化，产生格式化输出。4.write(buf,i);函数作用：将buf中的i个元素的值写到终端三.printf的运行过程： 从vsprintf生成显示信息，显示信息传送到write系统函数，write函数陷阱-系统调用int0x80或syscall.字符显示驱动子程序，从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4GETCHAR的实现分析 1.getchar()函数原型： 2.函数分析：n=read(0,buf,BUFSIZ);getchar调用read函数，将整个缓冲区都读到了buf里面，返回值是缓冲区的长度。函数实现时，只有当buf长度为零，getchar才会调用read函数，否则是直接将保存的buf中的最前面的元素返回。3.异步异常-键盘中断的处理： 键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章描述了Linux的IO设备管理方法，包括文件的不同类型以及unixio接口的作用，还描述了unixio接口及不同函数的作用。另外，分析了printf和getchar函数的具体实现过程。 结论 终于深刻地了解hello程序了！ 回顾hello的一生，从hello.c开始出发，进行预处理，处理了文件的“头”，进行编译，将文件用生动形象的汇编语言进行翻译，进行汇编，将文件翻译成枯燥无味的机器代码，进行链接，将不同文件“紧紧”链接在一起，得到一个可执行文件。但是一生才刚刚开始，它还没有发挥它的作用。我们运行它，为它创建“儿子”（子进程），对它轮番轰炸，进行各种花式操作，比如发送kill或pause信号，比如用字符串充满缓冲区，比如按ctrl+c或ctrl+z。最终它的进程被清除，它也完成了它的使命。我们为了充分了解它，还要分析它的内存空间和IO文件管理。多亏了它，我们才能有这样一份独一无二的大作业，复习课内的知识，以及掌握很多额外的知识。 回顾这一门课程，是真的感叹csapp这本大黑书写的很好，并且通过完成hello的一生大作业，我能再次回顾课程的知识点，进行查缺补漏。另外，也掌握了一些调试器的使用方法，比如gdb、edb等，这些都是分析程序必不可少的工具。 附件 1.hello.i：hello.c预处理之后的文本文件2.hello.s：hello.i编译之后得到的汇编文件（文本文件）3.hello.o：hello.s汇编之后得到的可重定位目标文件（二进制文件）4.hello1：用于测试sleepsecs的可执行目标文件5.helloo.elf：可重定位目标文件的elf文件6.hello：hello.c的可执行目标文件7.hello.elf：可执行目标文件的elf文件8.helloosection.txt：可重定位目标文件的重定位信息（链接的重定位过程分析）9.hellosection.txt：可执行目标文件的重定位信息（链接的重定位过程分析） 参考文献 [1]https://www.cnblogs.com/pianist/p/3315801.html[2]http://c.biancheng.net/view/3210.html[3]https://blog.csdn.net/liugaigai427/article/details/86742062 
第52篇文章[3]
力扣--动态规划专题I 题目列表 1.300-最长递增子序列2.剑指offer42.连续子数组的最大和3.70--爬楼梯4.413--等差数列划分5.64--最小路径和6.542--01矩阵7.221-最大正方形8.1277-统计全为1的正方形子矩阵 1.300-最长递增子序列 （1）题目条件：（2）题解： 动态规划 构建一个与nums数组长度相等的dp数组，dp[i]为以第i个元素结尾的最长子序列的长度，并设置初值均为1。遍历数组nums，当遍历到元素nums[i]时，dp[0…i-1]都被算出，所以dp[i]的状态转移方程为dp[i]=max(dp[i],dp[j]+1),0<=j<i,且nums[i]>nums[j]解释状态方程：遍历到nums[i]时，重新遍历nums[0…i-1]找到比nums[i]小的元素，因为只有比它小，才有可能增加子序列的长度。比nums[i]小的元素可能有很多，分别计算dp[j]+1，找到最大的dp[j]+1即[0…i-1]中比nums[i]小的元素的最长子序列长度。得到完整的dp数组之后，找到其中的最大值，就是最长子序列长度 classSolution{ public: intlengthOfLIS(vector<int>&nums){ intn=nums.size(); vector<int>dp(n,1); for(inti=1;i<n;i++){ for(intj=0;j<i;j++){ if(nums[i]>nums[j]){ dp[i]=max(dp[i],dp[j]+1); } } } intm=dp[0]; for(inti=1;i<n;i++){ if(m<dp[i]){ m=dp[i]; } } returnm; } }; 贪心+二分搜索 上一个算法的时间复杂度是O(n2)，复杂度较高。换一种思考方式，要让子序列尽可能地长，就要让子序列增加的尽可能地慢，也就是说让子序列的元素增加的尽可能地小，这是“贪心”思想。构造数组d[i]，代表长度为i的最长子序列末尾元素的最小值，d[1]=nums[0]。d[i]数组是当单调递增的，证明:若d[3]=5,d[5]=3,长度为5的最长子序列的末尾元素是3，而长度为3的最长子序列长度为5，这肯定是不对的，因为能在长度为5的最长子序列中找到长度为3的最长子序列的末尾元素，并且该元素要小于3，所以d[i]数组是单调递增的。算法步骤：a.设len表示最长子序列长度，len初值为1，遍历整个数组nums[i]b.若nums[i]>d[len],则len长度加1，将nums[i]加入到d数组中.c.否则，找到d[i-1]<nums[j]<d[i]，更新d[i]=nums[j]，由于d数组是单调递增的，可以用二分查找搜索。 classSolution{ public: intlengthOfLIS(vector<int>&nums){ intn=nums.size(),len=1; vector<int>d(n+1,0); d[len]=nums[0]; for(inti=1;i<n;i++){ if(nums[i]>d[len]){ len++; d[len]=nums[i]; } else{ intlow=1,high=len,pos=0; while(low<=high){ intmid=(high+low)>>1; if(nums[i]>d[mid]){ pos=mid; low=mid+1; } else{ high=mid-1; } } d[pos+1]=nums[i]; } } returnlen; } }; 2.剑指offer42.连续子数组的最大和 （1）题目条件： （2）题解： 动态规划构建一个数组dp[i]，代表以第i个元素结尾的连续子数组的最大和。若dp[i-1]>0，dp[i]=dp[i-1]+nums[i]。若dp[i-1]<=0,dp[i]=nums[i]，因为一个数加上一个负数一定会比这个数本身小，若是前一个数是负数，则可以遗弃它，直接从当前元素开始找。用res记录最大值可以避免之后在遍历一遍dp数组。 classSolution{ public: intmaxSubArray(vector<int>&nums){ intn=nums.size(); intres=nums[0]; vector<int>dp(n,0); dp[0]=nums[0]; for(inti=1;i<n;i++){ dp[i]=dp[i-1]>0?dp[i-1]+nums[i]:nums[i]; res=max(res,dp[i]); } returnres; } }; 3.70–爬楼梯 （1）题目条件：‘ （2）题解： 动态规划（简化）题目条件是每次只能爬1个或2个台阶，所以要求爬到第n阶台阶的方法数时，该方法数等于爬到n-1阶台阶的方法数+爬到n-2阶台阶的方法数之和，状态转移方程是dp[n]=dp[n-1]+dp[n-2]，由于只与前两个状态有关，所以没必要建立数组。 classSolution{ public: intclimbStairs(intn){ if(n==0||n==1)return1; intx=1,y=1,sum; for(inti=2;i<=n;i++){ sum=x+y; x=y; y=sum; } returnsum; } }; 4.413–等差数列划分 （1）题目条件： （2）题解： 动态规划dp[i]是以第i个元素结尾的等差数列的个数，由于求的是所有子数组的个数和，最后要把dp数组的元素个数相加。等差数列的划分满足nums[i]-nums[i-1]=nums[i-1]-nums[i-2] classSolution{ public: intnumberOfArithmeticSlices(vector<int>&nums){ intn=nums.size(); if(n<3)return0; vector<int>dp(n,0); for(inti=2;i<n;i++){ if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){ dp[i]=dp[i-1]+1; } } returnaccumulate(dp.begin(),dp.end(),0); } }; 5.64–最小路径和 （1）题目条件： （2）题解： 动态规划（二维）由题目条件可知，元素只能向右或者向下走，dp[i][j]代表以第i行第j列为结尾的元素的最小路径和，状态转移方程：dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j] classSolution{ public: intminPathSum(vector<vector<int>>&grid){ intm=grid.size(),n=grid[0].size(); vector<vector<int>>dp(m,vector<int>(n,0)); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(i==0&&j==0){ dp[i][j]=grid[0][0]; } elseif(i==0){ dp[i][j]=dp[i][j-1]+grid[i][j]; } elseif(j==0){ dp[i][j]=dp[i-1][j]+grid[i][j]; } else{ dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j]; } } } returndp[m-1][n-1]; } }; 动态规划压缩矩阵 由于dp数组遍历时只与左边和上边的值有关，我们可以将二维数组压缩成一维数组dp[j]代表遍历到第i行时，以第j列的元素结尾的最小路径和。对于第i行，在遍历到第j列时，由于第j-1列已经遍历完，所以dp[j-1]代表dp[i][j-1]，而dp[j]还没有被更新，所以dp[j]代表dp[i-1][j] classSolution{ public: intminPathSum(vector<vector<int>>&grid){ intm=grid.size(),n=grid[0].size(); vector<int>dp(n,0); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(i==0&&j==0){ dp[j]=grid[i][j]; } elseif(i==0){ dp[j]=dp[j-1]+grid[i][j]; } elseif(j==0){ dp[j]=dp[j]+grid[i][j]; } else{ dp[j]=min(dp[j],dp[j-1])+grid[i][j]; } } } returndp[n-1]; } }; 6.542–01矩阵 （1）题目条件： （2）题解： 广度优先搜索bfs更为常见，这里只介绍动态规划方法 动态规划对于矩阵中的1，要找到与它距离最近的0，共有四种走法：水平向左+竖直向上水平向左+竖直向下水平向右+竖直向上水平向右+竖直向下可以四种情况都考虑，但是会有重复，所以为了减少重复次数，只选择左上和右下就可以，说明原因：左上，从第一个元素开始遍历，对于每个元素都找到了左边和上边的最小值右下，从最后一个元素开始遍历，对于每个元素都找到了右边和下边的最小值 classSolution{ public: vector<vector<int>>updateMatrix(vector<vector<int>>&matrix){ intm=matrix.size(),n=matrix[0].size(); //初始dp的值为无穷大 vector<vector<int>>dp(m,vector<int>(n,INT_MAX/2)); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(matrix[i][j]==0){ dp[i][j]=0; } } } //向左和向上，注意遍历顺序 for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(i-1>=0) dp[i][j]=min(dp[i][j],dp[i-1][j]+1); if(j-1>=0) dp[i][j]=min(dp[i][j],dp[i][j-1]+1); } } //向右和向下，注意遍历顺序 for(inti=m-1;i>=0;i--){ for(intj=n-1;j>=0;j--){ if(i+1<m) dp[i][j]=min(dp[i][j],dp[i+1][j]+1); if(j+1<n) dp[i][j]=min(dp[i][j],dp[i][j+1]+1); } } returndp; } }; 7.221-最大正方形 （1）题目条件： （2）题解： 动态规划数组dp(i,j)表示以(i,j)为右下角，且只包含1的正方形的边长最大值.若matrix(i,j)=‘0’，dp(i,j)=0若matrix(i,j)=‘1’，考虑边界条件，若i=0或者j=0，则dp(i,j)只能为1，若不是在边界，则满足状态转移方程dp(i,j)=min(dp(i-1,j),dp(i,j-1),dp(i-1,j-1))+1 classSolution{ public: intmaximalSquare(vector<vector<char>>&matrix){ intm=matrix.size(),n=matrix[0].size(); intmaxside=0; vector<vector<int>>dp(m,vector<int>(n,0)); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(matrix[i][j]=='1'){ if(i==0||j==0)dp[i][j]=1; else{ dp[i][j]=min(min(dp[i-1][j],dp[i-1][j-1]),dp[i][j-1])+1; } } maxside=max(maxside,dp[i][j]); } } returnmaxside*maxside; } }; 8.1277-统计全为1的正方形子矩阵 （1）题目条件：（2）题解： 动态规划这道题与221最大正方形十分类似，对dp(i,j)可以有不同的定义，定义为以(i,j)元素结尾的全1矩阵的个数，计算过程中用sum进行相加得到最终个数。 classSolution{ public: intcountSquares(vector<vector<int>>&matrix){ intm=matrix.size(),n=matrix[0].size(); intsum=0; vector<vector<int>>dp(m,vector<int>(n,0)); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(matrix[i][j]==1){ if(i==0||j==0)dp[i][j]=1; else{ dp[i][j]=min(min(dp[i-1][j],dp[i-1][j-1]),dp[i][j-1])+1; } } sum+=dp[i][j]; } } returnsum; } }; 
第53篇文章[]
软件构造笔记（十六）---PPT第十二讲 面向正确性与健壮性的软件构造 两个特性健壮性正确性 错误与异常ErrorExceptioncheckedExceptiontry-catch-finallyuncheckedException自定义异常类 Assertions 两个特性 健壮性 1.健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度。2.面向健壮性的编程（1）处理未期望的行为和错误终止（2）即使终止执行，也要准确/无歧义的向用户展示全面的错误信息（3）错误信息有助于进行debug尽可能保持软件运行而不是总是退出两者的比较 正确性 正确性：程序按照spec加以执行的能力，是最重要的质量指标！永不给用户错误的结果 两者的对比： 错误与异常 Error 1.Error类描述了Java运行时系统内部很少发生的内部系统错误和资源耗尽情况(例如，VirtualMachineError,LinkageError)。不应该抛出这种类型的对象，如果发生这样的内部错误，除了通知用户并试图优雅地终止程序外，你能做的很少。内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结束2.种类（1）Userinputerrors用户输入错误（2）Deviceerrors设备错误（3）Physicallimitations物理限制 Exception 一.Exception类描述了由你的程序引起的错误(例如FileNotFoundException,IOException)。这些错误可以被你的程序捕获和处理(例如，执行一个替代操作或做一个优雅的退出关闭所有的文件，网络和数据库连接)。异常：你自己程序导致的问题，可以捕获、可以处理二.分类：1.运行时异常：由程序员在代码里处理不当造成2.其他异常：由外部原因造成 checkedException 1.处理方法：（1）你必须捕获和处理异常,或者告诉编译器不能处理它宣称你的方法抛出的异常,代码。（2）然后使用你的方法将不得不处理,异常(可以选择声明抛出的异常,如果它不能处理)。（3）编译器将检查我们是否完成了以下两件事中的一件(catch或declare)。2.编译过程：必须捕获并指定错误处理器handler，否则编译无法通过，类似于编程语言中的statictypechecking 从Exception中派生出子类型编译器可帮助检查你的程序是否已抛出或处理了可能的异常3.解决办法：（1）Declaringexceptions(throws)声明“本方法可能会发生XX异常”（2）Throwinganexception(throw)抛出XX异常（3）Catchinganexception(try,catch,finally)捕获并处理XX异常4.通过throws在函数头后和spec中均声明异常的种类父子函数–参见LSP原则（1）如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛（2）子类型方法可以抛出更具体的异常，也可以不抛出任何异常（3）如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。错误示例：5.通过throw（1）找到一个能表达错误的Exception类/或者构造一个新的Exception类（2）构造Exception类的实例，将错误信息写入，抛出它一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码6.通过try/catch异常发生后，如果找不到处理器，就终止执行程序，在控制台打印出stacktrace，所以可以通过try/catch捕获并处理异常举例来看：7.通过finally（1）当异常抛出时，方法中正常执行的代码被终止，如果异常发生前曾申请过某些资源，那么异常发生后这些资源要被恰当的清理，可以使用finally进行处理 （2）可以不使用catch子句而使用finally子句。不管代码是否抛出异常，finally都会被执行 try-catch-finally 分情况讨论：1.该代码不抛出任何异常。程序首先执行try块中的所有代码。然后执行finally子句中的代码。然后，执行finally子句后的第一个语句。换句话说，执行通过点1、2、5和6。2.代码抛出一个异常，该异常在catch子句中被捕获。程序执行try块中的所有代码，直到抛出异常为止。try块中的其余代码将被跳过。然后，程序执行匹配的catch子句中的代码，然后执行finally子句中的代码。如果catch子句没有抛出异常，则程序执行finally子句后的第一行。执行通过点1、3、4、5和6。如果catch子句抛出一个异常，那么该异常将被抛回调用者，执行只通过点1、3和5。3.该代码抛出一个未在任何catch子句中捕获的异常。在这里，程序执行try块中的所有代码，直到抛出异常。跳过try块中的剩余代码。然后，执行finally子句中的代码，并将异常抛回给该方法的调用者。执行只通过点1和点5。 uncheckedException ErrorsandRuntimeExceptions1.处理方法：（1）错误表示发生在应用程序之外的情况，例如系统崩溃。运行时异常通常是由于应用程序逻辑中的错误而发生的。（2）在这些情况下你什么都做不了，只能重写你的程序代码。所以编译器不会检查这些。（3）这些运行时异常将在开发和测试期间发现。然后我们必须重构我们的代码来删除这些错误。2.编译过程：可以不处理，编译没问题，但执行时出现就导致程序失败，代表程序中的潜在bug类似于编程语言中的dynamictypechecking 从RuntimeException派生出子类型3.举例：在编程和编译的时候，IDE与编译器均不会给出任何错误提示两者比较1.使用情况：（1）如果客户端可以通过其他的方法恢复异常，那么采用checkedexception；（2）如果客户端对出现的这种异常无能为力，那么采用uncheckedexception；（3）异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。2.对比表格 自定义异常类 为了定义checkedException，你要创建java.lang.Exception的一个子类(或子类的层次结构):可能抛出或传播此异常的方法必须声明它:举个例子： Assertions 一.定义：在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误。当断言为真时，意味着一切都按预期运行。当断言为假时，意味着它在代码中检测到一个意外错误。 
第54篇文章[]
软件构造博客2.凸包问题的思考 在进行软件构造Lab1的时候，相信大家都会遇到求解凸包问题，而很多人在第一次接触的时候难免会产生疑惑，笔者就这个问题谈一下自己的思考和解决方法： 首先让我们明确一个问题：什么是凸包问题。 凸包（ConvexHull）是一个计算几何（图形学）中的概念。在一个实数向量空间V中，对于给定集合P，所有包含P的凸集的交集S被称为P的凸包。P的凸包可以用P内所有点(p1， Pn)的凸组合来构造。在二维欧几里得空间中，凸包可想象为一个正多边形，它的边界和内部包含着所有顶点。 按照笔者的理解通俗来说，就是把所有顶点看作一堆木棒，现在你需要去找到一根绳子画一个范围，将所有的木棍包括在里面。很显然，就跟我们平时拿绳子捆木棍一样，绳子最先接触到的肯定是最外面的木棍，而凸包就是这些以这些最外面的木棍作为顶点构成的凸多边形。所以我们接下来的问题就是分析如何去找到这些最外面的“木棍”以及相应的时间复杂度。 求解凸包问题主要有三种方法，本文主要讲解前两种方法： 方法一.暴力破解 没错，说到解决问题第一个思考的肯定是暴力求解。具体思想十分简单：对于一个n个点集合中的两个点p1和p2，当且仅当该集合中的其它点都位于穿过这两点的直线的同一边时，它们的连线就是该集合凸包边界的一部分，简言之，p1和p2就是凸包问题中最小凸多边形的顶点。对每一对点都做一遍检验之后，满足条件的线段就构成了该凸包的边界。 在编写代码过程中，我们只需要建立一个直角坐标系，然后求出p1和p2的直线方程，然后将其他点代入方程计算结果是否全部大于等于0或者小于等于0，如果是则是凸包边界上的点，否则就不是。 而本方法的时间复杂度比较容易分析，为O(n^3)。实现代码如下： publicclassConvexHull{ //返回点集合中凸多边形的点集合 publicstaticPoint[]getConvexPoint(Point[]A){ Point[]result=newPoint[A.length]; intlen=0;//用于计算最终返回结果中是凸包中点的个数 for(inti=0;i<A.length;i++){ for(intj=0;j<A.length;j++){ if(j==i)//除去选中作为确定直线的第一个点 continue; int[]judge=newint[A.length];//存放点到直线距离所使用判断公式的结果 for(intk=0;k<A.length;k++){ inta=A[j].getY()-A[i].getY(); intb=A[i].getX()-A[j].getX(); intc=(A[i].getX())*(A[j].getY())-(A[i].getY())*(A[j].getX()); judge[k]=a*(A[k].getX())+b*(A[k].getY())-c;//根据公式计算具体判断结果 } if(JudgeArray(judge)){//如果点均在直线的一边,则相应的A[i]是凸包中的点 result[len++]=A[i]; break; } } } Point[]result1=newPoint[len]; for(intm=0;m<len;m++) result1[m]=result[m]; returnresult1; } //判断数组中元素是否全部大于等于0或者小于等于0，如果是则返回true，否则返回false publicstaticbooleanJudgeArray(int[]Array){ booleanjudge=false; intlen1=0,len2=0; for(inti=0;i<Array.length;i++){ if(Array[i]>=0) len1++; } for(intj=0;j<Array.length;j++){ if(Array[j]<=0) len2++; } if(len1==Array.length||len2==Array.length) judge=true; returnjudge; } 方法二.Gift-wrapping算法 本算法的基本思想为：遍历全部的点，找到最左侧的点，则这个点一定是凸包上的一个点，以这个点为凸包上的第一个点，初始角度为0°(相对于y轴正向的顺时针偏移)。接下来寻找凸包上的下一个点：遍历全部的点，找到从当前点的当前角度转向该点所需旋转最小角度的点。最后以寻找到的下一个点为当前点，当前角度更新为原角度加上旋转角度的和，然后继续去寻找下一个点，直到找到的下一个点为第一个时结束。 而本算法因为每次的起点都是上次找到的凸包点，因此外层循环的复杂度为O(W)，W为凸包上的点，内层循环每次都会全部遍历点，因此时间复杂度为O(n),因此总的是间复杂度为O(nW),在一般情况下凸包上的点的期望为logn，算法复杂度为O(nlogn),极端情况下，如下所示，所有点都在类似圆弧上的话，外层循环也是n，因此时间复杂度会达到O(n^2)。 算法实现： publicstaticSet<Point>convexHull(Set<Point>points){ if(points.size()<=2){ returnpoints; } HashSet<Point>result=newHashSet<Point>(); Pointtmp=points.iterator().next(); Pointstart=tmp; Pointtarg=tmp; doubleangle=0,a1=0,at=0; for(Pointp:points){ if(p.x()<start.x()||p.x()==start.x()&&p.y()>start.y()) start=p; } result.add(start); Pointptr=start; while(true){ at=TurtleSoup.newCalculateBearingToPoint(angle,ptr.x(),ptr.y(),targ.x(),targ.y()); for(Pointq:points){ if(targ==q) continue; a1=TurtleSoup.newCalculateBearingToPoint(angle,ptr.x(),ptr.y(),q.x(),q.y()); if(a1<at){//选择偏转角度最小的 targ=q; at=a1; }elseif(a1==at){//选择距离更大的 doubledist=TurtleSoup.calculateDistance(ptr.x(),ptr.y(),targ.x(),targ.y()); doubledis1=TurtleSoup.calculateDistance(ptr.x(),ptr.y(),q.x(),q.y()); if(dis1>dist){ targ=q; at=a1; } } } if(targ==start)//终止条件 break; else{ angle=at; result.add(targ); ptr=targ; } } returnresult; } 方法三.Graham-Scan法 本算法的思想是先找到凸包上的一个点，然后从那个点开始按逆时针方向逐个找凸包上的点，实际上就是进行极角排序，然后对其查询使用。时间复杂度为O（nlogn）。 具体实现方法略，读者可自行查阅相关文章。同时我们可以证明凸包问题的解法的时间复杂度不会低于O（nlogn），具体证明也请读者自行进行。 
第55篇文章[]
软件构造博客3.代码测试思考 相信很多同学都发现，每次的软件构造实验都要求我们进行测试代码的编写，而且课程中也很重视测试对于编程的作用，那么测试为什么这么重要呢，我们又该根据什么原则编写测试代码呢，本文就此问题给出笔者的一些看法。 测试为什么那么重要 在软件开发的过程中，我们提倡测试驱动开发(TDD)的方法，原因正是基于测试的重要性： 1.测试是提高软件质量的重要手段 2.测试可以确认开发的程序是否达到用户需求 3.测试可以具体关注系统的某一特定方面的质量特性 4.先进行测试可以节省大量的调试时间 注：测试并不能保证程序100%没有错误！ 我们该如何进行测试 按照老师PPT上的介绍，良好的测试应该有如下特点： 1.能发现错误 2.不冗余 3.体现最佳特性 4.别太复杂也别太简单 而测试也是分层级的，从低到高依次为： 单元测试:是指对软件中的最小可测试单元进行检查和验证，Java里单元指一个类或一个方法 集成测试：也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行测试 系统测试：是对整个系统的测试，将硬件、软件、操作人员看作一个整体，检验它是否有不符合系统说明书的地方 验收测试：是部署软件之前的最后一个测试操作。在软件产品完成了单元测试、集成测试和系统测试之后，产品发布之前所进行的软件测试活动。 此外还有回归测试，它指的是修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。 测试方法有白盒测试和黑盒测试： 白盒测试：对程序内部代码结构的测试，要考虑内部实现细节 黑盒测试：对程序外部表现出来的行为的测试，黑盒测试完全从函数spec导出测试用例，不考虑函数内部实现 而我们实验中主要采用的方法是根据等价类的划分来编写测试样例： 基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例针对每个输入数据需要满足的约束条件划分等价类每个等价类代表着对输入约束加以满足/违反的有效/无效数据的集合。而相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为测试用例即可 可以按照下面的准则划分： 输入数据限定了数值范围 输入数据指明了特定的值 输入数据确定了一组数 输入数据是Y/N 笛卡尔积做到全覆盖和对于每个维度的取值则至少覆盖一次即可，测试完备，但用例数量多，前者测试代价高但是并非所有组合情况都可能，后者测试用例少，代价低，但测试覆盖度未必高，通常情况下在这两个方案之间选取一个折衷的方案。 以Lab2中ConcreteVerticesGraph的部分测试代码为例，读者自行体会这种以等价类划分为基础的测试样例编写： //Testingstrategy //按照加入的点划分：点已经存在，点不存在 //按照加入的权值划分：权值为0，权值大于0，权值小于0 @Test publicvoidtestAddsource(){ Vertex<String>vertex=newVertex<String>("a"); assertEquals(0,vertex.addSource("b",5)); assertEquals(0,vertex.addSource("c",3)); assertEquals(5,vertex.addSource("b",4)); assertEquals(4,vertex.addSource("b",0)); assertEquals(-1,vertex.addSource("b",-1)); } //Testingstrategy //按照加入的点划分：点已经存在，点不存在 //按照加入的权值划分：权值为0，权值大于0，权值小于0 @Test publicvoidtestAddtarget(){ Vertex<String>vertex=newVertex<String>("a"); assertEquals(0,vertex.addTarget("b",5)); assertEquals(0,vertex.addTarget("c",3)); assertEquals(5,vertex.addTarget("b",4)); assertEquals(4,vertex.addTarget("b",0)); assertEquals(-1,vertex.addTarget("b",-1)); } //Testingstrategy //按照移除的点划分：点已经存在，点不存在 @Test publicvoidtestRemovesource(){ Vertex<String>vertex=newVertex<String>("a"); vertex.addSource("b",5); vertex.addSource("c",3); assertEquals(0,vertex.removeSource("d")); assertEquals(5,vertex.removeSource("b")); } //Testingstrategy //按照移除的点划分：点已经存在，点不存在 @Test publicvoidtestRemovetarget(){ Vertex<String>vertex=newVertex<String>("a"); vertex.addTarget("b",5); vertex.addTarget("c",3); assertEquals(0,vertex.removeTarget("d")); assertEquals(5,vertex.removeTarget("b")); } 
第56篇文章[]
软件构造博客4.Git多分支操作 在Lab3中，我们遇到了利用Git新建仓库和进行不同仓库的提交的操作，下文就这个问题给出较为详细的操作方法： 首先还是Github仓库和本地仓库的设立，这部分过程在我的博客1当中有介绍，有这部分需求的同学可以移步博客1，下面就让我们来看看怎么进行分支操作： 右击我们的本地仓库，选择GitBashhere，可以看到现在的默认分支为master，这时候我们想要新建一个分支change并且提交文件到Github的change分支上，则相关操作有： gitbranchchange(如果你想新建的分支是别的名字的话，这里就修改成你想要的分支名) 然后我们输入gitbranch，就发现现在有两个分支存在，而当前是位于master分支上，之后我们进行分支切换操作： 通过gitcheckoutchange进行分支切换，为了验证我们再次输入gitbranch，可以看到现在指向的分支为change，证明我们切换分支成功，具体操作截图如下： 之后的相关提交操作在我的博客1中有介绍，这里就不再介绍了，有需要的同学可以查看我的软件构造博客1。 
第57篇文章[1]
哈工大计算机系统大作业 程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机类 学 号 1190200106 班 级 1936601 学 生 何炫霖 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文介绍了hello的整个生命过程。在Linux系统下利用gcc，gdb，edb等工具分析了hello程序从hello.c经过预处理、编译、汇编、链接生成可执行文件的全过程，即P2P的过程，还分析了hello在运行过程中涉及的进程管理、内存管理、IO管理到最后hello被回收的020的过程。通过本文的分析，可以让我们对计算机系统有更深的理解。 关键词：Linux；hello程序；计算机系统 目 录 第1章概述 -3- 1.1Hello简介 -3- 1.2环境与工具 -3- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -6- 2.4本章小结 -7- 第3章编译 -8- 3.1编译的概念与作用 -8- 3.2在Ubuntu下编译的命令 -8- 3.3Hello的编译结果解析 -8- 3.4本章小结 -12- 第4章汇编 -13- 4.1汇编的概念与作用 -13- 4.2在Ubuntu下汇编的命令 -13- 4.3可重定位目标elf格式 -13- 4.4Hello.o的结果解析 -16- 4.5本章小结 -19- 第5章链接 -20- 5.1链接的概念与作用 -20- 5.2在Ubuntu下链接的命令 -20- 5.3可执行目标文件hello的格式 -20- 5.4hello的虚拟地址空间 -25- 5.5链接的重定位过程分析 -25- 5.6hello的执行流程 -28- 5.7Hello的动态链接分析 -28- 5.8本章小结 -29- 第6章hello进程管理 -30- 6.1进程的概念与作用 -30- 6.2简述壳Shell-bash的作用与处理流程 -30- 6.3Hello的fork进程创建过程 -30- 6.4Hello的execve过程 -31- 6.5Hello的进程执行 -31- 6.6hello的异常与信号处理 -32- 6.7本章小结 -35- 第7章hello的存储管理 -36- 7.1hello的存储器地址空间 -36- 7.2Intel逻辑地址到线性地址的变换-段式管理 -36- 7.3Hello的线性地址到物理地址的变换-页式管理 -37- 7.4TLB与四级页表支持下的VA到PA的变换 -38- 7.5三级Cache支持下的物理内存访问 -39- 7.6hello进程fork时的内存映射 -40- 7.7hello进程execve时的内存映射 -41- 7.8缺页故障与缺页中断处理 -41- 7.9动态存储分配管理 -42- 7.10本章小结 -44- 第8章hello的IO管理 -45- 8.1Linux的IO设备管理方法 -45- 8.2简述UnixIO接口及其函数 -45- 8.3printf的实现分析 -46- 8.4getchar的实现分析 -48- 8.5本章小结 -48- 结论 -48- 附件 -50- 参考文献 -51- 第1章概述 1.1Hello简介 程序的生命周期是指从程序源文件，依次经过预处理器cpp的预处理、编译器cc1的编译、汇编器as的汇编、链接器ld的链接最终成为可执行目标程序并在操作系统上加载、执行、回收的全过程。程序的生命周期可以分为P2P和020两个部分，P2P指程序由源文件到进程的过程；020指程序被加载到内存执行，直到被回收的过程。 P2P： GCC编译器驱动程序读取源程序文件并把它翻译成一个可执行目标文件。在预处理阶段，预处理器cpp读取需要的系统头文件内容，并把它直接插入程序文本中，得到hello.i。在编译阶段，编译器ccl间文本文件hello.i翻译成hello.s，这是一个汇编语言的程序。在汇编阶段，汇编器as将hello.s翻译成机器语言指令，并将结果保存在目标文件hello.o中，它以可重定位目标程序的格式存储。在链接阶段，链接器ld需要将一些库函数合并到hello.o的程序中，最终得到hello的可执行文件。用户在Ubuntushell键入./hello启动此程序，shell调用fork函数为其产生子进程，hello便成为了进程。完整过程图示如下： 020： 操作系统的进程管理调用fork函数产生子进程并调用execve函数，进行虚拟内存映射（mmp），并为运行的hello分配时间片来执行取指译码流水线等操作。操作系统的储存管理以及MMU解决VA到PA的转换，cache、TLB、页表等的功能为加速访问过程，IO管理与信号处理综合软硬件对信号等进行处理。程序结束时，shell回收hello进程，内核将其所有痕迹从系统中清除。 1.2环境与工具 硬件环境：IntelCorei5-9300HCPU；2.40GHz；8GBRAM 软件环境：Windows1064位；Ubuntu20.04.2LTS64位 开发与调试工具：gcc；edb；gdb；readelf；objdump 1.3中间结果 文件名文件作用hello.i预处理器修改了的源程序,分析预处理器行为hello.s编译器生成的编译程序,分析编译器行为hello.o可重定位目标程序,分析汇编器行为hello可执行目标程序,分析链接器行为helf.txthello.o的elf格式,分析汇编器和链接器行为h1elf.txt可执行hello的elf格式,作用是重定位过程分析 1.4本章小结 本章主要是本文实验的准备工作和绪论部分，主要介绍了hello程序P2P、020的过程，给出了实验中生成的中间文件，列出了实验使用的软硬件环境以及调试工具等。 第2章预处理 2.1预处理的概念与作用 预处理指令是以‘#’开头的代码行。‘#’必须是该行除了空白字符外的第一个字符。‘#’后面是指令关键字，整行语句构成一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。下图是ANSI标准定义的C语言预处理指令及其作用： 2.2在Ubuntu下预处理的命令 命令：cpphello.c>hello.i 2.3Hello的预处理结果解析 查看hello.i文件，可以发现原来的代码已经被拓展为3000多行，而main函数以及定义全局变量的代码没有任何改变，只是原来前面的#include语句被替换成了大量的头文件中的内容，包括外部函数的声明、结构体等数据结构的定义、数据类型的定义等内容。并且源程序开头的注释也被删除了。同时会对#define进行相应的符号替换。所以我们分析可以知道生成的是经过预处理扩展之后的源程序。 2.4本章小结 本章主要介绍了预处理的概念以及作用，预处理环节是接下来编译、汇编、链接等环节的基础，并通过hello.c经过预处理生成的hello.i文件导致两者内容的不同进行了分析。 第3章编译 3.1编译的概念与作用 概念： 编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序，该程序包含函数main的定义，这个过程称为编译。 作用： 编译的作用就是将高级语言源程序翻译成等价的目标程序，并且进行语法检查、调试措施、修改手段、覆盖处理、目标程序优化等步骤。 3.2在Ubuntu下编译的命令 命令：gcc–Shello.i-ohello.s 3.3Hello的编译结果解析 3.3.1数据 全局变量：sleepsecs 在hello.s中可以看到，.global将sleepsecs标记为全局变量。.data表明全局变量sleepsecs存放在数据段.data中，.align要求4字节对齐，.size表明变量为4字节，最后.long给出了变量的初值为2。 局部变量：i，用于循环计数： 在hello.s的汇编代码中，i被存储在%rbp-4的内存地址处。其中movl为i赋初值0，addl在每次循环时对i增加1，cmpl比较i和9的大小来决定什么时候结束循环。局部变量i是存放在栈上，通过相对栈顶（%rsp）的偏移量来访问。 字符串常量：Usage:Hello学号姓名！\n；Hello%s%s\n： 这两个字符串常量分别由.LC0和.LC1表示，存放在只读数据段.rodata中。 intargc： argc首先被保存在了寄存器%edi中，后续需要参与判断的时候编译器将其赋值给了-20(%rbp)。 charargv[]： argv[]的每个元素都是一个指向字符类型的指针，起始地址存放在栈中-32（%rbp）的位置，并且被两次调用传给printf。 3.3.2赋值 源程序中的赋值操作主要有：intsleepsecs=2.5、i=0。 对于intsleepsecs=2.5，直接在.data节中就已经将sleepsecs声明为值为2的long类型数据（隐式转换）。 对于i=0。在hello.s文件中是通过汇编语句movl$0，-4(%rbp)将立即数赋值给局部变量i的。这里使用的是“movl”，这是因为指令的后缀取决于操作数据的字节大小，movb：一个字节；movw：两个字节；movl：四个字节；movq：八个字节，而局部变量i是int类型的数据，占4个字节。 3.3.3类型转换 intsleepsecs=2.5的操作中出现了隐式类型转换，由于当double或float向int进行类型转换的时候，程序遵循向零舍入的原则将浮点数2.5转化为int类型的整数2，然后由于编译器缺省，int类型又被转换为了long类型。 3.3.4算术操作 在for循环的时候出现了算术操作为i++，编译时转化成加法指令，使用立即数1来实现每次增加1。 3.3.5关系操作 在程序中有两次关系操作： if中判断argc的取值是否不等于3：利用cmpl将argc和3进行比较，指令je根据条件码决定是否跳转。 for循环中判断i是否小于10：我们可以看到汇编代码将它优化为了i<=9，编译器会计算-4(%rbp)-9，并设置条件码，随之jle语句通过条件码决定进行怎样的跳转处理。 3.3.6数组/指针/结构操作 程序在访问argv[]的时候出现了数组操作，在向main函数传参时，通过movq%rsi,-32(%rbp)进行参数的传递，把argv数组的首地址保存在栈中。使用首地址+偏移量的方式来访问数组元素，数组首地址存储在%rbp-32，通过将首地址加8获得argv[1]的地址，将首地址加16获得argv[2]的地址，从而在循环中分别读取了argv[1]和argv[2]。 3.3.7控制转移 程序中有两次控制转移： if中判断argc的取值是否不等于3之后的控制转移： cmpl指令将argc和3进行比较，je根据条件码决定是否跳转，控制转移也由它完成。 for循环结束时的控制转移： 编译时使用cmpl指令将i和9进行比较，jle根据条件码决定是否跳转，控制转移也由它完成。 3.3.8函数操作 程序中一共有五次函数操作：main函数；printf函数；sleep函数；getchar函数；exit函数： 函数调用：printf函数第一次调用为在汇编代码中被优化为puts函数，第二次调用为直接调用；其他函数则直接通过call@函数名调用。 参数传递：向main函数传递的参数是argc和argv[]，分别使用%rdi（%edi）和%rsi存储；printf函数第一次传递首先将rdi赋值为字符串“Usage:Hello学号姓名！\n”字符串的首地址，然后调用了puts函数，将字符串参数传入，第二次则传递了3个参数，%rdi保存的是“Hello%s%s\n”的首地址，%rsi保存的是argv[1]，%rdx保存的是argv[2]；sleep函数则是通过movlsleepsecs(%rip),%eax和movl%eax,%edi，对应sleepsecs；getchar函数没有参数传递的过程；exit通过汇编语句movl$1，%edi将内容设置为1。 函数返回：只有main函数有函数返回的过程，将%eax设置为0后通过leave退出。 3.4本章小结 本章介绍了编译的概念以及作用，同时对hello.s的编译代码的数据、赋值、类型转换、算术操作、关系操作、数组/指针/结构操作以及控制转移和函数操作进行了分析。 第4章汇编 4.1汇编的概念与作用 概念： 汇编器（as）将.s汇编程序翻译成机器语言，把这些机器语言指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码，这个过程就叫做汇编。 作用： 汇编的作用就是将高级语言转化为机器可直接识别执行的机器指令代码文件。 4.2在Ubuntu下汇编的命令 命令：ashello.s-ohello.o 4.3可重定位目标elf格式 利用readelf-ahello.o>helf.txt获得hello的elf文件并重定向到helf.txt。 ELF头： 它以一个16字节的目标序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。hello.o中，这个16字节序列为7f454c46020101000000000000000000，并且系统的字的大小为8字节，字节顺序为小端序。剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型（如x86-64）、节头部表的文件偏移，以及节头部表中条目的大小和数量。 节头： 节头描述不同节的位置和大小，目标文件中的每个节都有一个固定大小的节头部表条目。在hello.s中： .text节表示已编译程序的机器代码。.rela.text节表示一个.text节中位置的列表。 .data节表示已初始化的全局和静态C变量，且该节的数据可读可写。.bss节表示未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量，且该节的数据可读可写。.rodata节：只读数据。.comment节表示版本控制信息。.note.GNU_stack节表示可执行堆栈。.eh_frame节处理异常，且数据只读。.rela.eh_frame节表示.eh_frame节的重定位信息。.shstrtab节表示节区名称。.symtab节表示一个符号表，存放在程序中定义和引用的函数和全局变量的信息。.strtab节表示一个字符串表，包括.symtab和.debug节中的符号表，以及节头部中的节名字。 符号表：符号表存放程序中定义和引用的函数和全局变量的信息，每个符号表是一个条目的数组，每个条目包括距定义目标的节的起始位置的偏移；目标的大小；指明数据还是函数；表示符号是本地的还是全局的等。 重定位节： 汇编器遇到对最终位置未知的目标引用，会产生一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。重定位信息就放在重定位节.，重定位条目放在.rel.data中。每个重定位条目包括需要被修改的引用的节偏移；标识被修改引用应该指向的符号；重定位类型。 ELF定义了32种不同的重定位类型，两种最基本的重定位类型包括R_X86_64_PC32（重定位使用32位PC相对地址的引用）和R_X86_64_32（重定位使用32位绝对地址的引用）。 4.4Hello.o的结果解析 利用objdump-d-rhello.o进行反汇编： 将其与hello.s进行对比： 我们可以知道机器语言指的是二进制的机器指令集合，机器可以直接根据二进制代码执行对应的操作。而机器指令是由操作码和操作数构成的。汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式。 每一条汇编语言的指令都可以映射到一条机器语言指令，从汇编语言转换成机器语言的过程中，部分操作数会出现不一致： 分支转移：hello.s文件中分支转移是使用段名称进行跳转的，而hello.o文件中分支转移是通过重定位地址进行跳转的。 函数调用：hello.s文件中，调用call后的是函数名称，而在hello.o文件中，因为这些函数都是共享库函数，它们的地址是不确定的，因此call指令将相对地址全部设置为0，然后在.rela.text节中为其添加重定位条目，在链接时确定最终的相对地址。 立即数：hello.s中的立即数都是用10进制数表示的，但在机器语言中，立即数都是用16进制数表示的。 4.5本章小结 本章介绍了汇编的概念以及作用，通过readelf命令查看了hello.o可重定位目标elf格式，并对其中的ELF头、节头、符号表和重定位表进行了分析。除此之外，将hello.o的反汇编代码和hello.s的代码进行比较，理解了汇编指令与机器指令的区别，更深刻地理解了汇编这一过程。 第5章链接 5.1链接的概念与作用 概念：链接是将各种代码和数据的片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。 作用：链接可以执行于编译时，也就是在源代码被翻成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在现代系统中，链接由链接器程序自动执行。链接包括两个主要任务：符号解析和重定位。链接在软件开发中扮演着一个关键的角色，因为它使得分离编译成为可能。无需将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块，极大地提高了大型程序编写的效率。 5.2在Ubuntu下链接的命令 命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 利用readelf-ahello>h1elf.txt查看可执行目标文件hello的ELF格式，并将结果重定向到h1elf.txt。其中信息相似的部分在4.3已经有过介绍，就不再赘述了，新的部分会在下面进行补充： ELF头： 节头： 程序头：描述了可执行文件的连续的片映射到连续的内存段的映射关系。包括目标文件的偏移、段的读写/执行权限、内存的开始地址、对齐要求、段的大小、内存中的段大小等。 符号表：相比于hello.o多出的符号是链接后产生的库中的函数以及一些必要的启动函数。 同时还有动态符号表，里面的符号都是共享库中的函数，需要动态链接： 重定位节：我们可以看到原来的.rela.text节已经没有了，说明链接的过程已经完成了对.rela.text的重定位操作。并且出现了新的重定位条目，它们和共享库中的函数有关，因为此时还没有进行动态链接，共享库中函数的确切地址仍是未知的，因此仍然需要重定位节，在动态链接后才能确定地址。 5.4hello的虚拟地址空间 通过edb，看出hello的虚拟地址空间开始于0x400000,结束与0x400ff0： 而其中，我们分析.rodata： 可以看到该节的位置,大小都和前面的节头一致，其他不一一列出了。 5.5链接的重定位过程分析 利用objdump-d-rhello进行hello的反汇编。 hello.o和hello反汇编的对比： 相比之下hello反汇编后多了许多文件节： hello.o反汇编之后其中的地址大多是相对偏移地址，而hello反汇编的地址是虚拟地址。这是因为hello已经是可执行文件了，相关的重定位工作必须已经完成，所有虚拟地址也必须确定。 相比之下，hello反汇编之后增加了许多外部链接的共享库函数： 重定位分析：当汇编器生成一个目标模块时，针对最终位置未知的目标引用，它会生成一个重定位条目，告诉链接器在生成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。在把hello.o链接为可执行文件hello的过程中，链接器就是根据.rel_data和.rel_text节中保存的重定位信息对符号或者函数进行重定位的。 重定位算法如下： 以hello.o重定位表中的第一项为例，目标符号引用出现在偏移0x1c处，其运行时地址为0x401141，目标符号定义在.rodata节中，其运行时地址为0x402008，我们记录下一条指令的运行时地址0x401145，将其与目标符合定义处的运行时地址做差得0x0ec3，将其转化为小端法表示则为c30e0000，与结果刚好相符。 5.6hello的执行流程 程序名程序地址ld-2.27.so!_dl_start0x7fce8cc38ea0ld-2.27.so!_dl_init0x7fce8cc47630hello!_start0x400550hello!init0x4004c0hello!main0x400582hello!puts@plt0x4004f0hello!exit@plt0x400530hello!printf@plt0x400500hello!sleep@plt0x400540hello!getchar@plt0x400510sleep@plt0x400540 5.7Hello的动态链接分析 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时，还是需要用到动态链接库。在调用共享库函数时生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。GNU编译系统使用延迟绑定，将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定是通过全局偏移量表(GOT)和过程连接表(PLT)实现的。GOT是数据段的一部分，而PLT是代码段的一部分。两表内容分别为： PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 接下来我们对hello的动态链接进行分析： 根据hello可执行目标文件可知，如下图所示，GOT运行时地址为0x403ff0，PLT的运行时地址为0x404000： 在程序调用dl_init前，使用edb查看地址0x404000处的内容： GOT表的内容在调用_start之后发生改变，其中GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是共享库模块的入口点。 5.8本章小结 本章首先介绍了链接的概念、作用，查看了hello的格式，随后分析了可执行目标文件与可重定位目标文件的区别，利用hello详细介绍了静态链接的重定位等过程，之后分析了hello的执行流程并且对hello介绍了动态链接分析，此时hello程序就可以加载到内存中执行了。 第6章hello进程管理 6.1进程的概念与作用 概念：进程就是一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文中。其中上下文是由程序正确运行所需的状态组成的，包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。 作用：进程的作用在于通过进程可以提供给我们一个假象，就好像我们的程序是系统中运行的唯一的程序；程序好像独占地使用处理器和内存；处理器好像是无间断地一条接一条地执行程序中的指令；程序的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 作用：Shell是用户与操作系统之间完成交互式操作的一个接口程序，它为用户提供简化了的操作。Shell最重要的功能是命令解释，从这种意义上说，Shell是一个命令解释器。Linux系统上的所有可执行文件都可以作为Shell命令来执行。当用户提交了一个命令后，Shell首先判断它是否为内置命令，如果是就通过Shell内部的解释器将其解释为系统功能调用并转交给内核执行；若是外部命令或实用程序就试图在硬盘中查找该命令并将其调入内存，再将其解释为系统功能调用并转交给内核执行。 处理流程： 终端进程读取用户由键盘输入的命令行。 分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量。 检查首个命令行参数是否是一个内置的shell命令。 如果不是内部命令，调用fork()创建新进程/子进程。 在子进程中，用步骤2获取的参数，调用execve()执行指定程序。 如果用户没要求后台运行(命令末尾没有&号）否则shell使用waitpid等待作业终止后返回。 如果用户要求后台运行(如果命令末尾有&号），则shell返回。 6.3Hello的fork进程创建过程 （以下格式自行编排，编辑时删除） 当在shell中输入命令“./hello1190200106何炫霖”时，shell解析输入的命令行，获得命令行指定的参数。由于./hello不是shell内置的命令，因此shell将hello看作一个可执行目标文件，在相应路径里寻找hello程序，找到该程序就执行它。shell会通过调用fork()函数创建一个子进程，新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同但独立的一个副本，包括代码段、数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，子进程可以读写父进程中打开的任何文件。父进程和子进程之间最大的区别在于它们的PID不同。hello程序之后就会运行在这个新创建的子进程的上下文中。 6.4Hello的execve过程 当创建了一个子进程之后，exceve函数在当前子进程的上下文加载并运行一个新的程序，加载并运行需要以下几个步骤： 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中已存在的区域结构。 映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些区域结构都是私有的，写时复制的。虚拟地址空间的代码和数据区域被映射为hello文件的.txt和.data区。 映射共享区域。如果hello程序与共享对象链接，然后再映射到用户虚拟地址空间中的共享区域。 设置程序计数器。exceve做的最后一件事就是设置当前进程的上下文中的程序计数器，使之指向代码区域的入口点。下一次调用这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 6.5Hello的进程执行 用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，这个模式中，硬件防止特权指令的执行，并对内存和I/O空间的访问操作进行检查。设置模式位时，进程处于内核模式，一切程序都可运行。任务可以执行特权级指令，对任何I/O设备有全部的访问权，还能够访问任何虚地址和控制虚拟内存硬件。 上下文信息：上下文程序正确运行所需要的状态，包括存放在内存中的程序的代码和数据，用户栈、用寄存器、程序计数器、环境变量和打开的文件描述符的集合构成。 Hello进程执行分析： Hello起初在用户模式下运行，在hello进程调用sleep之后转入内核模式，内核休眠，并将hello进程从运行队列加入等待队列，定时器开始计时2s，当定时器到时，发送一个中断信号，此时进入内核状态执行中断处理，将hello进程从等待队列中移出重新加入到运行队列，hello进程继续执行。 6.6hello的异常与信号处理 异常和信号异常可以分为四类：中断、陷阱、故障、终止： 对于hello程序： 正常运行： 随机键盘输入： 可以看到，无意义输入均被缓存到stdin，当调用getchar时读出一个‘\n’结尾的字符串，其他字符会当做shell命令输入，并且无意义输入并不会影响到hello进程的运行。 Ctrl+c： 按下Ctrl-C后，hello进程运行终止。组合键Ctrl-C会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况下，结果是终止前台作业。利用ps指令可以看到，hello进程已经父进程回收，进程表中无hello进程： Ctrl+z： 按下Ctrl-Z后，hello进程运行暂停。组合键Ctrl-Z会导致内核发送一个SIGSTP信号到前台进程组的每个进程，默认情况下，结果是挂起前台作业。 ps： 可以看到，hello进程并没有被回收，此时其后台作业号为1。 jobs： 可以看出当前的作业是hello进程，且状态是已停止。 pstree(部分)：将所有进程以树状图形式显示 fg： fg命令可以使停止的hello进程继续在前台运行，可以看到hello程序继续运行了。 kill： kill命令可以给指定进程发送信号。如图，kill-93647是指向PID为3647的进程（即hello）发送SIGKILL信号。这个命令会杀死hello进程，当再次使用ps时可以发现hello进程已经被杀死。 6.7本章小结 本章介绍了进程的概念与作用，同时介绍shell的一般处理流程和作用，并且分析了调用fork函数创建新进程和调用execve函数加载并执行hello，最后分析了hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：逻辑地址是指由程序产生的与段相关的偏移地址部分。例如，在进行C语言指针编程中，可以使用&操作读取指针变量的值，这个值就是逻辑地址，是相对于当前进程数据段的地址。一个逻辑地址由两部份组成：段标识符和段内偏移量。 线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址生成了一个线性地址。如果启用了页式管理，那么线性地址可以再变换产生物理地址。若没有启用页式管理，那么线性地址直接就是物理地址。 虚拟地址：因为虚拟内存空间的概念与逻辑地址类似，因此虚拟地址和逻辑地址实际上是一样的，都与实际物理内存容量无关。 物理地址：存储器中的每一个字节单元都给以一个唯一的存储器地址，用来正确地存放或取得信息，这个存储器地址称为物理地址，又叫实际地址或绝对地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址的表示形式为[段标识符：段内偏移量]，这个表示形式包含完成逻辑地址到虚拟地址（线性地址）映射的信息。 逻辑地址实际是由48位组成的，前16位是段选择符，后32位是段内偏移量。通过段选择符，我们可以获得段基地址，再与段内偏移量相加，即可获得最终的线性地址。 段标识符又名段选择符，是一个16位的字段，包括一个13位的索引字段，1位的TI字段和2位的RPL字段。 通过段标识符的前13位，可以直接在段描述符表中索引到具体的段描述符。每个段描述符中包含一个Base字段，它描述了一个段的开始位置的线性地址。将Base字段和逻辑地址中的段内偏移量连接起来就得到转换后的线性地址。全局的段描述符，放在全局段描述符表中，每个进程自己的段描述符，放在局部段描述符表中。全局段描述符表存放在gdtr控制寄存器中，而局部段描述符表存放在ldtr寄存器中。 逻辑地址到线性地址的变换过程为：给定逻辑地址，看段选择符的最后一位是0还是1，从而判断选择全局段描述符表还是局部段描述符表。通过段标识符的前13位，得到Base字段，和段内偏移量连接起来最终得到转换后的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 页表： 页表是一个页表条目（PTE）的数组，用于维护物理地址和虚拟地址的映射关系。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。每个PTE由一个有效位和一个n位地址字段组成，有效位表明该虚拟页是否被缓存在DRAM中。如果设置了有效位，那么地址字段表示相应的物理页的起始位置；如果没有设置有效位，那么空地址表示虚拟页还未被分配，否则这个地址指向该虚拟页在磁盘的起始位置。 如果不考虑TLB与多级页表，虚拟地址可以分为虚拟页号VPN和虚拟页偏移量VPO。其中，VPN可以作为到页表中的索引。进而，通过页表基址寄存器（PTBR）我们可以在页表中获得条目PTE。一条PTE中包含有效位和物理页号（PPN）。如果有效位是0，则代表页面不在存储器中（缺页）；如果有效位是1，则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，再与物理页偏移量（PPO）共同构成物理地址PA。 当页面命中时CPU硬件执行的步骤： 1．处理器生成一个虚拟地址，并把它传送给MMU； 2．MMU生成PTE地址，并从高速缓存/主存请求得到它； 3．高速缓存/主存向MMU返回PTE； 4．MMU构造物理地址，并把它传送给高速缓存/主存； 5．高速缓存/主存返回所请求的数据字给处理器。 7.4TLB与四级页表支持下的VA到PA的变换 PTE有三个权限位，控制对页的访问。R/W位确定页的内容是可以读写的还是只读的。U/S位确定是否能够在用户模式中访问该页，从而保护操作系统内核中的代码和数据不被用户程序访问。禁止执行位可以用来禁止从某些内存读取指令。当MMU翻译每一个内存地址时，它还会更新另外两个内存缺页处理程序会用到的位。每次访问一个页时，MMU都会设置引用位。内核可以用这个引用位来实现它的页替换算法。每次对一个页进行了写之后，MMU都会设置修改位或脏位。修改位告诉内核在复制替换页之前是否必须写回牺牲页。内核可以通过调用一条特殊的内核模式指令来清除引用位和修改位。 Corei7MMU中，36位VPN被划分成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 7.5三级Cache支持下的物理内存访问 首先使用物理地址的CI进行组索引，对8个块分别对CT进行标志位的匹配。如果匹配成功且块的有效位为1，则成功命中。然后根据数据偏移量CO取出相应的数据并返回。这里的数据保存在一级Cache。 如果没有命中，或者没找到相匹配的标志位，那么就会在下一级Cache中寻找，只要本级Cache中没找到就要去下一级的Cache中寻找数据，然后逐级写入Cache。 在更新Cache的时候，首先需要判断是否有有效位为0的块。若有，则直接写入；若不存在，则需要驱逐一个块（LRU策略），再进行写入。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。内核给新进程创建虚拟内存，创建当前进程的mm_struct、区域结构和页表的原样副本，将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，为每个进程保持了私有地址空间的抽象概念。同时延迟私有对象中的副本直到最后可能的时刻，充分利用了稀有的物理内存。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码,在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1.删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2.映射私有区域,为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的,初始长度为零。 3.映射共享区域，hello程序与共享对象libc.so链接,libc.so是动态链接到这个程序中的,然后再映射到用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 处理缺页要求硬件和操作系统内核协作完成： 1：处理器生成一个虚拟地址，并把它传送给MMU。 2：MMU生成PTE地址，并从高速缓存/主存请求得到它。 3：高速缓存/主存向MMU返回PTE。 4：PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。 5：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。 6：缺页处理程序页面调人新的页面，并更新内存中的PTE。 7：缺页处理程序返回到原来的进程，再次执行导致缺页的指令，CPU将地址重新发送给MMU。因为虚拟页面现在已经缓存在物理内存中，所以会命中，主存将所请求字返回给处理器。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块： 显式分配器：要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。C++中的new和delete操作符与C中的malloc和free相当。显式分配器必须在严格的约束条件下工作，约束有：必须处理任意请求序列；立即响应请求；只使用堆；对齐块；不修改已分配的块。分配器的编写应该实现：吞吐率最大化；内存使用率最大化（两者相互冲突）。 隐式分配器：要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集。例如，诸如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 在分配器的具体实现中，主要有以下几种实现方法： 显式空闲链表： 堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。这样一来，会使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。显式空闲链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。 隐式空闲链表： 隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要求对空闲链表进行搜索，该搜索时间与堆中已分配块和空闲块的总数呈线性关系。 带边界标记的隐式空闲链表： 这种方式可以允许在常数时间进行对前面块的合并，并且它对许多不同类型的分配器和空闲链表组织都是通用的。然而它也存在一个潜在的缺陷。它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销。 7.10本章小结 本章先介绍了各类地址的概念，然后分析了从逻辑地址到线性地址的变化（段式管理），以及从线性地址到物理地址的变化（页式管理）。然后解析了TLB与四级页表支持下的VA到PA的变换详细分析了地址翻译的过程，分析了三级Cache支持下的物理内存访问，以及hello进程fork和execve时的内存映射，还有缺页故障与缺页中断处理的操作过程。最后讲述了动态存储分配管理的基本方法和策略，从而得到了一个较为完整的动态分配内存的过程。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，所有的输入输出都被当作对相应文件的读和写来执行。 设备管理：unixio接口 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 UnixI/O接口： 打开文件： 一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息，应用程序只需要记住这个描述符。 linuxshell： 创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件中的常量可以代替显式的描述符值。 改变当前的文件位置： 对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。 读写文件： 一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 关闭文件： 当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： 打开文件的函数：intopen(char*filename,intflags,mode_tmode)； open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件；mode参数指定了新文件的访问权限位。 关闭文件的函数：intclose(intfd)； fd是需要关闭的文件描述符，成功返回0，错误返回-1。关闭一个已关闭的描述符会出错。 读写文件的函数：ssize_tread(intfd,void*buf,size_tn)； ssize_twrite(intfd,constvoid*buf,size_tn)； read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 先看printf函数的源码： int printf(const char *fmt,  ) { int i; char buf[256]; va_list arg = (va_list)((char*)(&fmt) + 4); i = vsprintf(buf, fmt, arg); write(buf, i); return i; } printf函数是格式化输出函数,一般用于向标准输出设备按规定格式输出信息。printf中调用了两个函数，分别为vsprintf和write： 对于vsprintf函数，它根据格式串fmt，并结合args参数产生格式化之后的字符串结果保存在buf中，并返回结果字符串的长度。 对于write函数： moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL 它将buf中的i个字符写到终端，由于i保存的是结果字符串的长度，因此write将格式化后的字符串结果写到终端。 sys_call函数： sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret 它实现的功能就是把将要输出的字符串从总线复制到显卡的显存中。显存中存储的是字符的ASCII码。字符显示驱动子程序通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar源码如下： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } getchar函数会从输入流中读入一个字符，输入的字符会存放在缓冲区中，如果输入了多个字符，之后的getchar会直接从缓冲区中读取字符。 getchar的返回值是读取字符的ASCII码，若出错则返回-1。 而对于异步异常-键盘中断的处理为键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章首先介绍了Linux的IO设备管理方法、UnixIO接口及其函数，最后分析了printf函数和getchar函数的实现。 结论 hello经历的过程： 源程序编写：通过编写工具(文本编辑器、IDE等)编写出hello.c； 预处理：预处理器cpp读取需要的系统头文件内容，生成ASCII码的中间文件hello.i。 编译：编译器ccl将C语言代码翻译成汇编指令，生成hello.s。 汇编：汇编器as将hello.s翻译成机器语言指令，并生成重定位信息，将结果保存在可重定位目标文件hello.o中。 链接：链接器进行符号解析、重定位、动态链接等创建一个可执行目标文件hello，此时hello可以被执行。 运行阶段：当我们在shell键入./hello启动程序的时候，shell调用fork函数为其产生子进程，子进程中调用execve函数，加载hello程序，进入hello的程序入口点。 进程运行：内核负责调度进程，并对可能产生的异常及信号进行处理。内存的管理由MMU、TLB、多级页表、cache、DRAM内存、动态内存分配器共同完成，而UnixI/O的作用则是让程序与文件进行交互。 终止：hello最终被shell父进程回收，内核删除为hello进程创建的所有数据结构。 感悟： hello从诞生到结束，需要在硬件、操作系统、软件的相互协作配合下，才能最终让它完美地实现自己的功能。从中我看到了对于一个系统而言，需要进行多方面的协调配合才能让每个模块发挥相应的功能。同时，计算机科学家们所做的抽象让应用与具体实现相互分离，从而让我们在实际体验当中往往会忽略它背后隐藏的复杂，我认为这是十分伟大的工作。 通过本门课程的学习，我觉得更多的是给我打开了计算机领域的大门，里面蕴藏着一代代科学家毕生研究的结晶，有许多奥秘等着我去探索，我还需要在未来的学习中更深入的研究里面的知识。 附件 文件名文件作用hello.i预处理器修改了的源程序，分析预处理器行为hello.s编译器生成的编译程序，分析编译器行为hello.o可重定位目标程序，分析汇编器行为hello可执行目标程序，分析链接器行为helf.txthello.o的elf格式，分析汇编器和链接器行为h1elf.txt可执行hello的elf格式，用来进行重定位过程分析 参考文献 [1]ANSIC标准定义的C语言预处理指令总结https://blog.csdn.net/zxnsirius/article/details/51158895?utm_source=itdadao&utm_medium=referral [2] 深入了解计算机系统（第三版）2016Bryant,R.E.机械工业出版社 [3] GCC编译器将源程序“.c”文件翻译为可执行文件的过程https://blog.csdn.net/qq_41543757/article/details/101019828 [4] printf函数实现的深入剖析https://www.cnblogs.com/pianist/p/3315801.html 
第58篇文章[]
软件构造博客1.Git的相关操作和使用 博客主要讲述笔者实验中遇到的一些问题的解决方法： 在开始软件构造实验的时候，相信大家都会对利用Git进行提交文件到Github上的指令有困惑，本文就这个问题给出了较为详细的操作步骤。 Git的相关安装操作实验手册上面已经有了介绍，这里就不再赘述。同时你还需要一个Github账号和仓库（感觉在说废话。。）。 1.打开你的Github仓库，点击code，将上面的URL复制下来（其实直接利用浏览器复制也可以） 2.然后去本地建立仓库与Github上的仓库相关联，找到你想建立本地仓库的位置，右击，如果你之前成功安装了Git的话，会出现GitBashhere，点击它。 3.在命令行中输入gitclonehttps (就是你从Github上复制得来的URL) 然后我们就会发现在你创建的地方出现了一个和你Github仓库名一样的文件夹，那就是你和Github仓库相关联的本地仓库文件夹。接下来我们就要通过本地仓库将文件提交到Github仓库中。 4.将你想要提交的文件全部放入本地文件夹中，然后进入Gitbash，在命令行中输入如下代码： gitadd. （此操作是把文件夹下面的文件进行添加） gitcommit -m ”随便写（提交信息）” （提交信息随便写，但是在软件开发的过程中最好是你实验的进度） gitpush-uoriginmaster（分支名） （本操作是将本地仓库push到github上面的master分支，如果交到其他分支上需要修改分支名字，第一次操作可能需要你输入帐号和密码） 完成这些操作后，我们打开我们的Github仓库以后就能看到我们提交之后的结果了。 除了上面以外，还有一些笔者在实际实验过后得出的一点可能称得上是建议的几点： 1.虽然Github也能手动提交，但是效率比较低，而且如果验收方是利用软件进行文件的检查的话手动提交的文件可能不会被查到，而且利用Git提交还能让开发者在Github上看清每次提交的差别，因此实际应用中笔者还是鼓励大家利用Git将提交到Github上。 2.虽然我们学校的WIFI自称能够直接访问Github，但是根据笔者自身体验下来，这种情况很少，甚至几乎没有==，不知道别的同学是不是跟我一样，所以还是鼓励大家在进行访问和提交操作的时候进行一些合理的“科学上网”，从而提高使用Git和Github的体验。 
第59篇文章[]
软件构造博客5.正则表达式梳理 在Lab3的实现过程中涉及到正则表达式的解析，本文就这个问题给出相关知识点的梳理。 首先我们先要了解什么是正则表达式。根据定义，正则表达式(regularexpression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 正则表达式是由普通字符（例如字符a到z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 在实际应用过程中我们使用grammar判断字符串是否合法，并解析成程序里使用的数据结构，通常是递归的数据结构。 url::=‘http://’hostname‘/’hostname::=‘mit.edu’|‘stanford.edu’|‘google.com’ 其中，url是根节点（特殊的非终止符），与’google.com’相似的是终止符，hosname是非终止符 操作： 连接：x::=yz（空格）重复（0次或多次）：x::=y*选择：x::=y|z有无：x::=y?重复（1次或多次）：x::=y+区间：x::=[a-c]equalsx::=‘a’|‘b’|‘c’x::=[aeiou]equalsx::=‘a’|‘e’|‘i’|‘o’|‘u’不包含区间：x::=[^a-c]equalsx::=‘d’|‘e’|‘f’|…*?+优先级最高，连接次之，|最低而正则语法的定义为：简化之后可以表达为一个产生式而不包含任何非终止节点 正则表达式的语法规则为： 
第60篇文章[]
软件构造博客6.final的功能用法总结 关于final，相信使用过Java的人都对它不陌生，而本文则将对它的功能和用法进行总结。 final关键字是一种变量前面的修饰符，代表着程序员的最终决策，final变量只能被赋值一次。 例如以下例子 finaldoublea=3.1; a=3.1412; finaldoubleb; b=3.1; b=3.1412; 以上两种方法都是错误的，因为对于double来说，final变量只能被赋值一次。同时对于基本的数值变量，比如int,float,double,boolean,其final一旦被确定则不可以进行任何修改。（如上面例子） 然而对于那些可变的（mutable）对象（object）变量，比如Data类，stringbuilder等，final只是固定了对其的引用，并不能保证其中的值不被修改。 如下例子： finalStringBuilderstringBuilder1=newStringBuilder(); stringBuilder1.append("Iamsosmart "); System.out.print(stringBuilder1); finalStringBuilderstringBuilder1=newStringBuilder(); StringBuilderstringBuilder2=stringBuilder1; stringBuilder2.append("Iamsosmart "); System.out.print(stringBuilder1); 以上两种方法都是可行的，所以我们到底该怎么理解final呢？ 笔者的理解是： 把final想象成一个固定的引用即可，对于基本变量类型，其被彻底固定，对于对象变量，我们仍可以使用其引用去修改它。 
第61篇文章[]
软件构造6 在此记录一个之前从未了解到的问题。 首先来看本人定义的一个ADT，命名为Employee，定义的ADT如下： publicclassEmployee{ privatefinalStringname; privatefinalStringjob; privatefinalStringphone; //Abstractionfunction: //name映射为员工名字，job映射为员工职务，phone映射为员工电话号码 //Representationinvariant: //name,job,phone都不为空 //Safetyfromrepexposure: //使用privatefinal修饰实例字段，防御式编程。 /** *初始化 *@paramname员工名字 *@paramjob员工职务 *@paramphone员工电话号码 */ publicEmployee(Stringname,Stringjob,Stringphone){ this.name=name; this.job=job; this.phone=phone; checkrep(); } /** *获得员工名字 *@return员工名字 */ publicStringgetname(){ returnname; } /** *获得员工职务 *@return员工职务 */ publicStringgetjob(){ returnjob; } /** *获得员工电话号码 *@return员工电话号码 */ publicStringgetphone(){ returnphone; } /** *检查 */ privatevoidcheckrep(){ assertname!=null; assertjob!=null; assertphone!=null; } @Override publicStringtoString(){ Strings="Employee:\n"+"姓名："+name+"\n"+"职务："+job+"\n"+"手机号码："+phone+"\n"+"\n"; returns; } @Override publicbooleanequals(Objectobj){ if(obj==null){ returnfalse; } if(objinstanceofEmployee){ if(this==obj){ returntrue; } Employeee=(Employee)obj; if(name.equals(e.name)&&job.equals(e.job)&&phone.equals(e.phone)){ returntrue; } } returnfalse; } @Override publicinthashCode(){ returnname.hashCode()+job.hashCode()+phone.hashCode(); } } 其中，name、job、phone均为privatefinal修饰的，而在重写equals的过程中，我们发现在将obj强制类型转换为Employee后，在判断两个对象的name、job和phone是否相同的过程中可以直接访问e中的name、job和phone，即可以直接使用e.name、e.job、e.phone，而name、job、phone这三个表示都是privatefinal的，按常规认识来说应当无法直接访问到，所以这是一个非常有意思的地方。 在翻阅PPT后，我们又发现了一处出现这种情况的地方，如下图所示。 这里，first和last都是privatefinal的，但在重写的equals中都可以直接通过n.first和n.last访问。 这种情况是之前在编程中未曾发现的，如果可以通过这种方式访问内部的表示的话，也就免去了在equals方法内部调用getname、getjob和getphone方法才能得到相应的表示的麻烦，更加清晰、明了。 
第62篇文章[1]
计算机系统大作业 程序人生-Hello’sP2P 摘 要 本文主要介绍了hello程序在Linux系统下的整个生命周期。详细地对预处理、编译、汇编、链接的过程进行了分析，并讨论了hello的进程管理、存储管理以及IO管理，介绍了汇编指令、机器代码、重定位、动态链接、异常控制流、虚拟内存以及IO函数的相关内容，对hello的一生进行了完整的描述，漫游了整个计算机系统。 关键词：汇编；链接；进程；虚拟内存；IO； 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 hello的P2P过程是从一个程序员输入的源文件hello.c开始的。hello.c分别经过预处理器cpp的预处理生成修改了的源程序hello.i、编译器ccl的编译生成汇编程序hello.s、汇编器as的汇编生成可重定位目标程序hello.o，最后通过链接器ld的链接生成可执行目标程序hello。当在shell中输入./hello后，shell会调用fork函数创建一个新的进程，然后调用execve将其加载到内存中，此时hello便从一个程序变为了进程。 随后CPU控制其逻辑流的运行、中断以及上下文切换。当进程终止后，父进程负责回收hello进程，内核删除相关数据结构。此过程即为hello的020. 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位 开发与调试工具：edb,gcc,gdb,readelf,HexEdit,vim 1.3中间结果 文件名称文件作用hello.ihello.c经过预处理后生成的修改了的源程序hello.shello.i经过编译后生成的汇编程序hello.ohello.s经过汇编后生成的可重定位目标程序hellooelf.txt保存hello.o的elf格式的文件信息的文本文件hellooobjdump.txt保存hello.o经过反汇编后生成的内容的文本文件hellohello.o经过链接后生成的可执行目标程序helloelf.txt保存hello的elf格式的文件信息的文本文件helloobjdump.txt保存hello经过反汇编后生成的内容的文本文件 1.4本章小结 本章主要介绍了hello程序的P2P、020的过程，并列出了实验环境与工具以及中间结果的相关信息。 第2章预处理 2.1 预处理的概念与作用 1.预处理的概念：预处理器(cpp)根据以字符#开头的命令，修改原始的C程序，得到一个以.i作为文件扩展名的C程序。 2.预处理的作用： (1).宏定义：用实际值替换用#define定义的字符串。 (2).文件包含：将#include所包含的头文件直接加入到文本文件中。比如#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。 (3).条件编译：如#ifdef，#ifndef，#else，#elif，#endif等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。 2.2在Ubuntu下预处理的命令 命令：gcc-m64-no-pie-fno-PIChello.c-E-ohello.i 图2.1Ubuntu下的预处理 2.3Hello的预处理结果解析 图2.2hello的预处理结果 经过预处理后，hello.c文件生成了hello.i文件，打开hello.i文件后可见文件从原本的28行扩展到了3000多行。原文件中包含的头文件stdio.h、unistd.h、stdlib.h的内容被插入到了该文件中。 2.4本章小结 本章主要介绍了预处理的概念及其作用，对hello.c文件进行了预处理操作并解析了其预处理的结果。 第3章编译 3.1编译的概念与作用 1.编译的概念：编译是指编译器做词法分析、语法分析、语义分析等，在检查无错误后，将代码翻译成汇编语言的过程。编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。 2.编译的作用： (1).进行词法分析和语法分析，分析过程中发现有语法错误，给出提示信息。 (2).将文本文件转化为汇编语言的形式，为后续的汇编操作奠定基础。汇编语言是非常有用的，它为不同的高级语言的不同编译器提供了通用的输出语言。最后生成一个汇编语言程序.s文件。 (3).除了基本功能之外，编译程序还具备调试措施、修改手段、覆盖处理、目标程序优化、不同语言合用等重要功能。 3.2在Ubuntu下编译的命令 命令：gcc-m64-no-pie-fno-PIC-Shello.i-ohello.s 图3.1Ubuntu下编译的命令 3.3Hello的编译结果解析 3.3.1数据 局部变量 main函数中声明了一个局部变量i，在编译时局部变量i会存放在堆栈中，如图所示，其初始值被赋值为0，存放在栈上%rbp-4的位置处。 图3.2局部变量 全局变量 在文件的开头定义了全局变量sleepsecs，由于其为int类型，故被赋值为2，并存放在.rodata节中。如图所示。 图3.3全局变量 立即数 立即数直接体现在汇编代码中，如图所示。 图3.4立即数 参数intargc argc作为传递给main的第一个参数，存放在堆栈上，如图所示，原本存放在寄存器%edi中的argc被存放在%rbp-20的位置处。 图3.5参数intargc的存放位置 数组char*argv[] char*argv[]是传递给main的第二个参数，其数组中的每一个元素均为字符类型的指针。如图所示，其被存放在%rbp-32位置处。 图3.6数组char*argv[]的存放位置 字符串 程序中共有两个字符串，如图所示，这两个字符串均存放在只读数据段中。 图3.7字符串 3.3.2赋值 程序中有两处赋值操作，第一处将全局变量sleepsecs赋值为2，第二处使用movl指令将局部变量i赋值为0.如图所示。 图3.8赋值 3.3.3类型转换 程序中涉及到隐式类型转换。全局变量sleepsecs定义为int类型，但在程序最开始处被赋值为2.5，即float类型。编译器将2.5隐式地转换成2存入sleepsecs中。如图所示。 图3.9类型转换 3.3.4算术操作 在循环体中，每次循环后都会执行i++操作，其被编译器处理的结果如下图所示，使用addl指令使i每次都加上立即数1. 图3.10算术操作 3.3.5关系操作 1.程序中涉及到的第一个关系操作是argc!=3，其被编译的结果如图所示，比较argc与立即数3是否相等，若相等则跳转到.L2。cmpl的指令还会设置条件码，根据条件码来判断是否需要跳转到分支中。 图3.11 关系操作1 2.第二个关系操作是i<10，其被编译的结果如图所示，判断i是否小于等于9，若是则跳转到.L4。 图3.12关系操作2 3.3.6数组操作 程序中包函数组char*argv[]，其数组中的每一个元素均为字符类型的指针。如图所示，其被存放在%rbp-32位置处。 图3.13数组的存放位置 当后续程序中调用printf函数输出argv[1]、argv[2]的值时，需要通过对数组的首地址加上相应的偏移量得到相应的数组元素的地址，然后通过movq指令即可得到数组元素的值。如图所示。 图3.14数组操作 3.3.7控制转移 汇编语言中首先设置条件码，然后根据条件码来进行控制转移。第一处控制转移为if(argc!=3)，其判断i是否等于3，如果i等于3，则不执行if语句，否则执行if语句。此部分被编译为cmpl和je条件跳转指令。如图所示。 图3.15控制转移1 第二处控制转移为for(i=0;i<10;i++)循环。通过每次判断i是否满足小于10来判断是否需要跳转至循环语句中。此部分被编译为cmpl和jle条件跳转指令。如图所示。 图3.16控制转移2 3.3.8函数操作 1.参数传递 该程序向main函数传递了两个参数，分别为intargc,char*argv[]，这两个参数在最开始分别被存放在了寄存器%edi、%rsi中。如图所示。 图3.17参数传递1 此外，执行循环中的printf函数时同样传递了两个参数argv[1]、argv[2]，这两个参数被作为参数传递的过程如图所示。 图3.18参数传递2 循环中还调用了sleep函数，并将sleepsecs作为参数传递进去，其传递过程如图所示。 图3.19参数传递3 从以上的传递过程中可以看出，要传递的参数都会存放在寄存器中，大多数情况下，第一个参数存放在%rdi中，第二个参数存放在%rsi中，第三个参数存放在%rdx中，第四个参数存放在%rcx中，以此类推。 2.函数调用 大多数情况下，调用函数时只需使用call指令进行调用即可。例如本程序中，调用printf、sleep和getchar函数的过程如图所示。 图3.20函数调用 3.函数返回 大多数情况下，函数的返回值都保存在寄存器%rax中，在本例中，函数的返回过程如图所示。 图3.21函数返回 3.4本章小结 本章主要讲述了编译的概念与作用，并解析了编译器将预处理文本文件hello.i翻译为文本文件hello.s的过程中如何处理各种数据和操作以及c语言中各种数据类型和操作所对应的的汇编代码。 第4章汇编 4.1汇编的概念与作用 汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含程序的指令编码。 4.2在Ubuntu下汇编的命令 命令：gcc-m64-no-pie-fno-PIChello.s-c-ohello.o 图4.1Ubuntu下汇编的命令 4.3可重定位目标elf格式 使用readelf-ahello.o>hellooelf.txt命令获得hello.o的elf文件并重定向到hellooelf.txt.下面对elf文件的各个部分进行分析。 1.elf头 elf头以16字节的序列Magic开始，该字节序列描述了生成该文件的系统的字的大小和字节顺序。elf头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括elf头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量等信息。不同节的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定大小的条目。 根据该elf头的信息，可知该文件类型为可重定位目标文件，且一共包含14个节。 图4.2elf头 2.节头部表 节头部表描述目标文件的节，包括节的类型、位置和大小等信息。由于该文件为可重定位目标文件，所以每个节都从0开始，用于重定位。在文件中得到节头部表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小。同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。 图4.3节头部表 3.重定位节 重定位节是一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。 重定位节中包含以下的几项信息： Offset（偏移量）：需要被修改的引用节的偏移。 Info（信息）：包括symbol和type两个部分，symbol在前面四个字节，type在后面四个字节。其中symbol标识被修改引用应该指向的符号，type告知链接器如何修改新的引用。 Type（类型）：重定位的类型。elf定义了32种不同类型的重定位类型，这里只关注其中两种最基本的重定位类型。R_X86_64_PC32为重定位一个使用32位PC相对地址的引用。R_X86_64_32为重定位一个使用32位绝对地址的引用。 Sys.Name（符号名称）：重定向到的目标的名称。 Addend（加数）：一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。 图4.4重定位节 4.符号表 符号表存放程序中定义和引用的函数和全局变量的信息。其中不包含局部变量的条目。 符号表中包含以下的几项信息： Value：符号相对于目标节的起始位置的偏移量，对于可执行目标文件，该值是一个绝对运行的地址。 Size：目标的大小。 Type：指明符号的种类。可以是数据、函数、文件、节或者NOTYPE的一种。 Bind：表明符号是本地的还是全局的。 Name：符号名称。 图4.5符号表 4.4Hello.o的结果解析 执行命令objdump-d-rhello.o后得到的结果如下图所示。 图4.6hello.o的反汇编 将其与hello.s进行比较可知，其余汇编语言的指令并没有什么不同，反汇编代码中包含机器代码。机器语言是用二进制表示的语言，也是机器能够真正识别的语言，机器指令由操作码和操作数构成。每一条汇编语言中的指令都可以对应于唯一的一个二进制数据表示，而汇编语言的操作数本身也可以表示为二进制数据，故每一条汇编语言的指令，即操作码+操作数都可以与机器指令建立一一对应的映射关系。从而能够通过这种映射关系将机器指令反汇编为我们更熟悉的、更接近CPU的动作和运行原理的汇编语言。 但同时机器语言中的操作数与汇编语言有时会出现不一致的现象，主要体现在以下两种情况时： 分支转移 反汇编的分支转移指令中的操作数用的并不是段的名称，如.L2、.L3等，而是用的确定的地址，如2d<main+0x2d>、6f<main+0x6f>等。段的名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后是不存在的，故必须使用确定的地址。 函数调用 在汇编语言中，函数调用的指令中使用的是函数名称，而在反汇编中，call指令后面的地址为call指令之后的一条指令的地址。因为hello.c中调用的函数都是共享库中的函数，故需要通过等待调用动态的链接把重定位的函数目标地址链接到共享库程序当中，最终需要通过动态链接器才能确定函数的运行时地址。在汇编成为机器语言时，对于这些不确定地址的函数调用，直接将其call指令后的相对地址设置为0，则目标地址正是下一条指令的地址，然后在.rela.text节中为其添加重定位条目，等待链接的进一步确定。 4.5本章小结 本章主要介绍了汇编的概念和作用，分析了可重定位目标elf格式中的elf头、节头部表、重定位节和符号表，同时解析了将hello.s汇编后生成的hello.o的结果并分析了汇编语言与机器语言之间的关系。 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载(复制)到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器的程序自动执行的。 hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，这个文件必须以某种方式合并到hello.o程序中。链接器就负责处理这种合并。结果得到hello文件，它是一个可执行目标文件，可以被加载到内存中由系统执行。 5.2在Ubuntu下链接的命令 命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1Ubuntu下链接的命令 5.3可执行目标文件hello的格式 使用readelf-ahello>helloelf.txt命令获得hello的elf文件并重定向到helloelf.txt.下面对elf文件的各个部分进行分析。 1.elf头 elf头的部分信息与hello.o的elf文件的elf头相同，其他信息均不同。例如，文件类型不同。hello.o文件为可重定位目标文件，而hello为可执行文件。hello.o的入口点地址、程序头起点、程序头大小和程序头数量均为0，而hello的均不为0。二者节头的起点不同。且hello一共包含27个节。 图5.2elf头 2.节头部表 节头部表中包含了hello中所有的节的信息，其中包括名称、类型、大小、地址和偏移量等信息，其中地址是程序被载入到虚拟地址的起始地址，偏移量是各个节在程序中的偏移量。根据节头部表的信息可以使用HexEdit定位各个节的起始位置及大小。 图5.3节头部表 3.程序头部表 elf可执行文件被设计的很容易加载到内存，可执行文件的连续的片被映射到连续的内存段，程序头部表描述了这种映射关系。程序头部表中包括各个程序头的偏移量、内存地址、对其要求、目标文件和内存中的段大小以及运行时访问权限等信息。 图5.4程序头部表 4.段节 图5.5段节 5.动态节 图5.6动态节 6.重定位节 重定位节包含了.text节中一些需要对目标进行重定位的函数信息,当链接器把函数的目标位置文件和其他目标文件组合在一起的时候,需要修改这些函数的位置。下图描述了程序中需要重定位的链接器函数的相关信息。 图5.7重定位节 7.动态符号表 用来保存与动态链接相关的导入导出符号，不包括模块内部的符号。 图5.8动态符号表 8.符号表 符号表存放程序中定义和引用的函数和全局变量的信息。符号表的索引就是这个数组的下标。 图5.9符号表 5.4hello的虚拟地址空间 用edb打开hello，查看memoryregions可知，hello的虚拟地址空间开始于0x400000，结束于0x405000.如图所示。 图5.10hello的虚拟地址空间 根据5.3节中的节头部表，即可通过edb找到各个节的信息。例如，.text节的地址为0x4010d0，大小为0x135，用edb查找后如下图所示。 图5.11.text节 .data节的地址为0x404040，大小为0x8，用edb查找后如下图所示。 图5.12.data节 .rodata节的地址为0x402000，大小为0x2f，用edb查找后如下图所示。其他的节查找也是如此。 图5.13.rodata节 此外，还可以根据5.3节中的程序头部表通过edb查询各程序头的信息。其中，程序头部的类型包含以下几种： PHDR：保存了二进制的程序头表。 INTERP：指定在程序已经从可执行文件映射到具体的内存区域之后，必须进程调用的解释器（如动态链接器）。 LOAD：表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据、程序的目标代码等 DYNAMIC：保存了由动态链接器使用的信息。 NOTE：保存辅助信息。 GNU_STACK：权限标志，标志栈是否是可执行的 GNU_RELRO：这个节中指定了在重定位程序结束之后那些映射到内存的区域是需要重新设置为只读类型的。 用edb的datadump即可查询各个程序头部的信息，例如类型为INTERP的程序头，其虚拟地址为0x4002e0，内存大小为0x1c，用edb查找后如下图所示。 图5.14INTERP程序头 其他的程序头部查找也是如此。 5.5链接的重定位过程分析 使用命令：objdump-d-rhello>helloobjdump.txt,获得hello的反汇编代码。通过比较hello与hello.o的反汇编代码可知，hello的反汇编代码有确定的虚拟地址，也就是已经完成了重定位,而hello.o的反汇编代码中代码的虚拟地址均为0，未完成可重定位的过程。如下面的两张图所示，可以比较出二者的差别。 图5.15hello的反汇编中的main函数 图5.16hello.o的反汇编 此外，hello的反汇编代码中多了很多节以及很多函数的汇编代码，如图所示。 图5.17hello的反汇编中除main函数外的内容 这些节都具有一定的功能和含义，例如，.init节为程序初始化需要执行的代码，.plt节为动态链接过程链接表，.fini节为当程序正常终止时需要执行的代码等。 故经过以上分析可知，链接的过程就是将多个可重定位目标文件合并在一起，生成一个可执行文件。在这个过程中，需要进行符号解析、重定位以及计算符号引用地址这三个步骤，最后便完成了链接。 下面对hello的重定位过程进行分析。 一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成： 1.重定位节和符号定义：链接器将所有类型相同的节合并为同一类型的新的聚合节。然后链接器将运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。 2.重定位节中的符号引用：这一步中，链接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构。当汇编器遇到对最终位置未知的目标引用时，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。其中，.rel.text节的内容以及每个符号的含义在4.3节中已经详细介绍过，这里不再赘述，直接给出如下的重定位算法。 首先，ELF重定位条目格式如下： 图5.18elf重定位条目格式 下面给出两种不同重定位类型的重定位算法： 图5.19两种重定位算法 5.6hello的执行流程 hello的执行过程中调用与跳转的各个程序的先后顺序如下表所示： ld-2.31.so!_dl_startld-2.31.so!_dl_inithello!_startld-2.31.so!_libc_start_mainld-2.31.so!_cxa_atexitld-2.31.so!_libc_csu.initld-2.31.so!_setjmphello!mainld-2.31.so!exit 5.7Hello的动态链接分析 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时，还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。 假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是PIC，因为他需要链接器修改调用模块的代码段，GNU编译系统使用延迟绑定技术,将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的。这两个数据结构是GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。 PLT（过程链接表）是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。PLT[1]调用系统函数（__libc_start_main），它初始化执行环境，调用main函数并处理其返回值。从PLT[2]开始的条目调用用户代码调用的函数。GOT（全局偏移量表）是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 根据hello的elf文件，GOT起始表的位置为0x404000。使用edb查看可知，在调用dl_init之前，GOT表位置在0x404008后的16个字节均为0，如图所示。 图5.20调用dl_init前GOT表中的内容 在调用dl_init之后，0x404008后的16个字节发生变化，如图所示。 图5.21调用dl_init后GOT表中的内容 其中，0x403e50和0x7f81f6c3b190包含动态链接器在解析函数地址时会使用的信息，0x7f81f6c24bb0是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数。 在调用puts函数前，每个GOT条目指向其对应的PLT条目的第二条指令，如图为puts@plt的地址。 图5.22puts@plt函数的地址 调用puts函数前，即链接前如下图所示： 图5.23调用puts函数前的内容 可以看出其对应GOT条目初始时指向其PLT条目的第二条指令的地址。puts函数执行后的变化如下： 图5.24调用puts函数后的内容 可以看出其已经动态链接，GOT条目已经改变。 5.8本章小结 本章主要介绍了链接的概念与作用，分析了可执行目标文件hello的格式、hello的虚拟地址空间、链接的重定位过程，并对hello的执行过程和动态链接的过程进行了详细的分析与说明，至此，可执行目标文件hello已经生成了。 第6章hello进程管理 6.1进程的概念与作用 1.进程的概念： 进程就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 2.进程的作用： 进程提供给我们一些假象。在现代系统上运行一个程序时，好像我们的程序是系统中当前运行的唯一的程序一样，我们的程序好像独占地使用处理器和内存，处理器好像无间断地一条接一条地执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 1.作用：shell是一个交互型应用级程序，代表用户运行其他程序。是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。shell也是一个程序，它由输入设备读取命令，再将其转为计算机可以了解的机械码，然后执行它。shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。 2.处理流程： (1)终端进程读取用户由键盘输入的命令行。 (2)将输入的命令行字符串切分，获取命令行参数，并构造传递给execve的argv向量。 (3)检查第一个命令行参数是否是一个内置的shell命令 (4)如果是内置命令则立即执行；如果不是内部命令，调用fork创建子进程。 (5)在子进程中，用获取的命令行参数调用execve执行指定程序。 (6)如果命令末尾没有&号，则说明进程要前台运行，shell使用waitpid等待作业终止后返回。 (7)如果命令末尾有&号，则说明进程要后台运行，shell直接返回。 6.3Hello的fork进程创建过程 以hello为例，当输入./hello1190200109刘文卓时，shell会对输入的命令行进行解析，由于输入的不是内置命令，故shell会调用fork创建一个新运行的子进程。子进程得到与父进程用户级虚拟地址空间相同但是独立的一个副本，包括代码段、段、数据段、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，父进程和新创建的子进程之间最大的区别在于他们有不同的PID。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。 6.4Hello的execve过程 当创建了一个新运行的子进程后，子进程调用execve函数在当前子进程的上下文中加载并运行hello程序。execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到hello，execve才会返回到调用程序。所以execve调用一次并从不返回。 execve函数在当前子进程的上下文中加载并运行新程序hello，这个程序覆盖当前正在执行的进程的地址空间，但并没有创建一个新的进程，新的程序有和原先进程相同的PID，并且继承了调用execve函数时已经打开的所有文件描述符。新的栈和堆段都会被初始化为零，新的代码和数据段被初始化为可执行文件中的内容。只有一些调用程序头部的信息才可能会在加载的过程中被从可执行磁盘复制到对应的可执行区域的内存。 6.5Hello的进程执行 进程提供给应用程序两个关键的抽象： 1.一个独立的逻辑控制流，它提供一个假象，好像我们的进程独占的使用处理器。 2.一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用内存系统。 下面对这些抽象进行详细的阐述。 逻辑控制流：即使系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做逻辑控制流。 并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流。这两个流被称为并发的运行。多个流并发的执行的一般现象被称为并发。 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 私有地址空间：进程为每个流都提供一种假象，好像它是独占的使用系统地址空间。进程为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。 用户模式和内核模式：为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常是用一个寄存器中的一个模式位来提供这种功能的，该寄存器描述了进程当前享有的特权。当没有设置模式位时，进程就运行在用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；当设置了模式位时，进程运行在内核模式中，该进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。 上下文：上下文就是内核重新启动一个被抢占的进程所需的状态，它由通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值组成。 上下文切换：当内核选择一个新的进程运行时，则内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。上下文切换保存当前进程的上下文，恢复某个先前被抢占的进程被保存的上下文，将控制传递给这个新恢复的进程。 在hello进程执行时，进程调用execve函数，进程为hello程序分配新的虚拟的地址空间，并将hello的.text和.data节分配为虚拟地址空间的代码区和数据区。当输入./hello1190200109刘文卓并执行后，hello运行在用户模式下，输出Hello1190200109刘文卓，然后hello调用sleep函数，进程陷入内核模式。内核不会等待sleep函数调用结束，而是处理休眠请求并主动释放当前进程，将hello进程从运行队列中移出并加入等待队列，定时器开始计时，内核进行上下文切换将当前进程的控制权交给其他进程并回到用户模式下。当定时器到时后会发送一个中断信号，此时又会进入内核模式执行中断处理，将hello进程从等待队列中移出并重新加入到运行队列，成为就绪状态，这时再次回到用户模式下，hello进程继续执行自己的控制逻辑流。 在hello调用getchar函数时，执行过程和上述过程类似。在进行read调用之后从用户模式转到内核模式，内核中的处理程序请求来自键盘缓冲区的传输，并且安排在完成传输后中断处理器。内核执行上下文切换，切换到其他进程。当完成键盘缓冲区到内存的数据传输时，引发一个中断信号，此时内核从其他进程进行上下文切换回hello进程。 6.6hello的异常与信号处理 hello执行过程中可能会出现以下异常： 1.中断：即来自I/O设备的信号。在hello程序执行的过程中可能会出现外部I/O设备引起的异常。 2.陷阱：即有意的异常。hello执行sleep函数时会出现这个异常。 3.故障：即潜在可恢复的错误。在hello执行过程中可能会发生缺页故障。 4.终止：即不可恢复的错误。在hello执行过程中可能会出现DRAM或SRAM位损坏的奇偶错误。 当hello执行过程中发生缺页故障时，操作系统会发送SIGSEGV信号给用户进程，用户进程会以段错误退出。当hello执行过程中传入main函数的参数个数不为3时，hello进程会以1退出并终止，这时会向父进程发送SIGCHLD信号，父进程捕获这个信号并忽略它。 hello正常执行的结果是，当一开始输入的命令行为./hello1190200109刘文卓时，程序会输出10行Hello1190200109刘文卓，并在最后用户输入一个字符串，程序读入这个字符串然后结束。如图所示。 图6.1正常运行的程序结果 在hello运行过程中，从键盘的输入和操作也会导致一些异常。具体情况如下： 当用户按下Ctrl-C时，会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况是终止前台作业，即终止hello进程。此时用ps查看前台进程组发现没有hello进程。如图所示。 图6.2按下Ctrl-C的程序结果 当用户按下Ctrl-Z时，默认结果是挂起前台的作业，即hello进程并没有回收，而是运行在后台下，用ps命令可以看到hello进程。如图所示。 图6.3按下Ctrl-Z后输入命令ps的结果 此时，输入jobs命令进行查看，可知hello的后台作业号为1。 图6.4输入命令jobs的结果 使用fg1命令即可将hello调为前台进程，shell会先打印命令行，然后继续运行并打印剩下的8个字符串，最后输入字符串后程序结束，hello进程将被回收。如图所示。 图6.5输入命令fg1的结果 当用户按下回车时，程序会继续执行，回车会被缓存到stdin，当程序运行到调用getchar函数时，回车会被当做一个字符串的结尾并将其当做空字符串读入，程序正常终止结束并被回收。如图所示。 图6.6按下回车后的结果 当用户随便乱按时，与上一种情况类似，输入的字符都会被缓存到stdin，当程序运行到调用getchar函数时会被当做字符串读入并寻找一个输入的回车作为字符串结尾，然后程序正常终止结束并被回收。多余的字符串会被当做shell的命令行输入。如图所示。 图6.7随便乱按后的结果 6.7本章小结 本章主要介绍了进程的概念与作用，简述了shell的作用与处理流程，并详细地分析了hello的fork进程创建过程、execve过程以及hello进程的执行过程，并在最后举例总结了hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址： 工具书中，逻辑地址的概念如下： 在有地址变换功能的计算机中,访问指令给出的地址(操作数)叫逻辑地址,也叫相对地址。把用户程序中使用的地址称为相对地址即逻辑地址。逻辑地址由两个16位的地址分量构成，一个为段基值，另一个为偏移量。两个分量均为无符号数编码。 学术文献中，逻辑地址的概念如下： 存储单元的地址可以用段基址(段地址)和段内偏移量(偏移地址)来表示,段基址确定它所在的段居于整个存储空间的位置,偏移量确定它在段内的位置,这种地址表示方式称为逻辑地址,通常表示为段地址:偏移地址的形式。所谓逻辑地址是指按数据的逻辑块号给出的磁盘的位置（l块=512字l字=64位）。 线性地址（虚拟地址）： 线性地址（LinearAddress）是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。线性地址是一个32位无符号整数，可以用来表示高达4GB的地址，也就是，高达4294967296个内存单元。线性地址通常用十六进制数字表示，值的范围从0x00000000到0xffffffff。程序代码会产生逻辑地址，通过逻辑地址变换就可以生成一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换以产生一个物理地址。当采用4KB分页大小的时候，线性地址的高10位为页目录项在页目录表中的编号，中间10位为页表中的页号，其低12位则为偏移地址。如果是使用4MB分页机制，则高10位页号，低22位为偏移地址。如果没有启用分页机制，那么线性地址直接就是物理地址。 物理地址： 在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址（PhysicalAddress），又叫实际地址或绝对地址。地址从0开始编号，顺序地每次加1，因此存储器的物理地址空间是呈线性增长的。它是用二进制数来表示的，是无符号整数，书写格式为十六进制数。它是出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。 在计算机科学中，物理地址（英语：physicaladdress），也叫实地址（realaddress）、二进制地址（binaryaddress），它是在地址总线上，以电子形式存在的，使得数据总线可以访问主存的某个特定存储单元的内存地址。在和虚拟内存的计算机中，物理地址这个术语多用于区分虚拟地址。尤其是在使用内存管理单元（MMU）转换内存地址的计算机中，虚拟和物理地址分别指在经MMU转换之前和之后的地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部分组成，段标识符：段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节。索引号，是“段描述符(segmentdescriptor)”的索引，段描述符具体地址描述了一个段（对于“段”这个字眼的理解:我们可以理解为把虚拟内存分为一个一个的段。比如一个存储器有1024个字节，可以把它分成4段，每段有256个字节）。这样，很多个段描述符，就组了一个数组，叫“段描述符表”，这样，可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符，这个描述符就描述了一个段，每一个段描述符由8个字节组成，如图所示。 图7.1段描述符 这些东西很复杂，虽然可以利用一个数据结构来定义它，不过，这里只关心Base字段，它描述了一个段的开始位置的线性地址。Intel设计的本意是，一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。那究竟什么时候该用GDT，什么时候该用LDT呢？这是由段选择符中的T1字段表示的，=0，表示用GDT，=1表示用LDT。GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。如图所示。 图7.2GDT与LDT 首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]， 1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。 2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，得到Base，即基地址就知道了。 3、把Base+offset，就是要转换的线性地址了。 7.3Hello的线性地址到物理地址的变换-页式管理 线性地址到物理地址之间的转换通过分页机制完成。具体变换过程如下。 使用虚拟寻址，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址被送到内存之前首先转换为适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。就像异常处理一样，地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做内存管理单元(MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该标的内容由操作系统管理。 虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上的数组的内容被缓存在主存中。磁盘上的数据被分割成块，这些块作为磁盘和主存之间的传输单元。虚拟内存系统通过将虚拟内存分割为被称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P=2^p字节。类似地，物理内存被分割为物理页，大小也为P字节。物理页也被称为页帧。 任意时刻虚拟页都被分为三个不相交的子集： 未分配的：VM系统还未分配的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。 缓存的：当前已经缓存在物理内存的已分配页。 未缓存的：未缓存在物理内存的已分配页。 每次地址翻译硬件将虚拟地址转换为物理地址时，都会读取页表来判断一个虚拟页是否缓存在DRAM的某个地方。如果是，系统即可确定这个虚拟页存放在哪个物理页中。如果不命中，系统判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。页表就是一个页表条目的数组，每一个页表条目是由一个有效位和一个n位地址字段组成的。有效位表明虚拟页是否缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟内存页在磁盘上的起始位置。 图7.3页表 形式上来说，地址翻译是一个N元素的虚拟地址空间中的元素和一个M元素的物理地址空间中元素之间的映射。如图所示。CPU中的一个控制寄存器，页表基址寄存器指向当前页表。n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移(VPO),一个n-p位的虚拟页号(VPN)，MMU利用VPN选择适当的PTE，例如VPN0选择PTE0，VPN1选择PTE1，以此类推。根据PTE，我们知道虚拟页的信息，如果虚拟页是已缓存的，那直接将页表条目的物理页号和虚拟地址的VPO串联起来就得到一个相应的物理地址。这里的VPO和PPO（物理页面偏移）是相同的。如果虚拟页是未缓存的，会触发一个缺页故障。调用一个缺页处理子程序将磁盘的虚拟页加载到内存中，然后再执行这个导致缺页的指令。 图7.4地址翻译 下图为页面命中时，CPU硬件执行的步骤。 图7.5页面命中时CPU执行的步骤 下图为缺页时，CPU硬件执行的步骤。 图7.6缺页时CPU执行的步骤 7.4TLB与四级页表支持下的VA到PA的变换 这里以一个运行Linux的IntelCorei7为例。Corei7支持实现48位的虚拟地址空间和52位的物理地址空间。页大小为4KB，支持4级页表，页表大小为4KB，CR3指向第一级页表的起始位置，TLB为4路16组相联。其中，第一、二、三级页表中条目的格式如图所示。当P=1时，地址字段包含一个40位物理页号（PPN），它指向适当的页表的开始处。这强加了一个要求，要求物理页表4KB对齐。 图7.7第一、二、三级页表条目格式 下图为第四级页表中条目的格式。当P=1，地址字段包括一个40位PPN，它指向物理内存中某一页的基地址。这又强加了一个要求，要求物理页面4KB对齐。 图7.8第四级页表条目格式 下面再简单介绍一下利用TLB加速地址翻译的过程。 TLB（翻译后备缓冲器）是一个在MMU中的关于PTE的小的缓存，是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相连度。如图所示。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有T=2^t个组，那么TLB索引（TLBI）是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。 图7.9虚拟地址中用以访问TLB的组成部分 下图展示了TLB命中时（通常情况）所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。 第1步：CPU产生一个虚拟地址。 第2步和第3步：MMU从TLB中取出相应的PTE。 第4步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。 第5步：高速缓存/主存将所请求的数据字返回给CPU。 当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，如图所示，新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。 图7.10TLB命中与不命中的操作 有了以上关于TLB和多级页表的介绍，下面就可以分析他们相结合时从虚拟地址到物理地址的翻译过程。 由于一个页表大小为4KB，一个PTE条目大小为8B，故一个页表中共有512个PTE条目，故使用9位二进制索引，4个页表共使用36位二进制索引。由于页的大小为4KB，故VPO应为12位。由于整个的虚拟地址为48位，故前36位正好为VPN，即四级页表的索引，后12位为虚拟页面偏移量。由于TLB共16组，故TLBI为4位，TLBT为32位。 当CPU产生一个虚拟地址时，将虚拟地址传送给MMU，MMU根据4位TLBI找到相应的组索引，再根据TLBT进行标记匹配，如果TLB命中，则将得到的物理页号与VPO连接起来得到一个52位的物理地址。如果TLB未命中，则MMU向页表中进行查询，CR3确定第一级页表的起始地址，然后根据4个9位的二进制索引，将36位的VPN从高位到低位分为4个9位的VPN1、VPN2、VPN3、VPN4.VPN1提供一个在第一级页表中的偏移量，根据这个偏移量得到的PTE包含第二级页表的基地址，然后VPN2提供一个在第二级页表中的偏移量，根据这个偏移量得到的PTE包含第三级页表的基地址，以此类推。最终在第四级页表中查询到PPN，与VPO组合成PA，并且向TLB中添加条目，至此，便完成了将虚拟地址翻译成物理地址的过程。如图所示。 图7.11VA到PA地址翻译过程 7.5三级Cache支持下的物理内存访问 首先对通用的高速缓存存储器组织结构进行介绍。每个存储器地址有m位，形成M=2^m个不同的地址。这样一个机器的高速缓存被组织为一个有S=2^s个高速缓存组的数组。每个组包含E个高速缓存行，每个行是由一个B=2^b字节的数据块组成的，一个有效位指明这个行是否包含有意义的信息，还有t=m-(b+s)个标记位，他们唯一地标识存储在这个高速缓存行中的块。高速缓存的大小C是指所有块的大小的和，C=S×E×B。具体结构如图所示。 图7.12高速缓存的结构 参数S和B将m个地址位分为了三个字段，如图所示。s个组索引位是一个到S个组的数组的索引，第一个组是组0，第二个组是组1，以此类推。组索引位被解释为一个无符号整数，它告诉我们这个字必须存储在哪个组中。一旦我们知道了这个字必须存储在哪个组中，t个标记位就告诉我们这个组中的哪一行包含这个字（如果有的话）。当且仅设置了有效位并且该行的标记位与地址中的标记位相匹配时，最终的这一行才包含这个字。一旦我们在组索引标识的组中定位了由标号所标识的行，那么b个块偏移位给出了在B个字节的数据块中的字偏移。 图7.13物理地址被划分的字段 一条加载指令指示CPU从主存地址A中读一个字时，它将地址A发送到高速缓存。如果高速缓存正保存着地址A出的那个字的副本，它就立即将那个字发回给CPU。如果缓存不命中，则从下一层高速缓存或主存中取出包含那个字的块，如果缓存已满，则可能会覆盖现存的一个块。 下面对L1cache的物理内存访问过程进行分析。由于L1cache共64组，每组8行，故每个块的大小为64字节。由此可知块偏移位b为6，组索引位s为6，标记位共40位。 CPU将地址A发送到L1cache。组选择取出地址中的组索引位，将二进制组索引转化为一个无符号整数，并找到相应的组。行匹配将地址A中的标记位与组中的每一行的标记位进行匹配。当某一行的标记位匹配，且有效位为1时，高速缓存L1命中。高速缓存命中后，根据地址A中的块偏移找到要获取的字的位置，将这个字取出并返回给CPU。若高速缓存L1不命中，则需要从L2中取出这个字，从L2中取出这个字的过程与L1相同，这里不再展开。取出后将新的块存储在组索引位指示的组中的某个高速缓存行中。一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，则产生冲突，采用最近最少使用策略LFU算法进行替换。 整个过程如下图所示。 图7.14物理内存访问过程 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建当前进程的mm_struct、区域结构和页表的原样副本。将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1.删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2.映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆区域也是请求二进制零的，初始长度为零。 3.映射共享区域。hello程序与共享对象或目标链接，比如libc.so。这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC）。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障：当指令引用一个相应的虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，会触发缺页故障。通过查询页表PTE可以知道虚拟页在磁盘的位置。缺页处理程序从磁盘加载适当的页面到物理内存中，并更新PTE。然后将控制返回给引起缺页故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，指令就可以没有故障的运行完成。具体的过程如图所示，唯一的不同在于缺页故障处理程序在运行结束后会重新执行当前指令，而不是终止。 图7.15缺页故障处理过程 缺页处理程序的具体处理过程如下图所示。 第1步:CPU生成一个虚拟地址,并把它传送给MMU。 第2步:地址管理单元生成PTE地址,并从高速缓存/主存请求得到它。 第3步:高速缓存/主存向MMU返回PTE。 第4步:PTE中的有效位是零,所以MMU触发了一次异常,传递CPU中的控制到操作系统内核中的缺页异常处理程序。 第5步:缺页处理程序确定出物理内存中的牺牲页,如果这个页面已经被修改了,则把它换出到磁盘。 第6步:缺页处理程序页面调入新的页面,并更新内存中的PTE。 第7步:缺页处理程序返回到原来的进程,再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中,所以就会命中,主存将所请求的字返回给处理器。 图7.16缺页处理程序的处理过程 7.9动态存储分配管理 1.动态内存分配器的基本原理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 图7.17堆 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格，两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器：要求应用显式地释放任何已分配的块。例如，c标准库提供一种叫做malloc程序包的显式分配器。c程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。c++中的new和delete操作符与c中的malloc和free相当。 隐式分配器：另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集，例如Lisp,ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 2.带边界标签的隐式空闲链表分配器原理 任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。大多数分配器将这些信息嵌入块本身。一个简单的方法如图所示。 图7.18一个简单的堆块格式 在这种情况中，一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是零。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。 头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。 假设块的格式如上图所示，我们可以将堆组织为一个连续的已分配块和空闲块的序列。如下图所示。 图7.19隐式空闲链表 我们称这种结构称为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。注意，我们需要某种特殊标记的结束块，在这个示例中，就是一个设置了已分配位而大小为零的终止头部。 (1)放置已分配的块 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略确定的。一些常见的策略是首次适配、下一次适配和最佳适配。 (2)分割空闲块 一旦分配器找到一个匹配的空闲块，它就必须做另一个策略决定，那就是分配这个空闲块多少空间。一个选择是用整个空闲块。虽然这种方式简单而快捷，但是主要的缺点就是它会造成内部碎片。如果放置策略趋向于产生好的匹配，那么额外的内部碎片也是可以接受的。 然而，如果匹配不太好，那么分配器通常会选择将这个空闲块分割为两部分。第一部分变为分配块，而剩下的变成一个新的空闲块。下图展示了分配器如何分割8个字的空闲块，来满足一个应用的对堆内存3个字的请求。 图7.20分割空闲块 (3)获取额外堆内存 如果分配器不能为请求块找到合适的空闲块，一个选择是合并那些在内存中物理上相邻的空闲块来创建一些更大的空闲块。然而，如果这样还不能生成一个足够大的块，或者如果空闲块已经最大程度地合并了，那么分配器会调用sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化为一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。 (4)合并空闲块 当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些相邻的空闲块可能引起一种现象叫做假碎片，就是有许多可用的空闲块被切割成为小的、无法使用的空闲块。为了解决假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为合并。 带边界标记的合并 Knuth提出了一种聪明而通用的技术，叫做边界标记，允许在常数时间内进行对前面块的合并。这种思想如图所示，是在每个块的结尾处添加一个脚部（边界标记），其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。 图7.21边界标记的堆块格式 3.显式空间链表的基本原理 因为根据定义，程序不需要一个空闲块的主体，所以实现空闲链表数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。如图所示。 图7.22使用双向空闲链表的堆块格式 使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于空闲链表中块的排序策略。 一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 7.10本章小结 本章主要介绍了hello的存储管理，详细地讲述了hello的存储器地址空间、Intel逻辑地址到线性地址的变换过程、hello的线性地址到物理地址的变换过程以及三级Cache支持下的物理内存访问过程，分析了hello进程fork时与execve时的内存映射，说明了缺页故障与缺页中断处理过程，并在最后介绍了动态存储分配管理的方法与原理。 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m个字节的序列：B0,B1,B2……Bm。 所有的I/O设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O,这使得所有的输入和输出都能以一种统一且一致的方式来执行。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixI/O接口： 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 2.Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0），标准输出（描述符为1）和标准错误（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值。 3.改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 4.读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。 类似地，写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 5.关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： 1.intopen(char*filename,intflags,mode_tmode)：进程通过调用open函数来打开一个已存在的文件或是创建一个新文件。open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。 2.intclose(fd)：fd是需要关闭的文件的描述符，close返回操作结果。关闭一个已关闭的描述符会出错。 3.ssize_tread(intfd,void*buf,size_tn)：read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 4.ssize_twirte(intfd,constvoid*buf,size_tn)：write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 首先查看Windows系统下printf的函数体： intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 其中，va_list的定义： typedefchar*va_list 这说明它是一个字符指针。 其中的：(char*)(&fmt)+4)表示的是 中的第一个参数。 再看vsprintf，其函数体如下： intvsprintf(char*buf,constchar*fmt,va_listargs) { char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!='%'){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); } 其作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。返回的是要打印出来的字符串的长度。 然后追踪write： write: moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL write(buf,i)的作用为写操作，把buf中的i个元素的值写到终端。在write函数中，将栈中参数放入寄存器，ecx是字符个数，ebx存放第一个字符地址。其中，intINT_VECTOR_SYS_CALL表示要通过系统来调用sys_call这个函数。下面再看sys_call的实现： sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret sys_call将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。 字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。 显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 于是我们的打印字符串就显示在了屏幕上。 同理，printf函数在Linux系统下的实现也是上述这种思路，这里不再进行详细的讨论。 8.4getchar的实现分析 异步异常-键盘中断的处理：当用户按键时，键盘接口会得到一个代表该按键的键盘扫描码，同时产生一个中断请求，中断请求抢占当前进程运行键盘中断子程序，键盘中断子程序先从键盘接口取得该按键的扫描码，然后将该按键扫描码转换成ASCII码，保存到系统的键盘缓冲区之中。 getchar的源码如下： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } getchar函数落实到底层调用了系统函数read，通过系统调用read读取存储在键盘缓冲区中的ASCII码直到读到回车符然后返回整个字串，getchar进行封装，大体逻辑是读取字符串的第一个字符然后返回。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法以及UnixIO接口及其函数，并对printf函数和getchar函数的实现进行了简要的分析。 结论 hello所经历的历程如下： 程序员通过键盘输入编写出hello.c文件。hello.c经过预处理，将所有调用的外部库插入合并，生成hello.i文件。hello.i经过编译生成汇编文件hello.s。hello.s经过汇编生成可重定位目标文件hello.o。hello.o与可重定位目标文件和动态链接库链接生成可执行目标文件hello。在shell中输入./hello1190200109刘文卓shell调用fork函数创建一个子进程。新运行的子进程调用execve函数在当前子进程的上下文中加载并运行hello程序。execve函数调用启动加载器，映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数。CPU为其分配时间片，在一个时间片中，hello享有CPU资源，顺序执行自己的控制逻辑流。MMU将程序中使用的虚拟内存地址翻译成物理地址。当hello执行printf函数时会调用malloc向动态内存分配器申请堆中的内存。当hello调用sleep函数时，会陷入内核模式，处理休眠请求主动释放当前进程，内核进行上下文切换将当前进程的控制权交给其他进程。当sleep函数调用完成时，内核执行上下文切换将控制传递给当前进程。程序运行过程中，按下Ctrl+c会终止当前进程，按下Ctrl+z会停止并挂起当前进程。子进程执行完成后，内核安排父进程回收子进程，将子进程的退出状态传递给父进程。内核删除为这个进程创建的所有数据结构。 至此，hello的一生结束了。 在学习过计算机系统后，我对计算机系统的设计与实现的精妙感到十分震撼。其所有的设计思想都是建立在抽象层面上的，且计算机系统的整体设计十分完备、功能全面。即便如此，计算机系统依然会不断向前发展，期待能够在将来见识到更精细、更完美的设计与实现。 附件 文件名称文件作用hello.ihello.c经过预处理后生成的修改了的源程序hello.shello.i经过编译后生成的汇编程序hello.ohello.s经过汇编后生成的可重定位目标程序hellooelf.txt保存hello.o的elf格式的文件信息的文本文件hellooobjdump.txt保存hello.o经过反汇编后生成的内容的文本文件hellohello.o经过链接后生成的可执行目标程序helloelf.txt保存hello的elf格式的文件信息的文本文件helloobjdump.txt保存hello经过反汇编后生成的内容的文本文件 参考文献 [1] https://www.cnblogs.com/pianist/p/3315801.html [2] https://blog.csdn.net/icandoit_2014/article/details/87897495 [3] http://blog.chinaunix.net/uid-1835494-id-2831799.html [4] 深入理解计算机系统（原书第3版） 
第63篇文章[]
软件构造5 由于软件构造课程需要用到git来提交实验结果，而本人是第一次使用到git，在使用过程中遇到了许多问题，故在此记录下一些git的使用方法以及一些问题的处理。 一.仓库克隆 1.右键点击要克隆到的本地文件夹，选择gitbashhere。 2.在命令行中输入gitclone+要克隆的仓库的URL地址，回车，即可将远程的github上的仓库中的东西克隆到本地的文件夹中。 二.提交 1.右键点击要提交的文件或项目文件夹，选择gitbashhere。 2.输入gitinit命令，回车，用来在当前项目的目录中生成本地的git管理库，我们可以发现在当前目录下多了一个.git的隐藏文件夹。此步骤即为初始化本地仓库。 3.输入gitadd./gitadd*命令，回车，将项目中所有的文件添加到缓存区中。如果想添加特定文件，把.换成对应的文件名即可。 4.输入gitcommit-m"firstcommit" 命令，回车，即可将缓存区中的文件提交到本地仓库中。其中双引号中的内容为注释，可以根据个人需要进行修改。 5.如果是第一次操作，可能会出现需要输入邮箱以及名字的提示，根据提示输入完毕后，再次输入gitcommit-m"firstcommit"即可。 6.输入gitremoteaddorigin+自己的仓库URL地址，回车。即可将本地仓库连接到远程仓库，即github上的仓库。 7.输入gitpushoriginmaster，回车，将本地仓库中master分支上的内容上传到github仓库中，等待一会后看到文件上传的过程显示完成后即为提交成功。 注：在gitpush的过程中可能会弹出failedtoaccess或timedout等提示，这些提示并不是说明提交的过程出错，而是只是因为网络的问题暂时无法连接到远程仓库，遇到这些问题时可以尝试反复提交直到成功为止，或使用加速器进行提交。没有意外情况的话多尝试几次即可成功。 三.创建新分支 1.右键点击要创建新分支的文件或项目文件夹，选择gitbashhere。 2.输入gitcheckout-b+新的分支名，回车，即可创建新分支。这时可以看到文件夹后面的分支名变为了新建立的分支名。 3.然后即可依照二中的步骤在新的分支上进行添加文件到缓存区并将缓存区的文件提交到本地仓库等操作。 4.如果需要将新的分支提交到github，则需要输入gitpushorigin+新的分支名，回车，即可向上述过程那样将文件或项目提交到远程仓库。 5.如需切换回master分支，可以输入gitcheckoutmaster，回车即可。想切换到其他分支只需要输入gitcheckout+分支名即可。 注：在切换分支后，本地文件夹中文件的内容会根据分支的不同进行改变。其内容会与本地仓库中文件的内容保持同步，故在切换分支进行文件更改时需要注意。且若其中一个分支中的本地文件被修改，在切换到其他分支前需要先将修改后的内容提交，再切换分支，否则修改后的内容无法保存。 
第64篇文章[]
软件构造3 继承 继承关系可以有效地在先前定义的某个类的基础上实现其定义的所有方法功能，并添加自己的独特方法功能。继承关系不仅能够体现复用的价值，还能够使设计思路变得清晰，逻辑结构更加鲜明。同时能够减少工作量，也更容易应对新的变化。 在继承时应遵循LSP原则，final定义的类无法派生出子类，且子类应比父类具有更强的规约、更强的不变量。子类型可以增加方法，但是不能删除。子类型需要实现抽象类型中的所有未实现方法。子类型中可以重写父类型中的方法，但是需要满足子类型方法的参数满足逆变、子类型方法的返回值满足协变且子类型不能抛出比父类型更多的异常。 逆变的过程是参数不便或变得越来越抽象的过程，如从String变为Object，但是目前java中遇到这种情况只能当做overload看待。 
第65篇文章[]
软件构造2 1.静态类型语言：在编译阶段进行类型检查并发现错误，避免将错误代入运行阶段，提高了代码的正确/健壮性。 动态类型语言：在运行阶段进行类型检查。 静态检查无法检查出与变量值有关的错误。可以检查出：语法错误，类名/函数名错误，参数数目错误，参数类型错误，返回值类型错误。 动态检查能检查出：非法的参数值，非法的返回值，越界，空指针。 2.final类无法派生子类。final变量无法改变值/引用。final方法无法被子类重写。 3.不变对象：一旦被创建，始终指向同一个值/引用。可变对象：拥有方法可以修改自己的值/引用 4.不可变类型，在修改时会频繁发生拷贝。 5.可变还是不可变：（1）看方法是否改变参数（2）看return是否是mutable类型（3）保证所有属性都是private，尽量加final。有时引用不可变但是指向的值是可变的。 6.List在遍历时被修改，就会发生某些错误或抛出异常。可以用iterator自带的remove方法。如果用List.remove删除元素，那么可能会发生遍历过程中的元素经过修改后的下标与期望的下标不匹配的情况。 
第66篇文章[]
软件构造4 1.参数类型是否匹配，在静态类型检查阶段完成。返回值类型是否匹配，也在静态类型检查阶段完成。 2.精确的规约有助于划分责任，规约可以扮演防火墙的角色。只讲能做什么，不讲怎么实现。可以通过规约判断方法的等价性。 3.静态类型声明是一种规约，可据此进行静态类型检查staticchecking。 4.spec变强：更放松的前置条件+更严格的后置条件。在比较后置条件时，应该在满足对方的前置条件的情况下进行判断。一旦规约1比规约2强，那么可以用规约1替换规约2。5.抽象数据型由操作定义，与内部实现无关。 6.可变与不可变数据类型。可变数据类型：提供了可改变其内部数据的值的操作。不可变数据类型：其操作不改变内部值，而是构造新的对象。 7. 构造器：可能实现为构造函数或静态函数。构造器被实现为静态函数，通常被称为工厂方法。工厂方法用于创建对象，属于静态方法；实例方法在创建对象后才能调用函数并且工作。 生产器：新产生的数据与旧的数据类型一致。 观察器：数据类型不一致。 变值器：改变函数内部对象属性的方法。变值器通常返回void则必然意味着它改变了对象的某些内部状态。也可能返回非空类型。 8.抽象空间A：抽象值构成的空间，即client看到和使用的值。表示空间R：内部表示的值构成的空间，其中既有非法的表示值，也有合法的表示值。AF：表示空间R与抽象空间A的映射关系。一定是满射，但未必是单射，也未必是双射。即R中的非法值没有映射对象，R中的多个合法值可能映射到A中相同的值。AF应当显示的以注释的形式写在代码中，以便于理解。 9.表示独立性：不暴露内部属性与实现方法。 10.RI：一种要求，说明R中的值哪些是合法的，哪些是非法的。RI也应该显示的以注释的形式写在代码中，用于时刻提醒自己。 11.在所有可能改变rep的方法内都应该调用checkRep来检查。checkRep只是自己用于在编程时防止出错或产生非法的表示值所定义的方法。这是一个良好的编程习惯。 12.设计ADT方法：(1)选择R和A；(2)RI：合法的表示值；(3)AF：如何解释合法的表示值。 
第67篇文章[]
软件构造1 在经过一段时间的软件构造课程以及java编程的学习过后，本人总结了许多收获与先前未曾了解的知识，在此将分成几个部分进行阐述。 1.接口以及面向对象的编程 对于java语言来说，最突出的优势就在于其面向对象的编程能力。其中接口是很方便的一个工具。当接口被定义好后，后续可以有多种实现。当完成这些不同的实现后，可以根据具体的需求来使用不同的实现。这样可以很好地进行复用。在具体的需求发生变化时，也可以更加灵活地进行调整与改变，而不需要像面向过程的编程那样需要调整许多代码，且每面临一次变化都需要调整一次代码，这样的代价未免过高，也不适合进行维护。所以，接口就显示出了独特的优势。 2.测试驱动的编程 经过这一段时间的编程体会，我深刻地感受到了测试驱动的编程带来的好处。在每次编写代码的实现之前，先写好测试用例是一个非常好的习惯。测试用例不仅可以全面地测试我们的实现代码，更重要的是能够引导我们的编程思路。同时，当完成了测试用例后，在编写实现的过程中可以随时进行测试，这样便于我们随时发现并更改实现中的错误。若总是先将实现写好后再编写测试用例，则若测试用例不通过的话我们也很难找出代码中的错误，这样便会浪费大量的时间。同时，若测试用例的编写全面的话，也会使我们注意到一些我们未曾发觉的潜在的风险，或是在我们的实现中并未考虑到的情况。所以测试驱动的编程会带来许多好处。再编写测试用例时，要做到全面、精简。要划分好等价类，并用笛卡尔乘积全覆盖的方式进行编写，以保证各个情况的分类的组合都能够测试的到。同时也要注意精简，不必重复很多相似或同类的测试用例。 
第68篇文章[5]
博客开通开坑软件构造 开始学习软件构造！不定期更新代码心得。 
第69篇文章[1]
计算机系统大作业 程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P 摘要本文梳理探讨了简单的C语言程序hello，在x86/Linux系统环境下，从源代码文件开始到最终完成执行完成的简单一生。其一生高度概括了程序在计算机系统体系结构中运行的各个重要阶段，包括编译处理、进程管理、内存管理、异常控制流、硬件存储结构层次、系统IO管理等。从一个简单程序作为切入点，深入探讨hello程序的完整执行过程，可以抽丝剥茧以小知大，更好的帮助我们深入理解计算机系统的结构，抽象出软硬件体系的运行管理机制。 关键词：计算机系统；软件；硬件；Linux；x86； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介P2P：FromProgramtoProcess意即从程序到进程。Hello程序从编写阶段开始，是以C语言源代码文件Hello.c的形式存在于硬盘上的。经过预编译阶段将头部include调用文件包含到源代码中，并将源代码中的宏定义替换，形成hello.i文件。再将完整的代码交给编译器进行编译，得到hello.s的汇编文件。汇编器将汇编文件处理为二进制可重定位文件，之后再交给链接器进行链接，最终形成可执行文件hello.o。在Linux系统终端中运行可执行文件，内核使用系统调用fork为其创建一个新的进程，在该进程的上下文中使用系统调用execve执行hello.o文件，至此，hello程序以进程的形式运行在计算机中，完成了从程序到进程的转变。O2O：FromZero-0toZero-0意即在内存中从0化为0。在运行hello.o文件前，hello程序在内存中是没有任何痕迹的。当内核为运行hello程序fork出一个进程后，调用execve执行hello文件，此时内核为hello分配虚拟内存空间，删除当前虚拟内存空间中用户部分已存在的数据结构，为hello的代码段、数据、bss以及栈区域创建新的区域结构，并将hello的源代码、数据等信息复制到内存中。然后虚拟内存与磁盘对象建立映射，设置程序计数器，使之指向代码区域的入口点，程序入口后虚拟内存映射的内容开始载入物理内存。做好执行程序的准备后进入main函数，CPU为hello分配时间片，将控制交给hello进程，执行hello的程序内容。待执行完毕后，hello成为僵死进程，等待父进程的回收，回收后内核会从内存中删除hello的所有痕迹，hello在内存中重新化为0。至此hello完成了在内存中从无到有再到无的过程，即从0到0。1.2环境与工具硬件环境：X64CPU;1.8GHz;8GRAM;512GSSD软件环境：VMware15;Ubuntu20.04LTS64位开发工具：GDB;EDB;GCC;Linux内置指令 1.3中间结果 图1.3.1中间生成文件一览hello.cC语言源代码文件hello.i预处理阶段生成文件hello.s编译阶段生成文件，内容为汇编代码hello.o汇编阶段生成文件，二进制可重定位目标文件hello可执行目标文件hello.elf可重定位目标文件的ELF格式hello2.elf可执行目标文件的ELF格式hello_o_asm.txt可重定位目标文件的反汇编代码hello_asm.txt可执行目标文件的返汇编代码1.4本章小结对P2P和O2O在本文中的特殊含义进行了阐述，简要概括了hello程序的一生。本章还列出了下文中使用到的工具以及生成的文件，对下文起说明性作用。（第1章0.5分） 第2章预处理2.1预处理的概念与作用概念：在C文件编译前对源代码进行的处理，主要包括文件包含、宏定义替换、条件编译等。C文件预处理后得到后缀为.i的预处理文件。作用：在hello程序中，预处理主要体现为头文件的包含，即将程序头部使用#include指令包含的文件复制整合到源代码中，生成hello.i文件方便后续编译。但在其他C文件中预处理常常还包括宏定义替换和条件编译。宏定义替换的作用是将程序中使用#define定义的部分在源代码中进行替换。条件编译的作用是根据源代码中的条件编译命令（如#if、#ifdef）选择性的编译部分源代码，方便程序的多样性实现。2.2在Ubuntu下预处理的命令gcc-Ehello.c-ohello.i 图2.2.1预处理命令生成的预处理文件部分内容如下所示： 图2.2.2预处理文件部分内容 2.3Hello的预处理结果解析 图2.3.1预处理文件部分内容生成的预处理文件名为hello.i，该文件共3065行，与hello.c源代码相比文件内容大大增加。其文件底部为hello.c的main函数代码。上面3000余行可以看到stdio.h等标注，均为复制整合的包含的头文件，即<stdio.h><unistd.h><stdlib.h>的内容。这体现出预处理包含头文件的功能。另外注意到预处理文件不含有任何宏定义，虽然hello源代码中并无宏定义，但包含的头文件源代码中普遍存在宏定义，在预处理文件中全部得以替换，也体现出预处理的宏定义替换功能。2.4本章小结本章关注C程序的预处理阶段。阐述了预处理操作的概念和作用后，实际操作生成并查看了预处理文件，通过对比预处理文件和源代码文件，对于预处理操作的实际功能有了更为具体的认识。（第2章0.5分） 第3章编译3.1编译的概念与作用概念：编译指C语言代码转化为汇编指令的过程，具体体现为编译器将预处理文件转化为以.s为后缀的汇编文件。作用：编译器将源代码翻译为汇编指令的过程分为五个阶段：词法分析，语法分析，代码优化（中间代码生成），目标代码生成。语法语义分析阶段的主要作用是检查语法错误，并给出错误提示信息。若代码无语法错误，则进入下一阶段代码优化阶段，此阶段的主要作用是根据程序功能对代码进行等价变换，使得程序的算法实现更加高效合理，此阶段产生的优化代码称为中间代码。最后进入目标代码生成阶段，编译器将优化后的中间代码转化为目标代码，即汇编指令代码。3.2在Ubuntu下编译的命令gcc-Shello.c-ohello.s 图3.2.1编译命令生成的汇编文件部分内容如下图所示： 图3.2.2汇编文件部分内容 3.3Hello的编译结果解析3.3.1数据类型Hello中涉及到的变量有全局整型变量sleepsecs、整型变量argc、字符串数组argv、局部整型变量i。 图3.3.1汇编代码内容sleepsecs作为已初始化的只读全局变量被存放在rodata段。 图3.3.2汇编代码内容参数argc和argv分别被存放在寄存器%edi和%rsi中被传入，随后被压入栈。对argc的赋值操作使用的后缀是l，对应4字节的int类型，对argv的赋值操作后缀为q，对应8字节的字符指针类型。 图3.3.3汇编代码内容局部变量i作为循环控制变量，在汇编代码中被存放在栈中。操作后缀为l，对应4字节的int类型。 图3.3.4汇编代码内容源代码中printf函数打印的内容被当作字符串常量存储rodata段。其中第一个字符串的内容涉及到中文字符，在汇编代码中使用utf-8编码表示。其余数据以立即数的形式给出，直接编码在汇编代码中。3.3.2赋值源代码中涉及到的赋值操作为局部变量i的初始化i:=0，在汇编代码中体现为 图3.3.5汇编代码内容MovS，D操作表示将S的值传送给D。在实际应用中，mov指令跟随后缀，上述代码的后缀为l，表示执行的是4字节操作，对应i变量所属的int类型。0以立即数的形式给出，i变量存放在栈中%rbp-4所指的位置，故通过movl直接赋值即可。汇编代码中其余的赋值操作均为代码翻译时产生的操作，mov后跟随的后缀有l、q，分别代表4字节、8字节操作。操作数有立即数、寄存器、寻址形式等。3.3.3SizeofSizeof是C语言中的一个一元操作符，返回对象或类型在内存中所占的字节数。Hello程序中涉及到的变量类型有int、char*，执行sizeof操作返回值分别为4和8。3.3.4算术和逻辑操作Hello程序中涉及到的算术逻辑操作主要是加法操作，即add。汇编代码中还出现了leaq加载有效地址指令。除此之外，常用的算数逻辑操作还包括减sub、乘imul、异或xor、或or、与|、取负neg、取补not、左移sal、算术右移sar、逻辑右移shr等。操作数个数视具体操作而定。操作后同样可以添加后缀以指明数据格式。3.3.5关系操作关系操作主要包含在比较测试指令cmp、test和跳转指令中。 图3.3.6汇编代码内容源代码中涉及到的argc!=3判断和循环判断i<10均通过比较指令来设置条件码，而后使用条件跳转指令根据条件码来改变程序控制。 图3.3.7汇编代码内容CmpS1，S2基于S2-S1的值设置条件码。例如S2-S1=0时je会读取到条件码设置为相等，此时执行跳转操作，否则不执行跳转。对于jle指令，如果读取到当前条件码为小于等于那么执行跳转，否则不执行。同样对于比较测试指令可以设定后缀来指明操作的数据格式。3.3.6数组/指针操作C语言中数组往往占据一片连续的内存区域，故使用数组开头的指针即可指代整个数组。Hello程序中argv即为字符指针，它存储一个字符数组的开头地址，即可指代一个字符数组。 图3.3.8汇编代码内容汇编代码中仅将数组头指针压入栈，若想对数组执行索引取值操作，只需以头指针为基准，根据数据格式和索引设置偏移量，即可寻址取得所需的数值。 图3.3.9汇编代码内容如对argv[1]和argv[2]的寻址。栈中%rbp-32处存放数组头指针，字符指针类型占据8字节，故一位索引偏移为8，两位索引偏移为16。汇编代码中根据索引和数据格式设置偏移量后，直接使用mov操作寻址赋值即可获取所需的数值。3.3.7控制转移控制转移基于跳转指令。Hello程序中涉及的控制转移为if(argc!=3)和for循环引起的跳转，汇编代码中对应的跳转指令如下。 图3.3.10汇编代码内容上述为条件跳转指令，即指令根据条件码的设置情况有选择的进行跳转。Je表示条件码为相等时跳转，jle表示条件码为小于等于时跳转。除此之外jmp指令不依据条件码执行直接跳转操作。3.3.8函数操作函数是一种过程，假设过程P调用过程Q吗Q执行后返回到P，这些动作包含限免一个或多个机制：1.传递控制：进行过程Q的时候，程序计数器必须设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。2.传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P中返回一个值。3.分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。过程调用使用call指令。过程调用与栈结构的使用关系密切，在执行call指令前需要先传递参数，将调用返回地址压入栈中，而后设置PC将控制交给调用过程。每一层调用都有属于自己的栈帧，维护栈帧是保证调用顺利运行的关键，若栈帧遭到破坏则会导致严重的恶性错误。Hello程序中使用的调用有main函数、printf函数、exit函数、sleep函数、getchar函数。其中main函数由系统启动函数调用。每一次函数调用前都会执行传递参数，返回地址压栈，PC设置等步骤，每一层函数调用都由属于自己的栈帧。3.4本章小结本章详细分析了hello程序的汇编代码。通过分析比较汇编代码与对应源代码之间的关系和区别，了解编译的基本机制和原理，对编译过程有了深层次的理解，对程序的机器级表示有了更好的领悟。（第3章2分） 第4章汇编4.1汇编的概念与作用概念：汇编程序被翻译为机器语言指令的过程。具体表现为汇编器（as）将后缀为.s的汇编文件打包翻译成可重定位目标程序的格式，并将结果保存在.o目标文件中。.o文件是一个二进制文件，它包含程序的机器指令编码。作用：生成可重定位的目标文件。4.2在Ubuntu下汇编的命令gcc-chello.c-ohello.o 图4.2.1汇编命令生成的可重定位目标文件如下： 图4.2.2生成文件4.3可重定位目标elf格式获取ELF格式指令：readelf-ahello.o>hello.elf 图4.3.1ELF头ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小与字节顺序。ELF头剩下的部分包括ELF头的大小、目标文件的类型、机器类型（如x86-64）、节头部表的文件偏移，以及节头部表条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。 图4.3.2ELF节头部表节头部表概述了文件中出现的各个节的基本信息，包括节的名称、大小、类型、地址、偏移量等。 图4.3.4ELF重定位节Hello的重定位节包括rela.text节、rela.eh_frame节、symtab节。重定位节中各信息的表示含义如下。偏移量：需要被修改的引用的节的偏移。信息：包括symbol和type两部分，其中symbol占前4个字节，type占后4个字节，symbol代表重定位到的目标在.symtab中的偏移量，type代表重定位的类型。类型：告知链接器如何修改新的引用。两种最基本的重定位类型：R_X86_64_PC32：重定位一个使用32位PC相对地址的引用。R_X86_64_32：重定位一个使用32位PC绝对地址的引用。符号名称：重定位目标的名称。加数：一个有符号常数，一些类型的重定位要使用它对被修改引用的值做调整。rela.text节是一个text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。例如hello程序中的puts函数、exit函数、printf函数、sleep函数。这些函数均为外部调用函数。而sleepsecs为全局变量引用，其被存放在.data段，引用时的位置需要修改。Symtab节是一个符号表，它存放在程序中定义和引用的函数和全局变量信息。每个可重定位目标文件在symtab中都有一张符号表，但symtab符号表中不含局部变量的条目。Hello的symtab节中包含了程序中引用的函数如printf、exit、sleep、getchar，以及引用的全局变量sleepsecs。4.4Hello.o的结果解析在Linux终端执行objdump-d-rhello.o指令，在终端中获取hello.o的反汇编代码如下图所示。 图4.4.1反汇编代码将反汇编代码与hello.s中的汇编代码进行比较，可以得到如下差别：反汇编代码指明了每一条指令的16进制机器码以及所处的地址。反汇编代码中操作数均为16进制，而汇编代码中为10进制。反汇编代码中部分指令省略了后缀的数据格式表示，汇编代码中均带有后缀。反汇编代码中涉及到的控制转移，如跳转操作和函数调用，其操作数均为目标指令的地址，而汇编代码中操作数是段名称或函数名称。最重要的是，反汇编代码中函数调用callq后的操作数地址指向下一条指令的地址，而不是特定函数的地址。这是因为hello中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0（目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。反汇编代码中对于全局变量的引用为%rip+0。这是因为rodata中数据地址也是在运行时确定，故访问需要重定位。所以在汇编成为机器语言时，将操作数设置为全0并添加重定位条目。综上来看，反汇编代码除在格式上与汇编文件不同外，其指令着重体现出文件的可重定位特征。4.5本章小结本章通过分析可重定位文件的ELF文件和反汇编代码内容，得到了二进制的可重定位目标文件的特征，进而理解了汇编器在程序编译处理过程中扮演的角色。可重定位文件表现的重定位特征也为接下来的链接阶段做了铺垫。（第4章1分） 第5章链接5.1链接的概念与作用概念：链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。作用：链接器使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把他分解为更小、更好管理的模块，可以独自修改和编译这些模块。当我们改变其中的一个块时，只需要简单的重新编译它，并重新链接应用，而不必重新编译其它文件。5.2在Ubuntu下链接的命令ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.2.1链接指令生成的文件如图所示： 图5.2.2链接生成文件5.3可执行目标文件hello的格式生成ELF格式指令为readelf-ahello>hello2.elf 图5.3.1ELF格式指令 图5.3.2ELF文件头可执行目标文件的ELF文件头内容如上图所示，其与可重定位目标文件的ELF头相似，除ELF文件节条目改变外，最主要的区别是可执行目标文件ELF头有了程序入口点地址，即程序运行时PC需设置的第一条指令地址。 图5.3.3ELF文件节头部表部分内容可执行目标文件的ELF格式中节头部表条目增多，对hello中所有的节信息进行了声明。各个节在内存中的虚拟地址和大小有了明确标明，可以根据虚拟地址信息定位各个节所占的区间。可执行目标文件ELF格式的明显特征是拥有了程序头，且不再有rel.text节和rel.data节，这些节中的可重定位信息已被重定位到最终的虚拟内存地址。但存在一些重定位节如.rela.plt和.rela.dyn，这些节需要之后进行动态链接。 图5.3.4ELF文件中存在的重定位节5.4hello的虚拟地址空间使用edb打开hello的可执行目标文件，如下图所示。 图5.4.1edb打开hello文件Edb左上窗口展示了汇编代码对应的16进制机器码和其所处的地址信息。 图5.4.1虚拟空间范围在DataDump窗口可以看到hello文件加载的虚拟空间范围为0x401000-0x402000. 图5.4.1edb中查看各节地址使用symbol窗口可以查看文件各节在虚拟地址空间中的地址，其地址信息与ELF格式中节头部表中的信息完全一致。5.5链接的重定位过程分析执行objdump-d-rhello指令得到hello的反汇编代码如下图所示。 图5.5.1hello的部分反汇编代码 对比第四章hello.o的反汇编代码，得到以下区别：1.在hello.o反汇编中，main函数地址从0开始，即地址指代均为相对偏移地址；而在hello中main函数0x4010c1开始，故hello已将hello.o重定位为了虚拟内存地址，2.hello可执行目标文件中增加了.init节和.plt段。.init节定义了一个_init函数，程序的初始化代码会调用它，用于初始化程序执行环境；.plt段是程序执行时的动态链接。并且所有重定位条目都被修改为了确定的运行时虚拟内存地址。3.将hello.c中用到的函数，如exit、printf、sleep、getchar等，链接到了hello中，在反汇编代码中可以看到为上述函数分配的虚拟内存空间信息。链接就是链接器ld将.o文件中的分散在外部文件中的目标函数段按照一定规则抓取组合到hello文件的过程。指定动态链接器为/lib64/ld-linux-x86-64.so.2。外部目标文件crt1.o、crti.o、crtn.o中主要定义了程序入口_start、初始化函数_init等运行程序必须的函数。ibc.so是动态链接共享库，其中定义了hello.c中用到的printf、sleep、getchar、exit函数。链接指令ld即是将上述文件和函数抓取并组合到hello文件中。重定位由两步组成：重定位节与符号定义、重定位节中的符号引用。在重定位节与符号定义这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节，而后，链接器将运行时虚拟内存地址赋值给新的聚合节、输入模块定义的每个节，以及输入模块定义的每个符号。在重定位节中的符号引用中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时虚拟地址，这一步依赖hello.o中的重定位条目。除此之外重定位类型分为两种，分别为R_X86_64_PC32与R_X886_64_32，这两种分别为PC相对寻址与绝对寻址。对于hello.o中使用PC相对寻址的指令使用R_X86_64_PC32类型进行重定位，而对hello.o直接引用地址的指令，采用R_X886_64_32类型进行重定位。5.6hello的执行流程执行过程中调用的所有函数如下：ld-2.27.so!_dl_startld-2.27.so!_dl_inithello!_startlibc-2.27.so!__libc_start_main-libc-2.27.so!__cxa_atexit-libc-2.27.so!__libc_csu_inithello!_initlibc-2.27.so!_setjmp-libc-2.27.so!_sigsetjmp-libc-2.27.so!__sigjmp_savehello!mainhello!puts@plthello!exit@plthello!printf@plthello!atoi@plthello!sleep@plthello!getchar@pltld-2.27.so!_dl_runtime_resolve_xsave-ld-2.27.so!_dl_fixup-ld-2.27.so!_dl_lookup_symbol_xlibc-2.27.so!exit5.7Hello的动态链接分析 图5.7.1dl_init之前.got.plt节的内容 图5.7.2dl_init之后.got.plt节的内容使用edb调试，DataDump窗口数据的值在运行dl_init前后发生变化。如图地址0x404000处的值改变，根据ELF文件，此处为.got.plt节。动态链接库是在进程启动时加载进来的。加载后，动态链接器需要对其作一系列的初始化，如符号重定位(动态库内以及可执行文件内)，这些工作是比较费时的，特别是对函数的重定位。因此为了节约时间对函数的重定位延迟进行，这使得我们可以对一些动态库里包含的很多全局函数之中的很小一部分我们使用到的、执行到的进行重定位。具体来说，就是应该等到第一次发生对该函数的调用时才进行符号绑定，也就是延迟绑定。延迟绑定的实现步骤有： 1.建立一个.got.plt表，该表用来放全局函数的实际地址，但最开始时，里面放的不是真实的地址而是一个跳转。2.对每一个全局函数，链接器生成一个与之相对应的影子函数。而所有对函数的调用，都换成对{（函数名）@plt}的调用。而{（函数名）@plt}的第一条指令会直接从got.plt拿真实的函数地址，如果之前已经发生过调用，got.plt就已经保存了真实的地址，如果是第一次调用，则got.plt中放的是{（函数名）@plt}中的第二条指令，这就使得当执行第一次调用时，{（函数名）@plt}中的第一条指令其实什么事也没做。继续往下执行，第二条指令的作用是把当前要调用的函数在got.plt中的编号传给_init()，而_init()将被调用函数进行重定位，然后把结果写入到got.plt相应的地方。5.8本章小结本章关注可重定位目标文件到可执行目标文件的过程。这个过程包括两个重要过程：链接、重定位。通过分析ELF文件格式、借用edb查看虚拟内存与代码间的映射关系，我们深入理解了程序链接和重定位过程中的机制和发生的变化。至此，hello程序从易于人理解的C语言代码彻底转变为了易于机器读懂的二进制文件了。（第5章1分） 第6章hello进程管理6.1进程的概念与作用概念：进程的经典定义是一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容，程序计数器、环境变量以及打开文件描述符的集合。作用：它提供一个假象，好像我们的程序是系统当前运行的唯一的程序一样。我们的程序好像是独占的使用处理器和内存。处理器好像无间断的一条接一条的执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。6.2简述壳Shell-bash的作用与处理流程Shell是一个交互型应用级程序，它代表用户运行其它程序。Shell执行一系列的读/求值步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，代表用户运行程序。处理流程：1.解析以空格分割的命令行代码，并构造最终会传递给execve的argv向量。2.解析了命令行之后，检查第一个命令行参数是否是一个内置的shell命令。如果，它立即解释该指令。3.如果不是内置指令，那么shell创建一个子进程，并在子进程中执行所请求的程序。4.如果用户要求在后台运行该程序，那么shell等待下一个命令并返回步骤1。5.如果不要求在后台运行，那么shell使用waitpid等待作业终止。待终止后，shell会等待下一个命令并返回步骤1。6.3Hello的fork进程创建过程Shell检测到命令行第一个参数不是内置指令后，通过调用fork函数创建一个新的运行的子进程来运行hello。新创建的子进程几乎但不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得父进程打开任何文件描述符相同的副本，这意味着当父进程调用fork函数时，子进程可以读写父进程中任何打开的文件。父进程与子进程之间最大的区别在于它们拥有不同的PID。 图6.3.1fork进程过程6.4Hello的execve过程 图6.4.1新程序开始时用户栈典型的组织结构Execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp。当加载器运行时，它将创建内存映像（在Linuxx86-64系统中，代码段总是从地址0x40000处开始）。而在程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据段。接下来，加载器跳转到程序的入口点，即_start函数的地址，_start函数调用系统启动函数_libc_start_main来初始化执行环境，并调用用户层的main函数，此时构造的argv向量被传递给主函数。在execve加载了hello之后，它调用启动代码设置栈，并将控制传递给新程序的主函数。主函数有以下原型：Intmain(intargc,char*argv[],char*envp[]);6.5Hello的进程执行为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常使用某个控制寄存器的一个模式位提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。内核会为每一个进程维持一个上下文，而在进程执行的某些时刻，内核可以进行调度、抢占当前进程，并重新开始一个先前被抢占了的进程。上下文切换的流程是1.保存当前进程上下文。2.恢复某个先前被抢占的进程被保存的上下文。3.将控制传递给这个新恢复的进程。 图6.5.1进程上下文切换控制传递到hello的入口处后，运行时内核为其保存一个上下文，进程在用户模式运行。如果没有异常或中断信号的产生，hello将继续正常地执行。如果遇到了异常或者中断信号，那么进程陷入内核模式，内核执行上下文切换，将控制转换到其它进程。当执行sleep函数时，hello进程将挂起指定时间，此时发生上下文切换，进程陷入内核模式，控制转移至另一个进程；当达到指定挂起时长后，再次发生上下文切换，进程陷入内核模式，将控制转移到原先挂起的hello进程。当hello循环结束后，调用getchar函数，需要键盘缓冲区DMA传输，发生异常，进程进入陷阱陷入内核，执行上下文切换，将控制转移给其他进程完成键盘输入。DMA传输完成后，内核切换回hello进程，然后hello执行return，进程终止。6.6hello的异常与信号处理 图6.6.1正常运行结果程序正常运行的结果如上。 图6.6.2任意输入运行结果程序运行过程中任意输入不会影响程序的运行，仅会在终端中显示输入的字符。程序最终的getchar函数会读取键盘输入的第一个值。 图6.6.3输入Ctrl-Z运行结果在程序运行过程中输入ctrl-z之后，shell父进程接收到SIGSTP信号，将hello进程暂时挂起。通过ps命令观察，可以hello进程并未被回收。 图6.6.4使用ps指令观察当前进程再运行一个新的hello进程，并使用ctrl+Z挂起，在此之后输入fg指令，将hello进程调回前台执行，可以看到第二个hello进程又在之前的挂起处继续执行。 图6.6.5使用fg指恢复前台进程再次使用Ctrl-Z将进程挂起，使用jobs查看当前作业，可以看到先前运行的两个hello进程。 图6.6.6当前作业再次恢复第二个hello进程，输入Ctrl-C，此时第二个进程接收到SIGINT信号，接到来自键盘的终止，故转到信号处理程序，终止该进程。再次使用jobs查看当前作业，可以看到仅剩第一个hello进程。 图6.6.7使用Ctrl-C指令再使用kill命令根据第一个进程的PID杀死进程。进程接收到SIGKILL信号，进程被杀死。再次使用ps查看当前进程，已没有hello进程在执行。 图6.6.8使用kill指令后的进程表综上，经过上述各种指令操作，进程收到了三种信号：SIGINT来自键盘的终止、SIGSTP挂起进程、SIGKILL杀死进程。6.7本章小结本章详细分析hello进程在系统上运行的过程。通过在hello实例进程运行过程中施加各种操作来体现进程运行中的异常控制流、信号处理。同时还探讨了有关进程管理、上下文切换的机制和原理。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：逻辑地址即为程序产生的与段相关的偏移地址，也叫相对地址。逻辑地址由段基值和偏移量组成，要经过寻址方式的计算或变换才得到内存储器中的实际有效物理地址。Hello.o文件中的地址即为逻辑地址。线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。即为hello中的虚拟地址。虚拟地址：程序使用的地址，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址被送到内存之前通过硬件与操作系统被转换成物理地址。Hello可执行文件反汇编代码中的地址即为虚拟地址。物理地址：在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址，又叫实际地址或绝对地址。Hello在运行过程中虚拟地址通过MMU映射得到物理地址。7.2Intel逻辑地址到线性地址的变换-段式管理在实地址模式下，处理器使用20位的地址总线，可以访问1MB(0~FFFFF)内存。而8086的模式，只有16位的地址线，不能直接表示20位的地址，采用内存分段的解决方法。段地址存放于16位的段寄存器中（CS、DS、ES或SS）7.3Hello的线性地址到物理地址的变换-页式管理。在保护模式下，段寄存器存放段描述符在段描述符表中的索引值，称为段选择器，此时CS存放代码段描述符的索引值，DS存放数据段描述符的索引值，SS存放堆栈段描述符的索引值。48位的全局描述符表寄存器GDTR指向GDT，即GDT在内存中的具体位置，16位局部描述符表寄存器LDTR指向LDT段在GDT中的位置。唯一的全局描述符表GDT包含操作系统使用的代码段、数据段、堆栈段的描述符，各程序的LDT段，每个程序有一个独立的局部描述符表LDT，包含对应程序私有的代码段、数据段、堆栈段的描述符、对应程序使用的门描述符：任务门、调用门等。7.3Hello的线性地址到物理地址的变换-页式管理概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址，作为数组的索引。磁盘上数组的内容被缓存在主存中。而VM系统将虚拟内存分割为称为虚拟页的固定大小的块，物理内存也同样被分割成物理页，物理页也被成为页帧。在任意时刻，虚拟页面的集合都分为三个不相交的子集：未分配的、缓存的、为缓存的。 图7.3.1物理页和虚拟页物理内存中存放着一个叫页表的数据结构，页表是一个页条目表，将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。 图7.3.2页表DRAM缓存不命中成为缺页。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页。在磁盘和内存之间传送页的活动叫做交换或者页面调度。页从磁盘换入DRAM和DRAM换出磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度。7.4TLB与四级页表支持下的VA到PA的变换下图展示了MMU如何利用页表来实现虚拟地址空间和物理地址空间的映射。 图7.4.1使用页表的地址翻译每次CPU产生一个虚拟地址，MMU就必须查阅一个PTE，以便将虚拟地址翻译为物理地址。然而硬件系统中往往在MMU中包含了一个关于PTE的小的缓存，称为翻译后备缓冲器（TLB）。 图7.4.2虚拟地址中用于访问TLB的组成部分TLB是一个小的、虚拟地址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常由高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。页表驻留在内存中的体积过大会使问题变得复杂，用来压缩页表的常用方法是使用层次结构的页表。例如，一级页表中的每个PTE负责映射虚拟地址空间中一个4MB的片，这里每一个片都是由1024个连续的页面组成的。二级页表中的每个PTE都负责映射一个4KB的虚拟内存页面，就像我们查看只有一级的页表一样。 图7.4.3一个两级页表层次结构这种方法从两个方面减少了内存要求。第一，如果一级页表中的一个PTE是空的，那么相应的二级页表就根本不会存在。这代表着一种巨大的潜在节约。第二，只有一级页表才需要总是在主存中的；虚拟内存系统可以在需要时创建、页面调入或调出二级页表，这样就减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中。7.5三级Cache支持下的物理内存访问以Corei7内存系统为例，处理器封装包括四个核、一个大的所有核共享的L3高速缓存，以及一个DDR3内存控制器。每个核包含一个层次结构的TLB、一个层次结构的数据和指令高速缓存，以及一组快速的点到点链路。TLB是虚拟寻址的，是4路组相联的。L1、L2、L3高速缓存是物理寻址的，块大小为64字节。L1和L2是8路组相联的，而L3是16路组相联的。当CPU请求访问的虚拟地址VA被翻译为物理地址PA后，高速缓存根据组索引CI找到缓存组，在缓存组中根据标记CT与缓存行中的标记位匹配。如果匹配成功且有效位为1，则命中，按照块偏移CO访问指定数据。否则不命中，向下一级缓存中请求数据。如果下一级缓存中已缓存所需数据，那么按替换策略决定本级缓存的牺牲快进行替换，否则继续向下一级存储中寻找数据。 图7.5.1Corei7地址翻译的概况7.6hello进程fork时的内存映射当fork函数被shell进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在hello中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。在这两个进程中的任一个后来进行写操作时，写时赋值机制就会创建新页面。因此，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地代替了当前程序，加载并运行hello程序需要以下几个步骤：1.删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。2.映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。3.映射共享区域。hello文件与共享对象链接，这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。4.设置程序计数器PC。Execve做的最后一件事就是设置当前进程的上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需求换入代码和数据页面。7.8缺页故障与缺页中断处理DRAM缓存不命中成为缺页。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页。若CPU引用了一个页中的字，而所需页并未缓存在DRAM中，请求不命中，那么就会触发一个缺页异常。之后缺页处理程序选择一个牺牲页将所需的页换入，更新页表，随后返回。异常返回后会重新回到导致缺页的命令，指令会重新将虚拟地址发送给MMU，此时所需页已缓存在DRAM中，请求命中。在磁盘和内存之间传送页的活动叫做交换或者页面调度。页从磁盘换入DRAM和从DRAM换出磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度。也可以采用其他方法，例如尝试预测不命中，在页面实际被引用之前就换入页面。然而，所有现代系统都使用的是按需页面调度方式。7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显示地保留为供应用程序使用。空闲块可用来分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。分配器有两种基本风格，两种风格都要求应用显式的分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。显式分配器，要求应用显式地释放任何已分配的块。隐式分配器，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。一个内存块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小，以及这个块是已分配块还是空闲的。由于块大小是8字节对齐的，故块大小最低3位总为0。因此我们用其中的最低位作分配位来指明这个块是已分配的还是空闲的。头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。 图7.9.1堆块的格式 在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。堆块的组织形式需要某种数据结构。常用的结构有隐式空闲链表、显式空闲链表和红黑树。其实现的吞吐率依次增加。放置已分配的块时需要搜索空闲链表寻找一个足够大的位置放置块。这种搜索方式是由放置策略决定的。常见的策略有首次适配、下一次适配和最佳适配。首次适配的应用最为广泛，但缺点时容易留下小的空闲碎片。下一次适配可以提高吞吐率，但内存利用率往往要低得多。最佳适配拥有最高的内存利用率，但相应的吞吐率较低。7.10本章小结本章着重探讨虚拟地址空间与物理地址空间相互映射变换的关系，以及虚拟地址到物理地址的寻址方式，回顾指明了进程管理中fork和execve函数完成的具体工作，并分析了动态内存分配管理的策略。内存管理是程序在计算机上运行至关重要的一环，高效的内存管理方式将大大提升程序的运行效率和系统的安全性，虚拟地址概念以及虚拟地址寻址技术的产生是计算机科学发展的重要成就之一。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件设备管理：UnixI/O接口一个Linux文件就是一个m个字节的序列：B0,B1,…,Bk,…,Bm-1所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。8.2简述UnixIO接口及其函数UnixI/O接口：1.打开文件：一个应用程序通过要求内核打开文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，用于标识这个文件。程序在只要记录这个描述符便能记录打开文件的所有信息。2.shell在创建的每个进程的开始时都为其打开三个文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。3.改变当前文件的位置：对于每个打开的文件，内核保存着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作显式地设置文件的当前位置为k。4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会出发一个称为EOF的条件，应用程序能检测到这个条件，在文件结尾处并没有明确的EOF符号。5.关闭文件：内核释放打开文件时创建的数据结构以及占用的内存资源，并将描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。UnixI/O函数：intopen(constchar*pathname,intflags,intperms)功能：打开一个已存在的文件或者创建一个新文件。Open函数将filename转换为一个文件描述符，并且返回描述符数字。intclose(intfd)功能：关闭一个打开的文件。关闭一个已关闭的描述符会出错。ssize_tread(intfd,void*buf,size_tcount);功能：从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则返回值表示的是实际传送的字节数量。ssize_twrite(intfd,void*buf,size_tcount);功能：从内存位置buf复制至多n个字节到描述符fd的当前文件位置。lseek();功能：应用程序能够显示地修改当前文件的位置。8.3printf的实现分析printf函数的源代码如下：intprintf(constchar*fmt,…){inti;charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } va_list的定义：typedefcharva_list这说明它是一个字符指针。其中的(char)(&fmt)+4)表示的是参数fmt后的第一个参数。vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。它最终会返回一个长度，即要打印出来的字符串的长度。从vsprintf生成显示信息，之后调用write系统函数陷入到陷阱-系统调用int0x80或syscall。之后字符显示驱动子程序实现从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）的过程。最后显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析Getchar函数的源代码如下：intgetchar(void){staticcharbuf[BUFSIZ];staticchar*bb=buf;staticintn=0;if(n==0){n=read(0,buf,BUFSIZ);bb=buf;}return(–n>=0)?(unsignedchar)*bb++:EOF;}在需要从键盘读入一个字符时，内核接收到异步异常，控制交给键盘中断处理程序。中断处理子程序接受按键扫描码转成ascii码，并保存到系统的键盘缓冲区。getchar函数中调用系统函数read，通过系统调用读取保存在系统键盘缓冲区的ascii码值，直到接收到回车键才返回。若用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中。8.5本章小结本章探讨hello程序的系统I/O管理，主要体现为printf函数和getchar函数的实现。通过对printf函数和getchar函数源代码的分析，更加深入理解了hello与外接设备的交互，并最终将信息打印到屏幕上的过程。（第8章1分） 结论Hello的一生可以概括为如下过程：1.从编码阶段开始，hello程序以源代码的形式产生于硬盘上。这是一名入门程序员唯一参与的过程。2.hello经过预处理、编译、汇编、链接、重定位转变为可执行目标文件。至此hello由易于人理解的C语言代码转变为机器可以理解的二进制代码。3.hello通过操作系统内核的管理，以进程的形式运行于系统之上。4.hello在运行过程中接收外部来自键盘的指令，并做出相应的反应。5.hello运行完成，结束短暂的一生，留下的僵死进程由内核回收。至此hello在系统中运行的痕迹被全部抹除。作为每一名程序员的入门程序hello，其实现如此简单而通俗易懂，以至于每个新手都会对它不屑一顾。实际上，hello的一生是短暂而精炼的。程序员们仅仅参与了代码的编写工作，hello余下的生命周期全部是在程序员不可参与的情况下执行的，而这些部分恰恰浓缩了现代计算机科学发展的成果，凝聚了一代代计算机科学家的心血和努力。为实现将姓名学号打印到电脑屏幕这一功能，看似简单的实现，其背后硬件系统与软件系统之间进行的精密、严谨而复杂的配合过程令人拍案叫绝。简单的hello程序凝聚的是人类智慧与科学发展的结晶，更是当今复杂程序系统，如操作系统、服务器、大型游戏、人工智能等实现的基石。能够理解如此庞大复杂的体系和精妙神奇的机制是令人振奋的。然而计算机科学的发展仅仅经历了不到百年的时光，如今计算机科学仍在以迅猛的势头不断发展。在未来，量子计算机、人工智能、虚拟现实技术等等充满无限可能的科技正慢慢向我们靠近。我们有理由相信，计算机科学仍然有无穷的潜力去创造一个又一个令人类骄傲的奇迹！ （结论0分，缺失-1分，根据内容酌情加分） 附件hello.cC语言源代码文件hello.i预处理阶段生成文件hello.s编译阶段生成文件，内容为汇编代码hello.o汇编阶段生成文件，二进制可重定位目标文件hello可执行目标文件hello.elf可重定位目标文件的ELF格式hello2.elf可执行目标文件的ELF格式hello_o_asm.txt可重定位目标文件的反汇编代码hello_asm.txt可执行目标文件的返汇编代码 （附件0分，缺失-1分） 参考文献为完成本次大作业你翻阅的书籍与网站等[1]深入理解计算机系统RandalE.BryantDavidR.O’Hallaron机械工业出版社[2]printf函数实现的深入剖析Pianistx 博客园https://www.cnblogs.com/pianist/p/3315801.html（参考文献0分，缺失-1分） 
第70篇文章[]
Java关于日期 周工作日 时间戳的转换 Lab3开发应用的过程中，与用户交互使用的格式大多是日期和周工作日的形式。比如日期：2021-07-04；周工作日形式：1(Monday)…7(Sunday)。而应用底层ADT的处理过程都是基于绝对时间戳的。在ADT将结果计算出来之后，同样要以日期或周工作日的形式打印信息反馈给用户。因此在这个过程中反复用到了日期与绝对时间戳的互相转化。自己造轮子写转化算法是比较麻烦的，难度不大，但细节很多（腊月、2月、闰年、平年），调试也需要花一番功夫。上网查了查，大概知道了java自带的日期类Date、日历类Calendar，以及日期格式化类SimpleDateFormat。借助这几个类的接口可以直接实现转化。但需要注意的是，这几个类的时间可以精确到毫秒级，也就是说转化后的时间戳1个单位表示1毫秒。而我们的应用中完全不需要如此高的精度，应用一精确到日，应用三精确到小时即可。虽然实验指导书上非常有先见之明的建议将ADT内部有关时间戳的类型全部定义为long，但调试的时候看一堆十几位的整数也是够累眼睛的，不如手动调整一下精度。原来想的是：一天24小时、一小时60分钟、一分钟60秒、一秒1000毫秒，那么只需要将精度为毫秒的时间戳/24/60/60/1000即可，这样得到的结果1个单位就表示1天，同理如果要精确到小时只需/60/60/1000。但测试了一下发现并不对，这么直接除是除不尽的。急中生智我打印了一下时间戳1对应的日期，是1970-01-01…。总之是位于这个日期中午的某个时间段而不是00:00。那么显然事件戳的起始点并不是1。但几乎可以肯定1970应该是万年历的起点（Windows系统时间起点就是1970）。那么顺势打印一下1970-01-0100:00的时间戳，发现为-28800000，看来起点是这个数（至于为甚么要设这么个奇怪的数当起点我也很迷惑）。那么我们只需要在上面的计算公式中引入28800000这个偏移量就行了。日期转时间戳的时候，要先将java自带类的转化结果+28800000，再依次除掉那些常数，最后2021-07-02这个日期顺利的除成了18335（具体多少忘了）左右一个数，大概算一下从1970年到现在差不多就是这么多天，那么我们的转换应该没有大问题了。日期转时间戳（精确到日）代码如下： /** *将日期转化为抽象的时间戳 * *@return转化后的时间戳 */ publiclongDate2Time(Stringdate)throwsParseException{ SimpleDateFormatformat=newSimpleDateFormat("yyyy-MM-dd"); Dated=format.parse(date); return(d.getTime()+28800000L)/1000L/60L/60L/24L; } 相应的反过来时间戳转日期需要-28800000这个偏移量（逆运算嘛），代码如下： /** *将时间戳转化为人可以看懂的格式化日期 * *@return格式化日期字符串 */ publicStringTime2Date(longtime){ time=time*60L*60L*24L*1000L-28800000L; SimpleDateFormatformat=newSimpleDateFormat("yyyy-MM-dd"); returnformat.format(newDate(time)); } 有了这两个函数，在与用户交互时表示问题就非常方便了。 
第71篇文章[]
Java防止内部成员变量外部泄露的措施 做Lab2时最大的收获是关于防泄漏方面的方法和思想。有必要写一点东西记录一下。 其实在此之前我本以为类内部的成员变量暴露给外界是无所谓的。去年暑假的java语言课我写的所有类成员变量全部是public修饰的，自认为这样在类外部可以直接引用查看更加方便。现在想想还是当时还是所知甚少。 Java语言一个很大的特性就是取消了指针类型，这也导致Java中除基本数据类型(int等类型)之外所有类型作为参数传递时传递的是引用（其实个人理解传递的全都是指针地址）而不是一个类的副本。如果某个可变类作为成员变量被暴露在外部，那么这个成员变量在外部可谓是一丝不挂的，外部可随意操纵、修改它，如果有人怀有恶意那么后果可想而知了。所以一定加以保护。 首先是成员变量的权限修饰词，非特殊情况成员变量一致用private修饰，仅限类内部直接使用，如果外部需要查看，则单独写一个observer方法专门返回这个变量的值。 再者就是用final修饰。这个修饰词对于基本类型（int、boolean等）的后果是一旦赋值后便不能再修改，无论是内部还是外部。对于一些可变类（ListSet），这些类无法在外部被引用，内部可以直接使用或修改。而对于成员方法，用final修饰就代表无法被子类继承（断子绝孙方法）。所以一般情况下可变类成员变量都要用final修饰一下，基础类型变量视情况而定，如果在类中以一种条件常量存在，完全可以用final修饰。final这个修饰词还是非常安全的。 最后是关于成员方法返回值的问题。如果成员方法返回的是基础类型值，那么没有问题，因为这类值传递的不是引用，无伤大雅。但如果返回的是可变类，那么就有问题了。如果一个observer方法把可变类成员变量返回到外部，那么外部实际上还是得到了这个类的引用，即使用了final修饰仍然是非常危险的。所以我们在返回前要做一些安全性处理。一种方法是使用Collections.unmodifiableXXX()方法加固返回变量。使用这个方法处理后可变类若在外部遭到修改，那么系统立马会抛出异常。另一种方法是手动复制，在局部定义一个同类型的类，然后将所有信息复制到这个新类中作为副本返回，这样就直接避免了成员变量地址的暴露。 以上就是在实验过程中用到的所有措施，这种安全性的编程思想在以后非常关键。 
第72篇文章[]
关于Java软件开发中Decorator设计模式的认识 Lab3最终敲定使用Decorator设计模式进行开发，最终结果证明这个选择是完全正确的。 Decorator设计模式本身强大的可扩展性和可复用性完全符合我的预期，对于上层ADT的开发没有占据多少时间（大量的时间都耗在了用户交互开发上了，打印信息真的是个枯燥而无脑的工作）。而且接口的具体实现类、Decorator类以及各个具体装饰类借助IDEA强大的纠错能力，根本没有调试，后续直接调用跑测试没出现任何底层的问题（问题还是全出现在输入信息提取、信息打印格式上）。 Decorator设计模式的核心是编写装饰类。一个基本的抽象装饰类Decorator是必不可少的，同时这也是Decorator设计模式最巧妙的地方。基本装饰类本身定义为接口的实现类，但又往往用abstract修饰，也就是说基础装饰类是不能直接调用的，他只是各具体装饰类相互结合的一个跳板。基础装饰类内部通过委派一个接口的多态来实现继承各个方法，正是因为这个委派，使得逐层装饰的效果都可以被组合。直接看一下用具体装饰类组装一个具有多种特性的ADT的定义方式： privatefinalNonBlankIntervalSet<Employee>DutyIntervalSet= newNonBlankIntervalSet<Employee>( newNonOverlapIntervalSet<Employee>( newUniqueIntervalSet<Employee>( newCommonIntervalSet<Employee>()))); 这是应用一中定义无空白、无重叠、标签唯一时间轴的方式。代表三种特性的具体装饰类依次嵌套，并作为参数传给上一层类的构造器进行构造。这种定义形式看起来非常复杂，但再看一下具体装饰类的写法就一目了然了： publicclassUniqueIntervalSet<L>extendsIntervalDecorator<L>{ publicUniqueIntervalSet(IntervalSet<L>set){ super(set); } /** *在当前时间轴中插入新的时间段和标签。 *若待插入时间段的标签与某个已有时间段标签相同，则不执行插入。 * *@paramlabel待插入时间段的标签 *@paramstart待插入时间段的开始时间 *@paramend待插入时间段的结束时间 */ @Override publicvoidinsert(Llabel,longstart,longend){ if(super.labels().contains(label)){ System.out.println("Labelalreadyexist!"); return; } super.insert(label,start,end); } } 这里标签唯一特性表现为重写了insert方法，在每次插入时间轴前检查该标签是否已经存在，如果不存在，再调用父类的插入方法，这就是新的特性。注意这里使用的是super，调用的是父类的方法。而每一个具体装饰类的父类都是基础装饰类Decorator。再看一下Decorator类的结构 publicabstractclassIntervalDecorator<L>implementsIntervalSet<L>{ protectedfinalIntervalSet<L>intervalSet; protectedIntervalDecorator(IntervalSet<L>set){ this.intervalSet=set; } @Override publicvoidinsert(Llabel,longstart,longend){ intervalSet.insert(label,start,end); } @Override //其他方法依次委派  //  } 也就是说在定义时将无特性的接口实现类CommonIntervalSet作为参数传入UniqueIntervalSet，UniqueIntervalSet的构造器将则个类传给父类进行构造，此时基础装饰类Decorato委派给了CommonIntervalSet。那么每次执行insert操作时，会进入UniqueIntervalSet的特性插入方法，如果达到了插入条件，他再使用super.insert通过父类操作，而其父类Decorator内部正是CommonIntervalSet，所以最后还是会调用CommonIntervalSet的插入方法。那么试想这样逐层嵌套，执行一个方法会根据这样的委派体系依次经历那些装饰类的特性操作，这样便实现了特性的组合。 需要注意的是，嵌套定义具有组合特性的ADT时，定义出来的ADT只能使用公用方法和最外层具体装饰类的特有方法。具体装饰类中一般通过重写方法来赋予特性。如果在具体装饰类中撰写新方法赋予特性，那么在定义时该类必须位于最外层嵌套，嵌套在内层的类的特有方法是无法直接调用的。 最后通过这样一种强大的设计模式，实验三最后新的变化一节修改特性时只需修改一行定义代码即可。因为对于Decorator设计模式来说修改特性就是重新组合嵌套装饰类，我们只需改变一下组装具体ADT时用到的装饰类即可。 
第73篇文章[]
相对路径./../区别 相对路径：由于是相对的，所以必须有一个基准作为参照物来说明 /基准所在的最顶级目录即根目录，根目录是相对于其他子目录来说的 ./基准所在的当前目录 …/基准所在的当前目录的上一级目录（当前目录的父级目录） 
第74篇文章[5]
声明：几篇博文都是我在课程学习过程中不定期写的，写完之后存在本地因为调代码格式比较麻烦没有立马上传，最后在期末前一并上传的，但并不是一天内写好的，请助教老师检查。 如题。声明：几篇博文都是我在课程学习过程中不定期写的，写完之后都存在本地，因为调博文的代码格式比较麻烦没有立马上传。虽然最后在期末前一并上传的，但并不是短时间内写了多篇，望助教老师知情，请检查。 
第75篇文章[]
使用Git管理github远程仓库的方式 今天上的第一节软构课就要求我们学习使用Git，未来的三个实验全部通过Git提交。晚上下课后就回去搞了搞，比我想象的复杂，骂了Git一整个晚上。之前偶尔用过Github，都是通过网页上传附件的形式上传到仓库，这次整这个git属实给我整迷糊了。 Git被普遍称为功能强大的版本管理工具，强不强大暂时感受不出来，但是用起来真tm的麻烦。安装好后和远程仓库关联起来就废了半天劲。网上的教程大多是远程公开仓库关联本地仓库，奈何我们的实验仓库都是private的，关联需要密钥认证，根据为数不多的教程一步一步照着弄才勉强关联好。 首先本地创建一个本地仓库，在想要创建的文件夹下打开gitbash输入 gitinit 这样本地会多出一个.git隐藏文件夹，作为仓库管理文件。然后在bash创建输入以下命令配置身份 gitconfig--globaluser.name"username" gitconfig--globaluser.email"email" 之后生成rsa密钥作为和git交互的凭证 ssh-keygen-trsa-C"email" 然后在C盘用户文件夹.ssh文件夹下找到两个rsa文件，分别是秘钥和公钥。我们需要把公钥.pub交给github。具体就是打开github的设置添加一个SSHkey，把公钥内容复制进去。 然后在bush输入以下命令测试连接，连接成功就可以了。 ssh-Tgit@github.com 至此把github和本地认证好后，我推荐用Gitgui来执行以后的push操作，毕竟图形界面适合初学者。在图形界面中根据remote->add->branch…等等选项自己可以摸索出来和远程仓库建立连接，无非就是复制以下ssh设定一下分支名。然后就可以push上传。 当然这只是个开始，push的过程中我还经历了各种各样的错误，大多与git分支管理方式有关，git分支的管理属实有点复杂。如果push上传了一个文件，在本地又删除，之后再次上传会出现错误告诉你本地仓库滞后于远程仓库的更新balabala，死活不让上传。这时候开bash用-force选项强制上传即可。不知道把一个上传搞这么严格有什么用，也许以后能慢慢发现好处吧。 
第76篇文章[]
Java文本文件读入方式 Lab1中遇到的唯一问题是有关文件读入的。要求读入一个.txt文本文件。百度了一下，具体方式如下： try{ Filefile=newFile("../src/P1/txt/"+fileName); if(file.isFile()&&file.exists()){ InputStreamReaderread=newInputStreamReader(newFileInputStream(file),"UTF-8"); BufferedReaderbufferedReader=newBufferedReader(read); StringLine; String[]splitArray; while((Line=bufferedReader.readLine())!=null)       }catch(Exceptione){ System.out.println("Filereadingerror!"); returnfalse; } returntrue; 这样通过各种文件类、流控制类可以实现打开文本文件。打开文件后可以将文本信息以字符串格式逐行读入到字符串变量中。 实验一整体上来说就是让你熟悉一下java语法和编程环境，学学用IDEA，没有什么太多值得记录的地方。 
第77篇文章[]
2021-07-07 Chapter1:ViewsandQualityObjectivesofSoftwareConstruction1.1Multi-DimensionalViewsofSoftwareConstruction1.软件构造过程中的多维度视图2.视图之间的联系1.2QualityObjectivesofSoftwareConstruction1.软件系统的质量外部质量因素内部质量因素折中、妥协2.五个关键的质量指标1.1Multi-DimensionalViewsofSoftwareConstruction1.软件构造过程中的多维度视图多维度视图1 Moment PeriodCode-level Component-level Code-level Component-levelBuild-time Sourcecode,AST,Interface-Class-Attribute-Method(ClassDiagram) Package,File,StaticLinking,Library,TestCase, BuildScript(ComponentDiagram) CodeChurn ConfigurationItem,VersionRun-time CodeSnapshot,Memorydump Package,Library,Dynamiclinking,Configuration,Database,Middleware,Network,Hardware(DeploymentDiagram) Executionstacktrace,Concurrentmulti-threads Eventlog,Multi-processes,DistributedprocessesProcedureCallGraph,MessageGraph(SequenceDiagram)Moment维度关注于程序在某一个时刻的表现，而Period维度更关注于程序在一段时间内的表现；Build-time维度关注程序还未被投入运行，编码阶段的表现，而Run-time维度更关注于程序运行时的表现；Code-level维度关注程序的语句层面，Component-level维度更关注于一段代码，当作一个块观察比如一个包、一个库。(1)Build-time,moment,andcode-levelview关注的是源码的组织情况，可在词汇（源码）、语法（抽象语法树）、语义（类图）三个层面分别分析。 (2)Build-time,period,andcode-levelview关注的是代码的变化（Codechurn代码变化） (3)Build-time,moment,andcomponent-levelview关注的是包/库，而且是静态链接库 (4)Build-time,period,andcomponent-levelview关注代码的更迭，与(2)中不同的是，这个维度下更关注文件版本的变化，而不是具体语句的变化（2中关注的是哪一行代码被修改了）----VCS的引出 (5)Run-time,moment,andcode-levelview关注的是程序在某个时间点内存中的情况，如代码快照图(CodeSnapshot)、内存信息转储(Memorydump)。 (6)Run-time,periodandcode-levelview关注的是代码的执行情况，执行跟踪 (7)Run-time,moment,andcomponent-levelview关注的也是包/库，但却是在代码执行过程中的情况，如动态链接库 (8)Run-time,period,andcomponent-levelview关注的是系统的使用情况，使用日志查看 2.视图之间的联系 从无到有，写出了代码，就进入了Build-time维度，开始只是单个的没有任何联系的代码文件，所以是在moment+Code-level维度，此时随着时间的推移，代码删删改改，就属于Period+Code-level了，而代码越写越多成为了一个包，甚至形成了一个库，于是就属于moment+Component-level维度了，但是随着时间的推移，你的库文件由于需求的变化发生了变化，所以就属于Period+Component-level。代码写好了，投入运行，进入Run-time维度，观察的如果是某一句代码的执行后结果，那就是moment+Code-level维度，但如果看的是代码执行的轨迹，那就是Period+Code-level维度，而如果看的是一个库文件的连接情况等，那就是moment+Component-level维度了，如果看的是线程或进程的执行过程，也就是通过日志等手段查看一段时间内系统都做了什么事情，那么就是Period+Component-level了。 1.2QualityObjectivesofSoftwareConstruction1.软件系统的质量外部质量因素External1:Correctness（正确性），正确就是满足spec，这是软件开发最重要的因素，一个可用的软件一定是正确的，所以首要保证软件的正确性，其他的都可以做妥协、让步，但只有这一项不可妥协。 External2:Robustness（鲁棒性），通过抛出异常然后处理异常等方式让出错的程序恢复到正常的执行流程上。 External3:Extendibility（易扩展性），要便于软件功能的增加/扩展（ADT、OOP、留下一个Visitor），降低未来修改软件时的成本。 External4:Reusability（复用性），在异性之间尽可能地寻找共性，以便于未来可以直接使用现在写的这段代码。这样可以降低软件地开发成本。 External5:Compatibility（兼容性），在不同的环境下都是可用的，不同的软件系统之间相互可容易的集成。 External6:Efficiency（效率），不要过早的优化，性能在没有正确性保障的条件下是没有意义的。 External7:Portability（可移植性），软件可方便的在不同的技术环境之间移植。 External8:Easeofuse（易用性），学习成本低，结构简单、清晰，易于使用。 External9:Functionality（功能性），功能过多会导致易用性的降低。主要功能要首要提升质量。 External10:Timeliness（时效性），软件要能够在交付时间之前完成开发交给使用者。 External10++:Otherqualities，Verifiability(可验证性)，Integrity(完整性)，Repairability(可修复性)，Economy(经济性)。 内部质量因素代码行数(LOC)、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小 折中、妥协Integrityvs.easeofuse、Economyvs.functionality、Efficiencyvs.portability、Efficiencyvs.reusability、Economyvs.reusability、Timelinessvs.extendibility 这些质量属性之间往往不能兼得，当某一项满足的足够好的时候有可能其他项的表现极差，因而需要做权衡，使得各部分的表现都较好，在某些特定要求下也可以放弃优化其他项而做到某一项的极致，这需要靠开发者的经验积累来判断。 正确性是绝不能与其他质量因素折中的！！！ 在OOP开发中，通过封装、模块化、组件、抽象、分散、错误处理、信息隐藏、框架、接口等技术来尽可能地满足上述地质量因素，提高软件的开发质量。 2.五个关键的质量指标Elegantandbeautifulcode：代码要容易理解，通过统一变量/方法的命名标准、代码的风格、注释、包组织结构、必要时重构代码等方式让代码尽可能的容易理解。Designfor/withreuse：ADT/OOP、接口、继承(Overload、Override)、多态、泛型、框架等技术可用于提高代码的可复用性。Lowcomplexity：当复杂度较低的时候，代码就容易被扩展新的功能，所以要高内聚低耦合，遵从SOLID原则、OO设计模式、使用VCS控制代码版本Robustnessandcorrectness：使用测试驱动的开发、异常处理、Assertion机制、防御式编程等技术保证程序的健壮性和正确性。Performanceandefficiency：使用设计模式、并行/多线程等技术提升性能。 
第78篇文章[6]
在Anaconda虚拟环境中安装Tensorflow+Keras 首先进入AnacondaPrompt，通过activate命令进入我们的虚拟环境，然后依次输入如下命令进行安装即可。1.安装mingwlibpython condainstallmingwlibpython 2.安装tensorflow(GPU加速版本) condainstalltensorflow-gpu 3.安装keras(GPU加速版本) condainstallkeras-gpu 
第79篇文章[]
Github将https方式改为ssh方式，进行push与clone 使用Git提交到Github时，若采用默认的https方式进行push与clone，则会比较慢，且对大文件容易出现报错的情况，故我们可以将其改为ssh方式。 步骤 打开Github的仓库，点击code，进入显示ssh的页面到本地项目文件夹子，打开gitbash。查看clone地址：git remote-v移除https的方式git remotermorigin添加新的git方式：ssh方式，ssh方式地址的话，在github上，切换到ssh方式，然后复制地址。gitremoteaddorigin刚刚复制的git地址git remote-v看到地址是以git@github.com:开头，说明ssh方式添加成功重新push（提交一下）git pushoriginmaste 完成以上步骤，便由https方式改为了ssh方式。 
第80篇文章[]
哈工大软件构造Lab2导读-Stanford6.031ProblemSet2:PoeticWalks 文章目录 前言一、P1-Problem1：编写测试用例1.GraphStaticTest2.GraphInstanceTest 二、实现两个ADT1.AF，RI，SafetyfromRepexposure.etc2.checkRep()3.方法的具体实现4.实现Graph.empty() 三、PoeticWalks1.题目意思梳理（结合MIT页面和spec看）2.编写测试用例3.具体实现Poet1)构造方法GraphPoet2)生成句子方法Poem3)toString方法 4.测试代码覆盖度 四、重构Lab1中的SocialNetwork总结 前言 由于实验的介绍为MIT的全英文页面，要点分散，可能造成理解上的困难。所以在这里梳理总结一下软构lab2的整个流程，可以结合MIT的问题描述来看。希望能帮到后来的学弟学妹，不要拿到程序包直接两眼一抹黑，不知从何下手。 写下这篇文章是在完成实验后进行回忆，如有疏漏请多指正。 先简单总结Lab2完成的工作：从github将代码clone到本地，根据已有spec完成测试用例的编写（P1，Problem1），再分别编写两个ADT：ConcreteVerticesGraph和ConcreteEdgesGraph的具体实现（P1，Problem2/3）。之后，我们利用两个ADT分别实现具体的类GraphPoet，并完成一系列的工作（P1，Problem4）。并重构我们在Lab1中实现过的人际关系图（P2） 本实验的完成基于IDEA，可以方便地可视化代码覆盖度，所以没有涉及安装EclEmma。 一、P1-Problem1：编写测试用例 按照TDD（Test-DrivenDevelopment，测试驱动开发）的策略，在编写具体实现之前，我们需要根据已有的spec设计出对应方法的测试。 1.GraphStaticTest 这一部分是对Graph.empty()的测试，可以先不用管，在完成Problem3.2实现Graph.empty()之前，这一块的代码是跑不起来的XD对GraphStaticTest的补充也需要在Problem3.2中进行。 2.GraphInstanceTest 这一部分是对Graph中的具体方法进行测试，需要好好构思构思，如果刚开始草草写了/没有考虑周全，那么在后面代码覆盖度过低，会反复回头来修改这部分，耽误很多时间！ 具体而言，这一部分要按等价类划分的方法，编写测试用例。严格写下来的话，代码行数不少。举个栗子： TestingstrategytestRemove()测试remove()方法，等价类划分如下：删除点是否在图中：是，否删除点是否有相连边：是，否 排除不可能的情况，共3个等价类，所以需要写三组测试。 另外，提醒考虑ADT对有环图的支持并测试，后续部分会用到。 二、实现两个ADT 1.AF，RI，SafetyfromRepexposure.etc 具体实现两个ADT，首先要求我们撰写相信很多同学这是第一次实际写一个程序的AF、RI，这些概念的具体意义可以参见关于AF,RI,Repexposure其实举个例子，照葫芦画瓢也还算容易。例如，对于ConcreteEdgesGraph，它的这些概念可以解释如下： Abstractionfunction:AF(vertices)=Graph中的点AF(edges)=Graph中的边 Representationinvariant:点的名字不能重复所有点都在vertices中edge的权值为正两点间的单向边最多只能有一条 Safetyfromrepexposure:成员变量vertices与edges均用privatefinal修饰，防止其被外部修改在涉及返回内部变量时，采用防御性拷贝的方式，创造一份新的变量return 2.checkRep() checkRep()部分就是针对RI设计出检查代码。比如，在RI中有一条“edge的权值为正”，则在checkRep()中需要用assert语句检查edge的成员是否大于0，在每次运行方法（如add，set）且修改了成员变量后，需要在return前调用checkRep()进行检查。 3.方法的具体实现 在实现ConcreteVerticesGraph和ConcreteEdgesGraph时，MIT的页面要求先用String型，再用泛型L，其实可以直接用泛型L来写，节省后续改的工作量。若用泛型L来写，则需要将两个ADT的部分内容修改为如下： publicclassConcreteEdgesGraph<L>implementsGraph<L>{ } classEdge<L>{ } 和 publicclassConcreteVerticesGraph<L>implementsGraph<L>{ } classVertex<L>{ } 相关方法的具体实现在这里暂且不表，在完成方法的实现后，可以通过前面写的测试用例来检验方法编写是否正确，并看看代码覆盖度，有哪些代码没有覆盖到。（实验要求代码覆盖度尽可能达到100%） 在这里简单讲一下IDEA的代码覆盖度测试：运行之后： 另外注意，两个ADT中需要分别实现成员Edge与成员Vertex，在ConcreteEdgesGraphTest与ConcreteVerticesGraphTest中，需要完成对Edge与Vertex各自成员方法的测试。 4.实现Graph.empty() 这一部分要求我们对Graph.java中的empty()方法进行实现，具体来说，就是让empty()方法返回两个具体ADT中的一个，如图：完成后，在GraphStaticTest中补充测试代码，具体来说，就是模仿已有代码，验证在Interger，Double等类型下是否正确，如图： 三、PoeticWalks 到此，我们已经完成了MIT页面上的Problem1~3，开始解决Problem4。 1.题目意思梳理（结合MIT页面和spec看） 在这一步中，需要依据语料生成一个单词图，单词图的每个顶点是语料中的一个单词，单词图的边代表前一个单词紧接着后一个单词，边的权重为前一个单词紧接着后一个单词的次数，并且不考虑大小写与标点符号。举个例子： hello,hello,HeLlo,world! 其中，hello→hello出现两次，hello→world出现一次，则这个语料构成的图为：更加具体的示例可以参照MIT实验官网的页面。 在根据语料构造好图后，下面需要完成的任务是：输入一个句子，提取出句子两两相邻的单词对，在图中进行一次检索，若句子的前后两单词w1→w2在单词图中隔着一个顶点b，则将b加入句子中，得到w1→b→w2。具体的构建规则如下： ①w1与w2间只能间隔一个顶点，这也就是说，如果在图中出现了w1→a→b→w2，甚至间隔更多的情况，则不会在w1→w2间加入单词。 ②如果从w1到w2同时有两条路径w1→a→w2与w1→b→w2，则选择权重最高路径上的单词加入w1与w2之间。 ③输出的句子中原单词的大小写保持不变，加入的单词全用小写。 ④可以存在指向自己的边，即该图可以是带环图。 2.编写测试用例 在理清思路后，我们可以着手开始编写测试用例，具体的测试策略为编写Poem与toString方法的测试用例，对于Poem，采用不同的语料，测试能否得到正确的输出；对于toString，则用不同用例测试toString方法的正确性。 举个例子如图：在mugar-omni-theater.txt中保存着语料 ThisisatestoftheMugarOmniTheatersoundsystem. 此条测试的意义是输入句子input，经过图处理后，检验输出是否与我们的预期AccOutput相同。 3.具体实现Poet 在GraphPoet中，我们需要依次实现三个方法： 1)构造方法GraphPoet 在GraphPoet的构造方法中，我们需要读取文本文档，并由其中语料按照前文所阐述的方法生成一个单词图。具体实现方式为：输入文件路径并按行读入，将单词进行切分，进行删除标点符号，大写转小写等预处理，每次取相邻元素在图中添加新边。 2)生成句子方法Poem Poem方法输入一个String参数作为原始句子，输出根据单词图匹配过的，扩充了bridgewords的新句子。具体实现思路为一次读入两个单词，检索前一个单词子节点的子节点，若其中包含后一个单词，则选择途径通路权重最高的一路，将该路上途径节点表示的单词加入原来两单词之间。 3)toString方法 简单重写toString方法，将整个图中所有点的指向转化为一条字符串输出。 4.测试代码覆盖度 代码覆盖度建议尽量达到100% 四、重构Lab1中的SocialNetwork 这一环节要求我们基于在前面步骤中定义的Graph及其两种实现，将泛型L替换为Person，按照Lab1中SocialNetWorek的要求，实现Lab1Problem3中FriendshipGraph的各种功能，并且尽可能复用我们在前文构造的类中已经实现的方法。最后，运行提供的main()和执行Lab1中的Junit测试用例，确保其正常运行。 有Lab1的基础，这部分的重构算是比较快的。利用ConcreteEdgesGraphTest与ConcreteVerticesGraphTest其一便可完成。测试代码与main函数之间copy，略加修改就可。 总结 总得来说，Lab2相较于前几届的版本，难度降低了很多，但仍有不易理解的地方，需要花一些时间才能完成。 
第81篇文章[]
类方法与实例方法的区别 类方法 用static修饰的方法。 由于类方法是属于整个类的，所以类方法的方法体中不能有与类的对象有关的内容。 即类方法体有如下限制： 类方法中不能引用对象变量；类方法中不能调用类的对象方法；在类方法中不能调使用super，this关键字；类方法不能被覆盖。 实例方法 当一个类创建了一个对象后，这个对象就可以调用该类的方法（对象方法）。 实例方法中可以引用对象变量，也可以引用类变量；实例方法中可以调用类方法；对象方法中可以使用super，this关键字。 区别和注意事项 区别 类方法可以通过类名调用，实例方法不能通过类名调用当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。 类方法在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出时才被取消。 注意 当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址。也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。 在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址 
第82篇文章[]
git配置SSH公钥，并与github在线仓库进行链接 首先参考其他资料完成git的安装 然后步入正题： ssh公钥的生成 1.进入C:\Users\Administrator\.ssh文件夹 2.在.ssh文件夹下打开gitbash，输入ssh-keygen-trsa，输入后一直回车即可生成秘钥：3.回到.ssh文件夹，可以看到生成的公钥与私钥。用记事本打开id_rsa.pub，复制其中内容到github的秘钥设置页面： 最后点击AddSSHKey，便完成了秘钥的设置。 SSH公钥链接在线仓库 通过 gitremoteseturlorigin在线仓库SSH地址 来链接对应仓库 相比https，通过ssh进行链接的好处是速度更快，且没有文件大小的上传限制。参考https://lanlan2017.github.io/blog/9f3d9944/ 
第83篇文章[5]
哈工大2021春CSAPP大作业-程序人生（Hello’sP2P） 
第84篇文章[6]
Win10+Anaconda3+Pytorch1.8(CUDA11.1)+Jupyter安装教程 最近要搭神经网络做二分类，因为很多教程都比较老了，所以在这里记录一下自己安装环境的全流程，方便其他人参考。 Anaconda3安装 Anaconda3下载 首先到Anaconda官网下载Anaconda3的安装包。如果是个人使用，依次点击左上角Products→IndiviadualEdition，点击Download，根据自己的电脑系统选择合适的版本进行下载，笔者在这里下载的是WindowsPython3.864-bit版本。 Anaconda3的安装 下载完成后进行安装。点击下载好的Anaconda3-2020.11-Windows-x86_64.exe，依次点击Next→Iagree。这里建议选择第二个选项，以便不同用户使用Anaconda。 之后就是选择路径这一步的两个选项，上面一个意思是加入环境变量，这个我们稍后自己设置，不用勾选。下面一个是默认使用Python3.8，建议勾选。然后等待安装完毕即可。 Anaconda3环境变量配置 依次点击此电脑 右键打开属性 高级系统设置 环境变量 path(注意是系统变量里的path,不是用户变量里的) 编辑 新建根据自己的路径，添加如下环境变量(把G:\Anaconda3改成自己的Anaconda安装路径)： G:\Anaconda3 G:\Anaconda3\Scripts G:\Anaconda3\Library\bin 检验是否安装成功 按win+R键进入运行栏，输入cmd，在命令行下输入conda。如果出现相关信息则说明安装成功。如果没有则按照提示信息进行激活等操作。再输入python，确认python版本为3.8 Pytorch的安装 创建虚拟环境 按win键打开AnacondaPrompt输入如下命令 condacreate-nGypsophilapython=3.8//创建虚拟环境，虚拟环境的名字是Gypsophila（可以任意修改） activateGypsophila//切换到我们创建的虚拟环境 通过第一行命令创建虚拟环境，中途需要确认，直接回车即可。输入第二行命令后，左边括号里变成了虚拟环境的名字，则说明创建成功。这个页面先不急着关掉，后续马上就会用到。 添加清华镜像源 在AnacondaPrompt中，如果命令行提示语句开头显示(base)，则首先用前一步的activate命令切换到我们创建的虚拟空间。开始添加清华源的步骤。因为国内连Pytorch的服务器速度很慢，安装失败率很高，所以切换到清华镜像源几乎是必须的。依次输入如下代码： condaconfig--addchannelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ condaconfig--addchannelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ condaconfig--setshow_channel_urlsyes condaconfig--addchannelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ condaconfig--addchannelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/ condaconfig--addchannelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ 其中最后一行命令安装CUDA11.1及以上版本才需要，不过建议还是写上 安装Pytorch Anaconda3安装完成并添加源后开始安装Pytorch。进入Pytorch官网，找到如下界面下面依次来介绍每一行的意义及选项 PytorchBuild：Pytorch版本的选择。建议选择Stable（稳定运行版）。清华源似乎不提供Preview版的镜像，若要下载Preview版可能速度很慢。YourOS：根据自己电脑操作系统选择Pytorch版本。Package：Windows系统选上Conda，Linux系统选Pip。Language：根据编程语言选择ComputePlatform：这一个的选择稍微有些复杂。首先，如果不是NVIDIA的显卡，则选择CPU选项。如果是NVIDIA的显卡，则通过win+R呼出cmd命令行，输入如下命令以确认自己电脑的CUDA版本： nvidia-smi 从CUDAVersion栏可以看出电脑显卡能够支持的最高版本CUDA（在这台电脑上是CUDA11.1），在选择ComputePlatform时对应的CUDA版本不能高于这里显示的CUDAVersion。在这之后，复制Pytorch官网生成的命令，但注意，要把命令中的-cpytorch与-cconda-forge（如果有）删掉，否则还是默认从主服务器上下载，速度很慢！！！最终得到的命令如下： condainstallpytorchtorchvisiontorchaudiocudatoolkit=11.1 呼出AnacondaPrompt，进入自己搭好的虚拟环境，输入上面的命令。安装包有数个G，需要等待一段时间，等待安装完成即可。安装完成后，在虚拟环境中输入如下命令 python importtorch torch.cuda.is_available() 如果返回值是True，则说明可用GPU加速，Pytorch与CUDA的安装完成。 Jupyter的安装 安好Anaconda与Pytorch后，编辑器的选择很多，有VSCode、PyCharm、Jupyter等等，这里介绍一下Jupyter的安装方法。先打开AnacondaPrompt命令行，进入自己设置的虚拟环境，输入如下命令安装： condainstallnb_conda 中途确认，等待安装完成。安装完成后，在虚拟环境下输入jupyternotebook，跳转到jupyter页面，选择红框所示选项（名字是自己虚拟环境的名字）。输入如下指令后点运行，输入为True，则说明Jupyter安装完成，且使用的是我们自己安装的带有Pytorch的虚拟环境。可以参照我的这些文章进行进一步的环境配置 在VScode下配置Anaconda环境 在Anaconda虚拟环境中安装TensorFlow+Keras 
第85篇文章[]
Java实现无向图深搜确定任意两点间最短距离 软件构造lab1实验中编写的Problem3部分，在此处做个记录 涉及的数据类，方法 Graph类表示无向图。其下有几个重要变量：persons：为ArrayList，用于保存graph中的节点。其定义为：publicList<Person>persons=newArrayList<Person>(); relationships：为嵌套的Vector，保存节点间的关系矩阵。若两节点直接相连，则对应位置为1；若两节点不直接相连，则对应位置为0。其定义为：publicVector<Vector<Integer>>relationships=newVector<Vector<Integer>>(); Person类表示图中的顶点。具有name与index两个私有变量，name为String类型，表示名称，是顶点的标识；index为int型，代表顶点在关系矩阵中对应第index行与第index列。若顶点不在图中，则index为默认值-1。getDistance方法输入参数为两个Person顶点，返回值为两顶点间的最短距离。为了方便说明，规定相连两点间距为1。方法声明为：publicintgetDistance(Personp1,Personp2) 算法基本思想 首先对异常情况进行判断，若输入两顶点相同/有不在图中的顶点，则直接返回-1。实现方法为具体根据person的index与name成员判断。进行BFS深搜。具体的实现如下：首先构造以下三个变量：intdistance=0;//起始点到终点的距离，初始为0 Queue<Person>queue=newLinkedList<Person>();//队列，用于BFS搜索 int[]visit=newint[persons.size()];//visit数组（visit为标志是否访问过的数组,访问过为1，否则为0） boolean[]isQueueEnd=newboolean[persons.size()];//isQueueEnd标志节点i是否是某轮bfs深搜的终点，若是，其为true，,需要使distance++ 在我们的算法中，先将初始顶点p1加入队列，因为其访问过，且为第0轮深搜的终点，故设置visit[]与isQueueEnd[]对应位为1。然后弹出该顶点，依次搜索与该顶点直接相连的顶点入队，将这些顶点的visit[]位均设置为1，且设置当前轮最后一个入队顶点的isQueueEnd[]对应位为1，由此，便完成了一轮BFS搜索。终结情况判断：当队首为终结顶点p2时，正常结束，返回distance。当检测到队空时，说明没有从p1到p2的通路，返回-1 以下图为例来解释我们的算法：假设计算从P1到P6的距离：1.先将P1入队2.弹出P1，加入P2,P3,P4，并标记P4为当前轮终点，distance++。3.之后按顺序依次进行:直到队首为P6，返回此时的distance值。 具体实现 person类 publicclassPerson{ privateStringname; privateintindex=-1; publicPerson(Stringname){ this.name=name; } publicStringgetName(){ returnname; } publicintgetIndex(){ returnindex; } publicvoidsetIndex(intindex){ this.index=index; } } getDistance()方法 /** *Addanewedgefromp1top2. * *@paramp1Thestartingvertexofthenewedge *@paramp2Theendingvertexofthenewedge *@returnTheshortestdistancebetweenp1andp2.Iftherearenoanypathsbetweenthem,return-1. */ publicintgetDistance(Personp1,Personp2){ //异常情况处理 //p1与p2有其一不在关系图中 if(p1.getIndex()==-1){ System.out.print(p1.getName()+"不在关系图中"); return-1; } if(p2.getIndex()==-1){ System.out.print(p2.getName()+"不在关系图中"); return-1; } //p1与p2相等 if(p1.getIndex()==p2.getIndex()){ return0; } Queue<Person>queue=newLinkedList<Person>();//队列，用于BFS搜素 intdistance=0; Persontemp=newPerson(""); PersonqueueEnd=newPerson(""); Vector<Integer>tempCol=newVector<Integer>(); //visit数组（visit为标志是否访问过的数组,访问过为1，否则为0） int[]visit=newint[persons.size()]; //isQueueEnd标志节点i是否是某轮bfs深搜的终点，若是，其为true，,需要使distance++ boolean[]isQueueEnd=newboolean[persons.size()]; //初始化，对p1进行设定 queue.add(p1); visit[p1.getIndex()]=1; isQueueEnd[p1.getIndex()]=true; while(queue.peek()!=p2){ temp=queue.poll();//弹出并保存queue的头元素 //将与queue头元素直接相连，且未访问过的元素入队 tempCol=relationships.get(temp.getIndex());//tempCol保存头元素对应的关系矩阵行 for(inti=0;i<tempCol.size();i++){//头元素对应的关系矩阵行，遍历此行中的所有元素，找到与头元素直接相邻的元素 if(tempCol.get(i)==1){ //查找index为i的person，并将其加入队列,同时把其标记为访问过 for(Persont:persons){ if(t.getIndex()==i&&visit[i]==0){ queue.add(t); visit[i]=1; queueEnd=t;//记录当前队尾 break; } } } } //最后队列空，说明没有p1到p2的直接通路 if(queue.isEmpty()) return-1; //记录当前队尾，并使distance++ if(isQueueEnd[temp.getIndex()]){ isQueueEnd[queueEnd.getIndex()]=true; distance++; } } returndistance; } 
第86篇文章[6]
Win10下在VScode中配置Anaconda3Python环境&CommandNotFoundError的解决方式 Anaconda3环境与PyTorch的安装 可以参考我之前的博文安装Anaconda3与PyTorch。 在VScode下配置Anaconda3 先安装VScode（可以参照其他教程）安装完成后，打开VScode，至少安装如下插件： Python环境安装，由于在之前安Anaconda时已经安装了Python，所以这里直接安VScode中的插件就好。安装VScode的中文环境插件，方便阅读。安装好上述插件后，在工作区中新建一个.py文件，点开.py文件，查看左下角Python版本的显示形式，如果不是PythonX.X.X64-bit('虚拟环境名':conda)的形式，则点击它，然后在弹出的窗口中选择我们的工作区，将Python版本切换成我们虚拟环境中的版本。这样VScode+Anaconda3Python环境便配置完成，通过如下代码进行测试，如果成功输出True则安装成功。 importtorch print(torch.cuda.is_available()) 如果测试时出现如下报错提示 CommandNotFoundError:Yourshellhasnotbeenproperlyconfiguredtouse‘condaactivate‘ 则可以按这位博主的方式处理https://blog.csdn.net/cskywit/article/details/99202520 
第87篇文章[1]
深入理解计算机系统-cachelab中矩阵转置的基本分析 在做cachelab时发现自己对cache的具体工作原理理解不深，网上也很少有这部分的具体讲解，故自己在此记录一下： （牢牢抓住一点：cache是高速缓存！！缓存！！） 以一个简单的例子来说明矩阵转置时cache的具体工作情况。 假设我们现在有一个包含2组，每组1行，每行存8个int型数据的简单cache（S=2,E=1,B=32），现在要对一个4x4的矩阵进行转置。记原矩阵为A，转置后的矩阵为B。 则我们可以得知，矩阵中前2行元素与后2行元素分别存在cache的不同块中。 假设交换的函数如下： for(i=0;i<4;i++) { for(j=0;j<4;j++) { tmp=A[i][j]; B[j][i]=tmp; } } 我们以示意图的方式来说明cache的工作情况(这里只列出了cache的数据块) 有上述简单分析，应该就能知道cachelab中不命中的原理了。 
第88篇文章[6]
VSCode下运行Python程序报错ModuleNotFoundError的解决方案 基本情况：安装了Anaconda虚拟环境，在用VSCode写Python程序时，遇见了这样的错误： ModuleNotFoundError:Nomodulenamed‘torch’ 经过测试，只有部分包如tensorflow,keras无法导入，而其他一些包如xlwt则导入正常，可以使用。 查找了网上的很多方法，如修改setting.json文件，并没有起到作用，最后通过开启设置中的runinterminal功能得以解决： Ctrl+Shift+P打开用户设置→拓展→RunCodeConfiguration→勾选RunInTerminal即可。 
第89篇文章[]
HIT软件构造Lab3实验心得 首先是有关Git的，删除分支的一些操作，因为IDEA不能删除特定分支（可能是我不会？），先是gitbranch-bmain，这个main指的是你要删除的本地分支的名字，而后是gitpushorigin--deletemain，main指的是你要删除的远程仓库分支的名字。 接下来是整个实验一个很重要的地方，是关于MultiIntervalSet如何复用IntervalSet，这部分是个难点，我的想法是增加一个私有的成员变量xxx，其类型为List<IntervalSet<L>>，然后List中的元素的存放的时间段数量依次递减，insert时就寻找还没有插入该label的IntervalSet即可。 然后是装饰器Decorator，实现checkBlank或checkOverlap是通过两个具体装饰角色来进行的，而装饰器和具体装饰角色的其他方法是直接return的，此时如果已经插入有很多时间段的intervalSet进行装饰后，调用相关方法就会出现固定的返回值，因此我们要checkBlank时，需新建立一个变量，通过IntervalSet<L>intervalset=new具体装饰角色的名字(intervalSet);声明后调用checkBlank即可完成检查，而后续还需要用intervalSet时只能用intervalSet来调用方法，因为intervalset调用方法的返回值是固定的。 
第90篇文章[1]
HIT-CSAPP大作业-程序人生-2021 摘要 本文主要阐述了hello程序的一生，从编写完得到的hello.c到其经过预处理、编译、汇编、链接和加载到内存进行运行的整个过程，同时还讲述了进程管理、存储管理以及IO管理，其中夹杂着很多计算机系统的本质概念。 关键词：程序；运行；管理；计算机系统 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 P2P：(FromProgramtoProcess) 首先编译器编写hello.c源程序Program，然后运行C预处理器（cpp）将hello.c翻译成一个ASCII码的中间文件hello.i，而后编译器（ccl）将hello.i翻译成一个ASCII汇编语言文件hello.s，接下来汇编器（as）将hello.s翻译成一个可重定位目标文件hello.o，在通过链接器与库函数链接，创建一个可执行目标文件prog，shell执行该文件，通过fork产生子进程，调用execve函数加载运行该进程，产生Process。 020：(FromZerotoZero) shell调用fork和execve后，程序映射到虚拟内存，删除当前虚拟地址的数据结构并创建新的区域结构，在经过程序入口后载入物理内存，再运行main函数至结束，父进程回收子进程，占据的内存也被释放。 1.2环境与工具 1.2.1硬件环境： Intel(R)Core(TM)i7-8750HCPU；2.20GHz；16.0GBRAM； 1.2.2软件环境： Windows1064位；VMware15.5；Ubuntu20.04LTS64位； 1.2.3开发工具与调试工具： VisualStudio201964位；CodeBlocks；gcc；objdump；gdb；edb；hexedit；readelf； 1.3中间结果 hello.c：C语言源程序 hello.i：hello.c预处理得到的.i文件 hello.s：hello.i经过编译得到的汇编代码.s文件 hello.o：hello.s经过汇编得到的可重定位目标.o文件 hello：hello.o与库函数的链接得到的可执行目标文件 helloo.txt：hello.o的反汇编文件，查看反汇编代码 hello.txt：hello的反汇编文件，查看反汇编代码 helloo.elf：hello.o的elf文件，查看各节的信息 hello.elf：hello的elf文件，查看各节信息 1.4本章小结 本章介绍了hello程序，同时列出了实验的环境、工具和中间结果。 第2章预处理 2.1预处理的概念与作用 2.1.1概念 预处理阶段将根据已放置在文件中的预处理指令来修改源文件的内容，得到以.i文件。#include指令就是一个预处理指令，告诉预处理器（cpp）读取头文件的内容. 2.1.2作用 1.条件编译：根据条件有选择性的保留或者放弃源文件中的内容。 2.源文件包含：搜索指定的文件，并将它的内容包含进来，放在当前所在的位置。源文件包含有两种，包含系统文件以及用户自定义文件。 3.宏替换：宏的作用是把一个标识符指定为其他一些成为替换列表的预处理记号，当这个标识符出现在后面的文本中，将用对应的预处理记号把它替换掉。 4.行控制：行控制指令以“#”和“line”引导，后面是行号和可选的字串。用于改变预定义宏“_LINE_”的值，如果后面的字串存在，则改变“_FILE_”的值。 2.2在Ubuntu下预处理的命令 预处理指令：gcc-Ehello.c-ohello.i 图2.1 产生的.i文本文件如下图：（预处理添加的内容较多，只截取了一部分） 图2.2 2.3Hello的预处理结果解析 可以看出，预处理后得到的.i文件的main函数主体是没变化的，但提取出来的头文件是很多的，该C源程序是包含有三个include的系统文件的，它让预处理器去系统目录下查找相关文件，并且将它的内容包含进来，放在当前所在的位置。 2.4本章小结 本章主要是了解预处理的概念和作用，以及Ubuntu下预处理的指令，并且对预处理的结果进行了相关的解析。 第3章编译 3.1编译的概念与作用 3.1.1概念 将预处理得到的输出文件（.i文件）进行翻译得到等价的中间代码表示或汇编代码（.s文件）。 3.1.2作用 经过预处理得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及C语言的关键字，而编译就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的汇编代码。 3.2在Ubuntu下编译的命令 gcc-Shello.i-ohello.s 图3.1Ubuntu下的编译指令 3.3Hello的编译结果解析 3.3.1伪指令 下图中截取的部分均为指导汇编器和连接器工作的伪指令。 .file：声明源文件的名字为“hello.c”；.text：表示代码段；.global：声明全局变量sleepsecs；.data：表示数据段；.align4：声明代码段的对齐方式为4字节对齐；.typesleepsecs,@object：声明sleepsecs为object符号；.size：声明sleepsecs的大小为4个字节；.long：AT&T的汇编伪指令中.long是.int的等价指令，声明sleepsecs为int类型；.section.rodata：表示只读数据段，其中.LC0和.LC1中的.string代表printf函数输出的两个字符串常量；.globalmain：声明main函数为全局变量；.typemain,@function：声明main为函数符号； 图3.2伪指令 3.3.2数据 1）整型 sleepsecs：初始化后的全局变量，在.data节中保存有初始值；argc：main函数的整型参数，保存在寄存器%edi中，且保存在初始栈底向上的20字节处；（具体见图3.3，图3.3开始部分是函数分配栈空间）i：整型局部变量，保存在栈中； 图3.3栈空间分配和main函数参数压栈 2）字符串 printf函数中的两个字符串常量，且保存在只读数据段.rodata节中； 3）数组 argv：字符型数组，保存在寄存器%rsi中，且保存在初始栈底向上的32字节处； 3.3.3赋值和算术操作 1）赋值 其中包含的赋值操作：movl、movq和leaq； 2）算术操作 其中包含的算术操作： addq：加操作；subq：减操作； 3.3.4关系操作 有两处的关系操作： cmpl$3,-20(%rbp)：argc!=3的关系判断（图3.4）； 图3.4argc!=3 cmpl$9,-4(%rbp)：i<10的关系判断（图3.5）； 图3.5i<10 3.3.5数组/指针操作 main的第二个参数为argv[]的char型指针数组，其中每个元素分别代表每一字符串的首地址，而在前面提到，argv保存在寄存器%rsi中，同时还保存在原栈底向上32位的处，在.L4一开始movq-32(%rbp),%rax指令把argv[0]存储的字符串地址传递给寄存器%rax，然后addq$16,%rax将%rax加16，即得到argv[2]的地址，接下来的movq(%rax),%rdx指令把argv[2]指向的字符串存储在寄存器%rdx中，之后的movq-32(%rbp),%rax、addq$8,%rax、movq(%rax),%rax同理，把argv[1]指向的字符串存储在寄存器%rax中，然后再movq%rax,%rsi传递给%rsi，然后%rdx和%rsi作为参数调用printf语句。 图3.6数组/指针操作 3.3.6控制转移 有两处的控制转移操作： 若argc等于3，则跳转到.L2处，不相等则继续下一步； 图3.7 若i大于9，则跳出循环，否则进行下一轮的循环； 图3.8 3.3.7函数操作 有四处的函数调用操作： 调用puts函数，其中.LC0处的字符串传给%rdi寄存器中，然后%rdi作为参数调用puts函数，进行输出（图3.9）；调用exit函数，程序终止（图3.9）； 图3.9 调用printf函数，上述中提到的argv[1]和argv[2]作为参数调用printf函数（图10）；调用sleep函数，将全局变量sleepsecs作为参数调用sleep函数进行休眠（图3.10）； 图3.10 3.4本章小结 本章主要对编译得到的汇编代码进行细致的分析，分析各种指令对应于C语言的含义以及相关的数据和操作的串联关联。 第4章汇编 4.1汇编的概念与作用 4.1.1概念 汇编是将hello.s翻译为机器语言指令，同时把这些指令打包为可重定位目标程序，并将结果保存到hello.o文件中； 4.1.2作用 将汇编代码翻译为机器可以识别的机器指令，可以在链接时与其他可重定位目标文件合并起来，创建一个可执行目标文件。 在Ubuntu下汇编的命令 gcc-chello.s-ohello.o 图4.1 4.3可重定位目标elf格式 4.3.1ELF头 ELF定义了ELF魔数、版本、小端/大端、操作系统平台、目标文件的类型、机器结构类型、程序执行的入口地址、程序头表（段头表）的起始位置和长度、节头表的起始位置和长度； 魔数：文件开头的16个字节，通常用来确定文件的类型或格式，加载或读取文件时，可用魔数确认文件类型是否正确； 图4.2ELF头信息 4.3.2节头表 除ELF头之外，节头表是ELF可重定位目标文件中最重要的部分内容； 描述每个节的节名、在文件中的偏移、大小、访问属性、对齐方式等； 图4.3节头表信息 4.3.3.rela.text节 .text节的重定位信息，用于重新修改代码段的指令中的地址信息，一般而言，任何调用外部函数或者引用全局变量的指令都需要修改，另一方面，调用本地函数的指令则不需要修改。 这是ELF重定位条目的格式： typedefstruct{ intoffset; inttype:32, symbol:32; longaddend; }Elf64_Rela; offset是需要被修改的引用的节偏移，指的就是.rela.text中的偏移量； symbol标识被修改引用应该指向的符号，对应的是.rela.text中的符号值和符号名称； type告知链接器如何修改新的引用，对应的是.rela.text中的信息和类型； addend是一个符号常熟，一些类型的重定位要使用它对被修改引用的值做偏移调整，对应的是.rela.text中的加数； 图4.4.rel.text节信息 4.3.4.rela.eh_frame节 .eh_frame节的重定位信息； 图4.5.rela.eh_frame节信息 4.3.5.symtab节 符号表，存放在程序中定义和引用的函数和全局变量的信息，但和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。 图4.6.symtab节信息 Hello.o的结果解析 使用命令objdump-d-rhello.o得到反汇编代码，对其与汇编代码进行对比分析，发现了一些不同之处： 4.4.1分支转移 hello.s得到的汇编代码进行分支转移时是借助了助记符.L4、.L2等，而对hello.o进行反汇编得到的代码分析可知，分支转移语句均使用PC偏移量进行跳转； 图4.7跳转语句1 图4.8跳转语句2 图4.9跳转语句3 4.4.2函数调用 hello.s得到的汇编代码进行函数调用是直接在指令后面跟着函数名，而在反汇编后的代码中，指令后面跟着的是需要在链接时进行重定位的地址，并将其添加到重定位条目； 图4.10调用puts函数 图4.11调用exit函数 图4.12调用printf函数 图4.13调用sleep函数 图4.14调用getchar函数 4.4.3数据 汇编代码调用puts和printf进行输出的两个字符串常量是通过两个助记符.LC0和.LC1，而反汇编代码是利用PC相对寻址和重定位来获取两个字符串常量，对于全局变量sleepsecs，汇编代码调用时直接利用sleepsecs的变量名作代表，而反汇编代码同样是利用PC相对寻址和重定位进行锁定。 图4.15原助记符.LC0对应的字符串 图4.16原助记符.LC1对应的字符串 图4.17sleepsecs全局变量 4.5本章小结 本章剖析了可重定位目标elf格式的构成，同时对汇编代码和可重定位目标文件的反汇编代码进行比较，明确了机器指令与汇编语言的映射关系。 第5章链接 5.1链接的概念与作用 5.1.1概念 将各种代码和数据片段收集并组合成为一个单一文件的过程。这个文件可被加载（复制）到内存并执行。 5.1.2作用 使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。 5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o /usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1 这段命令中dynamic-linker为动态链接器，指的是/lib64/ld-linux-x86-64.so.2，而我们使用ld非标准链接，因此需要crt1.o、ctri.o和crtn.o，crt1.o包含程序入口函数_start及两个未定义符号_libc_start_main和main，由入口函数调用_libc_start_main初始化libc，然后调用main函数，而crti.o和crtn.o辅助启动类似全局静态对象的代码。 5.3可执行目标文件hello的格式 5.3.1ELF头 与可重定位文件的ELF头稍有不同，可执行目标文件的ELF头中包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址：0x4010d0，在可重定位文件中则为0，其他部分均相似； 图5.2ELF头 5.3.2节头表 可执行目标文件的节头表与可重定位目标文件不同于地址空间，链接后，可执行目标文件的节头表中对应的每一个节的地址为虚拟地址。 .init节：用于定义_init函数，该函数用来进行可执行目标文件开始执行时的初始化工作，初始地址：0x401000，大小：0x1b； .text节：已编译程序的机器代码，初始地址：0x4010d0，大小：0x135； .rodata节：只读数据，比如printf语句中的格式串和开关语句的跳转表，初始地址：0x402000，大小：0x2f； .data节：已初始化的全局和静态C变量，初始地址：0x404040，大小：0x8； .bss节：未初始化的全局和静态C变量，大小：0x8； .symtab节：符号表，存放在程序中定义和引用的函数和全局变量的信息，大小：0x4c8； .debug节：调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件； .strtab节：字符串表，其内容包含.symtab和.debug中的符号表，以及节头部中的节名字，大小：0x150； .line节：原始C源程序中的行号和.text节中机器指令之间的映射。 图5.3节头表 图5.4节头表（续） 5.3.3程序头部表 描述了可执行文件的连续的片（chunk）被映射到连续的内存段的映射关系； 图5.5程序头部表 5.4hello的虚拟地址空间 1).init节对应的虚拟地址为：0x401000~0x40101a； 图5.6_init节对应的虚拟地址空间 2).text节对应的虚拟地址为：0x4010d0~0x401204； 图5.7.text节对应的虚拟地址空间 3).rodata节对应的虚拟地址为：0x402000~0x402002e； 图5.8.rodata节对应的虚拟地址空间 4).data节对应的虚拟地址为：0x404040~0x404047； 图5.9.data节对应的虚拟地址空间 5.5链接的重定位过程分析 可执行目标文件hello和可重定位目标文件hello.o的汇编代码是一致的，但两者的跳转指令、调用函数指令等后接的地址是不同的，hello.o的地址属于PC相对偏移，而对其进行重定位操作后，才能得到hello中可以由CPU直接访问的虚拟地址，并且对比反汇编文件，hello进行反汇编有更多的节，hello.o反汇编（objdump-d）得到的只有.text节，而hello反汇编得到的不止有.text节，还有.init、.plt、.fini和.plt.got节，.init节是程序初始化需要执行的代码，.plt和.plt.got节分别是动态链接中的过程链接表和全局偏移量表，.fini节是程序正常终止时需要执行的代码，因为库函数的代码已经链接到hello中，使得每个节更加完整。 下面详细介绍一下重定位具体步骤，重定位由两步组成： 重定位节和符号定义 在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成为输出的而可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 重定位节中的符号引用 在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构，在前面有提及重定位条目的数据结构，这里就不再赘述。 然后是重定位的具体算法，分为两块，一个是PC相对引用，另一个是绝对引用，而hello中的重定位只包含有PC相对引用，故下文我着重分析了重定位PC相对引用的算法： 重定位PC相对引用： 这里举个例子： 调用puts函数， ADDR(main)=0x401105； 图5.10main函数的地址 ADDR(puts)=0x401080； 图5.11puts函数的地址 puts函数在重定位节.rel.text中的偏移量为：0x21，addend值为-4； 图5.12.rela.text节中的相关信息 故，refaddr=ADDR(main)+offset=0x401105+0x21=0x401126； *refptr=(unsigned)(ADDR(puts)+addend-refaddr) =(unsigned)(0x401080+(-4)–0x401126)=(unsigned)(-0xaa)； 当CPU执行call指令时，PC的值为0x40112a，即紧随在call指令之后的指令的地址。 图5.13call指令之后的指令地址 PC<-PC+(-0xaa)=0x401080； 该地址正好是puts函数的第一条指令地址，故call指令成功调用了puts函数。 5.6hello的执行流程 子程序名地址ld-2.31.so!_dl_init0x7f9cf64fdf0hello!_start0x4010d0libc-2.31.so!_libc_start_main0x7f9cf746bfc0libc-2.31.so!_cxa_atexit0x7f9cf748ef60hello!_libc_csu_init0x401190libc-2.31.so!_setjmp0x7f9cf748ae00hello!main0x401105hello!puts@plt0x401030hello!exit@plt0x401060libc-2.31.so!exit0x7fe9f6f40bc0 图5.14edb调试hello的过程截图 5.7Hello的动态链接分析 程序调用由共享库定义的PIC函数，编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态连接器在程序加载的时候再解析它。不顾这种方法并不是PIC，因为它需要链接器修改调用模块的代码段，所以需要添加重定位记录，等待动态链接器处理，GNU编译系统使用延迟绑定技术，将过程地址的绑定推迟到第一次调用该过程时。 使用延迟绑定的动机是对于一个像libc.so这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用其中很少的一部分。把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用。 延迟绑定是通过两个数据结构的交互来实现的，这两个数据结构是GOT(全局偏移量表)和PLT（过程链接表）。如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT。GOT是数据段的一部分，PLT是代码段的一部分。图5.15展示了PLT和GOT如何协作在运行时解析函数的地址。 而其中我们关心的使GOT和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应与一个被调用的函数，其地址需要在运行时被解析。 图5.15用PLT和GOT调用外部函数 通过readelf查看节头表中的.got.plt信息，可知.got.plt节的开始地址为0x4040000，且大小为0x40； 图5.16.got.plt节地址 然后利用edb查看dl_init前后动态链接的变化，首先从edb的DataDump打开0x403000–0x405000范围内的数据，找出0x404000–0x40403f即为dl_init的数据段： 图5.17dl_init前 使用edb执行到dl_init，该段发生变化，变化为： 图5.18dl_init后 可以发现在dl_init后出现了两个地址，分别为0x7f9979380190和0x7f9979369bb0，这就是GOT[1]和GOT[2]，同样利用edb查看GOT[2]内容，可以发现是动态链接函数： 图5.19动态链接函数 5.8本章小结 本章分析了链接的指令以及链接产生的可执行目标文件hello的格式，同时解析了hello的虚拟地址空间还有重定位和动态链接的具体过程及算法。 第6章hello进程管理 6.1进程的概念与作用 6.1.1概念 一个执行中的程序的实例，同时也是系统进行资源分配和调度的基本单位。一般情况下，包括文本区域、数据区域和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。 6.1.2作用 进程能够提供给应用程序关键抽象： 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器； 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 6.2.1作用 Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至时编写一些程序。Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令，能够交互性地解释和执行用户输入的命令，能够通过调用系统级的函数或功能来执行程序、建立文件、进行并行操作，还能够协调程序间的运行冲突，保证程序能够高效执行，与此同时，bash还提供了一个图形化的界面。 6.2.2处理流程 Shell首先打印一个命令行提示符，然后从终端（terminal）中获取用户输入的命令然后对此命令分割命令行参数，然后对此进行重构若第一个参数是一个内置的shell命令，则直接调用内部函数执行若不是内置的shell命令且是一个可执行目标文件，则创建新的子进程，在子进程的上下文中加载运行该文件最后判断该程序是在前台执行还是在后台执行，如果是在前台执行则等待进程结束，若是在后台执行，则直接等待用户的下次的命令行输入 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的子进程； pid_tfork(void); 新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和子进程最大的区别在于它们有不同的PID。 fork函数只被调用一次，却会返回两次。一次是在调用进程中，一次是在新创建的子进程中。在父进程中，fork返回子进程的pid，在子进程中，fork返回0。因为子进程的PID总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。 创建过程： 给新进程分配一个标识符在内核中分配一个PCB（进程管理块），将其挂在PCB表上复制它的父进程的环境（PCB中大部分的内容）为其分配资源（程序、数据、栈等）复制父进程地址空间里的内容（代码共享，数据写时拷贝）将进程设置成就绪状态，并将其放入就绪队列，等待CPU调度 6.4Hello的execve过程 execve函数在当前进程的上下文中加载并运行一个新程序。 intexecve(constchar*filename,constchar*argv[],constchar*envp[]); execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境遍历列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。所以，与fork一次调用返回两次不同，execve调用一次并从不返回。 在execve加载了filename后，它调用驻留在内存中的启动加载器的操作系统代码以此执行hello程序，加载器删除子进程现有的虚拟内存段，并创建一组新的人代码、数据、堆和栈，栈和堆被初始化为0，通过虚拟地址映射到可执行目标文件的片，新的代码和数据段被初始化为可执行文件中的内容，然后跳转至_start函数，_start函数调用系统启动函数_libc_start_main进行初始化，最后调用主函数main。 6.5Hello的进程执行 操作系统内核使用一中称为上下文切换的较高层形式的异常控制流来实现多任务。 内核为每个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态，它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程一打开文件的信息的文件表。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策叫做调度，是由内核中称为调度器的代码处理的，当内核选择一个新的进程运行时，就说内核调度了这个进程。当内核调度了一个新的进程运行后，它就抢占当前进程，并通过上下文切换的机制将控制转移到新的进程。 上下文切换的流程为： 保存当前进程的上下文恢复某个先前被抢占的进程被保存的上下文将控制传递给这个新恢复的进程 当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个时间发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。如read系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另一个进程；sleep系统调用显式地请求让调用进程休眠。 中断也可能引发上下文切换。所有系统都有某种产生周期性定时器中断的机制，每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。 下图展示了一对进程A和B之间上下文切换的示例： 图6.1进程的上下文切换 6.6hello的异常与信号处理 程序运行过程中键盘不停乱按或者回车都不会影响输出，而在输出的循环结束了之后，程序调用getchar函数，读入了原先在运行过程中键盘乱按出的一行内容，并且后续乱按的内容也被不断地当成命令读入，说明在hello运行过程中，额外的输入会被缓存到输入缓冲区，直到程序结束后读出。 图6.2在运行过程中乱按 在hello运行的过程中按Ctrl+Z，进程停止； 图6.3Ctrl+Z进程停止 然后通过ps命令，可以查看当前进程的状态： 图6.4ps查看进程状态 jobs命令获取任务列表和任务的状态： 图6.5jobs获取任务列表 pstree命令查看进程树： 图6.6pstree查看进程树 图6.7进程树（续1） 图6.8进程树（续2） 图6.9进程树（续3） fg指令，将后台作业挂在前台： 图6.10fg命令 kill-92942杀死hello进程： 图6.11kill杀死hello进程 hello运行过程中按下Ctrl+C，程序直接终止： 图6.12Ctrl+C直接终止进程 6.6.1异常 异常可分为四类：中断、陷阱、故障和终止； 1）中断 中断是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为中断处理程序。 当中断处理程序返回时，它就将控制返回给下一条指令。结果是程序继续执行，就好像没有发生过中断一样。 2）陷阱 陷阱是有意的异常，是执行一条指令的结果。 陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。 用户程序经常需要像内核请求服务，为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的“syscalln”指令，当用户程序想要请求服务n时，可以执行这条命令。执行syscall指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。 3）故障 由错误情况引起的，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序，如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。 4）终止 终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。 6.6.2信号处理 这里只说明上述截图中涉及的信号处理； Ctrl+C：内核会发送一个SIGINT信号给这个前台进程组中的每个进程，默认情况下，结果为终止前台进程组； Ctrl+Z：内核会发送一个SIGTSTP信号到前台进程组中的每个进程，默认情况下，结果是挂起前台作业； kill-9：发送一个SIGKILL信号强制终止进程； 6.7本章小结 本章首先介绍了进程和shell，然后剖析了Hello通过调用fork函数创建子进程的过程和execve函数在当前进程的上下文加载并运行一个新程序的过程，最后演示了hello的异常和信号处理机制。 第7章hello的存储管理 7.1hello的存储器地址空间 7.1.1逻辑地址 也叫做相对地址，是由程序产生的与段有关偏移地址，用来指定一个操作数或是一条指令的地址，其格式为：段地址：段偏移量； 7.1.2线性地址 地址空间是一个非负整数地址的有序集合，而如果地址空间中的整数时连续的，那么我们可以说它时一个线性地址空间； 7.1.3虚拟地址 程序运行在保护模式下，程序访问存储器所使用的逻辑地址称为虚拟地址，虚拟内存被组织为一个存放在磁盘上的N个连续的字节大小的单元组成的数组，其每个字节对应的地址称为虚拟地址； 7.1.4物理地址 计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，其每个字节都被赋予一个唯一的地址，这个地址称为物理地址，物理地址同样也是计算机的硬件中的电路进行操作的地址。 对hello进行反汇编得到的每一节所在的地址均是逻辑地址的段偏移量部分，而段偏移量加上段基址即为虚拟地址，在这里虚拟地址与线性地址相同，而Linux的所有段基址均是0，所以此时逻辑地址与虚拟地址是相同的。 7.2Intel逻辑地址到线性地址的变换-段式管理 分段功能在实模式和保护模式下是不同的； 实模式下，逻辑地址和线性地址和物理地址是相等的，段寄存器存放真实的段基址，再根据32位的段地址偏移量即可访问物理内存； 保护模式下，内存管理单元先是依据16位的段选择符（段选择符如图7.1）中的TI确定选择GDT（全局描述符）还是LDT（局部描述符表），确定完之后，再通过段选择符的13位索引值从选中的描述符表中寻找对应的段描述符，而每个段描述符占8个字节，因此位移量位索引值乘8，再加上描述符表首地址，因此确定了选中的段描述符的地址，以此得到32位的段地址，最后加上偏移地址，就可以得到32位的线性地址了。（整体过程如图7.2） 图7.1段选择符的16位格式 图7.2整体过程 7.3Hello的线性地址到物理地址的变换-页式管理 概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存（较高层）之间的传输单元。VM系统通过将虚拟内存分割位称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P=2P字节。类似地，物理内存被分割为物理页，大小也为P字节。 在任意时刻，虚拟页面的集合都分为三个不相交的子集： 未分配的：VM系统还未分配的页。缓存的：当前已缓存在物理内存中的已分配页。未缓存的：未缓存在物理内存中的已分配页。 而页表将虚拟页映射到物理页，每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。 下图为一个页表的基本组织结构。页表就是一个页表条目的数组。虚拟地址空间中的每个页在页表中一个固定的偏移量处都有一个PTE，假设每个PTE是由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。 图7.3页表 下图展示了内存管理单元如何利用页表来实现这种映射。CPU中的一个控制寄存器，页表基址寄存器指向当前页表。N位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。MMU利用VPN来选择适当的PTE，将页表条目中物理页号和虚拟地址中的VPO串联起来，就得到相应的物理地址。 图7.4使用页表的地址翻译 7.4TLB与四级页表支持下的VA到PA的变换 TLB被称为翻译后备缓冲器，是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。如下图所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。 图7.5TLB的组成 图7.6a展示了当TLB命中时所包括的步骤： CPU产生一个虚拟地址；MMU从TLB中取出相应的PTE；MMU将此虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存；高速缓存/主存将所请求的数据字返回给CPU。 当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，如7.6b所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。 图7.6TLB命中和不命中的操作图 下图描述了四级页表下的VA到PA的变换即进行地址翻译。虚拟地址被划分位4个VPN和1个VPO。每个VPNi都是一个到第i级页表的索引。第j级页表中的每个PTE，都指向第j+1级的某个页表的基址。第k级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN之前，MMU必须访问k个PTE。 36位VPN被划分为4个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 图7.7使用4级列表的地址翻译 7.5三级Cache支持下的物理内存访问 虚拟地址通过地址翻译得到物理地址后，MMU发送物理地址给L1缓存，缓存从物理地址中抽取出缓存偏移CO、缓存组索引CI以及缓存标记CT，若标记匹配，缓存命中的话，则读出在偏移量CO处的数据字节，并将它返回给MMU，随后MMU将它传递给CPU，若缓存未命中的话，则从L2缓存中进行匹配，若命中则将其存储在L1缓存且返回给MMU，若不命中，则从L3缓存中进行匹配，若命中则将其存储与L2缓存和L1缓存，而后返回给MMU，若不命中，则从主存中寻找。下图为一个四级页表和三级Cache支持下的物理内存访问： 图7.8四级页表和三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 若hello进程fork创建的子进程试图写私有区域内的某个页面，那么写操作就会触发一个保护故障，当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限，如下图。当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。 图7.9进程2写了私有区域的一个页之后 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并允许包含了可执行文件hello中的程序，用hello程序有效地替代了当前程序。加载并允许hello需要以下一个步骤： 1. 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2. 映射私有区域。为hello程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零，下图概括了私有区域的不同映射。 3. 映射共享区域。如果hello与共享对象或目标链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 4. 设置程序计数器PC。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 下一次调度这个进程时，它将从这个入口点开始执行。Linux根据需要换入代码和数据页面。 图7.10加载器是如何映射用户地址空间的区域的 7.8缺页故障与缺页中断处理 当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。然后调用缺页处理程序，缺页处理程序就执行下面步骤： 查看虚拟地址是否合法，若不合法，那么缺页处理程序就触发一个段错误，从而终止这个进程；查看试图进行的内存访问是否合法，如果试图访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程；选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送虚拟地址到MMU，MMU就能正常翻译它了，而不会再产生缺页中断了。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显示地被应用所分配。一个已分配的块保持已分配状态，直到它被释放。 分配器有两种基本风格，显式的和隐式的。 显式分配器，要求应用显式地释放任何已分配的块。如C标准库提供的malloc程序包显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。 隐式分配器，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集。 任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。 一个块是由一个字的头部、有效载荷、以及可能的一些额外的填充组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是0。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。 头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。 假设块的格式如下图所示： 图7.11堆块格式 我们可以将堆组织为一个连续的已分配块和空闲块的序列，如下图所示： 图7.12隐式空闲链表 我们称这种结构称为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。 空闲块的组织通过以下的技术进行： 1. 放置已分配的块 当应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大的可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略确定的，一些常见的策略是首次适配、下一次适配和最佳适配。 首次适配从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配从上一次查询结束的地方开始搜索。最佳适配检查每个空闲块，选择适合所需请求大小的最小空闲块。 2. 分割空闲块 一旦分配器找到一个匹配的空闲块，就必须考虑分配这个空闲块中的多少空间。一个选择是用整个空闲块。 但如果匹配不太友好，则分配器通常会选择将这个空闲块分割为两部分。第一部分变成分配块，剩下的部分变成一个新的空闲块。 3. 获取额外的堆内存 如果分配器不能为请求块找到合适的空闲块，一个选择是通过合并那些在内存中物理相邻的空闲块来创建一个更大的空闲块。如果这样还是不能生成一个足够大的块，或者如果空闲块已经最大程度地合并了，那么分配器就会通过调用sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。 4. 合并空闲块 带边界标签的隐式空闲链表分配器允许在常数时间内进行对前面块的合并。是在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。 使用边界标记的堆块的格式如下图： 图7.13使用边界标记的堆块格式 7.10本章小结 本章主要介绍了hello的存储地址空间，Intel的段式管理和页式管理，同时还剖析了四级页表下从虚拟地址到物理地址的变换和三级Cache的支持下物理内存访问，还解析了hello进程fork和execve时的内存映射，同时还包括缺页中断处理程序的进行步骤和动态存储分配管理，页表映射贯穿整章，重要性显而易见。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 一个Liunx文件就是一个m个字节的序列：B0，B1，…，Bm-1。所有的I/O设备都被模型化为文件。 文件的类型： 普通文件包含任意数据。应用程序常常要区分文本文件和二进制文件，文本文件是只含有ASCII或Unicode字符的普通文件；二进制文件是所有其他的文件。对内核而言，文本文件和二进制文件没有区别；目录是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录；套接字是用来与另一个进程进行跨网络通信的文件。 设备管理：unixio接口 所有的输入和输出都被当作对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 8.2.1UnixIO的执行方式 打开文件：应用程序要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记录这个描述符。 Shell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。 改变当前的文件位置。对于每个打开的文件，内核保存着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会触发一个称为EOF的条件，应用程序能检测到这个条件，在文件结尾处并没有明确的“EOF”符号。 关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为相应，内核释放打开文件时创建的数据结构，并将描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 8.2.2UnixIO函数 通过调用open函数来打开一个已存在的文件或者创建一个新文件： intopen(char*filename,intflags,mode_tmode); open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，flags参数也可以是一个或者更多位掩码的或，为写提供一些额外的指示；mode参数指定了新文件的访问权限位； 进程通过调用close函数关闭一个打开的文件： intclose(intfd); 应用程序是通过分别调用read和write函数来执行输入和输出的。 ssize_tread(intfd,void*buf,size_tn); ssize_twrite(intfd,constvoid*buf,size_tn); read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall。字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 va_listarg=(va_list)((char*)(&fmt)+4)初始化变元指针arg，然后printf调用了vsprintf函数，vsprintf函数将printf的参数按照各种各样格式进行分析，将输出的字符串保存于buf中，最终返回要输出的字符串长度，然后保存在i中；最后，printf调用write系统函数，进行输出。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 用户按下键盘后，键盘接口得到一个代表该按键的键盘扫描码，与此同时会产生一个中断请求，运行键盘中断子程序，先从键盘接口取得该按键的扫描码，而后扫描码被转换为ASCII码，保存到键盘的缓冲区当中。 getchar调用read函数，read函数通过sys_call调用内核中的系统函数，将存储在键盘缓冲区中的ASCII码进行读取直到遇到回车符，然后返回整个字符串，，getchar函数只读取第一个字符，其他字符存储到输入缓冲区。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法，还列出了UnixIO的接口和函数，最重要的部分是printf和getchar的分析，这两个函数在调用系统函数下还实现了额外的功能。 结论 预处理，将放置在源文件的预处理指令修改源文件内容，预处理器cpp将hello.c转换为hello.i编译，将高级语言源程序编译为汇编语言程序，编译器ccl将hello.i编译成汇编文件hello.s汇编，将汇编代码转换为计算机能够识别的机器指令，汇编器as将hello.s进行翻译得到可重定位目标文件链接，将可重定位目标文件与标准库进行链接，是程序可以加载到内存中来执行，链接器ld将hello.o与动态链接库链接生成可执行目标文件运行时，父进程通过调用fork创建子进程，通过调用execve在子进程上下文加载新的程序，在进程执行过程中可能会出现一些异常，此时内核会调用处理程序进行相关处理程序加载到内存，CPU通过MMU对虚拟地址进行翻译，再进行数据的读写UnixIO能够实现对输入的处理和进行相对应的输出程序终止，回收子进程 计算机系统的设计与实现真的让我感到不可思议，复杂但每一处的逻辑都紧紧相连，这门课让我对计算机的组成和结构有了大致的了解，其中有很多地方让我印象深刻，如优化程序性能，这是单纯敲写代码也学习体会不到的，高速缓存的实现机制也让我倍感新奇。在完成大作业的过程中，有很多地方也让我收获颇丰，预处理阶段预处理指令的处理、使用edb查看从程序执行到结束的调用子程序的过程。我还有很长的路要走，其中的构建还需探索。 附件 hello.c：C语言源程序 hello.i：hello.c预处理得到的.i文件 hello.s：hello.i经过编译得到的汇编代码.s文件 hello.o：hello.s经过汇编得到的可重定位目标.o文件 hello：hello.o与库函数的链接得到的可执行目标文件 helloo.txt：hello.o的反汇编文件，查看反汇编代码 hello.txt：hello的反汇编文件，查看反汇编代码 helloo.elf：hello.o的elf文件，查看各节的信息 hello.elf：hello的elf文件，查看各节信息 参考文献 [1] 常用预处理指令：https://blog.csdn.net/qq_43630810/article/details/108786500 [2] 程序预处理阶段，在做什么： https://blog.csdn.net/localhostcom/article/details/108165432 [3] AT&T汇编伪指令： https://blog.csdn.net/shisiye15/article/details/7696941?locationNum=4&fps=1 [4] C语言编译过程详解，预处理，编译，汇编，链接： https://blog.csdn.net/wuhuaguo1992/article/details/103400202?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-3.control [5] Shell基础之Bash的基本功能： https://blog.csdn.net/u010456903/article/details/48735969 
第91篇文章[]
新添加jar包，IDEA的maven工程pom.xml添加新的依赖时报错（TravisCI在线build） 笔者因为写JUnit测试用例时用到了assertThat(MapObject,hasEntry("key","value")); IDEA报错但根据提示仍不知道原因，后面才知道原来需要一个jar包--hamcrest-all.jar 从https://search.maven.org/search?q=g:org.hamcrest中下载了该包并将其移动到 .m2\repository\org\hamcrest目录下，然后从IDEA的ProjectStructure中添加了该包 一开始没添加依赖到pom.xml，直到要上传到GitHub并且在TravisCI进行在线build的时候，才添加依赖于pom.xml中，但出现了报错（因为之前问题解决了，所以现在hamcrest-all和它的version不报错了，这里拿hamcrest-library做实验），出现红字： 可以先在IDEA右侧的maven处点击reload： 如果字体不红的话问题就解决了， 但如果还不行的话，可能就要把jar包安装到本地仓库 当然前提是你需要安装和配置maven（教程挺多的） 安装配置后然后打开cmd，首先cd到你放置你新安装jar包的目录下， 然后输入：（这里拿hamcrest-all-1.3为例） mvninstall:install-file-DgroupId=org.hamcrest -DartifactId=hamcrest-all -Dversion=1.3 -Dpackaging=jar -Dfile=hamcrest-all-1.3.jar 其中-DgroupId、-DartifactId、-Dversion均可以在依赖中看到， （能查看添加依赖的网站：https://mvnrepository.com） -Dpackaging为包的类型，即jar -Dfile是当时新添加的包的名字。 输完命令后回车，然后若提示BUILDSUCCESS，则jar包安装到本地仓库成功。 成功后回到IDEA下再次reload。 
第92篇文章[]
EclipseIDE的统计代码覆盖度工具EclEmma 首先，EclEmma是一个开源的软件测试工具，可以统计代码覆盖率覆盖率。 代码覆盖率用来刻画在软件测试里，被测试的程序的代码被测试的比例和程度。 在JUnit测试时，被测试代码被调用的比例是由代码在JUnit里使用的情况决定的。 EclEmma的安装：在Eclipse的Help中选取EclipseMarketplace 然后搜索EclEmma，点击Install即可直接安装EclEmma工具。 安装完毕后，右键选取你需要统计代码覆盖度的代码文件，选取CoverageAs，再选取JunitTest就可以测试出在Junit测试中的统计代码覆盖度。 调用后可以看见如图的标识： 绿色表示代码在JUnit测试中被执行到，黄色表示代码在JUnit测试中被部分执行到，红色表示代码没有在JUnit测试被执行到。 下方也有对于代码覆盖度的总体统计，最具体可以查看某个函数的代码覆盖度的数据。 
第93篇文章[]
Java环境的配置 课程最开始配置Java环境，但是完全没有学习过Java。之前学习C语言，编译器和环境只需要直接安装一个软件即可，而对于Java的环境配置很复杂，最后从Mooc上的新手课程中才搞清楚各种环境的关系。 对于Java的在官网上，环境相关的有JVM，JDK，JRE，JSE。各个文件分别对应的功能如下：JVM：Java虚拟机，Java编译过后的.class文件需要在JVM上运行，是Java可以跨平台的原因。 JRE:Java运行环境，包含了JVM和Java程序所需的核心类库。如果只是需要运行一个开发好的Java程序，我们只需在计算机中安装JRE即可。 JDK:Java开发工具包，包含了Java的开发工具、编译工具、打包工具。如果需要进行Java编程，就需要下载JDK。 三者的关系：JDK包含了JRE，JRE包含了JVM 下载安装好对应的环境以后，与C语言不同的是，你需要自行下载编译器，Java环境里是不具有编译器，既编辑代码的功能的。推荐安装Eclipse作为编译器。通过Eclipse即可开始Java编程了！ 
第94篇文章[1]
程序人生-Hello’sP2P 计算机系统大作业 题 目 程序人生-Hello’sP2P 专 业 计算机 学 号 1190200303 班 级 1936602 学 生 程明明 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文通过简单的hello程序为切入，详细阐述了一个程序如何由源代码通过预处理、编译、汇编、链接等步骤成为可执行程序，同时通过进程管理、存储管理、IO管理等系统机制使得程序能够在操作系统中正确运行的过程。并以此为契机将计算机的各种机制和操作原理结合已经学习的知识正确阐述出来。 关键词：程序人生；计算机系统；预处理；编译；汇编；链接；系统管理；CSAPP （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 由键盘输入，形成hello.c文件。然后将hello.c文件通过预处理、编译、汇编、链接，历经艰辛得到一个可执行目标文件。然后在Shell中通过命令运行该可执行文件，读取到运行的命令行，调用fork函数创建一个新的子进程，再调用execve在内存里开辟空间，将hello文件复制到开辟的空间，运行hello进程，通过IO管理输出，当程序运行结束后，由shell或者init清除空间和痕迹，最终回到程序运行前的状态，就像没有hello来过一样。 1.2环境与工具 硬件环境：Inteli5@2.4GHz，16GBRAM；256GHDDisk 软件环境：Windows1064位，VirtualBox；Ubuntu16.04LTS64位 开发工具：gcc，objdump，gdb，readelf，vim 1.3中间结果 hello.c：老师提供的源文件。 hello.i：预处理后产生的文件，用于查看预处理过程。 hello.s：编译后产生的汇编文件，查看编译过程。 hello.o：汇编产生二进制的可重定位目标文件.o，无法直接查看。 hello：生成的可执行程序。 hello.oelf：通过ELF工具查看hello.o而产生的文件，记录了hello.o的ELF格式。 hello.elf：通过ELF工具查看hello而产生的文件，记录了hello的ELF格式 helloo.txt：hello.o的反汇编文件，用于查看和与汇编前的hello.s进行比较。 hello.txt：hello的反汇编文件，查看链接后的反汇编以及与helloo.txt进行比较查看链接过程。 1.4本章小结 本章概述了hello的P2P与O2O过程，展示了实验的环境和中间结果。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 概念：预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。通常会将#起始的代码对整个代码进行替换与分割处理。 作用：预处理包括是对宏定义、文件包含、条件编译三个方面的处理。会对于宏定义进行替换，对于文件包含，会导入包含的文件与头文件中的内容，而条件编译指令决定编译程序代码处理的范围。最终使得代码更简单直接和完整，便于进一步处理。预处理生成hello.i文件。 2.2在Ubuntu下预处理的命令 命令：gcc-m64-no-pie-fno-PIC-Ehello.c-ohello.i 截图： 2-1.预处理命令 2-2.预处理结果 2.3Hello的预处理结果解析 删去注释。hello.c代码中的预处理指令有三条，预处理器找到这三个头文件的定义文件，然后所有的内容全部到复制到hello.i当中。函数主体部分基本没有变化。 2.4本章小结 通过预处理，将hello.c中三个头文件的内容全部包含在了文件中，将代码的注释部分删除，使得代码文件更简单直接和完整，便于进一步处理。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：通过编译器，将hello.i文件转变成汇编文件。转变过程中，编译器还会分析并优化c代码，最终得到hello.s。 作用：不仅能够将c代码翻译成机器更加容易理解的汇编语言，而且编译的过程中还会对代码进行分析优化，让其有更好的效率。 3.2在Ubuntu下编译的命令 命令：gcc-m64-no-pie-fno-PIC-Shello.i-ohello.s 截图： 3-1.输入的命令 3.3Hello的编译结果解析 常量： 3-2.常量存储 在只读数据rodata段里存储了字符串常量.LC0和.LC1，对应了两个printf函数的内容。而如3，10等数字常量都以立即数的形式存在于汇编代码中。 全局变量： 3-3.全局变量存储 存在一个全局变量sleepsecs，赋值为2.5，可以看出编译器将其从int型的变量优化为long型，进行了隐式的类型转换。sleepsecs被存放在.rotate节中。 局部变量： 3-4.局部变量存储 首先由%rsp开辟了一个栈空间。虽然局部变量i在代码里被首先声明，但是观察汇编文件发现，没有为其开辟空间。仅仅当需要使用i时，转跳至.L2，申请了栈里的空间，暂存在-4（%rbp）中，并且被初始化为0。 赋值： 由于全局变量的赋值直接在处理时在.data节声明，初始化为值为2的long型变量。对于局部变量的赋值使用mov语句完成，找到其存储的栈空间或者寄存器，直接对值使用mov语句。 算术操作： 3-5.循环变量自加一 hello.c仅仅存在加法操作，对于局部变量i在循环后自加1。直接对于i所存储的栈空间的值用addl命令加即可。 逻辑操作： 存在判断是否相等与大小的判断。 3-6.判断是否等于3 判断参数是否等于3，利用cmpl指令即可完成。 3-7.判断是否小于等于9 对于比较大小，也使用cmpl指令。可以发现，<10被编译器优化成了<=9，这样就可以直接使用指令完成比较。 数组与指针操作： 3-8.访问数组 程序中访问了argv数组的元素。数组本质为一串相连的存储空间，所以通过基地址加上偏移量的方式访问数组元素。而argv数组的起始地址-32(%rbp)，通过对%rax寄存器加16来访问argv[2]传递给%rdx，同理%rax寄存器加8来访问argv[1]并传递给%rax，最后将%rdx和%rax寄存器中的值作为参数传递给printf函数来输出。 函数操作： 分别调用了exit函数，printf函数，sleep函数和getchar函数。 3-9.调用exit函数 对于exit函数只有一个参数，于是通过将1赋值给%edi，来传递参数。 3-10.传递参数 该函数实际上系统函数，功能是暂时挂起进程。它以sleepsecs作为参数，将值传递到%eax,然后将%eax的值赋值给第一个参数寄存器%edi，最后通过%edi将值传入sleep使用。 3-11.调用puts函数 第一次的printf函数被优化成了puts函数，直接将.LC0作为参数写入%edi寄存器，然后作为参数传递。 3-12.调用printf函数 第二次printf函数就直接编译为printf函数，参数argv[1]和参数argv[2]被从栈中复制到寄存器%rdx和%rax中，常量字符串地址则保存在寄存器%edi中作为参数传入。 3-13.调用getchar函数 getchar函数的原型是没有参数的，所以它没有参数，因此不会使用到参数寄存器。 3.4本章小结 通过编译器，将hello.i文件转变成汇编文件hello.s。通过对比，能够清晰认识到代码转换的方式及优化。让其有更好的效率和更加适合机器运行。离翻译成二进制机器语言以便机器运行又更近了一步。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：汇编就是把汇编文件hello.s经过处理转化成二进制形式的可重定位目标文件.o，这样机器可以直接识别。 作用：由汇编指令到机器指令，机器可以直接识别。 4.2在Ubuntu下汇编的命令 命令：gcc-m64-no-pie-fno-PIC-chello.s-ohello.o 4-1.输入的命令 4.3可重定位目标elf格式 4-2.ELF文件头 ELF头： 展示了机器和文件的最基本信息。 4-3.ELF节头部表 节头部表： 展示了各个节的大小、类型、地址、偏移量各种信息，方便查找。 4-4.ELF重定位节 重定位节： 这部分描述了需要重定位的信息，这些信息在生成可执行文件时就会被重定位。可以发现在hello.o中需要被重定位的有.radata,puts,exit,printf,sleepsecs,sleep,getchar等。 4-5.ELF符号表 符号表： 记录和列举了程序中用到的函数和全局变量等符号。 4.4Hello.o的结果解析 4-6.反汇编文件 4-7.hello.s汇编文件 通过objdump-d-rhello.o得到hello.o的反汇编，与hello.s进行对比，发现基本相同，但是也存在差异。 首先是操作数的格式，由十进制变为了十六进制补码格式，因为hello.o文件已经是二进制文件形式了。除此之外，在汇编语言中，分支转移的跳转位置都是用.L3,.L4来表示的，但在机器语言中它们被偏移量表示的内存地址所替代。调用函数也不相同，在汇编语言中，函数的调用都是用函数名来跳转的，但在机器语言中它们调用的是一个待重定位的相对地址。 4.5本章小结 分析了hello.o的elf格式，对其结构有进一步认识。除此之外，利用hello.o的反汇编代码展示了二进制机器语言文件的格式和特性。由hello.o与hello.s的对比可以发现从汇编代码到机器语言的过程是完全按照对应的转换关系的。留下了可重定位的标记和地址填充的标记，为链接提供条件。 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：链接器通过符号解析（Symbolresolution）和重定位两个过程，赋予符号表中的符号唯一定义，并将被链接文件中的分散的代码片段组织起来，生成一个完全链接的可执行对象文件的过程。 作用：链将各种代码和数据片段收集并组合成为一个单一文件的过程，让程序能够完整的载入内存并运行。链接使得分离编译成为可能，能够将一个大型的应用程序拆分为较小的模块，而只要修改和编译这些模块，再将其重新就可以完成对整个应用程序的修改，而不必重新编译未修改的文件，大大节约了时间和人力成本。 5.2在Ubuntu下链接的命令 ld-oHello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5-1.输入的命令 5.3可执行目标文件hello的格式 观察可以发现其程序头由13个增加到26个。详细信息如下： 5-2.ELF文件中26个程序头 5.4hello的虚拟地址空间 5-3.EDB界面 地址由0x401000开始，结束于0x401ff0。 5.5链接的重定位过程分析 观察可以发现其节头表由13个增加到26个，多出来的分别为： interp，.note.ABI-tag，.hash，.gnu.hash，.dynsym，.gnu.version，.gnu.version_r，.rela.dyn，.rela.plt，.init，.plt，.plt.sec，fini，.got，.got.plt等。这些都来自于动态共享库，在链接的过程插入到了原来的节当中。 5-4.链接前的ELF文件 5-5.链接后的ELF文件 很明显可以发现hello.o中main函数的地址并没有确定，为0x0000，而在链接之后确定了地址，一些具体函数的调用在hello.o中只是以相对位置于main函数的偏移地址，而在hello中给出了绝对地址。在hello.o需要重定位的信息在hello中已经全部填充，hello是一个完整的文件。 重定位时：先将各个文件合并，然后程序中将需要链接的符号于符号表中进行查找，找到后将其内存地址填充到重定位标记处。 5.6hello的执行流程 5-6.ELF文件 执行过程中的进程分别为： 0x401000<_init>； 0x401020<.plt>； 0x401080<puts@plt>: 0x401090<printf@plt>: 0x4010a0<getchar@plt>: 0x4010b0<exit@plt> 0x4010c0<sleep@plt>: 0x4010d0<_start>: 0x401100<_dl_relocate_static_pie>: 0x401105<main>: 0x401190<__libc_csu_init>: 0x401200<__libc_csu_fini>: 0x0401208<_fini>: 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 5.8本章小结 本章通过对链接前后的程序的ELF格式和反汇编代码的比较，体现了链接前后的区别以及链接的过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：进程是一个执行中程序的实例，它的上下文提供了程序运行所需的状态。 作用：进程为应用程序提供了两个关键抽象，分别是逻辑控制流和私有地址空间。 6.2简述壳Shell-bash的作用与处理流程 Shell是Linux操作系统内核提供给用户的交互程序。它为用户提供了向内核传递命令的窗口。 处理流程：Shell首先获得输入的字符串，通过读入命令行或者文件的内容，结果是得到字符串。对字符串进行解析，通过元字符将其分割为词汇，检查词汇是否为内置命令的关键字，若是内置命令，直接执行。否则认为是程序文件，在当前目录下查找是否有对应的程序文件。若找到，直接建立进程和上下文，加载程序文件，让系统内核运行。程序运行后等待其退出并回收进程。 6.3Hello的fork进程创建过程 父进程调用fork函数，创建一个子进程，子进程具有与父进程虚拟地址空间相同却独立的副本，且具有不同的pid。两个进程的代码、数据段、堆、共享库以及用户栈均相同，所以子进程可以访问父进程的文件。Fork函数调用一次返回两次，在父进程中返回子进程的pid，在子进程中返回0. 当我们在shell中输入./hello1190200303程明明的时候，shell先进行命令解析，判断hello是一个当前目录下的可执行目标文件，通过fork过程创建子进程。 6.4Hello的execve过程 execve函数加载并运行可执行目标文件，函数原型为intexecve(const*filename,constchar*argv[],constchar*envp[])。通过读入可执行文件filename，argv是参数列表，envp是环境变量列表。对当前进程的上下文加载一个进程，直接覆盖了原先利用fork函数创建的进程。并且execve函数只有在调用失败之后才会返回-1，这与fork函数调用一次返回两次是不同的，它调用一次从不返回。 当fork子进程后，调用execve函数，直接覆盖了原先利用fork函数创建的子进程，然后重新创建一组新的代码、数据、堆和栈段。新的堆和栈的段被初始化为0，通过虚拟地址空间中的页映射到可执行文件的页大小的片。新代码被初始化为可执行文件的内容。最后加载器跳转到_start处运行程序。 6.5Hello的进程执行 Shell根据特定算法为所有进程分配时间片，包括hello程序进程。当到了hello程序运行的时间片时，首先加载hello的进程上下文信息，然后从控制从内核转换到hello程序。在hello程序中，我们认为它的进程被抢断发生在sleep发生的时候，调用了sleep(sleepsecs);，休眠了2秒，使得hello时间片结束而将控制返还给内核，此时要保存hello的进程上下文信息，然后根据下一时间片到来时，进程重新执行上述过程，所以程序应该输出十次，但每一次输出中间会出现2秒的间隔。 6-1.运行程序 6.6hello的异常与信号处理 6-2.回车处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 对于回车的异常，完全没有影响，只会改变输出的位置。 6-3.Ctrl-Z处理 Ctrl-Z的异常会导致发送一个SIGSTP信号给shell父进程。信号处理函数将hello进程挂起但并不结束，可使用fg命令可以把被挂起的hello重新调度到前台运行，继续将剩下的步骤运行完。 6-4.Ctrl-C处理 Ctrl-C的异常会发送SIGINT信号给shell父进程，使得将hello进程挂起并结束，此时hello进程已经结束。 6-5.乱按处理 随便乱按，Shell会随时用一个getchar函数监听输入的字符，并且分析读入的字符串，当字符串符合命令，就认为输入了命令然后执行，否则程序正常运行。 6.7本章小结 Shell是Linux用于对用户命令交互的应用程序，对于接收的命令行执行对应的可执行文件或者内置命令。而shell执行程序的方式为先构造要传递给execve函数的字符串组，fork子进程，并设置进程组id，然后调用execve函数，根据传入的字符串组复制可执行程序到内存执行。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：指的是在机器语言中，是为一个偏移地址，是由一个段标识符加上段内相对地址的偏移量，表示为[段标识符：段内偏移量]。在hello的程序里说即是hello.o里面的相对偏移地址。 线性地址：使用逻辑地址与对应的段的基地即可转化为线性地址。在分页机制中线性地址作为输入。 虚拟地址：是CPU寻址假定的内存空间地址，是通过MMU(内存管理单元)使虚拟地址转换为物理地址，仅仅当需要向地址写入内容时才会给对应的地址开辟真正的物理空间。之前看见的均为hello的虚拟内存地址。 物理地址：计算机主存被认为是M个块内存组成的数组，所以每个字节都有一个唯一的地址，而这个地址就是物理地址。对于hello程序来说，就会通过MMU由虚拟地址映射到物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 将程序分为多个段进行管理，通过段表，将段的信息记录下来。而对于逻辑地址可以分为两部分：段标识符和段内偏移量。通过段标识符，在段表之中权匹配查询，在段描述符表中找到一个具体的段描述符，就可以得到基地址，然后再将其与段内偏移量结合，即可得到线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 页映射就是从线性地址到物理地址的映射，是由cpu的页式管理单元负责管理的，可以将线性地址翻译为物理地址。在物理内存中的最小分配单位是帧，页是虚拟内存中最小的分配单位。线性地址的前半部分为页号，对应了虚拟内存的某页，而后半部分是页偏移量，可以在页内查找。而物理内存中还存在一个页表，它存储着虚拟内存页和物理内存帧的对应关系。这样就可以通过页表查询页号来找到对应的物理内存帧，再通过页偏移量，就得到了物理内存的地址。 7.4TLB与四级页表支持下的VA到PA的变换 四级页表指的是虚拟页号被等分为四段，用每段页号依次向下查找，第一级页表中找到相应的第二级页表，以此类推。如此节约了页表的总大小。但是仍然页表是庞大的，所以建立了一个缓存称为TLB，查询过的页表项会存入TLB中，当下一次查询就可以直接查询而不需要通过页表，大大节约了时间。 7.5三级Cache支持下的物理内存访问 在三级cache下，将物理地址分成CT（标记）+CI（索引）+CO（偏移量），首先在先通过索引去寻找到对应的组，然后在组内去匹配标记，当匹配上是看有效位是否有效，然后通过偏移量读取数据。如果在一级cache未命中，则到二级cache中去匹配，若仍然不命中则到三级cache访问。 7.6hello进程fork时的内存映射 Shell调用fork来生成子进程时，内核为hello进程创建了对应代码、数据、堆和栈段并且给了唯一的PID。而为了hello进程创建好虚拟内存，就需要将原本的页表 它创建了hello进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 首先，execve会删除当前进程的虚拟内存的内容；其次，要为新程序的代码、数据.bss和栈区创建内存区域，分别将已经初始化的数据映射到.data节,代码映射到.text节，未初始化的数据映射到.bss。然后请求栈空间。除此之外，将共享库链接后，映射到共享库的内存映射区域。 7.8缺页故障与缺页中断处理 当CPU发送一个虚拟地址传递给MMU，但是MMU通过查看TLB与PTE发现对应的物理地址不在内存中，而必须从磁盘中取出到内存，这就是缺页故障。缺页的对应处理程序会在内存里确定牺牲页，需要判断该页面是否被修改。若被修改就需要将修改后的内容写入磁盘。然后通过调入之前请求的页到物理内存去覆盖掉牺牲页，并且更新PTE，添加一条对应记录。最后将控制返回给引起故障的指令，让其重新执行调用该页的指令，再发送虚拟地址给MMU就不会引起缺页故障了。 7.9动态存储分配管理 通过一个动态内存分配器来维护进程的某一块虚拟内存区域，这一块区域被称为堆。位于未初始化的数据区域（.bss节）后开始，并向高的地址生长。对于进程，内核利用一个变量brk指针，它指向堆顶。堆被动态分配器视为块的集合，每一个块就是一个连续的虚拟内存片(chunk),保留为供应用程序使用，而块分为已分配和空闲两种状态。 空闲块是可用来来分配的。而分配器分为显式和隐式，显式的分配方法，块只有在应用要求释放时才能得到释放的，而隐式则会自动释放不使用的块，称为垃圾收集。 空闲的块由称为空闲链表的数据结构记录，它也有显式和隐式之分。0而malloc就是显式的分配方法。 7.10本章小结 本章主要解释了hello程序运行时，对于存储空间的分配操作和过程。对于各种地址的变换和翻译有了一定程度的解释。讲诉了存储器各级间的关系和相互间调用的操作。让我们对于hello程序的存储和在存储器上的调用有了更深的理解。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixi/o接口。将所有输入输出设备视为文件后，所有的输入与输出都被看成了读写文件，使得所有设备的输入输出具有统一的格式和执行方式，方便管理与使用。而从Linux的内核引出的一个简单的应用接口，称之为unixI/O接口。 8.2简述UnixIO接口及其函数 1.open()函数： 功能描述：用于打开或创建文件，在打开或创建文件时可以指定文件的属性及用户的权限等各种参数。 函数原型：intopen(constchar*pathname,intflags,intperms) 参数：pathname:被打开的文件名，flags:文件打开方式。 返回值：成功则返回文件描述符；失败则返回-1。 2.close()函数： 功能描述：用于关闭一个被打开的的文件。 所需头文件：#include<unistd.h> 函数原型：intclose(intfd) 参数：fd：文件描述符。 返回值：成功返回0，出错返回-1。 3.read()函数： 功能描述：从文件读取数据。 所需头文件：#include<unistd.h> 函数原型：ssize_tread(intfd,void*buf,size_tcount); 参数：fd：文件描述符；buf：读取的数据存放的缓冲区地址；count：一次read操作读取的字符数量。 返回值：读取成功返回所读取的字节数；读到EOF返回0；出错返回-1。 4.write()函数： 功能描述：向文件写入数据。 所需头文件：#include<unistd.h> 函数原型：ssize_twrite(intfd,void*buf,size_tcount); 参数：fd：文件描述符；buf：写入的数据所在的缓冲区地址；count：一次write操作写入的字符数量。 返回值：写入成功则返回写入的字节数；出错返回-1。 5.lseek()函数： 功能描述：用于在指定的文件描述符中将将文件指针定位到相应位置。 所需头文件：#include<unistd.h>，#include<sys/types.h> 函数原型：off_tlseek(intfd,off_toffset,intwhence); 参数：fd：文件描述符；offset:偏移量，每一个读写操作需要移动的字节数，向前移为正，向后移为负。 返回值：成功就返回当前位移量；失败则返回-1。 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 Getchar函数原型里调用了read函数，它从缓冲区将buf的大小读满，当方生异常时再监听键盘输入读取缓冲区，读取时获得读入的字节数，如果大于0则返回缓冲区第一个字节，否则返回eof。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章解释了unix系统的io管理，解析了io接口的相关函数，并且通过分析printf和getchar两个函数的具体实现来展示了i/o的过程。 （第8章1分） 结论 程序由源代码通过预处理、编译、汇编、链接等步骤成为可执行程序，在执行过程中通过进程管理、存储管理、IO管理等一系列的系统控制机制，使得程序能够由硬盘上的文件到内存中的进程，最后成功通过IO设备展示出结果。详细解释了hello程序的“P2P”（FromProgramtoProcess）和“O2O”（FromZero-0toZero-0）过程，深刻理解了程序的“一生”。 通过对hello程序的分析，成功地回忆和加深了对计算机系统所学的知识的理解。更重要的是，能够通过hello的“一生”将各个章节的知识联系起来，让我们对计算机系统有了一个全面的认识。 学习计算机系统后，对计算机的整个运行逻辑和机制有了清晰的认识。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.c：老师提供的源文件。 hello.i：预处理后产生的文件，用于查看预处理过程。 hello.s：编译后产生的汇编文件，查看编译过程。 hello.o：汇编产生二进制的可重定位目标文件.o，无法直接查看。 hello：生成的可执行程序。 hello.oelf：通过ELF工具查看hello.o而产生的文件，记录了hello.o的ELF格式。 hello.elf：通过ELF工具查看hello而产生的文件，记录了hello的ELF格式 helloo.txt：hello.o的反汇编文件，用于查看和与汇编前的hello.s进行比较。 hello.txt：hello的反汇编文件，查看链接后的反汇编以及与helloo.txt进行比较查看链接过程。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 
第95篇文章[]
JAVA可复用性 一.可复用性的度量、形态与外部表现1.可复用性简介 虽然说复用有不同层级，但是总的来说可复用性就是我们重复使用我们已经编写好的模块。因此过程分为两部分:在某些模块编写出可复用度高的代码，然后在某些模块尽量调用这些代码。 越抽象的东西，可复用性一般越强。因此总的来说，java中接口的可复用性大于抽象类，抽象类大于一般类。 可复用性高显然会带来很多优点：首先编写软件的过程会很愉快(如果能很简单复用的话)，可以让代码更标准，实现的更可靠等等。 但是有时为了提高可复用性，我们也会付出很高的代价，主要是很多时候想实现好的可复用性是很难的，会有很高的开发代价，维护代价以及复用时要进行适配带来的代价。比如Lab2中，Graph这个ADT想实现很好的可复用性就很简单，但对于棋类游戏，想让这个ADT对很多种特定的棋类都有很好的可复用性，就是非常让人头疼的事情。 2.可复用性的衡量 总的来说分为两点，一是复用的次数是否很频繁以及是否可以广泛的应用在很多情况之中(这两个有很强的正相关性，比如List可以广泛的被应用，所以理所当然的用的次数很频繁)；二是复用的代价如何。可见我们并不能定量的去判断某个软件可复用性效果如何，我们只能定性的做一些观察。 3.复用的层面 两种复用的方式：白盒复用和黑盒复用。黑盒复用就类似于调用API接口，或者方法等等；白盒复用是直接得到想要复用的源代码(或其他内容)等等，然后自己根据需要进行修改。 根据复用内容的结构从小到大，分为如下四种复用。 (1).源代码级别的复用:这个是最底层的复用，就是简单的复制粘贴修改。 (2).模块级复用:以class作为最基本的单元，复用的方式有继承和委托，其中委托的耦合度明显低于继承。 (3).类库级重用:相当于把一系列的class进行了打包，类似于第三方库的调用。 (4).框架级复用:在框架的基础上，填充自己的代码，形成完整系统。(其实就类似于一些实验中，给出了很多代码，要求我们填入一些自己的代码) 二.面向复用的软件构造技术1.LSP与泛型中的运用 在我们3.4的继承，多态，泛型等等的基础上，这里我们主要介绍LSP，即Liskov替换原则。 Liskov替换原则用数学性的语言来说，则如下图所示。 从实际设计的角度来说，这个原则其实就是对子类型的约束：要求子类型对象完全可以当作父类型的对象来使用，其中就包括了规约的前置条件不能强化，后置条件不能弱化，要保持不变量等等。 下面介绍协变与异变的概念。 协变：子类对父类方法的覆写中，异常、返回值的类型是父类方法中返回值的类型的子类型，就称之为协变。 逆变：顾名思义，与协变恰恰相反。 因此为了复合Liskov替换原则，我们要求如果有变化的话，那异常，返回值必须是协变，参数必须是异变(当然，在java语言中参数的异变或协变导致方法不再是覆写，而是重载)。 java中的泛型是类型不变的，如下图所示，是十分经典的例子。如果想进行协变或逆变，则需要使用通配符，例如List<?extendsNumber>是List<Number>的子类型，但是不论如何都要确保一个List中的元素都是一种类型的(尽管多种元素都可以放入)。 Class为类型类，详细的用法可以参考“java中的反射”，可以得到很多信息，来验证我们上面的说法。这里就不详细说明了。 2.委托与组合 委托顾名思义，类似于现实中我们委托别人去做一些事情，抽象到代码中，那就是在某个类的方法中，传入其他类的变量，把实现逻辑写在这个其他类的方法中，并在这个类的方法中调用。 例如我们想通过List的复用性实现stack，如果是继承关系的话，则stack中不可避免的有很多与我们期待的数据结构不匹配的方法。因此我们应该采取委托的方式，将pop等函数里某些操作委托给list即可。 由于继承过于严格，因此如果不是有很强的继承关系，使用委托会更合适。 总的来说，委托有四种形式。 (1).依赖(Dependency):逻辑即为AuseB,在A的方法中通过把B当作参数来或在方法的局部中，调用B的方法，是一种临时性的委托，只有调用这个方法的时候，它们才有临时关系。 (2).关联(Association):逻辑即为AhasB,对象A中的字段中有对象B，之后的操作和前面类似；只是A与B之间就有一个相对长的关系了。 (3).组合(Composition):逻辑即为BispartofB,A中有字段B，且在A被构造时，B就被初始化好了(A中的定义导致的，比如A中有privateTB=newT(…)语句)；因此它们声明周期一致。 (4).聚合(Aggregation):逻辑即为AownsB，与(3)很相似，只是B构造的方式是通过A的构造函数的参数。因此对于B的构造，比第三种要灵活。 3.框架设计 有两种形式：一是白盒框架，二是黑盒框架。 白盒框架：主要采用继承的方式，通过构建子类的方式进行扩展，子类中有main函数。代码是可见的，但是带来的问题就是要对父类的代码有了解，更贴近于开发者使用。 黑盒框架：主要采用用插件实现接口和委托的方式进行扩展，子类中没有main函数。更贴近于用户使用。 但无论是那种框架，控制权都是在框架手上的，这其实是框架和很多类构成的一个体系的区别。 至于如何设计好一个框架，总的来说与多个类之间的设计思想一致，只是需要更多的去了解这个框架的用途，然后更有针对性地去开发。 三.面向复用的设计模式 总的来说，针对开发的阶段不同，设计模式分为以下三种：创建型模式、结构型模式、行为类模式。本章主要是讲解其中与可复用性密切相关的一些模式。 1.结构型模式(1).适配器模式 主要是用于解决类之间的接口不兼容的问题。一般用于新版本的时候重新定义了接口或者新创建了一些类，要和旧版本写适配的时候。方式还是一样有两种，分为继承和委托，不过一般委托更方便些。 (2).装饰者模式 总的来说，就是把一个个特殊功能看成是装饰品，然后调用时通过决定加入哪些装饰品从而得到我们想要的结果，而不是通过继承的方式来得到具体的类。 具体实现方式就以ppt上冰淇淋这个例子来举例了，这也是最简单的一个装饰着模式的例子了。 我们对于一个冰激凌，想在它上面添加一些食料。由于不同种的食料可以组合，采用继承会组合数爆炸。因此我们可以采用如下的策略：首先定义接口，其中有我们想要有不同实现的方法：AddTopping()方法；其次，我们正常的实现没有任何装饰的类，用于委托；之后，我们定义一个装饰器基类，把没装饰的类的一个对象作为自己的一个字段(其实就是委托)，然后并不实现要装饰的方法，准备留到子类；注意这个类和没有装饰的类是类似于“兄弟关系”，都是实现共同的接口。 之后，我们再把对应的三种装饰方式实现为装饰器基类的子类，其中构造函数还是调用父类的构造函数，在待装饰的地方，就是先调用父类的操作，再加上自己独特的操作而成，这就是所谓的“装饰”。 之后客户端的调用就顺理成章了。我们想要哪些装饰，就套入哪个装饰的构造方法即可，就类似于递归调用，因为我们在编写类的时候方法的实现就是递归的。 不过这个模式在情况复杂的时候，写起来难度很大，逻辑上哪些应该先装饰，哪些应该后装饰还有冲突等如何处理也是个问题。 (3).外观模式 这个模式比较简单，其实就是客户端有的时候功能组合比较多，可能用起来比较复杂。因此我们就采用外观模式：用一个相对简化，统一的接口来实现对一系列接口的组合使用。 2.行为类模式(1).策略模式 其实这个模式也比较直观，就是实现的代码中，会根据用户输入的不同，采取不同策略的实现方式，就比如C++中的排序sort()函数，系统其实会根据输入的不同采取不同的算法。 当然，内部的实现可以是最简单的先评判输入，然后再生成对应的参数，调用其他接口(委托)；更好的更隐蔽的方式是使用工厂模式，这个在后面的章节中会介绍。 (2).模板模式 模板模式很适合白盒框架，其实就是在父类中定义一系列抽象方法(即为一个个流程)，以及一个方法来定义这些流程的实现步骤，然后再用子类去实现这一个个流程的具体步骤。可见，这个模式和策略模式有相似的地方，就是具体也是采用不同的方法，只是保证步骤一样。 (3).迭代器模式 不关心容器具体类型，用一种统一的方式进行遍历。 一般来说，实现的方式如下图所示。首先，这个类要实现Iterable接口，从而要实现蓝框中的方法得到迭代器。然后，我们就可以自己去实现对应的迭代器，其中这个迭代器要实现Iterator接口。通过这种方式，客户端在遍历的时候，完全无需看到迭代器是如何工作的。 
第96篇文章[]
软件构造 ADT 一.ADT的基本概念 数据抽象：由一组操作所刻画的数据类型；强调的是操作而不是具体如何存储的。 可以看出对应的抽象可能有多种实现方式。所以可见ADT是由操作定义的，与内部实现方式无关；一般用户也不关心实现方式，只关心暴露出的操作(通过规约来达成一致)。 二.典型的类型和操作 类型上可分为可变数据类型和不可变数据类型，与3.1节的含义相同。 下面内容为重点 操作上可以分为四类，分别是构造器、生产器、观察器、变值器。 构造器是从无到有的过程，一般用构造方法或者静态工厂方法来实现。 生产器是从旧到新的过程，一般是一些对不可变类型的修改导致新生成一个对象等等的操作。 观察器顾名思义，仅仅是看我们想要得到的内容，而不进行修改。 变值器也是顾名思义，指的那些改变对象属性的方法。一般返回值为void的方法很可能是变值器。有变值器的数据类型就是可变数据类型，否则就是不可变数据类型。 三.ADT的设计法则 法则1：操作要简洁，一致。对于复杂的操作，应该拆分成多个简单操作的叠加，以此提高内聚性。 法则2：操作要全面(即需要的功能要可以实现)，且为用户提供方便的操作。 法则3：要不是针对抽象，要不是针对具体，不要两者混合。因此面向具体应用的类型不应该有通用方法，面向通用的类型也不该有具体方法。 四.表示独立性 表示独立性(RepresentationIndependence)的含义为，客户端使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端，客户端调用的结果应该是相同的；也就是我们前面一直强调的用户调用与内部实现方式无关。 五.ADT的测试 总的来说，对构造器、生产器、变值器的测试要用观察器检查；对观察器的测试要用其他三类方法来产生或构造对象。但这样的风险是，可能会产生互相依赖的现象，导致无法找到真正的错误原因。 解决方案：新创建一些方法来解除这些耦合，或者是把一部分私有方法改为公有方法，测试完后再换回私有。或者如果对于小型程序，只要测试结果都是正确的，也就可以解决问题。 六.不变量 不变量就是ADT在使用的过程中永远为真的性质，与客户端的行为无关。为了确保ADT使用时的正确性以及出错误时定位错误，我们一般会经常判断我们的不变量是否为真。 例如不可变类型是不可变的，自己设计的set中不能有重复值(要求不能有重复值)等等。 一般导致不变量被破坏是因为表示泄露：将我们不应该被修改的内容交给了客户端去修改。总的来说，杜绝方法如下：尽量都使用不可变的数据类型；否则至少让输入的参数为不可变类型，同时做好防御性拷贝，返回新的对象，或者是把返回的字段改为不可变的。 七.表示不变量(RI)与抽象函数(AF) 首先，我们做如下的两个定义。 R：表示空间，ADT中实际存储的内容。(当然和ADT的实现密切相关) A：抽象空间，客户端看到和使用的值。 AF：从R到A之间的一个对应关系(映射)，即AF：R→A。 当然，A中的元素都肯定在R中至少有一个对应；而R中却可能有元素不和A中的任何元素对应(即不遵守规约的内容)，因此可见AF为满射而未必为单射。注：这里的映射其实指的是部分映射，因为映射要求R中每个元素都有A来对应，因此对全体R来看的话，只要每个像都有一个原像，那就是单射了；但即使既是单射又是满射，也可能不是双射。 RI：从R到boolean的一个映射，即RI：R→boolean，其中如果R中的元素在A中有像即表示合法，则该元素在RI的映射值为true。也可以说RI是一个条件，描述了哪些是合法值。 下图为一个简单的例子，实现的内容为字符集合。 不同的内部表示要设计不同的AF和RI，主要流程是先通过某种特定的表示方式R，来指定出RI，从而再做出相应的解释，也就是AF。 我们应该在开发阶段，对所有改变不变量的方法中随时检查(除了观察者之外的方法)。因此我们一般会使用assert语句。 八.AF，RI和表示泄露安全说明的文档化 这些都是写在代码的注释中，而非规约中。要给出理由，证明代码并未对外泄露其内部表示，比如字段全部为private，还有对可变字段的处理等等。 可用表示不变量来代替一些前置条件。 
第97篇文章[]
详解Java中的checked异常和unchecked异常 详解Java中的checked异常和unchecked异常（一）Java的异常层次结构 要想明白Java中checkedException和uncheckedException的区别，我们首先来看一下Java的异常层次结构。 这是一个简化的Java异常层次结构示意图，需要注意的是所有的类都是从Throwable继承而来，下一层则分为两个结构，Error和Exception。其中Error类层次描述了Java运行时系统的内部错误和资源耗尽错误，这种错误除了简单的报告给用户，并尽力阻止程序安全终止之外，一般也米有别的解决办法了。 (二）unchecked异常和checked异常的区别 有了上面的认识之后，我们再来看什么是checked异常，什么是unchecked的异常。其实，Java语言规范对这两个定义十分简单，将派生于Error或者RuntimeException的异常称为unchecked异常，所有其他的异常成为checked异常。尽管，这个定义十分简单，但是RuntimeException却是一个非常让人容易混淆的观念，似乎我们所有的异常都是在程序运行的过程中。我《EffectiveJava》中关于RuntimeException异常的阐述也不是那么尽如人意， Usecheckedexceptionsforrecoverableconditionsandruntimeexceptionsforprogrammingerrors(Item58in2ndedition)1 不过从这句话中我们可以简单引申一下，也就是说，如果出现了RuntimeException，就一定是程序员自身的问题。比如说，数组下标越界和访问空指针异常等等，只要你稍加留心这些异常都是在编码阶段可以避免的异常。如果你还是觉得这两个概念不好区分，那么“最暴力“的方法就是将常见的RuntimeException背下来，这样就可以省去很多判断的时间。 （三）为什么要对unchecked异常和checked异常进行区分？ 原因其实很简单，编译器将检查你是否为所有的已检查异常提供了异常处理机制，比如说我们使用Class.forName()来查找给定的字符串的class对象的时候，如果没有为这个方法提供异常处理，编译是无法通过的。 （四）我们应该对哪些异常进行声明？ 我们前面说，RuntimeException是在programing过程中可以避免的错误，那是不是我们就不需要抛出这些异常呢？原则上来说，是这样的，但是Java规范中并没有对此进行限制，只是看上去你抛出一个数组越界的异常并没有多少实际意义，相反还会对性能造成一定的损失。那么我们应该如何来设计抛出异常呢？我们要记住以下两种情况是必声明throws异常的： 调用一个checked异常的方法，例如IOException，至于原因我们前面已经讨论过了，如果抛出所有的checked异常时无法通过编译的。程序运行过程中发现错误，利用throw语句抛出一个异常。对于unchecked异常，无非主要是两种情况要么是可以避免的（RuntimeException），要么是不可控制的。这些也是需要声明异常的。 
第98篇文章[1]
32位Ubuntu系统share文件夹消失问题的解决 用的是VMware虚拟机，经常在Ubuntu重启后share共享文件夹消失。 输入如下代码： sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000 即可解决。好耶！ 
第99篇文章[]
软件构造 OOP 一.OOP基础 这里只是对需要注意的地方做一些常识性总结，毕竟这些都是java初学者必须要熟练掌握的内容。 1.OOP的一些基本概念 在java语言中，我们最经常遇到的OOP概念即为类，对象和接口。 现实世界中的对象可映射为编程中的对象，其中状态即映射为字段，行为则映射为方法。 类的概念是在对象的概念产生后产生的。类是对一组对象统一的表达，是一个抽象的概念，现实世界中并不存在类的实体；而对象则是类的实例化。 类中的字段和方法分为属于类的和属于对象的。加static即为属于类，在类的外部用类名.字段/方法名进行操作；而不加static即为属于对象，在类的外部用对象名.字段/方法名进行操作。 注：静态方法中无法直接调用非静态成员和方法，但是可以new一个对象，之后再使用。 接口不能有构造方法，也要写规约，实现接口的类对相应的方法可以不写规约。要注意如果接口的规约表示为不可变类，那相应的实现中也要是不可变的，这点常常被忽视。 以前使用接口并不能完全隐藏实现，但现在接口中可以有静态方法，从而实现完全的隐藏，例如实验二中的graph接口。 2.信息隐藏与封装 实现方式:尽量使用接口声明变量，客户端仅使用接口中定义的方法，让客户端不能直接访问属性。可采用不同的权限修饰词来进行约束，以下为四个修饰词各自的权限。 总的来说，不需要用户使用的方法都应尽量是private的，或者作用域能尽量小就尽量小。况且作用域越小，容错率越高。 3.继承与覆写 子类覆写的方法的可见性要大于等于父类，因为子类的对象应可以转型为父类对象，可见性的降低就会出现错误。同理，子类抛出的异常必须是父类的子集。 覆写的方法是在运行时判断类型来调用的，因此以new构造的类型为准。 在子类中,用super关键字来调用父类的各种方法，用的最多的是构造方法。 4.多态 多态主要分为三种，我们下面分别来介绍。 A.特殊多态:一个方法可以有多个同名的实现(方法重载)。要求参数列表必须有不同的地方，其他的并没有要求，总之就是把重载的方法看作和之前完全不同的方法。 重载是编译时确定，属于静态检查。而覆写是运行时确定。因此对于类A变量名=new类B(参数)而言，编译时类型为A，运行时类型为B。具体例子如下图所示。 另外，还需注意这种变量作为参数时多态的用法，如下图所示。 B.参数化多态:一个类型名字可以代表多个类型(泛型化编程)。 泛型类/接口的格式：关键字类名/接口名<占位符>(){…}占位符其实就相当于额外的参数，代表着对应的类型。实际调用的时候使用类型参数，转化为对应的类名(因此如果希望是整型参数，要用Integer而不是int)，因此运行阶段不存在泛型。泛型接口可以有泛型或非泛型的实现类，取决于自己的需求。 泛型方法的格式：关键字<占位符>返回值方法名(参数列表){…}，注意，参数列表中有泛型变量，并不会导致这是一个泛型方法，因为这其实是属于泛型类的泛型变量。 对于静态方法，如果使用泛型参数，那么必须也定义为泛型方法。 C.子类型/包含多态:一个变量名字可以代表多个类的实例。其实就如同上面的例子用到的一样。子类型的实例也可以说是父类型的一个实例(当然反之不成立)，因此子类型的规约不能弱化超类型的规约。 二.ADT和OOP中的等价性1.三种判断等价性的方法 <1>.利用数学上等价的定义:满足自反性，对称性和传递性。 <2>.利用AF来定义ADT的等价判断，如果两个值的AF映射值相同，则说明他们等价。 <3>.在调用者角度，如果调用两个对象的所有任意操作，效果都完全一样，那么则说明他们等价。 2.“==”与equals 对于“==”,代表着判断两个对象的地址空间是不是在同一个位置，也被称为引用等价性；而equals则代表着判断两个对象的内容，也被称为对象等价性。 object类的equals默认为判断两者的地址空间是不是在同一位置。总的来说，对于基本数据类型，我们应该用“==”，而对于对象数据类型，我们应该用equals判断(当然，要根据需要判断是否应该覆写)，当然，我们要明确知道我们写的方法是覆写还是重载。 除了写equals方法，尽量不要用instanceof和getclass()，因为他们不符合OOP的思想，不是好的书写风格。 3.hashcode与equals hashcode方法就类似于数据结构中的哈希函数一样，功能就是把一个个对象映射到一个地址(也就是桶)。默认的方式是按照地址映射，一般地址不同则值不同。 当我们使用HashSet等类似的数据结构的时候，这时再进行寻找时，就如同正常哈希表一样了，是通过判断哈希值是否相等先进行判断，哈希值相同是equals成立的前提，也是首先判断的方法。此时如果我们只重写equals而不重写hashcode，则hashcode还是默认的按地址算出一个值，一般而言只要地址不同则哈希值就不同了，导致了我们equals方法看似失效。 综上，equals()应满足如下条件：首先满足等价性(数学意义上)，其次保证在不被修改的情况下，每次调用的结果应该相同，同时要处理对象为null的情况还有如果这个类使用了哈希表进行查询(比如放入了HashSet中)，则也要覆写hashcode方法。 4.可变类型的等价性 有两种判断方式:观察等价性与行为等价性；分别代表不改变状态的前提下，通过观察器来判断两者是否相同以及调用任何方法是否有相同的结果，但由于是可变类型，也就相当于判断地址是否相同了。 虽然很多时候我们倾向于判断观察等价性是否相同，但是可能引起bug甚至破坏RI，尤其是使用了Set的时候。比如经典的Set<List<T>>引起的bug。 因此，总结起来来说，对于可变类型，我们不应该覆写equals方法和hashcode方法，如果想“比较”，我们可以使用其他自定义的方法；而对于不可变类型，如果我们想要“比较”，那么我们是一定要覆写这两个方法的。 5.装箱及其等价性 在使用集合类时，我们前面也提到过，会进行隐式的装箱操作。因此，装箱完毕后，如果是两个不同对象，即使是整数的装箱，使用“==”进行判断也会返回false，要进行equals的覆写。 但是下面有一个特例，那就是如果是-128到127之间的整数，进行两次装箱操作，那得到的地址是一样的(得益于java的缓存机制)。当然，上面也是要求只装箱，不能为两次new的操作，不然肯定地址值不同。 
第100篇文章[]
软件构造 面向可维护的设计模式 1.创建模式 这些类的作用主要就是为了创建对象，对应采取的模式就是不同的创建模式，分为以下几种模式。 A.工厂方法模式 使用ADT的时候，如果我们想创建一个对象，我们就要调用构造函数，而构造函数不会在接口中而是在实现类中，因此抽象程度降低了，而且导致用户可能会依赖于这个实现类的实现方式，而不是接口。为了解决这些，工厂模式应运而生。 我们也可以说其实就是对构造函数的包装(就像之前对其他字段或方法的包装一样)，包装到一个新的类中，从而实现隐藏了这个原始类的类名，新的类一般只有一个方法，那就是用来构造原有类的对象。 另外还有一种实现的结果相同的方法，就是在原始的类中添加静态工厂方法，同时将构造方法设置为私有。 B.抽象工厂模式 相比于普通的工厂方法模式中，一个工厂就用于创造一个类的对象，其实抽象方法模式就是变成了一个工厂可以创建一组类的对象，不过创建的搭配是固定好的。 我们可以举下列在麦当劳点餐的例子来大致说明： 对于普通的，没有使用创造模式的情况，我们就是这样点：一个奥尔良鸡腿堡，一个中可乐。我们提出需求时就直接是知道了具体的类，比如是奥尔良鸡腿堡，而不是通过它的父类“汉堡”。 而工厂方法模式，我们是这样点：有一个个优惠卷，每个卷有对应的产品。我们给服务员这些卷，让他们拿出对应的产品，而我们不再需要知道这些产品的名字。通过优惠卷信息的不同，通过不同的工厂去创造对应的对象。 而抽象工厂模式，我们是这样点：有一个个优惠卷，里面都是一个套餐。我们同样不用知道这些套餐中任何一个产品的名字，但是这些产品是绑定在这一个套餐之内的了，我们不再能一个个产品的去点，但是这样我们创建的时候对固定的模式更方便。 2.结构模式 通过改变类之间的结构，让类呈现新的功能。 A.代理模式 有的时候我们在创建一个类的对象时，就要进行一定的操作，而有的时候这个操作很费时间，而操作不一定必须，则此时我们就可以创建一个对应的包装，来实现将所谓的这个操作和对象的创建分隔开。 下面是一个很好的例子。 首先这张图说明在创建这个图片的时候，就调用了loadfromDisk这个需要花费很多时间的操作。 如果我们想要实现仅仅是创建一个对象而不是立刻执行加载操作，则可以执行如下操作：创建一个虚拟的了类，构造方法中不再有display而是挪到了外面，通过委托的机制进行调用。 代理模式与适配器模式的区别：前者的目的是解决私密问题和耗费过大的问题，而后者的目的主要是消除不匹配，让客户端和内部的类以统一的方式建立联系。 3.行为模式 行为性模式主要用于描述类或对象的交互以及职责分配。 A.观察者模式 总的来说就是一种一对多，类似于广播的模式。 在被观察者中，应该有添加观察者和删除观察者的操作(用于将观察者与被观察者之间建立联系)，还有就是将信息通知给观察者的操作(notify)。对于观察者，也该有更新状态的操作(当然是由被观察者的notify来操作) 例子如下所示，观察者即为被观察者中的一个列表。通过调用观察者的update操作来实现notify操作。(当然这里不能删除被观察者) 粉丝(被观察者)的例子如下，subject属性代表着对应的被观察者所观察的观察者。 当然，java中提供了Observer接口和Observable抽象类，类似于迭代器模式。 B.访问者模式 总的来说，访问者模式就是，被访问者中的某个具体的操作，因为各种原因，去委托给另外的类进行完成。委托给的类就是访问者。 我们还是用例子来说明，不然太抽象。 首先这是第一棵继承树，是被访问的那个类。其中要有accept方法，参数是访问类的对象，通过accept方法来让其访问。 而第二棵继承树就是访问类了。其中要有visit方法，通过多态实现取分访问不同类型的对象从而有多种实现，而实现中即可以正常的写业务逻辑了。这个例子相当于把每种物品的计算价格的操作委托给了另一个类，这也就是访问者模式最主要的目的。 与迭代器模式的区别：迭代器模式主要是进行一个个的访问，而访问者模式主要是被访问者将对应的某种功能的实现交给访问者，客户端可以灵活的改变访问者中的操作算法。 4.设计模式总结 虽然设计模式种类很多，但是抽象出的类与类之间的关联效果，都是如下两张图所示。 首先是单一继承树的情况。 其次是两颗继承树的情况。 至于如何去取分这些样式相同的模式，主要是通过它里面方法的不同，就类似于大家都是人，但是由于自身能做的事情不同，因此有不同的职业一样。 
第101篇文章[]
JAVA正则表达式 一、单个符号1、英文句点.符号：匹配单个任意字符。 表达式t.o可以匹配：tno，t#o，teo等等。不可以匹配：tnno，to，Tno，t正o等。2、中括号[]：只有方括号里面指定的字符才参与匹配，也只能匹配单个字符。 表达式：t[abcd]n只可以匹配：tan，tbn，tcn，tdn。不可以匹配：thn，tabn，tn等。3、|符号。相当与“或”，可以匹配指定的字符，但是也只能选择其中一项进行匹配。 表达式：t(a|b|c|dd)n只可以匹配：tan，tbn，tcn，tddn。不可以匹配taan，tn，tabcn等。4、表示匹配次数的符号 5、^符号：表示否，如果用在方括号内，^表示不想匹配的字符。 表达式：[^x]第一个字符不能是x6、\S符号：非空字符7、\s符号：空字符，只可以匹配一个空格、制表符、回车符、换页符，不可以匹配自己输入的多个空格。8、\r符号：空格符，与\n、\tab相同 二、快捷符号1、\d表示[0 9]2、\D表示[^0 9]3、\w表示[0 9A Z_a z]4、\W表示[^0 9A Z_a z]5、\s表示[\t\n\r\f]6、\S表示[^\t\n\r\f] 三、Pattern和Matcher实例： publicclassFindDemo{privatestaticTestmonitor=newTest();publicstaticvoidmain(String[]args){ Matcherm=Pattern.compile("//w+") .matcher("Eveningisfullofthelinnet'swings");while(m.find()) System.out.println(m.group());inti=0;while(m.find(i)){ System.out.print(m.group()+""); i++; } monitor.expect(newString[]{"Evening","is","full","of","the","linnet","s","wings","Eveningveningeningningingnggisissfull"+"fullulllllofoffthetheheelinnetlinnet"+"innetnnetnetettsswingswingsingsngsgss" }); }} 用括号可以给pattern进行分组，用group（inti）引用。 
第102篇文章[1]
程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机类 学 号 1190200407 班 级 1936602 学 生 林棋珺 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文以hello程序的编译过程再到执行过程作为引子，展示了机器执行程序的全过程以及在此期间机器内部的维持运转、各个部位的工作。 包括了hello程序的预处理、编译、汇编再到链接的过程，以及运行时hello的进程管理、存储管理和IO管理，通过提出概念并以hello作为例子详细刨析。 关键词：预处理、编译、汇编语言、机器语言、可重定位目标文件ELF格式、链接、重定位、动态链接、shell、进程、Cache、页表、TLB； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 P2P（FromProgramtoProcess）：指的是hello.c经过预处理、编译、汇编、链接后得到一个可执行程序hello O2O（FromZero-0toZero-0）： 一开始0 输入./hello学号姓名 Shell调用fork()申请子进程 子进程调用execve传入argc,argv,environ（参数和环境变量） 映射虚拟内存，载入物理内存 执行hello 运行结束后，Shell接受子进程信号回收 内核删除子进程 回到了0 1.2环境与工具 硬件环境：lntel(R)Core(TM)i7-8750HCPU@2.20GHz2.21GHz；8GBRAM 软件环境：Windows1064位，Vmware14；Ubuntu18.04LTS64位 开发工具：gcc+gedit,Codeblocks,edb，objdump，readelf 1.3中间结果 hello.i预处理后的文件 hello.s汇编语言文件 hello.o可重定位目标文件 hello可执行文件 1.4本章小结 这一章是hello的程序人生的开始，了解helloP2P和O2O的过程，让我们重回初恋，了解更多关于hello的一切。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 预处理是在源代码编译之前所做的修改源码的操作 主要的行为是删去#注释的代码，不同的注释作用如下： *将源文件中以“#include”格式包含的文件复制到编译的源文件中。 *用实际值替换用“#define”定义的字符串。 *根据“#if”后面的条件决定需要编译的代码。   此外删除了其他//和/**/的注释 2.2在Ubuntu下预处理的命令 输入该命令调用gcc预处理 图2-2预处理命令 2.3Hello的预处理结果解析 图2-3hello.i内容（未截全） 上面是hello.i最后的内容，因为内容过多所以直接了最后和hello.c的主函数一样的部分，可以看见main函数基本没有变化，说明预处理时还没有编译。 这里可以看到预处理的作用之一就是把头文件转换成源代码。 同时也有修改宏定义和条件编译的作用 2.4本章小结 每次写代码都会写的头文件，不知道有什么意义，现在终于明白了。 宏定义，拓展和条件编译，所有的#注释///**/注释都要删掉，才能让程序编程机器能懂的语言。 没想到短短的hello程序居然也可以包含如此多的内容，但是头文件的代码都是曾经的程序员一点一滴积累的，只有前人不断地开发，今后的代码才能越来越简练。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译是指预处理后的文件到生成汇编语言程序的过程，将文件hello.i转换成hello.s，获得一个汇编语言文件 编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。 3.2在Ubuntu下编译的命令 图3-2编译命令 3.3Hello的编译结果解析 图3-3hello.s文件 3.3.1数据 hello.s里出现的数据如下： 由图3-3-1-1可以看见main函数给自己的栈帧申请了32个字节 并将argc存在%rbp-20中（sizeof（argc）=4） argv的数组指针为%rbp-32，通过偏移可得： argv[1]地址为argv+8(%rbp-24) argv[2]地址为argv+16(%rbp-16) （sizeof（argv）=8） argc和argv是main函数带入的参数，也是调用hello命令时输入的 图3-3-1-1数据argc和argv 全局变量sleepsecs放在.data节中 sizeof(sleepsecs)=4 图3-3-1-2数据sleepsecs printf的两个表达式（LC）,放在.rodata节中 图3-3-1-3表达式 由这几句可以看出局部变量i存放在(%rbp)-4中 sizeof(i)=4 图3-3-1-3变量i 3.3.2 操作 3.3.2.1 赋值操作 用movl语句给寄存器i赋值 图3-3-2-1赋值操作 3.3.2.2 算术操作 用addl语句执行i++ 图3-3-2-2算术操作 3.3.2.3 关系操作 程序带有4个标志位，ZF，OF，SF，CF 在执行cmpl时会改变，然后根据这4个标志位的情况可以决定j**和cmov**是否执行，从而产生分支 例如判断（argc！=3）和（i<10) 图3-3-2-3关系操作 3.3.2.4 算术操作 main在.text节中，声明为全局变量和函数类型 图3-3-2-4-1函数操作-main 其余函数都是用call函数调用，一般传入的参数会放进%rdi,%rsi,%rdx,%rcx,%r8,%r9（按顺序优先）或栈中（前面的寄存器占用后），返回值一般放进%rax中 printf把表达式放入%rdi中 图3-3-2-4-2函数操作-printf 把参数放入%rdi中后调用sleep 图3-3-2-4-3函数操作-sleep 图3-3-2-4-4函数操作-getchar 图3-3-2-4-5函数操作-put 图3-3-2-4-6函数操作-exit 3.3.3 控制转移 图3-3-3for语句 通过上面提到的关系操作，判断i<=9的条件，满足就返回.L4（循环块） 3.4本章小结 麻雀虽小五脏俱全，小小的hello.s却包含了各种数据类型和各种操作 但是分析其中的结构和实现过程对我们了解汇编语言至关重要 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编是编译后的文件转换至机器语言二进制程序的过程。将文件hello.s转换成hello.o，获得一个可重定位目标文件。 4.2在Ubuntu下汇编的命令 图4-2汇编命令 4.3可重定位目标elf格式 图4-3elf格式 4.3.1 ELF头 命令输入readelf-hhello.o，得到elf头，存放整个程序的基本信息 包括机器类型；操作系统版本；节头部表的开始位置、大小；文件大小等等 图4-3-1ELF头 4.3.2 节头表 命令输入readelf-Shello.o，得到文件（图4-3elf格式中所述）各个节的信息(包括名称、类型、地址、偏移量、大小、全体大小、旗标、链接、信息、对齐） 图4-3-2节头表 4.3.3 symtab 输入命令readelf-shello.o，得到符号表（程序中所有函数名和有全局或者static属性的变量名） 对于每一个条目的不同属性的说明: Value:偏移量 Size:大小（字节数） Type:类型 Bind:绑定属性 是全局符号还是本地（局部）符号 Ndx:节索引 Vis: Name:符号名称 图4-3-3符号表 4.3.4 重定位条目 上文提到的偏移量会在此处加以叙述。 重定位就是将符号定义和符号引用进行连接的过程，通过偏移量计算它们运行时所处的内存地址。这一步需要依赖hello.o中的重定位条目 输入命令readelf-rhello.o，得到重定位节 偏移量 指向需要进行重定位操作的位置。信息指定必须对其进行重定位的符号表索引以及要应用的重定位类型。加数指定常量加数，用于计算存储在可重定位字段中的值。 图4-3-4可重定位节 4.4Hello.o的结果解析 图4-4hello.o的反汇编 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 4.4.1 机器语言的构成 1、单字节指令 操作码本身就隐含了操作数的信息，不需再加操作数。如retq,leaveq等 2、双字节指令 首字节为操作码，第二个字节为操作数或操作数地址。如callq，push等 3、三字节指令 首字节为操作码，后两个字节为操作数或操作数地址。如addl，mov，cmpl等等 与汇编语言的映射关系：操作码对应一个字节，根据操作码的不同，操作码后面会添加操作数或者操作数地址等等组成一个完整的指令 不同：汇编语言中用的是十进制，而机器语言（反汇编语言）用的是十六进制；汇编语言中跳转和调用函数用的是自定义段或者函数名字，而机器语言（反汇编语言）用的是相对寻址的方法（跳转到对应的rip） 4.5本章小结 程序转成了可重定位目标文件，已经是机器语言了，只差最后一步就可以执行了。 这一章节我们学习到了elf头和机器语言两大部分，都是链接后成为可执行文件的基础。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接过程将多个可重定位目标文件合并以生成可执行目标文件。 作用： -模块化 一个程序可以分成很多源程序文件； 可构建公共函数库，如数学库，标准C库等。以便代码重用，提高开发效率。 -效率高 时间上，可分开编译：只需要重新编译修改的源程序文件，然后重新链接； 空间上，无需包含共享库所有代码：源文件中无需包含共享库函数的源码，只要直接调用即可（如，只要直接调用printf()函数，无需包含其源码），另外，可执行文件和运行时的内存中只需包含所调用函数的代码，而不需要包含整个共享库。 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 图5-3-1ELF头 图5-3-2节头表 5.4hello的虚拟地址空间 图5-3-3edb中的.init段 图5-3-4edb中的.text段 对照elf头的位置和偏移亮可以看到，readelf中所有节的地址位置是和edb中显示的一一对应的 5.5链接的重定位过程分析 objdump-d-rhello运行结果如下： 可以看到hello比起hello.o，多了很多函数的代码，是在链接时引用的 并且在跳转和调用函数时，用的是绝对寻址，说明重定位完成，数据和代码都放进了地址空间中。 图5-5hello的反汇编代码 hello的重定位过程 1.合并相同的节（数据节和代码节） 2.确定「定义符号」在虚拟空间的绝对地址 3.用上述「定义符号」的绝对地址修改.text和.data节中「引用符号」的地址 5.6hello的执行流程 图5-6hello各函数地址 0x400520 hello!_start ->0x400607 main ->0x4004d0 hello!puts@plt ->0x400500 hello!exit@plt ->0x4004e0 hello!printf@plt ->0x400510 hello!sleep@plt ->0x4004f0 hello!getchar@plt ->0x400704 hello!_fini 5.7Hello的动态链接分析 hello程序的动态链接项目:global_offset表 图5-7-1运行dl_init前的GOT表 图5-7-2运行dl_init后的GOT表 执行了dl_init后的globaloffset表内的数据都发生了变化。 5.8本章小结 至此，我们的程序hello完成了P2P 只有一个函数只有一段代码是无法完成hello的全部工作的 需要与依赖的函数链接，将函数重定位，找到每个符号在虚拟空间中的绝对地址，才能真正执行hello （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是具有以下特征的活动单元：一组指令序列的执行，一个当前状态和相关的系统资源集计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 作用：进程提供一个假象，好像我们的程序是在独占使用处理器和内存。 6.2简述壳Shell-bash的作用与处理流程 shell是一个用户跟操作系统之间交互的命令解释器，可以合并编程语言以控制进程和文件，以及启动和控制其他程序。 处理流程： -输入的命令行 -将命令用空格分开 -判断是否为内置命令，如果是那就执行内部函数 -调用fork和execve函数来运行程序 6.3Hello的fork进程创建过程 Shell解析命令，调用fork函数获得一个进程 获得命令输入的参数argvargc，构造envp。 子进程自己创建一个进程组，并把父进程的信息私有的写时复制下来，这样调用hello时就不会影响到shell进程。 子进程调用execve函数进入hello的代码。 6.4Hello的execve过程 execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp。如果没有出现错误，execve正常加载运行hello，调用后就不会返回。 *删除已存在的用户区域：删除当前进程的虚拟地址的用户部分中的已存在的区域结构 *映射私有区域：为hello的代码、数据、bss和栈区域创建新的数据结构。私有的、写时复制。 *映射共享区域：将hello与共享对象动态链接，再映射到用户虚拟地址空间中的共享区域内 *设置程序计数器(PC)设置hello上下文中的程序计数器 6.5Hello的进程执行 （以下格式自行编排，编辑时删除） 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 6.5.1 进程上下文 操作系统内核使用一种成为上下文切换的较高层形式的异常控制流来实现多任务： 内核为每一个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态。 6.5.2 进程时间片 是操作系统分配给每个正在运行的进程的一段CPU时间 由操作系统内核的调度程序分配给每个进程。 6.5.3 进程调度的过程 刚开始控制在hello进程中，hello调用sleep函数时，会将控制权转交给内核进程，内核保存hello的上下文后，在sleep的时间片内执行进入进程的上下文将控制传递给该进程，此时可以接受来自键盘的信息，当sleep的时间片结束后，控制转移回hello保存的上下文，控制传递给hello。 6.5.4 用户态与核心态转换 可以通过中断，陷阱，故障，终止等异常情况，程序会从用户态转换到内核态，内核保存进程的上下文，恢复下一个进程的上下文来重新启动该进程，控制转交给进程，从核心态转换到用户态 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 6.6.1 可能出现的异常和信号 中断：ctrl+z会发送SIGTSTP信号->进程中断，切换至别的进程 终止：Ctrl+C会发送SIGINT信号->终止回收进程 hello可能会接受其他进程调用kill发送的信号 6.6.2 可能出现的情况 6-6-2-1正常情况 胡乱按键盘对进程没有影响 6-6-2-2胡乱按键盘 6-6-2-3Ctrl+C 按下Ctrl+Z后会发送SIGTSTP信号停止hello进程，此时可以输入其他指定 6-6-2-4Ctrl+Z+（ps，pstree，jobs） 在中断时可以用kill发送信号（上图为SIGKILL，下图为SIGCONT） 6-6-2-4Ctrl+Z+kill 6.7本章小结 进程是重要的概念。可以说我们能看到程序的运行靠的就是进程，了解进程利用进程也是十分重要的一项技能。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：在机器语言中用来确定一个指令或者是操作数的地址。逻辑地址包含段和偏移量，而偏移量是相对偏移，而段则确定了偏移开始的地方，这样就能通过段和偏移来确定地址。在hello中指hello.o中的相对偏移地址 线性地址：逻辑地址与物理地址之间的桥梁。用偏移加上段的地址就能得到线性地址，也就是虚拟内存地址。在hello中指hello中的虚拟内存地址 虚拟地址：虚拟地址和线性地址一样。 物理地址：加载到内存地址寄存器中的地址，内存单元的真正地址。hello的虚拟地址通过地址翻译器可转换成物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址由段地址和偏移地址组成。 计算机中共有4个段寄存器，用于存放数据、代码、堆栈、辅助4段的基地址，段选择符共计16位，前13位为索引位，用于确定段描述符在描述符表中的位置。 第14位为Tl位，Tl=0时选择全局描述符表，Tl=1时选择局部描述符表。 最后两位用于描述段的状态 被选中的描述符先被送至描述符Cache，每次从描述符Cache中取32位基地址，与32位段内偏移量（有效地址）相加得到线性地址 7.3Hello的线性地址到物理地址的变换-页式管理 Linux的线性地址到物理地址的转换，是通过页式管理完成的。一组固定长度的线性地址的集合被称为页面，一般来说页面有4KB大小。 线性地址的后12位是页内偏移（VPO） 前面36位是虚拟页号（VPN），通过VPN可以找到相应的物理地址所在的页，如果有多级页表，VPN将会被分成多份。第i个VPN作为第i级页表的索引指向第i+1级页表的基址。最后一级页表中的PTE包含每个物理页面的页号（PPN） 转换的具体过程如下： 1、CPU产生一个虚拟地址，将虚拟地址传递给主存 2、MMU从TLB中取出相应的PTE，通过PTE找出VPN对应的物理页号 3、与页内偏移量结合构成物理地址 7.4TLB与四级页表支持下的VA到PA的变换 TLB称为翻译后备缓冲器，是关于PTE的高速缓存。 如果TLB有T=2^t组，那么TLB索引（TLBI）是由VPN的最低t位组成，而TLB标记（TLBT）是由VPN剩余的位组成的 将VA的后12位作为VPO，前36位作为VPN MMU会先从TLB中寻找PTE，根据索引找到对应的组，如果组内存在标记相同切有效为为1的pte那么获得pte中的ppn。 如果没找到，内核就会通过内存和cache寻找。 将32位的vpn分为4个9位的vpn（1，2，3，4） 通过一个固定寄存器中的值获得以及页表的基地址，然后由vpn1作为索引找到第二级页表的基址，然后由vpn2作为索引，以此类推，直到vpn4指向的就是对应的ppn的值。 最后将ppn和VPO合成得到PA 7.5三级Cache支持下的物理内存访问 Cache的工作原理：内核通过内存地址的组索引找到对应的组。找到组内标记相同且有效位为1的块，返回块内的值。如果没有找到就是不命中，就需要从下一级cache中寻找，或者是内存（如果在第三级cache中不命中）。 找到数据后会对不命中的cache进行替换，放置在组内的空闲块或者驱逐最久没被使用的有效块（如果组内已满） 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。内核将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同，当这两个进程中的任一个后来进行写操作时，写时复制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 *删除已存在的用户区域：删除当前进程的虚拟地址的用户部分中的已存在的区域结构 *映射私有区域：为hello的代码、数据、bss和栈区域创建新的数据结构。私有的、写时复制。 *映射共享区域：将hello与共享对象动态链接，再映射到用户虚拟地址空间中的共享区域内 *设置程序计数器(PC)设置hello上下文中的程序计数器 7.8缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。 当发生缺页中断时，操作系统会调用缺页处理子程序。 程序会先判断虚拟地址A是否合法（否则出现段错误：访问一个不存在的页面），然后判断试图进行的内存访问是否合法（否则发生保护异常：例如，违反许可，写一个只读的页面）。 如果内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的，就会选择一个牺牲页面，如果这个页面被修改过，那么就将该页交换出去，换入新的页面并更新页表。然后返回程序中断处的当前指令，再次发送A到MMU，这次就可以正常翻译了。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。 分配器将堆视为一组大小不同的块的集合进行维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。 已分配的块显式地保留为供应用程序使用，空闲块可以用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已经分配的块保持已分配状态直到它被释放，释放要么由应用程序显式执行，要么由内存分配器隐式执行。 malloc函数为显式分配器，可以从堆中申请一块内存并返回指向该块的指针。 隐式空闲链表： 块的结构为头部：块大小+标志位（a已分配/f空闲）、（有效载荷+填充）和尾部（等于头部），通过头部存储的值将所有块连接起来。 显式空闲链表： 空闲块的结构为头部：块大小+标志位（a已分配/f空闲）、前驱指针、后继指针和尾部（等于头部），通过前后指针将空闲块用链表串联起来。 不同的空闲块会根据大小分类串到不同的链表中 分配: 首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。 下一次适配：每一次都从上一次搜索结束的地方开始搜索，选择第一个合适的空闲块。 最佳适配：对堆进行全面搜索，找到最合适的块。 增加堆的空间： 通过调用sbrk函数，申请额外的存储器空间，插入到空闲链表中。 合并空闲块：当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻，造成假碎片现象。即相邻的块被切割成了小块而无法使用。因此，合并空闲块的目的即为消除假碎片现象，提升内存利用率。 策略： 1、立即合并：释放完内存就合并 2、推迟合并：直到发生某种情况需要合并时再合并 7.10本章小结 所有的进程都需要调用内存，hello也不例外，然而hello自认为调用所有内存工作，实际上只是内存的“替身”罢了。 了解虚拟内存的工作原理，以及高速缓存、缺页异常和动态分配等等，揭开内存的真面目，才能再今后的计算机工作以应万变。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 一个linux文件就是一个m个字节的序列： B0,B1,…,Bk,…,Bm-1 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 UnixIO接口： 打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，作为描述符，它会在对文件所有操作中标识这个文件。 Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1），标准错误（描述符为2）。头文件定义了常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，它们可用来代替显式的描述符值。 改变当前的文件位置：内核保持这一个文件位置k，初始为0。文件位置是从文件开头起始的字节偏移量，应用程序能够通过seek操作，显式地设置文件的当前位置。 读写文件：一个读操作是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。（当k>=m时执行读操作会触发EOF条件，m为文件字节大小）写操作是从内存复制n>0个字节到文件，从当前文件位置开始，然后更新k。 关闭文件：当应用完成对文件的访问之后，通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 函数： open()： 函数原型：intopen（char*filename,intflags,mode_tmode） open函数将filename转换为一个文件描述符，并且返回描述符数字。若出错返回-1，否则返回新文件描述符，返回的描述符总是在进程中当前没有打开的最小描述符。flags指明进程打算如何访问文件： O_RDONLY:只读 O_WRONLY:只写 O_RDWR:可读可写 flags也可以是一个或更多位掩码的或，提供额外的指示： O_CREATE：文件不存在则创建 O_TRUNC：文件存在则截断 O_APPEND：写操作时设置到文件的结尾处 mode参数制定了新文件的访问权限位 close()：关闭一个打开的文件，若成功返回0，出错时返回-1 函数原型：intclose（intfd） 参数：fd文件描述符 read()：read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf，返回值-1表示一个错误，返回值为0表示EOF，否则，返回值表示的是实际传送的字节数量 函数原型：ssize_tread(intfd,void*buf,size_tn) 其中fd为文件描述符，buf缓冲区，n为传送字节数 write()：write函数从内存位置buf复制最多n个字节到描述符为fd的当前文件位置，返回值-1表示错误，否则，返回值表示写的字节数量 函数原型：ssize_twrite(intfd,constvoid*buf,size_tn) 其中fd为文件描述符，buf缓冲区，n为传送字节数 lseek：显式地修改当前文件的位置 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 机器的工作是在纷繁复杂的二进制码中计算和运转，但是在显示屏上显示的，在键盘上输入的，却是人类能懂的语言文字，这就要归功于计算机功能完备的IO系统。 实际上所有输入输出设备都被模型化为文件，在UnixI/O接口中完成用户和机器的沟通，可谓十分的巧妙。 （第8章1分） 结论 hello.c 预处理->hello.i预处理后的文件 编译->hello.s汇编语言文件 汇编->hello.o可重定位目标文件 链接->hello可执行文件 通过深入理解计算机系统，我对于该如何编写对编译器友好的代码，优化程序的性能有了更多的想法。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.c：hello源代码 hello.i：预处理后的文本文件 hello.s：编译后的汇编文件 hello.o：汇编后的可重定位目标文件 hello：链接后的可执行文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 https://blog.csdn.net/dlutbrucezhang/article/details/8753765https://blog.csdn.net/zycdeCSDN/article/details/102084045https://www.jianshu.com/p/b7e44f749211https://www.jianshu.com/p/3e3218ef0bcfhttps://www.cnblogs.com/pianist/p/3315801.html （参考文献0分，缺失-1分） 
第103篇文章[]
HashMap的底层实现原理 HashMap是最常用的Map接口的实现类型，通过存储键值对的方式，来表示两个集合的映射关系。 一、构造方法 HashMap有四个构造方法 HashMap() //无参构造方法HashMap(intinitialCapacity) //指定初始容量的构造方法HashMap(intinitialCapacity,floatloadFactor)//指定初始容量和负载因子HashMap(Map<?extendsK,?extendsV>m)//指定集合，转化为HashMap HashMap默认初始容量为16，HashMap的扩容十分耗时，如果能提前知道容量尽量提前设置。扩容时会将容量翻倍。 二、数据结构 HashMap的主要数据结构是哈希表，用“拉链法”实现。 哈希表是一组链表的数组。以内置静态类Entry作为结点，Entry的属性有hash，key，value，next 通过Entry.next将所有Entry连接成链表 哈希表通过类型K的内置函数hashCode()，根据这个函数和容量len，可以直接确定查找值所在位置，而不需要一个个比较。这样就Entry所在的位置，直接找到数据，提升效率。 三、函数实现 1.get(Kkey) 首先要寻找key的Entry，计算key.hashCode()%len，得到index，那么就在Entry[index]所在的链表中找到对应key相等的Entry,然后返回Entry中的value即可，如果没找到则返回null 2.put(Kkey,Vvalue) 计算key.hashCode()%len，得到index，遍历Entry[index]如果找到对应的key，替换上新的value并返回原来的value。否则调用addEntry(hash,key,value,index),即给链表添加新的Entry结点 三、后记 在Jdk1.8中，引用了红黑树，进一步提高了HashMap的效率，HashMap的实现方式做了一些改变，数据结构的存储由数组+链表的方式，变化为数组+链表+红黑树的存储方式，但是基本思想没有改变 
第104篇文章[]
哈工大 软件构造广度搜索 在Lab1实验三中对人际关系的搜索中需要使用广度搜索。由于Java中没有提供现成的队列，我对当时的Person类额外添加了两个属性，一个是是否已经访问的标志isVisited和用于广度遍历时记录层数的lengthpackageP3;importjava.util.*; publicclassPerson{publicintlength;publicStringname;publicbooleanisVisited;publicListneighborlist;publicPerson(Stringname){this.name=name;length=0;isVisited=false;neighborlist=newArrayList();}} 手写了一个很简单的队列packageP3;importjava.util.*; publicclassMyQueue{publicListQueueList;publicMyQueue(){QueueList=newArrayList();}publicvoidOffer(Personname){QueueList.add(name);}publicPersonPoll(){if(QueueList.isEmpty()){returnnull;}returnQueueList.remove(0);}}这里使用了动态数组，所以入队操作直接使用add，加到数组尾部而pop是将队头元素抛出所以用remove（0）实现。 
第105篇文章[]
软件构造---关于list 已知LinkedList和ArrayList均实现了List接口二者实现结构不同arraylist是基于数组，linkedlist是基于链表因此对于随机访问get和set，ArrayList优于LinkedList，因为ArrayList可以随机定位，而LinkedList要移动指针一步一步的移动到节点处。同时对于add和remove方法，链表的明显比数组有优势的多。对于get，由于数组可以随机访存，链表是顺序的，所以get方法ArrayList时间开销较小。另外arraylist的初始化时默认10容量，而linkedlist默认初始化为空。综上，如果对list有较多的增删操作那么优先选用linkedlist，如果只是访问较多的话，那么arraylist优势较大。不过我一般都直接用arraylist。。 
第106篇文章[5]
Hello,CSDN Hey,thisismyfirstblogfortesting!Hello,CSDN! 
第107篇文章[]
哈工大 软件构造关于迭代器Iterator 哈工大 软件构造关于迭代器Iterator迭代器Iterator提供了遍历集合类的方法，主要用法为：Iterator<Integer>it=mylist.iterator.声明一个迭代器遍历的时候基本格式为while(it.hasNext()){Integeri=it.next();…}需要使用迭代器的时候为：遍历时删除元素由于arraylist每次遍历的时候会去判断该集合是否被修改过，调用的方法是checkForComodification()。如果被修改会抛出ConcurrentModificationException异常。机制主要是通过维护2个变量来实现，modCount记录了修改次数，expectedModCount记录期望修改次数。通过iterator.remove()进行的删除操作，会同时修改modCount、ConcurrentModificationException;而通过list.remove(object/index)，则只会修改modCount。这也是fast-fail机制。而迭代器里面的删除同步了expectedModCount和modCount这两个值，所以不会报错。但是，需要注意的是，在使用迭代器一边遍历一边删除同时进行增加时，还是会报错，抛出ConcurrentModificationException异常，这里我个人的解决方案是在遍历过程中设置一个addflag变量，如果遍历过程中会有新元素加入，那么先记录数值并设置addflag为true，在遍历完成后再根据addflag决定是否向集合类中增加相应元素。 
第108篇文章[1]
哈工大计算机系统大作业程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号1190200410班 级1936602学生何纪辉 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文通过借助相关工具对hello.c程序的预处理、编译、汇编、链接等过程进行分析，了解一个程序是如何从开始到结束的。 关键词：预处理；编译；汇编；链接；目录 第1章概述-4-1.1HELLO简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在UBUNTU下预处理的命令-5-2.3HELLO的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在UBUNTU下编译的命令-6-3.3HELLO的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在UBUNTU下汇编的命令-7-4.3可重定位目标ELF格式-7-4.4HELLO.O的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在UBUNTU下链接的命令-8-5.3可执行目标文件HELLO的格式-8-5.4HELLO的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6HELLO的执行流程-8-5.7HELLO的动态链接分析-8-5.8本章小结-9-第6章HELLO进程管理-10-6.1进程的概念与作用-10-6.2简述壳SHELL-BASH的作用与处理流程-10-6.3HELLO的FORK进程创建过程-10-6.4HELLO的EXECVE过程-10-6.5HELLO的进程执行-10-6.6HELLO的异常与信号处理-10-6.7本章小结-10-第7章HELLO的存储管理-11-7.1HELLO的存储器地址空间-11-7.2INTEL逻辑地址到线性地址的变换-段式管理-11-7.3HELLO的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级CACHE支持下的物理内存访问-11-7.6HELLO进程FORK时的内存映射-11-7.7HELLO进程EXECVE时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章HELLO的IO管理-13-8.1LINUX的IO设备管理方法-13-8.2简述UNIXIO接口及其函数-13-8.3PRINTF的实现分析-13-8.4GETCHAR的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。P2P：高级语言编写得到.c文件，经过预处理得到.i文件，再编译得到.s文件，然后汇编器as将.s文件转化为可重定位目标程序，最后由链接器ld将其变为可执行的目标程序。在shell中运行，OS会通过fork为其创建一个新的进程。020：操作系统调用execve后映射虚拟内存，并依据需求载入物理内存再进入main函数执行代码。执行完成后，父进程回收hello进程内核删除相关数据结构。1.2环境与工具硬件环境：Intel®Core™i5-8265UCPU@1.60GHz1.80GHz8GRAM软件环境：Windows10家庭中文版&VMware+Ubuntu18.04.564位开发与调试工具：Devc++，CodeBlocks，objdump，gdb，edb1.3中间结果hello.i预处理后的文件hello.s编译生成的汇编文件hello.o汇编生成的可重定位文件hello链接后生成的hello的可执行目标程序1.4本章小结本章主要是对整篇文章一个简介，简单介绍了P2P，020以及实验环境和实验过程中生成的中间文件。 （第1章0.5分） 第2章预处理2.1预处理的概念与作用概念预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。典型地，由预处理器(preprocessor)对程序源代码文本进行处理，得到的结果再由编译器核心进一步编译。这个过程并不对程序的源代码进行解析，但它把源代码分割或处理成为特定的单位。通常前几个阶段由预处理器实现。作用作用：1）处理文件包含：对于C源程序中的#include指令，如#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它们直接插入到程序文本中。2）处理宏定义：对于#define指令，进行宏替换，用所定义的实际值去替换代表它的符号。3）处理注释：删除C源程序中的注释内容。4）处理条件编译：根据条件编译指令（如#if、#elif、#else等），按条件选择符合的代码送至编译器编译，从而有选择地执行相应操作。2.2在Ubuntu下预处理的命令cpphello.c>hello.i2.3Hello的预处理结果解析代码量大幅增加，文件开头加入大量头文件内容，最初的代码被放在了文件末尾。可以看到stdio.hunistd.hstdlib.h被从系统中读取并展开插入到程序文本中。cpp到默认的环境变量下搜索stdio.h头文件，打开/usr/include/stdio.h，发现其中仍有#include指令，于是再去搜索包含的头文件，直到最后的文件中没有#include指令，并把所有文件中的所有#define和#ifdef指令进行处理，执行宏替换和通过条件确定是否处理定义的指令。2.4本章小结本届主要介绍预处理概念及其作用，并结合hello.c预处理后得到的hello.i进行分析。（第2章0.5分） 3.1编译的概念与作用概念：通过词法分析，语法分析语义分析等方法把代码转化为汇编指令的过程。编译的作用编译器做一些语法分析、词法分析、语义分析等，若检查无错误，便将高级程序设计语言（C语言）书写的程序转变为与其等价的汇编语言程序（依据优化程度的不同可能会对代码进行优化）。汇编语言是介于高级语言和机器语言之间的中间代码，它为不同高级语言的不同编译器提供了通用的输出语言，使他们产生的输出文件都是用的一样的输出语言。3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s3.3Hello的编译结果解析.file：源文件名.text:代码段.global:全局变量.data:数据段.align:对齐方式.type:指定类型是对象类型或者函数类型.size:大小.long：长整型.section.rodata:rodata节（只读数据节）.string:字符串 1.常量： 常量均以立即数形式出现 2.变量（1）全局变量sleepsecssleepsecs是global的，类型为对象，占据4个字节保存在.rodata节（2）main函数参数argc被%edi保存，并储存在-20(%rbp)（3）循环变量i被赋初值为0并且每次循环+1保存在-4(%rbp)（4）argv作为第二个参数被从%rsi保存到-32(%rbp)3.类型转换可以看到对sleepsecs的赋值中把浮点强转为了int而在汇编中，sleepsecs被定义为long类型数值为2。4.赋值movl指令对循环变量i赋初值0对全局变量sleepsecs赋初值25.算术操作1.addl指令这里是对循环变量进行加1操作2.leaq指令分别是计算了.LC0和.LC1的段地址并与(%rip)相加之后传递给%rdi6.关系操作表达式argc!=3i<101)argc!=3框内语句为执行if语句时的判断部分2)框内语句为执行循环时的判断部分7.控制转移1）红框为执行的if语句，如果arc==3则执行L2中语句即第二个黑框的代码，反之则执行第一个黑框的代码。2）这部分为for循环语句，黑框L2语句为循环变量i赋初值并跳到L3部分，L3红框部分为循环的判断部分，如果判断条件成立则进入循环体L4执行，每次循环完给循环变量+1并再次进入L3红框部分判断。知道判断条件不成立跳出循环。8.函数操作1.main函数参数传递:argv和argc函数调用：系统调用函数返回：返回0将%eax赋值为0并返回2.printf函数参数传递：callputs时只传入了字符串参数首地址；for循环中callprintf时传入了argv[1]和argc[2]的地址。函数调用：前者是if语句条件满足时执行，后者是在每次循环时被调用3.exit函数参数传递：传入参数1，执行退出命令函数调用：满足if语句时执行4.sleep函数：参数传递：传入参数sleepsecs，传递控制：callsleep函数调用：for循环下被调用5.getchar函数传递控制：callgetchar函数调用：在main中被调用3.4本章小结了解了预处理文件经过编译得到的.s（汇编代码）文件具体内容，对其从常、变量，操作控制函数等方面解析。对代码执行时内部寄存器操作有一定了解。虽然相较高级语言较复杂，但是是了解底层必须了解的。并且有一个初步结论，语言越低级，对机器越友好，语言越高级对程序员越友好。（第3章2分） 第4章汇编4.1汇编的概念与作用概念:汇编器（as）将汇编语言程序翻译成等价的机器指令的过程，并将这些指令打包成可重定位目标程序的格式，并将结果保存在目标文件hello.o中。（hello.o是一个二进制文件）作用:将汇编语言翻译成机器指令，用二进制符号代替汇编语言符号，使之可以被机器直接识别。4.2在Ubuntu下汇编的命令ashello.s-ohello.o4.3可重定位目标elf格式使用readelf-hhello.o查看ELF头信息可知hello.o是可重定位文件，采用补码，小端序输入readelf-Shello.o查看节头信息输入readelf-shello.o查看符号表输入readelf-rhello.o查看重定位信息4.4Hello.o的结果解析objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 输入objdump-d-rhello.o>hello.oasm得到hello.o的反汇编文本与之前hello.s的对比 汇编语言中操作数是十进制的而机器语言反汇编得到的操作数是十六进制的。对全局变量（即字符串常量）的引用，汇编语言中是用的全局变量所在的那一段的名称加上%rip的值，而hello.o中用的是0加%rip的值，因为当前为可重定位目标文件，之后还需经过重定位方可确定其具体位置，所以这里都用0来代替。3.分支转移hello.s中汇编语言跳转指令用段名称（L3、L4）表示跳转地址。hello.o中因为每行指令被分配了对应的地址，在跳转指令后用目的地址来表示跳转到的位置。4.函数调用hello.s汇编语言畸形函数调用时call指令后用函数名表示对其的调用而在反汇编后的call指令后加上需调用的函数的地址来表示。可以发现，反汇编的每个call指令的操作数都为0，即相对地址都为0，因为需要链接生成可执行文件后才会生成确定地址，这里相对地址都用0代替。.5本章小结通过汇编器实现了hello从汇编语言到机器语言的转变（从.s到.o），hello到此可以被机器直接理解。hello的每条指令被分配了一个临时的地址，并通过不同地址之间的跳转实现把程序连成一个整体。我们通过对elf格式和机器语言与汇编语言的映射的观察对hello.o有一个初步了解。（第4章1分） 第5章链接5.1链接的概念与作用概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载（复制）到内存并执行。作用：把预编译好了的若干目标文件合并成为一个可执行目标文件。使得分离编译称为可能，不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为可独立修改和编译的模块。当改变这些模块中的一个时，只需简单重新编译它并重新链接即可，不必重新编译其他文件。5.2在Ubuntu下链接的命令ld-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.o/usr/lib/gcc/x86_64-linux-gnu/7/crtbegin.o/usr/lib/gcc/x86_64-linux-gnu/7/crtend.o/usr/lib/x86_64-linux-gnu/crtn.ohello.o-lc-zrelro-ohello5.3可执行目标文件hello的格式ELF头节头信息程序头5.4hello的虚拟地址空间其中的虚拟地址在edb的DataDump中都能找到对应位置 还可发现DataDump是从地址0x400000开始的，并且该处有ELF的标识，可以判断从可执行文件时加载的信息（只读代码段，读/写段）是从地址0x400000处开始的。5.5链接的重定位过程分析在hello中可以看到各函数的代码段并且每个函数的每条指令都有对应的虚拟地址。在hello.o中main函数起始地址为0而在hello.o中main函数起始地址为0x4005e7.在hello.o中由于没有链接，对全局变量的引用部分操作数为0而在hello中因为已经对全局变量进行定位，所以引用时使用了确定的相对偏移加上%rip的值来确定其位置。对于函数的调用，因为hallo.o中并为对函数进行定位所以调用时用call加下一条指令的地址表示而hello中使用其虚拟地址进行调用。对于跳转指令，hello.o中在其后加上目的地址，为main从0开始对每条指令分配的地址；而hello中同样加上目的地址，但这里是每条指令的虚拟地址。除了main函数，hello比hello.o多出了几个函数：printf、sleep、puts、getchar、atoi、exit。 除了.text节的区别外，hello1.ob比hello.ob多出了几个节：.init节、.plt节、.fini节。其中.init节是程序初始化需要执行的代码，.fini节是程序正常终止时需要执行的代码，.plt节是动态链接中的过程链接表。5.6hello的执行流程_dl_start_dl_init_start_libc_start_main_cxa_atexitlibc_csu_init_setjmp_sigsetjmp_sigjmp_savemain(argc!=3时:puts,exit)printsleepgetchar_dl_runtime_resolve_xsave_dl_fixupexit5.7Hello的动态链接分析当程序调用一个由共享库定义的函数时，编译器无法预测这个函数运行时的地址，因为定义它的共享模块在运行时可以加载到任何位置。这时，编译系统提供了延迟绑定的方法，将过程地址的绑定推迟到第一次调用该过程时。他通过GOT和过程链接表PLT的协作来解析函数的地址。在加载时，动态链接器会重定位GOT中的每个条目，使它包含正确的绝对地址，而PLT中的每个函数负责调用不同函数。在dl_init调用之前，对于每一条PIC函数调用，调用的目标地址都实际指向PLT中的代码逻辑，GOT存放的是PLT中函数调用指令的下一条指令地址。可以看到调用dl_init后0x404008和0x404010处的两个8字节的数据发生改变，出现了两个地址0x7f85442c2190和0x7f85442ad200。5.8本章小结本章介绍了链接的概念和作用，对链接后生成的可执行文件hello的elf格式文件进行了分析，分析了hello的虚拟地址空间、重定位过程、执行过程的各种处理操作。链接完成之后hello便可以开始在shell中运行了。（第5章1分） 第6章hello进程管理6.1进程的概念与作用进程的概念：一个执行中的程序的实例，同时也是系统进行资源分配和调度的基本单位。一般情况下，包括文本区域、数据区域和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。 进程的作用：，它提供一个假象，好像我们的程序独占地使用内存系统，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。6.2简述壳Shell-bash的作用与处理流程shell-bash的作用：shell-bash是一个C语言程序，它代表用户执行进程，它交互性地解释和执行用户输入的命令，能够通过调用系统级的函数或功能执行程序、建立文件、进行并行操作等。同时它也能够协调程序间的运行冲突，保证程序能够以并行形式高效执行。bash还提供了一个图形化界面，提升交互的速度。 shell-bash的处理流程：(1)终端进程读取用户由键盘输入的命令行。(2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量(3)检查第一个命令行参数是否是一个内置的shell命令(3)如果不是内部命令，调用fork()创建新进程/子进程(4)在子进程中，用步骤2获取的参数，调用execve()执行指定程序。(5)如果用户没要求后台运行(命令末尾没有&号）否则shell使用waitpid等待作业终止后返回。(6)如果用户要求后台运行(如果命令末尾有&号），则shell返回；6.3Hello的fork进程创建过程打开Terminal输入./hello学号姓名shell分析这条命令，由于./hello不是内置命令，于是判断./hello的语义是执行当前目录下可执行目标文件hello。然后Terminal调用fork创建一个新的子进程。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程与子进程之间的区别在于它们拥有不同的PID。6.4Hello的execve过程execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。所以execve调用一次并不返回。加载运行hello需要以下步骤： 删除已存在的用户区域，删除当前进程虚拟地址的用户部分中已存在的区域结构映射私有区域，为新程序的代码、程序、bss和栈区域创建新的区域结构。代码和数据区域被映射为hello文件的.text和.data区。bss区域是请求二进制零的，映射到匿名文件其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。映射共享区域。设置程序计数器使之指向代码区域的入口点。6.5Hello的进程执行系统中通常有许多程序在运行，那么进程会为每个程序提供一个好像它在独占地使用处理器的假象。这时依赖于进程提供的独立的逻辑控制流（由上下文切换机制提供）。如一个系统运行着多个进程，那么处理器的一个物理控制流就被分成了多个逻辑控制流，每个进程1个。这些逻辑流的执行是交错的，它们轮流使用处理器，会存在并发执行的现象。其中，一个进程执行它的控制流的一部分的每一时间段叫做时间片。这样的机制使进程在执行时仿佛独占了处理器。处理器用某个控制寄存器中的一个模式位来限制一个应用可以执行的指令以及它可以访问的地址空间范围。没有设置模式位时，进程运行在用户模式中，它必须通过系统调用接口才可间接访问内核代码和数据；而设置模式位时，它运行在内核模式中，可以执行指令集中的任何指令，访问系统内存的任何位置。异常发生时，控制传递到异常处理程序，由用户模式转变到内核模式，返回至应用程序代码时，又从内核模式转变到用户模式。内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占进程所需的状态。它由一些对象的值组成，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构。在进程执行的某些时刻，内核可以决定抢占当前进程，并且重新开始一个先前被抢占了的进程。这种决策叫做调度由内核中被称为调度器的代码处理的。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换1）保存当前进程的上下文，2）恢复某个先前被抢占的进程被保存的上下文，3）将控制传递给这个新恢复的进程。当程序在执行sleep函数时，系统调用显式地请求让调用进程休眠，调度器抢占当前进程，并发生上下文切换，将控制转移到新的进程，此时计时器开始，当计时器达到传入的第四个参数大小（这里是1s）时，产生一个中断信号，中断当前正在进行的进程，进行上下文切换恢复hello的上下文信息，控制会回到hello进程中。当循环结束后，程序调用getchar函数用getchar时，由用户模式进入内核模式，内核中的陷阱处理程序请求来自键盘缓冲区的信号传输，并执行上下文切换把控制转移给其他进程。数据传输结束之后，引发一个中断信号，控制回到hello进程中，执行return，进程终止。6.6hello的异常与信号处理（以下格式自行编排，编辑时删除）hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 可能会出现四类异常：中断、陷阱、故障、终止。5.中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。中断处理程序对其进行处理，返回后继续执行调用前待执行的下一条代码。6.陷阱是有意的异常，是执行一条指令的结果，调用后返回到下一条指令。用来调用适当的内核程序，使程序从用户模式切换到内核模式。7.故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。如果无法修正，则终止程序。8.终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。终止处理程序从不将控制返回给应用程序。处理程序将控制返回给一个abort例程，该例程会终止这个应用程序。hello执行过程中可能出现的信号如下hello对各种信号的处理的分析 正常运行hello程序程序在执行结束后，进程被回收。随便乱按乱按会将输入的内容保存在缓冲区，等进程结束后作为命令行的内容输入。运行过程中按下Ctrl+C运行过程中按下Ctrl+Z当按下Ctrl-Z之后，shell进程收到SIGSTP信号，信号处理函数的逻辑是打印屏幕回显、将hello进程挂起，通过ps命令我们可以看出hello进程没有被回收，其进程号时7308，用jobs命令看到jobID是1，状态是Stopped，使用fg1命令将其调到前台，此时shell程序首先打印hello的命令行命令，然后继续运行打印剩下的信息，之后再按下Ctrl-Z，将进程挂起。 用pstree查看进程用kill-92475杀死hello进程6.7本章小结本章分析了shell的作用、处理流程和fork、execve过程以及各种异常。最后分析了hello执行过程中的异常和异常处理。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：在有地址变换功能的计算机中，访内指令给出的地址(操作数)叫逻辑地址，也叫相对地址。分为两个部分，一个部分为段基址，另一个部分为段偏移量。线性地址：逻辑地址经过段机制后转化为线性地址，为描述符:偏移量的组合形式。分页机制中线性地址作为输入。虚拟地址：CPU启动保护模式后，程序运行在虚拟地址空间中。与物理地址相似，虚拟内存被组织为一个存放在磁盘上的N个连续的字节大小的单元组成的数组，其每个字节对应的地址成为虚拟地址。虚拟地址包括VPO（虚拟页面偏移量）、VPN（虚拟页号）、TLBI（TLB索引）、TLBT（TLB标记）。物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址。结合hello的反汇编文件，main函数的起始地址0x4005e7，这里的0x4010c1是逻辑地址的偏移量部分，偏移量再加上代码段的段地址就得到了main函数的虚拟地址（线性地址），虚拟地址是现代系统的一个抽象概念，再经过MMU的处理后将得到实际存储在计算机存储设备上的地址。7.2Intel逻辑地址到线性地址的变换-段式管理逻辑地址由段选择符和偏移量组成，线性地址为段首地址与逻辑地址中的偏移量组成。其中，段首地址存放在段描述符中。而段描述符存放在描述符表中，也就是GDT（全局描述符表）或LDT（局部描述符表）中。其中TI指示段描述符是在GDT还是LDT中，而索引指示段描述符在段描述符表中的位置。由此，便可以通过段选择符的指示在段描述符表中找到对应的段描述符，然后便可从段描述符中获得段首地址，将其与逻辑地址中的偏移量相加，就得到了线性地址。7.3Hello的线性地址到物理地址的变换-页式管理 线性地址（虚拟地址）由虚拟页号VPN和虚拟页偏移VPO组成。首先，MMU从线性地址中抽取出VPN，并且检查TLB，看他是否因为前面某个内存引用缓存了PTE的一个副本。TLB从VPN中抽取出TLB索引和TLB标记，查找对应组中是否有匹配的条目。若命中，将缓存的PPN返回给MMU。若不命中，MMU需从页表中的PTE中取出PPN，若得到的PTE无效或标记不匹配，就产生缺页，内核需调入所需页面，重新运行加载指令，若有效，则取出PPN。最后将线性地址中的VPO与PPN连接起来就得到了对应的物理地址。7.4TLB与四级页表支持下的VA到PA的变换为了消除每次CPU产生一个虚拟地址MMU就查阅一个PTE带来的时间开销，许多系统都在MMU中包括了一个关于PTE的小的缓存，称为翻译后被缓冲器（TLB），TLB的速度快于L1cache。TLB通过虚拟地址VPN部分进行索引，分为索引（TLBI）与标记（TLBT）两个部分。这样，MMU在读取PTE时会直接通过TLB，如果不命中再从内存中将PTE复制到TLB。同时，为了减少页表太大而造成的空间损失，可以使用层次结构的页表页压缩页表大小。虚拟地址VA虚拟页号VPN和虚拟页偏移VPO组成。若TLB命中时，所做操作与上面相同；若TLB不命中时，VPN被划分为四个片，每个片被用作到一个页表的偏移量，CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，依次类推。最后在L4页表中对应的PTE中取出PPN，与VPO连接，形成物理地址PA。7.5三级Cache支持下的物理内存访问已知Corei7的三级cache是物理寻址的，块大小为64字节。LI和L2是8路组相联的，而L3是16路组相联的。Corei7实现支持48位虚拟地址空间和52位物理地址空间。因为L1块大小为64字节，所以B=64，b=6.因为L1是8路组相联所以S=8，s=3.所以标记位为43位。根据物理地址的s位组索引索引到L1cache中的某个组，然后在该组中查找是否有某一行的标记等于物理地址的标记并且该行的有效位为1，若有，则说明命中，从这一行对应物理地址b位块偏移的位置取出一个字节，若不满足上面的条件，则说明不命中，需要继续访问下一级cache，访问的原理与L1相同，若是三级cache都没有要访问的数据，则需要访问内存，从内存中取出数据并放入cache。7.6hello进程fork时的内存映射当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给他一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中每个区域结构都标记为私有的写时复制。7.7hello进程execve时的内存映射execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。 1.删除已存在的用户区域，删除当前进程虚拟地址的用户部分中已存在的区域结构2.映射私有区域，为新程序的代码、程序、bss和栈区域创建新的区域结构。代码和数据区域被映射为hello文件的.text和.data区。bss区域是请求二进制零的映射到匿名文件其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。3.映射共享区域。4.设置程序计数器使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理缺页故障是一种常见的故障，当指令引用一个虚拟地址，在MMU中查找页表时发现与该地址相对应的物理地址不在内存中，因此必须从磁盘中取出的时候就会发生故障。缺页中断处理：缺页处理程序是系统内核中的代码，选择一个牺牲页面，如果这个牺牲页面被修改过，将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送VA到MMU，。7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。隐式空间链表头部编码了这个块的大小(包括头部和所有的填充),以及这个块是已分配的还是空闲的。块的头最后一位指明这个块是已分配的还是空闲的。头部后面是应用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。块的格式如图所示，空闲块通过头部块的大小字段隐含的连接着。1)放置已分配的块当一个应用请求一个k字节的块时，分配器搜索空闲链表。查找一个足够大可以放置所请求的空闲块。分配器搜索方式的常见策略是首次适配、下一次适配和最佳适配。(2)分割空闲块一旦分配器找到一个匹配的空闲块，就必须做一个另策决定，那就是分配这个块多少空间。分配器通常将空闲块分割为两部分。第一部分变为了已分配块，第二部分变为了空闲块。显式空间链表使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。一种方法使用后进先出的顺序维护链表，将新释放的块在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块，在这种情况下，释放一个块可以在线性的时间内完成，如果使用了边界标记，那么合并也可以在常数时间内完成。按照地址顺序来维护链表，其中链表中的每个块的地址都小于它的后继的地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序首次适配比LIFO排序的首次适配有着更高的内存利用率，接近最佳适配的利用率。 7.10本章小结本章对hello的存储空间进行了简要概况，介绍了逻辑地址、虚拟地址、物理地址与线性地址的概念与转换方法，回顾了fork和execve函数，介绍了动态内存分配管理。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件设备管理：unixio接口所有IO设备都被模型化为文件所有输入输出被当做文件读写来执行。将设备映射为文件的方式允许Linux内核引出一个应用接口（UnixIO）这使得所有输入输出都能以一种统一的方式来执行。8.2简述UnixIO接口及其函数1.打开文件：程序要求内核打开文件，表示它想访问一个I/O设备。内核返回一个小的非负整数称为描述符。内核记录有关这个打开文件的信息。程序只要记录这个描述符就能记录打开文件所有信息。2.shell在进程开始打开三个文件：标准输入（描述为0）、标准输出（描述符为1）、标准错误（描述符为2）。3.改变当前文件位置：对于每个打开的文件，内核保存着一个文件位置k，初始为0。这个文件位置从文件开头起始的字节偏移量。应用程序能通过执行seek操作显式的设置文件的当前位置k。4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会触发一个称为EOF的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的EOF符号。5.关闭文件：内核释放打开文件时创建的数据结构以及占用的内存资源并将描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。UnixIO接口的函数： 打开文件intopen(char*filename,intflags,mode_tmode);open函数将filename转换为一个文件描述符，并返回描述符数字。flags参数指明进程准备如何访问这个文件，mode参数制定了新文件的访问权限位。关闭文件intclose(intfd);关闭一个文件返回操作结果。读文件ssize_tread(intfd,void*buf,size_tn);read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则返回值表示的是实际传送的字节数量。写文件ssize_twrite(intfd,constvoid*buf,size_tn);write函数从内存位置buf复制只多n个字节到描述符fd的当前文件位置。8.3printf的实现分析（以下格式自行编排，编辑时删除）https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析（以下格式自行编排，编辑时删除）异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章介绍了Linux中I/O设备的管理方法，UnixIO函数分析了printf和getchar函数的实现方法。（第8章1分）结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。程序编写程序员将代码键入hello.c预处理预处理器cpp处理以#开头的行得到hello.i编译ccl将hello.i编译成汇编语言文件hello.s汇编器as将hello.s中的汇编语言翻译成机器语言得到可重定位文件hello.o链接器ld将hello.o与动态链接库链接生成可执行目标文件hello运行在shell中输入./hello1190200410何纪辉，shell通过fork创建新进程并通过execve将hello加载运行。一步步执行指令程序运行结束后，父进程进行回收，内核把它从系统中清除。感想：从大一到大二，直到学了这门课程，总算对一个高级语言程序是如何在计算机中运行的有一个初步了解。对计算机从编程课所学的编程语言到数字逻辑课学的与或非门寄存器锁存器等硬件这些课程所带来的分散的印象终于有一个较统一完整的理解。（结论0分，缺失-1分，根据内容酌情加分） 附件列出所有的中间产物的文件名，并予以说明起作用。hello.i预处理文件hello.s经过编译得到的汇编程序hello.o经过汇编得到的可重定位程序hello经过链接得到的可执行目标文件hello.oasmhello.o的反汇编文件（附件0分，缺失-1分） 参考文献为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp.（参考文献0分，缺失-1分） 
第109篇文章[]
有关抽象类的感悟 概念： 在面向对象方法中，抽象类主要用来进行类型隐藏。构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的； 通过从这个抽象体派生，也可扩展此模块的行为功能。为了能够实现面向对象设计的一个最核心的原则OCP(Open-ClosedPrinciple)，抽象类是其中的关键所在。 抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。 抽象类的特点：1，抽象方法一定在抽象类中。2，抽象方法和抽象类都必须被abstract关键字修饰。3，抽象类不可以用new创建对象。因为调用抽象方法没意义。4，抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。 抽象类比一般类多个了抽象函数。就是在类中可以定义抽象方法。抽象类不可以实例化。特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象。 abstract关键字，和哪些关键字不能共存。final：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。private:抽象类中的私有的抽象方法，不被子类所知，就无法被复写。而抽象方法出现的就是需要被复写。static：如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了。可是抽象方法运行没意义。 
第110篇文章[1]
24韩卓宸1190200421CSAPP大作业 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号1190200421班 级1936602学生韩卓宸 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要Hello的P2P，即programtoprocess过程，包括程序员用键盘输入hello。此文件的源代码本文通过对于hello程序的分析，从hello.c直到hello可执行程序进行逐步分析，结合课本上的知识和一些资料，通过乌邦图虚拟机进行试验，试验gdb，edb以及gcc等工具进行试验，把这个学期计算机系统中各章节知识进行融合，形成自己的个性化结果，展示自己的收获，体现自己对于对计算机系统这门课程的理解。 关键词：计算机系统，hello程序的一生； 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介Hello程序的生命周期是从一个源程序,或者说源文件的,即程序员通过编辑器创建并保存的文本文件,文件名是hello.c.hello.c分别经过预处理器cpp的预处理,、编译器ccl的编译，汇编器as的汇编依次生成生成hello.i文件，hello.s文件、,生成hello.o文件、最后使用链接器ld进行链接最终成为可执行目标程序hello.当我们在shell中输入字符串.\hello并使用回车代表输入结束后，shell通过一系列指令的调用将输入的字符读入到寄存器中，之后将Hello目标文件中的代码和数据从磁盘复制到主存。此时shell会调用fork函数创建一个新的进程，并通过加载报存上下文，将控制权交给这个新的进程，具体过程在后面会详细叙述。在hello加载完成后，处理器就开始执行这个程序，翻译成机器语言再翻译成指令编码，最后把程序的调用如：printf等进行链接。新的代码段和数据段被初始化为hello目标文件的内容.然后,加载器会从_start的地址开始,之后会来到main函数的地址，之后进入main函数执行目标代码，CPU为运行的hello分配时间片执行逻辑控制流。执行阶段把这个等执行的程序分解成几个阶段，分别执行对应的指令，最后输出字符串。之后输出的字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示到屏幕上。这标志着进程的终止，shell的父进程回收这个进程操作系统恢复shell的上下文，控制权重回shell，由shell等待接受下一个指令的输入。1.2环境与工具硬件环境：IntelCorei7x64CPU16GRAM512GSSD软件环境：Ubuntu18.04.1LTS开发与调试工具：visualstudioedb,gcc,gdb,readelf,HexEdit,ld，objdump1.3中间结果hello.i预处理器修改了的源程序,分析预处理器行为hello.s编译器生成的编译程序,分析编译器行为hello.o可重定位目标程序,分析汇编器行为hello可执行目标程序,分析链接器行为elf.txthello.o的elf格式,分析汇编器和链接器行为objdump.txthello.o的反汇编,主要是为了分析hello.o 1.4本章小结本章大致主要简单介绍了hello的p2p，020过程，列出了本次实验信息：环境、中间结果，并且大致简介了hello程序从c程序hello.c到可执行目标文件hello的大致经过的历程。 （第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理概念：预处理器cpp根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件。预处理阶段作用：1.处理宏定义指令预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。2.处理条件编译指令条件编译指令如#ifdef，#ifndef，#else，#elif，#endif等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。3.处理头文件包含指令头文件包含指令如#include"FileName"或者#include等。该指令将头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。4.处理特殊符号预编译程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。2.2在Ubuntu下预处理的命令命令：gcchello.c-E-ohello.i 2.3Hello的预处理结果解析 经过预处理之后，hello.c转化为hello.i文件，打开该文件可以发现，文件的内容增加，且仍为可以阅读的C语言程序文本文件。对原文件中的宏进行了宏展开，头文件中的内容被包含进该文件中。例如声明函数、定义结构体、定义变量、定义宏等内容。另外，如果代码中有#define命令还会对相应的符号进行替换。2.4本章小结 本章首先介绍了预处理的定义与作用、之后结合预处理之后的hello.i程序对预处理的结果进行了简单分析。预处理过程为接下来对程序的操作打下了基础，是十分重要，不可或缺的。本章也介绍了预处理的相关概念及其所进行的一些处理，例如实现将定义的宏进行符号替换、引入头文件的内容、根据指令进行选择性编译等。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译要对程序进行以下的过程:首先进行的是语法分析,编译完成的程序使用语法分析器对编译程序输入的符号进行语法检查,检验其语法是否完全符合了语法的标准,如果不完全符合就是产生了错误。编译器使用ccl把一个简单文本翻译文件的其中的一个hello.i翻译成为一个新的hello.s,它的翻译目的主要是为了包含一个可以使用多种汇编语言的应用程序。在机器语言编译的整个过程中,编译器或程序都会产生一种新的中间代码,这种优化就是为了保证下一步的编译器为优化程序进行了充分的准备,大部分的编译器或程序都会针对编译器或程序的功能进行一些优化,目的之一就是在编译器可以很好地实现其原有机器语言功能的前提下提高编译器程序的性能和运行的效率。最后就是使用编译器把已经优化好的编译器和中间代码提取出来进行机器语言编译,调用机器语言汇编的程序,最后生成机器语言的代码。注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序。 3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 3.3Hello的编译结果解析3.3.1汇编指令的介绍 .file:声明源文件.text：代码节.section:.rodata:只读代码段.align：数据或者指令的地址对其方式.string：声明一个字符串（.LC0,.LC1）.global：声明全局变量(main).type:声明一个符号是数据类型还是函数类型3.3.2数据1.字符串 .这两个字符串作为printf函数的参数2.局部变量main函数声明了一个局部变量i，编译器进行编译的时候将局部变量i会放在堆栈中。如图所示，局部变量i放在栈上-4（%rbp）的位置。 3.main函数参数argc作为用户传给main的参数。也是被放到了堆栈中。4.各种立即数立即数直接体现在汇编代码中5.数组：char*argv[]hello.c中唯一的数组是作为main函数的第二个参数，数组的每个元素都是一个指向字符类型的指针。数组的起始地址存放在栈中-32（%rbp）的位置，被两次调用找参数传给printf 3.3.3全局函数 由hello.c可知，hello.c声明了一个全局函数intmain(intargc,char*argv[])，经过编译之后，main函数中使用的字符串常量也被存放在数据区。 这段汇编代码说明main函数是全局函数 3.3.4赋值操作程序中的赋值操作主要有：i=0这条赋值操作在汇编代码主要使用mov指令来实现，而根据数据的类型又有好几种不一样的后缀movb:一个字节movw：两个字节movl：四个字节movq：八个字节 3.3.5算数操作 hello.c中的算数操作有：i++，由于是i是int类型的，因此汇编代码只用addl就能实现其他的操作有LeaqS,DD=&SINCDD=D+1DECDD=D-1NEGDD=-DADDS,DD=D+SSUBS,DD=D-S3.3.6关系操作(1)argc!=3;是在一条件语句中的条件判断：argc!=3，进行编译时，这条指令被编译为：cmpl$3,-20(%rbp)，同时这条cmpl的指令还有设置条件码的作用，当根据条件码来判断是否需要跳转到分支中。 （2）i<8，在hello.c作为判断循环条件，在汇编代码被编译为：cmpl$9,-4(%rbp)，计算i-7然后设置条件码，为下一步jle利用条件码进行跳转做准备。 3.3.7控制转移指令汇编语言中首先设置条件码，然后根据条件码来进行控制转移，在hello.c中，有以下控制转移指令：（1）判断i是否为3，如果i等于3，则不执行if语句，否则执行if语句，对应的汇编代码为 首先i赋初值0，然后无条件跳转至判断条件的代码中，即.L3。判断i是否符合循环的条件，符合直接跳转至.L4，也就是循环体的内部。 3.3.8函数操作调用函数时有以下操作：（假设函数P调用函数Q）（1）传递控制：进行过程Q的时候，程序计数器必须设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。（2）传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P中返回一个值。（3）分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。 hello.C涉及的函数操作有：main函数，printf，exit，sleep，getchar函数main函数的参数是argc和argv；两次printf函数的参数恰好是那两个字符串exit参数是1，sleep函数参数是atoi（argv[3]）函数的返回值存储在%eax寄存器中。 3.3.9类型转换hello.c中涉及的类型转换是：atoi（argv[3]），将字符串类型转换为整数类型其他的类型转换还有int、float、double、short、char之间的转换 3.4本章小结本章主要讲述了编译阶段中编译器如何处理各种数据和操作，以及c语言中各种类型和操作所对应的的汇编代码。通过理解了这些编译器编译的机制，我们可以很容易的将汇编语言翻译成c语言。（第3章2分） 第4章汇编4.1汇编的概念与作用汇编器（as）将汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码。汇编器把这些hello.s翻译成机器语言的指令,并且把这些机器语言指令编码打包成一个可重定位目标程序的指令编码格式,结果指令编码保存在了hello.o中。hello.o文件是一个简单的二进制指令编码文件,它可以包含目标程序的所有指令进行编码。此外汇编器还可以通过翻译生成计算机能直接自动识别和控制指令执行的一种二进制语言,也即机器语言。 4.2在Ubuntu下汇编的命令指令：gcchello.s-c-ohello.o 4.3可重定位目标elf格式(1)ELFHeader:用命令：readelf-hhello.o，如图ELFHeaderELFHeader：以16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解##标题释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量等信息。根据头文件的信息，可以知道该文件是可重定位目标文件，有1个节。 (2)SectionHeaders:命令：readelf-Shello.oSectionHeaders:节头部表，包含了文件中出现的各个节的语义，包括节的类型、位置和大小等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小，同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。 (3)查看符号表.symtab：命令readelf-shello.o.symtab：存放程序中定义和引用的函数和全局变量的信息。name是符号名称，对于可冲定位目标模块，value是符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址。size是目标的大小，type要么是数据要么是函数。Bind字段表明符号是本地的还是全局的。 重定位节：一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。重定位节.rela.text中各项符号的信息： Offset:需要被修改的引用节的偏移Info：包括symbol和type两个部分，symbol在前面四个字节，type在后面四个字节,symbol：标识被修改引用应该指向的符号,type:重定位的类型Type：告知链接器应该如何修改新的应用Attend：一个有符号常数，一些重定位要使用它对被修改引用的值做偏移调整Name:重定向到的目标的名称。 4.4Hello.o的结果解析（以下格式自行编排，编辑时删除）objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 通过反汇编的代码和hello.s进行比较，发现汇编语言的指令并没有什么不同的地方，只是反汇编代码所显示的不仅仅是汇编代码，还有机器代码，机器语言程序的是二进制机器指令的集合，是纯粹的二进制数据表示的语言，是电脑可以真正识别的语言。机器指令由操作码和操作数构成，汇编语言是人们比较熟悉的词句直接表述CPU动作形成的语言，是最接近CPU运行原理的语言。每一条汇编语言操作码都可以用机器二进制数据来表示，进而可以将所有的汇编语言(操作码和操作数）和二进制机器语言建立一一映射的关系，因此可以将汇编语言转化为机器语言，通过对机器代码的分析可以看出一下不同的地方。 (1)分支转移:反汇编的跳转指令用的不是段名称比如.L3，二是用的确定的地址，因为，因为段名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后显然不存在，而是确定的地址。 (2)函数调用:在.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0(目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。4.5本章小结本章对hello.s进行了汇编，生成了hello.o可重定位目标文件，并且分析了可重定位文件的ELF头、节头部表、符号表和可重定位节，比较了hello.s和hello.o反汇编代码的不同之处，分析了从汇编语言到机器语言的一一映射关系。 （第4章1分） 第5章链接5.1链接的概念与作用链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载(复制)到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。5.2在Ubuntu下链接的命令ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o. 5.3可执行目标文件hello的格式(1)ELFHeader:hello的文件头和hello.o文件头的不同之处如下图标记所示，Type类型为EXEC表明hello是一个可执行目标文件，有27个节 （2）节头部表SectionHeaders：SectionHeaders对hello中所有的节信息进行了声明，其中包括大小Size以及在程序中的偏移量Offset，因此根据SectionHeaders中的信息我们就可以用HexEdit定位各个节所占的区间（起始位置，大小）。其中Address是程序被载入到虚拟地址的起始地址。 (3)符号表.symtab (4)重定位节.rela.text 5.4hello的虚拟地址空间使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 通过datadump查看加载到虚拟地址的程序代码知hello的虚拟地址空间开始于0x400000，结束于0x400ff0 与5.3对照知edb中观察到的每个节的地址与程序头中所对应的address均相同。5.5链接的重定位过程分析objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。结合hello.o的重定位项目，分析hello中对其怎么重定位的。命令：objdump-d-rhello>linkhello.txt Hello反汇编 Hello.o反汇编 Hello反汇编 不同点：（1）指令地址不同；hello反汇编代码具有确定的虚拟地址，而hello.o的反汇编代码不具有确定的虚拟地址。（hello中函数调用、跳转的地址均变成虚拟地址）（2）Hello中增加了.init与.plt节及相应的部分函数（3）Hello中无重定位条目，而hello.o反汇编代码中含重定位条目（4）Hello中对全局变量的访问经过重定位，而hello.o中对全局变量的访问是$0x0及0（%rip）。 链接过程：链接器：（1）符号解析（2）重定位静态链接：目标文件直接链接进入可执行程序动态链接：在程序启动后才动态加载目标文件 hello重定位详述：（合并输入模块，并为每个符号分配运行时地址）（1）重定位节和符号定义：1.链接器将所有相同类型的节合并为同一类型的新的聚合节2.链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号3.此步骤完成后，hello程序中的每条指令和全局变量都有唯一的运行时内存地址（2）重定位节中的符号引用链接器依据重定位条目修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。5.6hello的执行流程（以下格式自行编排，编辑时删除）使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 子程序名地址_dl_init0x7f944cc65c10hello!_start+00x00000000004010d0libc-2.31.so!__libc_start_main+00x00007f944ca71fc0libc-2.31.so!__cxa_atexit+00x00007f944ca94f60 hello!__libc_csu_init+00x0000000000401190libc-2.31.so!_setjmp+00x00007f944ca90e00hello!main+00x0000000000401105hello!puts@plt+00x0000000000401030hello!exit@plt+00x0000000000401060 5.7Hello的动态链接分析（以下格式自行编排，编辑时删除）分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。dl_init前： dl_init后： 在进行动态链接前先进行静态链接，生成部分链接的可执行目标文件hello，此文件中有对定义在共享库中的例程和数据的未解析的引用在加载时，加载器将部分链接的可执行文件映射到内存调用动态链接器，通过加载共享库和重定位程序中的引用来完成链接任务。被编译为位置无关代码的共享库可以加载到任何地方，也可在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序也可在运行时使用动态链接器。5.8本章小结详细介绍了链接的概念及作用，展示并分析了hello的elf文件。使用edb查看了hello的虚拟地址空间，详述了链接过程，尤其是重定位过程；最后展示了hello的执行流程及动态链接过程。（第5章1分） 第6章hello进程管理6.1进程的概念与作用概念：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是又程序正确运行所需的状态组成。此状态包括存放在内存中程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量及打开文件描述符的集合。作用：（1）一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器（2）一个私有的地址空间，提供一个假象，好像我们的程序独占的使用内存系统6.2简述壳Shell-bash的作用与处理流程1.定义：交互型的应用级程序，代表用户运行其他程序；shell执行一系列读、求值步骤，然后终止。2.功能：shell应用程序提供了一个界面，用户通过访问这个界面访问操作系统内核的服务。 处理流程：（1）从终端读入输入的命令。（2）将输入字符串切分获得所有的参数（3）如果是内置命令则立即执行；否则调用相应的程序、为其分配子进程执行（4）shell应该接受键盘输入信号，并对这些信号进行相应处理6.3Hello的fork进程创建过程创建：父进程通过调用fork函数创建一个新的、处于运行状态的子进程(1)子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本（包括代码和数据段、堆、共享库及用户栈）(2)子进程获得与父进程任何打开文件描述符相同的副本（共享文件）(3)子进程有不同于父进程的PID(4)父子进程并发执行、具有相同但是独立的地址空间(5)fork函数调用一次返回两次（一次返回父进程，一次返回到新创建的子进程） hello的fork过程如下： (1)在shell输入：./hello1190200421韩卓宸(2)由于./hello不是shell内置命令，而是经过编译系统的可执行文件；故shell为当前进程fork一个子进程(3)将hello载入内存，开始执行 6.4Hello的execve过程 execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。创建子进程后，execve函数在当前进程的上下文中加载并运行一个新程序，此即hello程序。hello程序通过调用execve函数调用加载器。加载器将可执行目标文件hello的代码和数据从磁盘复制到内存，然后通过跳转到程序的第一条指令或入口点来运行该程序。即：（1）加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。（2）新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。（3）最后加载器设置PC指向_start地址，_start最终调用hello中的main函数。6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。（1）进程上下文信息：上下文就是内核重新启动一个先前被抢占了的进程所需的状态。此状态包含存放在内存中的程序的代码及数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、打开文件描述符的集合。（2）调度：在程序运行的某系时刻，内核决定抢占当前进程，并重新开始一个先前被抢占进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。（3）上下文切换：1.保存当前上下文2.恢复先前某个被抢占的进程被保存的上下文3.将控制传递给中国新恢复的进程（4）时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。（5）用户模式与内核模式：处理器用某个控制寄存器中的一个模式位来限制一个应用可以执行的指令及它可以访问的地址空间范围。当设置了模式位时，进程就运行在内核模式中。未设置模式位时，进程就运行在用户模式中。 hello的进程执行过程：最初hello运行在用户模式下，输出“Hello1190200421韩卓宸”hello调用sleep函数、陷入内核模式、处理休眠请求（定时器开始计时），内核将控制通过上下文切换机制转移给其他进程（进入用户模式）。定时器发送中断信号，进入内核模式，内核中中断处理程序处理中断，并再次进行上下文切换，将控制返回给hello。在用户状态下，继续执行hello程序。（hello在调用getchar函数时，也会执行上下文切换）总而言之：在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。6.6hello的异常与信号处理（以下格式自行编排，编辑时删除）hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。hello程序执行过程可能出现的异常一共有四种：中断、陷阱、故障、终止。（1）中断：来自I/O设备的信号，异步发生，总是返回到下一条指令。hello程序执行过程中可能会出现外部I/O设备引起的异常（2）陷阱：有意的异常，同步发生，总是返回到下一条指令。hello调用getchar函数时会触发此异常（3）故障：潜在可恢复的错误，同步发生，可能返回到当前指令或终止。hello程序运行时可能会出现缺页异常的情况（4）终止：不可恢复的错误，同步发生，不会返回。hello程序运行过程中硬件系统发生的一些错误可能会导致终止 接下来我们hello举例子（1）正常执行hello程序： （2）Ctrl+c终止：键入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，（默认）终止前台作业 （3）Ctrl+z暂停：键入Ctrl+z将（默认）挂起前台的作业，hello进程此时并没有被回收，而是运行在后台 （4）程序运行过程中乱按键盘：无关输入被缓存到stdin，并随着printf指令被输出。 （5）输入ps打印当前进程的状态 （6）输入jobs列出当前作业 （7）输入pstree打印进程树 （8）输入fg1，继续执行前台进程1 （9）输入kill，杀死hello 6.7本章小结详细介绍了进程的概念、功能与作用，并展示了shell的处理流程。与此同时，详述hello程序调用fork创建新进程、调用execve函数加载、执行hello的过程。着重展示了hello的进程执行过程及hello的异常及信号处理。 （第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。逻辑地址:逻辑地址是指由程序产生的与段相关的偏移地址部分。表示为[段标识符：段内偏移量]。hello.o里面的相对偏移地址即是逻辑地址。（又称相对地址）线性地址:逻辑地址经过段机制转化后为线性地址，用于描述程序分页信息的地址。（是逻辑地址与物理地址间转化过程中的一个环节）以hello为例，线性地址表明hello应该在内存的哪些块上运行。虚拟地址:为了方便加载与链接，将物理地址映射为虚拟地址。虚拟内存为每个进程提供了一致的地址空间，即虚拟地址空间，CPU在虚拟地址空间上的生成的地址即为虚拟地址。比如在将hello.o链接的时候hello.o文件中的main函数的地址即是虚拟地址。物理地址:CPU通过地址总线的寻址，找到真实的物理内存对应地址（又称绝对地址）；是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址直接成为物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址实际是由48位组成的，前16位包括段选择符，后32位为段内偏移量；段选择符前13位为索引，通过索引（依据TI取值）在描述符表（GDT：全局描述符表；LDT：局部描述符表）中找寻到32位段基地址，段基地址与段内偏移量相加即得线性地址。（32位） 7.3Hello的线性地址到物理地址的变换-页式管理 n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移(VPO),和一个n-p位的虚拟页号(VPN)，MMU利用VPN选择适当的PTE，（eg.VPN0选择PTE0,VPN1选择PTE1)。根据PTE中有效位的信息可知虚拟页是否被缓存，如果虚拟页已缓存，那直接将页表条目的物理页号和虚拟地址的VPO串联起来就得到一个相应的物理地址。（此处VPO和PPO相同）。如果虚拟页是未缓存的，会触发一个缺页故障。调用一个缺页处理子程序将磁盘的虚拟页重新加载到内存中，然后再执行这个导致缺页的指令。7.4TLB与四级页表支持下的VA到PA的变换 CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（TLB标记）+TLBI（TLB索引）访问、查询TLB中是否缓存有相应的PTE；如果TLB命中，则得到PPN，与VPO组合获得PA。如果TLB未命中，MMU向页表中查询，CR3包含L1页表的物理地址，VPN1提供一个L1PTE的偏移量，这个PTE包含L2页表的基地址，VPN2提供一个L2PTE的偏移量，以此类推，最终在第四级页表中查询到PPN的值，与VPO组合获得PA，并且向TLB中添加条目。如果查询PTE的时候发现不在物理内存中，则将引发缺页故障。7.5三级Cache支持下的物理内存访问（1）CPU产生虚拟地址VA。（2）MMU使用VPN在TLB中找寻PTE，若TLB命中，得到PPN与VPO组合得到PA；若TLB不命中，利用VPN的多级页表机制到内存中找到对应的物理页号PPN，与VPO组合得到PA。（3）PA分为PPN和PPO两部分。利用PPO，将其分成CI和CO，CI作为cache组索引，CO作为块偏移，PPN即是缓存组标志CT，利用CI进行组索引，将CT与标志位进行比较，若相同（即命中）则把偏移量CO处的数据字节传给MMU，随后将其传给CPU；不命中时则访问下一级缓存。（4）先访问一级缓存，不命中时访问二级缓存，再不命中访问三级缓存，再不命中访问主存，如果主存缺页则访问硬盘。7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并为它分配一个唯一的PID。为给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任何一个后来进行写操作时，写时复制机制就会创建新页面，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： （1）删除已存在的用户区域。（2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的结构区域。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text区和.data区。Bss区域是请求二进制零的，初始长度为0。（3）映射共享区域。若hello程序与共享对象链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。（4）设置PC。使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理缺页故障：（即DRAM缓存不命中）当指令引用一个相应的虚拟地址，而与该地址相对应的物理页面不在内存中，会触发缺页异常。 缺页异常将调用内核中的缺页异常处理程序，将执行以下操作：（1）判断虚拟地址是否合法，若不合法，则产生一个段错误，然后终止这个进程。（2）判断内存访问是否合法，若访问是不合法的，那么缺页处理程序会触发一个保护异常，终止这个进程。（3）若操作合法，选择一个牺牲页面，如果这个牺牲页面未被修改过，那么就将它交换出去，换入新的页面并更新页表。然后将控制转移给hello进程，再次执行触发缺页故障的指令。 7.9动态存储分配管理Printf会调用malloc，请简述动态内存管理的基本方法与策略。方法：动态内存分配器维护着一个进程的虚拟内存区域，称为堆；分配器将堆视为是一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式的保留为供应用程序使用。空闲块可用来分配。一个已分配的块保存已分配的状态，直至它被释放。一个空闲的块将保持空闲，直到它显式的被应用所分配。策略：显式分配器：要求应用显式地释放任何已分配的块隐式分配器：分配器检测到一个已分配块何时不再被程序所使用，而自动释放这个块。 显式分配器约束条件：（1）处理任意请求序列（2）立即响应请求（3）只使用堆（4）对齐块（5）不修改已分配的块目标：（1）最大化吞吐率（2）最大化内存利用率 堆中块组织形式：隐式空闲链表：空闲块通过头部中的大小字段隐含的连接着的。分配器可以通过遍历堆中所有的块，从而间接的遍历整个空闲块的集合；需要以特殊标记结束块。 块放置策略：（1）首次适配（2）下一次适配（3）最佳适配块合并策略：（1）立即合并（2）推迟合并显式空闲链表：将空闲块组织为某种形式的显式数据结构。将堆组织成一个双向空闲链表，在每个空闲块中，都包含一个先驱与后继指针。 块排序策略：（1）用后进先出的顺序维护链表（2）按地址顺序维护链表空闲链表分离策略：（1）简单分离存储（2）分离适配（3）伙伴系统 7.10本章小结从以下几个方面介绍了hello的存储管理：（1）存储器的4种地址空间、（2）逻辑地址、虚拟地址、物理地址的转换流程及管理模式（段式管理、页式管理）（3）基于TLB的地址翻译、物理内存访问（4）hello进程fork时及execve时的内存映射（5）缺页故障与缺页中断处理的流程（6）动态存储分配管理其中详细展示了（3）（6）模块的内容。 （第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件一个Linux文件就是一个m字节的序列： 所有的I/O设备（例如网络、磁盘、终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。设备管理：unixio接口将设备优雅的映射为文件，允许Linux内核引出一个简单、低级的应用接口8.2简述UnixIO接口及其函数UnixIO接口使得所有的输入、输出都能以一种统一且一致的方式来执行：（1）打开文件（2）shell创建的每个进程开始时都有3个打开的文件：标准输入、标准输出、标准错误（3）改变当前的文件位置（4）读写文件（5）关闭文件 相关函数：进程通过调用open函数来打开一个已存在的文件或创建一个新文件： Open函数将filename转换为一个文件描述符，并返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。Flags参数指明了进程打算如何访问这个文件。 接下来，下面的代码片段创建一个新文件，该文件的拥有者有读写权限，而所有其他的用户都有读权限： umask（DEF_UMASK）;fd=Open（“foo.txt”,O_CREAT|O_TRUNC|O_WRONLY,DEF_MODE）; 最后，进程通过调用close函数关闭一个打开的文件。intclose（intfd）; 应用程序分别调用read、write函数来执行输入、输出。 通过调用rio_readn和rio_writen函数，应用程序可以在内存和文件之间直接传送数据。#include“csapp.h” ssize_trio_readn（intfd,void*usrbuf,size_tn）;ssize_trio_writen（intfd,void*usrbuf,size_tn）;返回：若成功则为传送的字节数，若为EOF则为0（只对rio_readn而言），若出错则为-18.3printf的实现分析https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 Printf函数代码如下： Printf函数接受一个格式字符串fmt，之后是一个变参列表。后面每一个参数均对应这格式字符串中的一个格式符。Printf函数分别调用两个函数：vsprintf和write。vsprintf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。在printf中调用系统函数write(buf,i)将长度为i的buf输出。故printf的实现就是：用参数匹配格式字符串，然后用vsprintf将结果字符串整理，最后用write函数输出。 vsprintf函数： 8.4getchar的实现分析异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。getchar函数源代码： getchar函数调用系统函数read，该函数将整个缓冲区读入到buf中，后取出缓冲区内第一个字符作为结果。8.5本章小结本章主要介绍了IO设备管理方法、UnixI/O接口及其函数；同时也对printf函数与getchar函数的实现进行了简要分析.（第8章1分）结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。Hello的一生曾这样走过：·编程：在codeblocks或virtualstudio环境下编写、开发hello的C语言代码，生成hello.c文件·预处理：cpp根据以字符#开头的命令，修改原始C程序；读取并将系统头文件的内容直接插入程序文本、生成hello.i文件·编译：ccl将.i文件翻译为.s文件，其包含一个汇编语言程序·汇编：as将hello.s文件翻译为机器语言指令，将这些指令打包装入可重定位目标程序hello.o·链接：ld将可重定位目标文件hello.o与动态链接库链接成可执行目标文件hello，hello可被加载到内存中由内存执行。至此，Hello经过编译系统，实现了从高级语言程序到可执行语言程序的转变。接下来，hello将开启新的篇章。·运行：在shell上键入：./hello1190200525刘祥龙·创建子进程：由于在终端键入的非shell内置命令，故将调用fork函数创建一个子进程。·加载：shell调用execve，execve调用启动加载器，映射虚拟内存，设置当前进程上下文中的程序计数器，使之指向程序入口地址；进入程序入口程序后开始载入物理内存，然后进入main函数。·访存与缺页：CPU生成虚拟地址，CPU上的MMU将联合TLB将虚拟地址翻译为物理地址，此时可能会触发缺页故障，将调用异常处理程序。·执行指令：在一个时间片内进程享有CPU资源，可执行自己的逻辑控制流·上下文切换：在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。·信号处理：键入Ctrlz挂起当前进程，键入Ctrlc终止当前进程。·动态内存申请：当hello程序执行printf函数时，将调用malloc函数向动态内存分配器申请分配堆中的内存。·结束：当子进程hello执行完成时，内核安排父进程回收子进程，将子进程退出状态传递给父进程。内核删除为此进程创建的所有数据结构。至此，hello走到了生命的尽头，结束了它波澜壮阔的一生。 （结论0分，缺失-1分，根据内容酌情加分） 附件hello.i：预处理后的文本文件hello.s：汇编后的文本文件hello.o：编译后的可重定位文件hello,out:扩展文件linkhello.elf:hello的elf文件linkhello.txt：hello的反汇编代码文本hello：最终的可执行目标文件。（附件0分，缺失-1分） 参考文献[1]https://blog.csdn.net/weixin_36277197/article/details/116987253?C语言中编译预处理命令的作用有哪些，C语言系列 预处理命令[2]https://blog.csdn.net/Hanani_Jia/article/details/81735517?gcc编译程序四个阶段预处理、编译、汇编、链接[3]https://blog.csdn.net/qq_14892521/article/details/103460609?连接过程详述[4]https://blog.csdn.net/qq_42192672/article/details/82937667?初识edbdebugger[5]https://blog.csdn.net/genghaihua/article/details/89450057?物理地址和逻辑地址[6]https://blog.csdn.net/mzjmzjmzjmzj/article/details/84713351?通俗理解CPU中物理地址、逻辑地址、线性地址、虚拟地址、有效地址的区别[7]https://blog.csdn.net/Pipcie/article/details/105670156?段页式访存 逻辑地址到线性地址的转换[8]兰德尔E.布莱恩特，大卫R.奥哈拉伦深入理解计算机系统（第三版）collection/anatmorp. 
第111篇文章[]
pair的应用 在lab3的相关问题中我发现用pair存信息比较合适。我们学习了一个相关结构配对(Pair)。配对提供了一种方便方式来处理简单的键值关联，当我们想从方法返回两个值时特别有用。 在核心Java库中可以使用配对(Pair)的实现。除此之外，某些第三方库，比如ApacheCommons和Vavr，已经在各自的api中公开了这个功能。 核心java配对实现 Pair类 Pair类在javafx.util包中，类构造函数有两个参数，键及对应值： Pairpair=newPair<>(1,“One”); Integerkey=pair.getKey(); Stringvalue=pair.getValue(); 示例描述使用Pair类实现简单Integer到String的映射。示例中getKey方法返回key对象，getValue方法返回对应值对象。 AbstractMap.SimpleEntry和AbstractMap.SimpleImmutableEntry SimpleEntry定义在抽象类AbstractMap里面，其构造方法与Pair类似： AbstractMap.SimpleEntryentry =newAbstractMap.SimpleEntry<>(1,“one”); Integerkey=entry.getKey(); Stringvalue=entry.getValue(); 其键和值可以通过标准的getter和setter方法获得。 另外AbstractMap类还包含一个嵌套类，表示不可变配对：SimpleImmutableEntry类。 AbstractMap.SimpleImmutableEntryentry =newAbstractMap.SimpleImmutableEntry<>(1,“one”); 
第112篇文章[1]
241190200421韩卓宸大作业 这里写自定义目录标题 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML图表FLowchart流程图导出与导入导出导入 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号1190200421班 级1936602学生韩卓宸 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要Hello的P2P，即programtoprocess过程，包括程序员用键盘输入hello。此文件的源代码本文通过对于hello程序的分析，从hello.c直到hello可执行程序进行逐步分析，结合课本上的知识和一些资料，通过乌邦图虚拟机进行试验，试验gdb，edb以及gcc等工具进行试验，把这个学期计算机系统中各章节知识进行融合，形成自己的个性化结果，展示自己的收获，体现自己对于对计算机系统这门课程的理解。 关键词：计算机系统，hello程序的一生； 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介Hello程序的生命周期是从一个源程序,或者说源文件的,即程序员通过编辑器创建并保存的文本文件,文件名是hello.c.hello.c分别经过预处理器cpp的预处理,、编译器ccl的编译，汇编器as的汇编依次生成生成hello.i文件，hello.s文件、,生成hello.o文件、最后使用链接器ld进行链接最终成为可执行目标程序hello.当我们在shell中输入字符串.\hello并使用回车代表输入结束后，shell通过一系列指令的调用将输入的字符读入到寄存器中，之后将Hello目标文件中的代码和数据从磁盘复制到主存。此时shell会调用fork函数创建一个新的进程，并通过加载报存上下文，将控制权交给这个新的进程，具体过程在后面会详细叙述。在hello加载完成后，处理器就开始执行这个程序，翻译成机器语言再翻译成指令编码，最后把程序的调用如：printf等进行链接。新的代码段和数据段被初始化为hello目标文件的内容.然后,加载器会从_start的地址开始,之后会来到main函数的地址，之后进入main函数执行目标代码，CPU为运行的hello分配时间片执行逻辑控制流。执行阶段把这个等执行的程序分解成几个阶段，分别执行对应的指令，最后输出字符串。之后输出的字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示到屏幕上。这标志着进程的终止，shell的父进程回收这个进程操作系统恢复shell的上下文，控制权重回shell，由shell等待接受下一个指令的输入。1.2环境与工具硬件环境：IntelCorei7x64CPU16GRAM512GSSD软件环境：Ubuntu18.04.1LTS开发与调试工具：visualstudioedb,gcc,gdb,readelf,HexEdit,ld，objdump1.3中间结果hello.i预处理器修改了的源程序,分析预处理器行为hello.s编译器生成的编译程序,分析编译器行为hello.o可重定位目标程序,分析汇编器行为hello可执行目标程序,分析链接器行为elf.txthello.o的elf格式,分析汇编器和链接器行为objdump.txthello.o的反汇编,主要是为了分析hello.o 1.4本章小结本章大致主要简单介绍了hello的p2p，020过程，列出了本次实验信息：环境、中间结果，并且大致简介了hello程序从c程序hello.c到可执行目标文件hello的大致经过的历程。 （第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理概念：预处理器cpp根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件。预处理阶段作用：1.处理宏定义指令预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。2.处理条件编译指令条件编译指令如#ifdef，#ifndef，#else，#elif，#endif等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。3.处理头文件包含指令头文件包含指令如#include"FileName"或者#include等。该指令将头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。4.处理特殊符号预编译程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。2.2在Ubuntu下预处理的命令命令：gcchello.c-E-ohello.i 2.3Hello的预处理结果解析 经过预处理之后，hello.c转化为hello.i文件，打开该文件可以发现，文件的内容增加，且仍为可以阅读的C语言程序文本文件。对原文件中的宏进行了宏展开，头文件中的内容被包含进该文件中。例如声明函数、定义结构体、定义变量、定义宏等内容。另外，如果代码中有#define命令还会对相应的符号进行替换。2.4本章小结 本章首先介绍了预处理的定义与作用、之后结合预处理之后的hello.i程序对预处理的结果进行了简单分析。预处理过程为接下来对程序的操作打下了基础，是十分重要，不可或缺的。本章也介绍了预处理的相关概念及其所进行的一些处理，例如实现将定义的宏进行符号替换、引入头文件的内容、根据指令进行选择性编译等。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译要对程序进行以下的过程:首先进行的是语法分析,编译完成的程序使用语法分析器对编译程序输入的符号进行语法检查,检验其语法是否完全符合了语法的标准,如果不完全符合就是产生了错误。编译器使用ccl把一个简单文本翻译文件的其中的一个hello.i翻译成为一个新的hello.s,它的翻译目的主要是为了包含一个可以使用多种汇编语言的应用程序。在机器语言编译的整个过程中,编译器或程序都会产生一种新的中间代码,这种优化就是为了保证下一步的编译器为优化程序进行了充分的准备,大部分的编译器或程序都会针对编译器或程序的功能进行一些优化,目的之一就是在编译器可以很好地实现其原有机器语言功能的前提下提高编译器程序的性能和运行的效率。最后就是使用编译器把已经优化好的编译器和中间代码提取出来进行机器语言编译,调用机器语言汇编的程序,最后生成机器语言的代码。注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序。 3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 3.3Hello的编译结果解析3.3.1汇编指令的介绍 .file:声明源文件.text：代码节.section:.rodata:只读代码段.align：数据或者指令的地址对其方式.string：声明一个字符串（.LC0,.LC1）.global：声明全局变量(main).type:声明一个符号是数据类型还是函数类型3.3.2数据1.字符串 .这两个字符串作为printf函数的参数2.局部变量main函数声明了一个局部变量i，编译器进行编译的时候将局部变量i会放在堆栈中。如图所示，局部变量i放在栈上-4（%rbp）的位置。 3.main函数参数argc作为用户传给main的参数。也是被放到了堆栈中。4.各种立即数立即数直接体现在汇编代码中5.数组：char*argv[]hello.c中唯一的数组是作为main函数的第二个参数，数组的每个元素都是一个指向字符类型的指针。数组的起始地址存放在栈中-32（%rbp）的位置，被两次调用找参数传给printf 3.3.3全局函数 由hello.c可知，hello.c声明了一个全局函数intmain(intargc,char*argv[])，经过编译之后，main函数中使用的字符串常量也被存放在数据区。 这段汇编代码说明main函数是全局函数 3.3.4赋值操作程序中的赋值操作主要有：i=0这条赋值操作在汇编代码主要使用mov指令来实现，而根据数据的类型又有好几种不一样的后缀movb:一个字节movw：两个字节movl：四个字节movq：八个字节 3.3.5算数操作 hello.c中的算数操作有：i++，由于是i是int类型的，因此汇编代码只用addl就能实现其他的操作有LeaqS,DD=&SINCDD=D+1DECDD=D-1NEGDD=-DADDS,DD=D+SSUBS,DD=D-S3.3.6关系操作(1)argc!=3;是在一条件语句中的条件判断：argc!=3，进行编译时，这条指令被编译为：cmpl$3,-20(%rbp)，同时这条cmpl的指令还有设置条件码的作用，当根据条件码来判断是否需要跳转到分支中。 （2）i<8，在hello.c作为判断循环条件，在汇编代码被编译为：cmpl$9,-4(%rbp)，计算i-7然后设置条件码，为下一步jle利用条件码进行跳转做准备。 3.3.7控制转移指令汇编语言中首先设置条件码，然后根据条件码来进行控制转移，在hello.c中，有以下控制转移指令：（1）判断i是否为3，如果i等于3，则不执行if语句，否则执行if语句，对应的汇编代码为 首先i赋初值0，然后无条件跳转至判断条件的代码中，即.L3。判断i是否符合循环的条件，符合直接跳转至.L4，也就是循环体的内部。 3.3.8函数操作调用函数时有以下操作：（假设函数P调用函数Q）（1）传递控制：进行过程Q的时候，程序计数器必须设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。（2）传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P中返回一个值。（3）分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。 hello.C涉及的函数操作有：main函数，printf，exit，sleep，getchar函数main函数的参数是argc和argv；两次printf函数的参数恰好是那两个字符串exit参数是1，sleep函数参数是atoi（argv3）函数的返回值存储在%eax寄存器中。 3.3.9类型转换hello.c中涉及的类型转换是：atoi（argv3），将字符串类型转换为整数类型其他的类型转换还有int、float、double、short、char之间的转换 3.4本章小结本章主要讲述了编译阶段中编译器如何处理各种数据和操作，以及c语言中各种类型和操作所对应的的汇编代码。通过理解了这些编译器编译的机制，我们可以很容易的将汇编语言翻译成c语言。（第3章2分） 第4章汇编4.1汇编的概念与作用汇编器（as）将汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码。汇编器把这些hello.s翻译成机器语言的指令,并且把这些机器语言指令编码打包成一个可重定位目标程序的指令编码格式,结果指令编码保存在了hello.o中。hello.o文件是一个简单的二进制指令编码文件,它可以包含目标程序的所有指令进行编码。此外汇编器还可以通过翻译生成计算机能直接自动识别和控制指令执行的一种二进制语言,也即机器语言。 4.2在Ubuntu下汇编的命令指令：gcchello.s-c-ohello.o 4.3可重定位目标elf格式(1)ELFHeader:用命令：readelf-hhello.o，如图ELFHeaderELFHeader：以16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解##标题释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量等信息。根据头文件的信息，可以知道该文件是可重定位目标文件，有1个节。 (2)SectionHeaders:命令：readelf-Shello.oSectionHeaders:节头部表，包含了文件中出现的各个节的语义，包括节的类型、位置和大小等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小，同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。 (3)查看符号表.symtab：命令readelf-shello.o.symtab：存放程序中定义和引用的函数和全局变量的信息。name是符号名称，对于可冲定位目标模块，value是符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址。size是目标的大小，type要么是数据要么是函数。Bind字段表明符号是本地的还是全局的。 重定位节：一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。重定位节.rela.text中各项符号的信息： Offset:需要被修改的引用节的偏移Info：包括symbol和type两个部分，symbol在前面四个字节，type在后面四个字节,symbol：标识被修改引用应该指向的符号,type:重定位的类型Type：告知链接器应该如何修改新的应用Attend：一个有符号常数，一些重定位要使用它对被修改引用的值做偏移调整Name:重定向到的目标的名称。 4.4Hello.o的结果解析（以下格式自行编排，编辑时删除）objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 通过反汇编的代码和hello.s进行比较，发现汇编语言的指令并没有什么不同的地方，只是反汇编代码所显示的不仅仅是汇编代码，还有机器代码，机器语言程序的是二进制机器指令的集合，是纯粹的二进制数据表示的语言，是电脑可以真正识别的语言。机器指令由操作码和操作数构成，汇编语言是人们比较熟悉的词句直接表述CPU动作形成的语言，是最接近CPU运行原理的语言。每一条汇编语言操作码都可以用机器二进制数据来表示，进而可以将所有的汇编语言(操作码和操作数）和二进制机器语言建立一一映射的关系，因此可以将汇编语言转化为机器语言，通过对机器代码的分析可以看出一下不同的地方。 (1)分支转移:反汇编的跳转指令用的不是段名称比如.L3，二是用的确定的地址，因为，因为段名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后显然不存在，而是确定的地址。 (2)函数调用:在.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0(目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。4.5本章小结本章对hello.s进行了汇编，生成了hello.o可重定位目标文件，并且分析了可重定位文件的ELF头、节头部表、符号表和可重定位节，比较了hello.s和hello.o反汇编代码的不同之处，分析了从汇编语言到机器语言的一一映射关系。 （第4章1分） 第5章链接5.1链接的概念与作用链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载(复制)到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。5.2在Ubuntu下链接的命令ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o. 5.3可执行目标文件hello的格式(1)ELFHeader:hello的文件头和hello.o文件头的不同之处如下图标记所示，Type类型为EXEC表明hello是一个可执行目标文件，有27个节 （2）节头部表SectionHeaders：SectionHeaders对hello中所有的节信息进行了声明，其中包括大小Size以及在程序中的偏移量Offset，因此根据SectionHeaders中的信息我们就可以用HexEdit定位各个节所占的区间（起始位置，大小）。其中Address是程序被载入到虚拟地址的起始地址。 (3)符号表.symtab (4)重定位节.rela.text 5.4hello的虚拟地址空间使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 通过datadump查看加载到虚拟地址的程序代码知hello的虚拟地址空间开始于0x400000，结束于0x400ff0 与5.3对照知edb中观察到的每个节的地址与程序头中所对应的address均相同。5.5链接的重定位过程分析objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。结合hello.o的重定位项目，分析hello中对其怎么重定位的。命令：objdump-d-rhello>linkhello.txt Hello反汇编 Hello.o反汇编 Hello反汇编 不同点：（1）指令地址不同；hello反汇编代码具有确定的虚拟地址，而hello.o的反汇编代码不具有确定的虚拟地址。（hello中函数调用、跳转的地址均变成虚拟地址）（2）Hello中增加了.init与.plt节及相应的部分函数（3）Hello中无重定位条目，而hello.o反汇编代码中含重定位条目（4）Hello中对全局变量的访问经过重定位，而hello.o中对全局变量的访问是$0x0及0（%rip）。 链接过程：链接器：（1）符号解析（2）重定位静态链接：目标文件直接链接进入可执行程序动态链接：在程序启动后才动态加载目标文件 hello重定位详述：（合并输入模块，并为每个符号分配运行时地址）（1）重定位节和符号定义：1.链接器将所有相同类型的节合并为同一类型的新的聚合节2.链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号3.此步骤完成后，hello程序中的每条指令和全局变量都有唯一的运行时内存地址（2）重定位节中的符号引用链接器依据重定位条目修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。5.6hello的执行流程（以下格式自行编排，编辑时删除）使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 子程序名地址_dl_init0x7f944cc65c10hello!_start+00x00000000004010d0libc-2.31.so!__libc_start_main+00x00007f944ca71fc0libc-2.31.so!__cxa_atexit+00x00007f944ca94f60 hello!__libc_csu_init+00x0000000000401190libc-2.31.so!_setjmp+00x00007f944ca90e00hello!main+00x0000000000401105hello!puts@plt+00x0000000000401030hello!exit@plt+00x0000000000401060 5.7Hello的动态链接分析（以下格式自行编排，编辑时删除）分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。dl_init前： dl_init后： 在进行动态链接前先进行静态链接，生成部分链接的可执行目标文件hello，此文件中有对定义在共享库中的例程和数据的未解析的引用在加载时，加载器将部分链接的可执行文件映射到内存调用动态链接器，通过加载共享库和重定位程序中的引用来完成链接任务。被编译为位置无关代码的共享库可以加载到任何地方，也可在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序也可在运行时使用动态链接器。5.8本章小结详细介绍了链接的概念及作用，展示并分析了hello的elf文件。使用edb查看了hello的虚拟地址空间，详述了链接过程，尤其是重定位过程；最后展示了hello的执行流程及动态链接过程。（第5章1分） 第6章hello进程管理6.1进程的概念与作用概念：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是又程序正确运行所需的状态组成。此状态包括存放在内存中程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量及打开文件描述符的集合。作用：（1）一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器（2）一个私有的地址空间，提供一个假象，好像我们的程序独占的使用内存系统6.2简述壳Shell-bash的作用与处理流程1.定义：交互型的应用级程序，代表用户运行其他程序；shell执行一系列读、求值步骤，然后终止。2.功能：shell应用程序提供了一个界面，用户通过访问这个界面访问操作系统内核的服务。 处理流程：（1）从终端读入输入的命令。（2）将输入字符串切分获得所有的参数（3）如果是内置命令则立即执行；否则调用相应的程序、为其分配子进程执行（4）shell应该接受键盘输入信号，并对这些信号进行相应处理6.3Hello的fork进程创建过程创建：父进程通过调用fork函数创建一个新的、处于运行状态的子进程(1)子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本（包括代码和数据段、堆、共享库及用户栈）(2)子进程获得与父进程任何打开文件描述符相同的副本（共享文件）(3)子进程有不同于父进程的PID(4)父子进程并发执行、具有相同但是独立的地址空间(5)fork函数调用一次返回两次（一次返回父进程，一次返回到新创建的子进程） hello的fork过程如下： (1)在shell输入：./hello1190200421韩卓宸(2)由于./hello不是shell内置命令，而是经过编译系统的可执行文件；故shell为当前进程fork一个子进程(3)将hello载入内存，开始执行 6.4Hello的execve过程 execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。创建子进程后，execve函数在当前进程的上下文中加载并运行一个新程序，此即hello程序。hello程序通过调用execve函数调用加载器。加载器将可执行目标文件hello的代码和数据从磁盘复制到内存，然后通过跳转到程序的第一条指令或入口点来运行该程序。即：（1）加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。（2）新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。（3）最后加载器设置PC指向_start地址，_start最终调用hello中的main函数。6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。（1）进程上下文信息：上下文就是内核重新启动一个先前被抢占了的进程所需的状态。此状态包含存放在内存中的程序的代码及数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、打开文件描述符的集合。（2）调度：在程序运行的某系时刻，内核决定抢占当前进程，并重新开始一个先前被抢占进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。（3）上下文切换：1.保存当前上下文2.恢复先前某个被抢占的进程被保存的上下文3.将控制传递给中国新恢复的进程（4）时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。（5）用户模式与内核模式：处理器用某个控制寄存器中的一个模式位来限制一个应用可以执行的指令及它可以访问的地址空间范围。当设置了模式位时，进程就运行在内核模式中。未设置模式位时，进程就运行在用户模式中。 hello的进程执行过程：最初hello运行在用户模式下，输出“Hello1190200421韩卓宸”hello调用sleep函数、陷入内核模式、处理休眠请求（定时器开始计时），内核将控制通过上下文切换机制转移给其他进程（进入用户模式）。定时器发送中断信号，进入内核模式，内核中中断处理程序处理中断，并再次进行上下文切换，将控制返回给hello。在用户状态下，继续执行hello程序。（hello在调用getchar函数时，也会执行上下文切换）总而言之：在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。6.6hello的异常与信号处理（以下格式自行编排，编辑时删除）hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。hello程序执行过程可能出现的异常一共有四种：中断、陷阱、故障、终止。（1）中断：来自I/O设备的信号，异步发生，总是返回到下一条指令。hello程序执行过程中可能会出现外部I/O设备引起的异常（2）陷阱：有意的异常，同步发生，总是返回到下一条指令。hello调用getchar函数时会触发此异常（3）故障：潜在可恢复的错误，同步发生，可能返回到当前指令或终止。hello程序运行时可能会出现缺页异常的情况（4）终止：不可恢复的错误，同步发生，不会返回。hello程序运行过程中硬件系统发生的一些错误可能会导致终止 接下来我们hello举例子（1）正常执行hello程序： （2）Ctrl+c终止：键入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，（默认）终止前台作业 （3）Ctrl+z暂停：键入Ctrl+z将（默认）挂起前台的作业，hello进程此时并没有被回收，而是运行在后台 （4）程序运行过程中乱按键盘：无关输入被缓存到stdin，并随着printf指令被输出。 （5）输入ps打印当前进程的状态 （6）输入jobs列出当前作业 （7）输入pstree打印进程树 （8）输入fg1，继续执行前台进程1 （9）输入kill，杀死hello 6.7本章小结详细介绍了进程的概念、功能与作用，并展示了shell的处理流程。与此同时，详述hello程序调用fork创建新进程、调用execve函数加载、执行hello的过程。着重展示了hello的进程执行过程及hello的异常及信号处理。 （第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。逻辑地址:逻辑地址是指由程序产生的与段相关的偏移地址部分。表示为[段标识符：段内偏移量]。hello.o里面的相对偏移地址即是逻辑地址。（又称相对地址）线性地址:逻辑地址经过段机制转化后为线性地址，用于描述程序分页信息的地址。（是逻辑地址与物理地址间转化过程中的一个环节）以hello为例，线性地址表明hello应该在内存的哪些块上运行。虚拟地址:为了方便加载与链接，将物理地址映射为虚拟地址。虚拟内存为每个进程提供了一致的地址空间，即虚拟地址空间，CPU在虚拟地址空间上的生成的地址即为虚拟地址。比如在将hello.o链接的时候hello.o文件中的main函数的地址即是虚拟地址。物理地址:CPU通过地址总线的寻址，找到真实的物理内存对应地址（又称绝对地址）；是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址直接成为物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址实际是由48位组成的，前16位包括段选择符，后32位为段内偏移量；段选择符前13位为索引，通过索引（依据TI取值）在描述符表（GDT：全局描述符表；LDT：局部描述符表）中找寻到32位段基地址，段基地址与段内偏移量相加即得线性地址。（32位） 7.3Hello的线性地址到物理地址的变换-页式管理 n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移(VPO),和一个n-p位的虚拟页号(VPN)，MMU利用VPN选择适当的PTE，（eg.VPN0选择PTE0,VPN1选择PTE1)。根据PTE中有效位的信息可知虚拟页是否被缓存，如果虚拟页已缓存，那直接将页表条目的物理页号和虚拟地址的VPO串联起来就得到一个相应的物理地址。（此处VPO和PPO相同）。如果虚拟页是未缓存的，会触发一个缺页故障。调用一个缺页处理子程序将磁盘的虚拟页重新加载到内存中，然后再执行这个导致缺页的指令。7.4TLB与四级页表支持下的VA到PA的变换 CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（TLB标记）+TLBI（TLB索引）访问、查询TLB中是否缓存有相应的PTE；如果TLB命中，则得到PPN，与VPO组合获得PA。如果TLB未命中，MMU向页表中查询，CR3包含L1页表的物理地址，VPN1提供一个L1PTE的偏移量，这个PTE包含L2页表的基地址，VPN2提供一个L2PTE的偏移量，以此类推，最终在第四级页表中查询到PPN的值，与VPO组合获得PA，并且向TLB中添加条目。如果查询PTE的时候发现不在物理内存中，则将引发缺页故障。7.5三级Cache支持下的物理内存访问（1）CPU产生虚拟地址VA。（2）MMU使用VPN在TLB中找寻PTE，若TLB命中，得到PPN与VPO组合得到PA；若TLB不命中，利用VPN的多级页表机制到内存中找到对应的物理页号PPN，与VPO组合得到PA。（3）PA分为PPN和PPO两部分。利用PPO，将其分成CI和CO，CI作为cache组索引，CO作为块偏移，PPN即是缓存组标志CT，利用CI进行组索引，将CT与标志位进行比较，若相同（即命中）则把偏移量CO处的数据字节传给MMU，随后将其传给CPU；不命中时则访问下一级缓存。（4）先访问一级缓存，不命中时访问二级缓存，再不命中访问三级缓存，再不命中访问主存，如果主存缺页则访问硬盘。7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并为它分配一个唯一的PID。为给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任何一个后来进行写操作时，写时复制机制就会创建新页面，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： （1）删除已存在的用户区域。（2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的结构区域。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text区和.data区。Bss区域是请求二进制零的，初始长度为0。（3）映射共享区域。若hello程序与共享对象链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。（4）设置PC。使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理缺页故障：（即DRAM缓存不命中）当指令引用一个相应的虚拟地址，而与该地址相对应的物理页面不在内存中，会触发缺页异常。 缺页异常将调用内核中的缺页异常处理程序，将执行以下操作：（1）判断虚拟地址是否合法，若不合法，则产生一个段错误，然后终止这个进程。（2）判断内存访问是否合法，若访问是不合法的，那么缺页处理程序会触发一个保护异常，终止这个进程。（3）若操作合法，选择一个牺牲页面，如果这个牺牲页面未被修改过，那么就将它交换出去，换入新的页面并更新页表。然后将控制转移给hello进程，再次执行触发缺页故障的指令。 7.9动态存储分配管理Printf会调用malloc，请简述动态内存管理的基本方法与策略。方法：动态内存分配器维护着一个进程的虚拟内存区域，称为堆；分配器将堆视为是一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式的保留为供应用程序使用。空闲块可用来分配。一个已分配的块保存已分配的状态，直至它被释放。一个空闲的块将保持空闲，直到它显式的被应用所分配。策略：显式分配器：要求应用显式地释放任何已分配的块隐式分配器：分配器检测到一个已分配块何时不再被程序所使用，而自动释放这个块。 显式分配器约束条件：（1）处理任意请求序列（2）立即响应请求（3）只使用堆（4）对齐块（5）不修改已分配的块目标：（1）最大化吞吐率（2）最大化内存利用率 堆中块组织形式：隐式空闲链表：空闲块通过头部中的大小字段隐含的连接着的。分配器可以通过遍历堆中所有的块，从而间接的遍历整个空闲块的集合；需要以特殊标记结束块。 块放置策略：（1）首次适配（2）下一次适配（3）最佳适配块合并策略：（1）立即合并（2）推迟合并显式空闲链表：将空闲块组织为某种形式的显式数据结构。将堆组织成一个双向空闲链表，在每个空闲块中，都包含一个先驱与后继指针。 块排序策略：（1）用后进先出的顺序维护链表（2）按地址顺序维护链表空闲链表分离策略：（1）简单分离存储（2）分离适配（3）伙伴系统 7.10本章小结从以下几个方面介绍了hello的存储管理：（1）存储器的4种地址空间、（2）逻辑地址、虚拟地址、物理地址的转换流程及管理模式（段式管理、页式管理）（3）基于TLB的地址翻译、物理内存访问（4）hello进程fork时及execve时的内存映射（5）缺页故障与缺页中断处理的流程（6）动态存储分配管理其中详细展示了（3）（6）模块的内容。 （第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件一个Linux文件就是一个m字节的序列： 所有的I/O设备（例如网络、磁盘、终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。设备管理：unixio接口将设备优雅的映射为文件，允许Linux内核引出一个简单、低级的应用接口8.2简述UnixIO接口及其函数UnixIO接口使得所有的输入、输出都能以一种统一且一致的方式来执行：（1）打开文件（2）shell创建的每个进程开始时都有3个打开的文件：标准输入、标准输出、标准错误（3）改变当前的文件位置（4）读写文件（5）关闭文件 相关函数：进程通过调用open函数来打开一个已存在的文件或创建一个新文件： Open函数将filename转换为一个文件描述符，并返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。Flags参数指明了进程打算如何访问这个文件。 接下来，下面的代码片段创建一个新文件，该文件的拥有者有读写权限，而所有其他的用户都有读权限： umask（DEF_UMASK）;fd=Open（“foo.txt”,O_CREAT|O_TRUNC|O_WRONLY,DEF_MODE）; 最后，进程通过调用close函数关闭一个打开的文件。intclose（intfd）; 应用程序分别调用read、write函数来执行输入、输出。 通过调用rio_readn和rio_writen函数，应用程序可以在内存和文件之间直接传送数据。#include“csapp.h” ssize_trio_readn（intfd,void*usrbuf,size_tn）;ssize_trio_writen（intfd,void*usrbuf,size_tn）;返回：若成功则为传送的字节数，若为EOF则为0（只对rio_readn而言），若出错则为-18.3printf的实现分析https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 Printf函数代码如下： Printf函数接受一个格式字符串fmt，之后是一个变参列表。后面每一个参数均对应这格式字符串中的一个格式符。Printf函数分别调用两个函数：vsprintf和write。vsprintf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。在printf中调用系统函数write(buf,i)将长度为i的buf输出。故printf的实现就是：用参数匹配格式字符串，然后用vsprintf将结果字符串整理，最后用write函数输出。 vsprintf函数： 8.4getchar的实现分析异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。getchar函数源代码： getchar函数调用系统函数read，该函数将整个缓冲区读入到buf中，后取出缓冲区内第一个字符作为结果。8.5本章小结本章主要介绍了IO设备管理方法、UnixI/O接口及其函数；同时也对printf函数与getchar函数的实现进行了简要分析.（第8章1分）结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。Hello的一生曾这样走过：·编程：在codeblocks或virtualstudio环境下编写、开发hello的C语言代码，生成hello.c文件·预处理：cpp根据以字符#开头的命令，修改原始C程序；读取并将系统头文件的内容直接插入程序文本、生成hello.i文件·编译：ccl将.i文件翻译为.s文件，其包含一个汇编语言程序·汇编：as将hello.s文件翻译为机器语言指令，将这些指令打包装入可重定位目标程序hello.o·链接：ld将可重定位目标文件hello.o与动态链接库链接成可执行目标文件hello，hello可被加载到内存中由内存执行。至此，Hello经过编译系统，实现了从高级语言程序到可执行语言程序的转变。接下来，hello将开启新的篇章。·运行：在shell上键入：./hello1190200525刘祥龙·创建子进程：由于在终端键入的非shell内置命令，故将调用fork函数创建一个子进程。·加载：shell调用execve，execve调用启动加载器，映射虚拟内存，设置当前进程上下文中的程序计数器，使之指向程序入口地址；进入程序入口程序后开始载入物理内存，然后进入main函数。·访存与缺页：CPU生成虚拟地址，CPU上的MMU将联合TLB将虚拟地址翻译为物理地址，此时可能会触发缺页故障，将调用异常处理程序。·执行指令：在一个时间片内进程享有CPU资源，可执行自己的逻辑控制流·上下文切换：在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。·信号处理：键入Ctrlz挂起当前进程，键入Ctrlc终止当前进程。·动态内存申请：当hello程序执行printf函数时，将调用malloc函数向动态内存分配器申请分配堆中的内存。·结束：当子进程hello执行完成时，内核安排父进程回收子进程，将子进程退出状态传递给父进程。内核删除为此进程创建的所有数据结构。至此，hello走到了生命的尽头，结束了它波澜壮阔的一生。 （结论0分，缺失-1分，根据内容酌情加分） 附件hello.i：预处理后的文本文件hello.s：汇编后的文本文件hello.o：编译后的可重定位文件hello,out:扩展文件linkhello.elf:hello的elf文件linkhello.txt：hello的反汇编代码文本hello：最终的可执行目标文件。（附件0分，缺失-1分） 参考文献1https://blog.csdn.net/weixin_36277197/article/details/116987253?C语言中编译预处理命令的作用有哪些，C语言系列 预处理命令2https://blog.csdn.net/Hanani_Jia/article/details/81735517?gcc编译程序四个阶段预处理、编译、汇编、链接3https://blog.csdn.net/qq_14892521/article/details/103460609?连接过程详述4https://blog.csdn.net/qq_42192672/article/details/82937667?初识edbdebugger[5]https://blog.csdn.net/genghaihua/article/details/89450057?物理地址和逻辑地址[6]https://blog.csdn.net/mzjmzjmzjmzj/article/details/84713351?通俗理解CPU中物理地址、逻辑地址、线性地址、虚拟地址、有效地址的区别[7]https://blog.csdn.net/Pipcie/article/details/105670156?段页式访存 逻辑地址到线性地址的转换[8]兰德尔E.布莱恩特，大卫R.奥哈拉伦深入理解计算机系统（第三版）collection/anatmorp. 欢迎使用Markdown编辑器 你好！这是你第一次使用Markdown编辑器所展示的欢迎页。如果你想学习如何使用Markdown编辑器,可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown将代码片显示选择的高亮样式进行展示；增加了图片拖拽功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的KaTeX数学公式语法；增加了支持甘特图的mermaid语法1功能；增加了多屏幕编辑Markdown文章功能；增加了焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置等功能，功能按钮位于编辑区域与预览区域中间；增加了检查列表功能。 功能快捷键 撤销：Ctrl/Command+Z重做：Ctrl/Command+Y加粗：Ctrl/Command+B斜体：Ctrl/Command+I标题：Ctrl/Command+Shift+H无序列表：Ctrl/Command+Shift+U有序列表：Ctrl/Command+Shift+O检查列表：Ctrl/Command+Shift+C插入代码：Ctrl/Command+Shift+K插入链接：Ctrl/Command+Shift+L插入图片：Ctrl/Command+Shift+G查找：Ctrl/Command+F替换：Ctrl/Command+G 合理的创建标题，有助于目录的生成 直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式 强调文本强调文本 加粗文本加粗文本 标记文本 删除文本 引用文本 H2Ois是液体。 210运算结果是1024. 插入链接与图片 链接:link. 图片: 带尺寸的图片: 居中的图片: 居中并且带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片 去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的代码片. //Anhighlightedblock varfoo='bar'; 生成一个适合你的列表 项目 项目 项目 项目1项目2项目3 计划任务完成任务 创建一个表格 一个简单的表格是这么创建的： 项目Value电脑$1600手机$12导管$1 设定内容居中、居左、居右 使用:---------:居中使用:----------居左使用----------:居右 第一列第二列第三列第一列文本居中第二列文本居右第三列文本居左 SmartyPants SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如： TYPEASCIIHTMLSinglebackticks'Isn'tthisfun?'‘Isn’tthisfun?’Quotes"Isn'tthisfun?"“Isn’tthisfun?”Dashes--isen-dash,---isem-dash–isen-dash, isem-dash 创建一个自定义列表 Markdown Text-to- HTMLconversiontool Authors John Luke 如何创建一个注脚 一个具有注脚的文本。2 注释也是必不可少的 Markdown将文本转换为HTML。 KaTeX数学公式 您可以使用渲染LaTeX数学表达式KaTeX: Gamma公式展示 Γ ( n ) = ( n − 1 ) ! ∀ n ∈ N \Gamma(n)=(n-1)!\quad\foralln\in\mathbbN Γ(n)=(n−1)!∀n∈N是通过欧拉积分 Γ ( z ) = ∫ 0 ∞ t z − 1 e − t d t . \Gamma(z)=\int_0^\inftyt^{z-1}e^{-t}dt\,. Γ(z)=∫0∞​tz−1e−tdt. 你可以找到更多关于的信息LaTeX数学表达式here. 新的甘特图功能，丰富你的文章 Mon06 Mon13 Mon20 已完成 进行中 计划一 计划二 现有任务 AddingGANTTdiagramfunctionalitytomermaid 关于甘特图语法，参考这儿, UML图表 可以使用UML图表进行渲染。Mermaid.例如下面产生的一个序列图： 张三 李四 王五 你好！李四,最近怎么样? 你最近怎么样，王五？ 我很好，谢谢! 我很好，谢谢! 李四想了很长时间,文字太长了 不适合放在一行. 打量着王五  很好 王五,你怎么样? 张三 李四 王五 这将产生一个流程图。: 链接 长方形 圆 圆角长方形 菱形 关于Mermaid语法，参考这儿, FLowchart流程图 我们依旧会支持flowchart的流程图： CreatedwithRaphaël2.2.0 开始 我的操作 确认？ 结束 yes no 关于Flowchart流程图语法，参考这儿. 导出与导入 导出 如果你想尝试使用此编辑器,你可以在此篇文章任意编辑。当你完成了一篇文章的写作,在上方工具栏找到文章导出，生成一个.md文件或者.html文件进行本地保存。 导入 如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。 mermaid语法说明↩︎注脚的解释↩︎ 
第113篇文章[]
ADT,AF,RI,REPEXPOSURE ADT介绍抽象数据类型（AbstractDataType，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。 ADT具有三个特性，即表示泄漏、抽象函数AF以及表示不变量RI，在我看来，这三个特性都是为不变性所服务的。其中，表示泄漏保证了ADT的内部表示不会被客户端其它代码所篡改，影响不变性，其次，表示不变量RI，对ADT的内部表示进行限制，获取到希望的表示信息，即程序面对的表示，通过抽象函数AF得到客户端所见到的表示。 AFAF指的是抽象函数，抽象函数为表示值空间到抽象值空间的一个映射R:面向实现的表示值空间A:面向规格说明的抽象值空间R==>A一定是满射,但不一定是单射.抽象函数即一个R到A的映射:AF:R→A RIRI指的是表示不变性。"表示"即ADT中的各个属性;而表示不变性即这些属性必须保持的性质,如年龄不能为负数,概率不能大于1. checkRepRI指的是检查不变性，检查不变性就是确定RI是否还成立.在实现中采用断言技术assert来检查不变性是否保持，可以更早地捕获bug 避免表示泄露的方法表示泄露:指的是外部代码能直接改变(不借用类中的mutator方法)类中的属性. 我们需要注意三个关键词：private、final、immutable，所有的操作均为了赋予field这三个属性。 1.所有观察ADT属性的操作全都用observor来实现，这没什么好说的。 2.由于现在写的ADT都较为简单，private和final这两个前缀能加就加上。 3.immutabl的field由于是被数据类型本身决定，所以需要会使用防御式拷贝来保护。 
第114篇文章[]
有关delegation的思考 什么是委派模式？委派模式，并不属于23种经典的设计模式。但是在Spring框架源码中，它有多次体现。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。 字面理解委派模式项目组，包括：项目经理A、程序员B和程序员C。目前甲方有个项目，需要完成一个xxx任务。首先甲方会直接找到项目经理A去谈这个项目，而不是直接找B和C。项目经理分析这个项目，发现需要两人合作来完成，所以将A1模块分给B，将A2模块分给C，由B和C来合作完成该项目。 在该需求中，项目经理只起到了一个协调工作的作用，其实实际的工作是由B和C来完成的。由此可总结出委派模式的主要特点如下。 委派模式的主要特点干活是我(B和C)的，功劳是你的(A)。项目经理属于渔翁得利型 委派模式的其他特点①委派机制，类似于中介的功能 ②持有被委托人的引用(项目经理A可以随意使唤B和C) ③不关心过程，只关心结果(代理模式：关心的是过程，不关心结果) 代码实现1.甲方现在有一个项目projectA /** 现在有一个项目projectA*/publicinterfaceIDelegate{//项目ApublicvoidprojectA();}2.项目经理评估后，需要两个程序员B和C来完成 /** 程序员B/publicclassProgrammerBimplementsIDelegate{@OverridepublicvoidprojectA(){System.out.println(“程序员B完成模块A”);}}/*程序员C*/publicclassProgrammerCimplementsIDelegate{@OverridepublicvoidprojectA(){System.out.println(“程序员C完成模块B”);}}3.项目经理具体的分配过程 /** 项目经理A(虽然它也有工作,需要实现projectA,但是它的具体工作就是分配任务)/publicclassManagerAimplementsIDelegate{/* 封装构造方法,来获得具体实现该需求(程序员B和C)的实例*/IDelegateiDelegate;publicManagerA(IDelegateiDelegate){this.iDelegate=iDelegate;}@OverridepublicvoidprojectA(){this.iDelegate.projectA();}}4.测试。即：分工完成后，项目具体的完成情况 /** 需求的完成情况*/publicclasstest{publicstaticvoidmain(String[]args){//1.现在甲方有一个新的需求//2.项目经理分析完后,发现需要程序员B和C来完成IDelegateexuctorB=newProgrammerB();IDelegateexuctorC=newProgrammerC();//3.项目经理获取到B和C的引用，然后让B和C来完成工作newManagerA(exuctorB).projectA();newManagerA(exuctorC).projectA();//4.工作完成//5.代码看着像是项目经理A完成的，但实际是B和C完成的。即：干活是B和C，实际功劳确实A的}} 
第115篇文章[]
有关lsp的思考 含义：只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，有子类出现的地方，父类未必就能适应。 *子类型可以增加方法，但不可删 子类必须完全实现父类的方法，在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了里氏替换原则。 *子类型中重写的方法必须有相同或子类型的返回值 *子类型中重写的方法必须使用同样类型的参数 *子类型中重写的方法不能抛出额外的异常 同时，这也可以体现在方法的规约上面。 Sameorstrongerinvariants更强的不变量Sameorweakerpreconditions更弱的前置条件 Sameorstrongerpostconditions更强的后置条件 采用里氏替换原则的目的就是增强程序的健壮性，版本升级是也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。 基本介绍：1）如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明的使用其子类的对象。2）在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。3）里氏替换原则原则指出，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。 理解：即是在业务处理过程中，我们在用子类继承父类时，尽量不要重写父类中的方法，如果迫不得己必须重写，可采用聚合，组合和依赖等方法。 总结一下，即是：继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合度，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。那么如何解决：里氏替换原则 
第116篇文章[]
HIT软件构造期末复习笔记第2,12章 第二讲：软件测试与测试优先的编程 ·黑盒测试：对程序外部表现出来的行为进行测试；用于检查代码的功能，不关注内部的实现细节 检查是否符合规约等价类划分：针对每个输入数据需要满足的约束条件，划分等价类；从等价类中导出测试用例边界值分析：对等价类划分的一个补充（在等价类划分时将边界值作为等价类之一加入考虑）测试用例：输入+执行条件+期望结果 ·测试覆盖度：（1）笛卡尔积：全覆盖（2）每个维度的每个取值至少被一个测试用例覆盖一次即可代码覆盖度：函数覆盖、语句覆盖、分支覆盖、条件覆盖、路径覆盖覆盖度标准（100%语句覆盖，90%路径覆盖） ·以注释的形式撰写测试策略： ·TDD：（1）先写spec（2）再写符合spec的测试用例（3）写代码、执行测试、有问题再改、再执行测试用例，直到通过它·Junitassertxxx： 第十二讲：面向正确性与健壮性的软件构造 ·健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度 倾向于容错·正确性：程序按照spec加以执行的能力（最重要的质量指标） 倾向于直接报错可靠性=健壮性+正确性 ·Error/Runtime异常 Error：内部错误，一旦发生，想办法让程序优雅的结束Exception：异常：自己程序导致的问题，可以捕获，可以处理（1）将错误信息传递给上层调用者，并报告“案发现场”的信息（2）Return外的第二种退出途径（3）若找不到异常处理程序，整个系统完全退出（4）分为运行时异常和其他异常运行时异常：程序员在代码中处理不当造成，可避免其他异常：由外部原因造成，无法完全避免 ·Checked异常，Unchecked异常 Checked异常：必须捕获并指定错误处理器handle，否则编译无法通过 ·Checked异常处理机制（1）使用throws声明异常 方法应throws的异常：该方法调用的其他函数抛出的checkedexception当前方法检测并使用throws抛出的checkedexception若无handler来处理抛出的checkedexception，程序就终止执行 （2）使用throw抛出异常：1.找到一个能表达错误的Exception类/或者构造出一个新的Exception类2.构造Exception类的一个实例，将错误信息写入3.抛出错误（throw） 4.一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码 ·自定义异常类 Finally关键字：无论程序是否碰到异常，finally关键字都将被执行 ·断言在开发阶段的代码中嵌入，检验某些假设是否成立。若成立则表明程序运行正常，否则表明存在错误断言即是对代码中程序员所做的假设的文档化，不会影响程序的性能形式： 所构造的message将在发生错误时显示给用户，便于快速发现错误所在；实际运行阶段，不再使用断言！出现AssertionError即表示内部某些假设被违反了 可使用assert的情况：内部不变量、表示不变量、控制流不变量（switch-case）、方法的前置、后置条件断言只检查程序内部的状态是否符合规约，断言一旦false，程序就停止执行，外部错误（不受自己控制）要使用Exception机制去处理 ·防御式编程的基本思路：（1）最好的防御就是不要引入bug（2）若无法避免，则将bug限制在最小范围内；限定在一个方法内部，不扩散（3）Failfast 
第117篇文章[1]
HITCSAPP·Hello的一生 摘 要 本文通过展示hello程序的生命周期，深刻揭示了与计算机系统相关的概念、理论、技术与实现，详述了计算机的内部机制。Hello的一生可划分为2个阶段： 编译阶段：由高级语言程序编译为可执行程序运行阶段：结合进程管理、存储管理、I/O管理走完它的一生 关键词：预处理；编译；汇编；链接；进程；内存管理；I/O管理 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P：hello.c经cpp、ccl、as、ld处理转换得可执行目标文件hello，在shell中键入./hello1190200525刘祥龙，shell1为其fork一个子进程；如此便完成了hello从程序到进程的转变。 O2O：shell调用execve，execve调用启动加载器，映射虚拟内存，设置当前进程上下文中的程序计数器，使之指向程序入口地址；进入程序入口程序后开始载入物理内存，然后进入main函数执行目标代码。程序运行结束后父进程回收hello，内核删除相关数据结构。 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 ·硬件：X64CPU；2GHz；2GRAM；256GHDDisk以上 ·软件：Windows1064位，Ubuntu20.04LTS64位 ·开发工具：VisualStudioCode，GCC，objdump，EDB，readelf 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 hello.i：预处理后的文本文件 hello.s：汇编后的文本文件 hello.o：编译后的可重定位文件 hello.elf：hello.o的elf文件 hello.txt:hello的反汇编代码文本 linkhello.elf:hello的elf文件 linkhello.txt：hello的反汇编代码文本 hello：最终的可执行目标文件 1.4本章小结 本章主要介绍了hello的P2P与O2O过程，并说明、展示了实验的软硬件平台与中间结果文件。 第2章预处理 2.1 预处理的概念与作用 概念：预处理阶段，预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。 C语言目前提供了3种预处理功能： ·宏定义处理 ·文件包含处理 ·条件编译处理 作用： （1）用实际值替换符号常量 （2）读取系统头文件的内容，并将其直接插入到程序文本中 （3）处理条件编辑指令，决定需要编译的代码 此过程不会对程序的源代码进行解析，但也会删除程序中的注释及多余的空白字符。 2.2在Ubuntu下预处理的命令 命令：gcchello.c-E-ohello.i 2.3Hello的预处理结果解析 经预处理后，cpp将源文件hello.c翻译为文本文件hello.i 使用cat指令抓取文件内容后发现：文件内容增加，进行了宏展开，并将头文件中的内容插入到文本文件中；此时仍为可阅读的C语言文本。 2.4本章小结 本章主要介绍了C语言文件编译的预处理过程；从预处理的概念、作用及预处理结果这3大方面进行介绍。第3章编译 3.1编译的概念与作用 概念： 编译器（ccl）将文本文件hello.i翻译为文本文件hello.s，其包含一个汇编语言程序。 作用： （主要功能）将源程序翻译为汇编语言程序。进行语法分析、词法分析及目标代码生成。进行目标程序优化，提高程序性能。 3.2在Ubuntu下编译的命令 命令：gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 3.3.0指令及其内容 3.3.1数据 ·整型： （1）已初始化的全局变量sleepsecs存储在.data节，设置为long型，且值为2 立即数：在汇编代码中直接以“$”的形式标记Main函数参数argc：存储于栈空间中 ·字符串： 以全局变量的形式保存，存储于.rodata节 ·局部变量： 局部变量i保存在-4（%rbp）中，即栈中 ·全局变量： 3.3.2赋值 使用mov语句给局部变量i赋值 3.3.3类型转换 对全局变量sleepsecs的值进行隐式的类型转换（由2.5重新赋值为2） 3.3.4算术操作 指令功能leaA,BB=&AaddA,BB+=AsubA,BB-=AmulA,BB*=AincAA++decA A-=1negAA=-A 3.3.5关系操作 使用cmp语句进行关系比较 jmp的条件跳转语句也可进行关系比较 3.3.6逻辑操作 汇编语言中的逻辑操作由算术与赋值操作实现 3.3.7数组/指针操作 （1）数组：利用在栈帧中位置，通过(%rax)和%rax+8，分别得到argv[1]和argc[2]两个字符串 指针：使用mov指令获得argv[0]指针的地址 3.3.8控制转移 使用cmp语句设置条件码，根据条件码利用jmp语句进行跳转 3.3.9函数操作 使用call指令调用函数 3.4本章小结 介绍了编译的概念与作用，着重分析介绍了汇编指令，并就hello.s中的语句进行了分析。展示了编译器是如何根据C语言不同的数据类型与操作将.i文件翻译为.s文件。 第4章汇编 4.1汇编的概念与作用 概念：汇编器（as）将.s文件翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存到目标文件hello.o中（二进制文件） 作用：将汇编代码转换为机器指令，使其在链接后能被机器识别并执行 4.2在Ubuntu下汇编的命令 命令：gcc-chello.s-ohello.o 4.3可重定位目标elf格式 命令：readelf-ahello.o>hello.elf ·elf头: 命令：readelf-hhello.o Elf头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。Elf头剩余部分包含帮助链接器语法分析和解释目标文件的信息。其中包含elf头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小及数量。 ·节头部表 命令：readelf-Shello.o 节头部表记录各节名称、类型、地址、偏移量、大小、全体大小、旗帜、链接、信息、对齐等信息。 ·符号表 命令：readelf-shello.o 符号表存放在程序中定义和引用的函数及全局变量的信息。每个可重定位目标文件在.symtab这都有一张符号表，但其不包含局部变量的条目。 ·重定位节 命令：readelf-rhello.o 重定位节.rela.text: 一个.text节中位置的列表。当链接器把这个目标文件和其他文件组合时需要修改这些位置。一般而言，任何调用外部函数或引用全局变量的指令都需要修改，而调用本地函数的指令不需要修改。 偏移量：相对节头的偏移 信息：在符号表中的标号及类型 类型：重定位方式 此程序中需要被重定位的是printf,puts,exit,sleepsecs,getchar,sleep,rodata中的.L0及.L1 4.4Hello.o的结果解析 命令：objdump-d-rhello.o >hello.txt ·hello.o的反汇编代码： ·hello.s hello.o与hello.s代码在整体上区别不大；汇编代码及反汇编代码的差异主要体现在以下3个方面： 访问全局变量：汇编代码使用.LC0(%rip)访问全局变量，而汇编代码使用0x0（%rip）（因反汇编代码需要重定位）分支转移：汇编代码的分支跳转直接以助记符的形式表示，而反汇编中直接跳转到确定的地址函数跳转：汇编代码中的函数跳转形式为：call+函数名；而反汇编代码中call后直接指向下一条指令，且以main+偏移量的方式进行跳转。 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 4.5本章小结 介绍了汇编阶段的概念及作用，展示了hello.s到hello.o的汇编过程，介绍如何使用readelf工具观测、分析elf文件；利用objdump得到hello的反汇编代码，并与其汇编代码进行比较。充分展示了汇编代码与反汇编代码的异同。 第5章链接 5.1链接的概念与作用 概念：将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可执行于编译时、加载时、运行时。在现代系统中，链接由叫链接器的程序自动执行。 作用： （1）使得分离编译成为可能。不必再将一个大型的应用程序组织为一个巨大的源文件，而是可以将其分解为更小、更好管理的模块，可以独立的修改、编译这些模块。 （2）提高效率。当需要改变模块中的一个时，只需简单的重新编译它，并重新链接应用，而不必重新编译其他文件 （3）可利用共享库 5.2在Ubuntu下链接的命令 命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 命令：readelf-ahello>linkhello.elf ELF头： 相较于可重定位目标文件的elf头： ·类型变为可执行文件 ·可执行目标文件的elf头中节头数量增长至27 ·程序头大小变为56 ·指明程序入口点地址 文件头信息： ·.ref节已完成重定位，偏移量offset已给出，虚拟地址的起始地址已给出 重定位节： ·完成重定位 符号表： ·条目增加至51条 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 通过datadump查看加载到虚拟地址的程序代码知hello的虚拟地址空间开始于0x400000，结束于0x400ff0 与5.3对照知edb中观察到的每个节的地址与程序头中所对应的address均相同。 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 命令：objdump-d-rhello>linkhello.txt Hello反汇编 Hello.o反汇编 Hello反汇编 ·不同点： 指令地址不同；hello反汇编代码具有确定的虚拟地址，而hello.o的反汇编代码不具有确定的虚拟地址。（hello中函数调用、跳转的地址均变成虚拟地址）Hello中增加了.init与.plt节及相应的部分函数Hello中无重定位条目，而hello.o反汇编代码中含重定位条目Hello中对全局变量的访问经过重定位，而hello.o中对全局变量的访问是$0x0及0（%rip）。 ·链接过程： 链接器：（1）符号解析（2）重定位 静态链接：目标文件直接链接进入可执行程序 动态链接：在程序启动后才动态加载目标文件 ·hello重定位详述：（合并输入模块，并为每个符号分配运行时地址） 重定位节和符号定义： 链接器将所有相同类型的节合并为同一类型的新的聚合节链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号此步骤完成后，hello程序中的每条指令和全局变量都有唯一的运行时内存地址 重定位节中的符号引用 链接器依据重定位条目修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。 5.6hello的执行流程 （以下格式自行编排，编辑时删除） 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 子程序名地址_dl_init0x7f944cc65c10hello!_start+00x00000000004010d0libc-2.31.so!__libc_start_main+00x00007f944ca71fc0libc-2.31.so!__cxa_atexit+00x00007f944ca94f60 hello!__libc_csu_init+00x0000000000401190libc-2.31.so!_setjmp+00x00007f944ca90e00hello!main+00x0000000000401105hello!puts@plt+00x0000000000401030hello!exit@plt+00x0000000000401060 5.7Hello的动态链接分析 （以下格式自行编排，编辑时删除） 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 dl_init前： dl_init后： ·在进行动态链接前先进行静态链接，生成部分链接的可执行目标文件hello，此文件中有对定义在共享库中的例程和数据的未解析的引用 ·在加载时，加载器将部分链接的可执行文件映射到内存 ·调用动态链接器，通过加载共享库和重定位程序中的引用来完成链接任务。 被编译为位置无关代码的共享库可以加载到任何地方，也可在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序也可在运行时使用动态链接器。 5.8本章小结 详细介绍了链接的概念及作用，展示并分析了hello的elf文件。使用edb查看了hello的虚拟地址空间，详述了链接过程，尤其是重定位过程；最后展示了hello的执行流程及动态链接过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是又程序正确运行所需的状态组成。此状态包括存放在内存中程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量及打开文件描述符的集合。 作用： ·一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器 ·一个私有的地址空间，提供一个假象，好像我们的程序独占的使用内存系统 6.2简述壳Shell-bash的作用与处理流程 定义：交互型的应用级程序，代表用户运行其他程序；shell执行一系列读、求值步骤，然后终止。 功能：shell应用程序提供了一个界面，用户通过访问这个界面访问操作系统内核的服务。 处理流程： ·从终端读入输入的命令。 ·将输入字符串切分获得所有的参数 ·如果是内置命令则立即执行；否则调用相应的程序、为其分配子进程执行 ·shell应该接受键盘输入信号，并对这些信号进行相应处理 6.3Hello的fork进程创建过程 创建：父进程通过调用fork函数创建一个新的、处于运行状态的子进程 ·子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本（包括代码和数据段、堆、共享库及用户栈） ·子进程获得与父进程任何打开文件描述符相同的副本（共享文件） ·子进程有不同于父进程的PID ·父子进程并发执行、具有相同但是独立的地址空间 ·fork函数调用一次返回两次（一次返回父进程，一次返回到新创建的子进程） hello的fork过程如下： ·在shell输入：./hello1190200525刘祥龙 ·由于./hello不是shell内置命令，而是经过编译系统的可执行文件；故shell为当前进程fork一个子进程 ·将hello载入内存，开始执行 6.4Hello的execve过程 execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。 ·创建子进程后，execve函数在当前进程的上下文中加载并运行一个新程序，此即hello程序。 ·hello程序通过调用execve函数调用加载器 ·加载器将可执行目标文件hello的代码和数据从磁盘复制到内存，然后通过跳转到程序的第一条指令或入口点来运行该程序。 （具体而言： （1）加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。 （2）新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。 （3）最后加载器设置PC指向_start地址，_start最终调用hello中的main函数。 ） 6.5Hello的进程执行 （以下格式自行编排，编辑时删除） 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 ·进程上下文信息： 上下文就是内核重新启动一个先前被抢占了的进程所需的状态。此状态包含存放在内存中的程序的代码及数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、打开文件描述符的集合。 ·调度： 在程序运行的某系时刻，内核决定抢占当前进程，并重新开始一个先前被抢占进程。 在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。 ·上下文切换： 保存当前上下文恢复先前某个被抢占的进程被保存的上下文将控制传递给中国新恢复的进程 ·时间片： 一个进程执行它的控制流的一部分的每一时间段叫做时间片。 ·用户模式与内核模式： 处理器用某个控制寄存器中的一个模式位来限制一个应用可以执行的指令及它可以访问的地址空间范围。 当设置了模式位时，进程就运行在内核模式中。 未设置模式位时，进程就运行在用户模式中。 ·hello的进程执行过程： 最初hello运行在用户模式下，输出“Hello1190200525刘祥龙” hello调用sleep函数、陷入内核模式、处理休眠请求（定时器开始计时），内核将控制通过上下文切换机制转移给其他进程（进入用户模式）。 定时器发送中断信号，进入内核模式，内核中中断处理程序处理中断，并再次进行上下文切换，将控制返回给hello。 在用户状态下，继续执行hello程序。 （hello在调用getchar函数时，也会执行上下文切换） 总而言之： 在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。 6.6hello的异常与信号处理 （以下格式自行编排，编辑时删除） hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 hello程序执行过程可能出现的异常一共有四种：中断、陷阱、故障、终止。·中断：来自I/O设备的信号，异步发生，总是返回到下一条指令。 hello程序执行过程中可能会出现外部I/O设备引起的异常·陷阱：有意的异常，同步发生，总是返回到下一条指令。 hello调用getchar函数时会触发此异常·故障：潜在可恢复的错误，同步发生，可能返回到当前指令或终止。 hello程序运行时可能会出现缺页异常的情况·终止：不可恢复的错误，同步发生，不会返回。 hello程序运行过程中硬件系统发生的一些错误可能会导致终止 正常执行hello程序： Ctrl+c终止： 键入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，（默认）终止前台作业 Ctrl+z暂停： 键入Ctrl+z将（默认）挂起前台的作业，hello进程此时并没有被回收，而是运行在后台 程序运行过程中乱按键盘： 无关输入被缓存到stdin，并随着printf指令被输出。 （5）输入ps打印当前进程的状态 （6）输入jobs列出当前作业 输入pstree打印进程树 输入fg1，继续执行前台进程1 输入kill，杀死hello 6.7本章小结 详细介绍了进程的概念、功能与作用，并展示了shell的处理流程。与此同时，详述hello程序调用fork创建新进程、调用execve函数加载、执行hello的过程。着重展示了hello的进程执行过程及hello的异常及信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 （以下格式自行编排，编辑时删除） 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 ·逻辑地址:逻辑地址是指由程序产生的与段相关的偏移地址部分。表示为[段标识符：段内偏移量]。hello.o里面的相对偏移地址即是逻辑地址。（又称相对地址） ·线性地址:逻辑地址经过段机制转化后为线性地址，用于描述程序分页信息的地址。（是逻辑地址与物理地址间转化过程中的一个环节）以hello为例，线性地址表明hello应该在内存的哪些块上运行。 ·虚拟地址:为了方便加载与链接，将物理地址映射为虚拟地址。虚拟内存为每个进程提供了一致的地址空间，即虚拟地址空间，CPU在虚拟地址空间上的生成的地址即为虚拟地址。比如在将hello.o链接的时候hello.o文件中的main函数的地址即是虚拟地址。 ·物理地址:CPU通过地址总线的寻址，找到真实的物理内存对应地址（又称绝对地址）；是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址直接成为物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址实际是由48位组成的，前16位包括段选择符，后32位为段内偏移量；段选择符前13位为索引，通过索引（依据TI取值）在描述符表（GDT：全局描述符表；LDT：局部描述符表）中找寻到32位段基地址，段基地址与段内偏移量相加即得线性地址。（32位） 7.3Hello的线性地址到物理地址的变换-页式管理 n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移(VPO),和一个n-p位的虚拟页号(VPN)，MMU利用VPN选择适当的PTE，（eg.VPN0选择PTE0,VPN1选择PTE1)。根据PTE中有效位的信息可知虚拟页是否被缓存，如果虚拟页已缓存，那直接将页表条目的物理页号和虚拟地址的VPO串联起来就得到一个相应的物理地址。（此处VPO和PPO相同）。如果虚拟页是未缓存的，会触发一个缺页故障。调用一个缺页处理子程序将磁盘的虚拟页重新加载到内存中，然后再执行这个导致缺页的指令。 7.4TLB与四级页表支持下的VA到PA的变换 CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（TLB标记）+TLBI（TLB索引）访问、查询TLB中是否缓存有相应的PTE；如果TLB命中，则得到PPN，与VPO组合获得PA。如果TLB未命中，MMU向页表中查询，CR3包含L1页表的物理地址，VPN1提供一个L1PTE的偏移量，这个PTE包含L2页表的基地址，VPN2提供一个L2PTE的偏移量，以此类推，最终在第四级页表中查询到PPN的值，与VPO组合获得PA，并且向TLB中添加条目。如果查询PTE的时候发现不在物理内存中，则将引发缺页故障。 7.5三级Cache支持下的物理内存访问 ·CPU产生虚拟地址VA。 ·MMU使用VPN在TLB中找寻PTE，若TLB命中，得到PPN与VPO组合得到PA；若TLB不命中，利用VPN的多级页表机制到内存中找到对应的物理页号PPN，与VPO组合得到PA。 ·PA分为PPN和PPO两部分。利用PPO，将其分成CI和CO，CI作为cache组索引，CO作为块偏移，PPN即是缓存组标志CT，利用CI进行组索引，将CT与标志位进行比较，若相同（即命中）则把偏移量CO处的数据字节传给MMU，随后将其传给CPU；不命中时则访问下一级缓存。 ·先访问一级缓存，不命中时访问二级缓存，再不命中访问三级缓存，再不命中访问主存，如果主存缺页则访问硬盘。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并为它分配一个唯一的PID。为给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任何一个后来进行写操作时，写时复制机制就会创建新页面，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： ·删除已存在的用户区域。 ·映射私有区域。为新程序的代码、数据、bss和栈区域创建新的结构区域。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text区和.data区。Bss区域是请求二进制零的，初始长度为0。 ·映射共享区域。若hello程序与共享对象链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 ·设置PC。使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障：（即DRAM缓存不命中） 当指令引用一个相应的虚拟地址，而与该地址相对应的物理页面不在内存中，会触发缺页异常。 缺页异常将调用内核中的缺页异常处理程序，将执行以下操作： ·判断虚拟地址是否合法，若不合法，则产生一个段错误，然后终止这个进程。 ·判断内存访问是否合法，若访问是不合法的，那么缺页处理程序会触发一个保护异常，终止这个进程。 ·若操作合法，选择一个牺牲页面，如果这个牺牲页面未被修改过，那么就将它交换出去，换入新的页面并更新页表。然后将控制转移给hello进程，再次执行触发缺页故障的指令。 7.9动态存储分配管理 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 方法： 动态内存分配器维护着一个进程的虚拟内存区域，称为堆；分配器将堆视为是一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。 已分配的块显式的保留为供应用程序使用。空闲块可用来分配。一个已分配的块保存已分配的状态，直至它被释放。一个空闲的块将保持空闲，直到它显式的被应用所分配。 策略： ·显式分配器：要求应用显式地释放任何已分配的块 ·隐式分配器：分配器检测到一个已分配块何时不再被程序所使用，而自动释放这个块。 显式分配器约束条件： ·处理任意请求序列 ·立即响应请求 ·只使用堆 ·对齐块 ·不修改已分配的块 目标： ·最大化吞吐率 ·最大化内存利用率 堆中块组织形式： ·隐式空闲链表： 空闲块通过头部中的大小字段隐含的连接着的。分配器可以通过遍历堆中所有的块，从而间接的遍历整个空闲块的集合；需要以特殊标记结束块。 块放置策略： 首次适配（2）下一次适配（3）最佳适配 块合并策略： （1）立即合并（2）推迟合并 ·显式空闲链表： 将空闲块组织为某种形式的显式数据结构。将堆组织成一个双向空闲链表，在每个空闲块中，都包含一个先驱与后继指针。 块排序策略： 用后进先出的顺序维护链表（2）按地址顺序维护链表 空闲链表分离策略： （1）简单分离存储（2）分离适配（3）伙伴系统 7.10本章小结 从以下几个方面介绍了hello的存储管理： 存储器的4种地址空间、逻辑地址、虚拟地址、物理地址的转换流程及管理模式（段式管理、页式管理）基于TLB的地址翻译、物理内存访问hello进程fork时及execve时的内存映射缺页故障与缺页中断处理的流程动态存储分配管理 其中详细展示了（3）（6）模块的内容。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 一个Linux文件就是一个m字节的序列： 所有的I/O设备（例如网络、磁盘、终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。 设备管理：unixio接口 将设备优雅的映射为文件，允许Linux内核引出一个简单、低级的应用接口 8.2简述UnixIO接口及其函数 UnixIO接口使得所有的输入、输出都能以一种统一且一致的方式来执行： ·打开文件 ·shell创建的每个进程开始时都有3个打开的文件：标准输入、标准输出、标准错误 ·改变当前的文件位置 ·读写文件 ·关闭文件 相关函数： ·进程通过调用open函数来打开一个已存在的文件或创建一个新文件： Open函数将filename转换为一个文件描述符，并返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。Flags参数指明了进程打算如何访问这个文件。 ·接下来，下面的代码片段创建一个新文件，该文件的拥有者有读写权限，而所有其他的用户都有读权限： umask（DEF_UMASK）; fd=Open（“foo.txt”,O_CREAT|O_TRUNC|O_WRONLY,DEF_MODE）; ·最后，进程通过调用close函数关闭一个打开的文件。 intclose（intfd）; ·应用程序分别调用read、write函数来执行输入、输出。 ·通过调用rio_readn和rio_writen函数，应用程序可以在内存和文件之间直接传送数据。 #include“csapp.h” ssize_trio_readn（intfd,void*usrbuf, size_tn）; ssize_trio_writen（intfd,void*usrbuf,size_tn）; 返回：若成功则为传送的字节数，若为EOF则为0（只对rio_readn而言），若出错则为-1 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html ·从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. ·字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 ·显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 Printf函数代码如下： Printf函数接受一个格式字符串fmt，之后是一个变参列表。后面每一个参数均 对应这格式字符串中的一个格式符。Printf函数分别调用两个函数：vsprintf和write。 vsprintf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。在printf中调用系统函数write(buf,i)将长度为i的buf输出。 故printf的实现就是：用参数匹配格式字符串，然后用vsprintf将结果字符串整理，最后用write函数输出。 vsprintf函数： 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 getchar函数源代码： getchar函数调用系统函数read，该函数将整个缓冲区读入到buf中，后取出缓冲区内第一个字符作为结果。 8.5本章小结 本章主要介绍了IO设备管理方法、UnixI/O接口及其函数；同时也对printf函数与getchar函数的实现进行了简要分析. 结论 用计算机系统的语言，逐条总结hello所经历的过程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 Hello的一生曾这样走过： ·编程：在codeblocks或virtualstudio环境下编写、开发hello的C语言代码，生成hello.c文件 ·预处理：cpp根据以字符#开头的命令，修改原始C程序；读取并将系统头文件的内容直接插入程序文本、生成hello.i文件 ·编译：ccl将.i文件翻译为.s文件，其包含一个汇编语言程序 ·汇编：as将hello.s文件翻译为机器语言指令，将这些指令打包装入可重定位目标程序hello.o ·链接：ld将可重定位目标文件hello.o与动态链接库链接成可执行目标文件hello，hello可被加载到内存中由内存执行。 至此，Hello经过编译系统，实现了从高级语言程序到可执行语言程序的转变。 接下来，hello将开启新的篇章。 ·运行：在shell上键入：./hello1190200525刘祥龙 ·创建子进程：由于在终端键入的非shell内置命令，故将调用fork函数创建一个子进程。 ·加载：shell调用execve，execve调用启动加载器，映射虚拟内存，设置当前进程上下文中的程序计数器，使之指向程序入口地址；进入程序入口程序后开始载入物理内存，然后进入main函数。 ·访存与缺页：CPU生成虚拟地址，CPU上的MMU将联合TLB将虚拟地址翻译为物理地址，此时可能会触发缺页故障，将调用异常处理程序。 ·执行指令：在一个时间片内进程享有CPU资源，可执行自己的逻辑控制流 ·上下文切换：在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。 ·信号处理：键入Ctrlz挂起当前进程，键入Ctrlc终止当前进程。 ·动态内存申请：当hello程序执行printf函数时，将调用malloc函数向动态内存分配器申请分配堆中的内存。 ·结束：当子进程hello执行完成时，内核安排父进程回收子进程，将子进程退出状态传递给父进程。内核删除为此进程创建的所有数据结构。 至此，hello走到了生命的尽头，结束了它波澜壮阔的一生。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 hello.i：预处理后的文本文件 hello.s：汇编后的文本文件 hello.o：编译后的可重定位文件 hello.elf：hello.o的elf文件 hello.txt:hello的反汇编代码文本 linkhello.elf:hello的elf文件 linkhello.txt：hello的反汇编代码文本 hello：最终的可执行目标文件 参考文献 为完成本次大作业你翻阅的书籍与网站等 https://blog.csdn.net/weixin_36277197/article/details/116987253? C语言中编译预处理命令的作用有哪些，C语言系列 预处理命令https://blog.csdn.net/Hanani_Jia/article/details/81735517? gcc编译程序四个阶段预处理、编译、汇编、链接https://blog.csdn.net/qq_14892521/article/details/103460609? 连接过程详述https://blog.csdn.net/qq_42192672/article/details/82937667? 初识edbdebuggerhttps://blog.csdn.net/genghaihua/article/details/89450057? 物理地址和逻辑地址https://blog.csdn.net/mzjmzjmzjmzj/article/details/84713351? 通俗理解CPU中物理地址、逻辑地址、线性地址、虚拟地址、有效地址的区别https://blog.csdn.net/Pipcie/article/details/105670156? 段页式访存 逻辑地址到线性地址的转换兰德尔E.布莱恩特，大卫R.奥哈拉伦深入理解计算机系统（第三版） 
第118篇文章[]
HIT软件构造期末复习4~8章 第四讲：数据类型与类型检验 ·基本数据类型，对象数据类型 可将基本类型包装成对象类型，通常是在定义集合类型时使用它们，一般情况避免使用 Java：静态类型语言；在编译阶段进行类型检查·静态类型检查可在编译阶段发现错误，避免了将错误带入到运行阶段，提高程序健壮性、正确性关于“类型”的检查！！（1）语法错误（2）类名/函数名错误（3）参数数目错误（4）参数类型错误（5）返回值类型错误·动态类型检查关于“值”的检查！！（1）非法的参数值（2）非法的返回值（3）越界、空指针 ·值的改变，引用的改变，final改变一个变量：将该变量指向另一个值的存储空间改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值不变数据类型：一旦被创建，其值不能改变若是引用类型，也可是不变的：一旦确定其指向的对象，不能再被改变Mutable对象：拥有方法可以修改自己的值/引用Immutable对象：一旦被创建，始终指向同一个值/引用 Final类：（1）无法派生出子类（2）Final变量无法改变值或引用（3）Final方法无法被子类重写（4）修饰基本类型：起常量作用，基本类型的值不能改变（5）修饰引用类型：不能在指向其他对象，但被引用对象的值可以改变 对可变数据类型，采取防御式拷贝 给客户端返回一个全新的对象（副本）对不可变数据类型，无需采用防御式拷贝（应对有多个引用的情况）安全的使用可变数据类型：作为局部变量，只有一个引用，不涉及共享 ·Snapshotdiagram：用于描述程序运行时的内部状态 ·迭代器： 对iter使用remove方法可避免mutable对象对迭代器的破坏 注：此种不变性是在运行阶段获得的，编译阶段无法据此进行静态检查 第五讲：设计规约 ·specification 客户端无需阅读调用函数的代码，只需要理解spec即可规约可以隔离变化，无需通知客户端 前置条件：对客户端的约束，使用方法时必须满足的条件后置条件：对开发者的约束，方法结束时必须满足的条件契约：前置条件满足，后置条件必须满足；前置条件不满足，后置条件不一定满足 ·行为等价性站在客户端的角度看待行为等价性；根据规约判断行为是否等价 静态类型声明是一种规约，可据此进行静态类型检查staticchecking 方法前的注释也是一种规约，但需要人工判定其是否满足 Javadoc： ·比较规约：（1）规约的强度（2）规约的确定性（3）规约的陈述性 ·规约强度：Spec变强：更强的后置条件+更弱的前置条件可用更强的规约替换更弱的规约 操作式规约：（eg.伪代码）声明式规约：（无内部实现的描述，只有初终状态）更有价值内部实现的细节不在规约里呈现，放在代码实现体内部内部的注释内呈现 规约质量：·内聚的（spec描述的规约单一、简单、易理解）·信息丰富的（不能让客户端产生理解的歧义）·既足够强又足够弱 第六讲：抽象数据类型 ADT特性：表示泄漏、抽象函数AF、表示不变量RI ADT由操作定义，与其内部如何实现无关不变数据类型：其操作不改变内部值，而是构造新的对象 ·ADT操作的四种类型：构造器：可能实现为构造函数或静态函数生产器：由旧对象产生新对象观察器变值器测试creator、producer、mutator时用observer来观察这些操作是否的结果是否满足spec测试observer时用creator、producer、mutator等方法产生或改变对象，来看结果是否正确 ·表示独立性客户端使用ADT时无需考虑其内部是如何实现的，ADT内部表示的变化不应影响外部spec和客户端。 ·不变量在任何时候总是true，由ADT负责其不变量，与客户端的任何操作均无关（immutability即是一个典型的不变量） ·表示泄漏不仅影响不变性，也影响表示独立性；无法在不影响客户端的情况下改变其内部表示！ 使用immutable对象，可彻底的避免表示泄漏！ ·表示空间、抽象空间、AF ADT开发者关注R，client关注A满射！！！AF：R-->A ·RI（表示不变性）所有表示值的一个子集，包含了所有合法的表示值 选择某种特定的表示方式R，进而指定某个子集是合法的（RI），并为该子集中的每个值做出解释（AF） ·设计ADT：（1）选择R和A（2）RI：合法的表示值（3）如何解释合法的表示值：映射AF ·随时检查RI是否满足在所有可能会改变rep的方法中都要检查 ·在代码中以注释的形式记录AF、RI要精确记录的RI：rep中的所有fields何为有效要精确记录的AF：如何解释每一个R值表示泄漏的安全声明：给出理由，证明代码并未对外泄漏其内部表示 ADT的规约里只能使用client可见的内容来撰写，包含参数、返回值、异常等若规约里提及值，则只能采用A空间中的值在代码中以注释的形式写出AF和RI而不能在javadoc文档中，防止被外部看到而破坏表示独立性 构造器和生产器在创建对象时要确保不变量为true变值器和观察器在执行时必须保持不变性在每个方法return前，用checkRep()检查不变量是否得以保持 第七讲：面向对象编程 ·interface、class定义、实现ADT接口：确定ADT规约（javainterfacecannothaveconstructors）类：实现ADT 接口中的静态工厂方法使用接口类型声明变量，客户端仅使用接口中定义的方法，客户端无法直接访问属性 ·inheritance&override重写的函数：与父类或接口完全相同的signature；实际执行时调用哪个函数，运行时决定若父类型中的某个函数体的实现为空，说明其所有子类型都需要这个功能，但各有差异，无共性，在每个子类中均需要重写重写过后，使用supper()复用父类型中函数的功能，并对其进行扩展 ·多态&overload （1）特殊多态：功能重载（2）参数化多态：使用泛型（3）子类型多态：不同类型的对象可以统一处理，无需区分，从而隔离了变化；LSP原则BisasubtypeofAmeansthateveryBisA；everyBsatisfiesthespecofA子类型的spec不能弱化父类型的spec 第八讲：ADT和OOP中的等价性 ·等价性基于AF定义ADT的等价操作 AF映射到相同的结果，则等价等价关系：自反、传递、对称 ·equals()和==：引用等价性两个对象指向内存的同一段空间时，这两者引用等价Equals()：对象等价性具有相同的内容自定义ADT时要重写Object类的equals方法在object类中实现的缺省equals是在判断引用等价性！对基本数据类型，使用判断相等对对象类型，使用equals判断相等（eg.String） 重写equals的正确姿势其中instanceof操作符用于判断类的一致性 ·Equals等价关系：自反、对称、传递用是否为等价关系检验equals是否正确 ·hashCode()“相等”的对象，其hashCode的结果一定相同两个equals的对象，一定要有同样的hashCode（除非你能保证你的ADT不会被放置到hash类型的集合类中！） ·可变对象的观察等价性、行为等价性：观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致行为等价性：调用对象的任何方法都展示出一致的结果若某个mutable的对象包含在Set集合类当中，当其发生改变后，集合类的行为不确定对所有可变类型对象，实现行为等价性即可，也就是说只有指向相同内存空间的objects才是相等的；对所有mutable类型的对象，无需重写hashCode和equals方法，直接继承Object类的两个方法即可 ·不可变对象的引用等价性、对象等价性：不可变对象需重写equals方法及hashCode方法 
第119篇文章[]
HIT软件构造1~3章期末复习笔记 第一讲： 软件构造的多维度视图及质量目标 ·软件构造的多维度视图： 按构造对象划分：代码、构建视图（CodeorComponentlevel） ·软件构造的阶段划分、各阶段的构造活动： 语法树、流程图：B+C+M 版本控制工具：B+C+P UML图：R+C+P ·内部外部质量指标： 外部质量指标： 正确性（最重要）、健壮性、可扩展性、可复用性（兼容性、可移植性、易用性） 内部质量指标： LOC（lineofcode）、可读性、可理解性、规模、耦合度（低）、内聚度（高）、（圈）复杂度 第三讲： 软件构造过程与配置管理 ·SCM（软件配置管理） 追踪、控制软件的变化 SCI：软件配置项：软件发生变化的基本单元（形式：文件） Baseline：基线：软件持续变化过程中的“稳定时刻” CMDB：配置管理数据库：存储软件的各配置项随时间发生变化的信息+基线 Versioning：版本控制 ·VCS（版本控制系统） LocalVCS：本地版本控制系统：仓库存储于开发者本地机器，无法共享和合作 CentralizedVCS：集中式版本控制系统：仓库存储于独立的服务器，支持多开发者间的协作 DistributedVCS：分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器 ·GIt 基本结构： Gitrepository：dictionary本地CMDB Workingdictionary工作目录（本地文件系统） Stagingarea暂存区（隔离工作目录与git仓库） 基本指令： gitadd.（gitadd*）gitcommit-m“version”gitpushoriginmastergitpulloriginmaster（从远程仓库pull）gitclone git（克隆到本地仓库）gitcheckoutchange（切换分支）gitcheckout-bchange（新建并切换到分支change）gitmergechange（将change分支与当前分支合并） 每个commit指向一个父亲； 合并：一个commit指向多个父亲 分支：多个commit指向一个父亲 
第120篇文章[]
HIT软件构造期末复习笔记第9~11章 第九讲：面向复用的软件构造技术 ·白盒框架：通过代码层面的继承进行框架扩展·黑盒框架：通过实现特定接口、委派进行框架扩展 ·LSP原则（1）子类型可以增加方法，但不可以删除方法（2）子类型需要实现抽象类型中所有未实现的方法（3）子类型中重写的方法必须有相同或子类型的返回值或符合co-variance的参数（4）子类型中的重写的方法必须使用同样类型的参数或符合contra-variance的参数（5）子类型中重写的方法不能抛出额外的异常（更强的不变量，更弱的前置条件，更强的后置条件）子类型方法参数：逆变子类型方法的返回值：协变异常类型：协变 ·协变：父类型-->子类型：越来越具体的spec返回值类型、异常类型：不变或变的更具体·逆变：父类型-->子类型：越来越具体的spec参数类型：要不变或越来越抽象（目前Java遇到此种情况，均当作overload看待） ·数组的子类型化 ·泛型的子类型化ArrayList是List的子类型，而List不是List的子类型泛型不支持协变 类型擦除List不是List的子类型！ ·解决：使用通配符？ ·组合和委派委派：一个对象请求另一个对象的功能（复用的一种常见形式）委派模式：通过运行时动态绑定，实现对其他类中代码的复用委派发生在object层，继承发生在class层分类：（1）Dependency：临时性的delegation（2）Association：永久性的delegation（3）Composition：更强的association（难以变化）（4）Aggregation：更弱的association（可动态变化） ·接口的组合 ·CRP原则 ·白盒框架的原理与实现 ·黑盒框架的原理与实现 第十讲：面向可维护性的构造技术 ·可维护性的常见度量指标：可维护性、可扩展性、灵活性、可适应性、可管理性、支持性圈复杂度、代码行数、可维护性指数、继承的层次数、类之间的耦合度、单元测试的覆盖度 ·聚合度、耦合度：高聚合+低耦合 ·SOLID：SRP：单一责任原则OCP：开放-封闭原则LSP：Liskov替换原则ISP：接口聚合原则DIP：依赖转置原则 SRP：不应有多于一个原因让你的ADT发生变化，否则就拆分开OCP：对扩展性的开放：模块的行为应该是可扩展的对修改的封闭：模块自身的代码不应被修改；扩展模块行为的一般途径是修改模块的内部实现 LSP：子类型必须能替代其基类型；派生类必须能够通过其基类的接口使用，客户端无需理解这二者的差异ISP：不能强迫客户端依赖于它不需要的接口，只提供必需的接口DIP：抽象的模块不应依赖于具体的模块，具体应依赖于抽象（delegation时要通过interface建立联系，而非具体的子类） ·语法驱动的构造从外部读取文本数据，在应用中做进一步的处理用语法判断字符串是否合法，并解析成程序里使用的数据结构 ·正则表达式 第十一讲：面向可复用性和可维护性的设计模式 ·创建型模式： ··工厂方法（“虚拟构造器”）当客户端不知道要创建哪个具体类的实例，或不想在client代码中指明要具体创建的实例时，用工厂方法定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类 ·结构型模式： ··Adapter（适配器模式）将某个类、接口转换为client期望的其他形式；通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体的子类 ··Decorator（装饰器模式）为对象增加不同侧面的属性，对每个特性构造子类，通过委派机制增加到对象上 客户端需要一个具有多种特性的object，通过一层一层的装饰来实现 ·行为型模式 ··Strategy（策略模式）有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而非写死在代码中；为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例 ··Templatemethod（模板模式）做事情的步骤一致，但方法不一样；共性的步骤在抽象类中公共实现，差异化的步骤在各个子类中实现使用继承和重写实现模板模式 ··Iterator（迭代器模式）客户端希望遍历被放入到容器、集合类中的一组ADT对象，无需关心容器的具体类型 为ADT实现iterable接口，实现该接口的集合对象是可遍历迭代的（只含iterator方法）实现自己独特的Iterator迭代器（next、hasNext、remove），允许客户端应用这个迭代器进行显式或隐式的迭代遍历 ··Visitor将数据和作用于数据上的某种、某些种特定操作分离开来为ADT预留一个将来可扩展功能的接入点，外部实现的代码功能能在不改变ADT本身的情况下通过delegation接入ADT 
第121篇文章[]
Git：删除远程仓库中的文件及文件夹&GIt中错误“SSL_ERROR_SYSCALL,errno10054”的解决 eg.删除GitHub远程仓库中的FriendshipGraphTest.java文件 使用gitpulloriginmaster指令拉取远程仓库 使用gitrm-r--cachedfilename指令删除特定文件与文件夹 使用gitcommit-m“ ”指令提交删除操作至本地仓库 使用gitpush指令上传至远程仓库 最终结果 ·GIt中错误“SSL_ERROR_SYSCALL,errno10054”的解决方案： 此问题为安全设置问题： 使用指令： gitconfighttp.sslVerify"false" 即可解决 ·Git中错误：“TimeOut”解决方法： 因github为境外网站，时常出现崩坏的情况；如遇此情况： 反复多次提交即可解决。 参考文献：https://www.cnblogs.com/emmetyang/p/10620819.html 
第122篇文章[]
格式化日期的转化 1、格式化字符串日期转化为可计算可比较日期应用场景：如果时间的输入参数是一个字符串，那么比较两个日期就比较困难，计算两个日期之间差了多长时间更困难。经过查阅资料，发现日期可以通过字符串转化成long型的时间，这个时间表示的是从1970-1-1开始的毫秒时间。代码如下： publiclongparseTime(Stringdate) { DateFormatdft=newSimpleDateFormat("yyyy-MM-dd"); longtime=0; try{ Dated=dft.parse(date); time=d.getTime(); }catch(ParseExceptione){ System.out.println("时间错误"); System.exit(0); } returntime; } 这里输入日期的格式需要为“年-月-日”，对于不同的应用场景，只需修改格式串中的字符串。如果格式错误，会给出提示信息，并且退出运行，这个报错机制也可自行修改。 2、long型毫秒时间转化回字符串时间 publicStringtimeToString(longtime) { DateFormatdft=newSimpleDateFormat("yyyy-MM-dd"); Datereparse=newDate(); reparse.setTime(time); returndft.format(reparse); } 虽然long型的时间方便计算，但是字符串的时间方便观察，所以也需要将其转化回来。 3、将字符串日期转化成星期 /** *将字符串类型的时间信息转化成具体的星期几 *@paramtime字符串类型的时间 *@return周一到周五0-4，周六5，周日6 */ publicintparseTime(Stringtime) { DateFormatdft=newSimpleDateFormat("yyyy-MM-dd"); intday=0; try{ Dated=dft.parse(time); Calendarcal=Calendar.getInstance(); cal.setTime(d); day=cal.get(Calendar.DAY_OF_WEEK); }catch(ParseExceptione){ System.out.println("错误时间信息"); System.exit(0); } if(day==1) { return6; } returnday-2; } 这个函数的原型得到的day结果是，星期日：1，星期一到星期六：2-7，这里是为了方便处理我进行了转化。 在学习这一部分内容时，我主要参考了：https://blog.csdn.net/dashenmepi/article/details/108725254 
第123篇文章[]
在Eclipse中使用Junit测试代码 一、在项目中加入Junit库 右击项目文件，在选项中选择BuildPath这一选项。选择AddLibbraries选项，在其中找到Junit，可以自行选择需要的Junit版本。 当你的项目中除了之前的基础库文件，还出现了Junit库，说明已经添加完成了。二、Junit代码的构建 @Test publicvoidtestSet() { Graph<String>current=emptyInstance(); //测试错误输入负的权值 assertEquals(-1,current.set("A","B",-1)); assertEquals(false,current.vertices().contains("A")); assertEquals(false,current.vertices().contains("B")); assertEquals(false,current.targets("A").containsKey("B")); //测试权值不为0，图中没有这两点也没有这条边的情况，返回值应该是零，并且两个点应该已经被插入到图中，这条边也已经被插入到图中 assertEquals(0,current.set("A","B",1)); assertEquals(true,current.vertices().contains("A")); assertEquals(true,current.vertices().contains("B")); assertEquals(true,current.targets("A").containsKey("B")); //测试权值不为零，图中已经存在这两点的情况，返回值应该是1（同时完成对先前加入的边的权值的查看） assertEquals(1,current.set("A","B",2)); //测试权值为0，图中已经存在这两点的情况，返回值应该是2，并且这条边已经被删除 assertEquals(2,current.set("A","B",0)); assertEquals(false,current.targets("A").containsKey("B")); //测试权值不为零，图中有这两个点，但是没有这样的边的情况，返回值应该是0，并且这条边已经被添加 assertEquals(0,current.set("A","B",2)); assertEquals(true,current.targets("A").containsKey("B")); //测试权值为0，图中没有这两点也没有这条边的情况，返回值应该是0，但是同时没有对这两个点进行插入操作，也没有对这条边进行插入 assertEquals(0,current.set("C","D",0)); assertEquals(false,current.vertices().contains("C")); assertEquals(false,current.vertices().contains("D")); assertEquals(false,current.targets("C").containsKey("D")); } 以我之前对构建的图的类为例说明Junit代码的基本思路。首先对于任何用于测试的函数，都需要加上@Test标签，否则Eclipse不会识别你的测试方法，运行时不会执行。然后重点使用assertEquals函数，这个函数前一个参数是给定的正确结果，后一个参数是你要测试方法的返回结果。只有当两者相同，测试的结果才会是正确的。正确的结果将被标注为绿色，红色代表有运行错误，蓝色代表assertEquals结果出现错误，可以进一步进行检查。比如以下这个例子这一测试出现蓝色，双击这一内容进行检查。发现以下错误信息。双击上面一行进一步对比结果。可以看到详细的比较结果，然后返回查看代码的运行情况，进行debug。 3、使用注意(1)当使用Junit时如果代码中包含有exit函数，测试程序会直接卡死，网上有一些处理方式，详细可以查看https://blog.csdn.net/weixin_43872188/article/details/104781255(2)如果函数没有返回值可以进行比较，可以在类中定义相关的观察者方法，比如重写toString函数，当成检查的方式。(3)测试类也可以进行继承，并且子类如果没有重写父类中的测试函数，子类会自动执行父类的测试。举例：可以看到这一类中只写了三个测试方法。运行后可以看到执行了一些其他函数，而这些函数恰恰就是父类中的测试函数。 
第124篇文章[1]
计算机系统大作业程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机大类学 号119xxxxxxx班 级1903xxx学生 指导教师 计算机科学与技术学院2021年6月摘要本文较为完整地介绍了hello这一较为简单的c程序的运行过程。查阅各类资料，利用ubuntu中的分析工具观察运行结果，并进行了较为全面的分析。 关键词：计算机系统；Ubuntu；c语言； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-5-1.1HELLO简介-5-1.2环境与工具-5-1.3中间结果-5-1.4本章小结-6-第2章预处理-7-2.1预处理的概念与作用-7-2.2在UBUNTU下预处理的命令-8-2.3HELLO的预处理结果解析-8-2.4本章小结-9-第3章编译-10-3.1编译的概念与作用-10-3.2在UBUNTU下编译的命令-10-3.3HELLO的编译结果解析-10-3.3.1常量-10-3.3.1.1字符串-10-3.3.1.2各种立即数-10-3.3.2变量-11-3.3.2.1全局变量-11-3.3.2.2局部变量-11-3.3.2.3传入main函数的参数-11-3.3.3表达式-11-3.3.3.1赋值表达式-12-3.3.3.2算数表达式-12-3.3.3.3关系比较和转移操作-12-3.3.3.4函数调用和返回-12-3.4本章小结-13-第4章汇编-14-4.1汇编的概念与作用-14-4.2在UBUNTU下汇编的命令-14-4.3可重定位目标ELF格式-14-4.4HELLO.O的结果解析-15-4.5本章小结-17-第5章链接-18-5.1链接的概念与作用-18-5.2在UBUNTU下链接的命令-18-5.3可执行目标文件HELLO的格式-18-5.4HELLO的虚拟地址空间-20-5.5链接的重定位过程分析-21-5.6HELLO的执行流程-23-5.7HELLO的动态链接分析-23-5.8本章小结-24-第6章HELLO进程管理-25-6.1进程的概念与作用-25-6.2简述壳SHELL-BASH的作用与处理流程-25-6.3HELLO的FORK进程创建过程-25-6.4HELLO的EXECVE过程-26-6.5HELLO的进程执行-26-6.6HELLO的异常与信号处理-27-6.7本章小结-29-第7章HELLO的存储管理-30-7.1HELLO的存储器地址空间-30-7.2INTEL逻辑地址到线性地址的变换-段式管理-30-7.3HELLO的线性地址到物理地址的变换-页式管理-31-7.4TLB与四级页表支持下的VA到PA的变换-33-7.5三级CACHE支持下的物理内存访问-35-7.6HELLO进程FORK时的内存映射-36-7.7HELLO进程EXECVE时的内存映射-36-7.8缺页故障与缺页中断处理-36-7.9动态存储分配管理-37-7.9.1动态内存分配地基本原理-37-7.9.2隐式空闲链表原理-38-7.9.3显示空闲链表原理-39-7.10本章小结-40-第8章HELLO的IO管理-41-8.1LINUX的IO设备管理方法-41-8.2简述UNIXIO接口及其函数-41-8.3PRINTF的实现分析-42-8.4GETCHAR的实现分析-44-8.5本章小结-45-结论-45-附件-47-参考文献-48- 第1章概述1.1Hello简介P2P： Hello.c文件经过预处理、编译、汇编和链接过程，最终形成了可执行文件。用户在终端中输入./hello命令，shell调用fork函数为其创建一个新的进程。O2O：创建好新的进程后，shell调用execve函数，进行虚拟内存映射，载入物理内存。随后进入可执行文件中的代码段，进入main函数开始程序的运行。运行过程中进行信号处理、上下文切换等操作，最终程序执行完毕。父进程回收子进程，内核删除相关数据结构。1.2环境与工具硬件环境：IntelCorei7-9750HCPU；2.60GHz；8GBRAM软件环境：Windows1064位；Ubuntu16.04LTS64位开发与调试工具：gcc；edb；gdb；objdump；readelf；codeblocks1.3中间结果 Hello程序的可执行文件Hello.c程序c源文件Hello.i程序的预处理后的文件Hello.o程序汇编后的文件Hello.s程序编译后的文件 1.4本章小结本章主要交代了实验的大概内容，用到的工具，实验使用到的环境。（第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理的概念：预处理指的是在读入源程序后，预处理器（cpp）处理.c文件根据预处理指令修改原始文件，生成.i文件这一过程。预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。预处理指令分类及其功能：#include包含一个源代码文件#define定义宏#undef取消已定义的宏#if如果给定条件为真，则编译下面代码#ifdef如果宏已经定义，则编译下面代码#ifndef如果宏没有定义，则编译下面代码#elif如果前#if条件不为真，当前条件为真，则编译下面代码，其实就是elseif的简写#endif结束一个#if……#else条件编译块#error停止编译并显示错误信息主要分为三种功能：1、宏定义：宏定义又称为宏代换、宏替换，简称“宏”。预处理（预编译）工作也叫做宏展开：将宏名替换为字符串，即在对相关命令或语句的含义和功能作具体分析之前就要换。#define标识符字符串2、文件包含：文件包含处理是指在一个源文件中，通过文件包含命令将另一个源文件的内容全部包含在此文件中。在源文件编译时，连同被包含进来的文件一同编译，生成目标目标文件。#include"文件名"3、条件编译：条件编译指令将决定哪些代码被编译，而哪些不被编译的。可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件。#if/#endif/#else/#elif指令 2.2在Ubuntu下预处理的命令 命令：gcc-m64-no-pie-fno-PIChello.c-E-ohello.i（根据ppt中提供的不同设置参数） 2.3Hello的预处理结果解析 在本实验中给的hello.c文件中，只有三条文件包含类型的预处理指令，在进行预处理后生成了一个文本文件，其中按照系统路径将很多库文件引入，为后面的编译等操作做好准备。2.4本章小结本章主要介绍的是hello.c文件处理的第一步预处理操作，并通过实际测试观察了处理后的文件内容，其主要实现了对外部库文件的处理。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译的概念：编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。编译的作用：基本功能是把源程序(高级语言)翻译成目标程序。除了基本功能之外，编译程序还具备语法检查、调试措施、修改手段、覆盖处理、目标程序优化、不同语言合用以及人际联系等重要功能。 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析3.3.1常量3.3.1.1字符串 3.3.1.2各种立即数 例如本段代码中的$32、$3等。3.3.2变量3.3.2.1全局变量 在函数中定义的int类型sleepsecs变量，虽然定义给到的内容是2.5，但是在程序中小数部分被舍弃，只留下了2。3.3.2.2局部变量 这一部分是对循环变量i在进行操作，比较i是否<=9来进行循环，并且每次循环都对i进行加1操作。3.3.2.3传入main函数的参数 此处对argc进行判断，与3进行比较。 此处引用了argv数组，作为printf函数的参数。Argv数组的起始地址位于-32(%rbp)中，通过对这一地址进行+16和+8分别获取argv[2]和argv[1]，并将它们保存在%rdx和%rsi中。3.3.3表达式3.3.3.1赋值表达式包括有movl、movq分别是对4个字节和8个字节的数据进行赋值操作。3.3.3.2算数表达式subq减法操作，其在计算argv地址时使用。addl、addq加法操作，其在对局部变量更改时使用。3.3.3.3关系比较和转移操作 这两处相互对应，在汇编代码中利用cmpl操作实现对两个值的比较设置条件码，并利用je进行跳转实现if控制。 这两处相互对应，在循环过程中，i作为循环变量，汇编代码中利用cmpl实现其与9的比较，并且在小于等于9时进行跳转，实现与10的比较。3.3.3.4函数调用和返回 这两部分相互对应，当argc的值不等于3时，进入if中的代码，调用printf函数和exit函数，在汇编代码中表现为callputs和callexit操作。 进入到循环代码中，程序调用printf和sleep。对于printf来说需要argv[2]和argv[1]两个参数，在汇编代码中通过从-32(%rbp)中获取argv的首地址，并经过计算最终得到这两个参数，并将其传入到rdx和rsi中，随后直接调用printf完成函数调用。对于sleepsecs来说，只需要传入sleepsecs参数，在汇编代码中传入到rdi中，再使用call指令完成函数调用。 循环最终结束，调用getchar，也就是callgetchar结束。 在main函数返回时，出现leav指令，这一指令代表将rsp的值变为其进入main函数时的值，也将rbp还原成旧值，如此操作可以将函数栈中的状态恢复到前一个函数的状态，为后续返回做准备。 最终程序通过ret返回到调用它的函数中。 3.4本章小结本章主要进行了编译的操作，分析了程序的汇编代码，对程序的实际机器中的代码进行了解析。（第3章2分） 第4章汇编4.1汇编的概念与作用汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。直接通过readelf-a指令获取全部可重定位目标文件信息。1、ELF头 ELF头中包含生成该文件的系统的字的大小和字节顺序、ELF头的大小、目标文件的类型、机器类型、街头不表的文件偏移、节头部表中条目的大小和数量。例如本程序中，可以看到ELF头的大小为64字节，机器的类型为x86-64、此文件为可重定位文件、节头部表的起始位置在1176字节处、共有14个条目、并且每一个节都是64个字节、字符串表位于节头表的第13位等信息。2、节头部表 节头部表中包含各个节的名称、大小、可以进行的操作（属性）、类型、位置、对齐信息等信息。由于目前是可重定位文件，所以目前虚拟地址信息都是零，在未来链接后将会变为具体的虚拟地址。3、重定位节 这一部分在进行重定位时十分重要。这一部分有完整的计算公式，这一部分主要提供的信息为，重定位的类型包括重定位相对引用和重定位绝对引用、这个重定位区域在代码中的偏移量、重定位到的位置信息，拥有这些信息才可能在链接时完成重定位。4.4Hello.o的结果解析（以下格式自行编排，编辑时删除）objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 对比汇编后的代码发现，原来刚刚进行编译的到的汇编文件中有许多符号，在进行分支转移和循环时，跳转到的是一些符号所处的位置，在这一步中均已经去除，并替换上了其在函数中的相对偏移地址。而且原本没有的机器码也被成功生成了。在进行函数调用时，调用函数重定位信息已经被构建，只是没有在机器码中改变，这将会在后续的链接步骤中进一步实现。4.5本章小结本章比对了编译后和汇编后的汇编代码，分析了代码的变化，展现出汇编对于程序的意义。（第4章1分） 第5章链接5.1链接的概念与作用概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。作用：链接使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，我们可以独立的修改和编译那些更小的模块，这也更便于我们维护管理我们的代码。链接中也包括静态链接和动态链接，动态链接可以在加载和程序运行时进行，相比较静态链接更加灵活。5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。1、ELF头 与之前的可重定位文件的ELF头类似，区别在于类别变成了可执行文件、入口地址被成功设置为0x4010d0、这一文件也拥有了程序头表、节头表中各个节的大小以及节的数目已经发生了改变。2、节头表 可以看到节头表由于链接了其他文件，合并了部分节，并且添加了新的节，导致节头表部分节的大小发生变化，并且添加了几个条目。同时由于已经进行了重定位，所以rel节已经被删除。3、程序头部表 其中我们可以获得不同内存段在目标文件中的偏移、内存地址、对齐要求、目标文件中的段大小、内存中的段大小和访问权限。4、重定位表 5.4hello的虚拟地址空间使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 在地址从0x400000的地址开始，向后64个字节为可执行文件的ELF头的内容。并且根据节头表中的信息，也就是各个节对应的地址可以在edb中找到所有节对应的代码，比如定位.text节中的内容。通过节头表发现其初始地址为0x4010d0。 对应到的内容是这一部分机器代码。 通过edb查找对应的地址内容，发现正好对应。5.5链接的重定位过程分析 hello进行反汇编后得到的内容量远远大于之前的hello.o，并且很多地方都出现了改变。在hello一个文件中出现了外部链接来的函数，并且给出了他们的汇编代码，比如print、puts等函数，并且其附加了@plt符号。之前的虚拟地址由于没有进行重定位，所以都是0，在可执行文件中，虚拟地址变为了实际的数值，比如main函数的首地址0x401105。同时之前出现的call指令的后面的偏移量都是零，也是由于没有进行重定位，在hello文件中由机器分别计算了偏移量并放在了机器代码中。 对函数的重定位，这里给出一个详细的分析，以上一条目为例。首先在重定位后main函数的地址变成了0x401105，并且puts的首地址变为0x401080。根据重定位信息中转移的目标地址是puts的首地址-4，所以可以计算出转移的目标地址为0x40107c。计算出当时的PC的值为0x401105+0x1f-0，由此得到PC的值为0x401124。用目标值减去当前PC的值，得到偏移量为0xffffff58。 5.6hello的执行流程使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 没有输入参数执行ld-2.23.so!_dl_startld-2.23.so!_dl_inithello!__libc_start_main@plthello!puts@plthello!exit@plt输入两个参数ld-2.23.so!_dl_startld-2.23.so!_dl_inithello!__libc_start_main@plthello!printf@plt（循环调用了10次）hello!sleep@plt（循环调用了10次）hello!getchar@plt5.7Hello的动态链接分析分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。在对内容的变化进行解释前，首先简单阐述.plt、.got、.got.plt的作用。.got.plt中保存的是数据，为每个动态调用保存一个条目，条目的内容应该是对动态库函数的调用所跳转到的目标地址。由于Linux采用了延迟绑定技术，可执行文件中got.plt中的地址并不是目标地址，而是动态链接器（ld-linux）中的地址。在程序执行的第一次调用时，ld-linux把.got.plt的地址填写正确，之后的调用，就可以使用.got.plt中的目标地址了。.plt段中的内容则是实现跳转操作的代码片段。以本次代码中的puts@plt为例 可以看到其反汇编代码中的第一句是一个跳转命令，也就是当在main函数中调用puts函数，其首先要寻找自己在代码中实际的代码位置，而这第一句便是去寻找地址。在edb中定位.got.plt的地址，再通过puts的重定位信息可以找到在这一段内容中，puts的重定位信息的具体位置，也就是0x404018 在函数没有运行时，可以看到这一地址处的内容为0，也就是重定位信息没有成功加载。 在程序运行后，再次观察此处的地址，发现重定位信息已经被加载到了这一位置，动态链接的信息也就更新完成了。 5.8本章小结本章主要对链接的过程进行了简要分析，包括重定位信息、动态链接、可执行文件各段信息的分析等内容。（第5章1分） 第6章hello进程管理6.1进程的概念与作用在现代操作系统上运行一个程序时，我们会获得一个假象，就好像我们的程序是系统中当前运行的唯一程序一样。我们的程序好像是独占地使用处理起和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们的程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。进程的经典定义是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。6.2简述壳Shell-bash的作用与处理流程Shell是一种交互型的应用级程序，它代表用户运行其他程序。Shell执行一系列的读\求值步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。具体步骤：1、对用户输入的命令行进行解析，按照分隔符进行读取。2、设置传递给execuve的argv参数。并且判断第一个参数，如果是内部命令，那么调用对应的处理函数进行处理，如果不是认为是一个可执行目标文件，会在一个新的子进程中加载并运行这个文件。3、如果最后一个参数是&，那么表示在后台执行该程序，shell不会等待其完成，否则在前台执行这个程序，shell会等待其完成。4、完成以上步骤后，shell将会开始下一轮迭代。6.3Hello的fork进程创建过程由于我们在shell中输入的指令并非内部指令，所以会被当成是可执行文件进行加载并运行，在这一步之前系统会首先为这一程序的执行创建一个新的子进程，也就是调用fork函数。调用fork()函数创建一个子进程，子进程得到与父进程完全相同但是独立的一个副本，包括代码段、段、数据段、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，父进程和子进程最大的不同时他们的PID是不同的。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。6.4Hello的execve过程对于hello的执行，目前已经为其提供了一个新的子进程，现在要进行的是加载这一程序所需要的所有数据。程序通过调用execve函数，这一函数会调用加载其完成加载任务。首先删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为0.通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到_start地址，最终会调用应用程序的main函数。而在execve函数中，程序将自身运行所需要的环境变量和参数传给主函数。形成如下图所示的栈帧结构。 6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。前文已经完成了hello程序的加载过程，下面叙述hello从main函数开始的执行过程。在进入hello程序时输入参数1190200603和朱泓舟，于是argc的值变成3从而在第一次判断时不会直接退出，进入后续循环。首先执行printf此时执行的进程就是这个hello的程序。随后执行sleep函数，由于sleep函数进行了系统调用，进入内核模式，显示地让调用进程休眠，所以此时进行上下文切换，转换到其他进程运行。在执行完sleep后，又会恢复到用户模式，继续执行hello的余下内容。随后在执行getchar函数时，系统由于要对键盘输入内容进行读取，调用系统级函数read，所以又会进入内核模式，切换到其他进程运行，在getchar函数执行完成后，又会切换回用户模式，hello所在的进程又可以重新运行。 6.6hello的异常与信号处理hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。hello程序出现的异常可能有：中断：在hello程序执行的过程中由于要进行外部设备的输入，可能会出现外部I/O设备引起的异常。陷阱：陷阱是有意的异常，是执行一条指令的结果，hello执行sleep函数的时候会出现这个异常。故障：在执行hello程序的时候，可能会发生缺页故障。终止：终止时不可恢复的错误，在hello执行过程可能会出现DRAM或者SRAM位损坏的奇偶错误。Hello中可能产生多种信号，比如SIGINT、SIGKILL、SIGSEGV、SIGALRM和SIGCHLD等信号，后面会进行详细介绍。对各种命令的运行结果1、作为对比首先给出不进行任何输入的程序执行结果 2、输入ctrl+z 可以看到输入ctrl+z后程序运行停止，不再继续产生输出，并且给出了停止的提示信息。此时执行ps和jobs指令，都可以发现对应的进程和作业信息。使用kill指令发送9这个信号，也就是SIGKILL给hello所在的进程，再次查看对应进程和作业已经消失。 3、输入ctrl+c 输入ctrl+c后发现程序的执行也已经停止，但是与之前不同，在查看进程和作业信息时，没有对应的信息，所以ctrl+c指令已经将这一进程杀死，而不是暂停。4、随意输入内容 终端将所有内容都识别为命令，同时也没有这样的命令，所以直接报错。6.7本章小结在本章中简单对hello运行时的进程控制和信号处理进行了描述，着重分析了fork和execve函数的作用。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。逻辑地址：程序经过编译后出现在汇编代码中的地址。逻辑地址用来指定一个操作数或者是一条指令的地址。是由一个段标识符加上一个指定段内相对地址的偏移量，表示为[段标识符：段内偏移量]。线性地址：也叫虚拟地址，和逻辑地址类似，也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件也是内存的转换前地址。虚拟地址：也就是线性地址。物理地址：用于内存芯片级的单元寻址，与处理器和CPU链接的地址总线相对应。可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。7.2Intel逻辑地址到线性地址的变换-段式管理一个逻辑地址由两部份组成，段标识符:段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节。在段式管理系统中，整个进程的地址空间是二维的，即其逻辑地址由段号和段内地址两部分组成。为了完成进程逻辑地址到物理地址的映射，处理器会查找内存中的段表，由段号得到段的首地址，加上段内地址，得到实际的物理地址。 7.3Hello的线性地址到物理地址的变换-页式管理首先对虚拟存储模式进行简单介绍 这张图表示了虚拟内存管理模式的主要部分。当转换地址时实现了页命中的情况： 1、处理器生成一个虚拟地址，并把它传送给MMU2、MMU经过地址的翻译生成PTE地址，这个地址是对应在页表中寻找对应的PTE，并从高速缓存/主存中请求得到它。3、高速缓存/主存向MMU返回PTE4、MMU构造物理地址，并把它传送给高速缓存/主存5、高速缓存/主存返回所请求的数据字给处理器。当转换地址时发生了缺页 第一步到第三步与页命中的情况相同。4、PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。5、缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。6、缺页处理程序页面调入新的页面，并更新内存中的PTE。7、缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。以上介绍的是转换的主要步骤，下面对MMU中的地址翻译做进一步阐述。 在翻译过程中，利用VA中的VPN部分寻找对应的页表中的PTE，实际上就是物理地址中的PPN部分，然后虚拟地址中的VPO部分直接复制到PPO部分，最终构成了物理地址。7.4TLB与四级页表支持下的VA到PA的变换进行地址转化时，CPU每产生一个虚拟地址，MMU就必须查阅一个PTE，这涉及到内存的读取操作，花费周期较长，但是如果要取出的PTE位于一级高速缓存中，花费周期就会变得很小，所以在MMU中建立一个关于PTE的缓存，这有助于地址转化速率的提高，这个小缓存被称为TLB。 TLB的结构如图所示，在原本的虚拟地址中，VPN部分被分为两部分，一部分是TLB组的组索引TLBI，用于定位VPN在TLB中的组号。一部分是标记用于在寻找到组后，寻找对应的行。VPO与原来一致，都是直接复制与找到的PPN合并，构建出新的物理地址。 多级页表的作用是节省内存，如果发现前一级页表中有的PTE是空的，那么也就说明后续所有页表对应的这一部分都是空的，不需要占用内存，因此多级页表可以极大地节约内存。这里用一个36位的VPN为例，VPN被分为4个9位的片，每个片作用于一个页表的偏移量。VPN1中保存的是PTE在L1中的偏移量，在L1中定位到的PTE中保存的是其对应的L2部分的首地址，相应的VPN2就保存的在L2中的偏移量，以此类推，最终在L4中找到对应的PPN。在每一级寻找VPN时都可以采取TLB加速策略。7.5三级Cache支持下的物理内存访问 当虚拟地址成功转化为了物理地址，此时就要到高速缓存中读取对应的数据。 采用较为一般的缓存方式组相联高速缓存，物理地址被分为图中三个部分。首先利用组索引在高速缓存组中定位对应的组。然后，在这一组中，利用标记位信息在组中寻找有效位为0的对应行，如果没有对应上，那么就将数据从下一级高速缓存或者内存中读取出来，保存在组中，重新设置标记信息和有效位信息。如果成功对应了组中的某一行，那么此时就找了对应的数据。7.6hello进程fork时的内存映射当fork函数被新进程调用时，内核为新进程创建各种数据结构，并分配给它唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射Execve函数在当前进程中加载并运行包含在可执行文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤：删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。7.8缺页故障与缺页中断处理 缺页是发生在虚拟地址转化为物理地址时的故障，当CPU发出一个虚拟地址后，根据前文的翻译流程进行转化，如果在内存中的页表中没有找到对应的物理地址，此时便会出发缺页故障。缺页处理程序从磁盘中加载合适的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。7.9动态存储分配管理7.9.1动态内存分配地基本原理动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。分配器有两种基本风格，两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体来负责释放已分配的块。显式分配器：要求应用显式地释放任何已分配的块。例如，c标准库提供一种叫做malloc程序包的显式分配器。c程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。c++中的new和delete操作符与c中的malloc和free相当。隐式分配器：另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集，例如Lisp,ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。7.9.2隐式空闲链表原理首先介绍隐式空闲链表 一个块是由一个字的头部、有效载荷、可能的一些额外的填充，以及在块的结尾处的一个字的脚部组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是0。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。我们称这种结构称为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。注意：此时我们需要某种特殊标记的结束块，可以是一个设置了已分配位而大小为零的终止头部。 为了加快空闲块之间的合并速度，为每一个块加装一个脚部。在每个块的结尾添加一个脚部，那么分配器就可以通过检查它的脚部，判断前一个块的起始位置和状态，这个脚部总是在距离当前块开始位置一个字的距离。当需要进行空闲块的合并时，总共分为四种情况，对于每种情况分别进行不同的更新，即可完成在常数时间内的合并操作。7.9.3显示空闲链表原理 隐式链表因为块分配与堆块的数量呈线性关系，所以对于通用的分配器，隐式链表是不合适的，将空闲块组织为某种形式的显示数据结构更好。因为根据定义，程序不需要一个空闲块的主体，所以实现空闲链表数据结构的指针可以存放在这些空闲块的主体里面。显式空闲链表结构将堆组织成一个双向空闲链表，在每个空闲块的主体中，都包含一个pred（前驱）和succ（后继）指针。使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于空闲链表中块的排序策略。一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。 7.10本章小结本章内容较多，涉及到虚拟地址到物理地址地转化、物理地址在高速缓存中定位、虚拟内存映射、动态内存分配、缺页处理等内容。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法一个Linux文件就是一个m字节的序列：B0,B1,B2……Bm所有的IO设备(如网路、磁盘、终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O,这使得所有的输入和输出都被当做相应文件的读和写来执行。设备的模型化：文件设备管理：unixio接口8.2简述UnixIO接口及其函数UnixI/O接口统一操作：1、打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。2、Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。3、改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。4、读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。5、关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。UnixI/O函数：1、intopen(char*filename,intflags,made_tmode)函数主要功能：进程通过调用这一函数来打开一个已存在的文件或者创建一个新文件。参数功能：-filename：函数会将filename转化为一个文件描述符，也就是将要打开的文件名字。-flags：指明了进程打算如何访问这个文件。-mode：指定了新文件的访问权限位。返回值：返回文件的描述符数字，其总是在进程中当前没有打开的最小描述符。2、intclose(intfd)函数主要功能：关闭一个打开的文件参数功能：fd为将要关闭的文件的文件描述符返回值：0成功，-1出错3、ssize_tread(intfd,void*buf,size_tcount)函数主要功能：从文件中读取数据参数功能：-fd：要读取文件的文件描述符-buf：读取的文件中的字符将会存储在buf中-count：读取文件的最大字符数目返回值：若成功则为读的字节数，若EOF则为0，若出错为-14、ssize_twrite(intfd,void*buf,size_tcount)函数主要功能：向文件中写入数据参数功能：-fd：向文件描述符为fd的文件中写数据-buf：写入的数据首地址-count：写入的最多字节数返回值：若成功则为写的字节数，若出错为-18.3printf的实现分析printf函数代码如下所示：intprintf(constcharfmt,…){inti;charbuf[256];va_listarg=(va_list)((char)(&fmt)+4);i=vsprintf(buf,fmt,arg);write(buf,i);returni;}printf函数主要调用了vsprintf和write函数。下面首先介绍vsprintf(buf,fmt,arg)是什么函数。intvsprintf(char*buf,constcharfmt,va_listargs){charp;chartmp[256];va_listp_next_arg=args;for(p=buf;*fmt;fmt++){if(*fmt!=‘%’){*p++=*fmt;continue;}fmt++;switch(*fmt){case‘x’:itoa(tmp,((int)p_next_arg));strcpy(p,tmp);p_next_arg+=4;p+=strlen(tmp);break;case‘s’:break;default:break;}}return(p-buf);}vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。下面分析write的作用 write:moveax,_NR_writemovebx,[esp+4]movecx,[esp+8]intINT_VECTOR_SYS_CALL可以看到在write的汇编代码中进行了系统调用sys_call，下面分析syss_call函数的行为。sys_call:callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret 可以看出这个函数syscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。因此printf函数的全部执行流程为：从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析intgetchar(void){staticcharbuf[BUFSIZ];staticchar*bb=buf;staticintn=0;if(n==0){n=read(0,buf,BUFSIZ);bb=buf;}return(–n>=0)?(unsignedchar)*bb++:EOF;}异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章中主要介绍了Linux系统中IO的原理，包括输入输出函数和一些底层的实现原理。（第8章1分）结论首先编写完成hello.c文件，这个是否文件没有经过处理，与机器中的指令有很大差距，更加贴近于人能够理解的内容，在内存中表现为ascii编码的二进制文件。随后进行预处理，cpp将hello.c处理成为hello.i文件，此时对源文件的#进行了解析。然后进入编译阶段，ccl将hello.i处理成为hello.s文件，此时的文件中已经出现了汇编代码。编译器将hello.s文件处理后，生成hello.o文件，汇编代码已经与机器代码建立了对应关系。Hello.o文件以及各种库文件链接，使得hello.o中的符号得以解析，一些代码和数据的重定位信息得以加载完成。此时hello.c文件完成处理，生成了机器可以运行的可执行文件。在终端中输入可执行文件的名字./hello，shell利用fork函数为其创建一个新的子进程，随后调用execve加载并且运行这一程序，在程序的运行过程中，通过上下文切换、内存翻译、处理信号和异常等操作，实现对这一程序的完整运行。最终当程序结束运行，进程终止，父进程对其进行回收。（结论0分，缺失-1分，根据内容酌情加分） 附件 Hello程序的可执行文件Hello.c程序c源文件Hello.i程序的预处理后的文件Hello.o程序汇编后的文件Hello.s程序编译后的文件（附件0分，缺失-1分） 参考文献为完成本次大作业你翻阅的书籍与网站等[1]Pianistx.printf函数实现的深入剖析.https://www.cnblogs.com/pianist/p/3315801.html[2]RandalE.Bryant,DavidR.O’Hallaon.深入理解计算机系统.第三版.北京：机械工业出版社[M].2018：1-737.[3]物理内存与虚拟内存之间的映射https://blog.csdn.net/thebulesky/article/details/78561136（参考文献0分，缺失-1分） 
第125篇文章[]
Java按行读取文件内容：简要方法介绍和实例演示 Java按行读取文件内容：简要方法介绍和实例演示 1、使用到的相关方法和类简介 publicFileInputStream(Filefile)throwsFileNotFoundExceptionCreatesaFileInputStreambyopeningaconnectiontoanactualfile,thefilenamedbytheFileobjectfileinthefilesystem.AnewFileDescriptorobjectiscreatedtorepresentthisfileconnection.Ifthenamedfiledoesnotexist,isadirectoryratherthanaregularfile,orforsomeotherreasoncannotbeopenedforreadingthenaFileNotFoundExceptionisthrown. Parameters:file-thefiletobeopenedforreading.Throws:FileNotFoundException-ifthefiledoesnotexist,isadirectoryratherthanaregularfile,orforsomeotherreasoncannotbeopenedforreading.SecurityException-ifasecuritymanagerexistsanditscheckReadmethoddeniesreadaccesstothefile. 这是查阅的java原始库中的描述，简单介绍就是传入参数file，试图通过关联一个具体的文件建立一个文件输入流，如果文件名字不存在、无法被打开或是无法被阅读，那么就抛出异常。 建立文件输入流后，进一步需要建立BufferedReader对象来对文件输入进行读取。以下给出java原文档给出的实例，其中传入BufferedReader的参数还可以是InputStreamReader等输入流。 BufferedReaderin=newBufferedReader(newFileReader(“foo.in”)); 建立好字符读入后，便可以调用其中的方法进行按行读取内容。这里主要给出一个之后需要用到的方法，也就是按行读取一个字符串。 StringreadLine()Readsalineoftext. 2、实例演示 FilefileInput=newFile(fileName); ArrayList<ArrayList<Integer>>input=newArrayList<ArrayList<Integer>>(); Stringstr=newString(); inti=0; try{ FileInputStreamfile=newFileInputStream(fileInput); BufferedReaderbr=newBufferedReader(newInputStreamReader(file,"UTF-8"));//构造一个BufferedReader类来读取文件 while((str=br.readLine())!=null){ ArrayList<Integer>e=newArrayList<Integer>(); input.add(e); //System.out.println(str); for(Stringa:str.split("\t")){ try{ if(Integer.parseInt(a)<0) { System.out.println("输入中含有负数"); returnnull; } input.get(i).add(Integer.parseInt(a)); }catch(Exceptionw){ System.out.println("非法输入格式或内容"); returnnull; } } i++; } }catch(Exceptione){ System.out.println("读入文件错误"); returnnull; } 这段代码处理的是读取文件中的不含负数和小数的矩阵，按行对矩阵进行处理，最终将矩阵保存在input中，方便后续进一步处理。代码中的fileName便是读入文件的路径。 
第126篇文章[]
Git中较为常见的命令和错误 一、常用指令1、将自己本地的代码上传到自己的github仓库中 gitinit//初始化仓库 gitadd.//添加文件到本地暂存区或用gitadd(文件name) gitcommit-m“firstcommit”//提交到本地仓库 gitremoteaddorigin远程仓库地址//添加远程仓库 gitpush-uoriginmaster//把本地仓库的master分支推送到远程仓库master分支 这些指令是常常用来将自己本地代码推送到master分支的操作。 2、新建分支 …最初在master上工作… gitcheckout-bchange创建新分支同时也切换到了change分支 比如现在想要将内容推送到change分支 gitadd* gitcommit-m"change"在该分支上提交 gitpushoriginchange gitcheckoutmaster切换回master分支 这是用来新建分支，并将内容推送到新分支上的操作。 3、查看当前提交信息 gitlog gitlog--graph gitlog--graph--all 第一条指令用于查看当前分支提交记录，第二条指令可以给出当前分支更加完整的先后顺序信息，第三条可以给出所有分支的提交信息和结构。 二、问题及解决方案1、在github上的文件夹出现白色箭头，无法进入访问问题原因：文件夹内部有.git的隐藏文件，可以通过查看隐藏文件的选项在文件管理器中查看。github因此将其视为子模块。解决方案：（1）删除文件夹里面的.git文件夹 （2）执行gitrm--cached[文件夹名] （3）执行gitadd[文件夹名] （4）执行gitcommit-m“msg” （5）执行gitpushorigin[branch_name]概括来说就是先删除文件夹里的.git文件，重新将其push到仓库。 2、GitHub提交的时显示Updateswererejectedbecausetheremotecontainsworkthatyoudo问题原因：此问题原因较多，但根本原因是远程仓库中的文件有部分本地库中没有。解决方法：gitpulloriginmaster//把远程仓库master分支拉取到本地仓库master分支但是如果改动很大，比如直接在两个不同的文件夹下进行push操作，即使进行pull也可能出现其他问题。比如，refusingtomergeunrelatedhistories解决方案：gitpulloriginmaster--allow-unrelated-histories 以上是我在学习过程中遇到的问题和使用的情况，学习时主要参考了以下内容：https://blog.csdn.net/u012308586/article/details/104905828https://blog.csdn.net/u012145252/article/details/80628451https://blog.csdn.net/xiebaochun/article/details/114143346 
第127篇文章[]
Java正则表达式实例讲解 Java正则表达式实例讲解 首先观察本次需要读取的文件的内容 Employee{ ZhangSan{Manger,139-0451-0000} LiSi{Secretary,151-0101-0000} WangWu{AssociateDean,177-2021-0301} ZhaoLiua{Professor,138-1920-3912} ZhaoLiub{Lecturer,138-1921-3912} ZhaoLiuc{Professor,138-1922-3912} ZhaoLiud{Lecturer,198-1920-3912} ZhaoLiue{Professor,178-1920-3912} ZhaoLiuf{Lecturer,138-1929-3912} ZhaoLiug{Professor,138-1920-0000} ZhaoLiuh{AssciateProfessor,138-1929-0000} ZhaoLiui{Professor,138-1920-0200} ZhaoLiuj{AssciateProfessor,138-1920-0044} ZhaoLiuk{Professor,188-1920-0000}}Period{2021-01-10,2021-03-06}Roster{ ZhangSan{2021-01-10,2021-01-11} LiSi{2021-01-12,2021-01-20} WangWu{2021-01-21,2021-01-21} ZhaoLiua{2021-01-22,2021-01-22} ZhaoLiub{2021-01-23,2021-01-29} ZhaoLiuc{2021-01-30,2021-01-31} ZhaoLiud{2021-02-01,2021-02-08} ZhaoLiue{2021-02-09,2021-02-15} ZhaoLiuf{2021-02-16,2021-02-24} ZhaoLiug{2021-02-25,2021-02-28} ZhaoLiuh{2021-03-01,2021-03-01} ZhaoLiui{2021-03-02,2021-03-04} ZhaoLiuj{2021-03-05,2021-03-05} ZhaoLiuk{2021-03-06,2021-03-06}} 本段是一组排班人员的信息，第一部分是员工的信息包括其姓名、职称和电话，第二部分是值班表的开始时间和结束时间，第三部分是员工将要被放在排班表的位置信息。我们的目标是将以上介绍的信息全部读取出来。首先处理第一部分，我们最终要获得的是员工的姓名、职称和手机号，在对其所处部分进行对应后，建立以下正则表达式。 StringemployeeEntrance="\\s*Employee\\{\\s*"; StringemployeePattern="\\s*([^\\{]*)\\{([^,]*),(\\d{3})-(\\d{4})-(\\d{4})\\D*"; 第一行用于匹配Employee的第一行，也就是对应开始读入员工信息。表达式含义:\\s代表任何空白字符，包括空格、制表符、换页符等。后面跟一个*代表此空白符可以重复多次，或者一次也没有。与之类似的有+这个符号，表示这个位置至少有一个这样的字符。\{代表匹配大括号，注意在正则表达式中{带有格式说明的意思，所以为了表示其本身也需要加上\\。 第二行用于匹配后面真正的员工信息。表达式含义：这次与上次的式子不同，加入了（）括住了部分内容，括住的部分就代表将要在后面提取的内容，从前到后序号依次从一开始，在后面将通过这一顺序提取信息。[]括住的内容表示这一位置可能出现的字符，加上^代表除了这一字符的其他字符。后面\\d代表一个数字字符，与[0-9]相同，后面加上{3}代表重复三次，也就是按照文件中3-4-4的顺序进行提取。最后一个\\D*代表非数字字符的重复或空。 这样便构建了读取的正则表达式，但是想要按照表达式提取还没有完。 StringperiodPattern="Period\\{([0-9|-]*),([0-9|-]*)\\}"; StringrosterEntrance="Roster\\{\\s*"; StringrosterPattern="\\s*([^\\{]*)\\{([0-9|-]*),([0-9|-]*)\\}"; 这三句分别对应匹配后面三种句式，其中的内容与前面相似，我就不再详细介绍了。其中[0-9|-]，代表这一处可以是0-9的数字字符或是“-”这一字符，表示或者关系，采用|即可，表示范围可以使用头-尾。 用于匹配正则表达式的字符串规则构建完成，后面就是提取目标信息。 Patternemployee=Pattern.compile(employeeEntrance); Patternemessage=Pattern.compile(employeePattern); Patternperiod=Pattern.compile(periodPattern); Patternroster=Pattern.compile(rosterEntrance); Patternrmessage=Pattern.compile(rosterPattern); 创建Pattern对象对正则表达式进行解析。 Matchermessage=emessage.matcher(str); while(message.find()) { Stringname=message.group(1).substring(2); Stringposition=message.group(2); Stringphone=message.group(3)+message.group(4)+message.group(5); Stuffs=newStuff(name,phone,position); addStuff(s); str=br.readLine(); message=emessage.matcher(str); } 创建Matcher对象对读入字符串进行组捕获，之前在正则表达式中，我构建了五小括号，其中对应的内容分别保存在了group(1)到group(5)。group(0)中保存的式整个捕获的字符串。 这些是提取后的内容，其中还有其他内部处理，这里只是简单验证正确性。 我学习这部分内容主要参考的网址：https://www.runoob.com/java/java-regular-expressions.html里面内容比较全面，大家可以把我的当成一个实例来看。 
第128篇文章[]
[HIT]哈工大2021软件构造学习心得 复习了一遍软件构造的概念，对这门课的学习方式和学习内容也有了些体会和心得，给大家分享下我的感受。 第一就是这是门编程课，所以一定要动手！！！一定要动手！！！一定要动手！！！个人评判目前学过的四门编程课，动手要求能力：C语言程序设计>软件构造>数据结构>算法设计。编程课不去敲代码是绝对不行的，哪怕你不去上课，习题课的内容、实验课的内容你也要亲自动手去敲。因为很多东西你只学理论是永远学不明白的，就像教你竖式乘法你却不去动手计算。Lab3我想对于绝大多数同学都是个很大的挑战，但也是这个实验中，我对继承、抽象类、具体类、接口等等各种概念才有了自己的认识。多动手，才是学好这门课的最主要途径！ 第二，这门课的先修真的太重要了。没学过Java和Git的我从第一节课就开始懵，直接懵到考试前，所以建议学弟学妹们，在学习数据结构，或者更早的时候，顺道就给Java学了吧。而且学了Java才后知后觉，用Java实现数据结构里的链表、树、图有多么轻松！想想当初C语言折磨得我 悔不当初。所以，有空早学Java，早晚都要学的！ 我觉得以上两点就是能确保你学好这门课的全部要素了，当然我哪点做的都不好 但是期末了，三个Lab都写完了，复习也复习过一遍了，突然发现这门课是一门越学的深入越能感受到其巧妙的课程。我想每个同学Lab1和第一次习题课写的代码现在如果再找出来，都能挑一大堆毛病出来，这不正是这门课的收获。虽然只有短短32学时，我们已经从面向过程的古板简陋的C语言程序员，变成能从很多层面写代码，面向对象编程的Java程序员了，而且越是用的多，越能感受到这种不一样的编程方式的魅力。我现在很有一种冲动，就是和很多人一起完成一个大型程序，用所谓敏捷编程的思想做个什么项目出来，感觉这种交互性、协同性，才能激发我编程的激情。然后再回过头看看我们的作品，分析分析他的健壮性、正确性、复用性、可维护性等等，我想我又会有新的感想。C语言教我从无到有，而软件构造和数据结构则教我们从有到好，从好到更好。 以上就是我对这门课的一些感想，当然还有24小时时间，试还是要考，仍需继续学习才是。 
第129篇文章[]
[HIT]哈工大2021软件构造知识点理解(1) 委托 总有一些知识点，看起来似懂非懂，因此决定写几篇文章来对这些知识点总结归纳，顺便加强自己的理解，也欢迎各位积极指正其中理解不到位的地方。 在可复用处个人认为最难理解的地方就是委托(Delegation)，因此此处着重讨论一下Java中的四种委托 Dependency、Association、Aggregation和Composition。 由弱到强分别是Dependency->Association，Association中Aggregation->Composition。 假设有两个类A和B，A的Rep中含有B的对象，并且在之后A委托B，调用了B的方法，这样的委托称作Association，否则，若B的对象只作为A的某方法中的局部变量出现，我们管这样的委托叫做Dependency。 比如对于下面这个再简单不过的类B： publicclassB{ privatefinalintnum; publicB(intnum){ this.num=num; } publicintgetNum(){ returnnum; } } Dependency策略： publicclassA{ privatefinalintnum; publicA(){ Bb=newB(10); num=b.getNum(); } } 而关于Association策略，将其拆分成两部分，先来说较好理解的较强的Competition策略： publicclassA{ privatefinalintnum; privatefinalBb=newB(10); publicA(){ num=b.getNum(); } } 较弱的Aggregation策略： publicclassA{ privatefinalintnum; privatefinalBb; publicA(intnum){//此处传参也可以是Bb，看使用场景 Bb=newB(num); this.b=b; this.num=this.b.getNum(); } } 是不是有些懵，不用担心，接下来来总结一下： 1）Dependency策略的委托就像是一个渣男/渣女委托你办事，用完你就把你给甩了，并且在以前或者以后甚至都看不出任何你存在过的痕迹。 2）Competition策略的委托截然不同，就像一个贞洁烈女，只要我委托你办事了，我就赖上你了，而且我的对象从此以后只能是你，不能是别人。 3）Aggregation比较中庸，我委托给你了，我的心中就给你了一个位置，或许在未来我的对象会变，但他也永远是你的那个类型。 用这种方式来理解委托的概念，是不是就好理解多了。以上就是知识点理解第一篇的全部内容了。 
第130篇文章[1]
哈工大计算机系统HITICS大作业 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190200707 班 级 1936601 学 生 张修语 指导教师 刘宏伟 摘 要 本文讲述了hello.c程序在Linux环境下编写完成后到运行的生命历程，借助有关工具分析hello.c经过预处理、编译、汇编、链接等各个过程最终实现的原理，分析了这些过程中产生的文件的相应信息和作用。并且在此基础上理解进程管理、存储管理、IO管理等知识，对计算机系统的工作原理有了更加深入的理解。 关键词：Hello程序；实现过程；计算机系统 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -5- 第2章预处理 -6- 2.1预处理的概念与作用 -6- 2.2在Ubuntu下预处理的命令 -6- 2.3Hello的预处理结果解析 -7- 2.4本章小结 -7- 第3章编译 -8- 3.1编译的概念与作用 -8- 3.2在Ubuntu下编译的命令 -8- 3.3Hello的编译结果解析 -8- 3.3.1数据 -9- 3.3.2赋值操作 -10- 3.3.3类型转换 -10- 3.3.4算术操作 -11- 3.3.5关系操作 -11- 3.3.6数组操作 -11- 3.3.7控制转移 -11- 3.3.8函数操作 -12- 3.4本章小结 -12- 第4章汇编 -13- 4.1汇编的概念与作用 -13- 4.2在Ubuntu下汇编的命令 -13- 4.3可重定位目标elf格式 -13- 4.4Hello.o的结果解析 -16- 4.5本章小结 -18- 第5章链接 -19- 5.1链接的概念与作用 -19- 5.2在Ubuntu下链接的命令 -19- 5.3可执行目标文件hello的格式 -19- 5.4hello的虚拟地址空间 -24- 5.5链接的重定位过程分析 -24- 5.6hello的执行流程 -25- 5.7Hello的动态链接分析 -25- 5.8本章小结 -26- 第6章hello进程管理 -27- 6.1进程的概念与作用 -27- 6.2简述壳Shell-bash的作用与处理流程 -27- 6.3Hello的fork进程创建过程 -27- 6.4Hello的execve过程 -27- 6.5Hello的进程执行 -28- 6.6hello的异常与信号处理 -28- 6.7本章小结 -32- 第7章hello的存储管理 -33- 7.1hello的存储器地址空间 -33- 7.2Intel逻辑地址到线性地址的变换-段式管理 -33- 7.3Hello的线性地址到物理地址的变换-页式管理 -33- 7.4TLB与四级页表支持下的VA到PA的变换 -34- 7.5三级Cache支持下的物理内存访问 -34- 7.6hello进程fork时的内存映射 -35- 7.7hello进程execve时的内存映射 -35- 7.8缺页故障与缺页中断处理 -36- 7.9动态存储分配管理 -36- 7.10本章小结 -37- 第8章hello的IO管理 -38- 8.1Linux的IO设备管理方法 -38- 8.2简述UnixIO接口及其函数 -38- 8.3printf的实现分析 -39- 8.4getchar的实现分析 -39- 8.5本章小结 -40- 结论 -41- 附件 -42- 参考文献 -43- 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P:ProgramtoProcess 在Linux环境中，hello.c经过cpp的预处理、ccl的编译、as的汇编、ld的链接最终成为可执行目标程序hello，在终端中执行此文件时，操作系统会为其fork产生子进程，再通过execve加载此进程。 020:FromZero-0toZero-0 操作系统调用execve后映射虚拟内存，先删除当前虚拟地址的数据结构并为hello创建新的区域结构，进入程序入口后载入物理内存，再进入main函数执行代码。代码完成后，父进程回收hello进程，内核删除相关数据结构。 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 硬件环境：X64i7CPU；16GRAM；512GDisk 软件环境：Windows10；VirtualBox；Ubuntu20.04 开发/调试工具：gcc；gdb；objdump；readelf；edb 1.3中间结果 hello.c：源代码文件 hello.i：预处理后生成的文件 hello.s：编译后生成的文件 hello.o：汇编后生成的可重定位目标程序 hello_o_r.txt：hello.o的elf格式,分析汇编器和链接器行为 hello_o_o.txt：hello.o的反汇编文件 hello：链接之后生成的可执行程序 hello.txt：hello的反汇编文件 1.4本章小结 本章主要介绍了hello程序的P2P，020过程，以及实验时的软硬件环境及开发与调试工具并介绍了在本论文中生成的中间结果文件。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 预处理的概念是：在编译之前进行的处理。C语言的预处理主要有以下三个方面的内容：1.宏定义；2.文件包含；3.条件编译，预处理命令以符号#开头，如#if,#endif,#define,#include等。 预处理的作用：预处理器(cpp)根据以字符#开头的命令，修改原始的C程序。比如#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常以.i作为文件扩展名。 2.2在Ubuntu下预处理的命令 gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析 预处理前的文件仅30行，预处理后的文件达到了三千多行，但仔细观察可见main函数部分并未做出任何改变，因此可见预处理仅仅是将#include文件库函数的代码复制上去 2.4本章小结 本章介绍了预处理的概念和作用，同时介绍了Ubuntu环境下预处理的命令，并对预处理生成的hello.i文件进行了简要分析。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 概念：指利用编译程序从预处理文本文件（.i）产生汇编程序（.s）的过程。 作用：将输入的高级程序设计语言源程序翻译成以汇编语言或机器语言表示的目标程序作为输出。 3.2在Ubuntu下编译的命令 gcc-S-ohello.shello.i 3.3Hello的编译结果解析 3.3.1数据 (1)全局变量： 在此程序中仅有一个全局变量sleepsecs，且已被赋初值，根据已有知识应将此变量放于.data中，.align表示四字节对齐，.size表示此变量长度为四字节，最后.long将其赋初值2 (2)常量： 此程序中有两个常量，分别对应printf输出的两个字符串，根据已学的知识，的值应将其放于.rodata中，分别用.LC0和.LC1指示 (3)局部变量： 通过分析下方循环体的内容可知，用于循环计数的局部变量i存放在%rbp-4的内存地址处 (4)函数参数 如图，函数参数同样是存放在栈上的 3.3.2赋值操作 此程序中一共含有两次赋值操作：sleepsecs的赋值和循环过程中i的赋值。 sleepsecs的赋值操作已经在上方详细阐述过，在此处不再赘述。 下面分析循环体中i的赋值： 读上述代码可知，首先执行L2，将i赋值为0，后续与9进行比较以达成循环。所以，38行代码即为对i的赋值操作 3.3.3类型转换 此程序仅包含一次强制类型转换，即全局变量sleepsecs赋值为2.5时，编译器将其自动视为int类型的2了。 3.3.4算术操作 此程序仅包含一次算术操作，即循环体中i的i++操作，继续分析循环体可知，54行处的addl操作即为此操作，实际效果为addla,b->b=a+b 3.3.5关系操作 一次是判断argc是否不等于3，另一次是判断i在循环条件中是否小于10 (1)此处判断argc是否不等于3，若argc和3相等跳转，跳转到L2。 (2)此处判断i在循环条件中是否小于10，若i小于等于9跳转，跳转到L4。 3.3.6数组操作 此代码中通过首地址+偏移量的方式访问数组argv[]中的元素，其中，数组首地址位于%rbp-32的位置，每个数组元素长度为8，因为数组元素类型是指针类型，在程序中具体操作如下图： 3.3.7控制转移 两次转移与3.3.5中的两次关系操作一一对应，分别对应源代码中的if分支语句和for循环判断语句 3.3.8函数操作 计算编译后汇编语言执行call语句的次数，即可与源代码的五次调用函数的操作一一对应，分别是一次printf函数，一次exit函数，一次printf函数，一次sleep函数和一次getchar函数： (1)printf函数 (2)exit函数 (3)printf函数 (4)sleep函数 (5)getchar函数 3.4本章小结 本章介绍了编译的概念和作用，并针对具体的例子hello.s，按操作类型分类对hello.s进行解析，并且与源代码对比分析，得到了编译器解析代码时一些具体的思路和流程。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：汇编器（as）将.s文件翻译成机器语言指令，把这些指令打包成一种叫可重定位目标程序的格式，并将结果保存在目标文件（后缀为.o）中。 作用：将汇编代码转换成真正机器可以读懂的二进制代码。 4.2在Ubuntu下汇编的命令 gcc-chello.s-ohello.o 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 符号表： 重定位节： 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 与第三章的hello.s对比，首先在指令前增加了其十六进制表示，即机器语言。其次在操作数上，hello.s中操作数为十进制，而hello.o的反汇编中操作数为十六进制。在条件跳转语句上，hello.o的反汇编文件用的是相对偏移量，而hello.s中是函数名： 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 （1）立即数的变化：hello.s中的立即数都是用10进制数表示的。但是在机器语言中，由于转换成了二进制代码，因此立即数都是用16进制数表示的。 （2）分支转移的不一致：hello.s中的分支转移（即跳转指令）直接通过像.LC0，.LC1这样的助记符进行跳转，会直接跳转到相应符号声明的位置。助记符只是帮助程序员理解的，从汇编语言转换成机器语言之后，助记符就不再存在了，因此机器语言中的跳转使用的是确定的地址。下图中的main+0x29就表明要跳转到距main函数偏移量为0x29的位置。 （3）函数调用的不一致：hello.s中的函数调用直接在call指令后面加上要调用的函数名。但是在机器语言中，call指令后是被调函数的PC相对地址。在这里，由于调用的函数都是库函数，需要在动态链接后才能确定被调函数的确切位置，因此call指令后的二进制码为全0，同时需要在重定位节中添加重定位条目，在链接时确定最终的相对地址。 4.5本章小结 本章介绍了汇编的概念和作用，通过对比hello.s和hello.o分析了汇编的过程，同时分析了可重定位目标文件的ELF格式。 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：将各种代码和数据片段收集并组合成一个单一文件的过程 作用：使得分离编译成为可能。 5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 虚拟地址空间起始地址为0x400000结束地址为0x400ff0 下图为.txt节地址的起始地址0x400550，大小为0x132. 5.5链接的重定位过程分析 hello和hello.o相比，首先多了很多经过重定位之后的函数，如_init、puts@plt等，hello.o在.text段之后只有一个main函数；hello.o的地址是从0开始的，是相对地址，而hello的地址是从0x401000（_init的地址）开始的，是已经进行重定位之后的虚拟地址；在hello的main函数中，条件跳转指令和call指令后均为绝对地址，而hello.o中是相对于main函数的相对地址。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 hello重定位的过程： (1)重定位节和符号定义链接器将所有类型相同的节合并在一起后，这个节就作为可执行目标文件的节。然后链接器把运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号，当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。 (2)重定位节中的符号引用这一步中，连接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。执行这一步，链接器依赖于可重定位目标模块中称为的重定位条目的数据结构。 (3)重定位条目当编译器遇到对最终位置未知的目标引用时，它就会生成一个重定位条目。 5.6hello的执行流程 函数名 地址 ld-2.27.so!_dl_start ld-2.27.so!_dl_init hello!_start 0x400550 hello!_init 0x4004c0 hello!main 0x400582 hello!puts@plt 0x4004f0 hello!exit@plt 0x400530 hello!printf@plt 0x400500 hello!sleep@plt 0x400540 hello!getchar@plt 0x400510 sleep@plt 0x400540 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 全局偏移表GOT是一个数组，每个条目是一个8字节的地址，与PLT结合使用。GOT[0]和GOT[1]包含动态链接器解析函数地址时将使用的信息，GOT[2]是1d-linux.so模块中动态链接器的入口点。其余的每个条目对应于一个被调用的函数，该函数的地址需要在运行时解析。每个条目都有一个匹配的PLT条目。根据节头表，就可以得到PLT段存储GOT的起始地址为0x6008b8 查看EDB中的初始GOT条目。除了PLT[0]之外，每个PLT对应的got条目最初指向该PLT的第二条指令。如PLT[1]对应地址0x6008d0处的GOT[3]，0x6008d0处的值是0x400466，它正好指向PLT[1]的第二条指令。第一次调用函数时，动态链接器会修改相应的GOT条目。 改变后的GOT表如下: 5.8本章小结 本章通过对hello可执行程序的分析，回顾了链接的基本概念，文件的重定位过程，动态链接过程，虚拟地址空间，可重定位目标文件ELF格式的各个节等与链接有关的内容。链接的过程在软件开发中扮演一个关键的角色，它们使得分离编译成为可能。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中的程序的实例，每一个进程都有它自己的地址空间，一般情况下，包括文本区域、数据区域、和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储区着活动过程调用的指令和本地变量。 作用：进程为用户提供了一种假象：好像程序是系统中当前运行的唯一程序一样，好像程序是独占的使用处理器和内存。处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 Shell是指为使用者提供操作界面的软件（命令解析器）。它接受用户命令，然后调用相应的应用程序。Linux系统中所有的可执行文件都可以作为Shell命令来执行。 处理流程：首先对用户输入的命令进行解析，判断命令是否为内置命令，如果为内置命令，调用内置命令处理函数；如果不是内置命令，就创建一个子进程，将程序在该子进程的上下文中运行。判断为前台程序还是后台程序，如果是前台程序则直接执行并等待执行结束，如果是后台程序则将其放入后台并返回。同时Shell对键盘输入的信号和其他信号有特定的处理。 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的运行的子进程。Fork函数调用一次返回两次。 Shell通过fork创建一个新的子进程，它将在这个子进程上加载并运行hello。 6.4Hello的execve过程 Shell通过调用execve函数加载并运行可执行目标文件hello。execve函数调用一次从不返回。 当execve加载了hello之后，它调用__libc_start_main。其设置栈，并将控制转移给新程序的主函数。 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 逻辑流的执行在时间上与另一个流重叠，这称为并发流。这两个流称为并发运行。这个过程还为每个程序提供了一种假象，好像它只使用系统地址空间一样。 处理器通常使用控制寄存器中的模式位来提供一种机制来限制应用程序可以执行的指令范围和可以访问的地址空间。此寄存器描述进程当前享有的特权。设置模式位后，进程以内核模式运行。在内核模式下运行的进程可以执行指令集中的任何指令并访问系统中的任何内存位置。未设置模式位时，进程以用户模式运行。在用户模式下，不允许进程执行特权指令，也不允许进程直接引用地址空间内核区域中的代码和数据。 运行应用程序代码的进程以用户模式启动。当异常发生时，控制传递给异常处理程序，处理器将模式从用户模式更改为内核模式。处理器在内核模式下运行，当它返回到应用程序代码时，处理器将模式更改回用户模式。 内核为每个进程维护一个上下文。它由一些对象的值组成，包括通用寄存器、浮点寄存器、程序计数器、用户堆栈等。在进程执行的某个时刻，内核可以决定抢占当前进程并启动先前抢占的进程。这个决定被称为调度。在内核调度一个新进程运行之后，它会抢占当前进程，并使用一种称为上下文切换的机制将控制转移到新进程。 上下文切换：1.保存当前进程的上下文；2.恢复先前抢占进程的保存上下文；3.将控制转移到新恢复的流程。 在Hello中，当程序执行sleep函数时，sleep显式地请求调用进程睡眠。调度器抢占当前进程并通过上下文切换将其传输到新进程。sleep函数结束后，通过上下文切换返回Hello函数。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 hello程序出现的异常可能有： 中断：在程序执行的过程中可能会出现外部I/O设备引起的异常。 陷阱：陷阱是有意的异常，是执行一条指令的结果。 故障：在执行程序的时候，可能会发生缺页故障。 终止：终止时不可恢复的错误。 在发生异常时会发出信号，比如缺页故障会导致OS发生SIGSEGV信号给用户进程，而用户进程以段错误退出。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 回车与Ctrl+Z Ctrl+C ps、jobs、pstree、fg、kill等 乱按 6.7本章小结 本章介绍了有关进程管理的多个概念。介绍了Shell的作用和处理流程，以及利用fork创建子进程、利用execve加载进程的方法。展示hello程序执行的具体过程，以及异常信号的处理机制。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 逻辑地址： 在有地址变换功能的计算机中,访问指令给出的地址(操作数)叫逻辑地址,也叫相对地址。要经过寻址方式的计算或变换才得到内存储器中的物理地址。 线性地址： 线性地址（LinearAddress）是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。 物理地址： 在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址，又叫实际地址或绝对地址。 虚拟地址： 程序访问存储器所使用的逻辑地址称为虚拟地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址由段标识符和段内偏移量两部分组成。段标识符由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号，是对段描述符表的索引，每个段描述符由8个字节组成，具体描述了一个段。后3位包含一些硬件细节，表示具体是代码段寄存器还是栈段寄存器还是数据段寄存器等。通过段标识符的前13位，可以直接在段描述符表中索引到具体的段描述符。每个段描述符中包含一个Base字段，它描述了一个段的开始位置的线性地址。将Base字段和逻辑地址中的段内偏移量连接起来就得到转换后的线性地址。 对于全局的段描述符，放在全局段描述符表中，局部的（每个进程自己的）段描述符，放在局部段描述符表中。全局段描述符表的地址和大小存放在gdtr控制寄存器中，而局部段描述符表存放在ldtr寄存器中。 给定逻辑地址，看段选择符的最后一位是0还是1，用于判断选择全局段描述符表还是局部段描述符表。再根据相应寄存器，得到其地址和大小。通过段标识符的前13位，可以在相应段描述符表中索引到具体的段描述符，得到Base字段，和段内偏移量连接起来最终得到转换后的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 n位的虚拟地址包含两个部分，一个p位的虚拟页面偏移（VPO）和一个(n-p)位的虚拟页号（VPN）。 VPN作为到页表中的索引。若对应页表项的有效位为1，则取出物理页号（PPN）与物理页偏移量（PPO，等于VPO）组合形成物理地址。否则缺页，触发页面调度。 7.4TLB与四级页表支持下的VA到PA的变换 如果按照上述模式，每次CPU产生一个虚拟地址并且发送给地址管理单元，MMU就必须查找一个PTE行来用将虚拟地址翻译成物理地址。为了消除这种操作带来的大量时间开销，MMU中被设计了一个关于PTE的小的缓存，称为翻译后备缓冲器（TLB）也叫快表。例如当每次cpu发现需要重新翻译一个虚拟地址时,它就必须发送一个vpn得到虚拟地址mmu,发送一个vpo位得到一个l1高速缓存.例如当我们使用mmu向一个tlb的组请求一个页表中的条目时,l1高速缓存通过一个vpo位在页表中查找一个相应的数据标记组,并在页表中读出这个组里的个数据标记和相应的数据关键字.当mmu从一个tlb的组得到一个ppn时,代表缓存的工作在这个组的请求之前已经完全准备好,这个组的ppn与就已经可以与这些数据标记文件中的一个虚拟地址进行很好的匹配了。 corei7采用四级页表层次结构,每个四级页表进程都有他自己私有的页表层次结构,这种设计方法从两个基本方面就是减少了对内存的需求,如果一级页表的pte全部为空,那么二级页表就不会继续存在,从而为进程节省了大量的内存,而且也只有一级页表才会有需要总是在一个内存中。四级页表的层次结构操作流程如下:36位虚拟地址被寄存器划分出来组成四个9位的片,每个片被寄存器用作到一个页表的偏移量。cr3寄存器内储存了一个l1页表的一个物理起始基地址,指向第一级页表的一个起始和最终位置,这个地址是页表上下文的一部分信息。vpn1提供了到一个l1pet的偏移量,这个pte寄存器包含一个l2页表的起始基地址.vpn2提供了到一个l2pte的偏移量,一共四级,逐级以此层次类推。 7.5三级Cache支持下的物理内存访问 cache结构如下 如果选中的组存在一行有效位为1，且标记位与地址中的标记位相匹配，我们就得到了一个缓存命中，否则就称为缓存不命中。如果缓存不命中，那么它需要从存储器层次结构的下一层中取出被请求的块，然后将新的块存储在组索引位指示组中的一个高速缓存行中，具体替换哪一行取决于替换策略，例如LRU策略会替换最后一次访问时间最久远的那一行。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。内核给新进程创建虚拟内存，创建当前进程的mm_struct、区域结构和页表的原样副本，将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，为每个进程保持了私有地址空间的抽象概念。同时延迟私有对象中的副本直到最后可能的时刻，充分利用了稀有的物理内存。 7.7hello进程execve时的内存映射 加载并运行a.out的过程中： 1.删除已存在的用户区域。 2.映射私有区域。代码和数据区域被映射为a.out文件中的.text和.data区。.bss区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。 3.映射共享区域。如果a.out程序与共享对象（或目标）链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 7.8缺页故障与缺页中断处理 在指令请求一个虚拟地址时，MMU中查找页表，如果对于的物理地址没有存在主存内部，以至于我们必须要从磁盘中读出数据，这就是缺页故障（中断）。 在发生缺页中断之后，系统会调用内核中的一个缺页处理程序，选择一个页面作为牺牲页面。具体的操作过程如下： 1.CPU生成一个虚拟地址,并把它传送给MMU. 2.地址管理单元生成PTE地址,并从高速缓存/主存请求得到它. 3.高速缓存/主存向MMU返回PTE. 4.PTE中的有效位是零,所以MMU触发了一次异常,传递CPU中的控制到操作系统内核中的缺页异常处理程序. 5.缺页处理程序确定出物理内存中的牺牲页,如果这个页面已经被修改了,则把它换出到磁盘. 6.缺页处理程序页面调人新的页面,并更新内存中的PTE. 7.缺页处理程序返回地址到原来的缺页处理进程,再次对主存执行一些可能导致缺页的处理指令,cpu,然后将返回地址重新再次发送给处理程序mmu.因为程序中虚拟的页面现在已经完全缓存在了物理的虚拟内存中,所以处理程序会再次命中,主存将所请求字符串的返回地址发送给虚拟内存的处理器。 7.9动态存储分配管理 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对每个进程，内核维护一个变量brk，指向堆的顶部。分配器将堆视作一组不同大小的块的集合，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。分配器有两种基本风格：显式分配器和隐式分配器。显式分配器要求应用显式地释放任何已分配的块，隐式分配器要求分配器检测一个已分配块何时不再被程序所用，那么就释放这个块。隐式分配器又叫垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集。 为实现动态内存分配器，可以使用隐式空闲链表。当一个应用请求k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略确定的。一些常见的策略是首次适配、下一次适配和最佳适配。一旦分配器找到一个匹配的空闲块，就需要决定分配这个空闲块中多少空间。一个选择是用整个空闲块，但这样会造成内部碎片。如果匹配不太好，那么分配器会将这个空闲块分割，第一部分变成分配块，剩下的变成一个新的空闲块。利用边界标记，可以允许在常数时间内进行对前面块的合并。这种思想是在每个块的结尾添加一个脚部，其中脚部就是头部的一个副本。这样分配器就可以通过检查它的脚部，判断前面一个块的起止位置和状态，这个脚部总是在距离当前块开始位置一个字的距离。但是这种方法也存在潜在缺陷，就是在应用程序操作许多个小块时，会产生显著的内存开销。 7.10本章小结 本章主要介绍了hello的存储器的地址空间，介绍了四种地址空间的差别和地址的相互转换。同时介绍了hello的四级页表的虚拟地址空间到物理地址的转换。阐述了三级cashe的物理内存访问、进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m个字节的序列： 所有的IO设备（例如网络、磁盘和终端）都被模型化为文件，所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，使得所有的输入和输出都能以一种统一且一致的方式来执行。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixI/O接口： 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。 2.Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。 3.改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。 4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 5.关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。 UnixI/O函数: 1.intopen(char*filename,intflags,mode_tmode)，进程通过调用open函数来打开一个存在的文件或是创建一个新文件的。open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。 2.intclose(fd)，fd是需要关闭的文件的描述符，close返回操作结果。 3.ssize_tread(intfd,void*buf,size_tn)，read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF，否则返回值表示的是实际传送的字节数量。 4.ssize_twirte(intfd,constvoid*buf,size_tn)，write函数从内存位置buf复制至多n个字节到描述符为fd的当前文件位置。 8.3printf的实现分析 首先来看看printf函数的函数体 intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } printf函数是格式化输出函数,一般用于向标准输出设备按规定格式输出信息。printf中调用了两个函数，分别为vsprintf和write。 vsprintf函数根据格式串fmt，并结合args参数产生格式化之后的字符串结果保存在buf中，并返回结果字符串的长度。 write函数将buf中的i个字符写到终端，由于i保存的是结果字符串的长度，因此write将格式化后的字符串结果写到终端。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar函数体 intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章中简单的描述了linux的io的接口及其设备和管理模式,unixio的接口及其使用的函数,还有常见的printf函数和pritgetchar函数. （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 hello.c：c程序源代码，是一个二进制文本文件，hello.c中的每个字符均用ascall编码表示。 hello.i：hello.c经过预处理阶段变为hello.i。 hello.s：hello.i经过编译阶段变为hello.s。 hello.o：hello.s经过汇编阶段变为hello.o。 hello：hello.o与可重定位目标文件和动态链接库链接成为可执行文件hello。 运行：在终端输入./hello1190200707张修语。 创建子进程：由于终端输入的不是一个内置的shell命令，因此shell调用fork（）函数创建一个子进程。 加载：：shell调用execve，execve调用启动加载器，加映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数。 上下文切换:hello调用sleep函数之后进程陷入内核模式，处理休眠请求主动释放当前进程，内核进行上下文切换将当前进程的控制权交给其他进程，当sleep函数调用完成时，内核执行上下文切换将控制传递给当前进程。 动态申请内存：当hello程序执行printf函数是，会调用malloc向动态内存分配器申请堆中的内存。 信号管理：当程序在运行的时候我们输入Ctrl+c，内核会发送SIGINT信号给进程并终止前台作业。当输入Ctrl+z时，内核会发送SIGTSTP信号给进程，并将前台作业停止挂起。 终止：当子进程执行完成时，内核安排父进程回收子进程，将子进程的退出状态传递给父进程。内核删除为这个进程创建的所有数据结构。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 计算机系统的设计与人的思维方式有着很大的区别，特别是层序结构存储器，条理清晰层层深入，让我大受震撼，而汇编语言、数据表示、异常处理等内容，仅几个简单的数字或标记就能将复杂的算法与基层的计算机指令进行联系，还可以给操作系统报各种不同的错误，实在是精巧严谨。通过学习hello的程序人生，了解计算机这些底层结构，无疑对我自己以后的程序人生有着极大的启发和帮助。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 
第131篇文章[]
[HIT]哈工大2021软件构造知识点理解(2) 七大设计模式 不管怎么看，以我现在的水平，我都不可能在一篇文章中说明白一个设计模式，更别说七个。但如果你完全不知道这七大模式都是什么，那么这篇文章或许对引领你建立对这六种模式理解的框架有所帮助。 其实Java开发共有23种模式，关于这23种模式CSDN上优秀的文章比比皆是，但因为考试只针对其中六种，故在此为那些正在学习和明年将学习的学弟们写一篇入门的不能再入门的文章。 1）Adapter模式：Adapter模式也叫做适配器模式，什么是这个所谓的适配器模式呢。我来用最通俗的语言举个例子：假设你有一个3.5毫米插头耳机，并且你使用的是老款的安卓手机，上面带有一个3.5插孔耳机孔，你当然可以自由地使用这个耳机。但有一天你要换手机了，换成最新款的苹果手机，上面并不带有3.5插孔耳机孔，而是一个苹果专用接口，你该怎么做呢？将耳机线拆开将其重新焊接上苹果接口？还是给苹果手机拆开凿一个3.5插孔的耳机孔？现实中没有人这么做。因为这时就轮到我们的适配器登场了。只需要一个转换口，将原来的接口转换为适合耳机的接口即可。这里的这个转换口，就是Adapter。在Java编程实际过程中，Adapter一般是将具体类和接口进行转接，Adapter是OCP(Open-ClosedPrinciple)的体现之一。关于更详细的Adapter模式讲解，可参考以下文章：(4条消息)适配器模式的三种形式_烟雨星空的博客-CSDN博客_适配器模式 2）Decorator模式：装饰者模式，在我看来是这七大模式中最优雅当然也最晦涩难懂的设计模式。举一个经典的例子，也就是奶茶加珍珠的例子。假设一家奶茶店产品有红茶绿茶四季春奶茶，相应的配料有珍珠椰果红豆布丁奥利奥等等，作为软件工程师的你如何为这家店设计一个点餐平台呢？朴素的思想是排列组合，设计一个抽象类Tea，然后为每种具体饮品分别实现，在每个具体类中用boolisPearl，isOrio等等标记加料情况，那如果一个顾客加了三份珍珠怎么办呢？而且在每个具体类中重复的使用相同的bool变量，显然不符合我们避免代码复用的思想。优雅的解决方案是，为PearledTea等具体类设计一个统一的抽象类AddedTea，这个AdderTea继承Tea，且委托具体饮品类如RedTea等中的方法来完成功能，这样就形成了一个层层包装的商品流程。为简化例子，假设功能只有一个getPrice计算价格，一位顾客点了一杯三份珍珠一份奥利奥的红茶，那么包装的效果应如下所示： 关于更详细的Decorator模式讲解可参考：(4条消息)装饰者模式(通俗易懂)_笔记别偷看-CSDN博客_装饰着模式 3）Template模式：也叫模板模式，这个应该是最好理解的一个设计模式，同样开始举例子：假设用户想进行球类运动，球类运动的一般步骤假设是：换运动服 打球 洗澡 回家，可以见得不管打什么球，用户的换运动服和洗澡步骤都是一样的。那么模板模式的思想就是先设计一个抽象类，直接在其中具体实现换衣服方法和洗澡方法，至于具体打球方法留给各子类去完成。这个模式不贴参考文章了，应该明白意思就理解了，毕竟Lab中用的还蛮多的。 4）Strategy模式：策略模式，主要结合@Override使用。这种模式我们C语言最早期就接触过，用Switch语句选择不同的排序方式然后单步调试观察运行效果，可以类比到策略模式中。策略模式就是用户端动态的选择不同的算法来完成同一个任务，过程是首先构造一个接口，然后客户端传入要使用的算法后通过委托来实现所选择的算法。委托策略一般是Aggregation，也就是较折中的策略。策略模式可以参考(4条消息)策略模式及简单Java案例代码实现_Len-CSDN博客_策略模式java 5）Iterator模式：迭代器模式是较常用的轻量化模式，最为常见的便是链表List的遍历。迭代器模式设计要求设计者所完成的ADT无需关心容器具体类型的情况下即可完成迭代过程，其具体的实现方式是在ADT中实现Iterable接口，此接口内部只有一个返回一个迭代器的方法，然后再创建一个内部类实现Iterator接口，重写其hasNext()、next()和remove()方法，同样不贴参考文章了，贴一段代码，来自(4条消息)[HITSC]哈工大2020春软件构造复习笔记(4)_北言栾生的博客-CSDN博客 publicclassPair<E>implementsIterable<E>{ privatefinalEfirst,second; publicPair(Ef,Es){first=f;second=s;} publicIterator<E>iterator(){ returnnewPairIterator(); } privateclassPairIteratorimplementsIterator<E>{ privatebooleanseenFirst=false,seenSecond=false; publicbooleanhasNext(){return!seenSecond;} publicEnext(){ if(!seenFirst){seenFirst=true;returnfirst;} if(!seenSecond){seenSecond=true;returnsecond;} thrownewNoSuchElementException(); } publicvoidremove(){ thrownewUnsupportedOperationException(); } } //使用隐式方法迭代 publicstaticvoidmain(String[]args){ Pair<String>pair=newPair<String>("foo","bar"); for(Strings:pair){ } } } 6）Visitor模式：访问者模式的总体思想是数据Data与操作Operation分离的思想。实现较为复杂却并不困难：假设你家地下车库中放着各种乱七八糟的东西，如旧衣服篮球报纸玩具，而你要做的是是为你的汽车加油，但对其中大部分物品(Element)这个操作是不合法的，所以朴素的思想是在加油方法中加入判断语句，但如果是一个泛化操作，比如如果找到了玩具做什么，找到了报纸做什么，那么大段的switch-case不仅不优雅而且性能级差。因此Visitor模式的思想是通过一个Visitor抽象类，在其具体实现中实现visit方法，另外定义一个Element接口，在其具体实现中根据应用需求能够完成此时对应的操作，这样在访问时就能利用Dependency策略的委托来完成对应操作。深入学习可以参考(4条消息)设计模式(JAVA) Visitor模式_读书好学求知-CSDN博客 7）FactoryMethod模式：工厂方法模式也较好理解，举个例子，假如你要为你们家买一台空调，但还没决定好要买哪个牌子的空调，于是你对卖空调的工厂传入了你的需求。卖空调的工厂有很多子工厂，分别能生产海尔美的格力各种空调，这样一来，不管你买哪个牌子都可以直接与总工厂协商，总工厂再交由子工厂来具体实现为你生产空调这一操作。总工厂相当于一个接口，而子工厂则是这个接口的具体实现类。最为常见的FactoryMethod模式如使用Collection的时候，假设你要定义一个Map接口局部变量，你既可以实现为HashMap，也可以实现为TreeMap。更多请参考(4条消息)设计模式之工厂方法模式_Mr.yang的博客-CSDN博客 以上例子或者思想并不是我独立创造的，而是基本上全部来源于别人优秀的文章，我只是将他们进行总结归纳整合，在此抛砖引玉，希望为大家软件构造学习之路能有所启发有所帮助。 
第132篇文章[]
[HIT]哈工大2021软件构造知识点理解(3) 异常与断言 首先理解Java中异常的组织结构。Java中的异常Exception是一个类，继承自Throwable，Throwable还派生出Error类。Exception子类一般分为RuntimeException和一般性异常。 RuntimeException=运行时异常=系统异常=uncheckedException，可以编译通过，此类异常一定是程序员的问题，常见如被0除异常，是程序健壮性低的体现，打印异常信息即可。 一般性异常=受控异常=编译时异常=checkedException，此类异常必须显示的捕获/传递否则无法编译通过。 然后理解，捕获和抛出的有关概念： 1）捕获：try-catch-finally语句，try捕获异常，try接口会对可能含有异常的代码进行检查，若出现了异常信息，将异常传递给后面的catch()块进行处理，catch括号内为异常类，try后面可以跟多个catch块，对应不同的异常处理。try-catch类似于循环中的if-break，当异常出现时后续代码不会执行。而finally块是不管异常与否都会执行，也就是若出现异常，停止继续执行try块转而执行finally块，而若未出现异常，执行完try块将执行finally块。由于try-catch的break性质，一般先截获子异常，再截获父异常。由具体到抽象，由小范围到大范围。 2）抛出：注意，有两种语句：throws和throw。throws语句，一般在方法的声明处，跟在函数名后参数前。“出错了就不管了”的赖皮属性声明此方法可能产生的所有异常，不作处理将异常向上传递，异常处理交给调用者。throw用来在方法体内部抛出具体的异常，后面跟异常对象名，将错误信息真正的抛出。异常对象后面一般会跟getMessage()方法和printStackTrace()方法，二者区别在于getMessage会打印异常描述信息如日志信息，而printStackTrace会打印堆栈信息。 有了这些概念，assert就很容易了。 assert语句常见有两种： assertcondition;//condition为真则无事发生，为假则抛出一个AssertionError对象 assertcondition:message;//condition为真无事发生，为假会将message传入AssertionError进行错误信息输出 须注意的是，assert在IDE常规工作模式下并不会生效。 自定义异常也是考点的一部分，一般来说是一个继承自Exception的类，只含有无参数构造方法和有参数构造方法两个方法，如下： publicclassMyExceptionextendsException{ publicMyException(){ super(); } publicMyException(Stringmsg){ super(msg); } } 调用时需使用 thrownewMyException(message); 
第133篇文章[5]
[HIT]哈工大2021软件构造复习笔记(一轮) 花了一晚上时间，将软件构造的基础知识重新看了一遍，对其中很多内容有了新的理解，将我的复习笔记分享给大家。（记得比较粗糙，如果基础不太好建议还是跟着PPT学习，很多东西讲的更加透彻，知识点也更加全面。 
第134篇文章[1]
CSAPP大作业论文程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号1190200721班 级1936602学生张少卿指导教师刘宏伟 计算机科学与技术学院2021年6月 摘要 一个c语言程序到它完整地在计算机系统中实现需要经历过许多过程。首先是要将.c文件转换为可执行文件。这其中经历了预处理、编译、汇编、链接4个过程，形成可执行文件后，计算机就能读懂我们的.c代码去执行其中的语句。计算机在执行文件时候又有许多学问。例如：进程的概念，计算机存储的管理，IO的管理。一个文件的执行其背后是计算机许许多多不同且重要的功能合作完成的。 关键词：预处理；汇编；进程；存储管理；IO管理； 文章目录 摘要第1章概述1.1Hello简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2在Ubuntu下编译的命令3.3Hello的编译结果解析3.3.1变量/常量and赋初值/不赋初值and类型转换3.3.2sizeof3.3.3算术操作：+-*/%++--取正/负符合3.3.4逻辑/位操作3.3.5关系操作3.3.6数组/指针/结构操作3.3.7循环3.3.8函数 3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令4.3可重定位目标elf格式4.4Hello.o的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式5.4hello的虚拟地址空间5.5链接的重定位过程分析5.6hello的执行流程5.7Hello的动态链接分析5.8本章小结 第6章hello进程管理6.1进程的概念与作用6.2简述壳Shell-bash的作用与处理流程6.3Hello的fork进程创建过程6.4Hello的execve过程6.5Hello的进程执行6.6hello的异常与信号处理6.7本章小结 第7章hello的存储管理7.1hello的存储器地址空间7.2Intel逻辑地址到线性地址的变换-段式管理7.3Hello的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.5三级Cache支持下的物理内存访问7.6hello进程fork时的内存映射7.7hello进程execve时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章hello的IO管理8.1Linux的IO设备管理方法8.2简述UnixIO接口及其函数8.3printf的实现分析8.4getchar的实现分析8.5本章小结 附件参考文献 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。P2P：Hello的生命从hello.c开始，我们的hello.c首先经过第一道关卡 预处理，预处理器cpp将它预处理，将它变形为hello.i。于是我们的hello.i懵懵懂懂地来到了第二关卡 编译，编译器“咔咔咔”将它彻底改头换面，我们的hello.i就变为了hello.s。可是我们的发廊总裁“汇编器”对它还是不太满意。于是稍加修改。Hello.o文件问世。最后，hello.o满意地来到了最后一关。链接器ld将一身衣服“库函数”穿戴在它的身上，我们的hello就从原来的乡下小子hello.c变为了大明星hello可执行目标文件，实现P2P过程。020：子进程调用execve，映射虚拟内存并载入物理内存，进入程序入口处开始执行，同时，CPU为运行的hello分配时间片并执行逻辑控制流。在中途调用异常处理函数处理可能出现的异常。最后当hello进程终止，父进程shell将回收hello，接着内核删除相关数据结构的整个过程叫做020。 1.2环境与工具 硬件：Intel®Core™i5-9300HCPU@2.40GHz8GRAM虚拟机VUbuntu18.4开发工具：gccldreadelfgeditobjdumpedbgdbhexeditVisualStudio2019；CodeBlocks64位MwareWorkstationPro15.0 1.3中间结果 Hello可执行文件Hello.i预处理后文件Hello.s编译后文件Hello.o汇编后文件Hello_.s反汇编文件 1.4本章小结 本章简要介绍了hello的P2P，020的过程，列出了运行的环境和使用的工具，以及中间结果。 第2章预处理 2.1预处理的概念与作用 预处理概念：预处理器(cpp)根据以字符#开头的命令，修改原始的c程序。例如：#include<stdio.h>告诉预处理器读取系统头文件stdio.h的内容，并把它插入到程序文本中。得到一个新的c程序，通常是以.i命名。预处理作用：1.处理文件包含2.处理宏定义3.处理注释4.处理条件编译5.处理一些特殊控制指令 2.2在Ubuntu下预处理的命令 gcchello.c-E-ohello.i 2.3Hello的预处理结果解析 .i文件的开头： 其中数字1、2、3、4表示：1：表示新文件的开始2：表示返回一个文件（包含另外一个文件之后）3：表示一下文本来自系统头文件，因此应该抑制某些警告4：表示一下文本应该被视为包含在隐式的extern“C”块中。Stdio.h文件预处理后： 定义了些奇怪的符号： 关键字extern标示变量或者函数的定义在别的文件中： 可以发现.i文件中有许多的extern。拉到.i文件的最下方，可以发现我们的函数体，其中#的注释都被删除了。 2.4本章小结 预处理是为了将我们原始的.c文件拓展成更大的c文件，添加了许多的代码是为了方便后续编译器的操作。 第3章编译 3.1编译的概念与作用 编译的概念：编译器(ccl)将文本文件.i翻译成文本文件.s，它包含了一个汇编语言程序。编译的作用：1.扫描（词法分析）将源代码程序输入扫描器，将源代码的字符序列分割成一系列记号。2.语法分析基于词法分析得到的一系列记号，生成语法树。3.语义分析由语义分析器完成，指示判断是否合法，并不判断对错。又分：静态语义：隐含浮点型到整形的转换，会报warning；动态语义：在运行时才能确定。4.源代码优化（中间语言生成）中间代码（语言）使得编译器分为前端和后端，前端产生与机器（或环境）无关的中间代码，编译器的后端将中间代码转换为目标机器代码，目的：一个前端对多个后端，适应不同平台。5.代码生成，目标代码优化编译器后端主要包括：代码生成器:依赖于目标机器，依赖目标机器的不同字长，寄存器，数据类型等。目标代码优化器:选择合适的寻址方式，左移右移代替乘除，删除多余指令。 3.2在Ubuntu下编译的命令 编译的命令：gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 第一行解释了文件的由来第二行解释了全局变量名第四行解释了对齐的大小是4字节 这些应该是说明了这些变量存储的位置。例如：LC0存储了字符串“Usage:Hello学号姓名！”，其存储在.string节中。 3.3.1变量/常量and赋初值/不赋初值and类型转换 全局变量：全局变量一般都存储在.rodata节Hello.c中的Sleepsecs全局变量存放在.long节和.rodata中，存储的值是2，但我们观察c程序，发现其赋值是2.5。所以在这里有一个隐式的转换！将2.5转为int的2！局部变量：赋初值局部变量一半都存储在.bss节中，未赋初值的局部变量则不存放在某个位置，要是用时才存放在寄存器中在hello.c中局部变量i在前面的编译语句中没有找到，我们观察对i的调用是在循环中，所以我们去找寻相关的位置。i就保存在这个位置，看来局部变量在这里是存储在了栈中-4(%rbp)位置。 3.3.2sizeof Sizeof函数一般是在编译的时候就处理完成了，它在编译的时候就将变量类型对应的立即数改写到汇编指令中。 3.3.3算术操作：+-*/%++–取正/负符合 算术操作都是在寄存器的基础上完成的。以hello.c为例，在hello.c中出现了++运算。它执行是在循环中，我们去循环体中寻找： ++就是把对应的寄存器+1，同理–就是把对应的寄存器-1。从上面的例子我们很容易猜到加法运算的指令就是add，至于其他算术操作指令如下： Sub； imul；/一般是通过加减法来实现；%同除法；NEG取负复合拆分开一步一步计算 3.3.4逻辑/位操作 同样也是对寄存器进行操作。与&and；或|or；异或^xor；非~not；左移<<：算术左移sal；逻辑左移shl；右移>>：算术左移sar；逻辑左移shr； 3.3.5关系操作 在hello.c中的循环体中就有关系操作，一般是用cmp进行比较然后设定条件码，然后用j*语句执行相关的语句 例如将i和9进行比较，若小于等于则进入.L4块。以下是所有j*指令：指令同义名跳转条件描述Jmp1直接跳转JeJzZF相等/零JneJnz~ZF不相等/非零JsSF负数Jns~SF非负数JgJnle~（SF^OF）&ZF大于（有符号）JgeJnl~（SF^OF）大于等于（有符号）JlJngeSF^OF小于（有符号）JleJng（SF^OF）|ZF小于等于（有符号）JaJnbeCF&ZF超过（无符号）JaeJnb~CF超过相等（无符号）JbJnaeCF低于（无符号）JbeJnaCF|ZF低于等于（无符号） 3.3.6数组/指针/结构操作 数组和指针都是以地址来进行操作，在hello.c中有argv数组和argv。在hello.c中argv的地址存放在了-32(%rbp)的位置（具体分析看下面的函数操作）。 所以%rax存放的就是argv[0]的地址。所以%rax+16=argv[2]，%rax+8=argv[1]，这里的8是一个字节，16是两个字节，刚好是char的大小的倍数。 3.3.7循环 很显然cmpl指令就是循环体内部的比较语句，如果-4(%rbp)小于等于9则进入.L4块，这是一种guarded-do写法。接下来我们来观察.L4块。 .L4是循环中的语句（具体分析看下面函数调用），两个函数执行完毕后，第一次循环结束，i++，于是addl指令就执行了该操作。然后再此进入.L3块。 3.3.8函数 在hello.c中有许多的函数调用的例子函数的参数传递：Main函数 这两条指令执行了main函数的参数传递，函数的参数传递通常是保存在%rdi和%rsi寄存器中。根据.c文件，我们清楚在%edi中保存的是第一个参数argc，在%rsi中保存的是第二个参数*argv。 然后是函数的调用： 我们知道循环中主要是printf和调用sleep函数。这里就涉及了数组的偏移操作，我们知道数组首地址存放在-32(%rbp)中，所以%rax存放的就是argv[0]的地址。所以%rax+16=argv[2]，%rax+8=argv[1]，这里的8是一个字节，16是两个字节，刚好是char的大小。再将.LC1存放于%edi寄存器，参数设置完毕，接下来就是调用printf函数了。执行完后再将sleepsecs存放于%edi寄存器调用sleep函数。函数的调用有两种方式：1.直接调用，2.间接调用。直接调用的目标是作为指令的一部分编码，间接调用涉及了相对寻址，相对于call指令的下一条指令的地址。函数的返回return： 当循环体结束后，调用getchar函数，由于return0，将0存放于%eax寄存器，因为%eax是指定的返回函数存储的寄存器。然后leave和ret，函数调用结束返回。Leave是对栈的操作，取出数据然后%rsp+8/+16。 3.4本章小结 编译这一步，将hello.c文件从高级语言转变到了汇编语言，我们发现，汇编语言是机器代码的文本表示，更方便跟机器“沟通”。在这一步后，汇编器才能理解我们的程序，从而将我们的程序转变为更底层的机器语言。 第4章汇编 4.1汇编的概念与作用 汇编的概念：汇编器（as）将hello.s翻译成机器语言指令，并把这些指令打包成一种叫做可重定位目标程序。将结果保存在目标文件hello.o中汇编的作用：将汇编指令转成机器可以直接识别的机器指令 4.2在Ubuntu下汇编的命令 汇编的指令：gcc-chello.s-ohello.o 4.3可重定位目标elf格式 指令：readelf-ahello.o 相关的解读Magic：魔数E45L4CF46Data数据：补码表示，小端Entrypointaddress入口点地址：ELF起始位置Startofprogramheaders程序头起点：程序头表起始位置Startofsectionheaders：偏移量Numberofprogramheaders：表象个数Sizeofsectionheaders节头大小：每个节的大小节头数量：节个数字符串表索引头：.strtab节的位置2.节头部表，不同节的位置和大小都是节头部表描述的，其中每个节都一个固定大小的条目。 相关的说明：大小：节的字节数偏移量：节相对于自己的起始位置的偏移量（起始位置跟对齐有关）对齐：限制了节的起始地址，4就是代表了对齐最小单位是1000。3.重定位信息 在链接的时候需要对符号重新定义，定义的信息就来自于重定位节。可以看到函数和全局变量都在其中。4.符号表 存放了程序中定义的全局变量和函数的信息。 4.4Hello.o的结果解析 在hello.o的反汇编出来的汇编语言中，可以发现其将符号解析并增加了重定位信息，例如原本的.L2块中的jmp.L3转换为了地址。 还有就是全局变量sleepsecs和函数调用。 由于每条指令都有了自己的相对地址，所以分支转移函数调用就可以直接用相关指令的相对地址来进行跳转，同时增加了重定位信息，方便后续链接的时候修改。 4.5本章小结 在进行汇编过程后，hello.s文件转换为了二进制可重定位文件hello.o，在hello.o中我们hello.s本来是符号的地方都进行了解析转换为了一串地址。所以hello.o文件与hello.s文件有着不同之处，同时也更有利于机器理解。 第5章链接 5.1链接的概念与作用 链接的概念：链接器（ld）将多个.o文件合并，得到一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。链接的好处： 模块化：一个程序可以分成很多源程序文件可以构建共享函数库效率高时间上，可分开编译空间上，无需包含共享库所有代码 5.2在Ubuntu下链接的命令 链接的命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 这里ELF所显示的信息与hello.s的ELF的显示的都是一样的就不再解读，不过我们可以发现hello中节头的数量比hello.s的多得多。各节头的信息： 节头多了许多，不过阅读的方式没有改变。主要关注地址，偏移量和对齐共享库的地址： 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 我们的首要目标是.interp段的内容。有节头部表，可以知道该段的起始地址为0x402e0，那我们现在来查看该段的内容，我们发现其内容为：/lib64/ld-linux-x86-64.so.2。我们知道这是链接器的信息。 接下来搜索.dynstr节，结果为：.libc.so.6.exit.puts.printf.getchar.atoi.sleep.libc_strat_main.GLIBC_2.2.5.gmon_start。显然这些都是共享库的信息。 再来查看.rodata节，里面是字符串常量。 5.5链接的重定位过程分析 相比于hello.o的反汇编，hello的反汇编多了许多函数，而不仅有main。例如_init、puts、printf等等。同时在hello的反汇编中，地址全部转换为了虚拟地址，起始从400000开始，而不是0开始。 而原先hello.s反汇编中的重定位信息也都使用上改为了符号所对应的虚拟地址，由于符号和指令的相对位置是不变的，所以当求出指令的地址时，符号的地址也可以由这个重定位信息计算出来。 5.6hello的执行流程 ld-2.31.so!_dl_startld-2.31.so!_dl_inithello!_start0x400500libc-2.31.so!__libc_start_main-libc-2.31.so!__cxa_atexit-libc-2.31.so!__libc_csu_inithello!_initlibc-2.31.so!_setjmp-libc-2.31.so!_sigsetjmp–libc-2.31.so!__sigjmp_savehello!mainhello!puts@plthello!exit@plt*hello!printf@plt*hello!sleep@plt*hello!getchar@pltld-2.31.so!_dl_runtime_resolve_xsaveld-2.31.so!_dl_fixupld-2.31.so!_dl_lookup_symbol_xlibc-2.31.so!exit 5.7Hello的动态链接分析 （以下格式自行编排，编辑时删除）分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。hello程序对动态链接库的引用，利用代码段和数据段之间距离不变这一个事实，因此代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量。GNU编译系统使用了一种有趣的延迟绑定技术来解决动态库函数模块调用的问题，将过程地址的绑定推迟到了第一次调用该过程时。延迟绑定通过全局偏移量表（GOT）和过程链接表（PLT）的交互实现。如果一个目标模块调用定义在共享库中的任何函数，那么就有自己的GOT和PLT。前者是数据段的一部分，后者是代码段的一部分。下图是PLT数组。 GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[l]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。下面以printf为例子来解释动态链接：第一次调用printf：第一步：程序进入printf对应的PLT条目。第二步：第一条PLT指令通过相对应的GOT进行简介跳转，因为每个GOT条目初始都指向它对应的PLT条目的第二条指令，这个简介跳转知识简单地把控制传送回PLT[2]中的下一条指令。第三步：把printf的ID压入栈中，PTL跳转到PTL[0]第四步：PTL[0]通过GOT[1]间接地吧动态链接器的一个参数压入栈中，然后通过GOT[2]间接跳转进动态链接器中。动态连接器使用两个栈条目来确定printf的运行地址，将地址重写回printf对应的GOT，再把控制传递给printf。后续再调用printf时，GOT的间接跳转会直接将控制转移到printf。 Printf调用前GOT表 Printf调用后GOT表 5.8本章小结 链接器将我们需要的.o文件合并成一个可执行文件，这样的文件就可以在shell中执行了，我们的文件成功从原来的.c文件转换为了一个能在计算机中执行的文件。 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程是计算机科学中最深刻、最成功的概念之一。进程是正在运行的程序的实例。进程的作用： 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。2.一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 Shell：shell是一个交互型应用级程序，代表用户运行其他程序。是系统的用户界面，提供了用户与内核进行交互操作的一种接口。他就收哟洪湖输入的命令并把它送入内核去执行。2.功能：其实shell也是一支程序，它由输入设备读取命令，再将其转为计算机可以了解的机械码，然后执行它。各种操作系统都有它自己的shell，以DOS为例，它的shell就是command.com文件。如同DOS下有NDOS，4DOS，DRDOS等不同的命令解译程序可以取代标准的command.com，UNIX下除了Bourneshell（/bin/sh）外还有Cshell（/bin/csh）、Kornshell（/bin/ksh）、Bourneagainshell（/bin/bash）、TenexCshell（tcsh）等其它的shell。UNIX/linux将shell独立于核心程序之外，使得它就如同一般的应用程序，可以在不影响操作系统本身的情况下进行修改、更新版本或是添加新的功能。Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。3.处理流程：shell首先检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux本身的实用程序，如ls和rm，也可以是购买的商业程序，如xv，或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能够成功找到命令，该内部命令或应用程序将被分解为系统调用并传给Linux内核。 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的运行的子进程。调用fork函数后，新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码、数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于他们有不同的PID。fork被调用一次，却返回两次,子进程返回0，父进程返回子进程的PID。子进程有不同于父进程的PID。 6.4Hello的execve过程 Execve函数在当前的进程的上下文中加载并运行一个新程序。Execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。所以，execve调用一次并从不返回。子进程调用execve函数，在当前进程的上下文中加载并运行一个新程序即hello程序，execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行hello程序，并映射私有区域，为程序的代码，数据，bss，栈区域创建新的区域结构。新的栈和堆段被初始化为零，新的代码和数据段被初始化为可执行文件中的内容。最后加载器设置PC指向_start地址，_start最终调用hello中的main函数。。注意，execve函数再当前进程的上下文中加载并运行一个新程序。它会覆盖当前进程的地址空间，但是并没有创建一个新进程。新进程仍然有相同的PID，并继承了调用exceve函数时已打开的所有文件。 6.5Hello的进程执行 进程调度的过程：操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务。内核为每一个上下文维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫调度。在内核调度一个新的进程，上下文切换，实现 保存当前进程的上下文恢复某个先前被抢占的进程被保存的上下文将控制传递给这个心回复的进程进程时间片：一个继承执行它的控制流的一部分的每一时间段叫做时间片，当时间片的时间用尽后，若当前进程还没执行完毕，控制会转移给内核，有内核选择是否仍执行该进程。用户态与核心态转换：处理器使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权。如果没有设置模式位，进程就处于用户模式；设置模式位，进程就处于内核模式。用户模式的进程不允许执行特权指令，不允许直接应用地址空间中内核区内的代码和数据；内核模式下该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 6.6hello的异常与信号处理 乱按包括回车： 乱按的字符会保存在缓冲区内，如果在sleep这期间我们输入了字符和回车回车，则当我们的hello进程结束后，这些字符会被执行，例如图中的sd、fa、123等 Ctrl+c：会直接终止当前的进程 Ctrl+z：会停止当前的进程 停止后输入ps： 输出了执行进程的PID，TTY，TIME和我们输入的CMD。停止后输入jobs： 显示了我们当前的所有进程，包括停止的。停止后输入pstree： 停止后输入fg： 将我们的hello进程调度会前台继续执行。停止后执行kill-n921378： Hello进程被杀死。 6.7本章小结 本章介绍了进程与shell执行的相关知识。进程是计算机中最伟大的概念，有了进程才有了我们现在所身处的计算机世界。不同的进程在内核的调度下执行者自己的指令，而没有错误。在进程中遇到异常时，操作系统有着自己的方式来处理。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：在有地址变换功能的计算机中，访内指令给出的地址(操作数)叫逻辑地址，也叫相对地址。线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。虚拟地址：CPU启动保护模式后，程序运行在虚拟地址空间中，也就是程序在磁盘中使用的地址。Hello可执行文件反汇编后，每条指令前的地址就是虚拟地址物理地址：放在寻址总线上的地址。放在寻址总线上，如果是读，电路根据这个地址每位的值就将相应地址的物理内存中的数据放到数据总线中传输。如果是写，电路根据这个地址每位的值就在相应地址的物理内存中放入数据总线上的内容。物理内存是以字节(8位)为单位编址的。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址由段选择符和偏移量组成，线性地址为段首地址和逻辑地址中的偏移量组成。其中，段首地址存放在段描述符中。而段描述符存放在段描述符表中。一般逻辑地址实际是由48位组成，前16位包括[段选择符]，后32位[段内偏移量]。其中段指的是可执行文件中的代码段，数据段等等。段选择符用于寻找段描述符表，段内偏移量是指令地址相对于段基址的偏移量。段选择符的16位格式如下： 索引：描述符表的索引TI：如果TI是0。「描述符表」是「全局描述符表（GDT）」，如果TI是1。「描述符表」是「局部描述表（LDT）」RPL：段的级别。为0，位于最高级别的内核态。为11，位于最低级别的用户态。在linux中也仅有这两种级别。流程大致如下图： 其中GDT和LDT的首地址，存放在用户不可见的起存起中。这样子我们就拿到了我们要的段基地址，再加上我们的偏移量，得到了线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 从线性地址到物理地址简单来说就是下面这张图： 虚拟地址分为两部分：虚拟页号（VPN）以及和虚拟页偏移量（VPO），其中虚拟页偏移量与物理也偏移量是相同的，也就是说我们只需要找到物理页号（PPN）就可以得到我们想要的物理地址。那么物理页号存放在哪呢？它就存放在PTE页表中。我们通过VPN去页表中寻找，如果命中则取出物理页号，如果不命中，则替换该位置的PTE，再取出我们需要的物理页号。当然实际过程没这么简单，这里面还涉及了TLB的小缓存，一种关于PTE的缓存，称为翻译后备缓冲器。一般会先去TLB中寻找物理页号，若不命中则去PTE中寻找。这点接下来详细介绍。 7.4TLB与四级页表支持下的VA到PA的变换 我们知道虚拟地址分为VPN和VOP，以intelCorei7为例，Corei7支持48位虚拟地址和52位物理地址。以下图来解释： 48位的虚拟地址被划分为36位的VPN和12位的VPO。而对于TLB来说，36位的VPN有可以看成是32位的TLBT（标记）和4位的TLBI（组索引）。若命中则取出其中的PPN。若不命中，则用36位的VPN去页表中寻找，页表分为4级页表，每一页的页表对应9位的VPN片。每个片被用作到一个页表的偏移量。而2,3,4级的页表基地址由前一级的页表存储，1级的页表基地址由CR3提供。如果在PTE中仍然不命中，则替换该页。取出PPN后和VPO合并由此得到了物理地址。 7.5三级Cache支持下的物理内存访问 在我们得到物理地址后，就需要去访问物理内存，物理地址被分为3个部分，分别是CT（高速缓存标记），CI（高速缓存组索引），CO（高速缓存块偏移）。CT用来判断我们需要的内存块是否在缓存中，CI用来定位高速缓存中的组标号，CO是缓存块中的偏移。 仍以该图为例，64组，所以CI=6，每一块64字节，所以CO=6，那么CT=52-6-6=40。如果在L1cache中命中，则取出结果，如果未命中则去L2,L3,和主存中寻找。 7.6hello进程fork时的内存映射 Mm_struct（内存描述符）：描述了一个进程的整个虚拟内存空间。Vm_area_struct（区域结构描述符）：描述了进程的虚拟内存的一个空间。在fork创建虚拟内存的时候，要经历一下步骤： 创建当前进程的mm_struct，vm_area_struct和页表的原样副本两个进程的每个页面都标记为只读页面。两个进程的每个vm_area_struct都标记为私有，这样就只能在写入时复制 7.7hello进程execve时的内存映射 删除已存在的用户区域映射私有区域（.malloc，.data，.bss，.text）映射共享区域（.libc.so.data,lib.so.text）4.设置程序计数器PC，指向代码区域的入口 7.8缺页故障与缺页中断处理 缺页故障： 段错误，虚拟地址不合法保护异常，内存访问不合法 缺页中断处理：MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，执行以下步骤： 判断虚拟地址A是否合法，如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。判断试图进行的内存访问是否合法，如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。此时，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。于是，内核会选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这次MMU就能正常地翻译A，而不会引起缺页中断。 7.9动态存储分配管理 动态内存分配器为我们提供额外的虚拟内存。动态内存分配器维护者一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。 分配器有两种基本的风格，两种风格都要求应用显示地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。显示分配器，要求应用显示地释放任何已分配的块。例如，c标准库的malloc程序包隐式分配器，要求分配器检测一个已分配块合适不再被程序所使用，那么久释放这个块。隐式分配器也叫作垃圾收集器。 隐式空闲链表 A.找到一个空闲块，有以下适配方法：首次适配(Firstfit)：从头开始搜索空闲链表，选择第一个合适的空闲块。此时搜索时间与总块数是线性关系，且倾向在靠近链表起始处留下小空闲块的“碎片”，增加对较大块的搜索时间下一次适配(Nextfit)：和首次适配相似，是从链表中上一次查询结束的地方开始，这种适配比首次适应更快，可以避免重复扫描那些无用块。最佳适配(Bestfit)：查询链表，检查每一个空闲块，选择适合所需请求大小的最小空闲块，保证碎片最小，提高内存利用率，运行速度通常会慢于首次适配。B.分割(splitting)：申请空间比空闲块小，可以把空闲块分割成两部分。 C.释放并分配：清除已分配标志，合并相邻的空闲块，和下一个空闲块合并或者双向合并。 显示空闲链表 显式空闲链表采用的方式是维护空闲块链表，而不是所有块。在空闲块中储存前/后指针，而不仅仅是大小，此外还需要边界标记，用于块合并。幸运的是，只需跟踪空闲块，因此可以使用有效载荷区域。A.维护显式空闲链表方法：LIFO(last-in-first-out)策略：后进先出法。将新释放的块放置在链表的开始处。此方法优点是简单，常数时间，缺点是研究表明碎片比地址顺序法更糟糕。地址顺序法(Address-orderedpolicy)：按照地址顺序维护链表。addr(前一个块)<addr(当前回收块)<addr(下一个块)。此方法优点是研究表明碎片要少于LIFO，缺点是需要搜索。3.分离的空闲链表：分离存储，是一种流行的减少分配时间的方法。一般思路是将所有可能的块大小分成一些等价类/大小类。分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。维护方法：A.简单分离存储每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。B.分离适配每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显示或隐式链表，每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。（以下格式自行编排，编辑时删除）4.块按大小排序在每个空闲块中使用一个带指针的平衡树，并使用长度作为权值。 7.10本章小结 本章首先介绍了4种存储器的地址模式，然后是地址变换的方法，例如：逻辑地址到线性地址的变换，再从线性地址到物理地址的变换，这对应了如何将虚拟内存的数据映射到了物理内存中。其中线性地址到物理地址的变换设计了TLB缓存和4级页表，这两者的存在是为了提高转换的效率以及降低内存空间的使用。得到物理地址后，我们就需要根据物理地址去内存中寻找我们需要的内容。为了提高访问速率，三级Cache由此出现。接下来介绍了fork和execve的内存映射以及遇到缺页时，内核该怎么处理。最后就是内存的动态管理，这其中涉及了显示分配器和隐式分配器两种方式。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件设备管理：unixio接口一个Linux文件就是一个m个字节的序列B0，B1，……，Bm-1。所以的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这个设备映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得输入和输出都能以一种统一且一致的方式的来执行。 8.2简述UnixIO接口及其函数 打开文件：进程是通过调用open函数来打开一个已存在或者创建一个新文件的intopen(char*filename,intflags,mode_tmode);open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，flags参数也可以是一个或者更多位掩码的或，给写提供一些额外的指示。mode参数指定了新文件的访问权限位。关闭文件：进程通过调用close函数关闭一个打开的文件。intclose(intfd);关闭一个已关闭的描述符会出错。读和写文件：应用程序是通过分别调用read和write函数来执行输入和输出的。ssize_tread(intfd,void*buf,size_tn)；ssize_twrite(intfd,constvoid*buf,size_tn);read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF，否则返回值表示的是实际传送的字节数量。write函数从内存位置buf复制至多n个字节到描述符为fd的当前文件位置。 8.3printf的实现分析 （以下格式自行编排，编辑时删除） 我们知道printf函数的参数是不确定的，所以我们就需要确定具体的参数个数。va_list的定义：，说明它是一个字符指针。(char*)(&fmt)+4表示的是第二个参数，也就是……中的第一个参数。因为&fmt表示的是fmt的地址，是char*类型的指针，其大小为4，所以我们加上4后表示的就是第二个参数的首地址。 vsprintf的作用是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。然后sys_call显示格式化了的字符串。内核会通过字符显示子程序，根据传入的ASCII码到字模库读取字符对应的点阵，然后通过vram（显存）对字符串进行输出。显示芯片将按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量），最终实现printf中字符串在屏幕上的输出。 8.4getchar的实现分析 （以下格式自行编排，编辑时删除） 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章介绍了UnixI/O接口以及I/O函数，分析了printf和getchar的实现。（第8章1分）结论Hello的一生：1.程序员通过I/O设备，往计算机里敲入代码，编写出hello.c文件2.hello.c在预处理器下经过预处理形成hello.i文件3.hello.i在编译器下经过编译形成hello.s文件4.hello.s在汇编器下经过汇编形成hello.o文件5.hello.o在链接器下与其他.o文件链接形成hello可执行文件6.shell为hello文件分配空间形成进程，到前台执行7.shell通过fork()函数创建一个子进程，在子进程中通过execve函数加载hello城西，建立hello可执行文件到虚拟内存的映射。8.在执行hello时，发生了缺页中断，触发了缺页中断处理程序。9.内核将hello文件的虚拟内存映射为物理内存，将虚拟地址翻译为物理地址。再根据这个物理地址去Cache/主存内读取数据、指令。10.printf执行，将格式化结果显示到了shell中11.hello进程终止，向父程序shell发送SIGCHLD信号12.将hello进程进行回收感悟：一个文件的执行，不像我们看起来的那么简单，他需要涉及许多复杂且伟大的过程，许多创新性地概念。例如进程的提出用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。（结论0分，缺失-1分，根据内容酌情加分） 附件 Hello可执行文件Hello.i预处理后文件Hello.s编译后文件Hello.o汇编后文件Hello_.s反汇编文件 参考文献 为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp.（参考文献0分，缺失-1分） 
第135篇文章[]
HIT软件构造21年春lab总结 HIT软件构造21年春lab Lab1P2convexHull Lab2迭代器删除toString的益处AF，REP的理解参数输入类型的对比 Lab21.MultiIntervalSet对于IntervalSet的委派关于周期性的疑惑 Lab1 P2convexHull 关于二维凸包的一个问题，一开始的想法是：先选定最右下角的点作为基点，然后如果下一个点在相对于以基点做的y轴的右侧则后续的点都得选取逆时针角度最大的点，直到回到基点。以上想法是由于之前写过一个计算两个向量转向的函数，而如果是逆时针的话就是角度大于180度，所以就相当于寻找旋转角最大的即可，不过实际操作起来发现时间复杂度过大，于是去寻找了相关的算法，发现了向量叉乘结果可以判断逆时针还是顺时针，于是陷入了沉思。向量的叉乘究竟是如何判断逆时针还是顺时针，我查找了许多的参考资料都没有一个完整地解答这一个原理。我们知道，根据右手螺旋守则，逆时针方向的向量叉乘都指向同一侧，而顺时针都指向另一侧，个人猜测这个原理是个发现，由于发现逆时针叉乘结果都是正的，才规定叉乘结果是正就是逆时针，叉乘结果是负就是顺时针。 Lab2 在lab2中有许多新的发现。 迭代器删除 例如如果要删除容器里面的元素，例如：list，map，set。最好是使用迭代器来删除，因为如果用for循环来删除，假设当删去第i个元素时，后续的所有元素就会往前移动，第i+1变为i，i+2变为i+1……。而此时循环中的控制循环次数变量仍是i，且下一个循环就变为i+1，而我们本来的i+1元素已经到了第i个元素，所以会有漏删的可能性。这种时候我们就最好使用迭代器删除。然后迭代器中最难书写的就是Map了，需要在Map.Entry使用迭代器。 toString的益处 toString()函数在debug中的帮助。toString是为了让我们更好地理解一个ADT类，用人能听懂的话。当我们override了toString后，我们在debug时，我们的ADT变量就会用我们定义的toString来表示，如果我们没有toString，则该变量显示的就是内存地址，这不方便我们去理解内部的情况，所以后续在编写ADT时，最好先将toString完成。 AF，REP的理解 AF我的理解是用人的语言去描述ADT类型，让使用者可以听懂这个ADT是用来表示什么的。REP我的理解是它声明了有什么变量，变量之间或者变量本身要满足什么关系。 参数输入类型的对比 在FriendshipGraph中，我将原本的参数输入从Person改为String，然后在方法内部再new出Person。这里是由于习题课的时候老师提过一嘴，采用基础数据类型的好处在于让客户端对我们内部的实现了解更少，这样子更有利于我们保护内部的数据。 Lab2 1.MultiIntervalSet对于IntervalSet的委派 在MultiIntervalSet中要求将IntervalSet作为我们的Rep，称为intervalSet，需要复用IntervalSet中已实现的类和功能。但是IntervalSet接口的实现类CommonIntervalSet是针对标签只有一个时间段的插入。那么问题来了，如果要在MultiIntervalSet中通过intervalSet来插入一个标签多个时间段就必须得重写MultiIntervalSet的标签。然而时间段的管理都在intervalSet这个我们的Rep中的成员变量中。 但是MultiIntervalSet正常来说是无法范文IntervalSet中的Rep，所以我们就需要将IntervalSet中的Rep返回出来，于是我增加了一个getIntervalSet的函数。 现在又有个问题了：当DutyIntervalSet继承了CommonIntervalSet，它就多了一个getIntervalSet函数，很显然在DutyIntervalSet类中，我们是不想把他的Rep返回给客户端，对于这个问题我的想法是将DutyIntervalSet的getIntervalSet重写为空，但是这个方法又不符合LSP原则了。所以重写了MultiIntervalSet中的Rep，一开始的方法是将IntervalSet中的rep定义为Map<L,List<·Interval>>。现在我们将MultiIntervalSet中的Rep定义为List<·IntervalSet>。如果同一个标签有新的Interval就往List中add一个新的Interval。由此能很好地实现委派的任务。 关于周期性的疑惑 关于App1与App2，没有要求周期性。那么岂不本应该意味着App1和App2不论是否满足周期性都是正确的？而且App1本身便是一个标签一个时间段，从定义上一开始就不满足周期性。所以对于App1和App2我不去检验周期性，而对于App3由于要求满足周期性原则，所以如果经检验，不满足周期性我便抛出异常。以上是我对周期性的理解。 
第136篇文章[3]
代码之路 SPF（Tarjan算法应用） SPF 题目ProblemDescriptionInputOutputSampleInputSampleOutpit 思路相关知识：Tarjan算法，dfs序 AC代码小结 题目 ProblemDescription Considerthetwonetworksshownbelow.Assumingthatdatamovesaroundthesenetworksonlybetweendirectlyconnectednodesonapeer-to-peerbasis,afailureofasinglenode,3,inthenetworkontheleftwouldpreventsomeofthestillavailablenodesfromcommunicatingwitheachother.Nodes1and2couldstillcommunicatewitheachotherascouldnodes4and5,butcommunicationbetweenanyotherpairsofnodeswouldnolongerbepossible. Node3isthereforeaSinglePointofFailure(SPF)forthisnetwork.Strictly,anSPFwillbedefinedasanynodethat,ifunavailable,wouldpreventatleastonepairofavailablenodesfrombeingabletocommunicateonwhatwaspreviouslyafullyconnectednetwork.Notethatthenetworkontherighthasnosuchnode;thereisnoSPFinthenetwork.Atleasttwomachinesmustfailbeforethereareanypairsofavailablenodeswhichcannotcommunicate. Input Theinputwillcontainthedescriptionofseveralnetworks.Anetworkdescriptionwillconsistofpairsofintegers,onepairperline,thatidentifyconnectednodes.Orderingofthepairsisirrelevant;12and21specifythesameconnection.Allnodenumberswillrangefrom1to1000.Alinecontainingasinglezeroendsthelistofconnectednodes.Anemptynetworkdescriptionflagstheendoftheinput.Blanklinesintheinputfileshouldbeignored. Output Foreachnetworkintheinput,youwilloutputitsnumberinthefile,followedbyalistofanySPFnodesthatexist. Thefirstnetworkinthefileshouldbeidentifiedas“Network#1”,thesecondas"Network#2",etc.ForeachSPFnode,outputaline,formattedasshownintheexamplesbelow,thatidentifiesthenodeandthenumberoffullyconnectedsubnetsthatremainwhenthatnodefails.IfthenetworkhasnoSPFnodes,simplyoutputthetext“NoSPFnodes”insteadofalistofSPFnodes.Separatetestcaseswithablankline. SampleInput 1254313234350 12233445510 122334466325510 0 SampleOutpit Network#1（两空格）SPFnode3leaves2subnets Network#2（两空格）NoSPFnodes Network#3（两空格）SPFnode2leaves2subnets（两空格）SPFnode3leaves2subnets 思路 相关知识：Tarjan算法，dfs序 思路来源： 割点相关知识1:链接.割点相关知识2:链接. 笔记：dfn[]：记录的是节点的dfs序low[]：记录的是强连通分量/环中的最早的根子节点的dfs序搜查的时候会出现2中情况，设搜查点为v，分别为：v搜查过，v为搜查过。 未搜查时，则继续dfs，回溯时更新low，low[v]=min（low[u],low[v]）搜查过时，假设是从u去搜查，则显然dfn[u]>dfn[v]，则low[v]=min(low[u],low[v] 若出现回边，low一定会更新。 AC代码 #include<stdio.h> #include<stdlib.h> #defineM1010 /*runthisprogramusingtheconsolepauseroraddyourowngetch,system("pause")orinputloop*/ intdfn[M],low[M],head[M],cut[M],vis[M]; intcnt,num,root,root_son,test,n; //dfn记录i个点搜索的序号，low记录强连通分量（环）的根子节点，head记录第i个点加边的最后一条，vis记录dfs是否搜查 //cnt标记加边的序号，num标记搜查序号，root代表跟，root_son根子树，n代表节点数量 structEDG{ intto;//边的指向 intnext;//该节点上一条加入的边的序号 }edg[M*20]; voidinit(){ memset(dfn,0,sizeof(dfn)); memset(cut,0,sizeof(cut)); memset(low,0,sizeof(low)); memset(head,-1,sizeof(head)); memset(edg,0,sizeof(edg)); test++; n=1; cnt=0; num=1; } voidaddedge(intu,intv){ edg[cnt].to=v; edg[cnt].next=head[u];//该节点上一条边序号位置 head[u]=cnt++; } intmax(inta,intb){ returna>b?a:b; } intmin(inta,intb){ returna<b?a:b; } voidTarjan(intu){ inti; low[u]=dfn[u]=num++; for(i=head[u];i!=-1;i=edg[i].next){ intv=edg[i].to; if(!dfn[v]){ Tarjan(v); if(u==root){//如果是跟，则其子树数量加一 root_son++; } else{ if(low[u]>low[v]){//回溯时,若low[u]>low[v],说明存在强连通分量,将low[u]更新为根节点的dfs序 low[u]=low[v]; } if(low[v]>=dfn[u]){//若low[v]>dfn[u],说明是割点 cut[u]=1; } } } else{//若该点已搜查过，则显然dfn[u]>dfn[v],此时比较low[u]和dfn[v]即可 low[u]=min(low[u],dfn[v]); } } } voiddfs(intu){//查找割点的子树 vis[u]=1; for(inti=head[u];i!=-1;i=edg[i].next){ intv=edg[i].to; if(!vis[v]){ dfs(v); } } } intmain(){ intu,v,flag; test=0; while(scanf("%d",&u),u){ init(); n=max(u,n); scanf("%d",&v); n=max(v,n); addedge(u,v); addedge(v,u); while(scanf("%d",&u),u){ n=max(u,n); scanf("%d",&v); n=max(v,n); addedge(u,v); addedge(v,u); }//输入 root=1,root_son=0,flag=0; Tarjan(root); if(root_son>1){ cut[root]=1; } printf("Network#%d\n",test); for(inti=1;i<=n;i++){ if(cut[i]){ flag=1; memset(vis,0,sizeof(vis)); intson=0; vis[i]=1; for(intj=head[i];j!=-1;j=edg[j].next){ v=edg[j].to; if(!vis[v]){ dfs(v); son++; } } printf("SPFnode%dleaves%dsubnets\n",i,son); } } if(!flag){ printf("NoSPFnodes\n"); } printf("\n"); } return0; } 小结 Tarjan算法可以用来寻找有向图中的强连通分量，或是无向图中的环 
第137篇文章[3]
DecodingTask DecodingTask 题目思路AC代码 题目 题目偏长，放一个链接http://acm.hit.edu.cn/problemset/1012. 思路 本题难度感觉在于题目理解，题目要求2个十六进制数来代表一个btye，所以首先2个字符2个字符处理，转换为十进制。由于第二串字符（记为bi）多出一个空格（由十进制的32表示）。所以先用32异或b[1]，得到第一个密匙，在与第一串字符（记为ai）a[1]异或，得到明文，以此类推。 AC代码 #include<stdio.h> #include<stdlib.h> #include<string.h> #defineM20006 /*runthisprogramusingtheconsolepauseroraddyourowngetch,system("pause")orinputloop*/ chara[M],b[M],c[M]; intans[M]; intlen; intcread(charx){16进制转换为10进制 if(x>='A'){ returnx-'A'+10; } if(x>='0'&&x<='9'){ returnx-'0'; } } voidtodec(char*x){先将第一个字符串转换为十进制 for(inti=0;i<len;i+=2){ ans[i/2]=cread(x[i])*16+cread(x[i+1]); } } intmain(intargc,char*argv[]){ while(scanf("%s%s",a,b)!=EOF){ len=strlen(a); todec(a); intex=32,cnt=0; for(inti=0;i<len+2;i+=2){ intx=cread(b[i]),y=cread(b[i+1]); x=x*16+y; ex=ex^x; printf("%02X",ex); ex=ans[cnt++]^ex; } printf("\n"); } } 
第138篇文章[1]
由Cache引发的关于Malloc函数的思考 关于Malloc函数的一些理解 思考缘由 思考缘由 在计算机系统的实验6中，需要我们根据输入的要求去init一个Cache缓存器。代码如下：其中注释的内容是我后续为了理解mallo添加语句。这个init是这样子实现的：我们知道一个Cache中有多个组，每个组中又有多行缓存块。在我们这个init函数中，S是组的数量，E是行的数量。我们先mallocinitCache的组数，然后再对每一组malloc行数。用二维数组来理解的话就是我们先malloc行数，再malloc列数。这里就有一个问题，由于cache_set_t的大小根据要求是给定的：当我malloc组数之后，我们又如何能够对每一组去扩充他的行数？所以将cache中的信息都打印出来：我们发现Cache中的每一组都是连续的，161400,161408,161410。而每一组的每一行的地址是从164120开始，也就是说后续我们新扩增的Cache行是在后面增加的而不是我一开始想象中的类似矩阵一样连续的。 在写这个blog时，我忽然发现：Cache中的一维数组存的是一个指针，也就是这个指针指向了二维数组的位置，所以malloc才会是这样子的一个映射关系，而不像通常数组那样是连续的地址。 
第139篇文章[3]
hdu1066Lastnon-zeroDigitinN!详解 代码之路 hdu1066Lastnon-zeroDigitinN! 题目InputOutputSampleInputSampleOutput 思路AC代码 题目 题目链接：hdu1066 TheexpressionN!,readas“Nfactorial,”denotestheproductofthefirstNpositiveintegers,whereNisnonnegative.So,forexample,NN!011122364245120103628800Forthisproblem,youaretowriteaprogramthatcancomputethelastnon-zerodigitofthefactorialforN.Forexample,ifyourprogramisaskedtocomputethelastnonzerodigitof5!,yourprogramshouldproduce“2”because5!=120,and2isthelastnonzerodigitof120. Input Inputtotheprogramisaseriesofnonnegativeintegers,eachonitsownlinewithnootherletters,digitsorspaces.ForeachintegerN,youshouldreadthevalueandcomputethelastnonzerodigitofN!. Output Foreachintegerinput,theprogramshouldprintexactlyonelineofoutputcontainingthesinglelastnon-zerodigitofN!. SampleInput 122612531259999 SampleOutput 124828 思路 思路来源稍微对上面的内容补充些自己的理解。 首先考虑N！，显然N！=1*2*3*4*5*……*N；在这里先做一个处理，每次遇到5的倍数就先乘2再除二，这也就是上面链接所说的将5当做1的原因。这样处理的好处就是尾数在未除2时，会以10为周期方便计算。所以当N>10时候，只需要10个分一组，由于6*6=6，所以只需最后乘上6即可。而N有[N/5]个5的倍数，就需要除于[N/5]个2，于是有递归式子： F ( N ) = F [ N / 5 ] ∗ t a b l e [ N 的 尾 数 ] ∗ 6 2 [ N / 5 ] F(N)=\frac{F[N/5]*table[N的尾数]*6}{2^{[N/5]}} F(N)=2[N/5]F[N/5]∗table[N的尾数]∗6​ 而式子中的F(N/5)是什么意思呢？由于我们前面将5的倍数乘于2，然后将其当做1处理，实际上是将他们提取出来，有如下一个表格： 510152010203040 忽略末尾的0，显然就有1*2*3*4，其结果就是F(N/5)。而注意到2^1=2,2^2=4,2^3=8,2^4=16,2^5=32。以4为循环周期。于是将分母的N/5mod4即可。更正式子为如下： F ( N ) = F [ N / 5 ] ∗ t a b l e [ N 的 尾 数 ] ∗ 6 2 [ N / 5 ] M o d 4 F(N)=\frac{F[N/5]*table[N的尾数]*6}{2^{[N/5]Mod4}} F(N)=2[N/5]Mod4F[N/5]∗table[N的尾数]∗6​ 由于table以10为循环周期，2以4为循环周期，于是有 t a b l e [ N 的 尾 数 ] ∗ 6 2 [ N / 5 ] M o d 4 \frac{table[N的尾数]*6}{2^{[N/5]Mod4}} 2[N/5]Mod4table[N的尾数]∗6​以20为循环周期。 所以只需要打出上述的表格mod[20]={1,1,2,6,4,2,2,4,2,8,4,4,8,4,6,8,8,6,8,2}，去查找即可。由于本题的N较大，所以需要高精度计算。至此解释完毕。 AC代码 #include<stdio.h> #include<string.h> #defineMax10000000 intmod[20]={1,1,2,6,4,2,2,4,2,8,4,4,8,4,6,8,8,6,8,2}; charn[Max]; inta[Max]; intmain(){ inti,len,f,temp; while(~scanf("%s",&n)){ f=1; len=strlen(n); for(i=0;i<len;i++){ a[i]=n[len-1-i]-'0'; } while(len){ len-=!a[len-1]; f=f*mod[a[1]%2*10+a[0]]%10;//f为文中的F（N） for(temp=0,i=len-1;i>=0;i--){//把数除于5 temp=temp*10+a[i]; a[i]=temp/5; temp%=5; } } printf("%d\n",f); } } 
第140篇文章[3]
代码之路-Joseph‘sproblemI（Joseph问题） 1016-Joseph'sproblemI（Joseph问题） 题目ProblemDescriptionInputOutputSampleInputSampleOutput 思路AC代码 题目 ProblemDescription TheJoseph’sproblemisnotoriouslyknown.Forthosewhoarenotfamiliarwiththeproblem,amongnpeoplenumbered1,2…n,standingincircleeverymthisgoingtobeexecutedandonlythelifeofthelastremainingpersonwillbesaved.Josephwassmartenoughtochoosethepositionofthelastremainingperson,thussavinghislifetogivethemessageabouttheincident.AlthoughmanygoodprogrammershavebeensavedsinceJosephspreadoutthisinformation,Joseph’scousinintroducedanewvariantofthemalignantgame.Thisinsanecharacterisknownforitsbarbarianideasandwishestocleanuptheworldfromsillyprogrammers.WehadtoinfiltratesometheagentsoftheACMinordertoknowtheprocessinthisnewmortalgame.Inordertosaveyourselffromthisevilpractice,youmustdevelopatoolcapableofpredictingwhichpersonwillbesaved.TheDestructiveProcessThepersonsareeliminatedinaverypeculiarorder;misadynamicalvariable,whicheachtimetakesadifferentvaluecorrespondingtotheprimenumbers’succession(2,3,5,7…).Soinordertokilltheithperson,Joseph’scousincountsuptotheithprime. Input Itconsistsofseparatelinescontainingn[1…3501],andfinisheswitha0. Output Theoutputwillconsistinseparatelinescontainingthepositionofthepersonwhichlifewillbesaved. SampleInput 6 SampleOutput 4 思路 约瑟夫环指的是在n个人中，从第一个人开始数数，数到m时，第m个人就被淘汰，之后再继续从第m+1个人开始重新数数。求最后被留下来的人在初始n个人中排第几个。而本题m是变量。不过只要修改下求解方程即可。约瑟夫环可以从一开始开始求解，不过此时需要创立数组进行维护，由于维护非常麻烦，所以想到能否从最后一个开始去逆推。于是找到了如下的关系式 x’(第n轮的序号)=x(第n-1轮的序号)-(m(要数的个数)%people（第n-1轮的人数） 修改下为如下式子：x=(x’+m(第n-1轮要数的个数))%people AC代码 #include<stdio.h> #include<stdlib.h> #defineMax3502 /*runthisprogramusingtheconsolepauseroraddyourowngetch,system("pause")orinputloop*/ intprime[Max]; voidisprime(){ intcnt=0,i=3; prime[cnt++]=2; while(1){ intflag=0; for(intj=2;j<i;j++){ if(i%j==0){ flag=1; break; } } if(flag==0){ prime[cnt++]=i; } if(cnt>Max){ break; } i+=2; } } intmain(){ intn; isprime(); while(scanf("%d",&n),n){ intcut=n-2,ans=0,people=2; for(;cut>=0;cut--,people++){ intbox=prime[cut]; ans=(ans+box)%people; } printf("%d\n",ans+1); } return0; } 
第141篇文章[]
LSP原则学习笔记 LSP原则要求，子类要能替换父类型，从中总结出几点符合的条件要求： 子类的Spec要强于或等于父类。Spec强=前置条件更弱|（在对比双方中满足更强的前置条件下）后置条件更强。子类型的异常可以更具体，协变子类型的返回类型可以更具体，协变其实这点很好理解，比如父类的返回值原本为Animal，换回子类型之后，返回的是Cat，其中CatextendsAnimal，这在编译上是可以通过的。如果父类型是Cat，子类型返回Animal，那这就在编译上无法通过了子类型的参数类型可以更宽松，逆变同样从编译角度去考虑，假设父类型传入的是一个接口的参数，例如ArrayList<.L>，那么子类型改为List<.L>，原本传入父类型的参数仍然可以传入子类型的对象中，所以是满足的。如果反过来，父类型中是List<.L>，子类型是ArrayList<.L>，那么这在编译上就不能通过了，因为传入父类型的参数可以是LinkList，与ArrayList不同。 
第142篇文章[3]
代码之路 FastFood FastFood 题目思路代码 题目 ThefastfoodchainMcBurgerownsseveralrestaurantsalongahighway.Recently,theyhavedecidedtobuildseveraldepotsalongthehighway,eachonelocatedatarestaurantandsupplyingseveraloftherestaurantswiththeneededingredients.Naturally,thesedepotsshouldbeplacedsothattheaveragedistancebetweenarestaurantanditsassigneddepotisminimized.Youaretowriteaprogramthatcomputestheoptimalpositionsandassignmentsofthedepots. Tomakethismoreprecise,themanagementofMcBurgerhasissuedthefollowingspecification:Youwillbegiventhepositionsofnrestaurantsalongthehighwayasnintegersd1<d2<…<dn(thesearethedistancesmeasuredfromthecompany’sheadquarter,whichhappenstobeatthesamehighway).Furthermore,anumberk(k<=n)willbegiven,thenumberofdepotstobebuilt. Thekdepotswillbebuiltatthelocationsofkdifferentrestaurants.Eachrestaurantwillbeassignedtotheclosestdepot,fromwhichitwillthenreceiveitssupplies.Tominimizeshippingcosts,thetotaldistancesum,definedas mustbeassmallaspossible. Writeaprogramthatcomputesthepositionsofthekdepots,suchthatthetotaldistancesumisminimized. InputTheinputfilecontainsseveraldescriptionsoffastfoodchains.Eachdescriptionstartswithalinecontainingthetwointegersnandk.nandkwillsatisfy1<=n<=200,1<=k<=30,k<=n.Followingthiswillnlinescontainingoneintegereach,givingthepositionsdioftherestaurants,orderedincreasingly. Theinputfilewillendwithacasestartingwithn=k=0.Thiscaseshouldnotbeprocessed. OutputForeachchain,firstoutputthenumberofthechain.Thenoutputalinecontainingthetotaldistancesum. Outputablanklineaftereachtestcase. 思路 1.如果已知从第i个商店到第j个商店中有一个仓库，则这个仓库位于中间，也就是中位数（i+j）/2，原因如下：假设在5个商店中有一个仓库，则对于最远的2个商店，也就是第1个和第5个，无论仓库位于哪里，其路程和都是第1个仓库到第5个仓库的距离，此时可以不再讨论仓库对于这两个商店的影响，此时要讨论的商店仅剩3个，再依据上面的思路去讨论类似的问题，最后仅剩1个商店或2个商店，则仓库位于中位数处是距离和最小的。（反证即可）2.依据上面的思路进行动态规划。dp[i][j]代表前j个商店有i个仓库，找到动态转移方程： dp[i][j]=min(dp[i][j],dp[i-1][m]+cost[m+1][j]) 其中i-1<=m<=j-1,由于仓库数量确定为i-1，而商店数量未知，但可以确定他的取值范围。（第i-1个仓库在第i-1个商店）m=i-1,（第i个仓库在j处），则m=j-1。 代码 #include<stdio.h> #include<stdlib.h> #include<stdlib.h> #defineMax10000 /*runthisprogramusingtheconsolepauseroraddyourowngetch,system("pause")orinputloop*/ intdp[40][210]; intcost[210][210]; intdis[210]; intmin(intx,inty){ returnx>y?y:x; } intmain(intargc,char*argv[]){ intn,k,i,j,count=0; while(scanf("%d%d",&n,&k)==2&&n!=0&&k!=0){ count++; memset(dp,Max,sizeof(dp)); memset(cost,0,sizeof(cost)); memset(dis,0,sizeof(dis)); for(i=1;i<=n;i++){ scanf("%d",dis+i); } for(i=1;i<=n;i++){//计算从第i个餐厅到第j个餐厅只有一个仓库距离的求和 for(j=i;j<=n;j++){ for(intm=i;m<=j;m++){ cost[i][j]+=abs(dis[m]-dis[(i+j)/2]); } } } for(i=1;i<=n;i++){//街上只有一个商店，此时距离和为cost dp[1][i]=cost[1][i]; } for(i=2;i<=k;i++){//i代表街上的仓库数量 for(j=i;j<=n;j++){//j代表街上商店的数量，商店要大于等于仓库数量 for(intm=i-1;m<=j-1;m++){//状态转移方程，从i-1个仓库去推，由于商店数量未知，但知道其范围为i-1~j-1 dp[i][j]=min(dp[i][j],dp[i-1][m]+cost[m+1][j]); } } } printf("Chain%d\n",count); printf("Totaldistancesum=%d\n",dp[k][n]); printf("\n"); } } 
第143篇文章[]
软件构造期末复习内容9-12讲 程序复用性： 白盒：源代码可见可修改，通过代码层面的继承进行扩展 黑盒：源代码不可见，通过实现特定接口进行扩展 LSP：子类型可以增加方法，但不可删除 子类型必须实现所有抽象类未实现方法 子类型重写方法比如有相同类型返回值和参数列表 不能抛出额外异常 委派：一个对象请求另一个对象，也是复用的一种方式 可维护性： 纠错适应完善预防 耦合指不同方法之间的依赖 不应该有多于1个原因使你的ADT发生变化 设计模式：适配器 将某个类/接口转换成client期望的其他形式 装饰器 用子类实现不同特性 策略模式：用多种方法实现同一个任务，根据需要动态切换算法 模板模式：共性步骤一样，具体实现不同 迭代模式：无论容器为何，枚举方式一致 工厂模式：将实现交给子类，由子类决定实现什么。 运行时异常：由程序员处理不当导致 checked/unchecked如果能够补救，就checked，否则unchecked 
第144篇文章[]
软件构造期末复习内容4-8讲 数据类型： 类型检查： 静态检查：在编译阶段检查 动态检查：在运行时检查 Immutable:一旦确定其值或指向对象，无法再改变 （Final） 对于不可变类型，修改值实际上是修改了引用对象 拷贝时为确保安全，拷贝的是对象的一个复制 snapshot中，不可变类型用双线椭圆，不可变引用用双线箭头 设计规约spec 行为等价性：从客户端视角看是否等价 符合规约即等价 前置条件：对用户约束，后置条件：对开发者约束，前置条件满足则后置条件必须满足 规约强度：针对开发者的限制。 ADT操作的四种类型： 构造器：构造一个ADT 生产器，用当前内容产生一个新的对象 观察器：观察ADT中数据 变值器：改变对象属性的方法 表示独立性：使用ADT时无需考虑其内部实现 表示泄露：指用户可以使用我们提供方法以外的方法来修改ADT内部数据 RI：表示不变性，或看作某个表示是否合法 AF：某种具体表示对应抽象空间内容的映射 OOP：面向对象编程 接口Interface：定义ADT 一个接口可以有多个实现，一个类可以实现多个接口 接口用于确定规约 继承： 严格继承：子类只能使用父类的方法和自己的方法，不能修改 重写：子类可以重新实现父类的方法 重载：多个方法具有同样的名字，但有不同的参数列表和返回值 静态类型检查时根据参数列表匹配对应的方法 ADT等价：AF映射到同样结果即视为等价 ==对基本类型equals对对象类型 实现ADT时equals要重写 等价对象必须有相同的hashcode Mutable 观察等价：看起来是否一致 行为等价：对于相同行为，结果是否均一致 
第145篇文章[]
软件构造课程期末复习内容（1，3讲) 软件构造的多维度视图 按阶段划分：构造时/运行时 按动态性划分：时刻/阶段 按层次划分：代码/构件 软件构造的阶段划分： 构造阶段(Build-time):词汇，语义，语法，变化，静态链接 运行时阶段(Runtime): 内外部质量指标 外部： 正确性：按照预先规约的方式运行(最重要指标) 健壮性：针对异常情况的处理 可扩展性：是否可以容易地修改软件 可复用性：一次开发，多次使用 兼容性：不同软件之间相互可容易集成 性能 可移植：软件可方便地在不同环境之间移植 易用:容易操作，对用户友好 其他性质：及时，可验证，完整，可修复，经济等 内部： 代码可读，可理解，清晰，码量大小。 5个重要的质量指标 容易理解，便于开发，做好修改准备，面对bug是安全的，运行效率高。 软件配置管理SCM： 追踪控制软件变化 软件配置项：软件中发生变化的基本单元(如文件). 基线(Baseline)：软件变化过程中的稳定版本 版本：软件在某一特定时刻的标识，便于在多个开发者之间形成协作。 版本控制系统VCS 本地：仓库存储于本地 集中式：仓库有独立服务器 分布式：仓库存储于独立服务器和每个开发者的本地机器 git： 
第146篇文章[]
软件构造的一些个人体会2 在整个软件构造的课程中和学习Java的过程当中，学到了一些比较重要的知识点。对于一些知识点我理解的不是很透彻，觉得还是要进一步多学习一些。在这里稍微地总结一下之前学到的，理解起来对我来说比较困难的一些知识点吧。 关于Immutable和mutable 这个方面是在学习的时候让我感到比较难理解的。对于immutable：拥有方法可以修改自己的值或者引用，对于mutable：一旦被创建，始终指向同一个值或者引用。比如一个经常被举得例子，就是String和StringBuilder。 Strings="a";//开辟一个存储空间，里面存着字符a，s指向这块空间，记为space1 Stringt=s;//让t指向s所指向的空间即space1 s=s.concat("b");//把字符a和字符b连接，然后把“ab”放在一个新的存储空间，记为space2，最后让s指向这块空间 //我们可以看到，现在s和t所指向的是两块不同的空间，空间中的内容也不一样，因此s和t的效果是不一样的 StringBuildersb=newStringBuilder("a");//开辟一个存储空间，里面存着字符a StringBuildertb=sb;//开辟一个存储空间，里面存着字符a sb.append("b");//取出a，然后与字符b连接，然后把“ab”仍然放在这块空间内，把原来的“a”覆盖了，sb的指向没变 //在这个情况下，由于从始至终只用到了一块存储空间，所以sb和tb的效果实际上是相同的 mutable和immediate各有各的好处吧，不过为了避免一些错误，保证程序的正确性，多考虑使用mutable。 spec结构和强度 这个是课程的一个很重要的部分，实验和上课的时候经常强调。对于spec：前置条件：对客户端的约束，在使用方法时必须满足的条件；@paramannotation：说明每个参数的前置条件；后置条件：对开发者的约束，方法结束时必须满足的条件；@returnannotation：说明后置条件；@throwsannotation：说明出现异常的时候会发生什么。对于spec的强度，一般来说，使得spec变强的要求是更宽松的前置条件，加上更严格的后置条件。同时要注意，spec不可以暴露实现细节，不可以暴露局部变量，也不可以暴露私有的数据域。 关于等价性 不可变类型的等价性判断等价的两个方式：AF映射到同样的结果，则等价。站在外部观察者角度：对两个对象调用任何相同的操作，都会得到相同的结果，则认为这两个对象是等价的。两个等价的对象调用相同的Observer应该返回相同的结果。==：引用等价性equals()：对象等价性可变数据类型的等价性观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致。调用Observer方法表现出相同的结果。约等于对象等价性。行为等价性：约等于引用等价性。调用对象的任何方法都展示出一致的结果。包括mutator、producer、observer。 其他部分 其他的很多知识点也是很重要的，比如继承，委派，逆变，协变，LSP等部分，在这里就不具体的展开了，毕竟我自己觉得我的理解还是有待提升的。 
第147篇文章[]
软件构造的一些个人体会1 大二下学期的后半学期，学校开了软件构造这一门课。到不久之前结课为止，也是上了大半学期了，所以就在期末之前稍微提一下在这们课上学到的一些东西和自己的一些个人体会吧。 1.Git和GitHub在课程中的使用 在大一的时候就已经听过学长在讲座上介绍过Git以及GitHub，但是当时没有系统的学习过，就一直对这个东西是半懂不懂的状态。在软构这门课上，专门学习了版本控制系统VCS，同时实验课要求使用Git上传代码到GitHub上，所以自己查了一些资料，算是有了一些基本的了解了。在软件构造实验的时候使用到的git命令不多，主要是以下这一些：创建：gitinit暂存：gitadd.链接：gitremoteaddorigin提交：gitcommit-m“commitmessage”推送：gitpush-uoriginmaster在实验三还涉及到一些分支的命令。 2.对于测试的一些想法 软件构造课程上，老师十分强调测试用例的重要性，实验的要求里面也是十分的重视写测试代码。这里跟之前接触到的编程课还是有些不同的。之前的课程，比如大一的程序设计基础，还有上学期的数据结构和这学期的计算机系统，主要是使用的C语言，写代码的时候也没有特意去强调测试用例和debug等方面。不过在这一门课程里，不同的就是真的很重视测试代码。虽然我在写实验的过程中对写测试代码不是很熟练，有时候会有抵触的情绪，但是客观的说，测试用例能帮助我们节约很多的调试时间。以及，通过测试衍生出来的代码覆盖度问题，选取测试用例的问题，我认为都是很有帮助的。 3.spec和代码注释 之前的编程课强调实现的过程，更多的是自己和自己之间的一种行为，因此我在写代码，对于注释总是觉得能省则省，能够满足基本的看得懂就行。而现在在软件构造这门课上，更多的是强调了面向对象的思想，这时候写spec和代码的注释等就很重要了，不过在这方面我觉得我的意识还是不够。课程里面也是有挺多的地方涉及到这一方面的东西。好的spec好像⼀道防火墙⼀样将客户和实现者隔离开，它使得客户不必知道这个单元是如何运行的，也使得实现者不必管这个单元会被怎么使用。 4.课程的一些想法 这一门课最主要的内容就是介绍ADT和OOP的部分，还有一些复用性和可维护性的知识点，最后又讲了一些面向健壮性与正确性的内容。由于课时的压缩，整体的课程压力还是很大的。个人感觉难理解的主要是ADT以及OOP，可能是因为之前没学过Java，在大一的夏季学期学习的C++也忘了挺多内容的。再加上课程的课时紧张，要求我们自学Java，这就导致了在某一些方面学的不精的问题了。课程的内容比较多，全部面面俱到是很难的，我自己能力也不足。在后面的博客我想要讲一些我自己觉得比较重要的部分吧。 
第148篇文章[]
Java泛型的类型擦除 为什么Java的泛型要使用类型擦除？ 从技术来说，Java完全可以不使用类型擦除而直接实现”真泛型”。然而，Java诞生的时候，是没有包括泛型的，10年之后，Java才想实现类似于C++模板的概念，即泛型。由于Java类库是非常宝贵的资源，因此必须保证向后兼容。如果要实现“真泛型”，不仅需要修改JVM的源代码，让JVM能正确读取和校验泛型信息；而且为了兼容，需要为原本不支持泛型的API都添加相应的泛型API。这样的修改工作量是无法想象的。因此Java设计者采取了“类型擦除”这种机制作为折中的实现方式。 什么是类型擦除？ 在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉，这个过程就称为类型擦除。 我们以一个例子来验证Java的类型擦除机制。对于下面的代码，最后输出的结果为true。 ArrayList<Integer>intergerList=newArrayList<Integer>(); ArrayList<String>stringList=newArrayList<String>(); System.out.println(intergerList.getClass()==stringList.getClass());//true 我们定义的两个列表，一个是String泛型，一个是Integer泛型，但是它们的getClass()方法得到的类信息居然是一样的。这说明泛型类型String和Integer在运行之前就被擦除掉了，在运行时无法知道定义时的具体类型。 在类型擦除后的实际类型是什么呢？根据上面所说的向后兼容，擦除后的实际类型应该能被之前没有泛型时的Java程序接受。因此Java将具体的类型擦除为原始类型。原始类型就是擦除泛型信息，最后在字节码中的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供。类型变量擦除时，使用其限定类型替换（无限定时用Object替换）。 举例来说，如果我们定义下面这样一个带泛型的类： publicclassNode<T>{ privateTdata; privateNode<T>next; publicNode(Tdata,Node<T>next){ this.data=data; this.next=next; } publicTgetData(){ returndata; } //  } 那类型擦除后，它的实际定义应该类似于： publicclassNode{ privateObjectdata; privateNodenext; publicNode(Objectdata,Nodenext){ this.data=data; this.next=next; } publicObjectgetData(){ returndata; } //  } 所有的泛型T都被替换为Object。 类型擦除带来的问题 1.运行时的类型检测问题：由于类型变量会在运行前被擦除掉，那如何检测到向ArrayList<String>中添加非String类型的对象这种类型错误呢？ 解决方法：利用编译器进行静态检查。编译器会先检查代码中的泛型类型，如果存在类型不匹配，会直接报错，只有在类型匹配时才能进行后续的类型擦除。比如： List<Integer>myInts=newArrayList<Integer>(); myInts.add(1); myInts.add(2); List<Number>myNums=myInts;//compilererror myNums.add(3.14); staticlongsum(List<Number>numbers){ longsummation=0; for(Numbernumber:numbers){ summation+=number.longValue(); } returnsummation; } List<Integer>myInts=Arrays.asList(1,2,3,4,5); List<Long>myLongs=Arrays.asList(1L,2L,3L,4L,5L); List<Double>myDoubles=Arrays.asList(1.0,2.0,3.0,4.0,5.0); sum(myInts); sum(myLongs);//compilererror sum(myDoubles); 2.返回泛型类型的函数怎么办？所有的泛型类型都会被替换为原始类型，那返回泛型类型的函数实际上返回的是原始类型的对象，难道还需要手动的类型转化吗？ 解决方法：自动生成类型转换。ArrayList的get方法源代码如下： publicEget(intindex){ RangeCheck(index); return(E)elementData[index]; } 在return之前，会根据泛型的类型进行强转。即使泛型信息会被擦除，但是会将(E)elementData[index]编译为(Date)elementData[index]。因此不需要自己手动进行强转，在类型擦除时会自动地在结果字节码中插入强制类型转换。 3.不能使用泛型数组。如果我们假设在Java中可以创建泛型数组，那么看如下代码： List<String>[]s=newArrayList<String>[1]; List<Integer>i=Arrays.asList(1); Object[]o=s; o[0]=i Java的类型系统规定，子类数组是父类数组的子类，因此Object[]o=s;是正确的。如果我们假设可以创建泛型数组，那上述代码没有任何问题。但是最后一行代码将List<Integer>类型的对象赋给了List<String>类型的数组，这个问题在编译时无法发现，只能在运行时出现问题。然而，类型擦除机制要求编译器能够检测所有类型不匹配的问题。因此Java中禁止创建泛型数组，这样编译器就可以检测所有的类型不匹配问题。 
第149篇文章[]
2021哈工大软件构造Lab3 2021年春季学期计算学部《软件构造》课程 Lab3实验报告 目录 1实验目标概述···1 2实验环境配置···1 3实验过程···1 3.1待开发的三个应用场景···1 3.2面向可复用性和可维护性的设计：IntervalSet<L>·2 3.2.1IntervalSet<L>的共性操作···2 3.2.2局部共性特征的设计方案···3 3.2.3面向各应用的IntervalSet子类型设计（个性化特征的设计方案）···4 3.3面向可复用性和可维护性的设计：MultiIntervalSet<L>·7 3.3.1MultiIntervalSet<L>的共性操作···7 3.3.2局部共性特征的设计方案···7 3.3.3面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）···9 3.4面向复用的设计：L·11 3.5可复用API设计···13 3.5.1计算相似度···13 3.5.2计算时间冲突比例···14 3.5.3计算空闲时间比例···15 3.6应用设计与开发···15 3.6.1排班管理系统···15 3.6.2操作系统的进程调度管理系统···17 3.6.3课表管理系统···18 3.7基于语法的数据读入···18 3.8应对面临的新变化···20 3.8.1变化1·20 3.8.2变化2·21 3.9Git仓库结构···21 4实验进度记录···22 5实验过程中遇到的困难与解决途径···23 6实验过程中收获的经验、教训、感想···24 6.1实验过程中收获的经验和教训···24 6.2针对以下方面的感受···24 实验目标概述 本次实验覆盖课程第2、3章的内容，目标是编写具有可复用性和可维护性的软件，主要使用以下软件构造技术： 子类型、泛型、多态、重写、重载继承、代理、组合语法驱动的编程、正则表达式API设计、API复用 本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过ADT和泛型等抽象技术，开发一套可复用的ADT及其实现，充分考虑这些应用之间的相似性和差异性，使ADT有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。 实验环境配置 Eclipse和Git在上一次实验中已经配置好了。本次实验无需额外配置环境。 在这里给出你的GitHubLab3仓库的URL地址（Lab3-学号）。 https://github.com/ComputerScienceHIT/HIT-Lab3-1190200817 实验过程 请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。 待开发的三个应用场景 简要介绍三个应用： ①值班表管理，一个单位有n个员工，在某个时间段内安排值班。每天只能安排一个员工且不能出现无人值班的情况；每个员工需要安排在连续的几天内。值班表内需要记录员工的名字、职位、手机号码，以便于外界联系值班员。 ②操作系统进程调度管理，进程被调度在CPU上执行，操作系统决定在各个时段内执行哪个进程。操作系统可挂起某个正在执行的进程，在后续时刻可以恢复执行被挂起的进程。每个时间只能有一个进程在执行，其他进程处于休眠状态；一个进程的执行被分为多个时间段；在特定时刻，CPU可以“闲置”；调度无规律，可看作是随机调度。 ③大学课表管理：课程需要特定的教室和特定的教师。假设各周的课表都是完全一样的，同样的课程安排将以“周”为单位进行周期性的重复，直到学期结束；一门课程每周可以出现1次，也可以安排多次，且由同一位教师承担并在同样的教室进行；允许课表中有空白时间段；同一个时间段内可以安排不同的课程；一位教师也可以承担课表中的多门课程。 相同之处：都包含了具有不同特征的“时间段集合”对象。每个时间段对应一个对象标签。 不同之处：有三个维度上的差异。①是否允许时间轴上有空白。在应用1中，不允许有空白；在应用2和应用3中，允许有空白。②是否允许不同的interval之间有重叠。在应用1和应用2中，不允许有重叠；在应用3中，允许有重叠。③是否包含周期性的时间段。应用3中以“一周”为单位重复某个课程，但应用1和应用2中不存在这种情况。 面向可复用性和可维护性的设计：IntervalSet<L> 该节是本实验的核心部分。 IntervalSet<L>的共性操作 这个ADT描述了一组在时间轴上分布的“时间段”，每个时间段附着一个特定的标签，且标签不重复。因此共性的方法包括： 静态工厂方法empty()：创建一个空对象。voidinsert(longstart,longend,Llabel)：在当前对象中插入新的时间段和标签。Set<L>labels()：获得当前对象中的标签集合。booleanremove(Llabel)：从当前对象中移除某个标签所关联的时间段。longstart(Llabel)：返回某个标签对应的时间段的开始时间。longend(Llabel)：返回某个标签对应的时间段的结束时间。IntervalSet<L>copy()：返回这个对象的副本。 局部共性特征的设计方案 由于IntervalSet是一对一的结构，即一个标签对应一个时间段，因此可以使用Map作为内部的数据结构，定义为： privatefinalMap<L,time>intervalMap=newHashMap<>(); 由于时间段是两个long型的整数构成的，因此可以定义一个辅助类time表示一个时间段。其中start是时间段的开始，end是时间段的结束，同时要求start一定大于0且start一定比end小。这里time实现了Comparable接口是为了满足下面MultiIntervalSet中的一些功能。 对于empty()方法，直接返回一个具体实现类。 对于insert()方法，首先判断非法条件（start<0和start>=end），然后判断Map中是否包含标签，若包含该标签，那只有在重复设置相同时间段时才合法，否则会抛出IntervalConflictException；若不包含该标签，就直接插入时间段。（注意，这里是允许不同标签之间存在Overlap的） 对于labels()方法，直接返回Map中所有的键构成的集合即可。 对于remove()方法，判断Map的键中是否存在该标签，若不存在，直接返回false；若存在，就在Map中删除该标签，并返回true。 对于start()方法，判断Map的键中是否存在该标签，若不存在，直接返回-1，否则可以得到标签对应的时间段time，调用time的getStart()方法就可以得到时间段的开始时间并返回。 对于end()方法，同上，但要调用time的getEnd()方法得到时间段的结束时间并返回。 对于copy()方法，先新建一个空白的IntervalSet副本，然后遍历Map。将遍历得到的所有时间段和标签通过insert()方法插入到新的副本中，最后返回该副本。 此外，还需要重写toString方法提供容易阅读的信息。 面向各应用的IntervalSet子类型设计（个性化特征的设计方案） 一、使用decorator装饰器的方法进行是否允许不同的interval之间有重叠以及周期性的维度的个性特征的设计。向装饰器中传入待装饰的IntervalSet，并在继承该装饰器的具体子类中实现相应的个性化功能。如下图，在装饰器IntervalSetDecorator中有属性intervalSet，是一个待装饰的IntervalSet类，而IntervalSetDecorator中的所有方法都调用intervalSet的相应方法。 ①不允许重叠的IntervalSet实现如下： 首先NoOverlapIntervalSet继承装饰器IntervalSetDecorator，并实现IntervalSet接口。在NoOverlapIntervalSet中添加一个属性intervalMap记录添加的所有时间段。 在重写的insert()方法中，首先判断新添加的时间段是否与已添加的时间段发生重叠，如果有，直接抛出异常；否则就调用未重写的父类的insert()方法进行插入。 ②周期性的IntervalSet实现如下： 首先PeriodicIntervalSet继承装饰器IntervalSetDecorator，并实现IntervalSet接口。在PeriodicIntervalSet中添加一个属性period记录时间周期。 在重写的insert()方法中，将开始时间和结束时间对周期取模后再调用未重写的父类的insert()方法进行插入。 二、使用代理的方式进行是否允许时间轴上有空白这个维度的个性特征的设计。由于不允许空白相当于添加了新的方法，因此将这个特性抽象为一个接口NoBlankIntervalSet： 接口中包含三个方法：blankIntervals()返回所有的空白时间段集合；getStart-Time()返回总的开始时间；getEndTime()返回总的结束时间。 一个具体的不允许时间轴上有空白的IntervalSet只需要实现NoBlank-IntervalSet接口。具体实现类CommonNoBlankIntervalSet的实现如下： 属性startTime是总的开始时间，endTime是总的结束时间。blankIntervals()的实现如图，首先将空白时间段设置为整个时间段，然后遍历所有的时间段，将这些时间段从空白时间段中去除，最后得到的就是所有的空白时间段。 面向可复用性和可维护性的设计：MultiIntervalSet<L> MultiIntervalSet<L>的共性操作静态工厂方法empty()：创建一个空对象。MultiIntervalSet(IntervalSet<L>initial)：利用initial中包含的数据创建非空对象。voidinsert(longstart,longend,Llabel)：在当前对象中插入新的时间段和标签。Set<L>labels()：获得当前对象中的标签集合。booleanremove(Llabel)：从当前对象中移除某个标签所关联的所有时间段。IntervalSet<Integer>intervals(Llabel)：从当前对象中获取与某个标签所关联的所有时间段。 局部共性特征的设计方案 由于要求必须使用IntervalSet<L>作为其rep的一部分，因此选择IntervalSet<L>组成的List作为rep。一个IntervalSet中只存储某个标签对应的一个时间段，如果一个标签对应多个时间段，需要分散在不同的IntervalSet中。 对于empty()方法，直接返回一个具体实现类。 对于initial初始化方法，直接将传入的IntervalSet的副本作为rep的一个元素。 对于insert()方法，首先判断非法情况。之后遍历IntervalSet列表得到标签对应的所有时间段，判断已存在的时间段和要增加的时间段是否存在重叠，如果重叠则抛出异常；若不重叠，就寻找某个不存在该标签的IntervalSet，将这个时间段插入该IntervalSet，如果列表中所有的IntervalSet都包含该标签，就需要新建一个空白的IntervaSet加入列表，再进行插入。 对于labels()方法，可以直接返回第一个IntervalSet中的所有标签组成的集合。（因为插入时都是从头开始遍历的，因此不会存在某个标签出现在后面的IntervalSet而不在第一个IntervalSet中的情况） 对于remove()方法，直接对每个IntervalSet调用remove()方法即可。 对于intervals()方法，遍历IntervalSet列表得到标签对应的所有时间段，将时间段从小到大进行排序（前面time的实现中进行了说明）。然后将每个时间段以它的顺序作为标签插入到一个IntervalSet中并返回。 此外，还需要重写toString方法提供容易阅读的信息。 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案） 与3.2.3同理，使用decorator装饰器的方法进行是否允许不同的interval之间有重叠以及周期性的维度的个性特征的设计。向装饰器中传入待装饰的MultiIntervalSet，并在继承该装饰器的具体子类中实现相应的个性化功能。如下图，在装饰器MultiIntervalSetDecorator中有属性multiIntervalSet，是一个待装饰的MultiIntervalSet类，而MultiIntervalSetDecorator中的所有方法都调用multiIntervalSet的相应方法。 ①不允许重叠的MultiIntervalSet实现如下： 首先NoOverlapMultiIntervalSet继承装饰器MultiIntervalSetDecorator，并实现MultiIntervalSet接口。 在重写的insert()方法中，首先判断新添加的时间段是否与已添加的时间段发生重叠，如果有，直接抛出异常；否则就调用未重写的父类的insert()方法进行插入。 ②周期性的MultiIntervalSet实现如下： 首先PeriodicMultiIntervalSet继承装饰器MultiIntervalSetDecorator，并实现MultiIntervalSet接口。在PeriodicMultiIntervalSet中添加一个属性period记录时间周期。 在重写的insert()方法中，将开始时间和结束时间对周期取模后再调用未重写的父类的insert()方法进行插入。 面向复用的设计：L 设计三个应用的不同标签，分别为“员工”（Employee）、“进程”（Process）、 “课程”（Course）。并且它们都是immutable类。 ①对于Employee，具有的属性为：姓名、职务、手机号码。 除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：只有三个属性均相同时才认为是相同的。 ②对于Course，具有的属性为：课程ID、课程名称、教师名字、地点。 除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：只有四个属性均相同时才认为是相同的。 此外，Course类实现了Comparable接口，这是为了APP中显示课程顺序的合理性。 ③对于Process，具有的属性为：进程ID、进程名称、最短执行时间、最长执行时间。 除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：进程ID相同时认为是相同的。 可复用API设计 计算相似度 对于两个MultiIntervalSet：s1和s2，遍历s1中的标签，查看s2中是否存在相同的标签，如果不存在，则对相似度没有贡献；如果存在，那么这个标签在s1和s2中各有一个时间段的集合，计算这两个时间段集合的重合长度，将所有的重合长度加在一起除以MultiIntervalSet的时间跨度就是两个MultiIntervalSet的相似度。 计算时间冲突比例 对于IntervalSet来说，由于它是一个特殊的MultiIntervalSet，因此可以把它转换成MultiIntervalSet后再调用针对MultiIntervalSet的计算时间冲突比例的函数。 对于MultiIntervalSet，维护一个冲突时间段的集合conflictTime，初始时为空。遍历set中的标签，判断该标签和其他标签的时间段是否存在重合，如果存在，就将冲突的时间段加入conflictTime。向conflictTime加入时间段也需要考虑重合的问题，集合中不能有重合的时间段，因此向conflictTime加入时间段时需要进行适当的合并。最后conflictTime中的时间长度除以总的时间跨度就是时间冲突比例。 计算空闲时间比例 对于IntervalSet来说，由于它是一个特殊的MultiIntervalSet，因此可以把它转换成MultiIntervalSet后再调用针对MultiIntervalSet的计算空闲时间比例的函数。 对于MultiIntervalSet，原理类似于3.2.3中的blankIntervals()方法。维护一个空闲时间段的集合freeTime，初始时为整个时间段。遍历set中的所有时间段，并将其从freeTime中删去。最后freeTime中的时间长度除以总的时间跨度就是空闲比例。 应用设计与开发 利用上述设计和实现的ADT，实现手册里要求的各项功能。 排班管理系统 使用DutyIntervalSet作为数据结构，同时维护一个Employee的集合可以存储未被安排的员工。刚进入时APP，会提示初始化一些信息，包括：排班开始日期、结束日期以及一组员工信息。初始化结束后，打印一个菜单，告诉用户提供的一些功能。 根据用户选择的功能采取相应的操作。其中选项1,2涉及对Employee集合的增删；3对应DutyIntervalSet的insert操作；4对应DutyIntervalSet的remove操作；5对应DutyIntervalSet的blankIntervals操作；7对应DutyIntervalSet的blankIntervals操作以及DutyIntervalSet的labels、start、end操作；8的操作见3.7节。由于这些操作都是简单地使用一些函数，因此不再详细叙述。这里只介绍“6：自动编排”的实现方法：首先调用DutyIntervalSet的blankIntervals操作得到未被安排的时间段，然后遍历Employee集合，找出未被安排的员工，将这些未被安排的时间段和员工一对一匹配起来，并调用insert方法插入到DutyIntervalSet中。 此外，APP还拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。举例来说，针对添加员工的操作，存在各种非法的输入情况，在APP中都得到了相应的解决，并提示给用户。 操作系统的进程调度管理系统 使用ProcessIntervalSet作为数据结构，同时维护一个的Map存储进程和已执行时间的映射关系。进入APP后，会打印一个菜单，告诉用户提供的一些功能。 根据用户选择的功能采取相应的操作。其中选项1,2涉及对Map的增删；5，6对应ProcessIntervalSet的intervals操作。由于这些操作都是简单地使用一些函数，因此不再详细叙述。这里介绍3,4的实现方法，选项3：从时间点0开始进入一个循环，当所有的进程都被执行完成后退出循环。在循环中，首先使用随机数（random.nextBoolean）决定是否调度进程，如果决定不调度进程，则闲置一段随机的时间（random.nextInt）；如果决定调度进程，则随机选择一个未完成的进程（使用随机数选择进程的序号）并执行一段随机的时间（random.nextInt），执行结束后，如果该进程的总执行时间已经落到最短执行时间和最长执行时间的区间内，则该进程被执行完成，然后从这个时间点开始进行下一轮的循环。选项4：和选项3唯一的不同在于进程的选择不是随机的，而是选择距离其最大执行时间差距最小的进程。 同样地，APP拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。 课表管理系统 使用CourseIntervalSet作为数据结构，同时维护一个Course的Map存储未被安排的课程以及对应的剩余学时数。刚进入时APP，会提示初始化一些信息，包括：学期开始日期、总周数、以及一组课程信息。初始化结束后，打印一个菜单，告诉用户提供的一些功能。 根据用户选择的功能采取相应的操作。其中选项1,2涉及对Course映射的增删；3对应CourseIntervalSet的insert操作；4对应CourseIntervalSet的remove操作；5对应对Course映射的遍历以及显示；6,7对应API中操作的使用；8对应CourseIntervalSet的intervals操作。由于这些操作都是简单地使用一些函数，因此不再详细叙述。 同样地，APP拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。 基于语法的数据读入 首先对文件的格式进行分析，文件总共包括三个部分，分别是Employee、Period和Roster，每个部分有自己独特的格式。在假设没有空格、缩进和空行的情况下，可以分别设计识别每个部分的正则表达式。 Employee部分的正则表达式： Period部分的正则表达式： Roster部分的正则表达式： 对于整个文件，由于三个部分出现的顺序是不定的，即共有六种情况，因此识别整个文件的正则表达式为： 首先利用这个正则表达式判断文件的格式是否正确，如果正确就抽取出每个部分。 利用Employee内部的格式抽取出员工信息： 利用Period的格式抽取出时间段信息： 利用Roster内部的格式抽取出排班信息： 根据抽取出的信息，就可以构造出一个排班表了，在构造的同时判断一些错误，如：员工信息重复、员工未定义、时间重叠等。 在APP中，读入用户指定的文件，并去除所有的空格、缩进、空行，之后调用Parser解析信息，在出现错误时提示给用户相应错误信息。 应对面临的新变化 变化1 修改之前的DutyIntervalSet实现的是IntervalSet接口，但是本次变化要求每个标签可以对应多个时间段，因此要求DutyIntervalSet实现MulitIntervalSet接口，同时还要保持不允许重叠的特征。因此只需要修改DutyIntervalSet继承的装饰器类型以及实现的接口类型即可。具体修改如图： 修改前的代码： 修改后的代码： 由于DutyIntervalSet从实现IntervalSet接口变为实现MulitIntervalSet接口，因此一些方法会发生变化，例如不再支持start()和end()方法，同时新增加了intervals()方法。因此，在DutyRosterApp需要修改相应的实现方法。举例来说，对于APP中的可视化排班信息的功能，需要遍历DutyIntervalSet中的信息，之前的遍历方式直接使用labels()方法： 但是，修改之后需要使用intervals()方法： 在其他地方也涉及这种变化，就不一一列举了。同时，需要修改测试代码保持测试的正确性。 除修改测试代码的变化，一共修改大约50行代码，花费时间较短，说明之前的设计较为合理，应对变化的能力比较强，可维护性很好。测试代码的修改大约也在50行左右。 变化2 由于使用了装饰器，只需要将原来传入装饰器的MultiIntervalSet改为不能重叠的NonOverlapMultiIntervalSet即可。如果不考虑测试代码的话，真正修改的代码只有一行！说明之前的设计较为合理，应对变化的能力比较强，可维护性很好。具体修改如图： 修改前的代码（传入可重叠的MultiIntervalSet）： 修改后的代码（传入不可重叠的NoOverlapMultiIntervalSet）： 为了使得测试仍然保持正确，需要修改原来的测试代码，总共修改的代码量大约为50行，花费时间较短。 Git仓库结构 请在完成全部实验要求之后，利用Gitlog指令或Git图形化客户端或GitHub上项目仓库的Insight页面，给出你的仓库到目前为止的ObjectGraph，尤其是区分清楚change分支和master分支所指向的位置。 使用gitlog指令，得到如下结果： 可以看出，Git仓库到目前为止的ObjectGraph有如下形式： 实验进度记录 请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。 每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。 不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。 日期时间段计划任务实际完成情况2021.6.2812:30-14:30设计IntervalSet接口并完成一个具体的实现类CommonIntervalSet，编写测试完成2021.6.2814:30-17:00设计MultiIntervalSet接口并完成具体的实现类CommonMultiIntervalSet，编写测试完成2021.6.2817:30-18:30设计IntervalSet和Common-MultiIntervalSet的装饰器完成2021.6.2818:30-19:30在有无空白的维度上，设计NoBlankIntervalSet接口并完成具体实现类CommonNoBlankIntervalSet，编写测试完成2021.6.2819:30-21:00在是否允许重叠的维度上，设计实现不允许重叠的装饰类NoOverlapIntervalSet和NoOverlap-MultiIntervalSet，编写测试完成2021.6.2821:30-22:30在周期性的维度上，设计实现周期性的装饰类PeriodicIntervalSet和PeriodicMultiIntervalSet，编写测试完成2021.6.299:00-10:00实现Employee、Process、Course类，编写测试完成2021.6.2910:00-12:30设计实现API，编写测试完成2021.6.2913:30-14:00实现DutyIntervalSet、Process-IntervalSet和CourseIntervalSet，编写测试完成2021.6.2914:00-17:30实现DutyRosterApp测试健壮性时发现很多不足，延期一小时完成2021.6.2919:00-22:00实现CourseScheduleApp测试健壮性时发现很多不足，延期半小时完成2021.6.309:00-12:00实现ProcessScheduleApp完成2021.6.3016:30-17:30学习正则表达式完成2021.6.3018:30-20:30设计实现解析器Parser，编写测试由于对正则表达式不太熟悉，延期半小时完成2021.6.3021:00-22:30向DutyRosterApp中加入解析文件功能完成2021.7.19:00-10:00完善整个项目的注释（spec、AF、RI、safefromexposure、teststrategy）完成2021.7.110:30-11:30修改代码以面对新的变化完成 实验过程中遇到的困难与解决途径 遇到的难点解决途径对装饰器不够熟悉，不知如何编写正确的装饰器以实现功能。在网上查看其它应用使用装饰器的方法并加以总结，逐渐熟悉装饰器的使用。编写APP时遇到很多的健壮性问题。仔细分析每个步骤中用户可能的所有输入，针对任何非法情况都作出提示。虽然很耗费时间，但效果很好。不知如何设计正则表达式来抽取大量的文件信息。在学习正则表达式语法的同时进行一些小的测试，从小的正则表达式开始，逐渐累积成复杂的正则表达式，最终实现对文件的解析。 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 设计ADT时一定要考虑得全面且清楚，在最终决定实现方案后再编写代码，否则在后面的应用实现中发现问题时只能再重新设计。同时，在编写APP时，一定要事先考虑健壮性的问题，不然，在编写完代码之后进行测试时会遇到很多的健壮性问题，这时再去修改就会使得代码很臃肿，可读性变差，出错的可能性更高。 针对以下方面的感受重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用，你是否体会到复用的好处？ 面向ADT的编程需要从实际中进行抽象，并进行合理的设计，有很好的可扩展性和可复用性；而直接面向应用场景编程只针对特定应用，每次更换应用场景时都要重新编程，扩展性很差，只适合简单的应用场景。本实验中设计一个ADT就可以应用到三个不同的场景，大大缩短了开发时间。 重新思考Lab2中的问题：为ADT撰写复杂的specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？ 这些工作使得客户端了解各方法的功能但无法得知内部具体实现，可以防止内部变量被客户端恶意修改，时刻检查表示不变量，保证安全性。虽然这些工作有些麻烦，但却是好的软件必须具备的，因此我愿意在以后编程中坚持这么做。同时，在复杂的软件开发过程中，好的注释可以节省大量阅读代码的时间，使得开发时间大大降低。 之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？ 由于API面向的场景是广泛的，因此开发难度很大，但是一旦开发一个好的API，就可以在大量场合中应用，大大提高代码的复用性。 你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？ 语法驱动编程为实际应用提供了很大的便利，用户无需繁琐地一行一行地输入信息，而只需提供一个文件以及一定的语法规则即可。而对于应用的开发者，只需根据语法规则编写代码，即使改变语法规则也可以很快地修改实现代码，有很好的可维护性。 Lab1和Lab2的大部分工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过五周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？ ADT的难度主要体现在抽象上。一个好的ADT既不能过于具体，也不能过于抽象。需要从大量应用场景中寻找共性，抽象的程度也很难把握。对于这种情况，只能反复的推敲，比较不同设计方案的差异并选择最好的ADT设计方案。 “抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的五个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？ 接口、抽象类、类的抽象程度一定是逐渐降低的，将所有应用的共性抽象为接口，然后在抽象类以及类中添加新的特性。通过接口的组合可以形成新的接口，并可以具备不同接口中的抽象。类的继承也可以增加更具体的新的特性。同时，使用正确的设计模式可以使得代码的可复用性和可维护性最大化。 关于本实验的工作量、难度、deadline。 难度适中，可以接受，但是工作量很大，尤其是APP的编写要花费很长时间。虽然给了三周时间，但是和其他课的实验、大作业、考试有重叠，总体上时间还是很紧。希望各课程的老师可以相互协调一下实验安排。 到目前为止你对《软件构造》课程的评价。 逐渐理解了软件构造过程中独有的思路和方法，也逐渐适应了与之前完全不同的编程过程。通过Lab3大量的代码训练，自己的编程水平也有了极大的提高。 
第150篇文章[]
Integer的自动装箱与比较问题 问题引入 Java使用==进行引用的比较，使用equals进行对象的比较。在多数情况下，都是使用==比较基本数据类型，而使用equals比较对象类型。但Java又为每个基本数据类型建立了相应的包装类，这使得相等的比较稍微复杂了一些，其中涉及自动装箱与拆箱的问题。同时，Integer的缓存机制使得比较情况更加复杂。因此，在这里分析一下Integer的自动装箱与比较问题。 自动装箱 自动拆箱和自动装箱是java的语法糖之一，执行在编译期，会根据代码的语法决定是否进行拆箱和装箱动作。自动装箱使得定义基本数据类型的包装类时，可以直接使用=赋值，而不使用new，如： Integera=5; 在编译时，会根据这种语法，决定进行装箱操作，实际上执行的语句调用了Interger的静态方法： Integera=Integer.valueOf(128); 在任何时候，如果涉及到从基本数据类型到其包装类的转换，编译器都会决定进行自动装箱。比如： Map<String,Integer>map=newHashMap<>(); map.put("a",1); 由于map中值的类型为Integer，而put将int类型的值放到map中，自动装箱后的语句类似于： Map<String,Integer>map=newHashMap<>(); map.put("a",Integer.valueOf(1)); 自动拆箱 和自动装箱相反，如果将Integer类型的数据赋值给基本数据类型int，就会执行自动拆箱。如： Integera=newInteger(5); intb=a; 在编译时，会根据这种语法，决定进行拆箱操作，实际上执行的语句调用了a的intValue方法： Integera=newInteger(5); intb=a.intValue(); 当Integer类型的对象和基本数据类型进行算术或关系运算时，Integer对象也会自动拆箱，比如： Integera=newInteger(5); intb=6; Integerc=a+b; 当执行Integerc=a+b;时，编译器发现一个Integer类型和一个int类型进行算术运算，决定对Integer类型进行拆箱。a+b运算的结果实际上是int类型的，将结果赋值给c时又会进行装箱操作。 Integer的缓存机制 Integer的缓存机制使得比较问题更加复杂。上面说过，自动装箱时调用了Integer.valueOf()，这个函数的源码为： publicstaticIntegervalueOf(inti){ if(i>=IntegerCache.low&&i<=IntegerCache.high) returnIntegerCache.cache[i+(-IntegerCache.low)]; returnnewInteger(i); } 其中IntegerCache.low=-128，IntegerCache.high=127。这说明valueOf的参数如果介于-128和127之间的话，会返回IntegerCache中的对象，否则会重新new一个对象并返回。 Integer/int的比较 1.两个int类型进行比较，直接使用==就好了。 2.涉及Integer的比较，使用equals总不会出错。如果是两个Integer进行比较，equals当然比较的是各对象的值。如果是一个Integer和一个int比较，只能对Integer对象使用equals方法，这时会涉及自动装箱，比如： Integera=5; intb=5; a.equals(b); 最后一条语句会让b自动装箱，但是equals比较的始终是对象的值，因此不会有问题 3.涉及Integer的比较，如果使用==，情况会变得复杂。 如果是一个Integer和一个int比较，前面说过会进行自动拆箱，Integer对象会变为int类型，相当于两个int的==比较，没有问题。 如果是两个Integer进行比较，这里情况比较复杂。 (1)只要有一个Integer是通过new产生的，一定会得到false。因为new会在堆中分配内存，而==比较的是引用，也就是比较内存地址，只要不是别名引用，一定会得到false Integera=newInteger(5); Integerb=newInteger(5); Integerc=5; a==b//false a==c//false (2)两个Integer都是直接赋值产生的，只有被缓存时才能得到true。根据上面valueOf的源码可知，如果值落在-128~127之间，会返回IntegerCache中的对象，对于下面的代码，a和b都指向IntegerCache中的同一对象，因此==会得到true Integera=5; Integerb=5; a==b//true (3)两个Integer都是直接赋值产生的，但未缓存，会得到false。根据valueOf的源码，如果值不在-128~127之间，会返回new的对象，这时和(1)完全一样。对于下面的代码，a和b都是new出的对象，==会得到false Integera=128; Integerb=128; a==b//false 对于其他基本数据类型及其包装类，也涉及装箱、拆箱以及缓存的机制 包装类型基本数据类型缓存Booleanbooleantrue,falseBytebyte-128~127Shortshort-128~127Characterchar0~127Integerint-128~127Longlong-128~127Floatfloat无缓存Doubledouble无缓存 启示 可以看出比较的情况还是比较多的，但是如果只使用equals，就不会出现任何问题。因此涉及包装类对象之间值的比较，一定要用equals方法。这也是阿里Java开发手册编程规约中指出的：强制所有包装类对象之间值的比较，全部使用equals方法！ 
第151篇文章[]
哈工大软件构造Lab2 2021年春季学期计算学部《软件构造》课程 Lab2实验报告 目录 1实验目标概述···1 2实验环境配置···1 3实验过程···2 3.1PoeticWalks·2 3.1.1GetthecodeandprepareGitrepository·2 3.1.2Problem1:TestGraph<String>·2 3.1.3Problem2:ImplementGraph<String>·3 3.1.3.1ImplementConcreteEdgesGraph·3 3.1.3.2ImplementConcreteVerticesGraph·5 3.1.4Problem3:ImplementgenericGraph<L>·7 3.1.4.1Maketheimplementationsgeneric·7 3.1.4.2ImplementGraph.empty()·7 3.1.5Problem4:Poeticwalks·8 3.1.5.1TestGraphPoet·8 3.1.5.2ImplementGraphPoet·8 3.1.5.3Graphpoetryslam··9 3.1.6使用Eclemma检查测试的代码覆盖度···9 3.1.7Beforeyou’redone·10 3.2Re-implementtheSocialNetworkinLab1·10 3.2.1FriendshipGraph类···11 3.2.2Person类···11 3.2.3客户端main()·11 3.2.4测试用例···12 3.2.5提交至Git仓库···12 4实验进度记录···13 5实验过程中遇到的困难与解决途径···13 6实验过程中收获的经验、教训、感想···13 6.1实验过程中收获的经验和教训···13 6.2针对以下方面的感受···14 实验目标概述 本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说： 针对给定的应用问题，从问题描述中识别所需的ADT；设计ADT规约（pre-condition、post-condition）并评估规约的质量；根据ADT的规约设计测试用例；ADT的泛型化；根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction）使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure）；测试ADT的实现并评估测试的覆盖度；使用ADT及其实现，为应用问题开发程序；在测试代码中，能够写出testingstrategy并据此设计测试用例。 实验环境配置 Eclipse和Git在上一次实验中已经配置好了。本次实验只需要在eclipse中配置EclEmma用来检查测试的代码覆盖度。在Help->EclipseMarketplace中查找EclEmma，发现最初安装Eclipse就已经默认安装EclEmma了。这样，本实验所需要的所有环境就都配置好了。 在这里给出你的GitHubLab2仓库的URL地址（Lab2-学号）。 https://github.com/ComputerScienceHIT/HIT-Lab2-1190200817 实验过程 请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。 PoeticWalks 任务要求实现两种不同形式的图，给出了一个图接口来规定图所包含的各种方法，两种不同的实现需要继承这个接口，实现给定方法，同时需要满足泛型要求。在完成了两种实现后，任选一种实现形式完成自动扩展诗歌的任务。 GetthecodeandprepareGitrepository 使用gitinit初始化一个本地仓库，通过gitclone将GitHub上的文件下载到这个仓库中。这时就可以利用IDE进行代码编写。每当认为某一处代码修改完成，可以让它成为一个新的版本时，利用gitadd添加相应代码，使用gitcommit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过gitpushoriginmaster将本地仓库push到GitHub上。 Problem1:TestGraph<String> 思路：对Graph<String>接口中的所有方法进行测试，设计相应的测试策略，按等价类划分的方法进行测试。 测试策略：（1）对add方法进行测试，等价类划分：加入的点已经存在于图中；加入的点不在图中。（2）对set方法进行测试，等价类划分：设置的边已经在图中，权值依次为大于零（即需要更新权值）、等于零（即删除该边）、小于零（是非法情况，不做任何操作）；设置的边不在图中，但顶点在图中，权值依次为大于零、等于零、小于零；设置的边的顶点不在图中，权值依次为大于零、等于零、小于零。（3）对remove方法进行测试，等价类划分：要删除的点在图中，但不关联边；要删除的点在图中，且关联边；要删除的点不在图中。（4）对vertices方法进行测试，等价类划分：点集为空；点集非空。（5）对sources方法进行测试，等价类划分：作为参数的顶点存在源点（返回非空）；作为参数的点不存在源点（返回为空）。（6）对targets方法进行测试，等价类划分同（5），即是否存在目标点。在对每一个方法进行测试时，同时需要考虑其他方法的影响，因此在每个测试中都会同时测试一些其他方法。 结果：在实现了两种形式的图之后，运行编写的junit测试用例，通过。 Problem2:ImplementGraph<String> ImplementConcreteEdgesGraph （1）设计Edge类：Edge类应该含有一条有向边的所有信息，即起点标签、终点标签以及权值。 关于Edge类的AF、RI和防止表示泄露的方式： Abstractionfunction：AF(source)=该边的起点、AF(target)=该边的终点、AF(weight)=该边的权值 Representationinvariant：source与target非空且weight为正数 Safetyfromrepexposure：将source,target,weight设置为private,外部无法直接引用 由于Edge需要是不可变类型，将起点标签、终点标签以及权值都设置为privatefinal，并且Edge类中的方法不能修改这些属性。Edge中的方法包括：getSource()：获得起点标签；getTarget()：获得终点标签；getWeight()：获得权值（由于int和顶点类型L都是不可变类型，因此正常返回不会影响其不可变性）；Edge()：构造方法；checkRep()：检查表示不变量；同时重写了hashCode、equals和toString用于Edge类型判断相等。 （2）测试Edge类：对Edge类除checkRep()外的所有方法进行测试，对于getSource()、getTarget()、getWeight()、toString()、hashCode()，都是简单的返回结果，不存在特殊情况，无需划分等价类，对每个方法进行一次测试即可。对于equals()方法，只要划分成两个Edge实例相等和不相等两种情况。 （3）利用Edge实现ConcreteEdgesGraph： 关于ConcreteEdgesGraph类的AF、RI和防止表示泄露的方式： Abstractionfunction：AF(vertices)={vertex|vertexinvertices}、AF(edges)= {edges[i]|0<=i<edges.sizes()} Representationinvariant：edges中每条边满足长度大于零；起点终点都在vertices中；以一个点为起点另一个点为终点最多只有一条边(边不能重复) Safetyfromrepexposure：将vertices和edges设置为private,外部无法直接引用、返回vertices时进行防御式拷贝 各方法的实现思路如下： 方法名实现思路add()判断要加入的顶点是否已经存在于vertices集合，若存在，直接返回false；不存在则向vertices中添加顶点，返回trueset()参数source、target、weight，在edges中寻找是否有以source为起点、target为终点的边。若有，则记录权值并将这条边删去，当weight大于零时重新添加新边；若没有，判断weight的值，若weight大于零，则添加新边，同时可能需要向vertices添加新顶点，否则不做操作。最后，如果之前记录过权值，就将其返回，权值为负时返回-1，其他情况都返回0.remove()首先判断要删除的点是否在点集vertices中，如果不在，不做任何操作并返回false。若存在，在点集中将该点删除，同时遍历所有的边，只要某条边的起点或终点是要删除的点，就将这条边从edges中删除，最后返回true。vertices()返回vertices的一份不可修改的拷贝。sources()遍历所有的边，如果某条边的终点是输入参数，就将其放进结果映射中，最后返回结果映射。targets()遍历所有的边，如果某条边的起点是输入参数，就将其放进结果映射中，最后返回结果映射。toString()依次遍历点集vertices和边集edges，将所有信息组合成字符串，格式为”Vertices:…,Edges:…” （4）实现后，利用继承自GraphInstanceTest的ConcreteEdgesGraph进行测试，测试通过。 ImplementConcreteVerticesGraph （1）设计Vertex类：Vertex类应该含有与一个顶点有关的所有信息，即一个Vertex实例相当于一个邻接表。因此属性包括顶点的标签vertex和表示邻接关系的映射adjacent（其中adjacent的键是终点，值是这条边的权值）。为了避免表示泄露，使用privatefinal修饰这两个属性。 关于Vertex类的AF、RI和防止表示泄露的方式： Abstractionfunction：AF(vertex)=顶点的标签、AF(adjacent)=以该点为起点的所有边的集合 Representationinvariant:vertex非空且每个边的权值大于0 Safetyfromrepexposure：将vertex和adjacent设置为private，外部无法直接引用、返回adjacent时进行防御式拷贝 Vertex中的方法包括：getVertex()：获得顶点标签；getAdjacent()：获得邻接表；set()：改变邻接表中的某个条目，与Graph中的set相对应；remove()：删除邻接表中的某个条目，与Graph中的remove相对应；Vertex()：构造方法；checkRep()：检查表示不变量；同时重写了hashCode、equals和toString用于判断相等。Vertex类型是可变的，因为set()方法和remove()方法都会改变Vertex内部的属性值。 （2）测试Vertex类：对Vertex类除checkRep()外的所有方法进行测试。其中getVertex()只是简单地获得标签，无需划分等价类；getAdjacent()划分为邻接表空/非空两种情况；equals()划分为两个Vertex实例相等/不相等；toString()划分为邻接表空/非空两种情况；测试set()、remove()方法的策略和GraphInstanceTest中对set()、remove()的测试策略一致，详见3.1.2. （3）利用Vertex实现ConcreteVerticesGraph： 关于ConcreteVerticesGraph类的AF、RI和防止表示泄露的方式： Abstractionfunction：AF(vertices)={vertices[i]|0<=i<vertices.sizes()} Representationinvariant：vertices中不能有重复顶点 Safetyfromrepexposure：将vertices设置为private,外部无法直接引用 各方法的实现思路如下： 方法名实现思路add()判断要加入的顶点是否是vertices中某个Vertex实例的标签，若不是，直接返回false；否则以输入参数为标签新建一个Vertex并加入vertices，返回trueset()参数source、target、weight，在vertices中寻找是否有以source为标签的Vertex实例。若有，继续在其邻接表中寻找是否存在一个键是target，存在则记录权值，当weight>0时更新，weight=0时删除，weight<0时不操作；否则在weight大于零时添加新边。若没有，只有在weight>0时新建一个以source为标签的Vertex并加入vertices中，同时添加一条新边。只有在之前记录权值的情况下返回权值，权值为负时直接返回-1，其他情况均返回零。remove()首先判断要删除的点是否是vertices中某个Vertex实例的标签，如果不是，不做任何操作并返回false。若是，在vertices中将该点删除。同时遍历vertices中所有的Vertex实例，删除其邻接表中关于要删除边的信息，最后返回true。vertices()遍历vertices，将每个点的标签加入返回集合即可。sources()遍历所有顶点，如果其邻接表中有终点的信息，就将其放进结果映射中，最后返回结果映射。targets()如果源点存在，返回源点的邻接表的一份不可修改拷贝；否则返回一个空映射。toString()依次遍历点集vertices和边集edges，将所有信息组合成字符串，格式为”Vertices:…,Edges:…” （4）实现后，利用继承自GraphInstanceTest的ConcreteVerticesGraph进行测试，测试通过。 Problem3:ImplementgenericGraph<L> Maketheimplementationsgeneric 由于在针对String类型实现Graph时没有用到String类的特殊性质，所有相等的比较都是用equals实现，所有转化为字符串都是用toString实现，也没有用到String可比较的性质。因此，可以直接将刚才针对String类实现的ConcreteEdgesGraph和ConcreteVerticesGraph中的所有String更换为L即可。同时，Edge类和Vertex类也需要使用泛型，将其中所有的String改为L。在GraphStaticTest测试程序中，用和3.1.2中相同的测试策略，测试了泛型为Integer的情况，测试通过。 ImplementGraph.empty() 在Graph.empty()中，只需返回一个具体的Graph实例即可，可以在ConcreteEdgesGraph和ConcreteVerticesGraph任选其一。我选择了ConcreteVerticesGraph。 综上，关于Graph的实现全部完成，所有测试都顺利通过。 Problem4:Poeticwalks 任务要求利用之前实现的图，将语料库文件转化为一种图结构，并且根据输入的字符串在图中搜索可以插入的单词，完成诗句的扩展。 TestGraphPoet 对GraphPoet中的所有方法进行测试。GraphPoet中只有两个方法，构造方法GraphPoet()和产生诗的poem()。使用按等价类划分的方法对每个方法进行测试。 测试策略：（1）对构造方法，功能是读入语料库文件并产生相应的图。按照文件的形式划分等价类：文件为空；文件只有一行，且分隔符都是单个空格；文件有一行，但分隔符可能是连续空格；文件有多行但不存在空行；文件存在空行。针对以上情况设计语料库文件形式，测试是否能够正确生成相应的图结构。（2）对于poem()方法。按照输入字符串的形式和扩展形式划分等价类：输入字符串是空串；输入字符串存在连续空格；扩展后未插入单词；插入单词的过程中不存在比较行为；插入单词的过程中存在比较行为，测试是否能够正确扩展诗句。 ImplementGraphPoet 构造函数的实现：每次从文件中读入一行，用.split(“\\s+”)将读入的文本分割成单词，同时将所有单词转化为小写。对于分割后String数组中的每一个字符串，从它到它之后的字符串的边的权重加一，可以通过使用两个set()完成。 同时需要注意保留行尾的字符串，它到下一行第一个单词的边的权重需要加一。此外还要特别考虑空行的情况。 poem()函数的实现：先将输入字符串用.split(“\\s+”)分隔成单词，从前向后依次遍历两个单词，对前面的单词调用targets()得到它所有指向的顶点，对后面的单词调用sources()得到所有指向它的顶点。得到的两个结果的交集就是这两个单词的所有中间顶点，找到使得两条边权值和最大的顶点就是需要插入的顶点。维护一个List按顺序保存结果字符串中的每一个单词，每得到一个要插入的顶点，就将其对应的单词加到List中，每次循环最后将后面的单词也加入List中。循环结束时，List保存的就是结果字符串中的每个单词，将它们连接起来，中间由单个空格分隔就得到扩展后的字符串。 使用前面设计的测试用例测试，通过。 Graphpoetryslam 语料库内容如下： 扩展代码： 扩展结果： 使用Eclemma检查测试的代码覆盖度 除GraphPoet和FriendshipGraph中的main函数没有覆盖，其他基本都覆盖到了。 Beforeyou’redone 通过Git提交当前版本到GitHub上你的Lab2仓库：先使用gitstatus确定未被添加的代码；再使用gitadd添加相应代码；使用gitcommit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过gitpushoriginmaster将本地仓库push到GitHub上。 在这里给出你的项目的目录结构树状示意图。（Eclipse中显示的项目目录结构） Re-implementtheSocialNetworkinLab1 利用之前实现好的Graph<L>，重新实现Lab1中的SocialNetWork，并且要尽可能复用已经实现的add()和set()方法，并能和之前一样通过测试。这让我们体会到实现好一个类型对之后的工作有很大的简化。 FriendshipGraph类 使用ConcreteVerticesGraph<Person>作为FriendshipGraph中的图结构，并且用privatefinal修饰，避免表示泄露。 addVertex()方法直接使用Graph中的add()方法实现： addEdge()方法直接使用Graph中的set()方法实现，由于此题不带权，因此权值均设置为1： getDistance()没有太大变化，和之前一样利用广度优先搜索实现。 Person类 由于使用ConcreteVerticesGraph<Person>实现，要求Person是不可变类型，定义Person的属性只有一个，即名字字符串，同时用privatefinal修饰。 关于Vertex类的AF、RI和防止表示泄露的方式： Abstractionfunction：AF(name)=这个人的名字 Representationinvariant：名字不能为null Safetyfromrepexposure：将name设置为private,外部无法引用 Person类的方法包括：checkRep()检查表示不变量；getName()获得名字；Person()构造方法；重写的hashCode()、equals()、toString()使得便于判断重复；同时实现了compareTo()方法使得Person类是可比较的。可以发现，所有方法都无法更改Person内部的属性，因此Person类是不可变的。 客户端main() 客户端代码已经在Lab1中给出： 测试用例 对FriendshipGraph中的所有方法进行测试。使用按等价类划分的方法对每个方法进行测试。 测试策略：（1）对于addVertex()方法，测试添加重复的人和不重复的人的情况；（2）对于addEdge()方法，测试三种情况：添加朋友关系的人不在图中；添加自己到自己的朋友关系；正常添加朋友；（3）对于getDistance()测试三种情况：没有朋友关系的两个人之间的距离；有朋友关系的两个人之间的距离；自己到自己的距离。 使用按照测试策略设计的测试用例测试，通过。 提交至Git仓库 通过Git提交当前版本到GitHub上你的Lab2仓库：先使用gitstatus确定未被添加的代码；再使用gitadd添加相应代码；使用gitcommit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过gitpushoriginmaster将本地仓库push到GitHub上。 项目的目录结构树状示意图见3.1.7 实验进度记录 请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。 日期时间段计划任务实际完成情况2021.5.2118:30-20:30设计GraphInstanceTest中的测试用例完成2021.5.2219:30-22:00实现ConcreteEdgesGraph<String>并进行测试完成2021.5.2318:30-21:00实现ConcreteVerticesGraph<String>并进行测试完成2021.5.2321:00-21:30将特定类型转换为泛型发现前面实现中的问题并进行了修改，延期一小时完成2021.5.2420:00-22:30设计GraphPoet测试用例并实现GraphPoet，进行测试完成2021.5.2510:00-11:30利用ConcreteVerticesGraph重新实现之前的FriendshipGraph并进行测试完成 实验过程中遇到的困难与解决途径 遇到的难点解决途径撰写AF,RI,Safetyfromrepexposure时不知道从何写起 查看PPT中的示例以及在网上查找相关的示例理解撰写思路和方法，并逐渐掌握了撰写方法。测试用例覆盖的情况不全面 仔细地设计测试用例，尽可能覆盖等价类中所有的情况。 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 在实现使用泛型的类时，一定要事先完整地想好各个功能如何实现，特别是每个方法都要满足所有可能的类型，要特别小心不要利用某些类特有的性质。比如，在实现泛型为String的特殊情况时，使用了compareTo方法，这个方法不是所有类都有的，扩展到泛型时会产生错误，需要重新设计方法的实现。 针对以下方面的感受面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？ 面向ADT的编程需要从实际中进行抽象，并进行合理的设计，有很好的可扩展性和可复用性；而直接面向应用场景编程只针对特定应用，每次更换应用场景时都要重新编程，扩展性很差，只适合简单的应用场景。 使用泛型和不使用泛型的编程，对你来说有何差异？ 使用泛型能够扩展应用范围，可以适用于不同的类，能够很好地应对变化，并且能提高可复用性。但使用泛型也使得功能的实现更加困难，必须考虑可能的所有类型，不能依赖任何特定类型，需要更全面细致的考虑。 在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？ 这使得测试时不需考虑方法的实际实现，不会让测试过度依赖具体的实现方法，这也体现了测试优先编程的优势，可以更加容易地发现错误，保证测试的有效性。我也在逐渐适应这种测试优先的编程方法，也体会到这种方法确实很有效。 P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？ 可以提高代码的可复用性，减少大量重复的工作。 P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？ 正在逐渐适应从具体应用场景到ADT的“抽象映射”，并逐渐掌握抽象的方法。在P3自主设计时，仍然需要参考P1给出的逻辑关系，仿照P1进行设计，我也在自主设计的过程中逐渐掌握设计思路和方法，并尽可能地进行独立设计。 为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？ 这些工作使得客户端了解各方法的功能但无法得知内部具体实现，同时可以防止内部变量被客户端恶意修改。时刻检查表示不变量，可以更好地保证代码的正确和安全。虽然这些工作有些麻烦，但却是好的软件必须具备的，因此我愿意在以后编程中坚持这么做。 关于本实验的工作量、难度、deadline。 工作量不大，难度不太大，但是撰写specification,invariants,RI,AF以及testingstrategy会使用较长时间。deadline很合适，给了三周时间，完全可以完成。 《软件构造》课程进展到目前，你对该课程有何体会和建议？ 逐渐理解了软件构造过程中独有的思路和方法，也逐渐适应了与之前完全不同的编程过程。建议实验内容还是翻译成中文，有些英文读起来会有歧义。 
第152篇文章[]
Java继承问题以及子类转换为父类时调用方法及属性的情况 1.方法的继承 子类可以继承父类的非private方法。 classparent{ publicvoidpnp(){ System.out.println("Parent"); } } classchildextendsparent{ } childc=newchild(); c.pnp(); 输出结果为Parent. 子类可以重写父类的非private方法。 classparent{ publicvoidpnp(){ System.out.println("Parent"); } } classchildextendsparent{ @Override publicvoidpnp(){ System.out.println("Child"); } } 这时，输出结果为Child 对于父类的private方法，子类是不可见的，尝试调用父类的private方法会导致静态检查直接报错。 当然，子类中也可以添加自己独特的新方法。如果子类中写了一个和父类某个private方法一样的方法，这不能算重写，应该也算添加新方法。 2.属性的继承 属性的继承和方法的继承类似，子类可以继承父类的非private属性。父子类定义如下： classparent{ intnp=0; } classchildextendsparent{ } 子类child可以访问np属性，在main中进行测试，输出结果为0. childch=newchild(); System.out.println(ch.np); 当然，类似于方法的重写，子类也可以覆盖掉父类的属性。 classparent{ intnp=0; } classchildextendsparent{ intnp=1; } 测试代码和上面一样，输出结果为1. 当子类试图访问父类的private属性时，静态检查会直接报错。 子类中也可以添加自己独特的新属性。 3.方法与属性混合的情况 如果方法是从父类继承的，那么方法中使用到的属性都是父类的属性。 classparent{ intnp=0; publicvoidpnp(){ System.out.println(np); } } classchildextendsparent{ intnp=1; } childch=newchild(); ch.pnp(); 在main中测试，输出结果是0.即使子类中已经覆盖了属性np，但是方法的行为仍然和父类一致，这时就不能简单地看代码的逻辑了。如果子类想按照代码的逻辑实现功能的话就只能重写，而重写的代码和之前一模一样。 classparent{ intnp=0; publicvoidpnp(){ System.out.println(np); } } classchildextendsparent{ intnp=1; @Override publicvoidpnp(){ System.out.println(np); } } 这时测试输出结果为1. 然而对于方法内部再次调用方法的情况，却正好相反。如果从父类继承来的方法A调用了方法B，并且子类重写了方法B，当子类调用方法A时，方法A内部会调用被重写的方法B. classparent{ publicvoidA(){ B(); } publicvoidB(){ System.out.println("Origin"); } } classchildextendsparent{ publicvoidB(){ System.out.println("Override"); } } 子类调用A()时会输出Override。 4.子类转换为父类时，调用方法及属性的情况 显然的是，当子类转换为父类后，只能调用父类中存在的方法、访问父类中存在的属性。 当访问属性时，属性的值是父类中的值。 classparent{ intnp=0; } classchildextendsparent{ intnp=1; } parentc=newchild(); System.out.println(c.np); 输出结果为0. 而调用的方法应该是子类中的方法。 如果方法被重写，调用的方法就是子类中被重写的方法。 classparent{ publicvoidA(){ System.out.println("Origin"); } } classchildextendsparent{ @Override publicvoidA(){ System.out.println("Override"); } } parentc=newchild(); c.A(); 输出结果为Override。 如果方法没有被重写，调用的方法就是父类中的方法。 classparent{ publicvoidA(){ System.out.println("Origin"); } } classchildextendsparent{ } parentc=newchild(); c.A(); 输出结果为Origin。 如果调用的方法中访问了某个属性或者又调用了其他方法时，会遵循3中给出的分析。 简单总结一下 对于属性的访问，在运行前就会确定，因此只看当前的类型，当前的类型是什么就访问这个类型中定义的属性；而对方法的调用在运行时才会确定，要看原本的类型（即new的时候的类型），按照这个类型调用相应方法。而方法内部如果访问了属性，这个属性是定义该方法的那个类型中的属性；方法内部如果调用了其他方法，被调用的方法仍然是这个类型中的方法，当然，也存在嵌套的情况。 
第153篇文章[]
哈工大软件构造Lab1 Lab1实验报告 1实验目标概述 1 2实验环境配置 1 3实验过程 2 3.1MagicSquares.2 3.1.1isLegalMagicSquare().2 3.1.2generateMagicSquare().3 3.2TurtleGraphics.5 3.2.1Problem1:Cloneandimport5 3.2.2Problem3:TurtlegraphicsanddrawSquare.5 3.2.3Problem5:Drawingpolygons.6 3.2.4Problem6:CalculatingBearings.7 3.2.5Problem7:ConvexHulls.8 3.2.6Problem8:Personalart9 3.2.7Submitting.10 3.3SocialNetwork.10 3.3.1设计/实现FriendshipGraph类 10 3.3.2设计/实现Person类 12 3.3.3设计/实现客户端代码main().13 3.3.4设计/实现测试用例 13 4实验进度记录 15 5实验过程中遇到的困难与解决途径 16 6实验过程中收获的经验、教训、感想 16 6.1实验过程中收获的经验和教训 16 6.2针对以下方面的感受 16 实验目标概述 本次实验通过求解三个问题，训练基本Java编程技能，能够利用JavaOO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。 ⚫基本的JavaOO编程 ⚫基于EclipseIDE进行Java编程 ⚫基于JUnit的测试 ⚫基于Git的代码配置管理。 实验环境配置 在官网下载安装JDK，根据网上的步骤配置环境变量。 在官网下载安装Eclipse，设置JRE以及其他preferences。新建一个Workspace，建立项目、包以及java源代码，Eclipse配置成功的结果如图。 在官网下载Git并安装，设置用户名、邮箱等信息，Git配置成功的结果如图。 GitHubLab1仓库的URL地址：https://github.com/ComputerScienceHIT/HIT-Lab1-1190200817。 实验过程 请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。 为了条理清晰，可根据需要在各节增加三级标题。 MagicSquares 主要任务：从txt文件中解析数据，并判断数据是否构成一个幻方，通过5个文件进行测试。同时阅读和改进产生幻方的代码，并进行测试。 isLegalMagicSquare() 首先，需要从txt文件中读出数据，读txt文件可以使用固定的格式，即使用BufferedReader并用try-resource语句处理异常。 利用BufferedReader，每次可以从文件中读入一行字符串。由于txt文件以’\t’分隔数据的，用String类的split方法可以将读入的字符串以’\t’分隔，得到字符串数组，每个字符串数组都代表一个数。使用Integer.valueOf将分隔后的每个字符串解析为数字，同时需要捕获异常识别非法数据。 所有数据都存在二维ArrayList中，获得每一行数据的个数以及总行数，判断是否为n*n的矩阵。分别计算每行、每列以及两个对角线上的数字之和，比较是否相等，并返回结果。如果出现各种特殊情况，输出错误提示信息并返回。 generateMagicSquare() 阅读generateMagicSquare()的代码，可以看出它是将1到n2 填充到一个n*n 的幻方中，这种方法是常用的填充幻方的方法。程序的流程图如下： 但是，这种方法只能填充n 为奇数时的幻方。当n 为偶数时，函数产生异常java.lang.ArrayIndexOutOfBoundsException即填充过程中在row++时发生数组越界访问。并且当n 是负数时，不能有效处理非法输入，产生异常java.lang.NegativeArraySizeException即初始化了行列数为负数的数组。这导致了很差的健壮性。修改这个函数，当输入不合法时提示错误并退出。 同时，当输入合法时，增加将结果写入文件的功能。和之前类似，使用BufferedWriter将数据写入文件。 利用前面的isLegalMagicSquare()函数，可以判断生成的文本文件确实符合MagicSquare。 TurtleGraphics 主要任务：根据函数的注释补全代码，实现一系列绘图可能用到的功能。包括画出正方形、计算正多边形的内角、计算对应内角的正多边形边数、计算绘图时的角度转移、计算凸包、以及绘制自己独特的图形。 Problem1:Cloneandimport 使用gitinit初始化一个本地仓库，通过gitclone将GitHub上的文件下载到这个仓库中。这时就可以利用IDE进行代码编写。每当认为某一个代码改进完成，可以让它成为一个新的版本时，利用gitadd添加相应代码，使用gitcommit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过gitpushoriginmaster将本地仓库push到GitHub上。 Problem3:TurtlegraphicsanddrawSquare 绘制图形时要用到两个函数：forward和turn，分别实现前进和转向。绘制正方形时，只需要每次前进给定长度，然后转向90°，循环四次即可。 代码： 结果： Problem5:Drawingpolygons 对于给定边数的正多边形，需要计算内角的度数来确定每次转向的度数。实现calculateRegularPolygonAngle()函数确定给定边数的正多边形的内角度数。直接通过公式可求出。 和上面一样，每次前进给定长度，转向的角度为外角的度数，循环次数为边数。 代码： 结果（以正六边形为例）： 最后还要实现给定内角度数，确定正多边形边数的函数。直接通过公式可求出。注意最后要将结果四舍五入才能返回整数。 Problem6:CalculatingBearings 实现函数calculateBearingToPoint()以满足已知起点、终点和当前朝向时，应该转向的角度。计算起点和终点所连直线的斜率，利用atan函数得到最终的朝向的角度，它和当前朝向的差值就是需要转过的角度。 通过调用calculateBearingToPoint()函数就可以计算经过一系列点时每次要转向的角度，进而实现calculateBearings()。已知初始朝向，按顺序在列表中取出两个点，调用calculateBearingToPoint()就可以得到这两个点之间需要转过的角。修改当前朝向为转向之后的角度，就可以进行下一次计算。需要注意，更新当前朝向后，如果角度超过360°，需要减去360°。 Problem7:ConvexHulls 使用安德鲁算法求解凸包。首先判断特殊情况，如果顶点数小于等于2时，这些点都会是凸包中的，直接返回原点集。找到所有点中横坐标最大的点，有多个则选择纵坐标最小的点，把它作为基准点，这个点一定在凸包中。其他的点和这个点的连线与y轴正半轴存在夹角，按照夹角从小到大对其他顶点排序。维护一个栈，首先将基准点入栈。按顺序从排好序的顶点中取出一个，如果栈中的点数大于2，就取出栈顶的两个点。通过计算向量的内积判断栈顶的点是否应该在凸包中，如果不在，将栈顶的点弹出，继续判断；如果在，将取出的顶点入栈。如果栈中的点数小于2，直接将取出的顶点入栈。最后，栈中的点就是凸包中的点。代码如下： 对于以上实现的代码，都通过了测试程序的测试。 Problem8:Personalart 利用while循环绘制一个雪花图形，通过递推确定每次要转向的角度。 代码： 结果： Submitting 当所有代码都修改完成并确认无误后，利用gitadd添加修改过的代码文件，使用gitcommit将本地文件加入到本地仓库，同时可以标注版本信息。通过gitpushoriginmaster将本地仓库push到GitHub上，在GitHub上可以看到push之后的文件。 SocialNetwork 主要任务：设计Person类和FriendshipGraph类来模拟一个社交网络，并实现社交网络中需要的一些简单功能，包括添加人、添加社交关系以及计算两个人之间的距离。同时，编写测试程序来检查实现的正确性。 设计/实现FriendshipGraph类 社交网络是一个图模型，FriendshipGraph类中要存储一个图，并且要支持各种功能。我在FriendshipGraph类中只存储图的顶点，而顶点之间的关系和某一个人有关，因此存储在Person类中。FriendshipGraph类的属性只有privateHashSet<Person>vertex用来存储图的顶点，方法包括构造方法、private变量的getter和setter以及一些简单的功能addVertex(),addEdge(),getDistance()。另外，由于名字是Person的属性，因此判断名字是否重复交给Person类实现。 addVertex()向vertex集合中添加顶点，addEdge()在Person类的朋友集合中添加新的朋友，getDistance()利用广度优先搜索计算两个Person之间的最近距离。同时，在函数中判断一些非法情况。具体代码如下： 属性 构造函数 getter和setter addVertex() addEdge() getDistance() 设计/实现Person类 Person类是对人的抽象，属性包括自己的名字和朋友集合。方法包括：内部private属性的getter和setter，构造函数，以及添加朋友的addFriend()。同时，为了判断重名，在Person类中重写hashCode()、equals()和toString()方法，使得每个Person实例有不同的名字，如果有两个同名Person添加到社交网络的集合中，集合只会保留一个。具体代码如下： 属性 addFrined() 构造函数 Getter和setter 重写的hashCode,equals,toString 设计/实现客户端代码main() 按照给定的客户端代码实现。 设计/实现测试用例 对于addVertex()的测试：当调用addVertex()后，测试FriendshipGraph类中顶点集合vertex的大小。如果添加的人不重复，大小会加一，否则不变。 当addVertex()添加人的名字重复时，程序会输出提示信息并退出。因此测试程序退出时的输出内容是否正确（在网上查阅资料得知，需要添加额外的代码以测试调用System.exit()的情况）。 对于addEdge()的测试：当调用addEdge()后，测试添加朋友的Person类中朋友集合friend的大小。addEdge()两个参数对应的Person类中的friend集合大小都会加一。 对于getDistance()的测试：建立一个社交网络，测试函数返回的结果和实际结果是否相同，需要覆盖距离是-1、0以及大于0的情况。 测试结果： 实验进度记录 日期时间段任务实际完成情况2021-05-0620:30-21:30编写SocialNetwork问题中的FriendshipGraph类和Person类并在main函数中进行测试按计划完成2021-05-0718:30-19:30编写isLegalMagicSquare()函数，并用1.txt~5.txt文件中的数据进行测试延期10分钟完成2021-05-0720:30-21:30分析generateMagicSquare()函数的功能并进行修改，用其产生的MagicSquare测试isLegalMagicSquare()函数按计划完成2021-05-0814:00-17:00完成TurtleGraphics问题中的所有任务按计划完成2021-05-0918:30-19:00设计并编写addVertex(),addEdge()和getDistance()的单元测试按计划完成2021-05-1113:45-15:00使用Git管理仓库并push到GitHub延期20分钟完成 实验过程中遇到的困难与解决途径 遇到的困难解决途径用Git管理时无法合并到master分支 查阅资料，发现命令行参数存在问题，修改后成功。 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 本次实验初次接触软件构造，在实验中，我明白了软件构造的基本流程，并且更加熟练地掌握Java语言。同时，对Git的学习和使用也让我懂得了软件管理的重要性。获得了一些使用Git和本地IDE进行软件构造的经验。同时，也获得了一些教训，一定要在编写代码之前考虑好类的构造，属性、方法的定义以及使用的数据结构，否则一旦出错可能需要重头再来；同时，在设计之前也要平衡不同的质量目标，不至于在代码编写结束后再耗费很大功夫重新修改。 针对以下方面的感受Java编程语言是否对你的口味？ 是，面向对象的语言会更容易编写，同时Java也包含了更多常用的数据结构和函数，可以节省编写代码的工作量。 关于EclipseIDE； Eclipse集成开发环境功能很强大，使得编写程序更加容易。 关于Git和GitHub； 虽然Git的指令有些难搞懂，但是用它管理项目是很方便的。GitHub上的资源很多，功能也很强，但就是访问速度太慢了。 关于CMU和MIT的作业； 难度适合，也让我们可以与国外名校接轨。 关于本实验的工作量、难度、deadline； 难度不大，但是工作有些繁琐，但deadline设置比较合理，可以按时完成。 关于初接触“软件构造”课程； 初次做软件构造的实验，我认为可以通过这个课程提升自己的编程能力并且培养一种全局观念，同时可以获得更多不同的能力。 
第154篇文章[1]
2021哈工大计算机系统大作业 程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机类 学 号 1190200817 班 级 1936602 学 生 刘小川 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文介绍了hello的整个生命过程。利用gcc，gdb，edb，readelf，HexEdit等工具具体分析了hello从源程序开始，历经预处理、编译、汇编、链接的一系列步骤变为可执行文件的过程，即P2P的过程。同时还具体分析了hello在运行过程中涉及的进程管理、内存管理、IO管理到最后hello被回收，即020的过程。通过对hello这个简单程序的详细分析，我们能够更加深入地理解计算机系统。 关键词：Hello’sP2P；进程管理；内存管理；I/O管理 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -5- 1.1Hello简介 -5- 1.2环境与工具 -5- 1.3中间结果 -5- 1.4本章小结 -6- 第2章预处理 -7- 2.1预处理的概念与作用 -7- 2.2在Ubuntu下预处理的命令 -8- 2.3Hello的预处理结果解析 -9- 2.4本章小结 -9- 第3章编译 -10- 3.1编译的概念与作用 -10- 3.2在Ubuntu下编译的命令 -10- 3.3Hello的编译结果解析 -11- 3.3.1数据 -11- 3.3.2赋值操作 -13- 3.3.3类型转换 -13- 3.3.4算术操作 -13- 3.3.5关系操作 -14- 3.3.6数组操作 -14- 3.3.7控制转移 -15- 3.3.8函数操作 -15- 3.4本章小结 -16- 第4章汇编 -17- 4.1汇编的概念与作用 -17- 4.2在Ubuntu下汇编的命令 -17- 4.3可重定位目标elf格式 -17- 4.3.1ELF头 -17- 4.3.2节头部表 -18- 4.4.3符号表 -19- 4.3.4重定位节 -20- 4.4Hello.o的结果解析 -21- 4.5本章小结 -23- 第5章链接 -24- 5.1链接的概念与作用 -24- 5.2在Ubuntu下链接的命令 -24- 5.3可执行目标文件hello的格式 -24- 5.3.1ELF头 -25- 5.3.2节头部表 -26- 5.3.3程序头部表 -27- 5.3.4符号表 -27- 5.3.5重定位节 -29- 5.4hello的虚拟地址空间 -29- 5.5链接的重定位过程分析 -31- 5.6hello的执行流程 -33- 5.7Hello的动态链接分析 -33- 5.8本章小结 -35- 第6章hello进程管理 -36- 6.1进程的概念与作用 -36- 6.2简述壳Shell-bash的作用与处理流程 -36- 6.3Hello的fork进程创建过程 -36- 6.4Hello的execve过程 -37- 6.5Hello的进程执行 -37- 6.6hello的异常与信号处理 -38- 6.6.1可能出现的异常及处理方法 -38- 6.6.2可能产生的信号及处理方法 -39- 6.7本章小结 -41- 第7章hello的存储管理 -42- 7.1hello的存储器地址空间 -42- 7.2Intel逻辑地址到线性地址的变换-段式管理 -42- 7.3Hello的线性地址到物理地址的变换-页式管理 -43- 7.4TLB与四级页表支持下的VA到PA的变换 -43- 7.5三级Cache支持下的物理内存访问 -45- 7.6hello进程fork时的内存映射 -46- 7.7hello进程execve时的内存映射 -46- 7.8缺页故障与缺页中断处理 -47- 7.9动态存储分配管理 -48- 7.10本章小结 -51- 第8章hello的IO管理 -52- 8.1Linux的IO设备管理方法 -52- 8.2简述UnixIO接口及其函数 -52- 8.3printf的实现分析 -53- 8.4getchar的实现分析 -54- 8.5本章小结 -54- 结论 -55- 附件 -56- 参考文献 -57- 第1章概述 1.1Hello简介 简述Hello的P2P，020的整个过程。 Hello的P2P（FromProgramtoProcess）过程：在文本编辑器或IDE中编写C语言代码，得到最初的hello.c程序，即最初的Program。编译器驱动程序代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。驱动程序首先运行C预处理器（cpp），将C的源程序hello.c翻译成一个ASCII码的中间文件；然后运行C编译器（cc1）将中间文件翻译成一个ASCII汇编语言文件；之后运行汇编器（as）将汇编语言文件翻译成可重定位目标文件；最后运行链接器（ld）创建一个可执行目标文件hello。在shell中输入执行hello的命令，shell解析命令行，通过fork新建一个子进程来执行hello，这时Hello已经从Program转换为Process了。 Hello的020（FromZero-0toZero-0）过程：子进程调用execve，重新为hello进行内存映射，设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。进入程序入口后通过存储管理机制将指令和数据载入内存，CPU以流水线形式读取并执行指令，执行逻辑控制流。操作系统负责进程调度，为进程分时间片。执行过程中通过L1、L2、L3高速缓存、TLB、多级页表等进行存储管理，通过I/O系统进行输入输出。当程序运行结束后，shell回收hello进程，删除和该进程相关的内容，这时hello进程就不存在了。hello从开始的未被内存映射到运行再到回收后不再存在，就是020的过程。 1.2环境与工具 硬件环境：X64CPU；2.6GHz；16GRAM；256GHDDisk 软件环境：Windows1064位；Vmware16；Ubuntu16.04LTS64位 开发与调试工具：gcc，gdb，edb，readelf，HexEdit 1.3中间结果 hello.i：C预处理器产生的一个ASCII码的中间文件，用于分析预处理过程。 hello.s：C编译器产生的一个ASCII汇编语言文件，用于分析编译的过程。 hello.o：汇编器产生的可重定位目标程序，用于分析汇编的过程。 hello：链接器产生的可执行目标文件，用于分析链接的过程。 hello.txt：hello.o的反汇编文件，用于分析可重定位目标文件hello.o。 hellold.txt：hello的反汇编文件，用于分析可执行目标文件hello。 helloelf.txt：hello.o的ELF格式，用于分析可重定位目标文件hello.o。 helloldelf.txt：hello的ELF格式，用于分析可执行目标文件hello。 1.4本章小结 本章简述了Hello的P2P、020的整个过程并介绍了实验的基本信息：环境、工具以及实验的中间结果。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 预处理是指在进行编译的第一遍扫描之前所做的工作，是C语言的一个重要功能，由预处理程序负责完成。预处理在源代码编译之前对其进行的一些文本性质的处理，生成扩展的C源程序。C语言提供了多种预处理功能，包括宏定义、文件包含、条件编译等。 预处理指令是以‘#’开头的代码行。‘#’必须是该行除了空白字符外的第一个字符。‘#’后面是指令关键字，整行语句构成一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。下图是ANSI标准定义的C语言预处理指令。 图2-1C语言预处理指令 宏定义（#define）使用宏名来表示一个字符串，宏展开时以该字符串取代宏名。这是一种简单的文本替换，预处理程序对它不做任何检查。如有错误，只能在后续编译源程序时发现。文件包含指令（#include）把指定头文件插入到该指令行的位置取代该指令行，从而把指定的文件和当前的源程序文件连成一个源文件。条件编译指令（#ifdef，#ifndef，#else，#elif，#endif等）对源程序中一部分内容只在满足一定条件时才进行编译，即指定编译的条件。可以按不同的条件去编译不同的程序部分，从而产生不同的目标代码文件。 预处理程序还可以识别一些特殊的符号。__FILE__：包含当前程序文件名的字符串；__LINE__：表示当前行号的整数；__DATE__：包含当前日期的字符串；__STDC__：如果编译器遵循ANSIC标准，则是非零值；__TIME__：包含当前时间的字符串。预处理程序对于在源程序中出现的这些串将用合适的值进行替换。 合理地使用预处理功能编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。 2.2在Ubuntu下预处理的命令 预处理的命令：gcc-Ehello.c-ohello.i 预处理过程如图所示： 图2-2预处理命令 图2-3预处理结果 2.3Hello的预处理结果解析 查看预处理产生的hello.i文件，可以发现main函数以及定义全局变量的代码没有任何改变，而原来前面的#include语句被替换成了大量的头文件中的内容，包括外部函数的声明、结构体等数据结构的定义、数据类型的定义等内容。源程序开头的注释也被删除了。同时，如果有#define的话，还会进行相应的符号替换。但是可以看出，预处理的结果仍然是可以阅读的C语言程序，预处理只是对源程序进行了一些文本性质的处理，生成的是扩展的C源程序。 图2-4hello.i的部分结果 2.4本章小结 本章介绍了预处理的概念和作用，结合实际程序分析了预处理的过程，包括宏替换、头文件引入、删除注释、条件编译等。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的过程将预处理产生的ASCII码中间文件hello.i翻译成一个ASCII汇编语言文件hello.s。编译会对预处理文件进行词法分析、语法分析、优化等操作，将C语言这种高级语言转换为成更低级、更底层、机器更好理解的汇编语言程序。 词法分析对由字符组成的单词进行处理，从左至右逐个字符地对源程序进行扫描，产生一个个的单词符号，把作为字符串的源程序改造为单词符号串的中间程序。语法分析以单词符号作为输入，分析单词符号串是否形成符合语法规则的语法单位，如表达式、赋值、循环等，最后看是否构成一个符合要求的程序，按语言的语法规则分析检查每条语句是否有正确的逻辑结构（语法规则可用上下文无关文法来刻画）。代码优化对程序进行等价的变换，使得变换后的程序能产生更有效的目标代码。这种等价的变换不改变程序的运行结果，同时使得程序运行时间更短，占用的存储空间更小。如果在编译的过程中发现源程序有错误，会报告错误的性质和发生位置。但一般情况下，编译器只做语法检查和最简单的语义检查，而不检查程序的逻辑。 汇编语言程序比源程序的层次更低，但是与机器代码相比程序员更容易理解，汇编语言相当于高级语言和机器语言之间的过渡，是从源程序转换到机器代码的关键中间环节。 3.2在Ubuntu下编译的命令 编译的命令：gcc-Shello.i-ohello.s 编译过程如图所示： 图3-1编译命令 图3-2hello.s的部分结果 3.3Hello的编译结果解析 3.3.1数据 （1）常量：hello.c源程序中的两个printf的参数是字符串常量，分别为"Usage:Hello学号姓名！\n"和"Hello%s%s\n"。 图3-3hello.c中的字符串常量 在编译生成的hello.s中可以看到，这两个字符串常量分别由.LC0和.LC1指示，均存放在只读数据段.rodata中。 图3-4hello.s中的字符串常量 （2）全局变量：hello.c源程序中的sleepsecs是全局变量，且已被赋初值。 在编译生成的hello.s中可以看到，使用.global将sleepsecs标记为全局变量。.data表明全局变量sleepsecs存放在数据段.data中；.align要求4字节对齐；.size表明变量为4字节；最后.long给出了变量的初值为2。 图3-5hello.s中的全局变量 （3）局部变量：hello.c源程序中的局部变量包括i，用于循环的计数。 图3-6hello.c中的局部变量 分析hello.s中为for循环产生的汇编代码，可以看出i被存储在%rbp-4的内存地址处。其中movl为i赋初值0，addl在每次循环时对i增加1，cmpl比较i和9的大小来决定什么时候结束循环。因此局部变量i是存放在栈上的，并通过相对栈顶（%rsp）的偏移量来访问。 图3-7hello.s中的局部变量 hello.c中的其他局部变量还包括argc和argv，同样地，它们都存放在栈上的，并通过相对栈顶（%rsp）的偏移量来访问。 （4）关于数据的类型：在编译过程中，编译器会根据源程序中数据的类型来选取不同的寄存器以及不同的指令，比如浮点数会选择XMM寄存器，整数或指针会选择通用目的寄存器，同时也会根据数据的字节大小选择寄存器的不同部分以及指令的后缀。但在编译完成后，所有的类型信息都不复存在了，无法根据产生的汇编代码推断某个数据的类型。 3.3.2赋值操作 hello.c源程序中一共包括两次赋值操作，分别是对全局变量sleepsecs赋初值和对循环变量i赋初值。 图3-8hello.c中的赋值操作 对于全局变量赋初值，这个值直接存储在数据段.data中；而如果不对全局变量赋初值的话，变量会存放在.bss段。而对于其他情况，在不考虑优化的前提下，所有的赋值操作都转化成mov类的数据传送指令。指令的后缀取决于操作数据的字节大小，movb：一个字节；movw：两个字节；movl：四个字节；movq：八个字节。以对i赋值为例，由于i为四字节，因此使用指令movl. 图3-9hello.s中对应赋值操作的指令 3.3.3类型转换 hello.c源程序中只包含一次隐式的类型转换，出现在全局变量赋初值的时候。 对于隐式类型转换，编译器会自己直接进行转换，在这个例子中，2.5被隐式类型转换为int型，编译器直接将转换后的值2放在了相应的数据段中。 图3-10编译时的隐式类型转换 3.3.4算术操作 hello.c源程序中只包含一次算术操作，出现在循环变量i每次增加1的时候。算术操作为++。 算术操作++代表自增1的运算，编译时转化成add类的加法指令，使用立即数1来实现每次增加1. 图3-11hello.s中的++操作 其他和算术操作相关的指令还包括inc,dec,neg,sub,imul等等。 3.3.5关系操作 hello.c源程序中出现了两次关系操作。 （1）在if中判断argc的取值是否不等于3. 编译时使用cmpl指令将argc和3进行比较，并设置条件码。跳转指令je根据条件码决定是否跳转。对于关系操作!=来说，可以选择je或者jne跳转指令。 图3-12hello.s中的关系操作 （2）在for循环中判断结束条件，即判断i是否小于10。 类似地，编译时使用cmpl指令将i和9进行比较，并设置条件码。跳转指令jle根据条件码决定是否跳转。这里进行比较的值是9而不是10，与编译的过程中进行了优化有关。 图3-13hello.s中的关系操作 3.3.6数组操作 hello.c源程序中有关数组的操作出现在访问argv元素的时候，通过argv[1]和argv[2]访问了字符指针数组中的元素。 汇编代码中使用首地址+偏移量的方式来访问数组元素，数组首地址存储在%rbp-32的位置，通过将首地址加8获得argv[1]的地址，将首地址加16获得argv[2]的地址。值得注意的是，编译器会根据引用的数据类型的大小进行伸缩而不用程序员操心。由于这里的数组是指针数据，因此伸缩因子为8. 图3-14hello.s中的数组操作 3.3.7控制转移 hello.c源程序中出现了两次控制转移。 （1）if判断argc的取值后的控制转移。 编译时使用cmpl指令将argc和3进行比较，并设置条件码。跳转指令je根据条件码决定是否跳转。控制转移由指令je完成。 图3-15hello.s中的控制转移 （2）每次for循环结束时的控制转移。 类似地，编译时使用cmpl指令将i和9进行比较，并设置条件码。跳转指令jle根据条件码决定是否跳转。控制转移由指令jle完成。 图3-16hello.s中的控制转移 3.3.8函数操作 （1）函数的调用：hello.c源程序中一共出现了五次函数调用。 图3-17hello.c中的函数调用 编译时，所有的函数调用都转换成了指令call，后面跟着调用函数的名字。 图3-18hello.s中的函数调用 （2）参数的传递：大部分的参数传递通过寄存器实现，通过寄存器最多传递6个参数，按照顺序依次为%rdi、%rsi、%rdx、%rcx、%r8、%r9。多余的参数通过栈来传递。在hello.c这个例子中，对于第一个函数printf，只有一个参数，通过寄存其%edi传递。 图3-19hello.s中的参数传递 对于第二个函数exit，只有一个参数，通过寄存器%edi传递。 图3-20hello.s中的参数传递 对于第三个函数printf，有三个参数，分别通过寄存器%edi、%rsi、%rdx传递。 图3-21hello.s中的参数传递 对于第四个函数sleep，只有一个参数，通过寄存器%edi传递。 图3-22hello.s中的参数传递 最后一个函数getchar没有参数，无需传递。 （3）函数的返回：编译时，在函数的最后添加指令ret来实现函数的返回。在hello.c这个例子中，只能看到main函数的返回。 图3-23hello.s中的函数返回 3.4本章小结 本章介绍了编译的概念和作用，并针对具体的例子hello.s，详细地分析了编译器如何处理C语言的各种数据以及各类操作。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编的过程将编译生成的ASCII汇编语言文件hello.s翻译成一个可重定位目标文件hello.o。可重定位目标文件包含指令对应的二进制机器语言，这种二进制代码能够被计算机理解并执行。因此汇编是将汇编语言转换成最底层的、机器可理解的机器语言的过程。 4.2在Ubuntu下汇编的命令 汇编的命令：gcc-c-m64-no-pie-fno-PIChello.s-ohello.o 汇编过程如图所示： 图4-1汇编命令 4.3可重定位目标elf格式 使用readelf命令readelf-ahello.o>helloelf.txt查看hello.o的ELF格式，并将结果重定向到helloelf.txt便于查看分析。 图4-2查看hello.oELF格式的命令 4.3.1ELF头 ELF头以一个16字节的目标序列开始，如图中Magic所示，这个序列描述了生成该文件的系统的字的大小和字节顺序。以hello.o为例，这个16字节序列为7f454c46020101000000000000000000，描述了系统的字的大小为8字节，字节顺序为小端序。 ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量。以hello.o为例，ELF头中包含了ELF头的大小：64字节；目标文件的类型：REL（可重定位文件）；机器类型：AdvancedMicroDevicesX86-64；节头部表的文件偏移：1112bytes；节头部表中条目的数量：13. 图4-3hello.o的ELF头 4.3.2节头部表 节头部表描述不同节的位置和大小，目标文件中的每个节都有一个固定大小的节头部表条目。 以hello.s为例，节头部表一共描述了13个不同节的位置、大小等信息。依次为： [1].text节：已编译程序的机器代码，大小为0x7d字节，类型为PROGBITS，偏移量为0x40，标志为AX（表明该节的数据只读并且可执行）。 [2].rela.text节：一个.text节中位置的列表，大小为0xc0字节，类型为RELA，偏移量为0x318，标志为I。 [3].data节：已初始化的全局和静态C变量，大小为0x4字节，类型为PROGBITS，偏移量为0xc0，标志为WA（表明该节的数据可读可写）。 [4].bss节：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。大小为0x0字节，类型为NOBITS，偏移量为0xc4，标志为WA（表明该节的数据可读可写）。 [5].rodata节：只读数据，大小为0x2b字节，类型为PROGBITS，偏移量为0xc4，标志为A（表明该节的数据只读）。 [6].comment节：包含版本控制信息，大小为0x36字节，类型为PROGBITS，偏移量为0xef，标志为MS。 [7].note.GNU_stack节：标记可执行堆栈，大小为0x0字节，类型为PROGBITS，偏移量为0x125。 [8].eh_frame节：处理异常，大小为0x38字节，类型为PROGBITS，偏移量为0x128，标志为A（表明该节的数据只读）。 [9].rela.eh_frame节：.eh_frame节的重定位信息，大小为0x18字节，类型为RELA，偏移量为0x3d8，标志为I。 [10].shstrtab节：包含节区名称，大小为0x61字节，类型为STRTAB，偏移量为0x3f0。 [11].symtab节：一个符号表，存放在程序中定义和引用的函数和全局变量的信息。大小为0x180字节，类型为SYMTAB，偏移量为0x160。 [12].strtab节：一个字符串表，包括.symtab和.debug节中的符号表，以及节头部中的节名字。大小为0x37字节，类型为STRTAB，偏移量为0x2e0。 图4-4hello.o的节头部表 4.4.3符号表 符号表存放程序中定义和引用的函数和全局变量的信息，每个符号表是一个条目的数组，每个条目包括value：距定义目标的节的起始位置的偏移；size：目标的大小；type：指明数据还是函数；bind：表示符号是本地的还是全局的等等。 以hello.s为例，符号表一共描述了16个符号。比如全局变量sleepsecs，Ndx=3表明它在.data节，value=0表明它在.data节中偏移量为0的地方，size=4表明大小为4字节，bind=GLOBAL表明它是全局符号，type=OBJECT：表明它是数据。而对于函数main，Ndx=1表明它在.text节，value=0表明它在.text节中偏移量为0的地方，size=125表明大小为125字节，bind=GLOBAL表明它是全局符号，type=FUNC：表明它是函数。其他的符号如puts、exit、printf、sleep和getchar都是外部的库函数，需要在链接后才能确定。 图4-5hello.o的符号表 4.3.4重定位节 汇编器遇到对最终位置未知的目标引用，会产生一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位信息就放在重定位节.rel.text中，已初始化数据的重定位条目放在.rel.data中。 每个重定位条目包括offset：需要被修改的引用的节偏移；symbol：标识被修改引用应该指向的符号；type：重定位类型，告知链接器如何修改新的引用；attend：一些重定位要使用它对被修改引用的值做偏移调整。ELF定义了32种不同的重定位类型，两种最基本的重定位类型包括R_X86_64_PC32（重定位使用32位PC相对地址的引用）和R_X86_64_32（重定位使用32位绝对地址的引用）。 以hello.s为例，重定位节.rela.text一共描述了8个重定位条目。重定位节.rela.eh_frame描述了1个重定位条目。 图4-6hello.o的重定位节 4.4Hello.o的结果解析 使用命令objdump-d-rhello.o对hello.o进行反汇编，得到结果如图。 图4-7hello.o的反汇编结果 图4-8hello.s 与第3章的hello.s对比可以发现，hello.s中的汇编指令被映射到二进制的机器语言。机器语言完全是二进制代码构成的，机器可以直接根据二进制代码执行对应的操作。不同的汇编指令被映射到不同的二进制功能码，而汇编指令的操作数也被映射成二进制的操作数。因此每一条汇编语言的指令都可以映射到一条机器语言指令，而给出任何一条合法的机器语言指令也可以得知它对应的汇编指令。从汇编语言转换成机器语言的过程中，一些操作数会出现不一致的情况： （1）立即数的变化：hello.s中的立即数都是用10进制数表示的。 但是在机器语言中，由于转换成了二进制代码，因此立即数都是用16进制数表示的。 （2）分支转移的不一致：hello.s中的分支转移（即跳转指令）直接通过像.LC0，.LC1这样的助记符进行跳转，会直接跳转到相应符号声明的位置。 助记符只是帮助程序员理解的，从汇编语言转换成机器语言之后，助记符就不再存在了，因此机器语言中的跳转使用的是确定的地址。下图中的main+0x29就表明要跳转到距main函数偏移量为0x29的位置。 （3）函数调用的不一致：hello.s中的函数调用直接在call指令后面加上要调用的函数名。 但是在机器语言中，call指令后是被调函数的PC相对地址。在这里，由于调用的函数都是库函数，需要在动态链接后才能确定被调函数的确切位置，因此call指令后的二进制码为全0，同时需要在重定位节中添加重定位条目，在链接时确定最终的相对地址。 4.5本章小结 本章介绍了汇编的概念和作用，通过对比hello.s和hello.o分析了汇编的过程，同时分析了可重定位目标文件的ELF格式。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据的片段收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在现代系统中，链接由链接器程序自动执行。链接包括两个主要任务：符号解析和重定位。 链接是十分重要，不可或缺的，在软件开发中扮演着一个关键的角色，因为它使得分离编译成为可能。无需将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块，极大地提高了大型程序编写的效率。 5.2在Ubuntu下链接的命令 链接的命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 链接过程如图所示： 图5-1链接命令 5.3可执行目标文件hello的格式 使用readelf命令readelf-ahello>helloldelf.txt查看可执行目标文件hello的ELF格式，并将结果重定向到helloldelf.txt便于查看分析。 图5-2查看helloELF格式的命令 5.3.1ELF头 ELF头以一个16字节的目标序列开始，如图中Magic所示，这个序列描述了生成该文件的系统的字的大小和字节顺序。以hello为例，这个16字节序列为7f454c46020101000000000000000000，描述了系统的字的大小为8字节，字节顺序为小端序。 ELF头剩下的部分包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量。以hello为例，ELF头中包含了ELF头的大小：64字节；目标文件的类型：EXEC（可执行文件）；机器类型：AdvancedMicroDevicesX86-64；节头部表的文件偏移：4032bytes；节头部表中条目的数量：25。同时，ELF头中还包括程序的入口点（偏移量64字节），即程序运行时要执行的第一条指令的地址。 图5-3hello的ELF头 5.3.2节头部表 节头部表描述不同节的位置和大小，目标文件中的每个节都有一个固定大小的节头部表条目。 与hello.o相比，hello的节头部表一共描述了25个不同节的位置、大小等信息，比hello.o多出12个节。各节的起始地址由偏移量给出，同时也给出了大小等信息。 图5-4hello的节头部表 5.3.3程序头部表 程序头部表描述了可执行文件的连续的片映射到连续的内存段的映射关系。包括目标文件的偏移、段的读写/执行权限、内存的开始地址、对齐要求、段的大小、内存中的段大小等。 以hello中的第一个LOAD为例，Offset说明段的偏移量为0；VirtAddr说明映射到的虚拟内存段的开始地址是0x400000；FileSiz说明段的大小为0x720字节；Memsiz说明内存中的段大小也是0x720字节；Flags为RE，标志段的权限为只读且可执行；Align说明段的对齐要求为200000。 图5-5hello的程序头部表 5.3.4符号表 符号表存放程序中定义和引用的函数和全局变量的信息，每个符号表是一个条目的数组，每个条目包括value：距定义目标的节的起始位置的偏移；size：目标的大小；type：指明数据还是函数；bind：表示符号是本地的还是全局的等等。 hello的符号表一共描述了48符号，比hello.o多出32个符号。多出的符号都是链接后产生的库中的函数以及一些必要的启动函数。 图5-6hello的符号表 hello中还多出了一个动态符号表，表中的符号都是共享库中的函数，需要动态链接。 图5-7hello的动态符号表 5.3.5重定位节 重定位条目包括offset：需要被修改的引用的节偏移；symbol：标识被修改引用应该指向的符号；type：重定位类型，告知链接器如何修改新的引用；attend：一些重定位要使用它对被修改引用的值做偏移调整。ELF定义了32种不同的重定位类型，两种最基本的重定位类型包括R_X86_64_PC32（重定位使用32位PC相对地址的引用）和R_X86_64_32（重定位使用32位绝对地址的引用）。 在hello中，原来的.rela.text节已经没有了，说明链接的过程已经完成了对.rela.text的重定位操作。Hello中出现了6个新的重定位条目。这些重定位条目都和共享库中的函数有关，因为此时还没有进行动态链接，共享库中函数的确切地址仍是未知的，因此仍然需要重定位节，在动态链接后才能确定地址。 图5-8hello的重定位节 5.4hello的虚拟地址空间 使用edb加载hello，可以看到进程的虚拟地址空间各段信息。可以看出，段的虚拟空间从0x400000开始，到0x400ff0结束。 图5-9edb查看hello的虚拟地址空间 由5.3中的节头部表可以获得各个节的偏移量信息，从而得知各节在虚拟地址空间中的地址。 例如，对于.interp节，节头部表中给出了它的偏移量为0x1c8，大小为0x1c字节。 因此它的虚拟地址空间就从0x4001c8开始，在edb中查看该虚拟内存地址，可以看出，.interp节确实在这个位置。 图5-10edb查看.interp的虚拟地址 类似地，对于.rodata节，节头部表中给出了它的偏移量为0x600，大小为0x2f字节。 因此它的虚拟地址空间就从0x400600开始，在edb中查看该虚拟内存地址，可以看出，.rodata节确实在这个位置，程序中的两个字符串常量就存储在这里。 图5-11edb查看.rodata的虚拟地址 对于.data节，节头部表中给出了它的偏移量为0x900，大小为0x8字节。 因此它的虚拟地址空间就从0x400900开始，在edb中查看该虚拟内存地址，可以看出，.data节确实在这个位置，程序中的全局变量sleepsecs就存储在这里，并且值为2。 图5-12edb查看.data的虚拟地址 对于.text节，节头部表中给出了它的偏移量为0x4d0，大小为0x122字节。 因此它的虚拟地址空间就从0x4004d0开始，在edb中查看该虚拟内存地址，可以看出，.text节确实在这个位置，第一条指令的二进制机器码的第一个字节为0x31。 图5-13edb查看.text的虚拟地址 对于其他的节同理，不再赘述。 5.5链接的重定位过程分析 使用命令objdump-d-rhello>hellold.txt对hello进行反汇编，并将结果重定向到hellold.txt中便于查看分析。hello与hello.o的不同之处在于以下几个方面： （1）hello中的汇编代码已经使用虚拟内存地址来标记了，从0x400000开始；而hello.o中的汇编代码是从0开始的，还没有涉及到虚拟内存地址。 （2）在hello.o中，只存在main函数的汇编指令；而在hello中，由于链接过程中发生重定位，引入了其他库的各种数据和函数，以及一些必需的启动/终止函数，因此hello中除了main函数的汇编指令外，还包括大量其他的指令。 （3）main函数中涉及重定位的指令的二进制代码被修改。在之前汇编的过程中，汇编器遇到对最终位置未知的目标引用，会产生一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。因此在链接的过程中，链接器会根据重定位条目以及已知的最终位置对修改指令的二进制码，这个过程就是重定位的过程。下面以hello.o为例，说明hello如何进行重定位。 查看hello.o中的重定位条目，重定位条目给出了需要被修改的引用的节偏移、重定位类型、偏移调整等信息。 图5-14hello.o的重定位节 这里涉及到两种不同的重定位类型，分别是R_X86_64_PC32（重定位使用32位PC相对地址的引用）和R_X86_64_32（重定位使用32位绝对地址的引用）。对于第一种重定位类型，以第一个条目为例，第一个条目的信息说明需要重定位的位置在.text中偏移量为0x1b的地方。在hello.o中找到相应的位置： 图5-15条目1的重定位位置 这条指令的目的是将某一个数传送到%edi中，使其作为printf的参数。由源程序可知，这个指令对应与语句为printf("Usage:Hello学号姓名！\n");因此参数应该是字符串常量"Usage:Hello学号姓名！\n"的地址。由于字符串常量的最终位置未知，因此产生了一个重定位条目。而重定位的目的就是修改这个数据，使得传入%edi的是"Usage:Hello学号姓名！\n"的最终地址。同时，重定位类型为R_X86_64_32，因此地址为绝对地址。由5.4可知，该字符串常量的地址为0x400604，因此重定位会将这条指令的最后四个字节改为04064000（小端形式的地址）。查看hello的反汇编结果，确实是这样的。 图5-16条目1的重定位结果 对于第二种重定位类型，以第二个条目为例，第二个条目的信息说明需要重定位的位置在.text中偏移量为0x1b的地方。在hello.o中找到相应的位置： 图5-17条目2的重定位位置 这条指令的目的是调用函数puts。由于函数puts的最终位置未知，因此产生了一个重定位条目。而重定位的目的就是修改这个数据，使得call指令的地址为puts函数的起始地址。同时，重定位类型为R_X86_64_PC32，因此地址为相对地址。从hello的反汇编结果可以获得puts函数的地址为0x400460。 图5-18puts函数的位置 而这条call指令的地址为0x400514，它的下一条指令的地址为0x400519. 图5-19call指令的位置 因此相对地址为0x400460–0x400519=0xffffff47。因此重定位会将这条指令的最后四个字节改为47ffffff（小端形式的地址）。查看hello的反汇编结果，确实是这样的。 图5-20条目2的重定位结果 5.6hello的执行流程 从加载hello到_start，到callmain，以及程序终止的所有过程中调用的子程序名以及程序地址（调用顺序为从上到下）： 名称地址ld-2.23.so!_dl_start0x7f7c8a4619b0ld-2.23.so!dl_init0x7f7c8a470780hello!_start0x4004d0hello!__libc_start_main0x400480libc-2.23.so!__libc_start_main0x7f7c8a0b6750libc-2.23.so!cxa_atexit0x7f7c8a0d0290hello!__libc_csu_init0x400580hello!_init0x400430libc-2.23.so!_setjmp0x7f7c8a0cb260libc-2.23.so!_sigsetjmp0x7f7c8a0cb1c0hello!main0x4004fahello!puts@plt0x400460hello!exit@plt0x4004a0hello!printf@plt0x400470hello!sleep@plt0x4004b0hello!getchar@plt0x400490ld-2.23.so!_dl_runtime_resolve_avx0x7f7c8a477870libc-2.23.so!exit0x7f4ea0c8d5b0 5.7Hello的动态链接分析 当程序调用一个由共享库定义的函数时，编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。但这需要链接器修改调用模块的代码段，GNU编译系统使用一种称为延迟绑定的技术将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定是通过两个数据结构之间的交互来实现的，分别是GOT和PLT，GOT是数据段的一部分，而PLT是代码段的一部分。PLT与GOT的协作可以在运行时解析函数的地址，实现函数的动态链接。 过程链接表PLT是一个数组，每个条目是16字节代码。PLT[0]是一个特殊条目，跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。由5.3.2中的节头部表知，存储PLT的.plt节的开始地址为0x400450. 在hello的反汇编结果中可以查看到每个PLT条目。PLT[0]是一个特殊条目，跳转到动态链接器中。接下来每个条目对应一个调用的库函数，例如PLT[1]对应的是puts函数；PLT[2]对应的是printf函数…… 图5-21hello的PLT条目 全局偏移量表GOT是一个数组，每个条目为8字节地址，和PLT联合使用。GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息，GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。由5.3.2中的节头部表知，存储GOT的.got.plt节的开始地址为0x6008b8. 在edb中查看初始时的GOT条目（如图5-22）。除了PLT[0]外，每个PLT对应的GOT条目初始时都指向这个PLT的第二条指令。例如：如图5-21，PLT[1]对应地址0x6008d0处的GOT[3]，而0x6008d0处的值为0x400466，恰好指向PLT[1]的第二条指令。在函数第一次被调用时，动态链接器会修改相应的GOT条目。 图5-22hello的初始GOT条目 同时也可以看到，GOT[1]和GOT[2]这两个条目初始时均为0。而GOT[1]应该包含动态链接器在解析函数地址时会使用的信息，GOT[2]应该为动态链接器在1d-linux.so模块中的入口点。使用edb调试，当dl_start函数返回后，发现这两个条目被修改为正确的值。 图5-23dl_start后的GOT条目 在函数第一次被调用时，动态链接器会修改相应的GOT条目。以puts函数为例，puts函数对应的是PLT[1]，PLT[1]对应地址0x6008d0处的GOT[3]，而GOT[3]的初始值为0x400466，指向PLT[1]的第二条指令。当第一次调用puts时，动态链接器确定puts的运行时位置，用这个地址重写GOT[3]。这时，puts函数才真正完成动态链接，后续对puts的调用就可以直接根据GOT[3]的值进行跳转。 图5-24第一次调用puts后的GOT条目 5.8本章小结 本章介绍了链接的概念与作用，简要分析了可执行文件的ELF格式，hello的虚拟地址空间和执行流程，同时详细地分析了静态链接的重定位过程以及动态链接的过程。至此，一个完美的生命 hello诞生了。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。通过进程的概念提供给我们一个假象，就好像我们的程序是系统中运行的唯一的程序；程序好像独占地使用处理器和内存；处理器好像是无间断地一条接一条地执行程序中的指令；程序的代码和数据好像是系统内存中唯一的对象。 其中上下文是由程序正确运行所需的状态组成的，包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。 6.2简述壳Shell-bash的作用与处理流程 shell是指为使用者提供操作界面的软件，是一个交互型应用级程序，它接收用户命令，然后调用相应的应用程序。shell是系统的用户界面，提供了用户与内核进行交互操作的接口。 shell的作用：shell最重要的功能是命令解释，可以说shell是一个命令解释器。Linux系统上的所有可执行文件都可以作为shell命令来执行，同时它也提供一些内置命令。此外，shell还包括通配符、命令补全、命令历史、重定向、管道、命令替换等很多功能。 shell的处理流程：从终端读入输入的命令行->解析输入的命令行，获得命令行指定的参数->检查命令是否是内置命令，如果是内置命令则立即执行，否则在搜索路径里寻找相应的程序，找到该程序就执行它。 6.3Hello的fork进程创建过程 当在shell中输入命令“./hello1190200817刘小川”时，shell解析输入的命令行，获得命令行指定的参数。由于./hello不是shell内置的命令，因此shell将hello看作一个可执行目标文件，在相应路径里寻找hello程序，找到该程序就执行它。shell会通过调用fork()函数创建一个子进程，新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同但独立的一个副本，包括代码段、数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，子进程可以读写父进程中打开的任何文件。父进程和子进程之间最大的区别在于它们的PID不同。hello程序之后就会运行在这个新创建的子进程的上下文中。 6.4Hello的execve过程 shell创建一个子进程之后，这个子进程仍然是父进程的一个副本，因此需要在子进程中调用exceve()函数在当前进程的上下文中加载并运行我们需要的hello程序。execve函数加载并运行可执行文件filename，且带参数列表argv和环境变量envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。 execve函数用hello程序有效替代当前程序，需要以下几个步骤： （1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 （2）映射私有区域。为新程序（即hello）的代码、数据、bss和栈区域等创建新的区域结构。所有这些区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。 （3）映射共享区域。如果hello程序与共享对象（或目标）链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 （4）设置程序计数器。最后设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 当内核调度这个进程时，它就将从这个入口点开始执行。Linux根据需要换入代码和数据页面。 6.5Hello的进程执行 当子进程调用exceve()函数在上下文中加载并运行hello程序后，hello程序不会立即运行，需要内核调度它。进程调度是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，使用一种称为上下文切换的机制来将控制转移到新的进程。上下文切换包括：保存当前进程的上下文；恢复某个先前被抢占的进程被保存的上下文；将控制传递给这个新恢复的进程。其中上下文指的是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构（页表、进程表、文件表等）。 处理器提供了一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。通常用某个控制寄存器的一个模式位来提供这种机制，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程运行在内核模式中，进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置；没有设置模式位时，进程运行在用户模式中，进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据，否则会导致保护故障。运行应用程序代码的进程初始时在用户模式中，进程需要通过中断、故障或者陷入系统调用这样的异常才能从用户模式变为内核模式。 由于负责进程调度的是内核，因此内核调度需要运行在内核模式下。当内核代表用户执行系统调用时，可能会发生上下文切换，中断也可能引发上下文切换。同时，系统通过某种产生周期性定时器中断的机制判断当前进程已经运行了足够长的时间，并切换到一个新的进程。 以hello的进程执行为例。当子进程调用exceve()函数在上下文中加载并运行hello程序后，hello进程等待内核调度它。当内核决定调度hello进程时，它就抢占当前进程，进行上下文切换，将控制转移到hello进程，并从内核模式变为用户模式，这时hello进程开始运行应用程序代码。当hello进程调用sleep时，由于sleep是系统调用，进程陷入内核模式。这时hello进程被挂起，内核会选择调度其他进程，通过上下文切换保存hello进程的上下文，将控制传递给新调度的进程。定时器的时间到了后会发送中断信号，进入内核模式，将挂起的hello进程变成运行状态，这时hello进程就可以等待内核调度它。当内核再次调度hello进程时，恢复保存的hello进程的上下文，就可以从刚才停止的地方继续执行了。当hello调用getchar的时候同样会陷入内核模式，由于getchar需要来自键盘的DMA传输，时间很长，因此内核不会等待DMA完成，而是去调度其他进程。当DMA完成后，会向处理器发送中断信号，进入内核模式，内核知道DMA完成了，就可以再次调度hello进程了。 6.6hello的异常与信号处理 6.6.1可能出现的异常及处理方法 hello执行过程中，四类异常都可能会出现，四类异常分别为： 类别原因异步/同步返回行为中断来自I/O设备的信号异步总是返回到下一条指令陷阱有意的异常同步总是返回到下一条指令故障潜在可恢复的错误同步可能返回到当前指令终止不可恢复的错误同步不会返回 hello执行过程中发生中断：如果其他进程使用了外部I/O设备，那么在hello进程运行时可能会出现外部I/O设备引起的中断。中断的处理：将控制传递给适当的中断处理程序，处理程序返回时，就将控制返回给下一条指令，程序继续执行，好像没有发生过中断一样。 hello执行过程中发生陷阱：hello中调用了系统调用sleep，产生陷阱。陷阱的处理：将控制传递给适当的异常处理程序，处理程序解析参数，调用适当的内核程序。处理程序返回时，将控制返回给下一条指令。 hello执行过程中发生故障：当hello进程刚从入口点开始执行时，会发生缺页故障。hello进程运行的过程中，也可能发生缺页故障。故障的处理：将控制传递给故障处理程序，如果处理程序能够修正这个错误情况，就将控制返回到引起故障的指令并重新执行它；否则终止引起故障的应用程序。 hello执行过程中发生错误：hello执行过程中，DRAM或者SRAM可能发生位损坏，产生奇偶错误。发生错误时会将控制传递给终止处理程序，终止引起错误的应用程序。 6.6.2可能产生的信号及处理方法 hello执行过程中，可能产生的信号如：SIGINT，SIGTSTP，SIGCHLD，SIGKILL，SIGALRM等等。进程接受到信号时，会触发控制传递到信号处理程序，信号处理程序运行，信号处理程序返回后，将控制返回给被中断的程序。每个信号类型有相关联的默认行为，使用signal函数可以修改和信号相关联的行为。 下面以hello的运行过程为例，简要说明异常与信号的处理。 （1）程序运行过程中不停乱按键盘，包括回车。如果乱按不包括回车，输入的字符串会缓存到缓冲区；如果输入的最后是回车，则getchar会读进回车，把回车前的字符串作为输入shell的命令， 图6-1程序运行过程中不停乱按键盘，包括回车 （2）程序运行过程中键入Ctrl-Z。键入Ctrl-Z会发送SIGTSTP信号给前台进程组的每个进程，结果是停止前台作业，也就是停止hello进程。 图6-2键入Ctrl-Z 使用jobs命令可以查看当前的作业，可以看出当前的作业是hello进程，且状态是已停止 图6-3jobs命令 使用ps命令可以查看当前所有进程以及它们的PID，进程包括bash，hello以及ps。 图6-4ps命令 使用pstree命令将所有进程以树状图形式显示。 图6-5pstree命令 使用fg命令可以使停止的hello进程继续在前台运行。也可以再次键入Ctrl-Z停止hello的运行。 图6-6fg命令 使用kill命令可以给指定进程发送信号。比如kill-98329是指向PID为8329的进程（即hello）发送SIGKILL信号。这个命令会杀死hello进程，当再次使用ps时可以发现hello进程已经被杀死，使用jobs指令也看不到当前的作业了。 图6-7kill命令 （3）程序运行过程中键入Ctrl-C。键入Ctrl-C会发送SIGINT信号给前台进程组的每个进程，结果是终止前台进程，即终止hello进程。 图6-8键入Ctrl-C 使用ps命令可以发现，hello进程已经终止并被回收，不再存在了。使用jobs指令也看不到当前的作业了。 图6-9ps,jobs命令 6.7本章小结 本章介绍了进程的概念和作用，简述shell的工作过程，并分析了使用fork+execve加载运行hello，执行hello进程以及hello进程运行时的异常/信号处理过程。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：逻辑地址是指由程序产生的与段相关的偏移地址部分。例如，在进行C语言指针编程中，可以使用&操作读取指针变量的值，这个值就是逻辑地址，是相对于当前进程数据段的地址。一个逻辑地址由两部份组成：段标识符和段内偏移量。 线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址生成了一个线性地址。如果启用了页式管理，那么线性地址可以再变换产生物理地址。若没有启用页式管理，那么线性地址直接就是物理地址。 虚拟地址：因为虚拟内存空间的概念与逻辑地址类似，因此虚拟地址和逻辑地址实际上是一样的，都与实际物理内存容量无关。 物理地址：存储器中的每一个字节单元都给以一个唯一的存储器地址，用来正确地存放或取得信息，这个存储器地址称为物理地址，又叫实际地址或绝对地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址由段标识符和段内偏移量两部分组成。段标识符由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号，是对段描述符表的索引，每个段描述符由8个字节组成，具体描述了一个段。后3位包含一些硬件细节，表示具体是代码段寄存器还是栈段寄存器还是数据段寄存器等。通过段标识符的前13位，可以直接在段描述符表中索引到具体的段描述符。每个段描述符中包含一个Base字段，它描述了一个段的开始位置的线性地址。将Base字段和逻辑地址中的段内偏移量连接起来就得到转换后的线性地址。 对于全局的段描述符，放在全局段描述符表中，局部的（每个进程自己的）段描述符，放在局部段描述符表中。全局段描述符表的地址和大小存放在gdtr控制寄存器中，而局部段描述符表存放在ldtr寄存器中。 给定逻辑地址，看段选择符的最后一位是0还是1，用于判断选择全局段描述符表还是局部段描述符表。再根据相应寄存器，得到其地址和大小。通过段标识符的前13位，可以在相应段描述符表中索引到具体的段描述符，得到Base字段，和段内偏移量连接起来最终得到转换后的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 页表是一个页表条目（PTE）的数组，虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。每个PTE由一个有效位和一个n位地址字段组成，有效位表明该虚拟页是否被缓存在DRAM中。如果设置了有效位，那么地址字段表示相应的物理页的起始位置；如果没有设置有效位，那么空地址表示虚拟页还未被分配，否则这个地址指向该虚拟页在磁盘的起始位置。 MMU利用页表实现从虚拟地址到物理地址的变换。CPU中的一个控制寄存器，页表基址寄存器指向当前页表。n位的虚拟地址包含一个p位的虚拟页面偏移VPO和一个n-p位的虚拟页号VPN。MMU利用VPN选择适当的PTE，如果这个PTE设置了有效位，则页命中，将页表条目中的物理页号和虚拟地址中的VPO连接起来就得到相应的物理地址。否则会触发缺页异常，控制传递给内核中的缺页异常处理程序。缺页处理程序确定物理内存中的牺牲页，调入新的页面，并更新内存中相应PTE。处理程序返回到原来的进程，再次执行导致缺页的指令，MMU重新进行地址翻译，此时和页命中的情况一样。同时，也可以利用TLB缓存PTE加速地址的翻译。 图7-1线性地址到物理地址的变换 7.4TLB与四级页表支持下的VA到PA的变换 TLB的支持：在MMU中包括一个关于PTE的缓存，称为翻译后备缓冲器（TLB）。TLB是一个小的、虚拟寻址的缓存，每一行保存着一个由单个PTE组成的块。由于VA到PA的转换过程中，需要使用VPN确定相应的页表条目，因此TLB需要通过VPN来寻找PTE。和其他缓存一样，需要进行组索引和行匹配。如果TLB有2t个组，那么TLB的索引TLBI由VPN的t个最低位组成，TLB标记TLBT由VPN中剩余的位组成。 图7-2TLB 当MMU进行地址翻译时，会先将VPN传给TLB，看TLB中是否已经缓存了需要的PTE，如果TLB命中，可以直接从TLB中获取PTE，将PTE中的物理页号和虚拟地址中的VPO连接起来就得到相应的物理地址。这时所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。如果TLB不命中，那和7.3中描述的过程类似，需要从cache或者内存中取出相应的PTE。 图7-3TLB支持下的线性地址到物理地址的变换 四级页表的支持：多级页表可以用来压缩页表，对于k级页表层次结构，虚拟地址的VPN被分为k个，每个VPNi是一个到第i级页表的索引。当1≤j≤k-1时，第j级页表中的每个PTE指向某个第j+1级页表的基址。第k级页表中的每个PTE和未使用多级页表时一样，包含某个物理页面的PPN或者一个磁盘块的地址。对于IntelCorei7，使用了4级页表，每个VPNi有9位。当TLB未命中时，36位的VPN被分为VPN1、VPN2、VPN3、VPN4，每个VPNi被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址，VPN1提供到一个L1PTE的偏移量，这个PTE包含某个L2页表的基址。VPN2提供到这个L2页表中某个PTE的偏移量，以此类推。最后得到的L4PTE包含了需要的物理页号，和虚拟地址中的VPO连接起来就得到相应的物理地址。 图7-4四级页表支持下的线性地址到物理地址的变换 7.5三级Cache支持下的物理内存访问 当MMU完成了从虚拟地址到物理地址的转换后，就可以使用物理地址进行内存访问了。IntelCorei7使用了三级cache来加速物理内存访问，L1级cache作为L2级cache的缓存，L2级cache作为L3级cache的缓存，而L3级cache作为内存（DRAM）的缓存。 进行物理内存访问时，会首先将物理地址发送给L1级cache，看L1级cache中是否缓存了需要的数据。L1级cache共64组，每组8行，块大小64B。因此将物理地址分为三部分，块偏移6位，组索引6位，剩下的为标记位40位。首先利用组索引位找到相应的组；然后在组中进行行匹配，对于组中的8个行，分别查看有效位并将行的标记位与物理地址的标记位匹配，当标记位匹配且有效位是1时，缓存命中，根据块偏移位可以直接将cache中缓存的数据传送给CPU。如果缓存不命中，需要继续从存储层次结构中的下一层中取出被请求的块，将新块存储在相应组的某个行中，可能会替换某个缓存行。 L1级cache不命中时，会继续向L2级cache发送数据请求。和L1级cache的过程一样，需要进行组索引、行匹配和字选择，将数据传送给L1级cache。同样L2级cache不命中时，会继续向L3级cache发送数据请求。最后，L3级cache不命中时，只能从内存中请求数据了。 值得注意的是，三级cache不仅仅支持数据指令的访问，也支持页表条目的访问，在MMU进行虚拟地址到物理地址的翻译过程中，三级cache也会起作用。 图7-5三级Cache下的物理内存访问 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。内核给新进程创建虚拟内存，创建当前进程的mm_struct、区域结构和页表的原样副本，将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，为每个进程保持了私有地址空间的抽象概念。同时延迟私有对象中的副本直到最后可能的时刻，充分利用了稀有的物理内存。 7.7hello进程execve时的内存映射 exceve()函数在当前进程的上下文中加载并运行我们需要的hello程序。execve函数加载并运行可执行文件filename，且带参数列表argv和环境变量envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。 execve函数用hello程序有效替代当前程序，需要以下几个步骤： （1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 （2）映射私有区域。为新程序（即hello）的代码、数据、bss和栈区域等创建新的区域结构。所有这些区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。 （3）映射共享区域。如果hello程序与共享对象（或目标）链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 （4）设置程序计数器。最后设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 当内核调度这个进程时，它就将从这个入口点开始执行。Linux根据需要换入代码和数据页面。 图7-6execve时的内存映射 7.8缺页故障与缺页中断处理 缺页故障的产生：CPU产生一个虚拟地址给MMU，MMU经过一系列步骤获得了相应的PTE，当PTE的有效位未设置时，说明虚拟地址对应的内容还没有缓存在内存中，这时MMU会触发缺页故障。 缺页故障的处理：缺页异常导致控制转移到内核的缺页处理程序。处理程序随后执行以下步骤：（1）判断虚拟地址是否合法。缺页处理程序搜索区域结构的链表，把虚拟地址和每个区域结构中的vm_start和vm_end做比较。如果指令不合法，缺页处理程序会触发一个段错误，从而终止这个进程。（2）判断内存访问是否合法。比如缺页是否由一条试图对只读页面进行写操作的指令造成的。如果访问不合法，缺页处理程序会触发一个保护异常，从而终止这个进程。（3）这时，内核知道缺页是由合法的操作造成的。内核会选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。处理程序返回时，CPU重新执行引起缺页的指令，这条指令将再次发送给MMU。这次，MMU能正常地进行地址翻译，不会再产生缺页中断了。 图7-7缺页中断处理 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间的细节不同，但不失通用性，假设堆是一个请求二进制零的区域，紧接在未初始化数据区域后开始，向上生长。对每个进程，内核维护一个全局变量brk指向堆顶。分配器将堆视为一组不同大小的块的集合来维护。每个块是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留，供应用程序使用；空闲块可用来分配。空闲块保持空闲，直到空闲块显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的（即显式分配器），要么是内存分配器自身隐式执行的（即隐式分配器）。显式分配器和隐式分配器是动态内存分配器的两种基本风格。两种风格都要求应用显式地分配块，不同之处在于由哪个实体来负责释放已分配的块。显式分配器要求应用显式地释放任何已分配的块。隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集。 图7-8动态内存分配的区域 堆 显式分配器必须在一些约束条件下工作：处理任意请求序列；立即响应请求；只使用堆；对齐要求；不修改已分配的块。在这些限制条件下，分配器试图实现吞吐率最大化和内存使用率最大化，但这两个性能目标通常是相互冲突的。 分配器的具体操作过程以及相应策略： （1）放置已分配块：当一个应用请求一个k字节的块时，分配器搜索空闲链表。查找一个足够大可以放置所请求的空闲块。执行这种搜索的常见策略包括首次适配、下一次适配和最佳适配等。 （2）分割空闲块：一旦分配器找到了匹配的空闲块，需要决定分配这个空闲块中多少空间。可以选择用整个块，但会造成额外的内部碎片；也可以选择将空闲块分割为两部分，第一部分变成已分配块，剩下的变成新的空闲块。 （3）获取额外的堆内存：如果分配器不能为请求块找到空闲块，分配器通过调用sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块，将这个块插到空闲链表中，然后被请求的块放在这个新的空闲块中。 （4）合并空闲块：分配器释放一个已分配块时，要合并相邻的空闲块。分配器决定何时执行合并，可以选择立即合并或者推迟合并。合并时需要合并当前块和前面以及后面的空闲块。 组织空闲块的形式有很多，包括隐式空闲链表、显式空闲链表、分离的空闲链表等等。 带边界标签的隐式空闲链表分配器：一个块由一个字的头部、有效载荷、可能的一些额外的填充以及一个脚部。头部位于块的开始，编码了这个块的大小（包括头部、脚部和所有的填充）以及这个块是已分配的还是空闲的。由于对齐要求，头部的高位可以编码块的大小，而剩余的几位（取决于对齐要求）总是零，可以编码其他信息。使用最低位作为已分配位，指明这个块是已分配的还是空闲的。脚部位于每个块的结尾，是头部的一个副本，是为了方便释放块时的合并操作。头部后面就是调用分配器时请求的有效载荷，有效载荷后面是一片不使用的填充块，其大小可以是任意的。填充的原因取决于分配器的策略。如果块的格式是如上所述，就可以将堆组织成一个连续的已分配块和空闲块的序列，这种结构为隐式空闲链表。空闲块通过头部的大小字段隐含地连接，可以通过遍历堆中所有的块间接遍历整个空闲块的集合。同时，需要一个特殊标记的结束块（设置分配位而大小为零的头部），这种设置简化了空闲块合并。 图7-9隐式链表的块结构 显式空间链表：已分配块的块结构和隐式链表的相同，由一个字的头部、有效载荷、可能的一些额外的填充以及一个脚部组成。而在每个空闲块中，增加了一个前驱指针和后继指针。通过这些指针，可以将空闲块组织成一个双向链表。空闲链表中块的排序策略包括后进先出顺序、按照地址顺序维护、按照块的大小顺序维护等。显式空闲链表降低了放置已分配块的时间，但空闲块必须足够大，以包含所需要的指针、头部和脚部，这导致了更大的最小块大小，潜在提高内部碎片程度。 图7-10显式链表的块结构 而malloc采用的是分离的空闲链表。分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小升序排列，当分配器需要一个大小为n的块时，就搜索相应大小类对应的空闲链表。如果不能找到合适的块，就搜索下一个链表，以此例推。 7.10本章小结 本章总结了hello运行过程中有关内存管理的内容。简述了TLB、多级页表支持下的地址翻译、cache支持下的内存访问、缺页的处理、fork+execve过程的内存映射以及动态存储分配的过程。 （第7章2分) 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m个字节的序列： B0,B1,B2……Bm-1 所有的IO设备（例如网络、磁盘和终端）都被模型化为文件，所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，使得所有的输入和输出都能以一种统一且一致的方式来执行。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixIO接口，使得所有的输入和输出都能以一种统一且一致的方式来执行： （1）打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，即描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 （2）Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件中的常量可以代替显式的描述符值。 （3）改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 （4）读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发EOF条件，应用程序能检测到这个条件。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 （5）关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数: （1）进程通过调用open函数打开一个存在的文件或者创建一个新文件。 intopen(char*filename,intflags,mode_tmode); open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件；mode参数指定了新文件的访问权限位。 （2）进程通过调用close函数关闭一个打开的文件。 intclosefd; fd是需要关闭的文件描述符，成功返回0，错误返回-1。关闭一个已关闭的描述符会出错。 （3）应用程序通过分别调用read和write函数来执行输入和输出。 ssize_tread(intfd,void*buf,size_tn); ssize_twirte(intfd,constvoid*buf,size_tn); read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则返回值表示的是实际传送的字节数量。write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 printf的源代码： int printf(const char *fmt,  ) { int i; char buf[256]; va_list arg = (va_list)((char*)(&fmt) + 4); i = vsprintf(buf, fmt, arg); write(buf, i); return i; } printf函数是格式化输出函数,一般用于向标准输出设备按规定格式输出信息。printf中调用了两个函数，分别为vsprintf和write。 vsprintf函数根据格式串fmt，并结合args参数产生格式化之后的字符串结果保存在buf中，并返回结果字符串的长度。 write函数将buf中的i个字符写到终端，由于i保存的是结果字符串的长度，因此write将格式化后的字符串结果写到终端。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar的源代码： int getchar(void) { static char buf[BUFSIZ]; static char* bb=buf; static int n=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsigned char)*bb++:EOF; } getchar函数会从stdin输入流中读入一个字符。调用getchar时，会等待用户输入，输入回车后，输入的字符会存放在缓冲区中。第一次调用getchar时，需要从键盘输入，但如果输入了多个字符，之后的getchar会直接从缓冲区中读取字符。getchar的返回值是读取字符的ASCII码，若出错则返回-1。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章介绍了Linux的IO设备管理方法和UnixIO接口及其函数，并分析了printf和getchar函数的实现。 （第8章1分） 结论 hello所经历的过程： 源程序：在文本编辑器或IDE中编写C语言代码，得到最初的hello.c源程序。 预处理：预处理器解析宏定义、文件包含、条件编译等，生成ASCII码的中间文件hello.i。 编译：编译器将C语言代码翻译成汇编指令，生成一个ASCII汇编语言文件hello.s。 汇编：汇编器将汇编指令翻译成机器语言，并生成重定位信息，生成可重定位目标文件hello.o。 链接：链接器进行符号解析、重定位、动态链接等创建一个可执行目标文件hello。此时，hello才真正地可以被执行。 fork创建进程：在shell中运行hello程序时，shell会调用fork函数创建子进程，供之后hello程序的运行。 execve加载程序：子进程中调用execve函数，加载hello程序，进入hello的程序入口点，hello终于要开始运行了。 运行阶段：内核负责调度进程，并对可能产生的异常及信号进行处理。MMU、TLB、多级页表、cache、DRAM内存、动态内存分配器相互协作，共同完成内存的管理。UnixI/O使得程序与文件进行交互。 终止：hello进程运行结束，shell负责回收终止的hello进程，内核删除为hello进程创建的所有数据结构。hello的一生到此结束，没有留下一丝痕迹。 对计算机系统的设计与实现的深切感悟： hello从诞生到结束，经历了千辛万苦，在硬件、操作系统、软件的相互协作配合下，终于完美地完成了它的使命。这让我认识到，一个复杂的系统需要多方面的协作配合才能更好地实现功能。同时，计算机系统提供的一系列抽象使得实际应用与具体实现相互分离，可以很好地隐藏实现的复杂性，降低了程序员的负担，使得程序更加容易地编写、分析、运行。这让我认识到抽象是十分重要的，是计算机科学中最为重要的概念之一。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.i：C预处理器产生的一个ASCII码的中间文件，用于分析预处理过程。 hello.s：C编译器产生的一个ASCII汇编语言文件，用于分析编译的过程。 hello.o：汇编器产生的可重定位目标程序，用于分析汇编的过程。 hello：链接器产生的可执行目标文件，用于分析链接的过程。 hello.txt：hello.o的反汇编文件，用于分析可重定位目标文件hello.o。 hellold.txt：hello的反汇编文件，用于分析可执行目标文件hello。 helloelf.txt：hello.o的ELF格式，用于分析可重定位目标文件hello.o。 helloldelf.txt：hello的ELF格式，用于分析可执行目标文件hello。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] RANDALE.BRYANT,DAVIDR.O‘HALLARON.深入理解计算机系统[M].机械工业出版社,2011. [2] https://www.cnblogs.com/clover-toeic/p/3851102.html [3] https://www.runoob.com/linux/linux-comm-pstree.html [4] https://www.runoob.com/cprogramming/c-function-vsprintf.html [5] https://www.cnblogs.com/pianist/p/3315801.html （参考文献0分，缺失-1分） 
第155篇文章[]
接口中的default方法 复习的时候看到了interface还可以用default声明方法，学习了一下。Java8接口中也允许使用default关键字来定义并实现实例方法，这个应用有点类似于抽象类的功能。 通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它。上一个小例子： packageexample; interfaceIntefercaeExample{ defaultvoidshowDefault(){ System.out.println("hello"); } staticvoidshowStatic(){ System.out.println("haha"); } //没有实现的抽象方法 voidsayHi(); } classSometryimplementsIntefercaeExample{ @Override publicvoidsayHi(){ System.out.println("Hi"); } publicstaticvoidmain(String[]args){ IntefercaeExample.showStatic(); SometrylearnDefault=newSometry(); //被Default所修饰的具体方法可以通过引用变量来调用 learnDefault.showDefault(); learnDefault.sayHi(); } } 输出结果： 
第156篇文章[]
正则表达式笔记 基本语法跟形式语言课程中学的差不多，但java正则表达式的符号数量远远多于+，*，和连接。符号表网上可查，比较常用的有 （图片资源来源网络） 但实验中出现了一种特殊符号，好像是中文空格，它无法用\s识别，只能复制粘贴到正则表达式中，所以一定要注意文件格式和其中的缩进形式。 根据JavaLanguageSpecification的要求，Java源代码的字符串中的反斜线被解释为Unicode转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被Java字节码编译器解释。不加\\有时编译器会报错，有时不会报错，这种情况下一定要注意，否则又浪费半天。 
第157篇文章[1]
HIT计算机系统大作业-Hello‘sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 班 级 学 生 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文阐述了一个简单的入门程序“hello”在Linux系统下的全寿命周期所经历的全部阶段，从一个文本文件经过预处理，编译，汇编，链接生成了可执行文件的全过程。然后对hello文件在shell下的进程管理，系统下存储管理和I/管理。通过对hello这位老前辈一生的探索，加深了我们对计算机系统的理解。 关键词：Hello；预处理；编译；汇编；链接；进程；存储；虚拟内存；I/O； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1 预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 Hello’sP2P:FromProgramtoProcess,含义就是从用高级语言写出一个.c文件开始，在经过预处理器（cpp）的预处理生产hello.i（修改了的源程序），在经过编译器（cc1）的编译生成hello.c文件，然后通过汇编器（as），生成可重定位的目标文件（二进制）然后与预编译的库函数通过链接器（ld）进行链接，生成可执行文件hello。在shell中启动该程序操作系统会为其fork产生子进程，再调用execve函数加载进程。自此，hello的P2P结束。 Hello’s020:Fromzerotozero,操作系统调用execve函数后会映射到虚拟内存中，删除当前的虚拟地址中的数据并为hello创建新的区域，从程序入口进入物理存储地址，然后再执行hello程序中的main函数。代码完成后，父进程回收hello进程，内核删除其相关的数据结构。 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位 开发与调试工具：gcc，vim，Codeblocks，edb，readelf，HexEdit 1.3中间结果 1.4本章小结 本章主要介绍了Hello程序一生经历的两个过程P2P和020，同时给出了实验时的软硬件开发环境和本次大作业中所涉及到的中间文件它们的名称和其含义。很简略的介绍。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 预处理的概念：预处理器根据以字符“#”开头的命令，包括宏命令和条件编译，来修改最原始的c程序将所有引用的库展开后合并成一个完整的文本文件。 预处理阶段作用： 使用预处理功能便于程序的修改，阅读，移植和调试，也便于实现程序模块化设计。文件包含是预处理的一个重要功能。可以用来把多个源文件连接成一个源文件进行编译，结果生成一个目标文件。条件编译也是预处理阶段的一个重要作用。允许只编译满足条件的程序段，使生成的目标程序变短，从而减少了内存的开销，提高了程序效率。处理宏定义也是重要作用之一。预处理把程序所有的宏定义语句进行替换，例如#definePI3.14语句，在预处理过程中把程序里所有的PI进行替换。 2.2在Ubuntu下预处理的命令 命令：gcchello.c-E-ohello.i 图2.1Ubuntu下的hello程序预处理命令 2.3Hello的预处理结果解析 图2.2预处理后的hello.i文件（节选） 进行了预处理操作以后，我们发现一个只有十几行的hello.c文件被展开成立几千行的文本文件，然后阅读hello.i文件发现，增加的行数其实是对hello.c文件头文件的展开，还对一些宏定义的#define命令进行了相应符号的替换。 2.4本章小结 本章概括性的介绍了预处理阶段的作用和概念，同时给出了在ubuntu下的c语言预处理命令，并分析了预处理后生成的hello.i文本文件。hello的受精卵时期已经结束了。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的概念：编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含main函数的定义，将定义中的每条语句都以一种文本格式描述了一条机器语言指令。 编译的作用：基本功能是把源程序翻译成目标程序作为输出。编译的功能不只有基本功能。在编译阶段，对程序的编译还具有语法检查，调试措施，覆盖处理，目标程序优化等其它的重要功能。 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令 命令：gcc-Shello.i-ohello.s 图3.1Ubuntu下的编译指令 3.3Hello的编译结果解析 3.3.1汇编指令的介绍 图3.2hello.s中的相关汇编指令 .file:声明源文件.text：代码节.section:（定义内存段）.rodata:只读代码段.align：数据或者指令的地址对其方式.string：声明一个字符串.global：声明全局变量.type:声明一个符号是数据类型还是函数类型 3.3.2数据类型 1.局部变量：main函数声明了一个局部变量，编译时编译器会把局部变量放入堆栈中。如图3.3所示。 图3.3 字符串：程序中有两个字符串，从.s文件中的.string中可以看出（.LC0,.LC1） 图3.4 立即数:从汇编代码中可以直接看出来，形如“$0”这种表示风格的就是立即数。数组：hello.c中唯一涉及到的数组就是main函数传入的参char*argv[]；数组的每一个元素都是一个指向字符类型的指针。数组的起始地点是栈帧减去32的位置，然后被两次调用argv[0]和argv[1]传入printf函数中。如图3.5所示。 图3.5 全局函数：main函数。由hello.c可知，hello.c声明了一个全局函数intmain(intargc,char*argv[])，经过编译之后，main函数中使用的字符串常量也被存放在数据区。由下图可以看出。 图3.6 全局变量：由hello.c可知，hello.c声明了一个全局变量sleepsecs。经过编译以后，初始化了的全局变量sleepsecs处在数据段。可由图3.7看出。 图3.7 指针：hello.c中main函数的第二个参数char*argv[]，就是指针字符数组在。这里可以看出指针与数组紧密相连。但因为数组那介绍过了，所以这里不在赘述。结构：hello.c中未涉及到结构体这样数据类型，所以也不进行详述；但给出简单的定义：可以将不同类型的对象聚集到一个对象中，用名字来引用各个部分。 3.3.3各类操作 1.赋值操作：程序中的赋值操作主要有：i=0这条赋值操作在汇编代码主要使用mov指令来实现，而根据数据的类型又有好几种不一样的后缀b:一个字节w：两个字节l：四个字节q：八个字节 算数操作：hello.c中的算数操作由i++，因为i是int类型的，所以只需要add指令就可以实现。 下面给出各种算数运算的汇编指令： （1）加：x=x+y汇编语言是：addqy，x （2）减：x=x-y汇编语言是：subqy，x （3）乘：x=x*y汇编语言是：imulq：y，x （4）除：z=x/y汇编语言是:：movqx,z cqto idivqy 复合语句就是上面的组合，或者也有复合的汇编语句：z=x+Ay+B（A，B都是立即数）的汇编语言是leaqB(x，y，A)z 关系操作： hello.c中出现了if（argc！=3）的！=的关系操作符号，这条指令被编译为：cmpl$3,-20(%rbp)，同时这条cmpl的指令还有设置条件码的作用，当根据条件码来判断是否需要跳转到分支中。hello.c中还出现了i<10的关系判断符号，在汇编代码中被翻译为cmpl$9,-4(%rbp),同时设置条件码，来判断是否满足跳出循环的条件。 控制转移指令：汇编语言中通过上一步关系判断设置条件码，来进行下一步的转移跳转的指令。 图3.8hello.s中的两条转移跳转指令 有上一小节的关系操作中，我们了解到通过判断设置的条件码，可以判断是否执行跳转命令。相关跳转命令如下图： 图3.9一些汇编跳转指令 函数操作： 传递参数：是在程序运行过程中，实际参数就会将参数值传递给相应的形式参数，然后在函数中实现对数据处理和返回的过程，方法有按值传递参数，按地址传递参数和按数组传递参数函数调用：计算机编译或运行时，使用某个函数来完成相关命令。对无参函数调用时则无实际参数表。实际参数表中的参数可以是常数、变量或其它构造类型数据及表达式。各实参之间用逗号分隔。分配空间和释放内存：在开始时，函数要为局部变量分配空间，而在返回前，要释放这些空间。函数返回：返回一个结果或者void类型函数无返回值。 在hello.c中，涉及到的函数操作有： main函数调用printf，exit，sleep，getchar函数main函数的参数是argc和argv；printf函数的参数也是argc和argv；exit的参数是1；sleep的参数是全局变量sleepsecs。函数的返回值存在寄存器%rax（%eax)中。 图3.10hello.c函数中一些函数操作 6.类型转换：hello.c中并未涉及到相关类型转换操作。但根据实验二我们知道类型转换可以强制类型转换，例如inta=(int)c;或者调用相关类型转化函数，例如atoi等。未涉及到就不进行详细的展开介绍了。 3.4本章小结 本章主要讲述了编译阶段中编译器如何处理各种数据和操作，以及c语言中各种类型和操作所对应的的汇编代码。通过理解了这些编译器编译的机制，我们可以很容易的将汇编语言翻译成c语言。从此，hello已经进入了胚胎阶段。 （以下格式自行编排，编辑时删除） （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编的概念：汇编器（as）将.s文件翻译成机器语言指令，并把这些指令打包成一种叫可重定位目标程序的格式，并将结果保存在.o文件中。 汇编阶段的作用：将编译生成的汇编代码在汇编阶段生成机器可理解的，由0，1组成的二进制机器代码指令。 4.2在Ubuntu下汇编的命令 命令：gcchello.s-c-ohello.o 图4.1Ubuntu下的汇编阶段指令 4.3可重定位目标elf格式 1.ELFHEADER：在Ubuntu下用命令readelf-hhello.o查看其ELF头部表结构； 图4.2hello.o的ELF头 ELF头：从16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量等信息。 SectionHeader：在Ubuntu下用命令readelf-Shello.o查看其节头部表结构： 图4.3hello.o的节头部表 SectionHeader：节头部表，包含了文件中出现的各个节的语义，包括节的类型、位置和大小等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小，同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。 符号表（.symtab）：在Ubuntu下用命令readelf-shello.o查看其符号表结构： 图4.4hello.o的符号表 符号表（.symtab）： 存放程序中定义和引用的函数和全局变量的信息。name是符号名称，对于可重定位目标模块，value是符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址。size是目标的大小，type是该符号的类型。 重定位节：在Ubuntu下用readelf -ahello.o查看hello.o的全部elf信息，其中包括重定位节(.rel.text): 图4.5hello.o的重定位节 重定位节：一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。 4.4Hello.o的结果解析 （以下格式自行编排，编辑时删除） objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 图4.6hello.o的反汇编代码 图4.7hello.s中的main反汇编代码 通过这两段反汇编代码的比较，发现其汇编指令不存在不相同的地方，只是反汇编代码中还显示其汇编指令对应的相关机器代码。将汇编指令分成操作数和操作码，则可在机器指令与汇编指令中建立一种美妙的双射，进而可以将汇编指令转换为电脑可以直接识别的机器指令。但还是存在一些不同的地方。接下来进行分析： 分支转移：汇编代码的跳转是段名称比如.L2这类段跳转，而机器指令的跳转是跳转到确定的一个地址。函数调用：汇编代码的跳转命令后往往跟的是调用函数的名称，而在反汇编代码中call的目标地址是当前的下一条指令，后面跟的操作数是调用函数地址距离当前PC的相对偏移量。但这些需要动态连接时才可被确定，所以在反汇编成机器代码时，不确定相对地址，则将call指令后的相对地址全设为0；然后后在.rela.text重定位节中为其添加重定位条目，等待静态链接的进一步确定。 4.5本章小结 本章我们对hello.s进行了汇编操作，生成了可重定位目标文件hello.o，并且分析了其elf中的各种段种的信息，包括ELF头，重定位表，节头部表和符号表。然后在此基础上对hello.s和hello.o中的反汇编代码进行了比较，明确了汇编指令与机器指令间令人愉悦的美妙双射关系。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载到内存中并执行。链接可以发生在编译时，也可以发生在加载时，甚至执行在运行时。在现代系统中，链接是由较做链接器的程序自动执行的。 链接的作用：使得“分离编译”成为可能。我们不用将一个大型的应用组织成为一个大的源文件，而是可以把它分解成为更小的，更好管理的模块，可以独立的修改这些模块，我们改变这些其中一个时，只需简单的重新编译它，并重新链接，而不需要重新编译其他文件。 5.2在Ubuntu下链接的命令 命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1动态链接命令 5.3可执行目标文件hello的格式 1.ELF头：与hello.o的不同之处是类型变为了exec可执行文件，同时节头数量变为了25。 图5.2hello的ELF头 2.Section头节头表记录了各个节的信息，Address是程序被载入到虚拟地址的起始地址，off是在程序中的偏移量，size是节的大小。 图5.3hello的节头部表 重定位节： 图5.4hello的重定位节 符号表： 图5.5hello的符号表 5.4hello的虚拟地址空间 用edb查看程序hello，发现程序在地址0x400000~0x401000中被载入，从0x400000开始到0x400fff结束，这之间每个节的排列同节头部表中Address中声明。在0x400fff之后存放的是.dynamic~.shstrtab节。 图5.6datadump中0x400000内容 如图所示，开头是ELF头部分内容。 查看地址0x0x400200，发现是.interp节，保存着linux动态共享库的路径。 图5.7datadump查看地址0x400200内容 查看地址0x0x400298，发现是.dynsym节，保存动态符号表。 图5.8datadump查看地址0x400298内容 节头部表中的其他节都可以按照此方法一一查看其地址和内容。 5.5链接的重定位过程分析 两者main函数的汇编指令完全相同，除了地址由相对偏移变成了可以由CPU直接寻址的绝对地址。链接器把hello.o中的偏移量加上程序在虚拟内存中的起始地址0x400000和.text节的偏移量就得到了hello1中的地址。函数内的控制转移即jmp指令后的地址由偏移量变为了偏移量+函数的起始地址；call后的地址由链接器执行重定位后计算出实际地址。 除了main函数，hello比hello.o多出了几个函数：printf、sleep、puts、getchar、atoi、exit。 除了.text节的区别外，hello比hello.o多出了几个节：.init节、.plt节、.fini节。其中.init节是程序初始化需要执行的代码，.fini节是程序正常终止时需要执行的代码，.plt节是动态链接中的过程链接表。 函数调用：链接器解析重定条目时发现对外部函数调用的类型为R_X86_64_PLT32的重定位，此时动态链接库中的函数已经加入到了PLT中，.text与.plt节相对距离已经确定，链接器计算相对距离，将对动态链接库中函数的调用值改为PLT中相应函数与下条指令的相对地址，指向对应函数。对于此类重定位链接器为其构造.plt与.got.plt。 rodata引用：链接器解析重定条目时发现两个类型为R_X86_64_PC32的对.rodata的重定位（printf中的两个字符串），.rodata与.text节之间的相对距离确定，因此链接器直接修改call之后的值为目标地址与下一条指令的地址之差，指向相应的字符串。 图5.9hello的反汇编代码 图5.12edb查询函数执行流程图 5.7Hello的动态链接分析 对于动态共享链接库中PIC函数，编译器没有办法预测函数的运行时地址，所以需要添加重定位记录，等待动态链接器处理，为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT+全局偏移量表GOT实现函数的动态链接，GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。 PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 根据段头部表查看GOT表的值： 图5.13hello的GOT表（未调用init前） 图5.15GOT表内地址对应内容 5.8本章小结 本章介绍了链接的概念和作用，对链接后生成的可执行文件hello的elf格式文件进行了分析，分析了hello的虚拟地址空间、重定位过程、执行过程的各种处理操作。我们的hello程序终于出生了！ （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程就是一个执行中程序的实例。每次用户向shell中输入一个可执行文件的名字，运行程序时，shell就会创建一个新的进程。 进程的作用：进程为用户提供一种假象，我们的程序好像时系统中当前运行的唯一程序，我们的程序好像是独占处理器和内存，我们的程序代码和对象就像是系统内存中唯一存在的对象；处理器好像是无间断的执行和处理我们程序中的指令。 6.2简述壳Shell-bash的作用与处理流程 shell-bash的作用：shell-bash是一个C语言程序，它代表用户执行进程，它交互性地解释和执行用户输入的命令，能够通过调用系统级的函数或功能执行程序、建立文件、进行并行操作等。同时它也能够协调程序间的运行冲突，保证程序能够以并行形式高效执行。bash还提供了一个图形化界面，提升交互的速度。 shell-bash的处理流程： (1)终端进程读取用户由键盘输入的命令行。 (2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量 (3)检查第一个命令行参数是否是一个内置的shell命令，如果不是内部命令，调用fork()创建新进程/子进程 (4)在子进程中，用步骤2获取的参数，调用execve()执行指定程序。 (5)如果用户没要求后台运行(命令末尾没有&号）否则shell使用waitpid等待作业终止后返回。 (6)如果用户要求后台运行(如果命令末尾有&号），则shell返回； 6.3Hello的fork进程创建过程 首先打开terminal输入./hello1190200820李宇，接下来shell会分析这条命令，由于./hello不是一条内置的命令，于是判断./hello的语义是执行当前目录下的可执行目标文件hello，然后Terminal会调用fork创建一个新的运行的子进程，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，这就意味着，当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程与子进程之间的区别在于它们拥有不同的PID。 图6.1fork创建子进程流程图 6.4Hello的execve过程 在fork之后，子进程调用execve函数，execve函数在新创建的子进程的上下文中加载并运行hello程序。execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有发生错误时execve才会返回到调用程序。所以，execve调用一次且从不返回。 execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行程序,加载器删除子进程现有的虚拟内存段,并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零,通过将虚拟地址空间中的页映射到可执行文件的页大小的片,新的代码和数据段被初始化为可执行文件中的内容。最后加载器设置PC指向_start地址,_start最终调用main函数.除了一些头部信息,在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制,这时,操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 6.5Hello的进程执行 相关术语概念： 逻辑控制流：一系列程序计数器PC的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。（2）时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。（3）用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。（4）上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程的决定叫做调度。上下文切换的流程是： 保存当前进程的上下文。恢复某个先前被抢占的进程被保存的上下文。将控制传递给这个新恢复的进程。 图6.2上下文切换流程 然后分析hello的进程：hello初始运行在用户模式，调用sleep后进入内核模式，内核对休眠进行处理，并请求主动释放当前进程，并将hello从运行队列加入等待队列，定时器开始计时，此时内核把上下文切换的权限交给其他进程，2.5s后定时器发送中断信号，hello从等待队列移入运行队列，成为就绪状态，然后一切恢复，可以进行自己的控制逻辑流了。 6.6hello的异常与信号处理 6.6.1异常 hello执行过程中可能出现四类异常：中断、陷阱、故障和终止。 （1）中断是来自I/O设备的信号，异步发生，中断处理程序对其进行处理，返回后继续执行调用前待执行的下一条代码，就像没有发生过中断。 （2）陷阱是有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。帮助程序从用户模式切换到内核模式。 （3）故障是由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。 （4）终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程序会将控制返回给一个abort例程，该例程会终止这个应用程序。 6.6.2信号 图6.3信号的种类名称 6.6.3信号的处理 （1）正常运行hello程序。可以看出，程序在执行结束后，进程被回收。 图6.4正常执行hello （2）随便乱按。发现乱按会将输入的内容保存在缓冲区，等进程结束后作为命令行的内容输入。 图6.5随意乱按hello的执行结果 （3）运行过程中按下Ctrl-C。发现会向进程发送SIGINT信号。信号处理程序终止并回收进程。 图6.6输入crtl-c的hello执行结果 （4）运行过程中按下Ctrl-Z。当按下Ctrl-Z之后，shell进程收到SIGSTP信号，信号处理函数的逻辑是打印屏幕回显、将hello进程挂起。 图6.7输入crtl-Z后程序被挂起 图6.9kill杀死挂起的hello进程 （6）pstree命令 图6.10pstree指令执行 6.7本章小结 本章简述了进程管理的一些简要信息，比如进程的概念作用，shel的基本原理，shell如何调用fork和execve我们的hello进程，我们的hello进程在执行时会遇到什么样的情况（包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill 等命令的处理），它对这些情况如何做出反应。又介绍了一些常见异常和其信号处理方法。我们的hello出生后就进入了错综复杂的环境，他也要学习相关知识，来处理处理常伴身边的信号。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：是指由程序产生的与段相关的偏移地址部分。又称绝对地址。其表达形式为“段地址：段内偏移地址”。 虚拟地址：CPU启动保护模式后，程序运行在虚拟地址空间中。与物理地址相似，虚拟内存被组织为一个存放在磁盘上的N个连续的字节大小的单元组成的数组，其每个字节对应的地址成为虚拟地址。虚拟地址包括VPO（虚拟页面偏移量）、VPN（虚拟页号）、TLBI（TLB索引）、TLBT（TLB标记）。 线性地址：是逻辑地址到物理地址变换之间的中间层。程式代码会产生逻辑地址，或说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。 物理地址： 是指出目前CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。 由图可以看出，400532是逻辑代码的偏移量，加上.text段的基地址就能得到main的虚拟内存地址。 图7.1hello的汇编代码 7.2Intel逻辑地址到线性地址的变换-段式管理 原理：在段式存储管理中，将程序的地址空间划分为若干个段(segment)，这样每个进程有一个二维的地址空间。在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在段式存储管理系统中，则为每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续，物理内存的管理采用动态分区的管理方法。 为了实现段式管理，操作系统需要如下的数据结构来实现进程的地址空间到物理内存空间的映射，并跟踪物理内存的使用情况，以便在装入新的段的时候，合理地分配内存空间。 ·进程段表：描述组成进程地址空间的各段，可以是指向系统段表中表项的索引。每段有段基址(baseaddress)，即段内地址。 在系统中为每个进程建立一张段映射表： 图7.2段映射表 在段式管理系统中，整个进程的地址空间是二维的，即其逻辑地址由段号和段内地址两部分组成。为了完成进程逻辑地址到物理地址的映射，处理器会查找内存中的段表，由段号得到段的首地址，加上段内地址，得到实际的物理地址(见图4 5)。这个过程也是由处理器的硬件直接完成的，操作系统只需在进程切换时，将进程段表的首地址装入处理器的特定寄存器当中。这个寄存器一般被称作段表地址寄存器。 图7.3段式内存管理流程 7.3Hello的线性地址到物理地址的变换-页式管理 原理：将程序的逻辑地址空间划分为固定大小的页，而物理内存划分为同样大小的页框。程序加载时，可将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是VPN（虚拟页号），后一部分是VPO（虚拟页偏移量）。 图7.4物理地址结构 相关数据结构--页表：页表将虚拟内存映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。页表是一个页表条目（PTE）的数组。虚拟地址空间的每个页在页表中一个固定偏移量处都有一个PTE。假设每个PTE是由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。 页式内存管理：MMU利用VPN来选择适当的PTE，将列表条目中PPN和虚拟地址中的VPO串联起来，就得到相应的物理地址。 图7.5k级页表的地址翻译 7.4TLB与四级页表支持下的VA到PA的变换 TLB：一个小的，虚拟寻址的缓存，其每一行都保存在着由单个PTE组成的块。TLB通常具有非常高的相联度；如图所示 图7.6虚拟地址访问TLB的组成部分 TLB命中与不命中的步骤： 图7.7TLB操作图 Corei7使用的是四级页表层次结构。在四级页表层次结构的地址翻译中，虚拟地址被划分为4个VPN和1个VPO。每个第i个VPN都是一个到第i级页表的索引，第j级页表中的每个PTE都指向第j+1级某个页表的基址，第四级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN之前，MMU必须访问四个PTE。 图7.8Corei7的页表翻译 7.5三级Cache支持下的物理内存访问 在现代计算机中，存储器被组织成层次结构，因为这样可以最大程度地平衡访存时间和存储器成本。所以在CPU在访存时并不是直接访问内存，而是访问内存之前的三级cache。已知Corei7的三级cache是物理寻址的，块大小为64字节。LI和L2是8路组相联的，而L3是16路组相联的。Corei7实现支持48位虚拟地址空间和52位物理地址空间。 我们拿L1cache的访存来举例： 取出虚拟地址的组索引位，将二进制组索引转化为一个无符号整数，找到相应的组。把虚拟地址的标记为拿去和相应的组中所有行的标记位进行比较，当虚拟地址的标记位和高速缓存行的标记位匹配时，而且高速缓存行的有效位是1，则高速缓存命中。一旦高速缓存命中，我们就知道我们要找的字节在这个块的某个地方。因此块偏移位提供了第一个字节的偏移。把这个字节的内容取出返回给CPU即可不命中如果高速缓存不命中，那么需要从存储层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位所指示的组中的一个高速缓存行中。 所有cache的访存过程都可以分为这些步：组选择，行匹配，字选择，不命中处理； 图7.9i7的地址翻译过程 7.6hello进程fork时的内存映射 当fork被当前进程调用后，内核为新进程创建各种数据结构，并分配给它一个唯一的PID；为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct，区域结构和页表的原样副本。它将两个进程都标为只读，并将两个进程中的每个区域结构都标记为私有的写时复制； 当fork在新进程中返回时，新进程的虚拟内存刚好和调用fork的虚拟内存相同。当两个进程任意一个进行写操作时，写时复制机制就会创建新页面。 图7.10 hello进程fork时的内存映射 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1)删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2）映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3)映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 4）设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 图7.11加载器映射地址空间 7.8缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页，缺页故障是一种常见的故障，当指令引用一个虚拟地址，在MMU中查找页表时发现与该地址相对应的物理地址不在内存中，因此必须从磁盘中取出的时候就会发生故障。 图7.12缺页现象 缺页中断处理：缺页处理程序是系统内核中的代码，选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送VA到MMU，这次MMU就能正常翻译VA了。 图7.13缺页中断处理-牺牲页 7.9动态存储分配管理 动态内存分配器：动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护，每个块要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 图7.14堆 分配器有两种类型：显式分配器和隐式分配器； 显示分配器：要求应用显示的释放任何已分配的块。例如C标准库提供一个叫做malloc程序包的显示分配器。 隐式分配器：要求分配器检测一个已分配块何时不再被程序使用，那么就释放这个块。例如java等高级语言中的自动垃圾回收； 隐式空闲链表分配器； 任何实际的分配器都需要一些数据结构，允许它区别块边界，区别已分配块和空闲块；隐式分配器采取一种简单的方法： 图7.15简单的堆块格式 然后我们就可以将堆组织成一个连续的已分配块和空闲块组成的序列： 图7.16隐式空间链表组织堆 隐式空闲链表分配方式： (1)放置已分配的块：当一个应用请求一个k字节的块时，分配器搜索空闲链表。查找一个足够大可以放置所请求的空闲块。分配器搜索方式的常见策略是首次适配、下一次适配和最佳适配。 分割空闲块：一旦分配器找到一个匹配的空闲块，就必须做一个另策决定，那就是分配这个块多少空间。分配器通常将空闲块分割为两部分。第一部分变为了已分配块，第二部分变为了空闲块。 获取额外堆内存如果分配器不能为请求块找到空闲块，一个选择是合并那些在物理内存上相邻的空闲块，如果这样还不能生成一个足够大的块，分配器会调用sbrk函数，向内核请求额外的内存。 合并空闲块:如图所示： 图7.17合并空闲块的四种情况 显式空闲链表分配器：显示空闲链表是将空闲块组织为某种形式的显示数据结构。堆被组织为一个双向空闲链表，在每个空闲块中，都包含一个前驱和后继的指针。 图7.18双向空闲链表堆块 使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以使线性的，也可以是一个常数，这取决于我们选择的空闲链表中块的排序策略。 链表的维护方式有两种： 一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在线性时间内完成。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 一般而言，显示链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部，这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。 7.10本章小结 本章主要介绍了hello的存储管理，介绍了四种地址的概念，同时对地址的段页式管理进行了介绍，介绍了TLB与四级页表的支持下虚拟地址到物理地址的变化流程，同时也介绍了三级cache支持的物理地址访问；在此基础上回顾fork和execve的内存映射。然后介绍了缺页故障的处理方法和动态内存分配器的内存管理。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m字节的序列：B0,B1,B2……Bm所有的IO设备(如网路、磁盘、终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O,这使得所有的输入和输出都被当做相应文件的读和写来执行 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixI/O接口的几种操作： （1）打开文件：程序要求内核打开文件，内核返回一个小的非负整数（描述符），用于标识这个文件。程序在只要记录这个描述符便能记录打开文件的所有信息。 （2）shell在进程的开始为其打开三个文件：标准输入、标准输出和标准错误。 （3）改变当前文件的位置：对于每个打开的文件，内核保存着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作显式地设置文件的当前位置为k。 （4）读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会出发一个称为EOF的条件，应用程序能检测到这个条件，在文件结尾处并没有明确的EOF符号。 （5）关闭文件：内核释放打开文件时创建的数据结构以及占用的内存资源，并将描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： （1）intopen(char*filename,intflags,mode_tmode);open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。 （2）intclose(intfd);关闭一个打开的文件，返回操作结果。 （3）ssize_tread(intfd,void*buf,size_tn);read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF，否则返回值表示的是实际传送的字节数量。 （4）ssize_twrite(intfd,constvoid*buf,size_t);write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 printf函数源代码： `staticintprintf(constchar*fmt, ) { va_listargs; inti; va_start(args,fmt); write(1,printbuf,i=vsprintf(printbuf,fmt,args)); va_end(args); returni; } printf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。 write函数内容： write: moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL 其中intINT_VECTOR_SYS_CALLA代表通过系统调用syscall。 Syscall内容： sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret syscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中。 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar的源代码为： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章介绍了Linux中I/O设备的管理方法，UnixI/O接口和函数，并且分析了printf和getchar函数是如何通过UnixI/O函数实现其功能的。 （第8章1分） 结论 Hello精彩有坎坷的一生结束了，这一世hello经历过的重要阶段有： 通过文本编辑器编写，从空白文档变为hello.c文件；预处理：经过cpp的预处理，展开文件开头的宏和引用的文件；生成hello.i;编译阶段：经过编译器的编译得到hello.s文本文件；汇编阶段：经过汇编器的翻译将编译得到的hello.s文件翻译成为机器可以读懂的机器代码；同时将重定位信息加入，生成可重定位目标文件；链接阶段：链接器ld将hello.o与动态链接库链接生成可执行目标文件hello，从此，hello程序正式诞生；运行阶段：在shell中输入./hello1190200820李宇，hello开始运行；创建子进程：shell进程调用fork为其创建子进程加载：shell调用execve，execve调用启动加载器，加映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数。执行：CPU为hello分配时间片，hello执行自己的控制逻辑流访存：CPU为hello申请一个虚拟地址在，再通过mmu来翻译成物理地址并利用cache来访问内存；动态分配内存：printf会调用malloc向动态内存分配器申请堆中的内存。信号处理：shell处理hello运行过程中输入的各种信号；结束，被回收：shell父程序回收子进程内核删除跟这个进程有关的地址和数据，hello过完了自己的一生； 感悟：计算机的底层原理其实还是复杂而精巧的，一个最简单的hello.c程序的一生也经历了若如此奇幻的过程。从最底层的二进制机器代码，到cpu对程序的执行，越来越抽象；同时也敬佩计算机前辈们的头脑，设计出如此全面美妙的计算机系统；这次大作业是一边复习一边完成，加深了对书本上和老师讲解内容的理解； （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 （附件0分，缺失-1分） 文件名称文件内容hello.c源文件hello.i预处理后的文本文件hello.o可重定位目标执行文件hello连接以后的可执行文件hello.elfhello.o的elf表hello.txthello的反汇编代码hello.s编译之后的汇编文件helloo.txthello.o的反汇编代码 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42. [2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998 [1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] https://blog.csdn.net/hit_shaoqi/article/details/78516508 [7] file:///C:/Users/m1777/Desktop/深入理解计算机系统原书第3版 [8] https://www.cnblogs.com/pianist/p/3315801.html （参考文献0分，缺失-1分） 
第158篇文章[]
lab3中去除读进来的文件缩进的方法 首先，因为我先把整个文件用BufferReader给读成了一个String类型的量，因为String类型是immutable的，所以要新建一个String类型的临时变量来记录改变以后的内容；然后再用最笨的方法:String.replaceAll(""，""); 方法比较笨，但还是先记录在学习；代码就一句： Stringnewfile=fileentry.replace("\n","").replace("\r","").replace(" ","").replace("",""); （真不是在这水文章，这个当时的确调了一会，才把所有缩进都去掉） 
第159篇文章[]
JUnit5中测试异常抛出的方法 根据JUnit文档（http://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions）: importstaticorg.junit.jupiter.api.Assertions.assertThrows;   @Test voidexceptionTesting(){ ExecutableclosureContainingCodeToTest=()->thrownewIllegalArgumentException("amessage"); assertThrows(IllegalArgumentException.class,closureContainingCodeToTest,"amessage"); } 说实话我没太明白什么个原理，先码后了解 
第160篇文章[]
java自定义异常类 java可以通过继承Exception的手段来进行自定义的异常类 publicclassIntervalConflictExceptionextendsException{//自定义的异常类 /** *Makeanewintervalconflictexceptionwiththegivendetailmessage *@parammessagethedetailmessage */ publicIntervalConflictException(Stringmessage){ super(message); } } 但只是这么写Eclipse会有warning存在，warning内容如下： 出现这个warning的原因是：只要任何类别实现了Serializable这个接口的话，如果没有加入serialVersionUID，Eclipse都会给你warning提示，这个serialVersionUID为了让该类别Serializable向后兼容。即版本升级时反序列化仍保持对象的唯一性； 
第161篇文章[]
哈工大软件构造Lab1的设计实现 2021年春季学期 计算学部《软件构造》课程 Lab1实验报告 目录 1.实验目标概述3 2.实验环境配置3 3.实验过程6 3.1MagicSquares6 3.1.1isLegalMagicSquare()6 3.1.2generateMagicSquare()8 3.2TurtleGraphics10 3.2.1Problem1:Cloneandimport10 3.2.2Problem3:TurtlegraphicsanddrawSquare10 3.2.3Problem5:Drawingpolygons11 3.2.4Problem6:CalculatingBearings11 3.2.5Problem7:ConvexHulls12 3.2.6Problem8:Personalart12 3.2.7Submitting14 3.3SocialNetwork14 3.3.1设计/实现FriendshipGraph类14 3.3.2设计/实现Person类15 3.3.3设计/实现客户端代码main()16 3.3.4设计/实现测试用例17 4.实验进度记录18 5.实验过程中遇到的困难与解决途径19 6.实验过程中收获的经验、教训、感想19 6.1实验过程中收获的经验和教训19 6.2针对以下方面的感受19 实验目标概述 本次实验通过求解三个问题，训练基本Java编程技能，能够利用JavaOO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。 ⚫基本的JavaOO编程 ⚫基于EclipseIDE进行Java编程 ⚫基于JUnit的测试 ⚫基于Git的代码配置管理 实验环境配置 在这里给出你的GitHubLab1仓库的URL地址。 https://github.com/ComputerScienceHIT/HIT-Lab1-1190200828 实验过程 MagicSquares 该任务的目标：设计isLegalMagicSquare()函数，判定给定的几个矩阵是否为magicsquare；将给定的生成奇数阶的magicsquare的generateMagicSquare()函数作为静态函数加入我的程序代码中，将生成的矩阵存入6.txt并调用isLegalMagicSquare()判断所生成的矩阵是否正确。该阶段涉及到文件读写操作、对某些特定函数的调用（例如split等）、对部分异常的处理（例如矩阵中有负数、浮点数，或是行列数不相等）等。 isLegalMagicSquare() 1.根据实验要求，我不能上来直接就去用magic矩阵的定义去判断其正确性，即每行每列每个对角线的元素和都相等；而是应该先判断给定的矩阵是否合理，即判断行列数是否相等、矩阵中是否有浮点数、负数等。由此，我的想法是设置一个整型变量n=0，对于txt文件先按行读入，每读入一行n++，直到读完文件，此时n的值即为矩阵行数。然后，依旧是按行读入文件，每读入一行，将其存入Stringline中，并调用split(“\t”)将其分割并存入String[]line_cut，比较行数n与line_cut.length，不相等则输出错误提示并返回false，后经过测试，当文件未用”\t”进行分割时，也会导n!=line_cut.length，因此在这里一并输出错误提示；然后判断line_cut中的每一个元素是否都是正整数，按位寻访line_cut，若出现某一位不在数字字符’0’-‘9’中，则输出错误提示并返回false。综上所述，即有如下代码： 以上错误判断完毕后，将读入的文档存入矩阵magic中，并按照magic矩阵定义进行测试，若不符合magic矩阵定义，则返回false。注意，在此过程中，并未输出错误提示，表示矩阵本身不存在行列数不相等等错误。于是有以下代码： 至此，isLegalMagicSquare()函数设计完毕； 结果展示： generateMagicSquare() 程序代码已经在ppt中给出，程序流程图如下：除该程序代码外，需对该函数的输入进行测试，以防输入为偶数或负数。该测试在我的main函数中完成，输入阶数为负数或偶数或输入阶数小于2时输出错误提示并予以重新输入，但是，如果输入根本并非整数，而是浮点数或字符时，则输出错误提示且不允许重新输入，于是有如下代码：除此之外，还需要在函数中加入文件写入操作，将产生的magic矩阵存入6.txt以便于main函数中测试其生成的magic矩阵的正确性，添加的代码如下：结果展示： TurtleGraphics 该任务的目标：clone已有的程序后，利用turtle按照要求画图，主要需要修改及再编程的是TurtleSoup类，其中的一些函数编程时需要结合我们已有的数学几何知识、TurtleSoup类中的提示信息以及测试用的TurtleSoupTest类中的提示信息，最后可以发挥想象力进行自己的创作。 Problem1:Cloneandimport 从github获取代码 由于clone出现问题，找不到实验报告上给的那个链接，所以我进入该链接后，将代码逐个复制到我的程序类中。 初始化本地仓库gitinit Problem3:TurtlegraphicsanddrawSquare 该函数需要实现：已知边长，画出边长为指定数值的正方形。参数是海龟对象turtle和边长sideLength。循环执行，每次画笔直行sideLength距离，然后画笔方向旋转90度，循环执行4次后即可得到所需要的正方形，函数代码如下：结果展示（sideLength=40）： Problem5:Drawingpolygons 首先，要求计算已知正多边形边数的内角度，该计算由已知公式可以推导，因此相关函数代码如下：根据正方形的画法，只需要将画笔的转向角度设置为180–内角度数，循环多边形边数次数即可。考虑到画笔转向既能是顺时针又能是逆时针，故在此声明：sides可为负数，且当sides为负整数时，代表着画笔将逆时针旋转，且旋转度数为180–内角度数，并且取sides的绝对值为正多边形边数。函数代码如下： Problem6:CalculatingBearings 首先，已知起点和当前朝向角度，要求起点到终点需要转动的角度。根据几何运算，得函数代码如下：上述问题的扩展：此时有若干个点，要求从第一个点开始到第二个点，再从第二个点到第三个点……以此类推每次转向的角度。以起点为第一个点，循环n-1次，每次将第i+1号点设置为“终点”，通过上一个函数计算旋转角度并存储到List中，将下一次的“起点”用当前“终点”更新，继续循环。程序代码如下： Problem7:ConvexHulls 由凸包算法（CSDN（ConvexHull凸包算法之Gift-Wrapping_InnovativeWorkstation-CSDN博客）上查阅），可得该函数代码为： Problem8:Personalart 函数代码： 结果展示： Submitting 由于第一次提交时已经进行过初始化以及与我的云仓库的关联，本次提交中只需要添加文件、注释以及提交三个步骤。 SocialNetwork 该任务的目标：设计一张社交网络无向图，连接互为朋友的人与人，并且能计算任意两人之间需要的最少的关联路径。于是，该问题为最短路径问题，而构建的图为无向无权图，所以利用DFS深度优先遍历即可得到两点间的最短路径。 设计/实现FriendshipGraph类 存储图中的人姓名的集合： addVertex()函数：首先判断Personp是否在图中，若已经存在于图中，则输出错误信息，程序结束；否则将p添加至person中。 addEdge()函数：在a、b的朋友列表里分别加入彼此。 getDistance()函数：DFS深度优先算法求最短路径 设计/实现Person类 Person类包括： Person()：包括这个人的名字p_name，这个人的朋友列表friends； IsFriendOf(Personp)：在p_name的朋友列表里加入p； 设计/实现客户端代码main() 由ppt给出： 设计/实现测试用例 思想：将a通过addVertex()函数加入testGraph1中，b不加入，因此，测试用例为a在testGraph1.person中，b不在； 思想：将a、b通过addVertex()函数加入testGraph1中，调用addEdge()函数，在a、b加一条线，即关联在一起，那么，a、b的朋友列表将包含彼此，因此测试用例中，a在b.friends中，b也在a.friends中； 思想：getDistance测试中应包括自己与自己、相互认识的两人、相互不认识但是有中间人关联的两人以及互不相干的两人； 测试结果：至此，实验设计结束。 
第162篇文章[]
面向软件构造期末考试程序设计题的复习 面向软件构造期末考试程序设计题的复习 目录 目录1 1设计spec1 1.1spec的重要性1 1.2spec的结构1 1.3spec中不能包含的部分1 2ADT的设计1 2.1RI1 2.2表示泄露2 2.2AF2 3面向可维护性的设计模式2 3.1Visitor2 3.2Strategy策略模式2 3.3Iterator迭代器模式2 3.4Decorator装饰器模式3 3.5FactoryMethod工厂模式3 3.6Adapter适配器模式3 1设计spec 1.1spec的重要性 spec是程序员自己对所写的方法的规约，它规定了方法应该做什么，不应该做什么。spec时是测试优先编程的基础，因为程序员所编写的代码必定是符合spec的，否则就是不合格的，所以符合spec的代码也必然能通过根据spec所设计出的测试。同时，有了spec，客户端在使用所写的代码时就有所依据，客户端可以轻松的知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，而不必知道内部逻辑是怎么样的，大大节省了客户端使用自己的API时所需要的时间，并且降低了客户端对自己所编写的代码的误解。 1.2spec的结构 方法的功能；前置条件，即方法参数的限制条件，使用@param说明每个参数的前置条件；后置条件，即当前置条件满足时，方法结束时必须满足的条件，使用@return说明正确的返回值，即后置条件；使用@throws说明出现什么样的错误情况会导致什么样的异常。 1.3spec中不能包含的部分 spec不能暴露实现细节，不应该暴露局部变量，也不应该暴露私有的数据域，这些东西一旦暴露，就有可能给被非法的程序员利用，发现漏洞并实施攻击。 【注】方法不应该改变输入参数的取值，如果改了，则必须在spec中做出说明。所以推荐使用immutable的对象，以及使用immutable类作为返回值类型。 2ADT的设计 ADT的设计包括spec的设计、rep的设计以及implementation的设计，spec的设计上面已经提到，下面将介绍一些ADT相关的问题。 2.1RI RepInvariant，即不变量集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。我们通常通过写checkRep()来随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。 checkRep检查包括参数大小、参数是否为空、参数长度、参数中是否有 2.2表示泄露 即client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。一般来说，方法中的变量如果是public的，那么很有可能会出现表示泄露。若某些getter函数并未采用防御式拷贝，则变量有可能被外部指针所引用，导致表示泄露。 2.2AF AbstractionFunction，即从R空间到A空间存在一个映射，这个映射是一个满射，是将R中的每一个值解释为A中的一个值的映射。这个映射的解释函数就是AF。 3面向可维护性的设计模式 3.1Visitor 对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。 首先，设计相应扩展的Visitor接口，其中包括visit方法，该方法的参数为要扩展的方法类型，并且可复用。然后，设计一个CacuVisitor，实现Visitor接口中的方法，满足要扩展的功能条件。接着，在被扩展的方法中增加accept方法，即accept(Visitorvisitor){visitor.visit(this);}，即将自己传给visit。最后，在客户端调用accept(newCacuVisitor())即可。 3.2Strategy策略模式 有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。 首先，设计对应的扩展Strategy接口，接口中有相应的被扩展的方法select，该方法的参数与扩展前相同。然后，创建两个或多个不同的CacuStrategy方法，内部使用不同的策略来实现Strategy接口中的方法，分别满足原策略条件和要扩展的策略的功能条件。接着，在被扩展的方法参数中增加一个Strategy接口类型的参数，并将调用原策略方法的代码改为strategy.select(原参数)。最后，在客户端调用扩展方法时(原参数，newCacuStrategy)即可。 3.3Iterator迭代器模式 客户端希望遍历被放入容器/集合类的一组ADT对象。实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。 首先实现Iterator<遍历对象>的接口，然后实现iterator()方法，即publicIterator<遍历对象>iterator(){returnnewCacuIterator();} 接着创建内部类来实现该接口： privateclassCacuIteratorimplementsIterator<Car>，在该类中要实现next()，hasNext()，remove()三个方法。 3.4Decorator装饰器模式 每个子类实现不同的特性，因为这些特性都是多个维度上的个性化的特征，没办法做到在一个顶层的接口中完成所有特征的抽象，而且需要做到在各个维度上的特性的任意组合，此时光靠继承是没办法实现特性的组合的，如果要强行使用继承实现，那么面对的一个不可避免地问题是组合爆炸，因为每次继承只能扩展一个特性，多个特性就要多次继承实现，并且也不便于维护与扩展，而且会有大量的重复代码。 首先创建一个类来实现接口的方法，然后再创建一个类，来继承刚刚创建的那个类，并在此类中添加修饰。可以在继承后的类中添加rep，即参数。 3.5FactoryMethod工厂模式 解决的问题：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。 定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。也可以通过直接定义静态工厂方法来创建子类实例。 3.6Adapter适配器模式 将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。 后续将继续添加。 
第163篇文章[]
Lab2中遇到的困难及相关知识 Lab2中遇到的困难及相关知识 目录 1对一些对象类型的不熟悉1 1.1Queue1 1.2Set1 1.3List2 1.4Map2 2循环遍历2 2.1普通for循环3 2.2加强for循环3 2.3迭代器Iterator3 总结3 1对一些对象类型的不熟悉 1.1Queue 队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，有先进先出的特点。 其常用方法如下： add()：将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回true，如果当前没有可用的空间，则抛出IllegalStateException。element()：获取，但是不移除此队列的头。offer()：将指定的元素插入此队列（如果立即可行且不会违反容量制），当使用有容量限制的队列时，此方法通常要优于add(E)，后者可能无法插入元素，而只是抛出一个异常。peek()：获取但不移除此队列的头；如果此队列为空，则返回null。poll()：获取并移除此队列的头，如果此队列为空，则返回nullremove()：获取并移除此队列的头。 1.2Set Set继承于Collection接口，是一个不允许出现重复元素，并且无序的集合。 其常用方法如下： add()：向集合中添加元素clear()：去掉集合中所有的元素contains()：判断集合中是否包含某一个元素isEmpty()：判断集合是否为空remove()：从集合中去掉特定的对象size()：返回集合的大小 1.3List List是一个接口，它继承于Collection的接口。它代表着有序的队列。当我们讨论List的时候，一般都和Set作比较。 List中元素可以重复，并且是有序的（这里的有序指的是按照放入的顺序进行存储。如按照顺序把1，2，3存入List，那么，从List中遍历出来的顺序也是1，2，3）。而Set中的元素不可以重复，并且是无序的（从set中遍历出来的数据和放入顺序没有关系）。 List的常用方法： add()：向List的指定位置插入元素get()：返回list中指定位置的元素set()：修改List中的某一指定位置的元素isEmpty()：判断List是否为空remove()：从List中去掉特定的对象size()：返回List的大小 1.4Map Map是将键映射到值的对象的数据结构，一个映射不能包含重复的键，且每个键最多只能映射到一个值。 Map的常用方法： put()：添加映射对get()：根据键来获取其映射的值containsKey()：判断Map中是否有指定键值containsValue()：判断Map中是否有指定的值remove()：从Map中去掉特定的对象keySet()：获得键的集合values()：获得值的集合isEmpty()：判断Map是否为空entrySet()：返回Map中的元素对 2循环遍历 循环遍历中的加强for循环以及迭代器遍历是我之前没有用的循环遍历方式。 2.1普通for循环 类似于for(inti=0;i<n;i++)的循环遍历； 2.2加强for循环 类似于for(Stringstr:list)的循环遍历； 值得注意的是，在加强for循环的过程中，只能观察被遍历的元素的值，并不能对其进行删除等操作，否则会发生意料之外的事情。 2.3迭代器Iterator 例如如下程序： Iterator<String>it=list.iterator(); while(it.hasNext()){ Stringx=it.next(); if(x.equals(“del”)){ it.remove(); } } 总结 本章回顾了我在做Lab2时遇到的两个主要的困难以及与它们相关的知识。 
第164篇文章[]
Java面向对象的一些相关概念及设计实例 Java面向对象的一些相关概念及设计实例 1面向对象的相关概念 1.1面向对象 面向对象(ObjectOriented)是软件开发方法，一种编程范式。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。 1.2面向对象的相关概念 对象： 对象是指具体的某一个事物，即在现实生活中能够看得见摸得着的事物。在面向对象程序设计中，对象所指的是计算机系统中的某一个成分。在面向对象程序设计中，对象包含两个含义，其中一个是数据，另外一个是动作。对象则是数据和动作的结合体。对象不仅能够进行操作，同时还能够及时记录下操作结果。类的实例化可生成对象，一个对象的生命周期包括三个阶段：生成、使用、消除。 方法： 方法是指对象能够进行的操作，即函数。方法是类中的定义函数，其具体的作用就是对对象进行描述操作。 类： 类是具有相同特性（数据元素）和行为（功能）的对象的抽象。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象，类实际上就是一种数据类型。在我的理解中，类就像是一个带有内置函数的C语言中的结构体。 接口： 在Java语言中,仅支持单一继承,即一个子类只能有一个直接的父类，然而在日常生活中，多继承的问题在所难免如电子书既是一种图书，同时又是一种多媒体，这种继承关系要求子类继承多个父类。这样就可能导致子类具有多种多样的方法和实现形式。所以Java不允许多继承，为了解决多继承的问题，Java引入了接口的概念。定义一个接口不能使用class关键字，而是使用interface关健字。 1.3面向对象的核心特性 继承性： 继承简单地说就是一种层次模型，这种层次模型能够被重用。层次结构的上层具有通用性，但是下层结构则具有特殊性。在继承的过程中类则可以从最顶层的部分继承一些方法和变量。类除了可以继承以外同时还能够进行修改或者添加。通过这样的方式能够有效提高工作效率。 封装性： 封装是将数据和代码捆绑到一起，对象的某些数据和代码可以是私有的(private)，不能被外界访问，以此实现对数据和代码不同级别的访问权限。防止了程序相互依赖性而带来的变动影响，面向对象的封装比传统语言的封装更为清晰、更为有力。有效实现了两个目标：对数据和行为的包装和信息隐藏。 多态性： 多态是指不同事物具有不同表现形式的能力。多态机制使具有不同内部结构的对象可以共享相同的外部接口，通过这种方式减少代码的复杂度。一个接口，多种方式。 2面向对象的设计实例 设计实例即Lab2中Graph接口以及其具体实现的子类。 2.1Graph接口 /** *Amutableweighteddirectedgraphwithlabeledvertices. *Verticeshavedistinctlabelsofanimmutabletype{@codeL}whencompared *usingthe{@linkObject#equals(Object)equals}method. *Edgesaredirectedandhaveapositiveweightoftype{@codeint}. * *<p>PS2instructions:thisisarequiredADTinterface. *YouMUSTNOTchangethespecificationsoraddadditionalmethods. * *@param<L>typeofvertexlabelsinthisgraph,mustbeimmutable */ publicinterfaceGraph<L>{ /** *Createanemptygraph. * *@param<L>typeofvertexlabelsinthegraph,mustbeimmutable *@returnanewemptyweighteddirectedgraph */ publicstatic<L>Graph<L>empty(){ returnnewConcreteEdgesGraph<L>(); } /** *Addavertextothisgraph. * *@paramvertexlabelforthenewvertex *@returntrueifthisgraphdidnotalreadyincludeavertexwiththe *givenlabel;otherwisefalse(andthisgraphisnotmodified) */ publicbooleanadd(Lvertex); /** *Add,change,orremoveaweighteddirectededgeinthisgraph. *Ifweightisnonzero,addanedgeorupdatetheweightofthatedge; *verticeswiththegivenlabelsareaddedtothegraphiftheydonot *alreadyexist. *Ifweightiszero,removetheedgeifitexists(thegraphisnot *otherwisemodified). * *@paramsourcelabelofthesourcevertex *@paramtargetlabelofthetargetvertex *@paramweightnonnegativeweightoftheedge *@returnthepreviousweightoftheedge,orzeroiftherewasnosuch *edge */ publicintset(Lsource,Ltarget,intweight); /** *Removeavertexfromthisgraph;anyedgestoorfromthevertexare *alsoremoved. * *@paramvertexlabelofthevertextoremove *@returntrueifthisgraphincludedavertexwiththegivenlabel; *otherwisefalse(andthisgraphisnotmodified) */ publicbooleanremove(Lvertex); /** *Getalltheverticesinthisgraph. * *@returnthesetoflabelsofverticesinthisgraph */ publicSet<L>vertices(); /** *Getthesourceverticeswithdirectededgestoatargetvertexandthe *weightsofthoseedges. * *@paramtargetalabel *@returnamapwherethekeysetisthesetoflabelsofverticessuch *thatthisgraphincludesanedgefromthatvertextotarget,and *thevalueforeachkeyisthe(nonzero)weightoftheedgefrom *thekeytotarget */ publicMap<L,Integer>sources(Ltarget); /** *Getthetargetverticeswithdirectededgesfromasourcevertexandthe *weightsofthoseedges. * *@paramsourcealabel *@returnamapwherethekeysetisthesetoflabelsofverticessuch *thatthisgraphincludesanedgefromsourcetothatvertex,and *thevalueforeachkeyisthe(nonzero)weightoftheedgefrom *sourcetothekey */ publicMap<L,Integer>targets(Lsource); } 2.2具体实现 AF、RI、SafetyfromrepexposureCheckRep：ConcreteEdgesGraph中需要实现的方法(将方法全部实现即可)：ConcreteEdgesGraph：构造方法，不需要初始化变量；checkRep：检查表示不变性；add：添加一个顶点到顶点集vertices，不能重复加入；set：输入起点source、终点target和边权值weight，若起点或终点不在vertices内，则调用add将其加入。若weight<0，则返回-1；当weight=0时，若边存在，则删去该边；当weight>0时，若该边不存在，则将该边直接加入edges，否则应删去原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点，返回所有指向该点的起点及边的权值；targets：输入起点，返回该点指向的所有终点及边的权值；toString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点，返回所有指向该点的起点及边的权值；targets：输入起点，返回该点指向的所有终点及边的权值；toString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。 
第165篇文章[1]
哈工大2021春计算机系统大作业程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P 专业计算机 学号1190200828 班级1936601 学生赵英帅 指导教师刘宏伟 计算机科学与技术学院 2021年6月 摘要 大作业名为程序人生。人生大家都懂，是从出生到死亡的过程。那么，程序的一生都会经历些什么呢？通过PPT中Hello的自白，我们可以略知一二。本文将较为完整详细地阐述hello程序的生命周期，探讨hello程序从hello.c经过预处理、编译、汇编、链接到可执行文件诞生的全过程。并且我们将分析我们的计算机系统是如何“见证”hello的成长、表演直到谢幕回收hello，即Bash与OS对hello进行的进程管理、存储管理和I/O管理。通过对hello的程序人生，我们对计算机系统将有更深的了解。 **关键词：**计算机系统，Linux，Hello程序，预处理，编译，汇编，链接，进程，存储，虚拟内存，I/O **** 目录 第1章概述-4- 1.1Hello简介-4- 1.2环境与工具-4- 1.3中间结果-5- 1.4本章小结-5- 第2章预处理-6- 2.1预处理的概念与作用-6- 2.2在Ubuntu下预处理的命令-6- 2.3Hello的预处理结果解析-6- 2.4本章小结-7- 第3章编译-8- 3.1编译的概念与作用-8- 3.2在Ubuntu下编译的命令-8- 3.3Hello的编译结果解析-8- 3.3.1全局变量sleepsecs-8- 3.3.2输出字符串-9- 3.3.3main函数参数argc、数组argv-9- 3.3.4局部变量i-10- 3.3.5main函数-10- 3.3.6关系操作-10- 3.3.7函数操作-10- 3.3.8其他操作-11- 3.4本章小结-11- 第4章汇编-12- 4.1汇编的概念与作用-12- 4.2在Ubuntu下汇编的命令-12- 4.3可重定位目标elf格式-12- 4.4Hello.o的结果解析-14- 4.5本章小结-15- 第5章链接-16- 5.1链接的概念与作用-16- 5.2在Ubuntu下链接的命令-16- 5.3可执行目标文件hello的格式-16- 5.4hello的虚拟地址空间-18- 5.5链接的重定位过程分析-19- 5.6hello的执行流程-21- 5.7Hello的动态链接分析-21- 5.8本章小结-22- 第6章hello进程管理-23- 6.1进程的概念与作用-23- 6.2简述壳Shell-bash的作用与处理流程-23- 6.3Hello的fork进程创建过程-23- 6.4Hello的execve过程-24- 6.5Hello的进程执行-24- 6.6hello的异常与信号处理-25- 6.7本章小结-28- 第7章hello的存储管理-29- 7.1hello的存储器地址空间-29- 7.2Intel逻辑地址到线性地址的变换-段式管理-29- 7.3Hello的线性地址到物理地址的变换-页式管理-30- 7.4TLB与四级页表支持下的VA到PA的变换-31- 7.5三级Cache支持下的物理内存访问-32- 7.6hello进程fork时的内存映射-32- 7.7hello进程execve时的内存映射-32- 7.8缺页故障与缺页中断处理-33- 7.9动态存储分配管理-33- 7.10本章小结-36- 第8章hello的IO管理-37- 8.1Linux的IO设备管理方法-37- 8.2简述UnixIO接口及其函数-37- 8.3printf的实现分析-38- 8.4getchar的实现分析-40- 8.5本章小结-40- 结论-41- 附件-42- 参考文献-43- 第1章概述 1.1Hello简介 hello是一个基础却最重要的程序，它的一生都在计算机系统的“照顾”下，因此从其运行的过程，我们可以学到计算机系统各个方面的知识。hello的运行过程大致分为两个阶段 P2P和020： P2P： FromProgramtoProcess的缩写，即从程序到进程的转换过程。该过程中，hello.c文件首先经历的是来自cpp的预处理，cpp并不尝试着理解C语言语法，而是在编译之前给hello“换身衣服”，即实现文本替换功能(.i)。紧接着它将经历来自ccl的编译，它将hello改头换面，转换成了我们这学期刚认识的“新朋友”，汇编代码(.s)，这已经很贴近计算机硬件了。然后as也来凑热闹，将刚刚得到的汇编代码翻译成一定格式的机器码(.o)。最后，经过ld的链接，最终形成了可执行文件(.out)。在在shell中键入启动命令后，shell为其fork产生一个子进程，然后hello便从程序变为了进程。 020: FromZerotoZero的缩写，即进程从初始到回收的过程。该过程中，shell为hello进程execve、mmap，进入程序入口后程序开始载入物理内存，然后进入main函数执行目标代码，TLB、Cache努力地让hello快点登上舞台，CPU为运行的hello分配时间片执行逻辑控制流，I/O管理与信号处理软硬结合，在各种软硬件的支持下，hello开始了它的表演。hello的表演转瞬而逝，完美谢幕，shell父进程回收hello进程，内核删除相关数据结构。 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上； 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位； 开发工具：GDB/OBJDUMP；EDB；GCC，readelf，HexEdit等。 1.3中间结果 文件名文件作用hello.ihello.c经过预处理得到的文本文件hello.shello.i编译生成的汇编文件hello.ohello.s经过汇编生成的可重定位目标文件hello.txthello.o反汇编后生成的汇编语言文本文件hello.out链接后生成的可执行文件asm.shello.o反汇编后生成的汇编语言文本文件 1.4本章小结 本章对hello进行了总体的介绍，结合hello的自述，主要简述了hello的P2P和020过程、实验的环境和工具以及实验中生成了的文件及其作用。后文将依据本章作详细展开。 第2章预处理 2.1预处理的概念与作用 预处理的概念预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。对于C语言，由预处理器CPP对程序源代码文本进行处理，得到的结果再由编译器核心进一步编译。这个过程并不对程序的源代码进行解析，但它把源代码分割或处理成为特定的单位。预处理的作用预处理中会展开以#起始的行，试图将它们解释为预处理指令，包括#if/#ifdef/#ifndef/#else/#elif/#endif（条件编译）、#define（宏定义）、#include（头文件包含）、#line（行控制）、#error（错误指令）、#pragma（和实现相关的杂注）以及单独的#（空指令）。预处理指令一般被用来使源代码在不同的执行环境中被方便的修改或者编译。 2.2在Ubuntu下预处理的命令 预处理的命令为：cpphello.c>hello.i，当然也可以是gcc-Ehello.c-ohello.i。这两个指令都可以得到预处理得到的文件，即hello.i。 由下截图可知，预处理成功，我们得到了hello.i文件。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1iupoXLS-1624591156865)(media/c4ebb97fc1e832d01f294f267dbc0530.png)] 2.3Hello的预处理结果解析 打开hello.i文件，我们发现，该文件与hello.c相比，hello.i明显多了许多内容。结合预处理的概念及作用，不难得知，多出来的内容为预处理得到的头文件stdio.h、unistd.h、stdlib.h的具体内容。将文件翻到最后可以看到，hello.c中的C语句内容并未发生改变，进一步说明预处理并不对程序的源代码进行解析。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BdH5NJVP-1624591156867)(media/482cccaee3e7609d8fbdfae080c9c735.png)] 2.4本章小结 本章对hello的P2P阶段的第一步，即来自cpp的预处理过程进行介绍，主要介绍了预处理的概念及作用、在Ubantu中对hello.c的预处理命令以及预处理的结果，了解到预处理是对头文件包含、宏定义等行进行解释，并不对程序的源代码进行解析。 第3章编译 3.1编译的概念与作用 编译的概念编译是指编译器ccl将文本文件hello.i翻译成文本文件hello.s的过程，翻译得到的hello.s中包含一个汇编语言程序。编译的作用首先ccl将检查代码的正确性，即进行词法分析、语法分析、语义分析等，检查无误后，ccl将源代码翻译为汇编代码。 3.2在Ubuntu下编译的命令 编译的命令为：gcc-Shello.c-ohello.s； 由下截图知，编译成功，我们得到了hello.s文件。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c4bVdUfp-1624591156869)(media/e4d5e69d9a419946ea7d1c709a933073.png)] 3.3Hello的编译结果解析 3.3.1全局变量sleepsecs 对于全局变量sleepsecs的定义的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QqLfRhuT-1624591156870)(media/8674fe0877735d563787f14c385fe0b9.png)] 分析首先，globl声明该变量为全局变量，align为其地址对齐方式，type声明该变量为数据类型而非函数类型，.rodata声明只读代码段。因为sleepsecs变量为int型，所以size为4；其次，对于后续对sleepsecs的定义中，.long为2表明该变量的值为2，其他声明作用同上；最后，读C语言代码可知，sleepsecs=2.5，但是在汇编代码中.long却是2，这是因为sleepsecs类型为int而非float，相当进行一个隐式类型转换操作，即intsleepsces=(int)2.5，于是编译后其值为2。 3.3.2输出字符串 对于两个输出字符串的定义的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OCL0sJN9-1624591156871)(media/51d5588a4cf0314c9138707f10504d24.png)] 分析：根据后续代码结合源文件可知，这两个字符串将作为调用printf函数的参数，具体方法将在后续分析中给出。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IHI5lJQP-1624591156872)(media/300b955e4c5ffa87ad8bc6cfa05daa49.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Cd7n70lF-1624591156872)(media/5dad954b83aa76944c1e96384b17ae9d.png)] 3.3.3main函数参数argc、数组argv 处理argc、数组argv的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cJkVV28y-1624591156873)(media/c4ea6313165cf5951cfc354abd9e23d5.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kvq7804e-1624591156873)(media/d314f93e4bbb2222f7c80003957eac0c.png)] 分析：第29行和30行进行的是将参数argc与数组argv的地址压栈的过程，主要判断依据是第31行的操作，即将存在地址%rbp–20处的值与3进行比较，由hello.c的代码可知，第31行实际上正是参数argc与3的比较；而在第41到50行进行的数组操作是，将数组argv中的argv[1]和argv[2]两个值作为调用printf函数输出字符串LC1的两个参数。 3.3.4局部变量i 处理i的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mIH4p0Hm-1624591156874)(media/acc1abfccbd59e99e89f0d9720ebe97a.png)] 分析：局部变量i被压入栈中，保存在地址%rbp-4中。局部变量作为循环变量，除赋初值为0外，还需要进行的算数操作是每次循环加1，即每次循环中的代码执行完毕，i++，相应的汇编代码出现在L4中： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kTn19uAy-1624591156874)(media/31d8f7d5ac9a7ef1e77d13ff8c3e0c5b.png)] 3.3.5main函数 对于main函数的说明的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ro5gbaJK-1624591156874)(media/cee49dfcaf216f3d6ee63856dd5e1b13.png)] 分析：对于main函数，首先.globl声明main为全局变量，而type则声明main为函数类型而非数据类型，因此main为全局函数。main函数为主函数，是程序执行的起点。 3.3.6关系操作 hello.c中包括的关系操作有argc!=3和i<10，相应的源码及其翻译而成的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wjp4yufU-1624591156875)(media/146f9e06e951aa4922d4770e01fc7110.png)]=>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7gYYxwzh-1624591156875)(media/66df1470711f076f5d8b6a4b01988cb6.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pllTMzzL-1624591156876)(media/8ea832f2c7867c999d0b06dc939af2c4.png)]=>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zPpK7XDx-1624591156876)(media/faafec942e016315f819a229ef9d6c63.png)] 分析：关系操作argc!=3在汇编代码中被翻译为cmpl，而cmpl后将进行跳转je操作，即控制转移。当argc等于3时，不满足条件，则跳过if跳转至L2，执行L2中的操作即将i的初值设置为0，然后跳转L3执行if之后的for循环语句；否则将执行if中的语句。关系操作i<10在汇编代码中被翻译为cmpl和jle，在L3中判断循环条件，即i是否小于等于9，即i小于10。若满足循环条件，则跳转至L4继续进行循环，L4执行完最后一句时自动进入L3，再次判断循环条件，若满足循环条件则再次跳进L4，直到i<10不成立即循环条件不满足时，循环结束。 3.3.7函数操作 hello.c中有关函数的操作有main函数的执行，调用printf函数、exit函数、sleep函数、getchar函数，以及main函数的返回return，相关汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-55z4GV9z-1624591156876)(media/815ac5bc6d2a9f04fb83ff79ba5b43f2.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IEtIgoVv-1624591156877)(media/9a6bbc66fdd8b6c6d3072c98f32652e8.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zonNGyCn-1624591156877)(media/c60c3da79c8d20ae7b1c57d0c7b9b4d6.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-e9grMHMz-1624591156877)(media/3924f79f039565c3f0fbf5fefe605f65.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-phVZ5oxP-1624591156878)(media/2e2c94abf7c31d6aac2c8e27af7da147.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-O9XWehfG-1624591156878)(media/79d2b2d2ad860e406f800f5a91711127.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vWQvPkCt-1624591156879)(media/561a77bd763d8e79262f5ba8d70b2d4c.png)] 分析：首先，main函数是主函数，是程序执行的起点。main函数中，进行了两次输出函数printf的调用，但是汇编代码中却并不都是call的printf，其中第一次call的是puts，我认为原因在于该次调用输出函数并不需要传递参数，于是调用puts，将字符串输出即可。而第二次调用printf是在循环中，这次调用输出函数需要有参数，即argv[1]和argv[2]，传参过程及汇编代码已经在3.3.3中展示，不再重复；将1作为参数调用exit函数，表示异常退出；将全局变量sleepsecs作为参数调用sleep函数，让进程休眠2秒；调用getchar函数，吸收缓存区的所有字符；return0，即main函数的返回值为0。 3.3.8其他操作 赋值操作：主要是对全局变量sleepsecs和局部变量i的赋值，翻译为汇编代码的赋值操作为mov，在3.3.1和3.3.4中已经展示，不再重复；【注】mov具体包括：movb一个字，movw两个字节，movl四个字节，movq八个字节，遍布整个汇编代码；类型转换：在3.3.1中已经展示全局变量sleepsecs赋值时的隐式转换，不再重复；算术操作：主要是for循环中i++操作，翻译为汇编代码为add，在3.3.4中已经展示，不再重复；数组操作：主要是argv的数组操作，在3.3.3中已经展示，不再重复；控制转移：在3.3.6中已经与关系操作一同展示，不再重复。 3.4本章小结 本章主要介绍了编译的概念及作用，结合PPT中的提示，重点展示了在编译阶段中，编译器如何处理hello.c中的各种数据和操作，以及各类型数据和操作经过编译器翻译后对应的汇编代码。 第4章汇编 4.1汇编的概念与作用 汇编的概念 汇编语言是为特定计算机或计算机系列设计的一种面向机器的语言，由汇编执行指令和汇编伪指令组成。采用汇编语言编写程序虽不如高级程序设计语言简便、直观，但是汇编出的目标程序占用内存较少、运行效率较高，且能直接引用计算机的各种设备资源。它通常用于编写系统的核心部分程序，或编写需要耗费大量运行时间和实时性要求较高的程序段。 汇编的作用 汇编程序是指把汇编语言书写的程序翻译成与之等价的机器语言程序的翻译程序。汇编程序输入的是用汇编语言书写的源程序，输出的是用机器语言表示的目标程序。 4.2在Ubuntu下汇编的命令 预处理的命令为：ashello.s-ohello.o； 由下截图知，编译成功，我们得到了hello.o文件 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eMnGQpC0-1624591156879)(media/589bcf23f7c6c5bffeffe8d80bd1837e.png)] 4.3可重定位目标elf格式 readelf-hhello.o查看ELF头ELFHeader，结果如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Kk5qPLL6-1624591156880)(media/c01877ab26f54675771226dfc854e94a.png)] 在ELFHeader中可以看到ELF类型、版本、大小端等信息。根据头文件的信息，可以知道该文件是可重定位目标文件，有14个节。 readelf-Shello.o查看节头表SectionHeaders，结果如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-We4UOmU3-1624591156881)(media/6ffb1579d2b8d1e3dde0d98cc2fd71ad.png)] 在SectionHeaders中可以看到，目标文件中的每个节都有一个固定的条目体现在这个表中，指明了各个节的信息，包括名称、类型、起始地址和偏移量等。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。同时从信息中可以观察到，代码段可执行，但是不可写；数据段和只读数据段都不可执行，只读数据段不可写等。 readelf-rhello.o查看重定位节.rela.text，结果如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tG10x8ey-1624591156881)(media/6f85b4287c03aec8aa67db9ec82063d0.png)] 重定位节中保存的即是可重定位文件必须包含的说明如何修改其节内容的信息。当汇编器生成一个目标模块时，它并不知道数据和代码最终存放在内存中的什么位置，也不知道这个模块引用的任何外部定义的函数和全局变量的位置。而通过重定位节中保存的修改信息，链接器就能知道在将目标文件链接成可执行文件时如何修改这些未知引用。 readelf-shello.o查看符号表.symtab，结果如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZtYrEtCh-1624591156882)(media/cb189620be29b694e9522e3f2cce7cda.png)] 符号表：存放程序中定义和引用的函数和全局变量的信息。 Name：符号名称；Value：符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址；Size：目标的大小；Type：声明是数据类型还是函数类型；Bind：声明符号是局部的还是全局的。 4.4Hello.o的结果解析 objdump-d-rhello.o>hello.txt对hello.o进行反汇编，并将结果保存至hello.txt文件中；分析： 由反汇编生成的hello.txt与hello.s的比较可知，hello.txt中的汇编代码部分与hello.s功能上基本没有区别，形式上略有区别，例如： .s文件中由对于输出字符串、全局变量的定义，而反汇编代码中没有，这就导致了访问只读字符串、全局变量时方法的改变；[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uk1JgTiI-1624591156883)(media/518a5626e455a3b3548ddd3e78714404.png)]VS[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3MQrWhUY-1624591156883)(media/30b2a6232e9ce271a757a141a21b80c5.png)]在.s文件中的操作数为十进制，而在反汇编文件中为十六进制；[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-p4UU4tzW-1624591156884)(media/f616c9d335d6d3946e684778e046bcfe.png)]VS[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7fq8Vhvq-1624591156884)(media/36bb69e951ca0fead8f53803c1c1792a.png)].s文件中，调用转移函数时，控制转移到的地址是用L2等段名称表示，而反汇编文件中是用确定的地址； [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VE8zps4C-1624591156885)(media/1e08eeb5c0bde86e4827c2631565f4b7.png)]VS[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SNV3Z959-1624591156885)(media/1c3322044dc5237dd2b2ed9b2035ae5d.png)] 调用函数时，.s文件中是调用函数名，而反汇编代码中是调用函数链接修改后的相对偏移地址；[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vErc9Gql-1624591156885)(media/5756bb90b88f5f06cf3b93aff0a50747.png)]VS[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vV4E8YZG-1624591156886)(media/83c0a4b11f4a48a91800c0d361bcd55a.png)] 相对于汇编代码形式上的些许差别，两文件最大的不同是反汇编代码中包括了机器语言代码。 机器语言程序的是二进制机器指令的集合，是纯粹的二进制数据表示的语言，是电脑可以真正识别的语言。机器指令由操作码和操作数构成，汇编语言是人们比较熟悉的词句直接表述CPU动作形成的语言，是最接近CPU运行原理的语言。每一条汇编语言操作码都可以用机器二进制数据来表示，进而可以将所有的汇编语言和二进制机器语言建立一一映射的关系，因此可以将汇编语言转化为机器语言。 4.5本章小结 本章对hello.s进行了汇编，生成了hello.o可重定位目标文件，并且分析了可重定位文件的ELF头、节头表、可重定位节和符号表。本章还对hello.s进行了反汇编，比较了hello.s和hello.o反汇编代码的略微不同之处，介绍了机器语言的概念，并分析了从汇编语言到机器语言的一一映射关系。 第5章链接 5.1链接的概念与作用 链接的概念 链接是指在电子计算机程序的各模块之间传递参数和控制命令，并把它们组成一个可执行的整体的过程。 链接的作用 链接器将多个可重定位目标文件合并，生成可执行目标文件，这个文件可以被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。这使得分离编译成为可能。 5.2在Ubuntu下链接的命令 链接的指令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o-ohello.out 由下截图知，连接成功，生成了hello.out文件。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9tOGDDMG-1624591156886)(media/6a8d3e78968621881e4310f9b9eab67a.png)] 5.3可执行目标文件hello的格式 查看hello.out的ELF头： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dEqamn3G-1624591156887)(media/5d98f37c68562a799e5b5b55bf373100.png)] 从ELF头中可以知道，hello.out为可执行文件，并且包含27个节； 查看节头表： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OWuDfAOJ-1624591156887)(media/e8fabd4d45368783206bc03866068ff8.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lyne0WGJ-1624591156888)(media/e878b786a4012fa34f342d3651b1bda5.png)] 节头部表SectionHeaders对hello.out中所有的节信息进行了声明，包括大小、类型、地址、偏移量等，其中地址是指程序被载入到虚拟地址的起始地址。根据SectionHeaders中的信息我们就可以用HexEdit定位各个节所占的区间（起始位置，大小）。 查看链接后的重定位节： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E1PtDV52-1624591156889)(media/9bf636aea04351d67588c81871039bca.png)] 查看符号表： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eZyv8w9q-1624591156889)(media/0b341ccf978f7c0c9614b2ba880edb4b.png)] 5.4hello的虚拟地址空间 通过edb查看hello.out的虚拟地址空间各段的信息： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LOG5eXLp-1624591156890)(media/f17131a001e7a21248df7ff9498545b1.png)] 结合5.3中的节头表中各节的起始地址信息，可以通过edb的MemoryReigions找到各个节段的信息，例如.rodata节，起始地址为0x402000，大小为0x3A，在EDB中查看如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-P8lV5MGV-1624591156890)(media/bf8ec4bcb45f865573f4186108f7c2da.png)] 其他段的信息查看方式与.rodata节相同。 5.5链接的重定位过程分析 用命令objdump-d-rhello.out>asm.txt获得hello的反汇编代码并存入asm.txt文件中，由下截图知反汇编成功，生成了asm.txt文件。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xfSjAnrv-1624591156890)(media/73258818341aa1a325d9226dc5a1fa83.png)] 分析hello.out与hello.o的不同：hello.out反汇编的代码中多了很多的节以及其函数的汇编代码，如.init节、.plt节等，如下截图所示： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mTSTqU6d-1624591156891)(media/b5e78b99952a70dd7d8815ee27834c8a.png)] hello.out反汇编的代码有确定的虚拟地址，也就是说已经完成了重定位,而hello.o反汇编代码中代码的虚拟地址均为0，未完成可重定位的过程。例如下面两个截图，第一行为hello.out反汇编的代码而第二行为hello.o反汇编代码中与第一行对应的的代码： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-h5ivYucZ-1624591156892)(media/1104758b052b99ab76f628d6356ebf7f.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GvDfdu92-1624591156892)(media/8115a13f0e32b77f4db5c98248fde80c.png)] 链接与重定位过程：符号解析：目标文件(.o)定义和引用了符号，每个符号对应着一个函数、一个全局变量、一个静态变量等。符号解析的作用就是给每个符号引用分配一个精确的符号定义。链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对于那些引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。但是，对全局符号的引用解析要棘手得多。当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条(通常很难阅读的)错误信息并终止。重定位：重定位条目：当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在rel.text中。已初始化数据的重定位条目放在，rel.data中。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vk1XWYZ6-1624591156893)(media/061db4fd07eeca2127e5dc012014578e.png)] 重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节；重定位节中的符号引用：链接器依赖于可重定位目标模块中的重定位条目，修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。举例分析hello.out中的重定位过程： puts()： 重定位算法： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-x2OuOrVv-1624591156893)(media/de36c033475d7e7404986483b92d758d.jpeg)] 由puts的重定位条目，可得：r.offset=0x21;r.type=R_X86_64_PLT32;r.symble=puts;r.attend=-4;确定ADDR(s)=0x401105;由重定位算法，公式为：refaddr=ADDR(s)+r.offset=0x401105+0x21=0x401126*refptr=(unsigned)(ADDR(r.symbol)+r.addend-refaddr)=(0x401080+(-4)-0x401126)=-0xaa=(unsigned)(0xffffff56） 经验证，计算正确！相关截图如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FLHKqUei-1624591156893)(media/ebfd747ea49acd0aa745b766b3f40b33.png)] 5.6hello的执行流程 ld-linux-x86-64.so!_dl_start ld-linux-x86-64.so!_dl_init hello!_start hello!__libc_csu_init hello!_init libc.so!_setjmp hello!main hello!puts@plt ld-linux-x86-64.so!_dl_runtime_resolve_xsave ld-linux-x86-64.so!_dl_fixup ld-linux-x86-64.so!_dl_lookup_symbol_x hello!exit@plt libc.so!exit hello!_fini 5.7Hello的动态链接分析 动态链接简介动态链接，在可执行文件装载时或运行时，由操作系统的装载程序加载库。动态链接库中的函数在程序执行的时候才会确定地址，所以编译器无法确定其地址。为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。延迟绑定通过两个数据结构之间简洁但又有些复杂的交互来实现，即过程链接表（PLT）和全局偏移量表（GOT）。 PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 dl_init调用前后.got.plt的变化：由节头表可得.got.plt的地址为0x404000，大小为0x40： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jlONDXQb-1624591156894)(media/a9314c8778a39a81ca686a95b615b819.png)] 【注】蓝色选中区域即为.got.plt： 调用dl_init前： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-z1IH7jDG-1624591156894)(media/60b0fdd7bc35239b26d29494e3a6e2b8.png)] 调用dl_init后： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AqO1xalA-1624591156895)(media/310f78a6d769b2415a777bdd8ffd10de.png)] 对比信息，可见动态链接器解析函数的地址加入了信息中。 5.8本章小结 在本章中主要介绍了链接的概念与作用，并且详细阐述了hello.o链接成为一个可执行目标文件的过程，介绍了hello.o的ELF格式和某些节的含义，分析了hello.out的虚拟地址空间、重定位过程、执行流程、动态链接过程。经历了预处理、编译、汇编、链接，可执行的hello终于诞生了！虽然它在我这里叫做hello.out，但这对它的功能并没有什么影响。在以下的实验中，hello.out简称为hello。 第6章hello进程管理 6.1进程的概念与作用 进程的概念 进程是计算机科学中最深刻、最成功的概念之一，其经典定义为一个执行中程序的实例。 进程的作用 我们将关注它提供给应用程序两个关键抽象：一是一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器；二是一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 shell本身是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。作为命令语言，它交互式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支； shell的处理流程： 从终端读入输入的命令；将输入字符串切分获得所有的参数；如果是内置命令则立即执行，否则调用相应的程序执行；shell应该接受键盘输入信号，并对这些信号进行相应处理 6.3Hello的fork进程创建过程 当输入的命令不是内置shell命令时，父进程调用fork()函数创建一个新的子进程，子进程得到与父进程完全相同（但是独立）的一个副本，包括代码段、段、数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和子进程最大的不同时他们的PID是不同的。 有关hello的fork进程创建过程，例如当我在终端运行hello，输入运行指令./helloxy时，首先shell判断我输入的指令是否是shell内置命令，很显然不是，因此会调用fork为hello创建一个新的进程。 6.4Hello的execve过程 成功创建hello子进程之后，将调用execve函数在当前子进程的上下文加载并运行一个新的程序即hello程序。 当执行成功时，execve()并不会返回,调用execve的程序的代码段，data段，bss段和stack都将被加载的新程序的内容重写．这种状况其实就是金蝉脱壳，能够使用该函数来作程序的自更新；当调用失败时，返回-1,errno也被当即更新。 6.5Hello的进程执行 进程执行的相关概念两个抽象： 一个独立的逻辑控制流，它提供一个假象，好像我们的进程独占的使用处理器；一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用CPU内存。 逻辑并发流： 即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做逻辑控制流，或者简称逻辑流。 并发与时间片： 一个逻辑流的执行在时间上与另一个流重叠，称为并发流； 多个流并发地执行的一般现象被称为并发； 一个进程执行它的控制流的一部分的每一时间段叫做时间片。 私有地址空间： 进程为每个程序都提供一种假象，好像它独占地使用系统地址空间。一般而言，和地址空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，在这个意义上，这个地址空间是私有的。 用户模式和内核模式 处理器提供了一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常是用某个控制寄存器中的一个模式位(modebit)来提供这种功能的,该寄存器描述了进程当前享有的特权。 当设置了模式位时，进程就运行在内核模式中，一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置；没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令，也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。 运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序,处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。 上下文切换： 内核为每个进程维持一个上下文(context)。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度，是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换1)保存当前进程的上下文，2)恢复某个先前被抢占的进程被保存的上下文，3)将控制传递给这个新恢复的进程。 hello进程的执行 进程调用execve函数之后，进程已经为hello程序分配了自己的私有地址空间。当自定义参数有两个，分别是我的姓名和学号时，一开始，hello运行在用户模式下，输出Hello1190200828赵英帅，然后hello调用sleep函数之后进程转变为内核模式，内核不会等待sleep函数调用结束，而是休眠并释放hello进程，并将hello进程从当前运行队列中移出加入待运行队列，并转换回用户模式。随后定时器开始计时，内核进行上下文切换将当前进程的控制权交给其他进程。2秒后，休眠结束，定时器发送一个中断信号，进入内核模式处理中断，并将hello进程从待运行队列重新移入到运行队列，然后hello进程就又可以“登场表演”了。当然，再次输出Hello1190200828赵英帅后将重复以上过程，直到运行10次。而当自定义参数不为2时，则要简单的多，因为不会调用sleep也就没有模式转换，也就没有额外的上下文切换，hello表演转瞬即逝，直接退场。 6.6hello的异常与信号处理 异常的分类 异常可以分为四类：中断、陷阱、故障和终止，下图为对这些类别异常的属性做了小结。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yNDuU44i-1624591156895)(media/77b8b62534babb014b4c612bad70d1be.jpeg)] 中断中断是异步发生的，是来自处理器外部的I/O设备信号的结果。硬件中断不是任何一条专门的指令造成的，从这个意义上来说它是异步的。处理器从系统总线读取异常信号，然后调用适当的中断处理程序。当处理程序返回时，它将控制返回下一条指令，程序继续执行，就像没有发生中断一样。陷阱：陷阱是有意的异常，是执行一条指令的结果。像中断处理程序一样，陷阱处理程序将控制返回下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，称为系统调用。用户程序经常需要向内核请求服务，为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的“syscalln”指令，当用户程序想要请求服务n时，可以执行这条指令。执行该指令会导致一个异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。故障：故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。终止：终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。hello会出现的异常及信号在hello程序执行的过程中可能会出现外部I/O设备引起的异常，造成中断；hello执行sleep函数的时候会出现陷阱；执行hello程序的时候，可能会发生缺页故障；hello执行过程可能会出现DRAM或者SRAM位损坏的奇偶错误，引起终止。常见信号： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TrJZf8LA-1624591156895)(media/8ac0289d4bdb73eb883375525cbec3d5.jpeg)] 程序运行过程的键盘输入随便输入： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9MEyCiGS-1624591156896)(media/28921418fd2ddd2cd1e04c8fd004f519.png)] 可以发现，随便输入只是将屏幕的输入缓存，当打印结束执行getchar时，会读入一个回车结尾的字串作为一次输入，而其他字符串包括回车会在程序结束后当做shell命令行输入呈现。 Ctrl-z后分别运行psjobspstreefgkill等命令： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kGiKagRf-1624591156896)(media/8aa0b4af68f166e9b730b875cc4af2a4.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-PyT7f711-1624591156897)(media/49e1da59dd72c1debc455ff16f14d4d7.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mQfQcc0m-1624591156898)(media/1ca30a536f4fd78dcc66ae0a60ba50c5.png)] Ctrl-z后运行ps可以看出，hello并未被回收，而是被挂在了后台，jobs显示hello进程已停止，由于pstree太长，此处知识截了一部分的图。运行fg命令，发现hello进程又一次来到了前台继续运行。再次Ctrl-z，然后运行命令kill-93827，即向hello进程发送SIGKILL信号杀死程序，再向用fg将hello调回前台运行时发现任务已被杀死。 Ctrl-C：输入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况是终止前台作业，如下截图所示，用ps查看前台进程组发现没有hello进程信息。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-i1s8fWHN-1624591156898)(media/a508dadeff093ee25e7fc043568e8e8c.png)] 6.7本章小结 本章阐述进程的概念与作用，同时介绍了shell对命令的一般处理流程和shell的作用，着重分析了调用fork创建新进程，调用execve函数加载并执行hello，hello进程的执行，以及hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：指由程式产生的和段相关的偏移地址部分。例如，在进行C语言指针编程中，能读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，他是相对于你当前进程数据段的地址，与绝对物理地址不相关。只有在Intel实模式下，逻辑地址才和物理地址相等（因为实模式没有分段或分页机制,Cpu不进行自动地址转换）；逻辑也就是在Intel保护模式下程式执行代码段限长内的偏移地址（假定代码段、数据段如果完全相同）。线性地址：是逻辑地址到物理地址变换之间的中间层。程式代码会产生逻辑地址，或说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。虚拟地址：指由程序产生的由段选择符和段内偏移地址组成的地址，实际上就是线性地址；物理地址：用于内存芯片级的单元寻址，与处理器和CPU链接的地址总线相对应。可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部份组成，段标识符:段内偏移量。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aqytV7a0-1624591156899)(media/d513e506ac08ee67a57dc2f605be34a0.png)] 段式管理的特点： 段式管理以段为单位分配内存，每段分配一个连续的内存区；由于各段长度不等，所以这些存储区的大小不一；同一进程包含的各段之间不要求连续；段式管理的内存分配与释放在作业或进程的执行过程中动态进行。 逻辑地址转换为线性地址的一般步骤： 首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]； 看段选择符的T1=0还是1，判断当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，求其地址和大小，得到一个数组；拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，得到基地址base；base+偏移量就是要转换的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 虚拟寻址形式： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NpU0jjdO-1624591156900)(media/8c0c8ea87cd778cf9acfd241d2bb02ff.jpeg)] 虚拟页和物理页：虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘(较低层)上的数据被分割成块，这些块作为磁盘和主存(较高层)之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页(VirtualPage,VP)的大小固定的块来处理这个问题。每个虚拟页的大小为P=2p字节。类似地，物理内存被分割为物理页(PhysicalPage，PP)，大小也为P字节(物理页也被称为页帧(pageframe))。在任意时刻，虚拟页面的集合都分为三个不相交的子集：未分配的：VM系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间；缓存的：当前已缓存在物理内存中的已分配页；未缓存的：未缓存在物理内存中的已分配页。SRAM和DRAM：SRAM缓存表示位于CPU和主存之间的2高速缓存L1、L2和L3；DARRAM缓存表示虚拟内存系统的缓存，它在主存中缓存虚拟页。在存储层次结构中，DRAM缓存的位置对它的组织结构有很大的影响。DRAM比SRAM要慢大约10倍，而磁盘要比DRAM慢大约100000多倍。因此DRAM缓存中的不命中比起SRAM缓存中的不命中要昂贵得多，这是因为DRAM缓存不命中要由磁盘来服务，而SRAM缓存不命中通常是由基于DRAM的主存来服务的。因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是4KB~2MB。由于大的不命中处罚，DRAM缓存是全相联的，即任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的处罚也非常之高。页表：页表是一个存放在物理内存中的数据结构，页表将虚拟页映射到物理页，配合硬件确定虚拟页在磁盘中的位置。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。地址翻译：形式上来说，地址翻译是一个N元素的虚拟地址空间中的元素和一个M元素的物理地址空间中元素之间的映射。虚拟地址(VA)由VPN和VPO组成，其中VPO是虚拟页面偏移量，取值区间在0到2p-1,因此VPO为虚拟地址的低p位；VPN围殴虚拟页号，包含了TLB索引(TLBI)和TLB标记(TLBT)；物理地址(PA)由PPN和PPO组成，其中PPN为物理页号，PPO为物理页面偏移量。物理地址可以被分为CO、CI、CT，即缓冲块内的字节偏移量、缓存索引和缓存标记。由虚拟地址VPN中的TLBI和TLBT结合TLB表可以知道该次访存命中还是缺页，若命中则由TLB表可得PPN，而PPO与VPO相等，而PPN与PPO合在一起就构成了物理地址。若缺页，则引发缺页故障，从磁盘中将待访问页拿出来，用优良的替换算法进行页替换。 7.4TLB与四级页表支持下的VA到PA的变换 Corei7地址翻译的概况图 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TH7mKjLq-1624591156900)(media/651c663aecf6434a9c078e6622793a9b.jpeg)] 由上图不难得知，该虚拟地址共48位，其中前36位为VPN，后12位为VPO，TLB为16组级联，共64个条目，所以TLBI应为4位，TLBT位36-4等于32位。由于是四级页表，VPN可以分为VPN1~4，对应一到四级页表。地址翻译：基本与7.3.5中单页表中的地址翻译方式相同，此处不再重复。 7.5三级Cache支持下的物理内存访问 分析：由7.4中的概况图，因为有64组，所以组索引应有6位；每行64B，所以块偏移为6位；所以标记位为52-6-6=40位。物理访存过程：通过组索引选择相应的组；检查高速缓存是否命中，即该组中是否某一行的标记位与物理地址的标记位相同且该行的有效位为1；若命中，则通过块偏移找到返回的缓存字节；若未命中，则需要从存储层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位所指示的组中的一个高速缓存行中。一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置；否则组内都是有效块，产生冲突，最好采用最近最少使用策略LFU进行替换。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了当前进程的mn_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在hello进程中返回时，hello现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并运行包含在可执行目标文件hello.out中的程序，用hello.out程序有效地替代了当前程序。加载并运行hello.out需要以下几个步骤： 删除已存在的用户区域，即删除当前进程虚拟地址的用户部分中的已存在的区域结构；映射私有区域，即为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello.out文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello.out中。栈和堆地址也是请求二进制零的，初始长度为零；映射共享区域，即hello程序与共享对象标准C库libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内；设置程序计数器（PC），即设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 某指令引用的某字并未缓存在DRAM中；地址翻译硬件从内存中读取该字,并且触发一个缺页异常；缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，；如果牺牲页已经被修改过，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改牺牲页的页表条目，反映出该页不再缓存在主存中这一事实；内核从磁盘复制待缓存的页到内存中牺牲页的物理地址，更新PTE，随后返回；重新启动导致缺页的命令，该命令会把导致缺页的虚拟地址重发送到地址翻译硬件；当指令再次执行时，相应的物理页面已经驻留在内存中，页命中，因此指令可以没有故障的运行完成。 7.9动态存储分配管理 动态内存分配器的基本原理 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Hlo5E8uJ-1624591156901)(media/c377ec21fdb980d57f2570f4d4bbbce1.jpeg)]动态内存分配器维护着一个进程的虚报内存区域，移为地(heap)。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长(向更高的地址)。对于每个进程，内核维护着一个变量brk(读做“break”)，它指向堆的顶部。 分配器将堆视为一组不同大小的块(block)的集合来维护，每个块就是一个连续的虚摇内存片(chunk)，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用、空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格，两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器(explicitallocator)，要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过谓用malloc函数来分配一个块，并通过调用free函数来释放一个块，C++中的new和delete操作符与C中的malloc和free相当。 隐式分配器(implicitallocator)，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器(garbagecollector)，而自动释放未使用的已分配的块的过程叫做垃圾收集(garbagecollection)。例如，诸如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 带边界标签的隐式空闲链表分配器 隐式空闲链表区别块的边界、已分配块和空闲块的方法如图所示： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xdInLrb9-1624591156901)(media/4e2c991c761f5a3ce6242e10d627b44f.jpeg)] 这种情况下，一个块是由一个字的头部、有效载荷，以及可能的填充组成。头部编码了这个块的大小(包括头部和所有的填充),以及这个块是已分配的还是空闲的。块的头最后一位指明这个块是已分配的还是空闲的。 头部后面是应用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。块的格式如图所示，空闲块通过头部块的大小字段隐含的连接着，所以我们称这种结构就隐式空闲链表。 放置已分配的块 当一个应用请求一个k字节的块时，分配器搜索空闲链表。查找一个足够大可以放置所请求的空闲块。分配器搜索方式的常见策略是首次适配、下一次适配和最佳适配。 分割空闲块 一旦分配器找到一个匹配的空闲块，就必须做一个另策决定，那就是分配这个块多少空间。分配器通常将空闲块分割为两部分。第一部分变为了已分配块，第二部分变为了空闲块。如图所示。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ROCqwgTR-1624591156902)(media/d76de44948cd2b3038d346220b868188.jpeg)] 获取额外堆内存 如果分配器不能为请求块找到空闲块，一个选择是合并那些在物理内存上相邻的空闲块，如果这样还不能生成一个足够大的块，分配器会调用sbrk函数，向内核请求额外的内存。 合并空闲块 合并的情况一共分为四种：前空后不空，前不空后空，前后都空，前后都不空。对于四种情况分别进行空闲块合并，我们只需要通过改变头部的信息就能完成合并空闲块。Knuth提出了一种采用边界标记的技术快速完成空闲块的合并。如图所示。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EU5StDV2-1624591156902)(media/886f30c2dc04b93916698856027e231c.jpeg)] 显式空间链表的基本原理 隐式空闲链表为我们提供了一种介绍一些基本分配器概念的简单方法。然而，因为块分配与堆块的总数呈线性关系，所以对于通用的分配器，隐式空闲链表是不适合的(尽管对于堆块数量预先就知道是很小的特殊的分配器来说它是可以的)。 一种更好的方法是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred(前驱)和succ(后继)指针，如图所示。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XUzPDus0-1624591156903)(media/0d5972340b7bf7493cba8ee7ccc0b35c.jpeg)] 使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略。 一种方法是用后进先出(LIFO)的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 动态分区分配策略最先匹配：分配n个字节，使用第一个可用空间比n大的空闲区。 原理：空闲分区列表按照地址顺序排序；分配过程中，搜索第一个适合的分区；释放分区时，检查是否可与临近的空闲分区合并； 优点：简单；在高地址空间有大块的空闲分区； 缺点：外部碎片；分配大块使较慢。 最佳匹配：分配n个字节时，查找并使用不小于n的最小空闲分区。 原理：空闲分区列表按照大小排序；分配时，查找一个合适的分区；释放时，查找并且合并临近的空闲分区； 优点：避免大的空闲分区被拆分；可减小外部碎片的大小； 缺点：外部碎片；释放分区较慢；容易产生很多无用的小碎片 最差匹配；分配n个字节时，查找并使用不小于n的最大空闲分区。 原理：空闲分区列表按照从大到小排序；分配时，选最大的分区；释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序； 优点：中等大小的分配较多时，分配效果最好；避免出现太多的小碎片； 缺点：释放分区较慢；外部碎片；容易破坏大的空闲分区，因此后续难以分到大的分区 7.10本章小结 本章主要介绍了hello.out的存储器的地址空间，介绍了四种地址空间的概念和地址的相互转换。同时介绍了hello.out的四级页表的虚拟地址空间到物理地址的转换、三级cashe的物理内存访问、进程fork、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理等相关知识。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行，这就是UnixI/O接口。 8.2简述UnixIO接口及其函数 UnixI/O接口的统一输入输出方式： 打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访间一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符；Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO、STOOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值；改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k,初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k；读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k；关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O接口函数： intopen(char*filename,intflags,mode_tmode);函数功能：open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符；函数参数：filename：要打开的文件名；flags：指明进程将如何访问这个文件；mode：指定新文件的访问权限位；intclose(intfd);函数功能：关闭一个打开的文件，返回操作结果； 函数参数： fd：要关闭的文件的描述符； ssize_tread(intfd,void*buf,size_tn);函数功能：read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF，否则返回值表示的是实际传送的字节数量； 函数参数： fd：要读的文件的描述符； buf：将要读入到的内存位置； n：复制字节上限； ssize_twirte(intfd,constvoid*buf,size_tn);函数功能：从内存位置buf复制至多n个字节到描述符为fd的当前文件位置； 函数参数： fd：要读的文件的描述符； buf：将要读入到的内存位置； n：复制字节上限； 8.3printf的实现分析 printf的函数体： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-baHeOfAb-1624591156903)(media/44d8c86b550e633eacb1e6b7885b4053.png)] printf函数的内容： 首先将第一个参数入栈，然后调用vsprint函数，该函数作用为格式化输出字符串，返回值为要打印的字符串长度i。再调用write函数，将i位字符串写入终端，将栈中参数放入寄存器。intINT_VECTOR_SYS_CALLA代表通过系统调用syscall，该函数功能是不断打印出字符。字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。于是字符串被打印到了屏幕上。 【补】vsprint函数： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Xi9NBFWA-1624591156904)(media/9650c78a154fcc2334b50ff5eb9846eb.png)] sys_call的实现： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J5uL5lMn-1624591156904)(media/9d1b1859ed232e957a9a0b97babcfa49.png)] 8.4getchar的实现分析 异步异常-键盘中断的处理：当用户按键时，键盘接口会得到一个代表该按键的键盘扫描码，同时产生一个中断请求，中断请求抢占当前进程运行键盘中断子程序，键盘中断子程序先从键盘接口取得该按键的扫描码，然后将该按键扫描码转换成ASCII码，保存到系统的键盘缓冲区之中。getchar函数返回原理：当程序调用getchar()时，程序就等着用户按键。用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止(回车字符也放在缓冲区中)。当用户键入回车之后，getchar()才开始调用read系统函数，从输入流中每次读入一个字符。getchar()函数的返回值是用户输入的第一个字符的ASCII码,如出错返回EOF。如用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中，待后续getchar()调用读取。也就是说，后续的getchar()调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完为后，才等待用户按键。getchar函数作用：从标准输入流只读取一个字符(包括空格、回车、tab)，读到回车符(’\n’)时退出，键盘输入的字符都存到缓冲区内，一旦键入回车，getchar就进入缓冲区读取字符，一次只返回第一个字符作为getchar函数的值；如果有循环或足够多的getchar语句，就会依次读出缓冲区内的所有字符直到’\n’。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法、UnixIO接口及其函数，并且分析了printf函数和getchar函数的实现。 结论 首先程序员编写hello.c文件；下面分析hello.c在计算机中的历程： hello.c文件首先经历的是来自cpp的预处理，生成hello.i；hello.i将经历来自ccl的编译，生成hello.s；hello.s将经历as的翻译，生成一定格式的机器码文件hello.o；经过ld的链接，形成了可执行文件hello.out；在在shell中键入运行命令./hello.out1190200828赵英帅；因为输入的不是shell的内置命令，所以为其fork产生一个子进程，然后hello便从程序变为了进程；调用execve函数加载运行hello.out，映射虚拟内存，开始载入物理内存，进入main函数；当hello程序执行printf函数时，会调用malloc向动态内存分配器申请堆中的内存；打印完成后，hello调用sleep函数之后进程陷入内核模式，处理休眠请求主动释放当前进程，内核进行上下文切换将当前进程的控制权交给其他进程，2秒后休眠结束，内核执行上下文切换将控制传递给hello进程；若无输入信号干扰，8、9将重复执行10次；若输入CtrlZ，内核会发送SIGTSTP信号给hello进程，使之停止前台作业并挂起，后续执行fg将使之再次成为前台程序，继续执行；若输入CtrlC，内核会发送SIGINT信号给进程并终止hello进程；输入为其他字符时，第一次回车后再输入的字符将在hello进程运行结束后被当作命令行输入进行解释；当hello进程执行完成时，内核安排父进程回收hello进程，并将hello进程的退出状态传递给父进程。 hello程序短暂的一生就此结束啦！ 完结撒花！ 附件 文件名文件作用hello.ihello.c经过预处理得到的文本文件hello.shello.i编译生成的汇编文件hello.ohello.s经过汇编生成的可重定位目标文件hello.txthello.o反汇编后生成的汇编语言文本文件hello.out链接后生成的可执行文件asm.shello.o反汇编后生成的汇编语言文本文件 参考文献 [1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp.内核模式，处理休眠请求主动释放当前进程，内核进行上下文切换将当前进程的控制权交给其他进程，2秒后休眠结束，内核执行上下文切换将控制传递给hello进程； 若无输入信号干扰，8、9将重复执行10次；若输入CtrlZ，内核会发送SIGTSTP信号给hello进程，使之停止前台作业并挂起，后续执行fg将使之再次成为前台程序，继续执行；若输入CtrlC，内核会发送SIGINT信号给进程并终止hello进程；输入为其他字符时，第一次回车后再输入的字符将在hello进程运行结束后被当作命令行输入进行解释；当hello进程执行完成时，内核安排父进程回收hello进程，并将hello进程的退出状态传递给父进程。 hello程序短暂的一生就此结束啦！ 完结撒花！ 附件 文件名文件作用hello.ihello.c经过预处理得到的文本文件hello.shello.i编译生成的汇编文件hello.ohello.s经过汇编生成的可重定位目标文件hello.txthello.o反汇编后生成的汇编语言文本文件hello.out链接后生成的可执行文件asm.shello.o反汇编后生成的汇编语言文本文件 参考文献 [1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 
第166篇文章[]
哈工大软件构造Lab2设计实现 2021年春季学期 计算学部《软件构造》课程 **Lab2 目录 1实验目标概述3 2实验环境配置3 3实验过程5 3.1PoeticWalks5 3.1.1GetthecodeandprepareGitrepository5 3.1.2Problem1:TestGraph<String>5 3.1.3Problem2:ImplementGraph<String>6 3.1.4Problem3:ImplementgenericGraph<L>12 3.1.5Problem4:Poeticwalks14 3.1.6使用Eclemma检查测试的代码覆盖度16 3.1.7Beforeyou’redone16 3.2Re-implementtheSocialNetworkinLab118 3.2.1FriendshipGraph类18 3.2.2Person类18 3.2.3客户端main()19 3.2.4测试用例19 3.2.5提交至Git仓库20 4实验进度记录21 5实验过程中遇到的困难与解决途径22 6实验过程中收获的经验、教训、感想22 6.1实验过程中收获的经验和教训22 6.2针对以下方面的感受22 实验目标概述 本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说： ⚫针对给定的应用问题，从问题描述中识别所需的ADT； ⚫设计ADT规约（pre-condition、post-condition）并评估规约的质量； ⚫根据ADT的规约设计测试用例； ⚫ADT的泛型化； ⚫根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction） ⚫使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure）； ⚫测试ADT的实现并评估测试的覆盖度； ⚫使用ADT及其实现，为应用问题开发程序； ⚫在测试代码中，能够写出testingstrategy并据此设计测试用例。 实验环境配置 IDEA自带代码覆盖率工具，只需右键单击测试文件，选择RunwithCoverage即可： 在这里给出你的GitHubLab2仓库的URL地址（Lab2-学号）： https://github.com/ComputerScienceHIT/HIT-Lab2-1190200828 实验过程 PoeticWalks 此实验的目的是练习设计、测试和执行ADT。该阶段给出了一个图的接口，要求建立一个边图类一个点图类来分别继承自该图接口，在里面实现一系列方法并实现抽象数据型以完成poet。 GetthecodeandprepareGitrepository 从GitHub获取该任务的代码： gitclonehttps://github.com/rainywang/Spring2021_HITCS_SC_Lab2/ 在本地创建git仓库： 在自己创建的本地仓库中，打开gitbash输入gitinit然后与git远端仓库进行关联即可。 Problem1:TestGraph<String> 思路： 这是针对Graph<String>设计相应的测试策略，即对Graph<String>的每个方法进行测试。 过程： 下面的截图为接口Graph中的部分被方法测试策略，其中vertices()方法在add、set等方法的测试中已经测试过，因此不再单独测试： 其他测试策略不再一一展示。 Problem2:ImplementGraph<String> ImplementConcreteEdgesGraph Edge类的实现初始化构造方法：定义边起点source和边终点target，以及边权值weight。AF、RI、Safety：Edge中需要实现的方法：Edge：初始化构造方法，即初始化边的两个顶点和边权值；checkRep：检查表示不变性；getSource：返回边起点；getTarget：返回边终点；getWeight：返回边权值；toString：字符串形式描述一条边，形式为”Weightoftheedgefromsourcetotargetisweight.\n”Edge类中各方法的测试策略： 其他测试策略不再一一展示。 测试结果：ConcreteEdgesGraph类的实现初始化构造方法：定义顶点集vertices和边表edges。AF、RI、Safety：ConcreteEdgesGraph中需要实现的方法(结合已设计的Graph测试用例)：ConcreteEdgesGraph：构造方法，不需要初始化变量；checkRep：检查表示不变性；add：添加一个顶点到顶点集vertices，不能重复加入；set：输入起点source、终点target和边权值weight，若起点或终点不在vertices内，则调用add将其加入。若weight<0，则返回-1；当weight=0时，若边存在，则删去该边；当weight>0时，若该边不存在，则将该边直接加入edges，否则应删去原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点，返回所有指向该点的起点及边的权值；targets：输入起点，返回该点指向的所有终点及边的权值；toString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。测试结果(包含Graph测试用例测试结果和toString的测试结果)： ImplementConcreteVerticesGraph Vertex类的实现初始化构造方法：定义图中点的名字vertex，Mapsources用于存储指向点vertex的所有起点以及它们之间的边的权值，Maptargets用于存储点vertex指向的所有终点以及它们之间边的权值。AF、RI、Safety：Vertex类中需要实现的方法：Vertex：初始化构造方法；checkRep：检查表示不变性；getVertex：返回点的名字；addSource：向sources中添加指向该点的起点及它们间边的权值。若weight<0，则返回-1；当weight=0时，若该起点存在，则在sources中删去该起点；当weight>0时，直接sources.put进行添加或者替换。改变了原边权值时，返回原边权值，边不存在则返回0；addTarget：向targets中添加该点指向的终点及它们间边的权值。操作与addSource相类似；getSources：返回sources；getTargets：返回targets；removeSource：从sources中删去一个指向该点的起点；removeTarget：从targets中删去一个该点指向的终点；toString：返回该点以及sources、targets。测试结果：ConcreteVerticesGraph类的实现初始化构造方法：定义顶点列表。AF、RI、Safety：ConcreteVerticesGraph类中需要实现的方法：ConcreteVerticesGraph：构造方法，不需要初始化变量；checkRep：检查表示不变性；add：初始化一个新的顶点并将其添加到到顶点列表vertices，若该点已经存在于图中，不能重复加入；set：输入起点source、终点target和边权值weight，若起点或终点不在vertices()内，则调用add方法将其加入。关于weight不同取值的操作于Vertice类的addSource、addTarget方法中完成；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点，返回所有指向该点的起点及边的权值；targets：输入起点，返回该点指向的所有终点及边的权值；toString：字符串形式输出图，每一个顶点的sources和targets的格式都与Vertex类中toString方法中的返回形式相同。测试结果： Problem3:ImplementgenericGraph<L> Maketheimplementationsgeneric 将之前实现的类和方法均使用泛型实现即可，即将各类中一开始用String型定义的变量，如起点source、终点target等相关的String类型变量均换为L。 接下来，按照IDEA的报错，将代码的其他位置的String替换为泛型L即可。 ImplementGraph.empty() 返回一个Graph的具体实现即可。 补充其他类型的标签： 测试结果： Problem4:Poeticwalks TestGraphPoet GraphPoet类中GraphPoet与poem方法的测试策略及测试用例： 【注】因为GraphPoet方法没有任何输出，图变量graph为private，所以无法直接测试该方法，所以直接测试两个方法； 1_empty.txt：空白文件，图为空，b必定不存在，所以返回值与input一致； 2_easy.txt：简单测试用文件，要插入的b均唯一 3_difficult.txt：比较复杂的测试用文件，要插入的b不唯一 GraphPoet类中toString方法的测试策略： 【注】考虑到该方法的测试，将Graph的具体实现更改为边图类，因为边图类的toString输出比点图类输出简单，更易书写测试用例。 ImplementGraphPoet 初始化构造方法：定义字符串构成的图graph。AF、RI、Safety：需要实现的方法：GraphPoet：先将文件corpus中的所有点读入，考虑到其中存在相同的点，集合Set并不适用，因此将所有点都读入列表。循环遍历列表，每次读入一前一后两个点作为起点和终点，建成一条边，其权值为该边在corpus中出现的次数；poem：生成poem，设计如下：toString：调用Graph接口中的toString方法，将整个图中所有点的指向转化为一条字符串输出。因为Graph接口的具体实现在设计测试文件时改为了边图类，所以输出格式即为边图类的toString方法的输出。 Graphpoetryslam 在main函数中加入一个输出调用toString方法，运行结果如下： 使用Eclemma检查测试的代码覆盖度 Beforeyou’redone 如何通过Git提交当前版本到GitHub上你的Lab2仓库。 gitinit gitadd. gitcommit-m“Firstcommit:PoeticWalkshasbeendone” gitremoteaddoriginhttps://github.com/ComputerScienceHIT/HIT-Lab2-1190200828 gitpushoriginmaster-u-m 在这里给出你的项目的目录结构树状示意图： Re-implementtheSocialNetworkinLab1 用在PoeticWalks已经实现的Graph<L>来实现Lab1中的FriendshipGraph类的各个方法，使之能通过测试文件，并且运行main函数的结果与Lab1一致。 FriendshipGraph类 初始化构造方法：生成空图graph。AF、RI、Safety：FriendshipGraph类中要实现的方法：main：与Lab1一致；addVertex：向图中添加点，调用Graph类中的add即可；addEdge：向图中添加边，因为是无向图，调用两次Graph类中的set即可；getDistance：得到两点间的距离，利用DFS算法，通过调用Graph类中的sources等方法即可；getGraph：因为构造方法graph设置为为private，为方便测试，故设置该方法以返回graph。 Person类 初始化构造方法：定义人的名字nameAF、RI、Safety：Person类中要实现的方法：Person：初始化构造方法，即初始化name； 客户端main() 将Lab1中的main直接复制过来即可，运行结果如下： 该结果与Lab1中main的运行结果一致。 测试用例 测试用例与Lab1一致，新增方法getGraph在其他测试中已测试完毕，不再进行单独测试； 测试结果(main无法参与测试，所以代码覆盖度较低)： 提交至Git仓库 提交过程同PoeticWalks； 在这里给出你的项目的目录结构树状示意图。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EHvUECld-1625645261706)(media/21c74acf10e1062c719496a9d029fc77.png)] 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 经过学习，对于Java的一些概念更加了解；对于Java中自带的一些方法还是很不熟悉，很多方法都要靠百度现场搜，以后会多加积累，多加练习；总是因为一些小错误而debug很长时间，以后要避免循环溢出等小错误；因为IDEA太聪明了，导致手写代码基本不可能，以后要多加记忆代码，加强手写代码能力。 针对以下方面的感受 面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？ADT的实现过程比较困难，但是一旦实现了ADT，后续工作就会变得十分简单；使用泛型和不使用泛型的编程，对你来说有何差异？本次实验来讲并没有什么差异，因为开始时未用泛型时，也没有用到与特定数据类型相关的方法；在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？优势：有目的的编程，有助于保证代码的正确性；暂时不适应；P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？提高代码效率，降低实现难度；P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？首先，P3不存在；其次，肯定不适应，因为P1都只是勉强能写；为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？意义：防止内部变量被外部修改，提高代码安全性；我会尽量坚持，虽然繁琐，但可以提高代码安全性；关于本实验的工作量、难度、deadline。工作量比较大，主要体现在写代码、代码注释、测试策略以及实验报告的撰写；难度对我来说比较高，因为对Java还是不算熟悉，很多方法需要现查；ddl比较合理，毕竟三周时间，但很容易造成所有工作堆在最后完成，建议学习计算机系统实验，将整个实验分为几个具有联系的小型实验发布，每周一交；《软件构造》课程进展到目前，你对该课程有何体会和建议？Java是一个很聪明的语言，而IDEA也是一个很聪明的编程工具；实验中给出代码注释基本上都是英文，本次实验中，我的函数注释基本上也是用的英文，但是测试策略、代码注释还是中文，以后会慢慢改进。设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？首先，P3不存在；其次，肯定不适应，因为P1都只是勉强能写；为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？意义：防止内部变量被外部修改，提高代码安全性；我会尽量坚持，虽然繁琐，但可以提高代码安全性；关于本实验的工作量、难度、deadline。工作量比较大，主要体现在写代码、代码注释、测试策略以及实验报告的撰写；难度对我来说比较高，因为对Java还是不算熟悉，很多方法需要现查；ddl比较合理，毕竟三周时间，但很容易造成所有工作堆在最后完成，建议学习计算机系统实验，将整个实验分为几个具有联系的小型实验发布，每周一交；《软件构造》课程进展到目前，你对该课程有何体会和建议？Java是一个很聪明的语言，而IDEA也是一个很聪明的编程工具；实验中给出代码注释基本上都是英文，本次实验中，我的函数注释基本上也是用的英文，但是测试策略、代码注释还是中文，以后会慢慢改进。 
第167篇文章[5]
FirstBlog 没有什么内容，用来测试一下 
第168篇文章[1]
CSAPP程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机 学 号 1190200913 班 级 1936602 学 生 林煜鹏 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文简述了一个c文件从源文件到程序，再到进程，最后被回收的全流程。其中，c文件通过预处理，编译，汇编，链接，最后生成可执行程序。而可执行程序通过shell创建和运行，成为一个进程。进程在经过存储管理和IO管理后，顺利运行，并最终被回收。本文就对这些过程进行一一详述。 关键词：CSAPP；编译；缓存；进程；系统流程； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 P2P:hello.c源文件在cpp,ccl,as,ld的作用下，经过预处理 编译 汇编 链接这四个步骤生成一个名为hello的可执行文件。最终在shell中新建进程运行。这就是所谓fromProgramtoProcess(P2P)。 020：hello进程从不存在开始，在shell的作用下通过execve在fork产生的子进程中生成hello，为hello的代码、数据、bss和栈映射虚拟内存。在hello开始运行时分配并载入物理内存，cpu为hello分配时间片并执行逻辑控制流，UNIXI/O管理输入输出，最终hello进程结束，shell回收其内存空间，hello不复存在。这就是所谓的fromZero-0toZero-0(020) 1.2环境与工具 硬件环境：CPU:IntelCorei7-10870H；32GDDR43200hzRAM；2TBSSDDisk 软件环境：MicrosoftWindows10Home64位；VMwareWorkstaion15.5Pro;Ubuntu18.04 开发工具gcc readelf edb wxHexeditor codeblocks 1.3中间结果 文件名称作用hello.c源代码文件hello.i经过预处理得到的C语言文件hello.s经过编译得到的汇编文件hello.0经过汇编之后的可重定位目标执行文件hello经过链接之后的可执行文件 1.4本章小结 本章主要介绍了什么是P2P、020，以及hello的P2P、020过程，给出了本次实验的软硬件信息和开发工具，以及文件的中间结果 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 2.1.1何为预处理 预处理即在编译驱动程序处理程序源代码，使之转化为目标程序的过程中，首先执行的行为。预处理将源代码分割或处理成为特定的单位，用来支持语言特性。在C、C++语言中，预处理会对源代码文件中以字符#开头的代码行进行处理。 2.1.2预处理的作用 具体处理内容包括宏定义、源文件包含、条件编译、行控制、错误指令等。预处理指令一般被用来使源代码在不同的执行环境中被方便的修改或者编译。 预处理指令主要有以下4类 宏定义指令 如#defineNameTokenString，#undef等。对于前一个预处理指令，预处理所要做的是将程序中的所有名为Name的字符用TokenString替换，但作为字符串常量的Name则不被替换。对于后者，则将取消对某个宏的定义，使以后该串的出现不再被替换。 条件编译指令 如#ifdef，#ifndef，#else，#elif，#endif,等等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉 源文件包含指令 如#include"FileName"或者#include等。在头文件中一般用伪指令#define定义了大量的宏(最常见的是字符常量)，同时包含有各种外部符号的声明。采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用。因为在需要用到这些定义的C源程序中，只需加上一条#include语句即可，而不必再在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。 包含到c源程序中的头文件可以是系统提供的，这些头文件一般被放在/usr/include目录下。在程序中#include它们要使用尖括号(<>)。另外开发人员也可以定义自己的头文件，这些文件一般与c源程序放在同一目录下，此时在#include中要用双引号("")。 特殊符号 预编译程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号(十进制数)，FILE则被解释为当前被编译的.C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。 预编译程序所完成的基本上是对源程序的“替换”工作。经过此种替换，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。这个文件的含义同没有经过预处理的源文件是相同的，但内容有所不同。下一步，此输出文件将作为编译程序的输出而被翻译成为机器指令。 2.2在Ubuntu下预处理的命令 gcc-Ehello.c-ohello.i 图2.1预处理前 图2.2预处理后 2.3Hello的预处理结果解析 预处理之后，我们打开两个文件，查看内部内容 图2.3预处理后文件内容比较 通过比较我们可以发现，经过预处理后，#include指令消失，被头文件内容代替，并且//注释也消失了。可以看到main函数部分没有变化，说明预处理只是简单的替换和删除，并没有真正开始程序的编译等过程。 2.4本章小结 预处理过程是计算机对源程序进行操作的第一步，在这个过程中预处理器（cpp）会对hello.c文件进行初步的处理，对头文件、宏定义和注释进行操作，将程序中涉及到的库中的代码补充到程序中，将注释这个对于执行没有用的部分删除，最后将初步处理完成的文本保存在hello.i中，方便以后的编译过程。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 3.1.1编译的概念 编译阶段是在预处理之后的下一个阶段，在预处理阶段过后，我们获得了一个hello.i文件，编译阶段就是编译器（ccl）对hello.i文件进行处理的过程。此阶段编译器会完成对代码的语法和语义的分析，生成汇编代码，并将这个代码保存在hello.s文件中。 3.1.2编译的作用 代码在编译阶段会进行语法的检查。如果出现语法错误，则会编译失败。如 果语法不存在问题，编译器会将代码转换为汇编代码。 3.2在Ubuntu下编译的命令 gcc-Shello.i-ohello.s 图3.1编译前 图3.2编译后 3.3Hello的编译结果解析 3.3.1数据 （1）全局变量 查看源代码，可以知道我们的全局变量是int类型，标识符为sleepsecs 图3.3源代码的全局变量 查看汇编代码 图3.4汇编代码中的全局变量定义 可以看出，汇编代码中.globl代表的是全局变量，.type说明这个是一个数据，而.size表示其占有的字节大小，为4个字节。 （2）局部变量 查看源代码，可知我们定义了一个局部变量inti 查看汇编代码，我们并没有发现inti的定义，但是在赋值部分可以看到i 影子，这个下一部分讨论 3.3.2赋值 我们观察源代码可知，在最初定义全局变量的时候就进行了赋值 查看汇编代码，赋值语句是这样的形式 图3.5汇编代码中全局变量的赋值 可以看见有三行，第一行声明了变量名称sleepsecs，第二行为变量的值，第三行为储存的位置，由代码可知为.rodata节。 我们可以看出，当时赋值语句是将2.5赋值给这个变量，但是他保存的值却是2，这其中实际上发生了一次隐式类型转换，这个下一部分讨论 我们观察局部变量的赋值 图3.6汇编代码中局部变量的赋值 可以看出，局部变量是存储在栈中的，需要使用的时候，通过mov指令进行赋值 3.3.3类型转换 上节指出，sleepersec赋值时发生了隐式的类型转换。这是由于sleepersec是int型，而赋值的数据为2.5，为float型，因此自动发生了类型转换。查看代码我们可以看到，这一步是直接赋值为2，而没有其他特殊的操作。 3.3.4算数运算 源代码中只出现了一次算数操作，即i++。 在汇编代码中是这样显示的 图3.7汇编代码中算数操作 3.3.5关系操作 两个关系操作，阅读源代码可知，一个为不等于操作，另一个为小于操作 图3.8关系操作 这里我们可以看出，无论是哪种关系操作，在汇编代码中都是使用cmp进行比较，比较之后设定条件码，为之后的条件跳转打下基础 3.3.6控制转移 我们知道，在c语言中的逻辑结构，如循环，条件判断等，转换为汇编语言后就变成了控制转移。 控制转移主要通过jX指令执行，其中X为条件，即上一节谈到的条件码。当条件码满足跳转条件时，就会进行跳转。 jX指令有11条，条件类型有无条件，是否相等，是否为负，是否大于（等于），是否小于，并且有符号数和无符合数的跳转指令略有区别。 在hello.s中，有if语句的控制转移和循环体的控制转移，我们分别分析 if语句 图3.9if语句的控制转移 我们可以简单看出，在使用cmpl比较了3和argc之后，进行了一个条件跳转，若相等则跳转到L2（if语块之后），即不运行je之后的语句而直接跳转到循环体部分。因此，这个比较和跳转即为if语句转换为汇编代码的形态。 循环体 图3.10循环体的控制转移 分析代码可以看出，先进行了一个赋值操作（即i=0），然后无条件跳转到L3部分。L3部分将i和9进行对比，若i<=9，则跳转到L4，每次运行完成L4的部分时，i都会加1，然后再与9比较大小。与源代码对比，可以很清楚看出这个部分就是原来的循环体。因此，循环体转换为汇编代码时，会先进行一个无条件跳转到循环体的退出部分进行条件判断，若满足条件则正常退出，若不满足则跳转回循环体的开头执行指令，在执行完所有指令后进行自加一（或者其他操作改变值），然后再进行条件判断，以此反复直到完成循环。 3.3.7数组/指针/结构操作 阅读源代码，可以知道我们调用了argv[]里面的元素。对比汇编代码，我们可以看出汇编代码中已经没有数组、结构等概念，只存在地址和地址指向的值。对于数组的储存，在汇编中我们只保存了其起始地址，即argv[0]的地址，由于数组的储存是连续的地址，若要访问数组中其他元素只需要起始地址加上偏移量即可。 图3.11数组操作 分析代码，我们可以知道%rbp-32储存的是argv[0]的地址，由于argv[]是char*型，因此一个元素占8字节。先将argv[0]的地址赋给%rax，然后再将%rax加16，我们可以知道，此时的%rax中储存的是argv[2]的地址，下面类似的调用了argv[1]的地址，并将它们分别赋值给了%rdx和%rsi，在下一节中我们会清楚这些寄存器是用来做什么的 3.3.8函数操作 源代码中存在多个函数和函数调用。包括main函数，printf函数，exit函数，sleep函数，getchar函数，我们仅分析比较复杂的main函数，printf函数 首先我们先说明一下函数调用的过程。 （1）在调用者角度，我们需要向被调用函数传递参数，唤出被调用函数，然后接收返回值。对于传参操作，在参数比较少的情况，就直接存储在特定寄存器中，如%rdi，%rsi，%rdx，%rcx就分别用来存储第一至四个参数。X86的及其一共为我们提供了6个寄存器来保存参数。如果参数多于6个，那么就只能放在栈中保存了。传递参数完成后，我们使用call命令调用函数。call指令的操作原理是将call之后下一条指令的地址压入栈中，然后将被调用函数的首地址压入%rip中，从而达到调用的目的。调用完成后，返回值会储存在%rax中 （2）在被调用者角度，首先需要先将原先的栈底%rbp压栈，然后把原先栈顶%rsp的地址存入栈底%rbp中。这个操作的目的是保存原先被调用者的状态，并且方便在调用完成之后恢复到原先的状态。之后%rsp会减去一定数量的字节，这个步骤即为新内容分配空间（当前栈帧），然后将参数依次压入栈中，排序越靠前的参数，其压入栈的地址越高。之后执行完成后会先使用leave指令，让被调用者的状态返回到被调用前。leave指令的具体操作是将%rbp的值赋值回%rsp，然后将原%rbp弹出，以达到恢复的效果。然后最后使用ret指令，将返回地址弹出并压入%rip中，继续执行原指令。 汇编代码分析 （1）main函数 图3.12被调用函数的初始化 main函数开始运行时，进行的保存原寄存器值，分配栈帧，保存局部变量的操作。.cfi代码是debug使用的，我们分析时可以无视。观察代码，我们可以很明显的看出，main函数首先先将%rbp的原先值进行储存，然后对%rsp-32，分配了大小为32字节的栈帧空间。由于我们知道main函数有两个参数，即argc和argv[]，根据顺序分别保存在%rdi和%rsi中，之后的mov操作将这两个参数储存在栈中。初始化完成后开始正式运行 图3.13被调用函数的退出 main函数完成运行后，将返回值0压入%rax中，然后使用leave指令将保存的%rbp的值恢复，最后使用ret完成调用，释放栈帧，回到当初调用main的位置（即结束）。 （2）printf函数 图3.14调用函数前的初始化 这是第二次调用printf的时候，printf有三个参数：原来要输出的字符串（即"Hello%s%s\n"），argv[1],argv[2]。通过上面的代码我们可以清楚看出，参数按顺序存储在%rdi，%rsi，%rdx中，然后再使用call指令调用printf函数 3.4本章小结 本章我们主要介绍了编译器是如何将文本编译成汇编代码的。可以发现，编译器并不是死板的按照我们原来文本的顺序，逐条语句进行翻译下来的。编译器在编译的过程中，不时会对我们的代码做一些隐式的优化，而且会将原来代码中用到的跳转，循环等操作操作用控制转移等方法进行解析。最后生成我们需要的hello.s文件。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编器（as）将hello.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在hello.o中。这里的hello.o是一个二进制文件。 4.2在Ubuntu下汇编的命令 gcc-chello.s-ohello.o 图4.1通过汇编生成可重定位文件的过程 4.3可重定位目标elf格式 一般来说，elf文件的格式是这个样子的 图4.2ELF文件的通用结构 而由于可重定向目标文件和可执行文件的不同，我们阅读ELF文件中又存在两种不同的视图，分别是链接视图和执行视图 链接视图是以节（section）为单位，执行视图是以段（segment）为单位。链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。上图左侧的视角是从链接来看的，右侧的视角是执行来看的。总个文件可以分为四个部分： -ELFheader：描述整个文件的组织。 -ProgramHeaderTable:描述文件中的各种segments，用来告诉系统如何创建进程映像的。 -sections或者segments：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略programheadertable来处理此文件，在运行阶段可以忽略sectionheadertable来处理此程序（所以很多加固手段删除了sectionheadertable）。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。 -SectionHeaderTable:包含了文件各个section的属性信息。 图4.3两种不同视图的ELF阅读方式 由于我们的hello.o为可重定向目标文件，因此我们用链接视图阅读 使用指令readelf-ahello.o阅读hello.o的ELF文件 （1）ELFheader 图4.4ELF头的信息 第1行，ELFHeader:指名ELF文件头开始。 第2行，Magic魔数，用来指名该文件是一个ELF目标文件。第一个字节7F是固定的；后面的3个字节正是E,L,F三个字母的ASCII形式。之后的02表示的是文件类型，其中0为无效文件，1为ELF32位文件，2为ELF64位文件。接下去的01表示的是字节序，其中0为无效格式，1为小端序，2为大端序，再之后的01为ELF版本，再之后的字节没有定义，一般填零。用图可以表示如下 图4.5ELF魔数的构造 第3行，CLASS表示文件类型，这里是64位的ELF格式。 第4行，Data表示文件中的数据是按照什么格式组织(大端或小端)的，不同处理器平台数据组织格式可能就不同。 第5行，当前ELF文件头版本号，这里版本号为1。 第6行，OS/ABI，指出操作系统类型，ABI是ApplicationBinaryInterface的缩写。 第7行，ABI版本号，当前为0。 第8行，Type表示文件类型。ELF文件有3种类型，一种是如上所示的Relocatablefile可重定位目标文件，一种是可执行文件(Executable)，另外一种是共享库(SharedLibrary)。[这里就是区分上面三种类型的ELF文件] 第9行，机器平台类型，这里是在X86-64位机器。 第10行，当前目标文件的版本号。 第11行，程序的虚拟地址入口点，因为这还不是可运行的程序，故而这里为零。如果是可运行程序，这个地址并不是main函数的地址，而是_start函数的地址，_start由链接器创建，_start是为了初始化程序。 第12行，与11行同理，这个目标文件没有ProgramHeaders。 第13行，sections头开始的地址偏移，这里1320是十进制. 第14行，是一个与处理器相关联的标志，x86平台上该处为0。 第15行，ELF文件头的字节数。64bytes 第16行，因为这个不是可执行程序，故此处大小为0。 第17行，同理于第16行。 第18行，sectionsheader的大小，这里每个section头大小为64bytes。 第19行，一共有多少个section头，这里是14个。 第20行，section头字符串表索引表（.strtab）。表中存储的信息是用来链接使用的，主要包括：程序代码、程序数据（变量）、重定向信息等。比如：.text保存的是代码，.data保存的是初始化或未初始化的数据，等等。 （2）节头部表（sectionsheader） 图4.6节头部表 .text：已编译程序的机器代码。.rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。.data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。.bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。.rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。.common：现代编译器用.COMMON和.bss来更细化的区分这些变量，将未初始化的全局变量分配至.COMMON中。.eh_frame&.rela.eh_frame：gcc编译的过程中用于处理异常的部分.symtab：一个符号表（symboltable），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。.shstrtab：此节区包含节区名称。 （3）重定位节 图4.7重定位节 接下来可以看到.text节重定位的信息。重定位节中包括所有需要重定位的符号的信息，包括偏移量、信息、类型、符号值和符号名称+加数。当链接器把这个可重定位目标文件与其他文件相结合时，需要修改这些符号的位置。 其中，这些符号有两种类型。第一种类型为R_X86_64_PC32，表示重定位PC相对引用。链接器首先计算出引用的运行时地址，refaddr=ADDR(.text)+偏移量，然后更新该引用，使得它在运行时指向符号。这里的加数就是r.append,偏移量就是r.offset。故*refptr=ADDR（运行时地址）+r.append-refaddr，因此PC的值为PC+refptr，之后CPU调用call指令。 第二种类型为R_X86_64_PLT32，为位置无关代码，即无需重定位的代码。 另外，还有一种类型在这里没有显示，R_X86_64_32，表示重定位PC绝对引用。地址计算为fefptr=ADDR(运行时地址)+r.append 在.rela.text表之后是.rela.eh_frame，保存eh_frame的重定位信息。 （4）符号表.symtab 图4.8符号表 接下来我们可以看到.symtab表，记录了hello.c中调用的函数和全局变量的的名称，类型，地址等信息。 value地址信息，在可重定位文件中是起始位置的偏移量。 size表示符号的尺寸大小。例如main符号代表的就是main函数代码的总体大小 type为符号的定义，如object表示数据，func表示函数，notype表示暂未定义 bind表示符号是全局的还是本地的。 ndx表示每个符号表项与其他节区的关系，代表的就是此成员所在的节区的头部表索引，UND表示为在本文件中定义的符号。 4.4Hello.o的结果解析 objdump-d-rhello.o 图4.9反汇编代码 机器语言的构成 机器语言是计算机能直接识别的二进制代码，在hello.o的反汇编文件中，使用16进制表示机器代码，每个字节使用两个16进制数表示 机器语言和汇编语言的映射关系 汇编语言的每一条语句由机器语言中多个字节表示，而每一组特定的字节都可以翻译会汇编语言。 操作数 hello.s中使用十进制表示操作数，而反汇编语言中使用16进制表示操作数 函数调用 hello.s中函数调用只需使用call+函数名的方式即可，但是经过汇编后可以看出，链接器为每个函数调用找到了匹配的可执行代码的地址，并且需要经过重定位确定最后的实践地址。 分支转移 hello.s中的跳转指令是类似jX.L1的格式，其中.L1是标签，指代了某一句指令的位置。而经过汇编后，跳转指令是直接跳转到某个地址，可以是具体的地址，也可以是相对的地址。 4.5本章小结 本章中我们汇编了hello.s，将其转换为可重定位目标文件，并具体分析了可重定位文件的ELF格式和具体内容。并且反汇编了可重定位目标文件，并将其与原先的汇编代码进行对比。 通过这章，我们了解到汇编器将汇编代码处理成机器可以看懂的机器码，也就是二进制代码。二进制代码较汇编代码来说，虽然可读性变得比较差，但是在执行效率方面有了非常大的提升，汇编代码虽然已经在原来的文本的基础上进行了优化，但是还是存在着一些字符等不能够直接处理的数据。但是二进制代码中，已经将所有的指令、函数名字等量变成了相应的存储地址，这样机器就可以直接读取这些代码并执行。所以总的来说hello.o已经非常接近一个机器可以执行的代码了。 （第4章1分） 第5章链接 5.1链接的概念与作用 5.1.1链接的概念 链接是通过链接器（ld）将各种代码和数据片断收集并组合成一个单一文件的过程。这个文件可以被加载（复制）到内存并执行。链接包含符号解析和重定位两步。链接器将每个符号引用与符号的定义相关联，将符号在可重定位文件的位置重定位至可执行文件的位置。 5.1.2链接的作用 因为有了链接这个概念的存在，所以我们的代码才会变得比较方便和简洁，同时可移植性强，模块化程度比较高。因为链接的过程可以使我们将程序封装成很多的模块，我们在编程的过程中只需要考虑主程序的部分，对于其他的外部函数我们可以直接调用模块，就像C中调用printf一样。 同时我们可以将一个大型的应用程序分解成更小、更好管理的模块，可以独立地修改和编译这些模块，当我们改变这些模块中的一个时，只需要简单地重新编译，并重新链接应用，而不必重新编译其他文件。 5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1经过链接之后的可执行文件hello 5.3可执行目标文件hello的格式 总体的来说，ELF内部结构发生了一定的变化，链接完成后，ELF中多了程序头部表，这个是用来记录有哪些段（segments）的，多了不少的section和表，接下来我们依次说明 ELF头 图5.2可执行程序的ELF头 与上一章的ELF头相比，最大的变化发生在ELF类型，可以看到ELF类型已经变成可执行文件。同时我们发现相比与之前多了程序头，段数目，节的数量也有增加。同时入口点位置也不是虚拟地址0x0了，现在的入口地址是一个真实的物理地址 节头 图5.3可执行程序的节头表 多了几个节，我们来简单介绍一下 .interp：用于保存动态链接器的绝对地址，如/lib/ld-linux.so.hash：使用哈希技术存储的符号表，方便快速查找.dynsym：动态链接符号表.dynstr：动态链接字符串表，存放着所有符号名称的字符串，与.shstrtab类似.init：初始化信息，包括_start的地址，可以通过_start进入main函数.got：全局偏移量表，用来支持位置无关代码（PIC，PositionIndependentCode），存储的是所有引用的符号的地址，以实现对这些符号的间接访问。.plt.got：过程链接表，用来支持所引用函数的延迟绑定（即只有当该函数被第一次调用时才确定它的实际地址）.dynamic：动态链接信息表 程序头 图5.4程序头和段-节映射表 可以看到，此时的程序已经分配了真实的物理地址，因而可以运行 同时我们看到，多个节映射到一个段内。 动态链接信息表 图5.5动态链接信息表 动态链接信息表的数据结构非常简单，一个成员表示类型，另一个成员表示该类型的值（整数或地址） 重定位节 图5.6重定位节 .rel.dyn和.rel.plt是动态定位辅助段。由连接器产生，存在于可执行文件或者动态库文件内。借助这两个辅助段可以动态修改对应.got和.got.plt段，从而实现运行时重定位。 .rel.dyn：重定位的地方在.got段内。主要是针对外部数据变量符号。例如全局数据。重定位在程序运行时定位，一般是在.init段内。定位过程：获得符号对应value后，根据rel.dyn表中对应的offset，修改.got表对应位置的value。另外，.rel.dyn含义是指和dyn有关，一般是指在程序运行时候，动态加载。区别于rel.plt，rel.plt是指和plt相关，具体是指在某个函数被调用时候加载。我个人理解这个Section的作用是，在重定位过程中，动态链接器根据r_offset找到.got对应表项，来完成对.got表项值的修改。 .rel.plt：重定位的地方在.got.plt段内（注意也是.got内,具体区分而已）。主要是针对外部函数符号。一般是函数首次被调用时候重定位。首次调用时会重定位函数地址，把最终函数地址放到.got内，以后读取该.got就直接得到最终函数地址。我个人理解这个Section的作用是，在重定位过程中，动态链接器根据r_offset找到.got对应表项，来完成对.got表项值的修改。 动态符号表 图5.7动态符号表 符号表 图5.8符号表（部分） 5.4hello的虚拟地址空间 用edb打开hello，使用symbolview查看虚拟地址各段信息 图5.9动态库各段的虚拟地址 我们查看与节头表类似的部分 图5.10 与5.3的节头表对比，我们可以发现，基本每个节都被展开了，实际运行时占用内存更多，并且多了不少重定位之后的的外部函数地址。 5.5链接的重定位过程分析 图5.11可执行文件的反汇编代码 hello与hello.o相比，还是有很大不同的。 可以看到，在hello.o的反汇编代码中，只有一个main函数，但是对于hello的反汇编代码来说，可以看到很多如_init样子的函数。这些函数都是在链接的过程中，被加载到可执行文件中的。 同时，地址发生了很大的改变。链接之前，.o文件中main函数的反汇编代码从地址0开始往下，可以认为是相对偏移地址，而在链接之后，在main函数之前还链接上了其他的库文件，因此hello的main函数是从地址0x401105开始的，这时，在main函数中每一条指令的地址，每一个函数的地址都可认为是绝对地址，是CPU可以直接访问的地址。在hellomain函数中的绝对地址是通过可重定位文件中地址的偏移量加上起始地址得到的。 链接主要包括解析符号和重定位两步。在重定位之前，汇编器在hello.o文件的重定位段记录了需要重定位的符号和相应的类型和偏移量。链接器通过对符号的解析（包括局部符号和全局符号），将每个符号的引用和符号的定义相关联。这之后还需要将命令行输入的静态库链接，然后就开始重定位，在重定位过程中，将合并输入模块，并为每个符号分配运行时的地址。 首先需要对符号和节进行重定位。链接器将所有相同类型的节合并为同一类型的新的聚合节，然后链接器将运行时内存地址赋给新的聚合节，赋给定义的每个节和符号，此时程序中的每条指令和全局变量都有唯一的运行时内存地址。 然后重定位节中的符号引用，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。 5.6hello的执行流程 hello在执行的过程中一共要执行三个大的过程，分别是载入、执行和退出。 函数名阶段_dl_start加载_dl_init加载hello!start开始执行_libc_start_main开始执行_al_fixup开始执行_libc_csu_init开始执行_setjmp开始执行_main执行_printf执行_exit执行__sleep执行_getchar执行_dl_fixup退出exit退出 5.7Hello的动态链接分析 编译器在数据段开始的地方创建全局偏移量表（GOT），在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。 每个被可执行程序调用的库函数都有它自己的PTL条目，每个条目负责调用一个具体的函数。 查看dl_init运行前，.got.plt的值 .got.plt的起始地址是0x404000 在dl_init之前 图5.12 在dl_init之后 图5.13 5.8本章小结 链接的过程，是将原来的只保存了你写的函数的代码与代码用所用的库函数合并的一个过程。在这个过程中链接器会为每个符号、函数等信息重新分配虚拟内存地址，方法就是用每个.o文件中的重定位节与其它的节想配合，算出正确的地址。同时，将你会用到的库函数加载（复制）到可执行文件中。这些信息一同构成了一个完整的计算机可以运行的文件。链接让我们的程序做到了很好的模块化，我们只需要写我们的主要代码，对于读入、IO等操作，可以直接与封装的模块相链接，这样大大的简化了代码的书写难度。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程是一个执行中程序的实例，系统的每个程序都运行在某个进程的上下文中，上下文是由程序正确运行所需的状态组成的。包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 进程的作用：提供给应用程序一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器；提供给应用程序一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 shell是一个linux中提供的应用程序，他在操作系统中为用户与内核之间提供了一个交互的界面，用户可以通过这个界面访问操作系统的内核服务。他的处理流程如下： 从界面中读取用户的输入。将输入的内容转化成对应的参数。如果是内核命令就直接执行，否则就为其分配新的子进程继续运行。在运行期间，监控shell界面内是否有键盘输入的命令，如果有需要作出相应的反应 6.3Hello的fork进程创建过程 首先先来了解一下fork函数的机制。父进程通过调用fork函数创建一个新的子进程。新创建的子进程几乎但不完全与子进程相同。在创建子进程的过程中，内核会将父进程的代码、数据段、堆、共享库以及用户栈这些信息全部复制给子进程，同时子进程还可以读父进程打开的副本。唯一的不同就是他们的PID，这说明，虽然父进程与子进程所用到的信息几乎是完全相同的，但是这两个程序却是相互独立的，各自有自己独有的用户栈等信息。 fork函数虽然只会被调用一次，但是在返回的时候却有两次。在父进程中，fork函数返回子进程的PID；在子进程中，fork函数返回0。这就提供了一种用fork函数的返回值来区分父进程和子进程的方法。 同时fork在使用的过程中，有一个令人比较头疼的问题，就是父进程和子进程是并发执行的所以我们不能够准确的知道那个进程先执行或者先结束。这也就造成了每次执行的输出结果可能是不同的，也是不可预测的。 我们实际的执行一下，在命令行输入./hello1190200913lyp，shell检查该命令是否为内置命令，显然这不是内置命令。于是，shell调用fork函数创建一个新的子进程，子进程得到与父进程用户级虚拟地址空间相同的一份副本，这意味着父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大区别在于有不同的PID。 之后，更改进程组编号，准备hello的execve。 6.4Hello的execve过程 execve函数的作用是在当前进程的上下文中加载并运行一个新的程序。与fork函数不同的是，fork函数创建了一个新的进程来运行另一个程序，而execve直接在当前的进程中删除当前进程中现有的虚拟内存段，并穿件一组新的代码、数据、堆和用户栈的段。将栈和堆初始化为0，代码段与数据段初始化为可执行文件中的内容，最后将PC指向_start的地址。在CPU开始引用被映射的虚拟页的时候，内核才会将需要用到的数据从磁盘中放入内存中。 在shell新创建的子进程中，execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp，只有出现错误是，execve才会返回到调用程序。 在execve加载hello之后，调用启动代码来执行hello，新的代码和数据段初始化为可执行文件的内容，跳转到_start调用libc_start_main设置栈，并将控制传递给新程序的主函数， 6.5Hello的进程执行 在执行hello程序之后，hello进程一开始运行在用户模式，进程从用户模式变为内核模式的唯一方法是通过中断、故障等异常的调用，当进程处于内核模式时，可以访问任何内存位置，调用任何指令。当处理程序返回到应用程序代码时，从内核模式改为用户模式。 内核为每一个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态。包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构。 当内核选择一个新的进程运行时，即内核调度这个进程，内核使用上下文切换的机制来控制转移到新的进程：保存当前进程的上下文，恢复某个先前被强占的进程被保存的上下文，将控制传递给这个新恢复的进程。 在hello程序运行时，会有其他进程并发地运行，这些进程时间与hello重叠，为并发流，这些进程轮流运行，一个进程执行它的控制流的一部分的每一时间段叫做时间片。 接下来根据上述知识分析一下hello的进程调度。hello一开始运行在用户模式，内核保存一个上下文，继续运行调用printf函数，系统调用使得进程从用户模式变成内核模式，在printf函数执行完之后又返回到用户模式，继续运行调用sleep函数，此时会有些不同，由于该进程进行休眠，内核进行上下文切换，调用其他进程运行，同时计数器记录休眠的时间，等到休眠的时间到时，系统发生中断，再次进行上下文切换，转换到hello进程原先运行的位置。继续运行，遇到循环之后，hello进程会多次进行用户模式和内核模式的转变。之后调用getchar函数，进入内核模式，需要完成从键盘缓冲区到内存的数据传输，故上下文切换，运行其它进程，当数据传输结束，发生中断，再次上下文切换，回到hello进程，此时hello进程就运行结束了，return，hello进程运行终止。 6.6hello的异常与信号处理 hello的异常种类 中断 中断是异步发生的，是来自处理器外部的I/O设备的信号的结果，中断处理程序运行之后，返回到下一条指令。 陷阱和系统调用 陷阱是有意的异常，是执行一条指令的结果，就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令，在用户程序和内核之间提供一个像过程一样的接口，即系统调用。如读一个文件、创建一个进程、加载一个新的程序等。 故障 故障是由错误情况引起的，当故障发生时，将控制转移给故障处理程序，如果错误情况可以修正，则将控制返回到引起故障指令，重新执行，否则处理程序返回到内核abort，终止故障的应用程序。 终止 终止是不可恢复的致命错误造成的结果，会终止应用程序。 hello的信号 图6.1正常运行 可以看到在执行ps命令之后，程序后台并没有hello进程正在执行了，说明进程正常结束，已经被回收了。 在程序执行过程中，可以在命令行中乱按，包括回车，对于程序运行来说没有影响。 SIGTSTP信号 输入ctrl-z会发送一个SIGTSTP信号到前台进程组中的每个进程，默认情况下，停止（挂起）前台作业。 图6.2执行ctrl+z（挂起） 通过ps命令我们可以看到hello进程的pid，ctrl-z后hello进程被挂起，jobs命令看到hello进程的状态 图6.3通过pstree命令在进程树中找到bash的hello进程 使用fg将JID最大的放到前台，即继续运行hello 图6.4使用fg命令继续运行hello 使用kill-9PID杀死hello进程 图6.5使用kill命令终止hello进程 SIGINT信号 当用户输入ctrl-c时产生中断信号，导致内核发送一个SIGINT信号到前台工作组中的每个进程，默认终止前台作业，在这里，hello被终止。 图6.6使用ctrl+c终止hello进程 6.7本章小结 这一章介绍了hello可执行文件在进程中的执行过程。介绍了shell-bash的工作流程，shell利用fork和execve运行hello程序的过程，用户模式和内核模式，上下文的切换。最后，通过在命令行的各种命令的演示，讲述了hello进程的异常处理和信号机制。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：由程序产生的段偏移地址。由段标识和段偏移量组成。以段标识为下标到GDT/LDT查表获得段地址。段地址+端偏移量=线性地址 线性地址：一个非负整数地址的有序集合，如果此时地址是连续的，则称这个空间为线性地址空间。 虚拟地址：在保护模式下，程序运行在虚拟内存中。虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。虚拟地址由VPO（虚拟页面偏移量）、VPN（虚拟页号）、TLBI（TLB索引）、TLBT（TLB标记）组成。 物理地址：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每字节都有一个唯一的物理地址，比如第一个字节地址为0，第二个地址为1，以此类推。物理地址空间对应于系统中物理内存的M个字节：{0,1,2……M-1}。 在hello中，main函数的地址为0x401105，这是逻辑地址中的段偏移量，加上段地址就是main函数的虚拟地址，虚拟地址与物理地址之间存在一种映射关系，MMU利用页表实现这种映射，可得到实际的物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 实模式：逻辑地址CS:EA=EA+16*CS 保护模式：逻辑地址由段标识和段偏移量组成。以段标识为下标，去索引段描述符表，若T1=0，索引全局段描述符表（GDT），若T1=1，索引局部段描述符表（LDT）。将段描述符表中的段地址（base字段）加上段偏移量，即为线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 hello的线性地址到物理地址的变换，也就是从虚拟地址寻址物理地址，在虚拟地址和物理地址之间存在一种映射，MMU通过页表实现这种映射。 虚拟地址由虚拟页号（VPN）和虚拟页偏移量（VPO）组成，页表中由有效位和物理页号组成，VPN作为到页表的索引，去页表中寻找相应的PTE，其中PTE有三种情况，分别为已分配，未缓存，未分配。已分配表示已经将虚拟地址对应到物理地址，有效位为1，物理页号不为空。未缓存表示还未将虚拟内容缓存到物理页表中，有效位为0，物理页号不为空。未分配表示未建立映射关系，有效位为0，物理页号为空。 如果有效位为0，表示缺页，进行缺页处理，从磁盘读取物理页到内存，若有效位为1，则可以查询到相对应的PPN，物理页偏移量和VPO相同，PPN和PPO组成物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 首先介绍一下TLB。为减少内存读取数据的次数，在MMU中包括了一个关于PTE的小的缓存，即TLB，每一行都保存着一个由单个PTE组成的块。TLB索引由VPN的t个最低位组成，剩余的为为TLB标记。 其次我们来介绍一下多级页表的概念。在前面我们了解了一级页表是如何进行工作的。可以发现一级页表有一个弊端，就是对于每一个程序，内核都会给他分配一个固定大小的页表，这样有一些比较小的程序会用不到开出的页表的一些部分，就造成了空间的浪费，多级页表就很好的解决了这个问题。以二级页表为例，首先我们先开一个比较小的一级页表，我们将完整的页表分组，分别对应到开出来的一节页表的一个PTE中，在执行程序的过程中，如果我们用到了一个特定的页表，那么我们就在一级页表后面动态的开出来，如果没用到就不开，这样就大大的节省了空间。 CPU产生一个虚拟地址,当TLB命中时，MMU从TLB中取出相应的PTE，MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存中，高速缓存/主存将所请求的数据字返回给CPU。若TLB不命中，MMU必须从页表中的PTE取出PPN复制到PTE，而在得到PTE还会发生缺页或者是缓存不命中的情况。 7.5三级Cache支持下的物理内存访问 知道虚拟地址对应的物理地址之后，需要对物理地址进行访问。CPU访问物理地址是访问三级cacheL1、L2、L3。MMU将物理地址发送给L1缓存，从物理地址中得出CT（缓存标记）、CI（缓存组索引）、CO（缓存偏移）。根据缓存组索引找到L1缓存中对应的组，若缓存标记为1，根据缓存偏移直接从缓存中读取数据并返回。如果缓存标记为0，即缓存不命中，需要从L2、L3中去读取，如果在三级缓存中都不存在，需要到主存中读取。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本，它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello有效替代当前程序。加载并运行hello需要以下几个步骤： 删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 映射私有区域。为hello程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data段，bss是请求二进制零的，映射到匿名文件，大小包含在hello中，栈和堆也是请求二进制零的，初始长度为0。 映射共享区域。如果hello程序与共享对象链接，如libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 设置程序计数器。execve做的最后一件事就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时将从这个入口点开始执行。 7.8缺页故障与缺页中断处理 缺页现象的发生是由于页表只相当于磁盘的一个缓存，所以不可能保存磁盘中全部的信息，对于有些信息的查询就会出现查询失败的情况，也就是缺页。 对于一个访问虚拟内存的指令来说，如果发生了缺页现象，CPU就会触发一个缺页异常。缺页异常会调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果牺牲页已经被更改，那就先将其存回到磁盘中。 找到了要存储的页后，内核会从磁盘中将需要访问的内存，并且将PTE中的信息更新，这样就成功的将一个物理地址缓存在了页表中。当异常处理返回的时候，CPU会重新执行访问虚拟内存的操作，这个时候就可以正常的访问，不会发生缺页现象了。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆，分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 动态内存分配器分为显式分配器和隐式分配器两种。 7.9.1、带标签的隐式空闲链表 将堆组织为一个连续的已分配块和空闲块的序列的结构是隐式空闲链表，空闲块通过头部的大小字段隐含地链接。而带边界标签的隐式空闲链表则在每个块的结尾处添加一个脚部 头部的副本，脚部总是在距当前块开始位置一个字的距离。分配器可以通过检查它的脚部，判断前面一个块的起始位置和状态。 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以防止所请求块的空闲块。这种搜索方式由放置策略确定，包括首次适配、下一次适配和最佳适配。 一旦分配器找到匹配的空闲块之后，作出另一个决定 分配这个空闲块多少空间。通常选择将空闲块分割成两个部分，剩下的一部分变成新的空闲块。 当分配器释放一个已分配块之时，可能有其他空闲块与新释放的空闲块相邻，可能会导致假碎片问题，因此需要合并相邻的空闲块。而带有边界标签的隐式空闲链表分配器就可以在常数时间内完成对前面块的合并。简单来说，就是双向合并。 7.9.2、显式空闲链表 将空闲块组织成某种形式的显式数据结构，实现这个数据结构的指针可以存放在这些空闲块的主体里。堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个前驱和后继指针。 这样做的好处就是在我们在malloc的时候，隐式的方法是要遍历所有的块，包括空闲块了分配块。但是显式的结构只需要在空闲块中维护的链表检索就可以了，这样降低了在malloc时候的复杂度。 一种方法是后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处，分配器会最先检查最近使用过的块。.这样在malloc的时候会首先看一下最后被free的块是否符合要求。这样的好处是释放一个块的时候比较高效，直接放在头部就可以。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索定位合适的前驱。 7.10本章小结 这一章介绍了hello的存储器地址空间的概念和相关的地址计算方法，缺页和缺页处理，重点介绍了虚拟地址转换成物理地址的过程，包括四级页表、TLB加速、三级cache等。除此以外，介绍了内存映射，以及fork创建进程和execve函数运行hello时的具体过程。最后讲述了动态内存分配管理的不同结构的链表的操作。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行，这就是UnixI/O接口。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 （1）打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个叫做描述符的小的非负整数，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息，应用程序只需记住这个描述符。 对应的函数为intopen(char*filename,intflags,mode_tmode);filename为文件名，flags参数指明了进程打算如何访问这个文件，可以是只读、只写、可读可写。mode参数指定了新文件的访问权限位。若open成功则返回新文件描述符，若失败则返回-1. （2）Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。 （3）改变当前文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 （4）读写文件：一个读操作就是从文件复制n个字节到内存,从当前文件位置k开始，然后k增加到k+n,给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个EOF的条件，应用程序能检测到这个条件，在文件结尾处并没有明确地EOF符号。 类似的，写操作就是从内存复制n个文件到一个文件，从当前文件位置k开始，更新k。 读文件对应的函数为ssize_tread(intfd,void*buf,size_tn);fd为当前文件的描述符，buf是内存位置，n是复制最多n个字节。若成功则为读的字节数，若EOF则为0，若出错-1。 写文件对应的函数是sisze_twrite(intfd,constvoid*buf,size_tn);若成功则为写的字节数，若出错则为-1。 （5）关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核丢回关闭所有打开的文件并释放他们的内存资源。 关闭文件的函数为intclose(intfd);若成功为0，若出错为-1.关闭一个已经关闭的描述符会出错。 8.3printf的实现分析 首先观察一下Linux下printf的函数体 staticintprintf(constchar*fmt, ) { va_listargs; inti; va_start(args,fmt); write(1,printbuf,i=vsprintf(printbuf,fmt,args)); va_end(args); returni; } printf需要做的事情是：接受一fmt的格式，然后将匹配到的参数按照fmt格式输出。图8-1是printf的代码，我们可以发现，他调用了两个外部函数，一个是vsprintf，还有一个是write。 定义va_list型变量args，指向参数的指针。va_start和va_end是获取可变长度参数的函数，首先调用va_start函数初始化args指针，通过对va_arg返回可变的参数，然后va_end结束可变参数的获取。 重点需要看write函数和vsprintf函数。 vsprintf函数的作用是以fmt为格式字符串，根据args中的参数，向printfbuf输出格式化后的字符串。然后调用write函数，write函数是UnixI/O函数，用以在屏幕上输出长度为i的在printfbuf处的内容。查看write函数的汇编代码可以看出它将栈中参数存入寄存器，然后执行INT_VECTOR_SYS_CALL,代表通过系统调用syscall，syscall将寄存器中存储的字符串通过总线复制到显卡的现存中，字符显示驱动子程序通过ASCII码在字模库中找到点阵信息并将其存储到vram中。接下来显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。此时在屏幕上显示一个已经格式化的字符串。 8.4getchar的实现分析 intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf;` } return(--n>=0)?(unsignedchar)*bb++:EOF; } getchar函数通过调用read函数来读取字符，read函数的返回值是读入字符的个数，若出错则返回-1.read函数通过调用内核中的系统函数，读取键盘缓冲区的ASCII码，直到读到回车为止，然后将整个字符串返回。 8.5本章小结 这一章介绍了Linux的I/O管理方法、I/O接口及其函数，以及通过阅读printf函数和getchar函数的代码了解如何通过UnixI/O实现功能。总的说，UnixI/O使得所有的输入和输出都能以一种统一且一致的方式来执行。 （第8章1分） 结论 hello的一生是这样度过的 我们通过各种方法，编写得到hello.c源文件预处理器将hello.c文件初步修改为hello.i文件编译器将hello.i文件编译成汇编代码存储在hello.s文件中汇编器将hello.s文件处理成可重定位目标文件hello.o，这时候的hello.o已经和之后能够实际运行的机器代码相差不大了链接器将hello.o与库进行链接，完成能实际运行的可执行文件hello当我们在shell中运行hello文件时，内核会为我们分配运行程序所需的堆栈，虚拟内存等信息，方便我们执行hello在运行过程中遇到各种信号和键盘输入，shell为其提供信号处理程序hello访存时，请求的地址为虚拟地址，通过MMU、TLB、四级页表等得到对应的物理地址，在三级cache中进行访存hello输入输出调用的getchar函数和printf函数，通过UnixI/O接口进行实现当hello执行完成所有工作之后，最终被shell回收，结束了程序的一生 通过这次大作业，我更加全面系统的了解了这门课程，对书中的知识有了更加全面的认识。同时感受到了计算机系统的复杂性以及严密性。我们一个程序的成功运行需要多少计算机硬件和软件的共同配合。 （结论0分，缺失-1分，根据内容酌情加分） 附件 文件名称作用hello.c源代码文件hello.i经过预处理得到的C语言文件hello.s经过编译得到的汇编文件hello.0经过汇编之后的可重定位目标执行文件hello经过链接之后的可执行文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 
第169篇文章[]
学完哈工大软件构造的一点小心得 其实这个课应该叫Java编程深入学习（笑 写一点学习时感觉比较容易混淆的点，可能有错漏，大神轻喷 final的修饰作用 用来修饰一个引用 如果引用为基本数据类型，则该引用为常量，该值无法修改；如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。如果引用时类的成员变量，则必须当场赋值，否则编译会报错。（或者在实例化类时，在构造函数将final修饰的成员变量全部赋值） 总之就是固定了引用，使一个引用不能被改变，由于基本数据类型引用和数据是一一对应的，因此固定引用就是固定了数值。 用来修饰一个方法 当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。主要用于严格继承，子类无需重写父类中的方法 用来修饰类 当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。 静态方法，静态变量（或者叫类方法，类变量），实例方法，实例变量 概念：实例化，就是你新建一个对象的那个动作就叫实例化，实例方法和变量就是基于已经生成的对象的东西，而类方法和类变量不用实例化变量就可以使用（经典例子：Math.sin()），因为是每个类共有的东西，因此冠以类方法类变量的名称 实例变量（instancevariable） 实例变量：或叫实例域、实例字段（instancefield），或叫成员变量（membervariable）。实例的变量，每个实例的变量可能不同。 实例方法（instancemethod） 实例方法：或叫成员方法（membermethod）。供实例用的方法，必须要先有实例，才能通过此实例调用实例方法。 类变量（classvariable） 类变量：或叫静态域、静态字段（staticfield），或叫静态变量（staticvariable）。出现在这样的情况下：一个类的所有实例需要一个公有的属性，比如，一，统计实例个数；二，常量。类变量与类直接关联在一起。内存当中只有一个地方存放这个变量。任何实例都可以修改它的值（前提是它没有被final修饰符修饰，不然就是常量），但是，访问类变量并不需要实例，用类就可以操作了。 类方法（classmethod） 类方法（classmethod）：跟类变量的基本特点一样。供类用的方法，可以没有实例，直接通过类来调用类方法。 从形式上看，类变量和类方法，比一般的变量和方法多了一个static修饰符。因为这个原因，类变量和类方法也被叫做静态变量和静态方法。 使用方式 实例方法可以直接访问实例变量，调用实例方法； 实例方法可以直接访问类变量，调用类方法。但不推荐这么做，原因是不清晰，容易把类变量误认为是实例变量，把类方法误认为是实例方法（借助IDE，它会给出警告信息）； 类方法可以直接调用类变量和类方法； 类方法不能直接调用实例变量和实例方法； 类方法里面不能使用“this”关键字，因为没有实例存在，“this”不知道引用哪个实例。 public,protected,friendly,private 直接上图 作用域当前类同一package子孙类其他packagepublicYYYYprotectedYYYNfriendly(default)YYNNprivateYNNN override&overload override（重写）发生在子类和父类中。 重写是子类对父类的允许访问的方法的实现过程进行重新编写,返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。 重写规则 参数列表与被重写方法的参数列表必须完全相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5及更早版本返回类型要一样，java7及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个类，则不能重写该类的方法 overload（重载）可以发生在一个类中，或者父类和子类中 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准 重写与重载之间的区别 区别点重载方法重写方法参数列表必须修改一定不能修改返回类型可以修改一定不能修改异常可以修改可以减少或删除，一定不能抛出新的或者更广的异常访问可以修改一定不能做更严格的限制（可以降低限制） 多态的三个方面 Adhocpolymorphism(特殊多态)：体现在overload上 Parametricpolymorphism(参数化多态)：体现在泛型上 subtypepolymorphism（子类型多态）：体现在继承上 枚举 本质就是类，但是这些类已经实例化并存储在枚举列表中。枚举也可以有自己的构造方法，成员变量和成员方法。具体看https://blog.csdn.net/qq_35385687/article/details/90147104 接口（静态方法和default方法） default方法：写在接口中，相当于正常的方法，可以写方法体，也可以正常使用。 作用：由于修改接口需要修改接口所有相关的实现类，非常不利于开发维护，因此使用default给接口添加新的方法和实现，实现类会继承default方法，省去了重复开发的弊端。 静态方法：类似类的静态方法，不用实例化对象就能直接调用。 泛型通配符的一些小知识点 具体看https://www.cnblogs.com/minikobe/p/11547220.html 设计模式（工厂，适配器，装饰器，策略模式，模板模式，迭代器模式，访问者模式） 工厂模式：将创建类的细节和逻辑与客户端隔离开。使用一个接口创建不同的子类。 适配器模式：将一个接口转换为客户需要的另一个接口。 假如客户现在使用的接口是A，而需要B的功能，但是B和A之间不兼容。这时候就可以创造适配器类，通过委托调用B的功能。然后修改A，若需要调用B的功能，则在A中委托生成适配器，间接调用B。 缺点：使用过多类之间的关系会非常混乱，而且一个类只能使用一个适配器 装饰器模式：动态地给一个对象添加一些额外的职责。 假如客户现在使用的接口是A，需要一些功能可以灵活添加，则使用装饰器。首先构造一个抽象装饰类B实现接口A。但是抽象装饰类B并不具体实现装饰，而是委托调用装饰子类实现功能。接着我们写各种装饰子类，都继承自B，每个装饰类内部有具体的装饰功能。同时每个装饰子类中有一个构造函数，参数是最顶层的A。这意味这若要生成拥有多个特征的子类，只需在构造时每层嵌套一个装饰子类即可。 策略模式：没啥好说的，就是全部是委托关系。类要使用的时候可以随意选择不同的策略类进行计算 模板模式：类似给定程序框架，然后框架中的模块可以自定义。具体来说，给一个模板类，里面有一个表示方法逻辑关系的方法，在其中的不同方法的逻辑运行关系和流程是确定的，但是部分具体实现由于情况的不同而不同，这时我们可以通过子类继承该模板类，然后修改实现方法。 注意，表示逻辑和流程的方法应该用final修饰，防止被子类更改。 迭代器模式：以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。 访问者模式：当需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。 具体操作，在被访问的类里面加一个对外提供接待访问者的接口，在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。 在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT LSP原则： 只要父类能出现的地方，子类就可以出现，并且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但反之，未要求。 通俗点：子类可以扩展父类的功能，但不能改变父类原有的功能 具体来说： 子类可以实现父的抽象方法，但不能覆盖父类的非抽象方法覆盖或实现父类的方法时输入参数可以被放大，覆写或实现父类的方法时输出结果可以被缩小子类抛出的异常需要比父类具体 实践中： 在类中调用其它类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已违背了LSP如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。如果你的程序中出现了if/else之类对子类类型进行判断的条件，则说明类的设计已违背了LSP。 CRP原则： 软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。（能不用继承就不要用继承） 委托（dependance,Composition,Aggregation） dependance：临时使用，在方法中new一个，使用完成后就抛弃 composition：深入绑定，委派类作为该类的成员。 aggregation：浅绑定，委派类作为该类某个方法的参数进行使用 SOLID编程原则 (SRP)TheSingleResponsibilityPrinciple单一责任原则 当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。 (OCP)TheOpen-ClosedPrinciple开放-封闭原则 软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。 (1)通过增加代码来扩展功能，而不是修改已经存在的代码。 (2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。 (3)OCP支持替换的服务，而不用修改客户模块。 (LSP)TheLiskovSubstitutionPrincipleLiskov替换原则 客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。 (DIP)TheDependencyInversionPrinciple依赖转置原则 (1).高层模块不要依赖低层模块； (2).高层和低层模块都要依赖于抽象； (3).抽象不要依赖于具体实现； (4).具体实现要依赖于抽象； (5).抽象和接口使模块之间的依赖分离 (ISP)TheInterfaceSegregationPrinciple接口聚合原则 不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。 客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。 
第170篇文章[]
软件构造Lab3中关于时间相关类的设计 在lab3中，不同的应用需要的时间格式不同，但IntervalSet接口统一采用了long类型作为时间点参数。为了能够使用IntervalSet接口，初步考虑使用一个时间类进行统一的转换。本来采用了Java自带的Date数据类型作为转换头，但由于Date中大部分的方法已经被舍弃了，无法作为解码器使用；除此之外，由于从给定日期到1900年1月1日的毫秒数过大，在课表APP中担心爆long，因此需要重新设计APP。最终人为定义了一个编解码器类，每个APP需要时调用作为编解码器将时间与long进行转换。排班与课表APP采用从1900年1月1日到给定时间的天数作为编码结果，保证了编码的连续性；其中课表可以将天数乘10转换为课时数，并且也保证了连续。 classDutyCodec { publicDutyCodec(){} /** *Encodeadatetoalonginteger *@paramyeartheyearofthedate *@parammonththemonthofthedate *@paramdaythedayofthedate *@returnalongintegerindicatesthecodeofthedate */ publiclongencode(intyear,intmonth,intday)throwsDateError { longcode=day-1; if(year<1900||month<=0||day<=0||month>12||day>31) thrownewDateError("Invaliddate"); if(day==31) if(month==2||month==4||month==6||month==9||month==11) thrownewDateError("Invaliddate"); if(month==2&&day==29) if(!(year%4==0&&year%100!=0)) thrownewDateError("Invaliddate"); for(inti=1900;i<year;i++) { if((i%4==0&&i%100!=0)||i%400==0) code+=366; else code+=365; } for(inti=1;i<month;i++) { if(!(i==2||i==4||i==6||i==9||i==11)) code+=31; elseif(i!=2) code+=30; else code+=((i%4==0&&i%100!=0)||i%400==0)?29:28; } returncode; } /** *Gettheyearfromthecode *@paramcodethecodewanttodecode *@returnaintegerindicatestheyear */ publicintgetYear(longcode) { intyear=0; for(year=1900;code>=0;year++) { if((year%4==0&&year%100!=0)||year%400==0) code-=366; else code-=365; } returnyear-1; } /** *Getthemonthfromthecode *@paramcodethecodewanttodecode *@returnaintegerindicatesthemonth */ publicintgetMonth(longcode) { intyear=0; intmonth=0; for(year=1900;code>=0;year++) { if((year%4==0&&year%100!=0)||year%400==0) code-=366; else code-=365; } year--; code+=((year%4==0&&year%100!=0)||year%400==0)?366:365; for(month=1;code>=0;month++) { if(!(month==2||month==4||month==6||month==9||month==11)) code-=31; elseif(month!=2) code-=30; else code-=((year%4==0&&year%100!=0)||year%400==0)?29:28; } returnmonth-1; } /** *Getthedayfromthecode *@paramcodethecodewanttodecode *@returnaintegerindicatestheday */ publicintgetDay(longcode) { intyear=0; intmonth=0; for(year=1900;code>=0;year++) { if((year%4==0&&year%100!=0)||year%400==0) code-=366; else code-=365; } year--; code+=((year%4==0&&year%100!=0)||year%400==0)?366:365; for(month=1;code>=0;month++) { if(!(month==2||month==4||month==6||month==9||month==11)) code-=31; elseif(month!=2) code-=30; else code-=((year%4==0&&year%100!=0)||year%400==0)?29:28; } month--; if(!(month==2||month==4||month==6||month==9||month==11)) code+=31; elseif(month!=2) code+=30; else code+=((year%4==0&&year%100!=0)||year%400==0)?29:28; return(int)code+1; } } 
第171篇文章[]
对于装饰器模式的理解 之前一直有个疑问，如果采用装饰器模式设计继承树，那客户端在调用的时候如何使用装饰器中的功能？原先理解的是客户端仍然只能查看接口，但接口带来的问题就是：子类添加的个性的方法无法体现在顶层的接口中，从而导致客户端无法使用子类的所有功能。例如: publicinterfaceA{ publicstaticAempty(){ returnnewA1(); } publicvoida(); } publicA1implementsA{ publicA1(){} @Override publicvoida(){} } publicabstractDecoratorimplementsA{ protectedAdecoratedA; publicDecorator(Aa){ decoratedA=a; } @Override publicvoida(){ decoratedA.a(); } } publicDecorator1extendsDecorator{ publicDecorator1(Aa){ super(a); } publicvoidb(){}; } Aa=newA1(); Adecorator=newDecorator1(a); 此时decorator无法调用b方法查看网上别人的代码后发现，装饰器模式的装饰应该只真对于自身，而不能被外界使用，即b方法应该被private修饰。 
第172篇文章[1]
计算机系统大作业 文章目录 1.C语言的语言元素1.1程序结构1.1.1循序结构1.1.2分支if语句switch语句 1.1.3循环for循环while循环do-while循环 1.2变量1.2.1全局变量1.2.2局部变量1.2.3寄存器变量 1.3数据类型1.3.1常量1.3.2整型数1.3.3浮点数1.3.4数组1.3.5指针1.3.6引用1.3.7结构体 1.4函数 2.汇编语言的语言元素2.1程序结构2.1.1整体结构2.1.2寄存器2.1.3寻址2.1.4数据传送2.1.5压栈与弹栈2.1.6算术与逻辑操作2.1.7控制2.18栈 2.2宏定义2.3变量2.3.1全局变量2.3.2局部变量2.3.3整型变量2.3.4浮点变量 2.4函数2.4.1参数传递的规则2.4.2调用语句2.4.3返回值传递 3.C语言的汇编实现3.1数据类型3.1.1整型3.1.2浮点型3.1.3类型转换 3.2变量与数据的寻址3.3分支、循环结构的实现3.4代码优化对循环的影响3.5函数3.6指针3.7引用 4.C与汇编的优缺点分析4.1开发速度4.2软件运行速度4.3CPU新特性的支持程度4.4软件的可移植性4.5个人体会 5.参考文献 1.C语言的语言元素 1.1程序结构 对于任意一个程序来说，其都是从main函数开始执行。 1.1.1循序结构 intsum(inta,intb) { intc; c=a+b; returnc; } 如图中所示的循序结构函数的代码，循序结构又称顺序结构，其按照语句出现的先后顺序依次执行语句。对于循序结构来说，在忽略某个语句调用了其他函数并导致其他结构出现的情况下，其中的语句都会被执行，但每个语句只会执行一次。 1.1.2分支 C语言中实现分支结构的语句有两种：if语句和switch语句。分支结构先谷底循序结构来说，在忽略某个语句调用了其他函数并导致其他结构出现的情况下，其中的语句会被执行一次或不执行，并且总存在不执行的分支（if和else分支都存在的情况下）。 if语句 intfunction_if(intx) { if(x<0) return0; else returnx; } 如图所示的ReLU函数为典型的if语句实现。if根据括号后表达式的真假决定是否执行该分支。对于有着多种选择的情况，可以有两种实现方法：第一种：嵌套if语句，即在if语句的某个分支中再写入一个if语句。这种实现方法可以在多种分支存在共同的前置条件时使用。将前置条件作为外层if的判断，后置条件则放入内层if语句中第二种：使用elseif。以图中代码举例，若x需要选择大于0、小于0、等于0三个分支时，利用if，elseif，else实现三个分支，执行时会依次测试其中的分支，选中时直接进入。if语句在逻辑上有着较为清楚的实现，但当分支过多时，依次对比会导致执行速度下降。 switch语句 voidfunction_switch(charc) { switch(c) { case'a': cout<<1<<endl; break; case'b': cout<<2<<endl; break; default: cout<<3<<endl; break; } } 如图所示为一个switch语句的实现。switch语句在逻辑上比较清晰，但不能像if语言一样处理复杂分支。switch语句主要面向一个条件有着多个可能实现的分支的情况。其在对比的时候，因底层实现与if语句不同，只需要一次对比即可选中所需分支，在有着大量分支的情况下效率远高于if语句，但switch语句空间占用较大，是典型的空间换时间的策略。 1.1.3循环 C语言中有三种语句可以实现循环结构：for、while、do-while。循环结构与上述两种结构最大的不同在于，循环结构内的语句可以执行不止一次，并且存在不执行的情况，即循环0次。下面以计算从start到end的连续自然数之和的程序为例，介绍三种循环结构。 for循环 intfunction_for(intstart,intend) { intsum=0; for(registerinti=start;i<=end;i++) sum+=i; returnsum; } for循环的一般形式为：for（单次表达式；条件表达式；末尾循环体）{中间循环体}其中，表示式皆可以省略，但分号不可省略，因为“;”可以代表一个空语句，省略了之后语句减少，即为语句格式发生变化，则编译器不能识别而无法进行编译。for循环小括号里第一个分号前为一个为不参与循环的单次表达式，其可作为某一变量的初始化赋值语句,用来给循环控制变量赋初值；也可用来计算其它与for循环无关但先于循环部分处理的一个表达式。分号之间的条件表达式是一个关系表达式，其为循环的正式开端，当条件表达式成立时执行中间循环体。执行末尾循环体后将再次进行条件判断，若条件还成立，则继续重复上述循环，当条件不成立时则跳出当下for循环。for循环在实现访问连续内存空间时较为方便，逻辑清晰。 while循环 intfunction_while(intstart,intend) { intsum=0; while(start<=end) { sum+=start; start++; } returnsum; } while循环与for循环等价。但语法中只保留用于判断是否退出循环的条件表达式。其余需要在对应位置实现。while循环在实现例如遍历链表等访问不连续内存空间时使用方便，逻辑清晰 do-while循环 intfunction_dowhile(intstart,intend) { intsum=0; inti=start-1; do { i++; sum+=i; }while(i<end); returnsum; } do-while循环与上述两种循环的不同点在于：只要循环条件设置的好，上述的两种循环可以不执行循环体内的语句，而do-while循环至少会执行一次循环体内的语句。其他基本与while循环等价。do-while循环时候实现至少执行一次的循环，适合实现至少需要执行一次的循环。例如：用于迭代的计数器初值为0时计算1到n的累加和。 1.2变量 1.2.1全局变量 intinteger=0; unsignedintuinteger=0; floatreal=3.14; intintegers[2]={0,1}; int*pinteger=&integer; int&qinteger=integer; 全局变量能被程序中所有的函数以及对象调用。换句话说它的作用域为整个程序。全局变量被保存在可执行文件的数据段或者.bss段中。全局变量可以被extern和static修饰。对于一个拥有多个源文件的工程来说，每个文件都可以拥有自己的全局变量，并且对于任意文件都可调用。而被extern修饰的全局变量声明表示该全局变量在其他文件中。被static修饰的全局变量则只能被当前源文件内的函数与对象调用。 1.2.2局部变量 intfunction_for(intstart,intend) { intsum=0; for(registerinti=start;i<=end;i++) sum+=i; returnsum; } 以for循环的代码为例，其中出现的所有变量均为局部变量局部变量的作用域为：定义局部变量时，程序执行到的语句所在的花括号包围的范围。与全部变量不同，局部变量被保存在被称为栈的结构中进行管理。 1.2.3寄存器变量 intfunction_for(intstart,intend) { intsum=0; for(registerinti=start;i<=end;i++) sum+=i; returnsum; } 以for循环的代码为例，其中用于计数的i即为寄存器变量寄存器变量与上述两种变量不同，其被保存在存取速度最快的寄存器当中。用register修饰局部变量即可定义寄存器变量 1.3数据类型 1.3.1常量 #defineINTEGER20 #defineREAL3.14 #defineCHARACTER'c' #defineSTRING"string" 常数可分为整型常量（图中INTEGER）、实型常量（图中REAL）、字符型常量（图中CHARACTER）与字符串型常量（STRING）。对于每一种常量，其在底层的实现与其对应的变量相同，但常量的值不能更改，并且存储在文件的只读区域。整型常量、实型常量与字符型常量直接存储在代码段当中，当被使用时，在取指令阶段即可取出。字符串型常量略有不同，由于其一般内存占用较大，不能直接写入代码中，因此被存储在只读数据段中，代码段只保留其首地址。 1.3.2整型数 intinteger=0; unsignedintuinteger=0; 整型数分为有符号整型与无符号整型。二者所能表示的数的数量相同，但区间不同。对于一个k位的整型数来说，有符号整型表示-2(k-1)~2(k-1)-1范围内的所有整数，而无符号整型表示02^k-1范围内的所有整数。二者直接存在着互相转换的情况。当二者均在02(k-1)-1这个区间内时，二者的值相等，类型转换并不会带来值的改变；但是当有符号数在-2(k-1)0或无符号数在2^(k-1)2k-1时，类型转换会导致值的变化，其关系可表示为公式：有符号数+2k=无符号数。 1.3.3浮点数 floatreal=3.14; 与整型数可以精确表示整数不同，浮点数只能精确表示部分实数。对于大部分实数来说，浮点数只能近似表示。根据近似的精度不同，浮点数可以分为单精度浮点型与双精度浮点型。二者在组成上一致，只在二进制位数上不同，从而导致了精度的不同。对于一个浮点数，其二进制代码可分为三个部分：符号位，阶码和尾数。将一个待转换的实数用科学计数法的二进制形式表示，其符号对应着符号位，数量级对应着阶码，精确值的小数部分的前n位对应着尾数，n为尾数的位数。 1.3.4数组 intintegers[2]={0,1}; 数组即为一定数量的某种数据类型的集合。数组在内存中占用一段连续的存储单元，因此可以快速访问其中的元素。字符串类型的变量在底层实现上为一个以\0结尾的字符型数组。数组名的本质是一个指针，指向数组的起始地址。 1.3.5指针 int*pinteger=&integer; 指针的本质为一个整数，它表示指针所指向的对象在虚拟内存中的首地址。 1.3.6引用 int&qinteger=integer; 引用本质上相当于给它表示的对象起了一个别名，二者指向的是内存中的同一个对象，对其中一个的修改也会导致另一个的改变。 1.3.7结构体 structst { charname[20]; unsignedage; unsignedid; }ics_me; 有了上述的数据类型，已经足够实现C语言所有的功能了。但是，在具体使用时仍然会存在问题。首先，抽象层次不够高，不利于人的理解。其次，无法同时管理不同的数据类型，或者说给不同数据类型之间显式的建立关系。因此，C语言提供了结构体。结构体将一系列数据结构封装为用户自定义的一种数据结构，提高了抽象水平，更有利于人类理解。结构体占用的空间并不简单的等于其中所有数据结构的内存大小相加，而是大于等于相加之和，这是由于对齐的存在。其对齐要求与结构体中内存占用最大的那个类型的对齐要求相同。以将图中的结构体的第一个字段改为单一字符后的结构体为例，其空间占用为4+4+4=12字节，而不是2+4+4=10字节。因为对于无符号型来说，其需要满足地址可被4整除的地址要求，因此整个结构体的地址也需满足该要求。带来的结果是：字符型后面的2字节被空在那不被使用。 1.4函数 函数是指一段可以直接被另一段程序或代码引用的程序或代码，例如程序结构当中所具的函数的例子。对于函数来说，其内部代码本可以写入主程序当中。但是，假如一段程序调用了100次某函数，如果该函数存在错误，我们只需修改函数一次；对于写在主程序中的情况，则需要找到这100次并修改。因此封装成函数有利于代码复用，并且提高了程序的可读性。函数的通用形式为：返回类型名字(形式参数表列){函数体语句return表达式;}参数传递方式有三种，传值，传地址，传引用。传值的情况下，函数将实参的值复制给形参，函数体对形参的修改并不会导致实参的变化。对于传地址与传引用这两种形式，本质上都是传入了一个指向实参的一个对象，对形参的修改会同时修改实参。 2.汇编语言的语言元素 2.1程序结构 2.1.1整体结构 当一个程序加载到内存时，其具有五个主要部分：代码段、数据段、堆、共享模块、栈。代码段存储了我们在源文件中所有语句对应的机器指令，以及常数。在程序的执行过程中，处理器按照%rip寄存器所保存的地址依次读取代码段中的指令执行，并根据指令修改寄存器中的值或将值写入内存。代码段在执行过程中不可被修改。数据段中保留了程序中所定义的全局变量，其中已初始化的全局变量被保存在.data段中，未初始化的全局变量被保存在.bss段中。在执行过程中，程序可以读取数据段中的数据并加以修改。堆是保留给程序在执行阶段动态分配内存的区域。由malloc函数向操作系统申请堆的空间，并由free函数释放空间。共享模块是用于节省内存使用空间而引入的一个内存区域。程序中需要大量使用的代码，若每个进程都保留一个副本，则会造成内存的极大占用。而共享模块则只保留每个进程调用这段代码所需的数据，代码本事只在程序中包含一个副本，从而减少了内存开销。栈是程序中局部变量保存的地点以及辅助函数调用的结构。栈内的数据遵循一个规律：后进先出。栈顶地址由一个寄存器%rsp保存。每当进入一个函数时，程序会通过压栈的方式在栈中预先分配好局部变量所需的空间；当退出一个函数时，程序会通过弹栈的方式回收局部变量占用的空间。当函数调用另一个函数时，程序将当前函数的状态，即寄存器中保存的值，通过压栈的方式存入栈中；函数返回时则通过弹栈的方式恢复函数的状态，从而继续执行函数。 2.1.2寄存器 一个x86-64的CPU包含一组16个存储的64位值的通用目的寄存器。各个寄存器的名称与功能如下表 64位名称32位名称16位名称8位名称功能%rax%eax%ax%al返回值%rbx%ebx%bx%bl被调用者保存%rcx%ecx%cx%cl第4个参数%rdx%edx%dx%dl第3个参数%rsi%esi%si%sil第2个参数%rdi%edi%di%dil第1个参数%rbp%ebp%bp%bpl被调用者保存%rsp%esp%sp%spl栈指针%r8%r8d%r8w%r8b第5个参数%r9%r9d%r9w%r9b第6个参数%r10%r10d%r10w%r10b调用者保存%r11%r11d%r11w%r11b调用者保存%r12%r12d%r12w%r12b被调用者保存%r13%r13d%r13w%r13b被调用者保存%r14%r14d%r14w%r14b被调用者保存%r15%r15d%r15w%r15b被调用者保存 2.1.3寻址 对于大多数指令来说，其至少有一个操作数，指出源操作数的位置，以及结果存放位置。其格式主要有三种形式：1、立即数寻址$Imm，对应的操作数值为Imm2、寄存器寻址ra，对应的操作数值为ra中的值3、地址寻址Imm(ra,rb,s)，对应的操作数为地址Imm+ra+rb*s所指向的内存。s的值必须为1，2，4，8.其中的各部分均可以省略Imm省略时默认为0，ra与rb省略时默认值为0，s省略时默认为1。 2.1.4数据传送 数据传送指令 MOV类将数据从源位置复制到目的位置而不改变数据。MOV类指令由四条指令组成，movb，movw，movl，movq，分别移动1、2、4、8个字节。然而，数据的源位置与目的位置的数据大小并不一定相等。当源位置的数据大小大于目的位置时，CPU采用截断的方式缩小数据，即舍弃目的位置存不下的那部分数据；小于时，则需要扩展源数据以匹配目的位置的大小。扩展方式有两种： 零扩展MOVZ，在数据前面补充0。但这会导致有符号数在负数范围内出错。具体指令见下表符号扩展MOVS，在数据前面补充符号位数据。这可以保证有符号数的值不发生变化，但无符号数则会发生变化。具体指令见下表 2.1.5压栈与弹栈 pushq指令将一个四字从寄存器压入栈中，并修改栈顶指针的值。popq指令将一个四字从栈取出到寄存器中，并修改栈顶指针的值。 2.1.6算术与逻辑操作 处理器通过下表中的各种指令完成对数据的算数操作或者逻辑操作 2.1.7控制 对于循环和控制两种结构中的跳转，均需要通过比较来控制。CPU提供了一组单个位的条件码寄存器，描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支。常用的条件码有： CF：进位标志，用于检查无符号数的溢出ZF：零标志SF：符号标志OF：溢出标志，用于检查有符号数的溢出除了算术和逻辑相关指令会修改条件码之外，有两类特殊的指令：CMP指令和TEST指令只修改条件码而不修改其他寄存器的值。可通过这两种指令为循环与分支的触发条件设置对应的条件码：jmp指令则通过检测条件码来判断是否满足跳转条件。各指令对应的跳转条件如下图 2.18栈 栈的功能除了传递参数（见函数部分）、存储局部变量（见变量部分）、保存函数信息（见函数部分）以外，还可以用来保存暂时存储数据。由于寄存器的数量是有限的，当数据无法在寄存器中存下时，程序会将多余的有用的数据压入栈中暂存，当有需要时在将其取出。 2.2宏定义 对于不包含变量的宏定义，编译器会将程序中的宏直接替代，若是计算式则替代计算结果。如图中所示的def（）函数，最终的汇编代码直接返回20而省略计算 #defineDEF2*10 intdef() { returnDEF; } 0000000000401377<_Z3defv>: 401377:55push%rbp 401378:4889e5mov%rsp,%rbp 40137b:b814000000mov$0x14,%eax 401380:5dpop%rbp 401381:c3retq 对于包含变量的宏定义，编译器会将宏替换为对应的表达式。如图中所示的def（intx）函数，编译器将F1（x）的调用替换为了x+x #defineF1(x)x<<1 intdef(intx) { returnF1(x); } 0000000000401382<_Z3defi>: 401382:55push%rbp 401383:4889e5mov%rsp,%rbp 401386:897dfcmov%edi,-0x4(%rbp) 401389:8b45fcmov-0x4(%rbp),%eax 40138c:01c0add%eax,%eax 40138e:5dpop%rbp 40138f:c3retq 2.3变量 2.3.1全局变量 全局变量存储在程序的数据段中，代码段中存储的为全局变量在数据段中的地址。全局变量可分为强符号和弱符号。强符号为初始化的全局变量，而弱符号为未初始化的全局变量。一个程序中同名的强符号只能存在一个，若存在同名的全局变量，连接器会将弱符号解释为对应的强符号。 2.3.2局部变量 局部变量存储在程序的栈中，用于统一管理。以x86-64为例，在进入每个程序块时，指令控制处理器进行压栈操作为块内每个局部变量分配好空间，并且通过弹栈的方式控制变量的作用域。 2.3.3整型变量 按照字节数，整型变量可分为字节（一个字节）、字（两个字节）、双字（四个字节）、四字（八个字节），分别对应了c程序中的char、short、int、long。char类型数据均为无符号数，因此不需要考虑符号问题。对于其余三种数据类型，均存在有符号和无符号两种情况。有符号数以补码的方式存储，而无符号数以原码的方式存储。在运算过程中，若同时存在有符号数与无符号数，编译器会隐式的将有符号数转换成无符号数进行计算。当二者进行类型转换时，处理器不改变二进制形式，而是将补码（原码）直接解释成原码（补码）。 2.3.4浮点变量 处理器的浮点体系结构包含了16个浮点寄存器，从%ymm0到%ymm15。每个浮点寄存器可以存储一个双精度浮点或两个两个单精度浮点，并且可以并行计算。对于浮点体系来说，其包含了另一套指令，包括： 数据传送转换为整型数从整型数转换而来计算部分没学。 2.4函数 2.4.1参数传递的规则 仅考虑整型数。函数在传入参数的时候，首先使用寄存器。其按照%rdi、%rsi、%rdx、%rcx、%r8、%r9的顺序传入前6个参数。当参数数量超过6个时，程序会将这些参数压入栈中，通过栈将数据传入函数。所有通过栈传递的参数都向8的倍数对齐 2.4.2调用语句 函数通过call指令调用其他函数，并通过ret指令返回调用者。在执行过程中，每个函数都拥有一个栈帧 栈中属于该函数的一块连续的区域。每个栈帧的最后一个数据都是需要返回的函数地址 调用指令下一条指令的地址，在此之前栈帧中保存的数据为本函数作为调用者所需保存的参数。每个栈帧前几个数据都是本函数作为被调用者所需保存的参数。这些数据的保存均由call指令完成。同样，ret指令也会将这些数据恢复。当栈弹出返回地址时，PC就被修改为返回地址的值，从而达到了返回函数下一条语句的目的。递归调用则是上述函数调用过程对本函数的反复使用。具体代码和全局变量都在同一个数据段与代码段中，而栈帧又为每次递归调用提供了私有的同名局部变量；返回地址又保证了递归可以从深层返回回调用处。 2.4.3返回值传递 对于函数的返回值，整型数据保存在%rax中，浮点型数据保存在%ymm0中。 3.C语言的汇编实现 3.1数据类型 3.1.1整型 整型数可以分为有符号数与无符号数。对于一个长为k的二进制数，用xk-1,xk-2,…,x0来表示其对应的所有位。对于一个无符号数，其二进制编码形式与十进制数与二进制数和十进制数在数学中的关系相同，对应公式为 B 2 U ( x ) = ∑ i = 0 k − 1 x i 2 i B2U(x)=\sum\limits_{i=0}^{k-1}x_i2^i B2U(x)=i=0∑k−1​xi​2i对于有符号数来说，为了表示正负，其二进制编码的最高位被定义为符号位。其余位与无符号数表示意义相同。对应公式为 B 2 T ( x ) = − x k − 1 2 k − 1 + ∑ i = 0 k − 2 x i 2 i B2T(x)=-x_{k-1}2^{k-1}+\sum\limits_{i=0}^{k-2}x_i2^i B2T(x)=−xk−1​2k−1+i=0∑k−2​xi​2i 3.1.2浮点型 一个浮点型数据在底层编码上可以分为三个部分：符号位、尾数与阶码。符号位以1来表示负数，0表示正数。对于任意一个实数，将其绝对值表示成二进制的科学计数法，则其数量级即是阶码表示的部分，系数的小数部分即尾数表示的部分。当阶码全为1，尾数全为0时，该数表示无穷大，结合符号位即可表示正无穷大或负无穷大。当阶码全为1，尾数不全为0时，该数表示NAN（Notanumber）。为了便于比较，阶码放在尾数之前。如图所示，单精度浮点数有着8位阶码，23位尾数；双精度浮点数有着11位阶码，52位尾数。 3.1.3类型转换 对于c语言中的运算，存在着显式和隐式的类型转换。隐式类型转换会发生在赋值以及计算的时候。转换有着以下集中类型有符号数与无符号数之间的转换：当着二者发生转换时，由于均为整型数，其底层二进制编码不会改变，仅仅修改解码方式。小整型向大整型转换：小整型向大整型转换需要在多出的位上填充0或者1，即零扩展和符号扩展。对于有符号数来说，符号扩展能保证扩展后的值不发生改变；对无符号数来说，零扩展能保证扩展后的值不发生变化。大整型数向小整型数转换：大整型数相对小型整数来说具有更长的二进制位，因此需要截断多余的位来满足小整型数的位数要求。当大整型数的值本身在小整型数的表示范围内时，截断并不会改变数的值；但当大整型数的值不在小整型数的表示范围内时，截断会由于溢出而发生值的改变。如图中程序及输出所演示。 longlonga=1<<2; longlongb=(longlong)1<<40; cout<<(int)a<<endl; cout<<(int)b<<endl; 整型数转化为浮点数：此时类型转换不会发生溢出，但是由于尾数长度有限，可能会发生舍入浮点数转化为整型数：浮点数会舍弃小数部分，向0取整。 3.2变量与数据的寻址 在程序中，变量要么存储在寄存器中，要么存储在内存中。对于存储在寄存器当中的数据，如函数传入的参数，处理器会直接对寄存器访问或者修改。对于存储在内存当中的变量，编译器在编译链接阶段就确定了其地址。需要使用时，程序将地址存入某个寄存器，再使用寄存器进入内存中访问或者修改该变量。数据的情况与变量类似，但数据只存在于内存当中（这里特指写在数据段或者只读数据段的数据）。唯一的不同点在于，变量可以不用写回内存中，但数据则必须写回。进一步，只读数据只能读取，不可写入。 3.3分支、循环结构的实现 对于现代编译器生成的机器指令，循环以及分支语句通过均通过跳转指令实现。通过跳转到之前执行过的指令，再顺序执行到跳转指令处实现循环结构。以图中的function_jump函数为例，其前一部分为for循环，后一部分为选择语句。 intfunction_jump(intn) { intx=0; intsum=0; for(inti=0;i<n;i++) x+=i; if(n<=0) sum=0; else sum=x; returnsum; } 如图所示汇编代码，40134f处的jge指令判断i是否小于n，以控制是否继续循环；而40135b处的jmp指令则是跳回到循环的开始处。当不再继续循环时，程序在401234f处跳转到40135d，越过40135b从而进入分支部分。 401349:8b45f4mov-0xc(%rbp),%eax 40134c:3b45eccmp-0x14(%rbp),%eax 40134f:7d0cjge40135d<_Z13function_jumpi+0x30> 401351:8b45f4mov-0xc(%rbp),%eax 401354:0145fcadd%eax,-0x4(%rbp) 401357:8345f401addl$0x1,-0xc(%rbp) 40135b:ebecjmp401349<_Z13function_jumpi+0x1c> 通过跳转到不同的未执行过的指令，顺序执行到分支结束处，再通过跳转会和从而达到分支的功能。如图所示汇编代码，401361处的jg指令控制程序进入40136c之后的指令所对应的分支，另一条分支则为401363对于的语句。40136a处的jmp指令控制两条分支在401372处汇合，之所以只存在一个jmp指令，是因为40136c处的分支只需顺序运行下去即可达到401372处，无需跳转 40135d:837dec00cmpl$0x0,-0x14(%rbp) 401361:7f09jg40136c<_Z13function_jumpi+0x3f> 401363:c745f800000000movl$0x0,-0x8(%rbp) 40136a:eb06jmp401372<_Z13function_jumpi+0x45> 40136c:8b45fcmov-0x4(%rbp),%eax 40136f:8945f8mov%eax,-0x8(%rbp) 401372:8b45f8mov-0x8(%rbp),%eax 3.4代码优化对循环的影响 voidfunction_o3_1(int**A,int**B) { for(inti=0;i<100;i++) for(intj=0;j<100;j++) B[i][j]=A[j][i]; } voidfunction_o3_2() { intx=0; for(inti=0;i<5;i++) x+=5; } 以上图中两个函数为例，第一个为求100x100的矩阵转置，第二个为求前0+1+2+3+4。在不开优化的情况下，编译器按照程序所写的语句，依次将其转为汇编语言。当开启O3优化后，变化如下 0000000000401690<_Z13function_o3_1PPiS0_>: 401690:4989f0mov%rsi,%r8 401693:31c9xor%ecx,%ecx 401695:498b3448mov(%r8,%rcx,2),%rsi 401699:31c0xor%eax,%eax 40169b:0f1f440000nopl0x0(%rax,%rax,1) 4016a0:488b14c7mov(%rdi,%rax,8),%rdx 4016a4:8b140amov(%rdx,%rcx,1),%edx 4016a7:891486mov%edx,(%rsi,%rax,4) 4016aa:4883c001add$0x1,%rax 4016ae:4883f864cmp$0x64,%rax 4016b2:75ecjne4016a0<_Z13function_o3_1PPiS0_+0x10> 4016b4:4883c104add$0x4,%rcx 4016b8:4881f990010000cmp$0x190,%rcx 4016bf:75d4jne401695<_Z13function_o3_1PPiS0_+0x5> 4016c1:c3retq 4016c2:66662e0f1f8400data16nopw%cs:0x0(%rax,%rax,1) 4016c9:00000000 4016cd:0f1f00nopl(%rax) 首先，编译器会将循环打开，如图中所示汇编代码，编译器将整个矩阵拆分成以64为单位的块，每次对一个块进行转置操作，以补偿程序cache不命中的代价。 00000000004016d0<_Z13function_o3_2v>: 4016d0:c3retq 4016d1:662e0f1f840000nopw%cs:0x0(%rax,%rax,1) 4016d8:000000 4016db:0f1f440000nopl0x0(%rax,%rax,1) 其次，编译器会舍弃无用计算，例如将常数表达式替换成常数，或如图所示，不需要执行的操作不予生成。 3.5函数 每个函数在代码段中都有自己的位置。在执行阶段，每个函数都会在栈中拥有自己的栈帧。栈帧结构如下图所示。函数的参数通过寄存器传入，对于多余6个的，则通过栈传入（见2.4.1）。函数的调用通过call指令实现，其本质为保存原函数的内容并修改下一条指令的地址为被调用函数；函数返回通过ret指令实现，其本质为从栈中恢复寄存器当中的内容并修改下一条指令的地址为调用函数指令的下一条指令。 3.6指针 指针的本质为一个地址。每一个变量的使用在函数底层都是指针。指针在赋值时，若从另一个指针处获得值，则通过mov指令即可实现；若为某个变量经过取地址操作进行赋值，则通过leaq指令将变量的地址赋值给保存当前指针的寄存器。指针指向的地址为虚拟地址。在编译阶段，为了便于编译器实现以及满足操作系统的某些功能，生成的程序均以虚拟内存作为内存。当处理器需要提取某个指针指向的值时，处理器将指针表示的虚拟内存送入MMU中进行地址翻译，最终cache或内存返回数值供处理器使用。 3.7引用 引用在底层是通过指针实现的 intinteger=0; unsignedintuinteger=0; floatreal=3.14; intintegers[2]={0,1}; int*pinteger=&integer; int&qinteger=integer; intquota() { intx=integer; x=qinteger; returnx; } 以上图中的函数为例，其对应的汇编代码为 0000000000401436<_Z5quotav>: 401436:55push%rbp 401437:4889e5mov%rsp,%rbp 40143a:8b05602d0000mov0x2d60(%rip),%eax#4041a0<integer> 401440:8945fcmov%eax,-0x4(%rbp) 401443:b8a0414000mov$0x4041a0,%eax 401448:8b00mov(%rax),%eax 40144a:8945fcmov%eax,-0x4(%rbp) 40144d:8b45fcmov-0x4(%rbp),%eax 401450:5dpop%rbp 401451:c3retq 我们可以注意到，在0x40143a处第一次使用integer赋值时，integer的地址为0x4041a0，而在0x401443/0x401448处第二次使用引用赋值时，程序通过integer的指针取出integer的值从而实现引用。 4.C与汇编的优缺点分析 4.1开发速度 从开发速度的角度来说，C语言远快于汇编语言。C语言作为高级语言，更贴合人类的语言习惯。在开发过程中，C语言大部分只需要考虑逻辑上如何实现功能，极少部分时间由于bug的存在需要考虑底层实现；而汇编代码的每一个语句都需要考虑底层实现以及各种硬件资源，以防止有用数据丢失。 4.2软件运行速度 在运行速度上，经过设计的汇编语言比C语言快得多。因为人工设计的汇编程序能够有效的利用硬件资源；而编译器生成的汇编程序，由于需要保证程序的正确性，编译器会牺牲性能，除此之外，编译器也无法加入人工可以设计的技巧进行加速。 4.3CPU新特性的支持程度 汇编语言对CPU的新特性支撑程度更高。汇编语言中的指令往往能直接利用CPU的新特性。而C语言的底层实现不依赖于C程序，而依赖于编译器。当编译器不支持CPU的新特性时，C语言便不支持CPU的新特性。 4.4软件的可移植性 C语言的可移植性远高于汇编语言。对于不同类型的机器来说，其指令集往往是不同的，因此实现同样的功能，其汇编语言也往往不同，可移植性极差。而C语言不依赖于底层汇编，其描述的只是程序需要的逻辑，因此C程序可以在各种机器上移植，每中机器只需要提供对应的编译器即可。 4.5个人体会 当只能使用C语言或汇编语言时，若需要实现复杂功能，则必选C语言而不选择汇编语言。但是，当程序遇到速度瓶颈，而针对C程序的优化仍无法胜任时，需要在C程序的关键部分中插入人工设计的汇编语言以提高性能。除此之外，当遇到一台新机器，并且该机器缺少编译器的时候，则只能使用汇编语言。在开发一些嵌入式的简单程序时，使用汇编语言往往能达到更好的效果。 5.参考文献 [1]深入理解计算机系统（第三版）[2]http://www.360doc.com/content/17/0308/22/40101294_635112591.shtml 
第173篇文章[]
JUnit测试是否正常抛出错误 在使用JUnit测试代码时，课程上将的只有assertEquals函数。然而，assertEquals函数的实现是调用了对象提供的equals方法来判断被测是否与参照相同，如果程序抛出错误，assertEquals函数就无法捕获例如 NewList<Integer>list=newArrayList<>(); assertEquals(1,list.get(0)); 会抛出错误，假设此时我们需要测试是否正常抛出了越界错误，就不能使用assertEquals函数进行测试因此，JUnit提供了一个fail函数来判断是否抛出了异常，其随trycatch块一起共同使用 try { //被测代码 fail("缺了异常")； } catch(Exceptione) { System.out.println("e.getMessage()"); } 此时若被测代码没有抛出异常，则会执行fail函数 
第174篇文章[2]
信息安全课作业1：老师迷惑的打油诗 2021/5/25 网上除了老师的微博，上一届学长写的还不是这个作业，所以写下来造福下以后的学弟学妹，不要浪费时间在这上面 声明：图片都是作业自带的，跟我没关系（真的） 第一题 “二八”妙龄写密码，看谁聪明“爱死他”。 密文：76 6C 72 73 62 6F 76 70 6A 5E 6F 71 5F 72 71 76 6C 72 70 6D 62 6B 71 71 6C 6C 71 66 6A 62 明文：you very smart but you spent too time 思路：爱死它表示为ascii编码（能从密文看出来），而，所以这个是一个偏移量为3的凯撒密码（原因是后找的，实际是枚举0到10枚举出来的） 第二题 无题警示： 锦瑟无端五十弦，一弦一柱思华年， 千帆远眺蝴蝶梦，万国赛马撩人眼。 沧海月明珠有泪，蓝田日暖玉生烟， 此情可待成追忆，他年饮酒泪涟涟。 密文：24205299922620426799368643468534687 明文：庄生晓梦迷蝴蝶 思路：和上一题思路差不多，“万国马”就是Unicode，“饮酒”对应09，然后还是一个凯撒密码 后面的题开始坑爹了起来 网上找的能用的Des在线加密解密网页http://www.jsons.cn/desencrypt/ 第三题：黛丝打靶 日落西山红霞飞，战士打靶把营归。 五发中靶二十二，黛丝秘诀子弹飞。 密文：U2FsdGVkX18HM4A1Xow2e412F0IMPUSDVw/lNeTEtwDYAjSHsx61CQ== 明文：youareveryclover 思路：“黛丝”对应Des算法；“日落西山红霞飞，战士打靶把营归”是打靶归来的第一句，里面有句“misolamiso，lasomidore”，对应的简谱为35635,65312。而3+5+6+3+5=22，所以密钥是35635 第四题：迷人的黛丝 打靶通关密语 日落西山红霞飞，战士打靶把营归。 张三成绩二十二，李四十七把牛吹。 我的成绩比你好，先后起来你悲催； 美女黛丝抿嘴笑，再来一次子弹飞。 密文：U2FsdGVkX1+YN8tsns+7jvoarVmsqg316iBBvFP3ZemnrYEOGsI6bH5CvIVFSN0Y px1ka4fSPGj7cDvg81wU8BlnJYoDdhvl83cBIQDHk0JQnpaKXU3ZRA== 明文：Youareamazing 思路：这题大部分和上一题一样，3+5+6+3+5=22，6+5+3+1+2=17，但如果直接用这俩，不管怎么拼接都不行。“再来一次子弹飞”可以看出需要解密两次。 第一层：第三句“我的成绩比你好，先后起来你悲催”是关键，原本以为是拼接35635和65312的顺序，结果半天搞不定，甚至考虑了数字的单调性是不是对应“先后”这俩字。结果密钥是65312-35635=29677得到字符串“xxaqdl(p25-12-bstring)U2FsdGVkX199XCqgBzG3McJ1NuWuuPclqBS9lekxPpE=” 第二层：你看这字符串的开头啊：信息安全导论（xxaqdl）第二十五页（p25）第十二行（12）二进制数对应的字符串（bstring5），诶，孤零零一个01000011，第二层密钥就它了，解密时记得把xxaqdl(p25-12-bstring)去掉，后面的才是密文 
第175篇文章[]
已学的UML类图的基本元素 单个类 Class +Stringpublic -Stringprivate #Stringprotected ~Stringdefault +Abstract():String +Static():String 如图中类图所示+表示public修饰符-表示private修饰符#表示protected修饰符~表示默认包权限，即本包可见，外部包不可见斜体字表示抽象方法下划线表示静态方法 类间关系 继承 A B 图中所示有误，应用空心三角与实线表示继承关系 实现 A B 图中所示有误，应用空心三角与虚线表示继承关系 聚合（hasa关系） A B 用空心菱形与实线箭头表示，如图表示B含有一个A 
第176篇文章[]
Lab2中关于equals方法的一个问题（尚未解决） lab2实验中要求不能有警告且不能用@SuppressWarnings取消警告。然而，在为包含泛型的可变类型写equals方法时，遇到了如下问题 ClassGraph<L> { @Override publicbooleanequals(Objectobj) { if(obj==null) returnfalse; if(!(objinstanceofGraph)) returnfalse; Graph<L>g=(Graph<L>)obj; } } 在类型转换时，编译器报警告：Typesafety:UncheckedcastfromObjecttoGraph。网上给出的方法均是使用@SuppressWarnings(“unchecked”)或者设置IDE来忽视该警告。是否有其他解决办法？ 
第177篇文章[]
2021-07-07 关于多态的一些内容 重载的多态 与overload相关，主要是多个不同实现的方法具有相同的名字，但每个方法之间的参数必须有所区分。重载多态对于客户端而言是方便的，不需要记住大量方法的名字，根据输入的参数不同，会在静态类型检查时自动匹配相应的方法。例如： privatevoidPeople(Stringname) { } privatevoidPeople(Stringname,Stringtel) { } privatevoidPeople(Stringname,Stringtel,intage) { } 三者虽然方法名相同，但参数类型不同，因此符合重载多态注意： privatevoidPeople(Stringname,Stringtel,intage) { } PrivatebooleanPeople(Stringname,Stringtel,intage) { } 这两个方法虽然返回值类型不一致，但参数类型是相同的，不构成重载 参数的多态 参数多态即我们通常所说的泛型，当具体使用的数据类型还不确定时可以使用，能够提高代码的适用范围。例如： publicstatic<L>IntevalSet<L>empty() { } L便是我们所用的一个替代具体数据类型的一个标识符当我们需要赋予其具体类型时，例如String IntevalSet<String>a=IntevalSet.empty(); 只需将先前的L换成我们所要使用是数据类型即可 子类型多态 子类型多态的前提条件有以下几点： 要存在继承关系。重写子类（override)父类要引用子类对象。 publicclassfriend{ inta=10; publicvoidmakefriend() { System.out.println("makefriend"); } } publicclassBestfriendextendsfriend{ inta=9; publicvoidmakefriend() { System.out.println("makebestfriend"); } } Bestfriend继承了父类friend，而且重写了方法makefriend,二者都定义了一个成员变量a.测试： publicstaticvoidmain(String[]args){ friendf=newBestfriend();//多态使用 f.makefriend(); System.out.println(f.a); } 输出结果为; makebestfriend 10 我们发现1.调用成员方法时，使用的是子类型中重写后的成员方法。2.父类和子类中出现同名的成员变量时，多态调用该变量时，会使用父类中成员变量 
第178篇文章[]
2021-07-06 #关于final关键字的一些内容 修饰变量：final关系字修饰后的变量，其内存地址是不会发生变化的。例如：修饰基本数据类型 publicfinalStringa="kk"; a=newString("tt");//静态类型检查会报错 由于string是immutable类型的变量，当改变a的值时，会将其指向一个新的内存空间，与final变量修饰相矛盾，报错。修饰引用数据类型，即对象 finalPersonb=newPerson("b","00000"); finalPersonc=newPerson("a","11111"); System.out.println(b.getname()); b.setname("c"); System.out.println(b.getname()); 此时的输出结果为：可以看到b的保留的某些值是可以正常更改的。但想进行下列操作时 c=b; 系统会报错，因为对象b和对象c使用了final关键字来进行修饰，其指向的内存地址是不可以修改的。但对象内部值与对象的内存空间是不一样的，所以对象内部的值可以修改。修饰方法时final关键字修饰的方法是不能够重写的，并且某一个类中所有private方法都默认添加了final关键字修饰类时final关键字修饰的类是无法被继承的 
第179篇文章[3]
循环素数python 题目内容 数字197可以被称为循环素数，因为197的三个数位循环移位后的数字：197,971,719均为素数。100以内这样的数字包括13个，2,3,5,7,11,13,17,31,37,71,73,79,97。要求任意正整数n以内一共有多少个这样的循环素数。 输入格式 一个正整数n。 输出格式 n以内循环素数的数目。 输入样例 100 输出样例 13 importmath defIs_prime(x): foriinrange(2,int(math.sqrt(x))+1): ifx%i==0:returnFalse returnTrue n=int(input()) sum=0 foriinrange(2,n): flag=True num=str(i) forjinrange(len(num)): num=num[1:]+num[:1] temp=int(num) ifnotIs_prime(temp): flag=False break ifflag:sum+=1 print(sum) 
第180篇文章[]
如何将Java中的Date类变成immutable类型 想法一 直接使用final对Date的对象进行修饰。 但是Date是对象数据类型（Objecttypes），当我们对这样的数据类型用final修饰时，它引用的对象是不能改变的，但是它指向的对象的值是可以改变的。 finalDatedate=newDate(); date.setYear(2021);//allowed! 上面代码是合法的，我们尽管使用了final来修饰Date类型的date对象，我们依然可以调用setYear方法来修改date里有关年份的属性。 想法二 写一个自己的MyDate类，在这个类中，实现Date类的基本功能，但是一切可能改变对象值的方法都不应该再出现（例如上面提到的setYear方法）。其实本质上就是在新的类里创建了一个Date类型的private对象，然后将需要实现的方法委托（Delegation）给Date类。 importjava.util.Date; publicclassMyDate{ privateDatedate; publicMyDate(){ date=newDate(); } publicMyDate(longtime){ date=newDate(time); } publicbooleanafter(MyDatewhen){ returndate.after(when.date); } publicbooleanbefore(Mydatewhen){ returndate.before(when.date); } //  } 
第181篇文章[6]
QQ小程序下载文件到本地 通过QQ小程序自带的qq.cloud.downloadFile可将文件从云端下载，并保存至一个临时目录。这时如果我想把文件保存到手机本地怎么办呢？第一个想法是通过QQ小程序自带的qq.saveFile这个API，但是经过尝试后发现，这个保存的文件只有在小程序内部才能查看，而在手机的内部存储中找不到这个文件。所以才有了下面这个比较麻烦的方法，但是可以保存至手机本地。 思路：先将文件转化为图片，再把图片保存至系统相册，最后在手机存储中找到该图片再转化为原文件即可。 （假设下载的是PDF文件） qq.cloud.downloadFile({ fileID:'填入待下载文件的fileID' }) .then((res)=>{ console.log(res.tempFilePath) constsavePath=qq.env.USER_DATA_PATH+'/123.pdf.jpg' qq.getFileSystemManager().saveFile({ tempFilePath:res.tempFilePath, filePath:savePath, success(res){ console.log('save->',res) qq.saveImageToPhotosAlbum({ filePath:savePath, success:(res)=>{ qq.showModal({ title:'文件已保存到手机相册', content:'可在相册中查看文件详细位置，找到文件后将保存的文件后缀名改为[.pdf]即可', confirmColor:'#0bc183', confirmText:'知道了', showCancel:false }) } }) }, fail(){ console.log("下载失败") } }) }) 
第182篇文章[1]
主存与内存 计算器内存条采用的是DRAM(动态随机存储器)，即计算机的主存。我们通常所说的内存容量即指内存条DRAM的大小。 但是，严格地说，内存是包括主存与高速缓存(Cache，基于SRAM)的。可能是由于Cache相较内存条容量很小，毕竟内存容量只计内存条大小，加上重要性也不及内存条，所以就忽略了高速缓存Cache，直接将主存等同于内存了。 上图为计算机中存储器的层次结构。早期计算机系统的存储器层次结构只有三层：CPU寄存器、DRAM主存和磁盘存储。不过，由于CPU和主存之间速度差距较大，系统设计者被迫在CPU寄存器和主存之间增加了SRAM高速缓存（Cache）。 
第183篇文章[6]
QQ小程序更新数据库记录 QQ小程序的云开发文档中有关于数据库更新数据的相关教程（链接），但是它存在着一个致命的缺陷 不能根据某个或某几个索引进行查找后更新相关记录的数据。但是这个功能其实是很常用的，下面是一种替代方法。 思路：先通过某个索引查找相应记录，再将原记录删除；更新相应属性后，插入新的记录。 首先是数据库的初始化： constdb=qq.cloud.database({ env:'自己创建的云环境ID' }); conststudent=db.collection('student')//取名为"student"的集合索引 删除学号为123456的记录 student.where({ number:'123456' }).remove().then((res)=>{ console.log('删除一条记录',res.data); }); 将相应属性进行更新后，插入新记录 student.add({ data:{//这里一定要把所有属性都写出来 number:'123456', name:'张三',//例：更改姓名属性 } }).then((res)=>{ console.log('增加一条记录：',res.data); }); 这样便可以替代实现根据索引进行查找后更新相应记录的功能。 
第184篇文章[3]
Python实现 依次计算一系列给定字符串的字母值，字母值为字符串中每个字母对应的编号值（A对应1，B对应2，以此类推，不区分大小写字母，非字母字符对应的值为0）的总和。 题目内容：依次计算一系列给定字符串的字母值，字母值为字符串中每个字母对应的编号值（A对应1，B对应2，以此类推，不区分大小写字母，非字母字符对应的值为0）的总和。例如，Colin的字母值为3+15+12+9+14=53 输入格式:一系列字符串，每个字符串占一行。 输出格式：计算并输出每行字符串的字母值。 输入样例：ColinABC 输出样例：536 importsys defvalue(s): sum=0 forwordins: ifwordin'abcdefghijklmnopqrstuvwxyz': sum+=ord(word)-ord('a')+1 elifwordin'ABCDEFGHIJKLMNOPQRSTUVWXYZ': sum+=ord(word)-ord('A')+1 returnsum forlineinsys.stdin: line=line.strip() print(value(line)) 
第185篇文章[3]
Python实现 汉诺塔问题 题目内容：如在汉诺塔游戏中，我们希望将塔A上的n个盘子，通过塔B移动到塔C，则对于任意输入的n，给出移动的步骤。 输入格式:一个正整数n 输出格式：移动的步骤 输入样例：2 输出样例：Move1fromAtoBMove2fromAtoCMove1fromBtoC defhanoti(n,a,b,c): ifn==1: print('Move',n,'from',a,'to',c) else: hanoti(n-1,a,c,b) print('Move',n,'from',a,'to',c) hanoti(n-1,b,a,c) n=int(input()) hanoti(n,'A','B','C') 
第186篇文章[3]
单词计数（python） 使用python实现英文小说中简单的单词计数（去除标点、空格，忽略大小写），统计出现最频繁的50个单词。 importre f=open('emma.txt') d={} forlineinf: words=line.strip().lower().split() words_new=[] forwordinwords: word_new=re.sub(r'[\s+\.\!\/_,$%^*(+\"\']+|[+ ！，。？、~@#￥%……&*（）]+','',word)#过滤中英文标点 words_new.append(word_new) forwordinwords_new: ifwordind: d[word]+=1 else: d[word]=1 word_freq=sorted(d.items(),key=lambdax:x[1],reverse=True)#按出现次数从大到小排序 print(word_freq[:50])#打印出现次数最多的前50个单词 f.close() 测试小说样例下载 
第187篇文章[7]
哈工大数字逻辑与数字系统设计大作业（数字密码锁） 哈工大2020数字逻辑大作业 1.设计要求 1.1主要设计要求 （1）设计一个开锁密码至少为4位数字（或更多）的密码锁。（2）当开锁按扭开关（可设置8位或更多，其中只有4位有效，其余位为虚设）的输入代码等于所设密码时启动开锁控制电路，并且用绿灯亮、红灯灭表示开锁状态。（3）从第一个按扭触动后的5秒内若未能将锁打开，则电路自动复位并发出报警信号，同时用绿灯灭、红灯亮表示关锁状态。 1.2附加功能 （1）可以设置密码，在解锁状态下通过设置密码按钮SP设置密码。（2）五秒计时采用倒计时（即从5s计时到0）的方式，将秒数显示在开发板的七段数码管上。五秒后发出警报（警示灯亮）。（3）可以清空密码输入，重新输入密码（不中止计时器）。（4）设置密码及输入密码时，所键入的密码均会显示在开发板的七段数码管上。（5）输入密码错误、设置密码成功、输入密码成功，均会有相应的提示灯亮。 2.工作原理及系统方框图 2.1工作原理 根据系统功能来分析，可将整个系统分为以下4个主要功能模块。（1）编码模块：将输入的4位密码分别转换成8421-BCD码；（2）存储模块：在设置密码后，将密码保存；（3）比较模块：将之后输入的密码和存储的密码进行比较；（4）计时模块：主要体现五秒倒计时的功能。首先通过输入端输入密码，进而通过编码模块将十进制的密码转化成8421-BCD码进行保存，如果是设计密码的状态，则直接将密码保存下来，否则在输入4位密码后调用比较模块，将输入的密码与之前保存的密码进行比较。一旦输入的密码与设置的密码相等，则绿灯亮；否则，会有相应的指示灯闪烁表示输入密码错误。另外，在输入的第一位密码被读取的瞬间，计时模块启动，5s倒计时开始。如果在倒计时期间成功解锁，则立刻中止计时；如果倒计时结束后仍未解锁，则密码锁进入锁死状态，同时警示灯亮起。 2.2系统框图 系统的结构框图如下图所示。 3.各部分模块具体功能及设计思路 3.1编码模块 编码模块的核心功能是将输入的十进制数（0~7）编码为3位二进制数，功能类似于一个8-3编码器，它的主要作用是为其他模块提供数据来源。编码模块的输入和输出都是高电平有效的。 3.2存储模块 通过编码模块，我们已经将输入的十进制数转换成了二进制数。显然，由于需要输入4位密码，也就是4个十进制数，我们就需要保存下4个3位二进制数。我们想通过4个3位寄存器来分别存储这4个3位二进制数。但是，四位密码是依次输入的，这也就意味着4个寄存器是依次工作的，并且一次只能有一个寄存器工作。这里的依次存储功能可以通过一个4位计数器和一个2-4译码器的组合来实现。计数器负责选择每位数，从1-4位计数。为了知道已经输入几位密码而且依次准确地存储，我们将计数器的时钟端脉冲设置为密码输入端按下时产生的上升沿，用来驱动计数器，让计数器从00记到11。进而将计数器的输出端接到译码器的输入端，并且将译码器的输出端分别与4个寄存器的使能端相连接，从而完整实现分别使能四个寄存器，依次存储的功能。另外，要想使每次密码输入端按下时都产生一个脉冲，我们可以用或门来实现，开始时密码输入端都为低电平，只要有一个高电平输入，输出的时钟信号就是高电平，计数器就向下计一个数。另外为了便于用户设置以及输入密码，每当用户输入一位密码（无论是设置密码时还是尝试解锁时），均有一个提示灯闪烁一下表示输入成功。与此同时，用户所输入的密码会通过开发板上的七段数码管显示出来，以便于用户操作。 3.3比较模块 比较模块的核心工作是判断输入的密码与存储模块存储的密码是否相同。我们设计了4个3位的数值比较器来实现比较的功能，如果当前输入的3位二进制数与之前保存的数均相等，则输出1（高电平）。因此，当每个比较器的输出端都为1（表示数值相等）时，密码正确。我们将4个输出端用与门连接，当与门输出1时绿灯亮。每输入一位密码，就会产生一个脉冲，从而触发比较器的工作，依次输入四个密码如果都正确，那么密码锁就会打开。一旦密码正确，绿灯就会亮起，表示解锁成功，与此同时计时器会停止计时，其他的所有指示灯均熄灭。而如果输入的4位密码有误，会有指示灯闪烁以做出提示，此时计时器模块不停止工作。 3.4计时模块 计时模块主要包括分频器、计数器和显示器，能准确通过7段数码管显示秒数，并且能在计时5s后，发出警告（alarm警示灯亮），且使红灯亮。此时，进入复位状态（清空输入，设置的密码保存），即使输入正确密码也不能再使绿灯亮。这里的计时5s可以通过计数器和分频器的组合来实现，由于开发板的时钟频率是100Mhz，可以先将它分频100M，然后计数器每计数1次就代表1s，并且通过一个多多译码器在7段数码管上显示对应的秒数。当输入0~7数字中的任何一个（即开始输入密码）时，5秒倒计时开始，此时复位信号is_locked=0（低电平），其他模块均可以正常工作。一旦5s倒计时结束，就把is_locked设置为1（高电平），即进入锁死状态，并且警示灯亮起。 4.调试过程 4.1计时器的调试 计时器的主要功能是5s倒计时，并且将秒数显示在七段数码管上。倒计时的功能其实相对容易，只要调整分频参数即可实现。最需要调试的其实是计时器的启动和终止，因为尽管计时器是一个相对独立的模块，它的开始和停止很大程度上受到输入密码的控制。我们规定，在设置密码的状态下，计时器不会启动；在尝试解锁时，输入第一位密码后，计时器启动；输入密码正确时，计时器中止；倒计时结束后，计时器中止，如不手动复位，则计时器不再启动。上述功能我们是通过向计时器（timer）模块传递一个start参数进行实现的。首先初始化start<=0。在任何时候，一旦sp==1（即进入设置密码状态），start保持为0；而一旦密码锁已经上锁，尝试输入密码时，更改start<=1；如果倒计时未停止且解锁成功，便立刻将start赋值为0，停止计时。这三种情况都比较好实现，相对复杂的是最后一种情况，即倒计时结束后，计时器需要立刻中止。因为start是传入timer模块的参数，所以在模块内部是不能给start赋值的，正是这一点造成了这种情况的复杂性。不过由于计时器倒计时结束alarm便会变成高电平，我们可以在主模块内部对alarm的值进行判断，一旦alarm==1，则start<=1。 4.2设置及输入密码的调试 我最初的设想是只要pw（输入的密码）值改变，并且是有效值，就把输入转为二进制后保存下来。但是这样做存在一个致命的问题 对于一个reg类型的变量，verilog是不允许它在不同的两个always语句块中被赋值的，比如说我设置了一个clr按钮，一旦按下就清空当前输入的密码，那么清空操作触发的信号其实是posedgeclr，这个操作改变了暂存密码的几个寄存器的值；而在always@(pw)语句块中，肯定也需要修改这几个寄存器的值，这就产生了矛盾。而如果将这两个always语句块合并，又与预期的功能不符，所以这个设想被否定了。我在最后的代码里采用的想法是将这几个模块的处理统一放在一个always@(div_clk)语句块中，在语句块里检测sp，clr是否按下，pw是否有效等等。相对于之前的设想，这里对密码输入、clr操作等的检测的灵敏度一定程度上都下降了，但却能保证所有功能的正常实现。这里div_clk是对系统时钟的一个分频，这里分频的目的是便于用户输入密码 如果时钟频率过高，系统可能会一次读入多个密码；而如果频率过低，输入密码、clr、sp操作的效率就会下降。而只要分频合适，就能够兼顾上述功能的实现。以下是分频以及clr操作的部分代码。 4.3七段数码管显示的调试 七段数码管在开发板的左上方，一共有8组数码管。下图是七段数码管的实物图。但是在这8组数码管下方只标出了两组接口（图中较大的矩形框），这表明一次最多使用两个数码管。另外，在调试中我发现如果只对这两组接口进行赋值，七段数码管是不会有任何显示的，这就类似于数码管没有使能。经过更仔细的观察，我发现在每个七段数码管上方都有一个对应的接口（图中较小的蓝色矩形框），可以把这个看做数码管的使能端，只有在对应接口输入高电平数码管才能正常工作。 4.4各类指示灯的调试 整个系统里有6个指示灯 alarm（警示灯）、red（红灯）、green（绿灯）、work（输入有效）、sp_success（设置密码成功）、fail（输入密码错误）。这些指示灯的设置一方面是便于用户使用，另一方面也是便于调试。指示灯的调试其实是对不同状态的调试，指示灯不同代表密码锁进入了不同的状态。以下是密码锁的几个主要状态以及对应指示灯的情况：（1）复位状态：密码锁启动后的状态 只有红灯亮；（2）设置或输入密码状态：每输入一个有效密码 work灯闪烁一次；（3）设置密码成功状态：设置密码状态下连续读入4位有效密码 sp_success灯闪烁一次；（4）输入密码错误状态：尝试解锁时输入的4位密码错误 fail灯闪烁一次；（5）解锁成功状态 只有绿灯亮；（6）锁死状态：倒计时结束 alarm灯亮。在调试过程中，经常出现的问题是在控制相应灯亮起的同时会忽略关闭其他指示灯，这会造成很多指示灯同时亮起，导致对状态辨别的困难。例如，一旦输入密码正确，便会进入解锁状态，绿灯亮起，但如果忘记对其他指示灯操作，很有可能红灯也是亮起状态，这就产生了一个没有规定过的状态。如果这时又按下了sp按钮，绿灯就必须立马熄灭，因为进入了设置密码状态。下面这段代码展示的是在解锁后对指示灯的配置。 5.设计结论 我设计的电子密码锁有8个数字输入端，能存储4位密码，可以设置、修改密码，能够用绿灯亮表示密码输入正确，警示灯亮表示锁死。除了基本的功能外，我设计的电子密码锁还加入了一些对用户进行提示的功能。例如，倒计时和输入的密码均可以通过七段数码管显示出来，用户可以时刻了解到剩余的开锁时间、输入的密码；为了防止用户误输了密码，我还增加了清空密码输入的clr按钮，一旦按下就会清空密码输入；当设置密码成功、尝试输入密码错误时均会有相应指示灯亮起，以提示用户。在现有基础上，密码锁还可以实现更多的功能。比如增加密码的位数，又比如在设置密码时也可以清空输入，这些都是密码锁可以优化、改进的地方。 6.设计心得与总结 （1）模块化将整个系统划分成若干子模块是非常重要的。模块化的过程是对整个问题分析、理解的过程，也有助于理清整个问题的实现思路。尽管我最后的代码并没有完全依照模块的划分去实现，但是总的思路偏差不大。除此之外，模块化还有一个好处在于如果想添加新的功能，只需要在相应模块里修改即可，而无需考虑整个代码。（2）加注释在编写一个较为复杂的工程时，及时地添加必要的注释是很重要的。写注释不仅仅是为了让别人看懂你的代码，更重要的是为自己理清思路，也便于后续的修改。对我而言，我不是很擅长变量命名，所以我在每个变量后面都加上了注释，如图所示。这样一来，即使我一时忘记了某个变量的含义，也可以通过查看注释很快回想起来。而在主程序中，也可以在if语句、case语句后加上注释，标明某段代码的功能。（3）仿真文件仿真文件可以帮助我验证某段代码的正确性，但一旦代码过多、输入输出变量个数过多，编写仿真文件反而成了一件麻烦的事情。我采取的方法是只针对子模块编写仿真程序，而不对整个工程编写仿真程序，因为那样做不仅费时费力，而且一旦某个变量出错还难以发现。仿真文件测试通过也不能完全保证代码的正确性。有的问题只有把程序烧到板子上的时候才能发现。比如七段数码管的问题，如果只看仿真波形图的话，不会有一点问题，但是在板子上一测试就会发现数码管是不亮的，这时候才会发现问题所在。在板子上进行测试的另一个好处就是直观，也更容易发现一些隐藏的问题。比如我的密码锁共有6个指示灯，如果只看仿真波形图，很不直观，也很难发现问题，而在板子上一测试就会发现有些指示灯没控制好。 总结 这次的大作业很好的锻炼了我独立完成整个工程的能力。我收获到的不仅是代码的编写、调试能力的提升，还有自信心的提升。在代码的编写方面，我体会到了模块化、添加注释的重要性，其实这些都不会花费很多时间，但如果不去做的话就会给后续的调试带去很大的麻烦。而代码的调试也是很有讲究的，在我看来，编写仿真文件、看仿真波形是粗调，可以大致验证代码的正确性；验证通过后再将代码烧录到板子上细调，如果直接烧到板子上调理论上也可以，不过若代码错误较多，是不方便定位错误的。在自信心方面，这次的大作业对我的自信心是一次很大的提升。刚看到这道题目的时候，我是没有什么思路的。但经过细细分析，将问题逐渐分解，编写子模块的代码，组合代码等一系列过程后，我不但基本上完成了整个电子密码锁程序的编写，而且很有成就感，对于解决类似工程问题的信心增加了。 参考文献 [1]李建军,胡苗苗.基于FPGA的电子密码锁系统的设计[J].智能计算机与应用,2019(02):187-188+192.[2]熊军洲.基于FPGA的电子密码锁控制电路设计[J].石家庄职业技术学院学报,2018(06):11-15.[3]王俊博.关于FPGA的电子密码锁系统的设计[J].科学技术创新,2019(26):89-90.[4]康浩,叶翔,王建国,鄢梦林,杨斐.基于FPGA的智能电子密码锁的设计[J].湖北理工学院学报,2014(03):45-49.[5]肖萌萌.电子密码锁控制电路设计[J].黑龙江科技信息,2017(15):38. 附录 附录一：总体设计图 附录二：各模块仿真截图 以下为各个模块的仿真结果截图。 附录三：组员所做工作说明 所有工作均由本人独立完成。 
第188篇文章[1]
Ubuntu16.04编译安装最新的OpenCV4.4.0 -获取OpenCV源代码 $gitclonehttps://github.com/opencv/opencv.git 当然了，这个命令要想成功执行首先要安装git库，可通过以下命令行安装 $sudoapt-getinstallgit 执行完这条语句后，第一条语句就可以正常执行了，OpenCV也可以安装完成。但是Linux的网速通常比较慢（也取决于自家Wifi），如果以这种方式安装可能要等较长一段时间，还有可能安装失败。这里推荐大家到网上找OpenCV的Linux版本安装包（.tar.gz结尾），可在Windows上下载，再发送到Linux系统上，这样比较快。 -安装依赖库 #安装cmake $sudoapt-getinstall-ycmake #借助系统自带的opencv简化依赖安装步骤 $sudoapt-getinstall-ylibopencv-dev -编译源代码 $cdopencv $mkdirbuild $cdbuild $cmake.. $make-j10 在cmake编译源代码这部分，网上有很多种版本，但我个人觉得上述写法最为简单，且亲测有效。 -替换已经安装的版本 $sudomakeinstall 到此为止，如果执行正常的话，Ubuntu系统配置OpenCV的目标已经实现！ -Ubuntu系统安装Clion 进而，可通过在Ubuntu系统安装Clion、Clion配置OpenCV实现完整的环境搭建。具体教程见以下博客 Clion安装及配置OpenCV 
第189篇文章[1]
Ubuntu16.04双系统安装 1.访问官网下载Ubuntu16.04系统镜像文件 下载地址 2.下载“软碟通”软件，制作系统盘 下载地址（免费下载试用）【制作步骤】 3.磁盘分区，为Ubuntu16.04系统划分存储空间 【分区步骤】：右击计算机 >管理【分区步骤】：右击计算机 >管理 >磁盘管理【分区步骤】：右击计算机 >管理 >磁盘管理 >选择要压缩的盘，右击 >压缩卷【分区步骤】：右击计算机 >管理 >磁盘管理 >选择要压缩的盘，右击 >压缩卷卷 >输入压缩空间量(单位：M，这里压缩50G=51200M）【分区步骤】：右击计算机 >管理 >磁盘管理 >选择要压缩的盘，右击 >压缩卷卷 >输入压缩空间量(单位：M，这里压缩50G=51200M） >压缩后得到50G未分配空间 >分区完成 4.重启电脑，进入BIOS，选择从U盘启动 5.进入系统安装引导 
第190篇文章[3]
python实现 检索任意一个整数在prime()函数生成的素数列表中位置（索引）的功能，并返回该位置的索引值，若该数不存在则返回-1。 题目内容：定义一个prime()函数求整数n以内（不包括n）的所有素数（1不是素数），并返回一个按照升序排列的素数列表。使用递归来实现一个二分查找算法函数bi_search()，该函数实现检索任意一个整数在prime()函数生成的素数列表中位置（索引）的功能，并返回该位置的索引值，若该数不存在则返回-1。 输入格式:第一行为正整数n接下来若干行为待查找的数字，每行输入一个数字 输出格式：每行输出相应的待查找数字的索引值 输入样例：102467 输出样例：0-1-13 importmath importsys defprime(n): list=[] foriinrange(2,n): flag=True forjinrange(2,int(math.sqrt(i))+1): ifi%j==0: flag=False break ifflag: list.append(i) returnlist defsearch(list,x): l=0 r=len(list)-1 whilel<=r: mid=(l+r)//2 iflist[mid]==x: returnmid eliflist[mid]>x: r=mid-1 else: l=mid+1 iflist[l]==x: returnl else: return-1 n=int(input()) result=prime(n) forlineinsys.stdin: num=int(line) ifnum<2ornum>=n:#防止越界 print(-1) else: print(search(result,num)) 
第191篇文章[3]
欧拉图的判定 通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。而具有欧拉回路的无向图称为欧拉图。本文将通过C语言实现欧拉图的判定。用C语言程序完成欧拉图的判定，主要分为两步，分别是：判断每个顶点的度是否为偶数、判断图是否连通。具体代码如下： #include<stdio.h> #include<stdlib.h> #definemaxn500 inta[maxn][maxn]={0},n; voidinput(void);//输入邻接矩阵 intIs_Even(void);//判断是否每个点度数都为偶数 intWarshall(void);//判断是否连通 intmain() { input(); if(Is_Even()&&Warshall())printf("Yes\n");elseprintf("No\n"); return0; } voidinput(void) { inti,j; printf("请输入顶点个数："); scanf("%d",&n); printf("请输入图的邻接矩阵：\n"); for(i=0;i<n;i++) { for(j=0;j<n;j++) { scanf("%d",&a[i][j]); } } } intIs_Even(void) { intcount,i,j; for(i=0;i<n;i++) { count=0; for(j=0;j<n;j++) { count+=a[i][j]; } if(count%2)return0; } return1; } intWarshall(void) { inti,j,k; for(i=0;i<n;i++) for(j=0;j<n;j++) { if(a[j][i]==1) { for(k=0;k<n;k++) a[j][k]=a[j][k]+a[i][k]-a[j][k]*a[i][k]; } } for(i=0;i<n;i++) for(j=0;j<n;j++) if(a[i][j]==0)return0; return1; } 代码下载 
第192篇文章[]
Java防御式拷贝方法小结 为什么要用防御式拷贝 在ADT中，常常会有一些Observer方法，用户可以通过这样的方法查看ADT的一些相关属性。用户在获得相关属性后，可能会对这些属性做一些修改，如果我们直接把ADT中的rep返回给用户，那么用户的修改就有可能对ADT产生巨大影响，从而导致程序出现一些意想不到的错误。而使用防御性拷贝就是为了避免类似情况的出现。 其实，如果从更广义的角度看，不仅仅是出现返回值时有可能出现表示泄露，其实在构造函数里如果对用户输入的对象不进行有效的拷贝，用户之后的修改其实也可能对你设计的ADT产生影响，这时其实也需要进行防御性拷贝。 举例 以下面这个例子为例。 classPoem{ publicStringtitle; publicStringauthor; privateList<String>lines=newArrayList<>(); privateDatedate; //AF:代表一首诗，包含四个属性： //title为诗的题目， //author为诗的作者， //lines为诗的文本行， //date为诗的发表日期 publicPoem(Stringt,Stringa,List<String>l,Dated){ title=t; author=a; lines=l; date=d; } publicvoidaddOneLine(StringnewLine){ lines.add(newLine); } //.. publicList<String>getAllLines(){ returnlines; } } 在这个ADT中实际上是存在着一些表示泄露的风险的。 在构造函数里，直接使用了lines=l;这样的语句，本意试想把输入的List<String>l拷贝给rep里的lines属性。但是由于List是对象数据类型，所以实际上此时l与line指向的是同一个对象，一旦客户端改变l中的值，line也会跟着改变，这样是很危险的。在构造函数里，还出现了date=d;语句。Date是对象数据类型，一旦客户端改变d中的值，date中的值也会跟着改变，这样是很危险的。在getAllLines()方法中，直接把rep中的lines放回给了用户，这样用户可以随意修改返回的List，有可能会改变ADT中的rep，这也违反了表示独立性。 解决：防御式拷贝 关于防御式拷贝，主要的思路就是创建一个跟原来的对象一模一样的对象，并且这个新的对象不会受到原来对象的影响，也就是说它们是完全独立的。这里主要以List和Date这两个典型的mutable类型进行举例。 List 对于List，我们实际想要复制的是整个List里的所有对象，而不是指向这个List的指针。 我们可以遍历原始List，再将List里的所有元素拷贝到新的List中，代码如下。 classTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<>(Arrays.asList("a","b","c")); List<String>copyList=newArrayList<>(); for(inti=0;i<list.size();i++){ copyList.add(list.get(i)); } list.remove(0); System.out.println("list:"+list.toString()); System.out.println("copylist:"+copyList.toString()); } } 最后的运行结果为 list:[b,c]copylist:[a,b,c] 可以看出这里成功实现了元素的拷贝，对原来List的改变不会影响新的List。 但是这样的拷贝略显麻烦，下面的方法要简单一些。 classTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<>(Arrays.asList("a","b","c")); List<String>copyList=newArrayList<>(); copyList.addAll(list); list.remove(0); System.out.println("list:"+list.toString()); System.out.println("copylist:"+copyList.toString()); } } 通过List对象的addAll()方法，实现List中元素的拷贝（俗称“深拷贝”）。 Java中的一些其他的集合类（比如Set，Map等）也可以通过类似的方法实现防御式拷贝，进而避免外来的改变对ADT造成影响。 而在Observer方法中，实际上也需要进行防御式拷贝，这里可以使用上面的方法将rep的拷贝返回给用户，也可以使用Collections.unmodifiableLis()对List对象进行修饰，修饰过的对象是不可变的。 Date Date与List相比就要简单一些了，我们只需要创建一个新的Date对象，保证这个对象的值和原来的对象一样即可。 下面是具体的代码实现。 classTest{ publicstaticvoidmain(String[]args){ Datedate=newDate(); DatecopyDate=newDate(date.getTime()); date.setTime(2000000000); System.out.println("date:"+date.toString()); System.out.println("copydate:"+copyDate.toString()); } } 最后的运行结果为 date:SatJan2411:33:20CST1970copydate:TueJul0616:57:15CST2021 我们成功创建了两个完全独立的Date对象，这正是我们想要的。 对于一些其他的对象，或是通过构造函数，或是通过一些set方法，我们都可以创建一个与原先对象一模一样的对象。 结语 以List和Date为例，本文主要介绍了Java中进行防御式拷贝的一些方法，并且说明了防御式拷贝的必要性。 但是如果返回值本身的就是immutable类型的对象，实际上就不需要防御式拷贝了，因为这样的对象是不允许被改变的。所以，在日后的编程中，如果可以使用immutable类型的对象，就尽量使用，这样可以避免许多与表示泄露有关的麻烦。 
第193篇文章[]
关于boost多线程的小总结 join 一般来说，多线程的各个线程之间往往是相互联系的，一个线程停止，其他进程也没有继续进行下去的必要了。所以，一般只要在一个线程后面加.join()。但这并不是针对所有情况。比方说，如果两个线程之间没有联系，一个线程结束时，另一个线程不一定要同时结束，这样一来就要在两个线程后面都加上.join()。 加锁 一般只在需要处理共享变量的时候加锁。加锁虽然能让线程之间互不影响，但如果加锁覆盖的范围太广，就会减慢整个多线程的速度。有时候，需要进行一些很耗时的操作（比如抓图），但操作的是共享变量，这时候怎么办呢？一个很好的解决方案是先用一个临时变量代替这个共享变量进行抓图，然后再把这个临时变量赋值给共享变量。此时，抓图操作是在加锁之前，赋值操作在加锁之后，而赋值是很快的操作。这样一来，既在使用共享变量时加了锁，又大大加快了程序的运行速度。 结束 一般通过key=cv::waitKey(1)语句等待按“q”进行结束，但这往往只能正常终止当前线程，别的线程是被打断的而不是正常结束。可以在进程中的while循环的条件里写一个开关变量，一旦按下“q”键就修改这个变量的值，让所有进程正常结束。 
第194篇文章[1]
Ubuntu系统安装Clion及Clion配置OpenCV JetBrainsCLion是由JetBrains公司开发的一款跨平台的C++IDE。通过修改CMakeLists.txt文件可以很方便地链接OpenCV库。 -Ubuntu安装Clion 教程 -Clion配置OpenCV 教程 
第195篇文章[3]
杨辉三角形（python） 题目内容：帕斯卡三角形，又称杨辉三角形是二项式系数在三角形中的一种几何排列。帕斯卡三角形通常从第0行开始枚举，并且每一行的数字是上一行相邻两个数字的和。在第0行只写一个数字1，然后构造下一行的元素。将上一行中数字左侧上方和右侧上方的数值相加。如果左侧上方或者右侧上方的数字不存在，用0替代。下面给出6行的帕斯卡三角形：11112113311464115101051编写程序，输入帕斯卡三角形的高度n，然后生成和上面例子一样风格的三角形。 输入格式:一个正整数n 输出格式：相应高度的帕斯卡三角形，两个数字之间有一个空格 输入样例：6 输出样例：11112113311464115101051 importmath defC(m,n): ifm==0orm==n: return1 else: returnmath.factorial(n)//(math.factorial(m)*math.factorial(n-m)) n=int(input()) foriinrange(n): print(''*(n-1-i),end='') forjinrange(i+1): print(C(j,i),end='') print('\n') 
第196篇文章[3]
Python实现 实现逆向最大匹配分词算法，即从右向左扫描，找到最长的词并切分。 题目内容：实现逆向最大匹配分词算法，即从右向左扫描，找到最长的词并切分。如句子“研究生命的起源”，逆向最大匹配分词算法的输出结果为“研究生命的起源”。 输入格式:第一行是以utf-8格式输入的词表，每个词之间以空格分隔。接下来是若干行以utf-8格式输入的中文句子。 输出格式：以utf-8格式输出的逆向最大匹配的分词结果，每个词之间使用空格分隔。每个输入对应一行输出。 输入样例：你我他爱北京天安门研究研究生命生命的起源研究生命的起源我爱北京天安门 输出样例：研究生命的起源我爱北京天安门 注：以下是Python3.8的代码实现，如果要用Py2实现需要作相应修改。 #字典生成 defload_dic(s): words=s.split() word_dic=set() max_length=1 forwordinwords: word_dic.add(word) iflen(word)>max_length: max_length=len(word) returnmax_length,word_dic #逆向最大匹配分词 deffmm_word_seg(sentence,word_dic,max_length): end=len(sentence) words=[] whileend>0: forbegininrange(max(end-max_length,0),end): word=sentence[begin:end] ifwordinword_dicorend==begin+1: words.append(word) break end=begin returnwords max_len,word_dic=load_dic(input()) forlineinsys.stdin: words=fmm_word_seg(line,word_dic,max_len) foriinrange(len(words)-1,0,-1): print(words[i],end='') print(words[0]) 亦可参考博客：中文分词 
第197篇文章[1]
程序人生-Hello’sP2P（哈工大计算机系统大作业） 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190201018 班 级 1936603 学 生 李昆泽 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘要 本文从多个方面详细分析了hello程序在Linux系统下从诞生到执行结束的整个过程，并且结合课本的相关章节，运用相关的操作工具，对hello在整个过程中出现的各种现象、结果进行了分析与测试，力求加深对计算机系统的理解。 关键词：Linux；hello程序；计算机系统 目录 第1章概述1.1Hello简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2在Ubuntu下编译的命令3.3Hello的编译结果解析3.3.1数据3.3.3类型转换3.3.4算术操作3.3.5关系操作3.3.6数组/指针/结构操作3.3.7控制转移3.3.8函数操作 3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令4.3可重定位目标elf格式4.4Hello.o的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式5.4hello的虚拟地址空间5.5链接的重定位过程分析5.6hello的执行流程5.7Hello的动态链接分析5.8本章小结 第6章hello进程管理6.1进程的概念与作用6.2简述壳Shell-bash的作用与处理流程6.3Hello的fork进程创建过程6.4Hello的execve过程6.5Hello的进程执行6.6hello的异常与信号处理6.7本章小结 第7章hello的存储管理7.1hello的存储器地址空间7.2Intel逻辑地址到线性地址的变换-段式管理7.3Hello的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.5三级Cache支持下的物理内存访问7.6hello进程fork时的内存映射7.7hello进程execve时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章hello的IO管理8.1Linux的IO设备管理方法8.2简述UnixIO接口及其函数8.3printf的实现分析8.4getchar的实现分析8.5本章小结 结论附件参考文献 第1章概述 1.1Hello简介 P2P： GCC编译器驱动程序读取源程序文件并把它翻译成一个可执行目标文件。下图展示了编译系统把hello.c的源程序转化为可执行文件hello的完整过程。 在预处理阶段，预处理器cpp读取需要的系统头文件内容，并把它直接插入程序文本中，结果得到hello.i。 在编译阶段，编译器ccl间文本文件hello.i翻译成hello.s，这是一个汇编语言的程序。 在汇编阶段，汇编器as将hello.s翻译成机器语言指令，并将结果保存在目标文件hello.o中，它以可重定位目标程序的格式存储。 在链接阶段，链接器ld需要将一些库函数合并到hello.o的程序中，最终得到hello的可执行文件。 用户在Ubuntushell键入./hello启动此程序，shell调用fork函数为其产生子进程，hello便成为了进程（process）。O2O： OS的进程管理调用fork函数产生子进程，调用execve函数，进行虚拟内存映射（mmp），并为运行的hello分配时间片以执行取指译码流水线等操作；OS的储存管理以及MMU解决VA到PA的转换，cache、TLB、页表等加速访问过程，IO管理与信号处理综合软硬件对信号等进行处理；程序结束时，shell回收hello进程，内核将其所有痕迹从系统中清除。 1.2环境与工具 硬件环境：IntelCorei7-9750HCPU；2.60GHz；8GBRAM软件环境：Windows1064位；Ubuntu16.04LTS64位开发与调试工具：gcc；edb；gdb；objdump；readelf；codeblocks 1.3中间结果 文件名文件作用hello.i预处理器生成的文件，分析预处理器行为hello.s编译器生成的汇编语言程序，分析编译器行为hello.o可重定位目标程序，分析汇编器行为hello可执行目标程序，分析链接器行为hello.elfhello.o的elf格式，分析汇编器和链接器行为hello.asmhello.o的反汇编，主要是为了分析hello.o_hello.elf可执行文件hello的elf格式，作用是重定位过程分析_hello.asm可执行文件hello的反汇编，作用是重定位过程分析 1.4本章小结 本章主要简要介绍了hello程序P2P、020的过程，列出了实验中生成的中间文件，列出了实验使用的软硬件环境、调试工具等等。 第2章预处理 2.1预处理的概念与作用 概念：根据以符号“#”开头的预处理命令，将所需系统头文件的内容插入到程序文本中，它是在编译之前进行的处理。作用：（1）宏定义：将宏名替换为对应文本；（2）文件包含：根据以字符#开头的命令，修改原始的C程序。主要执行的操作是获取所需的系统头文件，并把它直接插入程序文本中,该过程递归进行，及被包含的文件可能还包含其他文件。（3）条件编译：对于满足if条件的代码进行筛选，只有满足的代码才进行编译。 2.2在Ubuntu下预处理的命令 预处理命令：cpphello.c>hello.i 2.3Hello的预处理结果解析 使用notepad++打开hello.i文件，可以发现整个文件已经被扩展成了3127行。而前面的3000多行就是.c文件中包含的头文件，这里体现的就是预处理器根据以字符“#”开头的命令，修改原始的C程序的结果。 2.4本章小结 本章主要介绍了预处理的概念与作用。对hello.c执行预处理的命令，并结合生成的hello.i文件，解析了hello的预处理结果。 预处理过程是后续所有操作的基础，是不可或缺的重要过程。 第3章编译 3.1编译的概念与作用 编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含函数main的定义，这个过程称为编译。 编译的作用就是将高级语言源程序翻译成等价的目标程序，并且进行语法检查、调试措施、修改手段、覆盖处理、目标程序优化等步骤。 3.2在Ubuntu下编译的命令 命令：gcc–Shello.i–ohello.s 3.3Hello的编译结果解析 3.3.1数据 变量（1）全局变量在程序中sleepsecs被声明为int类型全局变量，且已经被赋值。由于.data节存放已经初始化的全局和静态C变量，编译器首先将sleepsecs在.text代码段中声明为全局变量，然后在.data节设置对齐方式（.align）为4字节对齐，设置类型（.type）为对象，设置大小（.size）为4字节，设置为long类型（.long），其值为2，如下图所示。 我们发现全局变量sleepsecs的类型本来是int，却被转化为了long类型。这是因为隐式转换的规则，并且int转化为long不会丢失数据。（2）局部变量 编译器将局部变量存储在寄存器或者栈空间中。在hello.s中编译器将i存储在栈上空间-4(%rbp)中，如下图所示。（3）对于intargc argc是我们main函数的第一个参数。分析.s文件，我们发现argc首先被保存在了寄存器%edi中，又由于argc后续需要参与判断，编译器还将argc赋值给了-20(%rbp)。（4）字符串 从源程序中可以看出，程序中主要出现了两个字符串 “Usage:Hello学号姓名！\n”和“Hello%s%s\n”。argv[]中也保存的是字符串，这个我们在后续分析数组的时候再具体分析。 在hello.s中我们可以看到字符串“\345\255\246\345\217\267\345\247\223\345\220\215\357\274\201”，这些其实是“学号姓名”的UTF-8格式。 我们可以看到，这两个字符串都是在.rodata声明的，如下图所示。常量 这里的常量主要指常数立即数。常数立即数是直接在汇编代码中存在的，以“$+常数”的形式出现在汇编代码中。3.3.2赋值 源程序中的赋值操作主要有：intsleepsecs=2.5、i=0和i++。 对于intsleepsecs=2.5，根据前一部分的分析，sleepsecs是全局变量，并且直接在.data节中就已经将sleepsecs声明为值为2的long类型数据（隐式转换）。 对于i=0。在hello.s文件中是通过汇编语句movl$0,-4(%rbp)将立即数赋值给局部变量i的。这里使用的是“movl”，这是因为局部变量i是int类型的数据，占4个字节，如下图所示。 而对于i++，在汇编代码中是通过语句addl$1,-4(%rbp)实现的，这里-4(%rbp)中保存的是i的值，因此通过addl达到每次循环让i加1的目的。 3.3.3类型转换 源程序中用到的类型转换主要是隐式类型转换，即intsleepsecs=2.5，将浮点数2.5转化为int类型的整数2，然后由于编译器缺省，int类型又被转换为了long类型。 值得注意的是，2.5被隐式转换之后，变成了2而不是3。这是由于当double或float向int进行类型转换的时候，程序遵循向零舍入的原则。 3.3.4算术操作 汇编语言中算术操作的相关指令如下。 具体到我们的源程序中，算术操作有i++（即i=i+1），这个是通过汇编语句addl$1,-4(%rbp)实现的。除此之外，还有汇编语句subq$32,%rsp。这里对栈指针进行减法操作，目的是开辟一段新的栈空间。 3.3.5关系操作 关系操作的主要汇编指令如下。 比较和测试指令不修改任何寄存器的值，只是设置条件码。汇编代码中主要有两处涉及到关系操作，分别是cmpl$3,-20(%rbp)和cmpl$9,-4(%rbp)。 第一处对应的源代码是argc!=3，汇编代码将其优化为如果argc==3则跳转至后续的语句，如下图所示。 第二处对应的源代码是i<10，这里汇编代码将它优化为了i<=9，编译器会计算-4(%rbp)-9，并设置条件码，随之jle语句利用这些条件码，进行相应的跳转处理。 3.3.6数组/指针/结构操作 源代码中出现的数组主要是argv[]，在向main函数传参时，通过movq%rsi,-32(%rbp)进行参数的传递，把argv数组的首地址保存在栈中。 在后面的循环中，读取了argv中的元素，分别读取了argv[1]和argv[2]，这是通过下述汇编代码实现的。 首先将数组的首地址放到%rax中，然后将它加8或者16，分别获取argv[1]和argv[2]的地址（argv中保存的是指针，占8个字节），然后再通过movq(%rax),%rdx的方式将%rax里保存的地址处的值转移到%rdx中。 3.3.7控制转移 控制转移常常是配合指令CMP和TEST存在的。汇编代码中有两处出现了控制转移。第一处如下图所示。 这里对应的是源代码中的argc!=3，但编译器把它优化为了如果argc==3，则跳转至.L2。 第二处如下图所示。 这里能很明显的看出是一个循环，体现了编译器一种jumptomiddle的翻译方法，-4(%rbp)保存的是i的值，如果i<=9就跳转到.L4，执行循环，否则就执行后面的语句。 3.3.8函数操作 （1）main函数函数调用：main函数被系统启动函数__libc_start_main调用，call指令将下一个指令的地址压入栈中，然后跳转到main执行。参数传递：向main函数传递的参数是argc和argv，分别使用%rdi（%edi）和%rsi存储。函数返回：函数设置%eax为0后就正常退出，使用leave退出。（2）printf函数第一次函数调用：printf函数在具体的汇编代码中被优化为puts函数。第一次参数传递：首先将rdi赋值为字符串“Usage:Hello学号姓名！\n”字符串的首地址（leaq.LC0(%rip),%rdi），然后调用了puts函数，将字符串参数传入。第二次函数调用：这次是直接调用printf函数。第二次参数传递：这次需要传递3个参数，%rdi保存的是“Hello%s%s\n”的首地址，%rsi保存的是argv[1]，%rdx保存的是argv[2]。（3）sleep函数函数调用：通过汇编语句callsleep@PLT调用。参数传递：传入参数的过程为movlsleepsecs(%rip),%eax和movl%eax,%edi，对应于全局变量sleepsecs。（4）getchar函数函数调用：通过汇编语句callgetchar@PLT调用。（5）exit函数函数调用：通过汇编语句callexit@PLT调用。参数传递：通过汇编语句movl$1，%edi将%edi寄存器内容设置为1。 3.4本章小结 本章首先介绍了编译的概念与作用，以及在Ubuntu下编译的指令，然后我们具体到对hello.s文件进行数据、赋值、类型转换、算术操作、关系操作、数组/指针/结构操作以及控制转移和函数操作进行了详细的分析和研究。 第4章汇编 4.1汇编的概念与作用 概念：汇编器（as）将.s汇编程序翻译成机器语言，把这些机器语言指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，这个过程就叫做汇编。作用：汇编的作用就是将高级语言转化为机器可直接识别执行的机器指令代码文件。 4.2在Ubuntu下汇编的命令 汇编的命令：ashello.s-ohello.o 4.3可重定位目标elf格式 键入命令行readelf-ahello.o>hello.elf将elf可重定位目标文件输出定向到文本文件hello.elf中，如下图所示。 ELF格式的可执行目标文件的各类信息如下： ELF头：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型（如x86-64）、节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量。具体截图如下。 .text：已编译程序的机器代码； .rodata：只读数据，比如printf语句中的格式串和开关语句的跳转表； .data：已初始化的全局和静态C变量（局部C变量在运行时保存在栈中）； .bss：未初始化的全局和静态C变量以及所有被初始化为0的全局和静态变量（不占据实际空间）； .symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息，截图如下。 .rel.text：一个.text节中位置的列表，链接器链接时会修改位置，具体截图如下。 该节包括的内容是：偏移量、信息、类型、符号值、符号名称和加数。 其中，偏移量表示需要进行重定向的代码在.text或.data节中的偏移位置；信息包括symbol和type两部分，其中symbol占前4个字节，type占后4个字节，symbol代表重定位到的目标在.symtab中的偏移量，type代表重定位的类型；符号名称是重定位目标的名字；最后的加数表示重定位过程需要加减的常量。 .rel.data：被模块引用或定位的重定位信息（需要被修改）； .debug：一个调试符号表，其条目时程序中定义的全局变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件； .line：原始C源程序的行号和.text节中机器指令之间的映射； .strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。 节头部表：节头表包括节名称，节的类型，节的属性（读写权限），节在ELF文件中所占的长度以及节的对齐方式和偏移量，具体如下图所示。 4.4Hello.o的结果解析 命令行输入：objdump-dhello.o>hello.asm 机器语言指的是二进制的机器指令集合，而机器指令是由操作码和操作数构成的。汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式。 除此之外，还有如下几个具体的区别：（1）分支转移 hello.s文件中分支转移是使用段名称进行跳转的（见图22），而hello.o文件中分支转移是通过地址（重定位地址）进行跳转的（见图23）。（2）函数调用 hello.s文件中，函数调用call后跟的是函数名称（见图24）；而在hello.o文件中，因为这些函数都是共享库函数，它们的地址是不确定的，因此call指令将相对地址全部设置为0，然后在.rela.text节中为其添加重定位条目，等待链接的进一步确定（见图25）。（3）全局变量 hello.s文件中，全局变量的地址是通过段地址+%rip确定的（见图26）；对于hello.o的反汇编来说，则是0+%rip，因为.rodata节中的数据是在运行时确定的，也需要重定位，现在填0占位，并为其在.rela.text节中添加重定位条目（见图27）。 4.5本章小结 本章讨论了从hello.s到hello.o的汇编过程，通过readelf命令查看了可重定位目标elf格式。除此之外，使用了objdump工具得到了hello.o的反汇编代码，并和hello.s进行比较，从而更深刻地理解汇编这一过程。 第5章链接 5.1链接的概念与作用 概念： 链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。作用： 链接使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，我们可以独立的修改和编译那些更小的模块，这也更便于我们维护管理我们的代码。 5.2在Ubuntu下链接的命令 链接命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o或gcchello.o-ohello截图如下。 5.3可执行目标文件hello的格式 输入命令：readelf-ahello>_hello.elf，截图如下。 节头部表截图如下图所示。 5.4hello的虚拟地址空间 使用edb加载hello，通过观察edb的Symbols小窗口，我们发现从虚拟地址从0x400000开始和5.3节中的节头表几乎是一一对应的，如下图所示。 5.5链接的重定位过程分析 命令行：objdump-d-rhello 反汇编截图如下。 下面是对hello.o和hello反汇编后结果的一些对比。（1）_hello.asm比hello.asm多了许多文件节 在hello.asm文件中，我们发现只有.text节。而在_hello.asm（hello的反汇编结果）中，不仅有很多其他的节（例如.init节，.plt节等），而且.text节中的内容也比之前有所增加。（2）hello.asm中的大多是相对偏移地址，而_hello.asm文件中的地址是虚拟地址 在原来的hello.o的反汇编文件中，所用的地址基本上是相对偏移地址。例如把main函数的地址设置为0，其他函数或者跳转在计算地址时都是在此基础上加一个相对偏移量。 而在_hello.asm文件中，由于hello已经是可执行文件了，相关的重定位工作必须已经完成，所有虚拟地址也必须确定。尽管每次链接时动态库的虚拟地址都可能不同，但是当每次链接完成时，所有虚拟地址是唯一确定的。（3）_hello.asm中增加了许多外部链接的共享库函数 链接过程本身就是要把一些外部已经编译好的共享库添加到可执行文件中，所以在反汇编文件中出现这些共享库函数一点都不奇怪，截图如下所示。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。重定位分析： 当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置，它也不知道这个模块引用的外部函数或者全局变量的位置。所以针对最终位置未知的目标引用，它会生成一个重定位条目，告诉链接器在生成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。在把hello.o链接为可执行文件hello的过程中，链接器就是根据.rel_data和.rel_text节中保存的重定位信息对符号或者函数进行重定位的。具体的重定位过程我通过下面的一个例子给出。 以sleepsecs为例，通过查看.rela.text中的重定位信息，我们得到有关sleepsecs的重定位条目如下： r.offset=0x60 r.symbol=sleepsecs r.type=R_X86_64_PC32 r.addend=-4 这些字段告诉链接器修改开始于偏移量0x60处的32位PC相对引用，这样在运行时它会指向sleepsecs变量。对应的重定位算法如下图所示。 下面我们来手动模拟一下计算出sleepsecs虚拟地址的过程。 由于ADDR(s)=ADDR(main)=0x400627，r.offset=0x60， 所以refaddr=ADDR(s)+r.offset=0x4005B0； 又由于ADDR(r.symbol)=0x601058，r.addend=-0x4， 所以*refptr=ADDR(r.symbol)+r.addend–refaddr=0x2009CD 通过如下截图可验证算法的正确性。 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。（1）终端输入：./hello 子程序名程序地址ld-2.23.so!_dl_start0x7f9fb3c11c33ld-2.23.so!_dl_init0x7f9fb3c11c65hello!__libc_start_main@plt0x400574hello!puts@plt0x400643hello!exit@plt0x40064d （2）终端输入：./hello1190201018李昆泽 子程序名程序地址ld-2.23.so!_dl_start0x7fd2a03bcc33ld-2.23.so!_dl_init0x7fd2a03bcc65hello!__libc_start_main@plt0x400574hello!printf@plt（循环调用了10次）0x400680hello!sleep@plt（循环调用了10次）0x40068dhello!getchar@plt0x40069c 5.7Hello的动态链接分析 对于动态共享链接库中位置无关代码，编译器没有办法预测函数的运行时地址，所以需要添加重定位记录，等待动态链接器处理。 在dl_init之前，为了引用全集变量PIC，编译器利用了数据段与代码段的距离是一个运行时常量的事实，在数据段开始的地方创建了全局偏移量表GOT。每个被这个目标模块引用的全局数据目标都有一个8字节条目，还会生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含正确的绝对地址。 在之后的函数调用时，首先跳转到PLT执行.plt中操作，第一次访问跳转时，GOT地址为下一条指令，将函数序号压栈，然后跳转到PLT[0]，在PLT[0]中将重定位表地址压栈，然后访问动态链接器，在动态链接器中使用函数序号和重定位表确定函数运行时地址，重写GOT，再将控制传递给目标函数。之后如果对同样函数调用，第一次访问跳转直接跳转到目标函数。 5.8本章小结 本章首先介绍了链接的概念及作用，以及在linux下链接的命令行；接着对hello的elf格式进行了较为详细的分析，并分析了hello的虚拟地址空间；关于重定位过程的分析，本章通过对比hello和hello.o的反汇编文件，发现了它们之间的差异，了解了重定位在链接和汇编过程中的不同；除此之外，也对整个hello的执行过程进行了跟踪，在最后对hello进行了动态链接分析。 第6章hello进程管理 6.1进程的概念与作用 概念：狭义定义：进程是计算机科学中最深刻，最成功的概念之一。进程的经典定义就是一个执行中程序的实例，进程拥有一个独立的逻辑控制流和私有的地址空间。广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。作用： 在现代计算机中，进程为用户提供了以下假象：我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 作用： Shell是用户与操作系统之间完成交互式操作的一个接口程序，它为用户提供简化了的操作。Shell最重要的功能是命令解释，从这种意义上说，Shell是一个命令解释器。Linux系统上的所有可执行文件都可以作为Shell命令来执行。当用户提交了一个命令后，Shell首先判断它是否为内置命令，如果是就通过Shell内部的解释器将其解释为系统功能调用并转交给内核执行；若是外部命令或实用程序就试图在硬盘中查找该命令并将其调入内存，再将其解释为系统功能调用并转交给内核执行。在查找该命令时分为两种情况：（1）用户给出了命令的路径，Shell就沿着用户给出的路径进行查找，若找到则调入内存，若没找到则输出提示信息；（2）用户没有给出命令的路径，Shell就在环境变量PATH所制定的路径中依次进行查找，若找到则调入内存，若没找到则输出提示信息。处理流程： Shell从终端读入输入命令。如果是内置命令则立即执行。否则调用相应的程序为其分配子进程并运行。总之就是对其求值。1．Shell首先从命令行中找出特殊字符（元字符），在将元字符翻译成间隔符号。元字符将命令行划分成小块tokens。Shell中的元字符如下所示：SPACE,TAB,NEWLINE,&,;,(,),<,>,|2．程序块tokens被处理，检查看他们是否是shell中所引用到的关键字。3．当程序块tokens被确定以后，shell根据aliases文件中的列表来检查命令的第一个单词。如果这个单词出现在aliases表中，执行替换操作并且处理过程回到第一步重新分割程序块tokens。4．Shell对~符号进行替换。5．Shell对所有前面带有$符号的变量进行替换。6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用$(command)标记法。7．Shell计算采用$(expression)标记的算术表达式。8．Shell将命令字符串重新划分为新的块tokens。这次划分的依据是栏位分割符号，称为IFS。缺省的IFS变量包含有：SPACE,TAB和换行符号。9．Shell执行通配符*?[]的替换。10．shell把所有從處理的結果中用到的注释删除，並且按照下面的顺序实行命令的检查：A.内建的命令B.shell函数（由用户自己定义的）C.可执行的脚本文件（需要寻找文件和PATH路径）11．在执行前的最后一步是初始化所有的输入输出重定向。12．最后，执行命令。 6.3Hello的fork进程创建过程 父进程通过调用fork函数就创建一个新的运行的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈.子进程进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。其函数原型为pid_tfork(void)；对于返回值，若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1。 而对于hello来说，我们想要运行hello这个可执行文件时，需要在终端输入命令（例如./hello），我们输入的命令会被判断为非内置命令，然后shell试图在硬盘上查找该命令（即hello可执行程序），并将其调入内存，然后shell将其解释为系统功能调用并转交给内核执行。 shell执行fork函数，创建一个子进程。这时候我们的hello程序就开始运行了。hello子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。于此同时Linux将复制父进程的地址空间给子进程，因此，hello进程就有了独立的地址空间。 6.4Hello的execve过程 execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有当出现错误时，（例如找不到filename时），execve才会返回到调用程序。所以，与fork一次调用返回两次不同，execve调用一次并从不返回。 execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行程序，加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。最后加载器设置PC指向_start地址，_start最终调用main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制。这时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 对于hello来说，execve首先在当前进程的上下文中加载并运行新程序hello，然后调用启动代码，启动代码设置栈，并将控制传递给新程序的主函数，该函数有以下原型：intmain(intargv,char**argv,char**envp)或者等价的intmain(intargc,char*argv[],char*envp)。 当主函数开始执行时，用户栈的组织结构如下图所示。从栈底往栈顶看，首先是参数和环境字符串。紧随其后的是以null结尾的指针数组，其中每个指针都指向栈中的一个环境变量字符串。全局变量environ指向这些指针中的第一个envp[0]。紧随环境变量之后的是以null结尾的argv[]数组，其中每个元素都指向栈中的一个参数字符串。在栈的顶部是系统启动函数libc_start_main的栈帧。 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占进程所需的状态。它包含进程运行所需要的一些寄存器、用户栈以及数据结构等等。在内核调度了一个新的进程运行时，它会首先保存当前进程的上下文，然后恢复某个先前被强占的进程被保存的上下文，最后将控制传递给这个新恢复的进程。 调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被强占的进程。这种决策就叫调度（是由内核中的调度器的代码处理的）。在调度的过程中，可能会出现多个进程轮流运行的情况，这个概念就称为多任务，而多任务也叫做时间分片。用户态与核心态转换： 进程hello一开始运行在用户模式中，直到它通过执行系统调用函数sleep或者exit时便进入到内核模式。由于sleep函数的特殊性，内核此时可能会将hello进程休眠，转而执行一个其他的进程。待内核中的处理程序完成对系统函数的调用后，再执行上下文切换，将控制返回给进程hello系统调用之后的那条语句。 6.6hello的异常与信号处理 异常可以分为四类：中断、陷阱、故障和终止。下图对这些类别的属性做了小结。 而在hello的执行过程中，主要会遇到中断（键盘上敲击CTRL-C或者CTRL-Z）和陷阱（系统调用）的异常； 主要会产生SIGINT（来自键盘的中断），SIGSTP（来自终端的停止信号）等信号； 对于中断异常，处理情况如图； 对于陷阱，处理情况如图。运行截图（1）CTRL-Z（2）ps（3）jobs（4）pstree（5）fg（6）kill（7）输入乱码（8）CTRL-C异常与信号的处理 对于CTRL-C或者CTRL-Z，键盘键入后，内核就会发送SIGINT或者SIGSTP信号。SIGINT信号默认终止前台作业，即终止程序hello，SIGSTP默认挂起前台的hello作业。 对于fg信号，内核发送SIGCONT信号，我们刚刚挂起的程序hello重新在前台运行。 对于kill-93381。内核发送SIGKILL信号给我们指定的pid（hello程序），结果杀死了hello程序。 6.7本章小结 在本章中，首先简单介绍了进程的概念和作用，并在此基础上简述了壳Shell-bash的作用与处理流程。然后对可执行文件hello进行了具体的分析，分别分析了hello的fork过程、execve过程、进程执行过程，最后分析了hello在执行过程中可能遇到的异常和信号处理，并进行了测试。 第7章hello的存储管理 7.1hello的存储器地址空间 （1）逻辑地址 逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址，是由一个段标识符加上一个指定段内相对地址的偏移量。（2）线性地址 线性地址是逻辑地址到物理地址变换之间的中间层。hello程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。（3）虚拟地址 虚拟地址是程序运行在保护模式下，程序访问存储器所使用的逻辑地址称为虚拟地址。在保护模式中，在程序从磁盘加载进内存的中间加了一个中间层，即就是虚拟地址，在程序编译，链接的时候先映射进虚拟地址，在运行的时候会再映射进物理地址。这样的好处在于，在虚拟地址中，hello程序的虚拟地址，不管通过如何偏移，它都在虚拟地址中，最后再映射进物理地址，不会影响到其他的程序，起到了进程隔离，保护了其他的进程。（4）物理地址 物理地址用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。这个概念应该是这几个概念中最好理解的一个，但是值得一提的是，虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽象，内存的寻址方式并不是这样。另外，如果启用了分页机制，那么hello的线性地址会使用页目录和页表中的项变换成hello的物理地址；如果没有启用分页机制，那么hello的线性地址就直接成为物理地址了。 7.2Intel逻辑地址到线性地址的变换-段式管理 分段过程实质就是从逻辑地址到线性地址的过程。整个过程如下图所示。 逻辑地址实际是由48位组成的，前16位是段选择符，后32位是段内偏移量。通过段选择符，我们可以获得段基址，再与段内偏移量相加，即可获得最终的线性地址。 段选择符的16位格式如下图所示。其中， 索引：“描述符表”的索引； TI：如果TI是0，那么描述符表是全局描述符表（GDT）；如果TI是1，描述符表是局部描述表（LDT）。 RPL：表示段的级别。为0，位于最高级别的内核态；为11，位于最低级别的用户态。在linux中也仅有这两种级别。 被选中的段描述符先被送至描述符的cache中，每次从描述符cache中取出32位段基址，再与32位段内偏移量（有效地址）相加得到线性地址，截图如下。 7.3Hello的线性地址到物理地址的变换-页式管理 如果不考虑TLB与多级页表，虚拟地址可以分为虚拟页号VPN和虚拟页偏移量VPO。其中，VPN可以作为到页表中的索引。进而，通过页表基址寄存器（PTBR）我们可以在页表中获得条目PTE。一条PTE中包含有效位和物理页号（PPN）。如果有效位是0，则代表页面不在存储器中（缺页）；如果有效位是1，则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，再与物理页偏移量（PPO）共同构成物理地址PA。具体截图如下。 注意，因为物理和虚拟页面都是P字节的，所以PPO和VPO是相同的。 当页面命中时CPU硬件执行的步骤： 第1步：处理器生成一个虚拟地址，并把它传送给MMU； 第2步：MMU生成PTE地址，并从高速缓存/主存请求得到它； 第3步：高速缓存/主存向MMU返回PTE； 第4步：MMU构造物理地址，并把它传送给高速缓存/主存； 第5步：高速缓存/主存返回所请求的数据字给处理器。 7.4TLB与四级页表支持下的VA到PA的变换 TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块，TLB通常具有高度的相联度。 用以组选择和行匹配的索引和标记字段是从虚拟地址的虚拟页号中提取出来的，在TLB中寻址的过程其实和在cache中寻址的过程有点类似。下图展示了当TLB命中时（通常情况）所包括的步骤，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。 第1步：CPU产生一个虚拟地址； 第2步和第3步：MMU从TLB中取出相应的PTE； 第4步：MMU将这个虚拟地址翻译成一个物理地址，并将它发送到高速缓存/主存； 第5步：高速缓存/主存将所请求的数据字返回给CPU。四级页表： 使用层次结构的页表是为了压缩页表所占的空间。 在Corei7MMU中，36位VPN被划分成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 7.5三级Cache支持下的物理内存访问 通过上一节中的页表翻译，我们终于得到了物理地址PA，下面我们的工作时利用物理地址寻找相应的数据。 首先使用物理地址的CI进行组索引（每组8路），对8个块分别对CT进行标志位的匹配。如果匹配成功且块的有效位为1，则成功命中。然后根据数据偏移量CO取出相应的数据并返回。这里的数据是保存在L1中的，也就是一级Cache。 如果没有命中，或者没找到相匹配的标志位，那么就会在下一级Cache中寻找，这里可能是二级Cache甚至三级Cache，只要本级Cache中没找到就要去下一级的Cache中寻找数据，然后逐级写入Cache。 在更新Cache的时候，首先需要判断是否有有效位为0的块。若有，则直接写入；若不存在，则需要驱逐一个块（LRU策略），再进行写入。 7.6hello进程fork时的内存映射 虚拟内存和内存映射解释了fork函数如何为hello进程提供私有的虚拟地址空间。 当fork函数被hello进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello创建出的这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 在fork在新进程中返回时，新进程的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任意一个进行写操作时，由于写时复制机制的作用，会创建一个新的页面，也就为每个进程保持了私有地址空间的概念。 7.7hello进程execve时的内存映射 虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。假设运行在当前进程中的程序执行了如下的execve调用： execve(“hello”,NULL,NULL); 加载并运行hello需要以下的几个步骤：（1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。（2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆地址也是请求二进制零的，初始长度为零。（3）映射共享区域。hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。（4）设置程序计数器（PC）。execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，他将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 7.8缺页故障与缺页中断处理 处理缺页要求硬件和操作系统内核协作完成，具体操作如下。 第1步：处理器生成一个虚拟地址，并把它传送给MMU； 第2步：MMU生成PTE地址，并从高速缓存/主存请求得到它； 第3步：高速缓存/主存向MMU返回PTE； 第4步：PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序； 第5步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘； 第6步：缺页处理程序页面调人新的页面，并更新内存中的PTE； 第7步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令，CPU将地址重新发送给MMU。因为虚拟页面现在已经缓存在物理内存中，所以会命中，主存将所请求字返回给处理器。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器(explicitallocator)，要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。C++中的new和delete操作符与C中的malloc和free相当。 隐式分配器(implicitallocator)，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器(garbagecollector)，而自动释放未使用的已分配的块的过程叫做垃圾收集(garbagecollection)。例如，诸如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 显式分配器必须在严格的约束条件下工作，约束有：必须处理任意请求序列；立即响应请求；只使用堆；对齐块；不修改已分配的块。分配器的编写应该实现：吞吐率最大化；内存使用率最大化（两者相互冲突）。 在分配器的具体实现中，主要有以下几种实现方法：（1）隐式空闲链表 隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要求对空闲链表进行搜索，该搜索时间与堆中已分配块和空闲块的总数呈线性关系。（2）带边界标记的隐式空闲链表 这种方式可以允许在常数时间进行对前面块的合并，并且它对许多不同类型的分配器和空闲链表组织都是通用的。然而它也存在一个潜在的缺陷。它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销。（3）显式空闲链表 堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。这样一来，会使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。显式空闲链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。 7.10本章小结 本章就hello的地址管理展开了一系列讨论。首先介绍了各类地址的概念以及在程序运行中充当的角色，接着进一步分析了从逻辑地址到线性地址的变化（段式管理），以及从线性地址到物理地址的变化（页式管理）。然后借TLB与四级页表支持下的VA到PA的变换详细分析了地址翻译的过程。紧接着分析了三级Cache支持下的物理内存访问，以及hello进程fork和execve时的内存映射，还有缺页故障与缺页中断处理的操作过程。最后通过动态存储分配管理这一节对之前的内容进行了一个整体的梳理，较为完整地阐明了动态内存分配的过程。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，所有的输入输出都被当作对相应文件的读和写来执行。设备管理：unixio接口 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 UnixI/O接口（1）打开文件 一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息，应用程序只需要记住这个描述符。（2）linuxshell 创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO、STOOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值。（3）改变当前的文件位置 对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。（4）读写文件 一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。（5）关闭文件 当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。函数（1）打开文件 函数原型：intopen(char*filename,intflags,mode_tmode); open函数将filename转换为一个文件描述符，并且返回描述符数字。flags参数指明了进程打算如何访问这个文件，mode参数则指定了新文件的访问权限位。（2）关闭文件 函数原型：intclose(intfd); 关闭描述符为fd的文件，关闭一个已关闭的描述符会出错。（3）读和写文件 函数原型： ssize_tread(intfd,void*buf,size_tn); ssize_twrite(intfd,constvoid*buf,size_tn); read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。返回值：成功则返回写的字节数，出错则为-1。 8.3printf的实现分析 我们先来看printf的源码： 这里va_list是char类型的指针，表示arg是…中的第一个参数的地址。另外，我们发现在printf函数里分别调用了vsprintf和write函数，下面对这两个函数一一分析。 很容易看出，vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 我们发现vsprintf函数中也调用了write函数，下面我们来追踪一下write函数的汇编代码。 在write函数中，将栈中参数放入寄存器，ecx存放字符个数，ebx存放第一个字符地址，intINT_VECTOR_SYS_CALLA代表通过系统调用sys_call。从这里我们也可以看出write是一个系统函数。下面是sys_call的汇编代码。 sys_call函数实现的功能就是把将要输出的字符串从总线复制到显卡的显存中。显存中存储的是字符的ASCII码。字符显示驱动子程序通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。至此，就完成了对printf函数的分析，也完成了字符串的整个输出过程。 8.4getchar的实现分析 （1）当运行到getchar函数时，程序将控制权交给os。在进行输入时，内容会先进入缓存区，并在屏幕上回显。直到我们键入Enter，通知os输入完成，这时才再将控制权交还给程序。（2）异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。（3）getchar调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章介绍了Linux的I/O设备管理方法，简述了UnixIO接口及其函数，并对printf和getchar的实现进行了较为具体的分析。 结论 hello所经历的过程：（1）编写阶段，通过编写工具编写出hello.c；（2）预处理阶段，预处理器cpp读取需要的系统头文件内容，并把它直接插入程序文本中，结果得到hello.i；（3）编译阶段，编译器ccl间文本文件hello.i翻译成hello.s；（4）汇编阶段，汇编器as将hello.s翻译成机器语言指令，并将结果保存在目标文件hello.o中；（5）链接阶段，链接器ld需要将一些库函数合并到hello.o的程序中，最终得到hello的可执行文件；（6）运行阶段：用户在Ubuntushell键入./hello启动此程序，shell调用fork函数为其产生子进程，并由execve函数加载运行当前进程的上下文中加载并运行新程序hello；（7）进程执行：内核为每个进程维持一个上下文，在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被强占的进程。所以hello进程不是一直在执行的；（8）存储管理：在hello所经历的过程中，会产生各种地址，但最终我们真正期待的是物理地址，MMU将程序中使用的虚拟内存地址通过页表映射成物理地址；（9）信号与异常：在hello的运行过程中可能会出现各种信号或者异常，内核会对这些信号进行处理；（10）结束：hello最终被shell父进程回收，内核会收回为其创建的所有信息。感悟： 这本教材的名字叫《深入理解计算机系统》，而我才刚刚入了门，远远谈不上是“深入理解”。但是仅凭目前这一点对计算机系统的初步认识，我就已经觉得这是一个无比复杂，同时也无比精妙的系统。计算机是由很多部分组成的，这些部分既有明确的分工，又相互合作，最终成就了现在的计算机。这些部分在现在看来合情合理，但是在第一台计算机出现之前，没有人知道计算机应该由哪些部分组成，应该怎样去计算。 计算机系统这门课的学问很深，其中包含的是一代代计算机科学家的心血，这些不是仅仅通过这一门课所能够学完的，我们还需要在以后的实践中沉下心来，细细研究其中的学问。 附件 文件名文件作用hello.i预处理器生成的文件，分析预处理器行为hello.s编译器生成的汇编语言程序，分析编译器行为hello.o可重定位目标程序，分析汇编器行为hello可执行目标程序，分析链接器行为hello.elfhello.o的elf格式，分析汇编器和链接器行为hello.asmhello.o的反汇编，主要是为了分析hello.o_hello.elf可执行文件hello的elf格式，作用是重定位过程分析_hello.asm可执行文件hello的反汇编，作用是重定位过程分析 参考文献 [1]RandalE.Bryant,DavidR.O’Hallaon.深入理解计算机系统.第三版.北京：机械工业出版社[M].2018：1-737.[2]伍之昂.LinuxShell编程从初学到精通.北京：电子工业出版社.2011：1-59.[3]Cjacker.CmakePractice.1-47.[4]yjbjingcha.进程控制在进程管理中的作用.https://www.cnblogs.com/yjbjingcha/p/7040290.html.[5]madao756.段页式访存 逻辑地址到线性地址的转换.https://www.jianshu.com/p/fd2611cc808e.[6]madao756.段页式访存 线性地址到物理地址的转换.https://www.jianshu.com/p/c78cdf6214b5.[7]Pianistx.printf函数实现的深入剖析.https://www.cnblogs.com/pianist/p/3315801.html 
第198篇文章[3]
Python实现 若已知1800年1月1日为星期3，则对于一个给定的年份和月份，输出这个月的最后一天是星期几。 题目内容：若已知1800年1月1日为星期3，则对于一个给定的年份和月份，输出这个月的最后一天是星期几。 输入格式:两行整数，分别代表年份和月份 输出格式：星期数，0代表星期日 输入样例：203312 输出样例：6 defIs_leap_year(year): ifyear%400==0oryear%4==0andyear%100!=0: returnTrue else: returnFalse defDays_in_months(year,month): ifmonthin(1,3,5,7,8,10,12): return31 elifmonthin(4,6,9,11): return30 elifIs_leap_year(year): return29 else: return28 defTotal_days(year,month): days=0 foryinrange(1800,year): ifIs_leap_year(y): days+=366 days%=7 else: days+=365 days%=7 forminrange(1,month+1): days+=Days_in_months(year,m) days%=7 return(days+2)%7 year=int(input()) month=int(input()) print(Total_days(year,month)) 
第199篇文章[8]
学生成绩管理系统（C语言大作业） 设计一个学生成绩管理系统，包括学生成绩数据的增删改查等基本操作，通过编程实现如下菜单驱动的学生成绩管理系统：（1）录入每个学生的学号、姓名和各科考试成绩；（2）计算每门课程的总分和平均分；（3）计算每个学生的总分和平均分；（4）按每个学生的总分由高到低排出名次表；（5）按每个学生的总分由低到高排出名次表；（6）按学号由小到大排出成绩表；（7）按姓名的字典顺序排出成绩表；（8）按学号查询学生排名及其考试成绩；（9）按姓名查询学生排名及其考试成绩；（10）按优秀（90-100）、良好（80-89）、中等（70-79）、及格（60-69）、不及格（0-59）5个类别，对每门课程分别统计每个类别的人数以及所占的百分比；（11）输出每个学生的学号、姓名、各科考试成绩，以及每门课程的总分和平均分；（12）将每个学生的记录信息写入文件；（13）从文件中读出每个学生的记录信息并显示。 输入 首先，用户输入菜单选项（自然数0-13），程序会对非法输入进行判断，并提示用户重新输入。另外，当用户输入0-13中的某个数时，未必都是合法的。例如在输入1或13之前输入其他数字，即在录入成绩之前进行其他操作。程序亦会对此类非法输入进行判断并提示重新输入。 程序支持用户先后输入多个菜单选项，程序会在完成当前菜单选项的任务之后再次在屏幕上打印出菜单，以供用户再次选择，直至用户输入0终止程序。 为了节省空间，程序会采用动态分配内存的方式，这也就要求程序必须预先知道所需空间的大小。为了达到这一目的，在录入成绩时，程序会提示用户输入学生人数、课程门数（均为整型）以确定所需空间大小。 进而，在录入成绩的时候会涉及到不同类型的变量（学号（长整型）、姓名（字符串）、成绩（整型））。程序会提供表头，用户只需对应表头输入相应信息即可。在这里，程序默认输入的学生姓名无空格。 除此之外，用户无需输入大量数据，在个别菜单选项中，用户只需根据提示信息输入少量数据即可。若输入数据不合法，程序亦会提示用户重新输入。并且，程序中加入了对文件打开失败、动态内存分配不成功等异常情况的处理，以增强程序的健壮性。 输出 考虑到表格更直观，可读性更好，程序的输出主要以表格的形式。 另外，由于每次录入的学生学号、姓名长度会有所不同，程序中加入了对它们长度的判断，以较为对齐的方式输出表格，让用户阅读时更为舒适且不易出错。 当然，对于一些重要信息（例如学生的排名）程序是换行单独输出的，这样的考虑是为了让用户能更清楚地了解到一些重要信息。 代码 代码下载 #include<stdio.h> #include<stdlib.h> #include<string.h> #include"windows.h" intNumOfStudent,NumOfCourse,flag,*Total; typedefstructstudent { longintnum; charname[100]; intscore[10]; intrank; }STUDENT; STUDENT*stu; voidMenu();//函数、变量声明 intInput_Choice(); voidTable_Head(); voidData(); intLegal_Input(); voidInput_Data(); voidCourse_Score(STUDENTstu[]); voidStudent_Score(STUDENTstu[]); voidDownSort(int*Total); voidUpSort(int*Total); voidID_Sort(STUDENTstu[]); voidName_Sort(STUDENTstu[]); voidQuickSort(inta[],STUDENTb[],intlow,inthigh); voidswap(inta[],STUDENTb[],intlow,inthigh); intpartion(inta[],STUDENTb[],intlow,inthigh); voidSearch_Number(); voidSearch_Name(); voidStatistic(); voidOutput_Data(); voidwfile(); voidrfile(); voidMenu()//显示菜单 { printf("1.Inputrecord\n"); printf("2.Calculatetotalandaveragescoreofeverycourse\n"); printf("3.Calculatetotalandaveragescoreofeverystudent\n"); printf("4.Sortindescendingorderbytotalscoreofeverystudent\n"); printf("5.Sortinascendingorderbytotalscoreofeverystudent\n"); printf("6.Sortinascendingorderbynumber\n"); printf("7.Sortindictionaryorderbyname\n"); printf("8.Searchbynumber\n"); printf("9.Searchbyname\n"); printf("10.Statisticanalysisforeverycourse\n"); printf("11.Listrecord\n"); printf("12.Writetoafile\n"); printf("13.Readfromafile\n"); printf("0.Exit\n"); printf("Pleaseenteryourchoice:\n"); } intInput_Choice()//输入菜单选项 { intchoice,check; B: check=scanf("%d",&choice); while(check!=1||choice<0||choice>13) { while(getchar()!='\n'); printf("InputError!Pleaseenteryourchoiceagain:\n"); check=scanf("%d",&choice); } if(choice==1||choice==13||choice==0)flag=1; if(!flag) { printf("InputError!Pleaseenteryourchoiceagain:\n"); gotoB; } elsereturnchoice; } voidTable_Head()//输出成绩表表头 { inti; printf("IDnumberName"); for(i=1;i<=NumOfCourse;i++)printf("Course%d",i); printf("\n"); for(i=1;i<=NumOfCourse*9+14;i++)printf("-"); printf("\n"); } voidData()//输出成绩表主体数据 { inti,j; for(i=0;i<NumOfStudent;i++) { printf("%8ld%s",stu[i].num,stu[i].name); for(j=0;j<NumOfCourse;j++)printf("%3d",stu[i].score[j]); printf("\n"); } } intLegal_Input()//合法化输入 { intn,check; check=scanf("%d",&n); while(check!=1||n<0) { while(getchar()!='\n'); printf("InputError!Pleaseenteragain:\n"); check=scanf("%d",&n); } returnn; } voidInput_Data()//功能1：录入每个学生的学号、姓名和各科考试成绩 { inti,j; printf("Pleaseenterthenumberofstudents:\n"); NumOfStudent=Legal_Input(); printf("Pleaseenterthenumberofcourses:\n"); NumOfCourse=Legal_Input(); stu=(STUDENT*)calloc(NumOfStudent,sizeof(STUDENT)); Total=(int*)calloc(NumOfStudent,sizeof(int)); if(stu==NULL||Total==NULL) { printf("callocerror!\n");//内存申请不成功的处理 } Table_Head(); for(i=0;i<NumOfStudent;i++) { scanf("%ld",&stu[i].num); scanf("%s",stu[i].name); for(j=0;j<NumOfCourse;j++) { stu[i].score[j]=Legal_Input(); Total[i]+=stu[i].score[j]; } } QuickSort(Total,stu,0,NumOfStudent-1); for(i=NumOfStudent-1;i>=0;i--)stu[i].rank=NumOfStudent-i; } voidCourse_Score(STUDENTstu[])//功能2：计算每门课程的总分和平均分 { longinttotal=0; inti,j; printf("totalaverage\n"); for(i=0;i<NumOfCourse;i++) { total=0; for(j=0;j<NumOfStudent;j++) total+=stu[j].score[i]; printf("Course%d:%5ld%.2f\n",i+1,total,(double)total/NumOfStudent); } } voidStudent_Score(STUDENTstu[])//功能3：计算每个学生的总分和平均分 { inti; printf("totalaverage\n"); for(i=0;i<NumOfStudent;i++) { printf("%s:%5d%.2f\n",stu[i].name,Total[i],(double)Total[i]/NumOfCourse); } } voidDownSort(int*Total)//功能4：按每个学生的总分由高到低排出名次表 { inti,j; QuickSort(Total,stu,0,NumOfStudent-1); Table_Head(); for(i=NumOfStudent-1;i>=0;i--) { stu[i].rank=NumOfStudent-i; printf("%8ld%s",stu[i].num,stu[i].name); for(j=0;j<NumOfCourse;j++)printf("%3d",stu[i].score[j]); printf("\n"); } } voidUpSort(int*Total)//功能5：按每个学生的总分由低到高排出名次表 { QuickSort(Total,stu,0,NumOfStudent-1); Table_Head(); Data(); } voidID_Sort(STUDENTstu[])//功能6：按学号由小到大排出成绩表 { longintnumber[100]; inti; for(i=0;i<NumOfStudent;i++)number[i]=stu[i].num; QuickSort(number,stu,0,NumOfStudent-1); Table_Head(); Data(); } voidName_Sort(STUDENTstu[])//功能7：按姓名的字典顺序排出成绩表 { inti,j; STUDENTtemp; for(i=0;i<NumOfStudent-1;i++) for(j=i+1;j<NumOfStudent;j++) { if(strcmp(stu[i].name,stu[j].name)>0) { temp=stu[i]; stu[i]=stu[j]; stu[j]=temp; } } Table_Head(); Data(); } voidQuickSort(inta[],STUDENTb[],intlow,inthigh)//快速排序 { intpoint; if(low<high) { point=partion(a,b,low,high); QuickSort(a,b,low,point-1); QuickSort(a,b,point+1,high); } } voidswap(inta[],STUDENTb[],intlow,inthigh) { inttemp=a[low]; a[low]=a[high]; a[high]=temp; STUDENTtemp2; temp2=b[low]; b[low]=b[high]; b[high]=temp2; } intpartion(inta[],STUDENTb[],intlow,inthigh) { intkey=a[low]; while(low<high) { while(low<high&&a[high]>=key) { high--; } swap(a,b,low,high); while(low<high&&a[low]<=key) { low++; } swap(a,b,low,high); } returnhigh; } voidSearch_Number()//功能8：按学号查询学生排名及其考试成绩 { longintnumber[100],key; inti,j,l,r,mid; for(i=0;i<NumOfStudent;i++)number[i]=stu[i].num; QuickSort(number,stu,0,NumOfStudent-1); printf("Enterthenumberyouwanttosearch:\n"); scanf("%ld",&key); l=0;r=NumOfStudent-1; while(l<r) { mid=(l+r)/2; if(key==number[mid]) { Table_Head(); printf("%8ld%s",stu[mid].num,stu[mid].name); for(j=0;j<NumOfCourse;j++)printf("%2d",stu[mid].score[j]); printf("\n"); printf("rank:%d\n",stu[mid].rank); return; } if(key>number[mid])l=mid+1; if(key<number[mid])r=mid-1; } if(key==number[r]) { Table_Head(); printf("%8ld%s",stu[r].num,stu[r].name); for(j=0;j<NumOfCourse;j++)printf("%2d",stu[r].score[j]); printf("\n"); printf("rank:%d\n",stu[r].rank); return; } printf("Notfound!\n"); } voidSearch_Name()//功能9：按姓名查询学生排名及其考试成绩 { charkey[100]; inti,j,k,len,flag,count=0; printf("Enterthenameyouwanttosearch:\n"); scanf("%s",key); len=strlen(key); for(i=0;i<NumOfStudent;i++) { for(j=0;j<=strlen(stu[i].name)-len;j++) { flag=1; for(k=j;k<j+len;k++) { if(stu[i].name[k]!=key[k-j]) { flag=0; break; } } if(flag) { if(!count)Table_Head(); count++; printf("%8ld%s",stu[i].num,stu[i].name); for(k=0;k<NumOfCourse;k++)printf("%2d",stu[i].score[k]); printf("\n"); printf("rank:%d\n",stu[i].rank); break; } } } if(!count)printf("Notfound!\n"); } voidStatistic()//功能10：按优秀（90~100）、良好（80~89）、中等（70~79）、及格（60~69）、不及格（0~59）5个类别，对每门课程分别统计每个类别的人数以及所占的百分比 { inti,j,a,b,c,d,e; printf("ABCDE\n"); for(i=0;i<NumOfCourse;i++) { printf("Course%d",i+1); a=b=c=d=e=0; for(j=0;j<NumOfStudent;j++) { switch(stu[j].score[i]/10) { case10: case9:a++; break; case8:b++; break; case7:c++; break; case6:d++; break; default:e++; } } printf("%2d(%.1f%%)",a,(double)a/NumOfStudent*100); printf("%2d(%.1f%%)",b,(double)b/NumOfStudent*100); printf("%2d(%.1f%%)",c,(double)c/NumOfStudent*100); printf("%2d(%.1f%%)",d,(double)d/NumOfStudent*100); printf("%2d(%.1f%%)\n",e,(double)e/NumOfStudent*100); } } voidOutput_Data()//功能11：输出每个学生的学号、姓名、各科考试成绩，以及每门课程的总分和平均分 { Table_Head(); Data(); Course_Score(stu); } voidwfile()//功能12：将每个学生的记录信息写入文件 { FILE*fout; inti,j; fout=fopen("E://output.txt","w"); if(fout==NULL) { printf("Failedtowrite!\n");//文件打开失败的处理 exit(0); } fprintf(fout,"IDnumberName"); for(i=1;i<=NumOfCourse;i++)fprintf(fout,"Course%d",i); fprintf(fout,"\n"); for(i=1;i<=NumOfCourse*9+14;i++)fprintf(fout,"-"); fprintf(fout,"\n"); for(i=0;i<NumOfStudent;i++) { fprintf(fout,"%8ld%s",stu[i].num,stu[i].name); for(j=0;j<NumOfCourse;j++)fprintf(fout,"%2d",stu[i].score[j]); fprintf(fout,"\n"); } fclose(fout); } voidrfile()//功能13：从文件中读出每个学生的记录信息并显示 { FILE*fin; inti,j; fin=fopen("E://input.txt","r"); if(fin==NULL) { printf("Failedtoopenafile!\n");//文件打开失败的处理 exit(0); } fscanf(fin,"%d",&NumOfStudent); fscanf(fin,"%d",&NumOfCourse); stu=(STUDENT*)calloc(NumOfStudent,sizeof(STUDENT)); Total=(int*)calloc(NumOfStudent,sizeof(int)); for(i=0;i<NumOfStudent;i++) { fscanf(fin,"%ld",&stu[i].num); fscanf(fin,"%s",stu[i].name); for(j=0;j<NumOfCourse;j++) { fscanf(fin,"%d",&stu[i].score[j]); Total[i]+=stu[i].score[j]; } } QuickSort(Total,stu,0,NumOfStudent-1); for(i=NumOfStudent-1;i>=0;i--)stu[i].rank=NumOfStudent-i; Table_Head(); Data(); } intmain() { A: Menu(); switch(Input_Choice()) { case1:Input_Data(); system("pause"); system("cls"); gotoA; case2:Course_Score(stu); system("pause"); system("cls"); gotoA; case3:Student_Score(stu); system("pause"); system("cls"); gotoA; case4:DownSort(Total); system("pause"); system("cls"); gotoA; case5:UpSort(Total); system("pause"); system("cls"); gotoA; case6:ID_Sort(stu); system("pause"); system("cls"); gotoA; case7:Name_Sort(stu); system("pause"); system("cls"); gotoA; case8:Search_Number(); system("pause"); system("cls"); gotoA; case9:Search_Name(); system("pause"); system("cls"); gotoA; case10:Statistic(); system("pause"); system("cls"); gotoA; case11:Output_Data(); system("pause"); system("cls"); gotoA; case12:wfile(); system("pause"); system("cls"); gotoA; case13:rfile(); system("pause"); system("cls"); gotoA; default:free(stu); free(Total);//动态数组内存的释放 exit(0); } return0; } 优点 程序可执行多个选项，每次输入选项前清除缓存，并重新显示菜单。对输入菜单选项以及输入数据进行合法性检验。表格的打印较为整齐。采用动态数组存储数据，占用内存空间更少。使用模糊查询算法，若对查询内容稍有遗忘亦可查询到相关内容。使用文件输入输出，使输入更便捷。 创新之处 对输入菜单选项顺序的问题进行了考虑，如果在输入1、13、0之前输入其他选项，均视为非法输入。对数据的排序使用了快速排序算法，提高程序的运行效率。对姓名的查询采用了模糊查询算法，提高程序的容错率。程序加入了让输出结果停留与清除屏幕上原先输出结果的功能，使输出界面更简洁。 不足之处 表格的打印还无法做到对所有数据均输出整齐对部分数据的合法性缺少判断 收获与学习体会 当我们的程序只需执行单个功能时，我们也许无需太过在意内存空间的占用、变量或函数的命名这些细节问题；但一旦我们需要编写一段执行多种功能的复杂程序，这些细节的重要性就凸显出来了。在这次的编程过程中，我会有意识地去使用一些英文单词加“_”这样的组合去命名一个变量或者是函数名，尽管这样的名称会显得相对较长，但却能随时提醒我变量、函数的作用，给我的编程带来方便。编程时，思维的连贯性是很重要的，我不希望这些小细节影响了整个思维的连贯性。另外，加注释也有助于编程，当一个函数名旁边有了注释的时候，我就会很清楚这个函数的作用是什么，编写起来就相对比较容易。 也同样是由于程序复杂性的增加，我们自行发现代码bug的难度上升了。我一般采用增加中途输出的方法对程序的问题或者漏洞进行定位。在这一过程中，我发现很多错误都发生在一些简单的算法上，而由于思维的习惯，我们一般会以为简单的地方不会犯错，这无形中又增加了发现bug的难度。通过几次痛苦的debug，我明白了要不断增加对于简单算法的掌握程度与熟练度，这会大大提升调试代码的速度，也会让我在编写较长代码时变得更轻松。 在调试程序过程中，我还注意到，分模块调试是最有效的一种调试方法。先通过输出的数据猜测可能出错的模块，再针对单个模块进行调试。我觉得这一点对我写程序的顺序也有所启发。比如，如果我实现知道在某段代码中我可能要用到一个我之前不太熟悉的算法或者语句，那我可以先用一些可以实现同样功能的语句替代它们的功能，待程序整体调试完成，再将这些复杂的语句或者是程序块添加到程序中，如果测试有问题，我也会明确知道问题发生的具体语句。 说了那么多有关调试的问题，调试本身也是极为重要的。很少有人能一遍就把代码写得很完美、滴水不漏，这就需要我们能够及时找出问题所在并迅速想出解决方法，有时甚至需要我们自己去发现自己程序的漏洞并尝试修复它。敲完代码绝不意味着程序的完成，调试往往意味着更严峻的考验。 
第200篇文章[3]
舰船通道路线优化 1.研究背景及意义 考虑一个若干层的舰船，各房间的空间位置已知，房间之间有若干距离、拥挤程度不同的通道，各位置处人群密度随时间变化，相应的通过速度、所需通过时间也会不同。需要设计一个算法，对于船上的任意一点均可找出通往指定位置所需时间最短的路径。 舰船是一个人群密度相对较大、人群流动频繁的场所。移动路线的选择很大程度上影响了人的行动效率。优化的路线设计不仅可以提高船舶人流、物流的效率，而且非常有助于对舰船上管网电网布置、逃生消防等诸多方面的设计。可以说，这样的一个路线优化算法具有较高的应用价值。 2.建模方法 建立一个边带权图 G = ( V , E , g ) G=(V,E,g) G=(V,E,g)，其中： V V V是所有房间和通道交叉点的集合， E E E是所有通道的集合， g : E → R g:E→R g:E→R， ∀ e ∈ E ∀e∈E ∀e∈E， g ( e ) g(e) g(e)表示边e的长度。任一边上的人群密度函数为 ρ ( e , t ) , e ∈ E ρ(e,t),e∈E ρ(e,t),e∈E， t t t表示时间，假设人行走速度 υ υ υ受人群密度 ρ ρ ρ影响，且 υ υ υ与 ρ ρ ρ满足函数关系 υ = υ ( ρ ) υ=υ(ρ) υ=υ(ρ)。这样一来，根据边的权值与当前时刻人的行走速度可以计算出人通过某一条边的时间。问题转化为，对 ∀ u , v ∈ V ∀u,v∈V ∀u,v∈V，需找到一条从 u u u到 v v v的路使所需时间最短。 3.可能遇到问题及解决方案 3.1人群密度的变化问题 普通的最短路径问题边的权值是固定不变的，但在这个工程问题中，人群密度是在随时间不断变化的，这就给求解带来了很大的挑战。由于人群密度的不断变化，每到一个顶点，都需要重新规划最短路径，但仍不能保证随着时间的推移，这条路径仍是最短的。 在我看来，如果在每一点都求解那一时刻的最短路径，计算量是很大的，并且仍不能保证最优解。不如直接放弃寻找最优解，尝试寻找次优解。可以采用贪心算法，对当前节点 w w w，只考虑与它相关的若干条边的人群密度，且通过该边到达 w ′ w' w′后， d ( w , v ) > d ( w ′ , v ) d(w,v)>d(w',v) d(w,v)>d(w′,v)。在符合条件的若干边中选择所需时间最短的。 或者，统计一段较长时间内任一边人群的平均密度 ρ ′ ( e ) , e ∈ E ρ'(e),e∈E ρ′(e),e∈E，定义边的权值 g ′ ( e ) = g ( e ) / ( υ ( ρ ′ ) ) , e ∈ E g'(e)=g(e)/(υ(ρ')),e∈E g′(e)=g(e)/(υ(ρ′)),e∈E，进而转化为普通的最短路径问题进行求解，这样仍不能保证最优解，但与最优解已相当接近。 3.2对通道的通行状况刻画不到位问题 通道的通行不仅与距离、人群密度有关，还和通道的地面平整程度、光线明暗度等多方面因素相关，并且这些因素一定程度上也与时间有关，这样一来，问题将会变得更复杂。 如果把这些因素都看成时间的函数，问题无疑会变得复杂很多。在我看来，这些因素相比于人群密度而言变化幅度很小，可以把它们当作是边的权值的一部分，通过一些换算关系调整原先边的权值，使讨论更精确。 参考：基于图论的舰船通道路线优化 
第201篇文章[]
关于Java迭代器（Iterator）的思考 JavaIterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代ArrayList和HashSet等集合。 在我们使用 for( : ) 去遍历集合中的所有元素时，其实就隐式地使用了迭代器（Iterator）。 遍历集合的两种方法 通常来说，遍历集合中的元素主要有以下两种方法。 //method1 List<String>list= ; for(Stringstr:list){ System.out.println(str); } //method2 List<String>list= ; Iterator<String>iter=list.iterator(); while(iter.hasNext()){ Stringstr=iter.next(); System.out.println(str); } 对于第二种方法来说，其实是显式地定义了一个Iterator类型的对象，它有iterator()方法，调用该方法可以获取一个迭代器。 迭代器有三个基本操作，分别是next、hasNext和remove。 调用it.next()会返回迭代器的下一个元素，并且更新迭代器的状态。 调用it.hasNext()用于检测集合中是否还有元素。 调用it.remove()将迭代器返回的元素删除。 Iterator是Java中的一个接口，位于java.util包中，使用前需要引入它，语法格式如下： importjava.util.Iterator;//引入Iterator类 两种方法的比较 下面，我们来比较一下这两种方法有何不同。 我们先分别运行一下下面的两段代码。 publicclassTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<String>(Arrays.asList("Apple","Orange","Peach")); for(Stringstr:list){ System.out.println(str); } } } publicclassTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<String>(Arrays.asList("Apple","Orange","Peach")); Iterator<String>iter=list.iterator(); while(iter.hasNext()){ Stringstr=iter.next(); System.out.println(str); } } } 我们发现它们的运行结果是一样的。这样看它们好像没有什么差别，而且第一种写法要简单一些，代码量更少。 删除元素 下面我们比较一下当从集合中删除元素时，这两种写法的区别。 publicclassTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<String>(Arrays.asList("Apple","Orange","Peach")); for(Stringstr:list){ list.remove(str); } System.out.println(list); } } 当我们运行上面这段代码时，出现了报错。可以通过根据异常定位到报错的地方：当我们使用Java中的foreach循环时，其实编译器会根据list对象创建一个Iterator的迭代器。我们对list进行的增删操作的具体实现都必须经过Iterator。在Iterator创建的时候modCount被赋值给了expectedModCount，但是调用list的add和remove方法的时候不会同时自动增减expectedModCount，这样就导致两个count不相等，从而抛出异常。 我们再试试下面这种写法。 publicclassTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<String>(Arrays.asList("Apple","Orange","Peach")); Iterator<String>iter=list.iterator(); while(iter.hasNext()){ Stringstr=iter.next(); list.remove(str); } System.out.println(list); } } 运行之后，出现了和上面一样的报错信息。与上一种写法相比，这里的Iterator被显式地定义出来了，但是同样出现了调用list的remove方法的时候不会同时自动增减expectedModCount的问题，这样就导致两个count不相等，从而抛出异常。 那应该怎样在遍历List的同时删除元素呢，我们看一下下面这种写法。 publicclassTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<String>(Arrays.asList("Apple","Orange","Peach")); Iterator<String>iter=list.iterator(); while(iter.hasNext()){ Stringstr=iter.next(); if(str.endsWith("e")){ iter.remove(); } } System.out.println(list); } } 最后的运行结果如下：我们可以看到，这里成功的删除了以e结尾的两个字符串。为什么使用iter.remove()就可以成功删除List中的元素呢？这是因为在Iterator中的remove方法在删除元素后会自动调整迭代器指向的元素，也会自动增减expectedModCount的值，所以不会出现之前的报错。 使用自己的迭代器 上面我们都是使用的Java标准库里的Iterator接口，那能否定义自己的MyIterator类（接口）呢？ 答案是肯定的。并且在很多时候，为自己设计的抽象数据类型（ADT）增加一个迭代器是一个很不错的设计模式（IteratorPattern），用户可以用之前已经非常熟悉的迭代器方法来遍历你设计的ADT中的元素。 在Java的标准库中定义了一个Iterable接口，而实现该接口的集合对象是可遍历迭代的。这里的Ierator是迭代器的接口，也在Java标准库中有定义。基本结构如下。而所谓的Iteratorpattern就是指让自己的集合类实现Iterable接口，并实现自己独特的Iterator迭代器(重写hasNext,next,remove方法)，允许客户端利用这个迭代器进行显式或隐式的迭代遍历。 下面是一个实现样例。 //实现Iterable<E>接口 publicclassPair<E>implementsIterable<E>{ privatefinalEfirst,second; publicPair(Ef,Es){first=f;second=s;} //重写iterator方法 //返回自己的迭代器 publicIterator<E>iterator(){ returnnewPairIterator(); } //构建自己的Iterator privateclassPairIteratorimplementsIterator<E>{ privatebooleanseenFirst=false,seenSecond=false; //OverridehasNext方法 publicbooleanhasNext(){return!seenSecond;} //Overridenext方法 publicEnext(){ if(!seenFirst){seenFirst=true;returnfirst;} if(!seenSecond){seenSecond=true;returnsecond;} thrownewNoSuchElementException(); } //Overrideremove方法 //这里不允许删除元素 publicvoidremove(){ thrownewUnsupportedOperationException(); } } } 
第202篇文章[1]
物理内存和虚拟内存 物理内存就是电脑本身的内存大小。 而虚拟内存技术，是拿出一部分硬盘空间来充当内存使用，当内存被占用完时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。但是不要把虚拟内存跟真实的插在主板上的内存条相挂钩，虚拟内存它不是虚拟的，不存在的内存，它只是内存管理的一种抽象！ 所以，可以说计算机的内存大小等于实际物理内存容量加上“分页文件”（就是交换文件）的大小。 RAM是高速缓存，通电就具有记忆功能，断电就失去，也就是运行内存，就是用来存放临时文件，而“内存”就是RAM的一种物理硬件，广义来说两者也可以说是同一概念。而虚拟内存是系统利用硬盘分出来的具有辅助内存工作的虚拟RAM，不是硬件，但又依靠硬盘。 虚拟内存并不是把硬盘当作内存，而是在硬盘上创建的交换文件。当物理内存用完后，虚拟内存管理器选择最近没有用过的，低优先级的内存部分写到交换文件（页面文件）上，并将需要访问内存的程序的内容从页面文件中换入到物理内存。 正在运行的一个进程，所需的内存是有可能大于内存条容量之和的，那么不是所有数据都能一起加载到内存（物理内存）中，势必有一部分数据要放到其他介质中（比如硬盘）。待进程需要访问那部分数据时，再通过调度进入物理内存。所以，虚拟内存是进程运行时所有内存空间的总和，并且可能有一部分不在物理内存中，而物理内存就是我们平时所了解的内存条。有的地方呢，也叫这个虚拟内存为内存交换区。 什么是虚拟内存地址和物理内存地址呢。假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址00xFFFFFFFF（4G）的地址空间。但如果你的计算机只有256M的物理内存0x0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？回答这个问题前，先说明计算机的内存分页机制。 计算机会对虚拟内存地址空间（32位为4G）分页产生页（page），对物理内存地址空间（假设256M）分页产生页帧（pageframe），这个页和页帧的大小是一样大的，所以呢，在这里，虚拟内存页的个数势必要大于物理内存页帧的个数。在计算机上有一个页表（pagetable），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射，而且是一对一的映射。但是问题来了，虚拟内存页的个数>物理内存页帧的个数，岂不是有些虚拟内存页的地址永远没有对应的物理内存地址空间？不是的，操作系统是这样处理的。操作系统有个页面失效（pagefault）功能。操作系统找到一个最少使用的页帧，让他失效，并把它写入磁盘，随后把需要访问的页放到页帧中，并修改页表中的映射，这样就保证所有的页都有被调度的可能了。这就是处理虚拟内存地址到物理内存的步骤。 可以认为虚拟空间都被映射到了磁盘空间中，并且由页表记录映射位置，当访问到某个地址的时候，通过页表中的有效位，可以得知此数据是否在内存中，如果不是，则通过缺页异常，将磁盘对应的数据拷贝到内存中，如果没有空闲内存，则选择牺牲页面，替换其他页面。 
第203篇文章[3]
中文分词（python） 今天研究了一下中文分词，下面用两种简单的算法（正向最大匹配分词算法和逆向最大匹配分词算法）实现。 #字典生成 defload_dic(filename): f=open(filename,'r',encoding='utf-8') word_dic=set() max_length=1 forlineinf: word=line.strip() word_dic.add(word) iflen(word)>max_length: max_length=len(word) returnmax_length,word_dic #正向最大匹配分词 deffmm_word_seg(sentence,word_dic,max_length): begin=0 words=[] whilebegin<len(sentence): forendinrange(min(begin+max_length,len(sentence)),begin,-1): word=sentence[begin:end] ifwordinword_dicorend==begin+1: words.append(word) break begin=end returnwords max_len,word_dic=load_dic('lexicon.txt')#中文词汇库 words=fmm_word_seg(input(),word_dic,max_len) forwordinwords: print(word) #字典生成 defload_dic(s): words=s.split() word_dic=set() max_length=1 forwordinwords: word_dic.add(word) iflen(word)>max_length: max_length=len(word) returnmax_length,word_dic #逆向最大匹配分词 deffmm_word_seg(sentence,word_dic,max_length): end=len(sentence) words=[] whileend>0: forbegininrange(max(end-max_length,0),end): word=sentence[begin:end] ifwordinword_dicorend==begin+1: words.append(word) break end=begin returnwords max_len,word_dic=load_dic(input()) words=fmm_word_seg(input(),word_dic,max_len) foriinrange(len(words)-1,-1,-1): print(words[i])#逆序打印 两种算法略有不同，但总体思路类似。对于不同的中文句子，两种算法可能有的适用，有的不适用。例如 研究生命的起源 这句话，使用正向最大匹配分词算法时，会被分成 研究生命的起源 ，但使用逆向最大匹配分词算法就可以得到正确结果。当然逆向最大匹配分词算法也不是对所有句子都适用。 总的来看，两种算法都能一定程度上实现中文句子的分词，但都不完善，现阶段也没有百分百准确的分词算法，这一领域还有较大的研究空间。 
第204篇文章[3]
判断给定的字符串是否为合法的Python标识符 判断给定的字符串是否为合法的Python标识符，一个合法的Python标识符应当符合以下几个命名规则： 只能包含数字、字母或者下划线"_"只能以字母或者下划线开头不能为Python保留关键字 以下是Python的程序实现，从以上三个方面对输入字符串是否为合法的Python标识符进行判断。 importkeyword defIs_legalword(s):#判断是否是合法字符（数字、字母或下划线） forkeyins: ifnotkeyin'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_': returnFalse returnTrue defIs_legal(s): ifs[0]=='_'ors[0].isalpha():#开头为字母或下划线 ifkeyword.iskeyword(s):#判断是否为Python保留关键字 returnFalse elifIs_legalword(s): returnTrue else: returnFalse else: returnFalse line=input() print(Is_legal(line)) 正好，一道Python编程题的内容与判断Python标识符的合法性有关，具体题目如下。 Python编程题 题目内容：依次判断一系列给定的字符串是否为合法的Python标识符。 输入格式:一系列字符串，每个字符串占一行。 输出格式：判断每行字符串是否为合法的Python标示符，如果合法则输出True，否则输出False。 输入样例：abc_def21gh 输出样例：TrueTrueFalse 我们发现，这道编程题与我们之前考虑的问题略有不同，最大的不同点在于这道编程题要求输入一系列字符串，这要求代码能够实现多行输入。而以下代码可以解决这个问题。 importkeyword importsys defIs_legalword(s): forkeyins: ifnotkeyin'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_': returnFalse returnTrue defIs_legal(s): ifs[0]=='_'ors[0].isalpha(): ifkeyword.iskeyword(s): returnFalse elifIs_legalword(s): returnTrue else: returnFalse else: returnFalse list=[] list_new=[] forlineinsys.stdin: list_new=line.split() list.extend(list_new) forlineinlist: print(Is_legal(line)) 
第205篇文章[6]
word2019关闭时无响应 今天在关闭word文档时突然遇到了无响应的情况，网上有的资料说取消隐私设置里的所有对勾项，我尝试了一下之后失败了。最后我是通过下述方法解决的。 步骤 最好新建一个word文档进行操作以Office安全模式启动Word（按下CTRL键，双击打开word文档）。打开新建的文档，再关闭，检查问题是否依然存在。如果问题在安全模式下不存在，这说明是由加载项引起的。点击文件>选项>加载项>在管理列表中，单击COM加载项，然后单击转到,取消勾选在COM加载项对话框中列出的加载项，如果有多个，需要逐个取消勾选进行测试。此过程有助于确定哪个加载项是导致该问题的原因。最后COM加载项的页面如上图所示，我的word里共有6个加载项。后面4个其实是office自带的一些加载项，而我这个问题是最近才出现的，应该和这几个关系不大。我直接尝试关闭了前两个加载项（百度网盘、福昕PDF编辑器），问题成功解决。 
第206篇文章[6]
QQ小程序云开发 QQ小程序的开发有时候需要使用云开发能力，下面是我自己总结的云开发初始化的相关教程。注：在最初构建项目时要选择使用云服务。 1.下载Nodejs 下载地址，全部选择默认安装即可。（下图中版本号可能不对） 2.在小程序根目录打开终端，执行npminit，全部按回车 cmd切换到指定目录方法：相关博客 3.在终端输入npminstall--save@cloudbase/extension-ci，等待执行完毕。 4.点击QQ小程序开发者顶部栏-工具-构建npm 5.在QQ小程序需要云开发的页面加入如下代码即可。 constextCI=require('@cloudbase/extension-ci'); Page({ .. onLoad:function(){ //初始化环境 qq.cloud.init({ env:'此处填入自己注册的环境ID' }) //注册云开发扩展 qq.cloud.registerExtension(extCI); } .. }) 
第207篇文章[3]
Python实现 两位整数相乘形成的最大回文数是9009=99×91。编写程序，求得任意输入的n位整数相乘形成的最大回文数。 题目内容：两位整数相乘形成的最大回文数是9009=99×91。编写程序，求得任意输入的n位整数相乘形成的最大回文数。 输入格式:正整数n 输出格式：n位整数相乘形成的最大回文数 输入样例：2 输出样例：9009 【基本思路】从大到小枚举可能的n位数因子，从中找到最大的回文数乘积。【优化】试图缩小因子的取值范围，减少循环次数。【分析】设两个因子分别为 i i i和 j j j，取 i i i等于因子可能的最大值 1 0 n − 1 10^n-1 10n−1，从大到小枚举 j j j，一定可以找到回文数 N N N，设此时 j = j 0 j=j_0 j=j0​。则 i > j 0 i>j_0 i>j0​， j > = j 0 j>=j_0 j>=j0​，否则 i ∗ j < N i*j<N i∗j<N， i ∗ j i*j i∗j不可能是最大回文数。根据这个思路进行编程，代码如下： defIs_palindrome(s):#判断回文数 l=len(s) foriinrange((l-1)//2+1): ifs[i]!=s[l-1-i]:returnFalse returnTrue deffind(n): base=10**n-1#因子的基准值（从10^n-1开始减小） forjinrange(base,0,-1): ifIs_palindrome(str(base*j)): max=base*j mini=j#因子可能的最小值（如果i或者j小于mini的话，i*j一定小于base*mini） break foriinrange(base,mini,-1): forjinrange(i,mini,-1): ifIs_palindrome(str(i*j)): ifi*j>max:max=i*j returnmax n=int(input()) print(find(n)) 
第208篇文章[]
2021春软件构造雨课堂选择题(3）（4) 1.Externalqualityfactors：（1）正确性（2）健壮性（3）可扩展性（4）可复用性（5）兼容性（6）效率（7）可移植性（8）易用性（9）功能性 2.敏捷开发特征：增量式过程迭代过程 3.配置管理SCM①软件配置管理：用于追踪和控制软件的变化②SCI基本配置项：产生变化的基本单元③版本：为软件的任一特定时刻moment的形态指派一个唯一的编号，作为“身份标识”。④Git----集中式版本控制系统 4.Git①.git-----本地的CMDB②工作目录-------本地文件系统③暂存区-----隔离工作目录和Git仓库 ④3种状态：已修改、已暂存、已提交 ⑤Git存储发生变化的文件（而非代码行），不变化的文件不重复存储。 ⑥将Github上的某个Git仓库设置为本地仓库的指令是：gitpullaaa⑦将暂存区文件写入Git仓库的指令是：gitcommit-m“xxxx” 5.Git仓库的objectgraph 
第209篇文章[]
2021春软件构造雨课堂选择题(5) 1.codereview代码评审 2.staticcodeanalysis 3.dynamiccodeanalysis动态分析：执行程序并观察现象，收集数据、分析不足 4.profiling：对代码的运行时状态和性能进行度量，发现代码中存在的问题 5.refactoring重构在不改变功能的前提下，优化代码 
第210篇文章[]
Git学习笔记 个人的学习笔记，用作以后复习。以下内容来源于尚硅谷：link 1.Git的常用命令 1.1设置用户签名 安装完成后只需要设置一次用户签名否则提交代码会报错 gitconfig--globaluser.nameyourname gitconfig--globaluser.emailyouremailadd cat~/.gitconfig//查看设置好的用户 {查看用户：c盘用户} {这个签名和其他的账号，如Github账号没有任何关系} 小技巧：输入命令的前几个字母，点击tab键自动补全命令 1.2基本操作 先打开项目文件所在位置再打开bash .git文件默认隐藏，不要修改它里面放的东西 gitinit//初始化本地库 ll//查看文件 ll-a//查看隐藏文件 cd///回到根目录 cd..//回到上一层目录 gitstatus//查看本地库状态 //Onbranchmaster在master分支 gitaddfilename#添加到暂存区，也就是追踪文件的过程 gitadd--all waring：LFwillbereplacedbyCRLFinhello.txt 这里是window里面的换行符LF被改成Linux下的换行符CRLF，不必在意这个警告 //暂存区的文件可以删除 gitrm--cachedfilename//只是从暂存区里删掉了，工作区里没有删除 gitcommit-m"日志信息"filename//提交到本地库 gitreflog//查看版本信息 //965c6a1(HEAD->master)……//965c6a1版本号 gitlog//查看详细版本信息 catfilename//显示filename里面的内容 ·只要有文件修改就可以查看状态 ·修改文件后再用gitstatus查看，发现modified信息 ·Git里按行来修改文件 gitreset--hard版本号//版本穿梭：认为新的版本不行，回到旧的版本 //版本号用relog查看就可以 git切换版本用的是指针，不是记录很多个不同版本的文件（副本） HEAD指向的分支就是当前分支 2.Git的分支操作 2.1什么是分支 一个项目，多个任务，我们对每个任务创建分支。在不同的分支上完成开发，这样就不会影响主分支。 Master主分支 Hot-fix热修复分支 分支是可以改名的 2.2分支的操作 gitbranchname//创建分支 gitbranch-v//查看分支 gitbranch-mold_namenew_name gitcheckoutname//切换分支 gitmergename//把指定的分支合并到当前分支上 //注意：合并前得先切换到目标分支，再合并 2.3合并时冲突的处理办法 两个分支在同一文件同一位置有两套完全不同的修改人为决定谁去谁留 CONFLICT(content)：Mergeconflictinfilename.type 直接vim打开冲突的文件，人为修改<<<===>>>之间的内容，再次添加到缓存区，提交即可但提交时不要加上filename.type gitcommit-m"info" 即可 3.GitHub操作 3.1创建远程创库 gitremote-v//查看别名 gitremoteaddAB//创建别名将B重新起个名字，A gitremoteaddgit-demohttp://……//将网站叫做git-demo 3.2本地分支和远程仓库 gitpush别名分支//推送本地分支到远程仓库 //不用别名，直接用网页链接也可以 gitpull别名分支//拉取远程仓库到本地库 gitclonehttp://……//克隆远程代码到本地 /* 克隆代码不需要登陆 ①拉取代码 ②自动初始化本地仓库 ③别名也创建好了 */ 3.3GitHub团队内协作 前提条件：加入团队 在仓库创建者的账号里：setting-->manageaccess-->inviteacollaborator-->输入账号 得到了一个邀请的网页地址被邀请者需要进入这个网站，接受这个邀请 
第211篇文章[]
Java设计模式：装饰器模式（简易版） 软构lab3 这是个简单的例子 我们假设要点一份菜。菜单里：①蔬菜②肉类 现在我们为这个份菜增加装饰：①加辣椒②加量 1.抽象构件角色：Dish这是一个接口 packagefunc; publicinterfaceDish{ voidorderdish(Stringmsg);//点一份菜 } 2.具体实现：Meat和VegetableMeat和Vegetable是对Dish的具体实现，用implements packagefunc; publicclassMeatimplementsDish{ @Override publicvoidorderdish(Stringmsg){ //TODOAuto-generatedmethodstub System.out.println("你点了一份荤菜："+msg); } } packagefunc; publicclassVegetableimplementsDish{ @Override publicvoidorderdish(Stringmsg){ //TODOAuto-generatedmethodstub System.out.println("你点了一份素菜："+msg); } } 3.抽象装饰器DecoratorDish①这是一个抽象类，实现Dish，因此用implements②注意其成员属性：引用了Dish对象 packagedecorator; importfunc.Dish; publicabstractclassDecoratorDishimplementsDish{ //要装饰的对象是 privateDishmyDish; //构造器 publicDecoratorDish(DishmyDish){ this.myDish=myDish; } //原先在Dish接口中的方法 publicvoidorderdish(Stringmsg){ myDish.orderdish(msg); } } 4.具体装饰AddPepper和Large①在这里实现要增加的新方法②注意构造器的写法，用了super packagedecorator; importfunc.Dish; publicclassLargeextendsDecoratorDish{ //构造器 publicLarge(Dishlarge_dish){ super(large_dish); } //点一份加大的菜 @Override publicvoidorderdish(Stringmsg){ super.orderdish(msg);//原功能 LargeDish();//新功能 } //要增加的新的功能 publicvoidLargeDish(){ System.out.println("备注：大份的"); } } packagedecorator; importfunc.Dish; publicclassAddPepperextendsDecoratorDish{ //构造器 publicAddPepper(Dishpepper_dish){ super(pepper_dish); } //点一份加辣的菜 @Override publicvoidorderdish(Stringmsg){ super.orderdish(msg);//原功能 PepperDish();//新功能 } //要增加的新的功能 publicvoidPepperDish(){ System.out.println("备注：加辣的"); } } 5.测试 packagetest; importdecorator.AddPepper; importdecorator.Large; importfunc.Vegetable; importfunc.Dish; importfunc.Meat; publicclasstestde{ publicstaticvoidmain(String[]argv){ Dishsalad=newVegetable(); Dishchicken=newMeat(); System.out.println("-------原始的---------"); salad.orderdish("沙拉"); chicken.orderdish("烤鸡"); //这里就是使用了装饰的 //我们可以给Dish的具体实现类增加任意多的装饰 Dishlarge_salad=newLarge(newVegetable()); Dishpepper_chicken=newAddPepper(chicken); Dishdouble_deco=newAddPepper(newLarge(newVegetable())); System.out.println("\n-------加装饰的---------"); large_salad.orderdish("沙拉"); pepper_chicken.orderdish("烤鸡"); double_deco.orderdish("土豆泥"); } } 
第212篇文章[]
Java的ArrayList小问题 1.发现在new时，不是会自动初始化为null①在遍历时最好使用for-each方法，否则会出现越界异常②或者用size()来遍历也行 importjava.util.ArrayList; publicclassTry{ publicstaticvoidmain(String[]args){ //TODOAuto-generatedmethodstub ArrayList<String>mylist=newArrayList<>(); mylist.add(0,"A"); mylist.add(1,"A"); //注释掉，发现编译报错 //mylist.add(2,"NULL"); mylist.add(3,"B"); for(Stringi:mylist){ System.out.println(i); } } } 2.发现remove后，元素下标会自动排好 importjava.util.ArrayList; publicclassTry{ publicstaticvoidmain(String[]args){ //TODOAuto-generatedmethodstub ArrayList<Integer>mylist=newArrayList<>(); for(inti=0;i<=4;i++){ mylist.add(i); } for(intj:mylist){ System.out.println(j); } mylist.remove(1); System.out.println(mylist.indexOf(0)); System.out.println(mylist.indexOf(2)); System.out.println(mylist.indexOf(3)); System.out.println(mylist.indexOf(4)); } } 
第213篇文章[8]
C语言个人笔记 C语言个人笔记 在这里，我将整理我个人在学习C/C++遇到的一些零碎的问题或者知识点。它们零零碎碎，不成体系。这只是一篇笔记。 1.strcmp()函数 头文件<string.h>函数原型intstrcmp(constchar*str1,constchar*str2)功能描述用于比较两个字符串并根据比较结果返回整数返回值(ret)①str1<str2，ret<0②str1>str2，ret>0③str1=str2，ret=0 2.isdigit()函数 头文件<ctype.h>函数原型intisdigit(intc)功能描述检查所传的字符是否是十进制数字字符返回值(ret)①c是一个数字，ret非零值②否则，ret=0 C语言里没有boolean型，C++里有。 3.atoi()函数 头文件<stdlib.h>函数原型intatoi(constchar*str)功能描述把参数str所指向的字符串转换为一个int整数返回值(ret)①该函数返回转换后的长整数②，如果没有执行有效的转换，则返回零。 菜鸟教程：link 4.sigfillset()函数 头文件<signal.h>函数原型intsigfillset(sigset_t*set)功能描述用来将参数set信号集初始化,将所有信号加到信号集set中返回值(ret)①执行成功，ret=0②有错误，ret=-1 菜鸟教程：link 5.getopt()函数 头文件<unistd.h>函数原型intgetopt(intargc,char*constargv[],constchar*optstring)功能描述getopt()用来分析命令行参数 C语言中文网：link 
第214篇文章[6]
Linux学习笔记 Linux学习笔记 1. makeclean//清除上次的make命令所产生的object文件（后缀为“.o”的文件）及可执行文件。 make//根据Makefile文件编译源代码、连接、生成目标文件、可执行文件。 2. 如何生成.o文件 gcc-Ehello.c-ohello.i gcc-Shello.i-ohello.s gcc-Chello.s-ohello.o 
第215篇文章[]
2021春软件构造雨课堂选择题(2) 1.Memorydump属于软件三维视图中的：Run-time、Code-level、Moment 2.Executionstacktrace和codesnapshot在软件三维度视图中的共性是：都是Run-time，code-level 3.CodeChurn和AST分别是Build-time和period的视图 4.Staticlinking（静态链接）和Dynamiclinking（动态链接）的区别在于：①前者发生在构造阶段，后者发生在运行阶段。 
第216篇文章[]
Java时间年月日及其持续天数用Date！！！ 软构lab3 知道开始和结束日期的年月日，求持续天数 getTimeInMillis()将其转化成long,表示从格林威治标准时间1970年1月1日的00:00:00.000到Calendar对象表示的时间之间的毫秒数 importjava.util.Calendar; publicclassTry{ publicstaticvoidmain(String[]args){ Calendarstartdate=Calendar.getInstance(); Calendarenddate=Calendar.getInstance(); //设置时间 startdate.set(2021,6,30); enddate.set(2021,7,2); //getTimeInMills()函数 longdura=enddate.getTimeInMillis()-startdate.getTimeInMillis(); //输出检查 System.out.println(startdate.get(Calendar.YEAR)+"-"+startdate.get(Calendar.MONTH)+"-"+startdate.get(Calendar.DATE)); System.out.println(enddate.get(Calendar.YEAR)+"-"+enddate.get(Calendar.MONTH)+"-"+enddate.get(Calendar.DATE)); //得到毫秒数 System.out.println(dura); //得到天数 System.out.println(dura/1000/60/60/24); } } 以上方法十分离谱，快跑！！！ 2021-6-1到2021-6-5得到的时间是4但是！2021-6-30到2021-7-1得到的时间却是1 如果涉及到月转换，就别用这个方法 看了一番突然发现了问题所在：java里的Calendar不检查月份天数，它默认每个月都是31天。 publicstaticStringnyr(Calendara){ Stringmystr=a.get(Calendar.YEAR)+"-"+a.get(Calendar.MONTH)+"-"+a.get(Calendar.DATE); returnmystr; } publicstaticvoidmain(String[]args){ Calendara=Calendar.getInstance(); a.set(2021,2,28); System.out.println(nyr(a)); a.add(Calendar.DATE,1); System.out.println(nyr(a)); a.add(Calendar.DATE,1); System.out.println(nyr(a)); a.add(Calendar.DATE,1); System.out.println(nyr(a)); a.add(Calendar.DATE,1); System.out.println(nyr(a)); } 输出如下：？？？谁家2月有30号啊！！！！ 再见Calendar，我用Date去了 新方法如下： packagetest; //注意：引进的包是sql里的 importjava.sql.Date; importjava.util.Calendar; publicclassTry{ //给日期加n天 publicstaticDateadd_days(Datea,longday){ Calendartemp=Calendar.getInstance(); temp.setTime(a); temp.set(Calendar.DATE,temp.get(Calendar.DATE)+(int)day); Datemydate=newDate(temp.get(Calendar.YEAR)-1900,temp.get(Calendar.MONTH),temp.get(Calendar.DATE)); returnmydate; } //计算两个日期之间的持续天数 publicstaticlonggetDuration(Dateearly,Datelate){ //不必考虑日期的先后顺序，加个绝对值 longmyDura=Math.abs(early.getTime()-late.getTime())/(1000*60*60*24); returnmyDura; } publicstaticvoidmain(String[]args){ //奇妙的赋值方式 //年份-1900，月份-1，日正常 Datea=newDate(2021-1900,2-1,28); System.out.println(a.toString()); System.out.println("---------测试：加方法是否跨月份----------"); //注意：Date是mutable的 a=add_days(a,1); System.out.println(a.toString()); a=add_days(a,1); System.out.println(a.toString()); a=add_days(a,1); System.out.println(a.toString()); System.out.println("---------测试：两个日期之间的持续天数----------"); Dateb=newDate(2021-1900,6-1,1); Datec=newDate(2021-1900,6-1,5); Dated=newDate(2021-1900,7-1,1); System.out.println("2021-6-1到2021-6-5间隔"+getDuration(b,c)+"天"); System.out.println("2021-6-1到2021-7-1间隔"+getDuration(d,b)+"天"); } nice 
第217篇文章[]
2021春软件构造雨课堂选择题(1) Integera=newInteger(3); Integerb=3; intc=3; System.out.println("a==b"+(a==b)); System.out.println("b==c"+(b==c)); System.out.println("a==c"+(a==c)); 2. Stringa="c"; Stringb="c"; System.out.println("aandb:"+(a==b)); String是不可变的数据类型，改变引用、不改变内容。 System.out.println("2.00-1.10="+(2.00-1.10)); 浮点数在计算机里无法精确存储4. List<Integer>list=newArrayList<>(); for(inti=-3;i<3;i++){ list.add(i); } System.out.println("finishadd"+list); for(inti=0;i<3;i++){ list.remove(i); } System.out.println("finishremove"+list); remove（intindex）删除的是index处的数字删除后，数组的大小及其元素下标都会动态更改5. Strings="Hello"; s+="World"; s.trim(); System.out.println(s); trim()//去除字符串的头尾空格 
第218篇文章[]
软件构造作业-使用eclipse内置的git工具 前言 在哈工大软件构造的几个实验（作业）中，均要求使用git管理项目配置。同时，建议使用eclipseIDE进行项目开发。如果使用eclipse自带的git插件，就不需要额外安装和使用git，在eclipse中一并管理，比较方便。本文将实例演示使用内置git工具管理项目的常用方法。 步骤1新建远程仓库 在GitHub上创建远程仓库。软件构造课程的3个作业，只要点击链接，就可以自动生成仓库。在此我额外新建一个仓库作为演示。 1.1点击startaproject 1.2填写仓库信息 有仓库名和一些可选项。我选择添加README文件，因为如果仓库是空的，它不会生成默认分支，之后会有点麻烦。 1.3点击"Createrepository"确认 新建仓库完成后，应该看到这样的界面。 1.4*修改默认分支名为master 点击分支按钮，再点Viewallbranches，再点击右侧的铅笔图标，则如下图所示。 步骤2在eclipse中引入项目 2.1从Git中引入 打开eclipse，点击File->Import，选择ProjectsfromGit(withsmartimport)，点击Next。 2.2选择CloneURI 然后点击Next。 2.3填写相关信息 先复制远程仓库的地址。 再填写URI和自己的Github账号信息。Host和RepositoryPath会在填写URI后自动填写。勾选StoreinSecureStore，就可以记住密码，以后不用每次输入。 2.4剩下的操作 不断点击Next，再点Finish。完成的结果如下图。可以看到项目被引入工作空间了。 2.5*设置Java项目 右键项目，选择Properties. 选择ProjectNatures，AddJava，再点击OK和ApplyandClose。 再在buildpath中添加jdk和JUnit，具体操作略。 步骤3修改项目并提交到远程分支 3.1做出本地修改 新建文件new，写入123. 3.2提交到本地仓库 右键项目，选择Team->Commit  以下显示的是GitStaging。点击重叠的绿色加号，将修改放入stage。右侧是CommitMessage。必须填入，否则不能提交。 再点击右下角的Commit，即可提交。 3.3Push到远程仓库 右键项目，选择Team->PushtoUpstream Push成功后，会跳出如下窗口。 也可以在commit步骤直接点击CommitandPush，一步到位。 步骤4创建和切换分支 4.1在远程仓库创建新分支change 4.2在本地仓库添加Upstream的分支 右键->Team->Remote->ConfigureFetchfromUpstream  在Refmappings中点击Add ，Source选择change，输入后会稍微加载一段时间。 然后点击Next到Finish。 4.3新建并切换到本地分支change 右键->SwitchTo->NewBranch  填写name为change，完成。 4.4修改本地文件 4.5push到远程change分支 先commit，然后设置PushBranch"change"  填入Branch名为change。 再push就可以了。 4.6再切换回来 步骤5其它 本文中没有提到的有fetch，pull，解决冲突等问题。这些在本学期的软件构造中用不到，但在实际的多人协作中很常用。以后有时间可能会讨论。 
第219篇文章[1]
程序人生-Hello’sP2P哈工大计算机系统大作业 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 学 号 班 级 学 生 指导教师 计算机科学与技术学院 2021年6月 摘 要 本文将分析hello程序运行的全部过程，给出在执行每一步操作时计算机系统的操作方式来展现hello程序从开始到结束的生命历程。旨在通过hello程序的分析，更加深入地理解计算机系统各个部分地运作方式和作用，使读者能够对计算机系统产生一个较为整体的认知，同时对计算机系统中不同部分的任务和实现方式获得一定程度了解。 关键词：计算机系统；编译；链接；进程管理；存储管理 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P：FromProgramtoProcess 分为两步，第一步是生成可执行目标文件。在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的： linux>gcc-ohellohello.c GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。这个翻译过程可分为四个阶段完成，如下图。预处理阶段，预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。编译阶段，编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。汇编阶段，汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成可重定位目标程序（relocatableobjectprogram），并将结果保存在目标文件hello.o中。链接阶段。合并printf.o到hello.o程序中，得到hello文件，可执行目标文件。 第二步是加载到内存中运行。在Unix系统上运行，要输入文件名到shell中： linux>./hello 然后shell执行fork和execve加载可执行的hello文件，将hello目标文件中的代码和数据从磁盘复制到主存，处理器开始执行hello程序的main程序中的机器语言指令。在操作系统调度hello进程时，hello进程运行。 O2O:FromZero-0toZero-0 加载hello程序时，首先给对应进程一个虚拟内存。由虚拟内存地址到物理地址的翻译是OS和MMU合作完成。虚拟内存到物理内存的映射由4级页表储存，页表的缓存是TLB。内存有3级缓存cache。通过mmap程序从硬盘加载到虚拟内存。hello运行结束后内核回收内存，from0to0. 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 硬件：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件：Windows1064位；Vmware16；Ubuntu20.04LTS64位/ 开发工具：gcc/gdb/readelf 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 hello.c/hello.i/hello.s/hello.o/hello/hello.elf/objdump/objdump.s 1.4本章小结 本章对hello做了总体的介绍，简述了hello的p2p和020过程，列出并介绍了本次实验的环境和工具，阐明了这次实验中产生了中间产物。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 在编译之前进行的处理。C语言的预处理主要有三个方面的内容：1.宏定义；2.文件包含；3.条件编译。预处理命令以符号“#”开头。 2.2在Ubuntu下预处理的命令 应截图，展示预处理过程！ 2.3Hello的预处理结果解析 可以看到，预处理后的hello.i变成了3000多行，是因为#include的文件stdio.h等内容直接插入到程序文本中。 2.4本章小结 本章介绍了预处理的概念和作用，在ubuntu下预处理的方法，对预处理结果进行解析。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 利用编译程序从源语言编写的源程序产生目标程序的过程。编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含函数main的定义。 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令 应截图，展示编译过程！ 3.3Hello的编译结果解析 3.3.1数据 已初始化的全局变量sleepsecs放在data中。 局部变量放在栈中或寄存器中。如argc和argv从寄存器移动到栈中： 变量i储存在栈中： 字符串常量将储存在rodata中。 表达式和局部变量类似，会储存在栈和局部变量中，分步计算出结果。如argv[1]的计算： 3.3.2赋值 对全局变量sleepsecs的赋值应该是将要直接写入文件的data部分。 局部变量i的赋值通过mov指令实现。 3.3.3类型转换 处理int型变量sleepsecs时出现了隐式类型转换，把2.5转换成了2.C语言处理类型转换的方法如下： 3.3.4算术操作 i++编译为add指令。 3.3.5关系操作 可以看到，关系操作都编译为cmp指令。cmp指令设置条件码，读取不同的条件码获得不同的关系操作结果。 3.3.6数组操作 第41行和44行体现出取数组内容的方法。是通过mov指令中地址的偏移量处理的。 3.3.7控制转移 if控制编译为cmp命令结合je条件跳转命令。 for循环编译为3段，.L2初始化，.L3判断跳转，.L4为循环主体。 3.3.8函数操作 main函数的参数argc和argv分别在寄存器%edi和%rsi中被传递。 printf函数的参数通过%rdi,%rsi等传递，由call指令调用。 main函数结束后由leave指令返回。leave相当于popq%rbp+ret。 此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~3.3.x等按照类型和操作进行分析，只要hello.s中出现的属于大作业PPT中P4给出的参考C数据与操作，都应解析。 3.4本章小结 本章指出了编译的概念、命令，解析了编译结果中对C语言的数据和操作的具体处理方法。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编器（as）将汇编代码翻译成机器语言指令，把这些指令打包成可重定位目标程序（relocatableobjectprogram）。翻译成机器语言指令后机器可以直接读取分析。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。 4.2在Ubuntu下汇编的命令 应截图，展示汇编过程！ 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 ELF头 ELF头（ELFheader）以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型、机器类型、节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量。 节头部表 节头部表描述不同节的位置和大小，其中目标文件中每个节都有一个固定大小的条目（entry）。 重定位节 汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。 ELF重定位条目格式： 偏移量即offset，是需要被修改的引用的节偏移。信息包括symbol和type，symbol标识被修改引用应该指向的符号。ELF定义了32种不同的重定位类型，其中两种最基本的是R_X86_64_PC32和R_X86_64_32。加数即addend，是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。 符号表 符号表是由汇编器构造的，使用编译器输出到汇编语言.s文件中的符号。.symtab节中包含ELF符号表。这张符号表包含一个条目的数组。 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 机器语言指的是二进制的机器指令集合,而机器指令是由操作码和操作数构成的.汇编语言的主体是汇编指令.汇编指令和机器指令的差别在于指令的表示方法上,汇编指令是机器指令便于记忆的书写格式. 通过对比可以看出，操作数在汇编语言hello.s中用十进制表示，而在反汇编中objdump.s用十六进制表示，即在机器语言中是二进制表示。 分支转移地址表示，hello.s上为".L1"等段名称，在objdump.s为相对偏移的地址. 函数调用的地址表示在hello.s上为函数名，在objdump.s上为全0.这是因为还没有重定位，重定位后机器语言将用地址相对偏移量表示。 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 4.5本章小结 本章介绍了汇编，分析了可重定位目标文件，对比了汇编程序和机器程序的差别。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。 注意：这儿的链接是指从hello.o到hello生成过程。 5.2在Ubuntu下链接的命令 使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 首先是ELF头。 其余节的信息在节头部表中说明。 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 举例.interp 在节头部表信息如下： 在edb中： 该节的位置,大小都和节头部表描述一致,其他类推. 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 本次生成的汇编代码和hello.o生成的汇编代码的不同： 1. hello汇编代码中出现了更多函数，hello.o的汇编代码中只出现了main函数的名字，而hello的汇编代码中出现了_init，.plt等函数名。这体现了很多非hello.c源程序中生命的函数被链接到了hello中。 2.函数调用地址变化，在hello.o汇编代码中函数的地址不确定，在hello汇编代码中地址确定下来。 3.数据引用地址变化，在hello.o汇编代码中很多数据的地址不确定，在hello汇编代码中地址确定下来。 链接的过程： 1.在使用ld命令链接的时候,指定了动态链接器为64的/lib64/ld-linux-x86-64.so.2,_start程序调用hello.c中的main函数,libc.so是动态链接共享库,其中定义了hello.c中用到的printf、sleep、getchar、exit函数和_start中调用的__libc_csu_init,__libc_csu_fini,__libc_start_main.链接器将上述函数加入. 2.将所有的R_X86_64_PC32和R_X86_64_PLT32替换成计算好的地址。 重定位算法如下： 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 hello执行流程如下： （1）ld-linux-x86-64.so!_dl_start （2）ld-linux-x86-64.so!_dl_init （3）hello!_start （4）hello!__libc_csu_init （5）hello!_init （6）libc.so!_setjmp （7）hello!main （8）hello!puts@plt （9）ld-linux-x86-64.so!_dl_runtime_resolve_xsave （10）ld-linux-x86-64.so!_dl_fixup （11）ld-linux-x86-64.so!_dl_lookup_symbol_x （12）hello!exit@plt （13）libc.so!exit （14）hello!_fini 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 动态链接库中的函数在程序执行的时候才会确定地址，所以编译器无法确定其地址。为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。延迟绑定通过两个数据结构之间简洁但又有些复杂的交互来实现，即过程链接表（PLT）和全局偏移量表（GOT）。 过程链接表（PLT）：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。每个条目都负责调用一个具体的函数。 全局偏移量表（GOT）：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 对比信息，可见动态链接器解析函数的地址加入了信息中。 5.8本章小结 本章主要介绍了链接的概念与作用、hello的ELF格式,分析了hello的虚拟地址空间、重定位过程、执行流程、动态链接过程. （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 进程为用户提供了这样的假象，我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断地执行我们程序中地指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 Shell俗称壳，是指"为使用者提供操作界面"的软件。同时它又是一种程序设计语言。作为命令语言，它交互式解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令。它作为用户操作系统与调用其他软件的工具。 处理流程： （1）从终端读入输入的命令。 （2）将输入字符串切分，分析输入内容，解析命令和参数。 （3）如果命令为内置命令则立即执行，如果不是内置命令则创建新的进程调用相应的程序执行。 （4）在程序执行期间始终接受键盘输入信号，并对输入信号做相应处理。 6.3Hello的fork进程创建过程 由于hello不是一个内置命令，故解析后执行当前目录下的可执行目标文件hello，shell作为父进程通过fork函数为hello创建一个新的进程作为子进程。通过fork函数，子进程得到与父进程用户级虚拟地址空间相同但独立的一份副本，包括代码和数据段、堆、共享库、用户栈。hello进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程还可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。 6.4Hello的execve过程 子进程创建后，shell调用execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp。之后当出现错误时，例如找不到hello，execve才会返回到调用程序。 在execve加载了hello后，它调用启动代码，启动代码设置栈，并将控制转移给新程序的主函数main，此时用户栈已经包含了命令行参数和环境变量，进入main函数后开始逐步运行程序。 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象构成。 时间片：一个进程执行它的控制流的一部分的每一个时间段。 调度：在执行过程中，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。 用户态：进程运行在用户模式中时，不允许执行特权指令，比如停止处理器、改变模式位，或者发起一个I/O操作，也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。 核心态：进程运行在内核模式中时，可以执行指令集中的任何指令，并且可以访问内存中的任意位置。 用户态与核心态转换：程序在涉及到一些操作时，例如调用一些系统函数，内核需要将当前状态从用户态切换到核心态，执行结束后再改回用户态。 hello执行时存在逻辑控制流，多个进程的逻辑控制流在时间上可以交错，表现为交替运行。进程控制权的交换需要上下文切换。操作系统内核使用一种成为上下文切换的较高层形式的异常控制流来实现多任务。内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。 例如hello中对sleep的调用，内核中的调度器将hello进程挂起，进入内核模式，在执行结束后，内核会恢复hello被抢占时的上下文，回到用户模式。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 会出现四种异常：中断、陷阱、故障、终止。 会出现的信号：SIGSTP、SIGCONT、SIGKILL、SIFGINT等。 中断是来自I/O设备的信号，异步发生，中断处理程序对其进行处理，返回后继续执行调用前待执行的下一条代码，就像没有发生过中断。 陷阱是有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。帮助程序从用户模式切换到内核模式。 故障是由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。 终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程序会将控制返回给一个abort例程，该例程会终止这个应用程序。 程序运行时通过键盘操作给信号： （1）运行中不停乱按，将所输内容输出到屏幕上。 （2）运行中按ctrl-c，shell父进程收到SIGINT信号，信号处理函数将hello进程终止并回收。 （3）运行中按ctrl-z，shell父进程收到SIGSTP信号，信号处理函数将hello进程挂起。 （4）ctrl-z后运行fg命令发送SIGCONT信号继续执行hello。 （5）ctrl-z后运行kill命令发送SIGKILL信号杀死hello。 （6）ctrl-z后运行ps、jobs、pstree命令，输出相关信息。ps命令输出当前系统中的进程；jobs命令输出当前已启动的任务状态；pstree命令输出进程间的树状关系。 6.7本章小结 本章介绍了进程的概念和作用，结合fork和execve函数说明了hello进程的执行过程，之后分析了进程执行过程中异常和信号的处理问题。至此，可执行目标文件成功被加载至内存并执行。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 逻辑地址：程序代码经过编译后出现在汇编程序中地址.逻辑地址指的是机器语言指令中,用来指定一个操作数或者是一条指令的地址. 线性地址&虚拟地址：逻辑地址经过段机制后转化为线性地址（虚拟地址）,是逻辑地址到物理地址变换之间的中间层.在分段部件中逻辑地址是段中的偏移地址,然后加上基地址就是线性地址.是一个32位无符号整数,可以用来表示高达4GB的地址,也就是,高达4294967296个内存单元.线性地址通常用十六进制数字表示,值得范围从0x00000000到0xfffffff）程序代码会产生逻辑地址,通过逻辑地址变换就可以生成一个线性地址.如果启用了分页机制,那么线性地址可以再经过变换以产生一个物理地址.如果没有启用分页机制,那么线性地址直接就是物理地址. 物理地址：CPU地址总线传来的地址,由硬件电路控制（现在这些硬件是可编程的了）其具体含义.物理地址中很大一部分是留给内存条中的内存的,但也常被映射到其他存储器上（如显存、BIOS等）.在没有使用虚拟存储器的机器上,虚拟地址被直接送到内存总线上,使具有相同地址的物理存储器被读写；而在使用了虚拟存储器的情况下,虚拟地址不是被直接送到内存地址总线上,而是送到存储器管理单元MMU,把虚拟地址映射为物理地址. 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理是实现逻辑地址到线性地址转换机制的基础，段的特征有段基址、段限长、段属性。这三个特征存储在段描述符中，用以实现从逻辑地址到线性地址的转换。段描述符存储在段描述符表中，通常，我们使用段选择符定位段描述符在这个表中的位置。每个逻辑地址由16位的段选择符和32位的偏移量组成。 段基址规定了线性地址空间中段的开始地址。在保护模式下，段基址长32位。因为基址长度和寻址地址的长度相同，所以段基址可以是0-4GB范围内的任意地址。 和一个段有关的信息需要8个字节来描述，这就是段描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里所有的描述符都在一起集中存放，这就构成了一个描述符表，描述符表分为两种，GDT和LDT。 一些全局的段描述符，就放在"全局段描述符表(GDT)"中，一些局部的，例如每个进程自己的段描述符，就放在的"局部段描述符表(LDT)"中。 介绍一个完整的变换过程，给出一个完整的逻辑地址[段选择符：段内偏移地址]。首先看段选择符判断当前转换时GDT中的段还是LDT中的段，再根据相应寄存器得到其地址和大小。之后拿出段选择符中的前13位，在对应地址中查找到对应的段描述符，这样就知道了基址。根据基址和偏移量结合，就得到了所求的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 分页机制是实现虚拟存储的关键，位于线性地址与物理地址的变换之间设置。虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘上的数据被分割成块，这些块作为磁盘和主存之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页为大小固定的块来处理这个问题。每个虚拟页的大小固定。类似地，物理内存被分割为物理页，大小与虚拟页相同。 同任何缓存一样，虚拟内存系统必须用某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM，替换这个牺牲页。 页表是一个存放在物理内存中的数据结构，将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时读取页表。操作系统负责维护页表中的内容，以及再磁盘与DRAM之间来回传送页。 内存分页管理的基本原理是将整个内存区域划分成固定大小的内存页面。程序申请使用内存时就以内存页位单位进行分配。转换通过两个表，页目录表PDE（也叫一级目录）和二级页表PTE。进程的虚拟地址需要首先通过其局部段描述符变换为CPU整个线性地址空间中的地址，然后再使用页目录表和页表PTE映射到实际物理地址上。 7.4TLB与四级页表支持下的VA到PA的变换 36位VPN被划分成四个9位的片,每个片被用作到一个页表的偏移量.CR3寄存器包含L1页表的物理地址.VPN1提供到一个L1PET的偏移量,这个PTE包含L2页表的基地址.VPN2提供到一个L2PTE的偏移量,以此类推. 在对地址翻译的讨论中,我们描述了一个顺序的两个步骤的过程,1)MMU将虚拟地址翻译成物理地址,2)将物理地址传送到L1高速缓存.然而,实际的硬件实现使用了一个灵活的技巧,允许这些步骤部分重叠,因此也就加速了对L1高速缓存的访问.例如,页面大小为4KB的系统上的一个虚拟地址有12位的VPO,并且这些位和相应物理地址中的PPo的12位是相同的.因为八路组相联的、物理寻址的L1高速缓存有64个组和大小为64字节的缓存块,每个物理地址有6个(log264)缓存偏移位和6个(log264)索引位.这12位恰好符合虚拟地址的VPO部分,这绝不是偶然!当CPU需要翻译一个虚拟地址时,它就发送VPN到MMU,发送VPO到高速L1缓存.当MMU向TLB请求一个页表条目时,L1高速缓存正忙着利用VPO位查找相应的组,并读出这个组里的个标记和相应的数据字.当MMU从TLB得到PPN时,缓存已经准备好试着把这个PPN与这8个标记中的一个进行匹配了. 7.5三级Cache支持下的物理内存访问 得到物理地址PA后，通过其访问物理内存，物理地址由CI（组索引）、CT（标记位）、CO（偏移量）组成。首先使用CI进行组索引，每组8路，对8路的块分别匹配标记位CT，如果匹配成功且块的有效位为1则命中，根据数据偏移量CO取出数据返回。如果没有匹配成功则不命中，向下一级缓存中查询数据，顺序是L1缓存到L2缓存到L3缓存到主存。查询到数据后，放置策略是如果映射到的组有空闲块则直接放置，否则产生冲突，采用最近最少使用策略驱逐块并替换新块进入。 下图给出了三级Cache的大致构造： 7.6hello进程fork时的内存映射 Shell通过fork函数为hello创建新进程，当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面。 7.7hello进程execve时的内存映射 hello调用execve后，execve在当前进程中加载并运行包含在可执行目标文件中的程序，用hello程序有效地代替了当前程序。当加载并运行可执行目标文件时，需要以下几个步骤： （1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 （2）映射私有区域。为hello的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。 （3）映射共享区域。如果hello程序与共享对象（或目标）链接，比如标准C库libc.so,那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。下图给出了私有区域和共享区域在内存映射时的位置。 （4）设置程序计数器PC。execve做的最后一件事是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 物理内存缓存不命中称为缺页。假设CPU引用了磁盘上的一个字，而这个字所属的虚拟页并没有缓存在DRAM中。地址翻译硬件会从内存中读取虚拟页对应的页表，说明这个虚拟页没有被缓存，触发一个缺页故障。 这个异常导致控制转移到内核的缺页处理程序，处理程序首先判断虚拟地址A是否合法，如果不合法则触发段错误终止进程。如果合法则判断试图进行的内存访问是否合法，如果不合法则出发保护异常终止进程。如果合法则根据页式管理的规则，选择一个牺牲页，用新页替换掉，更新页表并再次触发地址翻译硬件进行翻译。 7.9动态存储分配管理 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器分为两种：显式分配器和隐式分配器。显式分配器要求应用显式地释放人设已分配地块。隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾回收器，而自动释放未使用的已经分配的块的过程叫做垃圾收集。 malloc使用的是显式分配器，通过free函数释放已分配的块。 下面分别介绍两种分配器： （1）隐式空闲链表分配器。我们可以将堆组织为一个连续的已分配块和空闲块的序列，空闲块是通过头部中的大小字段隐含地连接着的，这种结构为隐式空闲表。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块地集合。一个块是由一个字的头部、有效载荷、可能的填充和一个字的脚部，其中脚部就是头部的一个副本。头部编码了这个块的大小以及这个块是已分配还是空闲的。分配器就可以通过检查它的头部和脚部，判断前后块的起始位置和状态。 （2）显示空闲链表分配器。将堆组成一个双向空闲链表，在每个空闲块中，都包含一个pred和succ指针。一种方法是用后进先出（LIFO）的顺序来维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用。一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在的提高了内部碎片的程度。 7.10本章小结 本章介绍了hello的存储地址和存储空间，说明了虚拟内存相关知识，展示了各种地址表示的一步步转化，模拟了系统内部的一部分操作。并分析了进程的内存映射、缺页故障和缺页故障处理，还对动态内存分配器有了一定的了解。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 UnixI/O接口的统一操作： （1）打开文件。一个应用程序要求通过内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个标识符。 （2）Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。 （3）改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开始的字节偏移量。应用程序能够通过执行seek操作，现显式地设置文件的位置为k。 （4）读写文件。一个读操作就是从文件复制n个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个称为end-of-file的条件，应用程序能够检测到这个条件。在文件结尾处并没有明确的"EOF符号"。 （5）关闭文件。当应用程序完成了对文件的访问后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。 UnixI/O函数接口提供了以下函数共应用程序调用： （1）open：进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的。open将filename转换为一个文件描述符，并且放回描述符数字。 （2）close：进程通过调用close函数关闭一个打开的文件。关闭一个已关闭的描述符会出错。 （3）read：应用程序通过read函数来执行输入。read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误；返回值0表示EOF；否则，返回值表示的是实际传扫的字节数量。 （4）write：应用程序通过write函数来执行输出。write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章介绍了Linux的IO设备管理方法、UnixIO接口及其函数，并分析了printf函数和getchar函数。 （第8章1分） 结论 hello的一生经历了这些过程： （1）编写程序：源程序hello.c在编译器中完成。 （2）预处理：预处理器（cpp）将修改源程序，生成hello.i文件。 （3）编译：编译器（ccl）将hello.i文件翻译为汇编文件hello.s。 （4）汇编：汇编器（as）将hello.s文件翻译为二进制机器语言，生成可重定位目标文件hello.o。 （5）链接：链接器（ld）将可重定位目标文件hello.o和其他目标文件链接成为可执行文件hello。 （6）创建进程：shell进程调用fork函数为hello创建新进程，并调用execve函数运行hello。 （7）访问内存：通过MMU将需要访问的虚拟地址转化为物理地址，并通过缓存系统访问内存。 （8）动态申请内存：hello运行过程中可能会通过malloc函数动态申请堆中的内存。 （9）异常：hello运行过程中可能会产生各种异常和信号，系统会针对出现的异常和收到的信号做出反应。 （10）终止：hello运行结束后被父进程回收，内核删除相关数据。 以上，就是hello程序的一生。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.c源文件 hello.i预处理后的源文件 hello.s编译后的汇编代码 hello.o汇编后的可链接目标文件 hello可执行目标文件 hello.elf可执行目标文件的elf信息 hello.o.elf可链接目标文件的elf信息 objdump可执行目标文件的反汇编 objdump.s可链接目标文件的反汇编 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 《深入理解计算机系统第三版》 [2] 程序人生-Hello’sP2P_leolin037的博客-CSDN博客 [3] 程序人生-Hello’sP2P-dugudashen-博客园(cnblogs.com) （参考文献0分，缺失-1分） 
第220篇文章[]
SC（二） Iterator迭代器学习体会 做Lab2的时候用到了，简单了解了一下Iterator的使用。 Iterator可以遍历并选择列中的对象，在Java中只能单向移动 （1）iterator()：返回一个Iterator。例： Iterator<Edge<L>>it=edges.iterator(); （2）next()：获得序列中的下一个元素。例： Edge<L>a=it.next(); 第一次调用Iterator的next()方法时，它返回序列的第一个元素。 （3）hasNext()：检查序列中是否还有元素。例： while(it.hasNext()){ Edge<L>a=it.next(); } (4)remove()：将迭代器新返回的元素删除 it.remove(); Iterator<Edge<L>>it=edges.iterator(); while(it.hasNext()){ Edge<L>a=it.next(); if(){ flag=a.getWeight(); it.remove(); break; } } 
第221篇文章[]
SC（四） 两类ADT复用手段 继承 用于Class之间 父类和子类之间的关系，通过extends产生继承关系 子类可以直接访问父类中的非私有的属性和行为，无法继承父类中私有的内容 一个类只能有一个直接父类，但多个类可以继承一个父类；可以多层继承，例如A->B,B->C 遵循LSP原则 委派 用于Object之间，运行时建立动态链接 建立委派（rep存储/不存储）->动态传入（client负责）->实际调用 
第222篇文章[1]
2021-06-23 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算学部学 号1190201120班 级1936602学生卜铎 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文通过以hello.c程序为例，介绍了程序在计算机上的执行过程，包括预处理，编译，汇编，链接，进程管理等过程。 关键词：CSAPP；程序的生命周期；P2P；020 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介hello.c经过预处理，编译，汇编，链接之后，最终可以作为目标程序执行。在shell中启动后，shell会使用fork为其创建并生成子进程，这样hello从Program转换为Process，这是P2P的过程。完成P2P过程后进入020过程shell为程序调用execve函数，execve函数启动加载器，为该进程分配独立的虚拟内存。进入程序后，程序加载物理内存，然后进入main函数执行目标代码。CPU为程序分配时间片执行指令，调用系统I/O。程序结束后shell父进程回收hello进程，释放占用的内存，删除数据结构。这是020过程。1.2环境与工具Ubuntu20.02，Window10gdb，edb，vim，hexedit，objdump，Code::BlocksIDE1.3中间结果hello.c(C语言源程序) hello.i(hello.c预处理之后的程序文本) hello.s(hello.i编译成汇编语言之后的程序文本) hello.o(hello.s生成的二进制文件) hello(可执行的hello二进制文件) 1.4本章小结本章总括了本次实验的主要内容。（第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理是预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如hello.c中第一行的#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件拓展名。 2.2在Ubuntu下预处理的命令gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析预处理后hello.c中包含#的语句变成以#开头的字符串，描述的是运行库在计算机中的位置，以便于接下来的编译阶段。 2.4本章小结本章介绍了预处理的概念及作用，在Ubuntu下预处理的语句，以及预处理后的文件变化。预处理是一个.c源程序转化为可执行文件的第一步。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译是编译器将预处理得到的.i文件生成相应的汇编文件的过程，以.s作为文件拓展名注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 3.3Hello的编译结果解析1） 该字符串对应"Usage:Hello学号姓名！\n"，中文被编码为UTF-8格式 2）全局变量sleepsecs 初始化为2后存放在.rodata字节，即只读数据节。3）控制转移 如上图表示比较即时数3和地址%rbp-0x20处的值，如果相等则跳转到.L2函数。4）赋值操作 如上图5）算术操作 设%rax中存储的数为x，则上述表达式为x=x+166）数组 7）函数操作 3.4本章小结本章介绍了编译的概念和作用，以及Ubuntu中的编译指令，简单分析了汇编文件及其中的汇编代码。 （第3章2分） 第4章汇编4.1汇编的概念与作用 汇编是汇编器（as）将hello.s翻译成机器语言指令的过程。在汇编阶段，汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。4.2在Ubuntu下汇编的命令ashello.s-ohello.o 4.3可重定位目标elf格式 ELF头：以一个描述了生成该文件的系统的字的大小和字节顺序的16字节的序列开始。 节头表，包含魏晋之出现的各个节的类型，地址，偏移量，大小，旗标，链接，对齐等信息。.text已编译程序的机器代码，类型为PROBITS，旗标为AX，即分配内存且可执行.rel.text一个.text节中位置的列表.data已初始化的全局和静态变量，类型为PROBITS，旗标为WA，即分配内存且可修改.bss未初始化的全局和静态变量，类型为NOBITS，即暂无存储空间。该节在开始时不占据实际的空间.rodata只读数据.symtab符号表，装载符号信息.comment包含了版本控制信息.note.CNU-stack标记可执行堆栈.strtab一个字符串表，包含.symtab和.debug节中的符号表，以及节头部的节名字 符号表，包含main定义和引用的符号信息4.4Hello.o的结果解析 在hello.o中，在只读数据的使用上，反汇编得到的结果是先用$0x0替代，且在替代的同时，反汇编代码也在下方标注了一些重定位信息；而在hello.s中我们使用.LC0,.LC1来替代汇编代码中只读变量的出现。在hello.o中，对函数的调用上，在call之后使用的是对应命令在main函数中的便宜了而非函数名；而在hello.s中，直接call函数名。说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。4.5本章小结本章介绍了汇编的作用及概念，在Ubuntu中汇编指令的使用，同时通过readelf工具查看了汇编器生成的可重定位目标elf格式并进行了简单分析。在这一章中，hello.c由文本文件变成了二进制文件，汇编器将我们之前得到的hello.s转化成机器语言。 （第4章1分） 第5章链接5.1链接的概念与作用链接是将各种代码和数据片段收集并组合成一个单一文件的过程注意：这儿的链接是指从hello.o到hello生成过程。5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式ELF头： 节头部表： 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 各指令对应的地址为重定位之后的虚拟内存的地址，从0x400000开始，而hello.o是从0000000开始此外在开头hello还多了.init，.fini，.plt，.plt.got节，分别是程序初始化执行的代码，程序终止时需要执行的代码，动态链接中的过程连接表，动态链接中的全局偏移表5.6hello的执行流程 ld-2.27.so!_dl_start0x7f54dc67cdf0ld-2.27.so!_dl_init0x7f54dc6a85f8hello!_start0x400500libc-2.27.so!__libc_start_main0x7fbdf0cccab0hello!puts@plt0x400410hello!exit@plt0x400440hello!printf@plt0x4004c0hello!getchar@plt0x4004f05.7Hello的动态链接分析 通过之前使用readelf时得到的可执行文件hello各节的相关信息，我们可以得到.got和.got.plt的地址。 在DataDump中查看对应地址的内容: 可以看到在_dl_init之前，对应的地址内容为空。而在DataDump之后，对应地址内容不再为空，而是根据延迟绑定的策略调整对应的内容。5.8本章小结本章介绍了链接的概念及作用，链接是完成hello.c向可执行文件转换的最后一步。在本章中，通过readelf查看了可执行文件hello的格式，通过edb查看了hello的虚拟空间。对hello的重定位过程和执行流程以及动态链接过程进行了简单的分析。（第5章1分） 第6章hello进程管理6.1进程的概念与作用进程是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。通过进程，我们会得到一种假象，好像我们的程序是当前唯一运行的程序，我们的程序独占处理器和内存，我们程序的代码和数据好像是系统内存中唯一的对象。6.2简述壳Shell-bash的作用与处理流程Shell是一个命令解释器，主要用于用户和系统的交互，它解释由用户输入的命令并把它们送到内核。shell是操作系统内核常驻内存的部分，可以被看作一个由C语言编写的终端程序。Bash，全称为Bourne-AgainShell。它是一个为GNU项目编写的Unixshell。bash脚本功能非常强大，尤其是在处理自动循环或大的任务方面可节省大量的时间。处理流程： //解析引用并分割命令行为各个单词，各单词称为token。其中重定向所在的token会被保存下来，直到扩展步骤结束后才进行相关处理，如进行扩展、截断文件等//检查命令行结构。主要检查是否有命令列表、是否有shell编程结构的命令，如if判断命令、循环结构的for/while/select/until，这些命令属于保留关键字，需要特殊处理。//对第一个token进行别名扩展。如果检查出它是别名，则扩展后回到(2)再次进行token分解过程。如果检查出它是函数，则执行函数体中的复合命令。如果它既是别名，又是函数(即命令别名和函数同名称的情况)，则优先执行别名。在概念上，别名的临时性最强，优先级最高。//进行各种扩展。扩展顺序为：大括号扩展；波浪号扩展；参数、变量和命令替换、算术扩展(如果系统支持，此步还进行进程替换)；单词拆分；文件名扩展。6.3Hello的fork进程创建过程./hello运行之前生成的可执行文件hello，shell先判断是否是内置命令，shell判断出不是内置命令，加载可执行文件hello，通过fork创建一个子进程，子进程得到与父进程用户级虚拟地址空间相同的一份副本。子进程与父进程有不同的PID。 6.4Hello的execve过程子进程通过调用execve函数来调用加载器，加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。6.5Hello的进程执行系统中的每个程序都运行在某个进程的上下文中。上下文由程序正确运行所需的状态组成，这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。开始时由于我们再shell中运行hello，所以hello初始运行在用户模式，在hello进程调用sleep之后陷入内核模式，内核处理休眠请求主动释放当前进程，并将hello进程从运行队列中移出加入等待队列，定时器开始计时，内核进行上下文切换并将当前进程的控制权交给其他进程。当定时器计数到我们作为参数传入的暂停秒数之后会发送一个中断信号，此时进入内核状态，内核处理信号将hello进程从等待队列中移出重新加入到运行队列，恢复之前保存的hello的上下文，hello进程继续运行。 6.6hello的异常与信号处理 图6.6.1正常运行 图6.6.2按下Ctrl-C后程序停止 图6.6.3输入乱码时后续正常运行 图6.6.4输入回车时换行 图6.6.5输入Ctrl-Z后程序停止运行 图6.6.6输入Ctrl-Z程序停止后再输入ps，可以看到hello进程未被回收，只是被挂起。 图6.6.7输入jobs可以看到hello的状态是停止 图6.6.8输入fg后，程序重新开始运行 图6.6.9输入pstree后 图6.6.10使用kill命令杀死进程[4] 6.7本章小结本章阐述了进程的概念及作用，简要说明了Shell-Bash的概念和作用以及shell的处理流程。分析了hello的fork进程创建过程和execve过程，hello的进程执行。并且简要实践的hello的异常与信号处理。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址 逻辑地址：程序代码经过编译后出现在汇编程序中地址。逻辑地址由选择符（在实模式下是描述符，在保护模式下是用来选择描述符的选择符）和偏移量（偏移部分）组成。 线性地址：逻辑地址经过段机制后转化为线性地址，为描述符:偏移量的组合形式。分页机制中线性地址作为输入7.2Intel逻辑地址到线性地址的变换-段式管理段式内存管理方式就是直接将逻辑地址转换成物理地址，也就是CPU不支持分页机制。其地址的基本组成方式是段号+段内偏移地址。 在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值(index)。 首先给定一个完整的逻辑地址[段选择符：段内偏移地址], 1）看段选择描述符中的T1字段是0还是1，可以知道当前要转换的是GDT中的段，还是LDT中的段，再根据指定的相应的寄存器，得到其地址和大小，我们就有了一个数组了。 2）拿出段选择符中的前13位，可以在这个数组中查找到对应的段描述符，这样就有了Base，即基地址就知道了。 3）把基地址Base+Offset,就是要转换的下一个阶段的地址。 7.3Hello的线性地址到物理地址的变换-页式管理系统将每个段分割为被称为虚拟页（VP）的大小固定的块来作为进行数据传输的单元，虚拟地址分为虚拟页号VPN和虚拟页偏移量VPO，根据位数限制分析可以确定VPN和VPO分别占多少位是多少。 通过页表基址寄存器PTBR+VPN在页表中获得条目PTE，一条PTE中包含有效位、权限信息、物理页号。 如果有效位是0+NULL则代表没有在虚拟内存空间中分配该内存。 如果是有效位0+非NULL，则代表在虚拟内存空间中分配了但是没有被缓存到物理内存中。 如果有效位是1则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，与虚拟页偏移量共同构成物理地址PA7.4TLB与四级页表支持下的VA到PA的变换根据当前当前使用页的大小确定VPO的位数，再根据虚拟地址的位数，求出VPN的位数。 根据TLB的结构确定TLBI的位数，结合已求出的VPN就能得到对应的TLBT。根据TLBI和TLBT找到对应的TLB存储块，块中的内容就是PPN，又PPO和VPO相等。所以将得到的PPN和PPO组合起来就得到了PA。7.5三级Cache支持下的物理内存访问先将虚拟地址转换为物理地址，再对物理地址进行分析，物理地址一般由CT、CI、CO组成，用CI位进行索引，如果匹配成功且valid值为1，则称为命中，根据偏移量在L1cache中取数，如果不命中，在分别到L2、L3和主存中重复上述过程7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct，区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任意一个后来进行写操作时，写时复制机就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理在虛拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。图9-6展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页,在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。 接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图9-7展示了在缺页之后我们的示例页表的状态。 7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域，称为堆(heap)(见图9-33)。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长(向更高的地址)。对于每个进程，内核维护着一个变量brk(读做“break")，它指向堆的顶部。 分配器将堆视为一组不同大小的块(block)的集合来维护。每个块就是一个连续的虚拟内存片(chunk)，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 ●显式分配器(explicitallocator)，要求应用显式地释放任何已分配的块。例如，C标准库提供–种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。C++中的new和delete操作符与C中的malloc和free相当。 ●隐式分配器(implicitallocator)，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器(garbagecollector)，而自动释放未使用的已分配的块的过程叫做垃圾收集(garbagecollection)。例如，诸如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。7.10本章小结本章简单介绍了hello的存储器地址空间、intel的段式管理、hello的页式管理，TLB与四级页表支持下的VA到PA的变换，三级Cache支持下的物理内存访问，还介绍了hello进程fork时的内存映射，hello进程execve时的内存映射，缺页故障与缺页中断处理，动态存储分配管理。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件设备管理：unixio接口8.2简述UnixIO接口及其函数接口： 1）打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 2）Shell创建的每个进程都有三个打开的文件。标准输入（描述符为0），标准输出（描述符为1），标准错误（描述符为2）。 3）改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置k。 4）读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时执行读操作会触发一个称为end-of-file（EOF）的条件，应用程序能检测到这个文件。在文件结尾处并没有明确的“EOF符号”。 类似的，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 5）关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。 函数： 8.3printf的实现分析printf函数的源代码 vsprintf函数的源代码： intvsprintf(char*buf,constcharfmt,va_listargs){charp;chartmp[256];va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!='%'){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); } 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章主要介绍了hello的IO管理，包括：Linux的IO设备管理方法，UnixIO接口及其函数，printf和getchar的实现分析。（第8章1分）结论 hello.c经历了预处理，编译，汇编，链接，运行，程序结束回收进程等过程。hello.c在经过预处理，编译，汇编，链接过程后，一步步转化为可执行文件。而在运行过程中，又获得了跌宕起伏的冒险经历，创建子进程，运行程序，执行命令，对异常和信号进行处理。 （结论0分，缺失-1分，根据内容酌情加分） 附件hello.c(C语言源程序) hello.i(hello.c预处理之后的程序文本) hello.s(hello.i编译成汇编语言之后的程序文本) hello.o(hello.s生成的二进制文件) hello(可执行的hello二进制文件) （附件0分，缺失-1分） 参考文献为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp.（参考文献0分，缺失-1分） 
第223篇文章[]
SC（三） 重写（Override）和重载（Overload） 重写（Override） 重写是子类对父类允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。 重写方法的spec保持不变/增强 重写方法是子类对父类方法的修改/扩展，个性化过程 finalmethod不可被重写 在运行时决定调用哪个方法 重载（Overload） 重载：在同一个类里面，相同的方法名，不同的参数列表。常见构造器的重载 重载和重写是完全不同的，二者没有任何关系。 参考资料：https://www.runoob.com/java/java-override-overload.html 
第224篇文章[]
SC（一） 关于对“过早的优化是万恶之源”的理解 “过早的优化是万恶之源”这句话出自DonaldKnuth的《计算机编程艺术》 其实在接触软件构造课程之前，我并没有真正的去体会这句话。此前的编程目的都是为了学习一门编程语言，或者是学一些数据结构和算法。从这些角度出发，代码层的程序优化似乎是一件非常重要的事。有一段时间非常执着于对复杂度甚至代码简洁程度的优化，可以优化的复杂度都进行优化，对复杂度的优化超出我的能力范围后就开始简化代码。因为那时候需要写的代码量很小并且是面向过程的编程，所以并没有带来非常大的困扰。 当我被软件构造实验按在地上反复摩擦的时候，我终于开始正视这句话。在多次因为尝试对某一段代码进行优化结果导致连锁反应整个程序崩溃的时候，我也放弃了这种执着于从一开始就优化程序的想法。一个程序应该是先实现它需要实现的基本功能，再考虑优化问题。一个正确的程序，远比一个快速的程序重要的多。在遵循设计原则的基础上，完成一个正确的程序是首要任务。 优化应该是基于需求的，在没有明确真正需求的情况下过早的优化只能造成精力和时间的浪费。 对程序性能进行优化时，应该依赖性能分析数据，而不是靠直觉推断是否需要优化，理论数据和实际数据都有可能相去甚远，更不用说靠直觉产生的“假想数据”。 在了解需求和性能分析数据的情况下，应该选择相对更优的优化指标。你无法优化一切，在各种指标中选择更符合优化目标的进行优化。 
第225篇文章[]
2021-07-07 解决Thepackagejava包isnotaccessible问题包无法引进的问题，如下图：首先第一步查看自己是否在创建工程的时候不小心创建了module-info.java文件，如果是的话，这个时候有两种解决方案第一种eclipse自动给你生成的解决方案，你双击它后，可以在module infor.java文件生成如下代码：此时就会发现错误都解决了。 第二种比较粗暴：直接删除这个module-info.java 如果不是因为module-info.java文件的原因，那么网上有很多博客可以解决这个问题。 
第226篇文章[]
关于Java中的异常处理控制流 在软件构造实验中，我们使用java语言标准库的各种方法，时不时遇见Eclipse提示需要处理某某Exception。Eclipse一般会提示两种修改当前代码的方法以消除编译错误。一个是用trycatch语句块包围可能抛出异常的代码，另一个是为当前正在编写的方法添加throws声明。两种方法是有区别，但是以前对此不清不楚。在做实验三的时候，因为代码需要，学习了一下，现在在这里记录一下。 1.对可能抛出异常的代码使用try-catch-finally语句包围。 那些可能抛出异常的代码应该写在try中。 catch可以有多个列在try后面，分别处理相应的异常。几个catch语句块是有顺序的，发生异常时从前往后寻找匹配异常的语句块。只会匹配并执行一个catch语句块，然后控制流离开catch们，继续往下执行（finally或方法中剩余内容），try中的剩余内容不会再执行了。 若有两种异常需要处理，其中一个异常类型是另一个异常类型的子类型，那么子类型异常的特殊的处理得放在前面，对于其他父类型异常比较一般的处理就放在后面。如果catch(父类型异常){}在catch(子类型异常){}之前，子类型异常的处理就总是会被截胡永远没机会执行了，会有编译错误提示这一点。 finally语句块是总是要执行的内容，即有没有发生异常都要执行finally。finally理论上是保证只要执行了try，不管有没有执行catch，不管catch执行什么，finally语句块都执行。例如，catch中最后直接return，在真正离开本方法之前，还是会执行finally语句块，不过已经确定的返回值不会受到finally中相应赋值语句的影响。实际上有些情况会导致finally没机会执行，比如jvm进程已经在catch执行后结束了。 2.为当前方法添加throws声明。 那些可能抛出异常的代码直接写在当前方法中即可。 这会导致相应的异常转发到当前方法的调用者调用当前方法处抛出，由调用者决定如何处理。发生异常时，直接离开当前方法不再执行，控制流回到调用者调用这个方法的地方，并继续执行调用者方法中关于这个异常的处理逻辑。如果在调用链中每级方法都声明throws把异常处理推给上级，连main方法也如是，那么调用main方法的jvm内部逻辑会处理相关异常。 实际上，关于异常处理还有很多细节。不过在实验三中知道这些就差不多了吧。。。 
第227篇文章[]
关于Java中方法的重写（Override） 在java中，子类的非静态成员方法可以重写（Override）父类中的对应的方法。在使用父类引用调用相应的方法时，会根据运行时引用所指向的对象的实际类型动态调用子类或父类对应的方法，这就是多态了。软件构造课的考试题中有这样的题： 考察什么是正确的重写。 在java中，我们使用@Override注解让编译器为我们检查是否正确重写，编写子类时也是用IDE直接生成代码，因此有些细节就没有注意到，这里记录一下。 0.根据LSP规则，子类类型也是父类类型，需要父类类型的地方子类类型可以顶上去。因此，通过父类引用动态调用方法，调用的子类方法必须是兼容的。 1.private方法不能参与重写。private完全是仅本类可见的，自然不能被其他类（包括子类、父类）感知，动态调用之类的显然也不行了。 2.子类方法或不throws任何异常，或throws父类方法所声明的那些异常。子类方法throws的异常类型可以是父类方法throws的异常类型的子类型，这很好理解，父类方法要求throwsException，子类方法throwsIOException，IOException也是EXception，因此子类方法满足了要求。 3.子类方法返回值类型必须也是父类方法返回值类型。也就是说，子类方法或返回一样的类型，或返回父类方法返回类型的子类型。这也很好理解，父类方法returnNumber，子类方法returnDouble，Double也是Number，因此子类方法满足了要求。 4.理论上，根据LSP，还可以允许子类方法的参数类型是父类方法参数类型的父类型。即子类方法(List<?>scores)而父类方法(ArrayList<?>scores)，因为ArrayList<?>也是List<?>，参数传递起来是兼容的。实际上，在java中不允许这种重写。这某种意义上说与java的另一个特性是有关的，即重载：java允许一系列同名但参数类型不完全相同的方法写在一个类，并在编译阶段根据实参类型确定某段代码中调用的一系列重载方法究竟是哪一个。如果允许前面说的这种重写，就会出现子类中可以有多个方法重写父类方法，这不是乱套了？因此java不允许这种重写。其实这一问题可以有多种方法解决，比如增加某种关键字，在子类中明确指定哪个方法重写父类的哪个方法，但是这样非常不简洁。实际上，java采用重写加重载可以达到类似的效果，即用子类方法(ArrayList<?>scores)重写父类方法(ArrayList<?>scores)，然后子类方法(ArrayList<?>scores)直接调用另一个重载子类方法(List<?>scores)，实际效果相当于子类方法(List<?>scores)重写父类方法(ArrayList<?>scores)。 
第228篇文章[1]
2021-07-01 目 录 第1章C语言的语言元素-5- 1.1程序结构-5- 1.1.1循序结构-5- 1.1.2分支-5- 1.1.3循环-6- 1.1.3.1for语句-6- 1.1.3.2while语句-6- 1.1.3.3do-while语句-6- 1.1.3.4break语句和continue语句-7- 1.2类型-7- 1.2.1整数类型-7- 1.2.2浮点类型-8- 1.2.3数组类型-8- 1.2.4结构体类型-8- 1.3量-8- 1.3.1常量-8- 1.3.2变量-9- 1.3.2.1全局变量-10- 1.3.2.2局部变量-10- 1.4指针与引用-10- 1.5函数-11- 第2章汇编语言的语言元素-12- 2.1内存映像与ELF文件-12- 2.2程序结构-13- 2.2.1整体结构-13- 2.2.2 分支-14- 2.2.3循环-17- 2.3类型-18- 2.3.1整数类型-18- 2.3.2浮点类型-18- 2.4栈和寄存器-19- 2.5函数-19- 2.5.1调用约定-19- 2.5.1.1cdecl约定-19- 2.5.1.2fastcall约定-20- 2.5.1.3thiscall约定-20- 2.5.1.4stdcall约定-20- 2.5.2示例-20- 第3章C语言的汇编实现-22- 3.1基本数据类型的操作-22- 3.1.1整数类型的计算-22- 3.1.1.1加法，减法-22- 3.1.1.2乘法，除法，求模-24- 3.1.1.3左移，右移-28- 3.1.1.4与，或，非-29- 3.1.1.5比较-31- 3.1.1.6求补（取反），异或-33- 3.1.2浮点类型的加载与运算-34- 3.1.2.1浮点数传送-35- 3.1.2.2浮点数四则运算-35- 3.1.2.3浮点数比较-37- 3.1.3基本类型的转换-38- 3.1.3.1整数与整数-38- 3.1.3.2整数与浮点数-41- 3.1.3.3浮点数与浮点数-43- 3.2寻址问题-43- 3.3函数-44- 3.4C语言程序结构的实现-44- 3.4.1分支-44- 3.4.2循环-44- 3.4.3编译器优化循环-45- 3.5指针-46- 3.6C++语言-46- 第4章C与汇编的优缺点分析-48- 参考文献-49- 第1章C语言的语言元素 满分15分 C语言是一种面向过程的编译型语言。下面，我们来说一说C语言的各种语言元素。 任何程序，本质上是数据和操作步骤（即计算）的结合体。要解读一中编程语言，可以从其对数据的描述和对计算方法的描述两个角度考察。 1.1程序结构 1.1.1循序结构 循序结构是最基本的程序结构。在C语言中，一系列语句按顺序罗列即为循序结构。使用{}将语句包围，形成语句块（body），同时成为变量的作用域。关于作用域，在后文还会提及。 1.1.2分支 if语句，或者说条件判断，可以说是所有程序的灵魂，镶嵌于循序语句们中。没有条件判断实际上是写不成真正意义上的程序的。C语言中if语句结构如下： if(/*条件1*/){ /*满足条件1执行*/ } elseif(/*条件2*/){ /*满足条件2执行*/ } else{ /*不满足上述条件执行*/ } 在if和else的组合中，无论条件如何，两个语句块（body，一条语句或由{}包围的多条语句）只会执行一个而另一个不执行，然后就离开if-else语句。if-else将两个语句块连接成了一个语句块，可见elseif其实是else与if的组合。上述结构等价于： if(/*条件1*/){ /*满足条件1执行*/ } else{ if(/*条件2*/){ /*满足条件2执行*/ } else{ /*不满足上述条件执行*/ } } 1.1.3循环 1.1.3.1for语句 在C语言中，有三种形式的循环语句：for，while，do-while。 for语句最为常用。 for(/*初始化*/;/*循环条件*/;/*步长操作*/){ /*循环体*/ } 在初始化语句中一般对要用于循环遍历和条件判断的变量进行初始化。在C99标准中，允许在初始化语句中声明变量。初始化语句只执行一次。每次执行循环体前，先判断循环条件是否为真（非零），只有为真在执行，否则程序离开循环语句。执行完循环体后，执行步长操作，通常操作用于循环遍历和条件判断的变量。然后，流程回到执行循环条件判断之前，开始下一次循环。 1.1.3.2while语句 其次while语句也比较常用。 while(/*循环条件*/){ /*循环体*/ } 每次执行循环体之前，先判断是否满足循环条件。循环条件为真就执行循环体。否则不执行，程序离开while语句。执行完循环体后程序流程回到判断循环条件前，准备进入下一次循环。 while相当于for的简化版，因此也有人喜欢这样写： for(;/*循环条件*/;){ /*循环体*/ } 1.1.3.3do-while语句 do-while语句使用得比较少。它与while语句类似。 do{ /*循环体*/ } while(/*循环条件*/); 不同的是，先执行循环体、后判断循环条件。 1.1.3.4break语句和continue语句 提到循环就必须提到break和continue，它们使流程控制在没有goto的情况下也足够灵活。在循环体中使用break语句，实现不执行完循环体直接离开循环语句。显然，对于for语句，也不会再执行循环条件判断或步长操作。在循环体中使用continue语句，实现将流程直接跳到本次循环体执行结束。可知，对于for语句，continue之后还会执行步长操作，然后进入下一次循环。 加上break和continue，三种循环语句一定程度上可以互相转化（但还是有一些细节差别）。 1.2类型 在C语言中，类型的概念非常重要，任何数据的表示都离不开类型。类型的本质，就是对数据的存储方式的抽象而又具体的描述。从实现上看，类型最终就是数据总大小以及数据成员的偏移量。同面向对象的编程语言不同，在C语言中，操作不是严格绑定在类型中的，而属于外置的。因为对于存储器上的一段数据，C语言允许将它描述成任意类型，并强制实施操作，而其正确性由程序员保证。 话虽如此，类型之间有区别，操作的不同非常关键。我们说到类型的实现，最终还是要说操作的实现。对于典型的数据类型，C语言确保通过编译器给出良好的操作实现。以下是几个典型的类型。 1.2.1整数类型 C语言提供了非常多的整数类型，虽然到具体平台，这些类型的实现只有几种。在C语言中，整数类型首先分为： signed：有符号类型，不明确标注默认为有符号类型 unsigned：无符号类型 有无符号在存储上没有本质区别，仅仅在于是否将最高有效位解释为符号位，主要区别在涉及大小判断时发生。一些常用类型如下，都可以标记为有符号或无符号： char：又称字符型，1字节 short：短整型，2字节 int：整型，4字节 longlong：长长整型，8字节 然而，由于历史原因，C语言标准不严格保证上述常用类型的大小严格等于上述经典大小。因此，当程序中需要特别严格指定整型数据大小时，出于移植性考虑，需要使用标准intN_t和uintN_t类型： int8_t与uint8_t：1字节的有符号和无符号整数 int16_t与uint16_t：2字节的有符号和无符号整数 int32_t与uint32_t：4字节的有符号和无符号整数 int64_t与uint64_t：8字节的有符号和无符号整数 等等。 1.2.2浮点类型 C语言中通常使用两种浮点类型： float：在遵循IEEE754的机器上对应规定中的中32位单精度浮点的规定。 double：在遵循IEEE754的机器上对应规定中的中64位双精度浮点的规定。 现在的机器大都遵循IEEE754标准。在许多情况下，我们使用浮点数做数学计算，只需要符合一些浮点数的基本要求就可以，并不特别关心细节。 1.2.3数组类型 C语言中的数组类型，本质上是将相应的类型的数据在存储器上地址连续地存储数组长度那么多个。因此，在实质上与多个在存储器上地址连续的相应类型的数据没有区别，只是可以使用一个数组名加索引号的方式访问。具体而言，即是通过数组名得到基址、索引号计算得到偏移地址，最终计算出相应数组元素的地址并访问。 1.2.4结构体类型 结构体对于描述复杂数据非常实用。本质上是将相应类型的数据依结构体描述的次存放在该结构体类型数据的存储空间上。因此，在实质上与多个在存储器上对应位置的相应类型的数据没有区别，只是可以使用结构体名加成员名的方式访问。具体而言，即是通过结构体名得到基址、成员名计算得到偏移地址，最终计算出相应结构体成员的地址并访问。可以说数组就是一种结构体，而其成员的名称分别为0,1,2 这样的数字（索引号）。 1.3量 C语言中量可分为常量和变量。本质上都是某种类型的数据在程序中的具体安排。 1.3.1常量 常量即程序运行过程中不可改变的量，我们编写程序的过程中已经明确写定的各种数值、const结构体等都是常量。常量可以分为两种，一般来说，各种写定的数字是无名的（因而他们会在机器指令的立即数中记录，后文会提及），另一种是通过const关键字定义的，是有名的，本质上就是一种从未改变的变量，后文对变量的讨论对其也适用。 1.3.2变量 变量的本质就是与变量名关联的一段存储空间，通过使用变量名实现对该存储空间的直接引用。变量最基本的属性，除了类型，就是存储位置。当然，变量的其他属性还包括作用域，权限等。const关键字，可以将变量声明为前文所述的常量，其保证通过变量名直接引用该变量时，不能有修改操作，否则产生编译错误。 C语言中，变量存在作用域。只有在合适的作用域中才能访问相应的变量，其基本规则为，源文件作为顶级域，{}包围产生的语句块（body）嵌套组合形成一级一级的作用域。变量的作用域是自身所在的域加上这个域的所有下级域。但是。C语言中，变量是可以重名的，这就需要屏蔽规则确定当前在访问哪个变量。对于某个作用域，在一个级别中不能存在两个同名的变量。这就是说，与某个变量同名的变量或来自上级域，或来自下级域，或在另一个无关域。 inti=0; //顶级域 intget(){ inti=1; //函数域 Intj=-1; //语句块1 { inti=2; //语句块1的域 { inti=3; //语句块1中的次级域 printf("i=%d\n",i); //打印i=3 printf("j=%d\n",j); //打印j=-1 } printf("i=%d\n",i); //打印i=2 } //语句块2 { inti=4;//语句块2的域 printf("i=%d\n",i);//打印i=4 } //定义重名变量导致编译错误 //inti=5; } printf都只能访问到本级定义的那个i，来自上级的i被屏蔽了，但来自上级的j没有被屏蔽，下级的i属于下级的语句块，即属于其他语句块，是不可见的。 1.3.2.1全局变量 一般来说全局变量可以分为两种，它们都是直接声明在源文件里，没有放进任何{}包围的块。 普通全局变量 在源文件中简单地按照类型+名称的格式声明即可。其作用域是整个程序，在所有函数、语句块（即所有域）中都可以通过变量名直接引用这个变量。extern关键字非常有用，extern之后加上相应变量原来的声明构成一个所谓的外部引用声明。表示引用的变量可能不在本文件中，需要在链接阶段从其他可重定位文件夹中寻找，或在动态链接阶段在其他共享库中查找。可见，通过extern实现了整个程序的作用域。 静态全局变量 与普通全局变量类似。其作用域是本源文件。程序的其他部分不能通过变量名直接引用这个变量。 1.3.2.2局部变量 局部变量分为两种。局部变量在函数或函数下的语句块声明，作用域是所在的域及其各个下级域（若没有被屏蔽）。 （1）普通局部变量 是我们通常意义上的局部变量，存储在栈空间。也就是说，每次调用相应的函数，分配的局部变量都是不同的，和上一次调用分配的局部变量无关。 （2）静态局部变量 声明局部变量时加上static关键字。其不同于普通局部变量，只会在程序初始化时分配一次空间，之后通过变量名引用的都是同一个变量。可以看成是语句块中的静态全局变量。 寄存器变量 使用register关键字，提示编译器将这个变量放在寄存器中，以优化程序。显然，由于种种原因，编译器不保证遵循这个建议。 1.4指针与引用 在C语言中，指针的本质是一种整型变量，意义为指向存储空间（通常为虚拟内存）的某些单元（即内存单元的索引号）。其大小是平台相关的，一般而言，当编译到32位，其大小为4字节；编译到64位，其大小为8字节。通过指针实现对变量的间接引用，方便了数据的访问。在C语言中，传递结构体等复杂类型的数据通常传递指针。 前文提及，const确保通过变量名直接引用变量并做修改操作会导致编译错误。那么对于通过指针间接引用变量，const还能发挥作用吗？一般来说，函数中声明的const局部变量存储在栈上，通过指针间接引用仍旧可以修改。而const全局变量存储于只读的虚存空间，便、通过指针间接引用并修改虽然不会产生编译错误，运行时却产生段错误。可见const的对全局变量更为严格。 1.5函数 在C语言中，函数的本质是一系列操作指令。通过函数名，可以访问这些操作指令，不仅可以调用函数，也可以读取具体的操作指令的机器码。函数本质上抽象为对指定数据集的一系列操作。在C语言中，函数是可以嵌套调用（在任何函数的语句都可以调用其他函数），递归调用（任何函数都可以递归地调用自己，实现递归算法）的。 函数指针是一种特殊的指针，将其赋值为不同的函数的地址，然后通过它间接引用函数，可以实现对一组规约相同的函数的动态调用。在面向对象的C++语言中，即是通过函数指针的数组vtable实现多态。 C语言中，函数的参数传递总是按值传递的，即参数列表中的参数变量是值和传递时所传递变量相同但存储在不同位置的另一个变量，即便对于参数是结构体类型也是如此。但是，数组除外，C语言实质上不支持将数组作为参数按值传递。当数组作为参数传递时，特殊的语法将它取了地址并传递了数组的指针，函数里访问传递的数组，也通过指针间接引用了原来的数组。 第2章汇编语言的语言元素 满分30分 汇编语言属于低级语言，与机器指令一一对应，是机器码更便于人识记的形式。下面，我们以IA-32/Linux为例，简要介绍一段汇编程序的代码结构。汇编程序直接描述了要汇编生成的ELF目标文件的结构。因此，有必要了解Linux上程序的内存映像以及ELF的一些基本知识。 2.1内存映像与ELF文件 ELF文件中有不同的节，存储不同的内容。.interp节记录动态链接器的路径，内核加载这个可执行文件时，会加载相应的动态链接器完成一些工作。.dynsym.symtab节记录ELF的符号信息，即这个ELF导出的自己的以及引用的外部的变量和函数等，在动态链接时有很大的作用。.dynstr.shstrtab.strtab等节记录一系列字符串，包括节的名称、符号的名称、程序字符串常量以及ELF中其他字符串信息。.rela.dyn.rela.plt等节记录重定位信息，帮助链接器完成各种重定位。.init.fini.init_array.fini_array等节记录了程序初始化、结束时需要执行的代码的地址，由动态链接器在相应的时候调用。 .data.rodata.bss是程序中使用的各种全局变量（只读、读写、有初始化、无初始化）所在的节。.text是程序机器指令主要存在的节，各种可执行的函数、代码都在这里。 .dynamic存放动态链接时需要的重要信息。.plt.plt.got.got.got.plt与内部外部的全局变量的访问有关系，是所谓的跳板。 内核或者外部的ELF装载器将ELF文件装载到内存中时，是按段来装载的。段头（程序头）记录了应该怎样把文件中的内容映射到进程虚存空间。 代码段指虚存空间中可读可执行的页面区域，装载了ELF文件中可以执行的机器码（如.text节）。数据段指虚存空间中可读的页面区域，其中一部分可写，装载了ELF文件中的.bss.data等数据内容。堆是一段大小可以动态改变的区域（调用sbrk系统调用移动堆的界限，向上延伸），一般由动态内存分配器管理，存储程序运行过程中动态分配空间的变量。栈用于维护函数调用、参数传递、局部变量，实现函数的抽象。 2.2程序结构 2.2.1整体结构 在汇编程序（.S文件）中，“.”开头的行代表汇编器相关指令，不以“.”开头的行则为程序机器指令和程序标签。汇编器指令主要是向汇编器提供机器指令之外的信息，如ELF节，ELF符号等。下面是一些汇编器指令的例子和说明： .data#告诉汇编器，接下来的内容是ELF的.data节 .text#告诉汇编器，接下来的内容是ELF的.text节，汇编指令就写在后面 .align 4 #接下来的数据按照4字节对齐 .globlmInt#定义一个全局ELF符号mInt .typemInt,@object#ELF符号mInt类型为object类型 .sizemInt,4#ELF符号mInt大小为4 .long-1#放置4字节有符号整数-1 .value-1 #放置2字节有符号整数-1 .byte-1 #放置1字节有符号整数-1 简单按顺序罗列机器指令，即构成相应的循序程序。使用jmp，call等指令控制程序跳转到其他位置而不是严格按照地址递增的顺序执行，是程序调用和循环结构的基础。 2.2.2 分支 前文提到，条件判断在程序中非常重要。与ARM不同，IA-32并不各种指令的条件执行，分支结构主要靠条件跳转指令jcc实现，jcc指令描述如下： 可以看到条件码还是很多的，可以满足各种场景。这些条件码也可用于cmovcc，fcmovcc，loopcc，setcc等条件执行的指令。 在汇编程序中使用jcc指令，前面一般结合cmp或test指令，计算要比较的内容并影响EFLAGS中的条件码相关标志位，然后jcc根据当前条件码标志位判断，满足条件码要求则跳转到指定标签处。 2.2.3循环 循环同样使用jcc来实现，不同于简单分支结构，循环结构中一定会有一条往回跳的指令（这里是jcc往回跳，但其实结合jmp也可以）。 2.3类型 在汇编语言中，实际上已经不强调类型的概念了。在这里，对各种数据类型，其操作都分解为基本的计算操作和访存操作。正如前文所述，讲类型就是讲操作。单条指令级别的操作是针对基本数据类型设计的。 2.3.1整数类型 IA-32是一种32位ISA，有针对1字节、2字节和4字节整数的单条指令级别的操作。但是没有针对8字节64位整数的单条指令级别的操作，要对64位整数做计算，需要多条指令配合（adc，sbb等指令在这里就非常重要）。机器做整数加减计算（使用add，sub指令）时，无所谓是有符号数还是无符号数，两种结果都会给出（结果的二进制位模式一样，状态标志位条件码不同），编写程序时选取一种结果进一步解释即可。对于乘法和除法运算，需要明确指定使用有符号数操作（mul，div指令）还是无符号数操作（imul，idiv指令）。 关于放置整数的汇编器指令，参考2.2.1。 2.3.2浮点类型 IA-32遵循IEEE754标准，有支持32位单精度浮点和64位双精度浮点运算的浮点协处理器及相应的指令。此外，还支持80位扩展精度浮点。在LinuxGCC中，为了严格和i386保持兼容，编译32位程序不会使用mmx，sse等功能更为强大的指令，只使用x87FPU的浮点指令。 2.4栈和寄存器 IA-32是非常典型的CISC架构的ISA，寄存器很少，而且在不少指令中有特殊语义。下面是8个通用寄存器： 其中，16位寄存器与32位寄存器低16位重合，而8位寄存器相应地与16位寄存器的高8位和低8位重合。eax，ecx，edx，ebx在指令中的特殊语义可以简短指令长度，实现优化，不使用特殊语义也是可以的，因此这4个寄存器通用性比较好。 esp固定作为栈指针其实不太具有通用意义。栈用于保存函数调用上下文，保存局部变量，非常重要。在IA-32中，栈是严格4字节对齐的。push指令向栈中压入元素，使esp向下移动，pop则将元素弹出，使esp向上移动。call指令将当前eip压入栈顶，保存调用返回地址，而ret指令将栈顶元素弹入eip，实现返回。 2.5函数 汇编语言本身是没有函数这样的概念的，可以说机器也不需要函数这样抽象的概念。但是，模块化的要求促使我们逐渐在汇编语言中引入子过程、函数这样的概念。总的来说，函数就是一段汇编代码加上一定的调用约定，函数对传递进来的参数做一系列操作。 2.5.1调用约定 理论上，在汇编语言中关于函数的调用、参数传递、返回值传递等可以做任意的规定。实际运用中，为了将汇编程序与高级语言程序如C、Pascal程序结合在一起使用，通常遵循高级语言汇编实现的调用约定。最常用的是cdecl，IA-32上的C语言标准调用约定。此外还有fastcall，thiscall，stdcall等。 2.5.1.1cdecl约定 cdecl约定是IA-32上C语言实现的默认约定，最为常用。其完全使用栈传递参数，参数从右到左依次压入栈中，call指令最后把函数返回地址压入栈中，然后跳转到函数第一条指令处。例如，函数有两个参数：(charc,inti)，call跳转后，参数列表中左起第一个参数c位于[esp+4]处，第二个参数i位于[esp+8]处，尽可能保持4字节对齐。函数返回时，需要清理自己使用的栈，确保此时栈顶是原来的返回地址（注意，传递的参数不属于被调用函数自己使用的栈，不用清理，调用者会清理这部分），然后使用ret指令返回原来call指令的下一条指令。使用eax寄存器传递4字节以内的返回值，使用eax寄存器及edx寄存器共同传递8字节以内的返回值。一般来说这些已经足够应付绝大部分情况了。 2.5.1.2fastcall约定 前两个4字节以内的参数分别使用ecx和edx寄存器传递，剩余参数从右到左依次压入栈中，call指令最后把函数返回地址压入栈中。函数返回时，需要先清理自己使用的栈，确保此时栈顶是原来的返回地址，然后使用ret指令返回的同时清理参数传递使用的栈（称为自动清理）。使用寄存器传递两个参数并使用自动清理，速度更快，代码量更小。对于可变参数的函数，不使用寄存器传参。 2.5.1.3thiscall约定 第一个4字节以内的参数分别使用ecx寄存器传递，剩余参数从右到左依次压入栈中，call指令最后把函数返回地址压入栈中。函数返回时，需要先清理自己使用的栈，确保此时栈顶是原来的返回地址，然后使用ret指令返回的同时清理参数传递使用的栈（称为自动清理）。使用寄存器传递一个参数并使用自动清理，速度更快，代码量更小。对于可变参数的函数，不使用寄存器传参。这个调用约定主要用于C++的非静态成员函数，ecx就用于传递隐藏的第一个参数this指针。 2.5.1.4stdcall约定 参数从右到左依次压入栈中，call指令最后把函数返回地址压入栈中。函数返回时，需要先清理自己使用的栈，确保此时栈顶是原来的返回地址，然后使用ret指令返回的同时清理参数传递使用的栈（称为自动清理）。使用自动清理，代码量更小。一般不用于可变参数函数。 2.5.2示例 实现同样操作计算a-b-c的四种不同调用约定的函数。函数前使用汇编器指令.global.type声明ELF符号信息，标签之后是函数的汇编指令，最后还使用.size汇编器指令声明函数大小。 第3章C语言的汇编实现 满分40分 C语言是一种高级语言，有一些高级、抽象的概念，有些内容层次较高，本质上可由C语言中层次较低的元素去实现，例如前文提到了数组和结构体实际上不过提供了一种基于指针和偏移量的更便捷的变量组织、寻址方式。下面我们介绍C那些特别基本而重要的操作在汇编语言中是如何实现的。 3.1 基本数据类型的操作 复杂的数据类型是基本数据类型的逻辑组合。类型最重要的特性是其操作。因此，必须清楚对基本数据类型的操作是如何实现的。 3.1.1整数类型的计算 C语言中支持很多整数类型的计算。 3.1.1.1加法，减法 在IA-32上，加法指令（add）和减法指令（sub）支持对8位整数，16位整数以及32位整数做计算。对于加法和减法，有符号数与无符号数没有区别，两种情况的结果标志位都会反映在eflags中。 但是，IA-32没有64位整数的加法和减法运算指令，需要编译器利用adc指令和sbb指令实现相应的内部例程。adc指令和sbb指令利用eflags中的进位借位信息，可以很方便地实现长地整数的加减法。 如图，对64位整数的加减法，先用add、sub指令计算低32位并保存进位借位信息到eflags。再使用adc、sbb指令，结合进借位信息计算高32位。 3.1.1.2乘法，除法，求模 和加法减法不同，乘法除法对于有符号数和无符号数，结果的二进制位模式不同。在IA-32上，同时提供适用于有符号数和无符号数的乘法与除法。mul与div指令分别是无符号乘法与除法，imul与idiv指令分别是有符号乘法与除法。同样地，有8位、16位、32位整数的指令但没有64位整数的指令。由于乘法与除法比较复杂，为了简化指令编码，使用了寄存器的特殊语义。 上面截图自intel的手册，其中的64位指令属于x86_64，在IA-32上是没有的。 然而，在C语言中，整数乘法的结果总是截断到参与运算的类型的大小。对于整数乘法，无符号数乘法与有符号数乘法的结果截断后位模式相同，实际上编译器不会在意mul与imul指令的选择，几乎总是使用imul。 对有符号数和无符号数都使用了imul指令实现乘法计算。 与乘法不同，对于除法，有符号数除法使用idiv指令实现，无符号数的除法使用了div指令实现。 求模运算就是除法取余运算，因此同样使用除法的指令实现，不过还要从特殊语义的寄存器dx，edx取出余数结果。 3.1.1.3左移，右移 C语言中支持左移和右移操作。其中右移分为逻辑右移与算术右移，分别可以看成无符号数除2的幂与有符号数除2的幂。 可见左移只有一种，右移有两种。其实有一个sal指令，是shl指令的别名。C语言中一般对有符号数做算术右移，无符号数做逻辑右移，但是这个不是C语言标准中明确要求的，只是绝大部分编译器都这样实现。 3.1.1.4与，或，非 C语言中没有专门的布尔类型，普通的整数可以做布尔类型参与逻辑与、或、非运算。同时整数也可做位与、或、非运算。在IA-32中，有专门的指令做位级的与、或、非运算，分别是and指令，or指令和not指令。逻辑与、或、非运算需要结合计算结果的标志位信息做条件判断。 3.1.1.5比较 C语言中，整数比较运算根据两个数的大小关系给出逻辑结果。在IA-32中，有一个专门用于整数比较的指令cmp，其本质与sub相同，都是将两数相减。不同之处在于，cmp只影响体现大小关系的结果标志位，不会把最终计算结果送到目标处。cmp指令通常结合条件执行的指令jcc，setcc，cmovcc等。在第二章我们提到，IA-32条件执行码很多，可以应对各种情况，也可用于优化。这里仅列出一部分： 3.1.1.6求补（取反），异或 C语言中，求有符号数的相反数，也就是求补运算也很常用。此外还有一个很少用但有趣的运算：位异或运算。在IA-32中，有专门的指令实现这两个运算。 3.1.2浮点类型的加载与运算 一般来说，C语言中的float类型对应IEEE754标准中的32位单精度浮点，double类型对应IEEE754标准中的64位双精度浮点。IA-32是小端序的，根据标准，float和double类型的存储方式如下： 在IA-32上，有专门的x87浮点协处理器做浮点运算。后来还有更现代的mmx，sse等指令用于处理浮点数。在Linux上，GCC为了保持与i386的严格兼容，不会主动使用现代的扩展指令集实现浮点运算，只使用x87浮点指令。x87FPU的指令很有特点，所有计算、转换操作都是围绕一个特殊的浮点工作栈进行的。因此，进行浮点计算不像整数计算那么简单，首先要使用专门的装载指令将浮点数压入浮点栈。 3.1.2.1浮点数传送 fld、fst系列的指令专门负责将浮点数从通用的内存引用移送到浮点栈、将浮点数移送到通用的内存引用。通用寄存器不能用于保存浮点数。 3.1.2.2浮点数四则运算 x87FPU的浮点计算指令能支持32位单精度浮点数、64位双精度浮点数以及80位扩展精度浮点数的运算。 可以看到每一个函数的实现中都有fld指令负责将浮点数从通用栈传送到浮点栈。和整数计算指令一样，浮点数计算指令也可以将通用内存引用作为参数。 3.1.2.3浮点数比较 一般来说，C语言中浮点数比较运算主要用“>”和“<”，通常来说计算结果是有误差的，比较是否严格相等没有意义。在x87中，使用fcomi，fcomip，fucomi，fucomip比较浮点数并在eflags里设置结果标志位。 3.1.3基本类型的转换 3.1.3.1整数与整数 当两个类型大小相等时，汇编代码层面不做任何转换。这是因为有符号数与无符号数存储方式完全一样，C语言转换后，后续进行操作，使用相应的（无符号数或有符号数的）指令即可。 由图可见没有任何转换指令。 当目标类型大小比原类型小时，直接截取低位做截断，对有符号数也是如此。在IA-32中，利用寄存器之间的重合关系可以很方便地做整数截断。 当目标类型大小比原类型大时，根据是有符号数还是无符号数，选用相应的扩展操作。IA-32中，movzx传送数据同时进行零扩展，适用于无符号数；movsx传送数据同时进行符号扩展，适用于有符号数。 3.1.3.2整数与浮点数 整数与浮点数的转换不能直接进行，必须做一些运算。在x87中，fist、fild指令传送数据的同时可以进行浮点数与整数之间的转换，fiadd、fisub、fimul、fidiv指令在计算前将整数转换为浮点数参与计算（编译器可能不会使用这些指令进行优化）。但是，这些转换都是将整数看成有符号整数的。要对无符号整数进行转换，需要将它用更大的有符号数表示，可能还要其他算法。 3.1.3.3浮点数与浮点数 这是x87FPU的浮点工作栈一个很有意思的地方。当把数据压进浮点栈时，将它看成一种抽象的浮点数，之后进行计算时我们不关心浮点数的类型；当把数据从浮点栈弹出传送到通用内存引用时，自动转换为相应的浮点类型。 3.2 寻址问题 在C语言中，除了寄存器类型的变量，其他变量都对应虚拟内存上一个存储空间。IA-32采用平坦模型，程序中使用统一的虚拟地址即可，不需要考虑分段寻址的问题。基本类型的变量编译器都分配了绝对或相对的地址，使用这个地址即可。在C语言中对变量使用“&”运算符，可明确得到其地址。对于浮复杂类型如数组和结构体，在第一章讲述了成员寻址的方式，这里不再重复。 3.3函数 汇编程序中的函数就是C语言程序中的函数的实现。某种意义上说，我们在汇编里写函数就是模仿编译器生成函数。使用栈保存局部变量与调用上下文，实现了函数的封装，使函数内可以调用任何函数。 3.4C语言程序结构的实现 3.4.1分支 编译器分别为分支的两个情况（if和else）生成相应的代码片段，其中包括离开分支结构的代码。然后在前面生成进入分支结构的代码，即判断和条件跳转。 3.4.2循环 这里我们以典型的for循环为例。首先是循环体的代码片段，然后在合适的位置插入判断以及条件跳转（往后跳离开循环还是往前跳继续循环），最后补上初始化语句与步长增加语句。 3.4.3编译器优化循环 我们继续看3.4.3中的例子，使用-O3选项进行优化后，明显可以看到编译器更多使用寄存器，并且调整了程序结构，比如，首次判断与后面的判断分开了，步长增加操作混在循环体中。但是，编译器保证这样的结构仍旧与原循环效果一致。 3.5指针 在第一章我们提到过，C语言中指针的本质其实是整数类型。指针的运算（加法减法）也是用整数的运算实现。但是，涉及到指针的运算有一些普通整数运算不具有的特点，因此，在IA-32上，常常使用lea指令优化指针运算。 指针有别于普通整数类型的最关键点是，“*”算符的解引用运算。通过这个运算，可以间接引用C语言中的其他变量。在IA-32中，因为指令支持内存引用作为操作数，指针解引用运算可以由各种指令实现（与IA-32这种CISC架构不同，在典型RISC架构如ARM中，只有专门的ld、st类的指令才能一般性地引用内存）。常用mov指令实现指针解引用，实现对指定虚拟地址空间的访问。 3.6C++语言 C++语言是在C语言的基础上增加面向对象、模版编程等高级内容设计而成的，和C语言一样可以直接编译成机器可执行文件。而C语言既有足够的抽象能力，又接近底层。因此，C++语言的各种特性，一部分是语言高级特性，由编译器在较高层次支持；另一部分要使用汇编语言实现的内容，其实完全都可以使用C语言实现。这就是说，我们只需要考虑如何将C++语言的特性在C语言中妥善地表示出来就可以了。 例如，C++中非静态成员函数可以访问this指针，指向调用该函数的对象。用C语言表示，可以看成是成员函数有第0个隐藏的参数this。编译器只需要将成员函数改写成适当的C函数，再生成调用代码就可以了。这部分内容在第二章thiscall也有涉及。 又例如，C++中传递参数可以传递对象的引用。而普通的引用，究其本质是C语言中的指针，只不过传参的时候编译器自动帮我们做了取地址运算而已。 类是C++语言中非常重要的特性。实际上，类与C语言中的结构体是完全一样的实现方式，即对于成员变量，提供一个从成员名到偏移量的映射关系，便于进行访问。而成员函数本质上是外置的函数，和C语言中的函数没有本质区别。对于具有virtual函数的类，在类的成员变量开头有一个隐藏的成员变量，是一个指针，指向一个记录本类虚函数函数指针的数组，称为vtable。 第4章C与汇编的优缺点分析 满分15分 关于C语言：有良好的抽象同时能满足底层的开发要求。因此使用C语言开发程序，开发速度快。相比于其他高级语言，更接近底层，因而软件性能损失很小。遵循保持程序可移植性的各项原则，使得移植一般通用的C语言程序心智负担很小。但是，由于编译器出于通用性、兼容性、实现复杂性等方面考虑，不会激进地使用CPU的新特性，使用C语言编程难以充分利用CPU的新特性进行优化。尽管编译器会不断支持新硬件并放弃旧硬件，这个过程相比于CPU的迭代总是落后的。 关于汇编语言：一般来说是最为接近底层的，可以更好地掌控程序的运行，控制CPU的状态。不仅能做C语言能做的，还能做其不能做的。一般来说，编译器套装中汇编器更新是比较快的，因而使用汇编语言可以很快就用上CPU的新特性。针对CPU的特点，并运用新特性，可以有效提高程序的运行速度。但是由于汇编比较难懂，能熟练使用汇编语言的程序员相对较少。汇编很繁琐，导致开发速度不可能很快。汇编与具体的CPU相关，抽象不足，可移植性很差，每移植到一个新指令集的CPU都需要重写。 根据C语言和汇编语言的优缺点可知，为了降低开发成本、减少不必要的工作，应该尽可能使用C语言。事实上，现在即使在像linux内核这样非常底层的软件的开发中，也是严格限制汇编的使用的。但是，有些情况下必须使用汇编。有可能是相关的操作在C语言能力范围之外：例如execve()系统调用结束时更改用户进程的栈寄存器，C语言不提供这样的能力，只能使用汇编完成。有可能是使用汇编带来的收益很大，可以接受其带来的麻烦：例如在使用CPU渲染的OpenGL驱动程序中，使用汇编语言编写关键操作，可以充分利用SSE，AVX，armneon等高性能指令集，带来显著的性能提升。可见，现如今虽然汇编已经写得很少了，但不能一味排斥，必须具体问题具体分析，在合适的情况使用它。 参考文献 Intel®64andIA-32Architectures SoftwareDeveloper’sManual Volume2(2A, 2B,2C&2D):InstructionSetReference,A-ZAndroid社区源代码在线阅读https://www.androidos.net.cn/ 
第229篇文章[]
关于Java中equals方法 今天被这熟悉而又陌生的equals方法搞麻了。对于不可变类型，似乎还好，反正是不可变的，判断一下内容即可。主要是父类类型和子类类型之间做equals时，需要处理非常多的细节。但是把这种比较内容（也即是观察等价性）的想法用到可变类型上，可就掉坑里了。 一般借java讲等价性，都会提到，java的容器类型都实现了观察等价性。由于容器都是mutable的，嵌套的HashSet<ArrayList<String>>会出bug： publicstaticvoidmain(String[]args){ HashSet<ArrayList<String>>set=newHashSet<>(); ArrayList<String>list=newArrayList<>(); list.add("A"); set.add(list); set.contains(list);//returntrue list.add("B"); set.contains(list);//returnfalse } list并没有移除可是contains检测不到了。这是因为list被改变了，按其观察等价性的实现，hashcode也变了，contains计算哈希桶编号得到的不再是原来的那个保存着list的桶了，自然认为找不到list。麻了。 在PPT上，关于这里，说java的观察等价性实现是不好的，应该使用行为等价性实现，即使用Object中引用等价性的实现。可是使用引用等价性完全不能反应这个ADT的任何特点，实际上没有任何意义。这样的equals实现无非是“不出bug”，并不能使它有意义地出现在HashSet中。在HashSet里出现两个地址不同但元素完全相同的东西看上去是荒谬的。目前java中的这些容器类型不能很好地容纳可变类型，主要还是在于不能随着元素变化自动调整容器自身，和equals怎样实现是没有关系的。无论是没有意义的引用等价性还是倒霉的观察等价性，都不能让容器正确地、反应ADT特性地容纳相关类型。搞坏了equals，再去弄一个same，similar之类的去判断ADT等价性属实麻了。 最简单的规则还是禁止在容器中使用可变类型。实在需要在容器中使用可变类型，还是封装remove-add好一点。让equals做回自己吧。 
第230篇文章[]
【软件构造】Maven的使用 Maven是一个比较好用的配置管理工具。当你的程序需要多个配置项时，可以去他的官方网站，找到对应的版本，把对应的脚本粘贴到你的配置文件当中。它会自动下载。它还可以管理你程序的生命周期，无论你是要编译、生成文档、发布、测试、运行，你只需要配置好对应的脚本，运行脚本即可自动完成。 1.首先，在工程的根目录下创建一个pom.xml 2.配置依赖项，这一部分代码可以从https://mvnrepository.com/上查找。比如我们要引入log4j2、junit4的依赖 3.配置源文件夹、测试文件夹，这一部分放进<build>标签中 4.配置编译插件，放在<build><plugins>里，注意，maven默认的jdk版本是1.7，很多情况下需要改成1.8及以上版本 5.配置其他部分的插件，要放进对应的标签中，比如这里的spotBugs插件 6.要进行某些生命周期的操作，我们可以通过maven的命令行参数执行，也可用ide 7.执行complile，可以看到对应的结果 
第231篇文章[1]
CSAPP大作业 计算机系统 大作业 摘 要 回顾本学期计算机系统所学的内容，复习所学知识。在对hello程序运行的分析，研究在linux下p2p与020。巩固了预处理、编译、汇编、链接等的知识。 关键词：编译；汇编；链接；预处理；hello的进程管理；p2p；020 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 P2P：经过预处理、编译、汇编、链接之后，hello.c变成目标程序执行，在shell里启动之后，shell调用fork创建子进程。 020：shell映射虚拟内存，加载进物理内存执行代码，结束后shell父进程回收hello进程，释放内存并删除数据结构。 1.2环境与工具 X64CPU，2GHz，16GRAM，1TSSD； Win10，VMware，Ubuntu20.04 1.3中间结果 hello.i：预处理 hello.s：所得汇编代码 hello.o：所得的可重定位目标执行文件 hello.out：链接后所得二进制文件 hello：可执行程序 1.4本章小结 对hello做了简单介绍，；列举所需的环境与工具和中间结果的文件。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 C/C++程序中的源代码中包含以#开头的各种编译指令，这些指令称为预处理指令。预处理指令不属于C/C++语言的语法，但在一定意义上可以说预处理扩展了C/C++。 C预处理器提供了四个独立的功能：包含头文件（可以替换到程序中的声明文件）；宏扩展（可以定义宏，C预处理器将在整个程序中用宏的定义替换宏）；条件编译（使用特殊的预处理指令，可以根据不同的条件包括或排除部分程序）；和行控制（如果使用程序将源文件合并或重新排列为一个中间文件，然后编译该文件，则可以使用行控制通知编译器每个源代码行的起源位置）。 2.2在Ubuntu下预处理的命令 gcc-E-ohello.ihello.c 图表1预处理截图 2.3Hello的预处理结果解析 预处理后文件最开头的三个#include消失，一段代码代替了三个#include。方便下一部处理。 图表2hello.i文件 2.4本章小结 了解预处理的概念及作用，还有如何在linux进行预处理，并分析所得的.i文件。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译(compilation,compile)利用编译程序从源语言编写的源程序产生目标程序的过程。用编译程序产生目标程序的动作。编译就是把高级语言变成计算机可以识别的二进制语言。编译程序把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。 3.2在Ubuntu下编译的命令 gcc-Shello.i-ohello.s 图表3编译截图 3.3Hello的编译结果解析 3.3.1hello.s文件 图表4hello.s文件 3.3.2数据 （1）字符串 即Usage:Hello学号姓名！\n Hello%s%s\n （2）变量 全局变量sleepsecs，先初始化为2，然后存放在.rodata节 局部变量inti 参数intargc （3）数组 argv作为一个指针数组，每个地址是8位 3.3.3关系操作 cmpl$9,-4(%rbp) i<10优化变成i<=9 cmpl$3,-20(%rbp) argc!=3 3.3.4算术操作 addl$1,-4(%rbp) i加一 leaq.LC1(%rip),%rdi 计算格式串地址 3.3.5函数操作 main call指令将下一条指令的地址压入栈中，然后跳转到main函数，main将%eax设置为0返回 exit callexit@PLT printf 第一次callputs@PLT 第二次callprintf@PLT sleep callsleep@PLT getchar callgetchar@PLT 3.4本章小结 对hello.s文件的分析，明白各个部分的作用，了解机器指令是如何操作的。 第4章汇编 4.1汇编的概念与作用 通过汇编器，把汇编语言翻译成机器语言。作用：通过汇编这个过程，把汇编代码转化成了计算机完全能够理解的机器代码。 4.2在Ubuntu下汇编的命令 gcchello.s-s-ohello.o 图表5汇编截图 4.3可重定位目标elf格式 readelf-hhello.o 图表6文件头截图 可以看出文件的各类信息。 图表7节头部表 节头部表包含节的名称，类型等等。 图表8符号表 包含main定义和引用的符号的信息。每个可重定位目标模块都有一个符号表，它包含m的定义和引用的符号的信息。符号表是由汇编器构造，使用编译器输出到汇编语言.s文件中的符号。每个符号表是一个条目的数组。 4.4Hello.o的结果解析 Objdump-d-rhello.o>hello.txt 图表9hello.o反汇编截图 hello.o与hello.s的不同： 1、hello.o中分支转移是通过地址跳转，而hello.s是用段名称跳转。 2、为了机器识别，hello.o左边多了机器码。 3、hello.s文件中，全局变量是通过语句：段地址+%rip完成的，而在hello.o中，则是：0+%rip。 机器语言： 机器语言是二进制的机器指令的集合，其特点是灵活、速度快和直接执行，机器指令是由操作码和操作数构成。 汇编语言：主体是汇编指令，是机器指令便于记忆的表示形式。汇编指令和机器指令在指令的表示方法上有所不同。 4.5本章小结 对汇编进行介绍，包括汇编的概念与作用，对可重定位目标elf格式进行分析，对hello.o与hello.s文件进行比较，加深对汇编的理解。 第5章链接 5.1链接的概念与作用 概念：将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件。目标文件是包括机器码和链接器可用信息的程序模块。 作用：链接器的工作就是解析未定义的符号引用，将目标文件中的占位符替换为符号的地址。链接器还要完成程序中各目标文件的地址空间的组织，这可能涉及重定位工作。 5.2在Ubuntu下链接的命令 图表10链接截图 命令行：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 图表11hello的elf 节头部表： 图表12节头部表 图表13节头部表 符号表： 图表14符号表 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息。 图表15edb 窗口显示虚拟地址由0x401000开始，到0x402000结束，这之间的每一个节对应5.3中的每一个节头表的声明。 5.5链接的重定位过程分析 图表16objdump 各地址为重定位之后的虚拟内存的地址，从0x401000开始。hello.o是从0000000开始。在开头hello多了.init，.fini，.plt，.plt.got节，分别是程序初始化执行的代码，程序终止时需要执行的代码，动态链接中的过程连接表，动态链接中的全局偏移表。 5.6hello的执行流程 使用edb执行hello，从加载hello到_start，到callmain,以及程序终止的主要过程如下： 子程序名程序地址（16进制）ld-2.27.so!_dl_start7efbff4d8ea0ld-2.27.so!_dl_init7efbff4e7630hello!_start400500libc-2.27.so!__libc_start_main7efbff100ab0hello!puts@plt4004b0hello!exit@plt4004e0 5.7Hello的动态链接分析 动态链接使我们在调用一个共享库定义的函数可以在运行时找到函数的地址。但是在调用时编译器没办法预测这个函数（共享库定义）的运行时地址，因为定义它的共享模块可以在运行时加载到任何位置。但是GNU编译系统通过延迟绑定技术来解决这个问题，将过程地址的绑定推迟到第一次调用该过程中。 延迟绑定通过：GOT和PLT实现，如果一个目标模块调用定义在共享库中的任何函数，那么他就有自己的GOT和PLT。 第一次调用共享库函数时，不调用共享库函数，直接进入函数对应的PLT中，接着PLT指令通过对应的GOT指令进行间接跳转，由于每个GOT指令初始时都指向他对应的PLT条目的第二条指令，所以这个间接跳转只是简单的把控制传回PLT条目的下一条指令。接着把函数的ID入栈PLT跳转到PLT[0]，PLT[0]再将动态链接器的一个参数入栈，然后间接跳转到动态链接器中。动态链接器依据两个栈条目确定函数的运行位置，重写对应的GOT条目，再把控制传给函数。 所以，在运行dl_init前，GOT表中存放的都是对应PLT条目的第二条指令，在运行dl_init后，GOT表中存放的就是对应的函数的地址。 5.8本章小结 本章结合实验中的hello可执行程序依此介绍了链接的概念及作用，在Ubuntu下链接的命令行；并对hello的elf格式进行了详细的分析对比，同时注意到了hello的虚拟地址空间知识；并通过反汇编hello文件，将其与hello.o反汇编文件对比，详细了解了重定位过程；遍历了整个hello的执行过程，在最后对hello进行了动态链接分析。 第6章hello进程管理 6.1进程的概念与作用 概念：进程是一个执行中的程序的实例，系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 作用：进程提供给应用程序两个关键抽象： 1、逻辑控制流 每个程序似乎独占地使用CPU 通过OS内核的上下文切换机制提供 2、私有地址空间 每个程序似乎独占地使用内存系统 OS内核的虚拟内存机制提供 6.2简述壳Shell-bash的作用与处理流程 Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等。 Shell处理流程： 1.打印提示信息 2.等待用户输入 3.接受命令 4.解释命令 5.找到该命令，执行命令，如果命令含有参数，输入的命令解释它 6.执行完成，返回第一步 6.3Hello的fork进程创建过程 shell先判断出不是内置命令，于是加载可执行文件hello，通过fork创建一个子进程，子进程得到与父进程用户级虚拟地址空间相同的一份副本。子进程还获得与父进程任何打开文件描述符相同的副本。子进程与父进程有不同的pid。fork被调用一次，返回两次。在父进程中fork返回子进程的pid，在子进程中fork返回0.父进程与子进程是并发运行的独立进程。 6.4Hello的execve过程 在shell创建的子进程中将会调用execve函数，来调用加载器，加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。每个程序都有一个运行时内存映像，如图6.2所示。当加载器运行时，它创建类似图6.2所示的内存映像。在程序头部表的引导下，加载器将可执行文件的片（chunk）复制到代码段和数据段。接下来，加载器跳转到程序的入口点，也就是_start函数的地址。这个函数是在系统目标文件ctrl.o中定义的，对所哟额C程序都是一样的。_start函数调用系统启动函数__libc_start_main，该函数定义在libc.so中，它初始化执行环境，调用用户层的main函数，处理main函数的返回值，并且在需要的时候把控制返回给内核。 6.5Hello的进程执行 系统中的每个程序都运行在某个进程的上下文中。上下文由程序正确运行所需的状态组成，这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 内核调度hello的进程开始进行，输出Hello与之前输入的内容，然后执行sleep函数，这个函数是系统调用，它显示地请求让调用进程休眠。内核转而执行其他进程，这时就会发生一个上下文转换。2s后，又会发生一次进程转换，恢复hello进程的上下文，继续执行hello进程。重复9次这个过程。 循环结束后，后面执行到getchar函数，这时读取数据一般需要很长的时间，所以将会发生一个上下文切换转而执行其他进程，当数据已经被读取到缓存区中，将会发生一个中断，使内核发生上下文切换，重新执行hello进程。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 图表17回车 回车：进程被回收 图表18Ctrl+Z Ctrl+Z：停止前台作业 图表19Ctrl+C Ctrl+C：程序终止 图表20乱按 乱按：乱按的内容保存在缓冲区，按下回车会在程序停止后执行这些内容，不按回车则不执行 6.7本章小结 异常控制流发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。 1）在硬件层，异常是由处理器中的事件触发的控制流中的突变 2）在操作系统层，内核用ECF提供进程的基本概念。 3）在操作系统和应用程序之间的接口处，应用程序可以创建子进，等待他们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。 4）最后在应用层，C程序可以使用非本地跳转来规避正常的调用/返回栈规则，并且直接从一个函数分支到另一个函数。 同时还有四种不同类型的异常：中断，故障，终止和陷阱。 第7章hello的存储管理 7.1hello的存储器地址空间 物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址。 逻辑地址：程序代码经过编译后出现在汇编程序中地址。逻辑地址由选择符（在实模式下是描述符，在保护模式下是用来选择描述符的选择符）和偏移量（偏移部分）组成。 线性地址：逻辑地址经过段机制后转化为线性地址，为描述符:偏移量的组合形式。分页机制中线性地址作为输入。 7.2Intel逻辑地址到线性地址的变换-段式管理 段式内存管理方式就是直接将逻辑地址转换成物理地址，也就是CPU不支持分页机制。其地址的基本组成方式是段号+段内偏移地址。 在x86保护模式下，段的信息即段描述符占8个字节，段信息无法直接存放在段寄存器中。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值。 首先给定一个完整的逻辑地址 1.看段选择描述符中的T1字段是0还是1，可以知道当前要转换的是GDT中的段，还是LDT中的段，再根据指定的相应的寄存器，得到其地址和大小，我们就有了一个数组了。 2.拿出段选择符中的前13位，可以在这个数组中查找到对应的段描述符，这样就有了Base，即基地址就知道了。 3.把基地址Base+Offset,就是要转换的下一个阶段的地址。 7.3Hello的线性地址到物理地址的变换-页式管理 线性地址的表示方式是：前部分是虚拟页号后部分是虚拟页偏移。 CPU通过将逻辑地址转换为虚拟地址来访问主存，这个虚拟地址在访问主存前必须先转换成适当的物理地址。CPU芯片上叫做内存管理单元（MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址。然后CPU会通过这个物理地址来访问物理内存。 页表结构：在物理内存中存放着一个叫做页表的数据结构，页表将虚拟页映射到物理页，每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。 页表就是一个页表条目（PTE）数组，虚拟地址空间中的每个页在页表中的一个固定偏移量处都有一个PTE。PTE是由一个有效位和一个n个字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置。 MMU利用虚拟页号（VPN）来在虚拟页表中选择合适的PTE，当找到合适的PTE之后，PTE中的物理页号（PPN）和虚拟页偏移量（VPO）就会组合形成物理地址。其中VPO与PPO相同，因为虚拟页大小和物理页大小相同，所需要的偏移量位数也就相同。此时，物理地址就通过物理页号先找到对应的物理页，然后再根据物理页偏移找到具体的字节。 7.4TLB与四级页表支持下的VA到PA的变换 在酷睿i7中，36位的虚拟地址被分割成4个9位的片。CR3寄存器包含L1页表的物理地址。VPN1有一个到L1PTE的偏移量，找到这个PTE以后又会包含到L2页表的基础地址；VPN2包含一个到L2PTE的偏移量，找到这个PTE以后又会包含到L3页表的基础地址；VPN3包含一个到L3PTE的偏移量，找到这个PTE以后又会包含到L4页表的基础地址；VPN4包含一个到L4PTE的偏移量，找到这个PTE以后就是相应的PPN。 7.5三级Cache支持下的物理内存访问 酷睿i7MMU使用四级页表来将虚拟地址翻译成物理地址，得到了物理地址PA。现在分析三级cache支持下的物理内存访问。 L1Cache是8路64组相联。块大小为64B。因此CO和CI都是6位，CT是40位。根据物理地址（PA），首先使用CI组索引，每组8路，分别匹配标记CT。如果匹配成功且块的有效位是1，则命中，根据块偏移CO返回数据。 如果没有匹配成功或者匹配成功但是标志位是1，则不命中，向下一级缓存中取出被请求的块，然后将新的块存储在组索引指示的组中的一个高速缓存行中。一般而言，如果映射到的组内有空闲块，则直接放置，否则必须驱逐出一个现存的块，一般采用最近最少被使用策略LRU进行替换。 7.6hello进程fork时的内存映射 在用fork创建虚拟内存的时候，要经历以下步骤： 1.创建当前进程的mm_struct，vm_area_struct和页表的原样副本 2.两个进程的每个页面都被标记为只读页面 3两个进程的每个vm_area_struct都被标记为私有 7.7hello进程execve时的内存映射 exceve函数加载和执行程序Hello，需要以下几个步骤： 1.删除已存在的用户区域。 2.映射私有区域。为Hello的代码、数据、bss和栈区域创建新的区域结构，所有这些区域都是私有的、写时复制的。 3.映射共享区域。比如Hello程序与标准C库libc.so链接，这些对象都是动态链接到Hello的，然后再用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC）。exceve做的最后一件事就是设置当前进程的上下文中。 7.8缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3,从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。 缺页处理程序从磁盘上用VP3的副本取代VP4，在缺页处理程序重新启动导致缺页的指令之后，该指令将从内存中正常地读取字，而不会再产生异常。 7.9动态存储分配管理 基本方法：维护一个虚拟内存区域“堆”，将堆视为一组不同大小的块的集合来维护，每个块要么是已分配的，要么是空闲的，需要时选择一个合适的内存块进行分配。 1记录空闲块，可以选择隐式空闲链表，显示空闲链表，分离的空闲链表和按块大小排序建立平衡树。 2放置策略，可以选择首次适配，下一次适配，最佳适配。 3合并策略，可以选择立即合并，延迟合并。 4需要考虑分割空闲块的时机，对内部碎片的忍耐阈值。 7.10本章小结 1）虚拟内存是对主存的一个抽象。支持虚拟内存的处理器通过使用一种叫做虚拟内存寻址的间接形式来引用主存。处理器产生一个虚拟地址，在被发送到主存之前，这个地址被翻译成一个物理地址。从虚拟地址空间到物理地址空间的地址翻译要求硬件和软件紧密合作。专门的硬件使用页表来翻译虚拟地址，而页表的内容是由操作系统提供的。 2）虚拟内存提供三个功能：简化了内存保护；简化了内存管理；在主存中自动缓存最近使用的存放在磁盘上的虚拟地址空间的内容。 3）地址翻译的过程必须和系统中的所有的硬件缓存的操作集成在一起。 4）内存映射为共享数据、创建进程以及加载程序提供了一种高效的机制。 5）动态内存分配器直接操作内存，无需类型系统的很多帮助。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 文件的类型： 普通文件：包含任意数据的文件。 目录：包含一组链接的文件，每个链接都将一个文件名映射到一个文件（他还有另一个名字叫做“文件夹”）。 套接字：用来与另一个进程进行跨网络通信的文件 命名通道 符号链接 字符和块设备 设备管理：unixio接口 打开和关闭文件 读取和写入文件 改变当前文件的位置 8.2简述UnixIO接口及其函数 1.UnixIO接口： 打开文件：一个应用程序通过要求内核打开相应的文件，宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符。它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 shell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。 改变当前的文件位置：对于每个打开的文件，内核保持着一个文件的位置k，初始为0，这个文件的位置是从文件开头起始的字符偏移量。应用程序能够通过执行seek操作，将文件的当前位置设置为k。 读写文件：读操作就是从文件中复制n>0个字节到内存中，从当前文件位置k开始，然后将k增加到k+n。而写操作就是从内存复制字节到文件中。 关闭文件：当应用完成了对文件的访问后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 2.UnixIO函数： open函数:调要open函数可以打开或创建一个文件。 create函数：创建一个文件，也可通过以特定参数使用open来实现。 close函数：读文件进行关闭。 Iseek函数：为一个打开的文件设置其偏移量。 read函数：从打开的文件中读数据到buf。 write函数：写入文件。 pread,prwrite函数：主要用于解决文件共享问题。 dup函数 syns函数：用于解决延迟写问题，保证磁盘上实际文件系统和缓冲区高速缓存中内容的一致性。 8.3printf的实现分析 intprintf(constcharfmt,…) { inti; charbuf[256]; va_listarg=(va_list)((char)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 调用了两个函数vsprintf，write。 vsprintf函数的作用是将所有的参数内容格式化之后存入buf，然后返回格式化数组的长度。 write函数是将buf中的i个元素写到终端的函数。 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(–n>=0)?(unsignedchar)*bb++:EOF; } getchar函数调用read函数，将整个缓冲区都读到buf里，并将缓冲区的长度赋值给n。返回时返回buf的第一个元素，除非n<0。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 了解了hello的IO管理，以及读写的两个函数的实现 结论 C语言编写hello.c； 预处理hello.c，得到hello.i； 编译hello.i成为汇编文件hello.s； 汇编hello.s，将其变为可重定位目标文件hello.o； 链接，将hello.o与可重定位目标文件和动态链接库链接成为可执行程序hello 运行hello，在shell中输入./hello1190201214zzq shell调用fork创建子进程 shell调用execve，映射虚拟内存 进入程序，载入物理内存，进入main函数 执行指令：CPU为其分配时间片，在一个时间片中，hello享有CPU资源，顺序执行自己的控制逻辑流 访问内存：MMU将程序中使用的虚拟内存地址通过页表映射成物理地址。 动态申请内存：printf会调用malloc向动态内存分配器申请堆中的内存。 信号：运行途中键入不同指令，做出不同反应。 结束：shell父进程回收子进程，内核删除为这个进程创建的所有数据结构。 附件 列出所有的中间产物的文件名，并予以说明起作用。 hello.c 源文件 hello.i 预处理得到的文件 hello.s 编译得到汇编语言文件 hello.o 得到可重定位目标文件 hello 得到可执行目标文件 参考文献 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 
第232篇文章[]
【软件构造】使用JUnit进行单元测试 简介 JUnit是一个Java编程语言的单元测试框架。JUnit在测试驱动的开发方面有很重要的发展，是起源于JUnit的一个统称为xUnit的单元测试框架之一。 好处 1.可以书写一系列的测试方法，对项目所有的接口或者方法进行单元测试。 2.启动后，自动化测试，并判断执行结果,不需要人为的干预。 3.只需要查看最后结果，就知道整个项目的方法接口是否通畅。 4.每个单元测试用例相对独立，由Junit启动，自动调用。不需要添加额外的调用语句。 5.添加，删除，屏蔽测试方法，不影响其他的测试方法。开源框架都对JUnit有相应的支持。 环境配置 从官网http://www.junit.org 下载JUnit最新版本的压缩文件。 JUnit断言 Junit所有的断言都包含在Assert类中。 这个类提供了很多有用的断言方法来编写测试用例。只有失败的断言才会被记录。Assert类中的一些有用的方法列式如下： voidassertEquals(booleanexpected,booleanactual):检查两个变量或者等式是否平衡voidassertTrue(booleanexpected,booleanactual):检查条件为真voidassertFalse(booleancondition):检查条件为假voidassertNotNull(Objectobject):检查对象不为空voidassertNull(Objectobject):检查对象为空voidassertSame(booleancondition):assertSame()方法检查两个相关对象是否指向同一个对象voidassertNotSame(booleancondition):assertNotSame()方法检查两个相关对象是否不指向同一个对象voidassertArrayEquals(expectedArray,resultArray):assertArrayEquals()方法检查两个数组是否相等 JUnit注解 @Test:这个注释说明依附在JUnit的publicvoid方法可以作为一个测试案例。@Before:有些测试在运行前需要创造几个相似的对象。在publicvoid方法加该注释是因为该方法需要在test方法前运行。@After:如果你将外部资源在Before方法中分配，那么你需要在测试运行后释放他们。在publicvoid方法加该注释是因为该方法需要在test方法后运行。@BeforeClass:在publicvoid方法加该注释是因为该方法需要在类中所有方法前运行。@AfterClass:它将会使方法在所有测试结束后执行。这个可以用来进行清理活动。@Ignore:这个注释是用来忽略有关不需要执行的测试的。 JUnit加注解执行过程 beforeClass():方法首先执行，并且只执行一次。afterClass():方法最后执行，并且只执行一次。before():方法针对每一个测试用例执行，但是是在执行测试用例之前。after():方法针对每一个测试用例执行，但是是在执行测试用例之后。在before()方法和after()方法之间，执行每一个测试用例。 JUnit执行测试 测试用例是使用JUnitCore类来执行的。JUnitCore是运行测试的外观类。要从命令行运行测试，可以运行javaorg.junit.runner.JUnitCore。对于只有一次的测试运行，可以使用静态方法runClasses(Class[])。 JUnit参数化测试 Junit4引入了一个新的功能参数化测试。参数化测试允许开发人员使用不同的值反复运行同一个测试。你将遵循5个步骤来创建参数化测试。 用@RunWith(Parameterized.class)来注释test类。创建一个由@Parameters注释的公共的静态方法，它返回一个对象的集合(数组)来作为测试数据集合。创建一个公共的构造函数，它接受和一行测试数据相等同的东西。为每一列测试数据创建一个实例变量。用实例变量作为测试数据的来源来创建你的测试用例。 一旦每一行数据出现测试用例将被调用。 
第233篇文章[]
【软件构造】Git的使用 1.什么是Git? 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 2.目录结构 假如现在有一个工程被git管理，它分为三个部分：本地工作区，本地版本库（CMDB）的远程版本库。其中本地版本库有一个暂存区。 本地工作区就是你的工程所对应的本地文件夹 本地版本库是工作区（本地文件夹）下的.git隐藏文件夹。 远程版本库是你的工程在网络上的备份。 3.文件 文件时Git的基本配置项SCI（软件中发生变化的基本单元） 当一个文件被创建或者修改时，它与本地版本库中的相应文件不一样了，此时它处于“已修改”状态。 已修改的文件，可以通过gitadd命令，添加到暂存区，此时它处于“已暂存”状态。 已暂存的文件，可以通过gitcommit，把暂存区的文件汇总成一个commit，然后提交到本地版本库，此时它处于“已提交“”状态。 也可以通过gitcommit-a命令将已修改的文件提交commit。 4.操作 gitstatus可以查看当前工作目录的状态。 显示出来的文件总共有三种状态分别是 1.已添加至暂存区，未提交的（add后未commit的文件） 2.已修改，未暂存的 3.为追踪到的文件 gitdiff比较暂存区和工作区的文件的差异 gitdiffHEAD可以查看某个commit中的文件和当前工作区中的文件的差别 想要把本地的提交记录提交到远程，可以执行gitpush命令。 如果要把远程的提交记录拉回到本地，可以执行gitfetch命令。 如果要把远程的工程下载到本地，可以执行gitclone命令 如果要把远程工程拉到本地，并且立即和自己的本地版本合并，可以用gitpull命令。 要撤销本地工作区到暂存区的更改，可以用gitreset<file> 要撤销commit，可以用gitreset<commit> 5.分支 使用分支，相当于从现有的版本线上又分出来一条，可以加一些和以前不一样的版本分别管理，还可以合并，非常方便。 一次只能在一个分支上工作，要跳转分支，需要gitcheckout<branch> 要创建新分支，可以用gitcheckout-b<branch> 如果两个分支有共同的祖先，在某个时刻可以把这个有共同祖先的分支和自己合并，命令是gitmerge<branch> 6.总结（github官方的cheatsheet） 安装Git GitHub提供了包含图形界面的桌面客户端，通过客户端可以完成大部分常用的仓库操作，同时可以自动更新Git的命令行版本，以适应新的场景。 GitHubDesktop https://desktop.github.com/ GitHub的Linux和POSIX版本可以在官方的GitSCM网站上获取。 Git全平台版 http://git-scm.com 配置工具 对所有本地仓库的用户信息进行配置 $gitconfig--globaluser.name"[name]" 对你的commit操作设置关联的用户名 $gitconfig--globaluser.email"[emailaddress]" 对你的commit操作设置关联的邮箱地址 创建仓库 创建一个新的仓库或者从一个现有的链接获取仓库 $gitinit[project-name] 创建一个本地的仓库，并设置名字 $gitclone[url] 下载一个项目以及它所有的版本历史 更改 检查已有的编辑并执行commit操作 $gitstatus 列出所有新建或者更改的文件，这些文件需要被commit $gitdiff 展示那些没有暂存文件的差异 $gitadd[file] 将文件进行快照处理用于版本控制 $gitdiff--staged 展示暂存文件与最新版本之间的不同 $gitreset[file] 将文件移除暂存区，但是保留其内容 $gitcommit-m"[descriptivemessage]" 将文件快照永久地记录在版本历史中 批量更改 命名一系列commit以及合并已完成的工作 $gitbranch 列出当前仓库中所有的本地分支 $gitbranch[branch-name] 建立一个新分支 $gitcheckout[branch-name] 切换到一个特定的分支上并更新工作目录 $gitmerge[branch-name] 合并特定分支的历史到当前分支 $gitbranch-d[branch-name] 删除特定的分支 重构文件 重定位并移除版本文件 $gitrm[file] 从工作目录中删除文件并暂存此删除 $gitrm--cached[file] 从版本控制中移除文件，并在本地保存文件 $gitmv[file-original][file-renamed] 改变文件名并准备commit 保存临时更改 暂存一些未完成的更改 $gitstash 临时存储所有修改的已跟踪文件 $gitstashpop 重新存储所有最近被stash的文件 $gitstashlist 列出所有被stash的更改 $gitstashdrop 放弃所有最近stash的更改 查阅历史 浏览并检查项目文件的发展 $gitlog 列出当前分支的版本历史 $gitlog--follow[file] 列出文件的版本历史，包括重命名 $gitdiff[first-branch] [second-branch] 展示两个不同分支之间的差异 $gitshow[commit] 输出元数据以及特定commit的内容变化 撤销commit 擦除错误并更改历史 $gitreset[commit] 撤销所有[commit]后的的commit，在本地保存更改 $gitreset--hard[commit] 放弃所有更改并回到某个特定的commit 同步更改 注册一个远程的链接，交换仓库的版本历史 $gitfetch[remote] 下载远程仓库的所有历史 $gitmerge[remote]/[branch] 合并远程分支到当前本地分支 $gitpush[remote][branch] 上传所有本地分支commit到GitHub上 $gitpull 下载书签历史并合并更改 
第234篇文章[]
01软件构造的多维度视图和质量目标（软件构造） 软件构造的多维视图 三个维度 （1）编程时&运行时（2）时间&时刻（3）微观和宏观从这三个维度来看待软件构造，那么在这写维度的组合下，我们更关注一些什么呢？下图或许能解答你的疑惑！如图中所展示的九个内容，在下面将一一做出说明。 编程时的视图下 对于微观上的视图（Code-levelview），我们更加关注的是源代码：sourcecode。在这个视图下，主要分析代码的逻辑组织，即源代码是怎样在基本的编程块，例如函数、类、方法、接口等，在这些的基础上的逻辑组织。对于宏观的视图（Component-levelview），我们更加关注的则是整个工程的结构：architecture。此时，像文件、路径、包、库以及他们之间的相关性，则更加值得我们注意，换句话来说，在这个视图下，主要跟分析代码的物理组织。而在特定的时刻下，源代码和整体工程的特定形态也是我们分析代码的编程情况中必不可少的部分。最后，在一段时间内，也可以说是一定周期内（软件的开发呈现一定的周期性，这个问题之后或许会再来探讨），我们更关注的是发展和变化，在这段时间内修改的内容，添加的方法等等，而这些变化，人为的记录未免强人所难，这时，一个好的软件管理工具的使用能大大提高软件开发的效率，暂且按下不提。 （1）Build-time，moment，code-levelview 源代码在代码各部分的基础上是怎样逻辑组织的，例如函数、类、方法、接口等，以及它们之间的关系。而这些又可以从三个层面来看待：词汇层面、语法层面（例如：AbstractSyntaxTree（AST））、以及语义层面（例如：ClassDiagram） 词汇层面 即程序代码中使用的语句、字符串、以及变量以“近乎自然语言的风格+遵循特定的变成语法”的组织形式形成一种半结构化的源代码语言，这既方便了程序员的阅读，同时方便编译器的编译。如图，相信即使不懂Java语言，也能轻松看懂图中的代码做了一些什么事，而这样的组织结构，让不同的程序员在阅读他人的代码时节约时间。 语法层面 对于语法的层面，更加注重的是软件执行的过程，或者说是软件执行的算法流程。以图中左侧代码为例，构造出了AST（语法分析树），对应的就是程序执行的流程同样对于数据或者文件的操作也同样可以构造除AST来描述整个操作的流程。而AST的目的就是将程序彻底结构化，把源代码变成一棵树，对树做各种操作就是对源代码的修改。这应该怎么理解呢？以上图文件读取为例，在开发过程中，对读入文件的方式做出修改的话，只需要修改图中的①部分。这样结构分明的一棵树，便于修改的一种组织方式，对于我来说是没办法拒绝的。 语义层面 语义的含义是指源代码具体现实什么目标，例如：用UML来描述接口、类、属性、方法及它们之间的关系。而这些通常用图形化或者形式化的方法来表达“需求”和“设计”思想。如下图：该图相信可以清晰的表示人和学生、教授之间的关系，以及人与地址之间的关系。 （2）Build-time,period,andcode-levelview 主要关注的是编码时，代码的改变情况，即Codechurn代码变化，包括添加的行、文件的改进或删除、从一个版本到另一的版本的变化。而实现这些的管理，仅仅依靠自己是非常困难的，因此我们一般会使用一些版本控制工具。例如图中红色区域，就是该次修改的项目。更加清晰直观的表现出了变化的发生位置，设想这样一个场景，昨天保存的代码已经通过测试没有问题，而今天出现了bug，通过这样的版本控制工具就能尽快的定位到代码可能出错的位置。 (3)Build-time,moment,andcomponent-levelview 在这三个视图下，我们所关注的是代码的组织情况，简单来说就是在开发程序的时候会有很多的类、很多的文件，当然我们可以任意的放在工程里，但这样就会出现一个问题，如果想要对程序进行更改，那什么应该更改，什么不该更改这个问题就会需要耗费大量的时间去思考以及记录。一种好的组织方式就是利用模块化的方式来组织文件。比如功能类似的、完成某个功能的文件放在一个包里，这样上面的问题就迎刃而解了。如图中的ADT等。 Library 对于组织程序文件的时候，一种最简单的方法就是利用库函数（library）的形式来进行组织。在编程时，很多情况下，大部分的功能其实并不需要我们自己编写，大部分情况下我们可以调用第三方的库文件中的方法直接使用，就像使用编程指令一样使用库中的功能，例如： System.out.println("HelloWorld"); 除了编辑阶段，在构建阶段也可以使用库文件，例如我们可以用maven提供的资源；在测试阶段很多的第三方库也为我们提供了便利。 Linkingwithalibrary 但库文件毕竟是第三方提供的，那么我们如何去使用这些库文件呢？回想一下刚开始使用java的时候，我们需要配置java环境以及资源目录，而这些工作就是为了在之后的代码编写过程中告诉程序库文件的位置。但仅仅找到是不够的，我们要做的第二步就是告诉程序怎么把库文件链接到程序中，链接的方式有两种，一种是静态链接，一种是动态链接。关于链接的内容可以参考学习《深入理解计算机系统》，在这里只作简单介绍。静态链接是将库被拷贝进入代码形成整体，执行的时候无需提供库文件，这种链接发生在构造阶段，当然这样做的坏处就是当库文件更新升级的升级后，程序中的库文件相关资源是不会发生改变的；而动态链接则是在程序运行时，通过地址动态的使用库文件中的资源，因此，在将程序打包发送时，不要忘记将用到的库文件一并打包发送给客户！如图是一个模块化的UML图，与代码级别不同的是，这个图不在将视线聚集在方法和类等之间的关系，而是例如图中shoppingcart和orders之间。 (4)Build-time,period,andcomponent-levelview 在这些维度下，其实我们所关注的也是代码的改变情况，简单来说，也就是希望我们能够知道在这个阶段中，我们对这个代码做了什么改变。没错！还是版本控制工具！softwareconfigurationitem！比如说window在不同的阶段会有不同的版本，我们就希望能把它记录下来。例如图中，我们希望记录每个文件的不同的开发版本，而最后我们所发布的finalversion实际上就是file1的1.3，file2的1.2，以及file3的1.4的版本。而版本控制工具除了记录的功能外，它还提供了另一个非常重要的功能，支持协同开发。通常一个大的工程，不可能由一个人甚至是几个人来完成，他有可能是由一个大的几十甚至几百人的团队来负责开发的，那么这个时候就需要协同工作，在工程的不同分支上开发完成部分功能以及对这些功能的集成。如上图，可能每个分支就是不同的模块的功能的开发，这样能够在一定程度上不影响别人的工作状况下独立的完成自己的工作。 运行时的视图下 运行时，程序被载入目标机器，开始执行在code-levelview的维度，我们关心的是逻辑实体，例如：对象、函数等，在内存中如何呈现？其实很简单，我们使用的java是一种面向对象的编程语言，在程序进行运行的时候，我们所关注的就是程序在某一个时间点到底有多少个对象，以及对象里面的值是什么样的。而在模块化的角度，我们更关注的是多个模块在运行时的配置是什么样的，即在软件层面，物理实体（OS、network、hardware等等）在物理硬件环境中如何呈现？目前很多的程序都是采用分布式的情况来进行配置的，什么的是分布式呢，简单来说，就是一个程序并不是就安装在一个机器上，而可能是被分割成了几部分，安装在了不同的机器上来进行运行的。在时刻视角下，我们可能更关注的是程序在内存中的情况，程序占用内存的空间有多大，程序在某个时间点生成了多少个对象。在时间或者周期的角度，我们关注的是这个程序在执行时到底需要多大的内存等问题。 (5)Run-time,moment,andcode-levelview 在当前视图下，我们关注的就是程序在某一个时间点到底有多少个对象，以及对象里面的值是什么样的。这时候我们引入一个snapshotdiagram（代码快照图）来描述当前我们所关注的信息。如上两图，我们所关注的信息就一目了然了。而该图的含义与结构我们暂且按下不提。同样另外一个我们所使用的方法是memorydump（内存信息转储），这种工具科技方便的查看内存的使用情况。最常见的memorydump工具相信我们都并不陌生任务管理器！它就能告诉我们在运行过程中，程序的一些内存占用信息。 (6)Run-time,periodandcode-levelview 这个角度我们所看重的是代码的执行情况，这也可以通过一个UML图来表示，这时的UML图我们称之为运行视图，或者也可以称之为时序图，这个时序图就描述了在和层序运行的时候，多个类、多个方法之间是怎么进行调用的。当然我们还可以利用一些工具，例如一些列的tracing也就是追踪的工具，来了解到程序在执行的时候的一些信息，即用日志记录程序执行的调用次数。如下图： (7)Run-time,moment,andcomponent-levelview 在这个维度下，我们从模块的角度来看待代码的组织情况，即程序在不同的机器或者单元上的配置情况，如下图： (8)Run-time,period,andcomponent-levelview 在这最后一个维度下，我们关注的是整个系统的调用情况或系统的使用情况，我们可以通过日志文件从系统的层面上看待程序的使用情况，例如程序被调用、被挂起、程序结束等信息。如下图： 总结 将以上八个维度下的关注重点放在同一张表格中，我们就得到了本文讨论的内容：软件构造的多维度视图。表格中被红色框矿主的部分就是软件构造这门课会涉及的部分，而其他的知识点也推荐大家去了解知识点对应的内容。从不同的维度下看待软件构造，梳理了一遍之后，相信我们对如何构造使用工具来对软件进行监视和了解有了进一步的认识，当然还有如何构造一个好的软件也有了初步的判断，但更多的内容还需要之后慢慢探索。 引用 以上博文中的资料均引用自2021年春季学期软件构造课程（任课教师：王忠杰感谢老师的倾囊相授！）中的内容，加上个人对其的稍许理解。 欢迎各位相约探讨！ 
第235篇文章[1]
2021-06-30 摘要 为了学习计算机系统并对计算机有更好的了解，本文通过一个简单的小程序hello.c从产生到死亡的一生，来介绍Linux系统下的程序从代码到运行再到最后终止过程的底层实现进行了分析，描述了与之相关的计算机组成与操作系统的相关内容。过gcc、objdump、gdb、edb等工具对一段程序代码预处理、编译、汇编、链接与反汇编的过程进行分析与比较，并且通过shell及其他Linux内置程序对进程运行过程进行了分析。关键词：计算机系统；汇编；计算机组成原理； 第1章概述 Hello简介 简述Hello的P2P，020的整个过程。P2P（FromProgramtoProcess）：Hello.c（program）文件通过预处理，编译，汇编，链接，生成可执行文件hello，随后在Bash里，OS为该文件fork出子进程（process），并将文件execve入内存，再进行mmap映射，在分配的时间片得以执行，在Hardware上运行。完成P2P的过程。020（FromZero-0toZero-0）：shell为其execve映射虚拟内存。进入程序入口后，程序开始加载物理内存，然后进入main函数执行目标代码。CPU为正在运行的hello分配时间片以执行逻辑控制流。程序完成后，shell父进程负责恢复hello进程，内核删除相关的数据结构这就是hello的020过程； 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。Ubuntu64位，Windows1064位codeblocks,gdb,edb,visualstudio2019 1.3中间结果 文件名文件作用hello.c:源代码hello.i:hello.c文本预处理后得到的程序文件hello.s:hello.i编译后得到的汇编程序文件hello.o:hello.s汇编后得到的可重定位目标程序文件hello:链接后得到的可执行目标程序文件 1.4本章小结 初步介绍了hello程序的过程。 第2章预处理 2.1预处理的概念与作用 预处理的概念：编译预处理是C语言编译程序的组成部分，用于解释处理C语言源程序种的各种预处理指令，形式上都以#开头不属于C语言种真正的语句，但增强了C语言的编程功能，提高编程效率，C程序的编译处理用于把每一条C语句用若干条机器指令来实现，生成目标程序。由于#define等编译预处理指令不是语句，不能被编译程序翻译，需要在真正编译之前做一个预处理，解释完成编译预处理指令，从而把预处理指令转换成相应的C程序段，最终称为由纯粹C语句构成的程序，经编译后得到目标代码。作用：方便编译器的编译工作，1.宏定义；2.文件包含；3.条件编译。预处理命令以符号“#”开头。 2.2在Ubuntu下预处理的命令 gcc-Ehello.c-ohello.i Hello的预处理结果解析 hello.c程序中只包含三条预处理指令#include<stdio.h>#include<unistd.h>#include<stdlib.h>经过预处理后，Hello.c中的注释删除（见附件hello.i）前面三个消失了，出现了一大段代码（见附件hello.i及截图） 本章小结 描述了预处理的概念和作用，对hello.c进行了预处理，并分析结果。 第3章编译 3.1编译的概念与作用 概念：1、是利用编译程序将一段程序转换为指令集的过程。不同架构的指令集自然是不同的，带来的影响就是同一段代码，编译过后只能运行在对应的指令集上，比如一段C代码，在X86下编译完了，只能在X86下运行，而不能运行在ARM架构下运行。而事实上，编译得到的结果，更是操作系统相关的。假设，一段程序被编译成了X86下的硬程序，但是无法同时运行在Windows上和Linux上（Windows和Linux操作系统都可以装在X86架构的CPU上），如果程序一开始是在Windows操作系统下编译的，那这段程序就无法运行在其他比如Linux操作系统中。也就是说，编译与操作系统和CPU这二者都是相关的。作用：它把高级语言翻译成更接近机器语言的汇编语言 3.2在Ubuntu下编译的命令 gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 1.全局变量：全局变量在data节中定义它，并且解释了它。2.局部变量：局部变量会在栈中储存它，给他分配一个大小符合的字节大小。3.控制符及其跳转：利用jump，set，cmp等指令对程序进行跳转。4.main函数：.text在text节中定义.globlmain声明全局符号global.typemain,@function将main声明为函数随后定义main:标签，后跟main函数伪汇编指令 5.printf(“Usage:Hello学号姓名！\n”);Movl$.LC0,%ediCallputs第一处printf用puts替换，即可以读入缓冲区数据 将.LC0的部分传入参数，执行printf.LC0定义在.rodata节中，是一个字符常量.LC0:.string“Usage:Hello1190201226\345\215\223\345\215\216\357\274\201”6.字符串“Usage:Hello1190201226\345\215\223\345\215\216\357\274\201”对应Usage:Hello1190201226卓华！\n中文被编码为UTF-8格式“Hello%s%s\n”对应第二个printf中的格式化参数7.数组：Hello.c里有一个数组，就是main函数的第二个参数argv[]，argv作为一个指针数组，每个地址是8位，访问数组的地址，就是知道首地址之后，在这个地址基础上加上数据元素的大小，就到了下一位。分别取了argv[1]和argv[2]。9.函数：1.exit函数： 参数传递：传入的参数为0，再执行退出命令函数调用：if判断条件满足后被调用2.sleep函数：参数传递：传入参数sleepsecs，传递控制：callsleep函数调用：for循环下被调用3.getchar函数传递控制：callgetchar函数调用：在main中被调用 3.4本章小结 第4章汇编 4.1汇编的概念与作用 概念：通过汇编器把汇编语言翻译成机器语言的过程作用：通过汇编过程把汇编代码转换成机器代码 4.2在Ubuntu下汇编的命令 ashello.s-shello.o 4.3可重定位目标elf格式分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 在linux下生成hello.o文件elf格式的命令：readelf-ahello.o>hello.elf在未装入内存运行前的elf文件信息：ELF头：文件格式节头表：节头表中各段含义：.text：已经编译程序的机器代码.rodata：只读数据.data：初始化的全局和静态变量.bss：未初始化的全局和静态变量.symtab：符号表，是用来存放程序中定义和引用的全局变量和函数的信息。Name：是符号名，用来可重定位，value：是符号相对于目标节的起始位置偏移，size：是目标的大小，type：是数据还是函数，bind表明是全局还是局部。.rel.text：一个.text节中位置的列表.rel.data：别模块引用或定义的所有全局变量和重定位信息.debug：调试符号表.line：行号与.text的机器指令之间的映射.strtab：一个字符串表重定位节：重定位节表明了链接过程中的重要数据，而其中的符号值则可以区分动态链接和静态链接PC32说明链接内容是静态链接，而PLT32说明链接内容是动态链接内容eh_frame即exceptionhandleframe即异常处理框架就是说,这是与重定位相关的一个异常处理单元符号表：符号表中有hello.o中定义和引用的函数和全局变量，信息，其中包含大小、类型、名字等信息 4.4Hello.o的结果解析 反汇编：hello.shello.txt反汇编后与第三章中hello.s的比较发现：汇编器在汇编hello.s时：1：为每条语句加上了具体的地址，全局变量和常量都被安排到了具体的地址里面。2：操作数在hello.s里面都是十进制，在到hello.o里面的机器级程序时都是十六进制。3：跳转语句jx&jxx原来对应的符号都变成了相对偏移地址。4：函数调用时原来的函数名字也被替换成了函数的相对偏移地址。说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致、分支转移函数调用等。 4.5本章小结 介绍了汇编的概念与作用，分析了ELF格式文件，节头目表，符号表以及可重定位节。 第5章链接 第5章链接 5.1链接的概念与作用 概念：链接是将各种代码和数据片段收集并组合成一个可被加载到内存并执行的文件的过程。作用：将各种代码和数据片段收集并组合成一个文件 5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib/ld-linker.so.2/usr/lib/crt1.o/usr/lib/crti.o-lhello.o/usr/lib/ctrn.o 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。Elf头：节头表： 如图：共29个表项，地址和偏移量标注了起始地址，大小则标注了各段的大小 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。Hello的虚拟地址空间的起始为0x400000，结束与0x400ff0；而。Text节的起始地址为：0x400550，大小为0x132 5.5链接的重定位过程分析 hello中包含一些外部文件的宏定义、变量、库函数和操作系统的启动代码等，且.o文件.text节从0开始，而可执行文件.text节并非从0开始。过程：分为符号解析和重定位两步1.符号解析：目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。链接器将每个符号引用与一个确定的符号定义关联起来如图：节头与符号表中即可知道符号定义与引用，详见附件。2.hello重定位的过程：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。如图：左边跳转信息在重定位表中（见附件hello.elf）而右边则准确标注了跳转的地址。(1)重定位节和符号定义链接器将所有类型相同的节合并在一起后，这个节就作为可执行目标文件的节。然后链接器把运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号，当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。(2)重定位节中的符号引用这一步中，连接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。执行这一步，链接器依赖于可重定位目标模块中称为的重定位条目的数据结构。(3)重定位条目当编译器遇到对最终位置未知的目标引用时，它就会生成一个重定位条目。 5.6hello的执行流程 子程序名程序地址（16进制）ld-2.27.so_dl_start7efbff4d8ea0ld-2.27.so_dl_init7efbff4e7630hello_start400500libc-2.27.so__libc_start_main7efbff100ab0Hello_printf@plt（调用了10次）4004c0Hello_sleep@plt（调用了10次）4004f0hello!getchar@plt4004d0libc-2.27.so!exit7efbff122120 5.7Hello的动态链接分析 基本思想是：程序按照模块拆分成各个相对独立部分，在程序运行时将它们链接在一起形成一个完整的程序，不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时，还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。 5.8本章小结 介绍链接的概念与作用，对hello.o进行链接得到hello文件，并对结果进行分析 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程是计算机程序需要进行对数据集合进行操作所运行的一次活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程的作用：进程为用户提供了以下假象：我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 shell俗称壳，它是指UNIX系统下的一个命令解析器；主要用于用户和系统的交互。UNIX系统上有很多种Shell。首个shell，即BourneShell，于1978年在V7(AT&T的第7版)UNIX上推出。后来，又演变出Cshell、bash等不同版本的shell。Shell处理流程：1.打印提示信息2.等待用户输入3.接受命令4.解释命令5.找到该命令，执行命令，如果命令含有参数，输入的命令解释它6.执行完成，返回第一步 6.3Hello的fork进程创建过程 调用fork函数先创造出一个子进程，然后形成自身的一个子进程 6.4Hello的execve过程 在shell的子进程中执行execve函数，将参数传给Hello程序，并执行Hello 6.5Hello的进程执行 一开始，Hello运行在用户模式，当程序收到一个信号时，进入内核模式，运行信号处理程序，之后再返回用户模式。在Hello运行的过程中，cpu不断切换上下文，使Hello程序运行过程被切分成时间片，与其他进程交替占用cpu，实现进程的调度。结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 6.6hello的异常与信号处理 故障：缺页异常，hello进程的页表被映射到hello文件，然而实际代码拷贝至内存仍未完成，在执行到相应地址的代码时会引发缺页异常。终止：不可恢复错误发生。中断：接受到键盘键入的信号，如ctrlZ,ctrlC等hello执行中处理的信号:SIGINT,SIGSTP,SIGCONT,SIGWINCH信号处理：Crtlc：退出程序Ctrlz：挂起使用ps查看进程号：PID：3048以及3056即为挂起的hello程序Fg:前台运行 kill进程：使用pstree查看： 6.7本章小结 介绍了进程的概念与作用，分析了hello的执行过程（第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址。逻辑地址：程序代码经过编译后出现在汇编程序中地址。逻辑地址由选择符（在实模式下是描述符，在保护模式下是用来选择描述符的选择符）和偏移量（偏移部分）组成。线性地址(linearaddress)或也叫虚拟地址(virtualaddress)跟逻辑地址类似，它也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件页式内存的转换前地址。 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 7.2Intel逻辑地址到线性地址的变换-段式管理 8086共设计了20位宽的地址总线，通过将段寄存器左移4位加上偏移地址得到20位地址，这个地址就是逻辑地址。将内存分为不同的段，段有段寄存器对应（段寄存器主要是由mmu管理），段寄存器有一个栈、一个代码、两个数据寄存器。在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值(index)。 7.3Hello的线性地址到物理地址的变换-页式管理 首先先将线性地址分为VPN+VPO的形式，然后再将VPN拆分成TLBT+TLBI，然后去TLB缓存里找所对应的PPN，如果发生缺页情况则直接查找对应的PPN，找到PPN之后，将其与VPO组合变为PPN+VPO就是生成的物理地址了。 7.4TLB与四级页表支持下的VA到PA的变换 将VPN分成三段，对于TLBT和TLBI来说，可以在TLB中找到对应的PPN，但是有可能出现缺页的情况，需要到页表中去找。VPN被分成了更多段（这里是4段）CR3是对应的L1PT的物理地址，然后一步步递进往下寻址，越往下一层每个条目对应的区域越小，寻址越细致，在经过4层寻址之后找到相应的PPN让你和和VPO拼接起来。 7.5三级Cache支持下的物理内存访问 先将虚拟地址转换为物理地址，再对物理地址进行分析，物理地址由CT、CI、CO组成，然后在一级cache内部找，用CI位进行索引，如果匹配成功且valid值为1，则称为命中，根据偏移量在L1cache中取数，如果不命中，在分别到L2、L3和主存中重复上述过程 7.6hello进程fork时的内存映射 执行新进程（hello）时，为这个新进程创建虚拟内存 创建当前进程的的mm_struct,vm_area_struct和页表的原样副本两个进程的每个页面都标记为只读页面两个进程中的每个区域结构（vm_area_struct）都标记为私有。当需要写时，则需要再创建一个段，将需要写入的东西写入到该段中去。 7.7hello进程execve时的内存映射 删除已存在的用户区域；创建新私有区域结构；创建新共享区域；设置PC，指向代码的入口点 7.8缺页故障与缺页中断处理 （1）段错误：首先判断这个缺页的虚拟地址是否合法，遍历所有的合法区域结构，如果这个虚拟地址对所有的区域结构都无法匹配，就返回一个段错误。（2）非法访问：查看地址的权限，判断一下进程是否有读写改这个地址的权限。（3）如果不是上面两种情况那就是正常缺页，就选择一个页面换入新的页面并更新到页表。 7.9动态存储分配管理 基本方法：维护一个虚拟内存区域“堆”，将堆视为一组不同大小的块的集合来维护，每个块要么是已分配的，要么是空闲的，需要时选择一个合适的内存块进行分配。1记录空闲块，可以选择隐式空闲链表，显示空闲链表，分离的空闲链表和按块大小排序建立平衡树2放置策略，可以选择首次适配，下一次适配，最佳适配3合并策略，可以选择立即合并，延迟合并4需要考虑分割空闲块的时机，对内部碎片的忍耐阈值. 7.10本章小结 描述了存储的概念，进程fork和execve内存映射的内容，以及缺页问题和动态存储分配问题。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：将设备抽象成文件设备管理：通过unixio接口管理 8.2简述UnixIO接口及其函数 打开和关闭文件:open()andclose()读写文件:read()andwrite()改变当前的文件位置lseek() 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall等.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 （以下格式自行编排，编辑时删除）异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 了解了hello的IO管理。结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。先用C语言编写hello.c,作为源代码。预处理hello.c，将hello.c调用的所有外部的库合并到一个hello.i文件中。然后进行编译，成为汇编文件hello.s；汇编hello.s,会变成为可重定位目标文件hello.o；链接，将hello.o与可重定位目标文件和动态链接库链接成为可执行目标程序hello；shell中运行hello；Shell调用fork创建子进程；运行程序：shell调用execve，execve调用启动加载器，加映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数；CPU分配时间片，hello在一个时间片中顺序执行；访问内存，MMU将程序中使用的虚拟内存地址通过页表映射成物理地址；.动态申请内存：printf会调用malloc向动态内存分配器申请堆中的内存；如果运行途中键入中断，则调用shell的信号处理函数分别停止、挂起；shell父进程回收子进程，内核删除为这个进程创建的所有数据结构。如果父程序不能回收该子程序，则由中断直接收回。 附件 hello.c用C语言编写的hello程序源代码hello.i经预处理处理得到的文本文件hello.s编译后得到的汇编代码hello.o汇编操作得到的可重定位目标执行文件hello可执行程序 参考文献 为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 
第236篇文章[]
[软件构造]2020春HIT软构心得(IDEA+MAVEN+TravisCI) HIT的软构课程推荐使用Eclipse编写代码，并且三次实验都默认你使用Eclipse，而像我这样喜欢好看的IDE的人当然会选择用IDEA来编写代码。因此本文会讲述如何在IDEA环境下来完成软构实验的一些内容，并且简单讲述Maven的一些小技巧，以及如何用TravisCI进行在线build。 （使用的IDEA版本为2020.3.3，社区版） 目录 IDEA使用tips IDEA下用Maven构建项目 如何用TravisCI进行在线build 总结 IDEA使用tips 1.利用集成的Git进行相关操作 事实上，IDEA的功能是强大的，它集成了Git，并且让Git的许多操作变得十分简便易懂。 （关于Git的安装及使用本文不再赘述，B站教程很多，个人推荐尚硅谷） 对于一个新建工程，首先在最上面的一堆菜单选项中找到"VCS"，然后点击"CreateGitRepository"就可以创建本地仓库。 在创建了Git的本地仓库后，就可以点击IDEA上方的Git栏，看到下图所示界面。 点击Commit，可以将修改好的代码上传到本地仓库；点击Push，可以将本地仓库的代码上传到GitHub。这两个功能是实验中最常用到的功能。 需要注意的是，在第一次push前，需要先设置remotes（即下方的ManageRemotes）。点进去之后，可以创建新的remote。这里remote的名字只是你给URL地址起的一个别名，可以随便起。 在push过程中，我们可以选择将本地仓库的内容推送到一个远程仓库。在软构实验中，就是推送到专门的实验仓库中。 注意，push过程中，你有两个地方可以更改。第一个是你的remote，代表远程仓库的地址，第二个紧跟在remote后面，代表远程仓库的分支名字。通常我们都会推送到master分支上，所以将名字改为master即可。 此外，如果你在自己的实验仓库页面修改了分支名字，比如将初始生成的main分支改为master，那么第一次push很可能失败，因为有可能出现分支合并错误。你可以将分支改回main，再推送一个master；或者在写代码前先将远程仓库pull下来，这样就不会产生分支合并错误。 在今年的实验3中，还需要新建分支。此处直接点击"NewBranch"（需要至少commit一次该按钮才会亮起），输入新分支的名字点击创建即可。默认会勾选"Checkoutbranch"，代表新建分支后，自动将头指针移动到该分支。 2.设置test目录 根据目录要求，你需要在lab工程下创建src和test这两个目录。通常src会在新建工程时自动创建好，而test目录需要我们自己创建，创建好后如下图所示： 但是我们会发现，在test目录下，无法直接像在src目录下那样直接创建一个java文件。此时需要我们更改一些设置：右键工程根文件夹，然后选择“OpenModuleSettings”。 进入下图所示界面后，右键test目录，将其设置为“Tests”即可，之后你会发现test目录变为了绿色，那就代表设置成功。 设置成功后，你就可以正常地在test目录下添加java文件，来对你的代码进行测试。 （有关Junit的使用方法，网上也有很多教程，此处不再赘述） 3.测试代码覆盖率 在第二个实验中，会让你用Eclipse中的EclEmma来统计Junit测试用例的代码覆盖度。但在IDEA中你是找不到这个插件的（因为这个插件是为Eclipse设计的），取而代之，你可以找到JaCoCo。但没关系，你可以放心使用，因为EclEmma在2.0版本之后是基于JaCoCo设计的。 在编写完Junit测试代码并点击小绿色箭头测试前，你可以看到这个界面： 为了使用JaCoCo，首先点击最下面的"ModifyRunConfiguration"，进入如下界面： 默认设置都不用动，但你需要选择"CodeCoverage"栏右边的那个"Modify"选项，点开如下： 为了选择JaCoCo，你需要勾选"Specifyalternativecoveragerunner"。勾选之后，下方会多出一个选项： 默认选项应该是IntelliJIDEA，你只需要选为JaCoCo即可。 更改完设置以后，再次点击绿色箭头，选择第三个选项"Run‘xxx’withCoverage"，之后就会在右边显示相关的覆盖率数据。通常来讲不用过分追求百分百覆盖率，这不现实，也没必要。但是如果覆盖率很低，那就说明你需要重新设计测试代码，尽可能地去让每个函数的每个分支都能被测试到。 IDEA下用Maven构建项目 在课程中，会讲到软件构造的整个流程，其中一步就是Build，也就是构建。而Maven就是一个很棒的构建工具，此外它也是一个依赖管理工具和项目管理工具，能通过配置文件中的依赖关系从中央仓库中下载项目所需的外部库。 由于笔者能力有限，对于Maven的许多功能研究的并不透彻，只能做到抛砖引玉，同时让读者避开一些坑。下面开始讲如何用Maven构建一个项目。 1.添加Maven框架支持 依旧是右键工程根目录，点击"AddFrameworkSupport"。 之后在界面中勾选Maven，点击OK，就将Maven添加到你的工程中了。 （如果添加之后出现Errorreading，点击右边Maven框中的转圈的箭头按钮即可） 添加完之后，我们欣（wu）喜（yu）地发现项目的目录结构变了，同时多出了一个pom.xml配置文件，如下图。 但是！实验手册对目录结构有明确要求，我们不想改变目录结构！ 那有人就说了，我不用Maven不就行了！逃避虽然可耻，但有用！ Maven还是要用的，毕竟之后我们还要验证我们的程序是否能脱离本机环境跑起来，而这也是实验手册的要求。毕竟，仅仅能让代码在你的机器上跑起来是不够的！ 2.更改Maven目录结构 让我们先看看目录结构都改变什么了。首先是src目录，原先它是我们代码的根目录，现在代码的根目录变成了src\main\java，而test目录也变成了src\test\java（虽然之前的test目录也能用）。 这其实是Maven约定的目录结构（具体的目录结构可以去网上搜，很多详解）。而我们为了更改目录结构，就不得不打开pom.xml这个配置文件了！ 初始时，配置文件里会有如下信息（看不懂就对了，我也看不懂，就能看懂个UTF-8） <?xmlversion="1.0"encoding="UTF-8"?> <projectxmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"> <modelVersion>4.0.0</modelVersion> <groupId>groupId</groupId> <artifactId>test</artifactId> <version>1.0-SNAPSHOT</version> <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> </properties> </project> 现在我们在其中加上一些信息。 <?xmlversion="1.0"encoding="UTF-8"?> <projectxmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"> <modelVersion>4.0.0</modelVersion> <groupId>groupId</groupId> <artifactId>test</artifactId> <version>1.0-SNAPSHOT</version> <build> <sourceDirectory>src</sourceDirectory> <testSourceDirectory>test</testSourceDirectory> </build> <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> </properties> </project> 没错，就是多了一段build信息！更新配置文件信息后，你会看到这样一个小框： 直接点击按钮，它会帮你根据更新后的配置信息更改项目结构。让我们看看更新后的目录结构： src目录又回来了！test目录也回来了！问题成功解决！接下来你就可以把那些与实验无关的文件夹删掉了： 有的人会说，我直接像之前那样更改ModuleSettings不行吗？答案是否定的，不然我也不会去一个我看不懂的配置文件中去修改信息了2333 现在这个目录结构就符合实验手册的要求了。但是还没完！我们还需要往配置文件里加点信息。 3.添加Junit4依赖 我们在build项和version项中间加一些依赖关系信息： <dependencies> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> </dependency> </dependencies> 如果不加这个信息，你之后在用Junit4写测试用例时，是无法用maven构建成功的！ 如果以后你需要添加别的依赖关系，只需要按照dependency书写的格式，在dependencies中新加一个条目即可。 简单来说，dependency中的这三条信息可以唯一确定一个依赖条目，就像是函数中的一对一映射一样。至于这三条信息具体写什么，可以直接去Maven中央仓库网页（MavenRepository:Search/Browse/Explore(mvnrepository.com)）去查找，人家都会给你写好的。 4.用Maven进行测试 在右侧的Maven菜单中，双击Lifecycle中的test选项，Maven就会自动帮你执行test以前包括test的所有步骤。这里我们是想用Maven帮我们跑测试用例。 之后，我们就会看到一些输出信息，其中就可以看到关于测试用例的信息。 （中间如果出了什么错误信息可以百度，因为我也不知道会遇到什么千奇百怪的错误，我自己也遇到过各种错误，就挺离谱的） 请注意，想要让Maven识别你的测试文件，你需要以一定的格式来命名测试文件，比如xxxTest或者TestXXX。在测试过程中，我发现如果将文件名改成别的（比如单走一个t），Maven就不会输出测试信息。 5.控制台输出乱码 在刚才测试的过程中，如果你输出了一些中文信息，可能会出现乱码的情况！如果出现乱码，请试一试如下的解决方案（不保证百分百好用，不好用还可以继续百度） 如下图，修改pom.xml中的properties信息，新加两行。 <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <argLine>-Dfile.encoding=UTF-8</argLine> </properties> 至此关于Maven的一些使用方法就讲完了，由于笔者能力有限，如有错误，恳请斧正！ 如何用TravisCI进行在线build 其实本来可以不用Maven来如此费力的构建项目的（过程中还会出现许多莫名其妙的错误毁心态）。 不过一方面，如果想从走软构方向，这些东西是一定要会的，另一方面就是，Maven是我们接下来用TravisCI进行在线build的基础。 有关TravisCI如何注册、使用的方法，可以自行百度，教程多得很。接下来我们只是讲解如何用它在线build一个Java项目。 其实很简单，首先你需要在根目录下新建一个yml类型的文件 .travis.yml （注意，travis前面还有一个点） 然后复制如下代码： language:java jdk:openjdk8 branches:master install:mvninstall-DskipTests=true-Dmaven.javadoc.skip=true script:mvntest （如果你是手写，请务必记住，每一个条目的冒号后面都有一个空格！这是语法要求！不添加空格会识别不了相关信息） 其中，language条目说明了你的代码使用的是什么语言；jdk条目说明了你的jdk版本（比如jdk8）；branches条目说明了从GitHub仓库上的哪个分支去找代码；script条目相当于一个脚本，说明了要执行的命令，比如"mvntest"（就是上一节中的用Maven跑测试代码的命令） （至于install那个命令我也不知道什么意思，实在是能力有限） 之后你只需要把这个文件和仓库里的其他文件一起push到仓库中就可以了！TravisCI会很聪明地找到这个文件，然后开始根据这个文件帮你在线Build。如果你的项目在本机上可以用Maven成功构建，那么大概率在线build也不会出问题。 在等待10多秒之后，TravisCI就会提示你build成功，同时输出一些日志信息，在这里你同样可以看到测试信息（下图只截取成功时的部分画面，测试代码背景是本课程的lab2） 至此，你已经成功地让自己的项目脱离本机环境运行起来了，可喜可贺！ 总结 以上就是我在用IDEA进行软构实验中的一些小心得（和踩坑体验），希望能让学弟学妹少踩一些坑！当然，这篇文章并不是一篇保姆级教学，因此一些基础知识仍然需要在网上搜索资料，自行学习（这也是对能力的一种锻炼）。希望对你们有帮助！ 
第237篇文章[]
软件构造(一)srcrefspecmasterdoesnotmatchany的解决方案 在使用Git向Github上面push代码的时候,出现了 error:srcrefspecmasterdoesnotmatchany. 的问题,查阅了很多博客的解决方法针对于我的这次提交都无法解决该问题.最后发现是在push的时候没有切换分支导致的.只需要加入一句 gitcheckout分支名字 成功把分支切换成master分支,就可以解决这个error成功push项目代码啦!!! 
第238篇文章[]
软件构造(四)Override与Overload Override重写重写是子类对父类的允许访问的方法的实现过程进行重新编写,返回值和形参都不能改变。 重写不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常,也不能出现新的函数. 在面向对象原则里，重写意味着可以重写任何现有方法。参数列表与被重写方法的参数列表必须完全相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5及更早版本返回类型要一样，java7及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 方法的重写规则 1.父类的成员方法只能被它的子类重写。 2.声明为final的方法不能被重写。 3.声明为static的方法不能被重写，但是能够被再次声明。 4.若子类和父类在同一个包中，那么子类可以重写除了声明为private和final的所有方法。 5.若子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 6.重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 7.构造方法不能被重写。 8.如果不能继承一个类，则不能重写该类的方法。 当需要在子类中调用父类的被重写方法时，要使用super关键字。 classBird{ publicvoidmove(){ System.out.println("鸟儿可以叫"); } } classCooingextendsBird{ publicvoidmove(){ super.move();//应用super类的方法 System.out.println("鸽子可以咕咕咕"); } } publicclassTestCooing{ publicstaticvoidmain(Stringargs[]){ Birdb=newCooing();//Cooing对象 b.move();//执行Cooing类的方法 } } 执行结果应为 鸟儿可以叫 鸽子可以咕咕咕 Overload重载重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法都必须有一个不一样的参数类型列表。 最常用的地方就是构造函数的重载。 重载的规则 1.被重载的方法必须改变参数列表(参数个数或类型不一样)；2.被重载的方法可以改变返回类型；3.被重载的方法可以改变访问修饰符；4.被重载的方法可以声明新的或更广的检查异常；5.方法能够在同一个类中或者在一个子类中被重载。6.无法以返回值类型作为重载函数的区分标准。 publicvoidCat(intage,Stringname){ System.out.println("name:"+name+"\n"+"age:"+age); } publicvoidCat(Stringname,intage){ System.out.println("name:"+name+"\n"+"age:"+age); } 重写与重载的区别 重写重载参数不变变返回类型不变可变异常可减少删除,但不可抛出新的或更广的可变访问可以降低限制可变 总的来说,Overload除了参数必须要改,其他都是可以改的,相当于一个同名函数,为了做区分当然要在参数上有区别啦,不然他怎么知道该调用哪一个qwqq;而Override则可改范围很小,参数,返回类型皆不可变,是在原函数的框架内进行重写,受到的限制明显大于Overload. 
第239篇文章[]
软件构造(三)正则表达式 正则表达式语法 字符说明\将下一字符标记为特殊字符、文本、反向引用或八进制转义符。eg，n匹配字符n。\n匹配换行符。*零次或多次匹配前面的字符或子表达式(co*匹配c和coo)+一次或多次匹配前面的字符或子表达式(co+不匹配c)?零次或一次匹配前面的字符或子表达式\r匹配一个回车\s匹配任何空白字符,包括空格,制表,换页符\n匹配换行符\d数字字符匹配,等效于[0-9]\D非数字字符匹配,等效于[^0-9]\w匹配任意字类字符,等效于[A-Za-z0-9]\W匹配任意非字类字符,等效于[^A-Za-z0-9]^匹配输入字符串开始的位置。如果设置了RegExp对象的Multiline属性，^还会与"\n"或"\r"之后的位置匹配。$匹配输入字符串结尾的位置。如果设置了RegExp对象的Multiline属性，$还会与"\n"或"\r"之前的位置匹配。[xyz]匹配包含的任一字符集[a-z]匹配指定范围内的任何字符[匹配a到z的范围内的任何小写字母] 查找子串中是否包含了Cooing子串: Stringpattern=".*Cooing.*"; Stringcontent="qwqqqqCooingqwqqqqq"; booleanisMatch=Pattern.matches(pattern,content); System.out.println("字符串中是否包含了'Cooing'子串?"+isMatch); 在Java中，\\表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。Java中正则表达式中需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在Java的正则表达式中，两个\\代表其他语言中的一个\，这也就是为什么表示一位数字的正则表达式是\\d，而表示一个普通的反斜杠是\\。 
第240篇文章[5]
HITCSAPP程序人生大作业 
第241篇文章[]
软件构造(二)spec规约 spec规约是使用者（client）和实现者（implementor）之间的妥协与契约，即是一种在使用时必须要遵循的要求的说明，也是一种在在实现时需要遵循的原则.一般书写在每一个类和每一方法前面.由@param、@throws、@return组成. /** *Insertaintervalwithitsstart,end,andlabel *Labeledintervalsconflictif:theyhavethesamelabelwithdifferent *intervals,ortheyhavedifferentlabelswithoverlappingintervals. * *Forexample,ifthissetis{"A"=[0,10),"B"=[20,30)}, *insert("A"=[0,10))hasnoeffect *insert("A"=[10,20))throwsIntervalConflictException *insert("B"=[10,20))throwsIntervalConflictException *insert("C"=[20,30))throwsIntervalConflictException *insert("D"=[30,40))adds"D"=[30,40) * *@paramstartthestartoftheinterval(thelowendoftheinterval) *@paramendtheendoftheinterval(thehighendoftheinterval) *@paramlabelthelabeltoadd *@throwsIntervalConflictException-ifthelabelisalreadyexisted, *andthestartandendarenotthesamewiththenewones; *orthere'saexistedintervalwhoserangeconflictwiththenewone. */ 约定俗成的规矩是使用者需要在满足前置条件的情况下，才能得到正确的结果. 行为等价性:对于用户来讲,提供的同一个spec，若都被满足了，那么就算做等价.所以重点就是要站在用户端看待问题，只要同一个spec被满足，则说明实现了相同的功能，即同一个spec所有实现是等价的.不能单看代码结果不一样,就说两个实现不等价. spec的强弱判断和比较方法:前置条件越弱,后置条件越强,spec越强.(前者用户所需遵守规则少,后者用户得到的信息更详细)因为前置条件必须被满足，所以后置条件的比较是在前置假设成立的条件下进行的，在很多情况下，前置条件的限制使得后置条件从不同变为相同. 
第242篇文章[]
软件构造(五)异常 Checked异常、Unchecked异常：编译器可帮助检查你的程序是否已抛出或处理了可能的异常（checked异常）必须捕获并指定错误处理器handler，否则编译无法通过；类似于编程语言中的statictypechecking. ErrorsandRuntimeExceptions（unchecked异常）不需要在编译的时候用try…catch等机制处理. Checked异常的处理机制：声明、抛出、捕获、处理、清理现场、释放资源等：Declaringexceptions(throws)声明“本方法可能会发生XX异常”Throwinganexception(throw)抛出XX异常Catchinganexception(try,catch,finally)捕获并处理XX异常，不管程序是否碰到异常，finally都会被执行Unchecked异常也可以使用throws声明或try/catch进行捕获，但大多数时候是不需要的，也不应该这么做 掩耳盗铃，对发现的编程错误充耳不闻当要决定是采用checkedexception还是uncheckedexception的时候，问一个问题：“如果这种异常一旦抛出，client会做怎样的补救？”如果客户端可以通过其他的方法恢复异常，那么采用checkedexception；如果客户端对出现的这种异常无能为力，那么采用uncheckedexception；异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。错误可预料，但无法预防，但可以有手段从中恢复，此时使用checkedexception。如果做不到这一点，则使用uncheckedexception.自定义异常类如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛。子类型方法可以抛出更具体的异常，也可以不抛出任何异常。如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。 
第243篇文章[]
软件构造-学习笔记6：对于final关键字的理解 在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。 修饰类：当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。修饰方法：使用final修饰方法时，说明这个方法不允许被重写、修改，相当于“锁定”。修饰变量：final成员变量表示常量，只能被赋值一次，赋值后值不再改变。当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。就如同Snapshot里的双箭头含义一样：不可以指向其他地方。在本质上是一个意思，因为对于引用类型说，引用的值是一个地址，final要求该值，即地址的值不发生变化。final修饰一个成员变量（属性），必须要显式的初始化。 
第244篇文章[]
软件构造-学习笔记4：Javafor遍历是如何判断数据是不是list的最后一位 Javafor遍历是如何判断数据是不是list的最后一位 if(employees.size()-1==employees.indexOf(e)){ 如果该表达式成立，则说明数据为list的最后一位 
第245篇文章[]
软件构造-学习笔记10：Try-Catch中finally的用法 Try-Catch中finally的用法 Java中的Finally关键一般与try一起使用，在程序进入try块之后，无论程序是因为异常而中止或其它方式返回终止的，finally块的内容一定会被执行。 考题类型：判断try-catch块中多catch异常下的代码执行顺序：finally块中内容一定会执行。 
第246篇文章[]
软件构造-学习笔记8：一种自定义sort排序依据的方法 intervals.sort((x,y)->(int)(x.getStart()-y.getStart())); 
第247篇文章[]
软件构造-学习笔记5：一种处理整数时间点和字符型时间的方法 publiclongdaysBetween(StringstartTime,StringendTime)throwsParseException{ SimpleDateFormatDateFormat=newSimpleDateFormat("yyyy-MM-dd"); Datedate1=DateFormat.parse(startTime); Datedate2=DateFormat.parse(endTime); Calendarcal=Calendar.getInstance(); cal.setTime(date1); longtime1=cal.getTimeInMillis(); cal.setTime(date2); longtime2=cal.getTimeInMillis(); longbetween_days=(time2-time1)/(1000*3600*24); returnInteger.parseInt(String.valueOf(between_days)); } publicDatedateiswhat(longpoint)throwsParseException{ SimpleDateFormatDateFormat=newSimpleDateFormat("yyyy-MM-dd"); Datedate1=DateFormat.parse(startTime); CalendarrightNow=Calendar.getInstance(); rightNow.setTime(date1); rightNow.add(Calendar.DAY_OF_YEAR,(int)point); DateDT=rightNow.getTime(); returnDT; } Date和Calendar类的灵活使用注意DateFormat的使用，有助于这种转换。 
第248篇文章[]
软件构造-学习笔记7：重载（overloading）和重写（overriding）的区别 重载（overloading）和重写（overriding）的区别 文章目录 重载（overloading）和重写（overriding）的区别重载（overloading）重写（overriding） 重载（overloading） 重载(overloading)是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。 事实上，重载也可以针对同一函数针对不同传入类型进行设计，如在实验三中可以针对为IntervalSet和MultiIntervalSet进行重载，以展示出不同的行为。在一个类中，同名的方法有不同的参数列表，这是重载表现出的效果重载的参数列表一定要是不同的。这里的参数列表可以看做不同的对象。发生重载一定是在一个类中，重载是针对不同的对象有不同的操作。重载是实现多态的一种方式（编译阶段）重载对返回类型没有要求，但不能有两个同名同参数列表、返回类型不同的函数。 重写（overriding） 重写是子类对父类的允许访问的方法的实现过程进行重新编写,返回值和形参都不能改变。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如：父类的一个方法申明了一个检查异常IOException，但是在重写这个方法的时候不能抛出Exception异常，因为Exception是IOException的父类，只能抛出IOException的子类异常。在面向对象原则里，重写意味着可以重写任何现有方法。 重写是发生在两个类之间，即子类对父类中的方法进行重新定义。但子类不可以改变父类方法的方法名，参数列表，返回类型（除非子类的返回值是它父类的返回值的子类）。重写也是实现多态的一种方式（运行阶段）重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常在重写方法中，对访问修饰符的限制，子类一定要大于父类（public>protected>default>private) 
第249篇文章[]
软件构造-学习笔记9：可维护性的常见度量指标 可维护性的常见度量指标 指标： 圈复杂度代码行数可维护性指数继承的层次数类之间的耦合度单元测试的覆盖度 实际方法： 继承的层次数类之间的耦合度单元测试的覆盖度聚合度与耦合度 模块化编程：高内聚&低耦合 DirectMapping直接映射FewInterfaces尽可能少的接口SmallInterfaces尽可能小的接口ExplicitInterfaces显式接口InformationHiding信息隐藏 
第250篇文章[]
软件构造-学习笔记2：解决在已经push至Github后，.gitignore文件无法生效的问题 原因是：.gitignore只能忽略那些没有被纳入版本管理的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除，然后再提交：方法：打开GitBash，进入你想删除本地缓存仓库的目录，之后执行： gitrm-r--cached. gitadd. gitcommit-m'update.gitignore' 之后正常push，.gitignore文件即可正常生效。 
第251篇文章[1]
HITCSAPP2021大作业程序人生Hello‘sP2P 题 目 程序人生-Hello’sP2P 专 业 计算机学院 学 号 ******** 班 级 ********* 学 生 ******* 摘 要 本文主要参照《深入理解计算机系统》一书，结合CSAPP课程内容来介绍hello程序的一生，并对该过程中的知识点进行梳理，所有操作均在Ubuntu虚拟机完成，运用了多种调试工具，有助于加深对计算机系统的理解。 关键词：Ubuntu；CSAPP；深入理解计算机系统；程序生命周期 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.2.1硬件环境 -4- 1.2.2软件环境 -4- 1.2.3开发工具 -4- 1.3中间结果 -4- 1.4本章小结 -5- 第2章预处理 -6- 2.1预处理的概念与作用 -6- 2.2在Ubuntu下预处理的命令 -6- 2.3Hello的预处理结果解析 -7- 2.4本章小结 -9- 第3章编译 -10- 3.1编译的概念与作用 -10- 3.2在Ubuntu下编译的命令 -10- 3.3Hello的编译结果解析 -11- 3.3.1部分汇编伪指令 -11- 3.3.2数据 -11- 3.3.3赋值 -12- 3.3.4类型转换 -13- 3.3.5算数操作 -13- 3.3.6关系操作 -14- 3.3.7数组、指针、结构操作 -14- 3.3.8控制转移操作 -14- 3.3.9函数操作 -15- 3.4本章小结 -15- 第4章汇编 -16- 4.1汇编的概念与作用 -16- 4.2在Ubuntu下汇编的命令 -16- 4.3可重定位目标elf格式 -17- 4.4Hello.o的结果解析 -19- 4.5本章小结 -20- 第5章链接 -21- 5.1链接的概念与作用 -21- 5.2在Ubuntu下链接的命令 -21- 5.3可执行目标文件hello的格式 -22- 5.4hello的虚拟地址空间 -22- 5.5链接的重定位过程分析 -23- 5.6hello的执行流程 -24- 5.7Hello的动态链接分析 -25- 5.8本章小结 -25- 第6章hello进程管理 -26- 6.1进程的概念与作用 -26- 6.2简述壳Shell-bash的作用与处理流程 -26- 6.3Hello的fork进程创建过程 -26- 6.4Hello的execve过程 -27- 6.5Hello的进程执行 -27- 6.6hello的异常与信号处理 -28- 6.7本章小结 -31- 第7章hello的存储管理 -32- 7.1hello的存储器地址空间 -32- 7.2Intel逻辑地址到线性地址的变换-段式管理 -32- 7.3Hello的线性地址到物理地址的变换-页式管理 -33- 7.4TLB与四级页表支持下的VA到PA的变换 -34- 7.5三级Cache支持下的物理内存访问 -35- 7.6hello进程fork时的内存映射 -35- 7.7hello进程execve时的内存映射 -35- 7.8缺页故障与缺页中断处理 -36- 7.9动态存储分配管理 -36- 7.10本章小结 -38- 第8章hello的IO管理 -39- 8.1Linux的IO设备管理方法 -39- 8.2简述UnixIO接口及其函数 -39- 8.3printf的实现分析 -39- 8.4getchar的实现分析 -40- 8.5本章小结 -41- 结论 -41- 附件 -42- 参考文献 -43- 第1章概述 1.1Hello简介 P2P简介 P2P，英文是Fromprogramtoprocess。用户首先通过各种文本编辑器编写代码，得到hello.c文件，然后在Ubuntu下，调用C预处理器得到ASCII码的中间文件hello.i，然后调用C编译器得到ASCII汇编语言文件hello.s，然后运行汇编器得到可重定位目标文件hello.o，最后通过链接器得到可执行目标文件hello，用户可以在终端输入./hello来启动程序。 O2O简介 O2O，英文是FromZero-0toZero-0。用户输入命令后，shell根据命令调用fork函数生成子进程，子进程中execve函数运行hello，这要为hello各段创建新的空间。首次加载会产生缺页，调用缺页中断处理子程序，多次调用后hello就加载到内存中。在运行过程中会收到外部的信号（比如用户输入），因此还要相对的信号处理程序。hello执行完毕，hello结束，等待被父进程回收。 1.2环境与工具 1.2.1硬件环境 X64CPU；2.10GHz；16GRAM；512GSSDDisk 1.2.2软件环境 Windows1064位；VirtualBox6.0；Ubuntu20.04LTS64位 1.2.3开发工具 Gcc、vim、gdb、edb、readelf、HexEdit等 1.3中间结果 中间结果文件 文件作用 hello.i 预处理生成的文本文件hello.i hello.s 编译产生的文本文件hello.s hello.o 汇编后生成的可重定位目标文件hello.o helloo.elf hello.o的elf文件 helloo.objdump objdumphello.o生成的hello.o的反汇编代码文件 hello 链接生成的可执行文件hello hello.elf hello的elf文件 hello.objdump objdumphello生成的hello的反汇编代码文件 1.4本章小结 本章简要介绍了hello.c的P2P和O2O，然后介绍了hello从开始到结束的过程及中间生成的一些文件。可以大致知道其过程：hello.c经过预处理生成hello.i，然后经过编译生成hello.s，再汇编生成hello.o，再链接生成hello这个可执行文件。接着hello运行O2O的过程，最后被父进程回收，结束hello。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 预处理的概念： 预处理器（即cpp）根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将原始C程序引用的所有库展开，处理所有原始C程序的条件编译，并执行原始C程序所有的宏定义，得到另一个通常是以.i作为文件扩展名的、文件名与原始C程序相同的文本文件。 预处理的作用： 将源文件中用#include形式声明的文件复制到新的程序中。比如hello.c第6-8行中的#include<stdio.h>等命令告诉预处理器读取系统头文件stdio.hunistd.hstdlib.h的内容，并把它直接插入到程序文本中。用实际值替换用#define定义的字符串根据#if后面的条件决定需要编译的代码 2.2在Ubuntu下预处理的命令 预处理的命令：cpphello.c>hello.i(或gcc-Ehello.c-ohello.i) 图1使用cpp命令 图2使用gcc命令 （经过简单比对，两文件都有3065行，故认为两文件相同，为简单起见，后文只使用cpp命令得到的文件进行实验） 2.3Hello的预处理结果解析 使用文本编辑器打开hello.i，发现此时程序由之前的28行扩展为3065行，我们使用ctrl+f查找main函数所在位置。 图3main函数所在位置 可以看到main函数于3049行出现，hello.c文件原始代码于3046行出现。 经过预处理器处理后，hello.c文件转化为hello.i文件，打开文件后发现文件的内容大大增加，但该文件还是可以使用文本编辑器正常打开阅读的文本文件，进行粗略观察，发现hello.i对原文件中的宏进行了宏展开，将头文件中的内容包含进了该文件，比如一些标准库中的函数、结构体的定义、变量的定义等。 如果代码中有#define命令，预处理器还会对相应的符号进行替换。 我们在文本编辑器中使用ctrl+f查找头文件stdio.h， 图4查找stdio.h 去该路径找到该文件，可以看到该文件中还是有很多#开头的宏定义内容 图5<stdio.h>的内容 这是由于cpp对引入头文件是进行递归展开，所以最终.i程序中是没有#define语句的。我们还发现其中使用了大量的#ifdef#ifndef的语句，cpp会对条件值进行判断来决定是否执行包含其中的逻辑。其他宏定义是类似的。 2.4本章小结 Hello.c程序要想真正的运行起来，需要很多的前置准备。 本章主要介绍了预处理的概念及作用，并结合hello.c处理后的hello.i对处理过程进行分析。根据hello.i文件的内容对cpp预处理的机制进行了简单的探索。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的概念： 编译即编译器将文本文件hello.i翻译成另一个文本文件hello.s的过程。 编译的作用： 其作用在于以高级程序设计语言书写的源程序作为输入，而以汇编语言或机器语言表示的目标程序作为输出。 编译器的构建流程主要分为3个步骤： 词法分析器，用于将字符串转化成内部的表示结构。语法分析器，将词法分析得到的标记流（token）生成一棵语法树。目标代码的生成，将语法树转化成目标代码。 3.2在Ubuntu下编译的命令 编译的命令：gcc-Shello.i-ohello.s 图6使用gcc-S命令进行编译 3.3Hello的编译结果解析 3.3.1部分汇编伪指令 指令含义.file声明源文件.text以下是代码段.section.rodata以下是rodata节.globl声明一个全局变量.type用来指定是函数类型或是对象类型.size声明大小.long、.string声明一个long、string类型.align声明对指令或者数据的存放地址进行对齐的方式 3.3.2数据 hello.s中用到的C数据类型有：字符串、整数、数组。 Ⅰ字符串 在hello.c程序中使用到的字符串有： “Usage:Hello学号姓名！\n” “Hello%s%s\n” 编译器一般会将printf打印输出的格式串放在.rodata节，在hello.s中，这两个字符串存储格式如下：其中可以看到汉字被编码为UTF-8格式，一个汉字占三个字节，每个字节以\开始。 图7字符串在hello.s中的存储格式 Ⅱ整数 在hello.c中使用到的整形变量有sleepsecs、argc和i。 sleepsecs在C程序中被声明为全局变量，且已经被赋值，编译器处理时将会在.data节声明该变量，.data节存放已经初始化的全局和静态C变量。 在图8sleepsecs在hello.s中可以看到，编译器首先将sleepsecs在.text代码段中声明为全局变量，其次在.data段中，设置对齐方式为4、设置类型为对象、设置大小为4字节、设置为long类型其值为2（进行了隐式转换）（long类型在linux下与int相同为4字节，将int声明为long应该是编译器的偏好选择）。 图8sleepsecs在hello.s中 argc是从终端传入的参数个数，也是main函数的第一个参数，故由寄存器%edi进行保存。 i是局部变量，编译器将局部变量存储在寄存器或者栈空间中，在hello.s中编译器将i存储在栈上空间-4(%rbp)中，可以看出i占据了栈中的4字节。 Ⅲ数组 在hello.c程序中使用到的数组有：char*argv[]main 该数组存储函数执行时输入的命令行，argv作为存放char指针的数组，也同时作为第二个参数传入。 图9数组argv[]的使用 argv单个元素char*大小为8B，argv指针指向已经分配好的、一片存放着字符指针的连续空间，起始地址为argv，main函数中每次先获得数组的起始地址，然后通过加8*i来访问之后的字符指针，之后通过获得的字符指针寻找字符串在hello.s中，使用两次(%rax)寻址取值（两次rax分别为argv[1]和argv[2]的地址）取出其值。 3.3.3赋值 在hello.c程序中涉及的赋值操作有： intsleepsecs=2.5：因为sleepsecs是全局变量，所以直接在.data节中将sleepsecs声明为值2的long类型数据。i=0：整型数据的赋值使用mov指令完成，根据数据的大小不同使用不同后缀，分别为：一字节：b，一字：w，双字：l，四字：q。 i为4B双字的int类型，故使用movl进行赋值： 图10对局部变量i进行0赋值 3.3.4类型转换 在hello.c程序中涉及隐式类型转换的是： intsleepsecs=2.5，本条语句将浮点数类型的2.5转换为int类型。 当在double或float向int进行类型转换的时候，程序改变数值和位模式的原则是：值会向零舍入。例如1.999将被转换成1，-1.999将被转换成-1。进一步来讲，可能会产生值溢出的情况，一个浮点数到整数的转换，如果不能为该浮点数找到一个合适的整数近似值，就会产生一个整数不确定值。 浮点数默认类型为double，所以上述强制转化是double强制转化为int类型。遵从向零舍入的原则，将2.5舍入为2。 3.3.5算数操作 汇编语言中有如下几种算术操作： 指令行为描述incDD=D+1加1decDD=D-1减1negDD=-D取反addS,GD=D+SD加SsubS,DD=D-SD减SimulS,DD=D*SD乘SimulqSR[%rdx]:R[%rax]=S*R[%rax]有符号乘法mulqSR[%rdx]:R[%rax]=S*R[%rax]无符号乘法idivqSR[%rdx]=R[%rdx]:R[%rax]modSR[%rax]=R[%rdx]:R[%rax]divS有符号除法divqSR[%rdx]=R[%rdx]:R[%rax]modSR[%rax]=R[%rdx]:R[%rax]divS无符号触发leaqS,DD=&S加载有效地址 在hello.c程序中涉及算数操作的是：循环变量i的自增，如下： 图11循环变量i的自增 3.3.6关系操作 指令效果描述CMPS1,S2S2-S1比较S2-S1设置条件码TESTS1,S2S1&S2测试S1&S2设置条件码SETXX DD=XX按照XX将条件码设置DJXX 根据XX与条件码进行跳转 C语言中的关系操作有==、!=、>、<、>=、<=，这些操作在汇编语言中主要依赖于cmp和test指令实现，cmp指令根据两个操作数之差来设置条件码。cmp指令与SUB指令的行为是一样，而test指令的行为与and指令一样，除了它们只设置条件码而不改变目的寄存器的值。 在hello.c中有两处用到了关系操作，在cmp之后设置条件码，为之后的je和jle提供判断依据。 3.3.7数组、指针、结构操作 hello.s中取argv首地址，通过首地址加8字节找到argv[1]的地址，然后通过argv[1]中的内容找到对应的字符串，保存在寄存器%rax中，对argv数组其他元素所指的字符串也同理。 3.3.8控制转移操作 Hello.c程序涉及到的控制转移有两处。 第一处是判断argc是否与3相等，在hello.s中如图所示，cmpl比较argc和3设置条件码之后，通过判断条件码ZF位是否为零决定是否跳转到.L2，如果为0，说明argc等于3，代码跳转到.L2继续执行，如果不为0，则顺序执行指令。另一处基本同理。 图12控制转移 3.3.9函数操作 函数是一种过程，过程提供了一种封装代码的方式，用一组指定的参数和可选的返回值实现某种功能。P中调用函数Q包含以下动作： 传递控制：进行过程Q的时候，程序计数器必须设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。 传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P中返回一个值。 分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。 函数的程序参数存储顺序如下表： 第一个第二个第三个第四个第五个第六个第七个及之后%rdi%rsi%rdx%rcx%r8%r9栈中 函数调用使用call指令即可。 3.4本章小结 本章主要阐述了编译器是如何处理C语言的各个数据类型以及各类操作的，基本都是先给出原理然后结合hello.cC程序到hello.s汇编代码之间的映射关系作出合理解释。 编译器将.i的拓展程序编译为.s的汇编代码。经过编译之后，我们的hello自C语言解构为更加低级的汇编语言。通过理解了这些编译器编译的机制，我们可以很容易的将汇编语言翻译成伪C语言。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编器（as）将.s汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码。这个过程称为汇编，亦即汇编的作用。 4.2在Ubuntu下汇编的命令 汇编的命令：ashello.s-ohello.o（gcc-chello.s-ohello.o） 图13汇编的命令 图14使用gcc进行汇编 4.3可重定位目标elf格式 使用readelf-ahello.o>helloo.elf指令获得hello.o文件的ELF格式。其组成如下： ELFHeader：以16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量等信息。 图15ELF头信息 节头部表 节头部表包含了文件中出现的各个节的含义，包括节的地址、偏移量、大小等信息。 图16节头部表 .rela.text节 一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。 图17.rela.text节 .rela节的包含的信息有（readelf显示与hello.o中的编码不同，以hello.o为准）： Offset需要进行重定向的代码在.text或.data节中的偏移位置，8个字节。Info包括symbol和type两部分，其中symbol占前4个字节，type占后4个字节，symbol代表重定位到的目标在.symtab中的偏移量，type代表重定位的类型。Addend有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。Type重定位到的目标的类型。Name重定向到的目标的名称。 .rela.eh_frame节 .eh_frame节的重定位信息。 .symtab节 符号表，用来存放程序中的定义和引用函数的全局变量的信息。重定位需要引用的符号都在其中声明。name是字符串表中的字节偏移，指向符号的以null结尾的字符串名字，value是符号的地址，对于可重定位的模块来说，value是距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时地址，size是目标的大小，type通常要么是数据，要么是函数，binding表示符号是本地的还是全局的。ABS代表不该被重定位的符号，UNDEF代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号，COMMON表示还未被分配位置的未初始化的数据目标。 图18.symtab节 4.4Hello.o的结果解析 使用objdump-d-rhello.o>helloo.objdump获得反汇编代码。 机器语言是计算机能直接理解的语言，完全由二进制数构成，为了阅读的方便显示成了16进制。每两个16进制数构成一个字节编码，是机器语言中能解释一个运算符或操作数的最小单位。 机器语言由三种数据构成。一是操作码，它具体说明了操作的性质和功能，每一条指令都有一个相应的操作码，计算机通过识别该操作码来完成不同的操作；二是操作数的地址，CPU通过地址取得所需的操作数；三是操作结果的存储地址，把对操作数的处理所产生的结果保存在该地址中，以便再次使用。 总体观察后发现，除去显示格式之外两者差别不大，主要差别如下： 分支转移：反汇编代码跳转指令的操作数使用的不是段名称如.L3，因为段名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后显然不存在，而是确定的地址。 函数调用：在.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0（目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。 全局变量访问：在.s文件中，访问rodata（printf中的字符串），使用段名称+%rip，在反汇编代码中0+%rip，因为rodata中数据地址也是在运行时确定，故访问也需要重定位。所以在汇编成为机器语言时，将操作数设置为全0并添加重定位条目。 4.5本章小结 本章主要介绍了从hello.s到hello.o的汇编过程，通过查看hello.o的elf格式和使用objdump得到反汇编代码与hello.s进行比较，间接了解到从汇编语言映射到机器语言汇编器需要实现的转换。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。在现代系统中，链接是由较做链接器的程序自动执行的。 链接的作用：链接器使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。 5.2在Ubuntu下链接的命令 链接的命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图19链接的过程 5.3可执行目标文件hello的格式 使用使用readelf-ahello>hello.elf命令生成hello程序的ELF格式文件。查看hello的elf格式，节头表记录了各个节的信息，Address是程序被载入到虚拟地址的起始地址，off是在程序中的偏移量，size是节的大小。 图20hello文件的节头 5.4hello的虚拟地址空间 用edb查看程序hello，发现程序在地址0x400000~0x401000中被载入，从0x400000开始到0x400fff结束，在0x400fff之后存放的是.dynamic~.shstrtab节。在DataDump中查看地址0x400000开始的内容，可以看到开头是ELF头部分。 图21ELF头部分 查看地址0x0x4002e0，发现是.interp节，保存着linux动态共享库的路径。 图22linux动态共享库 查看地址0x0x402000，发现是.rodata节，其中保存着hello.c中的两个字符串。 图23.rodata节 其他节也可以通过节头部表用DataDump找到，这里不再赘述。 5.5链接的重定位过程分析 使用objdump-d-rhello>hello.objdump获得hello的反汇编代码。 图24两份反汇编代码 通过比较hello.objdump和helloo.objdump了解链接器。 函数个数：在使用ld命令链接的时候，指定了动态链接器为64的/lib64/ld-linux-x86-64.so.2，crt1.o、crti.o、crtn.o中主要定义了程序入口_start、初始化函数_init，_start程序调用hello.c中的main函数，libc.so是动态链接共享库，其中定义了hello.c中用到的printf、sleep、getchar、exit函数和_start中调用的__libc_csu_init，__libc_csu_fini，__libc_start_main。链接器将上述函数加入。 函数调用：链接器解析重定条目时发现对外部函数调用的类型为R_X86_64_PLT32的重定位，此时动态链接库中的函数已经加入到了PLT中，.text与.plt节相对距离已经确定，链接器计算相对距离，将对动态链接库中函数的调用值改为PLT中相应函数与下条指令的相对地址，指向对应函数。对于此类重定位链接器为其构造.plt与.got.plt。 .rodata引用：链接器解析重定条目时发现两个类型为R_X86_64_PC32的对.rodata的重定位（printf中的两个字符串），.rodata与.text节之间的相对距离确定，因此链接器直接修改call之后的值为目标地址与下一条指令的地址之差，指向相应的字符串。这里以计算第一条字符串相对地址为例说明计算相对地址的算法： refptr=s+r.offset=Pointerto0x4010dd refaddr=ADDR(s)+r.offset=ADDR(main)+r.offset=0x4010c1+0x1c=0x4010dd *refptr=(unsigned)(ADDR(r.symbol)+r.addend-refaddr) =ADDR(str1)+r.addend-refaddr =0x402008-0x4010dd=(unsigned)0xf2b 5.6hello的执行流程 使用edb执行hello 子程序名： ld-2.27.so!_dl_start ld-2.27.so!_dl_init hello!_start libc-2.27.so!__libc_start_main libc-2.27.so!__cxa_atexit libc-2.27.so!__libc_csu_init libc-2.27.so!_setjmp hello!main hello!puts@plt hello!exit@plt hello!printf@plt hello!sleep@plt hello!getchar@plt ld-2.27.so!_dl_runtime_resolve_xsave ld-2.27.so!_dl_fixup ld-2.27.so!_dl_lookup_symbol_x libc-2.27.so!exit 5.7Hello的动态链接分析 在进行动态链接前，首先进行静态链接，生成部分链接的可执行目标文件hello。此时共享库中的代码和数据没有被合并到hello中。加载hello时，动态链接器对共享目标文件中的相应模块内的代码和数据进行重定位，加载共享库，生成完全链接的可执行目标文件。 动态链接采用了延迟加载的策略，即在调用函数时才进行符号的映射。使用偏移量表GOT+过程链接表PLT实现函数的动态链接。GOT中存放函数目标地址，为每个全局函数创建一个副本函数，并将对函数的调用转换成对副本函数调用。 从图中可以看到.got.plt的条目发生变化。在之后的函数调用时，首先跳转到PLT执行.plt中逻辑，第一次访问跳转时，GOT地址为下一条指令，将函数序号压栈，然后跳转到PLT[0]，在PLT[0]中将重定位表地址压栈，然后访问动态链接器，在动态链接器中使用函数序号和重定位表确定函数运行时地址，重写GOT，再将控制传递给目标函数。之后如果对同样函数调用，第一次访问跳转直接跳转到目标函数。 5.8本章小结 在本章中介绍了链接的方法，分析了可执行文件hello的elf格式，同时反汇编hello文件，将其与hello.o的反汇编文件进行对比，最后对hello进行动态链接分析。涉及了重定位和符号解析的知识，加强了对重定位和链接的理解。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的概念 进程就是一个执行中的程序的示例，系统中的每个程序都运行在某个进程的上下文中，上下文是由程序正确运行所需的状态（包括存放在内存中的程序的代码和数据、栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符等）组成的。 进程的作用 进程提供给应用程序关键的抽象：一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器；一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 Shell的作用：Shell是一个用C语言编写的程序，他是用户使用Linux的桥梁。Shell是用户与操作系统之间完成交互式操作的一个接口程序，为用户提供简化了的操作，进一步开发出BorneAgainShell，简称bash，是Linux系统中默认的shell程序。提供了一个界面，用户通过这个界面访问操作系统内核的服务。 处理流程： 1）从终端读入输入的命令。 2）将输入字符串切分获得所有的参数 3）如果是内置命令则立即执行 4）否则调用相应的程序为其分配子进程并运行 5）shell应该接受键盘输入信号，并对这些信号进行相应处理 6.3Hello的fork进程创建过程 执行中的进程调用fork()函数，就创建了一个子进程。 函数原型：pid_tfork(void); 返回值：若成功调用则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1。 对于hello进程，终端的输入被判定为非内置命令，shell试图在硬盘上查找该命令（即hello可执行程序），并将其调入内存，然后shell将其解释为系统功能调用并转交给内核执行。shell执行fork函数，创建一个子进程，这时候程序开始运行。hello子进程是父进程的副本，将获得父进程数据空间、堆、栈等资源的副本。同时linux将复制子进程的地址空间给子进程，因此，hello进程就有了独立的地址空间。 6.4Hello的execve过程 函数原型intexecve(constchar*filename,constchar*argv[],constchar*envp[]); 如果成功，则不返回；如果错误，则返回-1。 在execve加载hello之后，它调用启动代码。启动代码设置栈，并将控制传递给hello主函数（main函数）。 main函数原型：intmain(intargc,char*argv[],char*envp[])。 过程如下：hello子进程通过execve系统调用启动加载器；加载器删除子进程所有的虚拟地址段，并创建一组新的代码、数据、堆段。新的栈和堆段被初始化为0；通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容；最后加载器跳到_start地址，最终调用hello的main函数。 除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制，直到CPU引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 6.5Hello的进程执行 进程时间片：一个进程执行他的控制流的一部分的每一个时间段叫做时间片，多任务也叫时间分片。 进程上下文切换：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程，这种决策叫做调度。在内核调度一个新的进程运行时，它抢占当前进程，并使用一种上下文切换的机制来控制转移到新的进程。 过程：1.保存当前进程的上下文。2.恢复某个先前被强占的进程被保存的上下文。3.将控制传递给这个新恢复的进程。 hello在刚开始运行时内核为其保存一个上下文，进程在用户模式下运行，当没有异常或中断信号的产生，hello将一直正常地执行，而当出现异常或系统中断时，内核将启用调度器休眠当前进程，并在内核模式中完成上下文切换，将控制传递给其他进程。 6.6hello的异常与信号处理 hello的异常： 1）中断：来自处理器外部的I/O设备的信号的结果（例如：在键盘上敲击Ctrl-C或者Ctrl-Z） 2）陷阱：有益的，执行指令的结果（例如：系统调用） 产生的信号： SIGINT,SIGSTP,SIGCONT,SIGWINCH 下面我们对hello执行过程中的几种可能异常进行分析： 首先尝试运行过程中敲击回车，除了换行外没有其他情况： 图25敲击回车 之后在ctrl-z后测试psjobspstreefgkill命令： 图26使用ctrl+z挂起进程 使用ps命令查看，发现hello进程在后台正常存在 图27ps命令查看进程 使用jobs命令，可以看到已停止的hello进程 图28jobs命令查看进程 Pstree查看： 图29pstree命令 Fg命令恢复 图30fg命令恢复进程 Kill命令杀死进程： 图31kill命令杀死进程 测试ctrl+c： 图32程序ctrl+c被终止 测试任意字符：不影响运行。 图33进行任意字符输入 信号处理： 1）Ctrl-CCtrl-Z：键盘输入后，内核发送SIGINT（默认终止前台job即程序hello）或者SIGSTP（默认挂起前台hello作业）。 2）fg信号：内核发送SIGCONT信号，让刚刚挂起的程序hello重新在前台运行。 3）kill-923166：内核发送SIGKILL信号给我们指定的pid，这样就杀死了hello程序。 6.7本章小结 本章主要介绍了进程的概念与作用，同时介绍了Shell的一般处理流程和作用，并且着重分析了调用fork创建新进程，调用execve函数执行hello，hello的进程执行，以及hello的异常与信号处理。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：在有地址变换功能的计算机中，访内指令给出的地址(操作数)叫逻辑地址，也叫相对地址。分为两个部分，一个部分为段基址，另一个部分为段偏移量。 线性地址：逻辑地址经过段机制后转化为线性地址，为描述符:偏移量的组合形式。分页机制中线性地址作为输入。 虚拟地址：CPU启动保护模式后，程序运行在虚拟地址空间中。与物理地址相似，虚拟内存被组织为一个存放在磁盘上的N个连续的字节大小的单元组成的数组，其每个字节对应的地址成为虚拟地址。虚拟地址包括VPO（虚拟页面偏移量）、VPN（虚拟页号）、TLBI（TLB索引）、TLBT（TLB标记）。 物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 实模式下：逻辑地址CS：EA=->物理地址CS*16+EA 保护模式下：以段描述符作为下标，到GDT/LDT表查表获得段地址，段地址+偏移地址=线性地址。 段选择符各字段含义，如图 TI=0，选择全局描述符表（GDT），TI=1，选择局部描述符表（LDT） RPL=00，为第0级，位于最高级的内核态，RPL=11，为第3级，位于最低级的用户态，第0级高于第3级 高13-8K个索引用来确定当前使用的段描述符在描述符表中的位置，如下图： 被选中的段描述符先被送至描述符cache，每次从描述符cache中取32位段基址，与32位段内偏移量（有效地址）相加得到线性地址，如下图： 7.3Hello的线性地址到物理地址的变换-页式管理 1.基本原理 将程序的逻辑地址空间划分为固定大小的页，而物理内存划分为同样大小的页框。程序加载时，可将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是VPN（虚拟页号），后一部分是VPO（虚拟页偏移量）。 页式管理方式的优点：没有外碎片；一个程序不必连续存放；便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。 页式管理方式的缺点：要求程序全部装入内存，没有足够的内存，程序就不能执行。 2.页式管理的数据结构 在页式系统中进程建立时，操作系统为进程中所有的页分配页框。当进程撤销时收回所有分配给它的页框。在程序的运行期间，如果允许进程动态地申请空间，操作系统还要为进程申请的空间分配物理页框。操作系统为了完成这些功能，必须记录系统内存中实际的页框使用情况。操作系统还要在进程切换时，正确地切换两个不同的进程地址空间到物理内存空间的映射。这就要求操作系统要记录每个进程页表的相关信息。为了完成上述的功能， 个页式系统中，一般要采用如下的数据结构。 页表：页表将虚拟内存映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。页表是一个页表条目（PTE）的数组。虚拟地址空间的每个页在页表中一个固定偏移量处都有一个PTE。假设每个PTE是由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。 3.页式管理地址变换 MMU利用VPN来选择适当的PTE，将列表条目中PPN和虚拟地址中的VPO串联起来，就得到相应的物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 为了消除每次CPU产生一个虚拟地址MMU就查阅一个PTE带来的时间开销，许多系统都在MMU中包括了一个关于PTE的小的缓存，称为翻译后被缓冲器（TLB），TLB的速度快于L1cache。 TLB通过虚拟地址VPN部分进行索引，分为索引（TLBI）与标记（TLBT）两个部分。这样，MMU在读取PTE时会直接通过TLB，如果不命中再从内存中将PTE复制到TLB。 同时，为了减少页表太大而造成的空间损失，可以使用层次结构的页表页压缩页表大小。 Corei7使用的是四级页表。如图7.9所示，在四级页表层次结构的地址翻译中，虚拟地址被划分为4个VPN和1个VPO。每个第i个VPN都是一个到第i级页表的索引，第j级页表中的每个PTE都指向第j+1级某个页表的基址，第四级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN之前，MMU必须访问四个PTE。 7.5三级Cache支持下的物理内存访问 得到了物理地址PA，首先使用物理地址的CI进行组索引（每组8路），对8路的块分别匹配CT进行标志位匹配，如果匹配成功且块的valid标志位为1，则命中hit，然后根据数据偏移量CO取出数据并返回。 若没找到想匹配的或者标志位为0，则miss，那么cache向下一级cache，这里是二级cache甚至三级cache中寻找查询数据，然后逐级写入cache。 在更新cache的时候，需要判断是否有空闲块：若有空闲块（即有效位为0），则写入；若不存在，则进行驱逐一个块（LRU策略）。 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给他一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障是一种常见的故障，当指令引用一个虚拟地址，在MMU中查找页表时发现与该地址相对应的物理地址不在内存中，因此必须从磁盘中取出的时候就会发生故障。 缺页中断处理：缺页处理程序是系统内核中的代码，选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送VA到MMU，这次MMU就能正常翻译VA了。 7.9动态存储分配管理 1.动态内存分配器的基本原理 在程序运行时程序员使用动态内存分配器(比如malloc)获得虚拟内存。动态内存分配器维护者一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护，每个块要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器的类型有两种：显式分配器和隐式分配器。 显式分配器：要求应用显式地释放任何已分配的块。例如，C语言中的malloc函数申请了一块空间之后需要free函数释放这个块 隐式分配器：应用检测到已分配块不再被程序所使用，就释放这个块。比如Java，ML和Lisp等高级语言中的垃圾收集。 2.带边界标签的隐式空闲链表分配器原理 带边界标签的隐式空闲链表的堆块结构如图7.13。一个块是由一个字的头部、有效载荷、可能的一些额外的填充，以及在块的结尾处的一个字的脚部组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是0。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。 寻找一个空闲块的方式有三种： （1）首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块：可以取总块数（包括已分配和空闲块）的线性时间，但是会在靠近链表起始处留下小空闲块的“碎片”。 （2）下一次适配：和首次适配相似，只是从链表中上一次查询结束的地方开始，优点是比首次适应更快：避免重复扫描那些无用块。但是一些研究表明，下一次适配的内存利用率要比首次适配低得多。 （3）最佳适配：查询链表，选择一个最好的空闲块适配，剩余最少空闲空间，优点是可以保证碎片最小 提高内存利用率，但是通常运行速度会慢于首次适配。 3.关于堆块的合并有四种情况。在情况1中，两个邻接的块都是已分配的，因此不可能进行合并。所以当前块的状态只是简单地从已分配变成空闲。在情况2中，当前块与后面的块合并。用当前块和后面块的大小的和来更新当前块的头部和后面块的脚部。在情况3中，前面的块和当前块合并。用两个块大小的和来更新前面块的头部和当前块的脚部。在情况4中，要合并所有的三个块形成一个单独的空闲块，用三个块大小的和来更新前面块的头部和后面块的脚部。在每种情况中，合并都是在常数时间内完成的。 3.显式空间链表的基本原理 显式空间链表是一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。双向链表使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以使线性的，也可以是一个常数，这取决于我们选择的空闲链表中块的排序策略。 链表的维护方式有两种：一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在线性时间内完成。另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 一般而言，显示链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部，这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。 malloc采用分离适配的方法。 适配块策略：首次适配、下一次适配、最佳适配。首次适配利用率较高，下一次适配时间较快，最佳适配可以很好的减少碎片的产生。在分离适配的时候采取的策略一般是首次试配（因为对分离空闲链表的简单首次适配的内存利用效率近似于整个堆的最佳适配的利用效率）。 7.10本章小结 本章引入了物理地址和虚拟地址的概念，以及相互转化的过程，需要了解段式空间和页面管理的相关知识。同时讨论了页命中和页不命中的相关操作，对fork和execve有了进一步的认知，了解了动态内存分配的方式和放置策略。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m字节的序列。所有的IO设备(如网路、磁盘、终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O,这使得所有的输入和输出都被当做相应文件的读和写来执行： 8.2简述UnixIO接口及其函数 接口： 1.打开文件：一个应用程序通过要求内核打开相应的文件来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个文件的所有信息，应用程序只需要记住这个描述符。 2.linuxshell创建进程的时候会打开三个文件 标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，可以代替显式的描述符值。 3.改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地改变当前文件位置k。 4.读写文件：一个读操作就是文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为EOF的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF”符号，类似地，写操作就是不从内存复制n>0个字节到一个文件，从当前文件位置k开始，更新k。 5.关闭文件：当应用完成对文件的访问后，通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 8.3printf的实现分析 staticintprintf(constchar*fmt, ) { va_listargs; inti; va_start(args,fmt); write(1,printbuf,i=vsprintf(printbuf,fmt,args)); va_end(args); returni; } vsprintf作用是格式化，接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 syscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。于是我们的打印字符串就显示在了屏幕上。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } 1.运行getchar()时，程序将控制权交给os，键入时，内容进入缓存并在屏幕显示，enter后，通知os输入完成，这时再将控制权交还给程序。 2.异步异常-键盘中断处理：键盘中断处理子程序，接受按键扫描码转成ASCII码，保存到系统的键盘缓冲区。 3.getchar调用read系统函数，通过系统调用读取按键ASCII码，直到接受到回车键才返回。 8.5本章小结 本章介绍了Linux中I/O设备的管理方法，UnixI/O接口和函数，并且分析了printf和getchar函数是如何通过UnixI/O函数实现其功能的，最后对printf和getchar两个函数进行分析。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 Hello.c程序首先经过程序员的编写，以文件形式存储在磁盘上，之后经过预处理得到hello.i文件，hello.i文件经过编译器后得到汇编代码hello.s汇编文件，hello.s经过汇编，得到二进制可重定位目标文件hello.o，hello.o经过链接，生成了可执行文件hello。 bash进程是一个shell，它调用fork函数，生成子进程，并由execve函数加载运行当前进程的上下文中加载并运行新程序hello，hello运行过程中会调用各种函数，例如printf函数，与linuxI/O密切相关。hello最终被shell父进程回收，内核回收为其创建的所有信息。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 计算机系统是一个复杂却精密的系统，这一部分拥有着细碎繁多但却都不可忽视的知识点。《深入理解计算机系统》一书可以带着我们逐步理解计算机系统，但是这只是一种启蒙，为了更好的学习计算机系统，我们还需要更多的实践，我相信在未来课程的学习中，我会更好的利用、加深计算机系统知识。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 中间结果文件文件作用hello.i预处理生成的文本文件hello.ihello.s编译产生的文本文件hello.shello.o汇编后生成的可重定位目标文件hello.ohelloo.elfhello.o的elf文件helloo.objdumpobjdumphello.o生成的hello.o的反汇编代码文件hello链接生成的可执行文件hellohello.elfhello的elf文件hello.objdumpobjdumphello生成的hello的反汇编代码文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 兰德尔E.布莱恩特.深入理解计算机系统.龚奕利译. [2] 库函数getchar()详解https://blog.csdn.net/hulifangjiayou/article/details/40480467 [3] Linux进程虚拟地址空间https://www.cnblogs.com/xelatex/p/3491305.html [4] printf函数实现的深入剖析. https://www.cnblogs.com/pianist/p/3315801.html [5] getchar函数的分析https://www.runoob.com/cprogramming/c-function-getchar.html （参考文献0分，缺失-1分） 
第252篇文章[]
软件构造-学习笔记3：解决SelectedClassfilename‘HelloWorld.Java‘mappedtonotjavafiletype“”的问题 原因：不小心创建了同名的文本文件，idea将其认定为模板存储在了FileTypes中，这时只需要打开：settings-Editor-FileTypes，在左侧边栏找到你报错的相关文件类型，将右下方的固定模板删去即可。 
第253篇文章[]
软件构造-学习笔记1：解决使用IDEA通过HTTPS链接无法提交代码至github的问题 解决使用IDEA通过HTTPS链接无法提交代码至github的问题 一、初次尝试解决： 首先是遇到了如图所示的报错：起初猜测是网络环境问题，之后尝试SCIENCE上网之后遇到新的报错：OpenSSLSSL_read:Connectionwasreset,errno10054查阅前人经验得知：首先，造成这个错误很有可能是网络不稳定，连接超时导致的。当时给出的解决方式是在GitBash中使用如下命令： gitconfig--globalhttp.sslVerify"false" 据查看文档得知，该命令作用为解除git对SSL证书错误的的限制，这个错误并不重要是系统证书的问题，系统判断到这个行为会造成不良影响，所以进行了阻止，只要设置跳过SSL证书验证就可以了。 初次使用确实有效，但似乎每次重启电脑后在push之前都需要输入该命令，十分麻烦。 二、使用SSH 参见文章GitHub如何配置SSHKey感谢博主@前端向朔的分享，配置成功后push过程顺利。 
第254篇文章[]
软件构造实验总结 Lab1 现在做完三个实验再回头看Lab1，发现真是基本没干什么，只是简单地熟悉了一下Java编程。 P1：MagicSquares 我遇到的问题主要是要实现从文本中读入数据并进行合法性判断的功能。通过上网查阅资料，最终学会了读操作，需要用到FileReader和BufferedReader。这是第一次的上网自学，当时还觉得挺了不起的，后来发现在编程过程中上网自学一些Java中的有关知识简直就是家常便饭。 后续的数据操作此处不再描述，我当时的代码风格还是C的风格，比如使用大量一维数组、二维数组进行遍历查找，但在后面的实验中有逐渐改进，慢慢地习惯了使用List、使用迭代器等等。 P2：TurtleGraphics 这个任务是我第一次接触到的填空式的程序设计，形式很新颖，趣味性较强。 任务要求主要就是参照给出的spec完成几个方法的实现，使得已有测试用例能通过（这也是在此门课程中首次接触到Junit测试）。每个待实现的方法其实都是一些简单的算法。值得一提的是一个求解凸包的问题，我的大致思路是先找到所有点当中的最左下角的点，然后遍历其他的点，找到能使得turtle旋转角度最小的点，移动到该点上，再用相同方法继续查找下一个点，以此类推，直到回到一开始选定的最左下角的点，说明已经找到了所有点当中在最外圈的点，也就得到了凸包。 当我把一个到处是空白的框架逐渐丰满起来，测试用例也一个个通过的时候，还是很欣慰很有成就感的。 P3：SocialNetwork 这个任务要求设计实现一个FriendshipGraph类来表示现实生活中的社交关系图，还要设计一个Person类来表示人，最后还要自己编写测试用例来对FriendshipGraph中的方法进行测试。当时觉得做了好多的工作，现在回头看只想一笑而过。 在这个任务的完成过程中，我对ADT以及TDD有了一个最最基本的了解（虽然这时候还不知道这些名词），初次感受了一个比较完整的简易的程序设计流程。至于完整的设计流程，在Lab2和Lab3中逐渐揭开了神秘的面纱。 Lab2 从Lab2开始，总算是接触到这门课程的核心了 ADT和OOP，实验难度也有了明显提升。 P1：PoeticWalks 其实P1可以被分成两个部分，第一个部分是设计一套ADT，第二个部分是利用这个设计好的ADT来完成一个应用，也就是poeticwalks。 这个任务和Lab1的P2一样，也是填空，不过这次填的东西就多了。查看已经给出的Graph类，里面声明了一些方法，通过对每个方法的spec进行阅读，确定首先要做的就是划分等价类、写测试策略并设计测试用例。这其实就是TDD的一个体现，以前的编程中我都是直接完成实现，在这里按照要求应该先完成测试用例，这样能使方法在实现之后能立即得到测试，确保其正确性及健壮性，而且在设计测试用例的过程中，我们也能提前考虑各种特殊情况，在完成实现的时候加以注意。 完成了测试用例，接下来就该实现Graph了。任务中要求了两种实现方式ConcreteEdgesGraph和ConcreteVerticesGraph，这就是对OOP中继承关系的体现了。两个类都是对抽象接口Graph的实现，只是两者的内部逻辑不一样，但对外表现出来的都是一样的，都能提供Graph中的方法。两者的测试用例也是一样的，都继承自Graph的测试用例，因为实现了相同的方法。 在实现过程中，还涉及到了mutability/immutability说明、AF、RI、safetyfromrepexposure以及每个方法的spec，这些内容部分已经给出，但绝大部分仍需要自行添加完善。这些说明能使代码具有更加清晰的逻辑，既能帮助别人读懂自己的代码，又能方便日后查看代码时快速明白当初的想法，还能提醒自己时刻注意所写程序的正确性、安全性，保证不会在以后被客户端恶意操作，同时也可以清楚展示给客户端各个方法能实现什么功能，以及该怎么输入。 接下来就进入了P1的第二个部分，应用ADT实现一个poeticwalks的功能。还是一样的，先阅读spec了解清楚各个方法要实现的功能，设计相关的测试用例，然后再实现各方法，完善mutability/immutability说明、AF、RI、safetyfromrepexposure以及每个方法的spec。在实现各个方法的时候，由于已经设计好了ADT，所以能直接调用其中的方法，省去了很多工作。 P2：ReimplementSocialNetwork 这个任务其实和P1的第二部分是一样的，就是用已设计的ADT来完成一个应用的实现，而这个实现正是在Lab1中完成过的社交关系图。有了Graph这个强有力的ADT，很快就能实现FriendshipGraph这个类。同样，mutability说明、AF、RI、safetyfromrepexposure以及每个方法的spec也是不可省略的。虽然这里只需要把Lab1的测试用例直接拿来用就行，但为了按照更标准的模板来，我还是划分等价类、写测试策略并设计测试用例，使得测试更加充分。 到此，我在Lab2中初次体验了面向ADT的编程。不同于以往的直接面向应用场景的编程，面向ADT的编程是一种具有更长远眼光的做法，能在以后更加方便的实现更多具有相似性的应用；面向应用场景的编程虽然在短期看来很方便，但是可扩展性差，在遇到相似情景的时候，只能做大量重复工作，将相似的功能进行反复开发，效率较低。 Lab3 到了Lab3，就是整个三次实验的最高潮了，除了一份实验手册上的思路介绍，所有的东西都要自己设计与实现，是真正的从零开始。 在Lab3里，要求实现三个应用 排班管理系统、操作系统进程调度管理系统和课表管理系统。对这三个应用进行分析，能发现它们均涉及到具有不同特征的“时间段集合”这种对象，为了提高软件的可复用性和可维护性，可以设计构造一套ADT。 一开始我还比较迷茫，就参照着Lab2中设计Graph的那一套流程来进行。首先是设计IntervalSet，在实验手册的提示下，我确定了IntervalSet这个抽象接口中的方法，并完成了每个方法的spec。然后划分等价类、写测试策略并设计测试用例。接下来对IntervalSet这个接口进行实现，不同于Lab2的是，这里只用完成一个实现，即CommonIntervalSet。mutability说明、AF、RI和safetyfromrepexposure也是需要完成的。这样做下来，我也渐渐明白了设计流程。 在IntervalSet的spec里面，提到里面的时间段的“标签”是不能重复的，这在排班管理系统里适用，但在操作系统进程调度管理系统和课表管理系统里就不适用了。于是，我们还要设计实现另一种“时间段集合”MultiIntervalSet，它允许不同时间段的标签“重复”。在实验里，我选择将其直接实现为具体的类，而没有设计相关的接口。和IntervalSet一样，MultiIntervalSet各个方法的设计与spec撰写、测试策略、测试用例、方法的具体实现、mutability说明、AF、RI和safetyfromrepexposure都得按顺序逐一实现。 接下来就要对局部共性进行设计与实现了，这里将用到设计模式的相关知识，我最终选择的是装饰器模式。对于三个维度的特性 是否允许空白、是否允许重叠及是否需要周期性重复，将它们分别看做一层层装饰，逐一地加到原本的对象上。由于排班管理系统会基于IntervalSet来实现，而它要求不允许空白和不允许重叠的特性，我就为之设计了两个用来装饰的类NoBlankIntervalSet和NonOverlapIntervalSet，它们都继承同一个类IntervalSetDecorator，而这个类是对接口IntervalSet的一个实现。然后再将NoBlankIntervalSet和NonOverlapIntervalSet逐层装饰到IntervalSet上，就得到了用于排班管理系统的DutyIntervalSet。 需要注意的是，NoBlankIntervalSet中添加了原IntervalSet中没有的方法checkNoBlank，为了能调用这个方法，在装饰的时候需要把它放在最外面的一层，并将对象声明为NoBlankIntervalSet而非IntervalSet。这样看来似乎有些打破装饰器模式，但我在查阅资料时发现这被称为半透明的装饰器模式，介于装饰器模式和适配器模式之间，允许对接口进行改变以增强功能。 类似的思路，继续为基于MultiIntervalSet的操作系统进程调度管理系统和课表管理系统设计MultiIntervalSetDecorator类，注意它并不是实现MultiIntervalSet，因为MultiIntervalSet已经是具体的类，而非抽象接口。这样似乎又违背了装饰器模式，但是其思路是完全一致的。再设计并实现NonOverlapMultiIntervalSet、OverlapMultiIntervalSet和PeriodicMultiIntervalSet，并通过包装得到用于操作系统进程调度管理系统的ProcessIntervalSet和用于课表管理系统的CourseIntervalSet。同NoBlankIntervalSet一样，PeriodicMultiIntervalSet也属于半透明的装饰器模式。 设计完三个面向应用的ADT，再追加三个immutable的类Employee、Process和Course，以及自主设计的API，我们的基础框架就整个完成了。运用这一套自主设计的ADT，我们已经能解决不少现实中的问题了。 接下来的工作就是用已经开发好的ADT来完成一开始提到的三个应用 DutyRosterApp、ProcessScheduleApp和CourseScheduleApp。在已有的ADT的帮助下，每个应用中要求的功能都比较容易想到解决方案。几个小的问题，例如对日期的计算、随机执行时间的“随机”的实现等，在自学LocalDate和Random后都能很快解决。比较大的问题就是对于各种情况的分类讨论不够全面，总是会出现一些漏洞，导致手动测试的时候bug的花样繁多。我也在这段修改代码的长时间斗争中感受到了数学基础和算法设计的重要性，以后还得多多加强这方面的训练。 实现完三个应用之后，还需要给排班表新增一个从文件读入初始化数据的功能，这不仅需要会读文件的操作，还要学会正则表达式的写法。于是我又继续上网找代码示例自学（不得不说自学能力真的太重要了！），参照着代码示例写出员工信息、排班信息和排班时间的正则表达式后，运用Pattern和Matcher，以正则表达式为模板，在文件输入里面进行匹配，获取需要的信息。一旦获取到信息，后续的初始化就很容易了。 好不容易完成所有的功能，又要面临新的变换 排班管理系统要允许一个员工多时间的排班，课程管理系统不允许任何课程的重叠。但是还好我们是面向ADT的编程，在面对这些变化时是比较容易的，不用大量重复的工作，只需少量的修改。 排班管理系统的变化，只需要新增一个NoBlankMultiIntervalSet类来继承MultiIntervalSetDecorator，再修改DutyIntervalSet，将其变成用NoBlankMultiIntervalSet和NonOverlapMultiIntervalSet装饰的MultiIntervalSet，最后修改DutyRosterApp中利用IntervalSet特性实现的少量代码即可。 课表管理系统的变化更加简单，甚至不用新增类，只需修改CourseIntervalSet即可，将其装饰由OverlapMultiIntervalSet改变为NonOverlapMultiIntervalSet就完成了，几乎不用花时间。 到此，软件构造的三个实验就都圆满结束了。我从一个毫无设计思维、只会一来就实现各种方法的小白，成长为了一个初步具有设计意识与习惯的软件构造初学者。期间，我体会了ADT与OOP的魅力，感受了面向ADT编程带来的良好的可维护性和可复用性，当然也经历了各种困难与崩溃。但是最终回顾整个过程时，收获颇丰，成就感十足，内心还是十分喜悦与欣慰的。 关于Git 在三次实验中，提交成果均用到了git，下面记录一下用到的几个指令： gitinit 创建一个本地git仓库 gitclonexxxx克隆一个仓库中的代码 gitremoteaddoriginxxxx将本地仓库与远程仓库关联 gitremote-v查看远程仓库相关信息 gitadd(filename)将工作区内容交到暂存区 gitcommit-m"xxxx"将暂存区内容提交到本地仓库 gitstatus查看仓库状态 gitpush-uoriginmaster将本地仓库内容提交到远程仓库上 gitcheckout-bchange创建新的分支change gitcheckoutmaster切换回master分支 关于在线build 我使用的是GitHub上的在线build，在Actions目录下选择JavawithMaven: 选择后会自动生成maven.yml文件，将其中版本修改为指定版本（我用的jdk8)再提交即可： build的结果如下： 注意在build之前要先提交一个pom.xml文件，否则可能会失败，文件内容如下（其中artifactId需根据每个仓库的仓库名进行修改）： 
第255篇文章[]
软件构造主要知识点总结 软件构造基础 软件构造的多维度视图 三个维度（buildtime--runtime;moment--period;codelevel--componentlevel）和八个视图 软件构造各阶段活动 质量因素 外部质量因素影响用户，内部质量因素影响软件本身和它的开发者，外部质量取决于内部质量。 外部质量因素：正确性、健壮性、可扩展性、可复用性、兼容性、时空性能、可移植性、易用性、功能性、及时性、可验证性、完整性、可修复性、经济性等 内部质量因素：可读性、可理解性、简洁性、大小等 各质量因素往往不能同时满足，需要折中，但正确性永远不能与其他质量因素折中。 SCM与VCS 软件配置管理(SCM)追踪和控制软件的变化，软件中发生变化的基本单元，如文件，被称为软件配置项(SCI)。当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。 版本控制系统(VCS)有三种：本地版本控制系统（存储在本地）、集中式版本控制系统（存储在服务器）、分布式版本控制系统（同时存储在本地和服务器）。 Git 四个区域及基本指令： 分支的创建与合并： ADT与OOP 数据类型 基本数据类型：如int、long、boolean、double、char等 对象数据类型：如String、BigInteger等 基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。 类型检查 静态类型检查：在编译阶段进行类型检查，避免将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误等。 动态类型检查：在运行阶段才会进行类型检查，例如非法的参数值、非法的返回值、越界、空指针等。 静态类型检查是关于数据类型的检查，而动态类型检查是关于值的检查。 Mutability/Immutability 不变对象：一旦被创建，始终指向同一个值/引用，会产生大量拷贝（需要垃圾回收） 可变对象：拥有方法可以修改自己的值/引用，效率更高但不够安全（但可通过防御式拷贝解决） 关于final final类无法派生子类 final变量无法改变值/引用 final方无法被子类override Snapshotdiagram 基本类型: 对象类型: mutable对象，单线椭圆:immutable对象，双线椭圆:可变的引用，单线箭头；不可变的引用，双线箭头： specification 规约(spec)是程序与客户端达成的一致，给程序员和用户双方都确定了责任，调用时双方都要遵守。规约能隔离“变化”，无需通知客户端；提高代码效率；解耦，客户端不需了解具体实现等。 前置条件(precondition)：对客户端的约束，在使用方法时必须满足的条件,使用@paramannotation说明。后置条件(postcondition)：对开发者的约束，方法结束时必须满足的条件，使用@returnannotation说明返回值的要求，使用@throwsannotation说明出现异常时的处理。 更强的spec意味着更放松的前置条件和更严格的后置条件。可以用更强的spec去替换弱的spec。越强的spec，意味着implementor的自由度越小、责任越重，而client的责任越轻。 ADT的四种操作类型 Creators构造器：用于创建一个新的对象。 Producers生产器：用于使用一个已存在的对象产生一个新的对象。 Observers观察器：不对数据做任何改动，查看一个已存在的对象的各个值。 Mutators变值器：用于改变对象的属性。 测试creators,producers,andmutators：调用observers来观察这些operations的结果是否满足spec。 测试observers：调用creators,producers,andmutators等方法产生或改变对象，来看结果是否正确。 风险：如果被依赖的其他方法有错误，可能导致被测试方法的测试结果失效。 ADT各特性 表示独立性(RepresentationIndependence)：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。 不变量(Invariants)：与程序运行无关，在任何时候都应该满足的一些条件，例如immutability。 表示空间R 和抽象空间 A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。 表示不变性(RI)：某个具体的“表示”是否是“合法的”;也可看作所有表示值的一个子集，包含了所有合法的表示值;也可看作一个条件，描述了什么是“合法”的表示值。 抽象函数(AF)：表示空间R和抽象空间A之间映射关系的函数，即如何去解释R中的每一个值为A中的每一个值。 表示泄漏的安全声明(safetyfromrepexposure)：给出代码并未对外泄露其内部表示的理由。 接口、抽象类、具体类 接口与类用于定义和实现ADT，接口确定ADT的规约，类对ADT进行具体实现。接口之间可以继承和扩展；一个类可以实现多个接口，从而具备多个接口中的方法；一个接口可以有多种实现类；接口中不应提供构造函数（不可被实例化），但允许静态方法和default方法实现；类中必须实现所继承接口的所有方法，允许添加新的方法。抽象类介于接口和具体类之间，比接口具体，比具体类抽象。 继承与Override 子类可以继承父类的成员变量和方法。 严格继承：子类只能添加新方法，无法重写父类中的方法，如父类中的方法使用了final关键字限定。 重写(override)：子类的方法覆盖了父类的方法。重写的方法应该与父类方法有相同的方法名和参数，只有这样编译器才会判定为重写的方法。使用@Overrideannotation强制检查是否重写了父类中的方法。 多态与Overload 三种多态：特殊多态、参数化多态、子类型多态 特殊多态与重载 重载(overload)即多个方法具有同样的名字，但有不同的参数列表或返回值类型。参数列表必须不同，返回值类型、可见性、异常可相同也可不同。重载不仅发生在类内，也可发生在父类与子类之间。 注意：override是在运行阶段决定的，而overload是在编译阶段决定的。 参数化多态与泛型编程 使用泛型参数代替具体的类型。运行时泛型消失，用具体类型代替。通配符"?"只在使用泛型的时候出现，不能在定义中出现。 子类型多态 “B是A的子类型”意味着每一个B都是A，从规约的角度说是“每个B都满足A的规约”。使用instanceof可以检查一个对象在运行时的实际类型。 等价性 引用等价性：使用==进行判断，是否等价取决于指向的地址是否相同。基本数据类型必须使用这种办法判断等价性。 对象等价性：使用equals()进行判断。对于对象类型，使用这种办法来判断等价性，如果只用==则是在判断两个对象的ID(内存里的同一空间)是否相等。 equals()与hashCode() 不可变对象的equals()与hashCode()方法继承Object中的方法。在Object中，equals()的实现为==，而hashCode()的实现为返回内存地址。这往往不是程序员想要的，所以这两个方法需要重写。注意重写的时候不要写成重载，参数类型仍然应该是Object。 可变对象的等价性 观察等价性：指在不改变状态的情况下，两个mutable对象是否看起来一致。 行为等价性：指调用对象的任何方法都展示出一致的结果。 对可变类型来说，人们往往倾向于实现严格的观察等价性，但在有些时候，观察等价性可能导致bug，甚至可能破坏RI。例如：如果某个mutable的对象包含在Set集合类中，当其发生改变后，集合类的行为不确定。 可变类型等价设计实现行为等价性即可，无需重写equals()和hashCode()（与不可变类型要求相反），如果要判断两个可变对象是否看起来一致，最好定义一个新方法。 面向可复用性和可维护性的软件构造 复用 面向复用编程(programmingforreuse)：开发可以复用的软件 基于复用编程(programmingwithreuse)：复用已有的软件开发 源代码层面：方法和语句 模块层面：类和接口 库层面：API 架构层面：框架 LSP 子类型多态：客户端可用统一的方式处理不同类型的对象。 Liskov替换原则内容： 协变： 逆变： 泛型类型是不支持协变的，如ArrayList<String>是List<String>的子类型，但List<String>不是List<Object>的子类型。这是因为发生了类型擦除，运行时就不存在泛型了，所有的泛型都被替换为具体的类型。 但是在实际使用的过程中是存在能够处理不同的类型的泛型的需求的，如定义一个方法参数是List<E>类型的，但是要适应不同的类型的E，于是可使用通配符"?"来解决这个需求。 委派 委派/委托(delegation)：一个对象请求另一个对象的功能。 如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，也就是说一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。 委托发生在object层面，而继承发生在class层面。 CRP 利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。组合就是多个不同方面的delegation的结合。 SOLID设计原则 单一责任原则(SRP)：不应该有多于1个原因让你的ADT发生变化，否则就应拆分开。开放-封闭原则(OCP)：对扩展性的开放，对修改的封闭。Liskov替换原则(LSP)：子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异。接口分割原则(ISP)：不能强迫客户端依赖于它们不需要的接口 只提供必需的接口。客户端不应依赖于它们不需要的方法，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的端口。依赖转置原则(DIP)：具体模块应依赖于抽象模块，但抽象模块不应依赖于具体模块。换句话说：委托的时候要通过接口建立联系，而非具体子类。 设计模式 创建型模式（工厂方法模式）、结构型模式（适配器模式、装饰器模式）、行为类模式（策略模式、模板模式、迭代器模式、参观者模式） 共性样式1：只使用继承 例子： 共性样式2：继承+委派 例子： 面向健壮性与正确性的软件构造 健壮性与正确性 健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常。 正确性：程序按照spec加以执行的能力，是最重要的质量指标。 Error/Runtime异常、其他异常 Error：与代码无关，程序员通常无能为力，一旦发生，想办法让程序优雅的结束。也可以通过对外部环境的配置解决问题，如用户输入错误、设备错误、物理限制等。 Exception：一定是程序导致的问题，可以捕获、可以处理。 由于程序员对Error通常无法预料无法解决，因此重点关注可被解决的Exception Checked异常、Unchecked异常 黑盒测试 黑盒测试用于检查程序是否符合规约，不关心内部实现细节。理想情况是用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误。 等价类划分针对每个输入数据需要满足的约束条件划分等价类，从等价类中导出测试用例。 边界值分析方法大量的错误发生在输入域的“边界”而非中央，边界值分析方法是对等价类划分方法的补充。故可在等价类划分时，将边界作为等价类之一加入考虑。 等价类覆盖的方式 笛卡尔积：全覆盖，多个划分维度上的多个取值，要组合起来，每个组合都要有一个用例。测试完备，但用例数量多，测试代价高。 覆盖每个取值：每个维度的每个取值至少被1个测试用例覆盖一次即可，测试用例少，代价低，但测试覆盖度未必高。 白盒测试 白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例。通常由开发人员完成，一般较早执行。 独立/基本路径测试：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试用例使每一条基本路径被至少覆盖1次。 
第256篇文章[]
Arrays.asList后对结果进行remove操作导致UnsupportedOperationException的解决方法 问题描述： 最近在完成实验的过程中，我想要将一个字符串数组转换为一个List，从而方便后续对其中元素进行检查，删除掉一部分非法元素。简单上网搜索资料以后，我发现了可以使用Arrays.asList的操作，将一个字符串数组转化为List，示例代码如下： String[]s={"aa","bb","cc"}; List<String>strlist=Arrays.asList(s); 但是当我使用这个方法完成代码，进行JUnit测试的时候却不能通过，查看FailureTrace时在这段代码处发现了UnsupportedOperationException的报错： 原因分析: 我们首先查看一下Arrays.asList的源码（按住"Ctrl"键，将鼠标指到"asList"上，即可选择查看其源码）： /** *Returnsafixed-sizelistbackedbythespecifiedarray.(Changesto *thereturnedlist"writethrough"tothearray.)Thismethodacts *asbridgebetweenarray-basedandcollection-basedAPIs,in *combinationwith{@linkCollection#toArray}.Thereturnedlistis *serializableandimplements{@linkRandomAccess}. * *<p>Thismethodalsoprovidesaconvenientwaytocreateafixed-size *listinitializedtocontainseveralelements: *<pre> *List&lt;String&gt;stooges=Arrays.asList("Larry","Moe","Curly"); *</pre> * *@param<T>theclassoftheobjectsinthearray *@paramathearraybywhichthelistwillbebacked *@returnalistviewofthespecifiedarray */ @SafeVarargs @SuppressWarnings("varargs") publicstatic<T>List<T>asList(T a){ returnnewArrayList<>(a); } 可以看到该方法返回的是一个ArrayList，继续查看这个ArrayList的源码，发现它并不是java.util.ArrayList的ArrayList，而是java.util.Arrays内部自己所包含的ArrayList。而这个内部类，继承了AbstractList类，没有重写remove方法： /** *@serialinclude */ privatestaticclassArrayList<E>extendsAbstractList<E> implementsRandomAccess,java.io.Serializable { privatestaticfinallongserialVersionUID=-2764017481108945198L; privatefinalE[]a; ArrayList(E[]array){ a=Objects.requireNonNull(array); } @Override publicintsize(){ returna.length; } @Override publicObject[]toArray(){ returna.clone(); } @Override @SuppressWarnings("unchecked") public<T>T[]toArray(T[]a){ intsize=size(); if(a.length<size) returnArrays.copyOf(this.a,size, (Class<?extendsT[]>)a.getClass()); System.arraycopy(this.a,0,a,0,size); if(a.length>size) a[size]=null; returna; } @Override publicEget(intindex){ returna[index]; } @Override publicEset(intindex,Eelement){ EoldValue=a[index]; a[index]=element; returnoldValue; } @Override publicintindexOf(Objecto){ E[]a=this.a; if(o==null){ for(inti=0;i<a.length;i++) if(a[i]==null) returni; }else{ for(inti=0;i<a.length;i++) if(o.equals(a[i])) returni; } return-1; } @Override publicbooleancontains(Objecto){ returnindexOf(o)!=-1; } @Override publicSpliterator<E>spliterator(){ returnSpliterators.spliterator(a,Spliterator.ORDERED); } @Override publicvoidforEach(Consumer<?superE>action){ Objects.requireNonNull(action); for(Ee:a){ action.accept(e); } } @Override publicvoidreplaceAll(UnaryOperator<E>operator){ Objects.requireNonNull(operator); E[]a=this.a; for(inti=0;i<a.length;i++){ a[i]=operator.apply(a[i]); } } @Override publicvoidsort(Comparator<?superE>c){ Arrays.sort(a,c); } } 再继续查看一下AbstractList类的源码，我们会发现它的remove方法被直接定义为了“thrownewUnsupportedOperationException();”： /** *{@inheritDoc} * *<p>Thisimplementationalwaysthrowsan *{@codeUnsupportedOperationException}. * *@throwsUnsupportedOperationException{@inheritDoc} *@throwsIndexOutOfBoundsException{@inheritDoc} */ publicEremove(intindex){ thrownewUnsupportedOperationException(); } 到这里就完美破案了，进行Arrays.asList的操作得到的是一个java.util.Arrays内部自己所包含的ArrayList，而它的remove方法继承的是AbstractList类中的remove方法，当我们试图对Arrays.asList的结果进行remove操作时，就会抛出UnsupportedOperationException。 解决方案： 新建一个java.util.ArrayList的ArrayList： List<String>inputword=Arrays.asList(input.split("")); List<String>inputwords=newArrayList<>(); inputwords.addAll(inputword); 
第257篇文章[]
Java中的ArrayList和LinkedList 在Java中，我们经常使用到List这个类。这个类有多种实现，本文将着重分析其中最为常见的两个实现方式ArrayList和LinkedList。 其实从名字就不难猜到，ArrayList是基于数组的实现方式，LinkedList是基于链表的实现方式，但我们最好还是通过查看源代码进行更具体的分析。 首先查看两者的rep和creator部分： ArrayLIst: privatestaticfinallongserialVersionUID=8683452581122892189L; /** *Defaultinitialcapacity. */ privatestaticfinalintDEFAULT_CAPACITY=10; /** *Sharedemptyarrayinstanceusedforemptyinstances. */ privatestaticfinalObject[]EMPTY_ELEMENTDATA={}; /** *Sharedemptyarrayinstanceusedfordefaultsizedemptyinstances.We *distinguishthisfromEMPTY_ELEMENTDATAtoknowhowmuchtoinflatewhen *firstelementisadded. */ privatestaticfinalObject[]DEFAULTCAPACITY_EMPTY_ELEMENTDATA={}; /** *ThearraybufferintowhichtheelementsoftheArrayListarestored. *ThecapacityoftheArrayLististhelengthofthisarraybuffer.Any *emptyArrayListwithelementData==DEFAULTCAPACITY_EMPTY_ELEMENTDATA *willbeexpandedtoDEFAULT_CAPACITYwhenthefirstelementisadded. */ transientObject[]elementData;//non-privatetosimplifynestedclassaccess /** *ThesizeoftheArrayList(thenumberofelementsitcontains). * *@serial */ privateintsize; /** *Constructsanemptylistwiththespecifiedinitialcapacity. * *@paraminitialCapacitytheinitialcapacityofthelist *@throwsIllegalArgumentExceptionifthespecifiedinitialcapacity *isnegative */ publicArrayList(intinitialCapacity){ if(initialCapacity>0){ this.elementData=newObject[initialCapacity]; }elseif(initialCapacity==0){ this.elementData=EMPTY_ELEMENTDATA; }else{ thrownewIllegalArgumentException("IllegalCapacity:"+ initialCapacity); } } /** *Constructsanemptylistwithaninitialcapacityoften. */ publicArrayList(){ this.elementData=DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** *Constructsalistcontainingtheelementsofthespecified *collection,intheordertheyarereturnedbythecollection's *iterator. * *@paramcthecollectionwhoseelementsaretobeplacedintothislist *@throwsNullPointerExceptionifthespecifiedcollectionisnull */ publicArrayList(Collection<?extendsE>c){ Object[]a=c.toArray(); if((size=a.length)!=0){ if(c.getClass()==ArrayList.class){ elementData=a; }else{ elementData=Arrays.copyOf(a,size,Object[].class); } }else{ //replacewithemptyarray. elementData=EMPTY_ELEMENTDATA; } } 从上面的代码中，我们能看到ArrayList确实采用了基于数组的实现方式，rep中有用于记录List长度的size，还有三种形式的数组： 1）EMPTY_ELEMENTDATA是用于构造空数组的； 2）DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是用于构造空数组的，但它与EMPTY_ELEMENTDATA是有区别的，当之后出现第一个元素加入该数组时，它会扩展为大小为DEFAULT_CAPACITY（默认设置为10）的一个数组，即它在首次增加元素时对数组增加的长度有要求； 3）elementData是真正用来存储List中所有元素的数组，若它等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则会在出现第一个元素加入该数组时，扩展为大小为DEFAULT_CAPACITY（默认设置为10）的一个数组。 接下来再看看ArrayList的creator，发现同样有三种方式： 1）传入一个int型参数initialCapacity，这个参数指定List的初始长度。若参数大于0，则直接将elementData设置为大小为initialCapacity的数组；若参数等于0，则将elementData设置为EMPTY_ELEMENTDATA这个空数组；其余情况下，将会抛出异常； 2）不传入参数，则直接将elementData设置为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，可在之后加入第一个元素时再进行扩展； 3）传入一个Collection，将按照Collection的iterator给定的顺序将元素放入数组，再将数组赋值给elementData（要进行类的检查，若Collection不是ArrayList，会先进行转换），若Collection为空，将elementData设置为EMPTY_ELEMENTDATA这个空数组。 LinkedList: transientintsize=0; /** *Pointertofirstnode. *Invariant:(first==null&&last==null)|| *(first.prev==null&&first.item!=null) */ transientNode<E>first; /** *Pointertolastnode. *Invariant:(first==null&&last==null)|| *(last.next==null&&last.item!=null) */ transientNode<E>last; /** *Constructsanemptylist. */ publicLinkedList(){ } /** *Constructsalistcontainingtheelementsofthespecified *collection,intheordertheyarereturnedbythecollection's *iterator. * *@paramcthecollectionwhoseelementsaretobeplacedintothislist *@throwsNullPointerExceptionifthespecifiedcollectionisnull */ publicLinkedList(Collection<?extendsE>c){ this(); addAll(c); } privatestaticclassNode<E>{ Eitem; Node<E>next; Node<E>prev; Node(Node<E>prev,Eelement,Node<E>next){ this.item=element; this.next=next; this.prev=prev; } } 从上面的代码中，我们能看到LinkedList也确实采用了基于链表的实现方式（而且是双向链表） rep中有记录List长度的size，还有List中第一个和最后一个结点first和last。值得一提的是，Java中没有指针，但这里的实现原理类似于指针，不过是借助结点Node实现的，所以我们还是将LinkedList看做链表。 LinkedList的creator也比ArrayList简单，有两种：一种不传入参数的，创建空链表；一种传入一个Collection，将按照Collection的iterator给定的顺序将元素创建链表。 然后看一下最基本的增加单个元素的操作： ArrayList: /** *Appendsthespecifiedelementtotheendofthislist. * *@parameelementtobeappendedtothislist *@return<tt>true</tt>(asspecifiedby{@linkCollection#add}) */ publicbooleanadd(Ee){ ensureCapacityInternal(size+1);//IncrementsmodCount!! elementData[size++]=e; returntrue; } /** *Insertsthespecifiedelementatthespecifiedpositioninthis *list.Shiftstheelementcurrentlyatthatposition(ifany)and *anysubsequentelementstotheright(addsonetotheirindices). * *@paramindexindexatwhichthespecifiedelementistobeinserted *@paramelementelementtobeinserted *@throwsIndexOutOfBoundsException{@inheritDoc} */ publicvoidadd(intindex,Eelement){ rangeCheckForAdd(index); ensureCapacityInternal(size+1);//IncrementsmodCount!! System.arraycopy(elementData,index,elementData,index+1, size-index); elementData[index]=element; size++; } 发现有两种增加元素的方式： 1）不指定位置，会在请求增加一个长度之后，直接加在List最后； 2）指定位置，先检查位置参数index的合法性，若合法再请求增加一个长度，将插入位置后面的元素依次向后挪动一个位置，最后将要增加的元素插入指定位置。 LinkedList: /** *Appendsthespecifiedelementtotheendofthislist. * *<p>Thismethodisequivalentto{@link#addLast}. * *@parameelementtobeappendedtothislist *@return{@codetrue}(asspecifiedby{@linkCollection#add}) */ publicbooleanadd(Ee){ linkLast(e); returntrue; } /** *Linkseaslastelement. */ voidlinkLast(Ee){ finalNode<E>l=last; finalNode<E>newNode=newNode<>(l,e,null); last=newNode; if(l==null) first=newNode; else l.next=newNode; size++; modCount++; } 可以看见LinkedList直接将元素放入新的结点，并加在List的末尾。 再看一下删减单个元素的操作： ArrayList: /** *Removestheelementatthespecifiedpositioninthislist. *Shiftsanysubsequentelementstotheleft(subtractsonefromtheir *indices). * *@paramindextheindexoftheelementtoberemoved *@returntheelementthatwasremovedfromthelist *@throwsIndexOutOfBoundsException{@inheritDoc} */ publicEremove(intindex){ rangeCheck(index); modCount++; EoldValue=elementData(index); intnumMoved=size-index-1; if(numMoved>0) System.arraycopy(elementData,index+1,elementData,index, numMoved); elementData[--size]=null;//cleartoletGCdoitswork returnoldValue; } /** *Removesthefirstoccurrenceofthespecifiedelementfromthislist, *ifitispresent.Ifthelistdoesnotcontaintheelement,itis *unchanged.Moreformally,removestheelementwiththelowestindex *<tt>i</tt>suchthat *<tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt> *(ifsuchanelementexists).Returns<tt>true</tt>ifthislist *containedthespecifiedelement(orequivalently,ifthislist *changedasaresultofthecall). * *@paramoelementtoberemovedfromthislist,ifpresent *@return<tt>true</tt>ifthislistcontainedthespecifiedelement */ publicbooleanremove(Objecto){ if(o==null){ for(intindex=0;index<size;index++) if(elementData[index]==null){ fastRemove(index); returntrue; } }else{ for(intindex=0;index<size;index++) if(o.equals(elementData[index])){ fastRemove(index); returntrue; } } returnfalse; } /* *Privateremovemethodthatskipsboundscheckinganddoesnot *returnthevalueremoved. */ privatevoidfastRemove(intindex){ modCount++; intnumMoved=size-index-1; if(numMoved>0) System.arraycopy(elementData,index+1,elementData,index, numMoved); elementData[--size]=null;//cleartoletGCdoitswork } 与增加方法对应，同样是两种删减方法：一种按参数index查找（需要检查参数合法性），一种按元素查找，若能找到，则需要将删除位置后面的元素依次向前挪动一个位置，把原本的最后一个元素置为null，再将List的长度减1。 LinkedList: /** *Removesthefirstoccurrenceofthespecifiedelementfromthislist, *ifitispresent.Ifthislistdoesnotcontaintheelement,itis *unchanged.Moreformally,removestheelementwiththelowestindex *{@codei}suchthat *<tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt> *(ifsuchanelementexists).Returns{@codetrue}ifthislist *containedthespecifiedelement(orequivalently,ifthislist *changedasaresultofthecall). * *@paramoelementtoberemovedfromthislist,ifpresent *@return{@codetrue}ifthislistcontainedthespecifiedelement */ publicbooleanremove(Objecto){ if(o==null){ for(Node<E>x=first;x!=null;x=x.next){ if(x.item==null){ unlink(x); returntrue; } } }else{ for(Node<E>x=first;x!=null;x=x.next){ if(o.equals(x.item)){ unlink(x); returntrue; } } } returnfalse; } /** *Unlinksnon-nullnodex. */ Eunlink(Node<E>x){ //assertx!=null; finalEelement=x.item; finalNode<E>next=x.next; finalNode<E>prev=x.prev; if(prev==null){ first=next; }else{ prev.next=next; x.prev=null; } if(next==null){ last=prev; }else{ next.prev=prev; x.next=null; } x.item=null; size--; modCount++; returnelement; } 按元素查找，若能找到，则需要将删除位置前面和后面的结点（如果都有的话）链接起来，否则只需要修改单个结点的“指针”即可。 到此我们可以得出结论，ArrayList是基于数组的实现方式，LinkedList是基于链表的实现方式。结合源代码分析，我们还能发现在增删元素时，LinkedList性能会更好，因为不会涉及到移动元素，而ArrayList需要大量移动元素的操作。这启示我们在需要频繁修改List中元素的情境下，可以优先考虑LinkedList。 
第258篇文章[1]
程序人生-Hello’sP2P 摘 要 本文从一个hello程序入手，漫步计算机系统世界。文章将解析hello程序从hello.c经过预处理、编译、汇编和链接生成可执行文件的全过程，阐述计算机系统对hello进行的进程管理、存储管理和IO管理，展示hello程序在Linux系统里的完整生命周期。在对hello程序生命周期探索的过程中，将会使用到Ubuntu虚拟机、edb和gcc等实用的工具，融合CS:APP中各章的重点知识，进一步提升读者对Linux系统操作的熟练度，加深读者对计算机系统的认识。 关键词：hello程序；预处理；编译；汇编；链接；进程；存储；IO 目 录 第1章概述 -4- 1.1hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -5- 第2章预处理 -6- 2.1预处理的概念与作用 -6- 2.2在Ubuntu下预处理的命令 -6- 2.3hello的预处理结果解析 -6- 2.4本章小结 -8- 第3章编译 -9- 3.1编译的概念与作用 -9- 3.2在Ubuntu下编译的命令 -9- 3.3hello的编译结果解析 -9- 3.3.1数据类型 -9- 3.3.2赋值操作 -11- 3.3.3算术操作 -11- 3.3.4关系操作 -11- 3.3.5数组操作 -11- 3.3.6控制转移 -12- 3.3.7函数操作 -13- 3.4本章小结 -14- 第4章汇编 -15- 4.1汇编的概念与作用 -15- 4.2在Ubuntu下汇编的命令 -15- 4.3可重定位目标elf格式 -15- 4.4hello.o的结果解析 -18- 4.5本章小结 -20- 第5章链接 -21- 5.1链接的概念与作用 -21- 5.2在Ubuntu下链接的命令 -21- 5.3可执行目标文件hello的格式 -21- 5.4hello的虚拟地址空间 -24- 5.5链接的重定位过程分析 -25- 5.6hello的执行流程 -27- 5.7hello的动态链接分析 -28- 5.8本章小结 -29- 第6章hello的进程管理 -30- 6.1进程的概念与作用 -30- 6.2简述壳shell-bash的作用与处理流程 -30- 6.3hello的fork进程创建过程 -31- 6.4hello的execve过程 -31- 6.5hello的进程执行 -31- 6.6hello的异常与信号处理 -32- 6.7本章小结 -35- 第7章hello的存储管理 -36- 7.1hello的存储器地址空间 -36- 7.2Intel逻辑地址到线性地址的变换-段式管理 -36- 7.3Hello的线性地址到物理地址的变换-页式管理 -36- 7.4TLB与四级页表支持下的VA到PA的变换 -37- 7.5三级Cache支持下的物理内存访问 -38- 7.6hello进程fork时的内存映射 -39- 7.7hello进程execve时的内存映射 -39- 7.8缺页故障与缺页中断处理 -40- 7.9动态存储分配管理 -41- 7.10本章小结 -44- 第8章hello的IO管理 -45- 8.1Linux的IO设备管理方法 -45- 8.2简述UnixIO接口及其函数 -45- 8.3printf的实现分析 -46- 8.4getchar的实现分析 -47- 8.5本章小结 -48- 结论 -49- 附件 -51- 参考文献 -52- 第1章概述 1.1hello简介 P2P:FromProgramtoProcess 用C语言编写得到的hello.c经过cpp的预处理变为hello.i，然后经过cc1的编译变为hello.s，再经过as的汇编变为hello.o，最后经过ld的链接成为可执行目标文件hello，如图1-1所示。当我们在shell中键入执行命令后，shell创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。 图1-1编译系统 020:FromZerotoZero Shell生成的子进程通过execve加载并运行hello，操作系统为其分配虚拟内存空间，再将虚拟内存空间映射到物理内存空间，然后进入main函数执行目标代码。CPU为运行的hello分配时间片，执行逻辑控制流。IO和信号处理使得hello中的内容能顺利显示到屏幕上。程序运行结束后，shell接收信号，回收hello进程，内核将会清除与hello相关的数据。 1.2环境与工具 硬件环境：X64CPU；2.5GHz；8GRAM；256GHDDisk 软件环境：Windows1064位；VMware16；Ubuntu20.04LTS64位 工具：gcc；edb；objdump；readelf等 1.3中间结果 文件名文件作用hello.ihello.c预处理后的文本文件，用于分析预处理结果hello.shello.i编译后的汇编文件，用于分析编译结果hello.ohello.s汇编后的可重定位目标文件，用于分析汇编结果elf.txthello.o的ELF格式，用于分析hello.oobjdump.txthello.o的反汇编代码，用于分析hello.ohellohello.o链接后的可执行目标文件elf2.txthello的ELF格式，用于分析helloobjdump2.txthello的反汇编代码，用于分析hello 1.4本章小结 本章简述了hello程序P2P和020的整个过程，介绍了实验所用到的环境和工具，并给出了hello程序走完整个生命周期将会经历的中间文件。 第2章预处理 2.1预处理的概念与作用 概念： 预处理是指预处理器根据以字符#开头的命令（包括宏定义、条件编译和源文件包含等），修改原始的C程序，插入指定文件，扩展指定的宏，得到一个完整的文本文件。 作用： 1.对宏定义进行宏替换。 2.处理条件编译命令，过滤不需要编译的代码。 3.将需包含的源文件的内容插入程序文本中。 4.过滤掉所有的注释。 5.使得源代码在不同的执行环境中被方便的修改或编译。 2.2在Ubuntu下预处理的命令 预处理命令：gcchello.c-E-ohello.i 图2-1预处理命令 2.3hello的预处理结果解析 将得到的hello.i以文本文件形式打开，会发现原本几十行的hello.c（如图2-2）变成了数千行。文件的最后末端部分是hello.c的主体内容（如图2-3），前面部分（如图2-4）将指定的源文件包含了进来，说明已经将hello.c进行了预处理。 图2-2hello.c代码 图2-3hello.i前面部分代码（仅展示了前50行） 图2-4hello.i末端部分代码 2.4本章小结 本章介绍了预处理的概念及作用，并演示了在Ubuntu虚拟机下对hello.c进行预处理的过程，分析了预处理结果hello.i。 第3章编译 3.1编译的概念与作用 概念： 编译是指编译器将预处理后得到的.i文件（文本文件）处理成为.s文件（文本文件），它包含一个汇编语言程序。 作用： 编译器能将不同的高级语言写出的源程序转换为使用通用的汇编语言的汇编语言程序，为后续生成机器语言的代码做好准备。值得一提的是，除了实现上述基本功能，编译器还可以实现语法检查、程序优化等功能。 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序。 3.2在Ubuntu下编译的命令 编译命令：gcchello.i-S-ohello.s 图3-1编译命令 3.3hello的编译结果解析 3.3.1数据类型 1.全局变量intsleepsecs 全局变量sleepsecs被存储在了数据段（如图3-2），其值大小不是2.5，而是2，这是因为sleepsecs的类型被定义为了int，这里进行了一个隐式的转换。 图3-2全局变量sleepsecs的编译结果 2.main函数参数intargc argc作为第一个参数，被存储在寄存器%rdi中。 图3-3main函数参数argc的编译结果 3.main函数参数char*argv[] argv作为第二个参数，被存储在寄存器%rsi中。注意argv是作为一个char型数组的首地址被存在%rsi中的。 图3-4main函数参数argv的编译结果 4.局部变量inti 局部变量通常储存在栈上，在hello.s中，我们能发现局部变量i存储在了栈上-4(%rbp)处。 图3-5局部变量i的编译结果 5.常量 代码中出现的常量，均以立即数的形式出现在hello.s中（如图3-6）。 图3-6常量的编译结果 6.字符串 字符串被放在只读数据段，如图3-7。 图3-7字符串的编译结果 3.3.2赋值操作 程序中的赋值操作i=0，由movl实现（如图3-5）。其中l表示传送的是双字大小，即4个字节。 3.3.3算术操作 程序中算术操作i++，由addl实现（如图3-8）。 图3-8i++的编译结果 3.3.4关系操作 1.argc!=3 判断main函数参数argc与3的大小时，用到了cmpl（如图3-9），然后设置条件码，为后续跳转做准备。 图3-9argc!=3的编译结果 2.i<10 判断局部变量i和10的大小时，用到了cmpl（如图3-10），然后设置条件码，为后续跳转做准备。 图3-10i<10的编译结果 3.3.5数组操作 程序中涉及到读取argv[1]和argv[2]的操作（如图3-11），可以看到先是将argv[0]的地址传入%rax，然后将%rax加16，即可得到argv[2]的地址，再将%rax中的值作为地址，将内存中对应地址处的值传给%rdx，至此便成功将argv[2]中的值读取出来存储到%rdx中了。读取argv[1]的值方法类似，不过在将%rax加16处改为了将%rax加8，使得%rax中存储的是argv[1]的地址，而不是argv[2]的地址。 图3-11argv[1]和argv[2]的编译结果 3.3.6控制转移 1.if(argc!=3) 3.3.4中的关系操作会使得条件码被设置，当条件满足时（ZF被设置，即两数相等），指令会跳转到指定处（.L2），如图3-12。 图3-12if(argc!=3)的编译结果 2.for(i=0;i<10;i++) 第一次循环开始前，先给i赋初值，然后无条件跳转到循环条件判断处（.L3），之后每次循环开始前都会比较i与10的大小，设置条件码，从而根据条件码判断是否需要继续跳转到循环体开始处（.L4），如图3-13。 图3-13if(argc!=3)的编译结果 3.3.7函数操作 函数被调用之前，需要先在寄存器中存好要传的参数（存储器使用顺序为%rdi、%rsi、%rdx、%rcx、%r8、%r9），然后用call来调用函数，函数的返回值会被存放到寄存器%rax中。 1.main函数 参数传递：main函数的传入参数argc和argv，分别用寄存器%rdi和%rsi存储，前面已经详细叙述过。 函数调用：main函数的调用是由_start函数调用的系统启动函数__libc_start_main来完成的，main的返回值也将由它处理，并且在需要的时候会将控制返回给内核。 函数返回：设置%eax为0并且leave，如图3-14，对应return0。 图3-14main函数返回的编译结果 2.printf函数 参数传递：第一次调用时，将字符串“Usage:Hello学号姓名！\n”的有效地址传入%rdi作为参数，调用puts，如图3-15。第二次调用时，将字符串“Hello%s%s\n”的有效地址传入%rdi，将argv[1]和argc[2]的值分别传入%rsi和%rdx作为参数，调用puts，如图3-16。 图3-15第一次调用printf函数 图3-16第二次调用printf函数 函数调用：在if条件判断中被main函数调用一次（如图3-15），在for循环中被main函数调用一次（如图3-16）。 3.exit函数 参数传递：传入的参数为1，存储在%rdi中，如图3-17。 函数调用：在if条件判断中被main函数调用，如图3-17。 图3-17调用exit函数 4.sleep函数 参数传递：传入的参数为sleepsecs，存储在%rdi中，如图3-18。 函数调用：在for循环中被main函数调用，如图3-18。 图3-18调用sleep函数 5.getchar函数 函数调用：在main函数中，最后返回前被调用，如图3-19。 图3-19调用getchar函数 3.4本章小结 本章介绍了编译的概念及作用，演示了在Ubuntu虚拟机下对hello.i进行编译得到hello.s的过程，并分析了编译结果。在结果分析部分，对hello.c中存在的数据类型、赋值操作、算术操作、关系操作、数组操作、控制转移和函数操作均进行了具体的分析，详细解读了hello的编译结果。 第4章汇编 4.1汇编的概念与作用 概念： 汇编是指汇编器将编译后得到的.s文件（文本文件）翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在目标文件.o（二进制文件）中。 作用： 将汇编代码转为机器语言指令，使代码真正能被机器识别并执行。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。 4.2在Ubuntu下汇编的命令 汇编命令：ashello.s-ohello.o 图4-1汇编命令 4.3可重定位目标elf格式 首先使用指令readelf-ahello.o>elf.txt获得hello.o的ELF可重定位目标文件，如图4-2。 图4-2生成elf.txt 1.ELF头 ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。 如图4-3，可以看出该系统字的大小为64位，采用小端序，机器类型为x86-64，这个ELF头的大小为64字节，有14个节头，文件是可重定位目标文件。 图4-3ELF头 2.节头部表 节头部表是描述目标文件的节，它会描述目标文件中不同节的编号、名称、类型、地址、偏移量、大小、全体大小、旗标、链接、信息和对齐等，如图4-4。 图4-4节头部表 3.重定位节 重定位节中的偏移量是指需要被修改的引用的节偏移；类型告知链接器如何修改新的引用；符号名称标识被修改引用应该指向的符号；加数是一个有符号常数，一些重定位要使用它对被修改引用的值做偏移调整。具体的重定位过程将在第5章进行叙述，此处只介绍相关概念。 .rela.text（如图4-5）是一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。 图4-5.rela.text节 类似地，.rela.eh_frame（如图4-6）中包含.eh_frame节中需要进行重定位的信息。 图4-6.rela.eh_frame节 4.符号表 .symtab是一个符号表（如图4-7），它存放在程序中定义和引用的函数和全局变量的信息。每个可重定位目标文件在.symtab中都有一张符号表（除非特意用STRIP命令去掉它）。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。 图4-7符号表 4.4hello.o的结果解析 首先使用objdump-d-rhello.o>objdump.txt得到hello.o的反汇编代码，如图4-8。 图4-8生成objdump.txt 查看objdump.txt的内容，如图4-9。 图4-9objdump.txt 将objdump.txt与hello.s比较，会发现两者具有一定的相似性，即在汇编指令部分几乎完全一致，涉及到函数调用的部分汇编指令发生了变化，引入了重定位条目。而且objdump.txt中出现了hello.s中没有的机器语言。 机器语言是纯粹的二进制数据表示的语言，能真正被机器识别并执行；汇编语言是容易被人理解的直接描述CPU行为的语言，但机器并不能直接识别和执行。每一条汇编语言的指令都能被转换为唯一确定的机器语言指令，即两者间存在着一一对应的映射关系。 机器语言中的操作数是由寄存器指示符字节指明用到的寄存器，用常数字指明立即数数据、地址指示符的偏移量及分支和调用的目的地址；而汇编语言用立即数、寄存器和内存引用的方式指明操作数。 hello.s中，程序为了进行分支转移，进行了分段并命名（如.L3），这是在编译时候标记的助记符。在汇编成机器语言之后，为了明确下一条指令的位置，不能再使用这种段名称的标记方式，所以objdump.txt得到的反汇编代码中的跳转指令用的不再是段名称，而是确定的地址。 hello.s中，函数调用后面直接跟着被调用函数的名称，而objdump.txt中，call的目标地址是下一条指令。这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器来确定函数运行时的目标地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0(即设为下一条指令），并在.rela.text节中添加重定位条目，等待后续的重定位。 4.5本章小结 本章介绍了汇编的概念及作用，演示了在Ubuntu虚拟机下对hello.s进行汇编得到hello.o的过程，并分析了汇编结果。在分析结果时，先是用readelf查看了hello.o的ELF文件，从ELF头、节头部表、重定位节和符号表的角度分别进行了分析，介绍一些基本概念，为第5章做好准备。同时也使用objdump查看了hello.o的反汇编代码，从操作数、分支转移和函数调用等方面分析了机器语言和汇编语言的差异。 第5章链接 5.1链接的概念与作用 概念： 链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。 作用： 链接使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其它文件。 注意：这儿的链接是指从hello.o到hello生成过程。 5.2在Ubuntu下链接的命令 链接命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5-1链接命令 5.3可执行目标文件hello的格式 首先使用指令readelf-ahello>elf2.txt获得hello的ELF可执行目标文件，如图5-2。 图5-2生成elf2.txt 1.ELF头 如图5-3，可以看出ELF头中部分信息与链接前相比发生了变化，文件类型变成了可执行目标文件，节头和程序头均增加，还获得了程序的入口点地址。 图5-3ELF头 2.节头部表 如图5-4，此时节的数量增多，各节已被重定位到最终运行时的内存地址处，地址、偏移量、大小等数据发生了变化。 图5-4节头部表 3.程序头部表 可执行文件的连续的片被映射到连续的内存段，程序头部表描述了这种映射关系。如图5-5，offset表示目标文件中的偏移，viraddr是虚拟地址，phyaddr是内存地址，filesize是目标文件中段的大小，memsiz是内存中段的大小，flags是运行时的访问权限，align是对齐要求。 PHDR指保存了二进制的程序头表，INTERP指定程序已经从可执行文件映射到具体的内存区域后，必须调用的解释器（如动态链接器）的路径，LOAD表示可加载的程序段，DYNAMIN保存了由动态链接器使用的信息，NOTE保存辅助信息，GNU_STACK标志栈是否可执行，GNU_RELRO指定重定位后需被设置成只读的内存区域。 图5-5程序头部表 5.4hello的虚拟地址空间 下面在DataDump中查看5.3中出现的段，以标为INTERP和第三个标为LOAD的段为例。 图5-6INTERP段 图5-7LOAD段 以这两个段为例，能看到在程序头表中描述的段的各类信息（类型、起始地址和大小等）均和DataDump查看结果一致。实际上，所有段的虚拟地址信息都被正确而完整地记录在了程序头表中。 5.5链接的重定位过程分析 首先使用objdump-d-rhello>objdump2.txt得到hello的反汇编代码，如图5-8。 图5-8生成objdump2.txt 查看objdump2.txt的内容，如图5-9。 图5-9objdump2.txt（仅包含main函数部分） 和上次反汇编的结果进行比较，有一些不同之处： （1）hello反汇编得到的汇编代码中，已经有了确定的地址，即完成了重定位；而hello.o反汇编的结果尚未进行重定位，仅仅标注出了需要重定位的部分。 （2）hello反汇编的结果中出现了更多函数的汇编代码，节也增多了，这是因为链接使得多个文件合并，更多的节以及更多的函数都被引入了。 ELF有多种重定位类型，其中最基本的两种是R_X86_64_PC32和R_X86_64_32，这两种重定位算法的伪代码如图5-10所示，其中r表示重定位条目，s表示节。 图5-10重定位算法 图5-11exit重定位后的地址 现在以exit为例，分析其重定位的实现过程：查看图4-9中的代码和重定位条目，再结合图4-5中的重定位节的信息，可知main函数引用了exit，且需使用32位PC相对地址进行重定位（R_X86_64_PLT32同R_X86_64_PC32一样是相对寻址）。 若exit的重定位条目为r，则由图4-9知，有： r.offset=0x2b r.symbol=exit r.type=R_X86_64_PLT32 r.addend=-4 且s满足： ADDR(s)=0x401105（如图5-9） 此外： ADDR(r.symbol)=ADDR(exit)=0x4010b0（如图5-11） 由图5-10中的公式知： refaddr=ADDR(s)+r.offset=0x401105+0x2b=0x401130 *refptr=(unsigned)(ADDR(r.symbol)+r.addend-refaddr) =(unsigned)(0x4010b0+(-4)-0x401130) =(unsigned)(0xffffff7c) 如图5-12，重定位结果正确。 图5-12hello中调用exit处代码 5.6hello的执行流程 ld-2.31.so!_dl_start ld-2.31.so!_dl_init hello!_start callmain ld-2.31.so!__libc_start_main hello!_init hello!main hello!puts@plt hello!exit@plt 5.7hello的动态链接分析 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的。共享库也称为共享目标，在Linux系统中通常用.so后缀来表示。 动态链接器使用过程链接表PLT+全局偏移量表GOT实现函数的动态链接，GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。如果一个目标模块调用定义在共享库中的任何函数，那么就有自己的GOT和PLT。 过程链接表（PLT）。PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 全局偏移表（GOT）。GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。初始时，每个GOT条目都指向对应PLT条目的第二条指令。 .got.plt起始地址是0x404000（如图5-4），在dl_init前，内容如图5-13所示。 图5-13dl_init前.got.plt内容 在dl_init后，内容如图5-14所示。 图5-14dl_init后.got.plt内容 5.8本章小结 本章介绍了链接的概念及作用，演示了在Ubuntu虚拟机下对hello.o进行链接得到hello的过程，并分析了链接结果。在分析结果时，先是用readelf查看了hello的ELF文件，从ELF头、节头部表和程序头部表的角度分别进行了分析，验证了段在虚拟地址空间的位置。同时也使用objdump查看了hello的反汇编代码，发现链接后的目标文件函数和节都增加了，重定位也完成了，还以exit为例解释了重定位算法的具体实现。除了静态的链接，链接器还会动态链接共享库，在最后还展示了hello的执行流程，分析了hello的动态链接。 第6章hello的进程管理 6.1进程的概念与作用 概念： 进程的经典定义就是一个执行中的程序的实例。系统的每一个程序都是运行在某一个进程上下文中。上下文是由程序正确运行所需要的状态构成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及上下文描述符的集合。 作用： 1.每次用户通过向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在新进程的上下文中运行它们自己的代码或其他应用程序。 2.进程提供给应用程序的关键抽象：一个独立的逻辑控制流，好像我们的程序独占地使用处理器；一个私有的地址空间，好像我们的程序独占地使用内存系统。 6.2简述壳shell-bash的作用与处理流程 作用： shell是一个应用程序，是操作系统中用户与系统内核进行交互的界面。 处理流程： 1.读取用户由键盘输入的命令行。 2.分析命令，以命令名作为文件名，并将其它参数改造为系统调用execve()内部处理所要求的形式。 3.终端进程调用fork()建立一个子进程。 4.终端进程本身调用wait()来等待子进程完成（如果是后台命令，则不等待）。当子进程运行时调用execve()，子进程根据文件名到目录中查找有关文件，调入内存，执行这个程序。 5.如果命令末尾有&,则终端进程不用执行系统调用wait()，立即发提示符，让用户输入下一条命令；否则终端进程会一直等待，当子进程完成工作后，向父进程报告，此时中断进程醒来，作必要的判别工作后，终端发出命令提示符，重复上述处理过程。 6.3hello的fork进程创建过程 父进程通过调用fork函数创建一个新的运行的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同但是独立的一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本。父进程和子进程最大的区别在于他们有不同的PID。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流中的指令。 在这里，shell作为父进程通过fork函数为hello创建一个新的子进程，在这个新进程的上下文中运行hello。 6.4hello的execve过程 子进程调用exceve函数在当前子进程的上下文加载并运行一个新的程序，此处即hello程序。exceve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量argc。加载器会删除现有的用户区域；映射私有空间，创建新的代码、数据、堆和栈区域，将代码段和数据段初始化为hello的代码和数据，堆和栈被置空；映射共享区域，实现动态链接；设置PC，将其指向hello程序的起始位置，即从下条指令开始执行hello程序。 6.5hello的进程执行 多个流并发地执行的一般现象被称为并发。一个进程和其他进轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片。因此，多任务也叫做时间分片。 内核为每个进程维持了一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策叫做调度。在内核调度了一个新的进程运行后，它就抢占当前进程，使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换1）保存当前进程的上下文，2）恢复某个先前被抢占的进程被保存的上下文，3）将控制传递给这个新恢复的进程。 最初hello运行在用户模式下，内核将控制给hello，为hello分时间片，上下文为hello的上下文。hello正常运行，当遇到sleep函数时，内核会因显式的请求抢占hello，进行上下文切换，将控制转移给sleep，直到sleep结束，内核再进行上下文切换，将控制传递给hello，过程如图6-1。其他的函数调度过程类似。 图6-1进程调度（以sleep为例） 6.6hello的异常与信号处理 可能出现的异常一共有四种：中断、陷阱、故障、终止。它们的产生原因及处理如图6-2。 图6-2异常类别及处理 在发生异常时会发出信号，常见信号种类如图6-3所示。 图6-3信号种类及处理 图6-4展示了正常运行hello至结束的情况。 图6-4正常运行 若在运行过程中乱按键盘，如图6-5。可以看到只是将字符缓存到stdin，直到按下’\n’，被当作命令读入。 图6-5乱按键盘 若在运行过程中按下Ctrl+C，内核发送一个SIGINT信号到前台进程组的每个进程，默认情况是终止前台作业，hello将会被立即终止，用ps查看发现无hello，如图6-6。 图6-6按下Ctrl+C 若在运行过程中按下Ctrl+Z，内核发送一个SIGTSTP信号到前台进程组的每个进程，默认情况是停止前台作业，此时hello未被回收，而运行在后台，用ps查看发现有hello，如图6-7。 图6-7按下Ctrl+Z 用jobs查看当前进程情况，用pstree查看相关进程关系，如图6-8。 图6-8jobs和pstree查看相关信息 用fg1将hello调回前台，此时会先打印执行hello的命令行命令，然后hello继续运行打印剩下的7个输出，最后输入字串，程序结束，同时进程被回收，如图6-9。 图6-9用fg调回hello 6.7本章小结 本章阐述了进程的概念与作用，介绍了Shell的作用和一般处理流程，分析了调用fork创建新进程，调用execve加载并执行hello以及hello的进程调度。还以乱按键盘、按下Ctrl+C和按下Ctrl+Z为例，着重分析了hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：程序产生的和段相关的偏移地址，由一个标识符加上一个指定段内的相对地址的偏移量构成。 线性地址（虚拟地址）：逻辑地址到物理地址变换之间的中间层。段中的偏移地址加上相应段的基地址就生成了一个线性地址。 物理地址：指出目前CPU外部地址总线上的寻址物理内存的地址信号，用于内存级芯片的单元寻址，是地址变换的最终结果地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由段标识符和段内偏移量两部分组成。段标识符是由一个16位长的字段组成，其中前13位是一个索引号，后3位是T1字段，索引号是段描述符的索引，很多个段描述符组成了一个段描述符表。先判断T1字段，看看这个段描述符究竟是在局部段描述符表(ldt)中还是全局段描述符表(gdt)中，通过索引号在描述符表内找到一个具体的段描述符。找到的段描述符加上偏移量即为线性地址。 7.3hello的线性地址到物理地址的变换-页式管理 系统将虚拟页作为进行数据传输的单元。虚拟内存分割被成为虚拟页，物理内存也被分割为物理页，大小和虚拟页相同。任意时刻虚拟页都被分为三个不相交的子集：未分配的（VM系统还未分配的页）、缓存的（当前已经缓存在物理内存的已分配页）、未缓存的（当前未缓存在物理内存的已分配页）。 每次将虚拟地址转换为物理地址，都会查询页表来判断一个虚拟页是否缓存在DRAM的某个地方，如果不在DRAM的某个地方，通过查询页表条目可以知道虚拟页在磁盘的位置。页表将虚拟页映射到物理页，如图7-1。 图7-1页表 7.4TLB与四级页表支持下的VA到PA的变换 先将虚拟地址分为虚拟页号（VPN），虚拟页偏移量（VPO），依据VPN（TLBT+TLBI）先在TLB中寻找，若找不到，则在高速缓存/内存中寻找，若找到对应的物理页号（PPN），再将PPN与VPO组合成物理地址，若还是查找不到，则需要缺页处理，在磁盘中查找，并将新的页更新入内存中，如图7-2。 图7-2使用页表的地址翻译 如图7-3，36位的VPN被分成4个9位的片，每个片被用做到一个页表的偏移量。CR3寄存器包含一级页表的基地址。VPN1提供一个一级PTEi的偏移量，它包含二级页表的基地址，VPN2再提供一个偏移量，以此类推。 图7-3TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 图7-4物理地址的划分 如图7-4，将已得到的物理地址拆分为CT（标记），CI（组索引），CO(块偏移)，在L1Cache中依据组索引，找到对应的组，再依据标记查找是否存在并判断是否有效，最后根据块偏移找到块，如图7-5。如果上述条件均满足则命中，否则按顺序对L2Cache、L3Cache、内存进行相同操作，直到命中，然后向上级返回。如果有空闲块则将目标块放置到空闲块中，否则将缓存中的某个块驱逐，将目标块放到被驱逐块的位置。 图7-5高速缓存组织结构 7.6hello进程fork时的内存映射 当fork函数被shell调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了hello进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序，如图7-6。加载并运行hello需要以下几个步骤： (1)删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 (2)映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 (3)映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 (4)设置程序计数器(PC)，execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 图7-6加载器映射用户地址空间的区域 7.8缺页故障与缺页中断处理 当指令引用一个虚拟地址，而与改地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生缺页故障。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。上述过程如图7-7所示。 图7-7缺页故障的处理 在发生缺页中断之后，系统会调用内核中的一个缺页处理程序。处理缺页要求硬件和操作系统内核协作完成，具体的操作过程如图7-8所示： (1)处理器生成一个虚拟地址，并把它传送给MMU。 (2)MMU生成PTE地址，并从高速缓存/主存请求得到它。 (3)高速缓存/主存向MMU返回PTE。 (4)PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。 (5)缺页处理程序确定出物理内存中的牺牲页，如果这个页面己经被修改了，则把它换出到磁盘。 (6)缺页处理程序页面调入新的页面，并更新内存中的PTE。 (7)缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，主存将所请求字返回给处理器。 图7-8缺页处理流程 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器，要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。C++中的new和delete操作符与C中的malloc和free相当。 隐式分配器，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集，例如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 下面介绍两种常见的分配器： 1.带边界标签的隐式空闲链表 一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是0。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。 头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。 我们称这种结构称为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。注意：此时我们需要某种特殊标记的结束块，可以是一个设置了已分配位而大小为零的终止头部。 Knuth提出了边界标记的技术，是在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面的一个块的起始位置和状态，这个脚部总是在据当前块开始位置一个字的距离。 考虑当分配器释放当前块时可能存在的所有情况： 1）前面的块和后面的块都是已分配的。 2）前面的块是已分配的，后面的块是空闲的。 3）前面的块是空闲的，而后面的块是已分配的。 4）前面的和后面的块都是空闲的。 按照图7-9分类处理即可： 图7-9使用边界标记的4种合并情况 然而这种方法也存在一个潜在的缺陷。它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销。 幸运的是，有一种非常聪明的边界标记的优化方法，能够使得在已分配块中不再需要脚部。把前面块的已分配位/空闲位存放在当前块中多出来的低位中，那么已分配的块就不需要脚部了，这样我们就可以将这个多出来的空间用作有效载荷了。不过空闲块仍然需要脚部。 2.显式空间链表 根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里。例如，堆可以组织成一个双向空闲链表。在每个空闲块中，都包含一个前驱和后继指针，如图7-10。 图7-10使用双向空闲链表的堆块的格式 使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块的线性时间。不过，释放一个块的时间也可以是线性的，也可能是某个常数，这取决于我们所选择的空闲链表中块的排序策略。 一种方法是使用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 另一种方式是按照地址顺序来维护链表，其中链表上每一个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。 7.10本章小结 本章主要介绍了hello的存储管理，讲解了存储器地址空间，段式管理和页式管理的机制，TLB与四级页表支持下的VA到PA的变换和三级Cache支持下的物理内存访问，并且回顾了hello进程fork时和execve时的内存映射，分析了缺页故障与缺页中断处理的流程，最后介绍了动态存储分配管理的方式。这一章的知识有助于编写高速缓存友好代码，优化程序。 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m个字节的序列，所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 UnixI/O接口使得所有输入和输出都能以一种统一且一致的方式来执行： (1)打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。 (2)Linuxshell创建的每个进程都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。 (3)改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 (4)读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k³m时，执行读操作会触发EOF条件，应用程序能检测到这个条件。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 (5)关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： (1)intopen(char*filename,intflags,mode_tmode)：进程通过调用open函数来打开一个已存在的文件或是创建一个新文件。open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件。mode参数指定了新文件的访问权限位。 (2)intclose(intfd)：进程通过调用close函数来关闭一个打开的文件。 (3)ssize_tread(intfd,void*buf,size_tn)：read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF。否则返回值表示的是实际传送的字节数量。 (4)ssize_twirte(intfd,constvoid*buf,size_tn)：write函数从内存位置buf复制至多n个字节到描述符为fd的当前文件位置。 8.3printf的实现分析 首先查看printf的代码： intprintf(constchar*fmt,…) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 其中va_list的定义为：typedefchar*va_list；这说明它是一个字符指针。 (char*)((&fmt)+4)表示的是…中的第一个参数。 vsprintf返回的是要打印出来的字符串的长度，它的作用就是格式化。它接受确定输出格式的格式字符fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 再看看write: moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL 其中INT_VECTOR_SYS_CALL的实现为：init_idt_desc(INT_VECTOR_SYS_CALL,DA_3861Gate,sys_caII,PRIVILEGE_USER); 其中intINT_VECTOR_SYS_CALL表示要通过系统来调用sys_call这个函数。 sys_call函数如下： callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret callsave是为了保存中断前进程的状态。 sys_call最终实现显示格式化的字符串的功能。它将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量），于是打印字符串就显示在了屏幕上。 8.4getchar的实现分析 异步异常-键盘中断的处理：当用户按键时，键盘接口会得到一个代表该按键的键盘扫描码，同时产生一个中断请求，中断请求抢占当前进程，运行键盘中断子程序。键盘中断子程序先从键盘接口取得该按键的扫描码，然后将该按键扫描码转换成ASCII码，保存到系统的键盘缓冲区。 查看getchar的代码如下： int getchar(void) { static char buf[BUFSIZ]; static char*bb=buf; static int n=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return (--n>=0)?(unsigned char)*bb++:EOF; } getchar函数落实到底层调用了系统函数read，通过系统调用read读取存储在键盘缓冲区中的ASCII码，直到读到回车符然后返回整个字串，getchar对其进行封装，读取字符串的第一个字符然后返回。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法，引出了UnixI/O接口的概念，又进一步介绍了UnixI/O的函数，最后简单分析了printf函数和getchar函数的实现。 结论 至此，hello已经走完它短暂的一生。我们在这里对它的人生历程再进行一次回顾。 Hello出生于名为hello.c的文本文件里，程序员通过对键盘的一次次敲击赋予了它生命。 刚出生不久的hello来到了预处理器的怀抱里，它在这里被修改 插入指定文件，扩展指定的宏，变成了一个更完整的文本文件hello.i。 然后，在编译器的帮助下，它把自己从原本的高级语言源程序变成了汇编语言程序hello.s，努力向着被机器识别并执行的方向前进着。 接下来，汇编器再助它一臂之力，将它翻译成机器语言指令，并把这些指令打包成可重定位目标程序的格式保存在二进制文件hello.o中。 虽然已经能被机器识别并运行了，hello却发现自身还需要进一步完善。它又去寻求了链接器的帮助，经过静态链接和动态链接的它终于成为了可执行目标文件hello。 当我们在shell中输入指令执行hello的那一刻，hello变身成为进程。这一刻意义巨大，这标志着hello完成了人生中的第一个阶段 P2P(FromProgramtoProcess)。 Shell调用fork函数生成一个新的子进程，这个子进程通过调用execve函数启动加载器加载hello，为其分配虚拟内存空间，再将虚拟内存空间映射到物理内存空间，然后进入main函数执行目标代码。CPU为运行的hello分配时间片，执行逻辑控制流。 在运行过程中，OS与MMU为hello的VA到PA操碎了心，TLB、四级页表和三级Cache等等各显神通为hello加速。 IO帮助hello中的内容顺利显示到屏幕上。 程序运行结束后，shell接收信号，回收hello进程，内核将会清除与hello相关的数据。Hello走完人生最后一个阶段 020(FromZerotoZero)，完美谢幕！ 通过对hello程序人生的分析，我感受到计算机系统的设计是环环相扣、精妙无比的。这次的计算机系统漫游使我对计算机的底层实现有了更深的理解，还学习到了避免由计算机表示数字方式引起数字错误的实践技巧、避免诸如缓冲区溢出等安全漏洞的方法、优化代码以充分利用现代处理器和存储器系统的设计。有了软件和硬件的相互配合，才有了高效的计算机系统。深入了解这些组件是如何工作的以及这些组件如何影响程序的正确性和性能，能大大提升计算机从业者的技能。 附件 文件名文件作用hello.ihello.c预处理后的文本文件，用于分析预处理结果hello.shello.i编译后的汇编文件，用于分析编译结果hello.ohello.s汇编后的可重定位目标文件，用于分析汇编结果elf.txthello.o的ELF格式，用于分析hello.oobjdump.txthello.o的反汇编代码，用于分析hello.ohellohello.o链接后的可执行目标文件elf2.txthello的ELF格式，用于分析helloobjdump2.txthello的反汇编代码，用于分析hello 参考文献 [1] RandalE.Bryant,DavidR.O’Hallaron.深入理解计算机系统（原书第3版）[M].机械工业出版社，2016.7 [2] https://www.cnblogs.com/pianist/p/3315801.html [3] https://blog.csdn.net/weixin_30438795/article/details/117124493 [4] https://blog.csdn.net/wohenfanjian/article/details/105869692 
第259篇文章[]
设计模式之装饰器模式（Decorator） 在设计继承树的时候，我们会选择将最基础最普遍的方法（共性方法）放入最顶层的接口中去实现，而将各个特殊的方法（个性方法）在底层的具体子类中去实现。 对于一些局部共性（即一些类有，一些类没有的方法），我们可以选择使用装饰器模式。本文接下来将会对装饰器模式进行简单介绍。 装饰器模式 装饰器模式是设计模式中常见的一种，它以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。示意图如下： 在装饰器模式中的角色有： 抽象构件角色(Component)：给出一个抽象接口，以规范将要实现功能扩展的对象。 具体构件角色(ConcreteComponent)：定义一个将要实现功能扩展的类。 装饰角色(Decorator)：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰角色(ConcreteDecorator)：负责给构件对象实现扩展的功能。 publicinterfaceComponent{ publicvoidsampleOperation(); } publicclassConcreteComponentimplementsComponent{ @Override publicvoidsampleOperation(){   } } publicclassDecoratorimplementsComponent{ privateComponentcomponent; publicDecorator(Componentcomponent){ //delegation this.component=component; } @Override publicvoidsampleOperation(){ component.sampleOperation(); } } publicclassConcreteDecoratorAextendsDecorator{ publicConcreteDecoratorA(Componentcomponent){ super(component); } @Override publicvoidsampleOperation(){ super.sampleOperation(); //实现功能扩展  } } publicclassConcreteDecoratorBextendsDecorator{ publicConcreteDecoratorB(Componentcomponent){ super(component); } @Override publicvoidsampleOperation(){ super.sampleOperation(); //实现功能扩展  } } 变化 如果只有一个具体构件角色，那么可以考虑去掉抽象构件角色，把装饰角色作为一个具体构件角色的子类。示意图如下： 如果只有一个具体装饰角色，那么还可以把装饰角色和具体装饰角色合并成一个类。示意图如下： 透明性要求 装饰器模式对客户端的透明性，要求程序不要声明一个ConcreteComponent类型或者ConcreteDecorator类型的变量，而应当声明一个Component类型的变量。示例代码如下： Componentcomponet=newConcreteComponent(); ComponentconcretedecoratorA=newConcreteDecoratorA(component); 如下示例代码是错误的： ConcreteComponentcomponet=newConcreteComponent(); ConcreteDecoratorAconcretedecoratorA=newConcreteDecoratorA(component); 半透明的装饰器模式 如果能满足透明性的要求，则是纯粹的装饰器模式，它要求在不改变接口的前提下扩展功能。但是在实际的功能扩展中，往往需要创建新的方法，这就导致了“半透明”的装饰器模式的出现。即允许装饰器模式改变接口以实现功能扩展。这意味着客户端可以声明ConcreteDecorator类型的变量，从而调用在ConcreteDecorator类中才有的方法，示例代码如下： Componentcomponet=newConcreteComponent(); ConcreteDecoratorAconcretedecoratorA=newConcreteDecoratorA(component); concretedecoratorA.methodA(); 半透明的装饰器模式是介于装饰器模式和适配器模式之间的。装饰器模式不改变类的接口，通过改写方法来扩展类的功能。适配器模式并不扩展类的功能，但是会改变类的接口，以便和目标接口相符合。半透明的装饰器模式应用更广，也称做半装饰器、半适配器模式。 对比继承关系 再把装饰器模式和继承关系对比分析一下，两者都是要扩展类的功能，但是装饰器模式比继承关系更具灵活性。装饰器模式允许动态地决定增加或是删除扩展的功能，按照需求自由地进行扩展性能的组合；而继承关系是静态的，事先就要全部写好，在扩展性能较多的时候，会遇到“组合爆炸”的尴尬处境。但是在扩展性能较多的情况下，装饰器模式也有一定弊端，就是复杂程度较高，显得较为臃肿冗余。 
第260篇文章[]
正则表达式学习笔记（统一用法） 
第261篇文章[]
HIT软件构造LAB3随机进程调度的实现 首先列出需求：针对操作系统的进程调度管理系统，所需完成的功能为：Step1增加一组进程，输入每个进程的ID、名称、最短执行时间、最长执行时间；进程一旦设定无法再修改其信息。Step2当前时刻（设定为0）启动模拟调度，随机选择某个尚未执行结束的进程在CPU上执行（执行过程中其他进程不能被执行），并在该进程最大时间之前的任意时刻停止执行，如果本次及其之前的累积执行时间已落到[最短执行时间，最长执行时间]的区间内，则该进程被设定为“执行结束”。重复上述过程，直到所有进程都达到“执行结束”状态。在每次选择时，也可“不执行任何进程”，并在后续随机选定的时间点再次进行进程选择。 privateLinkedList<Process>processes=newLinkedList<Process>(); privateLinkedList<Process>finprocesses=newLinkedList<Process>(); processes存储未执行完成的进程finprocess存储执行完成的进程设置longstart=0为当前时刻因为我们的需求是一次性完成所有进程的调度，故设置循环条件 while(processes.isEmpty()) 然后进行第一步，随机挑选进程执行我们要用到Random函数设置max为链表processes当前的长度 max=processes.size(); Randomra=newRandom(); r=ra.nextInt(max); 得到一个在[0,max)之间的整形数索引，此随机数就是我们此次要操作的进程的组索引 但我们选择了某一个进程，也可能不进行任何操作，故设定一个跳过此次操作的概率（我设的五分之一） Randomrc=newRandom(); if(rc.nextInt(5)!=0){//后接执行操作 然后开始我们的调度，我的每个Process类中都存有该进程已执行的时长sum，故我们需要生成一个在区间(0,maxtime-sum]的随机数作为此次执行的时间（注意左开右闭，因为至少要执行一个时间单位）。并更新sum，将该执行插入进程执行表中（MultiIntervalSet）中，注意，start为当前时刻，start+temp为此执行操作结束时间，之后更新start为start+temp Randomrb=newRandom(); temp=rb.nextInt((int)(processes.get(r).getmax()-processes.get(r).getsum()))+1; temp1=processes.get(r).getmax(); temp1+=temp; processes.get(r).changesum(temp1); schedule.insert(start,start+temp,processes.get(r)); start+=start+temp; 判断sum的大小，若sum处于[最短执行时间，最长执行时间]的区间内，将该进程加入finprocesses中，并将其移出processes if(temp1>=processes.get(r).getmin()&&temp1<=processes.get(r).getmax()){ finprocesses.add(processes.get(r)); processes.remove(processes.get(r)); } 至此我们就完成了随机调度的操作 
第262篇文章[]
HIT软构lab2中GraphPoet的一种实现 首先是第一个方法GraphPoet的实现 publicGraphPoet(Filecorpus)throwsIOException{ BufferedReaderbr=newBufferedReader(newFileReader(corpus)); Stringline; Stringfront,next; inttemp; Stringfulltxt=""; while((line=br.readLine())!=null){ fulltxt=fulltxt+line+"";//得到全文 } br.close(); fulltxt=fulltxt.toLowerCase();//大写转小写 String[]wordset=fulltxt.split("");//将句子以各种分句符号或空格划分，得到单词集合 for(inti=0;i<wordset.length-1;i++){ front=wordset[i]; next=wordset[i+1]; if(!graph.vertices().contains(front)||!graph.targets(front).containsKey(next)){//若front不在点集中或不含到next的边则添加一条边 graph.set(front,next,1); continue; } if(graph.targets(front).containsKey(next)){//若已有该边则weight++ temp=graph.targets(front).get(next)+1; graph.set(front,next,temp); continue; } } checkRep(); //thrownewRuntimeException("notimplemented"); } 首先将输入的文本提取到字符串text中，再用spilt方法进行处理，spilt仅根据空格切分即可，标点符号不能切割。因为单词后面接上标点符号有助于对上下文的判断，比如Hi,nicetomeetyou.如果将标点符号切割掉，就会将Hi这个单词与nice形成前后文，这不是我们所需要的。同时，我们生成诗句时也需要保留原标点符号。 然后是poet实现 publicStringpoem(Stringinput){ String[]wordset=input.split("");//把input分词 Stringstr=wordset[0]; Set<String>frontset=newHashSet<>(); Set<String>nextset=newHashSet<>(); inttemp=0; Stringtempstr; for(inti=1;i<wordset.length;i++){ tempstr=""; temp=0; frontset=graph.targets(wordset[i-1].toLowerCase()).keySet();//将wordset中的第i-1位的顶点的targets中所有顶点的label赋值给frontset nextset=graph.sources(wordset[i].toLowerCase()).keySet();//将wordset中的第i位的顶点的sources中所有顶点的label赋值给frontset for(Stringfront:frontset){//遍历寻找两个词之间是否存在“桥梁” for(Stringnext:nextset){ if(front==next){ temp++; tempstr=front; } } } if(temp==1){//若两词之间有且只有一条长度为1的桥 str=str+""+tempstr+""+wordset[i]; continue; } str=str+""+wordset[i]; } checkRep(); returnstr; //thrownewRuntimeException("notimplemented"); } 我的思路是将input中的词先spilt分词，然后将前后两个词放入循环，若查找到存在桥，就将桥加入输出字符串中 
第263篇文章[]
HIT软件构造lab3中DutyRosterApp中函数isfull()的实现 HIT软件构造lab3中DutyRosterApp中函数isfull()的实现 首先该函数的需求是用户可随时检查当前排班是否已满（即所有时间段都已被安排了特定员工值班）、若未满，则展示给用户哪些时间段未安排、未安排的时间段占总时间段的比例。 用户输入的时间一般为xx年xx月xx日，我们需要通过函数LocalDate.of(intyear,intmonth,intday)来将输入的年月日转化为大小为输入日期到1970年1月1日之间的天数的整形数，通过此函数得到排班开始日期startdate，排班结束日期enddate首先创建一个大小为排班日期的boolean数组timelist period=enddate-startdate; boolean[]timelist=newboolean[(int)period]; 然后通过遍历所有有有排班的员工，将有排班的时间段赋值为true其中worker类为员工，包含员工信息 for(workerp:schedule.labels()){ start=p.getstart(); end=p.getend(); for(longi=start-startdate;i<end-startdate;i++){ timelist[(int)i]=true; } } 处理完此数组后再次进行循环来输出空闲时间段设置count计数器来记录空闲时间的数量，flag为判断位 for(intj=0;j<(int)period;j++){ if(timelist[j]==false){ count++; if(flag==0){ sparestart=j+startdate; flag=1; } } else{ if(flag==1){ spareend=j+startdate-1; System.out.println(LocalDate.ofEpochDay(sparestart)+"->"+LocalDate.ofEpochDay(spareend)); flag=0; } } } 循环中，若当前块为空且flag为0，将此块设置为空闲时间段的起点（加上startdate）继续遍历，碰到第一个非空闲块时将flag设回0，并将空闲时间段结尾段设为j-1+enddate并输出LocalDate.ofEpochDay(sparestart)+“->”+LocalDate.ofEpochDay(spareend)LocalDate.ofEpochDay()为将天数转回日期最后输出空白占比count/period（若count为0则不输出） 
第264篇文章[1]
HIT-CSAPP大作业程序人生 
第265篇文章[]
HIT软件构造MultiIntervalSet中数据结构的设计 我在MultiIntervalSet中设计了两个子类一个为Nper(命名没有实际意义），用来存储label以及一个time类的链表，用以存储对一个目标的多次排班或调度 classNper<L>{ privateLlabel; privateLinkedList<time>timelist=newLinkedList<time>(); publicNper(LNlabel,longNstart,longNend){ this.label=Nlabel; timeNtime=newtime(Nstart,Nend); timelist.add(Ntime); } } 第二个子类为time，用以储存单次调度的起始时间与终止时间 classtime{ privatelongstart; privatelongend; publictime(longNstart,longNend){ this.start=Nstart; this.end=Nend; } } 说回MultiIntervalSet protectedLinkedList<Nper<L>>multilabels=newLinkedList<Nper<L>>(); 主要的数据结构为<Nper>的链表multilabels，每一个Nper中都会存储一个Llabel以及对其的调度表timelist。此种设计的好处就是，当需要取出对某个进程的调度信息（或某门课程的排课信息）时，只需要找到一次相应的Nper就可以调出他的所有时间调度。而对timelist插入时间时会进行排序（time的insert函数），timelist中根据index的大小顺序存储调度发生的时间。当所需调用时会更加的方便且清晰 
第266篇文章[]
软件构造 关于git指令复习的进一步理解 笔者在前几天简单描述了我在lab2用git提交时出现的一个问题。今天我在复习软件构造课程时，读到了git作为SCM工具的简单应用，看见了这样的一张图： 我们提交实验时最常用的方法就是首先 gitadd<文件> 然后gitcommit-m“提交信息” 最后gitpushURL分支 实际上，这在上面的图中就是前三个步骤。而我在lab2中遇到的问题就是重复了第三步，在不同的localrepository（本地仓库上）进行gitpush，从而无法成功提交。当时我的解决方法就是找到了第一次进行提交的本地仓库，随后提交成功。另外一种解决办法就是gitpull，上图中的黄颜色的指令就是将远程仓库上的所有文件全部清空并下载到本地工作区。清空了全部内容，下一次的提交也就一定会成功了。 
第267篇文章[]
软件构造 关于一个github提交错误原因的解决办法 笔者在完成lab2时还是周六的晚上，但当第二天修改好实验报告准备提交时，已经是晚上十点了，距离截止时间还有不到两个小时的时候，发现github提交时出现了错误！ 当我按照git提交流程一步一步的做到了 gitcommit-m"提交信息" 时，没有出现任何问题，但是当我最后即将 gitpushxxxxmaster 时，发现出现了网络问题，无法连接至github，这是一个很常见的问题，只需要重新提交几次就可以提交成功了，但是，我十分手欠地新建了一个文件夹，将原文件夹的数据拷贝过去。并在新文件夹中重新建立git仓库，重新提交。 于是当到了最后一步 gitpushxxxxmaster 时，出现了新的问题：git显示无法提交，这显然不是网络的问题，原因是我在原文件夹提交了commit信息，会导致无法再次提交文件，只有在原文件夹将文件成功push上传，才能提交其他文件。 于是，正在我焦头烂额的时候，我的室友给了我指导，他让我找回到原来的文件夹，在原文件夹里重新提交了好几次，最终上传成功。 当然，对这个问题，还有其他的解决方法：需要用到pull命令： gitpull--rebasexxxxmaster （xxxx为你的仓库名） 该命令会把个人仓库里的所有文件下载到你的新本地仓库中。 
第268篇文章[]
软件构造 关于java的正则表达式 笔者在完成lab3时，正则表达式实在是造成了很大的困扰，下面就来简单介绍一下java中的正则表达式。 一个字符串其实就是一个简单的正则表达式，例如 HelloWorld 正则表达式匹配"HelloWorld"字符串。而“.”（点号）也是一个正则表达式，它匹配任何一个字符如："0"或"a"。 java.util.regex包主要包括以下三个类： Pattern类： pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher类： Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。 PatternSyntaxException： PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 在Java中，“\\”表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。在Java中，正则表达式中需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在Java的正则表达式中，两个 \\ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\。其实，类比一下C语言可以很好理解这一部分。 对于正则表达式的语法，网上有很多的参考资料，本文只是对正则表达式的匹配方式进行简单介绍，这里就不多赘述。 下面介绍Matcher类的方法，参考https://www.runoob.com/java/java-regular-expressions.html 索引方法 索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配： 序号方法及说明1publicintstart()返回以前匹配的初始索引。2publicintstart(intgroup) 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引3publicintend()返回最后匹配字符之后的偏移量。4publicintend(intgroup)返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。 查找方法 查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式： 序号方法及说明1publicbooleanlookingAt() 尝试将从区域开头开始的输入序列与该模式匹配。2publicbooleanfind()尝试查找与该模式匹配的输入序列的下一个子序列。3publicbooleanfind(intstart）重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。4publicbooleanmatches()尝试将整个区域与模式匹配。 替换方法 替换方法是替换输入字符串里文本的方法： 序号方法及说明1publicMatcherappendReplacement(StringBuffersb,Stringreplacement)实现非终端添加和替换步骤。2publicStringBufferappendTail(StringBuffersb)实现终端添加和替换步骤。3publicStringreplaceAll(Stringreplacement) 替换模式与给定替换字符串相匹配的输入序列的每个子序列。4publicStringreplaceFirst(Stringreplacement) 替换模式与给定替换字符串匹配的输入序列的第一个子序列。5publicstaticStringquoteReplacement(Strings)返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement方法一个字面字符串一样工作。 
第269篇文章[]
软件构造 关于lab3对于时间的处理 本人最近完成了lab3的实验。在完成dutyroster类（排班表）时，需要对时间进行恰当的处理。因为面向现实生活时，必须要考虑不同年份、不同月份对计算时间差天数的处理。我在完成这次实验时也是产生了很大的困扰，最终在室友的帮助下，我利用java的localDate类实现了很好的处理。 下面介绍一下localDate类，我们直接用一组代码来理解： LocalDatelocalDate=LocalDate.now()； System.out.println("localDate="+localDate);//localDate=2021-07-05，直接获取当天的信息 System.out.println("localDate="+localDate.getDayOfWeek().getValue());//获取星期几 System.out.println("localDate="+localDate.get(ChronoField.ALIGNED_WEEK_OF_MONTH));//获取当前月的第几周 System.out.println(localDate.getDayOfYear());//获取本年中截止到今天已经过去的天数 System.out.println(localDate.with(TemporalAdjusters.firstDayOfMonth()));//得到所在月的第一天 System.out.println(localDate.withDayOfMonth(3));//得到所在月的第三天 System.out.println(localDate.with(TemporalAdjusters.lastDayOfMonth()));//得到所在月的最后一天 System.out.println(localDate.plusDays(10));//得到10天后的日期 通过上面的代码，可以对localDate有简单的理解。 在lab3中，我通过(endDate.toEpochDay()-startDate.toEpochDay())的表达式，来间接获得了起止天数差。 
第270篇文章[]
软件构造 在Eclipse中进行JUnit测试 本人完成了学期的所有实验后，想起来在完成lab1时，对如何进行Junit测试没搞清楚，所以在这里详细记录一下JUnit测试的具体步骤。 首先右键工作项目，并选中最下面的properties； 然后在JavaBuildPath中选中ClassPath，并点击右侧的addliabrary 选择自己想要的JUnit版本，点击Finish 对想要测试的类新建测试用例，右键该类选择new后选择JUnitTestCase 在接下来的页面上要勾选setup点击next，并给自己想要进行测试的方法打勾。 点击Finish，即可看到生成的测试用例，之后就可以自己进行编写改动。 
第271篇文章[]
HIT软件构造Lab1记录 目录 2实验环境配置 3实验过程 3.1MagicSquares 3.1.1isLegalMagicSquare() 3.1.2generateMagicSquare() 3.2TurtleGraphics 3.2.1Problem1:Cloneandimport 3.2.2Problem3:TurtlegraphicsanddrawSquare 3.2.3Problem5:Drawingpolygons 3.2.4Problem6:CalculatingBearings 3.2.5Problem7:ConvexHulls 3.2.6Problem8:Personalart 3.2.7Submitting 3.3SocialNetwork 3.3.1设计/实现FriendshipGraph类 3.3.2设计/实现Person类 3.3.3设计/实现客户端代码main() 3.3.4设计/实现测试用例 4实验进度记录 5实验过程中遇到的困难与解决途径 6实验过程中收获的经验、教训、感想 6.1实验过程中收获的经验和教训 6.2针对以下方面的感受 实验目标概述 本次实验通过求解三个问题，训练基本Java编程技能，能够利用JavaOO开 发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够 为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。 另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。 ⚫基本的JavaOO编程 ⚫基于EclipseIDE进行Java编程 ⚫基于JUnit的测试 ⚫基于Git的代码配置管理 实验环境配置 本实验使用了IDEA而不是pdf中给出的eclipse作为ide，不过还是通过pdf中给出的链接安装了eclipse，不过没有使用，在git官网下载了git，并在IDEA中下载了git和Junit插件，安装过程中并未出现困难 GitHubLab1仓库的URL地址： https://github.com/ComputerScienceHIT/HIT-Lab1-1190201517 实验过程 请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。 为了条理清晰，可根据需要在各节增加三级标题。 MagicSquares 幻方：对一个行列数相等的矩阵，若其每一行之和、每一列之和以及对角线之和都相等，则其为一个幻方（MagicSquare） 要求一： 设计一个程序来判断五个文件中的矩阵是否为MagicSquare，其中文件保存的矩阵需以\t分割每个数字。若是返回true，若不是或文件有错误则输出false并输出错误原因。 要求二： 设计一个函数来生成一个给定大小的MagicSquare，并存入到文件6.txt中，并用要求一中的和函数判断其是否为符合定义的MagicSquare。 isLegalMagicSquare() 对于读入的文件，构建二维数组存储其中的数字，读入过程中即可检查其行列是否相等、是否均为正整数，是否由\t分割等，若不符合定义则弹出报错终止程序。因为使用Integer.valueOf存入数组，在读取到空格时会报错，以此检验数字是否由\t分割 读入完毕后，对于得到的二维数组，计算其各行、列以及两对角线之和并依次比较，一旦发现不相等就跳出循环并返回false，若最终没有发现不相等，则返回true。 generateMagicSquare() 生成magicsquare的函数已经在手册中给出，因此我们只需检查输入的n是否合法（正奇数），不合法是终止函数返回false，合法时生成、写入文件并返回true。之后在用要求一的函数检验生成的文件即可。 TurtleGraphics 根据要求，我们要按照注释补全给定程序中缺失的特定功能的函数，来实现一个绘图工具，其能够实现绘制正多边形、计算正多边形内角、计算偏角等功能。 Problem1:Cloneandimport 从给定链接下载P2的文件包并导入项目中。 Problem3:TurtlegraphicsanddrawSquare、 通过已经给出的转向和前进指令来绘制正方形 Problem5:Drawingpolygons 绘制指定边数和边长的正多边形 Problem6:CalculatingBearings 通过给定朝向和点集，计算改变朝向的偏角值集 Problem7:ConvexHulls 利用BFS算法计算给定点集的凸包 Problem8:Personalart Submitting 通过IDEA的git插件，输入url提交至自己的github仓库中 SocialNetwork 通过Person和FriendshipGraph两个类，用FriendshipGraph模拟Person对象间的社交关系，实现对社交网络的模拟，并实现计算两个Person之间的最短社交距离的功能。 设计/实现FriendshipGraph类 存储网络中的person以及person的全部name 加入新用户时，检测是否有重名，若重名终止程序 通过person类中的操作实现addEdge 使用有向图的BFS算法计算两点的最短距离。 主函数部分实现了手册中给出的代码 运行结果： 设计/实现Person类 Person类代码如下 Person类包含了用户姓名以及人际关系，通过List保存每个对象的朋友以表现朋友关系，因此通过向List中添加元素实现addFriend的功能。 设计/实现客户端代码main() 设计/实现测试用例 通过三个测试用例，检验程序的添加用户、添加用户关系、计算最短距离三个功能 实验进度记录 请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。 每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。 不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。 日期时间段任务实际完成情况2021-05-1113:45-15:30大致学习实验内容，编写问题1的isLegalMagicSquare函数按计划完成2021-05-20全天完成P1及P2全部内容超过凌晨几小时2021-05-23全天完成剩余内容并整理学习到内容完成 实验过程中遇到的困难与解决途径 遇到的困难解决途径对java掌握不熟练，很多方法、函数需要查阅资料，浪费了很多时间努力学习java，掌握基本代码方式对github不太了解，不清楚仓库、clone等功能是如何运作的查阅各种资料，实践理解功能 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 大概了解了java的代码、项目管理、git的版本控制、以及github的共享体系 针对以下方面的感受Java编程语言是否对你的口味？ 还可以，有时不够直观，但整体上功能更多，比c更灵活 关于EclipseIDE； 没有使用，习惯使用IDEA，今后会补充这方面的不足 关于Git和GitHub； 用得不太好，但也还行 关于CMU和MIT的作业； 很有创意，给我提供了很多思路 关于本实验的工作量、难度、deadline； 难度很适合作为第一次实验 关于初接触“软件构造”课程； 有很多不习惯的地方，但是一一克服后感觉收获颇丰 
第272篇文章[1]
HIT计算机系统大作业 程序人生 计算机系统 大作业 计算机科学与技术学院 2021年6月 摘 要 底层实现在计算机领域至关重要，而在平时又难以直观感受，观察并研究hello.c程序在Linux环境下的底层编译、执行过程，了解汇编，链接，加载，执行等过程的概念和实现原理，对今后的学习非常有帮助 关键词：计算机系统；汇编语言；预处理；编译；汇编；链接；OS； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 1.P2P：ProgramtoProgress,文本格式的hello.c文件经过cpp的预处理生成hello.i预处理文件，之后交给ccl进行编译，生成hello.s汇编文件。再将汇编文件交给as生成可重定位文件hello.o，最后经由链接器ld，生成可执行文件hello，由上述过程生成可执行目标文件。 2.O2O：FromZreo-OtoZero-O。shell执行可执行目标文件，管理hello进程，对其进行存储管理，分配映射虚拟内存、分配物理内存，输出结果到显示器，最后结束hello进程，回收其内存空间。 1.2环境与工具 1.2.1硬件环境 Intel(R)Core(TM)i7-9750HCPU@2.60GHz；16GBRAM； 1.2.2软件环境 Windows1064位；VMware：Ubuntu20.04.2LTS64位VMware 1.2.3开发工具 Vim8.1.226964位；Visualstudio201964位；CodeBlocks20.0364位 1.3中间结果 1.hello.c：C语言源文件。 2.hello.i：预处理文本文件。 3.hello.s：汇编代码文件。 4.hello.o：可重定位目标文件。 5.hello：可执行目标文件。 6.hello.asm：由hello.o反汇编生成的汇编代码。 8.hello_o.asm：由hello反汇编生成的汇编代码文本。 7.hello.elf：hello.o的elf信息文本。 9.hello_o.elf：hello的elf信息文本。 1.4本章小结 解释了P2P和O2O的概念和过程，以及本次实验的实验环境即过程中的中间文件 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 概念：预处理器根据以字符#开头的命令，修改原始的C程序，如头文件、宏定义和条件编译。生成一个.i文本文件。 作用：预处理器加入头文件、执行宏替换和条件编译。再进行正式的编译工作，便于编译的高效进行。 2.2在Ubuntu下预处理的命令 图2-1 图1-2 2.3Hello的预处理结果解析 源文件hello.c内容如下 图2-3 预处理文件hello.i内容如下 图2-4 可以看到预处理文件比源文件多出几千行，其内容为对头文件的引入： 图2-5 其中描述了各运行库在计算机中的位置： 图2-6 声明了其中用到的函数名： 图2-7 2.4本章小结 本章介绍了预处理的概念和作用，将hello.c预处理为hello.i，并对预处理结果进行了分析。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译器将预处理文本文件hello.i翻译成汇编语言文本文件hello.s，该文件用汇编语言描述了程序的内容 作用：经过词法分析，语法分析，语义分析，和一定的优化来生成可以实现对应程序功能的汇编代码文件，与高级语言相比，汇编语言更接近计算机能够理解的语言，进一步有利于二进制机器语言的生成。 3.2在Ubuntu下编译的命令 图3-1 图3-2 3.3Hello的编译结果解析 生成的hello.s文件内容如下： 图3-3 3.3.1变量的处理 全局变量：源文件中声明了全局变量sleepsecs，在汇编语言中它存放在了.data区域 图3-4 局部变量：源文件中声明了局部变量i（int类型），局部变量不在数据段表现，观察汇编文件的代码段： 图3-5 可发现源文件中的变量i作为循环条件存在，而汇编代码中参与循环判断的是-4(%rbp)，故i的值存放在该位置 图3-6 3.3.2赋值、算数操作及条件判断与跳转 赋值操作： 该步对应了源代码中i=0的操作 算数操作： 该步对应源代码中i++ 条件判断与跳转： 该步对应了源代码中判断i<10，带汇编语言中表现为判断i是否小于等于9，若是则跳转到循环内部（.L4） 3.3.3函数调用 汇编语言中用call指令实现函数调用的操作 3.3.4数组、指针 该步对应了源代码中对argv[]数组的操作，汇编代码中对数组的实现表示为对数组头加上偏移量的形式实现 3.4本章小结 本章将预处理的文本文件编译为汇编语言表示的.s文件，用以后续生成过程，并对程序中出现的汇编代码进行了解析，使其与源代码中的命令对应 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：把汇编语言翻译成机器语言的过程，形成可重定位目标文件。作用：把汇编语言一一对应地翻译成机器可以理解并直接执行的机器指令。 4.2在Ubuntu下汇编的命令 图4-1 图4-8 4.3可重定位目标elf格式 ELF头：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。 节头：指明各个节的名称、类型、起始地址和偏移量 重定位节： 重定位节记录了程序的偏移信息，使程序可以在链接后正确生成可执行文件 4.4Hello.o的结果解析 图4-9 对比反汇编结果与hello.s可知二者不同： hello.s中分支跳转语句通过跳转到目标节.L3/.L4等来表示，而反汇编文件则通过直接跳转到对应目标地址来实现分支跳转hello.s中函数调用通过call对应函数名实现，而反汇编文件通过call对应函数所在地址来实现hello.s中可以通过直接访问数据段来访问全局变量，而反汇编文件中数据段位置不确定，故需要借助重定位信息进行访问 4.5本章小结 本章将汇编语言文件汇编为可重定位目标文件hello.c，并查看了elf头，分析了elf头中各节的作用，并通过反汇编了解了机器语言的底层实现 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：链接器把多个可重定位文件链接成一个完整的可执行文件。 作用：链接可以在编译、汇编、加载和运行时执行。链接方便了模块化编程。 5.2在Ubuntu下链接的命令 图5-1 图5-2 图5-3 5.3可执行目标文件hello的格式 elf头： 节头： 程序头：在hello_o.elf中没有这部分内容 重定位节: 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明 init:0x00401000 .text:0x004010d0 5.5链接的重定位过程分析 hello.asm中多出的段包括： .interp：保存ld.so的路径 .note.ABI-tag .note.gnu.build-i：编译信息表 .gnu.hash：gnu的扩展符号hash表 .dynsym：动态符号表 .dynstr：动态符号表中的符号名称 .gnu.version：符号版本 .gnu.version_r：符号引用版本 .rela.dyn：动态重定位表 .rela.plt：.plt节的重定位条目 .init：程序初始化 .plt：动态链接表 .fini：程序终止时需要的执行的指令 .eh_frame：程序执行错误时的指令 .dynamic：存放被ld.so使用的动态链接信息 .got：存放程序中变量全局偏移量 .got.plt：存放程序中函数的全局偏移量 .data：初始化过的全局变量或者声明过的函数 5.6hello的执行流程 加载程序： ld-2.27.so!_dl_start ld-2.27.so!_dl_init hello!_start callmain： libc-2.27.so!__libc_start_main hello!main hello!puts@pl 终止： exit 5.7Hello的动态链接分析 由elf文件可知.got.plt的地址 图5-8 使用edb查看运行前GOTPLT表的内容 图5-9 运行dl_start和dl_init后GOTPLT表内容发生变化 图5-10 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 5.8本章小结 本章通过链接成功生成了可执行的目标文件，并介绍了动态链接库等内容 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、以及打开文件描述符的集合。 作用：进程给应用程序提供的关键抽象有两种： a)一个独立的逻辑控制流，提供一个假象，程序独占地使用处理器。 b)一个私有的地址空间，提供一个假象，程序在独占地使用系统内存。 6.2简述壳Shell-bash的作用与处理流程 shell是用户与系统交互作用界面。Shell是一个命令解释程序，也是一种程序设计语言。 1.读入命令行、注册相应的信号处理程序、初始化进程组。 2.通过paraseline函数解释命令行，如果是内置命令则直接执行，否则阻塞信号后创建相应子进程，在子进程中解除阻塞，将子进程单独设置为一个进程组，在新的进程组中执行子进程。父进程中增加作业后解除阻塞。如果是前台作业则等待其变为非前台程序，如果是后台程序则打印作业信息。 6.3Hello的fork进程创建过程 intfork(void)函数： 子进程返回0，父进程返回子进程的PID 新创建的子进程几乎但不完全与父进程相同： 子进程得到与父进程虚拟地址空间相同的（但是独立的）一份副本。 子进程获得与父进程任何打开文件描述符相同的副本。 子进程有不同于父进程的PID fork()调用一次，返回两次。 在shell中如果fork返回值小于0，说明fork时出现了一些问题这时需要进行处理。否则就成功创建了子进程。 6.4Hello的execve过程 调用fork函数之后，子进程将会调用execve函数，来运行hello程序，如果成功调用则不再返回，若未成功调用则返回-1。 完整的加载运行hello程序需要以下几个步骤 首先加载器会删除当前子进程虚拟地址端。，然后创建一组新的代码、数据、堆端，并初始化为0。 接着映射私有区域和共享区域，将新的代码和数据段初始化为可执行文件中的内容 最后设置程序计数器，使其指向代码区的入口，下一次调度这个进程时，将直接从入口点开始执行 6.5Hello的进程执行 Linux系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制。子进程通过execve系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片(chunk),新的代码和数据段袚初始化为可执行文件的内容。最后，加载器跳转到_start地址，它最终会调用应用程序的main函数。 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 6.6hello的异常与信号处理 1.可能出现的异常 中断：来自I/O设备的信号。比如输入CTRL-C或者CTRL-Z 陷阱：有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。 故障是由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。 终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程序会将控制返回给一个abort例程，该例程会终止这个应用程序。 2.可能产生的信号：SIGINT,SIGSTP,SIGCONT,SIGWINCH等 3．异常处理：3.1:运行过程中按CTRL-C，给进程发送SIGINT信号，程序将被终止回收 图6-1 3.2：运行过程中按CTRL-Z，给进程发送SIGSTP信号，程序将被挂起，用fg命令，可以让程序回到前台继续运行。 图6-2 3.3：挂起中输入pstree时 图6-3 6.7本章小结 本章完成了程序从运行到结束的运行过程，体现了hello的进程管理 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：由程序产生的与段相关的偏移地址部分。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。 线性地址：地址空间中的整数是连续的。 虚拟地址：在一个带虚拟内存的系统中，CPU从一个有N=2"个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间。 物理地址：计算机系统的主存被组织成一个个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。 在hello加载进内存时会分配虚拟内存，总是从0x00401000开始 7.2Intel逻辑地址到线性地址的变换-段式管理 每个段的首地址就会被储存在各自的段描述符里面,所以的段描述符都将会位于段全局描述符表中(每个段的全局描述符表一个局部称为gdgdt和另一个局部的的段描述符表一个局部称为ldldt),通过段选择符我们可以快速寻找到某个段的段全局描述符。逻辑上段地址的偏移量结构就是段选择符+偏移量。 段选择符的索引位组成和定义如下,分别指的是索引位,ti,rpl,当索引位ti=0时,段描述符表在rpgdt中,ti=1时,段描述符表在rpldt中。而索引位index就类似一个数组,每个元素内都存放一个段的描述符,索引位首地址就是我们在查找段描述符时再这个元素数组当中的索引。一个段描述符的首地址是指含有8个元素的字节,我们通常可以在查找到段描述符之后获取段的首地址,再把它与线性逻辑地址的偏移量进行相加就可以得到段所需要的一个线性逻辑地址。 在分段保护模式下,分段有两种机制:段的选择符在段的描述符表->分段索引->目标段的段描述符条目->目标段的描述符基地址+偏移量=转换为线性段的基地址。由于现代的macosx86系统内核使用的描述符是基本扁平的逻辑模型,即目标段的逻辑地址=线性段的描述符=转换为线性段的基地址,等价于描述符转换为线性地址时关闭了偏移量和分段的功能。这样逻辑段的基地址与转换为线性段的基地址就合二为一了。 7.3Hello的线性地址到物理地址的变换-页式管理 系统将每个段分割为被称为虚拟页（VP）的大小固定的块来作为进行数据传输的单元，在linux下每个虚拟页大小为4KB，类似地，物理内存也被分割为物理页（PP/页帧），虚拟内存系统中MMU负责地址翻译，MMU使用存放在物理内存中的被称为页表的数据结构将虚拟页到物理页的映射，即虚拟地址到物理地址的映射。 7.4TLB与四级页表支持下的VA到PA的变换 将VPN分成三段，对于TLBT和TLBI来说，可以在TLB中找到对应的PPN，但是有可能出现缺页的情况，这时候就需要到页表中去找。此时，VPN被分成了更多段（这里是4段）CR3是对应的L1PT的物理地址，然后一步步递进往下寻址，越往下一层每个条目对应的区域越小，寻址越细致，在经过4层寻址之后找到相应的PPN让你和和VPO拼接起来。 7.5三级Cache支持下的物理内存访问 得到物理地址之后，先将物理地址拆分成CT（标记）+CI（索引）+CO（偏移量），然后在一级cache内部找，如果未能寻找到标记位为有效的字节（miss）的话就去二级和三级cache中寻找对应的字节，找到之后返回结果。 7.6hello进程fork时的内存映射 shell通过一个调用fork的函数让进程内核自动创建一个新的进程,这个新的进程拥有各自新的数据结构,并且被内核分配了一个唯一的pid。它有着自己独立的虚拟内存空间,并且还拥有自己独立的逻辑控制流,它同样可以拥有当前已经可以打开的各类文件信息和页表的原始数据和样本,为了有效保护进程的私有数据和信息,同时为了节省对内存的消耗,进程的每个数据区域都被内核标记起来作为写时复制。 7.7hello进程execve时的内存映射 execve函数在当前代码共享进程的上下文中加载并自动运行一个新的代码共享程序,它可能会自动覆盖当前进程的所有虚拟地址和空间,删除当前进程虚拟地址的所有用户虚拟和部分空间中的已存在的代码共享区域和结构,但没有自动创建一个新的代码共享进程。新的运行程序仍然在堆栈中拥有相同的区域pid。之后为新运行程序的用户共享代码、数据、bss和所有堆栈的区域结构创建新的共享区域和结构,新代码共享区域可能是在运行时私有的、写时复制的。它首先映射到一个共享的区域,hello这个程序与当前共享的对象libc.so链接,它可能是首先动态通过链接映射到这个代码共享程序上下文中的,然后再通过映射链接到用户虚拟地址和部分空间区域中的另一个共享代码区域内。为了设置一个新的程序计数器,execve函数要做的最后一件要做的事情就是自动设置当前代码共享进程上下文的一个程序计数器,使之成为指向所有代码共享区域的一个入口。 7.8缺页故障与缺页中断处理 段错误：首先判断这个缺页的虚拟地址是否合法，遍历所有的合法区域结构，如果对所有的区域结构都无法匹配，返回段错误。 非法访问：查看地址的权限，判断进程是否有读写权限。 若上述情况都不符合则为正常缺页，选择一个页面换入新的页面并更新到页表。 7.9动态存储分配管理 分配器通过维护虚拟内存（堆）来实现动态存储分配管理，存在两种维护方式： 隐式空闲链表：分配器检测一个已分配块何时不再被程序所使用,那么就释放这个块 显式空闲链表：每次声明内存空间都保证至少分配size_t大小的内存，双字对齐，每次必须从空闲块中分配空间，在申请空间时将空闲的空间碎片合并，以尽量减少浪费。 7.10本章小结 本章概括了进程的存储管理，介绍了了虚拟地址、物理地址、线性地址、逻辑地址的概念以及进程fork和execve的内存映射。描述了系统应对缺页异常的方法和malloc的内存分配管理机制。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 打开：open()，打开或创建目标文件。 关闭：close()，关闭文件。 读取：read()，从当前文件位置读取字节到内存中。 写入：write()，从内存复制字节到当前文件位置。 更改文件位置：lseek()，将文件位置更改为目标位置 8.3printf的实现分析 printf函数中调用了sprintf函数和write函数 sprintf函数将所有的参数内容格式化为字符串并存入buf，然后返回格式化数组长度。 write函数将buf中的元素写到终端。 vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量） 8.4getchar的实现分析 当buf为空时，getchar调用read函数，否则直接读取buf中的首元素。 read函数把整个缓冲区读到buf中，返回缓冲区长度。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章概括了Linux系统的IO管理，对IO相关函数进行了介绍和分析 （第8章1分） 结论 1.预处理源文件hello.c，将外部库合并并生成预处理文件hello.i 2.将hello.i编译为汇编语言文件hello.s 3.将汇编文件hello.s汇编为可重定位目标文件hello.o 4.将hello.o与动态链接库链接形成最终的hello可执行目标文件 5.在shell中输入命令运行目标文件hello 6.shell调用fork创建子进程 7.shell调用execve，为程序分配物理内存，映射虚拟内存，执行main函数 8.main函数执行程序命令，执行申请动态内存等操作 9.收到信号或运行完毕，程序终止，进程结束，内核回收该子进程 本次大作业是对本学习计算机系统学习内容的一次总结和回顾，运用到了课程各章节介绍的原理和方法，通过这门课我了解到计算机的底层实现原理非常重要，我们在编程中也应该更多考虑底层原理与问题，这样可以更深入地理解计算机系统 （结论0分，缺失-1分，根据内容酌情加分） 附件 1.hello.c：C语言源文件。 2.hello.i：预处理文本文件。 3.hello.s：汇编代码文件。 4.hello.o：可重定位目标文件。 5.hello：可执行目标文件。 6.hello.asm：由hello.o反汇编生成的汇编代码。 8.hello_o.asm：由hello反汇编生成的汇编代码文本。 7.hello.elf：hello.o的elf信息文本。 9.hello_o.elf：hello的elf信息文本。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1]Linux命令（65） ld命令.https://blog.csdn.net/K346K346/article/details/89088652 [2]分段和分页内存管理.https://blog.csdn.net/sinat_31135199/article/details/73605628 [3][转]printf函数实现的深入剖析.https://www.cnblogs.com/pianist/p/3315801.html [4]RandalE.Bryant,DavidR.O’Hallaron著，龚奕利，贺莲译深入理解计算机系统[M].北京：机械工业出版社，2016.7. （参考文献0分，缺失-1分） 
第273篇文章[]
软件构造学习笔记 数据类型与类型检验 数据类型 基本数据类型:只有值，没有ID(与其他值无法区分) 在栈中分配内存 代价低 不可变 int,long,boolean,double,char 对象数据类型:既有ID，也有值 在堆中分配内存 代价昂贵 可变\不可变 String,BigInteger 对象类型形成层次结构：继承关系（extends） 重载 同样的操作名可用于不同的数据类型 类型转换 inta=2;//a=2 doublea=2;//a=2.0(Implicit) inta=(int)18.7;//a=18double a=(double)2/3;//a=0.6666… Mutability与Immutability 改变一个变量：将该变量指向另一个值的存储空间 改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。 Immutability不变性 不变性：重要设计原则 不变数据类型：一旦被创建，其值不能改变 如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变 final：final类无法派生子类 final变量无法改变值/引用 final方法无法被子类重写 不变对象：一旦被创建，始终指向同一个值/引用 可变对象：拥有方法可以修改自己的值/引用 String是不可变的 StringBuilder是可变的 使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，不可变类型更“安全”，在其他质量指标上表现更好 可变类型最少化拷贝以提高效率，使用可变数据类型，可获得更好的性能 Snapshot 用于描述程序运行时的内部状态，便于程序员之间的交流，刻画各类变量随时间变化，解释设计思路 基本类型的值 对象类型的值 不可变对象：用双线椭圆 不可变的引用：用双线箭头 引用是不可变的，但指向的值却可以是可变的，可变的引用，也可指向不可变的值 
第274篇文章[]
软件构造学习笔记 软件构造的多维度视图 Build-time:软件的构造阶段。 Code-level:代码的逻辑组织。源代码如何被方法、函数、类和接口等底层模块组织起来，以及其中代码之间的依赖关系。 Component-level：代码的物理组织。代码块之间的关系，如文件、包等。 Momentview:特定时刻的软件形态。 Periodview:软件形态随时间的变化。 (1)Build-time,moment,andcode-levelview 词汇层面：Lexical-orientedsourcecode 半结构化：近乎自然语言的风格+遵循特定的编程语法 语法层面：Syntax-orientedprogramstructure:e.g.,AbstractSyntaxTree(AST) AST：彻底结构化，将源代码变为一棵树，对树做各种操作=对源代码的修改 语义层面：Semantics-orientedprogramstructure:e.g.,ClassDiagram 语义：源代码具体想实现什么目标？源代码 >现实世界 用于表达“需求”和“设计”思想，再转化成code 通常是图形化或形式化的 (2)Build-time,period,andcode-levelview Codechurn代码变化:Linesadded,modifiedordeletedtoafilefromoneversiontoanother (3)Build-time,moment,andcomponent-levelview 关注库（这里指静态链接库）和包，库有这几种来源：操作系统提供的库、编程语言提供的库、第三方公司提供的库以及自己积累的库。 开发者像使用编程语言指令一样使用库中的功能 操作系统提供的库 编程语言提供的库第三方公司提供的库 你自己积累的库 (4)Build-time,period,andcomponent-levelview 各项软件实体随时间如何变化 VersionControlSystem(VCS) (5)Run-time,moment,andcode-levelview 代码快照图：描述程序运行时内存里变量层面的状态 (6)Run-time,periodandcode-levelview 用日志方式记录程序执行的调用次序 (7)Run-time,moment,andcomponent-levelview DeploymentdiagraminUML (8)Run-time,period,andcomponent-levelview 事件日志：系统层面 
第275篇文章[1]
HIT计算机系统大作业 程序人生 计算机系统 大作业 计算机科学与技术学院 2021年6月 摘 要 底层实现在计算机领域至关重要，而在平时又难以直观感受，观察并研究hello.c程序在Linux环境下的底层编译、执行过程，了解汇编，链接，加载，执行等过程的概念和实现原理，对今后的学习非常有帮助 关键词：计算机系统；汇编语言；预处理；编译；汇编；链接；OS； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 1.P2P：ProgramtoProgress,文本格式的hello.c文件经过cpp的预处理生成hello.i预处理文件，之后交给ccl进行编译，生成hello.s汇编文件。再将汇编文件交给as生成可重定位文件hello.o，最后经由链接器ld，生成可执行文件hello，由上述过程生成可执行目标文件。 2.O2O：FromZreo-OtoZero-O。shell执行可执行目标文件，管理hello进程，对其进行存储管理，分配映射虚拟内存、分配物理内存，输出结果到显示器，最后结束hello进程，回收其内存空间。 1.2环境与工具 1.2.1硬件环境 Intel(R)Core(TM)i7-9750HCPU@2.60GHz；16GBRAM； 1.2.2软件环境 Windows1064位；VMware：Ubuntu20.04.2LTS64位VMware 1.2.3开发工具 Vim8.1.226964位；Visualstudio201964位；CodeBlocks20.0364位 1.3中间结果 1.hello.c：C语言源文件。 2.hello.i：预处理文本文件。 3.hello.s：汇编代码文件。 4.hello.o：可重定位目标文件。 5.hello：可执行目标文件。 6.hello.asm：由hello.o反汇编生成的汇编代码。 8.hello_o.asm：由hello反汇编生成的汇编代码文本。 7.hello.elf：hello.o的elf信息文本。 9.hello_o.elf：hello的elf信息文本。 1.4本章小结 解释了P2P和O2O的概念和过程，以及本次实验的实验环境即过程中的中间文件 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 概念：预处理器根据以字符#开头的命令，修改原始的C程序，如头文件、宏定义和条件编译。生成一个.i文本文件。 作用：预处理器加入头文件、执行宏替换和条件编译。再进行正式的编译工作，便于编译的高效进行。 2.2在Ubuntu下预处理的命令 图2-1 图1-2 2.3Hello的预处理结果解析 源文件hello.c内容如下 图2-3 预处理文件hello.i内容如下 图2-4 可以看到预处理文件比源文件多出几千行，其内容为对头文件的引入： 图2-5 其中描述了各运行库在计算机中的位置： 图2-6 声明了其中用到的函数名： 图2-7 2.4本章小结 本章介绍了预处理的概念和作用，将hello.c预处理为hello.i，并对预处理结果进行了分析。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译器将预处理文本文件hello.i翻译成汇编语言文本文件hello.s，该文件用汇编语言描述了程序的内容 作用：经过词法分析，语法分析，语义分析，和一定的优化来生成可以实现对应程序功能的汇编代码文件，与高级语言相比，汇编语言更接近计算机能够理解的语言，进一步有利于二进制机器语言的生成。 3.2在Ubuntu下编译的命令 图3-1 图3-2 3.3Hello的编译结果解析 生成的hello.s文件内容如下： 图3-3 3.3.1变量的处理 全局变量：源文件中声明了全局变量sleepsecs，在汇编语言中它存放在了.data区域 图3-4 局部变量：源文件中声明了局部变量i（int类型），局部变量不在数据段表现，观察汇编文件的代码段： 图3-5 可发现源文件中的变量i作为循环条件存在，而汇编代码中参与循环判断的是-4(%rbp)，故i的值存放在该位置 图3-6 3.3.2赋值、算数操作及条件判断与跳转 赋值操作： 该步对应了源代码中i=0的操作 算数操作： 该步对应源代码中i++ 条件判断与跳转： 该步对应了源代码中判断i<10，带汇编语言中表现为判断i是否小于等于9，若是则跳转到循环内部（.L4） 3.3.3函数调用 汇编语言中用call指令实现函数调用的操作 3.3.4数组、指针 该步对应了源代码中对argv[]数组的操作，汇编代码中对数组的实现表示为对数组头加上偏移量的形式实现 3.4本章小结 本章将预处理的文本文件编译为汇编语言表示的.s文件，用以后续生成过程，并对程序中出现的汇编代码进行了解析，使其与源代码中的命令对应 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：把汇编语言翻译成机器语言的过程，形成可重定位目标文件。作用：把汇编语言一一对应地翻译成机器可以理解并直接执行的机器指令。 4.2在Ubuntu下汇编的命令 图4-1 图4-8 4.3可重定位目标elf格式 ELF头：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。 节头：指明各个节的名称、类型、起始地址和偏移量 重定位节： 重定位节记录了程序的偏移信息，使程序可以在链接后正确生成可执行文件 4.4Hello.o的结果解析 图4-9 对比反汇编结果与hello.s可知二者不同： hello.s中分支跳转语句通过跳转到目标节.L3/.L4等来表示，而反汇编文件则通过直接跳转到对应目标地址来实现分支跳转hello.s中函数调用通过call对应函数名实现，而反汇编文件通过call对应函数所在地址来实现hello.s中可以通过直接访问数据段来访问全局变量，而反汇编文件中数据段位置不确定，故需要借助重定位信息进行访问 4.5本章小结 本章将汇编语言文件汇编为可重定位目标文件hello.c，并查看了elf头，分析了elf头中各节的作用，并通过反汇编了解了机器语言的底层实现 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：链接器把多个可重定位文件链接成一个完整的可执行文件。 作用：链接可以在编译、汇编、加载和运行时执行。链接方便了模块化编程。 5.2在Ubuntu下链接的命令 图5-1 图5-2 图5-3 5.3可执行目标文件hello的格式 elf头： 节头： 程序头：在hello_o.elf中没有这部分内容 重定位节: 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明 init:0x00401000 .text:0x004010d0 5.5链接的重定位过程分析 hello.asm中多出的段包括： .interp：保存ld.so的路径 .note.ABI-tag .note.gnu.build-i：编译信息表 .gnu.hash：gnu的扩展符号hash表 .dynsym：动态符号表 .dynstr：动态符号表中的符号名称 .gnu.version：符号版本 .gnu.version_r：符号引用版本 .rela.dyn：动态重定位表 .rela.plt：.plt节的重定位条目 .init：程序初始化 .plt：动态链接表 .fini：程序终止时需要的执行的指令 .eh_frame：程序执行错误时的指令 .dynamic：存放被ld.so使用的动态链接信息 .got：存放程序中变量全局偏移量 .got.plt：存放程序中函数的全局偏移量 .data：初始化过的全局变量或者声明过的函数 5.6hello的执行流程 加载程序： ld-2.27.so!_dl_start ld-2.27.so!_dl_init hello!_start callmain： libc-2.27.so!__libc_start_main hello!main hello!puts@pl 终止： exit 5.7Hello的动态链接分析 由elf文件可知.got.plt的地址 图5-8 使用edb查看运行前GOTPLT表的内容 图5-9 运行dl_start和dl_init后GOTPLT表内容发生变化 图5-10 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 5.8本章小结 本章通过链接成功生成了可执行的目标文件，并介绍了动态链接库等内容 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、以及打开文件描述符的集合。 作用：进程给应用程序提供的关键抽象有两种： a)一个独立的逻辑控制流，提供一个假象，程序独占地使用处理器。 b)一个私有的地址空间，提供一个假象，程序在独占地使用系统内存。 6.2简述壳Shell-bash的作用与处理流程 shell是用户与系统交互作用界面。Shell是一个命令解释程序，也是一种程序设计语言。 1.读入命令行、注册相应的信号处理程序、初始化进程组。 2.通过paraseline函数解释命令行，如果是内置命令则直接执行，否则阻塞信号后创建相应子进程，在子进程中解除阻塞，将子进程单独设置为一个进程组，在新的进程组中执行子进程。父进程中增加作业后解除阻塞。如果是前台作业则等待其变为非前台程序，如果是后台程序则打印作业信息。 6.3Hello的fork进程创建过程 intfork(void)函数： 子进程返回0，父进程返回子进程的PID 新创建的子进程几乎但不完全与父进程相同： 子进程得到与父进程虚拟地址空间相同的（但是独立的）一份副本。 子进程获得与父进程任何打开文件描述符相同的副本。 子进程有不同于父进程的PID fork()调用一次，返回两次。 在shell中如果fork返回值小于0，说明fork时出现了一些问题这时需要进行处理。否则就成功创建了子进程。 6.4Hello的execve过程 调用fork函数之后，子进程将会调用execve函数，来运行hello程序，如果成功调用则不再返回，若未成功调用则返回-1。 完整的加载运行hello程序需要以下几个步骤 首先加载器会删除当前子进程虚拟地址端。，然后创建一组新的代码、数据、堆端，并初始化为0。 接着映射私有区域和共享区域，将新的代码和数据段初始化为可执行文件中的内容 最后设置程序计数器，使其指向代码区的入口，下一次调度这个进程时，将直接从入口点开始执行 6.5Hello的进程执行 Linux系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制。子进程通过execve系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片(chunk),新的代码和数据段袚初始化为可执行文件的内容。最后，加载器跳转到_start地址，它最终会调用应用程序的main函数。 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 6.6hello的异常与信号处理 1.可能出现的异常 中断：来自I/O设备的信号。比如输入CTRL-C或者CTRL-Z 陷阱：有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。 故障是由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。 终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程序会将控制返回给一个abort例程，该例程会终止这个应用程序。 2.可能产生的信号：SIGINT,SIGSTP,SIGCONT,SIGWINCH等 3．异常处理：3.1:运行过程中按CTRL-C，给进程发送SIGINT信号，程序将被终止回收 图6-1 3.2：运行过程中按CTRL-Z，给进程发送SIGSTP信号，程序将被挂起，用fg命令，可以让程序回到前台继续运行。 图6-2 3.3：挂起中输入pstree时 图6-3 6.7本章小结 本章完成了程序从运行到结束的运行过程，体现了hello的进程管理 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：由程序产生的与段相关的偏移地址部分。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。 线性地址：地址空间中的整数是连续的。 虚拟地址：在一个带虚拟内存的系统中，CPU从一个有N=2"个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间。 物理地址：计算机系统的主存被组织成一个个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。 在hello加载进内存时会分配虚拟内存，总是从0x00401000开始 7.2Intel逻辑地址到线性地址的变换-段式管理 每个段的首地址就会被储存在各自的段描述符里面,所以的段描述符都将会位于段全局描述符表中(每个段的全局描述符表一个局部称为gdgdt和另一个局部的的段描述符表一个局部称为ldldt),通过段选择符我们可以快速寻找到某个段的段全局描述符。逻辑上段地址的偏移量结构就是段选择符+偏移量。 段选择符的索引位组成和定义如下,分别指的是索引位,ti,rpl,当索引位ti=0时,段描述符表在rpgdt中,ti=1时,段描述符表在rpldt中。而索引位index就类似一个数组,每个元素内都存放一个段的描述符,索引位首地址就是我们在查找段描述符时再这个元素数组当中的索引。一个段描述符的首地址是指含有8个元素的字节,我们通常可以在查找到段描述符之后获取段的首地址,再把它与线性逻辑地址的偏移量进行相加就可以得到段所需要的一个线性逻辑地址。 在分段保护模式下,分段有两种机制:段的选择符在段的描述符表->分段索引->目标段的段描述符条目->目标段的描述符基地址+偏移量=转换为线性段的基地址。由于现代的macosx86系统内核使用的描述符是基本扁平的逻辑模型,即目标段的逻辑地址=线性段的描述符=转换为线性段的基地址,等价于描述符转换为线性地址时关闭了偏移量和分段的功能。这样逻辑段的基地址与转换为线性段的基地址就合二为一了。 7.3Hello的线性地址到物理地址的变换-页式管理 系统将每个段分割为被称为虚拟页（VP）的大小固定的块来作为进行数据传输的单元，在linux下每个虚拟页大小为4KB，类似地，物理内存也被分割为物理页（PP/页帧），虚拟内存系统中MMU负责地址翻译，MMU使用存放在物理内存中的被称为页表的数据结构将虚拟页到物理页的映射，即虚拟地址到物理地址的映射。 7.4TLB与四级页表支持下的VA到PA的变换 将VPN分成三段，对于TLBT和TLBI来说，可以在TLB中找到对应的PPN，但是有可能出现缺页的情况，这时候就需要到页表中去找。此时，VPN被分成了更多段（这里是4段）CR3是对应的L1PT的物理地址，然后一步步递进往下寻址，越往下一层每个条目对应的区域越小，寻址越细致，在经过4层寻址之后找到相应的PPN让你和和VPO拼接起来。 7.5三级Cache支持下的物理内存访问 得到物理地址之后，先将物理地址拆分成CT（标记）+CI（索引）+CO（偏移量），然后在一级cache内部找，如果未能寻找到标记位为有效的字节（miss）的话就去二级和三级cache中寻找对应的字节，找到之后返回结果。 7.6hello进程fork时的内存映射 shell通过一个调用fork的函数让进程内核自动创建一个新的进程,这个新的进程拥有各自新的数据结构,并且被内核分配了一个唯一的pid。它有着自己独立的虚拟内存空间,并且还拥有自己独立的逻辑控制流,它同样可以拥有当前已经可以打开的各类文件信息和页表的原始数据和样本,为了有效保护进程的私有数据和信息,同时为了节省对内存的消耗,进程的每个数据区域都被内核标记起来作为写时复制。 7.7hello进程execve时的内存映射 execve函数在当前代码共享进程的上下文中加载并自动运行一个新的代码共享程序,它可能会自动覆盖当前进程的所有虚拟地址和空间,删除当前进程虚拟地址的所有用户虚拟和部分空间中的已存在的代码共享区域和结构,但没有自动创建一个新的代码共享进程。新的运行程序仍然在堆栈中拥有相同的区域pid。之后为新运行程序的用户共享代码、数据、bss和所有堆栈的区域结构创建新的共享区域和结构,新代码共享区域可能是在运行时私有的、写时复制的。它首先映射到一个共享的区域,hello这个程序与当前共享的对象libc.so链接,它可能是首先动态通过链接映射到这个代码共享程序上下文中的,然后再通过映射链接到用户虚拟地址和部分空间区域中的另一个共享代码区域内。为了设置一个新的程序计数器,execve函数要做的最后一件要做的事情就是自动设置当前代码共享进程上下文的一个程序计数器,使之成为指向所有代码共享区域的一个入口。 7.8缺页故障与缺页中断处理 段错误：首先判断这个缺页的虚拟地址是否合法，遍历所有的合法区域结构，如果对所有的区域结构都无法匹配，返回段错误。 非法访问：查看地址的权限，判断进程是否有读写权限。 若上述情况都不符合则为正常缺页，选择一个页面换入新的页面并更新到页表。 7.9动态存储分配管理 分配器通过维护虚拟内存（堆）来实现动态存储分配管理，存在两种维护方式： 隐式空闲链表：分配器检测一个已分配块何时不再被程序所使用,那么就释放这个块 显式空闲链表：每次声明内存空间都保证至少分配size_t大小的内存，双字对齐，每次必须从空闲块中分配空间，在申请空间时将空闲的空间碎片合并，以尽量减少浪费。 7.10本章小结 本章概括了进程的存储管理，介绍了了虚拟地址、物理地址、线性地址、逻辑地址的概念以及进程fork和execve的内存映射。描述了系统应对缺页异常的方法和malloc的内存分配管理机制。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 打开：open()，打开或创建目标文件。 关闭：close()，关闭文件。 读取：read()，从当前文件位置读取字节到内存中。 写入：write()，从内存复制字节到当前文件位置。 更改文件位置：lseek()，将文件位置更改为目标位置 8.3printf的实现分析 printf函数中调用了sprintf函数和write函数 sprintf函数将所有的参数内容格式化为字符串并存入buf，然后返回格式化数组长度。 write函数将buf中的元素写到终端。 vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量） 8.4getchar的实现分析 当buf为空时，getchar调用read函数，否则直接读取buf中的首元素。 read函数把整个缓冲区读到buf中，返回缓冲区长度。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章概括了Linux系统的IO管理，对IO相关函数进行了介绍和分析 （第8章1分） 结论 1.预处理源文件hello.c，将外部库合并并生成预处理文件hello.i 2.将hello.i编译为汇编语言文件hello.s 3.将汇编文件hello.s汇编为可重定位目标文件hello.o 4.将hello.o与动态链接库链接形成最终的hello可执行目标文件 5.在shell中输入命令运行目标文件hello 6.shell调用fork创建子进程 7.shell调用execve，为程序分配物理内存，映射虚拟内存，执行main函数 8.main函数执行程序命令，执行申请动态内存等操作 9.收到信号或运行完毕，程序终止，进程结束，内核回收该子进程 本次大作业是对本学习计算机系统学习内容的一次总结和回顾，运用到了课程各章节介绍的原理和方法，通过这门课我了解到计算机的底层实现原理非常重要，我们在编程中也应该更多考虑底层原理与问题，这样可以更深入地理解计算机系统 （结论0分，缺失-1分，根据内容酌情加分） 附件 1.hello.c：C语言源文件。 2.hello.i：预处理文本文件。 3.hello.s：汇编代码文件。 4.hello.o：可重定位目标文件。 5.hello：可执行目标文件。 6.hello.asm：由hello.o反汇编生成的汇编代码。 8.hello_o.asm：由hello反汇编生成的汇编代码文本。 7.hello.elf：hello.o的elf信息文本。 9.hello_o.elf：hello的elf信息文本。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 
第276篇文章[]
软件构造学习笔记 软件构造过程 传统软件进程模型 基础类型：线性过程、迭代过程 瀑布过程：线性推进阶段划分清楚整体推进无迭代管理简单无法适应需求增加/变化 增量过程：线性推进增量式（多个瀑布的串行）无迭代比较容易适应需求的增加 V字模型： 原型过程：迭代过程 螺旋模型：非常复杂的过程 。 多轮迭代基本遵循瀑布模式每轮迭代有明确的目标遵循“原型”过程，进行严格的风险分析方可进入下一轮迭代 敏捷开发 通过快速迭代和小规模的持续改进，以快速适应变化。 Agile=增量+迭代，每次迭代处理一个小规模增量 极限的用户参与 极限的小步骤迭代 极限的确认/验证 软件配置管理(SCM)和版本控制系统(VCS) 软件配置管理：追踪和控制软件的变化 软件配置项（SCI）：软件中发生变化的基本单元（例如：文件） 基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本） CMDB：配置管理数据库存储软件的各配置项随时间发生变化的信息+基线 Versioning版本控制 版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识” 古老的版本控制方法：通过复制文件并修改文件名 仓库：即于SCM中的CMDB 工作拷贝：在开发者本地机器上的一份项目拷贝 文件：一个独立的配置项 版本：在某个特定时间点的所有文件的共同状态 变化：即codechurn，两个版本之间的差异 HEAD：程序员正在其上工作的版本 版本控制系统（VCS） 本地版本控制系统：仓库存储于开发者本地机器，无法共享和协作 集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作 分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器 GitasanexampleofSCMtool 本地的CMDB 工作目录：本地文件系统 暂存区：隔离工作目录和Git仓库 
第277篇文章[]
软件构造Lab3记录 实验3，学期末时间太紧了，不然过程应该是挺快乐的 2实验环境配置 3实验过程 3.1待开发的三个应用场景 3.2面向可复用性和可维护性的设计：IntervalSet<L> 3.2.1IntervalSet<L>的共性操作 3.2.2局部共性特征的设计方案 3.2.3面向各应用的IntervalSet子类型设计（个性化特征的设计方案） 3.3面向可复用性和可维护性的设计：MultiIntervalSet<L> 3.3.1MultiIntervalSet<L>的共性操作 3.3.2局部共性特征的设计方案 3.3.3面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案） 3.4面向复用的设计：L 3.5可复用API设计 3.5.1计算相似度 3.5.2计算时间冲突比例 3.5.3计算空闲时间比例 3.6应用设计与开发 3.6.1排班管理系统 3.6.2操作系统的进程调度管理系统 3.6.3课表管理系统 3.7基于语法的数据读入 3.8应对面临的新变化 3.8.1变化1 3.8.2变化2 3.9Git仓库结构 4实验进度记录 5实验过程中遇到的困难与解决途径 6实验过程中收获的经验、教训、感想 6.1实验过程中收获的经验和教训 6.2针对以下方面的感受 实验目标概述 本次实验覆盖课程第2、3章的内容，目标是编写具有可复用性和可维护性 的软件，主要使用以下软件构造技术： ⚫子类型、泛型、多态、重写、重载 ⚫继承、代理、组合 ⚫语法驱动的编程、正则表达式 ⚫API设计、API复用 本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过ADT和泛型等抽象技术，开发一套可复用的ADT及其实现，充分考虑这些应用之间的相似性和差异性，使ADT有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。 实验环境配置 在这里给出你的GitHubLab3仓库的URL地址（HIT-Lab3-学号）。 实验过程 请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。 待开发的三个应用场景 （1）值班表管理（DutyRoster）：一个单位有n个员工，在某个时间段内（例如寒假1月10日到3月6日期间），每天只能安排唯一一个员工在单位值班，且不能出现某天无人值班的情况；每个员工若被安排值班m天（m>1），那么需要安排在连续的m天内。值班表内需要记录员工的名字、职位、手机号码，以便于外界联系值班员。 （2）操作系统进程调度管理（ProcessSchedule）：考虑计算机上有一个单核CPU，多个进程被操作系统创建出来，它们被调度在CPU上执行，由操作系统决定在各个时段内执行哪个线程。操作系统可挂起某个正在执行的进程，在后续时刻可以恢复执行被挂起的进程。可知：每个时间只能有一个进程在执行，其他进程处于休眠状态；一个进程的执行被分为多个时间段；在特定时刻，CPU可以“闲置”，意即操作系统没有调度执行任何进程；操作系统对进程的调度无规律，可看作是随机调度。 （2）大学课表管理（CourseSchedule）：针对某个班级，假设其各周的课表都是完全一样的（意即同样的课程安排将以“周”为单位进行周期性的重复，直到学期结束）；一门课程每周可以出现1次，也可以安排多次（例如每周一和周三的“软件构造”）且由同一位教师承担并在同样的教室进行；允许课表中有空白时间段（未安排任何课程）；考虑到不同学生的选课情况不同，同一个时间段内可以安排不同的课程（例如周一上午3-4节的“计算方法”和“软件构造”）；一位教师也可以承担课表中的多门课程。 面向可复用性和可维护性的设计：IntervalSet<L> 该节是本实验的核心部分。 IntervalSet<L>的共性操作 insert分配一个时间段给一个新的标签labels获取已分配的标签集remove移除某标签的已分配时间段start获取某标签的时间段开始时间end获取某标签的时间段结束时间 局部共性特征的设计方案 IntervalSet<L>类的设计： 创建一个Interval<L>类，每个Interval对象保存一个标签和其分配的唯一时间段 通过继承decorator的子类实现各种个性化特征设计 无重叠IntervalSet<L>： 遍历每个时间段检查是否有重叠部分 2.非空IntervalSet<L>： 当输入完成后使用函数checkNoBlank检查，该函数返回总时间轴上未分配的时间，当已经非空时返回空集 3.周期性IntervalSet<L>： 周期性并无太多特殊性，其求模、取偏移等过程在具体的应用场景中实现，不新建额外的类 面向可复用性和可维护性的设计：MultiIntervalSet<L> MultiIntervalSet<L>的共性操作 insert分配一个时间段给一个已保存的标签addlabel添加一个新的标签labels获取已分配的标签集remove移除某标签的所有已分配时间段starts获取某标签的所有时间段开始时间ends获取某标签的所有时间段结束时间delete删除一个未分配时间的标签 局部共性特征的设计方案 创建Intervals<L>，以复用IntervalSet<L>的代码，每个Intervals<L>对象保存了一个标签和其分配的所有时间段，用IntervalSet<Integer>表示 add为该标签分配一个时间段delete删除该标签的所有时间段getNum返回该标签分配的时间段个数getLabel返回标签名getStarts获取某标签的所有时间段开始时间getEnds获取某标签的所有时间段结束时间toString复用IntervalSet<L>中的toStirng方法 对于MultiIntervalSet<L>中各方法的实现： insert：复用insert代码，向label对应的Intervals<L>分配一个时间段，并使num+1 labels：遍历List<Intervals<L>>，返回所有label构成的集 remove：遍历List<Intervals<L>>，移除对应的label中的所有时间段 starts：遍历List<Intervals<L>>，找到对应label的Intervals<L>，遍历其intervalSet，返回每个时间段的intervalSet.start ends：遍历List<Intervals<L>>，找到对应label的Intervals<L>，遍历其intervalSet，返回每个时间段的intervalSet.end delete：检查对应label的Intervals<L>的num是否为0，是则从intervalsets中移除该对象 MultiIntervalSet<L>结构如下： 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）无重叠： 与IntervalSet<L>类似，相对复杂一些 非空 与IntervalSet<L>同理，调整遍历策略即可 面向复用的设计：L 对于三个实际应用，三个label分别是： Emploee： Process Course 对于每个label，重写其equals方法，只要某一唯一特征相同就返回true，如课程ID、进程ID、员工姓名（员工姓名唯一是实验手册要求，实际应用中不可能这样设计） 可复用API设计 三个API原理基本相同，策略是首先建立一个包含所有时间的List（即从开始到结束），多重遍历IntervalSet中的时间段并检查其特定条件，将符合条件的时间点从List中移除，根据List的剩余长度返回特征值，该方法时间复杂度较高，但考虑到三个应用没有太大的数据量，其实可以接受 计算相似度 计算时间冲突比例 计算空闲时间比例 应用设计与开发 利用上述设计和实现的ADT，实现手册里要求的各项功能。 应用系统已配备操作界面和文字描述，功能基本复用了上述类中的方法 排班管理系统 基本使用上述ADT实现，用户首先输入起止时间以确定范围，然后将Employee类看作IntervalSet中的label，进行相应操作，由于CommonIntervalSet类只保存已分配时间段的label，所以单独创建一个List用来存储总的职员表，在删除员工时应遍历检查其是否在IntervalSet.label中，不在即没有排班时才可以删除员工信息，时间表示上，程序的前端输入输出均使用直观的LocalDate类表示，即yyyy-mm-dd，在后端信息处理时则使用日期转换的大纪元日表示（距离某特定日期的天数，long类型），便于信息处理 添加排班记录，下图也体现了本系统的日期转换、输入模式等 添加员工信息的方法不对IntervalSet进行操作 删除员工时应检查其是否存在排班 对值班记录是否排满的检查直接复用了上述非空IntervalSet的检查方法 对于实验手册要求的随机排班功能，经实践发现如果完全随机排班，大概率出现排班时间不均的情况，甚至有时会一个人值所有班，这是不合理的，所以本系统采用了根据需值班天数和总员工数取每人需要值班的平均天数，但随机选择值班顺序的方法，这样可以尽可能公平地值班，该方法代码较长，可以在系统中进行测试，报告中不截图了 不过有一点需要注意，根据这种取平均值的方法，由于舍入问题，需要检查在只剩一人没有排班时，应将剩余天数都排给他，这会让他比别人多值最多人数-1天的班，通常这是可以接受的 主界面代码及操作截图： 操作系统的进程调度管理系统 进程管理系统使用MultiIntervalSet类和其无重叠子类实现，MultiIntervalSet类中可以存储未分配时间段的标签，所以不需要单独存储进程目录了，需要注意本程序禁止进程ID为0，现实中0号进程是系统进程，而在本系统中做此限制的原因会在后面提到 本系统需要实现的功能比较少，主要使用了三个方法： 随机进程调度randomSchedule() 在此采用的方法是通过进程ID随机选择目标，若目标已经完成则重新随机，手册中要求了系统空置的情况，为了模拟这种情况，我们额外添加了一个进程ID为0的进程，名为idle，这也是我们限制用户添加的进程ID的原因，这样在随机数取到0时就代表系统空置了，为了避免随机数取到特别大的数，我们限制空置时间为1到10的随机数，对于运行时间，我们取选择的目标程序的最长运行时间减去进程已运行时间（保存在Process类中）以内的随机一个正整数，通过MultiIntervalSet表示各个进程在时间轴上的运行记录，若运行后该进程运行时间达到最短运行时间，则标记其已经完成，之后不再选择，并且使计数器+1，当计数器等于进程数时停止系统 最短优先进程调度shortestSchedule() 该系统通过遍历选出longest–runningtime最小的进程作为目标即可，运行时间选择策略与上一个方法相同，区别是这种调度模式不再有系统空置的情况了 可视化处理visualization() 本方法在系统调度完成之后通过保存的MultiIntervalSet复现系统调度过程到用户指定的时刻，并标注各进程的状态，包括：pause暂停，stop终止（完成），running运行中，只有在用户指定时刻正在运行的进程是running状态 课表管理系统 写到这里时我发现前面的代码可以进行大量复用了，所以第三个App虽然内容不少但反而没有用大量时间 对于该系统的时间表示，由于周期性的特点我们在MultiIntervalSet中只保存0到34这段时间，从周一第一节开始，每个点代表一节课（2学时） 在排课分配时，每排一节课将该课程的已分配学时+2（保存在Course类中），当已分配满周学时时不可再为该课程排课 对于查询课表功能的实现，由于时间轴上保存的是抽象化的0到34表示上课时间，而用户输入的是yyyy-mm-dd格式的日期查询当天课程，所以需要进行转换，这里使用了Localdate中的getDayOfWeek()方法，该方法可以计算某日期当天是星期几，再根据星期几决定偏移量，比如星期一从0开始，星期二从5开始…从偏移量开始往后的五节课程，就是当天的课表，遍历MultiIntervalSet，将符合时间的课程输出即可 对于计算每周空闲时间和重复时间比例的功能，简单复用APIs.java中的方法即可实现 应对面临的新变化 变化1 值班表的改变相对比较复杂，因为我早期的设计思路有一些问题，IntervalSet和MultiIntervalSet的方法不方便相互改变，需要改动一些客户端的方法才能实现值班表从单一表到多重表的改动，代价偏大 变化2 课表系统因为不涉及多重表和单一表的转换，所以改动比较简单，只需再decorator中新增一种无重叠MultiIntervalSet并应用到客户端中即可，代价比较小 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训针对以下方面的感受重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用，你是否体会到复用的好处？ 面向ADT的编程可以使代码具有更好的可复用型，让ADT可以面向多种相似的应用场所，大量提高编程效率 重新思考Lab2中的问题：为ADT撰写复杂的specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？ 让ADT更加准确，愿意 之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？ 难处体会到了，乐趣很难说 你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？ 第一次接触，有点复杂 Lab1和Lab2的工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过三周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？ 难度主要体现在自己的设计要足够严谨，如果有功能的遗漏，后续的补救工作是灾难性的，反复思考，确认自己的设计可以应对相应场合 “抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的三个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、委派、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？ 模块化的设计思路能够大大减轻工作量，但需要时间来熟悉这种模式 关于本实验的工作量、难度、deadline。‘ 好 下周就要进行考试了，你对《软件构造》课程总体评价如何？ 面向更多实际应用，比较有意义 
第278篇文章[]
HIT软件构造Lab2记录 本次实验初看让人有点摸不着头脑，先根据模板写测试再编程的顺序在之前完全没见过，但熟悉之后发现效率很高，思路也更清晰，nice 目录 2实验环境配置 3实验过程 3.1PoeticWalks 3.1.1GetthecodeandprepareGitrepository 3.1.2Problem1:TestGraph<String> 3.1.3Problem2:ImplementGraph<String> 3.1.3.1ImplementConcreteEdgesGraph 3.1.3.2ImplementConcreteVerticesGraph 3.1.4Problem3:ImplementgenericGraph<L> 3.1.4.1Maketheimplementationsgeneric 3.1.4.2ImplementGraph.empty() 3.1.5Problem4:Poeticwalks 3.1.5.1TestGraphPoet 3.1.5.2ImplementGraphPoet 3.1.5.3Graphpoetryslam 3.1.6使用Eclemma检查测试的代码覆盖度 3.1.7Beforeyou’redone 3.2Re-implementtheSocialNetworkinLab1 3.2.1FriendshipGraph类 3.2.2Person类 3.2.3客户端main() 3.2.4测试用例 3.2.5提交至Git仓库 4实验进度记录 5实验过程中遇到的困难与解决途径 6实验过程中收获的经验、教训、感想 6.1实验过程中收获的经验和教训 6.2针对以下方面的感受 1.实验目标概述 本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说： l针对给定的应用问题，从问题描述中识别所需的ADT； l设计ADT规约（pre-condition、post-condition）并评估规约的质量； l根据ADT的规约设计测试用例； lADT的泛型化； l根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction） l使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure）； l测试ADT的实现并评估测试的覆盖度； l使用ADT及其实现，为应用问题开发程序； l在测试代码中，能够写出testingstrategy并据此设计测试用例。 2.实验环境配置 IDEA中自带覆盖率测试插件，故无需添加 在这里给出你的GitHubLab2仓库的URL地址（Lab2-学号）。https://github.com/ComputerScienceHIT/HIT-Lab2-1190201517 3.实验过程 3.1PoeticWalks 题目给出了一个graph接口，要求我们完成两个描述图的类，其中一个以边为主体，一个以点为主体，并按要求实现接口中的各种方法，最后使用完成的图抽象数据类型完成诗歌生成的功能 ​​​​​​​3.1.1 GetthecodeandprepareGitrepository 通过控制台命令建立本地git仓库，并用clone指令通过给出的url地址下载指定代码包到git仓库中 ​​​​​​​3.1.2 Problem1:TestGraph<String> 思路：首先根据接口的功能描述完成测试程序，测试程序应分别测试接口中给出的各个方法 add：对于点已存在和未存在的情况分别测试，检查输入的点是否在图中。 set：考虑多种情况：边不存在时添加，边已存在时覆盖并返回原权重，权重为0时删除边，权重为负时报错。 remove：点不存在时返回false，点存在时移除该点并返回true，移除后应检查与该点有关的边是否也被移除 vertices：检查点的添加和移除后是否均能正确返回点集 sources和targets：检查添加、移除边后能否正确返回源点集和终点集 ​​​​​​​3.1.3 Problem2:ImplementGraph<L> ​​​​​​​3.1.3.1 ImplementConcreteEdgesGraph 建立ConcreteEdgesGraph类和Egde类，Egde类表示边的状态，ConcreteEdgesGraph类实现接口功能，其中各方法功能如下表： Edge： 方法功能checkRep检查不变性getSource返回起始点getTarget返回终止点getWeight返回权重toString按“起始点-权重>终止点”的格式返回表示该边的字符串 ConcreteEdgesGraph： 方法功能checkRep检查不变性add向图中添加一个点，点的名称不可重复set向图中添加一条边，若边存在则覆盖旧边并返回旧边权重，边不存在则新建并返回0，当输入权重为0时移除该边，权重为负时报错remove移除一个点和该点连接的边，成功移除返回true，边不存在返回falsevertices返回图的所有点构成的集合sources返回图中所有作为起始点的点和其边构成的集合targets返回图中所有作为终止点的点和其边构成的集合toString将图中所有边转化为字符串返回，顺序按照边添加的顺序 ​​​​​​​3.1.3.2 ImplementConcreteVerticesGraph 建立ConcreteVerticesGraph类和Vertex类，Vertex类表示点及其连接状态，ConcreteVerticesGraph类实现接口功能，其中各方法功能如下表： Vertex： 方法功能checkRep检查不变性getVertex返回该点名称getSources返回指向该点的点集getTargets返回该点指向的点集addSources\removeSources添加、删除指向该点的边addTargets\removeTargets添加、删除该点指向的边toString按“起始点-权重>终止点”的格式返回表示该边的字符串 ConcreteVerticGraph： 方法功能checkRep检查不变性add向图中添加一个点，点的名称不可重复set向图中添加一条边，若边存在则覆盖旧边并返回旧边权重，边不存在则新建并返回0，当输入权重为0时移除该边，权重为负时报错remove移除一个点和该点连接的边，成功移除返回true，边不存在返回falsevertices返回图的所有点构成的集合sources返回图中所有作为起始点的点和其边构成的集合targets返回图中所有作为终止点的点和其边构成的集合toString将图中所有边转化为字符串返回，顺序按照点添加的顺序，每个点按边添加顺序输出以该点为起始点的边 ​​​​​​​3.1.4 Problem4:Poeticwalks 本题要求使用上述图结构，用给定的文件为文本集，连接集合中相邻的词，构建这样的图后，对任意词组成的的字符串，若串中任意两词间在图中存在一个“桥”，就将该桥插入字符串中。 ​​​​​​​3.1.4.1 TestGraphPoet 根据题目要求，需要对图的构建、字符串的插入进行测试，分情况需测试空文件、标准文件和多行文件的读入、多种权值比较的情况 ​​​​​​​3.1.4.2 ImplementGraphPoet 思路：读入文件时，按空格将文件内容按单词拆分为字符串数组，并按上述结构存入图中作为点集，并以此将相邻的单词连接，每一次相邻使权重加一。 对字符串进行插入时，检查以当前词指向的点中是否有指向下一个词的点，在所有符合条件的点中将权重和最高的点插入两词之间，按此规则遍历字符串并输出结果 ​​​​​​​3.1.4.5 使用Eclemma检查测试的代码覆盖度 ​​​​​​​3.2 Re-implementtheSocialNetworkinLab1 和Lab1中的FriendshipGraph类问题类似，只需将其中方法使用本次饰演的Graph结构实现即可 ​​​​​​ 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 本次实验遇到了时间规划不合理导致任务积压的问题，下次应为实验分配更合理的时间准备 ​​​​​​​针对以下方面的感受 1.面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？ 面向ADT编程时任务更加模块化，更好理清思路，对项目管理也有很大帮助 2.使用泛型和不使用泛型的编程，对你来说有何差异？ 使用泛型编程可以增加程序的泛用性，但因为此前用的不多，有些不熟悉，需要时间理解 3.在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？ 使测试不受程序影响，更具客观准确性，目前还不太适应 4.P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？ 提高了工作效率，使代码具备复用性 5.为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？ 保证了代码的安全性 6.关于本实验的工作量、、deadline。 适中，很合适 7.《软件构造》课程进展难度到目前，你对该课程有何体会和建议？ 这门课程更多偏向于实际应用中的项目管理、软件开发等方面，更贴近实际而不是理论 
第279篇文章[2]
信息安全概论复习笔记 目录 1.信息安全体系架构 2.密码体制的五要素 3.仿射密码 4.数据加密标准DES的算法结构和特点 5.公钥密码的思想（数学描述） 6.离散对数问题 7.Diffie-Hellman密钥交换协议 8.RSA公钥算法 9.散列函数的特点和作用 10.EMI、EMC、防电磁泄漏主要方法 11.容错与容灾的概念及主要技术方法 12.windows的网络认证 13.利用公开密钥和对称密钥设计认证协议获得会话密钥 14.Kerberos工作原理 15.PKI的体系结构及工作原理 16.访问控制的概念 17.DAC、MAC、RBAC的工作原理及特点 18.Windows安全体系结构、活动目录与组策略 19.传统病毒、蠕虫、木马的结构原理 20.拒绝服务攻击、缓冲区溢出、举例 21.防火墙主要技术概述 22.Netfilter／iptables的工作原理 23.基于网络和基于主机的入侵检测系统的优缺点 24.snorts的工作原理 25.IPSEC协议的体系结构 26.传输方式和隧道方式的区别 27.SSL握手协议 28.双签名技术原理（DS） 29.DRM结构原理 30.数字水印的工作原理 31.cc与bs7799的区别 32.风险评估的主要方法 33.网络安全法（非教材） 34.等级保护2.0（非教材） 35.工程伦理道德 1.信息安全体系架构 面向目标的知识体系结构：CIA三元组（机密性，完整性，可用性） 面向应用的层次型技术体系架构：人员（管理安全），信息（内容安全，数据安全），系统（运行安全，物理安全） 面向过程的信息安全保障体系：PDRR（保护，检测，反应，恢复） OSI开放系统互连安全体系结构：安全服务（鉴别服务，访问控制，数据完整性，数据机密性，抗抵赖性），安全机制（加密，数字签名，访问控制，数据完整性，鉴别交换，业务流填充，路由控制，公证），OSI参考模型（物理层，链路层，网络层，传输层，会话层，表示层，应用层） 2.密码体制的五要素 M,C,K,E,D M可能明文的有限集，称为明文空间 C可能密文的有限集，称为密文空间 K是一切可能密钥构成的有限集，称为密钥空间 E为加密算法，对于密钥空间的任一密钥加密算法都能够有效的计算 D为解密算法，对于密钥空间的任一密钥解密算法都能够有效的计算 3.仿射密码 加密变换Ek(m)=(k1m+k2)modq 密钥(k1,k2)k1,k2∈{0,q},且k1和q是互素的。 解密算法Dk(c)=k1-1(c-k2)modq 例题 4.数据加密标准DES的算法结构和特点 DES是一种对二进制数据进行分组加密的算法，它以64位为分组对数据，DES的密钥也是长度为64位的二进制数，其中有效位数为56位（因为每个字节第8位都用作奇偶校验），加密算法与解密算法很相似，唯一的区别在于子密钥的使用顺序正好相反。DES的整个密码体制是公开的，系统的安全性完全依赖于密钥的保密性。 DES的算法的过程是在一个初始置换IP后，明文组被分成左半部分和右半部分，输入到复合函数fk中，重复16轮迭代变换，将数据与密钥结合起来。16轮后，左，右两部分在连接起来，经过一个初始逆置换IP-1算法结束。在密钥的使用上，将64位密钥中的56位有效位经过循环位移和置换产生16个子密钥，用于16轮复合函数fk的变换。 5.公钥密码的思想（数学描述） 如果函数f(x)被称为单向陷门函数，必须满足以下三个条件。 给定x，计算y=f(x)是容易的 给定y，计算x使y=f(x)是困难的（所谓计算x=f-1(y)困难是指计算上相当复杂，已经无实际意义） 存在σ，已知σ时对给定的任何y，若相应的x存在，则计算x使y=f(x)是很容易的。 6.离散对数问题 若a是素数p的一个原根，则相对于任意整数b(bmodp!=0),必然存在唯一的整数i（1<=i<=p-1），使得b=aimodp,i称为b的以a为基数且模p的幂指数，及离散对数。 7.Diffie-Hellman密钥交换协议 Alice和Bobby协商好一个大的素数p和大的整数g，1<g<p，g是p的原根。P和g无须保密，可为网络上的所有用户共享。当Alice和Bob要进行信息保密通信时，它们可以按照如下步骤来做。 Alice选取大的随机数x<p,并计算Y=gx(modP)Bob选取大的随机数x’=gx’(modP)Alice将Y传送给Bob，Bob将Y’传送给AliceAlice计算K=(Y’)X(modP),Bob计算K’=(Y)x’(modP) 此时K=K’=gxx’(modP)，即Alice和Bob已经获得了相同的秘密值K。双方以K作为加解密钥，以传统对称密钥算法进行保密通信。 8.RSA公钥算法 RSA密钥生成步骤： 选择两个互异的素数p和q，计算n=pq,ϑ(n)=(p-1)(q-1)。选择整数e，使gcd(ϑ(n),e)=1,且1<e<ϑ(n).计算d，使d==e-1modϑ(n),即d为模ϑ(n)下e的乘法逆元。 则公开密钥Pk={e,n}，私用密钥Sk={d,n,p,q}。当明文是m，密文为c，加密时使用公开密钥Pk，加密算法c=memodn;解密时使用私用密钥Sk，m=cdmodn。故e也称为加密指数，d被称为解密指数。 9.散列函数的特点和作用 散列函数的目的是将任意长的消息映射成一个固定长度的散列值（Hash值），也称为消息摘要。消息摘要可以作为认证符，完成消息认证。 如果使用消息摘要作为认证符，必须要求散列函数具有健壮性，可以抵抗各种攻击，使消息摘要可以代表消息原文。当消息原文产生改变时，使用散列函数求得的消息摘要必须相应的变化，这就要求散列函数具有无碰撞特性和单向性。 弱无碰撞性：散列函数h被称为是弱无碰撞的，是指在消息特定的明文空间X中，给定消息x∈X，在计算机上几乎找不到不同于x的x’，x’∈X,使得h(x)=h’(x). 强无碰撞特性：散列函数h被称为是强无碰撞的，是指计算机上难以找到与x相异的x’，满足h(x)=h’(x)，x’可以不属于X。 单向性：散列函数h被称为单向的，是指通过h的逆函数h-1来求得散列值h(x)的信息原文，在计算上不可行。 10.EMI、EMC、防电磁泄漏主要方法 电磁干扰（EMI）指一切与有用信号无关的，不希望有的或对电器即电子设备产生不良影响的电池发射。防止EMI可以从两个方面考虑，一方面要减少电子设备的电磁发射，另一方面要提高电子设备的电磁兼容性（EMC）。电磁兼容性是指电子设备在自己正常工作时产生的电磁环境，与其他电子设备之间互相不影响的电磁特性。防电磁泄漏的方法：屏蔽法，频域法，时域法。 11.容错与容灾的概念及主要技术方法 容错的基本思想是即使出现了错误，系统也可以执行一组规定的程序；或者说，程序不会因为系统中的故障而中断或被修改，并且故障也不会引起运行结果的差错。简单地说，容错就是让系统具有抵抗错误带来的能力。 容灾是针对灾害而言的。是对偶然事故的预防与恢复。 空闲设备 镜像 复现 负载均衡 12.windows的网络认证 采用对称密钥加密来完成的。每一个试图登录windows网络的用户必须是已经在主域控制器上进行了有效注册的合法用户，用户与主域控制器共享口令，在域控制器的安全用户管理数据库中保存注册用户的用户名，口令的散列即其他信息。 用户首先激活Winlogon窗口，并输入用户名与口令，然后向域控制器发送登录请求，同时计算出口令的散列，口令及其散列不包含在登录请求信息中。域控制器收到登录请求后产生一个8字节的质询并发送给客户端，同时取出给用户的口令散列，用此口令散列对质询进行散列计算，得到质询散列。客户端收到8字节的质询后，首先使用前边计算得到的口令散列对质询进行散列计算，得到质询散列，随后将计算出的质询散列作为应答发送给域控制器。域控制器对比其计算出的质询散列和用户应答回送的质询散列，如果系统则登录认证通过，否则登录认证失败，同时向用户发送登录验证结果。 13.利用公开密钥和对称密钥设计认证协议获得会话密钥 对称密钥：挑战 应答A->B:IDa|IDbB->A:NbA->B:Ek(Nb) 公开密钥:不会A->B:EKub[IDa||Ra]B->A:EKua[Ra||Rb]A->B:EKub[Rb] 14.Kerberos工作原理 第三方认证服务，通过传统的共享密码技术来执行认证服务，每个用户或应用服务器均与Kerberos分享一个对称密钥。Kerberos由两个部分构成，分别是AS和TGS。Kerberos提供的认证服务，允许一个用户通过交换加密消息在整个网络上与另一个用户或应用服务器互相证明身份，一旦身份得以认证，Kerberos向通信双方提供对称密钥，对方进行安全通信对话。在Kerberos体系中，票据Ticket是客户端访问服务器时，提交的用于证明自己的身份，并可传递通信会话密钥的认证资料。AS负责签发访问TGS服务器的票据，TGS负责签发访问其他应用服务器的票据。 身份验证服务交换：完成身份验证，获得访问TGS的票据。 票据授予服务交换：获得访问应用服务器的数据。 客户与服务器身份验证交换：获得服务 15.PKI的体系结构及工作原理 利用公钥理论和技术建立的提供安全服务的基础设施，PKI采用数字证书技术来管理公钥，通过第三方的可信任机构 CA认证中心把用户的公钥和用户的其他标识消息绑在一起，在互联网上验证用户的身份。中心位置为核心技术，即公钥算法和数字证书技术，再次技术的基础上实现的PKI平台包括四个基本功能模块和一个应用接口模块。 认证机构CA 证书库 密钥备份即恢复 证书撤销处理 PKI应用接口 16.访问控制的概念 访问控制技术就是用来管理用户对系统资源的访问，对提高信息系统的安全性起到至关重要的作用。针对越权使用资源的防御措施，从而使系统资源在合法的范围内使用。 17.DAC、MAC、RBAC的工作原理及特点 自主访问控制模型（DAC）允许合法用户以用户或用户组的身份来访问系统控制策略许可的客体，同时阻止非授权用户访问客体，某些用户还可以自主的把自己所拥有的客体的访问权限授予其他用户。访问控制表，访问控制能力表，访问控制矩阵。 强制访问控制（MAC）是一种多级访问控制策略，系统事先给访问主体和受控客体分配不同的安全级别属性，在实施访问控制时，系统先对访问主体和受控客体的安全级别属性进行比较，在决定访问主体是否访问该受控客体。向下读，向上读，向下写，向上写。 基于角色的访问控制（RBAC）将访问权限分配给一定的角色，用户通过饰演不同的角色获得角色所拥有的访问许可权。最小特权原则，最小泄露原则，多级安全策略。 18.Windows安全体系结构、活动目录与组策略 Windows系统采用的是层次性的安全架构，整个安全架构的核心是安全策略，完整的安全策略决定了系统的安全性。安全策略明确了系统各个安全组件如何协调工作，Windows系统安全开始于用户认证，他是其他安全机制能够有效实施的基础，处于安全构架的最外层，加密和访问控制处于用户认证之后，是保证系统安全的主要手段，加密保证了系统与用户之间的通信即数据存储的机密性；访问控制则维护了用户访问的授权原则。审计和管理处于系统的内核层，负责系统的安全配置和事故处理，审计可以发现系统是否曾经遭受过攻击或者正在遭受灾难，并进行追查；管理则是为用户有效控制系统提供功能接口。 活动目录（AD）目录服务，它存储了有关网络对象的信息，并让管理员和用户能够轻松的查找和使用这些信息。功能基于目录的用户和资源管理，基于目录的网络服务，基于网络的应用管理。 组策略（GP）依据特定用户或计算机的安全需求制定的安全配置规则。 19.传统病毒、蠕虫、木马的结构原理 传统病毒三个模块，启动模块，传染模块，破坏模块。当系统执行力感染病毒的文件时，病毒的启动模块开始驻留在系统内存中。传染模块和破坏模块的发作均为条件触发，当满足了条件，病毒开始传染别的文件或破坏系统。 蠕虫病毒不需要寄生在宿主文件中，传播途径以计算机为载体，以网络为攻击对象，利用漏洞。主体驻留模块，传播模块。 木马是有隐藏性的，传播性的，可用来进行恶意行为的程序。一般不会对计算机产生危害，主要以控制计算机为目的。三部分，客户端，黑客用来控制远程计算机的木马程序；服务器端，是木马的核心，是潜入被感染的计算机内部，获取其操作权限的程序；木马配置程序，伪装隐藏木马程序，并确定反馈信息的传输路径。 20.拒绝服务攻击、缓冲区溢出、举例 拒绝服务攻击所表现出来的结果最终使得目标系统因遭受某种程度的破坏而不能提供正常的服务，导致物理上的瘫痪或崩溃。PingofDeath，Smurf，Teardrop，SynFlood，电子邮件炸弹。 缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖了合法数据。 21.防火墙主要技术概述 ACL：一系列允许和拒绝匹配规则的集合，利用这些规则来告诉防火墙那些数据包允许通过，那些数据包被拒绝。 静态包过滤：防火墙根据定义好的包过滤规则审查每个数据包，以便确定其是否与某一条包过滤规则匹配。 动态包过滤：采用动态配置包过滤规则的方法。 应用代理网关： 电路级网关： NAT：私有地址->合法IP地址的技术 VPN：通过公用网络建立一个临时的，安全的连接。 22.Netfilter／iptables的工作原理 设计思想是采用两层结构，处于内核层的Netfilter组件是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤的规则集。Iptables组件位于用户层，是一种管理包过滤规则的规则，可以完成插入，修改和删除包过滤的规则。 23.基于网络和基于主机的入侵检测系统的优缺点 基于主机的入侵检测系统优点：性价比高，不需要增加专门的硬件平台，当主机数量较少时性价比尤其突出；准确率高，主要监测用户在系统中的行为活动，这些行为能够准确的反映系统实时的状态，便于区分正常的行为和非法行为；对网络流量不敏感，不会因为网络流量的增加而丢掉对网络行为的监视；适合加密环境下的入侵检测。缺点：与操作系统平台相关，可移植性差；需要在每个被检测主机上安装入侵检测系统，维护比较复杂；难以检测针对网络的攻击。 基于网络的入侵检测系统优点：对用户透明，隐蔽性好，使用便捷，不容易遭受来自网络上的攻击；与被检测的系统平台无关；利用独立的计算机完成检测工作，不会给运行关键业务的主机带来负载上的增加；攻击者不易转移证据。缺点：无法检测到来自网络内部的攻击及内部合法用户的误用行为；无法分析所传输的加密数据报文；需要对所有的网络报文进行采集分析，主机的负荷比较大，且易受DoS攻击。 24.snorts的工作原理 一种网络入侵检测系统，包括数据包捕获模块，预处理模块，检测引擎和输出模块四部分。数据包捕获模块，将数据包从网络适配器中以原始状态捕获，并提交给预处理模块；预处理程序对数据包进行解码，检查及相关处理后将它们交给检测引擎；检测引擎对每个包进行检验以判断是否存在入侵；最后输出模块根据检测引擎的结果给出相应的输出，即写日志或报警。 25.IPSEC协议的体系结构 包括两个基本协议，分别封装安全有效负荷协议（ESP）和认证头协议（AH）。这两个协议的有效工作依赖于四个要件，分别为加密算法，认证算法，解释域以及密钥管理。 26.传输方式和隧道方式的区别 在传输模式下，AH和ESP主要对上一层的协议提供保护，只对IP数据包的有效负载进行加密或认证，继续使用之前的IP头部，只对IP头部的部分域进行修改，而IPSec协议头部插入到IP头部和传输层头部之间；在隧道模式下，AH和ESP则用于封装整个IP数据报文，对整个IP数据包进行加密或认证，此时需要产生新的IP头部，IPSec头部被放置在新产生的IP头部和以前的IP数据包之间，从而组成一个新的IP头部。 27.SSL握手协议 报文格式：类型（1），长度（3），内容（>=1） 通过在客户端和服务器之间传递消息报文，完成协商谈判。 四个阶段：建立起安全能力；服务器认证与密钥交换；客户端认证与密钥交换；结束； 28.双签名技术原理（DS） 将OI与PI这两个部分的摘要绑定在一起，确保交易的有效性与安全性。同时分离OI与PI，确保商家不知道顾客的支付卡信息，银行不知道顾客的订购细节。 29.DRM结构原理 分为服务器和客户端两个部分。服务器主要功能是管理版权文件的分发与授权。客户端的主要功能是依据受版权保护文件提供的信息申请授权许可证，并依据授权许可信息解密受保护文件，提供给客户使用。 30.数字水印的工作原理 一般包括三个基本方面：水印的形成，水印的嵌入和水印的检测。水印的形成是指选择有意义的数据，以特定的方式形成水印信息。水印的嵌入分为输入，嵌入处理与输出三部分，输入包括原始宿主文件，水印信息与密码；嵌入处理的主要任务是对原始文件进行分析选择嵌入点，将水印信息以一种特定的方式嵌入到一个或多个嵌入点，在整个过程中可能需要密码参与。输出是指将处理的数据整理为带有水印的信息文件。水印的检测分为两个工作，分别为检测水印是否存在（盲水印检测和非盲水印检测）和提取水印信息。 31.cc与bs7799的区别 cc是目前最全面的评价准则，充分突出了“保护轮廓”的概念，侧重点放在系统和产品的技术指标评价上。Bs7799采用层次化形式定义了11个安全管理要素，还给出了39个主要执行目标和133个具体控制措施，明确了组织机构信息安全管理建设的内容。 32.风险评估的主要方法 基线评估 详细评估 组合评估 33.网络安全法（非教材） 2016年11月7日通过 2017年6月1日起施行 34.等级保护2.0（非教材） 2019年5月13日，网络安全等级保护制度2.0标准正式发布，同时这些标准将于12月1日正式实施，我国迈入2.0时代。 35.工程伦理道德 要有工程伦理道德 
第280篇文章[]
关于软件构造的多维度视图的总结 这部分是在软件构造课上学习的，属于记忆性内容，在此作出一个总结 按状态划分：构造时视图（build-time）运行时视图（run-time） 按动态性划分：时刻视图（moment） 阶段视图（period） 按构造对象的层次划分：代码视图（code） 构件视图（component） 下面为一些举例： Sourcecode(源代码):bulild-timemomentcode AST(抽象语法树):build-timemomentcode Interiace-Class-Attribute-Method(内部类属性方法):build-timemomentcode CodeSnapshot(代码快照):run-timemomentcode Memorydump(内存转储):run-timemomentcode Package(包):build-timemomentcomponent File(文件):build-timemomentcomponent StaticLinking(静态链接):build-timemomentcomponent TestCase(测试用例):build-timemomentcomponent BuildScript(构建脚本):build-timemomentcomponent Package(封装):run-timemomentcomponent Library(程序库):run-timemomentcomponent Dynamiclinking(动态链接):run-timemomentcomponent Configuration(配置):run-timemomentcomponent Database(数据库):run-timemomentcomponent Middleware(中间软件):run-timemomentcomponent Network(网络):run-timemomentcomponent Hardware(计算机硬件):run-timemomentcomponent CodeChurn(代码变化):build-timeperiodcode ExecutionStackTrace(执行堆栈跟踪):run-timeperiodcode Concurrentmulti-threads(并发多线程):run-timeperiodcode ConfigurationItem(配置项):build-timeperiodcomponent Version(版本):build-timeperiodcomponent Eventlog(事件日志):run-timeperiodcomponent Multi-processes(多进程):run-timeperiodcomponent Distributedprocesses(分布式进程):run-timeperiodcomponent ProcedureCallGraph(过程调用图):run-timeperiodcode&component MessageGraph(消息图):run-timeperiodcode&component 
第281篇文章[1]
程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机 学 号 班 级 学 生 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文就hello.c文件为研究对象，通过分析从hello.c到可执行文件hello，再到运行该可执行文件到该文件结束运行的一系列过程，了解计算机系统的相应知识。 关键词：计算机系统；程序一生； 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -6- 2.1预处理的概念与作用 -6- 2.2在Ubuntu下预处理的命令 -6- 2.3Hello的预处理结果解析 -6- 2.4本章小结 -7- 第3章编译 -8- 3.1编译的概念与作用 -8- 3.2在Ubuntu下编译的命令 -8- 3.3Hello的编译结果解析 -8- 3.4本章小结 -11- 第4章汇编 -12- 4.1汇编的概念与作用 -12- 4.2在Ubuntu下汇编的命令 -12- 4.3可重定位目标elf格式 -12- 4.4Hello.o的结果解析 -14- 4.5本章小结 -14- 第5章链接 -15- 5.1链接的概念与作用 -15- 5.2在Ubuntu下链接的命令 -15- 5.3可执行目标文件hello的格式 -15- 5.4hello的虚拟地址空间 -18- 5.5链接的重定位过程分析 -20- 5.6hello的执行流程 -21- 5.7Hello的动态链接分析 -22- 5.8本章小结 -23- 第6章hello进程管理 -24- 6.1进程的概念与作用 -24- 6.2简述壳Shell-bash的作用与处理流程 -24- 6.3Hello的fork进程创建过程 -24- 6.4Hello的execve过程 -25- 6.5Hello的进程执行 -25- 6.6hello的异常与信号处理 -26- 6.7本章小结 -27- 第7章hello的存储管理 -28- 7.1hello的存储器地址空间 -28- 7.2Intel逻辑地址到线性地址的变换-段式管理 -28- 7.3Hello的线性地址到物理地址的变换-页式管理 -28- 7.4TLB与四级页表支持下的VA到PA的变换 -29- 7.5三级Cache支持下的物理内存访问 -31- 7.6hello进程fork时的内存映射 -32- 7.7hello进程execve时的内存映射 -32- 7.8缺页故障与缺页中断处理 -33- 7.9动态存储分配管理 -36- 7.10本章小结 -37- 第8章hello的IO管理 -38- 8.1Linux的IO设备管理方法 -38- 8.2简述UnixIO接口及其函数 -39- 8.3printf的实现分析 -39- 8.4getchar的实现分析 -39- 8.5本章小结 -40- 结论 -40- 附件 -41- 参考文献 -42- 第1章概述 1.1Hello简介 P2P：用C语言写出hello.c文件（Program），经过预处理器（ccp），编译器（ccl），汇编器（as）的预处理编译汇编分别生成.i，.s，.o文件，最后经过链接器链接可执行文件。在Bash中，进程管理（OS）利用fork生成子程序（Process）。 020：在输入hello的运行命令后，shell利用fork生成子进程，再利用execve加载。经历访存，内存分配等进程结束后被回收。 1.2环境与工具 软件：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位。 硬件：X64CPU；2GHz；2GRAM；256GHDDisk以上 开发及调试工具：Codeblocksgcccppedb 1.3中间结果 文件名字描述hello.i修改了的源程序(文本）hello.s汇编程序(文本）hello.o可重定位目标程序(二进制）hello.txthello.o的ELF格式objdump.txthello.o的反汇编文件hello可执行目标文件helloelf.txthello的ELF格式diff.txt分析hello与hello.o的不同的文本文件。 1.4本章小结 通过第一章的描述，使我们了解了在整个研究过程中，hello的FromProgramtoProcess与FromZero-0toZero-0的基本过程。还了解了本次研究所需要的硬件软件与开发调试工具和本次研究的中间结果，让我们对本次研究有了基本的了解。 第2章预处理 2.1预处理的概念与作用 2.1.1预处理的概念 预处理阶段。预处理器（CPP)根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件扩展名。 2.1.2预处理的作用 扩展源代码，插人所有用include命令指定的文件，并扩展所有声明指定的宏。 2.2在Ubuntu下预处理的命令 预处理命令：cpphello.c>hello.i生成.i文件。 2.3Hello的预处理结果解析 .i文件： 生成了三千余行的文本文件，将所有用include命令指定的文件与所有声明指定的宏插入。 例如在.i文件中插入的stdio.h头文件中的一部分。 该部分在stdio.h头文件中也存在。 文件最后的部分与.c文件相同。 2.4本章小结 本章就预处理操作，使我了解了预处理的概念与作用，预处理的命令与预处理结果。 第3章编译 3.1编译的概念与作用 3.1.1编译的概念 编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。 3.1.2编译的作用 编译是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。 3.2在Ubuntu下编译的命令 gcc-Shello.c-ohello.s生成.s文件 3.3Hello的编译结果解析 3.3.1编译结果 .s文件： 3.3.2数据 常量： 字符串常量存储在.text段中 例如代码中的printf中的两个字符串。 变量： 局部变量存储在堆栈段。 例如代码中的inti存储在栈的-4(%rbp)中，大小为4个字节。 例如代码中的argc存储在edi中 初始化的全局变量存储在数据段（.data段）。 例如代码中的intsleepsecs=2.5。 可以看到sleepsecs在.data段中。 赋值： mov例如给i赋值为0。 3.3.3类型转换 隐式： 例如代码中的intsleepsecs=2.5隐式类型转换。 3.3.4算术操作 例如hello中i+1表示为： 3.3.5关系操作 例如在比较i<10时： 比较i与9 例如比较argc!=3时： 比较3与argc 3.3.6数组操作 例如在访问数组argv[]时： 利用rax先后读取argv[1]与argv[2] 3.3.7控制转移 if(argc!=3)若条件成立，则跳转到L2。 for(i=0;i<10;i++)若条件不成立，则跳转到L4，否则i+1。 3.3.8函数操作 main函数：传递参数argc与argv[]存储在edi与rsi中。 printf函数： printf("Usage:Hello学号姓名！\n");传递参数为打印的字符串的首地址。利用call调用函数。 printf("Hello%s%s\n",argv[1],argv[2]);传递参数为打印的字符串的首地址。利用call调用函数。 getchar函数： 直接利用call调用。 exit函数： 利用call调用，传递参数为edi为1. Sleep函数： 传递参数eax作为sleep的参数。利用call调用 3.4本章小结 本章就编译操作的分析，使我了解了编译的概念与作用，编译的命令与Hello的编译结果。 第4章汇编 4.1汇编的概念与作用 汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatableobjectprogram)的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。 4.2在Ubuntu下汇编的命令 ashello.s-ohello.o产生.o文件 4.3可重定位目标elf格式 Readelf-ahello.o>hello.txt生成elf格式文件 ELF头（ELFheader)：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如X86-64)节头部表（sectionheadertable)的文件偏移，以及节头部表中条目的大小和数量。 节头部表：不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry)。 重定位节：链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输人模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输人模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 offset是需要被修改的引用的节偏移。symDol标识被修改引用应该指向的符号。type告知链接器如何修改新的引用。addend是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。 符号表：在编译时，编译器向汇编器输出每个全局符号，或者是强（strong)或者是弱（weak)，汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 4.4Hello.o的结果解析 objdump-d-rhello.o>objdump.txt 机器语言由机器指令集构成，能够直接被机器执行。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。简单来说，汇编语言是机器语言（二进制指令）的文本形式，与指令是一一对应的关系。在机器语言中，调用函数时并没有像汇编语言一样使用函数的目标地址，而是调用目标函数相对地址的下一条地址。在汇编语言中程序对不同分支进行了分段，以便访问这些分支，而机器语言调用了明确的地址。 4.5本章小结 本章就对汇编过程的分析，使我们了解了汇编的概念与作用，可重定位目标elf格式及机器语言与汇编语言的关系。 第5章链接 5.1链接的概念与作用 链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。 5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 readelf-ahello>helloelf.txt ELF头（ELFheader)：ELF头描述文件的总体格式。它还包括程序的入口点（entrypoint),也就是当程序运行时要执行的第一条指令的地址。.text.rodata和.data节与可重定位目标文件中的节是相似的。 节头部表：不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry)。 重定位节：链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输人模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输人模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 offset是需要被修改的引用的节偏移。symDol标识被修改引用应该指向的符号。type告知链接器如何修改新的引用。addend是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。 符号表：在编译时，编译器向汇编器输出每个全局符号，或者是强（strong)或者是弱（weak)，汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 动态符号表： 动态节：存储着动态链接器使用的信息。 程序头部表：ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片（chunk)被映射到连续的内存段。程序头部表（programheadertable)描述了这种映射关系。 5.4hello的虚拟地址空间 从程序头部表，我们会看到根据可执行目标文件的内容初始化两个内存段。第1行和第2行告诉我们第一个段（代码段）有读/执行访问权限，开始于内存地址0x400000处，总共的内存大小是0x76c字节，并且被初始化为可执行目标文件的头0x76c个字节，其中包括ELF头、程序头部表以及.init.text和.rodata节。 PHDR段：开始于内存地址0x400040处，总共的内存大小是0x1c0字节， 与5.3对比可以明显看出这部分存储着程序头部表。 INTERP段：开始于内存地址0x400200处，总共的内存大小是0x1c字节 可以明显看出这部分存储解释器。 NOTE:开始于内存地址0x40021c处，总共的内存大小是0x20字节 保存辅助信息。 第3行和第4行告诉我们第二个段（数据段）有读/写访问权限，开始于内存地址0x600e50处，总的内存大小为0x1f8字节，并用从目标文件中偏移0xe50处开始的.data节中的0x1f8个字节初始化。 DYNAMIC段:开始于内存地址0x600e50处，总共的内存大小是0x1a0字节 与5.3对比可以明显看出这部分存动态节的数据。 5.5链接的重定位过程分析 Objdump-d-rhello>diff.txt生成分析hello与hello.o的不同的文本文件。 链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。 hello增加了.init节与.plt节与.fini节： Hello还在增加的三个节中加入了hello所需要的_init,puts,printf,_libc_start_main,getchar,sleep,exit,.plt.got，_start,_libc_cus_init,libc_csu_fini,_fini 函数。 hello的地址较hello.s的地址发生了偏移。 重定位由两步组成： 重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输人模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输人模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。 重定位举例： 从hello的符号表中，变量sleepsecs的ADDR(symbol)=ADDR(sleepsecs)=0x600904; 从hello.o的重定位节中获取sleepsec的重定位信息type=R_X86_64_PC32，offset=0x5c,addend=-4。 在可执行文件的反汇编文件中得到ADDR(s)=ADDR(.text)=0x4004fa。 refaddr=ADDR(s)+offset=0x4004fa+0x5c=0x400556 *refptr=(unsigned)(ADDR(symbol)+addend-refaddr)=(unsigned)(0x600904–0x4-0x400556)=(unsigned)(0x2003aa)小端存储 在可执行文件的反汇编文件中对计算结果进行验证：发现计算正确 5.6hello的执行流程 _init 0x0000000000400488 _start() 0x000000000040052a __libc_start_main 0x000000000040052a __libc_csu_init() 0x0000000000400624 _init() 0x0000000000400488 main() 0x00000000004005b2 _IO_puts 0x00000000004004b5 __GI_exit 0x00000000004004e5 _fini() 0x000000000040063c _init 0x0000000000400488 _start 0x000000000040052a __libc_csu_init 0x0000000000400624 _init 0x0000000000400488 main 0x00000000004005b2 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 getchar() 0x00000000004004d5 __GI_exit 0x00000000004004e5 _fini() 0x000000000040063c 5.7Hello的动态链接分析 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接。 假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址,因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是PIC，因为它需要链接器修改调用模块的代码段，GNU编译系统使用了一种很有趣的技术来解决这个问题，称为延迟绑定(lazybinding)将过程地址的绑定推迟到第一次调用该过程时。延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：GOT和过程链接表（ProcedureLinkageTable,PLT)，如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。 可以看到.got大小为0x10，地址为0x600ff0。 可以看到.got.plt大小为0x40，地址为0x601000。 在运行dl_start前.got与.got.plt的存储如下： 在运行dl_start后.got与.got.plt的存储如下： 可以很明显的发现这些段发生了变化。 5.8本章小结 本章就链接的概念与作用，在Ubuntu下链接的命令，可执行目标文件hello的格式，hello的虚拟地址空间，链接的重定位过程分析，hello的执行流程，Hello的动态链接分析对链接进行了分析。 第6章hello进程管理 6.1进程的概念与作用 在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context)中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。每次用户通过向shell输人一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。 6.2简述壳Shell-bash的作用与处理流程 Shell是一个交互型的应用级程序，它代表用户运行其他程序。最早的shell是sh程序，后面出现了一些变种，比如csh，tcsh，ksh和bash，shell执行一系列的读/求值（read/evaluate)步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的运行的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。 fork函数只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork返回子进程的PID在子进程中，fork返回0。因为子进程的PID总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。 hello创建进程 观察hello进程 6.4Hello的execve过程 execve函数在当前进程的上下文中加载并运行一个新程序。execve函数加载并运行可执行目标文件filename,且带参数列表argv和环境变量列表envp只有当出现错误时，例如找不到filename才会返回到调用程序。所以，与fork 次调用返回两次不同，execve调用一次并从不返回。 6.5Hello的进程执行 多个流并发地执行的一般现象被称为并发（concurrency)。一个进程和其他进程轮流运行的概念称为多任务（multitasking)。一个进程执行它的控制流的一部分的每一时间段叫做时间片因此，多任务也叫做时间分片（timeslicing)。 为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。 处理器通常是用某个控制寄存器中的一个模式位（modebit)来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中（有时叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。 没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令(privilegedinstruction),比如停止处理器、改变模式位，或者发起一个I/O操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。 运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷人系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。 操作系统内核使用一种称为上下文切换(contextswitch)的较高层形式的异常控制流来实现多任务。内核为每个进程维持一个上下文（context)。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度（scheduling),是由内核中称为调度器（scheduler)的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换1)保存当前进程的上下文，2)恢复某个先前被抢占的进程被保存的上下文，3)将控制传递给这个新恢复的进程。 当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，hello中的sleep系统调用，它显式地请求让调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每1毫秒或每10毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。 6.6hello的异常与信号处理 正常运行： 可以看到程序结束后无该进程，说明上述进程被回收。 在键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程。结果是终止前台作业。 可以看到Ctrl+C后无该进程，说明上述进程被回收。 输入Ctrl+Z会发送一个SIGTSTP信号到前台进程组中的每个进程。结果是停止（挂起)前台作业。 可以看到Ctrl+Z后有进程，说明上述进程未被回收。 发现为停止（挂起)前台作业 可继续运行该进程 也可终止该进程 不停乱按键盘 进程忽略该信号 6.7本章小结 本文就hello进程管理，使我了解了进程的概念与作用，壳Shell-bash的作用与处理流程，Hello的fork进程创建过程，Hello的execve过程，Hello的进程执行，hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 物理地址：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。第一个字节的地址为0,接下来的字节地址为1，再下一个为2,依此类推。给定这种简单的结构，CPU访问内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址。 逻辑地址：这存储单元的地址就可以用段基址(段地址)和段内偏移量(偏移地址)来表示,段基址确定它所在的段居于整个存储空间的位置,偏移量确定它在段内的位置,这种地址表示方式称为逻辑地址,通常表示为段地址:偏移地址的形式。 线性地址：是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。 虚拟地址：虚拟地址是程序运行在保护模式下，这样程序访问存储器所使用的逻辑地址称为虚拟地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理（segmentation），是指把一个程序分成若干个段（segment）进行存储，每个段都是一个逻辑实体（logicalentity），程序员需要知道并使用它。它的产生是与程序的模块化直接有关的。段式管理是通过段表进行的，它包括段号或段名、段起点、装入位、段的长度等。此外还需要主存占用区域表、主存可用区域表。 7.3Hello的线性地址到物理地址的变换-页式管理 同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。 这些功能是由软硬件联合提供的，包括操作系统软件、MMU(内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表（pagetable)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。 7.4TLB与四级页表支持下的VA到PA的变换 TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。如图9-15所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有：T=2t个组，那么TLB索引（TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的。 图9-16a展示了当TLB命中时(通常情况)所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。 •第1步：CPU产生一个虚拟地址。 •第2步和第3步：MMU从TLB中取出相应的PTE •第4步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。 •第5步：高速缓存/主存将所请求的数据字返回给CPU 当TLB不命中时，MMU必须从L1缓存中取出相应的PTE,如图9-16b所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。 用来压缩页表的常用方法是使用层次结构的页表。用一个具体的示例是最容易理解这个思想的。假设32位虚拟地址空间被分为4KB的页，而每个页表条目都是4字节。还假设在这一时刻，虚拟地址空间有如下形式：内存的前2K个页面分配给了代码和数据，接下来的6K个页面还未分配，再接下来的1023个页面也未分配，接下来的1个页面分配给了用户栈。图9-17展示了我们如何为这个虚拟地址空间构造一个两级的页表层次结构。 一级页表中的每个PTE负责映射虚拟地址空间中一个4MB的片（chunk)，这里每一片都是由1024个连续的页面组成的。比如，PTE0映射第一片，PTE1映射接下来的一片，以此类推。假设地址空间是4GB，1024个PTE已经足够覆盖整个空间了。 如果片i中的每个页面都未被分配，那么一级PTEi就为空。例如，图9-17中，片2到7是未被分配的。然而，如果在片i中至少有一个页是分配了的，那么一级PTEi就指向一个二级页表的基址。例如，在图9-17中，片0、1和8的所有或者部分已被分配，所以它们的一级PTE就指向二级页表。 二级页表中的每个PTE都负责映射一个4KB的虚拟内存页面，就像我们查看只有一级的页表一样。注意，使用4字节的PTE。每个一级和二级页表都是4KB字节，这刚好和一个页面的大小是一样的。 图9-25描述了使用4级页表层次结构的地址翻译。虚拟地址被划分成为4个VPN和1个VPO。每个VPNi都是一个到第i级页表的索引，其中1<=i<=4。第j级页表中的每个PTE，1<=j<=3,都指向第j+1级的某个页表的基址。第4级页表中的每个PTE包含某个物理页面的PPN,或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN之前，MMU必须访问4个PTE。对于只有一级的页表结构，PPO和VPO是相同的。 7.5三级Cache支持下的物理内存访问 位于处理器芯片上的L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的L2高速缓存通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5到10倍。L1和L2高速缓存是用一种叫做静态随机访问存储器（SRAM)的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：LI，L2和L3系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。 在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构，如图1-9所示。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第0级或记为L0，这里我们展示的是三层高速缓存L1到L3,占据存储器层次结构的第1层到第3层。主存在第4层，以此类推。 存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID为了给这个新进程创建虚拟内存，它创建了当前进程的构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 要运行可执行目标文件hello,我们可以在Linuxshell的命令行中输入它的名字 ./hello1190201619惠羿 因为hello不是一个内置的shell命令，所以shell会认为hello是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器（loader)的操作系统代码来运行它。任何Linux程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。 虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。我们就能够理解execve函数实际上是如何加载和执行程序的。假设运行在当前进程中的程序执行了如下的execve调用： execve(“hello”,NULL,NULL); 函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤: 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。图9-31概括了私有区域的不同映射。 映射共享区域。如果hello程序与共享对象（或目标）链接，比如标准C库libc.so。那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 设置程序计数器（PC)。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的人口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 7.8缺页故障与缺页中断处理 在有些情况中，被引用的存储器位置实际上是存储在磁盘存储器上的。此时，硬件会产生一个缺页（pagefault)异常信号。同其他异常一样，这个异常会导致处理器调用操作系统的异常处理程序代码。然后这段代码会发起一个从磁盘到主存的传送操作。一旦完成，操作系统会返回到原来的程序，而导致缺页的指令会被重新执行。这次，存储器引用将成功，虽然可能会导致高速缓存不命中。让硬件调用操作系统例程，然后操作系统例程又会将控制返回给硬件，这就使得硬件和系统软件在处理缺页时能协同工作。因为访问磁盘需要数百万个时钟周期，0S缺页中断处理程序执行的处理所需的几百个时钟周期对性能的影响可以忽略不计。 从处理器的角度来看，将用暂停来处理短时间的高速缓存不命中和用异常处理来处理长时间的缺页结合起来，能够顾及到存储器访问时由于存储器层次结构引起的所有不可预测性。 故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。图8-7概述了一个故障的处理。 一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第9章中看到的那样，一个页面就是虚拟内存的一个连续的块（典型的是4KB)缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页（pagefault)，图9-6展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3,从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。 接下来，内核从磁盘复制VP3到内存中的PP3,更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图9-7展示了在缺页之后我们的示例页表的状态。 假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤： 1)虚拟地址A是合法的吗？换句话说，A在某个区域结构定义的区域内吗？为了回答这个问题，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图9-28中标识为“1”。因为一个进程可以创建任意数量的新虚拟内存区域所以顺序搜索区域结构的链表花销可能会很大。因此在实际中，Linux使用某些我们没有显示出来的字段，Linux在链表中构建了一棵树，并在这棵树上进行査找。 2)试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。这种情况在图9-28中标识为“2”。 3)此刻，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU。这次，MMU就能正常地翻译A而不会再产生缺页中断了。 7.9动态存储分配管理 虽然可以使用低级的mmap和munmap函数来创建和删除虚拟内存的区域，但是C程序员还是会觉得当运行时需要额外虚拟内存时，用动态内存分配器更方便，也有更好的可移植性。 动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap)(见图9-33)。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块（block)的集合来维护。每个块就是一个连续的虚拟内存片（chunk),要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器（explicitallocator),要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。 隐式分配器（implicitallocator)，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器,而自动释放未使用的已分配的块的过程叫做垃级收集例如，诸如Lisp，ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 7.10本章小结 本章就hello的存储管理，使我了解了hello的存储器地址空间，Intel逻辑地址到线性地址的变换-段式管理，Hello的线性地址到物理地址的变换-页式管理，TLB与四级页表支持下的VA到PA的变换，缺页故障与缺页中断处理，hello进程fork时的内存映射，hello进程execve时的内存映射，缺页故障与缺页中断处理，动态存储分配管理。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 一个Linux文件就是一个m个字节的序列，所有的I/O设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。 设备管理：unixio接口 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O,这使得所有的输人和输出都能以一种统一且一致的方式来执行： 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入(描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO，STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。 改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为是k。 读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。 类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 8.2简述UnixIO接口及其函数 进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的： open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件。mode参数指定了新文件的访问权限位。 进程通过调用close函数关闭一个打开的文件。 关闭一个已关闭的描述符会出错。 应用程序是通过分别调用read和write函数来执行输入和输出的。 read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1，表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章就hello的IO管理，使我了解了Linux的IO设备管理方法，UnixIO接口及其函数，printf的实现，getchar的实现。 结论 Hello的一生： 源代码：用C语言编写hello.c的代码。预处理：预处理器将hello.c处理成hello.i。编译：编译器将hello.i翻译成hello.s。汇编：汇编器将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。输入命令：在shell中输入./hello1190201619惠羿 shell识别并发送信号创建子进程：进程管理shell通过fork()创建子进程。运行：进程管理shell利用execve加载进程。执行：进程管理分配mmap，时间片。访存：MMU将CPU给出的虚拟地址翻译为物理地址，再根据物理地址去内存中寻找数据。动态申请内存：通过调用malloc，从堆中申请内存。结束：shell父进程回收子进程。 这就是hello的一生，虽然它的一生在机器中很短暂，但它的一生基本上囊括了计算机系统的所有知识。虽然hello的一生看起来简单，但对hello的一生的研究对我们了解计算机系统有着重要的作用。 附件 文件名字描述hello.i修改了的源程序(文本）hello.s汇编程序(文本）hello.o可重定位目标程序(二进制）hello.txthello.o的ELF格式objdump.txthello.o的反汇编文件hello可执行目标文件helloelf.txthello的ELF格式diff.txt分析hello与hello.o的不同的文本文件。 参考文献 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 
第282篇文章[]
正则表达式条件匹配的基本语法 条件匹配在正则表达式中十分重要，下面简单根据我的了解介绍一些： ?(A)B 表示只有当A存在时才会匹配B 下面的代码验证： Stringpattern="/?(A)B"; Stringstr="B"; Patternp=Pattern.compile(pattern); Matcherm=p.matcher(str); booleanresult=m.matches(); if(result){ System.out.println("匹配"); } else{ System.out.println("不匹配"); } 上述为A不存在B存在的情况，结果为不匹配 Stringpattern="/?(A)B"; Stringstr="AB"; Patternp=Pattern.compile(pattern); Matcherm=p.matcher(str); booleanresult=m.matches(); if(result){ System.out.println("匹配"); } else{ System.out.println("不匹配"); } 上述为AB都存在的情况结果为匹配 ?(A)B|C 若A存在，匹配B，否则，匹配C 下面的代码验证： Stringpattern="/?(A)B|C"; Stringstr="AB"; Patternp=Pattern.compile(pattern); Matcherm=p.matcher(str); booleanresult=m.matches(); if(result){ System.out.println("匹配"); } else{ System.out.println("不匹配"); } 上述为A存在的情况，结果为匹配 Stringpattern="/?(A)B|C"; Stringstr="C"; Patternp=Pattern.compile(pattern); Matcherm=p.matcher(str); booleanresult=m.matches(); if(result){ System.out.println("匹配"); } else{ System.out.println("不匹配"); } 上述为A不存在的情况，结果为匹配 
第283篇文章[]
assertEquals判断两个double是否相等的方法 在我们写测试用例时，难免要对各种数据类型是否相等进行判断。前几天在对两个double类型利 用aseertEquals进行判断时，遇到了下面的问题：精简化问题如下： 在这个例子中double类型h与y的值都为0.1，但assertEquals测试没通过，同时有一条warning ThemethodassertEquals(double,double)fromthetypeAssertisdeprecated 这条warning的意思是类型Assert中的方法assertEquals（double，double）已弃用。 其实我们都直到浮点型的存储形式，因为浮点数的范围和精度有限，所有直接判断两个double类 型是否相等是不合理的，以此我们利用下面的方法解决这个问题： java中提供了解决double判断的方法其中assertEquals的第一个参数为预期值，第二个参数为实 际值，第三个参数为偏差。当预期值与实际值之间的差值在偏差的范围内则判为相等，否则会抛出 错误。 
第284篇文章[]
有关java等价性问题==误用 在一次实验的test阶段，测试文件总是不通过，最后发现我是犯了等价性方面的错误： 在判断两个字符串是否相等时错误的使用==，将其改为equals()方法解决了问题。 后来在经课上听讲与课后调查了解到： ==是在判断两个对象是否指向内存里的同一段空间。 equals是将此字符串与指定的对象进行比较。当且仅当参数不为NULL并且是表示与此 对象相同的字符序列的字符串对象时，结果才为true。 就这个问题简化验证：将字符串s1与s2，利用==与equals()分别判断 Strings1="Hui"; Strings2=newString(s1); if(s1==s2){ System.out.println("==:T"); } else{ System.out.println("==:F"); } if(s1.equals(s2)){ System.out.println("equals:T"); } else{ System.out.println("equals:F"); } 结果如下：可以看出==判断为false，利用equals()判断为true。 这里让我想起了一道以前的课堂的一道题可以加深对==的理解： 答案为Flase;True a为创建的Integer对象，b是自动装箱产生的Integer对象，其地址不同，故第一个为false。 c为int类型，int与Integer比较时，Integer会进行拆箱，相当于两个int进行比较，故第二个为true。 通过以上测试可以看出：在判断相等的大部分情况下，我们在代码中的本意是equals()， 而不是==，这点不难理解，故在编写代码时一定要注意。 
第285篇文章[]
java中List的遍历方法 在做实验写代码时，List集合的遍历是经常要用到的 经过课上的讲解与课后的相关学习，总结如下： 首先在遍历之前创造一个List如下： List<String>list=newArrayList<>(); list.add("H"); list.add("u"); list.add("i"); list.add("Y"); list.add("i"); 第一种方法：for循环遍历 理解起来最为简单，利用for循环，设置循环内的局部变量通过get方法对List遍历。 for(inti=0;i<list.size();i++) { System.out.println(list.get(i)); } 第二种方法：增强型for循环遍历 for(数据类型变量名：容器对象){ } for(Strings:list){ System.out.println(s); } 第三种方法：迭代器： 通过集合对象获得迭代器对象 利用while循环遍历 利用hasNext()方法判断是否终止 利用next()获取元素 Iterator<String>iter=list.iterator(); while(iter.hasNext()){ Strings=iter.next(); System.out.println(s); } 三种方法的结果都如下： 可见三种方法都正确实现了List的遍历。 
第286篇文章[1]
HITCSAPP大作业-程序人生 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机 学 号 1190201628 班 级 1936601 学 生 尹岩泉 指导教师 刘宏伟 摘要 摘要是论文内容的高度概括，应具有独立性和自含性，即不阅读论文的全文，就能获得必要的信息。摘要应包括本论文的目的、主要内容、方法、成果及其理论与实际意义。摘要中不宜使用公式、结构式、图表和非公知公用的符号与术语，不标注引用文献编号，同时避免将摘要写成目录式的内容介绍。 关键词：计算机系统，预处理，编译，汇编，链接，进程，储存，IO 本文将从程序预处理开始一直到进程被回收的过程，解析hello.c程序的生命周期的过程，在过程中具体分析各个阶段的内容与实现机制。通过对进程的操作的了解，深入理解计算机系统。 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1 预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.3.1 数据 3.3.2数组 3.3.3赋值 3.3.4算数操作 3.3.5关系操作 3.3.6控制转移操作 3.3.7函数操作 3.3.8类型转换操作 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.3.1ELF头 4.3.2节头 4.3.3重定位节 4.3.4符号表 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.3.1ELF头 5.3.2节头 5.3.3重定位节 5.3.4符号表 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 P2P：FromProgramtoProcess，即从程序到过程。在linux中，hello.c文件经过编译器的预处理成为hello.i、再经过编译器的编译成为hello.s、接着被汇编为hello.o、最终链接成为可执行目标程序hello，操作系统执行此文件，然后，操作系统会为其fork产生子进程，再调用execve函数加载进程（Process）。至此，P2P结束。 020：FromZero-0toZero-0，shell通过execve加载并执行hello，操作系统映射虚拟内存。进入程序入口后，程序开始载入物理内存空间，然后进入main函数，执行目标代码，CPU为运行的hello分配时间片执行逻辑控制流。当程序运行结束后，shell父进程负责回收hello进程，内核删除相关数据结构。至此，020结束。 1.2环境与工具 X64CPU;1.80GHZ;8GROM;256GHDDISK。 Windows10;VmwareWorkstation Pro 15.5;Ubuntu18.0464位 CodeBlocks；VisualStdio；edb 1.3中间结果 hello.c：源程序 hello.i：经过预处理的源程序 hello.s：hello.i经过编译的汇编程序 hello.o：hello.s经过汇编的可重定位目标程序 hello：hello.o经过链接后的可执行目标程序 hello.elf：hello生成的elf文件 hello.o.elf：hello.o生成的elf文件 hello.asm：hello的反汇编代码 hello.o.asm：hello.o的反汇编代码 1.4本章小结 本章简单介绍了hello的P2P，O2O，介绍了实验用到的工具，中间结果。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 预处理的概念：预处理器cpp根据以字符#开头的命令（宏定义、条件编译），读取对应系统头文件的内容，并把它直接插入到程序文本中来修改原始的C程序，结果合并成为一个完整的文本文件。 预处理的作用： 1.头文件包含指令处理，将源文件中以”include”格式包含的文件复制到编译的源文件中。 2.宏定义指令处理，用实际值替换用“#define”定义的字符串，进行宏替换。 3.条件编译指令处理，根据“#if”后面的条件决定需要编译的代码。 4.特殊符号，预处理程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预处理程序对于在源程序中出现的这些串将用合适的值进行替换。为下一阶段的编译做准备。 2.2在Ubuntu下预处理的命令 命令：gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析 经过预处理之后，hello.c转化为hello.i文件，可以发现该文件的内容明显增加，但仍为可以阅读的C语言程序文本文件，符合C语言的语法。 可以发现命令对原文件中的宏进行了宏展开，头文件中三个#include的内容被替换进该文件中。源程序hello.c中没有定义宏常量，所以没有体现宏替换，但如果代码中有#define命令还会对相应的符号进行替换。 2.4本章小结 本章简述了hello程序生命周期中预处理阶段的概念作用及实现，预处理器以#开头的预处理命令，完成将对应的头文件插入程序文本中，进行宏替换等任务。生成的hello.i将进行下一阶段的编译。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的概念：将源程序（.i）翻译成汇编语言程序（.s）。 编译的作用：以高级程序设计语言书写的源程序翻译成汇编语言程序后，以汇编语言或机器语言表示的目标程序作为输出，之后更容易转化成机器可以看懂的二进制代码。 3.2在Ubuntu下编译的命令 命令：gcc-Ehello.c-ohello.i 3.3Hello的编译结果解析 3.3.1 数据 字符串 程序中有两个字符串，由图可知，这两个字符串都存放在只读数据段中。 2.全局变量 程序中有一个全局变量sleepsecs，定义为int类型，赋值为2.5。在编译过程中其实已经进行了一个隐式强制类型转换，在初始化后数值已经变成了2。 3.局部变量 main函数中声明了一个局部变量i，编译器进行编译时会将局部变量i放在堆栈中，在此程序中根据movl$0,-4(%rbp)，可知i在栈中的-4(%rbp)位置上。 4.main函数 main的参数argc储存在栈中。由cmpl$3,-20(%rbp)和je.L2可以看出argc在-20(%rbp)中。 5.立即数 立即数直接体现在汇编的代码中。 3.3.2数组 程序中唯一一个数组是char*argv[]，作为main函数的一个参数出现，每个元素都是指向字符类型的指针。由movq-32(%rbp),%rax可知数组的起始地址存放在栈的-32(%rbp)的位置，由于一个char*的大小是8字节，所以两个分别对应头指针+8和头指针+16，两次进行addq和movq的操作分别获取了argv[1]和argv[2]的地址。 3.3.3赋值 程序中的赋值操作一共有两个一个是intsleepsecs=2.5，一个是i=0。sleepsecs为全局变量，直接进行了强制类型转化；i=0在汇编代码中依靠movl指令来实现。 3.3.4算数操作 hello.c中实现的算数操作有i++。如在汇编代码中的addl$1,-4(%rbp)就是对位于-4(%rbp)的i加1。 常用的整数算数操作有如下图： 3.3.5关系操作 关系操作往往与条件跳转有关。程序通过判断两个变量的关系，来实现程序的逻辑控制。在本程序中有两个关系操作，分别如下： 1.argc!=3，进行编译时，这条指令被编译为cmpl$3,-20(%rbp)，同时这条cmpl的指令还有设置条件码的作用，当根据条件码来判断是否需要跳转到分支中，即下一句的je.L2。 2.i<10，在hello.c作为判断循环条件，在汇编代码被编译为cmpl$9,-4(%rbp)，计算i-9然后设置条件码，为下一步jle利用条件码进行跳转做准备，即jle.L4。 3.3.6控制转移操作 在本程序中有两个控制转移操作，一个if，一个for，具体如下： 1.if(argc!=3)：判断argc是否等于3，如果等于3，则不执行if中的语句，否则执行。对应的汇编代码为： 2.for(i=0;i<10;i++)，通过每次判断i是否满足小于10来判断是否需要跳转至循环语句中，对应的汇编代码为： 3.3.7函数操作 程序运行时先进入程序入口处，然后自动调用main函数。若程序员需要调用函数，在汇编代码中需要使用call指令，在使用之前需要先设置好参数（放在寄存器或者栈）。在hello.c中有调用main，puts，printf，sleep，exit，getchar函数。main函数的参数是argc和argv[]；两次printf函数的参数为两个只读数据段中的字符串；exit参数是1；sleep函数参数是sleepsecs。对应在hello.s中的操作如下： 3.3.8类型转换操作 在全局变量阶段已经有介绍。程序中有一个全局变量sleepsecs，定义为int类型，赋值为2.5。在编译过程中其实已经进行了一个隐式强制类型转换，在初始化后数值已经变成了2。 3.4本章小结 本章主要讲述了什么是编译，编译阶段中编译器如何处理各种数据和操作，以及c语言中各种类型和操作所对应的的汇编代码。理解了这些编译器编译的机制和一些汇编指令的含义和作用。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编器（as）将汇编代码（.s）翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在（.o）目标文件中，.o文件是一个二进制文件，它包含程序的指令编码，更便于机器在此后的链接与运行。 4.2在Ubuntu下汇编的命令 命令：gcc-chello.s-ohello.o 4.3可重定位目标elf格式 通过命令readelf-ahello.o查看内容进行分析。 4.3.1ELF头 首先是以一个16字节的序列Magic开始，描述了生成该文件的系统的字的大小和字节顺序。剩下部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、程序头的大小、文件类型为可重定位文件等信息。 4.3.2节头 节头包含了文件中出现的各个节的语义，包括节的类型、位置、大小和偏移量等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小。 4.3.3重定位节 重定位节包含了需要被修改的引用节的偏移量、信息、重定位的类型、符号值和重定位需要对被引用值的偏移调整量等。图中‘.rela.text’为一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。 4.3.4符号表 图中为程序符号表的信息，用来存放程序中定义和引用的函数和全局变量的信息。Value是符号相对于目标节的起始位置偏移、Size是目标的大小、Type为类型。Bind字段表明符号是本地的还是全局的。可以看到标号为11~16的符号都没有找到所在节，而sleepsecs在标号为3的节中，main在标号为1的节中。 4.4Hello.o的结果解析 命令：objdump-d-rhello.o，得到反汇编结果如下： hello.s的内容如下： 通过反汇编的代码和hello.s进行比较，发现从机器语言反汇编成汇编语言，与原本的汇编语言相差不大。但是通过对机器代码的分析也可以发现以下不同之处： （1）hello.s中没有对指令编码二进制的地址，而hello.o的反汇编代码中有。因为反汇编代码所显示的不仅仅是汇编代码，还有机器代码，机器语言程序的是二进制机器指令的集合，是纯粹的二进制数据表示的语言，是电脑可以真正识别的语言，这样才有编码和指令的对应。 （2）跳转指令：hello.s中采用的是段名称.L2,.L3等，反汇编用的则是确定的地址。因为，因为段名称只是在汇编语言中便于编写的助记符，而在反汇编代码中，由于已经得到每个指令的地址，就被替换成了具体的地址。 （3）对于函数调用，在hello.s中函数调用后直接加函数名称，而在反汇编指令中，采用的是call后直接为下一条指令。主要是因为，在反汇编代码中，还没有进行重定位，对于不确定地址的函数调用，需要添加重定位条目，等待链接时为其填上对应的值。 4.5本章小结 本章对hello.s进行了汇编，生成了hello.o可重定位目标文件，使用readelf方法分析了可重定位文件的ELF头、节头部表、符号表和可重定位节，比较了hello.s和hello.o反汇编代码的不同之处，分析了从汇编语言到机器语言的一一映射关系，体会了重定位的作用和意义。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载到内存并执行。链接由链接器自动执行。 链接的作用：链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。 5.2在Ubuntu下链接的命令 命令： ld-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.o/usr/lib/gcc/x86_64-linux-gnu/7/crtbegin.ohello.o-lc/usr/lib/gcc/x86_64-linux-gnu/7/crtend.o/usr/lib/x86_64-linux-gnu/crtn.o-zrelro-ohello 5.3可执行目标文件hello的格式 通过命令readelf-ahello.o查看内容进行分析。 5.3.1ELF头 hello的ELF头和hello.o的不同之处在于类型为EXEC（可执行文件），共有28个节。 5.3.2节头 节头包含了文件中出现的各个节的语义，包括节的类型、位置、大小和偏移量等信息。 5.3.3重定位节 重定位节包含了需要被修改的引用节的偏移量、信息、重定位的类型、符号值和重定位需要对被引用值的偏移调整量等。 5.3.4符号表 图中为程序符号表的信息，用来存放程序中定义和引用的函数和全局变量的信息。 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 通过DataDump可以看出hello的虚拟空间开始于0x400000，结束于0x400ff0。 根据上文得到的节头表，可以找到各个节的信息，如.txt节，虚拟地址开始于0x400500。 5.5链接的重定位过程分析 命令：objdump-d-rhello 下图为hello.out的反汇编代码： 可以明显看出，hello与hello.out对比，可以看出以下不同： hello的反汇编代码有确定的虚拟地址，重定位也已经完成，对应的跳转地址，全局变量调用等都已经加入了正确的值。hello的反汇编代码多出来了.init等节和很多函数的汇编代码。并且指令的地址也不相同，由于链接器将hello的代码映射到虚拟内存上，所以他们的地址不同。 下面举例介绍hello的重定位过程： 以hello.o中的.rodata节作为例子： 重定位算法如图所示： ADDR(S)=ADDR(main)=0x004005e7 refaddr=ADDR(S)+r.offest=0x004005e7+0x18=0x004005ff ADDR(r.symtab)=ADDR(.L0)=0x4006f4 所以最后填入的地址是0x4006f4-0x4005ff-0x4=0xf1 所以开始的四个字节为f1000000 验证可得正确。 5.6hello的执行流程 子程序名程序地址ld-2.27.so!_dl_start0x00007f38:3ebddea0ld-2.27.so!_dl_init0x00007f21:0198d760hello!_start0x00000000:00400500libc-2.27.so!__libc_start_main0x00007fc6:b7a2db12libc-2.27.so!__cxa_atexit0x00007fb9:b7a4f550hello!__libc_csu_init0x00000000:00400677hello!_init0x00000000:00400488libc-2.27so!_setjmp0x00007fa1:0198cef8 libc-2.27.so!__sigsetjmp0x00007f21:01993270libc-2.27.so!__sigjmp_save0x00007f21:01991840hello!main0x00000000:004005e7hello!puts@plt0x00000000:004004b0hello!printf@plt0x00000000:004004c0hello!sleep@plt0x00000000:004004f0hello!getchar@plt0x00000000:004004d0hello!exit@plt0x00000000:004004e0ld-2.27.so!_dl_runtime_resolve_xsave0x00007fad:1c1d08f0ld-2.27.so!_dl_fixup0x00007fad:1c1c8f80ld-2.27.so!_dl_lookup_symbol_x0x00007fad:1c1c4260libc-2.27.so!_exit0x00007fa1:01993210 5.7Hello的动态链接分析 由于编译器无法预测函数的运行时地址，所以需要添加重定位记录。为避免运行时修改调用模块的代码段,链接器采用延迟绑定的策略，使用全局偏移量表和 过程链接表（PLT+GOT）实现函数的动态链接。PLT使用GOT中的地址跳到目标函数，在加载时，连接器会重定位GOT，使得他包含目标的正确的绝对地址。 在dl_init调用之前，函数调用都指向PLT中的代码逻辑。第一次执行dl_init时，为GOT赋上相应的偏移量，初始化了函数调用。此后每次执行时不需要经过如此操作，每次都直接跳转到目标函数的地址。 5.8本章小结 在本章中主要介绍了链接的概念与作用，并且详细阐述了hello.o是怎么链接成为一个可执行目标文件的过程，详细介绍了hello.o的ELF格式和各个节的含义，并且分析了hello的虚拟地址空间、重定位过程、执行流程、动态链接过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context)中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。 6.2简述壳Shell-bash的作用与处理流程 Shell是一个交互型应用级程序，它可以读取用户输入的命令，执行相应的操作。Shell应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 其基本功能是解释并运行用户的指令，重复如下处理过程： 当从shell里输入命令（字符串）时，第一个单词是可执行程序的名称，后面 则是参数列表。shell会传进参数列表来执行对应程序，创建进程，并在进程终止后回收进程。 读入后，shell先解析字符串，得到命令行参数（char**argv）。检查第一个(首个、第0个）命令行参数是否是一个内置的shell命令，如果不是内部命令，调用fork()创建新进程/子进程。在子进程中，调用execve()执行指定程序若命令行。若参数的最后一个单词是&，表示要在后台执行，shell可以继续输入命令来做其他工作，否则则为前台执行，必须等待该进程结束并回收。 6.3Hello的fork进程创建过程 当程序调用fork函数时，将创建一个跟当前进程一模一样的进程副本（共享代码，有独立的地址空间，子进程可以读写父进程中打开的任何文件），进程分裂成父进程和子进程，它们拥有不同的PID。二者fork的返回值不同：父进程中fork的返回值是子进程的pid，子进程中fork的返回值是0。父进程和子进程独立运行，二者结束顺序不可知。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。 例如在hello中，当输入./hello1190201628尹岩泉时，这不是一个内置命令，故shell会调用fork新建一个子进程。 6.4Hello的execve过程 fork创建子进程之后，子进程调用execve函数（传入命令行参数）在当前进程的上下文中加载并运行一个新程序即hello程序。 execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行hello程序，加载器删除子进程现有的用户虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。换句话说，execve函数将用目标程序的进程替换当前进程，并传入相应的参数和环境变量，控制转移到新程序的main函数。 6.5Hello的进程执行 （1）逻辑控制流:：一系列程序计数器（PC）的值的序列叫做逻辑控制流。 （2）并发流：一个逻辑流的执行时间与另一个流重叠，成为并发流，这两个流被称为并发地运行。 （3）私有地址空间：进程为每个流都提供一种假象，好像它是独占的使用系统地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。 （4）用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 （5）上下文切换：当内核选择一个新的进程运行时，则内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程： 1）保存当前进程的上下文 2）恢复某个先前被抢占的进程被保存的上下文 3）将控制传递给这个新恢复的进程 最初hello运行在用户模式下，正常输出用户输入的内容，但是程序调用了sleep函数，进入内核模式，进程主动请求休眠释放当前进程，并将hello进程从运行队列中移出加入等待队列，定时器开始计时，内核进行上下文切换将当前进程的控制权交给其他进程。当计时器结束后，发送中断信号，此时进入内核状态执行中断处理，将hello进程从等待队列中移出重新加入到运行队列，从内核模式转换为用户模式，hello进程就可以继续进行自己的控制逻辑流了。 当hello调用getchar的时候，实际执行了read的调用，产生了上文所述的上下文切换。当完成键盘缓冲区到内存的数据传输时，内核从其他进程进行上下文切换回hello。 6.6hello的异常与信号处理 异常和信号异常一共可以分为4种： 在hello程序中可能出现： 中断：时钟中断。陷阱：调用了系统命令，如sleep，exit等。故障：可能发生缺页故障。 键盘上可能导致的异常： 1.首先给出正常运行的结果。 2.Ctrl+Z 输入Ctrl+z默认结果是挂起前台的作业，hello进程并没有回收，而是运行在后台下。 可以用ps命令看到hello进程并没有被回收。同时调用jobs，pstree观察。 继续调用fg1将其调到前台，此时shell程序首先打印hello的命令行命令，然后继续运行直至程序结束，同时进程被回收。 也可以通过kill命令操作。 3.Ctrl+C 在键盘上输入Ctrl+C默认情况是终止前台作业。 此时可以调用ps命令看到没有hello进程。 4.乱按键盘 可以看到乱按只是将屏幕的输入缓存到stdin，当getchar()的时候读出一个字符串，其他字串会当做shell命令行输入。 6.7本章小结 本章说明了进程的定义与作用，介绍了Shell-bash 的作用和处理流程，以及调用fork创建新进程，execve的过程，hello的进程执行的过程，系统对hello的异常与异常信号的处理。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：程序代码经过编译后出现在汇编程序中产生的与段相关的偏移地址。由段选择符+偏移地址构成。其中段选择符位于段寄存器（16位，CS、SS等）中。而偏移地址即为汇编、c代码中显示的地址。常见段寄存器有CS（代码段）、DS（数据段）、SS（栈）等。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相关。 线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址，用于描述程序分页信息的地址。以hello为例，线性地址就是hello应该在内存的哪些块上运行。 虚拟地址：同线性地址。 物理地址：物理地址为加载到内存地址寄存器中的地址，处理器通过地址总线的寻址，找到真实的物理内存对应地址。是内存单元的真实地址。以hello为例，物理地址就是hello真正应该在内存的哪些地址上运行 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理，是指把一个程序分成若干个段进行存储，每个段都是一个逻辑实体，程序员需要知道并使用它。它的产生是与程序的模块化直接有关的。段式管理是通过段表进行的，它包括段号或段名、段起点、装入位、段的长度等。此外还需要主存占用区域表、主存可用区域表。 逻辑地址是程序代码经过编译后出现在汇编程序中产生的与段相关的偏移地址，即在不同的机器上，使用相同的编译器来编译同一个源程序，则其逻辑地址是相同的，但是相同的逻辑地址，在不同的机器上运行，其生成的线性地址又不相同，因为把逻辑地址转换成线性地址的公式是： 线性地址=段基址*16+偏移的逻辑地址，而段基址由于不同的机器其任务不同，其所分配的段基址也会不相同，因此，其线性地址会不同。 即使，对于转换后线性地址相同的逻辑地址，也因为在不同的任务中，而不同的任务有不同的页目录表和页表把线性地址转换成物理地址，因此，也不会有相同的物理地址冲突。 下图为逻辑地址采用段式管理转化为线性地址的过程： 7.3Hello的线性地址到物理地址的变换-页式管理 首先给出一些概念，如图： 页表： 使用页表的地址翻译： 线性地址转换成物理地址的过程如下： n位的虚拟地址包含两个部分:一个p位的虚拟页面偏移（VirtualPageOffset，VPO)和一个(n-p)位的虚拟页号（Virtual PageNumber,VPN)。MMU利用VPN来选择适当的PTE。例如，VPNO选择PTEO，VPN1选择PTE1。以此类推。将页表条目中物理页号(PhysicalPageNumber,PPN)和虚拟地址中的VPO串联起来，就得到相应的物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 二级页表如图所示： k级页表如图所示： 对于多级页表，与上图类似。将VPN分为多级，在每一级都找到对应的位置。当到达最后一层时会得到PPN，与VPO连接就得到了最终的物理地址。 7.5三级Cache支持下的物理内存访问 图为地址翻译后返回结果。左侧是四级页表支持的虚拟地址翻译成物理地址，之后将物理地址分为三块。首先是从L1cache里寻找结果，行匹配把虚拟地址的标记为拿去和相应的组中所有行的标记位进行比较，判断是否命中。若字选择一旦高速缓存命中，则将寻址结果直接返回给CPU；否则需要向低一层的缓存中寻找，取出被请求的块，将新的块储存在组索引位所指示的组的一个高速缓存行中，并设置好tag和valid位。寻找到结果后返回。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，即创建hello进程时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，他创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork函数在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。也就是说，此时新进程并不包括hello程序的相关内容，只有在新进程调用execve加载hello程序，要对虚拟内存进行写操作时，写时复制机制就会创建新页面，将hello的各个段映射到相对应区域。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的概念。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1）删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2）映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3）映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 4）设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 execve只是建立了映射关系，并未加载程序到物理内存中，当开始调度这个进程开始运行的时候，产生缺页故障，然后才会所需要的页面加载进去。 7.8缺页故障与缺页中断处理 处理器首先生成一个虚拟地址，并把它传给MMU。MMU生成PTE地址，并从高速缓存/主存中请求得到它。高速缓存/主存向MMU返回PTE。PTE中的有效位为0，那么此时MMU就触发了一次异常，这个异常导致控制转移到内核的缺页处理程序，传递CPU中的控制到操作系统内核中的缺页异常处理程序。处理程序随后就执行下面的步骤： 1)虚拟地址A是合法的吗？换句话说，A在某个区域结构定义的区域内吗？为了回答这个问题，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图9-28中标识为“1”。 因为一个进程可以创建任意数量的新虚拟内存区域，所以顺序搜索区域结构的链表花销可能会很大。因此在实际中，Linux使用某些我们没有显示出来的字段，Linux在链表中构建了一棵树，并在这棵树上进行査找。 2)试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。这种情况在图9-28中标识为“2”。 3)此刻，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，缺页处理程序调入新的页面，并更新内存中的PTE。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，这次，MMU就能正常地翻译A，而不会再产生缺页中断了。 7.9动态存储分配管理 Printf会调用malloc，下面简述动态内存管理的基本方法与策略。 动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块（block）的集合来维护。每个块就是一个连续的虚拟内存片（chunk）,要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 隐式空闲链表分配器方法： 隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器。 我们可以将堆组织为一个连续的已分配块和空闲块的序列，这种结构被称为隐式空闲链表。以下为几种操作： 放置： （1）首次适配：从头开始搜素空闲链表，选择第一个合适的空闲块。 （2）下一次适配：从上一次查询结束的地方开始搜素空闲链表，选择第一个合适的空闲块。 （3）最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块。 分割空闲块合并： 可以分为立即合并和推迟合并。立即合并是指在每次一个块被释放时，就合并所有的相邻块；推迟合并是指直到某个分配请求失败时，扫描整个堆，合并所有的空闲块。 同时合并具有四种情况： （1）前后的块都为已分配块：不需要合并 （2）前面的块是已分配的，后面的块是空闲的：用当前块和后面块的大小的和来更新当前块的头部和后面块的脚部。 （3）前面的块是空闲的，后面的块是已分配的：用当前块和前面块的大小的和来更新前面块的头部和当前块的脚部。 （4）前后块都为空闲块：用三个块大小的和来更新前面块的头部和后面块的脚部。 显式空闲链表分配器方法： 显式空闲链表中的堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略。 一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检査最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 7.10本章小结 本章节介绍了储存器的四种地址空间的概念，介绍了段式管理和页式管理，解析了TLB与四级页表支持下的VA到PA的变换，以及三级cache支持下的物理内存访问，分析了fork和execve函数的内存映射，缺页故障和缺页中断处理，以及动态存储分配管理。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m字节的序列： 所有的IO设备(如网路、磁盘、终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行： 打开文件；改变当前的文件位置；读写文件；关闭文件。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixIO接口： （1）打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息 （2）Linux shell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0），标准输出（描述符为1），标准错误（描述符为2）. （3）改变当前文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 （4）读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时执行读操作时触发EOF的条件。 类似的，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 （5）关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件，作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixIO函数： 打开和关闭函数： 进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的： O_RDONLY：只读 O_WRONLY：只写 O_RDWR：读写 进程通过调用close函数关闭一个打开的文件： 关闭一个已关闭的文件会出错。 读和写函数 应用程序是通过分别调用read和write函数来执行输入和输出的： read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值为-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 printff函数的实现代码如下： （来源https://www.cnblogs.com/pianist/p/3315801.html） va_listarg=(va_list)((char*)(&fmt)+4);这句表示将 中的第一个参数定义为arg。 vsprintf(buf,fmt,arg)函数如下： vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 write(buf,i)函数如下： write是将参数放入寄存器，然后调用sys_call sys_call的实现如下： syscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码，符显示驱动子程序：在字模库找到点阵信息储存到vram（存储每一个点的RGB颜色信息）中。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：当用户按键时，键盘接口会得到一个代表该按键的键盘扫描码，键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章节介绍了Linux 的IO设备管理方法，接口及其函数，分析了printf和getchar函数的实现。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 hello所经历的过程总结如下： 编写代码：程序员用高级语言写.c文件，命名保存为hello.c。预处理：从hello.c经过预处理器生成hello.i文件，将hello.c中调用的外部库展开合并到hello.i中。编译：由hello.i经过编译器生成hello.s的汇编文件。汇编：将汇编程序hello.s经过汇编器翻译成机器语言指令文件hello.o，一种可重定位目标程序的格式。连接：将hello.o和各种动态链接库连接成为可重定位目标程序hello。运行：在shell中输入参数，命令，运行hello。创建子进程：shell调用fork函数，创建函数的子进程。加载：shell调用execve函数，加载进程。执行指令：CPU为进程分配时间片，加载器将计数器预置在程序入口点，则hello可以顺序执行自己的逻辑控制流，hello进程与其它进程并发运行。访问内存：hello有系统分配的地址空间，当进行访问内存的操作时，MMU将虚拟内存映射为物理内存地址，通过三级cache来访问内存。动态内存分配：系统根据程序需要申请动态内存。异常信号：根据用户输入的信号和程序内部的命令，shell可以利用信号处理函数处理程序的异常和用户的请求，系统会触发上下文切换，hello会在用户态和内核态切换。终止信号：程序执行完成，回收子进程。 感悟： 我感受到了计算机系统的复杂。并且懂得了要一个行之有效的系统都是对每个部分进行抽象从而实现的，如信息的表示用二进制表示抽象，实现操作系统管理硬件的抽象，它能让系统使用一些一致的操作来对系统中的每个任务进行有效的管理。而且计算机系统的设计巧妙，考虑全面，是一个严密而精致的过程。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 hello.c：源程序 hello.i：经过预处理的源程序 hello.s：hello.i经过编译的汇编程序 hello.o：hello.s经过汇编的可重定位目标程序 hello：hello.o经过链接后的可执行目标程序 hello.elf：hello生成的elf文件 hello.o.elf：hello.o生成的elf文件 hello.asm：hello的反汇编代码 hello.o.asm：hello.o的反汇编代码 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42. [2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998 [1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL]. Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/ collection/anatmorp. （参考文献0分，缺失-1分） 
第287篇文章[]
Java中关于Queue的一部分操作 队列是一个先进先出的数据结构，具有一些相似度较高的操作。在软件构造课程过程中，一些实际的操作在编写时，却触发了一些异常。下面记录一下自己遇到的问题。 1.关于add()与offer()的差别 add()与offer()都是向队列中添加一个元素。差别在于队列满时的添加操作。 查看add()的API如下： 查看offer()的API如下： 如图，差别在于，add()是抛出异常让你处理，而offer是返回false。 2.关于poll()与remove()的差别 poll()和remove()都是从队首获取元素，并将该元素从队列中移除。差别在于队列为空时的操作。 查看poll()的API如下： 查看remove()的API如下： 如图，差别在于，poll()会返回null，而remove()会抛出异常。 
第288篇文章[]
java.lang.IllegalStateException:Nomatchfound的错误解决方法 在java中编写正则表达式时，程序报错：java.lang.IllegalStateException:Nomatchfound 找到错误是因为在执行分组捕获的时候，没有先进行匹配操作，及find()。 下面是从程序中截出来的一段代码，目的是检测一段表达式： Patternpattern=Pattern.compile("Employee\\{\\s*(([a-z|A-Z]+\\{[^{}]*}\\s*)*)}"); Matcherm=pattern.matcher(fileContent); m.find(); Stringemployees=m.group(1); Employee{ ZhangSan{Manger,139-0451-0000} LiSi{Secretary,151-0101-0000} WangWu{AssociateDean,177-2021-0301} ZhaoLiua{Professor,138-1920-3912} ZhaoLiub{Lecturer,138-1921-3912} ZhaoLiuc{Professor,138-1922-3912} } 但是发现在处理另外一段表达式的时候还是会有java.lang.IllegalStateException:Nomatchfound的提示，其中发现问题出现在一句话： ZhaoLiu1{Professor,138-1920-3912} 要求的正则表达式中是不含数字的，但是当检测带有数字的表达式时还是会报错，后来发现正确的形式应该为： while(m.find()){ Stringemployees=m.group(1); } 这样问题就解决了。 
第289篇文章[]
Java多维度视图的总结 软件构造中第一章的最主要的内容应该就是软件的多维视图。可以以三个相互正交的维度划分： 按状态划分：构造时视图（build-time）运行时视图（run-time）按动态性划分：时刻视图（moment）阶段视图（period）按构造对象的层次划分：代码视图（code）组件视图（component） 软件的多维视图从构造-运行、代码层-组件层、时刻-阶段这三对对应的属性来刻画了各种可能出现的状态和过程。而软件构造的过程正伴随着这些视图的转换。 
第290篇文章[]
Java抽象与接口 抽象函数/抽象类 抽象函数：表达概念而无法实现具体代码的函数。 抽象类：表达概念而无法构造出实体的类。 抽象函数只有函数头而没有实现，它的实现由子类提供有抽象函数的类一定是抽象类，允许声明没有抽象方法的抽象类。非抽象类不能包含抽象函数，如果一个抽象父类的子类不能实现所有的抽象方法，它必须声明为抽象的。抽象类不能用new制造对象，但是可以定义变量；可以定义它的构造方法，可在子类的构造方法中调用。任何继承了抽象类的非抽象类的对象可以付给这个变量 接口的定义 1.接口是纯抽象类。 所有成员函数都是抽象函数所有成员变量都是publicstaticfinal 2.接口规定了里面有什么，但不管里面有什么。 3.接口不能被实例化，只能被类实现，或者被其他接口扩展。 4.关键字 interface表明其后紧跟的是接口名extends表明继承自哪些父接口 5.访问权限控制符 public表明任意类和接口均可使用这个接口；缺省修饰符表明只有与该接口定义在同一个包中的类和接口才可以使用这个接口。 接口的实现 类用extends，接口用implements类可以实现多个接口接口可以继承接口，但不能继承类接口不能实现接口 面向接口的编程方式 设计程序时需要先定义接口，再利用接口去实现类任何需要在函数间传入传出的一定是接口 
第291篇文章[]
JavaADT设计总结 ADT ADT是抽象数据类型（AbstractDataType）的缩写。ADT是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。 下面介绍有关表示的几个概念: 抽象函数(Abstract Function, AF)表示不变量(RepresentationInvariant, RI)表示独立性（RepresentationIndependence) （1）抽象函数(Abstract Function, AF) 表示域（称为R）包含的是值具体的实现实体。抽象域（称为A）包含类型设计时支持使用的值。抽象函数是表示值到其对应的抽象值的映射 AF:R->A。 （2）表示不变量(RepresentationInvariant, RI) 要求注明抽象值的合法区域，并说明合法或者不合法的原因。其中最基本的表示不变量的就是可变与不可变性（mutable/immutable）。 记录不变量是为了保持程序的“正确性”，防止发生错误。 （3）表示独立性（RepresentationIndependence) 说一个ADT有良好的表示独立性，就是说client使用ADT是无需考虑其内部如何实现的，ADT内部表示的变化不应影响外部spec和客户端。所有的操作的使用方法和效果都要在spec中说清楚，规定好输入的约束条件和输出的正确性和安全性。 
第292篇文章[]
2021-07-07 软件构造之关于委派delegation的一些感悟 1.delegate的含义：委派模式（Delegate）是面向对象设计模式中常用的一种模式。这种模式的原理为类B和类A是两个互相没有任何关系的类，B具有和A一模一样的方法和属性；并且调用B中的方法，属性就是调用A中同名的方法和属性。B好像就是一个受A授权委托的中介。第三方的代码不需要知道A的存在，也不需要和A发生直接的联系，通过B就可以直接使用A的功能，这样既能够使用到A的各种公能，又能够很好的将A保护起来了。2.delegate的类型：2.1AuseB：B类对象在A类中出现，但是是以局部变量或是方法参数的形式出现的。A类中并没有B类的对象作为域。一般称这种delegation为临时性的delegation。2.2AhasB：B类对象在A类中出现，B类的对象是A类的域之一。B类对象通过A类对象的constructor方法或其它方法从外部输入A类对象。AhasB有两种情况：Association为A类对象和B类对象之间并没有从属关系；Aggregation为A类对象由B类聚合而成，但是B类可以脱离A类单独存在。一般称这种delegation为永久性的delegation。2.3AispartofB：B类对象在A类中出现，B类的对象是A类的域之一。B类对象在A类对象内创建。B类对象不能脱离A类对象独立存在。一般称这种delegation为永久性的delegation。3.delegate的使用场景：在某些情况下，我们不希望或是不能直接访问对象A，而是通过访问一个中介对象B，由B去访问A达成目的，这种方式我们就称为代理。这里对象A所属类我们称为委托类，也称为被代理类，对象B所属类称为代理类。4.静态delegate：代理者的代码由程序员自己或通过一些自动化工具生成固定的代码再对其进行编译，代码运行前代理类的class编译文件就已经存在。5.动态gelegate：通过反射机制动态的生成代理者的对象，代理谁只有在执行时才知道。java提供了一个便捷的动态代理接口InvocationHandler,实现该接口需要重写invoke()方法。实现动态代理包括三步：1新建委托类；2实现InvocationHandler接口，这是负责连接代理类和委托类的中间类必须实现的接口；3通过Proxy类创建代理类对象。以上关于delegate的一些感悟是基于课程学习和csdn的一些文章得来，用于课程总结感悟，侵删。 
第293篇文章[]
2021-07-07 软件构造之知识点总结1、31.软件构造的多维度视图1.1Byphases:build-andrun-timeviews按阶段划分：构造时/运行时视图1.2Bydynamics:momentandperiodviews按动态划分：时刻/阶段视图1.3Bylevels:codeandcomponentviews按构造对象的层次划分：代码/构件视图2.软件构造的阶段划分、各阶段的构造活动阶段1：build-time，构造活动为design、refactoring、build、versioncontrol、evolution阶段2：dumping、debugtesting、buildinstalldeploy、profiling、tracing、logging3.内部/外部的质量标准外部质量因素影响用户，内部质量因素影响软件本身和它的开发者，外部质量取决于内部质量。包括：正确性，健壮性，可扩展性，可复用性，保持设计的同构性，有效性，可移植性，易用性，功能性，及时性等等4.软件配置管理SCM与版本控制系统VCS软件配置管理：追踪和控制软件的条件版本控制系统：本地版本控制系统：仓库存储于开发者本地机器无法共享和协作；集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作分布式版本控制系统：仓库存储与独立的服务器+每个开发者的本地机器5.Git的结构git仓库分为三部分：本地的CMDB、工作目录：本地文件系统以上为1、3的知识点文字总结，为本人针对软件构造学习所做，侵删 
第294篇文章[]
2021-07-06 软件构造之关于OOP的一些感悟 Object-OrientedProgramming面向对象的编程1.类：类的定义包括“成员变量”的定义和“方法”的定义:成员变量用于描述该类型对象共同的数据结构，方法用于描述对象的行为，封装对象的功能。类定义完成后，对象的创建可通过new关键字创建，创建对象的过程通常被称为实例化。2.对象：为了能够对实例化对象进行访问控制，需要用一个特殊的变量 引用。引用类型变量可以存放该类对象的地址信息，通常称为“指向该类的对象”。当一个引用类型变量指向该类的对象时，就可以通过这个变量对对象实施访问。除8种基本类型之外，用类、接口、数组等声明的变量都称为引用类型变量，简称“引用”。通过引用就可以访问对象的成员变量和调用方法。3.继承：子类继承自父类。一般通用的属性和方法都放在父类，子类继承后也有这些属性和方法，并可以添加自己的属性和方法。一个类只能继承一个父类。继承不仅让代码变得简洁，还增加了代码的可重用性，拓展，修改。子类的构造方法必须通过super关键字调用父类的构造方法。如果子类的构造方法没有调用父类的构造方法，编译器会自动加入对父类无参构造的调用。override：当子类对象的重写方法被调用时（无论是通过子类的引用还是父类的引用调用），运行的都是子类重写后的方法。这里注意一下override和overload的一些区别：overload是指在一个类中定义多个方法名相同参数列表不同的方法，在编译时根据参数个数和类型来决定绑定哪个方法；override是指在子类中定义和父类完全相同的方法，在运行时根据对象的类型不同（不是引用类型）来调用不同的版本。4.封装：修饰符本类同一个包中的类子类其他类public可以访问可以访问可以访问可以访问protected可以访问可以访问可以访问不能访问默认可以访问可以访问不能访问不能访问private可以访问不能访问不能访问不能访问真的，这个图就很重要，默认这个其实也是default（我这么看的）5.多态：多态是在继承的基础上实现的。多态的三要素：继承、重写和父类引用指向子类对象。父类引用指向不同子类对象时，调用相同的方法，呈现出不同的行为就是类多态特性。多态可以分为编译时多态和运行时多态。一个类型的引用在指向不同的对象时会有不同的实现；当然同样一个对象，造型成不同的类型时，也会有不同的功能。另外关注一下instanceof关键字，为了避免ClassCastException，可以通过instanceof关键字判读某个引用指向的对象是否可以强制为某类型。以上是本人学习了OOP之后结合课件和CSDN上的一些文章总结的结果，侵删，仅供参考和作为课程感悟用途。 
第295篇文章[]
2021-07-06 软件构造之ADT的一些感悟 前言：抽象数据类型和表示独立性是我们能够将如何在程序中使用数据与数据结构本身的特定形式分离开。设计良好的抽象数据结构，通过封装来避免客户端获取数据内部表示，避免潜在的bug，起到在client和implementer之间建立防火墙的作用。抽象类型：强调“作用于数据上的操作”，程序员和用户无需关心数据如何具体存储的，秩序设计或使用操作即可。可以说，ADT是由操作定义的，于其内部如何实现无关。可变与不可变数据类型：可变数据类型的对象提供了可改变其内部数据的值的操作，而不可变数据类型的操作不改变内部值，而实构造新的对象。举例而言，StringBuilder是String的可变版本，但这两个的Java类型肯定不相同，不能相互转换。抽象类型的操作：一个抽象类型包括构造器、生产器、观察器和变值器（改变对象属性的方法）。其中：构造器的可能实现为构造函数或静态函数，后者被称为一个工厂方法。变值器通常返回void，意味着改变了对象内部的某些状态（当然变值器也可以返回非空类型）。设计一个抽象类： 设计简洁、一致的操作；2.要足以支持客户对数据多做的所有操作需要，且用操作满足用户需要的难度要低；3.要么抽象要么具体，不要混合。表示独立性：表示独立性指用户在使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。除非ADT的操作指明了具体的pre和post-condition，否则不能改变ADT的内部表示，可以看作spec规定了client和implementer之间的契约。代表独立性的魅力在于，某函数的现有客户端只依赖于它的公共方法的规约，而不是它的私有字段，我们可以在不检查和更改所有的客户端代码的情况下进行此更改。测试一个ADT：调用观察器观察剩下三个操作的结果是否满足spec，反过来，调用这三个操作等方法产生或改变对象，看结果是否正确来测试观察器。变量：由ADT负责不变量，与客户端的任何行为无关。因为我们总要假设有客户端由恶意地破坏ADT的不变量，所以需要不变量保持程序的正确性并且易发现错误。一旦发生表示泄露，不仅影响不变性，也影响表示独立性，即无法在不影响客户端地情况下改变其内部表示。防御式拷贝：对可变对象进行复制，避免将引用泄露给rep，确保类不变量在任何输入中存储，以最小化可变性。通常，我们检查所有ADT的陈宗座参数和返回类型，如果任何类型是可变的，则确保我们的实现不会返回对其表示的直接引用。最好的办法就是使用不可变的类型，彻底表示表示泄露。AF与RI：AT（抽象函数），表示R和A之间映射关系的函数，即如何去结视R中的每一个值为A中的每一个值。RI（表示不变性），表示某个具体的“表示”是否是“合法的”。 
第296篇文章[]
2021-07-05 软件构造之关于git的使用 前言：本人软件构造课需要在github中获取提供的一些程序框架，并且需要持续的上传代码和报告更新github的个人仓库，所以需要用到一些git的基本操作以及技巧，所以利用这个机会在这里分享一下git学习和使用的收获与心得体会。创建版本库：默认已经安装好git了，首先，选择一个合适的地方，创建一个空目录，示例代码如下：$mkdirruanjiangouzao$cdruanjiangouzao$pwd其中ruanjiangouzao为你起的仓库的名字（当然具体要按照实验要求HIT-Lab？-学号），pwd的目的是显示当前目录。然后通过gitinit命令把这个目录变成Git可以管理的仓库：$gitinit添加远程仓库：建立好本地仓库后就需要与实验给出的远程仓库建立联系，由于软件构造的实验都实现给学生梦创建好了仓库，所以我们不需要在Github中创建新的仓库了，需要登上自己Lab的仓库改一下仓库名字变成规定的形式，然后保存下来仓库的地址并把main分支修改成master分支就好了。接下啦在本地仓库文件夹下运行$gitremoteaddorigingit@github.com:刚才保存的实验地址.git（没有http这些前缀的）接下来就是往github仓库中上传相关的代码和文件啦。这里建议先克隆下来实验的仓库到本地仓库在进行后续上传。从远程库克隆：加粗样式在本地仓库文件夹里执行如下命令克隆下来远程库：$gitclonegit@github.com:刚才保存的实验地址.git（没有http这些前缀的）向远程仓库中push：$gitadd.$gitcommit-m“随便起个名字”$gitpushoriginmaster第一行add是添加要上传的文件，.是添加该文件夹中所有的文件；第二行是为了给这个版本的提交起一个名字；第三行是把选中的内容推送到master分支上去。当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：Theauthenticityofhost‘github.com(xx.xx.xx.xx)’can’tbeestablished.RSAkeyfingerprintisxx.xx.xx.xx.xx.Areyousureyouwanttocontinueconnecting(yes/no)?这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：Warning:Permanentlyadded‘github.com’(RSA)tothelistofknownhosts.这个警告只会出现一次，后面的操作就不会有任何警告了。添加新的分支change：Lab3中要求修改原来的设计以应对一些变化，在确保之前的开发已经commit到Git仓库，然后创建新分支“change”，在该分支上完成一些功能的变化。$gitcheckout-bchange$gitadd*$gitcommit-m“change”$gitcheckoutmaster第一行创建change新分支；第三行在该分支上提交软件构造的Lab新代码；第四行切换回master分支。Tips： 正常方法连接github极不稳定，请切记不要赶在ddl前几分钟拼命提交。即使显示如"everythingisupdate"这种反馈也不要轻信，尽量自己打开仓库看一眼。仓库名字一定要按照要求起，一定记得把main改成master，不然真的会不被读取到。ddl一定要遵守。参考资料：廖雪峰git教程lab-3reusabilityandmaintainabilityorientedprogrammingv3 
第297篇文章[1]
2021-06-29 程序人生-Hello’sP2P 摘要本文简要分析了hello这一程序的生命周期，并介绍了相应的计算机系统组成成分（主要包括预处理，编译，汇编，链接，进程管理，存储管理，I/O管理几个部分）在其中的作用以及工作方法。关键词：hello，预处理，编译，汇编，链接，进程管理，存储管理，I/O管理；目录 第1章概述-4-1.1HELLO简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在UBUNTU下预处理的命令-5-2.3HELLO的预处理结果解析-5-2.4本章小结-7-第3章编译-8-3.1编译的概念与作用-8-3.2在UBUNTU下编译的命令-8-3.3HELLO的编译结果解析-8-3.4本章小结-12-第4章汇编-13-4.1汇编的概念与作用-13-4.2在UBUNTU下汇编的命令-13-4.3可重定位目标ELF格式-13-4.4HELLO.O的结果解析-16-4.5本章小结-17-第5章链接-18-5.1链接的概念与作用-18-5.2在UBUNTU下链接的命令-18-5.3可执行目标文件HELLO的格式-18-5.4HELLO的虚拟地址空间-24-5.5链接的重定位过程分析-25-5.6HELLO的执行流程-27-5.7HELLO的动态链接分析-28-5.8本章小结-29-第6章HELLO进程管理-30-6.1进程的概念与作用-30-6.2简述壳SHELL-BASH的作用与处理流程-30-6.3HELLO的FORK进程创建过程-30-6.4HELLO的EXECVE过程-30-6.5HELLO的进程执行-30-6.6HELLO的异常与信号处理-31-6.7本章小结-32-第7章HELLO的存储管理-34-7.1HELLO的存储器地址空间-34-7.2INTEL逻辑地址到线性地址的变换-段式管理-34-7.3HELLO的线性地址到物理地址的变换-页式管理-34-7.4TLB与四级页表支持下的VA到PA的变换-34-7.5三级CACHE支持下的物理内存访问-34-7.6HELLO进程FORK时的内存映射-35-7.7HELLO进程EXECVE时的内存映射-35-7.8缺页故障与缺页中断处理-35-7.9动态存储分配管理-35-7.10本章小结-35-第8章HELLO的IO管理-37-8.1LINUX的IO设备管理方法-37-8.2简述UNIXIO接口及其函数-37-8.3PRINTF的实现分析-37-8.4GETCHAR的实现分析-38-8.5本章小结-38-结论-38-附件-39-参考文献-40-第1章概述1.1Hello简介P2P是指fromprogramtoprocess，对原程序hello.c进行包括预处理，编译，汇编，链接的一系列操作后，形成可执行文件。执行该文件时，OS为该文件fork产生子进程（process）。020是指fromzerotozero。程序开始执行后，OS为其映射到虚拟内存，执行目标代码，然后mmap分配时间片，最终在硬件上实现。实现后由内核使内存等恢复到程序执行前的状态，即020。1.2环境与工具硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位开发与调试工具：gcc，vim，edb，readelf，HexEdit1.3中间结果Hello.c:源文件Hello.i:预处理之后的文件Hello.s:编译之后的汇编文件Hello.o：汇编输出文件Hello：链接输出文件。1.4本章小结本章简要介绍了文章的创作环境以及过程文件，简述hello程序从.c到可执行文件hello的大致过程。 第2章预处理2.1预处理的概念与作用概念：在编译之前预处理器cpp根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件。作用：1.宏替换，将宏名替换为文本；2.加载头文件；3.处理条件编译；4.处理特殊符号。2.2在Ubuntu下预处理的命令tu图2.3Hello的预处理结果解析预处理之后hello.c文件转化为hello.i文件，阅读hello.i，可见预处理对源文件保持main部分不变，头文件部分展开，宏定义也被处理。若文件存在嵌套关系，cpp也会逐层展开，这样hello.i就可以直接被译为.s文件。2.4本章小结本章主要介绍了预处理的概念和作用，并且对hello.c文件进行预处理且分析结果。第3章编译3.1编译的概念与作用概念：将程序员所撰写的编程语言翻译成汇编语言的过程：编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。其以高级程序设计语言书写的源程序作为输入，而以汇编语言或机器语言表示的目标程序作为输出。作用：通过语法检验，代码优化等过程，将程序员便于记忆和认知的编程语言转化为机器可识别的预言。注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令应截图，展示编译过程！3.3Hello的编译结果解析3.3.1汇编指令.file：声明源文件；.text：代码节.rodata：只读代码段；.align：数据或者指令的地址对齐方式；.string：声明一个字符串（.LC0，.LC1）；.global：声明全局变量；.type：声明一个符号是数据类型还是函数类型。3.3.2数据3.3.2.1字符串两个字符串都在只读数据段中，作为printf函数的参数。3.3.2.2全局变量函数声明一个全局变量i，编译器进行编译的时候将局部变量i放到堆栈中。3.3.2.3main函数参数argc作为用户传给main的参数，也是被放到堆栈里的。3.3.2.4各种立即数立即数直接体现在汇编代码中。3.3.2.5数组main函数的第二个参数是数组，每一个元素都是指向字符类型的指针。.L4中能看到它的起始地址等3.3.3全局变量hello.c文件中声明了全局函数intmain(intargc,char*argv[])，经过编译后，main函数中使用的字符串常量也被放在数据区。.globalmain说明main函数是全局变量。3.3.4赋值i=0;用mov实现，根据数据类型选择movqmovl等。3.3.5算数i++;用add实现，因为是int型。3.3.6关系操作3.3.6.1argc!=3;编译成cmpl$3,-20(%rbp)同时还有条件码判断是否需要跳转je.L23.3.6.2i<10;编译成cmpl$9,-4(%rbp)然后还设置条件码进行判断或跳转jle.L43.3.7控制转移指令3.3.7.1汇编为cmpl$3,-20(%rbp)je.L23.3.7.2 汇编为.L2:movl$0,-4(%rbp)jmp.L3.L3:cmpl$9,-4(%rbp)jle.L43.3.8函数操作调用函数时有以下操作：传递控制：进行过程B的时候，程序计数器必须设置为B的代码的起始地址，然后在返回时，要把程序计数器设置为A中调用B后面那条指令的地址。传递数据：A必须能够向B提供一个或多个参数B必须能够向A中返回一个值。分配和释放内存：在开始时，B可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。（假设函数A调用函数B）hello.C涉及的函数操作有：main函数，printf，exit，sleep，getchar函数main函数的参数是argc和argv；两次printf函数的参数恰好是那两个字符串exit参数是1，sleep函数参数是atoi（argv[3]）函数的返回值存储在%eax寄存器中。3.3.9类型转换atoi（argv[3]），将字符串类型转换为整数类型。此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~3.3.x等按照类型和操作进行分析只要hello.s中出现的属于大作业PPT中P4给出的参考C数据与操作，都应解析。3.4本章小结本章简要介绍了编译的概念和作用，以及编译阶段中编译器如何处理各种数据和操作，以及c语言中各种类型和操作所对应的的汇编代码并对hello.c和hello.s进行分析。第4章汇编4.1汇编的概念与作用概念：把汇编语言翻译成机器语言的过程。作用：汇编语言的诞生是由于机器代码难以记忆，所以用助记符代替操作码形成的方便记忆的语言，这种机器不能直接识别。用程序将其翻译为机器语言后，才可以被识别运行。注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。4.2在Ubuntu下汇编的命令4.3可重定位目标elf格式4.3.1ELFHeader以16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解##标题释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量等信息。4.3.2SectionHeaders:节头部表，包含了文件中出现的各个节的语义，包括节的类型、位置和大小等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小，同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。4.3.3.symtab：存放程序中定义和引用的函数和全局变量的信息。name是符号名称，对于可冲定位目标模块，value是符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址。size是目标的大小，type要么是数据要么是函数。Bind字段表明符号是本地的还是全局的。4.3.4重定位节.rela.text中包含.text节的重定位信息，在链接时程序将通过这些信息和代码提供的偏移找到正确的需要调用的函数地址。本程序中，需要重定位的包括.rodata节中的两个数据，全局变量sleepsecs,函数puts,exit,printf,sleep,getchar。分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。4.4Hello.o的结果解析通过对比可以发现，两者汇编代码有一些不同，而这些就是汇编过程实现的操作：1.o文件中每条语句都有了一个偏移量，便于跳转寻址。2去掉了面向程序员的助记符，跳转/调用指令后的函数名/助记符替换为了相对偏移地址。由于尚未进行链接，无法确定函数地址，所以偏移暂时为零。同时，在重定位节中添加相应条目。3为全局变量提供偏移量寻址。由于尚未进行链接，无法确定具体地址，所以偏移暂时为零。同时，添加重定位条目，等待链接。objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。4.5本章小结本章简要介绍了汇编的概念和作用，提供了Ubuntu下汇编的命令。对hello.s进行了汇编，生成了hello.o可重定位目标文件，并且分析了可重定位文件的ELF头、节头部表、符号表和可重定位节，比较了hello.s和hello.o反汇编代码的不同之处。第5章链接5.1链接的概念与作用概念：将各种代码和数据片段收集并合并成一个单一文件的过程，这个文件可以被加载到内存中执行。作用：使分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而实可以分解为更小的、更好管理的模块，可以独立地修改和编译单一模块。注意：这儿的链接是指从hello.o到hello生成过程。5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式以上。通过对比发现多了一个链接信息。分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。5.4hello的虚拟地址空间在edb中打开hello使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。5.5链接的重定位过程分析hello重定位的过程： 重定位节和符号定义链接器将所有类型相同的节合并在一起后，这个节就作为可执行目标文件的节。然后链接器把运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号，当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。重定位节中的符号引用这一步中，连接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。执行这一步，链接器依赖于可重定位目标模块中称为的重定位条目的数据结构。重定位条目当编译器遇到对最终位置未知的目标引用时，它就会生成一个重定位条目。代码的重定位条目放在.rel.txt。通过本图以及对比节头信息可以发现：1增加了一些外部函数。2增加了包括.init,.plt,.fini在内的一些节。3相对偏移地址变为了虚拟内存的地址。链接时，链接器通过符号表和节头了解到.data和.text在每个文件中的偏移和大小，进行合并，然后为新的合并出来的数据和代码节分配内存，并映射虚拟内存地址。最后修改对各种符号的引用，完成重定位。objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。结合hello.o的重定位项目，分析hello中对其怎么重定位的。5.6hello的执行流程使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。5.7Hello的动态链接分析动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。在调用共享库函数时，编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。GNU编译系统使用延迟绑定(lazybinding),将过程地址的绑定推迟到第一次调用该过程时。延迟绑定是通过GOT和PLT实现的。GOT是数据段的一部分，而PLT是代码段的一部分。两表内容分别为：PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。5.8本章小结本章简要介绍了链接的概念和作用以及Ubuntu下的链接命令。并对hello文件查看链接后的文件格式，对虚拟地址分配、重定位、动态链接等并分析。第6章hello进程管理6.1进程的概念与作用概念：操作系统对一个正在运行的程序的一种抽象。作用：一个程序在系统上运行时，操作系统会提供一种，程序在独占这个系统，包括处理器，主存，I/O设备的假象。处理器看上去在不间断地一条一条执行程序中的指令…这些假象都是通过进程的概念实现的。6.2简述壳Shell-bash的作用与处理流程Shell指操作界面，可以接收用户命令并调用相关程序。处理流程如下：读取输入命令并处理得到参数。判断输入命令是内置还是外部命令，内置命令立刻执行，外部命令则调用相关程序。根据后续输入向相应进程发送信号。处理接收到的信号，更新进程状态。6.3Hello的fork进程创建过程（Fork函数再进程的当前位置创建一个新进程，新进程具有与原进程完全相同的状态（除PID）。创建过程如下：为新进程复制父进程的堆栈等数据空间。创建新进程。6.4Hello的execve过程Execve函数在当前进程的上下文中加载并运行一个新程序。当读取文件出现错误时，返回原程序，否则不返回。具体步骤如下：根据第一个参数加载文件，通过启动代码对栈进行设置，并完成控制传递;顺序执行，用第二，三个参数调用main函数6.5Hello的进程执行系统执行进程时，内核可以暂停当前进程，并启用其他进程，这个过程称为调度，而这些进程以及它们的PC值所构成的序列就是逻辑控制流。当进程被执行时，内核代码不断地根据上下文信息，时间片等进行判断，并根据其结果转移控制权，完成调度。上下文信息：指内核重新启动一个被抢占的进程所需要的状态，由通用寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈等构成。时间片：一个进程执行它的控制流的每一时间段。结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。6.6hello的异常与信号处理hello程序出现的异常可能有：中断：在hello程序执行的过程中可能会出现外部I/O设备引起的异常。陷阱：陷阱是有意的异常，是执行一条指令的结果，hello执行sleep函数的时候会出现这个异常。故障：在执行hello程序的时候，可能会发生缺页故障。终止：终止时不可恢复的错误，在hello执行过程可能会出现DRAM或者SRAM位损坏的奇偶错误。在发生异常时会发出信号，比如缺页故障会导致OS发生SIGSEGV信号给用户进程，而用户进程以段错误退出。常见信号种类如下表所示。按下Ctrl+c的结果，在键盘上输入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况是终止前台作业按下ctrl-z的结果，输入ctrl-z默认结果是挂起前台的作业，hello进程并没有回收，而是运行在后台下，运行其他命令如下： 按下回车程序会一直执行直达用controlc停止为止。hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。6.7本章小结本章简要介绍了进程的概念和作用以及shell的处理流程。同时对hello文件分析了fork、execve、进程执行、异常以及信号处理过程。第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：由程序产生的与段相关的偏移地址。分为段标识符和段内偏移。线性地址：到物理地址的过渡，分为目录索引，页索引和页内偏移。虚拟地址：为更有效地管理内存并减少不同程序间内存冲突的问题，现代系统提供的一种对主存的抽象概念。物理地址：在主存中的地址。结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。7.2Intel逻辑地址到线性地址的变换-段式管理1．观察段选择符，0则转换的是GDT（全局）中的段，否则就是LDT（局部）中的段。2．根据相应寄存器，找到其起始地址。3．通过段标识符找到对应的基地址。4．用基地址加上偏移，得到线性地址。7.3Hello的线性地址到物理地址的变换-页式管理1．根据线性地址前十位找到对应页表的地址。2．根据线性地址中间十位找到对应页的起始地址。3．页的起始地址加上线性地址最后十二位，得到物理地址。7.4TLB与四级页表支持下的VA到PA的变换将VA分为四段。依次通过每段地址找到对应的PML4,PGD,PMD,PTE表，找到对应地址，组合得到PA。7.5三级Cache支持下的物理内存访问物理地址分为标记，组索引和块偏移。首先，在L1中匹配组索引位，若匹配成功，则根据标记和偏移的匹配结果决定缺失或是命中。若组索引匹配不成功，则进入下一级cache，重复直至进入内存。7.6hello进程fork时的内存映射Fork会为新进程（子进程）复制一个与父进程完全相同只读数据空间，并为其分配另一片内存和虚拟地址。分配时会将其标记为私有，防止过程中被父进程影响。7.7hello进程execve时的内存映射调用Execve时，系统首先删除了当前进程中用户部分已有的结构，然后映射私有区域（建立新的文件结构，包括.data在内的各种节），共享区域（当前进程的动态链接），并设置PC。7.8缺页故障与缺页中断处理1．段错误：地址不合法，即无法匹配到已有的区域结构中；2．非法访问：没有应有的读写权限；3．正常缺页：选择一页进行替换。7.9动态存储分配管理分配器有两种风格，显示分配器（要求应用显式地释放任何已分配的块），隐式分配器（要求分配器检测一个已分配块是否仍然需要，不需要则释放）。分配策略：1．空闲链表：（1）隐式：在每块的头，尾部增加32位存储块大小，以及是否空闲。（2）显式：在隐式的基础上在头部增加对前后空闲块的指针。（3）分离：同时维护多个空闲链表。2．带边界标记的合并：利用每块头尾的大小和空闲状态信息合并空闲块。3．无合适空闲块时，申请额外的堆空间。Printf会调用malloc，请简述动态内存管理的基本方法与策略。7.10本章小结本章简要介绍了hello的存储器的地址空间，介绍了四种地址空间的差别和地址的相互转换。同时介绍了hello的四级页表的虚拟地址空间到物理地址的转换。阐述了三级cashe的物理内存访问、进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件包括：1.普通文件（Is-al第一个属性为“-”）2.目录文件（Is-al第一个属性为“d”）3.设备文件设备管理：unixio接口包括：1.开关文件2.读写文件3.改变当前文件的位置8.2简述UnixIO接口及其函数 open：打开已存在的文件或建立新文件。close：关闭已打开的文件，会返回结果状态。ssize_tread：在文件的指定位置赋值。8.3printf的实现分析Vsprintf：接受一个格式化的命令，并把制定的匹配的参数格式化输出。Write：把字符串中n个元素的值写到终端（n为第二个参数）系统调用：显示格式化的字符串。https://www.cnblogs.com/pianist/p/3315801.htmlsyscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。于是我们的打印字符串就显示在了屏幕上。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章简要介绍了hello文件的I/O管理，包括设备管理方法，接口函数，读写函数的实现分析。结论Hello从原程序.c文件经过预处理，编译，汇编，链接得到了可执行文件。执行时，通过os对命令的处理结果，hello被分配到了自己的存储空间，虚拟内存地址和时间片。过程中，I/O不断接受信号并对其进行处理。运行结束后，内核清除已分配的数据空间，还原系统状态。附件列出所有的中间产物的文件名，并予以说明起作用。Hello.c:源文件Hello.i:预处理输出文件Hello.s:编译输出文件Hello.o：汇编输出文件Hello：链接输出文件参考文献为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 
第298篇文章[]
Java正则表达式的元字符 Lab3需要对字符串进行匹配，这里整理了一下元字符： 1.限定符 2.选择匹配符 3.分组组合和反向引用符 4.特殊字符 5.字符匹配符 6.定位符 \\转义号[]可接受的字符列表[^]不可接受的字符列表-连字符.匹配除\n以外任意字符\\d匹配单个数字字符\\D匹配单个非数字字符\\w匹配单个数字、大小写字母字符\W匹配单个非数字、大小写字母字符|匹配“|”之前或之后的表达式*指定的字符重复0/n次+指定的字符重复1/n次？指定的字符重复0/1次｛n｝只能输入n个字符｛n,｝指定至少n个匹配｛n,m｝指定至少n个但不多于m个匹配^指定开始字符$指定结束字符\\b匹配目标字符串的边界\bB匹配目标字符串的非边界\f匹配换页符\n匹配换行符\r匹配回车 
第299篇文章[5]
CS大作业 
第300篇文章[]
Java8中的stream(一点点) Stream是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。不会去存储对象 创建Steam： 由数组创建流，通过Arrays中的静态方法stream()创建数据源 static<T>Stream<T>stream(T[]array):返回一个流。 publicvoidstream(){ List<StreamObject>list=newArrayList(); Stream<StreamObject>stream=list.stream(); Stream<StreamObject>stream1=list.parallelStream(); } 由数组创建流，通过Arrays中的静态方法stream()创建数据源 static<T>Stream<T>stream(T[]array):返回一个流。 publicvoidstream2(){ Integer[]integer=newInteger[20]; Stream<Integer>stream=Arrays.stream(integer); } Stream中间操作： 筛选与切片： 1.filter(Predicatep)接收Lambda表达式，从流中排除某些元素 2.distinct()筛选，通过流所生成元素的hashCode()和equals()去除重复元素 3.limit(longmaxSize)截断流，使其元素不超过给定数量 4.skip(longn)跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补 映射： 1.map(Functionf)接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素 2.mapToDouble(ToDoubleFunctionf)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream 3.mapToInt(ToIntFunctionf)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream 排序： 1.sorted()产生一个新流，其中按自然顺序排序 2.sorted(Comparatorcomp)产生一个新流，其中按比较器顺序排序 应用： ​ publicstaticvoidtest(){ List<StreamObject>list=Arrays.asList( newStreamObject(1,"学","习","烂"), newStreamObject(2,"学","习","烂"), newStreamObject(2,"学","习","烂"), newStreamObject(3,"学","习","烂") ); Stream<StreamObject>stream= list.stream() .filter(StreamObject::method) .distinct() .limit(2) .skip(1); stream.forEach(System.out::println); System.out.println(list); } ​ 这里控制台会输出ID等于3的那条数据,在我们输出list的时候，我们发现list的数据并没有收到改变。 
第301篇文章[]
Java设计模式-装饰器模式 对于开发中不同级别的管理员，如何在管理员这个实体的基础上动态的去设置他们的权限范围呢？我们把权限当作一种挂饰，这种挂饰放在不同的管理员身上就代表他们是什么管理员，那么这种挂饰如何放到管理员身上呢？这就需要装饰器模式了。看一下概念： 装饰器模式（DecoratorPattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 首先定义一个管理员接口，实现这个接口证明你就是一个管理员： interfaceComponent{ voididentity(); } 基础管理员： classAdministratorimplementsComponent{ @Override publicvoididentity(){ System.out.println("无权限管理员"); } } 需要写一个装饰器负责把权限装饰到这个现有的管理员身上。首先肯定要有这个管理员的实例(对象)，所以这个装饰器的构造器中我们要传入一个管理员，其次如果想不破坏管理员的原有结构功能，那么我们肯定要实现管理员这个接口，放入传入具体管理员实例的方法，这样才能保证结构和功能： classDecoratorimplementsComponent{ protectedComponentcomponent; publicDecorator(Componentcomponent){ this.component=component; } @Override publicvoididentity(){ component.identity(); } } 通过装饰器，把权限这个挂饰挂在管理员身上，以此来形成负责不同模块的管理员工。这里我们来实现两个挂饰：写挂饰中挂饰通过装饰器去挂，那么我们肯定要继承这个装饰器，在重写它的方法中动态的增加权限。 classDeAextendsDecorator{ publicDeA(Componentcomponent){ super(component); } @Override publicvoididentity(){ this.component.identity(); personnelFile(); } publicvoidpersonnelFile(){ System.out.println("负责A"); } } classDeBextendsDecorator{ publicDeB(Componentcomponent){ super(component); } publicvoidadministration(){ System.out.println("负责B"); } @Override publicvoididentity(){ this.component.identity(); administration(); } } 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 
第302篇文章[]
Lab1中turtle凸包算法的实现 lab1中P2要求实现：给定一组点，计算凸包，即包含一组输入点中的所有点的最小凸集。使用Jarvis步进法，思路：纵坐标最小的那个点一定是凸包上的点，比如下面中的P0。从P0开始，按逆时针的方向，逐个找凸包上的点，每前进一步找到一个点，所以叫作步进法。利用夹角。假设现在已经找到P0,P1,P2了，要找下一个点：剩下的点分别和P2组成向量，设这个向量与向量P1P2的夹角为β。当β最小时就是所要求的下一个点了，此处为P3。 publicstaticSet<Point>convexHull(Set<Point>points){ if(points.size()<=2){ returnpoints; } Set<Point>convexHullPoints=newHashSet<Point>(); Pointa=newPoint(Double.MAX_VALUE,Double.MAX_VALUE); for(Pointi:points){ if(i.y()<a.y()) a=i; } PointcurPoint=a,minPoint=null,lastPoint=a; doublex1=0.0,y1=-1.0; do{ convexHullPoints.add(curPoint); doubleminTheta=Double.MAX_VALUE,x2=0.0,y2=0.0; for(Pointi:points){ if((!convexHullPoints.contains(i)||i==a)&&(i!=lastPoint)){ doublex3=i.x()-curPoint.x(),y3=i.y()-curPoint.y(); doubleTheta=Math .acos((x1*x3+y1*y3)/Math.sqrt(x1*x1+y1*y1)/Math.sqrt(x3*x3+y3*y3)); if(Theta<minTheta||(Theta==minTheta&&x3*x3+y3*y3>Math.pow(i.x()-minPoint.x(),2) +Math.pow(i.y()-minPoint.y(),2))){ minPoint=i; minTheta=Theta; x2=x3; y2=y3; } } } x1=x2; y1=y2; lastPoint=curPoint; curPoint=minPoint; }while(curPoint!=a); returnconvexHullPoints; } 
第303篇文章[]
关于AF、RI 思考一下两个值域之间的关系︰ 表示域(spaceofrepresentationvalues)里面包含的是值具体的实现实体。在简单的情况下，一个抽象类型只需要实现为单个的对象，但是更常见的情况是使用一个很多对象的网络。 抽象域里面包含的则是类型设计时支持使用的值。这些值是由表示域"抽象/想象"出来的，也是使用者关注的。例如，一个无限整数对象的抽象域是整个整数域，但是它的实现域可能是一个由原始整数类型〈有限)组成的数组实现的，而使用者只关注抽象域。 但是，实现者是非常"在意"表示域(和抽象域）)的，因为实现者的责任就是实现表示域到抽象域的转换（映射)。 选择用字符串来表示一个字符集合︰ publicclasscharset{ privatestrings;  } 如上图所示，表示域R包含的是我们的实现实体（字符串)，而抽象域里面是抽象类型表示的字符集合，我们用箭头表示这两个域之间的映射关系。这里要注意几点︰ ·每一个抽象值都是由表示值映射而来。我们之前说过实现抽象类型的意义在于支持对于抽象值的操作，即我们需要能够创建和管理所有的抽象值，因此它们也必须是可表示的。 ·一些抽象值是被多个表示值映射而来的。这是因为表示方法并不是固定的，我们可以灵活的表示一个抽象值。 ·不是所有的表示值都能映射到抽象域中。在上面这个例子中，"abbc"就没有被映射。因为我们已经确定了表示值的字符串中不能含有重复的字符 ―这样我们的remove方法就能在遇到第一个对应字符的时候停止，因为我们知道没有重复的字符。 由于我们不可能对每一个映射一一解释，为了描述这种对应关系和这两个域，我们再定义两个概念∶抽象函数abstractionfunction是表示值到其对应的抽象值的映射∶ AF:R→A 快照图中的箭头表示的就是抽象函数，可以看出，这种映射是满射，但不一定是单射(不一定是双射)。表示不变量repinvariant是表示值到布尔值的映射︰ Rl:R-boolean 对于表示值r，当且仅当r被AF映射到了A，Rl(r)为真。换句话说，RI告诉了我们哪些表示值是"良好组织"的(能够去表示A中的抽象值)，在下图中，绿色表示的就是Rl(r)为真的部分，AF只在这个子集上有定义。 对同一个定义域，有不同的表示不变量 publicclassCharset{ privatestrings;llRepinvariant: lls.length()iseven lls[0]<=s[1]<= <=s[s.length()-1]llAbstractionfunction: llAF(s)=unionof{c\s[2i]<=c<=s[2i+1]}l/ forall0<=i<s.length()/2   } 总之，一个ADT的实现不仅是选择表示域(规格说明)和抽象域〈具体实现)，同时也要决定哪一些表示值是合法的(表示不变量)，合法表示会被怎么解释/映射(抽象函数)。 
第304篇文章[]
对象和对象的引用 复习的时候突然被对象和对象的引用搞懵了。搜了一圈，终于搞明白了。 先建立一个类 publicclassTest{ //默认构造方法 publicTest{ } } 然后用这个类new一个对象 Testt=newTest(); 右边的“newTest”，是创建一个Test对象。 而左边的“Testt”创建了一个Test类引用变量，是用来指向Test对象的对象引用。 也可以写成： Testt;//创建对象引用 t=/*将对象引用指向对象*/newTest();//创建对象 //一个对象引用可以指向一个对象 Testt；//一个对象引用 Test=newTest();//一个对象引用指向一个对象 也可以多个对象引用指向一个对象 Testt1，t2，t3;//创建多个对象引用 t1=newTest(); t2=t1; t3=t2;//创建对象，并被多个对象引用指向 参考原文：https://blog.csdn.net/qq_26805137/article/details/52945688 牛(｡◕ˇ∀ˇ◕) 
第305篇文章[]
【新人】编写JUnit测试类有自定义类cannotberesolvedtoatype 今天在编写某实验的测试代码时，尝试实例化对象时出现了Edgecannotberesolvedtoatype的 错误。但这个类是有的，也已经import过了，就很令人费解。 后来请教了同学，了解到是项目的结构出了问题。之前的结构是这样的： 可以看到测试文件都是放在P1文件夹下，它们的package写的都是P1.graph/P1.poet，而src里的源文件都没有放在P1里，其package为graph/poet。 同学说，将测试文件与源文件的包名保持一致，这样测试代码就相当于可以直接看到源文件里的东西了。 于是我将结构进行修改： 果然通过了，同时还省去了一部分import。 非常的好用。 后续再学习学习原理。 
第306篇文章[]
在Eclipse中使用git传本地仓库到远程仓库 在后两次课程实验中，我都是使用Eclipse中的git操作上传代码到GitHub，现在课程结束了，我简单记录一下。 1、首先打开一个项目，右击，点击Team >ShareProject 2、选择Git 3、在该界面创建本地仓库 4、再次右键项目，Team >Commit 5、在1处填写提交信息，2处选择提交文件，完成后点击Commitandpush 6、在这里填写远程仓库的URL等信息。传Github在Authentication处填写用户名和密码 7、填写完成后继续，点击Finish即可。 之后每当有改动或增加内容，右键项目Team >Commit，重复一波即可，非常的方便，非常的银杏。 更多操作可以移步这里：https://www.jianshu.com/p/acb00e4c7301 
第307篇文章[1]
HIT-CSAPP2021大作业 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 xxxxxxxxxx 班 级 xxxxxx 学 生 xxx 指导教师 xxx 计算机科学与技术学院 2021年6月 摘 要 本文以hello小程序为例，通过对其在Linux系统下的P2P、020过程的分析梳理，来完成对计算机系统课程的整体内容的梳理，借由Ubuntu虚拟机，gcc、gdb、edb等工具的操作过程，体现个人对计算机系统课程的学习体会与理解，展示各人的收获。 关键词：hello程序的一生；计算机系统；Linux；Ubuntu 目 录 第1章概述-4- 1.1Hello简介-4- 1.2环境与工具-4- 1.3中间结果-5- 1.4本章小结-5- 第2章预处理-6- 2.1 预处理的概念与作用-6- 2.2在Ubuntu下预处理的命令-6- 2.3Hello的预处理结果解析-6- 2.4本章小结-7- 第3章编译-8- 3.1编译的概念与作用-8- 3.2在Ubuntu下编译的命令-8- 3.3Hello的编译结果解析-8- 3.3.1字符串-9- 3.3.2全局函数-10- 3.3.3赋值操作-10- 3.3.4算术操作-10- 3.3.5关系操作-11- 3.3.6控制转移指令-11- 3.3.7函数操作-12- 3.3.8类型转换-13- 3.4本章小结-13- 第4章汇编-14- 4.1汇编的概念与作用-14- 4.2在Ubuntu下汇编的命令-14- 4.3可重定位目标elf格式-14- 4.4Hello.o的结果解析-16- 4.5本章小结-17- 第5章链接-18- 5.1链接的概念与作用-18- 5.2在Ubuntu下链接的命令-18- 5.3可执行目标文件hello的格式-18- 5.4hello的虚拟地址空间-20- 5.5链接的重定位过程分析-22- 5.6hello的执行流程-23- 5.7Hello的动态链接分析-23- 5.8本章小结-24- 第6章hello进程管理-25- 6.1进程的概念与作用-25- 6.2简述壳Shell-bash的作用与处理流程-25- 6.3Hello的fork进程创建过程-25- 6.4Hello的execve过-25- 6.5Hello的进程执行-26- 6.6hello的异常与信号处理-26- 6.7本章小结-30- 第7章hello的存储管理-31- 7.1hello的存储器地址空间-31- 7.2Intel逻辑地址到线性地址的变换-段式管理-31- 7.3Hello的线性地址到物理地址的变换-页式管理-31- 7.4TLB与四级页表支持下的VA到PA的变换-32- 7.5三级Cache支持下的物理内存访问-34- 7.6hello进程fork时的内存映射-35- 7.7hello进程execve时的内存映射-35- 7.8缺页故障与缺页中断处理-35- 7.9动态存储分配管理-35- 7.10本章小结-36- 第8章hello的IO管理-37- 8.1Linux的IO设备管理方法-37- 8.2简述UnixIO接口及其函数-37- 8.3printf的实现分析-37- 8.4getchar的实现分析-37- 8.5本章小结-38- 结论-38- 附件-39- 参考文献-40- 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P：FromProgramtoProcess Program：在编辑器中编写hello.c的具体代码内容 Process：在Linux中，先通过预处理器（cpp）修改原始的c文件得到另一个以.i为文件扩展名的C程序；接着，编译器（ccl）将文本文件hello.i翻译成hello.s，这个文件包含一个汇编语言程序；然后，汇编器（as）将.s文件翻译成机器语言指令，将这些指令打包成可重定位目标程序的格式，并将结果保存在hello.o文件中；最后链接器（ld）负责处理.o文件的合并，来实现函数的正确调用，并得到最后的可执行文件hello，可以被加载到内存中由系统执行。 020：FromZerotoZero shell接受到./hello的指令之后就调用fork开辟进程，execve映射虚拟内存，进入程序入口后程序开始载入物理内存。之后程序由CPU控制其逻辑流的运行，运行结束后，shell父进程负责回收资源，这就是hello的020. 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 硬件环境： 软件环境： VirtualBox；Ubuntu20.04LTS64位 开发工具： VisualStudio201964位；CodeBlocks；vim+gcc 调试工具： gdb；edb 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 中间结果文件文件作用hello.i预处理得到的文件ASCII码的中间文件hello.sASCII汇编语言文件hello.oas得到可重定位目标文件Disas_hello.s反汇编得到的文本文件elf.txthello.o的elf文件hellold得到可执行目标文件hello_5.3.elfhello的elf文件hello_objdump.shello的反汇编文件 1.4本章小结 本章简单阐述了Hello的P2P，020的整个过程，介绍了编写本文过程所处的软硬件环境和生成的中间文件。 第2章预处理 2.1 预处理的概念与作用 预处理的概念： 预处理器（cpp）根据以字符#开头的命令，修改原始的C程序，试图解释为预处理指令(preprocessingdirective)。 ISOC/C++要求支持的预处理指令包括： #if、#ifdef、#ifndef、#else、#elif、#endif（条件编译）、#define（宏定义）、#include（源文件包含）、#line（行控制）、#error（错误指令）、#pragma（和实现相关的杂注）以及单独的#（空指令）。 预处理指令一般被用来使源代码在不同的执行环境中被方便的修改或者编译。 预处理的作用： 宏定义：宏定义将代码中的宏名与实际字符串进行替换，可以增强代码的可读性；文件包含处理：将include头文件复制到#处替换，减少重复的工作，加强代码模块化；条件编译处理：决定哪些具体代码会被编译处理。 2.2在Ubuntu下预处理的命令 cpphello.c>hello.i 截图2-1 截图2-2 2.3Hello的预处理结果解析 浏览hello.i文件可发现，只有28行的源码已经扩展至3065行，hello.i程序的开始是c程序头文件stdio.hunistd.hstdlib.h的依次展开，这三个头文件都被复制进来了。 截图2-3 2.4本章小结 本章简单介绍的与处理的概念及作用，完成了对hello.c文件的预处理操作，并简单解析了hello.i的预处理结果。 第3章编译 3.1编译的概念与作用 编译的概念：编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。其以高级程序设计语言书写的源程序作为输入，而以汇编语言或机器语言表示的目标程序作为输出。这个过程称为编译，同时也是编译的作用。 编译的作用：编译程序的基本功能是把源程序(高级语言)翻译成目标程序。除了基本功能之外，编译程序还具备语法检查、调试措施、修改手段、覆盖处理、目标程序优化、不同语言合用以及人际联系等重要功能。 3.2在Ubuntu下编译的命令 截图3-1 3.3Hello的编译结果解析 截图3-4、3-5 局部变量i main函数声明了一个局部变量i，编译器进行编译的时候会将局部变量i存在堆栈中。如图所示，局部变量i放在栈上-4（%rbp）的位置。 截图3-6 main函数 参数argc作为用户传给main的参数存放在堆栈中。 立即数 立即数直接体现在汇编代码中 数组char*argv[] 数组char*argv[]是作为main函数的第二个参数，其中的每个元素都是一个指向字符类型的指针。数组的起始地址存放在栈中-32（%rbp）的位置，被两次调用将参数传给printf函数 截图3-7 其中： movq-32（%rbp）,%rax表示数组argv存放的位置-32（%rbp） movq（%rax），%rdx movq（%rax），%rax分别获取argv[1]和argv[2]的地址 movq（%rax），%rsi 3.3.2全局函数 由c程序可知，hello.c声明了一个全局函数intmain(intargc,char*argv[])，经过编译之后，main函数中使用的字符串常量也被存放在数据区。 截图3-8 这行汇编代码说明main函数是全局函数。 3.3.3赋值操作 hello.c程序中的赋值操作为i=0 该操作在汇编代码中由mov指令实现，具体为： movb:一个字节 movw：两个字节 movl：四个字节 movq：八个字节 3.3.4算术操作 hello.c程序中的算术操作为：i++。因为i为int类型，故汇编代码只用addl就能实现其他的操作有 指令效果leaqS,DD=&SINCDD+=1DECDD-=1NEGDD=-DADDS,DD=D+SSUBS,DD=D-S 3.3.5关系操作 （1）argc!=3;是在一条件语句中的条件判断：argc!=3，进行编译时，这条指令被编译为：cmpl$3,-20(%rbp)，同时这条cmpl的指令还有设置条件码的作用，当根据条件码来判断是否需要跳转到分支中。 截图3-9 （2）i < 8，在hello.c作为判断循环条件，在汇编代码被编译为：cmpl$9，-4(%rbp)，计算i-7然后设置条件码，为下一步jle利用条件码进行跳转做准备。 截图3-10 3.3.6控制转移指令 首先设置条件码，然后根据条件码来进行控制转移。hello.c中有以下控制转移指令： 判断i是否为3，如果i等于3，则不执行if语句，否则执行if语句： 截图3-11 for(i = 0;i < 8;i++)，通过每次判断i是否满足小于8来判断是否需要跳转至循环语句中： 截图3-12 第一处画圈：i赋初值0，然后无条件跳转至判断条件的代码中 第二处画圈：判断i是否符合循环的条件，符合直接跳转至循环体的内部，即L4 3.3.7函数操作 调用函数时有以下操作： （假设函数P调用函数Q） （1）传递控制：进行过程Q的时候，程序计数器设置为Q的代码的起始地址；返回时，把程序计数器设置为P中调用Q后面那条指令的地址。 （2）传递数据：P能够向Q提供一个或多个参数，而Q能够向P中返回一个返回值。 （3）分配和释放内存：开始时，Q可能需要为局部变量分配空间，而在返回前需释放这些空间。 hello.c程序中涉及的函数操作有： main函数，printf，exit，sleep，getchar函数 main函数的参数是argc和argv；两次printf函数的参数恰好是那两个字符串 exit参数是1，sleep函数参数是atoi（argv[3]） 函数的返回值存储在%eax寄存器中。 3.3.8类型转换 hello.c中涉及的类型转换是：atoi（argv[3]），将字符串类型转换为整数类型其他的类型转换还有int、float、double、short、char之间的转换。 3.4本章小结 本章主要阐述了编译阶段中编译器是如何处理各种数据和操作的，以及简单分析了c语言中各种类型和操作所对应的的汇编代码。 第4章汇编 4.1汇编的概念与作用 汇编的概念：驱动程序运行汇编器as，将汇编语言翻译成机器语言的过程称为汇编，同时这个机器语言文件也是可重定位目标文件。 汇编的作用：汇编是将高级语言转化为机器可直接识别执行的代码文件的过程，汇编器将.s汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码。 4.2在Ubuntu下汇编的命令 截图4-1 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 截图4-2 ELF头：包含了系统信息、编码方式、ELF头大小、节的大小和数量等信息。 截图4-3 节头部表：描述了.o文件中出现的各个节的类型、位置、所占空间大小等信息。 截图4-4 重定位节：表述了各个段引用的外部符号等，在链接时，需要通过重定位节对这些位置的地址进行修改。链接器会通过重定位条目的类型判断该使用什么养的方法计算正确的地址值，通过偏移量等信息计算出正确的地址。 hello.c需要重定位的信息有：.rodata中的模式串、puts、exit、printf、slepsecs、sleep、getchar等符号。 截图4-5 符号表：symtab是一个符号表，负责存放在程序中定义和引用的函数和全局变量的信息。 截图4-6 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 截图4-7 截图4-8 数的表示：hello.s中的操作数时十进制，hello.o反汇编代码中的操作数是十六进制。分支转移：跳转语句之后，hello.s中是.L2和.LC1等段名称，而反汇编代码中跳转指令之后是相对偏移的地址，即间接地址。函数调用：hello.s中，call指令使用的是函数名称，而反汇编代码中call指令使用的是main函数的相对偏移地址。因为函数只有在链接之后才能确定运行执行的地址，因此在.rela.text节中为其添加了重定位条目。 4.5本章小结 本章对hello.s的结果进行了阐述，分析了可重定位文件的ELF头、节头部表、符号表和可重定位节，比较了hello.s和hello.o反汇编代码的区别，分析了机器语言的构成与汇编语言的映射关系。 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种不同文件的代码和数据部分收集（符号解析和重定位）起来并组合成一个单一文件的过程。 链接的作用：令源程序节省空间而未编入的常用函数文件进行合并，生成可以正常工作的可执行文件。这令分离编译成为可能，节省了大量的工作空间。 5.2在Ubuntu下链接的命令 指令： ld -ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 截图5-1 5.3可执行目标文件hello的格式 指令： ELF头：hello的文件头和hello.o文件头的不同之处如下图标记所示，Type类型为EXEC表明hello是一个可执行目标文件，有27个节头。 截图5-2 节头：描述各个节的大小、偏移量和其他属性。链接器链接时，会将各个文件的相同段合并成一段，并且根据该段的大小以及偏移量重新设置各个符号的地址。 截图5-3 截图5-4 重定位节 截图5-5 符号表 截图5-6 5.4hello的虚拟地址空间 在edb中加载hello可执行文件 截图5-7 观察edb的DataDump窗口。窗口显示虚拟地址由0x400000开始，到0x400fff结束，这之间的每一个节对应5.3中的每一个节头表的声明。 截图5-8 观察edb的Sympols Viewer，发现确实从虚拟地址从0x400000开始和5.3节中的节头表是对应的。 截图5-9 根据5.3中的的节头，可以在edb中找到各个节的信息。比如.rodata节，虚拟地址开始于0x402000，大小为0x2f 截图5-10 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 指令： 截图5-11 hello与hello.o的不同： 截图5-12 hello中增加了.init和.plt节，和一些节中定义的函数。hello中链接加入了在hello.c中用到的如exit、printf、sleep、getchar等函数。hello反汇编文件中的地址是虚拟地址，而hello.o反汇编节中的是相对偏移地址。hello中无hello.o中的重定位条目，并且跳转和函数调用的地址在hello中都变成了虚拟内存地址。对于hello.o的反汇编代码，函数只有在链接之后才能确定运行执行的地址，因此在.rela.text节中为其添加了重定位条目。 链接的过程： 链接就是链接器（ld）将各个目标文件（各种.o文件）组装在一起，文件中的各个函数段按照一定规则累积在一起。 链接的重定位过程说明： 要合并相同的节，确定新节中所有定义符号在虚拟地址空间中的地址，还要对引用符号进行重定位（确定地址），修改.text节和.data节中对每个符号的引用（地址），而这些需要用到在.rel_data和.rel_text节中保存的重定位信息。 5.6hello的执行流程 截图5-13 子程序地址： 7efbff4d8ea07efbff4e7630004004c0004004c0004004a000400500004004d0004004f07efbff122120 5.7Hello的动态链接分析 对于动态共享链接库中PIC函数，编译器没有办法预测函数的运行时地址，所以需要为其添加重定位记录，并等待动态链接器处理。为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT和全局偏移量表GOT实现函数的动态链接。其中GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。 在elf文件中可以找到： 截图5-14 edb执行init之前的地址： 截图5-15 edb在执行init之后的地址： 截图5-16 GOT表位置在调用dl_init之前0x600920后的16个字节均为0，调用后发生了变化。 之后的函数调用时，首先跳转到PLT执行.plt中逻辑，第一次访问跳转时，GOT地址为下一条指令，将函数序号压栈，然后跳转到PLT[0]，在PLT[0]中将重定位表地址压栈，然后访问动态链接器，在动态链接器中使用函数序号和重定位表确定函数运行时地址，重写GOT，再将控制传递给目标函数。之后如果对同样函数调用，第一次访问跳转直接跳转到目标函数。 5.8本章小结 本章温习了在linux中链接的过程。通过查看hello的虚拟地址空间，对比hello与hello.o的反汇编代码，进一步掌握了链接与中重定位的过程；遍历了整个hello的执行过程，在最后对hello进行了动态链接分析 第6章hello进程管理 6.1进程的概念与作用 进程的概念： 进程是执行中程序的抽象，是一个执行中程序的实例。 进程的作用： 能够实现计算机并行实现不同任务的构想，使得程序的模式切换更加自如迅速，效率更高。 进程提供给应用程序的关键抽象：一个独立的逻辑控制流，如同程序独占处理器；一个私有的地址空间，如同程序独占内存系统。 6.2简述壳Shell-bash的作用与处理流程 作用： 解释命令，连接用户和操作系统以及内核。 流程： ·终端进程读取用户由键盘输入的命令行。 ·分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量 ·检查第一个(首个、第0个）命令行参数是否是一个内置的shell命令 ·如果不是内部命令，调用fork()创建新进程/子进程 ·在子进程中，用步骤2获取的参数，调用execve()执行指定程序。 ·如果用户没要求后台运行(命令末尾没有&号）否则shell使用waitpid（或wait…等待作业终止后返回。 ·如果用户要求后台运行(如果命令末尾有&号），则shell返回； 6.3Hello的fork进程创建过程 在shell的命令行，用户完成输入命令。shell在解析输入命令之后创建argv、envp等参数列表，以及参数个数argc。shell作为父进程创建新子进程。子进程与父进程拥有完全相同的虚拟内存地址以及副本，但虚拟地址确是独立的，而且PID也不相同。 6.4Hello的execve过 fork之后子进程调用execve函数在当前进程的上下文中加载并运行一个新程序即hello程序。execve加载并运行可执行目标文件，且带参数列表argv和环境变量列表envp，并将控制传递给main函数。 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 逻辑控制流：一系列程序计数器PC的值的序列叫做逻辑控制流，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 用户模式和内核模式：shell使得用户可以有机会修改内核，所以需要设置一些防护措施来保护内核，如限制指令的类型和可以作用的范围。 上下文切换：上下文就是内核重新启动一个被抢占的进程所需要的状态，是一种比较高层次的异常控制流。 开始Hello运行在用户模式，收到信号后进入内核模式，运行信号处理程序，之后再返回用户模式。运行过程中，cpu不断切换上下文，使运行过程被切分成时间片，与其他进程交替占用cpu，实现进程的调度。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 hello的异常： 1）中断：来自处理器外部的I/O设备的信号的结果。 键盘上敲击CTRL-C或者CTRL-Z 陷阱：有意的，执行指令的结果（例如：系统调用） 产生的信号： SIGINT,SIGSTP,SIGCONT,SIGWINCH 运行截图： Ctrl+C（截图6-1） Ctrl+Z（截图6-2） Ctrl+Z后ps、jobs（截图6-3） 截图6-4 截图6-5 截图6-6 截图6-7 Pstree（截图6-8） fg（截图6-9） kill（截图6-10） 6.7本章小结 本章概述了进程的概念，简要介绍了shell处理过程的方式，介绍了fork和execve两个函数的执行过程以及信号异常的处理。 第7章hello的存储管理 7.1hello的存储器地址空间 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 逻辑地址：格式为“段地址:偏移地址”，是CPU生成的地址，在内部和编程使用，并不唯一。 物理地址：加载到内存地址寄存器中的地址，内存单元的真正地址。CPU通过地址总线的寻址，找到真实的物理内存对应地址。在前端总线上传输的内存地址都是物理内存地址。 虚拟地址：有时我们也把逻辑地址称为虚拟地址。因为与虚拟内存空间的概念类似，逻辑地址也是与实际物理内存容量无关的，是hello中的虚拟地址。 物理地址：指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么hello的线性地址会使用页目录和页表中的项变换成hello的物理地址；如果没有启用分页机制，那么hello的线性地址就直接成为物理地址了。 7.2Intel逻辑地址到线性地址的变换-段式管理 分段功能在实模式和保护模式下有所不同。 实模式：逻辑地址=线性地址=实际的物理地址。段寄存器存放真实段基址，同时给出32位地址偏移量，则可以访问真实物理内存。 保护模式：线性地址还需要经过分页机制才能够得到物理地址，线性地址也需要逻辑地址通过段机制来得到。 段寄存器用于存放段选择符，通过段选择符可以得到对应段的首地址。处理器在通过段式管理寻址时，首先通过段描述符得到段基址，然后与偏移量结合得到线性地址，从而得到了虚拟地址。 7.3Hello的线性地址到物理地址的变换-页式管理 将各进程的虚拟空间划分成若干个长度相等的页(page)，页式管理把内存空间按页的大小划分成片或者页面（pageframe），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。 7.4TLB与四级页表支持下的VA到PA的变换 使用K级页表的地址翻译 截图7-1 四级页表翻译 截图7-2 针对corei7页表翻译 截图7-3 Corei7 1-3级页表条目格式 截图7-4 其中，每个条目引用一个4KB子页表: 1）P:子页表在物理内存中(1)不在(0). 2）R/W:对于所有可访问页，只读或者读写访问权限. 3）U/S:对于所有可访问页，用户或超级用户(内核)模式访问权限. 4）WT:子页表的直写或写回缓存策略. 5）A: 引用位(由MMU在读或写时设置，由软件清除). 6）PS: 页大小为4KB或4MB(只对第一层PTE定义). 7）Pagetablephysicalbaseaddress:子页表的物理基地址的最高40位(强制页表4KB对齐) 8）XD:能/不能从这个PTE可访问的所有页中取指令。 Corei7第4级页表条目格式 截图7-5 P:子页表在物理内存中(1)不在(0). R/W:对于所有可访问页，只读或者读写访问权限. U/S:对于所有可访问页，用户或超级用户(内核)模式访问权限. WT:子页表的直写或写回缓存策略. A:引用位(由MMU在读或写时设置，由软件清除). D:修改位(由MMU在读和写时设置，由软件清除) Pagetablephysicalbaseaddress:子页表的物理基地址的最高40位(强制页表4KB对齐) XD:能/不能从这个PTE可访问的所有页中取指令. 7.5三级Cache支持下的物理内存访问 1、CPU给出VA 2、MMU用VPN到TLB中找寻PTE，若命中，得到PA；若不命中，利用VPN（多级页表机制）到内存中找到对应的物理页面，得到PA。 3、PA分成PPN和PPO两部分。利用其中的PPO，将其分成CI和CO，CI作为cache组索引，CO作为块偏移，PPN作为tag。 先访问一级缓存，不命中时访问二级缓存，再不命中访问三级缓存，再不命中访问主存，如果主存缺页则访问硬盘 截图7-6 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 删除已存在的用户区域。 映射私有区域：为新程序的代码、数据、.bss和栈区域创建新的区域结构。 映射共享区：hello与系统执行文件链接映射到共享区域。 设置程序计数器PC：设置当前进程上下文中的PC，指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障是一种常见的故障，要访问的主页不在主存，需要操作系统调入才能访问。缺页中断处理函数为do_page_fault函数。 截图7-7 7.9动态存储分配管理 基本方法与策略：通过维护虚拟内存（堆），一种是隐式空闲链表，一种是显式空闲链表。显式空闲链表法是malloc(size_tsize)每次声明内存空间都保证至少分配size_t大小的内存，双字对齐，每次必须从空闲块中分配空间，在申请空间时将空闲的空间碎片合并，以尽量减少浪费。 7.10本章小结 本章主要介绍了hello的存储器的地址空间，介绍了四种地址空间的差别和地址的相互转换。同时介绍了hello的四级页表的虚拟地址空间到物理地址的转换。简要阐述了三级cashe的物理内存访问、进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理以及动态存储分配管理。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件：所有的I/O设备都被模型化为文件，甚至内核也被映射为文件 设备管理：unixio接口：所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 Linux以文件的方式对I/O设备进行读写，将设备均映射为文件。对文件的操作，内核提供了一种简单、低级的应用接口，即UnixI/O接口。 打开文件：intopen(char*filename,intflags,mode_tmode); 关闭文件：intclose(intfd); 读文件：ssize_tread(intfd,void*buf,size_tn); 写文件：ssize_twrite(intfd,constvoid*buf,size_tn); 8.3printf的实现分析 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法、UnixIO接口及函数，简要分析了printf和getchar函数的实现。 结论 hello程序的过程可总结如下： 1、编写代码：用高级语言写.c文件 2、预处理：hello.c经过预编译，拓展得到hello.i文本文件 3、编译：由.i文件生成.s汇编文件 4、汇编：经过汇编，.s文件被翻译为机器语言指令，并打包成可重定位目标程序hello.o 5、链接：将.o可重定位目标文件和动态链接库链接成可执行目标程序hello。P2P过程完成。 6、运行：在shell中输入命令 1）创建子进程：shell嗲用fork为程序创建子进程 2）加载：shell调用execve函数,将hello程序加载到该子进程，映射虚拟内存 3）执行指令：CPU为进程分配时间片，加载器将计数器预置在程序入口点，则hello可以顺序执行自己的逻辑控制流 4）访问内存：MMU将虚拟内存地址映射成物理内存地址，CPU通过其来访问 5）动态内存分配：根据需要申请动态内存 6）信号：shell的信号处理函数可以接受程序的异常和用户的请求 7、终止：执行完成后父进程回收子进程，内核删除为该进程创建的数据结构 至此，hello运行结束。 附件 中间结果文件文件作用hello.i预处理得到的文件ASCII码的中间文件hello.sASCII汇编语言文件hello.oas得到可重定位目标文件Disas_hello.s反汇编得到的文本文件elf.txthello.o的elf文件hellold得到可执行目标文件hello_5.3.elfhello的elf文件hello_objdump.shello的反汇编文件 注：由于后期虚拟机运行突然出现问题，所以最后的附件是在同学的虚拟机下生成的，可能与报告中的截图内容存在一些冲突。 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42. [2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998 [1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL]. Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/ collection/anatmorp. （参考文献0分，缺失-1分） 
第308篇文章[]
2021-06-29 软件构造线程安全 线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。 多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。或者说：一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题。 线程安全问题大多是由全局变量及静态变量引起的，局部变量逃逸也可能导致线程安全问题。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。类要成为线程安全的，首先必须在单线程环境中有正确的行为。如果一个类实现正确(这是说它符合规格说明的另一种方式)，那么没有一种对这个类的对象的操作序列(读或者写公共字段以及调用公共方法)可以让对象处于无效状态，观察到对象处于无效状态、或者违反类的任何不可变量、前置条件或者后置条件的情况。此外，一个类要成为线程安全的，在被多个线程访问时，不管运行时环境执行这些线程有什么样的时序安排或者交错，它必须仍然有如上所述的正确行为，并且在调用的代码中没有任何额外的同步。其效果就是，在所有线程看来，对于线程安全对象的操作是以固定的、全局一致的顺序发生的。 正确性与线程安全性之间的关系非常类似于在描述ACID(原子性、一致性、独立性和持久性)事务时使用的一致性与独立性之间的关系：从特定线程的角度看，由不同线程所执行的对象操作是先后(虽然顺序不定)而不是并行执行的。线程安全的四中策略总结：1.Confinement:限制可变变量共享，线程之间不共享mutable数据类型，将可变数据限制在单一进程内部，避免竞争，不让其他进程直接读写该数据。局部变量总是线程安全的，但如果局部变量是一个对象引用，若该对指向象是可变对象，则必须确定该对象也是线程confine的，不能有其他线程也该对象的引用。2.Immutablity不可变数据类型：使用不可变数据类型和不可变引用，避免多线程之间的竞争，不可变数据类型通常是线程安全的，如果ADT使用了可变类型，需要通过加锁机制来保证线程安全。更强的不变性定义如下:1.没有改变数据的操作。（不要提供setter方法等）2.所有字段均为private和final。3.没有表示泄露。4.表示中的任何可变对象都不能发生变化。5.不允许子类重写方法（直接声明为final类，或者使构造方法私有，使用工厂方法构造实例）但是注意：如果是引用，任然必须保证指向的对象是不可变的。3.UsingThreadsafeDataTypes：使用线程安全的数据类型，如果必须要使用mutable的数据类型在多线程之间共享收据，要使用线性安全的数据类型，所有的集合类都不是线程安全的，Java提供了装饰器模式。4.同步和锁：防止线程在同一时间访问同一数据，程序员之间负责多线程之间对mutale数据的共享操作，通过同步策略，避免多线程同时访问数据使用锁机制。获得对数据的独家mutate权力。其他线程被阻塞，不能访问。MonitorPattern：用ADT之间左lock，对所有方法都加锁，把synchronized放到方法声明里和把方法体外套一个symchronized一样，Lockingprinciple：任何共享的mutable变量必须被lock所保护，多个变量组合必须被同一个锁保护，同步机制给性能带来很大的影响。死锁：多个线程相互竞争lock，相互等待对方释放lock解决方案1：lockordering。解决方案2：使用上级对象上锁。线程安全的意义：线程安全，是指变量或方法(这些变量或方法是多线程共享的)可以在多线程的环境下被安全有效的访问。这说明了两方面的问题:(1)可以从多个线程中调用，无需调用方有任何操作;(2)可以同时被多个线程调用，无需线程之不必要的交互。 
第309篇文章[1]
2021-06-29 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机专业学 号1190201722班 级1936603学生武晏峰 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文在linux操作系统下对C语言程序hello.c的运行全过程进行了分析。分析了从c文件转化为可执行文件过程中的预处理、编译、汇编和链接阶段，和可执行文件执行过程中的进程管理、存储空间管理和I/O管理的原理。（摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。P2P：FromProgramtoProcess在编译器的处理下，hello.c文件经过预处理、编译、汇编、链接变为可执行文件（program），然后由shell为其建立一个新的进程（process）并运行他。020：FromZerotoZero在他还没有被执行的时候（zero），在shell通过fork为其创建新的子进程后，通过exceve在进程的上下文中加载并运行hello，把他映射到虚拟内存，并载入物理内存，在CPU下执行，在程序运行结束后，父进程会对其进行回收，内核把他从系统中清除（zero）。1.2环境与工具列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位开发工具：GDB/OBJDUMP；EDB；gedit+gcc；CodeBlocks64位等。1.3中间结果列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。1.4本章小结本章简要介绍了Hello的P2P，020的整个过程以及实验的环境、工具和中间产物。（第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理是指在进行第一次编译之前所做的工作，预处理器根据以字符#开头的命令，如#define（宏定义），#include（文件包含），#ifdef（条件编译），修改原始的C程序。例如将头文件从库中提取出来插入到程序文本中，得到完整的源程序，通常以.i作为文件的扩展名。2.2在Ubuntu下预处理的命令gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析可见hello.i与hello.c相比，代码大大增多，而源程序hello.c中除注释和头文件部分位于hello.i的最后。 Cpp到默认的环境变量下寻找stdlib.h,打开/usr/include/stdlib.h,其中可能仍然会有#define语句，cpp对此进行递归展开，最终hello.i文件中只有对外部变量的声明，函数声明，没有宏定义。 2.4本章小结本章介绍了hello.c在编译前需要做的准备工作，预处理的内容与结果。cpp（预处理器）将hello.c转换为hello.i文件。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译是指将预处理后的程序转化为特定的汇编程序的过程。输入.i文件，输出.s文件。这个过程将较偏向自然语言的c文件，转换为偏机器语言的汇编文件，为下一步的汇编生成机器码创造了条件，同时也保持了一定的可读性，和微弱的可移植性。3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 1.程序中的字符串分别是：1）“Usage:Hello学号姓名！\n”，printf传入的格式化参数。在hello.s中声明如下图，注意到字符串使用UTF-8的格式编码的，一个汉字在UTF-8中占三个字节。2）“Hello%s%s\n”，仍然是由printf函数传入的格式化参数，hello.s声明如下。2.数字常量：hello.s中出现的常量有以下几个地方：对全局变量赋值2，将argc与3比较，循环中每次给i加1，循环中止条件i<10的判断。 3.数字变量：全局变量：有一个全局变量intsleepsecs，可见它作为全局变量被放在.data节中，设置了大小为4字节，并初始化为2。 局部变量：中局部变量intargc存放在栈中-20(%rbp)的位置，通过与3的比较操作可以找到它；局部变量inti存放在栈中-4(%rbp)的位置，从与9的比较和循环中每次加1的操作可以找到它；还有一个局部变量数组charargv[]，可以通过L4（循环部分）中输出函数前的两次取值找到argv[1],argv[2]的位置。 4.赋值：赋值操作共有两个，一个是对全局变量sleepsecs的赋值，源程序里令intsleepsecs=2.5。而因为sleepsecs为整型变量，所以编译时直接对其赋值为2。另一个是对局部变量i赋值，之前已经得知i存在栈中-4(%rbp)的位置。5.类型转换：对全局变量sleepsecs的赋值存在一个隐式类型转换。intsleepsecs=2.5因为它把一个浮点数赋给整型变量，所以它会把浮点数2.5强制转换为2（浮点数转整数时向零舍入）。6.算术操作：存在一个算术操作i++，即在每次循环中对变量i加1，之前已经得知i存在栈中-4(%rbp)的位置，那么通过add每次对-4(%rbp)中内容加1即可。7.关系操作：存在两个关系操作，第一个是判断argc!=3，即将argc(栈中-20(%rbp)的内容)与3通过cmp进行比较。第二个是判断i<10，即将i(栈中-4(%rbp)的内容)与9通过cmp进行比较（即判断i<=9）。8.数组/指针/结构操作：存在一个对数组argv的操作，在printf函数中引用了数组argv的两个元素argv[1],argv[2],可以通过L4（循环部分）中输出函数前的两次取值找到argv[1],argv[2]的位置。9.控制转移：第一处是判断argv是否等于3，若不等于，则继续执行，若等于，则跳转至L2处（循环前对i初始化）继续执行。第二处是对i初始化为0后的无条件跳转，以跳到L4,即循环部分代码。第三处是判断是否达到循环终止条件（i<10），这里用i与9进行比较，若小于等于则跳回L4重复循环，否则执行循环外的下一步。这里将i<10的比较改为了与其等价的i<=9。10.函数调用：共有三次函数调用，第一次调用puts函数输出一个字符串常量，参数存在%rdi中；第二次调用printf函数输出字符串常量以及两个局部变量数组的元素，字符串常量作为参数1存在%rdi中，两个数组元素作为参数2、3分别存在%rsi和%rdx中。第三次调用sleep函数，以sleepsecs为参数，参数存在%edi中。3.4本章小结汇编语言是高级语言和机器语言的中介，一方面具有可读性，但是不像高级语言那样易懂，但是一方面反映了机器的一些特征，汇编语言一定程度上翻译了指令集体系的架构。但是从高级语言到汇编语言的映射转化是不容易的。ccl(编译器)将hello.i转换成hello.s文件。 （第3章2分） 第4章汇编4.1汇编的概念与作用 汇编器as将hello.s翻译成机器语言指令，把这些指令打包成一种叫可重定位目标程序的格式，并将结果保存在目标文件hello.o中。（hello.o是一个二进制文件）。作用：把汇编语言翻译成机器语言，用二进制码代替汇编语言中的符号，即让它成为机器可以直接识别的程序。4.2在Ubuntu下汇编的命令ashello.s-ohello.o 4.3可重定位目标elf格式分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。readelf-ahello.oELF可重定位目标文件中首先是ELF头，它以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息：包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量。 然后是节头部表，它描述了不同节的位置和大小，目标文件中的每一个节都有一个固定大小的条目。 重定位项目,其中.rela.text节是一个.text节中位置的列表。当链接器把这个目标文件和其他文件组合时，需要修改这些位置。.rela.eh_frame节包含了对en_frame节的重定位信息。其中，Offset是需要被修改的引用的字节偏移（在代码节或数据节的偏移），Info指示了重定位目标在.symtab中的偏移量和重定位类型，Type表示不同的重定位类型，例如图中R_X86_64_PC32就表示重定位一个使用32位PC相对地址的引用。Sym.Name表示被修改引用应该指向的符号，Append用于一些类型的重定位要使用它对被修改引用的值做偏移调整。可见下图中，在链接时需要对.rodata中的两个字符串常量（用于printf函数中），全局变量sleepsecs，以及函数puts，exit，printf，sleep，getchar进行重定位。 符号表,它存放了程序中定义和引用的函数和全局变量的信息（不包含局部变量的条目）。 4.4Hello.o的结果解析通过objdump可以得到hello.o的反汇编代码，在汇编时从main开始（地址为0）依次为每一行指令都分配了一个地址。可以在下图中看到汇编所得到的机器语言，机器语言由二进制的操作码和操作数构成，图中给出了一个示例。每一条汇编指令能翻译成一条对应的机器指令，汇编语言可以看作是二进制机器语言的助记符。 1）可以看出，汇编语言中操作数是十进制的，而机器语言反汇编得到的操作数是十六进制的。2）对全局变量（即字符串常量）的引用，汇编语言中是用的全局变量所在的那一段的名称加上%rip的值，而hello.o中用的是0加%rip的值，因为当前为可重定位目标文件，之后还需经过重定位方可确定其具体位置，所以这里都用0来代替。3）对分支转移，hello.s的汇编语言中在跳转指令后用对应段的名称（如.L3）表示跳转到的位置，而hello.o中因为每行指令都被分配了对应的地址（从main函数第一条指令地址为0开始），在跳转指令后用跳转目的的地址来表示跳转到的位置。4）函数调用，hello.s中的汇编语言在函数调用时，在call指令后用函数的名字表示对其调用，而反汇编指令在call指令后加上下一条指令的地址来表示，观察机器语言，发现其中操作数都为0，即函数的相对地址为0，因为再链接生成可执行文件后才会生成其确定的地址，所以这里的相对地址都用0代替。4.5本章小结在汇编过程中，hello实现了由汇编语言到机器语言的转变，hello第一次称为了机器可以读懂的代码，它的每条指令得到了一个暂时的地址，并通过在不同地址间的跳转把程序连接成了一个整体。hello也第一次由文本程序变成了二进制程序。as（汇编器）将hello.s转换成hello.o文件。 （第4章1分） 第5章链接5.1链接的概念与作用链接器，将程序调用的外部函数（.o文件）与当前.o文件以某种方式并，并得到./hello可执行目标文件的的过程成为链接。且该二进制文件可被加载到内存，并由系统执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。基于此特性的改进，以提高程序运行时的时间、空间利用效率。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。它将巨大的源文件分解成更小的模块，易于管理。我么可以通过独立地修改或编译这些模块，并重新链接应用，不必再重新编译其他文件。5.2在Ubuntu下链接的命令ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。可通过readelf-a来查看可执行目标文件hello的ELF文件各节基本信息（包含在节头部表中），他描述了不同节的位置和大小等基本信息。其中，它的第一列按地址顺序列出了各段的名称及大小，第三列列出来各段的起始地址，最后一列列出来各段的偏移量。 5.4hello的虚拟地址空间通过readelf查看hello的ProgramHeaders，可发现其中列出的虚拟地址在edb的DataDump中都能找到对应的位置。 5.5链接的重定位过程分析通过readelf查看hello的ProgramHeaders，可发现其中列出的虚拟地址在edb的DataDump中都能找到对应的位置。 5.6hello的执行流程1）在hello.o中，我们看不到各函数的代码段，而在hello中，存在了各个函数的代码段并且，并且每个函数（以及其每条）指令都有了对应的虚拟地址。2）在hello.o中main函数的起始地址为0，往后依次得到每条指令的简单地址，而hello中每条指令都拥有一个虚拟地址，main函数也不是从0开始了。 3）对于全局变量的引用，hello.o中用0加上%rip的值来表示全局变量的位置，因为当时并未对全局变量进行定位，而在hello中，因为全局变量都有了确定的位置，所以用实际的相对偏移加%rip的值来描述其位置。4）对于函数的调用，因为hello.o中尚未对函数定位，所以在调用时都用call加下一条指令地址来表示，而hello中各函数已拥有了各自的虚拟地址，所以在call后加其虚拟地址来实现函数调用。5）对于跳转指令，hello.o中在其后加上目的地址，为main从0开始对每条指令分配的地址；而hello中同样加上目的地址，但这里是每条指令的虚拟地址。6）_dl_start地址：0x7ff806de3ea0_dl_init地址：0x7f75c903e630_start地址：0x400500_libc_start_main地址：0x7fce59403ab0_cxa_atexit地址：0x7f38b81b9430_libc_csu_init地址：0x4005c0_setjmp地址：0x7f38b81b4c10_sigsetjmp地址：0x7efd8eb79b70_sigjmp_save地址：0x7efd8eb79bd0main地址：0x400532(puts地址：0x4004b0exit地址：0x4004e0)(argc!=3时)print地址：0x4004c0sleep地址：0x4004f0(以上两个在循环体中执行10次)getchar地址：0x4004d0_dl_runtime_resolve_xsave地址：0x7f5852241680_dl_fixup地址：0x7f5852239df0_uflow地址：0x7f593a9a10d0exit地址：0x7f889f6721205.7Hello的动态链接分析当程序调用一个由共享库定义的函数时，编译器无法预测这个函数运行时的地址，因为定义它的共享模块在运行时可以加载到任何位置。这时，编译系统提供了延迟绑定的方法，将过程地址的绑定推迟到第一次调用该过程时。他通过GOT和过程链接表PLT的协作来解析函数的地址。在加载时，动态链接器会重定位GOT中的每个条目，使它包含正确的绝对地址，而PLT中的每个函数负责调用不同函数。那么，通过观察edb，便可发现dl_init后.got.plt节发生的变化。通过readelf可以发现.got.plt节在地址为0x601000的地方开始。而它后面的.data节从地址0x601040开始。那么中间部分便是.got.plt的内容。5.8本章小结本章介绍了链接的概念和作用，分析了hello的格式、虚拟地址空间、重定位过程、执行流程和动态链接分析。（第5章1分） 第6章hello进程管理6.1进程的概念与作用概念：进程是一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。作用：在现代系统上运行一个程序时，我们会得到一个假象，好像我们的程序是系统中唯一运行的程序一样。我们的程序好像独占处理器和内存。处理器好像无间断地一条接一条执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象是通过进程的概念提供的。进程提供给应用程序的关键抽象：1）一个独立的逻辑控制流，提供一个程序独占处理器的假象；2）一个私有的地址空间，提供一个程序独占地使用内存系统的假象。6.2简述壳Shell-bash的作用与处理流程作用：shell执行一系列的读/求值步骤，然后终止。读步骤读取来自用户的一个命令行，求值步骤解析命令行，并代表用户运行程序。处理流程：shell打印一个命令行提示符，等待用户在stdin上输入命令行，然后对命令行求值，即解析以空格分隔的命令行参数，第一个参数被假设为要么是一个内置的shell命令名，马上就会解释这个命令并执行相应操作；要么是一个可执行目标文件，会通过fork创建一个新的子进程，并在新的子进程的上下文中通过execve加载并运行这个文件。如果用户要求在后台运行该程序，那么shell返回到循环的顶部，等待下一个命令行。否则，shell使用waitpid函数等待作业终止并回收。当作业终止时，shell开始下一轮的迭代。6.3Hello的fork进程创建过程父进程通过调用fork函数创建一个新的运行的子进程。调用fork函数后，新创建的子进程几乎但不完全与父进程相同:子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本（包括代码、数据段、堆、共享库以及用户栈），子进程获得与父进程任何打开文件描述符相同的副本，这意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。fork被调用一次，却返回两次,子进程返回0，父进程返回子进程的PID。子进程有不同于父进程的PID。6.4Hello的execve过程exceve函数在当前进程的上下文中加载并运行一个新程序。exceve函数加载并运行可执行目标文件，并带参数列表和环境变量列表。只有当出现错误时，exceve才会返回到调用程序，否则，exceve调用一次且从不返回。在exceve加载了可执行目标文件后，他调用启动代码，启动代码设置栈，将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序，由此将控制传递给新程序的主函数。6.5Hello的进程执行系统中通常有许多程序在运行，那么进程会为每个程序提供一个好像它在独占地使用处理器的假象。这时依赖于进程提供的独立的逻辑控制流（由上下文切换机制提供）。如一个系统运行着多个进程，那么处理器的一个物理控制流就被分成了多个逻辑控制流，每个进程1个。这些逻辑流的执行是交错的，它们轮流使用处理器，会存在并发执行的现象。其中，一个进程执行它的控制流的一部分的每一时间段叫做时间片。这样的机制使进程在执行时仿佛独占了处理器。处理器用某个控制寄存器中的一个模式位来限制一个应用可以执行的指令以及它可以访问的地址空间范围。没有设置模式位时，进程运行在用户模式中，它必须通过系统调用接口才可间接访问内核代码和数据；而设置模式位时，它运行在内核模式中，可以执行指令集中的任何指令，访问系统内存的任何位置。异常发生时，控制传递到异常处理程序，由用户模式转变到内核模式，返回至应用程序代码时，又从内核模式转变到用户模式。操作系统内核使用上下文切换来实现多任务。内核为每个进程维持一个上下文，它是内核重启被抢占的进程所需的状态，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构的值。进程执行到某些时刻，内核可决定抢占该进程，并重新开启一个先前被抢占了的进程，这种决策称为调度。内核调度一个新的进程运行后，通过上下文切换机制来转移控制到新的进程：1）保存当前进程上下文；2）恢复某个先前被抢占的进程被保存的上下文3）将控制转移给这个新恢复的进程。当内核代表用户执行系统调用时，可能会发生上下文切换，这时就存在着用户态与核心态的转换。6.6hello的异常与信号处理hello执行过程中会出现的异常有：中断：他由处理器外部的I/O设备的信号引起（如Ctrl-Z，Ctrl-C），可能产生信号SIGSTP，它会将程序挂起，直到有下一个SIGCONT信号；也可能产生信号SIGINT，它会将进程终止。1）运行程序在终端运行程序，打印十次Hello姓名学号后，输入hello(任意)回车，程序执行完成，进程被回收。 2）运行时不停乱按（包括回车）发现他会把乱按的字符打印出来，按回车它会换一行，但是这些都不影响程序的正常执行，因为当程序执行时他不会受到外部输入的影响，它会阻塞这些操作产生的信号，而因为之前将大量字符（包括回车）输入到了屏幕上，所以最后不用自己再输入字符来结束程序，而是直接读取之前的输入。 3）运行程序时按Ctrl-Z程序运行时按Ctrl-Z，这时，产生中断异常，它的父进程会接收到信号SIGSTP并运行信号处理程序，然后便发现程序在这时被挂起了，并打印了相关挂起信息。 4）运行程序时按Ctrl-C运行hello时按Ctrl-C，会导致一个中断异常，从而内核产生信号SIGINT，父进程受到它后，向子进程发生SIGKILL来强制终止子进程hello并回收它。这时在运行ps，可以发现并没有进程hello，可以说明他已经被终止并回收了。 6.7本章小结hello开始真正在系统上运行时，离不开shell给它提供的平台，也离不开进程机制的支持和各种信号的通知。从创建进程，到在进程中加载程序，信号以及上下文切换使其可以自如的运行在计算机中，就好像独占了整个CPU。而当hello的进程生命结束，同样需要各种信号与系统的配合来对它进行终止，回收。程序的高效运行离不开异常、信号、进程等概念，正是这些机制支持hello能够顺利地在计算机上运行。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：逻辑地址指由程序产生的与段相关的偏移地址部分。在有地址变换功能的计算机中，访内指令给出的地址(操作数)叫逻辑地址，也叫相对地址。要经过寻址方式的计算或变换才得到内存储器中的实际有效地址，即物理地址。从hello的反汇编代码中看到的地址，它们需要通过计算，即加上对应段的基地址才能得到真正的地址，这些便是hello中的逻辑地址。线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，其偏移量加上基地址就是线性地址。hello的反汇编文件中看到的地址（即逻辑地址）中的偏移量，加上对应段的基地址，便得到了hello中内容对应的线性地址。虚拟地址：使用虚拟寻址时，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送至内存前先转换成适当的物理地址。虚拟地址转化成物理地址的过程叫做地址翻译。在linux中，虚拟地址数值树等于线性地址，即hello中看到的地址加上对应段基地址的值。物理地址：计算机系统的主存被组织成一个M个连续字节大小的单元组成的数组，每字节都有一个独立的物理地址。它是物理内存中实际对应的地址，在hello的运行中，在访问内存时需要通过CPU产生虚拟地址，然后通过地址翻译得到一个物理地址，并通过物理地址访问内存中的位置。7.2Intel逻辑地址到线性地址的变换-段式管理逻辑地址由段选择符和偏移量组成，线性地址为段首地址与逻辑地址中的偏移量组成。其中，段首地址存放在段描述符中。而段描述符存放在描述符表中，也就是GDT（全局描述符表）或LDT（局部描述符表）中。7.3Hello的线性地址到物理地址的变换-页式管理线性地址（虚拟地址）由虚拟页号VPN和虚拟页偏移VPO组成。首先，MMU从线性地址中抽取出VPN，并且检查TLB，看他是否因为前面某个内存引用缓存了PTE的一个副本。TLB从VPN中抽取出TLB索引和TLB标记，查找对应组中是否有匹配的条目。若命中，将缓存的PPN返回给MMU。若不命中，MMU需从页表中的PTE中取出PPN，若得到的PTE无效或标记不匹配，就产生缺页，内核需调入所需页面，重新运行加载指令，若有效，则取出PPN。最后将线性地址中的VPO与PPN连接起来就得到了对应的物理地址。7.4TLB与四级页表支持下的VA到PA的变换虚拟地址VA虚拟页号VPN和虚拟页偏移VPO组成。若TLB不命中时，VPN被划分为四个片，每个片被用作到一个页表的偏移量，CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，依次类推。最后在L4页表中对应的PTE中取出PPN，与VPO连接，形成物理地址PA。7.5三级Cache支持下的物理内存访问MMU将物理地址发给L1缓存，缓存从物理地址中取出缓存偏移CO、缓存组索引CI以及缓存标记CT。若缓存中CI所指示的组有标记与CT匹配的条目且有效位为1，则检测到一个命中，读出在偏移量CO处的数据字节，并把它返回给MMU，随后MMU将它传递给CPU。若不命中，则需到低一级Cache（若L3cache中找不到则到主存）中取出相应的块将其放入当前cache中，重新执行对应指令，访问要找的数据。7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给他一个唯一的pid。为了给这个新进程创建虚拟内存，他创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有写时复制。当fork从新进程返回，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要：1）删除已存在的用户区域：删除当前进程虚拟地址的用户部分中的已存在的区域结构。2）映射私有区域:为新程序hello的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。3)映射共享区域:如果hello程序与共享对象（或目标）链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。4)设置程序计数器(PC):设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。7.8缺页故障与缺页中断处理对虚拟内存来说，DRAM缓存不命中称为缺页。如下例所示，CPU引用了VP3中的一个字，而VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，因为有效位0，所以并未缓存，引发了缺页异常，调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，这里以存放在PP3中的VP4为例。若VP4被修改了，那么内核会将它复制回磁盘。内核会修改VP4的页表条目，反映出VP4以不在主存中。然后，内核从磁盘复制VP3到内存中PP3位置，然后处理程序返回，重新启动导致缺页的指令。这时，VP3已存在主存中，不会在导致缺页，可以正常读取。7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。1）隐式空闲链表：空闲块通过头部中的大小字段隐含地连接着。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。放置策略：首次适配、下一次适配、最佳适配。首次适配从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配从上一次查询结束的地方开始。最佳适配检查每个空闲块，选择适合所需请求大小的最小空闲块。合并策略：立即合并、推迟合并。立即合并就是在每次一个块被释放时，就合并所有的相邻块；推迟合并就是等到某个稍晚的时候再合并空闲块。2）显式空闲链表：每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。使用双向链表使首次适配的时间减少到空闲块数量的线性时间。空闲链表中块的排序策略：一种是用后进先出的顺序维护链表，将新释放的块放置在链表的开始处，另一种方法是按照地址顺序来维护链表，链表中每个块的地址都小于它后继的地址。分离存储：维护多个空闲链表，每个链表中的块有大致相等的大小。将所有可能的块大小分成一些等价类，也叫做大小类。分离存储的方法：简单分离存储和分离适配。7.10本章小结本章讨论了存储器地址空间，段式管理、页式管理，TLB与四级页表支持下的VA到PA的变换，三级Cache支持下的物理内存访问，hello进程fork时和execve时的内存映射，缺页故障与缺页中断处理和动态存储分配管理。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。8.2简述UnixIO接口及其函数1.打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。2.Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。3.改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0.这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会触发一个称为end-of-file（EOF）的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。5.关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。函数：1.intopen(char*filename,intflags,mode_tmode)进程通过调用open函数来打开一个已存在的文件或者创建一个新文件。open函数将filename转换为一个文件描述符，而且返回描述符数字。flags参数指明了进程打算如何访问这个文件。mode参数指定了新文件的访问权限位。2.intclose(intfd)进程通过调用close函数关闭一个打开的文件。3.ssize_tread(intfd,void*buf,size_tn)应用程序通过调用read函数来执行输入。read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，返回值0表示EOF。否则返回值表示的是实际传送的字节数量。4.ssize_twrite(intfd,constvoid*buf,size_tn)应用程序通过调用write函数来执行输出。write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。8.3printf的实现分析printf的代码： intprintf(constchar*fmt,…){inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } vsprintf的代码： intvsprintf(char*buf,constchar*fmt,va_listargs){char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!='%'){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); } write的代码：moveax,_NR_writemovebx,[esp+4]movecx,[esp+8]intINT_VECTOR_SYS_CALL sys_cal: sys_call：callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret syscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析1.intgetchar(void)2.{3.staticcharbuf[BUFSIZ];4.staticchar*bb=buf;5.staticintn=0;6.if(n==0)7.{8.n=read(0,buf,BUFSIZ);9.bb=buf;10.}11.return(–n>=0)?(unsignedchar)*bb++:EOF;12.} getchar函数调用read函数，将整个缓冲区都读到buf里，并将缓冲区的长度赋值给n。返回时返回buf的第一个元素，除非n<0。异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章简述了Linux的I/O设备管理机制，UnixI/O接口及函数，并简要分析了printf函数和getchar函数的实现。（第8章1分）结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。1）GCC编译器驱动程序读取源程序文件hello.c。2）预处理器cpp将其预处理为一个修改了的源程序hello.i（如读取并插入头文件内容等）。3）编译器ccl将其翻译成汇编语言程序hello.s。4）汇编器as将其翻译成机器语言指令，得到可执行目标文件hello.o。5）链接器ld将重定位目标文件链接为可执行目标文件hello。6）在shell中输入运行hello的指令，shell通过fork为其创建新的进程。7）通过execve将hello程序加载并运行。把它映射到对应虚拟内存区域，并依需求载入物理内存。8）在CPU的帮助下，它的指令被一步步执行，实现它拥有的功能。9）在程序运行结束后，父进程会对其进行回收，内核把它从系统中清除。这样，hello便完成了它的程序人生。计算机系统的设计复杂而严密，对内存，CPU等各个实现都有着精密的处理设计，以涵盖在系统运行时可能遇到的各种情况。计算机系统的运行需要内存，CPU，信号等机制的密切配合，来实现在系统上正确而又高效地运行程序。（结论0分，缺失-1分，根据内容酌情加分） 附件列出所有的中间产物的文件名，并予以说明起作用。hello.i预处理后修改了的源程序hello.s汇编生成的hello的汇编程序hello.o编译生成的hello的可重定位目标程序hello链接生成的hello的可执行目标程序asm.txthello.o的反汇编文件（附件0分，缺失-1分） 参考文献[1]动态链接原理分析https://blog.csdn.net/shenhuxi_yu/article/details/71437167[2]printf函数实现的深入剖析https://www.cnblogs.com/pianist/p/3315801.html[3]getchar函数浅谈https://blog.csdn.net/zhuangyongkang/article/details/38943863[4]https://baike.baidu.com/item/逻辑地址/3283849?fr=aladdin[5]https://baike.baidu.com/item/线性地址[6]https://baike.baidu.com/item/虚拟地址[7]https://www.cnblogs.com/huangwentian/p/7487670.html[8]https://blog.csdn.net/youyou519/article/details/82659007为完成本次大作业你翻阅的书籍与网站等（参考文献0分，缺失-1分） 
第310篇文章[]
2021-06-30 软件构造Delegation 引出：子类可以继承父类的字段、属性和方法，使用“继承”可以较大程度地复用代码。在使用继承时，务必要确定代码中定义的“父类”和“子类”确实存在客观的“父子关系”，而不要去做“为了代码复用而使用继承”的事情，这是舍本逐末的做法，也是滥用继承的体现。滥用继承会破坏类之间客观存在的关系，也会模糊代码所体现的语义。 委派和继承都是为了提高代码的复用性，只是方式不同。委派：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象。继承：利用extends来扩展一个基类。 （1）Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。示例代码： interfaceFlyable{ publicvoidfly(); } interfaceQuackable{ publicvoidquack(); } classFlyWithWingsimplementsFlyable{ @Override publicvoidfly(){ System.out.println("flywithwings"); } } classQuackimplementsQuackable{ @Override publicvoidquack(){ System.out.println("quacklikeduck"); } } interfaceDucklikeextendsFlyable,Quackable{ } publicclassDuckimplementsDucklike{ //delegation FlyableflyBehavior; QuackablequackBehavior; //设置delegation对象实例 publicvoidsetFlyBehavior(FlyableflyBehavior){ this.flyBehavior=flyBehavior; } publicvoidsetQuackBehavior(QuackablequackBehavior){ this.quackBehavior=quackBehavior; } //通过delegation实现具体行为 @Override publicvoidfly(){ this.flyBehavior.fly(); } @Override publicvoidquack(){ this.quackBehavior.quack(); } } publicclassClient{ publicstaticvoidmain(String[]args){ Flyablef=newFlyWithWings(); Quackableq=newQuack(); Duckd=newDuck(); d.setFlyBehavior(f); d.setQuackBehavior(q); d.fly(); d.quack(); } } （2）Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。示例代码： publicinterfaceStudy{ intstudy(Stringcontent); } classStudyInClassimplementsStudy{ @Override publicintstudy(Stringcontent){ return1; } } classStudyByMoocimplementsStudy{ @Override publicintstudy(Stringcontent){ return2; } } classStudent{ privateStringname; privateMap<String,Integer>scores=newHashMap<String,Integer>(); publicMap<String,Integer>getScores(){ returnscores; } //AF:name为学生名字，scores中的key为学科名字，value为学生成绩 //RI:学生成绩范围为[0,100] publicStudent(Stringname){ this.name=name; } publicintgetFinalScore(){ inttotal=0; for(Stringcontent:scores.keySet()){ total+=scores.get(content); } returntotal; } //建立临时性的delegation关系 publicintstudy(Stringcontent,Studymethod){ System.out.print(content+":\t"); returnmethod.study(content); } publicvoidgetScore(Stringcontent,Studymethod){ intscore=method.study(content); scores.put(content,score); } publicstaticvoidmain(String[]args){ StudyinClass=newStudyInClass(); StudybyMooc=newStudyByMooc(); StudentWu=newStudent("wyf"); Wu.study("软件构造",inClass); Wu.getScore("软件构造",inClass); System.out.println(Wu.getScores().get("软件构造")); Wu.study("计算机系统",byMooc); Wu.getScore("计算机系统",byMooc); System.out.println(Wu.getScores().get("计算机系统")); System.out.println("总成绩："+Wu.getFinalScore()); } （3）Composition:更强的association，但难以变化。也就是以下代码Association中的法二。（4）Aggregation:更弱的association，可动态变化。也就是以下代码Association中的法一。 //法一：在构造方法中传入参数绑定 Flyablef=newFlyWithWings(); Duckd=newDuck(f); d.fly(); classDuck{ Flyablef;//这个必须由构造方法传入参数绑定 publicDuck(Flyablef){this.f=f;} publicvoidfly(){f.fly();} } //法二：在rep或构造方法中直接写死 Duckd=newDuck(); d.fly(); classDuck{ //这两种实现方式的效果是相同的 Flyablef=newFlyWithWings();//写死在rep中 publicDuck(){f=newFlyWithWings();}//写死在构造方法中 publicvoidfly(){f.fly();} } 参考文献：https://blog.csdn.net/weixin_44940258 
第311篇文章[3]
最短路（4）--差分约束 差分约束的实质就是把多种约束连起来，比如x-y<=a和y-z<=b，把他们连起来就成了x-z<=a+b，这样很容易就可以想到把x-y看成一条由x指向y，权值为a的边，那么对于一堆约束条件，就可以转化为求最短路或最长路的问题 对于不同的一堆约束条件，有： 如果约束条件形如x-y<=a，则实际问题为求差的最大值，操作是求最短路如果约束条件形如x-y>=a，则实际问题为求差的最小值，操作是求最长路（此处较难理解，需要用到数学中交并集的知识）解释：对于一堆约束条件建立的如下的图：两种约束条件原理类似，拿<=举例：可见，算出1和3的关系有两钟解，一种是<=4，另一种是<=3，但是，因为要满足所有的约束条件，所以对于1和3的最大差值，只能取两个取值范围的交集，即<=3，这就使最短路 举例：POJ3159（模板题） *题目大意： 把糖分给n个小朋友，总共有m个约束条件，表示编号为i,j的小朋友之间分到的糖果数之差不大于一个值，求分完后第n个小朋友和第1个小朋友之间的最大差值* 完全是模板题，直接上代码（SPFA）这道题是我做过的最恶心的一道题，不能用queue，只能用stack就不说啥了，竟然连cin都不能用，只能用scanf。。。。白白浪费了我一个小时的时间，气的我想当场砸电脑 //poj3159 #include<cstdio> #include<queue> #include<stack> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=30000+10; constintMAXM=150000+10; constintINF=0x3f3f3f3f; intn,m; stack<int>q; intd[MAXN],vis[MAXN]; structedge { intto,next,w; }e[MAXM]; inthead[MAXN],cnt; voidadd(intu,intv,intw) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].w=w; } intmain() { scanf("%d%d",&n,&m); for(inti=1;i<=m;i++) { intu,v,w; scanf("%d%d%d",&u,&v,&w); add(u,v,w); } for(inti=1;i<=n;i++) d[i]=INF; d[1]=0; q.push(1);vis[1]=1; while(!q.empty()) { intu=q.top(); intv,w; q.pop(); vis[u]=0; for(inti=head[u];i;i=e[i].next) { v=e[i].to; w=e[i].w; if(d[v]>d[u]+w) { d[v]=d[u]+w; if(!vis[v]){q.push(v);vis[v]=1;} } } } printf("%d\n",d[n]); return0; } 
第312篇文章[3]
2-sat问题 2-sat问题： 给定一堆约束条件，每个都形如“xi为真/假或xj为真/假”，即：xi为真/假和xj为真/假中必有一个成立，现在问是否可以全部满足 思路： 可以把xi为真看成两个节点：2i,2i+1（因为2i^1=2i+1，可以互相转化）假如说约束条件为“xi为真或xj为假”，那么2i表示“xi为真”为真，2i+1表示“xi为真”为假；2j表示“xj为假”为真，2j+1表示”xj为假“为假则，由2j+1为真可以推出2i为真，同理，由2i+1可以推出2j为真所以，可以从2j+1到2i；2i+1到2j连两条有向边对于起点u，可以假设他为真，并对他进行深搜，如果过程中发现有点的两个结点都为真，则不能再假设他为假，再深搜，如果他还是不能，则不能建图 例题： 有n架飞机要着陆，每个都可以选择早着陆或晚着陆，请安排着陆方式，要求着陆时间差值的最小值最大 思路：”最小值最大“可以用二分，问题即可转化成着陆时间差值不大于mid是否成立，所以着陆时间小于mid的两个点，至多有一个成立，等价于这两个点的补至少有一个成立，这样就转化为了2-sat 代码：（调了一个上午，参考刘汝佳《算法竞赛入门经典训练指南》） #include<cstdio> #include<cstring> #include<string> #include<vector> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=2000+10; structtwosat { vector<int>G[MAXN*2]; boolmark[MAXN*2]; ints[MAXN*2],c; intn;//外面的n booldfs(intu) { if(mark[u^1])returnfalse; if(mark[u])returntrue; mark[u]=true; s[c++]=u; for(inti=0;i<G[u].size();i++) { intv=G[u][i]; if(!dfs(v))returnfalse; } returntrue; } voidinit(intn) { this->n/*这个是外面的n*/=n;//将外面的n赋值为里面的n for(inti=0;i<2*n;i++)G[i].clear(); memset(mark,0,sizeof(mark)); } voidadd(intx,intxval,inty,intyval)//x==xvalory==yval { x=2*x+xval;//2i y=2*y+yval;//2j G[x^1].push_back(y); G[y^1].push_back(x); } boolsolve() { for(inti=0;i<2*n;i+=2) if(!mark[i]&&!mark[i+1]) { c=0; if(!dfs(i)) { while(c>0)mark[s[--c]]=false;//如果深搜它不成功，则所有的假设都错误 if(!dfs(i+1))returnfalse;//如果假设他为真假都不对，不能成图 } } returntrue; } }; twosatsolver; intt[MAXN][2],n; booltest(intmid) { solver.init(n); for(inti=0;i<n;i++)for(inta=0;a<=1;a++) for(intj=i+1;j<n;j++)for(intb=0;b<=1;b++) { if(abs(t[i][a]-t[j][b])<mid)solver.add(i,a^1,j,b^1); } returnsolver.solve(); } intmain() { cin>>n; intl=0,r=0; for(inti=0;i<n;i++)for(inta=0;a<=1;a++) { cin>>t[i][a]; r=max(r,t[i][a]); } while(l<r) { intmid=l+(r-l+1)/2;//令相邻两个着陆时间都大于等于mid//时间差小于mid的两个时间不能同时满足 if(test(mid))l=mid;elser=mid-1; } cout<<l; return0; } 
第313篇文章[]
IdeaTest文件无法正常与运行文件链接newInstanceWithCaller 在编写完@Test代码测试程序时无法正常运行，出现如下问题 这里可能是因为两个程序没有指定在一个package内，或者命名相同但测试文件夹指定不同 可以在检查开头的packageinterval 或者右键单击test文件夹，选择markdirectoryas选项 
第314篇文章[3]
状态压缩DP（入门） 可以把一个难以描述的状态压缩为一个二进制数，即将状态用一个数字表示 例题： 给定一个n*m的方格，每次可以填一个1*2或2*1的矩形，若要将其填满，共有多少种填法(1<=n<=5,1<=m<=1000) 分析： 因为n的范围很小，所以我们可以把每一列都用一个二进制数表示，作为一个状态，则dp[i][j]表示前i列，第i列的装态为j时的最大填法数用dfs(i,j,now,next)表示深搜第i列，第j行，而第i列的状态为now,因为如果填1*2的矩形，则会对后面的状态有影响，所以用next记录对后面的影响当j==n即第i列已经讨论完时，给d[i+1][next]的值加上dp[i][now]的值 下面是代码 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=2000+10; intn,m; intdp[MAXN][MAXN];//dp[i][j]表示讨论到了第i列，当前列的状态是j时的方式数d[i][j]=sum(d[i-1][1~1<<n]) voiddfs(inti,intj,intnow,intnext)//第i列,当前讨论到第i列的第j个,当前列的状态为now,这一列对下一列影响后下一列的状态为next { if(j==n) { dp[i+1][next]+=dp[i][now];//这一列讨论完后更新下一列的dp值 return; } if(((1<<j)&now)) dfs(i,j+1,now,next); if(!((1<<j)&now)) dfs(i,j+1,now,next|(1<<j)); if((j+1)<n&&!((1<<j)&now)&&!((1<<(j+1))&now)) dfs(i,j+2,now,next); return; } intmain() { cin>>n>>m; dp[1][0]=1; for(inti=1;i<=m;i++) for(intj=0;j<(1<<n);j++) if(dp[i][j])dfs(i,0,j,0); cout<<dp[m+1][0]; return0; } 
第315篇文章[3]
优先队列的基本用法（初步） 优先队列的基本用法（初步） 优先队列实际上就是堆，可以用它来维护大根堆和小根堆 //优先队列 #include<queue> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; priority_queue<int>da;//大根堆 priority_queue<int,vector<int>,greater<int>>xiao;//小根堆，两个>之间要有空格 intmain() { intn; cin>>n; for(inti=1;i<=n;i++) { intu;cin>>u; da.push(u); xiao.push(u); } cout<<da.top(); cout<<endl<<xiao.top(); return0; } 重载运算符（较难理解） #include<cstdio> #include<cstdlib> #include<queue> #include<iostream> #include<algorithm> usingnamespacestd; structcmp { booloperator()(constinta,constintb)//如果a的优先级比b小返回true { returna%10>b%10;//定义“优先级小”为a%10>b%10时，a的优先级小 } }; priority_queue<int>q;//按照优先级从大到小排列，即把a拍在后面 intmain() { q.push(18); q.push(21); cout<<q.top(); return0; } 当然还有很多复杂而神奇的用法，但是对我目前用处不大，先不深入了解 
第316篇文章[8]
HelloWorld #include<iostream> usingnamespacestd; intmain() { cout<<"HelloWorld"; return0; } 
第317篇文章[3]
最短路（2）--bellman-ford和SPFA bellman-ford 首先，如果最短路存在，那么一定有一条不含环的最短路，因为如果是正环或零环，都可以直接去除，如果有负环，则最短路不存在，所以最短路顶多经过n-1个顶点，那么我们至多只需要进行n-1次松弛操作，每次操作中遍历所有边，如果该边的起点不是INF（已经松弛过）那么就对该边的终点松弛。这样就一定可以把最短路经过的所有点都松弛一遍，即求出了最短路（因为只要可以松弛，就一定有更短的方案）。 //bellmanford #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; constintINF=0x3f3f3f3f; intu[MAXN],v[MAXN],w[MAXN]; intd[MAXN]; intn,m; intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=m;i++) { cin>>u[i]>>v[i]>>w[i]; u[i+m]=v[i],v[i+m]=u[i],w[i+m]=w[i]; } d[1]=0; for(inti=2;i<=n;i++)d[i]=INF; for(intk=1;k<n;k++) for(inti=1;i<=2*m;i++) if(d[u[i]]<INF)d[v[i]]=min(d[v[i]],d[u[i]]+w[i]); for(inti=1;i<=n;i++) cout<<d[i]<<""; return0; } SPFA 思路： 把除起点外的所有点距离设为无限，然后让起点进入队列每次取出队列的第一个点，讨论他的所有只向点进行松弛操作，如果松弛成功并且该点并不在队列中，将该点放入队列，直到队列中没有点为止 和dijkstra的比较 dijkstra每次取出的是当前距离最小点，在后面的讨论中不可能再更新该点的值，所以每个点只用讨论一次SPFA每次取出的只是一个松弛过的点，很有可能再次讨论回来，所以一个点要讨论多次但是因为dijkstra中每次找距离最小点需要时间复杂度，所以O(mlogn)而SPFA没有这个需要，所以O(kn)，k是常数，而一般不会超过2而且dijkstra只能解决没有负权的问题，而SPFA可以解决，但不能解决有负环的问题，因为有负环的图没有最短路，他还可以判定负环，当一个点的进队次数超过n后，可以判定图中有负环 下面是SPFA的代码 //SPFA #include<cstdio> #include<cstdlib> #include<queue> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; constintINF=0x3f3f3f3f; queue<int>q; intn,m; intd[MAXN]; intvis[MAXN]; structedge { intto,next,w; }e[MAXN]; inthead[MAXN],cnt; voidadd(intu,intv,intw) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].w=w; } intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=m;i++) { intu,v,w; cin>>u>>v>>w; add(u,v,w);add(v,u,w); } for(inti=2;i<=n;i++) d[i]=INF; q.push(1);vis[1]=1; while(!q.empty()) { intu=q.front();q.pop();vis[u]=0; for(inti=head[u];i;i=e[i].next) { intv=e[i].to; if(d[v]>d[u]+e[i].w) { d[v]=d[u]+e[i].w; if(!vis[v]){q.push(v);vis[v]=1;} } } } for(inti=1;i<=n;i++) cout<<d[i]<<""; return0; } 
第318篇文章[1]
VMware创建ubuntu虚拟机后无法安装vmwaretools 在每次安装完vmtools上的ubuntu虚拟机后安装vmware-tools时，会提示如下并且vmwaretools中没有东西 按照网上方法更改CD文件为linux.iso问题仍然存在 更改完后需要重启vmwaretools即可解决 
第319篇文章[]
ADT设计时不可变性的保持 分两种情况，属性为不可变和可变 1.例如一个ADT Graph， 不能直接使用Graph.lenth（lenth为Graph中的一个属性），应该使用Graph.getLength() publicintgetLength(){ returnthis.length } intlength 为不可变（基本数据类型都为不可变）， 可以直接return 2. 如果ADT的field中有如下定义 publicclassGraph{ Datedate; intlength; } Date是一个可变类型，那么我们使用修改函数进行修改时，需要返回一个新的修改的对象，而非对其直接进行修改 无论可变不可变，return的一定是immutable的 
第320篇文章[]
set的基本用法 set是一棵红黑树，在一些操作上十分高效，还具有许多priority_queue没有的功能 下面是基本用法 //set #include<set> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; set<int>s; intmain() { intn; cin>>n; for(inti=1;i<=n;i++) { intt; cin>>t; s.insert(t); } //遍历： set<int>::iteratorit;//正向迭代器 for(it=s.begin();it!=s.end();it++)//正向遍历（即由小到大输出） cout<<*it<<""; cout<<endl; set<int>::reverse_iteratorrit;//反向迭代器 for(rit=s.rbegin();rit!=s.rend();rit++)//反向遍历（即由大到小输出） cout<<*rit<<""; //元素的删除：可以删除迭代器上的元素，等于某键值的元素，区间上的元素和清空集合 it=s.begin(); for(inti=1;i<=2;i++) s.erase(it++); for(it=s.begin();it!=s.end();it++) cout<<*it<<""; cout<<endl; s.clear(); for(it=s.begin();it!=s.end();it++) cout<<*it<<""; cout<<endl; //元素的检索：用s.find()，如果找到，则返回迭代器位置，否则返回s.end(); s.insert(5); cout<<*s.find(5)<<endl; if(s.find(20)==s.end())cout<<"NO"; return0; } 很多用到set时需要进行重载运算符，用法如下 //set #include<set> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; structmycmp//当set中的元素不是结构体时 { booloperator()(constint&a,constint&b) { returna%10<b%10; } }; set<int,mycmp>s1; structpoint { intx,y; booloperator<(constpoint&a)const//当set中的元素是结构体时,直接写在结构体中 { returnx<a.x;//按照x从小到大排序 } }; set<point>s2; intmain() { intn;cin>>n; for(inti=1;i<=n;i++) { intt;cin>>t;s1.insert(t); } set<int,mycmp>::iteratorit1; for(it1=s1.begin();it1!=s1.end();it1++) cout<<*it1<<""; cout<<endl; for(inti=1;i<=n;i++) { pointt; cin>>t.x>>t.y; s2.insert(t); } set<point>::iteratorit2; for(it2=s2.begin();it2!=s2.end();it2++) cout<<(*it2).x<<""; return0; } 
第321篇文章[3]
POJ2349（最小生成树） 题目大意：给定n个点，其中任意点都可以用无线电链接，但是无线电的连接范围不能超过D，D越大费用越高，现在可以给其中的S个点接上卫星，卫星范围无限，现在要求所有点都直接或间接的连接，求最小的D 思路： 把所有点都连接上后，需要把他们分成s个联通块，每个连通块里放一个卫星（不管是那个点），这样，两个连通块里的所有点都可以通过卫星连接，分成s个连通块需要删掉s-1条路既然要求D最小，那么就一定要删最大的s-1条边那么我就需要形成生成树的所有的边都尽量小因为最小生成树是按照边权从小到大排列的，满足条件所以求解的步骤就是先用Kruskal求出最小生成树，求的过程中把要形成生成树的边存起来，最后删除最大的s-1条边，然后输出最大边即可 //poj2349 #include<cmath> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> #include<queue> usingnamespacestd; constintMAXN=500*500+10; intx[MAXN],y[MAXN]; intfa[MAXN]; ints,n; intans; structedge { intu,v; doublew; }e[MAXN]; doubledist(intu,intv) { returnsqrt((double)(x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v])); } boolcmp(edgea,edgeb) { returna.w<b.w; } intfind(intx) { //if(fa[x]!=x)returnfa[x]=find(fa[x]); //elsereturnx; if(fa[x]==x)returnx; elsereturnfa[x]=find(fa[x]); } doubleq[MAXN]; voidkruskal(intcnt) { memset(q,0,sizeof(q)); for(inti=1;i<=n;i++) fa[i]=i; for(inti=1;i<=cnt;i++) { inta=e[i].u,b=e[i].v; intfx=find(a),fy=find(b); if(fx!=fy){fa[fy]=fx;q[++ans]=e[i].w;} } } intmain() { intt; cin>>t; while(t--) { cin>>s>>n; for(inti=1;i<=n;i++) cin>>x[i]>>y[i]; intcnt=0; for(inti=1;i<=n;i++) for(intj=i+1;j<=n;j++) { e[++cnt].w=dist(i,j); e[cnt].u=i,e[cnt].v=j; } sort(e+1,e+1+cnt,cmp); ans=0; kruskal(cnt); intto=ans-s+1; while(ans!=to) ans--; printf("%.2f\n",q[ans]); //cout<<q[ans]<<endl; } return0; } 
第322篇文章[3]
线段树基本操作（2） 线段树基本操作（2） 区间修改 假如指定一个操作给一段区间的所有值加2，求任意区间的最小值 修改区间时依然要按照线段树的结点搜索，但是如果一直搜索到底的话复杂度过大所以需要用到延迟标记当我指定一段区间进行修改时，依然按照线段树查找区间的方法逐层查找，但是区别是当刚好找到某结点的左右值刚好等于当前要改的左右值时，不用再继续查找下去，只需要在这个节点上加个延迟标记设要查找的区间为(ll,rr)，已知区间为lt,rt当(ll>=lt&&rr<=rt)时，如果此时这个区间上有延迟标记，则将他加载现在区间的值上，然后把延迟标记释放给子节点，如果此时lt==ll&&rr==rt，则返回当前结点的值即可注意，如果一直查到了叶子结点，但这个叶子上没有延迟标记，也要返回该叶子节点的值讨论完左右叶子节点后要更新当前节点的值 更新：才发现在change是就更改结点值而查询时只释放结点会更快，下面摘自网上 对于任意区间的修改，我们先按照查询的方式将其划分成线段树中的结点，然后修改这些结点的信息，并给这些结点标上代表这种修改操作的标记。在修改和查询的时候，如果我们到了一个结点p，并且决定考虑其子结点，那么我们就要看看结点p有没有标记，如果有，就要按照标记修改其子结点的信息，并且给子结点都标上相同的标记，同时消掉p的标记。 下面是代码 //线段树区间修改 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; intn; intval[2*MAXN],p[MAXN]; intsign[2*MAXN];//延迟标记 voidbuild(intnode,intlt,intrt)//建树 { if(lt==rt){val[node]=p[lt];return;} intmid=(lt+rt)>>1; build(node*2,lt,mid);build(node*2+1,mid+1,rt); val[node]=min(val[node*2],val[node*2+1]); return; } voidchange(intnode,intlt,intrt,intll,intrr)//区间修改 { if(lt==ll&&rr==rt){sign[node]++;return;} intmid=(lt+rt)>>1; if(rr<=mid){change(node*2,lt,mid,ll,rr);return;} if(ll>mid){change(node*2+1,mid+1,rt,ll,rr);return;} change(node*2,lt,mid,ll,mid); change(node*2+1,mid+1,rt,mid+1,rr); } intquery(intnode,intlt,intrt,intll,intrr)//区间查询 { if(ll>=lt&&rr<=rt&&sign[node]) { val[node]+=2*sign[node]; sign[node*2]+=sign[node]; sign[node*2+1]+=sign[node]; sign[node]=0; if(ll==lt&&rr==rt)returnval[node]; } if(lt==rt)returnval[node]; intmid=(lt+rt)>>1; if(rr<=mid)returnquery(node*2,lt,mid,ll,rr); if(ll>mid)returnquery(node*2+1,mid+1,rt,ll,rr); intv1=query(node*2,lt,mid,ll,mid); intv2=query(node*2+1,mid+1,rt,mid+1,rr); returnval[node]=min(v1,v2); } intmain() { freopen("tree.in","r",stdin); cin>>n; for(inti=1;i<=n;i++) cin>>p[i]; build(1,1,n); change(1,1,n,2,4); intans=query(1,1,n,1,n); //cout<<ans; //for(inti=1;i<=2*n;i++) //cout<<sign[i]<<""; //cout<<endl; for(inti=1;i<=2*n;i++) cout<<val[i]<<""; } 
第323篇文章[3]
CODEVS1134noip2011铺地毯 懒得用结构体 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; inta[MAXN],b[MAXN],g[MAXN],k[MAXN]; intmain() { intn; intx,y; intans=-1; cin>>n; for(inti=1;i<=n;i++) cin>>a[i]>>b[i]>>g[i]>>k[i]; cin>>x>>y; for(inti=1;i<=n;i++) { if(x>=a[i]&&x<=a[i]+g[i]&&y>=b[i]&&y<=b[i]+k[i]) ans=i; } cout<<ans; return0; } 
第324篇文章[3]
vijos1012平面最近点对(模板) vijos1012平面最近点对(模板) 半年没摸键盘了，为了PKUSC要做恢复性训练了裸的平面最近点对模板题，要用到分治算法，O（nlogn)，但是这道题暴力也能过 暴力 纯暴力肯定用不了，要用到一些剪枝 先把数组以x为第一次序，y为第二优先次序排序在两层循环中，如果p[i].x和p[j].x的差值已经大于当前算的最小距离了，那以后的就肯定不能取了，直接剪掉 //100 #include<cstdio> #include<cmath> #include<cstdlib> #include<iostream> #include<algorithm> #definelllonglong usingnamespacestd; intn; constintMAXN=100000+10; constintINF=0x3f3f3f3f; structnode { llx,y; }p[MAXN]; boolcmp(nodea,nodeb) { if(a.x==b.x)returna.y<=b.y; elsereturna.x<b.x; } doubledist(inta,intb) { returnsqrt((double)((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y))); } intmain() { //freopen("point.in","r",stdin); cin>>n; for(inti=1;i<=n;i++) cin>>p[i].x>>p[i].y; sort(p+1,p+1+n,cmp); doubleans=INF; for(inti=1;i<=n;i++) for(intj=i+1;j<=n;j++) { if((p[j].x-p[i].x)>ans)break; ans=min(ans,dist(i,j)); } printf("%.3f",ans); return0; } 分治 肯定还是要排序solve(i,j)表示点i到j之间的所有点可以形成的最小点对大小计算时运用分治法可以大量简化时间复杂度（我个人觉得这实际上是一种DP)对于一段区间[i,j]，找到他们的中间点mid=(i+j)>>1然后分别计算左右两区间的最小点对大小，再进行比较，即d=min(solve(i,mid),solve(mid+1,j))到这一步当然还不够，如果这两个区间之间的点对存在更小的情况呢？先取出中间点的横坐标midx因为事先已经排好序，所以如果存在上文说到的点对，则他们的横坐标的范围顶多在(midx-d,midx+d)之间把所有这样的点都找出来，再在这些点之间找出最小距离值和d比较就可以了再找这些点的时候可以用到与上面暴力相似的优化 代码如下 //AC #include<string> #include<cstring> #include<cmath> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; intn; constintMAXN=100000+10; constintINF=0x3f3f3f3f; structnode { longlongx,y; }p[MAXN]; nodetemp[MAXN]; boolcmp(nodea,nodeb) { if(a.x==b.x)returna.y<=b.y; elsereturna.x<b.x; } //doubledist(inta,intb) //{ //returnsqrt((double)((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y))); //} doubledist(nodea,nodeb) { returnsqrt((double)((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))); } doublejue(longlonga) { if(a>=0)returna; elsereturn-a; } boolcmpy(nodea,nodeb) { returna.y<b.y; } doublesolve(intlt,intrt) { doubleans=INF; if(lt==rt)returnans; intmid=(lt+rt)>>1; doubleans1=solve(lt,mid); doubleans2=solve(mid+1,rt); ans=min(ans1,ans2); intmidx=p[mid].x; intll=midx-ans,rr=midx+ans; intld=p[lt].x,rd=p[rt].x; intcnt=0; //for(inti=1;i<=n;i++) //if(p[i].x>=ll&&p[i].x<=rr&&p[i].x>=ld&&p[i].x<=rd)temp[++cnt]=p[i]; for(inti=lt;i<=rt;i++) if(jue(p[mid].x-p[i].x)<=ans)temp[++cnt]=p[i]; sort(temp+1,temp+1+cnt,cmpy); for(inti=1;i<=cnt;i++) for(intj=i+1;j<=cnt;j++) { nodeu=temp[i],v=temp[j]; if((v.y-u.y)>ans)break; doubleans3=dist(u,v); ans=min(ans,ans3); } returnans; } intmain() { freopen("point.in","r",stdin); cin>>n; for(inti=1;i<=n;i++) cin>>p[i].x>>p[i].y; sort(p+1,p+1+n,cmp); printf("%.3f",solve(1,n)); } 
第325篇文章[3]
最短路（3）--floyd和用floyd求最小环 先介绍floyd算法，这种算法可以用来求图中任意两点间的最短路 思路： 用d[i][j]表示点i到点j的最小距离如果要从点i到点j，有两种方法，一种是直接去，另一种是通过另一个点中转而他们可以通过一个点中转，也可以是两个，也可以是三个。。。。假设他们只能通过点1中转，则松弛操作为d[i][j]=min(d[i][j],d[i][1]+d[1][j])在循环完所有i,j后，再更新了最短路的基础上再讨论经过点2中转，以此类推，即for(intk=1;k<=n;k++)for(inti=1;i<=n;i++)for(intj=1;j<=n;j++)if(d[i][k]<INF&&d[k][j]<INF)d[i][j]=min(d[i][j],d[i][k]+d[k][j]); 下面是整个程序的代码 //floyd #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; constintINF=0x3f3f3f3f; intd[MAXN][MAXN]; intn,m; intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=n;i++) for(intj=1;j<=n;j++) if(i!=j)d[i][j]=INF; for(inti=1;i<=m;i++) { intu,v,w; cin>>u>>v>>w; d[u][v]=w; } for(intk=1;k<=n;k++) for(inti=1;i<=n;i++) for(intj=1;j<=n;j++) if(d[i][k]<INF&&d[k][j]<INF) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); for(inti=1;i<=n;i++) { for(intj=1;j<=n;j++) cout<<d[i][j]<<""; cout<<endl; } return0; } floyd求最小环 思路： 如果我们要求包含点i,j的最小环，在已经算出来i,j之间的最短路d[i][j]的情况下（假设他们之间是经过点k中转的），还需要计算有j到i且不经过点k的最短路我们令k为这个最小环里的最大编号的点，则在前面计算d[i][j]时，一定没有经过点k，所以当第一层循环循环到k时，枚举所有小于k的点对，计算d[i][j]+m[j][k]+m[k][i]，更新最小环的值*把上面的程序放在正常求floyd时遍历i,j循环的前面* //floyd求最小环 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; constintINF=0x3f3f3f3f; intd[MAXN][MAXN]; intmap[MAXN][MAXN];//两点之间的距离，这个数组是固定的，不会更新 intn,m; intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=n;i++) for(intj=1;j<=n;j++) if(i!=j)d[i][j]=map[i][j]=INF; for(inti=1;i<=m;i++) { intu,v,w; cin>>u>>v>>w; d[u][v]=map[u][v]=w; } intans=INF; for(intk=1;k<=n;k++) { for(inti=1;i<k;i++) for(intj=i+1;j<k;j++) ans=min(ans,map[k][i]+map[j][k]+d[i][j]); for(inti=1;i<=n;i++) for(intj=1;j<=n;j++) if(d[i][k]<INF&&d[k][j]<INF) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); } //for(inti=1;i<=n;i++) //{ //for(intj=1;j<=n;j++) //cout<<d[i][j]<<""; //cout<<endl; //} cout<<ans; return0; } 
第326篇文章[3]
最短路（1）--dijkstra dijkstra是求单元最短路的基本算法，大体思路为： 循环n次每次找出离起点最近的点，（如果这个点已经讨论过，跳过下一个），讨论它能到达的所有下一个点v，如果起点到v的距离大于起点到u的距离加上边的权值，则更新起点到v的距离，称为松弛操作因为一个点讨论过就不会再讨论，所以总共循环n次 //dijkstra #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; constintINF=0x3f3f3f3f; intvis[MAXN],d[MAXN]; intn,m; structedge { intto,next,w; }e[MAXN]; intcnt,head[MAXN]; voidadd(intu,intv,intw) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].w=w; } intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=m;i++) { inta,b,c; cin>>a>>b>>c; add(a,b,c);add(b,a,c); } for(inti=2;i<=n;i++)d[i]=INF; d[1]=0; for(inti=1;i<=n;i++)//每有一个点被取出进行松弛后就必再松弛，所以总共循环n { intminn=INF; intu; for(inti=1;i<=n;i++)if(!vis[i]&&d[i]<minn)minn=d[i],u=i; vis[u]=1; for(inti=head[u];i;i=e[i].next) if(d[e[i].to]>d[u]+e[i].w)d[e[i].to]=d[u]+e[i].w; } return0; } 因为找距离最小的点和找所有中点都要遍历，所以复杂度较高（当然，这已经比用邻接矩阵存储好的多了），所以在找距离最小的点时可以用到优先队列，每次只取取出队首元素就行了，但是这取出的只是队首元素的值，我需要用到它的下标，所以我们可以将它的值和它的下标打包 typedefpair<int,int>pii; 然后再放到优先队列中去 priority_queue<pii,vector<pii>,greater<pii>>; 因为优先队列需要按权值比较，所以应该把权值放在第一位 q.push(make_pair(d[i],i)); 其他的部分和优化前区别不大，下面是代码 //dijkstra优先队列优化 #include<cstdio> #include<cstdlib> #include<queue> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; constintINF=0x3f3f3f3f; intvis[MAXN],d[MAXN]; intn,m; structedge { intto,next,w; }e[MAXN]; intcnt,head[MAXN]; voidadd(intu,intv,intw) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].w=w; } typedefpair<int,int>pii;//因为不仅要去出优先队列中最小的元素，还要知道它对应的点的下标，所以将它和下标打包 priority_queue<pii,vector<pii>,greater<pii>>q; intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=m;i++) { inta,b,c; cin>>a>>b>>c; add(a,b,c);add(b,a,c); } for(inti=2;i<=n;i++)d[i]=INF; q.push(make_pair(d[1],1)); while(!q.empty()) { piit=q.top();q.pop(); intu=t.second; if(vis[u])continue; vis[u]=1; for(inti=head[u];i;i=e[i].next)if(d[e[i].to]>d[u]+e[i].w) { d[e[i].to]=d[u]+e[i].w; q.push(make_pair(d[e[i].to],e[i].to)); } } for(inti=1;i<=n;i++) cout<<d[i]<<""; return0; } 
第327篇文章[3]
POJ2823(单调队列初步) POJ2823(单调队列初步) 滚动窗口问题，单调队列的入门题 假设我要求最大值 思路是创建一个队列，每读入一个数据就和队尾的元素比较如果他大于对尾的元素，队尾就被删除，队尾再往前一个，直到这个数据比队尾小因为是窗口滚动，如果窗口已经离开队首元素，则删除队首元素，对手元素的下一个为队首因为此时要用到下标，所以队列里的值应该是元素的下标 对于这种有指针的题，代码细节非常重要，也是我最讨厌的 在开始循环之前，把1~k-1的元素都放进去先循环删队尾，删完后再把要放的元素放进去队列删空后立刻停止l,r都是直接指向队列的首位元素的当i-k>=q[l]时，需要删除队首元素应该先把要放的元素放进去，再考虑删除队首元素的问题 下面是代码 //单调队列 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1e+6+10; intl=1,r=0;//单调队列的左右指针 intp[MAXN],q[MAXN]; intn,k; intmain() { cin>>n>>k; for(inti=1;i<=n;i++) cin>>p[i]; q[++r]=1; if(k==1)cout<<p[q[l]]<<""; for(inti=2;i<=n;i++) { while(p[i]<p[q[r]]) { r--; if(r<l)break; } q[++r]=i; if((i-k)>=q[l])l++; if(i>=k)cout<<p[q[l]]<<""; } cout<<endl; memset(q,0,sizeof(q)); r=0,l=1; q[++r]=1; if(k==1)cout<<p[q[l]]<<""; for(inti=2;i<=n;i++) { while(p[i]>p[q[r]]) { r--; if(r<l)break; } q[++r]=i; if((i-k)>=q[l])l++; if(i>=k)cout<<p[q[l]]<<""; } return0; } 
第328篇文章[1]
计算机系统大作业 计算机科学与技术学院 2021年6月 摘 要 本文通过现场加载并执行一个hello.c程序，串联概括了一个程序在整个执行的过程中所经历的处理与链接等操作，是对《深入理解计算机系统》的实践和高度概括，可以帮助我们理解linux执行程序的机制和汇编语言的核心知识 关键词：计算机系统，linux （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 hello.c首先经过cpp进行预处理，然后通过ccl进行编译，as对其进行汇编，再经过ld的链接后生成可执行目标程序hello，使用shell运行fork后生成子程序，在在其中使用execve进行加载程序，hello从程序变为进程，即从program变为process，即为p2p。之后映射虚拟内存，载入物理内存，执行代码，为程序分配时间片，程序运行结束后，父进程回收子进程，即为020。 1.2环境与工具 CPUAMD4900HS16GRAM256GSSD Unbuntu16 Dev,vi,readelf,edb,hexedit 1.3中间结果 hello.i:预处理文件；hello.s编译后文件；hello.o:可重定位目标文件；hello可执行目标文件；helloobj.objdmp：反汇编代码helloelf.elf：hello.o的elf格式文件 1.4本章小结 介绍了程序运行过程和实验环境文件等信息 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 （以下格式自行编排，编辑时删除） 概念：cpp为预处理器，根据命令修改c程序，将引用的所有库和源代码合并成一个完整的文本文件。 功能： 将#include语句中提到的文件添加到源代码中用常量替换#define定义的值根据#if后面的条件决定需要编译的代码 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析打开hello.i后我们可以发现其中增加了许多代码，都是#include引用的库中的代码，在这里直接添加到了我们的程序中，保证我们引用的库中的函数可以正常运行 2.4本章小结 预处理过程是将我们编写代码时为了简化使用的库还原成真正可以直接运行的程序，方便在后面的过程中进行编译和运行。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译是将生成的与处理文件转换成汇编语言的程序的过程 作用：编译转换为汇编程序后，会更接近计算机的底层执行程序的逻辑，方便后面进一步的转换为机器代码，并生成可执行目标程序。 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.3.1数据 在这次我们的hello程序中有三种数据类型，整数，字符数组和数组 首先对于字符数组即字符串，我们使用文本编辑器打开生成的hello.s汇编文件，可以轻易找到我们再.c程序中定义的字符串，前面使用string表示，在汇编程序中，被转化为utf8编码，放在特定的位置中，hello也是同理 其次对于整型，其中有全局变量，局部变量，和立即数对于全局变量，与上面的字符串类似，放在了特定的位置中直接进行了定义 对于局部变量，inti，编译器使用了将其存储在栈中的策略，在汇编代码中使用%rbp即可对栈顶进行访问；而立即数则直接转化为了数字出现在汇编代码中 对于数组，我们以argv[]为例，其中存储着只想参数的指针，在编译的过程中，编译器将数组放在指针连续的空间中，并以头部作为起始地址，访问数组中对应的元素时，只需要指定一个索引寄存器，并使用对齐修改值的操作修改，直接访问数组即可，例如途中，rax即为索引，对其加8，即可访问下一元素 3.3.2赋值 我们以对i的赋值为例，在汇编语言中往往也会使用对应的赋值语句操作，例如movl，对i对应的寄存器赋值为0 3.3.3类型转换 程序中有一个运行类型转换操作，当使用intsleepsecs=2.5语句时，对sleepsecs的定义为一个int整型，而对它的赋值确实一个浮点数，这里会对2.5进行类型转换为int，编译器一般会使用向0舍入的原则，直接将其变为2，并将其放在汇编代码中赋值给sleepsecs。 3.3.4计算 上面对数组的操作中已经提到了一些计算的操作，例如addq等，它们会以对应的寄存器为初始目标，并在其上在进行对应操作，c程序中我们一般的计算操作都可以转换为对应的汇编操作，例如i++就是在其对应的寄存器上再加上8访问数组中下一元素的 3.3.5比较与跳转 为了实现分支语句和循环语句，汇编语言中比较和跳转的操作，在跳转时，我们可以直接跳转，也可以使用比较后，根据结果进行跳转的选择，例如在我们的程序中， 这里我们将i与9进行比较，如果i<=9则使用jle语句进入L4。 3.3.6函数调用 在一个函数调用另一个函数时，首先将本函数的返回地址先存在栈中，在向被调用函数传递参数，前六个函数使用规定好的顺序的寄存器，按照顺序分别为rdi,rsi,rdx,rcx,r8,r9，对于剩下需要传递的参数，我们将其保存在栈中传递给被调用函数，当被调用函数返回时，一定会正好清空该函数构造的栈帧，最终栈顶会指向我们最初存下的函数返回地址，使用ret指令即可将PC更新为该返回地址后回到调用函数。 3.4本章小结 本章叙述了汇编语言对应与我们的c程序的一些对应关系和对应转换，可以看出汇编代码的逻辑更加接近机器的底层逻辑。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编会将我们刚刚生成的汇编语言代码生成机器语言，并将其打包为可重定位目标文件，保存在hello.o中 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 分使用命令查看hello.o的elf格式： 打开生成的elf文件 我们可以在其中直观的看到程序的各个信息，Magic描述了生成该文件的系统的字的大小和字节顺序，剩下的部分包括ELF头的大小、目标文件的类别、机器类型、以及节头部表中条目的大小和数量等信息。 接下来是节头，即节头部表 其中为文件中各个接的类型，位置大小等信息 重定位节 其中包含了各个变量和函数的重定位信息，主要包含两种类型，相对寻址即R_X86_64_32，相对寻址即R_X86_64_32_PC，在后面链接为程序时，程序即可根据重定位的信息重新找到变量或函数对应的地址，并进行修改和添加，使得每个变量或函数的信息都是唯一且确定的。 4.4Hello.o的结果解析 使用命令获得反汇编代码 与前面生成的hello.s进行对比，查看差别 1.在直接生成汇编语言时，我们的跳转使用的是形如L1,L2等的跳转标记，但是在反汇编生成的代码中，我们可以发现对应的位置变成了直接的地址。 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 2.之前生成的汇编语言中，函数调用是直接使用函数名称进行的，但是在这里面，需要进行重定位的符号或者函数，目前的跳转地址都是0，需要根据相对或绝对寻址方式在后面连接的过程中生成新的地址。 4.5本章小结 本章介绍了汇编语言转化为.o文件的过程，并介绍了可重定位文件中的对应信息等，并将反汇编文件和正向生成的汇编语言文件进行了比较。 （第4章1分） 第5章链接 5.1链接的概念与作用 在前面生成可重定位文件的基础上，链接会将对应的多个可重定位文件链接加载到一块，链接可以执行于编译时，链接可以执行于编译时或者在运行时。 5.2在Ubuntu下链接的命令 运行命令 使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 执行命令生成hello.elf文件，查看对应信息 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 使用edb打开后，可以研究发现，首先在从0x400000的部分到0x401000的地址中加载程序，一直到0x400fff中的每个节都对应了上图中的地址部分，而0x400fff之后存放了程序的.dynamic-.shstrtab节，我们可以查看程序头 其中提供了各个段在虚拟地址和物理地址中的大小位置标志等信息，例如VirAddr注明了对应的虚拟地址，PhysAddr注明了对应的物理地址。 5.5链接的重定位过程分析 运行命令 通过与helloobj.objdump进行对比，我们可以看到其中多出来了一些节内容，列举如下 .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rala.plt .init .plt .fini .en_frame .dynamic .got .got.plt .data .comment 我们可以归纳出以下结论 在进行链接时，我们同时引用了动态链接器加载入了/lib64/ld-linux-x86-64.so.2，crto、crti.o,crtn.o，添加了许多模块，例如程序入口，初始化函数等，而另一个动态链接共享库中真正定义了我们一般正常使用的函数入printf,sleep等。与上面所说的相对PC寻址和绝对寻址，一些重定位条目中需要进行重定位的内容，根据它的类型是R_X86_64_32还是_X86_64_32_PC，连接器将它们重新分配正确的调用地址。 5.6hello的执行流程 （以下格式自行编排，编辑时删除） 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 子程序列举如下： ld-2.27.so!_dl_startld-27.so!_dl_inithello!_startlibc-2.27.so!__libc_start_main-libc-2.27.so!__cxa_atexit-libc-2.27.so!__libc_csu_inithello!_initlibc-2.27.so!_setjmp-libc-2.27.so!_sigsetjmp--libc-2.27.so!__sigjmp_savehello!mainhello!puts@plthello!exit@plt*hello!printf@plt*hello!sleep@plt*hello!getchar@pltld-2.27.so!_dl_runtime_resolve_xsave-ld-2.27.so!_dl_fixup--ld-2.27.so!_dl_lookup_symbol_xlibc-2.27.so!exit 5.7Hello的动态链接分析 对于动态共享链接库中PIC函数，需要添加重定位记录，等待动态链接器处理，为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT+全局偏移量表实现函数的动态链接。 5.8本章小结 本章介绍了链接的过程以及相比于之前没有连接的程序，程序增加的部分，以及重定位寻址等知识的具体操作。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中的程序的实例，包括文本区域、数据区域、和堆栈。 CPU的处理过程为每个进程提供了一种抽象的假象，我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 Shell是系统运行用户程序的方式，Shell应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 首先，shell通过命令行分析函数分析用户输入的命令行，并声称argv和envp，接下来，shell将判断程序是否为shell的内置程序，如果是则立刻执行，如果不是则使用fork创建子进程，并使用execve加载我们输入的制定运行程序，接下来即判断用户是否要求后台运行，如果不是则让父进程等待回收子进程。 6.3Hello的fork进程创建过程 与上面的运行过程相同，shell会首先受到我们运行hello的命令和我们输入的其他参数，例如学号等，接下来，shell会判断我们运行的程序不是shell中内置程序，所以使用fork，fork函数调用一次，返回两次，给子进程返回0，给父进程返回子进程的PID，父进程和子进程拥有不同的PID，并并行运行，具体的内部运行顺序由CPU随机决定。 6.4Hello的execve过程 excve函数会在保存当前进程的上下文，并在其中加载并运行新的程序，在这里即为我们的hello程序，execve被称为启动加载器的操作系统代码来执行hello程序，加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。 在新程序的内存映像中，与源程序是私有的写时复制区域 6.5Hello的进程执行 逻辑控制流：一系列程序计数器PC的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 内核态和用户态的转换：hello进程在正常运行时处于用户态阶段，当hello程序需要进行系统调用时，会转换进入内核态，在这个过程中会进行上下文切换，在内核态时可以访问内核所有信息，在完成系统调用切换会用户态时，系统会检查信号的状况并选择一个执行对应操作。 6.6hello的异常与信号处理 （以下格式自行编排，编辑时删除） hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 按下ctrl-z之后，shell父进程收到SIGSTP信号,将hello进程挂起，通过ps命令我们可以看出hello进程没有被回收 按下ctrl-c之后，shell父进程收到SIGINT信号，信号处理函数的逻辑是结束hello，并回收hello进程 乱按只是将屏幕的输入缓存到stdin，当下次运行到有关输入的函数例如gets等后，其他字串会当做shell命令行输入 6.7本章小结 本章叙述了hello在被shell调用过程中整个系统的进程调用和信号过程。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。 逻辑地址：程序代码经过编译后出现在 汇编程序中地址。 线性地址：逻辑地址经过段机制后转化为线性地址，为描述符:偏移量的组合形式。 虚拟地址类似线性地址 7.2Intel逻辑地址到线性地址的变换-段式管理 在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值。逻辑地址的格式为段选择符：段内偏移地址 我们首先观察段选择描述符中的T1字段是0or1，得知当前要转换的是GDT中的段，还是LDT中的段，再根据指定的相应的寄存器，得到其地址和大小，得到一个数组，接下来拿出段选择符中的前13位，可以在这个数组中查找到对应的段描述符，即基地址，基地址加上Offset即为要转换的下一个阶段的地址。 7.3Hello的线性地址到物理地址的变换-页式管理 分页把内存划分成大小固定的若干单元，每个单元称为一页，每页包含4k字节的地址空间。每一页的起始地址都是4k字节对齐的。为了能转换成物理地址，我们需要给CPU提供当前任务的线性地址转物理地址的查找表，即页表 为了节约页表占用的内存空间，x86将线性地址通过页目录表和页表两级查找转换成物理地址。32位的线性地址被分成3个部分：最高10位页目录表偏移量，中间10位页表偏移量，最低12位是物理页内的字节偏移量。页目录表的大小为4k，包含1024项，每个项4字节，项目里存储的内容就是页表的物理地址。如果页目录表中的页表尚未分配，则物理地址填0。页表的大小也是4k，同样包含1024项，每个项4字节，内容为最终物理页的物理内存起始地址。 7.4TLB与四级页表支持下的VA到PA的变换 MMU根据VPN访问TLB和页表，获取其中的PPN，并与VPO进行合并，即可得到PA 7.5三级Cache支持下的物理内存访问 首先直接访问一级缓存，不命中时访问二级，再不命中访问三级，接下来主存，访问到后即逐步将新的内容加载到上级缓存中，必要时会进行驱逐。 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程分配一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本，将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 首先删除已存在的用户区域创建新的区域结构:代码和初始化数据映射到.text和.data区（目标文件提供）,.bss和栈映射到匿名文件设置PC，指向代码区域的入口点 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 维护一个虚拟内存区域“堆”，将堆视为=不同大小的块的集合来维护，分为已分配块和空闲块 隐式空闲链表为所有的块构成一个链表，为了方便合并空闲块，每个空闲块存在头部和脚部，可以分为三种情况进行合并，分别为这个空闲块的前面为空闲块，后面不是，或者后面是，前面不是，或者后面前面都是。在这三种情况下分别进行头部脚部的更新操作，即可极大的减少外部碎片发生的几率 对于显式空闲链表，是所有的空闲块构成一个链表，这样在我们寻找空闲块的过程中，就不需要搜索所有块了，只需要寻找所有的空闲块。 7.10本章小结 本章主要介绍了计算机的虚拟内存和物理内存的对应关系，以及在程序运行时，分配内存等操作。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 （以下格式自行编排，编辑时删除） 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 1.打开和关闭文件:open()andclose() 2.读写文件:read()andwrite() 3.改变当前的文件位置lseek() 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(–n>=0)?(unsignedchar)*bb++:EOF; } 8.5本章小结 本章主要阐述了LinuxI/O和UnixI/O接口的关系方式和信息，并分析了一些经典函数例如printf和getchar （第8章1分） 结论 Hello.c程序到最后经过了以下的过程预处理---编译---汇编---链接---运行---创建子进程---运行程序---执行指令 预处理将我们引用的库转换为代码放到代码中，编译将完全体的代码转换为汇编代码，汇编将汇编代码生成可重定位目标文件，链接将我们运行时需要的库加载进来，并进行重定位操作。运行调用shell，创建进程加载我们的程序，执行指令即为CPU将我们的程序转换为底层的指令信息。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.i:预处理文件；hello.s编译后文件；hello.o:可重定位目标文件；hello可执行目标文件；helloobj.objdmp：反汇编代码helloelf.elf：hello.o的elf格式文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 
第329篇文章[3]
Trie树 字符串的插入和查找 如果给定n个字符串，要你在其中寻找字符串s 思路： 暴力算法：挨个比较，直到找出O(nm)如何让他的复杂度变回线性呢，就要用到Trie树了建立一个树，每个节点对应一个编号，表示一个字母，如果要在这个节点下再加入一个字母，则节点编号数++ 用ch[i][a]表示一条边，i是父亲节点的编号，a是一个字母，如果父亲对这个字母有连边，ch[i][a]=sz(编号）++，所以ch[i][a]对应字母a的编号，继续插入时从sz继续讨论当一个字符串插入完成后，在这个字符串的最后字母上加上附加值，表示这个字母是一个字符串的终点，当附加值==0时，表示他不是任何字符串的终点，这个附加值可以是字符串的标号 建成的树如图（出自刘汝佳《算法竞赛入门经典训练指南》） #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=2000+10; intd[MAXN]; //字母表为全体小写字母的Trie structTrie { intsz; intch[MAXN][26]; voidclear(){sz=1;memset(ch[0],0,sizeof(ch[0]));sz=1;}//初始时只有一个根结点 intval[MAXN]; intcal(chara){returna-'a';} //插入字符串s，附加信息为v。注意v必须非0，因为0代表“本结点不是单词结点” voidinsert(constchar*s,intv) { intu=0; intn=strlen(s); for(inti=0;i<n;i++) { intc=cal(s[i]); if(!ch[u][c])//结点不存在 { memset(ch[sz],0,sizeof(ch[sz]));//相当于申请新的内存空间（把即将加入的节点编号初始化） val[sz]=0;//中间结点的附加信息为0 ch[u][c]=sz++;//新建结点 } u=ch[u][c];//往下走 } val[u]=v;//字符串的最后一个字符的附加信息为v } //找出字符串s并返回它的附加信息 intfind(constchar*s)//查找 { intu=0; intn=strlen(s); for(inti=0;i<n;i++) { intc=cal(s[i]); if(ch[u][c])u=ch[u][c];//如果下一个字符在树中，往下走 elsereturn0; } if(!val[u])return0;//如果最后一个字符没有附加信息，则没有该字符串 elsereturnval[u]; } }; Trietrie; charstr[MAXN]; intmain() { trie.clear(); while(scanf("%s",str)==1) { trie.insert(str,3); cout<<trie.find(str)<<endl; } return0; } 
第330篇文章[]
几种重要的设计模式的便于记忆归纳 1. 适配器：把所有拉进来，根据情况执行 2. 装饰器：把要装饰的拉进来，再添点操作 3. 模版：抽象类，空三个，写一个用这三个，这三个在子类中实现 4. 策略：一个类引用另一种策略类，执行策略类中的操作，策略类可以换 5. 访问者：访问者类引用多个被访问者类，判断后输出判断结果 
第331篇文章[3]
洛谷1011车站（数学，模拟） LUOGU-P1011车站（数学，模拟） 题目描述 火车从始发站（称为第1站）开出，在始发站上车的人数为a，然后到达第2站，在第2站有人上、下车，但上、下车的人数相同，因此在第2站开出时（即在到达第3站之前）车上的人数保持为a人。从第3站起（包括第3站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第n-1站），都满足此规律。现给出的条件是：共有N个车站，始发站上车的人数为a，最后一站下车的人数是m（全部下车）。试问x站开出时车上的人数是多少？ 输入格式：a(<=20)，n(<=20)，m(<=2000)，和x(<=20)， 输出格式：从x站开出时车上的人数。 输入输出样例 输入样例#1：57324输出样例#1：13 分析： 因为“上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数”，所以实际上这一站添加的人数相当于前一站上车的人数设第二站上车人数为b，因为“上车的人数都是前两站上车人数之和“，递推出每一站的上车人数： 1234567…aba+ba+2b2a+3b3a+5b5a+8b 所以可以初始化上车人数数组，用ac[i]表示a的系数，用bc[i]表示b的系数 voidinit_c() { ac[1]=1;ac[2]=0; bc[1]=0;bc[2]=1; for(inti=3;i<=n;i++) { ac[i]=ac[i-1]+ac[i-2]; bc[i]=bc[i-1]+bc[i-2]; } } 所以第x站的人数=a*(ac[1]+ac[2]+ac[3]+…+ac[x])+b*(bc[1]+bc[2]+bc[3]+…+bc[x])用sac[i]表示(ac[1]+ac[2]+ac[3]+…+ac[i])，sbc[i]同理 voidinit_sc() { for(inti=1;i<=n;i++) { sac[i]=ac[i]+sac[i-1]; sbc[i]=bc[i]+sbc[i-1]; } } 然后根据最后一站（第n站）下车的人数即可推出b，即 b=m−(a+a∗sac[n−3])sbc[n−3] 注意：因为第n站为终点站，所以该站下车的人数等于从n-1站开出是的人数，所以要在n-1的基础上-2，即sac[n-3]那么从第x站开出时车上人数（此时不用-1）： x=a+a∗sac[x−2]+b∗sbc[n−2] 代码： #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=100+10; intac[MAXN],bc[MAXN];//a的系数和b的系数,代表上车的人数 intsac[MAXN],sbc[MAXN]; inta,n,m,x,b; voidinit_c() { ac[1]=1;ac[2]=0; bc[1]=0;bc[2]=1; for(inti=3;i<=n;i++) { ac[i]=ac[i-1]+ac[i-2]; bc[i]=bc[i-1]+bc[i-2]; } } voidinit_sc() { for(inti=1;i<=n;i++) { sac[i]=ac[i]+sac[i-1]; sbc[i]=bc[i]+sbc[i-1]; } } intmain() { cin>>a>>n>>m>>x; init_c(); init_sc(); b=(m-a-a*sac[n-3])/sbc[n-3]; intans=a+a*sac[x-2]+b*sbc[x-2]; cout<<ans; return0; } 
第332篇文章[3]
线段树基本操作（1） 线段树基本操作（1） （建树，查询和单点修改） 用途 线段树可以快速的对一段区间进行操作，包括求区间最值，并在对某点修改后再次求区间最值，对一个区间上的所有点进行修改等不需要对区间上的元素进行循环，而是一种类似于二分，分治的思想 方法 把一段长度为2^k的区间逐次对半分，可以总共分成2^(k+1)-1各节点，变成了一棵二叉树对于区间[lt,rt]，它的子节点为区间[lt,mid]和区间[mid+1,rt]查询时只要要查询的区间的左右边界刚好等于已知区间的边界，就可以返回值了，不需要一搜到底对于单点修改，基本上和二分查找差不多（查找时查找的值是该点的下标） //线段树 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; intn; intval[2*MAXN],p[MAXN]; voidbuild(intnode,intlt,intrt)//建树 { if(lt==rt){val[node]=p[lt];return;} intmid=(lt+rt)>>1; build(node*2,lt,mid);build(node*2+1,mid+1,rt); val[node]=min(val[node*2],val[node*2+1]); return; } intquery(intnode,intlt,intrt,intll,intrr)//区间查询 //lt,rt：点node的左右区间ll,rr：要查的左右区间 { if(lt==ll&&rt==rr)returnval[node]; intmid=(lt+rt)>>1; if(rr<=mid)returnquery(node*2,lt,mid,ll,rr); if(ll>mid)returnquery(node*2+1,mid+1,rt,ll,rr); intv1=query(node*2,lt,mid,ll,mid); intv2=query(node*2+1,mid+1,rt,mid+1,rr); returnmin(v1,v2); } //使用条件：相邻的区间的信息可以被合并成两个区间的并区间的信息 voidchange(intnode,intlt,intrt,intu,intadd)//单点修改 //u要修改的值的下标，add要给修改的值加上的值 { if(lt==rt){val[node]+=add;return;} intmid=(lt+rt)>>1; if(u<=mid)change(node*2,lt,mid,u,add); if(u>mid)change(node*2+1,mid+1,rt,u,add); val[node]=min(val[node*2],val[node*2+1]);//回溯修改 } intmain() { cin>>n; for(inti=1;i<=n;i++) cin>>p[i]; build(1,1,n); //intl,r; //cin>>l>>r; //cout<<query(1,1,n,l,r); intu,d; cin>>u>>d; change(1,1,n,u,d); cout<<query(1,1,n,2,4); return0; } 
第333篇文章[3]
有向图的强连通分量（Tanjan） 给定一个有向图，定义： 强连通分量：在一堆点中，任意两点都可以互相到达 求所有的强联通分量 思路： 记录一个点的时间戳和他能到达的最早点每深搜到一个点进队列，直到发现一个点能到达的最早点就是他自己，则把队尾一直到他的所有点输出，这就是一个强联通分量里的所有点 //Tanjan求强连通分量 #include<stack> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; intn,m; intlowlink[MAXN],qiang[MAXN],qiang_cnt; intpre[MAXN],tim; stack<int>s; inthead[MAXN],cnt; structedge { intto,next,num; }e[MAXN]; voidadd(intu,intv,inty) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].num=y; } voiddfs(intu) { pre[u]=lowlink[u]=++tim; s.push(u); for(inti=head[u];i;i=e[i].next) { intv=e[i].to; if(!pre[v]) { dfs(v); lowlink[u]=min(lowlink[u],lowlink[v]);//用后代所能到达的最早点更新u所能到达的最早点 } elseif(!qiang[v])lowlink[u]=min(lowlink[u],pre[v]);//如果遇到一个点已经讨论过，但是还没有加入任何强连通分量，则将他的时间戳与lowlink更新 } if(lowlink[u]==pre[u]) { qiang_cnt++; while(1) { intx=s.top();s.pop(); qiang[x]=qiang_cnt; if(x==u)break; } } } intmain() { intn,m; cin>>n>>m; for(inti=1;i<=m;i++) { intu,v;cin>>u>>v; add(u,v,i); } for(inti=1;i<=n;i++) if(!pre[i])dfs(i); for(intk=1;k<=qiang_cnt;k++) { for(inti=1;i<=n;i++) if(qiang[i]==k)cout<<i<<""; cout<<endl; } return0; } 
第334篇文章[]
git逻辑梳理 1.大致分为但各区域 workspace stage(标记文件) localrepository remoterepository -gitadd-> -gitcommit-> -gitpush-> 2.发生冲突时（对一个文件进行了不同修改） 两个个branch不能再进行合并 3.fetch 直接从远端拷贝下来，相同文件覆盖 4.对于没有冲突的不同文件，可以进行merge 5.gitpull=fetch+merge 
第335篇文章[]
静态工厂方法的实例理解 先上例子 主要思路为在接口中定义一个静态的函数，可以直接初始化一个任意的实现类 这样在多个实现类的情况下，在具体调用过程中可以不管具体实现操作，直接初始化接口的特定实现类 在每个实现类中特性化地实现构造函数即可 
第336篇文章[3]
拓扑排序 给定一些关系，如a>b，要求生成拓扑序，即对于所有形如a>b的关系，最后生成的点的序列中a必须在b的前面 可以把每个关系看成一条有向边，很明显，如果可以生成序列，则这个图一定是无环的所以问题转化成了遍历有向图，生成序列，后搜索到的节点一定在先搜索到的节点的后面可以用dfs处理，每搜索到一个元素，如果他后面不会生成环，就把他放入队首，因为当当前dfs退出时，新的当前dfs的元素要放在上一个前面，所以在放在队首即可如何判断是否形成了环呢？可以定义一个标记，如果u的指向v的标记值为-1，表示这个点正在dfs的上面某层中，即当前讨论的点u一定是从点v连过来的，（即递归调用dfs(v)正在栈帧中，尚未返回），就形成环了，直接returnfalse如果标记值为-1，表示没有讨论过因为每个点只能进队一次，所以标记值为1时，表示已经进过队了，不再讨论 下面是代码 //拓扑排序 #include<cstdio> #include<stack> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; intn,m; stack<int>s; structedge { intnext,to; }e[MAXN]; inthead[MAXN],cnt; voidadd(intu,intv) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; } intvis[MAXN];//在dfs中，判断点i的状态，如果为-1表示该点正在被访问，0表示为被访问过，1表示已经访问过 booldfs(intu) { vis[u]=-1; for(inti=head[u];i;i=e[i].next) { intv=e[i].to; if(vis[v]==-1)returnfalse; if(!vis[v]&&!dfs(v))returnfalse; } vis[u]=1; s.push(u);//因为DFS会一直到底，所以到底后把元素放入队首，return后到上一层函数后在放入队首，可以保证正序 returntrue; } voidprint_ans() { while(!s.empty()) {cout<<s.top()<<"";s.pop();} } booltapo() { memset(vis,0,sizeof(vis)); for(inti=1;i<=n;i++)if(!vis[i]) if(!dfs(i))returnfalse; returntrue; } intmain() { cin>>n>>m; for(inti=1;i<=m;i++) { intu,v; cin>>u>>v; add(u,v); } if(tapo())print_ans(); elsecout<<"NO"; return0; } 
第337篇文章[3]
二分图（1）--染色问题 题目大意：给定一个连通图，让你对它进行染色，总共黑白两种颜色，相邻两个节点不能是同一种颜色，问是否可以染 解析： 二分图：对于一个无向连通图，如果可以把所有点分成不相交的两部分，使所有边的起点和终点分别在两个部分内，称为二分图（即不能有边的起点和终点在一个部分内）转化为本题即为不能有边的起点和终点是同一种颜色 如图 代码实现： 定义数组color[]，1表示白色，2表示黑色，0表示未访问用dfs，对于dfs(u)，遍历它的所有v，如果有v访问过并且与他同色，返回false对于未访问过的v,对他染色并dfs(v)，如果dfs(v)不成功dfs(u)也不成功 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; intcolor[MAXN]; intn,m; inthead[MAXN],cnt; structedge { intto,next; }e[MAXN]; voidadd(intu,intv) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; } boolerfen(intu) { for(inti=head[u];i;i=e[i].next) { intv=e[i].to; if(color[u]==color[v])returnfalse; if(!color[v]) { color[v]=3-color[u]; if(!erfen(v))returnfalse; } } returntrue; } intmain() { cin>>n>>m; for(inti=1;i<=m;i++) { intu,v; cin>>u>>v; add(u,v);add(v,u); } color[1]=1; if(erfen(1))cout<<"YES"; elsecout<<"NO"; return0; } 
第338篇文章[3]
POJ2393USACOMarchGold 对于每周的货物，讨论他之前的星期，如果提前生产费用就是c[i]+(j-i)*s,会TLE，所以要进行剪枝 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; longlongn,s,ans; constintMAXN=10000+10; longlongc[MAXN],y[MAXN],vis[MAXN]; intmain() { cin>>n>>s; for(inti=1;i<=n;i++) cin>>c[i]>>y[i]; for(inti=2;i<=n;i++) for(intj=i-1;j>=1;j--) { if((c[j]+(i-j)*s)<c[i])c[i]=c[j]+(i-j)*s; if(vis[j])break; elsevis[j]=1; } for(inti=1;i<=n;i++) ans+=y[i]*c[i]; cout<<ans; return0; } 
第339篇文章[3]
Havel-Hakimi定理 Havel定理是用来判断是否成图的，对于一个点的序列，现在已知每个点的度，要求判定是否可以按要求组成一个图 判定过程： 把所有点按照度的大小从大到小排序对首元素的度为s1，则删除该元素，把他后面的s1个元素的度都-1，然后重新排序不断重复这个循环，如果过程中有点的度变成了-1，则不能成图，如果最后所有点的度都为0，则可以成图可以在给点的度-1的时候把s1和后面的连起来，就可以输出图了 //Havel-Hakimi boolHavel() { for(inti=1;i<n;i++) { sort(s+i,s+1+n,cmp); if(i+s[i]>=n)returnfalse;//如果改点的度大于所剩的点，无法成图 intu=s[i]; for(intj=i+1;j<=i+u;j++) { s[j]--; if(s[j]<0)returnfalse; } } if(s[n-1]!=0)returnfalse; returntrue; } 例题：POJ1659（模板题，要输出图） （时间关系暂时不做） 
第340篇文章[3]
无向图的割顶和桥 给定一个无向连通图，有以下定义： 割顶：如果去掉一个节点，可以把这个无向连通图变成两个连通图，称其为割顶桥：同理，如果去掉一条边，可以把这个连通图变成两个，称其为桥 求割顶和桥： 令一个点为根，从这个点开始dfs用pre表示时间戳，每搜到一个还未搜到的点，标记搜到他的时间用low[]表示一个点可以连接的时间最早的点，而如果这个值还没有它的父亲的时间早或等于他父亲的时间，那么这个点的父亲一定是割顶如图（出自《算法竞赛入门经典训练指南》–刘汝佳）而如果这个值严格大于他父亲的时间，则连接他父亲和他的的这条边一定是桥如果一个点没有父亲，且只有一个儿子，那么他是根且一定不是割顶 //无向连通图的割顶与桥 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; intn,m; intiscut[MAXN];//是否为割顶 intisbri[MAXN];//是否为桥 inttim; intlow[MAXN],pre[MAXN]; inthead[MAXN],cnt; structedge { intto,next,num; }e[MAXN]; voidadd(intu,intv,inty) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].num=y; } intdfs(intu,intfa) { intlowu=pre[u]=++tim; intchild=0; for(inti=head[u];i;i=e[i].next) { intv=e[i].to; if(!pre[v]) { child++; intlowv=dfs(v,u); lowu=min(lowu,lowv);//用其子节点的low更新low值 if(lowv>=pre[u])//如果v点的后代只能连到v自己，则该边为桥，且u为割顶，若还可以连到u，则u仍为割顶且该边不为桥 { if(lowv>pre[u])isbri[e[i].num]=true; iscut[u]=true; }//{iscut[u]=true;isbri[e[i].num]=true;} } elseif(pre[v]<pre[u]&&v!=fa)lowu=min(lowu,pre[v]);//从他连到其父亲的边不是反向边，如果删除他父亲是不能连通的，重点 } if(fa<=0&&child==1)iscut[u]=0;//如果u为根且只有一个儿子，不是割顶 low[u]=lowu; returnlow[u]; } intmain() { intn,m; cin>>n>>m; for(inti=1;i<=m;i++) { intu,v;cin>>u>>v; add(u,v,i);add(v,u,i); } dfs(1,0); for(inti=1;i<=n;i++) if(iscut[i])cout<<i<<""; cout<<endl; for(inti=1;i<=m;i++) if(isbri[i])cout<<i<<""; return0; } 
第341篇文章[]
关于git的一些知识 1.git的一些命令添加文件：gitaddxx.xx提交文件：gitcommit-m“message”push到远程仓库：gitpushoriginmaster从远程仓库pull：gitpulloriginmaster新建分支：gitcheckout-bbranch_name切换分支：gitcheckoutbranch_nameorgitcheckoutmaster选择一个分支与当前分支合并：gitmergebranch_name2（之前已有指令gitcheckoutbranch_name1）2.使用git提交作业的时候，记得检查名字。若名字不对，进入settings里边修改。以实验2为例：3.初次接触git的时候，我们会比较迷茫。我们应该先学会如何配置git，通过网上的相关教程。有些教程存在错误，我们在多次检查之后，如果依然行不通，我们应该换一个教程。第一次配置的时候，我在同学的帮助下才完成。然后我们应该了解git的相关指令。记住指令，我们才能将写好的代码上传。4.分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（gitclone），在本地机器上拷贝一个完整的Git仓库。Git的功能特性：从一般开发者的角度来看，git有以下功能：1、从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。2、在自己的机器上根据不同的开发目的，创建分支，修改代码。3、在单机上自己创建的分支上提交代码。4、在单机上合并分支。5、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。6、生成补丁（patch），把补丁发送给主开发者。7、看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。8、一般开发者之间解决冲突的方法，开发者之间可以使用pull命令解决冲突，解决完冲突之后再向主开发者提交补丁。从主开发者的角度（假设主开发者不用开发代码）看，git有以下功能：1、查看邮件或者通过其它方式查看一般开发者的提交状态。2、打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。3、向公共服务器提交结果，然后通知所有开发人员。优点：适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。缺点：学习周期相对而言比较长。不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。 
第342篇文章[1]
2021-06-30 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算学部学 号1190201820班 级1936603学生金翰廷 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要通过在linux系统中对hello.c的分析，结合书上的材料，我们又把程序的预处理、编译、汇编、链接的过程复习了一遍，使我们对计算机系统这门课的理解更加深入。关键词：linux；计算机系统；汇编； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-4-1.1HELLO简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在UBUNTU下预处理的命令-5-2.3HELLO的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在UBUNTU下编译的命令-6-3.3HELLO的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在UBUNTU下汇编的命令-7-4.3可重定位目标ELF格式-7-4.4HELLO.O的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在UBUNTU下链接的命令-8-5.3可执行目标文件HELLO的格式-8-5.4HELLO的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6HELLO的执行流程-8-5.7HELLO的动态链接分析-8-5.8本章小结-9-第6章HELLO进程管理-10-6.1进程的概念与作用-10-6.2简述壳SHELL-BASH的作用与处理流程-10-6.3HELLO的FORK进程创建过程-10-6.4HELLO的EXECVE过程-10-6.5HELLO的进程执行-10-6.6HELLO的异常与信号处理-10-6.7本章小结-10-第7章HELLO的存储管理-11-7.1HELLO的存储器地址空间-11-7.2INTEL逻辑地址到线性地址的变换-段式管理-11-7.3HELLO的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级CACHE支持下的物理内存访问-11-7.6HELLO进程FORK时的内存映射-11-7.7HELLO进程EXECVE时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章HELLO的IO管理-13-8.1LINUX的IO设备管理方法-13-8.2简述UNIXIO接口及其函数-13-8.3PRINTF的实现分析-13-8.4GETCHAR的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介Hello从出生到死亡，经历了cpp的预处理，ccl的编译，as的汇编，ld的链接。从hello.c到hello.i，从hello.s到hello.o。用户在运行此程序时，shell调用fork产生子进程，hello便成了进程。1.2环境与工具1.2.1硬件环境AMDRyzen75800HwithRadeonGraphicsCPU3.20GHz16GBRAM512GcSSDNVIDIAGeForceRTX3060LaptopGPU1.2.2软件环境Windows1064位VMware15.5.1Ubuntu16.04LTS64位1.2.3开发工具GDBEDBGCCvigedit1.3中间结果hello.i预处理后的文件hello.s汇编代码hello.o二进制文件hello.out可执行程序1.4本章小结本章主要介绍了什么是hello，本文用到的环境和工具，以及一些中间结果 第2章预处理2.1预处理的概念与作用预处理是指在源代码编译之前对其进行的处理。它会将以#include格式包含的文件复制到编译的源文件中。用实际值替换#define定义的字符串。2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 这是hello.i部分结果的截图。由于#include文件被展开，hello.i的行数相较于hello.c急剧增加。2.4本章小结本章讲述了预处理的命令，预处理的概念和作用，以及预处理之后的结果变化。 第3章编译3.1编译的概念与作用ccl的编译使.i文件变成.s文件。编译的时候可以选取适当的优化等级。编译的主要目的是把源程序翻译成目标程序，即高级语言变成汇编语言。3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析3.3.1赋值 3.3.2关系操作 3.3.3函数调用 3.3.4数组访问 3.3.5算术操作 3.3.6数据 int在赋值之前不占空间，使用时保存在寄存器中。字符串类型保存在只读数据区。各种立即数直接在汇编代码中显示。3.3.7局部变量 3.3.8全局函数 3.4本章小结本章讲述了编译的概念和作用，并给出了在Ubuntu下如何获得.s文件。以及在.s中各种命令的解释，各种操作和数据对应的汇编代码。 第4章汇编4.1汇编的概念与作用汇编器as将.s变成.o文件。相当于把机器语言指令打包成可重定位目标程序的格式。4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 Elf头信息位于文件最开始的部分，包括整个文件的结构信息，后面的内容包括Elf的头的大小，机器类型，节头部表，文件偏移，节头部表中条目的大小和数量。节头信息描述了hello.o文件中各个节的信息。重定位条目与符号表信息包括重定位类型与符号所在的位置，用于在链接时提供修改所需的信息。4.4Hello.o的结果解析 反汇编代码 hello.s反汇编代码相比于hello.s要多出机器代码。机器语言是二进制机器指令，是给电脑看的，汇编语言是使用代码描述CPU的动作，是给人看的。二者的映射大部分相同，在细微的地方有一些不同之处。变量符号与函数的调用地址被地址或重定位符号所取代。除此之外，hello.s的操作数是十进制的，但反汇编中的操作数是十六进制的。4.5本章小结本章介绍了一些linux下的代码，hello.o的elf信息和hello.o的反汇编文件与hello.s的异同。 第5章链接5.1链接的概念与作用链接是指将各种代码和数据片段收集并组合成一个单一文件的过程。链接可以在源代码编译成机器代码的时候，程序被加载器加载到内存并执行的时候，应用程序执行时使用。5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 代码区，数据区，共享区，栈，只读数据区，少了重定位段，符号表，GOT5.5链接的重定位过程分析 hello反汇编代码完成了重定位，有确定的虚拟地址，hello.o的反汇编代码未完成重定位，代码中的虚拟地址均为0。hello重定位的过程：(1)重定位节和符号定义链接器将所有类型相同的节合并在一起后，这个节就作为可执行目标文件的节。然后链接器把运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号，当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。(2)重定位节中的符号引用这一步中，连接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。执行这一步，链接器依赖于可重定位目标模块中称为的重定位条目的数据结构。(3)重定位条目当编译器遇到对最终位置未知的目标引用时，它就会生成一个重定位条目。代码的重定位条目放在.rel.txt。5.6hello的执行流程使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。5.7Hello的动态链接分析（以下格式自行编排，编辑时删除）分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 5.8本章小结本章主要介绍了链接的概念与作用。详细介绍了hello.o链接成可执行目标文件的过程。 第6章hello进程管理6.1进程的概念与作用进程是程序的一次执行，进程是程序及其数据在CPU下顺序执行时所发生的活动，进程是具有独立功能的程序在数据集上运行的过程，它是系统进行资源分配和调度的一个独立单位。进程控制是进程管理中最主要的功能。它用于创建一个新进程，终止一个已完毕的进程。或者去终止一个因出现某事件而使其无法执行下去的进程。还可负责进程执行中的状态转换。6.2简述壳Shell-bash的作用与处理流程shell俗称壳,是一种指"为使用者提供操作界面"的嵌入式软件(也被称为命令解析器)。软件提供了一种允许用户与其他操作系统之间进行通讯的一种方式。这种简单的通讯方式可以以交互方式(从键盘输入,并且用户可以立即地得到命令响应),或者以交互方式shellscript(非交互)的方式允许用户执行。shell（即壳）它是一个简单的命令解释器,它允许系统接收到一个用户的命令,然后自动调用相应的命令执行应用程序。Shell的处理流程：shell读取用户从终端使用外部设备输入（通常是键盘输入）的指令。解析所读取的指令，如果这个指令是一个内部指令则立即执行，否则，加载调用一个应用程序为申请的程序创建新的子进程，在子进程的上下文中运行。同时shell还允许接收从键盘读入的外部信号，（如：kill）并根据不同信号的功能进行对应的处理。6.3Hello的fork进程创建过程用户在终端输入对应的指令，这时shell就会读取输入的命令，并开始进行以下操作：第一步：判断hello不是一个内置的shell指令，所以调用应用程序，找到当前所在目录下的可执行文件hello，准备执行。Shell会自动的调用fork（）函数为父进程创建一个新的子进程，子进程就会因此得到与父进程（即shell）虚拟地址空间相同的一段各种的数据结构的副本（包括代码和数据段，堆，共享库和用户栈）。父进程与子进程最大的不同在于他们分别拥有不同的PID，父进程与子进程分别是两个并发的进程，在子进程中程序运行的这个过程中，父进程在原位置等待着程序的运行完毕。6.4Hello的execve过程Execve函数加载并运行可执行目标文件hello，且且包含相对应的一个带参数的列表argv和环境变量的列表exenvp,，只有当出现错误时，例如找不到hello文件时，execve才会返回-1到调用程序，execve调用成功则不会产生返回。在shell调用fork函数之后，execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行程序，使用启动加载器，子进程调用execve函数，在当前进程即子进程的上下文中加载新程序hello，这个程序覆盖当前正在执行的进程的所有的地址空间，但是这样的操作并没有创建一个新的进程，新的进程有和原先进程相同的PID，并且它还继承了打开hello调用execve函数之前所有已经打开的文件描述符。新的栈和堆段都会被初始化为零，新的代码和数据段被初始化为可执行文件中的内容。只有一些调用程序头部的信息才可能会在加载的过程中被从可执行磁盘复制到对应的可执行区域的内存6.5Hello的进程执行进程向每个程序人员提供一种假象,好像他们在一个独占的程序中使用了处理器,这种处理效果的具体实现效果本身就是一个逻辑控制流,它指的是一系列可执行程序的计数器pc的值,这些计数值唯一的定义对应于那些包含在程序的可执行文件目标对象中的可执行指令,或者说它指的是那些包含在程序运行时可以动态通过链接触到可执行程序的共享文件对象的可执行指令。时间片是指一个进程在执行控制流时候所处在的每一个时间段。处理器通过设置在某个控制寄存器中的一个模式位来限制一个程序可以可以执行的指令以及它可以访问的地址空间。没有设置模式位时，进程就运行在用户模式中。用户模式下不允许执行特权指令，不允许使用或者访问内核区的代码或者数据。设置模式位时，进程处于内核模式，该进程可以访问系统中的任何内存位置，可以执行指令集中的任何命令。进程从用户模式变为内核模式的唯一方式是使用诸如中断，故障或陷入系统调用这样的异常。异常发生时，控制传递到异常处理程序，处理器从用户模式转到内核模式。上下文在运行时候的状态这也就是一个进程内核重新开始启动一个被其他进程或者对象库所抢占的网络服务器时该进程所可能需要的一个下文状态。它由通用寄存器、浮点数据寄存器、程序执行计数器、用户栈、状态数据寄存器、内部多核栈和各种应用内核数据结构等各种应用对象的最大值数据寄存器组合构成。在调用进程发送sleep之前,hello在当前的用户内核模式下进程继续运行,在内核中进程再次调用当前的sleep之后进程转入用户内核等待休眠模式,内核中所有正在处理等待休眠请求的应用程序主动请求释放当前正在发送处理sleep休眠请求的进程,将当前调用hello的进程自动加入正在执行等待的队列,移除或退出正在内核中执行的进程等待队列。之后设置定时器，休眠的时间等于自己设置的时间，当计时器时间到时候，发送一个中断信号。内核收到中断信号进行中断处理，hello被重新加入运行队列，等待执行，这时候hello就可以运行在自己的逻辑控制流里面了。6.6hello的异常与信号处理中断（在hello程序执行的过程中可能会出现外部I/O设备引起的异常），异步，总是返回到下一条指令。陷阱（有意的异常，是执行一条指令的结果，hello执行sleep函数的时候会出现这个异常。），同步，总是返回到下一条指令。故障（在执行hello程序的时候，可能会发生缺页故障。），同步，可能返回到当前指令。终止（不可恢复的错误，在hello执行过程可能会出现DRAM或者SRAM位损坏的奇偶错误。），同步，不会返回。 正常结果 输入ctrl+z 运行在后台输入ps fg1 通过fg1可以调到前台 Ctrl+c 在键盘上输入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况是终止前台作业。乱按 乱按只是将屏幕的输入缓存到stdin。6.7本章小结本章介绍了shell的流程作用，hello的进程执行，相关异常处理和信号处理。 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：程序经过编译后出现在汇编代码中的地址。逻辑地址用来指定一个操作数或者是一条指令的地址。是由一个段标识符加上一个指定段内相对地址的偏移量，表示为[段标识符：段内偏移量]。线性地址：也叫虚拟地址，和逻辑地址类似，也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件也是内存的转换前地址。虚拟地址：也就是线性地址。物理地址：用于内存芯片级的单元寻址，与处理器和CPU链接的地址总线相对应。可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。7.2Intel逻辑地址到线性地址的变换-段式管理每个段的首地址就会被储存在各自的段描述符里面,所以的段描述符都将会位于段全局描述符表中(每个段的全局描述符表一个局部称为gdgdt和另一个局部的的段描述符表一个局部称为ldldt),通过段选择符我们可以快速寻找到某个段的段全局描述符。逻辑上段地址的偏移量结构就是段选择符+偏移量。段选择符的索引位组成和定义如下,分别指的是索引位(index),ti,rpl,当索引位ti=0时,段描述符表在rpgdt中,ti=1时,段描述符表在rpldt中。而索引位index就类似一个数组,每个元素内都存放一个段的描述符,索引位首地址就是我们在查找段描述符时再这个元素数组当中的索引。一个段描述符的首地址是指含有8个元素的字节,我们通常可以在查找到段描述符之后获取段的首地址,再把它与线性逻辑地址的偏移量进行相加就可以得到段所需要的一个线性逻辑地址。在分段保护模式下,分段有两种机制:段的选择符在段的描述符表->分段索引->目标段的段描述符条目->目标段的描述符基地址+偏移量=转换为线性段的基地址。由于现代的macosx86系统内核使用的描述符是基本扁平的逻辑模型,即目标段的逻辑地址=线性段的描述符=转换为线性段的基地址,等价于描述符转换为线性地址时关闭了偏移量和分段的功能。这样逻辑段的基地址与转换为线性段的基地址就合二为一了。7.3Hello的线性地址到物理地址的变换-页式管理在分页的机制下地址转化管理机制主要实现了虚拟地址(它也即非非线性内存地址)向虚拟地址物理页或内存地址的非线性分页转化。vm内存系统将虚拟内存的块大小分割成作为一个被我们称为基于虚拟页的内存大小固定的块块用来进行处理这个固定大小的内存问题,每个称为虚拟页的内存大小可以固定为2p=2p个单位字节。类似的,物理块和虚拟内存被再一次细分为一个物理页(也被通常称为页帧),大小与每一个虚拟页的地址大小与其对应的值相等。例如:一个32位的虚拟机器,线性的地址可以最大达到4gb,用4kb为一个页来进行划分,也可以分为1m个页,通过页表处理和查找这些虚拟页的数据,方便对线性地址的大小进行管理。之后计算机会进行一个翻译操作,把一个n元素的虚拟地址空间中的虚拟元素与一个m元素的另一个物理虚拟地址空间相互进行映射,这个翻译操作被我们称为地址翻译。虚拟地址由对应的虚拟物理页号(vpn)和虚拟页偏移量(vpo)共同组成,类似的,物理地址由虚拟物理页偏移号(ppn)和对应的物理页偏移量(ppo)共同分配组成(这里没有特别考虑tlb快表的物理地址结构)。页表中物理地址存在三种常见的情况:未分配:没有在虚拟内存的空间中分配该条目的内存。未分配缓存:在虚拟内存的空间中已经分配了但是没有被直接缓存到对应物理地址的内存中。已分配已缓存:内存已经缓存在了对应物理地址的内存中。页表的基址寄存器paptbr+vpn在页表中可以获得条目pte,通过对比条目对应的有效位判断物理地址是上述哪一种的情况,如果有效则通过提取得出对应物理地址的页号寄存器ppn,与对应的虚拟页偏移量共同分配构成了物理地址寄存器pa。当页面命中时CPU硬件执行的步骤：第1步:处理器会产生一个虚拟地址,并且将它传送给地址管理单元MMU。第2步:MMU生成PTE地址,并从高速缓存/主存请求得到它。第3步:高速缓存或者主存向MMU返回PTE。第4步:MMU构造物理地址,并把它传送给高速缓存/主存。第5步:高速缓存或者主存会返回所请求的数据字给处理器。7.4TLB与四级页表支持下的VA到PA的变换如果按照上述模式，每次CPU产生一个虚拟地址并且发送给地址管理单元，MMU就必须查找一个PTE行来用将虚拟地址翻译成物理地址。为了消除这种操作带来的大量时间开销，MMU中被设计了一个关于PTE的小的缓存，称为翻译后备缓冲器（TLB）也叫快表。例如当每次cpu发现需要重新翻译一个虚拟地址时,它就必须发送一个vpn得到虚拟地址mmu,发送一个vpo位得到一个l1高速缓存.例如当我们使用mmu向一个tlb的组请求一个页表中的条目时,l1高速缓存通过一个vpo位在页表中查找一个相应的数据标记组,并在页表中读出这个组里的个数据标记和相应的数据关键字.当mmu从一个tlb的组得到一个ppn时,代表缓存的工作在这个组的请求之前已经完全准备好,这个组的ppn与就已经可以与这些数据标记文件中的一个虚拟地址进行很好的匹配了。corei7采用四级页表层次结构,每个四级页表进程都有他自己私有的页表层次结构,这种设计方法从两个基本方面就是减少了对内存的需求,如果一级页表的pte全部为空,那么二级页表就不会继续存在,从而为进程节省了大量的内存,而且也只有一级页表才会有需要总是在一个内存中。四级页表的层次结构操作流程如下:36位虚拟地址被寄存器划分出来组成四个9位的片,每个片被寄存器用作到一个页表的偏移量。cr3寄存器内储存了一个l1页表的一个物理起始基地址,指向第一级页表的一个起始和最终位置,这个地址是页表上下文的一部分信息。vpn1提供了到一个l1pet的偏移量,这个pte寄存器包含一个l2页表的起始基地址.vpn2提供了到一个l2pte的偏移量,一共四级,逐级以此层次类推。7.5三级Cache支持下的物理内存访问L1,L2,L3原理相同，此处以L1为例。由于L1Cashe有64组，所以组索引位s为6，每组有8个高速缓存行，由于每个块的大小为64B，所以块偏移为为6，因此标记位为52-6-6=40位。因此L1Cashe的物理访存大致过程如下：(1)组选择取出虚拟地址的组索引位，将二进制组索引转化为一个无符号整数，找到相应的组(2)行匹配把虚拟地址的标记为拿去和相应的组中所有行的标记位进行比较，当虚拟地址的标记位和高速缓存行的标记位匹配时，而且高速缓存行的有效位是1，则高速缓存命中。(3)字选择一旦高速缓存命中，我们就知道我们要找的字节在这个块的某个地方。因此块偏移位提供了第一个字节的偏移。把这个字节的内容取出返回给CPU即可(4)不命中如果高速缓存不命中，那么需要从存储层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位所指示的组中的一个高速缓存行中。一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换。7.6hello进程fork时的内存映射当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。7.7hello进程execve时的内存映射execve函数在当前代码共享进程的上下文中加载并自动运行一个新的代码共享程序,它可能会自动覆盖当前进程的所有虚拟地址和空间,删除当前进程虚拟地址的所有用户虚拟和部分空间中的已存在的代码共享区域和结构,但是它并没有自动创建一个新的代码共享进程。新的运行程序仍然在堆栈中拥有相同的区域pid。之后为新运行程序的用户共享代码、数据、bss和所有堆栈的区域结构创建新的共享区域和结构,这一步叫通过链接映射到新的私有代码共享区域,所有这些新的代码共享区域都可能是在运行时私有的、写时复制的。它首先映射到一个共享的区域,hello这个程序与当前共享的对象libc.so链接,它可能是首先动态通过链接映射到这个代码共享程序上下文中的,然后再通过映射链接到用户虚拟地址和部分空间区域中的另一个共享代码区域内。为了设置一个新的程序计数器,execve函数要做的最后一件要做的事情就是自动设置当前代码共享进程上下文的一个程序计数器,使之成为指向所有代码共享区域的一个入口点(即_start函数)。7.8缺页故障与缺页中断处理缺页故障：当指令引用一个相应的虚拟地址，而与改地址相应的物理页面不再内存中，会触发缺页故障。通过查询页表PTE可以知道虚拟页在磁盘的位置。缺页处理程序从指定的位置加载页面到物理内存中，并更新PTE。然后控制返回给引起缺页故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，因此指令可以没有故障的运行完成。7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域,称为堆.系统之间细节不同,但是不失通用性,假设堆是一个请求二进制零的区域,它紧接在未初始化的数据区域后开始,并向上生长（向更高的地址）.对于每个进程,内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护.每个块就是一个连续的虚拟内存片,要么是已分配的,要么是空闲的.已分配的块显式地保留为供应用程序使用.空闲块可用来分配.空闲块保持空闲,直到它显式地被应用所分配.一个已分配的块保持已分配状态,直到它被释放,这种释放要么是应用程序显式执行的,要么是内存分配器自身隐式执行的。分配器有两种基本风格.两种风格都要求应用显式地分配块.它们的不同之处在于由哪个实体来负责释放已分配的块显式分配器(explicitallocator)：要求应用显式地释放任何已分配的块.例如,C标准库提供一种叫做malloc程序包的显式分配器.C程序通过调用malloc函数来分配一个块,并通过调用free函数来释放一个块.C++中的new和delete操作符与C中的malloc和free相当.隐式分配器(implicitallocator)：要求分配器检测一个已分配块何时不再被程序所使用,那么就释放这个块.隐式分配器也叫做垃圾收集器(garbagecollector),而自动释放未使用的已分配的块的过程叫做垃圾收集(garbagecollection).例如,诸如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。一个块是由一个字的头部,有效载荷,以及可能的一些额外的填充组成的.头部编码了这个块的大小,以及这个块是已分配的还是空闲的.如果我们强加一个双字的对齐约束条件,那么块大小就总是8的倍数,且块大小的最低3位总是零.因此,我们只需要内存大小的29个高位,释放剩余的3位来编码其他信息.在这种情况中,我们用其中的最低位(已分配位)来指明这个块是已分配的还是空闲的。7.10本章小结本章主要通过对hello程序运行时虚拟地址的变化进行分析,解析了适用于hello应用程序的虚拟存储地址空间,分析了虚拟地址,线性地址和虚拟物理线性地址之间的互相转换,页表的命中与不页表的命中,使用动态快表缓存作为页表的高速缓存以及如何加速页表,动态内存管理的操作,fork时的动态内存中断与映射、execve时的动态内存中断与映射、缺页的中断与缺页映射和中断的处理。第8章hello的IO管理8.1Linux的IO设备管理方法一个Linux文件就是一个m个字节的序列，：所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。8.2简述UnixIO接口及其函数UnixI/O接口：1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。2.Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。3.改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。5.关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。UnixI/O函数:1.intopen(char*filename,intflags,mode_tmode)，进程通过调用open函数来打开一个存在的文件或是创建一个新文件的。open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。2.intclose(fd)，fd是需要关闭的文件的描述符，close返回操作结果。3.ssize_tread(intfd,void*buf,size_tn)，read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF，否则返回值表示的是实际传送的字节数量。4.ssize_twirte(intfd,constvoidbuf,size_tn)，write函数从内存位置buf复制至多n个字节到描述符为fd的当前文件位置。8.3printf的实现分析printf的函数体：intprintf(constcharfmt,…){inti;charbuf[256];va_listarg=(va_list)((char)(&fmt)+4);i=vsprintf(buf,fmt,arg);write(buf,i);returni;}va_listarg=(va_list)((char)(&fmt)+4);vsprintf返回的是要打印出来的字符串的长度，它的作用就是产生格式化输出。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章描述了Linux的IO接口及设备的管理。简要的对printf函数的设计和实现做了讲解。结论hello程序最初是一个.c文件，它的内容是程序员所写。写完之后会把hello进行预处理操作从而生成hello.i。随后需要把它转换成.s文件。由于计算机只能识别二进制文件。所以还需要把.s文件转换成.o文件，即可重定位文件。下一步是动态链接过程，hello.o和动态链接库共同链接成可执行目标程序hello。然后hello就可以运行了。运行时shell里面输入./hello1190201820jht。然后fork和execve函数加载映射虚拟内存，为hello创建新的代码数据堆栈段。CPU为hello分配一个时间片，在程序计数器中加入自己的代码，按顺序执行他们。之后程序从cache中很快的取得需要的数据，或者从内存中取出需要的数据，又或是从磁盘加载数据。在此过程中键入ctrl-z就可以让程序挂起，键入ctrl-c，可以停止这个进程。最后，shell回收子进程，内核会删除这个进程使用所需要创建的一系列数据结构。至此，hello程序结束。 附件列出所有的中间产物的文件名，并予以说明起作用。 hello.i经过预处理器处理的源代码，用来查看与源代码的区别。hello.s通过编译器生成的编译程序，用来分析汇编代码与源代码的对应。hello.o可重定位目标程序,分析汇编器行为，通过反汇编与.o进行对比。hello可执行目标程序,分析链接的作用参考文献为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp.[7]https://baike.baidu.com/item/shell/99702?fr=aladdin[8]RandalE.Bryant,DavidR.O’Hallaron.深入理解计算机系统[M].北京：机械工业出版社，2016.7 
第343篇文章[]
java中ArrayList相关应用 初始化：1.动态初始化（指定长度）：数据类型[]数组名称=new数据类型（数据长度）2.静态初始化（指定内容）：数据类型[]数组名称=new数据类型[]{元素1，元素2…} 添加：ArrayListarrayList=newArrayList();arrayList.add(“0”);arrayList.add(“1”); 获取集合元素：ArrayListarrayList=newArrayList();arrayList.add(“0”);arrayList.add(“1”);arrayList.add(“2”);Stringa=arrayList.get(1);Stringb=arrayList.get(2);System.out.println(a);System.out.println(b); 删除集合中的元素：ArrayListarrayList=newArrayList();arrayList.add(“0”);arrayList.add(“1”);arrayList.add(“2”);//先创建Stringa=arrayList.remove(3);System.out.println(“删除的是：”+a); 获取集合长度ArrayListarrayList=newArrayList();arrayList.add(“0”);arrayList.add(“1”);arrayList.add(“2”);//创建ArrayList集合intsize=arrayList.size();System.out.println(“ArrayList集合长度：”+size); 
第344篇文章[]
java练手：万年历 clock：packagewannianli; publicclassClock{privateDisplayhour=newDisplay(24);privateDisplayminiute=newDisplay(60);privateDisplaysecond=newDisplay(60);privateDisplayyear=newDisplay(9999);privateDisplaymonth=newDisplay(12);privateDisplayday;publicvoidstart(){inti,j;for(;;){i=year.getValue();j=month.getValue();if(i%4000||i%40&&i%100!=0){if(j2){day=newDisplay(29);}elseif(j1||j3||j5||j7||j8||j10||j12){day=newDisplay(31);}else{day=newDisplay(30);}}else{if(j2){day=newDisplay(28);}elseif(j1||j3||j5||j7||j8||j10||j12){day=newDisplay(31);}else{day=newDisplay(30);}}second.increase();if(second.getValue()==0){miniute.increase();if(miniute.getValue()==0){hour.increase();if(hour.getValue()==0){day.increase();if(day.getValue()==0){month.increase();if(month.getValue()==0){year.increase();}}}}}System.out.printf("%04d:%02d:%02d:%02d:%02d:%02d\n",year.getValue(),month.getValue(),day.getValue(),hour.getValue(),miniute.getValue(),second.getValue());}}publicstaticvoidmain(String[]args){Clockc=newClock();c.start(); } } displaypackagewannianli; publicclassDisplay{ privateintvalue=0; privateintlimit=0; publicDisplay(intlimit) { this.limit=limit; } publicvoidincrease() { value++; if(value==limit) { value=0; } } publicintgetValue() { returnvalue; } } 
第345篇文章[]
面向对象编程 面向对象(ObjectOriented)是一种编程范式。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。面向对象与面向过程相对，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。面向对象的性质（1）对象唯一性每个对象都有自身唯一的标识，通过这种标识，可找到相应的对象。在对象的整个生命期中，它的标识都不改变，不同的对象不能有相同的标识。（2）抽象性抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。（3）继承性继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。继承性是面向对象程序设计语言不同于其它语言的最重要的特点，是其他语言所没有的。在类层次中，子类只继承一个父类的数据结构和方法，则称为单重继承。在类层次中，子类继承了多个父类的数据结构和方法，则称为多重继承。多重继承，JAVA、VB、NET、Objective-C均仅支持单继承，注意在C++多重继承时，需小心二义性。在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重用性。采用继承性，提供了类的规范的等级结构。通过类的继承关系，使公共的特性能够共享，提高了软件的重用性。（4）多态性多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。多态性允许每个对象以适合自身的方式去响应共同的消息。多态性增强了软件的灵活性和重用性。 
第346篇文章[]
java练手：城市之间距离 packagejava4; importjava.util.ArrayList;importjava.util.Scanner; publicclassa{ publicstaticvoidmain(String[]args){ ArrayList<String>hs=newArrayList<String>(); Scannerin=newScanner(System.in); Stringstr; intn=0; System.out.println("请输入城市"); for(;;) { str=in.next(); Strings="###"; if(str.equals(s)) { System.out.println("城市输入结束"); break; }//若输入“###”表示城市输入结束 hs.add(str); n++; }//循环读入城市并存入容器hs中 int[][]a=newint[n][n]; Scannerin2=newScanner(System.in); System.out.println("请输入距离"); for(inti=0;i<n;i++) { for(intj=0;j<n;j++) { a[i][j]=in2.nextInt(); } }//将距离矩阵读入，存入二维数组a中 System.out.println("结束输入距离"); Stringstr1,str2; Scannerin3=newScanner(System.in); System.out.println("请输入两个城市"); str1=in3.next();//读入第一个要比较的城市 str2=in3.next();//读入第二个要比较的城市 intq=0,w=0; for(intm=0;m<n;m++) { if(hs.get(m).equals(str1)) { q=m;//记录下第一个城市在容器中位置，即矩阵横坐标 break; } }//寻找第一个输入的城市在容器中的第几位 for(intm=0;m<n;m++) { if(hs.get(m).equals(str2)) { w=m;//记录下第二个城市在容器中位置，即矩阵纵坐标 break; } }//寻找第二个输入的城市在容器中的第几位 System.out.println("输出距离："+a[q][w]);//矩阵第i行第j列表示第i个城市与第j个城市之间的距离 } } 
第347篇文章[]
java中map相关知识和操作 Map概述：Map用于保存具有映射关系的数据，Map集合里保存着两组值，一组用于保存Map的ley，另一组保存着Map的value。Map集合的功能概述a:添加功能put(Kkey,Vvalue).b:删除功能voidclear();valueremove(key);c:判断功能booleancontainsKey(key);booleancontainsValue(value);booleanisEmpty()；d:获取功能valueget(key);intsize();//存在即返回键值，否则返回NULL，可以通过返回值来确定是否包含指定键，获取键值对的个数。e:长度功能intsize()：返回集合中的键值对的对数f:取出所有元素先获取map集合中的键存放进set集合中。通过Set集合的迭代器取出Set集合中键，通过map的get(key)方法获取键对应的值。g:Map下常用的子类：Hashtable：内部结构是哈希表。是同步的。不允许键和值为null。其内部子类Properties：用来存储键值对型的配置信息。HashMap：内部结构是哈希表，是不同步的。TreeMap：内部结构是二叉树。是不同步的，可以对Map中的键进行排序。 
第348篇文章[]
软件构造lab2 实验目标概述 根据实验手册简要撰写。 针对给定的应用问题，从问题描述中识别所需的ADT； 设计ADT规约（pre-condition、post-condition）并评估规约的质量； 根据ADT的规约设计测试用例； ADT的泛型化； 根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction） 使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure） 测试ADT的实现并评估测试的覆盖度； 使用ADT及其实现，为应用问题开发程序； 在测试代码中，能够写出testingstrategy并据此设计测试用例。 实验环境配置 简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。 特别是要记录配置过程中遇到的问题和困难，以及如何解决的。 安装配置EclEmma 在这里给出你的GitHubLab2仓库的URL地址（Lab2-学号）。 实验过程 请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。 PoeticWalks 在这里简要概述你对该任务的理解。 实现并测试具有标记顶点的Graph。然后实现一个使用单词的图生成诗歌的类 GetthecodeandprepareGitrepository 如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。 从实验指南中发布的链接上直接下载获取 Problem1:TestGraph<String> 以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。 testadd():测试能不能加入新顶点testSet():测试能不能加入一条新边testRemove():在图中加入一条边，然后删除某顶点，测试这条边是否还存在testVertices():向图中加入顶点测试集合是否正确testsSources():向图中加入顶点和边测试是否返回源头点和权重testTargets():向图中加入顶点和边测试测试某顶点相连是否正确 Problem2:ImplementGraph<String> 以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。 ImplementConcreteEdgesGraph Edge：用source表示源点，target表示目标点，weight表示权重，编写get以上三种数据，然后检查是否存在非法数据 ImplementConcreteVerticesGraph Vertex：用vertexname表示顶点，map存储与改点有关的数据，check检查是否存在空顶点。 Problem3:ImplementgenericGraph<L> Maketheimplementationsgeneric 搜索所有的string并将其转换为L ImplementGraph.empty() 利用conctreteedgesgraph（）实现Graph.empty() Problem4:Poeticwalks TestGraphPoet 借助测试用例实现功能 ImplementGraphPoet 从文本中获得单词图，返回处理好的字符串 Graphpoetryslam 使用Eclemma检查测试的代码覆盖度Beforeyou’redone 请按照C:\Users\a\Downloads\before_youre_donehttp://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done的说明，检查你的程序。 如何通过Git提交当前版本到GitHub上你的Lab2仓库。 在这里给出你的项目的目录结构树状示意图。 Re-implementtheSocialNetworkinLab1 在这里简要概述你对该任务的理解。 在定义了Graph的情况下，实现friendshipgraph类 FriendshipGraph类 给出你的设计和实现思路/过程/结果。 用Graph表示人物关系 Addvertex（）添加顶点 Getdistance（）寻找最短路径并返回路径长度 Person类 给出你的设计和实现思路/过程/结果。 Name表示顶点名字。 Distance表示最短距离。 Map存储所有相连顶点及其权重 List存储所有相连顶点 Check检查是否有重复级和空元素 客户端main() 给出你的设计和实现思路/过程/结果。 由lab1实验指南可得 测试用例 给出你的设计和实现思路/过程/结果。 提交至Git仓库 如何通过Git提交当前版本到GitHub上你的Lab3仓库。 Gitadd Gitcommit-m“xxxx” Gitpushoriginmaster 在这里给出你的项目的目录结构树状示意图。 实验进度记录 请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。 每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。 不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。 日期时间段计划任务实际完成情况2021/6/519:00-22:003.1完成2021/6/719:00-22:003.2粗糙完成2021/6/1312:00-16:00修改bug，完成报告完成 实验过程中遇到的困难与解决途径 遇到的难点解决途径函数较为复杂，编写过程中多次出现问题继续练习，熟练编写技巧分析图中关系时顺序混乱从头理头绪 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 丰富了对于不同类的理解和应用，进一步提高了编程和算法能力 针对以下方面的感受面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？ ADT能够复用数据结构和一系列方法，让代码更加清晰 使用泛型和不使用泛型的编程，对你来说有何差异？ 泛型更方便但限制条件多 在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？ 在一边实现具体类时可以一边测试，利于修改 P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？ 能够提高效率 P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？ 还没理解透彻，仍感到一些困难 为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？ 使开发者能够注意步骤，避免编程混乱 关于本实验的工作量、难度、deadline。 工作量比较大，需要比较长的时间 《软件构造》课程进展到目前，你对该课程有何体会和建议？ 学会了如何提高效率，实现更好的编译 实验目标概述 根据实验手册简要撰写。 针对给定的应用问题，从问题描述中识别所需的ADT； 设计ADT规约（pre-condition、post-condition）并评估规约的质量； 根据ADT的规约设计测试用例； ADT的泛型化； 根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction） 使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure） 测试ADT的实现并评估测试的覆盖度； 使用ADT及其实现，为应用问题开发程序； 在测试代码中，能够写出testingstrategy并据此设计测试用例。 实验环境配置 简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。 特别是要记录配置过程中遇到的问题和困难，以及如何解决的。 安装配置EclEmma 在这里给出你的GitHubLab2仓库的URL地址（Lab2-学号）。 实验过程 请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。 PoeticWalks 在这里简要概述你对该任务的理解。 实现并测试具有标记顶点的Graph。然后实现一个使用单词的图生成诗歌的类 GetthecodeandprepareGitrepository 如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。 从实验指南中发布的链接上直接下载获取 Problem1:TestGraph<String> 以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。 testadd():测试能不能加入新顶点testSet():测试能不能加入一条新边testRemove():在图中加入一条边，然后删除某顶点，测试这条边是否还存在testVertices():向图中加入顶点测试集合是否正确testsSources():向图中加入顶点和边测试是否返回源头点和权重testTargets():向图中加入顶点和边测试测试某顶点相连是否正确 Problem2:ImplementGraph<String> 以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。 ImplementConcreteEdgesGraph Edge：用source表示源点，target表示目标点，weight表示权重，编写get以上三种数据，然后检查是否存在非法数据 ImplementConcreteVerticesGraph Vertex：用vertexname表示顶点，map存储与改点有关的数据，check检查是否存在空顶点。 Problem3:ImplementgenericGraph<L> Maketheimplementationsgeneric 搜索所有的string并将其转换为L ImplementGraph.empty() 利用conctreteedgesgraph（）实现Graph.empty() Problem4:Poeticwalks TestGraphPoet 借助测试用例实现功能 ImplementGraphPoet 从文本中获得单词图，返回处理好的字符串 Graphpoetryslam 使用Eclemma检查测试的代码覆盖度Beforeyou’redone 请按照C:\Users\a\Downloads\before_youre_donehttp://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done的说明，检查你的程序。 如何通过Git提交当前版本到GitHub上你的Lab2仓库。 在这里给出你的项目的目录结构树状示意图。 Re-implementtheSocialNetworkinLab1 在这里简要概述你对该任务的理解。 在定义了Graph的情况下，实现friendshipgraph类 FriendshipGraph类 给出你的设计和实现思路/过程/结果。 用Graph表示人物关系 Addvertex（）添加顶点 Getdistance（）寻找最短路径并返回路径长度 Person类 给出你的设计和实现思路/过程/结果。 Name表示顶点名字。 Distance表示最短距离。 Map存储所有相连顶点及其权重 List存储所有相连顶点 Check检查是否有重复级和空元素 客户端main() 给出你的设计和实现思路/过程/结果。 由lab1实验指南可得 测试用例 给出你的设计和实现思路/过程/结果。 提交至Git仓库 如何通过Git提交当前版本到GitHub上你的Lab3仓库。 Gitadd Gitcommit-m“xxxx” Gitpushoriginmaster 在这里给出你的项目的目录结构树状示意图。 实验进度记录 请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。 每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。 不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。 日期时间段计划任务实际完成情况2021/6/519:00-22:003.1完成2021/6/719:00-22:003.2粗糙完成2021/6/1312:00-16:00修改bug，完成报告完成 实验过程中遇到的困难与解决途径 遇到的难点解决途径函数较为复杂，编写过程中多次出现问题继续练习，熟练编写技巧分析图中关系时顺序混乱从头理头绪 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 丰富了对于不同类的理解和应用，进一步提高了编程和算法能力 针对以下方面的感受面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？ ADT能够复用数据结构和一系列方法，让代码更加清晰 使用泛型和不使用泛型的编程，对你来说有何差异？ 泛型更方便但限制条件多 在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？ 在一边实现具体类时可以一边测试，利于修改 P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？ 能够提高效率 P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？ 还没理解透彻，仍感到一些困难 为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？ 使开发者能够注意步骤，避免编程混乱 关于本实验的工作量、难度、deadline。 工作量比较大，需要比较长的时间 《软件构造》课程进展到目前，你对该课程有何体会和建议？ 学会了如何提高效率，实现更好的编译 
第349篇文章[1]
计算机系统大作业（程序人生） 摘 要 摘要是论文内容的高度概括，应具有独立性和自含性，即不阅读论文的全文，就能获得必要的信息。摘要应包括本论文的目的、主要内容、方法、成果及其理论与实际意义。摘要中不宜使用公式、结构式、图表和非公知公用的符号与术语，不标注引用文献编号，同时避免将摘要写成目录式的内容介绍。 本文介绍了hello程序在Linux下的生命周期，从被创建到运行，最后被终止等一系列的过程。在结合了书本有关知识的基础上，进一步对hello程序的相关知识进行阐述，并借此来加深对于计算机系统的理解。 关键词：关键词1；关键词2；……； 关键词1：计算机系统 关键词2：程序 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P：hello.c预处理成为hello.i，编译得到hello.s，汇编后得到hello.o，最后通过链接，执行程序得到hello 020：shell启动后通过fork函数激活子进程，子进程调用exceve函数，在引入参数后，映射虚拟内存，然后载入物理内存，进入主函数开始执行代码，CPU为程序分配时间片执行逻辑控制流。在程序运行结束后，父进程对子进程进行回收，，内核删除有关的数据结构。 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位 开发与调试工具：gcc，vim，edb，codeblocks 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 Hello.i hello.c预处理之后的文本文件 Hello.s hello.i编译后的汇编文件 Hello.o hello.s汇编后的可重定位目标文件 Hello 链接后的执行目标文件 Hello.out hello反汇编之后的可重定位文件 1.4本章小结 （第1章0.5分） 本章主要介绍了hello的P2P，020过程，描述了实验的环境，列出了实验中的一些过程文件 第2章预处理 2.1预处理的概念与作用 概念：预处理器根据命令，修改原始C程序 作用：对预处理命令进行处理，1、宏定义2、文件包含3、条件编译 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 预处理之后hello.c转化为hello.i文件，其中文件的内容增加了，这些增加的代码就是头文件的源代码，随后进行宏定义以及拓展和条件编译 2.4本章小结 本章描述了有关hello.i的内容，与hello.c进行比较，加深了解 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译器把hello.i翻译成hello.s，利用处理后的源文件生成一个汇编语言程序 作用：把C语言文件转换成了汇编语言文件 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令 应截图，展示编译过程！ 3.3Hello的编译结果解析 3.3.1数据 局部变量：i:作为再函数中船舰的局部变量i被储存在栈中，在这个程序中i被储存在%rbp-4 3.3.2赋值 唯一的赋值是i=0，i在栈上，用mov赋值 3.3.3算数操作 i++，在本实验中用addl实验 3.3.4关系操作 通过cmpl和标志位的状态来实现 3.3.5数组/指针/结构 Argv数组是传入的参数，储存在栈上，在找到argv的地址后就能通过偏移argv+8和argv+16找到argv[1]和argv[2]的地址 3.3.6控制转移 在汇编语言中控制转移通过cmp再加上jXX来实现，cmp指令来改变标志位，然后再用JXX根据标志位来决定是否跳转 3.3.8函数操作 Main函数，printf函数，exit函数，sleep函数 此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~3.3.x等按照类型和操作进行分析，只要hello.s中出现的属于大作业PPT中P4给出的参考C数据与操作，都应解析。 3.4本章小结 本章描述了如何在编译阶段中系统如何把源代码转换成汇编代码，了解了有关汇编的操作 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：把汇编语言翻译成机器语言的过程 作用：汇编器将hello.s翻译成机器语言指令，并把这些指令打包成一种叫做可重定位目标程序的格式，将结果存在目标文件hello.o中。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。 4.2在Ubuntu下汇编的命令 （以下格式自行编排，编辑时删除） 应截图，展示汇编过程！ 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 ELF格式：以一个16字节序列开始，该序列描述了生成该文件的系统的字的大小和字节顺序，其余信息帮助链接器语法分析和解释目标文件信息 节头部表记录了各节名称、类型、地址、偏移量、大小、全体大小、旗标、连接、信息、对齐信息 重定位节，描述了.text节中需要重定位的信息，即当链接器链接该目标文件时需要修改的信息 符号表：程序中定义和引用函数和全局变量的信息，声明重定位需要引用的符号 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 在跳转时，hello.s是直接利用段的名字进行跳转，而在反汇编中则使用相对寻址来进行跳转 Hello.s用十进制，而反汇编用十六进制 Hello.o用函数的名字来调用函数，但反汇编则是用相对寻址来调用函数，并且因为还没有进行重定位所以操作数全是0 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 4.5本章小结 本章描述了可重定位目标程序的ELF格式，以及ELF表所包含的各项信息及其作用 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：将各种代码和数据片段组合成一个单一文件的过程 作用：链接使分离编译成为可能，我们可以独立的修改或编译与文件中的一个个块，在改变这些块之后只需要简单的重新编译即可，同时也提高了效率 注意：这儿的链接是指从hello.o到hello生成过程。 5.2在Ubuntu下链接的命令 使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小，目标文件的类型，及其类型，节头部表的文件偏移，节头部表中条目的大小和数量。如图，ELF包括类别,数据，类型，入口点地址，程序头起点地址，本头大小，节头部大小 节头部表对hello中所有的节信息进行说明 重定位节： 符号表： 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 通过查看edb，看出hello的虚拟地址空间开始于0x400000,结束与0x400ff0 Init段存在于0x401000 Rodata段 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 在完成符号解析之后，链接器将代码中的每个符号引用和符号定义关联，于是链接器就得到了代码节和数据节的大小。然后先进行重新定位，所有同类型的数据都会被重定位到一个节上，然后再对每个节赋予不同的地址，以及节中的每个符号，这个操作保证了程序中的每个节和每个符号都有相应的地址。之后对代码节和数据节中有地址操作的命令或者是数据进行修改，使他们能调用正确的地址。链接器完成符号解析后，将代码中每个符号引用和一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来，此时，链接器就知道了它的输入目标模块中的代码节和数据节的确切大小 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 每个节的位置确定：用已知的每个节的大小加上每个节与头部之间的相对距离来确定具体的位置。 节中每个命令的位置确定：因为已经把接的位置固定了，那么每条命令的位置只需要用每个命令的相对偏移加上节的位置就能得到每条命令的位置。 在重定位之后的变化：原来的可重定位文件中的地址都是相对偏移地址，有一些有关函数调用的地址甚至直接用0来省略了。但hello中的地址都是真正的地址，从这些地址上我们可以取到相应数据。在重定位之后，函数以及各种跳转都是通过虚拟地址或者是偏移量来直接完成的。同时，重定位之后，程序中也新增加了一些函数，这是本程序引用的，且不由本程序自己创建的函数。 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 hello!_start0x401090 __libc_start_main0x403ff0 main0x4010c1 hello!puts@plt0x401030 hello!exit@plt0x401070 hello!printf@plt0x401040 hello!atoi@plt0x401060 hello!sleep@plt0x401080 hello!getchar@plt0x401050 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 执行之前global表是全0的，执行之后被赋予了一个新的地址，我们推断出因为其中一个外部函数属于动态链接符号，所以重定位的过程会从链接阶段延后到dl_init阶段 在dlinit前 在dlinit后 5.8本章小结 本章讲述了链接，分析了链接前后elf表的变化还有重定位之后的ELF表在栈中的储存。在讲述了冲的为的操作流程之后我们分析了重定位前后代码的变化，主要对重定位之后的地址做了解析。最后我们对动态链接进行了分析，通过edb来清晰的观测了动态链接的重定位过程 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础 作用：通过进程，我们能得到假象：我们的程序是系统中当前运行的唯一的程序一样，我们的程序好像是在独占使用处理器和内存，处理器好像是一条无间断地一条接着一条的执行我们程序中的命令，我们程序中的代码好像是系统中唯一的对象 6.2简述壳Shell-bash的作用与处理流程 作用：是一个交互型的应用级程序，可以接受用户输入的命令，然后再系统中运行相应的程序，是用户与系统之间的桥梁 处理流程：读取用户输入的命令，将命令分开，判断是否为内置命令，如果是那就立刻执行，如果不是那就调用fork和execve函数来运行程序完成命令，同时在运行的时侯Shell依然可以读取用户的输入来对当前正在执行的命令进行其他操作，如果找不到能执行这条命令的应用，就显示错误。 6.3Hello的fork进程创建过程 Shell解析命令，然后通过调用fork函数创建子进程，子进程得到一个完全独立的副本，父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成 6.4Hello的execve过程 删除已存在的用户区域映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构映射共享区域 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 进程上下文信息，就是内核重新启动一个被抢占的程序所需的状态，它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈、和各种内核数据结构。 进程时间片，是指一个进程和执行它的控制流的一部分的每一时间段。用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这个决策就叫做调度。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用上文所述的上下文切换的机制将控制转移到新的进程。内核代表的用户执行系统调用时，可能会发生上下文切换；中断也有可能引发上下文切换。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。 终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的错误 6.7本章小结 本章介绍了进程的定义和作用，Shell的处理流程，如何调用fork（）创建子进程，如何调用execve函数执行可执行程序以及hello进程执行时的异常处理情况 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：包含在机器语言中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离 线性地址：逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。是hello中的虚拟内存地址 虚拟地址：CPU执行单元发出的内存地址将被MMU接收，从CPU到MMU的地址称为虚拟地址 物理地址;CPU通过地址来访问内存中的单元，地址有虚拟地址和物理地址之分，如果CPU没有MMU，或者有MMU但没有启用，CPU核在取指令或访问内存时发出的地址将直接传到CPU芯片的外部地址引脚上，直接被内存芯片接收，这称为物理地址 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理：逻辑地址->线性地址==虚拟地址 当TI=0则选择GDT首地址，当TI=1则选择LDT首地址。选取段选择符的前13位乘8再加上根据TI所选的首地址，之后根据得到的结果就能在描述符表中找到段描述符。再将其中的32位基地址和32位段内偏移量相加，就能得到32位线性地址 7.3Hello的线性地址到物理地址的变换-页式管理 页式管理是把物理空间划分成许多块。相应地，把逻辑地址空间划分成许多页页号和页内地址构成线性地址，我们通过页号找到页的起始地址，再加上页内地址就可以得到物理地址 7.4TLB与四级页表支持下的VA到PA的变换 TLB是一个小的虚拟寻址的缓存，其中每一行都保存着一个有单个PTE组成的块。TLB通常有高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号提取的 TLB命中时的步骤： 1、CPU产生一个虚拟地址 2、MMU从TLB中取出相应的PTE 3、MMU将这个虚拟地址翻译成一个物理地址，并且将它送到高速缓存或主存 4、高速缓存或主存将所请求的字返回给CPU 多级页表：一级页表中的每个PTE负责映射虚拟地址空间中的一个4MB的片，这里每一个是由1024个连续的页面组成的。比如PTE0映射第一篇，PTE1映射接下来的一篇，以此类推。假设地址空间是4GB，1034个PTE已经足够覆盖整个空间了。如果片i中的每个页面都未被分配，那么以及PTE就为空，以此类推。 这种方法从俩个方面减少了内存需求，第一，如果第一个PTE为空那么二级页表就不会存在。第二，只有一级页表才需要总是在主存中，系统可以在需要是才创建、调入、调出二级页表 7.5三级Cache支持下的物理内存访问 1.组选择取出虚拟地址的组索引位，将二进制组索引转化为一个无符号整数，找到相应的组 2.行匹配把虚拟地址的标记为拿去和相应的组中所有行的标记位进行比较，当虚拟地址的标记位和高速缓存行的标记位匹配时，而且高速缓存行的有效位是1，则高速缓存命中。 3.字选择一旦高速缓存命中，我们就知道我们要找的字节在这个块的某个地方。因此块偏移位提供了第一个字节的偏移。把这个字节的内容取出返回给CPU即可 4.不命中如果高速缓存不命中，那么需要从存储层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位所指示的组中的一个高速缓存行中。一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点 7.8缺页故障与缺页中断处理 缺页故障：当指令引用一个相应的虚拟地址，而与改地址相应的物理页面不再内存中，会触发缺页故障。通过查询页表PTE可以知道虚拟页在磁盘的位置。缺页处理程序从指定的位置加载页面到物理内存中，并更新PTE。然后控制返回给引起缺页故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，因此指令可以没有故障的运行完成 7.9动态存储分配管理 分配器有两种基本风格。两种风格都是要求显示的释放分配块。 显式分配器：要求应用显示的释放任何已分配的块。例如C标准库提供一个叫做malloc程序包的显示分配器。隐式分配器：要求分配器检测一个已分配块何时不再被程序使用，那么就释放这个块。隐式分配器也叫垃圾收集器。 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 使用后进先出的顺序维护链表，将新释放的块在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块，在这种情况下，释放一个块可以在线性的时间内完成，如果使用了边界标记，那么合并也可以在常数时间内完成。 按照地址顺序来维护链表，其中链表中的每个块的地址都小于它的后继的地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序首次适配比LIFO排序的首次适配有着更高的内存利用率，接近最佳适配的利用率。 7.10本章小结 本章主要介绍了hello的存储器的地址空间，介绍了四种地址空间的差别和地址的相互转换。同时介绍了hello的四级页表的虚拟地址空间到物理地址的转换。阐述了三级cashe的物理内存访问、进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m个字节的序列：B0,B1,B2….Bk,….,Bm-1 所有的I/O设备都被模型化为文件而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixIO接口： 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告他想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，他在后续对此文件的所有操作中标识这个文件。 Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（文件描述符0）、标准输出（描述符为1），标准出错（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，他们可用来代替显式的描述符值。 UnixIO函数： open（）函数 功能描述：用于打开或创建文件，在打开或创建文件时可以指定文件的属性及用户的权限等各种参数。 函数原型:intopen(constchar*pathname,intflags,intperms) 参数：pathname:被打开的文件名（可包括路径名如"dev/ttyS0"）flags:文件打开方式, 返回值：成功：返回文件描述符；失败：返回-1 close（）函数 功能描述：用于关闭一个被打开的的文件 所需头文件：#include<unistd.h> 函数原型:intclose(intfd) 参数：fd文件描述符 函数返回值：0成功，-1出错 read（）函数 功能描述：从文件读取数据。 所需头文件：#include<unistd.h> 函数原型：ssize_tread(intfd,void*buf,size_tcount); 参数：fd：将要读取数据的文件描述词。buf：指缓冲区，即读取的数据会被放到这个缓冲区中去。count：表示调用一次read操作，应该读多少数量的字符。 返回值：返回所读取的字节数；0（读到EOF）；-1（出错）。 write（）函数 功能描述：向文件写入数据。 所需头文件：#include<unistd.h> 函数原型：ssize_twrite(intfd,void*buf,size_tcount); 返回值：写入文件的字节数（成功）；-1（出错） 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 fmt是一个指针，这个指针指向第一个const参数（constchar*fmt)中的第一个元素而vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 Getchar中的read函数将缓冲区都读入buf数组中，返回缓冲区的长度。当buf数组为空，调用read函数，如果不空就返回buf中的第一个元素。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章讲述了IO设备的管理方法，IO接口及其函数，最后分析了printf和getchar函数的实现方法。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 1.编写hello代码，通过IDE将代码键入hello.c 2.预处理，hello.c经过预处理器处理得到文本文件hello.i 3.编译，hello.i编译成汇编文件hello.s 4.汇编，hello.s经汇编器翻译成机器语言指令，打包成为可重定位目标文件hello.o 5.链接，hello.o与可重定位目标文件和动态链接库链接成可执行目标程序hello 6.在shell中运行hello，shell进程调用fork为hello创建子进程 7.运行程序：子进程调用execve，execve调用启动加载器，映射虚拟内存，进入程序入口后程序载入物理内存，进入main函数。 8.执行指令：CPU为进程分配时间片，执行的控制逻辑流 9.访问内存：MMU将虚拟内存地址通过页表映射成物理地址。 10.动态申请内存：printf调用malloc向动态内存分配器申请堆中的内存。 11.信号：内核通过信号系统来处理程序执行中的用户请求和异常 12.结束：shell父进程回收子进程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 通过本学期的学习，我对于计算机系统有了一定程度的了解，并在不断地实验中锻炼自己的操作能力，更加深入的学习了有关计算机的知识。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 hello.c C语言源程序 hello.ihello.c 预处理后生成的文本文件 hello.s hello.i 经编译器翻译后生成的文本文件 hello.ohello.s 经过汇编器翻译后生成的可重定位目标文件 hellohello.o 链接后的可执行文件 hello.elf elf格式文件 （附件0分，缺失-1分） 
第350篇文章[1]
程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190201924 班 级 1936601 学 生 朱健坤 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 摘本论文将CSAPP课程所学内容通过hello小程序的一生，对我们所学进行全面的梳理与回顾。我们主要在Ubuntu下进行相关操作，合理运用了Ubuntu下的操作工具，进行细致的历程分析，目的是加深对计算机系统的了解。 关键词：hello；程序的一生；计算机系统；Ubuntu （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述-4- 1.1Hello简介-4- 1.2环境与工具-4- 1.3中间结果-4- 1.4本章小结-5- 第2章预处理-6- 2.1预处理的概念与作用-6- 2.2在Ubuntu下预处理的命令-6- 2.3Hello的预处理结果解析-6- 2.4本章小结-8- 第3章编译-9- 3.1编译的概念与作用-9- 3.2在Ubuntu下编译的命令-9- 3.3Hello的编译结果解析-9- 3.4本章小结-13- 第4章汇编-14- 4.1汇编的概念与作用-14- 4.2在Ubuntu下汇编的命令-14- 4.3可重定位目标elf格式-14- 4.4Hello.o的结果解析-15- 4.5本章小结-18- 第5章链接-19- 5.1链接的概念与作用-19- 5.2在Ubuntu下链接的命令-19- 5.3可执行目标文件hello的格式-19- 5.4hello的虚拟地址空间-20- 5.5链接的重定位过程分析-21- 5.6hello的执行流程-22- 5.7Hello的动态链接分析-23- 5.8本章小结-24- 第6章hello进程管理-25- 6.1进程的概念与作用-25- 6.2简述壳Shell-bash的作用与处理流程-25- 6.3Hello的fork进程创建过程-25- 6.4Hello的execve过程-26- 6.5Hello的进程执行-26- 6.6hello的异常与信号处理-27- 6.7本章小结-28- 第7章hello的存储管理-29- 7.1hello的存储器地址空间-29- 7.2Intel逻辑地址到线性地址的变换-段式管理-29- 7.3Hello的线性地址到物理地址的变换-页式管理-30- 7.4TLB与四级页表支持下的VA到PA的变换-30- 7.5三级Cache支持下的物理内存访问-31- 7.6hello进程fork时的内存映射-31- 7.7hello进程execve时的内存映射-32- 7.8缺页故障与缺页中断处理-32- 7.9动态存储分配管理-32- 7.10本章小结-33- 第8章hello的IO管理-34- 8.1Linux的IO设备管理方法-34- 8.2简述UnixIO接口及其函数-34- 8.3printf的实现分析-34- 8.4getchar的实现分析-35- 8.5本章小结-35- 结论-36- 附件-37- 参考文献-38- 第1章概述 1.1Hello简介 P2P： Program：在editor中键入代码得到hello.c程序 Process：hello.c（在Linux中），经过过cpp的预处理、ccl的编译、as的汇编、ld的链接最终成为可执目标程序hello。在shell中键入启动命令后，shell为其fork，产生子进程。 020： shell为hello进程execve，映射虚拟内存，进入程序入口后程序开始载入物理内存。 进入main函数执行目标代码，CPU为运行的hello分配时间片执行逻辑控制流。 当程序运行结束后，shell父进程负责回收hello进程，内核删除相关数据结构。 1.2环境与工具 硬件环境：处理器：Intel®Core™i7-8550UCPU@1.80GHz1.99GHz RAM：8.00GB系统类型：64位操作系统，基于x64的处理器 软件环境：Windows1064位；Ubuntu19.04 开发与调试工具：gcc，as，ld，vim，edb，readelf，VScode 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 预处理后的文件hello.i 编译之后的汇编文件hello.s 汇编之后的可重定位目标文件hello.o 链接之后的可执行目标文件Hello Hello.o的ELF格式Elf.txt Hello.o的反汇编代码Disas_hello.s hello的ELF格式hello1.elf hello的反汇编代码hello1_objdump.s 1.4本章小结 简述的P2P，020，分析列举了实验的前期工具，环境准备和实验中可能产生的中间文件 第2章预处理 2.1 预处理的概念与作用 概念：预处理器cpp根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件。 主要功能如下：1：将源文件中用#include形式声明的文件复制到新的程序中。2：用实际值替换用#define定义的字符串3：根据#if后面的条件决定需要编译的代码 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 打开hello.i，发现原来的helloc.c已经被拓展成几千行，前面的内容是hello.c的三个#include指令包含的头文件的代码，先寻找main函数，如下图。 再看之前的头文件的处理，以第一条#include指令为例，cpp到默认的环境变量下搜索stdio.h头文件，打开/usr/include/stdio.h，发现其中仍有#include指令，于是再去搜索包含的头文件，直到最后的文件中没有#include指令，并把所有文件中的所有#define和#ifdef指令进行处理，执行宏替换和通过条件确定是否处理定义的指令。 2.4本章小结 .c文件中包含有头文件也就是有外部文件的，还有一些程序员需要但是对于程序执行没有任何帮助的宏定义以注释，和一些程序员需要的条件编译和完善程序文本文件等操作都需要通过预处理来实现。预处理可以使得程序在后序的操作中不受阻碍，是非常重要的步骤。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的概念：编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。其以高级程序设计语言书写的源程序作为输入，而以汇编语言或机器语言表示的目标程序作为输出。这个过程称为编译，同时也是编译的作用。 编译程序的基本功能是把源程序(高级语言)翻译成目标程序。除了基本功能之外，编译程序还具备语法检查、调试措施、修改手段、覆盖处理、目标程序优化、不同语言合用以及人际联系等重要功能。 3.2在Ubuntu下编译的命令 图3.1hello.i编译生成hello.s 3.3Hello的编译结果解析 1.字符串 程序中用到的字符串有：“用法:Hello学号姓名秒数！\n”和“Hello%s%s\n”。编译器一般将字符串存放在.rodata节，这两个个字符串在hello.s中的存储如下图，可以看到第一个字符串中的汉字被编码成UTF-8格式，一个汉字占三个字节，每个字节用\分隔。第二个字符串中的两个%s为用户在终端运行hello时输入的两个参数。 图3.2hello.s存储的两个字符串 2.整数 hello.c中的整型变量有argc和i。 其中argc是从终端传入的参数个数，也是main函数的第一个参数，所以由寄存器%edi进行保存。由图3.3可知，argc又被存入了栈中-20(%rbp)的位置。 图3.3argc被保存在栈中 i则是局部变量，用来控制循环次数的计数器，编译器会将局部变量保存在寄存器或者栈中，由图3.4的30行看出hello.s将i存储在栈中-4(%rbp)的位置。 数组 hello.c中数组是main函数的第二个参数，char*argv[]，是字符指针数组，由于是第二个参数因而被保存在寄存器%rsi中，由图3.5可知它随后又被保存在了栈中-32(%rbp)的位置。 在访问argv[]所指向的内容时，每次先获得数组的起始地址，如图3.6的第33、36、43行，然后通过加8*i来访问之后的字符指针，如图3.6中的第34、37、44，原因是每个字符指针所占的空间大小围为8个字节。然后通过获得的字符指针寻找字符串。 赋值 hello.c中的赋值操作只有i=0这一条，这条语句在汇编中用mov指令实现，由于int占4个字节，所以以‘l’作为后缀。如图3.7。 算术操作 数据算术操作汇编指令： 指令效果 leaqS,DD=&S INCDD+=1 DECDD-=1 NEGDD=-D ADDS,DD=D+S SUBS,DD=D-S IMULQSR[%rdx]:R[%rax]=SR%rax MULQSR[%rdx]:R[%rax]=SR%rax IDIVQSR[%rdx]=R[%rdx]:R[%rax]modS(有符号) R[%rdx]=R[%rdx]:R[%rax]divS DIVQSR[%rdx]=R[%rdx]:R[%rax]modS(无符号) R[%rdx]=R[%rdx]:R[%rax]divS 程序中涉及的算数操作有： 1：i++，对计数器i自增，使用程序指令addl，后缀l代表操作数是一个4B大小的数据。 2：汇编中使用leaq.LC1(%rip),%rdi，使用了加载有效地址指令leaq计算LC1的段地址%rip+.LC1并传递给%rdi。 类型转换 程序中涉及隐式类型转换的是：intsleepsecs=2.5，将浮点数类型的2.5转换为int类型。 当在double或float向int进行类型转换的时候，程序改变数值和位模式的原则是：值会向零舍入。如果不能为该浮点数找到一个合适的整数近似值，就会产生一个整数不确定值。 浮点数默认类型为double，所以上述强制转化是double强制转化为int类型。遵从向零舍入的原则，将2.5舍入为2。 控制转移编译器将if，for等控制转移语句都使用了cmp来比较然后使用了条件跳转指令来跳转。编译器将if(argc!=3)编译成： 将for循环里面的比较和转移编译成： 函数操作printf(“Usage:Hello学号姓名！\n”)；编译结果 printf(“Hello%s%s\n”,argv[1],argv[2])；编译结果：图3.10printf(“Hello%s%s\n”,argv[1],argv[2])；汇编代码 sleep(sleepsecs);编译结果： 3.4本章小结 在编译阶段，编译器将高级语言编译成汇编语言。汇编语言是直接面向处理器的程序设计语言。处理器是在指令的控制下工作的，处理器可以识别的每一条指令称为机器指令。每一种处理器都有自己可以识别的一整套指令，称为指令集。处理器执行指令时，根据不同的指令采取不同的动作，完成不同的功能，既可以改变自己内部的工作状态，也能控制其它外围电路的工作状态。 汇编语言的另一个特点就是它所操作的对象不是具体的数据,而是寄存器或者存储器，也就是说它是直接和寄存器和存储器打交道，这也是为什么汇编语言的执行速度要比其它语言快，但同时这也使编程更加复杂，因为既然数据是存放在寄存器或存储器中，那么必然就存在着寻址方式，也就是用什么方法找到所需要的数据。例如上面的例子，我们就不能像高级语言一样直接使用数据，而是先要从相应的寄存器中把数据取出。这也就增加了编程的复杂性，因为在高级语言中寻址这部分工作是由编译系统来完成的，而在汇编语言中是由程序员自己来完成的，这无异增加了编程的复杂程度和程序的可读性。 然后，汇编语言指令是机器指令的一种符号表示，而不同类型的CPU有不同的机器指令系统，也就有不同的汇编语言,所以，汇编语言程序与机器有着密切的关系。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 驱动程序运行汇编器as，将汇编语言（这里是hello.s）翻译成机器语言（hello.o）的过程称为汇编，同时这个机器语言文件也是可重定位目标文件。 汇编就是将高级语言转化为机器可直接识别执行的代码文件的过程，汇编器将.s汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码。 4.2在Ubuntu下汇编的命令 gcchello.s-c-ohello.o4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 ELFHeader:用命令：readelf-hhello.o，如图4.3.1ELFHeader ELFHeader：以16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解##标题释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表的文件偏移，以及节头部表中条目的大小和数量等信息。 (2)SectionHeaders:命令：readelf-Shello.o SectionHeaders:节头部表，包含了文件中出现的各个节的语义，包括节的类型、位置和大小等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小，同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。 符号表.symtab：命令readelf-shello.o如图4.3.4 .symtab：存放程序中定义和引用的函数和全局变量的信息。name是符号名称，对于可冲定位目标模块，value是符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址。size是目标的大小，type要么是数据要么是函数。Bind字段表明符号是本地的还是全局的。 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 通过反汇编的代码和hello.s进行比较，发现汇编语言的指令并没有什么不同的地方，只是反汇编代码所显示的不仅仅是汇编代码，还有机器代码，机器语是二进制机器指令的集合，是纯粹的二进制数据表示的语言，是电脑可以真正识别的语言。机器指令由操作码和操作数构成，汇编语言是人们比较熟悉的词句直接表述CPU动作形成的语言，是最接近CPU运行原理的语言。每一条汇编语言操作码都可以用机器二进制数据来表示，进而可以将所有的汇编语言(操作码和操作数）和二进制机器语言建立一一映射的关系，因此可以将汇编语言转化为机器语言，通过对机器代码的分析可以看出一下不同的地方。 (1)分支转移:反汇编的跳转指令用的不是段名称比如.L3，二是用的确定的地址，因为，因为段名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后显然不存在，而是确定的地址。 (2)函数调用:在.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0(目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。 4.5本章小结 本章对汇编结果进行了详尽的介绍。经过汇编器的操作，汇编语言转化为机器语言，hello.o可重定位目标文件的生成为后面的链接做了准备。通过对比hello.s和hello.o反汇编代码的区别，令人更深刻地理解了汇编语言到机器语言实现地转变，和这过程中为链接做出的准备，对可重定位目标elf格式进行了详细的分析，侧重点在重定位项目上。同时对hello.o文件进行反汇编，将Disas_hello.s与之前生成的hello.s文件进行了对比。使得我们对该内容有了更加深入地理解。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接器概念： 链接是将各种不同文件的代码和数据部分收集（符号解析和重定位）起来并组合成一个单一文件的过程。 链接器作用： 令源程序节省空间而未编入的常用函数文件（如printf.o）进行合并，生成可以正常工作的可执行文件。这令分离编译成为可能，节省了大量的工作。 5.2在Ubuntu下链接的命令 ldhello.o-lc-ohello.out或gcchello.o-ohello.out 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 可见包含一个elf头表，29个节头，1个程序头，2个重定位节，2个符号表等，相比之前多了很多内容。图中含有地址，大小等信息 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 虚拟地址从0x00400000开始，到0x004001000 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 分析hello与hello.o的不同： 1.链接增加新的函数： 在hello中链接加入了在hello.c中用到的库函数，如exit、printf、sleep、getchar等函数。 2.增加的节： hello中增加了.init和.plt节，和一些节中定义的函数。 3.函数调用： hello中无hello.o中的重定位条目，并且跳转和函数调用的地址在hello中都变成了虚拟内存地址。对于hello.o的反汇编代码，函数只有在链接之后才能确定运行执行的地址，因此在.rela.text节中为其添加了重定位条目。 4.地址访问： hello.o中的相对偏移地址变成了hello中的虚拟内存地址。而hello.o文件中对于某些地址的定位是不明确的，其地址也是在运行时确定的，因此访问也需要重定位，在汇编成机器语言时，将操作数全部置为0，并且添加重定位条目。 链接的过程： 根据hello和hello.o的不同，分析出链接的过程为： 链接就是链接器（ld）将各个目标文件（各种.o文件）组装在一起，文件中的各个函数段按照一定规则累积在一起。 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 5.6hello的执行流程 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。 在调用共享库函数时，编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。GNU编译系统使用延迟绑定(lazybinding),将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定是通过GOT和PLT实现的。GOT是数据段的一部分，而PLT是代码段的一部分。两表内容分别为： PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 5.8本章小结 在本章中主要介绍了链接的概念与作用，并且详细阐述了hello.o是怎么链接成为一个可执行目标文件的过程，详细介绍了hello.o的ELF格式和各个节的含义，并且分析了hello的虚拟地址空间、重定位过程、执行流程、动态链接过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中的程序的实例，每一个进程都有它自己的地址空间，一般情况下，包括文本区域、数据区域、和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储区着活动过程调用的指令和本地变量。 作用：进程为用户提供了以下假象： (1)我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存。 (2)处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 Linux系统中，Shell是一个交互型应用级程序，代表用户运行其他程序(是命令行解释器，以用户态方式运行的终端进程)。 其基本功能是解释并运行用户的指令，重复如下处理过程： (1)终端进程读取用户由键盘输入的命令行。 (2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量 (3)检查第一个(首个、第0个）命令行参数是否是一个内置的shell命令 (4)如果不是内部命令，调用fork()创建新进程/子进程 (5)在子进程中，用步骤2获取的参数，调用execve()执行指定程序。 (6)如果用户没要求后台运行(命令末尾没有&号）否则shell使用waitpid（或wait…等待作业终止后返回。 (7)如果用户要求后台运行(如果命令末尾有&号），则shell返回； 6.3Hello的fork进程创建过程 终端程序通过调用fork()函数创建一个子进程，子进程得到与父进程完全相同但是独立的一个副本，包括代码段、段、数据段、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，父进程和子进程最大的不同时他们的PID是不同的。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。 以我们的hello为例，当我们输入的时候，首先shell对我们输入的命令进行解析，由于我们输入的命令不是一个内置的shell命令，因此shell会调用fork()创建一个子进程。 6.4Hello的execve过程 当创建了一个子进程之后，子进程调用exceve函数在当前子进程的上下文加载并运行一个新的程序即hello程序，加载并运行需要以下几个步骤： (1)删除已存在的用户区域。删除当前进程虚拟地址的用户部分中已存在的区域结构。 (2)映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些区域结构都是私有的，写时复制的。虚拟地址空间的代码和数据区域被映射为hello文件的.txt和.data区。bss区域是请求二进制零的，映射匿名文件，其大小包含在hello文件中。栈和堆区域也是请求二进制零的，初始长度为零。 (3)映射共享区域。如果hello程序与共享对象链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域。 (4)设置程序计数器（PC）。exceve做的最后一件事就是设置当前进程的上下文中的程序计数器，使之指向代码区域的入口点。下一次调用这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 6.5Hello的进程执行 进程提供给应用程序的抽象： (1)一个独立的逻辑控制流，它提供一个假象，好像我们的进程独占的使用处理器 (2)一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用CPU内存。 hello进程的执行是依赖于进程所提供的抽象的基础上，下面阐述操作系统所提供的的进程抽象： ①逻辑控制流:：一系列程序计数器PC的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。 ②并发流：一个逻辑流的执行时间与另一个流重叠，成为并发流，这两个流成为并发的运行。多个流并发的执行的一般现象成为并发。 ③时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 ④私有地址空间：进程为每个流都提供一种假象，好像它是独占的使用系统地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，在这个意义上，这个地址空间是私有的。 ⑤用户模式和内核模式：：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 ⑥上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 ⑦上下文切换：当内核选择一个新的进程运行时，则内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程： 1）保存以前进程的上下文 2）恢复新恢复进程被保存的上下文， 3）将控制传递给这个新恢复的进程，来完成上下文切换。 现在我们再来看一下hello进程执行，再进程调用execve函数之后，由上面分析可知，进程已经为hello程序分配了新的虚拟的地址空间，并且已经将hello的.txt和.data节分配虚拟地址空间的代码区和数据区。最初hello运行在用户模式下输出，然后hello调用sleep函数之后进程陷入内核模式，内核不会选择什么都不做等待sleep函数调用结束，而是处理休眠请求主动释放当前进程，并将hello进程从运行队列中移出加入等待队列，定时器开始计时，内核进行上下文切换将当前进程的控制权交给其他进程，当定时器到时发送一个中断信号，此时进入内核状态执行中断处理，将hello进程从等待队列中移出重新加入到运行队列，成为就绪状态，hello进程就可以继续进行自己的控制逻辑流了。 6.6hello的异常与信号处理 hello程序出现的异常可能有： 中断：在hello程序执行的过程中可能会出现外部I/O设备引起的异常。 陷阱：陷阱是有意的异常，是执行一条指令的结果，hello执行sleep函数的时候会出现这个异常。 故障：在执行hello程序的时候，可能会发生缺页故障。 终止：终止时不可恢复的错误，在hello执行过程可能会出现DRAM或者SRAM位损坏的奇偶错误。 在发生异常时会发出信号，比如缺页故障会导致OS发生SIGSEGV信号给用户进程，而用户进程以段错误退出。常见信号种类如下表所示。 6.7本章小结 本章阐明了进程的定义与作用，介绍了Shell的一般处理流程，以及调用fork创建新进程，调用execve执行hello，hello的进程执行的过程，还有系统对于异常与信号的处理。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：程序经过编译后出现在汇编代码中的地址。逻辑地址用来指定一个操作数或者是一条指令的地址。是由一个段标识符加上一个指定段内相对地址的偏移量，表示为[段标识符：段内偏移量]。 线性地址：也叫虚拟地址，和逻辑地址类似，也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件也是内存的转换前地址。 虚拟地址：也就是线性地址。 物理地址：用于内存芯片级的单元寻址，与处理器和CPU链接的地址总线相对应。可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部份组成，段标识符:段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，表示具体的是代码段寄存器还是栈段寄存器抑或是数据段寄存器，如图7.2.1所示。 索引号就是“段描述符(segmentdescriptor)”的索引，段描述符具体地址描述了一个段。很多个段描述符，就组了一个数组，叫“段描述符表”，这样，可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符，这句话很关键，说明段标识符的具体作用，每一个段描述符由8个字节组成，如图7.3.2所示 Base字段，表示的是包含段的首字节的线性地址，也就是一个段的开始位置的线性地址。一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。那究竟什么时候该用GDT，什么时候该用LDT呢？这是由段选择符中的T1字段表示的，=0，表示用GDT，=1表示用LDT，GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。 7.3Hello的线性地址到物理地址的变换-页式管理 由课本知识点可知，线性地址（也就是虚拟地址VA）到物理地址（PA）之间的转换通过分页机制完成。而分页机制是对虚拟地址内存空间进行分页。 这里我们不考虑TLB和多级页表，这将在下面探讨。 使用虚拟寻址，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址被送到内存之前首先转换为适当的物理地址。将一个虚拟地址转换为物理地址叫做地址翻译，需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做内存管理单元(MMU)的住哪用硬件，利用主存中的查询表来动态翻译虚拟地址。 虚拟地址作为到磁盘上存放字节的数组的索引，磁盘上的数组内容被缓存在主存中。同时，磁盘上的数据被分割成块，这些块作为磁盘和主存之间的传送单元。虚拟内存分割被成为虚拟页。物理内存被分割为物理页，物理页和虚拟页的大小时相同的。 任意时刻虚拟页都被分为三个不相交的子集： 未分配的：VM系统还未分配的页 缓存的：当前已经缓存在物理内存的已分配页 未缓存的：当前未缓存在物理内存的已分配页 每次将虚拟地址转换为物理地址，都会查询页表来判断一个虚拟页是否缓存在DRAM的某个地方，如果不在DRAM的某个地方，通过查询页表条目可以知道虚拟页在磁盘的位置。页表将虚拟页映射到物理页。如图7.3.1所示，页表就是一个页表条目的数组，每一个页表条目是由一个有效位和一个n为地址字段组成。有效位表明虚拟页是否缓存在DRAM中，n位地址字段是物理页的起始地址或者虚拟页在次胖的起始地址。 7.4TLB与四级页表支持下的VA到PA的变换 在IntelCorei7环境下研究VA到PA的地址翻译问题。前提如下：虚拟地址空间48位，物理地址空间52位，页表大小4KB，4级页表。TLB4路16组相联。CR3指向第一级页表的起始位置（上下文一部分）。解析前提条件：由一个页表大小4KB，一个PTE条目8B，共512个条目，使用9位二进制索引，一共4个页表共使用36位二进制索引，所以VPN共36位，因为VA48位，所以VPO12位；因为TLB共16组，所以TLBI需4位，因为VPN36位，所以TLBT32位。 CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（前32位）+TLBI（后4位）向TLB中匹配，如果命中，则得到PPN（40bit）与VPO（12bit）组合成PA（52bit）。如果TLB中没有命中，MMU向页表中查询，CR3确定第一级页表的起始地址，VPN1（9bit）确定在第一级页表中的偏移量，查询出PTE，如果在物理内存中且权限符合，确定第二级页表的起始地址，以此类推，最终在第四级页表中查询到PPN，与VPO组合成PA，并且向TLB中添加条目。如果查询PTE的时候发现不在物理内存中，则引发缺页故障。如果发现权限不够，则引发段错误。 7.5三级Cache支持下的物理内存访问 我们只讨论Cashe1的物理内存访问，Cashe2，Cashe3原理相同。 由于L1Cashe有64组，所以组索引位s为6，每组有8个高速缓存行，由于每个块的大小为64B，所以块偏移为为6，因此标记位为52-6-6=40位。 因此L1Cashe的物理访存大致过程如下： (1)组选择取出虚拟地址的组索引位，将二进制组索引转化为一个无符号整数，找到相应的组 (2)行匹配把虚拟地址的标记为拿去和相应的组中所有行的标记位进行比较，当虚拟地址的标记位和高速缓存行的标记位匹配时，而且高速缓存行的有效位是1，则高速缓存命中。 (3)字选择一旦高速缓存命中，我们就知道我们要找的字节在这个块的某个地方。因此块偏移位提供了第一个字节的偏移。把这个字节的内容取出返回给CPU即可 (4)不命中如果高速缓存不命中，那么需要从存储层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位所指示的组中的一个高速缓存行中。一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换。 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1)删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2）映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3)映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 4）设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障：当指令引用一个相应的虚拟地址，而与改地址相应的物理页面不再内存中，会触发缺页故障。通过查询页表PTE可以知道虚拟页在磁盘的位置。缺页处理程序从指定的位置加载页面到物理内存中，并更新PTE。然后控制返回给引起缺页故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，因此指令可以没有故障的运行完成。 7.9动态存储分配管理 动态储存分配管理使用动态内存分配器来进行。动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配的状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。动态内存分配主要有两种基本方法与策略： 带边界标签的隐式空闲链表分配器管理 带边界标记的隐式空闲链表的每个块是由一个字的头部、有效载荷、可能的额外填充以及一个字的尾部组成的。 隐式空闲链表：在隐式空闲链表中，因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。其中，一个设置了已分配的位而大小为零的终止头部将作为特殊标记的结束块。 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大的可以放置所请求块的空闲块。分配器有三种放置策略：首次适配、下一次适配合最佳适配。分配完后可以分割空闲块减少内部碎片。同时分配器在面对释放一个已分配块时，可以合并空闲块，其中便利用隐式空闲链表的边界标记来进行合并。 显示空间链表管理 显式空闲链表是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。如，堆可以组织成一个双向链表，在每个空闲块中，都包含一个前驱与一个后继指针。 显式空闲链表：在显式空闲链表中。可以采用后进先出的顺序维护链表，将最新释放的块放置在链表的开始处，也可以采用按照地址顺序来维护链表，其中链表中每个块的地址都小于它的后继地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。 7.10本章小结 本章主要介绍了hello的存储器地址空间、intel的段式管理、hello的页式管理，在指定环境下介绍了VA到PA的变换、物理内存访问，还介绍hello进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化 文件（所有的I/O设备都被模型化为文件，甚至内核也被映射为文件） 设备管理 unixio接口 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。 我们可以对文件的操作有：打开关闭操作open和close；读写操作read和write；改变当前文件位置lseek等 8.2简述UnixIO接口及其函数 打开文件：内核返回一个非负整数的文件描述符，通过对此文件描述符对文件进行所有操作。 Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（文件描述符0）、标准输出（描述符为1），标准出错（描述符为2）。头文件定义了常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，他们可用来代替显式的描述符值。 改变当前的文件位置，文件开始位置为文件偏移量，应用程序通过seek操作，可设置文件的当前位置为k。 读写文件，读操作：从文件复制n个字节到内存，从当前文件位置k开始，然后将k增加到k+n；写操作：从内存复制n个字节到文件，当前文件位置为k，然后更新k 关闭文件：当应用完成对文件的访问后，通知内核关闭这个文件。内核会释放文件打开时创建的数据结构，将描述符恢复到描述符池中 8.3printf的实现分析 其中调用的vsprintf函数的作用是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。Write则将vsprintf的输出逐个的写到终端。 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 以下格式自行编排，编辑时删除） 异getchar有一个int型的返回值.当程序调用getchar时.程序就等着用户按键.用户输入的字符被存放在键盘缓冲区中.直到用户按回车为止(回车字符也放在缓冲区中).当用户键入回车之后,getchar才开始从stdin流中每次读入一个字符.getchar函数的返回值是用户输入的第一个字符的ASCII码,如出错返回-1,且将用户输入的字符回显到屏幕.如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取.也就是说,后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 表述了UnixIO接口及其4个函数，简单了解了一下printf，getchar的实现 （第8章1分） 结论 用hello所经历的过程总结如下： 1、编写代码：用高级语言写.c文件 2、预处理：从.c生成.i文件，将.c中调用的外部库展开合并到.i中 3、编译：由.i生成.s汇编文件 4、汇编：将.s文件翻译为机器语言指令，并打包成可重定位目标程序hello.o 5、链接：将.o可重定位目标文件和动态链接库链接成可执行目标程序hello 6、运行：在shell中输入命令 7、创建子进程：shell嗲用fork为程序创建子进程 8、加载：shell调用execve函数,将hello程序加载到该子进程，映射虚拟内存 9、执行指令：CPU为进程分配时间片，加载器将计数器预置在程序入口点，则hello可以顺序执行自己的逻辑控制流 10、访问内存：MMU将虚拟内存地址映射成物理内存地址，CPU通过其来访问 11、动态内存分配：根据需要申请动态内存 12、信号：shell的信号处理函数可以接受程序的异常和用户的请求 13、终止：执行完成后父进程回收子进程，内核删除为该进程创建的数据结构 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1][美]大卫R.奥哈拉伦，兰德尔·E.布莱恩特.深入理解计算机系统[M].龚奕利，贺莲译.北京：机械工业出版社,2016.7. [2]博客园.printf函数的深入剖析.http://www.cnblogs.com/pianist/p/3315801.html,2013-9-11. [3]程序头表. https://blog.csdn.net/ylcangel/article/details/18145155 [4]C语言文件的编译与执行的四个阶段并分别描述.https://blog.csdn.net/yimingsilence/article/details/52800987 [5]C语言中的预处理详解. https://blog.csdn.net/dlutbrucezhang/article/details/8753765 （参考文献0分，缺失-1分） 
第351篇文章[]
ArrayListLinkList效率对比 由于老师上课的时候讲到了ArrayListLinkList效率不同，于是课下查找资料，并写了一个二者效率对比的小代码。 首先通过查找资料我了解到：1.LinkedList和ArrayList的差别主要来自于Array和LinkedList数据结构的不同。ArrayList是基于数组实现的，LinkedList是基于双链表实现的。另外LinkedList类不仅是List接口的实现类，可以根据索引来随机访问集合中的元素，除此之外，LinkedList还实现了Deque接口，它代表一个双向队列，因此LinkedList可以作为双向队列，栈和List集合使用。 2.因为Array是基于索引的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。 3.相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引。 4.LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。 首先我们测试ArrayListLinkList增加新的内容时效率上的区别。代码如下： 测试结果为： 可以看出array比link快。可能是因为在不修改指针的时候，在往数据末尾新增的时候速度还是比LinkList速度快。 然后测试插入操作： 结果为： 可以看出link确实比array快很多，因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。 
第352篇文章[]
软件构造lab2回顾 前言 临近期末考试，开始对知识点进行整理，对课程布置的实验进行回顾。经过反复对比，感觉还是动手实验对知识获取的帮助最大，逐步解决问题的过程让自己对课上知识的理解更深入了一些。Lab2这一部分的的主要内容是ADT和OOP，实验目的也是抽象数据型的实现，以及面向对象编程。以下是对Lab2这一实验过程中遇到的一些事物做的简单回顾，课程中涉及到的其他重要知识点将在以后慢慢总结。 内容 一.实验目标概述 本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说： 针对给定的应用问题，从问题描述中识别所需的ADT； 设计ADT规约（pre-condition、post-condition）并评估规约的质量； 根据ADT的规约设计测试用例； ADT的泛型化； 根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction） 使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure）； 测试ADT的实现并评估测试的覆盖度； 使用ADT及其实现，为应用问题开发程序； 在测试代码中，能够写出testingstrategy并据此设计测试用例。 二.涉及到的一些知识 （一）代码覆盖度测试 实验中主要采用Eclemma对测试用例的覆盖度进行测试，在eclipse上的使用方式如下： 1.准备好要测试的代码和测试用例； 2.右键项目->选择CoverageAs->JavaApplication，便可以完成覆盖度测试。显示结果将给出各测试用例的覆盖度，如图所示： 打开被测试的类，其中代码背景颜色被涂成红色的部分即为未覆盖的部分，注意对项目进行覆盖度测试时，只有当被测试的代码覆盖完整时，才会显示绿色，因此未被测试的类中的代码也会一并标记为红色。 （二）对象的存储--对象容器 用来盛装对象的工具，其特点不只在于能够对某一类对象进行存储，而且Java对每一种容器本身也提供了不少相应的方法，使得对象容器使用起来将要简单很多。 1.对象列表 示例如下： ArrayList<String>l=newArrayList<String>() 对象列表ArrayList是一个有顺序的列表，其下标索引从0开始。对象在该列表中的存储是有序的，因此与集合Set不同，我们可以通过下标对ArrayList中的元素进行访问。它的优点在于随机访问元素快，但是在中间插入和移除比较慢。 实验中用到的除了基本的size等方法，以下几种方法让我印象较为深刻： add(intindex,Objectelement)：在列表的指定位置插入指定元素。 set(inti,Objectelement)：将索引i位置元素替换为元素element并返回被替换的元素。 个人认为，对象列表和C语言中的数组类似，既可以直接操作、寻找对象，也可以通过下标进行操作，但其元素的个数不固定，长度可变，操作时更加灵活。 2.集合容器 示例如下： Set<String>set=newHashSet<String>(); Set和数学中集合的概念类似，元素具有唯一性和无序性。所以Set最常用的就是测试归属性，很容易的询问出某个对象是否存在Set中。而若是要获得确定元素顺序的集合，可以用treeset来进行存储。 Set具有和Collection完全一样的接口，继承相应的方法但没有额外的功能，只是表现的行为不同。 3.哈希表 示例如下： Map<String,Integer>m=newHashMap<String,Integer>(); Map接口就像图表，关键字与关键字的值具有对应关系。类似于日常使用的字典，它根据键的hashCode值存储数据，也就是键-值对的方式存储，因此大多数情况下可以通过键名直接定位到它的值。Map具有很快的访问速度，但其遍历顺序却是不确定的。注意HashMap最多只允许一条记录的键为null，允许多条记录的值为null。 HashMap很特别的特点就是，我们可以根据关键字和关键字的值分别对表中的对象进行寻找、修改等操作。 （三）遍历访问容器中的对象--迭代器 JavaIterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代ArrayList和HashSet等集合。它是Java迭代器最简单的实现，ListIterator是CollectionAPI中的接口，它扩展了Iterator接口。 迭代器的使用使不可变数据型对象容器的遍历等操作变得更加方便，比如删除操作。 迭代器的两个基本操作是next、hasNext和remove：方法it.next()会返回迭代器的下一个元素，并且更新迭代器的状态；方法hasNext()会返回布尔值，用于检测集合中是否还有元素；而方法remove()的用途则是将迭代器返回的元素删除。 以下是写实验时设计的一个使用迭代器实现的方法： @Overridepublicbooleanremove(Lvertex){ Iterator<Vertex<L>>V=vertices.iterator(); while(V.hasNext()){ Vertex<L>v=V.next(); if(v.Getname().equals(vertex)){//removethevertexitself V.remove(); checkRep(); returntrue; } else{ if(v.Getsources().containsKey(vertex)){//removethevertexfromrelatedmaps(assource) v.removesource(vertex); } if(v.Gettargets().containsKey(vertex)){//removethevertexfromrelatedmaps(astarget) v.removetarget(vertex); } } } checkRep(); returnfalse; } 总结 实验2中还有很多较为核心的内容没有列出，文章只给出了一些Java语法及测试的使用方法，一些其他重要的内容将在以后总结。 
第353篇文章[1]
哈尔滨工业大学计算机系统大作业 摘 要 本实验主要对hello这一c程序的整个生命周期展开研究。我们从hello.c源程序为起点，从预处理、编译、汇编、链接，到加载、运行，再到终止、回收逐一进行分析综合，并结合对《深入理解计算机系统》一书的内容及计算机系统课上老师的讲授，在Ubuntu系统下对hello程序展开编译、链接、调试、运行等实际操作，顺着hello.c文件在计算机中执行的生命周期，在整个计算机系统中漫游，并把计算机系统的体系整体串联在一起 关键词：Linux；hello程序；生命周期；计算机系统； 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 P2P：首先hello.c利用I/O设备通过总线存储进内存中。GCC编译器驱动然后读取源程序文件hello.c，通过预处理器cpp转化为hello.i，再利用编译器ccl读入hello.s（汇编语言），然后用as将其汇编，转化为机器友好的二进制代码并保存在hello.o中。最后，它通过链接器ld与标准C库动态链接，并最终成为hello可执行目标程序。 接下来是在shell中输入字符串“./hello”。shell程序将字符串读入寄存器并解析。然后shell调用fork函数来创建一个新的子进程。子进程是父进程shell的副本，再通过execve函数调用启动加载器。加载程序删除子进程现有的虚拟内存段，然后使用mmap函数创建新的内存区域，创建一组新的代码、数据、堆栈段。新的堆栈段被初始化为零。通过将虚拟地址空间中的页面映射到可执行文件的页面大小块，新的代码和数据段被赋值为可执行文件的对应内容。最后，加载器跳转到_start的地址运行应用main函数。 O2O：shell使用execve函数运行hello程序，映射虚拟内存，并从程序入口开始载入物理内存，再进入main函数执行目标代码，此时CPU为运行的hello分配时间片执行逻辑控制流，并通过流水线机制运行该程序，在此过程中，计算机通过TLB、4级页表、3级Cache，Pagefile等机制加速hello程序的运行，程序结束后，shell父进程负责回收hello进程，内核删除相关的数据结构。 1.2环境与工具 硬件环境：CPU：IntelCorei7-9300H2.40GHz；RAM：16GB 软件环境：Windows1064位；Ubuntu16.04.2LTS 开发与调试工具：objdump，gcc，as，ld，edb，readelf，VScode 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 文件名文件的作用hello.i预处理之后的文件hello.s编译之后的文件hello.o汇编之后的文件hello链接之后的文件hello_elfhello.o的elf格式hellold_elfhello的elf格式（链接之后）hello_objdumphello.o的反汇编代码hello_objdump0hello的反汇编代码（链接之后） 1.4本章小结 本章主要简单介绍了hello的P2P，020过程，列出了本次实验的环境、中间结果。也列出了该篇论文完成所需要生成的一些中间文件，为后续实验提供了基本思路。第一章简单解释了P2P和020的概念，说明了本次大作业的环境和工具，列出了为编写本论文，生成的中间结果文件并解释了其作用。 第2章预处理 2.1预处理的概念与作用 预处理的概念：预处理器（cpp）是根据以字符#开头的命令，修改原始的C程序：是指在进行编译的第一遍扫描之前所做的工作。该过程由预处理程序负责完成。当对一个c源文件进行预处理时，系统自动引用预处理程序以解析以字符#开头的预处理命令，比如#include<stdio.h>等命令来修改原始的C程序，待预处理进行完毕之后自动进入对源程序的编译。 预处理的主要作用如下： 1．删除宏定义“#define”展开并解析所定义的宏。 2．处理所有条件预编译指令，如“#if”,“#ifdef”,“#endif”等。 3．插入include后面的文件到“#include”处。 4．删除所有的注释“//”和“/**/”。 2.2在Ubuntu下预处理的命令 命令内容：>cpphello.chello.i 2.3Hello的预处理结果解析 观察hello.i文件可以发现，文件main函数之前的内容变多，main函数C语言程序文本文件，只是对原文件中的宏进行了宏展开，头文件中的内容被加入此文件中。如果代码中有#define命令还会替换程序中对相应的符号。 该文件扩展到了3061行之多，且原本的C代码被放置在了整个文件的末尾。 2.4本章小结 本章介绍了linux环境下对C语言程序进行预处理的命令，同时简要介绍了预处理的概念和作用，然后用简单的hello程序实际演示了从hello.c到hello.i的过程并结合具体代码对预处理结果进行了简单的分析。 第3章编译 3.1编译的概念与作用 编译的概念：编译是利用编译器从hello.i产生汇编文本文件hello.s的过程。主要包含五个阶段：词法分析、语法分析、语义检查、中间代码生成、目标代码生成。 编译的作用：将文本文件hello.i翻译成文本文件hello.s，并提示出现的语法错误。 3.2在Ubuntu下编译的命令 命令内容：>gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 3.3.1数据 局部变量：作为函数中的局部变量i被储存在栈中，栈地址：%rbp-4 argc：传入的参数，存在栈里，位于%rbp-20。 argv[]：传入的数组，存在栈里，argv的地址位于%rbp-32，利用argv的地址加i*8，就能得到argv[i]。 立即数：储存在.data段中，在运行需要时加入寄存器中，如果无空闲寄存器则放入栈中。 表达式：存在代码段的.rodata中 3.3.2赋值 为栈上的局部变量i赋初值=0，用movl赋值。 movl $0,-4(%rbp) 3.3.3类型转换 atoi函数将字符型argv[3]转换为整型数。 3.3.4算术操作 编译器将i++编译成 addl$1,-4(%rbp) 3.3.5关系操作 编译器将i<8与跳转编译成 cmpl$7,-4(%rbp) jle.L4 将argc!=4编译成 cmpl$4,-20(%rbp) je.L2 3.3.6数组/指针/结构操作 argv数组是传入的参数，储存在栈上。 初始地址位于%rbp-32，利用argv的地址加i*8，就能得到argv[i] 3.3.7控制转移 编译器将if，for等控制转移语句都使用了cmp来比较然后使用了条件跳转指令来跳转。编译器将if(argc!=3)编译成： cmpl$3,-20(%rbp) je.L2 将for循环里面的比较和转移编译成： cmpl$9,-4(%rbp) jle.L4 3.3.8函数操作 编译器将printf("用法:Hello学号姓名秒数！\n");编译为： 将printf("Hello%s%s\n",argv[1],argv[2]);编译为: 将sleep(atoi(argv[3]));编译为： 3.4本章小结 本章介绍了linux环境下对C语言程序进行预处理之后的文件进行编译的命令，同时简要介绍了编译的概念和作用，然后用简单的hello程序实际演示了从hello.i到hello.s的过程并结合具体代码对编译结果进行了简单的分析，通过源程序与汇编语言程序的对比，简要说明了编译器是怎么处理C语言的各个数据类型以及各类操作的，分数据，赋值，算数操作，关系操作，数组，控制转移，函数操作等方面按照类型和操作进行了分析。 第4章汇编 4.1汇编的概念与作用 汇编的概念：汇编器（as）将.s汇编程序翻译成机器语言，把这些机器语言指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中。这个过程就叫做汇编。 汇编的作用：将汇编语言翻译成机器语言，因为机器语言是计算机能直接识别和执行的一种语言。 4.2在Ubuntu下汇编的命令 命令内容：>gcc-chello.s-ohello.o 4.3可重定位目标elf格式 命令：readelf-ahello.o>hello.elf 4.3.1ELF头 描述了生成该文件的系统的字大小、字节顺序（大/小）、ELF头的大小、目标文件的类型、机器类型（如x86-64）、节头部表的偏移、节头部表中条目的大小和数量。 4.3.2节头部表 节头部表描述了不同节的偏移量和大小，其中目标文件中每个节都有一个固定大小的条目。具体的描述包括节的名称、类型、地址和偏移量等。 4.3.3重定位节 表述了各个段引用的外部符号等，在链接时，需要通过重定位节对这些位置的地址进行修改。链接器会通过重定位条目的类型判断该使用什么养的方法计算正确的地址值，通过偏移量等信息计算出正确的地址。 4.3.4符号表 存放在程序中定义和引用的函数和全局变量的信息。 4.4Hello.o的结果解析 命令内容：>objdump-d-rhello.o 与第三章对比可发现以下不同： 1.操作数进制表示： 可以看出，hello.s文件采用10进制，而反汇编的采用16进制。 2.函数调用 可以看出，hello.s中的函数调用是call函数名，而反汇编得到的是call相对地址，因为反汇编的代码已经经过了链接与重定位，知道了相对位置。 3.跳转分支 可以看出，hello.s文件的分支跳转是通过跳转到类似于.L2的形式来表示，而反汇编的代码使用跳转到某个相对位置来表示。 4.5本章小结 本章介绍了hello从hello.s到hello.o的汇编过程，分析了可重定位文件的结构和各个组成部分，以及它们的内容和功能；还查看了hello.o的elf格式，并使用objdump得到反汇编代码与hello.s进行比较，了解从汇编语言映射到机器语言汇编器需要实现的转换。在这个过程中，生成了重定位条目，为之后的链接中的重定位过程奠定了基础。 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。 链接的作用：链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。 5.2在Ubuntu下链接的命令 命令内容： >ld-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.o/usr/lib/gcc/x86_64-linux-gnu/9/crtbegin.o /usr/lib/gcc/x86_64-linux-gnu/9/crtend.o/usr/lib/x86_64-linux-gnu/crtn.o hello.o -lc -zrelro-ohello 5.3可执行目标文件hello的格式 5.3.1ELF头 ELF头描述文件的总体格式。包括程程序运行时要执行的第一条指令的地址。程序头部大小和数目也确定了下来。其余的部分基本与可重定位目标文件相同。 5.3.2节头 节头对hello中所有的节信息进行了声明，对于节的分类也更加详细，也确定了每个节在运行时的实际起始地址以及偏移量。其余部分都与可重定位目标文件的节头相同。 5.3.3程序头 程序头一共有8个段： （1）PHDR：包含程序头表本身； （2）INTERP：只包含了一个节，在这个节中，包含了动态链接过程中所使用的解释器路径和名称。 （3）两个LOAD段：第一个是代码段，第二个是数据段。在程序运行时需要映射到虚拟空间地址。 （4）DYNAMIC：保存了由动态链接器使用的信息。 （5）NOTE：保存了辅助信息。 （6）GNU_STACK：堆栈段。 （7）GNU_RELRO：在重定位之后哪些内存区域需要设置只读。 5.3.4重定位节 文件的重定位节已经完成重定位，符号表中的符号的信息都被记录在这里。 5.4hello的虚拟地址空间 使用edb加载hello，可以查看加载到虚拟地址中的hello程序。查看ELF格式文件中的ProgramHeaders，它告诉链接器运行时加载的内容并提供动态链接的信息。每一个表项提供了各段在虚拟地址空间和物理地址空间的各方面的信息。 查看ELF文件的程序头，程序头在为链接器提供运行时的加载内容和提供动态链接的信息，每一个表项提供了各段在虚拟地址空间大小和物理地址空间大小，位置，标志，访问权限和对齐方式。 可以看出，程序头包括8个段，正如5.3中所提到的： PHDR段； INTERP段； 两个LOAD段； DYNAMIC段； NOTE段； GNU_STACK段； GNU_RELRO段。 5.5链接的重定位过程分析 命令内容：>objdump-d-rhello 不同： 跳转：hello.o为相对偏移地址，hello为虚拟内存地址。 Hello含有外部链接得到的函数。 hello相对hello.o增加了部分节（.init,.plt等）。 重定位： 一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义(即其一个输入目标模块中的一个符号表条目)关联起来。此时，链接器就知道其输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成： 重定位节和符号定义：在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。 当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 重定位节中的符号引用：在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目(relocationentry)的数据结构，我们接下来将会描述这种数据结构。 5.6hello的执行流程 hello!_start0x401090 __libc_start_main0x403ff0 main0x4010c1 hello!puts@plt0x401030 hello!exit@plt0x401070 hello!printf@plt0x401040 hello!atoi@plt0x401060 hello!sleep@plt0x401080 hello!getchar@plt0x401050 5.7Hello的动态链接分析 动态链接： 共享库(sharedlibrary)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链楼(dynamiclinking)，是由一个叫做动态链接器(dytamiclinkeg的程序来执行的。共享库也称为共享目标(sharedobject)，在Linux系统中通常用，s0后缀来表示，微软的操作系统大量地使用了共享库，它们称为DLL(动态链接库)。 共享库是以两种不同的方式来“共享”的。首先，在任何给定的文件系统中，对于一个库只有一个.so文件。所有引用该库的可执行目标文件共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。其次，在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。 比如说：GOT：GOT是一个数组，其中元素是8字节的地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时需要用到的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。根据hello的ELF文件可知GOT起始表位置为0x404000。 Dl_init执行前0x404000的16个字节均为0： Dl_init执行后0x404000的16个字节有所改变： 5.8本章小结 第五章中主要介绍了链接的概念与作用，并且详细说明了hello.o是怎么与其他.o(.so)文件链接成为一个可执行目标文件的过程，展示了hello.o的ELF文件形式和各个节的含义，分析了hello的虚拟地址空间、重定位过程与动态链接过程。 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程是一个正在运行的程序的实例。系统中的每个程序都在某个进程的上下文中运行。上下文由程序正确运行所必需的状态组成。这种状态包括存储在内存中的代码和程序数据、堆栈、通用寄存器的内容、程序计数器、环境变量和文件描述符的集合。 进程的功能：进程为应用程序提供了两种抽象，一种是独立的逻辑控制流，一种是私有地址空间。提高CPU执行效率，减少因程序等待造成的CPU空闲和其他计算机软硬件资源的浪费。 6.2简述壳Shell-bash的作用与处理流程 shell是一个应用程序，他在操作系统中提供了一个用户与系统内核进行交互的界面。他的处理过程一般是这样的：首先从终端读入输入的命令，并将输入字符串分割获取参数，如果是内置命令则立即执行，如果不是内置命令则调用对应的程序并运行。Shell还可以接受键盘输入的信号比如ctrlc，并对这些信号进行处理。 6.3Hello的fork进程创建过程 根据shell的处理流程，可以推断，输入命令执行hello后，父进程如果判断不是内部指令，即会通过fork函数创建子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到一份与父进程用户级虚拟空间相同的（但是独立的）副本，包括数据段、代码、共享库、堆和用户栈。父进程打开的文件，子进程也可读写。二者之间最大的不同或许在于PID的不同。fork函数只会被调用一次，但会返回两次，在父进程中，fork返回子进程的PID，在子进程中fork返回0。 6.4Hello的execve过程 当fork之后，子进程调用execve函数在当前进程的上下文中加载并运行一个新程序即hello程序，execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行hello程序，加载器删除子进程现有的用户虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。最后加载器设置PC指向_start地址，_start最终调用hello中的main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，这时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 6.5Hello的进程执行 逻辑控制流：一系列程序计数器PC的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占，然后轮到其他进程。 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 在hello运行过程中，若hello进程不被抢占，则正常执行；若被抢占，则进入内核模式，进行上下文切换，转入用户模式，调度其他进程。 这里有个特殊的情况，当hello执行到sleep()的时候，为了不浪费处理器资源，hello进程会被抢占，直到sleep()返回，触发一个中断，使得hello进程重新被调度。 6.6hello的异常与信号处理 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 Ctrl+Z： 运行时按Ctrl-Z之后，将会发送一个SIGTSTP信号给shell。然后shell将转发给当前执行的前台进程组，使hello进程停止。 再输入ps查看当前进程，截图；输入jobs命令，截图；可见该进程已经停止。再输入pstree，可见这是一个树状图，显示了进程之间的关系。再输入fg（一个继续运行的命令），可以看出，刚才停止的程序继续运行，此时正在等我们输入一个字符。再运行一次这个程序，使用ctrl-z停止后再用kill杀死程序，并截图。 乱按： 程序运行情况正常，shell将乱输入的第一个字符当做getchar的输入，其余都当做新的shell命令，在hello进程结束被回收之后，将会在命令行中尝试解释这些命令。 6.7本章小结 本章简述了进程管理以及shell的一些信息，包括进程的概念与作用，shell的作用和处理流程，shell如何调用fork和execve运行我们的hello进程，以及hello是如何被执行的，当hello进程在执行时遇到特殊情况（比如回车，Ctrl-Z，Ctrl-C等）会如何处理。又介绍了一些常见异常和其信号处理方法。我们可以看出，一个进程的运行与信号密切相关，受到信号的调控。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：程序代码经过编译后出现在汇编程序中地址，逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。 线性地址与虚拟地址：逻辑地址经过段机制后转化为线性地址（虚拟地址）,是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。线性地址通常用十六进制数字表示，程序代码会产生逻辑地址，通过逻辑地址变换就可以生成一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换以产生一个物理地址。如果没有启用分页机制，那么线性地址直接就是物理地址。 物理地址：CPU地址总线传来的地址,由硬件电路控制。物理地址中很大一部分是留给内存条中的内存的，但也常被映射到其他存储器上。在没有使用虚拟存储器的机器上，虚拟地址被直接送到内存总线上，使具有相同地址的物理存储器被读写；而在使用了虚拟存储器的情况下，虚拟地址不是被直接送到内存地址总线上，而是送到存储器管理单元MMU，把虚拟地址映射为物理地址。 在hello程序中，他就表示了这个程序运行时的一条确切的指令在内存地址上的具体哪一块进行执行。 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理是从逻辑地址到线性地址的变换： 一个逻辑地址由两部分组成，段标识符、段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号，后面3位包含一些硬件细节，索引号，是“段描述符”，段描述符具体地址描述了一个段。这样，很多个段描述符，就组了一个数组，叫“段描述符表”，这样，可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符，这个描述符就描述了一个段，由8个字节组成。 给定一个逻辑地址[段选择符：段内偏移地址]，转换过程如下： 1、首先根据段选择符判断当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。这样就得到了一个数组。 2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。 3、Base+offset就是要转换的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 页式管理是从线性地址到物理地址的变换： Linux有一个的虚拟内存系统，其虚拟内存组织形式如下图。Linux将虚拟内存组织成一些区域（称为段）的集合，段之外的虚拟内存不存在因此不需要记录。内核为hello进程维护一个单独的任务结构即图中的task_struct，其中条目mm指向一个mm_struct，它描述了虚拟内存的当前状态，pgd指向第一级页表的基地址（结合一个进程一串页表），mmap指向一个vm_area_struct的链表，每个vm_area_struct都维护者一个区域。 物理内存被划分为一小块一小块的帧。分配内存时，帧是分配时的最小单位，最少也要给一帧。在虚拟内存中，与帧对应的概念就是页。线性地址的表示方式是：前部分是虚拟页号后部分是虚拟页偏移。 CPU通过将逻辑地址转换为虚拟地址来访问主存，这个虚拟地址在访问主存前必须先转换成适当的物理地址。CPU通过内存管理单元（MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址。然后CPU会通过这个物理地址来访问物理内存。 页表就是一个页表条目（PTE）数组，虚拟地址空间中的每个页在页表中的一个固定偏移量处都有一个PTE。PTE是由一个有效位和一个n个字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置。 MMU利用虚拟页号（VPN）来在虚拟页表中选择合适的PTE，当找到合适的PTE之后，PTE中的物理页号（PPN）和虚拟页偏移量（VPO）就会组合形成物理地址。其中VPO与PPO相同，因为虚拟页大小和物理页大小相同，所需要的偏移量位数也就相同。此时，物理地址就通过物理页号先找到对应的物理页，然后再根据物理页偏移找到具体的字节： 1.如果有效位是0，PPN为NULL则代表没有在虚拟内存空间中分配该内存； 2.如果是有效位0，PPN不为NULL，则代表在虚拟内存空间中分配了但是没有被缓存到物理内存中； 3.如果有效位是1则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，与虚拟页偏移量共同构成物理地址PA。 7.4TLB与四级页表支持下的VA到PA的变换 TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。下图展示了当TLB命中时所包括的步骤，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。 第1步:CPU产生一个虚拟地址。 第2步和第3步:MMU从TLB中取出相应的PTE。 第4步:MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。 第5步:高速缓存/主存将所请求的数据字返回给CPU。当TLB不命中时，MMU必须从Ll缓存中取出相应的PTE。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。 Corei7MMU如何使用四级的页表来将虚拟地址翻译成物理地址？36位VPN被划分成四个9位的片，每个片被用作到移个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个LlPET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 7.5三级Cache支持下的物理内存访问 CPU发送一条虚拟地址，随后MMU按照上述操作获得了物理地址PA。根据cache大小组数的要求，将PA分为CT，CS，CO。根据CS寻找到正确的组，比较每一个cacheline是否标记位有效以及CT是否相等。如果命中就直接返回想要的数据，如果不命中，就依次去L2,L3,主存判断是否命中，当命中时，将数据传给CPU同时更新各级cache的cacheline（如果cache已满则要采用换入换出策略）。 7.6hello进程fork时的内存映射 虚拟内存和内存映射解释fork函数如何为每个新进程提供私有的虚拟地址空间，在shell运行hello进程时，shell为hello进程创建虚拟内存创建当前进程的的mm_struct,vm_area_struct和页表的原样副本，两个进程中的每个页面都标记为只读两个进程中的每个区域结构（vm_area_struct）都标记为私有的写时复制（COW）在新进程中返回时，新进程拥有与调用fork进程相同的虚拟内存随后的写操作通过写时复制机制创建新页面。 7.7hello进程execve时的内存映射 shell进程调用execve函数在当前进程中加载并运行新程序hello的步骤： 删除已存在的用户区域，创建新的区域结构私有的、写时复制，代码和初始化数据映射到.text和.data区（目标文件提供），.bss和栈堆映射到匿名文件，栈堆的初始长度0，共享对象由动态链接映射到本进程共享区域，设置PC，指向代码区域的入口点，Linux根据需要换入代码和数据页面。 7.8缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。下图展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。 接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。下图展示了在缺页之后我们的示例页表的状态。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块(block)的集合来维护。每个块就是一个连续的虚拟内存片(chunk),要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格，它们都要求应用显式地分配块，而不同之处在于由哪个实体来负责释放已分配的块： 显式分配器，要求应用显式地释放任何已分配的块；而隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。因此隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集。 7.10本章小结 本章简要地介绍了hello进程的内存地址空间管理，并对intel的段式管理和页式管理做了介绍，对TLB与四级页表支持下的VA到PA的变换和三级Cache支持下的物理内存访问进行了介绍，进而结合hello进程对fork与execve从虚拟内存视角进行了分析。最后介绍了缺页故障与缺页中断处理和动态存储分配管理。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 一个Linux文件是一个m字节的序列，所有的I/O设备（如网络、磁盘和终端）都被建模为文件。并且所有的输入和输出都被认为是对相应文件的读取和写入并执行。这种将设备映射到文件的方法允许Linux内核在称为UnixI/O上运行一个简单的低级应用程序接口，它允许输入和输出以一致和一致的方式运行。 应用程序通过要求内核打开相应的文件来声明它要访问I/O设备。内核返回一个小的非负整数称为描述符，文件的关联数据由内核保存，应用程序只需要保存这个描述符。 Linuxshell创建的每个进程都包含三个文件： 标准输入、标准输出和标准错误以供操作时使用 对于每个打开的文件内核维护文件位置k，它从0开始，它是从文件开头的字节偏移量。应用程序可以通过执行搜索显式更改该值。 对于读操作，从文件复制n个字节到内存，文件位置k增加到k+n，当k大于等于文件大小时，触发EOF条件，即结束文件被读取。 最后，在文件访问结束后。该文件将被内核关闭。内核释放文件打开时创建的数据结构，并将描述符恢复到现有的描述符池中。 8.2简述UnixIO接口及其函数 (1)打开文件：一个应用程序同步异常（陷阱）请求内核打开某文件，表示其要访问一个I/O设备，内核返回一个小的非负整数（描述符），然后对此文件的所有操作中标识这个文件，内核把有关这个文件的所有信息进行记录。 (2)Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。 (3)更改当前的文件位置：对于已打开的某个文件，内核保存着一个文件位置，初始化为0，是从文件开头起始的字节偏移量是这个文件的位置，应用程序能够通过执行seek函数更改当前文件位置。 (4)读写文件：对于读操作，从文件复制n个字节到内存，文件位置k增加到k+n，当k大于等于文件大小时，触发EOF条件，即结束文件被读取。同理写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，写完成后更新k。 (5)关闭文件：内核释放文件打开时创建的数据结构，并将描述符恢复到现有的描述符池中。 UnixI/O函数: (1)intopen(char*filename,intflags,mode_tmode)，通过调用open函数打开现有文件或创建新文件的过程。open函数将文件名转换为文件描述符并返回描述符编号。返回的描述符始终是进程标志中未打开的最小描述符参数。指定进程打算如何访问文件。mode参数指定新的文件访问权限位。 (2)intclose(fd)，fd是需要关闭的文件的描述符，close返回操作结果（一个整型数）。 (3)ssize_tread(intfd,void*buf,size_tn)，read函数从当前带有fd描述符的文件位置到buf内存位置最多分配n个字节，返回值-1表示错误，0表示EOF；否则返回值表示实际传输的字节数。 4）ssize_twirte(intfd,constvoid*buf,size_tn)，write函数从内存位置buf复制至多n个字节到当前描述符为fd的文件位置。 8.3printf的实现分析 printf函数的函数体如下： intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } printf程序按照格式fmt结合参数args生成字符串，并返回串的长度。 然后是write函数： write: moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL 在printf中调用系统函数write将长度为i的buf输出，在write函数中，将栈中参数放入寄存器，ecx是字符个数，ebx存放第一个字符地址。 intINT_VECTOR_SYS_CALLA表示通过调用系统syscall。 然后是sys_call的实现： sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret sys_call函数通过总线将字符串中的字节从寄存器复制到显卡的显存。显存存储ASCII字符码，字符显示驱动子程序通过ASCII码在字体库中查找点阵信息，将点阵信息存储在vram中。 显示芯片根据刷新频率逐行读取vram。并通过信号线将每个点（RGB分量）发送到液晶显示器。所以我们的输入字符串出现在屏幕上。从vsprintf生成显示数据，写系统函数，int0x80拦截系统调用，或者sys_call字符显示驱动子程序：从ASCII到字体库显示vram。（采集每个点的RGB颜色数据） 显示芯片根据刷新频率逐行读取vram。并通过vsprintf的信号线将每个点（RGB分量）发送到液晶显示器，生成显示数据。编写write函数，然后到陷阱-系统调用int0x80或sys_call等。 字符显示驱动子程序：从ASCII到字体库显示vram（存储每个点的RGB颜色数据），显示芯片相应地逐行读取vram刷新频率并通过信号线将每个点（RGB分量）发送到液晶显示器。 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar的源代码为： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } 异步异常-键盘中断的处理：当用户按下一个键时，键盘接口会得到一个代表该键的键盘扫描码，同时产生一个中断请求。中断请求抢占当前进程运行键盘中断子程序。键盘中断子程序首先从键盘接口获取按键的扫描码。然后将按键扫描码转换成ASCII码保存在系统的键盘缓冲区中。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 第八章讲述了IO设备的管理方法，IO接口及其函数，最后分析了printf和getchar函数的实现方法。 结论 用计算机系统的语言，逐条总结hello所经历的过程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 编写：通过编辑器将代码输入hello.c。 预处理：将hello.c调用的所有外部库和宏替换预处理、扩展和合并到一个hello.i文件中。 编译：将hello.i编译成汇编文件hello.s。 汇编：把hello.s汇编成可重定位的目标文件hello.o。 链接：将hello.o与可重定位的目标文件和动态链接库链接成可执行的目标程序hello。 运行：在shell命令行中输入./hello1190202008赵加毅2。 创建子进程：shell进程调用fork为其创建子进程。 运行程序：shell调用execve，execve调用loader，添加映射的虚拟内存，程序进入程序入口后开始加载物理内存，然后进入main函数。 执行指令：CPU为其分配时间片，在一个时间片内，hello可以使用CPU，依次执行自己的控制逻辑流。 上下文切换：hello调用sleep函数之后进程进入内核模式，内核进行上下文切换将当前进程的控制权交给其他进程，当sleep函数调用完成时，内核执行上下文切换将控制返还给hello进程。 访问内存：MMU将程序中使用的虚拟内存地址通过页表映射到物理地址。 动态内存申请：printf调用malloc动态内存分配器在堆中申请内存。 信号：如果在运行时输入ctr-cctr-z，会分别调用shell的信号处理函数终止和停止。 结束：shell父进程或ini养父进程回收子进程，内核删除为这个进程创建的所有数据结构。 计算机系统的设计思想和实现是基于抽象实现的：抽象体现在：用二进制01表示的最低层信息，操作系统管理硬件，进程是处理器、主存和I/O设备的抽象。虚拟内存是主内存与磁盘设备联系的抽象等。 计算机系统的设计是统筹兼顾的：计算机系统的设计考虑了所有可能的实际情况，并相应地设计了一系列的处理方法来适应不同的情况。 计算机系统设计精巧：为了解决快设备小存储与大存储设备慢存储的不平衡，设计了Cache和TLB等缓存设备作为下层存储设备的缓存，很大程度上提高了CPU运行的速度。 
第354篇文章[]
软件构造笔记（四）：Spec、AF和RI 前言 本文将介绍一些关于ADT设计中Spec、AF和RI的细节。由于内容较为细碎，为了加强理解，特将该部分知识点列出来，进行简单归纳总结。 一.Spec 刚开始接触软件构造时，关于规约Spec的概念便已经有所接触，但真正开始逐步认识还是在实验中设计规约的时候。 （一）含义 Spec是程序员在设计ADT时对自己所写方法的规约，它规定了方法应该做什么，不应该做什么。而在接下来的设计中，测试用例的编写就需要依靠Spec的描述，因为程序员所编写的代码必定是符合spec的，否则就是不合格的。同时，有了Spec的存在，客户端在使用代码时就会有所依据，好的Spec可以大大节省客户端使用自己的API时所需要的时间，并且大大降低了客户端对自己所编写的代码的误解。 （二）内容及评判标准 Spec的主要内容分为以下三部分： 1.前置条件precondition：这是对客户端的约束，是用户在使用方法时必须满足的条件。在Java中一般使用声明@param说明每个参数的前置条件。 2.后置条件postcondition：这是对开发者的约束，也是方法结束时设计者必须满足的内容。在Java中一般使用如下两种声明，其内容及用途如下： @return：对后置条件的说明，一般为返回值； @throws：说明出现异常的时候会发生什么，一般为异常处理方式。 （三）Spec强弱 若想要Spec变强，可以采用如下方式： 1.更宽松的前置条件 2.更严格的后置条件 如果是用椭圆在图中对不同的Spec强弱进行表示，则越小（包含的结果的点越少）的椭圆，其Spec越强，此处我们可以理解为：椭圆的大小代表了开发者的自由度。 （四）注意事项 程序员应该通过Spec让客户端轻松地知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，但不应该让用户知道方法的内部逻辑是怎么样的，以避免恶意用户对代码结构的破坏。 二.AF和RI 由于AF和RI之间存在映射关系，因此可以将两者放在一起进行讨论。 （一）含义 RI：RepInvariant。其中Invariant是不变量的意思，是ADT的功能中任何时候都应该满足的一些条件。 AF：AbstractionFunction。代表抽象函数。 （二）具体表示 AF和RI中的A和R分别代表两个空间：R是内部表示的空间，是开发者关注的内容；而A是ADT能表示的存在于实际的对象，一般是由客户所关注的。 而AF就是从R空间到A空间的一个映射，作为解释函数，对A空间的每一个对象，在R空间中都至少由一种属性或类型与之对应，因此该映射是一个满射。 而RI是一个集合，是R空间中所有值的子集，包含了所有合法的表示值。checkRep()方法就是用来随时检查RI是否被满足的。 此处附上自己在lab2中写过的AF、RI，以及Safetyfromrepexposure的描述： //Abstractionfunction: //AF(vertices)=点集 //Representationinvariant: //无重复点 //Safetyfromrepexposure: //privatefinalList<Vertex<L>>vertices （三）注意事项 RI、AF存在如下关系： 相同的R可能存在不同的RI； 即使是同样的R、RI，也可以根据解释不同，而获得不同的AF； 两个ADT有相同的rep和相同的AF，但其R也不 定相同。 不应该给client看的内容有AF、RI、Repexposuresafetyargument、testingstrategy、Rep、Implementation和Testcases等等，留给client的只有Spec。 总结 本文主要解释了一些ADT设计中关于Spec、AF和RI的含义、内容、注意事项等内容。其细节部分相对琐碎，但是在实际应用中非常重要，因此应该牢记，并在日后有需求的时候活学活用。 
第355篇文章[]
软件构造lab3心得 前言 经过前后两周时间的调试和反复修改，终于完成了lab3实验指导手册中的内容(当然不一定很完善)。简单写一下心得，梳理一下自己实验中的收获，以及实验过程给我带来的新体会。外加临近期末考试，需要对知识点进行整理，对课程布置的实验进行回顾，因此决定写一篇博客，记录一下lab3给我带来的收获。 内容 一.实验目标概述 该实验的目标是编写具有可复用性和可维护性的软件，主要使用以下软件构造技术： 子类型、泛型、多态、重写、重载； 继承、代理、组合； 语法驱动的编程、正则表达式； API设计、API复用； 本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过ADT和泛型等抽象技术，开发一套可复用的ADT及其实现，充分考虑这些应用之间的相似性和差异性，使ADT有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。 二.实验中遇到的一些知识 （一）委派(delegation) 该实验设计过程中主要涉及到了委派的思想，用于提高代码的可复用性。 委托的含义：当我们设计ADT时，若遇到一个对象需要另一个对象的功能时，便可以让新对象捕获该对象，并可以在另一对象中对其进行功能调用，这个过程便是委托。 在使用委派时，过程涉及到的类A和类B是两个没有任何关系的类，而B具有和A一模一样的方法和属性；当我们调用B中的方法时，调用B中的属性就等价于调用A中同名的方法和属性。此时B如同得到A授权委派的中介。调用B类的代码不需要知道A的存在，也不会和A发生直接的联系，而通过B就可以直接使用A的功能，这样的模式，既能够使代码使用到A的各种属性及功能，又能够很好地将A保护起来。 委派与继承的操作过程相似，都是对某一个类进行复用，但两者实际上存在较大差异：继承是在一个现有类的基础上去构建一个新的类，而这个构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承（非父类私有）的属性和方法。如果想声明一个类继承另一个类，需要使用extends关键字。而委派的双方往往是关联不大的两个类，一般当想要调用一个类中的少部分属性或方法时，便可以采用委派的方法。而当多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要对那个类进行继承即可。 比如说，水果的榨汁过程需要工厂的操作，是因为水果自己不具有榨汁的功能，因此我们可以把水果交给工厂类中的方法进行处理，这便是委托的过程。 而水果成熟后，会从生长的植株上下落，这种下落的行为在水果中很常见，苹果、梨也有下落的行为，因此便可以在水果类中写下这种行为，然后在苹果类中通过extends获得这个方法的复用，这便是继承的过程。 （二）Decorator装饰器模式 Lab3中，自己对三个应用类的设计其实是采用了第五种方案，不过在实验设计完成以后又通过查阅资料对另外五种设计方案进行了简单的了解，感觉第六种方案更加简便，因此在这里介绍一下Decorator设计模式。 为了让每一个子类实现不同的特性，采用Decorator设计模式，为对象增加不同侧面的不同特性。该设计模式的原理如下： 首先从接口派生出子类，并在子类中定义一个父类接口，将其作为delegation的对象。这个过程类似于子类型自己到自己(该接口的其他子类)的委派。这两个类都是同一个接口的子类。 使用装饰类，通过一层一层反复装饰，最终得到的对象可以拥有任意不同特性的组合，我觉得这就是Decorator模式最精妙的地方，只要ADT设计得当，复用后使用起来将会非常简便。而装饰的顺序并不会影响到对象的最终结果拥有哪些特性，唯一的影响在于最终得到的是哪个类型的对象，即最后一次装饰的特性决定了最终得到哪个具体类型的对象。 三.自己在实现过程中遇到的困难及解决过程 实验刚开始进行的时候，我曾经犯过一个很低级的错误，就是将interface写在了class类中，后来通过对lab1、lab2中涉及到复用的代码进行查看才发现自己的错误所在。个人认为，interface和class在层次上可以是并列关系，接口类似于类，但其成员都没有执行方式，它只是方法、属性等内容的组合。 总结 实验3中还有很多较为核心的内容没有列出，文章只给出了一些Java语法及ADT复用的原理及使用方法，一些其他重要的内容将在以后总结。 
第356篇文章[]
软件构造笔记（三）：关于等价性的个人理解 前言 前两篇博客中介绍了自己软件构造的第二次、第三次实验内容及心得体会，本文将介绍一些软件构造学习过程中遇到的一部分知识点难点，剩余的内容将在随后补充。 一.引用等价性和对象等价性 （一）引用等价性==： 该比较符号比较的内容是索引，它测试的是指向相等，如果两个索引指向同一块存储区域，那它们就是相等的。对于基本数据类型，我们只能使用这种方式进行比较，若相同，结果为true；否则为false。 （二）对象等价性：equals()： 这是一种方法，比较的是对象的内容，用来测试对象的值是否相等，复合数据类型和对象都通过这种方式进行比较。 总结：当对两个同类型对象进行比较时，这两种比较方式的结果不一定相同，当我们比较引用等价性时，除非是同一个new出来的对象，否则结果为false。而当我们比较对象等价性时，则会根据对象内容及重写情况比较，若无重写则结果会等同于双等号比较。 二.hashCode()方法 （一）对于不可变类型： equals()应该比较抽象值是否相等。这和equals()比较行为等价性是一样的。 hashcode()应该将抽象值映射为整数。 不可变类型需同时重写equals()和hashcode()。 （二）对于可变类型： equals()应该比较索引，就像==一样。同样的，这也是比较行为相等性。 hashcode()应该将索引映射为整数。 所以可变类型不用重写这两个方法，直接继承Object中的即可。 三.观察等价性与行为等价性： （一）观察等价性： 两个索引在不改变各自对象状态的前提下不能被区分。即通过只调用observer，producer和creator中的方法，它测试的是这两个索引在当前程序状态下“看起来”相等。 （二）行为等价性： 两个索引在任何代码的情况下都不能被区分，即使有一个对象调用了改造者，它测试的是两个对象是否会在未来的所有状态下“行为”相等。 讨论 从前在实验里会常常用到equals()，但是没有注重过equals()的具体应用场景和重写。而在不够理解等价性的定义时候，我使用的方法多为，直接加条件判断，把需要判断相等即等于对象相等的变量直接放入条件判断语句，这正是比较观察等价性的一种体现，而以后对于可变数据型，定义新的方法就等同于使用条件语句判断，对于不可变数据类型，重写也就是注重对象中的“一部分”是等价的，就可满足条件。 此外，观察等价性与行为等价性的区分是可变数据类型特有的对象等价性区分特征，这里也需要注意一下。 
第357篇文章[]
HIT软件构造五 HIT软件构造笔记五Object-OrientedProgramming1、Interface接口接口可以实现静态方法，使用static关键字。 通过static关键字可以实现静态工厂方法，从而将接口的实现类封装，实现对外信息隐藏。 接口中也允许使用default关键字来定义并实现实例方法，这个应用有点类似于抽象类的功能。 通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它。2、继承和重写子类覆写的方法的可见性要大于等于父类，因为子类的对象应可以转型为父类对象，可见性的降低就会出现错误。同理，子类抛出的异常必须是父类的子集。 覆写的方法是在运行时判断类型来调用的，因此以new构造的类型为准。 在子类中,用super关键字来调用父类的各种方法，用的最多的是构造方法。3.、多态三种多态：特殊多态、参数化多态、子类型多态特殊多态:一个方法可以有多个同名的实现(方法重载)。要求参数列表必须有不同的地方，其他的并没有要求，总之就是把重载的方法看作和之前完全不同的方法。参数化多态:一个类型名字可以代表多个类型(泛型化编程)。子类型/包含多态:一个变量名字可以代表多个类的实例。 4.ADT与OOP中的等价性判断等价性的方法①利用数学上等价的定义:满足自反性，对称性和传递性。②利用AF来定义ADT的等价判断，如果两个值的AF映射值相同，则说明他们等价。③在调用者角度，如果调用两个对象的所有任意操作，效果都完全一样，那么则说明他们等价。 “”与equals对于“”,代表着判断两个对象的地址空间是不是在同一个位置，也被称为引用等价性；而equals则代表着判断两个对象的内容，也被称为对象等价性。 object类的equals默认为判断两者的地址空间是不是在同一位置。总的来说，对于基本数据类型，我们应该用“==”，而对于对象数据类型，我们应该用equals判断(当然，要根据需要判断是否应该覆写)，当然，我们要明确知道我们写的方法是覆写还是重载。 除了写equals方法，尽量不要用instanceof和getclass()，因为他们不符合OOP的思想，不是好的书写风格。 hashcode与equalshashcode方法就类似于数据结构中的哈希函数一样，功能就是把一个个对象映射到一个地址(也就是桶)。默认的方式是按照地址映射，一般地址不同则值不同。 当我们使用HashSet等类似的数据结构的时候，这时再进行寻找时，就如同正常哈希表一样了，是通过判断哈希值是否相等先进行判断，哈希值相同是equals成立的前提，也是首先判断的方法。此时如果我们只重写equals而不重写hashcode，则hashcode还是默认的按地址算出一个值，一般而言只要地址不同则哈希值就不同了，导致了我们equals方法看似失效。 综上，equals()应满足如下条件：首先满足等价性(数学意义上)，其次保证在不被修改的情况下，每次调用的结果应该相同，同时要处理对象为null的情况还有如果这个类使用了哈希表进行查询(比如放入了HashSet中)，则也要覆写hashcode方法。 可变类型的等价性：观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致。调用Observer方法表现出相同的结果。约等于对象等价性。行为等价性：调用对象的任何方法都展示出一致的结果。包括mutator、producer、observer。约等于引用等价性。 equals()和hashCode()所以，对可变类型，实现行为等价性即可，也就是说，只有指向同样内存空间的对象才是相等的。所以对可变类型来说，无需重写这两个函数，直接继承Object的equals()和hashCode()即可。 5.装箱及其等价性 在使用集合类时，我们前面也提到过，会进行隐式的装箱操作。因此，装箱完毕后，如果是两个不同对象，即使是整数的装箱，使用“==”进行判断也会返回false，要进行equals的覆写。 但是下面有一个特例，那就是如果是-128到127之间的整数，进行两次装箱操作，那得到的地址是一样的(得益于java的缓存机制)。当然，上面也是要求只装箱，不能为两次new的操作，不然肯定地址值不同。 
第358篇文章[]
HIT软件构造笔记三 HIT软件构造笔记三1.1DataTypeandTypeChecking 编程语言的数据类型基本数据类型(int、boolean、char、byte、double、long)，Immutable，在栈中分配内存，代价也比较低对象数据类型(String、Integer等)。Immutable/Mutable，分配的内存都在堆中，代价相对昂贵 基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。2.类型检查静态类型语言(Java)可执行静态类型检查，在编译阶段进行类型检查，这意味着避免了将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误都可以在静态类型检查时发现；动态类型语言(python)只有动态类型检查，在运行阶段才会进行类型检查，例如非法的参数值(最典型的NULL引用)、非法的返回值、越界等等。3.Mutability和ImmutabilityImmutability：不变性，一个重要的设计原则，设计ADT时尽量保证这个原则。 Immutabletypes：不可变的数据类型，当实例对象被创建以后，该对象的值就不可变化了，也就是该ADT中不能有mutator方法。 可变对象的优点：虽然mutable类型由于指向的是同一个存储区域，所以更改对象的内容后会在意想不到的位置产生意想不到的变化，所以更推荐使用Imutable的数据类型，但是使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，比如依次将‘a’~‘z’连接到一个空字符串上，就会产生25个临时拷贝，而使用可变类型则最少化拷贝以提高效率。 使用可变数据类型，可获得更好的性能。但是在质量指标中，性能的优先级较低，所以即使mutable类型有这个优点也更倾向于选择imutable的类型。 4.Snapshotdiagram基本类型的值对象类型的值：mutable对象，单线圈；immutable对象，双线圈；可变的引用，单线箭头；不可变的引用，双线箭头 5.集合类型List Set Map 1.2DesigningSpecification1、Spec的用处；没规约，没法写程序；即使写出来，也不知道对错；规约是程序与客户端之间达成的一致；Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守；很多bug来自于双方之间的误解，不写下来，那么不同开发者的理解就可能不同；没有规约，难以定位错误；精确的规约，有助于区分责任；客户端无需阅读调用函数的代码，只需理解spec即可2、Spec的结构：precondition前置条件：对客户端的约束，在使用方法时必须满足的条件使用@paramannotation说明每个参数的前置条件postcondition后置条件：对开发者的约束，方法结束时必须满足的条件使用@returnannotation说明后置条件使用@throwsannotation说明出现异常的时候会发生什么在方法声明中使用static等关键字声明，可据此进行静态类型检查当客户端满足前置条件的时候，结果必须满足后置条件；当前置条件不满足的时候，方法内部可以做任何事情，但作为开发者，应该尽量让程序做到failfast。 3、Spec的评判标准：spec变强的要求是更宽松的前置条件+更严格的后置条件，在这种情况下，就可以用变强了的spec去替换原来的spec。越强的规约，意味着implementor的自由度和责任越重，而client的责任越轻。 用椭圆表示spec的强度，大椭圆表示更弱的spec，小椭圆表示更强的spec，椭圆的大小表示的是开发者的自由度，小椭圆有更强的后置和更弱的前置，因此所包含的结果的点就少，所以就小。 
第359篇文章[]
HIT软件构造笔记四 HIT软件构造笔记四AbstractDataType(ADT)1.ADT的操作：Creatorscreatenewobjectsofthetype.构造器Producerscreatenewobjectsfromoldobjectsofthetype.生产器Observerstakeobjectsoftheabstracttypeandreturnobjectsofadifferenttype.观察器Mutatorschangeobjects.变值器，改变对象属性的方法 2.ADT的设计法则法则1：操作要简洁，一致。对于复杂的操作，应该拆分成多个简单操作的叠加，以此提高内聚性。 法则2：操作要全面(即需要的功能要可以实现)，且为用户提供方便的操作。 法则3：要不是针对抽象，要不是针对具体，不要两者混合。因此面向具体应用的类型不应该有通用方法，面向通用的类型也不该有具体方法。3.ADT的测试总的来说，对构造器、生产器、变值器的测试要用观察器检查；对观察器的测试要用其他三类方法来产生或构造对象。但这样的风险是，可能会产生互相依赖的现象，导致无法找到真正的错误原因。 解决方案：新创建一些方法来解除这些耦合，或者是把一部分私有方法改为公有方法，测试完后再换回私有。或者如果对于小型程序，只要测试结果都是正确的，也就可以解决问题。 4.不变量与抽象函数RepInvariant(RI)andAbstractionFunction(AF)Invariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件 两个空间R和A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。 AbstractionFunction：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。 RepInvariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。5.AF，RI和表示泄露安全说明的文档化这些都是写在代码的注释中，而非规约中。要给出理由，证明代码并未对外泄露其内部表示，比如字段全部为private，还有对可变字段的处理等等。 可用表示不变量来代替一些前置条件。 
第360篇文章[]
HIT软件构造笔记六 HIT软件构造笔记六一.可复用性的度量、形态与外部表现1.可复用性的评估评估的方面：复用的频繁性、复用的代价(适配)一个有高可复用性的代码应该有如下特点：小、简单；与标准兼容；灵活可变；可扩展；泛型、参数化；模块化；变化的局部性；稳定；丰富的文档和帮助。2、复用的层面两种复用的方式：白盒复用和黑盒复用。黑盒复用就类似于调用API接口，或者方法等等；白盒复用是直接得到想要复用的源代码(或其他内容)等等，然后自己根据需要进行修改。 根据复用内容的结构从小到大，分为如下四种复用。 (1).源代码级别的复用:这个是最底层的复用，就是简单的复制粘贴修改。 (2).模块级复用:以class作为最基本的单元，复用的方式有继承和委托，其中委托的耦合度明显低于继承。 (3).类库级重用:相当于把一系列的class进行了打包，类似于第三方库的调用。 (4).框架级复用:在框架的基础上，填充自己的代码，形成完整系统。(其实就类似于一些实验中，给出了很多代码，要求我们填入一些自己的代码) 二．面向复用的软件构造技术1、LSP与泛型中的运用Liskov替换原则，从实际设计的角度来说，这个原则其实就是对子类型的约束：要求子类型对象完全可以当作父类型的对象来使用，其中就包括了规约的前置条件不能强化，后置条件不能弱化，要保持不变量等等。 下面介绍协变与异变的概念。 协变：子类对父类方法的覆写中，异常、返回值的类型是父类方法中返回值的类型的子类型，就称之为协变。 逆变：顾名思义，与协变恰恰相反。 因此为了复合Liskov替换原则，我们要求如果有变化的话，那异常，返回值必须是协变，参数必须是异变(当然，在java语言中参数的异变或协变导致方法不再是覆写，而是重载)。 java中的泛型是类型不变的，如下图所示，是十分经典的例子。如果想进行协变或逆变，则需要使用通配符，例如List<?extendsNumber>是List<Number>的子类型，但是不论如何都要确保一个List中的元素都是一种类型的(尽管多种元素都可以放入)。 2、委托与组合委派/委托：一个对象请求另一个对象的功能。 四种委派方式：①Dependency：依赖关系，临时性的delegation②Association：关联关系，永久性的delegation。③Composition:更强的association，但难以变化。④Aggregation:更弱的association，可动态变化。 组合：利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。 3、框架framework黑盒框架：通过实现特定接口进行框架扩展，采用的是delegation机制达到这种目的，通常采用的设计模式是策略模式(Strategy)和观察者模式(Observer)白盒框架：通过继承和重写实现功能的扩展，通常的设计模式是模板模式(TemplateMethod)。 
第361篇文章[]
HIT软件构造lab1心得 1实验目标概述本次实验通过求解三个问题，训练基本Java编程技能，能够利用JavaOO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。基本的JavaOO编程基于EclipseIDE进行Java编程基于JUnit的测试基于Git的代码配置管理2实验环境配置安装Eclipse、JDK和Git 1、在配置Eclipse时，通过Window–Preferences–Java–InstalledJREs–添加已安装好的jdk的路径，配置jdk 2、学习了一些Git指令，如3.2Problrm2中初始化一个本地仓库，并将Lab1push到本地仓库中。3、学习了Junit测试project，在要使用Junit的project名上，右键–properties–javabuildpath–libraries–AddExternalJARs–点击Junit包。在3.2和3.3中书写并使用Junit进行测试。 3实验过程请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。为了条理清晰，可根据需要在各节增加三级标题。3.1MagicSquares该任务有两个要求：1、实现从txt文本中读取数据并保存，判断其是否为魔方阵2、创建一个阶数为n，且n为奇数的魔方阵，并根据1的代码判断这个魔方阵是否满足定义。在给出的代码中添加注释，并将创建出的魔方阵保存到6.txt文本中，当程序异常时,“优雅的”退出 函数输出false结束，并非非法退出。3.1.1isLegalMagicSquare()1、该函数：booleanisLegalMagicSquare(StringfileName)接受一个文件名，并且返回一个布尔结果（True/False),通过文件名+文件相对路径，函数读取文本中的数据，保存在一个二维数组中，进行判断该文本中的数据是否为魔方阵。2、在函数：voidmain(String[]args)throwsIOException中定义fileName并传输给isLegalMagicSquare，通过“src/P1/”+fileName找到文本文件。3、首先将数据按行存储在一个可动态修改的数组中，并且通过“\t”分隔符将数据存入一个二维数组中。4、对存入的数据进行判断：（1）判断文本中的数据是否合理：①判断文本中数据是否重复；②判断文本中数据是否均大于0；③判断数据中是否含有小数；④判断是否有文按“\t”分割存储的数据；（2）判断数据是否满足每行、列和两条对角线之和均相等。3.1.2generateMagicSquare()函数注释： 第0行中间，放置1。向当前位置的右上方放置下一个数；若下一个位置超出数组下标范围，则将魔方阵沿行、列方向看成环形，下标再从0开始计数若当前放置数是n的倍数，表示一条对角线已满，则下一个位置是本列的下一行采用二维数组存放幻方阵，元素下标i，j沿行、列方向看成环形变化规律如下：i=（i-1+n）%n；//向上一行j=（j+1）%n；//向右一列1、在调用函数generateMagicSquare()前，先对输入的n值进行判断，将大于0且是奇数的n传输到函数中。2、首先构造出n*n的魔方阵3、将魔方阵写入6.txt中4、输出生成的魔方阵5、调用函数IsLegalMagicSquare()判断6.txt中的数据是否是魔方阵6、结果 关于异常产生的分析: 数组越界,原因是在生成函数中,i<=square,计算机面对非整数时常用的方法是向下取整,输入奇数时col=n/2的值会向下取整,而square=n*n,所以此时i即使=square,数组也不会越界,而如果输入为偶数时,当i=square时就会发生越界,原因是在下标为n的数组中放入了大于n个的数据 此时数组下标为负值,输入的n为负值循环时数组下标为负，所以产生异常。3.2TurtleGraphics获取turtle包，熟悉TurtleGragpics的各种函数接口，调用已有的函数，实现java语言的绘图功能，并用java给出的.Math库里的函数实现一些简单的计算功能。3.2.1Problem1:Cloneandimport3.2.1.1从GitHub获取该任务的代码 https://github.com/rainywang/Spring2021_HITCS_SC_Lab1/tree/master/P2获取代码。将turtle包和rules包存入本地文件夹中，在Eclipse中，File–import–General–Filesystem–Browse…–找到本地文件夹并将turtle包和rules包复制到eclipse-workspace/TurtleGragphics.java/src/中，完成将实验需要的库导入。3.2.1.2在本地创建Git仓库：右键ProjectTurtleGragphics.java–Team–ShareProject…–Git–next–Finish3.2.1.3使用git管理本地开发。右键ProjectTurtleGragphics.java–Team->commit->StagedChanges->CommitMessage->Commit(推到本地仓库)3.2.2Problem3:TurtlegraphicsanddrawSquare3.2.2.1提供两个函数forward(units)：在当前方向上按单位像素移动turtlre，其中单位是一个整数。按照最初的标志惯例，turtle从朝上开始。turn(degrees):更改当前朝向，向右顺时针旋转，其中度数是double型。3.2.2.2调用forward()、turn()函数，画正方形，需要顺时针旋转90°前进sideLength,循环4次 下图为边长sideLength为100的正方形 3.2.3Problem5:Drawingpolygons3.2.3.1已知正多边形边数sides，求内角的度数由数学公式推导得内角度数=(double)((sides-2)*180.0/sides) 运行TurtleSoupTest中的Junit测试calculateRegularPolygonAngle()：右键TurtleSoupTest.java–Runas–1JUnitTest 3.2.3.2drawRegularPolygon(Turtle,int,int)，已知正多边形的内角、边数、边长，画出这个正多边形（转动的角度=180°-内角） Main函数，在main中输入得到正多边形的边数和边长 3.2.3.3示例边长为50的正六边形 边长为60的正八边形 3.2.4Problem6:CalculatingBearings3.2.4.1calculateBearingToPoint(double,int,int,int,int)计算turtle从当前位置和朝向到终点顺时针需要转过的角首先计算过两点的线段与x轴正方向形成的夹角，这里使用了Main.atan(x,y)函数，在与currentBearing相减，此时要注意：1、判断起点和终点是否重合2、夹角和turtle转过的角度范围都是[0.0,360.0）3、turtle朝向是上，而x轴正方向是向右，turtle是顺时针旋转（角度由小到大），坐标轴是逆时针旋转（角度由小到大）。所以currentBearing要减去90再取相反数。即currentBearing=90-currentBearing。 Junit测试 3.2.4.2publicstaticListcalculateBearings(ListxCoords,ListyCoords)该函数使用List存放每次调用calculateBearingToPoint返回的值，依次对相邻节点调用calculateBearingToPoint，在下一次循环，这一次的终点会被覆盖为下一次的起点，假设初始的起点为（0，0），总共由n个点，则有n-1次调用，在for循环中i=1，所以共循环n-2次。 Junit测试 3.2.5Problem7:ConvexHulls算法：边界漫游法时间复杂度：T（n）=O（n^2）1、首先遍历所有的点，找到最左下角的点2、以找到的点为基点，y轴正向为目前偏移角，开始依次找顺势针转角最小的点，记录这个点并将它加入到凸包集合中，以这次的偏向角累加上之前的角度度作为下一次的目前偏向角。3、循环直到再次遇到最左下角为止退出 Junit测试 3.2.6Problem8:Personalart 3.2.7Submitting如何通过Git提交当前版本到GitHub上你的Lab1仓库。 3.3SocialNetwork熟悉和掌握java中的数据结构类型，本项目要求我们掌握图的遍历，求两点之间的最短路径。利用图来实现人与人之间的关系，并能任意计算出人与人之间的情况（有无联系），基于FriendshipGraph类和Person类3.3.1设计/实现FriendshipGraph类FriendshipGraph类中包含图中所有点，每个点代表了一个Person，包含Person之间的边，并且可以计算两点之间的距离1、addVertex（）对Person名字进行判重：用哈希集合记录下所有Person的名字，当有新的Person加入时则判断是否已经在集合中。 2、addEdge（）将两个Person之间进行联系，在图中，两个点之间的有向边表示两个Person之间有联系，而联系是双向的，所以在计算边数时需要加两个方向的边。 3、getDistance（），计算任意两个Person之间的距离，若没有任何联系则输出-1。使用BFS算法。 3.3.2设计/实现Person类给出将每个人对应到一个Person上，并保存名字，调用每个Person姓名和朋友列表3.3.3设计/实现客户端代码main()由Lab1手册得： 结果为： 3.3.4设计/实现测试用例3.3.4.1addVertexTest()函数调用addVertex（）函数，添加一个人，并判断Person中最后一个是不是这个人 3.3.4.23.3.4.2addEdgeTest()调用addEdge（）函数，给两个人添加联系，并判断xw中的朋友最后一个人是不是wy 3.3.4.3getDistanceTest()调用getDistance（）函数，增加了a,b,c三人，并添加关系，判断与我们添加的关系是否一致 Junit测试： 4实验进度记录请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。日期时间段任务实际完成情况2021-05-1113:30-15:30编写3.1.1isLegalMagicSquare()按计划完成2021-05-1216：00-20：00编写generateMagicSquare()，完成3.1延期1小时完成2021-05-1613：00-20：003.2Problem1-Problem6按计划完成2021-05-1813:30-17:303.2Problem7按计划完成2021-05-1916：00-20：003.2完成按计划完成2021-05-2016：00-22：003.33.3.1FriendshipGraph类按计划完成2021-05-2118：00-23：003.3.2设计/实现Person类按计划完成2021-05-228：00-15：303.3完成延期1小时完成2021-05-238：00-14：00完成Lab1实验报告按计划完成5实验过程中遇到的困难与解决途径遇到的困难解决途径 Junit测试在3.2中test开始处是规定好的文件格式，添加Junit4后即可测试，在3.3中自己写测试的时候没有注意格式导致不成功，在与3.2中对比后，成功写出了可以进行junit测试的test.java文件凸包问题难以解决通过查询资料得到许多解决凸包问题的算法 6实验过程中收获的经验、教训、感想6.1实验过程中收获的经验和教训6.2针对以下方面的感受(1)Java编程语言是否对你的口味？第一次接触java，对其中的许多函数还不了解，只能从头开始学习。使用c语言完成的一些非常复杂的数据结构在java库中已经存在，对使用非常方便，这次实验让我受益匪浅。(2)关于EclipseIDE；初次使用Eclipse，许多操作并不了解，而网络上对它的细致的、系统的描述也比较少，只能通过一点点查询来了解java文件运行出错时可能的原因。让我比较印象深刻的是，eclipse对可能为空的字符串非常严格，只有在判断其不为空时，才能继续运行。(3)关于Git和GitHub；Git之前从未接触过,它可以在本地构建仓库更新版本，对Github也是知之甚少,这次实验我也只是学会创建了一个账号。(4)关于CMU和MIT的作业；全英文让我理解起来比较困难，只能反复的读题去理解题意(5)关于本实验的工作量、难度、deadline；对于初次接触java语言的我来说，有些吃力，deadline比较合理，因为平时周末基本没有课，没有实验的话可能也不会起早。(6)关于初接触“软件构造”课程；之前没有系统的了解过这门课程，但经过这几周的学习，让我对它愈发感兴趣起来。 
第362篇文章[]
HIT软件构造笔记二 HIT软件构造笔记二1.1.1SoftwareLifecycleandConfigurationManagement1、SoftwareDevelopmentLifecycle软件开发生命周期(SDLC)：从无到有，从有到好静态测试：肉眼检查。动态测试：用测试用例进行实际测试。2、传统软件过程模型：基本类型有线性过程(Linear)和迭代过程(Iterative) 目前存在的模型有瀑布过程(waterfall)，增量过程(incremental)，V字模型(V-model)，原型过程(prototyping)，螺旋模型(spiral)。3、敏捷开发：Agile=增量+迭代通过快速迭代和小规模的持续改进，以快速适应变化，每次迭代处理一个小规模增量4、极限编程：XP 1.1.2软件配置管理(SCM)和版本控制系统(VCS)软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被称为软件配置项(SCI)。 当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。 为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。 VCS分为三种：1、本地版本控制系统（无法协作）存储在本地2、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）3、存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。1.1.3Git创建：gitinit 暂存：gitadd 提交：gitcommit-m“commitmessage” 链接：gitremoteaddorigin 推送：gitpush-uoriginmaster 创建分支：gitcheckout-b 切换分支：gitcheckout 合并分支：gitmerge 删除分支：gitbranch-d git中的四个区域：workspace、stagingarea、Localrepository、Remoterepository git的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。 git单个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。 传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。 关于分支的合并：对于合并操作来说，如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的指针移到做过更改分支的指针的位置。而如果两个分支都做了更改，那么就找到更改的共同的祖先节点，以祖先节点为开始，将两个分支所有做出的更改都放在一起，在工作分支上形成一个新的节点删除分支时，只是删除了分支指针，并没有删除在该分支上的commit。 2.1Generalprocessofsoftwareconstruction 通常软件构造过程(1)Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。 (2)Codereview、Staticcodeanalysis：可以使用工具来发现bug，如CheckStyle,SpotBugs。 (3)Testing：测试，单元测试、集成测试、系统测试… (4)Debugging：调试 (5)Dynamiccodeanalysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分 (6)Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化 (7)Build：chapter22.狭义的软件构造过程(Build)这是一个借助于工具，将软件构造过程中大的各阶段的活动自动化的过程，尽可能地脱离人工，以提高构造效率。 常用的工具：Jenkins、Make、Ant、Maven、Gradle、EclipseIDE 利用工具完成项目的自动化构建、测试、打包release等功能，完成buildtime–>runtime。 
第363篇文章[]
HIT软件构造lab2实验心得 HIT软件构造lab2实验心得 1实验目标概述本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说：针对给定的应用问题，从问题描述中识别所需的ADT；设计ADT规约（pre-condition、post-condition）并评估规约的质量；根据ADT的规约设计测试用例；ADT的泛型化；根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction）使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure）；测试ADT的实现并评估测试的覆盖度；使用ADT及其实现，为应用问题开发程序；测试代码中，能够写出testingstrategy并据此设计测试用例。2实验环境配置根据实验手册中的网址，在eclipse中：help–EclipseMarketplace–search–EclEmmaJavaCodeCoverage–install安装成功 URL地址：https://github.com/ComputerScienceHIT/HIT-Lab2-11902020133实验过程请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。3.1PoeticWalksMIT指导页面链接：http://web.mit.edu/6.031/www/sp17/psets/ps2/该问题已经提供了ADT大体框架，graph的接口，要求我们建立一个边图类ConcreteEdgesGraph、一个点图类ConcreteVerticesGraph实现graph接口，实现抽象数据型，完成poet的工作。Graph接口要求实现add（添加新节点），set（添加新边），remove（移除节点），vertices（获得所有的节点集合），sources（target）获得以target为目标节点的边的起始节点，targes(source)获得以source为起始节点的边的目标节点。Poet：假设存在一条由a到b的有向边，构造有向图，再给定一句子，如果句子中两个相邻单词在有向图中有一个中间单词，则将该单词插入到a与b中间，若存在多个中间单词，则插入权重最大的那个3.1.1GetthecodeandprepareGitrepository如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。网址：https://github.com/rainywang/Spring2020_HITCS_SC_Lab2/tree/master/P1 gitbash直接执行gitclonehttps://github.com/rainywang/Spring2020_HITCS_SC_Lab2.git下载工程文件 gitclonehttps://github.com/ComputerScienceHIT/Lab2-1190202013.git本地仓库建好 3.1.2Problem1:TestGraph以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。针对Graph设计测试策略，编写测试用例主要利用等价类划分的思想进行测试。过程：用String类为Graph编写测试用例。共需编写六个函数的测试用例：add,set,remove,vertices,sources,targets。add,set,remove属于mutator；vertices,sources,targets属于observer。如下所示，为所有方法的测试策略 将Graph中的empty()方法修改为： 并对GraphStaticTest进行JUnit测试，如下：用String类为Graph编写测试用例。共需编写六个函数的测试用例：add,set,remove,vertices,sources,targets。add,set,remove属于mutator；vertices,sources,targets属于observer在coverage中查看覆盖率如下 3.1.3Problem2:ImplementGraph分别实现两个实现类ConcreteEgesGraph和ConcreteVerticesGraph，需标注创建的每一个类的AF和RI，如何防止表示泄露。使用函数checkRep来检验是否符合RI，重写toString函数以便输出该类信息。3.1.3.1ImplementConcreteEdgesGraph3.1.3.1.1实现Edge:1、EDGE中的字段包括边的起始节点、目标节点和边权值，定义为私有类型变量，信息对外界隐藏，使用final是其值不可变，防止外部对内部引用使其泄露。 2、实现Edge需要实现的方法：Fileds作用privatefinalLsource起始节点privatefinalLtarget目标节点privatefinalintweight边权值 Method作用Edge初始化构造方法，初始化边的起始节点和目标节点和边权值checkRep()检查表示不变性，两点不为null且权值非负getsource()返回有向边起始节点gettarget()返回有向边目标节点getweight()返回边权值@OverridetoString()使用@Override注释toString以确保正确覆盖Object方法的toString方法3、AF、RI和Safetyfromrepexposure 4、Edge测试策略： 3.1.3.1.2实现ConcreteEdgesGraph类：1、ConcreteEdgesGraph字段中包括顶点set表和边list表，定义私有类型的表如下图所示： 2、实现ConcreteEdgesGraph需要实现的方法： Method作用privatevoidcheckRep()检查表示不变性，edges长度是大于0的实数，有起始的节点publicbooleanadd(Lvertex)调用vertices.add，其返回结果为boolean且满足spec定义。publicintset(Lsource,Ltarget,intweight)前置条件要求weight>=0，如果weight<0，输出提示信息。在weight>=0的条件下，对图的边表进行遍历，若存在顶点为source，终点为target的边，保存这条边原本的权值，否则设为0。如果weight>0，则将这条边及顶点加入或者修改原有边的权值；如果weight=0，删除这条边。返回原本的权值。publicbooleanremove(Lvertex)从vertices中删去，传入的参数vertex点，遍历edges，寻找是否有边的起点或者是终点是该vertex，删去。注意在使用迭代器遍历时要使用iterator.remove方法保证安全。publicSetvertices()返回vertices集合publicMap<L,Integer>sources(Ltarget)根据传入的target参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。publicMap<L,Integer>targets(Lsource)根据传入的source参数寻找以source为起点的边。实现同上publicStringtoString()将整个图中所有点的指向转化为一条字符串输出 3、AF,RI和Safetyfromrepexposure 4、测试策略：继承Graph的测试策略，并增加toString的测试 测试结果如下： 检查覆盖率： 3.1.3.2ImplementConcreteVerticesGraph3.1.3.2.1实现Vertex：1、字段中应当包括点的名字，点的源点表Map，点的终点表Map，定义私有类型的表Filed作用privateLname节点名字privateMap<L,Integer>sources所有以name为目标节点的边，<起始节点name,边的权重>privateMap<L,Integer>targets所有以name为起始节点的边，<目标节点name,边的权重>2、在Vertex需要实现的方法: Interface作用privatevoidcheckRep()检查表示不变性，每个边的权值应该大于0publicLgetname)返回该节点的namepublicMap<L,Integer>getsources()根据传入的targets参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。publicMap<L,Integer>gettargets()根据传入的sources参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。publicintaddsource(Lnewsource,intweight)加入一条以source为起点，当前顶点为终点的边，即将source,weight加入sourcespublicintaddtarget(Lnewtarget,intweight)加入一条以当前点为起点，当前target为终点的边，即将target,weight加入targetspublicintremovesource(Lnewsource)在源点表中删除某起始点，并返回旧的边长publicintremovetarget(Lnewtarget)在终点表中删除某终点，并返回旧的边长publicStringtoString()得到一个点的字符串表示3、AF,RI和Safetyfromrepexposure： 4、测试策略： 3.1.3.2.2实现ConcreteVerticeGraph:1、ConcreteVerticesGraph的字段为Vertex构成的List，定义私有类型的表： 2、在ConcreteVerticesGraph需要实现的方法：Method实现思路privatevoidcheckRep()检查表示不变性，vertices中没有重复点publicbooleanadd(Lvertex)检查输入满足vertex!=null，添加一个顶点进入点表中publicintset(Lsource,Ltarget,intweight)输入source，target，weight，分别为边的起点、终点和权值。若权值为负，返回-1。若权值为正且新边已经存在，则除去原边并添加新边。若权值为正且新边不存在，则直接添加新边。若权值为0且新边已经存在，则出去原边。只要改变了原边权值，都返回原边权值，没有权值则返回0publicbooleanremove(Lvertex)除去某个点及与它相邻的所有边。只需要遍历vertices，寻找是否有与待删除点相同的名字的点直接删去即可，如果名字不相同，则在该点的源点表和终点表中寻找删去即可，使用迭代器实现。publicSetvertices返回所有的点集publicMap<L,Integer>sources(Ltarget)输入一个终点，返回与它相连的所有边和起点构成的MappublicMap<L,Integer>targets(Lsource)输入一个起点，返回与它相连的所有边和终点构成为的MappublicStringtoString()将整个图中所有点的指向转化为一条字符串输出3、AF,RI和Safetyfromrepexposure如下图： 4、测试策略：继承Graph的测试策略并增加toString的测试 测试结果： 检查覆盖率： 3.1.4Problem3:ImplementgenericGraph：3.1.4.1Maketheimplementationsgeneric将所有String改为L，并且Edge需改为Edge，Vertex需改为Vertex。3.1.4.2ImplementGraph.empty()选择ConcreteEdgesGraph作为Graph.empty()的实现类，返回newConcreteEdgesGraph 测试策略： 测试结果： 覆盖率： 3.1.5Problem4:Poeticwalks任务要求我们实现一个类，利用之前实现的图结构，能够将语料库转化为该种图结构，并且在图中搜索，完成对输入的诗句的句子进行扩充。3.1.5.1TestGraphPoet测试策略：GraphPoet()考虑到了输入文件是否存在、文件中含有多个连续空格、大小写、换行符、空行、标点符号、重复的词以及连续的词或词组等特殊情况，依此设计测试用例；poem()图中没有的词、相邻的两个词、两个词之间的路径经过多个词的情况不作改变；存在两个词在图中有一条只经过一个桥接词的路径；存在两个词在图中有多条只经过一个桥接词的路径。 具体实现读入一系列满足要求的文件： 测试结果为： 测试覆盖率为： 3.1.5.2ImplementGraphPoet1、构造器GraphPoet(Filecorpus)一行一行读入文件，以空格为界将词分开存入列表，以每两个连续的词作为顶点，这两个顶点之间有边，记录两个词连续出现的次数作为边权。观察器poem(Stringinput)输入需要进行扩充的字符串，声明声明一个StringBuilder保存，每次读取一个词，当前词作为source，下一个词作为target，然后在garph中寻找source的终点表中是否有与target的源点表中相同的元素，并且找到权值最大的和的点加入source和target之间，返回扩充后的字符串。Checkrep检查是否符合RI：图中每个词都不是空，不含有空格和换行符，都是小写，每个词都有边与之相连。toString调用ConcreteEdgesGraph中的toString方法，将整个图中所有点的指向转化为一条字符串输出2、AF,RI和Safetyfromrepexposure如下图： 3.1.5.3Graphpoetryslam运行main函数如下输出： 3.1.6Beforeyou’redone如何通过Git提交当前版本到GitHub上你的Lab2仓库。 在这里给出你的项目的目录结构树状示意图。 3.2Re-implementtheSocialNetworkinLab1这次实验要求我们基于PoeticWalks中定义的Graph及其两种实现（本人使用的是ConcreteVerticesGraph），实现Lab1中SocialNetWorek中的各种功能，并且尽可能复用ConcreteVerticesGraph中已经实现的方法，然后运行提供的main()和执行Lab1中的Junit测试用例，使之正常运行。3.2.1FriendshipGraph类(1).FriendshipGraph的字段为Person构成的ConcreteEdgesGraph，定义私有类型的表如下图所示： (2).在FriendshipGraph需要实现的方法如下图所示：FriendshipGraph构造方法addVertex在图中增加新Person，只需要调用ConcreteEdgesGraph中的add即可： addEdge为某个人增加朋友,a为这个人，b为增加的朋友,直接调用ConcreteEdgesGraph中的set即可： getallprople直接返回即可： getDistance遍历顶点以及其sources，根据广度优先算法，构建队列。将起点先加入队列，然后每次从队头弹出一个点，将其sources中还未在队列中的顶点压入队尾，直到遍历到终点。在这个过程中记录起点距每个点的距离即可。若直到队空也没有遍历到终点，则返回-1。00main复制Lab1的即可(3).AF,RI和Safetyfromrepexposure如下图： 3.2.2Person类(1).FriendshipGraph的字段为Person构成的ConcreteEdgesGraph，定义私有类型的表如下图所示： (2).在FriendshipGraph需要实现的方法如下图所示：Person没有重复名字则加入，构造方法getmyname返回本人名字，直接返回即可(3).AF,RI和Safetyfromrepexposure如下图： 3.2.3客户端main()复制Lab13.3中的main运行后如下： 3.2.4测试用例测试策略：与Lab1的测试策略相同： 测试结果： 检查覆盖率：(需要提前注释main()函数)： 3.2.4提交至Git仓库如何通过Git提交当前版本到GitHub上你的Lab2仓库。与提交P1相似 在这里给出你的项目的目录结构树状示意图。 4实验进度记录请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。日期时间段计划任务实际完成情况5.2513:00-22:30完成P1边图类完成5.2615：30-23：30完成P1点图类完成5.2815：30-20：00GraphPoet和poem未按计划完成5.2913：00-16：30Poem完成6.315：30-20：00修改完善测试用例完成6.414：30-19：30FriendshipGraph完成6.1015：30-16：00完善测试用例完成6.1113：00-16：00完善报告完成5实验过程中遇到的困难与解决途径遇到的难点解决途径换成泛型后很多警告 按照提示增加<> Git二次提交不太会使用git二次提交文件，所以重新增加master重新push6实验过程中收获的经验、教训、感想6.1实验过程中收获的经验和教训在自行设计多种类来实现功能的情况下，自己设计的很多类之间有很多重复和矛盾的部分，很多关系弄不清楚6.2针对以下方面的感受(1)面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？答：面向ADT需要考虑底层实现，而面向应用场景无需了解ADT如何实现各种功能，直接调用即可。 (2)使用泛型和不使用泛型的编程，对你来说有何差异？答：使用泛型应用范围更广，但设计的时候需要考虑不能应用某一类型内部的方法；不使用泛型应用范围窄，但设计时可以应用某一特定类型包装好的方法。 (3)在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？答：能够保证代码的正确性，及时修改。不适应。 (4)P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？答：可以提高代码的利用率，减少重复。 (5)P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？答：适应方式就是在应用场景时只考虑应用场景，“忘记”ADT内部的具体实现方式。自主实现感觉需要自己考虑的东西变多了。 (6)为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？答：保证程序的安全性和健壮性。可能很难坚持。 (7)关于本实验的工作量、难度、deadline。答：感觉工作量还挺多的。(8)《软件构造》课程进展到目前，你对该课程有何体会和建议？答：实验和课堂上的理论结合非常紧密。 
第364篇文章[]
HIT软件构造lab3心得 1实验目标概述本次实验覆盖课程第2、3章的内容，目标是编写具有可复用性和可维护性的软件，主要使用以下软件构造技术：子类型、泛型、多态、重写、重载继承、代理、组合语法驱动的编程、正则表达式API设计、API复用本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过ADT和泛型等抽象技术，开发一套可复用的ADT及其实现，充分考虑这些应用之间的相似性和差异性，使ADT有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。2实验环境配置Eclipse与git 在这里给出你的GitHubLab3仓库的URL地址（HIT-Lab3-学号）。https://github.com/ComputerScienceHIT/HIT-Lab3-11902020133实验过程请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。3.1待开发的三个应用场景3.1.1值班表管理要求：1、每天只有一个员工值班；2、不能出现某天无人值班的情况；3、任意两个员工值班时间不能重叠；4、记录员工值班日期、名字、职位、手机号码； 3.1.2操作系统进程调度管理要求：1、同一个进程可以在多个不同时间段内多次执行；2、多个进程执行时的时间段不可重叠；3、在特定时刻，时间轴上没有进程在执行，即“闲置”；4、操作系统对进程调度是随机的；3.1.3大学课表管理要求：1、课表中有多个课程排课；2、同一时间段可以有不同的课程（学生选课不同）3、同一课程每周可以出现一次，也可以安排多次；4、课表中允许有空白时间段（未安排任何课程）；5、同一课程由同一位老师在同一教室进行；6、一位老师可以承担课表中的多门课程；7、课表具有周期性（T=7days）； 三个应用的共性与差异：三个APP均与时间段有关，值班表要求一人只能对应一个时间段，进程与课表管理要求一个对象课可以对应多个时间段。在值班表和进程中，要求各个时间段不能重叠，而课表允许有重叠。在值班表中要求不能有空白的时间段，课表必须具有周期行等等。 3.2面向可复用性和可维护性的设计：IntervalSet该节是本实验的核心部分。3.2.1IntervalSet的共性操作1、IntervalSetempty()：创建一个空对象，返回创建的空对象；2、voidinsert(longstart,longend,Llabel)：插入新时间段，start,end分别表示开始时间和结束时间，label是时间段标签，当存在此标签或者时间段被占用时输出异常；3、Setlabels()：获得当前对象中标签集合4、booleanremove(Llabel)：从当前对象中移除某个标签label所关联的标签，若集合中没有找到指定标签则返回false，否则返回true，即成功移除；5、longstart(Llabel):返回标签label对应时间段的开始时间6、longend(Llabel)：返回标签label对应时间段的结束时间7、booleancheckLegal();检查当前程序的合法性8、voidclear():清空当前时间段集合中的所有时间段9、读取时间段集合链表LinkedList<Interval>readIntervalSet(); 3.2.2局部共性特征的设计方案采用报告3.4.2中的方案6使用decorator模式进行局部共性特征设计方案。定义一个装饰器抽象类Decorator继承自IntervalSet接口 下面设立多个子类分别继承自Decorator抽象类。三个局部共性特征为1、是否允许时间重叠2、是否允许时间段中有空隙3、是否允许时间循环呈周期变化可以看出这三个特征的区别在于插入方法和检查程序合法性两个方法上，因此在子类中分别对这两个函数进行重写即可 3.2.3面向各应用的IntervalSet子类型设计（个性化特征的设计方案）由于在值班表管理中要求n名员工的值班时间段必须相连，无空白时间段，所以DutyIntervalSet与之前设计的不允许时间冲突和不允许各个时间段中有空白时间段，和之前实现的子类功能高度重合，因此直接继承即可。noGapIntervalSet中增加了判断某个时间段中是否有循环或者空白时间段的方法booleancheckLegal()。该方法中将时间段集合链表LinkedList<Interval>中的时间段依次遍历，如果出现了当前遍历时间段开始时间大于上一个时间段的结束时间的情况，说明有空白，返回false，否则返回true。noOverlappingIntervalSet通过对insert函数进行重写，保证原集合内时间段之间不发生重叠。在每次加入新时间段时，判断新加入时间段与集合中原有所有时间段的位置关系。如果出现重合，则输出异常，否则可以加入原集合。 3.3面向可复用性和可维护性的设计：MultiIntervalSet3.3.1MultiIntervalSet的共性操作1、IntervalSetempty()：创建一个空对象，empty()或不带任何参数的构造函数，返回创建的空对象2、MultiIntervalSet(IntervalSetinitial)：创建一个非空对象，利用initial中包含的数据创建非空对象，返回创建的非空对象3、voidinsert(longstart,longend,Llabel):在当前对象中插入新的时间段和标签;4、Setlabels():获得当前对象中的标签集合：5、booleanremove(Llabel):从当前对象中移除某个标签所关联的所有时间段6、IntervalSetintervals(Llabel):从当前对象中获取与某个标签所关联的所有时间段：，返回结果表达为IntervalSet的形式，其中的时间段按开始时间从小到大的次序排列。7、getMap():返回当前的时间段集合8、booleancheckLegal():检查合法性9、清空当前的时间段集合3.3.2局部共性特征的设计方案针对multiIntervalSet同样面临着是否允许空隙，是否允许时间冲突，是否允许周期循环的三个问题，同样采用方案6的装饰器设计模式，重写multiIntervalSet的insert方法和checkLegal方法，设计出不同功能的子类。3.3.3面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）面对进程调度的应用设计一个ProcessIntervalSet，这个个性化特征为可以有空隙，但是时间不允许重叠，因此这个类继承自上面实现的无周期，不重叠，可以有间隙的装饰子类，因为需要设计成可视化，所以在这个子类中增加两个show方法，可以查看当前所有的进程调度，也可以查看单独的进程被调度的情况。面对课程表安排的应用设计一个CourseIntervalSet类，由于插入课程时希望通过星期几和开始上课的时间进行插入，因此在这个子类中需要增加能够将周数和开始上课的时间对应成时间段的开始时间和结束时间的方法，同时，这个课程表也需要可视化读入，所以增加一个获得具体星期的课表的方法。3.4面向复用的设计：L所有的ADT都采用泛型L，L必须是immutable类型的变量。如针对每个应用设计的类Employee、Process、Course等3.5可复用API设计将方法写在单独的APIs.java中，采用委派方式3.5.1计算相似度针对multiIntervalSet的计算相似度的方法，可以计算两个时间段集合的相似度。两个时间段集合的相似度是通过相似时间/总时间计算的，而相似时间则要求时间段和标签完全一样的时候才叫有效的相似时间。维护两个IntervalSet，标签使用Integer类型，然后将multi的时间段集合转换成普通的时间段集合，这样将每个时间段按照开始时间的先后顺序插入其中。这样还可以顺便计算出来两个时间段集合的最长持续时间是多少。然后通过for循环，遍历两个时间段集合的每个时间段，统计有效时间，由此计算出相似度结果。首先分析相似度的计算：我们以实验指导的例子为例：首先我们可以得出对于第一个MultiIntervalSet中标签A，其对应的区域有两个地方[0,5)和[20，25)，而在第二个MultiIntervalSet中标签A，其对应的区域有一个为[20,35)，而由于不同标签的相似度，只存在于相同的标签对应的时间段，因此我们可以计算出相似度。Similarratio=15/35=0.42857。在介绍方法前，首先简述求相似度的辅助函数：1.publicstaticlonggetStartTimerShaft(MultiIntervalSets)获得MultiIntervalSet的最早的时间2.publicstaticlonggetEndTimeShaft(MultiIntervalSets)获得MultiIntervalSet的最晚的时间3.publicstaticdoubleintervalLength(Sets1)计算s1中的所有时间段的时间的长度4.publicstaticSetsimilarIntervals(IntervalSets1,IntervalSets2)求s1与s2的重合时间段，其中参数为由MultiIntervalSet的label对应的多个Interval构成的Interval，Integer为从小到大的顺序。3.5.2计算时间冲突比例时间冲突比例应为计算一个MultiIntervalSet类型中所有labels对应的时间段存在重叠的部分。首先将所有的label映射到Boolean类型，即可认为当前是否已经遍历过该标签。初始化时候，将label对应的Boolean都设置为false。在循环MultiIntervalSet中所有标签时，依次将每一个设置为true，表示遍历完成。通过双层循环实现对label的遍历，在遍历一个标签时，若发现另一个标签与其相同或已访问过，则跳过，否则通过调用simlarIntervals函数和intervals函数，检查label标签对应的时间段与待检查标签中是否有相同的部分，若有，则累加，即为冲突时间。总时间通过对每一个label对应时间段求和即可得。冲突事件/总时间即为时间冲突比例。3.5.3计算空闲时间比例首先通过3.5.1中叙述的getStartTimerShaft(MultiIntervalSET)函数，获得MultiIntervalSet的最早的时间点，再通过getEndTimerShaft(MultiIntervalSET)函数，即可获得MultiIntervalSet的最晚的时间点。此时即可计算总的时间。首先将开头时间和结束时间放入Set中，即可得到此时对应的Interval的集合，开始时候，只有一个Interval，代表从头到结尾。通过对MultiIntervalSet中的labels遍历，依次得到每个label对应的时间段。当得到每个时间段后，将Set中的包含当前label对应的时间段的时间段拆分成，不包括不包括label的时间段的部分，并将原Interval删除，将新拆分的Intervals放入Set中，最后调用intervalLength函数，即可计算Set中的时间间隔的总长度。通过空闲时间/总时间即可计算出空闲时间比例。3.6应用设计与开发利用上述设计和实现的ADT，实现手册里要求的各项功能。3.6.1排班管理系统针对排班管理系统，所需完成的功能为：Step1设定排班开始日期、结束日期，具体到年月日即可。Step2增加一组员工，包括他们各自的姓名、职务、手机号码，并可随时删除某些员工。如果某个员工已经被编排进排班表，那么他不能被删除，必须将其排班信息删掉之后才能删除该员工。员工信息一旦设定则无法修改。Step3可手工选择某个员工、某个时间段（以“日”为单位，最小1天，可以是多天），向排班表增加一条排班记录，该步骤可重复执行多次。在该过程中，用户可随时检查当前排班是否已满（即所有时间段都已被安排了特定员工值班）、若未满，则展示给用户哪些时间段未安排、未安排的时间段占总时间段的比例。Step4除了上一步骤中手工安排，也可采用自动编排的方法，随机生成排班表。Step5可视化展示任意时刻的排班表。可视化要直观明了，可自行设计。其中step4的自动编排方法秉持着平均的原则，计算出一共要安排多少天，然后用天数除以员工数量，再最后处理剩余的没有安排上的部分，从而完成自动的安排。如果在自动安排之前已经手动插入了一些安排，那么就清空列表后再进行自动编排3.6.2操作系统的进程调度管理系统针对操作系统的进程调度管理系统，所需完成的功能为：Step1增加一组进程，输入每个进程的ID、名称、最短执行时间、最长执行时间；进程一旦设定无法再修改其信息。Step2当前时刻（设定为0）启动模拟调度，随机选择某个尚未执行结束的进程在CPU上执行（执行过程中其他进程不能被执行），并在该进程最大时间之前的任意时刻停止执行，如果本次及其之前的累积执行时间已落到[最短执行时间，最长执行时间]的区间内，则该进程被设定为“执行结束”。重复上述过程，直到所有进程都达到“执行结束”状态。在每次选择时，也可“不执行任何进程”，并在后续随机选定的时间点再次进行进程选择。Step3上一步骤是“随机选择进程”的模拟策略，还可以实现“最短进程优先”的模拟策略：每次选择进程的时候，优先选择距离其最大执行时间差距最小的进程。Step4可视化展示当前时刻之前的进程调度结果，以及当前时刻正在执行的进程。可视化的形式要直观明了，可自行设计。添加一组进程后，可以启动系统模拟进程调度。进程调度有两种调度策略，一个是随机调度，一个是最短进程优先策略。在这里都采取随机数的方式进行随机调度，同时加入无进程的情况。在随机进程选择中采用平均随机，即每次从未完成的进程中选择一个，并执行随机数的时间，然后进行下一次随机选择进程，直到所有进程都达到执行时间为止。而最短进程优先策略则增加随机数的产生范围，多余的随机数都指向最短时间的进程，这样最短时间的进程就会被更容易调度。欢迎界面 输入1 功能为添加进程。 输入2 输入5 3.6.3课表管理系统针对课表管理系统，所需完成的功能为：Step1设定学期开始日期（年月日）和总周数（例如18）；Step2增加一组课程，每门课程的信息包括：课程ID、课程名称、教师名字、地点、周学时数（偶数）；Step3手工选择某个课程、上课时间（只能是8-10时、10-12时、13-15时、15-17时、19-21时），为其安排一次课，每次课的时间长度为2小时；可重复安排，直到达到周学时数目时该课程不能再安排；Step4上步骤过程中，随时可查看哪些课程没安排、当前每周的空闲时间比例、重复时间比例；Step5因为课程是周期性的，用户可查看本学期内任意一天的课表结果。每次课的时间长度为2小时，且只有固定的几个时间段可以上课，因此可以根据星期几和上课的开始时间确定唯一的上课时间，在此通过一个转换即可做到。将weekday*24再加上开始上课的时间，就能确定唯一的上课时间。简要分析，我们需要一个一个标签对应多个时间段的数据类型，因此选择MultiIntervalSet类型。CourseScheduleApp运行如下：课表目录 更新课表信息 添加课程 设置课程上课时间 查看未安排的课程 查看设置完成的课程 3.7基于语法的数据读入修改“排班管理”应用以扩展该功能。该模块主要采用正则表达式处理从文件中读入的字符串。根据提供的文件的格式确定正则表达式，然后通过正则表达式的语法获取每一行的信息。用每一个正则表达式去匹配每一行，如果匹配上了就获取相应的信息进行处理即可。 在匹配确认格式匹配后，将所读入的内容转化为值班表。具体运行结果如下：当读入test1.txt时，具体运行结果如下所示： 3.8应对面临的新变化3.8.1变化1代价并不大。只需将值班表中使用的没有空时间段改为允许有空隙，并修改查看排版信息的遍历时所用到的intervalset中的函数（start,end），变为multi-intervalset中的函数（intervals）即可。同时，由于一个员工可以占据多段时间，随机排班的功能也需要进行修改。新的排版方式是对每一天进行遍历，每一天都随机选择一个员工。3.8.2变化2代价很小。只需要再套一层NoOverlapIntervalSet的装饰器就足以应对变化。3.9Git仓库结构请在完成全部实验要求之后，利用Gitlog指令或Git图形化客户端或GitHub上项目仓库的Insight页面，给出你的仓库到目前为止的ObjectGraph，尤其是区分清楚change分支和master分支所指向的位置。 4实验进度记录请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。日期时间段计划任务实际完成情况2021.06.2710:00-20:00完成IntervalSet接口和CommonIntervalSet实例按时完成2021.06.2813:00-15:00重构CommonIntervalSet代码按时完成2021.06.2816：00-19：00完成MultiIntervalSet接口和Common实例未完成2021.06.2821：00-23：00完成MultiIntervalSet接口和Common实例按时完成2021.06.299：00-13：00完成dutyIntervalSet设计和值班表app未完成2021.06.2915：00-19：00完成dutyIntervalSet设计和值班表app按时完成2021.06.307：00-13：00完成装饰类的书写按时完成2021.06.3015：00-23：00完成具体类的书写并实现进程调度按时完成2021.07.017：00-15：00完成课程表安排和APIs类按时完成2021.07.027：00-16：00完成应对变化及代价按时完成2021.07.037：00-18;00完成报告按时完成5实验过程中遇到的困难与解决途径遇到的难点解决途径 产生随机数不会网络搜索 如何对日期进行处理网络搜索，了解了Date等方法可以进行日期运算6实验过程中收获的经验、教训、感想6.1实验过程中收获的经验和教训对代码复用的体会更加深刻了6.2针对以下方面的感受(1)重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用，你是否体会到复用的好处？ 复用在一定程度上增加了代码的难度，但另一方面复用大量的减少了代码量。复用更考察了抽象能力，将不同的场景的共同点抽象成抽象ADT。 (2)重新思考Lab2中的问题：为ADT撰写复杂的specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？保证了正确性与安全性，并将一直坚持。 (3)之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？开发API难处体会比较深刻，乐趣没有难处深刻。 (4)你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？匹配过程更加实用。 (5)Lab1和Lab2的工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过三周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？抽象出相同的地方，勤于思考。 (6)“抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的三个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、委派、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？先写接口考虑好应用场景，并写测试，进而不断完善代码。 (7)关于本实验的工作量、难度、deadline。工作量过大、难度过大、deadline过紧。 (8)下周就要进行考试了，你对《软件构造》课程总体评价如何？对我编程起到了很大的作用，让我了解到如何编出更好的代码。 
第365篇文章[]
HIT软件构造笔记一 软件构造复习笔记一1.1软件构造过程中的多维度视图1、多维度视图 (1)Build-time,moment,andcode-levelview关注的是源码的组织情况，可在词汇（源码）、语法（抽象语法树）、语义（类图）三个层面分别分析。 (2)Build-time,period,andcode-levelview关注的是代码的变化（Codechurn代码变化） (3)Build-time,moment,andcomponent-levelview关注的是包/库，而且是静态链接库 (4)Build-time,period,andcomponent-levelview关注代码的更迭，与(2)中不同的是，这个维度下更关注文件版本的变化，而不是具体语句的变化（2中关注的是哪一行代码被修改了） (5)Run-time,moment,andcode-levelview关注的是程序在某个时间点内存中的情况，如代码快照图(CodeSnapshot)、内存信息转储(Memorydump)。 (6)Run-time,periodandcode-levelview关注的是代码的执行情况，执行跟踪 (7)Run-time,moment,andcomponent-levelview关注的也是包/库，但却是在代码执行过程中的情况，如动态链接库 (8)Run-time,period,andcomponent-levelview关注的是系统的使用情况，使用日志查看2、视图之间的联系代码是一个从无到有的过程，也就空集->Code，而有了代码之后程序必定会随着代码行的增加而逐步完善，最后被封装，也就是Code->Component这个过程。当程序构建成功后需要运行，也就是Build-time->Run-time，最后我们还可能需要多次修改调整程序，或者记录程序版本变化，也就需要Moment->Period维度的转变。 1.2QualityObjectivesofSoftwareConstruction 软件系统的质量外部质量因素（1）正确性正确性是软件产品能够正确的执行任务的能力，是首要的质量目标。保证正确性的途径是有条件的。一个软件系统设计多个层面，所以不可能仅仅靠每个构件和属性的正确性来保证整体的正确性，各层之间是相互依赖的。 （2）健壮性健壮性是软件系统对异常情况做出适当反应的能力。健壮性补充了正确性。正确性解决了系统在其规范所涵盖的情况下的行为；健壮性描述了在该规范之外发生的事情。健壮性是确保如果出现此类情况，系统不会导致灾难性事件；它应生成适当的错误消息，干净地终止执行，或进入所谓的“优雅降级”模式。健壮性同异常情况相关，异常或非异常取决于程序的规格说明，异常情况是程序的规格说明中没有涉及的部分。判断是否异常是异常的标准，不取决于客观的正确标准，而取决于程序的规格说明。 （3）可扩展性可扩展性是指软件易于调整以适应变化的能力。可扩展性同规模密切相关，越大越难以扩展。软件是易变的，需要可扩展性。传统方法最初冻结需求，假设没有变化，因此难以适应变化两个提高可扩展性的原则：简单的体系结构总是比复杂的体系更容易适应变化。模块自治性越强，变化时对其余模块影响越小。 （4）重用性软件经常遇到相似的模式，利用共性，避免重复实现。 （5）兼容性兼容性是指软件元素易于与其他的组合。因为我们的软件并非运行在真空中，但难点在于不同的软件有不同的设定。所以，解决兼容性的关键是标准性，例如规定文件格式、数据结构、用户接口等。更通用的方法是通过协议来实现更通用的兼容性。 （6）效率效率是软件系统对硬件资源尽可能少的需求的能力，但前提是软件的正确性，并且需要与其他目标进行权衡。 （7）可移植性可移植性是指便于将软件产品转移到各种硬件和软件环境。 （8）易用性用户可以轻松掌握软件的使用，也包括安装、运行和监控的容易度。既方便初学者入门，也不影响熟练的用户直接使用。一个关键是结构要简洁，理解用户，换位思考，站在用户的角度设计软件。 （9）功能性增加功能的同时也要防止陷入“蠕变特性”，即程序设计中一种不适宜的趋势，即软件开发者增加越来越多的功能，企图跟上竞争，其结果是程序极为复杂、不灵活、占用过多的磁盘空间。过多的新功能容易带来一致性的缺失，影响易用性。在质量提升技术的帮助下，可以在整个项目中保持质量水平不变，而不仅仅是功能性。 （10）及时性及时性是指软件系统能够在用户需要时或者需要需要之前发布 内部质量因素圈复杂度：用来衡量一个模块判定结构的复杂程度。耦合度：设计中追求高内聚和低耦合。可读性、易理解性、清晰度、复杂度、体积内部质量因素通常用作外部质量因素的部分度量。 正确性是绝不能与其他质量因素折中的！！！ 
第366篇文章[1]
程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190202026 班 级 1936601 学 生 周俣生 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文详细分析分析了C语言程序hello.c在Ubuntu下的执行过程，主要介绍了hello.c的预处理、编译、汇编、链接、进程管理、存储管理以及I/O管理。 通过跟踪hello程序的执行过程，带我们认识了计算机系统的工作方式。 关键词：预处理；编译；汇编；链接；进程；I/O；虚拟内存 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 程序员利用C语言编写了C程序hello.c，经过预处理、编译、汇编、链接，生成了可执行文件：hello。 在Bash中输入命令，OS进程管理为hello程序fork进程，调用execve加载，为进程mmap，分时间片，让hello程序得以在Hardware(CPU/RAM/IO)上执行（取指译码执行/流水线等）。 OS（存储管理）与MMU为hello程序翻译从VA到PA；TLB、4级页表、3级Cache，Pagefile等等为hello程序加速；IO管理与信号处理，软硬结合，才使hello程序最终在屏幕上显示。 Bash在运行结束后回收了进程。 O2O:FromZero-0toZero-0。 P2P:FromProgramtoProcess 1.2环境与工具 1.硬件环境： Win10_64位 处理器：Intel(R)Core(TM)i7-9750HCPU@2.60GHz 2.59GHz 机带RAM：8.00GB 2.软件环境： Windows10、Ubuntu 3.开发工具 EDB、GDB、VIM、Objdump、readelf 1.3中间结果 hello.c：C语言程序 hello.i：C语言程序hello.c预处理后得到的新的C程序 hello.s：将hello.c编译后得到汇编语言文本文件 hello.o：将hello.c汇编后得到的机器语言指令的可重定位目标程序 hello：将hello.o链接后得到的可执行文件 elf.txt：hello.o的ELF文件 elf1.txt：hello的ELF文件 hello.txt：hello.o反汇编后得到的汇编语言代码 hello1.txt：hello反汇编后得到的汇编语言代码 1.4本章小结 本章系统的介绍了hello程序P2P，020的过程。给出了本次实验的系统环境以及所使用的工具，并列出了实验过程中所产生的中间文件。 第2章预处理 2.1预处理的概念与作用 概念： 预处理是指在程序源代码被编译之前，由预处理器对程序源代码进行的处理。这个过程并不对程序的源代码进行解释，但它把源代码分割或处理成为特定的符号用来支持宏调调用。在C语言源程序中可以加入一些预处理命令，以改进程序设计环境，提高编程效率，这些预处理伪字符是统一规定的，但是它们不是C语言本身的组成部分，不能直接对它们进行编译。 C提供的预处理命令功能主要有以下3种： （1）宏定义 （2）文件包含 （3）条件编译 分别用宏定义伪命令，文件包含命令，条件编译命令来实现，为了与一般C语句相区别，这些命令以符号#开头。 2.2在Ubuntu下预处理的命令 cpphello.chello.i gcc-Ehello.c-ohello.i 图2.1Ubuntu下预处理命令 2.3Hello的预处理结果解析 使用命令cpp-Ehello.c，在终端查看预处理结果。 或者打开hello.i，直接在文本中查看。 图2.2Ubuntu下预处理结果 预处理命令的功能主要有三种（1）宏定义（2）文件包含（3）条件编译。 hello.c文件中共有三条预处理指令： 图2.3hello.c头文件 预处理器读取系统头文件的内容，然后将它们直接插入程序文本中。 从hello.i文本中可以看到stdio.h的位置在/usr/include中，我们在/usr/include中利用ls命令查看文件。 图2.4/usr/include下的文件 2.4本章小结 在C语言程序中加入一些预处理命令，以改进程序设计环境，提高编程效率，这此预处理伪字符是统一规定的，但它不是C语言本身的组成部分，不能直接对它们进行编译。预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。结果就得到了另一个C程序，通常是以.i作为文件扩展名。 第3章编译 3.1编译的概念与作用 编译是编译器将预处理文本翻译为汇编文本的过程。 编译器是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序。编译器（ccl）将文本文件hello.i翻译成hello.s，它包含一个汇编语言程序。该程序包含函数main的定义。 3.2在Ubuntu下编译的命令 gcc-Shello.c-ohello.s 图3.1Ubuntu下编译命令 3.3Hello的编译结果解析 3.3.1 在hello.c中定义了int型全局变量sleepsecs。 图3.2hello.c中定义的全局变量 在程序中被声明为long类型的全局变量，并为其分配四个字节的空间。 图3.3编译结果 将sleepsecs赋值为2。 图3.4编译结果 在复制过程中有一次隐式类型转换。 从float或者double转换成int,值将会向零舍人。例如,1.999将被转换成1,而-1.999将被转换成-1。进一步来说,值可能会溢出。C语言标准没有对这种情况指定固定的结果。与Intel兼容的微处理器指定位模式[10⋯00]为整数不确定值。一个从浮点数到整数的转换,如果不能为该浮点数找到一个合理的整数近似值,就会产生这样一个值。因此,表达式(int)+1e10会得到-21483648,即从一个正值变成了一个负值。 3.3.2 在hello.c中定义了int型局部变量i。 编译器将局部变量存储在寄存器或栈空间中。在hello.s中编译器将局部变量i存放在栈空间%rbx中。 图3.5编译结果 将i赋值为0。 图3.6编译结果 3.3.3 在hello.c中共有两条print语句。 图3.7hello.c中的print语句 在hello.s中分别将两条字符串存储在.LC0中和.LC1中。 图3.8编译结果 3.3.4 在hello.c中有一条条件语句。 图3.9hello.c中的if语句 编译器将argc放在寄存器%edi中。如果%edi中的值不等于3，则跳转到.L6。 图3.10编译结果 加载字符串.LC0的地址。调用printf函数打印字符串。 将立即数1写入寄存器%edi，调用exit（）函数。 图3.11编译结果 3.3.5 在hello.c中有for循环语句。 图3.12hello.c中的for语句 用寄存器%ebx保存局部变量i，赋值为0，然后跳转到.L2。 图3.13编译结果 如果寄存器%ebx中的值（i）小于等于9，则跳转到.L3。进入循环内部。 图3.14编译结果 将16（%rbp）中的参数argv[1]写入%rcx，将8（%rbp）中的参数argv[2]写入%rdx，加载字符串.LC1的地址到%rsi。调用printf函数。将sleepsecs赋值给%edi，作为参数传递给sleep函数。将%edi（i）加1。 图3.15编译结果 3.3.6 汇编语言中的寻址模式。 图3.16汇编语言中的寻址模式 参数argv[1]，argv[2]存放的地址分别16（%rbp）和8（%rbp）。 图3.17编译结果 3.3.7 C语言的算术操作对应的汇编语言。 图3.18C语言的算术操作对应的汇编语言 3.4本章小结 本章节主要结合了C语言中的各种数据类型，各种运算以及各种函数操作，逐个分析了编译器产生的汇编代码，介绍了编译器是如何处理C语言程序的。 在编译阶段，编译器将高级语言编译成汇编语言。汇编语言不具有可移植性，是直接面向处理器的语言，是机器指令的一种符号表示，不同类型的计算机系统有不同的机器指令系统，也就有不同的汇编语言。 第4章汇编 4.1汇编的概念与作用 汇编是将汇编语言翻译为机器语言的过程。 汇编器（as）将hello.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。 4.2在Ubuntu下汇编的命令 ashello.s-ohello.o 4.1Ubuntu下汇编命令 4.3可重定位目标elf格式 用readelf-ahello.o>elf.txt生成hello.o的ELF文件。 4.2Ubuntu下生成ELF文件命令 ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节序列。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。 图4.3ELF头 共13个节头。 图4.4节头 图4.5重定位节信息 可知，需要重定位的信息有.LC0，puts，exit，.LC1，__printf_chk，sleepsecs，sleep，stdin，和_IO_getc。 4.4Hello.o的结果解析 输入命令objdump-d-rhello.o>hello.txt，获得hello.o的反汇编代码，保存在hello.txt文件中。 图4.6反汇编hello.o命令 打开hello.txt，查看反汇编代码。 图4.7反汇编代码hello.txt 图4.8hello.s 机器语言完全由二进制0、1构成，在这里的反汇编代码中，以16进制格式显示。两个16进制数组成一个字节编码，表示一个运算符或者操作数。 将hello.o反汇编后得到的代码与hello.s大体相同，存在部分差异： 在反汇编得到的代码中，跳转指令后跟着的是地址，而在hello.s中，跳转指令后跟着的是.L2、.L3这样的代码段标签。在反汇编得到的代码中，call后面跟随的地址是相对地址，而在hello.s中，call后面跟随的是函数名。 4.5本章小结 本章节介绍了汇编过程，汇编器将hello.s汇编得到hello.o，查看了hello.o的ELF。使用objdump工具对hello.o进行了反汇编，得到了反汇编代码，并与之前得到的hello.s进行比较。通过观察二者之间的异同，了解分析汇编器将汇编语言翻译到机器语言的这一过程。 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序自动执行的。 5.2在Ubuntu下链接的命令 在终端中输入链接命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1Ubuntu下链接命令 5.3可执行目标文件hello的格式 用readelf工具，将hello的ELF文件保存在elf1.txt中。 输入命令：readelf-ahello>elf1.txt 查看ELF头信息： 图5.2ELF头信息 节头部表包含了hello中的每一个节，包含了名称、类型、地址、偏移量、大小、全体大小、旗标、链接、信息、对齐。 节头： 图5.3节头信息 5.4hello的虚拟地址空间 使用edb加载hello。 图5.4edb下打开hello 图5.5在节头部表中的信息 图5.6在edb中查看的节头部表的信息 5.5链接的重定位过程分析 objdump-d-rhello>hello1.txt 图5.7反汇编命令 打开hello1.txt，查看hello的反汇编代码。 图5.8hello反汇编代码 在使用ld命令链接的时候,指定了动态链接器为/lib64/ld-linux-x86-64.so.2，_start程序调用hello.c中的main函数，libc.so是动态链接共享库，其中定义了hello.c中用到的printf、sleep、getchar、exit函数和_start中调用的__libc_csu_init，__libc_csu_fini，__libc_start_main。链接器将上述函数加入。 链接器将所有R_X86_64_PC32和R_X86_64_PLT32换成计算好的地址。 以sleepsecs为例： 图5.9反汇编代码 相应的重定位条目r由4个字段组成： r.offset=0x4b; r.symbol=sleepsecs; r.type=R_X86_64_PC32; r.addend=-4; R_X86_64_PC32重定位算法如下： 图5.10R_X86_64_PC32重定位算法 refaddr=0x4005a2+0x4b=0x4005ed *refptr=(unsigned)(ADDR(r.sleepsecs)+r.addend-refaddr)=0x601044+(-0x4)-0x4005ed=(unsigned)0x200a53 图5.11反汇编代码 5.6hello的执行流程 0x7f4355798061 ld-2.27.so!oom 0x7f4355798090 ld-2.27.so!_start 0x7f4355798098 ld-2.27.so!_dl_start_user 0x7f43557980e0 ld-2.27.so!rtld_lock_default_lock_recursive 0x7f43557980f0 ld-2.27.so!rtld_lock_default_unlock_recursive 0x7f4355798100 ld-2.27.so!lookup_doit 0x7f4355798160 ld-2.27.so!dlmopen_doit 0x7f43557981b0 ld-2.27.so!print_unresolved 0x7f43557981f0 ld-2.27.so!print_missing_version 0x7f4355798230 ld-2.27.so!do_preload 0x7f43557982e0 ld-2.27.so!map_doit 0x7f4355798ea0 ld-2.27.so!_dl_start 0x4004f0 hello!_init 0x400520 hello!puts@plt 0x400530 hello!_IO_getc@plt 0x400540 hello!__printf_chk@plt 0x400550 hello!exit@plt 0x400560 hello!sleep@plt 0x400570 hello!_start 0x4005a0 hello!_dl_relocate_static_pie 0x4005a2 hello!main 0x400620 hello!__libc_csu_init 0x400690 hello!__libc_csu_fini 0x400694 hello!_fini 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 动态链接器使用过程链接表PLT+全局偏移量表GOT实现函数的动态链接，GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。下面是程序在run前后的（即执行dl_init函数前后）的GOT表变化情况。 图5.12节头部表 0x600000处偏移0x1000个字节，起始位置为0x601000。 图5.13edb中查看 运行完成dl_init之后。 图5.14edb中查看 5.8本章小结 本章介绍了链接的概念、作用、可执行目标文件hello的格式、hello的虚拟地址空间、链接的重定位过程分析、hello的执行流程以及hello的动态链接分析。 链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 进程给应用程序提供两个关键的抽象： 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 shell是一个交互型应用级程序，代表用户运行其他程序。是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。 其基本功能是解释并运行用户的指令，重复如下处理过程： (1)终端进程读取用户由键盘输入的命令行。 (2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量 (3)检查第一个命令行参数是否是一个内置的shell命令 (4)如果不是内部命令，调用fork()创建子进程 (5)在子进程中，用步骤2获取的参数，调用execve()执行指定程序。 (6)如果用户没要求后台运行(命令末尾没有&号）则shell使用waitpid（或wait)等待作业终止后返回。 (7)如果用户要求后台运行(如果命令末尾有&号），则shell返回。 6.3Hello的fork进程创建过程 在终端中输入命令./hello1190202026zys。 shell首先对命令进行解析，判断它是否是一个内置的shell命令。然后发现这并不是一个内置命令，而是当前目录下的一个可执行目标文件。然后调用fork函数为hello创建一个子进程。 新创建的子进程几乎但不完全与父进程相同：子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本，子进程获得与父进程任何打开文件描述符相同的副本，子进程有不同于父进程的PID。 图6.1hello进程图 6.4Hello的execve过程 execve函数加载并运行可执行目标文件filename，且带参数列表和环境变量列表envp。只有当出现错误时，例如找不到filename时，execve才会返回到调用程序。与fork一次调用返回两次不同，execve调用一次并从不返回。 图6.2execve函数 当shell为hello创建了一个子进程之后，得到的子进程与父进程几乎相同。fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。此时调用execve函数，在当前进程的上下文中加载并运行hello。它会覆盖当前进程的地址空间，但并没有创建一个新的进程。此时的新的进程仍有与原先相同的PID，并且继承了调用execve函数时已打开的所有文件描述符。 6.5Hello的进程执行 处理器提供了一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常用某个控制寄存器中的一个模式位来提供这种功能，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中。一个运行在内核模式中的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令，比如停止处理器、改变模式位，或者发起一个I/O操作。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度，是由内核中成为调度器的代码处理的。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种成为上下文切换的机制来控制转移到新的进程： 1）保存当前进程的上下文 2）恢复某个先前被抢占的进程被保存的上下文 3）将控制传递给这个新恢复发进程 当hello调用sleep函数时，它显示地请求了让进程休眠。此时，hello进程被挂起，从运行队列加入等待队列，定时器开始计时2s。调度器通过上下文切换，重新开始一个之前被抢占了的进程。当sleep调用完毕的时候，会发送一个中断信号，此时内核将当前进程挂起（或终止）并返回到hello进程。 图6.3上下文切换 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 图6.4hello正常运行过程 图6.5运行过程中按下回车 在运行过程中按下回车不影响进程输出，不会让进程终止或挂起。 图6.6运行过程中按下Ctrl-Z 运行过程中按下Ctrl-Z后，显示进程已停止（挂起）。 图6.7按下Ctrl-Z后执行ps 按下Ctrl-Z后执行ps命令，可以看到hello进程并没有结束。 图6.8按下Ctrl-Z后执行jobs 按下Ctrl-Z后执行jobs命令，查看hello和jid。 图6.9（1）按下Ctrl-Z后执行pstree 图6.9（2）按下Ctrl-Z后执行pstree 按下Ctrl-Z后执行pstree命令，以树状图结构显示进程之间的关系。输入pstree-p21808（bash进程的PID），以bash进程为根节点查看。 图6.10按下Ctrl-Z后执行fg 按下Ctrl-Z后执行fg命令，继续执行hello程序，继续输出没有输出的内容。 图6.11按下Ctrl-Z后执行kill 按下Ctrl-Z后执行kill命令，杀死hello进程。输入ps命令查看，可以看到hello进程显示已杀死。 图6.12按下Ctrl-C 按下Ctrl-C后，发现进程立即结束了。输入ps命令，可以看到hello进程已经终止。 进程运行时按下Ctrl-Z，对应的是shell接收到SIGTSTP信号，默认情况是停止（挂起）前台作业，而Ctrl-C会导致内核发送一个SIGINT信号，默认情况是终止前台作业。 图6.13部分信号及相应事件 6.7本章小结 本章节介绍了进程的概念与作用，介绍了shell的作用与处理流程，分析了shell如何调用fork创建进程以及如何调用execve执行hello进程。结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等，分析了hello的进程执行过程。通过在shell中执行各种命令操作，分析了hello的异常与信号处理。 异常控制流发生在计算机系统的各个层次。在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。一个一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：又称相对地址。由段地址加上偏移地址构成，它是描述一个程序运行段的地址。 线性地址：是经过段机制转化之后用于描述程序分页信息的地址。它是对程序运行区块的一个抽象映射。 虚拟地址：虚拟地址跟线性地址相同，都是对程序运行区块的相对映射。 物理地址：程序运行时加载到内存地址寄存器中的地址，内存单元的真正地址。它是在前端总线上传输的而且是唯一的。物理地址中很大一部分是留给内存条中的内存的，但也常被映射到其他存储器上。 在没有使用虚拟存储器的机器上，虚拟地址被直接送到内存总线上，使具有相同地址的物理存储器被读写；而在使用了虚拟存储器的情况下，虚拟地址不是被直接送到内存地址总线上，而是送到存储器管理单元MMU，把虚拟地址映射为物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部分构成，段标识符和段内偏移量。段标识符是由一个16位长的字段组成，成为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节。 一些全局的段描述符，就放在“全局段描述符表（GDT）”中；一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表（LDT）”中。什么时候使用GDT，什么时候使用LDT中是由段选择符中的TI字段表示的。 7.3Hello的线性地址到物理地址的变换-页式管理 CPU的页式内存管理单元负责把一个线性地址转换为物理地址。从管理和效率的角度出发，线性地址被划分成固定长度单位的数组，称为页。例如，一个32位的机器，线性地址可以达到4G，用4KB为一个页来划分，这样，整个线性地址就被划分为一个2^20次方的的大数组，共有2的20次方个页，也就是1M个页，我们称之为页表，该页表中每一项存储的都是物理页的基地址。 类似地，物理内存也被分割为物理页（PP），是分页单元将所有的物理内存都划分成了固定大小的单元为管理单位，其大小一般与内存页大小一致。 图7.1地址翻译符合小结 CPU中的一个控制寄存器，页表基址寄存器（PTBR）指向当前页表。N位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。MMU利用VPN来选择适当的PTE。当页表条目中的物理页号（PPN）和虚拟地址中的VPO串联起来，就得到相印的物理地址。注意，因为物理和虚拟页面都是P字节的，所以物理页面偏移（PPO）和VPO是相同的。 图7.2使用页表的地址翻译 当页面命中时，CPU的执行步骤： 1.处理器生成一个虚拟地址，并把它传送给MMU。 2.MMU生成PTE地址，并从高速缓存/主存请求得到它。 3.高速缓存/主存向MMU返回PTE。 4.MMU构造物理地址，并把它传送给高速缓存/主存。 5.高速缓存/主存返回所请求的数据字给处理器。 图7.3页面命中的操作图 页面命中完全是由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成。 1~3.和页面命中的第1步到第3步相同。 4.PTE中的有效位是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。 5.缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。 6.缺页处理程序页面调入新的页面，并更新内存中的PTE。 7.缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中。 图7.4缺页的操作图 7.4TLB与四级页表支持下的VA到PA的变换 翻译后备缓冲器（TLB）是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单一PTE组成的块。TLB通常有高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有T=2^t个组，那么TLB索引（TLBI）是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。 36位VPN被划分成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 图7.5虚拟地址中用以访问TLB的组成部分 图7.6Corei7页表翻译 优化地址翻译： 在对地址翻译的讨论中，我们描述了一个顺序的两个步骤的过程 1)MMU将虚拟地址翻译成物理地址 2)将物理地址传送到L1高速缓存 然而，实际的硬件实现使用了一个灵活的技巧，允许这些步骤部分重叠，因此也就加速了对L1高速缓存的访问。例如,页面大小为4KB的Corei7系统上的一个虚拟地址有12位的VPO，并且这些位和相应物理地址中的PPO的12位是相同的。因为八路组相联的、物理寻址的L1高速缓存有64个组和大小为64字节的缓存块，每个物理地址有6个（log264）缓存偏移位和6个（log264）索引位。这12位恰好符合虚拟地址的VPO部分，这绝不是偶然！当CPU需要翻译一个虚拟地址时，它就发送VPN到MMU，发送VPO到高速L1缓存。当MMU向TLB请求一个页表条目时，L1高速缓存正忙着利用VPO位查找相应的组，并读出这个组里的个标记和相应的数据字。当MMU从TLB得到PPN时，缓存已经准备好试着把这个PPN与这8个标记中的一个进行匹配了。 7.5三级Cache支持下的物理内存访问 获得了物理地址VA之后，使用CI进行组索引，每组8路，对8路的块分别匹配CT，如果匹配成功且块的valid标志位为1，则命中，根据数据偏移量CO取出数据返回。 如果没有匹配成功或者匹配成功但是标志位不是1，则不命中，向下一级缓存中查询数据（L2Cache、L3Cache、主存）。查询到数据之后，一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突，则采用最近最少使用策略LFU进行替换。也就是替换掉最不经常访问的一次数据。 7.6hello进程fork时的内存映射 当shell调用fork函数时，内核为新进程hello创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在进程hello中返回时，进程hello现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。映射私有区域。为新的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。映射共享区域。如果hello程序与共享对象（或目标）链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。设置程序计数器。execve做的最后一件事就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 图7.7加载器是如何映射用户地址空间的区域的 7.8缺页故障与缺页中断处理 处理缺页要求硬件和操作系统内核协作完成： 处理器生成一个虚拟地址，并把它传送给MMU。MMU生成PTE地址，并从高速缓存/主存请求得到它。高速缓存/主存向MMU返回PTE。PTE中的有效位是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。缺页处理程序页面调入新的页面，并更新内存中的PTE。缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器:要求应用显式地释放任何已分配的快。例如，C语言中的malloc和free。 隐式分配器:应用检测到已分配块不再被程序所使用，就释放这个块。比如Java，ML和Lisp等高级语言中的垃圾收集。 隐式空闲链表： 图7.8一个简单的堆块的格式 一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小，以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是零。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。 图7.9用隐式空闲链表来组织堆 、 图7.10使用边界标记的堆块的格式 在隐式空闲链表堆块的基础上，在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离，这样就允许在常数时间内进行对前面块的合并。 释放当前块的所有可能的情况： 前面的块和后面的块都是已分配的前面的块是已分配的，后面的块是空闲的前面的块是空闲的，后面的块是已分配的前面的和后面的块都是空闲的 显示空闲链表 一种更好的方法是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个前驱和后继指针。 图7.11使用双向空闲链表的堆块的格式 释放一个块的时间可以是线性的，也可能是个常数。 一种方法是用先进后出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址顺序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 7.10本章小结 本章主要介绍了hello的存储器地址空间、Intel的段式管理与页式管理、TLB与四级页表支持下的VA到PA的变换、三级Cache支持下的物理内存访问、hello进程fork时的内存映射、hello进程execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理等内容。 理解虚拟内存将帮助程序员更好地理解系统是如何工作的，理解虚拟内存将帮助程序员利用虚拟内存的强大功能在应用程序中添加动力，理解虚拟内存以及诸如malloc之类的管理虚拟内存的分配程序，可以帮助程序员避免很多错误。 理解存储器层次结构，因为它对应用程序的性能有着巨大的影响。如果我们的程序需要的数据是存储在CPU寄存器中的，那么在指令的执行期间，在0个周期内就能访问到它们。如果存储在高速缓存中，需要4~75个周期。如果存储在主存中，需要上百个周期。而如果存储在磁盘上，需要大约几千万个周期。理解存储器层次结构，对于我们以后编写一些运行速度更快的代码十分重要。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 一个Linux文件就是一个m个字节的序列： B0，B1，…，Bk，…，Bm-1 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行，这种方式称为UnixI/O接口。 8.2简述UnixIO接口及其函数 UnixI/O接口： 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访间一个I/O设备。内核返回一个小的非负整数，叫做描述，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： 打开和关闭文件： 打开文件 进程是通过调用open函数来打开一个已经存在的文件或者创建一个新文件的。 open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件： O_RDONLY：只读 O_WRONLY：只写 O_RDWR：读写 图8.1open函数 关闭文件 进程通过调用close函数关闭一个打开的文件。 图8.2close函数 读和写文件 read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。下图展示了一个程序使用read和write调用一次一个字节地从标准输入复制到标准输出。返回：若成功则为写的字节数。若出错则为-1。 图8.3read函数、write函数 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 研究printf的实现，首先来看看printf函数的函数体 intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 分析printf函数的内容 ： va_listarg=(va_list)((char*)(&fmt)+4); va_list的定义：typedefchar*va_list 这说明它是一个字符指针。其中的：(char*)(&fmt)+4)表示的是“ ”中的第一个参数。C语言中，参数压栈的方向是从右往左，也就是说，当调用printf函数的适合，先是最右边的参数入栈。fmt是一个指针，这个指针指向第一个const参数（constchar*fmt)中的第一个元素。fmt也是个变量，它的位置，是在栈上分配的，它也有地址。对于一个char*类型的变量，它入栈的是指针，而不是这个char*型变量。 图8.4vsprintf(buf,fmt,arg)函数 它接受一个格式化的命令，并把指定的匹配的参数格式化输出。vsprintf返回的是一个长度。 vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 write(buf,i)： write，顾名思义：写操作，把buf中的i个元素的值写到终端。 图8.5write函数结构体 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章讲述了Linux的I/O设备管理方法、UnixI/O接口及其函数、printf的实现分析、getchar的实现分析。 了解UnixI/O将帮助程序员理解其他的系统概念，有时候除了使用UnixI/O以外别无选择。 Linux提供了少量的基于UnixI/O模型的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行I/O重定向。Linux的读和写操作会出现不足值，应用程序必须能正确的预计和处理这种情况。应用程序不应直接调用UnixI/O函数，而应该使用RIO包，RIO包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。 结论 用计算机系统的语言，逐条总结hello所经历的过程。 编写C语言程序。预处理：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。结果就得到了另一个C程序，通常是以.i作为文件扩展名。编译：在编译阶段，编译器将高级语言编译成汇编语言。汇编语言不具有可移植性，是直接面向处理器的语言，是机器指令的一种符号表示，不同类型的计算机系统有不同的机器指令系统，也就有不同的汇编语言。汇编：在汇编阶段，汇编器将汇编语言指令翻译成机器可执行的机器语言指令。链接：链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。进程管理：进程是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。进程给应用程序提供两个关键的抽象：一个独立的逻辑控制流，一个私有的地址空间。存储管理：CPU上的内存管理单元MMU根据页表将CPU生成的虚拟地址翻译成物理地址，进行相应的页面调度。在这个过程中，TLB，三级cache结构的使用加快了访存速度。I/O管理：Linux提供了少量的基于UnixI/O模型的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行I/O重定向。Linux的读和写操作会出现不足值，应用程序必须能正确的预计和处理这种情况。应用程序不应直接调用UnixI/O函数，而应该使用RIO包，RIO包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。 附件 hello.c：C语言程序 hello.i：C语言程序hello.c预处理后得到的新的C程序 hello.s：将hello.c编译后得到汇编语言文本文件 hello.o：将hello.c汇编后得到的机器语言指令的可重定位目标程序 hello：将hello.o链接后得到的可执行文件 elf.txt：hello.o的ELF文件 elf1.txt：hello的ELF文件 hello.txt：hello.o反汇编后得到的汇编语言代码 hello1.txt：hello反汇编后得到的汇编语言代码 参考文献 [1] RandalE.Bryant ,DavidO'Hallaron.ComputerSystems:AProgrammer'sPerspective.中国电力出版社. 
第367篇文章[]
Java编程语言中类的继承 在软件构造实验3中，我们多次用到了继承的思想 继承是面向对象的开发过程中的一个非常重要的概念，通过继承，我们可以使用之前定义的成员方法和成员变量，经过简单的程序编码就可以在已有类的基础上增加新的功能。 Java程序设计语言通过继承机制，在现有类的基础上定义一个新的类，并在原有类的基础上添加新的方法或修改原有方法，从而提高编程效率、减少错误概率。 继承是通过关键字extends来声明的，其格式为： [修饰符]class类名extends父类名 如 publicclassbirdextendsanimal{ } bird类继承了animal类，即animal类是bird类的直接父类（或直接超类），bird是animal类的直接子类。 我们简单的编写animal类，使它作为bird类的父类 publicclassanimal{ publicbooleanlive; publicStringname; publicfinalbooleancanFly; publicanimal(booleancanFly) { this.canFly=canFly; } publicvoidgetName() { System.out.println(name); } } 我们用eclipse创建子类时，在指定包、类名的同时，还可以指定继承的超类（父类）和实现的接口。 我们可以在Superclass中输入或选择我们要继承的父类。 eclipse自动为我们生成了代码。 packageP1; publicclassbirdextendsanimal{ } 此时，eclipse向我们报错，因为我们在父类中写了一个构造方法，eclipse提醒我们为子类添加构造方法。 我们选择让eclipse自动添加构造方法，得到了如下代码。 packageP1; publicclassbirdextendsanimal{ publicbird(booleancanFly){ super(canFly); //TODOAuto-generatedconstructorstub } } 我们编写一个program来验证一下，子类bird是否继承了animal的成员方法与成员变量 packageP1; publicclassprogram{ publicstaticvoidmain(String[]args){ //TODOAuto-generatedmethodstub birdeagle=newbird(true); eagle.name="Eagle"; eagle.live=true; eagle.getName(); } } 运行结果如下 
第368篇文章[]
自增与自减运算符 在软件构造实验3中，从文本中读取有效信息时，出现了读取到的信息错误的问题 读取信息时，前两个字符总是相等，后面读取到的字符串也依次发生了错误 摘取部分错误代码如下 publicstaticvoidmain(String[]args) { inti=0; Strings="Java"; Stringst=""; st=st+s.charAt(i); System.out.println(st); st=st+s.charAt(i++); System.out.println(st); st=st+s.charAt(i++); System.out.println(st); st=st+s.charAt(i++); System.out.println(st); } 错误结果。 首先观察到的错误就是前两个字符相等，这与我们希望的结果明显不同 第一个字符输出与第二个字符相等，很明显这里实际执行的操作应该是 st=st+s.charAt(0); st=st+s.charAt(0); 这时候才反应过来i++与++i的区别 i++：使用i的值之后，将i的值加1 ++i：将i的值加1之后，使用i的值 i--：使用i的值之后，将i的值减1 --i：将i的值减1之后，使用i的值 publicstaticvoidmain(String[]args) { inti=0; Strings="Java"; Stringst=""; st=st+s.charAt(i); System.out.println(st); st=st+s.charAt(++i); System.out.println(st); st=st+s.charAt(++i); System.out.println(st); st=st+s.charAt(++i); System.out.println(st); } 修改后的结果 自增与自减运算符在刚开始接触高级语言的时候就已经学习过了，但是在平时使用的过程中可能很少需要区分i++与++i的区别，因此可能稍加不注意就出现了bug。有时可能不容易检查 在写代码的时候注意甄别两者的区别，可以避免在后续过程中调试的麻烦 
第369篇文章[]
用Java集合类实现图的广度优先算法 用Java集合类实现图的广度优先算法 第一次Java实验，就碰到了要求实现无向图两点间距离计算的题目。被迫拾起了数据结构的知识。 刚刚着手学习Java编程语言，加上之前数据结构的知识也都还给老师，就算还记得，也不知道怎样用Java实现图的结构与算法啊QAQ 没办法，最后硬着头皮，用Java集合类勉强写出来了。 过程可能要麻烦很多，我相信肯定也被很多人写过，不过我实在太懒了，也没有搜过相关文章。如果实现过程中有问题，还请大佬指出。 先给出题目条件吧。这里要存储的点是一个自定义的Person类，当然，你也可以使用任何的其他对象。 Map<Person,Set<Person>>graph=newHashMap<Person,Set<Person>>(); 我用一个HashMap对象graph来存储我的图。这里，Person是图中的每一个顶点，Set<Person>中存放的是每一个和Person相邻接的顶点。 添加顶点与添加边的方法比较简单，不具体写出来了，简述一下吧。 booleanaddVertex(Personname) voidaddEdge(Personname1,Personname2) 函数addVertex(Personname)将Person类name加入graph中，并为name新建一个集合，加入name在graph中映射到的值里。 函数addEdge(Personname1,Personname2)则分别将name1加入name2映射到的集合graph.get(name2)中，将name2加入到name1映射到的集合graph.get(name1)中。 接下来，就是用集合实现广度优先算法来获取距离了。话不多说，先给出代码。 intgetDistance(Personname1,Personname2) { intdistance=0; if(graph.containsKey(name1)&&graph.containsKey(name2))//有这两个人 { Map<Person,Integer>search=newHashMap<Person,Integer>();//search标记邻接点是否被访问过 Set<Person>set=newHashSet<Person>();//已经遍历到的全部点的集合set set.add(name1); search.put(name1,0); while(search.containsValue(0))//存在没有遍历的点 { if(set.contains(name2))//已经搜索到了name2 { returndistance; } Set<Person>friend=newHashSet<Person>();//新一轮遍历到的全部点的集合 Iterator<Person>it=set.iterator();//遍历全部点的集合 while(it.hasNext()) { Personx=it.next();//从set中依次取出 if(search.get(x)==0) { friend.addAll(graph.get(x));//将x的邻接的点全部添加到集合friend中 search.put(x,1);//标记x的邻接点已访问 } } set.addAll(friend);//将新集合并入原集合set it=set.iterator(); while(it.hasNext())//遍历集合set { Personx=it.next(); if(search.containsKey(x)==false)//存在search中未加入的新点 { search.put(x,0); } } distance=distance+1;//完成一次搜索，距离加1 } return-1; } else { System.out.println("error!根本没这人"); System.exit(0); } returndistance; } 首先，我们要保证这两个点在图中确实存在，然后我们再进行下一步。 用distance标记两人之间的距离，这里用了另一个HashMap对象search标记一个顶点是否被访问过邻接点。 Map<Person,Integer>search=newHashMap<Person,Integer>(); 用HashSet存储name1可达的顶点（我们从name1出发，搜索name2）。 Set<Person>set=newHashSet<Person>(); 如果一个顶点Person的邻接点被存入了set中，我们就把Person映射到的值标记为1，反之，如果点Person的邻接点还没有被存入set，我们将Person映射到的值标记为0。 下面我们正式开始。 首先我们将name1加入set，并将映射（set，0）写入哈希表search，因为此时我们仅仅是将name1写入了set，并没有将set的邻接点写入set。 接下来就要进入循环了，循环条件为search.containsValue(0)，也就是说在set中，存在着一些点，它们的邻接点还没有被添加进set中，此时我们可以继续添加这些点。 循环开始，我们先判断了name2是否存在于set中（不排除name2等于name1的可能），如果name2已存在于set中，返回distance（name2等于name1时，distance为0）。 接下来，我再次new了一个HashSet的集合。 Set<Person>friend=newHashSet<Person>(); friend存储的是这一轮循环过程中，将要被添加到set中的点，因为set需要遍历，担心直接添加进set中会引起混乱（这个我并没有进行实验，感兴趣的可以尝试一下），但是用个friend缓冲一下，就不会遇到这种问题了。 接下来，开始遍历set，依次从set中取出元素，如果这个元素被search标记为0，即它的邻接点并未被添加（我们暂时不考虑邻接点有哪些，有可能其实它的邻接点已经全部被添加进set中了，但是我们是不知道的，我们必须通过再添加一次，来保证不产生遗漏，Set类就像数学中的集合一样，会帮我们去掉重复的元素），我们将它映射到的集合添加到friend中（即将所有邻接点加入friend中）并将这个元素重新标记为1。 全部遍历完成后，我们再将集合friend并入到集合set中。 紧接着，我们再一次遍历set集合，如果set中存在元素，在search中不存在（即前一轮遍历得到的friend中存在着新的，原set中不存在的元素，被加入到了set中），则将此元素添加到search中，并使其映射到0。 遍历完成后，distance加1，即在原先已遍历到的顶点的前提上再次前进了一节。 接下来，继续进行最外层的循环。如果set中存在被标记为0的元素，则继续进行前面的步骤。 如果不存在被标记为0的元素，则说明上一轮的搜索并没有增加新的元素，我们已经完全搜索了name1可达的节点，这应该是图的一个连通子图。如果name2存在于这个子图中，由于新一轮搜索并没有增加新的标记为0的节点，也就是说在之前一轮的循环结束，set中就已经包含了这个连通子图，而在上一轮的循环中，显然如果存在name2，那么在if条件的判断时就应该已经返回了结果。因此，name2是不存在这个连通子图中的，也就是说name1无法到达name2，于是，我们返回一个-1。 有点啰嗦，写的有点多，希望大佬们不要见怪。 
第370篇文章[]
哈工大软件构造Lab3（继承不同父类时返回值类型不同带来的比较问题，提高代码的可复用性） 在实验三中，我们写了两个接口 IntervalSet<L> MultiIntervalSet<L> 我们定义了时间段类Interval privatefinallongstart; privatefinallongend; 在Interval中保存的是一个时间段的开始时间与结束时间 对于两个接口，写了相应的实现 CommonIntervalSet<L> privatefinalMap<L,Interval>intervals=newHashMap<>(); CommonIntervalSet所实现的主要功能是管理标签L到时间段Interval的映射关系。每个标签L只能对应一个时间段。 如：在安排值班时间时，每个人只安排一个时间段。 在CommonIntervalSet<L>中，我们给出了一种方法，得到标签Llabel对应的时间段 publicIntervalgetInterval(Llabel) CommonMultiIntervalSet<L> privatefinalMap<L,IntervalSet<Integer>>intervals=newHashMap<>(); CommonMultiIntervalSet实现的功能是管理标签L到时间段集合IntervalSet<Integer>的映射关系。IntervalSet<Integer>即第一个接口，这里我们是用Integer类型代替抽象数据类型。每个标签L映射到一个时间段集合，即每个标签可以对应多个时间段。 如：进程执行时，执行时间并不是连续的，因此一个进程可能对应多个时间段。 在MultiCommonIntervalSet<L>中，我们给出了一种方法，得到标签Llabel对应的时间段的集合IntervalSet<Integer> publicIntervalSet<Integer>getInterval(Llabel) 介绍完前提，我们开始介绍本次实验中遇到的问题。 我们需要设计一个值班表排表的APP，DutyRosterSet 我们需要实现两种APP 第一种：同一个员工可以在两个不连续的时间段值班 第二种：同一个员工的值班时间必须是连续的 publicclassDutyRosterSetextendsCommonMultiIntervalSet<Employee>implementsIDutyRosterSet publicclassDutyRosterSetextendsCommonIntervalSet<Employee>implementsIDutyRosterSet 很明显，对于第一种APP，我们应该继承CommonIntervalSet<L>类；对于第二种，我们应该继承CommonMultiIntervalSet<L>类 在DutyRosterSet中，我们需要实现以下功能 给定标签Llabel，以及时间段Intervaltime 我们要判断label是否指向时间段label 我们已经从CommonIntervalSet<L>和CommonMultiIntervalSet<L>中分别继承了 publicIntervalgetInterval(Llabel) 以及 publicIntervalSet<Integer>getInterval(Llabel) 此时，就给我们代码的实现带来了一定的问题。 当我们调用getInterval（label）的时候，由于继承的类不同，所返回的返回值的类型也不同，由于我们无法直接判断返回值是一个时间段的类型Interval，还是时间段集合IntervalSet<Integer>。这给我们判断标签label是否指向时间段time造成了很大困难。 因此，当已经实现第一种APP后，如果想实现第二种APP，此时我们不仅需要将继承的类由CommonIntervalSet<L>更改为CommonMultiIntervalSet<L>，还需要修改代码，这与我们要求尽可能高的复用性的要求相矛盾。 接下来，我们介绍一下针对这种问题的解决方案 2种方法，其实大同小异，都简单的写了一下 为了提高代码的可复用性，使我们可以更方便的根据不同要求，修改更少的代码。 我们考虑将判断的过程放入父类 第一种：保留差异性，在不同的父类中实现的方法，需要传入不同的参数 在CommonIntervalSet<L>中添加以下方法 publicbooleanbelong(Intervala,Intervalb) 在CommonMultiIntervalSet<L>中添加以下方法 publicbooleanbelong(Intervalt,IntervalSet<Integer>set) 此时，我们再判断标签label是否指向时间段time的时候，只需要调用 belong（time，getInterval（label）） 由于在CommonIntervalSet<L>中，getInterval（label）返回的是Interval类型，而belong（，）要传入的参数正是Interval型 而在CommonMultiIntervalSet<L>中，getInterval（label）返回的是IntervalSet<Integer>类型，而belong（，）要传入的参数则是IntervalSet<Integer>型，此时分别对应相等 此种方法既解决了继承不同父类时返回值不同的问题，同时也保留了部分差异性，当我们所需实现的APP对某些差异性有针对性的要求时，可以使用此方法 第二种：直接使用同样的接口 在CommonIntervalSet<L>和CommonMultiIntervalSet<L>中添加同样的方法 publicbooleanbelong(Intervalt,Llabel) 此时，我们要判断label是否指向时间段time，只需要调用 belong（time，label） 这种方法就消除了差异性的问题，使代码有了更高的可复用性 同时，因为消除了差异性，只保留了共性的部分，使其他程序员在使用我们设计的接口时，更简单易懂 个人还是比较倾向于第二种方法的，毕竟我们写接口就是为了抽象出共性的东西，让我们可以更方便的反复利用 总结： 为了提高可复用性，应尽量减少继承不同父类时出现的返回值类型不同的问题，减少其个性的方法，增加其共性的方法，针对不同要求有不同实现，然后通过相同的接口，可以让我们的代码具有更好的可复用性 
第371篇文章[]
正则表达式中的元字符 在软件构造实验三中，我们为排班表应用添加了一个从文本中读取排班信息的功能 文本中给出的信息在格式上可能是错误的，如果我们直接拿来使用的话，当我们在后续的对文本信息进行解析的过程中，可能会出现很多不必要的麻烦 通过使用正则表达式，在对文本内容解析之前，先筛除掉格式错误的文本文件，可以很大程度上减少我们后续过程中的工作量 我总结了一下常用的正则表达式的元字符，并简单介绍了一下它们的含义 正则表达式中的元字符 元字符正则表达式中的写法含义."."代表任意一个字符\d"\\d"代表0~9的任意一个数字\D"\\D"代表任意一个非数字字符\s"\\s"代表空白字符。如‘\t’、‘\n’\\S"\\S"代表非空白字符\w"\\w"代表可用作标识符的字符（不包括‘$’）\W"\\W"代表不可用于标识符的字符\p{Lower}\\p{Lower}代表小写字母{a~z}\p{Upper}\\p{Upper}代表大写字母{A~Z}\p{ASCII}\\p{ASCII}ASCII字符\p{Alpha}\\p{Alpha}字母字符\p{Digit}\\p{Digit}十进制数字\p{Alnum}\\p{Alnum}数字或字母字符\p{Punct}\\p{Punct}标点符号\p{Graph}\\p{Graph}可见字符\p{Print}\\p{Print}可打印字符\p{Blank}\\p{Blank}空格或制表符\p{Cntrl}\\p{Cntrl}控制字符 资料来源：《Java从入门到精通》，清华大学出版社，2019年10月第1版 
第372篇文章[]
初学Iterator迭代器设计模式 初学迭代器设计模式，一直不怎么理解，希望通过写篇博客加强理解。 我的理解是，迭代器设计模式可以解决这个问题。如果我有一个自已定义的类，这个类有当作容器的功能，比如里面有一个属性是Set，然后我想要遍历被放入这个容器类的一组ADT对象，而无需关注容器的具体类型，这时就可以使用迭代器设计模式了。 我们需要关注两个接口，Iterable和Iterator。这两个接口的大致结构如下： publicinterfaceIterable<T>{   Iterator<T>iterator(); } publicinterfaceIterator<E>{ booleanhasNext(); Enext(); voidremove(); } 让自己的集合类实现Iterable接口，并实现自己独特的Iterator迭代器（hasNext,next,remove），允许客户端利用这个迭代器进行显示或隐式的迭代遍历： for(Ee:collection){ } Iterator<E>iter=collection.iterator(); while(iter.hasNext()){ } 下面看一个具体的例子。比如我们要造一个停车场ParkingField，这是一个接口，它的实现类是ConcreteParkingField。然后车位的类叫Lot，停进去的东西有汽车，摩托车等，所以有一个接口Parkable。下面看看怎么实现迭代器。我们首先需要给停车场这个容器提供遍历的功能，所以用ParkingField继承接口Iterable，再用ConcreteParkingField实现ParkingField。r然后需要提供一个迭代器，用ParkingIterator来实现接口Iterator。代码框架大致如下（里面的方法和属性不是重点，所以我把大部分的属性用…代替，重点是和迭代器相关的东西）： ParkingField继承接口Iterable publicinterfaceParkingFieldextendsIterable<String>{ publicstaticParkingFieldcreate(int[]nos,int[]widths)throwsException{ returnnewConcreteParkingField(nos,widths); } publicstaticParkingFieldcreate(Map<Integer,Integer>lots)throwsException{ returnnewConcreteParkingField(lots); } publicvoidparking(Stringtype,Stringplate,intwidth,intnum,String[]extraRegistrationInfo)throwsException; publicvoidparking(Stringtype,Stringplate,intwidth,String[]extraRegistrationInfo); publicdoubledepart(Stringplate)throwsException; publicMap<Integer,String>status(); publicintgetNumberOfLots(); publicbooleanisLotInParkingField(intnum,intwidth); publicbooleanisEmpty(); intgetLotWidth(intnum)throwsException; } ConcreteParkingField实现接口ParkingField publicclassConcreteParkingFieldimplementsParkingField{ privatefinal  privatefinalMap<Lot,Parkable>status=newHashMap<>(); privatefinal  publicConcreteParkingField(Map<Integer,Integer>lotsInfo)throwsException{ } publicConcreteParkingField(int[]nos,int[]widths){ } @Override publicvoidparking(Stringtype,Stringplate,intwidth,intnum,String[]extraRegistrationInfo)throwsException{ } @Override publicvoidparking(Stringtype,Stringplate,intwidth,String[]extraRegistrationInfo){ } @Override publicdoubledepart(Stringplate)throwsException{ } @Override publicMap<Integer,String>status(){ } @Override publicintgetNumberOfLots(){ } @Override publicbooleanisLotInParkingField(intnum,intwidth){ } @Override publicbooleanisEmpty(){ } @Override publicintgetLotWidth(intnum)throwsException{ } @Override publicStringtoString(){ } //重点是这个。。。返回一个迭代器 @Override publicIterator<String>iterator(){ returnnewParkingIterator(this.status); } ParkingIterator来实现接口Iterator注意，正常情况下Iterator的泛型应该是Parkable，为了不给ParkingField和client泄露Parkable，改成了String。 publicclassParkingIteratorimplementsIterator<String>{ privatefinal  privatefinal  privateintcount=0; publicParkingIterator( ){   } @Override publicbooleanhasNext(){ returncount< size(); } @Override publicStringnext(){   count++;   } @Override publicvoidremove(){   } } 总的来说，迭代器模式让数据处理逻辑和内部数据管理分离，用一种更安全的方式进行遍历。此外，还可以还可以控制内部数据的顺序，这上面的例子中，于ParkingIterator的构造方法中加入一个排序即可。以上，如有错误，恳请斧正。 
第373篇文章[]
Java中的列举Enumerations 复习的时候发现Java中的Enumerations这个类型以前好像没有见过，感觉有时候还是挺有用的，所以就来记录一下。 根据我的理解，Enumerations就是一个类class，但是里面可以自定义一些常用的对象。比如说我有一个课程（Course）类，然后我经常使用的对象有math，Chinese，English这三门课程，所以就可以把这三种对象定义在Enumerations里面。 publicenumCourse{ math("math",6,"m"),Chinese("Chinese",4,"c"),English("English",4,"e"); privatefinalStringcourseName; privatefinalintstudyHours; privatefinalStringteacherName; Course(StringcourseName,intstudyHours,StringteacherName){ this.courseName=courseName; this.studyHours=studyHours; this.teacherName=teacherName; } publicStringgetCourseName(){ returnthis.courseName; } publicStringgetTeacherName(){ returnthis.teacherName; } publicintgetStudyHours(){ returnthis.studyHours; } } 像这样，我定义了一个Enumerations，里面有三个常用的对象，math，Chinese，English。如果想要调用其中一个也很容易，如下： Coursem=Course.math; System.out.println(m.getTeacherName()); 这样，m就是math这个对象了。 另外，还可以遍历这些对象，像这样： for(Coursep:Course.values()){ System.out.println(p.getCourseName()); } 后来又发现一点，不要轻易修改里面属性的值。比如现在我把Course修改如下，让它变成一个mutable的ADT，就是把studyHours前面的final修饰符去掉，然后增加了一个修改studyHours的方法setStudyHours。 publicenumCourse{ math("math",6,"m"),Chinese("Chinese",4,"c"),English("English",4,"e"); privatefinalStringcourseName; privateintstudyHours; privatefinalStringteacherName; Course(StringcourseName,intstudyHours,StringteacherName){ this.courseName=courseName; this.studyHours=studyHours; this.teacherName=teacherName; } publicStringgetCourseName(){ returnthis.courseName; } publicStringgetTeacherName(){ returnthis.teacherName; } publicintgetStudyHours(){ returnthis.studyHours; } publicvoidsetStudyHours(inthours){ this.studyHours=hours; } } 然后我尝试修改属性的值： publicstaticvoidmain(String[]args){ Coursem=Course.math; m.setStudyHours(4); System.out.println(m.getStudyHours()); System.out.println(Course.math.getStudyHours()); } 结果输出都是4。这就说明第一句的m=Course.math应该是让m指向math的空间，然后修改m的studyHours后，这个空间里的studyHours就会发生变化，所以Enumerations里面的math对象也就变化了。因此我觉得对于Enumerations，还是使用immutable的数据类型为好。 
第374篇文章[]
学习了Java中ADT的等价性的一些收获 这里写自定义目录标题 等价关系对象的等价性equals函数hashCode函数可变类型的等价性对equals和hashCode的总结 最近在软件构造课里学习了Java中ADT的等价性，希望能够通过写博客这种方式来总结一下，加强理解。 等价关系 之前在集合论与图论中学过关系，等价关系需要满足三个性质，自反性、对称性、传递性。对于一个集合T，这个集合的某一个关系可以定义为其笛卡尔积的子集，即关系R ⊆ \subseteq ⊆T × \times ×T。下面看看等价关系的三个性质。自反性 ∀ \forall ∀t ∈ \in ∈T,tRt.对称性 ∀ \forall ∀u,v ∈ \in ∈T,ifuRv,thenvRu.传递性 ∀ \forall ∀u,v,w ∈ \in ∈T,ifuRv,andvRw,thenuRw. 对象的等价性 注：这里的对象指的都是不可变(immutable)的，如果是可变的，直接用Object类里的函数即可。 老师上课举的例子我觉得对我的启示比较大，两个对象是否等价，需要比较的不应该是它们内部的属性，而是属性经过AF(abstractionfunction)映射后是结果，即AF(rep1)是否等于AF(rep2)。其中rep1和req2分别是待比较的两个对象的属性列表。 例子如下： publicclassDuration{ privatefinalmins; privatefinalsecs; //repinvariant: //mins>=0,secs>=0 //abstractionfunction: //representsaspanoftimeofminsminutesandsecsseconds /**Makeadurationlastingformminutesandsseconds.*/ publicDuration(intm,ints){ mins=m; secs=s; } /**@returnlengthofthisdurationinseconds*/ publiclonggetLength(){ returnmins*60+secs; } } 这是一个表示时间的类，如果要比较两个Duration对象的等价性，判断两个属性是否相等显然是不合理的，比如 Durationd1=newDuration(1,2); Durationd2=newDuration(0,62); 这两个对象虽然内部的属性不同，但表示的意义都是62秒，所以应该等价。这里就可以用函数getLength()来判断了，如果返回值相等，则等价。 在这里需要约束class里面的方法。对于两个等价的对象，执行同一观察器（observer）函数，返回的结果也要一样。例如有一个class的结构如下： classLetterSet{ privateStrings; //Abstractionfunction: //AF(s)=thesubsetoftheletters{a z}thatarefoundins //(ignoringalphabeticcaseandnon-letters) /**@returntrueifandonlyifallthelettersinthissetarelowercase*/ publicbooleanisAllLowercase(){ } } 这个isAllLowercase函数就是错误的。比如"abc"和"ABC"，有AF，都映射到集合{a,b,c}，但这个函数的返回值不同。 equals函数 首先看一下Object类中的equals函数。 publicclassObject(){   publicbooleanequals(Objectthat){ returnthis==that; } } 对于这个缺省的equals函数，我的理解是判断两个对象是否指向同一个内存空间（不太确定），所以一般来说，对于自己编写的类，需要以上文的原则重写这个函数。重写函数的代码基本如下： @Override publicbooleanequals(Objecto){ if(!(oinstanceofDuration))returnfalse; Durationthat=(Duration)o; returnthis.getLength()==that.getLength(); } 注意，这里的参数必须是Object型。这是因为这是对父类函数的重写（override），参数列表必须相同，如果参数类型不同，那是重载（overload）。比如说我们把equals函数写成下面的格式：publicbooleanequals(Duration)，则如果调用函数传入的参数类型是Duration，当然默认调用是我们写的这个函数，但如果参数是其他的类型，因为类型不匹配，所以会调用父类的equals函数，发生错误。 hashCode函数 这个函数的功能是将对象映射到一个常数。看一下Object类中的hashCode函数。 publicclassObject{   publicbooleanequals(Objectthat){returnthis==that;} publicinthashCode(){return/*thememoryaddressofthis*/;} } 这个函数的默认实现是返回它的内存地址。重写这个函数的规则和equals相似，都是由AF决定的。如果两个对象等价，则它们的hashCode返回值一定相等。对于上面的例子Duration这个类，重写的一种方法为： @Override publicinthashCode(){ return(int)getLength(); } 可变类型的等价性 这里引出了两个概念，观察等价性和行为等价性。观察等价性在不改变状态的情况下，两个mutable对象是否看起来一致。行为等价性调用对象的任何方法都展示出一致的结果。 对于不可变类型来说，这两种等价性是等价的，不可变类型没有变化器（mutator）方法。对于可变类型，往往使用观察等价性来判断，但有时用观察等价性会出现bug。当我们编写一个可变类型时，实现行为等价性即可，equals函数和hashCode函数，不需要重写，直接继承Object的两个方法就行了。当然如果一定要判断两个可变类型“看起来”是否一致，可以定义一个新的方法来判断。 对equals和hashCode的总结 对于不可变类型必须重写这两个方法，保证行为等价性，行为等价性等价于观察等价性。对于可变类型不需要重写，保证行为等价性。 最后，本人新手，恳请斧正。 
第375篇文章[]
Java中final修饰符与类型检查 文章目录 前言一、类型检查1.静态类型检查2.动态类型检查 二、可变数据类型和不可变数据类型1.可变数据类型2.不可变数据类型 final修饰符修饰可变类型修饰不可变类型 前言 最近在复习，感觉类型检查那部分细节比较多，final修饰符也会涉及到类型检查，所以就把这两个知识点综合起来总结一下。 一、类型检查 1.静态类型检查 Java是一种静态类型的语言。 ----所有变量的类型在编译的时候就已经知道了，然后编译器也会导出所有表达式的类型。 ----如果a和b为int类型，那么编译器会推断a+b也是int类型。 ----eclipse环境会在你写代码的时候就做这些事情，所以你在写代码的时候就会发现eclipse可能报出一些错误。 ----静态类型检查在编译阶段进行。 在编译阶段发现错误，避免了将错误带到运行阶段，可提高程序正确性。 一般是类型相关的错误。如语法错误，类名、函数名错误，参数数目、类型错误，返回值类型错误。 intn=1; if(n)n++; 在eclipse中输入这段代码时，在第二个n处会有红色波浪线，因为和C不一样，Java的判断语句内必须的boolean类型的。所以编译器在编译阶段就会报错。 2.动态类型检查 在像python这样的动态类型语言中，这种检查推迟到运行时候。 ----在运行阶段进行类型检查。 一般的错误有非法的参数值，非法的返回值，越界，空指针。 inta=1,b=0; System.out.println(a/b); 在eclipse中输入这段代码，没有运行时，不会报错。但运行后会抛出异常：Exceptioninthread“main”java.lang.ArithmeticException:/byzero。这是在运行阶段进行检查的动态类型检查。 二、可变数据类型和不可变数据类型 1.可变数据类型 可变数据类型是当改变一个变量的值时，将该变量当前指向的值的存储空间中写入一个新的值。比如StringBuilder是一种可变的数据类型。 StringBuildersb=newStringBuilder("a"); sb.append("b"); 其内部的过程可以由这个图来表示： 2.不可变数据类型 不可变数据类型是改变一个变量，将该变量指向令一个值的存储空间。比如String是一种不可变的数据类型。 Strings="a"; s=s.concat("b"); 其内部的过程可以由这个图来表示： final修饰符 用final修饰class可以阻止被继承；修饰method可以阻止被子类重写；修饰field可以阻止被重新赋值；修饰局部变量也可以阻止被重新赋值。 下面主要讨论final分别修饰可变和不可变数据类型与静态类型检查的情况。 修饰可变类型 以StringBuilder为例。 finalStringBuildersb=newStringBuilder("a"); sb.append("b"); 这段代码没有任何问题，代码快照图和上文可变数据类型的图相同。依然是同一个空间，只是空间里的值不同了。 finalStringBuildersb=newStringBuilder("a"); sb=newStringBuilder("ab"); 这段代码在第二个sb处就会有红色波浪线，因为有final修饰，无法改变变量指向的对象。对于可变数据类型，final使得变量无法改变其引用。 修饰不可变类型 以String为例。 finalStrings="a"; s=s.concat("b"); 和上文的图相同，String是不可变的数据类型，无法修改值，只能重新创建一个空间。这段代码就想要重新创造一个空间，这个空间里面的内容是“ab”，然后让s指向这个空间。显然会报错，因为有final修饰，s无法改变其指向。所以说，对于不可变数据类型，一旦被创建，其值不能改变。 
第376篇文章[]
Java中类的继承时调用方法的小细节 我在复习备考时发现自己对部分细节还是不熟悉，所以写篇博客记录一下，希望能够帮到大家。 首先我写了三个类，animal，dog，husky。代码如下，非常简单。 publicclassanimal{ publicvoideat(){ System.out.println("eat100"); } publicvoidrun(intp){ System.out.println("run100"); } } publicclassdogextendsanimal{ publicvoideat(){ System.out.println("eat200"); } publicvoidrun(Stringp){ System.out.println("run200"); } } publicclasshuskyextendsdog{ publicvoidrun(intp){ System.out.println("run300"); } } 我们创建对象时，有三组，共六种方式： animala=newanimal(); animalb=newdog(); animalc=newhusky(); dogd=newdog(); doge=newhusky(); huskyf=newhusky(); 第一个 animala=newanimal(); a.eat(); a.run(0); 这里显然只能这样调用，输出结果是eat100和run100没有疑问。 第二个可以看到，虽然dog类中run方法的参数类型是String，但这里只支持int的参数，也就是父类animal的run方法。这是因为这种定义方法，编译器将b静态解析成animal类，所以只能调用animal中的方法。运行一下试试 animalb=newdog(); b.eat(); b.run(0); 输出结果为：eat200（换行）run100。可以看到，eat方法虽然静态解析成animal中的方法，但运行时还是dog的eat方法。run方法，因为参数是int型，所以运行时只能调用animal的run方法。 第三个 animalc=newhusky(); c.eat(); c.run(0); 正如刚才所说，静态检查下是animal的方法。输出结果为eat200（换行）run300。husky中只重写了run方法，所以调用eat时默认运行的是父类dog的eat方法，而调用run方法就是husky的run方法。 第四个dogd=newdog();比较容易，就不再阐述了。 第五个这里的静态解析，将e解析成dog类，可以调用dog类中的方法和其父类animal类中的方法。 doge=newhusky(); e.eat(); e.run(0); e.run("0"); 输出结果为eat200（换行）run300（换行）run200。因为husky中没有些eat，所以这里调用的是父类dog中的eat。然后husky中有run(intp)，所以参数为int时调用husky中的run。参数为String时向父类搜索，调用dog中的run。 第六个huskyf=newhusky();这种情况类似于上一种。 huskyf=newhusky(); f.eat(); f.run(0); f.run("0"); 结果也和上面一种一样，这里就不解释了。 以上内容全部是个人通过代码实验出来的，如果有误，恳请斧正。 
第377篇文章[1]
计算机系统大作业程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算学部学 号1190202107班 级1936602学生姚舜宇 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文利用计算机系统这门课所学的知识，以hello.c程序为例，描述了它的从编写完成到终止的历程。包括预处理、编译、汇编、链接、进程管理、存储管理、IO管理的知识，加强了我们对于计算机系统和程序执行流程的理解。关键词：计算机系统；hello 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介P2P:Program:用户在编辑器或IDE中键入代码得到程序。Process:在Linux中，hello.c经过C预处理其cpp的预处理成为文本文件hello.i，C编译器ccl的编译成为汇编文件hello.s，汇编其as的汇编成为二进制可重定位目标文件hello.o，最终经过ld的链接，成为可执行程序hello。020：OS进程管理通过fork和execve产生子进程和加载并运行程序，进行虚拟内存的映射。CPU通过取指，译码，执行，访存，写回，更新PC的操作，一条一条执行指令。涉及到输入输出时，IO管理对函数进行处理。运行结束后，shell回收hello进程，并消除相关的数据等痕迹。1.2环境与工具硬件工具：X64IntelCorei5-8300HCPU,2.30GHz,8GRAM,512GHDDISK软件工具：Windows1064位，VMwareWorkstation16Pro,Ubuntu20.04.2.0开发与调试工具：Codeblocks,gccgdb,vim,readelf,objdump等1.3中间结果hello.i对hello.c进行预处理得到的文件hello.s对hello.i进行编译得到的文件hello.o对hello.s进行汇编得到的文件hello对hello.o进行链接得到的可执行文件hello.elfhello.o的ELF格式hello-run.elfhello的ELF格式hello_objdump.txt对hello.o进行反汇编得到的文件hello-d-r.txt对hello进行反汇编得到的文件1.4本章小结本章对hello进行了一个简介，并对其运行流程进行了一个总体的概括。然后介绍了所有操作的环境与工具，以及描述了中间产生的文件信息。 第2章预处理2.1预处理的概念与作用预处理是在编译之前对源文件提前进行的处理，可以算是一种展开。预处理通过扫描源代码，对其进行初步转换，产生新的源代码提供给编译器。预处理过程读入源代码，检测包含预处理指令的语句和宏定义，并进行相应的转换，以及删除注释和多余的空白符。预处理的主要作用如下：1.将源文件中以”include”格式包含的文件复制到编译的原文件中；2.用实际值替换以”#define”定义的字符串；3.根据”#if”后面的条件决定需要编译的代码，即条件编译；4.删除文件中的注释和多余的空白符。2.2在Ubuntu下预处理的命令gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析可以看到，原本很短的hello.c经过预处理之后生成的hello.i有数千行，这是预处理过程完成了对头文件的展开、宏定义的替换、去除注释、条件编译等内容。例如，头文件<stdio.h>在hello.i文件中的展开情况是从第13行到728行，里面包含了各种typedef和extern函数等。 在hello.i文件的末尾处，是源程序的主体部分。 2.4本章小结本节主要介绍了预处理的概念和功能，预处理是一个编写完的程序要进行的第一个步骤。预处理主要由预处理器完成，内容主要是展开头文件，宏定义替换，条件编译，去除无关注释。 第3章编译3.1编译的概念与作用编译是把通常为高级语言的源代码（这里指经过预处理而生成的hello.i）到能直接被计算机或虚拟机执行的目标代码（这里指汇编文件hello.s）的翻译过程。编译的主要作用如下：1.词法分析，词法分析器读入组成源程序的字符流并将其组成有意义的词素的序列，即将字符序列转换为单词序列的过程。2.语法分析，语法分析器使用词法分析器生成的各词法单元的第一个分类来创建树形的中间表示，在词法分析的基础上将单词序列组合成各类语法短语。该中间表示给出了词法分析产生的词法单元的语法结构，常用的表示方法为语法树。3.语义分析，语义分析器使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致，它同时收集类型信息，并存放在语法树或符号表中，为代码生成阶段做准备。4.代码生成和优化，在源程序的语法分析和语义分析完成后，会生成一个明确的低级的或类及其语言的中间表示。代码优化试图改进中间代码，生成执行所需要时间和空间更少。最后代码生成以中间表示形式为输入，并把它映射为目标语言。3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 3.3Hello的编译结果解析3.3.1文件内容简介 .file文件命名.text代码段.global全局变量.data数据段.align对齐方式.type类型.size大小.longlong类型.stringstring类型.section.rodata只读数据段 3.3.2数据hello.s中使用到的数据包括：sleepsecs,argc,argv,i,字符串,立即数。1.sleepsecs:这是定义时被初始化的全局变量。.data节保存已初始化的全局和静态C变量，所以编译器首先将sleepsecs在.text节中声明为全局变量，然后将其保存在.data节中，并设置对齐方式为4字节，类型为object，大小为4字节。在后面，sleepsecs又被标记为long类型，值为2，保存在只读代码段中。2.argc:这是传给main函数的第一个参数，表示命令行参数的个数。根据hello.c和hello.s文件推断，argc保存在地址为-20(%rbp)的栈中。 3.argv:它的完整声明为char*argv[]，是一个数组，main函数的第二个参数。它的首地址保存在地址为-32(%rbp)的栈中。 后续调用时，通过对地址进行加法运算，调用数组内部的元素。下图中先让寄存器%rax指向数组首地址，然后加偏移量16，再解引用。再次让寄存器%rax指向数组首地址，然后加偏移量8，再解引用，这样就调用了数组的第一个和第二个元素。 4.i:这是程序运行中定义的局部变量。根据hello.c文件中的循环可以推断，i保存在地址为-4(%rbp)的栈中。 5.字符串：在hello.c中，可以看到两个字符串。 在hello.s中，可以看到字符串 调用字符串时，使用语句 将这两个字符串作为printf函数的参数。6.立即数：立即数不需要寄存器或者栈的空间，直接表示在汇编代码中。 3.3.2控制与操作1.赋值操作赋值操作在hello.c中有对全局变量sleepsecs的初始化，对局部变量i的初始化以及自增运算i++。1)intsleepsecs=2.5sleepsecs是已经初始化的全局变量，在.data节中，值为2，数据类型为long。2)inti=0这是在循环入口处进行的初始化。 在hello.s文件的.L2处，可以看到局部变量i存储在-4(%rbp)处，并且用movl指令将其赋值为0。3)i++这是在每次循环结束时对i进行自增操作。 在hello.s文件的.L4末尾，用addl指令将存储在-4(%rbp)处的i加1。2.类型转换出现类型转换的位置是全局变量sleepsecs。在主函数main之外，使用intsleepsecs=2.5进行初始化。但后来被转换为值为2的long型变量。因为在初始化的时候，赋的数据是2.5，是浮点类型。所以进行向0舍入到2。而默认的浮点类型为8字节的double，所以后来强制转换为整型时转换为8字节的long型。 3.算术操作一般而言，算数操作包括加、减、乘、除、模等，但因为hello.c中出现的算术操作较少，所以这里只讨论加减运算和hello.s中涉及加减的汇编指令。1)i++在hello.s文件中，i++对应的汇编指令为addl$1,-4(%rbp)。即将地址为-4(%rbp)的数据进行加1。2)汇编指令中的算术操作subq$32,%rsp这里是将%rsp的值减32。因为%rsp是栈顶指针，所以这条指令的意义是在栈顶处开辟4字节的空间。leaq.LC1(%rip),%rdi这是加载有效地址的语句，也是算数操作，因为它涉及到计算有效地址。这句指令的意义是计算地址.LC1+%rip，并且传递给%rdi。addl$1,-4(%rbp)这里是将i的值加1。前面已经讨论过，i就局部变量，地址是-4(%rbp)。4.逻辑/位操作一般而言，逻辑/位操作包括与、或、非、异或、同或、移位等。在hello.c和hello.s中，并未出现逻辑/位操作，所以这里不予讨论。5.关系操作常见的涉及到关系操作的汇编指令包括cmp、test、jmp以及条件跳转等。下面就文件中出现的关系操作进行讨论。1)这条指令是将地址为-20(%rbp)的值与立即数3进行比较，并设置条件码。根据条件码的值，进行下一步的执行。下一条指令为je.L2，表示如果地址为-20(%rbp)的值等于3，则跳转到.L2的首地址开始执行。对应的C语言的语句为 但这里是如果参数不等于3则执行括号里的内容。对于汇编代码，对其进行了一定的优化，如果参数等于3，则执行相关内容。2)这一条指令同上一条类似，将地址为-4(%rbp)的值即局部变量i与立即数9进行比较，如果i小于或等于9，则跳转到.L4的首地址开始执行。在hello.c中，循环的判断条件是i<10，编译过程中将其优化为i<=9。6.数组/指针/结构操作1)数组与指针操作hello.c中涉及到的数组操作只有char*argv[]。这是一个数组指针。先查看汇编代码。 首先在这里，是将保存在寄存器里的参数放入内存中，将%edi的内容赋给-20(%rbp)地址的内容，将%rsi的内容赋给-32(%rbp)地址的内容，现在-32(%rbp)就是指向数组首地址的指针。 这里是引用数组下标为1和2的元素，即argv[1]和argv[2]。首先将数组首地址赋给%rax，然后%rax+16即第三个元素的首地址，然后将该地址的内容取出，赋给%rdx。下面再将数组首地址赋给%rax，然后%rax+8即第二个元素的首地址，然后将该地址的内容取出，赋给%rax。2)结构操作在hello.c中，没有定义结构，所以这里不予讨论。7.控制转移控制转移在上文的关系操作中有了一定的解释，一般的控制转移指令有jmp、je、jle、ja等，针对不同的条件码进行转移。1)控制转移指令为je.L2，表示如果地址为-20(%rbp)的值等于3，则跳转到.L2的首地址开始执行。对应的C语言的语句为 控制转移指令为jle.L4，如果i小于或等于9，则跳转到.L4的首地址开始执行。3)在.L2中，有一条无条件跳转指令jmp。 这条指令将会让程序无条件跳转到.L3首地址的位置开始执行。8.函数操作1)参数传递main函数：函数有两个参数，intargc,char*argv[]，第一个参数是一个int型整数，第二个参数是一个指针，即值是一个地址，它们分别存储在寄存器%edi和%rsi中，在函数中，将参数放入栈中保存。 printf函数：在编译过程中，有一处printf函数被优化为puts函数。在整个程序中，调用了两次输出的函数。第一处调用在判断体中。 在调用函数之前，将.LC0(%rip)的值即字符串"Usage:Hello1190202107姚舜宇！\n"的首地址传递给%rdi，所以%rdi为传入给函数puts的参数。第二处调用在循环体中。 在调用函数之前，将.LC1(%rip)的值即字符串"Hello%s%s\n"的首地址传递给%rdi，所以%rdi为传入给函数printf的参数。sleep函数：查看hello.c文件的内容，知道函数sleep的参数有一个，sleepsecs。查看hello.s文件的内容，在调用函数之前，执行movlsleepsecs(%rip),%eax、movl%eax,%edi将参数sleepsecs传入函数sleep。 exit函数：对于exit函数，传参较为简单。将寄存器%edi的值赋为1，然后调用函数。 getchar函数：并没有设置参数，进行条件判断之后直接调用函数。 2)函数调用main函数：由系统调用，首先在运行时通过动态链接，调用libc库里的函数__libc_start_main，然后这个函数会初始化程序，执行__init，注册退出处理程序，再调用main函数。printf函数：由指令callprintf@PLT调用。先将该指令的下一条指令地址压入栈中，然后进入该函数，函数执行结束后，执行调用printf函数指令下一条指令的地址。 sleep函数：由指令callsleep@PLT调用，过程同上。 exit函数：由指令callexit@PLT调用，过程同上。 getchar函数：由指令callgetchar@PLT调用，过程同上。 3)函数返回main函数：程序结束时，将%eax设置为0，然后调用leave。leave相当于调用mov%rbp,%rsp和pop%rbp，将栈恢复为最初的状态。然后调用ret返回。 其他函数返回时将栈恢复为调用该函数之前的状态，此时栈顶的元素就是调用该函数的指令的下一条指令的地址。然后执行该下一条指令即可。3.4本章小结本章着重介绍了编译的概念和作用，并且以hello.i到hello.s为例，分析了编译器是如何处理C语言的各个数据类型以及各类操作，包括字符串等各类数据，赋值操作，类型转换，算术操作，逻辑/位操作，关系操作，数组/指针/结构操作，控制转移，函数操作的内容。经过这部分的讨论与分析，对编译更加了解了。 第4章汇编4.1汇编的概念与作用编译完成生成hello.s文件后，驱动程序运行汇编器as，将hello.s翻译成一个可重定位目标文件hello.o，这个过程就是汇编。汇编的作用主要就是将编译的结果hello.s转化为机器可识别并执行二进制文件。4.2在Ubuntu下汇编的命令gcc-chello.s-ohello.o 4.3可重定位目标elf格式分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。1)可重定位目标文件的ELF格式简介ELF头包括16字节标识信息、文件类型、机器类型、节头表的偏移、表项大小及个数.text节编译后的代码部分.rodata节只读数据.data节已初始化的全局和静态C变量.bss节未初始化的全局和静态C变量.symtab节符号表，存放在程序中定义和引用的函数和全局变量的信息.rel.txt节一个.text节中位置的列表.rel.data节被模块引用或定义的所有全局变量的重定位信息.debug节一个调试符号表，条目是程序中定义的局部变量和类型定义.strtab节一个字符串表，内容包括.symtab和.debug节中的符号表，以及节头部中的节名字.line节原始C源程序中的行号和.text节中机器指令之间的映射Sectionheadertable（节头部表）每个节的节名、偏移和大小 2)读取可重定位目标文件的ELF格式命令：readelf-ahello.o>hello.elf 3)可重定位目标文件ELF格式的分析ELF头：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如X86-64）、节头部表的文件偏移，以及节头部表中条目的大小和数量。hello.o的ELF格式的ELF头如下图： 节头部表：详细标识了每个节的名称、类型、地址、偏移量、大小、读写权限、对齐方式等。如.text节，类型为PROGBITS，起始地址为0，偏移量为40，大小为85，属性为AX，即可装入可执行，对齐方式为1字节。 完整的节头部表如下图： .rel重定位节：在hello.elf里出现了重定位节.rela.text和重定位节.rela.eh_frame。它的内容有偏移量、信息、类型、符号值、符号名称、加数。在重定位节.rela.text中，可以看到符号名称有：.rodata，puts，exit，.rodata，printf，sleepsecs，sleep，getchar。具体数据如下图： .symtab节：存放在程序中定义和引用的函数和全局变量的信息，具体数据如下图： 这里存放了17个条目，可以看到序号为10到17的条目存放了全局变量sleepsecs，_GLOBAL_OFFSET_TABLE，以及各种函数：main，puts，exit，printf，sleep，getchar。4.4Hello.o的结果解析objdump-d-rhello.o>hello_objdump.txt 打开txt文件，发现它是根据.text节进行的反汇编。接下来分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。通过比较可以发现，在以下方面存在区别：控制转移的结构、全局变量的引用方式、函数调用的方法。1)控制转移的结构首先观察hello.s中的控制转移结构： 可以看到编译过程以.L1、.L2、.L3等名称来标记各个段，跳转指令直接描述需要跳转到的段的名称。再看反汇编得到的汇编代码： 可以看出是根据指令的位置相对于main函数地址的偏移量进行定位并且跳转的。2)全局变量的引用方式对全局变量sleepsecs的引用，两者也存在差别。在hello.s中，如下图，是根据段的首地址加%rip得到保存在%eax中，然后转递给%edi。 在hello.o反汇编得到的汇编代码中，如下图，看上去也是通过%rip加一个偏移量得到保存在%eax中，然后转递给%edi。但不同的是，这个偏移量是0。这是因为全局变量的地址在运行时通过重定位确定，在当前情况下通过0来占位。 3)函数调用的方法以sleep函数为例，在hello.s中，指令call后直接加函数名称。 在反汇编代码中，call后的地址就是该条指令下一条指令的地址，并没有函数的首地址。这是因为这些函数需要通过动态链接确定地址，所以当前只是在.rela.text重定位节中保留了函数的信息，等待动态链接进行调用。 最后来说明机器语言的构成，与汇编语言的映射关系。机器语言是一种二进制语言，每一条指令、数据都由二进制来表示。汇编语言用了助记符，对于很多指令的二进制编码，用一个字符串来表示，让程序员更容易读懂。另外反汇编代码不仅显示了汇编代码，还显示了二进制代码。综上可以认为机器语言和汇编语言的映射是一种双射。4.5本章小结本章着重介绍了汇编的概念和作用，并且以hello.s到hello.o为例，介绍并分析了可重定位目标文件的ELF格式，以及对hello.o的结果进行了解析，将编译的结果hello.s与对hello.o的反汇编代码hello_objdump.txt进行比较，了解了汇编代码和反汇编代码的一些结构和内容上的区别。通过这些讨论，增强了对汇编过程的理解。 第5章链接5.1链接的概念与作用汇编过程结束生成hello.o文件后，驱动程序运行链接器程序ld，将hello.o和其他一些必要的系统目标文件组合起来，创建一个可执行目标文件。这个过程就是链接。作用：链接可以将各种代码和数据片段收集并组合策划归纳为一个可以加载到内存并执行的单一文件。它使得分离编译成为可能，可以将一个大型的应用程序分解为更小，更好管理的模块，便于独立修改和编译。链接让程序员能够利用共享库，通过动态链接为程序提供动态内容。5.2在Ubuntu下链接的命令命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。1)可执行目标文件的ELF格式简介可执行目标文件的ELF格式与可重定位目标文件的ELF格式较为相似，稍有不同。ELF头字段e_entry给出执行程序时第一条指令的地址只读代码段程序头表结构数组.init节用于定义_init函数，该函数用来进行可执行目标文件开始执行的初始化工作.text节编译后的代码部分.rodata节只读数据.data节已初始化的全局和静态C变量读写数据段.bss节未初始化的全局和静态C变量.symtab节符号表，存放在程序中定义和引用的函数和全局变量的信息无需装入到存储空间的信息.debug节一个调试符号表，条目是程序中定义的局部变量和类型定义.strtab节一个字符串表，内容包括.symtab和.debug节中的符号表，以及节头部中的节名字.line节原始C源程序中的行号和.text节中机器指令之间的映射节头表每个节的节名、偏移和大小2)读取可执行目标文件的ELF格式命令：readelf-ahello>hello-run.elf 3)可执行目标文件ELF格式的查看ELF头标记了这是一个可执行文件，并且给定了入口点地址。 节头给定了各个部分的具体信息，具体地址。（由于节头过长不宜截图，所以这里仅为节头的一部分） 程序头表，给定了各个部分的具体信息，包括虚拟地址，物理地址。 5.4hello的虚拟地址空间使用edb加载hello，如下图： 根据下图，可以看出hello的虚拟地址从0x401000开始，到0x402000结束。 接下来将此与5.3中的节头进行对比。1).init节，起始地址0x401000，大小0x1b 2).plt节，起始地址0x401020，大小0x60 3).plt.sec节，起始地址0x401080，大小0x50 4).text节，起始地址0x4010d0，大小0x135 5).fini节，起始地址0x401208，大小0xd 5.5链接的重定位过程分析（以下格式自行编排，编辑时删除）objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。结合hello.o的重定位项目，分析hello中对其怎么重定位的。利用命令objdump-d-rhellohello-d-r.txt，将反汇编文件输出到txt文本中。1)hello与hello.o的不同以及链接的过程首先看到使用hello反汇编得到的文件中，对于每一条指令、节、函数，都有了一个以40开头的虚拟地址，和上一节在edb中看到的地址相同。而hello.o反汇编得到的文件中，在相应位置都是由相对偏移量来表示的。 可以观察到hello-d-r.txt比hello_objdump.txt要多出很多内容。包括.init节、.plt节、.plt.sec节、.fini节等。而hello_objdump.txt只有.text节。并且动态链接库里面的函数也已经在.plt.sec节中了，如下图： 链接的过程：1.符号解析。程序中有定义和引用的符号，存放在符号表.symtab节中。这是一个结构数组，存放在程序中定义和引用的函数和全局变量的信息。编译器将符号的引用存放在重定位节.rel.text节以及.rel.data节中，链接器将每一个符号的引用都与一个确定的符号定义建立关联。2.重定位。将多个代码段和数据段分别合并为一个完整的代码段和数据段，计算每一个定义的符号在虚拟地址空间的绝对地址而不是相对偏移量，将可执行文件中的符号引用处修改为重定位后的地址信息。 2)hello中如何重定位下图是链接器重定位算法的伪代码。假设每个节s是一个字节数组，每个重定位条目r是一个类型为Elf64_Rela的结构，定义如下。另外，假设算法运行时，链接器已经为每个节（用ADDR(s)表示）和每个符号都选择了运行时地址（用ADDR(r.symbol)表示）。算法首先计算需要被重定位的4字节引用的数组s中的地址。如果这个引用是PC相对寻址，则用第一个if结构进行处理。如果该引用使用的是绝对寻址，则通过第二个if结构处理。 接下来以函数sleep进行举例说明。在hello_objdump.txt中，函数main调用sleep函数。Call指令开始于节偏移0x6a的地方，包括1字节的操作码0xe8，后面跟着的是对目标sleep的PC相对引用的占位符。 在代码的重定位节.rela.text中，可以看到偏移量r.offset=0x6b，用于偏移调整的值r.addend=-4。 在hello的反汇编文件中，查找到sleep的首地址为0x4010c0，即ADDR(r.symbol)=0x4010c0。 最后ADDR(s)=0x401105。 由重定位算法，链接器首先计算出引用的运行时地址。refaddr=ADDR(S)+r.offset=0x401105+0x0x6b=0x401170。然后，更新该引用，使得它在运行时指向sleep函数。*refaddr=(unsigned)(ADDR(r.symbol)+r.addend-refaddr)=(unsigned)(0x4010c0+(-4)-0x401170)=(unsigned)(0xffffff4c)验证，与hello的反汇编结果一致。 5.6hello的执行流程使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。函数名地址<do_init>0x00007f3f02e9edf0<hello!_start>0x00000000004010d0libc-2.31.so!__libc_start_main>0x00007f3f02cbafc0<libc-2.31.so!__cxa_atexit>0x00007f3f02cddf60<hello!__libc_csu_init>0x0000000000401190<libc-2.31.so!_setjmp>0x00007f3f02cd9e00<hello!main>0x0000000000401105<hello!puts@plt>0x0000000000401030<hello!exit@plt>0x0000000000401060 5.7Hello的动态链接分析对于动态共享库中的PIC函数，编译器无法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任何位置，一般是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。编译器使用延迟绑定的技术将过程地址的绑定推迟到第一次调用过程时。延迟绑定通过GOT和过程链接表（PLT）这两个数据结构的交互来实现。GOT是数据段的一部分，PLT是代码段的一部分。GOT和PLT通过协作在运行时解析函数的地址。GOT和PLT在dl_init被第一次调用时，延迟解析它的运行时地址的步骤：1.不直接调用dl_init，程序调用进入PLT[2]，这是dl_init的PLT条目。2.第一条PLT指令通过GOT[4]进行间接跳转。因为每个GOT条目初始时都指向它对应的PLT条目的第二条指令，这个间接跳转只是简单地把控制传送回PLT[2]中的下一条指令。3.在把dl_init的ID压入栈中之后，PLT[2]跳转到PLT[0]。4.PLT[0]通过GOT[1]间接地把动态链接器的一个参数压入栈中，然后通过GOT[2]间接跳转进动态链接器中。动态链接器使用两个栈条目来确定dl_init的运行时位置，用这个地址重写GOT[4]，再把控制流传递给dl_init。下图是在命令行中用readelf命令查看.got.plt信息的结果，其首地址为0x404000，大小为0x40字节。 dl_init函数之前： 调用dl_init函数： dl_init函数之后： 对比这两个表，发现地址0x404008处的内容由0000000000000000变成了90c1ec023f7f0000。用小端法表示为00007f3f02ecc190。地址0x404010的内容由0000000000000000变成了b05beb023f7f0000。用小端法表示为00007f3f02eb5bb0。这里的变化是因为在程序调用函数dl_init前，编译器无法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。所以使用延迟绑定技术，将过程地址的绑定推迟到调用这个函数的时刻。在调用这个函数时，.got.plt的某些条目就发生了变化。5.8本章小结本章介绍了链接的概念和作用，以及以hello为例，分析了可执行文件的ELF格式、虚拟地址空间、将hello的反汇编文件和hello.o的反汇编文件进行比较，并举例计算了重定位的过程。经过这一部分的讨论，我对链接的过程更加理解了。 第6章hello进程管理6.1进程的概念与作用概念：进程就是一个执行中程序的实例。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。作用：在现代系统上运行一个程序时，进程会提供一个假象，好像我们的程序是系统中当前运行的唯一的程序一样。程序好像是独占地适用处理器和内存，处理器就好像是无间断地一条接一条地执行我们程序中的指令，而且程序中的代码和数据好像是系统内存中唯一的对象。进程提供给程序的关键抽象，一是一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地适用处理器。二是一个私有的地址空间，它提供一个假象，好像我们的程序独占地适用内存系统。6.2简述壳Shell-bash的作用与处理流程作用：shell最重要的功能是命令解释。shell是一个命令解释器。用户提交了一个命令后，shell首先判断它是否为内置命令，如果是就通过shell内部的解释器将其解释为系统功能调用并转交给内核执行；若是外部命令或使用程序就试图在硬盘中查找该命令并将其调入内存，再将其解释为系统功能调用并转交给内核执行。处理流程：shell打印一个命令行提示符，等待用户在stdin上输入命令行，然后对这个命令行求值。命令行求值的首要任务是调用parseline函数，这个函数解析了以空格分割的命令行参数，并构造最终会传递给execve的argv向量。第一个参数被假设为要么是一个内置的shell命令名，马上就会解释这个命令，要么是一个可执行目标文件，会在一个新的子进程的上下文中加载并运行这个文件。在解析了命令行之后，eval函数调用builtin_command函数，该函数检查第一个命令行参数是否是一个内置的shell命令。如果是，它就会易理解释这个命令，并返回值1。否则返回0，shell创建一个子进程，并在子进程中执行所请求的程序。如果用户要求在后台印象该程序，那么shell返回到循环的顶部，等待下一个命令行。否则，shell使用waitpid函数等待作业终止。当作业终止时，shell就回收子进程，并开始下一轮迭代。6.3Hello的fork进程创建过程父进程通过调用fork函数创建一个新的运行的子进程。fork函数只被调用一次，但会返回两次。一次是在调用进程中，一次是在新创建的子进程中。在父进程中，fork返回子进程的pid，在子进程中，fork返回0。创建过程：1.给新进程分配一个标识符。2.在内核中分配一个PCB（进程管理块），将其挂在PCB表上。3.复制它的父进程的环境（PCB中大部分的内容）。4.为其分配资源（程序、数据、栈等）。5.复制父进程地址空间里的内容（代码共享，数据写时拷贝）。6.将进程设置成就绪状态，并将其放入就绪队列，等待CPU调度。6.4Hello的execve过程execve函数在当前进程的上下文中加载并运行一个新程序。Intexecve(constchar*filename,constchar*argv[],constchar*envp[]);execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境遍历列表envp。只有当出现错误时，execve才会返回到调用程序。所以，execve调用一次并从不返回。在execve加载了filename后，调用启动代码，启动代码设置栈，并将控制转移传递给新程序的主函数。当main开始执行时，用户栈的组织结构如下。从栈底（高地址）往栈顶（低地址）依次观察。首先是参数和环境字符串。栈往上是以null结尾的指针数组，其中每个指针都指向栈中的一个环境变量字符串。全局变量environ指向这些指针中的第一个envp[0]。紧随环境变量数组之后的是以null结尾的argv[]数组，其中每个元素都指向栈中的一个参数字符串。在栈的顶部是系统启动函数libc_start_main的栈帧。 6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。进程的上下文：上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。进程时间片：一个进程执行它的控制流的一部分的每一个时间段叫做时间片。进程的调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。当内核选择一个新的进程运行时，就说内核调度了这个进程。当内核调度了一个新的进程运行后，它就抢占当前进程，并通过上下文切换的机制将控制转移到新的进程。上下文切换会保存当前进程的上下文，恢复某个先前被抢占的进程被保存的上下文，将控制传递给这个新恢复的进程。当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个时间发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。中断也可能引发上下文切换。用户态与内核态的转换：进程为hello程序分配了虚拟地址空间，并将hello的代码节和数据节分配到虚拟地址空间的代码区和数据区。首先hello在用户模式下运行，调用系统函数sleep，显式地请求让调用进程休眠。这时就发生了进程的调度。用户模式和内核模式的转换示意图如下： 6.6hello的异常与信号处理hello的异常（中断、陷阱）以及其处理方式。1.中断：中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。处理方式：在当前指令完成执行后，处理器注意到中断引脚的电压变高，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令。结果是程序继续执行，就像没有发生过中断一样。示意图如下： 2.陷阱：陷阱是有意的异常，是执行一条指令的结果。处理方式：陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。用户程序经常需要像内核请求服务，为了允许这些内核服务的受控的访问，处理器提供了一条特殊的“syscalln”指令每当用户程序想要请求服务n时，可以执行这条命令。执行syscall指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。示意图如下： 运行时按Ctrl-Z：内核发送一个SIGTSTP信号到前台进程组中的每个进程。默认情况下，结果是停止前台作业。 之后运行ps命令：ps命令用于显示当前进程的状态。 之后运行jobs命令：用于显示任务列表和任务状态。 之后运行pstree命令：查看进程树之间的关系。 之后运行fg命令：将后台作业（在后台运行或在后台挂起）放到前台运行。 之后运行kill-9%1命令：kill命令用于发送一个信号到一个进程。 重新运行时按Ctrl-C：内核发送一个SIGINT信号到前台进程组中的每个进程。默认情况下结果是终止前台作业。 运行过程中乱按键盘：不会影响程序的运行。 信号的处理：1.对于Ctrl-Z：内核发送一个SIGTSTP信号到前台进程组中的每个进程。默认情况下，结果是停止前台作业。2.对于Ctrl-C：内核发送一个SIGINT信号到前台进程组中的每个进程。默认情况下结果是终止前台作业。3.对于fg信号：将后台作业（在后台运行或在后台挂起）放到前台运行。4.对于kill命令发送的信号：信号编号是9，即SIGKILL，终止。kill-9%1是杀死后台hello程序。6.7本章小结这一章主要学习了异常控制流，进程，信号的处理。这一章的重要性在于讲述了应用是如何与操作系统交互的。这些交互都是围绕着ECF（异常控制流）的。从异常开始，异常位于硬件和操作系统交界的部分。系统调用是为应用程序提供到操作系统的入口点的异常。还有进程和信号，它们位于应用和操作系统的交界之处。学习这一章对于理解用户程序和系统内核的交互有重要的作用。 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：是在有地址变换功能的机器中访内指令给出的地址。也叫相对地址，也就是在机器语言指令中，用来指定一个操作数或是一条指令的地址。要经过寻址方式的计算才能得到内存储器中的实际有效地址。在hello中，生成的hello.o文件中的地址即偏移量，都是逻辑地址。线性地址：如果地址空间中的整数是连续的，那么就说它是一个线性地址空间。在这里讨论的线性地址就是虚拟地址。虚拟地址：是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。通常是一个32为无符号整数，可以用来表示4GB的地址。线性地址通常用十六进制数字表示。程序会产生逻辑地址，通过变换就可以生成线性地址，如果有分页机制，则线性地址可以再映射出一个物理地址。在hello中，对hello可执行文件进行反汇编得到的文本文件中的地址都是虚拟地址，在这里也就是线性地址。物理地址：真实的存储器中的地址，由CPU地址总线传来，硬件电路控制其具体含义。物理地址中很大一部分是留给内存条中的内存的，也常常被映射到其他的存储器上。在没有使用虚拟存储的机器上，虚拟地址被直接送到内存总线上，使用具有相同地址的物理存储器被读写。在使用了虚拟存储的机器上，虚拟地址经过MMU地址翻译后映射成为物理地址，在内存中进行读写。7.2Intel逻辑地址到线性地址的变换-段式管理逻辑地址向线性地址的转换过程如下图。逻辑地址包含16位的段选择符和32位的段内偏移量。MMU首先根据段选择符中的TI确定选择全局描述符表GDT还是局部描述符表LDT。确定描述符表后，再通过段选择符内的13位索引值从被选中的描述符表中找到对于的段描述符。因为每个段描述符占8个字节，所以位移量位索引值乘8，加上描述符表首地址，就可以确定选中的段描述符的地址，从中取出32位的基地址，与逻辑地址中32位的段内偏移量相加，就得到了32位线性地址。 通常情况下，MMU不需要到主存中访问GDT或LDT，只要根据段寄存器对于的描述符cache中的基地址、限界和存取权限来进行逻辑地址到线性地址的转换，如下图。 7.3Hello的线性地址到物理地址的变换-页式管理如下图。线性地址向物理地址的转换过程如下：首先，根据控制寄存器CR3给出的页目录表首地址找到页目录表，由DIR字段提供的页目录索引找到对应的页目录项；然后根据页目录项中的基地址指出的页表首地址找到对应的页表，再根据线性地址中间的页表索引找到页表中的页表项；最后将页表项中的基地址和线性地址中的12位页内偏移量组合成32位物理地址。 其中页目录项和页表项的格式如下图。 P：P=1表示页表或页在主存中；P=0表示页表或页不在主存中。R/W：该位为0时表示页表或页只能读不能写；为1时表示可读可写。U/S：该位为0时表示用户进程不能访问；为1时允许用户进程访问。PWT：用来控制页表或页对应的cache写策略是直写还是写回。PCD：用来控制页表或页能否被缓存到cache中。A：A=1表示指定页表或页被访问过，初始化时操作系统将其清0。D：脏位，只在页表项中有意义。D=1表示被修改过，否则表示为被修改，操作系统将页面替换出主存时，无须将页面写入硬盘。页目录项和页表项中的高20位是页表或页在主存中的首地址对应的页框号，即首地址的高20位。每个页表的起始位置都按4kb对齐。7.4TLB与四级页表支持下的VA到PA的变换TLB：翻译后备缓冲器，是在MMU中的一个关于PTE的小的缓存。TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。虚拟地址中用以访问TLB的组成部分如下。 TLB命中时的地址翻译步骤有：1.CPU产生一个虚拟地址。2.MMU从TLB中取出相应的PTE。3.MMU将这个虚拟地址翻译成一个物理地址，并将它发送到高速缓存或主存。4.高速缓存或主存将所请求的数据字返回给CPU。当TLB不命中时，MMU必须从L1缓存中取出相应的PTE。新取出的PTE存放在TLB中，可能回覆盖一个已经存在的条目。四级页表下的VA到PA的变换：下面是使用四级页表进行地址翻译的示意图。虚拟地址被划分位4个VPN和1个VPO。每个VPN都是一个到某一级页表的索引。36位VPN被划分为4个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 7.5三级Cache支持下的物理内存访问下图给出了在四级页表和三级cache下的物理内存访问示意图。四级页表下的虚拟地址到物理地址的转换已经有过阐述，接下来描述物理内存的访问。图中的L1cache有64组，八路组相连，每块64字节。所以块偏移CO是6位，组索引CI是6位，剩下的40位为标记CT。现有物理地址52位，低6位是CO，CO的左边高6位是CI，剩余的是CT。根据组索引CI，定位到L1cache中的某一组，遍历这一组中的每一行，如果某一行的有效位为1且标记位等于CT，则命中，根据块偏移CO取出数据。如果未命中，则向下一级cache寻找数据。更新cache时，首先判断是否有空闲块。如果有，则写入这个块，否则根据替换算法驱逐一个块后再写入。 7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数在当前进程中加载并允许包含了可执行文件hello中的程序，用hello程序有效地替代了当前程序。加载并允许hello需要以下一个步骤：1.删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。2.映射私有区域。为hello程序的代码、数据、bss和栈区域创建新的区域结构。3.映射共享区域。如果hello与共享对象或目标链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。4.设置程序计数器PC。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux根据需要换入代码和数据页面。下面是加载器如果映射用户地址空间的区域的示意图。 7.8缺页故障与缺页中断处理在异常控制流中学过，缺页异常是一种经典的故障。发生故障时，处理器将控制转移给故障处理程序。如果处理程序额能够修正这个错误的情况，它就将控制返回到引起故障的指令，重新执行。否则处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。 一般的缺页情况如下：CPU引用了VPi中的一个字，VPi并未缓存在物理内存中。地址翻译硬件从内存中读取PTEi，从有效位推断出VPi未被缓存，并且触发了一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序选择一个牺牲页，假设是VPj。如果VPj已经被修改了，那个内核就会将它复制回磁盘。无论那种情况，内核都会修改VPj的页表条目，反应出VPj不再缓存在主存中。接下来，内核从磁盘复制VPi到内存中的PPi，更新PTEi，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。现在，VPi已经缓存在主存中了，那么页命中页能由地址翻译硬件正常处理了。7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护者一个变量brk，指向堆的顶部。堆的示意图如下。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。一个已分配的块保持已分配状态，直到它被释放。分配器有两种基本风格，显式的和隐式的。显式分配器，要求应用显式地释放任何已分配的块。如C标准库提供的malloc程序包显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。隐式分配器，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。一个实际的分配器需要考虑以下几个问题：1.空闲块组织：如何记录空闲块？2.放置：如何选择一个合适的空闲块来放置一个新分配的块？3.分割：在将一个新分配的块放置到某个空闲块之后，如何处理这个空闲块中的剩余部分？4.合并：如何处理一个刚刚被释放的块？一种较为简单的叫隐式空闲链表的数据结构可以较好地解决这些问题。结构示意图如下： 每一个堆块内有一些字，每个字有4个字节。第一个字记录这个堆块的大小，以及是已分配的还是空闲的。这里介绍的堆块是双字对齐的，所以块大小一定为8的倍数，二进制的低第三位是0。所以用最低位来表示这个块是以分配的还是空闲的。有效载荷就是用户申请的空间，填充是不使用的，大小任意，填充可能是分配器策略的一部分，用来对付外部碎片，或者用它来满足对齐要求。动态存储的分配管理主要包括以下几个操作：1.放置已分配的块当应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大的可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略确定的，有首次适配、下一次适配、最佳适配等。首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配：从上一次查询结束的地方开始搜索。最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块。2.分割空闲块一旦分配器找到一个匹配的空闲块，就必须考虑分配这个空闲块中的多少空间。如果匹配不太友好，则分配器通常会选择将这个空闲块分割为两部分。第一部分变成分配块，剩下的部分变成一个新的空闲块。例如，目前的堆情况如下图所示： 现在有一个3个字的分配请求，因为第一个空闲块空间不够，所以将第二个空闲块分割来分配。分配情况如下图，红色方框的位置即为新分配的块。第一个字保存这个分配块的信息，后三个字保存有效载荷。 3.获取额外的堆内存如果分配器不能为请求块找到合适的空闲块，可以通过合并那些在内存中物理相邻的空闲块来创建一个更大的空闲块。如果这样还是不能生成一个足够大的块，则分配器会调用sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化为一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。4.合并空闲块当分配器释放一个已分配块石，可能有其他空闲块与这个新释放的空闲块相邻，如下图所示。 可以看到，有两个相邻的空闲块。此时如果请求一个4字的空闲块，分配器发现当前的空闲块无法满足要求，就会合并空闲块，将上图中两个相邻的空闲块合并成为一个大的空闲块。有一中更加优化的数据结构能够在常数时间内进行合并。 相比于前面的隐式空闲链表结构，这种结构在块的尾部有一个头部的副本，这样无论是从当前的块向前还是向后合并，都可以检查前一个块或者是后一个块是否是空闲的。如果是，就将它的大小简单地加到当前块头部的大小上，使得这两个块在常数时间内被合并。7.10本章小结本章重点介绍了计算机中的存储，包括地址空间的分类，地址的变换规则，虚拟内存的原理，cache的工作，和动态内存的分配。虚拟内存存在于磁盘中，处理器产生一个虚拟地址，然后虚拟地址通过页表映射等相关规则被转化为物理地址，再通过cache和主存访问物理地址内保存的内容，返回给处理器。通过这一章的学习和总结，我对于计算机的存储方式、缓存、寻址更加理解了。 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件。一个linux文件就是一个m个字节的序列。所有的IO设备都被模型化为文件，包括网络、磁盘、终端等。设备管理：unixio接口。所有的IO设备都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许linux内核引出一个简单、低级的应用接口，成为unixIO，这使得所有的输入和输出都能以一种统一且一致的方式来执行。8.2简述UnixIO接口及其函数Unixio接口：打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）、标准错误（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。改变当前文件的位置。对于每个打开的文件，内核保持着一个文件位置k，初始0.这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。UnixIO函数：open()函数。进程通过调用open函数来打开一个已存在的文件或者创建一个新文件。函数原型：intopen(char*filename,intflags,mode_tmode);open函数将filename转换成一个文件描述符，并且返回描述符字。返回的描述符总是在进程中当前没有的打开的最小描述符。flags参数指明了进程打算如何访问这个文件。close()函数。进程通过调用close函数关闭一个打开的文件。函数原型：intclose(intfd);若返回成功则为0，若出错则为-1。read()函数和write()函数。read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。函数原型：ssize_tread(intfd,void*buf,size_tn);write函数从内存位置buf复制至多n个字节到描述符fd的当前位置。函数原型：ssize_twrite(intfd,constvoid*buf,size_tn);若成功则返回写的字节数，若出错则返回-1。lseek函数。通过调用lseek函数，应用程序能够显式地修改当前文件的位置。函数头文件和原型如下。#include<sys/types.h>#include<unistd.h>off_tlseek(intfd,off_toffset,intwhence);它能够调整读写的位置。若调用成功，则返回当前读写位置相对于文件开始位置的偏移量。若调用失败，则返回-1，并给errno设置错误号。8.3printf的实现分析printf函数的函数体：intprintf(constcharfmt,…){inti;charbuf[256]; va_listarg=(va_list)((char)(&fmt)+4); i=vsprintf(buf,fmt,arg);write(buf,i); returni;}fmt是一个指针，指向第一个const参数中的第一个元素。((char*)(&fmt)+4)表示的是…中的第一个参数的地址。接下来是vsprinff(buf,fmt,arg)。vsprintf函数如下：intvsprintf(char*buf,constcharfmt,va_listargs){charp;chartmp[256];va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!='%'){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); }vsprintf返回的是要打印出来的字符串的长度，作用是格式化，它接受确定输出格式的格式字符串fmt，用格式字符串对个数变化的参数进行格式化，产生格式化输出。下一步是write(buf,i)。通过反汇编跟踪，发现这里是给几个寄存器传递了参数，然后一个int结束。这样的int表示要调用中断门了。通过中断门，来实现特定的系统服务。可以找到INT_VECTOR_SYS_CALL的实现：init_idt_desc(INT_VECTOR_SYS_CALL,DA_386TGate,sys_call,PRIVILEGE_USER);它表示通过系统来调用sys_call这个函数。它的实现如下：sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret开头的一个callsave，是为了保存中断前进程的状态。sys_call的功能就是显示格式化了的字符串。到这里，printf的底层实现就基本结束了。字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析getchar由宏实现：#definegetchar()getc(stdin)。getchar有一个int型的返回值。当程序调用getchar时，程序就等着用户按键。用户输入的字符被存放在键盘缓冲区中。直到用户按回车为止。当用户键入回车之后，getchar才开始从stdin流中每次读入一个字符。getchar函数的返回值是用户输入的字符的ASCII码，若文件结尾则返回-1(EOF)，且将用户输入的字符回显到屏幕。如用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中，等待后续getchar调用读取。也就是说，后续的getchar调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才等待用户按键。异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章着重介绍了Linux的IO设备管理方法，UnixIO接口及其函数，以及printf,getchar的实现和工作过程。这增强了对平时经常调用的一些函数的理解。 结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。hello.c编写完成后，要运行需要经过一下几个步骤：1.hello.c经过预处理，生成文本文件hello.i。2.hello.i经过编译，生成汇编文件hello.s。3.hello.s经过汇编，生成二进制可重定位目标文件hello.o。4.hello.o经过链接，生成可执行文件hello。到这里，hello已经可以成功运行了。在hello的运行过程中，涉及到调用fork函数生成子进程，并有execve函数加载并运行程序。在访存等过程中，涉及到存储管理，包括利用局部性的高速缓存cache和虚拟内存。涉及到输入输出时，又会利用IO管理，设备模拟化为文件等等。总之，hello.c虽然只是一个简单的程序，但从它的编写完成到执行，再到终止，经过了一系列复杂的过程。通过学习计算机系统这门课，像编译、存储、进程并行并发等知识，尤其是编译那一部分，编译器的功能如此的强大，我深深地体会到了计算机科学的伟大。计算机科学当前发展了几十年，汇聚了各路科学家的智慧，在人类社会发挥这越来越重要的作用。在计算机系统、底层的领域一定还会有更加具有智慧的突破出现。 附件列出所有的中间产物的文件名，并予以说明起作用。hello.i对hello.c进行预处理得到的文件hello.s对hello.i进行编译得到的文件hello.o对hello.s进行汇编得到的文件hello对hello.o进行链接得到的可执行文件hello.elfhello.o的ELF格式hello-run.elfhello的ELF格式hello_objdump.txt对hello.o进行反汇编得到的文件hello-d-r.txt对hello进行反汇编得到的文件 参考文献为完成本次大作业你翻阅的书籍与网站等[1]RandalE.Bryant,DavidR.O’Hallaon.深入理解计算机系统.第三版.北京市：机械工业出版社[M].2018：1-737.[2]物理地址、虚拟地址（线性地址）、逻辑地址以及MMU的知识.CSDNhttps://blog.csdn.net/macrossdzh/article/details/5.[3]lseek函数，lseek函数详细说明，函数原型和头文件，lseek函数的详细使用，补充命令（文件IO）[linux]。https://blog.csdn.net/qq_43648751/article/details/104133348[4]printf函数实现的深入剖析。https://www.cnblogs.com/pianist/p/3315801.html。[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 
第378篇文章[]
软件构造（二）checkRep遍历迭代器时死循环可能是因为assert没有设置开启 privatevoidcheckRep(){ Iterator<String>It1=set.iterator(); while(It1.hasNext()){ assertIt1.next()!=null; } } 第一次写checkRep的时候写成类似上面的格式，结果发现运行的时候如果It1.next的key为null，结果就会死循环，不能从while中退出。 后来发现是一个很愚蠢的错误。在eclipse中assert功能是默认关闭的，需要自己在设置中打开。 在新版本的eclipse中从菜单栏打开Run-RunConfigurations… 然后再在右边找到Arguments，在下面VMarguments里输入-ea，点击Run，就能解决问题。 
第379篇文章[]
软件构造（三）JAVA中ArrayList对自定义类的自然排序 在做软件构造lab3实验的时候，为了想让时间段，按照起始时间的大小从低到高排序，尝试了比较器。 publicclasstimeBlockimplementsComparator{ privatelongbegin; privatelongend; publictimeBlock(longbegin,longend){ this.begin=begin; this.end=end; } publiclonggetBegin(){ returnthis.begin; } publiclonggetEnd(){ returnthis.end; } @Override publicStringtoString(){ return"("+this.begin+"->"+this.end+")"; } @Override publicintcompare(Objecto1,Objecto2){ if(((timeBlock)o1).getBegin()>((timeBlock)o2).getBegin()) return1; elseif(((timeBlock)o1).getBegin()<((timeBlock)o2).getBegin()) return-1; else return0; } } publicclassMain2{ Set<String>set=newHashSet<>(); publicstaticvoidmain(String[]args){ List<timeBlock>set=newArrayList<>(); timeBlocka=newtimeBlock(4,10); timeBlockb=newtimeBlock(2,15); timeBlockc=newtimeBlock(15,19); set.add(a); set.add(b); set.add(c); set.sort(Comparator.naturalOrder()); System.out.println(set); } } 但是发现sort处出现了这样的错误信息。 后阅读Comparator.naturalOrder()的spec，发现要求自定义类必须实现Comparable的接口才能使用Comparator.naturalOrder()来进行自然排序，同理Comparator.reverseOrder()也是一样。 于是对代码修改以实现Comparable publicclasstimeBlock2implementsComparable<Object>{ privatelongbegin; privatelongend; //20210622151943 /** *forbuildatimeBlock *@parambeginpositive *@paramendshouldbelargerthanbegin */ publictimeBlock2(longbegin,longend){ this.begin=begin; this.end=end; } publiclonggetBegin(){ returnthis.begin; } publiclonggetEnd(){ returnthis.end; } @Override publicStringtoString(){ return"("+this.begin+"->"+this.end+")"; } @Override publicintcompareTo(Objecto){ if(this.begin<((timeBlock2)o).getBegin()) return-1; elseif(this.begin>((timeBlock2)o).getBegin()) return1; elseif(this.end<((timeBlock2)o).getEnd()) return-1; else return0; } } publicclassMain2{ Set<String>set=newHashSet<>(); publicstaticvoidmain(String[]args){ List<timeBlock2>set=newArrayList<>(); timeBlock2a=newtimeBlock2(4,10); timeBlock2b=newtimeBlock2(2,15); timeBlock2c=newtimeBlock2(15,19); set.add(a); set.add(b); set.add(c); set.sort(Comparator.naturalOrder()); System.out.println(set); } } 同理在sort中传入参数Comparator.reverseOrder()也可以实现逆向排序。 实际上ArrayList.sort传入的那个参数是一个比较器，并利用compare函数进行sort。所以我们也可以通过自己写compare函数来实现想要的比较方法，例如想进行逆向排序,就直接向sort传一个参数，要求他实现Comparator接口，并Ovrridecompare方法使得反向排序即可 publicclasstimeBlockimplementsComparator{ privatelongbegin; privatelongend; publictimeBlock(longbegin,longend){ this.begin=begin; this.end=end; } publiclonggetBegin(){ returnthis.begin; } publiclonggetEnd(){ returnthis.end; } @Override publicStringtoString(){ return"("+this.begin+"->"+this.end+")"; } @Override publicintcompare(Objecto1,Objecto2){ if(((timeBlock)o1).getBegin()>((timeBlock)o2).getBegin()) return-1; elseif(((timeBlock)o1).getBegin()<((timeBlock)o2).getBegin()) return1; else return0; } } publicclassMain2{ Set<String>set=newHashSet<>(); publicstaticvoidmain(String[]args){ List<timeBlock>set=newArrayList<>(); timeBlocka=newtimeBlock(4,10); timeBlockb=newtimeBlock(2,15); timeBlockc=newtimeBlock(15,19); set.add(a); set.add(b); set.add(c); set.sort(newtimeBlock(0,1)); System.out.println(set); } } 
第380篇文章[]
软件构造（五）java中privatepublicprotectedstaticfinal关键字的作用 private private关键字，只有在本类之中可以被直接修改。 protected 如果一个类中变量或方法有修饰字protected，同一类、同一包可以使用。不同包的类要使用，必须是该类的子类才能存取变量或调用。 public 任何类和对象都可以引用。 注：如果前面不加public，private和final，那么只能被同包内的类和对象引用。 static static修饰的类成员变量和类成员方法，只能被类调用，将作为类变量，可以不依靠创建对象来调用。比如静态工厂方法可以用来生成对象。但是该类的某一特定对象，也可以通过this.访问类的静态变量和静态方法。 static无法方法内的局部变量。 final final修饰的变量：不能修改引用。 例如：对于immutable的类型，如int，String。不允许修改变量的值。 对于mutable的类型，如ArrayList，可以继续向其中添加或者修改元素，但是不能将新的ArrayList赋值给变量，否则会在编译阶段报错。 当用final作用于类的成员变量时，成员变量必须在定义时或者构造器中进行初始化赋值。 final修饰的方法：不能被Override final修饰的类：不能被继承。final类中的成员方法将被视作final类型。 参考和引用： https://blog.csdn.net/findaway123/article/details/7604676 https://blog.csdn.net/u012723673/article/details/80580011 
第381篇文章[]
软件构造（四）Eclipse报错：AJNIerrorhasoccurred,pleasecheckyourinstallationandtryagain. 如果出现这个问题，并且正常java安装没问题可能主要的问题是Eclipse中设置的Compiler版本和JRE不一致。如果不一致哪怕重新装多少遍jdk估计也没辙。 JRE的版本，在工程目录中就可以直接看到，而Compiler的版本，可以右键选中工程project图标，然后选择properties JavaCompiler在右边可以看到编译器版本是9，并且可以在下拉栏中修改。 而我的Library版本是jdk1.8，所以需要将编译器版本也修改到1.8. 在properties JavaBuildPath中也可以对libraryremove和add的方式进行更换 
第382篇文章[1]
Hello的一生 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190202111 班 级 1936601 学 生 付一丁 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文介绍了C代码hello.c从一个C文件转化为一个进程、进程从产生到结束的全过程。中间夹杂着与之相关的知识点总结，是对这学期学过的知识的一次汇总。 关键词：预处理；编译；汇编；链接；进程；存储；IO 目 录 第1章概述 -5- 1.1Hello简介 -5- 1.2环境与工具 -5- 1.2.1硬件环境 -5- 1.2.2软件环境 -5- 1.3中间结果 -5- 1.4本章小结 -6- 第2章预处理 -7- 2.1预处理的概念与作用 -7- 2.2在Ubuntu下预处理的命令 -7- 2.3Hello的预处理结果解析 -8- 2.4本章小结 -10- 第3章编译 -11- 3.1编译的概念与作用 -11- 3.2 在Ubuntu下编译的命令 -11- 3.3Hello的编译结果解析 -11- 3.4本章小结 -19- 第4章汇编 -20- 4.1汇编的概念与作用 -20- 4.2在Ubuntu下汇编的命令 -20- 4.3可重定位目标elf格式 -20- 4.4Hello.o的结果解析 -20- 4.5本章小结 -24- 第5章链接 -26- 5.1链接的概念与作用 -26- 5.2在Ubuntu下链接的命令 -26- 5.3可执行目标文件hello的格式 -26- 5.4hello的虚拟地址空间 -28- 5.5链接的重定位过程分析 -29- 5.6hello的执行流程 -31- 5.7Hello的动态链接分析 -31- 5.8本章小结 -32- 第6章hello进程管理 -34- 6.1进程的概念与作用 -34- 6.2简述壳Shell-bash的作用与处理流程 -34- 6.3Hello的fork进程创建过程 -35- 6.4Hello的execve过程 -35- 6.5Hello的进程执行 -36- 6.6hello的异常与信号处理 -37- 6.7本章小结 -41- 第7章hello的存储管理 -42- 7.1hello的存储器地址空间 -42- 7.2Intel逻辑地址到线性地址的变换-段式管理 -43- 7.3Hello的线性地址到物理地址的变换-页式管理 -44- 页式管理是一种内存空间存储管理的技术，页式管理分为静态页式管理和动态页式管理。 -44- 7.4TLB与四级页表支持下的VA到PA的变换 -44- 7.5三级Cache支持下的物理内存访问 -46- 7.6hello进程fork时的内存映射 -47- 7.7hello进程execve时的内存映射 -47- 7.8缺页故障与缺页中断处理 -48- 7.9动态存储分配管理 -49- 7.10本章小结 -50- 第8章hello的IO管理 -51- 8.1Linux的IO设备管理方法 -51- 8.2简述UnixIO接口及其函数 -51- 打开、关闭文件 -51- 读、写文件 -51- 改变当前的文件位置 (seek)-52- 8.3printf的实现分析 -52- 8.4getchar的实现分析 -54- 8.5本章小结 -55- 结论 -55- 附件 -56- 参考文献 -57- 第1章概述 1.1Hello简介 hello从一段C代码，经过预处理变成hello.i，插入头文件，替换宏定义等等。又经过编译器变成汇编程序文本，经过汇编器变成可重定位目标文件。最后经过链接器变成可执行目标程序。 在可执行目标程序运行后，hello完成了从程序到进程的过程，在hello运行的过程中，涉及到了进程与信号的管理，内存的管理和分配，IO的管理，最后执行完毕后被系统回收，正式完成了从无到有，从有又重新化为零的过程。 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 1.2.1硬件环境 X64CPU；2.59GHz；16GRAM；512GHDDisk1.2.2 1.2.2软件环境 Windows1064位；VMwareWorkstation16Player(版本：16.1.0)；Ubuntu20.04.2LTS64位；VMwareWorkstationPro16，gcc，gdb，edb。 1.3中间结果 hello.i cpphello.c >hello.i hello.c经过预处理器(cpp),生成的修改了的源程序(文本)，将系统头文件插入程序文本，将宏定义替换程序文本。 hello.s gcc-Shello.c-ohello.s gcc运行编译器，产生一个汇编文件hello.s hello.o as hello.s–ohello.o hello.s汇编生成hello.o Hello.s objdump-d-rhello.o>Hello.s hello.o反汇编生成的Hello.s hello ld-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o-lc/usr/lib/x86_64-linux-gnu/crtn.o-zrelro-ohello 链接生成。 1.4本章小结 这里作为序言部分，概括的介绍了hello的一生需要经历的过程，后面附有实验运行环境和中间结果文件。 第2章预处理 2.1预处理的概念与作用 预处理器(cpp)根据以字符开头#开头的命令，修改原始的C程序。比如hello.c中的第一行的#include命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件扩展名。 预处理的三种主要作用： 宏定义 在预处理过程中会进行宏展开：将宏名替换成字符串，除了一般的字符串替换，还要做参数代换。但是宏替换只是做替换，不会去计算和求表达式的解。 文件包含 将多个源文件连接成一个源文件进行编译。将头文件插入程序文本中。 条件编译根据条件编译的指令（#if，#elif#else#endif等等），选择需要编译的代码送到编译器进行编译。 除此之外还会进行删除注释内容，处理#error（预处理过程中遇到#error停止编译输出用户自定义的错误信息，经常与条件编译的指令一起使用）等行为。 2.2在Ubuntu下预处理的命令 cpphello.c >hello.i 图1 预处理指令执行截图 生成hello.i 图2 生成hello.i 2.3Hello的预处理结果解析 我们可以看到相比于hello.c代码量增加了不少。这些都是在编译预处理过程中插入头文件的代码。 在hello.c中头文件有三个 图3 hello.c头文件 在这里截取这三个头文件在hello.i中的出现以证明插入。 图4 hello.i中的stdio.h 图5 hello.i中的stdlib.h 图6 hello.i中的unistd.h 但是在实际执行的过程中，我们根据地址找到stdio.h文件，stdio.h的内部也有需要include的头文件，预处理过程会将他们全部插入到文本中，类似递归的操作直到最后没有文本需要插入为止。 图7 hello.i中的stdio_lim.h 这是在hello.i中找到在stdio.h中include的stdio_lim.h 图8 hello.i中的stdio.h 其他头文件的插入过程与这个类似。 除此之外，我们发现并不能找到原本位于hello.c中我们写的注释，说明注释在预处理过程中被删除了 图9 注释已删除 2.4本章小结 预处理是hello.c向进程转化的第一步，在这个过程中hello插入必要的文件，执行了替换操作，删除了不必要的注释内容，选择了合适的条件编译部分，为编译做好了准备。 第3章编译 3.1编译的概念与作用 编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言文件程序。 编译的作用： 编译器将高级语言的声明、表达式、过程(函数)翻译成低级(底层)的指令序列。 在编译过程中编译器主要做了以下事情：扫描（词法分析）、语法分析、语义分析。在程序检查无错误之后，会将相应的高级语言转化成对应的汇编语言。而在这个过程中可以根据编译的选项或者实际需要对代码进行不同程度的优化。较高级别的优化能够提升程序的性能，但是也会使得程序变得令人难以理解。 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 在Ubuntu下编译的命令 gcc-Shello.c-ohello.s 图10 编译 3.3Hello的编译结果解析 观察hello.s,我们可以找到main函数 图11 hello.s 3.3.1 变量与常量 全局变量 观察全局变量sleepsecs在汇编代码中的表示 图12 sleepsecs 我们可以hello.s中查找到，观察知，它被赋值为2。 局部变量 观察hello.c中的局部变量i，观察以下两行，可知 图13 局部变量i 可知局部变量保存在-4(%rbp)的位置上，局部变量保存在栈中。 argc保存在-20(%rbp)。 图14 argc argv[1]保存在-24(%rbp) argv[2]保存在-16(%rbp)。通过观察rdx和rsi中保存值的由来可知。 图15 argv 常量 列举hello.c中存在的常量在汇编语言中的表示。 图16 常量sleepsecs 这里是将2赋值给全局变量sellpsecs的常数2. 图17 常数3 对应hello.c第16行常数3 图18 常数9 循环变量判断是否小于0，被转化成了判断是否小于等于9. 图19 exist(1) 一些字符串常量： 图20 字符串常量1 图21 printf参数常量 3.3.2 数组/指针/结构 argv[1]保存在-24(%rbp) argv[2]保存在-16(%rbp)。通过观察rdx和rsi中保存值的由来可知。 图21 argv 我们可以知道argv是char**类型，所以起始地址位于-32(%rbp)也就是argv[0]而角标每加一相当于地址加8. 3.3.3 赋值运算 图22 赋值 通过movl命令实现。 3.3.4 类型转换 图23 强制类型转换 在hello.c中原本给sleepsecs赋值2.5但是由于sleepsecs是int类型所以转化为赋值2. ​​​​​​​ ​​​​​​​3.3.5 关系操作 图24 比较== 图25 比较<= 用cmp命令来实现。 ​​​​​​​​​​​​​​ ​​​​​​​3.3.6 控制转移 图26 if(argc!=3) 图27 for循环控制 框起来三部分实现for(i=0;i<10;i++),37行实现i=0，53行实现i++，55和56行实现i<=9的判断和进入循环体。38行实现第一次判断。 函数操作传参 图28 main函数传参argc和argv 图29 printf传参 图30 sleep传参 图31 exist传参 图32 puts传参 函数调用 图33 函数调用 函数返回 上图61行main函数返回。 此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~3.3.x等按照类型和操作进行分析，只要hello.s中出现的属于大作业PPT中P4给出的参考C数据与操作，都应解析。 3.4本章小结 根据对变量、常量，函数、操作符等等的解析，我们理解了他们在汇编代码中的表示形式，也逐渐掌握了汇编代码的含义。hello.c正逐渐向着可执行的目标文件转换。 第4章汇编 4.1汇编的概念与作用 汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数marin的指令编码。 汇编作用：将hello.s中的汇编语言翻译成机器语言指令，生成可重定位目标文件。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。 4.2在Ubuntu下汇编的命令 as hello.s–ohello.o 应截图，展示汇编过程！ 图34 汇编 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 图35 反汇编 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 这里之前写错写的HELLO.O后来重新执行了正确的命令 objdump-d-rHello.s 4.4.1 汇编语言与机器语言的对应关系 我们可以通过观察发现，机器语言指令和汇编语言指令是逐行一一对应的。一条汇编指令对应一条机器指令。机器指令在计算机内是以二进制串的形式表示，但是这里为了方便阅读表示为按字节断的十六进制数。 4.4.1 GCC汇编代码和反汇编生成的汇编代码的一些语法不同 我们可以观察到发挥便生成的汇编代码和GCC生成的汇编代码是有一定的区别的。它省略了很多指令末尾的’q’。这些后缀是大小提示符，在大多数情况中可以省略。相反，反汇编器给call和ret指令添加了’q’后缀，同样省略这些后缀也没有问题。另外，在GCC生成的汇编代码中，使用的常数是十进制，在反汇编生成的代码中被转换成了十六进制。 图36 汇编代码 图37 反汇编代码 4.4.2 机器语言的构成 机器语言是由操作码和操作数构成。以上图的第7e行命令为例，其中后四位就是操作数，前面的是操作码。 4.4.3 机器语言和汇编语言操作数的不同。 在汇编语言中，调用全局变量的时候，是用段的名字，或者全局变量的名字在加上rip的值来寻址 图38 汇编代码寻址 但是在转换成机器语言之后 图39 反汇编代码寻址 会用0占位，并且标记在段中的偏移量，等待链接之后确定真实的地址。 4.4.4 分支转移 在汇编代码中，通过跳转到段名所标记的位置的方式来确定跳转的位置 图40 汇编跳转 在汇编语言中通过计算现在跳转的指令相对于函数开头的偏移量来实现。 图41 反汇编跳转 4.4.5 函数调用 在汇编语言中，函数调用是直接调用函数的名字 图42 汇编函数调用 在机器语言中，函数调用的指令的操作数暂时被填0占位，因为只有链接之后才能确定具体的地址。我们观察右侧的反汇编代码，可以看到这个地址用相对当前地址的偏移量表示 图43 反汇编函数调用 4.5本章小结 在汇编过程中，hello由汇编代码转换为了机器代码。但是还是有很多地方没有确定：与其他文件还没有建立联系，目前由于地址没有确定所以在跳转，调用函数和全局变量中使用的地址还是暂时占位的地址。而这些需要在接下来的步骤中实现。 第5章链接 5.1链接的概念与作用 链接是将各种代码是数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存中并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的，在现代计算机系统中，链接是由叫链接器的程序自动执行的。 注意：这儿的链接是指从hello.o到hello生成过程。 5.2在Ubuntu下链接的命令 ld-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o-lc/usr/lib/x86_64-linux-gnu/crtn.o-zrelro-ohello 图44 链接 使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 执行readelf-ahello 查看各段信息。 图45 节头表 图46 节头表后半 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 用edb打开文件，发现能够根据在readelf中看到的地址在edb中查找到对应位置。 图48 edb查看虚拟内存 图49 查看内存区域 打开memoryregions窗口，可以看到这里标记着不同部分的程序的信息的位置。我们根据之前readelf看到的头部表，可以发现他们位于0000000000400000所在的区间里，我们只需要在memoryregions点击就能跳转到这个内存区域，然后再在DataDump里根据地址查找我们想看的不同段的信息。 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 执行上述命令。 图50 hello.s 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 图51 全局变量、地址与重定位 比较这两处可以发现，在链接过程中，成功确定了全局变量的位置，给与了它真实的地址并且将其填写到这里，覆盖原本用来占位的0. 而且观察前面每行汇编命令的地址。Hello.s中只是相对于开头的偏移量。而在重定位之后，给予了每条语句确切的地址。 分支转移 图52 分支转移 可以看到在分支处跳转的时候，也将偏移量替换成了虚拟地址。 函数调用 图53 函数调用 函数调用的时候也将替换成了虚拟地址。 除去这些之外在重定位之后代码显著边长将链接前各个文件中的内容汇合在了一起。 5.6hello的执行流程 图54 按顺序列出函数 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 我不太明白如何用edb列出所有函数调用，但是我可以用gdb实现这个任务。 5.7Hello的动态链接分析 共享库是一个致力于解决静态库缺陷的现代创新产物。共享库是一个目标模块，在运行或者加载的时候，可以加载到任意内存地址，并和一个在内存中的程序链接起来执行的。共享库也被称为共享目标在linux里通常用.so后缀来表示。 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 我们观察函数.got.plt，在gdb中的地址。 图55 查看.got.plt 图56 运行前 图57 运行后 发现0x404000附近的值发生了变化。hello程序有很多函数需要共享调用，比如puts，等等，GNU使用延迟绑定的方法来处理这种情况，将过程地址的绑定退出到第一次调用的时候。在加载之后，动态链接器重定位GOT中的条目，使得它指向绑定后的正确的地址，也就是7f8f0b34abb0。 5.8本章小结 经过一系列程序hello终于在链接之后变成可以执行的可执行文件，在链接的过程中进行了符号解析和重定位，将各个需要的代码和数据片段合并到了一起，成为一个完整的，可以运行的程序。因为链接的存在，我们可以在开发的时候分别对不同文件开发，编译，而不需要每次对整个工程进行编译，极大地提高了开发的小笼包和管理的成本。 接下来可执行目标文件hello，将要正式走向运行。 第6章hello进程管理 6.1进程的概念与作用 在现代系统上运行一个程序的时候，我们会得到一个假象，就好像我们的程序是系统当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的命令。最后我们程序中的代码和数据就好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都在运行在某个进程的上下文当中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。每次用户通过shell输入一个可执行文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个进程的上下文中运行它们自己的代码或其他应用程序。 6.2简述壳Shell-bash的作用与处理流程 bash原来就是能够解释从标准输入和文件的命令，能够让人通过键盘输入特定命令的方式，调用相应的应用程序。 我们可以通过观察linux的进程树来理解bash的处理流程 在调用一次pstree之后 图58 pstree 我又输入了一次/bin/bash 图59 pstree(2) 可以看出来在进程树中bash创建了一个新进程bash，然后在新进程中衍生创建出了进程pstree。这个个多出来的中间的bash，就是我刚刚输入命令/bin/bash创建出来的。 在bash执行的时候，如果遇到fork()，将会派生出一个子进程，大致如下图。 图60 进程图 shell在处理的过程中，先打印一个标识符，表明在等待用户输入命令行(在ubuntu下通常为#或者$)。然后用户输入命令字符串。shell程序会调用parseline函数对这个字符串进行解析，拆解以空格分割命令中的词，存入argv数组。假设数组的第一个词是一个系统内置命令，那么shell将会立刻执行该命令。假设最后一个参数为’&’,那么这个程序将会转入后台执行，parseline返回1，否则返回0，表示应该在前台处理这个程序。 如果最后发现不是系统内置命令而是需要执行一个可执行文件，那么shell将会新创建一个子进程，并在这个子进程中去运行这个可执行文件。如果子进程终止，那么shell需要对僵尸进程进行回收。 6.3Hello的fork进程创建过程 我们在shell中键入./hello1190202111付一丁之后，shell会判断这个命令行是不是系统的内置命令。在发现不是之后，会调用fork创建一个子进程对其进行处理。新创建的子进程几乎但是不完全与父进程相同。子进程得到与父进程用户及虚拟地址空间相同的（但是独立的）一份副本，包括代码与数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这意味着父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别是他们有不同的PID。 fork函数只被调用一次，但是会返回两次：一次实在调用进程（父进程）中，一次是在新创建的进程子进程中。在父进程中，fork返回子进程的PID。在子进程中，fork返回0。 6.4Hello的execve过程 execve函数在当前进程的上下文中加载并运行一个新程序。 intexecve(char*filename,char*argv[],char*envp[]) execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到hello，execve才会返回到调用程序。所以与fork调用一次返回两次不同，execve调用一次从不返回。 调用execve会覆盖掉当前进程的代码、数据、栈，保留相同的PID。继承已打开的文件描述符和信号上下文。 6.5Hello的进程执行 时间片：一个进程执行它的控制流的一部分的每一个时间段叫做时间片。 内核模式：处理器必须提供一种机制，来限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常是用某个控制寄存器的一个模式位来提供这种功能。该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式（有时候叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。 用户模式：没有模式位的时候，进程就运行在用户模式中，用户模式不允许进程执行特权命令，也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。 内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。在进程执行的某些时刻，内核可以决定抢占当前进程，并且重新开始一个之前被抢占的进程。这种决策叫做调度。在内核调度了一个新进程运行后，它就抢占当前进程，并使用一种叫做上下文切换的进制将控制转移到当前的进程。 上下文切换的工作：保留当前进程的上下文；恢复某个先前被抢占的进程的被保存的上下文；将控制传递给这个进程。 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。在进程A和进程B之间进行上下文切换的例子如图 图61 A和B之间上下文切换 6.6hello的异常与信号处理 程序正常运行实例： 图62 正常运行 程序会打印十行Hello1190202111付一丁，然后输入一个字符并按回车之后终止程序。 6.6.1 在执行时输入ctrl-Z 图63 ctrl-z 输入ctrl-Z，程序停止 我们接着输入ps-ef|grephello。发现程序依旧存在只是暂时被停止了。 图64 查看进程是否存在 输入fg继续转入前台执行直到结束。 图65 恢复前台继续运行 这个实验我写到这里是晚上7点，之前虚拟机挂起了所以很早运行过hello，所以前面有一些记录。 图66 记录时间 再执行一次。 图67 停止 图68 查看进程 然后kill这个进程 图69 杀死进程 图70 终止进程 调用jobs命令查看 图71 调用jobs查看 我无意中有一个之前没有注意到的地方。 我在另一个为其他任务执行的shell中输入jobs 图72 另一个shell查看 得到的结果是不同的。 于是我使用pstree命令。 图73 查看进程树 可以查看整个进程树。找到bash和hello相关。 图74 查看bash分支 看到这里就明白了，在bash中调用jobs，只会在以当前bash为根的进程树的子树下查找jobs。所以在两个bash下显示的jobs的结果不同。 6.6.2 程序执行的时候输入ctrl-C 程序运行时输入ctrl-C，程序终止。 图75 查看进程 发现晚上7点运行的hello已经被终止了。 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 6.7本章小结 在这一章中hello正式由静止的程序，走向了执行中的进程。hello执行的过程，离不开他所依赖的shell，进程管理机制和各种信号异常的调控的支持。正是因为他们的存在，给与了hello良好的运行环境。让一个运行的进程顺利的完成从产生到终止的全过程。 第7章hello的存储管理 7.1hello的存储器地址空间 线性地址如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。为了简化讨论，我们总是假设使用的是线性地址空间。 物理地址:计算机系统的主存被组织为一个由M个连续字节大小的单元组成的数组。每字节都有一个由M个连续字节大小的单元组成的数组。每字节都有一个唯一的物理地址。第一个字节的地址为，剩下的字节地址顺序依次加一。 虚拟地址：使用虚拟寻址的时候，CPU生成一个虚拟地址，来访问主存，这个虚拟地址在被送到内存之前先转换成一个适当的物理地址。hello的虚拟地址在linux环境中和线性地址相等。等于逻辑地址加上段的基地址。 图76 查看各段地址 逻辑地址：在代码中相对于当前段的偏移量，或者说偏移地址，在程序机器码中的显示的地址，或者说在反汇编中看到的地址都是逻辑地址。他们需要加上对应段的基地址才是实际的地址。hello的反汇编看到的是逻辑地址。gdb看到的也是虚拟地址。 图77 前面的地址是逻辑地址 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理：段式管理是不连续分配技术的一种。它按照用户的思考方式，将程序按照程序段，数据段等具有明确逻辑含义的“段”，分配内存空间。段的管理是通过在节头表中保存的各段的信息实现的。在段式管理中，可以每个段不连续的地放在内存的不同分区中，但是每个段内部是连续的，操作系统以段为单位分配连续的内存。 图78 段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 页式管理是一种内存空间存储管理的技术，页式管理分为静态页式管理和动态页式管理。 将各进程的虚拟空间划分成若干个长度相等的页(page)，页式管理把内存空间按页的大小划分成片或者页面（pageframe），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。 图79 页式管理 7.4TLB与四级页表支持下的VA到PA的变换 我们先关注TLB的作用。TLB作为在CPU中的小的，虚拟寻址缓存，其中每一行都保存一个单个PTE组成的块， 图80 TLB 在拿到虚拟地址之后，可在VPN中根据TLB的组数，将VPN分成TLBT和TLBI两部分，根据TLBI查找到TLB对应组，根据TLBT确定指定虚拟地址是否在TLB中存在，若存在，则获取PTE生成完整的物理地址，MMU将物理地址传送到告诉缓存/主存，然后高速缓存/主存返回所请求的数据给处理器。这也就是下图的执行过程。 图81 命中 如果TLB不命中，那么MMU必须从L1缓存中取出相应的PTE。新取出的PTE存放在TLB中，可能会覆盖一个已有的条目。 图82 TLB不命中 那在具体实现的时候是怎么访问四级页表的呢。 图83 多级列表 页表的基地址寄存器指向一级页表的首地址。虚拟地址的VPN部分根据K级页表的结构分成K段，通过VPN1指向的一级页表的位置，寻找到对应的二级页表，再由VPN2指向的二级页表的位置寻找到对应的三级页表，以此类推。最终在k级页表里找到最终的PPN。PPN和VPO也就是PPO组合在一起，获得最终的物理地址。 7.5三级Cache支持下的物理内存访问 图84 三级cache示意 以IntelCorei7内存系统为例。 这张图展示了，一个有着三级cache的系统如何进行物理内存访问。 图85 物理内存访问流程 CPU先在根据当前的虚拟地址，在L1TLB中查找需要的PTE，如果命中，那么直接获得PPN生成物理地址。如果不命中需要在多级列表中继续查找PTE。在获得物理地址之后，需要将物理地址分成target，Index和偏移量三部分，现在L1d-cahce中查找，如果在L1中存在则直接将结果返回给CPU，如果L1中不存在则需要继续在下一级缓存/主存中查找，直到命中将结果返回给CPU。 7.6hello进程fork时的内存映射 程序调用hello命令，会新创建一个子进程，子进程会获得一个和父进程用户级虚拟地址空间相同的，但是独立的一个副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开的文件描述符相同的副本。 7.7hello进程execve时的内存映射 当hello进程开始执行的时候，会在当前的进程载入并运行一个新的程序，而不是像fork新创建一个进程。这就意味着会覆盖当前进程的代码，数据和栈。 新程序的main开始执行之后用户栈的结构如图所示。 图86 用户栈的结构 7.8缺页故障与缺页中断处理 图87 缺页的情况 该图显示了缺页的处理过程。CPU引用了VP3中的一个字，但是VP3并没有被缓存在DRAM中。地址翻译硬件从内存中调用VP3从有效位判断其未被缓存，则触发缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中牺牲页是存放在PP3中的VP4.如果VP4已经被修改了，那么内核就会将它复制回磁盘。接下来内核从磁盘中复制VP3到内存的PP3中，更新PTE3，然后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送到地址翻译硬件。但是现在，VPT3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。 图88 更新之后 7.9动态存储分配管理 （以下格式自行编排，编辑时删除） Printf会调用malloc，请简述动态内存管理的基本方法与策略。 动态内存分配器维护着一个进程的虚拟内存区域，称之为堆。假设堆是一个请求二进制零的区域，它紧邻在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每一个进程，内核维护着一个变量brk，它指向堆的顶部。堆维护一些大小不同的块的集合，每个块是连续的虚拟内存片，要么是已分配的，要么是空闲的。 内存分配管理有多种方法，有隐式空闲链表，显示空闲链表，红黑树等等。这里以隐式空闲链表为例，说明如何进行动态内存分配管理。 图89 隐式空闲链表 隐式空闲链表包含一个序言块和结尾块，用来标记头和尾。中间普通块包含头部和脚部，记录着当前块的大小，以及是否空闲。 当需要新分配一个大小为n的块的时候，需要调用一个查找适配块的函数，查找大于n的所有块，找到一个用来分配。 这个匹配的方法一般有三种： 首次适配。每次从链表的头部开始遍历直到找到一个块满足要求。 下一次适配。从上一次遍历的结束位置继续向下查找。 最佳适配。找到能分配的最合适的块（最小但是满足需求的）。但是需要查找的时间更长。 释放块：这个过程需要首先根据地址找到对应块，然后将需要释放的块标记为空闲。接下来需要查看是否需要与该块前后位置的两个块合并。 一共有四种情况：前面块空闲，后面已分配；前面块已分配，后面空闲；前面块已分配，后面已分配；前面块空闲，后面空闲。需要根据这四种情况分别进行处理，更新新的合并后的块的头部和脚部。 7.10本章小结 这一章涉及到hello在运行过程中的内存管理，涉及到了段式管理，页式管理，以及包含TLB，多级cache，多级页表下的综合情况。以及动态内存分配等相关内容。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 所有的I/O设备（例如网络、磁盘和终端）都被模式化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种设备优雅地映射成文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnitI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 打开、关闭文件 open()、close() intopen(char*filename,intflags,mode_tmode); intclose(intfd); open函数是将filename文件转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在当前进程中没有打开的最小描述符。flag指明了应该用什么读方式打开一个已经存在的文件： O_RDONLY 只读 O_WRONLY 只写 O_RDWR 可读可写 也可以是一个或者更多掩码的或 O_CREAT 如果文件不存在那么就创建一个截断的（空）文件 O_TRUNC 如果文件已经存在，那么就截断它。 O_APPEND 在每次写操作前，设置文件位置到文件的结尾处。 读、写文件 read()、write() 读文件从当前文件位置复制字节到内存位置，然后更新文件位置，返回值表示的是实际传送的字节数量。 写文件从内存复制字节到当前文件位置，然后更新文件位置，返回值表示的是从内存向文件fd实际传送的字节数量。 读文件和写文件不足值的情况是可能的(nbytes<sizeof(buf))，不是错误，但是两个函数的返回值若是小于0则是发生了错误。 改变当前的文件位置 (seek) 指示文件要读写位置的偏移量 lseek() 读取文件元数据 stat() 元数据是关于文件的信息 用户通过调用stat和fstat访问元数据 图90 元数据 这些都是异步信号安全的函数。 8.3printf的实现分析 先观察printf的函数 intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 这里面包含一个函数VSprintf intvsprintf(char*buf,constchar*fmt,va_listargs) { char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++) { if(*fmt!='%') { *p++=*fmt; continue; } fmt++; switch(*fmt) { case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); } 这个vsprintf的作用就是将我们在汇编看到的printf的第一个参数的字符串格式化，查找这个字符串里一些特定标志的是否存在，如%x，%s等等，这里应该只列出了一部分。然后将他们转换成实际对应的变量。就是一个将字符串内的符号和参数匹配的过程。 printf在调用vsprintf之后，调用了write函数，显然，他是将重新整合之后，也就是我们最终想输出的字符串，通过文件写的形式调用设备，输出到终端上。 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret 格式化在设备上输出字符串，这个过程需要到库中去查找需要输出的字符的点阵字模，然后在屏幕上通过LED灯显示。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 intgetchar(void) { charc; return(read(0,&c,1)==1)?(unsignedchar)c:EOF //EOF定义在stdio.h文件中 } 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 这里主要讨论hello在运行的时候如何与我们进行“交互”的一些内容，介绍了linux下I/O是如何管理的，一些UnixI/O接口函数，并且对printf和getchar的原理与实现进行了一些介绍。 结论 1.首先通过IDE完成对hello.c文件的编写 2.通过预处理器插入头文件，替换宏定义等操作。 3.通过编译器进行编译生成汇编代码。 4.汇编器将汇编代码转化为可重定位目标文件 5.链接器进行链接，生成和执行文件hello。 6.shell中键入命令，运行hellp程序。 7.shell调用fork为运行hello生成子进程。在这个过程中处理用户输入的命令和信号 8.内存管理系统将页表载入内存。如果缺页则进行处理在程序运行中 9.程序通过I/O管理获取设备的输入，并把输出打印在屏幕上。 10.hello运行结束之后，shell回收hello进程，释放内存。 感受；没有什么创新理念哈哈，这对于我来说还是为时过早了。但是真的学了这门课觉得发现几十年积淀设计出来的计算机真的是精致，这段学习的历程不虚此行。而且这门学到的知识这学期立刻就在自己的日常生活中和其他课的实验中应用到，还是受益很多。 附件 hello.i cpphello.c >hello.i hello.c经过预处理器(cpp),生成的修改了的源程序(文本)，将系统头文件插入程序文本，将宏定义替换程序文本。 hello.s gcc-Shello.c-ohello.s gcc运行编译器，产生一个汇编文件hello.s Hello.s objdump-d-rhello.o>Hello.s hello.o反汇编生成的Hello.s hello ld-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o-lc/usr/lib/x86_64-linux-gnu/crtn.o-zrelro-ohello 链接生成。 参考文献 [1] ComputerSystems:AProgrammer'sPerspective(3rdEdition). 北京：机械工业出版社，2016 [2] https://blog.csdn.net/shiyongraow/article/details/81454995 [3] https://blog.csdn.net/renlonggg/article/details/101034096 [4] https://blog.csdn.net/weixin_33262687/article/details/117052224 [5] https://blog.csdn.net/qq_36299025/article/details/90927980 [6] https://www.cnblogs.com/marsqi/p/6284272.html [7] https://www.cnblogs.com/pianist/p/3315801.html [8]https://zhengkang.blog.csdn.net/article/details/51680017?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.base [9] https://blog.csdn.net/qq_41824181/article/details/85860975 [10] https://baike.baidu.com/item/%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86/6984316?fr=aladdin 
第383篇文章[]
软件构造（一）java根据类属性生成hash值的方法 在写实验利用HashSet.contains进行判断当前对象在集合中是否存在的时候，需要判断该对象的hash值是否存在。这个时候需要override对象的hashCode方法。 假设对象所在的类大致如下： publicclassCourse{ privatelongID; privateStringname; privateStringteacherName; privateStringlocation; privatelongClass_hours; } 我们需要根据这些属性的值生成hash值。只有当这些属性的值相等的时候散列值相等，可以采用object.hash方法。 如下 publicclassCourse{ privatelongID; privateStringname; privateStringteacherName; privateStringlocation; privatelongClass_hours; @Override publicinthashCode(){ returnObjects.hash(ID,name,teacherName,locationClass_hours); } } 
第384篇文章[1]
哈尔滨工业大学-计算机系统大作业-程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号119020XXX班 级1936XXX学生XXX 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文以hello.c程序为例,阐述程序在Linux系统中的整个生命周期和操作系统在此过程中进行的各种管理，具体阐述了hello程序经过预处理、编译、汇编、链接生成可执行文件、产生进程直至进程终止回收的过程、操作系统的进程管理、存储管理和I/O管理。 关键词：Linux；计算机系统、程序、进程； 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介Hello的P2P（FromProgramtoProcess）过程：hello程序的生命周期从高级C语言程序开始，为了在系统上运行hello.c文件，首先要完成从源文件到可执行目标文件的过程，这包括四个阶段：预处理、编译、汇编、链接。在得到可执行目标文件hello之后，在shell中运行这个目标程序，shell将为其分配进程空间，加载目标程序并运行。这个过程就是P2P（FromProgramtoProcess）的过程。Hello的020（FromZerotoZero）过程：程序运行前，shell调用execve函数将hello程序加载到相应的上下文中，将程序内容载入物理内存，并从main函数开始执行目标代码；程序结束后，父进程回收终止进程，内核清除相关痕迹。hello程序从不存在（0）到产生再到被回收（0）的过程，即是020的过程。1.2环境与工具硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位；开发工具：VisualStudio201064位以上；GDB/OBJDUMP；DDD/EDB；GCC；vim;readelf；HexEdit1.3中间结果hello.c:c语言编写的源文件，以ASCII码编码hello.i:hello.c经预处理得到的文本文件hello.s:hello.i经编译得到的文本文件，包含汇编语言程序hello.o:hello.s经汇编得到的可重定位目标文件hello:经链接得到的可执行目标文件hello.out:hello的反汇编文件 1.4本章小结本章简要介绍了hello文件的P2P和020过程，介绍了将要使用的环境与工具，列出了过程中产生的中间结果。 （第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的#include<stdio.h>命令告诉预处理器读取头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件拓展名。2.2在Ubuntu下预处理的命令命令：gcc-Ehello.c-ohello.i 图2.1对hello.c的预处理过程2.3Hello的预处理结果解析 图2.2hello.c的预处理结果–hello.i文件 打开经预处理得到的hello.i文件，可以看到文件的内容增多，所做的处理包括1）处理宏定义指令，如对#define指令进行替换，对#undef取消对某个宏的定义2）处理条件编译指令，如#ifdef、#ifndef、#else、#elif、#endif等，过滤不必要的代码3）处理头文件包含指令，即#include，把头文件中的定义添加到文件中4）处理特殊符号，对LINE、FILE等符号用何时的值进行替换可以看到main函数在文件的最底部。 图2.3最底部的main函数 2.4本章小结本章简要介绍了hello.c的预处理过程，分析了hello.i文件，阐述了预处理过程中所进行的操作。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序，以文本格式描述低级机器语言指令。汇编语言为不同高级语言的不同编译器提供了通用的输出语言。3.2在Ubuntu下编译的命令命令：gcc-Shello.i-ohello.s 图3.1hello.i的编译过程3.3Hello的编译结果解析3.3.1汇编指令 图3.2汇编指令 .file“源文件名”，声明源文件.text定义一个代码段，处理器开始执行代码的地方，代表后面是代码.global定义声明全局变量.data定义初始化数据段.align对齐方式.type指明一个符号的类型（对象类型/函数类型）（typesleepsecs,@object声明sleepsecs是对象类型typemain,@function声明main是函数类型）.size大小.long定义一个长整形，并为它分配空间，占4字节.section.rodata定义只读数据段.string定义一个字符串，并为它分配空间 综上，hello.s文件的第一部分，声明文件名是“hello.c”；数据以4字节方式对齐；声明了一个全局变量sleepsecs，是对象类型的，大小是4字节，类型是Long，数值是2；在只读数据段存放了两个字符串；声明了一个全局变量main，它是函数类型的。3.3.2数据1.全局变量1）程序中定义了一个全局变量sleepsecs，在hello.c文件中，它在main函数前被定义（如图3.3）为int类型，值是2.5 图3.3sleepsecs在hello.c中的定义在hello.s中，它在程序开头，通过.global关键字被定义，并在初始化数据段指明了它的类型、大小和值：对象类型，4字节大小，Long型，值为2 图3.4speepsecs在hello.s中的定义这里需要注意的是，由于整型不能带有小数部分，可以看到，实际上2.5被隐含的强制类型转换取整数值2。2）hello.c中还定义了一个全局变量main，它是函数类型的，被声明在代码段 图3.5hello.s中声明的全局变量main2.局部变量程序中定义了一个局部变量i，初始化后被存储在栈中，地址为-4（%rbp） 图3.6存储在栈中的变量i被赋值为0 3.字符串在hello.c中一共有两个字符串，是作为printf的参数传入的，存储在只读数据段.rodata中 图3.7hello.c中的字符串1 图3.8hello.c中的字符串2 图3.9存储在只读数据段的字符串 图3.10作为printf参数传入的字符串1 图3.11作为printf参数传入的字符串24.函数参数main函数有两个参数，整型变量argc和指针数组argv，都存储在栈中，其中argv包含指向上述两个字符串的指针。 图3.12main函数的两个参数 图3.13存储在栈中的argc 图3.14存储在栈中的两个字符指针5.立即数在汇编代码中，许多立即数出现在指令中 图3.15出现在汇编代码中的立即数（1） 图3.16出现在汇编代码中的立即数（2）3.3.3赋值hello.c中有两个赋值操作，分别是给全局变量sleepsecs赋值为2.5，和给局部变量i赋初值为0。 图3.17给全局变量sleepsecs赋值 图3.18给局部变量i赋初值0在汇编文件hello.s中，给sleepsecs赋值体现在初始化数据段.data中，给i赋值则通过汇编指令movl完成，这里的后缀l表示传送四个字节。 图3.19给sleepsecs赋值 图3.20给局部变量i赋值MOV是一类数据传送指令，按照传送的数据大小和进行的拓展有不同的后缀，具体如下表 图3.21简单的数据传送指令 图3.22零拓展数据传送指令 图3.23符号拓展数据传送指令3.3.4类型转换程序中包含一个隐式类型转换，即给全局变量sleepsecs的赋值，由于sleepsecs被声明的类型是int型，而hello.c程序试图将一个浮点值2.5赋值给它，所以程序进行了隐式类型转换，将2.5的整数值2赋给了sleepsecs，在hello.s汇编文件中可以看出。 图3.24不正确的赋值 图3.25汇编代码给sleepsecs赋值为2 3.3.5算数操作hello.c中只包含一个局部变量i的自加一的算数操作，由汇编指令add实现。 图3.26add指令实现自加一其他的整数算数操作汇编指令如下表： 图3.27整数算数操作 3.3.6关系操作程序中包含两个关系操作：argc！=3和i<10，均由cmpl指令实现，这两个指令同时设置条件码，用于条件跳转。 图3.28两个关系操作 图3.29两个比较指令3.3.7数组/指针/结构操作main函数的参数argv是一个指针数组，argv[0]指向可执行文件的文件名,argv[1]、argv[2]分别指向开始的两个字符串，使argv[1]、argv[2]指向字符串的操作是通过leaq指令将存放字符串的地址放置到指针所指的寄存器来实现的。 图3.30使指针指向寄存器 图3.31将存放字符串的地址存到寄存器里3.3.8控制转移函数中包含两个控制转移：1）if（argc！=3）2）for(i=0;i<10;i++)这两个控制转移根据关系操作中设置的条件码进行条件跳转：1）如果argc=3，跳过if括号里的操作（跳转到L2）。2）如果i<=9,进入for循环（跳转到L4）在汇编代码中的实现如下： 图3.32跳转到L2 图3.33跳转到L43.3.9函数操作程序中涉及多个函数的操作：1）main函数：参数argc、argv2）printf函数3）exit函数：参数14）sleep函数：参数sleepsecs5）getchar函数以hello.c中调用的第一个printf为例：首先第一个字符串被存储在%rdi寄存器里，作为第一个参数，之后通过call指令调用puts函数，第一个参数被传递进来，如果要使用返回值，返回值应当被存储在%rax寄存器中。需要强调的是，在函数调用时，程序会在栈上给被调用者分配空间，保存一些寄存器的值，当函数调用结束时，栈又会恢复到调用之前的状态，并恢复需要恢复的寄存器值。3.4本章小结本章详细的叙述了程序编译过程中编译器所进行的各种操作，并将c语言的数据与操作对应到汇编代码。（第3章2分） 第4章汇编4.1汇编的概念与作用汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成可重定位目标文件的格式，并将结果保存在hello.o中。hello.o是一个二进制文件，包含main函数的指令编码。4.2在Ubuntu下汇编的命令命令：gcc-chello.s-ohello.o 4.3可重定位目标elf格式分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。4.3.0典型的ELF可重定位目标文件的格式（如图4.1）： 图4.1典型的ELF格式ELF头：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分描述包含帮助链接器语法分析和解释目标文件的信息：ELF头的大小、目标文件的类型、机器类型、节头目表的文件偏移，节头目表中条目的大小和数量。.text：已编译程序的机器代码.rodata：只读数据.data：已初始化的全局和静态C变量.bss：未初始化的全局和静态C变量.symtab：一个符号表，存放在程序中定义和引用的函数和全局变量的信息.rel.text：一个.taxt节中位置的列表，当链接器把这个目标文件和其他的文件组合时，需要修改这些位置。.rel.data：被模块引用或定义的所有全局变量的重定位信息.debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中引用的全局变量，以及原始的C文件.line：原始C源程序中的行号和.text节中机器指令之间的映射.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字节头部表：描述目标文件的节4.3.1ELF头(如图4.2)命令：readelf-hhello.o由图4.2可以看出，这是一个64位ELF文件；数据以2的补码、用小端法表示；是可重定位文件；机器类型X86-64；入口点地址是0；程序头开始地址是0；节头部开始地址是1152字节；ELF头的大小是64字节；节头部的大小是64字节；共有13个节头，节头部的字符串表索引是12。 图4.2用readelf查看的ELF头信息 4.3.2节头部表（图4.3）命令：readelf-Shello.o可重定位目标文件的每个节都从0开始，当在文件头中得到节头部的信息后，将使用节头部表中的偏移量和大小，确定各节在文件中的起始位置及大小。图4.3显式了各个节的信息，包括名字、类型、地址、偏移量、大小、对齐方式、读写权限等。可以看到，代码段不可写，可执行；.data和.bss段可读可写，不可执行；只读数据段不可写、不可执行。 图4.3用readelf查看的节头部表信息4.3.3符号表（如图4.4）命令：readelf-shello.oName是字符串表中的字节偏移，指向符号的以null结尾的字符串名字；value是符号的地址，对于可重定位的模块来说，value是句定义目标的节的起始位置的偏移，对于可执行目标文件来说，该值是一个绝对运行时地址；size是目标的大小（字节）；type指明是数据、函数、对象等；bingding指明是符号是全局的还是本地的；Ndx指示所在节索引数，UND为未定义，ABS为无需重定位。 图4.4用readelf查看的符号表信息4.3.4rel.data(如图4.5)命令：readelf-rhello.o重定位条目的格式：Offset：需要被修改的引用的节偏移Info：包含symbol（前4字节）和type（后4字节）的信息Addend：一个有符号常数，一些类型的重定位要用它对被修改引用的值做偏移调整Symbol：标识被修改引用应该指向的符号Type:重定位类型，告知链接器如何修改新的引用，包括两种最基本的重定位类型：R_X86_64_PC32:重定位一个使用32位PC相对地址的引用。一个PC相对地址就是距程序计数器的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就在指令中编码的32位值加上PC当前运行时值，得到有效地址，PC值通常是下一条指令在内存中的地址。R_X86_64_32:重定位一个使用32位绝对地址的引用，通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。 图4.5用readelf查看的rel.data信息 4.4Hello.o的结果解析hello.o的反汇编结果： 图4.6hello.o的反汇编结果 图4.7hello.s反汇编的过程是反汇编器根据机器代码生成一种类似于汇编代码的格式，在反汇编文件中，左侧列出机器代码，右侧列出与它等价的汇编语言。机器代码与它的反汇编有一些特性：1）X86_64的指令长度从1到15个字节不等，常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用的或者操作数较多的指令所需字节数较多。2）设计指令格式的方式是，从某个给定位值开始，可以将字节唯一地解码成机器指令。3）反汇编器指示基于机器代码文件中的字节序列来确定汇编代码，他不需要访问该程序的源代码或汇编代码。4）反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微差别，它省略了很多指令结尾的大小指示符，但给call和ret添加了q后缀。在分支转移中，反汇编使用的不是段名称，而是确定的地址。在函数调用中，反汇编的call的目标不是函数名称，而是下一条指令。4.5本章小结本章分析了hello.s汇编后得到的可重定位目标文件hello.o，并对可重定位目标文件的各部分进行了分析比较了机器语言与汇编语言的区别。 （第4章1分） 第5章链接5.1链接的概念与作用链接是将各种代码和数据片段收集并组合为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行与编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并运行时；甚至执行于运行时，也就是由应用程序来执行。在现代系统中，链接是由叫做链接器的程序自动执行的。链接器在软件开发中扮演着一个关键的角色，使得分离编译称为可能。5.2在Ubuntu下链接的命令命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1链接生成可执行目标文件的过程5.3可执行目标文件hello的格式典型的可执行目标文件ELF格式如图5.2 图5.2典型的ELF可执行目标文件可执行目标文件的格式类似于可冲定位目标文件的格式。.text、.rodata、。data节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终运行的内存地址以外。.init节定义了一个小函数，叫做_init,程序的初始化代码会用调用它，因为可执行文件是完全链接的（已重定位的），所以它不再需要.rel节 5.3.1ELF头(如图5.3)命令：readelf-hhello由图4.2可以看出，这是一个64位ELF文件；数据以2的补码、用小端法表示；是可执行文件；机器类型X86-64；入口点地址是0x400500；程序头开始地址是64；节头部开始地址是5928字节（指明程序运行时要执行的第一条指令的地址）；ELF头的大小是64字节；节头部的大小是64字节；共有25个节头，节头部的字符串表索引是24。 图5.3用readelf查看的ELF头信息 5.3.2节头部表（图5.4）命令：readelf-Shello图4.3显示了各个节的信息，包括名字、类型、地址、偏移量、大小、对齐方式、读写权限等，根据节头部中的信息可以确定每个节的起始位置和大小。 图5.4用readelf查看的节头部表信息 5.3.3符号表（如图5.5）命令：readelf-shello 图5.5用readelf查看的符号表信息5.4hello的虚拟地址空间hello的虚拟地址为0x400000~0x400ff0 图5.6hello虚拟空间的开始地址 图5.7hello虚拟空间的结束地址利用节头部表中的信息： 图5.8节头部表中信息.init段开始与0x400488,大小为0x017 图5.9.init段信息 .text段开始与0x400500,大小为0x132 图5.10.text段信息.rodata段开始与0x400640,大小为0x008 图5.11.rodata段信息 5.5链接的重定位过程分析 图5.12hello的反汇编hello.out与hello.o的不同：1）hello.out中增加的许多节和在hello.c中用到的函数的汇编代码2）因为可执行文件是完全链接的（已重定位的），所以它不再需要.rel节3）hello.o中用相对偏移表示的地址在hello.out中替换成了虚拟内存地址。 图5.13hello.out重定位过程：1）重定位节和符号定义:在这一步中，链接器将所有相同类型的节合并为同一个类型的新的聚合节，然后，链接器将运行时内存地址赋给新的聚合节，赋给输出模块定义的每个节，体积赋给输出模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。2）重定位节中的符号引用:在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的地址，要执行这一步，链接器依赖于可冲定位目标模块中称为重定位条目的数据结构。 图5.14重定位条目ELF定义了32种不同的重定位类型，其中最基本的两种：R_X86_64_PC32:重定位一个使用32位PC相对地址的引用。一个PC相对地址就是距程序计数器的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就在指令中编码的32位值加上PC当前运行时值，得到有效地址，PC值通常是下一条指令在内存中的地址。R_X86_64_32:重定位一个使用32位绝对地址的引用，通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。 图5.15重定位算法 5.6hello的执行流程ld-2.27.so!_dl_start0x7f8c4587893ld-2.27.so!_dl_init0x7f8c458070c5hello!_start0x400500libc-2.27.so!_libc_start_main0x7f8c45206534-libc-2.27.so!_cxa_atexit0x7f8c452488647-libc-2.27.so!_libc_csu_init0x4005c0libc-2.27.so!_setjmp0x7f8c45248672libc-2.27.so!exit0x7f8c452464255.7Hello的动态链接分析动态链接项目：global_offset表,全局偏移表通过hello信息可以看到，GOT起始表的位置是0x601000 dl_init前： dl_init后： 表中数据变成了相应的偏移量。5.8本章小结本章针对于链接过程，分析了ELF格式的可重定位目标文件、可执行目标文件和动态链接，分析了程序的执行流程。（第5章1分） 第6章hello进程管理6.1进程的概念与作用进程是一个执行中程序的实例，是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。进程给应用程序提供两个关键的抽象：一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器；一个私有的地址空间，他提供一个假象，好像我们的程序独占地使用内存系统。6.2简述壳Shell-bash的作用与处理流程1)shell：Shell是一个连接了用户和Linux内核的应用程序，是一个命令解释器，它通过接受用户输入的Shell命令来启动、暂停、停止程序的运行或对计算机进行控制。2）shell的功能：Shell除了能解释用户输入的命令，将它传递给内核，还可以调用其他程序，给其他程序传递数据或参数，并获取程序的处理结果；在多个程序之间传递数据，把一个程序的输出作为另一个程序的输入，Shell本身也可以被其他程序调用。因为shell可以调用其他程序，所以shell完全能够胜任Linux的日常管理工作，如文本或字符串检索、文件的查找或创建、大规模软件的自动部署、更改系统设置、监控服务器性能、发送报警邮件、抓取网页内容、压缩文件等。我们还可以在shell中编程。2）处理命令行的流程：1．Shell首先从命令行中找出特殊字符（元字符），在将元字符翻译成间隔符号。元字符将命令行划分成小块tokens。Shell中的元字符如下所示：SPACE,TAB,NEWLINE,&,;,(,),<,>,|2．程序块tokens被处理，检查看他们是否是shell中所引用到的关键字。3．当程序块tokens被确定以后，shell根据aliases文件中的列表来检查命令的第一个单词。如果这个单词出现在aliases表中，执行替换操作并且处理过程回到第一步重新分割程序块tokens。4．Shell对~符号进行替换。5．Shell对所有前面带有 符 号 的 变 量 进 行 替 换 。 6 ． S h e l l 将 命 令 行 中 的 内 嵌 命 令 表 达 式 替 换 成 命 令 ； 他 们 一 般 都 采 用 符号的变量进行替换。6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用 符号的变量进行替换。6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用(command)标记法。7．Shell计算采用$(expression)标记的算术表达式。8．Shell将命令字符串重新划分为新的块tokens。这次划分的依据是栏位分割符号，称为IFS。缺省的IFS变量包含有：SPACE,TAB和换行符号。9．Shell执行通配符*?[]的替换。10．shell把所有从处理的结果中用到的注释删除，并且按照下面的顺序实行命令的检查：A.内建的命令B.shell函数（由用户自己定义的）C.可执行的脚本文件（需要寻找文件和PATH路径）11．在执行前的最后一步是初始化所有的输入输出重定向。12．最后，执行命令。 6.3Hello的fork进程创建过程父进程通过调用fork（）函数创建一个新的运行的子进程。新创建的子进程几乎但并不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同（但是独立的）一份副本包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork是，子进程可以读写父进程中代开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。当我们输入执行这个hello程序的命令时，shel解析命令，并调用fork创建一个子进程。6.4Hello的execve过程execve函数在当前进程的上下文中加载并运行hello程序，加载并运行程序需要以下几个步骤：1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。图6.1概括了私有区域的不同映射。3）映射共享区域。如果a.out程序与共享对象(或目标)链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。4）设置程序计数器(PC)。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 图6.1加载器是如何映射用户地址空间的区域的6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。概念：1）进程上下文信息：上下文是由程序正常运行所需的状态组成的，这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。2）进程时间片：一个进程控制它的控制流的一部分的每一时间段。3）用户模式与内核模式：处理器通过控制某个寄存器的一个模式位来切换用户模式与内核模式；执行在内核模式下的进程，可以执行指令集中的任何指令，访问系统中的任何内存模式；用户程序则必须通过调用系统接口间接的访问内核代码和数据。4）调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个之前被抢占了的进程所需的状态，这种决策就叫调度。hello程序开始时运行在用户模式，当它调用sleep函数后，进程进入内核模式。内核处理休眠，将hello进程从运行队列移入等待队列，切换上下文，移交控制给其他进程。hello休眠的计时器到达时间后发送信号给内核，内核执行中断，将hello重新添加进运行队列，继续执行。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。hello调用getchar时，程序也从用户模式切换成内核模式，接受数据传输，内核移交控制给其他进程，数据传输结束后，内核接受中断信号，切换上下文，移交控制给hello。6.6hello的异常与信号处理可能出现的异常： 图6.2可能出现的异常我们可以通过键盘输入发送中断信号SIGTSTP信号和终止信号SIGINT给进程。1）Ctrl+z发送一个SIGTSTP中断信号给进程，进程挂起但不结束，使用ps仍能看到hello程序，调用fg，将hello调度到前台，hello继续运行，完成后续步骤。 图6.3ctrl+Z的处理2）Ctrl+c发送一个SIGINT信号给进程，默认行为是终止进程，调用ps不再看到hello。 图6.4ctrl+C的处理3）不停乱按：正常运行时不停乱按，输入的字符只是进入缓冲区，非命令的输入都不会得到处理。 图6.5乱按的处理 6.7本章小结本章介绍了进程创建、执行到回收的过程，以hello为例，分析了程序对常见信号的处理。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间1）逻辑地址：CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。对逻辑地址要求，“一个逻辑地址，是由一个段标识符加上一个指定段内相对地址的偏移量，表示为[段标识符：段内偏移量]。对hello程序来说，它是出现在汇编代码中的地址。2）线性地址（虚拟地址）：跟逻辑地址类似，它也是一个不真实的地址，线性地址对应了硬件页式内存的转换前地址3）物理地址：用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。加载到内存地址寄存器中的地址，内存单元的真正地址。在前端总线上传输的内存地址都是物理内存地址，编号从0开始一直到可用物理内存的最高端。这些数字被Nortbridgechip映射到实际的内存条上。物理地址是明确的、最终用在总线上的编号，不必转换，不必分页，也没有特权级检查7.2Intel逻辑地址到线性地址的变换-段式管理逻辑地址由48位组成的，前16位为“段选择符”（段标识符），后32位是段内偏移量。1）段选择符的格式如图： 图7.1段选择符前13位是在（全局/局部）描述符表中的索引；之后一位是TI，如果TI是0，那么前面的索引是在全局描述符表GDT中的索引；如果TI是1，那么前面的索引是在局部描述符表中的索引；最后两位是RPL，它指明段的级别。为00，位于最高级别的内核态。为11，位于最低级别的用户态。2）全局描述符GDT：只有一个，用来存放系统内用来存放系统内每个任务共用的描述符，例如，内核代码段、内核数据段、用户代码段、用户数据段以及TSS（任务状态段）等都属于GDT中描述的段。局部描述符表LDT：存放某任务（即用户进程）专用的描述符3）描述符表存放这段描述符，每个段描述符是8字节：BASE(32位)：段首地址的线性地址。 G：为0代表此段长度以字节为单位，为1代表此段长度以4K为单位。 LIMIT(20位)：此最后一个地址的偏移量，也相当于长度，G=0，段大小在11MB，G=1，段大小为4KB4GB。 S：为0表示是系统段，否则为代码段或数据段。 Type：描述段的类型和存取权限。 DPL：描述符特权级，表示访问这个段CPU要求的最小优先级(保存在cs寄存器的CPL特权级)，当DPL为0时，只有CPL为0才能访问，DPL为3时，CPL为0为3都可以访问这个段。 P：表示此段是否被交换到磁盘，总是置为1，因为linux不会把一个段都交换到磁盘中。 D或B：如果段的LIMIT是32位长，则置1，如果是16位长，置0。(详见intel手册) AVL：A=1已被访问过，A=0未被访问过。（通常A包含在TYPE字段中）4）下面来进行转换：①首先，由段选择符列TI确定在全局还是局部描述符表里查找②然后根据段选择符中的索引确定要选择的表项（段描述符）③应用段选择符的RPL确定的权限④把段描述符中取到的段基地址加到汇编语言中的地址（偏移量）上，形成线性地址7.3Hello的线性地址到物理地址的变换-页式管理概念：1）虚拟页面：虚拟内存被组织为一个有存放在磁盘上的N个连续的字节大小的单元组成的数组，每字节都有一个唯一的虚拟地址，作为到数组的索引。VM系统将虚拟内存分割为称为虚拟页（VP）的固定大小的块。类似的，物理内存也被分割为屋里也（PP）。虚拟页和物理页的大小是相同的。在任意时刻，虚拟页面的集合都分为三个不相交的子集:①未分配的:VM系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。②缓存的:当前已缓存在物理内存中的已分配页。③未缓存的:未缓存在物理内存中的已分配页。2）DRAM缓存作为虚拟内存系统的缓存，在主存中缓存虚拟页。3）页表是一个页表条目（PTE）的数组（如图7.2），虚拟地址空间中的每个页在页表中一个固定的偏移量处都有一个PTE。 图7.2页表每个PTE有一个有效位和一个n位地址字段组成。有效位表明了该虚拟页当前是否被缓存在DRAM中。①如果设置了有效位,那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。（缓存的）②如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。（未分配的）③否则，这个地址就指向该虚拟页在磁盘上的起始位置。（未缓存的）4）缺页异常：访问某个虚拟页时，它的PTE的有效位为0，说明它没有被缓存到物理页，但是物理页已经都有存储的信息了，那么缺页处理程序从物理页中选择一个牺牲页，把现在要访问的这个页存到这个物理页里，如果这个物理页之前被修改过，就把物理页的内容写回内存，否则直接覆盖。下面叙述线性地址翻译成物理地址的过程：一个n位的虚拟地址包含两部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。处理器生成一个虚拟地址，把它传送给MMU，MMU选择VPN对应的PTE，如果有效位是1，那么取出后续的物理页的起始位置，把它和VPO拼接在一起，构成一个物理地址。如果有效位是0，触发缺页异常，处理异常后，重新访问PTE，取出后续物理页的起始地址，与VPO组成物理地址。即以VPO作为偏移量，以物理页起始地址为基址，进行。7.4TLB与四级页表支持下的VA到PA的变换 图7.3如图7.3，虚拟地址是48位的，物理地址是52位的，每个页表的大小是4KB，共四级页表，每级页表以VPN的9位为索引，LITLB是4路16组相联的，L1高速缓存的块大小是64字节。CPU产生一个48位的虚拟地址，MMU将36位VPN的钱32位作为TLBT，后四位作为TLBI，如果在TLB中命中，直接得到PTE，得到四十位物理页起始地址，与12位VPO组合成物理地址；如果TLB不命中，以VPN前9位为第一季页表索引，确定二级页表基址，以此类推，在四级页表中得到四十位PPN，与12为VPO组合得到物理地址。上述过程中，如果PTE有效位为0，引发缺页异常，处理后重新访问PTE。7.5三级Cache支持下的物理内存访问以图7.3的L1d-cache为例，组数是64=26，所以组索引位数是6，每组8行，块大小是64=26字节，所以偏移量也是6位，所以标记位是52-6-6=40位。当有一个52位的物理地址1）首先根据组索引确定LI缓存的组数2）然后把标记位与组里每个行的标记位比较，如果有标记位一致且有效位为1的行，则根据偏移量选择出需要的块。3）如果没有符合条件的行，从下一级存储结构里取出这个块，放到刚才的组里，如果组里有空行，直接放置在空行上；如果组已满，那么采用一种驱逐策略，驱逐一个行，把这个块存进去。7.6hello进程fork时的内存映射当shell为hello程序调用fork函数时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数加载并运行hello程序需要以下几个步骤：1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。图6.1概括了私有区域的不同映射。3）映射共享区域。如果a.out程序与共享对象(或目标)链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。4）设置程序计数器(PC)。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。图7.4展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。 图7.4缺页前接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图9-7展示了在缺页之后我们的示例页表的状态。 图7.5缺页后7.9动态存储分配管理1）动态内存分配器维护着一个进程的虚拟内存区域，称为堆。假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进城，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块（block）的集合来维护。每个块就是一个连续的虚拟内存片（chunk），要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，知道它显式地被应用所分配。一个已分配的块保持已分配状态，知道它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。内存分配器有两种基本风格：显式分配器要求应用显式地释放任何已分配的块；隐式分配器，要求分配器检测一个已分配的块何时不再被程序所使用，那么就释放这个块。2）带边界标签的隐式空闲链表：分配器将用来区分块边界、区分已分配块和空闲块的数据结构嵌入块本身，在这种情况下，一个块是由一个字的头部、有效载荷，以及一些可能的额外的填充组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐条件，那么块的大小就总是8的倍数，且块的最低3位总是零。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配为）来指明这个块是已分配的还是空闲的。头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。我们将组堆织为一个连续的已分配块和空闲块的序列，称为隐式空闲链表。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。此时需要某种特殊标记的结束块。Knuth提出了一种边界标记技术（如图7.6），允许在常数时间内进行对前面块的合并。这种思想是在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。 图7.6使用边界标记的堆块的格式将空闲链表组织成一个隐式空闲链表，有如图7.7的恒定格式 图7.7隐式空闲链表的恒定格式第一个字是一个双字边界对齐的不使用的填充字。填充后面紧跟着一个特殊的序言块(prologueblock)，这是一个8字节的已分配块，只由一个头部和一个脚部组成。序言块是在初始化时创建的，并且永不释放。在序言块后紧跟的是零个或者多个由malloc或者free调用创建的普通块。堆总是以一个特殊的结尾块(epilogueblock)来结束，这个块是一个大小为零的已分配块，只由一个头部组成。序言块和结尾块是一种消除合并时边界条件的技巧。分配器使用一个单独的私有(static)全局变量(heap_listp)，它总是指向序言块。(作为一个小优化，我们可以让它指向下一个块，而不是这个序言块。)7.10本章小结这一章首先叙述了不同的地址概念和他们之间的转换，由此引出了存储结构、和访存的相关知识，最后又重温了内存映射，复习了动态内存分配的方法策略。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件设备管理：unixio接口一个Linux文件就是一个m个字节的序列：B0，B1,…,Bk,…,Bm-1所有的I/О设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。8.2简述UnixIO接口及其函数UnixI/O接口;1）打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。2）Linuxshell创建的每个进程开始时都有三个打开的文件:标准输入(描述符为0)、标准输出(描述符为1)和标准错误(描述符为2)。头文件<unistd.h>定义了常量sTDINFILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。3）改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。4）读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k十n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置é开始，然后更新é。5）关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数：1）open函数：intopen(char*filename,intflags,mode_tmode)返回：若成功则为新文件描述符，若出错则为-1Open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。Flags参数指明了进程打算如何访问这个文件，mode参数指明了新文件的访问权限位。2）close函数：intclose（intfd）返回：若成功则为0，出错则为-1.进程通过调用close函数关闭一个打开的文件。3）read函数ssize_tread(intfd,void*buf,size_tn)read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值一1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。4）write函数ssize_twrite(intfd,constvoid*buf,size_tn)write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。5)lseek函数通过调用了lseek函数，应用程序能够显式地修改当前文件的位置。8.3printf的实现分析Printf函数原型： 图8.1printf函数原型printf函数调用vsprintf函数，这个函数的作用是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出，它返回要打印的字符串长度接着printf函数调用UnixI/O函数write（buf，i），打印出长度为i的buf。 图8.2write函数intINT_VECTOR_SYS_CALL表示要通过系统来调用sys_call这个函数，sys_call函数显示格式化字符串。https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析getchar源码：intgetchar(void){staticcharbuf[BUFSIZ];staticchar*bb=buf;staticintn=0;if(n==0){n=read(0,buf,BUFSIZ);bb=buf;}return(–n>=0)?(unsignedchar)*bb++:EOF;}异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章主要介绍了UnixI/O的概念和相关函数，并以printf和getchar函数为例，展现了UnixI/O函数的应用。（第8章1分）结论用计算机系统的语言，逐条总结hello所经历的过程。1.hello.c:c语言编写的源文件，以ASCII码编码2.hello.i:hello.c经预处理得到的文本文件3.hello.s:hello.i经编译得到的文本文件，包含汇编语言程序4.hello.o:hello.s经汇编得到的可重定位目标文件5.hello:经链接得到的可执行目标文件6.运行：在shell中键入运行命令，1）shell调用fork为hello创建子进程2）shell调用execve加载并执行hello3）hello调用函数，或shell接受信号，shell进行上下文切换，传递控制4）shell为hello动态分配内存5）hello运行结束或接收信号而终止，shell安排父进程回收hello进程，清除相关痕迹。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。计算机系统设计是一个复杂而庞大的工程，系统中一个小程序的运行也是诸多部分共同工作的结果。计算机的设计首先体现了准确性：各种操作清晰明确，每一种操作在当时的情况下都是确定的；其次体现了全面性，计算机系统的设计必须考虑所有可能的情况，避免错误的发生；最后体现了平衡性，计算机系统协调的设计，追求时间、空间与经济上的平衡。 （结论0分，缺失-1分，根据内容酌情加分） 附件（附件0分，缺失-1分）hello.c:c语言编写的源文件，以ASCII码编码hello.i:hello.c经预处理得到的文本文件hello.s:hello.i经编译得到的文本文件，包含汇编语言程序hello.o:hello.s经汇编得到的可重定位目标文件hello:经链接得到的可执行目标文件hello.out:hello的反汇编文件 参考文献为完成本次大作业你翻阅的书籍与网站等[1]预处理阶段所要做的工作_yuer的博客-CSDN博客_预处理阶段有哪些操作https://blog.csdn.net/u010141928/article/details/74200737?ops_request_misc=&request_id=&biz_id=102&utm_term=%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C&utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-1-.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187[2] [2]https://blog.csdn.net/qq_38769551/article/details/100901907?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162441678416780261963856%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162441678416780261963856&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2allbaidu_landing_v2~default-1-100901907.first_rank_v2_pc_rank_v29&utm_term=%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4&spm=1018.2226.3001.4187[3]https://blog.csdn.net/sphone89/article/details/5962699?ops_request_misc=&request_id=&biz_id=102&utm_term=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2&utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-4-.nonecase&spm=1018.2226.3001.4187[4]https://blog.csdn.net/genghaihua/article/details/89450057?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162452282716780261991449%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162452282716780261991449&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2alltop_positive~default-1-89450057.first_rank_v2_pc_rank_v29&utm_term=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80&spm=1018.2226.3001.4187[5]https://blog.csdn.net/Pipcie/article/details/105670156?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162452327216780264020679%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162452327216780264020679&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2allbaidu_landing_v2~default-1-105670156.first_rank_v2_pc_rank_v29&utm_term=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E6%8D%A2&spm=1018.2226.3001.4187[6]https://blog.csdn.net/asdfsadfasdfsa/article/details/98223811?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162452327216780262512185%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162452327216780262512185&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_v2~rank_v29-4-98223811.first_rank_v2_pc_rank_v29&utm_term=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E6%8D%A2&spm=1018.2226.3001.4187 （参考文献0分，缺失-1分） 
第385篇文章[]
ADTandOOP复习总结(一) ADTandOOP复习总结（一） 软件构造的理论基础 ADT(抽象数据类型) 软件构造的技术基础 OOP(面向对象编程) 章节目标 1.Gettoknowbasicknowledgeaboutdatatype,andstaticand dynamictypecheckinginprogramminglanguage,especiallyinJava.  静态/动态类型检查 2.Understandmutabilityandmutableobjects 可变/不变的数据类型 3.Identifyaliasingandunderstandthedangersofmutability  可变数据类型的危险性 4.Useimmutabilitytoimprovecorrectness,clarityandchangeability  不变数据类型的优越性 5.Usesnapshotdiagramtodemonstratethestateofspecifictime duringaprogram’sexecution. 用Snapshot图理解数据类型 6.UseArrays,CollectionsandEnumtodealwithcomplexdatatypes  用集合类表达复杂数据类型 7.KnowtheharmofNullreferencesandavoidit  了解空引用的危害，并避免使用它 1.Typesinjava 基本数据类型 –int(forintegerslike5and-200,butlimitedtotherange±2^31,or roughly±2billion) –long(forlargerintegersupto±2^63) –boolean(fortrueorfalse) –double(forfloating-pointnumbers,whichrepresentasubsetofthereal numbers) –char(forsinglecharacterslike'A'and'$') 对象引用数据类型 –Stringrepresentsasequenceofcharacters. –BigIntegerrepresentsanintegerofarbitrarysize. 根据Java约定，基础数据类型为小写，而对象类型以大写字母开头。 基础数据类型对象引用类型int,long,byte,short,char,float,double,booleanClasses,interfaces,arrays,enums,annotations只有值，没有ID(与其他值无法区分)既有ID，也有值Immutable不可变的Somemutable,somenot可变/不可变Onstack,existonlywheninuse在栈中分配内存Onheap,garbagecollected在堆中分配内存无法实现表达的统一UnityofexpressionwithgenericsDirtcheap代价低Morecostly代价昂贵 将基本数据类型封装为对象类型 Boolean,Integer,Short,Long,Character,Float,Double 通常是在定义容器类型的时候使用它们（容器类型操作的元素要求是 对象类型，所以需要对基本数据类型进行包装，转换为对象类型），一般情况下，尽量避免使用（会降低性能） 操作符 -Assignment:= –Addition:+ –Subtraction:- –Multiplication:* –Division:/ java不支持操作符重载，虽然java里的String可以使用"+"进行连接，貌似进行了运算符重载，但其实不是，这是JVM进行的处理，JVM编译的时候会构建一个StringBuilder，然后调用了append方法将字符串连接起来，这和C++的运算符重载有本质的不同 2.静态与动态数据类型检查 java是静态类型语言，类型检查在运行前就进行了，在像Python这样的动态类型语言中，这种检查会被推迟到运行时（当程序运行时） 检查类型 静态检查动态检查不检查在程序运行之前就会自动发现这个错误执行代码时会自动发现错误该语言根本不能帮助您查找错误。你必须自己注意，否则就会得到错误的答案可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性静态检查往往是关于类型的，这些错误与变量所具有的特定值无关。关于“值”的检查检查类容：Syntaxerrors，Wrongnames，Wrongnumberofarguments，Wrongargumenttypes，Wrongreturntypes，Illegalargumentvalues，Unrepresentablereturnvalues，Out-of-rangeindexes，Callingamethodonanullobjectreference 3.可变性和不可变性 改变一个变量：将该变量指向另一个值的存储空间。 改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。 重要设计原则：不变性，变化是“罪恶”，但程序不能没有变化，尽可能避免变化，以避免副作用 不变数据类型：一旦被创建，其值不能改变 如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变指向其他对象 4.快照图 用于描述程序运行时的内部状态便于程序员之间的交流便于刻画各类变量随时间变化便于解释设计思路 具体看课件上的图，怎么画解释的很清楚，这里不多赘述。 5.复杂数据类型 int[]a=newint[100]; –indexing:a[2] –assignment:a[2]=0 –length:a.length List<Integer>list=newArrayList<Integer>(); –indexing:list.get(2) –assignment:list.set(2,0) –length:list.size() Note1:Listisaninterface.列表是一个接口 Note2:membersinaListmustbeanobject.列表的成员必须是对象数据类型 集合是包含零或多个唯一对象的无序集合。 –s1.contains(e)testifthesetcontainsanelement –s1.containsAll(s2)testwhethers1⊇s2 –s1.removeAll(s2)removes2froms1 Setisanabstractinterface集合是一个抽象接口 AMapissimilartoadictionary(key-value) –map.put(key,val)addthemappingkey→val –map.get(key)getthevalueforakey –map.containsKey(key)testwhetherthemaphasakey –map.remove(key)deleteamapping Mapisanabstractinterface ImplementationsofList,Set,andMap:列表、集合和图的实现 –List:ArrayListandLinkedList –Set:HashSet –Map:HashMap List<String>firstNames=newArrayList<String>(); List<String>lastNames=newLinkedList<String>(); List<String>firstNames=newArrayList<>(); List<String>lastNames=newLinkedList<>(); Set<Integer>numbers=newHashSet<>(); Map<String,Turtle>turtles=newHashMap<>(); 迭代器 迭代器是一个对象，它遍历一组元素并逐个返回元素，for(…:…)形式的遍历，调用的是被遍历对象所实现的迭代器 迭代器（iterator）的两个方法： –next()returnsthenextelementinthecollection thisisamutatormethod! –hasNext()testswhethertheiteratorhasreachedtheendofthecollection 用法如下： List<String>lst=newArrayList<String>(); Iteratoriter=lst.iterator(); while(iter.hasNext()){ Stringstr=iter.next(); System.out.println(str); } 空引用的危害 在Java中，对对象和数组的引用也可以接受特殊值Null，这意味着该引用不指向对象。空值是Java类型系统中一个不幸的漏洞。基本数据类型不能为空，编译器将拒绝这样的带有静态错误的尝试：intsize=null;//illegal无法调用任何方法或使用具有这些引用之一的任何字段（抛出Null指针异常）null与空字符串“”或空数组不相同在参数和返回值中隐式地不允许使用空值。如果一个方法允许一个参数的空值，它应该显式地声明它，或者如果它可能因此返回一个空值，它应该显式地声明它。但这些通常都不是什么好主意。避免设置为空。 
第386篇文章[]
java接口(Interface)学习笔记 java接口(Interface)学习笔记 接口(Interface)，在java编程语言中是一个抽象类型，是抽象方法的集合，通常用interface来声明，一个类可以通过继承接口的方式，从而来继承接口的抽象方法。一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为 需要注意的是，接口并不是类，编写接口的方式和类很相似，但是他们属于不同的概念，类描述对象的属性和方法，接口则包含要实现的方法。 如下面这是一个典型的类 publicclassDog{ //类的属性,接口的属性只能是finalstatic的属性，不能是变量 Stringname; intsize; Stringcolour; intage; //类的构造函数，接口没有构造函数 publicDog(Stringname){ this.name=name; } /*类的方法方法有方法体，而接口的方法是抽象的，不能有方法体，必须由要实现它的类来定义这些方法*/ voidsetSize(intsize){ this.size; } voidsetColour(Stringcolour){ this.colour=colour; } voidsetAge(intage){ this.age=age; } } 接口与类相似点： 一个接口可以有多个方法。接口文件保存在.java结尾的文件中，文件名使用接口名。接口的字节码文件保存在.class结尾的文件中。接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别： 接口不能用于实例化对象。接口没有构造方法。接口中所有的方法必须是抽象方法。接口不能包含成员变量，除了static和final变量。接口不是被类继承了，而是要被类实现。接口支持多继承。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是publicstaticfinal类型的。接口中不能含有静态代码块以及静态方法(用static修饰的方法)，而抽象类是可以有静态代码块和静态方法。一个类只能继承一个抽象类，而一个类却可以实现多个接口。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。总而言之，实现接口的类除非是抽象类，否则该类要定义接口中的所有方法。 接口的声明语法格式如下 [可见度]interface接口名称[extends其他的接口名]{ //声明变量 //抽象方法 } 下面是个接口声明的简单例子 publicinterfaceNameOfInterface { //任何类型final,static字段 //抽象方法 } 接口有以下特性： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。接口中的方法都是公有的。接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。 实例 interfaceAnimal{ publicvoideat(); publicvoidtravel(); } 接口的实现 当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 实现一个接口的语法，可以使用这个公式：  implements接口名称[,其他接口名称,其他接口名称 , ]  实例(抽象类实现接口) 抽象类和接口都是java中用来实现多态的方法，在java一般的用法中，如果要用普通类来实现接口，则必须实现该接口中的所有方法，这样就会导致需要实现多余的方法； 采用抽象类来实现方法，可以实现该接口中的部分方法，而且当其他类继承该抽象类时，只需要实现抽象类中未实现的方法即可。 例: 抽象类B只实现了接口A中的方法a、b， 当类C继承类B时，只需要实现B中为实现的接口c即可。 一般情况下，类C中的方法a、b都是调用父类B的方法a、b。 接口代码 publicinterfaceAction{ publicvoidjump(); publicvoideat(); publicvoidrun(); } 抽象父类 publicabstractclassAnimalimplementsAction{ publicStringname; publicintage; publicAnimal(){ } publicAnimal(Stringname,intage){ this.name=name; this.age=age; } publicabstractvoidfly(); @Override publicvoidjump(){ System.out.println(name+"在跳高"); } //没有实现publicvoidrun()和publicvoideat(); } 子类： publicclassCatextendsAnimal/*implementsJumpping*/{ publicCat(){ } publicCat(Stringname,intage){ super(name,age); } //只需实现了抽象类的抽象方法publicabstractvoidfly(); publicvoidfly(){ System.out.println("猫在飞"); } publicstaticvoidmain(Stringargs[]){ Catcat=newCat("wyq",12); cat.fly; cat.jump();//canrun,ok! cat.fly();//canrun,ok! cat.run();//会报错，抽象父类中并没有实现这个方法 } } 实例(普通类类实现一个接口) 需要实现接口中的所有方法 publicclassDogimplementsAnimal{ //类的属性,接口的属性只能是finalstatic的属性，不能是变量 Stringname; intsize; Stringcolour; intage; //类的构造函数，接口没有构造函数 publicDog(Stringname){ this.name=name; } /*类的方法方法有方法体，而接口的方法是抽象的，不能有方法体，必须由要实现它的类来定义这些方法*/ voidsetSize(intsize){ this.size; } voidsetColour(Stringcolour){ this.colour=colour; } voidsetAge(intage){ this.age=age; } /*需要实现的接口的方法*/ @Override publicvoideat(){ System.out.println("Dogeats"); } @Override publicvoidtravel(){ System.out.println("Dogtravels"); } publicstaticvoidmain(Stringargs[]){ Dogdog=newDog("wyq"); dog.eat(); dog.travel(); } } 实例(普通类实现多个接口) 如现在有两个接口如下 publicinterfaceInterface1{ publicvoidmethod1(); } publicinterfaceInterface2{ publicvoidmethod2(); } 那么一个类可以一并实现上面两个接口 publicclassAimplementsInterface1,Interface2{ publicA(){ } @Override publicvoidmethod1(){ System.out.println("method1"); } @Override publicvoidmethod2(){ System.out.println("method2"); } } 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。一个类只能继承一个类，但是能实现多个接口。一个接口能继承另一个接口，这和类之间的继承比较相似。 接口的继承(extends关键字) java类的多继承是不合法，但接口是支持多继承的。 语法如下  extends接口名称,其他接口名称,其他接口名称 ,  如现在有两个接口如下 publicinterfaceInterface1{ publicvoidmethod1(); } publicinterfaceInterface2{ publicvoidmethod2(); } 那么第三个接口可以同时继承上面两个接口 publicinterfaceInterface3extendsInterface1,Interface2{ publicvoidmethod3(); } 实现类，A类实现了Interface3，需要将Interface3的方法和它继承的Interface1和Interface2的方法一并实现。 publicclassAimplementsInterface3{ @Override publicvoidmethod1(){ System.out.println("method1"); } @Override publicvoidmethod2(){ System.out.println("method2"); } @Override publicvoidmethod3(){ System.out.println("method3"); } publicstaticvoidmain(String[]args){ method1(); method2(); method3(); } } 
第387篇文章[]
java泛型理解 java泛型理解 泛型在java中经常使用，有很重要的作用，在做软件构造的实验，我对泛型的理解不是很深，但随着了解和运用越来越多，理解也就加深了，这里记录一下学习的理解 什么是泛型？ 泛型，即“参数化类型”，是对java语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样，泛型的本质是为了参数化类型，在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型，在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 对于常见的泛型模式，推荐的泛型类型变量有： E：元素（element），多用于java集合框架K：关键字（Key）N：数字（Number）T：类型（Type）V：值（value）T和T的区别：T是tpye的首字母缩写；T表示“返回值”是一个泛型，传入什么类型，就返回什么类型，而单独的“T"表示限制传入的参数类型 举个例子说明泛型的作用 ListarrayList=newArrayList(); arrayList.add("aaaa"); arrayList.add(100); for(inti=0;i<arrayList.size();i++){ Stringitem=(String)arrayList.get(i); Log.d("泛型测试","item="+item); } 运行程序，崩溃 java.lang.ClassCastException:java.lang.Integercannotbecasttojava.lang.String 原因是ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。 我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。 List<String>arrayList=newArrayList<String>();   //arrayList.add(100);在编译阶段，编译器就会报错 泛型的特性 泛型只在编译阶段有效。看下面的代码： List<String>stringArrayList=newArrayList<String>(); List<Integer>integerArrayList=newArrayList<Integer>(); ClassclassStringArrayList=stringArrayList.getClass(); ClassclassIntegerArrayList=integerArrayList.getClass(); if(classStringArrayList.equals(classIntegerArrayList)){ Log.d("泛型测试","类型相同"); } 输出结果：D/泛型测试:类型相同。 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 泛型如何使用 泛型有三种使用方式，分别为：泛型类，泛型接口，泛型方法 1.泛型类 泛型类型用于类的定义中，最典型的是各种容器类，如：List，Set，Map 泛型的基本写法： class类名称<泛型标识：可以随便写任意标识号，标识指定的泛型的类型>{ private泛型标识/*（成员变量类型）*/var;   } } 举个例子： /*T的类型由外部指定*/ publicclassExample<T>{ privatekey; publicExample(Tkey){ this.key=key } publicTgetkey(){ returnkey } } 那如何使用呢 //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型 //传入的实参类型需与泛型的类型参数类型相同，即为Integer. Example<Integer>genericInteger=newExample<Integer>(123456); //传入的实参类型需与泛型的类型参数类型相同，即为String. Example<String>genericString=newExample<String>("key_vlaue"); Log.d("泛型测试","keyis"+genericInteger.getKey()); Log.d("泛型测试","keyis"+genericString.getKey()); 结果： 泛型测试:keyis123456 泛型测试:keyiskey_vlaue 2.泛型接口 泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： //定义一个接口 publicinterfaceGen<T>{ publicTnext() } 当实现泛型接口的类，未传入泛型实参时： /** *未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 *即：classFruitGenerator<T>implementsGen<T>{ *如果不声明泛型，如：classFruitGeneratorimplementsGenerator<T>，编译器会报错："Unknownclass" */ classFruitGenerator<T>implementsGen<T>{ @Override publicTnext(){ returnnull; } } 当实现泛型接口的类，传入泛型实参时： /** *传入泛型实参时： *定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator<T> *但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 *在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 *即：Generator<T>，publicTnext();中的的T都要替换成传入的String类型。 */ publicclassFruitGeneratorimplementsGenerator<String>{ privateString[]fruits=newString[]{"Apple","Banana","Pear"}; @Override publicStringnext(){ Randomrand=newRandom(); returnfruits[rand.nextInt(3)]; } } 3.泛型方法 泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型。 假设需要实现这样一个方法：该方法负责将一个Object数组的所有元素添加到一个Collection集合中。考虑采用如下代码来实现该方法： staticvoidfromArrayToCollection(Object[]a,Collection<Object>c){ for(Objecto:a){ c.add(o); } } 上面定义的方法没有任何问题，关键在于方法中的c参数，它的数据类型是Collection。正如前面介绍的，Collection不是Collection的子类型 所以这个方法的功能很有限，它只能将Object[]数组的元素复制到元素为Object（Object的子类不行）的Collection集合中，即下面代码会引起问题。 String[]strArr={"a","b"}; List<String>strList=newArrayList<>(); //Collection<String>会报错，Collection<String>不能当做/Collection<Object>使用 可见上面方法的参数类型不可以使用Collection，使用通配符Collection<?>也不行，因为Java不允许把对象放进一个未知类型的集合里。为解决这个问题，可以使用泛型方法，在声明方法时定义一个或多个类型形参。泛型用法格式如下： 修饰符<T，S>返回值类型方法名(形参列表){ //方法体 } 该泛型方法的方法签名比普通方法的方法签名多了类型形参声明，类型形参声明以尖括号括起来，多个类型形参直接以逗号（，）隔开，所有的类型形参声明放在方法修饰符和返回值类型之间。采用支持泛型的方法，就可以将上面的fromArrayToCollection方法改写为如下形式 static<T>voidfromArrayToCollection(T[]a,Collection<T>c){ for(Objecto:a){ c.add(o); } } 可以看到Object被替换成了T，而且在修饰符和返回值中间加了 下面代码示范了完整用法 static<T>voidfromArrayToCollection(T[]a,Collection<T>c){ for(Objecto:a){ c.add(o); } } publicstaticvoidmain(Sting[]args){ Object[]oa=newObject[100]; Collection<Object>co=newArrayList<>(); fromArrayToCollection(oa,co) String[]sa=newString[100]; Collection<String>cs=newArrayList<>(); fromArrayToCollection(sa,cs) Integer[]ia=newInteger[100]; Collection<Integer>co=newArrayList<>(); fromArrayToCollection(ia,ci) } 上面程序调用了一个泛型方法，该泛型方法中定义了一个T类型形参，这个T类型形参就可以在该方法内当成普通类型使用。与接口、类声明中定义的类型参数不同的是，方法声明中定义的形参只能在该方法内使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。 与类，接口中泛型参数不同的是，方法中的泛型参数无须显式传入实际类型参数，如上面程序所示，当程序调用fromArrayToCollection()方法时，无须在调用该方法前传入String、Object等类型，但系统依然可以知道类型参数的数据类型，因为编译器根据实参推断类型实参的值，它通常推断出最直接的类型参数。 
第388篇文章[]
用git把本地文件推送到远程仓库 要把实验的项目交到GitHub上，因为用git提交的问题之前一直有点迷糊，今天再整理一下一.先提交到本地仓库1.之前的gitbash已经安装好了，检查一下名字和地址，可以看到已经完成了绑定 2.创建一个空目录并将它设置为当前目录用pwd查看当前目录，看到当前目录已经设置成labs了 本地已经创建了一个labs空目录（这里注意windows目录里不能有中文） 3.把目录初始化为仓库 4.把eclipse的项目文件一到这个目录下 这里这个报错是说，要把我文件里的所有LF换行符换成CRLF换行符，这个主要是因为不同操作系统的换行符不一样，如果是跨平台开发的话要执行gitconfigcore.sutocrlffalse,因为我们就交到GitHub上，所以就简单忽略这个警告就行了。5.把文件提交到仓库 二.再提交到远程仓库1.添加远程库，就是在GitHub上建立一个仓库，我这里就是统一要求的仓库 这里wyq-cloud的地方应该是你的GitHub的用户名，labs的地方应该是你的仓库名你也可以用另一种办法：使用SSHkey命令应该是：$gitremoteaddoriginSSHkey这个SSHkey从GitHub上得到：进入你的仓库主页，在下载代码的地方 有一个SSH把它复制下来，粘贴到SSHkey的地方就行了（如果你这个命令用错了，添加了一个不存在的远程仓库，后面推送本地库内容会报错： 你可以删掉刚才那个库： 然后重新添加远程库）2.把本地库的内容推送到远程库 远程库里就有这些文件里，在master分支里 参考：https://blog.csdn.net/weixin_42152081/article/details/80558282?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162526935516780261942725%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162526935516780261942725&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2alltop_positive~default-1-80558282.first_rank_v2_pc_rank_v29&utm_term=git&spm=1018.2226.3001.4187 
第389篇文章[]
软件构造复习笔记（一） 软件构造复习：软件构造的多维度视图和质量目标1.按阶段划分：构造时/运行时视图（phases：build-/run-timeviews）按动态性划分：时刻/阶段视图（moment/periodviews）按构造对象的层次划分：代码/构件视图（levels:code/componentviews）2.软件构造：在不同视图间转换3.五个关键的质量目标：(1)容易理解：understandability可理解性.(2)准备好改变：maintainabilityandadaptability可维护性和适应性(3)发展的成本低：designwith/forreusereusability可复用性(4)健壮性(5)表现？Performance一．多维度软件视图1.Software=Program+Data+Documents软件=程序+数据+文档2.Software=Modules(Components)+Data/ControlFlows软件=模块（构件）+数据流/控制流3. 时刻时间段 代码构件代码构件构造时源代码静态链接codechurn配置项抽象语法树包、库、版本接口-类-属性文件、测试用例–方法、构造脚本（类图）（构件图） 代码构件代码构件运行时代码快照动态链接并行多线程事件日志内存转储包、库、执行时栈轨迹多进程、配置、中间件、分布式进程网络、数据库1）构造时视图1.代码层面：代码的逻辑组织：接口、类、方法、函数构件层面：代码的物理组织：库、包、目录、文件时刻：特定时刻软件形态时间段：软件形态随时间变化2.Build-time/moment/code:三种相互关联的形式：词汇层面:半结构化的语法层面:（AST）彻底结构化，将源代码变为一棵树语义层面:表达需求和设计思想Build-time/period/code:Codechurn代码变化Build-time/moment/component:源代码-文件-（目录）-包-构件-子系统-库3.库：操作系统提供的/编程语言提供的/第三方提供的/自己积累的4.静态链接：在静态链接里、库是单个对象文件的集合。Build进程时，如果一个函数被需要，链接工具会把它从库里抽取出来，复制到可执行文件中，执行的时候就是代码的一部分了，不再需要库文件。静态链接发生在构造阶段（buildtime）可执行文件被加载到机器上时静态链接就结束了，；最终的可执行文件被创建之后，就不能再从库中分离程序。（UML是统一软件建模语言；VCS版本控制系统；SCI软件配置项）2）运行时视图1.运行时：程序被载入目标文件，开始执行代码层面：逻辑实体在内存中如何呈现构件层面：物理实体在物理硬件环境中如何呈现2.一个库不能直接在机器上加载执行，必须先连接到可执行文件3.NativeMachineCode(原生机器码）：CPU可以直接理解，最快的执行代码的方法4.FullProgramInterpretation（程序完全解释执行）5.InterpretedByteCodes（解释型字节码）：（JVM：java虚拟机）6.动态链接：库文件在build阶段不被加入可执行文件，只做出标记；运行时，根据标记装载库值内存；发布软件时，需要把所有动态库也复制给用户优点：更新库的版本不需要重新创建可执行文件；许多操作系统值上传一份副本到内存，然后分享7.分布式程序的运行态：需要多个运行程序，分别不属于多个计算机物理环境8.Run-time/moment/code:代码快照：程序运行时内存里变量层面的状态内存信息转储：进程因为某些原因终止时，在内存里存一个它的内容的副本Run-time/period/code:执行跟踪：用日志方式记录程序执行的调用次序Run-time/Period/component:日志（系统层面） 
第390篇文章[]
2021-06-23 软件构造课后感想 软件构造课程已经接近尾声，实验也均验收，所以这里大致写一下对于课程和实验的一些感想。这门课程在期中开课，学时相比前几年缩减了一半以上，但是学习的内容似乎没有减少，区别是实验少做了一个，并且前三个实验的内容有所减少，总体来说压力是很大的，因为同期还有CSAPP这门大课。对于课程内容，因为学时压缩，感觉内容有些过多了，主要运用了java学习软件构造，包括测试，数据类型，规约，面对复用性，可维护性，健壮性，正确性进行软件构造等内容，使我们对软件构造有了一个大体的认知，并且也基于老师给的模板进行了部分实践，可以说收获是比较多的，对于编程也有了进一步的了解，相比之前学习的数据结构，高级程序语言设计等课上单纯的算法题目或者是对于数据结构，数据类型的学习，软件构造课上所学到的内容更加综合化，具体，面向实践，使我们对程序的理解更加深入，但是没有教材，并且ppt也基本是英文的，这一点有些遗憾，对于课程的学习造成了不小的困难，因为专业术语较多，即使借助翻译软件进行学习，结果也不尽人意，希望以后可以推出中文的教材或者是翻译后的ppt，这样自学时会方便许多。再谈谈实验，因为之前几乎没有关于java的学习，学校也没有安排相关的课程，而实验使用的是java语言，并且运用较为深入，不是之前对于c语言的那种简单使用，所以在实验过程中遇到了很多的障碍，java的使用不熟练对实验影响很大，个人认为软件构造课程初期应该至少花几节课的时间讲解一下java的基础使用，做实验的时候，不少地方都是大概理解应该如何实现，理解思想也有了思路，但是用java却不知道该怎么做，所以实验完成的过程效率很低，花费了过多的且没有必要的时间。但是实验本身是十分契合教学的，实验中对课程所讲授的内容基本都有涵盖，让我们对于课程内容真正地有了一些理解，如果能够在不查阅资料的情况下很好地完成实验，那么对于这门课程的学习基本就没有问题了，所以我认为实验设计的是很好的。既能复习巩固上课所学习的知识点，也能在实验的过程中自学不少知识。 
第391篇文章[3]
刷题心得-Q1最大子列和问题 01-复杂度1最大子列和问题(20分)给定K个整数组成的序列。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{-2,11,-4,13,-5,-2}，其连续子列{11,-4,13}有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下： 数据1：与样例等价，测试基本正确性；数据2：102个随机整数；数据3：103个随机整数；数据4：104个随机整数；数据5：105个随机整数；输入格式:输入第1行给出正整数K(≤100000)；第2行给出K个整数，其间以空格分隔。 输出格式:在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 输入样例:6-211-413-5-2输出样例:20两种巧妙的方法 第一种：采用分治的策略 子列和可以分成三块 左边的最大子列和，右边的最大子列和，从中间开始，包含左边与右边的子列和 那么，按照这种方法，问题的时间复杂度就成为了O(n/2)+O(n/2)+O(N) 就是n*log(n)的规模 #include<stdio.h> #include<stdlib.h> intcom2(intn1,intn2) { if(n1>n2) { returnn1; } else{ returnn2; } } intcom3(intn1,intn2,intn3) { inta=com2(n1,n2); intb=com2(a,n3); returnb; } intslovemax(int*ar,intn,inthead,intlast)//有些细节要严谨注意！！！ { if(head==last) { if(ar[head]<0){ returnar[head];} else { return0; } } intzuo=slovemax(ar,n,head,(last+head)/2); intyou=slovemax(ar,n,((last+head)/2)+1,last); inti,j,k; intzj_zuo=0,zj_you=0,zm=0,ym=0; i=j=(last+head)/2; for(;i>=head;i--) { zj_zuo+=ar[i]; if(zm<zj_zuo) { zm=zj_zuo; } } j++; for(;j<=last;j++) { zj_you+=ar[j]; if(ym<zj_you) { ym=zj_you; } } inttol=zm+ym; intmore1=com3(zm,ym,tol); returncom3(zuo,you,more1); } intmain() { intn; scanf("%d",&n); intar[n]; inti,j,k; for(i=0;i<n;i++) { scanf("%d",&ar[i]); } intmaxsum=0,thissum=0; printf("%d",slovemax(ar,n,0,n-1)); } 第二种方法：线性扫描的方法 从左往右扫描，最大和先初始为零，现在和+=a[i]，如果现在和为负，现在和=0， 每次如果现在和大于最大和，更新 这种方法，保证了在i固定时，最大和一定是前i个元素里面最大的。 #include<stdio.h> #include<stdlib.h> intmain() { intn; intmax=0,tm=0; scanf("%d",&n); inti,j,k,temp; for(i=0;i<n;i++) { scanf("%d",&temp); tm+=temp; if(tm<0) { tm=0; } if(tm>max) { max=tm; } } printf("%d",max); } 
第392篇文章[3]
最短路径问题学习心得 最短路径问题（浙大MOOC学习笔记） 单源最短路（时间最短，路程最短，边的个数。。。）：源点固定的 ​无权图 ​有权图 多源最短路：任意两个顶点之间 无权图的单源最短路 就是一次BFS，借助队列，很好实现 当然了，我们需要把BFS里面的Visitied改一下，改为源点到各个点的最短距离dist （初始化：正无穷，负无穷，-1）（与visitied的作用类似） 还有一个细节，我们需要用一个数组path，来存储路径 path存什么？ 前一个顶点！ 我们最后求解结束以后，从V点倒推到原点，利用堆栈，可以很好的实现反向。 伪码如下： voidUnweighted(VertexS) {Enqueue(S,Q); while(!IsEmpty(Q)){ V=Dequeue(Q); for(V的每个邻接点W) if(dist[W]==-1){ dist[W]=dist[V]+1; path[W]=V; Enqueue(W,Q); } } } 这种方法的时间复杂度应该是O（V+E) 有权图的单源最短路 （首先声明：图里面没有负值圈，因为会挂,也暂时没有负边） 与无权图的算法的类似之处：路径的长度是依次递增的。 Dijkstra算法的基本描述 设V为点集，E为带权值的边集，v0为原点，那么，我们进行如下的操作： 每次更新集合V的划分V1，V2（其中V1是已经确定最短距离的点集）V2是待确定的点集 我们要做的：从V2里面取一个与v0距离最短的点p，放到V1里面。 更新所有与p邻接的点的与v0距离（即考虑以p作为中介顶点带来的影响） 若V2为空集，结束 算法细节的简化版证明 最短路径一定仅经过V1里面的顶点pf：如果在V2里面存在顶点m，使得V1-m-p的长度小于V1-p，那么由于路径长度是从小到大递增的，导出m-V1的距离，小于p-V1，m应该在先于p出现在V1里面，矛盾!每次p收到V1里面后，仅对V2里面与p邻接的点进行更新就可以了pf：因为V1里面的点的距离已经是最短了，无需更新，而V2里面的点，由于p的最短距离的确定，会影响与p邻接的顶点与v0的已知最短距离，所以，更新与p邻接的顶点。dist[W]=min(dist[W],dist[p]+<p,W>) 算法的实现细节 V1与V2的划分，我们利用collected数组实现距离的存储我们利用dist数组实现，初始化应该利用正无穷path[W]=V，来存路径。 伪码描述: voidDijkstra(Vertexs) {while(1){ V=未收录顶点中dist最小者; if(这样的V不存在) break; collected[V]=true; for(V的每个邻接点W) if(collected[W]==false) if(dist[V]+E<V,W><dist[W]){ dist[W]=dist[V]+E<V,W>; path[W]=V; } } } 有权图的多源最短路 引入floyd算法 for(i=1;i<=v;i++) { for(j=1;j<=v;j++) {D[i][j]=g[i][j];}//初始化D（-1） } for(k=1;k<=v;k++) { for(i=1;i<=v;i++) { for(j=1;j<=v;j++) { if((D[i][k]+D[k][j])<D[i][j]) { D[i][j]=D[i][k]+D[k][j]; } } } } 其中，如果想要导出路径，我们利用path来解决问题 i-j经过k 所以，找i-j转化为i-k与k-j 问题解决 最后，咱还得那几道题目来检验下自己的水平： 第一题哈利波特的考试 07-图4哈利·波特的考试(25分) 哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。 现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。 输入格式: 输入说明：输入第1行给出两个正整数N(≤100)和M，其中N是考试涉及的动物总数，M是用于直接变形的魔咒条数。为简单起见，我们将动物按1~N编号。随后M行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。 输出格式: 输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。 输入样例: 611 3470 121 5450 2650 5660 1370 4660 3680 51100 2460 5280 输出样例: 470 蛮简单的，直接floyd一遍，找出每行最小，再找出所有的最小 代码见下： #include<iostream> #include<queue> #include<stdio.h> #defineMAXVALUE99999 usingnamespacestd; intg[120][120]; intv,e; voidstart() { cin>>v>>e; inti,j,x,y,value; for(i=0;i<e;i++) { cin>>x>>y>>value; g[x][y]=value; g[y][x]=value; } for(x=1;x<=v;x++) { for(y=1;y<=v;y++) { if(g[x][y]==0) { g[x][y]=MAXVALUE; } } } } voidfloyd() { inti,j,k,n; intD[120][120]; for(i=1;i<=v;i++) { for(j=1;j<=v;j++) {D[i][j]=g[i][j];}//初始化D（-1） } for(k=1;k<=v;k++) { for(i=1;i<=v;i++) { for(j=1;j<=v;j++) { if((D[i][k]+D[k][j])<D[i][j]) { D[i][j]=D[i][k]+D[k][j]; } } } } intanimals[120],tempmax; for(i=1;i<=v;i++) { tempmax=0; for(j=1;j<=v;j++) { if(i!=j) { if(D[i][j]>tempmax) { tempmax=D[i][j]; } } } animals[i]=tempmax; } intminvalue=MAXVALUE,minloca=-1,temp; for(i=1;i<=v;i++) { if(minvalue>animals[i]) { minvalue=animals[i]; minloca=i; } } if(minloca==-1) { cout<<"0"; } else { cout<<minloca<<""<<minvalue; } } intmain() { start(); floyd(); } 练习2旅游规划 （居然一遍编译就AC了，233333） 蛮简单，把正常的Dij算法里面的path变成money，问题就结束了。。。 07-图6旅游规划(25分) 有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。 输入格式: 输入说明：输入数据的第1行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0~(N−1)；M是高速公路的条数；S是出发地的城市编号；D是目的地的城市编号。随后的M行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。 输出格式: 在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。 输入样例: 4503 01120 13230 03410 02220 23120 输出样例: 340 代码如下： #include<iostream> #defineinf9999999 usingnamespacestd; structway { intlenth; intprice; /*data*/ }graph[530][530]; intN,M,S,D; intmoney[530]; intdist[530]; intcollect[530]; voidini() { cin>>N>>M>>S>>D; inti; intx,y,l,p; for(i=0;i<M;i++) { cin>>x>>y>>l>>p; graph[x][y].lenth=l; graph[x][y].price=p; graph[y][x].lenth=l; graph[y][x].price=p; } } intfind_mindist() { inti,tem=inf-5,rem=-1; for(i=0;i<N;i++) { if(dist[i]<tem&&collect[i]==0) { tem=dist[i]; rem=i; } } returnrem; } intmin(inta,intb) { if(a<b) {returna;} else { returnb; } } voidda() { inti,j,k; intp; for(i=0;i<N;i++) { dist[i]=inf; } dist[S]=0; money[S]=0; while(1) { p=find_mindist(); if(p==-1) { break; } else { collect[p]=1; for(i=0;i<N;i++) { if(graph[p][i].lenth!=0&&collect[i]==0) { if((graph[p][i].lenth+dist[p])<dist[i]) { dist[i]=graph[p][i].lenth+dist[p]; money[i]=money[p]+graph[p][i].price; } if((graph[p][i].lenth+dist[p])==dist[i]&&money[i]>(money[p]+graph[p][i].price)) { dist[i]=graph[p][i].lenth+dist[p]; money[i]=money[p]+graph[p][i].price; } } } } } cout<<dist[D]<<""<<money[D]; } intmain() { ini(); da(); } 
第393篇文章[]
一篇通俗易懂的ADT介绍 最近笔者通过哈工大的软件构造课程,学习了抽象数据类型.我们,将通过打比方的形式,通俗易懂的给大家讲明白ADT是谁,为什么要有这个东西,以及,怎么构建它 ADT:抽象数据类型 定义:抽象数据类型（AbstractDataType，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。按照MIT的说法,ADT可以用下面的这幅图来进行描述: 直观的看,ADT就是一道墙,将内在的表示与外部的使用进行隔离这种隔离,通过接口进行的间接访问,降低了代码块与块之间的耦合性. 下面的两个比喻,形象生动的说明了ADT是干什么的,为什么这么重要: 就像盖房子,我们写的软件代码,java里面一个个的Class,就像很多的***普通的砖头***,我们并不需要他们每一个都那么的独领风骚,我们需要每一块砖头都长得差不多,标准一致,这样可以进行将砖头进行千百次的堆砌.同时,我们需要一块砖头如果觉得它存在质量问题,我们可以马上用另一块相似的砖头进行代替.就像军舰里面的***水密隔舱***,通过一层一层的将船与外面的大海进行隔离,那么如果一侧因为中弹而进水,将防水门一关,进水将不会影响到军舰的其余部分. 为了能够造出更规则统一的砖头(水隔舱),无数计算机领域的巨佬,研究出ADT这样的指导思想,帮助外面更好的,造出统一而又安全的砖头. 可变与不可变数据类型 还是使用砖头来作比方:如果我们想要自己用砖头搭建起来的房子是可以平稳存在的,那么,我们就首先得要求这个砖头,它是稳定的.不可变数据类型就像是一块死砖头,它不会因为外界的操作而改变自己的属性,可以说这个砖头,它是死的.我们就可以依靠这个砖头来作房子的地基.从而使房子四平八稳.比如说,上图的字符串String,就是不可变的,它如果对其进行操作,会直接返回新的一个对象那么,如果我们的代码里面用了可变的数据类型,它会带来什么后果呢? 直接给外界你内部的属性的指针,让外界直接对内部属性进行修改.导致一些很阴间的bug.比如:神不知鬼不觉的,数据结构内部属性的值一下子就变了… /** *@returnthefirstdayofspringthisyear */ publicstaticDatestartOfSpring(){ returnaskGroundhog(); } ******************************************** //somewhereelseinthecode  publicstaticvoidpartyPlanning(){ DatepartyDate=startOfSpring(); //  } /** *@returnthefirstdayofspringthisyear */ publicstaticDatestartOfSpring(){ if(groundhogAnswer==null){ groundhogAnswer=askGroundhog(); } returngroundhogAnswer; } privatestaticDategroundhogAnswer=null; ********************************************** //somewhereelseinthecode  publicstaticvoidpartyPlanning(){ //let'shaveapartyonemonthafterspringstarts! DatepartyDate=startOfSpring(); partyDate.setMonth(partyDate.getMonth()+1); // uh-oh.whatjusthappened? } 所以,正如大厦的地基必须要用混凝土和坚实的砖石来打,程序内部所依靠的数据类型,最好是采用不可变的数据类型 Spec规约 假如我们是来给别人家房子的施工队,在出发之前,一般都是要和雇主甲方爸爸签一个文书的,这个就是规约Spec 这个spec,它通过规定双方的责任,也就是产品问题,找谁说理去.细分为两大类:前置条件:如果产品坏了,这个责任在用户.后置条件:如果产品坏了,这个责任在施工队. 在我们写Java程序时,其实,也有这样的一个spec要去完成它长这样: /** *Findavalueinanarray. *@paramarrarraytosearch,requiresthatvaloccursexactlyonce *inarr *@paramvalvaluetosearchfor *@returnindexisuchthatarr[i]=val */ staticintfind(int[]arr,intval) 不难发现里面的前置与后置可以大致分下: 前置条件 @paramarrarraytosearch,requiresthatvaloccursexactlyonceinarr @paramvalvaluetosearchfor find(int[]arr,intval) 后置 Findavalueinanarray. @returnindexisuchthatarr[i]=val 它就像一个防火墙,隔绝开了用户与程序内部的表示. 换一种视角数据->操作 如果我们对之前学的数据结构与算法换一种视角来看,我们的数据结构其实可以被一组操作进行刻画. 比如说,以我手里的茶杯为例它作为一名普普通通的茶杯,它可以用以下操作来刻画 classTeaCup{ /** *喝茶 */ publicDrink(){}; /** *倒茶 */ publicFill(WaterTea){}; } 我们作为21世纪的消费者,是不需要了解这个茶杯它是用硅酸盐组成的.然后里面添加了什么样子的化学物质来进行塑性等待的细节.我们使用的,只是它给我们的两个方法:喝茶,倒茶. ADT也一样,我们给外界的是一组操作,而非内部的表示. 四大er,四种方法 具体来说,这些操作可以细分为四大方法:以杯具的一生为例: 构造器:凭空直接给你造出一个茶杯生产器:放入一个白色的茶杯,与一些颜料,给你返回一个黑色的茶杯观察器:看下茶杯是否为空的,里面的茶叶是什么品种的.变值器:放入一个空茶杯,返回一个打满了茶水的茶杯. 来一点数学:抽象函数AbstractFunction 我们上面说了这么多,其实可以用一个简单的数学映射加以描述 AF(内在表示)==>抽象值 程序员需要利用号内在的表示值,同时编写程序,来进行映射,向外界提供观测,修改抽象值的接口. 这便是抽象.通过抽象,隐藏底层复杂的实现细节,将间接,可靠一致的抽象操作提供给外界,从而达到降低系统整体的耦合度的效果. 底层的实现细节就是R空间.而用户关注的空间,或者说,我们给用户呈现的空间,就是A空间,即抽象空间. 下面就是一个例子,通过抽象函数,我们将字符串映射到了集合空间A里面. 左边的R,是Representation,即数据表示.这个,便如我们施工队的比方,是我们房子下面的地基.这个地基,必须要稳,否则房子本身就是不稳定的,有害于人民群众的财产安全. 所以,我们作为ADT的编写者,有责任去做点事情,来确保这个房子是稳定的.体现为: RI表示不变量 还是以集合为例,我们用按顺序排列的字母来队这个集合进行表示,所有串里面的字符排列,必须是升序的.这个升序,就是RI,它对表示空间进行了划分,将我们用到的合法的值,映射为true,其余为false用函数的角度来说 RI(表示)==>{true,false} 我们还可以在代码里面对这个进行检查,因为只要我们的表示什么时候被RI给映射到了false,那么就意味着,我们的代码出bug了… 上述内容便是ADT的一些介绍,谢谢大家. 
第394篇文章[]
五种基于委托(delegation)设计模式的场景+代码分析 笔者在复习哈工大软件构造的设计模式时,对最基本的五种设计模式,展开了探讨 当然,借着编程操作的机会,也练习了一下正则匹配,防御式编程参数检查等一些软构课上教的(要考的)内容下面是五种基本的设计模式试用场景 目录 工厂方法装饰器模式适配器模式迭代器模式访问者模式小结 工厂方法 基本介绍通过工厂类,将客户端与client进行隔离开场景:假如我们要为一个游戏写NPC,考虑到NPC以后的种类会很多,所以,应该建议采用工厂方法而不是new,对NPC进行创建 //main publicclassCM{ publicstaticvoidmain(String[]args){ PersonP=PersonFactory.createPeron("M");//由静态工厂方法调用 System.out.print(P.getName()); } } //NPC publicclassPerson{ privatefinalStringname; publicPerson(StringN){ this.name=N; } publicStringgetName(){ returnname; } } //NPC的工厂方法: packageFactory; publicclassPersonFactory{ //普通工厂 publicPersonCreatPerson(Stringn){ returnnewPerson(n); } //静态工厂方法 publicstaticPersoncreatePeron(Stringn) { returnnewPerson(n); } } 装饰器模式 场景:假如我们的游戏需要对NPC进行包装 穿上了防弹衣可以防弹穿上雨衣可以防雨穿上了翅膀可以飞 客户需要构造穿着雨衣的鸟人和穿着防弹衣的鸟人 那么可以这样构造 //human的接口 publicinterfaceHuman{ /** *进行互动的行为 */ publicvoidaction(); } //human的实现基类 publicclassConcreteHumanimplementsHuman{ @Override publicvoidaction(){ System.out.println("我是Human"); } } /** *装饰类基类 */ publicclassBasicDecoratorimplementsHuman{ privatefinalHumanh0; publicBasicDecorator(Humanh1){ if(h1==null){//进行参数的检查 thrownewNullPointerException();//runTimeException } h0=h1; } @Override publicvoidaction(){ h0.action(); } } //三种装饰器 publicclassRaincoatHumanextendsBasicDecorator{ publicRaincoatHuman(Humanh1){ super(h1); } @Override publicvoidaction(){ System.out.println("这人穿了雨衣"); super.action(); } } publicclassFlyableHumanextendsBasicDecorator{ publicFlyableHuman(Humanh1){ super(h1); } @Override publicvoidaction(){ System.out.println("这人长了翅膀可以飞"); super.action(); } } publicclassBullyProfHumanextendsBasicDecorator{ publicBullyProfHuman(Humanh1){ super(h1); } @Override publicvoidaction(){ System.out.println("这人刀枪不入"); super.action(); } } //main函数 publicstaticvoidmain(String[]args){ //穿着雨衣的鸟人 HumanH0=newRaincoatHuman(newFlyableHuman(newConcreteHuman())); H0.action(); //穿着防弹衣的鸟人 HumanH1=newBullyProfHuman(newFlyableHuman(newConcreteHuman())); H1.action(); } 输出: 具体的UML类图 适配器模式 场景:假如我们由一个算法的黑盒子,只能够接受浮点数据为输入,以整形数为输出.而我们现在向用户提供的接口是字符串为输入,字符串为输出.这个时候,需要我们利用适配器,对类进行适配. 注意:我们需要对前置条件的参数进行检查,同时,也需要检查后置条件是否满足.采取的思路:前面的前置,利用正则进行检查,抛出UncheckedException.后面的用assert来进行判定,判定后置条件是否满足.思考:一个合法的浮点数,长什么样子? 不是0003.14这样子的,这样子太丑了可以没有小数点,但是如果有小数点,我们需要对后面的数位进行判定 我们写正则的时候,需要体现对思考的check //假如我们由一个黑盒: /** *年份久远的黑盒,可以work */ publicclassOldBlackBox{ publicintgetAnswer(doubled0){ System.out.println("计算中 "); return888; } } //我们向用户承诺了一个API接口 publicinterfaceAPIUserInterface{ /** *我们的API向用户提供的方法 * *@param以小数形式的字符串,必须为合法的小数,如为非0098.xxx格式(大于一的,前方不能含有0) *@return字符串形式的整形数888 */ publicStringAPIWork(Stringinput); } //现在我们对这个进行适配 publicclassAdapterimplementsAPIUserInterface{ @Override publicStringAPIWork(Stringinput){ //进行检查前置条件是否合法 if(!input.matches("([1-9][\\d]*|[0-9])(\\.[\\d]+)?"))//运用正则 { thrownewIllegalArgumentException("输入数据:"+input+"不是合法的浮点数"); } System.out.println("你输入了:"+input); //Delegate黑盒进行计算 OldBlackBoxOBB=newOldBlackBox(); Doubled0=Double.valueOf(input); Integeri=OBB.getAnswer(d0); StringRET=i.toString(); //检查后置条件是否合法 assertRET.equals("888"); returnRET; } } //用户代码: publicstaticvoidmain(String[]args){ APIUserInterfaceAPIU=newAdapter(); System.out.println(APIU.APIWork("996")); System.out.println("--------------"); System.out.println(APIU.APIWork("18.47")); System.out.println("--------------"); System.out.println(APIU.APIWork("18..47")); } 输出: 迭代器模式 场景:假如我们向用户提供一个List的抽象,用户可以从头进行顺序遍历到尾部. List需要满足其类型是Number的子类 //直接写了一个数组 publicclassUniqueList<LextendsNumber>implementsIterable{ privatefinalList<L>L0; publicUniqueList(){ L0=newArrayList<>(); } publicvoidadd(Lll){ L0.add(ll); } //按照王老师的做法,这里可以直接在类里面写迭代器,这样,就可以直接访问类里面的信息 privateclassUniqueIterator<L>implementsIterator<Object>{ privatefinalList<L>myL=newArrayList(L0); privateintcurrent=0; @Override publicbooleanhasNext(){ returncurrent<myL.size(); } @Override publicObjectnext(){ if(!hasNext()){ thrownewArrayIndexOutOfBoundsException("你访问第"+(1+current)+"个(1~n)元素,导致数组越界"); } Llo=myL.get(current); current++; returnlo; } @Override publicvoidremove(){ thrownewUnsupportedOperationException("删除元素并没有得到支持"); } } @Override publicIterator<L>iterator(){ returnnewUniqueIterator(); } } //客户端 publicstaticvoidmain(String[]args){ UniqueList<Integer>UL=newUniqueList<Integer>(); UL.add(5); UL.add(4); UL.add(3); UL.add(2); UL.add(1); Iterator<Integer>uli=UL.iterator(); while(uli.hasNext()){ System.out.println(uli.next()); } uli.next();//试图访问越界 结果: 访问者模式 场景:假如我们已经写好了一个数组的类.考虑到未来的扩展,我们留存了一个accept的方法来允许visitor对其进行访问 现在目标逐渐明确, 1.用一个visitor来进行访问数组,求平均值 2.用一个visitor来访问数组,求总和 3,用一个visitor来访问数组,求向量的模长 默认数组是int类型的 //我们的数组接口 publicinterfaceListInterface0extendsIterable{ /** *获取idx位置的元素 * *@paramidx合法的位置 *@returnidx位置的元素 */ publicintgetElement(intidx); /** *添加元素 * *@paramval添加的元素 */ publicvoidaddElement(intval); /** *接受访问者v0的扩展 * *@paramv0访问者 */ publicvoidaccept(Visitorv0); } //我们的访问者接口 publicinterfaceVisitor{ /** *对列表进行访问 * *@paramL0 */ publicvoidvisit(ListInterface0L0); } 数组接口的实现代码 publicclassList2implementsListInterface0{ privatefinalList<Integer>L0=newArrayList<>(); @Override publicintgetElement(intidx){ returnL0.get(idx); } @Override publicvoidaddElement(intval){ L0.add(val); } //按照王老师的做法,这里可以直接在类里面写迭代器,这样,就可以直接访问类里面的信息 privateclassUniqueIterator<L>implementsIterator<Object>{ privatefinalList<L>myL=newArrayList(L0); privateintcurrent=0; @Override publicbooleanhasNext(){ returncurrent<myL.size(); } @Override publicObjectnext(){ if(!hasNext()){ thrownewArrayIndexOutOfBoundsException("你访问第"+(1+current)+"个(1~n)元素,导致数组越界"); } Llo=myL.get(current); current++; returnlo; } @Override publicvoidremove(){ thrownewUnsupportedOperationException("删除元素并没有得到支持"); } } @Override publicIterator<Integer>iterator(){ returnnewUniqueIterator(); } @Override publicvoidaccept(Visitorv0){ v0.visit(this); } } 三种访问者的实现代码: //平均值访问者 publicclassMeanVisitorimplementsVisitor{ @Override publicvoidvisit(ListInterface0L0){ intsum=0; inti=0; Iterator<Integer>ii=L0.iterator(); while(ii.hasNext()){ sum+=ii.next(); i++; } System.out.println("平均值为:"+(double)((double)sum/i)); } } //总和访问者 publicclassSumVisitorimplementsVisitor{ @Override publicvoidvisit(ListInterface0L0){ intsum=0; inti=0; Iterator<Integer>ii=L0.iterator(); while(ii.hasNext()){ sum+=ii.next(); i++; } System.out.println("总和为:"+(sum)); } } //向量长度访问者 publicclassVecLengthimplementsVisitor{ @Override publicvoidvisit(ListInterface0L0){ intsum=0; Iterator<Integer>ii=L0.iterator(); while(ii.hasNext()){ intt=ii.next(); sum+=(t*t); } System.out.println("向量长度为:"+(sum)); } } 主函数 publicstaticvoidmain(String[]args){ ListInterface0L2=newList2(); L2.addElement(5); L2.addElement(4); L2.addElement(3); L2.addElement(2); L2.addElement(2); L2.accept(newMeanVisitor()); L2.accept(newSumVisitor()); L2.accept(newVecLength()); } 输出: UML图: 可以发现,访问者与被访问者互相依赖 小结 根据王忠杰老师所言:这五种设计模式,均是对委托(两颗继承树)的变形与拓展.在动手操作之后,发现老师说的,还真是蛮有道理的,脑海里对基本的设计模式的UML图有一个基本的映像,动手操作起来,还真是不难的. 以上便是这篇博客的全部内容.谢谢. 
第395篇文章[]
哈工大2021软件构造实验3心得(1)-进行GUI设计 哈工大2021软件构造实验3心得(1)-进行GUI设计 最近,笔者完成下窝工的软构实验三.在完成过程中,有很多坑想要记录一下.顺便方便一下后来的窝工学子. 此Blog主要讨论如何在Eclipse里面写出一个GUI WindowBulider介绍 来自应用商店的介绍:WindowBuilderiscomposedofSWTDesignerandSwingDesignerandmakesitveryeasytocreateJavaGUIapplicationswithoutspendingalotoftimewritingcode.UsetheWYSIWYGvisualdesignerandlayouttoolstocreatesimpleformstocomplexwindows;theJavacodewillbegeneratedforyou.Easilyaddcontrolsusingdrag-and-drop,addeventhandlerstoyourcontrols,changevariouspropertiesofcontrolsusingapropertyeditor,internationalizeyourapp,andmuchmore. 下面我们来介绍一下怎么来进行安装: WindowBuilder的安装 我们直接用最简单的方法,在Eclipse的商店里面装,但是,这个网站由于某种原因,它比较慢,所以,我们选择了换镜像 Eclipse镜像配置 毕竟工欲善其事，必先利其器,秉承着这样一个原则,我们首先对Eclipse的镜像进行配置.(1)打开Window里面的preference界面 (2)直接搜sites关键词进入AvailableSoftwareSites然后把里面的把这里链接里面的http://download.eclipse.org/替换为http://mirrors.ustc.edu.cn/eclipse即把它自己的源,更新为清华镜像比如说以AmaterasUML为例: 如果想进一步的探讨换镜像,可以参考大佬的博客,呐,链接在这.https://blog.csdn.net/weixin_44543145/article/details/95637057 Eclipse安装WindowBuilder 直接进入Help里面的Marketplace 然后进去直接搜索WindowBuilder点击Install,直接安装就可以了.可以发现,切了镜像以后灰常快. 在Eclipse里面设计一个简易的可以传参的GUI 首先,在新建项目里面直接new一个other的新类然后,点击Jframe进行建立给它写个名字点击Finish直接开工.创建完成以后,可以发现 屏幕里面,有菜单,可以进行自由切换,是源代码模式,还是Design模式 进入Design模式,发现,可以进行图形化编程,即,我们在Design里面进行的操作,将会被以代码的形式转到Sourse里面下面,我们将进行设计一个最简单的可以传参的GUI把JTextField,拖到窗口里面.发现窗口里面多了项textField然后,在里面进行更改其text内容与属性右边的窗口也变了 回到Sourse视窗,进行代码的重构发现,在这里面,存在一个一一对应的"你好世界"串,于是,我们将其进行替换为要对方法进行传入的参数即可 更改如下 //更改后 /** *Createtheframe. */ publicJFab(StringargS){ setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(100,100,450,300); contentPane=newJPanel(); contentPane.setBorder(newEmptyBorder(5,5,5,5)); contentPane.setLayout(newBorderLayout(0,0)); setContentPane(contentPane); textField=newJTextField(); textField.setText(argS); contentPane.add(textField,BorderLayout.CENTER); textField.setColumns(10); } } 然后,在main函数里面进行传入特定参数即可实现调用 可以在Design里面对窗口进行个性化比如换字体 以上就是利用Eclipse从无到有,设计一个可传参的GUI的过程,谢谢大家. 
第396篇文章[3]
归并排序-动手操作练习 归并排序 其实思想不难，体现分治的思想，时间复杂度O(nlogn) 主要是实现起来的细节。 首先是最基础的归并函数 然后是体现递归分治的函数（基准情形：左边下标L，大于等于右下标R时，直接PASS） 最后是函数接口的设计 这里，申请tempa[]数组 体现效率的地方：tempa[]数组只用申请一遍，提高运行效率 实际操作代码见下： #include<iostream> usingnamespacestd; voidmmerge(intL,intR,intRend,inta[],inttempa[])//传入5个参数，利用相邻归并的特性，计算Lend与元素个数 { intlend=R-1; intelements=Rend-L+1; inttemp=L; while(L<=lend&&R<=Rend)//赋值 { if(a[R]<=a[L]){ tempa[temp++]=a[R++]; } else { tempa[temp++]=a[L++]; } } while(L<=lend)//1.基本上就是上个循环里面的，可以省时间CV2.两个while只进行一遍 { tempa[temp++]=a[L++]; } while(R<=Rend) { tempa[temp++]=a[R++]; } for(inti=0;i<elements;i++,Rend--)//利用Rend还没变，从后往前，赋值 { a[Rend]=tempa[Rend]; } } voidmerge_sort(intL,intR,inta[],inttempa[]) { intcenter; if(L<R)//在L<R时才需要处理 { center=(L+R)/2; merge_sort(L,center,a,tempa);//递归左边 merge_sort(center+1,R,a,tempa);//右边 mmerge(L,center+1,R,a,tempa);//合并 } } voidmerge_init(inta[],intn) { int*tempa=newint[n];//如果C，应进行检查是否为空 merge_sort(0,n-1,a,tempa); } intmain() { inti,n; cin>>n; int*a=newint[n]; for(i=0;i<n;i++) { cin>>a[i]; } merge_init(a,n); for(i=0;i<n-1;i++) { cout<<a[i]<<""; }cout<<a[i]; } 
第397篇文章[3]
利用Prim算法解决最小生成树 最小生成树 定义：图G的生成子图T，如果满足： （1）是树（去掉任意边，图不联通） （2）边的权值之和最小 则T叫做最小生成树 求解策略：贪心算法 约束：1.只是图里面的边2.正好|V|-1条边3.没有圈 这里，有两种算法 首先介绍Prim-小树长大算法 每次从已经建立好的树外面，找到一个距离现在的树最近的点，然后把它联上树，问题解决。 实现的方式，类似Dijkstra算法的搜索可以将算法的时间复杂度降到O(V*V)的数量级 利用dists[]数组，找一个最近的点，每次更新距离树的距离 例子： 08-图7公路村村通(30分) 现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。 输入格式: 输入数据包括城镇数目正整数N（≤1000）和候选道路数目M（≤3N）；随后的M行对应M条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到N编号。 输出格式: 输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。 输入样例: 615 125 133 147 154 162 234 246 252 266 346 351 361 4510 468 563 输出样例: 12 这题就是求最小生成树的权重，在加边时，进行累加操作就可以了。 我一开始是盲搜最近的边，没有进行优化，结果时间复杂度到了O(v^3),后来发现这不是Prim正统思想。 后来的代码见下： #include<iostream> #defineinf9999999 usingnamespacestd; structway { intprice; /*data*/ }graph[5300][5300]; intN,M; intintree[5300]; intdists[5300]; intcost; voidini() { cin>>N>>M; inti,x,y,c; for(i=1;i<=M;i++) { cin>>x>>y>>c; graph[x][y].price=c; graph[y][x].price=c; } } intnear_by_intree(intn) { inti; for(i=1;i<=N;i++) { if(graph[i][n].price!=0&&intree[i]==0){ return0; } } return1; } intfind_dmin() { inti; intmd=inf-8,loca=-1; for(i=1;i<=N;i++) { if(intree[i]==0&&dists[i]<md) { md=dists[i]; loca=i; } } if(loca==-1) { return-1; } else { cost+=md; returnloca; } } intminer(inta,intb) { if(a>b){ returnb; } else { returna; } } intprim(intstart) { intree[start]=0; intp=start; inti,j,k; for(i=0;i<N+1;i++) { dists[i]=inf; } dists[start]=0; while(1) { p=find_dmin(); if(p==-1) { break; } intree[p]=1; for(i=1;i<=N;i++) { if(graph[i][p].price!=0&&intree[i]==0) { dists[i]=miner(graph[i][p].price,dists[i]); } } } for(i=1;i<=N;i++) { if(intree[i]==0) { cout<<"-1"; return0; } } cout<<cost; } intmain() { ini(); inti,j; intpri[20000]; prim(1); } 
第398篇文章[1]
哈尔滨工业大学CSAPP大作业程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P 专业计算学部 学号1190202126 班级1936602 学生李映泽 指导教师刘宏伟 计算机科学与技术学院 2021年6月 摘要 HellowWorld！ 表面上是平平无奇的hello在进行表演，可是它所表演背后的舞台，进程管理，虚拟内存系统，每一个步骤背后的ISA支持，是幕后的英雄。而本文就致力于探究hello一生背后的秘密。 本文通过对一个简简单单的hello程序进行分析，围绕着其全生命流程，展开了分析，从预处理，到编译，汇编，链接成.o文件，再到被加载入内存，成为进程，从进程管理，存储管理，IO管理的角度，对这个程序进行了进一步的探讨。 通过对计算机系统的漫游，从最外面的文本文件，一步一步，到了最底层的硬件实现，和操作系统的配合，使得对计算机系统的理解，更加深入。 **关键词：**汇编；编译；链接；操作系统；虚拟内存；硬件IO **** 目录 -第1章概述-5- 1.1Hello简介-5- 1.2环境与工具-5- 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上-5- 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位-5- 开发与调试工具：gcc，vim，edb，readelf，HexEdit-5- 1.3中间结果-5- 1.4本章小结-5- 。第2章预处理-7- 2.1预处理的概念与作用-7- 2.2在Ubuntu下预处理的命令-7- 2.3Hello的预处理结果解析-7- 2.4本章小结-9- 第3章编译-10- 3.1编译的概念与作用-10- 3.2在Ubuntu下编译的命令-10- 3.3Hello的编译结果解析-11- 数据：-11- 赋值：-13- 类型转换：-14- 算术操作-14- 关系操作：-15- 控制转移：-15- 指针/数组操作-16- 函数操作：-17- 开头：-18- 3.4本章小结-18- 第4章汇编-19- 4.1汇编的概念与作用-19- 4.2在Ubuntu下汇编的命令-19- 4.3可重定位目标elf格式-19- 4.4Hello.o的结果解析-21- 4.5本章小结-22- 第5章链接-23- 5.1链接的概念与作用-23- 5.2在Ubuntu下链接的命令-23- 5.3可执行目标文件hello的格式-24- 5.4hello的虚拟地址空间-25- 5.5链接的重定位过程分析-29- 5.6hello的执行流程-32- 5.7Hello的动态链接分析-33- 5.8本章小结-34- 第6章hello进程管理-35- 6.1进程的概念与作用-35- 6.2简述壳Shell-bash的作用与处理流程-35- 6.3Hello的fork进程创建过程-36- 6.4Hello的execve过程-37- 6.5Hello的进程执行-38- 6.6hello的异常与信号处理-39- 6.7本章小结-44- 第7章hello的存储管理-45- 7.1hello的存储器地址空间-45- 7.2Intel逻辑地址到线性地址的变换-段式管理-46- 7.3Hello的线性地址到物理地址的变换-页式管理-48- 7.4TLB与四级页表支持下的VA到PA的变换-50- 7.5三级Cache支持下的物理内存访问-52- 7.6hello进程fork时的内存映射-53- 7.7hello进程execve时的内存映射-54- 7.8缺页故障与缺页中断处理-54- 7.9动态存储分配管理-55- 7.10本章小结-57- 第8章hello的IO管理-59- 8.1Linux的IO设备管理方法-59- 8.2简述UnixIO接口及其函数-59- 8.3printf的实现分析-60- 8.4getchar的实现分析-62- 8.5本章小结-63- 结论-63- 附件-64- 参考文献-65- 第1章概述 1.1Hello简介 P2P:FromProgramtoProcess从程序到进程 Hello在一开时,仅仅是内存里面的一段程序代码.在Bash里面,OS进程管理通过fork了一个新Process,然后对子进程进行execve,载入装载hello,并分给它时间片,让它得以成为进程. 020:FromZero-0toZero-0从零到零 本来没有Hello,是程序员用手,打出了文本文件,hello.c.然后,通过预处理,编译,汇编,链接,得到了ELF格式hello文件.当我们在Bash里面执行hello的时候,hello被装载进去.最后,执行结束以后,shell的父进程负责回收hello,而内核来删除相关的数据结构.最后,什么也没有留下. 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位 开发与调试工具：gcc，vim，edb，readelf，HexEdit 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 1.4本章小结 介绍了hello的p2p,o2o过程,对hello的一生,进行了大体的定性说明. 罗列了本次实验的基本信息.环境与工具,中间结果. 并对中间结果进行了列表说明. （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 **概念：**预处理器（cpp）根据以字符#开头的命令，修改原始C程序。 例如：#include<stdio.h>将系统头文件里面的内容，直接插入到程序文本里面。得到了另外一个以.i结尾的C语言程序 **作用：**扩展C语言程序设计的环境。插入用#include的环境。同时拓展#define定义的宏。 2.2在Ubuntu下预处理的命令 通过命令： gcc-Ehello.c-ohello.i 进行预处理 对比： 左边是hello.i右边是hello.c 可以发现，在原有的基础上，又增加了许多的系统头文件的内容 2.3Hello的预处理结果解析 在原hello.c里面有，但hello.i里面没有的： 注释内容，在预处理时，已经把程序里面的注释给删了。 在原hello.c里面有，在hello.i里面也有的： 主程序部分。 对比： Hello.iHello.c 在原hello.c里面没有，但在hello.i里面有的： 通过#include插入的一系列运行库的位置 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WAXrMasl-1624784252313)(media/9cbadafa0a6ba334cf333eed7fac3b95.png)] 一些定义的结构体 还有一些定义的变量 和一些外部函数的名字 2.4本章小结 本章通过介绍预处理阶段的概念以及在C语言程序中的作用 并在Linus环境里面对hello.c程序进行了预处理 初步探究了预处理的执行情况。 并对预处理的结果进行了解析 第3章编译 3.1编译的概念与作用 **概念：**编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。每条语句都是以文本形式描述的低级机器指令 **作用：**为高级语言的不同编译器提供了通用的输出语言。例如：C编译器与Fortran编译器产生的输出文件用的是同样的，依赖于自己CPU的语言。 3.2在Ubuntu下编译的命令 首先：于键盘里面，按下： gcc-Shello.i-ohello.s 然后打开编译完成的文本文件 3.3Hello的编译结果解析 数据： 通过观察C语言程序，发现其中存在如下变量 sleepsecs 这个变量是全局变量，于main函数外部声明。 argc/argv 这个变量，是局部的，而且是调用main函数里面进行传入的参数。在IA64里面，它存放在rdi里面。 对main函数的汇编代码进行分析。 Hello.sHello.c | | 在汇编的代码中，是将这个数据一开始放于寄存器rdi里面，然后，调用main函数的。 然后再进入main后，又将其放入堆栈里面进行保存。 再在后面如果是要使用到rdi与rsi时，均是从堆栈里面调数据 i i作为hello.c里面的局部变量，在main里面的循环中出现。 观察汇编代码发现，i在堆栈里面出现，并作为每次循环都进行更新的变量。 这种风格的汇编代码，每次都需要将变量放到栈里面进行读写，性能上，并不占优势。于是我开了O2优化 开O2优化以后 观察： 发现在开启优化后，程序将i就保存与%ebx里面。而不是存于栈中，减小了内存的读取。 赋值： 观察C语言程序，赋值出现了两次。 首先是全局变量的赋值： 在汇编里面观察,发现 即赋初值的全局变量为在程序运行前便已经赋值了的. 然后是局部变量的赋值. 在这里,i被初始化为0 观察相应汇编代码里面的: 即,局部变量于运行时对变量进行赋初值.行为与程序里面保持一致 同时,看其对应的汇编代码: 是movl,即是对32位的数据进行移动,正好对应int的四字节的要求 类型转换： 全局变量sleepsecs的类型转换 在C代码里面时int/赋值时float/最后在汇编的结果时long 注意，它是int，不过却是赋值2.5. 我们看看汇编代码里面是如何处理的。 编译器将这个变量已经转变成2了 在用到sleepsecs的时候， 不难发现，这个转换是隐式转换。自动将2.5转换为了2，而且，类型由int转为了long 算术操作 C语言里面的++ 注意到循环里面的i++ 于是在汇编里面寻找对应 即正好对应在里面的值进行加1 注意到i是int类型,所以是进行32位的加法,即位addl 关系操作： 在程序里面存在两处关系操作,第一处是if条件里面的!=3判断 第二处是在循环里面的边界的判定 对应到汇编里面,其对应的语句就是: 与 对应的cmpl正是32位的比较, 控制转移： 在C代码里面有if与while语句,下面对其展开分析 针对C里面的if语句: C汇编 这种汇编的转换于CSAPP课本P143页里面提及. 针对C里面的while语句: C汇编 这个for循环是采用先赋初值,然后采用Jumptomiddle策略改变的循环结构 将汇编代码改写为等价含义的C语言代码: C由汇编转换后的C 指针/数组操作 程序对传入的argv数组进行了引用. argv数组是一个指针数组,即数组里面装的是指针 程序引用了argv[1]与argv[2] 和字符串一起,作为printf的三个参数,藏在for循环里面 下面进行分析: 首先在汇编代码里面定位到printf引用的这三个参数 引用的流程如下: 将数组的基地址取出=>对基地址进行计算偏移量=>取出内存里面的相应值 即最后一步其实是以argv[2]里面的内容为地址去访问内存.等价于*(argv[2]) 函数操作： main函数里面一共调用了4个函数:printf/exit/sleep/getchar 下面依次进行分析: 注意:这里所有的函数后缀都有@PLT这是动态链接的内容,我们将在链接章节里面介绍这两个函数! printf 引用了两次.第一次是仅仅输出字符串,第二次是含参数的格式化输出. 第一处的printf 观察汇编代码,不难发现,第一处的输出字符串是被替换为了puts@PLT 这里面隐藏着gcc编译器的默认优化,即,如果只是输出一组字符串+\n的话,会被默认优化为puts()指令 同时,看看传入的参数,不难发现,即这个rdi里面存的是.LC0,.LC0里面装的正好就是字符串.“Usage:Hello学号姓名！\n” 有关更细致的分析,将在下一章里面继续说明 exit main函数是将1传给rdi里面后就直接调用exit@PLT了 sleep函数: 也是将参数传给rdi以后直接调用 getchar 开头： 注意： 这里，已经在头部对这个.s文件进行了一定的说明。 .file:说明文件名字为从hello.c编译而来 .text代码段 .globl全局变量：说明sleepsecs是全局变量 .data数据段 .align对齐方式，.align4说明是按四个字节对齐 .typesleepsec，说明这个变量是对象类型 .size大小，说明这个变量占用的大小为4字节 .long说明sleepsec的类型是long .section说明sleepsecs的节在于只读数据段 .LC0与.LC1说明这是两个字符串，最后是需要被连接器进行重定位的。 最后是对main函数的定义： Main函数在.text段里面，main是全局符号，然后它的type是function即函数 本章小结 本章具体讨论编译. 对编译的概念与作用,Ubuntu下编译的命令,Hello的编译结果解析进行了分析说明 其中,对Hello的编译结果同C语言里面的数据/变量赋值(局部/全局)/类型转换/算术操作/关系操作/控制转移/指针数组操作/函数操作进行了细致的探讨 第4章汇编 4.1汇编的概念与作用 **概念:**将.s文件翻译成机器语言指令,并将这些指令打包成可重定位目标程序的格式.将结果保存到.o文件里面 **作用:**将给人看的汇编文本文件,翻译成给机器看的二进制代码. 4.2在Ubuntu下汇编的命令 命令: ashello.s-ohello.o 生成了hello.o文件 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 通过readelf-a命令进行查看: ELF头 节头部表: 描述了每一节的名字/大小,类型/条目size,地址/标志/链接/信息,偏移量/对齐方式, 文件里面没有动态节/程序头/节组 重定位节 注意到这些重定位的有些是静态链接,有些是动态链接.如R_X86_64PC32的是静态链接内容/而PLT_32则为动态链接内容. 还有一个与重定位有关的:.rela.eh_frame .rela.eh_frame eh_frame即exceptionhandleframe即异常处理框架 就是说,这是与重定位相关的一个异常处理单元 最后是符号表 它有18个条目 4.4Hello.o的结果解析 （以下格式自行编排，编辑时删除） objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 对比示意:左方为.o文件反汇编的结果.右方为.s 注意到基本的逻辑并没有改变,但是发现 1原来的十进制数已经被翻译成了16进制数. 2原来引用的一些全局变量,已经由<符号>(%rip)变成了0x0(%rip),原来的符号蕴含的重定位信息被放到了表里面.(右方的信息是Objdump自己给我们辅助生成的) 3.原来引用的一些函数,也是由<符号>(%rip)变成了0x0(%rip),原来的符号蕴含的重定位信息被放到了表里面.(右方的信息是Objdump自己给我们辅助生成的) 控制跳转指令的跳转位置,从jmp符号直接被转换为jmp指令族,其后方的二进制数代表了相对位置 4.5本章小结 本章讨论汇编 对汇编的概念与作用/在Ubuntu下汇编的命令/可重定位目标elf格式/Hello.o的结果解析进行了分析与阐述 并探究了hello.o文件的Objdump与之前原来汇编格式之间的差异 第5章链接 5.1链接的概念与作用 概念*:链接时将各种代码和数据片段收集并组合成为一个单一文件的过程.这个文件可以被加载到内存里面执行.* **作用:**在软件开发里面扮演着重要角色,使分离编译成为可能. 5.2在Ubuntu下链接的命令 第一种方法: 指令:ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 第二种方法:直接使用gcc进行操作 指令:gcchello.o-ohello 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 使用readelf进行分析,输入: readelf-ahello>hello_2_elf 进行对ELF文件进行查看: 如图,其各段的基本信息，如起始地址，大小等信息等,已被罗列如上. 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 首先,打开edb并加载程序文件 下面,开始查看hello的虚拟空间各个段的信息. 我们将对照之前笔者画的图片,挨个进行分析. 这个,是X86-64的虚拟空间示意图 我们利用edb的内存区域选项进行对内存区域的查看 两图一项一项的进行对照 在Memregions里面最下面一行的权限是只读区域,而且是不能执行的 我们对其进行dump 发现这个就是ELF的头！ 其内容，是和我们之前readelf读的是一致的 往上，是权限是r-x权限的内存区域，即这个区域是可以执行的。 正好与我们在EDB里面看到的指令装载的地址一致 在往上看,权限是只读的。我们对其进行分析： 对之进行dump后发现这个区域是只读数据域，保存了我们代码里面的如字符串之类的数据 继续往上，发现权限是可读可写，这个是运行时堆，运行时，由malloc进行管理这部分内存的分配 往上，内存地址发生了较大变化，一共有三段，MemoryRegions指示我们，这个区域是共享库的区域。 再最后往上，到了我们的用户栈 不难发现，这个用户栈的结构，和书中一致，即返回地址，以及其上面的环境变量 最上面的是内核区域，我们没有办法访问。 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 1)首先使用objdump-d-rhello指令，生成对hello的反汇编文件 2)然后如图，进行对比 不难发现，左图中的hello.o文件里面只有一个函数即main函数，而右方的对hello进行反汇编的结果里面有一整套的函数。比如：.init段的_init函数 含汇编代码的段增多 从原来的只有的.text段，扩增为了不仅有.text段，也有.init段、.plt段、.fini段等等。 .text段的内容增多了。 左右均是.text段的内容，不过左方的.text段只有main函数，右方的.text段不仅包含.main，更包含main函数的很多入口函数，如_start之类。 增加了外部的共享库函数 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 为了分析重定位，我们采用-no-pie指令对hello.c进行重新编译。 我们以原来在main函数中的第一条需要重定位的代码为例展开分析： 重定位PC相对引用 它在elf文件里面的信息是： 这个条目r的类型是R_X86_64_PC32的类型 条目信息：r.offset=0x1cr.symbol=.rodatar.type=R_X86_64_PC32r.addend=-4 下面开始对重定位的refptr进行计算： 通过链接器的计算，其已经确定如下信息： 在hello里面其.rodata的地址为：0x402000 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627172643714.png) 而main函数的地址是：0x4011b6 需要引用的字符串的地址Addr(r.symbol)=0x402004 调用CSAPP第三版第480页的重定位算法，进行计算： 计算过程：refaddr=Addr(s)+r.offset=0x4011b6+0x1c=0x4011d2*refptr=(unsigned)(Addr(r.symbol)+r.addend-refaddr)=(unsigned)(0x402004+(-4)-0x4011d2)=0xe2e 这个重定位计算得来的信息，正好与汇编代码里面的一致！ 在得到的可执行目标文件里面，lea指令有着如下的形式： 以上，便是链接器对代码里面的条目进行重定位的过程 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 打开edb载入hello ** ** 列出所有过程： 输入: ./hello1190202126李映泽 子程序名程序地址（16进制）ld-2.27.so_dl_start7efbff4d8ea0ld-2.27.so_dl_init7efbff4e7630hello_start400500libc-2.27.so__libc_start_main7efbff100ab0Hello_printf@plt（调用了10次）4004c0Hello_sleep@plt（调用了10次）4004f0hello!getchar@plt4004d0libc-2.27.so!exit7efbff122120 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 关于PLT与GOT表的介绍:对于动态共享链接库中PIC函数，编译器没有办法预测函数的运行时地址，所以需要为其添加重定位记录，并等待动态链接器处理。为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT和全局偏移量表GOT实现函数的动态链接。其中GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。 dl_init前后变化 在dl_init之前 利用gdb来进行打印内存地址内容: 在dl_init之后, 发现内容已经不同比如说 puts@got.plt函数的地址,已经在dl_init之后,被改写了 进入这个地址 0x7ffff7e475a0 发现,是_GI_IO_PUTS函数 5.8本章小结 本章讨论链接 对链接的概念与作用在Ubuntu下链接的命令可执行目标文件hello的格式hello的虚拟地址空间链接的重定位过程/执行流程展开了分析 根据X86-64的虚拟地址空间模型,以hello为例,一一进行了对照比较分析. 同时,根据CSAPP书中所述的重定位算法,对链接的重定位过程进行了分析 并使用gdb作为工具,对hello的执行流程/动态链接过程进行了分析 第6章hello进程管理 6.1进程的概念与作用 **概念:**进程是一个执行中程序的实例. 进程定义： 狭义定义：进程是正在运行的程序的实例（aninstanceofacomputerprogramthatisbeingexecuted）。 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元 进程作用： （以下内容节选自CSAPPP508） 1）进程为用户提供了以下假象： 我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 2）方便shell程序的构造 每次用户通过向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。 3）两个关键抽象 进程提供给应用程序两个关键抽象：一个独立的逻辑控制流；一个私有的地址空间。 6.2简述壳Shell-bash的作用与处理流程 （以下格式自行编排，编辑时删除） Shell的概念: shell是一个交互型应用级程序，代表用户运行其他程序。是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。 Shell的功能: 它代表用户运行其他程序.接收用户输入的命令并把它送入内核去执行。.实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。 处理流程: shell首先检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux本身的实用程序，如ls和rm，也可以是购买的商业程序，如xv，或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能够成功找到命令，该内部命令或应用程序将被分解为系统调用并传给Linux内核。 6.3Hello的fork进程创建过程 运行中的进程可以通过fork()函数创建子进程。 fork()函数简介：#include<sys/types.h>#include<unistd.h>pid_tfork(void);//返回:子进程返回0;父进程返回子进程的PID如果出错,返回-1 对于我们打开的shell而言： 首先读入我们敲入的命令行 将串”./hello1190202126李映泽”读入，作为一组参数。 对串进行解析 串被分割为**./hello与1190202126与李映泽**三个子串 读取第一个参数： 发现**./hello并不是内置参数，于是fork一个子进程，子进程去execvehello命令，带上参数：”./hello1190202126李映泽**” 进程图： 6.4Hello的execve过程 Shell产生的子进程利用的是execve函数进行对新程序的加载与运行。 execve函数在当前调用的进程的上下文里面加载并运行一个程序。 exceve函数的说明#include<unistd.h>intexecve(constchar*filename,constchar*argv[]constchar*envp[]);//如果加载成功,那么不返回,如果错误,返回-1//这个函数加载并运行可执行目标文件filename//且带参数列表argv与环境变量envp//只有出现错误，才返回-1；//否则不会返回 在加载了hello以后，通过调用启动代码，设置完成启动栈的结构，并转移控制权给main函数 如图：新程序开始后，用户栈的典型结构如下： 6.5Hello的进程执行 （以下格式自行编排，编辑时删除） 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 **进程时间片：**分时操作系统分配给每个正在运行的进程微观上的一段CPU时间。或者说，一个进程执行它的控制流的一部分的每一时间段。 **进程上下文信息：**进程执行活动全过程的静态描述。为内核重新启动一个被抢占的进程所需要的状态。由如：通用目的寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈以及各类内核数据结构组成。 **调度：**在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被强占的进程。这种决策就叫调度（是由内核中的调度器的代码处理的） *进程调度的过程：*上下文切换 保存当前进程的上下文恢复某个之前被抢占的进程的上下文将控制转移给这个新恢复的进程 用户态与核心态的转换： 即用户模式切换到内核模式 Hello一开始是运行在用户模式里面，在调用sleep、exit函数时，通过陷阱异常，实现syscall，将控制权给内核开始系统调用。在执行结束以后，控制权转移给main的用户模式。 6.6hello的异常与信号处理 （以下格式自行编排，编辑时删除） hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 hello执行中出现的异常: 中断*:接收到来自处理器外部的I/O设备的信号.* 比如:我们在键盘里面敲入CtrlC/Z.,使得在处理器执行时,中断引脚的电压变高了…在处理完当前指令后,控制转移给处理程序;中断处理程序进行执行.执行结束后,返回到下一条指令. 陷阱*:有意的异常.例如为了进行系统调用.* 在hello的执行过程中,需要调用系统函数来进行一系列的操作:如printf进行的显示屏输出/sleep的睡眠/exit进行退出等等.这些系统调用,均要进行syscall,即陷阱,从用户模式转内核模式 hello执行中处理的信号: SIGINT,SIGSTP,SIGCONT,SIGWINCH 信号处理演示: Ctrl-Z Ctrl-C(中断) |在ctrl-z以后的ps||****||按下fg,在前台进行||||kill-9PID(杀死进程)||||杀死后ps||||pstree|| 将输出重定向至文本文件里面 ||kill-19与kill-18的组合||首先将进程进行挂起: -19sigstop将进程进行停止 -18SIGCONT将进程继续 | 说明: 按下键盘的时候: 中断异常示例: 引发了中断异常.如图: 而当程序在进行显示屏输出的时候: 引发的是陷阱: 通过陷阱,调用系统函数.将字符串打印到屏幕上面 信号处理: 对于kill-98810: 直接将SIGKILL发送到8810进程,使其直接终止. 对于CTRLC/Z 将SIGINT/SIGSTP由内核发送到8810号进程.SIGINT直接终止8810.而SIGSTP将8810号进程进行停止与挂起. 6.7本章小结 本章讨论hello的进程管理 对进程的概念与作用壳Shell-bash的作用与处理流程Hello的fork进程创建过程/execve过程/的进程执行/异常与信号处理 进行深入的探讨,并以图示的方式展开了说明 第7章hello的存储管理 7.1hello的存储器地址空间 （以下格式自行编排，编辑时删除） 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 逻辑地址:段内偏移地址.程序产生的和段相关的偏移地址部分.也就是hello在“段基址+段内偏移地址”访问模式下的段内偏移地址. 线性地址:是逻辑地址到物理地址变换之间的中间层。逻辑地址是段里面的偏移地址,加上生成的段的基地址就是线性地址.在执行hello时,我们位于保护模式下,于是我们的段基址寄存器通过段选择子在GDT里面找到真正的段基址,加上段内偏移地址,作为一个整体,这个地址叫做线性地址. **虚拟地址:**如果开启分页,那么线性地址将作为虚拟地址,给CPU,通过查找页表,找到对应的物理地址.以hello为例,由于我们是在保护模式下,我们的虚拟地址就是和线性地址一样,其示例正如下图所示: **物理地址:**是内存单元的绝对地址,也是存储管理的终点.由CPU发出的地址最终会被转化为物理地址.结合hello为例:就是最后hello在内存里面存的地址 7.2Intel逻辑地址到线性地址的变换-段式管理 （以下格式自行编排，编辑时删除） 段式管理:把一个程序分成若干个段（segment）进行存储，每个段都是一个逻辑实体（logicalentity），程序员需要知道并使用它。它的产生是与程序的模块化直接有关的。段式管理是通过段表进行的，它包括段号或段名、段起点、装入位、段的长度等。此外还需要主存占用区域表、主存可用区域表。 通俗的说:这个变换,就是将逻辑地址,映射到线性地址. **逻辑地址=**段标识符+段内偏移量 段内偏移量,是保持不变的.直接送到最后的加法器,用于合成线性地址 段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图： 索引号,是在**”段描述符表”**的索引. 段描述表,可以细分为全局段描述符表(GDT)与局部段描述符表(LDT) 这两者的寻找的切换,是由上图的TI即表指示器进行决定的. (Intel设计的本意是，一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。) 通过在段描述符表里面进行索引寻找,它可以寻找到段描述符(segmentdescriptor) 这个段描述符描述了一个段，由8个字节组成，如下图： 我们只关心BASE段,即描述了一个段的开始位置的线性地址.它与之前逻辑地址里面的offset偏移量加加在一起,就成了线性地址. 故大体流程如下: 段式管理对逻辑地址进行分割成:段选择符+Offset看段选择符的TI,如果是0,那么切换到GDT,如果是1,那么切换到LDT利用段选择符里面的索引号在相应的表里面进行取出段描述符对段描述符里面的Base进行取出线性地址<=Base+Offset 7.3Hello的线性地址到物理地址的变换-页式管理 由于我们开启了分页,所以,Hello将进行由线性地址->物理地址的变换 首先引入页的概念: 页:将N个连续字节的数组,成为页 页可分为虚拟页(PP)与物理页(PP) 如果不考虑多级页表等更加精细的机制,我们的地址映射将是这样进行的. 线性地址,即虚拟地址. 被分成了两部分 线性地址=VPN(虚拟页号)+VPO(虚拟页偏移量) 虚拟页号是一个索引,在当前进程的CR3寄存器指向当前的页表里面寻找虚拟页,并把里面存的物理页号PPN返回与物理页偏移量PPO一道,进行返回. 即 物理地址=PPN(物理页号)+PPO(物理页偏移量) 7.4TLB与四级页表支持下的VA到PA的变换 （以下格式自行编排，编辑时删除） TLB支持下的VA到PA的变换 目的:利用局部性原理,加快地址翻译速度. TLB:翻译后备缓冲器(TranslationLookasideBuffer,TLB)为了加速地址翻译 它就是一个Cache 具有以下特性: ▪MMU中一个小的具有高相联度的集合 ▪实现虚拟页号向物理页号的映射 ▪页数很少的页表可以完全放在TLB中 如果缓存了的话,那么TLB可以直接将VPN映射到PTE,以上步骤都是在CPU内部的MMU单元完成的,极快! 四级页表支持下的VA到PA的变换 目的:利用多级页表,降低内存占用. 如果我们的页面大小4KB,48位地址空间,8字节的PTE,那么,我们的页表占用的空间至少应该是: 2^48*8/4KB=2^(48+3-12)=2^39Byte 即我们需要512G的页表,这显然不现实,我们发现,其实有很多页,我们并没有用上,于是,可以直接索性不放入PTE里面,采用多级页表的处理思路. 以4级页表为例: **大致流程:**由CR3寄存器指向L1的PT,然后由VPN1作为索引,进行寻找,找到PTE以后,以PTE条目里面的Base作为基址,再以VPN2作为索引,重复上述操作,直到找到L4的PT里面的PTE,以这个作为PPN,并上PPO,作为虚拟地址. Corei71-3级页表条目格式每个条目引用一个4KB子页表:P:子页表在物理内存中(1)不在(0)R/W:对于所有可访问页，只读或者读写访问权限U/S:对于所有可访问页，用户user或超级用户supervisor(内核)模式访问权限WT:子页表的直写或写回缓存策略A:引用位(由MMU在写时设置，由软件清除)PS:页大小为4KB或4MB(只对第一层PTE定义)页表物理基地址:子页表物理基地址的最高40位(强制物理页表4KB对齐)XD:能/不能从这个PTE可访问的所有页中取指令Corei7第4级页表条目格式每个条目引用一个4KB的页:P:子页表在物理内存中(1)不在(0)R/W:对于所有可访问页，只读或者读写访问权限U/S:对于所有可访问页，用户或超级用户(内核)模式访问权限WT:子页表的直写或写回缓存策略SD：能/不能缓存(Cachedisabledorenabled)A:引用位(由MMU在读或写时设置，由软件清除)D:修改位(Dirtybit,由MMU在写时设置，由软件清除)页表物理基地址:物理页基地址的最高40位(强制物理页4KB对齐)XD:能/不能从这个PTE可访问的所有页中取指令 7.5三级Cache支持下的物理内存访问 以Corei7为例 对于给定的物理地址PA,首先在L1里面进行寻找. (1)将PA分割成CTCICO CI是组号,定位了应该出现的组,CO是offset定位了偏移量.CT是tag即标识的tag. (2)对本层的Cache进行寻找 硬件会定位到CI的组(组索引),然后对组里面的每一行,(L1里面有8行)进行比较tag,如果tag相同且有效,那么找到了 (3)如果找到,那么直接返回数据 (4)如果找不到,那么就会到L2里面进行寻找,重复上述操作直到找到为止. (5)更新时,如果存在空闲的(有效0),那么直接替换,如果没有,根据LRU策略,找一个块进行驱逐. 7.6hello进程fork时的内存映射 （以下格式自行编排， 为新进程创建虚拟内存 ▪创建当前进程的mm_struct、vm_area_struct和页表的原样副本。 ▪两个进程中的每个页面都标记为只读 ▪两个进程中的每个区域结构(vm_area_struct)都标记为私有的写时复制(COW) 在新进程中返回时，新进程拥有与调用fork的父进程相同的虚拟内存 随后的写操作通过写时复制机制创建新页面 7.7hello进程execve时的内存映射 execve函数进行了以下步骤: 删除已存在的用户区域 删除当前进程虚拟地址的用户部分中已存在的内存区域 映射私有区域 将目标文件hello的代码和初始化的数据映射到.text和.data区 同时,将.bss和栈映射到匿名文件 映射共享区域: 将libc.so等内容映射到共享库里面的映射区域. 设置PC,指向代码区域的入口点 7.8缺页故障与缺页中断处理 1)处理器生成一个虚拟地址，并将其传送给MMU 2)MMU生成PTE地址(PTEA)，并从高速缓存/主存请求得到PTE 3)高速缓存/主存向MMU返回PTE 4)PTE的有效位为零,因此MMU触发缺页异常 5)缺页处理程序确定物理内存中的牺牲页(若页面被修改，则换出到磁盘 写回策略) 6)缺页处理程序调入新的页面，并更新内存中的PTE 7)缺页处理程序返回到原来进程，再次执行导致缺页的指令 7.9动态存储分配管理 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 **动态内存管理:**需要维护着进程的一个虚拟内存区域，称为堆. 我们这里的管理,用到的时malloc,这个是显示分配器,即要求应用显式地释放任何已分配的块 约束条件: ▪可以处理任意的分配(malloc)和释放(free)请求序列 ▪只能释放已分配的块,无法控制分配块的数量或大小 ▪立即响应malloc请求 ▪不允许分配器重新排列或者缓冲请求 ▪必须从空闲内存中分配块 ▪必须对齐块，使它们可以保存任何类型的数据对象 ▪在Linux上：8字节(x86)or16字节(x86-64)对齐 ▪只能操作或改变空闲块 ▪一旦块被分配，就不允许修改或移动它了 目标:最大化吞吐量，最大化内存利用率 基本方法与策略: 隐式空闲链表(Implicitlist) 通过头部中的大小字段隐含地连接空闲块 通过这些形式已经组织好了的块,进行连接在一起,维护了空闲块的结构 阴影:已分配块 空白:空闲块 头:大小/分配位 显式空闲链表(Explicitlist) 在空闲块中使用指针连接空闲块 实例: 分离的空闲列表(Segregatedfreelist) 空闲块按尺寸size分类/组，每个类/组使用一个空闲链表。 当分配器需要一个大小为n的块时: ▪搜索相应的空闲链表，其大小要满足m>n ▪如果找到了合适的块: ▪拆分块，并将剩余部分插入到适当的可选列表中 ▪如果找不到合适的块,就搜索下一个更大的大小类的空闲 链表 ▪直到找到为止。 如果空闲链表中没有合适的块: ▪向操作系统请求额外的堆内存(使用sbrk()) ▪从这个新的堆内存中分配出n字节 ▪将剩余部分放置在适当的大小类中 7.10本章小结 本章讨论hello的存储管理. 讨论了由硬件与操作系统支持的线性地址空间/虚拟地址空间/物理地址空间/逻辑地址空间之间的转化.对hello的存储器地址空间,进行了分析. 基于IntelCorei7,对/Hello的线性地址到物理地址的变换-页式管理/Intel逻辑地址到线性地址的变换-段式管理/TLB与四级页表支持下的VA到PA的变换/三级Cache支持下的物理内存访问进行了说明 同时,基于虚拟内存的概念,对hello进程fork时的内存映射/进程execve时的内存映射/缺页故障与缺页中断处理/动态存储分配管理等内容进行了分析说明 第8章hello的IO管理 8.1Linux的IO设备管理方法 （以下格式自行编排，编辑时删除） 设备的模型化：文件 一个Linux文件就是一个m字节的序列: B0,B1,…,Bk,…,Bm-1 设备管理：unixio接口 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O: 8.2简述UnixIO接口及其函数 （以下格式自行编排，编辑时删除） 接口描述如下： 打开文件：应用程序请求内核打开相应的文件，宣告其想要访问IO设备 对应的函数： 改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k。 应用程序执行seek操作，显示设置文件的当前位置为k。 读写文件：一个读操作是从文件里面复制n>0个字节到内存里面。从当前文件位置k开始，增加k到k+n。给定大小m文件，k>=m时，触发EOF条件，然后应用程序检测到。类似，写操作是从内存里面复制n>0字节到文件里面，从当前文件位置k开始，然后更新k。 关闭文件：应用程序完成了文件访问以后，通知内核来关闭文件。 打开文件的函数：#include<sys/types.h>#include<sys/stat.h>#include<fcntl.h>intopen(char*filename,intflags,mode_tmode); 关闭文件的函数#include<unistd.h>intclose(intfd); 读写文件函数#include<unistd.h>//读文件函数ssize_tread(intfd,void*buf,size_tn);//写文件函数ssize_twrite(intfd,constvoid*buf,size_tn); 8.3printf的实现分析 （以下格式自行编排，编辑时删除） https://www.cnblogs.com/pianist/p/3315801.html 首先观察printf的函数体： printf函数体：intprintf(constchar*fmt,…){inti;charbuf[256];va_listarg=(va_list)((char*)(&fmt)+4);i=vsprintf(buf,fmt,arg);write(buf,i);returni;} 其中，调用了函数vsprrintf与write vsprintf生成显示信息: vsprintfintvsprintf(char*buf,constchar*fmt,va_listargs){char*p;chartmp[256];va_listp_next_arg=args;for(p=buf;*fmt;fmt++){if(*fmt!=‘%’){*p++=*fmt;continue;}fmt++;//将fmt字符串拷贝到buf缓冲里面,直到出现格式化串switch(*fmt)//出现格式化串,针对不同的串,进行相应的操作{case‘x’:itoa(tmp,*((int*)p_next_arg));strcpy(p,tmp);p_next_arg+=4;p+=strlen(tmp);break;case‘s’:break;default:break;}}return(p-buf);} 经过分析可知： vsprintf是一个系统函数 vsprintf返回的是一个要打印的字符串的长度 通过接受确定输出格式的格式化字符串，对参数进行格式化，输出到格式化buf里面，然后将buf传给write，利用write进行输出 write系统函数 write1.write:2.moveax,_NR_write3.movebx,[esp+4]4.movecx,[esp+8]5.intINT_VECTOR_SYS_CALL Write干的就是给寄存器传好参然后进入一个陷阱-系统调用 下面进入syscall函数进行刨析： syscallsys_call:;ecx中是要打印出的元素个数;ebx中的是要打印的buf字符数组中的第一个元素;这个函数的功能就是不断的打印出字符，直到遇到：’\0’;[gs:edi]对应的是0x80000h：0采用直接写显存的方法显示字符串xorsi,simovah,0Fhmoval,[ebx+si]cmpal,’\0’je.endmov[gs:edi],axincsiloop:sys_call.end:ret Syscall在这里，只有一个功能：显示格式化了的字符串。 它将串里面的字节，从寄存器里面通过总线，复制到显卡显存里面，存放Ascll码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。最后我们的打印字符串就显示在了屏幕上。 8.4getchar的实现分析 （以下格式自行编排，编辑时删除） 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 对个getchar的实现分析： getchar1.intgetchar(void)2.{3.staticcharbuf[BUFSIZ];4.staticchar*bb=buf;5.staticintn=0;6.if(n==0)7.{8.n=read(0,buf,BUFSIZ);9.bb=buf;10.}11.return(–n>=0)?(unsignedchar)*bb++:EOF;12.} 用户通过按下键盘，键盘的接口得到了代表按键的键盘码，产生了中断，这个中断，抢占了当前的进程，通过上下文切换机制，进入键盘中断子程序，子程序从键盘接口（文件），获得键盘按下的扫描码，让那后将这个扫描码转为ASCII码的形式，存到键盘的缓冲区里面。 对于getchar函数来说，调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。gethar对这个进行的是一次封装过程。即在按下回车以后读走一个字符。 8.5本章小结 本章具体讨论看hello的IO管理 通过分析说明Linux的IO设备管理方法/UnixIO接口及其函数/printf的实现分析/getchar的实现分析 探讨了小小hello程序背后支撑着它的IO基础 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 逐条总结hello所经历的过程： 从被程序员，一个键盘，一个键盘的敲到文本文件里面，以ASCII码进行呈现，Hello便以文本形式进行了诞生 1.通过预处理器的预处理，hello进行了补全，但仍然是C语言格式的 2.被编译器编译后，成了汇编语言，文本格式，但是语言已经成立汇编的语言了。 继续向前，被汇编器处理成为了二进制代码，hello.o，这个文件的格式是ELF文件格式，有待于进一步被链接 链接器收到.o格式的hello，对hello进行符号解析与重定位。将最后已经链接成功的文件，输出到a.out里面。 我们在bash的shell里面，输入了执行命令./a.out,加载器替我们进行对hello进行加载，fork一个子进程，对子进程通过调用exceve函数，对虚拟内存进行了映射，hello就开始在子进程里面进行运行。 6.在hello的main函数结束后，子进程进入终止状态，由父进程进行对子进程回收。 计算机系统的设计与实现的深切感悟 通过对小小的hello背后的计算机系统的探究，丰富了我对于hello的认识 表面上，只是一个小小的hello，但它的背后，是一群强大的抽象。 从指令集的ISA，到虚拟内存系统，再到进程的管理。 背后，是一个复杂的系统 一环套一环，为抽象进行服务。 搭起了计算机系统的高楼大厦 附件 列出所有的中间产物的文件名，并予以说明起作用。 文件名介绍 hello.c原始的hello文件(C语言) hello.i经过预处理之后的hello文件 hello.s经过编译之后的hello文件,由汇编代码写成 hello.ohello经过汇编之后生成的可重定位的目标文件(二进制代码) hellohello.o经过链接之后生成的目标文件,可以执行 参考文献 [1]CSAPP深入理解计算机系统第三版 [2]程序员的自我修养-链接装载与库 [3]https://www.cnblogs.com/diaohaiwei/p/5094959.html. [4]https://www.cnblogs.com/pianist/p/3315801.html 
第399篇文章[]
哈工大2021软件构造实验3心得(2)在Junit里面对命令行程序的单元测试 笔者最近完成了窝工软件构造里面的Lab3写了一个针对命令行交互的小程序. 不过,在进行测试时遇到了一丢丢小麻烦即,怎么来对一个对命令行交互的程序进行测试 前言 在<<阿里巴巴Java开发规范>>里面有这样的一句话 【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执 行过程必须完全自动化才有意义。 输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。 【强制】单元测试是可以重复执行的，不能受到外界环境的影响。 说明:单元测试通常会被放到持续集成中，每次有代码checkin时单元测试都会被执行。 如果单测对外部环境(网络、服务、中间件等)有依赖，容易导致持续集成机制的不可用。 正例:为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring这样的DI框架注入一个本地(内存)实现或者Mock实现。 我们作为一名系统学习了软件构造的学生,如果仅仅是向大一那样,通过纯手敲的方法,来对一个小软件进行测试,那就有点low了. 于是,我们采用Junit的方法,利用它,进行软件的单元测试 核心 关键:对Java的输入输出进行重定向 首先,我们需要记录下默认的Java输入输出流: //记录标准流 finalInputStreamoInputStream=System.in; finalPrintStreamoOutputStream=System.out; 然后,我们需要手动设置输出流,即,将程序的输出,从屏幕转到我们想要的地方 //设置输出流 finalByteArrayOutputStreamBoutputStream=newByteArrayOutputStream(); System.setOut(newPrintStream(BoutputStream)); FileInputStreamFinputStream=null; 同时,我们还需要手动设置输入流,将键盘输入转成从文件里面进行输入 try{ FinputStream=newFileInputStream("test/CMD/P0.txt"); System.setIn(FinputStream); }catch(FileNotFoundExceptione){ e.printStackTrace(); } 然后,就可以开始进行跑我们的程序了 //这是我的命令行应用程序 ProcessScheduleAppCmdPSAC=newProcessScheduleAppCmd(); PSAC.run(); 跑完以后,我们直接取出标准输出,转String进行检查 StringcmdOutsString=BoutputStream.toString(); assertEquals(true,cmdOutsString.contains("进行随机模拟")); // 这里面省略无数assertequal语句 assertEquals(true,cmdOutsString.contains("是否已经结束：true")); 最后,复位标准输入输出 System.setIn(oInputStream); System.setOut(oOutputStream); 尾声 以上就是利用Junit对在命令行程序进行check的步骤,谢谢大家 
第400篇文章[]
哈工大软件构造-设计模式学习心得 设计模式 设计模式，即DesignPatterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性 一:总纲 按照王老师的体系,23种设计模式,看上去很多,但万变不离其宗.一切设计模式,均是离不开这两张图.具体来说,就如下两种: 1.只有继承关系的: DIP:依赖倒转原则,细节应当依赖于抽象，抽象不应当依赖于细节。OCP:开闭原则,软件实体应当对扩展开放，对修改关闭. 特点: 只有一颗继承树 在设计模式里面的体现: 模板方法:比如,我写了一个白盒框架,现在要往里面加东西,我希望用户来进行手动添加,那么,我给用户一个接口,下面的子类型实现是可以进行任意安排的. 2.继承+委托(delegation) 特点:两颗继承树 通过另一组继承树,对内在的实现进行了隐藏,具体的体现比如说:Factory方法,Adapter方法,装饰器模式,等等. 对于装饰器来说,可以认为这两颗树均是自己,通过自己对自己进行委托,进行功能的附加. 下面,我们来具体的对王老师上课所授的7种设计模式展开具体分析: 二:具体的7种设计模式 2.1工厂方法: 用户是通过工厂类来得到新的对象,而不是通过new运算符来得到新的对象 常规情况 ProductA=newProductA(); 工厂方法 ProductB=ProductFactory.ProduceA(); 正如船舶里面的水隔舱,工厂类对对象的创建与用户进行了隔离.对于用户而言,它是不知道它的要的产品具体叫什么,这个提供产品的事情,已经被工厂所取代.如果我们需要对功能进行修改的话,只需要动工厂的new的对象,客户端的程序实质上,是稳定的. 2.2适配器模式 考虑下列情形: 假如我们在进行一个机器学习的项目,我们的核心算法,它需要提供一个numpy形式的矩阵,而我们的数据采集器,返回的矩阵,是一个excel文件.这个时候,我们就需要一个适配器,帮我们干活了 它通过委托与接口,在二者之间建立了如下的桥梁; 2.3装饰器模式 人靠衣装,在街上走,你会看到有穿T恤的,穿长袖夹克的,有穿背心的各种各样的人.那么,如果要建立这样的关系的话,我们是可以通过继承来组合,也可以通过建立装饰器来进行委托.如果是组合的话,问题会越来越麻烦.设想,假如一开始所有人都穿T恤,那么到后来,秋天了,大家穿长袖的,有可能是里面套了一个背心,也有可能是里面传了一件毛衣,那么我们都用继承来进行处理的话,这个组合树,将会越来越大.问题很大!这就是组合爆炸所以,正确的做法是,让类学会穿衣服.不同的衣服,展现出不同的特性.有不同的功能 为每一个特性构造子类,并通过委派机制,添加到对象上.基类实现最原始的功能,然后每一个装饰类实现一部分,逐层的去委派实现. 2.4策略模式 考虑如下的场景:假如我们在写一个文本翻译的APP,用户输入文本,我们对其进行翻译.我们一开始是采用SVD分解对文本进行词嵌入.后来,竞争对手纷纷采用了BERT来进行词嵌入,效果比我们好很多.那么,我们也想要用BERT来进行,不过由于考虑到以后的扩展,我们决定将词嵌入,放到一个方法类里面去进行.即这里的策略类.策略模式:存在多种算法来处理同一个任务,但client需要根据需要动态切换算法.我们可以为不同的实现算法构造抽象接口.利用委托,在运行时,动态传入Client倾向的算法类的实例.其UML图如下; 2.5模板模式 还是我们的文本翻译APP.众所周知,NLP文本翻译任务,包含以下几个基本步骤:文本预处理->文本词嵌入->Seq2Seq的生成 我们可以把这几个步骤抽出来作为模板,子类在继承时,进行实现.让子类分别实现我们的模板里面的方法,预处理,词嵌入,文本生成.他们,作事情的步骤时一样的,但具体的方法不同.让共性的步骤在公共实现.差异化的在子类实现. 2.6迭代器模式 用途:我们给外界用户的往往是一个黑箱,如果用户有想要逛逛的需求的话,我们便要在既维护内在表示的基础上,又满足外界用户的需求.在Java里面已经提供了下面的接口:Iterable接口:实现这个的集合对象是可遍历的Iterator接口:迭代器,实现这个的是可以进行显示/隐式的进行迭代的. 2.7Visitor模式 简单点说:就是预留扩展点,以便日后的扩展为我们的对象的特定Visit,运行时进行动态的绑定.操作可以灵活更改的.方便以后操作. 以上就是对于设计模式的一些总结与思考,谢谢. 
第401篇文章[]
Java源码探究学习(一)论List(更新中) Java源码探究学习(一)论List(更新中) 前言:由于笔者于哈工大学习软件构造时,王老师上课抛出了一个小任务,即,从Java的源码里面来学习它的ADT的思想.所以,笔者希望通过写一点点博客,进行探究 一.LinkedList的探究 首先,我们进入linkedlist的源码,进行粗略的看看,首先,看看这个实现的spec,通过加批注的方式进行学习. 首先介绍,这个链表,实现了List与Deque,允许所有的元素. /** *Doubly-linkedlistimplementationofthe{@codeList}and{@codeDeque} *interfaces.Implementsalloptionallistoperations,andpermitsall *elements(including{@codenull}). * *<p>Alloftheoperationsperformascouldbeexpectedforadoubly-linked *list.Operationsthatindexintothelistwilltraversethelistfrom *thebeginningortheend,whicheverisclosertothespecifiedindex. **/ Percondition: 通过加粗的话,设定前置条件,这个实现不是synchronized.的 /* *<p><strong>Notethatthisimplementationisnotsynchronized.</strong> *Ifmultiplethreadsaccessalinkedlistconcurrently,andatleast *oneofthethreadsmodifiestheliststructurally,it<i>must</i>be *synchronizedexternally.(Astructuralmodificationisanyoperation *thataddsordeletesoneormoreelements;merelysettingthevalueof *anelementisnotastructuralmodification.)Thisistypically *accomplishedbysynchronizingonsomeobjectthatnaturally *encapsulatesthelist. * *Ifnosuchobjectexists,thelistshouldbe"wrapped"usingthe *{@linkCollections#synchronizedListCollections.synchronizedList} *method.Thisisbestdoneatcreationtime,topreventaccidental *unsynchronizedaccesstothelist:<pre> *Listlist=Collections.synchronizedList(newLinkedList( ));</pre> **/ Postcondition: 对后置条件进行说明: 说明本类里面方法的返回值,同时提到了failfast,即针对每种不满足情况,抛出的异常 /*<p>Theiteratorsreturnedbythisclass's{@codeiterator}and *{@codelistIterator}methodsare<i>fail-fast</i>:ifthelistis *structurallymodifiedatanytimeaftertheiteratoriscreated,in *anywayexceptthroughtheIterator'sown{@coderemove}or *{@codeadd}methods,theiteratorwillthrowa{@link *ConcurrentModificationException}.Thus,inthefaceofconcurrent *modification,theiteratorfailsquicklyandcleanly,ratherthan *riskingarbitrary,non-deterministicbehavioratanundetermined *timeinthefuture. * *<p>Notethatthefail-fastbehaviorofaniteratorcannotbeguaranteed *asitis,generallyspeaking,impossibletomakeanyhardguaranteesinthe *presenceofunsynchronizedconcurrentmodification.Fail-fastiterators *throw{@codeConcurrentModificationException}onabest-effortbasis. *Therefore,itwouldbewrongtowriteaprogramthatdependedonthis *exceptionforitscorrectness:<i>thefail-fastbehaviorofiterators *shouldbeusedonlytodetectbugs.</i> * *<p>Thisclassisamemberofthe *<ahref="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"> *JavaCollectionsFramework</a>. **/ 下面是对作者进行了介绍,膜拜一下大佬  /* *@authorJoshBloch *@seeList *@seeArrayList *@since1.2 *@param<E>thetypeofelementsheldinthiscollection */ 再往下面看,发现当年作者写的checkRep即,从这里我们可以看到作者的表示不变量即要么,size是0,链表里面没有元素;firstlastnull要么,first的前面与last的后面,都是null 更新中… 
第402篇文章[3]
拓扑排序以及其C++实现 拓扑排序 啥是拓扑排序？ 直观理解就是在AOE/AOV网络里面，把图的一种先后顺序，对图进行遍历 进行的算法也不难 直接每次选取入度为0的点，进行入队 然后每次出队一个，并对其邻接的顶点进行度的减一操作。 如果出队的顶点数小于总的顶点数，那么，表明存在圈 所以，该算法也能用于有向图的圈的判定问题。 咱们利用一道例题说明： 08-图8HowLongDoesItTake(25分) Giventherelationsofalltheactivitiesofaproject,youaresupposedtofindtheearliestcompletiontimeoftheproject. InputSpecification: Eachinputfilecontainsonetestcase.EachcasestartswithalinecontainingtwopositiveintegersN(≤100),thenumberofactivitycheckpoints(henceitisassumedthatthecheckpointsarenumberedfrom0toN−1),andM,thenumberofactivities.ThenMlinesfollow,eachgivesthedescriptionofanactivity.Forthei-thactivity,threenon-negativenumbersaregiven:S[i],E[i],andL[i],whereS[i]istheindexofthestartingcheckpoint,E[i]oftheendingcheckpoint,andL[i]thelastingtimeoftheactivity.Thenumbersinalineareseparatedbyaspace. OutputSpecification: Foreachtestcase,iftheschedulingispossible,printinalineitsearliestcompletiontime;orsimplyoutput“Impossible”. SampleInput1: 912 016 024 035 141 241 352 540 469 477 574 682 784 SampleOutput1: 18 SampleInput2: 45 011 022 213 134 325 SampleOutput2: Impossible 题目的大致意思，就是：每项工作，用图G里面的边进行表示，节点表示任务结束（AOE/activityonedge网络），求最小完成时间 我们需要做的，实现之前的拓扑排序算法 对于最短时间，我们只需要弄一个数组earlist，每次入度减一时，进行最大的更新操作 PS：一开始，没看清楚权重为0的边，表明我们在对图的初始化时，要当心。调试程序真的是让人头秃啊。。。。。 代码见下： #include<iostream> #include<queue> #defineinf9999999 intn,m; intgraph[200][200]; intru_du[200]; usingnamespacestd; voidini() { cin>>n>>m; inti,j,k,x,y; for(i=0;i<200;i++) { for(j=0;j<200;j++) { graph[i][j]=-100; } } for(i=0;i<m;i++) { cin>>x>>y; cin>>k; graph[x][y]=k; ru_du[y]++; } } intmaxx(inta,intb) { if(a>b) { returna; } else { returnb; } } voidslove() { queue<int>qq; inti,j,k; for(i=0;i<n;i++) { if(ru_du[i]==0) { qq.push(i); } } intcounnt=0; intearlist[2000]={0}; while(!qq.empty()) { intt=qq.front(); qq.pop(); counnt++; for(i=0;i<n;i++) { if(graph[t][i]!=-100) { ru_du[i]--; earlist[i]=maxx(earlist[i],earlist[t]+graph[t][i]); if(ru_du[i]==0) { qq.push(i); } } } } if(counnt!=n) { cout<<"Impossible"; return; } else { intt=0; for(i=0;i<n;i++) { t=maxx(earlist[i],t); } cout<<t; return; } } intmain() { ini(); slove(); } 
第403篇文章[6]
数学建模1-评价类问题 数学建模-评价类问题 问题的引入： 假设小明同学高考结束，准备选择EE或者是CS里面的一个，现在，我们需要帮助小明做出符合数学的抉择。 （其实是一类问题，问题本身是非数学的，再比如，你母亲和女友同时落水，你准备救哪一个，但是，我们需要根据我们所学的数学知识，做出抉择） 那么我们就打分吧。 一个显然的想法：确定好打分指标，然后，对每个方案进行打分。 但是，问题在于，怎么打分？毕竟，打分这事，有点主观性过强。 所以，接下来，介绍的，评价类算法，就是告诉我们，怎么打分。 首先上场的是层次分析法 简单的介绍：（此处引用他人的博客。。） 说白了，就是几步，我画了个流程图来概括其大致思路。 根据问题，确定目标层 根据文献（自己的推测？）确定准则层与决策层（个数小于15） 然后两两确定，写出判断矩阵，再进行一致性检验， 在一致性检验通过的时候，求解权重 （P.S这种方法，也可以进行判断比较并确定其它评价方法里面准则的权重）（套娃？？） 然后上场的，是TOPSIS方法（优劣解距离法） 上种方法评价的决策层不能太多，否则，差异太大 如果我们已经得到了数据，那么，层次分析法就显得太主观了，引入数据来分析，更加客观。 此处再次引用他人博客 基本的思路 对指标进行分类： ​极大（小）型指标：越大（小）越好 ​中间（区间）型：居中（某一个区间）就好 然后极小型（中间型）转极大型 标准化消去指标间的量纲 最后进行归一化： （抽象的来看，就是导出评价对象在评价域这个向量空间里面，与我们最大（小）值向量的距离，并以此来进行排序） 导出与最大/最小 所以，方法的核心就是：对我们手中所得到的数据进行处理，找出指标，处理掉指标的量纲影响，确定一个评价空间，在这个向量空间里面，找出每一个对象距离最大值与最小值的距离。 二话不说，上流程图： 在TOPSIS方法里面，每个指标对应的权重，是可以根据层次分析法进行赋值的，不过，这种方法主观性太强了。还有一种方法，也可以对指标进行赋值 熵权法 指标的变异程度越小，反应的信息量越小，对应的权值应该越低 而概率越大的事件，其信息量应该越少，概率越小，信息量应该越多。 基本原理：引用他人博客 基本的流程: 1）数据处理，归一化 2）计算信息熵 3）计算权重 换一种角度，还有方法进行评价-模糊综合评价 其实，所有的评价类问题的方法，抽象的来看，说的都是一个东西。 定义： ​因素集：所研究的问题，可以从多个角度看，因素集，即问题空间中的一组基。 ​评语集：将问题空间里面的元素经映射后，对应的结果（值域）。 ​权重集：各因素集元素在某一次至评语集映射中所占权重。 我们在评价类问题里面需要解决的要做的：把论域中的对象对应至评语集中指定的评语。不同的评价类方法，就是不同的映射。将论域V里面的问题，映射到我们的评价域U。 上面的比较抽象，其实简单的来说，就是对某一特定对象给出一个评价。或者，将把评价换成方案。 那么，回到原点，什么是模糊综合评价？ 简单的来说，就是引入模糊数学里面的概念，通过隶属函数（模糊）/模糊统计法，确定好各因素在评语集里面所占的份量，最后，赋予权重，找最大的权值的评语作为我们的结论。 详细的解说：别人的博客 我对上述过程画了一张图来帮助理解。 
第404篇文章[1]
哈工大计算机系统大作业-C、C++底层实现分析 哈工大计算机系统大作业-C、C++底层实现分析 第1章C语言的语言元素1.1程序结构1.1.1循序结构1.1.2分支（1）if语句（2）switch语句 1.1.3循环（1）while语句（2）do-while语句（3）for语句 1.2变量1.2.1全局变量1.2.2局部变量1.2.3整型变量1.2.4浮点变量1.2.5寄存器变量1.2.6指针变量1.2.7结构体1.2.8共用体1.2.9枚举类型1.2.10数组1.2.11常量 1.3函数1.3.1函数格式1.3.2参数传递 1.4其他1.4.1类型转换1.4.2运算符 第2章汇编语言的语言元素2.1程序结构2.1.1整体结构2.1.2分支2.1.3循环 2.2数据2.2.1数据存储2.2.2整数2.2.3浮点数2.2.4数据格式 2.3函数2.3.1参数传递的规则2.3.1调用语句2.3.2返回值传递 第3章C语言的汇编实现3.1数据类型的实现3.1.1整型3.1.2浮点型3.1.3指针与数组、结构3.1.4类型转换3.1.5寻址问题 3.2代码结构的实现3.2.1循序3.2.2分支3.2.3循环3.2.4优化对循环的影响 3.3函数的实现 第4章C与汇编的优缺点分析4.1C语言4.1.1优势4.1.2劣势4.1.3应用场景 4.2汇编语言4.2.1优势4.2.2劣势4.2.3应用场景 4.3总结 参考文献 第1章C语言的语言元素 1.1程序结构 1.1.1循序结构 C语言中程序的执行方式为顺序执行，即当某一代码块中没有可能会导致跳转的语句，例如循环、分支、函数等时，程序从这一代码块的第一条指令，逐条执行到最后一条指令。例如在某一.c文件中写入下列代码： intmain() { A=1; B=2; A=A+B; return0; } 在这一程序中，main函数所运行的代码为完全的循序结构。 1.1.2分支 （1）if语句 在C语言中，if语句的格式为： if(条件表达式1) {代码1} elseif(条件表达式2) {代码2} 。。。 else {代码n} 其中elseif和else不是必须的。在每个if和elseif后的括号中，为运行其后代码所需要的条件，当所有条件表达式均为否时，则执行else后面的代码，若没有else，则不做任何操作。在C语言中，当条件表达式的值为0时，则认为条件表达式为否，而当条件表达式为任意非0值时，则认为条件表达式为真。除此之外，C++中还定义了bool类型，true表示真，false表示否，且true可视作为1，false可视作0。 （2）switch语句 在C语言中，switch语句的格式为： switch(变量a) { case情况1: 代码1 case情况2: 代码2 。。。 default: 代码n } 其中，变量为某一基本类型变量a，即char、int、float、double等类型变量。并且default标记不是必要的。case后面的情况为a所可能的各种取值，当a满足其取值为某种情况时，程序将跳转到这一情况对应case后面的代码，并且程序将运行后面全部代码，包括其他case的代码，直到遇到break语句或运行完其后续的所有代码，才会退出switch代码块。当a没有满足任何列出的情况时，程序将跳转到default后面的语句，运行情况同case。另外，当没有default时，程序将直接退出switch代码块。 1.1.3循环 （1）while语句 在C语言中，while语句的格式如下： while(条件表达式) { 代码 } 当条件表达式为真时，程序将执行代码块中的代码。 （2）do-while语句 在C语言中，do-while语句的格式如下： do { 代码 }while(条件表达式); 程序将先执行一遍代码块中的代码，然后判断条件表达式是否为真，若为真，则重复执行代码块中的代码。 （3）for语句 在C语言中，for循环的语句格式如下： for(初始化表达式;条件表达式;迭代表达式) { 代码 } 程序先根据初始化表达式进行初始化，并判断条件表达式是否为真，若为真则运行代码块中的代码，随后运行迭代表达式，再重新判断条件表达式是否为真，当条件表达式不为真时，退出循环，否则继续运行代码块。 1.2变量 1.2.1全局变量 在C语言中，定义在函数外的变量为全局变量，其作用域为文件中的全体函数，以及调用该文件的其他文件中的全体函数，当其用static进行修饰时，其作用域仅为当前文件中的全部函数。当用extern进行修饰时，说明该全局变量需要在其他C文件中定义。任何数据类型的变量均可被定义为全局变量，且全局变量的生命周期为整个程序的生命周期，当程序结束时，其内存才被释放，在此之前，其内存一直存在。当代码中未对全局变量进行初始化时，其将被初始化为0。 1.2.2局部变量 在C语言中，局部变量定义在函数内部或函数内部某一代码块中，其作用域为函数内部或代码块内部，以及函数内部的代码块中。局部变量的生命周期为整个函数或代码块，当局部变量没有被显示初始化时，其值为一伪随机数，所以局部变量需要在使用前进行初始化。但当局部变量用static进行修饰时，其值不会因为其所在函数结束而被修改，而是会在再次执行到这一函数时存储其先前的值。另外静态局部变量若没有进行显示初始化，其初始值为0。 1.2.3整型变量 在C语言中，整型变量包括char、short、int、long、longlong几种类型，其区别在于所需存储空间的大小以及其所能表示数字的大小，long类型在不同系统中往往有着不同的容量。在C语言中，整形数据均采用补码存储，除char类型外，其他类型均默认为有符号整数，可以通过在int等关键字前添加unsigned关键字来声明无符号的数据类型，同理可以通过在char关键字前添加signed关键字特别声明有符号的以表示单字节变量。另外，char类型大部分时候均用来表示ASCII码，并不经常用来表示数字。 1.2.4浮点变量 在C语言中，浮点变量包括float、double、longdouble几种类型，其区别同样是其存储空间大小及其表数范围、表数精度。其中longdouble在不同系统中往往有不同的容量。C语言中，浮点类型通过IEEE754编码实现。浮点变量通常用于表示小数以及过大的数，但其对于大部分数字而言只能存储近似值，不能保证绝对精确，而精确程度与其存储空间有关。 1.2.5寄存器变量 在C语言中，需要频繁进行使用的变量可以通过register关键字将其定义为寄存器变量，寄存器变量总是保存在CPU的寄存器中，可以有最高的运行效率。32位下由于寄存器空间的限制，寄存器变量只能为char、short、int类型。而且由于寄存器变量不存储在内存中，所以不可以对其用取地址运算符。 1.2.6指针变量 在C语言中，指针变量存储一个虚拟内存的地址，任何数据类型均有与其对应的指针类型，除此之外，还有指向函数的函数指针。指针类型在32位编译模式下大小为4字节，在64为编译模式先大小为8字节。可以通过取地址运算符&获取某一变量的地址，也可以通过*运算符访问一个指针所指向的内存空间。除此之外，当指针为结构体指针时，可以通过->运算符读取该指针所指向结构体的成员变量。 1.2.7结构体 在C语言中，结构体是一种抽象数据类型，它一般表示某种需要通过多种数据类型才能精准表示的事物。一般定义结构体数据类型的代码格式如下： struct类型名 { 数据类型1变量A; 。。。 数据类型n变量N; }; 在定义结构体类型后，需要通过以下格式声明一个结构体类型变量：struct结构体类型名变量名;若想访问或修改结构体变量的某个具体属性，需要通过圆点运算符.进行读取。 1.2.8共用体 C语言中，可以通过共用体对同一段内存进行不同种数据类型的存储、读取。其定义格式如下： union共用体类型名 { 可能的数据类型变量; }; 在定义共用体类型后，需要通过以下格式声明一个共用体类型变量：union共用体类型名变量名;并通过原点操作符.来选择其存储哪种数据类型并进行读写。共用体所占空间大小与其内部最大空间的数据类型相同，当用较小的数据类型模式读取存储较大数据类型的共用体时，只会读取内存的前几个字节，且具体读出的结果与大小端模式有关。 1.2.9枚举类型 C语言中，对于某一概念中包括多种常量时，可以使用枚举类型，其定义格式为： enum枚举类型名 { 常量名1; 。。。 常量名n; }; 枚举类型的常量可以直接对其常量名进行访问，另外在枚举类型定义时可对其各个常量进行赋值，用以使其用来表示某个整数值。若没有在枚举类定义中设置常量值，则程序将从第一个常量从0开始顺序赋值；若只对第一个常量进行赋值，程序将从这个值开始为后续常量顺序赋值。除此之外，枚举常量作为常量，不能被程序进行修改，只能将其赋值给某一变量。 1.2.10数组 C语言中，所有类型的变量都可以在其声明时在其变量名后添加[]使其被定义为数组变量，通常[]中应以常量注明数组大小，但当数组被初始化时，数组大小可不进行注明。另外，变量名后可添加多个[]表示多维数组，但只有第一个[]可以不注明数组大小。除此之外，char数组足够大时可被直接用来存储字符串，字符串可被视作以\0字符结尾的字符数组。 1.2.11常量 C语言中，常量包括数字、字符串、宏常量、const常量几种数字包括整数与小数，其中整数可以通过在数字前标注0前缀表示8进制，标注0x前缀表示16进制，另外可以通过在数字后加U后缀表示该数字为无符号数字，后缀L表示数字为long类型，否则将其视为十进制有符号int类型。而浮点类型可以通过在数字后加F表示该数字为float类型，否则为double类型。在代码中所有显示出现的字符串均被视为常量，不可以对其进行修改，否则会报错。C语言中可以通过预处理命令定义宏常量，会在预处理阶段将宏常量转化为其对应的常量，其定义格式为：#define常量名常量数值C语言中，还可以通过const关键字使某一变量值除定义时的初始化外，无法进行修改，即使其成为常量，但该常量的作用域仍与其定义位置有关。另外，当一个指针变量被const关键字修饰时，其所指向的内存也不可通过这个指针变量进行修改。 1.3函数 1.3.1函数格式 在C语言中，函数表示某一段执行特定功能的代码，可以由其他函数进行调用，其定义格式为： 返回值类型函数名(数据类型1变量A,。。。,数据类型n变量N) { 代码 return返回值; } 当返回值类型为void时，return语句可以不写，也可以仅为return;用以标志程序退出位置。通常情况，函数应该在编写实现代码前进行声明，函数声明格式如下：返回值类型函数名(数据类型1变量A,。。。,数据类型n变量N);当在函数声明前添加static关键字时，可以将函数的使用范围限定在当前文件中。当在函数声明前添加extern关键字时，函数被视作需要从其他C文件中引用，因而不需要函数体。另外，在每一个可以被编译为可执行程序的C文件中均有一个程序开始执行的入口函数，对于命令行程序而言，其入口函数为main函数，程序总是从main函数的第一行开始执行，且main函数无论通过直接或间接方法都无法访问到的函数通常可以被认为永远无法被执行。 1.3.2参数传递 在调用某一函数时，开发者需要按照函数声明向函数输入约定参数进行调用，并接收其返回值。函数在被调用时所接受的参数存储在其自身的局部变量中，对传递进来的参数进行修改，不会影响到传递的参数的值，但对于指针参数而言，其所指向的位置依然相同，因此对指针所指向的空间操作会影响到其他函数的运行，所以当有不想被函数修改指向空间的指针变量时，可以在其声明中加以const关键字修饰。当函数的参数为数组或结构体时，可以视为传递的为数组或结构体的指针，对他们进行操作时也会导致其内部结构发生改变。在C++中，可以在声明中通过引用变量直接对传递进来的参数进行操作，修改其数值。另外，通常函数在运行时，只能直接访问其内部的局部变量以及各全局变量，不能访问到其他函数的局部变量。 1.4其他 1.4.1类型转换 在C语言中，类型转换分为隐式转换与显示转换。隐式类型转换发生在小数据类型与大数据类型进行运算时，以及整数数据类型与浮点数据类型运算的时候。当某一小数据类型与大数据类型进行运算时，小数据类型会被转换为大数据类型再进行运算，并且计算结果为大数据类型。当整数数据类型与浮点数据类型进行计算时，整数数据类型会被转换为浮点类型再进行计算。另外在用整数数据类型变量接收浮点类型时，会自动将浮点类型转换为舍入到整数位的整数类型，再进行赋值；当用大数据类型接受小数据类型时，会自动将小数据类型转化为大数据类型，再进行赋值。显示转换也叫强制类型转换，一般发生在大数据类型转换为小数据类型、将某一数字常量强制视为另一种类型的常量进行运算、强制将某一变量通过另一变量的格式进行解读时。需要注意的是，第一种情况下，强制类型转换可能会导致数据溢出和舍入。除此之外，有符号整数与无符号整数之间的强制类型转换，满足数据的位模式不变。 1.4.2运算符 C语言中有大量运算符，他们在计算过程中会按照优先级进行运算，下列是运算符优先级及功能表||| 优先级运算符名称或含义使用形式结合方向说明1[]数组下标数组名[常量表达式]左到右–1()圆括号(表达式）/函数名(形参表)左到右–1.成员选择（对象）对象.成员名左到右–1->成员选择（指针）对象指针->成员名左到右–2-负号运算符-表达式右到左单目运算符2~按位取反运算符~表达式右到左单目运算符2++自增运算符++变量名/变量名++右到左单目运算符2–自减运算符–变量名/变量名–右到左单目运算符2*取值运算符*指针变量右到左单目运算符2&取地址运算符&变量名右到左单目运算符2!逻辑非运算符!表达式右到左单目运算符2(类型)强制类型转换(数据类型)表达式右到左–2sizeof长度运算符sizeof(表达式)右到左–3/除表达式/表达式左到右双目运算符3*乘表达式*表达式左到右双目运算符3%余数（取模）整型表达式%整型表达式左到右双目运算符4+加表达式+表达式左到右双目运算符4-减表达式-表达式左到右双目运算符5<<左移变量<<表达式左到右双目运算符5>>右移变量>>表达式左到右双目运算符6>大于表达式>表达式左到右双目运算符6>=大于等于表达式>=表达式左到右双目运算符6<小于表达式<表达式左到右双目运算符6<=小于等于表达式<=表达式左到右双目运算符7==等于表达式==表达式左到右双目运算符7!=不等于表达式!=表达式左到右双目运算符8&按位与表达式&表达式左到右双目运算符9^按位异或表达式^表达式左到右双目运算符10|按位或表达式表达式左到右11&&逻辑与表达式&&表达式左到右双目运算符12||逻辑或表达式||表达式左到右双目运算符13?:条件运算符表达式1?表达式2:表达式3右到左三目运算符14=赋值运算符变量=表达式右到左–14/=除后赋值变量/=表达式右到左–14*=乘后赋值变量*=表达式右到左–14%=取模后赋值变量%=表达式右到左–14+=加后赋值变量+=表达式右到左–14-=减后赋值变量-=表达式右到左–14<<=左移后赋值变量<<=表达式右到左–14>>=右移后赋值变量>>=表达式右到左–14&=按位与后赋值变量&=表达式右到左–14^=按位异或后赋值变量^=表达式右到左–14|=按位或后赋值变量|=表达式右到左–15，逗号运算符表达式,表达式,…左到右– 第2章汇编语言的语言元素 2.1程序结构 2.1.1整体结构 注意，下面所说的汇编语言均以AT&T为例。汇编程序中每个节由.section进行标识，每个汇编程序通常有.data、.text、.bss三个节，其功能如下.data节存储已初始化的变量，且其可读也可写，可以在代码中对其进行读写。.bss节存储未初始化的变量，当使用这些变量时，可以视作他们都被初始化为0。.data节与.bss节共同构成了程序的数据段，用来存储汇编程序中的各种变量。.text节存储程序的指令代码，该节中的代码为只读模式，不可进行修改。每一个可执行汇编程序中都应该至少有一个.text节。通常在.text节的第一行代码中定义.global_start符号或.global_main符号，并在后面编写其程序体，以此作为程序的入口函数，并按照该函数中的代码顺序运行。.text节也被视作汇编程序的代码段，用来存储程序中的各个函数的指令代码。汇编程序中的栈段并不会在代码中显示定义，但代码段中有各种用于对栈进行操作的指令，例如push，pop等，另外程序可以通过对栈顶指针相对寻址的方式来间接使用栈段。栈段的数据为可读写模式。 2.1.2分支 在汇编语言中，分支通过jmp等指令修改%rip寄存器实现，其中，jmp为无条件强制跳转，而其他跳转指令则是根据当前各条件位的状态判断是否跳转到其他指令地址。例如je指令在判断ZF条件码为1时才会跳转到其参数的地址。在跳转指令中，可以通过*运算符来进行间接跳转，例如跳转到某寄存器所存内存地址等情况。需要注意的是，汇编语言中的跳转指令通常可以跳转到任何位置，操作不当可能会造成严重错误，所以通常应该只用于函数内部的跳转。 2.1.3循环 在汇编语言中，并没有直接提供用来构造循环的语法，但是可以通过设置循环起点以及循环终止条件，当终止条件不满足时，使用je等指令跳转到循环起点，从而实现循环的功能。通常，循环起点被标注为loop符号。 2.2数据 2.2.1数据存储 在汇编语言中，数据分为立即数、寄存器数据、内存数据三种。常数通常直接使用立即数进行表示，在任何操作中，立即数均不能作为指令的接收部分。在AT&T中，立即数的表示方法为在数字前加$符号。另外，可以在数字前加0x前缀以表示十六进制数字。变量通常使用寄存器与内存进行存储，对于使用频率极高的变量，可以将其存储于寄存器中，以提高读取速度，而通常的变量，均存放在内存中。许多指令都只支持寄存器作为参数，所以许多时候，变量需要先读取至存储器中，才能进行操作，这种情况，存储器相当于一个实现功能所需的缓存。另外，由于存储器数量比较少，所以大部分的数据通常都存放在内存中，对于作用域比较小的变量，通常通过%rsp和%rbp两个寄存器，将其存放在栈中，并使用他们对其进行读写。而对于全局性变量来说，通常使用绝对取址或通过%rip寄存器运算获取其位置，并进行读写操作。 2.2.2整数 在汇编语言中，整数通过补码进行表示，且不区分有符号整数与无符号整数，同一位模式的数据既可以作为有符号整数操作，也可以作为无符号整数操作。但汇编语言中有各种针对相同位模式，分有符号和无符号两种对数据进行操作的指令。另外，整数数据也按照大小分为单字节、单字、双字、四字四种类型，分别对应一个字节、两个字节、四个字节、八个字节四种情况，每种类型对应的指令分别有b、w、l、q四种后缀，以针对这四种类型的数据进行操作。需要注意的是，当寄存器中大数据强行作为小数据使用时，其高位数据通常会被保留，但四字数据强行转换为双字数据时，其高四位将被清零。 2.2.3浮点数 在汇编语言中，浮点数也通过IEEE754编码进行表示，并且浮点数的存储方式与正常数据相同，但读取一个浮点数不应使用%rax等整数寄存器，而是应该使用%xmm、%ymm系列寄存器，并使用浮点数专用的指令进行浮点运算。 2.2.4数据格式 在汇编语言中，指令的操作数按照下图的格式进行输入： 2.3函数 2.3.1参数传递的规则 在32位汇编程序中，参数的传递一般是按照将函数的参数从左到右依次压入栈中，然后通过函数的栈指针对各参数进行读取与修改。在64位汇编程序中，参数的传递一般结合了寄存器实现，参数会依次存入%rdi、%rsi、%rdx、%rcx、%r8、%r9中，当参数多于6个时，其余参数会被压入栈中，并通过栈指针进行读取与修改。 2.3.1调用语句 在汇编语言函数开始调用时，call指令会先将%rip中的数据进行压栈，然后将%rip修改为该函数的第一条语句，前几条语句通常是用来构建函数栈的，并按照顺序逐条执行函数中的语句，同时，当需要使用局部变量时，函数会将其存放在。最终，函数通常将运行leave和ret指令，从而将控制权转移回调用它的函数，并将栈清空。 2.3.2返回值传递 通常，当函数有返回值时，该函数会在结束运行前将计算得到的返回值保存到%rax寄存器中，并在调用者函数中通过访问%rax寄存器进行对函数返回值的接受。 第3章C语言的汇编实现 3.1数据类型的实现 3.1.1整型 在C语言被编译为汇编语言的过程中，表示整型数据的全局变量被翻译为汇编语言中的各种全局符号，表示整型数据的局部变量被转换为对应函数栈帧中的特定位置内存，而C源代码中出现的各整数常量则被翻译为立即数。具体实现过程描述如下：对于全局变量，汇编代码中会将其翻译为全局符号，对于有初始值的全局变量，其在汇编代码中会被标志为.data节，并在符号内部填充相应初始值；而对于无初始值的全局变量而言，其会被标志为.bss节。但其具体使用相似，都是被编译为在汇编指令中直接使用相应全局符号。而对于局部变量而言，汇编代码中，会将C语言各函数中的局部变量名无视，直接将局部变量存储在函数的栈帧中，并使用寄存器进行寻址来读写局部变量。需要注意的是，静态局部变量会被编译器解释为符号，并按照与全局变量相同的方式进行存储于使用，但其使用范围会被限制在相应的函数中。另外，代码中出现的整型常量通常被直接翻译为汇编代码中的立即数，作为汇编指令的源操作数。 3.1.2浮点型 对于浮点数，C语言在编译后会将表示浮点数的IEEE754编码按照十六进制数字整数进行存储、读取，但浮点数运算部分，代码会被编译为使用%xmm等寄存器并使用各种浮点数运算指令进行相关的浮点运算。 3.1.3指针与数组、结构 当C语言被编译为汇编时，C语言中的指针会被视为整型变量，唯一区别是，C语言中针对指针的各种操作会被编译为一套特定的汇编代码，而通常的整型变量不可以使用这些操作，从而不可能出现非指针变量被编译后出现这些指令序列的情况。数组通过在内存中对同一数据类型连续存储实现，访问数组某一元素，只需根据首字节地址以及其与首字节的偏移量即可实现。结构和数组的结构相似，但其内部的数据类型不同，占用空间也不同，每种数据类型的存储位置按照其在结构体中定义的顺序，而且每一个数据其距离结构体首字节的距离满足其自身大小的整数倍，从而实现对齐。另外，在数组、结构等数据类型被编译为汇编语言时，其内部数据通常存储在栈中，而用表示其首字节地址的整型变量作为其位置的标识，并根据其内部结构进行相对寻址从而读写他们内部的数据。 3.1.4类型转换 C语言中的整数间类型转换在汇编语言中通过movzbl等指令以及CPU寄存器特性等功能实现。对于自动类型转换而言，相应计算代码会被编译为先使用类型转换命令将小数据转换为大数据类型随后将两个相同数据类型的数据再进行运算。而强制类型转换也是通过这些指令来进行的，区别仅在于C语言中的限制。对于与浮点数有关的类型转换，均是通过浮点数指令来进行的，例如通过vcvtsi2ss指令将整数转换为单精度浮点数。 3.1.5寻址问题 在C语言被编译为汇编语言的过程中，全局变量的寻址通常使用与%rip共同使用来间接访问某一绝对地址的方式实现，而局部变量的寻址则是通过在其所在函数的栈帧中，通过%rsp进行相对寻址来实现。 3.2代码结构的实现 3.2.1循序 当C语言被编译为汇编语言时，C语言中的循序代码会被逐条翻译为相应的汇编代码，其运行顺序不变，从而实现了C源代码编译后的汇编代码依然循序。 3.2.2分支 当C语言被编译为汇编语言时，if语句会被翻译为先进行条件判断，当满足条件时跳转到相应代码，不满足条件时顺序执行的汇编结构。而switch语句将会构建一个跳转表，对于每一种情况，都将其代码进行标记，并将标记存放在跳转表中，当满足条件时，控制将会跳转到相应代码并顺序执行。 3.2.3循环 C语言中包含三种循环，其被翻译为汇编代码时有不同的表现，细节如下：对于do-while循环，其汇编代码实现方式为在代码第一行前通过一个符号进行标志，当运行结束这段代码时，判断循环条件，若满足条件，则跳转到前面的符号，从而实现循环功能。对于while循环，程序会在代码部分和条件判定部分分别进行标记，在开始循环前，程序会跳转到条件判定部分，当条件满足时，再跳转到代码部分并循序执行相应代码，执行结束时，控制会回到条件判定部分，从而实现循环功能。对于for循环，程序会在循环条件判定部分及循环体部分进行标记。在循环代码执行前执行循环初始化代码，随后将控制转移到条件判定标志，当条件满足时，执行循环体，紧接着执行循环迭代代码，再进行条件判定，从而实现for循环功能。 3.2.4优化对循环的影响 当编译器开启了优化选项时，编译器可以对循环生成的代码进行优化，从而实现效率的提升，其具体实现可以分成以下几点：首先，当某一循环体为空时，优化会导致程序忽略该循环。其次，当循环中的运算结果若在后续代码中未被使用，循环将直接被优化删除。除此之外，优化可能为了提高程序效率调整部分代码次序或删除部分代码。另外，当代码中重复计算相同的数据时，该部分代码会被编译器移出循环。需要注意的是，用于实现等待一段时间的循环通常会被编译器优化。 3.3函数的实现 C语言被编译为汇编语言时，函数名会被翻译为一个.text节符号，并在它的内部定义函数的具体实现代码。每个函数的前几行指令，通常为开辟新的函数栈帧以保存其内部局部变量等信息，并在最后几行调用leave、ret等指令，将控制转移回其调用函数。对于函数各个参数的传入，以64位系统为例，调用函数需要在调用所需函数前将函数所需要的各个参数存放在相应寄存器中，当参数数目过多，寄存器无法容纳时，函数栈帧将会有一块专门的参数构造区，用以存储参数7之后的参数，并通过%rsp、%rbp进行相对寻址从而对其进行读写操作。需要注意的是，若在C语言代码中对变量进行取地址运算，则该变量通常会被保存在栈中。当函数代码运行完毕前，需要将要返回的数据保存在%rax中，并在调用函数中接收并进行相应的操作。 第4章C与汇编的优缺点分析 4.1C语言 4.1.1优势 C语言作为一种高级编程语言，其抽象程度比汇编语言更强，也更加贴近于人的理解过程。它的优点包括以下几个方面：C语言，将对内存中各个地址的数据的操作抽象为对一个个变量的操作，只需要专注于某个算法的具体实现流程，而无需过多考虑底层硬件，这一特点使得它相比于汇编语言能让人更好的了解与设计某段程序的功能以及其运行过程，使得其编程思路相比于汇编语言也更加人性化。所以，C语言的开发速度相比汇编语言大大提高，同时其也大大降低了编程的门槛与难度。除此之外，若一个C程序不调用任何与某个特定平台相关的库以及其中的函数，则将它的源代码复制到不同的平台，并使用该平台上的编译器，则其编译后的程序的运行效果将完全相同，而不受平台的影响，其可移植性相比汇编语言更强。另外，C语言也是程序员入门的较好的编程语言，他的内容比较少，而且与底层硬件紧密相关，能够帮助学习者更快地了解计算机的相关知识。 4.1.2劣势 C语言作为一个高级编程语言也有着不少缺点，当CPU出现某些新特性时，要想利用他们，C语言的编译器可能不得不进行改变，甚至对于某些特定的特性，C语言很难将其进行利用，进而导致程序对CPU无法进行充分地利用。另外，C语言虽然是一种比较高效的高级语言，但对于一个熟练的汇编语言程序员来说，汇编代码的效率往往比C语言更高。 4.1.3应用场景 当某个学生希望学习编程相关知识时，应该首先考虑内容较少但却与底层硬件紧密相关的C语言作为入门编程语言。当编写操作系统时，对于一些抽象程度较高的功能，应该使用C语言进行编写，从而简化编写过程，将注意力更多地放在程序的功能上，并减少潜在的BUG。当编写一些功能众多、体量巨大又追求较好的效率，但与计算机底层关系并不是很大却也有部分相关的项目时，也应该采用C语言以提高开发效率。当编写一些嵌入式设备的程序时，但开发者对该设备CPU所使用的汇编语言不了解时，也应采用C语言，从而完成任务。当编写的程序可能需要在多个平台发布时，相比于汇编语言也应该考虑C语言，从而简化移植过程。 4.2汇编语言 4.2.1优势 汇编语言作为一种抽象程度较低的，比较原始的编程语言，其优点在于好的汇编程序员可以使程序占用更少的空间、发挥更好的效率，以及它可以支持CPU的全部特性两方面。相比与高级语言编译生成的汇编代码而言，由熟练的汇编程序员所编写的代码往往可以减少各种不必要的操作，更加充分地使用各种数据，并通过各种技巧来提高程序的效率，进而使相同功能的汇编代码有着更高的效率。另外，汇编代码中可以应用无法直接在高级语言中使用的CPU的特性，从而使汇编代码在某些场合下相比于高级语言程序有着更好的功能性，极大提高特定工作的效率。 4.2.2劣势 汇编语言也有自己的劣势，具体表现为以下几个方面：汇编语言相比于C语言需要对计算机底层的知识有更加充分的掌握，否则很难编写出优质的汇编代码，另外，想要编写出比高级语言效率更高的代码，需要程序员大量的经验，上手难度较高。汇编语言需要对每一步机器运行过程进行编写，需要消耗程序员大量精力，同时也使程序的开发效率极大降低。汇编语言往往在不同架构的CPU上有不同的具体指令，将程序从一个平台向另一个平台需要进行大量工作，甚至完全重写代码，可移植性极差。 4.2.3应用场景 当编写计算机操作系统时，其最基本的功能应提供汇编语言实现，从而提高效率。当编写效率要求较高、功能性较强、存储空间较少的程序时，应使用汇编语言实现。当编写高级语言的解释器、系统函数库等高级语言基本组件时，应用汇编语言实现，以提高效率。当编写特殊环境下的嵌入式设备时，应使用汇编语言编写以最大可能避免各种问题。 4.3总结 C语言与汇编语言的各种特性决定了不可能有某一方完全代替另一方。当要求开发速度快、可以移植性强、学习简单，但对运行效率没有极度追求，程序功能性也不需要太强，例如通常的软件编写等情况下，C语言无疑为更好的选择；而在要求运行效率高，程序功能性强，但对开发效率、可移植性没有太高要求时，例如航天设备软件编写等情况下，汇编语言无疑更加实用。总的来说，C语言主要应用于抽象程度较高的领域，而汇编应用主要应用于抽象程度较低的领域。所以，无论是汇编语言还是C语言都有着其各自的用武之地，两种语言均需要培养相应的人才。 参考文献 [1]C语言运算符优先级（超详细）：http://blog.csdn.net/huangblog/article/details/8271791[2]ATT汇编语言格式：https://max.book118.com/html/2017/0906/132304926.shtm[3]第二部分ATT汇编语言：https://wenku.baidu.com/view/4bb1dad9777f5acfa1c7aa00b52acfc788eb9f6e.html[4]百度百科-汇编语言：https://baike.baidu.com/item/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/61826?fr=aladdin#5_1 本文为作者原创，部分内容表述可能并不准确，请读者仅将本文作为一份参考，若发现错误请酌情提醒本人改正另附本人关于本次大作业所上交实验代码的下载网址 
第405篇文章[]
软件构造复习笔记(3) 注：文章中带有*的标题表示往年考试中出现过相应考点 文章目录 第七章面向对象的编程(OOP)1基本概念：对象、类、属性、方法*2接口和枚举*4封装和信息隐藏*5继承和重写*Overriding*抽象类 6多态、子类型、重载*9动态分派10一些Java中的重要对象方法*11设计好的类*12OOP历史 第八章ADT和OOP中的“等价性”1等价关系*2不可变类型的等价性3==和equal()*4实现equal()5对象契约*6可变类型的等价性7自动封装和等价性 第九章面向复用的软件构造技术1什么是软件复用2如何度量可复用性3可重用部件的等级和形态5设计可复用类*Liskov替代原则(LSP)*委派和组成* 6设计系统级可复用API库和框架 第七章面向对象的编程(OOP) 1基本概念：对象、类、属性、方法* 对象：是状态和行为的组合状态-对象中所包含的数据-类中的实例变量行为-对象所支持的行为-类中的实例方法 类：每个对象都属于某个类，方法定义了类型和实现类成员变量：一个和类相关而非类的实例相关的变量-静态成员变量类方法：之和类相关的方法-静态方法 注：本节为基础知识，需要掌握 2接口和枚举* 接口(Interface)：一个方法声明的列表，不包含方法体，可以由类实现接口间可以继承和扩展一个类可以实现多个接口(从而具备了多个接口中的方法)一个接口可以有多种实现类 接口-确定ADT规范，类-实现ADT可以不需要接口直接使用类作为ADT，既有ADT定义也有ADT实现但实际中更倾向于使用接口来定义变量 打破了抽象边界，接口定义中没有包含constructor，也无法保证所有实现类中都包含了同样名字的constructor。 故而，客户端需要知道该接口的某个具体实现类的名字。可以提供静态工厂方法而非构造函数来向客户端提供具体实现类。 接口中每个方法都需要在所有实现它的类中实现可以通过default关键字修饰方法，在接口中统一实现某些功能，无需在各个类中重复实现它以增量式的为接口增加额外的功能而不破坏已实现的类 枚举：注：本节了解一下接口就行了 4封装和信息隐藏* 信息隐藏：区分模块设计好坏的唯一最重要的因素是它对其他模块隐藏内部数据和其他实现细节的程度，设计良好的代码应该能隐藏全部实现细节 通过接口进行信息隐藏：1.使用接口类型声明变量2.客户端仅使用接口中定义的方法3.客户端代码无法直接访问属性 权限修饰符：private：只能在类内部进行使用protected：可以在其子类及同个包中的其他类中使用public：在所有类中都可以使用 信息隐藏策略：1.认真设计API2.只提供客户端需要的功能，其他所有成员都应该是private的3.你可以在不破坏客户端的情况下将任何一个private成员修饰为public 注：本节需要了解权限修饰符的功能 5继承和重写* Overriding* 可重写的方法：未加final修饰的方法都可以在子类中重写，即在子类中将该方法重写实现，重写的方法有着和原方法完全相同的声明，实际执行时调用哪个方法，在运行时决定 严格继承：子类只能添加新的方法，无法重写超类中的方法如果一个方法不能被重写，那它一定以final修饰 通产override的方法都需要在方法声明前添加@override final作用：1.变量-使变量在初始化后不能再改变取值2.方法-避免子类中重写该方法3.类-避免该类被继承 重写时，可以使用super()复用父类中函数的功能，并在后续代码中进行拓展重写时，不要改变原方法的本意 抽象类 抽象方法：存在有声明，但没有实现的方法，这个方法由abstract关键字修饰抽象类：存在至少一个抽象方法的类，该类必须由abstract关键字修饰，抽象类不能被实例化 接口可以被认为是只有抽象方法的抽象类 如果某些操作是所有子类型都共有，但彼此有差别，可以在父类型中设计抽象方法，在各子类型中重写。所有子类型完全相同的操作，放在父类型中实现，子类型中无需重写。有些子类型有而其他子类型无的操作，不要在父类型中定义和实现，而应在特定子类型中实现。 注：继承、重写是重要概念，必须掌握 6多态、子类型、重载* 三种多态类型：特殊多态-函数重载参数化多态-泛型子类型多态、包含多态-多个子类继承某父类 重载(Overload)：多个方法具有同样的名字，但有不同的参数列表或返回值类型价值：方便客户端使用，客户端可用不同的参数列表，调用同样的函数重载时一种静态多态：进行静态类型检查，根据参数列表进行最佳匹配，在编译阶段时决定要具体执行哪个方法 重载规则：1.必须有不同的参数列表2.可以有相同/不同的返回值类型3.可以有相同/不同的权限修饰符4.可以有新的或更广泛的检查异常5.可以在同一个类内重载，也可以在子类中重载 重写(Override)则是在运行时进行动态检查，根据内存中对象的具体类型来调用对应方法泛型：以泛型方式定义函数和类型，以便基于运行时传递的参数工作，即允许静态类型化而不完全指定类型。 泛型编程：是一种编程风格，其中数据类型和函数用稍后指定的类型编写，然后在需要时对作为参数提供的特定类型进行实例化。 类型变量：未指定的变量类型泛型类：类定义中包含了类型变量泛型接口：接口定义中包含了类型变量泛型方法：方法定义中包含了类型变量 泛型的其他性质：子类型：若B是A的子类型，意味着每一个B类型的变量都可以被当作A类型B是A的子类型当且仅当B的Spec至少和A一样强，子类型的规约不能弱化父类型的规约 子类型多态：不同类型的对象可以统一的处理而无需区分 注：重载、重写应该掌握，泛型应该了解一下，子类型多态需要注意对子类型spec的要求 9动态分派 动态分派：确定要在运行时调用的方法，即在运行时解析对已覆盖或多态方法的调用静态分派：重载的方法使用静态绑定绑定，而重载的方法在运行时使用动态绑定绑定。 10一些Java中的重要对象方法* equals方法：当两个对象等价时返回true，应满足对称、自反、传递的性质hashCode方法：返回在哈希映射中使用的哈希代码toString方法：返回一个可打印的字符串表示注：应重点关注equal方法 11设计好的类* 不可变类的优点：简单、固有线程安全、可以自由共享、不需要防御拷贝、优秀的构建块 如何写不可变类：1.不提供任何mutator2.确保方法都不会被重写3.使所有变量均被final修饰4.使所有变量均被private修饰5.确保任何可变类型的组成部分的安全性(避免表示泄露)6.实现toString()、hashCode()、equals()等方法 注：需要学会怎么设计不可变的类 12OOP历史 第八章ADT和OOP中的“等价性” 1等价关系* ADT是对数据的抽象，体现为一组对数据的操作抽象函数AF：内部表示->抽象表示基于抽象函数AF定义ADT的等价操作 等价关系：自反、对称、传递注：需要理解什么是等价关系 2不可变类型的等价性 如果AF映射到相同的结果，则等价站在外部观察者的角度，对两个对象调用任何相同的操作，都会得到相同的结果，则认为两个对象是等价的，反之亦然 3==和equal()* ==运算符比较的是对象的引用，两个对象指向同一个内存空间时，则说明这两个对象具有引用等价性equal()方法比较的是对象的内容，即对象等价性 在自定义ADT时，需要重写Object的equals() ==通常用于对基本数据类型判断是否相等，equal()用于判断对象类型是否等价 注：需要了解如何区分两者区别 4实现equal() 在Object中缺省equals()是在判断引用等价性，所以一般需要重写 equal方法如果接受的参数不是Object类型则实现不是override而是overload instanceof运算符可以判断某一变量所指向内存是否属于某各类型(动态检查) 5对象契约* equal方法满足的契约：1.等价关系：自反、对称、传递2.除非对象被修改了，否则调用多次equals应有同样的结果3.对于非null引用x，x.equals(null)应返回false4.等价的对象，其hashCode()的结果必须相同 哈希表：等价的对象必须有相同的hashCode，但不等价的对象也可以有相同的hashCode，不够性能会变差 重载hashCode()：注：主要关注equals()方法 6可变类型的等价性 观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致行为等价性：调用对象的任何方法都展示出一致的结果，可以认为就是引用等价性 对可变类型来说，往往倾向于实现严格的观察等价性，但有时候观察等价性可能导致bug，甚至可能破坏RI 在hashSet等类型中，其内部的可变数据类型发生改变时，hashCode会改变，导致hashSet的contains方法会判断集合中改变过的内容不属于集合 7自动封装和等价性 第九章面向复用的软件构造技术 1什么是软件复用 软件复用是使用现有软件组件实现或更新软件系统的过程 软件复用的两个视角：1.面向复用编程(Creation)：开发出可复用的软件2.基于复用编程(Use)：利用已有的可复用软件搭建应用系统 复用好处：1.降低成本和开发时间2.经过充分测试，可靠、稳定3.标准化，在不同应用中保持一致 2如何度量可复用性 从以下几个角度度量：1.复用的机会有多频繁？复用的场合有多少？2.复用的代价有多大？ 3可重用部件的等级和形态 最主要的复用是在代码层面，但软件构造过程中的任何实体都可能被复用-需求、设计/规约、数据、测试用例、文档 白盒复用：源代码可见，可修改和拓展-复制已有代码到正在开发的系统，进行修改优点：可定制化程度高缺点：对其修改增加了软件的复杂度，且需要对其内部充分的了解 黑盒复用：源代码不可见，不能修改-只能通过API接口来使用，无法修改代码优点：简单、清晰缺点：适应性差些 复用一个类的方法：1.继承：子类可以对父类中的属性、方法等进行复用2.委派：在一个类中使用其他类的方法来实现自己的功能 框架：一组具体类、抽象类、及其之间的连接关系开发者根据framework的规约，填充自己的代码进去，形成完整系统 白盒框架：通过代码层面的继承进行框架拓展黑盒框架：通过实现特定接口/delegation进行框架拓展 5设计可复用类* Liskov替代原则(LSP)* 子类型多态：客户端可用统一的方式处理不同类型的对象在Java中的编译器强制执行的规则：1.子类型可以增加方法，但不可以删2.子类型中需要实现抽象类型中的所有未实现方法3.子类型中重写的方法必须返回相同的类型或其子类型(满足协变)4.子类型中重写的方法必须接收相同的参数类型(满足逆变)5.子类型中重写的方法不能抛出额外的异常 LSP原则：子类方法必须相比于父类方法有着相同或更强的不变量，相同或更弱的前置条件，相同或更强的后置条件，才能使子类无条件地可以替代父类。LSP是子类型关系的一个特殊定义，称为（强）行为子类型 LSP依赖于以下限制：1.前置条件不能强化2.后置条件不能弱化3.不变量要保持4.子类型方法参数：逆变5.子类型方法返回值：协变6.异常类型：协变 协变：随着父类型到子类型越来越具体，对于返回值类型而言，不变或变得更具体，异常的类型也是如此逆变：随着父类型到子类型越来越具体，参数类型会相反地变化，要不变或者越来越抽象(目前Java中这种情况会被视作overload) 数组是协变的：根据Java的子类型规则，一个类型T的数组可以容纳类型T和其子类型的变量 泛型不是协变的，ArrayList是List的子类型，但List不是类型List的泛型 泛型中的通配符： 委派和组成* 以排序为例，如果你的ADT需要比较大小，或者要放入Collections或Array进行排序，可实现Comparator接口构建比较器并overridecompare方法或者实现Comparable接口拓展ADT并overridecompareTo方法(不需要构建新的Comparator类，比较代码防止ADT内部) 上述例子中，Comparator属于delegation，而Comparable不属于delegation 委派：一个对象请求另一个对象的功能，委派是代码复用的一种常见形式 显式委派：将发送对象传递给接收对象隐式委派：通过成员查找规则 委派模式：通过运动时动态绑定，实现对其他类中代码的动态复用 委派和继承：继承通过拓展基类来添加新操作或重写某操作委派通过捕捉某个行为，并将其发送给另一个对象很多设计模式都使用两者组合 如果子类只需要复用父类中的一小部分方法，则可以不需要使用继承，而是通过委派机制来实现一个类不需要继承另一个类的全部方法时，可以通过委派机制调用部分方法，从而避免大量无用方法 委托发生在object层面，而继承发生在class层面 组合复用原则(CRP)：类应该通过其组合（通过包含实现所需功能的其他类的实例）来实现代码重用，而不是从基类或父类继承来实现多态行为和代码重用。 CRP原则的思路：1.使用接口定义系统必须对外展示的不同侧面的行为2.接口之间通过extends实现行为的扩展（接口组合）3.类implements组合接口，从而规避了复杂的继承关系 delegation的类型：1.Dependency:临时性的delegation(作为方法的参数使用)Dependency：对象需要其他对象（供应者）才能实现的临时关系2.Assosiation:永久性的delegation(作为对象的属性使用)Assosiation：对象类之间的持久关系，允许一个对象实例代表另一个对象实例执行操作。3.Composition:更强的assosiation，但难以变化(属性通过内部各方法进行初始化、修改等)Composition：是一种将简单的对象或数据类型组合成更复杂的数据类型的方法4.Aggregation:更弱的assosiation，可动态变化(属性通过外部方法进行修改)Aggregation：对象存在于另一个外部，在外部创建，因此它作为参数传递给解释器。这四种类型都支持一对多的delegation注：本节为重点，需要理解LSP、CRP、继承、委派等概念的含义，并会分析及写相应代码 6设计系统级可复用API库和框架 库：提供可复用功能的类和方法的集合 
第406篇文章[]
软件构造复习笔记(1) 注：文章中带有*的标题表示往年考试中出现过相应考点 文章目录 第一章软件构造的多维度视图和质量目标1多维度软件视图*Build-timeview-构造阶段-编写代码过程Runtimeview-运行阶段-程序运行过程 2软件构造：视图间的转换3软件系统的质量属性*外部质量因素*内部质量因素折中 4软件构造五大关键质量目标 第二章软件测试与测试优先的编程1软件测试*2测试用例3测试优先的编程*4单元测试5使用JUnit的自动单元测试6黑盒测试*等价类划分边界值分析两个极端的划分覆盖策略 7白盒测试8测试的覆盖度*9自动测试和回归测试10测试策略* 第三章软件构造过程与配置管理1软件开发生命周期(SDLC)2传统软件流程模型![在这里插入图片描述](https://img-blog.csdnimg.cn/20210705212556877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dzAxMDAwMTM0,size_16,color_FFFFFF,t_70)3敏捷开发4软件配置管理(SCM)和版本控制系统(VCS)*5SCM工具例子：Git*6软件构造的总体流程 第一章软件构造的多维度视图和质量目标 1多维度软件视图* Build-timeview-构造阶段-编写代码过程 Code-levelview-代码的逻辑组织-函数、类、方法、接口等Component-levelview-代码的物理组织-文件、路径、包、库等 Momentview-特定时刻的软件形态-特定时间Periodview-软件形态随时间的变化-一段时间 Runtimeview-运行阶段-程序运行过程 Code-levelview-逻辑实体在内存中如何呈现-内存状态Component-levelview-物理实体在物理硬件环境中如何呈现-物理环境 Momentview-逻辑/物理实体在内存/硬件环境中特定的形态如何-特定时间Periodview-逻辑/物理实体在内存/硬件环境中的形态随时间如何变化-一段时间 上述三类view共构成八种具体情况 代码快照图(Snapshotdiagram)：描述程序运行时内存里变量层面的状态 注：本节需要记住各操作对应八种维度中的哪个 2软件构造：视图间的转换 3软件系统的质量属性* 外部质量因素* 外部质量因素：例如使用的速度或难易程度等质量，其在软件产品中的存在或缺失可以被其用户检测到外部质量因素影响用户 外部质量因素包括：1.正确性：程序能按照预先定义的规约执行，正确性是最重要的质量指标。每一层保证自己的正确性，同时假设其下层是正确的。 2.健壮性：针对异常情况的处理，出现异常时不要崩溃 3.可拓展性：为了应对未来可能的变化 4.可复用性：一次开发，多次使用 5.兼容性：不同的软件系统之间相互可容易的集成 6.高效性：性能毫无意义，除非有足够的正确性，过早优化时万恶之源 7.可移植性：软件可方便的在不同的技术环境之间移植 8.易用性：容易学、安装、操作、监控 9.功能性：提供未来可能需要的功能，每增加一小点功能，都确保其他质量属性不受到损失 10.及时性：用户需要前，软件系统能及时发布 11.其他：可验证性、完整性、可修复性、经济性 注：本节只需要记住几个外部特性即可 内部质量因素 内部质量因素：适用于软件产品的其他质量，如模块化或可读性，是内部因素内部质量因素影响软件本身和它的开发者 复杂性是几乎任何外部质量因素的敌人！内部质量因素通常用作外部质量因素的部分测量。只有外部质量重要，但外部质量取决于内部质量。 折中 正确的软件开发过程中，开发者应该将不同质量因素之间如何做出折中的设计决策和标准明确的写下来 虽然需要折中，但“正确性”绝不能与其他质量因素折中。 最重要的几个质量因素：正确性、健壮性-可靠可拓展性、可复用性-模块化 4软件构造五大关键质量目标 可理解性：可复用性：可维护性和可适应性：健壮性：性能表现： 第二章软件测试与测试优先的编程 1软件测试* 软件测试：提高软件质量的重要手段，用来寻找程序bug、检查程序是否满足使用要求，确认程序是否到达可用级别(用户需求)。关注系统的某一侧面的质量特性。 测试跟其他活动的目标相反：破坏、证错 即使是最好的测试程序也无法达到100%无错误，再好的测试也无法证明系统里不存在错误。 好的测试：能发现错误、不冗余、最佳特性、别太复杂也别太简单 测试层次：静态测试：不需要运行程序，例如检查代码动态测试：描述代码的动态行为，需要运行在给定的集合或测试集合上 测试与调试：测试-发现是否存在错误，调试-识别错误根源，消除错误 白盒测试：对程序内部代码结构的测试黑盒测试：对程序外部表现出来的行为的测试 注：本节只考过选择题，而且比较简单，简单看一遍就行了 2测试用例 测试用例：输入+执行条件+期望结果 好的测试用例的特性：最可能发现错误、不重复、不冗余、最有效、即不简单也不复杂 3测试优先的编程* 在写代码前写测试用例 过程：1.先写spec2.再写符合spec的测试用例3.写代码、执行测试、有问题再改、再执行测试用例、直到通过它 Spec：描述函数的输入和输出行为它给出了参数的类型和对它们的任何附加约束条件。它也给出了返回值类型以及返回值如何与输入相关联在代码中，规范由方法声明和上面描述它所做什么的注释组成。 注：本节内容需要理解Spec是什么 4单元测试 单元测试：针对软件的最小单元模型开展测试，隔离各个模块，容易定位错误和调试 对每个函数的spec编写测试用例，每个测试都应该包括一组预期结果 5使用JUnit的自动单元测试 需要记住的方法：assertEquals、assertTrue、assertFalse 6黑盒测试* 黑盒测试：用于检查代码的功能，不关心内部实现细节 黑盒测试寻找以下类型的错误：1.不正确或缺失的函数2.接口错误3.数据结构或外部数据库使用错误4.行为错误5.初始化和终止错误 黑盒测试的测试用例：为了检查程序是否符合规约，用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误 等价类划分 基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。针对每个输入数据需要满足的约束条件，划分等价类每个等价类代表着对输入约束加以满足/违反的有效/无效数据的集合 基于的假设：相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为测试用例即可 边界值分析 大量的错误发生在输入域的“边界”而非中央 边界值分析方法是对等价类划分方法的补充，在等价类划分时，将边界作为等价类之一加入考虑 两个极端的划分覆盖策略 笛卡尔积：全覆盖多个划分维度上的多个取值，要组合起来，每个组合都要有一个用例并非所有组合情况都可能 测试完备，但用例数量多，测试代价高 覆盖每个取值：最少一次即可每个维度的每个取值至少被1个测试用例覆盖一次即可 测试用例少，代价低，但测试覆盖度未必高 注：本节容易考根据spec写测试用例 7白盒测试 黑盒测试完全从函数spec导出测试用例，不考虑函数内部实现 白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例 白盒测试一般较早执行 独立/基本路径测试：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试用例使每一条基本路径被至少覆盖1次。 8测试的覆盖度* 代码覆盖度：已有的测试用例有多大程度覆盖了被测程序 代码覆盖度越低，测试越不充分，但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高 常用工具：EclEmma 注：本节只在选择题的某个选项中考过EclEmma 9自动测试和回归测试 自动测试：自动调用被测函数、自动判定测试结果、自动计算覆盖度只是“测试用例的自动执行”，并非“自动生成测试用例” 回归测试：一旦程序被修改，重新执行之前的所有测试 一旦发现bug，要马上写一个可重现该bug的测试用例，并将其加入测试库 常用工具：ContinuousIntegration、TravisCI 10测试策略* 测试策略(根据什么来选择测试用例)非常重要，需要在程序中显式记录下来 目的：在代码评审过程中，其他人可以理解你的测试，并判断你的测试是否足够充分 注：本节需要学会怎么写测试策略 第三章软件构造过程与配置管理 1软件开发生命周期(SDLC) 2传统软件流程模型 3敏捷开发 敏捷开发：通过快速迭代和小规模的持续改进，以快速适应变化。 Agile=增量+迭代每次迭代处理一个小规模增量 4软件配置管理(SCM)和版本控制系统(VCS)* 软件配置管理：追踪和控制软件的变化 软件配置项(SCI)：软件中发生变化的基本单元（例如：文件） 基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本） 配置管理数据库(CMDB)：存储软件的各配置项随时间发生变化的信息+基线 版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识” 仓库：即于SCM中的CMDB 工作拷贝：在开发者本地机器上的一份项目拷贝 文件：一个独立的配置项 版本：在某个特定时间点的所有文件的共同状态 变化：即codechurn，两个版本之间的差异 HEAD：程序员正在其上工作的版本 本地版本控制系统：仓库存储于开发者本地机器无法共享和协作 集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作 分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器 注：本节只在选择题中考过SCI、SCM的概念 5SCM工具例子：Git* Git视图：Git仓库包括以下三个部分：.git文件：本地的CMDB工作目录：本地文件系统暂存区：隔离工作目录和Git仓库 每个文件都处于下列三种状态之一：Modified：已修改Staged：已暂存Committed：已提交Git的对象图： Git存储发生变化的文件本身，而不是变化的代码行文件未发生变化，则后续多个版本始终指向同一个文件文件发生变化了，存储两份不同的文件，两个版本指向不同的文件gitpush、gitpull：向/从远程服务器发送/接受对象图 分支、合并：gitcheckout-bA新建分支Agitcheckout-dA删除分支AgitcheckoutA切换到分支AgitmergeA将当前分支与A合并注：本节考过git所对应的SCM各部分、git的指令等 6软件构造的总体流程 
第407篇文章[]
软件构造复习笔记(4) 注：文章中带有*的标题表示往年考试中出现过相应考点 文章目录 第十章面向可维护性的构造技术1软件可维护性和演化2可维护性的指标3模块化设计和模块化原则4OO设计原则：SOLID*单一责任原则(SRP)开放-封闭原则(OCP)Liskov替换原则(LSP)接口隔离原则(ISP)依赖转置原则(DIP) 5语法驱动的构造*语法的构成要素语法中的运算*语法中的递归分析树正则语法和正则表达式* 第十一章面向可复用性和可维护性的设计模式1创建模式*2结构模式*适配器模式(AdapterPattern)装饰器模式(Decorator) 3行为模式*策略模式(Strategy)模板模式(TemplateMethod)迭代器模式(Iterator)访问器模式(Visitor) 4设计模式的共性与差异* 第十二章面向正确性与健壮性的软件构造1什么是健壮性和正确性？2如何量度健壮性和正确性3Java中的Error和Exception*4异常处理*5断言6防御式编程7SpotBugs工具 第十章面向可维护性的构造技术 1软件可维护性和演化 软件维护：修复错误、改善性能 主要步骤：1.测试所做的修改2.回归测试3.记录变化 除了修复问题，修改中不能引入新的故障最大的问题：修改后没有足够的文档记录和测试 软件可维护性的类型：软件演化：对软件进行持续的更新，软件的大部分成本来自于维护阶段 软件维护不仅仅是运维工程师的工作，而是从设计和开发阶段就开始了在设计与开发阶段就要考虑将来的可维护性 面向可维护性的构造技术：1.模块化设计2.OO设计原则3.OO设计模式4.基于状态的构造技术5.表驱动的构造技术6.基于语法的构造技术 2可维护性的指标 可维护性：软件系统或组件易于修改以纠正故障、提高性能或其他属性，或适应已改变的环境”。 可拓展性：软件设计/实施考虑到未来的增长，可拓展性被视为扩展系统能力和实施扩展所需努力水平的系统衡量。 灵活性：软件根据用户需求、外部技术和社会环境等而轻松改变的能力。 可适应性：交互系统（自适应系统）的能力，可以根据获取的用户及其环境信息来适应个别用户的行为。 可管理性：监控和维护软件系统的效率和容易，以保持系统运行、安全和平稳运行。 支持性：基于包括质量文档、诊断信息和知识渊博的技术人员的资源，在部署后软件如何有效地运行。 HalsteadVolume:基于源代码中（不同的）运算符和操作数数量的复合度量。 3模块化设计和模块化原则 目的：将系统划分为模块，并用一种模块内高内聚，模块间低耦合的方式分配各模块的职责 模块化降低了程序员在任何时候都必须处理的总复杂性，做到分离关注点和信息隐藏 评估模块性的五个标准：1.可分解性(Decomposability)：较大的组件是否已分解为较小的组件2.可组合性(Composability)：较大的组件是否可以由较小的组件构成3.可理解性(Understandability)：组件是否可以单独理解4.可持续性(Continuity)：对规约的小改变是否只影响本地优先数量的组件5.出现异常之后的保护(Protection)：运行时异常的影响是否局限于少量的相关组件 五个模块化设计的规则：1.直接映射(DirectMapping)2.尽可能少的接口(FewInterfaces)3.尽可能小的接口(SmallInterfaces)4.显式接口(ExplicitInterfaces)5.信息隐藏(InformationHiding) 耦合性：耦合是衡量模块之间依赖关系的度量方法模块间耦合性程度由模块之间的接口数量和每个接口的复杂性决定(复杂性由通信的类型决定) 内聚性：是衡量模块功能或责任的紧密相关的标准，如果一个模块的所有元素都在朝着相同的目标工作，那么该模块就具有很高的内聚性 好的设计需要高内聚，低耦合，但有时需要折中，耦合程度高时，内聚内聚程度倾向于变低，反之亦然 4OO设计原则：SOLID* SOLID：五大类的设计原则TheSingleResponsibilityPrinciple单一责任原则(SRP)TheOpen-ClosedPrinciple开放-封闭原则(OCP)TheLiskovSubstitutionPrincipleLiskov替换原则(LSP)TheDependencyInversionPrinciple依赖转置原则(DIP)TheInterfaceSegregationPrinciple接口聚合原则(ISP) 单一责任原则(SRP) SRP:不应该有多于1个原因让你的ADT发生变化，否则就拆分开；一个类，一个责任责任：变化的原因 如果一个类包含了多个责任，那么将引起不良后果：1.引入额外的包，占据资源2.导致频繁的重新配置、部署等 开放-封闭原则(OCP) 开放：对拓展性的开发，模块的行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化 封闭：对修改的封闭，模块自身的代码是不应被修改的；扩展模块行为的一般途径是修改模块的内部实现；如果一个模块不能被修改，那么它通常被认为是具有固定的行为 关键的解决方案：抽象技术 “软件实体（类、模块、功能等）。应该开放扩展，但关闭修改”，即使用继承和组合/委托更改类的行为 Liskov替换原则(LSP) LSP：子类型必须能够替换其基类型派生类必须能够通过其基类的接口使用，客户端无需了解两者之间的差异 接口隔离原则(ISP) ISP：不能强迫客户端依赖于他们不需要的接口，只提供必需的接口 不要用许多方法污染接口，避免臃肿的接口，客户端不应该被强迫依赖他们不需要的方法接口属于客户端，而不是体系结构 接口臃肿的类是接口不够聚合的类，胖接口可以分解为多个小接口；不同的接口向不同的客户端提供服务；客户端只访问自己所需要的接口 图示： 依赖转置原则(DIP) DIP：抽象的模块不应该依赖于具体的模块，具体的模块应该依赖于抽象的大部分的接口和抽象都应该被使用 delegation时，要通过接口建立联系，而非具体子类注：本节SOLID五个原则都应该了解 5语法驱动的构造* 语法的构成要素 有一类应用，从外部读取文本数据，在应用中做进一步处理。特定的，字节或字符序列应该有如下特性：1.输入文件有特定格式，程序需读取文件并从中抽取正确的内容2.从网络上传输过来的信息，遵循特定的协议3.用户在命令行输入的指令，遵循特定的格式4.内存中存储的字符串，也有格式需要 通常使用语法分析来判断字符串是否合法，并解析成程序里使用的数据结构，且这个数据通常是一个递归的数据结构 一个语法定义了一个字符串集合语法中的文字字符串被称作终止节点，他们是语法解析树的叶节点，无法再向下扩展，通常被表示为字符串 一个语法由一个产生式节点的集合描述，其中每一个产生式都定义了一个非终止节点，并遵循特定规则，利用操作符、终止节点和其他非终止节点，构造新的字符串，非终止节点是树中表示字符串的内部节点 一个语法中的产生式有如下形式：nonterminal::=expressionofterminals,nonterminals,andoperators 根节点：是一个语法中的非终止节点，语法识别出的字符串集合中都是与根节点匹配的字符串 语法中的运算* 三种基本语法运算：连接(Concatenation)-x::=yz-x匹配y后接z的字符串重复(Repetition)-x::=y*-x匹配零个或多个y选择(Union)-x::=y|z-x要么匹配y要么匹配z 运算优先级：1.通常情况下，前缀运算符*,?,+有最高的运算优先度2.连接其次3.选择优先度最低但圆括号可以被用作修改优先级，括号内的优先运算 其他语法运算符：可选(Optional)-x::=y+-x要么是y要么为空一次或多次出现-x::=y+-x是一个或多个y的连接一个字符类-x::=[…]-表示包含方括号中列出的任何字符的长度为1的字符串,例如x::=[a-c]等价于x::=‘a’|‘b’|‘c’一个倒置的字符类-x::=[^…]-表示包含括号中未列出的任何字符的长度为1的字符串，例如x::=[^a-c]等价于x::=‘d’|‘e’|‘f’|… 语法中的递归 分析树 分析树：根据语法匹配将一个字符串生成一个能显示字符串中的各部分如何和语法中各部分联系起来的树树的叶节点标记着终止符号，代表已经被分析完的字符串部分，如果从左到右将叶节点连接，将获得原字符串 正则语法和正则表达式* 正则语法：简化之后可以表达为一个产生式而不包含任何非终止节点 正则表达式：终端和运算符的约简表达式可以写成一种更紧凑的形式，称为正则表达式。正则表达式会去掉了终端周围的引号以及终端和运算符之间的空格，因此它只由终端字符、用于分组的括号和运算符字符组成。 一些正则表达式的运算：.-任意字符\d-任意数字\s-任意空白符\w任意有意义的字符，相当于[a-zA-Z_0-9].()*+…-表示反斜杠后的字符 注：本节只需要学会正则表达式即可 第十一章面向可复用性和可维护性的设计模式 1创建模式* 工厂方法，也被称作虚拟构造器，当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。可以定义一个用于创建对象的接口，让其子类来决定实例化哪个类，从而使一个类的实例化延迟到其子类 带有工厂方法的类也可以实现其他功能有新的具体产品类加入时，可以在工厂类里修改过增加新的工厂函数(OCP)，不会影响客户端代码客户端使用工厂方法来创建实例，得到的实例的类型是抽象接口而非具体类根据类型决定创建哪个具体产品 优点：消除了将特定于应用程序的类绑定到代码的需要。代码仅处理产品接口，因此它可以处理任何用户定义的具体产品 潜在缺点：客户可能必须创建构造类的子类，以便他们可以创建特定的产品。 注：本节了解一下就行 2结构模式* 适配器模式(AdapterPattern) 将某个类/接口转换为客户端期望的其他形式，适配器使由于不相容的接口导致本不能一起使用的类可以一起使用。一般通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。 装饰器模式(Decorator) 装饰器用于为对象添加不同侧面的特性，对于每一个特性构造子类，通过委派机制增加到对象上装饰器使用了子类型和委派 Collections.unmodifiedSet等通过装饰器实现，修改原数据依然会导致所得到的添加特性后的对象改变客户端需要一个具有多种特性的object，可以通过一层一层的装饰来实现注：本节需要简单理解一下 3行为模式* 策略模式(Strategy) 问题：有多种不同的算法来实现同一个任务，但需要客户端根据需要动态切换算法，而不是写死在代码中 实现方法：为不同的实现算法构造抽象接口，利用delegation，运行时动态传入客户端倾向的算法实例 优点：易于扩展到新的算法实现将算法与客户端上下文进行分离 模板模式(TemplateMethod) 问题：做事情的步骤一样，但具体方法不同 实现方法：共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现 模板模式使用继承和重写方法组合的策略来实现 迭代器模式(Iterator) 问题：客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型 解决方案：一种专为迭代的策略模式 作用：1.隐藏底层容器的内部实现2.支持具有统一接口的多个遍历策略3.易于更改容器类型4.促进项目各部分之间的沟通 Iterable接口：实现该接口的集合对象是可迭代遍历的Iterator接口：迭代器 迭代器模式：让自己的集合实现Iterable接口，并实现自己的独特Iterator迭代器，允许客户端利用这个迭代器进行显示或隐式的迭代遍历： 访问器模式(Visitor) Visitorpattern：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类本质上：将数据和作用于数据上的某种/些特定操作分离开 效果：为ADT预留一个将来可拓展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT 只要更换visitor的具体实现，即可切换算法 注：本节内容都比较重要，需要会根据各种设计模式写代码 4设计模式的共性与差异* 共性样式1：只使用继承，不使用委派核心思路OCP/DIP，依赖反转，客户端只依赖“抽象”，不能依赖于”具体“发生变化时最好是扩展，而非修改 代表：Adaptor、Template共性样式2：注：本节需要理解 第十二章面向正确性与健壮性的软件构造 1什么是健壮性和正确性？ 健壮性(Robustness)：系统在不正常输入或不正常外部环境下仍能够表现正常的程度 面向健壮性的编程：1.处理未期望的行为和错误终止2.即使终止执行，也要准确/无歧义的向用户展示全面的错误信息3.错误信息有助于debug 健壮性原则：1.总是假定用户恶意，假定自己的代码可能失败2.把用户想象成白痴，可能输入任何东西3.对别人宽容点，对自己狠一点对自己的代码要保守，对用户的行为要开放 健壮性编程的原则：1.封闭实现细节，限定用户的恶意行为2.考虑极端情况，没有不可能 正确性(Correctness)：程序按照spec加以执行的能力，是最重要的质量指标 正确性-永不给用户错误的结构健壮性-尽可能保持软件运行而不是总是退出正确性倾向于直接报错(error)，健壮性则倾向于容错(fault-tolerance) 健壮性：让用户变得更容易：出错也可以容忍，程序内部已有容错机制正确性：让开发者变得更容易：用户输入错误（不满足precondition的调用），直接结束。 对外的接口，倾向于健壮；对内的实现，倾向于正确 安全关键型应用程序相比于健壮性倾向于支持正确性消费者的应用程序相比于正确性倾向于支持健壮性 可靠性(Reliability)：系统在规定条件下执行其所需功能的能力-故障之间的平均时间长度。Reliability=Robustness+Correctness 提高健壮性和正确性的步骤：0.使用断言、防御性编程、代码审查、正式验证等来编写具有健壮性和正确性的代码1.观察故障症状（内存转储、堆栈跟踪、执行日志、测试）2.识别潜在的故障（错误定位、调试）3.修复错误（代码修订） 2如何量度健壮性和正确性 外部观察角度：Meantimebetweenfailures平均失效间隔时间(MTBF)：系统运行过程中系统固有故障之间的预期运行时间。MTBF描述了可修复系统的两次故障之间的预期时间，而meantimetofailure平均故障时间(MTTF)表示不可修复系统的预期故障时间。内部观察角度：残余缺陷率：每千行代码中遗留的bug数量 3Java中的Error和Exception* 内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结果异常：程序的问题，可以捕获、可以处理 Error种类：用户输入错误、设备错误、物理限制大多数情况下，Error不需要被实例化注：本节了解一下就行 4异常处理* 使用try-catch结构异常：程序执行中的非正常时间，程序无法再按预想的流程执行 Exception会将错误信息传递给上层调用者，并报告”案发现场“的信息Exception可以是return之外的第二种退出途径-当找不到异常处理程序时，整个系统会完全退出 异常可以被分为RuntimeException和其他类型运行时异常：由程序员在代码中处理不当造成，是程序源代码中引入的故障造成的，如果在代码中提前进行验证，则这些故障就可以避免 其他异常：由外部原因造成，是程序员无法完全控制的外在问题所导致的，即使在代码中提前加以验证(文件是否存在等)，也无法完全避免失效发生 当异常产生时，要么异常处理程序处理了异常，要么会告诉编译器无法处理该异常，并在命令行中输出错误信息。编译器可以帮助检查程序是否已经抛出或处理了可能的异常。 Error和RuntimeException并不被编译器进行检查， RuntimeException不需要在编译时用trycatch等机制处理，但执行时可能会导致程序失败，代表程序中的潜在bug-类似动态检查 而其他Exception则必须捕获并指定错误处理程序，否则编译无法通过-类似静态类型检查 Java中异常处理的关键字：try、catch、finally、throws、throwthrows：表明方法会抛出XX异常throw：抛出XX异常try、catch、finally：捕获并处理XX异常 Unchecked异常也可以使用throws声明或try/catch进行捕获，但大多数时候是不需要的，也不应该这么做-掩耳盗铃，对发现的编程错误充耳不闻 如果客户端可以通过其他的方法恢复异常，那么采用checkedexception；如果客户端对出现的这种异常无能为力，那么采用uncheckedexception；异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息 “异常”也是方法和client端之间spec的一部分，在post-condition中刻画 对于checkedexception，需要在方法声明后加throwsXX异常程序员必须在方法的spec中明确写清本方法会抛出的所有checkedexception，以便于调用该方法的client加以处理而uncheckedexception则不需要 若一个程序内部某方法可能抛出某checkedexception，则要么它内部有该异常的处理程序，要么它也声明会抛出异常，将异常移交给调用它的方法处理。若没有处理程序来处理checkedexception，程序将终止运行 程序员不应抛出Error，Error通常只指虚拟机或动态库的错误 子类型多态相关：1.如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛2.子类型方法可以抛出更具体的异常，也可以不抛出任何异常3.如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。 抛出异常方法：流程：1.找到到一个能表达错误的Exception类/或者构造一个新的Exception类2.构造Exception类的实例，将错误信息写入3.抛出它 一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码 构造异常类：对于checkedexception，只需要继承Exception类对于uncheckedexception，只需要继承RuntimeException类 异常处理程序：若某段代码中可能抛出异常，可以将这段代码包含在try代码块内，并使用catch捕获其抛出的各种异常。若在各catch代码段后有finally代码段，程序会在执行完catch代码段后执行finally代码段，另外，没有抛出异常时finally代码段也会被执行。 finally代码段通常用于清理异常发生前曾申请过的资源 重新抛出异常：catch代码段中也可以抛出异常目的：更改exception的类型，更方便客户端获取错误信息并处理调用栈追踪： 注：本节需要学会ava中的两类异常，并掌握他们区别，并掌握异常抛出、处理等相关代码的编写，还需要了解异常处理观察者控制的转移路径，以及异常导致程序退出时显示的的方法调用栈含义 5断言 断言：当不满足前提条件时，此代码通过抛出断言错误异常来终止程序。调用者的错误的影响无法传播。检查前置条件是防御式编程的一种典型形式 为什么要断言：在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误。 断言即是对代码中程序员所做假设的文档化，也不会影响运行时性能(在实际使用时，assertion都会被disabled)断言为了程序正确性，使用断言处理“绝不应该发生”的情况，如果来自于自己所写的其他代码，可以使用断言来帮助发现错误异常为了程序健壮性，使用异常来处理你“预料到可以发生”的不正常情况，如果参数来自于外部（不受自己控制），使用异常处理 6防御式编程 防御性编程是一种防御性设计的形式，旨在确保一块软件在不可预见的情况下的持续功能。 7SpotBugs工具 SpotBugs是一个使用静态分析来查找Java代码中的bug的程序 
第408篇文章[2]
哈工大信息安全概论复习笔记(3) 哈工大信息安全概论复习笔记（3） 考点十五PKI的体系结构及工作原理 公钥基础设施(PKI)采用数字证书技术来管理公钥，通过第三方的可信任机构 CA认证中心把用户的公钥和用户的其他标识信息捆绑到一起，在互联网上验证用户的身份。在PKI的组成结构中，处在中心位置的是构建PKI的核心技术，即公钥算法和数字证书技术，在此技术基础上实现的PKI平台包括四个基本功能模块和一个应用接口模块。 1.认证机构CA：CA是PKI的核心执行机构，也称为认证中心。其主要功能包括数字证书的申请注册、证书签发和管理。 2.证书库：证书库是CA颁发证书和撤销证书的集中存放地，它像网上的“白页”一样，是网上的公共信息库，可供公众进行开放式查询。 3.密钥备份和恢复：密钥备份和恢复是密钥管理的主要内容，PKI提供了密钥备份和密钥恢复机制，即当用户证书生成时，密钥被CA备份存储，当需要恢复时，用户只需向CA提出申请，CA就会为用户自动进行密钥恢复。 4.证书撤销处理：被撤销的CA证书将进入证书库的"黑名单"，用于公众来核实证书的有效性。 5.PKI应用接口：PKI应用接口使使用者与PKI交互的唯一途径，PKI应用接口也可以看成是PKI的客户端软件。 考点十六访问控制的概念 访问控制：是针对越权使用资源的防御措施，从而使系统资源在合法范围内使用。 访问控制的基本组成元素：1.主体-值提出访问请求的实体，主体是动作的发起者，但不一定是动作的执行者，可以是用户或其他代理用户行为的实体(如进程、作业和程序等)2.客体-是指可以接受主体访问的被动实体。凡是可以被操作的信息、资源、对象都可以认为是客体。3.访问控制策略-指主体对客体的操作行为和约束条件的关联集合 考点十七DAC、MAC、RBAC的工作原理及特点 自主访问控制DAC 自主访问控制(DAC):允许合法用户以用户或用户组的身份来访问系统控制策略许可的客体，同时阻止非授权用户访问客体，某些用户还可以自主地把自己所拥有的客体的访问权限授予其他用户。实现上：首先要对用户的身份进行鉴别，然后就可以按照访问控制列表所赋予用户的权限允许或限制用户访问客体资源。主体控制权限的修改通常由特权用户或特权用户组实现。 强制访问控制MAC 强制访问控制(MAC)：系统事先给访问主体和受控客体分配不同的安全级别属性，在实施访问控制时，系统先对访问主体和受控客体的安全级别属性进行比较，再决定访问主体能否访问该受控客体。主体对客体的访问可以分为以下四种形式：1.向下读2.向上读3.向下写4.向上写向下读向上写，防止机密信息向下级泄露，保护机密性向上读向下写，保护数据的完整性 基于角色的访问控制RBAC 组：具有相同性质(访问权限)的用户集合角色；一个与特定行为关联的行为与责任的集合RBAC思想：将访问权限分配给角色，用户饰演角色获得访问许可权。一个用户可当多个角色 考点十八Windows安全体系结构、活动目录与组策略 整个安全架构的核心是安全策略，完善的安全策略决定了系统的安全性。Windows系统的安全策略明确了系统各个安全组件如何协调工作。 Windows系统安全开始于用户认证，它是其他安全机制能够有效实施的基础，处于安全框架的最外层。 加密和访问控制处于用户认证之后，是保证系统安全的主要手段，加密保证了系统与用户之间的通信及数据存储的机密性；访问控制则维护了用户访问的授权原则。 审计和管理处于系统的内核层，负责系统的安全配置和事故处理，审计可以发现系统是否曾经遭受过攻击或者正在遭受攻击，并进行追查；管理则是为用户有效控制系统提供功能接口。 活动目录(AD)存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。 组策略(GP)是AD安全性地重要体现，可理解为依据特定地用户或计算机地安全需求定制地安全配置规则 考点十九传统病毒、蠕虫、木马的结构原理 传统病毒一般由三个主要模块组成，包括启动模块、传染模块和破坏模块。当系统执行了感染病毒地文件时，病毒的启动模块开始驻留在系统内存中。传染模块和破坏模块的发作均为条件触发，当满足了传染条件，病毒开始传染别的文件；满足了破坏条件，病毒就开始破坏系统。 蠕虫病毒一般不需要寄生在宿主文件中，这一点与传统病毒存在差别，蠕虫病毒具有传染性，它是通过在互联网环境下复制自身进行传播。蠕虫病毒的传染目标是互联网内的所有计算机，传播途径主要包括局域网内的共享文件夹、电子邮件、网络中的恶意网页和大量存在着漏洞的服务器等。可以说蠕虫病毒是以计算机为载体，以网络为攻击对象。 木马是有隐藏性的、传播性的、可被用来进行恶意行为的程序。木马一般不会直接对计算机产生危害，主要以控制计算机为目的。木马的传播方式主要通过电子邮件附件、被挂载木马的网页以及捆绑了木马程序的应用软件。木马被下载后完成修改注册表、驻留内存、安装后门程序、设置开机加载等，甚至能够使杀毒程序、个人防火墙等防范软件失效。 考点二十拒绝服务攻击、缓冲区溢出、举例 拒绝服务攻击(DoS)也被称为业务否定攻击，不是一种具体的攻击方式，二十攻击所表现的结果最终使得目标系统因遭受某种程度的破坏二不能继续提供正常的服务，甚至导致物理上的瘫痪或崩溃。通常拒绝服务攻击可分为两种类型，第一类是利用网络协议的缺陷，通过发送一些非法数据包致使主机系统瘫痪，如PingofDeath；第二类攻击是通过构造大量网络流量致使主机通信或网络堵塞，使系统不能相应正常的服务，如Smurf。 缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖了合法数据。利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果，更为严重的是可以利用它执行非授权指令，甚至可以取得系统特权并控制主机，进行各种非法操作。 考点二十一防火墙主要技术概述 依据防火墙的技术特征，常见的防火墙可以分为包过滤防火墙、代理防火墙和个人防火墙。 包过滤防火墙是面向网络底层数据流进行审计和控管，因此其安全策略主要根据数据包头的源地址、目的地址、端口号和协议类型等标志来指定，可见其主要工作在网络层和传输层。 代理防火墙是基于代理(Proxy)技术，使防火墙参与到每一个内、外网络之间的连接过程，防火墙需要理解用户使用的协议，对内部节点向外部节点的请求进行还原审查后，转发给外部服务器；外部节点发送来数据也需要进行还原审查，然后封装转发给内部节点。代理防火墙主要工作在应用层，有时也称为应用级网关。 个人防火墙使目前普通用户最常用的一种。个人防火墙是一种能保护个人计算机系统安全的软件，它可以直接在用户的计算机上运行，有效地帮助普通用户对系统进行监控及管理，使个人计算机免受各种攻击 
第409篇文章[2]
哈工大信息安全概论复习笔记(1) 哈工大信息安全概论复习笔记（1） 文章目录 哈工大信息安全概论复习笔记（1）考点一信息安全架构1面向目标的知识体系结构2面向应用的层次型技术架构3面向过程的信息安全保障体系4OSI开放系统互联安全体系结构 考点二密码体制的五要素考点三仿射密码考点四数据加密标准DES的算法结构和特点1S-DES(简化DES)算法结构：2DES的特点 考点五公钥密码的思想（数学描述）考点六离散对数问题1素数的原根2离散对数3求解离散对数 考点七Diffie-Hellman密钥交换协议 考点一信息安全架构 1面向目标的知识体系结构 信息安全CIA三元组(信息安全的三个最基本的目标)：C-机密性：信息在存储、传输、使用过程中，不会泄露给非授权用户或实体I-完整性：信息在存储、传输、使用过程中，不会被非授权用户篡改或防止授权用户对信息进行不恰当的篡改A-可用性：凡是为了确保授权用户或实体对信息资源的正常使用不会被异常拒绝，允许其可靠而及时地访问信息资源地相关理论技术均属于可用性范畴 如果组织最关心地是对私密信息地保护，就会特别强调机密性原则，如果组织最关心的是随时随地向客户提供正确的信息，那就会突出完整性和可用性的要求。 DAD三元组(信息安全面临的最普遍的三类风险)：D-泄漏、A-篡改、D-破坏 2面向应用的层次型技术架构 信息系统的基本要素：人员、信息、系统；人员-管理安全信息-内容安全、数据安全系统-运行安全、物理安全三者的五个层次安全有一定顺序关系，每个层次均为其上层提供基础安全保证 3面向过程的信息安全保障体系 信息安全保障体系包括四部分内容(PDRR)P-保护：指预先采取安全措施，阻止攻击可以发生的条件形成，让攻击者无法顺利地入侵。保护是被动防御，不可能完全阻止各种对信息系统的攻击行为。 D-检测：指依据相关安全策略，利用有关技术措施，针对可能被攻击者利用的信息系统的脆弱性进行具有一定实时性的检查，根据结果形成检测报告。 R-反应：指对于危及安全的事件、行为、过程及时做出适当的响应处理，杜绝危害事件进一步扩大，将信息系统受到的损失降低到最小。 R-恢复：指当危害事件发生后把系统恢复到原来状态或比原来状态更安全的状态，将危害的损失降到最小。 保护是最基本的被动防御措施，也是第一道防线；检测的重要目的之一是针对突破“保护防线”后的入侵行为进行探测预警；而反应是在检测报警后针对入侵采取的控制措施；恢复是针对攻击入侵带来的破坏进行弥补，是最后的减灾方法，如果前面的保障过程有效地控制了攻击行为，恢复过程则无须进行。 4OSI开放系统互联安全体系结构 安全服务：1.鉴别服务-用于确保某个实体身份的+可靠性2.访问控制-防止对任何资源的非授权访问3.数据机密性-确保只有经过授权的实体才能理解受保护的信息4.数据完整性-防止对数据的未授权修改和破坏5.抗抵赖性-也称不可否认性，用于防止对数据源以及数据提交的否认 安全机制：1.加密-用于保护数据的机密性2.数字签名-保证数据完整性及不可否认性的一种重要手段3.访问控制-与实体认证密切相关4.数据完整性-用于保护数据免受未经授权的修改5.鉴别交换-用于实现通信双方的实体身份鉴别(身份认证)6.业务流填充-针对的是对网络流量进行分析的攻击7.路由控制-可以指定数据报文通过网络的路径8.公证机制-由通信各方都信任的第三方提供 考点二密码体制的五要素 通常一个完整密码体制要包括如下五个要素，分别是M、C、K、E和D，具体定义如下： M-是可能明文的有限集，称为明文空间C-是可能密文的有限集，称为密文空间K-是一切可能密钥构成的有限集，称为密钥空间E-为加密算法，对于密钥空间的任一密钥加密算法都能够有效地计算D-为解密算法，对于密钥空间地任一密钥解密算法都能够有效地计算 一个密码体系如果是实际可用的，必须满足如下特性：1.加密算法 ( E k : M → C ) (E_k:M\rightarrowC) (Ek​:M→C)和解密算法 ( D k : C → M ) (D_k:C\rightarrowM) (Dk​:C→M)满足 D k ( E k ( x ) ) = x D_k(E_k(x))=x Dk​(Ek​(x))=x，这里 x ∈ M x\inM x∈M；2.破译者取得密文后，不能在有效的时间内破解出密钥k或明文x 考点三仿射密码 仿射密码是替换密码的一个特例，可以看做是移位密码和乘数密码的结合。其加密变换如下： E k ( m ) = ( k 1 m + k 2 ) m o d q E_k(m)=(k_1m+k_2)mod\spaceq Ek​(m)=(k1​m+k2​)mod q仿射密码的密钥为 ( k 1 , k 2 ) (k_1,k_2) (k1​,k2​)，其中， k 1 , k 2 ∈ ( 0 , q ) k_1,k_2\in(0,q) k1​,k2​∈(0,q)，且 k 1 k_1 k1​和q是互素的。其密码体系描述如下： M = C = Z / ( 26 ) ; q = 26 ; K = { k 1 , k 2 ∈ Z ∣ 0 < k 1 , k 2 < 26 , g c d ( k 1 , 26 ) = 1 } ; E k ( m ) = ( k 1 m + k 2 ) m o d q ; D k ( c ) = k 1 − 1 ( c − k 2 ) m o d q ; M=C=Z/(26);\\q=26;\\K=\{k_1,k_2\inZ|0<k_1,k_2<26,gcd(k_1,26)=1\};\\E_k(m)=(k_1m+k_2)mod\spaceq;\\D_k(c)=k_1^{-1}(c-k_2)mod~q; M=C=Z/(26);q=26;K={k1​,k2​∈Z∣0<k1​,k2​<26,gcd(k1​,26)=1};Ek​(m)=(k1​m+k2​)mod q;Dk​(c)=k1−1​(c−k2​)mod q;其中， k 1 − 1 k_1^{-1} k1−1​为 k 1 k_1 k1​在模q下的乘法逆元(不是倒数) gcd(k,q)=1表示k与q的最大公因子为1，即两者互素。 乘法逆元定义： k − 1 为 k 在 模 q 下 的 乘 法 逆 元 ， 其 定 义 为 k − 1 ∗ k m o d q = 1 k^{-1}为k在模q下的乘法逆元，其定义为k^{-1}*k~mod~q=1 k−1为k在模q下的乘法逆元，其定义为k−1∗k mod q=1 考点四数据加密标准DES的算法结构和特点 1S-DES(简化DES)算法结构： S-DES加密算法输入为一个8位的二进制明文组和一个10位的二进制密钥，输出为8位二进制密文组；解密与加密基本一致。算法共射击8个函数，两个与密钥变换有关的分别是置换函数P8、P10和循环移位函数Shift；4个基本函数用于数据加密变换，包括初始置换IP、复合函数 f k f_k fk​、转换函数SW以及末尾置换 I P − 1 IP^{-1} IP−1加密过程表达式： 密 文 = I P − 1 ( f k 2 ( S W ( f k 1 ( I P ( 明 文 ) ) ) ) ) 密文=IP^{-1}(f_{k_2}(SW(f_{k_1}(IP(明文))))) 密文=IP−1(fk2​​(SW(fk1​​(IP(明文)))))式中 k 1 = P 8 ( S h i f t ( P 10 ( k e y ) ) ) k 2 = P 8 ( S h i f t ( S h i f t ( P 10 ( k e y ) ) ) ) k_1=P8(Shift(P10(key)))\\k_2=P8(Shift(Shift(P10(key)))) k1​=P8(Shift(P10(key)))k2​=P8(Shift(Shift(P10(key))))解密过程表达式： 明 文 = I P − 1 ( f k 1 ( S W ( f k 2 ( I P ( 密 文 ) ) ) ) ) 明文=IP^{-1}(f_{k_1}(SW(f_{k_2}(IP(密文))))) 明文=IP−1(fk1​​(SW(fk2​​(IP(密文))))) 2DES的特点 DES是一种对二进制数据进行分组加密的算法，以64位为分组对数据加密，DES的密钥也是长度为64位的二进制数。加密算法和解密算法非常相似，唯一的区别在于子密钥的使用顺序正好相反。DES的整个密码体制是公开的，系统的安全性完全依赖于密钥的保密性。 考点五公钥密码的思想（数学描述） 公开密钥的核心思想：单向陷门函数如果函数 f ( x ) f(x) f(x)被称为单向陷门函数，必须满足以下三个条件 1.给定x，计算y=f(x)是容易的2.给定y，计算x使y=f(x)是困难的(所谓计算 x = f − 1 ( y ) x=f^{-1}(y) x=f−1(y)困难是指计算上相当复杂，已无实际意义)3.存在 δ \delta δ，已知 δ \delta δ时对给定的任何y，若相应的x存在，则计算x使y=f(x)是容易的注：（1）仅满足1、2条的称为单向函数；第3条称为陷门性， δ \delta δ称为陷门信息（2）当用陷门函数f作为加密函数时，可将f公开，这相当于公开加密密钥 P k P_k Pk​。f函数的设计者将 δ \delta δ保密，用做解密密钥，此时 δ \delta δ称为秘密钥匙 S k S_k Sk​。由于加密函数是公开的，任何人都可以将信息x加密成y=f(x)，然后发送给函数的设计者。由于设计者拥有 S k S_k Sk​，他自然可以利用 S k S_k Sk​求解 x = f − 1 ( y ) x=f^{-1}(y) x=f−1(y)。（3）单向陷门函数的第2条性质表明窃听者由截获的密文y=f(x)推测x是不可行的。 考点六离散对数问题 1素数的原根 若a是素数p的原根，则1. a m o d p , a 2 m o d p , … … , a p − 1 m o d p a~mod~p,a^2~mod~p,……,a^{p-1}~mod~p a mod p,a2 mod p,……,ap−1 mod p是不同的2.包含从1到p-1间所有正数的某种排列，对 ∀ b ∈ Z \forallb\inZ ∀b∈Z，有唯一的i，满足 b ≡ a i m o d p , ( 1 ≤ i ≤ p − 1 ) b\equiva^i~mod~p,(1\lei\lep-1) b≡ai mod p,(1≤i≤p−1)。注： b ≡ a i m o d p b\equiva^i~mod~p b≡ai mod p等价于 b m o d p = a i m o d p b~mod~p=a^i~mod~p b mod p=ai mod p，称为b与a模p同余。 2离散对数 若a是系数p的一个原根，则 ∀ b ∈ Z ( b m o d p ≠ 0 ) \forallb\inZ(b~mod~p\ne0) ∀b∈Z(b mod p​=0),必有在唯一的 i ( 1 ≤ i ≤ p − 1 ) , s . t . b ≡ a i m o d p 。 i(1\lei\lep-1),s.t.b\equiva^i~mod~p。 i(1≤i≤p−1),s.t.b≡ai mod p。i称为b的以a为基数且模p的幂指数，即离散对数。 3求解离散对数 对 y ≡ g x m o d p y\equivg^x~mod~p y≡gx mod p(g为系数p的原根，x与y均为正整数)，则1.从g，x，p计算y是容易的2.从g，y，p计算x是困难的注：离散对数的求解为数学界公认的困难问题 考点七Diffie-Hellman密钥交换协议 DH密钥交换算法的描述如下：Alice和Bob协商好一个大素数p和大的整数g，1<g<p，g是p的原根。p和g无须保密，可为网络上的所有用户共享。当Alice和Bob要进行保密通信时，他们可以按如下步骤来做 1.Alice选取大的随机数 x < p x<p x<p，并计算 Y = g x ( m o d P ) Y=g^x(mod~P) Y=gx(mod P)。2.Bob选取大的随机数 x ′ < p x^{'}<p x′<p，并计算 Y ′ = g x ′ ( m o d P ) Y^{'}=g^{x^{'}}(mod~P) Y′=gx′(mod P)。3.Alice将Y传送给Bob，Bob将 Y ′ Y^{'} Y′传送给Alice。4.Alice计算 K = ( Y ′ ) X ( m o d P ) K=(Y^{'})^X(mod~P) K=(Y′)X(mod P)，Bob计算 K = ( Y ) X ′ ( m o d P ) K=(Y)^{X^{'}}(mod~P) K=(Y)X′(mod P)。显而易见， K = K ′ = g x x ′ ( m o d P ) K=K^{'}=g^{xx^{'}}(mod~P) K=K′=gxx′(mod P)，即Alice和Bob已获得了相同的秘密值K。双发以K作为加解密钥，以传统对称密钥算法进行保密通信。 
第410篇文章[]
软件构造复习笔记(2) 注：文章中带有*的标题表示往年考试中出现过相应考点 文章目录 第四章数据类型与类型检验1编程语言中的数据类型*2静态、动态类型检查*3可变性、不可变性*4Snapshotdiagram*5复杂数据类型-Arrays和Collections*6有用的不可变数据类型* 第五章设计规约1编程语言中的函数、方法*2规约：面向交流编程*假设规约行为等价性规约结构-前置条件和后置条件* 3设计规约*规约性质*规约图设计好的规约* 第六章抽象数据类型(ADT)1抽象与用户定义的类型2对类型和操作进行分类*3抽象数据类型例子4设计一个抽象类型*5表示独立性6对ADT的测试7不变量*8表示不变性和抽象函数*9有益的可变性10记录AF、RI、以及防止表示泄露的方法*11ADT不变量替代前置条件 第四章数据类型与类型检验 1编程语言中的数据类型* 基本数据类型：int、boolean等 对象数据类型：String、Integer等 注：本节简单看看就行了，考也是大题里穿插考 2静态、动态类型检查* 静态类型语言：在编译阶段进行类型检查动态类型语言：在运行阶段进行类型检查静态类型检查>>动态>>无检查 静态类型检查：可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性 静态检查：关于“类型”的检查，不考虑值动态检查：关于“值”的检查 注：本节看一遍就行了，需要知道怎么找错，就考过选择， 3可变性、不可变性* 改变一个变量：将该变量指向另一个值的存储空间改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。 尽可能避免变化，以避免副作用 不变性：重要设计原则不变数据类型：一旦被创建，其值不能改变，使用final关键字修饰，如果是引用类型，也可以是不变的，即一旦确定其指向的对象，指向不能再被改变 如果编译器无法确定final变量不会改变，就提示错误，这也是静态类型检查的一部分。尽量使用final变量作为方法的输入参数、作为局部变量。 注意：1.final类无法派生子类2.final变量无法改变值/引用3.final方法无法被子类重写 不变对象：一旦被创建，始终指向同一个值/引用(这个对象内部的各个属性都不能修改)可变对象：拥有方法可以修改自己的值/引用 Immutable数据类型例子：StringString类型不可变，所以一个String对象在其生命周期中只能有一个值为了向一个String对象末尾添加元素，将重新创建一个新的String对象Mutable数据类型例子：StringBuilderStringBuilder有插入、删除、替代字符等方法修改对象内部的值因此它是可变数据类型String和StringBuilder区别：当只有一个引用指向该值时，没有区别有多个引用的时候，差异就出现了可变数据类型的优点：1.使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)2.可变类型最少化拷贝以提高效率3.使用可变数据类型，可获得更好的性能4.可变数据类型也适合于在多个模块之间共享数据 可变数据类型的风险：传递可变值时，函数可能超过spec的范畴，因为它可能会改变输入参数的值返回可变值时，后续对返回值的操作可能会影响全局变量的值 解决方案：1.通过防御式拷贝，给客户端返回一个副本2.安全地使用可变类型：局部变量，不会涉及共享；同一时间只有一个引用 注：本节需要掌握怎么区分可变和不可变数据类型，还得会画相应的snapshotdiagram 4Snapshotdiagram* 作用：用于描述程序运行时的内部状态 画法：注：本节经常在大题中考如何画snapshotdiagram，需要会画 5复杂数据类型-Arrays和Collections* 数组：数组定长，一旦被创建，其长度不可改变 列表：List是类型T的可变长序列 数组和List的迭代：集合：零个或多个唯一对象的无序集合映射：类似与字典，使用键值对存储，一个键只能对应一个值List、Set、Map都是接口，使用时需要用其具体实现类ArrayList、HashSet、HashMap等 迭代器：可变数据类型使用迭代器时，不可添加元素，若想删除元素，必须调用对应迭代器的remove方法。 注：本节是大题的基本知识，应该掌握 6有用的不可变数据类型* 基本类型及其封装对象类型都是不可变的 Collections类中有将可变Collections转化为不可变类型的方法：Collections.unmodifiableListCollections.unmodifiableSetCollections.unmodifiableMap其参数为要转化的Collection，这种包装器得到的结果是不可变的，只能看但是这种“不可变”是在运行阶段获得的，编译阶段无法据此进行静态检查 注：本节考过选择题，看看就行了 第五章设计规约 1编程语言中的函数、方法* 方法：参数类型是否匹配，在静态类型检查阶段完成返回值类型是否匹配，也在静态类型检查阶段完成 方法是程序的"积木"，可以被独立开发、测试、复用使用方法的客户端，无需了解方法内部具体如何工作-“抽象” 完整方法示例： 注：大题一定会考写方法，学过编程语言的应该都会，看看就行了 2规约：面向交流编程* 例子，JAVAAPI文档： 假设 把对某个变量所做出的假设写下来，例如，假定某一变量必须指向Integerfinal关键字也算假设，它定义了不可改变的设计决策 为什么要写出假设？一，自己记不住二，别人看不懂 代码中蕴含的“设计决策”-给编译器读注释形式的“设计决策”-给自己和别人读 规约 没规约，没法写程序，即使写出来，也不知道对错规约也是程序与客户端之间达成的一致Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守 很多bug来自于双方间的误解不写下来，那么不同开发者的理解可能就不同没有规约，难以定位错误 规约优点：1.精确的规约，有助于区分责任2.客户端无需阅读调用函数的代码，只需理解spec即可 例子：规约可以隔离“变化”，无需通知客户端规约也可以提高代码效率规约也扮演了用户和实现者之间的防火墙，用户不需要了解具体实现 规约只讲“能做什么”，不讲“怎么实现” 行为等价性 行为等价性：两个事物是否可以相互替换要站在客户端的视角看待行为等价性 根据规约判断是否行为等价，如果两个函数符合这个规约，那他们对于这个规约而言就等价 规约结构-前置条件和后置条件* 前置条件：对客户端的约束，在使用方法时必须满足的条件后置条件：对开发者的约束，方法结束时必须满足的条件契约：如果前置条件满足了，后置条件必须满足，若前置条件不满足，则方法可以做任何事情 静态类型声明是一种规约，可据此进行静态类型检查。方法前的注释也是一种规约，但需人工判定其是否满足 除非在后置条件里声明过，否则方法内部不应该改变输入参数应尽量遵循此规则，尽量不设计mutating的spec，否则容易引发bug原因：程序中可以有多个变量指向用一个可变对象(别名)，无法强迫类的实现体和客户端不保存可变变量的别名 注：本节只需要看一遍就行，可能考选择 3设计规约* 规约性质* 规约的三条性质：确定性、陈述性、强度 强度： 当规约S2相比S1的前置条件更弱，后置条件更强时，则称规约S2的强度强于S1，就可以用S2替代S1Spec变强：更放松的前置条件+更严格的后置条件 例子：确定性：明确的规约：给定一个满足前置条件的输入，其输出是唯一的、明确的欠定的规约：同一个输入可以有多个输出非确定的规约：同一个输入，多次执行时得到的输出可能不同欠定通常可认为等价于非确定，但欠定的规约通常有确定的实现 陈述性：操作式规约：给出方法进行的一系列步骤，例如伪代码声明式规约：没有内部实现的描述，只有“初-终”状态声明式规约更有价值，通常不使用操作式规约，内部实现的细节通常放在实现体内部注释中 规约图 设计好的规约* 好的规约应该易于阅读，应该有以下几个性质：1.内聚的：Spec描述的功能应单一、简单、易理解2.信息丰富的：不能让客户端产生理解的歧义3.足够健壮的：开发者应尽可能考虑各种特殊情况，在后置条件中给出处理措施4.足够虚弱的：太强的spec在很多特殊情况下难以达到，给开发者增加了实现的难度5.使用抽象类型：在规约里使用抽象类型，可以给方法的实现体与客户端更大的自由度6.前置后置条件选取：*注：本节主要需要重点掌握怎么写spec以及spec的前置、后置条件强度的比较等* 第六章抽象数据类型(ADT) 1抽象与用户定义的类型 除了编程语言所提供的基本数据类型和对象数据类型，程序员可定义自己的数据类型 数据抽象：由一组操作所刻画的数据结构，而非传统意义上关注数据的具体表示 抽象类型：强调“作用于数据上的操作”，程序员和客户端无需关心数据如何具体存储，只需设计/使用操作即可。 一个抽象数据类型由它的操作所定义，与其内部实现无关 2对类型和操作进行分类* 对类型的分类：可变类型的对象：提供了可改变其内部数据的值的操作不可变数据类型：其操作不改变内部值，而是构造新的对象 对操作的分类：构造器(Creator)：创造ADT的新对象生产器(Producer)：提供ADT以前的对象创造新的对象观察器(Observer)：获取抽象类型的对象，并返回不同类型的对象变值器(Mutator)：改变对象属性的方法 构造器可能实现为构造函数或静态函数，实施为静态函数的通常被称作工厂方法变值器通常返回void，如果返回值为void，则必然意味着它改变了对象的某些内部状态变值器也可能返回非空类型，例如返回boolean，判断操作是否成功 注：本节需要掌握如何判断某一方法有可能属于哪种，建议关注一下静态工厂方法 3抽象数据类型例子 4设计一个抽象类型* 设计好的ADT，靠“经验法则”，提供一组操作，设计其行为规约spec 以下是几个设计规则：1.设计简洁、一致的操作2.要足以支持客户端对数据所做的所有操作需要，且用操作满足客户端需要的难度要低3.要么抽象、要么具体，不要混合-要么针对抽象设计，要么针对具体应用的设计 注：本节内容理解就行，考试必考ADT设计 5表示独立性 表示独立性(RI)：客户端使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端 除非ADT的操作指明了具体的前置和后置条件，否则不能改变ADT的内部表示-spec规定了客户端和实现者之间的契约 6对ADT的测试 测试creators,producers,andmutators：调用observers来观察这些operations的结果是否满足spec；测试observers：调用creators,producers,andmutators等方法产生或改变对象，来看结果是否正确。风险：如果被依赖的其他方法有错误，可能导致被测试方法的测试结果失效。 7不变量* 不变量(invariants)：在任何时候都是true由ADT来负责其不变量，与client端的任何行为无关 为什么需要不变量：保持程序的“正确性”，容易发现错误 总是要假设客户端有“恶意”破坏ADT的不变量除非迫不得已，否则不要把希望寄托于客户端上，ADT有责任保证自己的invariants，并避免“表示泄露”。 最好的办法就是使用immutable的类型，彻底避免表示泄露 保持不变性和避免表示泄漏，是ADT最重要的一个Invariant！ 注：本节简单理解一下就行了 8表示不变性和抽象函数* 抽象值构成的空间：用户端看到和使用的值 ADT开发者关注表示空间R，client关注抽象空间A 抽象函数：R和A之间映射关系的函数，即如何去解释R中每一个值为A中的每一个值抽象函数性质：1.满射：每一个抽象值都必须被某个表示值所映射2.未必单射：某个抽象值可能由超过一个表示值映射3.未必双射：不是所有表示值都需要有映射，R中部分值并非合法的，在A中无映射值 RI:R→boolean表示不变性(RI通常指的是这个)：某个具体的“表示”是否是“合法的”也可以将RI看作：所有表示值的一个子集，包含了所有合法的表示值也可将RI看作：一个条件，描述了什么是“合法”的表示值 RI和AF都是作为注释写在代码中的，通常写在rep下方 不同的内部表示，需要设计不同的AF和RI，即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。 编写过程：选择某种特定的表示方式R，进而指定某个子集是“合法”的(RI)，并为该子集中的每个值做出“解释”(AF) 即如何映射到抽象空间中的值。 在实现中通常有一个checkRep方法，在所有可能改变rep的方法内检查RI是否被满足 注：本节比较重要，需要理解 9有益的可变性 对immutable的ADT来说，它在A空间的abstractvalue应是不变的，但其内部表示的R空间中的取值则可以是变化的。 这种mutation只是改变了R值，并未改变A值，对client来说，是immutable的“AF并非单射”，从一个R值变成了另一个R值 但这并不代表在immutable的类中就可以随意出现mutator！ 10记录AF、RI、以及防止表示泄露的方法* 在代码中用注释形式记录AF和RI以及防止表示泄露的方法，其内容是客户端不可见的 要精确的记录RI：rep中的所有fields何为有效要精确记录AF：如何解释每一个R值 表示泄漏的安全声明：给出理由，证明代码并未对外泄露其内部表示 自证清白 具体措施：ADT的规约里只能使用client可见的内容来撰写，包括参数、返回值、异常等。如果规约里需要提及“值”，只能使用A空间中的“值“。ADT的规约里也不应谈及任何内部表示的细节，以及R空间中的任何值ADT的内部表示(私有属性)对外部都应严格不可见 表示泄漏的风险：一旦泄露，ADT内部表示可能会在程序的任何位置发生改变（而不是限制在ADT内部），从而无法确保ADT的不变量是否能够始终保持为true。 导致表示泄露的代码：1.直接将内部rep的别名作为返回值输出2.直接用rep作为外部可变对象的别名3.内部rep未用private修饰 如何构建不变性：1.在对象的初始状态不变量为true，在对象发生变化时，不变量也要为true2.构造器和生产器在创建对象时要确保不变量为true3.变值器和观察器在执行时必须保持不变性4.在每个方法return之前，用checkRep()检查不变量是否得以保持。 注：本节内容需要会读AF/RI，并会判断什么情况下RI可能不满足，以及知道哪些行为会导致表示泄露 11ADT不变量替代前置条件 用ADT不变量取代复杂的Precondition，相当于将复杂的precondition封装到了ADT内部。 
第411篇文章[2]
哈工大信息安全概论复习笔记(2) 哈工大信息安全概论复习笔记（2） 文章目录 哈工大信息安全概论复习笔记（2）考点八RSA公钥算法考点九散列函数的特点和作用考点十EMI、EMC、防电磁泄漏主要方法考点十一容错与容灾的概念及主要技术方法考点十二windows的网络认证考点十三利用公开密钥和对称密钥设计认证协议获得会话密钥1基于对称密钥的认证协议2基于公开密钥的认证协议 考点十四Kerberos工作原理 考点八RSA公钥算法 RSA算法的数学基础是初等数论中的欧拉定理以及大整数因子分解问题。RSA密码体制是一种分组密码，明文和密文均是0到n之间的整数，n的大小通常为1024位二进制数或309位十进制数，因此，明文空间P=密文空间C= { x ∈ Z ∣ 0 < x < n , Z 为 整 数 集 合 } \{x\inZ|0<x<n,Z为整数集合\} {x∈Z∣0<x<n,Z为整数集合}。 RSA密码的密钥生成具体步骤如下。1.选择两个互异的素数p和q，计算 n = p q n=pq n=pq， ϕ ( n ) = ( p − 1 ) ( q − 1 ) \phi(n)=(p-1)(q-1) ϕ(n)=(p−1)(q−1)。2.选择整数e，使 g c d ( ϕ ( n ) , e ) = 1 gcd(\phi(n),e)=1 gcd(ϕ(n),e)=1，且 1 < e < ϕ ( n ) 1<e<\phi(n) 1<e<ϕ(n)。3.计算d，使 d ≡ e − 1 m o d ϕ ( n ) d\equive^{-1}~mod~\phi(n) d≡e−1 mod ϕ(n)，即d为模 ϕ ( n ) \phi(n) ϕ(n)下e的乘法逆元 则公开密钥 P k = { e , n } P_k=\{e,n\} Pk​={e,n}，私用密钥 S k = { d , n , p , q } S_k=\{d,n,p,q\} Sk​={d,n,p,q}。当明文为m，密文为c，加密时使用公开密钥 P k P_k Pk​，加密算法 c = m e m o d n c=m^e~mod~n c=me mod n；解密时使用私用密钥 S k ， m = c d m o d n S_k，m=c^d~mod~n Sk​，m=cd mod n。故e也被称为加密指数，d被称为解密指数。 考点九散列函数的特点和作用 散列函数的目的：将任意长的消息映射成一个固定长度的散列值(Hash值)，也称为消息摘要。消息摘要可以作为认证符，完成消息认证。健壮性：1.弱无碰撞性：指在消息特定的明文空间X中，给定消息 x ∈ X x\inX x∈X，在计算机上几乎找不到不同于x的 x ′ , x ′ ∈ X ， 使 得 h ( x ) = h ( x ′ ) x^{'},x^{'}\inX，使得h(x)=h(x^{'}) x′,x′∈X，使得h(x)=h(x′)。2.强无碰撞性：指在计算机上几乎找不到不同于x的 x ′ ， 使 得 h ( x ) = h ( x ′ ) ， x ′ 可 以 不 属 于 X x^{'}，使得h(x)=h(x^{'})，x^{'}可以不属于X x′，使得h(x)=h(x′)，x′可以不属于X。注：强无碰撞自然包含弱无碰撞3.单向性：指通过h的逆函数 h − 1 h^{-1} h−1来求得散列值h(x)的消息原文x在计算上不可行。 考点十EMI、EMC、防电磁泄漏主要方法 电磁干扰(EMI)：指一切与有用信号无关的、不希望有的或对电器及电子设备产生不良影响的电磁发射。防止EMI要从两方面考虑，一方面要减少电子设备的电磁发射，另一方面要提高电子设备的电磁兼容性(EMC)。 电磁兼容性(EMC)：指电子设备在自己正常工作时产生的电磁环境，与其他电子设备之间相互不影响的电磁特性。 防电磁信息泄漏的基本思想主要包括三个层面：1.抑制电磁发射2.屏蔽隔离3.相关干扰 常用的防电磁泄漏的方法有三种：1.屏蔽法-主要用来屏蔽辐射及干扰信号2.频域法-主要解决正常的电磁发射受干扰问题3.时域法-与频域法相似，时域法也是用来回避干扰信号 考点十一容错与容灾的概念及主要技术方法 容错基本思想：即使出现了错误，系统也可以执行一组规定的程序；或者说，程序不会因为系统中的故障而中断或被修改，并且故障也不会引起运行结果的差错。简单地说，容错就是让系统具有抵抗错误带来的能力。 容错系统可分为五种类型：1.高可用度系统2.长寿命系统3.延迟维修系统4.高性能系统5.关键任务系统 常用数据容错技术主要有以下四种：1.空闲设备-当正常运行的部件出现故障时，原来空闲的一台立即替补2.镜像-把一份工作交给两个相同的部件同时进行3.复现-也称延迟镜像，原系统故障时，辅助系统只能在接近故障点的地方开始工作。同一时间只需要管理一套设备4.负载均衡-将一个任务分解成多个子任务，分配给不同的服务器执行。 容灾含义：对偶然事故的预防和恢复 解决方案：一是对服务的维护和恢复，二是保护或恢复丢失的、被破坏的或被删除的信息。只有两者结合起来才能提供完整的灾难恢复方案。 常用恢复策略：1.做最坏的打算2.充分利用现有资源3.既重视灾后恢复也重视灾前措施 考点十二windows的网络认证 用户登入时的身份认证过程也是采用对称密钥加密来完成的用户与主域控制器共享口令，在域控制器的安全用户管理(SAM)数据库中保存注册用户的用户名、口令的散列以及其他信息。 用户登录具体过程：1.用户先激活winlogon窗口，并输入用户名和口令，然后向域控制器发送登录请求，同时计算出口令的散列，口令及其散列不包含在登录请求信息中。2.域控制器收到登录请求后产生一个8字节的质询(挑战)并发送给客户端，同时取出给用户的口令散列，用此口令散列对质询进行散列计算(也称加密)，得到质询散列。3.客户端收到8字节的质询后，首先使用前边计算得到的口令散列对质询进行散列计算，得到质询散列，随后将计算出的质询散列作为应答发送给域控制器。4.域控制器比对其算出的质询散列和用户应答回送的质询散列，如果相同则登录认证通过，否则登录认证失败，同时向用户发送登录认证结果。 考点十三利用公开密钥和对称密钥设计认证协议获得会话密钥 描述符号： A → B A\rightarrowB A→B表示A向B发送信息 E k ( x ) E_k(x) Ek​(x)表示使用共享密钥k对信息进行加密 x ∣ ∣ y x||y x∣∣y表示信息串x和y相连接 1基于对称密钥的认证协议 只有少量用户的封闭网络系统，使用挑战-应答方式认证对于规模较大的网络系统，依靠可靠的第三方完成认证 基于挑战应答方式的认证协议：1. A → B : I D a ∣ ∣ I D b A\rightarrowB:ID_a||ID_b A→B:IDa​∣∣IDb​2. B → A : N b B\rightarrowA:Nb B→A:Nb3. A → B : E k ( N b ) A\rightarrowB:E_k(Nb) A→B:Ek​(Nb) 2基于公开密钥的认证协议 A要认证B，有以下两种方式：（1）1.A向B发送明文挑战(挑战因子/随机数)2.B用私钥加密(签名)，返回给A3.A用B的公钥解密，比对，完成认证（2）1.A用B的公钥加密挑战因子(或随机数)发送给B2.B用私钥解密，返回明文给A3.A比对，完成认证 考点十四Kerberos工作原理 Kerberos协议的认证过程分为三个阶段，六个步骤第一阶段身份验证服务交换：完成身份认证，获得访问TGS的票据(1) C → A S : I D C ∣ ∣ I D t g s ∣ ∣ T S 1 C\rightarrowAS:ID_C||ID_{tgs}||TS_1 C→AS:IDC​∣∣IDtgs​∣∣TS1​(2) A S → C : E K C [ K C , t g s ∣ ∣ I D t g s ∣ ∣ T S 2 ∣ ∣ L i f e t i m e 2 ∣ ∣ T i c k e t t g s ] AS\rightarrowC:E_{KC}[K_{C,tgs}||ID_{tgs}||TS_2||Lifetime_2||Ticket_{tgs}] AS→C:EKC​[KC,tgs​∣∣IDtgs​∣∣TS2​∣∣Lifetime2​∣∣Tickettgs​] 注：步骤(1)为请求TGS票据 I D C : ID_C: IDC​:ClientC的用户标识 I D t g s : ID_{tgs}: IDtgs​:用请求访问的TGS的标识 T S 1 : TS_1: TS1​:让AS验证ClientC的时钟是与AS的时钟是否同步的 步骤(2)为返回TGS票据 E K C : E_{KC}: EKC​:基于用户口令的加密，使得AS和ClientC可以验证口令，并保护消息 K C , t g s : K_{C,tgs}: KC,tgs​:由AS产生，用于在TGS和ClientC之间信息的安全交接 I D t g s : ID_{tgs}: IDtgs​:确认这个ticket是为特定TGS制作的 T S 2 : TS_2: TS2​:告诉用户该ticket签发的时间 L i f e t i m e 2 : Lifetime_2: Lifetime2​:告诉用户该ticket的有效期 T i c k e t t g s : Ticket_{tgs}: Tickettgs​:用户用来访问TGS的ticket，可重用，避免多次认证输入口令，其中， T i c k e t t g s = E K t g s [ K C , t g s ∣ ∣ I D c ∣ ∣ A D C ∣ ∣ I D t g s ∣ ∣ T S 2 ∣ ∣ L i f e t i m e 2 ] Ticket_{tgs}=E_{Ktgs}[K_{C,tgs}||ID_c||AD_C||ID_{tgs}||TS_2||Lifetime_2] Tickettgs​=EKtgs​[KC,tgs​∣∣IDc​∣∣ADC​∣∣IDtgs​∣∣TS2​∣∣Lifetime2​] 第二阶段票据授予服务交换：获得访问应用服务器的票据。(3) C → T G S : I D V ∣ ∣ T i c k e t t g s ∣ ∣ A u t h e n t i c a t o r C C\rightarrowTGS:ID_V||Ticket_{tgs}||Authenticator_C C→TGS:IDV​∣∣Tickettgs​∣∣AuthenticatorC​(4) T G S → C : E K C , t g s [ K C , V ∣ ∣ I D V ∣ ∣ T S 4 ∣ ∣ T i c k e t V ] TGS\rightarrowC:E_{K_{C,tgs}}[K_{C,V}||ID_V||TS_4||Ticket_V] TGS→C:EKC,tgs​​[KC,V​∣∣IDV​∣∣TS4​∣∣TicketV​] 注：步骤(3)为请求应用服务器票据 I D V : ID_V: IDV​:告诉TGS用户要访问应用服务器V T i c k e t t g s : Ticket_{tgs}: Tickettgs​:向TGS证实该用户已被AS认证 A u t h e n t i c a t o r C : Authenticator_C: AuthenticatorC​:由用户生成，用于验证时效性 A u t h e n t i c a t o r C = E K C , t g s [ I D C ∣ ∣ A D C ∣ ∣ T S 3 ] Authenticator_C=E_{K_{C,tgs}}[ID_C||AD_C||TS_3] AuthenticatorC​=EKC,tgs​​[IDC​∣∣ADC​∣∣TS3​] 步骤(4)为返回应用服务器票据 E K C , t g s [ ] : E_{K_{C,tgs}}[]: EKC,tgs​​[]:使用ClientC和TGS共享的密钥加密，用以保护本消息 K C , V : K_{C,V}: KC,V​:由TGS生成，用于ClientC和ServerV之间信息的安全交换； I D V : ID_V: IDV​:确认该ticket是签发给setcerV的 T S 4 : TS_4: TS4​:告诉用户该ticket签发的时间 T i c k e t V : Ticket_V: TicketV​:用户用以访问应用服务器V的ticket，其中， T i c k e t V = E K V [ K C , V ∣ ∣ I D C ∣ ∣ A D C ∣ ∣ I D V ∣ ∣ T S 4 ∣ ∣ L i f e t i m e 4 ] Ticket_V=E_{KV}[K_{C,V}||ID_C||AD_C||ID_V||TS_4||Lifetime_4] TicketV​=EKV​[KC,V​∣∣IDC​∣∣ADC​∣∣IDV​∣∣TS4​∣∣Lifetime4​] E K V [ ] : E_{K_V}[]: EKV​​[]:Ticket用只有TGS和ServerV共享的密钥加密，以预防篡改 第三阶段客户与服务器身份验证交换：获得服务(5) C → V : T i c k e t V ∣ ∣ A u t h e n t i c a t o r C\rightarrowV:Ticket_V||Authenticator C→V:TicketV​∣∣Authenticator(6) V → C : E K C , V [ T S 5 + 1 ] ( f o r m u t u a l a u t h e n t i c a t i o n ) V\rightarrowC:E_{K_{C,V}}[TS_5+1](for~mutual~authentication) V→C:EKC,V​​[TS5​+1](for mutual authentication) 注：步骤(5)为向应用服务器发起服务请求。 T i c k e t V : Ticket_V: TicketV​:向服务器证实该用户已被AS认证 A u t h e n t i c a t o r C : Authenticator_C: AuthenticatorC​:由ClientC生成用于验证时效性 A u t h e n t i c a t o r C = E K C , V [ I D C ∣ ∣ A D C ∣ ∣ T S 5 ] Authenticator_C=E_{K_{C,V}}[ID_C||AD_C||TS_5] AuthenticatorC​=EKC,V​​[IDC​∣∣ADC​∣∣TS5​] E K C , V [ ] : E_{K_{C,V}}[]: EKC,V​​[]:使用ClinetC和ServerV的共享密钥加密，来验证身份并保护本信息 步骤(6)为服务器对客户机可选的身份认证 T S 5 + 1 : TS_5+1: TS5​+1:向ClientC证明这不是重放攻击的应答 
第412篇文章[]
从C语言到Java学习过程（1） 从C语言到Java学习过程（1） 文章目录 从C语言到Java学习过程（1）前言一.Helloworld1.代码2.编译、运行3.个人总结 二.基本知识1.基本数据类型(1)基本介绍(2)类型转换(3)常量声明 2.选择语句3.循环语句 小结 前言 本人由于课程需要使用java语言，而之前对于该语言并不是很熟悉，但在大一的课程上简单的学习过一些C语言的知识，对编程语言方面并不算毫无基础。这篇及以后可能写的几篇博客算是记载一下我个人的Java学习过程吧，也希望能给以后的读者(如果有的话)一些帮助吧。 一.Helloworld 所有语言的学习一般都是从写Helloworld程序开始的吧，所以我打算先写个Java版的Helloworld程序并拿来和C语言的比较一下。 1.代码 下面是C语言的Helloworld，文件名记为Helloworld.c，代码如下： #include<stdio.h> intmain(intargc,char**argv) { printf("Helloworld\n"); return0; } 下面是Java语言的Helloworld，文件名记为Helloworld.java，代码如下： publicclassHelloworld{ publicstaticvoidmain(String[]args){ System.out.println("Helloworld"); } } 2.编译、运行 C语言和Java语言均属于静态编译语言，所以想要运行两者都需要进行编译。 对于C程序，使用gcc编译，可以在命令行中输入如下指令： gccHelloworld.c-oHelloworld.exe 可以得到程序的exe文件，在命令行中输入 ./Helloworld.exe 即可运行，效果为在命令行中输出Helloworld字样 对于JAVA语言，可以使用javac进行编译，在命令行中输入 javacHelloworld.java 可以得到Helloworld.class文件，在命令行中输入 javaHelloworld 即可运行，效果与C语言程序相同。 注：javac命令需要安装jdk才能使用，而gcc编译器一般linux自带，在windows下可以通过安装mingw获取gcc编译器。具体安装过程网上有的是，这里不再赘述。 两者都需要将其对应可执行程序所在目录设置为环境变量时，才能直接在命令行中使用。 3.个人总结 Java和C语言最大的差别就是java是一个彻底的面向对象的语言，也就是说，程序的一切行为都是以类为基础的，不可以有单独存在的方法(函数)与属性(变量)，所以main函数的外面需要套在一个class的代码块中。 而且一般来说，Java文件的名字应该与其主类名称相同(这里为Helloworld)。除此之外，每个java类中都可以有一个main方法，且当将这个类被编译为.class文件时，并直接通过java命令运行时，运行的就是这个类中的main方法。 另外，关于库调用方面，C语言是通过引入头文件的形式得以调用函数库中的已有函数，而java则是通过引入其他包来调用其他文件中的类及其各种方法(System类属于Java默认调用的包，不需要特意进行引入)。 二.基本知识 Java中的许多初学者基础知识和C语言及其相似，以下是个人学习过程中的一些总结。 1.基本数据类型 (1)基本介绍 Java和C都有char、short、int、long、float、double这几个数据类型，不同的是，Java中还有boolean类型用以表示布尔值，以及byte类型用于单独表示一个字节，而C语言中有指针类型和longlong与longdouble(后两种并不常见)。 数据类型java中所占字节数C语言中所占字节数byte1\char21short22int44long84/8longlong\8float44double88longdouble\8/12/16bollean不明\void*\4/8 java中的char类型存储字符的unicode编码，而C语言中的char存储的是ASCII码，另外，java通过使用byte表示占用一个字节的值，而C语言往往使用signedchar来表示一个字节的值。 关于short、int、long、float、double等数据类型的使用场合，Java和C一般相同，java的long类型相比于C语言的更加确定，相当于longlong类型。 C语言中通常使用int类型表示布尔值，为0表示false，为其他任意非0值时表示true。而Java中则用boolean类型来表示布尔值，且只有true和false两种取值。 至于C语言中的指针，个人认为Java中与其对应的为各种引用数据类型，不同的是，指针可以直接进行各种操作，而Java中对引用数据类型的操作则受到各种限制。 指针可以使程序的编写过程更加灵活，但也可能因为程序员水平不高导致潜在风险，但无论如何指针都是C语言的精髓。至于引用数据类型的细节后面再说吧。 (2)类型转换 Java的类型转换与C语言差不多，分为自动(隐式)类型转换和强制类型转换。隐式类型转换发生在小数据类型与大数据类型进行运算以及整数数据类型与浮点数据类型运算的时候，这里不再赘述。需要注意，整数的默认类型为int，浮点数的默认类型为double，若要声明float类型的浮点数，需要在后面加f或者F。 强制类型转换方面，两者也差不多，通常发生在将大的数据类型转换为小的数据类型以及浮点数转换为整数的时候。需要注意的是，通常强制类型转换会导致数据精度损失以及数据溢出，且浮点数转换为整数并不是四舍五入，而是抛弃小数位。 boolean类型不可进行类型转换。 注：上面的强制类型转换仅局限于对基本数据类型进行操作，暂时不包括引用数据类型。 (3)常量声明 在C语言中，常量包括宏常量和const常量两种，前者通过在预编译阶段直接替换实现，后者通过存储在只读数据段中实现，具体实例如下： #defineX100//定义一个表示100的宏常量 constinty=100;//定义一个表示100的const常量 而Java中通过使用final关键字，其实现细节暂时不清楚，个人认为和C语言的const常量类似。实例如下： finalintz=100;//定义一个表示100的常量 2.选择语句 选择语句没什么说的，C语言和Java都是下列格式 if(条件1为真){   } elseif(条件2为真){ }   elseif(条件n为真){   } else{   } 这里不做过多解释。 3.循环语句 C语言中的三种循环方法java均可以使用，具体如下： for(循环初始化;循环条件1;循环迭代表达式){   } while(循环条件2){   } do{   }while(循环条件3) 上述三种循环方法这里不做过多解释。 另外Java中还提供了加强型for循环(foreach循环)，实例如下： int[]intArray={ }; for(inti:intArray){   } 注：其中数组可以替换为任何实现了iterable接口的类(具体后面再说吧)。 小结 今天写了不少，感觉没太大错误，之后有时间再写，但毕竟本人还是个新手，难免出错，要是有什么错误，希望读者能在评论区不吝赐教。 
第413篇文章[]
软件构造学习笔记2（Delegation委派） 目录 软件构造学习笔记 前言 一、什么是Delegation（委派） 二、不同类型的委派 1.Dependency:临时性的delegation 2.Association:永久性的delegation 3.Composition:更强的association，但难以变化 4.Aggregation:更弱的association，可动态变化 三、总结 1.委派过程 2.委派与继承 前言 学习委派机制（Delegation）时遇到一些困惑，因此查阅相关资料，结合课件和课堂笔记整理一下知识点。以下内容是个人理解，如果有不正确的地方欢迎大家指出。 一、什么是Delegation（委派） 委派：一个对象请求另一个对象的功能，于是捕获操作并发送给另一对象，进行功能调用。是复用的一种常见形式。 与继承（Inheritance）的区别：“委托”发生在object层面，运行时建立联系，而“继承”发生在class层面 二、不同类型的委派 Use(AuseB) Association(AhasB) Composition/aggregation(AownsB) 1.Dependency:临时性的delegation 两个类之间的这种暂时性的关系叫做“use-a"关系。 以下面的代码为例，Duckd想要请求FlyWithWingsf的功能，实现fly方法，在临时性的委派关系中，不需要将委托对象f存储为Duck类中的字段，只需在d.fly(f)中动态传入f，并在fly方法中通过f.fly()完成实际调用。 publicclassFlyWithWingsimplementsFlyable{ @Override publicvoidfly(){ System.out.println("Wings"); } } classDuck{ //不需要将委托的类存储为Duck类中的字段 voidfly(Flyablef){ f.fly(); } } Flyablef=newFlyWithWings(); Duckd=newDuck(); d.fly(f);//将f动态传入d中 2.Association:永久性的delegation 这是类之间的永久关系，属于has-a的关系。这种关系允许一个对象实例a让另一个对象实例b为它自己做事。 这种关系是结构化的，它指定了一种对象与另一种对象相关联，不指定行为。可以将下面的Composition/Aggregation看作是Association的两种具体形态。 classDuck{ FlyWithWingsf; //  } 3.Composition:更强的association，但难以变化 这种关系是”a-part-of“关系，一个类将另一个类作为属性或实例变量 classFlyWithWingsimplementsFlyable{ @Override publicvoidfly(){ System.out.println("flywithwings"); } } classDuck{ Flyablef=newFlyWithWings();//一个类把另一个类作为自己的属性或实例变量 voidfly(){ f.fly(); } } Duckd=newDuck(); d.fly(); 这种关系中，若对象d销毁了，则委派对象f也没有了存在的意义 4.Aggregation:更弱的association，可动态变化 这种关系是“has-a”的关系 以下面的代码为例，将另一个外部对象f，以参数形式传递给Duck类中的构造方法或其他特定方法（如本例中的setBehavior方法） publicclassCannotFlyimplementsFlyable{ @Override publicvoidfly(){ System.out.println("Cannotfly"); } } classDuck{ Flyablef; Duck(Flyablef){ this.f=f; } voidsetFlyBehavior(Flyablef){ this.f=f; } voidfly(){ f.fly(); } } 这种类型与Composition的不同在于： 1.委托的对象可以动态变化，例如运行下面这段代码 Flyablef=newFlyWithWings(); Duckd=newDuck(f);//将另一个外部对象f，以参数形式传递给Duck类的构造方法 d.fly(); Flyablef2=newCannotFly(); d.setFlyBehavior(f2);//委托的对象可以动态改变 d.fly(); 输出结果为 2.对象d销毁后，对象f和f2依然可以独立存在 三、总结 1.委派过程 通过以上分析，委派过程可以大致总结为以下三步： 1.建立委派 classDuck{ //Flyablef;//可以将委托对象f存储在rep中，也可以不存储 voidfly(){//运行时建立关系 f.fly(); } } 2.动态传入 Duckd=newDuck(f);//将另一个外部对象f，以参数形式传递给Duck类的构造方法 d.setFlyBehavior(f);//或传入其他特定方法 3.实际调用 d.fly(); 2.委派与继承 “委托”发生在object层面，而“继承”发生在class层面。如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，从而避免大量无用的方法。 例如在上述开发场景中，fly的具体实现可以有很多种（如FlyWithWings,CanNotFly)，且Duck中的fly方式也有可能发生变化，因此设计时如果设计成DuckextendsFlyableAnimal将会造成很多不便，而使用委派机制更加合适，更加灵活。 
第414篇文章[1]
计算机系统大作业 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机 学 号 1190202210 班 级 1936602 学 生 XXX 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文简述了hello.c程序从编写完成后，经过预处理，编译，汇编，链接等过程，形成可执行目标文件hello的过程，以及从进程hello的创建到执行，最后被回收的过程，并结合hello分析了内存地址，内存分配，I/O设备管理等知识，从而对计算机系统有了更加深入的理解。 关键词：预处理；编译；汇编；链接；进程；存储管理；I/O管理 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 Hello的P2P：（fromprogramtoprocess） hello.c文件经过预处理器cpp生成.i文件，再经过编译器编译，将高级语言转化为指令，生成.s文件，再经过汇编(as)生成二进制.o文件，最后经过链接器与c标准库动态链接，生成可执行的二进制目标文件hello。在shell中输入./hello参数1参数2，shell调用fork函数，execve函数创建新的进程。 020的过程：（fromzerotozero）: shell调用fork创建新的子程序，在子程序中调用execve，加载并运行helllo,映射虚拟内存，进入main函数执行目标代码。当程序运行结束后，shell父进程回收hello进程，内核删除相关数据结构。 1.2环境与工具 硬件环境：IntelCorei58265U 软件环境：Ubuntu18.04.1,Windows10 开发与调试工具:CodeBlocks，vim，gcc，edb，readelf，gdb 1.3中间结果 hello.i：预处理器cpp预处理之后的文件 hello.s：生成的汇编文件 hello.o：可重定位目标文件 hello：链接后生成的可执行目标文件 hello_elf.txt：hello的ELF分析 hello_o_elf.txt：hello.o的ELF分析 hello_o.txt：hello.o的反汇编文件 hello_obj.txt:hello的反汇编文件 1.4本章小结 本章简要介绍了hello的p2p,020过程，以及开发环境和生成的中间文件。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 概念：预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。预处理器（cpp）根据以字符#开头的命令，修改原始的c程序 作用： 根据以字符#开头的命令，修改原始的c程序 1#include 预处理指令，包含头文件的操作，将所包含头文件的指令替代 （如果头文件中包含了其他头文件，也需要将头文件展开包含） 2#define宏定义 将所有的#define删除，并且展开所有的宏定义 3处理所有条件编译指令，如#if等 4删除用户的注释 2.2在Ubuntu下预处理的命令 图2.1预处理命令 2.3Hello的预处理结果解析 1）例如在Hello.c中，#include<stdio.h>命令告诉预处理器读取系统头文件 stdio.h的内容,并把它插入程序中。其他命令类似，结果就得到了hello.i 图2.2hello.i 2）如图，发现hello.c中的注释被删除，加入了头文件 图2.3hello.i 2.4本章小结 本章介绍了hello.c经过预处理后生成hello.i文件的过程，以及预处理的概念和作用。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：利用编译程序从源语言编写的源程序产生目标程序的过程。 作用：编译器(ccl)将文本文件hello.i翻译咸文本文件hello.s,它包含一个汇编语言程序。汇编语言为不同高级语言的不同编译器提供通用的输出语言. 3.2在Ubuntu下编译的命令 图3.1编译命令 3.3Hello的编译结果解析 图3.2hello.s文件 图3.3hello.s文件 3.3.1数据 字符串常量 Printf中的字符串常量，放在.rodata段 （2）局部变量inti 是局部变量，保存在栈上，存储在-4(%rbp)处 （3）全局变量intsleepsec=2.5 图3.4sleepsec globl代表sleepsecs是全局变量，将sleepsecs存放在.data节，类型是对象,分配大小4字节，.long定义为长整型数2。 （4）参数intargc 参数，程序中通过访问栈上-20(%rbp)的位置访问。表示参数个数 （5）数组char*argv[] 是main函数的参数，在此程序hello中存放着输入的字符串姓名和学号 3.3.2赋值 （1）i=0 图3.5i=0赋值 使用指令movl将立即数0存入-4（%rbp）处 i++ 图3.6i++赋值 用addl指令完成i=i+1 3.3.3关系操作 （1）if(argc!=3) 图3.7关系比较 cmpl比较argc和3，并设置条件码，je判断是否相等，是则跳转 循环测试条件i<10 图3.8关系比较 cmpl比较i和9，jle判断若i<=9则跳转至.L4 3.3.4控制转移 （1）if(argc!=3) 图3.9条件跳转 je判断argc和3是否相等，是则跳转至.L2 for(i=0;i<10;i++) 图3.10条件跳转 jle判断若i<=9则跳转至.L4 3.3.5函数操作 （1）main main函数有两个参数，argc，和*argv[]，传参过程中，argc保存在寄存器rsi，*argv[]保存在运行时栈中 printf 图3.11调用printf 参数在%eax中准备 exit 图3.12调用exit 准备参数，参数是1 getchar 图3.13调用getchar 循环结束后被调用，无参数传递 sleep 参数被保存在%edi中传递，然后使用call调用sleep 图3.14调用sleep 3.4本章小结 本章介绍了编译的过程，通过对文件hello.s的分析，对汇编语言有了进一步理解，汇编语言为不同高级语言的不同编译器提供通用的输出语言。同时本章分析了编译过程中对赋值语句，控制转移，函数调用等过程的处理，进一步理解了编译过程。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：把汇编语言书写的程序翻译成与之等价的机器语言程序。汇编语言是为特定计算机或计算机系列设计的一种面向机器的语言，由汇编执行指令和汇编伪指令组成。 作用：汇编器（as）将hello.s翻译成机器语言指令，并把这些指令打包成可重定位目标程序的格式，将结果保存在二进制目标文件hello.o中。 4.2在Ubuntu下汇编的命令 图4.1汇编命令 4.3可重定位目标elf格式 （1）各节的基本信息： 图4.2ELF头 图4.2各节信息 .text:代码节 .rela.text一个.text节中位置的列表 .data:已初始化的全局变量，静态c变量， .bss：未初始化的全局变量和静态c变量，。 .rodata:只读数据，如printf中的格式串和switch中的跳转表， .symtab:装载符号信息 （2）重定位节 图4.3重定位节 重定位节：.rela.text,一个.text节中位置的列表，包含.text节中需要进行重定位的信息，链接时需要修改这些位置。调用本地函数的指令则不需要修改。 offset：需要进行重定向的代码在.text或.data节中的偏移位置 type：代表重定位的类型（PC相对寻址或PC绝对寻址） 符号名称：重定向到的目标对象的名称 （3）符号表 图4.4符号表 程序中定义和引用符号的信息 4.4Hello.o的结果解析 图4.5反汇编命令 汇编语言根据规则编码成机器指令，每个指令1-10个字节。 图4.6反汇编文件 图4.6反汇编文件 以上图第一个圈中的指令为例，488d3800000000中的00000000是占位符，此处需要在链接时进行重定位，通过PC相对寻址确定最终的指令字节，其余几处操作数与.s文件中不同的情况类似。以第二个圈为例，分支转移和函数调用时，同样需要在链接时通过重定位确定最后的地址，以重定位后的地址字节替换现在的机器指令中的占位符00000000 4.5本章小结 本章分析了汇编的概念及作用，分析了汇编语言和机器语言的关系，并介绍了机器指令中操作数与汇编语言不同的情况，对汇编过程以及重定位有了进一步认识。 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：链接是指将各种代码和数据片段收集并组合成为一个单一文件的过程。这个文件可以被加载到内存并执行。 作用：链接使得分离编译成为可能，不用将大型应用组织为一个巨大的源文件，而是可以将它们分解为更小，更好管理的模块，可以独立地修改和编译这些模块。当改变这些模块中地一个时，只需要重新编译它，并重新链接应用，而不必重新编译其他文件。 5.2在Ubuntu下链接的命令 命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1链接命令 链接后执行： 图5.2执行程序 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 图5.3readelf命令 ELF头： 图5.4ELF头 各段的起始地址及大小信息： 图5.5各节信息 图5.6各节信息 图5.7各节信息 5.4hello的虚拟地址空间 代码段地址从0x401000开始 图5.8edb调试 与5.3对照： .interp节，地址从0x400200开始 图5.9edb调试 .dynstr节，从0x400359开始 图5.10edb调试 .text节 地址从0x400500开始 图5.11edb调试 图5.12edb调试 .rodata节 地址从0x400640开始，printf中的格式字符串等存放在这里 图5.13edb调试 各节的起始地址及大小信息与5.3中一样 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同 图5.14objdump命令 不同： （1）hello中比hello.o中多了.init和.plt部分 图5.15对比不同 （2）增加了put,printf,getchar,exit,sleep函数，说明链接器将库里被应用程序引用的目标模块复制过来了 图5.16 对比不同 （3）重定位 在hello.o由占位符0x00占位的指令编码在hello中完成了重定位 图5.17重定位 图5.18重定位 以调用exit函数为例，在确定.text节起始地址为0x400500及exit函数地址为0x4004e0后，由refaddr=ADDR(s)+r.offset=0x400559计算出引用的运行时地址， 再由*refptr=(unsigned)(0x4004e0+(-4)–0x400559)=0xff83更新引用时的call指令为e883ffffff（在hello.o中是e800000000），完成一个重定位。 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 Edb执行过程： 图5.19 edb执行 Gdb调试过程： 图5.20gdb调试 1.从加载hello到_start调用及跳转的子程序名及地址 图5.21gdb调试 2.从_start到callmain调用及跳转的子程序名及地址 图5.22gdb调试 3.从callmain到程序终止调用及跳转的子程序名及地址 图5.23gdb调试 5.7Hello的动态链接分析 dl_init前 图5.24edb调试 dl_init后 图5.25edb调试 GOT与dl_init之前不同，即发生了动态链接 5.8本章小结 本章介绍了链接器将hello.o与动态库函数链接，最终生成可执行文件按hello的过程，包括符号解析和重定位，分析ELF头等，对链接的相关知识有了进一步了解。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：一个正在运行的程序的实例 作用：进程提供给应用程序两个关键抽象：一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器；一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 shell 是一个交互型应用级程序，代表用户运行其他程序 （1）作用：解释由用户输入的命令并且把它们送到内核 （2）处理流程： 1.读取用户由键盘输入的命令； 2.对命令进行分析，以命令名为文件名，并将其他参数改造为系统调用execve()参数处理所要求的格式； 3.终端进程(shell)调用fork()建立一个子进程； 4.子进程根据文件名（命令名）到目录中查找有关文件，将他调入内存，并创建新的文本段，并根据写时拷贝的方式创建相应的数据段、堆栈段； 5.当子进程完成处理或者出现异常后，通过exit()或_exit()函数向父进程报告； 6.终端进程调用wait函数来等待子进程完成，并对子进程进行回收； 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的、处于运行状态的子进程： intfork(void) 子进程返回0，父进程返回子进程的PID 新创建的子进程几乎但不完全与父进程相同： 子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本 子进程获得与父进程任何打开文件描述符相同的副本 子进程有不同于父进程的PID （fork函数：被调用一次，却返回两次） 6.4Hello的execve过程 intexecve(char*filename,char*argv[],char*envp[]) execve函数加载并运行可执行文件hello,在当前进程中载入并运行程序，覆盖当前进程的代码、数据、栈，继承已打开的文件描述符和信号上下文，调用一次并从不返回 6.5Hello的进程执行 一个进程执行它的控制流的一部分的每一时间段叫做时间片。内核为每个进程维持一个上下文，在进程执行地某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策叫调度。内核调度了新进程后，使用上下文切换的机制将控制转移到新的进程。 上下文切换：1.保存当前进程的上下文。2.恢复某个先前被抢占的进程保存的上下文。3.将控制传递给这个新恢复的进程。 执行hello时，调用sleep函数时，它显式地请求让调用进程休眠，进程可以执行上下文切换，运行另一个进程，休眠结束后，内核再次执行上下文切换，将控制转移到此进程。 当hello调用getchar时，实际上是执行系统read。hello运行在用户模式中，直到它通过执行系统调用read陷入内核。内核中的陷阱处理程序请求来自磁盘控制器的DMA传输，并且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。磁盘读取数据要用一段相对较长的时间，所以内核决定执行上下文切换。直到磁盘发出一个中断信号，表示数据读入内存，内核再进行上下文切换，将控制返回给hello。 图6.1 上下文切换 6.6hello的异常与信号处理 Hello执行过程中，调用printf,getchar函数时会产生的异常是陷阱，向内核请求服务；键盘按下Ctrl-Z，Ctrl-C时产生的异常是中断。 Ctrl-C 内核发送SIGINT信号给到前台进程组中的每个进程，通过ps和jobs,fg等查看，发现hello进程被回收 图6.2ctrl-c 图6.3ctrl-c （2）Ctrl+z Ctrl+z的输入发送一个SIGTSTP信号让进程停止，运行ps,jobs,fg命令查看，发现hello进程被停止 图6.4ctrl-z （3）乱按和回车 按下回车后，乱输入的字符会被当做命令处理 图6.5乱按加回车 6.7本章小结 本章介绍了进程的相关知识，包括进程的创建，回收，以及上下文切换，信号处理等知识，分析了hello进程的执行过程，具体分析了fork函数，execve函数，异常和信号处理过程，对相关知识有了进一步理解。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 （1）虚拟地址由hello程序产生的由段选择符和段内偏移地址组成的地址。 （2）逻辑地址指由程序产生的段内偏移。有时候直接把逻辑地址当做虚拟地址。例如hello中jump等跳转指令的地址。 （3）线性地址指虚拟地址到物理地址变换的中间层，是处理器可寻址的内存空间中的地址。程序代码会产生逻辑地址，也就是段中的偏移地址，加上相应的段基址就成了线性地址。如果开启了分页机制，那么线性地址需要再经过变换，转为为物理地址。如果无分页机制，那么线性地址就是物理地址。 （4）物理地址指CPU外部地址总线上寻址物理内存的地址信号，是地址变换的最终结果。计算机系统的主存被组织成一个连续的字节的单元组成的数组，每字节有唯一的物理地址 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址实际是由 48 位组成的，前 16 位包括段选择符,后 32 位段内偏移量(段指可执行文件hello中的代码段、数据段等)，通过索引在描述符表中找到段基址（Linux中段基址为0），例如指令movl8(%ebp)中有效地址EA=R[%ebp]+8,最后得到线性地址LA=段基址+EA。 7.3Hello的线性地址到物理地址的变换-页式管理 从线性地址（虚拟地址）（VA）到物理地址(PA)的变换是通过分页机制来实现的。VM系统将虚拟内存分割为称为虚拟页（VP）的大小固定块，在linux下为4KB。相应地，物理内存被分割为物理页，大小也为4KB。 CPU的页式内存管理单元MMU负责把一个线性地址转换为物理地址。例如，一个32位的机器，线性地址可以达到4G，若页大小为4KB，则划分为1M个页，即需要1M个PTE，每一项PTE存储的都是对应物理页的基地址。 7.4TLB与四级页表支持下的VA到PA的变换 TLB是一个小的，虚拟寻址的缓存，每一行保存着由单个PTE组成的块。用来压缩页表的常用方式是层次结构的页表。四级页表支持下，虚拟地址（VA）被划分为4个VPN和一个VPO，每个VPNi都是一个到第i级页表的索引，第j级页表中的每个PTE都指向第某个j+1级页表的基址。CPU产生一个VA，MMU根据VPN在TLB中搜索PTE，若命中，MMU取出相应的PTE，根据PTE将VA翻译成PA；若不命中，则通过多级页表查询PTE是否在页中，若在页中，找到对应的PTE，MMU将VA翻译成PA，若没有在页中，则进行缺页处理。如下图，L4PTE指向页的物理地址（物理页号PPN）,PPN和PPO（偏移量，和VPO相同）组成了物理地址（PA）。 图7.1 四级页表下的地址转换 7.5三级Cache支持下的物理内存访问 物理地址PA在cache的机制下由块偏移（CO）、组索引（CI）和标记（CT）组成。首先，在L1-cache中，使用组索引CI找到对应的组，在组中若存在标记位为CT且有效位为1的块，则命中，根据块偏移CO取出相应的字节发送到CPU；若不命中，则向下一级缓存中查找块（L2-cache是L1的下一级缓存，L3-cache是L2的下一级缓存，主存是L3的下一级缓存）。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核创建了一个新进程，为新进程创建各种数据结构，并分配给它唯一的PID。为了创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本，它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。任一进程进行写时操作时，写时复制机制创建新页面，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 加载并运行hello需要以下步骤： 删除当前进程虚拟地址已存在的用户区域映射私有区域。为代码，数据，bss和栈区域创建新的区域结构映射共享区域。Hello程序与C标准库libc.so等链接，这些对象都是动态链接到这个程序，然后再映射到用户虚拟地址空间中的共享区域内。设置PC，使之指向代码区域的入口点。 图7.2 内存映射 7.8缺页故障与缺页中断处理 MMU翻译虚拟地址时若触发一个缺页，控制转移到内核的缺页处理程序，执行以下步骤： 虚拟地址A是否合法，若不合法，触发段错误，终止进程。试图进行的内存访问是否合法，若不合法，触发保护异常，终止进程。若是合法操作，选择一个牺牲页面交换出去，换入新的页面并更新页表。缺页处理程序返回时，CPU重新启动引起缺页的指令，再次发送A到MMU，这时MMU正常翻译虚拟地址A，不会产生缺页。 图7.3缺页处理 7.9动态存储分配管理 分配器将堆视为一组不同大小的块(blocks)的集合来维护，每个块要么是已分配的，要么是空闲的，需要时选择一个合适的内存块进行分配。分配器有两种基本风格：显式分配器和隐式分配器。两种风格都要求应用显式的分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 分配器利用隐式空闲链表管理块的策略： 1.放置已分配的块 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲块。常见的放置策略有：首次适配、下一次适配、最佳适配。 （1）首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。 （2）下一次适配：从上一次查询结束的地方开始，搜索空闲链表，选择第一个合适的空闲块 （3）最佳适配：检查每个空闲块，选择合适所需请求大小的最小空闲块。 2.分割空闲块 如果匹配不太好，那么分配器通常会选择将这个空闲块分割为两部分。第一部分变成分配块，而剩下的变成一个新的空闲块。 3.合并空闲块 分配器可以选择立即合并或者推迟合并。立即合并就是在每次一个块被释放时，就合并所有的相邻块。推迟合并是等到某个稍晚的时候再合并空闲块。 7.10本章小结 本章分析了存储管理的相关知识，以hello为例分析了从逻辑地址到线性地址，再到物理地址的地址转换与寻址过程，介绍了hello运行时的内存映射，以及缺页故障的处理过程。此外，还分析了动态存储分配管理的基本方式和几种策略，对存储管理的相关知识有了更深入的了解。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 Linux以文件的方式对I/O设备进行读写，将设备均映射为文件。对文件的操作，内核提供了一种简单、低级的应用接口，即UnixI/O接口。 函数： 1）open 打开文件返回一个小的非负整数，即描述符。用描述符来标识文件。每个进程都有三个打开的文件：标准输入（0）、标准输出（1）、标准错误（2） 函数原型：intopen(char*filename,intflags,mode_tmode); （flags:进程打算如何访问文件； O_RDONLY:只读 O_WRONLY:只写 O_RDWR:可读可写 mode:指定新文件的访问权限位） 2）lseek 函数原型：off_tlseek(intfd,off_toffset,intwhence); 返回值：成功返回新的文件偏移量，失败-1 3）read 读操作：从文件拷贝n个字节到存储器，从当前文件位置k开始，将k增加到k+n，对于一个大小为m字节的文件，当k>=m时，读操作触发一个EOF的条件。 函数原型：ssize_tread(intfd,void*buf,size_tn); 返回值是文件读取字节数 4）write 写操作：从存储器拷贝n个字节到文件，k更新为k+n 函数原型：ssize_twrite(intfd,constvoid*buf,size_tn); 返回值：文件写入字节数 5）关闭文件 内核释放文件打开时创建的数据结构，并恢复描述符到描述符池中，进程通过调用close函数关闭一个打开的文件。（关闭一个已关闭的描述符会出错） 函数原型 intclose(intfd) 返回值：成功返回0 失败-1 8.3printf的实现分析 printf函数的函数体： intprintf(constchar*fmt, ){inti;charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 实现过程： 1）.vsprintf生成显示信息：vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 2）.调用write系统函数， write: moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL 3）.陷阱-系统调用int0x80或syscall. sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret 4）.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 最终，屏幕上显示出要显示的字符。 8.4getchar的实现分析 getchar函数的函数体： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(–n>=0)?(unsignedchar)*bb++:EOF; } 实现过程： 1）异步异常-键盘中断的处理：系统调用键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 2）getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。当用户键入回车之后，getchar才开始从stdio流中每次读入一个字符。函数的返回值是用户输入的字符的ASCII码，若读到文件结尾(End-Of-File)则返回-1(EOF)，且将用户输入的字符回显到屏幕。 8.5本章小结 本章介绍了hello的IO管理，包括对UnixIO的简介以及对printf函数和getchar函数的详细分析，对Linux的IO设备管理有了进一步认识。 （第8章1分） 结论 Hello的一生走过了以下历程： 用高级语言编写成代码hello.c,先经过预处理，生成hello.i,再经过编译，生成hello.s文件，经过汇编，生成可重定位的hello.o二进制文件。接着，链接器将hello.o与动态库函数链接到一起，生成最后的可执行文件hello。在shell中执行./hello,开始为hello创建进程并将hello程序加载到内存中运行，如遇到异常则要进行异常，最后程序执行结束，进程被回收，hello结束了它的一生。 我对计算机系统的设计与实现的感悟：本门课程的知识量很丰富，计算机系统的设计与实现是一个复杂的过程，其中需要考虑各种各样的因素，为了更好的性能还需要不断尝试和创新。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.i：预处理器cpp预处理之后的文件 hello.s：编译生成的汇编文件 hello.o：汇编后的可重定位目标文件 hello：链接后生成的可执行目标文件 hello_elf.txt：hello的ELF分析 hello_o_elf.txt：hello.o的ELF分析 hello_o.txt：hello.o的反汇编 hello_obj.txt:hello的反汇编文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1]兰德尔E.布莱恩特,大卫R.奥哈拉伦.深入理解计算机系统.机械工业出版社 [2]虚拟地址、逻辑地址、线性地址、物理地址-简书(jianshu.com) [3]https://baike.baidu.com/item/%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/10204389?fr=aladdin百度百科：预处理命令 [4]https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343?fr=aladdin百度百科：编译 [5]编译原理入门篇|一篇文章理解编译全过程-fishers-博客园(cnblogs.com) 
第415篇文章[]
软件构造学习4（以ArrayList和LinkedList为例理解表示独立性repindependence) 目录 一、什么是表示独立性（RepresentationIndependence） 二、以List为例 1.ArrayList 2.LinkedList 3.总结 三、表示独立性的重要性 一、什么是表示独立性（RepresentationIndependence） 表示独立性：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端（除非ADT的操作指明了具体的pre-和post-condition，否则不能改变ADT的内部表示） 二、以List为例 List接口继承collection接口，添加了插入、删除、查找等方法。其实现有两种，但List提供的操作表现的内容与其用LinkedList还是Array无关 Eget(intindex); Eset(intindex,Eelement); voidadd(intindex,Eelement); Eremove(intindex); intindexOf(Objecto); intlastIndexOf(Objecto); ListIterator<E>listIterator(); ListIterator<E>listIterator(intindex); List<E>subList(intfromIndex,inttoIndex); 1.ArrayList 内部表示如下，可以看到使用了数组实现 privatetransientObject[]elementData;//支撑数组 privateintsize; 当增加元素到列表结尾时，实现如下 publicbooleanadd(Ee){ ensureCapacityInternal(size+1);//确保内部数组有足够的空间 elementData[size++]=e;//将元素加入到数组的末尾 returntrue; } 可以看到如果ArrayList容量满足需求时，add()其实就是直接对数组进行赋值，因此性能很高。 2.LinkedList 内部表示如下，使用了双向链表数据结构 privatetransientEntry<E>header=newEntry<E>(null,null,null); privatetransientintsize=0; 当增加元素到列表结尾时，实现如下 voidlinkLast(Ee){ finalNode<E>l=last; //构建一个新节点newNode finalNode<E>newNode=newNode<>(l,e,null); //将newNode作为尾节点 last=newNode; if(l==null) first=newNode; else l.next=newNode; size++; modCount++; } LinkedList由于使用了链表结构，每次元素的增加都需要新建一个node对象，并进行插入操作，很多情况下会对性能会有所影响。 3.总结 可以看到，不同的内部表示会影响方法的性能，但是client使用List时无需考虑其内部如何实现，使用时都是通过list.add(),list.remove()等进行操作，与其用LinkedList还是Array无关。 三、表示独立性的重要性 下面的代码是一个破坏了表示独立性的例子 /** *Representsafamilythatlivesinahouseholdtogether. *Afamilyalwayshasatleastonepersoninit. *Familiesaremutable. */ classFamily{ publicList<Person>people; publicList<Person>getMembers(){ returnpeople; } } 在Family类中使用的内部表示是List<Person>，当客户端使用下面的方式访问家庭成员时，就破坏了表示独立性 voidclient1(Familyf){ Personbaby=f.people.get(f.people.size()-1);   } } 当Family中修改代码，将内部表示改变为Set<Person>后， classFamily{ Set<Person>p; List<Person>getMembers(){ returnnewArrayList<>(p); } } 客户端的代码就不能适应变化。但是根据表示独立性，ADT内部表示的变化不应影响外部spec和客户端，因此正确的实现应该如下 voidclient2(Familyf){ Personanybody=f.getMember().get(0);   } } 
第416篇文章[]
java设计模式--对象适配器模式 目录 一、适配器模式（AdapterPattern)的思想 二、适配器模式中的三个角色 三、对象适配器模式 总结 适配器模式的优点 一、适配器模式（AdapterPattern)的思想 思想：把一个类/接口转换为客户端期望的形式。 这样做的好处： 1.使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 2.通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。 二、适配器模式中的三个角色 目标(Target):客户端期待得到的接口。源(Adaptee):需要被适配的接口。适配器(Adapter)：连接目标和源，把源接口转换成期待的目标接口。 适配器模式包括3种形式：类适配器模式、对象适配器模式、接口适配器模式。本文主要介绍对象适配器。 三、对象适配器模式 在对象适配器模式中，目标ITarget是一个与客户端需求匹配的接口，适配器Adapter和源Adaptee之间是委派关系（delegation）。 以下面的代码为例： 客户端想调用LegacyRectangle中的方法，画出一个长方形。这个例子中LegacyRectangle类就是源。但是客户端想要传入的是左上角的顶点和右下角的顶点，而源Adaptee中的方法需要的参数是左上角的顶点，以及宽和高，出现了不适配。 classClient{ publicdisplay(){ newLegacyRectangle().display(x1,y1,x2,y2);//客户端想要传入左上角的顶点和右下角的顶点 } } classLegacyRectangle{ voiddisplay(intx1,inty1,intw,inth){  //源Adaptee中的方法需要的参数是左上角的顶点，以及宽和高 } } 此时通过对象适配器模式，先增加一个接口shape，这个接口与客户端的要求适配。（客户端对抽象接口编程，与LegacyRectangle隔离） interfaceShape { voiddisplay(intx1,inty1,intx2,inty2); } 再用一个Rectangle类实现shape接口，此时Rectangle充当的是Adapter的角色，通过与LegacyRectangle类建立委派关系完成display方法的实现。 classRectangleimplementsShape{ voiddisplay(intx1,inty1,intx2,inty2){ newLegacyRectangle().display(x1,y1,x2-x1,y2-y1);//通过委派完成display } } 此时客户端的代码实现如下： classClient{ Shapeshape=newRectangle();//客户端对抽象接口编程，与LegacyRectangle隔离 publicdisplay(){ shape.display(x1,y1,x2,y2); } } 可以看到，通过适配器Rectangle,解决了LegacyRectangle与客户端期望形式不匹配的问题，实现了代码的复用。 总结 适配器模式的优点 代码复用：使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。可以复用已经实现的类的功能。 封装：通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。 
第417篇文章[]
软件构造（规约的强弱） 目录 一、什么是规约（spec) 二、规约的强弱 1.以下面的代码为例 2.Note 一、什么是规约（spec) 规约是写在方法前面的注释，用来解释方法的功能、参数、返回值等 为什么要为每个方法写规约？ 1.精确的规约，有助于区分责任 2.客户端无需阅读调用函数的代码，只需理解spec即可 3.规约可以隔离“变化”，无需通知客户端 规约的结构： 1.对方法的解释 2.前置条件：对客户端的约束，在使用方法时必须满足的条件 3.后置条件：对开发者的约束，方法结束时必须满足的条件 二、规约的强弱 定义：规格说明S2强于（等于）规格说明S1，如果： S2的前置条件弱于或等价于S1的S2的后置条件强于或等于S1的后置条件。 即：spec变强意味着更放松的前置条件+更严格的后置条件 1.以下面的代码为例 版本1中，对find方法的规约中，前置条件中规定val在数组a中出现有且仅有一次 再看版本2 此时前置条件规定val应该出现至少一次，因此前置条件变弱了，所以spec更强了 再看版本3 和版本2比，在满足前置条件的情况下，后置条件变强了，所以spec更强了 2.Note 需要注意的是，两个specS1和S2比较时，一定要在满足前置条件的情况下比较后置条件的强弱 看下面这个例子 单看后置条件，S2的后置条件比S1更强，但是在满足S1的前置条件，即满足val在数组a中至少出现一次的条件时，其实S2的后置条件与S1相比并没有变化。前置条件更弱，后置条件不变，因此S2比S1更弱了。 
第418篇文章[]
Java中的等价性 目录 一、相等（Equality） 二、==与equals() 1.== 2.equals 3.总结 三、不可变类型的等价性 总结 一、相等（Equality） 我们可以从三个角度来看待ADT中的相等： 1.从ADT中的抽象函数AF（abstractfunction）：如果AF(a)=AF(b)，我们就说a和b相等。 2.从关系的角度 等价关系是指对于关系E⊆TxT，它满足： 自反性:E(t,t)∀t∈T对称性:E(t,u)⇒E(u,t)传递性:E(t,u)∧E(u,v)⇒E(t,v) 3.从外部观察者角度：对两个对象调用任何相同的操作，都会得到相同的结果，则认为这两个对象是等价的。 二、==与equals() Java有两种判断相等的操作：==和equals 1.== ==比较的是引用，也就是说，测试的是引用等价性。如果两个索引指向同一块存储区域，那它们就是==的。 2.equals equals()操作比较对象内容，也就是测试的是对象等价性。 在自定义ADT时，需要重写Object的equals() 3.总结 使用： 对基本数据类型，使用==判定相等 对对象类型，使用equals()。如果用==，是在判断两个对象身份标识ID是否相等（即是否指向内存里的同一段空间） 三、不可变类型的等价性 在Object中实现的缺省equals()是在判断引用等价性，实现如下 publicclassObject{   publicbooleanequals(Objectthat){ returnthis==that; } } 重写与重载 在方法签名中犯一个错误很容易，并且当您打算覆盖它时重载一个方法。只要你的意图是在你的超类中重写一个方法，就应该使用Java的批注@Override。通过这个注解，Java编译器将检查超类中是否存在具有相同签名的方法，如果签名中出现错误，则会给出编译器错误。 总结 相等应该满足等价关系（自反、对称、传递）。相等和哈希必须互相一致，以便让使用哈希表的数据结构（例如 HashSet 和 HashMap）正常工作。抽象函数是不可变类型相等的比较基础。索引是可变类型相等的比较基础。这也是确保相等一致性和保护哈希表不变量的唯一方法。 
第419篇文章[]
软件构造 关于RI与AF 1.基本概念 以PPT为依据整理一下主要概念：表示独立性（Representationindependent）：client使用ADT时无需考虑其内部如何实现，ADT内部的变化不应影响外部spec和客户端。不变量（Invariant）：程序的一个属性，对于程序的每一个可能的运行时状态，它总是为真。例如：immutability就是一个典型的“不变量”。表示域（R）：包含的是值具体的实现实体的空间。一般情况下ADT的表示比较简单，有些时候需要复杂表示。抽象域（A）：包含的是类型设计时支持使用的值的空间。这些值是由表示域“抽象/想象”出来的，也是使用者关注的。抽象函数（Abstractionfunction）：R和A之间映射关系的函数。AF：R→A表示不变量（Repinvariant）：将表示空间的值映射到布尔值。RI:R→booleanSafetyfromRepExposure：防止表示泄露的方法 2.实际运用 在代码编写中，我们一般会在一个Class开头写下注释，内容包含：AF，RI和SafetyfromRepExposure。以下面的代码为例：可以看到，在开头的注释里就包含了这三部分。其中，AF就是说明将一个抽象的东西，表示成程序可以表示的东西。在这里，我们将一张图G表示为G中所有的点v的集合。RI就是对所有表示值的一个子集，包含了所有合法的表示值。也可以看做：一个条件，描述了什么是“合法”的表示值。在这里，我们对所有点v做出了要求。SafetyfromRepExposure就是对安全性的策略。在这里，我们保证所有field都是private，每个method返回的都是变量的赋值，点的元素都是immutable的。 3.保护不变量 如何保护表示不变量呢，一般情况下有如下几种做法： 通过私有变量来保护通过防御式拷贝防止泄露写规格说明（通常无用）使用Collections.unmodifiableList()这类方法来返回不变量 
第420篇文章[]
软件构造 关于等价性 关于等价性 在学到ADT的等价性的时候，有三条基本原则，即：自反、传递、对称。其中，自反和对称往往是满足的，但传递常常出现一些问题。比如，在课堂上就出现了这样一个例子： 显然，这个equals()不满足于传递性，问题就出现所谓的误差值CLOCK_SKEW上。由于误差值在传递的过程中会不断累加，从而导致了最终超过可容忍的误差值的情况。 但这种设置误差值的方法是经常使用的，比如在ACM的很多计算几何题目中，就大量采用了误差值的方法。以二维为例：设一个误差值eps（通常很小），对两点A(x1,y1)和B(x2,y2)，当这两点间距离 d i s ( A , B ) = ( x 1 − x 2 ) 2 + ( y 1 − y 2 ) 2 ≤ e p s dis(A,B)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}\leqeps dis(A,B)=(x1​−x2​)2+(y1​−y2​)2 ​≤eps时，将A与B视为同一点。 这个方法是非常实用的，因为它很好地解决了计算机浮点运算中精度误差的问题。但这样的代价就是破坏了等价关系的传递性。 从某种意义上来说，我们经常不得不对程序的实用性与准确性进行取舍，这一点在等价性关系上展现得很好。 解决方案 那么，有没有既满足实用性，又满足等价性的解决方案呢？我有一个初步的想法。以一维线段为例：设左端点为0，右端点为10。将其等距地划分为n段，则每个区间形成了一个等价类。 equals(A,B)：当A和B在同一个区间内时，认为A和B是等价的。否则A和B不等价。 显然，这个equals()是满足等价性的三个原则的：A与B等价，B与C等价，则说明ABC在同一组内，那么A与C等价。这个equals()是运用了分块算法的想法：块内统一管理。但面对块间的情况时，equals()就不能发挥作用了：只要A与B在不同的块内，哪怕 d i s ( A , B ) ≤ e s p dis(A,B)\leqesp dis(A,B)≤esp，A与B也不等价。这就是对实用性的牺牲。同时，我们发现n要尽量的大。上图中分别为n=2和n=5的情况，显然n=5的情况中equals()更为精准，不容易出现跨块的情况。 改进方案 正如数学上的插值法所说明的：当等距的方法到达瓶颈后，不妨试一下不等距的情况。由于我们开发的是软件，面对的是实际情况的数据，而实际情况的数据又一般具有一些规律，如：符合正态分布。因此我们可以根据数据的分布情况来改变分块的策略。不妨假设输入数据满足正态分布：对上图进行改造：可以看到2、3两条线段中都是n=5，但是由于数据常常出现在中间部分，两头的数据会较少，因此线段3改变了策略，将端点设置在了{1,2,8,9}。 
第421篇文章[6]
李宏毅机器学习（1） Regression 1.什么是Regression Regression，有道词典翻译为拟合，就是构建一个函数，通过输入特征值，得到预测的结果。举例说明：①股市预测②自动驾驶③商品推荐由此可见，Regression可以做很多东西，其主要功能还是预测。 Regression的步骤 一个有趣的例子就是预测宝可梦进化后的CP（战斗力）值。问题可以描述为： 输入：宝可梦进化前的CP值，种类，属性，血量，重量，高度。输出：宝可梦进化后的CP值。 Step1确定模型 模型的种类有很多，但最经典的还是多项式模型，其中最简单的就是线性模型。这一题中用的就是多项式函数模型，不妨先认为进化前的cp值（x值）和进化后的cp值（y值）满足线性关系。 y=w·x+b 显然我们要求的就是w和b值。 Step2GoodnessofFunction 1、获取trainingdata 为了让我们的函数走向正确的道路，我们还需要采集数据，形成trainingdataset，引导函数参数的变化。 2、设计LossFunction 为了评价我们设计的function的好坏（goodnessoffunction），还需要设计一个LossFunction，它将构建好的函数作为参数，输出一个数值。LossFunction的值越小，则代表这个函数越好。本题中，使用了最小二乘法的Lossfunction。 Step3找到最好的函数BestFunction 1、什么是最好的函数 很显然，最好的函数就是预测最准的函数，即：令L(f)最小的函数。记为argminL(f)。尽管用线性代数就能解决这个问题，但为了后续更复杂问题的解决，要使用下面的方法。 2、GradientDescent梯度下降法 在本题中，函数比较简单，是普通多项式函数，且为linerfunction，直接给出GradientDescent的步骤： 设 f ( x 1 , x 2 . . . x n ) f(x_1,x_2 x_n) f(x1​,x2​ xn​)对 x 1 , x 2 . . x n x_1,x_2..x_n x1​,x2​..xn​都可求微分设计一个值 η > 0 η>0 η>0，称这个 η \eta η为learningrate随机的选择一个点 P 0 ( x 1 , x 2 . . . x n ) P_0(x_1,x_2 x_n) P0​(x1​,x2​ xn​)每次通过迭代从 P m P_m Pm​得到 P m + 1 P_{m+1} Pm+1​： x 1 ′ = x 1 − η α L α x 1 ∣ P m x_{1}^{'}=x_1-η\frac{αL}{αx_1}|_{P_m} x1′​=x1​−ηαx1​αL​∣Pm​​, x 2 ′ = x 2 − η α L α x 2 ∣ P m x_{2}^{'}=x_2-η\frac{αL}{αx_2}|_{P_m} x2′​=x2​−ηαx2​αL​∣Pm​​… x n ′ = x n − η α L α x n ∣ P m x_{n}^{'}=x_n-η\frac{αL}{αx_n}|_{P_m} xn′​=xn​−ηαxn​αL​∣Pm​​经过多次迭代，得到globaloptimal（全局最优解）‘’ 原理：因为这里的LossFunctionL是凸的，linerregression没有localoptimal。 
第422篇文章[]
软件构造 关于面向对象设计原则 1.五大原则 我们在学习面向可维护性的构造技术时，学习了面向对象设计的五大原则，掌握这些原则能帮助我们更好的理解面向对象的概念，也能更好的理解设计模式。 2.SRP单一责任原则 不应该有多于1个原因让你的ADT发生变化，否则就拆分开。 单一职责原则的优点： 类的复杂性降低，实现什么职责都有明确的定义；逻辑变得简单，类的可读性提高了，而且，因为逻辑简单，代码的可维护性也提高了；变更的风险降低，因为只会在单一的类中的修改。 3.OCP开放-封闭原则 分为两部分。 对扩展性的开放：模块的行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化。对修改的封闭：模块自身的代码是不应被修改的，扩展模块行为的一般途径是修改模块的内部实现，如果一个模块不能被修改，那么它通常被认为是具有固定的行为。 4.LSPLiskov替换原则 子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异。简单概括：只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何异常。但是反过来就不行了，因为子类可以扩展父类没有的功能，同时子类还不能改变父类原有的功能。具体来说： 子类型可以增加方法，但不可删除。子类型需要实现抽象类型中的所有未实现方法。子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance的参数。子类型中重写的方法必须使用同样类型的参数或者符合contra-variance的参数。子类型中重写的方法不能抛出额外的异常。 5.ISP接口隔离原则 不能强迫客户端依赖于它们不需要的接口：只提供必需的接口。意思就是客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，这就需要对接口进行细化，保证接口的纯洁性。换成另一种说法就是，类间的依赖关系应该建立在最小的接口上，也就是建立单一的接口。 6.DIP依赖转置原则 抽象的模块不应依赖于具体的模块，具体应依赖于抽象。在Java语言中，抽象就是指接口或抽象类，两者都不能被实例化；而细节就是实现接口或继承抽象类产生的类，也就是可以被实例化的实现类。依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的，这就是俗称的面向接口编程。 
第423篇文章[]
软件构造 关于设计模式 1.设计模式 在软件构造的学习中，我们学习了几种设计模式，这里做出一个汇总和分类。 创建型模式结构型模式行为类模式 2.创建型模式 (1).工厂方法模式 当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 3.结构型模式 (1).适配器模式 将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。 (2).装饰器模式 装饰者模式用每个子类实现不同的特性，在我们需要大量有重复属性但是同时又有特定属性的时候，使用单纯地继承委托等方法可能会造成组合爆炸、大量代码重复等等问题。而装饰器模式能很好地解决这个问题。其问题是为对象增加不同侧面的特性，解决方式是对每一个特性构造子类，通过委派机制增加到对象上，其工作原理是以递归的方式实现，接口：定义装饰物执行的公共操作，起始对象，在其基础上增加功能(装饰)，将通用的方法放到此对象中。Decorator抽象类是所有装饰类的基类，里面包含的成员变量component指向了被装饰的对象。 3.行为类模式 (1).策略模式 有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。 (2).模板模式 有些问题做事情的步骤一样，但具体方法不同。共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。 (3).迭代器模式 客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型。也就是说，不管对象被放进哪里，都应该提供同样的遍历方式。Iteratorpattern：让自己的集合类实现Iterable接口，并实现自己的独特Iterator迭代器(hasNext,next,remove)，允许客户端利用这个迭代器进行显式或隐式的迭代遍历。 (4).访问者模式 对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。本质上：将数据和作用于数据上的某种/些特定操作分离开来。为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT。 
第424篇文章[1]
程序人生-Hello’sP2P 摘要本文介绍了在Linux操作系统下hello的整个生命周期。借助gcc，objdump等工具，对hello的预处理、编译、汇编、链接等过程进行分析。并对程序hello运行过程中的动态链接库调用、内存管理、系统级I/O等进行介绍。关键词：预处理；编译；汇编；链接；进程；内存管理；IO； 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-5-1.4本章小结-5-第2章预处理-6-2.1预处理的概念与作用-6-2.2在Ubuntu下预处理的命令-6-2.3Hello的预处理结果解析-6-2.4本章小结-7-第3章编译-8-3.1编译的概念与作用-8-3.2在Ubuntu下编译的命令-8-3.3Hello的编译结果解析-8-3.4本章小结-14-第4章汇编-15-4.1汇编的概念与作用-15-4.2在Ubuntu下汇编的命令-15-4.3可重定位目标elf格式-15-4.4Hello.o的结果解析-19-4.5本章小结-20-第5章链接-21-5.1链接的概念与作用-21-5.2在Ubuntu下链接的命令-21-5.3可执行目标文件hello的格式-21-5.4hello的虚拟地址空间-26-5.5链接的重定位过程分析-27-5.6hello的执行流程-29-5.7Hello的动态链接分析-30-5.8本章小结-30-第6章hello进程管理-31-6.1进程的概念与作用-31-6.2简述壳Shell-bash的作用与处理流程-31-6.3Hello的fork进程创建过程-31-6.4Hello的execve过程-32-6.5Hello的进程执行-33-6.6hello的异常与信号处理-33-6.7本章小结-35-第7章hello的存储管理-36-7.1hello的存储器地址空间-36-7.2Intel逻辑地址到线性地址的变换-段式管理-36-7.3Hello的线性地址到物理地址的变换-页式管理-37-7.4TLB与四级页表支持下的VA到PA的变换-42-7.5三级Cache支持下的物理内存访问-43-7.6hello进程fork时的内存映射-44-7.7hello进程execve时的内存映射-45-7.8缺页故障与缺页中断处理-46-7.9动态存储分配管理-47-7.10本章小结-50-第8章hello的IO管理-51-8.1Linux的IO设备管理方法-51-8.2简述UnixIO接口及其函数-51-8.3printf的实现分析-52-8.4getchar的实现分析-53-8.5本章小结-54-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介P2P：C语言源代码文件（Program）hello.c被GCC编译器的驱动程序读取，通过四个步骤被翻译为可执行文件hello：预处理阶段：C预处理器根据#include命令和#define声明拓展源代码，生成了另一个C程序hello.i；编译阶段：编译器（ccl）产生源文件的汇编代码hello.s；汇编阶段：接下来，汇编器（as）会将汇编代码hello.s转化成二进制目标代码hello.o；链接阶段：最后，链接器（ld）将目标代码文件hello.o与实现库函数的代码合并，并生成最终的可执行代码文件hello。之后执行该文件会将该文件加载在内存中，由系统执行。这时，在shell中运行它，OS（进程管理）会通过fork来为其创建一个新的进程（Process）。这样就完成了P2P（FromProgramtoProcess）过程。 O2O：可执行文件hello运行时shell会为其分配对应的虚拟内存空间。在开始运行进程的时候分配并载入物理内存，开始执行hello的程序，在CPU的帮助下，它的指令被一步步执行，成功在屏幕上输出程序运行完成后系统会回收hello进程并且删除内存中对应的数据，完成O2O（FromZero-0toZero-0）过程。1.2环境与工具1.2.1硬件环境联想拯救者y7000CPU:Intel®_Core™i7-9750HF_CPU@_2.60GHz内存(RAM):16GB硬盘:WDCWDS100T2B0C-00PXH01.2.2软件环境Windows10家庭中文版Ubuntu18.04LTS64位1.2.3开发工具gcc(GCC)9.2.0GNUMake4.2.1GNUEmacs26.31.3中间结果hello.i预处理后修改了的源程序hello.s汇编生成的hello的汇编程序hello.o编译生成的hello的可重定位目标程序hello链接生成的hello的可执行目标程序asm.txthello.o的反汇编文件1.4本章小结本章简述了hello的P2P，O2O过程，介绍了编写本文时的工作环境。 第2章预处理2.1预处理的概念与作用概念：预处理就是预处理器根据#标识的命令（头文件、宏定义、条件编译等），修改原始c代码，将包含的头文件插入到c代码中，并将宏定义进行替换，去除注释等，形成一个.i文本文件。作用：1.程序的预处理过程就是将预处理指令（可以简单理解为#开头的正确指令）转换为实际代码中的内容（替换）2.#include<stdio.h>,这里是预处理指令，包含头文件的操作，将所包含头文件的指令替代3.如果头文件中包含了其他头文件，也需要将头文件展开包含2.2在Ubuntu下预处理的命令cpphello.c>hello.i 图21hello.c的预处理2.3Hello的预处理结果解析 图2-2hello.c 图2-3hello.i可以观察到，预处理后文件变大了很多，原本的#include全部消失，变为stdio.h等头文件的代码。但主体代码缺没有任何改变。2.4本章小结本章节简单介绍了c语言在编译前的预处理过程，简单介绍了预处理过程的概念和作用，对预处理过程进行演示，并举例说明预处理的结果还有解析预处理的过程。 第3章编译3.1编译的概念与作用编译：即编辑器将某种编程语言转化为汇编代码的过程。在本例中就是将hello.i转化为hello.s。作用：将高级语言源程序翻译成等价的目标程序,并且进行语法检查、调试措施、修改手段、覆盖处理、目标程序优化等步骤。3.2在Ubuntu下编译的命令gcc-m64-no-pie-fno-PIC-Shello.i-ohello.s 图3-1编译指令3.3Hello的编译结果解析3.3.1.数据本例中，hello.c中数据类型有：整型，字符串和数组。3.3.1.1.整型C程序的全局变量，已初始化的存放在.data节，未初始化的或初始化为0的存放在.bss节。hello中没有全局变量。对于局部变量，程序要么存在寄存器中，要么存在用户栈中，函数返回时恢复栈帧。例如，在hello.s中，循环变量i采用了存放在用户栈中的方法（如图3-2所示），-4(%rbp)就是循环变量i。 图3-2临时变量i3.3.1.2.字符串hello.c中有两个字符串，即：1.printf(“Usage:Hello学号姓名！\n”);2.printf(“Hello%s%s\n”,argv[1],argv[2]);字符串都声明在.section与.rodata中，在hello.s中以如下形式出现： 图3-3字符串在汇编代码的存储3.3.1.3.数组main函数中的第二个参数char*argv存储在栈上。在汇编代码中，存放在-32(%rbp)。 图3-4argv在汇编代码的体现3.3.2.赋值赋值操作一般用movq指令实现。如hello.s中，就将循环变量i的初始值设为0（图3-3的第二个红框）。已初始化全局变量的初始值直接保存在.data段内，无需mov指令。3.3.3.算术操作常见的算数操作指令如图3-5所示： 图3-5算数操作汇编指令 hello.s中只有一处算数操作，即i++运算。在汇编代码中用addl指令实现。 图3-6算数操作汇编指令hello.s中无逻辑运算操作。3.3.4.关系操作hello.c中有用到的关系操作有：“!=”和“<”。（1）“!=”运算比较通过cmp来实现，指令根据两个操作数之间的差值来设置条件码。如果两个操作数相等，则标记条件码ZF=1，表示两个数是相等的。如果第一个操作数比第二个小，则设置条件码SF=1,表示比较结果为负数，计算机会根据这些条件码来决定跳转。所以“!=”通过如下代码实现： 图3-7不等语句在汇编代码的体现（2）“<”运算类比与“!=”实现： 图3-8小于语句在汇编代码的体现3.3.5.数组操作hello.c中，argv是char*型的数组。argv作为hello的第二个参数，其首元素地址存放在寄存器%rdi中，之后被放进栈空间中的-32(%rbp)位置。引用数组元素时，用“基地址加偏移量”的方式寻址，如图3-4所示。 图3-9hello中argv数组的引用方式3.3.6.控制转移第一处是判断argv是否等于3，若不等于，则继续执行，若等于，则跳转至L2处（循环前对i初始化）继续执行。 图3-10第一处控制转移第二处是对i初始化为0后的无条件跳转，以跳到L4,即循环部分代码。 图3-11第二处控制转移第三处是判断是否达到循环终止条件（i<10），这里用i与9进行比较，若小于等于则跳回L4重复循环，否则执行循环外的下一步。这里将i<10的比较改为了与其等价的i<=9。 图3-12第三处控制转移3.3.7.函数操作hello.c中涉及函数main，printf，exit，sleep，atoi和getchar。（1）main函数main是整个程序的入口，系统传入参数argc，argv，通过寄存器%rdi（%edi）和%rsi传入，在开始时将这两个参数圧入栈中便于使用寄存器，由系统调用。如下： 图3-13main函数将参数压入栈在汇编代码的体现最后main函数返回值为0，通过%rax（%eax）。 图3-14main函数返回语句在汇编代码的体现（2）prinft函数第一次调用及其汇编代码： 图3-16第一次调用printf语句及其汇编代码其中$.LC0就是字符串"Usage:Hello学号姓名！\n"对应的地址。由于原字符串以’\n’结束，且printf没有其他参数用于格式化，所以编译器优化为puts函数。第二次调用及其汇编代码： 图3-17第二次调用printf语句及其汇编代码由于argv已经被圧入栈了，所以要通过-32(%rbp)+bias来访问。然后我们就可以将参数放入%rdi（%edi）、%rsi和%rdx三个寄存器中。（3）exit函数exit的作用是直接结束程序，同样通过%edi传入参数，就是整个程序的返回值。 图3-18调用exit语句的汇编代码（4）sleep函数sleep传入的参数是atoi的返回值，通过%edi传入。 图3-19调用sleep语句的汇编代码（5）getchar函数getchar可以直接调用，会返回输入的字符。其结果保存在寄存器%eax中。。 图3-20调用getchar语句的汇编代码3.4本章小结本章显示简述了编译的概念和作用，具体分析了一个c程序是如何被编译器编译成一个汇编程序的过程，还详细分析了不同的c语句和翻译成汇编语句之后的表示方法。 第4章汇编4.1汇编的概念与作用概念：汇编器as将汇编程序hello.s文件转化为二进制机器码文件hello.o的过程叫做汇编，它把汇编指令打包成一种叫做可重定位目标程序的格式。作用：利用汇编器将汇编指令翻译成二进制字节码，形成可执行可链接格式文件（即ELF文件），使之在链接后能够被机器执行。4.2在Ubuntu下汇编的命令ashello.s-ohello.o 图4-1汇编指令4.3可重定位目标elf格式4.3.1.ELF文件信息输入如下命令可以查看hello.o的ELF信息：readelf-ahello.oELF是一种Unix二进制文件，它可能是可链接文件，也可能是可执行文件。图4-2概括了一个典型的ELF文件中的各类信息。 图4-2ELF可执行文件的结构 4.3.2.ELF头ELF头的信息如图4-3所示。可以看到，ELF头以一个16字节的序列（7f454c46020101000000000000000000）开始，描述了使该文件得以运行的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器.语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移、以及节头部表的大小和数目。 图4-3ELF头信息4.3.3.节头部表节头部表如图4-4所示。描述了ELF文件中各节的基本信息，包括位置和大小等。此外，节的一般属性和功能，由旗标描述。为了保持内存对齐，各节往往还需要一定大小的对齐填充，这个大小也在表中。 图4-4hello.o的节头部表4.3.4.重定位节接下来是重定位条目表，如图4-5所示。汇编器每遇到一个对最终位置的目标的引用，就会生成一个重定位条目。表有五列，分别是偏移量、信息、类型、符号值和符号名称+加数。 图45重定位条目表(1)偏移量，是指所引用的符号的相对偏移，或者说符号应该填在程序的哪个位置。例如，第二行中，puts的偏移量为0x00000000001b。这就相当于告诉链接器，需要修改开始于偏移量0x1b处的32位PC相对引用，使它在运行时指向puts函数。(2)信息，包括符号和类型两部分，共占8个字节。其中，前4个字节表示符号，后4个字节表示类型。符号代表重定位到的目标在.symtab节中的偏移量，类型则包括相对地址引用和绝对地址应用。(3)类型，就是对第二列中类型信息的翻译。(4)符号值，就是符号代表的值。(5)第五列分为两部分。符号名称是重定位目标的名字，可能是节名、变量名、函数名等；加数则是用于对被修改的引用值做偏移调整。最后是.symtab节，即符号表。它保存了程序中所用的各种符号的信息，包括文件名、函数名、全局变量名、静态（私有）变量名等，如图4-6所示。 图46符号表4.4Hello.o的结果解析使用objdump反汇编的结果如下： 图4-7hello.o的反汇编代码与第3章的hello.s进行对照我们会发现：（1）伪指令消失原本hello.s中的许多以’.'开始的伪指令，在反汇编代码中都消失了。（2）条件分支变化我们可以发现，在hello.s中跳转到的目标位置都是用.L3/.L4来表示的，在hello.o反汇编之后，这些目标被用具体的地址位置代替。（3）函数调用变化反汇编代码中的函数调用call指令是用相对地址寻址的，而在汇编码中中则是用函数名（符号）。这是因为hello.c源代码中调用的函数是共享库中的函数（如printf、getchar等），在动态链接器链接之前无法确定函数运行时的实际地址。所以，对于这些地址不确定的函数调用，在编译时要用符号占位，汇编时则要使用相对地址（偏移）。（4）数据访问变化汇编码中，访问全局变量时，使用段名称+%rip，在反汇编代码中则是X+%rip（其中X显示为全0，实际上是重定位条目）。这是因为.rodata段的地址也是在运行时方能确定，所以对.rodata中数据的访问也需要重定位。而设置重定位条目的工作是在汇编阶段完成，从而造成汇编码和返回编码的不同。4.5本章小结本章介绍了汇编。汇编器（as）将汇编代码hello.s转化为可重定位目标文件hello.o，得到一个可以用于链接的二进制文件。通过readelf我们可以查看hello.o的elf信息和重定位信息。通过对比hello.o的反汇编和第3章的hello.s，对汇编过程有更深的理解。 第5章链接5.1链接的概念与作用概念：链接是将各种代码和数据片段收集并组合称为一个单一文件的过程。作用：链接可以执行于编译时,也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。5.2在Ubuntu下链接的命令ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5-1链接指令5.3可执行目标文件hello的格式输入如下命令可以查看hello的ELF信息：readelf-ahelloELF头信息如图5-2所示 图52hello的ELF头各节信息如图5-3所示。信息包括各节的名称、大小、属性和相对偏移量等。 图53hello的ELF各节信息程序头部表如图54所示。 图54hello的程序头部表段映射和动态节项目信息如图55所示。 图55hello的段映射和动态节项目重定位条目信息如图56所示。 图56hello的重定位条目符号表信息如图57所示。 图57hello的符号表（部分）5.4hello的虚拟地址空间用edb打开hello。如图58所示，从DataDump窗口中不难看出，hello隔断的虚拟地址空间被限制在0x400000到0x401000之间。 图5-8hello的虚拟内存不难发现，DataDump中展示的虚拟内存内容和readelf展示的节表是相对应的，根据图52得到的各节起始地址，可以在edb中查找得到对应内容，如图59所示。 图59ELF节信息与DataDump对照展示5.5链接的重定位过程分析输入objdump-d-rhello得到反汇编代码。 图5-10hello的反汇编代码对比与反汇编hello.o得到的代码可以发现：(1)hello的反汇编代码含有更多的函数。hello.o的反汇编代码中只有一个函数main，而在hello的反汇编代码中还出现了_init，.plt，puts@plt等函数。很多外部的被hello.c调用的函数以及一些初始函数（如_init）都被链接到hello中。(2)函数调用变化。在hello.o中函数的地址是不确定的，但是在hello中外部函数调用的地址确定，不再是0。如puts的地址就明确为0x401030。 图5-11函数调用对比(3)数据引用变化。和函数类似，hello.o中一些数据的地址是不确定的，但是在hello中它们的地址确定了。如.rodata+0x22的地址就明确为0x40202e。链接主要分为两个过程：符号解析和重定位。1）符号解析：目标文件定义和引用符号，符号解析将每个符号引用和一个符号定义关联起来。2）重定位：编译器和汇编器生成从0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。通过上面的分析可以得出在重定位过程中，链接器在完成符号解析以后，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。然后就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时的地址。5.6hello的执行流程使用edb执行hello，观察从加载hello到_start，到main，以及程序终止的所有过程。下面列出调用与跳转的子程序名和子程序地址，如表51所示。程序名程序地址加载hellold-linux-x86-64.so!_dl_start0x00007ffff7fd4d30ld-linux-x86-64.so!_dl_init0x00007ffff7fe27b0hello!_start0x0000000000401090hello!__libc_csu_init0x00000000004010d0hello!_init0x0000000000401000libc.so!_setjmp0x00007ffff7e08b10程序运行hello!main0x0000000000401149hello!puts@plt0x0000000000401030ld-linux-x86-64.so!_dl_runtime_resolve_xsave0x00007ffff7fe87a0ld-linux-x86-64.so!_dl_fixup0x00007ffff7fe1de0ld-linux-x86-64.so!_dl_lookup_symbol_x0x00007ffff7fdd610退出程序hello!exit@plt0x0000000000401070libc.so!exit0x00007ffff7e0b840hello!_fini0x00000000004011d4表51hello从加载到终止过程中调用或跳转的主要子程序5.7Hello的动态链接分析函数调用一个由共享库定义的函数时，编译器无法预先判断出函数的地址，因为定义它的共享模块在运行时可以加载到任意位置。GNU编译系统使用延迟绑定的方式解决该问题，在运行时动态载入。现代编译器会将共享模块的代码段编译为位置无关代码（PIC）。这种代码可以加载到内存的任何位置而无需连接器修改。这样一来，多个进程就可以共同使用共享模块的同一副本。延迟绑定是通过两个数据结构之间简洁但乂有些复杂的交互来实现的，这两个数据结构是：全局偏移量表（GOT）和过程链接表（PLT）。如果一个目标模块调用了定义在共享库中地函数，那么它就有自己的GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。通过readelf获得的节头部表可以知道.got.plt的起始位置为0x0000000000404000。在调用_dl_start之前对应的内存为： 图5-12_dl_start调用前.got.plt对应内存对应的内存全为0，而_dl_start之后： 图5-13_dl_start调用后.got.plt对应内存对应的内存有了动态链接器在解析函数地址时会使用的信息。5.8本章小结本章展示了hello.o经过链接成为hello可执行文件的全过程，着重介绍了重定位和动态链接的流程，深入学习了hello.o可重定位文件到hello可执行文件的流程，和链接的各个过程介绍了链接器如何将hello.o可重定向文件与动态库函数链接起来。 第6章hello进程管理6.1进程的概念与作用概念：进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。作用：进程是计算机科学中最深刻、最成功的概念之一。它令我们得到一种假象：我们的程序好像是系统中当前运行的唯一的程序一样；我们的程序好像是独占地使用处理器和内存；处理器好像是不间断地执行着指令；我们程序中的代码和数据好像是系统内存中唯一的对象。6.2简述壳Shell-bash的作用与处理流程作用：Shell是系统的用户界面，它为用户提供了一种与内核进行交互操作的接口，即接收用户输入的命令并把它送入内核执行。处理流程：Shell首先读取用户的输入。然后分析输入内容，获得输入参数。如果是内核命令则直接执行，否则调用相应的程序执行命令。在程序运行期间，shell需要监视键盘的输入内容，并且做出相应的反应。6.3Hello的fork进程创建过程父进程可以通过fork函数创建一个新子进程。函数原型为pid_tfork(void);新创建的子进程与父进程几乎完全相同。子进程得到与父进程用户级虚拟地址空间相同（但是独立的）一份副本，包括代码段和数据段、堆、共享库以及用户栈。子进程还会获得父进程所打开的文件描述符的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的差别在于它们有不同的PID。函数返回值分两种情形，父进程内返回子进程的PID，子进程内返回0。fork函数有一些微妙的地方。(1)调用一次，返回两次。父进程调用一次fork，有一次是返回到父进程，而另一次是返回到子进程的。(2)并发执行。父进程和子进程是并发运行的独立进程，内核可以以任意方式交替执行它们的逻辑控制流中的指令。我们不能对不同进程中指令的交替执行做任何假设。(3)相同但独立的地址空间。两个进程有相同的用户栈、运行时堆和本地变量值等，但它们对各自内存空间的修改是相互独立的。事实上，在物理内存中，一开始，两个进程指向的地址确实是相同的；但是，一旦一方对部分共享空间做了修改，这部分空间就会被拷贝出去，不再共享。这种技术被称作写时复制。写时复制会在7.6节中详细阐述(4)共享文件。子进程会继承父进程打开的所有文件。 6.4Hello的execve过程execve函数在当前进程的上下文中加载并运行一个新程序。其原型为： 图62execve函数原型execve函数加载并运行可执行目标文件filename，带上参数列表argv和环境变量列表envp。函数返回值，只有出现错误返回-1，否则不返回。execve加载了filename之后，程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据段并重新初始化栈空间和堆空间。接着，CPU为新进程进程分配时间片执行逻辑控制流，跳转到程序的入口点，也就是_start函数的地址。_start函数调用系统启动函数__libc_start_main，该函数定义在libc.o中。它初始化执行环境，调用main函数，处理main函数的返回值。main开始执行时，用户栈的组织结构如图62所示。可以看到，低地址部分有环境变量和参数字符串数组等，栈顶就是系统启动函数__libc_start_main。 图63新程序开始时用户栈的典型组织结构 6.5Hello的进程执行系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。内核为每个进程维护了一个上下文。当内核选择的一个新的进程运行时，我们说内核调度了这个进程。所以当内核调度了hello这个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换会首先保存当前进程的上下文，然后恢复新恢复进程被保存的上下文，最后控制传递给这个新恢复的进程，来完成上下文切换。过程如下： 图6-4进程间切换上图是对于上下文切换的剖析的一个实例。hello调用sleep和getchar函数时都会有类似的上下文切换。6.6hello的异常与信号处理hello执行时，可能产生如表61所示的四种类别的异常：类别原因同步/异步返回行为中断来自I/O设备的信号异步总是返回到下一条指令陷阱有意的异常同步总是返回到下一条指令故障潜在可恢复的错误同步可能返回到当前指令终止不可恢复的错误同步不会返回表61系统异常的四个类别hello执行时，还可以发送或接收信号。信号是一种系统消息，它用于通知进程系统中发生了某种类型的事件，是一种更高层的软件形式的异常。不同的事件对应不同的信号类型。信号传送到目的进程由发送和接收两个步骤组成。信号的发送者一般是内核，接收者是进程。发送信号可以有如下两种原因：(1)内核检测到一个系统事件（如除零错误或者子进程终止）；(2)一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。接收信号是内核强迫目的进程做出的反应。进程可以以默认方式做出反应，也可以通过信号处理程序捕获这个信号。每个信号只会被处理一次。待处理信号指的是已经发送而没有接收的信号。任何时候，一种信号类型至多有一个待处理信号，即信号不会排队。进程可以有选择性地阻塞接收某种信号。被阻塞的信号仍可以发出，但不会被目标进程接收。信号种类繁多，现列举如表62所示。编号信号名称默认行为说明1SIGHUP终止终止控制终端或进程2SIGINT终止键盘产生的中断3SIGQUITdump键盘产生的退出4SIGILLdump非法指令5SIGTRAPdumpdebug中断6SIGABRT／SIGIOTdump异常中止7SIGBUS／SIGEMTdump总线异常/EMT指令8SIGFPEdump浮点运算溢出9SIGKILL终止强制进程终止10SIGUSR1终止用户信号,进程可自定义用途11SIGSEGVdump非法内存地址引用12SIGUSR2终止用户信号，进程可自定义用途13SIGPIPE终止向某个没有读取的管道中写入数据14SIGALRM终止时钟中断(闹钟)15SIGTERM终止进程终止16SIGSTKFLT终止协处理器栈错误17SIGCHLD忽略子进程退出或中断18SIGCONT继续如进程停止状态则开始运行19SIGSTOP停止停止进程运行20SIGSTP停止键盘产生的停止21SIGTTIN停止后台进程请求输入22SIGTTOU停止后台进程请求输出23SIGURG忽略socket发生紧急情况24SIGXCPUdumpCPU时间限制被打破25SIGXFSZdump文件大小限制被打破26SIGVTALRM终止虚拟定时时钟27SIGPROF终止剖析定时器期满28SIGWINCH忽略窗口尺寸调整29SIGIO/SIGPOLL终止I/O可用30SIGPWR终止电源异常31SIGSYS／SYSUNUSEDdump系统调用异常表62信号的种类 图6-5Ctrl-ZCtrl-Z操作向进程发送了一个SIGTSTP信号，让进程暂时挂起，输入jobs、ps指令可以发现hello进程在后台挂起，通过fg指令可以恢复运行。 图6-6Ctrl-CCtrl-C操作向进程发送了一个SIGINT信号，让进程终止，输入jobs、ps指令可以发现hello进程已经被回收。6.7本章小结为了描述程序运行，进程的概念不得不提，它是计算机科学中最深刻、最成功的概念之一。进程为程序提供的抽象环境，使得进程可以同时地、并发地执行。为了高效地描述系统中发生的各类事件，则需要用到信号，这是一种更高层级的软件形式的异常。利用信号，内核和进程之间得以高效地传递信息并对各类事件做出相应的反应。 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：在计算机体系结构中逻辑地址是指应用程序角度看到的内存单元、存储单元、网络主机的地址，即hello.o里面的相对偏移地址。在x86系统中，有一种被称作“段式内存管理”的内存映射方式。在x86架构下，访问指令给出的地址（操作数）叫逻辑地址，也叫相对地址、有效地址。逻辑地址往往不同于物理地址，通过地址翻译器或映射函数可以把逻辑地址转化为物理地址。线性地址：即虚拟地址。虚拟地址：虚拟地址是程序用于访问物理内存的逻辑地址，即线性地址，在hello中为虚拟地址，等于逻辑地址加上基地址。逻辑地址可转化为线性地址，其地址空间是一个非负整数地址的有序集合，如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。物理地址：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有唯一的物理地址，它是指在地址总线上、以电子形式存在的、使得数据总线可以访问主存的某个特定存储单元的内存地址。在hello程序中，他就表示了这个程序运行时的一条确切的指令在内存地址上的具体哪一块进行执行。7.2Intel逻辑地址到线性地址的变换-段式管理内存分段是为了支持多任务并发执行，每一个任务对应各自的段空间，段之间支持保护访问限制，实现了程序和数据从物理地址空间到虚拟地址空间的重映射，从而达到隔离的效果。如上所述，在段式内存管理中，程序的地址空间被划分为若干段，每个进程都有一个“二维”的地址空间。系统为每个段分配一个连续分区，而进程中的各个段可以不连续地存放在内存的各个分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续，物理内存的管理采用动态分区的管理方法。程序过来一个逻辑地址，使用其段标识符（也即段选择符）的Index字段去索引段描述符表，若TI=0，索引全局段描述符表，TI=1，索引局部段描述符表，表的地址在相应的寄存器中。通过Index字段和段描述符表的位置能找到某项具体的段描述符。将段描述符中的base字段和逻辑地址中的offset字段合并即得到了线性地址。按照Intel的本意，全局的用GDT，每个进程自己的用LDT 不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。[1]中有介绍，四个段的基地址全为0。这样，给定一个段内偏移地址，按照前面转换公式，0+段内偏移，转换为线性地址，可以得出重要的结论，“在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。”所以如果做linux下内核开发，对于上述的x86的段式管理可以完全不用理会，我们可以认为linux根本没有用intel弄出来的这个段式管理，而是以页式管理完成了所有的内存管理工作。 图71段式内存管理的地址变换需要特别注意的是，段式内存管理是Intelx86系统的产物。amd64架构虽然支持x86所有形式的段，但在64位模式下，段式的设计已被取消，转而使用平坦内存模型。在这种模型下，分段机制虽仍然存在，但所有的段基址都是0，段大小被忽略。这就使得逻辑地址可以访问处理器支持的所有虚拟内存空间。也就是说，amd64架构中，段式地址转换形同虚设，逻辑地址（相对地址、有效地址）与虚拟地址（线性地址）是相同的。为了表述方便，接下来针对amd64架构的叙述，全部使用“虚拟地址”一词。7.3Hello的线性地址到物理地址的变换-页式管理7.3.1基本原理虚拟内存系统将程序的虚拟地址空间划分为固定大小的虚拟页（每个大小为P=2^p），物理内存被划分为同样大小的物理页（也被称作页帧，大小也为P字节）。在页式储存管理方式中地址结构由两部构成，前一部分是虚拟页号（VPN），后一部分为虚拟页偏移量（VPO）。在任意时刻，虚拟页面的集合都分为三个不相交的子集：(1)未分配页。虚拟内存系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间(2)缓存页。当前已缓存在物理内存中的已分配页(3)未缓存页。未缓存在物理内存中的已分配页从存储位置上看，物理内存存储在主存中，而虚拟内存存储在磁盘中。7.3.2页表同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。这些功能是由软硬件联合提供的，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。图72展示了一个页表的基本组织结构。 图72页表页表就是一个页表条目的数组。虚拟地址空间中的每个页在页表中的各固定偏移量处都有一个PTE。都有一个为方便理解，我们假设每个页表条目都是由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位为真，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。注意，因为DRAM缓存是全相联的，所以任意物理页都可以包含任意虚拟页。7.3.3页命中为了访问物理页，CPU中的地址翻译硬件会先把虚拟地址作为索引去访问页表。若对应的表项有效位为真，那么，该项中的地址字段就是我们所要的物理页的起始地址。以图7-3中的虚拟页2为例，由于对应页表条目有效位是1，所以发生页命中，即这个页已经被缓存到主存中了。于是，直接访问地址字段指向的物理内存物理页2即可。 图73页命中7.3.4缺页在虚拟内存的习惯说法中，DRAM缓存不命中被称为缺页（pagefault）。图7-4展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果虚拟页4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改虚拟页4的页表条目，反映出VP4不再缓存在主存中这一事实。接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了，图75展示了在缺页后我们的示例页表的状态。 图74缺页后的页表状态7.3.5地址翻译从形式上说，地址翻译要做的是把N元素的虚拟地址空间（VAS）映射到M元素的物理地址空间（PAS）中。如果虚拟地址A处的数据在物理地址A’处，那么映射值就是A’；否则，若A处的数据不在物理内存中，映射值就是空。 图75地址翻译流程图75展示了MMU如何利用页表来实现这种映射。CPU中的一个控制寄存器，页表基址寄存器指向当前页表。n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个(n-p)位的虚拟页号（VPN）。MMU利用VPN来选择对应的页表项目。将页表条目中物理页号（PPN）和虚拟地址中的VPO串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是p字节的，所以物理页面偏移（PPO）和VPO是相同的。图76a展示的是页命中时CPU硬件执行的步骤：(1)处理器生成一个虚拟地址，并把它传送给MMU(2)MMU生成对应的页表项目地址，并访问高速缓存或主存获得其内容(3)高速缓存或主存向MMU返问页表项目(4)有效位为真，MMU构造物理地址，并把它传送给高速缓存或主存(5)高速缓存或主存返冋所请求的数据字给处理器页命中完全由硬件处理，而缺页则需要硬件和操作系统内核协作完成。如图76b所示：(1)与页命中的第1步操作相同(2)与页命中的第2步操作相同(3)与页命中的第3步操作相同(4)页表项目的有效位是0，MMU触发异常，CPU的控制传送到操作系统内核中的缺页异常处理程序(5)缺页处理程序确定出物理内存中的牺牲页。如果这个页被修改过，还需要把它换出到磁盘(6)缺页处理程序页面调入新的页，并更新内存中的页表项目(7)缺页处理程序返回到原来的进程，再次执行那个导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。现在，所需的虚拟页已经缓存在物理内存中了，所以会发生页命中。在MMU执行了图7-6a中的步骤之后，主存就会将所请求字返回给处理器 图76页命中和缺页的操作图7.4TLB与四级页表支持下的VA到PA的变换36位VPN被划分成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含Ll页表的物理地址。VPN1提供到一个LlPET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 图7-7四级页表支持下的VA到PA的变换7.5三级Cache支持下的物理内存访问我们通过MMU获得对应的物理内存地址后，就需要在物理内存中得到对应的数据。此时我们会通过高速缓存来加速数据读取。首先L1高速缓存会通过地址解析出缓存的索引和偏移，对缓存进行访问，匹配标记查找是否含有相关的字，如果命中，则将数据发送给CPU，如果没有命中，则访问L2缓存，依次类推，直到主存，然后取出这个字，存入高一级缓存，最后返回数据给CPU。 图7-8三级Cache支持下的物理内存访问7.6hello进程fork时的内存映射当fork函数被shell调用时，内核为hello创建各种数据结构，并分配一个唯一的PID。创建当前进程的mm_struct,vm_area_struct和页表的原样副本。两个进程的每个页面都标记为只读页面。两个进程的每个vm_area_struct都标记为私有，这样就只能在写入时复制。当fork在hello进程中返回时，hello现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新的页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 图7-9私有的写时复制对象7.7hello进程execve时的内存映射虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。假设运行在当前进程中的程序执行了如下的execve调用execve(“hello”,NULL,NULL);正如6.4节所说，execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤：(1)删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。(2)映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。图717概括了私有区域的不同映射。(3)映射共享区域。如果hello程序与共享对象（或目标）链接，比如标准C库libc.so，那么这些对象都先是动态链接到程序，再映射到用户虚拟地址空间中的共享区域内的。(4)设置程序计数器PC。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的人口点。下一次调度这个进程时，它将从这个人口点开始执行。Linux将根据需要换人代码和数据页面。 图710加载器映射用户地址空间区域的方法7.8缺页故障与缺页中断处理假设MMU在试图翻译某个虚拟地址A时，触发了缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤（如图711所示）：(1)虚拟地址A是合法的吗？换句话说，A在某个区域结构定义的区域内吗？缺页处理程序会搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图711标识为“1”。(2)试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。这个情况在图711标识为“2”。(3)若不满足以上两种情形，内核明白这个缺页是由于对合法的虚拟地址进行合法的操作造成的。接下来，内核会遵循7.3.3节中的步骤进行处理，这里不再重复。 图711Linux缺页处理7.9动态存储分配管理7.9.1动态内存分配器虽然可以使用低级的mmap和munmap函数创建和删除虚拟内存的区域，但使用动态内存分配器（dynamicmemoryallocator）更方便，也有更好的移植性。动态内存分配器用于分配和维护一个进程的虚拟内存区域，称为堆（如图712所示）。堆在系统内存中向上生长。对于每个进程，系统维护着一个堆顶指针brk。 图712虚拟内存区域 堆分配器将堆视为不同大小的块（block）组成的集合。每个块就是一段连续的虚拟内存片（chunk），要么是已分配的（allocated），要么是空闲的（free）。已分配的块显式地保留给应用程序使用，空闲块留待分配。1.显式分配器。显式分配器要求程序显式地释放已分配块。例如，C标准库就提供了malloc库这一显式分配器。它需要满足如下的约束条件：能够处理任意请求序列；立即响应请求；仅使用堆；块对齐；不修改已分配块。在满足这些限制条件的前提下，其分配吞吐速率越大、内存使用率越高，其性能越优秀。然而，这两个要求是冲突的。为了把握好平衡，就需要分配器有效地组织空闲块，精心设计放置、分割和合并的处理方式。2.隐式分配器（也叫垃圾收集器）能够检测已分配块何时不再被程序使用，并将其自动释放。这种分配器将内存视为一张有向可达图，凡不能从根到达的节点都是垃圾节点，代表程序无法再访问使用的内存空间。垃圾收集器能够以某种方式维护这张图，释放不可达节点并将其返还给空闲链表，从而达到定期回收内存的目的。7.9.2隐式空闲链表我们可以将堆组织为一个连续的已分配块和空闲块的序列。一个块是由一个字的头部、有效载荷、可能的填充和一个字的脚部，其中脚部就是头部的一个副本。头部和脚部包含这个块的大小和是否空闲（1为已分配，0为空闲）。空闲块是通过头部中的大小字段隐含地连接着的，这种结构为隐式空闲表。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块地集合。 图7-13隐式空闲链表的一个块7.9.3显式空闲链表将堆组成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。一种方法是用后进先出（LIFO）的顺序来维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用。一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小快大小，也潜在的提高了内部碎片的程度。 图7-14显式空闲链表的一个块7.9.4分离空闲链表一般的单向空闲链表，其查找和分配所需时间都是线性的。为了减少分配时间，可以按块大小对空闲块分类，每个类都单独维护一个链表，类中的块大小大致相同，这被称为“分离”的显式空闲链表。例如，可以按照2的幂来划分块大小：{1},{2},{3,4},{5~8},…,{1025~2048},{2049~4096},{4097~∞}链表的头元素存储在静态数组中。链表内部的元素以块大小按升序排列。当分配器需要一个对齐后大小为n的块时，它就会搜索相应的空闲链表。如果不能找到合适的块与之相匹配，就搜索下一个链表，以此类推。7.10本章小结本章具体分析了存储管理。包括逻辑地址、线性地址、虚拟地址和物理地址、其中的转化过程、三级高速缓存、fork与execve和动态内存分配等。其中，虚拟内存是重中之重，是计算机系统最重要的概念之一，可以为每个进程分配一个独立的虚拟内存空间而不不会受到其他进程影响，而动态内存分配器则可以提高内存的利用率和效率。 第8章hello的IO管理8.1Linux的IO设备管理方法一个Linux文件就是一个m个字节的序列：B0,B1,…,Bk,…,Bm-1所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。8.2简述UnixIO接口及其函数所有的输入和输出都能以一种统一且一致的方式来执行：(1)打开文件。一个应用程序要求通过内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个标识符。(2)Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。(3)改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开始的字节偏移量。应用程序能够通过执行seek操作，现显式地设置文件的位置为k。(4)读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个称为end-of-file的条件，应用程序能够检测到这个条件。在文件结尾处并没有明确的“EOF符号”。(5)关闭文件。当应用程序完成了对文件的访问后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。UnixI/O函数原型有：(1)intclose(intfd)该函数可以关闭一个打开的文件，其中fd是需要关闭的文件的描述符。(2)intopen(char*filename,intflags,mode_tmode)进程通过调用open函数来打开已存在的文件或是创建新文件。(3)size_twrite(intfd,constvoid*buf,size_tn)该函数从内存位置复制至多n个字节到描述符为fd的当前文件位置。(4)size_tread(intfd,void*buf,size_tn)该函数从描述符为fd的文件位置赋值最多n个字节到内存位置buf。返回-1表示出现错误，0表示EOF；否则返回值表示的是实际传送的字节数量。8.3printf的实现分析printf函数实现如下：1.intprintf(constchar*fmt,…){2.inti;3.charbuf[256];4.5.va_listarg=(va_list)((char*)(&fmt)+4);6.i=vsprintf(buf,fmt,arg);7.write(buf,i);8.9.returni;10.} 用vsprintf函数生成显示信息，实现如下：1.intvsprintf(char*buf,constchar*fmt,va_listargs){2.char*p;3.chartmp[256];4.va_listp_next_arg=args;5.for(p=buf;*fmt;fmt++){6.if(*fmt!=‘%’){7.*p++=*fmt;8.continue;9.}10.fmt++;11.switch(*fmt){12.case‘x’:13.itoa(tmp,*((int*)p_next_arg));14.strcpy(p,tmp);15.p_next_arg+=4;16.p+=strlen(tmp);17.break;18.case‘s’:19.break;20.default:21.break;22.}23.}24.return(p-buf);25.} write的汇编代码：1.moveax,_NR_write2.movebx,[esp+4]3.movecx,[esp+8]4.intINT_VECTOR_SYS_CALL write函数中，%ecx中存储字符个数，%ebx中存储字符串首地址，intINT_VECTOR_SYS_CALL的意思是通过系统调用sys_call。这个函数的功能就是不断地打印出字符，直到遇到\0。追踪sys_call，得到其汇编实现如下：1.sys_call：2.callsave3.pushdword[p_proc_ready]4.sti5.pushecx6.pushebx7.call[sys_call_table+eax*4]8.addesp,4*39.mov[esi+EAXREG-P_STACKBASE],eax10.cli11.ret 接着，字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析getchar函数的声明在stdio.h头文件中。一种实现如下：1.intgetchar(){2.charc;3.return(read(0,&c,1)==1)?c:EOF;4.} 这个getchar每次从标准输入中读取一个字符。具体来说，若当前I/O未被锁定，它就调用系统_IO_getc_unlocked内置宏，读取一个字符。简单地说，我们用一个指针_IO_read_ptr指向缓冲区，用另一个指针_IO_read_end指向缓冲区的末尾。调用_IO_getc_unlocked时，先检查指针是否越界。如果没有，就返回_IO_read_ptr所指向的字符并自增_IO_read_ptr。若已越界，就调用_uflow（内部使用了系统read），用这个函数重新填充缓冲区并返回重新读入的字符。对于异步异常和键盘中断的处理：键盘中断处理子程序；接受按键扫描码转成ASCII码，保存到系统的键盘缓冲区。也就是说，getchar等调用read系统函数，通过系统调用读取按键ASCII码，直到接受到回车键才返回。 8.5本章小结本章主要介绍了Linux的IO设备管理方法、UnixIO接口及其函数，分析了printf函数和getchar函数。 结论hello的一生包含如下阶段：(1)预处理：将hello.c根据以字符#开头命令，修改原始c程序，得到hello.i。(2)编译：将hello.i翻译为hello.s的汇编程序，中间对代码进行语法检查和优化。(3)汇编：将hello.s翻译为二进制机器码，得到可重定位目标文件hello.o。(4)链接：将hello.o同等动态库等连接，生成可执行目标文件hello。(5)创建进程：通过shell运行hello程序。shell通过fork创建子进程，通过execve运行hello。(6)访问内存：通过MMU将hello中的虚拟地址转换为实际的物理地址，再通过多级缓存读取数据。(7)异常：程序执行过程中，如果从键盘输入Ctrl-C等命令，会给进程发送一个异常信号，然后通过信号处理函数对信号进行处理。(8)结束：hello运行完后会由父进程（shell进程）回收，内核会删除对应的数据结构。至此，我们对于hello的分析已经完成。通过写大作业，将本学期大部分所学内容串联了起来。从一个hello.c的到详细的进程执行。这样，我们才能够真正理解硬件、操作系统和编译系统对应用程序的性能和正确性的影响，为将来设计和构造大型软件产品提供更基础、更底层的角度和思路。 附件文件名称文件作用hello.chello的C语言源代码hello.ihello.c预处理生成的代码hello.shello.i编译生成的汇编代码hello.ohello.s汇编生成的可重定位目标文件hellohello.o链接生成的可执行文件hello_o_objdump.asmhello.o的反汇编代码hello_objdump.asmhello的反汇编代码hello_o_elf.txthello.o的ELF信息概述hello_elf.txthello的ELF信息概述 参考文献[1]兰德尔E.布莱恩特.大卫R.奥哈拉伦.等深入理解计算机系统[M].北京：机械工业出版社.2019.[2]printf函数实现的深入剖析https://www.cnblogs.com/pianist/p/3315801.html 
第425篇文章[]
软件构造 关于mutable与immutable 1.immutable与mutable类的定义 mutable类：定义比较简单，创建之后，该对象拥有可以更改其值/引用的方法 immutable类：immutable类是指这个类的实例一旦创建完成后，就不能改变其成员变量值，也就是不能改变对象的状态。首先，类需要声明为final，保证其不可以被继承,所有成员变量定义为privatefinal,不提供改变成员变量的Mutators方法，通过构造器初始化成员变量，如果构造器传入了引用数据类型需要进行防御式拷贝。 2.Java中常见的mutable和immutable类 常见的immutable类 String：一个String总是表示一个相同的字符串。由于String是immutable的，一旦创建，一个String类总是含有相同的值。想要改变值，java会创建一个新的String类。 基本类型及其封装对象类型：基本类型：byte、short、int、long、float、double、char、boolean与封装类：Byte,Short,Integer,Long,Float,Double,Character,Boolean, Scanner常见的扫描器 将Iterator迭代器转换为Scala迭代器 经过Collections.unmodifiableList/Map/Set()方法处理后的集合 常见的mutable类 StringBuilder：StringBuilder是mutable类型的一个例子。它有删除部分字符串，插入或替换字符等方法。这个类有改变对象值的方法，而不仅仅是返回新值。 StringBuffer 常见的Map如HashMap Java中的常见的大多数迭代器Iterator 3.mutable与immutable的优劣 使用immutable，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)。mutable最少化拷贝以提高效率。因此，使用可变数据类型，可获得更好的性能。也适合于在多个模块之间共享数据。 4.mutable与immutable的差异例子 5.使用final 可以这么理解：在java中引用变量的组成分为两部分：引用哪个对象，那个对象的值。immutable就是那个对象的值不会改变，但引用哪个对象会改变。mutable就是两者都能改变。而如果在一个引用变量前使用final修饰，则会导致引用哪个对象不会发生改变。在snapdiagram中，表现为指针变成双线。 
第426篇文章[5]
HelloWorld！ HelloWorld！ 
第427篇文章[0]
GraphPoet翻译 ClassGraphPoet java.lang.Object poet.GraphPoet publicclass GraphPoetextendsObject 一个基于图的诗歌派生器。 GraphPoet由文本语料库初始化，它用这个语料库来派生一个单词亲和图wordaffinitygraph。单词words用图中的顶点vertices表示。单词是不包括空格和换行符的不区分大小写的非空字符串，它们在语料库中由空格、换行符或EOF分隔。图中的各边表示邻接的数量：从w1到w2的边的权重定义为语料库中“w2”紧跟在“w1”后面的次数。 举个栗子，给定这个语料库: Hello,HELLO,hello,goodye! 生成的图应该包含两条边： (“hello,”)->(“hello,”)权重为2(“hello,”)->(“goodbye!”)权重为1 两个点表示为不区分大小写的“hello,”和“goodbye!” 给定输入字符串，GraphPoet通过尝试在输入中的每对相邻单词之间插入一个桥接词bridgeword来生成一首诗。单词由语料库中的单词定义和分隔。输入词“w1”和“w2”之间的桥接词“b”使得w1->b->w2成为一条包含两条边的路径，满足在这个诗人(GraphPoet)的单词亲和图中的所有从w1到w2的包括两条边路径中，具有最大权重。如果没有这样的路径，则不会插入桥接词。在输出的诗句中，输入词保留了原来的大小写，而桥词则是小写。诗中每个字之间的空白是一个空格，开头和结尾没有空格。 再举个栗子，给定这个语料库： ThisisatestoftheMugarOmniTheatersoundsystem. 对于这个输入： Testthesystem. 输出的诗句将会是： Testofthesystem. 说明：这是一个有要求的ADT类，并且你不能弱化要求的规约specifications。但是，你可以强化规约，也可以添加额外方法。你必须在你的属性rep中使用Graph类，但是除此之外这个类的实现取决于你。 ConstructorSummary GraphPoet (File corpus)使用从corpus生成的图创建一个新的诗人。 MethodSummary String poem (String input)生成一首诗。 从java.lang.Object类继承的方法 equals, getClass, hashCode, notifyAll, toString, wait, wait, wait ConstructorDetail GRAPHPOET publicGraphPoet(Filecorpus)throwsIOException 使用从corpus生成的图创建一个新的诗人。 parameters corpus-生成诗人的单词亲和图的文本文件 Throws IOException-如果无法找到或无法读corpus文件 MethodDetail POEM publicStringpoem(Stringinput)派生一首诗。 Parameters input-派生一首诗的源字符串 Returns poem-(如上文所说) 声明：翻译自MIT6.031的 GraphPoet(ProblemSet2:PoeticWalks)仅供个人学习个人水平有限，如有疏漏和错误恳请批评指正 
第428篇文章[]
Java为什么不采用360垃圾清理来进行垃圾回收呢？ Java垃圾回收机制 什么是垃圾回收（GC） 垃圾回收，顾名思义，便是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。在Java虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。 Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。它从一系列GCRoots出发，边标记边探索所有被引用的对象。 判断对象死亡的方法 引用计数法: 它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。 引用计数法的具体实现是这样子的： 如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器+1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器-1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。 引用计数法的弊端： 除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。 可达性分析算法: 可达性分析算法的实质在于将一系列**GCRoots**作为初始的**存活对象合集（liveset）**，然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。 什么是GCRoots呢？ 我们可以暂时理解为由堆外指向堆内的引用， 一般而言，GCRoots包括（但不限于）如下几种： -Java方法栈桢中的局部变量； -已加载类的静态变量； - JNIhandles； -已启动且未停止的Java线程。 -可达性分析优点：解决循环引用问题 可达性分析可以解决引用计数法所不能解决的循环引用问题。 举例来说，即便对象a和b相互引用，只要从GCRoots出发无法到达a或者b，那么可达性分析便不会将它们加入存活对象合集之中。 -可达性分析算法的问题 虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。 比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为null）或者漏报（将引用设置为未被访问过的对象）。 误报并没有什么伤害，Java虚拟机至多损失了部分垃圾回收的机会。 漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致Java虚拟机崩溃。 垃圾收集算法 清除（sweep）: 把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（freelist）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。 清除这种回收方式的优点是原理极其简单。 但是清除有两个缺点： 一是会造成内存碎片。由于Java虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。 二是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointerbumping）来做分配。而对于空闲列表，Java虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。 压缩（compact）: 把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。 这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。 复制（copy）： 把内存区域分为两等分，分别用两个指针from和to来维护，并且只是用from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域中，并且交换from指针和to指针的内容。 复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。 垃圾收集器 Serial收集器 Serial收集器是最基本的、历史最悠久的收集器，曾经是JDK1.3.1之前虚拟机的新生代收集的唯一选择。Serial这个名字揭示了这是一个单线程的垃圾收集器，特点如下： 仅仅使用一个线程完成垃圾收集工作；在垃圾收集时必须暂停其他所有的工作线程，知道垃圾收集结束；StoptheWorld是在用户不可见情况下执行的，会造成某些应用响应变慢；使用复制算法； ParNew收集器 ParNew收集器其实是Serial收集器的多线程版本，与Serial不同的地方就是在垃圾收集过程中使用多个线程，剩下的所有行为包括控制参数、收集算法、StoptheWorld、对象分配规则和回收策略等都一样。ParNew收集器也使用复制算法。 ParallelScavenge收集器 ParallelScavenge收集器和ParNew类似，是一个新生代收集器，使用复制算法，又是并行的多线程收集器。不过和ParNew不同的是，ParallelScavenge收集器的关注点不同。 CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而ParallelScavenge收集器的目的则是达到一个可控制的吞吐量。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+运行垃圾收集时间）。如果虚拟机一共运行100分钟，垃圾收集运行了1分钟，那么吞吐量就是99%。 停顿时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 ParallelScavenge收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。 MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能在给定时间内完成垃圾收集。不过垃圾收集时间的缩短是以牺牲吞吐量和新生代空间为代价的，短的垃圾收集时间会导致更加频繁的垃圾收集行为，从而导致吞吐量的降低。 SerialOld收集器 SerialOld是Serial的老年版本，在Serial的工作流程图中可以看到，SerialOld收集器也是一个单线程收集器，使用“标记-整理”算法。这个收集器主要给Client模式下的虚拟机使用。如果在Serve模式下，它有两个用途：一个是在JDK1.5之前的版本中与ParallelScavenge收集器搭配使用；另一个就是作为CMS收集器的后备预案，在并发收集发生ConcurrentModeFailure时使用。这个收集器的工作流程在Serial的后半部分有所体现。 ParallelOld收集器 ParallelOld收集器是ParallelScavenge收集器的老年版本，它也使用多线程和“标记-整理”算法。这个收集器是在JDK1.6开始提供。 CMS收集器 CMS（ConcurrentMarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。在重视响应速度和用户体验的应用中，CMS应用很多。 CMS收集器使用“标记-清除”算法，运作过程比较复杂，分为4个步骤： 初始标记（CMSinitialmark）并发标记（CMSConcurrentmark）重新标记（CMSremark）并发清除（CMSConcurrentSweep） G1收集器 G1（Garbagefirst）收集器是最先进的收集器之一，是面向服务端的垃圾收集器。与其他收集器相比，G1收集器有如下优点： 并行与并发：有些收集器需要停顿的过程G1仍然可以通过并发的方式让用户程序继续执行；分代收集：可以不使用其他收集器配合管理整个Java堆；空间整合：使用标记-整理算法，不产生内存碎片；可预测的停顿：G1除了降低停顿外，还能建立可预测的停顿时间模型； G1中也有分代的概念，不过使用G1收集器时，Java堆的内存布局与其他收集器有很大的差别，它将整个Java堆划分为多个大小相等的独立区域（Region），G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要的时间的经验值），在后台维护一个优先列表，每次优先收集价值最大的那个Region。这样就保证了在有限的时间内尽可能提高效率。 G1收集器的大致步骤如下： 初始标记（Initialmark）并发标记（Concurrentmark）最终标记（Finalmark）筛选回收（LiveDataCountingandEvacuation） 回到标题 360垃圾清理的目标和JavaGC的目标是不同的。 360清理的目标集中在文件系统里无用的垃圾，而GC的目标集中在内存里不需要再用到的数据。 :) 
第429篇文章[]
Java集合类总结 在编写java程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！ java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等。 Collection接口 Collection接口是最基本的集合接口，它不提供直接的实现，JavaSDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。 在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。 List接口 List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 2.1 ArrayList ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。size、isEmpty、get、set、iterator和listIterator操作都以固定时间运行。add操作以分摊的固定时间运行，也就是说，添加n个元素需要O(n)时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。ArrayList擅长于随机访问。同时ArrayList是非同步的。 2.2LinkedList同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：Listlist=Collections.synchronizedList(newLinkedList( )); 2.3Vector 与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。 2.4StackStack 继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。。 Set接口 Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。 3.1EnumSet是枚举的专用Set。所有的元素都是枚举类型。 3.2HashSetHashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。 Map接口 Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。 4.1HashMap以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[]table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 4.2TreeMap键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口 4.3HashTable也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低 Queue接口 队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。 
第430篇文章[]
软件构造内容简单梳理 1.多维度视图与质量目标 1.多维度视图与质量目标 1.1三维度八视图 MomentPeriodCode-levelComponent-levelCode-levelComponent-levelBuild-timeSourcecode,AST,Interface-Class-Attribute-Method(ClassDiagram)Package,File,StaticLinking,Library,TestCase,BuildScript(ComponentDiagram)CodeChurnConfigurationItem,VersionRun-timeCodeSnapshot,MemorydumpPackage,Library,Dynamiclinking,Configuration,Database,Middleware,Network,Hardware(DeploymentDiagram)Executionstacktrace,Concurrentmulti-threadsProcedureCallGraph,MessageGraph(SequenceDiagram)Eventlog,Multi-processes,DistributedprocessesProcedureCallGraph,MessageGraph(SequenceDiagram) 1.2质量目标 1.2.1五个关键的质量目标 1.Elegantandbeautifulcode：代容易理解。2.Designfor/withreuse：提高代码的可复用性。3.Lowcomplexity：高内聚低耦合。4.Robustnessandcorrectness：健壮性和正确性。5.Performanceandefficiency：提升性能。 1.2.2内部&外部质量因素 内部： 代码行数(LOC)、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小。 外部： Correctness（正确性），Robustness（鲁棒性），Extendibility（易扩展性），Reusability（复用性），Compatibility（兼容性），Efficiency（效率），Portability（可移植性），Easeofuse（易用性），Functionality（功能性），Timeliness（时效性），Verifiability(可验证性)，Integrity(完整性)，Repairability(可修复性)，Economy(经济性)等。 2.软件构造的过程与工具 2.软件构造的过程与工具 2.1SCM,VCS,Git 2.1.1SCM(软件配置管理) 软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被成为软件配置项(SCI)。 当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。 为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。 2.1.2VCM（版本控制系统） VCS分为三种：本地版本控制系统（无法协作）存储在本地、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。 2.1.3Git 指令： 创建：gitinit 暂存：gitadd<filename> 提交：gitcommit-m“commitmessage” 链接：gitremoteaddorigin<URL> 推送：gitpush-uoriginmaster 创建分支：gitcheckout-b<branchname> 切换分支：gitcheckout<branchname> 合并分支：gitmerge<branchname> 删除分支：gitbranch-d<branchname> 注意，git的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。 2.2软件构造过程 1.Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。 2.Codereview、Staticcodeanalysis：可以使用工具来发现bug，如CheckStyle,SpotBugs。 3.Testing：测试，单元测试、集成测试、系统测试… 4.Debugging：调试 5.Dynamiccodeanalysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分 6.Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化 7.Build：第2部分 3.ADT&OOP 3.ADT&OOP 3.1Spec 3.1.1Spec的结构 precondition前置条件：对客户端的约束，在使用方法时必须满足的条件使用@paramannotation说明每个参数的前置条件postcondition后置条件：对开发者的约束，方法结束时必须满足的条件使用@returnannotation说明后置条件 抛出异常：使用@throwsannotation说明出现异常的时候会发生什么在方法声明中使用static等关键字声明，可据此进行静态类型检查 3.1.2Spec的强弱 更强的Spec：前置条件变弱，后置条件变强，强的Spec可以替换弱的。 3.2ADT 3.2.1 ADT的操作Creators构造器：用于使用new关键字创建一个新的对象。还有一种方法是静态方法，如Arrays.asList()、String.valueOf(ObjectObj)等。 Producers生产器：用于使用一个存在的对象产生一个新的对象，例如String.concat()就是使用已存在的字符串构造出一个新的对象，而且不会改动原先存在的对象。 Observers观察器：不对数据做任何改动，只是查看一个已经存在的对象的各个值，如List.size()、所有的getter方法等。 Mutators变值器：用于改变对象属性的方法，如List.add()。mutator通常返回void，因为它不需要对外界做出反应，只是对ADT的数据域做了更改；mutator也可能返回非空，比如返回boolean表示修改成败等。 3.2.2.设计ADT设计一个好的ADT需要靠开发者的经验来设计它的操作的spec，设计一个ADT要遵循下面三个原则：（1）设计简洁一致的操作（2）要足以支持client所需要的对数据的所有操作，且用操作的难度要低（3）要么抽象要么具体，不要混合 要么针对抽象设计，要么针对具体应用的设计。 实现一个ADT的三个部分：specification、representation、implementation RepresentationIndependence表示独立性client不应该知道内部的数据域是怎么实现的，最好client只能通过ADT提供的getter方法获得ADT存储的数据。 client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。其目的一个是为了便于未来的升级和维护，当内部发生变化的时候不会影响到client。 3.2.3测试ADT因为测试相当于client使用ADT，所以它也不能直接访问ADT内部的数据域，所以只能调用其他方法去测试被测试的方法。 针对creator：构造对象之后，用observer去观察是否正确 针对observer：用其他三类方法构造对象，然后调用被测observer，判断观察结果是否正确 针对producer：produce新对象之后，用observer判断结果是否正确 RepInvariant(RI)andAbstractionFunction(AF)Invariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件 两个空间R和A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。 AbstractionFunction：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。 RepInvariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。 相同的R空间有肯能会有不同的RI。 即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。 checkRep()：用于随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。 表示泄露：client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。 3.3OOP 3.3.1继承与重写 子类可以继承父类的数据域和方法。 严格继承：子类只能添加新方法，无法重写超类中的方法。原因：父类中的方法使用了final关键字限定。 重写：子类的方法覆盖了父类的方法。重写的方法应该与父类方法有相同的签名，只有这样编译器才会判定为重写的方法。使用@Overrideannotation强制检查是否重写了超类中的方法。 3.3.2多态 三种多态：特殊多态、参数化多态、子类型多态 特殊多态：功能重载 重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型。参数列表必须不同，返回值类型、可见性、异常均为可以相同也可不同。重载不仅可以发生在类内，也可发生在父类与子类之间。 父类与子类之间发生重载的例子如下。这两个情况都不能编译成功，以为无论是a还是h，他们的运行时类型都是Animal，而不是通过new创建的具体类型。 参数化多态：泛型 使用泛型参数代替具体的类型。作为一个泛型接口，当实现的时候可以实现一个具有具体类型的子类型，也可以实现一个具有泛型接口的实现类。 子类型多态 终极目的：不同类型的对象可以统一处理而无需区分。 遵循的设计原则：LSP 4.复用 4.复用 4.1四个复用层面 1.源代码层面的复用可以在网络上寻找自己需要的代码，但要注意开发商用的软件不能直接复制开源的代码，避免引起法律纠纷。 2.模块层面的复用通过继承(Inheritance)的方式复用父类的代码，同时也可override父类中已存在的方法。另一个复用的方法是委托(delegation)，详见下一小节(4.2)。3.库层面的复用通过导入库来调用库中的API完成复用。除了导入本地库，也可以通过导入部署在网络上的库来完成复用，如WebServices/RestfulAPIs 4.架构层面的复用框架：一组具体类、抽象类、及其之间的连接关系。开发者可以根据spec填充自己的代码从而形成完整的系统。开发者根据Framework预留的接口所写的程序，而Framework作为主程序加以执行，执行过程中调用开发者所写的程序。关于框架详见下一小节4.2.3。 黑盒框架：通过实现特定接口/delegation进行框架扩展白盒框架：通过代码层面的继承进行框架扩展 4.2LSP 4.2.1LSPLiskovSubstitutionPrinciple中子类重写父类的方法应该满足的条件： 编译器在静态类型检查时强制满足的条件 子类型可以增加方法，但不可删除子类型需要实现抽象类型中的所有未实现方法子类型中重写的方法返回值必须与父类相同或符合co-variance(协变)子类型中重写的方法必须使用同样类型的参数或者符合contra-variance(逆变)的参数子类型中重写的方法不能抛出额外的异常还应该满足的条件 更强的不变量(RI)更弱的前置条件更强的后置条件协变关于返回值的类型，应该保持不变或者变得更具体，也就是与派生的方向一致。 所抛出的异常的类型也是如此。 4.2.2.4种委派方式 1.Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。 2.Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。 3.Composition:更强的association，但难以变化。 4.Aggregation:更弱的association，可动态变化。 4.3.6种经典复用模式 1.Adapter适配器模式目的是将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。 因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。 2.Decorator装饰器模式 装饰器模式的原理是从接口派生出子类，然后在子类中定义一个父类接口然后将其作为delegation的对象，也就是说：自己到自己的委派。这里第一个自己指的是子类型本身，第二个自己是指该接口的其他子类，由于他们两个是同一个接口的子类，所以可以称为自己到自己的委派。 3.Facade外观模式 客户端在调用的API时候会以固定的方式调用一系列的方法，而为了简化客户端的使用，便于客户端的学习使用、解耦，所以需要提供一个统一的接口来取代一系列小接口调用，对复杂系统做了一个封装。 4.Strategy策略模式 有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。 5. TemplateMethod模板模式 做事情的步骤一样，但具体方法不同，因此共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。 在模板中，实现了一个固定执行一系列操作的方法，这个方法使用final关键字做了限定，不能再被子类重写，因此，子类只能通过重写该方法调用的那些尚未实现的方法。 6.Iterator迭代器模式 客户端希望遍历被放入容器/集合类的一组ADT对象，而无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式 实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。 5.可维护性 5.可维护性 5.1SOLID设计原则 1.(SRP)TheSingleResponsibilityPrinciple---------单一责任原则 尽可能地将功能分割，以达到不应该有多于一个原因让你的ADT发生变化的目的，否则就要拆分开。如果多个责任（功能）放在一个类中就有可能在未来某一个功能发生变化的时候影响到整个类，从而影响到整个程序的很大一部分实现（需要全部重新编译打包部署）。2.(OCP)TheOpen-ClosedPrinciple-------------------开放-封闭原则 在未来对功能进行修改或者扩展的时候，要遵循尽量不去改动已有的代码而是扩展出新的类然后调用新的类的原则。 典型的违反OCP的例子是大量的使用if-else/switch-case语句，这给维护造成了极大的麻烦。所以应对的方法是让客户端传入接口的不同子类型，而在ADT中只需要统一的调用接口中共有的方法即可。 3.(LSP)TheLiskovSubstitutionPrincipleLiskov----替换原则 子类型必须能够替换其基类型。4.(DIP)TheDependencyInversionPrinciple--------依赖转置原则 具体的模块应该依赖于抽象的模块，但抽象的模块不应依赖于具体的模块。5.(ISP)TheInterfaceSegregationPrinciple----------接口隔离原则 大接口分解为多个小的接口。 5.2可维护性的设计模式 1.FactoryMethod工厂方法当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。 定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 当然也可以通过直接定义静态工厂方法来创建子类实例。 2.AbstractFactory抽象工厂当client需要的是多个具有固定搭配的类的组合，如A和B两个系列的类，A1搭配B1，A2搭配B2，于是，就要用抽象工厂对其做一次封装。 定义一个用于创建对象的接口，让其子类来决定实例化哪一组类，从而使类与类之间的搭配对于client来说固定了。 本质上，AbstractFactory是把多类产品的factorymethod组合在一起 3.Proxy代理模式某个对象比较“敏感”/“私密”/“贵重”，不希望被client直接访问到，故设置proxy，在二者之间建立防火墙。 创建一个代理类，它接受client的功能请求，然后把功能请求转发(delegate)给实现类，类似于Adapter模式。 4.Observer观察者模式 5.Visitor对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。 为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT 本质上是将数据和作用于数据上的某种/些特定操作分离开来。 6.共性和差异Proxyvs.AdaptorAdapter：目的是消除不兼容，目的是B以客户端期望的统一的方式与A建立起联系。 Proxy：目的是隔离对复杂对象的访问，降低难度/代价，定位在“访问/使用行为” Visitorvs.IteratorIterator：目的是以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。 Visitor：在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT Strategyvs.visitor同：二者都是通过delegation建立两个对象的动态联系 Visitor：强调是的外部定义某种对ADT的操作，该操作于ADT自身关系不大（只是访问ADT），故ADT内部只需要开放accept(visitor)即可，client通过它设定visitor操作并在外部调用。 visitor是站在外部client的角度，灵活增加对ADT的各种不同操作（哪怕ADT没实现该操作）。 Strategy：强调是对ADT内部某些要实现的功能的相应算法的灵活替换。这些算法是ADT功能的重要组成部分，只不过是delegate到外部strategy类而已。 strategy是站在内部ADT的角度，灵活变化对其内部功能的不同配置。 6.正确性&健壮性 6.正确性&健壮性 6.1并发 并发编程有两种模式： 共享内存：在内存中读写共享数据，某一时刻执行在不同处理器上的同一程序共享内存里的数据；消息传递：通过channel交换消息，A把消息发给B，B把执行结果发给A 6.2线程安全 1. Confinement限制数据共享，将可变数据限制在单一线程内部，不允许任何线程直接读写该数据。 核心思想：线程之间不共享mutable数据类型。 避免使用全局数据，而是使用局部数据。如果使用全局的mutable的数据，就有可能造成竞争条件。 2.Immutability共享不可变数据，使用不可变数据类型和不可变引用，避免多线程之间的racecondition，因为不可变数据通常是线程安全的。 大家都只是读取它的值，而不能对它做出更改，所以它是线程安全的。 不可变类型要满足的条件： 没有mutator方法所有的数据域都是private和final的没有表示泄露rep中的mutable的数据没有任何改变3.UsingThreadsafeDataTypes共享线程安全的可变数据，如果必须要用mutable的数据类型在多线程之间共享数据，要使用线程安全的数据类型。 在JDK中的类，文档中明确指明了是否threadsafe。 一般来说，JDK同时提供两个相同功能的类，一个是threadsafe，另一个不是(threadsafe的类一般性能上受影响)。例如： StringBuffervs.StringBuilder StringBuffer是线程安全的，可被安全的用于多线程。 StringBuilder是线程不安全的，但它的运行速度要比StringBuffer更快。 4:LocksandSynchronization 同步机制：通过锁的机制共享线程不安全的可变数据，变并行为串行。 6.3锁、同步 6.3.1锁 Lock是Java语言提供的内嵌机制。在Java中，任何对象都可以作为锁。可以创建一个没有意义的对象Objectlock=newObject();作为锁来使用，而拥有lock的线程可独占式的执行该部分代码。 6.3.2同步 程序员来负责多线程之间对mutable数据的共享操作，通过“同步”策略，避免多线程同时访问数据。 使用锁机制，获得对数据的独家mutation权，其他线程被阻塞，不得访问。 当A线程申请了A锁时，它获得了对数据的独家修改访问权限，B线程再想访问时，就必须申请A锁的使用权限，这就要等A线程执行结束释放锁时候再获得。 
第431篇文章[]
软件构造-关于图 一些概念： 1.连通图与连通分量 连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。 连通分量：非连通图中的各个连通子图称为该图的连通分量。 2.邻接矩阵 邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。 3.邻接表 邻接表是图的一种链式存储表示方法。它是改进后的"邻接矩阵"，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。 1.顶点类： 在非常抽象的图的问题中，知识简单的把顶点编号，从0->n-1,不需要任何变量类型来存储顶点，因为他们的用处来自于他们之间的相互关系，但大多数情况下，顶点表示某个真实世界的对象。顶点对象能放在数组中，然后用下标指示。 packagecom.cn.graph;/** *图的顶点类 *@authorAdministrator * */publicclassVertex{publiccharlable;publicbooleanwasvisited;publicVertex(charlab){ lable=lab; wasvisited=false;}} 2.深度优先搜索 找到一个起始点---本例为顶点A,需要做三件事情，首先访问该节点，然后把该点放入栈中，以便记住它，最后标记该点，这样就不会再访问它了。 packagecom.cn.graph;/** *深度优先实现的图 *@authorAdministrator * */publicclassGraph{privatefinalintMAX_VERTS=20;privateVertex[]vertexList;privateintadjMat[][];publicintnVerts;privateStackXtheStack;publicGraph(){ vertexList=newVertex[MAX_VERTS]; adjMat=newint[MAX_VERTS][MAX_VERTS]; nVerts=0; for(inti=0;i<MAX_VERTS;i++){ for(intj=0;j<MAX_VERTS;j++){ adjMat[i][j]=0; } } theStack=newStackX();}publicvoidaddVertex(charlab){ vertexList[nVerts++]=newVertex(lab);}publicvoidaddEdage(intstart,intend){ adjMat[start][end]=1; adjMat[end][start]=1;}publicvoiddisplayVertex(intv){ System.out.print(vertexList[v].lable+"");}publicvoiddfs(){ vertexList[0].wasvisited=true; displayVertex(0); theStack.push(0); while(!theStack.isEmpty()){ intv=getAdjUnvisitedVertex(theStack.peek()); if(v==-1) theStack.pop(); else{ vertexList[v].wasvisited=true; displayVertex(v); theStack.push(v); } } for(inti=0;i<nVerts;i++) vertexList[i].wasvisited=false;}publicintgetAdjUnvisitedVertex(intv){ for(inti=0;i<nVerts;i++) if(adjMat[v][i]==1&&vertexList[i].wasvisited==false) returni; return-1;}} 3.广度优先 首先访问起始顶点的所有邻接点，然后再访问较远的区域，用队列来实现它。（A是起始点，所以访问它，并标记为当前顶点，然后应用规则）。 packagecom.cn.graph;/** *图的广度优先搜索---队列类 *@authorAdministrator * */publicclassQueue{privatefinalintSIZE=20;privateintqueueArray[];privateintfront;privateintrear;publicQueue(){ queueArray=newint[SIZE]; front=0; rear=-1;}publicvoidinsert(intj){ if(rear==SIZE-1) rear =-1; queueArray[++rear]=j;}publicintremove(){ inttemp=queueArray[front++]; if(front==SIZE) front=0; returntemp;}publicbooleanisEmpty(){ return(rear+1==front||front+SIZE-1==rear);}} 
第432篇文章[1]
删除.dll文件时遇到的一点问题（操作无法完成因为在资源管理器中打开、系统找不到指定路径） 本人之前误下了一个流氓软件，不仅每天弹窗很多广告，找到它安装路径的文件夹还发现了许多其他软件的.exe。在删除多数文件后有两个文件一直删不掉，显示为“操作无法完成，因为文件已在windows资源管理器打开”。这种一般是.dll文件。 0.先复制要删除的文件路径，包括文件名字。 1.按住Ctrl+Alt+Del,出现如下界面： 选择任务管理器。 2. 如图，在详细信息中找到explorer.exe,右键后选择结束任务（不是结束进程树），这时候屏幕最下方一行会消失。 3.接着选择上方文件，点击选择运行新任务，打开cmd窗口。 4.输入del+空格+所要删除的文件路径（带文件名） 正常来说到这一步就能删除了。但是有可能命令行会显示系统找不到指定路径，是因为路径太复杂了，需要把路径弄短一点，比如把待删除文件直接剪切粘贴到桌面或C盘下。 5.回到任务管理器，依然是点上方文件+运行新任务，在输入栏里输入explorer,如果确定栏是灰的不能点就点一下一系统管理权限创建此任务再点确定。 完成。 
第433篇文章[1]
HIT计算机系统大作业：hello的一生 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 Hello的P2P：从hello.c的源文件开始，通过GCC编译器驱动程序对它进行预处理后生成hello.i文件，再通过编译器生成汇编程序hello.s，汇编程序再通过汇编器生成可重定位目标程序，最后再与标准库函数进行链接生成可执行文件。然后在shell中运行可执行文件，shell通过fork()函数为它开辟新的子进程。Hello.c就从Program变成了Process。 Hello的020：Hello变成进程后，shell再调用execve()函数将程序加载进来：先删除已存在的用户区域，再为Hello映射新的私有区域，映射共享区域。CPU来控制Hello的运行，为它分配资源。当进程结束后，通过父进程回收，通过内核将数据删除，将Hello运行的所有记录消除。 1.2环境与工具 软件环境：VMware®Workstation14Player，Ubuntu16.04LTS64位。硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk。开发调试工具：GCC编译器，EDB，as，ld，readelf。 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 Hello.c Hello的c语言代码 Hello.i 预处理之后的文本文件 Hello.s 编译之后产生的汇编文件 Hello.ld 链接后的文件 Hello.o 可重定位的目标文件 Hello 可执行文件hello Helloo.objdump Hello.o反汇编文件 Hello.elf Hello的ELF格式 Hello.objdump Hello的反汇编文件 1.4本章小结 即使是对于再简单的hello，也同样涉及到了关于计算机系统的从硬件到软件的各个部分的共同配合才能实现一个hello的功能。因此我们要根据hello来了解计算机系统的各个组成部分,从顶层到底层,然后再由底层到顶层,这样我们就进一步了解计算机系统是如何构造和运作的,便于我们更加深刻的了解计算机系统。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 预处理是指在编译之前的预处理阶段，预处理程序对程序进行的操作.预处理器根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件。 1.将所有的#define删除，并展开所有的宏定义； 2.处理所有的预编译指令，例如：#if,#elif,#else,#endif; 3.处理#include预编译指令，将被包含的文件插入到预编译指令的位置； 4.添加行号信息文件名信息，便于调试； 5.删除所有的注释：///**/; 6.保留所有的#pragma编译指令，因为在编写程序的时候,我们经常要用到#pragma指令来设定编译器的状态或者是指示编译器完成一些特定的动作。 生成.i文件。 包括:1.宏定义2.文件包含(文件包含是指把指定文件的全部内容包括到当前源程序文件中。)3.条件编译(指在特定的条件下，对满足条件和不满足条件的情况分别进行处理 满足条件时编译某些语句，不满足条件时编译另一些语句。) 预处理的主要作用仅仅是对程序代码文本进行替换操作，如将以#include格式包含的文件内容复制到编译的源文件中，用实际值替换#define定义的宏，以及根据#if的条件决定需要编译的代码。预处理过后程序代码中的预处理指令会被删除。所以预处理器的输出是原程序的一个编辑后的、不包含指令的版本。 2.2在Ubuntu下预处理的命令 预处理命令行：gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析 经过预处理程序处理hello.c源文件由23行扩展成为3000多行，main函数被放在了最后，而前面3000多行是hello.c引用的头文件，如stdio.h。预处理过程中预处理器（cpp）识别到#include这种指令就会在环境中搜寻该头文件并将其递归展开。 #include,#include‘stdio.h’这两种表示形式有区别，第一种系统会直接在c库函数头文件所在的目录中查找要包含的文件，第二种是用户在当前目录中查找，如果找不到才回到c库函数头文件所在目录中华查找要包含的文件，一般用于自己编写的头文件 2.4本章小结 通过本章我们了解到了预处理.预处理是整个编译过程的第一步，在翻译器中，C预处理器（cpp）将源文件翻译成一个ASCII码的中间文件。在这个过程中仅仅是将一些.c文件里面用到的、涉及到的函数库头文件复制到程序源文件中、在程序代码中替换宏定义，并根据条件编译的条件保留相应的内容,直到预处理文件中不包含任何预处理命令为止,就这样完成了预处理的指令，为其继续翻译成机器能够识别的汇编语言文件打下基础。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译是指编译器（ccl）将文本文件hello.i翻译成文本文件hello.s的过程，这个文本文件内包含了一个汇编语言程序。 作用：编译过程编译器实现了经过词法分析、语法分析、语义分析等过程，在检查无错误后将代码翻译成汇编语言。得到的汇编语言代码可供编译器进行生成机器代码、链接等操作。由于计算机并不能直接接受和执行用高级语言编写的源程序（此处指.c，.i文件），因而利用编译器，能将高级语言编写的程序全盘扫描，翻译成用机器语言表示的与之等价的目标程序（此处指.s，即汇编语言程序），该目标程序能被计算机接受和执行，以便后续翻译等操作进行。 3.2在Ubuntu下编译的命令 编译命令行：gcc-Ehello.c-ohello.s 结果展示为： 3.3Hello的编译结果解析 文件声明： .file源文件 .text代码段 .globel全局变量 .align对齐格式 .type对象类型或函数类型 .size数据空间大小 .section.rodata只读代码段 .string字符串 数据： .s文件中主要数据类型为：整形，字符串，指针数组 1.整形 （1）.main参数intargc： Argc是函数传入的第一个int的参数，存储在%edi中，表示终端输入的参数的个数多少。 （2）.main函数中的局部变量inti： 函数内部的局部变量存于堆栈中，其中用movl$0,-4(%rbp)进行数据在堆栈内的存储，并且由于-4所以可知i占用了4字节大小的栈空间 2.字符串： （1）第一个字符串.LC0中包含汉字，其中汉字的编码方式为utf-8编码，汉字被编码为三个字节。 （2）第二个字符串.LC1其中的两个%S对应与输入的两个参数：argv[1]和argv[2]。 3.指针数组argv[]: 作为main函数的参数出现在栈帧中。 赋值： 1.对局部变量的赋值： 通过movl指令，利用寄存器和$0,-4(%rbp)指令对局部变量进行赋初值0 算术操作： Hello.c中的主要的算术操作为循环遍历增加（i++）以及语句argc！=4 编译器将i++翻译为addl$1,-4(%rbp) 关系操作： Hello.c中的主要的算术操作为循环的控制（i<10）以及语句argc！=4 编译器将i<8翻译为$7,4(%rbp) 将argc！=4翻译为cmpl$4,-20(%rbp) 数组/指针/结构操作 指针数组(char*argv[])： 在argv数组中，argv[0]指向输入程序的路径和名称，argv[1]和argv[2]和argc[3]分别指向两个用户从终端输入的字符串分别对应学号姓名时间。根据图3-11，可知通过%rax+16和%rax+24%rax+8中存储的地址，(语句：addq$24,%raxaddq$16,%rax以及addq$8,%rax)分别得到argv[1]和argc[2]和argc[3] 控制转移： hello.c内部的控制转移主要有if语句以及for循环内部的控制转移 1.for(i=0;i<8;i++)： for循环的控制时比较cmpl$7,-4(%rbp)，当i大于9时跳出循环，否则进入.L4循环体内部执行 2.if(argc!=4)： 当argc不等于4时进行跳转。cmpl语句比较-20(%rbp)和-4，设置条件码，然后根据ZF进行判断，如果最近的操作得出的结果为0，则跳到.L2中，否则顺序执行下一条语句。 函数操作： 内部主要有5个函数：main(),printf(),exit(),atoi(),sleep(),getchar() 1.main()： 参数传递：传入参数argc和argv，分别用寄存器%rdi和%rsi存储 函数调用：被系统启动函数调用， 函数返回：设置%eax为0并且返回 函数作用：作为程序运行的唯一入口 2.printf()： 参数传递：callputs时只传入了字符串参数首地址；for循环中callprintf时传入了argv[1]和argc[2]的地址。 函数调用：在for循环中被调用 函数作用：用来打印信息 3.exit()： 参数传递：传入一个布尔变量 函数调用：if判断条件满足后被调用 函数作用：如果传入的参数为1，则执行退出命令 4.atoi()： 参数传递：传入参数argv[3] 传递控制：callatoi 函数调用：for循环下被调用 函数作用：将传入的参数从字符串形式转化为int整形 5.sleep()： 参数传递：传入参数argv[3]经过atoi函数的输出值 传递控制：callsleep 函数调用：for循环下被调用 函数作用：使计算机程序（进程，任务或线程）进入休眠 6.getchar(): 传递控制：callgetchar 函数调用：在main中被调用 函数作用：用来读取字符串 3.4本章小结 编译器将预处理后的文本进行汇编处理，对于常量，编译器将它储存到一个特定的位置，记录它的一些信息，比如类型；对于一些特定的常量，比如printf()函数中的信息，编译器会把它提取出来保存。程序中的语句，例如赋值语句，编译器通过寄存器，栈等结构进行赋值；分支语句用je,jle,jge等条件跳转语句进行实现。每种语句都有对应的实现方法。程序中的函数，如果不是库函数，则会对函数进行逐句的语法分析和解析，如果是标准的库函数，编译器可以直接用call语句进行调用。 在本章中，编译器将高级语言编译成汇编语言，在以上的分析过程中，详细的分析了编译器是怎么处理C语言的各个数据类型以及各类操作的，按照不同的数据类型和操作格式，解释了hello.c文件与hello.s文件间的映射关系。在此阶段，编译器将hello.i文件编译成更抽象更低级的hello.s汇编语言文件，为汇编阶段产生机器可识别的机器语言指令打下基础。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编的概念：通过汇编器将汇编语言转化为机器语言。 汇编的作用：汇编器将hello.s翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在hello.o中，hello.o是二进制文件。 4.2在Ubuntu下汇编的命令 汇编命令行：gcc-chello.s-ohello.o 应截图，展示汇编过程！ 4.3可重定位目标elf格 ELF可重定位目标文件的格式： 汇编器在对hello.s文件转化为机器代码后，对程序做出了最基本的处理，在rel.text对每个调用的标准库函数和全局变量给出了偏移量，以及在信息一类中给出的符号在symbol节中的偏移量，以及符号的类型。 4.4Hello.o的结果解析 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 反汇编后的汇编代码已经进行了初始化的定位，形成EIF可重定位文件，并且每条指令都给出了对应的机器码。 1）对于条件分支：.s文件中通过使用.Ln等助记符来标记跳转位置，而在反汇编文件中去掉了这种记号，直接使用偏移地址来进行跳转。 hello.s文件： 反汇编文件： 2）对于函数调用：在.s文件中，call指令后面接的是函数名，并没有给出地址，而在反汇编文件中，给出了函数的偏移地址。因为在汇编的过程中，对于程序中的函数，汇编器在EIF文件的rel.text段中给出了定位，所以反汇编中函数就有了相对于首地址的偏移地址。 hello.s文件： 反汇编文件： 3）对于全局变量调用：.s文件中通过全局变量的名字加上%rip的值来调用，而在反汇编代码中通过0x0加上%rip的值来调用。因为在.s文件中并没有给出全局变量地址的信息，所以只能通过变量名来标记；在反汇编代码中，已经对全局变量作出了定位处理，当后续操作进行链接后就可以给出绝对地址了。 hello.s文件: 反汇编文件： 4.5本章小结 汇编器对hello.s文件进行汇编，生成了可重定位文件。对文件的全局变量，函数，程序语句都进行了分析，给出了初始的相对位置信息，相当于对整个文件做出了一个初始的整理，为后面的链接等操作做准备。 （以下格式自行编排，编辑时删除） （第4章1分） 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。 5.2在Ubuntu下链接的命令 执行命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5-1链接截图 5.3可执行目标文件hello的格式 执行命令：readlf-ahello 得到Sectionheader的信息截图如下，其中offset为各section的在程序中的地址偏移量，size为各段的大小，基本信息与可重定位文件相似，见4.3节。这里的Sectionheader与可重定位文件有一个明显的区别就是address不再都是0了，被分配了相应的虚拟空间的地址。 图5-2hello的ELF文件sectionheader 5.4hello的虚拟地址空间 通过view->memoryregions开业查看程序运行各个段的地址。 第一段0x400000~0x401000为1~11段的地址 第二段0x401000~0x402000为12~16段的地址 第三段0x402000~0x403000为17~28段的地址。 第四段0x403000~0x405000为19~22段的地址。 剩下的.so为共享库的地址，还有[stack]堆栈的地址。 在0x400000~0x405000段中，程序被载入，自虚拟地址0x400000开始，自0x404fff结束，这之间每个节（开始~.data节）的排列即开始结束同图5.2中Address中声明。 图5-3hello程序的虚拟内存区域 5.5链接的重定位过程分析 （以下格式自行编排，编辑时删除） objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 与hello.o反汇编文本helloo.objdump相比，在hello.objdump中多了许多节，列在下面。通过比较hello.objdump和helloo.objdump了解链接器。 1.函数个数：在使用ld命令链接的时候，指定了动态链接器为64的/lib64/ld-linux-x86-64.so.2，crt1.o、crti.o、crtn.o中主要定义了程序入口_start、初始化函数_init，_start程序调用hello.c中的main函数，libc.so是动态链接共享库，其中定义了hello.c中用到的printf、sleep、getchar、exit函数和_start中调用的__libc_csu_init，__libc_csu_fini，__libc_start_main。链接器将上述函数加入。 2.函数调用：链接器解析重定条目时发现对外部函数调用的类型为R_X86_64_PLT32的重定位，此时动态链接库中的函数已经加入到了PLT中，.text与.plt节相对距离已经确定，链接器计算相对距离，将对动态链接库中函数的调用值改为PLT中相应函数与下条指令的相对地址，指向对应函数。对于此类重定位链接器为其构造.plt与.got.plt。 3. rodata引用：链接器解析重定条目时发现两个类型为R_X86_64_PC32的对.rodata的重定位（printf中的两个字符串），.rodata与.text节之间的相对距离确定，因此链接器直接修改call之后的值为目标地址与下一条指令的地址之差，指向相应的字符串。 图5-4初始化函数_init反汇编代码 图5-5.plt函数反汇编代码 图5-6 hello调用库函数的反汇编代码 图5-7_start程序（调用hello.c中的main函数）反汇编代码 我们来看main函数反汇编代码，他调用的函数都已经在hello的反汇编代码中显示的定义了出来，有地址有名称，可以直接call这个函数，跳转到函数的地址。他调用的rodata也是可以直接跳转到具体地址的。 图5-8main函数反汇编代码 图5-9调用的动态库的反汇编代码。 5.6hello的执行流程 在edb中加载hello可执行文件列出所有过程(终端输入hello1190301610wangjiaqi) 子程序名地址ld-3.31.so!_dl_start7efbff4d8ea0ld-3.31.so!_dl_init7efbff4e7630Hello!_start400500libc-3.31.so!_libc_start_main7efbff100ab0Hello!printf@plt(10)4004c0Hello!sleep@plt(10)4004f0Hello!getchar@plt4004d0Libc-3.31.so!exit7efbff122120 列出所有过程（未输入） 子程序名地址ld-3.31.so!_dl_start7efbff4d8ea0ld-3.31.so!_dl_init7efbff4e7630Hello!_start400500libc-3.31.so!_libc_start_main7efbff100ab0Hello！puts@plt4004b0Hello！exit@plt4004e0 5.7Hello的动态链接分析 对于动态共享库里面的PIC函数，编译器没有办法预测函数运行时候的地址，所以需要为他天骄重定位记录，并等待动态链接器来处理。为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT和全局偏移量表GOT实现函数的动态链接。其中GOT中存在函数目标地址，PLT使用GOT中的地址跳转到目标函数。 5.8本章小结 本章详细讲述了hello在执行的时候的链接操作，包括链接的概念，作用，在Unbuntu下怎么链接。并对hello的ELF文件进行了详细的解析，同时结合了虚拟地址的空间知识。通过反汇编hello文件，将它与hello.o反汇编文件进行对比，加深了对重定位的理解。最后对hello的动态链接过程进行了分析。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程是操作系统一个正在运行的程序的一种抽象。程序在系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器，主存和I/O设备。处理器看上去就像在不间断地一条接一条的执行程序中的指令。 进程的作用：通过进程的概念，系统可以实现多线程，并发运行等操作。 6.2简述壳Shell-bash的作用与处理流程 shell作为父进程通过fork函数为hello创建一个新的进程，供其执行。通过fork函数，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本。 处理流程：shell执行一系列的读／求值(read/evaluate)步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。 6.3Hello的fork进程创建过程 Shell通过调用fork函数创建一个新的运行的子进程。也就是Hello程序，Hello进程几乎但不完全与Shell相同。Hello进程得到与Shell用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。Hello进程还获得与Shell任何打开文件描述符相同的副本，这就意味着当Shell调用fork时，Hello可以读写Shell中打开的任何文件。Sehll和Hello进程之间最大的区别在于它们有不同的PID。 6.4Hello的execve过程 创建进程后，在子进程中通过判断pid即fork()函数的返回值，判断处于子进程，则会通过execve函数在当前进程的上下文中加载并运行一个新程序。execve加载并运行可执行目标文件，且带参数列表argv和环境变量列表envp。只有当出现错误时，execve才会返回到调用程序。 在execve加载了可执行程序之后，它调用启动代码。启动代码设置栈，并将控制传递给新程序的主函数，即可执行程序的main函数。此时用户栈已经包含了命令行参数与环境变量，进入main函数后便开始逐步运行程序。 6.5Hello的进程执行 创建进程后，在子进程中通过判断pid即fork()函数的返回值，判断处于子进程，则会通过execve函数在当前进程的上下文中加载并运行一个新程序。execve加载并运行可执行目标文件，且带参数列表argv和环境变量列表envp。只有当出现错误时，execve才会返回到调用程序。 在execve加载了可执行程序之后，它调用启动代码。启动代码设置栈，并将控制传递给新程序的主函数，即可执行程序的main函数。此时用户栈已经包含了命令行参数与环境变量，进入main函数后便开始逐步运行程序。 6.5Hello的进程执行 逻辑控制流：一系列程序计数器PC的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 hello程序执行过程中存储时间分片，与操作系统的其他进行并发运行。并发执行涉及到操作系统内核采取的上下文交换策略。内核为每个进程维持一个上下文，上下文就是内核重新启动一个先前被抢占的进程所需的状态。 在执行过程中，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程，这个过程称为调度。 在此基础上，hello程序与操作系统其他进程通过操作系统的调度，切换上下文，拥有各自的时间片从而实现并发运行。 程序在涉及到一些操作时，例如调用一些系统函数，内核需要将当前状态从用户态切换到核心态，执行结束后再及时改用户态，从而保证系统的安全与稳定。 6.6hello的异常与信号处理 Ctrl-C命令，hello被终止，如下图。 图6-4 Ctrl-C Ctrl-z命令，hello被暂停，利用ps查看，还可以看到hello仍在进程里面。 图6-5 Ctrl-z后运行ps Ctrl-z命令，hello被暂停，利用jobs查看，还可以看到hello状态为stopped。 图6-6 Ctrl-z后运行jobs Ctrl-z命令，hello被暂停，执行fg，hello继续执行，jobs里面没有hello，hello被父进程回收。 图6-7 Ctrl-z后运行fg 6.7本章小结 在本章中hello已经正式上岗工作运行了，这都多亏于“进程”这个概念的提出。进程给hello提供了抽象的概念，使得进程能够有条不紊的并发执行。各个进程之间也不会产生严重的矛盾和冲突，是进程使得不同的程序能在相安无事的运行直到结束。 本章主要介绍了进程的概念和作用，描述了shell如何在用户和系统内核之间搭建桥梁，介绍了fork函数和execve函数在调用程序中的作用，程序的异常如何处理，不同进程之间是如何进行上下文切换等等内容。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 物理地址：物理地址是内存单元的绝对地址，与地址总线具有对应关系。无论CPU如何处理地址，最终访问的都是物理地址。CPU实模式下段地址+段内偏移地址即为物理地址，CPU可以使用此地址直接访问内存。物理地址的大小决定了内存中有多少个内存单元，物理地址的大小由地址总线位宽决定。 线性地址（虚拟地址）：CPU在保护模式下，“段基址+段内偏移地址”为线性地址，如果CPU在保护模式下未开启分页功能，线性地址将被当成物理地址使用。若开启了虚拟分页功能，线性地址等同于虚拟地址，此时虚拟地址需要通过页部件电路转化为最终的物理地址。虚拟地址是CPU由N=2n个地址空间中生成的，虚拟地址即为虚拟空间中的地址。 逻辑地址：无论cpu在什么模式下，段内偏移地址又称为有效地址/逻辑地址 Hello中的指令地址都是16位的虚拟地址，在程序中虚拟地址和逻辑地址没有明显的界限。 逻辑地址转换成线性地址（虚拟地址），由段式管理执行的 线性地址转换成物理地址，是由页式管理执行的 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部分组成，段标识符和段内偏移量。段标识符由16位字段组成，前13位为索引号。 索引号是段描述符的索引，很多个描述符，组成了一个数组，叫做段描述表，可以通过段描述标识符的前13位，再这个表中找到一个具体的段描述符，这个描述符就描述了一个段，每个段描述符由八个字节组成。 段描述符中的base字段，描述了段开始的线性地址，一些全局的段描述符，放在全局段描述符表中，一些局部的则对应放在局部段描述符表中。由T1字段决定使用哪个。 以下是具体的转化步骤： 1.给定一个完整的逻辑地址。 2.看段选择符T1，知道要转换的是GDT中的段还是LDT中的段，通过寄存器得到地址和大小。 3.取段选择符中的13位，再数组中查找对应的段描述符，得到BASE，就是基地址。 4.线性地址等于基地址加偏移。 7.3Hello的线性地址到物理地址的变换-页式管理 分页管理机制通过上述页目录表和页表实现32位线性地址到32位物理地址的转换。控制寄存器CR3的高20位作为页目录表所在物理页的页码。首先把线性地址的最高10位(即位22至位31)作为页目录表的索引，对应表项所包含的页码指定页表；然后，再把线性地址的中间10位(即位12至位21)作为所指定的页目录表中的页表项的索引，对应表项所包含的页码指定物理地址空间中的一页；最后，把所指定的物理页的页码作为高20位，把线性地址的低12位不加改变地作为32位物理地址的低12位。 为了避免在每次存储器访问时都要访问内存中的页表，以便提高访问内存的速度，80386处理器的硬件把最近使用的线性 物理地址转换函数存储在处理器内部的页转换高速缓存中。在访问存储器页表之前总是先查阅高速缓存，仅当必须的转换不在高速缓存中时，才访问存储器中的两级页表。页转换高速缓存也称为页转换查找缓存，记为TLB。 在分页机制转换高速缓存中的数据与页表中数据的相关性，不是由80386处理器进行维护的，而必须由操作系统软件保存，也就是说，处理器不知道软件什么时候会修改页表，在一个合理的系统中，页表只能由操作系统修改，操作系统可以直接地在软件修改页表后通过刷新高速缓存来保证相关性。高速缓存的刷新通过装入处理器控制寄存器CR3完成。 7.4TLB与四级页表支持下的VA到PA的变换 TLB可以理解为页表的一个小的，虚拟寻址的高速缓存（类似cache是内存的一个缓存），用于组选择和行匹配的索引和标记字段是从虚拟地址的页号中提取出来的，如下图所示，如果TLB有2^t组，TLB索引（TLBI）由VPN的t个低位组成的，TLB标记（TLBG）是由VPN中剩余的位组成的。 图7-TLB寻址 为了减少页表在内存空间的占用，引入了多级页表的机制，k级页表示意图如下。如果虚拟内存不存在，则不分配页表来记录这段内存。 1级页表指向2级页表，2级页表存储的是3级页表基地址，只有最后一级页表的内容是PTE和物理页号。 图7-K级页表示意图 前提如下：虚拟地址空间48位，物理地址空间52位，页表大小4KB，4级页表。TLB4路16组相联。CR3指向第一级页表的起始位置（上下文一部分）。 解析前提条件：由一个页表大小4KB，一个PTE条目8B，共512个条目，使用9位二进制索引，一共4个页表共使用36位二进制索引，所以VPN共36位，因为VA48位，所以VPO12位；因为TLB共16组，所以TLBI需4位，因为VPN36位，所以TLBT32位。 如图，CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（前32位）+TLBI（后4位）向TLB中匹配，如果命中，则得到PPN（40bit）与VPO（12bit）组合成PA（52bit）。如果TLB中没有命中，MMU向页表中查询，CR3确定第一级页表的起始地址，VPN1（9bit）确定在第一级页表中的偏移量，查询出PTE，如果在物理内存中且权限符合，确定第二级页表的起始地址，以此类推，最终在第四级页表中查询到PPN，与VPO组合成PA，并且向TLB中添加条目。如果查询PTE的时候发现不在物理内存中，则引发缺页故障。如果发现权限不够，则引发段错误。 图7-TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 前提：只讨论L1Cache的寻址细节，L2与L3Cache原理相同。L1Cache是8路64组相联。块大小为64B。 解析前提条件：因为共64组，所以需要6bitCI进行组寻址，因为共有8路，因为块大小为64B所以需要6bitCO表示数据偏移位置，因为VA共52bit，所以CT共40bit。 在上一步中我们已经获得了物理地址VA，使用CI进行组索引，每组8路，对8路的块分别匹配CT（前40位）如果匹配成功且块的valid标志位为1，则命中（hit），根据数据偏移量CO（后六位）取出数据返回。 如果没有匹配成功或者匹配成功但是标志位是1，则不命中（miss），向下一级缓存中查询数据（L2Cache->L3Cache->主存）。查询到数据之后，一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换。 图7-三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 虚拟内存和内存映射解释了fork函数如何为每个新进程提供私有的虚拟地址空间。 为新进程创建虚拟内存。 创建当前进程的的mm_struct,vm_area_struct和页表的原样副本。 两个进程中的每个页面都标记为只读。 两个进程中的每个区域结构（vm_area_struct）都标记为私有的写时复制（COW）。 在新进程中返回时，新进程拥有与调用fork进程相同的虚拟内存。 随后的写操作通过写时复制机制创建新页面。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1.删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2.映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3.映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。图7-8展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3,从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。缺页处理程序从磁盘上用VP3的副本取代VP4，在缺页处理程序重新启动导致缺页的指令之后，该指令将从内存中正常地读取字，而不会再产生异常。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器分为两种：显式分配器、隐式分配器。显式分配器：要求应用显式地释放任何已分配的块，例如malloc（）函数。隐式分配器（垃圾收集器）：要求分配器检测一个已分配块何时不再使用，那么就释放这个块；自动释放未使用的已经分配的块的过程叫做垃圾收集。 隐式空闲链表：所谓隐式空闲链表，对比于显式空闲链表，代表并不直接对空闲块进行链接，而是将对内存空间中的所有块组织成一个大链表，其中Header和Footer中的block大小间接起到了前驱、后继指针的作用。 图7- 隐式空闲链表结构 涉及到的操作包括查找空闲块，malloc一个块，合并空闲块等等。其中比较复杂的就是合并空闲块这个操作，因为合并空闲块，不仅要看此块之后是不是空闲块，还要看之前是不是空闲块，这也是加入头部和角标的原因之一。对于此块前后是否为空闲块，分为以下四种情况，对每种情况要分别考虑。 图7- 隐式空闲链表合并空闲块 7.10本章小结 本章着重介绍了被许多现代操作系统所采用的虚拟内存系统，即访存时地址需要从逻辑地址翻译到虚拟地址并进一步翻译成物理地址，并详细阐述了在TLB和四级页表支持下VA到PA的转换，以及得到了PA后，三级cache下的物理内存的访问过程，最后还讨论了malloc堆区的动态内存分配。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化： 所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。 设备管理：unixio接口 设备管理方法：一个linux文件就是一个m个字节的序列：B0,B1,…,Bk,…,Bm-1所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 （UnixI/O接口： 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访间一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 2.Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO、STOOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值。 3.改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k,初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为K。 4.读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 5.关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： 1.进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的： intopen(char*filename,intflags,mode_tmode); open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。 返回：若成功则为新文件描述符，若出错为-1。 2.进程通过调用close函数关闭一个打开的文件。 intclose(intfd); 返回：若成功则为0,若出错则为-1。 3.应用程序是通过分别调用readwrite函数来执行输入和输出的。 ssize_tread(intfd,void*buf,size_tn); read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 返回：若成功则为读的字节数，若EOF则为0,若出错为-1。 ssize_twrite(intfd,constvoid*buf,size_tn); write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 返回：若成功则为写的字节数，若出错则为-1。 8.3printf的实现分析 首先观察printf函数的实现 我们发现printf函数中，定义了一个字符指针va_list类型的arg，这个函数调用了vsprintf，继续看一下他： 函数主要实现的功能：格式化。接受确定输出格式的字符串fmt，勇哥是字符串对个数变化参数进行格式化，产生格式化输出。 系统函数write 反汇编write函数，发现要调用INT_VECTOR_SYS_CALL，他通过系统调用sys_call这个函数。 再来看sys_call这个函数，通过分析，知道这个函数的主要功能是显示格式化的字符串，将要输出的字符串从总线复制到显卡的显存里面 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。我们要显示的“hello1190301610王家琪”就被打印输出到了显示器上。 8.4getchar的实现分析 getchar有一个int型的返回值.当程序调用getchar时.程序就等着用户按键.用户输入的字符被存放在键盘缓冲区中.直到用户按回车为止(回车字符也放在缓冲区中).当用户键入回车之后,getchar才开始从stdin流中每次读入一个字符.getchar函数的返回值是用户输入的第一个字符的ASCII码,如出错返回-1,且将用户输入的字符回显到屏幕.如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取.也就是说,后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 输入／输出(I/O)是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。Linux本身提供的一些系统函数已经实现了对底层的调用，例如write函数。printf函数正是通过它间接向标准输出这个文件输出内容，它会调用syscall触发中断以内核模式对硬件进行操作。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 hello最开始是一段代码，描述了它想要进行的操作，但它却不能实现操作，因为它缺少各种条件，它只有代码。当系统想要执行它的时候，hello就开始了它的一生： 首先先对hello.c源文件进行预处理，将hello需要的头文件中的信息插入到文本中，生成了hello.i文件；为了更好的翻译为机器代码，hello.i文件被汇编为hello.s汇编文件，对于程序中的函数，变量，语句都进行了语法分析；再将汇编文件编译成为hello.o机器代码文件，是一个二进制文件，并且对于程序中的函数，变量做出了最基础的处理，为它们划分了不同的段，储存了不同的信息，包括偏移量，访问权限等等信息；最后将程序调用的子函数进行链接，并且将逻辑地址转化为虚拟地址，形成了可执行文件。这个时候hello就有了可以被执行的条件，但是它还不能执行，因为它没有系统分配的资源，包括它要运行的空间等等。 当在shell中输入命令行执行hello时，shell首先分析参数，然后调用fork()函数为它开辟新的子进程，这个时候hello就有了资源：它拥有了和父进程完全一样但独立的用户虚拟空间。execxe()函数将hello程序加载到进程。子进程执行hello所请求的操作，并且通过调用异常处理子程序处理执行过程的异常。对于hello的储存管理，处理器采用逻辑控制流的抽象来保证hello的执行，并且采用虚拟内存的抽象，好像hello独占整个内存。系统采用页表来管理hello的虚拟地址，hello的虚拟地址要翻译为物理地址才能找到数据，物理地址首先到cache中找，然后再到主存中找，找到后返回给进程。 hello进程和I/O设备有交互，所以调用了printf()函数。系统对I/O设备采用映射文件的管理方式。 最后hello进程执行完操作后，会由父进程来回收，并且将它所占用的资源删除，这时候hello就结束了。它又变成了一段代码。下一次在用它时，开启的进程是不是和上一个进程是一个呢？还是上一个进程已经永远的结束了呢？ （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 hello.c：hello的c语言源代码 hello.i：预处理后的文本文件 hello.s：hello.i编译后的汇编文件 hello.o：hello.s汇编后的可重定位目标文件 hello.txt：hello.o的elf文件 hello_obj.txt：hello.o的反汇编结果文件 hello：helllo.o与预编译文件链接后的可执行文件 hello_e.txt：可执行文件hello的elf文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42. [2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998 [1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL]. Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/ collection/anatmorp. （参考文献0分，缺失-1分） 
第434篇文章[]
浅谈Java的继承 在生活中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物，同理，波斯猫和巴厘猫继承自猫，这些动物之间会形成一个继承体系。在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。 继承的用法：在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。通过extends关键字让类与类之间产生继承关系。多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。多个类可以称为子类，单独这个类称为父类或者超类。 classPerson{ Stringname; intage; } classStudentextendsPerson{//此处运用了继承的思想，将class继承 voidstudy(){ System.out.println("studentstudy "+age); } } classExtendDemo{ publicstaticvoidmain(String[]args){ Students=newStudent(); s.name="zhangsan"; s.age=20; s.study(); } } 注意事项：1.子类可以直接访问父类中的非私有的属性和行为。2.子类无法继承父类中私有的内容。3.父类怎么来的？共性不断向上抽取而来的。4.Java只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类。 继承的优点：1.继承的出现提高了代码的复用性。2.继承的出现让类与类之间产生了关系，提供了多态的前提。 继承的特点：1.在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类，2.多个类可以继承一个父类。3.在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。例如下面这种情况是允许的。4.在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。 
第435篇文章[]
类与对象的基本概念 类与对象时整个面向对象中最基础的组成单元。 类：是抽象的概念集合，表示的是一个共性的产物，类之中定义的是属性和行为（方法）； 类是定义对象形式的模板，指定了数据以及操作数据的代码。Java中使用类的规范来构造对象，而对象是类的实例。类是逻辑抽象的，只有类的实例 对象才是内存中的物理表示。类一般都包含方法和变量，通过class创建类。 //类由class创建 publicclassPerson{ publicPerson(){ System.out.println("热烈庆祝中国共产党成立一百周年"); } } 对象：对象是一种个性的表示，表示一个独立的个体，每个对象拥有自己独立的属性，依靠属性来区分不同对象。对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步： 1.声明：声明一个对象，包括对象名称和对象类型。 2.实例化：使用关键字new来创建一个对象。 3.初始化：使用new创建对象时，会调用构造方法初始化对象。 publicclassPuppy{ publicStringname_; publicSupper(Stringname) { name_=name; } publicstaticvoidmain(String[]args) { SuppermySupper=newSupper("tommy");//这条语句将创建一个Puppy对象 } } 可以一句话来总结出类和对象的区别：类是对象的模板，对象是类的实例。类只有通过对象才可以使用，而在开发之中应该先产生类，之后再产生对象。类不能直接使用，对象是可以直接使用的。 
第436篇文章[]
面向对象编程的特点 对于初学Java的新手来说，Java的面向对象问题比较难理解，今天我就对此问题谈一谈自己所学到的知识。 Java面向对象编程作为一种编程思想，有三大特性，封装，继承，多态。次三类特性可以说是决定面向对象编程的根本，只有对此概念有一定的理解，才能学好Java语言。 1.封装 把客观事物封装成抽象的类，并且把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。也就是说，抽象数据类型对数据信息以及对数据的操作进行打包，将其变成一个不可分割的实体在这个实体内部，我们对数据进行隐藏和保密，只留下一些接口供外部调用。 简而言之，一个类就是一个封装了数据以及操作代码的实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。 封装类似于黑箱操作。一个具体复杂的对象有很多的属性和方法，有些需要公开，有些不需要公开，就好比一个具体的人的信息，有些是public，有些是private，而有些是protecred，别人问到的时候对于怎么样的信息都有不同的态度。根据与这个人的关系来回答问题，封装的结果是输出结果，不问过程。 比如我们将一个房子看做是一个对象，里面的漂亮的装饰，也有实用的家具，这都是该房子的私有属性，但是家是属于私人的，不可以被他人随意观看或出入，封装就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设，同时不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。 2.继承 继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。在本职上是特殊和一般的关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。 Java的继承属性避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围 在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。 继承的原则：1.能够继承父类的public和protected成员变量，不能够继承父类的private11成员变量。2.对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承。3.对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。 3.多态 相比于封装和继承，Java多态是三大特性中比较难的一个，封装和继承最后归结于多态，多态指的是类和类的关系，两个类由继承关系，存在有方法的重写，故而可以在调用时有父类引用指向子类对象。自己对于多态的理解还不够深刻，故而分享的不是很多，敬请见谅。 
第437篇文章[]
Java注释的简单理解 每种编程语言的语法规范中都包含了注释的规则，从早期的C到近些年的Python大体上各种语言的注释要求都类似。良好的注释习惯会让别人很轻松地阅读你的代码，同时，也让自己的编程过程中的想法有了准确的记录，下面就我最近学习的Java语言，与大家分享一下我的理解。 在Java中有3种类型的注释，分别是单行注释、多行注释和文档注释。 1.单行注释 单行注释的作用是注释一行代码。它是使用双斜线（//）标注的，注释的内容放在“//”的后面。 //注释内容 2.多行注释 如果我们想同时注释连续的多行代码，可以使用多个单行注释。但是这种方式太过繁琐，我们可以直接使用多行注释的方式。 多行注释的作用是注释连续的多行内容。它把注释的内容放在“/*”开始，“*/”结束的区域内。这其中的一切内容均属于注释部分，不用做代码处理。 /*多 行 注 释 */ 3.文档注释 单行注释和多行注释是大多数程序语言共有的，Java语言在二者之上还有自己独有的文档注释。 文档注释的好处是将分离的代码和注释连接起来，保证代码与注释内容可以同时更新。除此之外，文档注释还可以生成API文档。 文档注释以“/**”开始，“*/”结束，中间的内容全部都是文档注释。 /** 文档注释 */ 不过，要想保证代码与注释同时更新，仅使用“/**”、“*/”这两个符号是不够的，还要使用到文档注释的标签，也可以称为“标记”。文档注释的标记是什么、完整的文档注释应该怎么编写、如何将文档注释生成API见“2.文档注释生成API文档”。下面是3种注释的示例。 packagestudy._cqf; /** *主题：Java中的注释 * *@authorCongqiufeng * */ publicclassstudy{ /** *【文档注释】 *@param字符串数组 *@returnvoid类型 */ publicstaticvoidmain(String[]args){ /* *【多行注释】 *System类字段out */ System.out.println("HelloWorld!");//【单行注释】输出内容为HelloWorld! } } 
第438篇文章[]
对于重载，重写的理解 重载概念： 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。 调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法,这就是多态性。重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。 重载的规则： 1）、必须具有不同的参数列表； 2）、可以有不同的返回类型，只要参数列表不同就可以了； 3）、可以有不同的访问修饰符； 4）、可以抛出不同的异常； 重载和重写（覆盖）的特点： Override特点 1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果； 2、覆盖的方法的返回值必须和被覆盖的方法的返回一致； 3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 2.Overload特点 1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）； 2、不能通过访问权限、返回类型、抛出的异常进行重载； 3、方法的异常类型和数目不会对重载造成影响； 4、对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。 
第439篇文章[]
软件构造复习笔记 软件构造课程复习笔记1 1.软件构造中的多维度视图2.视图间的转换3.软件系统的质量 由于在之前的夏季小学期选择的课程并非java，因此在java方面投放了部分精力自学。博客整理的开始时间较晚，请见谅。现在开始对软件构造课程进行复习和整理。（主要基于对课件的阅读以及课堂知识的整理） 1.软件构造中的多维度视图 Moment维度是指程序在某一个时刻的表现，而Period维度指程序在一段时间内的表现；Build-time维度是指程序在编码阶段的表现，而Run-time维度关注程序在运行时的表现；Code-level维度在程序代码的语句层面，Component-level维度指程序一段代码：一个包，一个库 Build-timeviews：code-levelview关注源代码的逻辑组织情况，结构，方法等component-levelview关注源代码的物理组织，如库，包，文件等等是如何链接组织起来的(1)Build-time,moment,andcode-levelview关注的是源码的组织情况，可在词汇层面（源码）、语法层面（抽象语法树）、语义层面（类图）三个层面分别分析。AST：抽象语法树（abstractsyntaxcode，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，这所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节，比如说，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。抽象语法树并不依赖于源语言的语法，也就是说语法分析阶段所采用的上下文无文文法，因为在写文法时，经常会对文法进行等价的转换（消除左递归，回溯，二义性等），这样会给文法分析引入一些多余的成分，对后续阶段造成不利影响，甚至会使合个阶段变得混乱。因些，很多编译器经常要独立地构造语法分析树，为前端，后端建立一个清晰的接口。（初始理解就是关于将源代码结构表示为树）AST：彻底结构化，将源代码变为一棵树，对树做各种操作==对源代码的修改(2)Build-time,period,andcode-levelview关注的是代码的变化（Codechurn代码变化）(3)Build-time,moment,andcomponent-levelview关注的是包/库：静态链接库（课件里有一些关于库的知识）(4)Build-time,period,andcomponent-levelview关注代码版本的更迭，而不是具体语句的变化，这里与2不同Run-timeviews区分了动态链接和静态链接(5)Run-time,moment,andcode-levelview关注的是程序在某个时间点内存中的情况，如代码快照图(CodeSnapshot)、内存转储(Memorydump)。(6)Run-time,periodandcode-levelview关注的是代码的执行情况，执行跟踪(7)Run-time,moment,andcomponent-levelview关注的也是包/库，但却是在代码执行过程中的情况，如动态链接库(8)Run-time,period,andcomponent-levelview关注的是系统的使用情况，使用日志查看 2.视图间的转换 Build-time维度：写出代码的维度。moment+Code-level维度，写出了一些零散代码此时随着时间的推移，代码删删改改，就属于Period+Code-level了，而代码越写越多成为了一个包，甚至形成了一个库，于是就属于moment+Component-level维度了（包含了代码间的物理联系），Period+Component-level：库文件由于需求的变化发生了变化，代码写好了，投入运行，进入Run-time维度，观察的如果是某一句代码的执行后结果，那就是moment+Code-level维度，但如果看的是代码执行的轨迹，那就是Period+Code-level维度，而如果看的是一个库文件的连接情况等，那就是moment+Component-level维度，如果看的是线程或进程的执行过程，也就是通过日志等手段查看一段时间内系统都做了什么事情，那么就是Period+Component-level。 3.软件系统的质量 外部质量因素（影响用户）External1:Correctness（正确性），正确就是按照预先定义的“规约”执行，这是软件开发最重要质量指标，一个可用的软件一定是正确的，所以首要保证软件的正确性，其他的都可以做妥协、让步，但只有这一项不可妥协。通过测试和调试可以发现和消除不正确。防御式编程可以在写程序时就保证正确性。形式化方法：通过形式化验证发现问题。External2:Robustness（健壮性），是针对异常情况的处理，对正确性的补充。出现规约定义之外的情形的时候，软件要做出恰当的反应，不要崩溃。External3:Extendibility（可扩展性），要便于软件功能的增加/扩展（ADT、OOP、留下一个Visitor），应对变化，降低未来修改软件时的成本，External4:Reusability（可复用性），在异性之间尽可能地寻找共性，以便于未来可以直接使用现在写的这段代码。这样可以降低软件地开发成本。进行一次开发，多次使用。发现共性。External5:Compatibility（兼容性），在不同的环境下都是可用的，不同的软件系统之间相互可容易的集成。（保持设计的同构性）External6:Efficiency（效率），不要过早的优化，性能在没有正确性保障的条件下是没有意义的。External7:Portability（可移植性），软件可方便的在不同的技术环境之间移植。External8:Easeofuse（易用性），学习成本低，结构简单、清晰，易于使用。（对用户而言）External9:Functionality（功能性），功能过多会导致易用性的降低。主要功能要首要提升质量。External10:Timeliness（时效性），软件要能够在交付时间之前完成开发交给使用者。External10++:Otherqualities，Verifiability(可验证性)，Integrity(完整性)，Repairability(可修复性)，Economy(经济性)。 内部质量因素（影响软件本身以及开发者）代码行数、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小 折中、妥协 完整性与易用性;经济性与功能性；效率与可移植性；效率与可复用性；经济与可复用性；经济性与可扩展性这些质量属性之间往往不能兼得，当某一项满足的足够好的时候有可能其他项的表现极差，因而需要做权衡，使得各部分的表现都较好，在某些特定要求下也可以放弃优化其他项而做到某一项的极致，这需要靠开发者的经验积累来判断。 正确性决不能折中。 在OOP开发中，通过封装、模块化、组件、抽象、分散、错误处理、信息隐藏、框架、接口等技术来尽可能地满足上述地质量因素，提高软件的开发质量。 2.五个关键的质量指标Elegantandbeautifulcode：代码要容易理解，通过统一变量/方法的命名标准、代码的风格、注释、包组织结构、必要时重构代码等方式让代码尽可能的容易理解。Designfor/withreuse：ADT/OOP、接口、继承(Overload、Override)、多态、泛型、框架等技术可用于提高代码的可复用性。Lowcomplexity：当复杂度较低的时候，代码就容易被扩展新的功能，所以要高内聚低耦合，遵从SOLID原则、OO设计模式、使用VCS控制代码版本Robustnessandcorrectness：使用测试驱动的开发、异常处理、Assertion机制、防御式编程等技术保证程序的健壮性和正确性。Performanceandefficiency：使用设计模式、并行/多线程等技术提升性能。 
第440篇文章[]
软件构造复习笔记4 数据类型与类型检验 编程语言的数据类型​在Java中，数据类型分为基本数据类型(int、boolean、char等)和对象数据类型(String、Integer等)。所有的基本数据类型都是Immutable的，而且在栈中分配内存，代价也比较低。而对象数据类型有的是Immutable的，有的是Mutable的，分配的内存都在堆中，代价相对昂贵。因此在能使用基本类型的情况下尽量使用基本数据类型，降低代价。 对象数据类型是OOP的核心，由于对象数据类型存在继承(extends)机制，因此在OOP中可以更好的复用代码。 基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。2.类型检查静态类型语言可执行静态类型检查，在编译阶段进行类型检查，这意味着避免了将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误都可以在静态类型检查时发现；动态类型语言(python)只有动态类型检查，在运行阶段才会进行类型检查，例如非法的参数值(最典型的NULL引用)、非法的返回值、越界等等。（简言之编程时就会报错） 静态类型检查是关于数据类型的检查，它不会关心具体的值，而动态类型检查是关于值的检查。 例如intn=1.1在静态类型检查的时候就会报错，但doublea=0;doubleb=2/a;只有在运行之后，执行动态类型检查的时候才会报告除零错。3.关于不可变性改变变量：使变量指向存储着另一个值的空间 改变变量的值：变量指向的空间不变，变化的是存储的内容。 Immutability：不变性，一个重要的设计原则，设计ADT时尽量保证这个原则。 Immutabletypes：不可变的数据类型，当实例对象被创建以后，该对象的值就不可变化了，也就是该ADT中不能有mutator方法。 在编写程序的时候使用final关键字可以保证该变量不可再被改变，但不能保证该变量的值不变。所以，尽量使用final变量作为方法的输入参数、作为局部变量。 final类无法派生子类 final变量无法改变值/引用 final方无法被子类override(重写) 比较immutable和mutable不变对象：一旦被创建，始终指向同一个值/引用可变对象：拥有方法可以修改自己的值/引用可变对象的优点：虽然mutable类型由于指向的是同一个存储区域，所以更改对象的内容后会在意想不到的位置产生意想不到的变化，所以更推荐使用Imutable的数据类型，但是使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，比如依次将‘a’~‘z’连接到一个空字符串上，就会产生25个临时拷贝，而使用可变类型则最少化拷贝以提高效率。 使用可变数据类型，可获得更好的性能。但是在质量指标中，性能的优先级较低，所以即使mutable类型有这个优点也更倾向于选择imutable的类型。 也适合于在多个模块之间共享数据。在这里强烈不推荐使用Globalvariables。 设计规范 为什么要写注释？因为单靠代码自己无法把开发者的设计决策全部清晰直观地表现出来，如final关键字本身就是一种设计决策，开发者很容易理解，但这个的只要目的不是为了给人读，是为了给编译器读，如果未来程序员对这个部分做了什么改动，编译器可以很快的在静态代码分析中就能发现错误，避免错误带入后面的开发中，而只有注释，才能够让其他人清晰的看到这部分干了什么，甚至是怎么实现的等等信息。为什么要写spec？spec是程序员自己对所写的方法的规约，它规定了方法应该做什么，不应该做什么，有了spec就可以编写测试用例了，因为程序员所编写的代码必定是符合spec的，否则就是不合格的，符合spec的代码也必然能通过根据spec所设计出的测试。同时，有了spec，客户端在使用所写的代码时就有所依据，客户端可以轻松的知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，而不必知道内部逻辑是怎么样的，大大节省了客户端使用自己的API时所需要的时间，并且大大降低了客户端对自己所编写的代码的误解。而且，拥有精确的spec，有助于区分责任，很容易地就可以找到是哪一部分的代码出了问题。最后，由于客户端并不需要了解内部的实现也就意味着你可以在满足spec的大前期下对实现方法进行任意的改动而不需要告知客户端，因为无论你怎么改，只要满足spec，在客户端看来，你的行为(作用)都是相同的。spec的结构precondition前置条件：对客户端的约束，在使用方法时必须满足的条件使用@paramannotation说明每个参数的前置条件postcondition后置条件：对开发者的约束，方法结束时必须满足的条件使用@returnannotation说明后置条件使用@throwsannotation说明出现异常的时候会发生什么在方法声明中使用static等关键字声明，可据此进行静态类型检查当客户端满足前置条件的时候，结果必须满足后置条件；当前置条件不满足的时候，方法内部可以做任何事情，但作为开发者，应该尽量让程序做到failfast。 spec不能有什么？ spec不能暴露实现细节，不应该暴露局部变量，也不应该暴露私有的数据域，这些东西一旦暴露，就有可能给被非法的程序员利用，发现漏洞并实施攻击。 注意：方法不应该改变输入参数的取值，如果改了，则必须在spec中做出说明。所以不推荐使用mutable的对象。另外，我们无法强迫类的实现体和客户端不保存可变变量的“别名”，因此，如果直接返回本来的mutable对象，客户端可能修改它的值造成内部实现的错误，同样，如果返回了的是原来mutable对象的拷贝，虽然内部不用再担心客户端的更改影响到自己，但客户端无法知道内部是否保留了被返回的拷贝的别名，因此双方无法完全的信任彼此，故而不推荐使用mutable类作为返回值类型。 spec的评判标准评判哪个规约更好的三个方面：规约的确定性、规约的陈述性、规约的强度 重点是规约的强度的判断，spec变强的要求是更宽松的前置条件+更严格的后置条件，在这种情况下，就可以用变强了的spec去替换原来的spec。越强的规约，意味着实现者的自由度和责任越重，而客户的责任越轻。 强的spec可以替换弱的spec，这一点会在第4章的LSP中得到应用 用椭圆表示spec的强度 如下图，大椭圆表示更弱的spec，小椭圆表示更强的spec，椭圆的大小表示的是开发者的自由度，小椭圆有更强的后置和更弱的前置，因此所包含的结果的点就少，所以就小。 ADT ADT的操作Creators构造器：用于使用new关键字创建一个新的对象。还有一种方法是静态方法，如Arrays.asList()、String.valueOf(ObjectObj)等。 Producers生产器：用于使用一个存在的对象产生一个新的对象，例如String.concat()就是使用已存在的字符串构造出一个新的对象，而且不会改动原先存在的对象。 Observers观察器：不对数据做任何改动，只是查看一个已经存在的对象的各个值，如List.size()、所有的getter方法等。 Mutators变值器：用于改变对象属性的方法，如List.add()。mutator通常返回void，因为它不需要对外界做出反应，只是对ADT的数据域做了更改；mutator也可能返回非空，比如返回boolean表示修改成败等。 设计ADT设计一个好的ADT需要靠开发者的经验来设计它的操作的spec，设计一个ADT要遵循下面三个原则：（1）设计简洁一致的操作（2）要足以支持client所需要的对数据的所有操作，且用操作的难度要低（3）要么抽象要么具体，不要混合 要么针对抽象设计，要么针对具体应用的设计。 实现一个ADT的三个部分：specification、representation、implementation RepresentationIndependence表示独立性client不应该知道内部的数据域是怎么实现的，最好client只能通过ADT提供的getter方法获得ADT存储的数据。 client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。其目的一个是为了便于未来的升级和维护，当内部发生变化的时候不会影响到client。 测试ADT因为测试相当于client使用ADT，所以它也不能直接访问ADT内部的数据域，所以只能调用其他方法去测试被测试的方法。 针对creator：构造对象之后，用observer去观察是否正确 针对observer：用其他三类方法构造对象，然后调用被测observer，判断观察结果是否正确 针对producer：produce新对象之后，用observer判断结果是否正确 RepInvariant(RI)andAbstractionFunction(AF)Invariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件 两个空间R和A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。 AbstractionFunction：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。 RepInvariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。 相同的R空间有肯能会有不同的RI。 即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。 checkRep()：用于随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。 表示泄露：client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。 DocumentingtheAF,RI,andSafetyfromRepExposure在代码中用注释的形式记录AF（如何解释每个R值）和RI（rep中哪些数据是有效的）。 
第441篇文章[]
软件构造复习笔记8 可维护性 可维护性的指标软件维护的类型：纠错性维护(25%)、适应性维护(21%)、完善性维护(50%)、预防性维护(4%) 可维护性(Maintainability)、可扩展性(Extensibility)、灵活性(Flexibility)、可适应性(Adaptability)、可管理性(Manageability)、支持性(Supportability)这些指的都是可维护性。 评判可维护性的一些方面： 设计结构足够简单；模块之间松散耦合；模块内部高度聚合；不要使用了非常深的继承树，尽量使用delegation替代继承；代码的圈复杂度不能太高；不存在重复代码2.模块化设计原则目的：高内聚低耦合；分离关注点(通过delegation等机制分离功能)；信息隐藏(避免表示泄露、静态工厂方法等等) 评估模块化的五个标准： 可分解性(Decomposability)：让复杂的功能分解成一个个ADT完成可组合性(Composability)：让一个个ADT组合完成复杂的功能可理解性(Understandability)：OOP是面向世界上存在的事物编程，所以容易被理解可持续性(Continuity)：发生变化时使得受影响范围最小出现异常之后的保护(Protection)：出现异常后使得受影响范围最小模块化设计的五个原则： DirectMapping(直接映射)FewInterfaces(尽可能少的接口)SmallInterfaces(尽可能小的接口)ExplicitInterfaces(显式接口)InformationHiding(信息隐藏)高内聚低耦合 高内聚：模块内部的功能之间的联系要紧密，无关的功能之间要分离成不同的模块 低耦合：模块之间的关系要越松散越好 SOLID设计原则SOLID原则： (SRP)TheSingleResponsibilityPrinciple---------单一责任原则(OCP)TheOpen-ClosedPrinciple-------------------开放-封闭原则(LSP)TheLiskovSubstitutionPrincipleLiskov----替换原则(DIP)TheDependencyInversionPrinciple--------依赖转置原则(ISP)TheInterfaceSegregationPrinciple----------接口隔离原则单一责任原则(SRP)一个类，一个责任 尽可能地将功能分割，以达到不应该有多于一个原因让你的ADT发生变化的目的，否则就要拆分开。如果多个责任（功能）放在一个类中就有可能在未来某一个功能发生变化的时候影响到整个类，从而影响到整个程序的很大一部分实现（需要全部重新编译打包部署）。 开放-封闭原则(OCP)对扩展性的开放，对修改的封闭 在未来对功能进行修改或者扩展的时候，要遵循尽量不去改动已有的代码而是扩展出新的类然后调用新的类的原则。 典型的违反OCP的例子是大量的使用if-else/switch-case语句，这给维护造成了极大的麻烦。所以应对的方法是让客户端传入接口的不同子类型，而在ADT中只需要统一的调用接口中共有的方法即可。 替换原则(LSP)子类型必须能够替换其基类型 代价是失去了子类型扩展出的功能。 依赖转置原则(DIP)具体的模块应该依赖于抽象的模块，但抽象的模块不应依赖于具体的模块 使用接口隔离应用层和实现层，client面向接口编程。 接口隔离原则(ISP)大接口分解为多个小的接口 客户端不应依赖于它们不需要的方法，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的接口面向可维护性的编程 FactoryMethod工厂方法解决的问题：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。 定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 当然也可以通过直接定义静态工厂方法来创建子类实例。 AbstractFactory抽象工厂解决的问题：当client需要的是多个具有固定搭配的类的组合，如A和B两个系列的类，A1搭配B1，A2搭配B2，于是，就要用抽象工厂对其做一次封装。 定义一个用于创建对象的接口，让其子类来决定实例化哪一组类，从而使类与类之间的搭配对于client来说固定了。 本质上，AbstractFactory是把多类产品的factorymethod组合在一起 Proxy代理模式解决的问题：某个对象比较“敏感”/“私密”/“贵重”，不希望被client直接访问到，故设置proxy，在二者之间建立防火墙。 创建一个代理类，它接受client的功能请求，然后把功能请求转发(delegate)给实现类，类似于Adapter模式。4.Observer观察者模式解决的问题：“粉丝”对“偶像”感兴趣，希望随时得知偶像的一举一动。 粉丝到偶像那里注册，偶像一旦有新闻发生，就推送给已注册的粉丝（回调callback粉丝的特定功能）。这是一个双向delegate的关系，5.Visitor解决的问题：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。 为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT 
第442篇文章[]
软件构造复习笔记3 1.软件开发生命周期 1.从无到有；从有到好2.传统软件过程模型：基本类型有线性过程(Linear)和迭代过程(Iterative)，目前存在的模型有瀑布过程(waterfall)，增量过程(incremental)，V字模型(V-model)，原型过程(prototyping)，螺旋模型(spiral)。 3.敏捷开发：Agile=增量+迭代 将任务划分成一个个小规模的任务，因此较小的团队也能够适应大规模软件的开发。在每个小步骤的迭代中，用户可以参与开发，软件可以随时修正，质量因此得到了保证。因此，敏捷开发是一次次小迭代，将任务细分成一个个小任务，在每个小任务上完成迭代。 4.极限编程：关注于测试驱动的开发(TDD)，自动化构建、持续集成、持续交付。（迭代：开发出来之后由用户试用/评审，发现问题反馈给开发者，开发者修改原有的实现，继续交给用户评审。循环往复这个过程，直到用户满意为止。时间代价高，但开发质量也高。） 2.软件配置管理(SCM)和版本控制系统(VCS) 软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被成为软件配置项(SCI)。 当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。 为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。 VCS：本地版本控制系统（无法协作）存储在本地、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。 （基线：软件持续变化过程中的“稳定时刻”）版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识” 3.git 创建：gitinit 暂存：gitadd 提交：gitcommit-m“commitmessage” 链接：gitremoteaddorigin 推送：gitpush-uoriginmaster 创建分支：gitcheckout-b 切换分支：gitcheckout 合并分支：gitmerge 删除分支：gitbranch-d git中的四个区域：workspace、stagingarea、Localrepository、Remoterepository git的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。 git单个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。 传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。 关于分支的合并：对于合并操作来说，如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的指针移到做过更改分支的指针的位置。 通常软件构造过程(1)Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。 (2)Codereview、Staticcodeanalysis：可以使用工具来发现bug，如CheckStyle,SpotBugs。 (3)Testing：测试，单元测试、集成测试、系统测试… (4)Debugging：调试 (5)Dynamiccodeanalysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分 (6)Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化 (7)Build：第2部分 狭义的软件构造过程(Build)这是一个借助于工具，将软件构造过程中大的各阶段的活动自动化的过程，尽可能地脱离人工，以提高构造效率。 常用的工具：Jenkins、Make、Ant、Maven、Gradle 利用工具完成项目的自动化构建、测试、打包release等功能，完成buildtime–>runtime。 
第443篇文章[]
软件测试复习笔记 软件测试与测试优先的编程 对软件测试进行复习。即使是最好的测试也无法达到百分之百的无错。好的测试：能发现错误。不冗余；最佳特性；别太复杂也别太简单。Testinglevels：单元测试（函数级别）；集成测试（包，类，等等）；系统测试（最终测试）。静态测试；静态测试通常是隐含的，作为校对，加上当编程工具/文本编辑器检查源代码结构或编译器(预编译程序)检查语法和数据流作为静态程序分析。（没有实际运行）动态测试：动态测试描述了对代码的动态行为的测试，它实际上是用给定的一组测试用例来执行编程代码。-动态测试可以在程序100%完成之前开始，以便测试特定部分的代码，并应用于离散的函数或模块。-这方面的典型技术是使用存根/驱动程序或从调试器环境执行。先测试，在调试。白盒测试：对程序内代码结构的测试黑盒测试黑盒测试##对程序外部行为进行的测试。想要进行好的测试，就要抱着想要另其出错的态度。 测试用例 测试用例：输入+执行条件+期望结果测试用例是为特定目标而开发的，例如执行特定的程序路径或验证对特定需求的遵从性。测试用例可能只是您对程序提出的一个问题。运行测试的目的是获取信息，例如，程序是否通过测试。测试用例是质量保证的基石，而测试用例是为了验证产品的质量和行为而开发的。 测试优先的编程 先写spec（规约）再写符合spec的测试用例测试，修改，通过。先写测试更为方便。 单元测试 针对软件的最小单元模型进行测试 Junit测试 junit是一个单元测试框架。junit单元检测仪@test为注释利用断言等方法进行检测，1.assertEquals测试两个对象是否相等，该断言不能用于数组的比较，数组的比较用assertArrayEquals2.assertArrayEquals测试两个数组是否相等3.assertTrue，assertFalseassertTrue和assertFalse用于测试boolean变量的值为true还是false4.assertNull，assertNotNullassertNull和assertNotNull用于测试变量的值是否为null5.assertSame，assertNotSameassertSame和assertNotSame用于测试两个对象的引用是否相同6.assertThatassertSame和assertNotSame用于测试两个对象的引用是否相同 黑盒测试 检查程序是否符合规约 通过分区选择测试用例 基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。针对每个输入数据需要满足的约束条件，划分等价类 代码覆盖度 代码覆盖度：已有的测试用例有多大程度覆盖了被测程序码覆盖度越低，测试越不充分但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高 
第444篇文章[]
软件构造复习笔记7 复用 面向复用编程面向复用编程(programmingforreuse)：开发可以复用的软件 基于复用编程(programmingwithreuse)：复用已有的软件开发 为了降低成本和开发时间，提出了面向复用的编程，所有面向复用的代码都应该经过充分的测试，以保证它的可靠性和稳定性（不能在未来使用的时候发现一堆bug，那就白干了），而因为它是面向复用的，所以在不同的应用里可以保持一致的表现，也就是说对此功能做了标准化。 可复用性的评估 评估的方面：复用的频繁性、复用的代价(适配) 一个有高可复用性的代码应该有如下特点：小、简单；与标准兼容；灵活可变；可扩展；泛型、参数化；模块化；变化的局部性；稳定；丰富的文档和帮助。 复用的层面最主要的复用是在代码层面，这也是我们所关注的，但软件构造过程中的任何实体都可能被复用（需求、spec、数据、测试用例、文档等等） 源代码层面：方法、语句… 模块层面：ADT(类和接口) 库层面：API，如.jar文件 架构层面：框架 复用分为白盒复用和黑盒复用，白盒复用意味着源码是可见的，对我们来说意义不是很大，更多的是源码不可见的黑盒复用，只有这样才能隔离客户端和ADT的内部实现。 源代码层面的复用可以在网络上寻找自己需要的代码，但要注意开发商用的软件不能直接复制开源的代码，避免引起法律纠纷。 模块层面的复用通过继承(Inheritance)的方式复用父类的代码，同时也可override父类中已存在的方法。另一个复用的方法是委托(delegation)，详见下一小节(4.2)。库层面的复用通过导入库来调用库中的API完成复用。 除了导入本地库，也可以通过导入部署在网络上的库来完成复用，如WebServices/RestfulAPIs 架构层面的复用框架：一组具体类、抽象类、及其之间的连接关系。开发者可以根据spec填充自己的代码从而形成完整的系统。开发者根据Framework预留的接口所写的程序，而Framework作为主程序加以执行，执行过程中调用开发者所写的程序。关于框架详见下一小节4.2.3。 黑盒框架：通过实现特定接口/delegation进行框架扩展白盒框架：通过代码层面的继承进行框架扩展Liskov替换原则(LSP)子类型多态子类型多态：客户端可用统一的方式处理不同类型的对象。例子类对象取代父类对象而不会产生任何问题。 LSPLiskovSubstitutionPrinciple中子类重写父类的方法应该满足的条件： 编译器在静态类型检查时强制满足的条件 子类型可以增加方法，但不可删除子类型需要实现抽象类型中的所有未实现方法子类型中重写的方法返回值必须与父类相同或符合co-variance(协变)子类型中重写的方法必须使用同样类型的参数或者符合contra-variance(逆变)的参数子类型中重写的方法不能抛出额外的异常还应该满足的条件 更强的不变量(RI)更弱的前置条件更强的后置条件协变关于返回值的类型，应该保持不变或者变得更具体，也就是与派生的方向一致。 所抛出的异常的类型也是如此。 classT{Objecta(){…}voidb()throwsThrowable{…}}classSextendsT{@Override//返回值从Object协变成了String，这是符合重写的语法的Stringa(){…}@Override//抛出的异常从Throwable协变成了IOException，这也是符合重写的语法的voidb()throwsIOException{…}} 逆变关于参数的类型，应该保持不变或者变得更抽象，也就是与派生的方向相反。 classT{voidc(Strings){…}}classSextendsT{@Override//虽然按照LSP这是合法的，但是在java语法中，不当作override，而是overloadvoidc(Objects){…}} 类型擦除(泛型中的LSP)泛型类型是不支持协变的，如ArrayList是List的子类型，但List不是List的子类型。这是因为发生了类型擦除，运行时就不存在泛型了，所有的泛型都被替换为具体的类型。 但是在实际使用的过程中是存在能够处理不同的类型的泛型的需求的，如定义一个方法参数是List类型的，但是要适应不同的类型的E，于是可使用通配符?来解决这个需求。组合与委托委派/委托：一个对象请求另一个对象的功能。 一个使用Comparator接口实现delegation的例子： publicclassEdge{Vertexs,t;doubleweight;…}publicclassEdgeComparatorimplementsComparator{@Overridepublicintcompare(Edgeo1,Edgeo2){if(…>…)return1;elseif(…<…)return-1;elsereturn0;}}publicvoidsort(Listedges){Comparatorcomp=newEdgeComparator();Collections.sort(edges,comp);//把比较的功能分离出来单独委派给了一个类} 实现比较功能还有另一种方式，让ADT实现Comparable接口然后override该接口的comparaTo()方法，但是这种方法就不再是delegation了。 选择继承还是委派？ 如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，也就是说一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。 委托发生在object层面(朋友关系)，而继承发生在class层面(父子关系) 四种委派方式Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。 //如果要让鸭子用其他方式叫(或飞)只需更换new的q(f)的类型即可Flyablef=newFlyWithWings();//使用翅膀飞行的飞行方式Quackableq=newQuack();//鸭叫声的叫声Duckd=newDuck();//一只鸭子d.fly(f);//让鸭子飞d.quack(q);//让鸭子叫 classDuck{//nofieldtokeepFlyableobjectpublicvoidfly(Flyablef){f.fly();}//让这个鸭子以f的方式飞publicvoidquack(Quackableq){q.quack()};//让鸭子以q的方式叫} Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。 //法一：在构造方法中传入参数绑定Flyablef=newFlyWithWings();Duckd=newDuck(f);d.fly();classDuck{Flyablef;//这个必须由构造方法传入参数绑定publicDuck(Flyablef){this.f=f;}publicvoidfly(){f.fly();}}//法二：在rep或构造方法中直接写死Duckd=newDuck();d.fly();classDuck{//这两种实现方式的效果是相同的Flyablef=newFlyWithWings();//写死在rep中publicDuck(){f=newFlyWithWings();}//写死在构造方法中publicvoidfly(){f.fly();}}Composition:更强的association，但难以变化。也就是Association中的法二。 Aggregation:更弱的association，可动态变化。也就是Association中的法一。 上面所说的都是一对一的delegation，也存在一对多的delegation，只需要在rep中保存所有被委派的对象即可。 组合CompositeReusePrinciple(CRP)利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。组合就是多个不同方面的delegation的结合。 接口的具体子类型又可以通过静态工厂方法隐藏。 抽象层是不会轻易发生变化的，会发生变化的只有底层的具体的子类型，而具体功能的变化（实现不同的功能）也是在最底层，所以抽象层是稳定的。而在具体层，两个子类之间的委派关系就有可能是稳定的也有可能是动态的，这取决于需求和设计者的设计决策。 上图中所存在的子类与父类的替换只有在满足LSP的前提下才能存在，不满足LSP就没有这种delegation机制了。六种设计模式：Adapter、Decorator、Facade、Strategy、Templatemethod、Iterator Adapter适配器模式目的是将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。 因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。 Decorator装饰器模式你即将开始无限套娃之旅 每个子类实现不同的特性，因为这些特性都是多个维度上的个性化的特征，没办法做到在一个顶层的接口中完成所有特征的抽象，而且需要做到在各个维度上的特性的任意组合，此时光靠继承是没办法实现特性的组合的，如果要强行使用继承实现，那么面对的一个不可避免地问题是组合爆炸，因为每次继承只能扩展一个特性，多个特性就要多次继承实现，并且也不便于维护与扩展，而且会有大量的重复代码。 因此，提出了Decorator设计模式，为对象增加不同侧面的不同特性。 装饰器模式的原理是从接口派生出子类，然后在子类中定义一个父类接口然后将其作为delegation的对象，也就是说：自己到自己的委派。这里第一个自己指的是子类型本身，第二个自己是指该接口的其他子类，由于他们两个是同一个接口的子类，所以可以称为自己到自己的委派。 下图中，Component是一个接口，接口中是公共的特性，ConcreteComponent是这个接口的基本实现，没有任何个性。Decorator是接口的一个抽象实现，它解决了委派关系的建立问题，从它派生出的诸多子类可以实现各个单独的特性而不必考虑所需要的其他特性如何在本类中实现，这些问题都通过delegation机制交给了其他子类完成。 如果你没看懂，不要担心，看看下面的例子吧 一个使用装饰器模式设计的例子 //Stack接口，定义了所有的Stack共性的基础的功能interfaceStack{voidpush(Iteme);Itempop();}//最基础的类，啥个性也没有的Stack，只有共性的实现publicclassArrayStackimplementsStack{…//reppublicArrayStack(){…}publicvoidpush(Iteme){…}publicItempop(){…}}//装饰器类，可以是一个抽象类，用于扩展出有各个特性方面的各个子类publicabstractclassStackDecoratorimplementsStack{protectedfinalStackstack;//用来保存delegation关系的reppublicStackDecorator(Stackstack){this.stack=stack;//建立稳定的delegation关系}publicvoidpush(Iteme){stack.push(e);//通过delegation完成任务}publicItempop(){returnstack.pop();//通过delegation完成任务}}//一个有撤销特性功能的子类publicclassUndoStackextendsStackDecoratorimplementsStack{privatefinalUndoLoglog=newUndoLog();publicUndoStack(Stackstack){super(stack);//调用父类的构造方法建立delegation关系}publicvoidpush(Iteme){log.append(UndoLog.PUSH,e);//实现个性化的功能super.push(e);//共性的功能通过调用父类的实现来完成}publicvoidundo(){//implementdecoratorbehaviorsonstack}…} 使用装饰类，通过一层一层的装饰，让得到的对象最终能够拥有任意不同特性的组合，这才是decorator模式最精妙的地方。而且装饰的顺序是不会影响到对象的最终结果拥有哪些特性的，影响到的唯一地方在于最终得到的是哪个类型的对象，也就是最后一次装饰的特性决定了最终得到哪个具体类型的对象。 简直神来之笔 //先创建出一个基础类对象Stacks=newArrayStack();//利用UndoStack中继承到的自己到自己的委派建立起从UndoStack到ArrayStack的delegation关系//这样，UndoStack也就能够实现最基础的功能，并且自身也实现了个性化的功能Stackus=newUndoStack(s);//通过一层层的装饰实现各个维度的不同功能Stackss=newSecureStack(newSynchronizedStack(us)); JDK中装饰器模式的应用：staticListunmodifiableList(Listlist)、staticSetsynchronizedSet(Setset); Facade外观模式客户端在调用的API时候会以固定的方式调用一系列的方法，而为了简化客户端的使用，便于客户端的学习使用、解耦，所以需要提供一个统一的接口来取代一系列小接口调用，对复杂系统做了一个封装。 经过封装得到的一个方法通常是静态方法，因为客户端可以直接调用这个方法而没必要new一个对象。 Strategy策略模式有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。 ConcreatestrategyA和ConcreateStrategyB是Strategy接口的两种不同的实现，客户端在运行时可选择任意一种来完成功能。在方法中只需要留出一个Strategy接口类型的参数，客户端选择具体类型后传入即可。 TemplateMethod模板模式做事情的步骤一样，但具体方法不同，因此共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。 在模板中，实现了一个固定执行一系列操作的方法，这个方法使用final关键字做了限定，不能再被子类重写，因此，子类只能通过重写该方法调用的那些尚未实现的方法。 在上一节中提到的白盒框架就是用这种技术实现的 Iterator迭代器模式客户端希望遍历被放入容器/集合类的一组ADT对象，而无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式 实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。 一个迭代器的实例： publicclassPairimplementsIterable{privatefinalEfirst,second;publicPair(Ef,Es){first=f;second=s;}publicIteratoriterator(){returnnewPairIterator();}privateclassPairIteratorimplementsIterator{privatebooleanseenFirst=false,seenSecond=false;publicbooleanhasNext(){return!seenSecond;}publicEnext(){if(!seenFirst){seenFirst=true;returnfirst;}if(!seenSecond){seenSecond=true;returnsecond;}thrownewNoSuchElementException();}publicvoidremove(){thrownewUnsupportedOperationException();}}//使用隐式方法迭代publicstaticvoidmain(String[]args){Pairpair=newPair(“foo”,“bar”);for(Strings:pair){…}}} 
第445篇文章[]
软件构造复习笔记5 OOP set.contains(list);//false!//甚至还有如下神奇的事情for(Listl:set)set.contains(l);//false小心：如果某个mutable的对象包含在Set集合类中，当其发生改变后，集合类的行为不确定。 在JDK中，不同的mutable类使用不同的等价性标准： Date.equals()、List.equals()实现的是观察等价性。 StringBuilder.equals()实现的是行为等价性，它的equals()方法实际上是直接继承自Object类。 equals()和hashCode()所以，对可变类型，实现行为等价性即可，也就是说，只有指向同样内存空间的对象才是相等的。所以对可变类型来说，无需重写这两个函数，直接继承Object的equals()和hashCode()即可。 自动封装手动封装的结果： Integerx=newInteger(3);Integery=newInteger(3);x.equals(y);//truex==y;//false(int)x==(int)y;//true 自动封装的结果： Map<String,Integer>a=newHashMap<>(),b=newHashMap<>();a.put(“c”,130);//被自动转换成了Integerb.put(“c”,130);a.get(“c”)==b.get(“c”);//false，get获得的是Integer，并不会自动转换成原始的inta.get(“c”).equals(b.get(“c”));//true 特殊情况： Map<String,Integer>a=newHashMap<>(),b=newHashMap<>();a.put(“c”,1);b.put(“c”,1);a.get(“a”)==b.get(“a”);//true 原因：JVM为-128~127分配的空间位于常量池中，所以即使被自动封装成了对象类型也可以用==判断相等。 Integerx=2;Integery=2;x==y;//true/*仅限于上面的方式创建的对象，通过new创建的对象不行*/Integerx=newInteger(2);Integery=newInteger(2); 
第446篇文章[]
Java中的List类的contains和indexOf方法的区别 问题： 在对List类的使用中，有一次使用到了contains和indexOf方法，而出现预期以外的错误，考虑到List中的元素都为引用类型，因此想知道List的contains和indexOf方法的结果是否与引用对象相关。 代码实例如下： importjava.util.ArrayList; importjava.util.List; publicclassTemp { publicstaticvoidmain(String[]args)throwsException { List<String>list=newArrayList<String>(); for(inti=0;i<10;i++){ list.add(String.valueOf(i)); } //使用contains System.out.println(list.contains("5")); //使用indexOf System.out.println(list.indexOf("5")); System.out.println(list.indexOf(newString("5"))); List<People>peoples=newArrayList<People>(); Peoplea=newPeople("a"); Peopleb=newPeople("b"); Peoplenewa=newPeople("a"); peoples.add(a); peoples.add(b); //使用contains System.out.println(peoples.contains(newa)); //使用indexOf System.out.println(peoples.indexOf(newa)); } } classPeople{ privateStringname; /** *@paramname */ publicPeople(Stringname){ this.name=name; } @Override publicinthashCode(){ finalintprime=31; intresult=1; result=prime*result+((name==null)?0:name.hashCode()); returnresult; } @Override publicbooleanequals(Objectobj){ if(this==obj) returntrue; if(obj==null) returnfalse; if(getClass()!=obj.getClass()) returnfalse; Peopleother=(People)obj; if(name==null){ if(other.name!=null) returnfalse; }elseif(!name.equals(other.name)) returnfalse; returntrue; } /** *@returnthename */ publicStringgetName(){ returnname; } } 运行结果如下： 由此可见，如果List的泛型重写了equals方法，则contains和indexOf方法都可以正常工作，而不需要要求参数为List中的同一个引用对象，只需要值相同即可。 而将equals去掉之后，其他代码不变，发现结果如下： 发现contains和indexOf方法都判定newa这个对象不在peoples这个List中。 如果再将此行改为： //使用contains System.out.println(peoples.contains(a)); //使用indexOf System.out.println(peoples.indexOf(a)); 运行结果如下： 结果再一次正确。 总结： contains和indexOf方法是一致的。如果希望值相同就可以在List中找到，则需要重写List<L>的L中的equals方法。如果希望引用相同，则不可以重写L中的equals方法。 
第447篇文章[1]
hello的一生 摘要 本文通过对一个简单的hello程序的创建、运行、到终止的跟踪，阐述了预处理、编译、汇编、链接、进程管理、存储管理、IO管理等的原理以及和hello程序结合的内容。 关键词：汇编；链接；进程管理；hello程序的一生； 目录 摘要 第一章概述 1.1hello简介 1.2环境与工具 1.2.1硬件环境 1.2.2软件环境 1.2.3开发与调试工具 1.3中间结果 1.4本章小结 第2章预处理 2.1 预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 重定位算法如下： 以对hello.o中的puts分析为例： 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第一章概述 1.1hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 Hello的P2P：首先，在hello.c中编写程序，此时program形成。在linux下，hello.c经过cpp的预处理变为hello.i、经过ccl的编译变为hello.s、经过as的汇编变为hello.o、经过ld的链接变为可执行程序hello。在shell中，输入执行hello的指令之后，shell调用fork函数创建一个子进程，再在子进程中调execve函数，将hello加载到这个子进程中，覆盖掉原子进程，即hello变为了一个进程（process），完成P2P。 Hello的020：在hello成为进程之后，操作系统为该进程划分时间片，让它不断与其他进程上下文切换，并发执行。Hello的执行中，不断从内存中取指令，此时用到了MMU将虚拟内存转换为物理内存，再利用了快表、4级页表、3级cache等来进行加速从内存中取出数据。在Hello的执行中，还可能接收并处理来自键盘等IO设备的信号，还可能产生缺页等异常，还会经过上下文切换进入异常处理程序。在hello执行完毕之后，由其父进程shell来对其进行回收，从此hello进程不复存在，完成020。 1.2环境与工具 1.2.1硬件环境 Intel64CUP；2.6GHZ；RAM16G；256GDisk 1.2.2软件环境 Windows10 64位；Vmware15；Ubuntu18.0464位 1.2.3开发与调试工具 Linux下：gcc，vim，edb，gdb，readelf Windows下：HexEdit 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 文件名作用hello.chello程序的源代码（文本文件）hello.ihello.c预处理处理得到的文件（文本文件）hello.shello.i编译后得到的汇编代码（文本文件）hello.ohello.s汇编后得到的可重定位目标文件（二进制文件）helloHello.o与其他文件链接后得到的可执行文件（二进制文件） 1.4本章小结 本章对hello程序进行了一个P2P、020的简介，列出了编写本论文用到的软硬件环境、工具、中间产物及其作用等。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 预处理概念：在编译之前对源文件提前进行的内存处理。预处理过程扫描源代码，对其进行初步转换，产生新的源代码提供给编译器，可见预处理过程先于编译器对源代码进行处理。预处理格式为：#+指令关键字。 作用：1.预处理过程读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行相应的转换。2.预处理过程还会删除程序中的注释和多余的空白字符。3.预处理还会将源程序引用的所有库导入并且合并成为一个完整的文本文件。 2.2在Ubuntu下预处理的命令 命令：gcchello.c-E-ohello.i 图2.2 2.3Hello的预处理结果解析 图2.3 Hello.i仍然为文本文件。由hello.i与hello.c的对比可以看出，在hello.c的基础上，预处理对其添加了许多内容，其中大量使用了typedef语句，extern关键字以及结构体。hello.c文件的头文件被拷贝进了hello.i文件，而宏定义也被逐一替换。 2.4本章小结 本章对.c文件的预处理进行了介绍，了解了.c文件是如何经过处理头文件，宏替换等一系列操作而被预处理的，阅读了.i文件，了解了其与.c文件的区别。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译阶段是检查语法，生成汇编的过程。就是把代码转化为汇编指令的过程，汇编指令只是CPU相关的。 作用：将.i文件翻译成汇编文件.s。编译过程还具备语法检查、方便调试、加上特定参数还可以使目标程序不同程度的优化、使不同逻辑的高级语言产生相同的汇编语言，便于后续将其一一对应翻译为机器码，而不受高级语言限制。 3.2在Ubuntu下编译的命令 命令：gcc-Shello.i-ohello.s 图3.2 3.3Hello的编译结果解析 3.3.0汇编文件头 开头如下： 图3.3.0 .file：源文件名（.c文件）.text：代码段.globl：全局变量.data：数据段.align：对齐方式，按4字节对齐 .type：指定其为对象类型或者函数类型.size：大小.long：长整型 其值为2 .section.rodata：以西是.rodata节.string：字符串常量 3.3.1数据 常量 在.c程序中出现的常量，在汇编中都以立即数的形式出现：比如: 在汇编中为： 即3表示为$3。 变量 全局变量： 其在汇编中表示为: 可知，全局变量保存在.rodata节中。其值为2（由于2.5强转而来），为对象类型，占据4个字节。 局部变量： 在汇编中表示为： 说明i存放在栈中，地址为%rbp-0x4. main函数的两个参数: 在汇编中体现如下： 说明argc变量存储在%edi中，并且转存在%rbp-0x20中 说明argv变量存储在%rdi中，并且转存在%rbp-0x32中 类型 虽然sleepsecs全局变量在程序中被定义为int类型，但是在汇编中被定义为long类型。 3.3.2赋值 在c语言中的变量的赋值语句在汇编中均使用mov语句来实现 将i赋值为0. 将sleepsecs赋值为2 局部变量保存在栈中，初始化的全局变量保存在.data中 3.3.3类型转换 由此可以看出，c程序对sleepsecs进行了强制类型转换，将float强行转换为int类型，但是实际上汇编把他当作long类型。强制类型转换满足取整数部分的原则 3.3.4算数操作 即为自增运算，其在汇编中实现如下： 3.3.5关系操作 ，在汇编中实现如下： ，在汇编中实现如下： ，采取的和9比较，跳转条件为小于等于，与i<10意义相同。 3.3.6数组操作 在调用printf时，将使用了argv[1],argv[2]来作为printf的参数，在汇编中实现如下： ，其使用了加载有效地址指令leaq来计算LC1的所在段的段地址，为%rip+.LC1并将所计算的地址传递给%rdi作为printf的参数 3.3.7控制转移 ，其汇编实现如下： 先使用cmp指令来比较，再利用设置的条件码来进行条件跳转 ，其汇编实现如下： 与if类似，只不过跳转到的位置为for循环内部的起始代码位置 3.3.8函数操作 参数传递：argc和argv，分别保存在%edi和%rsi。函数调用：系统自动启动。函数返回：将%eax设置为0并且返回，对应于return0 参数传递：单参数的printf函数被汇编为puts，调用时只传入了字符串参数首地址； 而for循环中多参数的printf函数被汇编为printf，调用时传入了argv[1]和argc[2]的地址。 函数调用：if语句成立时调用，for循环中调用 对应的汇编为： 参数传递：传入的参数为立即数$1，执行退出命令函数调用：if语句成立时调用 对应的汇编为： 参数传递：传入参数sleepsecs函数调用：for循环中调用 对应的汇编为： 参数传递：无参数函数调用：在main中被调用 3.4本章小结 本章对.i文件进一步被生成的.s文件进行了了解和解释，分别从8个方面对汇编文件进行了对应解释，更加熟悉了c语言与汇编语言的对应关系，更加熟练了解了汇编语言，更加了解了高级语言对应的汇编层面的实现。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：编译后的文件到生成机器语言二进制程序的过程，机器码可以被CPU直接执行。 作用：可以将汇编语言一一对应翻译为计算机可以识别的机器码，它将汇编语言变为成可重定位目标程序的格式保存，即.o文件，还可以利用汇编产生的.o文件反汇编来调试代码。 4.2在Ubuntu下汇编的命令 命令：gcchello.s-c-ohello.o 图4.2 4.3可重定位目标elf格式 首先输入 readelf-hhello.o查看hello.o的ELF头的信息 图4.3.1hello.o的ELF头的信息 由图4.3.1头信息可得知ELF文件的基本信息，如：该.o文件为可重定位文件；ELF头的大小为64字节，程序头有0个，节头有13个 等等。 输入readelf-Shello.o查看hello.o的节头信息 图4.3.2hello.o的节头信息 再输入readelf-shello.o查看符号表 图4.3.3符号表 再输入readelf-rhello.o查看重定位信息 图4.3.4重定位信息 分析可知，再.rela.text中有8个项目需要重定位，包含1个变量、2个段以及5个函数，.rela.eh_frame有1个项目需要重定位，包含1个段。 输入readelf-ahello.o查看ELF所有信息 图4.3.5 ELF所有信息 由以上可知ELF格式文件由ELF头、节头、符号表、重定位信息等组成。 4.4Hello.o的结果解析 输入objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 输入objdump-d-rhello.o后输出如下： 图4.4.1hello.o的反汇编 而之前的.s文件如下： 图4.4.2hello.s 对比分析可知： 机器语言与汇编语言位一一对应。 区别如下： .s文件中objdump中分支转移类似于.L4的跳转目录指令的地址，如jmp6f函数调用使用函数名称使用函数地址进制使用十进制使用16进制全局变量使用sleepsecs(%rip)访问使用0x0(%rip)访问 4.5本章小结 通过对本章的完成，我深入了解了.o文件，更加熟练地使用了readelf指令查看ELF格式文件，之后还对之前生成的.s文件与objdump反汇编生成的文件进行了对比，明白了两者之间的细微区别。还了解了机器语言与汇编语言的对应关系。 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：分为静态链接和动态链接。静态链接是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息。编译时，加载时，运行时都可以链接。 作用：把多个可重定位文件合并在一起，找到这些文件之间的关系，生成一个大的、有绝对位置的目标程序，使得机器可以执行。 5.2在Ubuntu下链接的命令 使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.2 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 使用readelf-ahello命令得到如下信息： 图5.3.1ELF头信息 与hello.o不同为：类型为可执行文件，且程序头大小为56字节，有8个程序头，而段头数量也增加为25。 图5.3.2段头信息 对25个段头的信息进行了一一列出，还包含了整体信息，比如名称，类型，载入虚拟地址的起始地址，在程序中偏移量，对齐信息等等。 图5.3.3程序头信息 图5.3.4重定位节信息 图5.3.5符号表信息 等等一系列的信息，具体可以使用readelf-ahello来查看。与上一章的分析基本一致。 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 使用edb加载hello之后得到如下结果： 图5.4.1 hello程序的虚拟地址从0x400000开始，到0x400ff0结束。 而根据刚刚通过readelf工具查看的ELF格式文件中的节头表可以知道各个段的信息。 比如： 图5.4.2 根据.rodata的地址为0x400640可以查看其内容： 图5.4.3 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 不同之处： hello的反汇编中显示已经被重定位了，虚拟地址以已经给出，而hello.o的反汇编中的地址为相对地址，未完成重定位。 图5.5.1hello的反汇编 图5.5.2hello.o的反汇编 hello的反汇编中增加了一些函数，这些函数都在main中或者函数初始化时用到了。例如： 图5.5.3hello的反汇编 重定位的过程： (1)所有类型相同的节被连接器合并在一起后，此节就作为可执行目标文件的对应的节。之后链接器把运行时的内存地址赋给新的合成的一个“大的”节、赋给输入模块定义的每个节以及输入模块定义的每个符号，至此，程序中每条指令和全局变量都有唯一运行时的地址。 (2)在重定位节中的符号引用这一步中，连接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。链接器通过可重定位目标文件中的重定位条目的数据结构来对符号进行重定位。 (3)而重定位条目是当编译器遇到对最终位置未知的目标引用时，生成的一个数据结构。代码的重定位条目放在.rel.txt，如下： 图5.5.4.rel.txt 而其中，这些表头符号含义如下： Offset偏移量Type修改方式Name需要修改的名称Addend偏移调整 重定位算法如下： 图5.5.5重定位算法 以对hello.o中的puts分析为例： 图5.5.6 Refptr=s+r.offset=0x4004b0+1d=0x4004dd 因为r.type==R_x86_64_PLT32,则进入第一个if语句 *refptr=0x4004b0+(-0x4)-(0x40054e+1)=-0xa2=-163=ffffff5d 小端表示为5dffffff结果正确。 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 如下： 即为 即为 图5.6 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 动态链接：要解决空间浪费和更新困难这两个问题最简单的办法就是把程序的模块相互划分开来，形成独立的文件，而不再将他们静态的链接在一起。简单地讲，就是不对那些组成程序的目标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到了运行时再进行，这就是动态链接(DynamicLinking)的基本思想。 在调用共享库函数时，编译器为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。GNU编译系统使用延迟绑定,将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定是通过GOT和PLT实现的。GOT是数据段的一部分，而PLT是代码段的一部分。两表内容分别为： PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 而由hello的ELF文件可知 图5.7.1hello的ELF文件 .got段起始地址为0x600ff0， .got.plt段起始地址为0x601000,进入edb调试 在未执行dl_init之前，.got段内容为： 图5.7.2.got段 在未执行dl_init之前，.got.plt段内容为： 图5.7.3.got.plt段 发现在0x600ff0之后16字节全为0，0x601008之后的16个字节全为0 执行dl_init之后，.got段内容为： 图5.7.4.got段 执行dl_init之后，.got.plt段内容为： 图5.7.5.got.plt段 发现0x600ff0之后的8个字节发生了变化，变为：0x7f9fe61d4ab0,而0x601008之后的16个字节也发生了变化，0x601008后8个字节变为：0x7f9fe67cd170,0x601010后8个字节变为:7f9fe65bb680，说明hello已经被动态链接。 5.8本章小结 通过对本章的完成，我了解了链接的概念与作用，以及了解了可执行文件hello的格式以及ELF内容，hello的虚拟地址分析，执行流程，动态链接过程分析等等，让我更加对链接有了深入的认识。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：进程是正在运行的程序的实例。 作用：可以让程序实例有两个假象：1.一个运行的程序实例好像独占了整个cpu。2。一个运行的程序实例好像独占了整个内存。进程使得一个物理设备可以并发地执行多个程序实例。 6.2简述壳Shell-bash的作用与处理流程 作用：Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。BASH：是GNU的BourneAgainShell，是GNU操作系统上默认的shell。 处理流程：shell在内存中长时间运行。根据以下程序得知其内部程序： 图6.2 因此shell重复以下过程： (1)终端进程读取用户由键盘输入的命令行。 (2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量 (3)检查第一个命令行参数是否是一个内置的shell命令 (4)如果不是内部命令，调用fork()创建子进程 (5)在子进程中，用步骤2获取的参数，调用execve()执行指定程序 (6)shell使用waitpid等待前台作业终止回收，使用机制信号来回收后台作业 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的、处于运行状态的子进程。 使用函数intfork(void) 子进程返回0，父进程返回子进程的PID 新创建的子进程几乎但不完全与父进程相同： 1.子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本 2.子进程获得与父进程任何打开文件描述符相同的副本 3.子进程有不同于父进程的PID fork函数：被调用一次，却返回两次（分别是父子进程） 6.4Hello的execve过程 使用intexecve(char*filename,char*argv[],char*envp[])函数，在当前进程中载入并运行程序 filename:可执行文件：目标文件或脚本(用#!指明解释器,如#!/bin/bash) argv：参数列表,惯例：argv[0]==filename envp：环境变量列表：如"name=value"strings(e.g.,USER=droh)，getenv,putenv,printenv 覆盖当前进程的代码、数据、栈，保留有相同的PID，继承已打开的文件描述符和信号上下文 调用一次并从不返回，除非有错误，例如：指定的文件不存在 图6.4新程序启动后的栈结构 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 以hello中的这个循环为例： 图6.5.1 printf为用户进程中的一部分，而sleep为系统内核进程的一部分，因此此处有上下文切换过程，如下： 图6.5.2上下文切换 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 正常结果： 图6.6.1正常结果 不停乱按： 图6.6.2不停乱按结果 图6.6.3 不停乱按时，乱按输入的字符被缓存到stdin（标准输入），hello中运行到getchar的时读一个“\n”结尾的字串，该字符串会当做shell命令行输入（且为最后一次以\n结尾的字符串）。图中输入了ksafdjbl.\n与fasjnddas.na\n，运行hello程序结束之后屏幕输出了fasjnddas.na作为命令行。 Ctrl-Z： 图6.6.4按下Ctrl_Z Ctrl_Z为挂起前台作业，由图可知该进程被挂起（stopped），但是被挂起的hello进程没有被回收，它的jid为1，在后续输入fg之后，该hello又被唤醒，命令行先输出./hello1190202328江经这个进程名称，再继续接着刚刚中断的位置执行，后续输出与原来一致，也需要等待输入一个字符才能结束该进程。 在按下Ctrl_Z之后继续按下如下命令： ps： 图6.6.5按下ps 显示当前所有进程（图中因为我运行了两个hello程序,按下了两次ctrl_z，因此有两个作业都被挂起，因此有两个hello） jobs： 图6.6.6按下jobs 显示当前所有作业及其状态（图中因为我运行了两个hello程序,按下了两次ctrl_z，因此有两个作业都被挂起） pstree： 图6.6.7按下pstree 显示进程树，由于太多，因此只截图部分示意 fg： 图6.6.8按下fg 将后台的进程调入前台运行，图中我将作业号为1的作业调入前台运行，即刚刚被挂起的hello进程，因此该进程继续输出8个hello1190202328江经后等待一个字符输入，之后结束进程，然后被回收。 kill： 图6.6.9按下kill 发送信号给某个进程或者进程组。图中我发送9号信号（杀死进程）给2582号进程（即为hello的一个进程），因此显示1号任务（对应进程号2582）被杀死（killed）。 Ctrl-C： 图6.6.10按下Ctrl_C Ctrl_C为终止前台作业，由图可知该进程杀死，而输入ps之后观察，进程中已经没有hello（pid=2755）了，hello进程接收到ctrl_c之后就被终止，且被回收。 6.7本章小结 通过对本章的学习，我学会了进程的相关概念，比如：如何通过fork来创建进程，如何通过wait等一系列函数来回收进程，如何通过execve来加载覆盖一个进程。以及信号的一些概念，如信号的发送，阻塞，接收等。对Linux的上下文切换等机制有了更深的了解。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 逻辑地址：在有地址变换功能的计算机中，访内指令给出的地址(操作数)叫逻辑地址，也叫相对地址。例如hello的反汇编代码中的指令地址。 线性地址：逻辑地址到物理地址变换之间的中间层。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址就直接成为物理地址了。 虚拟地址：即为线性地址。 物理地址：指出现CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 图7.2 步骤如上图。首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]， 1、看段选择符的T1=0还是1，知道当前要转换是（全局段描述符）GDT中的段，还是局部段描述符（LDT）中的段，再根据相应寄存器（GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中），得到其地址和大小。于是就得到了一个数组了。 2、拿出段选择符中前13位即图中的index，可以在这个数组中，查找到对应的段描述符，这样基地址Base就知道了。 3、Base+offset即为被转换的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 图7.3.1符号表 首先将线性地址分为VPN+VPO的形式，再去页表中寻找PPN，如果页表中没有，则发生缺页，进入缺页异常处理程序，选择一个牺牲页，换入该页，再重新运行访问页面的指令。在查找到对应的PPN之后，将其与VPO组合变为PPN+VPO，即为物理地址。如下图： 图7.3.2翻译示图 7.4TLB与四级页表支持下的VA到PA的变换 如果有TLB，则首先将线性地址分为VPN+VPO的形式，再将VPN分为TLBT+TLBI的形式，根据这标记和索引去TLB中寻找，如果命中，则直接取出其中存放的PPN；如果不命中，则去页表中寻找，此时将VPN分解为VPN1+VPN2+VPN3+VPN4，一级一级地查找，如果到对应的PPN，则取出PPN；如果找不到，则产生异常，进入缺页异常处理程序，选择一个牺牲页，将其替换，再重新执行刚刚的指令，得到PPN。 在查找到对应的PPN之后，将其与VPO组合变为PPN+VPO，即为物理地址。 图7.4i7地址翻译实例 7.5三级Cache支持下的物理内存访问 如上图,在得到物理地址之后，将物理地址拆分为三部分：CT（标记）+CI（组索引）+CO（块偏移），首先在L1cache中寻找，如果未命中，则继续在L2中寻找，如果还未命中，则继续在L3中寻找，如果L3未命中，则去内存中寻找，直到找到，返回结果。 7.6hello进程fork时的内存映射 mm_struct（内存描述符）：描述了一个进程的整个虚拟内存空间 vm_area_struct（区域结构描述符）：描述了进程的虚拟内存空间的一个区间 用fork创建虚拟内存时： 1.fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID 2.创建当前进程的mm_struct,vm_area_struct和页表的原样副本 3.两个进程的每个页面都标记为只读页面 4.两个进程的每个vm_area_struct都标记为私有，这样就只能在写入时复制。 以此保证在fork之后，父子进程的内存映射几乎完全相同。 7.7hello进程execve时的内存映射 函数原型：intexecve(char*filename,char*argv[],char*envp[]) 在当前进程中载入并运行程序，在此例中为shell进程首先fork一个子进程，再在子进程中调用execve函数加载hello进程。 filename:可执行文件，本例中应该为hello argv：参数列表,惯例：argv[0]==filename（hello） envp：环境变量列表 调用execve函数之后覆盖当前进程的代码、数据、栈 保留有相同的PID，继承已打开的文件描述符和信号上下文 如下图： 图7.7execve函数执行后栈 加载hello的具体过程如下： 1.删除已存在的用户区域，删除当前进程（shell调用fork创建的子进程）虚拟地址的用户部分中的已存在的区域结构。 2.映射私有区域，为新程序的代码、数据、.bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，.bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3.映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC），设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 1.段错误：首先，先判断缺页的虚拟地址是否合法。遍历所有的合法区域结构，如果这个虚拟地址对所有的区域结构都无法匹配，那么就返回一个段错误（segmentfault） 2.非法访问：接着，查看这个地址的权限，判断一下进程是否有读写改这个地址的权限。如下图： 3.如果不是以上两种情况则为正常缺页，通过查询页表PTE可以知道虚拟页所在在磁盘的位置。缺页处理程序从指定的位置加载页面到物理内存中，并更新PTE。然后控制返回给引起缺页故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，因此指令可以没有故障地运行完成。具体流程如图步骤(1)(2)(3)(4)所示： 图7.8.1段错误示例 图7.8.2缺页处理流程 7.9动态存储分配管理 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 在程序运行时程序员使用动态内存分配器(比如malloc)获得虚拟内存。(数据结构的大小只有运行时才知道。)动态内存分配器维护着一个进程的虚拟内存区域，称为堆。层次关系如图7.9.1。内存镜像如图7.9.2。 图7.9.1层次关系 图7.9.2内存镜像 分配器将堆视为一组不同大小的块(blocks)的集合来维护，每个块要么是已分配的，要么是空闲的。 分配器的类型： 1.显式分配器: 要求应用显式地释放任何已分配的快 例如，C语言中的malloc和free 2.隐式分配器:应用检测到已分配块不再被程序所使用，就释放这个块 比如Java，ML和Lisp等高级语言中的垃圾收集(garbagecollection) 动态内存管理的基本方法与策略： 方法1:隐式空闲链表(Implicitlist)：通过头部中的大小字段 隐含地连接所有块。如图7.9.3 图7.9.3隐式空闲链表 如果块是对齐的，那么一些低阶地址位总是0，因此不要存储这些0位，而是使用它作为一个已分配/未分配的标志。但是读大小字段时，必须将其屏蔽掉。其内部结构如图7.9.4： 图7.9.4块结构 其搜索策略如下： 1.首次适配(Firstfit):从头开始搜索空闲链表，选择第一个合适的空闲块。 为总块数(包括已分配和空闲块)的线性时间，但是在靠近链表起始处留下小空闲块的“碎片”。 2.下一次适配(Nextfit):和首次适配相似，只是从链表中上一次查询结束的地方开始。 比首次适应更快，因为避免重复扫描那些无用块。一些研究表明，下一次适配的内存利用率要比首次适配低得多。 最佳适配(Bestfit):查询链表，选择一个最好的空闲块。 剩余最少空闲空间，保证了碎片最小 提高内存利用率，但是通常运行速度会慢于首次适配。 还可以利用边界标记(Boundarytags)[Knuth73]来实现双向查找，方便合并空闲块。即：在空闲块的“底部”标记“大小/已分配”，这允许我们反查“链表”，但这需要额外的空间。如图7.9.5： 图7.9.5块结构 合并策略： 立即合并(Immediatecoalescing):每次释放都合并 延迟合并(Deferredcoalescing):尝试通过延迟合并，即直到需要才合并来提高释放的性能。例如:1.为malloc扫描空闲链表时可以合并2.外部碎片达到阈值时可以合并。 方法2:显式空闲链表(Explicitlist)：在空闲块中使用指针。如图7.9.6 图7.9.6显式空闲链表 其每块内部结构如图7.9.7 图7.9.7块结构 显式空闲链表维护空闲块链表,而不是所有块， “下一个”空闲块可以在任何地方，因此需要存储前/后指针，而不仅仅是大小（size），还需要边界标记，用于块合并，但是，只需跟踪空闲块，因此可以使用有效载荷区域。 插入原则: 1.LIFO(last-in-first-out)策略：后进先出法，将新释放的块放置在链表的开始处 优点:简单，常数时间 缺点:研究表明碎片比地址顺序法更糟糕 2.地址顺序法(Address-orderedpolicy)，按照地址顺序维护链表:addr(前一个块)<addr(当前回收块)<addr(下一个块) 优点:研究表明碎片要少于LIFO(后进先出法) 缺点:需要搜索 方法3:分离的空闲列表(Segregatedfreelist)：按照大小分类，构成不同大小的空闲链表，如图7.9.8： 图7.9.8分离的空闲列表 每个尺寸类(sizeclass)中的块，构成一个空闲链表，通常每个小的尺寸/size，都是一个单独的类，对于大的尺寸/size:按照2的幂分类。 分离适配策略如下： 申请块： 分配器维护一个空闲链表数组，每个空闲链表和一个大小类关联，链表是显式或隐式的。 当分配器需要一个大小为n的块时:搜索相应的空闲链表，其大小要满足m>n。1.如果找到了合适的块:拆分块，并将剩余部分插入到适当的可选列表中；如果找不到合适的块,就搜索下一个更大的大小类的空闲链表，直到找到为止。 如果空闲链表中没有合适的块:向操作系统请求额外的堆内存(使用sbrk())，从这个新的堆内存中分配出n字节，将剩余部分放置在适当的大小类中。 释放块： 合并，并将结果放置到相应的空闲链表中。 分离适配的优势 方法4:块按大小排序：在每个空闲块中使用一个带指针的平衡树，并使用长度作为权值。 7.10本章小结 通过堆本章的学习，我深入理解了虚拟内存的概念，以及如何将虚拟地址转换为物理地址，再利用物理地址来通过cache寻找内存的相应内容；我还深入理解了执行了fork、execve之后的内存映射；还深入理解了动态内存管理的基本方法与策略。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 一个Linux文件就是一个m字节的序列:§B0,B1, ,Bk, ,Bm-1¢所有的I/O设备都被模型化为文件: 例如： /dev/sda2（用户磁盘分区）/dev/tty2（终端）甚至内核也被映射为文件:§/boot/vmlinuz-3.13.0-55-generic（内核映像）/proc（内核数据结构） 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O: 8.2简述UnixIO接口及其函数 打开和关闭文件：open()andclose() 读写文件：read()andwrite() 改变当前的文件位置：seek() 指示文件要读写位置的偏移量：lseek() 8.3printf的实现分析 研究printf的实现，首先来看看printf函数的函数体： 图8.3.1printf函数的函数体 在形参列表里有这么一个token： ，这个是可变形参的一种写法。当传递参数的个数不确定时，就可以用这种方式来表示。很显然，我们需要一种方法，来让函数体可以知道具体调用时参数的个数。 先来看printf函数的内容： va_listarg=(va_list)((char*)(&fmt)+4); va_list的定义：typedefchar*va_list 这说明它是一个字符指针。其中的：(char*)(&fmt)+4)表示的是 中的第一个参数。 下面我们来看看下一句： i=vsprintf(buf,fmt,arg); 让我们来看看vsprintf(buf,fmt,arg)是什么函数。 图8.3.2vsprintf(buf,fmt,arg)函数 vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 write系统函数： 图8.3.3write系统函数 INT_VECTOR_SYS_CALL的实现： init_idt_desc(INT_VECTOR_SYS_CALL,DA_386IGate,sys_call,PRIVILEGE_USER); INT_VECTOR_SYS_CALL表示要通过系统来调用sys_call这个函数。 sys_call的实现： 图8.3.4sys_call的实现 其作用可以理解为：显示格式化了的字符串。 因此得知printf函数执行如下： 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar函数源代码如下： 图8.4getchar函数 异步异常-键盘中断的处理：当用户按键时，键盘接口会得到一个代表该按键的键盘扫描码，同时产生一个中断请求，中断请求抢占当前进程运行键盘中断子程序，键盘中断子程序先从键盘接口取得该按键的扫描码，然后将该按键扫描码转换成ASCII码，保存到系统的键盘缓冲区之中。 getchar函数落实到底层调用了系统函数read，通过系统调用read读取存储在键盘缓冲区中的ASCII码直到读到回车符然后返回整个字串。 8.5本章小结 通过对本章的学习，我了解了Linux的IO设备管理方法以及UnixIO接口及其函数；以及深入理解了printf的实现以及getchar的实现。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 写代码：hello.c中编写程序预处理：hello.c经过cpp的预处理变为hello.i编译：hello.i经过ccl的编译变为hello.s汇编：hello.s经过as的汇编变为hello.o链接：hello.o经过ld的链接变为可执行程序hello。运行：在shell终端输入命令行运行hello程序创建子进程：在shell中，输入执行hello的指令之后，shell调用fork函数创建一个子进程加载hello程序：shell在子进程中调execve函数，将hello加载到这个子进程中，覆盖掉原子进程，即hello变为了一个进程。上下文切换：操作系统为该进程划分时间片，hello程序执行时间达到该时间片之后，内核进行上下文切换到其他进程执行。或者，当hello程序执行到sleep函数，内核进行上下文切换，进程切换到处理休眠的进程，当sleep函数调用完成时，内核进行上下文切换将控制再次传递给hello进程。执行中取指令：Hello的执行中，不断从内存中取指令，此时用到了MMU将虚拟内存转换为物理内存，再利用了快表、4级页表、3级cache等来进行加速从内存中取出数据。动态内存申请：当hello程序执行printf函数时，printf会调用malloc向动态内存分配器申请堆中的内存。信号处理：在Hello的执行中，还可能接收并处理来自键盘等IO设备的信号，还可能产生缺页等异常，还会经过上下文切换进入异常处理程序。执行完毕：在hello执行完毕之后，由其父进程shell来对其进行回收，从此hello进程不复存在。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 计算机系统的设计与实现的深切感悟：计算机系统的设计最核心的部分就是软硬件的交界面，在这个界面中，既要将硬件抽象为一个个的接口，还要通过软件的设计来运用好这些接口，从而方便更高层应用的使用。而计算机设计的最主要目的是：快！为了加快计算机速度，在计算机内部采用了cache，TLB等一系列结构，充分利用时间空间局部性来加快计算机速度。 创新理念：可以尝试增加cache层级来加快速度，需要实验验证。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明其作用。 文件名作用hello.chello程序的源代码（文本文件）hello.ihello.c预处理处理得到的文件（文本文件）hello.shello.i编译后得到的汇编代码（文本文件）hello.ohello.s汇编后得到的可重定位目标文件（二进制文件）helloHello.o与其他文件链接后得到的可执行文件（二进制文件） （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 RandalE.Bryant and DavidR.O'Hallaron.ComputerSystems:AProgrammer'sPerspective,3/E(CS:APP3e). CarnegieMellonUniversity,2015. https://www.csdn.net https://baike.baidu.com https://www.cnblogs.com/pianist/p/3315801.html （参考文献0分，缺失-1分） 
第448篇文章[]
eclipse使用过程中遇到的问题合集（持续更新中 ） 目录 问题1 JUnit项目无法正确运行 问题2 JUnit配置问题 问题3 在外部修改了文件后无法在eclipse中读取和运行 问题1 JUnit项目无法正确运行 解决方法 方法一：将测试代码文件暂时放入src文件夹中才能执行，在test文件夹中不能执行。 方法二：外部创建的文件夹是普通文件夹，而不是source folder，因此需要在eclipse中创建source file，在这个文件夹中再建立package，再建立.java即可运行。 问题2 JUnit配置问题 解决方法 应该在classPath导入库 注意是在Classpath中加入JUnit库，而不是在Modulepath中加入。 问题3 在外部修改了文件后无法在eclipse中读取和运行 解决方法 在eclipse中删除该文件（注意不要删除磁盘文件），然后点击 Openprojectsfromfilesystem,再点击Directory，选中自己要导入的java文件夹即可。 
第449篇文章[]
Git将文件提交到远程仓库 本文主要是对git的提交做了一个整理，对于git的起步的安装以及初始化等不再赘述，默认git已经安装完成可以使用。 注意，文中尖括号表示可变的部分，url表示链接地址 一、获取git仓库 1.Git前如果不是在目标文件夹中使用git，那么可以通过cd指令如： $cd/home/user/my_project(linux) $cd/User/user/my_project(macOS) $cd/c/user/my_prject(Windows) 或者是在目标文件夹右键空白位置打开菜单栏里打开gitbash直接就在当前目标文件夹下。 2. $gitinit 该命令在目标文件夹下创建一个名为.git的子目录，这个子目录含有你初始化的git仓库中的必须文件，这些文件是git仓库的骨干。 3.$gitclone<url> 获得一份已经存在的git仓库的拷贝，将git仓库上的文件拷贝到你的本地并且在目录下初始化一个.git文件夹。 4.$gitadd. (别忘了add后有个空格且有个.) $gitcommit-m“<name>” 将目标文件夹中的文件进行版本控制，并初步提交到本地git仓库。 二、git远程仓库的使用 1.$gitremote-v 查看远程仓库,会显示需要读写远程操作使用的git保存的简写以及其对应的URL （Ps:gitclone命令货去的git仓库会添加有远程仓库） 2.$gitremoteadd<name><url> 添加一个新的远程git仓库 3.$gitbranch<name> 在本地建立一个新的分支（比如master分支） $gitcheckout<name> 切换到<name>的分支上 （这部分不是很重要，创建新分支时使用） 4.$gitpush<remote><branch>（这个指令也可以将新建的分支push到远程仓库上） 如$gitpushorigin<name>将本地的<name>分支推送到远程仓库上 $gitpushorigin<branch>:<branch> 前一个为本地仓库分支名，后一个为远程仓库的分支名，将本地分支指定推送到远程仓库的某个分支上。 5.Ps：远程仓库的重命名和移除 重命名：$gitremoterename<prename><newname> 移除$gitremoteremove<name> 6.注意分支切换之后会改变HEAD的指向，会指向当前所在的分支，如果进行本地仓库的commit，会导致head指向的分支和head操作自动向前移动，其他分支并没有，会留在切换之前commit的历史，那么这样就可以对项目做出分叉。 7.更多参考资料https://git-scm.com/book/zh/v2 
第450篇文章[]
spec学习笔记 设计规约 目标：方法的规约 前置/后置条件 欠定规约，非确定规约 陈述式、操作式规约 规约强度及其比较 如何写出好的规约 “方法”是程序的“积木”，可以被独立开发、测试和复用，需要抽象 代码中蕴含的“设计决策”：给编译器度 注释中蕴含的“设计决策”：给自己和别人读 规约给“供需双方”都确定了责任，在调用时候双方都要遵守。 前置条件和后置条件 前置条件：对客户端的约束，在使用方法时必须满足的条件 后置条件：对开发者的约束，方法结束时必须满足的条件 契约：前置条件满足，后置条件必须满足 可以加入@requires和@effects 规约的评价 规约的确定性；规约的陈述性；规约的强度 前置条件和后置条件的切分考虑 强的规约，放松的前置条件和更严格的后置。 欠定规约：同一个输入有多个输出 非确定规约：同一个输入，多次执行时的输出可能不同 操作式规约：伪代码 声明式规约：没有内部实现描述，只有“初-终” 例子 /** * * */ 
第451篇文章[]
数据类型学习笔记 数据类型：一组值，并且包括可以对齐所做的操作 变量：用特定数据类型定义可以存储满足类型约束的值 基本数据类型：int;long;Boolean;double;char; 对象数据类型：String;BigInteger; 基础类型一般是只有值，没有ID（与其他值无法区分）是不可边的，在栈中分配内存，代价一般较低 对象引用类型：（如classes,interfaces,arrays等）既有自己的ID也有值，分为可变和不可变的，在堆中分配内存，代价一般很昂贵。 对象引用类型能形成层次结构： 比如：继承关系（extends） 可以将基础类型包装为对象引用类型（一般是定义一个集合） 操作符：+-*/等运算；重载：操作符可用于不同数据类型 静态/动态类型检查 静态类型，在编译阶段进行类型检查 语法错误；类名/函数名错误；参数数目错误；参数类型错误；返回值类型错误 动态类型：在运行阶段进行类型检查。 非法的参数值；非法的返回值；越界；空指针 可变/不可变数据类型 改变变量：将该变量指向另一个值的存储空间 改变变量值：将该变量当前指向值的存储空间清除后写入一个新的值 所以在改变变量值的过程中的变化可能产生副作用。 不变性： 不变数据类型：一旦被创建，其值不能改变，包括引用类型，确定其指向的对象就不能再改变。（java中采用final变量作为方法的输入参数和局部变量） 不变对象：一旦被创建，始终指向同一个值（引用） 可变对象：在一些方法下可以修改自己的值/引用 要注意程序中哪些参数在程序始终不发生改变。也尽量避免改变 不可变：需要频繁的修改和产生大量临时的拷贝（需要进行垃圾回收） 可变：减少拷贝提高效率 不可变类型更加安全。 在引用参数时需要注意数据发生的变化，以防发生冒险 
第452篇文章[]
Junit断言（assert） voidassertArrayEquals(expectedArray,actualArray) 检查两个数组是否相等voidassertEquals(Objectexpected,Objectactual) 检查两个变量（可以为布尔值，可以为文本，也可以为数据）或等式是否平衡voidassertTrue(Booleancondition)检查为真voidassertFalse(Booleancondition)检查为假voidassertNotNull(Objectobject)检查对象不为空voidassertNull(Objectobject)检查对象为空voidassertSame(Objectobject,Objectobject)检查两个对象是否为相同的引用voidassertNotSame(Objectobject,Objectobject)检查两个对象是否为不同的引用voidassertThat(Objectobject,condition) 9.主要都是前一个待测数据是否符合后面的条件，条件有 /*一般匹配符*/ allOf()接下来的所有条件必须都成立 anyOf()接下来的所有条件至少一个成立 anything()不管如何，永远成立 is()与is括号中给出的object相等则通过 not()与not括号中给出的object不等则通过 /*数据匹配符*/ CloseTo()前面的数据在括号中给出的范围之内，括号给出（n,a）表示n±a的范围内 GreaterThan()前面的数据大于括号内的数据 LessThan()前面的数据小于括号内的数据 EqualTo()前面的数据等于括号内的数据，相当于equals方法 /*字符串匹配符*/ containsString()前面的数据中包含指定字符串 startsWith()前面的数据是指定字符串开头 endsWith()前面的数据是指定字符串结尾 /*集合匹配符*/ hasItem()集合中含有指定元素 hasEntry()含有指定的键对 hasKey()含指定键 hasValue()含指定值 
第453篇文章[1]
CSAPP大作业 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机科学与技术 学 号 1190202402 班 级 1936602 学 生 李培意 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 从hello这一文件看到一个程序背后的故事。围绕我们每个程序员最先写下的能正常运行的程序hello，透过其整个生命的流程，分析出其背后的种种过程以及各种系统中的管理，来反馈出计算机系统这一复杂系统的理解。也了解硬件，操作系统，程序之间的配合关系。也让hello从编程软件中脱离出来，经历预处理、编译、汇编、再到链接。成为一个系统可运行的程序。也从系统的进程管理，存储管理，IO的管理角度进行分析。以及最后被系统回收。从hello的一生，来看计算机系统的运行。 关键词：hello的一生；计算机系统；存储管理；进程管理；预处理、编译、汇编、链接； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P：FromProgramtoprocess: Hello刚开始只是一段C语言代码，存于内存当中，也就是最初的hello.c程序，也就是最初的program。编译器驱动程序。然后编译器驱动程序在需要时候调用预处理器、编译器、汇编器和链接器。首先是预处理器（cpp）将C语言源程序hello.c预处理为一个中间文件；编译器（ccl）将该中间文件翻译为一个汇编语言文件；汇编器（as）将汇编语言文件翻译为可重定位目标文件；最后链接器（ld）创建一个可执行目标文件。可以通过shell创建一个子进程运行该可执行目标文件。 020：FromZero-0toZero-0 运行可执行目标文件，调用程序wxecve,一次进行对于虚拟内存的映射，物理内存载入，进入主程序运行代码，调用系统函数 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位 开发与调试工具：gcc，vim，edb，readelf，HexEdit 1.3中间结果 hello.c (C语言源程序) hello.i (hello.c预处理之后的中间文件) hello.s (hello.i编译成汇编语言之后的汇编语言文件) hello.o (hello.s生成的二进制文件，也就是可重定位目标文件) hello (可执行目标文件) 。 1.4本章小结 介绍了Hello的基本信息，介绍了实验的基本环境工具，以及可能生成的实验的中间结果。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 （以下格式自行编排，编辑时删除） 预处理的概念：预处理器根据字符#开头的命令，修改原始程序，将引用的库合并成完整文件。 C语言的预处理主要有三个方面的内容： 1.宏定义（#define）； 2.文件包含（#include）； 3.条件编译（#ifdef/#ifndef/#if/#else/#elseif/#endif）； C预处理器是C语言、C++语言的预处理器。用于在编译器处理程序之前预扫描源代码，完成头文件的包含, 宏扩展, 条件编译, 行控制（linecontrol）等操作。 这样做的目的是使得编译器在对程序进行翻译的时候更加方便。 2.2在Ubuntu下预处理的命令 预处理命令：gcc-Ehello.c-ohello.i 应截图，展示预处理过程！ 2.3Hello的预处理结果解析 原本只有几行的源代码扩展到了3000多行并且在在原有的代码基础上加入了系统库中包含的typedef，结构体，以及外部引用符号。另外还添加了以#开头的语句，这些都是用来辅助表示代码是源自哪个文件以及行号的。 typedef 结构体，#语句 2.4本章小结 本章介绍了C预处理的概念和作用。展示了用linux虚拟机进行预处理的过程以及结果，还有对该结果的分析 （以下格式自行编排，编辑时删除） （第2章0.5分） 第3章编译 3.1编译的概念与作用 将某种高级程序设计语言翻译为低一级的汇编语言并生成汇编语言文件 是高级语言和机器语言之间的媒介，方便程序进一步转换为机器可读的语言。 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令 编译命令：gcc-Shello.i-ohello.s 应截图，展示编译过程！ 3.3Hello的编译结果解析 编译结果： .file"hello.c" .text .globl sleepsecs .data .align4 .type sleepsecs,@object .size sleepsecs,4 sleepsecs: .long 2 .section.rodata .align8 .LC0: .string "Usage:Hello1190202402\346\235\216\345\237\271\346\204\217\357\274\201" .LC1: .string "Hello%s%s\n" .text .globl main .type main,@function main: .LFB6: .cfi_startproc endbr64 pushq %rbp .cfi_def_cfa_offset16 .cfi_offset6,-16 movq %rsp,%rbp .cfi_def_cfa_register6 subq $32,%rsp movl %edi,-20(%rbp) movq %rsi,-32(%rbp) cmpl $3,-20(%rbp) je .L2 leaq.LC0(%rip),%rdi callputs@PLT movl $1,%edi callexit@PLT .L2: movl $0,-4(%rbp) jmp.L3 .L4: movq -32(%rbp),%rax addq $16,%rax movq (%rax),%rdx movq -32(%rbp),%rax addq $8,%rax movq (%rax),%rax movq %rax,%rsi leaq.LC1(%rip),%rdi movl $0,%eax callprintf@PLT movl sleepsecs(%rip),%eax movl %eax,%edi callsleep@PLT addl$1,-4(%rbp) .L3: cmpl $9,-4(%rbp) jle .L4 callgetchar@PLT movl $0,%eax leave .cfi_def_cfa7,8 ret .cfi_endproc .LFE6: .size main,.-main .ident "GCC:(Ubuntu10.3.0-1ubuntu1~20.10)10.3.0" .section.note.GNU-stack,"",@progbits .section.note.gnu.property,"a" .align8 .long 1f-0f .long 4f-1f .long 5 0: .string "GNU" 1: .align8 .long 0xc0000002 .long 3f-2f 2: .long 0x3 3: .align8 4: 全局变量：全局变量在data节中定义它，并且解释了它。 .globl sleepsecs 局部变量：局部变量会在栈中储存它，给他分配一个大小符合的字节大小。 argc/argv调用main函数里传入的参数，存放在%rdi中 主函数： main: .LFB6: .cfi_startproc endbr64 pushq %rbp .cfi_def_cfa_offset16 .cfi_offset6,-16 movq %rsp,%rbp .cfi_def_cfa_register6 subq $32,%rsp movl %edi,-20(%rbp) movq %rsi,-32(%rbp) cmpl $3,-20(%rbp) je .L2 leaq.LC0(%rip),%rdi callputs@PLT movl $1,%edi callexit@PLT 其余略， rdi和rsi均为从堆栈中调用数据 i局部变量，在循环中出现，作为每次循环更新的变量保存在%ebx中 赋值 .long 2（全局变量赋值） movl $0,-4(%rbp)（局部变量赋值） 4．类型转换 .type sleepsecs,@object .size sleepsecs,4 sleepsecs: .long 2 movl sleepsecs(%rip),%eax movl %eax,%edi 算数操作 addl$1,-4(%rbp)(对应i++) addq$16,%rax addq$8,%rax subq$32,%rsp 关系操作 cmpl $9,-4(%rbp)（循环中的＜操作 cmpl $3,-20(%rbp)（if语句） 控制转移 je .L2根据条件进行跳转 jmp.L3 ret返回 函数操作 callputs@PLT callexit@PLT callsleep@PLT callgetchar@PLT 头部 .file: 说明文件名字为从hello.c编译而来 .text 代码段 .globl 全局变量：说明sleepsecs是全局变量 .data 数据段 .align 对齐方式，.align4说明是按四个字节对齐 .type sleepsec，说明这个变量是对象类型 .size 大小，说明这个变量占用的大小为4字节 .long 说明sleepsec的类型是long .section说明sleepsecs的节在于只读数据段 注意main为全局符号在.text段中 3.4本章小结 介绍了编译的概念及其作用，利用汇编文件解析了汇编文件中各部分的作用，并与源程序对比，看汇编文件有哪些方面不同，从汇编文件中看源程序。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 通过汇编器，将汇编语言翻译成机器语言，并生成机器语言的二进制程序 转化为了机器能够理解的二进制文本，方便程序的执行。 4.2在Ubuntu下汇编的命令 汇编命令：ashello.s-ohello.o 应截图，展示汇编过程！ 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 由图可知，ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或共享的）、机器类型（如x86-64）、节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的头目（entry）。 节头部表，描述了每个节的名字，种类，地址偏移，大小，全体大小，flag，链接，信息，对齐。 但没有这些头： 重定位节：有静态链接内容pc也有动态链接内容plt，也存在一个异常处理单元 符号表 4.4Hello.o的结果解析 hello.o： 文件格式elf64-x86-64 Disassemblyofsection.text: 0000000000000000<main>: 0: f30f1efa endbr64 4: 55 push %rbp 5: 4889e5 mov %rsp,%rbp 8: 4883ec20 sub $0x20,%rsp c: 897dec mov %edi,-0x14(%rbp) f: 488975e0 mov %rsi,-0x20(%rbp) 13: 837dec03 cmpl $0x3,-0x14(%rbp) 17: 7416 je 2f<main+0x2f> 19: 488d3d00000000 lea 0x0(%rip),%rdi #20<main+0x20> 1c:R_X86_64_PC32.rodata-0x4 20: e800000000 callq 25<main+0x25> 21:R_X86_64_PLT32 puts-0x4 25: bf01000000 mov $0x1,%edi 2a: e800000000 callq 2f<main+0x2f> 2b:R_X86_64_PLT32 exit-0x4 2f: c745fc00000000movl $0x0,-0x4(%rbp) 36: eb3b jmp 73<main+0x73> 38: 488b45e0 mov -0x20(%rbp),%rax 3c: 4883c010 add $0x10,%rax 40: 488b10 mov (%rax),%rdx 43: 488b45e0 mov -0x20(%rbp),%rax 47: 4883c008 add $0x8,%rax 4b: 488b00 mov (%rax),%rax 4e: 4889c6 mov %rax,%rsi 51: 488d3d00000000 lea 0x0(%rip),%rdi #58<main+0x58> 54:R_X86_64_PC32.rodata+0x21 58: b800000000 mov $0x0,%eax 5d: e800000000 callq 62<main+0x62> 5e:R_X86_64_PLT32 printf-0x4 62: 8b0500000000 mov 0x0(%rip),%eax #68<main+0x68> 64:R_X86_64_PC32sleepsecs-0x4 68: 89c7 mov %eax,%edi 6a: e800000000 callq 6f<main+0x6f> 6b:R_X86_64_PLT32 sleep-0x4 6f: 8345fc01 addl $0x1,-0x4(%rbp) 73: 837dfc09 cmpl $0x9,-0x4(%rbp) 77: 7ebf jle 38<main+0x38> 79: e800000000 callq 7e<main+0x7e> 7a:R_X86_64_PLT32 getchar-0x4 7e: b800000000 mov $0x0,%eax 83: c9 leaveq 84: c3 retq 十进制数被翻译为了16进制数一些符号信息已经被放入了表中，特别是引用函数中的符号的重定位信息堆栈申请大小不同没有再细分便于理解的各种段地址由相对偏移量转变为了可由cpu直接访问的虚拟地址跳转指令的变化 4.5本章小结 对汇编的概念以及作用的叙述，并且在linux虚拟机中进行了演示，并探究了重定位前和重定位后反汇编的汇编程序的差异。分析了ELF格式文件的组成。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据片段收集并组合成一个单一文件的过程，将一个或多个由编译器或汇编器生成的目标文件外加库，链接为一个可执行文件。这个文件可以被加载到内存并执行。链接可以在编译时实现，也就是在源代码被翻译成机器代码时，也可以在加载时实现，也就是在程序被加载器加载到内存并执行时，甚至可以在运行时实现，也就是由应用程序来执行。 产生一个可以直接被加载到内存并执行的文件。 5.2在Ubuntu下链接的命令 链接命令：gcchello.o-ohello 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 前四行为堆栈分配的虚拟空间。 5.5链接的重定位过程分析 （以下格式自行编排，编辑时删除） hello： 文件格式elf64-x86-64 Disassemblyofsection.init: 0000000000001000<_init>: 1000: f30f1efa endbr64 1004: 4883ec08 sub $0x8,%rsp 1008: 488b05d92f0000 mov 0x2fd9(%rip),%rax #3fe8<__gmon_start__> 100f: 4885c0 test %rax,%rax 1012: 7402 je 1016<_init+0x16> 1014: ffd0 callq *%rax 1016: 4883c408 add $0x8,%rsp 101a: c3 retq Disassemblyofsection.plt: 0000000000001020<.plt>: 1020: ff357a2f0000 pushq 0x2f7a(%rip) #3fa0<_GLOBAL_OFFSET_TABLE_+0x8> 1026: f2ff257b2f0000 bndjmpq*0x2f7b(%rip) #3fa8<_GLOBAL_OFFSET_TABLE_+0x10> 102d: 0f1f00 nopl (%rax) 1030: f30f1efa endbr64 1034: 6800000000 pushq $0x0 1039: f2e9e1ffffff bndjmpq1020<.plt> 103f: 90 nop 1040: f30f1efa endbr64 1044: 6801000000 pushq $0x1 1049: f2e9d1ffffff bndjmpq1020<.plt> 104f: 90 nop 1050: f30f1efa endbr64 1054: 6802000000 pushq $0x2 1059: f2e9c1ffffff bndjmpq1020<.plt> 105f: 90 nop 1060: f30f1efa endbr64 1064: 6803000000 pushq $0x3 1069: f2e9b1ffffff bndjmpq1020<.plt> 106f: 90 nop 1070: f30f1efa endbr64 1074: 6804000000 pushq $0x4 1079: f2e9a1ffffff bndjmpq1020<.plt> 107f: 90 nop Disassemblyofsection.plt.got: 0000000000001080<__cxa_finalize@plt>: 1080: f30f1efa endbr64 1084: f2ff256d2f0000 bndjmpq*0x2f6d(%rip) #3ff8<__cxa_finalize@GLIBC_2.2.5> 108b: 0f1f440000 nopl 0x0(%rax,%rax,1) Disassemblyofsection.plt.sec: 0000000000001090<puts@plt>: 1090: f30f1efa endbr64 1094: f2ff25152f0000 bndjmpq*0x2f15(%rip) #3fb0<puts@GLIBC_2.2.5> 109b: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010a0<printf@plt>: 10a0: f30f1efa endbr64 10a4: f2ff250d2f0000 bndjmpq*0x2f0d(%rip) #3fb8<printf@GLIBC_2.2.5> 10ab: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010b0<getchar@plt>: 10b0: f30f1efa endbr64 10b4: f2ff25052f0000 bndjmpq*0x2f05(%rip) #3fc0<getchar@GLIBC_2.2.5> 10bb: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010c0<exit@plt>: 10c0: f30f1efa endbr64 10c4: f2ff25fd2e0000 bndjmpq*0x2efd(%rip) #3fc8<exit@GLIBC_2.2.5> 10cb: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010d0<sleep@plt>: 10d0: f30f1efa endbr64 10d4: f2ff25f52e0000 bndjmpq*0x2ef5(%rip) #3fd0<sleep@GLIBC_2.2.5> 10db: 0f1f440000 nopl 0x0(%rax,%rax,1) Disassemblyofsection.text: 00000000000010e0<_start>: 10e0: f30f1efa endbr64 10e4: 31ed xor %ebp,%ebp 10e6: 4989d1 mov %rdx,%r9 10e9: 5e pop %rsi 10ea: 4889e2 mov %rsp,%rdx 10ed: 4883e4f0 and $0xfffffffffffffff0,%rsp 10f1: 50 push %rax 10f2: 54 push %rsp 10f3: 4c8d05c6010000 lea 0x1c6(%rip),%r8 #12c0<__libc_csu_fini> 10fa: 488d0d4f010000 lea 0x14f(%rip),%rcx #1250<__libc_csu_init> 1101: 488d3dc1000000 lea 0xc1(%rip),%rdi #11c9<main> 1108: ff15d22e0000 callq *0x2ed2(%rip) #3fe0<__libc_start_main@GLIBC_2.2.5> 110e: f4 hlt 110f: 90 nop 0000000000001110<deregister_tm_clones>: 1110: 488d3d012f0000 lea 0x2f01(%rip),%rdi #4018<__TMC_END__> 1117: 488d05fa2e0000lea 0x2efa(%rip),%rax #4018<__TMC_END__> 111e: 4839f8 cmp %rdi,%rax 1121: 7415 je 1138<deregister_tm_clones+0x28> 1123: 488b05ae2e0000 mov 0x2eae(%rip),%rax #3fd8<_ITM_deregisterTMCloneTable> 112a: 4885c0 test %rax,%rax 112d: 7409 je 1138<deregister_tm_clones+0x28> 112f: ffe0 jmpq *%rax 1131: 0f1f8000000000nopl 0x0(%rax) 1138: c3 retq 1139: 0f1f8000000000nopl 0x0(%rax) 0000000000001140<register_tm_clones>: 1140: 488d3dd12e0000 lea 0x2ed1(%rip),%rdi #4018<__TMC_END__> 1147: 488d35ca2e0000 lea 0x2eca(%rip),%rsi #4018<__TMC_END__> 114e: 4829fe sub %rdi,%rsi 1151: 4889f0 mov %rsi,%rax 1154: 48c1ee3f shr $0x3f,%rsi 1158: 48c1f803 sar $0x3,%rax 115c: 4801c6 add %rax,%rsi 115f: 48d1fe sar %rsi 1162: 7414 je 1178<register_tm_clones+0x38> 1164: 488b05852e0000 mov 0x2e85(%rip),%rax #3ff0<_ITM_registerTMCloneTable> 116b: 4885c0 test %rax,%rax 116e: 7408 je 1178<register_tm_clones+0x38> 1170: ffe0 jmpq *%rax 1172: 660f1f440000 nopw 0x0(%rax,%rax,1) 1178: c3 retq 1179: 0f1f8000000000nopl 0x0(%rax) 0000000000001180<__do_global_dtors_aux>: 1180: f30f1efa endbr64 1184: 803d892e000000 cmpb $0x0,0x2e89(%rip) #4014<completed.0> 118b: 752b jne 11b8<__do_global_dtors_aux+0x38> 118d: 55 push %rbp 118e: 48833d622e0000 cmpq $0x0,0x2e62(%rip) #3ff8<__cxa_finalize@GLIBC_2.2.5> 1195: 00 1196: 4889e5 mov %rsp,%rbp 1199: 740c je 11a7<__do_global_dtors_aux+0x27> 119b: 488b3d662e0000 mov 0x2e66(%rip),%rdi #4008<__dso_handle> 11a2: e8d9feffff callq 1080<__cxa_finalize@plt> 11a7: e864ffffff callq 1110<deregister_tm_clones> 11ac: c605612e000001 movb $0x1,0x2e61(%rip) #4014<completed.0> 11b3: 5d pop %rbp 11b4: c3 retq 11b5: 0f1f00 nopl (%rax) 11b8: c3 retq 11b9: 0f1f8000000000nopl 0x0(%rax) 00000000000011c0<frame_dummy>: 11c0: f30f1efa endbr64 11c4: e977ffffff jmpq 1140<register_tm_clones> 00000000000011c9<main>: 11c9: f30f1efa endbr64 11cd: 55 push %rbp 11ce: 4889e5 mov %rsp,%rbp 11d1: 4883ec20 sub $0x20,%rsp 11d5: 897dec mov %edi,-0x14(%rbp) 11d8: 488975e0 mov %rsi,-0x20(%rbp) 11dc: 837dec03 cmpl $0x3,-0x14(%rbp) 11e0: 7416 je 11f8<main+0x2f> 11e2: 488d3d1f0e0000 lea 0xe1f(%rip),%rdi #2008<_IO_stdin_used+0x8> 11e9: e8a2feffff callq 1090<puts@plt> 11ee: bf01000000 mov $0x1,%edi 11f3: e8c8feffff callq 10c0<exit@plt> 11f8: c745fc00000000movl $0x0,-0x4(%rbp) 11ff: eb3b jmp 123c<main+0x73> 1201: 488b45e0 mov -0x20(%rbp),%rax 1205: 4883c010 add $0x10,%rax 1209: 488b10 mov (%rax),%rdx 120c: 488b45e0 mov -0x20(%rbp),%rax 1210: 4883c008 add $0x8,%rax 1214: 488b00 mov (%rax),%rax 1217: 4889c6 mov %rax,%rsi 121a: 488d3d0c0e0000 lea 0xe0c(%rip),%rdi #202d<_IO_stdin_used+0x2d> 1221: b800000000 mov $0x0,%eax 1226: e875feffff callq 10a0<printf@plt> 122b: 8b05df2d0000 mov 0x2ddf(%rip),%eax #4010<sleepsecs> 1231: 89c7 mov %eax,%edi 1233: e898feffff callq 10d0<sleep@plt> 1238: 8345fc01 addl $0x1,-0x4(%rbp) 123c: 837dfc09 cmpl $0x9,-0x4(%rbp) 1240: 7ebf jle 1201<main+0x38> 1242: e869feffff callq 10b0<getchar@plt> 1247: b800000000 mov $0x0,%eax 124c: c9 leaveq 124d: c3 retq 124e: 6690 xchg %ax,%ax 0000000000001250<__libc_csu_init>: 1250: f30f1efa endbr64 1254: 4157 push %r15 1256: 4c8d3d3b2b0000 lea 0x2b3b(%rip),%r15 #3d98<__frame_dummy_init_array_entry> 125d: 4156 push %r14 125f: 4989d6 mov %rdx,%r14 1262: 4155 push %r13 1264: 4989f5 mov %rsi,%r13 1267: 4154 push %r12 1269: 4189fc mov %edi,%r12d 126c: 55 push %rbp 126d: 488d2d2c2b0000 lea 0x2b2c(%rip),%rbp #3da0<__do_global_dtors_aux_fini_array_entry> 1274: 53 push %rbx 1275: 4c29fd sub %r15,%rbp 1278: 4883ec08 sub $0x8,%rsp 127c: e87ffdffff callq 1000<_init> 1281: 48c1fd03 sar $0x3,%rbp 1285: 741f je 12a6<__libc_csu_init+0x56> 1287: 31db xor %ebx,%ebx 1289: 0f1f8000000000nopl 0x0(%rax) 1290: 4c89f2 mov %r14,%rdx 1293: 4c89ee mov %r13,%rsi 1296: 4489e7 mov %r12d,%edi 1299: 41ff14df callq *(%r15,%rbx,8) 129d: 4883c301 add $0x1,%rbx 12a1: 4839dd cmp %rbx,%rbp 12a4: 75ea jne 1290<__libc_csu_init+0x40> 12a6: 4883c408 add $0x8,%rsp 12aa: 5b pop %rbx 12ab: 5d pop %rbp 12ac: 415c pop %r12 12ae: 415d pop %r13 12b0: 415e pop %r14 12b2: 415f pop %r15 12b4: c3 retq 12b5: 66662e0f1f8400data16nopw%cs:0x0(%rax,%rax,1) 12bc: 00000000 00000000000012c0<__libc_csu_fini>: 12c0: f30f1efa endbr64 12c4: c3 retq Disassemblyofsection.fini: 00000000000012c8<_fini>: 12c8: f30f1efa endbr64 12cc: 4883ec08 sub $0x8,%rsp 12d0: 4883c408 add $0x8,%rsp 12d4: c3 retq 汇编代码段增加，增加了.init.plt.plt.sec.fini .text段除了main增加了一些函数，如_start等 增加了外部的共享库函数 0000000000001090<puts@plt>: 1090: f30f1efa endbr64 1094: f2ff25152f0000 bndjmpq*0x2f15(%rip) #3fb0<puts@GLIBC_2.2.5> 109b: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010a0<printf@plt>: 10a0: f30f1efa endbr64 10a4: f2ff250d2f0000 bndjmpq*0x2f0d(%rip) #3fb8<printf@GLIBC_2.2.5> 10ab: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010b0<getchar@plt>: 10b0: f30f1efa endbr64 10b4: f2ff25052f0000 bndjmpq*0x2f05(%rip) #3fc0<getchar@GLIBC_2.2.5> 10bb: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010c0<exit@plt>: 10c0: f30f1efa endbr64 10c4: f2ff25fd2e0000 bndjmpq*0x2efd(%rip) #3fc8<exit@GLIBC_2.2.5> 10cb: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010d0<sleep@plt>: 10d0: f30f1efa endbr64 10d4: f2ff25f52e0000 bndjmpq*0x2ef5(%rip) #3fd0<sleep@GLIBC_2.2.5> 10db: 0f1f440000 nopl 0x0(%rax,%rax,1) 重定位 重定位节和符号：将所有类型相同的节合并在一起后，这个节就作为可执行目标文件的节。然后链接器把运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号，当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。也就是.text段中增加的一些新的函数，这些函数最终合并为同一聚合结。 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行地址。 5.6hello的执行流程 _start0x00000000004010fe _libc_start_main0x00007fffff5d70b3 main0x0000000000401105 printf@plt0x0000000000401090 sleep@plt 0x4010c0 getchar0x7fffff63e6e0 _rtld_global_ro0x7fffff7dd620 5.7Hello的动态链接分析 地址在dl_init后被改写了 进入改写地址后发现进入了一个新的函数，并且实现了GOT的动态链接。PLT使用GOT中的地址跳转到目标函数。 5.8本章小结 介绍了链接器的概念和作用，探讨了程序运行时的虚拟地址空间，分析了可执行文件的ELF，研究了重定位以及动态链接的过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的经典定义是一个执行中程序的实例，系统的每个程序都运行在某个进程的上下文。上下文是由程序正确运行所需的状态组成的，这个状态包括存放在内存里的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。 通过进程，我们会得到一种假象，好像我们的程序是当前唯一运行的程序，我们的程序独占处理器和内存，我们程序的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 shell俗称壳，它是指UNIX系统下的一个命令解析器；主要用于用户和系统的交互。UNIX系统上有很多种Shell。首个shell，即BourneShell，于1978年在V7(AT&T的第7版)UNIX上推出。后来，又演变出Cshell、bash等不同版本的shell。 Shell接受用户的命令并解释该命令然后将其送入内核执行。 处理流程：：打印一个提示符，等待用户输入命令行，从终端读入输入的命令。将输入的命令行切分得出参数，如果是内置命令则立即执行，否则调用相应的程序为其分配子进程并运行，.shell应该接受键盘输入信号，并对这些信号进行相应处理。并最终回收。 6.3Hello的fork进程创建过程 Shell调用fork函数创建子进程，形成自身的一个拷贝，为运行hello做准备 6.4Hello的execve过程 Shell调用execve函数在当前进程的上下文中加载并运行一个新的程序，即hello程序 6.5Hello的进程执行 逻辑控制流：即为一系列程序计数器PC的值序列进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。 时间片：进程执行它的控制流的部分时间段。 用户模式和内核模式：用户模式即为未设置模式位，不允许执行特权指令直接引用地址空间中内核区内的代码和数据；内核模式为设置模式位时，该进程执行所有命令访问所有数据。 上下文信息：上下文就是内核重启被抢占的进程所需要的状态，它由通用寄存器等各种内核数据构成。分别三个步骤： 保存当前进程的上下文 恢复某个先前被抢占的进程被保存的上下文 将控制传递给这个新恢复的进程。 6.6hello的异常与信号处理 正常运行： 乱按 回车 Ctrl+c Ctrl+z Ps: Jobs: Pstree： Fg： Kill 6.7本章小结 讨论了进程的概念和作用，简单介绍了shell以及其重要功能函数，最后进行了异常信号的处理。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：汇编程序中地址。逻辑地址由选择符和偏移量组成。是经过编译后出现在汇编程序中的地址。 线性地址：逻辑地址经过段机制后转化为线性地址，以描述符：偏移量的组合形式存在。分页机制中线性地址作为输入。 虚拟地址：类似于线性地址 物理地址：真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址 7.2Intel逻辑地址到线性地址的变换-段式管理 最初8086处理器的寄存器是16位的，为了能够访问更多的地址空间但不改变寄存器和指令的位宽，所以引入段寄存器，8086共设计了20位宽的地址总线，通过将段寄存器左移4位加上偏移地址得到20位地址，这个地址就是逻辑地址。将内存分为不同的段，段有段寄存器对应，段寄存器有一个栈、一个代码、两个数据寄存器。 分段功能在实模式和保护模式下有所不同。 实模式，即不设防，也就是说逻辑地址=线性地址=实际的物理地址。段寄存器存放真实段基址，同时给出32位地址偏移量，则可以访问真实物理内存。 在保护模式下，线性地址还需要经过分页机制才能够得到物理地址，线性地址也需要逻辑地址通过段机制来得到。段寄存器无法放下32位段基址，所以它们被称作选择符，用于引用段描述符表中的表项来获得描述符。描述符表中的一个条目描述一个段，构造如下： 7.3Hello的线性地址到物理地址的变换-页式管理 线性地址到物理地址之间的转换通过分页机制完成。而分页机制是对虚拟地址内存空间进行分页。 首先Linux系统有自己的虚拟内存系统，Linux将虚拟内存组织成一些段的集合，段之外的虚拟内存不存在因此不需要记录。内核为hello进程维护一个段的任务结构即图中的task_struct，其中条目mm指向一个mm_struct，它描述了虚拟内存的当前状态，pgd指向第一级页表的基地址（结合一个进程一串页表），mmap指向一个vm_area_struct的链表，一个链表条目对应一个段，所以链表相连指出了hello进程虚拟内存中的所有段。 系统将每个段分割为被称为虚拟页（VP）的大小固定的块来作为进行数据传输的单元，在linux下每个虚拟页大小为4KB，类似地，物理内存也被分割为物理页（PP/页帧），虚拟内存系统中MMU负责地址翻译，MMU使用存放在物理内存中的被称为页表的数据结构将虚拟页到物理页的映射，即虚拟地址到物理地址的映射。 7.4TLB与四级页表支持下的VA到PA的变换 36位的虚拟地址被分割成4个9位的片。CR3寄存器包含L1页表的物理地址。VPN1有一个到L1PTE的偏移量，找到这个PTE以后又会包含到L2页表的基础地址；VPN2包含一个到L2PTE的偏移量，找到这个PTE以后又会包含到L3页表的基础地址；VPN3包含一个到L3PTE的偏移量，找到这个PTE以后又会包含到L4页表的基础地址；VPN4包含一个到L4PTE的偏移量，找到这个PTE以后就是相应的PPN（物理页号）。 7.5三级Cache支持下的物理内存访问 cache：高速缓存，从上图就可以看出高速缓存的高效和高昂，三级cache是为了能在达到效率的前提下降低成本。 获得物理地址VA后，使用CI（后六位再后六位）进行组索引，每组8路，对8路的块分别匹配CT（前40位）如果匹配成功且块的valid标志位为1，则命中（hit），根据数据偏移量CO（后六位）取出数据返回。 如果没有匹配成功或者匹配成功但是标志位是1，则不命中（miss），向下一级缓存中查询数据（L2Cache->L3Cache->主存）。查询到数据之后，一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换 7.6hello进程fork时的内存映射 fork的内存映射是使用特殊文件提供匿名内存映射，而这种内存映射，适用于具有亲缘关系的进程之间；由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。 7.7hello进程execve时的内存映射 exceve函数加载和执行程序hello的步骤为：首先删除已存在的用户区域。然后为hello的代码、数据、bss和栈区域创建新的区域结构，所有这些区域都是私有的、写时复制的。再映射共享区域。比如hello程序与标准C库libc.so链接，这些对象都是动态链接到hello，然后存储在用户虚拟地址空间中的共享区域内。最后设置程序计数器（PC）。 7.8缺页故障与缺页中断处理 DRAM缓存的不命中被称为缺页。DRAM缓存的不命中触发一个缺页故障，缺页故障调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果该牺牲页已经做了更改，那么内核会将它复制回磁盘，否则不会进行复制即写回，然后将牺牲页从DRAM中出去，更新该页的位置放入待取的页面。然后CPU重新执行造成缺页故障的命令此时将可以正常运行。 7.9动态存储分配管理 在程序运行时应使用动态内存分配器给引用程序分配内存，动态内存分配器的维护着一个进程的虚拟内存（堆）。分配器将堆视为一组不同大小的块的集合来进行维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留以供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器分为两种基本风格：显式分配器、隐式分配器。 显式分配器：要求应用显式地释放任何已分配的块。 隐式分配器：要求分配器检测一个已分配块何时不再使用，那么就释放这个块。 7.10本章小结 通过对虚拟内存的介绍了解，学习了TLB和四级页表支持下VA到PA的转换，以及得到了PA后，三级cache下的物理内存的访问过程，掌握了各种函数与虚拟内存的关系。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 接口： 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。 2.Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。 3.改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置a，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置a。 4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置a开始，然后将a增加到a+n，给定一个大小为m字节的而文件，当a>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置a开始，然后更新a。 5.关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。 函数： open()函数：这个函数回打开一个已经存在的文件或者创建一个新的文件。 close()函数：这个函数关闭一个已经打开的文件。 read()函数：从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，返回值为0表示EOF。否则返回值表示的是实际传送的字节数量。 write()函数：从内存buf位置复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } intvsprintf(char*buf,constchar*fmt,va_listargs) { char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++) { if(*fmt!='%') { *p++=*fmt; continue; } fmt++; switch(*fmt) { case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); } vsprintf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。 在printf中调用系统函数write(buf,i)将长度为i的buf输出 Write: write: mov eax, _NR_write mov ebx, [esp + 4] mov ecx, [esp + 8] int INT_VECTOR_SYS_CALL 在write函数中，将栈中参数放入寄存器，ecx是字符个数，ebx存放第一个字符地址，intINT_VECTOR_SYS_CALLA代表通过系统调用syscall Sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret syscall将字符串中的字节“Hello1190202402李培意”从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 学习了linux中的I/O管理机制，以及其各类的函数的功能等。也对printf和getchar函数有了更多更新的研究。 （第8章1分） 结论 最终跟随着hello程序走完了它的一生，也从它的一生中，了解了计算机系统的种种内容。从开始，到结束，也是我们编写的代码的开始，到可能的将来的结束。但当下，一个hello结束了，我们还要有更多的程序，从编写，到交给系统，再到电脑硬件的执行，最后的结束回收，在这个过程中循环往复。赋能人类的生活。 1.预处理器将hello.c源代码经过初步的修改变成了hello.i文件。 2.编译器处理hello.i文件使之成为汇编代码并保存在hello.s文件中。 3.汇编器将hello.s文件处理成了可重定位的目标程序，也就是hello.o文件，这个时候，我们的程序离可以运行就只差一步了。 4.链接器将我们的hello.o与外部文件进行链接，终于我们得到了可以跑起来的hello文件了。 5.当我们在shell中运行hello程序时，内核会为我们分配好运行程序所需要的堆、用户栈、虚拟内存等一系列信息。使我们的hello程序能够正常的运行。 6.从外部对hello程序进行操控只需要在键盘上给一个相应的信号，hello程序就会按照我们的指令来执行。 7.在hello需要访问磁盘中的信息的时候，MMU会将程序中使用的虚拟内存地址通过页表映射成物理地址。 8.当hello执行结束，shell父进程回收子进程，内核删除为这个进程创建的所有数据结构，hello也就结束了它的一生。 （结论0分，缺失-1分，根据内容酌情加分） 附件 Hello.c C语言源文件 Hello.i 预处理后的文本文件 Hello.o 汇编之后的可重定位目标执行文件 Hello.s 编译后的文本文件 Hello 链接之后的可执行的目标文件 Elf hello.o的ELF Elf2 hello的ELF （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 
第454篇文章[]
test测试学习笔记 Softwaretesting （1）提高软件质量的重要手段 （2）确认是否达到用户需求 （3）关注系统的某一侧面的质量特性 当然也要注意，无论什么样的测试，质量有多高的测试，也无法达到100%的没有错误 （4）残留缺陷率（每一千行代码交付后留存的bug） 典型工业软件1-10defects/kloc 高质量的验证0.1-1defects/kloc（java库） 非常高的安全关键认证0.01-0.1defects/kloc(重要的航天控件等) （5）什么是高质量的测试 *能发现错误 *不冗余 *最佳的品类 *别太复杂也别太简单 （6）测试的等级 单元测试->集成测试->系统测试->验收测试 单元测试：验证特定代码部分功能的测试，功能级别 集成测试：多个程序员或者编程团队创建的两个/多个类、包等的组合执行 系统测试：测试一个完整集成的系统，是否满足要求，在最终配置中执行 回归测试：回到上一层级的测试。一旦程序被修改，重新执行之前的所有测试 （7）其他测试种类 略 （8）静态测试和动态测试 静态测试是隐式的，用编程工具和文本检查源代码结构和编译器 检查语法和数据流（用眼睛看） 动态测试可在程序未完成时候进行，测试特定的代码部分。 （9）测试和调试（debug） 测试：发现是否存在错误 调试，识别错误根源，根除错误。 （10）白盒测试和黑盒测试 白盒测试：对程序内部代码结构的测试，程序内部代码可见 黑盒测试：对程序外部表现出来的行为的测试，并不需要看到程序内部代码 testcase（测试用例） 1）测试用例={测试输入+执行条件+期望的结果} 2）写测试->组织测试用例->执行测试用例->获取状态和报告 3. 测试优先编程 1）先写spec->写符合spec的测试用例->写代码、执行测试、有问题再改、再执行。 2）先写测试会节省大量调试时间 3）test-drivendevelopment 在测试中完善。 4．Junit 1）assertEquals()期望值和运行值的比较 2）assertTrue() 3）assertFalse() 4）另外 注意@Test的标识，表示这是一个测试 5.黑盒测试 黑盒测试：检查代码的功能但不关心其内部结构 从规约（程序的规范和需求）出发 测试用例完全由spec导出 6.等价类划分和边界值分析方法 按输入域进行划分 对称，传递，自反 从数值范围，长度，要求等进行划分 主要是考虑边界问题，输入数据的特殊情况，进行边界值的分析方法 程序在边界可能发生一些“突变” 7.白盒测试 需要考虑内部的细节，俺炸程序执行的路径设计测试用例 对所有执行的路径进行等价类划分，找出代表性的最简单路径、每条基本路径至少覆盖一次 8.覆盖度 测试用例多大程度覆盖了被测程序，覆盖度越低，测试越不充分 路径＞分支＞语句（难度和效果） 测试策略：testingstrategy 
第455篇文章[]
spec简单例子 总是让我们写spec但是究竟该怎么写，那么我们通过例子来看。 比如我们碰到以下代码让我们对他写spec 例子 publicList<String>getSomeLines(intstart,intend){ List<String>some=newArrayList<>(); for(inti=start;i<end;i++){ some.add(lines.get(i)); returnsome; } } 方法getSomeLines（）返回诗的第start行到第end行的文本，我们需要针对该方法设计spec，充分考虑健壮性。 /** *@Paramstartstart需要大于等于0并且小于总行数 *@Paramendend需要大于start并且小于等于总行数 *@return返回从start行到end行之间的行列表 *@throwsNolines没有行抛出异常 *@throwsBoundExceptionstart和end不符合规范 */ 我们就可以根据代码写出如此的比较简单的spec。 
第456篇文章[1]
CS大作业论文 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190202408 班 级 1936601 学 生 闫广泽 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本篇主要通过对hello的一生进行探讨。通过对hello.c文件到进程被回收这个质朴却复杂的计算机系统运行过程进行解释和说明，来对计算机系统的运行加以解释和说明。主要针对程序的编译过程、进程管理、存储管理、IO管理进行研究和探讨。 关键词：P2P；020；程序的生命周期；进程； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 我是一个C语言程序，我每次都会在最后出现在屏幕上，我对我自己有简介： P2P：在Linux中，经过预处理、编译、再链接 P2P：首先从一个写好的源程序程序文件（Program）开始，GCC编译器的驱动程序读取它，依次通过预处理器cpp将其预处理为一个修改了的源程序，通过编译器ccl把它变成汇编程序，汇编器as把它转化为可重定位的目标程序，最后再由链接器ld将其变为可执行的目标程序。这时，在shell中运行它，OS（进程管理）会通过fork来为其创建一个新的进程（Process）。这便是P2P的过程。 020：首先，通过Editor编写出一个源程序hello.c，然后通过GCC编译器的驱动程序读取它，并依次经过预处理，编译，汇编，链接来生成一个可执行文件，然后再shell中输入执行它的指令，shell通过fork为其创建新的子进程，然后通过exceve在进程的上下文中加载并运行hello，把它映射到对应虚拟内存区域，并依需求载入物理内存，在CPU的帮助下，它的指令被一步步执行，实现它拥有的功能，在程序运行结束后，父进程会对其进行回收，内核把它从系统中清除，hello完成了它的一生，这便是020的过程。 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows1064位以上；Vmware11以上；Ubuntu16.04LTS64位 开发工具：GDB/OBJDUMP；EDB；gedit+gcc；CodeBlocks64位，gdb等。 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 hello.c源文件 hello.i预处理后的文件 hello.s编译后的汇编文件 hello.o汇编后的可重定位文件 hello链接后的可执行文件 hello.elfhello的elf文件 helloout.elfhello.o的elf文件 hello1.txtobjdumphello的反汇编文件 hello0.txtobjdumphello.o的反汇编文件 1.4本章小结 本章主要介绍了hello的P2P，020过程，以及进行实验时的软硬件环境及开发与调试工具和在本论文中生成的中间结果文件。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 （以下格式自行编排，编辑时删除） 预处理过程是整个编译过程的第一步，预处理输入的文件格式是c文件或者是h文件，经过预处理输出的就是i文件。在预处理过程中，预处理器会分析预处理指令（包括#include头文件和#define宏定义等）以及去除源代码中的注释。通常来说，编译器会直接将c文件编译成o文件，然后再去交给链接器链接为elf文件。如果希望通过命令行仅仅将c文件预处理成为i文件，只要在命令行中加上-E参数，就可以使编译器在预处理后停止下来，输出预处理后的源文件。 2.2在Ubuntu下预处理的命令 例如我们的命令行就是，gcc-Ehello.c-ohello.i，就会生成.i文件 hello.c截图 hello.i截图 2.3Hello的预处理结果解析 可以看到，相比较于hello.c的不到三十行代码，hello.i有3000多行代码，其实就是对源文件中的宏定义进行了展开，增加的代码就是宏定义解析的代码 2.4本章小结 本章节简单介绍了c语言在编译前的预处理过程，简单介绍了预处理过程的概念和作用，对预处理过程进行演示，并举例说明预处理的结果还有解析预处理的过程。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译器ccl将文本文件hello.i翻译成文本文件hello.s。它包含一个汇编语言程序。 作用：编译器做一些语法分析、词法分析、语义分析等，若检查无错误，便将高级程序设计语言（C语言）书写的程序转变为与其等价的汇编语言程序（可能依情况做一些优化），汇编语言是介于高级语言和机器语言之间的中间代码，它为不同高级语言的不同编译器提供了通用的输出语言，使他们产生的输出文件都是用的一样的输出语言。 3.2在Ubuntu下编译的命令 gcc-Shello.i-ohello.s hello.s 3.3Hello的编译结果解析 和刚才动辄3000行代码的.i文件不同，.s文件只有80多行，认真观察hello.s文本，发现他其实只翻译了hello.i中main函数及其周围的部分，头文件里面的内容他并没有翻译。 3.3.1汇编文件伪指令 这部分内容主要声明了源文件的名字（.file），代码段（.text），数据段（.data），全局变量及其大小（.globl，.size），指令及数据存放地址的对齐方式（.align）等文件信息。 3.3.2数据类型 我们可以查看hello.c 发现主要有以下几种类型： 1．常量 字符串型常量，汇编语言中，输出字符串作为全局变量保存。汇编文件hello.s中，共有两个字符串，均作为printf参数，如下图： 2.变量 定义了全局int型变量sleepsecs和局部int型变量i，argc。 其中sleepsecs在开头定义： .c文件中是这样的 .s文件中是 可以看到sleepsecs占用4字节空间并且保存在只读代码段rodata中，并且发生了隐式转换，因为在.c中是定义的sleepsecs是int型全局变量，但是赋值却是浮点型，所以编译器对2.5舍入得2 而i作为局部变量保存在栈中（运行）时，如下（下面为给i赋初值为0） argv也是如此： hello.c中，同时主要定义和使用了argv数组，而在hello.s中，通过以下代码可知 分析可知，argv[1]作为printf第二个参数，应当存于寄存器%rsi中，因此可推断argv[1]地址为-0x2A(%rbp)中，argv[2]作为printf函数的第三个参数，应当存于寄存器%rdx中，因此可推断argv[2]地址为-0x16(%rbp)；数组首地址位于-0x32(%rbp)，以上所占字节数为8。 3.3.3各类操作 1.赋值操作 如在for循环中，初始化局部变量i为0。在hello.s中，可以找到对应的操作，主要使用了数据传送指令，如下图： 在给printf传参数时，使用了加载有效地址指令，如下图： 2.类型转换操作 在前面我们已经介绍，这里不过多赘述 3.关系操作 在hello.c中使用了if语句，其中使用了关系操作，如下图 通过cmpl指令比较了argv与3的大小关系 4.控制转移操作 在hello.c中使用了if语句，那么紧接着就需要转移，当条件不满足时该怎样或者条件满足该怎样，如上，当比较argv和3相等的时候就会跳转到L2 5.算术操作 算术操作对应于hello.c中的i++ hello.s中对应以上操作 6.for循环操作 hello.c中的for循环对应于hello.s中的 使用了条状指令jle和关系操作指令cmpl实现了for循环操作。 7.函数操作。hello.c中调用了许多函数，如printf，exit，getchar，可以通过以下的指令实现，如下图printf的实现，通过过程调用指令call来实现函数操作，同时通过寄存器（如%rdi）来传递参数。 3.4本章小结 编译器将预处理后的文本进行汇编处理，对于常量，编译器将它储存到一个特定的位置，记录它的一些信息，比如类型；对于一些特定的常量，比如printf()函数中的信息，编译器会把它提取出来保存。程序中的语句，例如赋值语句，编译器通过寄存器，栈等结构进行赋值；分支语句用je,jle,jge等条件跳转语句进行实现。每种语句都有对应的实现方法。程序中的函数，如果不是库函数，则会对函数进行逐句的语法分析和解析，如果是标准的库函数，编译器可以直接用call语句进行调用。 汇编语言相对于高级语言来说，它更加靠近底层机器且直接面对硬件的，所以也为高级语言提供了一种统一的面向机器的解释，它具有一些助记符，所以比直接的机器语言好理解，但相对于高级语言又显得难以掌握。汇编语言具有：机器相关性，高速度和高效率，编写和调试的复杂性等特性。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：汇编器as将hello.s翻译成机器语言指令，把这些指令打包成一种叫可重定位目标程序的格式，并将结果保存在目标文件hello.o中。（hello.o是一个二进制文件）。 作用：把汇编语言翻译成机器语言，用二进制码代替汇编语言中的符号，即让它成为机器可以直接识别的程序。 4.2在Ubuntu下汇编的命令 gcc-chello.s-ohello.o 4.3可重定位目标elf格式 使用readelf查看hello.o： 分析.elf文件中的内容： 分析.elf文件中的内容： ELF头：ELF头（ELFheader）以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含了帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是有节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry）。 节头：记录各节名称、类型、地址、偏移量、大小、全体大小、旗标、链接、信息、对齐。 重定位节：.rela.text，保存的是.text节中需要被修正的信息；任何调用外部函数或者引用全局变量的指令都需要被修正；调用外部函数的指令需要重定位；引用全局变量的指令需要重定位；调用局部函数的指令不需要重定位；在可执行目标文件中不存在重定位信息。本程序需要被重定位的是printf、puts、exit、sleepsecs、getchar、sleep和.rodata中的.L0和.L1。 .rela.eh_frame节是.eh_frame节重定位信息。 符号表：.symtab，一个符号表，它存放在程序中定义和引用的函数和全局变量的信息，一些程序员错误地认为必须通过-g选项来编译一个程序，才能得到符号表信息。实际上每个可重定位目标文件在.symtab中都有一张符号表（除非程序员特意用STRIP命令去掉它）。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。 具体内容： 1.ELF头 由图可知，ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 2.重定位节'.rela.text' 节头部表描述了不同节的位置与大小，并且目标文件的每个节都有一个固定大小的条目，其中记录了各节名称、类型、地址、偏移量、大小、全体大小、旗标、连接、信息、对齐信息。 由图可知'.rela.text'是一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。如图4.4，图中8条重定位信息分别是对.L0（第一个printf中的字符串）、puts函数、exit函数、.L1（第二个printf中的字符串）、printf函数、sleepsecs、sleep函数、getchar函数进行重定位声明。 其中偏移量为需要进行重定向的代码在.text或.data节中的偏移位置，信息包括symbol和type两部分，其中symbol占前4个字节，type占后4个字节，symbol代表重定位到的目标在.symtab中的偏移量，type代表重定位的类型，类型代表重定位到的目标的类型，符号名称和加数则指出了重定向到的目标的名称计算重定位位置的辅助信息。 3.重定位节'.rela.eh_frame' '.rela.eh_frame'包含了eh_frame节的重定位信息。 符号表 .symtab存放着程序中定义和引用函数和全局变量的信息。且不包含局部变量的条目。重定位需要引用的符号都在其中声明。 4.4Hello.o的结果解析 hello.s的内容 hello.o反汇编的内容 比较来看hello.s和hello.o操作数赖看hello.s是十进制，hello.o是十六进制，其中的内容其实大部分是差不太多的，但是左半边hello.o多了很多东西。有前面的机器指令的位置，以及后面的对应每一行汇编语句的机器指令，显然这是给机器读的以为机器是二进制实现的，0和1构成，方便查看所以使用十六进制 4.4.1分支跳转语句 对比来看，不难发现，在hello.s文件中，跳转到的位置都是用.L3/.L4等来进行表示的，但是在hello.o中，跳转目标位置是由确实的地址来表示的。 4.4.2函数调用 hello.s的函数调用是通过使用call+函数名，比如callgetchar@PLT而在hello.o中是call+地址，例如callq7e<main+0x7e>指的是相对于main函数的地址偏移量为7e的函数位置。 4.5本章小结 汇编器对hello.s文件进行汇编，生成了可重定位文件。对文件的全局变量，函数，程序语句都进行了分析，给出了初始的相对位置信息，相当于对整个文件做出了一个初始的整理，为后面的链接等操作做准备。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器的程序自动执行的。 链接的作用： 链接在软件开发中扮演着一个关键的角色，因为它们使得分离编译成为可能。链接能将各种代码和数据片段收集并组合成为一个单一文件，即链接多个目标文件成一个可执行文件。 在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 命令： 5.3可执行目标文件hello的格式 使用readelf来查看hello： ELF的各个作用 1.ELF头：描述文件的总体格式 2.段头部表：将连续的文件映射到运行时的内存段。 3…init节：定义了一个_init函数，程序的初始化代码会调用它。 4…text节：已编译程序的机器代码。 5…rodata节：只读数据，比如printf语句中的格式串和开关语句的跳转表 6…data节：已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中。 7…bss节：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。 8…symtab节：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。 9…debug节：一个调试符号表，其条目是程序中定义的全局变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。 10…line节：原始C源程序的行号和.text节中机器指令之间的映射 11…strtab节：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。 12.节头部表：描述目标文件的节。 首先来看ELF头 我们可以看到sectionheaders节头表有27个 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 5.4hello的虚拟地址空间 在edb的DataDump一栏中可以看到程序的虚拟地址。 代码段开始于0x400000处，程序被载入，然后查看elf文件里面的programheaders，程序头表在执行时被使用，它负责提供链接器加载的内容并提供动态链接的信息分析elf里面的ProgramHeaders： PHDR：程序头表 INTERP：程序执行前需要调用的解释器 LOAD：程序目标代码和常量信息 DYNAMIC：动态链接器所使用的信息 NOTE:：辅助信息 GNU_EH_FRAME：保存异常信息 GNU_STACK：使用系统栈所需要的权限信息 GNU_RELRO：保存在重定位之后只读信息的位 其余的从.dynamic到.strtab节的内容是存放在0x00400fff后面 5.5链接的重定位过程分析 hello的objdump hello.o的objdump 可以明显看出来可执行文件对每个函数给出了重定位处理，给出了它们的绝对物理地址；而在hello.o中，只是给出了每个函数对于程序首地址的偏移地址。 通过上面两个文件，可以了解到链接实现的过程：将可重定位文件中的.text节中函数以及全局变量的相对地址转变为了绝对地址，全局变量的寻址方式0x0%rsp也将0x0改为了确定的地址。 对hello.中的重定位节中的定位：在hello.o中，给出了函数和全局变量相对于EIF头的偏移量，所以在链接后，给定了程序首地址，然后根据偏移量，计算出函数和全局变量的绝对地址 链接主要分为两个过程：符号解析和重定位。 1）符号解析：目标文件定义和引用符号，符号解析将每个符号引用和一个符号定义关联起来。 2）重定位：编译器和汇编器生成从0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。 对于hello来说，链接器把hello中的符号定义都与一个内存位置关联了起来，重定位了这些节，并在之后对符号的引用中把它们指向重定位后的地方。hello中每条指令都对应了一个虚拟地址，而且对每个函数，全局变量也都它关联到了一个虚拟地址，在函数调用，全局变量的引用，以及跳转等操作时都通过虚拟地址来进行，从而执行这些指令。 5.6hello的执行流程 在main函数之前执行的函数有： _start; _libc_start_main@plt; __libc_csu_init; _init; frame_dummy; register_tm_clones; 在main函数之后执行的程序有： Exit(); cxa_thread_atexit_impl; fini; 5.7Hello的动态链接分析 在进行动态链接前，首先进行静态链接，生成部分链接的可执行目标文件hello。此时共享库中的代码和数据没有被合并到hello中。加载hello时，动态链接器对共享目标文件中的相应模块内的代码和数据进行重定位，加载共享库，生成完全链接的可执行目标文件。 动态链接采用了延迟加载的策略，即在调用函数时才进行符号的映射。使用偏移量表GOT+过程链接表PLT实现函数的动态链接。GOT中存放函数目标地址，为每个全局函数创建一个副本函数，并将对函数的调用转换成对副本函数调用。 调用init之前的.got.plt 调用init之后的.got.plt 5.8本章小结 通过本章了解了c语言的链接过程，明白了链接的概念及作用，学会了GCC下链接操作对应的指令，并学会了查看hello运行时的虚拟地址空间，了解了hello的重定位过程，对hello的执行流程有了一定的了解，同时对hello的动态链接过程进行了分析。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：进程的经典定义是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的代码和数据，它的栈、通用目的寄存器中的内容、程序计数器、环境变量和打开文件描述符的集合。进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 作用：在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 6.2简述壳Shell-bash的作用与处理流程 作用：shell是命令行界面，是系统内核的一层壳,作用是用来保护内核同时传递入与计算机交互的信息.它只是系统的一个工具,我们可以使用它来操作计算机。 处理流程： 从终端读入输入的命令。 Shell对用户输入命令进行解析，判断是否为内置命令。 如果是内置命令则立即调用内置命令处理函数，否则调用execve函数创建一个子进程进行运行。 判断是否为前台运行程序，如果是，则调用等待函数等待前台作业结束；否则将程序转入后台，直接开始下一次用户输入命令。 shell应该接受键盘输入信号，并对这些信号进行相应处理。 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的运行的子进程。调用fork函数后，新创建的子进程几乎但不完全与父进程相同:子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本（包括代码、数据段、堆、共享库以及用户栈），子进程获得与父进程任何打开文件描述符相同的副本，这意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。fork被调用一次，却返回两次,子进程返回0，父进程返回子进程的PID。子进程有不同于父进程的PID。 6.4Hello的execve过程 execve函数加载并运行可执行目标文件，且带参数列表argv和环境变量列表envp。它在加载文件后，调用文件的启动代码，加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。 6.5Hello的进程执行 在获取程序进程ID（PID）之后，hello等待被内核执行，内核为hello保存一个上下文，这个上下文包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构（比如页表、进程表、文件表）等等。 Execve函数在当前进程的上下文中加载并运行一个新程序，当hello在内核中运行的时候，并行的也有其他进程，一个进程执行它的控制流的一部分的每一时间段叫做时间片，所以内核可以控制到底是否需要枪战当前进程，并重新开始一个先前被挂起的进程或者别的进程，这个过程成为调度。 在此前提下，hello程序与操作系统其他的进程通过内核的调度，切换上下文，并行地完成进程。当程序在完成一些操作的时候，例如调用一些系统函数，访问一些系统参数，当前程序需要核心权限，这时候就要让程序从用户态转变为核心态，通过信号函数的作用完成这个转换。 6.6hello的异常与信号处理 hello执行过程中出现的异常种类可能会有：中断、陷阱、故障、终止。 乱按和空格： 这都不会影响程序输出，因为乱按只是将屏幕的输入缓存到stdin，当getchar的时候读出一个’\n’结尾的字串（作为一次输入），其他字串会当做shell命令行输入。 运行时输入Ctrl-Z 可以看到输入Ctrl-Z后，hello进程停止了，原因是shell父进程收到SIGSTP信号，信号处理函数的逻辑是打印屏幕回显、将hello进程挂起。 输入ps命令查看PID 可以看到我们的hello进程被挂起，PID为27094 输入jobs命令： 可以看到hello进程的job号为1 pstree命令是查看进程树 输入fg指令后： 程序会继续运行。 kill命令 运行时输入Ctrl-C 可以看到输入Ctrl-C，hello进程终止了，原因是当按下ctrl-c之后，shell父进程收到SIGINT信号，信号处理函数的逻辑是结束hello，并回收hello进程。 6.7本章小结 在本章中，我们首先总结了进程的概念与作用，然后我们完整地分析并实践了hello程序是如何从头到尾运行的，并分析了可能出现的异常与信号处理，做出总结。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：又称相对地址，是程序运行由CPU产生的与段相关的偏移地址部分。他是描述一个程序运行段的地址。 物理地址：程序运行时加载到内存地址寄存器中的地址，内存单元的真正地址。他是在前端总线上传输的而且是唯一的。在hello程序中，他就表示了这个程序运行时的一条确切的指令在内存地址上的具体哪一块进行执行。 虚拟地址：使用虚拟寻址时，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送至内存前先转换成适当的物理地址。虚拟地址转化成物理地址的过程叫做地址翻译。在linux中，虚拟地址数值树等于线性地址，即hello中看到的地址加上对应段基地址的值。 线性地址：这个和虚拟地址是同一个东西，是经过段机制转化之后用于描述程序分页信息的地址。他是对程序运行区块的一个抽象映射。” 7.2Intel逻辑地址到线性地址的变换-段式管理 在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值(index)。 一个逻辑地址由两部份组成，段标识符:段内偏移量。 首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]， 1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再依据对应寄存器，得到其地址和大小。我们就有了一个数组了。 2、拿出段选择符中前13位，能够在这个数组中。查找到相应的段描写叙述符，这样。它了Base。即基地址就知道了。 3、把Base+offset，就是要转换的线性地址了。 7.3Hello的线性地址到物理地址的变换-页式管理 线性地址即虚拟地址，用VA来表示。VA被分为虚拟页号（VPN）与虚拟页偏移量（VPO），CPU取出虚拟页号，通过页表基址寄存器（PTBR）来定位页表条目，在有效位为1时，从页表条目中取出信息物理页号（PPN），通过将物理页号与虚拟页偏移量（VPO）结合，得到由物理地址（PPN）和物理页偏移量（PPO）组合的物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 36位VPN被划分成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含Ll页表的物理地址。VPN1提供到一个LlPET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 Corei7是四级页表进行的虚拟地址转物理地址。48位的虚拟地址的前36位被分为四级VPN区。结合存放在CR3的基址寄存器，由前面多级页表的知识，可以确定最终的PPN，与VPO结合得到物理地址。 7.5三级Cache支持下的物理内存访问 首先取组索引对应位，向L1cache中寻找对应组。如果存在，则比较标志位，并检查对应行的有效位是否为1。如果上述条件均满足则命中。否则按顺序对L2cache、L3cache、内存进行相同操作，直到出现命中。然后向上级cache返回直到L1cache。如果有空闲块则将目标块放置到空闲块中，否则将缓存中的某个块驱逐，将目标块放到被驱逐块的原位置。 7.6hello进程fork时的内存映射 在shell输入命令行后，内核调用fork创建子进程，为hello程序的运行创建上下文，并分配一个与父进程不同的PID。通过fork创建的子进程拥有父进程相同的区域结构、页表等的一份副本，同时子进程也可以访问任何父进程已经打开的文件。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同，当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： （1）删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 （2）映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 （3）映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 （4）设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障是一种常见的故障，当指令引用一个虚拟地址，在MMU中查找页表时发现与该地址相对应的物理地址不在内存中，因此必须从磁盘中取出的时候就会发生故障。 缺页中断处理：缺页处理程序是系统内核中的代码，选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送VA到MMU，这次MMU就能正常翻译VA了。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆(heap)。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块(block)的集合来维护。每个块就是一个连续的虚拟内存片(chunk),要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 基本方法：这里指的基本方法应该是在合并块的时候使用到的方法，有最佳适配和第二次适配还有首次适配方法，首次适配就是指的是第一次遇到的就直接适配分配，第二次顾名思义就是第二次适配上的，最佳适配就是搜索完以后最佳的方案，当然这种的会在搜索速度上大有降低。 策略：这里的策略指的就是显式的链表的方式分配还是隐式的标签引脚的方式分配还是分离适配，带边界标签的隐式空闲链表分配器允许在常数时间内进行对前面块的合并。这种思想是在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。显式空间链表就是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个前驱和后继指针，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。为了分配一个块，必须确定请求的大小类，并且对适当的空闲链表做首次适配，查找一个合适的块。如果找到了一个，那么就（可选地）分割它，并将剩余的部分插入到适当的空闲链表中。如果找不到合适的块，那么就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。如果空闲链表中没有合适的块，那么就向操作系统请求额外的堆内存，从这个新的堆内存中分配出一个块，将剩余部分放置在适当的大小类中。要释放一个块，我们执行合并，并将结果放置到相应的空闲链表中。 7.10本章小结 本章介绍了储存器的地址空间，讲述了虚拟地址、物理地址、线性地址、逻辑地址的概念，还有进程fork和execve时的内存映射的内容。描述了系统如何应对那些缺页异常，最后描述了malloc的内存分配管理机制（C语言为例）。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m字节的序列。所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。这使得所有输入和输出都能以一种统一且一致的方式来执行： 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。 2.LinuxShell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出、标准错误。 3.改变当前文件的位置。对于每个打开的文件，内核保持着一个文件位置k、初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显示地设置文件的当前位置为k。 4.读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 5.关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。 8.2简述UnixIO接口及其函数 Linux提供如下IO接口函数： （1）read和write：最简单的读写函数； （2）readn和writen：原子性读写操作； （3）recvfrom和sendto：增加了目标地址和地址结构长度的参数； （4）recv和send：允许从进程到内核传递标志； （5）read和writev：允许指定往其中输入数据或从其中输出数据的缓冲区； （6）recvmsg和sendmsg：结合了其他IO函数的所有特性，并具备接受和发送辅助数据的能力。 8.3printf的实现分析 int printf(constcharfmt,…) { inti; char buf[256]; va_listarg =(va_list)((char)(&fmt)+4); //arg是一个指针，表示的是被省略参数中的第一个参数。 i= vsprintf(buf,fmt,arg); //vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt（输入）。//用格式字符串对个数变化的参数进行格式化，产生格式化输出。 write(buf, i);//接受buf与需要输出的参数个数， //执行写操作，把buf中的i个元素的值写到终端 returni; } 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 int getchar(void) { charc; return (read(0,&c,1)==1)?(unsignedchar)c:EOF //read函数的第一个参数是描述符fd，0代表标准输入 //第二个参数是输入内容的指针，这里是所读取字符的地址 //最后一个参数等于1表示读入字符数为1 } 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 hello进程需要I/O设备的信号来正确执行，而Unix通过将设备映射为文件来管理I/O设备。 printf()和getchar()函数通过调用vprintf()函数处理传入的参数，调用write()函数将数据提交给操作系统，然后操作系统通过管理硬件最后实现终端显示。 （第8章1分） 结论 1、首先有高级语言产生的hello.c文件 2、经过预处理后，hello.c进行了宏替换并且还将库函数.h文件等添加进入文件生成了hello.i 3、再通过编译器编译产生hello.s，变成了汇编语言。 4、再通过汇编器产生了hello.o，变成了可重定位文件。 5、通过链接器，将其他可重定位的文件写入进来变成hello可执行文件。 6、在shell中按要求输入并执行该可执行文件，shell会先fork一个子进程然后execve，加载运行hello。 7、创建了虚拟内存空间，并映射到物理内存。 8、在sleep函数时会发生异常，然后上下文切换。 9、printf函数会使用malloc函数申请堆空间，使用到动态内存管理技术。 10、printf函数会使用IO设备管理进行输出。 11、最后，进程结束被回收。Hello结束。 感想：感觉这门课虽然要结束了，但是要去学的东西还有很多很多，很多地方只是了解了大概，底层东西还是不太清楚，学海无涯，以前总是关注表面的东西，但是这常常导致编程错误，但是在学习了计算机系统之后，通篇读完这本书，包括写完这个大作业，对系统的整体等等有了更深的认识，明白了许多当时犯下的错误是因为什么，明白了做任何事不能在上面人云亦云，就像hello的一生，简单平凡，需要在底层，明白如何完成的，才知道自己该干什么不该干什么。hello的一生到此就结束了，但是我们的学习生涯才算刚刚开始，加油！ （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.c源文件 hello.i预处理后的文件 hello.s编译后的汇编文件 hello.o汇编后的可重定位文件 hello链接后的可执行文件 hello.elfhello的elf文件 helloout.elfhello.o的elf文件 hello1.txtobjdumphello的反汇编文件 hello0.txtobjdumphello.o的反汇编文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 
第457篇文章[]
JAVA异常处理 在上一个博客里面我们有涉及到类似下面的句式，那么它究竟是干什么的以及怎么用。 try{   }catch(Exceptione) {   } 下面我们来探讨一下： 作为看这篇博客的你来讲，代码肯定是很熟悉的东西了，并且人为操作的东西总是有漏洞，体现在代码上面就是异常，错误等。 为此Java提供了异常处理机制来帮助我们检查可能出现的错误。 假设我们运行以下代码： publicclasstest{ publicstaticvoidmain(String[]args){ intresult; result=1/0; System.out.println(result); } } 那么程序就会出现下面的异常，不能正常运行 其中他说的是ArithmeticException：/byzero直接描述给我们是因为在算术表达式中1/0 0作为除数出现，这不符合我们正常的算术表达式，不能继续执行，异常提前退出。 为了保证能够让程序有效的进行，我们需要对发生的异常进行相应的处理。因为当异常产生之后，如果不做任何处理的情况下，程序就会把被终止。 publicclasstest{ publicstaticvoidmain(String[]args){ Stringstr=newString("csdnyyds"); System.out.println(str); intcode_age=Integer.parseInt(str); System.out.println(code_age); } } 再假设我们运行上面的例子，我们已知Integer.parseInt是将非字符型转换为int型，匹配我们定义的code_age。但是运行之后程序会出现以下异常： 和上一次不同，这次报出的是NumberFormatException也就是字符转数字异常。执行转换代码的时候异常终止。 既然我们已经知道了报出异常，那么如何捕捉异常呢？ 这就涉及到我们本次主要介绍的东西 try{   }catch(Exception1e){ 对Exception1的处理 } catch(Exception2e){ 对Exception2的处理 }   finally{ 程序块 } 那么我们把刚才的代码套入trycatch里面 publicclasstest{ publicstaticvoidmain(String[]args){ try{ Stringstr=newString("csdnyyds"); System.out.println(str); intcode_age=Integer.parseInt(str); System.out.println(code_age); }catch(Exceptione){ e.printStackTrace(); } System.out.println("程序执行完毕"); } } 运行结果如下： 虽然还是会报错但是我们的程序不会停止运行。 当在try里面遇到会报错的代码的时候，编译器就会自动去catch里面运行，运行完catch里面之后继续运行接下来的代码也就是System.out.println("程序执行完毕");这不会导致程序因为异常而终止。 另外finally语块是完整的try-catch不可缺少的，无论是否执行try-catch是否顺利执行，都会执行fanally。 抛出异常： 有throws和throw两种方法 //已知代码会发生负数数组异常的前提下我们可以： publicclasstest{ staticvoidpop()throwsNegativeArraySizeException{ int[]array=newint[-10]; } publicstaticvoidmain(String[]args){ try{ pop(); }catch(NegativeArraySizeExceptione){ System.out.println("pop()方法抛出异常"); } } } 运行结果如下： 我们定义了一个负数数组，但是我们可以通过throws关键字抛出异常，不让我们看到异常语句。 另外throw一般用于方法体中，程序在执行到throw语句的时候立刻终止，后面语句不再执行。感兴趣的童鞋可以搜索查看哦 
第458篇文章[1]
汇编语言小汇总（1） 对于初学者而言，汇编语言晦涩难懂，所谓万事开头难。 初学者寻找汇编以及反汇编指令有些困难。 例如在linux下 我们可以使用Linux命令行，对于mstore.c 可以使用linux>gcc-Og-Smstore.c，使用“-S”，就会给编译器指令产生汇编文件。 如果我们使用“-c”选项，GCC就会编译并汇编该代码。 linux>gcc-Og-cmstore.c 另外，反汇编器的程序也很有用，在Linux中带“-d”命令行标志程序OBJDUMP("表示objectdump")可以充当这个角色。 linux>objdump-dmstorc.o --------------------------------------------- 以下为部分汇编语言总结 --------------------------------------------- C语言数据类型在x86-64中的大小。在64位机器中，指针长8字节 C声明Intel数据类型汇编代码后缀大小（字节）char字节b1short字w2int双字l4long四字q8char*四字q8float单精度s4double双精度q8 操作数的格式 类型格式操作数值名称立即数$ImmImm立即数寻址寄存器r1R[r1]寄存器寻址存储器ImmM[Imm]绝对寻址存储器(r1)M[R[r1]]间接寻址存储器Imm(r1)M[Imm+R[r1]](基址+偏移量)寻址存储器(r1,r2)M[R[r1]+R[r2]]变址寻址存储器Imm(r1,r2)M[Imm+R[r1]+R[r2]]变址寻址存储器(,r1,s)M[R[r1]*s]比例变址寻址存储器Imm(,r1,s)M(Imm+R[r1]*s)比例变址寻址存储器(r1,r2,s)M(R[r1]+R[r2]*s)比例变址寻址存储器Imm(r1,r2,s)M(Imm+R[r1]+R[r2]*s)比例变址寻址 下期更新汇编小汇总（2）包括数据传送指令，条件码，控制等。 
第459篇文章[]
Java的继承 类的继承 类的继承，在我理解中有点类似父进程和子进程。 首先继承的基本思想就是基于某个父类进行扩展，得到一个新的子类，子类可以继承父类原有的属性和方法，相应地，也可以增加原来父类所不具有的属性和方法，或者直接重写父类中的方法。 举个例子，例如正方形，是特殊的四边形，因为正方形是四个边都相等的四边形，可以说正方形继承了四边形类。这时，正方形继承了平行四边形所有具有的属性和方法，以及可以基于四边形类所增加的新的平行四边形类的属性和方法。 举例： publicclassTest{ publicTest(){//构造方法 //something.. } protectedvoiddoSomething(){//成员方法 //something.. } protectedTestdolt(){//方法返回值类型为Test类型 returnnewTest(); } } classTest2extendsTest{//继承父类 publicTest2(){//构造方法 super();//调用父类构造方法 super.doSomething();//调用父类成员方法 } publicvoiddoSomethingnew(){//新增方法 //something.. } publicvoiddoSomething(){//重写父类方法 //somenewsentence.. } protectedTest2dolt(){//重写父类方法，方法返回类型为Test2类型 returnnewTest2(); } } 该例子中定义了两个类，其中Test2类继承Test类，可以说Test类为Test2类的父类，Test2为Test的子类。在子类中可以连同初始化父类构造方法来完成子类初始化操作，既可以在子类的构造方法中用super()语句调用父类的构造方法，也可以在子类中使用super关键字调用父类的成员方法等。但是对于父类中的private方法，子类没有权限调用它，只可以调用父类中修饰符为public或者protected的成员方法。例如子类构造方法中可以使用super关键字调用父类的doSomething()方法，因为doSomething方法修饰符为protected。同时在子类中也可以定义一些新的方法，如子类的doSomethingnew（）方法。 继承并不只是扩展父类的功能，还可以重写父类的成员方法。重写还可以成为覆盖，就是在子类中讲父类的成员方法的名称保留，重写成员方法的实现内容，更改成员方法的存储权限，或是修改成员方法的返回类型。 在继承中还有一种特殊的重写方式，子类与父类的成员方法返回值，方法名称，参数类型及个数完全相同，唯一不同你的就是方法实现内容，这种特殊重写方式被称为重构。 publicclassParent{ Parent(){ System.out.println("调用父类的Parent()构造方法"); } } classSubParentextendsParent{ SubParent(){ System.out.println("调用子类的SubParent()构造方法"); } } publicclassSubroutineextendsSubParent{ publicSubroutine(){ System.out.println("调用子类的Subroutine()构造方法"); //TODO自动生成的构造函数存根 } publicstaticvoidmain(String[]args){ Subroutines=newSubroutine(); } } 创建Subroutine类和两个父类，分别为Parent和SubParent。这三个类的继承关系是Subroutine类继承Subparent类，而Subparent类继承Parent类。分别在这三个类的构造方法中输出构造方法名称来验证继承关系。 Eclipse输出如下 调用父类的Parent()构造方法 调用子类的SubParent()构造方法 调用子类的Subroutine()构造方法 运行结果可以看出，在子类Subroutine的主方法中只调用子类的构造方法实例化子类对象，并且在子类构造方法中没有调用父类构造方法的任何语句，但是在实例化子类对象时它相应调用了父类的构造方法。在这个结果中可以看到调用构造方法的顺序，首先是顶级父类，然后是上一级父类，最后才是子类。也就是说，实例化子类对象时首先要实例化父类对象，然后在实例化子类对象，所以在子类构造方法访问父类的构造方法去，父类已经完成实例化操作。 
第460篇文章[]
Java类与类的构造方法以及this关键字 类 构造一个类我们需要设定 权限修饰符返回值类型方法名(参数类型参数名) {  //方法体 return返回值; } 一个成员方法可以有参数，这个参数可以是对象，也可以是基本数据类型的变量，同时成员方法有返回值和不返回任何值的选择，如果需要返回值，就需要在方法体中使用return关键字，return之后这个方法执行就会被终止。 但是注意返回值一定要与成员方法的返回值类型一样。 权限修饰符： 访问包位置privateprotectedpublic本类可见可见可见同包其他类或子类不可见可见可见其他包的类或子类不可见不可见可见 默认访问权限： 当我们创建如下没有权限修饰符的类时： classAnything{ publicvoiddoEverything(){ ..//方法体 } } 默认修饰符，就是只有一个包内的其他类和子类可以对该类进行访问，而AnyClass类中的doEverything方法被修饰为public权限，但它会跟从Anything的权限。Java语言规定，类的权限设定会约束类成员的权限设定，所以即使把public换成任何诸如private或者没有，效果都是一样的。 this关键字 最开始学的时候对这个this关键字很不熟悉，不知道到底在指代什么。 那么我在此举几个例子 privatevoidsetName(Stringname){ this.name=name; } 一般而言，类似这种定义我们会发现两个name一个是全局变量，一个是形参，那么当我们想要修改全局变量的时候我们不清楚究竟有没有改变全局变量，因为往往我们都希望通过参数来改变全局变量。 再看另一种用法 publicBookgetBook(){ returnthis;//返回Book类引用 } 此时的应用就是方法的返回值。 类的构造方法： 构造方法的特点：构造方法没有返回值，构造方法的名称要与本类的名称相同。 publicbook(){  //构造方法体 } book是方法的名称 例子： publicclassAnything{ publicAnything{ this("this调用有参构造方法");//定义无参构造方法 System.out.println("无参构造方法");//使用this调用有参构造方法 } publicAnything(Stringname){ System.out.println("有参构造方法");//定义有参构造方法 } } 看倒定义了两个构造方法，在无参构造方法中可以使用this关键字调用有参的构造方法。但使用这种方式需要注意的是只可以在无参构造方法中的第一句使用this调用有参构造方法。 
第461篇文章[]
JAVAI/O流File操作 众所周知java语言提供给程序员非常多的包供编程时使用，方便又快捷。 I/O流也如此，在Java中这些类被放在java.io包里面，所以我们想要开始使用I/O就先把java.io填进去。 一.I/O （1）输入流 首先介绍输入流，介绍输入流就要先了解InputStream类，它是字节输入流的抽象类，是所有字节输入流的父类。比如它包括AudioInputStream，ByteArrayInputStream，StringBufferInputStream等等，其中这类方法遇到错误的时候都会引发IOException异常。 该类中，有以下一些方法： read()：从输入流中读取数据的下一个字节，并且返回0-255范围内的int字节值。如果到达了流末尾而没有可用的字节，则返回-1。 read(byte[]b):从输入流中读入一定长度的字节，并以整数的形式返回字节数。 mark(intreadlimit):在输入流的当前位置放置一个标记，readlimit参数告知此输入流在标记位置失效之前允许读取的字节数。 reset()：将输入指针返回到当前所做的标记处。 close()：关闭此输入流并且释放与该流关联的所有系统资源。 由于Java中的字符是Unicode编码，双字节，InputStream是用来处理字节的，并不适合处理字符串。所以Java为了字符输入提供了单独的类也就是Reader。相应的Reader类是字符输入流的抽象类，所有字符输入流的实现都是它的子类。Reader类与InputStream类中的方法类似，在此不进行赘述，感兴趣的可以去JDK文档自行查询。 （2）输出流 想对比与InputStream，输出流当然是OutputStream。 OutputStream类是字节输出流的抽象类，同样OutputStream类中也包含了很多方法，其中所有方法的返回值均为void，均返回void。在遇到错误的时候也会引发IOException异常。 下面简要介绍几个子类： write(intb)（//对应于read，方便好记）：将指定的字节写入这个输出流。 write(byte[]b):将b个字节从指定的byte数组写入此输出流。 write(byte[]b,intoff,intlen)方法：将指定byte数组中从偏移量off开始的len个字节写入此输出流。 flush()：彻底完成输出并且清空缓存区。 close()：关闭输出流。 二.File操作 （1）文件的创建与删除 Java中提供了File类创建文件对象，通常情况下使用以下三种。 File(Stringname) 其中name指的是文件的路径名字，例如，我们想要创建一个新的File对象，我们可以 Filefilename=newFile("c:/java1.txt"); File(Stringparent,Stringchild) 该方法根据父路径来创建一个新的File对象 Filefile=newFile("C:","java1.txt"); File(Filef,Stringchild) 与上面类似，只不过前面的paret变成了File类型，所以我们需要换一种构造方式。 Fileparent=newFile("c:"); Filefile=newFile(parent,"java1.txt"); 当然每次进行newFile不妨考虑到会不会有该文件或者是直接创建问题。那么我们可以看下面代码如何解决。 publicclassTest{ publicstaticvoidmain(String[]rags){ Filefile=newFile("java1.txt"); if(file.exists()){ file.delete(); System.out.println("文件删除"); } else{ try{ file.createNewfile(); System.out.println("文件创建好了"); }catch(Exceptione){ e.printStackTrace(); } } } } 可以看到这里面有关于文件异常的操作，trycatch，另外我们还调用了delete和exists，分别是当我们创建了文件java1.txt时候，判断如果该文件存在，那我们进行delete操作，并且输出提示，else否则如果文件不存在那么我们进行文件创建，createNewfile，并且输出提示。 下面在最后简单进行一下File包含常用的方法的小汇总： 方法返回值说明getName()String获取文件的名称canRead()boolean判断文件是否可读canWrite()boolean判断文件是否可以被写入exits()boolean判断文件是否存在length()long以字节位单位获取文件长度getAbsolutePath()String获取文件的绝对路径getParent()String获取文件的父亲路径isFile()boolean判断文件是否存在isDirectory()boolean判断文件是否为一个目录isHidden()boolean判断文件是否为隐藏文件lastModified()long获取文件最后修改时间 好了，本次介绍就到此结束了，下次再见，拜拜！ 
第462篇文章[]
如何对HashMap进行排序 问题描述 这个问题从字面上看会有点奇怪，毕竟HashMap是按哈希值存储元素的，每个元素的位置是固定的，所以无法像list一样可以通过索引值list.get(i)去获取元素，由于位置由哈希值确定，也谈不上排序。但是，问题就在于确实会遇到一些情形，比如我定义了一个map对象 Map<Student,Integer>map=newHashMap<>(); map是由学生类作为key，整型类作为value的，我的toString函数里面，希望它能够按照Integer（实际意义为分数）的大小进行排序，并返回一个按顺序排列的字符串。 比如下面这个map Map<Student,Integer>map=newHashMap<>(); Studenta=newStudent("a"); Studentb=newStudent("b"); Studentc=newStudent("c"); map.put(a,78); map.put(c,60); map.put(b,99); 打印map.toString()的结果 {[Studentname:a]=78,[Studentname:b]=99,[Studentname:c]=60} 既不是按照插入顺序，也不是按照我们预期的value大小顺序排列。所以说直接returnmap.toString()肯定是不行的，那我怎么能够构造一个字符串表示map，而且是按value大小排列的呢？ 解决方案 方法①首先网上有一些大佬的博客都介绍了用Java8的Streams进行排序，比如： map.entrySet().stream().sorted((e1,e2)->e1.getValue().compareTo(e2.getValue())).forEach(System.out::println); 输完这行代码，然后直接运行，就会神奇地发现控制台打印出了按value顺序排列的map然而，这种方法虽然很舒服，但是不能解决我的这个所面临的问题，它不能变成一个可返回的字符串，而是直接打印了出来。 方法②仍然使用Java8的Streams进行排序，同时借助了LinkedHashMap Map<Student,Integer>sortedMap=map.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors .toMap(Map.Entry::getKey, Map.Entry::getValue, (e1,e2)->e1, LinkedHashMap::new)); 这时候，我们打印一下sortedMap Strings=sortedMap.toString(); System.out.println(s); 输出结果：这方法也很舒适，直接调用内置方法，就可以排序了，而且只需改一下参数就能按key排序或者是降序排序，十分快捷。 但是，有时候人就比较作，或者面临的情况很specific，比如说，我不希望这个返回的字符串是xx(Student)=xx(成绩)这种形式输出，但是我们知道，map这种类型的toString就是{key1=value1,key2=value2…}，如果跑到人家库里面的去改写方法，这不太好…或者自己重新写一个类继承map后又重写toString，会比较麻烦。 所以就有了下面这种比较原始的方法，看上去会比之前两个多花点时间，但是结果上灵活性会更强。 方法③这个方法，说起来很直观，一看就懂，一般也能想到，我称之为“土办法”，也就是定义两个列表，keylist和valuelist，然后按value值对valuelist排序，交换valuelist中元素的同时交换keylist中的元素。也就是同时排序的思想。 Strings="{"; List<Student>keylist=newArrayList<>(); List<Integer>valuelist=newArrayList<>(); for(Map.Entry<Student,Integer>entry:map.entrySet()){ keylist.add(entry.getKey()); valuelist.add(entry.getValue()); }//初始化keylist和valuelist for(inti=0;i<valuelist.size();i++){ intminpos=i; Integermin=valuelist.get(i); for(intj=i+1;j<valuelist.size();j++){ if(valuelist.get(j).compareTo(min)<0){ minpos=j; min=valuelist.get(j); } }//选择排序（按值排序） if(minpos!=i){ Integertemp=valuelist.get(i); valuelist.set(i,min); valuelist.set(minpos,temp);//valuelist排序 Studenttempl=keylist.get(i); keylist.set(i,keylist.get(minpos)); keylist.set(minpos,templ);//同时排序keylist } } //个性化操作 for(inti=0;i<keylist.size();i++){ s+=keylist.get(i)+"\t对应成绩="; s+=valuelist.get(i); if(i<keylist.size()-1)s+=",\n"; } s+="}"; 同时排序使得将原有map分解为：两个索引值对应的list，那么我们就可以按大小顺序对list中的值操作，灵活性会比较高。打印一下s，输出结果： 参考链接 如何对HashMap进行排序 
第463篇文章[1]
哈工大深入理解计算机系统大作业 文章目录 摘要 第1章概述1.1Hello简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2在Ubuntu下编译的命令3.3Hello的编译结果解析3.3.1数据3.3.2赋值3.3.3类型转换3.3.4算术操作3.3.5关系操作3.3.6数组操作3.3.7控制转移3.3.8函数操作 3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令4.3可重定位目标elf格式4.3.1ELF头4.3.2节头部表4.3.3符号表4.3.4重定位节 4.4Hello.o的结果解析4.4.1结果对比4.4.2机器语言的构成及与汇编语言的映射关系 4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式5.3.1ELF头5.3.2节头部表5.3.3程序头表5.3.4重定位节5.3.5符号表5.3.6动态符号表 5.4hello的虚拟地址空间5.5链接的重定位过程分析5.5.1hello.o与hello区别：5.5.2hello重定位地址计算 5.6hello的执行流程5.7Hello的动态链接分析5.8本章小结 第6章hello进程管理6.1进程的概念与作用6.2简述壳Shell-bash的作用与处理流程6.3Hello的fork进程创建过程6.4Hello的execve过程6.5Hello的进程执行6.6hello的异常与信号处理6.6.1异常处理与信号6.6.2Hello异常分析 6.7本章小结 第7章hello的存储管理7.1hello的存储器地址空间7.2Intel逻辑地址到线性地址的变换-段式管理7.2.1CPU的段寄存器：7.2.2段描述符7.2.3全局描述符表与局部描述符表7.2.4分段机制将逻辑地址转化为线性地址的步骤： 7.3Hello的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.4.1利用TLB加速地址翻译7.4.2单级页表的局限性7.4.3四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问7.6hello进程fork时的内存映射7.7hello进程execve时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.9.1动态内存分配器的基本原理7.9.2带边界标签的隐式空闲链表分配器原理7.9.3显式空间链表的基本原理7.9.4分离空闲链表的基本原理 7.10本章小结 第8章hello的IO管理8.1Linux的IO设备管理方法8.2简述UnixIO接口及其函数8.2.1UnixI/O接口 8.2.2UnixI/O函数8.3printf的实现分析8.4getchar的实现分析8.5本章小结 结论附件参考文献 摘要 本文以hello程序的P2P过程（即FromProgresstoProcess）为例，运用gcc,objdump,edb等工具，详细介绍了程序从最初的源代码到可执行的目标文件的整个过程，需要经历预处理、编译、汇编、链接等操作；并详细分析了运行hello程序时系统的进程管理、存储管理与I/O管理的原理与机制。 关键词：hello程序、P2P过程、编译系统、进程、系统级I/O 第1章概述 1.1Hello简介 P2P过程（FromProgramtoProcess）：从hello.c程序到二进制的可执行文件hello的过程。在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。 linux>gcc-ohellohello.c GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。这个翻译过程由四个阶段完成，如上图，执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统。 O2O过程（FromZero-0toZero-0）：hello进程从无到有再到无的过程。 在shell中，键入命令行执行hello linux>./hello学号（参数1）姓名（参数2） shell通过fork创建一个新的进程，linux加载器execve()将程序计数器设置为程序入口点，并为hello进程映射虚拟内存，虚拟内存机制通过mmap为该进程规划一片空间。2.CPU为执行文件hello分配时间周期，执行逻辑控制流，每条指令在流水线上取值、译码、执行、访存、写回、更新PC。MMU和CPU在执行过程中通过高速缓存和TLB、多级页表在物理内存中存取数据、指令，通过I/O系统输入输出。如果触发异常，则把控制返回给内核进行处理。3.当程序运行结束时，shell回收进程hello以及其僵死子进程。释放内存并且删除有关的上下文。 1.2环境与工具 硬件环境：IntelCorei7-8565Ux64CPU；1.80GHz；8GRAM软件环境：Ubuntu20.04开发与调试工具：gcc，EDB，Hexedit，objdump，readelf，gedit 1.3中间结果 文件名作用hello.c源程序（文本）hello.i预处理之后的程序（文本）hello.s汇编语言程序（文本）hello.o可重定位目标程序（二进制）hello可执行目标程序（二进制）hello1_asm.txthello.o的反汇编文件hello2_asm.txthello的反汇编文件hello1_elf.txthello.o的elf头信息hello2_elf.txt可执行文件hello的elf头信息 1.4本章小结 本章概述了hello从源程序到可执行程序的过程，并且结合shell执行hello进程的整个过程，介绍了开发环境以及中间文件。 第2章预处理 2.1预处理的概念与作用 概念：预处理(pre-treatment)，在程序设计领域，一般是指程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。典型地，由预处理器(preprocessor)对程序源代码文本进行处理，得到的结果再由编译器核心进一步编译。这个过程并不对程序的源代码进行解析，但它把源代码分割或处理为特定的单位。作用：预处理阶段读取C源程序，对其中的预处理指令（以#开头的指令）和特殊符号进行处理。或者说是扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。预处理过程先于编译器对源代码进行处理，读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行转换。预处理过程还会删除程序中的注释和多余的空白字符。预处理指令主要有以下三种：1）包含文件：将源文件中以#include格式包含的文件复制到编译的源文件中，可以是头文件，也可以是其它的程序文件。2）宏定义指令：#define指令定义一个宏，#undef指令删除一个宏定义。3）条件编译：根据#ifdef和#ifndef后面的条件决定需要编译的代码。 2.2在Ubuntu下预处理的命令 预处理命令：gcc-Ehello.c-ohello.i或者cpphello.c>hello.i结果：预处理后生成文件hello.i 2.3Hello的预处理结果解析 查看hello.i文件 main函数体以及全局变量sleepsecs的代码保持不变，在这之前的部分约有三千行，这是由于头文件stdio.h，unistd.h，stdlib.h依次被展开。以stdio.h的展开为例，stdio.h是标准库文件，cpp到Ubuntu中的默认环境变量下寻找stdio.h，打开文件/usr/include/stdio.h，发现其中依然使用了#define预处理语句，cpp对stdio中的宏定义递归展开，最终hello.i文件中没有#define语句。可以发现，其中是用来大量的#ifdef/#ifndef条件编译语句，cpp会根据#ifdef和#ifndef后面的条件决定需要编译的代码。 2.4本章小结 本章主要介绍了预处理相关的概念、作用以及方法，并结合预处理文件对预处理过程进行分析。 第3章编译 3.1编译的概念与作用 概念：编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。编译的过程实质上是把预处理文件进行词法分析、语法分析、语义分析、优化，从C语言等高级语言转换为成机器更好理解的汇编语言程序，转换后的文件仍为ASCII文本文件。 作用：编译后生成的.s汇编语言程序文本文件比预处理文件更容易让机器理解、比.o可重定位目标文件更容易让程序员理解，是对于程序像机器指令的一步关键过程。 3.2在Ubuntu下编译的命令 编译命令：gcc-Shello.c-ohello.s或者cclhello.i-ohello.s结果：生成汇编程序hello.s 3.3Hello的编译结果解析 3.3.1数据 查看hello.c代码（如下图）： 程序中的数据主要有以下几类：①全局变量：sleepsecs②局部变量：整型i；main函数的函数参数：argc,argv③字符串常量：两个printf中的字符串④整型常量：汇编代码中的0、1、2、3、9等整型常量 ①全局变量：由于全局变量sleepsecs被初始化，所以存放在.data节中，由于源程序中声明sleepsecs为int类型，赋初值为2.5，可以发现在汇编代码中数据变为2，小数点后的部分被截断，并规定了对齐字节为4字节。 ②局部变量：i；main函数的参数argc，argv1）局部变量int类型的i：主要起计数作用，存储在运行时的栈中，地址为%rbp-4如图，首先对i变量赋初值为0 然后执行循环，比较i与9的大小，如果i<=9，则执行循环体，跳到.L4 .L4末尾对i进行加一，实现循环变量迭代 2）main函数的参数：int型的argc和字符型指针数组的指针argv。从汇编代码中可以看到，argc开始存储在寄存器rdi中，比较过程中放在了栈中，帧指针为%rbp-20，argv开始存储在寄存器rsi中，使用时放在栈中，帧指针为%rbp-32 第三行代码与if(argc!=3)相对应，如果相等，则跳转到.L2 ③字符串常量程序中存在两个printf中的字符串，分别是"Usage:Hello学号姓名！\n"和“Hello%s%s\n”，如图所示，字符串常量以uft-8格式编码并存储在.rodata段。 由于该文件还未进行汇编，此处仅使用符号.LC0和.LC1代表两个字符串的首地址。 ④整型常量：汇编代码中的0、1、2、3、9等整型常量代码段中的整型常量被改写为汇编语言中的立即数，作为代码段的一部分存储，上文中的0、1、2、3、9等均在此列。 3.3.2赋值 ①对全局变量sleepsecs的赋值intsleepsecs=2.5;对应汇编代码如图，在main函数之前就进行了赋值，赋值为2，并且四字节对齐。 ②对循环变量i的赋值for(i=0;i<10;i++)对应汇编代码 可以看到，对局部变量的赋值语句通过mov指令实现。除此之外也可以通过lea指令实现。 3.3.3类型转换 过程中对sleepsecs进行了隐式类型转换，如3.3.2图所示，要求赋值为2.5，但由于定义为int类型，所以发生了隐式类型转换，数据变为2。 3.3.4算术操作 本程序中唯一的算术运算是for循环对i的自增运算i++，在编译过程中被编译器翻译为ADD类指令，C代码与汇编代码如下所示 3.3.5关系操作 本程序中进行了两次关系操作：①argc!=3使用cmpl语句设置条件码，je语句根据条件码做出是否需要跳转的选择，如图，将argc的值与3比较，如果相等，则跳转到.L2，否则顺序执行。 ②i<10如图，将i的值与9进行比较，如果i小于等于9，则跳转至.L4执行循环体代码，否则继续向下执行。 3.3.6数组操作 程序用到的数组为argv指向的字符串指针数组，打印数组元素argv[1],argv[2]printf(“Hello%s%s\n”,argv[1],argv[2]);对应汇编代码如下，首先对指针argv解引用，加16后对应argv[2]，将argv[2]的值取出放入寄存器rdx中，再对指针argv解引用，加8后对应argv[1]，将argv[1]的值取出放入寄存器rsi中，最后将字符串常量放入寄存器rdi中，调用printf函数进行输出。 3.3.7控制转移 关系操作往往作为控制转移的判定表达式，本实验C代码中共有2处控制转移操作：if分支和for循环，分别对应两次关系操作。①if(argc!=3)控制转移如图，将argc的值与3比较，如果相等，则跳转到.L2，否则顺序执行。控制转移通过je实现。 ②for(i=0;i<10;i++)控制转移for循环在.L2处对循环变量i进行初始化，然后通过jmp跳转到.L3，在.L3中进行了循环终止条件的判断，如果i<=9，则跳转到循环体部分.L4，否则顺序执行。 3.3.8函数操作 本实验中的函数操作主要涉及以下函数：①printf②exit③sleep④getchar。①printf函数第一处：printf("Usage:Hello学号姓名！\n");printf函数在调用之前，首先将.LC0的printf格式串的地址放入寄存器rdi中进行传参，然后由于只有一个参数，编译器采取了一个小trick，将printf函数翻译为puts函数来进行输出。 第二处：printf("Hello%s%s\n",argv[1],argv[2]);printf函数在调用之前，三个参数按顺序依次为.rodato节的.LC1的printf格式串的地址，argv[1]，argv[2]，分别存放在了寄存器rdi，rsi，rdx中。 ②exit函数exit函数调用之前，将立即数1存入rdi中，作为exit的第一参数进行传递。 ③sleep函数 sleep(sleepsecs); sleepsecs放入寄存器rdi中，作为第一参数传递并调用sleep函数。 ④getchar函数 getchar(); 由于getchar函数无参数，直接调用getchar函数如图： 3.4本章小结 本章主要介绍编译操作的过程，主要将预处理后的hello.i文件编译为汇编代码文件hello.s，在此过程中，编译器将会对源文件进行语法分析、词法分析，得到汇编文件hello.s。同时，编译器还会对源代码进行保守的、有限的优化。同时，本章中解析了变量、相关运算，以及各类C语言的基本语句的汇编表示，更便于理解高级语言的底层表示。 第4章汇编 4.1汇编的概念与作用 概念：汇编器(as)将hello.s文件翻译成二进制机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存到目标文件hello.o中。hello.o是一个二进制文件，包含着程序的指令编码，如果用文本编辑器打开，将看到一堆乱码。 作用：在汇编过程中，文件格式将由面向阅读友好的文本文件转化为机器可执行的二进制文件，并且将文本文件中的常量转化为对应的二进制补码，同时，汇编过程也将生成可重定位目标文件的结构信息，Linux系统使用可执行可链接格式(ELF)对目标文件进行组织。 4.2在Ubuntu下汇编的命令 汇编命令：gcc-chello.s-ohello.o或者ashello.s-ohello.o结果：生成可重定位目标程序hello.o 4.3可重定位目标elf格式 4.3.1ELF头 使用readelf命令查看hello.o的elf格式 readelf-ahello.o>hello1_elf.txt ELF头以一个16字节的序列Magic开始，该序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助连接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（可重定位/可执行/共享）、机器类型、节头部表的文件偏移，以及节头部表条目的大小和数量。由hello.o文件的ELF头部分可知：该文件为REL（可重定位目标文件）；机器类型为AMDX86-64；节头部表的文件偏移为0；字节顺序为小端序；节头大小为64字节；节头数量为14。 4.3.2节头部表 Linux系统使用可执行可链接格式(ELF)对目标文件进行组织，其具体结构及其内容如图所示： .text：已编译程序的机器代码.rodata：只读数据.data：已初始化的全局和静态C变量.bss：未初始化的全局和静态C变量.symtab：符号表.rel.text：代码段重定位信息表.rel.data：数据段重定位信息表.debug：调试符号表.line：C代码行号与机器码行号映射表.strtab：字符串表 节头部表包含目标文件各节的语义，包括节的名称、大小、类型、地址、偏移量、是否链接、读写权限等信息。本程序对应的节头部表如下图所示：以.text节为例分析具体节头部表条目的含义，其大小为0x92字节；虚拟内存地址为0x0000000000000000，这是由于hello.o是可重定位目标文件，所以每个节都从0开始，用于重定位；读写权限为AX，即分配内存、可执行；相对于文件头的偏移量为0x40字节。 .rela.text节：一个.text节中的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。.data节：已初始化的静态和全局C变量。类型为PROGBITS，意为程序数据，旗标为WA，即权限为可分配可写。.bss节：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。类型为NOBITS，意为暂时没有存储空间，旗标为WA，即权限为可分配可写。.rodata节：存放只读数据，例如printf中的格式串和开关语句中的跳转表。类型为PROGBITS，意为程序数据，旗标为A，即权限为可分配。.comment节：包含版本控制信息。.note.GNU_stack节：用来标记executablestack（可执行堆栈）。.eh_frame节：处理异常。.rela.eh_frame节:.eh_frame的重定位信息。.shstrtab节：该区域包含节区名称。.symtab节：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。.strtab节：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部的节名字。 4.3.3符号表 符号表是由汇编器构造的，使用编译器输出到汇编语言.s文件中的符号。.symtab节中包含ELF符号表。这张符号表包含一个条目的数组。下图中展示了每个条目的格式： .symtab节 符号表每个条目都对应一个符号的语义，具体包括：①符号名称name：以整型变量存放在符号表中，是字符串表.strtab中的字节偏移，指向符号的以null结尾的字符串名字。②符号地址value：距定义目标的节的起始位置的偏移，对于可执行目标文件来说是一个绝对的运行时地址。③符号类型type：表明符号的类型，通常要么是数据，要么是函数。④符号范围binding：该字段表明符号是本地的还是全局的。⑤分配目标section：该字段是一个到节头部表的索引，表明对应符号被分配至目标文件的某个节；有三个特殊的伪节，它们在节头部表中是没有条目的：ABS代表不该被重定位的符号；UNDEF代表未定义的符号，即本模块中引用的外部符号；COMMON表示还未被分配位置的未初始化的数据目标。⑥目标大小size 在上图中，全局符号sleepsecs定义的条目，它是位于.data节中偏移量为0（即value值）处的4字节目标；全局符号main定义的条目，它是位于.text节中偏移量为0（即value值）处的133字节函数。全局符号puts，exit，printf，sleep，getchar定义的条目，是未定义的符号（UND），为NOTYPE未知类型；局部符号hello.c定义的条目为文件，是不该被重定位的符号（ABS）。 4.3.4重定位节 当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在.rel.data中。 ①offset：需要被修改的引用的字节偏移。②symbol：标识被修改引用应该指向的符号。③type：告知链接器如何修改新的引用。④addend：一些类型的重定位要使用它对被修改引用的值做偏移调整。 其中，重定位类型（type）常见有2种：①R_X86_64_32：重定位绝对引用。重定位时使用一个32位的绝对地址的引用，通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改；②R_X86_64_PC32：重定位PC相对引用。重定位时使用一个32位PC相对地址的引用。一个PC相对地址就是据程序计数器的当前运行值的偏移量。 ·重定位PC相对引用重定位算法如下：refaddr=ADDR(s)+r.offset;*refptr=(unsigned)(ADDR(r.symbol)+r.addend–refaddr);·重定位绝对引用重定位算法如下：*refptr=(unsigned)(ADDR(r.symbol)+r.addend);其中，假设算法运行时，链接器为每个节（用ADDR(s)表示）和每个符号都选择了运行时地址（用ADDR(r.symbol)）表示。 本程序中的重定位节，见下图： 以图中第一个条目.rodata的重定位为例，设它的重定位地址为refptr。第一步，计算引用的运行时地址refaddr=ADDR(s)+r.offset,.rodata的r.offset为0x16，ADDR(s)是由链接器确定的，所以可以计算出refaddr。第二步，更新引用，refptr=(unsigned)(ADDR(r.symbol)+r.addend–refaddr),.rodata的ADDR(r.symbol)也是由链接器确定的，r.addend由上图可知为0，refaddr第一步已经算出来了，所以，可以计算出refptr，即.rodata的重定位的重定位地址。 同时我们可以用objdump结合反汇编代码和查看.rodata节分析：objdump-dhello.o>hello_asm.txt首先查看0x1c附近的代码，可以看到该处代码与第一个格式串相关。 objdump-shello.o>hello_asm1.txt然后，查看.rodata节的内容，.rodata-4对应第一个格式串的位置。 4.4Hello.o的结果解析 4.4.1结果对比 在shell中输入命令objdump-dhello.o>hello_asm.txt查看反汇编文件hello_asm.txt和汇编程序hello.s，比较如下：①跳转语句不同hello.s：代码直接声明具体的段存储位置，操作数为助记符如.LC0，.LC1 反汇编代码：计算出地址，依据地址跳转 ②数据内容不同hello.s：立即数为10进制格式 反汇编代码：立即数为16进制格式 ③有无对应机器码hello.s：只有汇编代码反汇编代码：有对应的机器码④有无重定位条目hello.s：调用函数时采用函数的助记符，直接声明 对全局变量的引用采用助记符 反汇编：生成重定位的条目，在链接时计算运行时的内存地址，然后分配给每一条引用，保证每一条引用最终都能指向正确的地址。 4.4.2机器语言的构成及与汇编语言的映射关系 机器语言的构成：机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指指令系统令的集合。以Y86-64指令集为例（如下图）。指令编码长度从1个字节到10个字节不等。一条指令含有一个单字节的指令指示符，可能含有一个单字节的寄存器指示符，还可能含有一个8字节的常数字。字段fn指明是某个整数操作(OPq)、数据传送条件(cmovXX)或是分支条件(jXX)。所有的数值都用十六进制表示。下图展示了机器语言与汇编语言直接的映射关系： 在这个图中，左边是指令的汇编码表示，右边是字节编码。 4.5本章小结 本章介绍了汇编的整个过程，从汇编语言到机器码，重点关注了生成文件hello.o可重定位这一特性，并且通过objdump反汇编得到的代码与hello.s进行比较，了解了其中的映射机制以及两者之间的区别。 第5章链接 5.1链接的概念与作用 概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。作用：把可重定位目标文件和命令行参数作为输入，产生一个完全链接的，可以加载运行的可执行目标文件，使得分离编译成为可能。 5.2在Ubuntu下链接的命令 链接命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o /usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 结果：生成可执行目标文件hello 5.3可执行目标文件hello的格式 查看hello的ELF格式readelf-ahello>hello2_elf.txt 5.3.1ELF头 ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型(如可重定位、可执行或者共享的)、机器类型(如x86-64)、节头部表(sectionheadertable)的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目(entry)。查看ELF头： hello.o的ELF以一个16进制序列： 7f454c46020101000000000000000000作为ELF头的开头。这个序列描述了生成该文件的系统的字的大小为8字节和字节顺序为小端序。 ELF头的大小为64字节；目标文件的类型为EXEC（可执行文件）；机器类型为AMDX86-64；程序头条目数量为12、大小为56字节；节头条目数量为27、大小为64字节。 5.3.2节头部表 节头部表如下图：与hello.o的节头部表作对比，可以得出：①hello的节头部表增加了若干条目，下图中一共有26个节的信息，而hello.o的节头部表中只有13个节的信息。②所有节被分配了运行时的地址。可以看到下图中某些节地址有所不同，而hello.o的节头部表中所有节的Address为全0。 5.3.3程序头表 可执行文件或共享目标文件的程序头表是一个结构数组。每种结构都描述了系统准备程序执行所需的段或其他信息。 typedefstruct{ Elf64_Wordp_type; Elf64_Wordp_flags; Elf64_Offp_offset; Elf64_Addrp_vaddr; Elf64_Addrp_paddr; Elf64_Xwordp_filesz; Elf64_Xwordp_memsz; Elf64_Xwordp_align; }Elf64_Phdr; p_type：此数组元素描述的段类型或解释此数组元素的信息的方式。表 13-1中指定了类型值及其含义。p_offset：相对段的第一个字节所在文件的起始位置的偏移。p_vaddr：段的第一个字节在内存中的虚拟地址。p_paddr：段在与物理寻址相关的系统中的物理地址。由于此系统忽略了应用程序的物理地址，因此该成员对于可执行文件和共享目标文件具有未指定的内容。p_filesz：段的文件映像中的字节数，可以为零。p_memsz：段的内存映像中的字节数，可以为零。p_flags：与段相关的标志。表 13-2中指定了类型值及其含义。p_align：可装入的进程段必须具有p_vaddr和p_offset的同余值（以页面大小为模数）。此成员可提供一个值，用于在内存和文件中根据该值对齐各段。值0和1表示无需对齐。另外，p_align应为2的正整数幂，并且p_vaddr应等于p_offset（以p_align为模数）。 查看程序头表如下： 5.3.4重定位节 基本概念与4.3.4节一致 5.3.5符号表 如下图所示，hello程序的符号表包含编号Num、Value、Size、Type、Bind、Vis、Ndx、Name字段。其含义可以参照4.3.3内容，在此不做赘述。可以看到，可执行目标文件的符号表表项数目（51entries）明显多于可重定位目标文件的表项数目（18entries）。一方面，可执行目标文件中加入了与调试、加载、动态链接相关的节，使得表示节的符号数增多；另一方面，由于链接器对可重定位目标文件中的符号进行了进一步解析，加入了若干系统调用。 5.3.6动态符号表 动态符号表(.dynsym)用来保存与动态链接相关的导入导出符号，不包括模块内部的符号。而.symtab则保存所有符号，包括.dynsym中的符号。 5.4hello的虚拟地址空间 使用edb加载hello，由图知虚拟空间从0x400000开始。 以.text节和.rodata节为例 由节头部表知.text节起始地址为0x4010d0 结束于内存地址0x401215处 由节头部表知.rodata节起始地址为0x402000，结束于地址0x40202f 5.5链接的重定位过程分析 objdump-dhello>hello2_asm.txt反汇编hello文件 5.5.1hello.o与hello区别： ①虚拟地址不同hello.o：反汇编代码虚拟地址从0开始 hello：反汇编代码虚拟地址从0x400000开始 ②反汇编节数不同hello.o：只有.text节，其中只有main函数的反汇编代码 hello：在main函数之前填充有链接过程中重定位而加入进来各种函数、数据，增加了.init，.plt，.plt.sec等节的反汇编代码。 ③call函数跳转地址，引用全局变量地址不同hello.o： hello 不过注意到，相对地址没有改变。 5.5.2hello重定位地址计算 重定位地址计算伪代码如下图所示：·重定位PC相对引用重定位算法如下： refaddr=ADDR(s)+r.offset; *refptr=(unsigned)(ADDR(r.symbol)+r.addend–refaddr); ·重定位绝对引用重定位算法如下： *refptr=(unsigned)(ADDR(r.symbol)+r.addend); 其中，假设算法运行时，链接器为每个节（用ADDR(s)表示）和每个符号都选择了运行时地址（用ADDR(r.symbol)）表示。 5.6hello的执行流程 本小节中使用edb执行hello，下面列出了hello从加载到程序终止的所有调用与跳转的函数名及其运行时地址函数名运行时地址ld-2.27.so!_dl_start0x00007f294d8086c0ld-2.27.so!_dl_init0x00007f294d808c50hello!_start0x400550hello!init0x401000hello_main0x401105hello!puts@plt0x401080hello!exit@plt0x4010b0hello!printf@plt0x401090hello!sleep@plt0x404044hello!getchar@plt0x404028sleep@plt0x4010c0 5.7Hello的动态链接分析 动态链接项目中，查看dl_init前后项目变化。对于动态共享链接库中PIC函数，编译器加重定位记录，等待动态链接器处理，为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略，将过程地址的绑定推迟到第一次调用该过程。动态链接器使用过程链接表PLT+全局偏移量表GOT实现函数的动态链接，GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。GOT运行时地址为0x403ff0，PLT的运行时地址为0x404000。 在程序调用dl_init前，使用edb查看地址0x404000处的内容，如下所示： 在dl_init调用之前，对于每一条PIC函数调用，调用的目标地址都实际指向PLT中的代码逻辑，初始时每个GOT条目都指向对应的PLT条目的第二条指令。调用前： 调用后： 在dl_init调用前后，0x6008b0和0x6008c0处的两个8字节的数据分别发生改变。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。其中GOT[1]指向重定位表（依次为.plt节需要重定位的函数的运行时地址）用来确定调用的函数地址，GOT[2]是动态链接器ld-linux.so模块中的入口点。 在之后的函数调用时，首先跳转到PLT执行.plt中逻辑，第一次访问时，GOT地址为下一条指令，将函数序号压栈，然后跳转到PLT[0]，在PLT[0]中将重定位表地址压栈，然后访问动态链接器，在动态链接器中使用函数序号和重定位表确定函数运行时地址，重写GOT，再将控制传递给目标函数。之后如果对同样函数调用，第一次访问跳转直接跳转到目标函数。 5.8本章小结 本章首先介绍了链接的概念及作用，详细分析了可执行目标文件hello的ELF格式，并且通过edb调试查看其虚拟地址空间，并分析了重定位过程、执行流程和整个动态链接过程。 第6章hello进程管理 6.1进程的概念与作用 概念：进程是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。作用：进程提供给应用程序关键抽象：①一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。②一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 1.shell的定义shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。2.shell的作用实际上shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。3.shell的处理流程shell首先检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux本身的实用程序，如ls和rm，也可以是购买的商业程序，如xv，或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能够成功找到命令，该内部命令或应用程序将被分解为系统调用并传给Linux内核。 6.3Hello的fork进程创建过程 终端程序通过调用fork()函数创建一个子进程，子进程得到与父进程完全相同但是独立的一个副本，包括代码段、数据段、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，父进程和子进程最大的不同时他们的PID是不同的。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。我们在shell上输入./hello，由于这不是一个内置的shell命令，所以shell会认为hello是一个可执行目标文件，通过调用某个驻留在存储器中被称为加载器的操作系统代码来运行它。 6.4Hello的execve过程 execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的PID，并且继承了调用execve函数时已打开所有文件描述符。hello的execve过程可以总结为以下几个步骤：删除已存在的用户区域；映射私有区域；映射共享区域；设置程序计数器。hello加载并运行后栈的结构如下： 6.5Hello的进程执行 上下文切换：操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在较低层异常机制之上的。内核为每个进程维持-一个.上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度，是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个read系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。另一个示例是sleep系统调用，它显式地请求让调用进程休眠。hello程序与操作系统其他进程通过操作系统的调度，切换上下文，拥有各自的时间片从而实现并发运行。hello在调用sleep函数时做了上下文切换。 hello初始运行在用户模式中，直到它通过执行系统调用sleep陷入到内核。内核处理休眠请求主动释放当前进程(hello)，同时计时器开始计时，内核进行如上图所示的上下文切换，将当前进程的控制权交给其他进程，当进程达到sleep_secs的时间时，给其他进程发送中断信号，触发中断异常处理子程序，将hello进程从等待队列中移出，重新加入到运行队列。 6.6hello的异常与信号处理 6.6.1异常处理与信号 异常处理可以分为四类，如下表： 一种更高层的软件形式的异常，称为Linux信号，它允许进程和内核中断其他进程。一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。下图展示了Linux系统上支持的30种不同类型的信号。 6.6.2Hello异常分析 hello执行过程中进行如下操作：①键盘随机按键：如果按键过程中没有回车键，会把输入屏幕的字符串缓存起来；如果按键过程中有回车键，则当程序运行完成后，缓存区中的换行符前的字符串会被shell当作指令执行。 ②按Ctrl-Z键输入Ctrl-Z键会发送一个SIGTSTP信号给前台进程组的每一个进程，故hello进程停止。 运行ps命令：显示当前进程的状态运行jobs命令：用于显示Linux中的任务列表及任务状态，包括后台运行的任务。运行fg命令：用于将后台作业（在后台运行的或者在后台挂起的作业）放到前台终端运行。由于后台作业只有hello，于是hello被转到前台运行，继续循环输出字符串。 pstree命令：将所有行程以树状图显示 kill命令kill-9<进程号>：杀死对应进程 ②按Ctrl-C键 如果在程序运行过程中输入Ctrl+C,会让内核发送一个SIGINT信号给到前台进程组中的每个进程，结果是终止前台进程。 6.7本章小结 本章介绍了进程的定义与作用，对hello被加载、执行的过程进行分析，同时介绍shell的一般处理流程和作用，并且着重分析了调用fork函数创建新进程，调用execve函数加载并执行hello，以及hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 （1）逻辑地址：在有地址变换功能的计算机中,访问指令给出的地址(操作数)叫逻辑地址,也叫相对地址。要经过寻址方式的计算或变换才得到内存储器中的物理地址。（2）物理地址：在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址（PhysicalAddress），又叫实际地址或绝对地址。（3）虚拟地址： CPU启动保护模式后，程序运行在虚拟地址空间中。注意，并不是所有的“程序”都是运行在虚拟地址中。CPU在启动的时候是运行在实模式的，Bootloader以及内核在初始化页表之前并不使用虚拟地址，而是直接使用物理地址的。（4）线性地址： 线性地址（LinearAddress）是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 7.2.1CPU的段寄存器： 在CPU中，跟段有关的CPU寄存器一共有6个：cs，ss，ds，es，fs，gs，它们保存的是段选择符(或者叫段描述符)。而同时这六个寄存器每个都有一个对应的非编程寄存器，它们对应的非编程寄存器中保存的是段描述符。系统可以把同一个寄存器用于不同的目的，方法是先将其寄存器中的值保存到内存中，之后恢复。而在系统中最主要的是cs，ds，ss这三个寄存器。 7.2.2段描述符 段描述符就是保存在全局描述符表或者局部描述符表中，当某个段寄存器试图通过自己的段选择符获取对于的段描述符时，会将获取到的段描述符放到自己的非编程寄存器中，这样就不用每次访问段都要跑到内存中的段描述符表中获取。 7.2.3全局描述符表与局部描述符表 全局描述符表和局部描述符表保存的都是段描述符，记住要把段描述符和段选择符区别开来，保存在寄存器中的是段选择符，这个段选择符会到描述符表中获取对于的段描述符，然后将段描述符保存到对应寄存器的非编程寄存器中。系统中每个CPU有属于自己的一个全局描述符表(GDT)，其所在内存的基地址和其大小一起保存在CPU的gdtr寄存器中。其大小为64K，一共可保存8192个段描述符，不过第一个一般都会置空，也就是能保存8191个段描述符。第一个置空的原因是防止加电后段寄存器未经初始化就进入保护模式而使用GDT。而对于局部描述符表，CPU设定是每个进程可以创建属于自己的局部描述符表(LDT)，当前被使用的LDT的基地址和大小一起保存在ldtr寄存器中。不过大多数用户态的liunx程序都不使用局部描述符表，所以linux内核只定义了一个缺省的LDT供大多数进程共享。描述这个局部描述符表的局部描述符表描述符保存在GDT中。 7.2.4分段机制将逻辑地址转化为线性地址的步骤： 1）使用段选择符中的偏移值（段索引）在GDT或LDT表中定位相应的段描述符。(仅当一个新的段选择符加载到段寄存器中是才需要这一步)2）利用段选择符检验段的访问权限和范围，以确保该段可访问。3）把段描述符中取到的段基地址加到偏移量(也就是上述汇编语言汇中直接出现的操作地址)上，最后形成一个线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 Linux采用了分页的方式来记录对应关系。所谓的分页，就是以更大尺寸的单位页来管理内存。在Linux中，通常每页大小为4KB。CPU中的一个控制寄存器，页表基址寄存器(PageTableBaseRegister,PTBR)指向当前页表。n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移(VirtualPageOffsetm,VPO)和一个(n-p)位的虚拟页号(VirtualPageNumber,VPN)。MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE0，VPN1选择PTE1，以此类推。将页表条目中物理页号(PhysicalPageNumber,PPN)和虚拟地址中的VPO串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是P字节的，所以物理页面偏移(PhysicalPageOffset，PPO)和VPO是相同的。下图展示了从虚拟地址到物理地址的基于页表的翻译过程： 下图展示了当页命中时，CPU硬件执行的步骤： 第1步:处理器生成一个虚拟地址，并把它传送给MMU。第2步:MMU生成PTE地址，并从高速缓存/主存请求得到它。第3步:高速缓存/主存向MMU返回PTE。第4步:MMU构造物理地址，并把它传送给高速缓存/主存。第5步:高速缓存/主存返回所请求的数据字给处理器用来压缩页表的常用方法为使用层次结构的页表：以二级页表为例：第一级页表:每个PTE指向一个页表(常驻内存)第二级页表:每个PTE指向一页 下图描述了使用k级页表层次结构的地址翻译： 虚拟地址被划分成为k个VPN和1个VPO。每个VPNi都是一个到第i级页表的索引，其中1≤i≤k。第j级页表中的每个PTE,1≤j≤k-1，都指向第j+1级的某个页表的基址。第k级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN。之前，MMU必须访问k个PTE。对于只有一级的页表结构，PPO和VPO是相同的。访问k个PTE,第一眼看上去昂贵而不切实际。然而，这里TLB能够起作用，正是通过将不同层次，上页表的PTE缓存起来。实际上，带多级页表的地址翻译并不比单级页表慢很多。 7.4TLB与四级页表支持下的VA到PA的变换 7.4.1利用TLB加速地址翻译 正如我们看到的，每次CPU产生一个虛拟地址，MMU就必须查阅一个PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。如果PTE碰巧缓存在L1中，那么开销就下降到1个或2个周期。然而，许多系统都试图消除即使是这样的开销，它们在MMU中包括了一个关于PTE的小的缓存，称为翻译后备缓冲器(TranslationLookasideBuffer，TLB)。TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。如图9-15所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有T=2^t个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的。 TLB具有如下特征：MMU中一个小的相联存储设备实现虚拟页码向物理页码的映射对于页码数很少的页表可以完全包含在TLB中 上图展示了当TLB命中时(通常情况)所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。第1步：CPU产生一个虚拟地址。第2步和第3步：MMU从TLB中取出相应的PTE。第4步：MMU将这个虚拟地址翻译成–个物理地址，并且将它发送到高速缓存/主存。第5步：高速缓存/主存将所请求的数据字返回给CPU。当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，如上图所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。 7.4.2单级页表的局限性 在32位系统中，地址空间有32位，假设每个页面大小为4KB，每个PTE大小为4字节，那么即使所引用的只是虚拟地址空间中很小的一部分，也总是需要一个4MB的页表驻留在内存中，对于地址空间为64位的系统而言，问题将变得更加复杂。为解决上述问题，我们使用层次结构的页表来对其空间进行压缩，其主要思想为：将页表构建出层次结构，高级页表中存储低级页表的低质，最底层页表存储相应的物理内存地址。 7.4.3四级页表支持下的VA到PA的变换 Linux为了在更高层次提供抽像，为每个CPU提供统一的界面。提供了一个四层页管理架构，来兼容这些二级、三级、四级管理架构的CPU。 这四级分别为：①页全局目录PGD（对应刚才的页目录）②页上级目录PUD（新引进的）③页中间目录PMD（也就新引进的）④页表PT（对应刚才的页表）。 具体的翻译步骤参考7.4.3节k级页表层次结构的地址翻译，不再重复叙述。 其一级、二级、三级PTE格式如下所示： 四级PTE格式如下所示： 每次对一个页进行了写之后，MMU都会设置D位，又称修改位或脏位。修改位告诉内核在复制替换页之前是否必须写回牺牲页。内核可以通过调用一条特殊的内核模式指令来清除引用位和修改位。 7.5三级Cache支持下的物理内存访问 对于一个虚拟地址请求，CPU首先将去TLB寻找，看是否已经在TLB中缓存。如果命中的话就直接MMU获取，没有命中的话就先在结合多级页表，得到物理地址PA，L1Cache对PA进行分解，将其分解为标记(CT)、组索引(CI)、块偏移(CO)，检测物理地址是否L1cache命中，若命中，则直接将PA对应的数据内容取出返回给CPU，若不命中则在下一级中寻找，并重复L1cache中的操作。CPU的高速缓存机制具体过程图如下： 7.6hello进程fork时的内存映射 当fork函数被shell调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了hello进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的PID，并且继承了调用execve函数时已打开所有文件描述符。hello的execve过程可以总结为以下几个步骤：删除已存在的用户区域；映射私有区域；映射共享区域；设置程序计数器。hello加载并运行后栈的结构如下： 7.8缺页故障与缺页中断处理 7.8.1缺页故障虚拟内存中的字不在物理内存中(DRAM缓存不命中)即缺页。下图中展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。 7.8.2Linux缺页处理假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤： ①判断虚拟地址A是否合法，即A是否在某个区域结构定义的区域内。缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。②判断试图进行的内存访问是否合法。即进程是否有读、写或者执行这个区域内页面的权限。例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的?这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的?如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。③如果不是上述两点，则内核知道这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU。这次，MMU就能正常地翻译A，而不会再产生缺页中断了。 7.9动态存储分配管理 7.9.1动态内存分配器的基本原理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。分配器有两种基本风格，两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体来负责释放已分配的块。①显式分配器：要求应用显式地释放任何已分配的块。例如，c标准库提供一种叫做malloc程序包的显式分配器。c程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。c++中的new和delete操作符与c中的malloc和free相当。②隐式分配器：另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集，例如Lisp,ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 7.9.2带边界标签的隐式空闲链表分配器原理 对于带边界标签的隐式空闲链表分配器，一个块是由一个字的头部、有效载荷、可能的一些额外的填充，以及在块的结尾处的一个字的脚部组成的。 头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是0。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。我们称这种结构称为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。注意：此时我们需要某种特殊标记的结束块，可以是一个设置了已分配位而大小为零的终止头部。 7.9.3显式空间链表的基本原理 因为根据定义，程序不需要一个空闲块的主体，所以实现空闲链表数据结构的指针可以存放在这些空闲块的主体里面。 显式空闲链表结构将堆组织成一个双向空闲链表，在每个空闲块的主体中，都包含一个pred（前驱）和succ（后继）指针。使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于空闲链表中块的排序策略。一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址 7.9.4分离空闲链表的基本原理 分离空闲链表的核心思想是分离存储，即维护多个空闲链表，其中每个链表的块有大致相等的大小，实现有两种基本方法：简单分离存储和分离适配。C语言的malloc函数实现方法介绍显示空闲链表加分离适配。 7.10本章小结 在本章中整理了有关内存管理的知识，介绍了四种地址空间，以及intel环境下的段式管理和页式管理，同时以Inteli7处理器为例，介绍了基于四级页表、三级cache的虚拟地址空间到物理地址的转换，阐述了fork和exceve的内存映射，并介绍缺页故障和缺页中断管理机制。 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m字节的序列：B0，B1，B2……Bm所有的IO设备（如网络、磁盘、终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O，这使得所有的输入和输出都被当做相应文件的读和写来执行。Coolfact:所有的I/O设备（网络、磁盘、终端）都被模型化为文件:/dev/sda2（用户磁盘分区）/dev/tty2（终端）甚至内核也被映射为文件:/boot/vmlinuz-3.13.0-55-generic（内核映像）/proc（内核数据结构）设备的模型化：文件设备管理：unixio接口 8.2简述UnixIO接口及其函数 8.2.1UnixI/O接口 ①打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息②Shell创建的每个进程都有三个打开的文件：标准输入、标准输出、标准错误。③改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k④读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k⑤关闭文件：内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去 8.2.2UnixI/O函数 ①open函数进程通过调用open函数来打开一个已存在的文件或者创建一个新文件： open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件:O_RDONLY:只读。O_WRONLY:只写。ORDWR:可读可写。 ②close函数进程通过调用close函数关闭一个打开的文件。 ③read和write函数 read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 查看printf函数的函数体： intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } printf需要做的事情是：接受一个fmt的格式，然后将匹配到的参数按照fmt格式输出。printf用了两个外部函数，一个是vsprintf，还有一个是write。vsprintf函数作用是接受确定输出格式的格式字符串fmt（输入）。用格式字符串对个数变化的参数进行格式化，产生格式化输出。write函数将buf中的i个元素写到终端。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall。字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 查看getchar函数的函数体： intgetchar(void) { staticcharbuf[BUFSIZ];//缓冲区 staticchar*bb=buf;//指向缓冲区的第一个位置的指针 staticintn=0;//静态变量记录个数 if(n==0) { n=read(0,buf,BUFSIZ); bb=buf;//并且指向它 } return(--n>=0)?(unsignedchar)*bb++:EOF; } getchar有一个int型的返回值。当程序调用getchar时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中直到用户按回车为止(回车字符也放在缓冲区中)。当用户键入回车之后，getchar才开始从stdio流中每次读入一个字符。getchar函数的返回值是用户输入的第一个字符的ASCII码,如出错返回-1,且将用户输入的字符回显到屏幕。如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取。异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法、UnixIO接口及其函数，分析了printf函数和getchar函数的实现。 结论 程序从源代码hello.c到可执行文件hello需要经历编译系统处理的过程，包括预处理、编译、汇编、链接的过程。首先预处理过程预处理器cpp修改源程序hello.c为hello.i，读取头文件内容并插入到程序文本中；编译过程编译器cc1将hello.i翻译为汇编语言程序hello.s；汇编阶段汇编器as将hello.s翻译成机器语言指令，打包成可重定位目标程序hello.o；最后链接器ld将所有可重定位目标程序合并，得到可执行目标文件hello。我们在终端运行hello程序时，shell首先调用fork函数创建子进程，其地址空间与shell父进程完全相同；并调用execve函数在当前进程的上下文中加载并运行hello程序；之后调用hello程序的main函数，hello程序开始在一个进程的上下文中运行；期间，MMU，TLB，多级页表机制，三级cache共同完成对地址的请求；异常处理机制保证了hello对异常信号的处理，使程序平稳运行；UnixI/O让程序能够与文件进行交互。最后，hello运行完毕，shell回收子进程，内核会删除这个进程使用所需要创建的一系列数据结构。至此，hello程序运行结束。hello的一生，从源码到可执行文件，从执行再到运行结束，经历了复杂的过程，需要操作系统、硬件与软件的参与；通过学习这门课，我深深感受到了计算机系统的复杂和奥妙，同时对内部实现的有了更多了解，能更好地编写系统性能优良的代码以及规避掉一些由底层机制带来的bug。 附件 文件名作用hello.c源程序（文本）hello.i预处理之后的程序（文本）hello.s汇编语言程序（文本）hello.o可重定位目标程序（二进制）hello可执行目标程序（二进制）hello1_asm.txthello.o的反汇编文件hello2_asm.txthello的反汇编文件hello1_elf.txthello.o的elf头信息hello2_elf.txt可执行文件hello的elf头信息 参考文献 [1]RandalE.Bryant/DavidO’Hallaron.深入理解计算机系统（原书第3版）[M].机械工业出版社，2016：1-87.[2]段页式存储管理方式详解https://blog.csdn.net/low5252/article/details/106075945 
第464篇文章[]
如何用Junit测试 文章目录 导入JUnit的包新建一个Junit测试类测试用例运行测试类 导入JUnit的包 右键点击java项目→BuildPath→ConfigureBuildPathAddLibrary→JUnit选择Junit的版本→Finish→Applyandclose 新建一个Junit测试类 在java包上点击右键→New→Other（讲道理熟悉了以后，直接new一个普通的class，再自己导入junit包和这个操作也是一样的）选择JunitTestCase给测试类取名，选择classundertest点击Finish 测试用例 //insert(): //测试策略 //插入标签在时间集合中(非法插入); //插入标签不在集合中:插入时间不合法(end<start);插入时间合法（合法插入） @Test publicvoidtestInsert(){ IntervalSet<Employee>iset=emptyInstance(20210101,20210305); longstart=20210101; longend=20210203; Employeelabel1=newEmployee("a","manager",18846451368L); Employeelabel2=newEmployee("b","worker",16548751663L); assertTrue(iset.insert(start,end,label1));//合法插入 assertTrue(iset.labels().contains(label1)); System.out.println("预期插入出错测试方法：testInsert()"); assertFalse(iset.insert(start+1,end+1,label1));//标签重复 assertFalse(iset.insert(end,start,label2));//插入时间不合法，起始时间>终止时间 } 先写测试策略（划分等价类，或者用边界值分析的思想）测试方法前用@Test标注使用assertTrue(),assertFalse(),assertEquals(预期值，测试值)等方法对结果进行测试需要测试抛出异常的方法，@Test(expected=xxx异常.class) @Test(expected=IntervalBlankException.class) publicvoidtestBlank()throwsIntervalBlankException{ longpstart=20210110L; longpend=20210306L; DutyIntervalSetdiset=newDutyIntervalSet(newCommonIntervalSet1<Employee>(pstart,pend)); Employeea=newEmployee("ZhangSan","Manager",13904510000L); diset.insert(20210112L,20210131L,a); diset.checkifBlank();//预期结果：调用checkifBlank方法抛出IntervalBlankException的异常 } 运行测试类 右键点击测试类→RunAs→JUnitTest绿色表示测试通过，如果是红色或者蓝色则测试失败，需要根据报错提示对源代码修改。 
第465篇文章[]
Java_如何编写自己的泛型类 泛型 泛型，即参数化类型，类似于方法中将变量参数化，泛型是将原来定义的具体的类型参数化。 使用泛型的需求 Java中为什么要使用泛型，是因为泛型使用起来非常之方便，泛型类/方法针对于面向复用的开发。当我们想让一个类/方法同时适配于多种数据类型，这将大大省去我们编写重复代码的时间。 举一个常见的例子说明： List<Integer>ilist=newArrayList<Integer>(); List<String>slist=newArrayList<String>(); 其中List接口以及类ArrayList均使用了泛型，从而可以构造出接收以类型Integer,String为参数的list；所以下面的add操作中可以用不同类型的变量作为参数（用泛型可以省去重载方法的开销）： ilist.add(1); ilist.add(2); System.out.println(ilist); slist.add("a"); slist.add("b"); System.out.println(slist); 分别输出为[1,2] [a,b] 泛型应用场景 可以看到，除了部分底层的实现类，上层的类/抽象类/接口基本都是用泛型实现的，用泛型实现能够很好地进行复用，比如这里的L可以是Employee，Course，Process，从而派生出三个具体子类DutyIntervalSet，CourseIntervalSet，ProcessIntervalSet。 下面我们将以上图为例介绍如何编写一个自己的泛型类。 如何编写自己的泛型类 我们以MultiIntervalSet为例进行分析：编写面向泛型的类时需要注意以下几点：①泛型类的声明：需要在类名后加上<L> publicclassMultiIntervalSet<L>implementsIMultiIntervalSet<L> ②需要用到泛型的地方，全部用L代替 protectedfinalSet<L>elabel=newHashSet<>(); protectedfinalMap<L,List<Interval>>emap=newHashMap<>(); ③只能对定义为泛型的变量做一些通用的操作：对于一个Llabel的泛型变量label，可以对它进行list.add(label)，set.contains(label)等操作，由于它在具体传入的时候已经变成了一个具体的类。但是想要显式地调用它自己的方法只能调用如下几种（此时感觉label就是一个原始的Object类）：要小心，不要代入某个具体的类型，调用它特有的方法；所以这也是泛型的一个局限性，对于通用的操作可以复用，但如果要用到某个具体类的方法，则不能将该类型作为参数传递。 ④泛型类中可以有非泛型方法，也可以有非泛型的成员变量。这点很好理解，泛型类中不一定每个方法都需要用到泛型，用到泛型时才是泛型方法；同时泛型类中当然也可以有具体类型的成员变量。 protectedfinalSet<L>elabel=newHashSet<>(); protectedfinalMap<L,List<Interval>>emap=newHashMap<>(); protectedIntervalduration; 最后给出一个泛型方法的例子 publicbooleanremove(Llabel){ if(!elabel.contains(label))returnfalse; else{ emap.remove(label); elabel.remove(label); checkRep(); returntrue; } } 总结 总之，写泛型类的时候要保持平常心，将L当作一个普通的类型去编写代码，开始时不要因为觉得L的写法陌生，而不敢对它进行操作，或者不愿意自定义泛型类/方法。 补充介绍：类型通配符 类型通配符一般是使用?代替具体的类型参数。例如List<?>在逻辑上是List<String>,List<Integer>等所有List<具体类型实参>的父类。①在某些情况下，我们必须使用到类型通配符，否则静态编译时会报错：比如：重写equals函数时用到instanceof运算符 @Overridepublicbooleanequals(Objectobj){ if(objinstanceofEdge<L>){ Edge<L>e=(Edge<L>)obj; // 后续逻辑省略 编译报错：CannotperforminstanceofcheckagainstparameterizedtypeEdge.UsetheformEdge<?>insteadsincefurthergenerictypeinformationwillbeerasedatruntime 修改为下图所示，编译通过。 if(objinstanceofEdge<?>){ Edge<?>e=(Edge<?>)obj; ②类型通配符还可以用于特定的情形比如限定类型的上/下限： List<?extendsNumber>限定接收类型的上限为Number，接受Number及其下层子类类型 List<?superNumber>限定接收类型的下限为Number，接受Number及其三层父类类型，如Object类型的实例。 
第466篇文章[]
多维软件视角 三维度八视图 多维软件视角 三个维度：阶段：Build（构造阶段），Run（运行阶段）层次：代码层面，构件层面时间：时刻，一段时间 视角一：Build-time,moment,andcode-levelview 词汇层面：源代码语法层面：抽象语法树（AST，AbstractSyntaxTree）语义层面：类图 视角二：Build-time,period,andcode-levelview Codechurn：代码变化（一段时间） 视角三：Build-time,moment,andcomponent-levelview 源代码被物理地组织成文件（File），这些文件又被目录组织起来；文件被封装到包（Package）中，逻辑上构成组件和子系统可重用模块以库（Library）的形式出现 静态链接发生在构造阶段，静态链接时，库被拷贝进入代码形成整体，执行的时候无需提供库文件 视角四：Build-time,period,andcomponent-levelview SoftwareConfigurationItem(SCI，配置项)Version(版本) 视角五：Run-time,moment,andcode-levelview Snapshotdiagram:代码快照图（描述程序运行时内存里变量层面的状态）Memorydump(内存信息转储) 视角六：Run-time,periodandcode-levelview Executiontracing执行跟踪用日志方式记录程序执行的调用次序（代码层面） 视角七：Run-time,moment,andcomponent-levelview Deploymentdiagram（部署图） 视角八：Run-time,period,andcomponent-levelview EventLog：事件日志，构件/系统层面 
第467篇文章[]
Java中的重载（Overload）机制详解及与重写（Override）的区别 文章目录 重载重载的定义重载的好处重载是一种静态多态重载的规则重载举例 重载与重写的区别 重载 重载的定义 重载：多个方法具有相同的名字，但有不同的参数列表 重载的好处 方便client（客户端）调用，client可用不同的参数列表，调用同样的函数 比如想要定义加法的方法，让它可以计算不同类型的数之和，有不同类型的返回值，可以如下定义： publicintadd(intx,inty){ returnx+y; } publicdoubleadd(doublex,doubley){ returnx+y; } 如果没有重载机制，那么想要定义两个具有相同/相似功能的方法，必须用不同函数名加以区分，如add1,add2，去定义和记住这些方法名字，对开发者和使用者都是一种负担。 重载是一种静态多态 重载是一种静态多态，根据参数列表进行最佳匹配，做静态类型检查，在编译阶段时决定要具体执行哪个方法。 与之相反，重写方法则是在运行时进行动态检查。 关于这一点，首先需要明白两个概念： 绑定：将调用的名字与实际的方法名字联系起来（可能很多个）分派：具体执行哪个方法（earlybinding→staticdispatch） 提前/静态绑定（Early/Staticbinding）每当一个方法的绑定发生时，所绑定的类型由编译器在编译时确定，然后绑定发生。 推迟/动态绑定（Late/Dynamicbinding）在重写父类和子类具有相同的方法时，对象的类型决定了要执行的方法。对象的类型在运行时确定。 类型分派原理发生阶段应用场景静态分派根据变量的静态类型编译期（不由Java虚拟机执行）Overload动态分派根据变量的动态类型运行期（由Java虚拟机执行）Override Overload方法：提前绑定和静态分派。 编译阶段即可确定要执行哪个具体操作。这个主要是针对多态性而言的。笔者理解为，如果发生了继承的情况，子类重载了父类的方法，由于参数列表不同，编译阶段可以很快检查并绑定到对应的方法，所以采取了这种earlybinding+staticdispatch的机制。 Override方法:推迟绑定和动态分派。 如果子类重写了父类的方法，编译阶段不知道对象类型，需要进行推迟绑定，在运行阶段决定具体执行哪个方法。 如果这一点不理解可以暂时跳过，但需要了解在哪个阶段进行检查与确定执行方法。即重载方法在编译时做静态类型检查，决定执行哪一个方法；而重写方法在运行时进行动态检查，并决定执行哪个方法。 重载的规则 必须有不同的参数列表可以有相同/不同的返回值类型可以有相同/不同的访问权限(public/private/protected)可以声明新的异常可以在同一个类内重载，也可在子类中重载 注意到，重载规则中最重要的也是最本质的是第一条规则：重载方法的参数列表必须改变，指的是参数个数/参数类型发生改变比如 //方法1（原方法） publicvoidchangeSize(intsize,Stringname,floatpattern){} //方法2 publicvoidchangeSize(intsize,Stringname){} //方法3 publicvoidchangeSize(intlength,Stringpattern,floatsize){} //方法4 publicbooleanchangeSize(intsize,Stringname,floatpattern){} 方法2即为方法1的重载方法，方法3、4均不是方法1的重载方法，参数列表（指参数类型和参数个数）与方法1相同方法3仅仅改变了参数变量名称，没有改变参数类型和个数方法4只是改变了方法返回类型，也没有改变参数列表 重载举例 下面我们来看一组子类重载父类方法的例子，加深我们的理解。注意，可以子类中重载，也可在同一个类内重载（像前述add方法可以放在同一个类中）；并不是像重写一样必须发生在父类和子类之间。首先定义两个类Animal和Horse，Horse类中重载了Animal中的eat方法，需要传入一个字符串变量 publicclassAnimal{ publicvoideat(){ System.out.println("undefined"); } } classHorseextendsAnimal{ publicvoideat(Stringfood){ System.out.println(food); } } 我们进行如下测试 //测试1 Animala=newAnimal(); a.eat(); 输出结果：undefined，调用Animal中的无参eat方法 //测试2 Horseh=newHorse(); h.eat(); 输出结果：undefined，调用Horse类中继承的无参eat方法 //测试3 Animalah=newHorse(); ah.eat(); 输出结果：undefined，由于没有参数，调用了Animal类中的无参eat方法 //测试4 Horsehe=newHorse(); he.eat("Apples"); 输出结果：Apples，调用Horse类中有参方法 //测试5 Animala2=newAnimal(); a2.eat("treats"); 编译报错：Themethodeat()inthetypeAnimalisnotapplicableforthearguments(String)，Animal类中没有带参数的eat方法，这里也再次说明了重载是一种静态多态，在编译时期进行静态检查。 //测试6 Animalah2=newHorse(); ah2.eat("Carrots"); 编译报错：Themethodeat()inthetypeAnimalisnotapplicableforthearguments(String)，Animal类中没有带参数的eat方法，尽管ah2具有多态性，但重载方法基于earlybinding和静态分派，编译时会做静态检查，到Animal的方法里去找带参数的eat，如果找到然后进行绑定，但是显然此处静态检查是出错的（找不到带参数的eat），所以编译报错。 重载与重写的区别 重载（Overload）重写（Override）参数列表必须改变必须不变返回值类型可以改变必须不变异常可以改变要么不抛出异常，要么抛出与父类方法相同的异常或该异常的子类访问权限可以改变子类的方法的访问权限不能小于父类调用引用类型确定选择哪个重载版本（基于声明的参数类型），在编译时发生对象类型（堆上实际实例的类型）决定了选择哪个方法，发生在运行时 
第468篇文章[]
(软件构造博客）List的浅拷贝和深拷贝 List的拷贝 在写实验的时候发现List的常见的复制方式复制完后的结果居然不是和原List无关的，查阅资料之后记录这一情况。首先展示一下我发现问题的一个简化示例： publicclassPerson{ privateStringname; privateintage; publicPerson(Stringname,intage) { this.name=name; this.age=age; } publicvoidsetAge(intage) { this.age=age; } @Override publicStringtoString() { returnthis.name+this.age; } publicstaticvoidmain(String[]argv) { List<Person>a=newArrayList<>(); Personp1=newPerson("john",20); Personp2=newPerson("jack",30); a.add(p1); a.add(p2); List<Person>b=newArrayList<>(); for(inti=0;i<a.size();i++) { b.add(a.get(i)); } System.out.println("刚复制完时："); System.out.println("a:"+a.toString()); System.out.println("b:"+b.toString()); b.get(1).setAge(40); System.out.println("修改b之后："); System.out.println("a:"+a.toString()); System.out.println("b:"+b.toString()); } } 输出结果如下： 刚复制完时： a:[john20,jack30] b:[john20,jack30] 修改b之后： a:[john20,jack40] b:[john20,jack40] 可以发现，a居然跟随着b的变化一起变化了，这显然和我们的设计要求不一致，接下来就来看看List的复制的几种情况。 1.浅拷贝 我们上面展示的这种方法就是浅拷贝的一种，可以说是我日常复制List的时候最常用的。顾名思义，浅拷贝将原List和拷贝List中的元素指向同一个地址，要是刚好这个元素的类型是mutable的，那么就会出现上述情况，修改b结果把a也给修改了。以下是浅拷贝的几种不同的方式 1.1遍历循环复制 也就是上述代码展示的了，不再赘述。 1.2使用List实现类的构造方法 如下代码展示，其实和遍历复制本质相同，只是使用了构造方法。 List<Person>b=newArrayList<>(a); 我们可以分析一下ArrayList的源码，就可以发现事实上它是利用了一个叫做copyOf的函数实现的构造函数的主要功能，构造函数源码如下： publicArrayList(Collection<?extendsE>c){ elementData=c.toArray(); if((size=elementData.length)!=0){ //c.toArraymight(incorrectly)notreturnObject[](see6260652) if(elementData.getClass()!=Object[].class) elementData=Arrays.copyOf(elementData,size,Object[].class); }else{ //replacewithemptyarray. this.elementData=EMPTY_ELEMENTDATA; } } 我们可以继续分析copyOf函数的源码，发现调用了一个System.arraycopy的函数，copyOf源码如下： publicstatic<T,U>T[]copyOf(U[]original,intnewLength,Class<?extendsT[]>newType){ @SuppressWarnings("unchecked") T[]copy=((Object)newType==(Object)Object[].class) ?(T[])newObject[newLength] :(T[])Array.newInstance(newType.getComponentType(),newLength); System.arraycopy(original,0,copy,0, Math.min(original.length,newLength)); returncopy; } 继续看System.arraycopy的源码，这是一个naive函数，那就不继续分析了，关键在于这个函数实现的功能就是实现数组之间的复制，而且由调用这一方法的构造函数也是浅拷贝的一种。 1.3list.addAll() 使用方法： List<Person>a=newArrayList<>(); Personp1=newPerson("john",20); Personp2=newPerson("jack",30); a.add(p1); a.add(p2); List<Person>b=newArrayList<>(); b.addAll(a); 源码如下： publicbooleanaddAll(Collection<?extendsE>c){ Object[]a=c.toArray(); intnumNew=a.length; ensureCapacityInternal(size+numNew);//IncrementsmodCount System.arraycopy(a,0,elementData,size,numNew); size+=numNew; returnnumNew!=0; } 通过简单查看其源码发现和构造函数的复制函数方法没什么两样，不再赘述。 1.4System.arraycopy() 不再赘述，和上面一样，调用方法参见addAll源码即可。 1.5使用Stream的方式copy 使用方法： List<Person>b=a.stream().collect(Collectors.toList()); 2.List深拷贝 和浅拷贝不同，那么显然深拷贝就是a与b的元素指向不同的地址，因此a与b内容相同，但是修改的时候互不影响，这才是我们在大多数情况下比较符合我们要求的拷贝方法。以下两种方法参考博客：https://blog.csdn.net/qq_35507234/article/details/85070429 2.1使用序列化方法 publicstatic<T>List<T>deepCopy(List<T>src)throwsIOException,ClassNotFoundException{ ByteArrayOutputStreambyteOut=newByteArrayOutputStream(); ObjectOutputStreamout=newObjectOutputStream(byteOut); out.writeObject(src); ByteArrayInputStreambyteIn=newByteArrayInputStream(byteOut.toByteArray()); ObjectInputStreamin=newObjectInputStream(byteIn); @SuppressWarnings("unchecked") List<T>dest=(List<T>)in.readObject(); returndest; } List<Person>destList=deepCopy(srcList);//调用该方法 2.2clone方法 publicclassAimplementsCloneable{ publicStringname[]; publicA(){ name=newString[2]; } publicObjectclone(){ Ao=null; try{ o=(A)super.clone(); }catch(CloneNotSupportedExceptione){ e.printStackTrace(); } returno; } } for(inti=0;i<n;i+=){ copy.add((A)src.get(i).clone()); } 3.使用场景 很显然，在没有特殊情况的时候使用浅拷贝绰绰有余，例如List中的元素如果是String，那么使用浅拷贝并不会存在a与b同时修改的情况，这是因为String是Immutable的，例如我们对b这个List中的某一个String进行修改，那么这个String会指向一段新的地址，而a的相同位置的元素指向原来的地址不变，因此不存在同步变化的情况，使用浅拷贝即可。但是如果我们真的需要使用一个元素是mutable类型的List的话，而且这个List还有可能在多处被复制使用的话就需要考虑深拷贝了。例如文章最开始那个例子，如果List的元素是自定义的Person类，而且这是一个mutable的ADT，那么使用浅拷贝可能存在风险。 
第469篇文章[6]
pycharm使用matploit绘图时无法输出中文解决方法 在代码中加上plt.rcParams[‘font.sans-serif’]=[u’SimHei’]plt.rcParams[‘axes.unicode_minus’]=False 
第470篇文章[6]
indexoutofrangeinself的解决方法 现在在使用pytorch中的Embedding层的时候出现了indexoutofrangeinself的报错，报错信息如下，现在记录一下解决方法。发现这个问题主要是由self.entity_embeddings(LongTensor[head]))这一条语句引起的，我的解决方法是把它换成self.entity_embeddings(Variable(LongTensor([head])))换了之后就不报错了，具体原因还没找到。 
第471篇文章[6]
网络正常但Chrome不能上网的解决方法 最近经常发生网络正常，但是Chrome无法连接网络的情况，记录解决方法：1.在Chrome的设置中打开电脑的代理设置：2.将自动检测打开之后点击保存：3.如果本来就是开着的可以尝试关闭之后再打开，点击保存。4.注意最后将Chrome浏览器关闭再重新打开，就可以正常上网了。 
第472篇文章[]
Amazon数据集网址 在构建知识图谱的时候大多需要使用Amazon的数据集，在此记录Amazon数据集网址。2014版：http://snap.stanford.edu/data/amazon/productGraph/2018版：http://deepyeti.ucsd.edu/jianmo/amazon/index.html两个版本略有不同，可以按需使用 
第473篇文章[]
（软件构造博客）immutable和mutable immutable和mutable 复习到了这一部分，记录一下immutable和mutable的性质与区别。 1.优缺点比较 首先先把二者的优缺点列出来： 优缺点immutablemutable缺点由于内部数据不可变，所以对其频发修改会产生大量的临时拷贝，浪费空间可变类型由于其内部数据可变，所以其风险更大优点内部数据的不可变导致其更加安全，可以用作多线程的共享对象而不必考虑同步问题可变类型会减少数据的拷贝次数，从而其效率要高于immutable 2.各自的定义 immutable：一个immutable的对象其值在指定了之后就不可再改变，如果试图修改其内部的值会新建一个新的地址保存新的值。mutable：一个mutable的对象其值在指定了之后还是可以修改的。 3.举例 在编程语言中这个概念是通用的，以下使用java来举例。首先，java中很典型的一个immutable的对象就是String。当对String完成初始化之后，String指向的这一段地址的内容就固定了，如果为这个String赋另外一个值，将会给这个String赋一段新的地址，这个新地址中存着新值，如果旧的地址将没有其他对象指向它，将等待回收。以下使用一个SnapShot图来表示这个过程。而mutable的一个例子就是List，java中的List、set、Map等对象都是可变的，这一点从它们都存在类似于add的方法就可以看出。mutable在改变值的时候不改变地址，而是直接修改原本地址中的值。 4.优缺点分析 每一种对象的存在和使用都是存在其合理性的。以下为两种对象使用过程中的优缺点分析。 4.1immutable 对于immutable来说，优点十分明显，就是它指向的地址的内容是不可变的，也就不存在两个对象都指向一个地址的时候其中一个对象无法知道另外一个对象是否对这个地址的内容进行修改。也就是说，immutable在很大程度上保证了多线程的时候的正确性。但是缺点同样十分明显，就是每一次修改都要进行一次复制，可能会产生很大的时间开销，同时会产生大量的需要回收的垃圾。例如对于如下代码片段： publicvoidtest(intn) { Strings=""; for(inti=0;i<n;i++) { s.concat(String.valueOf(i)); } } 对于第一个i来说进行了n次插入意味着复制了n次，也就是这个过程中时间复杂度是O(n^2)的，而这只是一个最简单的一层循环。 4.2mutable mutable由于其指向地址内容可变，因此每次修改的时候不需要复制，因此其开销比immutable小很多。但是其缺点就在于如果多个变量指向同一段地址的时候，其中一个对象对于地址内容的修改会影响到其他所有的变量的值，这种影响很有可能导致程序出错，例如如下代码片段： publicclassZoo{ privateList<String>animals; publicZoo(List<String>animals){ this.animals=animals; } publicList<String>getAnimals(){ returnthis.animals; } publicstaticvoidmain(String[]argv) { List<String>a=newArrayList<>(); a.addAll(Arrays.asList("lion","tiger","bear")); Zoozoo=newZoo(a); a.add("zebra"); System.out.println(a); System.out.println(zoo.getAnimals()); List<String>b=zoo.getAnimals(); b.add("flamingo"); System.out.println(a); } } 其中List是一个Mutable的对象，因此a，zoo.animals,b都指向了同一段内存空间，任何一个内容的修改都会造成三个值一起发生变化，因此main函数的输出如下：很显然这种输出在很大可能性下不是我们想要的，因此使用mutable是存在风险的。 5.使用场景 尽可能使用不可变的对象和不可变的引用。如果可以肯定某一段地址空间只会由一个对象指向，可以考虑使用mutable对象，但是使用的时候一定要注意不要产生多个对象修改一段空间内值的情况。 
第474篇文章[3]
leetcode746.使用最小花费爬楼梯c++ 746.使用最小花费爬楼梯 题目数组的每个索引作为一个阶梯，第i个阶梯对应着一个非负数的体力花费值cost【i】(索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为0或1的元素作为初始阶梯。示例1:输入:cost=[10,15,20]输出:15解释:最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。示例2:输入:cost=[1,100,1,1,1,100,1,1,100,1]输出:6解释:最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析这一题使用动态规划算法可以很快解决，但是其中有一些细节需要注意。首先，dp的大小应该是n+1，是因为最终需要站上顶层而不是最后一级台阶，需要将大小+1；其次需要考虑每一层最小的情况的可选区间。 代码 classSolution{ public: intminCostClimbingStairs(vector<int>&cost){ intn=cost.size(); vector<int>dp(n+1); for(inti=2;i<n+1;++i) { dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1]); } returndp.back(); } }; 
第475篇文章[1]
计算机系统大作业 程序人生-Hello’sP2P 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号班 级学生郑晟赫 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文主要通过分析hello这个程序的一生，回顾了这学期计算机系统这门课的几乎所有知识。在分析过程中使用ubuntu作为操作系统，并使用了一些工具辅助完成，目的是对于计算机系统的工作与原理有更深的了解。 关键词：计算机系统；程序的一生；P2P；O2O； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录第1章概述-5-1.1HELLO简介-5-1.2环境与工具-5-1.3中间结果-5-1.4本章小结-6-第2章预处理-7-2.1预处理的概念与作用-7-2.2在UBUNTU下预处理的命令-7-2.3HELLO的预处理结果解析-7-2.4本章小结-8-第3章编译-9-3.1编译的概念与作用-9-3.2在UBUNTU下编译的命令-9-3.3HELLO的编译结果解析-9-3.3.1数据-10-3.3.2赋值-12-3.3.3类型转换-12-3.3.4算术操作-13-3.3.5关系操作-13-3.3.6数组/指针/结构操作-14-3.3.7函数调用-14-3.4本章小结-15-第4章汇编-17-4.1汇编的概念与作用-17-4.2在UBUNTU下汇编的命令-17-4.3可重定位目标ELF格式-17-4.3.1命令-17-4.3.2ELF头-17-4.3.3节头表-18-4.3.4重定位节-18-4.3.5符号表-19-4.4HELLO.O的结果解析-19-4.5本章小结-21-第5章链接-22-5.1链接的概念与作用-22-5.2在UBUNTU下链接的命令-22-5.3可执行目标文件HELLO的格式-22-5.3.1ELF头-22-5.3.1节头-23-5.4HELLO的虚拟地址空间-23-5.5链接的重定位过程分析-24-5.6HELLO的执行流程-25-5.7HELLO的动态链接分析-26-5.8本章小结-27-第6章HELLO进程管理-28-6.1进程的概念与作用-28-6.2简述壳SHELL-BASH的作用与处理流程-28-6.3HELLO的FORK进程创建过程-29-6.4HELLO的EXECVE过程-29-6.5HELLO的进程执行-29-6.6HELLO的异常与信号处理-30-6.7本章小结-34-第7章HELLO的存储管理-35-7.1HELLO的存储器地址空间-35-7.2INTEL逻辑地址到线性地址的变换-段式管理-35-7.3HELLO的线性地址到物理地址的变换-页式管理-36-7.4TLB与四级页表支持下的VA到PA的变换-36-7.5三级CACHE支持下的物理内存访问-37-7.6HELLO进程FORK时的内存映射-38-7.7HELLO进程EXECVE时的内存映射-38-7.8缺页故障与缺页中断处理-39-7.9动态存储分配管理-39-7.10本章小结-40-第8章HELLO的IO管理-41-8.1LINUX的IO设备管理方法-41-8.2简述UNIXIO接口及其函数-41-8.3PRINTF的实现分析-42-8.4GETCHAR的实现分析-43-8.5本章小结-43-结论-44-附件-45-参考文献-46- 第1章概述1.1Hello简介根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。P2P：首先，Hello的开始是一段储存在磁盘上的程序文本（Program），在需要使用这一个代码文件的时候，用预处理器处理hello.c文件，生成一个hello.i文件，也就是修改了的源程序，之后，hello.i输入编译器，编译器将生成一个hello.s文件，在这一步之前所有的文件都还是文本形式，还没有转换为二进制机器码格式。生成的hello.s文件将输入汇编器，产生一个hello.o，也就是可重定位程序，可重定位文件经过链接器的链接将生成可执行目标程序hello，此时在shell中调用相关命令将为其创建进程（Process），执行程序。O2O：在shell中输入相关命令后，shell将调用fork函数为这一程序创建进程，之后将通过exceve在进程的上下文中加载并运行hello，将进程映射到虚拟内存空间，并加载需要的物理内存。执行时，在CPU的分配下，指令进入CPU流水线执行。当执行结束后父进程将回收这一进程，内核将清除这一进程的相关信息，这一进程就结束了。1.2环境与工具列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。硬件环境：处理器：Intel®Core™i7-9750HCPU@2.60GHzRAM：32.00GB系统：64位操作系统，基于x64的处理器软件环境：Windows1064位；Ubuntu20.04开发与调试工具：gcc，as，ld，vim，edb，readelf，gedit，gdb1.3中间结果列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 中间结果文件名称文件作用Hello.i预处理后的文件Hello.s汇编程序Hello.o可重定位目标文件Hello可执行目标程序Elf.txtHello.o的ELF格式Dis_hello.txtHello.o的反汇编代码Hello.elfHello的elf格式文件Hello.txtHello的反汇编代码 1.4本章小结这一章主要堆hello在执行的过程中的总体流程进行了简要的概述，以及在实验中使用的软硬件条件以及实验中产生的文件。（第1章0.5分） 第2章预处理2.1预处理的概念与作用概念：预处理器（cpp）根据以字符#开头的命令，修改原始的c程序。作用：1.处理头文件：比如hello.c的第一行的#include<stdio.h>命令告诉预处理器读取系统有文件stdio.h的内容，并把它直接插入程序文本中。2.处理宏定义：对于#define指令，进行宏替换，对于代码中所有使用宏定义的地方使用符号表示的实际值替换定义的符号3.处理条件编译：根据可能存在的#ifdef来确定程序需要执行的代码段。4.处理特殊符号：例如#error等，预编译程序可以识别一些特殊的符号，并在后续过程中进行合适的替换。5.删除c语言源程序中的注释部分。2.2在Ubuntu下预处理的命令cpphello.c>hello.i 图2.1ubuntu下的预处理命令2.3Hello的预处理结果解析可以发现，原本的源代码文件只有28行，预处理后的文件为3074行，原本的源代码部分在3055行之后，在这之前是hello引用的所有的头文件stdio.h,unistd.h,stdlib.h内容的展开。而很显然我们发现插入的部分不止有这三个头文件的内容，还出现了其他的头文件，这是以为这三个头文件中同样使用#include命令引入了其他的头文件，这些头文件同样出现在了hello.i文件中。插入的库文件的具体信息如下图所示： 图2.2头文件信息可以观察如下两张图，我们发现在源代码头部出现的注释在预处理之后的源代码部分已经不可见，因此这一点就印证了我们上面说的在预处理过程中预处理器将删除源代码中的注释部分。由于源代码中不存在宏定义与#ifdef等部分，因此这一部分无法展示。 图2.3预处理后的源代码部分图2.4源代码文件2.4本章小结这一部分介绍了在预处理过程中预处理器的工作（头文件展开，宏替换，删除注释，条件替换等），同时使用ubuntu系统展示了对于hello.c文件的预处理过程与预处理结果。 （第2章0.5分） 第3章编译3.1编译的概念与作用概念：编译器（ccl）将文本文件hello.i翻译成文本文件hello.i，它包含一个汇编语言程序。作用：编译的主要作用可以分为如下几个部分： 扫描（词义分析）：将源代码程序输入扫描器，将源代码中的字符序列分割为一系列c语言中的符合语法要求的字符单元，这一部分可以分为自上而下的分析和自下而上的分析两种方式。语法分析：基于词法分析得到的字符单元生成语法分析树。语义分析：在语法分析完成之后由语义分析妻进行语义分析，主要就是为了判断指令是否是合法的c语言指令，这一部分也可以叫做静态语义分析，并不判断一些在执行时可能出现的错误，例如如果不存在IDE优化，这一步对于1/0这种只有在动态类型检查的时候才会发现的错误，代码将不会报错。中间代码：中间代码的作用是可使使得编译程序的逻辑更加明确，主要是为了下一步代码优化的时候优化的效果更好。代码优化：根据用户指定的不同优化等级对代码进行安全的、等价的优化，这一行为的目的主要是为了提升代码在执行时的性能。生成代码：生成是编译的最后一个阶段。在经过上面的所有过程后，在这一过程中将会生成一个汇编语言代码文件，也就是我们最后得到的hello.s文件，这一文件中的源代码将以汇编语言的格式呈现。 3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 图3.1ubuntu下编译的命令3.3Hello的编译结果解析 3.3.1数据①常量数字常量：通过观察我们可以发现在源代码中使用的数字常量都是储存在.text段的，包括在比较的时候使用的数字变量3，在循环的时候使用的循环比较变量等数字常量都是储存在.text节的，具体情况可以见如下截图： 图3.2数字变量储存情况字符串常量：可以发现在printf等函数中使用的字符串常量是储存在.rotate段的，具体储存情况可以见如下截图： 图3.3字符常量储存情况②变量全局变量：在代码中存在一个全局变量，也就是在sleep中需要使用的sleepsecs变量，通过观察编译后的结果我们可以发现这一个全局变量放在了.data段，且大小被设置为4个字节，这一变量的初始化不需要其他的汇编语句，在刚开始的时候就初始化好了，详细情况可见如下截图： 图3.4全局变量储存情况局部变量：可以发现局部变量是储存在栈中的某一个位置的或是直接储存在寄存器中的，对于源代码中的每一个局部变量可以进行逐一分析。局部变量共有三个，一个是循环变量i，以及argc和argv，对于i，我们发现它储存在栈中地址为-4（%rbp）的位置，对于i的操作可见如下截图： 图3.5局部变量i的储存情况对于局部变量argc，标志的是在程序运行的时候输入的变量的个数，可以发现它储存在栈中地址为-20（%rbp）的位置，对于它的操作主要是与3比较之后确定有一部分代码是否执行，具体汇编代码如下截图： 图3.6局部变量argc的储存情况对于局部变量argv，是一个保存着输入变量的数组，观察发现它储存在栈中，具体汇编代码段如下： 图3.7局部变量argv的储存情况3.3.2赋值可以发现对于变量的赋值在代码中出现了两次，一次是对于全局变量sleepsecs的赋值，一次是对于循环变量i的在循环中的赋值，可以分别进行分析。对于全局变量的赋值正如我们在上面看到的图3.4中展示的一样，在编译完成的时候就已经完成了对于全局变量sleepsecs的赋值，因此不需要其他的赋值语句。对于局部变量i，每次循环结束的时候都对齐进行+1操作，具体的操作汇编代码如下: 图3.8对局部变量i的赋值操作3.3.3类型转换对于全局变量sleepsecs事实上是存在一个隐式类型转换的，对于int型的全局变量赋值为2.5，很显然最后sleepsecs的值将会是2，在这里发生了由float向int转换的隐式类型转换，这一点也可以在汇编代码中得到验证： 图3.9sleepsecs发生的隐式类型转换可以发现第9行中sleepsec被初始化为2，这也印证了类型转换的发生。3.3.4算术操作对于局部变量i，由于其是循环变量，因此在每一轮的循环中都要修改这个值，对于这个局部变量的算术操作的汇编代码如下： 图3.10对局部变量i的算术操作3.3.5关系操作源代码中一共出现了两处关系操作，具体情况可以分别分析。第一处是对于argc的判断，当等于3的时候将进行条件跳转，其中源代码片段如下： 图3.11关系操作1源代码而对应的汇编代码如下： 图3.12关系操作1汇编代码另一处是在for循环中对于循环变量i的判断，这一段的汇编代码如下图所示，当循环变量i大于等于9的时候将进行条件跳转。 图3.13关系操作2汇编代码3.3.6数组/指针/结构操作这一段代码中出现的数组操作只有一个，也就是对于argv数组的操作，观察汇编代码可以发现argv储存的两个值都存放在栈中，argv[1]的储存地址是-24（%rbp），而argv[1]的储存地址是-16（%rbp），对于数组操作的汇编代码如下截图： 图3.14数组操作3.3.7函数调用在这一段代码中出现了几个函数调用的情况，首先明确在X86系统中函数参数储存的规则，第1~6个参数依次储存在%rdi、%rsi、%rdx、%rcx、%r8、%r9这六个寄存器中，其余的参数保存在栈中的某些位置。Main函数：参数：传入参数argc和argv，其中argv储存在栈中，argc储存在%rdi中返回：在源代码中最后的返回语句是return0，因此在汇编代码中最后是将%eax设置为0并返回这一寄存器。汇编代码如下： 图3.15main函数汇编代码Printf函数：参数：第一次调用的时候只传入了字符串参数首地址；for循环中调用的时候传入了argv[1]和argc[2]的地址。调用：第一次是满足if条件的时候调用，第二次是在for循环条件满足的时候调用。具体汇编代码如下： 图3.16printf第一次调用 图3.17printf第二次调用Sleep函数：函数以全局变量sleepsecs为参数，这一参数储存在%edi中，这一函数在for循环的条件下被调用，详细汇编代码如下： 图3.18sleep函数调用Exit函数：参数：传入的参数为1，执行退出命令。调用：当if条件满足的时候调用这一函数。具体汇编代码如下： 图3.19exit函数的调用3.4本章小结本章主要介绍了在将修改了的源程序文件转换为汇编程序的时候主要发生的变化以及汇编代码文件中主要存在的部分以及源代码中的一些主要的操作对应的汇编代码中的汇编代码的展现形式。总的来说，编译器做的就是在进行词义分析和语义分析之后判断源代码符合语法要求之后将其转换为汇编代码。（第3章2分） 第4章汇编4.1汇编的概念与作用概念：汇编器as将hello.s翻译成机器语言指令，把这些指令打包成一种叫可重定位目标程序的格式，并将结果保存在目标文件hello.o中。（hello.o是一个二进制文件）。作用：将汇编代码根据特定的转换规则转换为二进制代码，也就是机器代码，机器代码也是计算机真正能够理解的代码格式。4.2在Ubuntu下汇编的命令命令：ashello.s-ohello.o 图4.1ubuntu下的汇编命令4.3可重定位目标elf格式4.3.1命令readelf-ahello.o>./elf.txt使用这一命令导出我们需要的elf的文件 图4.2生成可重定位目标elf格式4.3.2ELF头ELF头以一个16字节的序列开始，这个序列描述了生成该文件系统下的字的大小以及一些其他信息。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息：包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量。具体ELF头的代码如下： 图4.3ELF头4.3.3节头表描述了.o文件中每一个节出现的位置，大小，目标文件中的每一个节都有一个固定大小的条目。具体内容如下图所示： 图4.4节头表4.3.4重定位节重定位节中包含了在代码中使用的一些外部变量等信息，在链接的时候需要根据重定位节的信息对这些变量符号进行修改。链接的时候链接器会根据重定位节的信息对外部变量符号决定选择何种方法计算正确的地址，通过偏移量等信息计算出正确的地址。本程序需要重定位的信息有：.rodata中的模式串，puts，exit，printf，slepsecs，sleep，getchar这些符号同样需要与相应的地址进行重定位。具体重定位节的信息如下图所示： 图4.5重定位节信息4.3.5符号表.symtab是一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。例如本程序中的getchar、puts、exit等函数名都需要在这一部分体现，具体信息如下图所示： 图4.6符号表内容4.4Hello.o的结果解析命令：objdump-d-rhello.o>Disas_hello.s反汇编代码如下： hello.o：文件格式elf64-x86-64 Disassemblyofsection.text: 0000000000000000:0:55push%rbp1:4889e5mov%rsp,%rbp4:4883ec20sub$0x20,%rsp8:897decmov%edi,-0x14(%rbp)b:488975e0mov%rsi,-0x20(%rbp)f:837dec03cmpl$0x3,-0x14(%rbp)13:7416je2b<main+0x2b>15:488d3d00000000lea0x0(%rip),%rdi#1c<main+0x1c>18:R_X86_64_PC32.rodata-0x41c:e800000000callq21<main+0x21>1d:R_X86_64_PLT32puts-0x421:bf01000000mov$0x1,%edi26:e800000000callq2b<main+0x2b>27:R_X86_64_PLT32exit-0x42b:c745fc00000000movl$0x0,-0x4(%rbp)32:eb3bjmp6f<main+0x6f>34:488b45e0mov-0x20(%rbp),%rax38:4883c010add$0x10,%rax3c:488b10mov(%rax),%rdx3f:488b45e0mov-0x20(%rbp),%rax43:4883c008add$0x8,%rax47:488b00mov(%rax),%rax4a:4889c6mov%rax,%rsi4d:488d3d00000000lea0x0(%rip),%rdi#54<main+0x54>50:R_X86_64_PC32.rodata+0x2154:b800000000mov$0x0,%eax59:e800000000callq5e<main+0x5e>5a:R_X86_64_PLT32printf-0x45e:8b0500000000mov0x0(%rip),%eax#64<main+0x64>60:R_X86_64_PC32sleepsecs-0x464:89c7mov%eax,%edi66:e800000000callq6b<main+0x6b>67:R_X86_64_PLT32sleep-0x46b:8345fc01addl$0x1,-0x4(%rbp)6f:837dfc09cmpl$0x9,-0x4(%rbp)73:7ebfjle34<main+0x34>75:e800000000callq7a<main+0x7a>76:R_X86_64_PLT32getchar-0x47a:b800000000mov$0x0,%eax7f:c9leaveq80:c3retq分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。可以发现有如下几点不同： 进制不同：hello.s反汇编之后对于数字的表示是十进制的，而hello.o反汇编之后数字的表示是十六进制的。分支转移：对于条件跳转，hello.s反汇编中给出的是段的名字，例如.L2等来表示跳转的地址，而hello.o由于已经是可重定位文件，对于每一行都已经分配了相应的地址，因此跳转命令后跟着的是需要跳转部分的目标地址。函数调用：hello.s中，call指令后跟的是需要调用的函数的名称，而hello.o反汇编代码中call指令使用的是main函数的相对偏移地址。同时可以发现在hello.o反汇编代码中调用函数的操作数都为0，即函数的相对地址为0，因为再链接生成可执行文件后才会生成其确定的地址，所以这里的相对地址都用0代替。4.5本章小结本章对汇编过程进行了一个简单但是完整的叙述。经过汇编器之后，生成了一个可重定位的文件，为下一步链接做好了准备。通过与hello.s的反汇编代码的比较，更加深入的理解了在汇编过程中发生的变化，这些变化都是为了链接做准备的。（第4章1分） 第5章链接5.1链接的概念与作用概念：链接是将各种不同文件的代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。作用：把预编译好了的若干目标文件合并成为一个可执行目标文件。使得分离编译称为可能，不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为可独立修改和编译的模块。当改变这些模块中的一个时，只需简单重新编译它并重新链接即可，不必重新编译其他文件。5.2在Ubuntu下链接的命令命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1ubuntu下的链接命令5.3可执行目标文件hello的格式命令：readelf-ahello>hello1.elf5.3.1ELF头包含内容与汇编中4.3.2节展示的类似，详细内容截图如下：分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 图5.2ELF头5.3.1节头描述了各个节的大小、偏移量和其他属性。链接器链接时，会将各个文件的相同段合并成一个大段，并且根据这个大段的大小以及偏移量重新设置各个符号的地址。详细内容如下： 图5.3节头表部分内容5.4hello的虚拟地址空间使用edb打开hello可执行文件，可以在edb的DataDump窗口看到hello的虚拟地址空间分配的情况，具体内容截图如下： 图5.4edb中的datadump视图可以发现这一段程序的地址是从0x401000开始的，并且该处有ELF的标识，可以判断从可执行文件时加载的信息。接下来可以分析其中的一些具体的内容：其中PHDR保存的是程序头表；INTERP保存了程序执行前需要调用的解释器；LOAD记录程序目标代码和常量信息；DYNAMIC储存了动态链接器所使用的信息；NOTE记录的是一些辅助信息；GNU_EH_FRAME保存异常信息；GNU_STACK使用系统栈所需要的权限信息；GNU_RELRO保存在重定位之后只读信息的位置。5.5链接的重定位过程分析命令：objdump-d-rhello>hello_objdump.s 图5.5hello反汇编代码部分hello与hello.o的不同：1.在链接过程中，hello中加入了代码中调用的一些库函数，例如getchar，puts，printf，等，同时每一个函数都有了相应的虚拟地址。例如exit函数的虚拟地址如下图： 图5.6exit链接后虚拟地址展示2.对于全局变量的引用，由于hello.o中还未对全局变量进行定位，因此hello.o中用0加上%rip的值来表示全局变量的位置，而在hello中，由于已经进行了定位，因此全局变量的的值使用一个确切的值加上%rip表示全局变量的位置。 图5.7hello中全局变量的表示3.hello中增加了.init和.plt节，和一些节中定义的函数。4.hello中无hello.o中的重定位条目，并且跳转和函数调用的地址在hello中都变成了虚拟内存地址。这是由于hello.o中对于函数还未进行定位，只是在.rel.text中添加了重定位条目，而hello进行定位之后自然不需要重定位条目。5．地址访问：在链接完成之后，hello中的所有对于地址的访问或是引用都调用的是虚拟地址地址。例如下图中84行条件跳转代码所示： 图5.8hello中的地址访问链接的过程：链接主要分为两个过程：符号解析和重定位。符号解析：目标文件定义和引用符号，符号解析将每个符号引用和一个符号定义关联起来。重定位：编译器和汇编器生成从0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。5.6hello的执行流程根据反汇编代码可以看出执行函数及虚拟内存地址如下：401000<_init>401020<.plt>401030puts@plt401040printf@plt401050getchar@plt401060atoi@plt401070exit@plt401080sleep@plt401090<_start>4010c0<_dl_relocate_static_pie>4010c1401150<__libc_csu_init>4011b0<__libc_csu_fini>4011b4<_fini> 图5.9使用edb执行hello过程截图5.7Hello的动态链接分析当程序调用一个由共享库定义的函数时，由于编译器无法预测这时候函数的地址是什么，因此这时，编译系统提供了延迟绑定的方法，将过程地址的绑定推迟到第一次调用该过程时。通过GOT和过程链接表PLT的协作来解析函数的地址。在加载时，动态链接器会重定位GOT中的每个条目，使它包含正确的绝对地址，而PLT中的每个函数负责调用不同函数。那么，通过观察edb，便可发现dl_init后.got.plt节发生的变化。首先可以观察elf中.got.plt节的内容 图5.10elf中.got.plt的内容使用edb查看时有如下发现： 图5.11执行init之前的地址 图5.12执行init之后的地址5.8本章小结在链接过程中，各种代码和数据片段收集并组合为一个单一文件。利用链接器，分离编译称为可能，我们不用将应用程序组织为巨大的源文件，只是把它们分解为更小的管理模块，并在应用时将它们链接就可以完成一个完整的任务。经过链接，已经得到了一个可执行文件，接下来只需要在shell中调用命令就可以为这一文件创建进程并执行该文件。（第5章1分） 第6章hello进程管理6.1进程的概念与作用概念：进程是执行中程序的抽象。作用：在现代系统上运行一个程序时，我们会得到一个假象，好像我们的程序是系统中唯一运行的程序一样。我们的程序好像独占处理器和内存。处理器好像无间断地一条接一条执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象是通过进程的概念提供的。进程提供给应用程序的关键抽象：1）一个独立的逻辑控制流，提供一个程序独占处理器的假象；2）一个私有的地址空间，提供一个程序独占地使用内存系统的假象。6.2简述壳Shell-bash的作用与处理流程作用：shell执行一系列的读/求值步骤，然后终止。读步骤读取来自用户的一个命令行，求值步骤解析命令行，并根据解析结果运行程序。处理流程：1．Shell首先从命令行中找出特殊字符（元字符），在将元字符翻译成间隔符号。元字符将命令行划分成小块tokens。Shell中的元字符如下所示：SPACE,TAB,NEWLINE,&,;,(,),<,>,|2．程序块tokens被处理，检查看他们是否是shell中所引用到的关键字。3．当程序块tokens被确定以后，shell根据aliases文件中的列表来检查命令的第一个单词。如果这个单词出现在aliases表中，执行替换操作并且处理过程回到第一步重新分割程序块tokens。4．Shell对~符号进行替换。5．Shell对所有前面带有 符 号 的 变 量 进 行 替 换 。 6 ． S h e l l 将 命 令 行 中 的 内 嵌 命 令 表 达 式 替 换 成 命 令 ； 他 们 一 般 都 采 用 符号的变量进行替换。6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用 符号的变量进行替换。6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用(command)标记法。7．Shell计算采用$(expression)标记的算术表达式。8．Shell将命令字符串重新划分为新的块tokens。这次划分的依据是栏位分割符号，称为IFS。缺省的IFS变量包含有：SPACE,TAB和换行符号。9．Shell执行通配符*?[]的替换。10．shell把所有从处理的结果中用到的注释删除，并且按照下面的顺序实行命令的检查：A.内建的命令B.shell函数（由用户自己定义的）C.可执行的脚本文件（需要寻找文件和PATH路径）11．在执行前的最后一步是初始化所有的输入输出重定向。12．最后，执行命令。[1]6.3Hello的fork进程创建过程父进程通过调用fork函数创建一个新的运行的子进程。调用fork函数后，新创建的子进程几乎但不完全与父进程相同:子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本，包括代码、数据段、堆、共享库以及用户栈，子进程获得与父进程任何打开文件描述符相同的副本，这意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。fork被调用一次，却返回两次,子进程返回0，父进程返回子进程的PID。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。6.4Hello的execve过程exceve函数在当前进程的上下文中加载并运行一个新程序。exceve函数加载并运行可执行目标文件，并带参数列表和环境变量列表。只有当出现错误时，exceve才会返回到调用程序。所以，与fork一次调用返回两次不同，在exceve调用一次并从不返回。当加载可执行目标文件后，exceve调用启动代码，启动代码设置栈，将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序，由此将控制传递给新程序的主函数。6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。进程调度：即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器（PC）的值，这些值唯一的对应于包含在运行时动态链接到程序的共享对象中的指令。这个PC的序列叫做逻辑控制流，或者简称逻辑流。进程是轮流适用处理器的，每个进程执行它的流的一部分，然后被抢占，然后轮到其他进程。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策就叫做调度，是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行，我们说内核调度了这个进程。在内核调度了一个新的进程运行了之后，它就抢占了当前进程，并使用上下文切换机制来将控制转移到新的进程。内核模式转变到用户模式：操作系统内核使用上下文切换来实现多任务。内核为每个进程维持一个上下文，它是内核重启被抢占的进程所需的状态，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构的值。进程执行到某些时刻，内核可决定抢占该进程，并重新开启一个先前被抢占了的进程，这种决策称为调度。内核调度一个新的进程运行后，通过上下文切换机制来转移控制到新的进程：1）保存当前进程上下文；2）恢复某个先前被抢占的进程被保存的上下文3）将控制转移给这个新恢复的进程。当内核代表用户执行系统调用时，可能会发生上下文切换，这时就存在着用户态与核心态的转换。如下图所示： 图6.1上下文切换6.6hello的异常与信号处理正常执行状态： 图6.2程序正常执行状态异常类型：类别原因异步/同步返回行为中断来自I/O设备的信号异步总是返回到下一条指令陷阱有意的异常同步总是返回到下一条指令故障潜在可恢复的错误同步可能返回到当前指令终止不可恢复的错误同步不会返回处理方式： 图6.3中断处理方式 图6.4陷阱处理方式 图6.5故障处理方式 图6.6终止处理方式不停乱按：将屏幕的输入缓存到缓冲区。乱码被认为是命令，不影响当前进程的执行。 图6.7运行时不停乱按按下Ctrl-Z：程序运行时按Ctrl-Z，这时，产生中断异常，它的父进程会接收到信号SIGSTP并运行信号处理程序，然后便发现程序在这时被挂起了，并打印了相关挂起信息。 图6.8运行时按下Ctrl-ZCtrl-Z后运行ps，打印出了各进程的pid，可以看到之前挂起的进程hello。 图6.9挂起hello后执行psCtrl-Z后运行jobs，打印出了被挂起进程组的jid，可以看到之前被挂起的hello，以被挂起的标识Stopped。 图6.10挂起hello后执行jobsCtrl-Z后运行pstree，可看到它打印出的信息： 图6.11挂起hello后执行pstreeCtrl-Z后运行fg：因为之前运行jobs是得知hello的jid为1，那么运行fg1可以把之前挂起在后台的hello重新调到前台来执行，打印出剩余部分，然后输入hello回车，程序运行结束，进程被回收。 图6.12挂起hello后执行fgCtrl-Z后运行Kill：重新执行进程，可以发现hello的进程号为34230，那么便可通过kill-934230发送信号SIGKILL给进程34230，它会导致该进程被杀死。然后再运行ps，可发现已被杀死的进程hello。 图6.13挂起hello后执行kill按下Ctrl-C：进程收到SIGINT信号，结束hello。在ps中查询不到其PID，在job中也没有显示，可以看出hello已经被彻底结束。 图6.14运行hello时按下Ctrl-C6.7本章小结本章主要介绍了hello可执行文件的执行过程，包括进程创建、加载和终止，以及通过键盘输入等过程。从创建进程到进程并回收进程，这一整个过程中需要各种各样的异常和中断等信息。程序的高效运行离不开异常、信号、进程等概念，正是这些机制支持hello能够顺利地在计算机上运行。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：逻辑地址指由程序产生的与段相关的偏移地址部分，也叫相对地址。要经过寻址方式的计算或变换才得到内存储器中的实际有效地址，即物理地址。从hello的反汇编代码中看到的地址，它们需要通过计算，通过加上对应段的基地址才能得到真正的地址，这些便是hello中的逻辑地址。线性地址：是逻辑地址到物理地址变换之间的中间层。程序hello的代码会产生逻辑地址，hello的反汇编文件中看到的地址（即逻辑地址）中的偏移量，加上对应段的基地址，便得到了hello中内容对应的线性地址。虚拟地址：有时我们也把逻辑地址称为虚拟地址。因为与虚拟内存空间的概念类似，逻辑地址也是与实际物理内存容量无关的，是hello中的虚拟地址。物理地址：是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。在hello的运行中，在访问内存时需要通过CPU产生虚拟地址，然后通过地址翻译得到一个物理地址，并通过物理地址访问内存中的位置。7.2Intel逻辑地址到线性地址的变换-段式管理逻辑地址由段选择符和偏移量组成，线性地址为段首地址与逻辑地址中的偏移量组成。其中，段首地址存放在段描述符中。而段描述符存放在描述符表中，也就是GDT（全局描述符表）或LDT（局部描述符表）中。 图7.1段式管理示意图段式管理特点:1.段式管理以段为单位分配内存，每段分配一个连续的内存区。2.由于各段长度不等，所以这些存储区的大小不一。3.同一进程包含的各段之间不要求连续。4.段式管理的内存分配与释放在作业或进程的执行过程中动态进行。7.3Hello的线性地址到物理地址的变换-页式管理页式管理是一种内存空间存储管理的技术，页式管理分为静态页式管理和动态页式管理。将各进程的虚拟空间划分成若干个长度相等的页(page)，页式管理把内存空间按页的大小划分成片或者页面（pageframe），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。线性地址（虚拟地址）由虚拟页号VPN和虚拟页偏移VPO组成。首先，MMU从线性地址中抽取出VPN，并且检查TLB，看他是否因为前面某个内存引用缓存了PTE的一个副本。TLB从VPN中抽取出TLB索引和TLB标记，查找对应组中是否有匹配的条目。若命中，将缓存的PPN返回给MMU。若不命中，MMU需从页表中的PTE中取出PPN，若得到的PTE无效或标记不匹配，就产生缺页，内核需调入所需页面，重新运行加载指令，若有效，则取出PPN。最后将线性地址中的VPO与PPN连接起来就得到了对应的物理地址。 图7.2Corei7地址翻译7.4TLB与四级页表支持下的VA到PA的变换每次CPU产生一个虚拟地址，MMU（内存管理单元）就必须查阅一个PTE（页表条目），以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会从内存多取一次数据，代价是几十到几百个周期。如果PTE碰巧缓存在L1中，那么开销就会下降1或2个周期。然而，许多系统都试图消除即使是这样的开销，它们在MMU中包括了一个关于PTE的小的缓存，称为翻译后备缓存器（TLB）。虚拟地址VA虚拟页号VPN和虚拟页偏移VPO组成。若TLB命中时，所做操作与7.3中相同；若TLB不命中时，VPN被划分为四个片，每个片被用作到一个页表的偏移量，CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，依次类推。最后在L4页表中对应的PTE中取出PPN，与VPO连接，形成物理地址PA。 图7.3多级页表管理7.5三级Cache支持下的物理内存访问MMU将物理地址发给L1缓存，缓存从物理地址中取出缓存偏移CO、缓存组索引CI以及缓存标记CT。若缓存中CI所指示的组有标记与CT匹配的条目且有效位为1，则检测到一个命中条目，读出在偏移量CO处的数据字节，并把它返回给MMU，随后MMU将它传递给CPU。若不命中，则在下一级cache或是主存中寻找需要的内容，储存到上一级cache后再一次请求读取。 图7.4存储器层次结构7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给他一个唯一的pid。为了给这个新进程创建虚拟内存，系统创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有写时复制。当fork从新进程返回，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要：(1)删除已存在的用户区域(2)映射私有区域:为新程序hello的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。(3)映射共享区域:如果hello程序与共享对象（或目标）链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。(4)设置程序计数器(PC),指向代码的入口点。7.8缺页故障与缺页中断处理页面命中完全是由硬件完成的，而处理缺页是由硬件和操作系统内核协作完成的： 处理器生成一个虚拟地址，并将它传送给MMUMMU生成PTE地址，并从高速缓存/主存请求得到它高速缓存/主存向MMU返回PTEPTE中的有效位是0，所以MMU出发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。缺页处理程序确认出物理内存中的牺牲页，如果这个页已经被修改了，则把它换到磁盘。缺页处理程序页面调入新的页面，并更新内存中的PTE缺页处理程序返回到原来的进程，再次执行导致缺页的命令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面已经换存在物理内存中，所以就会命中。 图7.5缺页操作示意图7.9动态存储分配管理定义：一种内存管理方法。对内存空间的分配、回收等操作在进程执行过程中进行，以便更好地适应系统的动态需求，提高内存利用率。分配器的基本风格： 显示分配器：要求应用显示地释放任何已分配的块。隐式分配器：要求分配器检测一个已分配的块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器。基本方法与策略：1.带边界标签的隐式空闲链表分配器管理带边界标记的隐式空闲链表的每个块是由一个字的头部、有效载荷、可能的额外填充以及一个字的尾部组成的。当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个符合大小的空闲块来放置这个请求块。分配器有三种放置策略：首次适配、下一次适配合最佳适配。在释放一个已分配块的时候需要考虑是否能与前后空闲块合并，减少系统中碎片的出现。2.显示空间链表管理显式空闲链表是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。如，堆可以组织成一个双向链表，在每个空闲块中，都包含一个前驱与一个后继指针。放置策略与上述放置策略一致。7.10本章小结本章主要介绍了hello进程在执行的过程中的虚拟内存与物理内存之间的转换关系，以及一些支持这些转换的硬件或软件机制。同时介绍了在发生缺页异常的时候系统将会如何处理这一异常。最后介绍了动态内存分配的作用以及部分方法与策略。 （第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件。所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入输出都被当做对相应文件的读和写来执行。设备管理：unixio接口。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。8.2简述UnixIO接口及其函数UnixIO接口：打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（文件描述符0）、标准输出（描述符为1），标准出错（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，他们可用来代替显式的描述符值。改变当前的文件位置，文件开始位置为文件偏移量，应用程序通过seek操作，可设置文件的当前位置为k。读写文件，读操作：从文件复制n个字节到内存，从当前文件位置k开始，然后将k增加到k+n；写操作：从内存复制n个字节到文件，当前文件位置为k，然后更新k。关闭文件：当应用完成对文件的访问后，通知内核关闭这个文件。内核会释放文件打开时创建的数据结构，将描述符恢复到描述符池中UnixIO函数：(1).打开文件：intopen(char*filename,intflags,mode_tmode);Open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程当中没有打开的最小描述符。Flags参数指明了进程打算如何访问这个文件，同时也可以是一个或者更多为掩码的或，为写提供给一些额外的指示。Mode参数指定了新文件的访问权限位。(2).关闭文件：intclose(intfd);调用close函数，通知内核结束访问一个文件，关闭打开的一个文件。成功返回0，出错返回-1。(3).读文件：ssize_tread(intfd,void*buf,size_tn);调用read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示错误，返回值0表示EOF，否则返回值表示的是实际传送的字节数量。(4).写文件：ssize_twrite(intfd,constvoid*buf,size_tn);调用从内存位置buf复制至多n个字节到描述符fd的当前文件位置。返回值-1表示出错，否则，返回值表示内存向文件fd输出的字节的数量。8.3printf的实现分析printf函数：intprintf(constchar*fmt,…){inti;va_listarg=(va_list)((char*)(&fmt)+4);i=vsprintf(buf,fmt,arg);write(buf,i);returni;}可以发现printf的输入参数是fmt，但是后面是不定长的参数，同时在printf内存调用了两个函数，一个是vsprintf，一个是write。intvsprintf(char*buf,constchar*fmt,va_listargs){char*p;chartmp[256];va_listp_next_arg=args;for(p=buf;*fmt;fmt++){if(*fmt!=‘%’){*p++=*fmt;continue;}fmt++;switch(*fmt){case‘x’:itoa(tmp,*((int*)p_next_arg));strcpy(p,tmp);p_next_arg+=4;p+=strlen(tmp);break;case‘s’:break;default:break;}return(p-buf);}}Printf执行流程：vsprintf函数将所有的参数内容格式化之后存入buf，然后返回格式化数组的长度。write函数将buf中的i个元素写到终端。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析getchar是读入函数的一种。它从标准输入里读取下一个字符，相当于getc(stdin)。返回类型为int型，为用户输入的ASCII码或EOF。getchar可用宏实现：#definegetchar()getc(stdin)。getchar有一个int型的返回值。当程序调用getchar时.程序就等着用户按键。用户输入的字符被存放在键盘缓冲区中。直到用户按回车为止（回车字符也放在缓冲区中）。当用户键入回车之后，getchar才开始从stdin流中每次读入一个字符。getchar函数的返回值是用户输入的字符的ASCII码，若文件结尾(End-Of-File)则返回-1(EOF)，且将用户输入的字符回显到屏幕。[2]异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章主要介绍了linux系统中的I/O设备基本概念和管理方法，同时简单介绍了printf和getchar函数的实现。（第8章1分） 结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。Hello的一生是简单的但是又蕴含着每一个c语言程序执行前的必经之路： 预处理，hello.c文件通过cpp的预处理，得到了扩展后的源程序文件hello.i编译，hello.i通过编译器的处理，被翻译成了汇编语言程序hello.s汇编，在汇编器as的处理下，hello.s生成了可重定位文件hello.o链接，链接器将重定位目标文件链接为可执行目标文件hello生成子进程，在shell中输入指定命令shell调用fork函数为hello生成进程。Execve加载并运行hello程序，将它映射到对应虚拟内存区域，并依需求载入物理内存。I/O设备，在hello程序中存在输入与输出，这些部分与printf，getchar函数有关，这些函数与linux系统的I/O设备密切相关。Hello将在cpu流水线中执行每一条指令程序运行结束后，父进程会对其进行回收，内核把它从系统中清除。这样，hello就结束了它的一生。在计算机系统的设计与实现过程中所必须要满足的就是准确，程序的执行必须能输出准确的结果，在这一基础上进行一定的优化能够让程序执行的更快，包括cache，流水线，超标量等设计都是基于这些的。在完成大作业的过程中相当于回顾了一遍这学期的学习内容，对于计算机系统设计与实现也有了更深切的感悟。（结论0分，缺失-1分，根据内容酌情加分） 附件列出所有的中间产物的文件名，并予以说明起作用。中间结果文件名称文件作用Hello.i预处理后的文件Hello.s汇编程序Hello.o可重定位目标文件Hello可执行目标程序Elf.txtHello.o的ELF格式Dis_hello.txtHello.o的反汇编代码Hello.elfHello的elf格式文件Hello.txtHello的反汇编代码 （附件0分，缺失-1分） 参考文献为完成本次大作业你翻阅的书籍与网站等[1]伍之昂.LinuxShell编程从初学到精通[M].北京：电子工业出版社[2]https://baike.baidu.com/item/getchar/919709?fr=aladdin[3]《深入理解计算机系统》RandalE.BryantDavidR.O’Hallaron机械工业出版社[4]https://blog.csdn.net/wang13342322203/article/details/80862382[5]https://docs.microsoft.com/zh-cn/cpp/build/creating-precompiled-header-files?view=msvc-160[6]CSDN博客ELF可重定位目标文件格式[7]https://www.cnblogs.com/knife-king/p/11090029.html[8]https://baike.baidu.com/item/ELF/7120560?fr=aladdin[9]http://www.elecfans.com/emb/20190402898901.html （参考文献0分，缺失-1分） 
第476篇文章[3]
最优贸易题解c++实现 题目 题目描述C国有n个大城市和m条道路，每条道路连接这n个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这m条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为1条。 C国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到C国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设C国n个城市的标号从1~n，阿龙决定从1号城市出发，并最终在n号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有n个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品 水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来C国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设C国有5个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。C国有n个大城市和m条道路，每条道路连接这n个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这m条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为1条。C国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到C国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设C国n个城市的标号从1~n，阿龙决定从1号城市出发，并最终在n号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有n个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品 水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来C国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。假设C国有5个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。 假设1~n号城市的水晶球价格分别为4，3，5，6，1。阿龙可以选择如下一条线路：1->2->3->5，并在2号城市以3的价格买入水晶球，在3号城市以5的价格卖出水晶球，赚取的旅费数为2。阿龙也可以选择如下一条线路1->4->5->4->5，并在第1次到达5号城市时以1的价格买入水晶球，在第2次到达4号城市时以6的价格卖出水晶球，赚取的旅费数为5。 现在给出n个城市的水晶球价格，m条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入格式第一行包含2个正整数n和m，中间用一个空格隔开，分别表示城市的数目和道路的数目。 第二行n个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这n个城市的商品价格。 接下来m行，每行有3个正整数，x，y，z，每两个整数之间用一个空格隔开。如果z=1，表示这条道路是城市x到城市y之间的单向道路；如果z=2，表示这条道路为城市x和城市y之间的双向道路。 输出格式共1行，包含1个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出0。 样例数据 input5543561121141232351452 output5 分析 这一题主要思路就是找到在一条路径上的最大最小值，将其相减就是所求的收益。需要注意的是，最大值需要在最小值之后，那么很容易想到从前往后一次dijkstra求出最小值，从后往前一次dijkstra求出最大值，但是，这样是有问题的。由于对于一个顶点加入集合之后，dijkstra就不再更新该节点，我们不妨看一下下面这种情况，其中加粗的为该点的价格。其测试样例为 910 432157896 121 231 341 421 251 561 671 781 861 691 正确的输出应为8，但是正反两次dijkstra结果是6，这是由于1、2、3结点之间的更新出现一定问题，导致后续出现一定问题。那么这题可以采用正反两次SPFA算法就可以解决啦。以下是正确代码（在洛谷AC，且测试过一定的自己使用的样例） #include<queue> #include<vector> #include<cstdio> #include<cstring> #include<iostream> #defineINF1000000 #defineN1000005 usingnamespacestd; intdis1[N]={0},dis2[N]={0},vis[N]; vector<int>edge1[N],edge2[N];//分别是正向和反向建图 intn,m;//分别表示城市数和道路数 intprice[N]={0}; voidread() { cin>>n>>m; for(inti=1;i<=n;i++) { cin>>price[i]; } intu,v,k; for(inti=1;i<=m;i++) { cin>>u>>v>>k; edge1[u].push_back(v); edge2[v].push_back(u); if(k>1) { edge1[v].push_back(u); edge2[u].push_back(v); } } } voidSPFA1() { memset(dis1,INF,sizeof(dis1)); memset(vis,0,sizeof(vis)); queue<int>Q; Q.push(1); vis[1]=1; while(!Q.empty()) { inttemp=Q.front(); Q.pop(); dis1[temp]=min(dis1[temp],price[temp]); for(inti=0;i<edge1[temp].size();i++) { intv=edge1[temp][i]; if(dis1[temp]<dis1[v]) { dis1[v]=dis1[temp]; if(!vis[v]) { vis[v]=1; Q.push(v); } } } vis[temp]=0;//关键步骤 } } voidSPFA2() { memset(dis2,0,sizeof(dis2)); memset(vis,0,sizeof(vis)); queue<int>Q; Q.push(n); vis[n]=1; while(!Q.empty()) { inttemp=Q.front(); Q.pop(); dis2[temp]=max(dis2[temp],price[temp]); for(inti=0;i<edge2[temp].size();i++) { intv=edge2[temp][i]; if(dis2[temp]>dis2[v]) { dis2[v]=dis2[temp]; if(!vis[v]) { vis[v]=1; Q.push(v); } } } vis[temp]=0; } } intmain() { intres=0; read(); SPFA1(); SPFA2(); for(inti=1;i<=n;i++) { res=max(res,dis2[i]-dis1[i]); } cout<<res<<endl; system("pause"); return0; } 
第477篇文章[6]
解决numpy.ndarraysizechanged,mayindicatebinaryincompatibility.报错 目前正在学习使用一个python包的使用，运行示例代码过程中出现了numpy.ndarraysizechanged,mayindicatebinaryincompatibility报错。如下图所示： 实测只需要将numpy更新为最新版本（本人更新为1.20.2）即可解决问题。其中pip过程中可能提示tensorflow与最新版本的numpy不匹配，如下图： 经测试暂时未发现tensorflow运行出现问题。 
第478篇文章[]
（软件构造博客）java中的final java中的final java中的final关键字可以用来声明变量、方法、类。主要起到的作用就是达到引用不可变的效果。具体分别介绍如下： 1.1final变量 被final修饰的变量在赋值之后引用关系就确定了，也就是不能对于基本数据类型来说不可以另赋新值，对于对象数据类型来说不能为这个变量指派一个新的对象。也就是类似于以下语句都是会在静态检查的时候报错的： finalinta=1; a=2; finalStrings="GOOGLE"; s="BAIDU"; 那么仔细考虑来看，如果我们指定的一个变量是immutable的，那么就意味着如果用final修饰，在初始化之后这个变量就不可以修改了，如果是mutable的话，内部的值还可以修改但是不可以改变引用关系。那么是不是意味着如果在我们定义的ADT内部如果我们用final修饰了一个immutable的变量的时候就不用担心表示泄露了呢？事实上不是这样的，如果在这种情况下存在表示泄露可能会存在使用者分析运行时内存的具体情况判断ADT内部一些实现功能的危险，也就是说即使使用了final，还是需要注意表示泄露的问题。 1.2final方法 下面这段话摘自《Java编程思想》第四版第143页： “使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的 含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用 。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java 版本中，不需要使用final方法进行这些优化了。“ 也就是说，如果一个方法使用了final修饰，那么这个方法将不再能被子类重写。需要注意的是由于重写首先建立在继承的关系上，如果父类中一个final方法是private的，子类自然无法访问，那么子类中定义相同的方法名和参数是不会报错的，但是这时候不再是重写关系。例如如下代码是不会报错的 publicclassPerson{ privatefinalvoiddecision(){ System.out.println("父类"); } } publicclassconcretePersonextendsPerson{ publicvoiddecision(){ System.out.println("子类"); } publicstaticvoidmain(String[]args){ Personp=newconcretePerson(); //p.decision(); } } 但是可以发现的是如果我们去掉注释的话IDE会直接在注释那一行下报错，显示没有这个方法。这是由于静态检查阶段p的类型还是Person，而Person的decison方法是private的，不可访问，因此静态检查报错。 1.3final类 与上面两类类似，如果使用final修饰类的话，那么这个类是不可以被继承的。 2.final一些实例 2.1final变量与普通变量 很重要的一点就是final变量的指向已经不可变了，因此可以看下面这个例子 publicstaticvoidmain(String[]args){ Stringa="helloworld"; Stringb="helloworld"; Stringc="hello"+"world"; finalStringd="hello"; Stringe="hello"; Stringf=d+"world"; Stringg=e+"world"; System.out.println(a==b); System.out.println(a==c); System.out.println(d==e); System.out.println(a==f); System.out.println(a==g); } 输出如下： true true true true false 这个结果让我困惑了一段时间，查阅了资料之后有了一定的了解。接下来对于每一个结果进行分析。首先需要明确的就是对于这种直接通过双引号""声明字符串的方式,虚拟机首先会到字符串常量池中查找该字符串是否已经存在，如果存在会直接返回该引用,如果不存在则会在堆内存中创建该字符串对象,然后到字符串常量池中注册该字符串。 也就是说a和b和c事实上是指向同一段地址的，因此a==b和a==c成立。 接下来分析一下a==g为什么是false的。这是因为g是在运行的时候才分配的一段地址，因此和a的地址是不一致的，因此返回false。那么为什么a==f就是对的呢？这是因为d是由final修饰的，在静态编译的时候就当做常量使用，因此f的地址是在常量池中分配的，和a是指向一段地址的，因此a==f成立。 
第479篇文章[3]
leetcode1139.最大的以1为边界的正方形c++ leetcode1139.最大的以1为边界的正方形c++题目给你一个由若干0和1组成的二维网格grid，请你找出边界全部由1组成的最大正方形子网格，并返回该子网格中的元素数量。如果不存在，则返回0。 示例1： 输入：grid=[[1,1,1],[1,0,1],[1,1,1]] 输出：9 示例2： 输入：grid=[[1,1,0,0]] 输出：1 提示： 1<=grid.length<=1001<=grid[0].length<=100grid[i][j]为0或1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/largest-1-bordered-square 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析这道题的解决可以从一个点开始向它的周围进行遍历，寻找符合题意的最大正方形。在代码实现中是通过定义一个点是正方形的右下点，求出可能的最大正方形之后在可能值中求得最优解。代码 classSolution{ public: intlargest1BorderedSquare(vector<vector<int>>&grid){ intlength=grid.size(),width=grid[0].size(); intleft[length][width];//某点左边连续1的个数 intup[length][width];//某点上方连续1的个数 for(inti=0;i<length;i++) { for(intj=0;j<width;j++) { if(j&&grid[i][j-1])left[i][j]=left[i][j-1]+grid[i][j]; elseleft[i][j]=grid[i][j]; if(i&&grid[i-1][j])up[i][j]=up[i-1][j]+grid[i][j]; elseup[i][j]=grid[i][j]; } } intres=0; for(inti=0;i<length;i++) { for(intj=0;j<width;j++) { if(grid[i][j]) { intlen=min(left[i][j],up[i][j]);//可能的最大值 while(res<len) { if(up[i][j-len+1]>=len&&left[i-len+1][j]>=len)//判断可能正方形的左下点和右上点是否符合提议 { res=len; break; } len--;//缩小可能正方形的大小 } } } } returnres*res; } }; 
第480篇文章[]
（软件构造博客）==和equals的区别 ==和equals的区别 之前在做软件构造实验的时候遇到了应该使用==还是equals判断相等的情况，结合上课讲的内容和查阅的资料在此记录二者的相同点和区别，如有不正确的地方请批评指正。 1.相同点 很显然二者的相同点就是都是用来判断两个元素是否相同的，只是使用的方式以及判断的方法不同。 2.不同点 首先，最大的区别就是==是一个运算符而equals是一个函数，这是二者本质上的不同，当然，在使用的时候这不是我们需要考虑的重点。在使用的时候我们需要考虑的是：1.对于一些基本数据类型例如byte，int等只能使用==，表示对于数值或者是基本数据类型值的比较，由于这些都是基本数据类型，因此不存在使用equals函数来比较的必要2.对于一些复合数据类型，如果我们使用==来表示比较比较两个元素的话我们比较的是他们的存放地址的相同与否，也就是如果们new了两个复合数据类型，尽管它们内部的值可能是相同的，但是比较结果是不相同的，很显然在大多数时候这都是不符合我们的使用要求的。3.对于复合数据类型，使用的equals都是继承自java的Object类，在不进行override的情况下比较的还是存放地址，因为Object中默认是使用==实现这个函数的，可以通过override来重写，定义我们需要的比较方式，例如Interger，Date，String等复合数据类型内部都进行了重写，不再是比较存放的地址位置。 具体例子 代码： //基本数据类型的比较 inttest1=10; inttest2=10; System.out.println(test1==test2);//true //引用数据类型的比较 Strings1="test"; Strings2="test"; System.out.println(s1==s2);//true System.out.println(s1.equals(s2));//true //String类中==与equals的比较 Strings3=newString("test"); Strings4=newString("test"); System.out.println(s3==s4);//false System.out.println(s3.equals(s4));//true //非String类中==与equals类型的比较 4.关于重写equals 一般来说，如果我们定义的一个ADT我们希望它是immutable类型的时候我们需要重写equals，这是因为很可能存在使用这个ADT，new出的两个实体由于存放的位置不同而无法使用==比较是否相等，这时候就需要重写equals，而mutable类型的ADT一般不需要重写equals方法。 
第481篇文章[6]
anaconda中下载pip 一般情况下anaconda中是自带pip的，但是若不小心卸载了pip，那么可以用如下方法解决。1.打开链接https://pypi.org/project/pip/#files2.下载.tar.gz文件3.解压该文件4.使用AnacondaPrompt进入解压之后的文件夹5.运行如下代码 pythonsetup.pyinstall 6.等待安装完成即可 
第482篇文章[]
（软件构造博客）软件构造的三维度八视图 软件构造的三维度八视图 ​软件构造的三维度八视图是在软件的构造和后期维护过程中的一个概念，其实就是软件构造应该如何构造的问题，事实上，“软件构造”就可以看做是三维度八视图之间的相互切换的过程。在此对于这三维度和八视图进行简要的归纳总结。 ​三维度八视图的英文版图如下： 中文翻译版如下： 以下是我对三维度八视图的理解，如有不正确请批评指正： 1.三维度 首先时刻和阶段这一维度较好理解，就是指是在某一个时刻或者是一段时间内进行观察得到的结果。 而代码和构件这一维度来看，很显然，代码层面就是指直接与源代码相关的部分而构件层面更多的指这个项目使用的一些外部的配置、库等信息。 编译与运行时这一维度也较好理解，不过多赘述 2.八视图 个人感觉这八个视图事实上和计算机系统中很多知识是重叠的，由于这学期刚好两门课都学，因此尝试从不同角度对八视图进行解释。 2.1编译时 时刻 代码 很显然，这一部分如果需要对应于计算机系统中的编译过程，在c语言中由gcc完成，在java中由JDK完成这一过程，与这一过程密切相关的就是源代码，也就是日常最常接触到的，其次就是语法分析数，这是由编译器产生的一棵树，主要是对程序进行词义分析、语法分析等工作，语法分析树这一部分知识可以见形式语言与自动机或编译原理课程。一棵c语言语法分析树示例如下： 2.2编译时 时刻 构件 显然，这一部分对应于静态链接的过程，在c语言链接过程中使用链接器（ld）将文件转化为可执行目标文件，在java中这一流程类似，也是将外部的包等代码中使用的外部的包信息与代码文件进行链接。 2.3编译时 阶段 代码 这一阶段事实上对应于源代码的一个变化的过程，主要体现的是对于源代码不断地修改，很好理解。 2.4编译时 阶段 构件 首先，对应于配置项的变化，配置项的解释就是：软件生存周期各个阶段活动的产物经审批后即可称之为软件配置项。也就是在源代码变化之后生成了多个部件，我们可能有了这个软件的不同零件，将其组合起来之后就是整个软件；其次就是版本控制，这一点很好理解，处于维护、功能升级等不同原因，软件总会不断推出新版本，这些版本表现的就是软件的一个演变过程。 github为我们每一个项目维护的一个提交历史记录就可以看成是这一阶段的一个简单示例 2.5运行时 时刻 代码 这一阶段对应于在运行中代码的变化，主要表示的就是例如在运行时某一时刻某个变量的值是什么样的，事实上我们对于程序打断点调试的时候看的就是这一个视图的内容。 2.6运行时 时刻 构建 很显然，这一阶段对应于动态链接，可以简单理解成在加载的时候再对使用的一些外部构件进行的链接；除了动态链接之外，这一视图对应的很重要的一部分是类似于在运行时使用数据库这种情况，数据库并没有嵌入软件，而是在软件运行时某个时刻请求数据库的信息。 2.7运行时 阶段 代码 这一部分可以看成是在程序运行过程中栈的信息的一个展示，最明显的一个展示就是java程序报错的时候出现的报错信息，这就是在java运行过程中与某个报错相关的栈的信息的展示，一个简单的例子如下图所示： 2.8运行时 阶段 构件 这一阶段主要对应于事件日志这一类信息，其事实上就是构件层面上的代码运行过程中的栈信息，但是它并没有2.7中栈信息内容那么繁多，其主要记录代码运行过程中的重要的事件的发生信息。 以上就是我对于三维度八视图的一些理解，如有错误或不足希望批评指正。 
第483篇文章[]
（软件构造博客）Eclipse使用基本教程一（安装、JDK配置） 1.Eclipse安装 下载官方链接：https://www.eclipse.org/downloads/ 点击红框中的DownloadPackages，进入如下页面：根据使用的系统选择第一项中的Eclipse版本即可，后续只需要按照提示内容安装即可，不再赘述。 2.JDK安装 2.1下载 由于我们需要进行java开发，因此需要下载并配置JDK，具体方法如下：官方下载链接：https://www.oracle.com/java/technologies/javase-downloads.html如果使用官方链接直接点击Download,选择合适的版本即可。如果觉得官方链接太慢可以使用如下链接：华为云镜像：https://repo.huaweicloud.com/java/jdk/，进入之后选择合适的版本和系统即可。 2.2安装点击下载好的exe文件，出现如下安装指引点击下一步后出现如下页面，可以点击修改，更改安装地址，例如本人改为E:\JDK\JDK8，之后点击下一步等待安装即可。由于本人安装的是JDK8，因此还需要安装JRE（如果是JDK10后的版本无此过程），安装完成后，会弹出JRE安装界面，如下： 等待JRE安装完成即可。 2.3环境变量配置在Win10系统中演示，其他系统同理。打开系统属性界面（如果找不到直接在设置界面的搜索框中搜索变量，选择编辑系统变量选项即可）点击环境变量，进入如下界面，点击新建或编辑即可操作 由于本人电脑上已经配置了JDK11，因此JAVA_HOME等已经创建，第一次配置时新建即可。1.新建JAVA_HOME，将其设置为JDK安装目录。2.新建Path（如果已有的话再末尾添加即可），添加一项，为%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;3.新建CLASSPATH，设置为.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar（注意开头有一个点） 如果进行到这一步，那么JDK已经安装完成，可以进行验证。首先win+R打开如下面板： 进入cmd，输入javac，出现如下内容：如果需要查看JDK版本，使用java-version命令，出现如下信息：这就意味着JDK安装完成。 这是Eclipse配置java项目的第一步，下一个教程将展示如何开始第一个java程序，并使用Junit进行测试。 
第484篇文章[6]
leetcode刷题一个月心得 leetcode刷题心得： 今天刷题满一个月，在这一个月里，坚持刷题（其实也断了3、4天），从一开始的见题死，或者死磕两个小时才可以做出来，痛苦面具；到后来的轻轻松松半个小时，还可以找到比官方更好的一些算法，刷题刷上瘾。 感觉收获还是蛮大的，在此总结一下这一个月心得 感受方法层面的： 1、网上攻略千千万，自己动手才是真。说实在的，类似的攻略心得我也收藏了不少，但是也就是上个月才开始动手，就是做了简简单单的每日一题，也没有刻意，肯定又不全面的地方，但是我刷题的目的就是提升自己的代码能力，也算是物有所值。 2、坚持死磕是必须的一开始做题，中等难度的对我相当于都是判了死刑，孩子就可以打打简单的，而且效率还不高。但是我对于这种题，一般都是死磕一天，有事没事都想着他，最后也可以大概写出一些（但是也有很多bug，思路混乱不清晰之类的），最后快睡觉了，我才会放弃，看看官方解答。这样慢慢的，大概十几天吧，就发现了自己的一些问题，然后不断改进，最后其实真的进步收获蛮大的 3、不断反思自己的做题习惯对我来说，主要是两个：一个是代码想清楚了再开始打；一个是找bug的能力。 技能知识层面的： 1、边界条件要判断，其实到了最后，我找bug都是找边界条件的判断2、数据结构很有用。很多栈，二叉树，图的思想，当时学的时候的死的，后来在不断解决问题中才渐渐变成自己的3、算法这个很玄妙。我吹爆几个自己很薄弱的算法吧，动态规划（主要是字符串相关的，回文串，最长公共子串，floyd之类的），想法真的很巧妙DFS（深度优先搜索），这个算法其实是暴力算法的一种，我是在图的遍历那里学到的，后来发现自己压根不会举一反三，我很多最终都没有攻克的题目，一般都是搜索+回溯之类的，这个不重不漏真的很难，我现在还是不太懂。递归的应用其实这个我也没太搞明白，大概就是要有递归终止条件，递归主函数、递归方程之类的，这个也是想不明白很难的 下一阶段目标： 可能偶尔还是会刷leetcode，但是想要学习一下几个软件的使用分别是linux下的gdb调试以及各种命令IDA的使用burp的使用最近笔者对信息安全稍微侧重一下吧，前段时间看了一个椭圆方程加密的密码学问题，感觉很有意思 
第485篇文章[3]
leetcode 找全部回文子串集合（DFS和动态规划复习） 文章目录 问题一、官方是如何又一次站在大气层的？二、我遇到了那些问题三、得与失的反思 问题 给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。返回s所有可能的分割方案。 示例: 输入:“aab”输出:[[“aa”,“b”],[“a”,“a”,“b”]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindrome-partitioning著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 一、官方是如何又一次站在大气层的？ 我的思路和官方一样，也想过要用递归、搜索，但是写代码能力不行，一直有bug。在深入思索了官方的DFS+动态规划的思路之后，我觉得这是一道好题，有很多知识点可以学习。 官方思路： 由于需要求出字符串ss的所有分割方案，因此我们考虑使用搜索+回溯的方法枚举所有可能的分割方法并进行判断。 假设我们当前搜索到字符串的第i个字符，且s[0…i-1]位置的所有字符已经被分割成若干个回文串，并且分割结果被放入了答案数组ans中，那么我们就需要枚举下一个回文串的右边界j，使得s[i…j]是一个回文串。 因此，我们可以从i开始，从小到大依次枚举j。对于当前枚举的j值，我们使用双指针的方法判断s[i…j]是否为回文串：如果s[i…j]是回文串，那么就将其加入答案数组ans中，并以j+1作为新的i进行下一层搜索，并在未来的回溯时将s[i…j]从ans中移除。 如果我们已经搜索完了字符串的最后一个字符，那么就找到了一种满足要求的分割方法。 细节 我们可以将字符串s的每个子串s[i…j]是否为回文串预处理出来，使用动态规划即可。设f(i,j)表示s[i…j]是否为回文串，那么有状态转移方程： ​ 其中∧表示逻辑与运算，即s[i…j]为回文串，当且仅当其为空串（i>=j），其长度为11（i=j），或者首尾字符相同且s[i+1…j-1]为回文串。 预处理完成之后，我们只需要O(1)的时间就可以判断任意s[i…j]是否为回文串了。 官方代码如下： classSolution{ private: vector<vector<int>>f; vector<vector<string>>ret; vector<string>ans; intn; public: voiddfs(conststring&s,inti){ if(i==n){ ret.push_back(ans); return;//DFS的终止条件 } for(intj=i;j<n;++j){ if(f[i][j]){ ans.push_back(s.substr(i,j-i+1)); dfs(s,j+1); ans.pop_back(); //这个pop一开始很困惑，后来明白，这是把当前找的i到j的字符串去掉， //保证了j可以一直往后遍历，真的是想到了就是想到了，递归真的神了 } } } vector<vector<string>>partition(strings){ n=s.size(); f.assign(n,vector<int>(n,true)); for(inti=n-1;i>=0;--i){//必须从n-1开始 for(intj=i+1;j<n;++j){ f[i][j]=(s[i]==s[j])&&f[i+1][j-1]; } } dfs(s,0); returnret; } }; 为了更深刻的了解DFS的思想内涵，我找到了我之前写的一个图的DFS的代码，加深一下印象 代码如下： /*rooms为一个二维数组，储存图的顶点和边信息， rooms[i]里面的数字都是与i相邻的顶点编号 */ voidtravel(vector<vector<int>>&rooms) { intlen=rooms.size(); for(inti=0;i<len;i++) { visited.push_back(false); }//初始化visited数组，均标记为为访问 for(inti=0;i<len;i++)//防止不是连通图 { if(visited[i]==false) { DFS(i,rooms); } } } voidDFS(inti,vector<vector<int>>&rooms){ visited[i]=true;//标记已经访问过 intl=rooms[i].size();//顶点i连接的其它顶点 cout<<i;//输出当前被访问的节点 for(intj=0;j<l;j++) { if(visited[rooms[i][j]]==false) DFS(rooms[i][j],rooms); } } 2、动态规划判断回文子串：需要注意的是，动态规划如果想要知道ij，就必须要知道i+1，j-1，所以填矩阵的顺序一定是从下往上，从左往右，这是典型的动态规划的套路了。 二、我遇到了那些问题 我的失败代码如下： ```cpp classSolution{ public: vector<string>temp;//回文分割子集 vector<vector<string>>res; booljudge=true; stringfront,back; //判断s是否为回文，是返回0，否则为-1 inthelp(strings){ intn=s.size(); stringback; if(n==0)return0; for(inti=0;i<n;i++){ back.push_back(s[n-1-i]); }//将s反着复制一遍,笨办法 if(s.compare(back)==0){ return0; } elsereturn-1; } //还是写一个递归函数专门找回文吧 voidhui(intindex,strings){ intcopy;//复制尾指针 for(copy=index;copy<s.size();copy++){//生成回文集终止条件 front.clear(); for(i=index;i<copy+1;i++){ front.push_back(s[i]); }//复制部分字符串 //判断是否为回文 inti=help(front); if(i==0){ temp.push_back(front);//前面的已经时回文了，后面的同理 hui(copy+1,strings) //头指针后移 } else{ copy--; } } //主函数 vector<vector<string>>partition(strings){ inti;//循环 intindex=0;//角标，s某个回文开头 inttail;//s某个回文结尾 intcopy; intcount=s.size();//s的大小 tail=count; if(count==1){ temp.push_back(s); res.push_back(temp); returnres; } //目前不需要if(count==0)returnres; //两个指针，枚举方法：一开始的时候，一个固定在开头，另一个从尾端向前移动，发现回文，头指针向后移，尾端重新到最后 //保证枚举的不重不漏（但是这是有漏的），为指针一个一个移动，每一次都判断 while(tail!=-1) {index=0; } if(!temp.empty()) res.push_back(temp); temp.clear(); } returnres; }; }; 怎么说的，改了一个多小时，还是出现失败，我也佛了，感觉没用递归的纯循环就是死亡（大哭） 三、得与失的反思 有时候代码还是要积累和总结的事后诸葛也很重要，要知道很多事前诸葛就是从事后诸葛过来的。 
第486篇文章[6]
大创文献阅读 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档 文章目录 前言一、作者和发表年限二、研究内容1.摘要2.具体的东东 三、结论四、缺点 前言 提示：阅读了一篇外文文献SoilMoistureSensingwithCommodityRFIDSystems，在这里整理一下文献的思路。 提示：作者，发表年限，研究内容，研究结论 一、作者和发表年限 JWang†,LiqiongChang‡,ShouryaAggarwal†?,OmidAbari†andSrinivasanKeshav†§†UniversityofWaterloo,‡NorthwestUniversity,?IndianInstituteofTechnologyDelhi,§UniversityofCambridge MobiSys’20,June15–19,2020,Toronto,ON,Canada 二、研究内容 1.摘要 Intelligentirrigationbasedonmeasurementsofsoilmoisturelevelsineverypotinagreenhousecannotonlyimproveplantproductivityandqualitybutalsosavewater.However,existingsoilmoisturesensorsaretooexpensivetodeployineverypot.WethereforeintroduceGreenTag,alow-costRFID-basedsoilmoisturesensingsystemwhoseaccuracyiscomparabletothatofanexpensivesoilmoisturesensor.OurkeyideaistoattachtwoRFIDtagstoaplant’scontainersothatchangesinsoilmoisturecontentarereflectedintheirDifferentialMinimumResponseThreshold(DMRT)metricatthereader.Weshowthatalow-passfilteredDMRTmetricisrobusttochangesbothintheRFenvironment(e.g.,fromhumanmovement)andinpotlocations.Inarealisticsetting,GreenTagachievesa90-percentilemoistureestimationerrorsof5%,whichiscomparabletothe4%errorsusingexpensivesoilmoisturesensors.Moreover,thisaccuracyismaintaineddespitechangesintheRFen-vironmentandcontainerlocations.WealsoshowtheeffectivenessofGreenTaginarealgreenhouse. 大体意义上说，作者把两个RFID标签贴在花盆上，然后通过读写器读取两个标签的无线电能量相关信息，然后一通操作猛如虎，就可以测出土壤湿度。然后作者把自己的论文夸了一通。 2.具体的东东 RFID读取的MRT，RSS和phase都和土壤湿度有一定关系，但是前两者是线性关系。两个标签，一个贴在花盆外的土壤上方，一个贴在中部，两个曲线相减大概就是土壤湿度，然后多项式拟合。最后分析了一下环境的影响。 三、结论 MRT和土壤湿度是多项式函数关系，通过布置RFID标签，可以检测土壤湿度，精确度，持久性什么的都不错。 四、缺点 论文使用的RFID读写器太贵，ImpinjSpeedwayR420reader，人民币大概好几万，不适合普通的学生项目创新，有待改良。 
第487篇文章[3]
leetcode 矩阵置零(原地算法) 文章目录 前言一、题目是什么？二、解法1.我的解法2.官方层层递进的三个解法 总结维基百科定义：例题：解：解： 前言 提示：题目不是很难，但关键是怎么减少空间复杂度，我一开始想到的是o（m+n）的，后来看了答案，才知道原来还可以将本来的输入矩阵第一行和第一列进行改造，变成我们需要的标记数组。这样就是o（1）的空间复杂度了 提示：本题涉及到了一个名词，原地算法。 一、题目是什么？ 题目点击这里 二、解法 1.我的解法 我的代码（这是看过官方的第二个分析之后，我自己写的代码）： lassSolution{ public: voidsetZeroes(vector<vector<int>>&matrix){ intm=matrix.size();//row intn=matrix[0].size();//column boolflag1=false; boolflag2=false; for(inti=0;i<n;i++){ if(matrix[0][i]==0){ flag1=true; break; } } for(inti=0;i<m;i++){ if(matrix[i][0]==0){ flag2=true; break; } } for(inti=1;i<m;i++){ for(intj=1;j<n;j++){ if(matrix[i][j]==0){ matrix[i][0]=0; matrix[0][j]=0; } } } for(inti=1;i<n;i++){ if(matrix[0][i]==0){ for(intj=0;j<m;j++){ matrix[j][i]=0; } } } for(intj=1;j<m;j++){ if(matrix[j][0]==0) { for(inti=0;i<n;i++){ matrix[j][i]=0; } } } if(flag1==true){ for(inti=0;i<n;i++){ matrix[0][i]=0; } } if(flag2==true){ for(inti=0;i<m;i++){ matrix[i][0]=0; } } } }; 2.官方层层递进的三个解法 官方解答点这里 总结 我想重点说一说原地算法是什么，因为百度上说的真的有点翻译腔的味道（懂得都懂） 维基百科定义： 在计算机科学中，一个原地算法（in-placealgorithm）基本上不需要额外辅助的数据结构（比如数组、栈，二叉树，堆等）,然而,允许少量额外的辅助变量来转换数据的算法。当算法运行时，输入的数据通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。 一句话总结就是:原地算法不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。 例题： 1、要将具有n项内容的数组a翻转过来。 解： 你可以在开辟一个数组的空间，然后将原数组copy过来；也可以用原地算法，可以直接在原数组上两两对换，只用o（1）的空间即可。 2、给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 解： 这个blog里面有详细代码 
第488篇文章[3]
leetcode 132模式（单调栈）+疯狂补丁 文章目录 前言一、题目是什么？二、使用步骤1.第一种极其暴力的解法2.修修补补的第二个解法3、官方解法 总结 前言 这道题我做的就是修修补补，其实就算我的第二个解法最后通过了101个测试例子，但是我还是怀疑是有bug的。这个代码反复提交了有14遍，针对遇到的不同的问题，我在代码上打了有针对性的补丁，完整直接的思路是没有的。 欢迎各位大佬来找bug。。。。。。小弟求之不得，铭感五内 一、题目是什么？ 题目点击这里 二、使用步骤 1.第一种极其暴力的解法 人家别人的暴力解法是o（n^2），我直接三个for循环，很快的，都不带动脑子……代码如下： classSolution{ public: boolfind132pattern(vector<int>&nums){ intn=nums.size(); if(n<3)returnfalse; for(inti=0;i<n;i++){ if(i+1<n){ for(intj=i+1;j<n;j++){ if(nums[i]<nums[j]){ if(j+1<n){ for(intk=j+1;k<n;k++){ if(nums[i]<nums[k]&&nums[k]<nums[j]) returntrue; } } } } } } returnfalse; } }; 提交的过程中，超时了，这大概是一个o（n^3）的解法，不过我觉得正确性是没什么可质疑的，简单直接 2.修修补补的第二个解法 代码如下： classSolution{ public: boolfind132pattern(vector<int>&nums){ intn=nums.size(); if(n<3)returnfalse; inti=0,temp; stack<int>s; s.push(nums[i]); i++; intfront=nums[0]; while(i<n&&!s.empty()){ if(i==n-1){//n-1特殊情况，后面没有可以比较的元素了 if(nums[i]>=s.top())returnfalse; else{ while(!s.empty()&&nums[i]<=s.top()){ s.pop(); } if(s.empty())returnfalse; elsereturntrue; } } if(i<n-1){//大餐开始了 if(nums[i]>=s.top()){ s.push(nums[i]); i++;//维护一个单调递增的栈 } else{//如果出现一个比栈顶元素小的元素 temp=i; while(i<n-1&&nums[i]<nums[i+1]&&i<n-1){//判断另一个单调栈， if(nums[i+1]<s.top()){ i++; } else{ break; } } //单调不下去了 if(i<n-1&&nums[i]>=nums[i+1]){ for(intj=i;j<n;j++){ if(nums[j]<s.top()&&nums[j]>front) returntrue; } } //出来有两种可能，一种i=n-1，一种比top（）大了 while(!s.empty()&&s.top()>=nums[i]){ s.pop(); } if(!s.empty())returntrue; else{ front=nums[temp]; for(intj=temp;j<=i;j++) s.push(nums[j]); i++; } } } } returnfalse; } }; 先说说大概思路吧： 维护一个单调递增的栈s，相当于认为栈底的是1，栈顶的是3，然后一旦遇到比3小的数（单调性被打破），执行以下操作： 从当前数开始，记最后找的元素为key，相当于维护了另一个隐形的单调递增的栈，分为3种情况： 1、一直单调递增到n-1，也就是尾端元素。这个时候啥也不说了，将key与栈内元素比较即可 2、单调递增到了一个比top大的元素那里，这个时候，这个元素之前的，就是key，将它和栈里面的元素比较。如果符合132模式，返回；否则，将这个隐形的单调栈压栈。 3、他不单调了，这个就比较麻烦了，这个我一开始没怎么细想，结果出bug了……出问题的测试例子是这个：[10,12,6,8,3,11]`。 我针对这个例子想了一个暴力方法：就是把top之后的元素，挨个与栈里面的1、3进行比较，看看存不存在132模式，如果存在，皆大欢喜；如果不存在，执行2操作。 3、官方解法 官方解法。。。 总结 有几个小技巧：1、多个判断条件，把判断合法类型的放在前面。不然容易出错，例如 while(!s.empty()&&s.top()>=nums[i]) if(i<n-1&&nums[i]>=nums[i+1]) 判断栈是否为空，数组角标是否越界这种合法性方面的条件放在前面。如果顺序颠倒，会出现bug，我就吃了好几次这样的亏。 2、不知道大家怎么样，反正我找边界条件其实很费劲，那种合法性的啊，n-1，n-2这种其实一开始我根本想不到，都是测试的时候发现了问题，之后慢慢加的。。。但是我觉得这些条件也很重要。 
第489篇文章[1]
Unbuntu下的cmake..执行出错 项目场景： unbuntu下安装edb-debugger 问题描述： unbuntu下面安装edb-debugger来看程序的虚拟内存，安装教程如下：首先安装依赖包，然后从github上面安装edb-debugger按步执行既可以 安装#installdependencies sudoapt-getinstallcmakebuild-essentiallibboost-dev\ libqt5xmlpatterns5-devqtbase5-devqt5-default\ libqt5svg5-devlibgraphviz-devlibcapstone-dev 安装#buildandrunedb sudoaptinstallgit gitclone--recursivehttps://github.com/eteran/edb-debugger.git cdedb-debugger mkdirbuild cdbuild cmake..如出错sudoapt-getinstall--reinstallpkg-configcmake-data make ./edb--run执行程序 但是在cmake的时候遇到了这个问题，这步不解决接下来的make执行不了。 原因分析and解决方案： 通过观察错误信息和查阅相关资料一个类似的问题原因应该是没有–init--recursive这两个文件，再重新clone一下就可以了。 执行gitsubmoduleupdate--init--recursive命令即可。 但是与网站不同的是，我执行完了之后还有一些错误提示但是神奇的是不影响之后的make命令和./edb命令了，也算是成功解决了吧。 
第490篇文章[3]
leetcode 从先序序列判断是否为二叉树（中等） 文章目录 一、题目是什么？二、解答1.我的解法2.官方解法 总结 哈哈哈，孩子高兴疯了，半个小时的时间编出代码，用时打败100%，内存打败87.91%，孩子从来打代码没有这么爽过。。。。。。 提示：这题感觉属于抖机灵那种，没什么编程技巧，代码量也不大 一、题目是什么？ 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录。 _9_ /\ 32 /\/\ 41#6 /\/\/\ ###### 例如，上面的二叉树可以被序列化为字符串“9,3,4,#,#,1,#,#,2,#,6,#,#”，其中#代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示null指针的‘#’。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如“1,3”。 示例1: 输入:“9,3,4,#,#,1,#,#,2,#,6,#,#”输出:true示例2: 输入:“1,#”输出:false示例3: 输入:“9,#,#,1”输出:false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 二、解答 1.我的解法 我的想法很简单，就是判断字符串里面#的个数是不是数字个数+1.在之前的离散数学，数据结构里，我记得这样一条性质，二叉树里面，度为0的节点（也就是本题的空节点）是度为2的节点的数目+1，具体证明就是算两次，找边和顶点直接的关系，在此就不赘述了。 然后在反复提交修改的过程中，加了三个细节： 1、数字可以为多位的 2、空树的判断 3、null=node（d=2）+1，更完善一些，一旦先序序列的前i个元素满足了上面的关系，此时，如果后面还有元素，这也不是一颗二叉树。 代码如下： classSolution{ public: boolisValidSerialization(stringpreorder){ intn=preorder.size(); intpre=0; inttree=0,node=0; if(preorder[0]=='#'&&n!=1)returnfalse;//空树判断 for(inti=0;i<n;i++){ if(preorder[i]=='#')node++; if(isdigit(preorder[i])&&pre!=i-1){//注意，这里的数字不一定是个位，要考虑到多位的情况 pre=i; tree++;} if(node==tree+1&&i!=n-1)returnfalse;//如果前面已经成树，那么后面就不可能再和前面组成一棵新的二叉树了 } if(node==tree+1)returntrue; elsereturnfalse; } }; 2.官方解法 让我小小的骄傲一下，此时我想大声的说一句话：你个垃圾！！！(心酸，这都是以前我看完官方代码之后对自己说的话，风水轮流转啊。。。嚣张ing) 官方思路：方法一：栈我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。 二叉树的建立也伴随着槽位数量的变化。 如果遇到了空节点，则要消耗一个槽位；如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。此外，还需要将根节点作为特殊情况处理。 我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处剩余槽位的数量，而栈顶元素就对应着下一步可用的槽位数量。当遇到空节点时，仅将栈顶元素减1；当遇到非空节点时，将栈顶元素减1后，再向栈中压入一个2。无论何时，如果栈顶元素变为0，就立刻将栈顶弹出。 遍历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽位数量不足，则序列不合法。 复杂度分析 时间复杂度：O(n)，其中n为字符串的长度。我们每个字符只遍历一次，同时每个字符对应的操作都是常数时间的。 空间复杂度：O(n)。此为栈所需要使用的空间。 方法二：计数能否将方法一的空间复杂度优化至O(1)呢？ 回顾方法一的逻辑，如果把栈中元素看成一个整体，即所有剩余槽位的数量，也能维护槽位的变化。 因此，我们可以只维护一个计数器，代表栈中所有元素之和，其余的操作逻辑均可以保持不变。 PS：个人感觉代码一直在数空槽位的个数 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 方法二代码如下（示例）： classSolution{ public: boolisValidSerialization(stringpreorder){ intn=preorder.length(); inti=0; intslots=1; while(i<n){ if(slots==0){ returnfalse;//如果没有槽位了，但是还有元素，那么这个树就是错的啦 } if(preorder[i]==','){ i++; }elseif(preorder[i]=='#'){ slots--;//遇到空节点，槽位被占用 i++; }else{ //读一个数字 while(i<n&&preorder[i]!=','){ i++; } slots++;//slots=slots-1+2，遇到非空节点，槽位+1 } } returnslots==0;//判断条件哦 } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/yan-zheng-er-cha-shu-de-qian-xu-xu-lie-h-jghn/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结 本题有两种思路，一种就是我的想法，发掘二叉树的数学性质，找到判断二叉树的充要条件。一种就是官方的，找槽位，他没有深入挖掘二叉树的数学性质，但是想的很直接，只要没有槽位可以让节点填充，那么这个树就是false，然后维护一个计数器。其实这种想法更正统一般一些，有值得学习的地方。 
第491篇文章[5]
CSAPP大作业hello的一生 我的github仓库地址 
第492篇文章[]
Java里long类型除法转double 问题描述： java里面两个long类型的数相除，想要得到double类型的结果。 publicstaticvoidmain(String[]args)throwsException{ longa=2; longb=3; doublec=a/b; System.out.println(c); } 结果得到了0.0 解决方案： 数据类型强制转化。 publicstaticvoidmain(String[]args)throwsException{ longa=2; longb=3; //或者doublead=(double)a; //doublec=ad/b; doublec=(double)a/b; System.out.println(c); } 得到结果0.666666666 
第493篇文章[3]
leecode 螺旋矩阵 文章目录 前言一、题目是什么？二、解答1.我的解答2.官方 总结 前言 提示：前两天leecode上面的题都是和hash映射有关，数据结构倒是讲了相关内容，但是孩子当时没有代码实践。。。总的来说，hash就是一种基于地址直接查找的算法，突破了传统的查找算法，比如，顺序查找，二分查找，B树查找之类的乱七八糟的查找的时间极限。学习了一下代码，倒是没有自己打。 提示：以下是本篇文章正文内容，本次代码思维量较少，还是考察代码功底，注意数组不要越界！ 一、题目是什么？ 给你一个m行n列的矩阵matrix，请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例1： 输入：matrix=[[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例2： 输入：matrix=[[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 二、解答 1.我的解答 大致思路是这样的，由于每次读一圈，规律都是相似的，所有考虑递归。本质上就是坐标（i,j）在边界上的循环。 值得注意的是，当写递归主函数的时候，有一些特殊情况要判断，比如只有一行，只有一列，只有两行，只有两列等等，避免重复。 本次代码用时，大概1：30分钟，中间debug主要是两个问题：1、递归函数传入参数的意义没有特别清楚，其实之前我还尝试过首坐标加行数之类的，但是写着写着自己就搞混了，导致了一些bug。 2、数组越界问题，我记得C语言里面，对于数组越界是没有专门的防护机制的，但是这个C++好像有哦（good！）出现了runtimeerror的问题，就是数组角标出现了-1之类的。 代码如下： classSolution{ public: vector<int>result; voidyouCanTry(vector<vector<int>>&matrix,inta,intb,intc,intd){ //a,b,行首(尾)坐标，c,d,列首（尾）坐标 if(b<a||d<c)return;//数组坐标越界检查，也是终止条件 if(b==a&&d==c){//只有一行一列 result.push_back(matrix[a][c]); return; } for(inti=c;i<=d;i++){ result.push_back(matrix[a][i]); //cout<<matrix[a][i]<<""; } if(b==a)return;//只有一行 for(inti=a+1;i<=b;i++){ //cout<<"wrong"; result.push_back(matrix[i][d]); //cout<<matrix[m-1][i]<<""; //向下 } if(d==c)return;//只有一列 for(inti=d-1;i>=c;i--){ result.push_back(matrix[b][i]); } //<- if(a==b-1)return;//只有两行 for(inti=b-1;i>a;i--){ result.push_back(matrix[i][c]); } youCanTry(matrix,a+1,b-1,c+1,d-1); } vector<int>spiralOrder(vector<vector<int>>&matrix){ intm=matrix.size();//行 intn=matrix[0].size();//列 youCanTry(matrix,0,m-1,0,n-1); returnresult; } }; 性能：执行用时：0ms,在所有C++提交中击败了100.00%的用户内存消耗：6.8MB,在所有C++提交中击败了42.19%的用户毕竟用了递归嘛，内存肯定是比纯循环要大的。 2.官方 leetcode官方解答<-点击这里官方解答很详细了，我总结一些就OK了，官解有两个，一个和我想的差不多，就是循环遍历矩阵，不过官方更厉害一点，他直接就是一个循环，而且代码写的也很漂亮！另一个是有点意思的，模拟：他规定了四个方向向量（注意，这个顺序也是有讲究的，符合这个螺旋方向的优先级）还有一个visited数组，标志是否当前节点被访问过。值得细细琢磨。 classSolution{ private: staticconstexprintdirections[4][2]={{0,1},{1,0},{0,-1},{-1,0}}; public: vector<int>spiralOrder(vector<vector<int>>&matrix){ if(matrix.size()==0||matrix[0].size()==0){ return{}; } introws=matrix.size(),columns=matrix[0].size(); vector<vector<bool>>visited(rows,vector<bool>(columns)); inttotal=rows*columns; vector<int>order(total); introw=0,column=0; intdirectionIndex=0; for(inti=0;i<total;i++){ order[i]=matrix[row][column]; visited[row][column]=true; intnextRow=row+directions[directionIndex][0],nextColumn=column+directions[directionIndex][1]; if(nextRow<0||nextRow>=rows||nextColumn<0||nextColumn>=columns||visited[nextRow][nextColumn]){//判断条件：越界，被访问过。 directionIndex=(directionIndex+1)%4; } //下一个方向向量一定就是了，如果不放心，可以把if改成while。 //我试了一下，改成while超出了时间限制，还是if把，因为它之前设的方向向量的顺序，就默认了下一个就是对的。 row+=directions[directionIndex][0]; column+=directions[directionIndex][1]; } returnorder; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结 好好学习，天天向上！！！多尝试，多实践！！！CSAPP我来了！！！ 
第494篇文章[3]
leetcode 不同的子序列（动态规划） 文章目录 前言一、题目二、解答1.我的超时方法2.答案的解答 总结 前言 字符串的动态规划问题，感觉找两个字符串之间的某种关系，比如最长公共子序列，回文序列之类的，都用到了动态规划。我记得floyd算法也是典型的动态规划问题。当初讲算法导论的时候，动态规划这里就听的迷迷糊糊的，我印象中好像就是填一个矩阵，这个矩阵有一些数很容易求，关键是找关系方程。实践倒是很少，这道题也算一个锻炼吧。 提示：代码大概20分钟打出来了，但是清晰的找到状态转移方程这个过程倒是摸索了很久，但是不幸的是，只用递归加状态转移方程超时了，因为有大量的重复计算。但是相同的思路，用上了动态规划，多了一步矩阵的转换和运算，就很好。 一、题目 给定一个字符串s和一个字符串t，计算在s的子序列中t出现的个数。字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE”是“ABCDE”的一个子序列，而“AEC”不是）题目数据保证答案符合32位带符号整数范围。 示例1： 输入：s=“rabbbit”,t=“rabbit”输出：3解释：如下图所示,有3种可以从s中得到“rabbit”的方案。(上箭头符号^表示选取的字母)rabbbit^^^^^^rabbbit^^^^^^rabbbit^^^^^^示例2： 输入：s=“babgbag”,t=“bag”输出：5解释：如下图所示,有5种可以从s中得到“bag”的方案。(上箭头符号^表示选取的字母)babgbag^^^babgbag^^^babgbag^^^babgbag^^^babgbag^^^ 提示： 0<=s.length,t.length<=1000s和t由英文字母组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/distinct-subsequences著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 二、解答 1.我的超时方法 解题思路“aabdbaabeeadcbbdedacbbeecbabebaeeecaeabaedadcbdbcdaabebdadbbaeabdadeaabbabbecebbebcaddaacccebeaeedababedeacdeaaaeeaecbe”“bddabdcae”这个测试用例，在leetcode上超出时间限制，自己用编译器打了一下，发现数是一样的，好难受。。。 大体的思路相当于是递归+发现状态转移方程s：a0a1…an-1t：b0b1…bm-1（1）如果a0！=b0，那么相当于对s：a1…an-1;t：b0b1…bm-1计算（2）如果a0==b0，分两种情况1、相当于对s：a1…an-1;t：b1…bm-1计算2、相当于对s：a1…an-1;t：b0b1…bm-1计算1、2加起来即可 代码如下： classSolution{ public: intnumDistinct(strings,stringt){ if(s.size()<t.size()||s.empty()||t.empty())return0; if(s.size()==t.size()&&s.compare(t)==0)return1; //if(s.size()==t.size()&&s.compare(t)!=0)return0; if(t.size()==1){ inti=0; intm=0; for(i=0;i<s.size();i++){ if(s[i]==t[0])m++; } returnm; } if(s.size()==1)returns[0]==t[0]; //终止条件 //递归主函数 if(s[0]!=t[0])returnnumDistinct(s.substr(1),t); elseif(s[0]==t[0])returnnumDistinct(s.substr(1),t.substr(1))+numDistinct(s.substr(1),t); elsereturn-1; } 2.答案的解答 leetcode官方解答很详细了，点击这里就好了 总结 状态转移方程结合动态规划使用更加哦，而且听说这还是一个典型的动态规划问题。。。。。。 
第495篇文章[]
java的String：==和equals（）区别 项目场景： 做MIT软件构造实验：ProblemSet2:PoeticWalks，实现Graph的implement CMU实验网站 问题描述： 问题是这样的，我定义了如下的一个类Edge, classEdge<L>{ //TODOfields privatefinalLsou; privatefinalLtar; privatefinalIntegerwei; //Abstractionfunction: //souisthesource,taristhetarget,weiistheweightonthedirectededgefromsourcetotarget //Representationinvariant: //true //Safetyfromrepexposure: //thefieldsareallprivatefinal //TODOconstructor publicEdge(Lsource,Ltarget,Integerweight){ sou=source; tar=target; wei=weight; checkRep(); } //TODOcheckRep publicvoidcheckRep(){ assertwei>0; assertsou!=null; asserttar!=null; } //TODOmethods //防御式拷贝 publicLgetSource(){ checkRep(); returnsou; } publicLgetTarget(){ checkRep(); returntar; } publicIntegergetWeight(){ checkRep(); returnwei; } //TODOtoString() publicStringtoString(){ checkRep(); returnthis.sou+"->"+this.tar+"weight:"+this.wei+"\n"; } } 现在我定义了一个List，里面的元素都是Edge，但是我想要比较两个Edge的source是否是一样的，发现如果直接用==，得到的结果永远是false，只有用equals方法才可以正确比较。 //firstversionalwaysfalse if(edges.get(i).getSource()==source) //secondversionwrightanswer if(edges.get(i).getSource().equals(source)) 而且最玄学的是，我在test里面跑的时候没有问题，但是将Graph作接口引入到了poem代码里面的时候这个问题才发现。 现在想想，这是因为我Junit测试的时候，输入的L都是常字符串，就是"a","b"这种直接赋值的，这种好像是==里面可以正常判断的。部分测试代码如下。 @Test publicvoidtestSourcesAndTarget(){ Graph<String>g=emptyInstance(); Stringa="a"; Stringb="b"; Stringc="c"; g.add(a); g.add(b); g.add(c); g.set(a,b,1); g.set(a,c,1); g.set(c,b,1); Map<String,Integer>res=g.targets(a); assertEquals(true,1==res.get(b)); assertEquals(true,1==res.get(c)); Map<String,Integer>res1=g.sources(b); assertEquals(true,1==res1.get(a)); assertEquals(true,1==res1.get(c)); } 原因分析： 后来我在想，为什么会发生这种事情呢？经过调查，我发现，由于我在poem里面应用的是String代替L。String可以用==和equals（）方法比较，==是比较两个字符串的首地址，equals（）方法是比较两个字符串的内容。所以对于两个不同的Edge里面的String类型的source，当然用==方法比较不出来的了。所以，以后比较String相等，保险起见，还是都用equals（）吧 简单的测试用例（来源） Strings1,s2,s3="abc",s4="abc"; s1=newString("abc"); s2=newString("abc"); System.out.println("s1==s2:"+(s1==s2));//false System.out.println("s1==s3:"+(s1==s3));//false System.out.println("s3==s4:"+(s3==s4));//true System.out.println("s1.equals(s2):"+(s1.equals(s2)));//true System.out.println("s1.equals(s3):"+(s1.equals(s3)));//true System.out.println("s3.equals(s4):"+(s3.equals(s4)));//true 拓展 注意：对于s3和s4来说，有一点不一样要引起注意，由于s3和s4是两个字符，串常量所生成的变量，其中所存放的内存地址是相等的，所以s3==s4是true（即使没有s3=s4这样一个赋值语句） 另外对于int等基本类型比较，只能用==，没有equals（）方法 对于基本类型的包装类型，比如Boolean、Character、Byte、Shot、Integer、Long、Float、Double等的引用变量，==是比较地址的，而equals是比较内容的（equals（）被重写了）。 对于object函数，equals（）也是比较首地址，可以在object函数里面重写equals方法，来达到比较的目的 
第496篇文章[1]
gcc编译32位代码出错 项目场景： vmware上的unbuntu终端，用gcc编译文件出错 问题描述： 前几天用vmware上的unbuntu终端，用gcc编译文件，出现了如下bug /usr/bin/ld:cannotfindScrt1.o:Nosuchfileordirectory /usr/bin/ld:cannotfindcrti.o:Nosuchfileordirectory /usr/bin/ld:skippingincompatible/usr/lib/gcc/x86_64-linux-gnu/9/libgcc.awhensearchingfor-lgcc /usr/bin/ld:cannotfind-lgcc /usr/bin/ld:skippingincompatible/usr/lib/x86_64-linux-gnu/libgcc_s.so.1whensearchingforlibgcc_s.so.1 /usr/bin/ld:cannotfindlibgcc_s.so.1 /usr/bin/ld:skippingincompatible/usr/lib/gcc/x86_64-linux-gnu/9/libgcc.awhensearchingfor-lgcc /usr/bin/ld:cannotfind-lgcc collect2:error:ldreturned1exitstatus 原因分析： 错误提示显示好几个文件都找不到，而且我之前用gcc编译文件也没有出现这个问题，-m32也用过。我上网查了很多办法，有的说要设置环境变量，有的说要重下（我之前其实下过）32位的包（一般下载的gcc默认是64位的），但是我试过，都没有用，气得我把unbuntu卸载了之后重装，发现还是一样的提示。 解决方案： 最后在stackflow上找到了答案https://stackoverflow.com/questions/6329887/compiling-problems-cannot-find-crt1-o（网站有时候不稳定，多试几次就OK） 只要执行这个命令，下载一个东西就可以正常编译了。 sudoaptinstallgcc-multilib stackflow解释：Theproblemisyoulikelyonlyhavethegccforyourcurrentarchitectureandthat’s64bit.Youneedthe32bitsupportfiles.Forthat,youneedtoinstallthem 
第497篇文章[]
Junit单元测试程序运行bug：ClassNotFoundException 问题描述： 利用Junit进行单元测试的时候，之前都可以，但是有一天突然不行了，出现了ClassNotFoundException的异常提示，并且对于所有的Junit测试都是一样的。 原因分析： 原因分析有很多，java这方面的bug解决方案也有很多，很多人说是因为版本不匹配，jre，jdk版本之类的，我也不太懂，但是亲测两种方法是有效的。重新下载jdk，jre什么的解决方案，不在我的考虑之内，因为这样太麻烦了。 解决方案： PS：之前试了更改.classpath文件，里面加了output信息；也尝试了这个blog的方法，但是都没有用 1、后来我自己尝试的一种方法： 类似重新加载Junit5包。 我之前导入的Junit5包，后来尝试导入了Junit4包，然后用他进行单元测试用例，但是这个时候eclipse出现了错误 提示只能用版本5进行测试，然后我又重新换回来Junit5，这次居然成功了！！！ 2、clean。后来有出现了一次这样的情况，这次在eclipse里，project->clean，重新再进行Junit测试 
第498篇文章[3]
leetcode 栈 文章目录 前言一、题目是什么？二、解法1.我的解法 很简单的暴力算法2.官方解法 栈 总结 前言 抱怨两句：前两天leetcode上的每日一题都是找回文串子集之类的题目，对于菜鸟的我来说有点难，确实写了很久还有bug，题目难度分别为中等，困难。今天这道题是简单的，思路比较直接，代码也比较简洁 一、题目是什么？ 给出由小写字母组成的字符串S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在S上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 输入：“abbaca”输出：“ca”解释：例如，在“abbaca”中，我们可以删除“bb”由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串“aaca”，其中又只有“aa”可以执行重复项删除操作，所以最后的字符串为“ca”。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string 二、解法 1.我的解法 很简单的暴力算法 个人想的很简单，就是循环遍历字符串，每次遍历的时候看看有没有可以删除的字符对，结束判断条件就用一个flag标记就OK了另外一点，C++是没有数组越界检查的（CSAPP曰），所以本人非常怕越界出bug，在很多必要不必要的地方都加了一些越界检查代码如下： classSolution{ public: stringremoveDuplicates(stringS){ inti; if(S.size()==1)returnS;//简单情况单独判断 boolflag;//标记是否已经完成删除 do{ flag=false; i=0; while(i<S.size()){ if(S[i]==S[i+1]) {S.erase(i,2); flag=true; } else{ i++; } if(S.size()==1)returnS; } if(flag==false)//没有修改 break; } while(flag==true); returnS; } }; 作者：kolerk 链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/kan-lai-wo-zhi-neng-zuo-chu-lai-jian-dan-ugs5/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2.官方解法 栈 先说一下两个解法的不同吧，官方因为调用了栈，所有内存更多，但是时间变少了，只要o（n）即可，但是个人解法就是内存少，但是时间多，而且时间复杂度依赖于string结构。其实我看到栈这个字的时候，我瞬间就想到了 妙啊！只要将栈顶的元素和下一个元素比较就好了，相同就弹出；不同就压栈。数据结构，永远的神！代码如下： classSolution{ public: stringremoveDuplicates(stringS){ stringstk; for(charch:S){ if(!stk.empty()&&stk.back()==ch){ stk.pop_back(); }else{ stk.push_back(ch); } } returnstk; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/shan-chu-zi-fu-chuan-zhong-de-suo-you-xi-4ohr/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结 下一次做题，可以想想栈啊，队列啊，树啥的，傻循环确实有点low。。。 
第499篇文章[3]
leetcode 基础计算器（中等） 文章目录 前言一、题目是什么？二、解答1.我的解答2.官方 总结 前言 基础运算器，没有括号，只有加减乘除，运算数字不一定是只有一位的0~9，可能是多位。在提交了7遍之后，终于通过了。。。（大哭） 提示：本题思路及其简单直接，关键就是一些编程技巧，用得好可以简化代码 一、题目是什么？ 给你一个字符串表达式s，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。 示例1： 输入：s=“3+2*2”输出：7示例2： 输入：s="3/2"输出：1示例3： 输入：s="3+5/2"输出：5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/basic-calculator-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 注：虽然示例给的是个位数，但是题目要求是对于十进制数都可以的，要考虑如何把字符串转化为数字。 二、解答 1.我的解答 分析：先乘除，后加减。运算符号和数字分别压栈乘除：遍历一遍字符串：1、遇到space，直接跳过2、遇到数字，判断它到底有几位，利用ASCLL将字符串转化为longint整型(之前用过int整型，但是在测试中出现了溢出现象)3、遇到加减，符号压栈3、遇到*\，将这个符号前后两个数运算，将计算结果代替原来的top()。 加减：乘除中，我是在字符串从前往后这么遍历的，这就导致一个问题，之后进行加减运算的时候，还要把栈中元素的顺序reverse。所以我在想，从后往前，会不会节省内存，这样就不用在reverse栈了。 classSolution{ public: //第一遍先算乘除，第二遍算加减 // intcalculate(strings){ stack<longint>symbol;//储存运算符号 stack<int>num; stack<longint>symbol1;//储存运算符号 stack<int>num1; intn=s.size(); longinttemp=0;//溢出 longinthelp=0; inti=0,j=-1; //先乘除 while(i<n){ if(s[i]==32)i++; elseif(s[i]>='0'&&s[i]<='9'){ if(j==i-1&&j!=-1){ temp=num.top(); num.pop(); temp=temp*10+s[i]-'0'; num.push(temp); j=i; i++;//考虑一下十位数 } else{ num.push(s[i]-'0'); j=i; i++; } } elseif(s[i]==43){//+ symbol.push(1); i++; } elseif(s[i]==45){//- symbol.push(-1); i++; } elseif(s[i]==42){//* temp=num.top(); num.pop(); j=1; while(s[i+j]==32)j++; i=i+j;//开始下一个数 help=0; while(s[i]>='0'&&s[i]<='9'){ help=help*10+s[i]-'0'; i++; } temp=temp*help; num.push(temp); } elseif(s[i]==47){/// temp=num.top(); num.pop(); j=1; while(s[i+j]==32)j++; i=i+j;//开始下一个数 help=0; while(s[i]>='0'&&s[i]<='9'){ help=help*10+s[i]-'0'; i++; } temp=temp/help; num.push(temp); } else{ cout<<"wrong!"<<endl; } } while(!symbol.empty()){ symbol1.push(symbol.top()); symbol.pop(); } while(!num.empty()){ num1.push(num.top()); num.pop(); } //后加减 while(!symbol1.empty()){ if(symbol1.top()==1){ temp=num1.top(); num1.pop(); temp=temp+num1.top(); num1.pop(); num1.push(temp); symbol1.pop(); } elseif(symbol1.top()==-1){ temp=num1.top(); num1.pop(); temp=temp-num1.top(); num1.pop(); num1.push(temp); symbol1.pop(); } else{ cout<<"wrong!"<<endl; } } temp=num1.top(); returntemp; } }; 2.官方 由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值。 基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。 具体来说，遍历字符串ss，并用变量\textit{preSign}preSign记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据\textit{preSign}preSign来决定计算方式： 加号：将数字压入栈；减号：将数字的相反数压入栈；乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新preSign为当前遍历的字符。 遍历完字符串s后，将栈中元素累加，即为该字符串表达式的值。 作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/basic-calculator-ii/solution/ji-ben-ji-suan-qi-ii-by-leetcode-solutio-cm28/来源：力扣（LeetCode） 优点：将加减统一为加（减去相反数）。减少内存和时间。 classSolution{ public: intcalculate(strings){ vector<int>stk; charpreSign='+'; intnum=0; intn=s.length(); for(inti=0;i<n;++i){ if(isdigit(s[i])){//专门判断数字的函数 num=num*10+int(s[i]-'0'); } if(!isdigit(s[i])&&s[i]!=''||i==n-1){//判断符号,多个判断条件一起考虑 //排除space，确定终止条件 switch(preSign){ case'+': stk.push_back(num); break; case'-': stk.push_back(-num); break; case'*': stk.back()*=num; /*temp=stk.top(); stk.pop(); temp=temp*num; stk.push(temp); */ break; default: stk.back()/=num; } preSign=s[i]; num=0; } } returnaccumulate(stk.begin(),stk.end(),0);//另一个高级函数，计算栈里面的元素之和 } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/basic-calculator-ii/solution/ji-ben-ji-suan-qi-ii-by-leetcode-solutio-cm28/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结 之前学习数据结构的时候，在栈的应用那一节，详细讲了如何通过栈进行四则运算，记得还有专门的后缀，前缀写法。现在都已经忘得七七八八了，只记得如果遇到右括号，就一直弹栈，直到弹到第一个左括号为止。但是面对千奇百怪的问题变形，记得理论什么的可能也没多大用了，一些基本的思想，包括实践的经验还有待慢慢积累练习。。。。。。 
第500篇文章[3]
leetcode 单调栈 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档 文章目录 题目一、我的代码二、看了答案之后我悟了1.先上官方代码2.我的解读单调栈是什么？ 总结 题目 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字x的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出-1。 示例1:输入:[1,2,1]输出:[2,-1,2]解释:第一个1的下一个更大的数是2；数字2找不到下一个更大的数；第二个1的下一个最大的数需要循环搜索，结果也是2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/next-greater-element-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 提示：以下是本篇文章正文内容，下面案例可供参考 一、我的代码 思路很简单，就是两个循环便利，既然找后一个大的，我就一直往后找嘛，可以说是暴力算法 classSolution{ public: vector<int>nextGreaterElements(vector<int>&nums){ vector<int>res; if(nums.empty())returnnums; intlen=nums.size(); inti,j; for(i=0;i<len;i++){ j=(i+1)%len; while(nums[j]<=nums[i]){ if(j==i){ res.push_back(-1); break; } else { j=(j+1)%len; } } if(j!=i) res.push_back(nums[j]); } returnres; } }; 二、看了答案之后我悟了 1.先上官方代码 代码如下（示例）： classSolution{ public: vector<int>nextGreaterElements(vector<int>&nums){ intn=nums.size(); vector<int>ret(n,-1); stack<int>stk; for(inti=0;i<n*2-1;i++){ while(!stk.empty()&&nums[stk.top()]<nums[i%n]){ ret[stk.top()]=nums[i%n]; stk.pop(); } stk.push(i%n); } returnret; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/next-greater-element-ii/solution/xia-yi-ge-geng-da-yuan-su-ii-by-leetcode-bwam/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2.我的解读 代码如下（示例）： 思路是单调栈+一次循环我是这样想的：你看，在我们之前的暴力算法的时候，是不是有一些重复的比较，比如a>b>c但是他们之后的d比a还要大，那么a，b，c的后一个最大不就都是d了，这样就省去了b和c的比较。所以基于这个小发现，我们想到了单调栈这个高级名词， 单调栈是什么？ 就是这个栈的栈底到栈顶的元素都是单调的，在本题里面，就是单调不升。这样当你遇到了一个命中注定的d之后，就可以把栈里面的元素都弹出，他们对应的元素都是d了。另外，对于循环这个东西，在数组后面复制前面的n-1个元素就可以了，官方说这是把数组拉直，其实就是取模（哭） 该处使用的url网络请求的数据。 总结 好久没有打代码了，手都生了，好多之前的语法之类的都忘的差不多了，比如vector，stack等基本操作，bug也出的莫名其妙，居然是数组名写串了。。。新学期，希望可以坚持刷题 leetcode每日一题之单调栈 题目一、我的代码二、看了答案之后我悟了1.先上官方代码2.我的解读单调栈是什么？ 总结 
第501篇文章[5]
软构复习【5】 
第502篇文章[]
【总结】Obj&Spec SPEC Object 属性/数据 可变的不可变的方法 Spec实现 Spec: 定义：双方的“合同”/”防火墙“（外部不可见）基本结构： 前置条件（对参数的约束，对客户端的约束）后置条件（对返回值的约束，对开发者的约束）原则：​前置满足---->后置必须满足前置满足 >？(failfine)​Spec是给客户端看的，不要把程序内部暴露出来强度： stronger（对客户端更加友好/易使用，对开发者要求更高/难设计/实现方式更少）： 前置条件更弱,后置条件更强（在前置条件一样的情况下） 【注：看PPT的几个例子】 下面情况不可比较强度： ​前置变弱且前置相同时，后置变弱 ​当不可比较的时候，两个spec无法替代另一个 ​当可以比较的时候，可以用stronger的条件代替weaker的条件 Spec的强度： A>b: 可以用A取代b preA<=preb更弱的前置条件postA>=postb(以b的pre为准）更强的后置条件 更强的spec实现自由度小，难于开发易于使用ven图：更大的圈代表更大的实现自由度，spec强度更低 可以让后置条件减弱：Throwerror 参数检查的代价： 代价高：不实现，写在pre-condition中 代价低：检查，直接在post中抛出异常 
第503篇文章[]
2021-06-06ADT总结 ADT总结 1.ADT的内容 属性（名词）rep内部数据结构不可见方法（动词）Spec规约impl实现方法，功能Spec可见impl不可见 对外部只有接口，封装后用户不关心内部 1.1ADT的内部方法可以大致分为以下四类 creator构造器 ​初始化，新建一个ADT对象 a.new() b.静态工厂：graph.empty() producer生产器 ​比如String.concat()能够返回一个新的对象,不改变内部数据 observer观察器 Eg:.size()看内部东西，不改变内部数据 mutator变值器Eg.Add()修改内部数据​大部分返回void/bool​只有mutable类型才有！ 1.2表示独立性 内部变化后，外部不因此受影响 ​为什么内部会变化(impl)？（优化性能，多种实现）​内部变化一定要遵循spec!(测试用例就是根据spec写的） 对于客户端，只能见到spec，无法看见rep和impl 比如：List可以有两种实现方式： Lista=NewarrayList Listb=NewlinkeList 但是从外部看来，调用方法并没有差异（比如.Add()、.remove()方法是一样的） 内部rep应该是private而不是public用户端使用的API不应该因为内部rep实现的改变而瘫痪 1.3表示泄漏/repexposure： ​个人理解：client获取到了你内部变量/获取到了你的内部实现方法（本来不应该看到的，给人看到了！） 如何避免表示泄漏： 全部属性private对于mutable类型 Collection.unmodifiable.wraped)（解决拷贝空间问题）防御式拷贝（返回一个拷贝后的新的对象） 尽可能用immutable数据类型 1.4如何测试一个ADT的方法（测试用例） adt的四种方法、 c/p/m用observer查看属性O先用c/p造出，再调用o代码覆盖率无须100% 2.ADT的不变性 “始终保持为真的一组条件” 2.1抽象空间A,实际空间R 抽象空间A：用户看到的值;(Abstract)实际空间R：内部维系的值(Realization) A中的值，一定能够在R中至少找到一个值与之对应(满射） ​（但是不是单射不一定） 2.2AFRI概念 AF（abstractfunction）抽象函数（就是A--R之间的函数） 抽象函数是表示从表示空间到抽象空间映射的函数比如：我存了一个graph图来表示人际关系​AF(graph)=现实中的人际关系图RI（repinvariant）表示不变量 表示不变量将表示变量值映射成一个布尔值。简单来说，就是一个条件，判断内部元素是否合法。比如：我要求图graph不为空，那么RI中就是“图不为空”这个条件。Checkrep():满足条件，合法；不满足，非法！使得属性都满足RI为true每个方法返回之前调用 用Assert+表达式 False:throwAssertErro(直接退出！违反了RI，程序没有必要继续错误地执行） 调用时机： C/P/M最后一行返回之前。 O按道理来说不会改变RI，但是防止粗心，也需要在最后写一个。 每次都调用，增加复杂度？ 开关！ -ea开发的时候，打开assert -da交付的时候，关闭assert 参考：AFRI的概念 unmodifiableList返回一个只能看不能改的方法 3.ADT的设计流程 设计一组方法（C/T/M/O）以及specTDD测试用例（根据spec）选择Rep（内部数据结构）/并impl设计RI（比如边的权值不为负，点不能为空）设计AF（R >A)（比如边对应人际关系）RI/AF的注释是为了提醒自己怎么避免表示泄漏（mutable与immutable都要考虑） 4.ADT如何保持表示不变性 对于immutable，只要保证没有/M对于RI：checkRep()无表示泄漏！（见1.3） 
第504篇文章[5]
【软构课堂笔记3：面向对象编程】 
第505篇文章[1]
CSAPP2021helloP2P 计算机系统 大作业 题目*程序人生-Hello’sP2P* 专业*计算机科学与技术* 学 号*1190301804* 班 级*1936602* 学生*梁成 * 指导教师*刘宏伟 * 计算机科学与技术学院 2021年6月 [[]{#_Toc250450163.anchor}]{#_Toc225579639.anchor}摘要 hello’P2P介绍了hello.c程序从诞生到结束的全过程，包括预处理、编译、汇编、链接、进程等。我们主要使用gcc,edb,gdb等工具在linus下对hello进行一系列操作和分析，在这个过程中搭建起了认识计算机底层的框架，加深对CSAPP课本知识点的理解。 **关键词：**hello；P2P；计算机系统；Ubuntu；CSAPP； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） **** 目录 第1章概述-5- 1.1.Hello简介-5- 1.2.环境与工具-5- 1.3.中间结果-5- 1.4.本章小结-5- 第2章预处理-7- 2.1.预处理的概念与作用-7- 2.2.在Ubuntu下预处理的命令-7- 2.3.Hello的预处理结果解析-7- 2.4.本章小结-8- 第3章编译-9- 3.1.编译的概念与作用-9- 3.2.在Ubuntu下编译的命令-9- 3.3.Hello的编译结果解析-10- 3.3.1.文件声明解析-10- 3.3.2.数据与赋值解析-10- 3.3.3.算术操作-11- 3.3.4.关系操作与转移控制-11- 3.3.5.数组/指针/结构操作-11- 3.3.6.函数操作-12- 3.3.7.类型转换-13- 3.4.本章小结-13- 第4章汇编-14- 4.1.汇编的概念与作用-14- 4.2.在Ubuntu下汇编的命令-14- 4.3.可重定位目标elf格式-14- 4.3.1.获取ELF文件的命令-14- 4.3.2.ELF文件结构：-15- 4.3.3.ELFHeader-15- 4.3.4.SectionHeader-16- 4.3.5.重定位节-16- 4.3.6.符号表-17- 4.4.Hello.o的结果解析-18- 4.5.本章小结-19- 第5章链接-21- 5.1.链接的概念与作用-21- 5.2.在Ubuntu下链接的命令-21- 5.3.可执行目标文件hello的格式-21- 5.4.hello的虚拟地址空间-23- 5.5.链接的重定位过程分析-25- 5.5.1.hello相对hello.o的内容变化-25- 5.5.2.链接的过程-27- 5.6.hello的执行流程-27- 5.7.Hello的动态链接分析-28- 5.8.本章小结-29- 第6章hello进程管理-30- 6.1.进程的概念与作用-30- 6.2.简述壳Shell-bash的作用与处理流程-30- 6.3.Hello的fork进程创建过程-30- 6.4.Hello的execve过程-31- 6.5.Hello的进程执行-31- 6.6.hello的异常与信号处理-32- 6.7.本章小结-35- 第7章hello的存储管理-36- 7.1.hello的存储器地址空间-36- 7.2.Intel逻辑地址到线性地址的变换-段式管理-36- 7.3.Hello的线性地址到物理地址的变换-页式管理-37- 7.4.TLB与四级页表支持下的VA到PA的变换-39- 7.5.三级Cache支持下的物理内存访问-40- 7.6.hello进程fork时的内存映射-41- 7.7.hello进程execve时的内存映射-41- 7.8.缺页故障与缺页中断处理-42- 7.9.动态存储分配管理-43- 7.10.本章小结-45- 第8章hello的IO管理-46- 8.1.Linux的IO设备管理方法-46- 8.2.简述UnixIO接口及其函数-46- 8.3.printf的实现分析-47- 8.4.getchar的实现分析-49- 8.5.本章小结-49- 第9章结论-50- 第10章附件-51- 第11章参考文献-52- 概述 Hello简介 P2P过程：将hello.c经过预处理->编译->汇编->链接四个步骤生成hello的二进制可执行文件，在shell中为其fork出进程并执行。 020过程：shell开始执行并为其映射出虚拟内存，然后在开始运行进程的时候分配并载入物理内存，开始执行hello的程序，将output显示到屏幕，最后hello进程结束，shell回收内存空间。 环境与工具 硬件环境：处理器：Intel®Core™i7-8550UCPU@1.80GHz1.99GHz RAM：8.00GB系统类型：64位操作系统，基于x64的处理器 软件环境：Windows1064位；Ubuntu19.04 开发与调试工具：gcc，as，ld，vim，edb，readelf，VS 中间结果 文件的作用文件名*预处理后的文件hello.i*编译之后的汇编文件hello.s*汇编之后的可重定位目标文件hello.o*链接之后的可执行目标文件Hello*Hello.o的ELF格式elf.txt*Hello.o的反汇编代码disassemble_hello.s*hello的ELF格式helloELF.elfhello的反汇编代码disassemble_hello_o.s 本章小结 本章主要介绍了hello的P2P，020过程，以及进行实验时的软硬件环境及开发与调试工具和在本论文中生成的中间结果文件。 （第1章0.5分） 预处理 预处理的概念与作用 预处理概念： 预处理以展开的#开头，试图解释为预处理指令。其中ISOC/C++要求支持的包括#if、#ifdef、#ifndef、#else、#elif、#endif（条件编译）、#define（宏定义）、#include（源文件包含）、#line（行控制）、#error（错误指令）、#pragma（和实现相关的杂注）以及单独的#（空指令）。预处理指令一般被用来使源代码在不同的执行环境中被方便的修改或者编译 预处理作用： 将源文件中用#include形式声明的文件复制到新的程序中。比如hello.c第6-8行中的#include<stdio.h>等命令告诉预处理器读取系统头文件stdio.hunistd.hstdlib.h的内容，并把它直接插入到程序文本中。特殊符号，预编译程序可以识别一些特殊的符号，预编译程序对于在源程序中出现的这些串将用合适的值进行替换。用实际值替换用#define定义的字符串根据#if后面的条件决定需要编译的代码 在Ubuntu下预处理的命令 命令：cpphello.c>hello.i [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3tz6vfao-1623927515230)(media/image2.png)]{width=“5.340972222222222in”height=“0.2048611111111111in”} 图1cpp命令 Hello的预处理结果解析 预处理器（cpp）根据以字符#开头的命令，修改原始的c程序。比如hello.c中第1行的#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并将它直接插入到程序文本中。 打开hello.i，原来以#开头的行发生了扩展。总内容扩展到了3065行，而hello.c的内容出现在3046行，在其之前的内容是#号对应宏展开(stdio.h,unistd.h,stdlib.h)。 本章小结 本章主要介绍了预处理（包括头文件的展开、宏替换、去掉注释、条件编译）的概念和应用功能，以及Ubuntu下预处理的两个指令，同时具体到我们的hello.c文件的预处理结果hello.i文本文件解析，详细了解了预处理的内涵 （第2章0.5分） 编译 编译的概念与作用 编译的概念： 编译阶段将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级程序机器语言指令。 编译包括以下基本流程： 语法分析：编译程序的语法分析器以单词符号作为输入，分析单词符号串是否形成符合语法规则的语法单位，方法分为两种：自上而下分析法和自下而上分析法。中间代码：源程序的一种内部表示，或称中间语言。中间代码的作用是可使编译程序的结构在逻辑上更为简单明确，特别是可使目标代码的优化比较容易实现中间代码。代码优化：指对程序进行多种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。目标代码：生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。此处指汇编语言代码，须经过汇编程序汇编后，成为可执行的机器语言代码。 编译的作用： 它把高级语言翻译成更接近机器语言的汇编语言，使生成过程更加方便顺畅，以便机器读取。还具有语法检查，调试措施，修改手段。 在Ubuntu下编译的命令 命令：gcc-Shello.i-ohello.s [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XskExuND-1623927515231)(media/image3.png)]{width=“5.280555555555556in”height=“0.25in”} 图2gcc命令 Hello的编译结果解析 文件声明解析 声明含义.file源文件.text代码段.data数据段，存储已初始化的全局和静态c变量.align对齐格式.type符号类型.size数据空间大小.sectionrodata只读代码段.global全局变量.string字符串类型数据.long长整型数据 数据与赋值解析 全局变量 定义sleepsecs全局变量在汇编文件中sleepsecs的内容 intsleepsecs=2.5;.text .globlsleepsecs .data .align4 .typesleepsecs,@object .sizesleepsecs,4 .globl声明了这是一个全局变量；.type说明了类型是一个数据；.size说明了这个变量的大小，这里sleepsecs变量占了4个字节 常量 printf打印字符串字符串内容保存 printf(“Usage:Hello学号姓名！\n”);.LC0: printf(“Hello%s%s\n”,argv[1],argv[2]);.string“Usage:Hello\345\255\246\345\217\267\345\247\223\345\220\215\357\274\201” .LC1: .string"Hello%s%s\\n" printf()函数的字符串常量被存储在.rodata节中 局部变量 初始化i=0将0存入-4(%rbp)处 for(i=0;i<10;i++).L2: movl\$0,-4(%rbp) jmp.L3 局部变量存储在寄存器或者栈中。 在这里局部变量i被存储在-4(%rbp)处。 算术操作 循环过程的自加操作addl操作，栈上存储的变量+1 for(i=0;i<10;i++)addl$1,-4(%rbp) cmpl\$9,-4(%rbp) jle.L4 关系操作与转移控制 判断参数argc是否小于4cmpl操作 if(argc!=3)cmpl\$3,-20(%rbp) je.L2 循环过程中判断i是否<10cmpl操作 for(i=0;i<10;i++)cmpl$9,-4(%rbp) jle.L4 利用cmpl操作和je指令，实现转移控制 数组/指针/结构操作 字符指针数组char*argv[]:存储用户输入的命令行信息地址 argv[0]指向输入程序的路径与名称，argv[1]argv[2]指向字符串（学号/姓名） 该数组中每个元素大小为8bit，argv既是数组名也是数组的首地址 main函数中访问数组元素argv[1],argv[2]时，按照起始地址argv大小8B计算数据地址取数据，在hello.s中，使用两次(%rax)（两次rax分别为argv[1]和argv[2]的地址）取出其值。 如下图： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bWM4ispI-1623927515233)(media/image4.png)]{width=“3.1590277777777778in”height=“0.8715277777777778in”} 图3main函数的参数 函数操作 函数是一种过程，过程提供了一种封装代码的方式，用一组指定的参数和可选的返回值实现某种功能。P中调用函数Q包含以下动作： 1）传递控制：进行过程Q的时候，程序计数器必须设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。 2）传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P中返回一个值。 3）分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，必须释放这些空间。 X86-64中,过程调用传递参数规则： 第1~6个参数一次储存在%rdi、%rsi、%rdx、%rcx、%r8、%r9这六个寄存器中，剩下的参数保存在栈当中。 main() 传递控制：被系统启动函数调用。 传递数据：传入参数argc和argv[]，分别用寄存器%rdi和%rsi存储。 返回内容：设置%eax为0并且返回，对应return0 printf() printf(“Usage:Hello学号姓名！\n”);leaq.LC0(%rip),%rdi callputs@PLT 传递控制：if判断满足条件后调用 传递数据：callputs时只传入了字符串参数的首地址；（%rdi） printf(“Hello%s%s\n”,argv[1],argv[2]);.L4: movq-32(%rbp),%rax addq\$16,%rax **movq**(%rax),%rdx*//第三个参数：获得argv\[1\]的内容* movq-32(%rbp),%rax addq\$8,%rax **movq**(%rax),%rax movq%rax,%rsi*//第二个参数：传入参数argv\[2\]* leaq.**LC1**(%rip),%rdi*//第一个参数：.LC1的首地址* movl\$0,%eax callprintf@PLT 传递控制：在for循环中调用 传递数据：callprintf时还传入了argv[1]和argv[2]的地址。(%rsi%rdx) exit() 传递控制：在if判断满足后调用 传递数据：传入参数为1（%edi） exit(1);movl$1,%edi callexit@PLT sleep() 传递控制：在循环内部用 传递数据：传入sleepsecs（%edi） sleep(sleepsecs);movl%eax,%edi callsleep@PLT getchar() getchar();callgetchar@PLT 类型转换 程序中涉及隐式类型转换的是： intsleepsecs=2.5; 当在double或float向int进行类型转换的时候，程序改变数值和位模式的原则是：值会向零舍入。例如1.999将被转换成1，-1.999将被转换成-1。进一步来讲，可能会产生值溢出的情况，与Intel兼容的微处理器指定位模式[10…000]为整数不确定值，一个浮点数到整数的转换，如果不能为该浮点数找到一个合适的整数近似值，就会产生一个整数不确定值。 浮点数默认类型为double，所以上述强制转化是double强制转化为int类型。遵从向零舍入的原则，将2.5舍入为2。 本章小结 本章主要介绍了编译的概念与作用，同时通过对hello.s汇编代码的分析，分析了C语言的各个数据类型与操作在汇编代码中的实现。 通过本章内容，我更深刻地理解了C语言与汇编语言之间的关系，也进一步熟悉了汇编代码，理解了编译的概念。 汇编 汇编的概念与作用 概念 驱动程序运行汇编器as，将汇编语言（hello.s）翻译成机器语言（hello.o）的过程称为汇编。 （hello.o也是可重定位目标文件） 作用 将高级语言转化为机器可直接识别执行的代码文件：将.s汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序格式并保存在.o二进制文件中。 在Ubuntu下汇编的命令 Linus>ashello.s-ohello.o [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OZm7AQ4k-1623927515234)(media/image5.png)]{width=“4.310416666666667in”height=“0.9923611111111111in”} 图4as命令获取hello.o 可重定位目标elf格式 获取ELF文件的命令 Linus>readelf-ahello.o>./elf.txt获得ELF.txt文件 ELF文件结构： 如图，夹在ELF头和节头部表之间的都是节，ELF中存储了很多不同的节的信息，每一个节中保存了程序中对应的一些变量或者重定位等这些信息。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cCv4D1TI-1623927515235)(media/image6.png)] 图5ELF文件结构 ELFHeader 从16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable的文件偏移，以及节头部表中条目的大小和数量等信息。 ELFHeader: Magic:7f454c46020101000000000000000000 Class:ELF64 Data:2’scomplement,littleendian Version:1(current) OS/ABI:UNIX-SystemV ABIVersion:0 Type:REL(Relocatablefile) Machine:AdvancedMicroDevicesX86-64 Version:0x1 Entrypointaddress:0x0 Startofprogramheaders:0(bytesintofile) Startofsectionheaders:1232(bytesintofile) Flags:0x0 Sizeofthisheader:64(bytes) Sizeofprogramheaders:0(bytes) Numberofprogramheaders:0 Sizeofsectionheaders:64(bytes) Numberofsectionheaders:14 Sectionheaderstringtableindex:13 SectionHeader 节头部表描述不同节的位置和大小，目标文件中1每个节都有一个固定大小的条目，相关信息包括节的名称，类型，地址，偏移量，对齐，旗标等 SectionHeaders: [Nr]NameTypeAddressOffset SizeEntSizeFlagsLinkInfoAlign [0]NULL000000000000000000000000 00000000000000000000000000000000000 [1].textPROGBITS000000000000000000000040 00000000000000850000000000000000AX001 [2].rela.textRELA000000000000000000000380 00000000000000c00000000000000018I1118 [3].dataPROGBITS0000000000000000000000c8 00000000000000040000000000000000WA004 [4].bssNOBITS0000000000000000000000cc 00000000000000000000000000000000WA001 [5].rodataPROGBITS0000000000000000000000cc 000000000000002b0000000000000000A001 [6].commentPROGBITS0000000000000000000000f7 000000000000002b0000000000000001MS001 [7].note.GNU-stackPROGBITS000000000000000000000122 00000000000000000000000000000000001 [8].note.gnu.propertNOTE000000000000000000000128 00000000000000200000000000000000A008 [9].eh_framePROGBITS000000000000000000000148 00000000000000380000000000000000A008 [10].rela.eh_frameRELA000000000000000000000440 00000000000000180000000000000018I1198 [11].symtabSYMTAB000000000000000000000180 00000000000001b0000000000000001812108 [12].strtabSTRTAB000000000000000000000330 000000000000004d0000000000000000001 [13].shstrtabSTRTAB000000000000000000000458 00000000000000740000000000000000001 KeytoFlags: W(write),A(alloc),X(execute),M(merge),S(strings),I(info), L(linkorder),O(extraOSprocessingrequired),G(group),T(TLS), C(compressed),x(unknown),o(OSspecific),E(exclude), l(large),p(processorspecific) 从节头部表中我们得知，hello.o一共有13个节。 重定位节 表述了各个段引用的外部符号等。在链接时，需要通过重定位节对这些位置的地址进行修改。链接器会通过重定位条目的类型通过偏移量等信息计算出正确的地址。 Relocationsection‘.rela.text’atoffset0x380contains8entries: OffsetInfoTypeSym.ValueSym.Name+Addend 00000000001c000500000002R_X86_64_PC320000000000000000.rodata-4 000000000021000d00000004R_X86_64_PLT320000000000000000puts-4 00000000002b000e00000004R_X86_64_PLT320000000000000000exit-4 000000000054000500000002R_X86_64_PC320000000000000000.rodata+1a 00000000005e000f00000004R_X86_64_PLT320000000000000000printf-4 000000000064000a00000002R_X86_64_PC320000000000000000sleepsecs-4 00000000006b001000000004R_X86_64_PLT320000000000000000sleep-4 00000000007a001100000004R_X86_64_PLT320000000000000000getchar-4 Relocationsection‘.rela.eh_frame’atoffset0x440contains1entry: OffsetInfoTypeSym.ValueSym.Name+Addend 000000000020000200000002R_X86_64_PC320000000000000000.text+0 以上8条重定位信息分别是对.L0（第一个printf中的字符串）、puts函数、exit函数、.L1（第二个printf中的字符串）、printf函数、sleepsecs、sleep函数、getchar函数进行重定位声明。 Offset需要修改的引用的节偏移Info包括symbol和type两部分，其中symbol占前4个字节，type占后4个字节，symbol代表重定位到的目标在.symtab中的偏移量，type代表重定位的类型Type重定位到的目标的类型Sys.value重定向到的目标的名称Sys.Name+addend计算重定位位置的辅助信息，共占8个字节 符号表 .symtab是一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。 Symboltable‘.symtab’contains18entries: Num:ValueSizeTypeBindVisNdxName 0:00000000000000000NOTYPELOCALDEFAULTUND 1:00000000000000000FILELOCALDEFAULTABShello.c 2:00000000000000000SECTIONLOCALDEFAULT1 3:00000000000000000SECTIONLOCALDEFAULT3 4:00000000000000000SECTIONLOCALDEFAULT4 5:00000000000000000SECTIONLOCALDEFAULT5 6:00000000000000000SECTIONLOCALDEFAULT7 7:00000000000000000SECTIONLOCALDEFAULT8 8:00000000000000000SECTIONLOCALDEFAULT9 9:00000000000000000SECTIONLOCALDEFAULT6 10:00000000000000004OBJECTGLOBALDEFAULT3sleepsecs 11:0000000000000000133FUNCGLOBALDEFAULT1main 12:00000000000000000NOTYPEGLOBALDEFAULTUND\_GLOBAL\_OFFSET\_TABLE\_ 13:00000000000000000NOTYPEGLOBALDEFAULTUNDputs 14:00000000000000000NOTYPEGLOBALDEFAULTUNDexit 15:00000000000000000NOTYPEGLOBALDEFAULTUNDprintf 16:00000000000000000NOTYPEGLOBALDEFAULTUNDsleep 17:00000000000000000NOTYPEGLOBALDEFAULTUNDgetchar Hello.o的结果解析 执行objdump-d-rhello.o>disassemble_hello.s，得到hello.o的反汇编如下： hello.o:fileformatelf64-x86-64 Disassemblyofsection.text: 0000000000000000<main>: 0:f30f1efaendbr64 4:55push%rbp 5:4889e5mov%rsp,%rbp 8:4883ec20sub$0x20,%rsp c:897decmov%edi,-0x14(%rbp) f:488975e0mov%rsi,-0x20(%rbp) 13:837dec03cmpl$0x3,-0x14(%rbp) 17:7416je2f<main+0x2f> 19:488d3d00000000lea0x0(%rip),%rdi#20<main+0x20> 1c:R\_X86\_64\_PC32.rodata-0x4 20:e800000000callq25<main+0x25> 21:R\_X86\_64\_PLT32puts-0x4 25:bf01000000mov$0x1,%edi 2a:e800000000callq2f<main+0x2f> 2b:R\_X86\_64\_PLT32exit-0x4 2f:c745fc00000000movl$0x0,-0x4(%rbp) 36:eb3bjmp73<main+0x73> 38:488b45e0mov-0x20(%rbp),%rax 3c:4883c010add$0x10,%rax 40:488b10mov(%rax),%rdx 43:488b45e0mov-0x20(%rbp),%rax 47:4883c008add$0x8,%rax 4b:488b00mov(%rax),%rax 4e:4889c6mov%rax,%rsi 51:488d3d00000000lea0x0(%rip),%rdi#58<main+0x58> 54:R\_X86\_64\_PC32.rodata+0x1a 58:b800000000mov$0x0,%eax 5d:e800000000callq62<main+0x62> 5e:R\_X86\_64\_PLT32printf-0x4 62:8b0500000000mov0x0(%rip),%eax#68<main+0x68> 64:R\_X86\_64\_PC32sleepsecs-0x4 68:89c7mov%eax,%edi 6a:e800000000callq6f<main+0x6f> 6b:R\_X86\_64\_PLT32sleep-0x4 6f:8345fc01addl$0x1,-0x4(%rbp) 73:837dfc09cmpl$0x9,-0x4(%rbp) 77:7ebfjle38<main+0x38> 79:e800000000callq7e<main+0x7e> 7a:R\_X86\_64\_PLT32getchar-0x4 7e:b800000000mov$0x0,%eax 83:c9leaveq 84:c3retq 与第三章的hello.s对照主要差别如下： 分支转移函数 反汇编结果hello.s17:7416je2f<main+0x2f>je.L2 反汇编代码中可以看出相对偏移地址取代了hello.s中的标志位。反汇编代码跳转指令的操作数使用的不是段名称如.L2，因为段名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后显然不存在，而是确定的地址。 函数调用 反汇编结果hello.s 6a:e800000000callq6f&lt;main+0x6f&gt;callsleep@PLT 6b:R\_X86\_64\_PLT32sleep-0x4 在hello.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。 这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0（目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。 全局变量访问 反汇编结果 62:8b0500000000mov0x0(%rip),%eax\#68&lt;main+0x68&gt; 64:R\_X86\_64\_PC32sleepsecs-0x4 hello.s movq-32(%rbp),%rax addq\$8,%rax 在hello.s文件中对于全局变量的访问为LC0和sleepsecs（%rip）,而在反汇编代码中是$0x0和0（%rip），原因与函数调用一样，全局变量的地址也是在运行时才确定，访问也需要经过重定位。 进制表示 反汇编结果hello.s 43:488b45e0mov-0x20(%rbp),%raxmovq-32(%rbp),%rax 47:4883c008add\$0x8,%raxaddq\$8,%rax 反汇编后用16进制，hello.s用的是十进制。 本章小结 经过汇编过程后，hello.s被汇编器变为hello.o文件,此时hello.o已经是可以被机器读懂的二进制文件了。hello.o可重定位目标文件也为后面进行链接做好了准备。但是此时的hello仍然不能“上岗工作”，还需要进行最后一步链接才能变为可以被系统执行的可执行文件。 通过反汇编hello.o并与之前的hello.s进行比较，我进一步了解了汇编代码和机器代码之间的区别和联系。 （第4章1分） 链接 链接的概念与作用 链接的概念 链接是将各种不同文件的代码和数据部分收集（符号解析和重定位）起来并组合成一个单一文件的过程。 链接的作用 令源程序节省空间而未编入的常用函数文件（如printf.o）进行合并，生成可以正常工作的可执行文件。这令分离编译成为可能，节省了大量的工作空间。 在Ubuntu下链接的命令 执行命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 得到hello的可执行目标文件 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3eyx8Dwz-1623927515236)(media/image7.png)]{width=“5.901388888888889in”height=“1.6284722222222223in”} 图6链接得到hello的可执行文件 可执行目标文件hello的格式 使用命令:**readelf-ahello>helloELF.elf** ELFheader ELFHeader: Magic:7f454c46020101000000000000000000 Class:ELF64 Data:2’scomplement,littleendian Version:1(current) OS/ABI:UNIX-SystemV ABIVersion:0 Type:EXEC(Executablefile) Machine:AdvancedMicroDevicesX86-64 Version:0x1 Entrypointaddress:0x4010d0 Startofprogramheaders:64(bytesintofile) Startofsectionheaders:14200(bytesintofile) Flags:0x0 Sizeofthisheader:64(bytes) Sizeofprogramheaders:56(bytes) Numberofprogramheaders:12 Sizeofsectionheaders:64(bytes) Numberofsectionheaders:27 Sectionheaderstringtableindex:26 SectionHeader SectionHeader中包含了各节的名称，类型，地址，偏移量等信息。 可以看出此时节的数目由hello.o的14个增加到了27个，说明在链接过后有很多文件有添加进来。 Address：该节的虚拟地址（绝对地址） Offset：该节在程序中地址的偏移量（相对地址） SectionHeaders: [Nr]NameTypeAddressOffset SizeEntSizeFlagsLinkInfoAlign [0]NULL000000000000000000000000 00000000000000000000000000000000000 [1].interpPROGBITS00000000004002e0000002e0 000000000000001c0000000000000000A001 [2].note.gnu.propertNOTE000000000040030000000300 00000000000000200000000000000000A008 [3].note.ABI-tagNOTE000000000040032000000320 00000000000000200000000000000000A004 [4].hashHASH000000000040034000000340 00000000000000340000000000000004A608 [5].gnu.hashGNU_HASH000000000040037800000378 000000000000001c0000000000000000A608 [6].dynsymDYNSYM000000000040039800000398 00000000000000c00000000000000018A718 [7].dynstrSTRTAB000000000040045800000458 00000000000000570000000000000000A001 [8].gnu.versionVERSYM00000000004004b0000004b0 00000000000000100000000000000002A602 [9].gnu.version_rVERNEED00000000004004c0000004c0 00000000000000200000000000000000A718 [10].rela.dynRELA00000000004004e0000004e0 00000000000000300000000000000018A608 [11].rela.pltRELA000000000040051000000510 00000000000000780000000000000018AI6218 [12].initPROGBITS000000000040100000001000 000000000000001b0000000000000000AX004 [13].pltPROGBITS000000000040102000001020 00000000000000600000000000000010AX0016 [14].plt.secPROGBITS000000000040108000001080 00000000000000500000000000000010AX0016 [15].textPROGBITS00000000004010d0000010d0 00000000000001350000000000000000AX0016 [16].finiPROGBITS000000000040120800001208 000000000000000d0000000000000000AX004 [17].rodataPROGBITS000000000040200000002000 000000000000002f0000000000000000A004 [18].eh_framePROGBITS000000000040203000002030 00000000000000fc0000000000000000A008 [19].dynamicDYNAMIC0000000000403e5000002e50 00000000000001a00000000000000010WA708 [20].gotPROGBITS0000000000403ff000002ff0 00000000000000100000000000000008WA008 [21].got.pltPROGBITS000000000040400000003000 00000000000000400000000000000008WA008 [22].dataPROGBITS000000000040404000003040 00000000000000080000000000000000WA004 [23].commentPROGBITS000000000000000000003048 000000000000002a0000000000000001MS001 [24].symtabSYMTAB000000000000000000003078 00000000000004c8000000000000001825308 [25].strtabSTRTAB000000000000000000003540 00000000000001500000000000000000001 [26].shstrtabSTRTAB000000000000000000003690 00000000000000e10000000000000000001 KeytoFlags: W(write),A(alloc),X(execute),M(merge),S(strings),I(info), L(linkorder),O(extraOSprocessingrequired),G(group),T(TLS), C(compressed),x(unknown),o(OSspecific),E(exclude), l(large),p(processorspecific) hello的虚拟地址空间 使用edb加载hello，DataDump窗口可以查看加载到虚拟地址中的hello程序。 可以看出在0x400000~0x401000段中，程序被载入。这之间每个节的排列顺序与SectionHeaders中声明的顺序相同。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oZRd4VkE-1623927515237)(media/image8.png)]{width=“4.916666666666667in”height=“1.992361111111111in”} 图7edb中节的内容 ProgramHeaders ProgramHeaders: TypeOffsetVirtAddrPhysAddr FileSizMemSizFlagsAlign PHDR0x00000000000000400x00000000004000400x0000000000400040 0x00000000000002a00x00000000000002a0R0x8 INTERP0x00000000000002e00x00000000004002e00x00000000004002e0 0x000000000000001c0x000000000000001cR0x1 \[Requestingprograminterpreter:/lib64/ld-linux-x86-64.so.2\] LOAD0x00000000000000000x00000000004000000x0000000000400000 0x00000000000005880x0000000000000588R0x1000 LOAD0x00000000000010000x00000000004010000x0000000000401000 0x00000000000002150x0000000000000215RE0x1000 LOAD0x00000000000020000x00000000004020000x0000000000402000 0x000000000000012c0x000000000000012cR0x1000 LOAD0x0000000000002e500x0000000000403e500x0000000000403e50 0x00000000000001f80x00000000000001f8RW0x1000 DYNAMIC0x0000000000002e500x0000000000403e500x0000000000403e50 0x00000000000001a00x00000000000001a0RW0x8 NOTE0x00000000000003000x00000000004003000x0000000000400300 0x00000000000000200x0000000000000020R0x8 NOTE0x00000000000003200x00000000004003200x0000000000400320 0x00000000000000200x0000000000000020R0x4 GNU_PROPERTY0x00000000000003000x00000000004003000x0000000000400300 0x00000000000000200x0000000000000020R0x8 GNU_STACK0x00000000000000000x00000000000000000x0000000000000000 0x00000000000000000x0000000000000000RW0x10 GNU_RELRO0x0000000000002e500x0000000000403e500x0000000000403e50 0x00000000000001b00x00000000000001b0R0x1 参数说明： PHDR：保存程序头表 INTERP：动态链接器的路径 LOAD：可加载的程序段 DYNAMIN：保存了由动态链接器使用的信息 NOTE保存辅助信息 GNU_STACK：标志栈是否可执行 GNU_RELRO：指定重定位后需被设置成只读的内存区域 链接的重定位过程分析 使用objdump-d-rhello获得hello的反汇编代码。 hello相对hello.o的内容变化 与hello.o反汇编文本相比，在hello的反汇编文件中内容发生了变化。 链接中新增了.plt.sec节，其中是一些函数如：puts、printf、getchar等 Disassemblyofsection.plt.sec: 0000000000401080<puts@plt>: 401080:f30f1efaendbr64 401084:f2ff258d2f0000bndjmpq*0x2f8d(%rip)#404018<puts@GLIBC_2.2.5> 40108b:0f1f440000nopl0x0(%rax,%rax,1) 0000000000401090<printf@plt>: 401090:f30f1efaendbr64 401094:f2ff25852f0000bndjmpq*0x2f85(%rip)#404020<printf@GLIBC_2.2.5> 40109b:0f1f440000nopl0x0(%rax,%rax,1) 00000000004010a0<getchar@plt>: 4010a0:f30f1efaendbr64 4010a4:f2ff257d2f0000bndjmpq*0x2f7d(%rip)#404028<getchar@GLIBC_2.2.5> 4010ab:0f1f440000nopl0x0(%rax,%rax,1) 00000000004010b0<exit@plt>: 4010b0:f30f1efaendbr64 4010b4:f2ff25752f0000bndjmpq*0x2f75(%rip)#404030<exit@GLIBC_2.2.5> 4010bb:0f1f440000nopl0x0(%rax,%rax,1) 00000000004010c0<sleep@plt>: 4010c0:f30f1efaendbr64 4010c4:f2ff256d2f0000bndjmpq*0x2f6d(%rip)#404038<sleep@GLIBC_2.2.5> 4010cb:0f1f440000nopl0x0(%rax,%rax,1) 链接中新增.init节和.plt节和.plt.sec节和.fini节 Disassemblyofsection.init: … Disassemblyofsection.plt: … Disassemblyofsection.plt.sec: … Disassemblyofsection.text: … Disassemblyofsection.fini: … 寻址方式变化 hello.o中相对寻址： 19:488d3d00000000lea0x0(%rip),%rdi#20<main+0x20> hello中直接寻址 40111e:488d3ddf0e0000lea0xedf(%rip),%rdi#402004<_IO_stdin_used+0x4> 这是因为hello.o文件中对于某些地址定位暂时不明确，其地址也是在运行时确定的，因此访问需要重新定位。 函数调用方式变化 hello.o调用函数相对地址全设置为0 2a:e800000000callq2f<main+0x2f> 2b:R\_X86\_64\_PLT32exit-0x4 hello调用函数有具体地址 40112f:e87cffffffcallq4010b0<exit@plt> hello无需重定位所以没有hello.o中的重定位条目，跳转地址和函数调用地址在hello中都变成了虚拟内存地址。链接器将hello.o中的偏移量加上程序在虚拟内存中的起始地址0x0040000和.text节中的偏移量就得到了反汇编代码hello中的地址。 下面简要分析一下callqexit的重定位PC相对引用： 在ELF文件中能够找到exit对应的重定位条目如下 OffsetInfoTypeSym.ValueSym.Name+Addend 00000000001c000500000002R_X86_64_PC320000000000000000.rodata-4 000000000021000d00000004R_X86_64_PLT320000000000000000puts-4 00000000002b000e00000004R_X86_64_PLT320000000000000000exit-4 可得： r.offset=0x2b r.addend=0x-4 <exit>的首地址(Addr(s)) 00000000004010b0<exit@plt>: <main>的首地址(Addr(r.symbol)) 0000000000401105<main>: 由相对地址重定位计算公式 refaddr=Addr(s)+r.offset=0x4010b0+0x2b *refptr=(unsigned)(ADDR(r.symbol)+r.addend-refaddr) =(unsigned)[0x4010b0-0x4-(0x4010b0+0x2b)] =(unsigned)[0x-84] =0xffffff7c 由于是小端序存储，所以callq的机器码为e87cffffff 链接的过程 链接的方式有静态和动态两种。最基本的链接叫做静态链接，就是将每个模块的源代码文件编译成目标文件（Linux：.oWindows：.obj），然后将目标文件和库一起链接形成最后的可执行文件。 链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。链接的过程如下： 地址和空间的分配符号决议（用符号来标识一个地址）重定向 hello的执行流程 用gdb调试记录下执行过程中call命令进入的函数 程序名称>程序地址ld-2.27.so!_dl_start>0x7fce8cc38ea0ld-2.27.so!_dl_init>0x7fce8cc47630hello!_start>0x400500libc-2.27.so!libc_start_main>0x7fce8c867ab0-libc-2.27.so!cxa_atexit>0x7fce8c889430-libc-2.27.so!libc_csu_init>0x4005c0hello!_init>0x400488libc-2.27.so!_setjmp>0x7fce8c884c10-libc-2.27.so!_sigsetjmp>0x7fce8c884b70–libc-2.27.so!sigjmp_save>0x7fce8c884bd0hello!main>0x400532hello!puts@plt>0x4004b0hello!exit@plt>0x4004e0*hello!printf@plt>–*hello!sleep@plt>–*hello!getchar@plt>–ld-2.27.so!_dl_runtime_resolve_xsave>0x7fce8cc4e680-ld-2.27.so!_dl_fixup>0x7fce8cc46df0–ld-2.27.so!_dl_lookup_symbol_x>0x7fce8cc420b0libc-2.27.so!exit>0x7fce8c889128 Hello的动态链接分析 在进行动态链接前，首先进行静态链接，生成部分链接的可执行目标文件hello。此时共享库中的代码和数据没有被合并到hello中。加载hello时，动态链接器对共享目标文件中的相应模块内的代码和数据进行重定位，加载共享库，生成完全链接的可执行目标文件。 动态链接采用了延迟加载的策略，即在调用函数时才进行符号的映射。使用偏移量表GOT+过程链接表PLT实现函数的动态链接。GOT中存放函数目标地址，为每个全局函数创建一个副本函数，并将对函数的调用转换成对副本 在elf文件中可以找到： [20].gotPROGBITS0000000000403ff000002ff0 00000000000000100000000000000008WA008 [21].got.pltPROGBITS000000000040400000003000 00000000000000400000000000000008WA008 进入edb查看： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XsucLq1u-1623927515238)(media/image9.png)]{width=“5.492361111111111in”height=“1.2951388888888888in”} 图8edb执行init前的地址 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mTfL3gvV-1623927515239)(media/image10.png)]{width=“5.477083333333334in”height=“1.2652777777777777in”} 图9edb执行init后的地址 对于变量而言，我们利用代码段和数据段的相对位置不变的原则计算正确地址。对于库函数而言，需要plt、got合作，plt初始存的是一批代码，它们跳转到got所指示的位置，然后调用链接器。初始时got里面存的都是plt的第二条指令，随后链接器修改got，下一次再调用plt时，指向的就是正确的内存地址。plt就能跳转到正确的区域。 本章小结 在本章中主要介绍了链接的概念与作用、hello的ELF格式，分析了hello的 虚拟地址空间、重定位过程、执行流程、动态链接过程。 （第5章1分） hello进程管理 进程的概念与作用 进程的概念： 进程是执行中程序的抽象。 进程的作用： 每次运行程序时，shell创建一新进程，在这个进程的上下文切换中运行这个可执行目标文件。应用程序也能够创建新进程，并且在新进程的上下文中运行它们自己的代码或其他应用程序。进程提供给应用程序的关键抽象：一个独立的逻辑控制流，如同程序独占处理器；一个私有的地址空间，如同程序独占内存系统。 简述壳Shell-bash的作用与处理流程 Shell-bash的作用 Shell是一个用C语言编写的程序，是用户使用Linux的桥梁，它提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Shell-bash的处理流程 1）从终端读入输入的命令。 2）将输入字符串切分获得所有的参数 3）如果是内置命令则立即执行，否则调用相应的程序为其分配子进程并运行 shell应该接受键盘输入信号，并对这些信号进行相应处理。 Hello的fork进程创建过程 在终端输入./hello1190301804liangcheng运行的终端程序会对输入的命令行进行解析，因为hello不是一个内置的shell命令所以解析之后终端程序判断./hello的语义为执行当前目录下的可执行目标文件hello，之后终端程序首先会调用fork函数创建一个新的运行的子进程，新创建的子进程几乎但不完全与父进程相同：子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。 父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。 Hello的execve过程 exceve函数在当前进程的上下文中加载并运行一个新程序，execve函数加载并运行可执行目标文件hello，执行一次，并且从不返回。删除子进程现有的虚拟内存段，新的栈和堆段被初始化为零，新的代码和数据段被初始化为可执行文件中的内容。 Hello的进程执行 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这个决策就叫做调度，是由内核中称为调度器的代码处理的。 在内核调度了一个新的进程运行后，它就抢占当前进程，并使用上文所述的上下文切换的机制将控制转移到新的进程。内核代表的用户执行系统调用时，可能会发生上下文切换；中断也有可能引发上下文切换。 通过内核模式用户模式的切换描述用户态核心态转换的过程，在切换的第一部分中，内核代表进程A在内核模式下执行指令。然后在某一时刻，它开始代表进程B(仍然是内核模式下)执行指令。在切换之后，内核代表进程B在用户模式下执行指令。随后，进程B在用户模式下运行一会儿，直到磁盘发出一个中断信号，表示数据已经从磁盘传送到了内存。内核判定进程B已经运行了足够长的时间，就执行一个从进程B到进程A的上下文切换，将控制返回给进程A中紧随在系统调用read之后的那条指令。进程A继续运行，直到下一次异常发生，依此类推。 hello的异常与信号处理 异常类型： 类别原因异步/同步返回行为中断来自I/O设备的信号异步总是返回到下一条指令陷阱有意的异常同步总是返回到下一条指令故障潜在可恢复的错误同步可能返回到当前指令终止不可恢复的错误同步不会返回 处理方法： 中断 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4Sy6ukDC-1623927515239)(media/image11.png)]{width=“3.6215277777777777in”height=“1.1819444444444445in”} 图10中断的处理 陷阱 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lZpLx6U5-1623927515240)(media/image12.png)]{width=“3.6819444444444445in”height=“1.2270833333333333in”} 图11陷阱的处理 故障 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hrYlt9kO-1623927515241)(media/image13.png)]{width=“3.848611111111111in”height=“1.1895833333333334in”} 图12故障的处理 终止 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-emmalDtt-1623927515241)(media/image14.png)]{width=“3.598611111111111in”height=“1.257638888888889in”} 图13终止的处理 执行过程中按键盘： 正常执行。如下图所示，为hello程序正常运行的结果，接着输入命令ps后执行，程序后台并没有hello进程正在执行了，说明进程正常结束，已经被回收了。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xK7TKElI-1623927515242)(media/image15.png)]{width=“5.90625in”height=“2.1659722222222224in”} 图14正常执行 不停乱按：结果是程序运行情况和前面的相同，不同之处在于shell将我们刚刚乱输入的字符除了第一个回车按下之前的字符当做getchar的输入之外，其余都当做新的shell命令，在hello进程结束被回收之后，将会在命令行中尝试解释这些命令。中间没有任何对于进程产生影响的信号被产生。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fmei8dhM-1623927515242)(media/image16.png)]{width=“5.901388888888889in”height=“4.007638888888889in”} 图15键盘乱按 ctrl+c 在hello程序运行时输入CTRL+C会导致内核发送一个SIGINT信号到前台进程组的每个进程。默认情况下，结果是终止前台作业。 用ps和jobs观察，发现进程已经被终止。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3CkUDTuQ-1623927515243)(media/image17.png)]{width=“5.901388888888889in”height=“1.0152777777777777in”} 图16ctrl+c ctrl+z 将会发送一个SIGTSTP信号给shell。然后shell将转发给当前执行的前台进程组，使hello进程挂起。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KXLOj8kD-1623927515243)(media/image18.png)]{width=“5.90625in”height=“0.5527777777777778in”} 图17ctrl+z 我们输入ps命令，hello进程仍然存在 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XRkAvPrp-1623927515244)(media/image19.png)]{width=“5.552777777777778in”height=“0.8104166666666667in”} 图18ctrl+z用ps观察 输入jobs命令：hello已经停止，进程号为1 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ku241pOu-1623927515244)(media/image20.png)]{width=“5.333333333333333in”height=“0.3861111111111111in”} 图19ctrl+z用jobs观察 使用fg1（1是进程号）命令将其调回前台，继续执行： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pBpkJHre-1623927515245)(media/image21.png)]{width=“5.409027777777778in”height=“1.6972222222222222in”} 图20ctrl+z后用fg调回 kill命令：kill后无法用ps看到进程号，jobs也为空。进程已经被杀死。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EvMcYhyr-1623927515245)(media/image22.png)]{width=“5.90625in”height=“0.9083333333333333in”} 图21kill指令 本章小结 本章了解了hello进程的执行过程。主要讲hello的创建、加载和终止，通过键盘输入。程序是指令、数据及其组织形式的描述，进程是程序的实体。可以说，进程是运行的程序。在hello运行过程中，内核有选择对其进行管理，决定何时进行上下文切换。也同样是在hello的运行过程中，当接受到不同的异常信号时，异常处理程序将对异常信号做出相应，执行相应的代码，每种信号都有不同的处理机制，对不同的异常信号，hello也有不同的处理结果。 （第6章1分） hello的存储管理 hello的存储器地址空间 逻辑地址 逻辑地址（LogicalAddress）是指由程序hello产生的与段相关的偏移地址部分（hello.o）。 线性地址 线性地址（LinearAddress）是逻辑地址到物理地址变换之间的中间层。程序hello的代码会产生逻辑地址，或者说是（即hello程序）段中的偏移地址，它加上相应段的基地址就生成了一个线性地址。 虚拟地址 有时我们也把逻辑地址称为虚拟地址。因为与虚拟内存空间的概念类似，逻辑地址也是与实际物理内存容量无关的，是hello中的虚拟地址。 物理地址 物理地址（PhysicalAddress）是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么hello的线性地址会使用页目录和页表中的项变换成hello的物理地址；如果没有启用分页机制，那么hello的线性地址就直接成为物理地址了。 Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部份组成，段标识符、段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如下图： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ygFgYtKM-1623927515245)(media/image23.png)] 图22段选择符 索引号，是“段描述符(segmentdescriptor)”，段描述符具体地址描述了一个段。这样，很多个段描述符，就组了一个数组，叫“段描述符表”，这样，可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符，这个描述符就描述了一个段，由8个字节组成，如下图 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lms1Zy40-1623927515246)(media/image24.png)] 图23段描述符 Base字段：它描述了一个段的开始位置的线性地址。Intel设计的本意是，一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。 当段选择符中的T1字段=0，表示用GDT；若为1，表示用LDT。GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。再看图7-3比起来要直观些： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nEFQLTnV-1623927515246)(media/image25.png)] 图24逻辑地址转线性地址 首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]， 1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。 2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，Base（基地址）就知道了。 3、把Base+offset，就是要转换的线性地址了。 Hello的线性地址到物理地址的变换-页式管理 页式管理是一种内存空间存储管理的技术，页式管理分为静态页式管理和动态页式管理。将各进程的虚拟空间划分成若干个长度相等的页(page)，页式管理把内存空间按页的大小划分成片或者页面（pageframe），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。 Linux将虚拟内存组织成一些段的集合，段之外的虚拟内存不存在因此不需要记录。内核为hello进程维护一个段的任务结构即图中的task_struct，其中条目mm指向一个mm_struct，它描述了虚拟内存的当前状态，pgd指向第一级页表的基地址（结合一个进程一串页表），mmap指向一个vm_area_struct的链表，一个链表条目对应一个段，所以链表相连指出了hello进程虚拟内存中的所有段。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-d3iltck0-1623927515247)(media/image26.png)]{width=“4.280555555555556in”height=“2.6284722222222223in”} 图25段集合示意图 而物理内存被划分为一小块一小块，每块被称为帧(Frame)。分配内存时，帧是分配时的最小单位，最少也要给一帧。 在虚拟内存中，与帧对应的概念就是页(Page)。虚拟地址的表示如下，由虚拟页号VPN与虚拟页偏移量VPO组成。 MMU利用虚拟页号（VPN）来在虚拟页表中选择合适的PTE，当找到合适的PTE之后，PTE中的物理页号（PPN）和虚拟页偏移量（VPO）就会组合形成物理地址。其中VPO与PPO相同，因为虚拟页大小和物理页大小相同，所需要的偏移量位数也就相同。此时，物理地址就通过物理页号先找到对应的物理页，然后再根据物理页偏移找到具体的字节： 1.如果有效位是0+NULL则代表没有在虚拟内存空间中分配该内存； 2.如果是有效位0+非NULL，则代表在虚拟内存空间中分配了但是没有被缓存到物理内存中； 3.如果有效位是1则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，与虚拟页偏移量共同构成物理地址PA。 如下图所示， [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kgDd1sEf-1623927515248)(media/image27.png)]{width=“3.265277777777778in”height=“1.6895833333333334in”} 图26页式管理示意图 页式管理优缺点分析： 优点： 1、由于它不要求作业或进程的程序段和数据在内存中连续存放，从而有效地解决了碎片问题。 2、动态页式管理提供了内存和外存统一管理的虚存实现方式，使用户可以利用的存储空间大大增加。这既提高了主存的利用率，又有利于组织多道程序执行。 缺点： 1、要求有相应的硬件支持。例如地址变换机构，缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。这增加了机器成本。 2、增加了系统开销，例如缺页中断处理机， 3、请求调页的算法如选择不当，有可能产生抖动现象。 4、虽然消除了碎片，但每个作业或进程的最后一页内总有一部分空间得不到利用果页面较大，则这一部分的损失仍然较大。 TLB与四级页表支持下的VA到PA的变换 VA由VPN和VPO组成。PA由PPN与PPO组成。 VPN可以作为在TLB中的索引，如下图所示，TLB可以看作是一个PTE的cache，将常用的PTE缓存到TLB中，加速虚拟地址的翻译。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-o2V1iSP9-1623927515248)(media/image28.png)]{width=“3.9923611111111112in”height=“2.848611111111111in”} 图27core-i7地址翻译情况 如果能够在TLB中找到与VPN对应的PTE，即为TLB命中，TLB直接给出PPN，然后PPO即为VPO，这样就得到了物理地址PA。如果TLB没有命中，那么就需要到四级页表中寻址： 将虚拟地址的VPN划分为相等大小的四部分，每个部分用于寻找由上一级确定的页表基址对应的页表条目。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-N7ZWECIe-1623927515249)(media/image29.png)]{width=“3.901388888888889in”height=“2.3784722222222223in”} 图28core-i7页表翻译 然后解析VA，利用前m位vpn1寻找一级页表位置，接着一次重复4次，在第4级页表获得了页表条目，将PPN与VPO组合获得PA。 三级Cache支持下的物理内存访问 MMU获得PA后，根据cache大小将PA分为(CT，CI，CO)三部分。 然后根据CI（倒数7-12位）进行组索引，每组8路。对8路的块分别匹配CT（前40位）。 如果匹配成功且块内valid位为1，则命中。命中后根据CO（后六位）取出数据并返回。如果不命中，则需要向下一级缓存中查询数据(L2cache–>L3cache–>内存),查询到数据后，用相应的放置策略更新各级cache。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yPJz7rYO-1623927515249)(media/image30.png)]{width=“3.8027777777777776in”height=“2.6215277777777777in”} 图29三级cache下物理内存访问 hello进程fork时的内存映射 理解了虚拟内存和内存映射，那么我们就可以清晰地知道fork函数是如何创建一个带有自己独立虚拟地址空间的新进程的。 当fork函数被shell调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了hello进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 hello进程execve时的内存映射 在bash中的进程中执行了如下的execve调用：execve(“hello”,NULL,NULL)； execve函数在当前进程中加载并运行包含在可执行文件hello中的程序，用hello替代了当前bash中的程序。 下面是加载并运行hello的几个步骤： 删除已存在的用户区域。映射私有区域映射共享区域设置程序计数器（PC）exceve做的最后一件事是设置当前进程的上下文中的程序计数器，是指指向代码区域的入口点。而下一次调度这个进程时，他将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KHe5ZOBT-1623927515250)(media/image31.png)]{width=“3.2729166666666667in”height=“2.454861111111111in”} 图30加载器映射用户地址区域 缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。页面命中完全是由硬件完成的，而处理缺页是由硬件和操作系统内核协作完成的。 假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤: 先确认是不是一个合法的地址：即通过不断将这个地址与每个区域的vm_start&vm_end进行比对，如果并不是在一个区域里的话，就给出segmentationfault，因为它引用了一个不合法的地址确认访问权限是不是正确的：即如果这一页是只读页，但是却要做出写这个动作，那明显是不行的。如果做出了这类动作，那么处理程序就会触发一个保护异常，默认行为是结束这个进程当确认了是合法地址并且是符合权限的访问，那么就用某个特定算法选出一个牺牲页，如果该页被修改了，就将此页滑出（swapout）并且swapin那个被访问的页，并将控制传递到触发缺页中断的那条指令，这条指令继续执行的时候就不会触发缺页中断，这样就可以继续执行下去。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n4xHoz8S-1623927515251)(media/image32.png)]{width=“4.038194444444445in”height=“2.401388888888889in”} 图31linus缺页处理 动态存储分配管理 动态储存分配管理使用动态内存分配器来进行。动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配的状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 动态内存分配主要有两种基本方法与策略： 带边界标签的隐式空闲链表分配器管理 带边界标记的隐式空闲链表的每个块是由一个字的头部、有效载荷、可能的额外填充以及一个字的尾部组成的。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-JCJUY07h-1623927515252)(media/image33.png)]{width=“4.424305555555556in”height=“1.9618055555555556in”} 图32隐式空间链表的堆块示意图 隐式空闲链表：在隐式空闲链表中，因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。其中，一个设置了已分配的位而大小为零的终止头部将作为特殊标记的结束块。 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大的可以放置所请求块的空闲块。分配器有三种放置策略：首次适配、下一次适配合最佳适配。分配完后可以分割空闲块减少内部碎片。同时分配器在面对释放一个已分配块时，可以合并空闲块，其中便利用隐式空闲链表的边界标记来进行合并。 显式空间链表管理 显式空闲链表是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。如，堆可以组织成一个双向链表，在每个空闲块中，都包含一个前驱与一个后继指针。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VBhOSSko-1623927515253)(media/image34.png)]{width=“4.727083333333334in”height=“2.3784722222222223in”} 图33显式空闲表的堆块示意图 显式空闲链表：在显式空闲链表中。可以采用后进先出的顺序维护链表，将最新释放的块放置在链表的开始处，也可以采用按照地址顺序来维护链表，其中链表中每个块的地址都小于它的后继地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。 本章小结 本章主要介绍了hello的存储器地址空间、intel的段式管理、hello的页式管理，在指定环境下介绍了VA到PA的变换、物理内存访问，还介绍hello进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 （第7章2分） hello的IO管理 Linux的IO设备管理方法 设备的模型化：所有的IO设备都被模型化为文件，而所有的输入输出都被当作对相应文件的读和写来执行。设备管理：将设备优雅地映射为文件的方式,允许Linux内核引出一个简单、低级的应用接口,称为UnixI/O,这使得所有的输入和输出都能以一种统一且一致的方式来执行,这就是UnixI/O接口。 简述UnixIO接口及其函数 UnixI/O接口统一操作： 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。 UnixI/O函数： open（）函数 功能描述：用于打开或创建文件，在打开或创建文件时可以指定文件的属性及用户的权限等各种参数。 函数原型:intopen(constchar*pathname,intflags,intperms) 参数：pathname:被打开的文件名（可包括路径名如"dev/ttyS0"）flags:文件打开方式, 返回值：成功就返回文件描述符；失败就返回-1 close（）函数 功能描述：用于关闭一个被打开的的文件 所需头文件：#include<unistd.h> 函数原型:intclose(intfd) 参数：fd文件描述符 函数返回值：0成功，-1出错 read（）函数 功能描述：从文件读取数据。 所需头文件：#include<unistd.h> 函数原型：ssize_tread(intfd,void*buf,size_tcount); 参数：fd：将要读取数据的文件描述词。buf：指缓冲区，即读取的数据会被放到这个缓冲区中去。count：表示调用一次read操作，应该读多少数量的字符。 返回值：返回所读取的字节数；0（读到EOF）；-1（出错）。 write（）函数 功能描述：向文件写入数据。 所需头文件：#include<unistd.h> 函数原型：ssize_twrite(intfd,void*buf,size_tcount); 返回值：写入文件的字节数（成功）；-1（出错） lseek（）函数 功能描述：用于在指定的文件描述符中将将文件指针定位到相应位置。 所需头文件：#include<unistd.h>，#include<sys/types.h> 函数原型：off_tlseek(intfd,off_toffset,intwhence); 参数：fd;文件描述符。offset:偏移量，每一个读写操作所需要移动的距离，单位是字节，可正可负（向前移，向后移） 返回值：成功：返回当前位移；失败：返回-1 printf的实现分析 printf函数体： intprintf(constchar*fmt,…) { inti; charbuf[256]; va\_listarg=(va\_list)((char\*)(&fmt)+4); i=**vsprintf**(buf,fmt,arg); **write**(buf,i); returni; } 下面分析一下printf函数内容： va_listarg=(va_list)((char*)(&fmt)+4); 将所有的参数内容格式化之后存入buf，然后返回格式化数组的长度i。 vsprintf函数 intvsprintf(char*buf,constchar*fmt,va_listargs) { char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!=‘%’){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case‘x’: itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case‘s’: break; default: break; } } return(p-buf); } vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 write(buf,i); 用write函数将buf中的i个元素写到终端。 write函数 write: moveax,\_NR\_write movebx,\[esp+4\] movecx,\[esp+8\] intINT_VECTOR_SYS_CALL 在write函数中，ecx:字符个数，ebx:第一个字符的地址，最后调用syscall。 syscall 实现较为复杂。功能：不断打印出字符，直到遇到‘\0’停止。 printf实现流程如下： （1）：vsprintf格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 （2）：vsprintf的输出到write系统函数中。在Linux下，write通过执行syscall指令实现了对系统服务的调用，从而使内核执行打印操作。内核会通过字符显示子程序，根据传入的ASCII码到字模库读取字符对应的点阵，然后通过vram（显存）对字符串进行输出。 （3）：显示芯片将按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量），最终实现printf中字符串在屏幕上的输出。 getchar的实现分析 getchar有一个int型的返回值。当程序调用getchar时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中直到用户按回车为止(回车字符也放在缓冲区中)。 当用户键入回车之后，getchar才开始从stdio流中每次读入一个字符。getchar函数的返回值是用户输入的第一个字符的ascii码,如出错返回-1,且将用户输入的字符回显到屏幕。 如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取。也就是说,后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 本章小结 本章介绍了Linux的I/O设备的基本概念和管理方法，以及UnixI/O接口及其函数。最后分析了printf函数和getchar函数的工作过程。 （第8章1分） 结论 hello程序终于完成了它艰辛的一生，它的一生有这么几件大事： hello.c经过预编译，拓展得到hello.i文本文件hello.i经过编译，得到汇编代码hello.s汇编文件hello.s经过汇编，得到二进制可重定位目标文件hello.ohello.o经过链接，生成了可执行文件hellobash进程调用fork函数，生成子进程；hello由execve函数加载运行当前进程的上下文中加载并运行新程序hello通过解析得到物理地址PA。hello再运行时会调用一些函数，比如printf函数，这些函数与linuxI/O的设备模拟化密切相关。hello最终被shell父进程回收，内核会收回为其创建的所有信息 个人感悟：CSAPP不愧是本科期间收获最大的一门课，大作业也设计得如此精巧！它带我们领略的计算机内部的美丽风景，从浅入深地剖析讲解了计算机的方方面面，领我们从顶层到达了底层！体验完了hello一生，我也对计算机系统有了更深入的了解！ （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 文件的作用文件名*预处理后的文件hello.i*编译之后的汇编文件hello.s*汇编之后的可重定位目标文件hello.o*链接之后的可执行目标文件Hello*Hello.o的ELF格式elf.txt*Hello.o的反汇编代码disassemble_hello.s*hello的ELF格式helloELF.elfhello的反汇编代码disassemble_hello_o.s （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 RandalE.Bryant,DavidO’Hallaron,龚奕利,等.深入理解计算机系统[J].中国电力出版社,2004.刘兵,吴煜煌.Linux实用教程[J].中国水利水电出版社,2004.C.Linus操作基础[M/OL].CSDN,2018-05-27.李洛,黄达峰.Linux教程[M].清华大学出版社,2005.ELF构造：https://www.cs.stevens.edu/~jschauma/631/elf.html进程的睡眠、挂起和阻塞：https://www.zhihu.com/question/42962803printf函数剖析https://blog.csdn.net/zhengqijun_/article/details/72454714虚拟地址https://baike.baidu.com/item/虚拟地址/1329947?fr=aladdin （参考文献0分，缺失-1分） 
第506篇文章[6]
将python项目用docker部署到服务器上的全过程 任务描述 由于笔记本算力有限，要将python项目部署到服务器上。在查阅了大量资料后，踩了无数坑后，今天记录一下全过程，希望对大家有帮助。 配置要求 需要部署的python项目虚拟机/linusdocker安装服务器端口 大致流程 shareFile Docker pythonproject linus image.tar 服务器 1.Docker的打包 docker官网安装教程docker安装菜鸟教程 项目最终结构： docker_test├──Dockerfile├──pythonproject│││└──tset.py│││└──其他配置文件└──requirements.txt 生成requirements.txtcd进入到main.py目录或者直接在pycharm的Terminal下执行 pipenvlock--requirements>requirements.txt //或者 pipfreeze>>requirements.txt 得到requirement文件 dockFile的编写建议直接在linus下编写 #将官方Python运行时用作父镜像 FROMpython:3.8.2 #将工作目录设置为/pythonproject WORKDIR./pythonproject #将当前目录内容复制到位于/pythonproject中的容器中 ADD.. #安装requirements.txt中指定的任何所需软件包 RUNpipinstall-rrequirements.txt #在容器启动时运行tset.py CMD["python3","./pythonproject/tset.py"] 镜像的生成在linus下，cd到Dockerfile文件下 dockerbuild-tcowsay. 详细信息： dockerbuild-timagenameDockerfilepath #imagename：镜像名称，自定义 #Dockerfilepath：Dockerfile所在文件夹名称，当前名录为“.” 生成镜像 dockerbuild-timagenameDockerfilepath 运行镜像 dockerrun--rmcowsay --rm:跑完就删除（因为有时候container比较占空间） 在这里给大家总结一下一些docker命令dockerimagels列出镜像dockerps列出container（正在运行的）（可以加-a列出所有的）dockerrmcontainerID删除containerdockerrmiImageID删除imagedockerexec-itcontainerIDbash进入container IMAGE.tar的生成（Image打包） dockersavef660ca2347c0>image.tar //输出镜像文件到tar文件中 660ca2347c0是Image的ID号，可以通过dockerimagels查看 至此，我们已经得到IMAGE.tar了接下来，把它上传上服务器并运行 2.服务器部分 传输文件（非ssh） scpIMAGE.tarhostname@服务器地址:path scp命令详解 登录服务器 ssh账号@服务器地址 如何登录服务器 docker载入tar文件 dockerimageload<IMAGE.tar dockerrun！（快结束啦！）解压完以后就能看到docker镜像了！然后正常执行dockerrun操作就可以啦！（还是把命令贴出来看一下把） dockerrun--rmcowsay //cowsay只是一个自定义名字 可以参考dockerrun 
第507篇文章[3]
148.排序链表在O(nlogn)时间复杂度和常数级空间复杂度下，对链表进行排序。 快慢指针找中点//slow：（5个停在3,10个停在5） classSolution{ public: ListNode*sortList(ListNode*head){ if(head==NULL||head->next==NULL) returnhead; ///*快慢指针查找剧中节点*/ //ListNode*fast=head,*slow=head; //ListNode*tmp=head; //while(fast!=nullptr&&fast->next!=nullptr){ //tmp=slow; //fast=fast->next->next; //slow=slow->next; //} //tmp->next=NULL; //ListNode*left=sortList(head); //ListNode*right=sortList(slow); ListNode*fast=head->next,*slow=head; while(fast&&fast->next){ fast=fast->next->next; slow=slow->next; } ListNode*pre=slow->next; slow->next=NULL; ListNode*left=sortList(head); ListNode*right=sortList(pre); returnmerge(left,right); } 后面那一种查找中点的方式更加简单，巧妙之处在于“fast=head->next;" ListNode*merge(ListNode*left,ListNode*right) {ListNode*result=newListNode(0); ListNode*cur=result; while(left!=NULL&&right!=NULL){ if(left->val<right->val) { cur->next=left; cur=cur->next; left=left->next; } else{ cur->next=right; cur=cur->next; right=right->next; } } if(left!=NULL){ cur->next=left; } if(right!=NULL){ cur->next=right; } //cur->next=(left==NULL?right:left); returnresult->next; } 
第508篇文章[]
【lab2】关于Equals和HashCode重写 为什么要重写Equals和HashCode？ 每当我们定义一个immutable类的时候，就应该考虑重写其Equals和HashCode ​一个immutable类，创造两个对象A,B;A和B有着一模一样的内容，但是由于内存地址的不同，我们用"==“或者是缺省的equals(内部实现还是”==")，是不能够得出他们相等的。 ​如果要想他们在外界看来是一样的，那就要重写类中的equals函数，而HashCode也应该随之重写。 ​因为：如果两个对象相同，就是适用于equals(java.lang.Object)方法，那么这两个对象的hashCode一定要相同ref 对于mutable的类，我们不必管Equals和HashCode，直接使用默认的即可 如何重写Equals和HashCode？ ​例子： @Override publicbooleanequals(Objectobj){ if(this==obj)returntrue; if(obj==null||this.getClass()!=obj.getClass())returnfalse; Personperson=(Person)obj; returnname.equals(person.name); } @Override publicinthashCode(){ returnObjects.hash(name,age); } [reference:] 重写hashcode方法|Tanthen HashMap什么时候重写hashcode和equals方法，为什么需要重写_Keith003的博客-CSDN博客 为什么使用HashMap需要重写hashcode和equals方法？_hxt的博客-CSDN博客_为什么要重写hashcode和equals方法 Java中hashCode的作用 
第509篇文章[]
【lab2】defensivecopy HowtoDefensiveCopy 条件 方法返回一个mutable的数据类型 语法 withoutdefensivecopy: publicNamegetName(){ returnname; } 这种observer则会造成类中参数被改变的风险。 withdefensivecopy: publicNamegetName(){ returnnewName(name.toString()); } 对于抽象类型 lab2中给出的L是一个不知道类型的抽象数据类型，但是spec中有明确讲到必须是immutable的 *@param<L>typeofvertexlabelsinthisgraph,mustbeimmutable 所以我们在接口设计的时候不需要刻意实现防御式拷贝。 参考 
第510篇文章[1]
Vmware共享目录消失（绝对有用！） 查看是否已经挂载 vmware-hgfsclient 2.如果没有挂载 先umount卸下 sudoumount/mnt/hgfs 然后在重新挂上去 sudovmhgfs-fuse.host://mnt/hgfs 再次查看 vmware-hgfsclient 
第511篇文章[1]
Linus下EDB的安装 安装#installdependencies sudoapt-getinstallcmakebuild-essentiallibboost-dev\ libqt5xmlpatterns5-devqtbase5-devqt5-default\ libqt5svg5-devlibgraphviz-devlibcapstone-dev 安装#buildandrunedb sudoaptinstallgit gitclone--recursivehttps://github.com/eteran/edb-debugger.git 如果出错，把https改为git再重新执行 cdedb-debugger mkdirbuild cdbuild cmake.. 如出错sudoapt-getinstall--reinstallpkg-configcmake-data make ./edb--run执行程序 
第512篇文章[]
【lab2】scanner读文件 publicGraphPoet(Filecorpus)throwsIOException{ try{ Filefile=newFile("assets/test.txt"); Scannerscanner=newScanner(corpus); scanner.useDelimiter("\\s+"); StringpreWord=null; StringthisWord; inti=0; while(scanner.hasNext()){ thisWord=scanner.next(); graph.add(thisWord.toLowerCase()); if(i>0){ //不存在边，加入 intlastEdgeWeight=this.graph.set(preWord.toLowerCase(),thisWord.toLowerCase(),1); //如果边已经存在了，weight++ if(lastEdgeWeight!=0) this.graph.set(preWord.toLowerCase(),thisWord.toLowerCase(),lastEdgeWeight+1); } i=1; preWord=thisWord; System.out.println(); } scanner.close(); }catch(Exceptione){ thrownewIOException("FileNotReadableorNotFound"); } publicGraphPoet(Filecorpus)throwsIOException{ //读文件 try{ BufferedReaderreader=newBufferedReader(newFileReader(corpus)); BufferedReaderbReader=newBufferedReader(reader); Stringline; List<String>words=newArrayList<>(); while((line=bReader.readLine())!=null){ //单词小写加入图 words.clear(); words.addAll(Arrays.asList(line.split("\\s+"))); intnum=words.size(); for(inti=0;i<num;i++){ graph.add(words.get(i).toLowerCase()); if(i>0){ //不存在边，加入 intlastEdgeWeight=this.graph.set(words.get(i-1).toLowerCase(),words.get(i).toLowerCase(),1); //如果边已经存在了，weight++ if(lastEdgeWeight!=0) this.graph.set(words.get(i-1).toLowerCase(),words.get(i).toLowerCase(),lastEdgeWeight+1); } } } bReader.close(); checkRep(); }catch(Exceptione){ thrownewIOException("FileNotReadableorNotFound"); } //thrownewRuntimeException("notimplemented"); } ``` 
第513篇文章[1]
ubuntu下无法看到共享文件夹 无法看到mnt/hgfs/后的共享文件夹 执行 执行 sudovmhgfs-fuse.host://mnt/hgfs/-oallow_other-ouid=1000 
第514篇文章[]
【总结】ADT ADT总结 1.ADT的内容 属性（名词）rep内部数据结构不可见方法（动词）Spec规约impl实现方法，功能Spec可见impl不可见 对外部只有接口，封装后用户不关心内部 1.1ADT的内部方法可以大致分为以下四类 creator构造器 ​初始化，新建一个ADT对象 a.new() b.静态工厂：graph.empty() producer生产器 ​比如String.concat()能够返回一个新的对象,不改变内部数据 observer观察器 Eg:.size()看内部东西，不改变内部数据 mutator变值器 Eg.Add()修改内部数据 ​大部分返回void/bool ​只有mutable类型才有！ 1.2表示独立性 内部变化后，外部不因此受影响 ​为什么内部会变化(impl)？（优化性能，多种实现）​内部变化一定要遵循spec!(测试用例就是根据spec写的） 对于客户端，只能见到spec，无法看见rep和impl 比如：List可以有两种实现方式： Lista=NewarrayList Listb=NewlinkeList 但是从外部看来，调用方法并没有差异（比如.Add()、.remove()方法是一样的） 内部rep应该是private而不是public用户端使用的API不应该因为内部rep实现的改变而瘫痪 1.3表示泄漏/repexposure： ​个人理解：client获取到了你内部变量/获取到了你的内部实现方法（本来不应该看到的，给人看到了！） 如何避免表示泄漏： 全部属性private对于mutable类型 Collection.unmodifiable.wraped)（解决拷贝空间问题）防御式拷贝（返回一个拷贝后的新的对象） 尽可能用immutable数据类型 1.4如何测试一个ADT的方法（测试用例） adt的四种方法、 c/p/m用observer查看属性O先用c/p造出，再调用o代码覆盖率无须100% 2.ADT的不变性 “始终保持为真的一组条件” 2.1抽象空间A,实际空间R 抽象空间A：用户看到的值;(Abstract)实际空间R：内部维系的值(Realization) A中的值，一定能够在R中至少找到一个值与之对应(满射） ​（但是不是单射不一定） 2.2AFRI概念 AF（abstractfunction）抽象函数（就是A--R之间的函数） 抽象函数是表示从表示空间到抽象空间映射的函数比如：我存了一个graph图来表示人际关系​AF(graph)=现实中的人际关系图RI（repinvariant）表示不变量 表示不变量将表示变量值映射成一个布尔值。简单来说，就是一个条件，判断内部元素是否合法。比如：我要求图graph不为空，那么RI中就是“图不为空”这个条件。Checkrep():满足条件，合法；不满足，非法！使得属性都满足RI为true每个方法返回之前调用 用Assert+表达式 False:throwAssertErro(直接退出！违反了RI，程序没有必要继续错误地执行） 调用时机： C/P/M最后一行返回之前。 O按道理来说不会改变RI，但是防止粗心，也需要在最后写一个。 每次都调用，增加复杂度？ 开关！ -ea开发的时候，打开assert -da交付的时候，关闭assert [参考：AFRI的概念](表示不变量（RepresentationInvariant）与抽象函数（AbstractFunction）-siren27-博客园(cnblogs.com)) unmodifiableList返回一个只能看不能改的方法 3.ADT的设计流程 设计一组方法（C/T/M/O）以及specTDD测试用例（根据spec）选择Rep（内部数据结构）/并impl设计RI（比如边的权值不为负，点不能为空）设计AF（R >A)（比如边对应人际关系）RI/AF的注释 怎么避免表示泄漏？（mutable与immutable都要考虑） 4.ADT如何保持表示不变性 对于immutable，只要保证没有/M对于RI：checkRep()无表示泄漏！（见1.3） 
第515篇文章[]
【lab2】Safetyfromrepexposure 简单来说，一个主类有属性和方法两种成分，这里的主类是指用户直接使用的类，需要做到以下两点 1、将类中所有的属性（变量）定义为private类型， ​目的是不让用户得到你的内部属性 2、方法或者返回immutabledata，或者返回本应该返回的mutabledata的副本，或者返回一个不可修改的mutabledata ​1、尽量使用immutable数据类型，比如能使用String就不使用StringBuilder，能使用Instance就不使用Data ​2、为了创造mutabledata的副本，可以进行defensivecopy。可以在主类方法中构造然后返回，但是推荐方法是使用mutable数据类型的clone，假如该mutable数据类型是自己写的类，那么推荐在类中写一个clone的方法 ​3、使用Collections.unmodifiableSet等方法 这里需要注意的是第二个方面，如果想要返回一个Collection类的数据，有人说我创建了一个Collection类，向里面添加数据后，不管数据怎样，都算defensivecopy了，但是如果数据是mutable类型，那么就不算defensivecopy，因为Collection类储存的是地址，尽管new了一个hashSet或者hashMap，但是没有真正的对mutable数据进行defensivecopy。  版权声明：本文为CSDN博主「djd566」的原创文章，遵循CC4.0BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/djd566/article/details/79749757 
第516篇文章[]
【lab2】如何在@test测试函数中抓获异常 @Test(expected=IllegalArgumentException.class) publicvoidtestEmptyVertexToString()throwsIllegalArgumentException{ newVertex<>(null);//传入null参数报错，抛出IllegalArgumentException异常 } 
第517篇文章[5]
【软构课堂笔记6：设计模式】 
第518篇文章[5]
【软构课堂笔记4：可复用性CRP可维护性正则表达式】 
第519篇文章[]
SoftwareConstructionlab2：总结 SoftwareConstructionlab2 junit测试代码覆盖率： ​代码覆盖率可以使用IDEA自带的工具 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wTShgQvr-1622905245128)(E:\Typora_info\pong\image-20210605214220642.png)] 整体设计流程： 写Spec 根据Spec完成测试用例 实现Graph 防止内存泄漏的方法 1.内部变量尽量使用immutable的，并设置为私有属性 2.对于返回值，如果是mutable数据类型，一定要使用防御式拷贝 3.必要时加上final关键字 checkRep()的意义 ​我们定义的每一个对象，都要遵循规约，而checkRep()就是我们检查对象内部属性是否合法的方法。 ​调用时机：应该在所有方法的最后一行/返回前调用checkRep(),不必担心影响程序速度，可以关掉。 读取TXT文件 参考 使用BuffererReader.继承Reader类 publicvoidfileRead()throwsException{ Filefile=newFile("D:\\test.txt");//定义一个file对象，用来初始化FileReader FileReaderreader=newFileReader(file);//定义一个fileReader对象，用来初始化BufferedReader BufferedReaderbReader=newBufferedReader(reader);//new一个BufferedReader对象，将文件内容读取到缓存 StringBuildersb=newStringBuilder();//定义一个字符串缓存，将字符串存放缓存中 Strings=""; while((s=bReader.readLine())!=null){//逐行读取文件内容，不读取换行符和末尾的空格 sb.append(s+"\n");//将读取的字符串添加换行符后累加存放在缓存中 System.out.println(s); } bReader.close(); Stringstr=sb.toString(); System.out.println(str); } ​way2:使用FileInputStream类 privatestaticStringgetTemplateContent()throwsException{ Filefile=newFile("D:\\test.txt"); if(!file.exists()){ returnnull; } FileInputStreaminputStream=newFileInputStream(file); intlength=inputStream.available(); bytebytes[]=newbyte[length]; inputStream.read(bytes); inputStream.close(); Stringstr=newString(bytes,StandardCharsets.UTF_8); returnstr; } java异常捕获 ​java异常捕获 try{ d=Double.parseDouble(bidPrice); }catch(Exceptione){ e.printStackTrace(); //方法也抛出了异常，交由调用者处理 thrownewAuctionException("这是由throw关键字抛出的异常"); } try{ at.bid("abc"); }catch(AuctionExceptionae){ System.err.println(ae.getMessage()); } ​ 
第520篇文章[5]
软构复习【6】 
第521篇文章[]
【lab2】关于构造器非法参数的问题 结论：如果判断条件非法，直接抛出异常 thrownewIllegalArgumentException("Wrong!"); 参考网址 下面直接截取详细内容：Iftheprogrameverexecutesastatementlike: thrownew???Exception("…message…"); Javastopstheprogramandsignalstheerrorthroughtheconstructedinstanceofthe???Exception(wherethe???arereplacedbythenameofwhicheverparticularexceptionisdesired).Forourpurposes,thiswillsimplyterminatetheprogramandprintthegivenerrormessage. 
第522篇文章[5]
【软构lab3日志：造轮子的苦逼】 
第523篇文章[5]
软构复习【4】 
第524篇文章[]
【lab2】如何创建可变类&不可变类 如何创建可变类&不可变类 可变类和不可变类(MutableandImmutableObjects) 可变类和不可变类的区别：是否有mutator方法（是否可以更改属性） 可变类和不可变类(MutableandImmutableObjects)的初步定义： 可变类：当你获得这个类的一个实例引用时，你可以改变这个实例的内容。 不可变类：当你获得这个类的一个实例引用时，你不可以改变这个实例的内容。不可变类的实例一但创建，其内在成员变量的值就不能被修改。 举个例子：String和StringBuilder，String是immutable的，每次对于String对象的修改都将产生一个新的String对象，而原来的对象保持不变，而StringBuilder是mutable，因为每次对于它的对象的修改都作用于该对象本身，并没有产生新的对象。 如何创建一个自己的不可变类： a.所有属性都是privatefinalb.不提供对成员的改变方法，例如：也就是王老师上课说的 “immutable类不能有mutator的方法” c.确保所有的方法不会被重载。手段有两种：使用finalClass(强不可变类)，或者将所有类方法加上final(弱不可变类)。d.确保类不能被继承：​将类声明为final,或者使用静态工厂并声明构造器为private。 静态工厂能保证对象创造时的唯一性；并且由于命名不是固定的，更能清楚地表达意思。 (如果类可以被继承会破坏类的不可变性机制，只要继承类覆盖父类的方法并且继承类可以改变成员变量值，那么一旦子类以父类的形式出现时，不能保证当前类是否可变。) 如果某一个类成员不是原始变量(primitive)或者不可变类，必须通过在成员初始化(in)或者get方法(out)时通过深度clone方法，来确保类的不可变。 reference:可变类与不可变类的区别 reference:JAVA-可变对象与不可变对象 优质reference：[Java]如何实现一个不可变类（Immutableclass） 
第525篇文章[1]
Linus下CodeBlocks的安装 只需输入3个命令 sudoadd-apt-repositoryppa:damien-moore/codeblocks-stable sudoapt-getupdate sudoapt-getinstallcodeblocks
第525篇文章[5]
软构复习【3】 
第526篇文章[5]
【软构课堂笔记6：设计模式】 
第527篇文章[5]
【软构课堂笔记3：面向对象编程】 
第528篇文章[5]
软构复习【2】  
第530篇文章[5]
【软构课堂笔记4：可复用性CRP可维护性正则表达式】 
第532篇文章[]
正则表达式在Java语言程序编程时如何从文件中读取数据并运用 正则表达式在Java语言程序编程时如何从文件中读取数据并运用 1.读取文件 读取文件的方式有很多，这里我简单地使用字符串标明路径，通过路径创建文件型变量（File）。 Stringfilepath="src/txt/test.txt"; Filefile=newFile(filepath); Scannerfileread=newScanner(file); 这时我们能够从文件以字符串的形式读取内容，通过相关的正则表达式来判断内容是否正确。 2.转换文件信息 我们无法直接从文件里获取数据给程序中的变量，因此我们要暂时存储数据 Stringtext=""; while(fileread.hasNext()){ text+=fileread.nextLine(); text+="\n"; } fileread.close(); 这里为了保证文件读取后转换为String类型时其内容的结构不变（如果你使用过正则语言表达式，你会发现空格是很恶心的东西），所以我们使用Scanner.nextLine()来成行地读取数据。 3.再次提取信息 Strings;   Patternpattern=Pattern.compile(Stringparser); Matcherm=pattern.matcher(s); while(m.find()){ System.out.println(m.group()); } 这是一段很经典的正则语言匹配代码，parser为字符串类型变量，它表示的是正则语言表达式；而m可以看作是正则表达式在s中索引内容parser的一个方法概括,m.find()代表正则表达式找到了一个匹配的对象，此时如果再m.find()的话正则表达式会去寻找下一个匹配的对象（这一点和next()很像）。在这里要注意的是m.group()返回的是m.find()找到的对象，这就意味着，如果开始时没有m.find()，m.group()是不起作用的；同时，如果只进行一次m.find()，无论输出多少次m.group()都只是最靠近的一次m.find()找到的内容。 4.提取变量内容 在这里，比如说我想提取一段时间，文本内容是   {2021-01-01,2021-02-03}   这里我们进行一下简单约束，我们可以设计一个正则语言把时间提取出来 parser="//{20[0-9][0-9]-[0-9][0-9]-[0-9][0-9],20[0-9][0-9]-[0-9][0-9]-[0-9][0-9]//}"; 通过我上述的代码完全可以获得 Stringmessage=m.group(); 我们再精确提取时间 intyear1,year2,month1,month2,day1,day2; PatternYear=pattern.compile("20[0-9][0-9]"); PatternMonth=pattern.compile("[0-9][0-9]"); PatternDay=pattern.compile("[0-9][0-9]"); Matcheryear=Year.matcher(message); Matchermonth=Month.matcher(message); Matcherday=Day.matcher(message); year.find();//**2021**-01-01,2021-02-03 year1=Integer.parseInt(year.group()); year.find();//2021-01-01,**2021**-02-03 year2=Integer.parseInt(year.group()); month.find();//**20**21-01-01,2021-02-03 month.find();//20**21**-01-01,2021-02-03 month.find();//2021-**01**-01,2021-02-03 month1=Integer.parseInt(month.group()); month.find();//2021-01-**01**,2021-02-03 month.find();//2021-01-01,**20**21-02-03 month.find();//2021-01-01,20**21**-02-03 month.find();//2021-01-01,2021-**02**-03 month2=Integer.parseInt(month.group()); day.find();//**20**21-01-01,2021-02-03 day.find();//20**21**-01-01,2021-02-03 day.find();//2021-**01**-01,2021-02-03 day.find();//2021-01-**01**,2021-02-03 day1=Integer.parseInt(day.group()); day.find();//2021-01-01,**20**21-02-03 day.find();//2021-01-01,20**21**-02-03 day.find();//2021-01-01,2021-**02**-03 day.find();//2021-01-01,2021-02-**03** day2=Integer.parseInt(day.group()); 此时变量数据便提取了出来。 
第533篇文章[1]
2021-06-23 程序人生-Hello’sP2P 摘要 一个hello程序的生成，要经历预处理，编译，汇编和链接，从而得到可执行目标文件；而hello程序的运行，则需要进程，信号和I/O的共同实现。通过一个简简单单的hello文件，可以大致窥探到计算机运行的整个面貌。 关键词：编译；汇编；链接；虚拟内存；进程；I/O。 目录 摘要第1章概述1.1Hello简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2Ubuntu下编译命令3.3Hello的编译结果解析3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令4.3可重定位目标ELF格式4.4Hello.o的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件HELLO的格式5.4HELLO的虚拟地址空间5.5链接的重定位过程分析5.6HELLO的执行流程5.7HELLO的动态链接分析5.8本章小结 第6章HELLO的进程管理6.1进程的概念与作用6.2简述壳SHELL-BASH的作用与处理流程6.3的FORK进程创建过程6.4HELLO的EXECVE过程6.5HELLO的进程执行6.6HELLO的异常与信号6.7本章小结 第7章HELLO的存储管理7.1HELLO的存储器地址空间7.2INTEL逻辑地址到线性地址的变换-段式管理7.3HELLO的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.5三级CACHE支持下的物理内存访问7.6HELLO进程FORK时的内存映射7.7HELLO进程EXECVE时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章HELLO的IO管理8.1LINUX的IO设备管理方法8.2简述UNIXIO接口及其函数8.3PRINTF的实现分析8.4GETCHAR实现分析8.5本章小结 结论附件参考文献第1章概述1.1Hello简介1.2环境与工具1.3中间结果本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析本章小结 第3章编译3.1编译的概念与作用3.2在Ubuntu下编译的命令3.3Hello的编译结果解析3.3.1全局变量sleepsecs3.3.2局部变量i3.3.3if的控制转移3.3.4for循环的实现3.3.5函数调用3.3.6数组3.3.7强制转换3.3.8算数操作 本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令可重定位目标elf格式4.4hello.o的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式5.4hello的虚拟地址空间5.5链接的重定位过程分析5.6hello的执行流程5.7Hello的动态链接分析本章小结 第6章hello进程管理6.1进程的概念与作用6.2简述壳Shell-bash的作用与处理流程6.3Hello的fork进程创建过程6.4Hello的execve过程6.5Hello的进程执行6.6hello的异常与信号处理6.7本章小结 第7章hello的存储管理7.1hello的存储器地址空间7.2Intel逻辑地址到线性地址的变换-段式管理7.3Hello的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.6hello进程fork时的内存映射7.7hello进程execve时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章hello的IO管理8.1Linux的IO设备管理方法8.2简述UnixIO接口及其函数8.3printf的实现分析8.4getchar的实现分析8.5本章小结 附件参考文献 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2Ubuntu下编译命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标ELF格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件HELLO的格式 5.4HELLO的虚拟地址空间 5.5链接的重定位过程分析 5.6HELLO的执行流程 5.7HELLO的动态链接分析 5.8本章小结 第6章HELLO的进程管理 6.1进程的概念与作用 6.2简述壳SHELL-BASH的作用与处理流程 6.3的FORK进程创建过程 6.4HELLO的EXECVE过程 6.5HELLO的进程执行 6.6HELLO的异常与信号 6.7本章小结 第7章HELLO的存储管理 7.1HELLO的存储器地址空间 7.2INTEL逻辑地址到线性地址的变换-段式管理 7.3HELLO的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级CACHE支持下的物理内存访问 7.6HELLO进程FORK时的内存映射 7.7HELLO进程EXECVE时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章HELLO的IO管理 8.1LINUX的IO设备管理方法 8.2简述UNIXIO接口及其函数 8.3PRINTF的实现分析 8.4GETCHAR实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 P2P(fromprogramtoprocess)，将源代码经过预处理转化为预处理输出文件，将预处理输出文件经过编译转化为汇编代码文件，将汇编代码文件经过汇编转化为可重定位目标文件，将可重定位目标文件经过链接转化为可执行目标文件。020(fromzero-0tozero-0)，hello程序从主存到开始，通过虚拟地址寻址并由IO执行，在执行完之后释放内存存储空间，一切就像没有发生过的一样。 1.2环境与工具 电脑型号：荣耀MagicBook2019CPU：AMDRyzen53500UwithRadeonVegaMobileGfx2.10GHz物理机系统：Windows10版本号：19042.1052虚拟机：VMware16.1.2build-17966106虚拟机系统：Ubuntu64位20.04gcc:C语言编译器objdump,edb,gdb 1.3中间结果 hello.c:源文件hello.i:预处理输出文件hello.s:编译代码文件hello.o：可重定位目标文件hello：可执行目标文件 本章小结 本章从整体角度大致地介绍了程序（program）的生成和执行过程，以及下文内容的实现所使用的软硬件环境。 第2章预处理 2.1预处理的概念与作用 预处理是将源程序转化为可执行程序的第一个转化步骤，主要用于C语言编译器对各种预处理命令进行处理，包括对头文件的包含，宏定义的扩展，条件编译的选择等。 2.2在Ubuntu下预处理的命令 将.c文件转化为预处理后的.i可见文本文件hello.c->hello.i:linux>gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析 预处理后可以发现，原先源代码里的头文件和宏都被程序替换为对应路径里面的文本，将所有调用全部展开，为后面的编译做准备。 本章小结 本章介绍了预处理的指令与过程，从代码展开的层面解释了预处理的原理与意义，为后面介绍编译做准备。 第3章编译 3.1编译的概念与作用 C编译器在进行具体的程序翻译之前，会先对源程序进行词法分析，语义分析和语法分析，然后根据分析的结果进行代码优化和存储分配，最终把C语言源程序翻译成为汇编语言程序。编译器通常采用对源程序进行多次扫描的方式进行处理，每次集中完成一项或几项任务，也可以将一项任务分散到几次扫描进行完成。 3.2在Ubuntu下编译的命令 hello.i->hello.s:linux>gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 3.3.1全局变量sleepsecs sleepsces作为全局变量被放在.data节，并通过globl声明为全局变量。 3.3.2局部变量i 局部变量i为int型数据，在这里大小为4字节。局部变量一般都是存储在寄存器或者栈空间，在这里%rbp栈堆开出4字节空间存储i 3.3.3if的控制转移 If循环使用cmpl来进行数值比较和条件码的设置，若不等于3，通过无条件跳转jmp跳转到L3来实现if内的语句。 3.3.4for循环的实现 For循环也是通过条件码来实现跳转，在这里L3的条件跳转和L4的自然结束后过渡到L3共同构成了一个循环，当i>=10时跳出循环。 3.3.5函数调用 Printf函数，getchar函数，sleep函数，exit函数，通过call来调用这些函数 3.3.6数组 编译后数组通过索引值和基值实现对数组内容的寻址，char*为地址数组类型，每一个大小8字节，则将寄存器%rax中的值增加16恰好到达argv[2]处。 3.3.7强制转换 Sleepsecs被隐式强制转换，实际上被赋值为2（向0舍弃）。 3.3.8算数操作 通过add来实现加法运算 本章小结 本章通过hello的实例将C语言操作和数据类型与汇编语言对应起来，从寄存器和堆的角度来看待程序的运行。 第4章汇编 4.1汇编的概念与作用 汇编的功能是将编译生成的汇编语言代码转换为机器语言代码。因为通常最终的可执行目标文件由多个不同模块对应的机器语言目标代码组合而形成，所以，在生成单个模块的机器语言目标代码时，不能确定每条指令或每个数据最终的地址，也即，单个模块的机器语言目标代码文件需要重新定位，因此，通常把汇编生成的机器语言目标代码文件称为可重定位目标文件。 4.2在Ubuntu下汇编的命令 hello.s->hello.o:linux>gcc-chello.s-ohello.o 可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。readelf-ahello.o>hello.elf ELF头：开头Magic:7f454c46020101000000000000000000，描述了生成该文件的系统的字的大小和字节顺序，紧接着便是ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移、节头部表中的条目的大小和数量节头部表：节头部表显示不同节的位置与大小信息，目标文件中每个节都有一个固定大小的条目。重定位节：显示偏移量，信息，类型，符号值，符号名称和加数等信息。符号表：符号表由汇编器构造，表中包含一个数组。 4.4hello.o的结果解析 objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。两者的代码实现功能相同，但是相比之下反汇编的代码更加“奇妙”，这种奇妙是机器运行计算和人脑思维运算的不同。由.i文件得到的.s文件像是一种翻译，将人类的高级编程语言翻译成机器语言，但是思维逻辑还是人的思维；而.o文件的反汇编更像是对程序在机器层面运行的记录，它的每一步都通过机器语言从硬件层面记录下来，同时也可以优化人类所翻译的机器语言，提高了逻辑性，降低了人类的阅读性和理解性。说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 4.5本章小结 通过汇编与反汇编的对比，用ELF表头显式地表现程序结构，从机器层面去了解和解释程序的运行变得更加容易。 第5章链接 5.1链接的概念与作用 链接的功能是将所有关联的可重定位目标文件组合起来，以生成一个可执行文件。可重定位目标文件和可执行目标文件都是机器语言目标文件，所不同的是前者是单个模块生成的，而后者是多个模块组合而成的。 5.2在Ubuntu下链接的命令 ld-ohello.ld-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 5.4hello的虚拟地址空间 edb显示的与5.3中内容对应。 5.5链接的重定位过程分析 在获得的反汇编文件中，对于一些过程要比汇编生成的内容要详细，如生成了链接过程中才能指定的地址。在重定位中要对绝对地址进行引用，需要进行PC相对寻址；同时也将一些头文件的函数通过引用里libc.so加入到.text中。 5.6hello的执行流程 _init0x1000.plt0x1020_cxa_finalize@plt0x1080puts@plt0x1090printf@plt0x10a0getchar@plt0x10b0exit@plt0x10c0sleep@plt0x10d0_start0x10e0_libc_csu_fini0x10fa_libc_csu_init0x1101deregister_tm_clones0x1110_fini0x12c8 5.7Hello的动态链接分析 PIC函数调用了由共享库定义的函数，编译器无法预测函数的运行时的地址。GNU编译系统把函数地址的解析推迟到它实际被调用的地方。延迟绑定通过动态链接器使用过程链接表(PLT)和全局偏移量表(GOT)两个数据结构实现。GOT存放函数目标地址，PLT通过GOT中存储的地址间接跳转至目标函数。 当调用库内函数时，控制流会跳转到相应函数的PLT表中，PLT会通过GOT把将要调用的函数序号压入栈中，然后调用动态链接器；动态链接器会进行重定位，用栈中的地址重写入GOT，替代GOT原先用来跳转到PLT的地址变为实际的函数地址，再把控制传递给调用函数和PLTPLT，再次通过GOT间接跳转。 本章小结 本章讲述链接的过程，最终生成可执行文件，并且对执行过程进行对比，使我对链接的理解更加深刻。 第6章hello进程管理 6.1进程的概念与作用 进程就是程序的一次运行过程。更确切地说，进程是一个具有一定的独立功能的程序关于某个数据集合的一次运行活动，因而进程具有动态意义。计算机处理的所有任务实际上都是由进程来完成的。 6.2简述壳Shell-bash的作用与处理流程 Shell接收用户命令，调用相关程序：读取命令并处理得到的参数；判断命令的类型，对不同类型命令分情况执行；处理信号，更新进程状态；判断输入发出信号。 6.3Hello的fork进程创建过程 子进程通过fork()函数来创建。子进程相当于当前进程的一个复制本，但是其发展走向与父进程并不一定完全相同；此外，由fork函数创建的子进程其pid一定不为0，故fork函数返回值为0，这就意味着pid为0时为子进程，这为判断进程提供了方法。子进程继续运行函数的剩余部分，子进程也可以有自己的子进程，父进程和子进程的运行顺序按照拓扑排序执行，所有进程一直运行直到进程终止。 6.4Hello的execve过程 excve函数在上下文中加载运行一个新程序，在这里它加载hello可执行文件，之后调用启动代码，并且传递控制。 6.5Hello的进程执行 系统执行进程时，内核可以暂停当前进程，同时启用其他进程，这个过程就是调度，而这些进程以及它们的PC值所构成的序列就是逻辑控制流。当进程被执行时，内核代码不断地根据上下文信息，时间片等进行判断，并根据其结果转移控制权并完成调度。 6.6hello的异常与信号处理 正常情况没有干扰下，内容打印10遍乱按情况下没有影响ctrl+c直接结束程序Ctrl+z程序挂起ps查看程序运行状态jobs查看作业pstree查看进程关系fg程序继续运行kill杀死进程 6.7本章小结 本章介绍fork和execve函数，通过shell介绍命令和进程以及信号处理过程。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：由程序产生，其内容是与段相关的偏移地址，由段标识符和段内偏移量组成。线性地址：当一个地址空间的地址是连续的非负整数时，该地址空间中的地址被称为线性地址。虚拟地址：CPU通过虚拟地址寻址，然后通过MMU(内存管理单元)将虚拟地址转换为物理地址。物理地址：计算机主存被划分成连续字节大小的内存组成的数组，每个字节都有唯一一个地址，这个地址就是物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 全局描述符表GDT：通常来说系统只定义了一个GDT，用来存放系统内每个任务都可能访问的描述符。局部描述符表LDT：存放进程专用的描述符首先，判断段选择描述符中T1字段的数字，可知当前将要转换的是GDT中的段，还是LDT中的段；再根据指定的相应寄存器，得到其地址和大小，得到一个数组。抽取段选择符中的前13位，在这个数组中查找到对应的段描述符，这样就有了Base。把基地址Base+Offset，得到要转换的下一个阶段地址。 7.3Hello的线性地址到物理地址的变换-页式管理 虚拟缓存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须判定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判定这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换掉牺牲页。这些功能是由软硬件联合提供的，包括操作系统软件，MMU(内存管理单元)中的地址翻译硬件和一个存放在物理内存中的骄傲做页表的数据结构，页表会将虚拟页映射到物理页。首先，根据控制寄存器CR3给出的页目录表首地址找出页目录表，由DIR字段提供的10位页目录索引找到对应的页目录项，每个页目录项大小为4B；然后，根据页目录项中20位基地址指出的页表首地址找到对应页表，再根据线性地址中间的页表索引(PAGE字段)找到页表中的页表项；最后，将页表项中的20位及地址和线性地址中的12位页内偏移量组合成32位物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 为了减小缓存次数，往往把页表中最活跃的几个页表项复制到高速缓存中，这种在高速缓存中的页表项组成的页表称为后被转换缓冲器(TLB)。在VA到PA的变换过程中，虚拟地址被分割成4个9位的片。在这里，CR3寄存器包含L1页表的物理地址。VPN1有一个到L1PTE的偏移量，找到这个PTE以后又会包含到L2页表的基础地址；VPN2包含一个到L2PTE的偏移量，找到这个PTE以后又会包含到L3页表的基础地址；VPN3包含一个到L3PTE的偏移量，找到这个PTE以后又会包含到L4页表的基础地址；VPN4包含一个到L4PTE的偏移量，找到这个PTE以后就是相应的PPN。7.5三级Cache支持下的物理内存访问组选择：组索引位标识组，如图7.5.1所示。 行匹配和字选择：行匹配检查多个行的标记位和有效位，以确定所请求的字是否在集合中。传统的内存是一个值的数组以地址作为输人，并返回存储在那个地址的值。另一方面,相联存储器是一个(key,value)对的数组，以key为输人，返回与输人的key相匹配的(key,value)对中的value值，因此我们可以把组相联高速缓存中的每个组都看成一个小的相联存储器，key是标记和有效位，而value就是块的内容。 图7.5.3展示了相联高速缓存中行匹配的基本思想。这里的一个重要思想就是组中的任何一行都可以包含任何映射到这个组的内存块。所以高速缓存必须搜索组中的每一行寻找一个有效的行，其标记与地址中的标记相匹配，如果高速缓存找到了这样一行，那么我们就命中，块偏移从这个块中选择一个字。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构,并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存,它创建了当前进程的rm_struct、区城结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并运行包含在可执行目标文件hello的程序,用hello程序有效地替代了当前程序。加载并运行hello需要以下儿个步骤： 删除已存在的用户区城。删除当前进程虚拟地址的用户部分中的已存在的区域结构。映射私有区城。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的,text和,data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆区域也是请求二进制零的，初始长度为零，图7.7.1概括了私有区域的不同映射。映射共享区域。hello程序与共享对象(或目标)链接，这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。设置程序计数器(PC)。execve做的最后一件事情就是设置当前进程上下文中的粘序计数器，使指向代码区域的入口点。下一次调度这个进程时，它将从这个入口开始执行。Linux将根据需要换入代码和数据页面。 7.8缺页故障与缺页中断处理 假设MMU在试图翻译某个虚报地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤： 虚报地址A是合法的吗？换句话说，A在某个区域结构定义的区域内吗？为了回答这个向题，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的,那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图7.8.1中标识为”1”。因为一个进程可以创建任意数量的新虚拟内存区域，所以顺序搜索区域结构的链表花销可能会很大，因此在实际中，Linux使用某些没有显示出来的字段，Linux在链表中构建了一棵树，并在这棵树上进行查找。试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个页面是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程，这种情况在图7.8.1中标为”2”。此刻，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表，当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU。这次，MMU就能正常地翻译A，而不会再产生缺页中断了。 7.9动态存储分配管理 动态内存分配器维护者一个进程的虚拟内存区域，称为堆。系统之间的细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护者一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。空闲块可以保持空闲，直到它显式地被应用所分配。一个已分配的块保持分配状态，直到它被释放，这种释放要么是应用程序显式执行，要么是内存分配器自身隐式执行。分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器(explicitalloeator)，要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器，C程序通调洲用mal1oc函数来分配一个块，并通过调用Free函数来释放一个块，C中的new和delete操作符与C中的mal1oc和Free相当。隐式分配器(implicitalocator)，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器(garbagecollector)，而自动释放未使用的块的过程叫做垃圾收集。 7.10本章小结 深入了解了hello程序运行时在内存中的映像，展示虚拟内存和物理内存之间的关系。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件设备管理：unixio接口所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入输出都被当作相对应文件的读和写。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访间一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。2.Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO、STOOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值。3.改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k,初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为K。4.读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数：1.进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的。intopen(char*filename,intflags,mode_tmode);open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。返回：若成功则为新文件描述符，若出错为-1。2.进程通过调用close函数关闭一个打开的文件。intclose(intfd);返回：若成功则为0,若出错则为-1。3.应用程序是通过分别调用read和write函数来执行输入和输出的。ssize_tread(intfd,void*buf,size_tn);read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。ssize_twrite(intfd,constvoid*buf,size_tn);write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。返回：若成功则为写的字节数，若出错则为-1。 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章了解了系统级I/O下的文件操作和管理方法，以printf和getchar两个函数为例分析了库函数的实现。（第8章1分）结论hello.c通过预处理生成hello.ihello.i通过编译生成hello.shello.s通过汇编生成hello.ohello.o通过链接生成hellohello被IO执行，分配内存空间。开始运行后，系统不断接收和发出信号调节和维持进程状态。运行结束后，系统释放缓存，清除数据，还原状态。 附件 列出所有的中间产物的文件名，并予以说明起作用。Hello.i：预处理生成文件Hello.s：汇编语言文件Hello.o：可重定位文件Hello：可执行生成文件Hello.elf：elf表头文件，是txt的可读取文件Hello.txt：反汇编文件，用来和hello.s对比 参考文献 为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 
第534篇文章[1]
计算机系统作业(大黑书csapp第二章部分课后作业）（一） 计算机系统作业(大黑书csapp第二章部分课后作业）（一） 哈尔滨工业大学2019级计算机系统作业（一） 深入理解计算机系统（csapp)第二章2.59,2.63,2.67,2.71,2.75,2.79,2.83,2.87,2.91题目答案（2.61以后的题目符合书本第88页位级整数编码规则的要求），19级的小菜鸡自己写+参考（ctrl+c,ctrl+v）以往大佬的（侵删），难免有错误，还请批评指正QAQ。 2.59 typedefunsignedchar*type_pointer; voidshow_byte(type_pointerstart,size_tlen) { printf("%02X",start[len]); } intmain(void) { intx,y,i; printf("Pleaseinputthedataofxandy:"); scanf_s("%d%d",&x,&y); printf("0x"); for(i=sizeof(int)-1;i>0;i--) { show_byte((type_pointer)&y,i); } show_byte((type_pointer)&x,0); } 2.63 unsignedsrl(unsignedx,intk) { unsignedxsra=(int)x>>k; intx_1=(1<<((sizeof(int)<<3)-k))-1; xsra&=x_1; returnxsra; } intsra(intx,intk) { intxsrl=(unsigned)x>>k; intx_1=1<<((sizeof(int)<<3)-k-1); x_1&=xsrl; x_1=~((x_1<<1)-1); xsrl|=x_1; returnxsrl; } intmain(void) { intx,k; printf("Pleaseinputthenumberofxandk:"); scanf_s("%d%d",&x,&k); printf("%08X,%8X",srl(x,k),sra(x,k)); } 2.67 A.编译器信息警告应是数据超过位宽范围，猜测SUNSPARC这样的机器int型应该是16位. B.分次左移，将intbeyond_msb=1<<32;改为intbeyond_msb=1<<31;beyond_msb=beyond_msb<<1; C. /*Thefollowingcodedoesnotrunproperlyonsomemachines*/ intbad_int_size_is_16(){ /*Setmostsignificantbit(msb)of16-bitmachine*/ intset_msb=1<<15; /*Shiftpastmsbof16-bitword*/ intbeyond_msb=1<<15; beyond_msb=beyond_msb<<1; /*set_msbisnonzerowhenwordsize>=16 beyond_msbiszerowhenwordsize<16*/ returnset_msb&&!beyond_msb; } 2.71 A.在return(word>>(bytenum<<3))&0xFF;中，代码实现的是无符号扩展的32位，与要求不符. B. /*Correctlyattemptatxbyte*/ intxbyte(packed_tword,intbytenum) { intbyte,i; byte=(word>>(bytenum<<3))&0xFF; i=1<<7; i=byte&i; i=i<<1; i=i-1; i=~i; byte=byte|i; returnbyte; } 2.75 这段我写的有些离谱，因为不能用循环，只好把代码手动重复32遍，写完之后发现自己题目可能理解错了（w不确定是多少），所以这一题真的是仅供参考TAT intsigned_high_prod(intx,inty) { longlongunsignedlx,ly,lx0,byte_get,w,start,test; lx=(unsigned)x,ly=(unsigned)y,w=0; start=1,test=0; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; return(int)(w>>32); } unsignedunsigned_high_prod(unsignedx,unsignedy) { returnsigned_high_prod((int)x,(int)y); } intmain(void) { unsignedx,y; scanf_s("%u%u",&x,&y); printf("%x,%x\n",x,y); printf("%x\n",unsigned_high_prod(x,y)); } 2.79 这题写的可能有问题 floatmul3div4(intx) { intnum1; num1=x+(x<<1); floatnum=num1; *((int*)&num)-=0b1000000000000000000000000; returnnum; } intmain(void) { intx; scanf_s("%d",&x); printf("%f",mul3div4(x)); } 2.83 A.该值num=Y/(2^k-1)就是一个等比数列求无穷大的极限。 B.(a)5/7(b)2/5©19/63 2.87 描述HexMEVD-0800000-0-0.0最小的>2的值3C011025/1024152.0019531252.0019535125FFF2047/102423512512.0最大的非规格数03FF1023/102400.0000609750.000061-infFC00---inf-inf十六进制表示为3BB0的数3BB01.921875140.96063750.960638 2.91 A.0x40490FDB=0b01000000010010010000111111011011,对应浮点数3.141593，二进制表示为0b11.001000110 B.22/7=0b11.001001001001001001… C.小数点后第六位. 
第535篇文章[1]
HIT计算机系统（CSAPP）大作业 计算机系统 大作业 题目程序人生-Hello’sP2P 专业计算机 学号xxxx 班级1936603 学生xxx 指导教师刘宏伟 计算机科学与技术学院 2021年6月 摘要 本文借助hello程序的运行过程介绍了计算机系统的底层知识：程序加工、进程执行、存储管理等。主要采用实验验证的方法，通过在Ubuntu操作系统+x64cpu上分解hello程序运行的各个阶段，展示一个“小生命”从新生到结束的过程，最终达到深入理解计算机系统的目的。能够使读者在日常的编程中提高系统能力，从计算机系统去考虑问题，而不仅仅是考虑数据结构和算法。 **关键词：**计算机系统；Linux；程序的运行；进程管理；存储管理； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） **** 目录 第1章概述-5- 1.1Hello简介-5- 1.2环境与工具-5- 1.3中间结果-5- 1.4本章小结-6- 第2章预处理-7- 2.1预处理的概念与作用-7- 2.2在Ubuntu下预处理的命令-7- 2.3Hello的预处理结果解析-8- 2.4本章小结-10- 第3章编译-11- 3.1编译的概念与作用-11- 3.2在Ubuntu下编译的命令-11- 3.3Hello的编译结果解析-12- 3.3.1全局变量-12- 3.3.2main函数的参数-12- 3.3.3局部变量-13- 3.3.4字符串常量-13- 3.3.5比较操作-13- 3.3.6分支语句-13- 3.3.7循环语句-14- 3.3.8数组操作-14- 3.3.9函数调用-15- 3.3.10函数返回-16- 3.4本章小结-16- 4.1汇编的概念与作用-17- 4.2在Ubuntu下汇编的命令-17- 4.3可重定位目标elf格式-17- 4.3.1ELF头-17- 4.3.2节-18- 4.3.3节头表-19- 4.4Hello.o的结果解析-21- 4.5本章小结-24- 第5章链接-25- 5.1链接的概念与作用-25- 5.2在Ubuntu下链接的命令-25- 5.3可执行目标文件hello的格式-25- 5.4hello的虚拟地址空间-28- 5.5链接的重定位过程分析-30- 5.6hello的执行流程-32- 5.7Hello的动态链接分析-34- 5.8本章小结-35- 第6章hello进程管理-36- 6.1进程的概念与作用-36- 6.2简述壳Shell-bash的作用与处理流程-36- 6.3Hello的fork进程创建过程-37- 6.4Hello的execve过程-38- 6.5Hello的进程执行-39- 6.6hello的异常与信号处理-40- 6.7本章小结-44- 第7章hello的存储管理-45- 7.1hello的存储器地址空间-45- 7.1.1逻辑地址-45- 7.1.2线性地址-45- 7.1.3虚拟地址-45- 7.1.4物理地址-45- 7.1.5hello的地址空间-45- 7.2Intel逻辑地址到线性地址的变换-段式管理-46- 7.3Hello的线性地址到物理地址的变换-页式管理-46- 7.4TLB与四级页表支持下的VA到PA的变换-47- 7.5三级Cache支持下的物理内存访问-49- 7.6hello进程fork时的内存映射-50- 7.7hello进程execve时的内存映射-51- 7.8缺页故障与缺页中断处理-52- 7.9动态存储分配管理-52- 7.10本章小结-54- 第8章hello的IO管理-55- 8.1Linux的IO设备管理方法-55- 8.2简述UnixIO接口及其函数-56- 8.2.1打开和关闭文件-56- 8.2.2读和写文件-56- 8.3printf的实现分析-57- 8.4getchar的实现分析-59- 8.5本章小结-59- 结论-60- 附件-64- 参考文献-65- 第1章概述 1.1Hello简介 本论文会从一个hello程序的一生作为示例，分析一个C语言程序在linux+ X64环境下所要经历的全部内容。 首先从编写高级语言源程序开始，我们需要建立一个hello.c文件，并按照特定的语法写入程序，但是此时的程序还不能执行，我们需要经过预处理（展开头文件、宏定义等）、编译（翻译为汇编语言程序）、汇编（翻译为可重定位的目标程序）、链接（生成可执行的目标程序），最终生成一个可以执行的程序hello。 接着，这个程序要想运行，需要在shell中输入命令./hello1190401018黄子扬，shell在磁盘上找到相应的程序，现fork一个子进程，接着用execve将hello的上下文加载入这个子进程，并开始执行。程序执行结束后，它并不会立刻完全消失，需要等待父进程将其回收，至此，它才能完全从世界上消失。 在控制流执行的过程中，离不开硬件的帮忙，而现代的处理器的流水线设计，大大提高了吞吐率，使得不同程序的取值、译码、执行、访存、写回、更新PC六大阶段可以在一定条件下并行，极大的提高了运行速率。 程序当然是需要存储空间的了，当前的系统具有四级页表、三级cache、还有容量超大的主存和磁盘，如此复杂却又精细的一套内存管理系统，让hello能够尽情的运行在计算机系统上。cpu从虚拟地址开始，首先查找TLB，如果直接找到则能直接翻译为物理地址，否则则按照级别从多级页表中查找，最终翻译为物理地址，接着又到L1cache中去寻找我们要的字节数据，如果没找到，则按照存储体系从上到下继续寻找。 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 软件环境：Windows1064位；Vmware15.6；Ubuntu20.04LTS64位 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk 开发与调试工具：gcc、gdb、vscode、readelf、edb 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 附件1hello.c 作用：高级语言源程序 附件2hello.i 作用：预处理生成的.i文件 附件3hello.s 作用：编译生成的.s文件（汇编语言文件） 附件4hello.o 作用：汇编生成的.o文件（可重定位的目标文件） 附件5hello.elf 作用：hello.o的elf格式，用于展示可重定位的elf文件格式 附件6hello.asm 作用：hello.o的反汇编格式，用汇编语言的格式来观察可重定位的目标文件 附件7hello 作用：链接生成的可执行的目标文件 附件8hello_exe.elf 作用：hello的elf格式，用于展示可执行的elf文件格式 附件9hello_exe.asm 作用：hello的反汇编格式，用汇编语言的格式来观察可执行的目标文件 1.4本章小结 本章从总体上介绍了hello程序的一生，主要从p2p的过程，即从高级语言源程序到正在执行的进程的过程，和020的过程，即从程序还没开始执行到最终进程被回收的过程，这两个过程来展开的。 本章的精华涵盖了一个程序执行的几乎所有方面：预处理、编译、汇编、链接、fork子进程、execve切换上下文、进程信号机制、硬件执行流程（F、D、E、M、W、U）、从cache到磁盘的存储体系、进程回收机制等。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 概念：预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。典型地，由预处理器(preprocessor)对程序源代码文本进行处理，得到的结果再由编译器核心进一步编译。通常由以下几个操作组成： 头文件展开：将#include包含的文件插入到该指令位置 宏展开：展开所有的宏定义，并删除#define 条件编译：处理所有的条件预编译指令：#if、#ifdef、#else删除注释 添加行号和文件名标识：编译调试时显示行号信息 保留#pragma命令 作用： 宏定义可以简化我们的编程，赋予一个常量有意义的特定的名字，在编程中可以方便程序员的操作，在预处理后会统一进行替换； 头文件的包含可以帮助程序员调用其他模块定义的函数、功能，方便将一个大型程序进行系统化、模块化、组件化； 注释只是在源文件中帮助程序员理解而写的文字，完全没必要在编译的时候考虑，所以一律删掉； 条件编译可以帮助程序员有选择地进行编译，针对不同情况进行处理； 添加行号信息则是方便程序员进行调试操作，能够在debug的时候快速定位错误位置。 2.2在Ubuntu下预处理的命令 gcc-m64-no-pie-fno-PIC-Ehello.c-ohello.i 图2-2-1预处理命令 图2-2-2预处理后得到的文件hello.i 2.3Hello的预处理结果解析 我们打开预处理得到的hello.i文件可以发现，这其中有着大量的头文件展开后引入的内容，可以验证预处理其中的一个最大的作用就是解析头文件的引用，进而确定到具体的代码的位置。如图2-3-1所示。 图2-3-1hello.i中的头文件引入的内容 可以发现，在hello.i文件中，定义了大量的数据类型的别名。应该都是从系统库中引入的一些东西。如图2-2-3所示。 图2-3-2定义数据别名 我们可以发现，从一个简单到只有不到30行的程序，经过预处理后竟然有长达3000余行的代码。如图2-3-3。 图2-3-3预处理后源程序 2.4本章小结 本章简要介绍了c语言程序预处理的基本知识，从预处理指令到预处理后的文件的改变，我们可以看到程序的生成其实是很困难的，远不是我们表面看上去的那么简单。其中比较重要的是头文件和宏定义的展开。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念： 编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序，即编译的目的是将高级语言源程序转化为汇编语言源程序，但本质上这两者都还是机器看不懂的程序，都是为了方便人能看懂，只是级别不太一样。汇编语言程序更加贴近底层，能够直接观察到代码操纵了哪些数据、哪些内存、哪些寄存器、发生了怎样的转换、控制流是如何传递和跳转的等等。 作用：1.扫描（词法分析），2.语法分析，3.语义分析，4.源代码优化（中间语言生成），5.代码生成，目标代码优化。 1.将源代码程序输入扫描器，将源代码的字符序列分割成一系列记号。 2.基于词法分析得到的一系列记号，生成语法树。 3.由语义分析器完成，指示判断是否合法，并不判断对错。又分静态语义：隐含浮点型到整形的转换，会报warning；动态语义：在运行时才能确定。 4.中间代码（语言）使得编译器分为前端和后端，前端产生与机器（或环境）无关的中间代码，编译器的后端将中间代码转换为目标机器代码，目的：一个前端对多个后端，适应不同平台。 5.编译器后端主要包括： 代码生成器：依赖于目标机器，依赖目标机器的不同字长，寄存器，数据类型等；目标代码优化器：选择合适的寻址方式，左移右移代替乘除，删除多余指令。 3.2在Ubuntu下编译的命令 gcc-m64-no-piefno-PIC-Shello.i-ohello.s 图3-2-1编译命令 图3-2-2编译后得到的文件hello.s 3.3Hello的编译结果解析 3.3.1全局变量 我们直到在C语言源程序中定义了intsleepsecs=2.5，这是一个已经初始化了的全局变量，我们在hello.s中观察，可以发现它是在.rodata节中的。 图3-3-1全局变量sleepsecs 3.3.2main函数的参数 由寄存器相关的知识，我们知道存储函数参数的前六个寄存器分别是%rdi，%rsi，%rdx，%rcs，%r8，%r9。根据汇编代码，我们可以发现argc和argv分别存储在%edi，%rsi中，并在一开始首先分别保存到了-20(%rbp)，-32(%rbp)的位置。 图3-3-2寄存器传递函数参数 3.3.3局部变量 我们知道局部变量一般直接存储在栈中。我们知道本题的循环变量i是一个局部变量，观察发现它若能执行到循环分支，则它被初始化为0，且存储在栈中。 图3-3-3局部变量存储在寄存器中 3.3.4字符串常量 字符串常量一般存储在.text节中。我们在汇编代码中可以发现，我们用到的两个字符串常量均在.text节中存储，并且各自有一个标号。 图3-3-4-1字符串常量的存储 我们还可以发现在使用字符串常量的时候，是直接使用标号来引用的。 图3-3-4-2通过标号来引用字符串常量 3.3.5比较操作 变量之间的不等关系是通过!=符号来实现的。而在汇编代码中的体现则是用cmp语句。 图3-3-5cmp语句的使用来比较两个变量的大小关系 3.3.6分支语句 分支语句是基于3.3.5中的比较语句加jxx跳转语句实现的，通过cmp设置的标志，达到一定条件则执行对应的分支。 图3-3-6分支的实现 3.3.7循环语句 循环也是通过比较加跳转语句来实现的。 初始值是0，和9作比较，总循环次数10次 图3-3-7循环的实现 3.3.8数组操作 我们知道数组的操作一般都是通过首地址加上偏移量得到的，我们在汇编代码中可以观察到这种方式用在了取argv中的字符串的地址。 argv数组中的内容存储在了栈中，我们从中取出对应的字符串的地址，并分别放到%rsi和%rdx中，作为printf的第二和第三个参数，最终输出到了屏幕上。 图3-3-8数组操作 3.3.9函数调用 函数调用在汇编中的实现很简单，就是调用call指令。在hello.s中执行多次。而函数参数的传递则类似于3.3.2中的描述。前六个参数分别存储于%rdi,%rsi,%rdx,%rcx,%r8,%r9，而剩余的参数则存放在栈中，位于返回地址的上面。 图3-3-9-1调用puts 图3-3-9-2调用printf 图3-3-9-3调用sleep 3.3.10函数返回 一般的函数返回前会有这样几个操作，恢复被调用者保存的寄存器的值，恢复旧的帧指针%rbp（不一定有这个操作），并跳转到原来的控制流的地址。最终一般都是以ret指令结尾的。 图3-3-10ret指令 3.4本章小结 本章的核心是汇编代码的深入理解。从核心知识上来说有这样几点：数据操作、算数运算、逻辑运算、流程控制、过程调用等等。我们从一个具体的汇编代码文件hello.s来总结整个汇编方面我们需要掌握的知识。 主要涉及到的有：全局变量、本地局部变量、字符串常量、分支语句、循环语句、比较操作、数组、函数调用、函数参数传递、函数返回。 （第3章2分）第4章汇编 4.1汇编的概念与作用 概念：汇编器将hello.s翻译成机器语言指令，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，是机器可以读懂的语言。在我们程序员的的角度来看，目标文件中就完全是乱码。 作用：将汇编语言翻译成可重定位的二进制目标文件。 4.2在Ubuntu下汇编的命令 图4-2-1汇编指令 图4-2-2汇编生成的hello.o文件 4.3可重定位目标elf格式 4.3.1ELF头 图4-3-1ELF头 上图是hello.o的ELF可重定位目标文件的格式。 ELF头以一个16字节的序列开始，这个序列描述生成了该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定的大小的条目。 具体代码格式如下： #defineEI_NIDENT16 typedefstruct{ unsignedchare_ident[EI_NIDENT];//包含用以表示ELF文件的字符，以及其他一些与机器无关的信息。开头的4个字节值固定不变，为0x7f和ELF三个字符。 Elf32_Halfe_type;//标识的是该文件的类型 Elf32_Halfe_machine;//表明运行该程序需要的体系结构 Elf32_Worde_version;//表示文件的版本 Elf32_Addre_entry;//程序的入口地址 Elf32_Offe_phoff;//表示Programheadertable在文件中的偏移量 Elf32_Offe_shoff;//表示Sectionheadertable在文件中的偏移量 Elf32_Worde_flags;//对IA32而言，此项为0 Elf32_Halfe_ehsize;//表示ELFheader大小 Elf32_Halfe_phentsize;//表示Programheadertable中每一个条目的大小 Elf32_Halfe_phnum;//表示Programheadertable中有多少个条目 Elf32_Halfe_shentsize;//表示Sectionheadertable中的每一个条目的大小 Elf32_Halfe_shnum;//表示Sectionheadertable中有多少个条目 Elf32_Halfe_shstrndx;//包含节名称的字符串是第几个节 }Elf32_Ehdr; 4.3.2节 在ELF头和节头表之间，存储的是各个节的内容。我们可以使用readelf-pnum<file>的命令来查看节的内容： 图4-3-2某几个节的内容 4.3.3节头表 节头表通常包含以下几个节： .text.rodata.data.bss.symtab.rel.text.rel.data.debug.line.strtab 图4-3-3-1典型的节头表格式 .text：已编译程序的机器代码 .rodata：只读数据，比如printf语句中的格式串和开关语句中的跳转表 .data：已初始化的全局和静态C变量。局部局部C变量在运行的时候保存在栈中，既不出现在.data节中，也不出现在.bss节中。 .bss：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态C变量。在目标文件中这个节不占用实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。 .symtab：一个符号表，它存放在程序中定义和引用的的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。 .rel.text：；一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件并不需要重定位信息，因此通常忽略，除非用户显示地指示链接器包含这些信息。 .rel.data：被模块引用或者定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都要被修改。 .debug：一个调试符号表，其条目时程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有以-g选项调用编译器驱动程序时，才会得到这张表。 .line：原始C程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译器驱动程序时，才会得到这张表。 .strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。 图4-3-3-2hello.o的节头表 4.4Hello.o的结果解析 我们将反汇编的结果输入到文件hello.asm中。 对比分析： 1.hello.s中是没有位置信息的，但是在hello.asm是有的，代码间是有顺序关系的。 图4-4-1hello.asm中代码是有位置信息的 图4-4-2hello.s中的代码是没有地址的 2.hello.asm中使用地址进行跳转，而hello.s中使用标号进行跳转 图4-4-3使用地址跳转 图4-4-4使用标号进行跳转 3.hello.asm中使用地址进行函数调用，而hello.s中使用函数名进行跳转 图4-4-5hello.asm中使用地址进行函数调用 图4-4-6hello.s中使用函数名进行函数调用 4.hello.asm中有重定位条目，而hello.s中没有 如图4-4-7中sleepsecs中的重定位格式是R_X86_64_PC32说明是PC相对的32位的地址，当前PC是main+64，减0x04后是main+60，正好是其应该填充的位置，在重定位后就会填充到这个位置。 重定位条目 图4-4-7重定位条目 图4-4-8hello.s中没有重定位条目 机器语言：就是机器可以直接识别执行的二进制代码，是我们人无法理解的语言，一般是由操作码和操作数构成的。比如call在机器语言中对应的编码就是e8，而操作数则是由是对应的编码的小端格式，如补码、IEEE754表示的浮点格式等等。 汇编语言：是人类为了方便编程，发明出来的和机器语言对应的编程语言，引入了助记符，帮助人们快速的对应复杂的二进制编码。 关系：汇编语言和机器语言基本上是一一对应的，每一条汇编语言实际上是一条机器语言的助记符形式。 4.5本章小结 本章我们把汇编语言源程序汇编成了可重定位的目标文件。分析了可重定位的目标文件的elf格式，elf头、节头表、符号表等等内容，理解了汇编后的二进制可重定位代码。知道了重定位条目的信息，当重定位形成可执行文件之后，就会在对应的位置填入相应的数据。 objdump工具可以帮助我们将可重定位的目标文件反汇编生成反汇编代码，进一步理解hello.o的内容。 （第4章1分） 第5章链接 5.1链接的概念与作用 概念： 链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存中并执行。链接可以执行于编译时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在早期的计算机系统中，链接甚至是手动执行的。在现代系统中，链接是由叫做链接器的程序自动执行的。 作用： 链接器在软件开发中扮演着一个关键的角色，因为他们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需要简单地重新编译它，并重新链接应用，而不是重新编译其他文件。 5.2在Ubuntu下链接的命令 链接命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5-2-1链接指令 图5-2-2链接后生成的可执行目标文件 5.3可执行目标文件hello的格式 hello的elf格式和可重定位的目标文件的elf格式相类似。 图5-3-1可执行文件的elf格式 其中可以很明显的发现在Type一栏变成了EXEC，即可执行的。 地址 大小 图5-3-2节头表 5.4hello的虚拟地址空间 首先用edb加载hello程序。 图5-4-1使用edb加载hello 查看符号 图5-4-2符号 可以发现，和图5-3-2中的一致，interp都在0x4002e0。其他的节都在这附近，可以直接在symbols中或者datadump中观察到。 或者可以直接输入对应节的起始地址，直接再Bootmarks中查看。 图5-4-3-1直接用bootmarks查看地址内容 图5-4-3-2不存在地址的节 可以发现，最后着5个节都没有地址，因为他们的内容已经在连接后直接加入到了二进制代码之中，不需要再次存储了，可执行程序已经可以正常执行了。 5.5链接的重定位过程分析 链接的过程： 1.符号解析 目标文件(.o)定义和引用了符号； 每个符号对应着一个函数、一个全局变量或一个静态变量等； 其中函数、已初始化的全局变量或者静态变量是强符号，未初始化的全局变量或者静态变量是弱符号； 其中有三条链接时的规则：1.不允许由多个同名的强符号；2.如果有一个强符号和多个弱符号同名，那么选择强符号；3.如果由多个弱符号同名，那么从这些弱符号中任意选择一个； 符号解析的作用就是给每个符号引用分配一个精确的符号定义； 2重定位 编译器和汇编器生成的代码段和数据段的开始地址都是0； 链接器给每个符号定义分配一个内存地址，然后修改所有对这些符号的引用使得这些引用指向的是前面分配的内存地址； 链接器使用由汇编器生成的详细的指令(重定位条目)来执行这些重定位操作； hello没有了hello.o重定位条目，因为所有的地方都已经确定了位置，而hello.o因为还没有链接，所以还保留有许多汇编器生成的重定位条目供之后的链接使用。链接的本质是合并不同文件的相同节，如数据节合并在一起，而代码节合并在一起。在这个过程中因为文件要使用其他文件中符号的定义，所以就需要用到在汇编过程中生成的.rel.data和.rel.text节中的重定位信息。 具体看到hello和hello.o的差别，我们通过hello反汇编生成的hello_exe.asm和hello.asm作比较来查看。 首先最明显的差别就是地址的长度不同，未链接的文件中只是简单的使用相对偏移量，而链接后的文件中则是使用虚拟地址空间中的地址。 图5-5-1hello.asm中使用相对偏移量来作为地址 图5-5-2hello_exe.asm中使用虚拟地址 其次，在主函数中调用的函数都不是定义子该文件中的，而是定义在库文件中的，所以未链接时在文件中找不到这些函数的定义，而链接后则可以找到。 图5-5-3在链接后可以在反汇编代码中找到调用函数的定义 最后我们用一个可重定位条目翻译的例子来看重定位的过程： 图5-5-4一个重定位条目的例子 我们在已链接的文件中找到对应的地方。 可以发现其绝对地址时404044，但是是使用的PC相对引用，当程序执行到401163时，PC的值时401169，在加上相对的偏移值0x2edb，即为绝对地址404044。 5.6hello的执行流程 通过命令行输入参数执行程序 图5-6-1用edb执行hello程序 不断地stepinto，可以看到执行过的程序名，如： 图5-6-2hello!_start 执行过程： ld-2.27.so!_dl_start0x7fce8cc38ea0 ld-2.27.so!_dl_init0x7fce8cc47630 hello!_start0x400500 libc-2.27.so!libc_start_main0x7fce8c867ab0 -libc-2.27.so!__cxa_atexit0x7fce8c889430 -libc-2.27.so!__libc_csu_init0x4005c0 hello!_init0x400488 libc-2.27.so!_setjmp0x7fce8c884c10 -libc-2.27.so!_sigsetjmp0x7fce8c884b70 –libc-2.27.so!__sigjmp_save0x7fce8c884bd0 hello!main0x400532 hello!puts@plt0x4004b0 hello!exit@plt0x4004e0 *hello!printf@plt– *hello!sleep@plt– *hello!getchar@plt– ld-2.27.so!_dl_runtime_resolve_xsave0x7fce8cc4e680 -ld-2.27.so!_dl_fixup0x7fce8cc46df0 –ld-2.27.so!_dl_lookup_symbol_x0x7fce8cc420b0 libc-2.27.so!exit0x7fce8c889128 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 图5-6-3edb中的执行结果 5.7Hello的动态链接分析 动态链接主要是书上7.10到7.12的内容。 书上的解释是这样的：假设程序调用一个有共享库定义的函数。编译器无法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法时为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。GNU通过一种叫做延迟绑定的技术来将地址的绑定推迟到第一次调用该过程。 动态链接器使用过程链接表PLT和全局偏移量表GOT实现函数的动态链接。其中GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。 通过反汇编我们可以知道GOT和PLT的位置 图5-7-1GOT和PLT的位置 GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]时动态链接器在ld-linux.so模块种的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT项目。 图5-7-2链接前的GOT 图5-7-3动态链接后的GOT 5.8本章小结 链接是现代编程思想的精华部分之一，链接器的出现，使得模块化的编程成为常态，分块编程，各自编译，最后链接是一个很自然的想法。同时，我们程序员也可以更好的使用库函数了。这得益于动态链接的出现，我们不用多次在文件中保存相同的代码，只需要用一个动态链接库，等到函数需要被调用时，再去取对应的代码就可以了。 而传统的静态链接有两个过程，首先是符号解析，需要重点知道强弱符号的规则，第二是重定位，需要知道解析引用的原则。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 狭义概念：进程是正在运行的程序的实例 广义概念：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 这其中有两点最为重要的需要我们深入把握和理解： 第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域、数据区域和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。 作用：当在现代系统上运行一个程序的时候，我们会得到一个假象，就好像我们的程序时系统种当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中地指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象是通过进程的概念提供给我们的。 进程的并发性让我们能够同时运行多个程序在电脑上，而且看起来是在独占CPU的；进程异步性让我们同时运行多个程序时是互不影响的；进程的信号机制能够让不同的进程之间产生联系，让进程之间实现通信……进程是计算机科学中最伟大的概念之一，有了进程，才有我们今天的高性能PC机。 6.2简述壳Shell-bash的作用与处理流程 概念：在计算机科学中，Shell俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（commandinterpreter，命令解析器）。它类似于DOS下的COMMAND.COM和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。 CSAPP上的解释就是：shell是一个交互型的应用级程序，它代表客户运行其他程序。 功能:Shell连接了用户和Linux内核，让用户能够更加高效、安全、低成本地使用Linux内核,能够接收用户输入的命令，并对命令进行处理，处理完毕后再将结果反馈给用户，比如输出到显示器、写入到文件等。 在Shell中输入的命令，有一部分是Shell本身自带的，这叫做内置命令；有一部分是其它的应用程序（一个程序就是一个命令），这叫做外部命令。 Shell本身支持的命令并不多，功能也有限，但是Shell可以调用其他的程序，每个程序就是一个命令，这使得Shell命令的数量可以无限扩展，其结果就是Shell的功能非常强大，完全能够胜任Linux的日常管理工作，如文本或字符串检索、文件的查找或创建、大规模软件的自动部署、更改系统设置、监控服务器性能、发送报警邮件、抓取网页内容、压缩文件等。 处理流程： 1．Shell首先从命令行中找出特殊字符（元字符），在将元字符翻译成间隔符号。元字符将命令行划分成小块tokens。Shell中的元字符如下所示： SPACE,TAB,NEWLINE,&,;,(,),<,>,| 2．程序块tokens被处理，检查看他们是否是shell中所引用到的关键字。 3．当程序块tokens被确定以后，shell根据aliases文件中的列表来检查命令的第一个单词。如果这个单词出现在aliases表中，执行替换操作并且处理过程回到第一步重新分割程序块tokens。 4．Shell对~符号进行替换。 5．Shell对所有前面带有$符号的变量进行替换。 6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用$(command)标记法。 7．Shell计算采用$(expression)标记的算术表达式。 8．Shell将命令字符串重新划分为新的块tokens。这次划分的依据是栏位分割符号，称为IFS。缺省的IFS变量包含有：SPACE,TAB和换行符号。 9．Shell执行通配符*?[]的替换。 10．shell把所有从处理的結果中用到的注释删除，並且按照下面的顺序实行命令的检查： A.内建的命令 B.shell函数（由用户自己定义的） C.可执行的脚本文件（需要寻找文件和PATH路径） 11．在执行前的最后一步是初始化所有的输入输出重定向。 12．最后，执行命令。 6.3Hello的fork进程创建过程 我们在终端输入./hello1190401018黄子扬，回车后即开始了这个过程 图6-3-1进程执行的命令 此时，bash首先搜索这是否是一个内置命令，发现不是后，进程开始在磁盘上搜索，找到hello程序后，将其调入内存。 接着bash实行fork()函数，创建一个子进程，此时，该子进程拥有和父进程完全相同的虚拟地址空间副本，即是相对于父进程是独立的。如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。同时父进程和子进程是共享文件的。父进程和子进程的区别在于他们的进程号不同，即PID不同。 父进程和子进程在各自的虚拟地址空间内独立并发的向前推进。 简要介绍fork函数： pid_tfork(void); fork函数调用一次，却会返回两次：一次是在父进程中，一次是在新创建的子进程中。在父进程中，fork返回子进程的PID。在子进程中，fork返回0。因为子进程的PID总是为非0，返回值就提供了一个明确的方法来分辨程序是在父进程还是在子进程中执行。 6.4Hello的execve过程 但是此时fork出来的子进程并没有达到要执行hello程序的目的，我们还要求换上下文，去执行hello程序。 简要介绍execve函数： intexecve(constchar*filename,constchar*argv[],constchar*envp[]); 如果成功，则不返回，如果失败，则返-1。 execve函数加载并运行可执行目标文件filename，即hello程序，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。 其中的参数列表：argv变量指向指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv[0]是可执行目标文件的名字。环境变量列表类似于参数列表，envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如“name=value”的名字-值对。 bash得到的子程序会去执行execve函数，去加载hello程序，它会首先调用启动代码，启动代码设置栈，并将控制传递给新程序的主函数，该主函数具有如下形式的原型： intmain(intargc,char**argv,char**envp); 当main开始执行时，用户栈的组织结构从栈底往栈顶依次是这样的：首先是参数和环境字符串，栈往上紧随其后的是以null结尾的指针数组，其中每个指针都指向栈中的一个环境变量字符串，全局变量environ指向这些指针中的第一个envp[0]。紧随环境变量数组之后的是以null结尾的argv[]数组，其中每个元素都指向栈中的一个参数字符串。在栈的顶部是系统启动函数libc_start_main的栈帧，接下来就是main函数执行后的即未来的栈帧了。 6.5Hello的进程执行 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。 进程时间片的概念：时间片（timeslice）又称为“量子（quantum）”或“处理器片（processorslice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。现代操作系统（如：Windows、Linux、MacOSX等）允许同时运行多个进程 例如，你可以在打开音乐播放器听音乐的同时用浏览器浏览网页并下载文件。事实上，虽然一台计算机通常可能有多个CPU，但是同一个CPU永远不可能真正地同时运行多个任务。在只考虑一个CPU的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在Linux上为5ms－800ms），用户不会感觉到。 进程调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度，是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进城后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。 图6-5-1进程调度图示 hello程序一开始是运行在usercode中的，所以是不能执行kernel里的代码的，只能通过异常的方式，使其改变为内核模式，执行异常处理程序中的系统调用代码，即sleep函数。等待执行完后，又再依次切换到用户模式执行hello程序。 进程之间的上下文切换是在kernel里完成的，完成后，又退出内核模式，进入到用户模式，去执行切换后的进程，这就是调度的原理。 6.6hello的异常与信号处理 hello出现的异常：中断，陷阱（即系统调用） hello产生的信号：SIGINT、SIGTSTP、SIGCONT、SIGCHLD 我们首先先执行hello程序，并在执行了一会后输入Ctrl+C，直接终止它。进程会收到一个SIGINT信号。 图6-6-1进程收到SIGINT信号后终止 接着我们再次运行，用Ctrl+Z暂停进程。并且用ps命令查看进程，可以发现hello进程仍然存在。 图6-6-2进程收到SIGTSTP信号后停止 还可以使用jobs进行观察。 图6-6-3用jobs观察作业 用pstree观察进程树，我们可以在终端部分找到bash和hello进程。其中hello和pstree都是bash的子进程 可以看到hello进程是bash的子进程 图6-6-4进程树 我们使用kill指令为其传入一个SIGCONT信号，让它继续执行下去。 图6-6-5传入SGICONT信号让进程继续执行 我们使用kill指令为其传入一个SIGKILL信号杀死hello程序。 图6-6-6传入SIGKILL信号将进程杀死 6.7本章小结 进程是现代计算机科学最伟大的概念之一，它让计算机有了并发执行多个程序的能力，大大提高了计算机的性能。我们通过这章的学习，了解到了进程的基本概念、运行原理、进程的用户模式和内核模式、上下文切换、两个重要函数（fork和execve）、四大异常（终端、陷阱、故障、终止）、进程的并发执行等等。 通过这章的学习也让我们对操作系统有了基本的认识，只有有了操作系统，我们才能够控制冷冰冰的硬件来为我们工作。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 7.1.1逻辑地址 CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址（偏移地址），不和绝对物理地址相干。 7.1.2线性地址 CPU在保护模式下，“段基址+段内偏移地址”叫做线性地址，注意，保护模式下段基址寄存器中存储的不是真正的段基值（和实模式的含义不一样），而是被称为“段选择子”的东西，通过段选择子在GDT（全局描述表）中找到真正的段基值。另外，如果CPU在保护模式下没有开启分页功能，则线性地址就被当做最终的物理地址来用，若开启了分页功能，则线性地址就叫虚拟地址（在没开启分页功能的情况下线性地址和虚拟地址就是一回事）。但是，如果开启分页功能，虚拟地址（或线性地址）还要通过页部件电路转换成最终的物理地址。 7.1.3虚拟地址 虚拟地址并不真实存在于计算机中。每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间。理论上，虚拟空间受物理内存大小的限制，如给有4GB内存，那么虚拟地址空间的地址范围就应该是0x00000000~0xFFFFFFFF。每个进程都有自己独立的虚拟地址空间。这样每个进程都能访问自己的地址空间，这样做到了有效的隔离。 7.1.4物理地址 物理地址就是内存单元的绝对地址，比如你有一个4G的内存条插在电脑上，物理地址0x0000就表示内存条的第一个存储单元，0x0010就表示内存条的第17个存储单元，不管CPU内部怎么处理地址，最终访问的都是物理地址。在CPU实模式下“段基址+段内偏移地址”就是物理地址，CPU可以使用此地址直接访问内存。 7.1.5hello的地址空间 hello程序主要使用的就是从虚拟地址到物理地址变换的这一套机制，来实现其虚拟地址空间的独立化，但是同时又能精确的映射到对应的物理空间，使其和其他的程序的地址空间隔离。 7.2Intel逻辑地址到线性地址的变换-段式管理 在段式存储管理中，将程序的地址空间划分为若干个段(segment)，这样每个进程有一个二维的地址空间。在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在段式存储管理系统中，则为每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。 程序加载时，操作系统为所有段分配其所需内存，这些段不必连续，物理内存的管理采用动态分区的管理方法。在为某个段分配物理内存时，可以采用首先适配法、下次适配法、最佳适配法等方法。在回收某个段所占用的空间时，要注意将收回的空间与其相邻的空间合并。段式存储管理也需要硬件支持，实现逻辑地址到物理地址的映射。 程序通过分段划分为多个模块，如代码段、数据段、共享段：可以分别编写和编译；可以针对不同类型的段采取不同的保护；可以按段为单位来进行共享，包括通过动态链接进行代码共享。这样做的优点是：可以分别编写和编译源程序的一个文件，并且可以针对不同类型的段采取不同的保护，也可以按段为单位来进行共享。 总的来说，段式存储管理的优点是：没有内碎片，外碎片可以通过内存紧缩来消除；便于实现内存共享。缺点与页式存储管理的缺点相同，进程必须全部装入内存。 图7-2-1段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(pageframe)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。 在页式系统中进程建立时，操作系统为进程中所有的页分配页框。当进程撤销时收回所有分配给它的页框。在程序的运行期间，如果允许进程动态地申请空间，操作系统还要为进程申请的空间分配物理页框。操作系统为了完成这些功能，必须记录系统内存中实际的页框使用情况。操作系统还要在进程切换时，正确地切换两个不同的进程地址空间到物理内存空间的映射。这就要求操作系统要记录每个进程页表的相关信息。 图7-3-1页式管理 7.4TLB与四级页表支持下的VA到PA的变换 首先在TLB中查找PTE，若能直接找到则直接得到对应的PPN，具体的操作是将VPN看作TLBI和TLBT，前者是组号，后者是标记，根据TLBI去对应的组找，如果TLBT能够对应的话，则能够直接得到PTE，进而得到PPN。 图7-4-1从TLB寻找PTE 其中若是在TLB中找不到对应的条目，则应去多级页表中查找，VPN被分为了四块。有一个叫做CR3的寄存器包含L1页表的物理地址，VPN1提供到了一个L1PET的偏移量，这个PTE包含L2页表的基地址，VPN2提供到一个L2PTE的偏移量。依次类推，最终找到页表中的PTE，得到PPN。 图7-4-2四级页表的查询 而VPO和PPO相等，最终的PA等于PPN+PPO。 7.5三级Cache支持下的物理内存访问 PA又被分为了CT、CI、CO分别是标志位、组号和偏移量。首先我们根据组号在L1cache中找到对应的组，然后挨个比较标志位，如果标志位对应且有效位为1，则说明发生了hit，然后根据CO偏移量得到我们想要取的数据就可以了。如果发生了miss，则依次到L2cache、L3cache、主存中去找。 图7-5-1三级cache的示意图 具体的翻译过程： CT即相当于t，CI即相当于s，CO即相当于b。根据cache的工作机制，即先到对应的组去找，然后一一匹配t，检查v，最终若找到则根据b取数据，若没有找到则到更低级的存储中去取数据。 图7-5-2cache的具体翻译过程 7.6hello进程fork时的内存映射 内核为hello程序维护一个单独的任务结构（源代码中的task_struct）。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（例如，PID、指向用用户栈的指针、可执行目标文件的名字、PC）。 图7-6-1hello如何组织虚拟内存 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork从新进程返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的概念。 7.7hello进程execve时的内存映射 加载hello并执行需要以下几个步骤： 1.删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构（即mmap指向的vm_area_structs）。 2.映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域时请求二进制0的，映射到匿名文件，其大小包括在hello中。栈和堆区域也是请求二进制0的，初始长度为0. 3.映射共享区域。如果hello程序域共享对象链接，比如C标准库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC）。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 图7-7-1加载器映射用户地址空间的区域 7.8缺页故障与缺页中断处理 若MMU在翻译一个虚拟地址A时，触发了一个却页。这个却页将导致控制转移到内核的却页处理程序。却页处理程序会执行以下的步骤： 1.搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止进程。 2.检查这个却页是否为一条试图对这个代码段里的只读页面进行写操作的存储指令造成的，或者是否为一个运行在用户模式中的进程试图从内核虚拟内存中读取数据字造成的。如果试图进行的访问时不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。 3.若上面两条都不是触发缺页的理由，则此时内核知道了这个缺页是由于对合法的的虚拟地址进行合法的操作造成的。内核会选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU，此时，MMU就能正常的翻译A了。 图7-8-1缺页处理 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，指向堆的顶部。 分配器有两种风格，但是这两种风格都要求应用显示的分配块。 其中显示分配器要求显示释放任何已分配的块，如malloc、new等。 隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。所以也叫垃圾收集器。 显示分配器有以下几点要求：能够处理任意请求序列；立即相应请求；只是用堆；对齐开；不修改已分配的块。 在性能上有两点追求： 1.最大化吞吐率； 2.最大化内存利用率； 但是这两点通常是对立的。 具体的技术有以下几种： 隐式空闲列表 块大小（最低位保存a/f）有效载荷（只包括已分配的块）填充（可选，为了保持双字对齐）块大小（最低位保存a/f） 显示空闲列表 图7-9-1显示空闲列表图示 7.10本章小结 本章是理解计算机系统存储的重中之重，从内存的分页式管理，到三级cache的高层内存管理，再到一个程序内部的堆的管理。其中的思想十分复杂，却又十分精妙，不得不让人感叹前人的智慧。 正是有了这么多从上到下分层的内存管理机制，计算机系统才能有条不紊、并且快速的运行程序。CPU首先发出指令要取某个数据，然后MMU首先去查TLB，如果没有得到就通过4级页表，查找物理地址，得到物理地址后，又通过三级cache，不断的从上到下去寻找我们要的数据，最不济得到磁盘上去读数据，那会造成巨大的时间开销。而如果我们在程序执行的时候需要动态的申请堆空间的话，就需要用到动态分配器了，一般在C语言中使用的是malloc和free的组合。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：所有的IO设备（例如网络、磁盘、终端）都被模型化为文件。每个linux文件都有一个类型来表明他在系统中的角色： 普通文件：包含任意数据。 目录：包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。每个目录至少含有两个条目：“.”是到该目录自身的链接，以及“…”是到目录层次结构中父目录的链接。 套接字：用来与另一个进程进行跨网络通信的文件。 图8-1-1linux文件组织结构模型 设备管理：IO是在主存和外部设备之间复制数据的过程。输入操作是从IO设备复制数据到主存，而输出操作时从主存复制数据到IO设备。所有的IO色号被被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行： 1.打开文件。内核返回一个小的非负整数，叫做描述符，用于标识文件。 2.stdin的描述符为0，stdout的描述符为1，stderr的描述符为2。 3.改变当前文件的位置：用seek操作。 4.读写文件：读时从文件到内存，写时从内存到文件。 5.关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为相应，内核释放文件打开时创建的数据结构，并将它使用的文件描述符恢复到可以使用的描述符池中去。 8.2简述UnixIO接口及其函数 8.2.1打开和关闭文件 intopen(char*filename,intflags,mode_tmode); 若打开文件成功则返回文件描述符，否则返回-1。 flags有多种O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（可读可写）、O_CREAT（如果文件不存在，就创建它的一个截断的空文件）、O_TRUNC（如果文件已经存在，就截断它）、O_APPEND（在每次写操作前，设置文件位置到文件的结尾处）。 mode参数指定访问权限位。 图8-2-1访问权限位 intclose(intfd); 会关闭一个打开的文件，如果关闭一个已关闭的文件描述符会出错。 8.2.2读和写文件 ssize_tread(intfd,void*buf,size_tn); 若成功则返回读的字节数，若EOF则为0，若出错则为-1。 ssize_twrite(intfd,constvoid*buf,size_tn); 若成功则返回为写的字符数，若出错则返回-1。 read函数从描述符为fd的当前位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。可以通过调用lseek函数，显示地修改当前文件的位置。 8.3printf的实现分析 printf的函数体如下： intprintf(constchar*fmt,…){inti;charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4);i=vsprintf(buf,fmt,arg);write(buf,i); returni;} va_listarg=(va_list)((char*)(&fmt)+4);是在找第一个参数，其中va_list是一个字符指针。 下面，则执行vsprintf，以下是vsprintf的函数体： intvsprintf(char*buf,constchar*fmt,va_listargs) { char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!=‘%’){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case‘x’: itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case‘s’: break; default: break; } } return(p-buf); } 这个函数返回的是要打印的字符串的长度。 接下来要调用write函数，我们反汇编追踪一下： write:moveax,_NR_writemovebx,[esp+4]movecx,[esp+8]intINT_VECTOR_SYS_CALL 我们可以找到INT_VECTOR_SYS_CALL的实现： init_idt_desc(INT_VECTOR_SYS_CALL,DA_386IGate,sys_call,PRIVILEGE_USER); 可以发现它是要调用sys_call这个函数： sys_call:callsavepushdword[p_proc_ready]stipushecxpushebxcall[sys_call_table+eax*4]addesp,4*3mov[esi+EAXREG-P_STACKBASE],eaxcliret 接着执行字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 最后显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar()是stdio.h中的库函数，它的作用是从stdin流中读入一个字符，也就是说，如果stdin有数据的话不用输入它就可以直接读取了，第一次调用getchar()时，确实需要人工的输入，但是如果你输了多个字符，以后的getchar()再执行时就会直接从缓冲区中读取了。 下面是它的函数实现： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(–n>=0)?(unsignedchar)*bb++:EOF; } 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章简要总结了unixI/O的有关知识，通过对外部设备的模型化实现简单、贯通的读写操作，将所有的IO设备看作文件，通过简单的几个系统函数的组合就完成了各种的读写操作。同时还提供了一种树结构的文件管理模式，并且把目录也抽象为了一种文件。 需要我们重点在编程中掌握read、write、lseek、open、close等基本函数，深入理解内部机制，做到安全的对文件进行读写。 （第8章1分） 结论 hello程序的从诞生到结束要经历很多个过程。它的一生是无数人类计算机科学家智慧的结晶，也是现代信息文明高度发达的果实。 其中第一个，也是完全面向我们程序员的过程，就是用我们的双手一个字母一个字母的将程序敲入电脑中的编辑器里。或许是因为所处的时代高度发达，我们这一代的程序员不用再去考虑许许多多额外的复杂的东西，各种花里胡哨的编辑器层出不穷，更有集成开发环境（IDE）降维打击。我最常用的编辑器有notepad++、sublimeText、vscode，其中vscode背靠微软，功能最为强大，插件生态最为完善，全世界的程序员都在使用这样一款工具。当我们按下键盘，将这样几行字母敲进机器中，一个高级语言（C）源程序就这样诞生了，如图1-1。 图9-1-1hello.c源程序 接着，我们将这个文件保存在了磁盘上，我们终于有了hello.c这个文件。 图9-1-2hello.c源文件 此时虽然我们已经有了源文件，但是它是它，电脑是电脑，谁也不认识谁，要想让它在电脑上执行，我们必须把这个文件中的语句翻译成机器能够认识的语句，这个时候我们的编译工具gcc就登场了。从高级语言到源程序到可执行文件中间需要经历五个步骤： 预处理： 图9-1-3预处理指令 图9-1-4预处理生成的.i文件 编译： 图9-1-5编译指令 图9-1-6编译生成的.s文件 汇编： 图9-1-7汇编指令 图9-1-8汇编生成的.o文件 链接： 图9-1-9-1链接指令1 图9-1-9-2链接指令2 图9-1-10链接生成的可执行文件hello 在经历了如此繁杂的过程后，我们终于得到了我们想要的可执行文件hello，打开终端（terminal），输入执行的命令和命令行参数，我们终于得到了我们预期的实验结果： 图9-1-11hello程序的执行效果 这样看起来简单但是十分伟大的现象终于出现在了我们的眼前。从程序执行开始到完全消失又是一个十分繁杂的过程： 首先，我们打开了终端，运行着一个名为bashshell的程序，接着，我们欲运行一个我们自己写的程序hello，操作系统为我们fork了一个子进程，此时这个子进程（childprocess）拥有着自己独立的进程号（pid），它拥有着于父进程（parentprocess）完全一样但是又独立的虚拟地址空间，并且继承了父进程打开的所有文件的描述符，这就意味着可以往父进程打开的文件中读写数据。 然后，操作系统使用execve，在当前子进程的上下文中加载并运行hello程序。 一个程序的执行不可只能只依赖软件，本质上所有软件的运行都是依赖硬件的。流水线的设计，使得指令的执行速度大大提高，取值、译码、执行、访存、写回、更新PC，不同指令的6大阶段可以重叠执行（无冒险情况下），大大提高了程序的运行速度。 为了更高效的利用存储单元，我们根据存储单元的存取速度和单位造价对存储单元进行了分级，从最顶层的cpu、cache逐渐往下，分别是：主存（DRAM）、本地二级存储（本地磁盘）、远程二级存储（分布式文件系统、网络服务器）等。其中，每一级存储作为下一级存储的缓存，cpu会优先从更高级的存储中去找数据和指令，当找不到时，才会从更低级的存储中去不断地加载到更加高级地存储。 一个程序地上下文（context）是如此地难以管理，操作系统是通过虚拟内存地概念来解决了这个问题，是的每一个独立的程序看上去好像都是独立的占有cpu一样。操作系统通过mmu计算虚拟地址（virtualaddress）和物理地址（physicaladdress）的关系，得到物理地址后，进而又按照从cache到主存再到磁盘的顺序查找想要的数据。这其中，为了加速地址计算和查找的过程，又引入了TLB和页表的概念，读一次磁盘的代价是十分巨大的，因此每次读都需要读很大一块，我们称之为页，数据是按页从磁盘读取读取到主存上的，通常的页的大小是4K。 那么屏幕作为一个外部文件是如何与hello程序产生联系的呢。Linux操作系统会把所有的外部IO设备模型化为一个文件，这样，我们对一个设备的IO操作就模型化为了对一个文件进行的IO操作，我们可以从文件中读，也可以向文件中写。而这个hello程序正是向标准输出流 屏幕上，写出了一系列字符串，在程序的结尾又使用getchar函数从标准输入流 键盘读入了一个字符。 进程的执行还受信号的影响，如我们人为的在终端输入CTRL+C，就可以向所有前台进程发送一个SIGINT信号，终止进程的执行。 图9-1-12子进程收到SIGINT信号后终止 但是进程终止后，并不会立即从这个世界上小时，它仍然会以僵死进程的形式存在在系统中，占用着资源。当父进程将其回收后，它才会从系统中彻底消失。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 附件1hello.c 作用：高级语言源程序 附件2hello.i 作用：预处理生成的.i文件 附件3hello.s 作用：编译生成的.s文件（汇编语言文件） 附件4hello.o 作用：汇编生成的.o文件（可重定位的目标文件） 附件5hello.elf 作用：hello.o的elf格式，用于展示可重定位的elf文件格式 附件6hello.asm 作用：hello.o的反汇编格式，用汇编语言的格式来观察可重定位的目标文件 附件7hello 作用：链接生成的可执行的目标文件 附件8hello_exe.elf 作用：hello的elf格式，用于展示可执行的elf文件格式 附件9hello_exe.asm 作用：hello的反汇编格式，用汇编语言的格式来观察可执行的目标文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1]CSAPP3ed [2]https://blog.csdn.net/xiaosaizi/article/details/105669070 [3]https://blog.csdn.net/huoyahuoya/article/details/53083424 [4]https://www.cnblogs.com/mlgjb/p/8241718.html [5]https://blog.csdn.net/mzjmzjmzjmzj/article/details/84713351?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162393596716780265440699%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162393596716780265440699&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-84713351.first_rank_v2_pc_rank_v29&utm_term=%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80&spm=1018.2226.3001.4187 [6]https://blog.csdn.net/fuzhongmin05/article/details/58061584 [7]https://www.cnblogs.com/pianist/p/3315801.html （参考文献0分，缺失-1分） 
第536篇文章[3]
第21次CCF计算机软件能力认证CSP-202009-2-风险人群筛查（详细注释版） #include<iostream> usingnamespacestd; typedefstructcoordinate//定义坐标类型，处理更加方便 { intx,y; }coordinate; intmain(void) { intn,k,t,xl,yd,xr,yu;//按题目中要求命名一致，思路更清晰 cin>>n>>k>>t>>xl>>yd>>xr>>yu;//第一行输入 coordinatepos[n][t];//坐标，用矩阵n*t矩阵存储总的位置信息 for(inti=0;i<n;i++) { for(intj=0;j<t;j++) { cin>>pos[i][j].x>>pos[i][j].y; } } intpass=0;//经过人数 intstay=0;//逗留人数 for(inti=0;i<n;i++) { inttemp=0;//temp用于记录连续多少个节点经过危险区域 boolflag=false;//标志变量标志是否经过危险区域 for(intj=0;j<t;j++) { if(pos[i][j].x>=xl&&pos[i][j].x<=xr&&pos[i][j].y>=yd&&pos[i][j].y<=yu) { flag=true; temp++; if(temp>=k)//当连续的经过点数量达到k时直接跳出循环 break; } else { temp=0; } } if(!flag); elseif(flag&&temp<k)pass++;//只经过不逗留 else//逗留一定经过 { pass++; stay++; } } cout<<pass<<'\n'<<stay; return0; } 
第537篇文章[3]
第20次CCF计算机软件能力认证CSP-202006-1-线性分类器 #include<iostream> usingnamespacestd; typedefstructnode { intx,y; chartype; }coordinate; intmain(void) { intn,m; cin>>n>>m; coordinatepoint[n]; for(inti=0;i<n;i++) { cin>>point[i].x>>point[i].y>>point[i].type; } inttheta0[m],theta1[m],theta2[m]; for(inti=0;i<m;i++) { cin>>theta0[i]>>theta1[i]>>theta2[i]; } for(inti=0;i<m;i++) { boolflag=(theta0[i]+(theta1[i]*point[0].x)+(theta2[i]*point[0].y))>0; booltemp=true; for(intj=1;j<n;j++) { if(point[j].type==point[0].type) { if(((theta0[i]+(theta1[i]*point[j].x)+(theta2[i]*point[j].y))>0)==flag) continue; else{ temp=false; break; } } else { if(((theta0[i]+(theta1[i]*point[j].x)+(theta2[i]*point[j].y))>0)!=flag) continue; else { temp=false; break; } } } if(temp)cout<<"Yes"<<endl; elsecout<<"No"<<endl; } return0; } 
第538篇文章[]
停车场管理系统-----软件构造习题课代码分析 题目描述： 软件框架： ADT设计： 静态工厂方法 /** *创建一个新的停车场 * *@paramnos各停车位的编号，均为自然数，且无重复 *@paramwidths各停车位的宽度，包含的元素数量=nos中元素数量且>=5 *@return一个停车场对象，包含了widths.length个车位，各车位的宽度与nos中相应数字一致，且各车位上均未有停车 *@throws如果违反nos和widths不合法 */ publicstaticParkingFieldcreate(int[]nos,int[]widths)throwsException{ returnnewConcreteParkingField(nos,widths); } 创建一个新的停车场。 停车： /** *在某个停车位上停车 *车牌号为plate的车辆，之前没停在车场，执行后停在了车位号为num的车位上，该车位宽度大于车宽度 *其他车位的状态不变 * *@paramplate要停进来的车辆车牌号，notnull *@paramwidth车的宽度，自然数 *@paramnum指定的停车位编号，自然数 *@throws如果plate车已经停在该停车场，或者num车位已被其他车占用，或者num车位宽度不超过width，或者num并不是合法车位 */ publicvoidparking(Stringtype,Stringplate,intwidth,intnum,String[]extraRegistrationInfo)throwsException; 驶离停车场： /** *将汽车驶离停车场，plate车原来占用的车位空出来了，计算出本次停车的费用（半小时10元，不足半小时按半小时计算） * *@paramplate待驶离的车辆，notnull *@return本次停车的费用（精确计算得到） *@throwsplate车并没有停在本车场 */ publicdoubledepart(Stringplate)throwsException; 停车场状态: /** *返回当前停车场每个车位的状态（空，或被某车占用） * *@returnKey为停车位的编号，Value为该车位上的车辆车牌号。如果停车位上无车辆，则对应的Value为“” */ publicMap<Integer,String>status(); 以上是核心方法，其他辅助性的方法不再说明。方法的实现都十分简单，并不是软件构造课的主要内容，故对其逻辑不一一说明。 面向复用的设计： 相机场等，本质上和停车场的功能完全一样，所以我们设计的ADT如果有很好的复用性的话，只需经过少量的扩展，就可以实现一个更加复杂的场景下的类。 我们首先将Car扩展成Parkable，即停放的东西不止可以是车，还可以是飞机、摩托车等。针对Parkable，设计一组方法来描述其行为。 publicinterfaceParkable{ publicintgetWidth(); publicStringgetPlate(); publicdoublegetPricingUnit(); publicdoublegetPrice(); publicStategetState(); publicvoidsetState(Statestate); publicstaticParkablecreate(Stringtype,Stringplate,intwidth,String[]extraRegistrationInfo)throwsException{ returnnewParkableFactory().create(type,plate,width,extraRegistrationInfo); } } 为了避免在客户端代码使用new操作，我们使用静态工厂方法来代替new操作。 publicstaticParkablecreate(Stringtype,Stringplate,intwidth,String[]extraRegistrationInfo)throwsException{ returnnewParkableFactory().create(type,plate,width,extraRegistrationInfo); } 接着，针对各种交通工具进行方法的实现。 如，Car类： publicclassCarextendsConcreteParkable{ privatefinalDriverRegistrationdr=newDriverRegistration(); publicCar(Stringplate,intwidth){ super(plate,width); pricingUnit=30; price=10; } publicvoidregisterDriver(Stringname){ dr.registerDriver(name); } publicStringgetDriverInfo(){ returndr.getDriverInfo(); } @Override publicStringtoString(){ return"Car"+super.toString(); } } 工厂方法： 针对不同的类，提供工厂方法来创建实例对象，将对象类型作为一个参数，定义到工厂方法中去，Stringtype，这样，在每次创建时根据不同的类型来创建不同类型的实例。 publicParkablecreate(Stringtype,Stringplate,intwidth,String[]extraRegistrationInfo)throwsException{ if(type.equals("car")){ Carc=newCar(plate,width); c.registerDriver(extraRegistrationInfo[0]); returnc; }elseif(type.equals("motor")){ Motorm=newMotor(plate,width); m.registerDriver(extraRegistrationInfo[0]); returnm; }elseif(type.equals("plane")){ Planep=newPlane(plate,width); Calendarc=Calendar.getInstance(); //根据extraRegistrationInfo[1]字符串设置c的值 p.registerAirport(extraRegistrationInfo[0],c); returnp; } else thrownewException("Illegaltype"); } State设计模式： 创建State接口，实现两个状态，一种是停着（parking)，一种是在路上（depart）让Parkable拥有一个属性State，能够管理自己的状态。 Decorator设计模式： 建立一个用于装饰的基础类ComplexParkingField，实现ParkingField接口，其中的所有方法都delegate到未装饰之前的对象。然后，建立一个具体装饰类ParkingFieldWithCompany，也实现ParkingField接口，继承自ComplexParkingField类，增加了rep（公司信息），对需要变化的方法进行扩展（使用super.xxx()调用基础功能）。修改构造函数，增加company参数。 privateStringcompany; privatevoidcheckRep(){ assertcompany!=null&&company.length()>0; } publicParkingFieldWithCompany(ParkingFieldpf,Stringcompany){ super(pf); this.company=company; checkRep(); } @Override publicvoidparking(Stringtype,Stringplate,intwidth,intnum,String[]extraRegistrationInfo) throwsException{ super.parking(type,plate,width,num,extraRegistrationInfo); System.out.println("-------"+plate+","+this.company+"welcometoparking"); } visitor设计模式： 扩展其他功能：考虑将来对ParkingField的功能扩展。例如要扩展的一个功能是统计停车场当前时刻占用比例(=已停车的车位数量总车位数)。建立visitor接口ParkingVisitor，只有一个方法doublevisit(parkingFieldpf)。建立其子类PercentageVisitor，实现该visit方法，调用pf的方法获得pf的内部表示，进行计算。在ParkingField接口中增加accept(ParkingVisitorpv)方法，其实现很简单：pv.visit(this)。 publicinterfaceParkingVisitor{ publicdoublevisit(ParkingFieldpf); } 如果还有其他功能，可以继续定义visitor进行扩展。 
第539篇文章[3]
CCF计算机软件能力认证考试CSP-202006-2稀疏向量 #include<iostream> usingnamespacestd; #include<map> typedefstructnode { intindex; intvalue; }node; intmain(void) { intn,a,b; longlongintsum=0;//大数用longlongint，要不然会溢出 cin>>n>>a>>b; map<int,int>v1; for(inti=0;i<a;i++) { nodetemp; cin>>temp.index>>temp.value; v1[temp.index]=temp.value; } for(inti=0;i<b;i++) { nodetemp; cin>>temp.index>>temp.value; if(v1[temp.index]!=0) sum+=v1[temp.index]*temp.value; } cout<<sum; return0; } //必须用map动态创建键值对，要不然空间太大，内存不够 //也不能两个向量暴力匹配，时间复杂度太高，时间过不去 
第540篇文章[]
HIT软件构造---Git工具使用遇见的问题 HIT软件构造--------Git工具使用小记 目录 ==HIT软件构造==--------Git工具使用小记==校园网==登录不上github==git==常见指令（只列平常用的多的，其他建帮助手册）记录一些在使用git时遇见的==奇怪问题== 校园网登录不上github 只能说太离谱了，不翻墙登不上github，被针对了？ git常见指令（只列平常用的多的，其他建帮助手册） 1.gitinit:初始化一个本地git仓库2.gitclone[url]:将[url]处的远程仓库拷贝到本地3.gitadd*:将当前文件下的所有文件（*代表所有文件）提交到暂存区4.gitcommit-m"":提交暂存区的文件到本地仓库""内记录一些本次提交的信息5.gitpushoriginmaster:master:这个指令更一般化的形式是gitpush远程主机名远程分支名本地分支名，可以将本地仓库的文件提交到远程仓库（github、gitee等）6.gitfetch:将远程仓库的某分支拉取到本地仓库7.gitmerge：合并分支8.gitpull：相当于gitfetch+gitmerge：将远程仓库直接拉取并和本地仓库合并 记录一些在使用git时遇见的奇怪问题 1.fetch、pull、push、clone时遇到Failedtoconnecttogithub.comport443:Timedout的错误而且还时有时没有的，把人整蒙了。 在翻墙时会自动打开使用代理服务器这一项，导致连接不到github的端口，所以我们把这一项取消，并选中上面的自动检测。 如图所示，这样就不会出现timeout的错误了。 2.main和master的问题以往github默认分支名字时master，但是到2020年之后github官方将默认名字改为了main。但是老师明确说明要将代码提交到master分支，所以我们要建立一个master分支，再将其提交上去。 
第541篇文章[]
Java正则表达式的使用 写在前面 学过形式语言与自动机的小伙伴对regex应该都不陌生了，我们简单的回顾几个离散中的概念， ( a ) ∗ (a)^{*} (a)∗代表的是克林闭包，代表a可以重复 ( 0 , ∞ ) (0,\infty) (0,∞)次，而 ( a ) + (a)^{+} (a)+代表正闭包，说明a最少出现一次。 Java中regex的应用 如果想匹配一段特定的串，直接输入即可数字：\d或者[0-9]字母：\w或者[a-zA-Z]空白：\s重复0次以上：*重复1次以上：+0次或1次：？其他都用处不大，可以大概找手册看一遍，知道有那些东西，用的时候再去查就可以。Attention：在java正则表达式中\代表反斜杠，所以转义字符前的那个斜杠要输入\才行，也就是说如果我们要去比配数字，我们要使用\\d+，而不是\d+ 实际用法 字符串本身就有一个matches方法 我们随意选举一个字符串对象实验，可以发现matches方法返回的是一个Boolean值，如果能够匹配给出的regex就返回true，这就是最简单也是最实用的方法了。 更加复杂的用法 前面的matches方法已经非常使用了，但是有时候我们需要从大型的文本中去匹配一些对象，此时matches方法就不好使了，所以我们需要结合java提供的Pattern和Matcher类来对文本进行读取。 我们首先使用文本读取的方法将字符串读入到一个字符串对象中。现生成一个Pattern对象，注意，这个对象只能由工厂方法创建即: Patternregex=Pattern.compile() 然后再括号内输入你想要的正则表达式即可。接下来创建一个matcher对象，matcher对象的创建是根据之前我们已经创建的Pattern对象直接创建的：其参数是我们想要匹配的文本，即我们之前从文本文件中读取的字符串，我们将其输入在括号中即可。 接下来主要有三个方法： matches：只有整个字符串都符合regex，才返回truelookingAt：从串的最前面开始匹配，有能够匹配的上的，就返回truefind：只要整个串中有匹配的地方，就返回true当我们用以上三个方法找到对应的匹配时，用**m.group()**方法就可以得到匹配的字符串啦。这就是regex最简单的应用了。 
第542篇文章[]
EclEmma的安装与使用----HIT软件构造 EclEmma EclEmma是一个软件测试工具，可以查看代码的调用情况，也可以检查测试用例代码执行的覆盖率。直接打开Eclipse，在商店里面搜索安装。安装好后左上角有一个coverage按钮。运行即可：这是其中一段代码的示例，绿色说明覆盖的比较好，黄色差一等，红色最差。可以在弹出来的coverage栏查看覆盖率。 
第543篇文章[]
HIT软件构造----保姆级Gradle安装教程（10分钟入门） Gradle安装教程 官网：https://gradle.org/ 首先安装Gradle，我们打开官网，点击installgradle在prerequisites中发现，需要jdk在1.8以上（现在也没人用老版本了把哈哈）下面一堆英文，不想看的同学光看楼主所说的就可以了：翻到下面，点击这个蓝色Download随便选一个版本，然后点击binary-only，将这个zip文件随便下载到任何一个地方：然后将它解压： 完全不用像官网说的放在c盘，随便放哪都行，但是要记住它。接着我们添加环境变量：这个过程有过开发经验的同学应该都很熟悉把，具体的就是右键此电脑–》属性–》高级系统设置–》环境变量–》在系统变量中找到Path：点击编辑，新建，浏览，找到刚才解压的地方：选择Gradle目录下的gradle-7.0.2目录下的bin，添加即可。 接下来打开cmd，输入gradle-v进行验证，出现以上信息说明你的安装大功告成啦！ 如上图，可以直接在eclipse和idea中安装插件，楼主使用的是eclipse，所以我们点击eclipse。进入到下面这个网址：https://www.vogella.com/tutorials/EclipseGradle/article.html根据介绍我们可以知道，最简单的方法就是进入eclipse，然后在商店里下载即可。工具栏中点Help，然后选最下面的EclipseMarketplace。搜索BuildshipGradle，安装即可。如果是新建一个Gradle工程的话，直接在新建工程的地方创建即可：File–>new–>other 然后选择Gradle即可：由于楼主的工程是已经创建好了，所以需要用另一种方式来添加Gradle配置： 在工程名处右键单击，选择Configure，然后选择AddGradleNature： 
第544篇文章[]
java中的泛型中的静态方法 泛型方法 泛型方法就是要在权限符和返回值之间声明泛型，通常用L、V、E、T、K等字母，然后就可以在这个方法的内部将其看作一种方法类型了 在实验中遇到的问题 publicstatic<L>IntervalSet<L>empty()throwsException{ thrownewRuntimeException(); } 本以是想用静态工厂方法定义一个初始化的方法，但是发信并不能使用类定义的泛型。 静态方法不能直接使用类定义的泛型，也就是说如果要在静态方法中使用泛型的话，就必须将其声明为泛型方法。 查阅的材料 https://www.cnblogs.com/coprince/p/8603492.html链接 
第545篇文章[]
HIT软件构造----Reading6:Specifications（fromMITSoftwareConstruction） Specifications 原文链接http://web.mit.edu/6.031/www/sp20/classes/06-specifications/ Introduction Thespecificationactsasacontract:theimplementerisresponsibleformeetingthecontract,andaclientthatusesthemethodcanrelyonthecontract.同老师上课讲法，spec就是客户端和开发者之间的合同，开发者必须按照合同实现方法，用户必须按照合同去使用方法。 本文将讨论preconditions、postconditions、exceptions三个重要概念 Javaneededforthisreading 需要我们了解exception的概念try、catch的用法很简单的基本概念，用过java的同学应该都知道。 Behavioralequivalence 所谓的行为等价性：whetherwecouldsubstituteoneimplementationfortheother。即我们是否可以用一段代码去代替另一段代码。如下面两个小例子：1. staticintfind(int[]arr,intval){ for(inti=0;i<arr.length;i++){ if(arr[i]==val)returni; } return-1; } staticintfind(int[]arr,intval){ for(inti=0,j=arr.length-1;i<=j;i++,j--){ if(arr[i]==val)returni; if(arr[j]==val)returnj; } return-1; } 两个方法都是在一个数组中寻找是否存在某个数，如果存在则返回下标，如果不存在则返回-1。我们的问题是：是否能够用方法2来代替方法1呢？即这两个方法是否具有行为等价性呢？答案是不能的，如果有待查找的数字多次出现在了这个数组中，第一个方法会返回第一次出现时的下标，第二个方法会返回最小或者最大的下标，取决于谁更加靠近端点。而如果我们加上一个限定条件：只有一个待寻找的数存在在数组当中的话，那么两个方法的返回值就是唯一的，在这个条件的约束下，两个方法具有行为等价性。行为等价性的定义是从客户端的角度来说的，如果一个方法能够替换另一个，则两方法具有行为等价性。 staticintfind(int[]arr,intval) requires: valoccursexactlyonceinarr effects: returnsindexisuchthatarr[i]=val 博客中给出的习题，复习时均应阅读：spec和test（test-first-programming）一定要先写好 两句很有启发的话：strongpreconditionhidestheirpotentialdifferencesinbehavior.前置条件太强的话，会盖住潜在的行为不同性，两个看起来不同的方法在很强的前置条件下会具有行为等价性。==aweakpostconditionpermitstheirdifferencesinbehavior==前置条件太弱，就会允许一些行为上的差异，但是两方法仍具有行为等价性。 Whyspecifications? spec可以帮助我们使程序更好理解，我们要了解一个方法能干什么，只读spec即可，不必费心神去读源代码。也可以帮助我们更快的确定bug的位置。spec不仅像用户和实现者之间的合同，也像用户和实现者之间的防火墙。implementer可以用任何的数据结构和算法来实现spec要求的功能，而不必将细节暴露给客户端。这样的防火墙带来的好处就是将客户端和实现者解耦（decoupling）。 Specificationstructure spec的构成：1.方法名，参数类型，返回值类型，抛出异常的类型2.requires（pre）3.effects（post）满足precodition是客户端的义务。而满足postcondition是实现者的义务。参数类型和requires都是precondition。返回值类型和抛出异常的类型和effects都是postcondition。 前置条件满足，后置条件必须满足前置条件不满足，后置条件随意，实现者可以做任何事（即使是不道德的事情） Whenourpreconditionisviolated,theclienthasabug.Wecanmakethatbugeasiertofindandfixbyfailingfast,eventhoughwearenotobligatedtodoso.自律的要求（即使没有任何人要求我们这么做）：抛出异常，failfast（让程序尽快死掉），检查bug。 SpecificationsinJava @param@return@throw用这样的语法可以自动生成帮助手册。例： spec的注释第一行两个星号不用加参数类型或着返回值类型没有@requires和@effects这样的关键字 **什么是spce不应该说的：** 局部变量，私有属性，算法实现的任何细节，实现者应该保证细节对读代码的人不可见。 Donotallownullreferences 原始类型不能被赋值为null：（8种primitives）byte、short、int、long、float、double、boolean、char。你无法访问null对象的任何属性和方法。例如Stringname=null;name.length()----------------->throwsNullPointExceptionnull通常是危险的，所以spec除非显示说明可以接受null，否则null是不能做为参数和返回值的。所以默认任何spec都有一个precondition：参数不能是null，也都有一个postcondition：返回值不能是null！！！Avoidnull!!!建议显示的使用@NonNull关键字来说明禁止出现null，这样编译器就会自动检查。 void也是一个值，如果返回类型是void，只能用return;null.length()会导致NullPointerException 关键：只要没提参数或者返回值可以是null，就默认不能是null。 Includeemptiness null和emptiness的差别：null和空串的差别，类似于形式语言与自动机那门课中， ϕ 和 ϵ \phi和\epsilon ϕ和ϵ的区别。List.of()返回一个空列表。 只要没说可以用null，就绝对不能用null。前件不成立，后件无条件成立。 Testingandspecifications Testingunits 集成测试：一个测试用例结合各个模块的功能。不应该使测试用例违反前置条件，否则测试没有意义。如果编译器能检查出某种错误，那么它不应该被写入spec，那是多余的。 Specificationsformutatingmethods 后置条件存在的side-effects，可能会修改某个内部的值。 pre必须限制list1不等于list2，否则有可能算法无法停止。 就像null如果不特殊说明就被禁止出现在参数和返回值中一样，mutation不特殊说明也被禁止出现在参数和返回值中。 Exceptions 例： IndexOutOfBoundsException NullPointException ArithmeticException NumberFormatException 出现不应该出现的情况时，以往的程序员往往返回一个特殊值，如-1，null，9/9/99等，然而这样时有问题的，我们不仅容易忘了这么做，而且还会导致我们无法发现程序中存在的bug。Java的异常处理机制，提供以下两种做法: 用throw抛出异常用trycatch处理异常例题：try必须跟catch或者finally，否则静态检车都过不去。try和catch会把变量的作用域分开，在try中声明的变量到这个大括号外面就直接被释放了，不再存在，不能对它赋值或者引用。空的catch体是一个很坏的编程习惯，尽量不要这么去做。它捕获了异常，但又什么都不做，让程序继续执行下去。chainedexception，将原来捕获的异常作为新的异常的构造器的参数传入，构造一个新的异常，然后继续抛出。 Checkedanduncheckedexceptions 从上一个部分可以看出异常机制的两个重要理由：特殊的返回值和bug检测。有这样一通用的规则：用checkedexceptions来标识特殊值，用uncheckedexceptions来标识bug。 checkedexceptions:需要在函数声明中写throwXXXXException，这样编译器就会进行静态检查。Exception之下有一支全是checkedexceptionRuntimeException下面全是uncheckedexception当用catch，你最好用最细分的exception类型，而不是简单的用Exception或者RuntimeException，可能会影响静态检查或者隐藏bug。 unchecked的exception最好不要抛出来，而是直接打印信息，方便我们找到bug所在。checked的exception要抛给上一层，告诉我们需要处理特殊值了（情况不符合）。抛出的异常就类似于我们以往的编程工作中所写的函数所返回的特殊值（例如遇到找不到的情况就返回-1，并在main函数中检测这个特殊值）。可以把抛特殊值等价于抛异常。 Error是UncheckedException，但是error不是exception的子类，所以无法被try，catch捕获。而且直接自动打印栈信息。checkedexception：@throws和throws都要写uncheckedexception：只用写@throws Summary SafefrombugsEasytounderstandReadyforchange 
第546篇文章[3]
CCF计算机软件能力认证考试CSP-201912-2回收站选址 #include<iostream> usingnamespacestd; #include<map> typedefstructnode { longlongx,y; boolisrecy; intscore; }coordinate; boolisrecy(coordinatep,coordinatepos[],intn) { boolflag1=false,flag2=false,flag3=false,flag4=false; for(inti=0;i<n;i++) { if(pos[i].x-1==p.x&&pos[i].y==p.y)flag1=true; elseif(pos[i].x+1==p.x&&pos[i].y==p.y)flag2=true; elseif(pos[i].x==p.x&&pos[i].y+1==p.y)flag3=true; elseif(pos[i].x==p.x&&pos[i].y-1==p.y)flag4=true; } if(flag1&&flag2&&flag3&&flag4)returntrue; elsereturnfalse; } intscore(coordinatep,coordinatepos[],intn) { intscore=0; for(inti=0;i<n;i++) { if(p.x-1==pos[i].x&&p.y-1==pos[i].y)score++; elseif(p.x-1==pos[i].x&&p.y+1==pos[i].y)score++; elseif(p.x+1==pos[i].x&&p.y+1==pos[i].y)score++; elseif(p.x+1==pos[i].x&&p.y-1==pos[i].y)score++; } returnscore; } intmain(void) { intn; cin>>n; coordinatepos[n]; for(inti=0;i<n;i++) { cin>>pos[i].x>>pos[i].y; } for(inti=0;i<n;i++) { pos[i].isrecy=isrecy(pos[i],pos,n); } for(inti=0;i<n;i++) { pos[i].score=0; } for(inti=0;i<n;i++) { if(isrecy(pos[i],pos,n)){ pos[i].score=score(pos[i],pos,n); } } intscore[5]={0}; for(inti=0;i<n;i++) { if(isrecy(pos[i],pos,n)){ score[pos[i].score]++; } } for(inti=0;i<5;i++) { cout<<score[i]<<endl; } return0; } 
第547篇文章[]
面向可复用性的软件构造 一.复用的等级和形态 源代码级别的复用：复制粘贴模块级别的复用：类与接口库级别的复用：API和包 二.复用的类型 白盒复用：复制并修改一段代码。可以对代码的功能进行定制，但是愮指导代码内部的实现逻辑，增加了软件的复杂度。黑盒复用：不能直接看到源代码，只是利用别人提供的API，更加简单，但是适用性差。 三.源代码级别的复用 粘贴代码 四.模块级别的复用：类与接口 继承： 设计继承树可能会重写一堆方法（@Override）extend是类级别的复用 代理： 显式代理：传递对象给需要使用这些功能的对象隐式代理：将某个对象定义为这个对象的成员，去调用其方法是对象级别的复用 五.库级别的复用：API和包 库：开发者构造软件，去调用库中的功能框架：可以复用的骨架代码，可以定制功能到某个应用。框架作为主程序去执行，执行过程中调用开发者自己写的程序 六.框架级别的复用 框架：一组抽象类和具体类，以及他们之间的关系。开发者根据框架的规约，填充一些自己的代码进去，形成完整的代码 白盒框架：通过继承进行框架的扩展黑盒框架：通过实现特定的接口、或者通过dialing来进行扩展 七.行为子类型和LSP原则 子类型多态：客户端可以用统一的方式来处理不同类型的对象。使用父类的地方，都可以无条件用子类来代替。静态类型检查（即编译器对子类型的要求）： 子类型可以添加方法，但是不可以删除子类型需要实现抽象类型中的所有未实现的方法子类型中重写的方法必须有相同或子类型的返回值候符合协变的返回值子类中重写的方法必须使用同样类型的参数或者符合逆变的参数子类型中重写的方法不能抛出额外的异常总结：更强的不变量、更弱的前置条件、更强的后置条件协变：返回值的类型和异常的类型要更加具体。 Object-->String Throwable-->IOException 逆变：参数类型要更加抽象。 String-->Object 理论上是这样的，但是目前java还不支持这样，还是会将其当作overload而不是override看待。但是泛型中的参数不能这样理解，协变后的泛型不是原类型的子类型：List<Integer>不是List<Number>的子类型。也就是说Myclass<A>和Myclass<B>没有任何关系，无论A和B是否有关系。 泛型中的通配符 List<?>是一个不知道什么类型的列表使用通配符的典型场景： 你实现的方法可以通过使用Object类的方法来实现当你的方法在泛型类中不依赖参数的类型时，如List.size,List.clear等List<Object>很可能使错误的用法，而正确的用法使List<>?>通配符下界：<?superA>，A的父类和自己都可以传入通配符下界：<?extendsA>，A的子类和自己都可以传入List<Number>是List<？>的子类型List<Number>是List<？extendsObject>的子类型List<Object>是List<？superString>的子类型 八.委派（delegation） InterfaceComparator<T>intcompare(To1,To2)如果ADT需要实现比较大小的操作，或着要放入Collections或Arrays中进行排序，实现Comparator接口并重写compare方法InterfaceComparable<T>让ADT实现Comparable接口，然后overridecompareTo方法 区别：不用构建新的Comparator类，比较代码放在ADT内部委派（delegation）：一个对象请求另一个对象的功能，通过运行时动态绑定，实现对其他类中代码的复用显示委派：将对象作为参数传入隐式委派：放入实现类的内部client calls >Receiver delegatesto >delegate问题：如果子类中只需要复用父类中的一小部分代码，那么就不需要继承，继承是没有意义的，而是需要动态请求一个对象，通过委派来实现代码的复用，避免大量无用的复用Compositeoverinheritanceprinciple（CRP）：组合比继承更好，has_a、use_a比is_a更好。代理的类型：use：临时性的delegation，通过参数传入，方法运行完，两者就彻底脱离关系了association：永久性的delegation，在rep中定义一个属性存储要请求的对象，通过构造方法传参构造，但是传入后就不能修改了，就固定住了composition：更强的association，直接在写ADT的时候就将类型固定好了，不能通过传参设定，难以变化，可以理解为is_part_ofAggregation：更弱的association：不仅可以通过构造方法传参构造，还可以在后续的客户端代码处，通过特殊的设定方法，随时改变属性。 
第548篇文章[3]
第21次CCF计算机软件能力认证CSP-202009-1-称检测点查询 题目背景 2020年6月8日，国务院联防联控机制发布《关于加快推进新冠病毒核酸检测的实施意见》，提出对“密切接触者”等八类重点人群“应检尽检”，其他人群“愿检尽检”。 问题描述 某市设有n个核酸检测点，编号从1到n，其中i号检测点的位置可以表示为一个平面整数坐标(xi,yi)。 为方便预约核酸检测，请根据市民所在位置（x，y），查询距其最近的三个检测点。多个检测点距离相同时，编号较小的视为更近。 输入格式 输入共n+1行。 第一行包含用空格分隔的三个整数n、x和y，表示检测点总数和市民所在位置。 第二行到第n+1行依次输入n个检测点的坐标。第i+1行（1<=i<=n）包含用空格分隔的两个整数xi和yi，表示i号检测点所在位置。 输出格式 输出共三行，按距离从近到远，依次输出距离该市民最近的三个检测点编号。 样例输入1 322222324 样例输出1 123 样例输入2 501-10001002-12 样例输出2 241 代码如下： #include<iostream> usingnamespacestd; #definemax200 typedefstructdist { intx; inty; }dist; intmain(){ dista[max]; intn,x,y; cin>>n>>x>>y; intresult[n]; boolflag[n]; for(inti=0;i<n;i++) { flag[i]=false; cin>>a[i].x>>a[i].y; result[i]=(a[i].x-x)*(a[i].x-x)+(a[i].y-y)*(a[i].y-y); } intnum[3]; intk; for(inti=n-1;i>=n-3;i--) { k=n-1; for(intj=n-2;j>=0;j--) { if(result[j]<=result[k]&&!flag[j]) { k=j; } } num[n-1-i]=result[k]; flag[k]=true; } for(inti=0;i<3;i++) { for(intj=0;j<n;j++) { if(result[j]==num[i]&&flag[j]) { cout<<j+1<<'\n'; flag[j]=false; } } } return0; } 
