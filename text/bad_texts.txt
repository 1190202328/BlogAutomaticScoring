程序人生-Hello’sP2P 计算机系统 大作业 摘要 hello.c,每个计算机人程序路上的第一步。预处理、编译、汇编、链接、进程管理、存储管理、IO管理 它最为简单，却是每个计算机程序运行的点点缩影。Hello.c是用高级语言C编写的，我们要经过预处理，编译，汇编等过程，才能作为机器能读懂的机器代码储存在磁盘中。Hello现在的状态叫程序（Program），用户通过shell，调用一系列函数将hello运行在内存中。他是通过一种叫做进程（Process）的抽象来实现的。理解这些简单之下的过程与作用，能加深对计算机系统的深刻认识，以及学习过程疑问的逐步解答。以“hello一生”，走进计算机的故事。 关键词：编译管理；进程链接；hello;计算机系统分析； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-4- 1.1Hello简介-4- 1.2环境与工具-4- 1.3中间结果-4- 1.4本章小结-4- 第2章预处理-5- 2.1预处理的概念与作用-5- 2.2在Ubuntu下预处理的命令-5- 2.3Hello的预处理结果解析-5- 2.4本章小结-5- 第3章编译-6- 3.1编译的概念与作用-6- 3.2在Ubuntu下编译的命令-6- 3.3Hello的编译结果解析-6- 3.4本章小结-6- 第4章汇编-7- 4.1汇编的概念与作用-7- 4.2在Ubuntu下汇编的命令-7- 4.3可重定位目标elf格式-7- 4.4Hello.o的结果解析-7- 4.5本章小结-7- 第5章链接-8- 5.1链接的概念与作用-8- 5.2在Ubuntu下链接的命令-8- 5.3可执行目标文件hello的格式-8- 5.4hello的虚拟地址空间-8- 5.5链接的重定位过程分析-8- 5.6hello的执行流程-8- 5.7Hello的动态链接分析-8- 5.8本章小结-9- 第6章hello进程管理-10- 6.1进程的概念与作用-10- 6.2简述壳Shell-bash的作用与处理流程-10- 6.3Hello的fork进程创建过程-10- 6.4Hello的execve过程-10- 6.5Hello的进程执行-10- 6.6hello的异常与信号处理-10- 6.7本章小结-10- 第7章hello的存储管理-11- 7.1hello的存储器地址空间-11- 7.2Intel逻辑地址到线性地址的变换-段式管理-11- 7.3Hello的线性地址到物理地址的变换-页式管理-11- 7.4TLB与四级页表支持下的VA到PA的变换-11- 7.5三级Cache支持下的物理内存访问-11- 7.6hello进程fork时的内存映射-11- 7.7hello进程execve时的内存映射-11- 7.8缺页故障与缺页中断处理-11- 7.9动态存储分配管理-11- 7.10本章小结-12- 第8章hello的IO管理-13- 8.1Linux的IO设备管理方法-13- 8.2简述UnixIO接口及其函数-13- 8.3printf的实现分析-13- 8.4getchar的实现分析-13- 8.5本章小结-13- 结论-14- 附件-15- 参考文献-16- 第1章概述 1.1 Hello简介 P2P的过程:在linux中，hello.c经过cpp的预处理、ccl的编译、as的汇编、ld的链接最终成为可执行目标程序hello，在shell中键入启动命令后，shell为其fork，产生子进程，于是hello便从Program成为Process。 020的过程: shell为其execve，映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数执行目标代码，CPU为运行的hello分配时间片执行逻辑控制流。当程序运行结束后，shell父进程负责回收hello进程，内核删除相关数据结构。 1.2环境与工具 硬件环境：IntelG4560 x64CPU, 16GRAM 软件环境：Ubuntu18.04.3 开发与调试工具：vim，gcc，ld，edb，readelf，HexEdit 1.3中间结果 [if!supportLists]1. [endif]hello.i：hello.c预处理之后的文件 [if!supportLists]2. [endif]hello.s：编译之后的汇编文件 [if!supportLists]3. [endif]hello.o：汇编之后的目标执行 [if!supportLists]4. [endif]hello：链接实现的可执行目标文件 [if!supportLists]5. [endif]helloo.elf：hello.o的ELF格式 [if!supportLists]6. [endif]hello.elf：hello的ELF格式 1.4本章小结 本章主要简单介绍了hello的p2p，020过程，列出了本次实验信息：环境、中间结果。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 概念： 程序设计领域中，预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。典型地，由预处理器(preprocessor)对程序源代码文本进行处理，得到的结果再由编译器核心进一步编译。 作用： 1.对相关命令或语句的含义和功能作具体分析。 3.用实际值替换用#define定义的字符串 4.根据#if后面的条件决定需要编译的代码 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 预编译实现了： 1.将所有的#define删除，并展开所有的宏定义； 2.处理所有的预编译指令，例如：#if,#elif,#else,#endif; 3.处理#include预编译指令，将被包含的文件插入到预编译指令的位置； 4.添加行号信息文件名信息，便于调试； 5.删除所有的注释：///**/; 2.4本章小结 hello.c预处理生成hello.i,生成.i文件。 包括（1）去注释（2）宏替换（3）头文件展开（4）条件编译 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序 作用：将c语言文件变为汇编语言文件 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.3.1.数据：在执行main程序时首先将栈底指针入栈，同时令栈顶指针值等于栈底指针值，完成栈的初始化。然后通过减少栈顶指针值在栈中获得空间。此时的argc与argv[]存放在寄存器edi和rsi中，通过两个mov操作，将参数值进栈，从而完成了参数的传递。 常量 变量(全局(无)/局部) 向函数传递参数值、数组、指针 argc为图中-20(%rbp) 变量i 3.3.2赋值 将i赋值为0 3.3.3类型转换 调用atoi函数将字符串转为整型 3.3.4算术操作 对局部变量i累加 3.3.5关系操作 判断argc与4是否相等 判断i是否小于等于7 3.3.6数组/指针/结构操作 对argv数组进行操作，数组在存储空间中申请的是连续的内存。 3.3.7函数操作 终止程序 从键盘输入内读取字符串 打印到屏幕 字符串转为整型 need-to-insert-img 休眠 清除回车 3.3.8for循环 若参数个数为4，则跳转到.L2。此时进入for循环。for循环的控制变量为局部变量i，且初值为0的i满足i<8时进入循环。.L2将i的初值赋值为0，跳转到.L3。循环开始前执行.L3的第一条cmp语句，满足条件进入循环体，在汇编代码中的体现为跳转到.L4。在.L4中，调用了printf函数，通过main创建的栈为其传递参数到寄存器rdx和rsi中。然后调用sleep函数。注意到sleep函数中的参数为atoi函数，则首先需要执行atoi函数。仍是利用已经存储在栈中的argv数组，将所需值送入寄存器rdi，执行atoi后，返回值存储在寄存器eax中。再将其送入寄存器edi，则参数值成功传入sleep中，一次循环进行完成，将循环控制变量i的值+1，进入新一轮循环。当i的值等于8时，循环停止。 3.4本章小结 第三章主要还是详细分析编译器对hello.c的具体操作与生成的.s文件，了解各个数据和操作类型如何进行表示与实现。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编器将.s汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，它包含程序的指令编码。这个过程称为汇编，亦即汇编的作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 hello.o是可重定位文件，节头大小为64字节，数量为13，字符串表索引节头为12 4.4Hello.o的结果解析 从总体流程看，hello.s与hello.o的总体流程相同。从hello.o的反汇编文件可以看出每行十六进制数代表着一个指令操作，存在一一对应的关系。机器语言由二进制数构成，分为操作数和操作码。每条01序列构成的指令都有不同的含义。例如，对于一条机器指令，有些序列代表寄存器的编号。将操作码与代表寄存器的序列结合后生成新的01序列，此时看来会有机器语言中的操作数与汇编语言不一致的现象。其本质是机器语言的指令结合了操作码。hello.s文件中使用标志来进行分支转移，如指令jmp.L2。而在hello.o反汇编得到的文件中，则采用了相对寻址方式进行分支转移操作。.函数调用：hello.o反汇编文件中调用函数的操作为“call下条指令的地址”，在hello.s中则是“call函数名”。因为hello.c中调用的函数都是库函数，在进行下一步链接后才能最终确定其地址，所以在汇编时将call指令后的地址设置为0，等待链接。 主要差别如下： 1.反汇编代码跳转指令的操作数使用的不是段名称，所以在汇编成机器语言之后是确定的地址。2.在.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。 4.5本章小结 第四章解释了hello.s到hello.o的汇编过程，并使用readelf与objdump工具对hello.o的ELF文件分析与反汇编之后与hello.s的比较，表现了汇编语言到机器语言的转换。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。 5.2在Ubuntu下链接的命令 ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 1.读取ELF文件头 2.显示程序头表 3.读取头节表 5.4hello的虚拟地址空间 Type存储段的类型 特殊节的类型 VirtAddr首字节的虚拟地址 PhysAddr首字节的物理地址 Align对齐方式 为2的整数幂 FileSiz文件中所占的字节数 MemSiz存储器中所占字节数 5.5链接的重定位过程分析 hello相对于hello.o有如下不同： 1.hello相对hello.o多了很多的节类似于.init,.plt等 2.hello.o中的相对偏移地址到了hello中变成了虚拟内存地址 3.hello中相对hello.o增加了许多的外部链接来的函数。 4.hello.o中跳转以及函数调用的地址在hello中都被更换成了虚拟内存地址。 重定位： 在hello到hello.o中，首先是重定位节和符号定义，链接器将所有输入到hello中相同类型的节合并为同一类型的新的聚合节。 然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每一个符号。 当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 然后是重定位节中的符号引用，链接器会修改hello中的代码节和数据节中对每一个符号的引用，使得他们指向正确的运行地址。 5.6hello的执行流程 ld-2.27.so!_dl_start ld-2.27.so!_dl_init hello!_start libc-2.27.so!__libc_start_main -libc-2.27.so!__cxa_atexit -libc-2.27.so!__libc_csu_init hello!_init libc-2.27.so!_setjmp -libc-2.27.so!_sigsetjmp –libc-2.27.so!__sigjmp_save hello!main hello!puts@plt hello!exit@plt hello!printf@plt hello!atoi@plt hello!sleep@plt hello!getchar@plt ld-2.27.so!_dl_runtime_resolve_xsave-ld-2.27.so!_dl_fixup –ld-2.27.so!_dl_lookup_symbol_x libc-2.27.so!exit 5.7Hello的动态链接分析 (图5.6调用dl_init之前) （图5.7调用之后） 5.8本章小结 在本章中主要介绍了链接的概念与作用、hello的ELF格式，分析了hello的虚拟地址空间、重定位过程、执行流程、动态链接过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中的程序的实例，每一个进程都有它自己的地址空间，一般情况下，包括文本区域、数据区域、和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储区着活动过程调用的指令和本地变量。 6.2简述壳Shell-bash的作用与处理流程 Shell的作用： Shell是指一种应用程序，Shell应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 命令别名和快捷键 查看系统当中的别名自定义别名删除别名将别名写入环境变量配置文件则会永久生效 6.3Hello的fork进程创建过程 （图6.1fork（）创建进程） 6.4Hello的execve过程 1.使用execve就是一次系统调用，首先要做的将新的可执行文件的绝对路径从调用者（用户空间）拷贝到系统空间中。 2.在得到可执行文件路径后，就找到可执行文件打开，由于操作系统已经为可执行文件设置了一个数据结构，就初始化这个数据结构，保存一个可执行文件必要的信息。 3.可执行文件不是真正上能够自己运行的，需要有代理人来代理。在系统内核中有一个formats队列，循环遍历这个队列，看看现在被初始化的这个数据结构是哪个代理人可以代理的。如果没有就继续查看数据结构中的信息。按照系统配置了是否可以动态加载模块，加载一次模块，再循环遍历看是否有代理人前来认领。 4.找到正确的代理人后，代理人首先要做的就是放弃以前从父进程继承来的资源。 6.5Hello的进程执行 用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 6.6hello的异常与信号处理 运行时按下ctrl-C，hello进程终止，并向父进程发送SIGINT（进程终止）信号，由父进程负责完成子进程的回收 运行时按下ctrl-Z，子进程暂时挂起，向父进程发出SIGSTOP信号。此时子进程并不会被回收。当其收到特定信号时，会继续执行。执行结束后进程终止，向父进程发送SIGINT信号，被父进程回收 ctrl+z后jobs ctrl+z后pstree 运行过程中的无关输入被缓存到stdin，并随着printf指令被输出到结果 6.7本章小结 在本章中，阐明了进程的定义与作用，介绍了Shell的一般处理流程，调用fork创建新进程，调用execve执行hello，hello的进程执行，hello的异常与信号处理。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 1.物理地址 用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。 [if!supportLists]2. [endif]虚拟内存 例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000-1那个地址元素； 例如，要调用某个函数main（），代码不是callA，而是call0x0811111111，也就是说，函数A的地址已经被定下来了。没有这样的“转换”，没有虚拟地址的概念，这样做是根本行不通的。 3.逻辑地址 逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。以上例，我们说的连接器为A分配的0x08111111这个地址就是逻辑地址。 “一个逻辑地址，是由一个段标识符加上一个指定段内相对地址的偏移量，表示为[段标识符：段内偏移量]，也就是说，上例中那个0x08111111，应该表示为[A的代码段标识符:0x08111111]，这样，才完整一些” [if!supportLists]3. [endif]线性地址 跟逻辑地址类似，它也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件页式内存的转换前地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 机器语言指令中出现的内存地址，都是逻辑地址，需要转换成线性地址，再经过MMU(CPU中的内存管理单元)转换成物理地址才能够被访问到。 在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值 7.3Hello的线性地址到物理地址的变换-页式管理 通过分页机制，具体的说，就是通过页表查找来对应物理地址。 准确的说分页是CPU提供的一种机制，Linux只是根据这种机制的规则，利用它实现了内存管理。 在保护模式下，控制寄存器CR0的最高位PG位控制着分页管理机制是否生效，如果PG=1，分页机制生效，需通过页表查找才能把线性地址转换物理地址。如果PG=0，则分页机制无效，线性地址就直接做为物理地址。 分页的基本原理是把内存划分成大小固定的若干单元，每个单元称为一页（page），每页包含4k字节的地址空间（为简化分析，我们不考虑扩展分页的情况）。这样每一页的起始地址都是4k字节对齐的。为了能转换成物理地址，我们需要给CPU提供当前任务的线性地址转物理地址的查找表，即页表(pagetable)。注意，为了实现每个任务的平坦的虚拟内存，每个任务都有自己的页目录表和页表。 为了节约页表占用的内存空间，x86将线性地址通过页目录表和页表两级查找转换成物理地址。 32位的线性地址被分成3个部分： 最高10位 Directory 页目录表偏移量，中间10位 Table是页表偏移量，最低12位Offset是物理页内的字节偏移量。 页目录表的大小为4k（刚好是一个页的大小），包含1024项，每个项4字节（32位），项目里存储的内容就是页表的物理地址。如果页目录表中的页表尚未分配，则物理地址填0。 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 当fork函数被shell调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。并且创建hello进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。 execve函数执行了以下几个操作： 1.删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2.映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3.映射共享区域。 4.设置程序计数器（PC）。execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 1、当内存管理单元（MMU）中确实没有创建虚拟物理页映射关系，并且在该虚拟地址之后再没有当前进程的线性区（vma）的时候，可以肯定这是一个编码错误，这将杀掉该进程； 2、当MMU中确实没有创建虚拟页物理页映射关系，并且在该虚拟地址之后存在当前进程的线性区vma的时候，这很可能是缺页中断，并且可能是栈溢出导致的缺页中断； 3、当使用malloc/mmap等希望访问物理空间的库函数/系统调用后，由于linux并未真正给新创建的vma映射物理页，此时若先进行写操作，将和2产生缺页中断的情况一样；若先进行读操作虽然也会产生缺页异常，将被映射给默认的零页，等再进行写操作时，仍会产生缺页中断，这次必须分配1物理页了，进入写时复制的流程； 4、当使用fork等系统调用创建子进程时，子进程不论有无自己的vma，它的vma都有对于物理页的映射，但它们共同映射的这些物理页属性为只读，即linux并未给子进程真正分配物理页，当父子进程任何一方要写相应物理页时，导致缺页中断的写时复制； 7.9动态存储分配管理 1）首次适应：首次适应策略要求空闲区按其起始地址从小到大排列，当某一用户作业要求装入内存时，存储分配程序从起始地址最小的空间区开始扫描，直到找到满足该作业要求的空闲区为止。 2）循环首次适应：在查找空闲区时，不再每次从链首开始查找，而是从上一次找到的空闲区的下一个空闲区开始查找，直到找到一个能满足要求的空闲区为止，并从中划出一块与请求大小相等的内存空间分给该作业。 3）最佳适应：该策略总是把满足要求，又使最小的空闲区分配给请求作业，即在空闲区表中，按空闲区的大小从小到大排列，建立索引，当用户作业请求内存空间时，从索引表中找到第一个满足该作业的空闲区分给它。 4）最差适应：该策略总是把最大的空闲区分配给请求作业，空闲区表（空闲区链）中的空闲分区要按大小从大到小进行排序，自表头开始查找到第一个满足要求的空闲分区分配给作业。 7.10本章小结 本章主要介绍了hello的存储器地址空间、intel的段式管理、hello的页式管理，以intelCore7在指定环境下介绍了VA到PA的变换、物理内存访问，还介绍了hello进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 （第7章 2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 1.read和write函数，例子用法如下，第一个参数为文件描述符fd,位于stdio.h中 read(STDIN_FILENO,buf,BUFFSIZE); write(STDOUT_FILENO,buf,BUFFSIZE); 常用方式 while((n=read(STDIN_FILENO,buf,BUFFSIZE))!=n) { if(write(STDOUT_FILENO,buf,n)!=n) perror("writeerror"); } 其中STDIN_FILENO要求unistd.h 2.getc和putc函数，例子用法如下 while((c=getc(stdin))!=EOF) if(putc(c,stdout)==EOF) perror("error"); 3.fgets(buf,MAXSIZE,stdin); 从标准输入读入一次读一行，返回buf，以换行符结束，后面跟一个空字符 如果读到文件末尾，返回一个null指针 8.3printf的实现分析 C语言中，参数压栈的方向是从右往左。也就是说，当调用printf函数的适合，先是最右边的参数入栈。 fmt是一个指针，这个指针指向第一个const参数（constchar*fmt)中的第一个元素。fmt也是个变量，它的位置，是在栈上分配的，它也有地址。 对于一个char*类型的变量，它入栈的是指针，而不是这个char*型变量。 sys_call: ;ecx中是要打印出的元素个数 ;ebx中的是要打印的buf字符数组中的第一个元素 ;这个函数的功能就是不断的打印出字符，直到遇到：'\0' ;[gs:edi]对应的是0x80000h：0采用直接写显存的方法显示字符串 xorsi,si movah,0Fh moval,[ebx+si] cmpal,'\0' je.end mov[gs:edi],ax incsi loop: sys_call .end: ret 无论如何printf()函数都不能确定参数 究竟在什么地方结束，也就是说，它不知道参数的个数。它只会根据format中的打印格式的数目依次打印堆栈中参数format后面地址的内容。这样就存在一个可能的缓冲区溢出问题。。 8.4getchar的实现分析 #define getchar() getc(stdin)。getchar有一个int型的返回值.当程序调用getchar时.程序就等着用户按键.用户输入的字符被存放在键盘缓冲区中.直到用户按回车为止(回车字符也放在缓冲区中).当用户键入回车之后,getchar才开始从stdin流中每次读入一个字符.getchar函数的返回值是用户输入的第一个字符的ASCII码,如出错返回-1,且将用户输入的字符回显到屏幕.如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取.也就是说,后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键. 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法、UnixIO接口及其函数，分析了printf函数和getchar函数。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 1.编写，通过editor将代码键入hello.c 2.预处理，将hello.c调用的所有外部的库展开合并到一个hello.i文件中 3.编译，将hello.i编译成为汇编文件hello.s 4.汇编，将hello.s会变成为可重定位目标文件hello.o 5.链接，将hello.o与可重定位目标文件和动态链接库链接成为可执行目标程序hello 6.运行：在shell中输入./hello1170300127 wumenglin 7.创建子进程：shell进程调用fork为其创建子进程 8.运行程序：shell调用execve，execve调用启动加载器，加映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数。 9.执行指令：CPU为其分配时间片，在一个时间片中，hello享有CPU资源，顺序执行自己的控制逻辑流 10.访问内存：MMU将程序中使用的虚拟内存地址通过页表映射成物理地址。 11.动态申请内存：printf会调用malloc向动态内存分配器申请堆中的内存。 12.信号：如果运行途中键入ctr-cctr-z则调用shell的信号处理函数分别停止、挂起。 13.结束：shell父进程回收子进程，内核删除为这个进程创建的所有数据结构。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.c源代码 hello.c预处理得到的修改了的源程序 hello.i编译后生成的hello.s hello.s汇编后生成的hello.o hello.o使用objdump反汇编得到的结果 hello.o与动态库链接得到的hello可执行文件 hello.elf hello的ELF格式 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1]林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42. [2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999. [3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998 [1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL]. Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/ collection/anatmorp. （参考文献0分，缺失-1分）

软件构造实验心得（二） 

软件构造实验心得（四） 

软件构造实验心得（一） 从软件构造这门课中，我学到了很多编程知识而这门课的四个实验，静下心来做，更是能令人获益匪浅下面分享出我的实验报告，供其他同学们参考 

软件构造实验心得（三）

spfa+多源转单源前向星模板 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constintmaxn=2*1e5; constllinf=1e12; structedge{ intto; llw; intnext; }e[4*maxn+5]; structnode{ intto; llw; booloperator<(nodea)const{ returnw>a.w; } }; inthead[maxn+10]; inttot=0; lld[maxn+10]; lla[maxn+10]; boolvis[maxn+10]; intn,m; voidadd(intx,inty,llw) { e[tot].to=y,e[tot].next=head[x],e[tot].w=w,head[x]=tot++; e[tot].to=x,e[tot].next=head[y],e[tot].w=w,head[y]=tot++; } voidinit() { scanf("%d%d",&n,&m); memset(vis,0,sizeof(vis)); memset(head,-1,sizeof(head)); d[0]=0; a[0]=0; intx,y; llw; for(inti=1;i<=m;i++) { scanf("%d%d%lld",&x,&y,&w); add(x,y,2*w); } for(inti=1;i<=n;i++) scanf("%lld",&a[i]); for(inti=1;i<=n;i++) { d[i]=inf; add(0,i,a[i]); } } voidspfa() { priority_queue<node>q; q.push((node){0,0}); while(!q.empty()) { nodex=q.top(); q.pop(); intnow=x.to; if(vis[now])continue; vis[now]=1; for(inti=head[now];i!=-1;i=e[i].next) { llw=e[i].w; intnow2=e[i].to; if(d[now]+w<d[now2]) { d[now2]=d[now]+w; q.push((node){now2,d[now2]}); } } } } intmain() { //freopen("in.txt","r",stdin); init(); spfa(); for(inti=1;i<=n;i++) printf("%lld",d[i]); return0; } 

辛普森公式之求椭圆面积 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constdoubleeps=1e-7; doublea,b; doublef(doublex) { returnb*sqrt(1-x*x/(a*a)); } doublesimpson(doublel,doubler) { doublemid=(l+r)/2; return(r-l)*(f(l)+f(r)+4*f(mid))/6; } doublesolve(doublel,doubler) { doublemid=(l+r)/2; if(fabs(simpson(l,r)-simpson(l,mid)-simpson(mid,r))<=eps) { returnsimpson(l,r); } returnsolve(l,mid)+solve(mid,r); } intmain() { intt; scanf("%d",&t); doublel,r; while(t--) { scanf("%lf%lf%lf%lf",&a,&b,&l,&r); printf("%.3lf\n",2*solve(l,r)); } } 

字符串（马拉车+KMP+Tries树模板） 马拉车 voidmanacher() { intpos=0,r=0; for(inti=0;i<n;i++) { if(i<r)p[i]=min(p[2*pos-i],r-i); elsep[i]=1; while(s2[i-p[i]]==s2[i+p[i]])p[i]++; if(i+p[i]>r)r=i+p[i],pos=i; } } voidinit() { scanf("%s",s); n=strlen(s); intcnt=0; s2[0]='#'; for(inti=0;i<n;i++) { s2[++cnt]=s[i]; s2[++cnt]='#'; } n=cnt; } 异或Tries树 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constintmaxn=3200005; intTries[maxn][2]; intcnt[maxn]; inttot; intn,m; voidinit() { memset(cnt,0,sizeof(cnt)); memset(Tries,0,sizeof(Tries)); tot=0; } voidinsert(intx) { intnow=0; for(inti=31;i>=0;i--) { if(x&(1<<i)) { if(Tries[now][1]==0) Tries[now][1]=++tot; now=Tries[now][1]; } else { if(Tries[now][0]==0) Tries[now][0]=++tot; now=Tries[now][0]; } } } voidsolve(intx) { intnow=0; intans=0; for(inti=31;i>=0;i--) { if(x&(1<<i)) { //printf("%d%d\n",i,x); if(Tries[now][0]) { now=Tries[now][0]; } else now=Tries[now][1],ans+=(1<<i); } else { if(Tries[now][1]) { ans+=(1<<i); now=Tries[now][1]; } else now=Tries[now][0]; } } printf("%d\n",ans); } intmain() { //freopen("in.txt","r",stdin); intt; scanf("%d",&t); for(inti=1;i<=t;i++) { scanf("%d%d",&n,&m); intx; init(); for(intj=1;j<=n;j++) { scanf("%d",&x); insert(x); } printf("Case#%d:\n",i); for(intj=1;j<=m;j++) { scanf("%d",&x); solve(x); } } return0; } KMP，Codefroces1137BCampSchedule #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; chars[500005]; chars2[500005]; intnextt[500005]; intn,n2; stringans; voidgetc() { inti; intj=-1; nextt[0]=-1; for(i=0;i<n2;) if(j==-1||s2[i]==s2[j])nextt[++i]=++j; elsej=nextt[j]; } intmain() { //freopen("in.txt","r",stdin); scanf("%s",s); scanf("%s",s2); intnum1=0,num0=0; n=strlen(s); n2=strlen(s2); getc(); for(inti=0;i<n;i++) if(s[i]=='1')num1++; elsenum0++; intcnt=0; if(n<n2) { cout<<s<<endl; return0; } while(num1>0&&num0>0) { if(s2[cnt]=='0') { if(num0>0) { num0--; ans+='0'; cnt++; } else break; } else { if(num1>0) { num1--; ans+='1'; cnt++; } else break; } if(cnt==n2) cnt=nextt[cnt]; } while(num0)num0--,ans+='0'; while(num1)num1--,ans+='1'; cout<<ans<<endl; return0; } 写的好乱好杂 自己水平好低 有时间来改改吧 

tarjan求最小加入边而为ebcc模板 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constintmaxn=1e4; constllinf=1e8; intcnt,top,num,tot; intn,r; intdeg[maxn+5]; intdfn[maxn+5],low[maxn+5],vis[maxn+5],s[maxn+5],color[maxn+5]; structedge{ intto,next; }e[2*maxn+5]; inthead[maxn+5]; voidinit() { memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(vis,0,sizeof(vis)); memset(deg,0,sizeof(deg)); memset(head,-1,sizeof(head)); cnt=0; top=0; num=0; tot=0; } voidtarjan(intx,intfa) { dfn[x]=low[x]=++cnt; vis[x]=1; s[++top]=x; for(inti=head[x];i!=-1;i=e[i].next) { intv=e[i].to; if(!dfn[v]) { tarjan(v,x); low[x]=min(low[x],low[v]); } elseif(vis[v]&&v!=fa) { low[x]=min(low[x],low[v]); } } if(low[x]==dfn[x]) { color[x]=++num; vis[x]=0; while(s[top]!=x) { //printf("%d%d\n",x,s[top]); color[s[top]]=num; vis[s[top--]]=0; } top--; } } voidadd(intu,intv) { e[tot].to=v,e[tot].next=head[u],head[u]=tot++; } intmain() { //freopen("in.txt","r",stdin); scanf("%d%d",&n,&r); init(); intx,y; for(inti=1;i<=r;i++) { scanf("%d%d",&x,&y); add(x,y); add(y,x); } for(inti=1;i<=n;i++) if(!dfn[i]) tarjan(i,0); //printf("%d\n",num); for(inti=1;i<=n;i++) for(intj=head[i];j!=-1;j=e[j].next) { x=e[j].to; if(color[x]!=color[i]) { deg[color[x]]++,deg[color[i]]++; } } intans=0; for(inti=1;i<=num;i++) if(deg[i]==2)ans++; printf("%d\n",(ans+1)/2); return0; } 

一些细节 引用参数的数组降价 优先队列的缺省定义 动态规划的边界条件 c++的全局变量，慎 关于memset造成MLE的问题，AC自动机！ 双目运算符的优先级！！ 

poj1220numberbaseconversion高精度进制转换java c++和java两种来写，感觉java写着要顺一些，虽然代码存在很多java的错误习惯，还是贴一下，所以一定要好好学java啊orz importjava.math.BigDecimal; importjava.math.BigInteger; importjava.util.Scanner; importjava.util.*; importjava.text.*; importjava.io.*; publicclassMain{ publicstaticintgetint(charch) { if(Character.isDigit(ch))return(ch-'0'); elseif(Character.isUpperCase(ch))return(ch-'A'+10); elsereturn(ch-'a'+36); } publicstaticchargetchar(inti) { if(i>=0&&i<=9)return(char)(i+'0'); elseif(i>=10&&i<=35)return(char)(i-10+'A'); elsereturn(char)(i-36+'a'); } publicstaticvoidmain(String[]args){ Scannercin=newScanner(newBufferedInputStream(System.in)); intt=cin.nextInt(); while(t--!=0) { Strings; Stringans=newString(); intbase1,base2; base1=cin.nextInt(); base2=cin.nextInt(); s=cin.next(); BigIntegerresult=BigInteger.valueOf(0); for(inti=0;i<s.length();i++) { result=result.multiply(result.valueOf(base1)).add(result.valueOf(getint(s.charAt(i)))); } while(!result.equals(BigInteger.ZERO)) { ans=getchar(result.mod(result.valueOf(base2)).intValue())+ans; result=result.divide(result.valueOf(base2)); } if(ans.length()==0)ans+='0'; System.out.println(base1+""+s+'\n'+base2+''+ans); System.out.println(); } } } c++呢就是从从第i次开始，(i=1,2,3 )每一次都从首位开始枚举字符串，不断地求商取对应进制的模，求出来对应进制第i位上的数，直至结束。 

kruscal+lca模板求最小值 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constintmaxn=1e4; constllinf=1e8; intt; intn,m,w; intf[maxn+5][20]; inthead[maxn+5]; intfa[maxn+5]; intdp[maxn+5][20]; structnode{ intfrom,to,w; booloperator<(nodea)const{ returnw>a.w; } }e2[5*maxn+5]; structedge{ intto,w,next; }e[10*maxn+5]; inttot=0; intdep[maxn+5]; voidadd(intx,inty,intw) { e[tot].to=y,e[tot].w=w,e[tot].next=head[x],head[x]=tot++; e[tot].to=x,e[tot].w=w,e[tot].next=head[y],head[y]=tot++; } intfind(intx) { if(fa[x]==x)returnx; returnfa[x]=find(fa[x]); } booljudge(intx,inty) { returnfind(x)==find(y); } voidmerge(intx,inty) { x=find(x),y=find(y); fa[x]=y; } voidkruscal() { sort(e2+1,e2+1+m); for(inti=1;i<=m;i++) { intu=e2[i].from; intv=e2[i].to; if(judge(u,v))continue; add(u,v,e2[i].w); merge(u,v); } } voiddfs(intx,intfather,intw) { dep[x]=dep[father]+1; f[x][0]=father; dp[x][0]=w; for(inti=1;i<=19;i++) { if(f[x][i-1]==0)break; f[x][i]=f[f[x][i-1]][i-1]; dp[x][i]=min(dp[x][i-1],dp[f[x][i-1]][i-1]); } for(inti=head[x];i!=-1;i=e[i].next) { intv=e[i].to; //printf("%d%d%d\n",x,v,i); if(v==father)continue; dfs(v,x,e[i].w); } } intlca(intu,intv) { intans=inf; if(dep[u]<dep[v])swap(u,v); for(inti=19;i>=0;i--) { if(dep[f[u][i]]>=dep[v]) { ans=min(ans,dp[u][i]); u=f[u][i]; } } if(u==v)returnans; for(inti=19;i>=0;i--) { if(f[u][i]!=f[v][i]) { ans=min(ans,dp[u][i]); ans=min(ans,dp[v][i]); u=f[u][i]; v=f[v][i]; } } //printf("%d%d\n",u,v); ans=min(ans,dp[u][0]); ans=min(ans,dp[v][0]); returnans; } intmain() { //freopen("in.txt","r",stdin); scanf("%d%d",&n,&m); memset(head,-1,sizeof(head)); memset(f,0,sizeof(f)); for(inti=1;i<=n;i++) fa[i]=i; for(inti=1;i<=m;i++) { scanf("%d%d%d",&e2[i].from,&e2[i].to,&e2[i].w); } kruscal(); dep[0]=0; for(inti=1;i<=n;i++) if(fa[i]==i) dfs(i,0,0); intx,y,q; scanf("%d",&q); for(inti=1;i<=q;i++) { scanf("%d%d",&x,&y); if(!judge(x,y))printf("-1\n"); else printf("%d\n",lca(x,y)); } return0; } 

AC自动机模板 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> #definefr(i,a,b)for(inti=a;i<=b;i++) usingnamespacestd; typedeflonglongll; constintmaxn=100005; inttries[500005][26]; intcnt[500005]; intfail[500005]; inttot=0; intn; charx[1000005]; voidinsert() { intl=strlen(x); intnow=0; for(inti=0;i<l;i++) { intw=x[i]-'a'; if(!tries[now][w]) tries[now][w]=++tot; now=tries[now][w]; } cnt[now]++; } voidgetf() { queue<int>q; for(inti=0;i<26;i++) { if(tries[0][i]) { fail[tries[0][i]]=0; q.push(tries[0][i]); } } while(!q.empty()) { intfront=q.front(); q.pop(); for(inti=0;i<26;i++) { if(tries[front][i]) { fail[tries[front][i]]=tries[fail[front]][i]; q.push(tries[front][i]); } else tries[front][i]=tries[fail[front]][i]; } } } intquery() { intl=strlen(x); intnow=0; intans=0; for(inti=0;i<l;i++) { intw=x[i]-'a'; now=tries[now][w]; for(intj=now;j!=0&&cnt[j]!=-1;j=fail[j]) { ans+=cnt[j]; cnt[j]=-1; } } returnans; } intmain() { //freopen("in.txt","r",stdin); intt; scanf("%d",&t); while(t--) { memset(cnt,0,sizeof(cnt)); memset(tries,0,sizeof(tries)); tot=0; fail[0]=0; scanf("%d",&n); for(inti=1;i<=n;i++) { scanf("%s",x); insert(); } getf(); scanf("%s",x); //cout<<x<<endl; printf("%d\n",query()); } return0; } 

2021HITCSAPP大作业程序人生-Hello’sP2P 目录 摘要第1章概述1.1HELLO简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2在Ubuntu下编译的命令3.3Hello的编译结果解析3.3.1编译后生成文件3.3.2数据处理解析3.3.3操作符解析3.3.4控制转移解析3.3.5函数操作解析 3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令4.3可重定位目标elf格式4.3.1 ELF头4.3.2 节头部表4.3.3 重定位节4.3.4 符号表 4.4Hello.o的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式5.4hello的虚拟地址空间5.5链接的重定位过程分析5.6hello的执行流程5.7Hello的动态链接分析5.8本章小结 第6章hello进程管理6.1进程的概念与作用6.2简述壳Shell-bash的作用与处理流程6.3Hello的fork进程创建过程6.4Hello的execve过程6.5Hello的进程执行6.6hello的异常与信号处理6.7本章小结 第7章hello的存储管理7.1hello的存储器地址空间7.2Intel逻辑地址到线性地址的变换-段式管理7.3Hello的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.5三级Cache支持下的物理内存访问7.6hello进程fork时的内存映射7.7hello进程execve时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章hello的IO管理8.1Linux的IO设备管理方法8.2简述UnixIO接口及其函数8.3printf的实现分析8.4getchar的实现分析8.5本章小结 结论附件参考文献 摘要 本论文对hello运行的一生进行了深入地分析，在Ubuntu下通过从hello文件的诞生再到加载hello的进程并回收这一连串的过程来梳理与回顾整个CSAPP课程的脉络与知识，并对这个过程进行进一步的分析去深入地理解计算机系统。关键词：hello；文件；进程；计算机系统 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 第1章概述 1.1HELLO简介 Hello的P2P是一个从高级C语言程序开始到一个运行的进程的过程，由hello.c（源程序）经过预处理器(ccp)变成hello.i（修改了的源程序），再经过编译器(ccl)变成hello.s（汇编程序），再经过汇编器(as)生成hello.o（可重定位目标程序）最后由链接器(ld)生成hello（可执行目标程序）。经过这预处理、编译、汇编、链接四个步骤后，最后Linux系统再由shell加载运行hello程序，为它fork或是execve进程，完成从FromProgramtoProcess的P2P过程。 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk软件环境：Windows1064位；Vmware11；Ubuntu16.04LTS64位开发工具：VisualStudio201064位以上；GDB/OBJDUMP；DDD/EDB 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。中间结果文件文件作用使用时期hello.c本次大实验使用的程序整个过程hello.i预处理后得到的文本文件第二章-预处理hello.s编译后的文本文件第三章-编译hello.o汇编后得到的可重定位目标文件（二进制）第四章-汇编helloo.asm反汇编hello.o得到的文本文件第四章-汇编helloo.elfhello.o的elf文件第四章-汇编hello链接后得到的可执行目标文件（二进制）第五章-链接hello.elfhello的elf文件第五章-链接hello.asmhello的反汇编文件第五章-链接 1.4本章小结 本章对整个实验的全部过程进行了一个基本的概述，介绍了其P2P，O2O的两个过程，同时展示出本次实验所需的环境和工具，列举出编写本论文生成的所有中间结果文件及其作用。（第1章0.5分） 第2章预处理 2.1预处理的概念与作用 预处理的概念：编译之前进行的处理，在程序编译之前，预处理器根据以字符#开头的命令，修改原始的c程序。预处理的作用：展开#起始行的内容，并直接插入程序文本中以便调用。使用的预处理名称及意义如图2-1所示。 图2-1预处理名称及意义同时，预处理还会把代码中的注释去掉。 2.2在Ubuntu下预处理的命令 预处理的命令为gcc-ohello.i-Ehello.c。其中-E是对hello.c进行预处理命令，-o是对输入结果进行导入操作，这里即是将输入结果导入到hello.i。 图2-2预处理命令 2.3Hello的预处理结果解析 预处理后生成文件结果如图2-3所示 图2-3预处理后生成文件结果hello.c中文本共28行，有注释，有头文件。 图2-4hello.c文本经过预处理后共3074行，其中删除了注释，并将头文件中的stdio.hunistd.hstdlib.h展开，将所有内容放入hello.i文本中。 图2-5hello.i文本 2.4本章小结 预处理阶段，预处理器将#后代码行展开，并删除注释，gcc预处理的命令为gcc-ohello.i-Ehello.c。如此进行使得hello完成P2P的一步，为后续编译阶段打下基础。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的概念：编译器将预处理后的代码进行词法语法分析语义检查及优化后翻译成汇编语言程序。编译的作用：将不同的高级语言程序翻译成机器更好理解更通用的低级汇编语言文本。注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序。 3.2在Ubuntu下编译的命令 编译的命令为gcc-ohello.s-Shello.i其中-S是对hello.i进行编译命令，-o是对输入结果进行导入操作，这里即是将输入结果导入到hello.s。 图3-1编译的命令 3.3Hello的编译结果解析 3.3.1编译后生成文件 编译后生成文件结果如图3-2所示图3-2编译后生成文件结果 3.3.2数据处理解析 1.全局变量 图3-4全局变量在hello.c的初始化只有一个全局变量sleepsecs，大小为4字节，要求也要4字节对齐。 图3-5全局变量sleepsecssleepsecs进行了初始化所以其位于.rodata节中，同时因赋值时sleepsecs时int型对于浮点数2.5发生隐式类型转换，故实际赋值为2。图3-6全局变量sleepsecs 2.局部变量局部变量存放在寄存器或栈中，此处存放在栈-4(%rbp)里。 图3-7局部变量在hello.c的赋值 图3-8局部变量的赋值 3.形式参数 图3-9hello.c定义的形式参数前6个形式参数存放在寄存器rdi，rsi，rdx，rcx，r8，r9中，其后的参数放入栈中的参数构造区。在根据图3-7中hello.c中对argv[1],argv[2]的调用以及argc!=3的表达式，定位到hello.s中的调用，得到argc,argv[]先是位于rdi,rsi中后放入栈中。 图3-10形式参数在hello.s中的调用 4.常量字符串 图3-11hello.c中部分常量字符串常量字符串分别位于hello.s的.LC0和.LC1中。 图3-12hello.s中的字符串常量采用如图3-13的方式调用用lea指令加载具体存储地址到rdi寄存器中。 图3-13字符串常量的调用 3.3.3操作符解析 1.赋值操作符对于hello.c中的赋值操作符，均采用图3-8所示mov方式将其赋值给具体寄存器或内存位置，从而赋值给寄存器或内存位置对应参数，而对于mov后缀代码定义为赋值的字节大小。而对于赋值过程中的类型转换及初值问题于3.3.2中全局变量已有解释。 图3-14代码后缀定义2.逗号操作符逗号操作符在hello.c中当作顺序点用，对于图3-9用逗号隔开的形式参数，所位于栈中位置按一定规则排列，如图3-10所示，逗号前面的argc位于栈更低地址更高的位置，argv位于栈更高地址更低的位置。3.算术操作符对于i++操作在hello.s中的汇编代码如图3-16所示 图3-15hello.ci++操作 图3-16hello.s对应汇编代码4.关系操作符对于argc!=3和i<10这样的比较操作，在hello.s中用cmp将具体变量与立即数进行比较。 图3-17hello.s中的比较操作5.数组操作对于char*argv[]这样的数组引用，在hello.s中由图3-10得知其位于一段连续的栈中，从地址-32(%rbp)获得数组首地址后，分别加16和加8，获得argv[2],argv[1]。 3.3.4控制转移解析 对于argv!=3就执行图3-11操作，以及对i<10就继续循环的操作在hello.s中是通过cmp操作设置条件码然后根据条件采取对应jump操作到具体目标。 图3-18hello.s设置条件码并跳转 3.3.5函数操作解析 1.参数操作对于函数参数的构建是前6个参数存放在寄存器rdi，rsi，rdx，rcx，r8，r9中，其后的参数放入栈中的参数构造区。例如如图3-10main函数参数的传递，又如图3-19中寄存器rdi,rsi传递给print函数两个参数，rdi传递给sleep一个参数,rdi传递给exit一个函数 图3-19hello.s中对print函数两个参数和sleep函数一个参数传递 2.函数调用及信息如图3-19所示对于函数的调用在hello.s中采取call的汇编代码指令，包括图3-21亦是对getchar()函数调用。同时对于hello.c定义的主函数main还有关于其全局函数的信息解释。 图3-20main函数的信息 图3-21调用getchar函数3.函数返回值hello.s中的函数返回值均保存在寄存器rax中，如图3-21main函数返回0. 图3-22main函数返回值的信息 3.4本章小结 阐述了编译过程的概念与作用，用gcc的命令实现了从预处理后文件到生成汇编代码程序，并深入地解析了hello.s中各部分数据操作的含义。（第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编的概念：汇编器(as)将汇编语言程序翻译成机器语言指令，把这些指令打包成可重定位目标程序。汇编的作用：将汇编代码转换成计算机可识别的二进制文件。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。 4.2在Ubuntu下汇编的命令 汇编的命令为gcc-ohello.o-chello.s其中-c是对hello.s进行汇编命令，-o是对输入结果进行导入操作，这里即是将输入结果导入到hello.o。 图4-1汇编命令 4.3可重定位目标elf格式 ELF格式如图4-2所示 图4-2ELF格式 图4-3ELF头与节头 4.3.1 ELF头 ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，节头部表中条目的大小和数量等。 4.3.2 节头部表 节头部表则描述了各节的名称、大小、类型、地址、偏移量、对齐、读写属性等等信息。 4.3.3 重定位节 图4-4重定位节信息.rela.text是.text中重定位目标列表，链接器把这个目标文件和其他文件组合时，需要修改这些位置。同时下方每一行对应一个重定位条目，指出了每个符号的节偏移量，重定位类型，信息，符号值，对应的符号名称，和进行重定位时地址计算的加数。hello.o重定位条目包括以及只读数据节，各类函数，以及全局变量sleepsecs。.rela.eh_frame则是eh_frame节的重定位信息。 4.3.4 符号表 图4-5符号表信息Value表示节中偏移量，Size表示大小，Type表示为函数还是数据，Bind表示是否为全局的，如sleepsecs为全局变量，大小为4字节 4.4Hello.o的结果解析 图4-6hello.o反汇编结果反汇编后与hello.s进行比较后发现hello.s中的立即数均为十进制，而反汇编后的为十六进制数，同时分支转移函数调用时反汇编call指令接的是具体值，汇编代码中直接接的函数名。同时反汇编中没有.L0.L1等目标位置，对于条件跳转直接接的地址值。剩余部分机器语言二进制指令对应反汇编代码与hello.s中基本一致。 4.5本章小结 介绍了汇编的概念和作用，采用gcc命令将hello.s汇编成hello.o，同时深入地分析了汇编后的ELF格式与信息，并且对hello.o进行了反汇编并于hello.s的汇编代码进行比较。（第4章1分） 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接的作用：把必要的系统目标文件组合起来生成一个可执行目标文件。注意：这儿的链接是指从hello.o到hello生成过程。 5.2在Ubuntu下链接的命令 Ubuntu下链接的命令为:ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/lib/x86_64-linux-gnu/crt1.o/lib/x86_64-linux-gnu/crti.o/lib/x86_64-linux-gnu/libc.so/lib/x86_64-linux-gnu/crtn.ohello.o 图5-1链接命令使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 5.3可执行目标文件hello的格式 5.3.1ELF头对比图4-3我们可以发现，类型变成了可执行文件，节头增加至了27个。 图5-2ELF头 5.3.2节头部表对比图4-3我们可以发现，节头部表仍旧描述了各节的名称、大小、类型、地址、偏移量、对齐、读写属性等等信息。但增加了诸如.plt这般新的节。这里给出部分常见节的解释.init:程序初始化代码调用.text:已编译的机器代码.rodata:只读数据.plt过程链接表（ProcedureLinkageTable），包含动态链接器调用从共享库导入的函数所必须的相关代码。.data:已初始的全局和静态C变量.got节保存全局偏移表。它和.plt节一起提供了对导入的共享库函数访问的入口。.rela.dyn：动态重定位表.rela.plt：.plt节的重定位条目.gnu.hash：gnu的扩展符号hash表.eh_frame：程序执行错误时的指令.dynsym节保存共享库导入的动态符号信息。.dynstr保存动态符号字符串表，存放一系列字符串，代表了符号的名称，以空字符作为终止符。.gnu.version：符号版本.gnu.version_r：符号引用版本.bss:为初始化的全局和静态C变量及初始化为0的全局和静态变量.symtab:符号表，存放程序中定义和引用的函数和全局变量的信息.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。 图5-3节头部表5.3.3程序头hello的程序头表是一个结构数组。每种结构都描述了系统准备程序执行所需的段或其他信息。目标文件段包含一个或多个节。该程序头内共八个段，包含各段的类型，偏移量，读写属性，虚拟地址，物理地址，对齐要求，内存大小等信息。其中程序包含八个段：1.PHDR:指定程序头表在文件及程序内存映像中的位置和大小。2.INTERP:指定要作为解释程序调用的以空字符结尾的路径名的位置和大小。对于动态可执行文件，必须设置此类型。3.LOAD:指定可装入段，通过p_filesz和p_memsz进行描述。文件中的字节会映射到内存段的起始位置。4.DYNAMIC:指定动态链接信息。5.NOTE:指定辅助信息的位置和大小。6.GNU_PROPERTY:7.GNU_STACK:权限标志，标志栈是否是可执行的。8.GNU_RELRO:指定在重定位结束之后那些内存区域是需要设置只读。 图5-4程序头5.3.4段节与动态链接节信息段节中包含各段的符号名字，同时动态链接节各共享库引入的节中的名称类型。 图5-5段节和动态链接节5.3.5重定位节信息重定位节信息与4.3.3相同，只是增加了两个新的重定位符号__libc_start_main@GLIBC_2.2.5和__gmon_start__。 图5-6重定位节信息5.3.6符号表信息符号表信息与4.3.4中相同，只是增加了许多新的符号。 图5-7符号表信息 5.4hello的虚拟地址空间 图5-8edb查看虚拟地址空间可以看到虚拟空间从0x400000开始与图5-4中的LOAD段对应，其中地址0x400040与PHDR段对应，其中地址0x4002e0与INTERP对应，地址0x400300与NOTE和GNU_PROPERTY段对应，地址0x403e50与GNU_RELRO和DYNAMIC段对应。 5.5链接的重定位过程分析 图5-9objdump-d-rhello分析得到此时反汇编得到的程序包含链接函数的汇编代码，并且都取重定位后确定的地址为跳转目标，地址不再从0开始，不同区域有着不同的虚拟地址。重定位常用方法为重定位PC相对引用和重定位PC绝对引用。此处我们选取printf函数进行分析，得知main函数口的地址为0x401185结合图4-4printf的偏移量为0x5e，得到运行时地址为0x4011e3，同时得知printf函数的地址0x401090,0x401090–0x4011e3–0x4（重定位时的加数）转换为小端序的计算结果为0xa8feffff与objdumpprintf函数结果相同。 图5-10objdumpprintf函数结果 5.6hello的执行流程 其调用与跳转的各个子程序名如下：_dl_start_dl_init_start_libc_start_main__libc_csu_init_initmain_GI_IO_puts__GI_exit_fini 图5-11执行过程部分callfrom截图 5.7Hello的动态链接分析 dl_init调用之前直接进入函数对应的PLT中，接着PLT指令通过对应的GOT指令进行间接跳转，由于每个GOT指令初始时都指向他对应的PLT条目的第二条指令，所以这个间接跳转只是简单的把控制传回PLT条目的下一条指令。接着把函数的ID入栈PLT跳转到PLT[0]，PLT[0]再将动态链接器的一个参数入栈，然后间接跳转到动态链接器中。动态链接器依据两个栈条目确定函数的运行位置，重写对应的GOT条目，再把控制传给函数。在dl_init调用之后，GOT表中存放的就是对应的函数的地址。我们根据.got.plt地址发现存储的got基本为零。 图5-12dl_init调用之前调用后有新地址生成。 图5-13dl_init调用之后 5.8本章小结 本章介绍了链接的概念和作用，采用ld命令进行了动态链接，分析了链接可执行文件hello的ELF格式，节头部信息等等，并与hello.o文件对应比较，然后分析了hello的虚拟空间分布以及如何进行重定位，获取了hello从头到尾运行的子程序，最后对hello进行了动态链接分析。（第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的概念：一个执行中程序的实例。进程的作用：提供一种抽象使得我们的程序好像是系统当中当前唯一运行的程序一样。我们的程序就好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们的指令。最后我们程序中的代码和数据好像是系统内存中的唯一对象。 6.2简述壳Shell-bash的作用与处理流程 shell的作用:在交互方式下解释从命令行输入的命令，执行一系列读/求值步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并表用户运行程序。shell的处理流程：首先shell打印一个命令行提示符，等待用户在stdin上输入命令行，待输入命令行并回车后，解析这个以空格分隔的命令行参数，并构造最终会传递给execve的argv向量，同时若最后一个参数是’&’字符，表示应该在后台执行，否则应该在前台执行。解析完命令行后，开始检查第一个命令行参数是否是一个内置的shell命令。是则立即解释，否则shell创建一个子进程，并在子进程执行所请求程序，若是在后台运行则shell返回顶部，等待下一个命令行，否则shell等待作业终止再开始下一轮迭代。 6.3Hello的fork进程创建过程 我们根据shell的处理流程，在当前目录下打开shell输入./hello1190100612冯梓峻运行，shell作为父进程，通过fork函数创建一个新的运行的子进程hello。Hello子进程几乎但不完全与父进程相同，hello进程得到与父进程用户级虚拟空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库、以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，Hello进程可以读写父进程中打开的任何文件。父进程和Hello进程最大的区别在于它们有不同的PID。 图6-1hello的fork进程 6.4Hello的execve过程 如果采用execve函数来加载hello进程的话，输入参数为当前hello所在目录文件名，且带上参数列表和当前环境变量列表，同时进行上下文切换，调用启动代码，将控制传递给新程序的主函数，并不返回。 图6-2execve函数 图6-3上下文切换 6.5Hello的进程执行 当我们执行hello进程的时候，首先因未设置模式位而运行在用户模式下，同时内核会该进程维护一个上下文，即内核重新新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构。同时因为shell本身进程和其他进程与hello进程的运行时间有重叠，故他们是在并发的运行，每个进程都有它独立的逻辑控制流。而此时我们考虑由不是hello的时间片到执行hello进程的时间片时，首先进行如图6-3的上下文切换，由内核的调度器来进行调度hello进程抢占当前进程，它首先保存当前进程的上下文，然后恢复hello被抢占所保存的上下文，最后将控制传递给这个新的上下文。然后我们考虑hello进程的执行过程，在hello输出后，调用sleep函数使整个进程休眠2秒，此刻发生上下文转换，运行其他进程，两秒后hello重新抢占进程，如此运行9次。随后遇见getchar()函数会读一个文件(read)，触发一个陷阱，此时hello进程将控制传递给内核模式下的陷阱处理程序，处理程序再返回到hello进程的下一条指令，直至最后程序终止。结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 hello正常执行时Hello进程在执行中，遇见getchar()函数会读一个文件(read)，触发一个陷阱，此时hello进程将控制传递给内核模式下的陷阱处理程序，处理程序再返回到hello进程的下一条指令。同时遇见sleep函数时，亦会触发陷阱，处理方法与上述相同。最后进程会执行exit指令也是一个陷阱终止进程，并向父进程发送一个SIGCHLD信号。Ctrl-ZHello进程执行时遇见Ctrl-z后进程收到一个中断，同时收到一个SIGSTOP信号，整个进程停止。此时psjobspstreefgkill各命令运行结果如下。 图6-4ps与jobs命令 图6-5jobs命令fg命令发送一个SIGCONT信号给hello进程，使得hello进程在前台继续运行。 图6-6fg命令最后用kill命令发送一个SIGKILL信号杀死进程。 图6-7kill命令3.Ctrl-c命令Ctrl-c发送一个SIGINT信号给hello进程，最终hello进程终止。 图6-8ctrl-c命令 6.7本章小结 本章阐述了进程的概念与作用以及壳Shell-bash的作用与处理流程，同时深入地分析并理解了hello的fork和execve过程，同时理解了有关上下文信息、进程时间片，进程调度的过程，用户态与核心态转换等等诸多概念的理解过程，同时对hello进程的执行过程的异常和信号处理，以及外部造成的异常和信号处理有了更多的了解和认识。（第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：在有地址变换功能的计算机中,访问指令给出的地址(操作数)叫逻辑地址，是CPU的段内偏移地址，由两个地址分量构成，一个为段基值，另一个为偏移量。线性地址：是逻辑地址到物理地址变换之间的中间层，在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。虚拟地址：指的就是线性地址。物理地址：地址存储器中存储单元对应实际地址称物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 因CPU不支持分页机制，所以逻辑地址到线性地址的转换采用段式管理。48位逻辑地址前16位为段选择符，段选择符又分为索引，TI，RPL，其中索引为描述符表的索引，TI是0则在GDT全局描述符表中寻找，为1则在LDT局部描述符表中寻找。RPL则是段的级别。通过索引找到段基址后与后32位段内偏移量相加就是线性地址值。 图7-1段选择符 图7-2段式管理流程 7.3Hello的线性地址到物理地址的变换-页式管理 线性地址即虚拟地址，VM系统通过将虚拟内存分割位虚拟页，类似地，物理内存被分割为物理页，大小都为P字节，由于DRAM不命中昂贵的时间代价，虚拟页往往很大，于是我们采用页式管理来进行从线性地址到物理地址的变换。虚拟地址VA分为p位的VPO（虚拟页面偏移量），和(n-p)位的VPN（虚拟页号），MMU(地址管理单元)利用VPN来选择适当的PTE。如，VPN0选择PTE0，VPN1选择PTE1，以此类推。然后将页表条目中物理页号和虚拟地址中的VPO串联起来，就得到相应的物理地址。注意因为物理页面和虚拟页面都是P字节的，所以虚拟页偏移量和物理页偏移量都是相同的。 图7-3页表的地址翻译 7.4TLB与四级页表支持下的VA到PA的变换 TLB称为翻译后备缓冲器，是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB的组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号提取出来。如图T=2^t个组，索引则由VPN的t个最低位组成，而TLB标记由VPN剩下的位组成。TLB命中的步骤为，CPU产生虚拟地址MMU从TLB中取出对应PTE然后翻译成物理地址发送给高速缓存/主存，随后返回数据字给CPU，不命中时则必须从L1缓存中取出相应PTE。 图7-4虚拟地址中用以访问TLB的组成成分 图7-5TLB命中和不命中操作图 而这里我们采用COREi7地址翻译下运行的四级页表下VA到PA的变换：我们可以发现，36位VPN被划分成了4个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含Ll页表的物理地址。VPN1提供到一个LlPET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 图7-6如图为四级页表支持下VA到PA的变换 7.5三级Cache支持下的物理内存访问 三级Cache支持下的物理内存访问。 图7-7三级Cache支持下的物理内存访问 当我们获取了物理地址PA后，PA分为CT(高速缓存标记)，CI(高速缓存索引)，CO(缓冲块内的字节偏移量)三部分。首先对于当前PA根据CI在L1cache查找索引然后根据高速缓存标记CT判断是否在组内存在该块，若存在该块且标记位为1则命中，再根据CO获取块偏移后结果，将该结果返回给CPU。若不命中则按照相同的查找策略按L2cache、L3cache、主存这样以此向下查找下去，找到相应块后，若上一层组内缓存有空闲块则将它写入空闲块中，否则则采用相应策略选取牺牲块用找到的块将其替换，替换到L1后返回结果。 7.6hello进程fork时的内存映射 当shell先调用fork函数时，内核会为新进程创建如下组织的数据结构，同时分配给它一个唯一的PID。这个数据结构首先是一个任务结构task_struct。任务结构中的一个条目指向mm_struct,它描述了虚拟内存的当前状态。两个字段分别是pgd和mmap,其中pgd指向第一级页表(页全局目录)的基址,而mmp指向一个vm_area_structs(区域结构)的链表,其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时,就将pgd存放在CR3控制寄存器中。为了我们的目的,一个具体区域的区域结构包含下面的字段:vm_start:指向这个区域的起始处。vm_end:指向这个区域的结束处。vm_prot:描述这个区域内包含的所有页的读写许可权限。vm_flags:描述这个区域内的页面是与其他进程共享的,还是这个进程私有的(还描述了其他一些信息).vm_next:指向链表中下一个区域结构。 图7-8虚拟内存的组织为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。将两个进程中的每个页面都标记为已读，并将两个区域结构都标记为私有的写时复制。当fork在新进程中返回时,新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时,写时复制机制就会创建新页面,因此,也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 在fork一个新进程后shell调用execve加载并运行hello可执行文件，按如下几个步骤进行，先是删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。然后映射私有区域。为hello程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和data区。bss区域是请求二进制零的,映射到匿名文件,其大小包含在hello中。栈和堆区域也是请求二进制零的,初始长度为零。 图7-9加载器映射的地址空间再然后是映射共享区域。如果hello程序与共享对象(或目标)链接,比如标准C库1ibc.so,那么这些对象都是动态链接到这个程序的,然后再映射到用户虚拟地址空间中共享区域内。最后设置程序计数器(PC)。execve做的最后一件事情就是设置当前进程上下文中的程序计数器,使之指向代码区域的入口点。下一次调度这个进程时,它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 7.8缺页故障与缺页中断处理 当MMU在试图翻译某个虚拟地址A时，触发一个缺页。这个异常导致控制转入到内核的缺页处理程序，处理程序随后就执行下面的步骤。首先判断虚拟地址是否合法，即缺页处理程序搜索区域结构的链表将其与vm_start与vm_end作比较，不合法则触发段错误故障，从而终止进程。然后判断进程是否有读写该页面的权限，如对只读页面进行写操作这样不合法的访问，触发一个保护异常，终止进程。最后内核知道缺页是对合法的虚拟地址进行合法的操作造成的，那么它开始选择一个牺牲页面，若其被修改过，就交换出去，换入新的页面并更新页表。缺页处理程序返回则重新启动引起缺页指令，再次发送A到MMU后可正常翻译。 图7-10缺页处理 7.9动态存储分配管理 Hello的Printf会调用malloc，下面简述动态内存管理的基本方法与策略：动态内存分配器维护着一个进程的虚拟内存区域，称为堆(heap)。假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。而对于分配器采用的数据结构，分为带边界标签的隐式空闲链表和带边界标签的显示空闲链表。带边界标签的隐式空闲链表是由一个字的头部、有效载荷，以及有效载荷、可能的一些额外的填充组成。同时还在块的结尾处添加一个脚部（边界标记），其中脚部就是头部的一个副本。而显式的链表则在隐式链表的基础下增添一个pred（前驱）和succ（后继）指针。在确定了分配器的数据结构后，我们开始考虑内存管理的方法，首先对于放置分配块的策略，常见的策略有：首次适配、下一次适配、最佳适配。首次适配是从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配则是从上一次查询结束地方开始搜索。最佳适配则是检查每一个空闲块，选择适合所需的空闲块。找到匹配空闲块，则根据空间大小匹配选择整个空闲块还是分割空闲块，对于显示链表来说，分割后的空闲块采用后进先出的顺序或是按照地址顺序来维护链表。若没有足够大的空闲块来放置，则向内核请求额外的堆内存，转化为一个大的空闲块来放置。而当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻，则根据前后块的边界标记判断它是否是空闲块，是空闲块则将其合并为一个更大的空闲块。至此动态内存管理的基本方法与策略介绍完毕。 7.10本章小结 本章首先介绍了逻辑地址、线性地址、虚拟地址、物理地址的概念，随后分析了从逻辑地址到线性地址的段式管理，再介绍了从线性地址到物理地址的页式管理，介绍了TLB对虚拟地址寻找物理地址的加速，同时介绍了TLB缓存查找不命中时，通过四级页表节约内存空间来进行从VA到PA的转换。随后介绍了hello进程fork时和execve时的内存映射，对翻译虚拟地址时的缺页故障和缺页故障处理程序进行了探讨，最后简述了动态内存管理的基本方法与策略。（第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件文件的类型如下：普通文件：包含任意数据，应用程序通常要区分文本文件和二进制文件，文本文件只含有ASCII或Unicode字符；二进制文件是所有其他的文件。对内核而言，这二者没有区别。目录：目录是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。套接字：是用来和另一个进程进行跨网络通信的文件。设备管理：unixio接口输入和输出以一种的统一且一致的方式来执行。 打开文件。应用程序通过要求内核打开相应文件，内核返回一个小的非负整数，称为描述符。改变当前文件位置。对于每个打开的文件，内核保持一个位置k，初始为0。读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。关闭文件。当应用完成对文件的访问，就通知内核关闭这个文件。 8.2简述UnixIO接口及其函数 1.打开和关闭文件intopen(char*filename,intflags,mode_tmode);open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。出错则返回-1。Flags指明进程打算如何访问这个文件，mode参数指定新文件的访问权限位。intclose(intfd);进程通过调用close关闭一个打开的文件。关闭一个已关闭的描述符会出错。2.读和写文件ssize_tread(intfd,void*buf,size_tn);read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。ssize_twrite(intfd,constvoid*buf,size_tn);write函数从内存位置buf复制之多n个字节到描述符fd的当前文件位置。同样我们可以采用RIO包进行健壮的读取读写。下为RIO无缓冲的输入输出函数。 图8-1无缓冲的输入输出函数Rio_readn函数从描述符fd的当前文件位置最多传送n个字节到内存位置usrbuf，rio_writen类似。当这两个函数被一个应用信号处理程序的返回中断，每个函数都会手动地重启read或write。下为RIO带缓冲的输入函数 图8-2RIO带缓冲的输入函数 Rio_readlineb函数从文件rp读出下一个文本行，将它复制到内存位置usrbuf，并且用NULL字符来结束这个文本行。其最多都maxlen-1个字节，超过的文本行被截断，并用一个NULL字符结束。Rio_reandnb函数从文件rp最多读n个字节到内存位置usrbuf。3.读取文件元数据 图8-3读取文件元数据函数 Stat函数以一个文件名作为输入，并填写数据到如图8-4所示的数据结构里，fstat函数类似，只是以文件描述符作为输入。 图8-4stat数据结构4.读取目录内容 图8-5返回目录流指针函数 函数opendir以路径名为参数，返回指向目录流的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。 图8-6readdir函数 每次对readdir的调用返回的都是指向流dirp中下一个目录项的指针，或者，如果没有更多目录项则返回NULL。如果出错则返回NULL并设置error。 图8-7closedir函数 函数closedir关闭流并释放其所有的资源。 8.3printf的实现分析 首先我们查看printf的源码图8-8printf源码 发现定义了一个va_list类型查看它的定义typedefcharva_list发现是一个字符指针，(char)(&fmt)+4)表示的是…中的第一个参数。2.随后查看vsprintf函数的源码 图8-9vsprintf源码vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。3.反汇编查看write函数 图8-10反汇编write函数给几个寄存器传递了几个参数，然后一个intINT_VECTOR_SYS_CALL表示要通过系统来调用sys_call这个函数。4.sys_call函数 图8-11sys_call的实现它的功能是显示格式化了的字符串。将要输出的字符串从总线复制到显卡的显存中。5.字符显示驱动子程序：字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。6.显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 图8-10getchar函数内容 当调用getchar函数时，getchar调用一个read系统函数，文件描述符为0，所以是从标准输入流中读入，因此触发一个异常，进入键盘中断处理子程序，进程控制转给终端输入，而当从键盘输入字符时，接受按键扫描码转成ascii码，保存到系统的键盘缓冲区，直到接受到回车键才返回。随后控制返回给getchar函数，getchar函数返回内存位置的第一个元素。 8.5本章小结 本章是对hello中的I/O管理的总结，介绍了设备的模型化文件的概念，并介绍了IO的设备管理方法。随后对I/O打开和关闭、读写、读取元数据、目录等基本函数做了介绍。深入分析了hello中printf和getchar函数的I/O实现。（第8章1分） 结论 一开始hello.c是一个程序文本文件，经过预处理器cpp读取头文件后修改生成了hello.i源程序，再经过编译器ccl翻译成汇编语言得到汇编程序hello.s，然后经过汇编器as翻译成机器语言程序hello.o，最后经过链接器ld链接生成可执行目标程序hello。然后运行shell并fork一个子进程，调用execve函数在当前进程的上下文加载并运行hello程序，该进程映射它的虚拟空间到文件，运行的过程当中伴随着虚拟地址到物理地址的转换，调用的函数与I/O设备紧密结合，当进程的一切终止时，被shell所回收，内核清除掉它的痕迹。至此hello一生结束，计算机系统的课程也告一段落。几百页书籍的翻看，成百上千小时的学习，最后凝结在hello这短短的一生，计算机系统就是这般，晦涩难懂到渐入佳境，书越读越薄，最后便是大道至简。回顾学习，还是有许多地方没来的及深入学习，还有很多实验能够进一步优化和进步，还有很多细节没来的及分析。有收获，也有遗憾，希望自己能在未来进一步的学习，真正做到计算机系统的融会贯通。（结论0分，缺失-1分，根据内容酌情加分） 附件 中间结果文件文件作用使用时期hello.c本次大实验使用的程序整个过程hello.i预处理后得到的文本文件第二章-预处理hello.s编译后的文本文件第三章-编译hello.o汇编后得到的可重定位目标文件（二进制）第四章-汇编helloo.asm反汇编hello.o得到的文本文件第四章-汇编helloo.elfhello.o的elf文件第四章-汇编hello链接后得到的可执行目标文件（二进制）第五章-链接hello.elfhello的elf文件第五章-链接hello.asmhello的反汇编文件第五章-链接 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等[1]链接程序和库指南[N/OL]https://docs.oracle.com/cd/E38902_01/html/E38861/chapter6-83432[2]用gcc编译c语言程序以及其编译过程[N/OL]https://blog.csdn.net/weixin_33755847/article/details/89697445[3]Linux下可视化反汇编工具EDB基本操作知识[N/OL]https://blog.csdn.net/hahalidaxin/article/details/84442132[3]通俗理解CPU中物理地址、逻辑地址、线性地址、虚拟地址、有效地址的区别[N/OL]https://blog.csdn.net/mzjmzjmzjmzj/article/details/84713351[4]printf函数实现的深入剖析[N/OL]https://www.cnblogs.com/pianist/p/3315801.html[5]RandalE.Bryant,DavidR.O’Hallaon.深入理解计算机系统.第三版.北京市：机械工业出版社[M].2018：1-737（参考文献0分，缺失-1分） 

线段树&树状数组模板 线段树模板 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<map> #include<queue> #include<set> #definefr(i,a,b)for(inti=a;i<=b;i++) usingnamespacestd; typedeflonglongll; constintmaxn=100005; intn,q; lltree[4*maxn+1]; lllz[4*maxn+1]; voidbuild(intnode,intl,intr) { if(l==r) { scanf("%lld",&tree[node]); return; } intmid=(l+r)>>1; build(node*2,l,mid); build(node*2+1,mid+1,r); tree[node]=tree[node*2]+tree[node*2+1]; } voidupdate(intnode,intl,intr,intindex) { if(l==r) { tree[node]=index; return; } intmid=(l+r)>>1; if(index<=mid) update(node*2,l,mid,index); else update(node*2+1,mid+1,r,index); tree[node]=tree[node*2]+tree[node*2+1]; } voidpush_down(intnode,intl,intr) { if(l==r) { lz[node]=0; return; } if(lz[node]) { intmid=(l+r)>>1; tree[2*node]+=(mid-l+1)*lz[node]; tree[2*node+1]+=(r-mid)*lz[node]; lz[2*node]+=lz[node]; lz[2*node+1]+=lz[node]; lz[node]=0; } } voidupdate_range(intnode,intl,intr,intL,intR,intadd) { if(l>=L&&R>=r) { lz[node]+=add; tree[node]+=(r-l+1)*add; return; } push_down(node,l,r); intmid=(l+r)>>1; if(mid>=L) update_range(node*2,l,mid,L,R,add); if(mid<R) update_range(node*2+1,mid+1,r,L,R,add); tree[node]=tree[node*2]+tree[node*2+1]; } llquery_range(intnode,intl,intr,intL,intR) { if(l>=L&&R>=r)returntree[node]; push_down(node,l,r); intmid=(l+r)>>1; llsum=0; if(mid>=L) sum+=query_range(node*2,l,mid,L,R); if(mid<R) sum+=query_range(node*2+1,mid+1,r,L,R); returnsum; } intmain() { //freopen("in.txt","r",stdin); scanf("%d",&n); build(1,1,n); memset(lz,0,sizeof(lz)); return0; } 板子敲错两遍就离谱  树状数组模板 #include<cstdio> #include<cmath> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<queue> #include<set> usingnamespacestd; typedeflonglongll; constintmaxn=500005; intC[maxn]; intlowbit(intx) { return(-x)&x; } voidinsert(inti,intw) { while(i<=n) { C[i]+=w; i+=lowbit(i); } } intquery(inti) { intsum=0; while(i>=1) { sum+=C[i]; i-=lowbit(i); } returnsum; } intmain() { //freopen("in.txt","r",stdin); return0; } 果然树状数组好敲很多哇QAQ 

高精度压位模板 #include<cstdio> #include<iostream> #include<cstdlib> #include<cstring> #include<algorithm> #include<queue> #defineinf1000000000] #definep9//注意乘法压位过大 usingnamespacestd; void_scanf(int&x){ charch=getchar(); boolf=0; x=0; while(!isdigit(ch)){ if(ch=='-')f=1; ch=getchar(); } while(isdigit(ch))x=10*x+ch-'0',ch=getchar(); if(f)x=-x; } void_scanf(int&a,int&b){ _scanf(a); _scanf(b); } structbign{ intz[25],len; bign(){ memset(z,0,sizeof(z)); len=0; } bign(intx){ *this=x; } bignoperator=(intx){ chars[25]; sprintf(s,"%d",x); *this=s; } bignoperator=(char*s){ intlen=strlen(s); intcur=0; bigna; charw[25]; while(len>0){ while(len>=p){ strcpy(w,s+len-p); a.z[cur++]=atoi(w); len-=p; } if(len>0){ strcpy(w,s); w[len]='\0'; a.z[cur++]=atoi(w); len=0; } } a.len=cur; *this=a; } friendbignoperator+(bigna,bignb){ bignc; intlen=max(a.len,b.len)+1; for(inti=0;i<=len-1;i++){ c.z[i]=a.z[i]+b.z[i]; } for(inti=0;i<=len-1;i++) c.z[i+1]+=c.z[i]/1000000000,c.z[i]%=1000000000; while(c.z[len-1]==0&&len>1)len--; c.len=len; returnc; } }; voidbignout(bigna){ intlen=a.len; printf("%d",a.z[len-1]); for(inti=len-2;i>=0;i--) printf("%0*d",p,a.z[i]); } 

HDU-4460FriendChains（邻接表&BFS） 小白日记.2HDU-4460FriendChains 题目大意：如果两个人互为朋友则距离为一，距离可累加，求一群人中任意两个人之间的最短距离的最大值。 常见的BFS利用邻接表剪枝 代码如下： #include<iostream> #include<stdio.h> #include<string.h> #include<queue> #include<iostream> #include<string> #include<map> usingnamespacestd; map<string,int>m; vector<int>gx[1007]; intcc[1007]; intk=0,ok=0,N; structnode{ intp; intt; }; voidBfs(intx) { memset(cc,0,sizeof(cc)); queue<node>q; nodenow,next; now.p=x; now.t=0; q.push(now); cc[x]=1; while(!q.empty()){ now=q.front(); q.pop(); for(inti=0;i<gx[now.p].size();i++){//利用邻接表简化代码 intj=gx[now.p][i]; if(cc[j]==0){ next.p=j; next.t=now.t+1; q.push(next); cc[j]=1;//查重剪枝 k=max(k,next.t); } } } for(inti=0;i<N;i++){ if(cc[i]==0){ ok=1; } } } intmain() { intc; stringstr; while(cin>>N&&N){ ok=0; k=0; m.clear(); for(inti=0;i<N;i++){//初始化 gx[i].clear(); } for(inti=0;i<N;i++){ cin>>str; m[str]=i;//将字符串映射为数字 } cin>>c; while(c--){ inta1,a2; cin>>str; a1=m[str]; cin>>str; a2=m[str]; gx[a1].push_back(a2); gx[a2].push_back(a1);//建立邻接表 } for(inti=0;i<N;i++){ Bfs(i); if(ok==1)break; } if(ok==1) cout<<-1<<endl; else cout<<k<<endl; } return0; } 总结与收获：1.邻接表的使用2.map将字符串映射为数字3.初始化 

HDU1240Asteroids!（三维BFS） #小白日记.1HDU1240Asteroids! 题目大意：三维空间的走迷宫。注意题目中x，y，z坐标的定义。 比较常规的BFS题目需要用到三维数组 下面是代码： #include<iostream> #include<stdio.h> #include<string.h> #include<queue> #include<iostream> #include<string> usingnamespacestd; charmaze[11][11][11];//地图 intN,ax,ay,az,bx,by,bz,ok; structnode{ intx,y,z; intt;//第几步 }; intwlk[6][3]={{0,0,1},{0,0,-1},{0,1,0},{0,-1,0},{1,0,0},{-1,0,0}};//六个方向行走 intJudge(intx,inty,intz){//判断是否可以走 if(x>=0&&x<N&&y>=0&&y<N&&z>=0&&z<N&&maze[x][y][z]=='O') return1; elsereturn0; } voidBfs() { ok=0; nodenow,next; queue<node>q; now.x=ax; now.y=ay; now.z=az; now.t=0; maze[ax][ay][az]='X'; q.push(now); while(!q.empty()){ now=q.front(); q.pop(); if(now.x==bx&&now.y==by&&now.z==bz){ ok=1; cout<<N<<""<<now.t<<endl; break; } next.t++; for(inti=0;i<6;i++){ next.x=now.x+wlk[i][0]; next.y=now.y+wlk[i][1]; next.z=now.z+wlk[i][2]; next.t=now.t+1;// if(Judge(next.x,next.y,next.z)){ //cout<<next.x<<""<<next.y<<""<<next.z<<""<<next.t<<""<<endl;// maze[next.x][next.y][next.z]='X'; q.push(next); } } } } intmain() { stringstr; while(cin>>str){ cin>>N; for(inti=0;i<N;i++){ for(intj=0;j<N;j++){ for(intk=0;k<N;k++){ cin>>maze[i][j][k]; } } } cin>>ay>>az>>ax>>by>>bz>>bx; cin>>str; Bfs(); if(ok==0) cout<<"NOROUTE"<<endl; } return0; } 总结与收获：1.struct定义三位点与步数的应用。2.wlk数组的使用，可以简化代码。3.剪枝，注意初始位置。4.Judge函数的应用。 

Ubuntu--用GCC编译helloworld的c程序 安装好Ubuntu之后，最重要的就是用Linux系统进行编译，在查找了许多资料之后，终于能够运行出一个helloworld的c程序了，以下是编译的过程演示 1.安装gcc编译器 打开命令行快捷键：ctrl+alt+T只有安装了gcc才能进行编译，所以安装gcc是第一步。 （1）首先更新包列表：sudoaptupdate输入密码时不会显示密码，输入之后直接按回车就可以了 （2）安装软件包：sudoaptinstallbuild-essential这个软件包已经包含了gcc、g++等（或者可以输入sudoapt-getinstallgcc/g++,分别安装gcc和g++） （3）安装之后验证gcc版本：gcc--version 引用https://www.linuxidc.com/Linux/2019-06/159059.htm 2.创建helloworld程序 vi编辑器是Linux系统下标准的编辑器 （1）通过vim创建一个文档demo1.c：（2）进入下面这个页面之后无法进行编辑，因为目前还是命令行模式（3）输入i之后进入插入模式，可以开始进行编辑：（4)输入相应的程序注意：按下esc键，输入：wq！保存文件，这里一定要做！！！按回车键，输入ls键验证文件是否保存 3.运行helloworld程序 确定c文件存在后，使用命令gccc文件名-o生成的可执行文件名(例：gccdemo1.c-odemo1)。输入编译命令后，如果没显示什么信息，就意味编译成功了编译成功后，再用ls命令查看一下可执行文件是否有生成最后再运行一下可执行文件，可以看到，正确输出语句：HelloWorld！ 引用：https://zhidao.baidu.com/question/2202210069320880548.html 

力扣---数组专题I(简单) 题目名称 1.867--转置矩阵--简单2.面试题17.10.主要元素3.977-有序数组的平方4.628-三个数的最大乘积5.219-存在重复元素II6.228-汇总区间7.1-两数之和8.167-两数之和II-输入有序数组 1.867–转置矩阵–简单 (1)题目条件：（2）题解： 该题的目的是对已知矩阵进行转置，由于矩阵的行数和列数可能不相等，对于一个m行n列的矩阵，利用vector创建一个n行m列的空矩阵res，进行赋值操作，res[j][i]=matrix[i][j]。 classSolution{ public: vector<vector<int>>transpose(vector<vector<int>>&matrix){ intm=matrix.size(),n=matrix[0].size(); vector<vector<int>>res(n,vector<int>(m)); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ res[j][i]=matrix[i][j]; } } returnres; } }; 2.面试题17.10.主要元素 （1）题目条件：（2）题解： 摩尔投票法:在网上看到了一个形象的比喻，多个候选人要选举总统，如果其中一个人获得选票比其他人加起来的还多，那么即使进行一对一的比拼，最后剩下的还是这个人。 算法步骤：I.遍历数组元素，从第一个元素开始，计数器初始设置为0，st设置为数组第一个元素II.遇到与st相同的元素时，count加1，否则，count减一。若count=0时，st更换为现在的元素III.最后重新遍历一遍数组，看st的数量是否超过数组元素的一半，若超过一半，则返回该元素，否则返回-1. classSolution{ public: intmajorityElement(vector<int>&nums){ intn=nums.size(); if(n==0)return-1; intst=nums[0],count=0; for(inti=0;i<n;i++){ if(nums[i]==st){ count++; } else{ count--; if(count<=0){ st=nums[i]; count=1; } } } count=0; for(inti=0;i<n;i++){ if(st==nums[i])count++; } if(count>n/2)returnst; elsereturn-1; } }; 排序方法： 将数组从小到大排序，若某个元素数量超过数组元素个数一半，数组最中间的元素一定是该元素。 classSolution{ public: intmajorityElement(vector<int>&nums){ intn=nums.size(); if(n==0)return-1; sort(nums.begin(),nums.end());//对数组从小到大排序 intmid=nums[n/2]; intcount=0;//设置计数器 for(inti=0;i<n;i++){ if(mid==nums[i])count++; } if(count>n/2)returnmid; elsereturn-1; } }; 3.977-有序数组的平方 （1）题目条件：（2）解题方法： 暴力算法 先将数组元素都平方，然后将数组重新排序 classSolution{ public: vector<int>sortedSquares(vector<int>&nums){ intn=nums.size(); for(inti=0;i<n;i++){ nums[i]=nums[i]*nums[i]; } sort(nums.begin(),nums.end()); returnnums; } }; 双指针 题目条件给出数组是非递减顺序排列的，对于正数来说，平方之后顺序不变，对于负数来说，平方之后顺序反转，所以平方后的最大值出现在数组开头或者结尾，最小值出现在数组中间。 classSolution{ public: vector<int>sortedSquares(vector<int>&nums){ intn=nums.size()-1; inti,j; vector<int>ans(nums.size(),0); for(i=0,j=nums.size()-1;i<=j;){ if(nums[i]*nums[i]<nums[j]*nums[j]){ ans[n--]=nums[j]*nums[j]; j--; } else{ ans[n--]=nums[i]*nums[i]; i++; } } returnans; } }; 4.628-三个数的最大乘积 （1）题目条件：（2）题解： 最大值可能出现的情况只有两种，一种是三个全是正数，即数组最大的三个正数，另一种是两个负数一个正数，最小的两个负数和最大的一个正数 排序法 classSolution{ public: intmaximumProduct(vector<int>&nums){ sort(nums.begin(),nums.end()); intn=nums.size(); returnmax(nums[0]*nums[1]*nums[n-1],nums[n-3]*nums[n-2]*nums[n-1]); } }; 非排序法 是要找到最大的三个值和最小的两个值就可以了 classSolution{ public: intmaximumProduct(vector<int>&nums){ intn=nums.size(); intmax1=-1000,max2=-1000,max3=-1000;//第一、第二、第三大的数 intmin1=1000,min2=1000;//第一、第二小的数 for(inti=0;i<n;i++){ if(nums[i]>=max1){//大于最大的数 max3=max2;max2=max1;max1=nums[i]; } elseif(nums[i]>=max2){//在max1和max2之间 max3=max2;max2=nums[i]; } elseif(nums[i]>=max3){//在max2和max3之间 max3=nums[i]; } if(nums[i]<=min1){//比最小值还小 min2=min1;min1=nums[i]; } elseif(nums[i]<=min2){//在min1和min2之间 min2=nums[i]; } } returnmax(min1*min2*max1,max3*max2*max1); } }; 5.219-存在重复元素II （1）题目条件：（2）题解： 哈希表HashSet，HashSet继承于set类，set类的元素都是唯一的。算法步骤：i.构造一个哈希表set，让哈希表的长度始终为kii.遍历整个数组，看遍历的元素是否已经存在于set集合中了，若在集合中，则返回true，若没在集合中，则将该元素加入哈希表，若哈希表的长度超过k，则将最先加入的元素移除 解法说明：https://leetcode-cn.com/problems/contains-duplicate-ii/solution/hua-jie-suan-fa-219-cun-zai-zhong-fu-yuan-su-ii-by/ classSolution{ publicbooleancontainsNearbyDuplicate(int[]nums,intk){ HashSet<Integer>set=newHashSet<>(); for(inti=0;i<nums.length;i++){ if(set.contains(nums[i]))returntrue; set.add(nums[i]); if(set.size()>k){ set.remove(nums[i-k]); } } returnfalse; } } 6.228-汇总区间 （1）题目条件：（2）题解： 代码注意事项i.while(i<n&&nums[i-1]+1==nums[i])要先写i<n，因为若数组只有一个元素，则i<n是错误的直接不进行循环，但若是先写后面的条件，由于nums[i]不存在，所以会报错（这个问题找了好久）ii.c++中存在string类，将数字转换成字符可以使用to_string函数，在后面添加元素可以用append函数 classSolution{ public: vector<string>summaryRanges(vector<int>&nums){ inti=0; vector<string>ret; intn=nums.size(); while(i<n){ intlow=i; i++; while(i<n&&nums[i-1]+1==nums[i]){ i++; } inthigh=i-1; stringtemp=to_string(nums[low]); if(low<high){//证明存在一个区间 temp.append("->"); temp.append(to_string(nums[high])); } ret.push_back(temp); } returnret; } }; 7.1-两数之和 （1）题目条件： （2）题解： 暴力枚举 classSolution{ public: vector<int>twoSum(vector<int>&nums,inttarget){ intn=nums.size(); for(inti=0;i<n;i++){ intj=i+1; while(j<n){ if(nums[i]+nums[j]==target){ returnvector<int>{i,j}; } else{ j++; } } } returnvector<int>{-1,-1}; } }; 哈希表 classSolution{ publicint[]twoSum(int[]nums,inttarget){ Map<Integer,Integer>map=newHashMap<>(); for(inti=0;i<nums.length;i++){ if(map.containsKey(target-nums[i])){ returnnewint[]{map.get(target-nums[i]),i}; } map.put(nums[i],i); } returnnewint[]{-1,-1}; } } 8.167-两数之和II-输入有序数组 （1）题目条件： （2）题解：利用数组有序的条件 二分查找固定第一个值，寻找第二个值的时候用二分查找的方法能缩短查找时间，提高效率。 classSolution{ public: vector<int>twoSum(vector<int>&numbers,inttarget){ intn=numbers.size(); for(inti=0;i<n;i++){ intlow=i+1,high=n-1; while(low<=high){ intmid=(high-low)/2+low; if(numbers[mid]==target-numbers[i]){ return{i+1,mid+1}; } elseif(numbers[mid]>target-numbers[i]){ high=mid-1; } else{ low=mid+1; } } } return{-1,-1}; } }; 双指针初始时将两个指针放在数组两侧，sum为两个指针指向数据之和若sum==target，则找到唯一解若sum<target，左指针向右移，增大sum若sum>target，右指针向左移，减小sum classSolution{ public: vector<int>twoSum(vector<int>&numbers,inttarget){ intlow=0,high=numbers.size()-1; while(low<high){ intsum=numbers[low]+numbers[high]; if(sum==target){ return{low+1,high+1}; } elseif(sum>target){ high--; } else{ low++; } } return{-1,-1}; } }; ``` 

gcc常用命令行编译指令 1.gcc-Esource_file.c -E，只执行到预编译。直接输出预编译结果。 2.gcc-Ssource_file.c -S，只执行到源代码到汇编代码的转换，输出汇编代码。 3.gcc-csource_file.c -c，只执行到编译，输出目标文件。 4.gcc(-E/S/c/)source_file.c-ooutput_filename -o,指定输出文件名，可以配合以上三种标签使用。-o参数可以被省略。这种情况下编译器将使用以下默认名称输出：-E：预编译结果将被输出到标准输出端口（通常是显示器）-S：生成名为source_file.s的汇编代码-c：生成名为source_file.o的目标文件。无标签情况：生成名为a.out的可执行文件。 5.gcc-gsource_file.c -g，生成供调试用的可执行文件，可以在gdb中运行。由于文件中包含了调试信息因此运行效率很低，且文件也大不少。这里可以用strip命令重新将文件中debug信息删除。这是会发现生成的文件甚至比正常编译的输出更小了，这是因为strip把原先正常编译中的一些额外信息（如函数名之类）也删除了。用法为stripa.out 6.gcc-ssource_file.c -s,直接生成与运用strip同样效果的可执行文件（删除了所有符号信息）。 7.gcc-Osource_file.c -O（大写的字母O），编译器对代码进行自动优化编译，输出效率更高的可执行文件。-O后面还可以跟上数字指定优化级别，如：gcc-O2source_file.c数字越大，越加优化。但是通常情况下，自动的东西都不是太聪明，太大的优化级别可能会使生成的文件产生一系列的bug。一般可选择2；3会有一定风险。 8.gcc-Wallsource_file.c -W，在编译中开启一些额外的警告（warning）信息。-Wall，将所有的警告信息全开。 9.gccsource_file.c-L/path/to/lib-lxxx-I/path/to/include -l,指定所使用到的函数库，本例中链接器会尝试链接名为libxxx.a的函数库。-L，指定函数库所在的文件夹，本例中链接器会尝试搜索/path/to/lib文件夹。-I,指定头文件所在的文件夹，本例中预编译器会尝试搜索/path/to/include文件夹。 示例：在linux下已经创建了一个hello.c文件(1)hello.c-->hello.i:gcc-Ehello.c-ohello.i(预编译的结果)(2)hello.i-->hello.s:gcc-Shello.c-ohello.s(产生汇编代码）(3)hello.s-->hello.o:gcc-chello.s-ohello.o(4)hello.o-->hello.out:gcchello.c-ohello.out 原文链接：https://blog.csdn.net/zhubaohua_bupt/article/details/52763639 

CSAPP--DataLab 目录 前言1.bitXor2.tmin3.isTmax4.allOddBits5.negate6.isAsciiDigit7.conditional8.isLessOrEqual9.logicalNeg10.howManyBits11.floatScale212.floatFloat2Int13.floatPower2 前言 在看完csapp第二章之后，上网找了配套的lab做，发现难度不是一般的大，附上实验链接：csapp实验网站，直接点Self-StudyHandout就可以下载实验的资料，做实验之前要先把前面的README之类的先都看一遍，看一下实验要求 1.bitXor //1 /* *bitXor-x^yusingonly~and& *Example:bitXor(4,5)=1 *Legalops:~& *Maxops:14 *Rating:1 */ 题目条件：手动实现异或 x&y能够得到x、y都为1的位，(~x&~y)能够得到x、y都为0的位，由于异或是两者相同取零，所以要对两者都取反，即~(~x&~y)&~(x&y)，可能还比较懵，举例说明一下 intbitXor(intx,inty){ return~(~x&~y)&~(x&y); } 2.tmin /* *tmin-returnminimumtwo'scomplementinteger *Legalops:!~&^|+<<>> *Maxops:4 *Rating:1 */ 题目条件：返回TMin TMin是符号位为1，其余位都是0，通过移位操作即可实现，1<<31是将第31位的1移到第一位，其余位用零填补 inttmin(void){ return1<<31; } 3.isTmax /* *isTmax-returns1ifxisthemaximum,two'scomplementnumber, *and0otherwise *Legalops:!~&^|+ *Maxops:10 *Rating:1 */ 题目条件：如果1是TMax，则返回1，否则返回0 TMin是符号位为1，其余位都是0，TMax是~(1<<31)，x与TMax取异或，之后再取反，即可得到结果 intisTmax(intx){ return!(x^(~(1<<31))); } 4.allOddBits /* *allOddBits-return1ifallodd-numberedbitsinwordsetto1 *wherebitsarenumberedfrom0(leastsignificant)to31(mostsignificant) *ExamplesallOddBits(0xFFFFFFFD)=0,allOddBits(0xAAAAAAAA)=1 *Legalops:!~&^|+<<>> *Maxops:12 *Rating:2 */ 题目条件：如果奇数位值都为1，则返回1，否则返回0 可以通过掩码的方式，得到奇数位的值，同时将偶数位设置为0将wall设置为0xAA，则前8位满足奇数位为1，偶数位为0，通过移位得到了wall=0xAAAAAAAA，将x与wall相与，得到x的奇数位的值，再将其与wall相异或，看奇数位是否仍为1（这里存在一点疑问，本来我是想要直接将wall设置成0xAAAAAAAA，但是网上的答案都是通过移位实现的，感觉应该没什么区别吧…） intallOddBits(intx){ intwall=0xAA; wall=wall+(wall<<8)+(wall<<16)+(wall<<24) return!(wall^(x&wall)); } 5.negate /* *negate-return-x *Example:negate(1)=-1. *Legalops:!~&^|+<<>> *Maxops:5 *Rating:2 */ **题目条件：得到值的非** 根据csapp书上的公式，-x=~x+1即可求解 intnegate(intx){ return(~x+1); } 6.isAsciiDigit /* *isAsciiDigit-return1if0x30<=x<=0x39(ASCIIcodesforcharacters'0'to'9') *Example:isAsciiDigit(0x35)=1. *isAsciiDigit(0x3a)=0. *isAsciiDigit(0x05)=0. *Legalops:!~&^|+<<>> *Maxops:15 *Rating:3 */ 题目条件：如果x值在0x30到0x39之间，则返回1，否则返回0 与边界值进行比较，如果在0x30和0x39之间，左右两边的符号位都为0，向右移动31位之后仍为0，若是不满这个条件，则左右两边或的结果是全为1，取反之后得到零 intisAsciiDigit(intx){ return!(((x-0x30)>>31)|((0x39-x)>>31)); } 7.conditional /* *conditional-sameasx?y:z *Example:conditional(2,4,5)=4 *Legalops:!~&^|+<<>> *Maxops:16 *Rating:3 */ 题目条件：如果x为真，返回y，如果不为真，则返回z 此题解法十分巧妙，将x化为布尔值，也就是说，x为0时，布尔值为0x00…00，x为其他值时，布尔值为0x00…01。对x的布尔值取反加1，当x为0，val全为0，当x不为0时，val全为1利用或运算，当val取1时，返回y，当val取0时，返回z intconditional(intx,inty,intz){ intval=~(!!x)+1; return(val&y)|(~val&z); } 8.isLessOrEqual /* *isLessOrEqual-ifx<=ythenreturn1,elsereturn0 *Example:isLessOrEqual(4,5)=1. *Legalops:!~&^|+<<>> *Maxops:24 *Rating:3 */ 题目条件：如果x<=y，则返回1，否则返回0 分情况讨论：如果x、y符号位相同，则比较x-y的值即可如果符号位不同，x符号位为0时返回0，x符号位为1时返回1 如果x和y符号位相同，则val1=0，若x<=y，则val2全1，若x>y,则val2全0若符号位不同，则val1=1利用位或表达式得到val2和val3的值 intisLessOrEqual(intx,inty){ intval1=(x<<31)+(y<<31); intval2=!((y+~x+1)>>31); intval3=(x>>31)&1; return(val1&val3)|(~val1&val2)； } 9.logicalNeg /* *logicalNeg-implementthe!operator,usingallof *thelegaloperatorsexcept! *Examples:logicalNeg(3)=0,logicalNeg(0)=1 *Legalops:~&^|+<<>> *Maxops:12 *Rating:4 */ 题目条件：实现x逻辑非 0的非是1，其他值的非都是0如果x为0，x|x的符号位是0，向右移31位再加1能得到1，而其他的值与自身的复数进行或操作的符号位为1，向右移31位再加1能得到0 intlogicalNeg(intx){ return(x|(~x+1))>>31+1; }  剩下的等之后再补充吧，感觉前面的还是挺难想的，先把题目放在这里了 10.howManyBits /*howManyBits-returntheminimumnumberofbitsrequiredtorepresentxin *two'scomplement *Examples:howManyBits(12)=5 *howManyBits(298)=10 *howManyBits(-5)=4 *howManyBits(0)=1 *howManyBits(-1)=1 *howManyBits(0x80000000)=32 *Legalops:!~&^|+<<>> *Maxops:90 *Rating:4 */ inthowManyBits(intx){ return0; } 11.floatScale2 /* *floatScale2-Returnbit-levelequivalentofexpression2*ffor *floatingpointargumentf. *Boththeargumentandresultarepassedasunsignedint's,but *theyaretobeinterpretedasthebit-levelrepresentationof *single-precisionfloatingpointvalues. *WhenargumentisNaN,returnargument *Legalops:Anyinteger/unsignedoperationsincl.||,&&.alsoif,while *Maxops:30 *Rating:4 */ 题目条件： unsignedfloatScale2(unsigneduf){ return2; } 12.floatFloat2Int /* *floatFloat2Int-Returnbit-levelequivalentofexpression(int)f *forfloatingpointargumentf. *Argumentispassedasunsignedint,but *itistobeinterpretedasthebit-levelrepresentationofa *single-precisionfloatingpointvalue. *Anythingoutofrange(includingNaNandinfinity)shouldreturn *0x80000000u. *Legalops:Anyinteger/unsignedoperationsincl.||,&&.alsoif,while *Maxops:30 *Rating:4 */ intfloatFloat2Int(unsigneduf){ return2; } 13.floatPower2 /* *floatPower2-Returnbit-levelequivalentoftheexpression2.0^x *(2.0raisedtothepowerx)forany32-bitintegerx. * *Theunsignedvaluethatisreturnedshouldhavetheidenticalbit *representationasthesingle-precisionfloating-pointnumber2.0^x. *Iftheresultistoosmalltoberepresentedasadenorm,return *0.Iftoolarge,return+INF. * *Legalops:Anyinteger/unsignedoperationsincl.||,&&.Alsoif,while *Maxops:30 *Rating:4 */ unsignedfloatPower2(intx){ return2; } 参考：1.https://www.cnblogs.com/panhz/p/13450085.html2.https://zhuanlan.zhihu.com/p/149689152 

CSAPP练习题3.4 题目条件 src_t*sp;dest_t*dp;sp和dp的值分别存储在寄存器%rdi和寄存器%rsi中，表中每个表项应实现两条指令，第一条是从内存中读数，做适当的转换，并设置寄存器%rax的适当部分。第二条指令是要把%rax的适当部分写到内存。在这两种情况下，寄存器的部分可以是%rax,%eax,%ax或%al。当执行强制类型转换既涉及大小变化又涉及C语言中符号变化时，操作应先改变大小 要求实现：*dp=(dest_t)*sp; src_tdest_t指令longlongcharintcharunsignedunsignedcharlongintcharunsignedunsignedcharcharshort 这个转换比较繁琐，但是根据csapp书上图3-4、图3-5、图3-6的知识点就能完成相应的转换，下面来一行一行的进行推导 1.long-->long long是8个字节，8个字节的转换用movq，存储器是64位，所以用%rax。 读取8字节：movq(%rdi),%rax存储8字节：movq%rax,(%rsi) 2.char-->int char是1个字节，int是4个字节，并且是有符号数，进行符号扩展，movs是符号扩展，由于要扩展到4字节，所以用movsbl。4个字节的存储器用%eax。 读1个字节并进行符号扩展：movsbl(%rdi),%eax存储4字节：movl%eax,(%rsi) 3.char-->unsigned char是1个字节，unsigned是4个字节，已知当执行强制类型转换既涉及大小变化又涉及C语言中符号变化时，操作应先改变大小，所以先将char转换为int，选择符号扩展，存储器选用%eax。 读1个字节并进行符号扩展：movsbl(%rdi),%eax存储4字节：movl%eax,(%rsi) 4.unsignedchar-->long unsignedchar是1个字节，long是8个字节，应先改变大小，将char转换为long，由于char是无符号数，所以进行零扩展，选择movzbq，存储器选择%rax。 读1个字节并进行零扩展：movzbq(%rdi),%rax存储8字节：movq%rax,(%rsi) 这道题第一条指令的答案是movzbl(%rdi),%eax，之前上网查好像是与cpu有关，但是我没太弄懂，感觉按原理来说应该是我上面的答案 5.int-->char int是4个字节，char是1个字节，所以先将int的值从内存复制到存储器中，在从存储器中存低位字节即可。 读4个字节：movl(%rdi),%eax存低位字节：movb%al,(%rsi) 6.unsigned-->unsignedchar 这个与第五个是一样的原理，就不复述了。 读4个字节：movl(%rdi),%eax存低位字节：movb%al,(%rsi) 7.char-->short char是1个字节，short是2个字节，由于是有符号数，所以进行符号扩展，存储器选择%ax。 读1个字节并进行符号扩展：movsbw(%rdi),%ax存两个字节：movw%ax,(%rsi) 

HIThello的一生---2021大作业 程序人生-Hello’sP2P 摘要第1章：概述1.1HELLO简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在UBUNTU下预处理的命令2.3HELLO的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2在UBUNTU下编译的命令3.3HELLO的编译结果解析3.3.1数据3.3.2赋值3.3.3关系操作3.3.4算术操作3.3.5函数操作 3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在UBUNTU下汇编的命令4.3可重定位目标ELF格式4.4HELLO.O的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在UBUNTU下链接的命令5.3可执行目标文件HELLO的格式5.4HELLO的虚拟地址空间5.5链接的重定位过程分析5.6HELLO的执行流程5.7HELLO的动态链接分析5.8本章小结 第6章HELLO进程管理6.1进程的概念与作用6.2简述壳SHELL-BASH的作用与处理流程6.3HELLO的FORK进程创建过程6.4HELLO的EXECVE过程6.5HELLO的进程执行6.6HELLO的异常与信号处理6.7本章小结 第7章HELLO的存储管理7.1HELLO的存储器地址空间7.2INTEL逻辑地址到线性地址的变换-段式管理7.3HELLO的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.5三级CACHE支持下的物理内存访问7.6HELLO进程FORK时的内存映射7.7HELLO进程EXECVE时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章HELLO的IO管理8.1LINUX的IO设备管理方法8.2简述UNIXIO接口及其函数8.3PRINTF的实现分析8.4GETCHAR的实现分析8.5本章小结 结论附件参考文献 摘要 本文以hello.c程序为源程序，首先对该程序进行预处理，得到hello.i，之后对得到的文件进行编译，得到汇编文件hello.s，再之后对得到的文件进行汇编，得到可重定位目标文件hello.o，最终通过与其他文件链接，得到一个可执行文件hello。在得到这些文件之后，分别对其内容进行了分析。 得到可执行文件之后，在linux系统下进行进程管理分析，包括进程的执行过程与信号的异常处理。另外，通过了解虚拟内存的概念，也在本文中描述了程序是如何在内存中存储的，比如通过线性地址到物理地址的变换，比如通过cache高速缓存机制。存储时也会发生缺页故障，本文也描述了缺页中断处理操作与动态存储分配。 IO管理也是必不可少的。本文在最后一章中描述了Linux的IO设备管理方法，包括文件的不同类型以及unixio接口的操作，还描述了io接口的不同函数、printf函数的实现以及getchar函数的实现。关键词：链接；操作系统;IO管理；汇编语言；shell；程序的生命周期；进程； 第1章：概述 1.1HELLO简介 1.P2P(FromProgramtoProcess) 首先创建一个hello.c文件(Program)，依次对该文件进行预处理(hello.i)、编译(hello.s)、汇编(hello.o)、链接(hello)，形成一个可执行文件（二进制文件）。得到可执行文件之后，OS（进程管理）通过shell新建一个进程，还可以通过fork函数创建一个子进程，分配相应的内存资源，使用execve函数加载进程，完成P2P过程。2.020(FromZero-0toZero-0) 计算机存储结构层层递进，下一级作为上一级的缓存，并通过cache加快传输数据的速度。对hello的数据进行处理时，将数据从磁盘加载到CPU寄存器。处理hello时，通过TLB、分级页表等机制，将程序映射到虚拟内存，在开始运行时载入物理内存，多样的信号处理机制能应对程序产生异常的情况。操作系统将IO设备都抽象成了文件，实现程序能够间接调用硬件完成输入输出。hello执行完成后shell回收hello进程，并且内核会从系统中删除hello的所有痕迹，实现020过程。 1.2环境与工具 一.硬件环境： X64CPU;2.60GHz;8.00GBRAM;476.81GBDisk二.软件环境： Windows1064位操作系统;Vmware15.0.4;Ubuntu18.01三.开发工具： Codeblocks17.12;vim/gcc/g++；objdump；gdb；edb；hexedit 1.3中间结果 1.hello.i：hello.c预处理之后的文本文件2.hello.s：hello.i编译之后得到的汇编文件（文本文件）3.hello.o：hello.s汇编之后得到的可重定位目标文件（二进制文件）4.hello1：用于测试sleepsecs的可执行目标文件5.helloo.elf：可重定位目标文件的elf文件6.hello：hello.c的可执行目标文件7.hello.elf：可执行目标文件的elf文件8.helloosection.txt：可重定位目标文件的重定位信息（链接的重定位过程分析）9.hellosection.txt：可执行目标文件的重定位信息（链接的重定位过程分析） 1.4本章小结 本章是对这个大作业的一个概述，首先描述了对这个大作业的理解，即hello简介，然后描述了完成作业需要的环境要求，在完成大作业后，将所输出的中间结果的文件完整列出。 第2章预处理 2.1预处理的概念与作用 1.概念：在编译之前的命令，在C/C++中处理源文件中以”#”开头的预编译命令。2.作用：（1）删除”#define”并展开所定义的宏（2）处理所有条件预编译指令，如”#if”,“#ifdef”,“#endif”等（3）插入头文件到”#include”处，可以递归方式进行处理（4）删除所有的注释”//”和”/**/”（5）添加行号和文件名标识，以便编译时编译器产生调试用的行号信息（6）保留所有”pragma”编译指令经过预编译处理后，得到的是预处理文件（如hello.i），文件还是一个可读的文本文件，但不包含任何宏定义 2.2在UBUNTU下预处理的命令 1.利用gcc-m64-no-pie-fno-PIC-Ehello.c>hello.i生成预处理文件hello.i 2.生成hello.i文件 部分文件内容： 2.3HELLO的预处理结果解析 hello.c头文件如下： hello.i文件较长，共3105行，存储了头文件中的所有内容比如下面截取了部分库在计算机中的存储位置 还有对一些数据结构和函数的声明： 2.4本章小结 本章了解了预处理的概念及作用，能够运用gcc-E的指令生成xxx.o预处理文件，并能直观了解预处理文件的内容，为下一步编译做好准备 第3章编译 3.1编译的概念与作用 1.概念：编译是利用编译程序从源语言编写的源程序产生目标程序的过程，一般通过编译程序来实现。将某一种程序设计语言写的程序翻译成等价的另一种语言的程序的程序，称之为编译程序。2.作用：编译程序把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。(1)词法分析 词法分析的任务是对由字符组成的单词进行处理，从左至右逐个字符地对源程序进行扫描，产生一个个的单词符号，把作为字符串的源程序改造成为单词符号串的中间程序。执行词法分析的程序称为词法分析程序或扫描器。(2)语法分析 编译程序的语法分析器以单词符号作为输入，分析单词符号串是否形成符合语法规则的语法单位，如表达式、赋值、循环等，最后看是否构成一个符合要求的程序，按该语言使用的语法规则分析检查每条语句是否有正确的逻辑结构，程序是最终的一个语法单位。编译程序的语法规则可用上下文无关文法来刻画。(3)中间代码 中间代码是源程序的一种内部表示，或称中间语言。中间代码的作用是可使编译程序的结构在逻辑上更为简单明确，特别是可使目标代码的优化比较容易实现中间代码，即为中间语言程序。(4)代码优化 代码优化是指对程序进行多种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。所谓等价，是指不改变程序的运行结果。所谓有效，主要指目标代码运行时间较短，以及占用的存储空间较小。这种变换称为优化。(5)目标代码 目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。 3.2在UBUNTU下编译的命令 1.用gcc-m64-no-pie-fno-PIC-Shello.i>hello.s 2.生成hello.s文件 3.文件部分内容： 3.3HELLO的编译结果解析 3.3.1数据 1.全局变量：intsleepsecs=2.5 已初始化的全局变量sleepsecs，在.text节中声明为全局变量，在.data节，设置对齐方式是4个字节，类型是“object”，大小占4个字节。输出sleepsecs发现值为2，在文件中存在隐式的类型转换 2.局部变量：inti；局部变量分配在栈中，本题位于-4(%rbp)，先将i赋值为零，之后每次循环与9作比较 3.main函数参数：intmain(intargc,char*argv[]) argc占4个字节，所以是movl，argv[]是指针，占8个字节，所以是movq，并且下一步是将argc与3进行比较4.数组：argv[] argv[]作为main函数的第二个参数传进去，被分配在-32(%rbp)位置处，argv指针指向一段连续的、已经被分配好的内存空间 对printf语句的调用如下，连续两次调用argv数组，并用%rax保存两次调用的值 5.字符串：第一个字符串输出，汇编代码如下： 可以看出，汉字在Linux下使用UTF-8编码格式，每个汉字占3个字节 第二个字符串输出，声明在main函数中 3.3.2赋值 1.全局变量 已初始化的全局变量sleepsecs位于.data节，未初始化的全局变量位于.bss节，且不占任何实际磁盘空间2.局部变量：for(i=0;i<10;i++) 通过mov指令进行赋值操作，根据不同数据类型增添不同后缀 3.3.3关系操作 1.不等于：if(argc!=3) 2.小于：for(i=0;i<10;i++) 关系操作通过cmp指令实现，得到的结果一般与跳转指令相结合，跳转到相应的位置 3.3.4算术操作 自增操作：i++通过add指令可以实现加1操作 3.3.5函数操作 （1）函数传递：intmain(intargc,char*argv[])，argc存储在%edi，argv[]存储在%rsi，局部变量存放在栈中，所以刚开始将%rsp-32，分配32个字节 （2）函数调用：通过call指令调用函数，puts()、exit()、printf()、sleep()、main()、getchar()，将PC设置为要跳转的地址，将当前地址的下一行地址作为返回地址压入栈中 （3）函数返回通过leave和ret指令结束函数，实现return0：释放分配的栈空间，并弹出调用函数%rbp值作为PC地址，进行跳转，结束调用函数 3.4本章小结 本章了解了编译的概念和作用，在Ubuntu下实现编译操作，并得到编译文件hello.s，分析hello.s文件了解C语言数据与操作是如何在汇编语言中实现的，比如不同类型的数据、赋值、类型转换、算术操作、关系操作、函数操作、数组、控制转移是如何在汇编语言中实现的。 第4章汇编 4.1汇编的概念与作用 1.概念： 汇编语言，即第二代计算机语言，用一些容易理解和记忆的字母，单词来代替一个特定的指令，比如：用“ADD”代表数字逻辑上的加减，“MOV”代表数据传递等等。汇编代码文件（由汇编指令构成）称为汇编语言源程序。汇编程序用来将汇编语言源程序转换为机器指令序列。汇编指令和机器指令一一对应，前者是后者的符号表示。2.作用： 比起机器语言，汇编语言具有更高的机器相关性，更加便于记忆和书写，但又同时保留了机器语言高速度和高效率的特点。汇编语言仍是面向机器的语言，很难从其代码上理解程序设计意图，设计出来的程序不易被移植，故不像其他大多数的高级计算机语言一样被广泛应用。所以在高级语言高度发展的今天，它通常被用在底层，通常是程序优化或硬件操作的场合。 4.2在UBUNTU下汇编的命令 通过gcc-m64-no-pie-fno-PIC-chello.s>hello.o 生成hello.o文件 4.3可重定位目标ELF格式 通过readelf-ahello.o>helloo.elf生成包含ELF头文件和节头表的文件helloo.elf ELF头信息格式 （1）Magic：ELF文件的魔数，加载或读取文件时，可用魔数确认文件类型是否正确（2）Class：ELF版本（3）Data：2进制补码，小端法（4）Type：REL可重定位目标文件（5）没有程序头表，且虚拟内存从0开始存储（6）节头表大小为64*13 2.节头表（1）Address：可重定位目标文件中，每个可装入节的起始地址总是0（2）Offset：相对于起始位置的偏移，对于.bss节无意义（3）Align：节的对齐要求（4）Flags：节标志，该节在虚拟空间中的访问属性3…rela.text节重定位节该节中存储了重定位的相关信息 4.4HELLO.O的结果解析 利用objdump-d-rhello.o分析反汇编代码得到反汇编 分析：1.两种基本的重定位类型R_X86_64_32绝对地址R_X86_64_PC32PC相对地址2.分支转移： 不再使用段名称如.L2，而是具体地址，重定位前的序号代表从第几个字节开始被重定位，比如下图是从第16个字节开始重定位 下图是hello.s的文件信息，能够看出左边没有数字序列，hello.o冒号左边数字代表运行时机器指令的位置，冒号右边的数字序列代表每一行汇编语句代表的机器指令 3.函数调用call指令 在hello.s文件中call指令后直接接函数名称，因为编译成汇编语言时，是不确定函数的调用位置的；而在hello.o文件中，call后面接的是下一条指令的地址，因为在hello.c中调用的函数都是共享库的函数，需要通过链接才能确定最终地址。 4.5本章小结 本章中了解了汇编的概念与作用，在Ubuntu中通过gcc指令生成汇编文件，另外生成了可重定位elf文件，了解elf头文件信息、节头表、重定位表各个表项代表的含义，分析了hello.o与hello.s文件的不同，找出汇编语言与机器语言的映射关系，因为是一一对应的，但还是在某些地方有所不同，这些都进行了一定的了解。 第5章链接 5.1链接的概念与作用 1.概念：在构建大型程序的时候,为了方便代码管理,会根据不同的功能把代码分为多个片段(或模块)并存储在不同的文件中,在代码执行时需要把这些代码模块合并成一个单一的可执行文件,这个合并过程叫链接2.作用：将多个可重定位目标文件合并生成可执行目标文件 5.2在UBUNTU下链接的命令 输入命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o得到hello文件 5.3可执行目标文件HELLO的格式 生成hello.elf文件：通过readelf-ahello>hello.elf指令，生成hello.elf文件分析文件内容1.ELF头信息表 信息与可重定位目标文件的ELF头信息表基本相同，有几处不同（1）Type：EXEC代表可执行文件（2）头文件入口地址不为零（3）有程序头表 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。2.节头表： 基本信息与可重定位目标文件中的节头表基本相同 5.4HELLO的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，能够从DataDump中看出hello的起始地址为0x00400000，结束地址为0x00400ff0 分析程序头表： （1）代码段第一个LOAD是只读代码段第二个LOAD是读写代码段（2）PHDR程序头表 5.5链接的重定位过程分析 利用objdump-d-rhello命令生成两个文件，便于比较 分析hello与hello.o的不同（1）hello以init节开始 （2）hello中多了不同函数的汇编代码 （3）hello地址为真实储存地址hello.o中main初始地址显示为0，因为是虚拟内存首地址（4）函数跳转指令hello中是call+首地址调用该函数 hello.o是call+main偏移量 （5）重定位信息hello.o文件15、1a、24所在行后面的零都是需要重定位的信息，在没有重定位之前，后面都初始化为0 重定位之后，hello文件中能够看出bf后面四个字节、e8后面四个字节都是重定位后的信息，通过公式转移目标地址=PC+偏移地址进行计算 5.6HELLO的执行流程 程序名称载入：_dl_start_dl_init开始执行：_start_libc_start_main_init执行main：_main_printf_exit_sleep_getchar_dl_runtime_resolve_xsave_dl_fixup_dl_lookup_symbol_x退出：exit 5.7HELLO的动态链接分析 在edb调试之后我们发现原先0x00600a10开始的global_offset表是全0的状态，在执行过_dl_init之后被赋上了相应的偏移量的值。这说明dl_init操作是给程序赋上当前执行的内存地址偏移量，这是初始化hello程序的一步。 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 5.8本章小结 本章介绍了链接的概念和作用，在Ubuntu下生成链接文件，通过gcc命令生成ELF可执行目标文件，了解了ELF头信息、节头表、程序头表等各项代表的含义，了解虚拟空间的大小，分析了重定位前后文件的变化，函数的执行过程与链接过程 第6章HELLO进程管理 6.1进程的概念与作用 1.概念：进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。2.作用：在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 6.2简述壳SHELL-BASH的作用与处理流程 1.Shell：一般我们是用图形界面和命令去控制计算机，真正能够控制计算机硬件（CPU、内存、显示器等）的只有操作系统内核（Kernel），由于安全、复杂、繁琐等原因，用户不能直接接触内核，需要另外再开发一个程序，让用户直接使用这个程序；该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核，内核和用户之间就多了一层“中间代理”，Shell其实就是一种脚本语言，也是一个可以用来连接内核和用户的软件，我们编写完源码后不用编译，直接运行源码即可。2.常用的Shell：bash由GNU组织开发，sh是UNIX上的标准shell，是第一个流行的Shell，bash保持了对shshell的兼容性，是各种Linux发行版默认配置的shell。现在sh已经基本被bash代替，bash是sh的扩展补充，但是也有些是不兼容的，大多数情况下区别不大，特殊场景可以使用bash代替sh。3.处理流程：（1）读取用户的输入（2）分析输入内容，获得输入参数（3）如果是内核命令则直接执行，否则调用相应的程序执行命令（4）在程序运行期间，shell需要监视键盘的输入内容，并且做出相应的反应 6.3HELLO的FORK进程创建过程 当在shell中输入一条命令时，shell会判断是否是内核命令，如果是内核命令则直接执行，否则shell进程会以自己为模板（即父进程），创建（fork）一个新的进程。这个新建的进程对shell中输入的命令进行处理，即调用exec()这一系统调用来执行shell中输入的命令，处理完之后新进程结束自己的生命，等待shell进程进行回收。 新创建的父进程和子进程内容相同，虚拟地址相同，但是是完全独立的，并且拥有不同的PID。 6.4HELLO的EXECVE过程 （1）通过pid=fork()函数创建一个新进程后，判断pid的值，若pid=0，则该进程为新创建的子进程（2）子进程通过系统调用execve()函数将新程序加载到子进程的内存空间中，execve()函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量envp（3）只有当出现错误时，例如找不到filename，execve才会返回到调用程序；一般情况下，execve调用一次并从不返回，加载filename后，调用启动代码，启动代码设置栈，并将控制传递给新程序的主函数，主函数有如下原型：intmain(intargc,char**argv,char**envp);（4）当main开始执行时，用户栈的组织结构如下： 举例来说： 在shell(shell也是一个进程)中执行最简单的HelloWorld程序。它也是首先调用execve()这个系统调用的，下面用strace跟踪下执行HelloWorld的过程，我们可以看到第一步执行的是execve()。 6.5HELLO的进程执行 1.基本概念：（1）并发：多个流并发地执行的一般现象（2）多任务（时间分片）：一个进程和其它进程轮流运行的概念（3）上下文：内核为每个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态（4）调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程2.如下程序进行上下文切换，其中sleepsecs=2.5 sleep函数的作用是将一个进程挂起一段指定的时间，如果请求的时间量已经到了，sleep返回零。 6.6HELLO的异常与信号处理 1.ctrl+Z： 输入ctrl+Z后，会发送一个SIGTSTP信号到前台进程组中的每个进程，默认情况下，是停止（挂起）前台作业。在图中能看到还有hello进程未结束。 2.fg命令： fg命令是让挂起的程序继续运行，下图能看出在输出6次字符串后输入ctrl+z让程序挂起，输入fg后继续运行输出十次结束 3.ctrl+C 输入ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程，默认情况下，是终止前台作业。下图通过ps能看到hello进程已经结束。 4.jobs jobs命令可以用来查看当前终端放入后台的工作，工作管理的名字也来源于jobs命令。下图通过jobs能看到被挂起的程序。 5.pstree：进程树，把各个进程通过树型连接起来 6.kill命令： 通过ps查看进程号为2778的进程未终止，kill-s向固定进程发送信号，比如下图24信号SIGXCPU，代表CPU时间限制超出，fg继续运行输出错误信息。 6.7本章小结 在本节中，了解了进程的概念和作用，能运用fork创建进程，execve执行进程，了解了不同信号的作用，并能在linux下使用，能通过运用不同的命令了解前台作业和后台作业的基本信息。 第7章HELLO的存储管理 7.1HELLO的存储器地址空间 1.物理地址：用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚按发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示，也可以简单的理解为实际上内存上的地址。2.虚拟地址/线性地址：虚拟地址：虚拟地址并不真实存在于计算机中。每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间。理论上，虚拟空间受物理内存大小的限制，如给有4GB内存，那么虚拟地址空间的地址范围就应该是0x00000000~0xFFFFFFFF。每个进程都有自己独立的虚拟地址空间。这样每个进程都能访问自己的地址空间，这样做到了有效的隔离。3.逻辑地址：包含在机器语言指令中用来指定一个操作数或一条指令的地址，这种寻址方式在80x86著名的分段结构中表现得尤为具体，它促使windows程序员把程序分成若干段。每个逻辑地址都由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。例如我们常说的结构体中某个参数的地址其实就相当于：结构体首地址+偏移量。逻辑地址是相对于应用程序而言的。 7.2INTEL逻辑地址到线性地址的变换-段式管理 逻辑地址是程序源码编译后所形成的跟实际内存没有直接联系的地址，即在不同的机器上，使用相同的编译器来编译同一个源程序，则其逻辑地址是相同的，但是相同的逻辑地址，在不同的机器上运行，其生成的线性地址又不相同，因为把逻辑地址转换成线性地址的公式是：线性地址=段基址*16+偏移的逻辑地址，而段基址由于不同的机器其任务不同，其所分配的段基址（线性地址）也会不相同，因此，其线性地址会不同。 即使，对于转换后线性地址相同的逻辑地址，也因为在不同的任务中，而不同的任务有不同的页目录表和页表把线性地址转换成物理地址，因此，也不会有相同的物理地址冲突。 注意的是，源码编译后生成的地址，只是偏移的地址，而形成逻辑地址的[段基址:偏移地址]中的段基址，是在生成任务时才定下来的，也就是说，[段基址:偏移地址]只有在进程中才会用到，在程序中只有偏移地址的概念。 7.3HELLO的线性地址到物理地址的变换-页式管理 1.基本概念（1）线性地址：是进程使用的地址，虚拟的地址。人为抽象出一大片地址空间给进程使用，为了方便32位地址总线存取，linux内核定义为了4G。（2）物理地址：是采用32位总线存取物理内存某个字节时，地址总线上电位的高低。分页单元将线性地址转换成物理地址。2.两种变换：CPU通过地址来访问内存中的单元，地址有虚拟地址和物理地址之分，如果CPU没有MMU，或者有MMU但没有启用，CPU核在取指令或访问内存时发出的地址将直接传到CPU芯片的外部地址引脚上，直接被内存芯片接收，这称为物理地址. 如果CPU启用了MMU，CPU核发出的地址将被MMU截获，从CPU到MMU的地址称为虚拟地址，而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将虚拟地址映射成物理地址，如下图所示。，利用TLB加速地址翻译，TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。 3.具体过程：将虚拟地址分为VPN(虚拟页号)和VPO(虚拟页偏移)，TLB是利用VPN的位进行虚拟寻址的，VPN分为TLBI(组索引)和TLBT(标记)。将物理地址分为PPN(物理页面)和PPO(物理页偏移)，然后再进行划分，分为CO(块偏移)、CI(组索引)、CT(标记)。VPO与PPO相对应，VPN对应页表中的某一项，通过PTE查找到对应的PPN，将PPN和PPO连在一起即为物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 一般来讲，能通过VPN中TLB找到PPN是最好的，但也可能出现缺页的情况，在TLB中无法找到对应的PPN，则要访问内存，在页表中寻找PPN。 将虚拟地址划分为4个VPN和1个VPO，每个VPNi都是到第i级页表的索引，为了构造物理地址，在能够确定PPN之前，MMU必须访问4个PTE，和只有一级到页表结构一样，PPO和VPO是相同的。 7.5三级CACHE支持下的物理内存访问 将物理地址分为三部分，分为CO(块偏移)、CI(组索引)、CT(标记)，根据CI找到组索引，找到标记相同的位置，最后通过块偏移找到对应位置。若未找到，则到二级或三级cache下寻找。 7.6HELLO进程FORK时的内存映射 1.基本概念：（1）mm_struct（内存描述符）：描述了一个进程的整个虚拟内存空间（2）vm_area_struct（区域结构描述符）：描述了进程的虚拟内存空间的一个区间2.映射过程：（1）当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID（2）创建当前进程的mm_struct,vm_area_struct和页表的原样副本（3）将两个进程的每个页面都标记为只读页面（4）两个进程的每个vm_area_struct都标记为私有，这样就只能在写入时复制。 7.7HELLO进程EXECVE时的内存映射 1.加载并运行程序步骤：（1）删除已存在的用户区域（2）映射私有区域：为新程序的代码、数据、bss和栈区域创建新的区域结构。（3）映射共享区域（4）设置程序计数器PC2.加载器映射用户地址空间区域： 7.8缺页故障与缺页中断处理 1.缺页故障：（1）段错误：首先，先判断这个缺页的虚拟地址是否合法，那么遍历所有的合法区域结构，如果这个虚拟地址对所有的区域结构都无法匹配，那么就返回一个段错误（segmentfault）（2）非法访问：接着查看这个地址的权限，判断一下进程是否有读写改这个地址的权限。（3）如果不是上面两种情况那就是正常缺页，那就选择一个页面牺牲然后换入新的页面并更新到页表。 2.缺页处理： 处理器将虚拟地址发送给MMU2-3)MMU使用内存中的页表生成PTE地址有效位为零,因此MMU触发缺页异常缺页处理程序确定物理内存中牺牲页(若页面被修改，则换出到磁盘)缺页处理程序调入新的页面，并更新内存中的PTE缺页处理程序返回到原来进程，再次执行缺页的指令 7.9动态存储分配管理 1.程序员使用动态内存分配器（比如malloc）获得虚拟内存，动态内存分配器维护着一个进程的虚拟内存区域，称为堆 2.分配器（1）概念：分配器将堆视为一组不同大小的块(blocks)的集合来维护，每个块要么是已分配的，要么是空闲的。（2）分配器的类型a.显式分配器:要求应用显式地释放任何已分配的快例如，C语言中的malloc和freeb.隐式分配器:应用检测到已分配块不再被程序所使用，就释放这个块比如Java，ML和Lisp等高级语言中的垃圾收集(garbagecollection)3.malloc程序包#include<stdlib.h>（1）void*malloc(size_tsize)1）成功:返回已分配块的指针，块大小至少size字节，对齐方式依赖编译模式：8字节（32位模式），16字节（64位模式）Ifsize==0,returnsNULL2）出错:返回NULL(0)，同时设置errno（2）voidfree(void*p)将p指向的块返回到可用内存池，p必须malloc、realloc或calloc已分配块的起始地址（3）Otherfunctionscalloc:malloc的另一版本，将已分配块初始化为0.realloc:改变之前分配块的大小.sbrk:分配器隐含地扩展或收缩堆4.记录空闲块方法：（1）隐式空闲链表：通过头部中的大小字段 隐含地连接所有块 （2）显式空闲链表：在空闲块中使用指针 （3）分离空闲链表：按照大小分类，构成不同大小的空闲链表（4）块按大小排序：在每个空闲块中使用一个带指针的平衡树，并使用长度作为权值 7.10本章小结 通过本章的学习，了解了虚拟地址、物理地址、线性地址、逻辑地址的概念，也了解了地址之间的转化关系，比如从虚拟地址转换到物理地址是需要通过地址翻译机制实现的。学习内存映射，掌握fork函数、execve函数的内存映射。还学习了缺页的种类与处理步骤，以及处理空闲块的方法。 第8章HELLO的IO管理 8.1LINUX的IO设备管理方法 1.设备的模型化：文件文件类型：（1）普通文件：包含任意数据，应用程序通常包含文本文件和二进制文件。（2）目录：包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录（3）套接字：用来与另一个进程进行跨网络通信的文件（4）命名通道（5）符号链接（6）字符和块设备2.设备管理：unixio接口（1）打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个IO设备。Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）、标准错误（描述符为2）（2）改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量。（3）读写文件：读操作是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。写操作是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。（4）关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件，作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。 8.2简述UNIXIO接口及其函数 一.打开和关闭文件1.open()函数：打开一个已存在的文件或者创建一个新文件 将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符。若出错，则返回-1。flags参数指明了进程打算如何访问这个文件。mode参数制定了新文件的访问权限位。 2.close()函数：关闭一个已打开的文件，若关闭一个已关闭的描述符会出错，返回-1. 二.读和写文件1.read()函数：若成功则为读的字节数，若EOF则为0，若出错为-1read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。 2.write()函数：若成功则为写的字节数，若出错则为-1write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 三.改变当前文件位置调用lseek函数改变当前文件位置 8.3PRINTF的实现分析 一.printf函数体内容： 二.分析函数体：1.形参列表中的“…”：可变参数的写法，当传递参数的个数不确定时，就用这种方式表示。2.va_listarg=(va_list)((char*)(&fmt)+4);（1）va_list：是一个字符指针（2）((char*)(&fmt)+4)：表示的是…中的第一个参数fmt是一个指针，指向第一个const参数(constcharfmt)的第一个元素，它是在栈上进行分配的，有地址。char类型的变量，入栈的是指针而不是该变量，所以得到的也是一个固定的值所以将得到的值转换成va_list类型可以得到第一个参数的地址。3.i=vsprintf(buf,fmt,arg);（1）vsprintf函数原型： （2）函数功能：接受确定输出格式的格式字符串fmt，用格式字符串对个数变化的参数进行格式化，产生格式化输出。4.write(buf,i);函数作用：将buf中的i个元素的值写到终端三.printf的运行过程： 从vsprintf生成显示信息，显示信息传送到write系统函数，write函数陷阱-系统调用int0x80或syscall.字符显示驱动子程序，从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4GETCHAR的实现分析 1.getchar()函数原型： 2.函数分析：n=read(0,buf,BUFSIZ);getchar调用read函数，将整个缓冲区都读到了buf里面，返回值是缓冲区的长度。函数实现时，只有当buf长度为零，getchar才会调用read函数，否则是直接将保存的buf中的最前面的元素返回。3.异步异常-键盘中断的处理： 键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章描述了Linux的IO设备管理方法，包括文件的不同类型以及unixio接口的作用，还描述了unixio接口及不同函数的作用。另外，分析了printf和getchar函数的具体实现过程。 结论 终于深刻地了解hello程序了！ 回顾hello的一生，从hello.c开始出发，进行预处理，处理了文件的“头”，进行编译，将文件用生动形象的汇编语言进行翻译，进行汇编，将文件翻译成枯燥无味的机器代码，进行链接，将不同文件“紧紧”链接在一起，得到一个可执行文件。但是一生才刚刚开始，它还没有发挥它的作用。我们运行它，为它创建“儿子”（子进程），对它轮番轰炸，进行各种花式操作，比如发送kill或pause信号，比如用字符串充满缓冲区，比如按ctrl+c或ctrl+z。最终它的进程被清除，它也完成了它的使命。我们为了充分了解它，还要分析它的内存空间和IO文件管理。多亏了它，我们才能有这样一份独一无二的大作业，复习课内的知识，以及掌握很多额外的知识。 回顾这一门课程，是真的感叹csapp这本大黑书写的很好，并且通过完成hello的一生大作业，我能再次回顾课程的知识点，进行查缺补漏。另外，也掌握了一些调试器的使用方法，比如gdb、edb等，这些都是分析程序必不可少的工具。 附件 1.hello.i：hello.c预处理之后的文本文件2.hello.s：hello.i编译之后得到的汇编文件（文本文件）3.hello.o：hello.s汇编之后得到的可重定位目标文件（二进制文件）4.hello1：用于测试sleepsecs的可执行目标文件5.helloo.elf：可重定位目标文件的elf文件6.hello：hello.c的可执行目标文件7.hello.elf：可执行目标文件的elf文件8.helloosection.txt：可重定位目标文件的重定位信息（链接的重定位过程分析）9.hellosection.txt：可执行目标文件的重定位信息（链接的重定位过程分析） 参考文献 [1]https://www.cnblogs.com/pianist/p/3315801.html[2]http://c.biancheng.net/view/3210.html[3]https://blog.csdn.net/liugaigai427/article/details/86742062 

力扣--动态规划专题I 题目列表 1.300-最长递增子序列2.剑指offer42.连续子数组的最大和3.70--爬楼梯4.413--等差数列划分5.64--最小路径和6.542--01矩阵7.221-最大正方形8.1277-统计全为1的正方形子矩阵 1.300-最长递增子序列 （1）题目条件：（2）题解： 动态规划 构建一个与nums数组长度相等的dp数组，dp[i]为以第i个元素结尾的最长子序列的长度，并设置初值均为1。遍历数组nums，当遍历到元素nums[i]时，dp[0…i-1]都被算出，所以dp[i]的状态转移方程为dp[i]=max(dp[i],dp[j]+1),0<=j<i,且nums[i]>nums[j]解释状态方程：遍历到nums[i]时，重新遍历nums[0…i-1]找到比nums[i]小的元素，因为只有比它小，才有可能增加子序列的长度。比nums[i]小的元素可能有很多，分别计算dp[j]+1，找到最大的dp[j]+1即[0…i-1]中比nums[i]小的元素的最长子序列长度。得到完整的dp数组之后，找到其中的最大值，就是最长子序列长度 classSolution{ public: intlengthOfLIS(vector<int>&nums){ intn=nums.size(); vector<int>dp(n,1); for(inti=1;i<n;i++){ for(intj=0;j<i;j++){ if(nums[i]>nums[j]){ dp[i]=max(dp[i],dp[j]+1); } } } intm=dp[0]; for(inti=1;i<n;i++){ if(m<dp[i]){ m=dp[i]; } } returnm; } }; 贪心+二分搜索 上一个算法的时间复杂度是O(n2)，复杂度较高。换一种思考方式，要让子序列尽可能地长，就要让子序列增加的尽可能地慢，也就是说让子序列的元素增加的尽可能地小，这是“贪心”思想。构造数组d[i]，代表长度为i的最长子序列末尾元素的最小值，d[1]=nums[0]。d[i]数组是当单调递增的，证明:若d[3]=5,d[5]=3,长度为5的最长子序列的末尾元素是3，而长度为3的最长子序列长度为5，这肯定是不对的，因为能在长度为5的最长子序列中找到长度为3的最长子序列的末尾元素，并且该元素要小于3，所以d[i]数组是单调递增的。算法步骤：a.设len表示最长子序列长度，len初值为1，遍历整个数组nums[i]b.若nums[i]>d[len],则len长度加1，将nums[i]加入到d数组中.c.否则，找到d[i-1]<nums[j]<d[i]，更新d[i]=nums[j]，由于d数组是单调递增的，可以用二分查找搜索。 classSolution{ public: intlengthOfLIS(vector<int>&nums){ intn=nums.size(),len=1; vector<int>d(n+1,0); d[len]=nums[0]; for(inti=1;i<n;i++){ if(nums[i]>d[len]){ len++; d[len]=nums[i]; } else{ intlow=1,high=len,pos=0; while(low<=high){ intmid=(high+low)>>1; if(nums[i]>d[mid]){ pos=mid; low=mid+1; } else{ high=mid-1; } } d[pos+1]=nums[i]; } } returnlen; } }; 2.剑指offer42.连续子数组的最大和 （1）题目条件： （2）题解： 动态规划构建一个数组dp[i]，代表以第i个元素结尾的连续子数组的最大和。若dp[i-1]>0，dp[i]=dp[i-1]+nums[i]。若dp[i-1]<=0,dp[i]=nums[i]，因为一个数加上一个负数一定会比这个数本身小，若是前一个数是负数，则可以遗弃它，直接从当前元素开始找。用res记录最大值可以避免之后在遍历一遍dp数组。 classSolution{ public: intmaxSubArray(vector<int>&nums){ intn=nums.size(); intres=nums[0]; vector<int>dp(n,0); dp[0]=nums[0]; for(inti=1;i<n;i++){ dp[i]=dp[i-1]>0?dp[i-1]+nums[i]:nums[i]; res=max(res,dp[i]); } returnres; } }; 3.70–爬楼梯 （1）题目条件：‘ （2）题解： 动态规划（简化）题目条件是每次只能爬1个或2个台阶，所以要求爬到第n阶台阶的方法数时，该方法数等于爬到n-1阶台阶的方法数+爬到n-2阶台阶的方法数之和，状态转移方程是dp[n]=dp[n-1]+dp[n-2]，由于只与前两个状态有关，所以没必要建立数组。 classSolution{ public: intclimbStairs(intn){ if(n==0||n==1)return1; intx=1,y=1,sum; for(inti=2;i<=n;i++){ sum=x+y; x=y; y=sum; } returnsum; } }; 4.413–等差数列划分 （1）题目条件： （2）题解： 动态规划dp[i]是以第i个元素结尾的等差数列的个数，由于求的是所有子数组的个数和，最后要把dp数组的元素个数相加。等差数列的划分满足nums[i]-nums[i-1]=nums[i-1]-nums[i-2] classSolution{ public: intnumberOfArithmeticSlices(vector<int>&nums){ intn=nums.size(); if(n<3)return0; vector<int>dp(n,0); for(inti=2;i<n;i++){ if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){ dp[i]=dp[i-1]+1; } } returnaccumulate(dp.begin(),dp.end(),0); } }; 5.64–最小路径和 （1）题目条件： （2）题解： 动态规划（二维）由题目条件可知，元素只能向右或者向下走，dp[i][j]代表以第i行第j列为结尾的元素的最小路径和，状态转移方程：dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j] classSolution{ public: intminPathSum(vector<vector<int>>&grid){ intm=grid.size(),n=grid[0].size(); vector<vector<int>>dp(m,vector<int>(n,0)); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(i==0&&j==0){ dp[i][j]=grid[0][0]; } elseif(i==0){ dp[i][j]=dp[i][j-1]+grid[i][j]; } elseif(j==0){ dp[i][j]=dp[i-1][j]+grid[i][j]; } else{ dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j]; } } } returndp[m-1][n-1]; } }; 动态规划压缩矩阵 由于dp数组遍历时只与左边和上边的值有关，我们可以将二维数组压缩成一维数组dp[j]代表遍历到第i行时，以第j列的元素结尾的最小路径和。对于第i行，在遍历到第j列时，由于第j-1列已经遍历完，所以dp[j-1]代表dp[i][j-1]，而dp[j]还没有被更新，所以dp[j]代表dp[i-1][j] classSolution{ public: intminPathSum(vector<vector<int>>&grid){ intm=grid.size(),n=grid[0].size(); vector<int>dp(n,0); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(i==0&&j==0){ dp[j]=grid[i][j]; } elseif(i==0){ dp[j]=dp[j-1]+grid[i][j]; } elseif(j==0){ dp[j]=dp[j]+grid[i][j]; } else{ dp[j]=min(dp[j],dp[j-1])+grid[i][j]; } } } returndp[n-1]; } }; 6.542–01矩阵 （1）题目条件： （2）题解： 广度优先搜索bfs更为常见，这里只介绍动态规划方法 动态规划对于矩阵中的1，要找到与它距离最近的0，共有四种走法：水平向左+竖直向上水平向左+竖直向下水平向右+竖直向上水平向右+竖直向下可以四种情况都考虑，但是会有重复，所以为了减少重复次数，只选择左上和右下就可以，说明原因：左上，从第一个元素开始遍历，对于每个元素都找到了左边和上边的最小值右下，从最后一个元素开始遍历，对于每个元素都找到了右边和下边的最小值 classSolution{ public: vector<vector<int>>updateMatrix(vector<vector<int>>&matrix){ intm=matrix.size(),n=matrix[0].size(); //初始dp的值为无穷大 vector<vector<int>>dp(m,vector<int>(n,INT_MAX/2)); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(matrix[i][j]==0){ dp[i][j]=0; } } } //向左和向上，注意遍历顺序 for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(i-1>=0) dp[i][j]=min(dp[i][j],dp[i-1][j]+1); if(j-1>=0) dp[i][j]=min(dp[i][j],dp[i][j-1]+1); } } //向右和向下，注意遍历顺序 for(inti=m-1;i>=0;i--){ for(intj=n-1;j>=0;j--){ if(i+1<m) dp[i][j]=min(dp[i][j],dp[i+1][j]+1); if(j+1<n) dp[i][j]=min(dp[i][j],dp[i][j+1]+1); } } returndp; } }; 7.221-最大正方形 （1）题目条件： （2）题解： 动态规划数组dp(i,j)表示以(i,j)为右下角，且只包含1的正方形的边长最大值.若matrix(i,j)=‘0’，dp(i,j)=0若matrix(i,j)=‘1’，考虑边界条件，若i=0或者j=0，则dp(i,j)只能为1，若不是在边界，则满足状态转移方程dp(i,j)=min(dp(i-1,j),dp(i,j-1),dp(i-1,j-1))+1 classSolution{ public: intmaximalSquare(vector<vector<char>>&matrix){ intm=matrix.size(),n=matrix[0].size(); intmaxside=0; vector<vector<int>>dp(m,vector<int>(n,0)); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(matrix[i][j]=='1'){ if(i==0||j==0)dp[i][j]=1; else{ dp[i][j]=min(min(dp[i-1][j],dp[i-1][j-1]),dp[i][j-1])+1; } } maxside=max(maxside,dp[i][j]); } } returnmaxside*maxside; } }; 8.1277-统计全为1的正方形子矩阵 （1）题目条件：（2）题解： 动态规划这道题与221最大正方形十分类似，对dp(i,j)可以有不同的定义，定义为以(i,j)元素结尾的全1矩阵的个数，计算过程中用sum进行相加得到最终个数。 classSolution{ public: intcountSquares(vector<vector<int>>&matrix){ intm=matrix.size(),n=matrix[0].size(); intsum=0; vector<vector<int>>dp(m,vector<int>(n,0)); for(inti=0;i<m;i++){ for(intj=0;j<n;j++){ if(matrix[i][j]==1){ if(i==0||j==0)dp[i][j]=1; else{ dp[i][j]=min(min(dp[i-1][j],dp[i-1][j-1]),dp[i][j-1])+1; } } sum+=dp[i][j]; } } returnsum; } }; 

哈工大计算机系统大作业 程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机类 学 号 1190200106 班 级 1936601 学 生 何炫霖 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文介绍了hello的整个生命过程。在Linux系统下利用gcc，gdb，edb等工具分析了hello程序从hello.c经过预处理、编译、汇编、链接生成可执行文件的全过程，即P2P的过程，还分析了hello在运行过程中涉及的进程管理、内存管理、IO管理到最后hello被回收的020的过程。通过本文的分析，可以让我们对计算机系统有更深的理解。 关键词：Linux；hello程序；计算机系统 目 录 第1章概述 -3- 1.1Hello简介 -3- 1.2环境与工具 -3- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -6- 2.4本章小结 -7- 第3章编译 -8- 3.1编译的概念与作用 -8- 3.2在Ubuntu下编译的命令 -8- 3.3Hello的编译结果解析 -8- 3.4本章小结 -12- 第4章汇编 -13- 4.1汇编的概念与作用 -13- 4.2在Ubuntu下汇编的命令 -13- 4.3可重定位目标elf格式 -13- 4.4Hello.o的结果解析 -16- 4.5本章小结 -19- 第5章链接 -20- 5.1链接的概念与作用 -20- 5.2在Ubuntu下链接的命令 -20- 5.3可执行目标文件hello的格式 -20- 5.4hello的虚拟地址空间 -25- 5.5链接的重定位过程分析 -25- 5.6hello的执行流程 -28- 5.7Hello的动态链接分析 -28- 5.8本章小结 -29- 第6章hello进程管理 -30- 6.1进程的概念与作用 -30- 6.2简述壳Shell-bash的作用与处理流程 -30- 6.3Hello的fork进程创建过程 -30- 6.4Hello的execve过程 -31- 6.5Hello的进程执行 -31- 6.6hello的异常与信号处理 -32- 6.7本章小结 -35- 第7章hello的存储管理 -36- 7.1hello的存储器地址空间 -36- 7.2Intel逻辑地址到线性地址的变换-段式管理 -36- 7.3Hello的线性地址到物理地址的变换-页式管理 -37- 7.4TLB与四级页表支持下的VA到PA的变换 -38- 7.5三级Cache支持下的物理内存访问 -39- 7.6hello进程fork时的内存映射 -40- 7.7hello进程execve时的内存映射 -41- 7.8缺页故障与缺页中断处理 -41- 7.9动态存储分配管理 -42- 7.10本章小结 -44- 第8章hello的IO管理 -45- 8.1Linux的IO设备管理方法 -45- 8.2简述UnixIO接口及其函数 -45- 8.3printf的实现分析 -46- 8.4getchar的实现分析 -48- 8.5本章小结 -48- 结论 -48- 附件 -50- 参考文献 -51- 第1章概述 1.1Hello简介 程序的生命周期是指从程序源文件，依次经过预处理器cpp的预处理、编译器cc1的编译、汇编器as的汇编、链接器ld的链接最终成为可执行目标程序并在操作系统上加载、执行、回收的全过程。程序的生命周期可以分为P2P和020两个部分，P2P指程序由源文件到进程的过程；020指程序被加载到内存执行，直到被回收的过程。 P2P： GCC编译器驱动程序读取源程序文件并把它翻译成一个可执行目标文件。在预处理阶段，预处理器cpp读取需要的系统头文件内容，并把它直接插入程序文本中，得到hello.i。在编译阶段，编译器ccl间文本文件hello.i翻译成hello.s，这是一个汇编语言的程序。在汇编阶段，汇编器as将hello.s翻译成机器语言指令，并将结果保存在目标文件hello.o中，它以可重定位目标程序的格式存储。在链接阶段，链接器ld需要将一些库函数合并到hello.o的程序中，最终得到hello的可执行文件。用户在Ubuntushell键入./hello启动此程序，shell调用fork函数为其产生子进程，hello便成为了进程。完整过程图示如下： 020： 操作系统的进程管理调用fork函数产生子进程并调用execve函数，进行虚拟内存映射（mmp），并为运行的hello分配时间片来执行取指译码流水线等操作。操作系统的储存管理以及MMU解决VA到PA的转换，cache、TLB、页表等的功能为加速访问过程，IO管理与信号处理综合软硬件对信号等进行处理。程序结束时，shell回收hello进程，内核将其所有痕迹从系统中清除。 1.2环境与工具 硬件环境：IntelCorei5-9300HCPU；2.40GHz；8GBRAM 软件环境：Windows1064位；Ubuntu20.04.2LTS64位 开发与调试工具：gcc；edb；gdb；readelf；objdump 1.3中间结果 文件名文件作用hello.i预处理器修改了的源程序,分析预处理器行为hello.s编译器生成的编译程序,分析编译器行为hello.o可重定位目标程序,分析汇编器行为hello可执行目标程序,分析链接器行为helf.txthello.o的elf格式,分析汇编器和链接器行为h1elf.txt可执行hello的elf格式,作用是重定位过程分析 1.4本章小结 本章主要是本文实验的准备工作和绪论部分，主要介绍了hello程序P2P、020的过程，给出了实验中生成的中间文件，列出了实验使用的软硬件环境以及调试工具等。 第2章预处理 2.1预处理的概念与作用 预处理指令是以‘#’开头的代码行。‘#’必须是该行除了空白字符外的第一个字符。‘#’后面是指令关键字，整行语句构成一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。下图是ANSI标准定义的C语言预处理指令及其作用： 2.2在Ubuntu下预处理的命令 命令：cpphello.c>hello.i 2.3Hello的预处理结果解析 查看hello.i文件，可以发现原来的代码已经被拓展为3000多行，而main函数以及定义全局变量的代码没有任何改变，只是原来前面的#include语句被替换成了大量的头文件中的内容，包括外部函数的声明、结构体等数据结构的定义、数据类型的定义等内容。并且源程序开头的注释也被删除了。同时会对#define进行相应的符号替换。所以我们分析可以知道生成的是经过预处理扩展之后的源程序。 2.4本章小结 本章主要介绍了预处理的概念以及作用，预处理环节是接下来编译、汇编、链接等环节的基础，并通过hello.c经过预处理生成的hello.i文件导致两者内容的不同进行了分析。 第3章编译 3.1编译的概念与作用 概念： 编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序，该程序包含函数main的定义，这个过程称为编译。 作用： 编译的作用就是将高级语言源程序翻译成等价的目标程序，并且进行语法检查、调试措施、修改手段、覆盖处理、目标程序优化等步骤。 3.2在Ubuntu下编译的命令 命令：gcc–Shello.i-ohello.s 3.3Hello的编译结果解析 3.3.1数据 全局变量：sleepsecs 在hello.s中可以看到，.global将sleepsecs标记为全局变量。.data表明全局变量sleepsecs存放在数据段.data中，.align要求4字节对齐，.size表明变量为4字节，最后.long给出了变量的初值为2。 局部变量：i，用于循环计数： 在hello.s的汇编代码中，i被存储在%rbp-4的内存地址处。其中movl为i赋初值0，addl在每次循环时对i增加1，cmpl比较i和9的大小来决定什么时候结束循环。局部变量i是存放在栈上，通过相对栈顶（%rsp）的偏移量来访问。 字符串常量：Usage:Hello学号姓名！\n；Hello%s%s\n： 这两个字符串常量分别由.LC0和.LC1表示，存放在只读数据段.rodata中。 intargc： argc首先被保存在了寄存器%edi中，后续需要参与判断的时候编译器将其赋值给了-20(%rbp)。 charargv[]： argv[]的每个元素都是一个指向字符类型的指针，起始地址存放在栈中-32（%rbp）的位置，并且被两次调用传给printf。 3.3.2赋值 源程序中的赋值操作主要有：intsleepsecs=2.5、i=0。 对于intsleepsecs=2.5，直接在.data节中就已经将sleepsecs声明为值为2的long类型数据（隐式转换）。 对于i=0。在hello.s文件中是通过汇编语句movl$0，-4(%rbp)将立即数赋值给局部变量i的。这里使用的是“movl”，这是因为指令的后缀取决于操作数据的字节大小，movb：一个字节；movw：两个字节；movl：四个字节；movq：八个字节，而局部变量i是int类型的数据，占4个字节。 3.3.3类型转换 intsleepsecs=2.5的操作中出现了隐式类型转换，由于当double或float向int进行类型转换的时候，程序遵循向零舍入的原则将浮点数2.5转化为int类型的整数2，然后由于编译器缺省，int类型又被转换为了long类型。 3.3.4算术操作 在for循环的时候出现了算术操作为i++，编译时转化成加法指令，使用立即数1来实现每次增加1。 3.3.5关系操作 在程序中有两次关系操作： if中判断argc的取值是否不等于3：利用cmpl将argc和3进行比较，指令je根据条件码决定是否跳转。 for循环中判断i是否小于10：我们可以看到汇编代码将它优化为了i<=9，编译器会计算-4(%rbp)-9，并设置条件码，随之jle语句通过条件码决定进行怎样的跳转处理。 3.3.6数组/指针/结构操作 程序在访问argv[]的时候出现了数组操作，在向main函数传参时，通过movq%rsi,-32(%rbp)进行参数的传递，把argv数组的首地址保存在栈中。使用首地址+偏移量的方式来访问数组元素，数组首地址存储在%rbp-32，通过将首地址加8获得argv[1]的地址，将首地址加16获得argv[2]的地址，从而在循环中分别读取了argv[1]和argv[2]。 3.3.7控制转移 程序中有两次控制转移： if中判断argc的取值是否不等于3之后的控制转移： cmpl指令将argc和3进行比较，je根据条件码决定是否跳转，控制转移也由它完成。 for循环结束时的控制转移： 编译时使用cmpl指令将i和9进行比较，jle根据条件码决定是否跳转，控制转移也由它完成。 3.3.8函数操作 程序中一共有五次函数操作：main函数；printf函数；sleep函数；getchar函数；exit函数： 函数调用：printf函数第一次调用为在汇编代码中被优化为puts函数，第二次调用为直接调用；其他函数则直接通过call@函数名调用。 参数传递：向main函数传递的参数是argc和argv[]，分别使用%rdi（%edi）和%rsi存储；printf函数第一次传递首先将rdi赋值为字符串“Usage:Hello学号姓名！\n”字符串的首地址，然后调用了puts函数，将字符串参数传入，第二次则传递了3个参数，%rdi保存的是“Hello%s%s\n”的首地址，%rsi保存的是argv[1]，%rdx保存的是argv[2]；sleep函数则是通过movlsleepsecs(%rip),%eax和movl%eax,%edi，对应sleepsecs；getchar函数没有参数传递的过程；exit通过汇编语句movl$1，%edi将内容设置为1。 函数返回：只有main函数有函数返回的过程，将%eax设置为0后通过leave退出。 3.4本章小结 本章介绍了编译的概念以及作用，同时对hello.s的编译代码的数据、赋值、类型转换、算术操作、关系操作、数组/指针/结构操作以及控制转移和函数操作进行了分析。 第4章汇编 4.1汇编的概念与作用 概念： 汇编器（as）将.s汇编程序翻译成机器语言，把这些机器语言指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码，这个过程就叫做汇编。 作用： 汇编的作用就是将高级语言转化为机器可直接识别执行的机器指令代码文件。 4.2在Ubuntu下汇编的命令 命令：ashello.s-ohello.o 4.3可重定位目标elf格式 利用readelf-ahello.o>helf.txt获得hello的elf文件并重定向到helf.txt。 ELF头： 它以一个16字节的目标序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。hello.o中，这个16字节序列为7f454c46020101000000000000000000，并且系统的字的大小为8字节，字节顺序为小端序。剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型（如x86-64）、节头部表的文件偏移，以及节头部表中条目的大小和数量。 节头： 节头描述不同节的位置和大小，目标文件中的每个节都有一个固定大小的节头部表条目。在hello.s中： .text节表示已编译程序的机器代码。.rela.text节表示一个.text节中位置的列表。 .data节表示已初始化的全局和静态C变量，且该节的数据可读可写。.bss节表示未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量，且该节的数据可读可写。.rodata节：只读数据。.comment节表示版本控制信息。.note.GNU_stack节表示可执行堆栈。.eh_frame节处理异常，且数据只读。.rela.eh_frame节表示.eh_frame节的重定位信息。.shstrtab节表示节区名称。.symtab节表示一个符号表，存放在程序中定义和引用的函数和全局变量的信息。.strtab节表示一个字符串表，包括.symtab和.debug节中的符号表，以及节头部中的节名字。 符号表：符号表存放程序中定义和引用的函数和全局变量的信息，每个符号表是一个条目的数组，每个条目包括距定义目标的节的起始位置的偏移；目标的大小；指明数据还是函数；表示符号是本地的还是全局的等。 重定位节： 汇编器遇到对最终位置未知的目标引用，会产生一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。重定位信息就放在重定位节.，重定位条目放在.rel.data中。每个重定位条目包括需要被修改的引用的节偏移；标识被修改引用应该指向的符号；重定位类型。 ELF定义了32种不同的重定位类型，两种最基本的重定位类型包括R_X86_64_PC32（重定位使用32位PC相对地址的引用）和R_X86_64_32（重定位使用32位绝对地址的引用）。 4.4Hello.o的结果解析 利用objdump-d-rhello.o进行反汇编： 将其与hello.s进行对比： 我们可以知道机器语言指的是二进制的机器指令集合，机器可以直接根据二进制代码执行对应的操作。而机器指令是由操作码和操作数构成的。汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式。 每一条汇编语言的指令都可以映射到一条机器语言指令，从汇编语言转换成机器语言的过程中，部分操作数会出现不一致： 分支转移：hello.s文件中分支转移是使用段名称进行跳转的，而hello.o文件中分支转移是通过重定位地址进行跳转的。 函数调用：hello.s文件中，调用call后的是函数名称，而在hello.o文件中，因为这些函数都是共享库函数，它们的地址是不确定的，因此call指令将相对地址全部设置为0，然后在.rela.text节中为其添加重定位条目，在链接时确定最终的相对地址。 立即数：hello.s中的立即数都是用10进制数表示的，但在机器语言中，立即数都是用16进制数表示的。 4.5本章小结 本章介绍了汇编的概念以及作用，通过readelf命令查看了hello.o可重定位目标elf格式，并对其中的ELF头、节头、符号表和重定位表进行了分析。除此之外，将hello.o的反汇编代码和hello.s的代码进行比较，理解了汇编指令与机器指令的区别，更深刻地理解了汇编这一过程。 第5章链接 5.1链接的概念与作用 概念：链接是将各种代码和数据的片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。 作用：链接可以执行于编译时，也就是在源代码被翻成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在现代系统中，链接由链接器程序自动执行。链接包括两个主要任务：符号解析和重定位。链接在软件开发中扮演着一个关键的角色，因为它使得分离编译成为可能。无需将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块，极大地提高了大型程序编写的效率。 5.2在Ubuntu下链接的命令 命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 利用readelf-ahello>h1elf.txt查看可执行目标文件hello的ELF格式，并将结果重定向到h1elf.txt。其中信息相似的部分在4.3已经有过介绍，就不再赘述了，新的部分会在下面进行补充： ELF头： 节头： 程序头：描述了可执行文件的连续的片映射到连续的内存段的映射关系。包括目标文件的偏移、段的读写/执行权限、内存的开始地址、对齐要求、段的大小、内存中的段大小等。 符号表：相比于hello.o多出的符号是链接后产生的库中的函数以及一些必要的启动函数。 同时还有动态符号表，里面的符号都是共享库中的函数，需要动态链接： 重定位节：我们可以看到原来的.rela.text节已经没有了，说明链接的过程已经完成了对.rela.text的重定位操作。并且出现了新的重定位条目，它们和共享库中的函数有关，因为此时还没有进行动态链接，共享库中函数的确切地址仍是未知的，因此仍然需要重定位节，在动态链接后才能确定地址。 5.4hello的虚拟地址空间 通过edb，看出hello的虚拟地址空间开始于0x400000,结束与0x400ff0： 而其中，我们分析.rodata： 可以看到该节的位置,大小都和前面的节头一致，其他不一一列出了。 5.5链接的重定位过程分析 利用objdump-d-rhello进行hello的反汇编。 hello.o和hello反汇编的对比： 相比之下hello反汇编后多了许多文件节： hello.o反汇编之后其中的地址大多是相对偏移地址，而hello反汇编的地址是虚拟地址。这是因为hello已经是可执行文件了，相关的重定位工作必须已经完成，所有虚拟地址也必须确定。 相比之下，hello反汇编之后增加了许多外部链接的共享库函数： 重定位分析：当汇编器生成一个目标模块时，针对最终位置未知的目标引用，它会生成一个重定位条目，告诉链接器在生成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。在把hello.o链接为可执行文件hello的过程中，链接器就是根据.rel_data和.rel_text节中保存的重定位信息对符号或者函数进行重定位的。 重定位算法如下： 以hello.o重定位表中的第一项为例，目标符号引用出现在偏移0x1c处，其运行时地址为0x401141，目标符号定义在.rodata节中，其运行时地址为0x402008，我们记录下一条指令的运行时地址0x401145，将其与目标符合定义处的运行时地址做差得0x0ec3，将其转化为小端法表示则为c30e0000，与结果刚好相符。 5.6hello的执行流程 程序名程序地址ld-2.27.so!_dl_start0x7fce8cc38ea0ld-2.27.so!_dl_init0x7fce8cc47630hello!_start0x400550hello!init0x4004c0hello!main0x400582hello!puts@plt0x4004f0hello!exit@plt0x400530hello!printf@plt0x400500hello!sleep@plt0x400540hello!getchar@plt0x400510sleep@plt0x400540 5.7Hello的动态链接分析 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时，还是需要用到动态链接库。在调用共享库函数时生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。GNU编译系统使用延迟绑定，将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定是通过全局偏移量表(GOT)和过程连接表(PLT)实现的。GOT是数据段的一部分，而PLT是代码段的一部分。两表内容分别为： PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 接下来我们对hello的动态链接进行分析： 根据hello可执行目标文件可知，如下图所示，GOT运行时地址为0x403ff0，PLT的运行时地址为0x404000： 在程序调用dl_init前，使用edb查看地址0x404000处的内容： GOT表的内容在调用_start之后发生改变，其中GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是共享库模块的入口点。 5.8本章小结 本章首先介绍了链接的概念、作用，查看了hello的格式，随后分析了可执行目标文件与可重定位目标文件的区别，利用hello详细介绍了静态链接的重定位等过程，之后分析了hello的执行流程并且对hello介绍了动态链接分析，此时hello程序就可以加载到内存中执行了。 第6章hello进程管理 6.1进程的概念与作用 概念：进程就是一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文中。其中上下文是由程序正确运行所需的状态组成的，包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。 作用：进程的作用在于通过进程可以提供给我们一个假象，就好像我们的程序是系统中运行的唯一的程序；程序好像独占地使用处理器和内存；处理器好像是无间断地一条接一条地执行程序中的指令；程序的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 作用：Shell是用户与操作系统之间完成交互式操作的一个接口程序，它为用户提供简化了的操作。Shell最重要的功能是命令解释，从这种意义上说，Shell是一个命令解释器。Linux系统上的所有可执行文件都可以作为Shell命令来执行。当用户提交了一个命令后，Shell首先判断它是否为内置命令，如果是就通过Shell内部的解释器将其解释为系统功能调用并转交给内核执行；若是外部命令或实用程序就试图在硬盘中查找该命令并将其调入内存，再将其解释为系统功能调用并转交给内核执行。 处理流程： 终端进程读取用户由键盘输入的命令行。 分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量。 检查首个命令行参数是否是一个内置的shell命令。 如果不是内部命令，调用fork()创建新进程/子进程。 在子进程中，用步骤2获取的参数，调用execve()执行指定程序。 如果用户没要求后台运行(命令末尾没有&号）否则shell使用waitpid等待作业终止后返回。 如果用户要求后台运行(如果命令末尾有&号），则shell返回。 6.3Hello的fork进程创建过程 （以下格式自行编排，编辑时删除） 当在shell中输入命令“./hello1190200106何炫霖”时，shell解析输入的命令行，获得命令行指定的参数。由于./hello不是shell内置的命令，因此shell将hello看作一个可执行目标文件，在相应路径里寻找hello程序，找到该程序就执行它。shell会通过调用fork()函数创建一个子进程，新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同但独立的一个副本，包括代码段、数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，子进程可以读写父进程中打开的任何文件。父进程和子进程之间最大的区别在于它们的PID不同。hello程序之后就会运行在这个新创建的子进程的上下文中。 6.4Hello的execve过程 当创建了一个子进程之后，exceve函数在当前子进程的上下文加载并运行一个新的程序，加载并运行需要以下几个步骤： 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中已存在的区域结构。 映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些区域结构都是私有的，写时复制的。虚拟地址空间的代码和数据区域被映射为hello文件的.txt和.data区。 映射共享区域。如果hello程序与共享对象链接，然后再映射到用户虚拟地址空间中的共享区域。 设置程序计数器。exceve做的最后一件事就是设置当前进程的上下文中的程序计数器，使之指向代码区域的入口点。下一次调用这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 6.5Hello的进程执行 用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，这个模式中，硬件防止特权指令的执行，并对内存和I/O空间的访问操作进行检查。设置模式位时，进程处于内核模式，一切程序都可运行。任务可以执行特权级指令，对任何I/O设备有全部的访问权，还能够访问任何虚地址和控制虚拟内存硬件。 上下文信息：上下文程序正确运行所需要的状态，包括存放在内存中的程序的代码和数据，用户栈、用寄存器、程序计数器、环境变量和打开的文件描述符的集合构成。 Hello进程执行分析： Hello起初在用户模式下运行，在hello进程调用sleep之后转入内核模式，内核休眠，并将hello进程从运行队列加入等待队列，定时器开始计时2s，当定时器到时，发送一个中断信号，此时进入内核状态执行中断处理，将hello进程从等待队列中移出重新加入到运行队列，hello进程继续执行。 6.6hello的异常与信号处理 异常和信号异常可以分为四类：中断、陷阱、故障、终止： 对于hello程序： 正常运行： 随机键盘输入： 可以看到，无意义输入均被缓存到stdin，当调用getchar时读出一个‘\n’结尾的字符串，其他字符会当做shell命令输入，并且无意义输入并不会影响到hello进程的运行。 Ctrl+c： 按下Ctrl-C后，hello进程运行终止。组合键Ctrl-C会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况下，结果是终止前台作业。利用ps指令可以看到，hello进程已经父进程回收，进程表中无hello进程： Ctrl+z： 按下Ctrl-Z后，hello进程运行暂停。组合键Ctrl-Z会导致内核发送一个SIGSTP信号到前台进程组的每个进程，默认情况下，结果是挂起前台作业。 ps： 可以看到，hello进程并没有被回收，此时其后台作业号为1。 jobs： 可以看出当前的作业是hello进程，且状态是已停止。 pstree(部分)：将所有进程以树状图形式显示 fg： fg命令可以使停止的hello进程继续在前台运行，可以看到hello程序继续运行了。 kill： kill命令可以给指定进程发送信号。如图，kill-93647是指向PID为3647的进程（即hello）发送SIGKILL信号。这个命令会杀死hello进程，当再次使用ps时可以发现hello进程已经被杀死。 6.7本章小结 本章介绍了进程的概念与作用，同时介绍shell的一般处理流程和作用，并且分析了调用fork函数创建新进程和调用execve函数加载并执行hello，最后分析了hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：逻辑地址是指由程序产生的与段相关的偏移地址部分。例如，在进行C语言指针编程中，可以使用&操作读取指针变量的值，这个值就是逻辑地址，是相对于当前进程数据段的地址。一个逻辑地址由两部份组成：段标识符和段内偏移量。 线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址生成了一个线性地址。如果启用了页式管理，那么线性地址可以再变换产生物理地址。若没有启用页式管理，那么线性地址直接就是物理地址。 虚拟地址：因为虚拟内存空间的概念与逻辑地址类似，因此虚拟地址和逻辑地址实际上是一样的，都与实际物理内存容量无关。 物理地址：存储器中的每一个字节单元都给以一个唯一的存储器地址，用来正确地存放或取得信息，这个存储器地址称为物理地址，又叫实际地址或绝对地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址的表示形式为[段标识符：段内偏移量]，这个表示形式包含完成逻辑地址到虚拟地址（线性地址）映射的信息。 逻辑地址实际是由48位组成的，前16位是段选择符，后32位是段内偏移量。通过段选择符，我们可以获得段基地址，再与段内偏移量相加，即可获得最终的线性地址。 段标识符又名段选择符，是一个16位的字段，包括一个13位的索引字段，1位的TI字段和2位的RPL字段。 通过段标识符的前13位，可以直接在段描述符表中索引到具体的段描述符。每个段描述符中包含一个Base字段，它描述了一个段的开始位置的线性地址。将Base字段和逻辑地址中的段内偏移量连接起来就得到转换后的线性地址。全局的段描述符，放在全局段描述符表中，每个进程自己的段描述符，放在局部段描述符表中。全局段描述符表存放在gdtr控制寄存器中，而局部段描述符表存放在ldtr寄存器中。 逻辑地址到线性地址的变换过程为：给定逻辑地址，看段选择符的最后一位是0还是1，从而判断选择全局段描述符表还是局部段描述符表。通过段标识符的前13位，得到Base字段，和段内偏移量连接起来最终得到转换后的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 页表： 页表是一个页表条目（PTE）的数组，用于维护物理地址和虚拟地址的映射关系。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。每个PTE由一个有效位和一个n位地址字段组成，有效位表明该虚拟页是否被缓存在DRAM中。如果设置了有效位，那么地址字段表示相应的物理页的起始位置；如果没有设置有效位，那么空地址表示虚拟页还未被分配，否则这个地址指向该虚拟页在磁盘的起始位置。 如果不考虑TLB与多级页表，虚拟地址可以分为虚拟页号VPN和虚拟页偏移量VPO。其中，VPN可以作为到页表中的索引。进而，通过页表基址寄存器（PTBR）我们可以在页表中获得条目PTE。一条PTE中包含有效位和物理页号（PPN）。如果有效位是0，则代表页面不在存储器中（缺页）；如果有效位是1，则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，再与物理页偏移量（PPO）共同构成物理地址PA。 当页面命中时CPU硬件执行的步骤： 1．处理器生成一个虚拟地址，并把它传送给MMU； 2．MMU生成PTE地址，并从高速缓存/主存请求得到它； 3．高速缓存/主存向MMU返回PTE； 4．MMU构造物理地址，并把它传送给高速缓存/主存； 5．高速缓存/主存返回所请求的数据字给处理器。 7.4TLB与四级页表支持下的VA到PA的变换 PTE有三个权限位，控制对页的访问。R/W位确定页的内容是可以读写的还是只读的。U/S位确定是否能够在用户模式中访问该页，从而保护操作系统内核中的代码和数据不被用户程序访问。禁止执行位可以用来禁止从某些内存读取指令。当MMU翻译每一个内存地址时，它还会更新另外两个内存缺页处理程序会用到的位。每次访问一个页时，MMU都会设置引用位。内核可以用这个引用位来实现它的页替换算法。每次对一个页进行了写之后，MMU都会设置修改位或脏位。修改位告诉内核在复制替换页之前是否必须写回牺牲页。内核可以通过调用一条特殊的内核模式指令来清除引用位和修改位。 Corei7MMU中，36位VPN被划分成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 7.5三级Cache支持下的物理内存访问 首先使用物理地址的CI进行组索引，对8个块分别对CT进行标志位的匹配。如果匹配成功且块的有效位为1，则成功命中。然后根据数据偏移量CO取出相应的数据并返回。这里的数据保存在一级Cache。 如果没有命中，或者没找到相匹配的标志位，那么就会在下一级Cache中寻找，只要本级Cache中没找到就要去下一级的Cache中寻找数据，然后逐级写入Cache。 在更新Cache的时候，首先需要判断是否有有效位为0的块。若有，则直接写入；若不存在，则需要驱逐一个块（LRU策略），再进行写入。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。内核给新进程创建虚拟内存，创建当前进程的mm_struct、区域结构和页表的原样副本，将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，为每个进程保持了私有地址空间的抽象概念。同时延迟私有对象中的副本直到最后可能的时刻，充分利用了稀有的物理内存。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码,在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1.删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2.映射私有区域,为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的,初始长度为零。 3.映射共享区域，hello程序与共享对象libc.so链接,libc.so是动态链接到这个程序中的,然后再映射到用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 处理缺页要求硬件和操作系统内核协作完成： 1：处理器生成一个虚拟地址，并把它传送给MMU。 2：MMU生成PTE地址，并从高速缓存/主存请求得到它。 3：高速缓存/主存向MMU返回PTE。 4：PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。 5：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。 6：缺页处理程序页面调人新的页面，并更新内存中的PTE。 7：缺页处理程序返回到原来的进程，再次执行导致缺页的指令，CPU将地址重新发送给MMU。因为虚拟页面现在已经缓存在物理内存中，所以会命中，主存将所请求字返回给处理器。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块： 显式分配器：要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。C++中的new和delete操作符与C中的malloc和free相当。显式分配器必须在严格的约束条件下工作，约束有：必须处理任意请求序列；立即响应请求；只使用堆；对齐块；不修改已分配的块。分配器的编写应该实现：吞吐率最大化；内存使用率最大化（两者相互冲突）。 隐式分配器：要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集。例如，诸如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 在分配器的具体实现中，主要有以下几种实现方法： 显式空闲链表： 堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。这样一来，会使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。显式空闲链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。 隐式空闲链表： 隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要求对空闲链表进行搜索，该搜索时间与堆中已分配块和空闲块的总数呈线性关系。 带边界标记的隐式空闲链表： 这种方式可以允许在常数时间进行对前面块的合并，并且它对许多不同类型的分配器和空闲链表组织都是通用的。然而它也存在一个潜在的缺陷。它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销。 7.10本章小结 本章先介绍了各类地址的概念，然后分析了从逻辑地址到线性地址的变化（段式管理），以及从线性地址到物理地址的变化（页式管理）。然后解析了TLB与四级页表支持下的VA到PA的变换详细分析了地址翻译的过程，分析了三级Cache支持下的物理内存访问，以及hello进程fork和execve时的内存映射，还有缺页故障与缺页中断处理的操作过程。最后讲述了动态存储分配管理的基本方法和策略，从而得到了一个较为完整的动态分配内存的过程。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，所有的输入输出都被当作对相应文件的读和写来执行。 设备管理：unixio接口 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 UnixI/O接口： 打开文件： 一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息，应用程序只需要记住这个描述符。 linuxshell： 创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件中的常量可以代替显式的描述符值。 改变当前的文件位置： 对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。 读写文件： 一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 关闭文件： 当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： 打开文件的函数：intopen(char*filename,intflags,mode_tmode)； open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件；mode参数指定了新文件的访问权限位。 关闭文件的函数：intclose(intfd)； fd是需要关闭的文件描述符，成功返回0，错误返回-1。关闭一个已关闭的描述符会出错。 读写文件的函数：ssize_tread(intfd,void*buf,size_tn)； ssize_twrite(intfd,constvoid*buf,size_tn)； read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 先看printf函数的源码： int printf(const char *fmt,  ) { int i; char buf[256]; va_list arg = (va_list)((char*)(&fmt) + 4); i = vsprintf(buf, fmt, arg); write(buf, i); return i; } printf函数是格式化输出函数,一般用于向标准输出设备按规定格式输出信息。printf中调用了两个函数，分别为vsprintf和write： 对于vsprintf函数，它根据格式串fmt，并结合args参数产生格式化之后的字符串结果保存在buf中，并返回结果字符串的长度。 对于write函数： moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL 它将buf中的i个字符写到终端，由于i保存的是结果字符串的长度，因此write将格式化后的字符串结果写到终端。 sys_call函数： sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret 它实现的功能就是把将要输出的字符串从总线复制到显卡的显存中。显存中存储的是字符的ASCII码。字符显示驱动子程序通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar源码如下： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } getchar函数会从输入流中读入一个字符，输入的字符会存放在缓冲区中，如果输入了多个字符，之后的getchar会直接从缓冲区中读取字符。 getchar的返回值是读取字符的ASCII码，若出错则返回-1。 而对于异步异常-键盘中断的处理为键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章首先介绍了Linux的IO设备管理方法、UnixIO接口及其函数，最后分析了printf函数和getchar函数的实现。 结论 hello经历的过程： 源程序编写：通过编写工具(文本编辑器、IDE等)编写出hello.c； 预处理：预处理器cpp读取需要的系统头文件内容，生成ASCII码的中间文件hello.i。 编译：编译器ccl将C语言代码翻译成汇编指令，生成hello.s。 汇编：汇编器as将hello.s翻译成机器语言指令，并生成重定位信息，将结果保存在可重定位目标文件hello.o中。 链接：链接器进行符号解析、重定位、动态链接等创建一个可执行目标文件hello，此时hello可以被执行。 运行阶段：当我们在shell键入./hello启动程序的时候，shell调用fork函数为其产生子进程，子进程中调用execve函数，加载hello程序，进入hello的程序入口点。 进程运行：内核负责调度进程，并对可能产生的异常及信号进行处理。内存的管理由MMU、TLB、多级页表、cache、DRAM内存、动态内存分配器共同完成，而UnixI/O的作用则是让程序与文件进行交互。 终止：hello最终被shell父进程回收，内核删除为hello进程创建的所有数据结构。 感悟： hello从诞生到结束，需要在硬件、操作系统、软件的相互协作配合下，才能最终让它完美地实现自己的功能。从中我看到了对于一个系统而言，需要进行多方面的协调配合才能让每个模块发挥相应的功能。同时，计算机科学家们所做的抽象让应用与具体实现相互分离，从而让我们在实际体验当中往往会忽略它背后隐藏的复杂，我认为这是十分伟大的工作。 通过本门课程的学习，我觉得更多的是给我打开了计算机领域的大门，里面蕴藏着一代代科学家毕生研究的结晶，有许多奥秘等着我去探索，我还需要在未来的学习中更深入的研究里面的知识。 附件 文件名文件作用hello.i预处理器修改了的源程序，分析预处理器行为hello.s编译器生成的编译程序，分析编译器行为hello.o可重定位目标程序，分析汇编器行为hello可执行目标程序，分析链接器行为helf.txthello.o的elf格式，分析汇编器和链接器行为h1elf.txt可执行hello的elf格式，用来进行重定位过程分析 参考文献 [1]ANSIC标准定义的C语言预处理指令总结https://blog.csdn.net/zxnsirius/article/details/51158895?utm_source=itdadao&utm_medium=referral [2] 深入了解计算机系统（第三版）2016Bryant,R.E.机械工业出版社 [3] GCC编译器将源程序“.c”文件翻译为可执行文件的过程https://blog.csdn.net/qq_41543757/article/details/101019828 [4] printf函数实现的深入剖析https://www.cnblogs.com/pianist/p/3315801.html 

计算机系统大作业 程序人生-Hello’sP2P 摘 要 本文主要介绍了hello程序在Linux系统下的整个生命周期。详细地对预处理、编译、汇编、链接的过程进行了分析，并讨论了hello的进程管理、存储管理以及IO管理，介绍了汇编指令、机器代码、重定位、动态链接、异常控制流、虚拟内存以及IO函数的相关内容，对hello的一生进行了完整的描述，漫游了整个计算机系统。 关键词：汇编；链接；进程；虚拟内存；IO； 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 hello的P2P过程是从一个程序员输入的源文件hello.c开始的。hello.c分别经过预处理器cpp的预处理生成修改了的源程序hello.i、编译器ccl的编译生成汇编程序hello.s、汇编器as的汇编生成可重定位目标程序hello.o，最后通过链接器ld的链接生成可执行目标程序hello。当在shell中输入./hello后，shell会调用fork函数创建一个新的进程，然后调用execve将其加载到内存中，此时hello便从一个程序变为了进程。 随后CPU控制其逻辑流的运行、中断以及上下文切换。当进程终止后，父进程负责回收hello进程，内核删除相关数据结构。此过程即为hello的020. 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位 开发与调试工具：edb,gcc,gdb,readelf,HexEdit,vim 1.3中间结果 文件名称文件作用hello.ihello.c经过预处理后生成的修改了的源程序hello.shello.i经过编译后生成的汇编程序hello.ohello.s经过汇编后生成的可重定位目标程序hellooelf.txt保存hello.o的elf格式的文件信息的文本文件hellooobjdump.txt保存hello.o经过反汇编后生成的内容的文本文件hellohello.o经过链接后生成的可执行目标程序helloelf.txt保存hello的elf格式的文件信息的文本文件helloobjdump.txt保存hello经过反汇编后生成的内容的文本文件 1.4本章小结 本章主要介绍了hello程序的P2P、020的过程，并列出了实验环境与工具以及中间结果的相关信息。 第2章预处理 2.1 预处理的概念与作用 1.预处理的概念：预处理器(cpp)根据以字符#开头的命令，修改原始的C程序，得到一个以.i作为文件扩展名的C程序。 2.预处理的作用： (1).宏定义：用实际值替换用#define定义的字符串。 (2).文件包含：将#include所包含的头文件直接加入到文本文件中。比如#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。 (3).条件编译：如#ifdef，#ifndef，#else，#elif，#endif等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。 2.2在Ubuntu下预处理的命令 命令：gcc-m64-no-pie-fno-PIChello.c-E-ohello.i 图2.1Ubuntu下的预处理 2.3Hello的预处理结果解析 图2.2hello的预处理结果 经过预处理后，hello.c文件生成了hello.i文件，打开hello.i文件后可见文件从原本的28行扩展到了3000多行。原文件中包含的头文件stdio.h、unistd.h、stdlib.h的内容被插入到了该文件中。 2.4本章小结 本章主要介绍了预处理的概念及其作用，对hello.c文件进行了预处理操作并解析了其预处理的结果。 第3章编译 3.1编译的概念与作用 1.编译的概念：编译是指编译器做词法分析、语法分析、语义分析等，在检查无错误后，将代码翻译成汇编语言的过程。编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。 2.编译的作用： (1).进行词法分析和语法分析，分析过程中发现有语法错误，给出提示信息。 (2).将文本文件转化为汇编语言的形式，为后续的汇编操作奠定基础。汇编语言是非常有用的，它为不同的高级语言的不同编译器提供了通用的输出语言。最后生成一个汇编语言程序.s文件。 (3).除了基本功能之外，编译程序还具备调试措施、修改手段、覆盖处理、目标程序优化、不同语言合用等重要功能。 3.2在Ubuntu下编译的命令 命令：gcc-m64-no-pie-fno-PIC-Shello.i-ohello.s 图3.1Ubuntu下编译的命令 3.3Hello的编译结果解析 3.3.1数据 局部变量 main函数中声明了一个局部变量i，在编译时局部变量i会存放在堆栈中，如图所示，其初始值被赋值为0，存放在栈上%rbp-4的位置处。 图3.2局部变量 全局变量 在文件的开头定义了全局变量sleepsecs，由于其为int类型，故被赋值为2，并存放在.rodata节中。如图所示。 图3.3全局变量 立即数 立即数直接体现在汇编代码中，如图所示。 图3.4立即数 参数intargc argc作为传递给main的第一个参数，存放在堆栈上，如图所示，原本存放在寄存器%edi中的argc被存放在%rbp-20的位置处。 图3.5参数intargc的存放位置 数组char*argv[] char*argv[]是传递给main的第二个参数，其数组中的每一个元素均为字符类型的指针。如图所示，其被存放在%rbp-32位置处。 图3.6数组char*argv[]的存放位置 字符串 程序中共有两个字符串，如图所示，这两个字符串均存放在只读数据段中。 图3.7字符串 3.3.2赋值 程序中有两处赋值操作，第一处将全局变量sleepsecs赋值为2，第二处使用movl指令将局部变量i赋值为0.如图所示。 图3.8赋值 3.3.3类型转换 程序中涉及到隐式类型转换。全局变量sleepsecs定义为int类型，但在程序最开始处被赋值为2.5，即float类型。编译器将2.5隐式地转换成2存入sleepsecs中。如图所示。 图3.9类型转换 3.3.4算术操作 在循环体中，每次循环后都会执行i++操作，其被编译器处理的结果如下图所示，使用addl指令使i每次都加上立即数1. 图3.10算术操作 3.3.5关系操作 1.程序中涉及到的第一个关系操作是argc!=3，其被编译的结果如图所示，比较argc与立即数3是否相等，若相等则跳转到.L2。cmpl的指令还会设置条件码，根据条件码来判断是否需要跳转到分支中。 图3.11 关系操作1 2.第二个关系操作是i<10，其被编译的结果如图所示，判断i是否小于等于9，若是则跳转到.L4。 图3.12关系操作2 3.3.6数组操作 程序中包函数组char*argv[]，其数组中的每一个元素均为字符类型的指针。如图所示，其被存放在%rbp-32位置处。 图3.13数组的存放位置 当后续程序中调用printf函数输出argv[1]、argv[2]的值时，需要通过对数组的首地址加上相应的偏移量得到相应的数组元素的地址，然后通过movq指令即可得到数组元素的值。如图所示。 图3.14数组操作 3.3.7控制转移 汇编语言中首先设置条件码，然后根据条件码来进行控制转移。第一处控制转移为if(argc!=3)，其判断i是否等于3，如果i等于3，则不执行if语句，否则执行if语句。此部分被编译为cmpl和je条件跳转指令。如图所示。 图3.15控制转移1 第二处控制转移为for(i=0;i<10;i++)循环。通过每次判断i是否满足小于10来判断是否需要跳转至循环语句中。此部分被编译为cmpl和jle条件跳转指令。如图所示。 图3.16控制转移2 3.3.8函数操作 1.参数传递 该程序向main函数传递了两个参数，分别为intargc,char*argv[]，这两个参数在最开始分别被存放在了寄存器%edi、%rsi中。如图所示。 图3.17参数传递1 此外，执行循环中的printf函数时同样传递了两个参数argv[1]、argv[2]，这两个参数被作为参数传递的过程如图所示。 图3.18参数传递2 循环中还调用了sleep函数，并将sleepsecs作为参数传递进去，其传递过程如图所示。 图3.19参数传递3 从以上的传递过程中可以看出，要传递的参数都会存放在寄存器中，大多数情况下，第一个参数存放在%rdi中，第二个参数存放在%rsi中，第三个参数存放在%rdx中，第四个参数存放在%rcx中，以此类推。 2.函数调用 大多数情况下，调用函数时只需使用call指令进行调用即可。例如本程序中，调用printf、sleep和getchar函数的过程如图所示。 图3.20函数调用 3.函数返回 大多数情况下，函数的返回值都保存在寄存器%rax中，在本例中，函数的返回过程如图所示。 图3.21函数返回 3.4本章小结 本章主要讲述了编译的概念与作用，并解析了编译器将预处理文本文件hello.i翻译为文本文件hello.s的过程中如何处理各种数据和操作以及c语言中各种数据类型和操作所对应的的汇编代码。 第4章汇编 4.1汇编的概念与作用 汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含程序的指令编码。 4.2在Ubuntu下汇编的命令 命令：gcc-m64-no-pie-fno-PIChello.s-c-ohello.o 图4.1Ubuntu下汇编的命令 4.3可重定位目标elf格式 使用readelf-ahello.o>hellooelf.txt命令获得hello.o的elf文件并重定向到hellooelf.txt.下面对elf文件的各个部分进行分析。 1.elf头 elf头以16字节的序列Magic开始，该字节序列描述了生成该文件的系统的字的大小和字节顺序。elf头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括elf头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量等信息。不同节的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定大小的条目。 根据该elf头的信息，可知该文件类型为可重定位目标文件，且一共包含14个节。 图4.2elf头 2.节头部表 节头部表描述目标文件的节，包括节的类型、位置和大小等信息。由于该文件为可重定位目标文件，所以每个节都从0开始，用于重定位。在文件中得到节头部表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小。同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。 图4.3节头部表 3.重定位节 重定位节是一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。 重定位节中包含以下的几项信息： Offset（偏移量）：需要被修改的引用节的偏移。 Info（信息）：包括symbol和type两个部分，symbol在前面四个字节，type在后面四个字节。其中symbol标识被修改引用应该指向的符号，type告知链接器如何修改新的引用。 Type（类型）：重定位的类型。elf定义了32种不同类型的重定位类型，这里只关注其中两种最基本的重定位类型。R_X86_64_PC32为重定位一个使用32位PC相对地址的引用。R_X86_64_32为重定位一个使用32位绝对地址的引用。 Sys.Name（符号名称）：重定向到的目标的名称。 Addend（加数）：一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。 图4.4重定位节 4.符号表 符号表存放程序中定义和引用的函数和全局变量的信息。其中不包含局部变量的条目。 符号表中包含以下的几项信息： Value：符号相对于目标节的起始位置的偏移量，对于可执行目标文件，该值是一个绝对运行的地址。 Size：目标的大小。 Type：指明符号的种类。可以是数据、函数、文件、节或者NOTYPE的一种。 Bind：表明符号是本地的还是全局的。 Name：符号名称。 图4.5符号表 4.4Hello.o的结果解析 执行命令objdump-d-rhello.o后得到的结果如下图所示。 图4.6hello.o的反汇编 将其与hello.s进行比较可知，其余汇编语言的指令并没有什么不同，反汇编代码中包含机器代码。机器语言是用二进制表示的语言，也是机器能够真正识别的语言，机器指令由操作码和操作数构成。每一条汇编语言中的指令都可以对应于唯一的一个二进制数据表示，而汇编语言的操作数本身也可以表示为二进制数据，故每一条汇编语言的指令，即操作码+操作数都可以与机器指令建立一一对应的映射关系。从而能够通过这种映射关系将机器指令反汇编为我们更熟悉的、更接近CPU的动作和运行原理的汇编语言。 但同时机器语言中的操作数与汇编语言有时会出现不一致的现象，主要体现在以下两种情况时： 分支转移 反汇编的分支转移指令中的操作数用的并不是段的名称，如.L2、.L3等，而是用的确定的地址，如2d<main+0x2d>、6f<main+0x6f>等。段的名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后是不存在的，故必须使用确定的地址。 函数调用 在汇编语言中，函数调用的指令中使用的是函数名称，而在反汇编中，call指令后面的地址为call指令之后的一条指令的地址。因为hello.c中调用的函数都是共享库中的函数，故需要通过等待调用动态的链接把重定位的函数目标地址链接到共享库程序当中，最终需要通过动态链接器才能确定函数的运行时地址。在汇编成为机器语言时，对于这些不确定地址的函数调用，直接将其call指令后的相对地址设置为0，则目标地址正是下一条指令的地址，然后在.rela.text节中为其添加重定位条目，等待链接的进一步确定。 4.5本章小结 本章主要介绍了汇编的概念和作用，分析了可重定位目标elf格式中的elf头、节头部表、重定位节和符号表，同时解析了将hello.s汇编后生成的hello.o的结果并分析了汇编语言与机器语言之间的关系。 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载(复制)到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器的程序自动执行的。 hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，这个文件必须以某种方式合并到hello.o程序中。链接器就负责处理这种合并。结果得到hello文件，它是一个可执行目标文件，可以被加载到内存中由系统执行。 5.2在Ubuntu下链接的命令 命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1Ubuntu下链接的命令 5.3可执行目标文件hello的格式 使用readelf-ahello>helloelf.txt命令获得hello的elf文件并重定向到helloelf.txt.下面对elf文件的各个部分进行分析。 1.elf头 elf头的部分信息与hello.o的elf文件的elf头相同，其他信息均不同。例如，文件类型不同。hello.o文件为可重定位目标文件，而hello为可执行文件。hello.o的入口点地址、程序头起点、程序头大小和程序头数量均为0，而hello的均不为0。二者节头的起点不同。且hello一共包含27个节。 图5.2elf头 2.节头部表 节头部表中包含了hello中所有的节的信息，其中包括名称、类型、大小、地址和偏移量等信息，其中地址是程序被载入到虚拟地址的起始地址，偏移量是各个节在程序中的偏移量。根据节头部表的信息可以使用HexEdit定位各个节的起始位置及大小。 图5.3节头部表 3.程序头部表 elf可执行文件被设计的很容易加载到内存，可执行文件的连续的片被映射到连续的内存段，程序头部表描述了这种映射关系。程序头部表中包括各个程序头的偏移量、内存地址、对其要求、目标文件和内存中的段大小以及运行时访问权限等信息。 图5.4程序头部表 4.段节 图5.5段节 5.动态节 图5.6动态节 6.重定位节 重定位节包含了.text节中一些需要对目标进行重定位的函数信息,当链接器把函数的目标位置文件和其他目标文件组合在一起的时候,需要修改这些函数的位置。下图描述了程序中需要重定位的链接器函数的相关信息。 图5.7重定位节 7.动态符号表 用来保存与动态链接相关的导入导出符号，不包括模块内部的符号。 图5.8动态符号表 8.符号表 符号表存放程序中定义和引用的函数和全局变量的信息。符号表的索引就是这个数组的下标。 图5.9符号表 5.4hello的虚拟地址空间 用edb打开hello，查看memoryregions可知，hello的虚拟地址空间开始于0x400000，结束于0x405000.如图所示。 图5.10hello的虚拟地址空间 根据5.3节中的节头部表，即可通过edb找到各个节的信息。例如，.text节的地址为0x4010d0，大小为0x135，用edb查找后如下图所示。 图5.11.text节 .data节的地址为0x404040，大小为0x8，用edb查找后如下图所示。 图5.12.data节 .rodata节的地址为0x402000，大小为0x2f，用edb查找后如下图所示。其他的节查找也是如此。 图5.13.rodata节 此外，还可以根据5.3节中的程序头部表通过edb查询各程序头的信息。其中，程序头部的类型包含以下几种： PHDR：保存了二进制的程序头表。 INTERP：指定在程序已经从可执行文件映射到具体的内存区域之后，必须进程调用的解释器（如动态链接器）。 LOAD：表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据、程序的目标代码等 DYNAMIC：保存了由动态链接器使用的信息。 NOTE：保存辅助信息。 GNU_STACK：权限标志，标志栈是否是可执行的 GNU_RELRO：这个节中指定了在重定位程序结束之后那些映射到内存的区域是需要重新设置为只读类型的。 用edb的datadump即可查询各个程序头部的信息，例如类型为INTERP的程序头，其虚拟地址为0x4002e0，内存大小为0x1c，用edb查找后如下图所示。 图5.14INTERP程序头 其他的程序头部查找也是如此。 5.5链接的重定位过程分析 使用命令：objdump-d-rhello>helloobjdump.txt,获得hello的反汇编代码。通过比较hello与hello.o的反汇编代码可知，hello的反汇编代码有确定的虚拟地址，也就是已经完成了重定位,而hello.o的反汇编代码中代码的虚拟地址均为0，未完成可重定位的过程。如下面的两张图所示，可以比较出二者的差别。 图5.15hello的反汇编中的main函数 图5.16hello.o的反汇编 此外，hello的反汇编代码中多了很多节以及很多函数的汇编代码，如图所示。 图5.17hello的反汇编中除main函数外的内容 这些节都具有一定的功能和含义，例如，.init节为程序初始化需要执行的代码，.plt节为动态链接过程链接表，.fini节为当程序正常终止时需要执行的代码等。 故经过以上分析可知，链接的过程就是将多个可重定位目标文件合并在一起，生成一个可执行文件。在这个过程中，需要进行符号解析、重定位以及计算符号引用地址这三个步骤，最后便完成了链接。 下面对hello的重定位过程进行分析。 一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成： 1.重定位节和符号定义：链接器将所有类型相同的节合并为同一类型的新的聚合节。然后链接器将运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。 2.重定位节中的符号引用：这一步中，链接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构。当汇编器遇到对最终位置未知的目标引用时，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。其中，.rel.text节的内容以及每个符号的含义在4.3节中已经详细介绍过，这里不再赘述，直接给出如下的重定位算法。 首先，ELF重定位条目格式如下： 图5.18elf重定位条目格式 下面给出两种不同重定位类型的重定位算法： 图5.19两种重定位算法 5.6hello的执行流程 hello的执行过程中调用与跳转的各个程序的先后顺序如下表所示： ld-2.31.so!_dl_startld-2.31.so!_dl_inithello!_startld-2.31.so!_libc_start_mainld-2.31.so!_cxa_atexitld-2.31.so!_libc_csu.initld-2.31.so!_setjmphello!mainld-2.31.so!exit 5.7Hello的动态链接分析 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时，还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。 假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是PIC，因为他需要链接器修改调用模块的代码段，GNU编译系统使用延迟绑定技术,将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的。这两个数据结构是GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。 PLT（过程链接表）是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。PLT[1]调用系统函数（__libc_start_main），它初始化执行环境，调用main函数并处理其返回值。从PLT[2]开始的条目调用用户代码调用的函数。GOT（全局偏移量表）是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 根据hello的elf文件，GOT起始表的位置为0x404000。使用edb查看可知，在调用dl_init之前，GOT表位置在0x404008后的16个字节均为0，如图所示。 图5.20调用dl_init前GOT表中的内容 在调用dl_init之后，0x404008后的16个字节发生变化，如图所示。 图5.21调用dl_init后GOT表中的内容 其中，0x403e50和0x7f81f6c3b190包含动态链接器在解析函数地址时会使用的信息，0x7f81f6c24bb0是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数。 在调用puts函数前，每个GOT条目指向其对应的PLT条目的第二条指令，如图为puts@plt的地址。 图5.22puts@plt函数的地址 调用puts函数前，即链接前如下图所示： 图5.23调用puts函数前的内容 可以看出其对应GOT条目初始时指向其PLT条目的第二条指令的地址。puts函数执行后的变化如下： 图5.24调用puts函数后的内容 可以看出其已经动态链接，GOT条目已经改变。 5.8本章小结 本章主要介绍了链接的概念与作用，分析了可执行目标文件hello的格式、hello的虚拟地址空间、链接的重定位过程，并对hello的执行过程和动态链接的过程进行了详细的分析与说明，至此，可执行目标文件hello已经生成了。 第6章hello进程管理 6.1进程的概念与作用 1.进程的概念： 进程就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 2.进程的作用： 进程提供给我们一些假象。在现代系统上运行一个程序时，好像我们的程序是系统中当前运行的唯一的程序一样，我们的程序好像独占地使用处理器和内存，处理器好像无间断地一条接一条地执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 1.作用：shell是一个交互型应用级程序，代表用户运行其他程序。是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。shell也是一个程序，它由输入设备读取命令，再将其转为计算机可以了解的机械码，然后执行它。shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。 2.处理流程： (1)终端进程读取用户由键盘输入的命令行。 (2)将输入的命令行字符串切分，获取命令行参数，并构造传递给execve的argv向量。 (3)检查第一个命令行参数是否是一个内置的shell命令 (4)如果是内置命令则立即执行；如果不是内部命令，调用fork创建子进程。 (5)在子进程中，用获取的命令行参数调用execve执行指定程序。 (6)如果命令末尾没有&号，则说明进程要前台运行，shell使用waitpid等待作业终止后返回。 (7)如果命令末尾有&号，则说明进程要后台运行，shell直接返回。 6.3Hello的fork进程创建过程 以hello为例，当输入./hello1190200109刘文卓时，shell会对输入的命令行进行解析，由于输入的不是内置命令，故shell会调用fork创建一个新运行的子进程。子进程得到与父进程用户级虚拟地址空间相同但是独立的一个副本，包括代码段、段、数据段、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，父进程和新创建的子进程之间最大的区别在于他们有不同的PID。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。 6.4Hello的execve过程 当创建了一个新运行的子进程后，子进程调用execve函数在当前子进程的上下文中加载并运行hello程序。execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到hello，execve才会返回到调用程序。所以execve调用一次并从不返回。 execve函数在当前子进程的上下文中加载并运行新程序hello，这个程序覆盖当前正在执行的进程的地址空间，但并没有创建一个新的进程，新的程序有和原先进程相同的PID，并且继承了调用execve函数时已经打开的所有文件描述符。新的栈和堆段都会被初始化为零，新的代码和数据段被初始化为可执行文件中的内容。只有一些调用程序头部的信息才可能会在加载的过程中被从可执行磁盘复制到对应的可执行区域的内存。 6.5Hello的进程执行 进程提供给应用程序两个关键的抽象： 1.一个独立的逻辑控制流，它提供一个假象，好像我们的进程独占的使用处理器。 2.一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用内存系统。 下面对这些抽象进行详细的阐述。 逻辑控制流：即使系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做逻辑控制流。 并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流。这两个流被称为并发的运行。多个流并发的执行的一般现象被称为并发。 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 私有地址空间：进程为每个流都提供一种假象，好像它是独占的使用系统地址空间。进程为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。 用户模式和内核模式：为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常是用一个寄存器中的一个模式位来提供这种功能的，该寄存器描述了进程当前享有的特权。当没有设置模式位时，进程就运行在用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；当设置了模式位时，进程运行在内核模式中，该进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。 上下文：上下文就是内核重新启动一个被抢占的进程所需的状态，它由通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值组成。 上下文切换：当内核选择一个新的进程运行时，则内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。上下文切换保存当前进程的上下文，恢复某个先前被抢占的进程被保存的上下文，将控制传递给这个新恢复的进程。 在hello进程执行时，进程调用execve函数，进程为hello程序分配新的虚拟的地址空间，并将hello的.text和.data节分配为虚拟地址空间的代码区和数据区。当输入./hello1190200109刘文卓并执行后，hello运行在用户模式下，输出Hello1190200109刘文卓，然后hello调用sleep函数，进程陷入内核模式。内核不会等待sleep函数调用结束，而是处理休眠请求并主动释放当前进程，将hello进程从运行队列中移出并加入等待队列，定时器开始计时，内核进行上下文切换将当前进程的控制权交给其他进程并回到用户模式下。当定时器到时后会发送一个中断信号，此时又会进入内核模式执行中断处理，将hello进程从等待队列中移出并重新加入到运行队列，成为就绪状态，这时再次回到用户模式下，hello进程继续执行自己的控制逻辑流。 在hello调用getchar函数时，执行过程和上述过程类似。在进行read调用之后从用户模式转到内核模式，内核中的处理程序请求来自键盘缓冲区的传输，并且安排在完成传输后中断处理器。内核执行上下文切换，切换到其他进程。当完成键盘缓冲区到内存的数据传输时，引发一个中断信号，此时内核从其他进程进行上下文切换回hello进程。 6.6hello的异常与信号处理 hello执行过程中可能会出现以下异常： 1.中断：即来自I/O设备的信号。在hello程序执行的过程中可能会出现外部I/O设备引起的异常。 2.陷阱：即有意的异常。hello执行sleep函数时会出现这个异常。 3.故障：即潜在可恢复的错误。在hello执行过程中可能会发生缺页故障。 4.终止：即不可恢复的错误。在hello执行过程中可能会出现DRAM或SRAM位损坏的奇偶错误。 当hello执行过程中发生缺页故障时，操作系统会发送SIGSEGV信号给用户进程，用户进程会以段错误退出。当hello执行过程中传入main函数的参数个数不为3时，hello进程会以1退出并终止，这时会向父进程发送SIGCHLD信号，父进程捕获这个信号并忽略它。 hello正常执行的结果是，当一开始输入的命令行为./hello1190200109刘文卓时，程序会输出10行Hello1190200109刘文卓，并在最后用户输入一个字符串，程序读入这个字符串然后结束。如图所示。 图6.1正常运行的程序结果 在hello运行过程中，从键盘的输入和操作也会导致一些异常。具体情况如下： 当用户按下Ctrl-C时，会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况是终止前台作业，即终止hello进程。此时用ps查看前台进程组发现没有hello进程。如图所示。 图6.2按下Ctrl-C的程序结果 当用户按下Ctrl-Z时，默认结果是挂起前台的作业，即hello进程并没有回收，而是运行在后台下，用ps命令可以看到hello进程。如图所示。 图6.3按下Ctrl-Z后输入命令ps的结果 此时，输入jobs命令进行查看，可知hello的后台作业号为1。 图6.4输入命令jobs的结果 使用fg1命令即可将hello调为前台进程，shell会先打印命令行，然后继续运行并打印剩下的8个字符串，最后输入字符串后程序结束，hello进程将被回收。如图所示。 图6.5输入命令fg1的结果 当用户按下回车时，程序会继续执行，回车会被缓存到stdin，当程序运行到调用getchar函数时，回车会被当做一个字符串的结尾并将其当做空字符串读入，程序正常终止结束并被回收。如图所示。 图6.6按下回车后的结果 当用户随便乱按时，与上一种情况类似，输入的字符都会被缓存到stdin，当程序运行到调用getchar函数时会被当做字符串读入并寻找一个输入的回车作为字符串结尾，然后程序正常终止结束并被回收。多余的字符串会被当做shell的命令行输入。如图所示。 图6.7随便乱按后的结果 6.7本章小结 本章主要介绍了进程的概念与作用，简述了shell的作用与处理流程，并详细地分析了hello的fork进程创建过程、execve过程以及hello进程的执行过程，并在最后举例总结了hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址： 工具书中，逻辑地址的概念如下： 在有地址变换功能的计算机中,访问指令给出的地址(操作数)叫逻辑地址,也叫相对地址。把用户程序中使用的地址称为相对地址即逻辑地址。逻辑地址由两个16位的地址分量构成，一个为段基值，另一个为偏移量。两个分量均为无符号数编码。 学术文献中，逻辑地址的概念如下： 存储单元的地址可以用段基址(段地址)和段内偏移量(偏移地址)来表示,段基址确定它所在的段居于整个存储空间的位置,偏移量确定它在段内的位置,这种地址表示方式称为逻辑地址,通常表示为段地址:偏移地址的形式。所谓逻辑地址是指按数据的逻辑块号给出的磁盘的位置（l块=512字l字=64位）。 线性地址（虚拟地址）： 线性地址（LinearAddress）是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。线性地址是一个32位无符号整数，可以用来表示高达4GB的地址，也就是，高达4294967296个内存单元。线性地址通常用十六进制数字表示，值的范围从0x00000000到0xffffffff。程序代码会产生逻辑地址，通过逻辑地址变换就可以生成一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换以产生一个物理地址。当采用4KB分页大小的时候，线性地址的高10位为页目录项在页目录表中的编号，中间10位为页表中的页号，其低12位则为偏移地址。如果是使用4MB分页机制，则高10位页号，低22位为偏移地址。如果没有启用分页机制，那么线性地址直接就是物理地址。 物理地址： 在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址（PhysicalAddress），又叫实际地址或绝对地址。地址从0开始编号，顺序地每次加1，因此存储器的物理地址空间是呈线性增长的。它是用二进制数来表示的，是无符号整数，书写格式为十六进制数。它是出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。 在计算机科学中，物理地址（英语：physicaladdress），也叫实地址（realaddress）、二进制地址（binaryaddress），它是在地址总线上，以电子形式存在的，使得数据总线可以访问主存的某个特定存储单元的内存地址。在和虚拟内存的计算机中，物理地址这个术语多用于区分虚拟地址。尤其是在使用内存管理单元（MMU）转换内存地址的计算机中，虚拟和物理地址分别指在经MMU转换之前和之后的地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部分组成，段标识符：段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节。索引号，是“段描述符(segmentdescriptor)”的索引，段描述符具体地址描述了一个段（对于“段”这个字眼的理解:我们可以理解为把虚拟内存分为一个一个的段。比如一个存储器有1024个字节，可以把它分成4段，每段有256个字节）。这样，很多个段描述符，就组了一个数组，叫“段描述符表”，这样，可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符，这个描述符就描述了一个段，每一个段描述符由8个字节组成，如图所示。 图7.1段描述符 这些东西很复杂，虽然可以利用一个数据结构来定义它，不过，这里只关心Base字段，它描述了一个段的开始位置的线性地址。Intel设计的本意是，一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。那究竟什么时候该用GDT，什么时候该用LDT呢？这是由段选择符中的T1字段表示的，=0，表示用GDT，=1表示用LDT。GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。如图所示。 图7.2GDT与LDT 首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]， 1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。 2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，得到Base，即基地址就知道了。 3、把Base+offset，就是要转换的线性地址了。 7.3Hello的线性地址到物理地址的变换-页式管理 线性地址到物理地址之间的转换通过分页机制完成。具体变换过程如下。 使用虚拟寻址，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址被送到内存之前首先转换为适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。就像异常处理一样，地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做内存管理单元(MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该标的内容由操作系统管理。 虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上的数组的内容被缓存在主存中。磁盘上的数据被分割成块，这些块作为磁盘和主存之间的传输单元。虚拟内存系统通过将虚拟内存分割为被称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P=2^p字节。类似地，物理内存被分割为物理页，大小也为P字节。物理页也被称为页帧。 任意时刻虚拟页都被分为三个不相交的子集： 未分配的：VM系统还未分配的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。 缓存的：当前已经缓存在物理内存的已分配页。 未缓存的：未缓存在物理内存的已分配页。 每次地址翻译硬件将虚拟地址转换为物理地址时，都会读取页表来判断一个虚拟页是否缓存在DRAM的某个地方。如果是，系统即可确定这个虚拟页存放在哪个物理页中。如果不命中，系统判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。页表就是一个页表条目的数组，每一个页表条目是由一个有效位和一个n位地址字段组成的。有效位表明虚拟页是否缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟内存页在磁盘上的起始位置。 图7.3页表 形式上来说，地址翻译是一个N元素的虚拟地址空间中的元素和一个M元素的物理地址空间中元素之间的映射。如图所示。CPU中的一个控制寄存器，页表基址寄存器指向当前页表。n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移(VPO),一个n-p位的虚拟页号(VPN)，MMU利用VPN选择适当的PTE，例如VPN0选择PTE0，VPN1选择PTE1，以此类推。根据PTE，我们知道虚拟页的信息，如果虚拟页是已缓存的，那直接将页表条目的物理页号和虚拟地址的VPO串联起来就得到一个相应的物理地址。这里的VPO和PPO（物理页面偏移）是相同的。如果虚拟页是未缓存的，会触发一个缺页故障。调用一个缺页处理子程序将磁盘的虚拟页加载到内存中，然后再执行这个导致缺页的指令。 图7.4地址翻译 下图为页面命中时，CPU硬件执行的步骤。 图7.5页面命中时CPU执行的步骤 下图为缺页时，CPU硬件执行的步骤。 图7.6缺页时CPU执行的步骤 7.4TLB与四级页表支持下的VA到PA的变换 这里以一个运行Linux的IntelCorei7为例。Corei7支持实现48位的虚拟地址空间和52位的物理地址空间。页大小为4KB，支持4级页表，页表大小为4KB，CR3指向第一级页表的起始位置，TLB为4路16组相联。其中，第一、二、三级页表中条目的格式如图所示。当P=1时，地址字段包含一个40位物理页号（PPN），它指向适当的页表的开始处。这强加了一个要求，要求物理页表4KB对齐。 图7.7第一、二、三级页表条目格式 下图为第四级页表中条目的格式。当P=1，地址字段包括一个40位PPN，它指向物理内存中某一页的基地址。这又强加了一个要求，要求物理页面4KB对齐。 图7.8第四级页表条目格式 下面再简单介绍一下利用TLB加速地址翻译的过程。 TLB（翻译后备缓冲器）是一个在MMU中的关于PTE的小的缓存，是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相连度。如图所示。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有T=2^t个组，那么TLB索引（TLBI）是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。 图7.9虚拟地址中用以访问TLB的组成部分 下图展示了TLB命中时（通常情况）所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。 第1步：CPU产生一个虚拟地址。 第2步和第3步：MMU从TLB中取出相应的PTE。 第4步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。 第5步：高速缓存/主存将所请求的数据字返回给CPU。 当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，如图所示，新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。 图7.10TLB命中与不命中的操作 有了以上关于TLB和多级页表的介绍，下面就可以分析他们相结合时从虚拟地址到物理地址的翻译过程。 由于一个页表大小为4KB，一个PTE条目大小为8B，故一个页表中共有512个PTE条目，故使用9位二进制索引，4个页表共使用36位二进制索引。由于页的大小为4KB，故VPO应为12位。由于整个的虚拟地址为48位，故前36位正好为VPN，即四级页表的索引，后12位为虚拟页面偏移量。由于TLB共16组，故TLBI为4位，TLBT为32位。 当CPU产生一个虚拟地址时，将虚拟地址传送给MMU，MMU根据4位TLBI找到相应的组索引，再根据TLBT进行标记匹配，如果TLB命中，则将得到的物理页号与VPO连接起来得到一个52位的物理地址。如果TLB未命中，则MMU向页表中进行查询，CR3确定第一级页表的起始地址，然后根据4个9位的二进制索引，将36位的VPN从高位到低位分为4个9位的VPN1、VPN2、VPN3、VPN4.VPN1提供一个在第一级页表中的偏移量，根据这个偏移量得到的PTE包含第二级页表的基地址，然后VPN2提供一个在第二级页表中的偏移量，根据这个偏移量得到的PTE包含第三级页表的基地址，以此类推。最终在第四级页表中查询到PPN，与VPO组合成PA，并且向TLB中添加条目，至此，便完成了将虚拟地址翻译成物理地址的过程。如图所示。 图7.11VA到PA地址翻译过程 7.5三级Cache支持下的物理内存访问 首先对通用的高速缓存存储器组织结构进行介绍。每个存储器地址有m位，形成M=2^m个不同的地址。这样一个机器的高速缓存被组织为一个有S=2^s个高速缓存组的数组。每个组包含E个高速缓存行，每个行是由一个B=2^b字节的数据块组成的，一个有效位指明这个行是否包含有意义的信息，还有t=m-(b+s)个标记位，他们唯一地标识存储在这个高速缓存行中的块。高速缓存的大小C是指所有块的大小的和，C=S×E×B。具体结构如图所示。 图7.12高速缓存的结构 参数S和B将m个地址位分为了三个字段，如图所示。s个组索引位是一个到S个组的数组的索引，第一个组是组0，第二个组是组1，以此类推。组索引位被解释为一个无符号整数，它告诉我们这个字必须存储在哪个组中。一旦我们知道了这个字必须存储在哪个组中，t个标记位就告诉我们这个组中的哪一行包含这个字（如果有的话）。当且仅设置了有效位并且该行的标记位与地址中的标记位相匹配时，最终的这一行才包含这个字。一旦我们在组索引标识的组中定位了由标号所标识的行，那么b个块偏移位给出了在B个字节的数据块中的字偏移。 图7.13物理地址被划分的字段 一条加载指令指示CPU从主存地址A中读一个字时，它将地址A发送到高速缓存。如果高速缓存正保存着地址A出的那个字的副本，它就立即将那个字发回给CPU。如果缓存不命中，则从下一层高速缓存或主存中取出包含那个字的块，如果缓存已满，则可能会覆盖现存的一个块。 下面对L1cache的物理内存访问过程进行分析。由于L1cache共64组，每组8行，故每个块的大小为64字节。由此可知块偏移位b为6，组索引位s为6，标记位共40位。 CPU将地址A发送到L1cache。组选择取出地址中的组索引位，将二进制组索引转化为一个无符号整数，并找到相应的组。行匹配将地址A中的标记位与组中的每一行的标记位进行匹配。当某一行的标记位匹配，且有效位为1时，高速缓存L1命中。高速缓存命中后，根据地址A中的块偏移找到要获取的字的位置，将这个字取出并返回给CPU。若高速缓存L1不命中，则需要从L2中取出这个字，从L2中取出这个字的过程与L1相同，这里不再展开。取出后将新的块存储在组索引位指示的组中的某个高速缓存行中。一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，则产生冲突，采用最近最少使用策略LFU算法进行替换。 整个过程如下图所示。 图7.14物理内存访问过程 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建当前进程的mm_struct、区域结构和页表的原样副本。将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1.删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2.映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆区域也是请求二进制零的，初始长度为零。 3.映射共享区域。hello程序与共享对象或目标链接，比如libc.so。这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC）。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障：当指令引用一个相应的虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，会触发缺页故障。通过查询页表PTE可以知道虚拟页在磁盘的位置。缺页处理程序从磁盘加载适当的页面到物理内存中，并更新PTE。然后将控制返回给引起缺页故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，指令就可以没有故障的运行完成。具体的过程如图所示，唯一的不同在于缺页故障处理程序在运行结束后会重新执行当前指令，而不是终止。 图7.15缺页故障处理过程 缺页处理程序的具体处理过程如下图所示。 第1步:CPU生成一个虚拟地址,并把它传送给MMU。 第2步:地址管理单元生成PTE地址,并从高速缓存/主存请求得到它。 第3步:高速缓存/主存向MMU返回PTE。 第4步:PTE中的有效位是零,所以MMU触发了一次异常,传递CPU中的控制到操作系统内核中的缺页异常处理程序。 第5步:缺页处理程序确定出物理内存中的牺牲页,如果这个页面已经被修改了,则把它换出到磁盘。 第6步:缺页处理程序页面调入新的页面,并更新内存中的PTE。 第7步:缺页处理程序返回到原来的进程,再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中,所以就会命中,主存将所请求的字返回给处理器。 图7.16缺页处理程序的处理过程 7.9动态存储分配管理 1.动态内存分配器的基本原理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 图7.17堆 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格，两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器：要求应用显式地释放任何已分配的块。例如，c标准库提供一种叫做malloc程序包的显式分配器。c程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。c++中的new和delete操作符与c中的malloc和free相当。 隐式分配器：另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集，例如Lisp,ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 2.带边界标签的隐式空闲链表分配器原理 任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。大多数分配器将这些信息嵌入块本身。一个简单的方法如图所示。 图7.18一个简单的堆块格式 在这种情况中，一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是零。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。 头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。 假设块的格式如上图所示，我们可以将堆组织为一个连续的已分配块和空闲块的序列。如下图所示。 图7.19隐式空闲链表 我们称这种结构称为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。注意，我们需要某种特殊标记的结束块，在这个示例中，就是一个设置了已分配位而大小为零的终止头部。 (1)放置已分配的块 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略确定的。一些常见的策略是首次适配、下一次适配和最佳适配。 (2)分割空闲块 一旦分配器找到一个匹配的空闲块，它就必须做另一个策略决定，那就是分配这个空闲块多少空间。一个选择是用整个空闲块。虽然这种方式简单而快捷，但是主要的缺点就是它会造成内部碎片。如果放置策略趋向于产生好的匹配，那么额外的内部碎片也是可以接受的。 然而，如果匹配不太好，那么分配器通常会选择将这个空闲块分割为两部分。第一部分变为分配块，而剩下的变成一个新的空闲块。下图展示了分配器如何分割8个字的空闲块，来满足一个应用的对堆内存3个字的请求。 图7.20分割空闲块 (3)获取额外堆内存 如果分配器不能为请求块找到合适的空闲块，一个选择是合并那些在内存中物理上相邻的空闲块来创建一些更大的空闲块。然而，如果这样还不能生成一个足够大的块，或者如果空闲块已经最大程度地合并了，那么分配器会调用sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化为一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。 (4)合并空闲块 当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些相邻的空闲块可能引起一种现象叫做假碎片，就是有许多可用的空闲块被切割成为小的、无法使用的空闲块。为了解决假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为合并。 带边界标记的合并 Knuth提出了一种聪明而通用的技术，叫做边界标记，允许在常数时间内进行对前面块的合并。这种思想如图所示，是在每个块的结尾处添加一个脚部（边界标记），其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。 图7.21边界标记的堆块格式 3.显式空间链表的基本原理 因为根据定义，程序不需要一个空闲块的主体，所以实现空闲链表数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。如图所示。 图7.22使用双向空闲链表的堆块格式 使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于空闲链表中块的排序策略。 一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 7.10本章小结 本章主要介绍了hello的存储管理，详细地讲述了hello的存储器地址空间、Intel逻辑地址到线性地址的变换过程、hello的线性地址到物理地址的变换过程以及三级Cache支持下的物理内存访问过程，分析了hello进程fork时与execve时的内存映射，说明了缺页故障与缺页中断处理过程，并在最后介绍了动态存储分配管理的方法与原理。 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m个字节的序列：B0,B1,B2……Bm。 所有的I/O设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O,这使得所有的输入和输出都能以一种统一且一致的方式来执行。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixI/O接口： 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 2.Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0），标准输出（描述符为1）和标准错误（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值。 3.改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 4.读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。 类似地，写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 5.关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： 1.intopen(char*filename,intflags,mode_tmode)：进程通过调用open函数来打开一个已存在的文件或是创建一个新文件。open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。 2.intclose(fd)：fd是需要关闭的文件的描述符，close返回操作结果。关闭一个已关闭的描述符会出错。 3.ssize_tread(intfd,void*buf,size_tn)：read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 4.ssize_twirte(intfd,constvoid*buf,size_tn)：write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 首先查看Windows系统下printf的函数体： intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 其中，va_list的定义： typedefchar*va_list 这说明它是一个字符指针。 其中的：(char*)(&fmt)+4)表示的是 中的第一个参数。 再看vsprintf，其函数体如下： intvsprintf(char*buf,constchar*fmt,va_listargs) { char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!='%'){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); } 其作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。返回的是要打印出来的字符串的长度。 然后追踪write： write: moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL write(buf,i)的作用为写操作，把buf中的i个元素的值写到终端。在write函数中，将栈中参数放入寄存器，ecx是字符个数，ebx存放第一个字符地址。其中，intINT_VECTOR_SYS_CALL表示要通过系统来调用sys_call这个函数。下面再看sys_call的实现： sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret sys_call将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。 字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。 显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 于是我们的打印字符串就显示在了屏幕上。 同理，printf函数在Linux系统下的实现也是上述这种思路，这里不再进行详细的讨论。 8.4getchar的实现分析 异步异常-键盘中断的处理：当用户按键时，键盘接口会得到一个代表该按键的键盘扫描码，同时产生一个中断请求，中断请求抢占当前进程运行键盘中断子程序，键盘中断子程序先从键盘接口取得该按键的扫描码，然后将该按键扫描码转换成ASCII码，保存到系统的键盘缓冲区之中。 getchar的源码如下： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } getchar函数落实到底层调用了系统函数read，通过系统调用read读取存储在键盘缓冲区中的ASCII码直到读到回车符然后返回整个字串，getchar进行封装，大体逻辑是读取字符串的第一个字符然后返回。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法以及UnixIO接口及其函数，并对printf函数和getchar函数的实现进行了简要的分析。 结论 hello所经历的历程如下： 程序员通过键盘输入编写出hello.c文件。hello.c经过预处理，将所有调用的外部库插入合并，生成hello.i文件。hello.i经过编译生成汇编文件hello.s。hello.s经过汇编生成可重定位目标文件hello.o。hello.o与可重定位目标文件和动态链接库链接生成可执行目标文件hello。在shell中输入./hello1190200109刘文卓shell调用fork函数创建一个子进程。新运行的子进程调用execve函数在当前子进程的上下文中加载并运行hello程序。execve函数调用启动加载器，映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数。CPU为其分配时间片，在一个时间片中，hello享有CPU资源，顺序执行自己的控制逻辑流。MMU将程序中使用的虚拟内存地址翻译成物理地址。当hello执行printf函数时会调用malloc向动态内存分配器申请堆中的内存。当hello调用sleep函数时，会陷入内核模式，处理休眠请求主动释放当前进程，内核进行上下文切换将当前进程的控制权交给其他进程。当sleep函数调用完成时，内核执行上下文切换将控制传递给当前进程。程序运行过程中，按下Ctrl+c会终止当前进程，按下Ctrl+z会停止并挂起当前进程。子进程执行完成后，内核安排父进程回收子进程，将子进程的退出状态传递给父进程。内核删除为这个进程创建的所有数据结构。 至此，hello的一生结束了。 在学习过计算机系统后，我对计算机系统的设计与实现的精妙感到十分震撼。其所有的设计思想都是建立在抽象层面上的，且计算机系统的整体设计十分完备、功能全面。即便如此，计算机系统依然会不断向前发展，期待能够在将来见识到更精细、更完美的设计与实现。 附件 文件名称文件作用hello.ihello.c经过预处理后生成的修改了的源程序hello.shello.i经过编译后生成的汇编程序hello.ohello.s经过汇编后生成的可重定位目标程序hellooelf.txt保存hello.o的elf格式的文件信息的文本文件hellooobjdump.txt保存hello.o经过反汇编后生成的内容的文本文件hellohello.o经过链接后生成的可执行目标程序helloelf.txt保存hello的elf格式的文件信息的文本文件helloobjdump.txt保存hello经过反汇编后生成的内容的文本文件 参考文献 [1] https://www.cnblogs.com/pianist/p/3315801.html [2] https://blog.csdn.net/icandoit_2014/article/details/87897495 [3] http://blog.chinaunix.net/uid-1835494-id-2831799.html [4] 深入理解计算机系统（原书第3版） 

博客开通开坑软件构造 开始学习软件构造！不定期更新代码心得。 

计算机系统大作业 程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P 摘要本文梳理探讨了简单的C语言程序hello，在x86/Linux系统环境下，从源代码文件开始到最终完成执行完成的简单一生。其一生高度概括了程序在计算机系统体系结构中运行的各个重要阶段，包括编译处理、进程管理、内存管理、异常控制流、硬件存储结构层次、系统IO管理等。从一个简单程序作为切入点，深入探讨hello程序的完整执行过程，可以抽丝剥茧以小知大，更好的帮助我们深入理解计算机系统的结构，抽象出软硬件体系的运行管理机制。 关键词：计算机系统；软件；硬件；Linux；x86； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介P2P：FromProgramtoProcess意即从程序到进程。Hello程序从编写阶段开始，是以C语言源代码文件Hello.c的形式存在于硬盘上的。经过预编译阶段将头部include调用文件包含到源代码中，并将源代码中的宏定义替换，形成hello.i文件。再将完整的代码交给编译器进行编译，得到hello.s的汇编文件。汇编器将汇编文件处理为二进制可重定位文件，之后再交给链接器进行链接，最终形成可执行文件hello.o。在Linux系统终端中运行可执行文件，内核使用系统调用fork为其创建一个新的进程，在该进程的上下文中使用系统调用execve执行hello.o文件，至此，hello程序以进程的形式运行在计算机中，完成了从程序到进程的转变。O2O：FromZero-0toZero-0意即在内存中从0化为0。在运行hello.o文件前，hello程序在内存中是没有任何痕迹的。当内核为运行hello程序fork出一个进程后，调用execve执行hello文件，此时内核为hello分配虚拟内存空间，删除当前虚拟内存空间中用户部分已存在的数据结构，为hello的代码段、数据、bss以及栈区域创建新的区域结构，并将hello的源代码、数据等信息复制到内存中。然后虚拟内存与磁盘对象建立映射，设置程序计数器，使之指向代码区域的入口点，程序入口后虚拟内存映射的内容开始载入物理内存。做好执行程序的准备后进入main函数，CPU为hello分配时间片，将控制交给hello进程，执行hello的程序内容。待执行完毕后，hello成为僵死进程，等待父进程的回收，回收后内核会从内存中删除hello的所有痕迹，hello在内存中重新化为0。至此hello完成了在内存中从无到有再到无的过程，即从0到0。1.2环境与工具硬件环境：X64CPU;1.8GHz;8GRAM;512GSSD软件环境：VMware15;Ubuntu20.04LTS64位开发工具：GDB;EDB;GCC;Linux内置指令 1.3中间结果 图1.3.1中间生成文件一览hello.cC语言源代码文件hello.i预处理阶段生成文件hello.s编译阶段生成文件，内容为汇编代码hello.o汇编阶段生成文件，二进制可重定位目标文件hello可执行目标文件hello.elf可重定位目标文件的ELF格式hello2.elf可执行目标文件的ELF格式hello_o_asm.txt可重定位目标文件的反汇编代码hello_asm.txt可执行目标文件的返汇编代码1.4本章小结对P2P和O2O在本文中的特殊含义进行了阐述，简要概括了hello程序的一生。本章还列出了下文中使用到的工具以及生成的文件，对下文起说明性作用。（第1章0.5分） 第2章预处理2.1预处理的概念与作用概念：在C文件编译前对源代码进行的处理，主要包括文件包含、宏定义替换、条件编译等。C文件预处理后得到后缀为.i的预处理文件。作用：在hello程序中，预处理主要体现为头文件的包含，即将程序头部使用#include指令包含的文件复制整合到源代码中，生成hello.i文件方便后续编译。但在其他C文件中预处理常常还包括宏定义替换和条件编译。宏定义替换的作用是将程序中使用#define定义的部分在源代码中进行替换。条件编译的作用是根据源代码中的条件编译命令（如#if、#ifdef）选择性的编译部分源代码，方便程序的多样性实现。2.2在Ubuntu下预处理的命令gcc-Ehello.c-ohello.i 图2.2.1预处理命令生成的预处理文件部分内容如下所示： 图2.2.2预处理文件部分内容 2.3Hello的预处理结果解析 图2.3.1预处理文件部分内容生成的预处理文件名为hello.i，该文件共3065行，与hello.c源代码相比文件内容大大增加。其文件底部为hello.c的main函数代码。上面3000余行可以看到stdio.h等标注，均为复制整合的包含的头文件，即<stdio.h><unistd.h><stdlib.h>的内容。这体现出预处理包含头文件的功能。另外注意到预处理文件不含有任何宏定义，虽然hello源代码中并无宏定义，但包含的头文件源代码中普遍存在宏定义，在预处理文件中全部得以替换，也体现出预处理的宏定义替换功能。2.4本章小结本章关注C程序的预处理阶段。阐述了预处理操作的概念和作用后，实际操作生成并查看了预处理文件，通过对比预处理文件和源代码文件，对于预处理操作的实际功能有了更为具体的认识。（第2章0.5分） 第3章编译3.1编译的概念与作用概念：编译指C语言代码转化为汇编指令的过程，具体体现为编译器将预处理文件转化为以.s为后缀的汇编文件。作用：编译器将源代码翻译为汇编指令的过程分为五个阶段：词法分析，语法分析，代码优化（中间代码生成），目标代码生成。语法语义分析阶段的主要作用是检查语法错误，并给出错误提示信息。若代码无语法错误，则进入下一阶段代码优化阶段，此阶段的主要作用是根据程序功能对代码进行等价变换，使得程序的算法实现更加高效合理，此阶段产生的优化代码称为中间代码。最后进入目标代码生成阶段，编译器将优化后的中间代码转化为目标代码，即汇编指令代码。3.2在Ubuntu下编译的命令gcc-Shello.c-ohello.s 图3.2.1编译命令生成的汇编文件部分内容如下图所示： 图3.2.2汇编文件部分内容 3.3Hello的编译结果解析3.3.1数据类型Hello中涉及到的变量有全局整型变量sleepsecs、整型变量argc、字符串数组argv、局部整型变量i。 图3.3.1汇编代码内容sleepsecs作为已初始化的只读全局变量被存放在rodata段。 图3.3.2汇编代码内容参数argc和argv分别被存放在寄存器%edi和%rsi中被传入，随后被压入栈。对argc的赋值操作使用的后缀是l，对应4字节的int类型，对argv的赋值操作后缀为q，对应8字节的字符指针类型。 图3.3.3汇编代码内容局部变量i作为循环控制变量，在汇编代码中被存放在栈中。操作后缀为l，对应4字节的int类型。 图3.3.4汇编代码内容源代码中printf函数打印的内容被当作字符串常量存储rodata段。其中第一个字符串的内容涉及到中文字符，在汇编代码中使用utf-8编码表示。其余数据以立即数的形式给出，直接编码在汇编代码中。3.3.2赋值源代码中涉及到的赋值操作为局部变量i的初始化i:=0，在汇编代码中体现为 图3.3.5汇编代码内容MovS，D操作表示将S的值传送给D。在实际应用中，mov指令跟随后缀，上述代码的后缀为l，表示执行的是4字节操作，对应i变量所属的int类型。0以立即数的形式给出，i变量存放在栈中%rbp-4所指的位置，故通过movl直接赋值即可。汇编代码中其余的赋值操作均为代码翻译时产生的操作，mov后跟随的后缀有l、q，分别代表4字节、8字节操作。操作数有立即数、寄存器、寻址形式等。3.3.3SizeofSizeof是C语言中的一个一元操作符，返回对象或类型在内存中所占的字节数。Hello程序中涉及到的变量类型有int、char*，执行sizeof操作返回值分别为4和8。3.3.4算术和逻辑操作Hello程序中涉及到的算术逻辑操作主要是加法操作，即add。汇编代码中还出现了leaq加载有效地址指令。除此之外，常用的算数逻辑操作还包括减sub、乘imul、异或xor、或or、与|、取负neg、取补not、左移sal、算术右移sar、逻辑右移shr等。操作数个数视具体操作而定。操作后同样可以添加后缀以指明数据格式。3.3.5关系操作关系操作主要包含在比较测试指令cmp、test和跳转指令中。 图3.3.6汇编代码内容源代码中涉及到的argc!=3判断和循环判断i<10均通过比较指令来设置条件码，而后使用条件跳转指令根据条件码来改变程序控制。 图3.3.7汇编代码内容CmpS1，S2基于S2-S1的值设置条件码。例如S2-S1=0时je会读取到条件码设置为相等，此时执行跳转操作，否则不执行跳转。对于jle指令，如果读取到当前条件码为小于等于那么执行跳转，否则不执行。同样对于比较测试指令可以设定后缀来指明操作的数据格式。3.3.6数组/指针操作C语言中数组往往占据一片连续的内存区域，故使用数组开头的指针即可指代整个数组。Hello程序中argv即为字符指针，它存储一个字符数组的开头地址，即可指代一个字符数组。 图3.3.8汇编代码内容汇编代码中仅将数组头指针压入栈，若想对数组执行索引取值操作，只需以头指针为基准，根据数据格式和索引设置偏移量，即可寻址取得所需的数值。 图3.3.9汇编代码内容如对argv[1]和argv[2]的寻址。栈中%rbp-32处存放数组头指针，字符指针类型占据8字节，故一位索引偏移为8，两位索引偏移为16。汇编代码中根据索引和数据格式设置偏移量后，直接使用mov操作寻址赋值即可获取所需的数值。3.3.7控制转移控制转移基于跳转指令。Hello程序中涉及的控制转移为if(argc!=3)和for循环引起的跳转，汇编代码中对应的跳转指令如下。 图3.3.10汇编代码内容上述为条件跳转指令，即指令根据条件码的设置情况有选择的进行跳转。Je表示条件码为相等时跳转，jle表示条件码为小于等于时跳转。除此之外jmp指令不依据条件码执行直接跳转操作。3.3.8函数操作函数是一种过程，假设过程P调用过程Q吗Q执行后返回到P，这些动作包含限免一个或多个机制：1.传递控制：进行过程Q的时候，程序计数器必须设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。2.传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P中返回一个值。3.分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。过程调用使用call指令。过程调用与栈结构的使用关系密切，在执行call指令前需要先传递参数，将调用返回地址压入栈中，而后设置PC将控制交给调用过程。每一层调用都有属于自己的栈帧，维护栈帧是保证调用顺利运行的关键，若栈帧遭到破坏则会导致严重的恶性错误。Hello程序中使用的调用有main函数、printf函数、exit函数、sleep函数、getchar函数。其中main函数由系统启动函数调用。每一次函数调用前都会执行传递参数，返回地址压栈，PC设置等步骤，每一层函数调用都由属于自己的栈帧。3.4本章小结本章详细分析了hello程序的汇编代码。通过分析比较汇编代码与对应源代码之间的关系和区别，了解编译的基本机制和原理，对编译过程有了深层次的理解，对程序的机器级表示有了更好的领悟。（第3章2分） 第4章汇编4.1汇编的概念与作用概念：汇编程序被翻译为机器语言指令的过程。具体表现为汇编器（as）将后缀为.s的汇编文件打包翻译成可重定位目标程序的格式，并将结果保存在.o目标文件中。.o文件是一个二进制文件，它包含程序的机器指令编码。作用：生成可重定位的目标文件。4.2在Ubuntu下汇编的命令gcc-chello.c-ohello.o 图4.2.1汇编命令生成的可重定位目标文件如下： 图4.2.2生成文件4.3可重定位目标elf格式获取ELF格式指令：readelf-ahello.o>hello.elf 图4.3.1ELF头ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小与字节顺序。ELF头剩下的部分包括ELF头的大小、目标文件的类型、机器类型（如x86-64）、节头部表的文件偏移，以及节头部表条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。 图4.3.2ELF节头部表节头部表概述了文件中出现的各个节的基本信息，包括节的名称、大小、类型、地址、偏移量等。 图4.3.4ELF重定位节Hello的重定位节包括rela.text节、rela.eh_frame节、symtab节。重定位节中各信息的表示含义如下。偏移量：需要被修改的引用的节的偏移。信息：包括symbol和type两部分，其中symbol占前4个字节，type占后4个字节，symbol代表重定位到的目标在.symtab中的偏移量，type代表重定位的类型。类型：告知链接器如何修改新的引用。两种最基本的重定位类型：R_X86_64_PC32：重定位一个使用32位PC相对地址的引用。R_X86_64_32：重定位一个使用32位PC绝对地址的引用。符号名称：重定位目标的名称。加数：一个有符号常数，一些类型的重定位要使用它对被修改引用的值做调整。rela.text节是一个text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。例如hello程序中的puts函数、exit函数、printf函数、sleep函数。这些函数均为外部调用函数。而sleepsecs为全局变量引用，其被存放在.data段，引用时的位置需要修改。Symtab节是一个符号表，它存放在程序中定义和引用的函数和全局变量信息。每个可重定位目标文件在symtab中都有一张符号表，但symtab符号表中不含局部变量的条目。Hello的symtab节中包含了程序中引用的函数如printf、exit、sleep、getchar，以及引用的全局变量sleepsecs。4.4Hello.o的结果解析在Linux终端执行objdump-d-rhello.o指令，在终端中获取hello.o的反汇编代码如下图所示。 图4.4.1反汇编代码将反汇编代码与hello.s中的汇编代码进行比较，可以得到如下差别：反汇编代码指明了每一条指令的16进制机器码以及所处的地址。反汇编代码中操作数均为16进制，而汇编代码中为10进制。反汇编代码中部分指令省略了后缀的数据格式表示，汇编代码中均带有后缀。反汇编代码中涉及到的控制转移，如跳转操作和函数调用，其操作数均为目标指令的地址，而汇编代码中操作数是段名称或函数名称。最重要的是，反汇编代码中函数调用callq后的操作数地址指向下一条指令的地址，而不是特定函数的地址。这是因为hello中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0（目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。反汇编代码中对于全局变量的引用为%rip+0。这是因为rodata中数据地址也是在运行时确定，故访问需要重定位。所以在汇编成为机器语言时，将操作数设置为全0并添加重定位条目。综上来看，反汇编代码除在格式上与汇编文件不同外，其指令着重体现出文件的可重定位特征。4.5本章小结本章通过分析可重定位文件的ELF文件和反汇编代码内容，得到了二进制的可重定位目标文件的特征，进而理解了汇编器在程序编译处理过程中扮演的角色。可重定位文件表现的重定位特征也为接下来的链接阶段做了铺垫。（第4章1分） 第5章链接5.1链接的概念与作用概念：链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。作用：链接器使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把他分解为更小、更好管理的模块，可以独自修改和编译这些模块。当我们改变其中的一个块时，只需要简单的重新编译它，并重新链接应用，而不必重新编译其它文件。5.2在Ubuntu下链接的命令ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.2.1链接指令生成的文件如图所示： 图5.2.2链接生成文件5.3可执行目标文件hello的格式生成ELF格式指令为readelf-ahello>hello2.elf 图5.3.1ELF格式指令 图5.3.2ELF文件头可执行目标文件的ELF文件头内容如上图所示，其与可重定位目标文件的ELF头相似，除ELF文件节条目改变外，最主要的区别是可执行目标文件ELF头有了程序入口点地址，即程序运行时PC需设置的第一条指令地址。 图5.3.3ELF文件节头部表部分内容可执行目标文件的ELF格式中节头部表条目增多，对hello中所有的节信息进行了声明。各个节在内存中的虚拟地址和大小有了明确标明，可以根据虚拟地址信息定位各个节所占的区间。可执行目标文件ELF格式的明显特征是拥有了程序头，且不再有rel.text节和rel.data节，这些节中的可重定位信息已被重定位到最终的虚拟内存地址。但存在一些重定位节如.rela.plt和.rela.dyn，这些节需要之后进行动态链接。 图5.3.4ELF文件中存在的重定位节5.4hello的虚拟地址空间使用edb打开hello的可执行目标文件，如下图所示。 图5.4.1edb打开hello文件Edb左上窗口展示了汇编代码对应的16进制机器码和其所处的地址信息。 图5.4.1虚拟空间范围在DataDump窗口可以看到hello文件加载的虚拟空间范围为0x401000-0x402000. 图5.4.1edb中查看各节地址使用symbol窗口可以查看文件各节在虚拟地址空间中的地址，其地址信息与ELF格式中节头部表中的信息完全一致。5.5链接的重定位过程分析执行objdump-d-rhello指令得到hello的反汇编代码如下图所示。 图5.5.1hello的部分反汇编代码 对比第四章hello.o的反汇编代码，得到以下区别：1.在hello.o反汇编中，main函数地址从0开始，即地址指代均为相对偏移地址；而在hello中main函数0x4010c1开始，故hello已将hello.o重定位为了虚拟内存地址，2.hello可执行目标文件中增加了.init节和.plt段。.init节定义了一个_init函数，程序的初始化代码会调用它，用于初始化程序执行环境；.plt段是程序执行时的动态链接。并且所有重定位条目都被修改为了确定的运行时虚拟内存地址。3.将hello.c中用到的函数，如exit、printf、sleep、getchar等，链接到了hello中，在反汇编代码中可以看到为上述函数分配的虚拟内存空间信息。链接就是链接器ld将.o文件中的分散在外部文件中的目标函数段按照一定规则抓取组合到hello文件的过程。指定动态链接器为/lib64/ld-linux-x86-64.so.2。外部目标文件crt1.o、crti.o、crtn.o中主要定义了程序入口_start、初始化函数_init等运行程序必须的函数。ibc.so是动态链接共享库，其中定义了hello.c中用到的printf、sleep、getchar、exit函数。链接指令ld即是将上述文件和函数抓取并组合到hello文件中。重定位由两步组成：重定位节与符号定义、重定位节中的符号引用。在重定位节与符号定义这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节，而后，链接器将运行时虚拟内存地址赋值给新的聚合节、输入模块定义的每个节，以及输入模块定义的每个符号。在重定位节中的符号引用中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时虚拟地址，这一步依赖hello.o中的重定位条目。除此之外重定位类型分为两种，分别为R_X86_64_PC32与R_X886_64_32，这两种分别为PC相对寻址与绝对寻址。对于hello.o中使用PC相对寻址的指令使用R_X86_64_PC32类型进行重定位，而对hello.o直接引用地址的指令，采用R_X886_64_32类型进行重定位。5.6hello的执行流程执行过程中调用的所有函数如下：ld-2.27.so!_dl_startld-2.27.so!_dl_inithello!_startlibc-2.27.so!__libc_start_main-libc-2.27.so!__cxa_atexit-libc-2.27.so!__libc_csu_inithello!_initlibc-2.27.so!_setjmp-libc-2.27.so!_sigsetjmp-libc-2.27.so!__sigjmp_savehello!mainhello!puts@plthello!exit@plthello!printf@plthello!atoi@plthello!sleep@plthello!getchar@pltld-2.27.so!_dl_runtime_resolve_xsave-ld-2.27.so!_dl_fixup-ld-2.27.so!_dl_lookup_symbol_xlibc-2.27.so!exit5.7Hello的动态链接分析 图5.7.1dl_init之前.got.plt节的内容 图5.7.2dl_init之后.got.plt节的内容使用edb调试，DataDump窗口数据的值在运行dl_init前后发生变化。如图地址0x404000处的值改变，根据ELF文件，此处为.got.plt节。动态链接库是在进程启动时加载进来的。加载后，动态链接器需要对其作一系列的初始化，如符号重定位(动态库内以及可执行文件内)，这些工作是比较费时的，特别是对函数的重定位。因此为了节约时间对函数的重定位延迟进行，这使得我们可以对一些动态库里包含的很多全局函数之中的很小一部分我们使用到的、执行到的进行重定位。具体来说，就是应该等到第一次发生对该函数的调用时才进行符号绑定，也就是延迟绑定。延迟绑定的实现步骤有： 1.建立一个.got.plt表，该表用来放全局函数的实际地址，但最开始时，里面放的不是真实的地址而是一个跳转。2.对每一个全局函数，链接器生成一个与之相对应的影子函数。而所有对函数的调用，都换成对{（函数名）@plt}的调用。而{（函数名）@plt}的第一条指令会直接从got.plt拿真实的函数地址，如果之前已经发生过调用，got.plt就已经保存了真实的地址，如果是第一次调用，则got.plt中放的是{（函数名）@plt}中的第二条指令，这就使得当执行第一次调用时，{（函数名）@plt}中的第一条指令其实什么事也没做。继续往下执行，第二条指令的作用是把当前要调用的函数在got.plt中的编号传给_init()，而_init()将被调用函数进行重定位，然后把结果写入到got.plt相应的地方。5.8本章小结本章关注可重定位目标文件到可执行目标文件的过程。这个过程包括两个重要过程：链接、重定位。通过分析ELF文件格式、借用edb查看虚拟内存与代码间的映射关系，我们深入理解了程序链接和重定位过程中的机制和发生的变化。至此，hello程序从易于人理解的C语言代码彻底转变为了易于机器读懂的二进制文件了。（第5章1分） 第6章hello进程管理6.1进程的概念与作用概念：进程的经典定义是一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容，程序计数器、环境变量以及打开文件描述符的集合。作用：它提供一个假象，好像我们的程序是系统当前运行的唯一的程序一样。我们的程序好像是独占的使用处理器和内存。处理器好像无间断的一条接一条的执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。6.2简述壳Shell-bash的作用与处理流程Shell是一个交互型应用级程序，它代表用户运行其它程序。Shell执行一系列的读/求值步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，代表用户运行程序。处理流程：1.解析以空格分割的命令行代码，并构造最终会传递给execve的argv向量。2.解析了命令行之后，检查第一个命令行参数是否是一个内置的shell命令。如果，它立即解释该指令。3.如果不是内置指令，那么shell创建一个子进程，并在子进程中执行所请求的程序。4.如果用户要求在后台运行该程序，那么shell等待下一个命令并返回步骤1。5.如果不要求在后台运行，那么shell使用waitpid等待作业终止。待终止后，shell会等待下一个命令并返回步骤1。6.3Hello的fork进程创建过程Shell检测到命令行第一个参数不是内置指令后，通过调用fork函数创建一个新的运行的子进程来运行hello。新创建的子进程几乎但不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得父进程打开任何文件描述符相同的副本，这意味着当父进程调用fork函数时，子进程可以读写父进程中任何打开的文件。父进程与子进程之间最大的区别在于它们拥有不同的PID。 图6.3.1fork进程过程6.4Hello的execve过程 图6.4.1新程序开始时用户栈典型的组织结构Execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp。当加载器运行时，它将创建内存映像（在Linuxx86-64系统中，代码段总是从地址0x40000处开始）。而在程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据段。接下来，加载器跳转到程序的入口点，即_start函数的地址，_start函数调用系统启动函数_libc_start_main来初始化执行环境，并调用用户层的main函数，此时构造的argv向量被传递给主函数。在execve加载了hello之后，它调用启动代码设置栈，并将控制传递给新程序的主函数。主函数有以下原型：Intmain(intargc,char*argv[],char*envp[]);6.5Hello的进程执行为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常使用某个控制寄存器的一个模式位提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。内核会为每一个进程维持一个上下文，而在进程执行的某些时刻，内核可以进行调度、抢占当前进程，并重新开始一个先前被抢占了的进程。上下文切换的流程是1.保存当前进程上下文。2.恢复某个先前被抢占的进程被保存的上下文。3.将控制传递给这个新恢复的进程。 图6.5.1进程上下文切换控制传递到hello的入口处后，运行时内核为其保存一个上下文，进程在用户模式运行。如果没有异常或中断信号的产生，hello将继续正常地执行。如果遇到了异常或者中断信号，那么进程陷入内核模式，内核执行上下文切换，将控制转换到其它进程。当执行sleep函数时，hello进程将挂起指定时间，此时发生上下文切换，进程陷入内核模式，控制转移至另一个进程；当达到指定挂起时长后，再次发生上下文切换，进程陷入内核模式，将控制转移到原先挂起的hello进程。当hello循环结束后，调用getchar函数，需要键盘缓冲区DMA传输，发生异常，进程进入陷阱陷入内核，执行上下文切换，将控制转移给其他进程完成键盘输入。DMA传输完成后，内核切换回hello进程，然后hello执行return，进程终止。6.6hello的异常与信号处理 图6.6.1正常运行结果程序正常运行的结果如上。 图6.6.2任意输入运行结果程序运行过程中任意输入不会影响程序的运行，仅会在终端中显示输入的字符。程序最终的getchar函数会读取键盘输入的第一个值。 图6.6.3输入Ctrl-Z运行结果在程序运行过程中输入ctrl-z之后，shell父进程接收到SIGSTP信号，将hello进程暂时挂起。通过ps命令观察，可以hello进程并未被回收。 图6.6.4使用ps指令观察当前进程再运行一个新的hello进程，并使用ctrl+Z挂起，在此之后输入fg指令，将hello进程调回前台执行，可以看到第二个hello进程又在之前的挂起处继续执行。 图6.6.5使用fg指恢复前台进程再次使用Ctrl-Z将进程挂起，使用jobs查看当前作业，可以看到先前运行的两个hello进程。 图6.6.6当前作业再次恢复第二个hello进程，输入Ctrl-C，此时第二个进程接收到SIGINT信号，接到来自键盘的终止，故转到信号处理程序，终止该进程。再次使用jobs查看当前作业，可以看到仅剩第一个hello进程。 图6.6.7使用Ctrl-C指令再使用kill命令根据第一个进程的PID杀死进程。进程接收到SIGKILL信号，进程被杀死。再次使用ps查看当前进程，已没有hello进程在执行。 图6.6.8使用kill指令后的进程表综上，经过上述各种指令操作，进程收到了三种信号：SIGINT来自键盘的终止、SIGSTP挂起进程、SIGKILL杀死进程。6.7本章小结本章详细分析hello进程在系统上运行的过程。通过在hello实例进程运行过程中施加各种操作来体现进程运行中的异常控制流、信号处理。同时还探讨了有关进程管理、上下文切换的机制和原理。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：逻辑地址即为程序产生的与段相关的偏移地址，也叫相对地址。逻辑地址由段基值和偏移量组成，要经过寻址方式的计算或变换才得到内存储器中的实际有效物理地址。Hello.o文件中的地址即为逻辑地址。线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。即为hello中的虚拟地址。虚拟地址：程序使用的地址，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址被送到内存之前通过硬件与操作系统被转换成物理地址。Hello可执行文件反汇编代码中的地址即为虚拟地址。物理地址：在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址，又叫实际地址或绝对地址。Hello在运行过程中虚拟地址通过MMU映射得到物理地址。7.2Intel逻辑地址到线性地址的变换-段式管理在实地址模式下，处理器使用20位的地址总线，可以访问1MB(0~FFFFF)内存。而8086的模式，只有16位的地址线，不能直接表示20位的地址，采用内存分段的解决方法。段地址存放于16位的段寄存器中（CS、DS、ES或SS）7.3Hello的线性地址到物理地址的变换-页式管理。在保护模式下，段寄存器存放段描述符在段描述符表中的索引值，称为段选择器，此时CS存放代码段描述符的索引值，DS存放数据段描述符的索引值，SS存放堆栈段描述符的索引值。48位的全局描述符表寄存器GDTR指向GDT，即GDT在内存中的具体位置，16位局部描述符表寄存器LDTR指向LDT段在GDT中的位置。唯一的全局描述符表GDT包含操作系统使用的代码段、数据段、堆栈段的描述符，各程序的LDT段，每个程序有一个独立的局部描述符表LDT，包含对应程序私有的代码段、数据段、堆栈段的描述符、对应程序使用的门描述符：任务门、调用门等。7.3Hello的线性地址到物理地址的变换-页式管理概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址，作为数组的索引。磁盘上数组的内容被缓存在主存中。而VM系统将虚拟内存分割为称为虚拟页的固定大小的块，物理内存也同样被分割成物理页，物理页也被成为页帧。在任意时刻，虚拟页面的集合都分为三个不相交的子集：未分配的、缓存的、为缓存的。 图7.3.1物理页和虚拟页物理内存中存放着一个叫页表的数据结构，页表是一个页条目表，将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。 图7.3.2页表DRAM缓存不命中成为缺页。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页。在磁盘和内存之间传送页的活动叫做交换或者页面调度。页从磁盘换入DRAM和DRAM换出磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度。7.4TLB与四级页表支持下的VA到PA的变换下图展示了MMU如何利用页表来实现虚拟地址空间和物理地址空间的映射。 图7.4.1使用页表的地址翻译每次CPU产生一个虚拟地址，MMU就必须查阅一个PTE，以便将虚拟地址翻译为物理地址。然而硬件系统中往往在MMU中包含了一个关于PTE的小的缓存，称为翻译后备缓冲器（TLB）。 图7.4.2虚拟地址中用于访问TLB的组成部分TLB是一个小的、虚拟地址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常由高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。页表驻留在内存中的体积过大会使问题变得复杂，用来压缩页表的常用方法是使用层次结构的页表。例如，一级页表中的每个PTE负责映射虚拟地址空间中一个4MB的片，这里每一个片都是由1024个连续的页面组成的。二级页表中的每个PTE都负责映射一个4KB的虚拟内存页面，就像我们查看只有一级的页表一样。 图7.4.3一个两级页表层次结构这种方法从两个方面减少了内存要求。第一，如果一级页表中的一个PTE是空的，那么相应的二级页表就根本不会存在。这代表着一种巨大的潜在节约。第二，只有一级页表才需要总是在主存中的；虚拟内存系统可以在需要时创建、页面调入或调出二级页表，这样就减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中。7.5三级Cache支持下的物理内存访问以Corei7内存系统为例，处理器封装包括四个核、一个大的所有核共享的L3高速缓存，以及一个DDR3内存控制器。每个核包含一个层次结构的TLB、一个层次结构的数据和指令高速缓存，以及一组快速的点到点链路。TLB是虚拟寻址的，是4路组相联的。L1、L2、L3高速缓存是物理寻址的，块大小为64字节。L1和L2是8路组相联的，而L3是16路组相联的。当CPU请求访问的虚拟地址VA被翻译为物理地址PA后，高速缓存根据组索引CI找到缓存组，在缓存组中根据标记CT与缓存行中的标记位匹配。如果匹配成功且有效位为1，则命中，按照块偏移CO访问指定数据。否则不命中，向下一级缓存中请求数据。如果下一级缓存中已缓存所需数据，那么按替换策略决定本级缓存的牺牲快进行替换，否则继续向下一级存储中寻找数据。 图7.5.1Corei7地址翻译的概况7.6hello进程fork时的内存映射当fork函数被shell进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在hello中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。在这两个进程中的任一个后来进行写操作时，写时赋值机制就会创建新页面。因此，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地代替了当前程序，加载并运行hello程序需要以下几个步骤：1.删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。2.映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。3.映射共享区域。hello文件与共享对象链接，这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。4.设置程序计数器PC。Execve做的最后一件事就是设置当前进程的上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需求换入代码和数据页面。7.8缺页故障与缺页中断处理DRAM缓存不命中成为缺页。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页。若CPU引用了一个页中的字，而所需页并未缓存在DRAM中，请求不命中，那么就会触发一个缺页异常。之后缺页处理程序选择一个牺牲页将所需的页换入，更新页表，随后返回。异常返回后会重新回到导致缺页的命令，指令会重新将虚拟地址发送给MMU，此时所需页已缓存在DRAM中，请求命中。在磁盘和内存之间传送页的活动叫做交换或者页面调度。页从磁盘换入DRAM和从DRAM换出磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度。也可以采用其他方法，例如尝试预测不命中，在页面实际被引用之前就换入页面。然而，所有现代系统都使用的是按需页面调度方式。7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显示地保留为供应用程序使用。空闲块可用来分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。分配器有两种基本风格，两种风格都要求应用显式的分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。显式分配器，要求应用显式地释放任何已分配的块。隐式分配器，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。一个内存块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小，以及这个块是已分配块还是空闲的。由于块大小是8字节对齐的，故块大小最低3位总为0。因此我们用其中的最低位作分配位来指明这个块是已分配的还是空闲的。头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。 图7.9.1堆块的格式 在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。堆块的组织形式需要某种数据结构。常用的结构有隐式空闲链表、显式空闲链表和红黑树。其实现的吞吐率依次增加。放置已分配的块时需要搜索空闲链表寻找一个足够大的位置放置块。这种搜索方式是由放置策略决定的。常见的策略有首次适配、下一次适配和最佳适配。首次适配的应用最为广泛，但缺点时容易留下小的空闲碎片。下一次适配可以提高吞吐率，但内存利用率往往要低得多。最佳适配拥有最高的内存利用率，但相应的吞吐率较低。7.10本章小结本章着重探讨虚拟地址空间与物理地址空间相互映射变换的关系，以及虚拟地址到物理地址的寻址方式，回顾指明了进程管理中fork和execve函数完成的具体工作，并分析了动态内存分配管理的策略。内存管理是程序在计算机上运行至关重要的一环，高效的内存管理方式将大大提升程序的运行效率和系统的安全性，虚拟地址概念以及虚拟地址寻址技术的产生是计算机科学发展的重要成就之一。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件设备管理：UnixI/O接口一个Linux文件就是一个m个字节的序列：B0,B1,…,Bk,…,Bm-1所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。8.2简述UnixIO接口及其函数UnixI/O接口：1.打开文件：一个应用程序通过要求内核打开文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，用于标识这个文件。程序在只要记录这个描述符便能记录打开文件的所有信息。2.shell在创建的每个进程的开始时都为其打开三个文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。3.改变当前文件的位置：对于每个打开的文件，内核保存着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作显式地设置文件的当前位置为k。4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会出发一个称为EOF的条件，应用程序能检测到这个条件，在文件结尾处并没有明确的EOF符号。5.关闭文件：内核释放打开文件时创建的数据结构以及占用的内存资源，并将描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。UnixI/O函数：intopen(constchar*pathname,intflags,intperms)功能：打开一个已存在的文件或者创建一个新文件。Open函数将filename转换为一个文件描述符，并且返回描述符数字。intclose(intfd)功能：关闭一个打开的文件。关闭一个已关闭的描述符会出错。ssize_tread(intfd,void*buf,size_tcount);功能：从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则返回值表示的是实际传送的字节数量。ssize_twrite(intfd,void*buf,size_tcount);功能：从内存位置buf复制至多n个字节到描述符fd的当前文件位置。lseek();功能：应用程序能够显示地修改当前文件的位置。8.3printf的实现分析printf函数的源代码如下：intprintf(constchar*fmt,…){inti;charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } va_list的定义：typedefcharva_list这说明它是一个字符指针。其中的(char)(&fmt)+4)表示的是参数fmt后的第一个参数。vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。它最终会返回一个长度，即要打印出来的字符串的长度。从vsprintf生成显示信息，之后调用write系统函数陷入到陷阱-系统调用int0x80或syscall。之后字符显示驱动子程序实现从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）的过程。最后显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析Getchar函数的源代码如下：intgetchar(void){staticcharbuf[BUFSIZ];staticchar*bb=buf;staticintn=0;if(n==0){n=read(0,buf,BUFSIZ);bb=buf;}return(–n>=0)?(unsignedchar)*bb++:EOF;}在需要从键盘读入一个字符时，内核接收到异步异常，控制交给键盘中断处理程序。中断处理子程序接受按键扫描码转成ascii码，并保存到系统的键盘缓冲区。getchar函数中调用系统函数read，通过系统调用读取保存在系统键盘缓冲区的ascii码值，直到接收到回车键才返回。若用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中。8.5本章小结本章探讨hello程序的系统I/O管理，主要体现为printf函数和getchar函数的实现。通过对printf函数和getchar函数源代码的分析，更加深入理解了hello与外接设备的交互，并最终将信息打印到屏幕上的过程。（第8章1分） 结论Hello的一生可以概括为如下过程：1.从编码阶段开始，hello程序以源代码的形式产生于硬盘上。这是一名入门程序员唯一参与的过程。2.hello经过预处理、编译、汇编、链接、重定位转变为可执行目标文件。至此hello由易于人理解的C语言代码转变为机器可以理解的二进制代码。3.hello通过操作系统内核的管理，以进程的形式运行于系统之上。4.hello在运行过程中接收外部来自键盘的指令，并做出相应的反应。5.hello运行完成，结束短暂的一生，留下的僵死进程由内核回收。至此hello在系统中运行的痕迹被全部抹除。作为每一名程序员的入门程序hello，其实现如此简单而通俗易懂，以至于每个新手都会对它不屑一顾。实际上，hello的一生是短暂而精炼的。程序员们仅仅参与了代码的编写工作，hello余下的生命周期全部是在程序员不可参与的情况下执行的，而这些部分恰恰浓缩了现代计算机科学发展的成果，凝聚了一代代计算机科学家的心血和努力。为实现将姓名学号打印到电脑屏幕这一功能，看似简单的实现，其背后硬件系统与软件系统之间进行的精密、严谨而复杂的配合过程令人拍案叫绝。简单的hello程序凝聚的是人类智慧与科学发展的结晶，更是当今复杂程序系统，如操作系统、服务器、大型游戏、人工智能等实现的基石。能够理解如此庞大复杂的体系和精妙神奇的机制是令人振奋的。然而计算机科学的发展仅仅经历了不到百年的时光，如今计算机科学仍在以迅猛的势头不断发展。在未来，量子计算机、人工智能、虚拟现实技术等等充满无限可能的科技正慢慢向我们靠近。我们有理由相信，计算机科学仍然有无穷的潜力去创造一个又一个令人类骄傲的奇迹！ （结论0分，缺失-1分，根据内容酌情加分） 附件hello.cC语言源代码文件hello.i预处理阶段生成文件hello.s编译阶段生成文件，内容为汇编代码hello.o汇编阶段生成文件，二进制可重定位目标文件hello可执行目标文件hello.elf可重定位目标文件的ELF格式hello2.elf可执行目标文件的ELF格式hello_o_asm.txt可重定位目标文件的反汇编代码hello_asm.txt可执行目标文件的返汇编代码 （附件0分，缺失-1分） 参考文献为完成本次大作业你翻阅的书籍与网站等[1]深入理解计算机系统RandalE.BryantDavidR.O’Hallaron机械工业出版社[2]printf函数实现的深入剖析Pianistx 博客园https://www.cnblogs.com/pianist/p/3315801.html（参考文献0分，缺失-1分） 

声明：几篇博文都是我在课程学习过程中不定期写的，写完之后存在本地因为调代码格式比较麻烦没有立马上传，最后在期末前一并上传的，但并不是一天内写好的，请助教老师检查。 如题。声明：几篇博文都是我在课程学习过程中不定期写的，写完之后都存在本地，因为调博文的代码格式比较麻烦没有立马上传。虽然最后在期末前一并上传的，但并不是短时间内写了多篇，望助教老师知情，请检查。 

在Anaconda虚拟环境中安装Tensorflow+Keras 首先进入AnacondaPrompt，通过activate命令进入我们的虚拟环境，然后依次输入如下命令进行安装即可。1.安装mingwlibpython condainstallmingwlibpython 2.安装tensorflow(GPU加速版本) condainstalltensorflow-gpu 3.安装keras(GPU加速版本) condainstallkeras-gpu 

哈工大2021春CSAPP大作业-程序人生（Hello’sP2P） 

Win10+Anaconda3+Pytorch1.8(CUDA11.1)+Jupyter安装教程 最近要搭神经网络做二分类，因为很多教程都比较老了，所以在这里记录一下自己安装环境的全流程，方便其他人参考。 Anaconda3安装 Anaconda3下载 首先到Anaconda官网下载Anaconda3的安装包。如果是个人使用，依次点击左上角Products→IndiviadualEdition，点击Download，根据自己的电脑系统选择合适的版本进行下载，笔者在这里下载的是WindowsPython3.864-bit版本。 Anaconda3的安装 下载完成后进行安装。点击下载好的Anaconda3-2020.11-Windows-x86_64.exe，依次点击Next→Iagree。这里建议选择第二个选项，以便不同用户使用Anaconda。 之后就是选择路径这一步的两个选项，上面一个意思是加入环境变量，这个我们稍后自己设置，不用勾选。下面一个是默认使用Python3.8，建议勾选。然后等待安装完毕即可。 Anaconda3环境变量配置 依次点击此电脑 右键打开属性 高级系统设置 环境变量 path(注意是系统变量里的path,不是用户变量里的) 编辑 新建根据自己的路径，添加如下环境变量(把G:\Anaconda3改成自己的Anaconda安装路径)： G:\Anaconda3 G:\Anaconda3\Scripts G:\Anaconda3\Library\bin 检验是否安装成功 按win+R键进入运行栏，输入cmd，在命令行下输入conda。如果出现相关信息则说明安装成功。如果没有则按照提示信息进行激活等操作。再输入python，确认python版本为3.8 Pytorch的安装 创建虚拟环境 按win键打开AnacondaPrompt输入如下命令 condacreate-nGypsophilapython=3.8//创建虚拟环境，虚拟环境的名字是Gypsophila（可以任意修改） activateGypsophila//切换到我们创建的虚拟环境 通过第一行命令创建虚拟环境，中途需要确认，直接回车即可。输入第二行命令后，左边括号里变成了虚拟环境的名字，则说明创建成功。这个页面先不急着关掉，后续马上就会用到。 添加清华镜像源 在AnacondaPrompt中，如果命令行提示语句开头显示(base)，则首先用前一步的activate命令切换到我们创建的虚拟空间。开始添加清华源的步骤。因为国内连Pytorch的服务器速度很慢，安装失败率很高，所以切换到清华镜像源几乎是必须的。依次输入如下代码： condaconfig--addchannelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ condaconfig--addchannelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ condaconfig--setshow_channel_urlsyes condaconfig--addchannelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ condaconfig--addchannelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/ condaconfig--addchannelshttps://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ 其中最后一行命令安装CUDA11.1及以上版本才需要，不过建议还是写上 安装Pytorch Anaconda3安装完成并添加源后开始安装Pytorch。进入Pytorch官网，找到如下界面下面依次来介绍每一行的意义及选项 PytorchBuild：Pytorch版本的选择。建议选择Stable（稳定运行版）。清华源似乎不提供Preview版的镜像，若要下载Preview版可能速度很慢。YourOS：根据自己电脑操作系统选择Pytorch版本。Package：Windows系统选上Conda，Linux系统选Pip。Language：根据编程语言选择ComputePlatform：这一个的选择稍微有些复杂。首先，如果不是NVIDIA的显卡，则选择CPU选项。如果是NVIDIA的显卡，则通过win+R呼出cmd命令行，输入如下命令以确认自己电脑的CUDA版本： nvidia-smi 从CUDAVersion栏可以看出电脑显卡能够支持的最高版本CUDA（在这台电脑上是CUDA11.1），在选择ComputePlatform时对应的CUDA版本不能高于这里显示的CUDAVersion。在这之后，复制Pytorch官网生成的命令，但注意，要把命令中的-cpytorch与-cconda-forge（如果有）删掉，否则还是默认从主服务器上下载，速度很慢！！！最终得到的命令如下： condainstallpytorchtorchvisiontorchaudiocudatoolkit=11.1 呼出AnacondaPrompt，进入自己搭好的虚拟环境，输入上面的命令。安装包有数个G，需要等待一段时间，等待安装完成即可。安装完成后，在虚拟环境中输入如下命令 python importtorch torch.cuda.is_available() 如果返回值是True，则说明可用GPU加速，Pytorch与CUDA的安装完成。 Jupyter的安装 安好Anaconda与Pytorch后，编辑器的选择很多，有VSCode、PyCharm、Jupyter等等，这里介绍一下Jupyter的安装方法。先打开AnacondaPrompt命令行，进入自己设置的虚拟环境，输入如下命令安装： condainstallnb_conda 中途确认，等待安装完成。安装完成后，在虚拟环境下输入jupyternotebook，跳转到jupyter页面，选择红框所示选项（名字是自己虚拟环境的名字）。输入如下指令后点运行，输入为True，则说明Jupyter安装完成，且使用的是我们自己安装的带有Pytorch的虚拟环境。可以参照我的这些文章进行进一步的环境配置 在VScode下配置Anaconda环境 在Anaconda虚拟环境中安装TensorFlow+Keras 

Win10下在VScode中配置Anaconda3Python环境&CommandNotFoundError的解决方式 Anaconda3环境与PyTorch的安装 可以参考我之前的博文安装Anaconda3与PyTorch。 在VScode下配置Anaconda3 先安装VScode（可以参照其他教程）安装完成后，打开VScode，至少安装如下插件： Python环境安装，由于在之前安Anaconda时已经安装了Python，所以这里直接安VScode中的插件就好。安装VScode的中文环境插件，方便阅读。安装好上述插件后，在工作区中新建一个.py文件，点开.py文件，查看左下角Python版本的显示形式，如果不是PythonX.X.X64-bit('虚拟环境名':conda)的形式，则点击它，然后在弹出的窗口中选择我们的工作区，将Python版本切换成我们虚拟环境中的版本。这样VScode+Anaconda3Python环境便配置完成，通过如下代码进行测试，如果成功输出True则安装成功。 importtorch print(torch.cuda.is_available()) 如果测试时出现如下报错提示 CommandNotFoundError:Yourshellhasnotbeenproperlyconfiguredtouse‘condaactivate‘ 则可以按这位博主的方式处理https://blog.csdn.net/cskywit/article/details/99202520 

深入理解计算机系统-cachelab中矩阵转置的基本分析 在做cachelab时发现自己对cache的具体工作原理理解不深，网上也很少有这部分的具体讲解，故自己在此记录一下： （牢牢抓住一点：cache是高速缓存！！缓存！！） 以一个简单的例子来说明矩阵转置时cache的具体工作情况。 假设我们现在有一个包含2组，每组1行，每行存8个int型数据的简单cache（S=2,E=1,B=32），现在要对一个4x4的矩阵进行转置。记原矩阵为A，转置后的矩阵为B。 则我们可以得知，矩阵中前2行元素与后2行元素分别存在cache的不同块中。 假设交换的函数如下： for(i=0;i<4;i++) { for(j=0;j<4;j++) { tmp=A[i][j]; B[j][i]=tmp; } } 我们以示意图的方式来说明cache的工作情况(这里只列出了cache的数据块) 有上述简单分析，应该就能知道cachelab中不命中的原理了。 

VSCode下运行Python程序报错ModuleNotFoundError的解决方案 基本情况：安装了Anaconda虚拟环境，在用VSCode写Python程序时，遇见了这样的错误： ModuleNotFoundError:Nomodulenamed‘torch’ 经过测试，只有部分包如tensorflow,keras无法导入，而其他一些包如xlwt则导入正常，可以使用。 查找了网上的很多方法，如修改setting.json文件，并没有起到作用，最后通过开启设置中的runinterminal功能得以解决： Ctrl+Shift+P打开用户设置→拓展→RunCodeConfiguration→勾选RunInTerminal即可。 

HIT-CSAPP大作业-程序人生-2021 摘要 本文主要阐述了hello程序的一生，从编写完得到的hello.c到其经过预处理、编译、汇编、链接和加载到内存进行运行的整个过程，同时还讲述了进程管理、存储管理以及IO管理，其中夹杂着很多计算机系统的本质概念。 关键词：程序；运行；管理；计算机系统 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 P2P：(FromProgramtoProcess) 首先编译器编写hello.c源程序Program，然后运行C预处理器（cpp）将hello.c翻译成一个ASCII码的中间文件hello.i，而后编译器（ccl）将hello.i翻译成一个ASCII汇编语言文件hello.s，接下来汇编器（as）将hello.s翻译成一个可重定位目标文件hello.o，在通过链接器与库函数链接，创建一个可执行目标文件prog，shell执行该文件，通过fork产生子进程，调用execve函数加载运行该进程，产生Process。 020：(FromZerotoZero) shell调用fork和execve后，程序映射到虚拟内存，删除当前虚拟地址的数据结构并创建新的区域结构，在经过程序入口后载入物理内存，再运行main函数至结束，父进程回收子进程，占据的内存也被释放。 1.2环境与工具 1.2.1硬件环境： Intel(R)Core(TM)i7-8750HCPU；2.20GHz；16.0GBRAM； 1.2.2软件环境： Windows1064位；VMware15.5；Ubuntu20.04LTS64位； 1.2.3开发工具与调试工具： VisualStudio201964位；CodeBlocks；gcc；objdump；gdb；edb；hexedit；readelf； 1.3中间结果 hello.c：C语言源程序 hello.i：hello.c预处理得到的.i文件 hello.s：hello.i经过编译得到的汇编代码.s文件 hello.o：hello.s经过汇编得到的可重定位目标.o文件 hello：hello.o与库函数的链接得到的可执行目标文件 helloo.txt：hello.o的反汇编文件，查看反汇编代码 hello.txt：hello的反汇编文件，查看反汇编代码 helloo.elf：hello.o的elf文件，查看各节的信息 hello.elf：hello的elf文件，查看各节信息 1.4本章小结 本章介绍了hello程序，同时列出了实验的环境、工具和中间结果。 第2章预处理 2.1预处理的概念与作用 2.1.1概念 预处理阶段将根据已放置在文件中的预处理指令来修改源文件的内容，得到以.i文件。#include指令就是一个预处理指令，告诉预处理器（cpp）读取头文件的内容. 2.1.2作用 1.条件编译：根据条件有选择性的保留或者放弃源文件中的内容。 2.源文件包含：搜索指定的文件，并将它的内容包含进来，放在当前所在的位置。源文件包含有两种，包含系统文件以及用户自定义文件。 3.宏替换：宏的作用是把一个标识符指定为其他一些成为替换列表的预处理记号，当这个标识符出现在后面的文本中，将用对应的预处理记号把它替换掉。 4.行控制：行控制指令以“#”和“line”引导，后面是行号和可选的字串。用于改变预定义宏“_LINE_”的值，如果后面的字串存在，则改变“_FILE_”的值。 2.2在Ubuntu下预处理的命令 预处理指令：gcc-Ehello.c-ohello.i 图2.1 产生的.i文本文件如下图：（预处理添加的内容较多，只截取了一部分） 图2.2 2.3Hello的预处理结果解析 可以看出，预处理后得到的.i文件的main函数主体是没变化的，但提取出来的头文件是很多的，该C源程序是包含有三个include的系统文件的，它让预处理器去系统目录下查找相关文件，并且将它的内容包含进来，放在当前所在的位置。 2.4本章小结 本章主要是了解预处理的概念和作用，以及Ubuntu下预处理的指令，并且对预处理的结果进行了相关的解析。 第3章编译 3.1编译的概念与作用 3.1.1概念 将预处理得到的输出文件（.i文件）进行翻译得到等价的中间代码表示或汇编代码（.s文件）。 3.1.2作用 经过预处理得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及C语言的关键字，而编译就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的汇编代码。 3.2在Ubuntu下编译的命令 gcc-Shello.i-ohello.s 图3.1Ubuntu下的编译指令 3.3Hello的编译结果解析 3.3.1伪指令 下图中截取的部分均为指导汇编器和连接器工作的伪指令。 .file：声明源文件的名字为“hello.c”；.text：表示代码段；.global：声明全局变量sleepsecs；.data：表示数据段；.align4：声明代码段的对齐方式为4字节对齐；.typesleepsecs,@object：声明sleepsecs为object符号；.size：声明sleepsecs的大小为4个字节；.long：AT&T的汇编伪指令中.long是.int的等价指令，声明sleepsecs为int类型；.section.rodata：表示只读数据段，其中.LC0和.LC1中的.string代表printf函数输出的两个字符串常量；.globalmain：声明main函数为全局变量；.typemain,@function：声明main为函数符号； 图3.2伪指令 3.3.2数据 1）整型 sleepsecs：初始化后的全局变量，在.data节中保存有初始值；argc：main函数的整型参数，保存在寄存器%edi中，且保存在初始栈底向上的20字节处；（具体见图3.3，图3.3开始部分是函数分配栈空间）i：整型局部变量，保存在栈中； 图3.3栈空间分配和main函数参数压栈 2）字符串 printf函数中的两个字符串常量，且保存在只读数据段.rodata节中； 3）数组 argv：字符型数组，保存在寄存器%rsi中，且保存在初始栈底向上的32字节处； 3.3.3赋值和算术操作 1）赋值 其中包含的赋值操作：movl、movq和leaq； 2）算术操作 其中包含的算术操作： addq：加操作；subq：减操作； 3.3.4关系操作 有两处的关系操作： cmpl$3,-20(%rbp)：argc!=3的关系判断（图3.4）； 图3.4argc!=3 cmpl$9,-4(%rbp)：i<10的关系判断（图3.5）； 图3.5i<10 3.3.5数组/指针操作 main的第二个参数为argv[]的char型指针数组，其中每个元素分别代表每一字符串的首地址，而在前面提到，argv保存在寄存器%rsi中，同时还保存在原栈底向上32位的处，在.L4一开始movq-32(%rbp),%rax指令把argv[0]存储的字符串地址传递给寄存器%rax，然后addq$16,%rax将%rax加16，即得到argv[2]的地址，接下来的movq(%rax),%rdx指令把argv[2]指向的字符串存储在寄存器%rdx中，之后的movq-32(%rbp),%rax、addq$8,%rax、movq(%rax),%rax同理，把argv[1]指向的字符串存储在寄存器%rax中，然后再movq%rax,%rsi传递给%rsi，然后%rdx和%rsi作为参数调用printf语句。 图3.6数组/指针操作 3.3.6控制转移 有两处的控制转移操作： 若argc等于3，则跳转到.L2处，不相等则继续下一步； 图3.7 若i大于9，则跳出循环，否则进行下一轮的循环； 图3.8 3.3.7函数操作 有四处的函数调用操作： 调用puts函数，其中.LC0处的字符串传给%rdi寄存器中，然后%rdi作为参数调用puts函数，进行输出（图3.9）；调用exit函数，程序终止（图3.9）； 图3.9 调用printf函数，上述中提到的argv[1]和argv[2]作为参数调用printf函数（图10）；调用sleep函数，将全局变量sleepsecs作为参数调用sleep函数进行休眠（图3.10）； 图3.10 3.4本章小结 本章主要对编译得到的汇编代码进行细致的分析，分析各种指令对应于C语言的含义以及相关的数据和操作的串联关联。 第4章汇编 4.1汇编的概念与作用 4.1.1概念 汇编是将hello.s翻译为机器语言指令，同时把这些指令打包为可重定位目标程序，并将结果保存到hello.o文件中； 4.1.2作用 将汇编代码翻译为机器可以识别的机器指令，可以在链接时与其他可重定位目标文件合并起来，创建一个可执行目标文件。 在Ubuntu下汇编的命令 gcc-chello.s-ohello.o 图4.1 4.3可重定位目标elf格式 4.3.1ELF头 ELF定义了ELF魔数、版本、小端/大端、操作系统平台、目标文件的类型、机器结构类型、程序执行的入口地址、程序头表（段头表）的起始位置和长度、节头表的起始位置和长度； 魔数：文件开头的16个字节，通常用来确定文件的类型或格式，加载或读取文件时，可用魔数确认文件类型是否正确； 图4.2ELF头信息 4.3.2节头表 除ELF头之外，节头表是ELF可重定位目标文件中最重要的部分内容； 描述每个节的节名、在文件中的偏移、大小、访问属性、对齐方式等； 图4.3节头表信息 4.3.3.rela.text节 .text节的重定位信息，用于重新修改代码段的指令中的地址信息，一般而言，任何调用外部函数或者引用全局变量的指令都需要修改，另一方面，调用本地函数的指令则不需要修改。 这是ELF重定位条目的格式： typedefstruct{ intoffset; inttype:32, symbol:32; longaddend; }Elf64_Rela; offset是需要被修改的引用的节偏移，指的就是.rela.text中的偏移量； symbol标识被修改引用应该指向的符号，对应的是.rela.text中的符号值和符号名称； type告知链接器如何修改新的引用，对应的是.rela.text中的信息和类型； addend是一个符号常熟，一些类型的重定位要使用它对被修改引用的值做偏移调整，对应的是.rela.text中的加数； 图4.4.rel.text节信息 4.3.4.rela.eh_frame节 .eh_frame节的重定位信息； 图4.5.rela.eh_frame节信息 4.3.5.symtab节 符号表，存放在程序中定义和引用的函数和全局变量的信息，但和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。 图4.6.symtab节信息 Hello.o的结果解析 使用命令objdump-d-rhello.o得到反汇编代码，对其与汇编代码进行对比分析，发现了一些不同之处： 4.4.1分支转移 hello.s得到的汇编代码进行分支转移时是借助了助记符.L4、.L2等，而对hello.o进行反汇编得到的代码分析可知，分支转移语句均使用PC偏移量进行跳转； 图4.7跳转语句1 图4.8跳转语句2 图4.9跳转语句3 4.4.2函数调用 hello.s得到的汇编代码进行函数调用是直接在指令后面跟着函数名，而在反汇编后的代码中，指令后面跟着的是需要在链接时进行重定位的地址，并将其添加到重定位条目； 图4.10调用puts函数 图4.11调用exit函数 图4.12调用printf函数 图4.13调用sleep函数 图4.14调用getchar函数 4.4.3数据 汇编代码调用puts和printf进行输出的两个字符串常量是通过两个助记符.LC0和.LC1，而反汇编代码是利用PC相对寻址和重定位来获取两个字符串常量，对于全局变量sleepsecs，汇编代码调用时直接利用sleepsecs的变量名作代表，而反汇编代码同样是利用PC相对寻址和重定位进行锁定。 图4.15原助记符.LC0对应的字符串 图4.16原助记符.LC1对应的字符串 图4.17sleepsecs全局变量 4.5本章小结 本章剖析了可重定位目标elf格式的构成，同时对汇编代码和可重定位目标文件的反汇编代码进行比较，明确了机器指令与汇编语言的映射关系。 第5章链接 5.1链接的概念与作用 5.1.1概念 将各种代码和数据片段收集并组合成为一个单一文件的过程。这个文件可被加载（复制）到内存并执行。 5.1.2作用 使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。 5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o /usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1 这段命令中dynamic-linker为动态链接器，指的是/lib64/ld-linux-x86-64.so.2，而我们使用ld非标准链接，因此需要crt1.o、ctri.o和crtn.o，crt1.o包含程序入口函数_start及两个未定义符号_libc_start_main和main，由入口函数调用_libc_start_main初始化libc，然后调用main函数，而crti.o和crtn.o辅助启动类似全局静态对象的代码。 5.3可执行目标文件hello的格式 5.3.1ELF头 与可重定位文件的ELF头稍有不同，可执行目标文件的ELF头中包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址：0x4010d0，在可重定位文件中则为0，其他部分均相似； 图5.2ELF头 5.3.2节头表 可执行目标文件的节头表与可重定位目标文件不同于地址空间，链接后，可执行目标文件的节头表中对应的每一个节的地址为虚拟地址。 .init节：用于定义_init函数，该函数用来进行可执行目标文件开始执行时的初始化工作，初始地址：0x401000，大小：0x1b； .text节：已编译程序的机器代码，初始地址：0x4010d0，大小：0x135； .rodata节：只读数据，比如printf语句中的格式串和开关语句的跳转表，初始地址：0x402000，大小：0x2f； .data节：已初始化的全局和静态C变量，初始地址：0x404040，大小：0x8； .bss节：未初始化的全局和静态C变量，大小：0x8； .symtab节：符号表，存放在程序中定义和引用的函数和全局变量的信息，大小：0x4c8； .debug节：调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件； .strtab节：字符串表，其内容包含.symtab和.debug中的符号表，以及节头部中的节名字，大小：0x150； .line节：原始C源程序中的行号和.text节中机器指令之间的映射。 图5.3节头表 图5.4节头表（续） 5.3.3程序头部表 描述了可执行文件的连续的片（chunk）被映射到连续的内存段的映射关系； 图5.5程序头部表 5.4hello的虚拟地址空间 1).init节对应的虚拟地址为：0x401000~0x40101a； 图5.6_init节对应的虚拟地址空间 2).text节对应的虚拟地址为：0x4010d0~0x401204； 图5.7.text节对应的虚拟地址空间 3).rodata节对应的虚拟地址为：0x402000~0x402002e； 图5.8.rodata节对应的虚拟地址空间 4).data节对应的虚拟地址为：0x404040~0x404047； 图5.9.data节对应的虚拟地址空间 5.5链接的重定位过程分析 可执行目标文件hello和可重定位目标文件hello.o的汇编代码是一致的，但两者的跳转指令、调用函数指令等后接的地址是不同的，hello.o的地址属于PC相对偏移，而对其进行重定位操作后，才能得到hello中可以由CPU直接访问的虚拟地址，并且对比反汇编文件，hello进行反汇编有更多的节，hello.o反汇编（objdump-d）得到的只有.text节，而hello反汇编得到的不止有.text节，还有.init、.plt、.fini和.plt.got节，.init节是程序初始化需要执行的代码，.plt和.plt.got节分别是动态链接中的过程链接表和全局偏移量表，.fini节是程序正常终止时需要执行的代码，因为库函数的代码已经链接到hello中，使得每个节更加完整。 下面详细介绍一下重定位具体步骤，重定位由两步组成： 重定位节和符号定义 在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成为输出的而可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 重定位节中的符号引用 在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构，在前面有提及重定位条目的数据结构，这里就不再赘述。 然后是重定位的具体算法，分为两块，一个是PC相对引用，另一个是绝对引用，而hello中的重定位只包含有PC相对引用，故下文我着重分析了重定位PC相对引用的算法： 重定位PC相对引用： 这里举个例子： 调用puts函数， ADDR(main)=0x401105； 图5.10main函数的地址 ADDR(puts)=0x401080； 图5.11puts函数的地址 puts函数在重定位节.rel.text中的偏移量为：0x21，addend值为-4； 图5.12.rela.text节中的相关信息 故，refaddr=ADDR(main)+offset=0x401105+0x21=0x401126； *refptr=(unsigned)(ADDR(puts)+addend-refaddr) =(unsigned)(0x401080+(-4)–0x401126)=(unsigned)(-0xaa)； 当CPU执行call指令时，PC的值为0x40112a，即紧随在call指令之后的指令的地址。 图5.13call指令之后的指令地址 PC<-PC+(-0xaa)=0x401080； 该地址正好是puts函数的第一条指令地址，故call指令成功调用了puts函数。 5.6hello的执行流程 子程序名地址ld-2.31.so!_dl_init0x7f9cf64fdf0hello!_start0x4010d0libc-2.31.so!_libc_start_main0x7f9cf746bfc0libc-2.31.so!_cxa_atexit0x7f9cf748ef60hello!_libc_csu_init0x401190libc-2.31.so!_setjmp0x7f9cf748ae00hello!main0x401105hello!puts@plt0x401030hello!exit@plt0x401060libc-2.31.so!exit0x7fe9f6f40bc0 图5.14edb调试hello的过程截图 5.7Hello的动态链接分析 程序调用由共享库定义的PIC函数，编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态连接器在程序加载的时候再解析它。不顾这种方法并不是PIC，因为它需要链接器修改调用模块的代码段，所以需要添加重定位记录，等待动态链接器处理，GNU编译系统使用延迟绑定技术，将过程地址的绑定推迟到第一次调用该过程时。 使用延迟绑定的动机是对于一个像libc.so这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用其中很少的一部分。把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用。 延迟绑定是通过两个数据结构的交互来实现的，这两个数据结构是GOT(全局偏移量表)和PLT（过程链接表）。如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT。GOT是数据段的一部分，PLT是代码段的一部分。图5.15展示了PLT和GOT如何协作在运行时解析函数的地址。 而其中我们关心的使GOT和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应与一个被调用的函数，其地址需要在运行时被解析。 图5.15用PLT和GOT调用外部函数 通过readelf查看节头表中的.got.plt信息，可知.got.plt节的开始地址为0x4040000，且大小为0x40； 图5.16.got.plt节地址 然后利用edb查看dl_init前后动态链接的变化，首先从edb的DataDump打开0x403000–0x405000范围内的数据，找出0x404000–0x40403f即为dl_init的数据段： 图5.17dl_init前 使用edb执行到dl_init，该段发生变化，变化为： 图5.18dl_init后 可以发现在dl_init后出现了两个地址，分别为0x7f9979380190和0x7f9979369bb0，这就是GOT[1]和GOT[2]，同样利用edb查看GOT[2]内容，可以发现是动态链接函数： 图5.19动态链接函数 5.8本章小结 本章分析了链接的指令以及链接产生的可执行目标文件hello的格式，同时解析了hello的虚拟地址空间还有重定位和动态链接的具体过程及算法。 第6章hello进程管理 6.1进程的概念与作用 6.1.1概念 一个执行中的程序的实例，同时也是系统进行资源分配和调度的基本单位。一般情况下，包括文本区域、数据区域和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。 6.1.2作用 进程能够提供给应用程序关键抽象： 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器； 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 6.2.1作用 Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至时编写一些程序。Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令，能够交互性地解释和执行用户输入的命令，能够通过调用系统级的函数或功能来执行程序、建立文件、进行并行操作，还能够协调程序间的运行冲突，保证程序能够高效执行，与此同时，bash还提供了一个图形化的界面。 6.2.2处理流程 Shell首先打印一个命令行提示符，然后从终端（terminal）中获取用户输入的命令然后对此命令分割命令行参数，然后对此进行重构若第一个参数是一个内置的shell命令，则直接调用内部函数执行若不是内置的shell命令且是一个可执行目标文件，则创建新的子进程，在子进程的上下文中加载运行该文件最后判断该程序是在前台执行还是在后台执行，如果是在前台执行则等待进程结束，若是在后台执行，则直接等待用户的下次的命令行输入 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的子进程； pid_tfork(void); 新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和子进程最大的区别在于它们有不同的PID。 fork函数只被调用一次，却会返回两次。一次是在调用进程中，一次是在新创建的子进程中。在父进程中，fork返回子进程的pid，在子进程中，fork返回0。因为子进程的PID总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。 创建过程： 给新进程分配一个标识符在内核中分配一个PCB（进程管理块），将其挂在PCB表上复制它的父进程的环境（PCB中大部分的内容）为其分配资源（程序、数据、栈等）复制父进程地址空间里的内容（代码共享，数据写时拷贝）将进程设置成就绪状态，并将其放入就绪队列，等待CPU调度 6.4Hello的execve过程 execve函数在当前进程的上下文中加载并运行一个新程序。 intexecve(constchar*filename,constchar*argv[],constchar*envp[]); execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境遍历列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。所以，与fork一次调用返回两次不同，execve调用一次并从不返回。 在execve加载了filename后，它调用驻留在内存中的启动加载器的操作系统代码以此执行hello程序，加载器删除子进程现有的虚拟内存段，并创建一组新的人代码、数据、堆和栈，栈和堆被初始化为0，通过虚拟地址映射到可执行目标文件的片，新的代码和数据段被初始化为可执行文件中的内容，然后跳转至_start函数，_start函数调用系统启动函数_libc_start_main进行初始化，最后调用主函数main。 6.5Hello的进程执行 操作系统内核使用一中称为上下文切换的较高层形式的异常控制流来实现多任务。 内核为每个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态，它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程一打开文件的信息的文件表。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策叫做调度，是由内核中称为调度器的代码处理的，当内核选择一个新的进程运行时，就说内核调度了这个进程。当内核调度了一个新的进程运行后，它就抢占当前进程，并通过上下文切换的机制将控制转移到新的进程。 上下文切换的流程为： 保存当前进程的上下文恢复某个先前被抢占的进程被保存的上下文将控制传递给这个新恢复的进程 当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个时间发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。如read系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另一个进程；sleep系统调用显式地请求让调用进程休眠。 中断也可能引发上下文切换。所有系统都有某种产生周期性定时器中断的机制，每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。 下图展示了一对进程A和B之间上下文切换的示例： 图6.1进程的上下文切换 6.6hello的异常与信号处理 程序运行过程中键盘不停乱按或者回车都不会影响输出，而在输出的循环结束了之后，程序调用getchar函数，读入了原先在运行过程中键盘乱按出的一行内容，并且后续乱按的内容也被不断地当成命令读入，说明在hello运行过程中，额外的输入会被缓存到输入缓冲区，直到程序结束后读出。 图6.2在运行过程中乱按 在hello运行的过程中按Ctrl+Z，进程停止； 图6.3Ctrl+Z进程停止 然后通过ps命令，可以查看当前进程的状态： 图6.4ps查看进程状态 jobs命令获取任务列表和任务的状态： 图6.5jobs获取任务列表 pstree命令查看进程树： 图6.6pstree查看进程树 图6.7进程树（续1） 图6.8进程树（续2） 图6.9进程树（续3） fg指令，将后台作业挂在前台： 图6.10fg命令 kill-92942杀死hello进程： 图6.11kill杀死hello进程 hello运行过程中按下Ctrl+C，程序直接终止： 图6.12Ctrl+C直接终止进程 6.6.1异常 异常可分为四类：中断、陷阱、故障和终止； 1）中断 中断是来自处理器外部的I/O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为中断处理程序。 当中断处理程序返回时，它就将控制返回给下一条指令。结果是程序继续执行，就好像没有发生过中断一样。 2）陷阱 陷阱是有意的异常，是执行一条指令的结果。 陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。 用户程序经常需要像内核请求服务，为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的“syscalln”指令，当用户程序想要请求服务n时，可以执行这条命令。执行syscall指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。 3）故障 由错误情况引起的，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序，如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。 4）终止 终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。 6.6.2信号处理 这里只说明上述截图中涉及的信号处理； Ctrl+C：内核会发送一个SIGINT信号给这个前台进程组中的每个进程，默认情况下，结果为终止前台进程组； Ctrl+Z：内核会发送一个SIGTSTP信号到前台进程组中的每个进程，默认情况下，结果是挂起前台作业； kill-9：发送一个SIGKILL信号强制终止进程； 6.7本章小结 本章首先介绍了进程和shell，然后剖析了Hello通过调用fork函数创建子进程的过程和execve函数在当前进程的上下文加载并运行一个新程序的过程，最后演示了hello的异常和信号处理机制。 第7章hello的存储管理 7.1hello的存储器地址空间 7.1.1逻辑地址 也叫做相对地址，是由程序产生的与段有关偏移地址，用来指定一个操作数或是一条指令的地址，其格式为：段地址：段偏移量； 7.1.2线性地址 地址空间是一个非负整数地址的有序集合，而如果地址空间中的整数时连续的，那么我们可以说它时一个线性地址空间； 7.1.3虚拟地址 程序运行在保护模式下，程序访问存储器所使用的逻辑地址称为虚拟地址，虚拟内存被组织为一个存放在磁盘上的N个连续的字节大小的单元组成的数组，其每个字节对应的地址称为虚拟地址； 7.1.4物理地址 计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，其每个字节都被赋予一个唯一的地址，这个地址称为物理地址，物理地址同样也是计算机的硬件中的电路进行操作的地址。 对hello进行反汇编得到的每一节所在的地址均是逻辑地址的段偏移量部分，而段偏移量加上段基址即为虚拟地址，在这里虚拟地址与线性地址相同，而Linux的所有段基址均是0，所以此时逻辑地址与虚拟地址是相同的。 7.2Intel逻辑地址到线性地址的变换-段式管理 分段功能在实模式和保护模式下是不同的； 实模式下，逻辑地址和线性地址和物理地址是相等的，段寄存器存放真实的段基址，再根据32位的段地址偏移量即可访问物理内存； 保护模式下，内存管理单元先是依据16位的段选择符（段选择符如图7.1）中的TI确定选择GDT（全局描述符）还是LDT（局部描述符表），确定完之后，再通过段选择符的13位索引值从选中的描述符表中寻找对应的段描述符，而每个段描述符占8个字节，因此位移量位索引值乘8，再加上描述符表首地址，因此确定了选中的段描述符的地址，以此得到32位的段地址，最后加上偏移地址，就可以得到32位的线性地址了。（整体过程如图7.2） 图7.1段选择符的16位格式 图7.2整体过程 7.3Hello的线性地址到物理地址的变换-页式管理 概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存（较高层）之间的传输单元。VM系统通过将虚拟内存分割位称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P=2P字节。类似地，物理内存被分割为物理页，大小也为P字节。 在任意时刻，虚拟页面的集合都分为三个不相交的子集： 未分配的：VM系统还未分配的页。缓存的：当前已缓存在物理内存中的已分配页。未缓存的：未缓存在物理内存中的已分配页。 而页表将虚拟页映射到物理页，每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。 下图为一个页表的基本组织结构。页表就是一个页表条目的数组。虚拟地址空间中的每个页在页表中一个固定的偏移量处都有一个PTE，假设每个PTE是由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。 图7.3页表 下图展示了内存管理单元如何利用页表来实现这种映射。CPU中的一个控制寄存器，页表基址寄存器指向当前页表。N位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。MMU利用VPN来选择适当的PTE，将页表条目中物理页号和虚拟地址中的VPO串联起来，就得到相应的物理地址。 图7.4使用页表的地址翻译 7.4TLB与四级页表支持下的VA到PA的变换 TLB被称为翻译后备缓冲器，是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。如下图所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。 图7.5TLB的组成 图7.6a展示了当TLB命中时所包括的步骤： CPU产生一个虚拟地址；MMU从TLB中取出相应的PTE；MMU将此虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存；高速缓存/主存将所请求的数据字返回给CPU。 当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，如7.6b所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。 图7.6TLB命中和不命中的操作图 下图描述了四级页表下的VA到PA的变换即进行地址翻译。虚拟地址被划分位4个VPN和1个VPO。每个VPNi都是一个到第i级页表的索引。第j级页表中的每个PTE，都指向第j+1级的某个页表的基址。第k级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN之前，MMU必须访问k个PTE。 36位VPN被划分为4个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 图7.7使用4级列表的地址翻译 7.5三级Cache支持下的物理内存访问 虚拟地址通过地址翻译得到物理地址后，MMU发送物理地址给L1缓存，缓存从物理地址中抽取出缓存偏移CO、缓存组索引CI以及缓存标记CT，若标记匹配，缓存命中的话，则读出在偏移量CO处的数据字节，并将它返回给MMU，随后MMU将它传递给CPU，若缓存未命中的话，则从L2缓存中进行匹配，若命中则将其存储在L1缓存且返回给MMU，若不命中，则从L3缓存中进行匹配，若命中则将其存储与L2缓存和L1缓存，而后返回给MMU，若不命中，则从主存中寻找。下图为一个四级页表和三级Cache支持下的物理内存访问： 图7.8四级页表和三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 若hello进程fork创建的子进程试图写私有区域内的某个页面，那么写操作就会触发一个保护故障，当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限，如下图。当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。 图7.9进程2写了私有区域的一个页之后 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并允许包含了可执行文件hello中的程序，用hello程序有效地替代了当前程序。加载并允许hello需要以下一个步骤： 1. 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2. 映射私有区域。为hello程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零，下图概括了私有区域的不同映射。 3. 映射共享区域。如果hello与共享对象或目标链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 4. 设置程序计数器PC。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 下一次调度这个进程时，它将从这个入口点开始执行。Linux根据需要换入代码和数据页面。 图7.10加载器是如何映射用户地址空间的区域的 7.8缺页故障与缺页中断处理 当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。然后调用缺页处理程序，缺页处理程序就执行下面步骤： 查看虚拟地址是否合法，若不合法，那么缺页处理程序就触发一个段错误，从而终止这个进程；查看试图进行的内存访问是否合法，如果试图访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程；选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送虚拟地址到MMU，MMU就能正常翻译它了，而不会再产生缺页中断了。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显示地被应用所分配。一个已分配的块保持已分配状态，直到它被释放。 分配器有两种基本风格，显式的和隐式的。 显式分配器，要求应用显式地释放任何已分配的块。如C标准库提供的malloc程序包显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。 隐式分配器，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集。 任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。 一个块是由一个字的头部、有效载荷、以及可能的一些额外的填充组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是0。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。 头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。 假设块的格式如下图所示： 图7.11堆块格式 我们可以将堆组织为一个连续的已分配块和空闲块的序列，如下图所示： 图7.12隐式空闲链表 我们称这种结构称为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。 空闲块的组织通过以下的技术进行： 1. 放置已分配的块 当应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大的可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略确定的，一些常见的策略是首次适配、下一次适配和最佳适配。 首次适配从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配从上一次查询结束的地方开始搜索。最佳适配检查每个空闲块，选择适合所需请求大小的最小空闲块。 2. 分割空闲块 一旦分配器找到一个匹配的空闲块，就必须考虑分配这个空闲块中的多少空间。一个选择是用整个空闲块。 但如果匹配不太友好，则分配器通常会选择将这个空闲块分割为两部分。第一部分变成分配块，剩下的部分变成一个新的空闲块。 3. 获取额外的堆内存 如果分配器不能为请求块找到合适的空闲块，一个选择是通过合并那些在内存中物理相邻的空闲块来创建一个更大的空闲块。如果这样还是不能生成一个足够大的块，或者如果空闲块已经最大程度地合并了，那么分配器就会通过调用sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。 4. 合并空闲块 带边界标签的隐式空闲链表分配器允许在常数时间内进行对前面块的合并。是在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。 使用边界标记的堆块的格式如下图： 图7.13使用边界标记的堆块格式 7.10本章小结 本章主要介绍了hello的存储地址空间，Intel的段式管理和页式管理，同时还剖析了四级页表下从虚拟地址到物理地址的变换和三级Cache的支持下物理内存访问，还解析了hello进程fork和execve时的内存映射，同时还包括缺页中断处理程序的进行步骤和动态存储分配管理，页表映射贯穿整章，重要性显而易见。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 一个Liunx文件就是一个m个字节的序列：B0，B1，…，Bm-1。所有的I/O设备都被模型化为文件。 文件的类型： 普通文件包含任意数据。应用程序常常要区分文本文件和二进制文件，文本文件是只含有ASCII或Unicode字符的普通文件；二进制文件是所有其他的文件。对内核而言，文本文件和二进制文件没有区别；目录是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录；套接字是用来与另一个进程进行跨网络通信的文件。 设备管理：unixio接口 所有的输入和输出都被当作对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 8.2.1UnixIO的执行方式 打开文件：应用程序要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记录这个描述符。 Shell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。 改变当前的文件位置。对于每个打开的文件，内核保存着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会触发一个称为EOF的条件，应用程序能检测到这个条件，在文件结尾处并没有明确的“EOF”符号。 关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为相应，内核释放打开文件时创建的数据结构，并将描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 8.2.2UnixIO函数 通过调用open函数来打开一个已存在的文件或者创建一个新文件： intopen(char*filename,intflags,mode_tmode); open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，flags参数也可以是一个或者更多位掩码的或，为写提供一些额外的指示；mode参数指定了新文件的访问权限位； 进程通过调用close函数关闭一个打开的文件： intclose(intfd); 应用程序是通过分别调用read和write函数来执行输入和输出的。 ssize_tread(intfd,void*buf,size_tn); ssize_twrite(intfd,constvoid*buf,size_tn); read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall。字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 va_listarg=(va_list)((char*)(&fmt)+4)初始化变元指针arg，然后printf调用了vsprintf函数，vsprintf函数将printf的参数按照各种各样格式进行分析，将输出的字符串保存于buf中，最终返回要输出的字符串长度，然后保存在i中；最后，printf调用write系统函数，进行输出。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 用户按下键盘后，键盘接口得到一个代表该按键的键盘扫描码，与此同时会产生一个中断请求，运行键盘中断子程序，先从键盘接口取得该按键的扫描码，而后扫描码被转换为ASCII码，保存到键盘的缓冲区当中。 getchar调用read函数，read函数通过sys_call调用内核中的系统函数，将存储在键盘缓冲区中的ASCII码进行读取直到遇到回车符，然后返回整个字符串，，getchar函数只读取第一个字符，其他字符存储到输入缓冲区。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法，还列出了UnixIO的接口和函数，最重要的部分是printf和getchar的分析，这两个函数在调用系统函数下还实现了额外的功能。 结论 预处理，将放置在源文件的预处理指令修改源文件内容，预处理器cpp将hello.c转换为hello.i编译，将高级语言源程序编译为汇编语言程序，编译器ccl将hello.i编译成汇编文件hello.s汇编，将汇编代码转换为计算机能够识别的机器指令，汇编器as将hello.s进行翻译得到可重定位目标文件链接，将可重定位目标文件与标准库进行链接，是程序可以加载到内存中来执行，链接器ld将hello.o与动态链接库链接生成可执行目标文件运行时，父进程通过调用fork创建子进程，通过调用execve在子进程上下文加载新的程序，在进程执行过程中可能会出现一些异常，此时内核会调用处理程序进行相关处理程序加载到内存，CPU通过MMU对虚拟地址进行翻译，再进行数据的读写UnixIO能够实现对输入的处理和进行相对应的输出程序终止，回收子进程 计算机系统的设计与实现真的让我感到不可思议，复杂但每一处的逻辑都紧紧相连，这门课让我对计算机的组成和结构有了大致的了解，其中有很多地方让我印象深刻，如优化程序性能，这是单纯敲写代码也学习体会不到的，高速缓存的实现机制也让我倍感新奇。在完成大作业的过程中，有很多地方也让我收获颇丰，预处理阶段预处理指令的处理、使用edb查看从程序执行到结束的调用子程序的过程。我还有很长的路要走，其中的构建还需探索。 附件 hello.c：C语言源程序 hello.i：hello.c预处理得到的.i文件 hello.s：hello.i经过编译得到的汇编代码.s文件 hello.o：hello.s经过汇编得到的可重定位目标.o文件 hello：hello.o与库函数的链接得到的可执行目标文件 helloo.txt：hello.o的反汇编文件，查看反汇编代码 hello.txt：hello的反汇编文件，查看反汇编代码 helloo.elf：hello.o的elf文件，查看各节的信息 hello.elf：hello的elf文件，查看各节信息 参考文献 [1] 常用预处理指令：https://blog.csdn.net/qq_43630810/article/details/108786500 [2] 程序预处理阶段，在做什么： https://blog.csdn.net/localhostcom/article/details/108165432 [3] AT&T汇编伪指令： https://blog.csdn.net/shisiye15/article/details/7696941?locationNum=4&fps=1 [4] C语言编译过程详解，预处理，编译，汇编，链接： https://blog.csdn.net/wuhuaguo1992/article/details/103400202?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-3.control [5] Shell基础之Bash的基本功能： https://blog.csdn.net/u010456903/article/details/48735969 

程序人生-Hello’sP2P 计算机系统大作业 题 目 程序人生-Hello’sP2P 专 业 计算机 学 号 1190200303 班 级 1936602 学 生 程明明 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文通过简单的hello程序为切入，详细阐述了一个程序如何由源代码通过预处理、编译、汇编、链接等步骤成为可执行程序，同时通过进程管理、存储管理、IO管理等系统机制使得程序能够在操作系统中正确运行的过程。并以此为契机将计算机的各种机制和操作原理结合已经学习的知识正确阐述出来。 关键词：程序人生；计算机系统；预处理；编译；汇编；链接；系统管理；CSAPP （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 由键盘输入，形成hello.c文件。然后将hello.c文件通过预处理、编译、汇编、链接，历经艰辛得到一个可执行目标文件。然后在Shell中通过命令运行该可执行文件，读取到运行的命令行，调用fork函数创建一个新的子进程，再调用execve在内存里开辟空间，将hello文件复制到开辟的空间，运行hello进程，通过IO管理输出，当程序运行结束后，由shell或者init清除空间和痕迹，最终回到程序运行前的状态，就像没有hello来过一样。 1.2环境与工具 硬件环境：Inteli5@2.4GHz，16GBRAM；256GHDDisk 软件环境：Windows1064位，VirtualBox；Ubuntu16.04LTS64位 开发工具：gcc，objdump，gdb，readelf，vim 1.3中间结果 hello.c：老师提供的源文件。 hello.i：预处理后产生的文件，用于查看预处理过程。 hello.s：编译后产生的汇编文件，查看编译过程。 hello.o：汇编产生二进制的可重定位目标文件.o，无法直接查看。 hello：生成的可执行程序。 hello.oelf：通过ELF工具查看hello.o而产生的文件，记录了hello.o的ELF格式。 hello.elf：通过ELF工具查看hello而产生的文件，记录了hello的ELF格式 helloo.txt：hello.o的反汇编文件，用于查看和与汇编前的hello.s进行比较。 hello.txt：hello的反汇编文件，查看链接后的反汇编以及与helloo.txt进行比较查看链接过程。 1.4本章小结 本章概述了hello的P2P与O2O过程，展示了实验的环境和中间结果。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 概念：预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。通常会将#起始的代码对整个代码进行替换与分割处理。 作用：预处理包括是对宏定义、文件包含、条件编译三个方面的处理。会对于宏定义进行替换，对于文件包含，会导入包含的文件与头文件中的内容，而条件编译指令决定编译程序代码处理的范围。最终使得代码更简单直接和完整，便于进一步处理。预处理生成hello.i文件。 2.2在Ubuntu下预处理的命令 命令：gcc-m64-no-pie-fno-PIC-Ehello.c-ohello.i 截图： 2-1.预处理命令 2-2.预处理结果 2.3Hello的预处理结果解析 删去注释。hello.c代码中的预处理指令有三条，预处理器找到这三个头文件的定义文件，然后所有的内容全部到复制到hello.i当中。函数主体部分基本没有变化。 2.4本章小结 通过预处理，将hello.c中三个头文件的内容全部包含在了文件中，将代码的注释部分删除，使得代码文件更简单直接和完整，便于进一步处理。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：通过编译器，将hello.i文件转变成汇编文件。转变过程中，编译器还会分析并优化c代码，最终得到hello.s。 作用：不仅能够将c代码翻译成机器更加容易理解的汇编语言，而且编译的过程中还会对代码进行分析优化，让其有更好的效率。 3.2在Ubuntu下编译的命令 命令：gcc-m64-no-pie-fno-PIC-Shello.i-ohello.s 截图： 3-1.输入的命令 3.3Hello的编译结果解析 常量： 3-2.常量存储 在只读数据rodata段里存储了字符串常量.LC0和.LC1，对应了两个printf函数的内容。而如3，10等数字常量都以立即数的形式存在于汇编代码中。 全局变量： 3-3.全局变量存储 存在一个全局变量sleepsecs，赋值为2.5，可以看出编译器将其从int型的变量优化为long型，进行了隐式的类型转换。sleepsecs被存放在.rotate节中。 局部变量： 3-4.局部变量存储 首先由%rsp开辟了一个栈空间。虽然局部变量i在代码里被首先声明，但是观察汇编文件发现，没有为其开辟空间。仅仅当需要使用i时，转跳至.L2，申请了栈里的空间，暂存在-4（%rbp）中，并且被初始化为0。 赋值： 由于全局变量的赋值直接在处理时在.data节声明，初始化为值为2的long型变量。对于局部变量的赋值使用mov语句完成，找到其存储的栈空间或者寄存器，直接对值使用mov语句。 算术操作： 3-5.循环变量自加一 hello.c仅仅存在加法操作，对于局部变量i在循环后自加1。直接对于i所存储的栈空间的值用addl命令加即可。 逻辑操作： 存在判断是否相等与大小的判断。 3-6.判断是否等于3 判断参数是否等于3，利用cmpl指令即可完成。 3-7.判断是否小于等于9 对于比较大小，也使用cmpl指令。可以发现，<10被编译器优化成了<=9，这样就可以直接使用指令完成比较。 数组与指针操作： 3-8.访问数组 程序中访问了argv数组的元素。数组本质为一串相连的存储空间，所以通过基地址加上偏移量的方式访问数组元素。而argv数组的起始地址-32(%rbp)，通过对%rax寄存器加16来访问argv[2]传递给%rdx，同理%rax寄存器加8来访问argv[1]并传递给%rax，最后将%rdx和%rax寄存器中的值作为参数传递给printf函数来输出。 函数操作： 分别调用了exit函数，printf函数，sleep函数和getchar函数。 3-9.调用exit函数 对于exit函数只有一个参数，于是通过将1赋值给%edi，来传递参数。 3-10.传递参数 该函数实际上系统函数，功能是暂时挂起进程。它以sleepsecs作为参数，将值传递到%eax,然后将%eax的值赋值给第一个参数寄存器%edi，最后通过%edi将值传入sleep使用。 3-11.调用puts函数 第一次的printf函数被优化成了puts函数，直接将.LC0作为参数写入%edi寄存器，然后作为参数传递。 3-12.调用printf函数 第二次printf函数就直接编译为printf函数，参数argv[1]和参数argv[2]被从栈中复制到寄存器%rdx和%rax中，常量字符串地址则保存在寄存器%edi中作为参数传入。 3-13.调用getchar函数 getchar函数的原型是没有参数的，所以它没有参数，因此不会使用到参数寄存器。 3.4本章小结 通过编译器，将hello.i文件转变成汇编文件hello.s。通过对比，能够清晰认识到代码转换的方式及优化。让其有更好的效率和更加适合机器运行。离翻译成二进制机器语言以便机器运行又更近了一步。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：汇编就是把汇编文件hello.s经过处理转化成二进制形式的可重定位目标文件.o，这样机器可以直接识别。 作用：由汇编指令到机器指令，机器可以直接识别。 4.2在Ubuntu下汇编的命令 命令：gcc-m64-no-pie-fno-PIC-chello.s-ohello.o 4-1.输入的命令 4.3可重定位目标elf格式 4-2.ELF文件头 ELF头： 展示了机器和文件的最基本信息。 4-3.ELF节头部表 节头部表： 展示了各个节的大小、类型、地址、偏移量各种信息，方便查找。 4-4.ELF重定位节 重定位节： 这部分描述了需要重定位的信息，这些信息在生成可执行文件时就会被重定位。可以发现在hello.o中需要被重定位的有.radata,puts,exit,printf,sleepsecs,sleep,getchar等。 4-5.ELF符号表 符号表： 记录和列举了程序中用到的函数和全局变量等符号。 4.4Hello.o的结果解析 4-6.反汇编文件 4-7.hello.s汇编文件 通过objdump-d-rhello.o得到hello.o的反汇编，与hello.s进行对比，发现基本相同，但是也存在差异。 首先是操作数的格式，由十进制变为了十六进制补码格式，因为hello.o文件已经是二进制文件形式了。除此之外，在汇编语言中，分支转移的跳转位置都是用.L3,.L4来表示的，但在机器语言中它们被偏移量表示的内存地址所替代。调用函数也不相同，在汇编语言中，函数的调用都是用函数名来跳转的，但在机器语言中它们调用的是一个待重定位的相对地址。 4.5本章小结 分析了hello.o的elf格式，对其结构有进一步认识。除此之外，利用hello.o的反汇编代码展示了二进制机器语言文件的格式和特性。由hello.o与hello.s的对比可以发现从汇编代码到机器语言的过程是完全按照对应的转换关系的。留下了可重定位的标记和地址填充的标记，为链接提供条件。 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：链接器通过符号解析（Symbolresolution）和重定位两个过程，赋予符号表中的符号唯一定义，并将被链接文件中的分散的代码片段组织起来，生成一个完全链接的可执行对象文件的过程。 作用：链将各种代码和数据片段收集并组合成为一个单一文件的过程，让程序能够完整的载入内存并运行。链接使得分离编译成为可能，能够将一个大型的应用程序拆分为较小的模块，而只要修改和编译这些模块，再将其重新就可以完成对整个应用程序的修改，而不必重新编译未修改的文件，大大节约了时间和人力成本。 5.2在Ubuntu下链接的命令 ld-oHello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5-1.输入的命令 5.3可执行目标文件hello的格式 观察可以发现其程序头由13个增加到26个。详细信息如下： 5-2.ELF文件中26个程序头 5.4hello的虚拟地址空间 5-3.EDB界面 地址由0x401000开始，结束于0x401ff0。 5.5链接的重定位过程分析 观察可以发现其节头表由13个增加到26个，多出来的分别为： interp，.note.ABI-tag，.hash，.gnu.hash，.dynsym，.gnu.version，.gnu.version_r，.rela.dyn，.rela.plt，.init，.plt，.plt.sec，fini，.got，.got.plt等。这些都来自于动态共享库，在链接的过程插入到了原来的节当中。 5-4.链接前的ELF文件 5-5.链接后的ELF文件 很明显可以发现hello.o中main函数的地址并没有确定，为0x0000，而在链接之后确定了地址，一些具体函数的调用在hello.o中只是以相对位置于main函数的偏移地址，而在hello中给出了绝对地址。在hello.o需要重定位的信息在hello中已经全部填充，hello是一个完整的文件。 重定位时：先将各个文件合并，然后程序中将需要链接的符号于符号表中进行查找，找到后将其内存地址填充到重定位标记处。 5.6hello的执行流程 5-6.ELF文件 执行过程中的进程分别为： 0x401000<_init>； 0x401020<.plt>； 0x401080<puts@plt>: 0x401090<printf@plt>: 0x4010a0<getchar@plt>: 0x4010b0<exit@plt> 0x4010c0<sleep@plt>: 0x4010d0<_start>: 0x401100<_dl_relocate_static_pie>: 0x401105<main>: 0x401190<__libc_csu_init>: 0x401200<__libc_csu_fini>: 0x0401208<_fini>: 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 5.8本章小结 本章通过对链接前后的程序的ELF格式和反汇编代码的比较，体现了链接前后的区别以及链接的过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：进程是一个执行中程序的实例，它的上下文提供了程序运行所需的状态。 作用：进程为应用程序提供了两个关键抽象，分别是逻辑控制流和私有地址空间。 6.2简述壳Shell-bash的作用与处理流程 Shell是Linux操作系统内核提供给用户的交互程序。它为用户提供了向内核传递命令的窗口。 处理流程：Shell首先获得输入的字符串，通过读入命令行或者文件的内容，结果是得到字符串。对字符串进行解析，通过元字符将其分割为词汇，检查词汇是否为内置命令的关键字，若是内置命令，直接执行。否则认为是程序文件，在当前目录下查找是否有对应的程序文件。若找到，直接建立进程和上下文，加载程序文件，让系统内核运行。程序运行后等待其退出并回收进程。 6.3Hello的fork进程创建过程 父进程调用fork函数，创建一个子进程，子进程具有与父进程虚拟地址空间相同却独立的副本，且具有不同的pid。两个进程的代码、数据段、堆、共享库以及用户栈均相同，所以子进程可以访问父进程的文件。Fork函数调用一次返回两次，在父进程中返回子进程的pid，在子进程中返回0. 当我们在shell中输入./hello1190200303程明明的时候，shell先进行命令解析，判断hello是一个当前目录下的可执行目标文件，通过fork过程创建子进程。 6.4Hello的execve过程 execve函数加载并运行可执行目标文件，函数原型为intexecve(const*filename,constchar*argv[],constchar*envp[])。通过读入可执行文件filename，argv是参数列表，envp是环境变量列表。对当前进程的上下文加载一个进程，直接覆盖了原先利用fork函数创建的进程。并且execve函数只有在调用失败之后才会返回-1，这与fork函数调用一次返回两次是不同的，它调用一次从不返回。 当fork子进程后，调用execve函数，直接覆盖了原先利用fork函数创建的子进程，然后重新创建一组新的代码、数据、堆和栈段。新的堆和栈的段被初始化为0，通过虚拟地址空间中的页映射到可执行文件的页大小的片。新代码被初始化为可执行文件的内容。最后加载器跳转到_start处运行程序。 6.5Hello的进程执行 Shell根据特定算法为所有进程分配时间片，包括hello程序进程。当到了hello程序运行的时间片时，首先加载hello的进程上下文信息，然后从控制从内核转换到hello程序。在hello程序中，我们认为它的进程被抢断发生在sleep发生的时候，调用了sleep(sleepsecs);，休眠了2秒，使得hello时间片结束而将控制返还给内核，此时要保存hello的进程上下文信息，然后根据下一时间片到来时，进程重新执行上述过程，所以程序应该输出十次，但每一次输出中间会出现2秒的间隔。 6-1.运行程序 6.6hello的异常与信号处理 6-2.回车处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 对于回车的异常，完全没有影响，只会改变输出的位置。 6-3.Ctrl-Z处理 Ctrl-Z的异常会导致发送一个SIGSTP信号给shell父进程。信号处理函数将hello进程挂起但并不结束，可使用fg命令可以把被挂起的hello重新调度到前台运行，继续将剩下的步骤运行完。 6-4.Ctrl-C处理 Ctrl-C的异常会发送SIGINT信号给shell父进程，使得将hello进程挂起并结束，此时hello进程已经结束。 6-5.乱按处理 随便乱按，Shell会随时用一个getchar函数监听输入的字符，并且分析读入的字符串，当字符串符合命令，就认为输入了命令然后执行，否则程序正常运行。 6.7本章小结 Shell是Linux用于对用户命令交互的应用程序，对于接收的命令行执行对应的可执行文件或者内置命令。而shell执行程序的方式为先构造要传递给execve函数的字符串组，fork子进程，并设置进程组id，然后调用execve函数，根据传入的字符串组复制可执行程序到内存执行。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：指的是在机器语言中，是为一个偏移地址，是由一个段标识符加上段内相对地址的偏移量，表示为[段标识符：段内偏移量]。在hello的程序里说即是hello.o里面的相对偏移地址。 线性地址：使用逻辑地址与对应的段的基地即可转化为线性地址。在分页机制中线性地址作为输入。 虚拟地址：是CPU寻址假定的内存空间地址，是通过MMU(内存管理单元)使虚拟地址转换为物理地址，仅仅当需要向地址写入内容时才会给对应的地址开辟真正的物理空间。之前看见的均为hello的虚拟内存地址。 物理地址：计算机主存被认为是M个块内存组成的数组，所以每个字节都有一个唯一的地址，而这个地址就是物理地址。对于hello程序来说，就会通过MMU由虚拟地址映射到物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 将程序分为多个段进行管理，通过段表，将段的信息记录下来。而对于逻辑地址可以分为两部分：段标识符和段内偏移量。通过段标识符，在段表之中权匹配查询，在段描述符表中找到一个具体的段描述符，就可以得到基地址，然后再将其与段内偏移量结合，即可得到线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 页映射就是从线性地址到物理地址的映射，是由cpu的页式管理单元负责管理的，可以将线性地址翻译为物理地址。在物理内存中的最小分配单位是帧，页是虚拟内存中最小的分配单位。线性地址的前半部分为页号，对应了虚拟内存的某页，而后半部分是页偏移量，可以在页内查找。而物理内存中还存在一个页表，它存储着虚拟内存页和物理内存帧的对应关系。这样就可以通过页表查询页号来找到对应的物理内存帧，再通过页偏移量，就得到了物理内存的地址。 7.4TLB与四级页表支持下的VA到PA的变换 四级页表指的是虚拟页号被等分为四段，用每段页号依次向下查找，第一级页表中找到相应的第二级页表，以此类推。如此节约了页表的总大小。但是仍然页表是庞大的，所以建立了一个缓存称为TLB，查询过的页表项会存入TLB中，当下一次查询就可以直接查询而不需要通过页表，大大节约了时间。 7.5三级Cache支持下的物理内存访问 在三级cache下，将物理地址分成CT（标记）+CI（索引）+CO（偏移量），首先在先通过索引去寻找到对应的组，然后在组内去匹配标记，当匹配上是看有效位是否有效，然后通过偏移量读取数据。如果在一级cache未命中，则到二级cache中去匹配，若仍然不命中则到三级cache访问。 7.6hello进程fork时的内存映射 Shell调用fork来生成子进程时，内核为hello进程创建了对应代码、数据、堆和栈段并且给了唯一的PID。而为了hello进程创建好虚拟内存，就需要将原本的页表 它创建了hello进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 首先，execve会删除当前进程的虚拟内存的内容；其次，要为新程序的代码、数据.bss和栈区创建内存区域，分别将已经初始化的数据映射到.data节,代码映射到.text节，未初始化的数据映射到.bss。然后请求栈空间。除此之外，将共享库链接后，映射到共享库的内存映射区域。 7.8缺页故障与缺页中断处理 当CPU发送一个虚拟地址传递给MMU，但是MMU通过查看TLB与PTE发现对应的物理地址不在内存中，而必须从磁盘中取出到内存，这就是缺页故障。缺页的对应处理程序会在内存里确定牺牲页，需要判断该页面是否被修改。若被修改就需要将修改后的内容写入磁盘。然后通过调入之前请求的页到物理内存去覆盖掉牺牲页，并且更新PTE，添加一条对应记录。最后将控制返回给引起故障的指令，让其重新执行调用该页的指令，再发送虚拟地址给MMU就不会引起缺页故障了。 7.9动态存储分配管理 通过一个动态内存分配器来维护进程的某一块虚拟内存区域，这一块区域被称为堆。位于未初始化的数据区域（.bss节）后开始，并向高的地址生长。对于进程，内核利用一个变量brk指针，它指向堆顶。堆被动态分配器视为块的集合，每一个块就是一个连续的虚拟内存片(chunk),保留为供应用程序使用，而块分为已分配和空闲两种状态。 空闲块是可用来来分配的。而分配器分为显式和隐式，显式的分配方法，块只有在应用要求释放时才能得到释放的，而隐式则会自动释放不使用的块，称为垃圾收集。 空闲的块由称为空闲链表的数据结构记录，它也有显式和隐式之分。0而malloc就是显式的分配方法。 7.10本章小结 本章主要解释了hello程序运行时，对于存储空间的分配操作和过程。对于各种地址的变换和翻译有了一定程度的解释。讲诉了存储器各级间的关系和相互间调用的操作。让我们对于hello程序的存储和在存储器上的调用有了更深的理解。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixi/o接口。将所有输入输出设备视为文件后，所有的输入与输出都被看成了读写文件，使得所有设备的输入输出具有统一的格式和执行方式，方便管理与使用。而从Linux的内核引出的一个简单的应用接口，称之为unixI/O接口。 8.2简述UnixIO接口及其函数 1.open()函数： 功能描述：用于打开或创建文件，在打开或创建文件时可以指定文件的属性及用户的权限等各种参数。 函数原型：intopen(constchar*pathname,intflags,intperms) 参数：pathname:被打开的文件名，flags:文件打开方式。 返回值：成功则返回文件描述符；失败则返回-1。 2.close()函数： 功能描述：用于关闭一个被打开的的文件。 所需头文件：#include<unistd.h> 函数原型：intclose(intfd) 参数：fd：文件描述符。 返回值：成功返回0，出错返回-1。 3.read()函数： 功能描述：从文件读取数据。 所需头文件：#include<unistd.h> 函数原型：ssize_tread(intfd,void*buf,size_tcount); 参数：fd：文件描述符；buf：读取的数据存放的缓冲区地址；count：一次read操作读取的字符数量。 返回值：读取成功返回所读取的字节数；读到EOF返回0；出错返回-1。 4.write()函数： 功能描述：向文件写入数据。 所需头文件：#include<unistd.h> 函数原型：ssize_twrite(intfd,void*buf,size_tcount); 参数：fd：文件描述符；buf：写入的数据所在的缓冲区地址；count：一次write操作写入的字符数量。 返回值：写入成功则返回写入的字节数；出错返回-1。 5.lseek()函数： 功能描述：用于在指定的文件描述符中将将文件指针定位到相应位置。 所需头文件：#include<unistd.h>，#include<sys/types.h> 函数原型：off_tlseek(intfd,off_toffset,intwhence); 参数：fd：文件描述符；offset:偏移量，每一个读写操作需要移动的字节数，向前移为正，向后移为负。 返回值：成功就返回当前位移量；失败则返回-1。 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 Getchar函数原型里调用了read函数，它从缓冲区将buf的大小读满，当方生异常时再监听键盘输入读取缓冲区，读取时获得读入的字节数，如果大于0则返回缓冲区第一个字节，否则返回eof。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章解释了unix系统的io管理，解析了io接口的相关函数，并且通过分析printf和getchar两个函数的具体实现来展示了i/o的过程。 （第8章1分） 结论 程序由源代码通过预处理、编译、汇编、链接等步骤成为可执行程序，在执行过程中通过进程管理、存储管理、IO管理等一系列的系统控制机制，使得程序能够由硬盘上的文件到内存中的进程，最后成功通过IO设备展示出结果。详细解释了hello程序的“P2P”（FromProgramtoProcess）和“O2O”（FromZero-0toZero-0）过程，深刻理解了程序的“一生”。 通过对hello程序的分析，成功地回忆和加深了对计算机系统所学的知识的理解。更重要的是，能够通过hello的“一生”将各个章节的知识联系起来，让我们对计算机系统有了一个全面的认识。 学习计算机系统后，对计算机的整个运行逻辑和机制有了清晰的认识。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.c：老师提供的源文件。 hello.i：预处理后产生的文件，用于查看预处理过程。 hello.s：编译后产生的汇编文件，查看编译过程。 hello.o：汇编产生二进制的可重定位目标文件.o，无法直接查看。 hello：生成的可执行程序。 hello.oelf：通过ELF工具查看hello.o而产生的文件，记录了hello.o的ELF格式。 hello.elf：通过ELF工具查看hello而产生的文件，记录了hello的ELF格式 helloo.txt：hello.o的反汇编文件，用于查看和与汇编前的hello.s进行比较。 hello.txt：hello的反汇编文件，查看链接后的反汇编以及与helloo.txt进行比较查看链接过程。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 

32位Ubuntu系统share文件夹消失问题的解决 用的是VMware虚拟机，经常在Ubuntu重启后share共享文件夹消失。 输入如下代码： sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000 即可解决。好耶！ 

程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机类 学 号 1190200407 班 级 1936602 学 生 林棋珺 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文以hello程序的编译过程再到执行过程作为引子，展示了机器执行程序的全过程以及在此期间机器内部的维持运转、各个部位的工作。 包括了hello程序的预处理、编译、汇编再到链接的过程，以及运行时hello的进程管理、存储管理和IO管理，通过提出概念并以hello作为例子详细刨析。 关键词：预处理、编译、汇编语言、机器语言、可重定位目标文件ELF格式、链接、重定位、动态链接、shell、进程、Cache、页表、TLB； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 P2P（FromProgramtoProcess）：指的是hello.c经过预处理、编译、汇编、链接后得到一个可执行程序hello O2O（FromZero-0toZero-0）： 一开始0 输入./hello学号姓名 Shell调用fork()申请子进程 子进程调用execve传入argc,argv,environ（参数和环境变量） 映射虚拟内存，载入物理内存 执行hello 运行结束后，Shell接受子进程信号回收 内核删除子进程 回到了0 1.2环境与工具 硬件环境：lntel(R)Core(TM)i7-8750HCPU@2.20GHz2.21GHz；8GBRAM 软件环境：Windows1064位，Vmware14；Ubuntu18.04LTS64位 开发工具：gcc+gedit,Codeblocks,edb，objdump，readelf 1.3中间结果 hello.i预处理后的文件 hello.s汇编语言文件 hello.o可重定位目标文件 hello可执行文件 1.4本章小结 这一章是hello的程序人生的开始，了解helloP2P和O2O的过程，让我们重回初恋，了解更多关于hello的一切。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 预处理是在源代码编译之前所做的修改源码的操作 主要的行为是删去#注释的代码，不同的注释作用如下： *将源文件中以“#include”格式包含的文件复制到编译的源文件中。 *用实际值替换用“#define”定义的字符串。 *根据“#if”后面的条件决定需要编译的代码。   此外删除了其他//和/**/的注释 2.2在Ubuntu下预处理的命令 输入该命令调用gcc预处理 图2-2预处理命令 2.3Hello的预处理结果解析 图2-3hello.i内容（未截全） 上面是hello.i最后的内容，因为内容过多所以直接了最后和hello.c的主函数一样的部分，可以看见main函数基本没有变化，说明预处理时还没有编译。 这里可以看到预处理的作用之一就是把头文件转换成源代码。 同时也有修改宏定义和条件编译的作用 2.4本章小结 每次写代码都会写的头文件，不知道有什么意义，现在终于明白了。 宏定义，拓展和条件编译，所有的#注释///**/注释都要删掉，才能让程序编程机器能懂的语言。 没想到短短的hello程序居然也可以包含如此多的内容，但是头文件的代码都是曾经的程序员一点一滴积累的，只有前人不断地开发，今后的代码才能越来越简练。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译是指预处理后的文件到生成汇编语言程序的过程，将文件hello.i转换成hello.s，获得一个汇编语言文件 编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。 3.2在Ubuntu下编译的命令 图3-2编译命令 3.3Hello的编译结果解析 图3-3hello.s文件 3.3.1数据 hello.s里出现的数据如下： 由图3-3-1-1可以看见main函数给自己的栈帧申请了32个字节 并将argc存在%rbp-20中（sizeof（argc）=4） argv的数组指针为%rbp-32，通过偏移可得： argv[1]地址为argv+8(%rbp-24) argv[2]地址为argv+16(%rbp-16) （sizeof（argv）=8） argc和argv是main函数带入的参数，也是调用hello命令时输入的 图3-3-1-1数据argc和argv 全局变量sleepsecs放在.data节中 sizeof(sleepsecs)=4 图3-3-1-2数据sleepsecs printf的两个表达式（LC）,放在.rodata节中 图3-3-1-3表达式 由这几句可以看出局部变量i存放在(%rbp)-4中 sizeof(i)=4 图3-3-1-3变量i 3.3.2 操作 3.3.2.1 赋值操作 用movl语句给寄存器i赋值 图3-3-2-1赋值操作 3.3.2.2 算术操作 用addl语句执行i++ 图3-3-2-2算术操作 3.3.2.3 关系操作 程序带有4个标志位，ZF，OF，SF，CF 在执行cmpl时会改变，然后根据这4个标志位的情况可以决定j**和cmov**是否执行，从而产生分支 例如判断（argc！=3）和（i<10) 图3-3-2-3关系操作 3.3.2.4 算术操作 main在.text节中，声明为全局变量和函数类型 图3-3-2-4-1函数操作-main 其余函数都是用call函数调用，一般传入的参数会放进%rdi,%rsi,%rdx,%rcx,%r8,%r9（按顺序优先）或栈中（前面的寄存器占用后），返回值一般放进%rax中 printf把表达式放入%rdi中 图3-3-2-4-2函数操作-printf 把参数放入%rdi中后调用sleep 图3-3-2-4-3函数操作-sleep 图3-3-2-4-4函数操作-getchar 图3-3-2-4-5函数操作-put 图3-3-2-4-6函数操作-exit 3.3.3 控制转移 图3-3-3for语句 通过上面提到的关系操作，判断i<=9的条件，满足就返回.L4（循环块） 3.4本章小结 麻雀虽小五脏俱全，小小的hello.s却包含了各种数据类型和各种操作 但是分析其中的结构和实现过程对我们了解汇编语言至关重要 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编是编译后的文件转换至机器语言二进制程序的过程。将文件hello.s转换成hello.o，获得一个可重定位目标文件。 4.2在Ubuntu下汇编的命令 图4-2汇编命令 4.3可重定位目标elf格式 图4-3elf格式 4.3.1 ELF头 命令输入readelf-hhello.o，得到elf头，存放整个程序的基本信息 包括机器类型；操作系统版本；节头部表的开始位置、大小；文件大小等等 图4-3-1ELF头 4.3.2 节头表 命令输入readelf-Shello.o，得到文件（图4-3elf格式中所述）各个节的信息(包括名称、类型、地址、偏移量、大小、全体大小、旗标、链接、信息、对齐） 图4-3-2节头表 4.3.3 symtab 输入命令readelf-shello.o，得到符号表（程序中所有函数名和有全局或者static属性的变量名） 对于每一个条目的不同属性的说明: Value:偏移量 Size:大小（字节数） Type:类型 Bind:绑定属性 是全局符号还是本地（局部）符号 Ndx:节索引 Vis: Name:符号名称 图4-3-3符号表 4.3.4 重定位条目 上文提到的偏移量会在此处加以叙述。 重定位就是将符号定义和符号引用进行连接的过程，通过偏移量计算它们运行时所处的内存地址。这一步需要依赖hello.o中的重定位条目 输入命令readelf-rhello.o，得到重定位节 偏移量 指向需要进行重定位操作的位置。信息指定必须对其进行重定位的符号表索引以及要应用的重定位类型。加数指定常量加数，用于计算存储在可重定位字段中的值。 图4-3-4可重定位节 4.4Hello.o的结果解析 图4-4hello.o的反汇编 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 4.4.1 机器语言的构成 1、单字节指令 操作码本身就隐含了操作数的信息，不需再加操作数。如retq,leaveq等 2、双字节指令 首字节为操作码，第二个字节为操作数或操作数地址。如callq，push等 3、三字节指令 首字节为操作码，后两个字节为操作数或操作数地址。如addl，mov，cmpl等等 与汇编语言的映射关系：操作码对应一个字节，根据操作码的不同，操作码后面会添加操作数或者操作数地址等等组成一个完整的指令 不同：汇编语言中用的是十进制，而机器语言（反汇编语言）用的是十六进制；汇编语言中跳转和调用函数用的是自定义段或者函数名字，而机器语言（反汇编语言）用的是相对寻址的方法（跳转到对应的rip） 4.5本章小结 程序转成了可重定位目标文件，已经是机器语言了，只差最后一步就可以执行了。 这一章节我们学习到了elf头和机器语言两大部分，都是链接后成为可执行文件的基础。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接过程将多个可重定位目标文件合并以生成可执行目标文件。 作用： -模块化 一个程序可以分成很多源程序文件； 可构建公共函数库，如数学库，标准C库等。以便代码重用，提高开发效率。 -效率高 时间上，可分开编译：只需要重新编译修改的源程序文件，然后重新链接； 空间上，无需包含共享库所有代码：源文件中无需包含共享库函数的源码，只要直接调用即可（如，只要直接调用printf()函数，无需包含其源码），另外，可执行文件和运行时的内存中只需包含所调用函数的代码，而不需要包含整个共享库。 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 图5-3-1ELF头 图5-3-2节头表 5.4hello的虚拟地址空间 图5-3-3edb中的.init段 图5-3-4edb中的.text段 对照elf头的位置和偏移亮可以看到，readelf中所有节的地址位置是和edb中显示的一一对应的 5.5链接的重定位过程分析 objdump-d-rhello运行结果如下： 可以看到hello比起hello.o，多了很多函数的代码，是在链接时引用的 并且在跳转和调用函数时，用的是绝对寻址，说明重定位完成，数据和代码都放进了地址空间中。 图5-5hello的反汇编代码 hello的重定位过程 1.合并相同的节（数据节和代码节） 2.确定「定义符号」在虚拟空间的绝对地址 3.用上述「定义符号」的绝对地址修改.text和.data节中「引用符号」的地址 5.6hello的执行流程 图5-6hello各函数地址 0x400520 hello!_start ->0x400607 main ->0x4004d0 hello!puts@plt ->0x400500 hello!exit@plt ->0x4004e0 hello!printf@plt ->0x400510 hello!sleep@plt ->0x4004f0 hello!getchar@plt ->0x400704 hello!_fini 5.7Hello的动态链接分析 hello程序的动态链接项目:global_offset表 图5-7-1运行dl_init前的GOT表 图5-7-2运行dl_init后的GOT表 执行了dl_init后的globaloffset表内的数据都发生了变化。 5.8本章小结 至此，我们的程序hello完成了P2P 只有一个函数只有一段代码是无法完成hello的全部工作的 需要与依赖的函数链接，将函数重定位，找到每个符号在虚拟空间中的绝对地址，才能真正执行hello （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是具有以下特征的活动单元：一组指令序列的执行，一个当前状态和相关的系统资源集计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 作用：进程提供一个假象，好像我们的程序是在独占使用处理器和内存。 6.2简述壳Shell-bash的作用与处理流程 shell是一个用户跟操作系统之间交互的命令解释器，可以合并编程语言以控制进程和文件，以及启动和控制其他程序。 处理流程： -输入的命令行 -将命令用空格分开 -判断是否为内置命令，如果是那就执行内部函数 -调用fork和execve函数来运行程序 6.3Hello的fork进程创建过程 Shell解析命令，调用fork函数获得一个进程 获得命令输入的参数argvargc，构造envp。 子进程自己创建一个进程组，并把父进程的信息私有的写时复制下来，这样调用hello时就不会影响到shell进程。 子进程调用execve函数进入hello的代码。 6.4Hello的execve过程 execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp。如果没有出现错误，execve正常加载运行hello，调用后就不会返回。 *删除已存在的用户区域：删除当前进程的虚拟地址的用户部分中的已存在的区域结构 *映射私有区域：为hello的代码、数据、bss和栈区域创建新的数据结构。私有的、写时复制。 *映射共享区域：将hello与共享对象动态链接，再映射到用户虚拟地址空间中的共享区域内 *设置程序计数器(PC)设置hello上下文中的程序计数器 6.5Hello的进程执行 （以下格式自行编排，编辑时删除） 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 6.5.1 进程上下文 操作系统内核使用一种成为上下文切换的较高层形式的异常控制流来实现多任务： 内核为每一个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态。 6.5.2 进程时间片 是操作系统分配给每个正在运行的进程的一段CPU时间 由操作系统内核的调度程序分配给每个进程。 6.5.3 进程调度的过程 刚开始控制在hello进程中，hello调用sleep函数时，会将控制权转交给内核进程，内核保存hello的上下文后，在sleep的时间片内执行进入进程的上下文将控制传递给该进程，此时可以接受来自键盘的信息，当sleep的时间片结束后，控制转移回hello保存的上下文，控制传递给hello。 6.5.4 用户态与核心态转换 可以通过中断，陷阱，故障，终止等异常情况，程序会从用户态转换到内核态，内核保存进程的上下文，恢复下一个进程的上下文来重新启动该进程，控制转交给进程，从核心态转换到用户态 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 6.6.1 可能出现的异常和信号 中断：ctrl+z会发送SIGTSTP信号->进程中断，切换至别的进程 终止：Ctrl+C会发送SIGINT信号->终止回收进程 hello可能会接受其他进程调用kill发送的信号 6.6.2 可能出现的情况 6-6-2-1正常情况 胡乱按键盘对进程没有影响 6-6-2-2胡乱按键盘 6-6-2-3Ctrl+C 按下Ctrl+Z后会发送SIGTSTP信号停止hello进程，此时可以输入其他指定 6-6-2-4Ctrl+Z+（ps，pstree，jobs） 在中断时可以用kill发送信号（上图为SIGKILL，下图为SIGCONT） 6-6-2-4Ctrl+Z+kill 6.7本章小结 进程是重要的概念。可以说我们能看到程序的运行靠的就是进程，了解进程利用进程也是十分重要的一项技能。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：在机器语言中用来确定一个指令或者是操作数的地址。逻辑地址包含段和偏移量，而偏移量是相对偏移，而段则确定了偏移开始的地方，这样就能通过段和偏移来确定地址。在hello中指hello.o中的相对偏移地址 线性地址：逻辑地址与物理地址之间的桥梁。用偏移加上段的地址就能得到线性地址，也就是虚拟内存地址。在hello中指hello中的虚拟内存地址 虚拟地址：虚拟地址和线性地址一样。 物理地址：加载到内存地址寄存器中的地址，内存单元的真正地址。hello的虚拟地址通过地址翻译器可转换成物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址由段地址和偏移地址组成。 计算机中共有4个段寄存器，用于存放数据、代码、堆栈、辅助4段的基地址，段选择符共计16位，前13位为索引位，用于确定段描述符在描述符表中的位置。 第14位为Tl位，Tl=0时选择全局描述符表，Tl=1时选择局部描述符表。 最后两位用于描述段的状态 被选中的描述符先被送至描述符Cache，每次从描述符Cache中取32位基地址，与32位段内偏移量（有效地址）相加得到线性地址 7.3Hello的线性地址到物理地址的变换-页式管理 Linux的线性地址到物理地址的转换，是通过页式管理完成的。一组固定长度的线性地址的集合被称为页面，一般来说页面有4KB大小。 线性地址的后12位是页内偏移（VPO） 前面36位是虚拟页号（VPN），通过VPN可以找到相应的物理地址所在的页，如果有多级页表，VPN将会被分成多份。第i个VPN作为第i级页表的索引指向第i+1级页表的基址。最后一级页表中的PTE包含每个物理页面的页号（PPN） 转换的具体过程如下： 1、CPU产生一个虚拟地址，将虚拟地址传递给主存 2、MMU从TLB中取出相应的PTE，通过PTE找出VPN对应的物理页号 3、与页内偏移量结合构成物理地址 7.4TLB与四级页表支持下的VA到PA的变换 TLB称为翻译后备缓冲器，是关于PTE的高速缓存。 如果TLB有T=2^t组，那么TLB索引（TLBI）是由VPN的最低t位组成，而TLB标记（TLBT）是由VPN剩余的位组成的 将VA的后12位作为VPO，前36位作为VPN MMU会先从TLB中寻找PTE，根据索引找到对应的组，如果组内存在标记相同切有效为为1的pte那么获得pte中的ppn。 如果没找到，内核就会通过内存和cache寻找。 将32位的vpn分为4个9位的vpn（1，2，3，4） 通过一个固定寄存器中的值获得以及页表的基地址，然后由vpn1作为索引找到第二级页表的基址，然后由vpn2作为索引，以此类推，直到vpn4指向的就是对应的ppn的值。 最后将ppn和VPO合成得到PA 7.5三级Cache支持下的物理内存访问 Cache的工作原理：内核通过内存地址的组索引找到对应的组。找到组内标记相同且有效位为1的块，返回块内的值。如果没有找到就是不命中，就需要从下一级cache中寻找，或者是内存（如果在第三级cache中不命中）。 找到数据后会对不命中的cache进行替换，放置在组内的空闲块或者驱逐最久没被使用的有效块（如果组内已满） 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。内核将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同，当这两个进程中的任一个后来进行写操作时，写时复制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 *删除已存在的用户区域：删除当前进程的虚拟地址的用户部分中的已存在的区域结构 *映射私有区域：为hello的代码、数据、bss和栈区域创建新的数据结构。私有的、写时复制。 *映射共享区域：将hello与共享对象动态链接，再映射到用户虚拟地址空间中的共享区域内 *设置程序计数器(PC)设置hello上下文中的程序计数器 7.8缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。 当发生缺页中断时，操作系统会调用缺页处理子程序。 程序会先判断虚拟地址A是否合法（否则出现段错误：访问一个不存在的页面），然后判断试图进行的内存访问是否合法（否则发生保护异常：例如，违反许可，写一个只读的页面）。 如果内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的，就会选择一个牺牲页面，如果这个页面被修改过，那么就将该页交换出去，换入新的页面并更新页表。然后返回程序中断处的当前指令，再次发送A到MMU，这次就可以正常翻译了。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。 分配器将堆视为一组大小不同的块的集合进行维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。 已分配的块显式地保留为供应用程序使用，空闲块可以用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已经分配的块保持已分配状态直到它被释放，释放要么由应用程序显式执行，要么由内存分配器隐式执行。 malloc函数为显式分配器，可以从堆中申请一块内存并返回指向该块的指针。 隐式空闲链表： 块的结构为头部：块大小+标志位（a已分配/f空闲）、（有效载荷+填充）和尾部（等于头部），通过头部存储的值将所有块连接起来。 显式空闲链表： 空闲块的结构为头部：块大小+标志位（a已分配/f空闲）、前驱指针、后继指针和尾部（等于头部），通过前后指针将空闲块用链表串联起来。 不同的空闲块会根据大小分类串到不同的链表中 分配: 首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。 下一次适配：每一次都从上一次搜索结束的地方开始搜索，选择第一个合适的空闲块。 最佳适配：对堆进行全面搜索，找到最合适的块。 增加堆的空间： 通过调用sbrk函数，申请额外的存储器空间，插入到空闲链表中。 合并空闲块：当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻，造成假碎片现象。即相邻的块被切割成了小块而无法使用。因此，合并空闲块的目的即为消除假碎片现象，提升内存利用率。 策略： 1、立即合并：释放完内存就合并 2、推迟合并：直到发生某种情况需要合并时再合并 7.10本章小结 所有的进程都需要调用内存，hello也不例外，然而hello自认为调用所有内存工作，实际上只是内存的“替身”罢了。 了解虚拟内存的工作原理，以及高速缓存、缺页异常和动态分配等等，揭开内存的真面目，才能再今后的计算机工作以应万变。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 一个linux文件就是一个m个字节的序列： B0,B1,…,Bk,…,Bm-1 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 UnixIO接口： 打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，作为描述符，它会在对文件所有操作中标识这个文件。 Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1），标准错误（描述符为2）。头文件定义了常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，它们可用来代替显式的描述符值。 改变当前的文件位置：内核保持这一个文件位置k，初始为0。文件位置是从文件开头起始的字节偏移量，应用程序能够通过seek操作，显式地设置文件的当前位置。 读写文件：一个读操作是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。（当k>=m时执行读操作会触发EOF条件，m为文件字节大小）写操作是从内存复制n>0个字节到文件，从当前文件位置开始，然后更新k。 关闭文件：当应用完成对文件的访问之后，通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 函数： open()： 函数原型：intopen（char*filename,intflags,mode_tmode） open函数将filename转换为一个文件描述符，并且返回描述符数字。若出错返回-1，否则返回新文件描述符，返回的描述符总是在进程中当前没有打开的最小描述符。flags指明进程打算如何访问文件： O_RDONLY:只读 O_WRONLY:只写 O_RDWR:可读可写 flags也可以是一个或更多位掩码的或，提供额外的指示： O_CREATE：文件不存在则创建 O_TRUNC：文件存在则截断 O_APPEND：写操作时设置到文件的结尾处 mode参数制定了新文件的访问权限位 close()：关闭一个打开的文件，若成功返回0，出错时返回-1 函数原型：intclose（intfd） 参数：fd文件描述符 read()：read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf，返回值-1表示一个错误，返回值为0表示EOF，否则，返回值表示的是实际传送的字节数量 函数原型：ssize_tread(intfd,void*buf,size_tn) 其中fd为文件描述符，buf缓冲区，n为传送字节数 write()：write函数从内存位置buf复制最多n个字节到描述符为fd的当前文件位置，返回值-1表示错误，否则，返回值表示写的字节数量 函数原型：ssize_twrite(intfd,constvoid*buf,size_tn) 其中fd为文件描述符，buf缓冲区，n为传送字节数 lseek：显式地修改当前文件的位置 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 机器的工作是在纷繁复杂的二进制码中计算和运转，但是在显示屏上显示的，在键盘上输入的，却是人类能懂的语言文字，这就要归功于计算机功能完备的IO系统。 实际上所有输入输出设备都被模型化为文件，在UnixI/O接口中完成用户和机器的沟通，可谓十分的巧妙。 （第8章1分） 结论 hello.c 预处理->hello.i预处理后的文件 编译->hello.s汇编语言文件 汇编->hello.o可重定位目标文件 链接->hello可执行文件 通过深入理解计算机系统，我对于该如何编写对编译器友好的代码，优化程序的性能有了更多的想法。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.c：hello源代码 hello.i：预处理后的文本文件 hello.s：编译后的汇编文件 hello.o：汇编后的可重定位目标文件 hello：链接后的可执行文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 https://blog.csdn.net/dlutbrucezhang/article/details/8753765https://blog.csdn.net/zycdeCSDN/article/details/102084045https://www.jianshu.com/p/b7e44f749211https://www.jianshu.com/p/3e3218ef0bcfhttps://www.cnblogs.com/pianist/p/3315801.html （参考文献0分，缺失-1分） 

Hello,CSDN Hey,thisismyfirstblogfortesting!Hello,CSDN! 

哈工大计算机系统大作业程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号1190200410班 级1936602学生何纪辉 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文通过借助相关工具对hello.c程序的预处理、编译、汇编、链接等过程进行分析，了解一个程序是如何从开始到结束的。 关键词：预处理；编译；汇编；链接；目录 第1章概述-4-1.1HELLO简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在UBUNTU下预处理的命令-5-2.3HELLO的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在UBUNTU下编译的命令-6-3.3HELLO的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在UBUNTU下汇编的命令-7-4.3可重定位目标ELF格式-7-4.4HELLO.O的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在UBUNTU下链接的命令-8-5.3可执行目标文件HELLO的格式-8-5.4HELLO的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6HELLO的执行流程-8-5.7HELLO的动态链接分析-8-5.8本章小结-9-第6章HELLO进程管理-10-6.1进程的概念与作用-10-6.2简述壳SHELL-BASH的作用与处理流程-10-6.3HELLO的FORK进程创建过程-10-6.4HELLO的EXECVE过程-10-6.5HELLO的进程执行-10-6.6HELLO的异常与信号处理-10-6.7本章小结-10-第7章HELLO的存储管理-11-7.1HELLO的存储器地址空间-11-7.2INTEL逻辑地址到线性地址的变换-段式管理-11-7.3HELLO的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级CACHE支持下的物理内存访问-11-7.6HELLO进程FORK时的内存映射-11-7.7HELLO进程EXECVE时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章HELLO的IO管理-13-8.1LINUX的IO设备管理方法-13-8.2简述UNIXIO接口及其函数-13-8.3PRINTF的实现分析-13-8.4GETCHAR的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。P2P：高级语言编写得到.c文件，经过预处理得到.i文件，再编译得到.s文件，然后汇编器as将.s文件转化为可重定位目标程序，最后由链接器ld将其变为可执行的目标程序。在shell中运行，OS会通过fork为其创建一个新的进程。020：操作系统调用execve后映射虚拟内存，并依据需求载入物理内存再进入main函数执行代码。执行完成后，父进程回收hello进程内核删除相关数据结构。1.2环境与工具硬件环境：Intel®Core™i5-8265UCPU@1.60GHz1.80GHz8GRAM软件环境：Windows10家庭中文版&VMware+Ubuntu18.04.564位开发与调试工具：Devc++，CodeBlocks，objdump，gdb，edb1.3中间结果hello.i预处理后的文件hello.s编译生成的汇编文件hello.o汇编生成的可重定位文件hello链接后生成的hello的可执行目标程序1.4本章小结本章主要是对整篇文章一个简介，简单介绍了P2P，020以及实验环境和实验过程中生成的中间文件。 （第1章0.5分） 第2章预处理2.1预处理的概念与作用概念预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。典型地，由预处理器(preprocessor)对程序源代码文本进行处理，得到的结果再由编译器核心进一步编译。这个过程并不对程序的源代码进行解析，但它把源代码分割或处理成为特定的单位。通常前几个阶段由预处理器实现。作用作用：1）处理文件包含：对于C源程序中的#include指令，如#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它们直接插入到程序文本中。2）处理宏定义：对于#define指令，进行宏替换，用所定义的实际值去替换代表它的符号。3）处理注释：删除C源程序中的注释内容。4）处理条件编译：根据条件编译指令（如#if、#elif、#else等），按条件选择符合的代码送至编译器编译，从而有选择地执行相应操作。2.2在Ubuntu下预处理的命令cpphello.c>hello.i2.3Hello的预处理结果解析代码量大幅增加，文件开头加入大量头文件内容，最初的代码被放在了文件末尾。可以看到stdio.hunistd.hstdlib.h被从系统中读取并展开插入到程序文本中。cpp到默认的环境变量下搜索stdio.h头文件，打开/usr/include/stdio.h，发现其中仍有#include指令，于是再去搜索包含的头文件，直到最后的文件中没有#include指令，并把所有文件中的所有#define和#ifdef指令进行处理，执行宏替换和通过条件确定是否处理定义的指令。2.4本章小结本届主要介绍预处理概念及其作用，并结合hello.c预处理后得到的hello.i进行分析。（第2章0.5分） 3.1编译的概念与作用概念：通过词法分析，语法分析语义分析等方法把代码转化为汇编指令的过程。编译的作用编译器做一些语法分析、词法分析、语义分析等，若检查无错误，便将高级程序设计语言（C语言）书写的程序转变为与其等价的汇编语言程序（依据优化程度的不同可能会对代码进行优化）。汇编语言是介于高级语言和机器语言之间的中间代码，它为不同高级语言的不同编译器提供了通用的输出语言，使他们产生的输出文件都是用的一样的输出语言。3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s3.3Hello的编译结果解析.file：源文件名.text:代码段.global:全局变量.data:数据段.align:对齐方式.type:指定类型是对象类型或者函数类型.size:大小.long：长整型.section.rodata:rodata节（只读数据节）.string:字符串 1.常量： 常量均以立即数形式出现 2.变量（1）全局变量sleepsecssleepsecs是global的，类型为对象，占据4个字节保存在.rodata节（2）main函数参数argc被%edi保存，并储存在-20(%rbp)（3）循环变量i被赋初值为0并且每次循环+1保存在-4(%rbp)（4）argv作为第二个参数被从%rsi保存到-32(%rbp)3.类型转换可以看到对sleepsecs的赋值中把浮点强转为了int而在汇编中，sleepsecs被定义为long类型数值为2。4.赋值movl指令对循环变量i赋初值0对全局变量sleepsecs赋初值25.算术操作1.addl指令这里是对循环变量进行加1操作2.leaq指令分别是计算了.LC0和.LC1的段地址并与(%rip)相加之后传递给%rdi6.关系操作表达式argc!=3i<101)argc!=3框内语句为执行if语句时的判断部分2)框内语句为执行循环时的判断部分7.控制转移1）红框为执行的if语句，如果arc==3则执行L2中语句即第二个黑框的代码，反之则执行第一个黑框的代码。2）这部分为for循环语句，黑框L2语句为循环变量i赋初值并跳到L3部分，L3红框部分为循环的判断部分，如果判断条件成立则进入循环体L4执行，每次循环完给循环变量+1并再次进入L3红框部分判断。知道判断条件不成立跳出循环。8.函数操作1.main函数参数传递:argv和argc函数调用：系统调用函数返回：返回0将%eax赋值为0并返回2.printf函数参数传递：callputs时只传入了字符串参数首地址；for循环中callprintf时传入了argv[1]和argc[2]的地址。函数调用：前者是if语句条件满足时执行，后者是在每次循环时被调用3.exit函数参数传递：传入参数1，执行退出命令函数调用：满足if语句时执行4.sleep函数：参数传递：传入参数sleepsecs，传递控制：callsleep函数调用：for循环下被调用5.getchar函数传递控制：callgetchar函数调用：在main中被调用3.4本章小结了解了预处理文件经过编译得到的.s（汇编代码）文件具体内容，对其从常、变量，操作控制函数等方面解析。对代码执行时内部寄存器操作有一定了解。虽然相较高级语言较复杂，但是是了解底层必须了解的。并且有一个初步结论，语言越低级，对机器越友好，语言越高级对程序员越友好。（第3章2分） 第4章汇编4.1汇编的概念与作用概念:汇编器（as）将汇编语言程序翻译成等价的机器指令的过程，并将这些指令打包成可重定位目标程序的格式，并将结果保存在目标文件hello.o中。（hello.o是一个二进制文件）作用:将汇编语言翻译成机器指令，用二进制符号代替汇编语言符号，使之可以被机器直接识别。4.2在Ubuntu下汇编的命令ashello.s-ohello.o4.3可重定位目标elf格式使用readelf-hhello.o查看ELF头信息可知hello.o是可重定位文件，采用补码，小端序输入readelf-Shello.o查看节头信息输入readelf-shello.o查看符号表输入readelf-rhello.o查看重定位信息4.4Hello.o的结果解析objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 输入objdump-d-rhello.o>hello.oasm得到hello.o的反汇编文本与之前hello.s的对比 汇编语言中操作数是十进制的而机器语言反汇编得到的操作数是十六进制的。对全局变量（即字符串常量）的引用，汇编语言中是用的全局变量所在的那一段的名称加上%rip的值，而hello.o中用的是0加%rip的值，因为当前为可重定位目标文件，之后还需经过重定位方可确定其具体位置，所以这里都用0来代替。3.分支转移hello.s中汇编语言跳转指令用段名称（L3、L4）表示跳转地址。hello.o中因为每行指令被分配了对应的地址，在跳转指令后用目的地址来表示跳转到的位置。4.函数调用hello.s汇编语言畸形函数调用时call指令后用函数名表示对其的调用而在反汇编后的call指令后加上需调用的函数的地址来表示。可以发现，反汇编的每个call指令的操作数都为0，即相对地址都为0，因为需要链接生成可执行文件后才会生成确定地址，这里相对地址都用0代替。.5本章小结通过汇编器实现了hello从汇编语言到机器语言的转变（从.s到.o），hello到此可以被机器直接理解。hello的每条指令被分配了一个临时的地址，并通过不同地址之间的跳转实现把程序连成一个整体。我们通过对elf格式和机器语言与汇编语言的映射的观察对hello.o有一个初步了解。（第4章1分） 第5章链接5.1链接的概念与作用概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载（复制）到内存并执行。作用：把预编译好了的若干目标文件合并成为一个可执行目标文件。使得分离编译称为可能，不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为可独立修改和编译的模块。当改变这些模块中的一个时，只需简单重新编译它并重新链接即可，不必重新编译其他文件。5.2在Ubuntu下链接的命令ld-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.o/usr/lib/gcc/x86_64-linux-gnu/7/crtbegin.o/usr/lib/gcc/x86_64-linux-gnu/7/crtend.o/usr/lib/x86_64-linux-gnu/crtn.ohello.o-lc-zrelro-ohello5.3可执行目标文件hello的格式ELF头节头信息程序头5.4hello的虚拟地址空间其中的虚拟地址在edb的DataDump中都能找到对应位置 还可发现DataDump是从地址0x400000开始的，并且该处有ELF的标识，可以判断从可执行文件时加载的信息（只读代码段，读/写段）是从地址0x400000处开始的。5.5链接的重定位过程分析在hello中可以看到各函数的代码段并且每个函数的每条指令都有对应的虚拟地址。在hello.o中main函数起始地址为0而在hello.o中main函数起始地址为0x4005e7.在hello.o中由于没有链接，对全局变量的引用部分操作数为0而在hello中因为已经对全局变量进行定位，所以引用时使用了确定的相对偏移加上%rip的值来确定其位置。对于函数的调用，因为hallo.o中并为对函数进行定位所以调用时用call加下一条指令的地址表示而hello中使用其虚拟地址进行调用。对于跳转指令，hello.o中在其后加上目的地址，为main从0开始对每条指令分配的地址；而hello中同样加上目的地址，但这里是每条指令的虚拟地址。除了main函数，hello比hello.o多出了几个函数：printf、sleep、puts、getchar、atoi、exit。 除了.text节的区别外，hello1.ob比hello.ob多出了几个节：.init节、.plt节、.fini节。其中.init节是程序初始化需要执行的代码，.fini节是程序正常终止时需要执行的代码，.plt节是动态链接中的过程链接表。5.6hello的执行流程_dl_start_dl_init_start_libc_start_main_cxa_atexitlibc_csu_init_setjmp_sigsetjmp_sigjmp_savemain(argc!=3时:puts,exit)printsleepgetchar_dl_runtime_resolve_xsave_dl_fixupexit5.7Hello的动态链接分析当程序调用一个由共享库定义的函数时，编译器无法预测这个函数运行时的地址，因为定义它的共享模块在运行时可以加载到任何位置。这时，编译系统提供了延迟绑定的方法，将过程地址的绑定推迟到第一次调用该过程时。他通过GOT和过程链接表PLT的协作来解析函数的地址。在加载时，动态链接器会重定位GOT中的每个条目，使它包含正确的绝对地址，而PLT中的每个函数负责调用不同函数。在dl_init调用之前，对于每一条PIC函数调用，调用的目标地址都实际指向PLT中的代码逻辑，GOT存放的是PLT中函数调用指令的下一条指令地址。可以看到调用dl_init后0x404008和0x404010处的两个8字节的数据发生改变，出现了两个地址0x7f85442c2190和0x7f85442ad200。5.8本章小结本章介绍了链接的概念和作用，对链接后生成的可执行文件hello的elf格式文件进行了分析，分析了hello的虚拟地址空间、重定位过程、执行过程的各种处理操作。链接完成之后hello便可以开始在shell中运行了。（第5章1分） 第6章hello进程管理6.1进程的概念与作用进程的概念：一个执行中的程序的实例，同时也是系统进行资源分配和调度的基本单位。一般情况下，包括文本区域、数据区域和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。 进程的作用：，它提供一个假象，好像我们的程序独占地使用内存系统，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。6.2简述壳Shell-bash的作用与处理流程shell-bash的作用：shell-bash是一个C语言程序，它代表用户执行进程，它交互性地解释和执行用户输入的命令，能够通过调用系统级的函数或功能执行程序、建立文件、进行并行操作等。同时它也能够协调程序间的运行冲突，保证程序能够以并行形式高效执行。bash还提供了一个图形化界面，提升交互的速度。 shell-bash的处理流程：(1)终端进程读取用户由键盘输入的命令行。(2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量(3)检查第一个命令行参数是否是一个内置的shell命令(3)如果不是内部命令，调用fork()创建新进程/子进程(4)在子进程中，用步骤2获取的参数，调用execve()执行指定程序。(5)如果用户没要求后台运行(命令末尾没有&号）否则shell使用waitpid等待作业终止后返回。(6)如果用户要求后台运行(如果命令末尾有&号），则shell返回；6.3Hello的fork进程创建过程打开Terminal输入./hello学号姓名shell分析这条命令，由于./hello不是内置命令，于是判断./hello的语义是执行当前目录下可执行目标文件hello。然后Terminal调用fork创建一个新的子进程。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程与子进程之间的区别在于它们拥有不同的PID。6.4Hello的execve过程execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。所以execve调用一次并不返回。加载运行hello需要以下步骤： 删除已存在的用户区域，删除当前进程虚拟地址的用户部分中已存在的区域结构映射私有区域，为新程序的代码、程序、bss和栈区域创建新的区域结构。代码和数据区域被映射为hello文件的.text和.data区。bss区域是请求二进制零的，映射到匿名文件其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。映射共享区域。设置程序计数器使之指向代码区域的入口点。6.5Hello的进程执行系统中通常有许多程序在运行，那么进程会为每个程序提供一个好像它在独占地使用处理器的假象。这时依赖于进程提供的独立的逻辑控制流（由上下文切换机制提供）。如一个系统运行着多个进程，那么处理器的一个物理控制流就被分成了多个逻辑控制流，每个进程1个。这些逻辑流的执行是交错的，它们轮流使用处理器，会存在并发执行的现象。其中，一个进程执行它的控制流的一部分的每一时间段叫做时间片。这样的机制使进程在执行时仿佛独占了处理器。处理器用某个控制寄存器中的一个模式位来限制一个应用可以执行的指令以及它可以访问的地址空间范围。没有设置模式位时，进程运行在用户模式中，它必须通过系统调用接口才可间接访问内核代码和数据；而设置模式位时，它运行在内核模式中，可以执行指令集中的任何指令，访问系统内存的任何位置。异常发生时，控制传递到异常处理程序，由用户模式转变到内核模式，返回至应用程序代码时，又从内核模式转变到用户模式。内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占进程所需的状态。它由一些对象的值组成，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构。在进程执行的某些时刻，内核可以决定抢占当前进程，并且重新开始一个先前被抢占了的进程。这种决策叫做调度由内核中被称为调度器的代码处理的。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换1）保存当前进程的上下文，2）恢复某个先前被抢占的进程被保存的上下文，3）将控制传递给这个新恢复的进程。当程序在执行sleep函数时，系统调用显式地请求让调用进程休眠，调度器抢占当前进程，并发生上下文切换，将控制转移到新的进程，此时计时器开始，当计时器达到传入的第四个参数大小（这里是1s）时，产生一个中断信号，中断当前正在进行的进程，进行上下文切换恢复hello的上下文信息，控制会回到hello进程中。当循环结束后，程序调用getchar函数用getchar时，由用户模式进入内核模式，内核中的陷阱处理程序请求来自键盘缓冲区的信号传输，并执行上下文切换把控制转移给其他进程。数据传输结束之后，引发一个中断信号，控制回到hello进程中，执行return，进程终止。6.6hello的异常与信号处理（以下格式自行编排，编辑时删除）hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 可能会出现四类异常：中断、陷阱、故障、终止。5.中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。中断处理程序对其进行处理，返回后继续执行调用前待执行的下一条代码。6.陷阱是有意的异常，是执行一条指令的结果，调用后返回到下一条指令。用来调用适当的内核程序，使程序从用户模式切换到内核模式。7.故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。如果无法修正，则终止程序。8.终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。终止处理程序从不将控制返回给应用程序。处理程序将控制返回给一个abort例程，该例程会终止这个应用程序。hello执行过程中可能出现的信号如下hello对各种信号的处理的分析 正常运行hello程序程序在执行结束后，进程被回收。随便乱按乱按会将输入的内容保存在缓冲区，等进程结束后作为命令行的内容输入。运行过程中按下Ctrl+C运行过程中按下Ctrl+Z当按下Ctrl-Z之后，shell进程收到SIGSTP信号，信号处理函数的逻辑是打印屏幕回显、将hello进程挂起，通过ps命令我们可以看出hello进程没有被回收，其进程号时7308，用jobs命令看到jobID是1，状态是Stopped，使用fg1命令将其调到前台，此时shell程序首先打印hello的命令行命令，然后继续运行打印剩下的信息，之后再按下Ctrl-Z，将进程挂起。 用pstree查看进程用kill-92475杀死hello进程6.7本章小结本章分析了shell的作用、处理流程和fork、execve过程以及各种异常。最后分析了hello执行过程中的异常和异常处理。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：在有地址变换功能的计算机中，访内指令给出的地址(操作数)叫逻辑地址，也叫相对地址。分为两个部分，一个部分为段基址，另一个部分为段偏移量。线性地址：逻辑地址经过段机制后转化为线性地址，为描述符:偏移量的组合形式。分页机制中线性地址作为输入。虚拟地址：CPU启动保护模式后，程序运行在虚拟地址空间中。与物理地址相似，虚拟内存被组织为一个存放在磁盘上的N个连续的字节大小的单元组成的数组，其每个字节对应的地址成为虚拟地址。虚拟地址包括VPO（虚拟页面偏移量）、VPN（虚拟页号）、TLBI（TLB索引）、TLBT（TLB标记）。物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址。结合hello的反汇编文件，main函数的起始地址0x4005e7，这里的0x4010c1是逻辑地址的偏移量部分，偏移量再加上代码段的段地址就得到了main函数的虚拟地址（线性地址），虚拟地址是现代系统的一个抽象概念，再经过MMU的处理后将得到实际存储在计算机存储设备上的地址。7.2Intel逻辑地址到线性地址的变换-段式管理逻辑地址由段选择符和偏移量组成，线性地址为段首地址与逻辑地址中的偏移量组成。其中，段首地址存放在段描述符中。而段描述符存放在描述符表中，也就是GDT（全局描述符表）或LDT（局部描述符表）中。其中TI指示段描述符是在GDT还是LDT中，而索引指示段描述符在段描述符表中的位置。由此，便可以通过段选择符的指示在段描述符表中找到对应的段描述符，然后便可从段描述符中获得段首地址，将其与逻辑地址中的偏移量相加，就得到了线性地址。7.3Hello的线性地址到物理地址的变换-页式管理 线性地址（虚拟地址）由虚拟页号VPN和虚拟页偏移VPO组成。首先，MMU从线性地址中抽取出VPN，并且检查TLB，看他是否因为前面某个内存引用缓存了PTE的一个副本。TLB从VPN中抽取出TLB索引和TLB标记，查找对应组中是否有匹配的条目。若命中，将缓存的PPN返回给MMU。若不命中，MMU需从页表中的PTE中取出PPN，若得到的PTE无效或标记不匹配，就产生缺页，内核需调入所需页面，重新运行加载指令，若有效，则取出PPN。最后将线性地址中的VPO与PPN连接起来就得到了对应的物理地址。7.4TLB与四级页表支持下的VA到PA的变换为了消除每次CPU产生一个虚拟地址MMU就查阅一个PTE带来的时间开销，许多系统都在MMU中包括了一个关于PTE的小的缓存，称为翻译后被缓冲器（TLB），TLB的速度快于L1cache。TLB通过虚拟地址VPN部分进行索引，分为索引（TLBI）与标记（TLBT）两个部分。这样，MMU在读取PTE时会直接通过TLB，如果不命中再从内存中将PTE复制到TLB。同时，为了减少页表太大而造成的空间损失，可以使用层次结构的页表页压缩页表大小。虚拟地址VA虚拟页号VPN和虚拟页偏移VPO组成。若TLB命中时，所做操作与上面相同；若TLB不命中时，VPN被划分为四个片，每个片被用作到一个页表的偏移量，CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，依次类推。最后在L4页表中对应的PTE中取出PPN，与VPO连接，形成物理地址PA。7.5三级Cache支持下的物理内存访问已知Corei7的三级cache是物理寻址的，块大小为64字节。LI和L2是8路组相联的，而L3是16路组相联的。Corei7实现支持48位虚拟地址空间和52位物理地址空间。因为L1块大小为64字节，所以B=64，b=6.因为L1是8路组相联所以S=8，s=3.所以标记位为43位。根据物理地址的s位组索引索引到L1cache中的某个组，然后在该组中查找是否有某一行的标记等于物理地址的标记并且该行的有效位为1，若有，则说明命中，从这一行对应物理地址b位块偏移的位置取出一个字节，若不满足上面的条件，则说明不命中，需要继续访问下一级cache，访问的原理与L1相同，若是三级cache都没有要访问的数据，则需要访问内存，从内存中取出数据并放入cache。7.6hello进程fork时的内存映射当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给他一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中每个区域结构都标记为私有的写时复制。7.7hello进程execve时的内存映射execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。 1.删除已存在的用户区域，删除当前进程虚拟地址的用户部分中已存在的区域结构2.映射私有区域，为新程序的代码、程序、bss和栈区域创建新的区域结构。代码和数据区域被映射为hello文件的.text和.data区。bss区域是请求二进制零的映射到匿名文件其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。3.映射共享区域。4.设置程序计数器使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理缺页故障是一种常见的故障，当指令引用一个虚拟地址，在MMU中查找页表时发现与该地址相对应的物理地址不在内存中，因此必须从磁盘中取出的时候就会发生故障。缺页中断处理：缺页处理程序是系统内核中的代码，选择一个牺牲页面，如果这个牺牲页面被修改过，将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送VA到MMU，。7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。隐式空间链表头部编码了这个块的大小(包括头部和所有的填充),以及这个块是已分配的还是空闲的。块的头最后一位指明这个块是已分配的还是空闲的。头部后面是应用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。块的格式如图所示，空闲块通过头部块的大小字段隐含的连接着。1)放置已分配的块当一个应用请求一个k字节的块时，分配器搜索空闲链表。查找一个足够大可以放置所请求的空闲块。分配器搜索方式的常见策略是首次适配、下一次适配和最佳适配。(2)分割空闲块一旦分配器找到一个匹配的空闲块，就必须做一个另策决定，那就是分配这个块多少空间。分配器通常将空闲块分割为两部分。第一部分变为了已分配块，第二部分变为了空闲块。显式空间链表使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。一种方法使用后进先出的顺序维护链表，将新释放的块在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块，在这种情况下，释放一个块可以在线性的时间内完成，如果使用了边界标记，那么合并也可以在常数时间内完成。按照地址顺序来维护链表，其中链表中的每个块的地址都小于它的后继的地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序首次适配比LIFO排序的首次适配有着更高的内存利用率，接近最佳适配的利用率。 7.10本章小结本章对hello的存储空间进行了简要概况，介绍了逻辑地址、虚拟地址、物理地址与线性地址的概念与转换方法，回顾了fork和execve函数，介绍了动态内存分配管理。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件设备管理：unixio接口所有IO设备都被模型化为文件所有输入输出被当做文件读写来执行。将设备映射为文件的方式允许Linux内核引出一个应用接口（UnixIO）这使得所有输入输出都能以一种统一的方式来执行。8.2简述UnixIO接口及其函数1.打开文件：程序要求内核打开文件，表示它想访问一个I/O设备。内核返回一个小的非负整数称为描述符。内核记录有关这个打开文件的信息。程序只要记录这个描述符就能记录打开文件所有信息。2.shell在进程开始打开三个文件：标准输入（描述为0）、标准输出（描述符为1）、标准错误（描述符为2）。3.改变当前文件位置：对于每个打开的文件，内核保存着一个文件位置k，初始为0。这个文件位置从文件开头起始的字节偏移量。应用程序能通过执行seek操作显式的设置文件的当前位置k。4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会触发一个称为EOF的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的EOF符号。5.关闭文件：内核释放打开文件时创建的数据结构以及占用的内存资源并将描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。UnixIO接口的函数： 打开文件intopen(char*filename,intflags,mode_tmode);open函数将filename转换为一个文件描述符，并返回描述符数字。flags参数指明进程准备如何访问这个文件，mode参数制定了新文件的访问权限位。关闭文件intclose(intfd);关闭一个文件返回操作结果。读文件ssize_tread(intfd,void*buf,size_tn);read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则返回值表示的是实际传送的字节数量。写文件ssize_twrite(intfd,constvoid*buf,size_tn);write函数从内存位置buf复制只多n个字节到描述符fd的当前文件位置。8.3printf的实现分析（以下格式自行编排，编辑时删除）https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析（以下格式自行编排，编辑时删除）异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章介绍了Linux中I/O设备的管理方法，UnixIO函数分析了printf和getchar函数的实现方法。（第8章1分）结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。程序编写程序员将代码键入hello.c预处理预处理器cpp处理以#开头的行得到hello.i编译ccl将hello.i编译成汇编语言文件hello.s汇编器as将hello.s中的汇编语言翻译成机器语言得到可重定位文件hello.o链接器ld将hello.o与动态链接库链接生成可执行目标文件hello运行在shell中输入./hello1190200410何纪辉，shell通过fork创建新进程并通过execve将hello加载运行。一步步执行指令程序运行结束后，父进程进行回收，内核把它从系统中清除。感想：从大一到大二，直到学了这门课程，总算对一个高级语言程序是如何在计算机中运行的有一个初步了解。对计算机从编程课所学的编程语言到数字逻辑课学的与或非门寄存器锁存器等硬件这些课程所带来的分散的印象终于有一个较统一完整的理解。（结论0分，缺失-1分，根据内容酌情加分） 附件列出所有的中间产物的文件名，并予以说明起作用。hello.i预处理文件hello.s经过编译得到的汇编程序hello.o经过汇编得到的可重定位程序hello经过链接得到的可执行目标文件hello.oasmhello.o的反汇编文件（附件0分，缺失-1分） 参考文献为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp.（参考文献0分，缺失-1分） 

24韩卓宸1190200421CSAPP大作业 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号1190200421班 级1936602学生韩卓宸 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要Hello的P2P，即programtoprocess过程，包括程序员用键盘输入hello。此文件的源代码本文通过对于hello程序的分析，从hello.c直到hello可执行程序进行逐步分析，结合课本上的知识和一些资料，通过乌邦图虚拟机进行试验，试验gdb，edb以及gcc等工具进行试验，把这个学期计算机系统中各章节知识进行融合，形成自己的个性化结果，展示自己的收获，体现自己对于对计算机系统这门课程的理解。 关键词：计算机系统，hello程序的一生； 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介Hello程序的生命周期是从一个源程序,或者说源文件的,即程序员通过编辑器创建并保存的文本文件,文件名是hello.c.hello.c分别经过预处理器cpp的预处理,、编译器ccl的编译，汇编器as的汇编依次生成生成hello.i文件，hello.s文件、,生成hello.o文件、最后使用链接器ld进行链接最终成为可执行目标程序hello.当我们在shell中输入字符串.\hello并使用回车代表输入结束后，shell通过一系列指令的调用将输入的字符读入到寄存器中，之后将Hello目标文件中的代码和数据从磁盘复制到主存。此时shell会调用fork函数创建一个新的进程，并通过加载报存上下文，将控制权交给这个新的进程，具体过程在后面会详细叙述。在hello加载完成后，处理器就开始执行这个程序，翻译成机器语言再翻译成指令编码，最后把程序的调用如：printf等进行链接。新的代码段和数据段被初始化为hello目标文件的内容.然后,加载器会从_start的地址开始,之后会来到main函数的地址，之后进入main函数执行目标代码，CPU为运行的hello分配时间片执行逻辑控制流。执行阶段把这个等执行的程序分解成几个阶段，分别执行对应的指令，最后输出字符串。之后输出的字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示到屏幕上。这标志着进程的终止，shell的父进程回收这个进程操作系统恢复shell的上下文，控制权重回shell，由shell等待接受下一个指令的输入。1.2环境与工具硬件环境：IntelCorei7x64CPU16GRAM512GSSD软件环境：Ubuntu18.04.1LTS开发与调试工具：visualstudioedb,gcc,gdb,readelf,HexEdit,ld，objdump1.3中间结果hello.i预处理器修改了的源程序,分析预处理器行为hello.s编译器生成的编译程序,分析编译器行为hello.o可重定位目标程序,分析汇编器行为hello可执行目标程序,分析链接器行为elf.txthello.o的elf格式,分析汇编器和链接器行为objdump.txthello.o的反汇编,主要是为了分析hello.o 1.4本章小结本章大致主要简单介绍了hello的p2p，020过程，列出了本次实验信息：环境、中间结果，并且大致简介了hello程序从c程序hello.c到可执行目标文件hello的大致经过的历程。 （第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理概念：预处理器cpp根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件。预处理阶段作用：1.处理宏定义指令预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。2.处理条件编译指令条件编译指令如#ifdef，#ifndef，#else，#elif，#endif等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。3.处理头文件包含指令头文件包含指令如#include"FileName"或者#include等。该指令将头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。4.处理特殊符号预编译程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。2.2在Ubuntu下预处理的命令命令：gcchello.c-E-ohello.i 2.3Hello的预处理结果解析 经过预处理之后，hello.c转化为hello.i文件，打开该文件可以发现，文件的内容增加，且仍为可以阅读的C语言程序文本文件。对原文件中的宏进行了宏展开，头文件中的内容被包含进该文件中。例如声明函数、定义结构体、定义变量、定义宏等内容。另外，如果代码中有#define命令还会对相应的符号进行替换。2.4本章小结 本章首先介绍了预处理的定义与作用、之后结合预处理之后的hello.i程序对预处理的结果进行了简单分析。预处理过程为接下来对程序的操作打下了基础，是十分重要，不可或缺的。本章也介绍了预处理的相关概念及其所进行的一些处理，例如实现将定义的宏进行符号替换、引入头文件的内容、根据指令进行选择性编译等。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译要对程序进行以下的过程:首先进行的是语法分析,编译完成的程序使用语法分析器对编译程序输入的符号进行语法检查,检验其语法是否完全符合了语法的标准,如果不完全符合就是产生了错误。编译器使用ccl把一个简单文本翻译文件的其中的一个hello.i翻译成为一个新的hello.s,它的翻译目的主要是为了包含一个可以使用多种汇编语言的应用程序。在机器语言编译的整个过程中,编译器或程序都会产生一种新的中间代码,这种优化就是为了保证下一步的编译器为优化程序进行了充分的准备,大部分的编译器或程序都会针对编译器或程序的功能进行一些优化,目的之一就是在编译器可以很好地实现其原有机器语言功能的前提下提高编译器程序的性能和运行的效率。最后就是使用编译器把已经优化好的编译器和中间代码提取出来进行机器语言编译,调用机器语言汇编的程序,最后生成机器语言的代码。注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序。 3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 3.3Hello的编译结果解析3.3.1汇编指令的介绍 .file:声明源文件.text：代码节.section:.rodata:只读代码段.align：数据或者指令的地址对其方式.string：声明一个字符串（.LC0,.LC1）.global：声明全局变量(main).type:声明一个符号是数据类型还是函数类型3.3.2数据1.字符串 .这两个字符串作为printf函数的参数2.局部变量main函数声明了一个局部变量i，编译器进行编译的时候将局部变量i会放在堆栈中。如图所示，局部变量i放在栈上-4（%rbp）的位置。 3.main函数参数argc作为用户传给main的参数。也是被放到了堆栈中。4.各种立即数立即数直接体现在汇编代码中5.数组：char*argv[]hello.c中唯一的数组是作为main函数的第二个参数，数组的每个元素都是一个指向字符类型的指针。数组的起始地址存放在栈中-32（%rbp）的位置，被两次调用找参数传给printf 3.3.3全局函数 由hello.c可知，hello.c声明了一个全局函数intmain(intargc,char*argv[])，经过编译之后，main函数中使用的字符串常量也被存放在数据区。 这段汇编代码说明main函数是全局函数 3.3.4赋值操作程序中的赋值操作主要有：i=0这条赋值操作在汇编代码主要使用mov指令来实现，而根据数据的类型又有好几种不一样的后缀movb:一个字节movw：两个字节movl：四个字节movq：八个字节 3.3.5算数操作 hello.c中的算数操作有：i++，由于是i是int类型的，因此汇编代码只用addl就能实现其他的操作有LeaqS,DD=&SINCDD=D+1DECDD=D-1NEGDD=-DADDS,DD=D+SSUBS,DD=D-S3.3.6关系操作(1)argc!=3;是在一条件语句中的条件判断：argc!=3，进行编译时，这条指令被编译为：cmpl$3,-20(%rbp)，同时这条cmpl的指令还有设置条件码的作用，当根据条件码来判断是否需要跳转到分支中。 （2）i<8，在hello.c作为判断循环条件，在汇编代码被编译为：cmpl$9,-4(%rbp)，计算i-7然后设置条件码，为下一步jle利用条件码进行跳转做准备。 3.3.7控制转移指令汇编语言中首先设置条件码，然后根据条件码来进行控制转移，在hello.c中，有以下控制转移指令：（1）判断i是否为3，如果i等于3，则不执行if语句，否则执行if语句，对应的汇编代码为 首先i赋初值0，然后无条件跳转至判断条件的代码中，即.L3。判断i是否符合循环的条件，符合直接跳转至.L4，也就是循环体的内部。 3.3.8函数操作调用函数时有以下操作：（假设函数P调用函数Q）（1）传递控制：进行过程Q的时候，程序计数器必须设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。（2）传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P中返回一个值。（3）分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。 hello.C涉及的函数操作有：main函数，printf，exit，sleep，getchar函数main函数的参数是argc和argv；两次printf函数的参数恰好是那两个字符串exit参数是1，sleep函数参数是atoi（argv[3]）函数的返回值存储在%eax寄存器中。 3.3.9类型转换hello.c中涉及的类型转换是：atoi（argv[3]），将字符串类型转换为整数类型其他的类型转换还有int、float、double、short、char之间的转换 3.4本章小结本章主要讲述了编译阶段中编译器如何处理各种数据和操作，以及c语言中各种类型和操作所对应的的汇编代码。通过理解了这些编译器编译的机制，我们可以很容易的将汇编语言翻译成c语言。（第3章2分） 第4章汇编4.1汇编的概念与作用汇编器（as）将汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码。汇编器把这些hello.s翻译成机器语言的指令,并且把这些机器语言指令编码打包成一个可重定位目标程序的指令编码格式,结果指令编码保存在了hello.o中。hello.o文件是一个简单的二进制指令编码文件,它可以包含目标程序的所有指令进行编码。此外汇编器还可以通过翻译生成计算机能直接自动识别和控制指令执行的一种二进制语言,也即机器语言。 4.2在Ubuntu下汇编的命令指令：gcchello.s-c-ohello.o 4.3可重定位目标elf格式(1)ELFHeader:用命令：readelf-hhello.o，如图ELFHeaderELFHeader：以16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解##标题释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量等信息。根据头文件的信息，可以知道该文件是可重定位目标文件，有1个节。 (2)SectionHeaders:命令：readelf-Shello.oSectionHeaders:节头部表，包含了文件中出现的各个节的语义，包括节的类型、位置和大小等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小，同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。 (3)查看符号表.symtab：命令readelf-shello.o.symtab：存放程序中定义和引用的函数和全局变量的信息。name是符号名称，对于可冲定位目标模块，value是符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址。size是目标的大小，type要么是数据要么是函数。Bind字段表明符号是本地的还是全局的。 重定位节：一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。重定位节.rela.text中各项符号的信息： Offset:需要被修改的引用节的偏移Info：包括symbol和type两个部分，symbol在前面四个字节，type在后面四个字节,symbol：标识被修改引用应该指向的符号,type:重定位的类型Type：告知链接器应该如何修改新的应用Attend：一个有符号常数，一些重定位要使用它对被修改引用的值做偏移调整Name:重定向到的目标的名称。 4.4Hello.o的结果解析（以下格式自行编排，编辑时删除）objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 通过反汇编的代码和hello.s进行比较，发现汇编语言的指令并没有什么不同的地方，只是反汇编代码所显示的不仅仅是汇编代码，还有机器代码，机器语言程序的是二进制机器指令的集合，是纯粹的二进制数据表示的语言，是电脑可以真正识别的语言。机器指令由操作码和操作数构成，汇编语言是人们比较熟悉的词句直接表述CPU动作形成的语言，是最接近CPU运行原理的语言。每一条汇编语言操作码都可以用机器二进制数据来表示，进而可以将所有的汇编语言(操作码和操作数）和二进制机器语言建立一一映射的关系，因此可以将汇编语言转化为机器语言，通过对机器代码的分析可以看出一下不同的地方。 (1)分支转移:反汇编的跳转指令用的不是段名称比如.L3，二是用的确定的地址，因为，因为段名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后显然不存在，而是确定的地址。 (2)函数调用:在.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0(目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。4.5本章小结本章对hello.s进行了汇编，生成了hello.o可重定位目标文件，并且分析了可重定位文件的ELF头、节头部表、符号表和可重定位节，比较了hello.s和hello.o反汇编代码的不同之处，分析了从汇编语言到机器语言的一一映射关系。 （第4章1分） 第5章链接5.1链接的概念与作用链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载(复制)到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。5.2在Ubuntu下链接的命令ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o. 5.3可执行目标文件hello的格式(1)ELFHeader:hello的文件头和hello.o文件头的不同之处如下图标记所示，Type类型为EXEC表明hello是一个可执行目标文件，有27个节 （2）节头部表SectionHeaders：SectionHeaders对hello中所有的节信息进行了声明，其中包括大小Size以及在程序中的偏移量Offset，因此根据SectionHeaders中的信息我们就可以用HexEdit定位各个节所占的区间（起始位置，大小）。其中Address是程序被载入到虚拟地址的起始地址。 (3)符号表.symtab (4)重定位节.rela.text 5.4hello的虚拟地址空间使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 通过datadump查看加载到虚拟地址的程序代码知hello的虚拟地址空间开始于0x400000，结束于0x400ff0 与5.3对照知edb中观察到的每个节的地址与程序头中所对应的address均相同。5.5链接的重定位过程分析objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。结合hello.o的重定位项目，分析hello中对其怎么重定位的。命令：objdump-d-rhello>linkhello.txt Hello反汇编 Hello.o反汇编 Hello反汇编 不同点：（1）指令地址不同；hello反汇编代码具有确定的虚拟地址，而hello.o的反汇编代码不具有确定的虚拟地址。（hello中函数调用、跳转的地址均变成虚拟地址）（2）Hello中增加了.init与.plt节及相应的部分函数（3）Hello中无重定位条目，而hello.o反汇编代码中含重定位条目（4）Hello中对全局变量的访问经过重定位，而hello.o中对全局变量的访问是$0x0及0（%rip）。 链接过程：链接器：（1）符号解析（2）重定位静态链接：目标文件直接链接进入可执行程序动态链接：在程序启动后才动态加载目标文件 hello重定位详述：（合并输入模块，并为每个符号分配运行时地址）（1）重定位节和符号定义：1.链接器将所有相同类型的节合并为同一类型的新的聚合节2.链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号3.此步骤完成后，hello程序中的每条指令和全局变量都有唯一的运行时内存地址（2）重定位节中的符号引用链接器依据重定位条目修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。5.6hello的执行流程（以下格式自行编排，编辑时删除）使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 子程序名地址_dl_init0x7f944cc65c10hello!_start+00x00000000004010d0libc-2.31.so!__libc_start_main+00x00007f944ca71fc0libc-2.31.so!__cxa_atexit+00x00007f944ca94f60 hello!__libc_csu_init+00x0000000000401190libc-2.31.so!_setjmp+00x00007f944ca90e00hello!main+00x0000000000401105hello!puts@plt+00x0000000000401030hello!exit@plt+00x0000000000401060 5.7Hello的动态链接分析（以下格式自行编排，编辑时删除）分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。dl_init前： dl_init后： 在进行动态链接前先进行静态链接，生成部分链接的可执行目标文件hello，此文件中有对定义在共享库中的例程和数据的未解析的引用在加载时，加载器将部分链接的可执行文件映射到内存调用动态链接器，通过加载共享库和重定位程序中的引用来完成链接任务。被编译为位置无关代码的共享库可以加载到任何地方，也可在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序也可在运行时使用动态链接器。5.8本章小结详细介绍了链接的概念及作用，展示并分析了hello的elf文件。使用edb查看了hello的虚拟地址空间，详述了链接过程，尤其是重定位过程；最后展示了hello的执行流程及动态链接过程。（第5章1分） 第6章hello进程管理6.1进程的概念与作用概念：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是又程序正确运行所需的状态组成。此状态包括存放在内存中程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量及打开文件描述符的集合。作用：（1）一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器（2）一个私有的地址空间，提供一个假象，好像我们的程序独占的使用内存系统6.2简述壳Shell-bash的作用与处理流程1.定义：交互型的应用级程序，代表用户运行其他程序；shell执行一系列读、求值步骤，然后终止。2.功能：shell应用程序提供了一个界面，用户通过访问这个界面访问操作系统内核的服务。 处理流程：（1）从终端读入输入的命令。（2）将输入字符串切分获得所有的参数（3）如果是内置命令则立即执行；否则调用相应的程序、为其分配子进程执行（4）shell应该接受键盘输入信号，并对这些信号进行相应处理6.3Hello的fork进程创建过程创建：父进程通过调用fork函数创建一个新的、处于运行状态的子进程(1)子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本（包括代码和数据段、堆、共享库及用户栈）(2)子进程获得与父进程任何打开文件描述符相同的副本（共享文件）(3)子进程有不同于父进程的PID(4)父子进程并发执行、具有相同但是独立的地址空间(5)fork函数调用一次返回两次（一次返回父进程，一次返回到新创建的子进程） hello的fork过程如下： (1)在shell输入：./hello1190200421韩卓宸(2)由于./hello不是shell内置命令，而是经过编译系统的可执行文件；故shell为当前进程fork一个子进程(3)将hello载入内存，开始执行 6.4Hello的execve过程 execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。创建子进程后，execve函数在当前进程的上下文中加载并运行一个新程序，此即hello程序。hello程序通过调用execve函数调用加载器。加载器将可执行目标文件hello的代码和数据从磁盘复制到内存，然后通过跳转到程序的第一条指令或入口点来运行该程序。即：（1）加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。（2）新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。（3）最后加载器设置PC指向_start地址，_start最终调用hello中的main函数。6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。（1）进程上下文信息：上下文就是内核重新启动一个先前被抢占了的进程所需的状态。此状态包含存放在内存中的程序的代码及数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、打开文件描述符的集合。（2）调度：在程序运行的某系时刻，内核决定抢占当前进程，并重新开始一个先前被抢占进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。（3）上下文切换：1.保存当前上下文2.恢复先前某个被抢占的进程被保存的上下文3.将控制传递给中国新恢复的进程（4）时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。（5）用户模式与内核模式：处理器用某个控制寄存器中的一个模式位来限制一个应用可以执行的指令及它可以访问的地址空间范围。当设置了模式位时，进程就运行在内核模式中。未设置模式位时，进程就运行在用户模式中。 hello的进程执行过程：最初hello运行在用户模式下，输出“Hello1190200421韩卓宸”hello调用sleep函数、陷入内核模式、处理休眠请求（定时器开始计时），内核将控制通过上下文切换机制转移给其他进程（进入用户模式）。定时器发送中断信号，进入内核模式，内核中中断处理程序处理中断，并再次进行上下文切换，将控制返回给hello。在用户状态下，继续执行hello程序。（hello在调用getchar函数时，也会执行上下文切换）总而言之：在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。6.6hello的异常与信号处理（以下格式自行编排，编辑时删除）hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。hello程序执行过程可能出现的异常一共有四种：中断、陷阱、故障、终止。（1）中断：来自I/O设备的信号，异步发生，总是返回到下一条指令。hello程序执行过程中可能会出现外部I/O设备引起的异常（2）陷阱：有意的异常，同步发生，总是返回到下一条指令。hello调用getchar函数时会触发此异常（3）故障：潜在可恢复的错误，同步发生，可能返回到当前指令或终止。hello程序运行时可能会出现缺页异常的情况（4）终止：不可恢复的错误，同步发生，不会返回。hello程序运行过程中硬件系统发生的一些错误可能会导致终止 接下来我们hello举例子（1）正常执行hello程序： （2）Ctrl+c终止：键入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，（默认）终止前台作业 （3）Ctrl+z暂停：键入Ctrl+z将（默认）挂起前台的作业，hello进程此时并没有被回收，而是运行在后台 （4）程序运行过程中乱按键盘：无关输入被缓存到stdin，并随着printf指令被输出。 （5）输入ps打印当前进程的状态 （6）输入jobs列出当前作业 （7）输入pstree打印进程树 （8）输入fg1，继续执行前台进程1 （9）输入kill，杀死hello 6.7本章小结详细介绍了进程的概念、功能与作用，并展示了shell的处理流程。与此同时，详述hello程序调用fork创建新进程、调用execve函数加载、执行hello的过程。着重展示了hello的进程执行过程及hello的异常及信号处理。 （第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。逻辑地址:逻辑地址是指由程序产生的与段相关的偏移地址部分。表示为[段标识符：段内偏移量]。hello.o里面的相对偏移地址即是逻辑地址。（又称相对地址）线性地址:逻辑地址经过段机制转化后为线性地址，用于描述程序分页信息的地址。（是逻辑地址与物理地址间转化过程中的一个环节）以hello为例，线性地址表明hello应该在内存的哪些块上运行。虚拟地址:为了方便加载与链接，将物理地址映射为虚拟地址。虚拟内存为每个进程提供了一致的地址空间，即虚拟地址空间，CPU在虚拟地址空间上的生成的地址即为虚拟地址。比如在将hello.o链接的时候hello.o文件中的main函数的地址即是虚拟地址。物理地址:CPU通过地址总线的寻址，找到真实的物理内存对应地址（又称绝对地址）；是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址直接成为物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址实际是由48位组成的，前16位包括段选择符，后32位为段内偏移量；段选择符前13位为索引，通过索引（依据TI取值）在描述符表（GDT：全局描述符表；LDT：局部描述符表）中找寻到32位段基地址，段基地址与段内偏移量相加即得线性地址。（32位） 7.3Hello的线性地址到物理地址的变换-页式管理 n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移(VPO),和一个n-p位的虚拟页号(VPN)，MMU利用VPN选择适当的PTE，（eg.VPN0选择PTE0,VPN1选择PTE1)。根据PTE中有效位的信息可知虚拟页是否被缓存，如果虚拟页已缓存，那直接将页表条目的物理页号和虚拟地址的VPO串联起来就得到一个相应的物理地址。（此处VPO和PPO相同）。如果虚拟页是未缓存的，会触发一个缺页故障。调用一个缺页处理子程序将磁盘的虚拟页重新加载到内存中，然后再执行这个导致缺页的指令。7.4TLB与四级页表支持下的VA到PA的变换 CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（TLB标记）+TLBI（TLB索引）访问、查询TLB中是否缓存有相应的PTE；如果TLB命中，则得到PPN，与VPO组合获得PA。如果TLB未命中，MMU向页表中查询，CR3包含L1页表的物理地址，VPN1提供一个L1PTE的偏移量，这个PTE包含L2页表的基地址，VPN2提供一个L2PTE的偏移量，以此类推，最终在第四级页表中查询到PPN的值，与VPO组合获得PA，并且向TLB中添加条目。如果查询PTE的时候发现不在物理内存中，则将引发缺页故障。7.5三级Cache支持下的物理内存访问（1）CPU产生虚拟地址VA。（2）MMU使用VPN在TLB中找寻PTE，若TLB命中，得到PPN与VPO组合得到PA；若TLB不命中，利用VPN的多级页表机制到内存中找到对应的物理页号PPN，与VPO组合得到PA。（3）PA分为PPN和PPO两部分。利用PPO，将其分成CI和CO，CI作为cache组索引，CO作为块偏移，PPN即是缓存组标志CT，利用CI进行组索引，将CT与标志位进行比较，若相同（即命中）则把偏移量CO处的数据字节传给MMU，随后将其传给CPU；不命中时则访问下一级缓存。（4）先访问一级缓存，不命中时访问二级缓存，再不命中访问三级缓存，再不命中访问主存，如果主存缺页则访问硬盘。7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并为它分配一个唯一的PID。为给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任何一个后来进行写操作时，写时复制机制就会创建新页面，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： （1）删除已存在的用户区域。（2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的结构区域。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text区和.data区。Bss区域是请求二进制零的，初始长度为0。（3）映射共享区域。若hello程序与共享对象链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。（4）设置PC。使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理缺页故障：（即DRAM缓存不命中）当指令引用一个相应的虚拟地址，而与该地址相对应的物理页面不在内存中，会触发缺页异常。 缺页异常将调用内核中的缺页异常处理程序，将执行以下操作：（1）判断虚拟地址是否合法，若不合法，则产生一个段错误，然后终止这个进程。（2）判断内存访问是否合法，若访问是不合法的，那么缺页处理程序会触发一个保护异常，终止这个进程。（3）若操作合法，选择一个牺牲页面，如果这个牺牲页面未被修改过，那么就将它交换出去，换入新的页面并更新页表。然后将控制转移给hello进程，再次执行触发缺页故障的指令。 7.9动态存储分配管理Printf会调用malloc，请简述动态内存管理的基本方法与策略。方法：动态内存分配器维护着一个进程的虚拟内存区域，称为堆；分配器将堆视为是一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式的保留为供应用程序使用。空闲块可用来分配。一个已分配的块保存已分配的状态，直至它被释放。一个空闲的块将保持空闲，直到它显式的被应用所分配。策略：显式分配器：要求应用显式地释放任何已分配的块隐式分配器：分配器检测到一个已分配块何时不再被程序所使用，而自动释放这个块。 显式分配器约束条件：（1）处理任意请求序列（2）立即响应请求（3）只使用堆（4）对齐块（5）不修改已分配的块目标：（1）最大化吞吐率（2）最大化内存利用率 堆中块组织形式：隐式空闲链表：空闲块通过头部中的大小字段隐含的连接着的。分配器可以通过遍历堆中所有的块，从而间接的遍历整个空闲块的集合；需要以特殊标记结束块。 块放置策略：（1）首次适配（2）下一次适配（3）最佳适配块合并策略：（1）立即合并（2）推迟合并显式空闲链表：将空闲块组织为某种形式的显式数据结构。将堆组织成一个双向空闲链表，在每个空闲块中，都包含一个先驱与后继指针。 块排序策略：（1）用后进先出的顺序维护链表（2）按地址顺序维护链表空闲链表分离策略：（1）简单分离存储（2）分离适配（3）伙伴系统 7.10本章小结从以下几个方面介绍了hello的存储管理：（1）存储器的4种地址空间、（2）逻辑地址、虚拟地址、物理地址的转换流程及管理模式（段式管理、页式管理）（3）基于TLB的地址翻译、物理内存访问（4）hello进程fork时及execve时的内存映射（5）缺页故障与缺页中断处理的流程（6）动态存储分配管理其中详细展示了（3）（6）模块的内容。 （第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件一个Linux文件就是一个m字节的序列： 所有的I/O设备（例如网络、磁盘、终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。设备管理：unixio接口将设备优雅的映射为文件，允许Linux内核引出一个简单、低级的应用接口8.2简述UnixIO接口及其函数UnixIO接口使得所有的输入、输出都能以一种统一且一致的方式来执行：（1）打开文件（2）shell创建的每个进程开始时都有3个打开的文件：标准输入、标准输出、标准错误（3）改变当前的文件位置（4）读写文件（5）关闭文件 相关函数：进程通过调用open函数来打开一个已存在的文件或创建一个新文件： Open函数将filename转换为一个文件描述符，并返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。Flags参数指明了进程打算如何访问这个文件。 接下来，下面的代码片段创建一个新文件，该文件的拥有者有读写权限，而所有其他的用户都有读权限： umask（DEF_UMASK）;fd=Open（“foo.txt”,O_CREAT|O_TRUNC|O_WRONLY,DEF_MODE）; 最后，进程通过调用close函数关闭一个打开的文件。intclose（intfd）; 应用程序分别调用read、write函数来执行输入、输出。 通过调用rio_readn和rio_writen函数，应用程序可以在内存和文件之间直接传送数据。#include“csapp.h” ssize_trio_readn（intfd,void*usrbuf,size_tn）;ssize_trio_writen（intfd,void*usrbuf,size_tn）;返回：若成功则为传送的字节数，若为EOF则为0（只对rio_readn而言），若出错则为-18.3printf的实现分析https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 Printf函数代码如下： Printf函数接受一个格式字符串fmt，之后是一个变参列表。后面每一个参数均对应这格式字符串中的一个格式符。Printf函数分别调用两个函数：vsprintf和write。vsprintf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。在printf中调用系统函数write(buf,i)将长度为i的buf输出。故printf的实现就是：用参数匹配格式字符串，然后用vsprintf将结果字符串整理，最后用write函数输出。 vsprintf函数： 8.4getchar的实现分析异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。getchar函数源代码： getchar函数调用系统函数read，该函数将整个缓冲区读入到buf中，后取出缓冲区内第一个字符作为结果。8.5本章小结本章主要介绍了IO设备管理方法、UnixI/O接口及其函数；同时也对printf函数与getchar函数的实现进行了简要分析.（第8章1分）结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。Hello的一生曾这样走过：·编程：在codeblocks或virtualstudio环境下编写、开发hello的C语言代码，生成hello.c文件·预处理：cpp根据以字符#开头的命令，修改原始C程序；读取并将系统头文件的内容直接插入程序文本、生成hello.i文件·编译：ccl将.i文件翻译为.s文件，其包含一个汇编语言程序·汇编：as将hello.s文件翻译为机器语言指令，将这些指令打包装入可重定位目标程序hello.o·链接：ld将可重定位目标文件hello.o与动态链接库链接成可执行目标文件hello，hello可被加载到内存中由内存执行。至此，Hello经过编译系统，实现了从高级语言程序到可执行语言程序的转变。接下来，hello将开启新的篇章。·运行：在shell上键入：./hello1190200525刘祥龙·创建子进程：由于在终端键入的非shell内置命令，故将调用fork函数创建一个子进程。·加载：shell调用execve，execve调用启动加载器，映射虚拟内存，设置当前进程上下文中的程序计数器，使之指向程序入口地址；进入程序入口程序后开始载入物理内存，然后进入main函数。·访存与缺页：CPU生成虚拟地址，CPU上的MMU将联合TLB将虚拟地址翻译为物理地址，此时可能会触发缺页故障，将调用异常处理程序。·执行指令：在一个时间片内进程享有CPU资源，可执行自己的逻辑控制流·上下文切换：在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。·信号处理：键入Ctrlz挂起当前进程，键入Ctrlc终止当前进程。·动态内存申请：当hello程序执行printf函数时，将调用malloc函数向动态内存分配器申请分配堆中的内存。·结束：当子进程hello执行完成时，内核安排父进程回收子进程，将子进程退出状态传递给父进程。内核删除为此进程创建的所有数据结构。至此，hello走到了生命的尽头，结束了它波澜壮阔的一生。 （结论0分，缺失-1分，根据内容酌情加分） 附件hello.i：预处理后的文本文件hello.s：汇编后的文本文件hello.o：编译后的可重定位文件hello,out:扩展文件linkhello.elf:hello的elf文件linkhello.txt：hello的反汇编代码文本hello：最终的可执行目标文件。（附件0分，缺失-1分） 参考文献[1]https://blog.csdn.net/weixin_36277197/article/details/116987253?C语言中编译预处理命令的作用有哪些，C语言系列 预处理命令[2]https://blog.csdn.net/Hanani_Jia/article/details/81735517?gcc编译程序四个阶段预处理、编译、汇编、链接[3]https://blog.csdn.net/qq_14892521/article/details/103460609?连接过程详述[4]https://blog.csdn.net/qq_42192672/article/details/82937667?初识edbdebugger[5]https://blog.csdn.net/genghaihua/article/details/89450057?物理地址和逻辑地址[6]https://blog.csdn.net/mzjmzjmzjmzj/article/details/84713351?通俗理解CPU中物理地址、逻辑地址、线性地址、虚拟地址、有效地址的区别[7]https://blog.csdn.net/Pipcie/article/details/105670156?段页式访存 逻辑地址到线性地址的转换[8]兰德尔E.布莱恩特，大卫R.奥哈拉伦深入理解计算机系统（第三版）collection/anatmorp. 

241190200421韩卓宸大作业 这里写自定义目录标题 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML图表FLowchart流程图导出与导入导出导入 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号1190200421班 级1936602学生韩卓宸 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要Hello的P2P，即programtoprocess过程，包括程序员用键盘输入hello。此文件的源代码本文通过对于hello程序的分析，从hello.c直到hello可执行程序进行逐步分析，结合课本上的知识和一些资料，通过乌邦图虚拟机进行试验，试验gdb，edb以及gcc等工具进行试验，把这个学期计算机系统中各章节知识进行融合，形成自己的个性化结果，展示自己的收获，体现自己对于对计算机系统这门课程的理解。 关键词：计算机系统，hello程序的一生； 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介Hello程序的生命周期是从一个源程序,或者说源文件的,即程序员通过编辑器创建并保存的文本文件,文件名是hello.c.hello.c分别经过预处理器cpp的预处理,、编译器ccl的编译，汇编器as的汇编依次生成生成hello.i文件，hello.s文件、,生成hello.o文件、最后使用链接器ld进行链接最终成为可执行目标程序hello.当我们在shell中输入字符串.\hello并使用回车代表输入结束后，shell通过一系列指令的调用将输入的字符读入到寄存器中，之后将Hello目标文件中的代码和数据从磁盘复制到主存。此时shell会调用fork函数创建一个新的进程，并通过加载报存上下文，将控制权交给这个新的进程，具体过程在后面会详细叙述。在hello加载完成后，处理器就开始执行这个程序，翻译成机器语言再翻译成指令编码，最后把程序的调用如：printf等进行链接。新的代码段和数据段被初始化为hello目标文件的内容.然后,加载器会从_start的地址开始,之后会来到main函数的地址，之后进入main函数执行目标代码，CPU为运行的hello分配时间片执行逻辑控制流。执行阶段把这个等执行的程序分解成几个阶段，分别执行对应的指令，最后输出字符串。之后输出的字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示到屏幕上。这标志着进程的终止，shell的父进程回收这个进程操作系统恢复shell的上下文，控制权重回shell，由shell等待接受下一个指令的输入。1.2环境与工具硬件环境：IntelCorei7x64CPU16GRAM512GSSD软件环境：Ubuntu18.04.1LTS开发与调试工具：visualstudioedb,gcc,gdb,readelf,HexEdit,ld，objdump1.3中间结果hello.i预处理器修改了的源程序,分析预处理器行为hello.s编译器生成的编译程序,分析编译器行为hello.o可重定位目标程序,分析汇编器行为hello可执行目标程序,分析链接器行为elf.txthello.o的elf格式,分析汇编器和链接器行为objdump.txthello.o的反汇编,主要是为了分析hello.o 1.4本章小结本章大致主要简单介绍了hello的p2p，020过程，列出了本次实验信息：环境、中间结果，并且大致简介了hello程序从c程序hello.c到可执行目标文件hello的大致经过的历程。 （第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理概念：预处理器cpp根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件。预处理阶段作用：1.处理宏定义指令预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。2.处理条件编译指令条件编译指令如#ifdef，#ifndef，#else，#elif，#endif等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。3.处理头文件包含指令头文件包含指令如#include"FileName"或者#include等。该指令将头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。4.处理特殊符号预编译程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。2.2在Ubuntu下预处理的命令命令：gcchello.c-E-ohello.i 2.3Hello的预处理结果解析 经过预处理之后，hello.c转化为hello.i文件，打开该文件可以发现，文件的内容增加，且仍为可以阅读的C语言程序文本文件。对原文件中的宏进行了宏展开，头文件中的内容被包含进该文件中。例如声明函数、定义结构体、定义变量、定义宏等内容。另外，如果代码中有#define命令还会对相应的符号进行替换。2.4本章小结 本章首先介绍了预处理的定义与作用、之后结合预处理之后的hello.i程序对预处理的结果进行了简单分析。预处理过程为接下来对程序的操作打下了基础，是十分重要，不可或缺的。本章也介绍了预处理的相关概念及其所进行的一些处理，例如实现将定义的宏进行符号替换、引入头文件的内容、根据指令进行选择性编译等。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译要对程序进行以下的过程:首先进行的是语法分析,编译完成的程序使用语法分析器对编译程序输入的符号进行语法检查,检验其语法是否完全符合了语法的标准,如果不完全符合就是产生了错误。编译器使用ccl把一个简单文本翻译文件的其中的一个hello.i翻译成为一个新的hello.s,它的翻译目的主要是为了包含一个可以使用多种汇编语言的应用程序。在机器语言编译的整个过程中,编译器或程序都会产生一种新的中间代码,这种优化就是为了保证下一步的编译器为优化程序进行了充分的准备,大部分的编译器或程序都会针对编译器或程序的功能进行一些优化,目的之一就是在编译器可以很好地实现其原有机器语言功能的前提下提高编译器程序的性能和运行的效率。最后就是使用编译器把已经优化好的编译器和中间代码提取出来进行机器语言编译,调用机器语言汇编的程序,最后生成机器语言的代码。注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序。 3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 3.3Hello的编译结果解析3.3.1汇编指令的介绍 .file:声明源文件.text：代码节.section:.rodata:只读代码段.align：数据或者指令的地址对其方式.string：声明一个字符串（.LC0,.LC1）.global：声明全局变量(main).type:声明一个符号是数据类型还是函数类型3.3.2数据1.字符串 .这两个字符串作为printf函数的参数2.局部变量main函数声明了一个局部变量i，编译器进行编译的时候将局部变量i会放在堆栈中。如图所示，局部变量i放在栈上-4（%rbp）的位置。 3.main函数参数argc作为用户传给main的参数。也是被放到了堆栈中。4.各种立即数立即数直接体现在汇编代码中5.数组：char*argv[]hello.c中唯一的数组是作为main函数的第二个参数，数组的每个元素都是一个指向字符类型的指针。数组的起始地址存放在栈中-32（%rbp）的位置，被两次调用找参数传给printf 3.3.3全局函数 由hello.c可知，hello.c声明了一个全局函数intmain(intargc,char*argv[])，经过编译之后，main函数中使用的字符串常量也被存放在数据区。 这段汇编代码说明main函数是全局函数 3.3.4赋值操作程序中的赋值操作主要有：i=0这条赋值操作在汇编代码主要使用mov指令来实现，而根据数据的类型又有好几种不一样的后缀movb:一个字节movw：两个字节movl：四个字节movq：八个字节 3.3.5算数操作 hello.c中的算数操作有：i++，由于是i是int类型的，因此汇编代码只用addl就能实现其他的操作有LeaqS,DD=&SINCDD=D+1DECDD=D-1NEGDD=-DADDS,DD=D+SSUBS,DD=D-S3.3.6关系操作(1)argc!=3;是在一条件语句中的条件判断：argc!=3，进行编译时，这条指令被编译为：cmpl$3,-20(%rbp)，同时这条cmpl的指令还有设置条件码的作用，当根据条件码来判断是否需要跳转到分支中。 （2）i<8，在hello.c作为判断循环条件，在汇编代码被编译为：cmpl$9,-4(%rbp)，计算i-7然后设置条件码，为下一步jle利用条件码进行跳转做准备。 3.3.7控制转移指令汇编语言中首先设置条件码，然后根据条件码来进行控制转移，在hello.c中，有以下控制转移指令：（1）判断i是否为3，如果i等于3，则不执行if语句，否则执行if语句，对应的汇编代码为 首先i赋初值0，然后无条件跳转至判断条件的代码中，即.L3。判断i是否符合循环的条件，符合直接跳转至.L4，也就是循环体的内部。 3.3.8函数操作调用函数时有以下操作：（假设函数P调用函数Q）（1）传递控制：进行过程Q的时候，程序计数器必须设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。（2）传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P中返回一个值。（3）分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。 hello.C涉及的函数操作有：main函数，printf，exit，sleep，getchar函数main函数的参数是argc和argv；两次printf函数的参数恰好是那两个字符串exit参数是1，sleep函数参数是atoi（argv3）函数的返回值存储在%eax寄存器中。 3.3.9类型转换hello.c中涉及的类型转换是：atoi（argv3），将字符串类型转换为整数类型其他的类型转换还有int、float、double、short、char之间的转换 3.4本章小结本章主要讲述了编译阶段中编译器如何处理各种数据和操作，以及c语言中各种类型和操作所对应的的汇编代码。通过理解了这些编译器编译的机制，我们可以很容易的将汇编语言翻译成c语言。（第3章2分） 第4章汇编4.1汇编的概念与作用汇编器（as）将汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码。汇编器把这些hello.s翻译成机器语言的指令,并且把这些机器语言指令编码打包成一个可重定位目标程序的指令编码格式,结果指令编码保存在了hello.o中。hello.o文件是一个简单的二进制指令编码文件,它可以包含目标程序的所有指令进行编码。此外汇编器还可以通过翻译生成计算机能直接自动识别和控制指令执行的一种二进制语言,也即机器语言。 4.2在Ubuntu下汇编的命令指令：gcchello.s-c-ohello.o 4.3可重定位目标elf格式(1)ELFHeader:用命令：readelf-hhello.o，如图ELFHeaderELFHeader：以16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解##标题释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量等信息。根据头文件的信息，可以知道该文件是可重定位目标文件，有1个节。 (2)SectionHeaders:命令：readelf-Shello.oSectionHeaders:节头部表，包含了文件中出现的各个节的语义，包括节的类型、位置和大小等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小，同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。 (3)查看符号表.symtab：命令readelf-shello.o.symtab：存放程序中定义和引用的函数和全局变量的信息。name是符号名称，对于可冲定位目标模块，value是符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址。size是目标的大小，type要么是数据要么是函数。Bind字段表明符号是本地的还是全局的。 重定位节：一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。重定位节.rela.text中各项符号的信息： Offset:需要被修改的引用节的偏移Info：包括symbol和type两个部分，symbol在前面四个字节，type在后面四个字节,symbol：标识被修改引用应该指向的符号,type:重定位的类型Type：告知链接器应该如何修改新的应用Attend：一个有符号常数，一些重定位要使用它对被修改引用的值做偏移调整Name:重定向到的目标的名称。 4.4Hello.o的结果解析（以下格式自行编排，编辑时删除）objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 通过反汇编的代码和hello.s进行比较，发现汇编语言的指令并没有什么不同的地方，只是反汇编代码所显示的不仅仅是汇编代码，还有机器代码，机器语言程序的是二进制机器指令的集合，是纯粹的二进制数据表示的语言，是电脑可以真正识别的语言。机器指令由操作码和操作数构成，汇编语言是人们比较熟悉的词句直接表述CPU动作形成的语言，是最接近CPU运行原理的语言。每一条汇编语言操作码都可以用机器二进制数据来表示，进而可以将所有的汇编语言(操作码和操作数）和二进制机器语言建立一一映射的关系，因此可以将汇编语言转化为机器语言，通过对机器代码的分析可以看出一下不同的地方。 (1)分支转移:反汇编的跳转指令用的不是段名称比如.L3，二是用的确定的地址，因为，因为段名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后显然不存在，而是确定的地址。 (2)函数调用:在.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0(目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。4.5本章小结本章对hello.s进行了汇编，生成了hello.o可重定位目标文件，并且分析了可重定位文件的ELF头、节头部表、符号表和可重定位节，比较了hello.s和hello.o反汇编代码的不同之处，分析了从汇编语言到机器语言的一一映射关系。 （第4章1分） 第5章链接5.1链接的概念与作用链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载(复制)到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。5.2在Ubuntu下链接的命令ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o. 5.3可执行目标文件hello的格式(1)ELFHeader:hello的文件头和hello.o文件头的不同之处如下图标记所示，Type类型为EXEC表明hello是一个可执行目标文件，有27个节 （2）节头部表SectionHeaders：SectionHeaders对hello中所有的节信息进行了声明，其中包括大小Size以及在程序中的偏移量Offset，因此根据SectionHeaders中的信息我们就可以用HexEdit定位各个节所占的区间（起始位置，大小）。其中Address是程序被载入到虚拟地址的起始地址。 (3)符号表.symtab (4)重定位节.rela.text 5.4hello的虚拟地址空间使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 通过datadump查看加载到虚拟地址的程序代码知hello的虚拟地址空间开始于0x400000，结束于0x400ff0 与5.3对照知edb中观察到的每个节的地址与程序头中所对应的address均相同。5.5链接的重定位过程分析objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。结合hello.o的重定位项目，分析hello中对其怎么重定位的。命令：objdump-d-rhello>linkhello.txt Hello反汇编 Hello.o反汇编 Hello反汇编 不同点：（1）指令地址不同；hello反汇编代码具有确定的虚拟地址，而hello.o的反汇编代码不具有确定的虚拟地址。（hello中函数调用、跳转的地址均变成虚拟地址）（2）Hello中增加了.init与.plt节及相应的部分函数（3）Hello中无重定位条目，而hello.o反汇编代码中含重定位条目（4）Hello中对全局变量的访问经过重定位，而hello.o中对全局变量的访问是$0x0及0（%rip）。 链接过程：链接器：（1）符号解析（2）重定位静态链接：目标文件直接链接进入可执行程序动态链接：在程序启动后才动态加载目标文件 hello重定位详述：（合并输入模块，并为每个符号分配运行时地址）（1）重定位节和符号定义：1.链接器将所有相同类型的节合并为同一类型的新的聚合节2.链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号3.此步骤完成后，hello程序中的每条指令和全局变量都有唯一的运行时内存地址（2）重定位节中的符号引用链接器依据重定位条目修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。5.6hello的执行流程（以下格式自行编排，编辑时删除）使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 子程序名地址_dl_init0x7f944cc65c10hello!_start+00x00000000004010d0libc-2.31.so!__libc_start_main+00x00007f944ca71fc0libc-2.31.so!__cxa_atexit+00x00007f944ca94f60 hello!__libc_csu_init+00x0000000000401190libc-2.31.so!_setjmp+00x00007f944ca90e00hello!main+00x0000000000401105hello!puts@plt+00x0000000000401030hello!exit@plt+00x0000000000401060 5.7Hello的动态链接分析（以下格式自行编排，编辑时删除）分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。dl_init前： dl_init后： 在进行动态链接前先进行静态链接，生成部分链接的可执行目标文件hello，此文件中有对定义在共享库中的例程和数据的未解析的引用在加载时，加载器将部分链接的可执行文件映射到内存调用动态链接器，通过加载共享库和重定位程序中的引用来完成链接任务。被编译为位置无关代码的共享库可以加载到任何地方，也可在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序也可在运行时使用动态链接器。5.8本章小结详细介绍了链接的概念及作用，展示并分析了hello的elf文件。使用edb查看了hello的虚拟地址空间，详述了链接过程，尤其是重定位过程；最后展示了hello的执行流程及动态链接过程。（第5章1分） 第6章hello进程管理6.1进程的概念与作用概念：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是又程序正确运行所需的状态组成。此状态包括存放在内存中程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量及打开文件描述符的集合。作用：（1）一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器（2）一个私有的地址空间，提供一个假象，好像我们的程序独占的使用内存系统6.2简述壳Shell-bash的作用与处理流程1.定义：交互型的应用级程序，代表用户运行其他程序；shell执行一系列读、求值步骤，然后终止。2.功能：shell应用程序提供了一个界面，用户通过访问这个界面访问操作系统内核的服务。 处理流程：（1）从终端读入输入的命令。（2）将输入字符串切分获得所有的参数（3）如果是内置命令则立即执行；否则调用相应的程序、为其分配子进程执行（4）shell应该接受键盘输入信号，并对这些信号进行相应处理6.3Hello的fork进程创建过程创建：父进程通过调用fork函数创建一个新的、处于运行状态的子进程(1)子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本（包括代码和数据段、堆、共享库及用户栈）(2)子进程获得与父进程任何打开文件描述符相同的副本（共享文件）(3)子进程有不同于父进程的PID(4)父子进程并发执行、具有相同但是独立的地址空间(5)fork函数调用一次返回两次（一次返回父进程，一次返回到新创建的子进程） hello的fork过程如下： (1)在shell输入：./hello1190200421韩卓宸(2)由于./hello不是shell内置命令，而是经过编译系统的可执行文件；故shell为当前进程fork一个子进程(3)将hello载入内存，开始执行 6.4Hello的execve过程 execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。创建子进程后，execve函数在当前进程的上下文中加载并运行一个新程序，此即hello程序。hello程序通过调用execve函数调用加载器。加载器将可执行目标文件hello的代码和数据从磁盘复制到内存，然后通过跳转到程序的第一条指令或入口点来运行该程序。即：（1）加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。（2）新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。（3）最后加载器设置PC指向_start地址，_start最终调用hello中的main函数。6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。（1）进程上下文信息：上下文就是内核重新启动一个先前被抢占了的进程所需的状态。此状态包含存放在内存中的程序的代码及数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、打开文件描述符的集合。（2）调度：在程序运行的某系时刻，内核决定抢占当前进程，并重新开始一个先前被抢占进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。（3）上下文切换：1.保存当前上下文2.恢复先前某个被抢占的进程被保存的上下文3.将控制传递给中国新恢复的进程（4）时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。（5）用户模式与内核模式：处理器用某个控制寄存器中的一个模式位来限制一个应用可以执行的指令及它可以访问的地址空间范围。当设置了模式位时，进程就运行在内核模式中。未设置模式位时，进程就运行在用户模式中。 hello的进程执行过程：最初hello运行在用户模式下，输出“Hello1190200421韩卓宸”hello调用sleep函数、陷入内核模式、处理休眠请求（定时器开始计时），内核将控制通过上下文切换机制转移给其他进程（进入用户模式）。定时器发送中断信号，进入内核模式，内核中中断处理程序处理中断，并再次进行上下文切换，将控制返回给hello。在用户状态下，继续执行hello程序。（hello在调用getchar函数时，也会执行上下文切换）总而言之：在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。6.6hello的异常与信号处理（以下格式自行编排，编辑时删除）hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。hello程序执行过程可能出现的异常一共有四种：中断、陷阱、故障、终止。（1）中断：来自I/O设备的信号，异步发生，总是返回到下一条指令。hello程序执行过程中可能会出现外部I/O设备引起的异常（2）陷阱：有意的异常，同步发生，总是返回到下一条指令。hello调用getchar函数时会触发此异常（3）故障：潜在可恢复的错误，同步发生，可能返回到当前指令或终止。hello程序运行时可能会出现缺页异常的情况（4）终止：不可恢复的错误，同步发生，不会返回。hello程序运行过程中硬件系统发生的一些错误可能会导致终止 接下来我们hello举例子（1）正常执行hello程序： （2）Ctrl+c终止：键入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，（默认）终止前台作业 （3）Ctrl+z暂停：键入Ctrl+z将（默认）挂起前台的作业，hello进程此时并没有被回收，而是运行在后台 （4）程序运行过程中乱按键盘：无关输入被缓存到stdin，并随着printf指令被输出。 （5）输入ps打印当前进程的状态 （6）输入jobs列出当前作业 （7）输入pstree打印进程树 （8）输入fg1，继续执行前台进程1 （9）输入kill，杀死hello 6.7本章小结详细介绍了进程的概念、功能与作用，并展示了shell的处理流程。与此同时，详述hello程序调用fork创建新进程、调用execve函数加载、执行hello的过程。着重展示了hello的进程执行过程及hello的异常及信号处理。 （第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。逻辑地址:逻辑地址是指由程序产生的与段相关的偏移地址部分。表示为[段标识符：段内偏移量]。hello.o里面的相对偏移地址即是逻辑地址。（又称相对地址）线性地址:逻辑地址经过段机制转化后为线性地址，用于描述程序分页信息的地址。（是逻辑地址与物理地址间转化过程中的一个环节）以hello为例，线性地址表明hello应该在内存的哪些块上运行。虚拟地址:为了方便加载与链接，将物理地址映射为虚拟地址。虚拟内存为每个进程提供了一致的地址空间，即虚拟地址空间，CPU在虚拟地址空间上的生成的地址即为虚拟地址。比如在将hello.o链接的时候hello.o文件中的main函数的地址即是虚拟地址。物理地址:CPU通过地址总线的寻址，找到真实的物理内存对应地址（又称绝对地址）；是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址直接成为物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址实际是由48位组成的，前16位包括段选择符，后32位为段内偏移量；段选择符前13位为索引，通过索引（依据TI取值）在描述符表（GDT：全局描述符表；LDT：局部描述符表）中找寻到32位段基地址，段基地址与段内偏移量相加即得线性地址。（32位） 7.3Hello的线性地址到物理地址的变换-页式管理 n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移(VPO),和一个n-p位的虚拟页号(VPN)，MMU利用VPN选择适当的PTE，（eg.VPN0选择PTE0,VPN1选择PTE1)。根据PTE中有效位的信息可知虚拟页是否被缓存，如果虚拟页已缓存，那直接将页表条目的物理页号和虚拟地址的VPO串联起来就得到一个相应的物理地址。（此处VPO和PPO相同）。如果虚拟页是未缓存的，会触发一个缺页故障。调用一个缺页处理子程序将磁盘的虚拟页重新加载到内存中，然后再执行这个导致缺页的指令。7.4TLB与四级页表支持下的VA到PA的变换 CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（TLB标记）+TLBI（TLB索引）访问、查询TLB中是否缓存有相应的PTE；如果TLB命中，则得到PPN，与VPO组合获得PA。如果TLB未命中，MMU向页表中查询，CR3包含L1页表的物理地址，VPN1提供一个L1PTE的偏移量，这个PTE包含L2页表的基地址，VPN2提供一个L2PTE的偏移量，以此类推，最终在第四级页表中查询到PPN的值，与VPO组合获得PA，并且向TLB中添加条目。如果查询PTE的时候发现不在物理内存中，则将引发缺页故障。7.5三级Cache支持下的物理内存访问（1）CPU产生虚拟地址VA。（2）MMU使用VPN在TLB中找寻PTE，若TLB命中，得到PPN与VPO组合得到PA；若TLB不命中，利用VPN的多级页表机制到内存中找到对应的物理页号PPN，与VPO组合得到PA。（3）PA分为PPN和PPO两部分。利用PPO，将其分成CI和CO，CI作为cache组索引，CO作为块偏移，PPN即是缓存组标志CT，利用CI进行组索引，将CT与标志位进行比较，若相同（即命中）则把偏移量CO处的数据字节传给MMU，随后将其传给CPU；不命中时则访问下一级缓存。（4）先访问一级缓存，不命中时访问二级缓存，再不命中访问三级缓存，再不命中访问主存，如果主存缺页则访问硬盘。7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并为它分配一个唯一的PID。为给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任何一个后来进行写操作时，写时复制机制就会创建新页面，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： （1）删除已存在的用户区域。（2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的结构区域。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text区和.data区。Bss区域是请求二进制零的，初始长度为0。（3）映射共享区域。若hello程序与共享对象链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。（4）设置PC。使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理缺页故障：（即DRAM缓存不命中）当指令引用一个相应的虚拟地址，而与该地址相对应的物理页面不在内存中，会触发缺页异常。 缺页异常将调用内核中的缺页异常处理程序，将执行以下操作：（1）判断虚拟地址是否合法，若不合法，则产生一个段错误，然后终止这个进程。（2）判断内存访问是否合法，若访问是不合法的，那么缺页处理程序会触发一个保护异常，终止这个进程。（3）若操作合法，选择一个牺牲页面，如果这个牺牲页面未被修改过，那么就将它交换出去，换入新的页面并更新页表。然后将控制转移给hello进程，再次执行触发缺页故障的指令。 7.9动态存储分配管理Printf会调用malloc，请简述动态内存管理的基本方法与策略。方法：动态内存分配器维护着一个进程的虚拟内存区域，称为堆；分配器将堆视为是一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式的保留为供应用程序使用。空闲块可用来分配。一个已分配的块保存已分配的状态，直至它被释放。一个空闲的块将保持空闲，直到它显式的被应用所分配。策略：显式分配器：要求应用显式地释放任何已分配的块隐式分配器：分配器检测到一个已分配块何时不再被程序所使用，而自动释放这个块。 显式分配器约束条件：（1）处理任意请求序列（2）立即响应请求（3）只使用堆（4）对齐块（5）不修改已分配的块目标：（1）最大化吞吐率（2）最大化内存利用率 堆中块组织形式：隐式空闲链表：空闲块通过头部中的大小字段隐含的连接着的。分配器可以通过遍历堆中所有的块，从而间接的遍历整个空闲块的集合；需要以特殊标记结束块。 块放置策略：（1）首次适配（2）下一次适配（3）最佳适配块合并策略：（1）立即合并（2）推迟合并显式空闲链表：将空闲块组织为某种形式的显式数据结构。将堆组织成一个双向空闲链表，在每个空闲块中，都包含一个先驱与后继指针。 块排序策略：（1）用后进先出的顺序维护链表（2）按地址顺序维护链表空闲链表分离策略：（1）简单分离存储（2）分离适配（3）伙伴系统 7.10本章小结从以下几个方面介绍了hello的存储管理：（1）存储器的4种地址空间、（2）逻辑地址、虚拟地址、物理地址的转换流程及管理模式（段式管理、页式管理）（3）基于TLB的地址翻译、物理内存访问（4）hello进程fork时及execve时的内存映射（5）缺页故障与缺页中断处理的流程（6）动态存储分配管理其中详细展示了（3）（6）模块的内容。 （第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件一个Linux文件就是一个m字节的序列： 所有的I/O设备（例如网络、磁盘、终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。设备管理：unixio接口将设备优雅的映射为文件，允许Linux内核引出一个简单、低级的应用接口8.2简述UnixIO接口及其函数UnixIO接口使得所有的输入、输出都能以一种统一且一致的方式来执行：（1）打开文件（2）shell创建的每个进程开始时都有3个打开的文件：标准输入、标准输出、标准错误（3）改变当前的文件位置（4）读写文件（5）关闭文件 相关函数：进程通过调用open函数来打开一个已存在的文件或创建一个新文件： Open函数将filename转换为一个文件描述符，并返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。Flags参数指明了进程打算如何访问这个文件。 接下来，下面的代码片段创建一个新文件，该文件的拥有者有读写权限，而所有其他的用户都有读权限： umask（DEF_UMASK）;fd=Open（“foo.txt”,O_CREAT|O_TRUNC|O_WRONLY,DEF_MODE）; 最后，进程通过调用close函数关闭一个打开的文件。intclose（intfd）; 应用程序分别调用read、write函数来执行输入、输出。 通过调用rio_readn和rio_writen函数，应用程序可以在内存和文件之间直接传送数据。#include“csapp.h” ssize_trio_readn（intfd,void*usrbuf,size_tn）;ssize_trio_writen（intfd,void*usrbuf,size_tn）;返回：若成功则为传送的字节数，若为EOF则为0（只对rio_readn而言），若出错则为-18.3printf的实现分析https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 Printf函数代码如下： Printf函数接受一个格式字符串fmt，之后是一个变参列表。后面每一个参数均对应这格式字符串中的一个格式符。Printf函数分别调用两个函数：vsprintf和write。vsprintf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。在printf中调用系统函数write(buf,i)将长度为i的buf输出。故printf的实现就是：用参数匹配格式字符串，然后用vsprintf将结果字符串整理，最后用write函数输出。 vsprintf函数： 8.4getchar的实现分析异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。getchar函数源代码： getchar函数调用系统函数read，该函数将整个缓冲区读入到buf中，后取出缓冲区内第一个字符作为结果。8.5本章小结本章主要介绍了IO设备管理方法、UnixI/O接口及其函数；同时也对printf函数与getchar函数的实现进行了简要分析.（第8章1分）结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。Hello的一生曾这样走过：·编程：在codeblocks或virtualstudio环境下编写、开发hello的C语言代码，生成hello.c文件·预处理：cpp根据以字符#开头的命令，修改原始C程序；读取并将系统头文件的内容直接插入程序文本、生成hello.i文件·编译：ccl将.i文件翻译为.s文件，其包含一个汇编语言程序·汇编：as将hello.s文件翻译为机器语言指令，将这些指令打包装入可重定位目标程序hello.o·链接：ld将可重定位目标文件hello.o与动态链接库链接成可执行目标文件hello，hello可被加载到内存中由内存执行。至此，Hello经过编译系统，实现了从高级语言程序到可执行语言程序的转变。接下来，hello将开启新的篇章。·运行：在shell上键入：./hello1190200525刘祥龙·创建子进程：由于在终端键入的非shell内置命令，故将调用fork函数创建一个子进程。·加载：shell调用execve，execve调用启动加载器，映射虚拟内存，设置当前进程上下文中的程序计数器，使之指向程序入口地址；进入程序入口程序后开始载入物理内存，然后进入main函数。·访存与缺页：CPU生成虚拟地址，CPU上的MMU将联合TLB将虚拟地址翻译为物理地址，此时可能会触发缺页故障，将调用异常处理程序。·执行指令：在一个时间片内进程享有CPU资源，可执行自己的逻辑控制流·上下文切换：在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。·信号处理：键入Ctrlz挂起当前进程，键入Ctrlc终止当前进程。·动态内存申请：当hello程序执行printf函数时，将调用malloc函数向动态内存分配器申请分配堆中的内存。·结束：当子进程hello执行完成时，内核安排父进程回收子进程，将子进程退出状态传递给父进程。内核删除为此进程创建的所有数据结构。至此，hello走到了生命的尽头，结束了它波澜壮阔的一生。 （结论0分，缺失-1分，根据内容酌情加分） 附件hello.i：预处理后的文本文件hello.s：汇编后的文本文件hello.o：编译后的可重定位文件hello,out:扩展文件linkhello.elf:hello的elf文件linkhello.txt：hello的反汇编代码文本hello：最终的可执行目标文件。（附件0分，缺失-1分） 参考文献1https://blog.csdn.net/weixin_36277197/article/details/116987253?C语言中编译预处理命令的作用有哪些，C语言系列 预处理命令2https://blog.csdn.net/Hanani_Jia/article/details/81735517?gcc编译程序四个阶段预处理、编译、汇编、链接3https://blog.csdn.net/qq_14892521/article/details/103460609?连接过程详述4https://blog.csdn.net/qq_42192672/article/details/82937667?初识edbdebugger[5]https://blog.csdn.net/genghaihua/article/details/89450057?物理地址和逻辑地址[6]https://blog.csdn.net/mzjmzjmzjmzj/article/details/84713351?通俗理解CPU中物理地址、逻辑地址、线性地址、虚拟地址、有效地址的区别[7]https://blog.csdn.net/Pipcie/article/details/105670156?段页式访存 逻辑地址到线性地址的转换[8]兰德尔E.布莱恩特，大卫R.奥哈拉伦深入理解计算机系统（第三版）collection/anatmorp. 欢迎使用Markdown编辑器 你好！这是你第一次使用Markdown编辑器所展示的欢迎页。如果你想学习如何使用Markdown编辑器,可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。 新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客： 全新的界面设计，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown将代码片显示选择的高亮样式进行展示；增加了图片拖拽功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的KaTeX数学公式语法；增加了支持甘特图的mermaid语法1功能；增加了多屏幕编辑Markdown文章功能；增加了焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置等功能，功能按钮位于编辑区域与预览区域中间；增加了检查列表功能。 功能快捷键 撤销：Ctrl/Command+Z重做：Ctrl/Command+Y加粗：Ctrl/Command+B斜体：Ctrl/Command+I标题：Ctrl/Command+Shift+H无序列表：Ctrl/Command+Shift+U有序列表：Ctrl/Command+Shift+O检查列表：Ctrl/Command+Shift+C插入代码：Ctrl/Command+Shift+K插入链接：Ctrl/Command+Shift+L插入图片：Ctrl/Command+Shift+G查找：Ctrl/Command+F替换：Ctrl/Command+G 合理的创建标题，有助于目录的生成 直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式 强调文本强调文本 加粗文本加粗文本 标记文本 删除文本 引用文本 H2Ois是液体。 210运算结果是1024. 插入链接与图片 链接:link. 图片: 带尺寸的图片: 居中的图片: 居中并且带尺寸的图片: 当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。 如何插入一段漂亮的代码片 去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的代码片. //Anhighlightedblock varfoo='bar'; 生成一个适合你的列表 项目 项目 项目 项目1项目2项目3 计划任务完成任务 创建一个表格 一个简单的表格是这么创建的： 项目Value电脑$1600手机$12导管$1 设定内容居中、居左、居右 使用:---------:居中使用:----------居左使用----------:居右 第一列第二列第三列第一列文本居中第二列文本居右第三列文本居左 SmartyPants SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如： TYPEASCIIHTMLSinglebackticks'Isn'tthisfun?'‘Isn’tthisfun?’Quotes"Isn'tthisfun?"“Isn’tthisfun?”Dashes--isen-dash,---isem-dash–isen-dash, isem-dash 创建一个自定义列表 Markdown Text-to- HTMLconversiontool Authors John Luke 如何创建一个注脚 一个具有注脚的文本。2 注释也是必不可少的 Markdown将文本转换为HTML。 KaTeX数学公式 您可以使用渲染LaTeX数学表达式KaTeX: Gamma公式展示 Γ ( n ) = ( n − 1 ) ! ∀ n ∈ N \Gamma(n)=(n-1)!\quad\foralln\in\mathbbN Γ(n)=(n−1)!∀n∈N是通过欧拉积分 Γ ( z ) = ∫ 0 ∞ t z − 1 e − t d t . \Gamma(z)=\int_0^\inftyt^{z-1}e^{-t}dt\,. Γ(z)=∫0∞​tz−1e−tdt. 你可以找到更多关于的信息LaTeX数学表达式here. 新的甘特图功能，丰富你的文章 Mon06 Mon13 Mon20 已完成 进行中 计划一 计划二 现有任务 AddingGANTTdiagramfunctionalitytomermaid 关于甘特图语法，参考这儿, UML图表 可以使用UML图表进行渲染。Mermaid.例如下面产生的一个序列图： 张三 李四 王五 你好！李四,最近怎么样? 你最近怎么样，王五？ 我很好，谢谢! 我很好，谢谢! 李四想了很长时间,文字太长了 不适合放在一行. 打量着王五  很好 王五,你怎么样? 张三 李四 王五 这将产生一个流程图。: 链接 长方形 圆 圆角长方形 菱形 关于Mermaid语法，参考这儿, FLowchart流程图 我们依旧会支持flowchart的流程图： CreatedwithRaphaël2.2.0 开始 我的操作 确认？ 结束 yes no 关于Flowchart流程图语法，参考这儿. 导出与导入 导出 如果你想尝试使用此编辑器,你可以在此篇文章任意编辑。当你完成了一篇文章的写作,在上方工具栏找到文章导出，生成一个.md文件或者.html文件进行本地保存。 导入 如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。 mermaid语法说明↩︎注脚的解释↩︎ 

HITCSAPP·Hello的一生 摘 要 本文通过展示hello程序的生命周期，深刻揭示了与计算机系统相关的概念、理论、技术与实现，详述了计算机的内部机制。Hello的一生可划分为2个阶段： 编译阶段：由高级语言程序编译为可执行程序运行阶段：结合进程管理、存储管理、I/O管理走完它的一生 关键词：预处理；编译；汇编；链接；进程；内存管理；I/O管理 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P：hello.c经cpp、ccl、as、ld处理转换得可执行目标文件hello，在shell中键入./hello1190200525刘祥龙，shell1为其fork一个子进程；如此便完成了hello从程序到进程的转变。 O2O：shell调用execve，execve调用启动加载器，映射虚拟内存，设置当前进程上下文中的程序计数器，使之指向程序入口地址；进入程序入口程序后开始载入物理内存，然后进入main函数执行目标代码。程序运行结束后父进程回收hello，内核删除相关数据结构。 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 ·硬件：X64CPU；2GHz；2GRAM；256GHDDisk以上 ·软件：Windows1064位，Ubuntu20.04LTS64位 ·开发工具：VisualStudioCode，GCC，objdump，EDB，readelf 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 hello.i：预处理后的文本文件 hello.s：汇编后的文本文件 hello.o：编译后的可重定位文件 hello.elf：hello.o的elf文件 hello.txt:hello的反汇编代码文本 linkhello.elf:hello的elf文件 linkhello.txt：hello的反汇编代码文本 hello：最终的可执行目标文件 1.4本章小结 本章主要介绍了hello的P2P与O2O过程，并说明、展示了实验的软硬件平台与中间结果文件。 第2章预处理 2.1 预处理的概念与作用 概念：预处理阶段，预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。 C语言目前提供了3种预处理功能： ·宏定义处理 ·文件包含处理 ·条件编译处理 作用： （1）用实际值替换符号常量 （2）读取系统头文件的内容，并将其直接插入到程序文本中 （3）处理条件编辑指令，决定需要编译的代码 此过程不会对程序的源代码进行解析，但也会删除程序中的注释及多余的空白字符。 2.2在Ubuntu下预处理的命令 命令：gcchello.c-E-ohello.i 2.3Hello的预处理结果解析 经预处理后，cpp将源文件hello.c翻译为文本文件hello.i 使用cat指令抓取文件内容后发现：文件内容增加，进行了宏展开，并将头文件中的内容插入到文本文件中；此时仍为可阅读的C语言文本。 2.4本章小结 本章主要介绍了C语言文件编译的预处理过程；从预处理的概念、作用及预处理结果这3大方面进行介绍。第3章编译 3.1编译的概念与作用 概念： 编译器（ccl）将文本文件hello.i翻译为文本文件hello.s，其包含一个汇编语言程序。 作用： （主要功能）将源程序翻译为汇编语言程序。进行语法分析、词法分析及目标代码生成。进行目标程序优化，提高程序性能。 3.2在Ubuntu下编译的命令 命令：gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 3.3.0指令及其内容 3.3.1数据 ·整型： （1）已初始化的全局变量sleepsecs存储在.data节，设置为long型，且值为2 立即数：在汇编代码中直接以“$”的形式标记Main函数参数argc：存储于栈空间中 ·字符串： 以全局变量的形式保存，存储于.rodata节 ·局部变量： 局部变量i保存在-4（%rbp）中，即栈中 ·全局变量： 3.3.2赋值 使用mov语句给局部变量i赋值 3.3.3类型转换 对全局变量sleepsecs的值进行隐式的类型转换（由2.5重新赋值为2） 3.3.4算术操作 指令功能leaA,BB=&AaddA,BB+=AsubA,BB-=AmulA,BB*=AincAA++decA A-=1negAA=-A 3.3.5关系操作 使用cmp语句进行关系比较 jmp的条件跳转语句也可进行关系比较 3.3.6逻辑操作 汇编语言中的逻辑操作由算术与赋值操作实现 3.3.7数组/指针操作 （1）数组：利用在栈帧中位置，通过(%rax)和%rax+8，分别得到argv[1]和argc[2]两个字符串 指针：使用mov指令获得argv[0]指针的地址 3.3.8控制转移 使用cmp语句设置条件码，根据条件码利用jmp语句进行跳转 3.3.9函数操作 使用call指令调用函数 3.4本章小结 介绍了编译的概念与作用，着重分析介绍了汇编指令，并就hello.s中的语句进行了分析。展示了编译器是如何根据C语言不同的数据类型与操作将.i文件翻译为.s文件。 第4章汇编 4.1汇编的概念与作用 概念：汇编器（as）将.s文件翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存到目标文件hello.o中（二进制文件） 作用：将汇编代码转换为机器指令，使其在链接后能被机器识别并执行 4.2在Ubuntu下汇编的命令 命令：gcc-chello.s-ohello.o 4.3可重定位目标elf格式 命令：readelf-ahello.o>hello.elf ·elf头: 命令：readelf-hhello.o Elf头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。Elf头剩余部分包含帮助链接器语法分析和解释目标文件的信息。其中包含elf头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小及数量。 ·节头部表 命令：readelf-Shello.o 节头部表记录各节名称、类型、地址、偏移量、大小、全体大小、旗帜、链接、信息、对齐等信息。 ·符号表 命令：readelf-shello.o 符号表存放在程序中定义和引用的函数及全局变量的信息。每个可重定位目标文件在.symtab这都有一张符号表，但其不包含局部变量的条目。 ·重定位节 命令：readelf-rhello.o 重定位节.rela.text: 一个.text节中位置的列表。当链接器把这个目标文件和其他文件组合时需要修改这些位置。一般而言，任何调用外部函数或引用全局变量的指令都需要修改，而调用本地函数的指令不需要修改。 偏移量：相对节头的偏移 信息：在符号表中的标号及类型 类型：重定位方式 此程序中需要被重定位的是printf,puts,exit,sleepsecs,getchar,sleep,rodata中的.L0及.L1 4.4Hello.o的结果解析 命令：objdump-d-rhello.o >hello.txt ·hello.o的反汇编代码： ·hello.s hello.o与hello.s代码在整体上区别不大；汇编代码及反汇编代码的差异主要体现在以下3个方面： 访问全局变量：汇编代码使用.LC0(%rip)访问全局变量，而汇编代码使用0x0（%rip）（因反汇编代码需要重定位）分支转移：汇编代码的分支跳转直接以助记符的形式表示，而反汇编中直接跳转到确定的地址函数跳转：汇编代码中的函数跳转形式为：call+函数名；而反汇编代码中call后直接指向下一条指令，且以main+偏移量的方式进行跳转。 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 4.5本章小结 介绍了汇编阶段的概念及作用，展示了hello.s到hello.o的汇编过程，介绍如何使用readelf工具观测、分析elf文件；利用objdump得到hello的反汇编代码，并与其汇编代码进行比较。充分展示了汇编代码与反汇编代码的异同。 第5章链接 5.1链接的概念与作用 概念：将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可执行于编译时、加载时、运行时。在现代系统中，链接由叫链接器的程序自动执行。 作用： （1）使得分离编译成为可能。不必再将一个大型的应用程序组织为一个巨大的源文件，而是可以将其分解为更小、更好管理的模块，可以独立的修改、编译这些模块。 （2）提高效率。当需要改变模块中的一个时，只需简单的重新编译它，并重新链接应用，而不必重新编译其他文件 （3）可利用共享库 5.2在Ubuntu下链接的命令 命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 命令：readelf-ahello>linkhello.elf ELF头： 相较于可重定位目标文件的elf头： ·类型变为可执行文件 ·可执行目标文件的elf头中节头数量增长至27 ·程序头大小变为56 ·指明程序入口点地址 文件头信息： ·.ref节已完成重定位，偏移量offset已给出，虚拟地址的起始地址已给出 重定位节： ·完成重定位 符号表： ·条目增加至51条 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 通过datadump查看加载到虚拟地址的程序代码知hello的虚拟地址空间开始于0x400000，结束于0x400ff0 与5.3对照知edb中观察到的每个节的地址与程序头中所对应的address均相同。 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 命令：objdump-d-rhello>linkhello.txt Hello反汇编 Hello.o反汇编 Hello反汇编 ·不同点： 指令地址不同；hello反汇编代码具有确定的虚拟地址，而hello.o的反汇编代码不具有确定的虚拟地址。（hello中函数调用、跳转的地址均变成虚拟地址）Hello中增加了.init与.plt节及相应的部分函数Hello中无重定位条目，而hello.o反汇编代码中含重定位条目Hello中对全局变量的访问经过重定位，而hello.o中对全局变量的访问是$0x0及0（%rip）。 ·链接过程： 链接器：（1）符号解析（2）重定位 静态链接：目标文件直接链接进入可执行程序 动态链接：在程序启动后才动态加载目标文件 ·hello重定位详述：（合并输入模块，并为每个符号分配运行时地址） 重定位节和符号定义： 链接器将所有相同类型的节合并为同一类型的新的聚合节链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号此步骤完成后，hello程序中的每条指令和全局变量都有唯一的运行时内存地址 重定位节中的符号引用 链接器依据重定位条目修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址。 5.6hello的执行流程 （以下格式自行编排，编辑时删除） 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 子程序名地址_dl_init0x7f944cc65c10hello!_start+00x00000000004010d0libc-2.31.so!__libc_start_main+00x00007f944ca71fc0libc-2.31.so!__cxa_atexit+00x00007f944ca94f60 hello!__libc_csu_init+00x0000000000401190libc-2.31.so!_setjmp+00x00007f944ca90e00hello!main+00x0000000000401105hello!puts@plt+00x0000000000401030hello!exit@plt+00x0000000000401060 5.7Hello的动态链接分析 （以下格式自行编排，编辑时删除） 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 dl_init前： dl_init后： ·在进行动态链接前先进行静态链接，生成部分链接的可执行目标文件hello，此文件中有对定义在共享库中的例程和数据的未解析的引用 ·在加载时，加载器将部分链接的可执行文件映射到内存 ·调用动态链接器，通过加载共享库和重定位程序中的引用来完成链接任务。 被编译为位置无关代码的共享库可以加载到任何地方，也可在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序也可在运行时使用动态链接器。 5.8本章小结 详细介绍了链接的概念及作用，展示并分析了hello的elf文件。使用edb查看了hello的虚拟地址空间，详述了链接过程，尤其是重定位过程；最后展示了hello的执行流程及动态链接过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是又程序正确运行所需的状态组成。此状态包括存放在内存中程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量及打开文件描述符的集合。 作用： ·一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占的使用处理器 ·一个私有的地址空间，提供一个假象，好像我们的程序独占的使用内存系统 6.2简述壳Shell-bash的作用与处理流程 定义：交互型的应用级程序，代表用户运行其他程序；shell执行一系列读、求值步骤，然后终止。 功能：shell应用程序提供了一个界面，用户通过访问这个界面访问操作系统内核的服务。 处理流程： ·从终端读入输入的命令。 ·将输入字符串切分获得所有的参数 ·如果是内置命令则立即执行；否则调用相应的程序、为其分配子进程执行 ·shell应该接受键盘输入信号，并对这些信号进行相应处理 6.3Hello的fork进程创建过程 创建：父进程通过调用fork函数创建一个新的、处于运行状态的子进程 ·子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本（包括代码和数据段、堆、共享库及用户栈） ·子进程获得与父进程任何打开文件描述符相同的副本（共享文件） ·子进程有不同于父进程的PID ·父子进程并发执行、具有相同但是独立的地址空间 ·fork函数调用一次返回两次（一次返回父进程，一次返回到新创建的子进程） hello的fork过程如下： ·在shell输入：./hello1190200525刘祥龙 ·由于./hello不是shell内置命令，而是经过编译系统的可执行文件；故shell为当前进程fork一个子进程 ·将hello载入内存，开始执行 6.4Hello的execve过程 execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。 ·创建子进程后，execve函数在当前进程的上下文中加载并运行一个新程序，此即hello程序。 ·hello程序通过调用execve函数调用加载器 ·加载器将可执行目标文件hello的代码和数据从磁盘复制到内存，然后通过跳转到程序的第一条指令或入口点来运行该程序。 （具体而言： （1）加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。 （2）新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。 （3）最后加载器设置PC指向_start地址，_start最终调用hello中的main函数。 ） 6.5Hello的进程执行 （以下格式自行编排，编辑时删除） 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 ·进程上下文信息： 上下文就是内核重新启动一个先前被抢占了的进程所需的状态。此状态包含存放在内存中的程序的代码及数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、打开文件描述符的集合。 ·调度： 在程序运行的某系时刻，内核决定抢占当前进程，并重新开始一个先前被抢占进程。 在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。 ·上下文切换： 保存当前上下文恢复先前某个被抢占的进程被保存的上下文将控制传递给中国新恢复的进程 ·时间片： 一个进程执行它的控制流的一部分的每一时间段叫做时间片。 ·用户模式与内核模式： 处理器用某个控制寄存器中的一个模式位来限制一个应用可以执行的指令及它可以访问的地址空间范围。 当设置了模式位时，进程就运行在内核模式中。 未设置模式位时，进程就运行在用户模式中。 ·hello的进程执行过程： 最初hello运行在用户模式下，输出“Hello1190200525刘祥龙” hello调用sleep函数、陷入内核模式、处理休眠请求（定时器开始计时），内核将控制通过上下文切换机制转移给其他进程（进入用户模式）。 定时器发送中断信号，进入内核模式，内核中中断处理程序处理中断，并再次进行上下文切换，将控制返回给hello。 在用户状态下，继续执行hello程序。 （hello在调用getchar函数时，也会执行上下文切换） 总而言之： 在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。 6.6hello的异常与信号处理 （以下格式自行编排，编辑时删除） hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 hello程序执行过程可能出现的异常一共有四种：中断、陷阱、故障、终止。·中断：来自I/O设备的信号，异步发生，总是返回到下一条指令。 hello程序执行过程中可能会出现外部I/O设备引起的异常·陷阱：有意的异常，同步发生，总是返回到下一条指令。 hello调用getchar函数时会触发此异常·故障：潜在可恢复的错误，同步发生，可能返回到当前指令或终止。 hello程序运行时可能会出现缺页异常的情况·终止：不可恢复的错误，同步发生，不会返回。 hello程序运行过程中硬件系统发生的一些错误可能会导致终止 正常执行hello程序： Ctrl+c终止： 键入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，（默认）终止前台作业 Ctrl+z暂停： 键入Ctrl+z将（默认）挂起前台的作业，hello进程此时并没有被回收，而是运行在后台 程序运行过程中乱按键盘： 无关输入被缓存到stdin，并随着printf指令被输出。 （5）输入ps打印当前进程的状态 （6）输入jobs列出当前作业 输入pstree打印进程树 输入fg1，继续执行前台进程1 输入kill，杀死hello 6.7本章小结 详细介绍了进程的概念、功能与作用，并展示了shell的处理流程。与此同时，详述hello程序调用fork创建新进程、调用execve函数加载、执行hello的过程。着重展示了hello的进程执行过程及hello的异常及信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 （以下格式自行编排，编辑时删除） 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 ·逻辑地址:逻辑地址是指由程序产生的与段相关的偏移地址部分。表示为[段标识符：段内偏移量]。hello.o里面的相对偏移地址即是逻辑地址。（又称相对地址） ·线性地址:逻辑地址经过段机制转化后为线性地址，用于描述程序分页信息的地址。（是逻辑地址与物理地址间转化过程中的一个环节）以hello为例，线性地址表明hello应该在内存的哪些块上运行。 ·虚拟地址:为了方便加载与链接，将物理地址映射为虚拟地址。虚拟内存为每个进程提供了一致的地址空间，即虚拟地址空间，CPU在虚拟地址空间上的生成的地址即为虚拟地址。比如在将hello.o链接的时候hello.o文件中的main函数的地址即是虚拟地址。 ·物理地址:CPU通过地址总线的寻址，找到真实的物理内存对应地址（又称绝对地址）；是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址直接成为物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址实际是由48位组成的，前16位包括段选择符，后32位为段内偏移量；段选择符前13位为索引，通过索引（依据TI取值）在描述符表（GDT：全局描述符表；LDT：局部描述符表）中找寻到32位段基地址，段基地址与段内偏移量相加即得线性地址。（32位） 7.3Hello的线性地址到物理地址的变换-页式管理 n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移(VPO),和一个n-p位的虚拟页号(VPN)，MMU利用VPN选择适当的PTE，（eg.VPN0选择PTE0,VPN1选择PTE1)。根据PTE中有效位的信息可知虚拟页是否被缓存，如果虚拟页已缓存，那直接将页表条目的物理页号和虚拟地址的VPO串联起来就得到一个相应的物理地址。（此处VPO和PPO相同）。如果虚拟页是未缓存的，会触发一个缺页故障。调用一个缺页处理子程序将磁盘的虚拟页重新加载到内存中，然后再执行这个导致缺页的指令。 7.4TLB与四级页表支持下的VA到PA的变换 CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（TLB标记）+TLBI（TLB索引）访问、查询TLB中是否缓存有相应的PTE；如果TLB命中，则得到PPN，与VPO组合获得PA。如果TLB未命中，MMU向页表中查询，CR3包含L1页表的物理地址，VPN1提供一个L1PTE的偏移量，这个PTE包含L2页表的基地址，VPN2提供一个L2PTE的偏移量，以此类推，最终在第四级页表中查询到PPN的值，与VPO组合获得PA，并且向TLB中添加条目。如果查询PTE的时候发现不在物理内存中，则将引发缺页故障。 7.5三级Cache支持下的物理内存访问 ·CPU产生虚拟地址VA。 ·MMU使用VPN在TLB中找寻PTE，若TLB命中，得到PPN与VPO组合得到PA；若TLB不命中，利用VPN的多级页表机制到内存中找到对应的物理页号PPN，与VPO组合得到PA。 ·PA分为PPN和PPO两部分。利用PPO，将其分成CI和CO，CI作为cache组索引，CO作为块偏移，PPN即是缓存组标志CT，利用CI进行组索引，将CT与标志位进行比较，若相同（即命中）则把偏移量CO处的数据字节传给MMU，随后将其传给CPU；不命中时则访问下一级缓存。 ·先访问一级缓存，不命中时访问二级缓存，再不命中访问三级缓存，再不命中访问主存，如果主存缺页则访问硬盘。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并为它分配一个唯一的PID。为给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任何一个后来进行写操作时，写时复制机制就会创建新页面，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： ·删除已存在的用户区域。 ·映射私有区域。为新程序的代码、数据、bss和栈区域创建新的结构区域。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text区和.data区。Bss区域是请求二进制零的，初始长度为0。 ·映射共享区域。若hello程序与共享对象链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 ·设置PC。使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障：（即DRAM缓存不命中） 当指令引用一个相应的虚拟地址，而与该地址相对应的物理页面不在内存中，会触发缺页异常。 缺页异常将调用内核中的缺页异常处理程序，将执行以下操作： ·判断虚拟地址是否合法，若不合法，则产生一个段错误，然后终止这个进程。 ·判断内存访问是否合法，若访问是不合法的，那么缺页处理程序会触发一个保护异常，终止这个进程。 ·若操作合法，选择一个牺牲页面，如果这个牺牲页面未被修改过，那么就将它交换出去，换入新的页面并更新页表。然后将控制转移给hello进程，再次执行触发缺页故障的指令。 7.9动态存储分配管理 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 方法： 动态内存分配器维护着一个进程的虚拟内存区域，称为堆；分配器将堆视为是一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。 已分配的块显式的保留为供应用程序使用。空闲块可用来分配。一个已分配的块保存已分配的状态，直至它被释放。一个空闲的块将保持空闲，直到它显式的被应用所分配。 策略： ·显式分配器：要求应用显式地释放任何已分配的块 ·隐式分配器：分配器检测到一个已分配块何时不再被程序所使用，而自动释放这个块。 显式分配器约束条件： ·处理任意请求序列 ·立即响应请求 ·只使用堆 ·对齐块 ·不修改已分配的块 目标： ·最大化吞吐率 ·最大化内存利用率 堆中块组织形式： ·隐式空闲链表： 空闲块通过头部中的大小字段隐含的连接着的。分配器可以通过遍历堆中所有的块，从而间接的遍历整个空闲块的集合；需要以特殊标记结束块。 块放置策略： 首次适配（2）下一次适配（3）最佳适配 块合并策略： （1）立即合并（2）推迟合并 ·显式空闲链表： 将空闲块组织为某种形式的显式数据结构。将堆组织成一个双向空闲链表，在每个空闲块中，都包含一个先驱与后继指针。 块排序策略： 用后进先出的顺序维护链表（2）按地址顺序维护链表 空闲链表分离策略： （1）简单分离存储（2）分离适配（3）伙伴系统 7.10本章小结 从以下几个方面介绍了hello的存储管理： 存储器的4种地址空间、逻辑地址、虚拟地址、物理地址的转换流程及管理模式（段式管理、页式管理）基于TLB的地址翻译、物理内存访问hello进程fork时及execve时的内存映射缺页故障与缺页中断处理的流程动态存储分配管理 其中详细展示了（3）（6）模块的内容。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 一个Linux文件就是一个m字节的序列： 所有的I/O设备（例如网络、磁盘、终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。 设备管理：unixio接口 将设备优雅的映射为文件，允许Linux内核引出一个简单、低级的应用接口 8.2简述UnixIO接口及其函数 UnixIO接口使得所有的输入、输出都能以一种统一且一致的方式来执行： ·打开文件 ·shell创建的每个进程开始时都有3个打开的文件：标准输入、标准输出、标准错误 ·改变当前的文件位置 ·读写文件 ·关闭文件 相关函数： ·进程通过调用open函数来打开一个已存在的文件或创建一个新文件： Open函数将filename转换为一个文件描述符，并返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。Flags参数指明了进程打算如何访问这个文件。 ·接下来，下面的代码片段创建一个新文件，该文件的拥有者有读写权限，而所有其他的用户都有读权限： umask（DEF_UMASK）; fd=Open（“foo.txt”,O_CREAT|O_TRUNC|O_WRONLY,DEF_MODE）; ·最后，进程通过调用close函数关闭一个打开的文件。 intclose（intfd）; ·应用程序分别调用read、write函数来执行输入、输出。 ·通过调用rio_readn和rio_writen函数，应用程序可以在内存和文件之间直接传送数据。 #include“csapp.h” ssize_trio_readn（intfd,void*usrbuf, size_tn）; ssize_trio_writen（intfd,void*usrbuf,size_tn）; 返回：若成功则为传送的字节数，若为EOF则为0（只对rio_readn而言），若出错则为-1 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html ·从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. ·字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 ·显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 Printf函数代码如下： Printf函数接受一个格式字符串fmt，之后是一个变参列表。后面每一个参数均 对应这格式字符串中的一个格式符。Printf函数分别调用两个函数：vsprintf和write。 vsprintf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。在printf中调用系统函数write(buf,i)将长度为i的buf输出。 故printf的实现就是：用参数匹配格式字符串，然后用vsprintf将结果字符串整理，最后用write函数输出。 vsprintf函数： 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 getchar函数源代码： getchar函数调用系统函数read，该函数将整个缓冲区读入到buf中，后取出缓冲区内第一个字符作为结果。 8.5本章小结 本章主要介绍了IO设备管理方法、UnixI/O接口及其函数；同时也对printf函数与getchar函数的实现进行了简要分析. 结论 用计算机系统的语言，逐条总结hello所经历的过程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 Hello的一生曾这样走过： ·编程：在codeblocks或virtualstudio环境下编写、开发hello的C语言代码，生成hello.c文件 ·预处理：cpp根据以字符#开头的命令，修改原始C程序；读取并将系统头文件的内容直接插入程序文本、生成hello.i文件 ·编译：ccl将.i文件翻译为.s文件，其包含一个汇编语言程序 ·汇编：as将hello.s文件翻译为机器语言指令，将这些指令打包装入可重定位目标程序hello.o ·链接：ld将可重定位目标文件hello.o与动态链接库链接成可执行目标文件hello，hello可被加载到内存中由内存执行。 至此，Hello经过编译系统，实现了从高级语言程序到可执行语言程序的转变。 接下来，hello将开启新的篇章。 ·运行：在shell上键入：./hello1190200525刘祥龙 ·创建子进程：由于在终端键入的非shell内置命令，故将调用fork函数创建一个子进程。 ·加载：shell调用execve，execve调用启动加载器，映射虚拟内存，设置当前进程上下文中的程序计数器，使之指向程序入口地址；进入程序入口程序后开始载入物理内存，然后进入main函数。 ·访存与缺页：CPU生成虚拟地址，CPU上的MMU将联合TLB将虚拟地址翻译为物理地址，此时可能会触发缺页故障，将调用异常处理程序。 ·执行指令：在一个时间片内进程享有CPU资源，可执行自己的逻辑控制流 ·上下文切换：在hello的运行过程中，CPU不断切换上下文，使运行过程被切分成时间片，hello将与其他进程交替占用CPU，以实现进程的调度。 ·信号处理：键入Ctrlz挂起当前进程，键入Ctrlc终止当前进程。 ·动态内存申请：当hello程序执行printf函数时，将调用malloc函数向动态内存分配器申请分配堆中的内存。 ·结束：当子进程hello执行完成时，内核安排父进程回收子进程，将子进程退出状态传递给父进程。内核删除为此进程创建的所有数据结构。 至此，hello走到了生命的尽头，结束了它波澜壮阔的一生。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 hello.i：预处理后的文本文件 hello.s：汇编后的文本文件 hello.o：编译后的可重定位文件 hello.elf：hello.o的elf文件 hello.txt:hello的反汇编代码文本 linkhello.elf:hello的elf文件 linkhello.txt：hello的反汇编代码文本 hello：最终的可执行目标文件 参考文献 为完成本次大作业你翻阅的书籍与网站等 https://blog.csdn.net/weixin_36277197/article/details/116987253? C语言中编译预处理命令的作用有哪些，C语言系列 预处理命令https://blog.csdn.net/Hanani_Jia/article/details/81735517? gcc编译程序四个阶段预处理、编译、汇编、链接https://blog.csdn.net/qq_14892521/article/details/103460609? 连接过程详述https://blog.csdn.net/qq_42192672/article/details/82937667? 初识edbdebuggerhttps://blog.csdn.net/genghaihua/article/details/89450057? 物理地址和逻辑地址https://blog.csdn.net/mzjmzjmzjmzj/article/details/84713351? 通俗理解CPU中物理地址、逻辑地址、线性地址、虚拟地址、有效地址的区别https://blog.csdn.net/Pipcie/article/details/105670156? 段页式访存 逻辑地址到线性地址的转换兰德尔E.布莱恩特，大卫R.奥哈拉伦深入理解计算机系统（第三版） 

计算机系统大作业程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机大类学 号119xxxxxxx班 级1903xxx学生 指导教师 计算机科学与技术学院2021年6月摘要本文较为完整地介绍了hello这一较为简单的c程序的运行过程。查阅各类资料，利用ubuntu中的分析工具观察运行结果，并进行了较为全面的分析。 关键词：计算机系统；Ubuntu；c语言； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-5-1.1HELLO简介-5-1.2环境与工具-5-1.3中间结果-5-1.4本章小结-6-第2章预处理-7-2.1预处理的概念与作用-7-2.2在UBUNTU下预处理的命令-8-2.3HELLO的预处理结果解析-8-2.4本章小结-9-第3章编译-10-3.1编译的概念与作用-10-3.2在UBUNTU下编译的命令-10-3.3HELLO的编译结果解析-10-3.3.1常量-10-3.3.1.1字符串-10-3.3.1.2各种立即数-10-3.3.2变量-11-3.3.2.1全局变量-11-3.3.2.2局部变量-11-3.3.2.3传入main函数的参数-11-3.3.3表达式-11-3.3.3.1赋值表达式-12-3.3.3.2算数表达式-12-3.3.3.3关系比较和转移操作-12-3.3.3.4函数调用和返回-12-3.4本章小结-13-第4章汇编-14-4.1汇编的概念与作用-14-4.2在UBUNTU下汇编的命令-14-4.3可重定位目标ELF格式-14-4.4HELLO.O的结果解析-15-4.5本章小结-17-第5章链接-18-5.1链接的概念与作用-18-5.2在UBUNTU下链接的命令-18-5.3可执行目标文件HELLO的格式-18-5.4HELLO的虚拟地址空间-20-5.5链接的重定位过程分析-21-5.6HELLO的执行流程-23-5.7HELLO的动态链接分析-23-5.8本章小结-24-第6章HELLO进程管理-25-6.1进程的概念与作用-25-6.2简述壳SHELL-BASH的作用与处理流程-25-6.3HELLO的FORK进程创建过程-25-6.4HELLO的EXECVE过程-26-6.5HELLO的进程执行-26-6.6HELLO的异常与信号处理-27-6.7本章小结-29-第7章HELLO的存储管理-30-7.1HELLO的存储器地址空间-30-7.2INTEL逻辑地址到线性地址的变换-段式管理-30-7.3HELLO的线性地址到物理地址的变换-页式管理-31-7.4TLB与四级页表支持下的VA到PA的变换-33-7.5三级CACHE支持下的物理内存访问-35-7.6HELLO进程FORK时的内存映射-36-7.7HELLO进程EXECVE时的内存映射-36-7.8缺页故障与缺页中断处理-36-7.9动态存储分配管理-37-7.9.1动态内存分配地基本原理-37-7.9.2隐式空闲链表原理-38-7.9.3显示空闲链表原理-39-7.10本章小结-40-第8章HELLO的IO管理-41-8.1LINUX的IO设备管理方法-41-8.2简述UNIXIO接口及其函数-41-8.3PRINTF的实现分析-42-8.4GETCHAR的实现分析-44-8.5本章小结-45-结论-45-附件-47-参考文献-48- 第1章概述1.1Hello简介P2P： Hello.c文件经过预处理、编译、汇编和链接过程，最终形成了可执行文件。用户在终端中输入./hello命令，shell调用fork函数为其创建一个新的进程。O2O：创建好新的进程后，shell调用execve函数，进行虚拟内存映射，载入物理内存。随后进入可执行文件中的代码段，进入main函数开始程序的运行。运行过程中进行信号处理、上下文切换等操作，最终程序执行完毕。父进程回收子进程，内核删除相关数据结构。1.2环境与工具硬件环境：IntelCorei7-9750HCPU；2.60GHz；8GBRAM软件环境：Windows1064位；Ubuntu16.04LTS64位开发与调试工具：gcc；edb；gdb；objdump；readelf；codeblocks1.3中间结果 Hello程序的可执行文件Hello.c程序c源文件Hello.i程序的预处理后的文件Hello.o程序汇编后的文件Hello.s程序编译后的文件 1.4本章小结本章主要交代了实验的大概内容，用到的工具，实验使用到的环境。（第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理的概念：预处理指的是在读入源程序后，预处理器（cpp）处理.c文件根据预处理指令修改原始文件，生成.i文件这一过程。预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。预处理指令分类及其功能：#include包含一个源代码文件#define定义宏#undef取消已定义的宏#if如果给定条件为真，则编译下面代码#ifdef如果宏已经定义，则编译下面代码#ifndef如果宏没有定义，则编译下面代码#elif如果前#if条件不为真，当前条件为真，则编译下面代码，其实就是elseif的简写#endif结束一个#if……#else条件编译块#error停止编译并显示错误信息主要分为三种功能：1、宏定义：宏定义又称为宏代换、宏替换，简称“宏”。预处理（预编译）工作也叫做宏展开：将宏名替换为字符串，即在对相关命令或语句的含义和功能作具体分析之前就要换。#define标识符字符串2、文件包含：文件包含处理是指在一个源文件中，通过文件包含命令将另一个源文件的内容全部包含在此文件中。在源文件编译时，连同被包含进来的文件一同编译，生成目标目标文件。#include"文件名"3、条件编译：条件编译指令将决定哪些代码被编译，而哪些不被编译的。可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件。#if/#endif/#else/#elif指令 2.2在Ubuntu下预处理的命令 命令：gcc-m64-no-pie-fno-PIChello.c-E-ohello.i（根据ppt中提供的不同设置参数） 2.3Hello的预处理结果解析 在本实验中给的hello.c文件中，只有三条文件包含类型的预处理指令，在进行预处理后生成了一个文本文件，其中按照系统路径将很多库文件引入，为后面的编译等操作做好准备。2.4本章小结本章主要介绍的是hello.c文件处理的第一步预处理操作，并通过实际测试观察了处理后的文件内容，其主要实现了对外部库文件的处理。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译的概念：编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。编译的作用：基本功能是把源程序(高级语言)翻译成目标程序。除了基本功能之外，编译程序还具备语法检查、调试措施、修改手段、覆盖处理、目标程序优化、不同语言合用以及人际联系等重要功能。 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析3.3.1常量3.3.1.1字符串 3.3.1.2各种立即数 例如本段代码中的$32、$3等。3.3.2变量3.3.2.1全局变量 在函数中定义的int类型sleepsecs变量，虽然定义给到的内容是2.5，但是在程序中小数部分被舍弃，只留下了2。3.3.2.2局部变量 这一部分是对循环变量i在进行操作，比较i是否<=9来进行循环，并且每次循环都对i进行加1操作。3.3.2.3传入main函数的参数 此处对argc进行判断，与3进行比较。 此处引用了argv数组，作为printf函数的参数。Argv数组的起始地址位于-32(%rbp)中，通过对这一地址进行+16和+8分别获取argv[2]和argv[1]，并将它们保存在%rdx和%rsi中。3.3.3表达式3.3.3.1赋值表达式包括有movl、movq分别是对4个字节和8个字节的数据进行赋值操作。3.3.3.2算数表达式subq减法操作，其在计算argv地址时使用。addl、addq加法操作，其在对局部变量更改时使用。3.3.3.3关系比较和转移操作 这两处相互对应，在汇编代码中利用cmpl操作实现对两个值的比较设置条件码，并利用je进行跳转实现if控制。 这两处相互对应，在循环过程中，i作为循环变量，汇编代码中利用cmpl实现其与9的比较，并且在小于等于9时进行跳转，实现与10的比较。3.3.3.4函数调用和返回 这两部分相互对应，当argc的值不等于3时，进入if中的代码，调用printf函数和exit函数，在汇编代码中表现为callputs和callexit操作。 进入到循环代码中，程序调用printf和sleep。对于printf来说需要argv[2]和argv[1]两个参数，在汇编代码中通过从-32(%rbp)中获取argv的首地址，并经过计算最终得到这两个参数，并将其传入到rdx和rsi中，随后直接调用printf完成函数调用。对于sleepsecs来说，只需要传入sleepsecs参数，在汇编代码中传入到rdi中，再使用call指令完成函数调用。 循环最终结束，调用getchar，也就是callgetchar结束。 在main函数返回时，出现leav指令，这一指令代表将rsp的值变为其进入main函数时的值，也将rbp还原成旧值，如此操作可以将函数栈中的状态恢复到前一个函数的状态，为后续返回做准备。 最终程序通过ret返回到调用它的函数中。 3.4本章小结本章主要进行了编译的操作，分析了程序的汇编代码，对程序的实际机器中的代码进行了解析。（第3章2分） 第4章汇编4.1汇编的概念与作用汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。直接通过readelf-a指令获取全部可重定位目标文件信息。1、ELF头 ELF头中包含生成该文件的系统的字的大小和字节顺序、ELF头的大小、目标文件的类型、机器类型、街头不表的文件偏移、节头部表中条目的大小和数量。例如本程序中，可以看到ELF头的大小为64字节，机器的类型为x86-64、此文件为可重定位文件、节头部表的起始位置在1176字节处、共有14个条目、并且每一个节都是64个字节、字符串表位于节头表的第13位等信息。2、节头部表 节头部表中包含各个节的名称、大小、可以进行的操作（属性）、类型、位置、对齐信息等信息。由于目前是可重定位文件，所以目前虚拟地址信息都是零，在未来链接后将会变为具体的虚拟地址。3、重定位节 这一部分在进行重定位时十分重要。这一部分有完整的计算公式，这一部分主要提供的信息为，重定位的类型包括重定位相对引用和重定位绝对引用、这个重定位区域在代码中的偏移量、重定位到的位置信息，拥有这些信息才可能在链接时完成重定位。4.4Hello.o的结果解析（以下格式自行编排，编辑时删除）objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 对比汇编后的代码发现，原来刚刚进行编译的到的汇编文件中有许多符号，在进行分支转移和循环时，跳转到的是一些符号所处的位置，在这一步中均已经去除，并替换上了其在函数中的相对偏移地址。而且原本没有的机器码也被成功生成了。在进行函数调用时，调用函数重定位信息已经被构建，只是没有在机器码中改变，这将会在后续的链接步骤中进一步实现。4.5本章小结本章比对了编译后和汇编后的汇编代码，分析了代码的变化，展现出汇编对于程序的意义。（第4章1分） 第5章链接5.1链接的概念与作用概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。作用：链接使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，我们可以独立的修改和编译那些更小的模块，这也更便于我们维护管理我们的代码。链接中也包括静态链接和动态链接，动态链接可以在加载和程序运行时进行，相比较静态链接更加灵活。5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。1、ELF头 与之前的可重定位文件的ELF头类似，区别在于类别变成了可执行文件、入口地址被成功设置为0x4010d0、这一文件也拥有了程序头表、节头表中各个节的大小以及节的数目已经发生了改变。2、节头表 可以看到节头表由于链接了其他文件，合并了部分节，并且添加了新的节，导致节头表部分节的大小发生变化，并且添加了几个条目。同时由于已经进行了重定位，所以rel节已经被删除。3、程序头部表 其中我们可以获得不同内存段在目标文件中的偏移、内存地址、对齐要求、目标文件中的段大小、内存中的段大小和访问权限。4、重定位表 5.4hello的虚拟地址空间使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 在地址从0x400000的地址开始，向后64个字节为可执行文件的ELF头的内容。并且根据节头表中的信息，也就是各个节对应的地址可以在edb中找到所有节对应的代码，比如定位.text节中的内容。通过节头表发现其初始地址为0x4010d0。 对应到的内容是这一部分机器代码。 通过edb查找对应的地址内容，发现正好对应。5.5链接的重定位过程分析 hello进行反汇编后得到的内容量远远大于之前的hello.o，并且很多地方都出现了改变。在hello一个文件中出现了外部链接来的函数，并且给出了他们的汇编代码，比如print、puts等函数，并且其附加了@plt符号。之前的虚拟地址由于没有进行重定位，所以都是0，在可执行文件中，虚拟地址变为了实际的数值，比如main函数的首地址0x401105。同时之前出现的call指令的后面的偏移量都是零，也是由于没有进行重定位，在hello文件中由机器分别计算了偏移量并放在了机器代码中。 对函数的重定位，这里给出一个详细的分析，以上一条目为例。首先在重定位后main函数的地址变成了0x401105，并且puts的首地址变为0x401080。根据重定位信息中转移的目标地址是puts的首地址-4，所以可以计算出转移的目标地址为0x40107c。计算出当时的PC的值为0x401105+0x1f-0，由此得到PC的值为0x401124。用目标值减去当前PC的值，得到偏移量为0xffffff58。 5.6hello的执行流程使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 没有输入参数执行ld-2.23.so!_dl_startld-2.23.so!_dl_inithello!__libc_start_main@plthello!puts@plthello!exit@plt输入两个参数ld-2.23.so!_dl_startld-2.23.so!_dl_inithello!__libc_start_main@plthello!printf@plt（循环调用了10次）hello!sleep@plt（循环调用了10次）hello!getchar@plt5.7Hello的动态链接分析分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。在对内容的变化进行解释前，首先简单阐述.plt、.got、.got.plt的作用。.got.plt中保存的是数据，为每个动态调用保存一个条目，条目的内容应该是对动态库函数的调用所跳转到的目标地址。由于Linux采用了延迟绑定技术，可执行文件中got.plt中的地址并不是目标地址，而是动态链接器（ld-linux）中的地址。在程序执行的第一次调用时，ld-linux把.got.plt的地址填写正确，之后的调用，就可以使用.got.plt中的目标地址了。.plt段中的内容则是实现跳转操作的代码片段。以本次代码中的puts@plt为例 可以看到其反汇编代码中的第一句是一个跳转命令，也就是当在main函数中调用puts函数，其首先要寻找自己在代码中实际的代码位置，而这第一句便是去寻找地址。在edb中定位.got.plt的地址，再通过puts的重定位信息可以找到在这一段内容中，puts的重定位信息的具体位置，也就是0x404018 在函数没有运行时，可以看到这一地址处的内容为0，也就是重定位信息没有成功加载。 在程序运行后，再次观察此处的地址，发现重定位信息已经被加载到了这一位置，动态链接的信息也就更新完成了。 5.8本章小结本章主要对链接的过程进行了简要分析，包括重定位信息、动态链接、可执行文件各段信息的分析等内容。（第5章1分） 第6章hello进程管理6.1进程的概念与作用在现代操作系统上运行一个程序时，我们会获得一个假象，就好像我们的程序是系统中当前运行的唯一程序一样。我们的程序好像是独占地使用处理起和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们的程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。进程的经典定义是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。6.2简述壳Shell-bash的作用与处理流程Shell是一种交互型的应用级程序，它代表用户运行其他程序。Shell执行一系列的读\求值步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。具体步骤：1、对用户输入的命令行进行解析，按照分隔符进行读取。2、设置传递给execuve的argv参数。并且判断第一个参数，如果是内部命令，那么调用对应的处理函数进行处理，如果不是认为是一个可执行目标文件，会在一个新的子进程中加载并运行这个文件。3、如果最后一个参数是&，那么表示在后台执行该程序，shell不会等待其完成，否则在前台执行这个程序，shell会等待其完成。4、完成以上步骤后，shell将会开始下一轮迭代。6.3Hello的fork进程创建过程由于我们在shell中输入的指令并非内部指令，所以会被当成是可执行文件进行加载并运行，在这一步之前系统会首先为这一程序的执行创建一个新的子进程，也就是调用fork函数。调用fork()函数创建一个子进程，子进程得到与父进程完全相同但是独立的一个副本，包括代码段、段、数据段、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，父进程和子进程最大的不同时他们的PID是不同的。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。6.4Hello的execve过程对于hello的执行，目前已经为其提供了一个新的子进程，现在要进行的是加载这一程序所需要的所有数据。程序通过调用execve函数，这一函数会调用加载其完成加载任务。首先删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为0.通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到_start地址，最终会调用应用程序的main函数。而在execve函数中，程序将自身运行所需要的环境变量和参数传给主函数。形成如下图所示的栈帧结构。 6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。前文已经完成了hello程序的加载过程，下面叙述hello从main函数开始的执行过程。在进入hello程序时输入参数1190200603和朱泓舟，于是argc的值变成3从而在第一次判断时不会直接退出，进入后续循环。首先执行printf此时执行的进程就是这个hello的程序。随后执行sleep函数，由于sleep函数进行了系统调用，进入内核模式，显示地让调用进程休眠，所以此时进行上下文切换，转换到其他进程运行。在执行完sleep后，又会恢复到用户模式，继续执行hello的余下内容。随后在执行getchar函数时，系统由于要对键盘输入内容进行读取，调用系统级函数read，所以又会进入内核模式，切换到其他进程运行，在getchar函数执行完成后，又会切换回用户模式，hello所在的进程又可以重新运行。 6.6hello的异常与信号处理hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。hello程序出现的异常可能有：中断：在hello程序执行的过程中由于要进行外部设备的输入，可能会出现外部I/O设备引起的异常。陷阱：陷阱是有意的异常，是执行一条指令的结果，hello执行sleep函数的时候会出现这个异常。故障：在执行hello程序的时候，可能会发生缺页故障。终止：终止时不可恢复的错误，在hello执行过程可能会出现DRAM或者SRAM位损坏的奇偶错误。Hello中可能产生多种信号，比如SIGINT、SIGKILL、SIGSEGV、SIGALRM和SIGCHLD等信号，后面会进行详细介绍。对各种命令的运行结果1、作为对比首先给出不进行任何输入的程序执行结果 2、输入ctrl+z 可以看到输入ctrl+z后程序运行停止，不再继续产生输出，并且给出了停止的提示信息。此时执行ps和jobs指令，都可以发现对应的进程和作业信息。使用kill指令发送9这个信号，也就是SIGKILL给hello所在的进程，再次查看对应进程和作业已经消失。 3、输入ctrl+c 输入ctrl+c后发现程序的执行也已经停止，但是与之前不同，在查看进程和作业信息时，没有对应的信息，所以ctrl+c指令已经将这一进程杀死，而不是暂停。4、随意输入内容 终端将所有内容都识别为命令，同时也没有这样的命令，所以直接报错。6.7本章小结在本章中简单对hello运行时的进程控制和信号处理进行了描述，着重分析了fork和execve函数的作用。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。逻辑地址：程序经过编译后出现在汇编代码中的地址。逻辑地址用来指定一个操作数或者是一条指令的地址。是由一个段标识符加上一个指定段内相对地址的偏移量，表示为[段标识符：段内偏移量]。线性地址：也叫虚拟地址，和逻辑地址类似，也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件也是内存的转换前地址。虚拟地址：也就是线性地址。物理地址：用于内存芯片级的单元寻址，与处理器和CPU链接的地址总线相对应。可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。7.2Intel逻辑地址到线性地址的变换-段式管理一个逻辑地址由两部份组成，段标识符:段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节。在段式管理系统中，整个进程的地址空间是二维的，即其逻辑地址由段号和段内地址两部分组成。为了完成进程逻辑地址到物理地址的映射，处理器会查找内存中的段表，由段号得到段的首地址，加上段内地址，得到实际的物理地址。 7.3Hello的线性地址到物理地址的变换-页式管理首先对虚拟存储模式进行简单介绍 这张图表示了虚拟内存管理模式的主要部分。当转换地址时实现了页命中的情况： 1、处理器生成一个虚拟地址，并把它传送给MMU2、MMU经过地址的翻译生成PTE地址，这个地址是对应在页表中寻找对应的PTE，并从高速缓存/主存中请求得到它。3、高速缓存/主存向MMU返回PTE4、MMU构造物理地址，并把它传送给高速缓存/主存5、高速缓存/主存返回所请求的数据字给处理器。当转换地址时发生了缺页 第一步到第三步与页命中的情况相同。4、PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。5、缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。6、缺页处理程序页面调入新的页面，并更新内存中的PTE。7、缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。以上介绍的是转换的主要步骤，下面对MMU中的地址翻译做进一步阐述。 在翻译过程中，利用VA中的VPN部分寻找对应的页表中的PTE，实际上就是物理地址中的PPN部分，然后虚拟地址中的VPO部分直接复制到PPO部分，最终构成了物理地址。7.4TLB与四级页表支持下的VA到PA的变换进行地址转化时，CPU每产生一个虚拟地址，MMU就必须查阅一个PTE，这涉及到内存的读取操作，花费周期较长，但是如果要取出的PTE位于一级高速缓存中，花费周期就会变得很小，所以在MMU中建立一个关于PTE的缓存，这有助于地址转化速率的提高，这个小缓存被称为TLB。 TLB的结构如图所示，在原本的虚拟地址中，VPN部分被分为两部分，一部分是TLB组的组索引TLBI，用于定位VPN在TLB中的组号。一部分是标记用于在寻找到组后，寻找对应的行。VPO与原来一致，都是直接复制与找到的PPN合并，构建出新的物理地址。 多级页表的作用是节省内存，如果发现前一级页表中有的PTE是空的，那么也就说明后续所有页表对应的这一部分都是空的，不需要占用内存，因此多级页表可以极大地节约内存。这里用一个36位的VPN为例，VPN被分为4个9位的片，每个片作用于一个页表的偏移量。VPN1中保存的是PTE在L1中的偏移量，在L1中定位到的PTE中保存的是其对应的L2部分的首地址，相应的VPN2就保存的在L2中的偏移量，以此类推，最终在L4中找到对应的PPN。在每一级寻找VPN时都可以采取TLB加速策略。7.5三级Cache支持下的物理内存访问 当虚拟地址成功转化为了物理地址，此时就要到高速缓存中读取对应的数据。 采用较为一般的缓存方式组相联高速缓存，物理地址被分为图中三个部分。首先利用组索引在高速缓存组中定位对应的组。然后，在这一组中，利用标记位信息在组中寻找有效位为0的对应行，如果没有对应上，那么就将数据从下一级高速缓存或者内存中读取出来，保存在组中，重新设置标记信息和有效位信息。如果成功对应了组中的某一行，那么此时就找了对应的数据。7.6hello进程fork时的内存映射当fork函数被新进程调用时，内核为新进程创建各种数据结构，并分配给它唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射Execve函数在当前进程中加载并运行包含在可执行文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤：删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。7.8缺页故障与缺页中断处理 缺页是发生在虚拟地址转化为物理地址时的故障，当CPU发出一个虚拟地址后，根据前文的翻译流程进行转化，如果在内存中的页表中没有找到对应的物理地址，此时便会出发缺页故障。缺页处理程序从磁盘中加载合适的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。7.9动态存储分配管理7.9.1动态内存分配地基本原理动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。分配器有两种基本风格，两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体来负责释放已分配的块。显式分配器：要求应用显式地释放任何已分配的块。例如，c标准库提供一种叫做malloc程序包的显式分配器。c程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。c++中的new和delete操作符与c中的malloc和free相当。隐式分配器：另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集，例如Lisp,ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。7.9.2隐式空闲链表原理首先介绍隐式空闲链表 一个块是由一个字的头部、有效载荷、可能的一些额外的填充，以及在块的结尾处的一个字的脚部组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是0。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。我们称这种结构称为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。注意：此时我们需要某种特殊标记的结束块，可以是一个设置了已分配位而大小为零的终止头部。 为了加快空闲块之间的合并速度，为每一个块加装一个脚部。在每个块的结尾添加一个脚部，那么分配器就可以通过检查它的脚部，判断前一个块的起始位置和状态，这个脚部总是在距离当前块开始位置一个字的距离。当需要进行空闲块的合并时，总共分为四种情况，对于每种情况分别进行不同的更新，即可完成在常数时间内的合并操作。7.9.3显示空闲链表原理 隐式链表因为块分配与堆块的数量呈线性关系，所以对于通用的分配器，隐式链表是不合适的，将空闲块组织为某种形式的显示数据结构更好。因为根据定义，程序不需要一个空闲块的主体，所以实现空闲链表数据结构的指针可以存放在这些空闲块的主体里面。显式空闲链表结构将堆组织成一个双向空闲链表，在每个空闲块的主体中，都包含一个pred（前驱）和succ（后继）指针。使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于空闲链表中块的排序策略。一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。 7.10本章小结本章内容较多，涉及到虚拟地址到物理地址地转化、物理地址在高速缓存中定位、虚拟内存映射、动态内存分配、缺页处理等内容。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法一个Linux文件就是一个m字节的序列：B0,B1,B2……Bm所有的IO设备(如网路、磁盘、终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O,这使得所有的输入和输出都被当做相应文件的读和写来执行。设备的模型化：文件设备管理：unixio接口8.2简述UnixIO接口及其函数UnixI/O接口统一操作：1、打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。2、Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。3、改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。4、读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。5、关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。UnixI/O函数：1、intopen(char*filename,intflags,made_tmode)函数主要功能：进程通过调用这一函数来打开一个已存在的文件或者创建一个新文件。参数功能：-filename：函数会将filename转化为一个文件描述符，也就是将要打开的文件名字。-flags：指明了进程打算如何访问这个文件。-mode：指定了新文件的访问权限位。返回值：返回文件的描述符数字，其总是在进程中当前没有打开的最小描述符。2、intclose(intfd)函数主要功能：关闭一个打开的文件参数功能：fd为将要关闭的文件的文件描述符返回值：0成功，-1出错3、ssize_tread(intfd,void*buf,size_tcount)函数主要功能：从文件中读取数据参数功能：-fd：要读取文件的文件描述符-buf：读取的文件中的字符将会存储在buf中-count：读取文件的最大字符数目返回值：若成功则为读的字节数，若EOF则为0，若出错为-14、ssize_twrite(intfd,void*buf,size_tcount)函数主要功能：向文件中写入数据参数功能：-fd：向文件描述符为fd的文件中写数据-buf：写入的数据首地址-count：写入的最多字节数返回值：若成功则为写的字节数，若出错为-18.3printf的实现分析printf函数代码如下所示：intprintf(constcharfmt,…){inti;charbuf[256];va_listarg=(va_list)((char)(&fmt)+4);i=vsprintf(buf,fmt,arg);write(buf,i);returni;}printf函数主要调用了vsprintf和write函数。下面首先介绍vsprintf(buf,fmt,arg)是什么函数。intvsprintf(char*buf,constcharfmt,va_listargs){charp;chartmp[256];va_listp_next_arg=args;for(p=buf;*fmt;fmt++){if(*fmt!=‘%’){*p++=*fmt;continue;}fmt++;switch(*fmt){case‘x’:itoa(tmp,((int)p_next_arg));strcpy(p,tmp);p_next_arg+=4;p+=strlen(tmp);break;case‘s’:break;default:break;}}return(p-buf);}vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。下面分析write的作用 write:moveax,_NR_writemovebx,[esp+4]movecx,[esp+8]intINT_VECTOR_SYS_CALL可以看到在write的汇编代码中进行了系统调用sys_call，下面分析syss_call函数的行为。sys_call:callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret 可以看出这个函数syscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。因此printf函数的全部执行流程为：从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析intgetchar(void){staticcharbuf[BUFSIZ];staticchar*bb=buf;staticintn=0;if(n==0){n=read(0,buf,BUFSIZ);bb=buf;}return(–n>=0)?(unsignedchar)*bb++:EOF;}异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章中主要介绍了Linux系统中IO的原理，包括输入输出函数和一些底层的实现原理。（第8章1分）结论首先编写完成hello.c文件，这个是否文件没有经过处理，与机器中的指令有很大差距，更加贴近于人能够理解的内容，在内存中表现为ascii编码的二进制文件。随后进行预处理，cpp将hello.c处理成为hello.i文件，此时对源文件的#进行了解析。然后进入编译阶段，ccl将hello.i处理成为hello.s文件，此时的文件中已经出现了汇编代码。编译器将hello.s文件处理后，生成hello.o文件，汇编代码已经与机器代码建立了对应关系。Hello.o文件以及各种库文件链接，使得hello.o中的符号得以解析，一些代码和数据的重定位信息得以加载完成。此时hello.c文件完成处理，生成了机器可以运行的可执行文件。在终端中输入可执行文件的名字./hello，shell利用fork函数为其创建一个新的子进程，随后调用execve加载并且运行这一程序，在程序的运行过程中，通过上下文切换、内存翻译、处理信号和异常等操作，实现对这一程序的完整运行。最终当程序结束运行，进程终止，父进程对其进行回收。（结论0分，缺失-1分，根据内容酌情加分） 附件 Hello程序的可执行文件Hello.c程序c源文件Hello.i程序的预处理后的文件Hello.o程序汇编后的文件Hello.s程序编译后的文件（附件0分，缺失-1分） 参考文献为完成本次大作业你翻阅的书籍与网站等[1]Pianistx.printf函数实现的深入剖析.https://www.cnblogs.com/pianist/p/3315801.html[2]RandalE.Bryant,DavidR.O’Hallaon.深入理解计算机系统.第三版.北京：机械工业出版社[M].2018：1-737.[3]物理内存与虚拟内存之间的映射https://blog.csdn.net/thebulesky/article/details/78561136（参考文献0分，缺失-1分） 

哈工大计算机系统HITICS大作业 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190200707 班 级 1936601 学 生 张修语 指导教师 刘宏伟 摘 要 本文讲述了hello.c程序在Linux环境下编写完成后到运行的生命历程，借助有关工具分析hello.c经过预处理、编译、汇编、链接等各个过程最终实现的原理，分析了这些过程中产生的文件的相应信息和作用。并且在此基础上理解进程管理、存储管理、IO管理等知识，对计算机系统的工作原理有了更加深入的理解。 关键词：Hello程序；实现过程；计算机系统 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -5- 第2章预处理 -6- 2.1预处理的概念与作用 -6- 2.2在Ubuntu下预处理的命令 -6- 2.3Hello的预处理结果解析 -7- 2.4本章小结 -7- 第3章编译 -8- 3.1编译的概念与作用 -8- 3.2在Ubuntu下编译的命令 -8- 3.3Hello的编译结果解析 -8- 3.3.1数据 -9- 3.3.2赋值操作 -10- 3.3.3类型转换 -10- 3.3.4算术操作 -11- 3.3.5关系操作 -11- 3.3.6数组操作 -11- 3.3.7控制转移 -11- 3.3.8函数操作 -12- 3.4本章小结 -12- 第4章汇编 -13- 4.1汇编的概念与作用 -13- 4.2在Ubuntu下汇编的命令 -13- 4.3可重定位目标elf格式 -13- 4.4Hello.o的结果解析 -16- 4.5本章小结 -18- 第5章链接 -19- 5.1链接的概念与作用 -19- 5.2在Ubuntu下链接的命令 -19- 5.3可执行目标文件hello的格式 -19- 5.4hello的虚拟地址空间 -24- 5.5链接的重定位过程分析 -24- 5.6hello的执行流程 -25- 5.7Hello的动态链接分析 -25- 5.8本章小结 -26- 第6章hello进程管理 -27- 6.1进程的概念与作用 -27- 6.2简述壳Shell-bash的作用与处理流程 -27- 6.3Hello的fork进程创建过程 -27- 6.4Hello的execve过程 -27- 6.5Hello的进程执行 -28- 6.6hello的异常与信号处理 -28- 6.7本章小结 -32- 第7章hello的存储管理 -33- 7.1hello的存储器地址空间 -33- 7.2Intel逻辑地址到线性地址的变换-段式管理 -33- 7.3Hello的线性地址到物理地址的变换-页式管理 -33- 7.4TLB与四级页表支持下的VA到PA的变换 -34- 7.5三级Cache支持下的物理内存访问 -34- 7.6hello进程fork时的内存映射 -35- 7.7hello进程execve时的内存映射 -35- 7.8缺页故障与缺页中断处理 -36- 7.9动态存储分配管理 -36- 7.10本章小结 -37- 第8章hello的IO管理 -38- 8.1Linux的IO设备管理方法 -38- 8.2简述UnixIO接口及其函数 -38- 8.3printf的实现分析 -39- 8.4getchar的实现分析 -39- 8.5本章小结 -40- 结论 -41- 附件 -42- 参考文献 -43- 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P:ProgramtoProcess 在Linux环境中，hello.c经过cpp的预处理、ccl的编译、as的汇编、ld的链接最终成为可执行目标程序hello，在终端中执行此文件时，操作系统会为其fork产生子进程，再通过execve加载此进程。 020:FromZero-0toZero-0 操作系统调用execve后映射虚拟内存，先删除当前虚拟地址的数据结构并为hello创建新的区域结构，进入程序入口后载入物理内存，再进入main函数执行代码。代码完成后，父进程回收hello进程，内核删除相关数据结构。 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 硬件环境：X64i7CPU；16GRAM；512GDisk 软件环境：Windows10；VirtualBox；Ubuntu20.04 开发/调试工具：gcc；gdb；objdump；readelf；edb 1.3中间结果 hello.c：源代码文件 hello.i：预处理后生成的文件 hello.s：编译后生成的文件 hello.o：汇编后生成的可重定位目标程序 hello_o_r.txt：hello.o的elf格式,分析汇编器和链接器行为 hello_o_o.txt：hello.o的反汇编文件 hello：链接之后生成的可执行程序 hello.txt：hello的反汇编文件 1.4本章小结 本章主要介绍了hello程序的P2P，020过程，以及实验时的软硬件环境及开发与调试工具并介绍了在本论文中生成的中间结果文件。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 预处理的概念是：在编译之前进行的处理。C语言的预处理主要有以下三个方面的内容：1.宏定义；2.文件包含；3.条件编译，预处理命令以符号#开头，如#if,#endif,#define,#include等。 预处理的作用：预处理器(cpp)根据以字符#开头的命令，修改原始的C程序。比如#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常以.i作为文件扩展名。 2.2在Ubuntu下预处理的命令 gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析 预处理前的文件仅30行，预处理后的文件达到了三千多行，但仔细观察可见main函数部分并未做出任何改变，因此可见预处理仅仅是将#include文件库函数的代码复制上去 2.4本章小结 本章介绍了预处理的概念和作用，同时介绍了Ubuntu环境下预处理的命令，并对预处理生成的hello.i文件进行了简要分析。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 概念：指利用编译程序从预处理文本文件（.i）产生汇编程序（.s）的过程。 作用：将输入的高级程序设计语言源程序翻译成以汇编语言或机器语言表示的目标程序作为输出。 3.2在Ubuntu下编译的命令 gcc-S-ohello.shello.i 3.3Hello的编译结果解析 3.3.1数据 (1)全局变量： 在此程序中仅有一个全局变量sleepsecs，且已被赋初值，根据已有知识应将此变量放于.data中，.align表示四字节对齐，.size表示此变量长度为四字节，最后.long将其赋初值2 (2)常量： 此程序中有两个常量，分别对应printf输出的两个字符串，根据已学的知识，的值应将其放于.rodata中，分别用.LC0和.LC1指示 (3)局部变量： 通过分析下方循环体的内容可知，用于循环计数的局部变量i存放在%rbp-4的内存地址处 (4)函数参数 如图，函数参数同样是存放在栈上的 3.3.2赋值操作 此程序中一共含有两次赋值操作：sleepsecs的赋值和循环过程中i的赋值。 sleepsecs的赋值操作已经在上方详细阐述过，在此处不再赘述。 下面分析循环体中i的赋值： 读上述代码可知，首先执行L2，将i赋值为0，后续与9进行比较以达成循环。所以，38行代码即为对i的赋值操作 3.3.3类型转换 此程序仅包含一次强制类型转换，即全局变量sleepsecs赋值为2.5时，编译器将其自动视为int类型的2了。 3.3.4算术操作 此程序仅包含一次算术操作，即循环体中i的i++操作，继续分析循环体可知，54行处的addl操作即为此操作，实际效果为addla,b->b=a+b 3.3.5关系操作 一次是判断argc是否不等于3，另一次是判断i在循环条件中是否小于10 (1)此处判断argc是否不等于3，若argc和3相等跳转，跳转到L2。 (2)此处判断i在循环条件中是否小于10，若i小于等于9跳转，跳转到L4。 3.3.6数组操作 此代码中通过首地址+偏移量的方式访问数组argv[]中的元素，其中，数组首地址位于%rbp-32的位置，每个数组元素长度为8，因为数组元素类型是指针类型，在程序中具体操作如下图： 3.3.7控制转移 两次转移与3.3.5中的两次关系操作一一对应，分别对应源代码中的if分支语句和for循环判断语句 3.3.8函数操作 计算编译后汇编语言执行call语句的次数，即可与源代码的五次调用函数的操作一一对应，分别是一次printf函数，一次exit函数，一次printf函数，一次sleep函数和一次getchar函数： (1)printf函数 (2)exit函数 (3)printf函数 (4)sleep函数 (5)getchar函数 3.4本章小结 本章介绍了编译的概念和作用，并针对具体的例子hello.s，按操作类型分类对hello.s进行解析，并且与源代码对比分析，得到了编译器解析代码时一些具体的思路和流程。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：汇编器（as）将.s文件翻译成机器语言指令，把这些指令打包成一种叫可重定位目标程序的格式，并将结果保存在目标文件（后缀为.o）中。 作用：将汇编代码转换成真正机器可以读懂的二进制代码。 4.2在Ubuntu下汇编的命令 gcc-chello.s-ohello.o 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 符号表： 重定位节： 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 与第三章的hello.s对比，首先在指令前增加了其十六进制表示，即机器语言。其次在操作数上，hello.s中操作数为十进制，而hello.o的反汇编中操作数为十六进制。在条件跳转语句上，hello.o的反汇编文件用的是相对偏移量，而hello.s中是函数名： 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 （1）立即数的变化：hello.s中的立即数都是用10进制数表示的。但是在机器语言中，由于转换成了二进制代码，因此立即数都是用16进制数表示的。 （2）分支转移的不一致：hello.s中的分支转移（即跳转指令）直接通过像.LC0，.LC1这样的助记符进行跳转，会直接跳转到相应符号声明的位置。助记符只是帮助程序员理解的，从汇编语言转换成机器语言之后，助记符就不再存在了，因此机器语言中的跳转使用的是确定的地址。下图中的main+0x29就表明要跳转到距main函数偏移量为0x29的位置。 （3）函数调用的不一致：hello.s中的函数调用直接在call指令后面加上要调用的函数名。但是在机器语言中，call指令后是被调函数的PC相对地址。在这里，由于调用的函数都是库函数，需要在动态链接后才能确定被调函数的确切位置，因此call指令后的二进制码为全0，同时需要在重定位节中添加重定位条目，在链接时确定最终的相对地址。 4.5本章小结 本章介绍了汇编的概念和作用，通过对比hello.s和hello.o分析了汇编的过程，同时分析了可重定位目标文件的ELF格式。 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：将各种代码和数据片段收集并组合成一个单一文件的过程 作用：使得分离编译成为可能。 5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 虚拟地址空间起始地址为0x400000结束地址为0x400ff0 下图为.txt节地址的起始地址0x400550，大小为0x132. 5.5链接的重定位过程分析 hello和hello.o相比，首先多了很多经过重定位之后的函数，如_init、puts@plt等，hello.o在.text段之后只有一个main函数；hello.o的地址是从0开始的，是相对地址，而hello的地址是从0x401000（_init的地址）开始的，是已经进行重定位之后的虚拟地址；在hello的main函数中，条件跳转指令和call指令后均为绝对地址，而hello.o中是相对于main函数的相对地址。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 hello重定位的过程： (1)重定位节和符号定义链接器将所有类型相同的节合并在一起后，这个节就作为可执行目标文件的节。然后链接器把运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号，当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。 (2)重定位节中的符号引用这一步中，连接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。执行这一步，链接器依赖于可重定位目标模块中称为的重定位条目的数据结构。 (3)重定位条目当编译器遇到对最终位置未知的目标引用时，它就会生成一个重定位条目。 5.6hello的执行流程 函数名 地址 ld-2.27.so!_dl_start ld-2.27.so!_dl_init hello!_start 0x400550 hello!_init 0x4004c0 hello!main 0x400582 hello!puts@plt 0x4004f0 hello!exit@plt 0x400530 hello!printf@plt 0x400500 hello!sleep@plt 0x400540 hello!getchar@plt 0x400510 sleep@plt 0x400540 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 全局偏移表GOT是一个数组，每个条目是一个8字节的地址，与PLT结合使用。GOT[0]和GOT[1]包含动态链接器解析函数地址时将使用的信息，GOT[2]是1d-linux.so模块中动态链接器的入口点。其余的每个条目对应于一个被调用的函数，该函数的地址需要在运行时解析。每个条目都有一个匹配的PLT条目。根据节头表，就可以得到PLT段存储GOT的起始地址为0x6008b8 查看EDB中的初始GOT条目。除了PLT[0]之外，每个PLT对应的got条目最初指向该PLT的第二条指令。如PLT[1]对应地址0x6008d0处的GOT[3]，0x6008d0处的值是0x400466，它正好指向PLT[1]的第二条指令。第一次调用函数时，动态链接器会修改相应的GOT条目。 改变后的GOT表如下: 5.8本章小结 本章通过对hello可执行程序的分析，回顾了链接的基本概念，文件的重定位过程，动态链接过程，虚拟地址空间，可重定位目标文件ELF格式的各个节等与链接有关的内容。链接的过程在软件开发中扮演一个关键的角色，它们使得分离编译成为可能。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中的程序的实例，每一个进程都有它自己的地址空间，一般情况下，包括文本区域、数据区域、和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储区着活动过程调用的指令和本地变量。 作用：进程为用户提供了一种假象：好像程序是系统中当前运行的唯一程序一样，好像程序是独占的使用处理器和内存。处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 Shell是指为使用者提供操作界面的软件（命令解析器）。它接受用户命令，然后调用相应的应用程序。Linux系统中所有的可执行文件都可以作为Shell命令来执行。 处理流程：首先对用户输入的命令进行解析，判断命令是否为内置命令，如果为内置命令，调用内置命令处理函数；如果不是内置命令，就创建一个子进程，将程序在该子进程的上下文中运行。判断为前台程序还是后台程序，如果是前台程序则直接执行并等待执行结束，如果是后台程序则将其放入后台并返回。同时Shell对键盘输入的信号和其他信号有特定的处理。 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的运行的子进程。Fork函数调用一次返回两次。 Shell通过fork创建一个新的子进程，它将在这个子进程上加载并运行hello。 6.4Hello的execve过程 Shell通过调用execve函数加载并运行可执行目标文件hello。execve函数调用一次从不返回。 当execve加载了hello之后，它调用__libc_start_main。其设置栈，并将控制转移给新程序的主函数。 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 逻辑流的执行在时间上与另一个流重叠，这称为并发流。这两个流称为并发运行。这个过程还为每个程序提供了一种假象，好像它只使用系统地址空间一样。 处理器通常使用控制寄存器中的模式位来提供一种机制来限制应用程序可以执行的指令范围和可以访问的地址空间。此寄存器描述进程当前享有的特权。设置模式位后，进程以内核模式运行。在内核模式下运行的进程可以执行指令集中的任何指令并访问系统中的任何内存位置。未设置模式位时，进程以用户模式运行。在用户模式下，不允许进程执行特权指令，也不允许进程直接引用地址空间内核区域中的代码和数据。 运行应用程序代码的进程以用户模式启动。当异常发生时，控制传递给异常处理程序，处理器将模式从用户模式更改为内核模式。处理器在内核模式下运行，当它返回到应用程序代码时，处理器将模式更改回用户模式。 内核为每个进程维护一个上下文。它由一些对象的值组成，包括通用寄存器、浮点寄存器、程序计数器、用户堆栈等。在进程执行的某个时刻，内核可以决定抢占当前进程并启动先前抢占的进程。这个决定被称为调度。在内核调度一个新进程运行之后，它会抢占当前进程，并使用一种称为上下文切换的机制将控制转移到新进程。 上下文切换：1.保存当前进程的上下文；2.恢复先前抢占进程的保存上下文；3.将控制转移到新恢复的流程。 在Hello中，当程序执行sleep函数时，sleep显式地请求调用进程睡眠。调度器抢占当前进程并通过上下文切换将其传输到新进程。sleep函数结束后，通过上下文切换返回Hello函数。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 hello程序出现的异常可能有： 中断：在程序执行的过程中可能会出现外部I/O设备引起的异常。 陷阱：陷阱是有意的异常，是执行一条指令的结果。 故障：在执行程序的时候，可能会发生缺页故障。 终止：终止时不可恢复的错误。 在发生异常时会发出信号，比如缺页故障会导致OS发生SIGSEGV信号给用户进程，而用户进程以段错误退出。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 回车与Ctrl+Z Ctrl+C ps、jobs、pstree、fg、kill等 乱按 6.7本章小结 本章介绍了有关进程管理的多个概念。介绍了Shell的作用和处理流程，以及利用fork创建子进程、利用execve加载进程的方法。展示hello程序执行的具体过程，以及异常信号的处理机制。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 逻辑地址： 在有地址变换功能的计算机中,访问指令给出的地址(操作数)叫逻辑地址,也叫相对地址。要经过寻址方式的计算或变换才得到内存储器中的物理地址。 线性地址： 线性地址（LinearAddress）是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。 物理地址： 在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址，又叫实际地址或绝对地址。 虚拟地址： 程序访问存储器所使用的逻辑地址称为虚拟地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址由段标识符和段内偏移量两部分组成。段标识符由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号，是对段描述符表的索引，每个段描述符由8个字节组成，具体描述了一个段。后3位包含一些硬件细节，表示具体是代码段寄存器还是栈段寄存器还是数据段寄存器等。通过段标识符的前13位，可以直接在段描述符表中索引到具体的段描述符。每个段描述符中包含一个Base字段，它描述了一个段的开始位置的线性地址。将Base字段和逻辑地址中的段内偏移量连接起来就得到转换后的线性地址。 对于全局的段描述符，放在全局段描述符表中，局部的（每个进程自己的）段描述符，放在局部段描述符表中。全局段描述符表的地址和大小存放在gdtr控制寄存器中，而局部段描述符表存放在ldtr寄存器中。 给定逻辑地址，看段选择符的最后一位是0还是1，用于判断选择全局段描述符表还是局部段描述符表。再根据相应寄存器，得到其地址和大小。通过段标识符的前13位，可以在相应段描述符表中索引到具体的段描述符，得到Base字段，和段内偏移量连接起来最终得到转换后的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 n位的虚拟地址包含两个部分，一个p位的虚拟页面偏移（VPO）和一个(n-p)位的虚拟页号（VPN）。 VPN作为到页表中的索引。若对应页表项的有效位为1，则取出物理页号（PPN）与物理页偏移量（PPO，等于VPO）组合形成物理地址。否则缺页，触发页面调度。 7.4TLB与四级页表支持下的VA到PA的变换 如果按照上述模式，每次CPU产生一个虚拟地址并且发送给地址管理单元，MMU就必须查找一个PTE行来用将虚拟地址翻译成物理地址。为了消除这种操作带来的大量时间开销，MMU中被设计了一个关于PTE的小的缓存，称为翻译后备缓冲器（TLB）也叫快表。例如当每次cpu发现需要重新翻译一个虚拟地址时,它就必须发送一个vpn得到虚拟地址mmu,发送一个vpo位得到一个l1高速缓存.例如当我们使用mmu向一个tlb的组请求一个页表中的条目时,l1高速缓存通过一个vpo位在页表中查找一个相应的数据标记组,并在页表中读出这个组里的个数据标记和相应的数据关键字.当mmu从一个tlb的组得到一个ppn时,代表缓存的工作在这个组的请求之前已经完全准备好,这个组的ppn与就已经可以与这些数据标记文件中的一个虚拟地址进行很好的匹配了。 corei7采用四级页表层次结构,每个四级页表进程都有他自己私有的页表层次结构,这种设计方法从两个基本方面就是减少了对内存的需求,如果一级页表的pte全部为空,那么二级页表就不会继续存在,从而为进程节省了大量的内存,而且也只有一级页表才会有需要总是在一个内存中。四级页表的层次结构操作流程如下:36位虚拟地址被寄存器划分出来组成四个9位的片,每个片被寄存器用作到一个页表的偏移量。cr3寄存器内储存了一个l1页表的一个物理起始基地址,指向第一级页表的一个起始和最终位置,这个地址是页表上下文的一部分信息。vpn1提供了到一个l1pet的偏移量,这个pte寄存器包含一个l2页表的起始基地址.vpn2提供了到一个l2pte的偏移量,一共四级,逐级以此层次类推。 7.5三级Cache支持下的物理内存访问 cache结构如下 如果选中的组存在一行有效位为1，且标记位与地址中的标记位相匹配，我们就得到了一个缓存命中，否则就称为缓存不命中。如果缓存不命中，那么它需要从存储器层次结构的下一层中取出被请求的块，然后将新的块存储在组索引位指示组中的一个高速缓存行中，具体替换哪一行取决于替换策略，例如LRU策略会替换最后一次访问时间最久远的那一行。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。内核给新进程创建虚拟内存，创建当前进程的mm_struct、区域结构和页表的原样副本，将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，为每个进程保持了私有地址空间的抽象概念。同时延迟私有对象中的副本直到最后可能的时刻，充分利用了稀有的物理内存。 7.7hello进程execve时的内存映射 加载并运行a.out的过程中： 1.删除已存在的用户区域。 2.映射私有区域。代码和数据区域被映射为a.out文件中的.text和.data区。.bss区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。 3.映射共享区域。如果a.out程序与共享对象（或目标）链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 7.8缺页故障与缺页中断处理 在指令请求一个虚拟地址时，MMU中查找页表，如果对于的物理地址没有存在主存内部，以至于我们必须要从磁盘中读出数据，这就是缺页故障（中断）。 在发生缺页中断之后，系统会调用内核中的一个缺页处理程序，选择一个页面作为牺牲页面。具体的操作过程如下： 1.CPU生成一个虚拟地址,并把它传送给MMU. 2.地址管理单元生成PTE地址,并从高速缓存/主存请求得到它. 3.高速缓存/主存向MMU返回PTE. 4.PTE中的有效位是零,所以MMU触发了一次异常,传递CPU中的控制到操作系统内核中的缺页异常处理程序. 5.缺页处理程序确定出物理内存中的牺牲页,如果这个页面已经被修改了,则把它换出到磁盘. 6.缺页处理程序页面调人新的页面,并更新内存中的PTE. 7.缺页处理程序返回地址到原来的缺页处理进程,再次对主存执行一些可能导致缺页的处理指令,cpu,然后将返回地址重新再次发送给处理程序mmu.因为程序中虚拟的页面现在已经完全缓存在了物理的虚拟内存中,所以处理程序会再次命中,主存将所请求字符串的返回地址发送给虚拟内存的处理器。 7.9动态存储分配管理 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对每个进程，内核维护一个变量brk，指向堆的顶部。分配器将堆视作一组不同大小的块的集合，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。分配器有两种基本风格：显式分配器和隐式分配器。显式分配器要求应用显式地释放任何已分配的块，隐式分配器要求分配器检测一个已分配块何时不再被程序所用，那么就释放这个块。隐式分配器又叫垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集。 为实现动态内存分配器，可以使用隐式空闲链表。当一个应用请求k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略确定的。一些常见的策略是首次适配、下一次适配和最佳适配。一旦分配器找到一个匹配的空闲块，就需要决定分配这个空闲块中多少空间。一个选择是用整个空闲块，但这样会造成内部碎片。如果匹配不太好，那么分配器会将这个空闲块分割，第一部分变成分配块，剩下的变成一个新的空闲块。利用边界标记，可以允许在常数时间内进行对前面块的合并。这种思想是在每个块的结尾添加一个脚部，其中脚部就是头部的一个副本。这样分配器就可以通过检查它的脚部，判断前面一个块的起止位置和状态，这个脚部总是在距离当前块开始位置一个字的距离。但是这种方法也存在潜在缺陷，就是在应用程序操作许多个小块时，会产生显著的内存开销。 7.10本章小结 本章主要介绍了hello的存储器的地址空间，介绍了四种地址空间的差别和地址的相互转换。同时介绍了hello的四级页表的虚拟地址空间到物理地址的转换。阐述了三级cashe的物理内存访问、进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m个字节的序列： 所有的IO设备（例如网络、磁盘和终端）都被模型化为文件，所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，使得所有的输入和输出都能以一种统一且一致的方式来执行。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixI/O接口： 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。 2.Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。 3.改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。 4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 5.关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。 UnixI/O函数: 1.intopen(char*filename,intflags,mode_tmode)，进程通过调用open函数来打开一个存在的文件或是创建一个新文件的。open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。 2.intclose(fd)，fd是需要关闭的文件的描述符，close返回操作结果。 3.ssize_tread(intfd,void*buf,size_tn)，read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF，否则返回值表示的是实际传送的字节数量。 4.ssize_twirte(intfd,constvoid*buf,size_tn)，write函数从内存位置buf复制至多n个字节到描述符为fd的当前文件位置。 8.3printf的实现分析 首先来看看printf函数的函数体 intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } printf函数是格式化输出函数,一般用于向标准输出设备按规定格式输出信息。printf中调用了两个函数，分别为vsprintf和write。 vsprintf函数根据格式串fmt，并结合args参数产生格式化之后的字符串结果保存在buf中，并返回结果字符串的长度。 write函数将buf中的i个字符写到终端，由于i保存的是结果字符串的长度，因此write将格式化后的字符串结果写到终端。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar函数体 intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章中简单的描述了linux的io的接口及其设备和管理模式,unixio的接口及其使用的函数,还有常见的printf函数和pritgetchar函数. （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 hello.c：c程序源代码，是一个二进制文本文件，hello.c中的每个字符均用ascall编码表示。 hello.i：hello.c经过预处理阶段变为hello.i。 hello.s：hello.i经过编译阶段变为hello.s。 hello.o：hello.s经过汇编阶段变为hello.o。 hello：hello.o与可重定位目标文件和动态链接库链接成为可执行文件hello。 运行：在终端输入./hello1190200707张修语。 创建子进程：由于终端输入的不是一个内置的shell命令，因此shell调用fork（）函数创建一个子进程。 加载：：shell调用execve，execve调用启动加载器，加映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数。 上下文切换:hello调用sleep函数之后进程陷入内核模式，处理休眠请求主动释放当前进程，内核进行上下文切换将当前进程的控制权交给其他进程，当sleep函数调用完成时，内核执行上下文切换将控制传递给当前进程。 动态申请内存：当hello程序执行printf函数是，会调用malloc向动态内存分配器申请堆中的内存。 信号管理：当程序在运行的时候我们输入Ctrl+c，内核会发送SIGINT信号给进程并终止前台作业。当输入Ctrl+z时，内核会发送SIGTSTP信号给进程，并将前台作业停止挂起。 终止：当子进程执行完成时，内核安排父进程回收子进程，将子进程的退出状态传递给父进程。内核删除为这个进程创建的所有数据结构。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 计算机系统的设计与人的思维方式有着很大的区别，特别是层序结构存储器，条理清晰层层深入，让我大受震撼，而汇编语言、数据表示、异常处理等内容，仅几个简单的数字或标记就能将复杂的算法与基层的计算机指令进行联系，还可以给操作系统报各种不同的错误，实在是精巧严谨。通过学习hello的程序人生，了解计算机这些底层结构，无疑对我自己以后的程序人生有着极大的启发和帮助。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 

[HIT]哈工大2021软件构造复习笔记(一轮) 花了一晚上时间，将软件构造的基础知识重新看了一遍，对其中很多内容有了新的理解，将我的复习笔记分享给大家。（记得比较粗糙，如果基础不太好建议还是跟着PPT学习，很多东西讲的更加透彻，知识点也更加全面。 

CSAPP大作业论文程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号1190200721班 级1936602学生张少卿指导教师刘宏伟 计算机科学与技术学院2021年6月 摘要 一个c语言程序到它完整地在计算机系统中实现需要经历过许多过程。首先是要将.c文件转换为可执行文件。这其中经历了预处理、编译、汇编、链接4个过程，形成可执行文件后，计算机就能读懂我们的.c代码去执行其中的语句。计算机在执行文件时候又有许多学问。例如：进程的概念，计算机存储的管理，IO的管理。一个文件的执行其背后是计算机许许多多不同且重要的功能合作完成的。 关键词：预处理；汇编；进程；存储管理；IO管理； 文章目录 摘要第1章概述1.1Hello简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2在Ubuntu下编译的命令3.3Hello的编译结果解析3.3.1变量/常量and赋初值/不赋初值and类型转换3.3.2sizeof3.3.3算术操作：+-*/%++--取正/负符合3.3.4逻辑/位操作3.3.5关系操作3.3.6数组/指针/结构操作3.3.7循环3.3.8函数 3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令4.3可重定位目标elf格式4.4Hello.o的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式5.4hello的虚拟地址空间5.5链接的重定位过程分析5.6hello的执行流程5.7Hello的动态链接分析5.8本章小结 第6章hello进程管理6.1进程的概念与作用6.2简述壳Shell-bash的作用与处理流程6.3Hello的fork进程创建过程6.4Hello的execve过程6.5Hello的进程执行6.6hello的异常与信号处理6.7本章小结 第7章hello的存储管理7.1hello的存储器地址空间7.2Intel逻辑地址到线性地址的变换-段式管理7.3Hello的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.5三级Cache支持下的物理内存访问7.6hello进程fork时的内存映射7.7hello进程execve时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章hello的IO管理8.1Linux的IO设备管理方法8.2简述UnixIO接口及其函数8.3printf的实现分析8.4getchar的实现分析8.5本章小结 附件参考文献 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。P2P：Hello的生命从hello.c开始，我们的hello.c首先经过第一道关卡 预处理，预处理器cpp将它预处理，将它变形为hello.i。于是我们的hello.i懵懵懂懂地来到了第二关卡 编译，编译器“咔咔咔”将它彻底改头换面，我们的hello.i就变为了hello.s。可是我们的发廊总裁“汇编器”对它还是不太满意。于是稍加修改。Hello.o文件问世。最后，hello.o满意地来到了最后一关。链接器ld将一身衣服“库函数”穿戴在它的身上，我们的hello就从原来的乡下小子hello.c变为了大明星hello可执行目标文件，实现P2P过程。020：子进程调用execve，映射虚拟内存并载入物理内存，进入程序入口处开始执行，同时，CPU为运行的hello分配时间片并执行逻辑控制流。在中途调用异常处理函数处理可能出现的异常。最后当hello进程终止，父进程shell将回收hello，接着内核删除相关数据结构的整个过程叫做020。 1.2环境与工具 硬件：Intel®Core™i5-9300HCPU@2.40GHz8GRAM虚拟机VUbuntu18.4开发工具：gccldreadelfgeditobjdumpedbgdbhexeditVisualStudio2019；CodeBlocks64位MwareWorkstationPro15.0 1.3中间结果 Hello可执行文件Hello.i预处理后文件Hello.s编译后文件Hello.o汇编后文件Hello_.s反汇编文件 1.4本章小结 本章简要介绍了hello的P2P，020的过程，列出了运行的环境和使用的工具，以及中间结果。 第2章预处理 2.1预处理的概念与作用 预处理概念：预处理器(cpp)根据以字符#开头的命令，修改原始的c程序。例如：#include<stdio.h>告诉预处理器读取系统头文件stdio.h的内容，并把它插入到程序文本中。得到一个新的c程序，通常是以.i命名。预处理作用：1.处理文件包含2.处理宏定义3.处理注释4.处理条件编译5.处理一些特殊控制指令 2.2在Ubuntu下预处理的命令 gcchello.c-E-ohello.i 2.3Hello的预处理结果解析 .i文件的开头： 其中数字1、2、3、4表示：1：表示新文件的开始2：表示返回一个文件（包含另外一个文件之后）3：表示一下文本来自系统头文件，因此应该抑制某些警告4：表示一下文本应该被视为包含在隐式的extern“C”块中。Stdio.h文件预处理后： 定义了些奇怪的符号： 关键字extern标示变量或者函数的定义在别的文件中： 可以发现.i文件中有许多的extern。拉到.i文件的最下方，可以发现我们的函数体，其中#的注释都被删除了。 2.4本章小结 预处理是为了将我们原始的.c文件拓展成更大的c文件，添加了许多的代码是为了方便后续编译器的操作。 第3章编译 3.1编译的概念与作用 编译的概念：编译器(ccl)将文本文件.i翻译成文本文件.s，它包含了一个汇编语言程序。编译的作用：1.扫描（词法分析）将源代码程序输入扫描器，将源代码的字符序列分割成一系列记号。2.语法分析基于词法分析得到的一系列记号，生成语法树。3.语义分析由语义分析器完成，指示判断是否合法，并不判断对错。又分：静态语义：隐含浮点型到整形的转换，会报warning；动态语义：在运行时才能确定。4.源代码优化（中间语言生成）中间代码（语言）使得编译器分为前端和后端，前端产生与机器（或环境）无关的中间代码，编译器的后端将中间代码转换为目标机器代码，目的：一个前端对多个后端，适应不同平台。5.代码生成，目标代码优化编译器后端主要包括：代码生成器:依赖于目标机器，依赖目标机器的不同字长，寄存器，数据类型等。目标代码优化器:选择合适的寻址方式，左移右移代替乘除，删除多余指令。 3.2在Ubuntu下编译的命令 编译的命令：gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 第一行解释了文件的由来第二行解释了全局变量名第四行解释了对齐的大小是4字节 这些应该是说明了这些变量存储的位置。例如：LC0存储了字符串“Usage:Hello学号姓名！”，其存储在.string节中。 3.3.1变量/常量and赋初值/不赋初值and类型转换 全局变量：全局变量一般都存储在.rodata节Hello.c中的Sleepsecs全局变量存放在.long节和.rodata中，存储的值是2，但我们观察c程序，发现其赋值是2.5。所以在这里有一个隐式的转换！将2.5转为int的2！局部变量：赋初值局部变量一半都存储在.bss节中，未赋初值的局部变量则不存放在某个位置，要是用时才存放在寄存器中在hello.c中局部变量i在前面的编译语句中没有找到，我们观察对i的调用是在循环中，所以我们去找寻相关的位置。i就保存在这个位置，看来局部变量在这里是存储在了栈中-4(%rbp)位置。 3.3.2sizeof Sizeof函数一般是在编译的时候就处理完成了，它在编译的时候就将变量类型对应的立即数改写到汇编指令中。 3.3.3算术操作：+-*/%++–取正/负符合 算术操作都是在寄存器的基础上完成的。以hello.c为例，在hello.c中出现了++运算。它执行是在循环中，我们去循环体中寻找： ++就是把对应的寄存器+1，同理–就是把对应的寄存器-1。从上面的例子我们很容易猜到加法运算的指令就是add，至于其他算术操作指令如下： Sub； imul；/一般是通过加减法来实现；%同除法；NEG取负复合拆分开一步一步计算 3.3.4逻辑/位操作 同样也是对寄存器进行操作。与&and；或|or；异或^xor；非~not；左移<<：算术左移sal；逻辑左移shl；右移>>：算术左移sar；逻辑左移shr； 3.3.5关系操作 在hello.c中的循环体中就有关系操作，一般是用cmp进行比较然后设定条件码，然后用j*语句执行相关的语句 例如将i和9进行比较，若小于等于则进入.L4块。以下是所有j*指令：指令同义名跳转条件描述Jmp1直接跳转JeJzZF相等/零JneJnz~ZF不相等/非零JsSF负数Jns~SF非负数JgJnle~（SF^OF）&ZF大于（有符号）JgeJnl~（SF^OF）大于等于（有符号）JlJngeSF^OF小于（有符号）JleJng（SF^OF）|ZF小于等于（有符号）JaJnbeCF&ZF超过（无符号）JaeJnb~CF超过相等（无符号）JbJnaeCF低于（无符号）JbeJnaCF|ZF低于等于（无符号） 3.3.6数组/指针/结构操作 数组和指针都是以地址来进行操作，在hello.c中有argv数组和argv。在hello.c中argv的地址存放在了-32(%rbp)的位置（具体分析看下面的函数操作）。 所以%rax存放的就是argv[0]的地址。所以%rax+16=argv[2]，%rax+8=argv[1]，这里的8是一个字节，16是两个字节，刚好是char的大小的倍数。 3.3.7循环 很显然cmpl指令就是循环体内部的比较语句，如果-4(%rbp)小于等于9则进入.L4块，这是一种guarded-do写法。接下来我们来观察.L4块。 .L4是循环中的语句（具体分析看下面函数调用），两个函数执行完毕后，第一次循环结束，i++，于是addl指令就执行了该操作。然后再此进入.L3块。 3.3.8函数 在hello.c中有许多的函数调用的例子函数的参数传递：Main函数 这两条指令执行了main函数的参数传递，函数的参数传递通常是保存在%rdi和%rsi寄存器中。根据.c文件，我们清楚在%edi中保存的是第一个参数argc，在%rsi中保存的是第二个参数*argv。 然后是函数的调用： 我们知道循环中主要是printf和调用sleep函数。这里就涉及了数组的偏移操作，我们知道数组首地址存放在-32(%rbp)中，所以%rax存放的就是argv[0]的地址。所以%rax+16=argv[2]，%rax+8=argv[1]，这里的8是一个字节，16是两个字节，刚好是char的大小。再将.LC1存放于%edi寄存器，参数设置完毕，接下来就是调用printf函数了。执行完后再将sleepsecs存放于%edi寄存器调用sleep函数。函数的调用有两种方式：1.直接调用，2.间接调用。直接调用的目标是作为指令的一部分编码，间接调用涉及了相对寻址，相对于call指令的下一条指令的地址。函数的返回return： 当循环体结束后，调用getchar函数，由于return0，将0存放于%eax寄存器，因为%eax是指定的返回函数存储的寄存器。然后leave和ret，函数调用结束返回。Leave是对栈的操作，取出数据然后%rsp+8/+16。 3.4本章小结 编译这一步，将hello.c文件从高级语言转变到了汇编语言，我们发现，汇编语言是机器代码的文本表示，更方便跟机器“沟通”。在这一步后，汇编器才能理解我们的程序，从而将我们的程序转变为更底层的机器语言。 第4章汇编 4.1汇编的概念与作用 汇编的概念：汇编器（as）将hello.s翻译成机器语言指令，并把这些指令打包成一种叫做可重定位目标程序。将结果保存在目标文件hello.o中汇编的作用：将汇编指令转成机器可以直接识别的机器指令 4.2在Ubuntu下汇编的命令 汇编的指令：gcc-chello.s-ohello.o 4.3可重定位目标elf格式 指令：readelf-ahello.o 相关的解读Magic：魔数E45L4CF46Data数据：补码表示，小端Entrypointaddress入口点地址：ELF起始位置Startofprogramheaders程序头起点：程序头表起始位置Startofsectionheaders：偏移量Numberofprogramheaders：表象个数Sizeofsectionheaders节头大小：每个节的大小节头数量：节个数字符串表索引头：.strtab节的位置2.节头部表，不同节的位置和大小都是节头部表描述的，其中每个节都一个固定大小的条目。 相关的说明：大小：节的字节数偏移量：节相对于自己的起始位置的偏移量（起始位置跟对齐有关）对齐：限制了节的起始地址，4就是代表了对齐最小单位是1000。3.重定位信息 在链接的时候需要对符号重新定义，定义的信息就来自于重定位节。可以看到函数和全局变量都在其中。4.符号表 存放了程序中定义的全局变量和函数的信息。 4.4Hello.o的结果解析 在hello.o的反汇编出来的汇编语言中，可以发现其将符号解析并增加了重定位信息，例如原本的.L2块中的jmp.L3转换为了地址。 还有就是全局变量sleepsecs和函数调用。 由于每条指令都有了自己的相对地址，所以分支转移函数调用就可以直接用相关指令的相对地址来进行跳转，同时增加了重定位信息，方便后续链接的时候修改。 4.5本章小结 在进行汇编过程后，hello.s文件转换为了二进制可重定位文件hello.o，在hello.o中我们hello.s本来是符号的地方都进行了解析转换为了一串地址。所以hello.o文件与hello.s文件有着不同之处，同时也更有利于机器理解。 第5章链接 5.1链接的概念与作用 链接的概念：链接器（ld）将多个.o文件合并，得到一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。链接的好处： 模块化：一个程序可以分成很多源程序文件可以构建共享函数库效率高时间上，可分开编译空间上，无需包含共享库所有代码 5.2在Ubuntu下链接的命令 链接的命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 这里ELF所显示的信息与hello.s的ELF的显示的都是一样的就不再解读，不过我们可以发现hello中节头的数量比hello.s的多得多。各节头的信息： 节头多了许多，不过阅读的方式没有改变。主要关注地址，偏移量和对齐共享库的地址： 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 我们的首要目标是.interp段的内容。有节头部表，可以知道该段的起始地址为0x402e0，那我们现在来查看该段的内容，我们发现其内容为：/lib64/ld-linux-x86-64.so.2。我们知道这是链接器的信息。 接下来搜索.dynstr节，结果为：.libc.so.6.exit.puts.printf.getchar.atoi.sleep.libc_strat_main.GLIBC_2.2.5.gmon_start。显然这些都是共享库的信息。 再来查看.rodata节，里面是字符串常量。 5.5链接的重定位过程分析 相比于hello.o的反汇编，hello的反汇编多了许多函数，而不仅有main。例如_init、puts、printf等等。同时在hello的反汇编中，地址全部转换为了虚拟地址，起始从400000开始，而不是0开始。 而原先hello.s反汇编中的重定位信息也都使用上改为了符号所对应的虚拟地址，由于符号和指令的相对位置是不变的，所以当求出指令的地址时，符号的地址也可以由这个重定位信息计算出来。 5.6hello的执行流程 ld-2.31.so!_dl_startld-2.31.so!_dl_inithello!_start0x400500libc-2.31.so!__libc_start_main-libc-2.31.so!__cxa_atexit-libc-2.31.so!__libc_csu_inithello!_initlibc-2.31.so!_setjmp-libc-2.31.so!_sigsetjmp–libc-2.31.so!__sigjmp_savehello!mainhello!puts@plthello!exit@plt*hello!printf@plt*hello!sleep@plt*hello!getchar@pltld-2.31.so!_dl_runtime_resolve_xsaveld-2.31.so!_dl_fixupld-2.31.so!_dl_lookup_symbol_xlibc-2.31.so!exit 5.7Hello的动态链接分析 （以下格式自行编排，编辑时删除）分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。hello程序对动态链接库的引用，利用代码段和数据段之间距离不变这一个事实，因此代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量。GNU编译系统使用了一种有趣的延迟绑定技术来解决动态库函数模块调用的问题，将过程地址的绑定推迟到了第一次调用该过程时。延迟绑定通过全局偏移量表（GOT）和过程链接表（PLT）的交互实现。如果一个目标模块调用定义在共享库中的任何函数，那么就有自己的GOT和PLT。前者是数据段的一部分，后者是代码段的一部分。下图是PLT数组。 GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[l]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。下面以printf为例子来解释动态链接：第一次调用printf：第一步：程序进入printf对应的PLT条目。第二步：第一条PLT指令通过相对应的GOT进行简介跳转，因为每个GOT条目初始都指向它对应的PLT条目的第二条指令，这个简介跳转知识简单地把控制传送回PLT[2]中的下一条指令。第三步：把printf的ID压入栈中，PTL跳转到PTL[0]第四步：PTL[0]通过GOT[1]间接地吧动态链接器的一个参数压入栈中，然后通过GOT[2]间接跳转进动态链接器中。动态连接器使用两个栈条目来确定printf的运行地址，将地址重写回printf对应的GOT，再把控制传递给printf。后续再调用printf时，GOT的间接跳转会直接将控制转移到printf。 Printf调用前GOT表 Printf调用后GOT表 5.8本章小结 链接器将我们需要的.o文件合并成一个可执行文件，这样的文件就可以在shell中执行了，我们的文件成功从原来的.c文件转换为了一个能在计算机中执行的文件。 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程是计算机科学中最深刻、最成功的概念之一。进程是正在运行的程序的实例。进程的作用： 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。2.一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 Shell：shell是一个交互型应用级程序，代表用户运行其他程序。是系统的用户界面，提供了用户与内核进行交互操作的一种接口。他就收哟洪湖输入的命令并把它送入内核去执行。2.功能：其实shell也是一支程序，它由输入设备读取命令，再将其转为计算机可以了解的机械码，然后执行它。各种操作系统都有它自己的shell，以DOS为例，它的shell就是command.com文件。如同DOS下有NDOS，4DOS，DRDOS等不同的命令解译程序可以取代标准的command.com，UNIX下除了Bourneshell（/bin/sh）外还有Cshell（/bin/csh）、Kornshell（/bin/ksh）、Bourneagainshell（/bin/bash）、TenexCshell（tcsh）等其它的shell。UNIX/linux将shell独立于核心程序之外，使得它就如同一般的应用程序，可以在不影响操作系统本身的情况下进行修改、更新版本或是添加新的功能。Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。3.处理流程：shell首先检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux本身的实用程序，如ls和rm，也可以是购买的商业程序，如xv，或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能够成功找到命令，该内部命令或应用程序将被分解为系统调用并传给Linux内核。 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的运行的子进程。调用fork函数后，新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码、数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于他们有不同的PID。fork被调用一次，却返回两次,子进程返回0，父进程返回子进程的PID。子进程有不同于父进程的PID。 6.4Hello的execve过程 Execve函数在当前的进程的上下文中加载并运行一个新程序。Execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。所以，execve调用一次并从不返回。子进程调用execve函数，在当前进程的上下文中加载并运行一个新程序即hello程序，execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行hello程序，并映射私有区域，为程序的代码，数据，bss，栈区域创建新的区域结构。新的栈和堆段被初始化为零，新的代码和数据段被初始化为可执行文件中的内容。最后加载器设置PC指向_start地址，_start最终调用hello中的main函数。。注意，execve函数再当前进程的上下文中加载并运行一个新程序。它会覆盖当前进程的地址空间，但是并没有创建一个新进程。新进程仍然有相同的PID，并继承了调用exceve函数时已打开的所有文件。 6.5Hello的进程执行 进程调度的过程：操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务。内核为每一个上下文维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫调度。在内核调度一个新的进程，上下文切换，实现 保存当前进程的上下文恢复某个先前被抢占的进程被保存的上下文将控制传递给这个心回复的进程进程时间片：一个继承执行它的控制流的一部分的每一时间段叫做时间片，当时间片的时间用尽后，若当前进程还没执行完毕，控制会转移给内核，有内核选择是否仍执行该进程。用户态与核心态转换：处理器使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权。如果没有设置模式位，进程就处于用户模式；设置模式位，进程就处于内核模式。用户模式的进程不允许执行特权指令，不允许直接应用地址空间中内核区内的代码和数据；内核模式下该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 6.6hello的异常与信号处理 乱按包括回车： 乱按的字符会保存在缓冲区内，如果在sleep这期间我们输入了字符和回车回车，则当我们的hello进程结束后，这些字符会被执行，例如图中的sd、fa、123等 Ctrl+c：会直接终止当前的进程 Ctrl+z：会停止当前的进程 停止后输入ps： 输出了执行进程的PID，TTY，TIME和我们输入的CMD。停止后输入jobs： 显示了我们当前的所有进程，包括停止的。停止后输入pstree： 停止后输入fg： 将我们的hello进程调度会前台继续执行。停止后执行kill-n921378： Hello进程被杀死。 6.7本章小结 本章介绍了进程与shell执行的相关知识。进程是计算机中最伟大的概念，有了进程才有了我们现在所身处的计算机世界。不同的进程在内核的调度下执行者自己的指令，而没有错误。在进程中遇到异常时，操作系统有着自己的方式来处理。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：在有地址变换功能的计算机中，访内指令给出的地址(操作数)叫逻辑地址，也叫相对地址。线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。虚拟地址：CPU启动保护模式后，程序运行在虚拟地址空间中，也就是程序在磁盘中使用的地址。Hello可执行文件反汇编后，每条指令前的地址就是虚拟地址物理地址：放在寻址总线上的地址。放在寻址总线上，如果是读，电路根据这个地址每位的值就将相应地址的物理内存中的数据放到数据总线中传输。如果是写，电路根据这个地址每位的值就在相应地址的物理内存中放入数据总线上的内容。物理内存是以字节(8位)为单位编址的。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址由段选择符和偏移量组成，线性地址为段首地址和逻辑地址中的偏移量组成。其中，段首地址存放在段描述符中。而段描述符存放在段描述符表中。一般逻辑地址实际是由48位组成，前16位包括[段选择符]，后32位[段内偏移量]。其中段指的是可执行文件中的代码段，数据段等等。段选择符用于寻找段描述符表，段内偏移量是指令地址相对于段基址的偏移量。段选择符的16位格式如下： 索引：描述符表的索引TI：如果TI是0。「描述符表」是「全局描述符表（GDT）」，如果TI是1。「描述符表」是「局部描述表（LDT）」RPL：段的级别。为0，位于最高级别的内核态。为11，位于最低级别的用户态。在linux中也仅有这两种级别。流程大致如下图： 其中GDT和LDT的首地址，存放在用户不可见的起存起中。这样子我们就拿到了我们要的段基地址，再加上我们的偏移量，得到了线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 从线性地址到物理地址简单来说就是下面这张图： 虚拟地址分为两部分：虚拟页号（VPN）以及和虚拟页偏移量（VPO），其中虚拟页偏移量与物理也偏移量是相同的，也就是说我们只需要找到物理页号（PPN）就可以得到我们想要的物理地址。那么物理页号存放在哪呢？它就存放在PTE页表中。我们通过VPN去页表中寻找，如果命中则取出物理页号，如果不命中，则替换该位置的PTE，再取出我们需要的物理页号。当然实际过程没这么简单，这里面还涉及了TLB的小缓存，一种关于PTE的缓存，称为翻译后备缓冲器。一般会先去TLB中寻找物理页号，若不命中则去PTE中寻找。这点接下来详细介绍。 7.4TLB与四级页表支持下的VA到PA的变换 我们知道虚拟地址分为VPN和VOP，以intelCorei7为例，Corei7支持48位虚拟地址和52位物理地址。以下图来解释： 48位的虚拟地址被划分为36位的VPN和12位的VPO。而对于TLB来说，36位的VPN有可以看成是32位的TLBT（标记）和4位的TLBI（组索引）。若命中则取出其中的PPN。若不命中，则用36位的VPN去页表中寻找，页表分为4级页表，每一页的页表对应9位的VPN片。每个片被用作到一个页表的偏移量。而2,3,4级的页表基地址由前一级的页表存储，1级的页表基地址由CR3提供。如果在PTE中仍然不命中，则替换该页。取出PPN后和VPO合并由此得到了物理地址。 7.5三级Cache支持下的物理内存访问 在我们得到物理地址后，就需要去访问物理内存，物理地址被分为3个部分，分别是CT（高速缓存标记），CI（高速缓存组索引），CO（高速缓存块偏移）。CT用来判断我们需要的内存块是否在缓存中，CI用来定位高速缓存中的组标号，CO是缓存块中的偏移。 仍以该图为例，64组，所以CI=6，每一块64字节，所以CO=6，那么CT=52-6-6=40。如果在L1cache中命中，则取出结果，如果未命中则去L2,L3,和主存中寻找。 7.6hello进程fork时的内存映射 Mm_struct（内存描述符）：描述了一个进程的整个虚拟内存空间。Vm_area_struct（区域结构描述符）：描述了进程的虚拟内存的一个空间。在fork创建虚拟内存的时候，要经历一下步骤： 创建当前进程的mm_struct，vm_area_struct和页表的原样副本两个进程的每个页面都标记为只读页面。两个进程的每个vm_area_struct都标记为私有，这样就只能在写入时复制 7.7hello进程execve时的内存映射 删除已存在的用户区域映射私有区域（.malloc，.data，.bss，.text）映射共享区域（.libc.so.data,lib.so.text）4.设置程序计数器PC，指向代码区域的入口 7.8缺页故障与缺页中断处理 缺页故障： 段错误，虚拟地址不合法保护异常，内存访问不合法 缺页中断处理：MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，执行以下步骤： 判断虚拟地址A是否合法，如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。判断试图进行的内存访问是否合法，如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。此时，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。于是，内核会选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这次MMU就能正常地翻译A，而不会引起缺页中断。 7.9动态存储分配管理 动态内存分配器为我们提供额外的虚拟内存。动态内存分配器维护者一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。 分配器有两种基本的风格，两种风格都要求应用显示地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。显示分配器，要求应用显示地释放任何已分配的块。例如，c标准库的malloc程序包隐式分配器，要求分配器检测一个已分配块合适不再被程序所使用，那么久释放这个块。隐式分配器也叫作垃圾收集器。 隐式空闲链表 A.找到一个空闲块，有以下适配方法：首次适配(Firstfit)：从头开始搜索空闲链表，选择第一个合适的空闲块。此时搜索时间与总块数是线性关系，且倾向在靠近链表起始处留下小空闲块的“碎片”，增加对较大块的搜索时间下一次适配(Nextfit)：和首次适配相似，是从链表中上一次查询结束的地方开始，这种适配比首次适应更快，可以避免重复扫描那些无用块。最佳适配(Bestfit)：查询链表，检查每一个空闲块，选择适合所需请求大小的最小空闲块，保证碎片最小，提高内存利用率，运行速度通常会慢于首次适配。B.分割(splitting)：申请空间比空闲块小，可以把空闲块分割成两部分。 C.释放并分配：清除已分配标志，合并相邻的空闲块，和下一个空闲块合并或者双向合并。 显示空闲链表 显式空闲链表采用的方式是维护空闲块链表，而不是所有块。在空闲块中储存前/后指针，而不仅仅是大小，此外还需要边界标记，用于块合并。幸运的是，只需跟踪空闲块，因此可以使用有效载荷区域。A.维护显式空闲链表方法：LIFO(last-in-first-out)策略：后进先出法。将新释放的块放置在链表的开始处。此方法优点是简单，常数时间，缺点是研究表明碎片比地址顺序法更糟糕。地址顺序法(Address-orderedpolicy)：按照地址顺序维护链表。addr(前一个块)<addr(当前回收块)<addr(下一个块)。此方法优点是研究表明碎片要少于LIFO，缺点是需要搜索。3.分离的空闲链表：分离存储，是一种流行的减少分配时间的方法。一般思路是将所有可能的块大小分成一些等价类/大小类。分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。维护方法：A.简单分离存储每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。B.分离适配每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显示或隐式链表，每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。（以下格式自行编排，编辑时删除）4.块按大小排序在每个空闲块中使用一个带指针的平衡树，并使用长度作为权值。 7.10本章小结 本章首先介绍了4种存储器的地址模式，然后是地址变换的方法，例如：逻辑地址到线性地址的变换，再从线性地址到物理地址的变换，这对应了如何将虚拟内存的数据映射到了物理内存中。其中线性地址到物理地址的变换设计了TLB缓存和4级页表，这两者的存在是为了提高转换的效率以及降低内存空间的使用。得到物理地址后，我们就需要根据物理地址去内存中寻找我们需要的内容。为了提高访问速率，三级Cache由此出现。接下来介绍了fork和execve的内存映射以及遇到缺页时，内核该怎么处理。最后就是内存的动态管理，这其中涉及了显示分配器和隐式分配器两种方式。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件设备管理：unixio接口一个Linux文件就是一个m个字节的序列B0，B1，……，Bm-1。所以的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这个设备映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得输入和输出都能以一种统一且一致的方式的来执行。 8.2简述UnixIO接口及其函数 打开文件：进程是通过调用open函数来打开一个已存在或者创建一个新文件的intopen(char*filename,intflags,mode_tmode);open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，flags参数也可以是一个或者更多位掩码的或，给写提供一些额外的指示。mode参数指定了新文件的访问权限位。关闭文件：进程通过调用close函数关闭一个打开的文件。intclose(intfd);关闭一个已关闭的描述符会出错。读和写文件：应用程序是通过分别调用read和write函数来执行输入和输出的。ssize_tread(intfd,void*buf,size_tn)；ssize_twrite(intfd,constvoid*buf,size_tn);read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF，否则返回值表示的是实际传送的字节数量。write函数从内存位置buf复制至多n个字节到描述符为fd的当前文件位置。 8.3printf的实现分析 （以下格式自行编排，编辑时删除） 我们知道printf函数的参数是不确定的，所以我们就需要确定具体的参数个数。va_list的定义：，说明它是一个字符指针。(char*)(&fmt)+4表示的是第二个参数，也就是……中的第一个参数。因为&fmt表示的是fmt的地址，是char*类型的指针，其大小为4，所以我们加上4后表示的就是第二个参数的首地址。 vsprintf的作用是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。然后sys_call显示格式化了的字符串。内核会通过字符显示子程序，根据传入的ASCII码到字模库读取字符对应的点阵，然后通过vram（显存）对字符串进行输出。显示芯片将按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量），最终实现printf中字符串在屏幕上的输出。 8.4getchar的实现分析 （以下格式自行编排，编辑时删除） 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章介绍了UnixI/O接口以及I/O函数，分析了printf和getchar的实现。（第8章1分）结论Hello的一生：1.程序员通过I/O设备，往计算机里敲入代码，编写出hello.c文件2.hello.c在预处理器下经过预处理形成hello.i文件3.hello.i在编译器下经过编译形成hello.s文件4.hello.s在汇编器下经过汇编形成hello.o文件5.hello.o在链接器下与其他.o文件链接形成hello可执行文件6.shell为hello文件分配空间形成进程，到前台执行7.shell通过fork()函数创建一个子进程，在子进程中通过execve函数加载hello城西，建立hello可执行文件到虚拟内存的映射。8.在执行hello时，发生了缺页中断，触发了缺页中断处理程序。9.内核将hello文件的虚拟内存映射为物理内存，将虚拟地址翻译为物理地址。再根据这个物理地址去Cache/主存内读取数据、指令。10.printf执行，将格式化结果显示到了shell中11.hello进程终止，向父程序shell发送SIGCHLD信号12.将hello进程进行回收感悟：一个文件的执行，不像我们看起来的那么简单，他需要涉及许多复杂且伟大的过程，许多创新性地概念。例如进程的提出用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。（结论0分，缺失-1分，根据内容酌情加分） 附件 Hello可执行文件Hello.i预处理后文件Hello.s编译后文件Hello.o汇编后文件Hello_.s反汇编文件 参考文献 为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp.（参考文献0分，缺失-1分） 

代码之路 SPF（Tarjan算法应用） SPF 题目ProblemDescriptionInputOutputSampleInputSampleOutpit 思路相关知识：Tarjan算法，dfs序 AC代码小结 题目 ProblemDescription Considerthetwonetworksshownbelow.Assumingthatdatamovesaroundthesenetworksonlybetweendirectlyconnectednodesonapeer-to-peerbasis,afailureofasinglenode,3,inthenetworkontheleftwouldpreventsomeofthestillavailablenodesfromcommunicatingwitheachother.Nodes1and2couldstillcommunicatewitheachotherascouldnodes4and5,butcommunicationbetweenanyotherpairsofnodeswouldnolongerbepossible. Node3isthereforeaSinglePointofFailure(SPF)forthisnetwork.Strictly,anSPFwillbedefinedasanynodethat,ifunavailable,wouldpreventatleastonepairofavailablenodesfrombeingabletocommunicateonwhatwaspreviouslyafullyconnectednetwork.Notethatthenetworkontherighthasnosuchnode;thereisnoSPFinthenetwork.Atleasttwomachinesmustfailbeforethereareanypairsofavailablenodeswhichcannotcommunicate. Input Theinputwillcontainthedescriptionofseveralnetworks.Anetworkdescriptionwillconsistofpairsofintegers,onepairperline,thatidentifyconnectednodes.Orderingofthepairsisirrelevant;12and21specifythesameconnection.Allnodenumberswillrangefrom1to1000.Alinecontainingasinglezeroendsthelistofconnectednodes.Anemptynetworkdescriptionflagstheendoftheinput.Blanklinesintheinputfileshouldbeignored. Output Foreachnetworkintheinput,youwilloutputitsnumberinthefile,followedbyalistofanySPFnodesthatexist. Thefirstnetworkinthefileshouldbeidentifiedas“Network#1”,thesecondas"Network#2",etc.ForeachSPFnode,outputaline,formattedasshownintheexamplesbelow,thatidentifiesthenodeandthenumberoffullyconnectedsubnetsthatremainwhenthatnodefails.IfthenetworkhasnoSPFnodes,simplyoutputthetext“NoSPFnodes”insteadofalistofSPFnodes.Separatetestcaseswithablankline. SampleInput 1254313234350 12233445510 122334466325510 0 SampleOutpit Network#1（两空格）SPFnode3leaves2subnets Network#2（两空格）NoSPFnodes Network#3（两空格）SPFnode2leaves2subnets（两空格）SPFnode3leaves2subnets 思路 相关知识：Tarjan算法，dfs序 思路来源： 割点相关知识1:链接.割点相关知识2:链接. 笔记：dfn[]：记录的是节点的dfs序low[]：记录的是强连通分量/环中的最早的根子节点的dfs序搜查的时候会出现2中情况，设搜查点为v，分别为：v搜查过，v为搜查过。 未搜查时，则继续dfs，回溯时更新low，low[v]=min（low[u],low[v]）搜查过时，假设是从u去搜查，则显然dfn[u]>dfn[v]，则low[v]=min(low[u],low[v] 若出现回边，low一定会更新。 AC代码 #include<stdio.h> #include<stdlib.h> #defineM1010 /*runthisprogramusingtheconsolepauseroraddyourowngetch,system("pause")orinputloop*/ intdfn[M],low[M],head[M],cut[M],vis[M]; intcnt,num,root,root_son,test,n; //dfn记录i个点搜索的序号，low记录强连通分量（环）的根子节点，head记录第i个点加边的最后一条，vis记录dfs是否搜查 //cnt标记加边的序号，num标记搜查序号，root代表跟，root_son根子树，n代表节点数量 structEDG{ intto;//边的指向 intnext;//该节点上一条加入的边的序号 }edg[M*20]; voidinit(){ memset(dfn,0,sizeof(dfn)); memset(cut,0,sizeof(cut)); memset(low,0,sizeof(low)); memset(head,-1,sizeof(head)); memset(edg,0,sizeof(edg)); test++; n=1; cnt=0; num=1; } voidaddedge(intu,intv){ edg[cnt].to=v; edg[cnt].next=head[u];//该节点上一条边序号位置 head[u]=cnt++; } intmax(inta,intb){ returna>b?a:b; } intmin(inta,intb){ returna<b?a:b; } voidTarjan(intu){ inti; low[u]=dfn[u]=num++; for(i=head[u];i!=-1;i=edg[i].next){ intv=edg[i].to; if(!dfn[v]){ Tarjan(v); if(u==root){//如果是跟，则其子树数量加一 root_son++; } else{ if(low[u]>low[v]){//回溯时,若low[u]>low[v],说明存在强连通分量,将low[u]更新为根节点的dfs序 low[u]=low[v]; } if(low[v]>=dfn[u]){//若low[v]>dfn[u],说明是割点 cut[u]=1; } } } else{//若该点已搜查过，则显然dfn[u]>dfn[v],此时比较low[u]和dfn[v]即可 low[u]=min(low[u],dfn[v]); } } } voiddfs(intu){//查找割点的子树 vis[u]=1; for(inti=head[u];i!=-1;i=edg[i].next){ intv=edg[i].to; if(!vis[v]){ dfs(v); } } } intmain(){ intu,v,flag; test=0; while(scanf("%d",&u),u){ init(); n=max(u,n); scanf("%d",&v); n=max(v,n); addedge(u,v); addedge(v,u); while(scanf("%d",&u),u){ n=max(u,n); scanf("%d",&v); n=max(v,n); addedge(u,v); addedge(v,u); }//输入 root=1,root_son=0,flag=0; Tarjan(root); if(root_son>1){ cut[root]=1; } printf("Network#%d\n",test); for(inti=1;i<=n;i++){ if(cut[i]){ flag=1; memset(vis,0,sizeof(vis)); intson=0; vis[i]=1; for(intj=head[i];j!=-1;j=edg[j].next){ v=edg[j].to; if(!vis[v]){ dfs(v); son++; } } printf("SPFnode%dleaves%dsubnets\n",i,son); } } if(!flag){ printf("NoSPFnodes\n"); } printf("\n"); } return0; } 小结 Tarjan算法可以用来寻找有向图中的强连通分量，或是无向图中的环 

DecodingTask DecodingTask 题目思路AC代码 题目 题目偏长，放一个链接http://acm.hit.edu.cn/problemset/1012. 思路 本题难度感觉在于题目理解，题目要求2个十六进制数来代表一个btye，所以首先2个字符2个字符处理，转换为十进制。由于第二串字符（记为bi）多出一个空格（由十进制的32表示）。所以先用32异或b[1]，得到第一个密匙，在与第一串字符（记为ai）a[1]异或，得到明文，以此类推。 AC代码 #include<stdio.h> #include<stdlib.h> #include<string.h> #defineM20006 /*runthisprogramusingtheconsolepauseroraddyourowngetch,system("pause")orinputloop*/ chara[M],b[M],c[M]; intans[M]; intlen; intcread(charx){16进制转换为10进制 if(x>='A'){ returnx-'A'+10; } if(x>='0'&&x<='9'){ returnx-'0'; } } voidtodec(char*x){先将第一个字符串转换为十进制 for(inti=0;i<len;i+=2){ ans[i/2]=cread(x[i])*16+cread(x[i+1]); } } intmain(intargc,char*argv[]){ while(scanf("%s%s",a,b)!=EOF){ len=strlen(a); todec(a); intex=32,cnt=0; for(inti=0;i<len+2;i+=2){ intx=cread(b[i]),y=cread(b[i+1]); x=x*16+y; ex=ex^x; printf("%02X",ex); ex=ans[cnt++]^ex; } printf("\n"); } } 

由Cache引发的关于Malloc函数的思考 关于Malloc函数的一些理解 思考缘由 思考缘由 在计算机系统的实验6中，需要我们根据输入的要求去init一个Cache缓存器。代码如下：其中注释的内容是我后续为了理解mallo添加语句。这个init是这样子实现的：我们知道一个Cache中有多个组，每个组中又有多行缓存块。在我们这个init函数中，S是组的数量，E是行的数量。我们先mallocinitCache的组数，然后再对每一组malloc行数。用二维数组来理解的话就是我们先malloc行数，再malloc列数。这里就有一个问题，由于cache_set_t的大小根据要求是给定的：当我malloc组数之后，我们又如何能够对每一组去扩充他的行数？所以将cache中的信息都打印出来：我们发现Cache中的每一组都是连续的，161400,161408,161410。而每一组的每一行的地址是从164120开始，也就是说后续我们新扩增的Cache行是在后面增加的而不是我一开始想象中的类似矩阵一样连续的。 在写这个blog时，我忽然发现：Cache中的一维数组存的是一个指针，也就是这个指针指向了二维数组的位置，所以malloc才会是这样子的一个映射关系，而不像通常数组那样是连续的地址。 

hdu1066Lastnon-zeroDigitinN!详解 代码之路 hdu1066Lastnon-zeroDigitinN! 题目InputOutputSampleInputSampleOutput 思路AC代码 题目 题目链接：hdu1066 TheexpressionN!,readas“Nfactorial,”denotestheproductofthefirstNpositiveintegers,whereNisnonnegative.So,forexample,NN!011122364245120103628800Forthisproblem,youaretowriteaprogramthatcancomputethelastnon-zerodigitofthefactorialforN.Forexample,ifyourprogramisaskedtocomputethelastnonzerodigitof5!,yourprogramshouldproduce“2”because5!=120,and2isthelastnonzerodigitof120. Input Inputtotheprogramisaseriesofnonnegativeintegers,eachonitsownlinewithnootherletters,digitsorspaces.ForeachintegerN,youshouldreadthevalueandcomputethelastnonzerodigitofN!. Output Foreachintegerinput,theprogramshouldprintexactlyonelineofoutputcontainingthesinglelastnon-zerodigitofN!. SampleInput 122612531259999 SampleOutput 124828 思路 思路来源稍微对上面的内容补充些自己的理解。 首先考虑N！，显然N！=1*2*3*4*5*……*N；在这里先做一个处理，每次遇到5的倍数就先乘2再除二，这也就是上面链接所说的将5当做1的原因。这样处理的好处就是尾数在未除2时，会以10为周期方便计算。所以当N>10时候，只需要10个分一组，由于6*6=6，所以只需最后乘上6即可。而N有[N/5]个5的倍数，就需要除于[N/5]个2，于是有递归式子： F ( N ) = F [ N / 5 ] ∗ t a b l e [ N 的 尾 数 ] ∗ 6 2 [ N / 5 ] F(N)=\frac{F[N/5]*table[N的尾数]*6}{2^{[N/5]}} F(N)=2[N/5]F[N/5]∗table[N的尾数]∗6​ 而式子中的F(N/5)是什么意思呢？由于我们前面将5的倍数乘于2，然后将其当做1处理，实际上是将他们提取出来，有如下一个表格： 510152010203040 忽略末尾的0，显然就有1*2*3*4，其结果就是F(N/5)。而注意到2^1=2,2^2=4,2^3=8,2^4=16,2^5=32。以4为循环周期。于是将分母的N/5mod4即可。更正式子为如下： F ( N ) = F [ N / 5 ] ∗ t a b l e [ N 的 尾 数 ] ∗ 6 2 [ N / 5 ] M o d 4 F(N)=\frac{F[N/5]*table[N的尾数]*6}{2^{[N/5]Mod4}} F(N)=2[N/5]Mod4F[N/5]∗table[N的尾数]∗6​ 由于table以10为循环周期，2以4为循环周期，于是有 t a b l e [ N 的 尾 数 ] ∗ 6 2 [ N / 5 ] M o d 4 \frac{table[N的尾数]*6}{2^{[N/5]Mod4}} 2[N/5]Mod4table[N的尾数]∗6​以20为循环周期。 所以只需要打出上述的表格mod[20]={1,1,2,6,4,2,2,4,2,8,4,4,8,4,6,8,8,6,8,2}，去查找即可。由于本题的N较大，所以需要高精度计算。至此解释完毕。 AC代码 #include<stdio.h> #include<string.h> #defineMax10000000 intmod[20]={1,1,2,6,4,2,2,4,2,8,4,4,8,4,6,8,8,6,8,2}; charn[Max]; inta[Max]; intmain(){ inti,len,f,temp; while(~scanf("%s",&n)){ f=1; len=strlen(n); for(i=0;i<len;i++){ a[i]=n[len-1-i]-'0'; } while(len){ len-=!a[len-1]; f=f*mod[a[1]%2*10+a[0]]%10;//f为文中的F（N） for(temp=0,i=len-1;i>=0;i--){//把数除于5 temp=temp*10+a[i]; a[i]=temp/5; temp%=5; } } printf("%d\n",f); } } 

代码之路-Joseph‘sproblemI（Joseph问题） 1016-Joseph'sproblemI（Joseph问题） 题目ProblemDescriptionInputOutputSampleInputSampleOutput 思路AC代码 题目 ProblemDescription TheJoseph’sproblemisnotoriouslyknown.Forthosewhoarenotfamiliarwiththeproblem,amongnpeoplenumbered1,2…n,standingincircleeverymthisgoingtobeexecutedandonlythelifeofthelastremainingpersonwillbesaved.Josephwassmartenoughtochoosethepositionofthelastremainingperson,thussavinghislifetogivethemessageabouttheincident.AlthoughmanygoodprogrammershavebeensavedsinceJosephspreadoutthisinformation,Joseph’scousinintroducedanewvariantofthemalignantgame.Thisinsanecharacterisknownforitsbarbarianideasandwishestocleanuptheworldfromsillyprogrammers.WehadtoinfiltratesometheagentsoftheACMinordertoknowtheprocessinthisnewmortalgame.Inordertosaveyourselffromthisevilpractice,youmustdevelopatoolcapableofpredictingwhichpersonwillbesaved.TheDestructiveProcessThepersonsareeliminatedinaverypeculiarorder;misadynamicalvariable,whicheachtimetakesadifferentvaluecorrespondingtotheprimenumbers’succession(2,3,5,7…).Soinordertokilltheithperson,Joseph’scousincountsuptotheithprime. Input Itconsistsofseparatelinescontainingn[1…3501],andfinisheswitha0. Output Theoutputwillconsistinseparatelinescontainingthepositionofthepersonwhichlifewillbesaved. SampleInput 6 SampleOutput 4 思路 约瑟夫环指的是在n个人中，从第一个人开始数数，数到m时，第m个人就被淘汰，之后再继续从第m+1个人开始重新数数。求最后被留下来的人在初始n个人中排第几个。而本题m是变量。不过只要修改下求解方程即可。约瑟夫环可以从一开始开始求解，不过此时需要创立数组进行维护，由于维护非常麻烦，所以想到能否从最后一个开始去逆推。于是找到了如下的关系式 x’(第n轮的序号)=x(第n-1轮的序号)-(m(要数的个数)%people（第n-1轮的人数） 修改下为如下式子：x=(x’+m(第n-1轮要数的个数))%people AC代码 #include<stdio.h> #include<stdlib.h> #defineMax3502 /*runthisprogramusingtheconsolepauseroraddyourowngetch,system("pause")orinputloop*/ intprime[Max]; voidisprime(){ intcnt=0,i=3; prime[cnt++]=2; while(1){ intflag=0; for(intj=2;j<i;j++){ if(i%j==0){ flag=1; break; } } if(flag==0){ prime[cnt++]=i; } if(cnt>Max){ break; } i+=2; } } intmain(){ intn; isprime(); while(scanf("%d",&n),n){ intcut=n-2,ans=0,people=2; for(;cut>=0;cut--,people++){ intbox=prime[cut]; ans=(ans+box)%people; } printf("%d\n",ans+1); } return0; } 

代码之路 FastFood FastFood 题目思路代码 题目 ThefastfoodchainMcBurgerownsseveralrestaurantsalongahighway.Recently,theyhavedecidedtobuildseveraldepotsalongthehighway,eachonelocatedatarestaurantandsupplyingseveraloftherestaurantswiththeneededingredients.Naturally,thesedepotsshouldbeplacedsothattheaveragedistancebetweenarestaurantanditsassigneddepotisminimized.Youaretowriteaprogramthatcomputestheoptimalpositionsandassignmentsofthedepots. Tomakethismoreprecise,themanagementofMcBurgerhasissuedthefollowingspecification:Youwillbegiventhepositionsofnrestaurantsalongthehighwayasnintegersd1<d2<…<dn(thesearethedistancesmeasuredfromthecompany’sheadquarter,whichhappenstobeatthesamehighway).Furthermore,anumberk(k<=n)willbegiven,thenumberofdepotstobebuilt. Thekdepotswillbebuiltatthelocationsofkdifferentrestaurants.Eachrestaurantwillbeassignedtotheclosestdepot,fromwhichitwillthenreceiveitssupplies.Tominimizeshippingcosts,thetotaldistancesum,definedas mustbeassmallaspossible. Writeaprogramthatcomputesthepositionsofthekdepots,suchthatthetotaldistancesumisminimized. InputTheinputfilecontainsseveraldescriptionsoffastfoodchains.Eachdescriptionstartswithalinecontainingthetwointegersnandk.nandkwillsatisfy1<=n<=200,1<=k<=30,k<=n.Followingthiswillnlinescontainingoneintegereach,givingthepositionsdioftherestaurants,orderedincreasingly. Theinputfilewillendwithacasestartingwithn=k=0.Thiscaseshouldnotbeprocessed. OutputForeachchain,firstoutputthenumberofthechain.Thenoutputalinecontainingthetotaldistancesum. Outputablanklineaftereachtestcase. 思路 1.如果已知从第i个商店到第j个商店中有一个仓库，则这个仓库位于中间，也就是中位数（i+j）/2，原因如下：假设在5个商店中有一个仓库，则对于最远的2个商店，也就是第1个和第5个，无论仓库位于哪里，其路程和都是第1个仓库到第5个仓库的距离，此时可以不再讨论仓库对于这两个商店的影响，此时要讨论的商店仅剩3个，再依据上面的思路去讨论类似的问题，最后仅剩1个商店或2个商店，则仓库位于中位数处是距离和最小的。（反证即可）2.依据上面的思路进行动态规划。dp[i][j]代表前j个商店有i个仓库，找到动态转移方程： dp[i][j]=min(dp[i][j],dp[i-1][m]+cost[m+1][j]) 其中i-1<=m<=j-1,由于仓库数量确定为i-1，而商店数量未知，但可以确定他的取值范围。（第i-1个仓库在第i-1个商店）m=i-1,（第i个仓库在j处），则m=j-1。 代码 #include<stdio.h> #include<stdlib.h> #include<stdlib.h> #defineMax10000 /*runthisprogramusingtheconsolepauseroraddyourowngetch,system("pause")orinputloop*/ intdp[40][210]; intcost[210][210]; intdis[210]; intmin(intx,inty){ returnx>y?y:x; } intmain(intargc,char*argv[]){ intn,k,i,j,count=0; while(scanf("%d%d",&n,&k)==2&&n!=0&&k!=0){ count++; memset(dp,Max,sizeof(dp)); memset(cost,0,sizeof(cost)); memset(dis,0,sizeof(dis)); for(i=1;i<=n;i++){ scanf("%d",dis+i); } for(i=1;i<=n;i++){//计算从第i个餐厅到第j个餐厅只有一个仓库距离的求和 for(j=i;j<=n;j++){ for(intm=i;m<=j;m++){ cost[i][j]+=abs(dis[m]-dis[(i+j)/2]); } } } for(i=1;i<=n;i++){//街上只有一个商店，此时距离和为cost dp[1][i]=cost[1][i]; } for(i=2;i<=k;i++){//i代表街上的仓库数量 for(j=i;j<=n;j++){//j代表街上商店的数量，商店要大于等于仓库数量 for(intm=i-1;m<=j-1;m++){//状态转移方程，从i-1个仓库去推，由于商店数量未知，但知道其范围为i-1~j-1 dp[i][j]=min(dp[i][j],dp[i-1][m]+cost[m+1][j]); } } } printf("Chain%d\n",count); printf("Totaldistancesum=%d\n",dp[k][n]); printf("\n"); } } 

2021哈工大计算机系统大作业 程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机类 学 号 1190200817 班 级 1936602 学 生 刘小川 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文介绍了hello的整个生命过程。利用gcc，gdb，edb，readelf，HexEdit等工具具体分析了hello从源程序开始，历经预处理、编译、汇编、链接的一系列步骤变为可执行文件的过程，即P2P的过程。同时还具体分析了hello在运行过程中涉及的进程管理、内存管理、IO管理到最后hello被回收，即020的过程。通过对hello这个简单程序的详细分析，我们能够更加深入地理解计算机系统。 关键词：Hello’sP2P；进程管理；内存管理；I/O管理 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -5- 1.1Hello简介 -5- 1.2环境与工具 -5- 1.3中间结果 -5- 1.4本章小结 -6- 第2章预处理 -7- 2.1预处理的概念与作用 -7- 2.2在Ubuntu下预处理的命令 -8- 2.3Hello的预处理结果解析 -9- 2.4本章小结 -9- 第3章编译 -10- 3.1编译的概念与作用 -10- 3.2在Ubuntu下编译的命令 -10- 3.3Hello的编译结果解析 -11- 3.3.1数据 -11- 3.3.2赋值操作 -13- 3.3.3类型转换 -13- 3.3.4算术操作 -13- 3.3.5关系操作 -14- 3.3.6数组操作 -14- 3.3.7控制转移 -15- 3.3.8函数操作 -15- 3.4本章小结 -16- 第4章汇编 -17- 4.1汇编的概念与作用 -17- 4.2在Ubuntu下汇编的命令 -17- 4.3可重定位目标elf格式 -17- 4.3.1ELF头 -17- 4.3.2节头部表 -18- 4.4.3符号表 -19- 4.3.4重定位节 -20- 4.4Hello.o的结果解析 -21- 4.5本章小结 -23- 第5章链接 -24- 5.1链接的概念与作用 -24- 5.2在Ubuntu下链接的命令 -24- 5.3可执行目标文件hello的格式 -24- 5.3.1ELF头 -25- 5.3.2节头部表 -26- 5.3.3程序头部表 -27- 5.3.4符号表 -27- 5.3.5重定位节 -29- 5.4hello的虚拟地址空间 -29- 5.5链接的重定位过程分析 -31- 5.6hello的执行流程 -33- 5.7Hello的动态链接分析 -33- 5.8本章小结 -35- 第6章hello进程管理 -36- 6.1进程的概念与作用 -36- 6.2简述壳Shell-bash的作用与处理流程 -36- 6.3Hello的fork进程创建过程 -36- 6.4Hello的execve过程 -37- 6.5Hello的进程执行 -37- 6.6hello的异常与信号处理 -38- 6.6.1可能出现的异常及处理方法 -38- 6.6.2可能产生的信号及处理方法 -39- 6.7本章小结 -41- 第7章hello的存储管理 -42- 7.1hello的存储器地址空间 -42- 7.2Intel逻辑地址到线性地址的变换-段式管理 -42- 7.3Hello的线性地址到物理地址的变换-页式管理 -43- 7.4TLB与四级页表支持下的VA到PA的变换 -43- 7.5三级Cache支持下的物理内存访问 -45- 7.6hello进程fork时的内存映射 -46- 7.7hello进程execve时的内存映射 -46- 7.8缺页故障与缺页中断处理 -47- 7.9动态存储分配管理 -48- 7.10本章小结 -51- 第8章hello的IO管理 -52- 8.1Linux的IO设备管理方法 -52- 8.2简述UnixIO接口及其函数 -52- 8.3printf的实现分析 -53- 8.4getchar的实现分析 -54- 8.5本章小结 -54- 结论 -55- 附件 -56- 参考文献 -57- 第1章概述 1.1Hello简介 简述Hello的P2P，020的整个过程。 Hello的P2P（FromProgramtoProcess）过程：在文本编辑器或IDE中编写C语言代码，得到最初的hello.c程序，即最初的Program。编译器驱动程序代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。驱动程序首先运行C预处理器（cpp），将C的源程序hello.c翻译成一个ASCII码的中间文件；然后运行C编译器（cc1）将中间文件翻译成一个ASCII汇编语言文件；之后运行汇编器（as）将汇编语言文件翻译成可重定位目标文件；最后运行链接器（ld）创建一个可执行目标文件hello。在shell中输入执行hello的命令，shell解析命令行，通过fork新建一个子进程来执行hello，这时Hello已经从Program转换为Process了。 Hello的020（FromZero-0toZero-0）过程：子进程调用execve，重新为hello进行内存映射，设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。进入程序入口后通过存储管理机制将指令和数据载入内存，CPU以流水线形式读取并执行指令，执行逻辑控制流。操作系统负责进程调度，为进程分时间片。执行过程中通过L1、L2、L3高速缓存、TLB、多级页表等进行存储管理，通过I/O系统进行输入输出。当程序运行结束后，shell回收hello进程，删除和该进程相关的内容，这时hello进程就不存在了。hello从开始的未被内存映射到运行再到回收后不再存在，就是020的过程。 1.2环境与工具 硬件环境：X64CPU；2.6GHz；16GRAM；256GHDDisk 软件环境：Windows1064位；Vmware16；Ubuntu16.04LTS64位 开发与调试工具：gcc，gdb，edb，readelf，HexEdit 1.3中间结果 hello.i：C预处理器产生的一个ASCII码的中间文件，用于分析预处理过程。 hello.s：C编译器产生的一个ASCII汇编语言文件，用于分析编译的过程。 hello.o：汇编器产生的可重定位目标程序，用于分析汇编的过程。 hello：链接器产生的可执行目标文件，用于分析链接的过程。 hello.txt：hello.o的反汇编文件，用于分析可重定位目标文件hello.o。 hellold.txt：hello的反汇编文件，用于分析可执行目标文件hello。 helloelf.txt：hello.o的ELF格式，用于分析可重定位目标文件hello.o。 helloldelf.txt：hello的ELF格式，用于分析可执行目标文件hello。 1.4本章小结 本章简述了Hello的P2P、020的整个过程并介绍了实验的基本信息：环境、工具以及实验的中间结果。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 预处理是指在进行编译的第一遍扫描之前所做的工作，是C语言的一个重要功能，由预处理程序负责完成。预处理在源代码编译之前对其进行的一些文本性质的处理，生成扩展的C源程序。C语言提供了多种预处理功能，包括宏定义、文件包含、条件编译等。 预处理指令是以‘#’开头的代码行。‘#’必须是该行除了空白字符外的第一个字符。‘#’后面是指令关键字，整行语句构成一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。下图是ANSI标准定义的C语言预处理指令。 图2-1C语言预处理指令 宏定义（#define）使用宏名来表示一个字符串，宏展开时以该字符串取代宏名。这是一种简单的文本替换，预处理程序对它不做任何检查。如有错误，只能在后续编译源程序时发现。文件包含指令（#include）把指定头文件插入到该指令行的位置取代该指令行，从而把指定的文件和当前的源程序文件连成一个源文件。条件编译指令（#ifdef，#ifndef，#else，#elif，#endif等）对源程序中一部分内容只在满足一定条件时才进行编译，即指定编译的条件。可以按不同的条件去编译不同的程序部分，从而产生不同的目标代码文件。 预处理程序还可以识别一些特殊的符号。__FILE__：包含当前程序文件名的字符串；__LINE__：表示当前行号的整数；__DATE__：包含当前日期的字符串；__STDC__：如果编译器遵循ANSIC标准，则是非零值；__TIME__：包含当前时间的字符串。预处理程序对于在源程序中出现的这些串将用合适的值进行替换。 合理地使用预处理功能编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。 2.2在Ubuntu下预处理的命令 预处理的命令：gcc-Ehello.c-ohello.i 预处理过程如图所示： 图2-2预处理命令 图2-3预处理结果 2.3Hello的预处理结果解析 查看预处理产生的hello.i文件，可以发现main函数以及定义全局变量的代码没有任何改变，而原来前面的#include语句被替换成了大量的头文件中的内容，包括外部函数的声明、结构体等数据结构的定义、数据类型的定义等内容。源程序开头的注释也被删除了。同时，如果有#define的话，还会进行相应的符号替换。但是可以看出，预处理的结果仍然是可以阅读的C语言程序，预处理只是对源程序进行了一些文本性质的处理，生成的是扩展的C源程序。 图2-4hello.i的部分结果 2.4本章小结 本章介绍了预处理的概念和作用，结合实际程序分析了预处理的过程，包括宏替换、头文件引入、删除注释、条件编译等。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的过程将预处理产生的ASCII码中间文件hello.i翻译成一个ASCII汇编语言文件hello.s。编译会对预处理文件进行词法分析、语法分析、优化等操作，将C语言这种高级语言转换为成更低级、更底层、机器更好理解的汇编语言程序。 词法分析对由字符组成的单词进行处理，从左至右逐个字符地对源程序进行扫描，产生一个个的单词符号，把作为字符串的源程序改造为单词符号串的中间程序。语法分析以单词符号作为输入，分析单词符号串是否形成符合语法规则的语法单位，如表达式、赋值、循环等，最后看是否构成一个符合要求的程序，按语言的语法规则分析检查每条语句是否有正确的逻辑结构（语法规则可用上下文无关文法来刻画）。代码优化对程序进行等价的变换，使得变换后的程序能产生更有效的目标代码。这种等价的变换不改变程序的运行结果，同时使得程序运行时间更短，占用的存储空间更小。如果在编译的过程中发现源程序有错误，会报告错误的性质和发生位置。但一般情况下，编译器只做语法检查和最简单的语义检查，而不检查程序的逻辑。 汇编语言程序比源程序的层次更低，但是与机器代码相比程序员更容易理解，汇编语言相当于高级语言和机器语言之间的过渡，是从源程序转换到机器代码的关键中间环节。 3.2在Ubuntu下编译的命令 编译的命令：gcc-Shello.i-ohello.s 编译过程如图所示： 图3-1编译命令 图3-2hello.s的部分结果 3.3Hello的编译结果解析 3.3.1数据 （1）常量：hello.c源程序中的两个printf的参数是字符串常量，分别为"Usage:Hello学号姓名！\n"和"Hello%s%s\n"。 图3-3hello.c中的字符串常量 在编译生成的hello.s中可以看到，这两个字符串常量分别由.LC0和.LC1指示，均存放在只读数据段.rodata中。 图3-4hello.s中的字符串常量 （2）全局变量：hello.c源程序中的sleepsecs是全局变量，且已被赋初值。 在编译生成的hello.s中可以看到，使用.global将sleepsecs标记为全局变量。.data表明全局变量sleepsecs存放在数据段.data中；.align要求4字节对齐；.size表明变量为4字节；最后.long给出了变量的初值为2。 图3-5hello.s中的全局变量 （3）局部变量：hello.c源程序中的局部变量包括i，用于循环的计数。 图3-6hello.c中的局部变量 分析hello.s中为for循环产生的汇编代码，可以看出i被存储在%rbp-4的内存地址处。其中movl为i赋初值0，addl在每次循环时对i增加1，cmpl比较i和9的大小来决定什么时候结束循环。因此局部变量i是存放在栈上的，并通过相对栈顶（%rsp）的偏移量来访问。 图3-7hello.s中的局部变量 hello.c中的其他局部变量还包括argc和argv，同样地，它们都存放在栈上的，并通过相对栈顶（%rsp）的偏移量来访问。 （4）关于数据的类型：在编译过程中，编译器会根据源程序中数据的类型来选取不同的寄存器以及不同的指令，比如浮点数会选择XMM寄存器，整数或指针会选择通用目的寄存器，同时也会根据数据的字节大小选择寄存器的不同部分以及指令的后缀。但在编译完成后，所有的类型信息都不复存在了，无法根据产生的汇编代码推断某个数据的类型。 3.3.2赋值操作 hello.c源程序中一共包括两次赋值操作，分别是对全局变量sleepsecs赋初值和对循环变量i赋初值。 图3-8hello.c中的赋值操作 对于全局变量赋初值，这个值直接存储在数据段.data中；而如果不对全局变量赋初值的话，变量会存放在.bss段。而对于其他情况，在不考虑优化的前提下，所有的赋值操作都转化成mov类的数据传送指令。指令的后缀取决于操作数据的字节大小，movb：一个字节；movw：两个字节；movl：四个字节；movq：八个字节。以对i赋值为例，由于i为四字节，因此使用指令movl. 图3-9hello.s中对应赋值操作的指令 3.3.3类型转换 hello.c源程序中只包含一次隐式的类型转换，出现在全局变量赋初值的时候。 对于隐式类型转换，编译器会自己直接进行转换，在这个例子中，2.5被隐式类型转换为int型，编译器直接将转换后的值2放在了相应的数据段中。 图3-10编译时的隐式类型转换 3.3.4算术操作 hello.c源程序中只包含一次算术操作，出现在循环变量i每次增加1的时候。算术操作为++。 算术操作++代表自增1的运算，编译时转化成add类的加法指令，使用立即数1来实现每次增加1. 图3-11hello.s中的++操作 其他和算术操作相关的指令还包括inc,dec,neg,sub,imul等等。 3.3.5关系操作 hello.c源程序中出现了两次关系操作。 （1）在if中判断argc的取值是否不等于3. 编译时使用cmpl指令将argc和3进行比较，并设置条件码。跳转指令je根据条件码决定是否跳转。对于关系操作!=来说，可以选择je或者jne跳转指令。 图3-12hello.s中的关系操作 （2）在for循环中判断结束条件，即判断i是否小于10。 类似地，编译时使用cmpl指令将i和9进行比较，并设置条件码。跳转指令jle根据条件码决定是否跳转。这里进行比较的值是9而不是10，与编译的过程中进行了优化有关。 图3-13hello.s中的关系操作 3.3.6数组操作 hello.c源程序中有关数组的操作出现在访问argv元素的时候，通过argv[1]和argv[2]访问了字符指针数组中的元素。 汇编代码中使用首地址+偏移量的方式来访问数组元素，数组首地址存储在%rbp-32的位置，通过将首地址加8获得argv[1]的地址，将首地址加16获得argv[2]的地址。值得注意的是，编译器会根据引用的数据类型的大小进行伸缩而不用程序员操心。由于这里的数组是指针数据，因此伸缩因子为8. 图3-14hello.s中的数组操作 3.3.7控制转移 hello.c源程序中出现了两次控制转移。 （1）if判断argc的取值后的控制转移。 编译时使用cmpl指令将argc和3进行比较，并设置条件码。跳转指令je根据条件码决定是否跳转。控制转移由指令je完成。 图3-15hello.s中的控制转移 （2）每次for循环结束时的控制转移。 类似地，编译时使用cmpl指令将i和9进行比较，并设置条件码。跳转指令jle根据条件码决定是否跳转。控制转移由指令jle完成。 图3-16hello.s中的控制转移 3.3.8函数操作 （1）函数的调用：hello.c源程序中一共出现了五次函数调用。 图3-17hello.c中的函数调用 编译时，所有的函数调用都转换成了指令call，后面跟着调用函数的名字。 图3-18hello.s中的函数调用 （2）参数的传递：大部分的参数传递通过寄存器实现，通过寄存器最多传递6个参数，按照顺序依次为%rdi、%rsi、%rdx、%rcx、%r8、%r9。多余的参数通过栈来传递。在hello.c这个例子中，对于第一个函数printf，只有一个参数，通过寄存其%edi传递。 图3-19hello.s中的参数传递 对于第二个函数exit，只有一个参数，通过寄存器%edi传递。 图3-20hello.s中的参数传递 对于第三个函数printf，有三个参数，分别通过寄存器%edi、%rsi、%rdx传递。 图3-21hello.s中的参数传递 对于第四个函数sleep，只有一个参数，通过寄存器%edi传递。 图3-22hello.s中的参数传递 最后一个函数getchar没有参数，无需传递。 （3）函数的返回：编译时，在函数的最后添加指令ret来实现函数的返回。在hello.c这个例子中，只能看到main函数的返回。 图3-23hello.s中的函数返回 3.4本章小结 本章介绍了编译的概念和作用，并针对具体的例子hello.s，详细地分析了编译器如何处理C语言的各种数据以及各类操作。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编的过程将编译生成的ASCII汇编语言文件hello.s翻译成一个可重定位目标文件hello.o。可重定位目标文件包含指令对应的二进制机器语言，这种二进制代码能够被计算机理解并执行。因此汇编是将汇编语言转换成最底层的、机器可理解的机器语言的过程。 4.2在Ubuntu下汇编的命令 汇编的命令：gcc-c-m64-no-pie-fno-PIChello.s-ohello.o 汇编过程如图所示： 图4-1汇编命令 4.3可重定位目标elf格式 使用readelf命令readelf-ahello.o>helloelf.txt查看hello.o的ELF格式，并将结果重定向到helloelf.txt便于查看分析。 图4-2查看hello.oELF格式的命令 4.3.1ELF头 ELF头以一个16字节的目标序列开始，如图中Magic所示，这个序列描述了生成该文件的系统的字的大小和字节顺序。以hello.o为例，这个16字节序列为7f454c46020101000000000000000000，描述了系统的字的大小为8字节，字节顺序为小端序。 ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量。以hello.o为例，ELF头中包含了ELF头的大小：64字节；目标文件的类型：REL（可重定位文件）；机器类型：AdvancedMicroDevicesX86-64；节头部表的文件偏移：1112bytes；节头部表中条目的数量：13. 图4-3hello.o的ELF头 4.3.2节头部表 节头部表描述不同节的位置和大小，目标文件中的每个节都有一个固定大小的节头部表条目。 以hello.s为例，节头部表一共描述了13个不同节的位置、大小等信息。依次为： [1].text节：已编译程序的机器代码，大小为0x7d字节，类型为PROGBITS，偏移量为0x40，标志为AX（表明该节的数据只读并且可执行）。 [2].rela.text节：一个.text节中位置的列表，大小为0xc0字节，类型为RELA，偏移量为0x318，标志为I。 [3].data节：已初始化的全局和静态C变量，大小为0x4字节，类型为PROGBITS，偏移量为0xc0，标志为WA（表明该节的数据可读可写）。 [4].bss节：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。大小为0x0字节，类型为NOBITS，偏移量为0xc4，标志为WA（表明该节的数据可读可写）。 [5].rodata节：只读数据，大小为0x2b字节，类型为PROGBITS，偏移量为0xc4，标志为A（表明该节的数据只读）。 [6].comment节：包含版本控制信息，大小为0x36字节，类型为PROGBITS，偏移量为0xef，标志为MS。 [7].note.GNU_stack节：标记可执行堆栈，大小为0x0字节，类型为PROGBITS，偏移量为0x125。 [8].eh_frame节：处理异常，大小为0x38字节，类型为PROGBITS，偏移量为0x128，标志为A（表明该节的数据只读）。 [9].rela.eh_frame节：.eh_frame节的重定位信息，大小为0x18字节，类型为RELA，偏移量为0x3d8，标志为I。 [10].shstrtab节：包含节区名称，大小为0x61字节，类型为STRTAB，偏移量为0x3f0。 [11].symtab节：一个符号表，存放在程序中定义和引用的函数和全局变量的信息。大小为0x180字节，类型为SYMTAB，偏移量为0x160。 [12].strtab节：一个字符串表，包括.symtab和.debug节中的符号表，以及节头部中的节名字。大小为0x37字节，类型为STRTAB，偏移量为0x2e0。 图4-4hello.o的节头部表 4.4.3符号表 符号表存放程序中定义和引用的函数和全局变量的信息，每个符号表是一个条目的数组，每个条目包括value：距定义目标的节的起始位置的偏移；size：目标的大小；type：指明数据还是函数；bind：表示符号是本地的还是全局的等等。 以hello.s为例，符号表一共描述了16个符号。比如全局变量sleepsecs，Ndx=3表明它在.data节，value=0表明它在.data节中偏移量为0的地方，size=4表明大小为4字节，bind=GLOBAL表明它是全局符号，type=OBJECT：表明它是数据。而对于函数main，Ndx=1表明它在.text节，value=0表明它在.text节中偏移量为0的地方，size=125表明大小为125字节，bind=GLOBAL表明它是全局符号，type=FUNC：表明它是函数。其他的符号如puts、exit、printf、sleep和getchar都是外部的库函数，需要在链接后才能确定。 图4-5hello.o的符号表 4.3.4重定位节 汇编器遇到对最终位置未知的目标引用，会产生一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位信息就放在重定位节.rel.text中，已初始化数据的重定位条目放在.rel.data中。 每个重定位条目包括offset：需要被修改的引用的节偏移；symbol：标识被修改引用应该指向的符号；type：重定位类型，告知链接器如何修改新的引用；attend：一些重定位要使用它对被修改引用的值做偏移调整。ELF定义了32种不同的重定位类型，两种最基本的重定位类型包括R_X86_64_PC32（重定位使用32位PC相对地址的引用）和R_X86_64_32（重定位使用32位绝对地址的引用）。 以hello.s为例，重定位节.rela.text一共描述了8个重定位条目。重定位节.rela.eh_frame描述了1个重定位条目。 图4-6hello.o的重定位节 4.4Hello.o的结果解析 使用命令objdump-d-rhello.o对hello.o进行反汇编，得到结果如图。 图4-7hello.o的反汇编结果 图4-8hello.s 与第3章的hello.s对比可以发现，hello.s中的汇编指令被映射到二进制的机器语言。机器语言完全是二进制代码构成的，机器可以直接根据二进制代码执行对应的操作。不同的汇编指令被映射到不同的二进制功能码，而汇编指令的操作数也被映射成二进制的操作数。因此每一条汇编语言的指令都可以映射到一条机器语言指令，而给出任何一条合法的机器语言指令也可以得知它对应的汇编指令。从汇编语言转换成机器语言的过程中，一些操作数会出现不一致的情况： （1）立即数的变化：hello.s中的立即数都是用10进制数表示的。 但是在机器语言中，由于转换成了二进制代码，因此立即数都是用16进制数表示的。 （2）分支转移的不一致：hello.s中的分支转移（即跳转指令）直接通过像.LC0，.LC1这样的助记符进行跳转，会直接跳转到相应符号声明的位置。 助记符只是帮助程序员理解的，从汇编语言转换成机器语言之后，助记符就不再存在了，因此机器语言中的跳转使用的是确定的地址。下图中的main+0x29就表明要跳转到距main函数偏移量为0x29的位置。 （3）函数调用的不一致：hello.s中的函数调用直接在call指令后面加上要调用的函数名。 但是在机器语言中，call指令后是被调函数的PC相对地址。在这里，由于调用的函数都是库函数，需要在动态链接后才能确定被调函数的确切位置，因此call指令后的二进制码为全0，同时需要在重定位节中添加重定位条目，在链接时确定最终的相对地址。 4.5本章小结 本章介绍了汇编的概念和作用，通过对比hello.s和hello.o分析了汇编的过程，同时分析了可重定位目标文件的ELF格式。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据的片段收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在现代系统中，链接由链接器程序自动执行。链接包括两个主要任务：符号解析和重定位。 链接是十分重要，不可或缺的，在软件开发中扮演着一个关键的角色，因为它使得分离编译成为可能。无需将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块，极大地提高了大型程序编写的效率。 5.2在Ubuntu下链接的命令 链接的命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 链接过程如图所示： 图5-1链接命令 5.3可执行目标文件hello的格式 使用readelf命令readelf-ahello>helloldelf.txt查看可执行目标文件hello的ELF格式，并将结果重定向到helloldelf.txt便于查看分析。 图5-2查看helloELF格式的命令 5.3.1ELF头 ELF头以一个16字节的目标序列开始，如图中Magic所示，这个序列描述了生成该文件的系统的字的大小和字节顺序。以hello为例，这个16字节序列为7f454c46020101000000000000000000，描述了系统的字的大小为8字节，字节顺序为小端序。 ELF头剩下的部分包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量。以hello为例，ELF头中包含了ELF头的大小：64字节；目标文件的类型：EXEC（可执行文件）；机器类型：AdvancedMicroDevicesX86-64；节头部表的文件偏移：4032bytes；节头部表中条目的数量：25。同时，ELF头中还包括程序的入口点（偏移量64字节），即程序运行时要执行的第一条指令的地址。 图5-3hello的ELF头 5.3.2节头部表 节头部表描述不同节的位置和大小，目标文件中的每个节都有一个固定大小的节头部表条目。 与hello.o相比，hello的节头部表一共描述了25个不同节的位置、大小等信息，比hello.o多出12个节。各节的起始地址由偏移量给出，同时也给出了大小等信息。 图5-4hello的节头部表 5.3.3程序头部表 程序头部表描述了可执行文件的连续的片映射到连续的内存段的映射关系。包括目标文件的偏移、段的读写/执行权限、内存的开始地址、对齐要求、段的大小、内存中的段大小等。 以hello中的第一个LOAD为例，Offset说明段的偏移量为0；VirtAddr说明映射到的虚拟内存段的开始地址是0x400000；FileSiz说明段的大小为0x720字节；Memsiz说明内存中的段大小也是0x720字节；Flags为RE，标志段的权限为只读且可执行；Align说明段的对齐要求为200000。 图5-5hello的程序头部表 5.3.4符号表 符号表存放程序中定义和引用的函数和全局变量的信息，每个符号表是一个条目的数组，每个条目包括value：距定义目标的节的起始位置的偏移；size：目标的大小；type：指明数据还是函数；bind：表示符号是本地的还是全局的等等。 hello的符号表一共描述了48符号，比hello.o多出32个符号。多出的符号都是链接后产生的库中的函数以及一些必要的启动函数。 图5-6hello的符号表 hello中还多出了一个动态符号表，表中的符号都是共享库中的函数，需要动态链接。 图5-7hello的动态符号表 5.3.5重定位节 重定位条目包括offset：需要被修改的引用的节偏移；symbol：标识被修改引用应该指向的符号；type：重定位类型，告知链接器如何修改新的引用；attend：一些重定位要使用它对被修改引用的值做偏移调整。ELF定义了32种不同的重定位类型，两种最基本的重定位类型包括R_X86_64_PC32（重定位使用32位PC相对地址的引用）和R_X86_64_32（重定位使用32位绝对地址的引用）。 在hello中，原来的.rela.text节已经没有了，说明链接的过程已经完成了对.rela.text的重定位操作。Hello中出现了6个新的重定位条目。这些重定位条目都和共享库中的函数有关，因为此时还没有进行动态链接，共享库中函数的确切地址仍是未知的，因此仍然需要重定位节，在动态链接后才能确定地址。 图5-8hello的重定位节 5.4hello的虚拟地址空间 使用edb加载hello，可以看到进程的虚拟地址空间各段信息。可以看出，段的虚拟空间从0x400000开始，到0x400ff0结束。 图5-9edb查看hello的虚拟地址空间 由5.3中的节头部表可以获得各个节的偏移量信息，从而得知各节在虚拟地址空间中的地址。 例如，对于.interp节，节头部表中给出了它的偏移量为0x1c8，大小为0x1c字节。 因此它的虚拟地址空间就从0x4001c8开始，在edb中查看该虚拟内存地址，可以看出，.interp节确实在这个位置。 图5-10edb查看.interp的虚拟地址 类似地，对于.rodata节，节头部表中给出了它的偏移量为0x600，大小为0x2f字节。 因此它的虚拟地址空间就从0x400600开始，在edb中查看该虚拟内存地址，可以看出，.rodata节确实在这个位置，程序中的两个字符串常量就存储在这里。 图5-11edb查看.rodata的虚拟地址 对于.data节，节头部表中给出了它的偏移量为0x900，大小为0x8字节。 因此它的虚拟地址空间就从0x400900开始，在edb中查看该虚拟内存地址，可以看出，.data节确实在这个位置，程序中的全局变量sleepsecs就存储在这里，并且值为2。 图5-12edb查看.data的虚拟地址 对于.text节，节头部表中给出了它的偏移量为0x4d0，大小为0x122字节。 因此它的虚拟地址空间就从0x4004d0开始，在edb中查看该虚拟内存地址，可以看出，.text节确实在这个位置，第一条指令的二进制机器码的第一个字节为0x31。 图5-13edb查看.text的虚拟地址 对于其他的节同理，不再赘述。 5.5链接的重定位过程分析 使用命令objdump-d-rhello>hellold.txt对hello进行反汇编，并将结果重定向到hellold.txt中便于查看分析。hello与hello.o的不同之处在于以下几个方面： （1）hello中的汇编代码已经使用虚拟内存地址来标记了，从0x400000开始；而hello.o中的汇编代码是从0开始的，还没有涉及到虚拟内存地址。 （2）在hello.o中，只存在main函数的汇编指令；而在hello中，由于链接过程中发生重定位，引入了其他库的各种数据和函数，以及一些必需的启动/终止函数，因此hello中除了main函数的汇编指令外，还包括大量其他的指令。 （3）main函数中涉及重定位的指令的二进制代码被修改。在之前汇编的过程中，汇编器遇到对最终位置未知的目标引用，会产生一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。因此在链接的过程中，链接器会根据重定位条目以及已知的最终位置对修改指令的二进制码，这个过程就是重定位的过程。下面以hello.o为例，说明hello如何进行重定位。 查看hello.o中的重定位条目，重定位条目给出了需要被修改的引用的节偏移、重定位类型、偏移调整等信息。 图5-14hello.o的重定位节 这里涉及到两种不同的重定位类型，分别是R_X86_64_PC32（重定位使用32位PC相对地址的引用）和R_X86_64_32（重定位使用32位绝对地址的引用）。对于第一种重定位类型，以第一个条目为例，第一个条目的信息说明需要重定位的位置在.text中偏移量为0x1b的地方。在hello.o中找到相应的位置： 图5-15条目1的重定位位置 这条指令的目的是将某一个数传送到%edi中，使其作为printf的参数。由源程序可知，这个指令对应与语句为printf("Usage:Hello学号姓名！\n");因此参数应该是字符串常量"Usage:Hello学号姓名！\n"的地址。由于字符串常量的最终位置未知，因此产生了一个重定位条目。而重定位的目的就是修改这个数据，使得传入%edi的是"Usage:Hello学号姓名！\n"的最终地址。同时，重定位类型为R_X86_64_32，因此地址为绝对地址。由5.4可知，该字符串常量的地址为0x400604，因此重定位会将这条指令的最后四个字节改为04064000（小端形式的地址）。查看hello的反汇编结果，确实是这样的。 图5-16条目1的重定位结果 对于第二种重定位类型，以第二个条目为例，第二个条目的信息说明需要重定位的位置在.text中偏移量为0x1b的地方。在hello.o中找到相应的位置： 图5-17条目2的重定位位置 这条指令的目的是调用函数puts。由于函数puts的最终位置未知，因此产生了一个重定位条目。而重定位的目的就是修改这个数据，使得call指令的地址为puts函数的起始地址。同时，重定位类型为R_X86_64_PC32，因此地址为相对地址。从hello的反汇编结果可以获得puts函数的地址为0x400460。 图5-18puts函数的位置 而这条call指令的地址为0x400514，它的下一条指令的地址为0x400519. 图5-19call指令的位置 因此相对地址为0x400460–0x400519=0xffffff47。因此重定位会将这条指令的最后四个字节改为47ffffff（小端形式的地址）。查看hello的反汇编结果，确实是这样的。 图5-20条目2的重定位结果 5.6hello的执行流程 从加载hello到_start，到callmain，以及程序终止的所有过程中调用的子程序名以及程序地址（调用顺序为从上到下）： 名称地址ld-2.23.so!_dl_start0x7f7c8a4619b0ld-2.23.so!dl_init0x7f7c8a470780hello!_start0x4004d0hello!__libc_start_main0x400480libc-2.23.so!__libc_start_main0x7f7c8a0b6750libc-2.23.so!cxa_atexit0x7f7c8a0d0290hello!__libc_csu_init0x400580hello!_init0x400430libc-2.23.so!_setjmp0x7f7c8a0cb260libc-2.23.so!_sigsetjmp0x7f7c8a0cb1c0hello!main0x4004fahello!puts@plt0x400460hello!exit@plt0x4004a0hello!printf@plt0x400470hello!sleep@plt0x4004b0hello!getchar@plt0x400490ld-2.23.so!_dl_runtime_resolve_avx0x7f7c8a477870libc-2.23.so!exit0x7f4ea0c8d5b0 5.7Hello的动态链接分析 当程序调用一个由共享库定义的函数时，编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。但这需要链接器修改调用模块的代码段，GNU编译系统使用一种称为延迟绑定的技术将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定是通过两个数据结构之间的交互来实现的，分别是GOT和PLT，GOT是数据段的一部分，而PLT是代码段的一部分。PLT与GOT的协作可以在运行时解析函数的地址，实现函数的动态链接。 过程链接表PLT是一个数组，每个条目是16字节代码。PLT[0]是一个特殊条目，跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。由5.3.2中的节头部表知，存储PLT的.plt节的开始地址为0x400450. 在hello的反汇编结果中可以查看到每个PLT条目。PLT[0]是一个特殊条目，跳转到动态链接器中。接下来每个条目对应一个调用的库函数，例如PLT[1]对应的是puts函数；PLT[2]对应的是printf函数…… 图5-21hello的PLT条目 全局偏移量表GOT是一个数组，每个条目为8字节地址，和PLT联合使用。GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息，GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。由5.3.2中的节头部表知，存储GOT的.got.plt节的开始地址为0x6008b8. 在edb中查看初始时的GOT条目（如图5-22）。除了PLT[0]外，每个PLT对应的GOT条目初始时都指向这个PLT的第二条指令。例如：如图5-21，PLT[1]对应地址0x6008d0处的GOT[3]，而0x6008d0处的值为0x400466，恰好指向PLT[1]的第二条指令。在函数第一次被调用时，动态链接器会修改相应的GOT条目。 图5-22hello的初始GOT条目 同时也可以看到，GOT[1]和GOT[2]这两个条目初始时均为0。而GOT[1]应该包含动态链接器在解析函数地址时会使用的信息，GOT[2]应该为动态链接器在1d-linux.so模块中的入口点。使用edb调试，当dl_start函数返回后，发现这两个条目被修改为正确的值。 图5-23dl_start后的GOT条目 在函数第一次被调用时，动态链接器会修改相应的GOT条目。以puts函数为例，puts函数对应的是PLT[1]，PLT[1]对应地址0x6008d0处的GOT[3]，而GOT[3]的初始值为0x400466，指向PLT[1]的第二条指令。当第一次调用puts时，动态链接器确定puts的运行时位置，用这个地址重写GOT[3]。这时，puts函数才真正完成动态链接，后续对puts的调用就可以直接根据GOT[3]的值进行跳转。 图5-24第一次调用puts后的GOT条目 5.8本章小结 本章介绍了链接的概念与作用，简要分析了可执行文件的ELF格式，hello的虚拟地址空间和执行流程，同时详细地分析了静态链接的重定位过程以及动态链接的过程。至此，一个完美的生命 hello诞生了。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。通过进程的概念提供给我们一个假象，就好像我们的程序是系统中运行的唯一的程序；程序好像独占地使用处理器和内存；处理器好像是无间断地一条接一条地执行程序中的指令；程序的代码和数据好像是系统内存中唯一的对象。 其中上下文是由程序正确运行所需的状态组成的，包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。 6.2简述壳Shell-bash的作用与处理流程 shell是指为使用者提供操作界面的软件，是一个交互型应用级程序，它接收用户命令，然后调用相应的应用程序。shell是系统的用户界面，提供了用户与内核进行交互操作的接口。 shell的作用：shell最重要的功能是命令解释，可以说shell是一个命令解释器。Linux系统上的所有可执行文件都可以作为shell命令来执行，同时它也提供一些内置命令。此外，shell还包括通配符、命令补全、命令历史、重定向、管道、命令替换等很多功能。 shell的处理流程：从终端读入输入的命令行->解析输入的命令行，获得命令行指定的参数->检查命令是否是内置命令，如果是内置命令则立即执行，否则在搜索路径里寻找相应的程序，找到该程序就执行它。 6.3Hello的fork进程创建过程 当在shell中输入命令“./hello1190200817刘小川”时，shell解析输入的命令行，获得命令行指定的参数。由于./hello不是shell内置的命令，因此shell将hello看作一个可执行目标文件，在相应路径里寻找hello程序，找到该程序就执行它。shell会通过调用fork()函数创建一个子进程，新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同但独立的一个副本，包括代码段、数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，子进程可以读写父进程中打开的任何文件。父进程和子进程之间最大的区别在于它们的PID不同。hello程序之后就会运行在这个新创建的子进程的上下文中。 6.4Hello的execve过程 shell创建一个子进程之后，这个子进程仍然是父进程的一个副本，因此需要在子进程中调用exceve()函数在当前进程的上下文中加载并运行我们需要的hello程序。execve函数加载并运行可执行文件filename，且带参数列表argv和环境变量envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。 execve函数用hello程序有效替代当前程序，需要以下几个步骤： （1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 （2）映射私有区域。为新程序（即hello）的代码、数据、bss和栈区域等创建新的区域结构。所有这些区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。 （3）映射共享区域。如果hello程序与共享对象（或目标）链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 （4）设置程序计数器。最后设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 当内核调度这个进程时，它就将从这个入口点开始执行。Linux根据需要换入代码和数据页面。 6.5Hello的进程执行 当子进程调用exceve()函数在上下文中加载并运行hello程序后，hello程序不会立即运行，需要内核调度它。进程调度是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，使用一种称为上下文切换的机制来将控制转移到新的进程。上下文切换包括：保存当前进程的上下文；恢复某个先前被抢占的进程被保存的上下文；将控制传递给这个新恢复的进程。其中上下文指的是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构（页表、进程表、文件表等）。 处理器提供了一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。通常用某个控制寄存器的一个模式位来提供这种机制，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程运行在内核模式中，进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置；没有设置模式位时，进程运行在用户模式中，进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据，否则会导致保护故障。运行应用程序代码的进程初始时在用户模式中，进程需要通过中断、故障或者陷入系统调用这样的异常才能从用户模式变为内核模式。 由于负责进程调度的是内核，因此内核调度需要运行在内核模式下。当内核代表用户执行系统调用时，可能会发生上下文切换，中断也可能引发上下文切换。同时，系统通过某种产生周期性定时器中断的机制判断当前进程已经运行了足够长的时间，并切换到一个新的进程。 以hello的进程执行为例。当子进程调用exceve()函数在上下文中加载并运行hello程序后，hello进程等待内核调度它。当内核决定调度hello进程时，它就抢占当前进程，进行上下文切换，将控制转移到hello进程，并从内核模式变为用户模式，这时hello进程开始运行应用程序代码。当hello进程调用sleep时，由于sleep是系统调用，进程陷入内核模式。这时hello进程被挂起，内核会选择调度其他进程，通过上下文切换保存hello进程的上下文，将控制传递给新调度的进程。定时器的时间到了后会发送中断信号，进入内核模式，将挂起的hello进程变成运行状态，这时hello进程就可以等待内核调度它。当内核再次调度hello进程时，恢复保存的hello进程的上下文，就可以从刚才停止的地方继续执行了。当hello调用getchar的时候同样会陷入内核模式，由于getchar需要来自键盘的DMA传输，时间很长，因此内核不会等待DMA完成，而是去调度其他进程。当DMA完成后，会向处理器发送中断信号，进入内核模式，内核知道DMA完成了，就可以再次调度hello进程了。 6.6hello的异常与信号处理 6.6.1可能出现的异常及处理方法 hello执行过程中，四类异常都可能会出现，四类异常分别为： 类别原因异步/同步返回行为中断来自I/O设备的信号异步总是返回到下一条指令陷阱有意的异常同步总是返回到下一条指令故障潜在可恢复的错误同步可能返回到当前指令终止不可恢复的错误同步不会返回 hello执行过程中发生中断：如果其他进程使用了外部I/O设备，那么在hello进程运行时可能会出现外部I/O设备引起的中断。中断的处理：将控制传递给适当的中断处理程序，处理程序返回时，就将控制返回给下一条指令，程序继续执行，好像没有发生过中断一样。 hello执行过程中发生陷阱：hello中调用了系统调用sleep，产生陷阱。陷阱的处理：将控制传递给适当的异常处理程序，处理程序解析参数，调用适当的内核程序。处理程序返回时，将控制返回给下一条指令。 hello执行过程中发生故障：当hello进程刚从入口点开始执行时，会发生缺页故障。hello进程运行的过程中，也可能发生缺页故障。故障的处理：将控制传递给故障处理程序，如果处理程序能够修正这个错误情况，就将控制返回到引起故障的指令并重新执行它；否则终止引起故障的应用程序。 hello执行过程中发生错误：hello执行过程中，DRAM或者SRAM可能发生位损坏，产生奇偶错误。发生错误时会将控制传递给终止处理程序，终止引起错误的应用程序。 6.6.2可能产生的信号及处理方法 hello执行过程中，可能产生的信号如：SIGINT，SIGTSTP，SIGCHLD，SIGKILL，SIGALRM等等。进程接受到信号时，会触发控制传递到信号处理程序，信号处理程序运行，信号处理程序返回后，将控制返回给被中断的程序。每个信号类型有相关联的默认行为，使用signal函数可以修改和信号相关联的行为。 下面以hello的运行过程为例，简要说明异常与信号的处理。 （1）程序运行过程中不停乱按键盘，包括回车。如果乱按不包括回车，输入的字符串会缓存到缓冲区；如果输入的最后是回车，则getchar会读进回车，把回车前的字符串作为输入shell的命令， 图6-1程序运行过程中不停乱按键盘，包括回车 （2）程序运行过程中键入Ctrl-Z。键入Ctrl-Z会发送SIGTSTP信号给前台进程组的每个进程，结果是停止前台作业，也就是停止hello进程。 图6-2键入Ctrl-Z 使用jobs命令可以查看当前的作业，可以看出当前的作业是hello进程，且状态是已停止 图6-3jobs命令 使用ps命令可以查看当前所有进程以及它们的PID，进程包括bash，hello以及ps。 图6-4ps命令 使用pstree命令将所有进程以树状图形式显示。 图6-5pstree命令 使用fg命令可以使停止的hello进程继续在前台运行。也可以再次键入Ctrl-Z停止hello的运行。 图6-6fg命令 使用kill命令可以给指定进程发送信号。比如kill-98329是指向PID为8329的进程（即hello）发送SIGKILL信号。这个命令会杀死hello进程，当再次使用ps时可以发现hello进程已经被杀死，使用jobs指令也看不到当前的作业了。 图6-7kill命令 （3）程序运行过程中键入Ctrl-C。键入Ctrl-C会发送SIGINT信号给前台进程组的每个进程，结果是终止前台进程，即终止hello进程。 图6-8键入Ctrl-C 使用ps命令可以发现，hello进程已经终止并被回收，不再存在了。使用jobs指令也看不到当前的作业了。 图6-9ps,jobs命令 6.7本章小结 本章介绍了进程的概念和作用，简述shell的工作过程，并分析了使用fork+execve加载运行hello，执行hello进程以及hello进程运行时的异常/信号处理过程。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：逻辑地址是指由程序产生的与段相关的偏移地址部分。例如，在进行C语言指针编程中，可以使用&操作读取指针变量的值，这个值就是逻辑地址，是相对于当前进程数据段的地址。一个逻辑地址由两部份组成：段标识符和段内偏移量。 线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址生成了一个线性地址。如果启用了页式管理，那么线性地址可以再变换产生物理地址。若没有启用页式管理，那么线性地址直接就是物理地址。 虚拟地址：因为虚拟内存空间的概念与逻辑地址类似，因此虚拟地址和逻辑地址实际上是一样的，都与实际物理内存容量无关。 物理地址：存储器中的每一个字节单元都给以一个唯一的存储器地址，用来正确地存放或取得信息，这个存储器地址称为物理地址，又叫实际地址或绝对地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址由段标识符和段内偏移量两部分组成。段标识符由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号，是对段描述符表的索引，每个段描述符由8个字节组成，具体描述了一个段。后3位包含一些硬件细节，表示具体是代码段寄存器还是栈段寄存器还是数据段寄存器等。通过段标识符的前13位，可以直接在段描述符表中索引到具体的段描述符。每个段描述符中包含一个Base字段，它描述了一个段的开始位置的线性地址。将Base字段和逻辑地址中的段内偏移量连接起来就得到转换后的线性地址。 对于全局的段描述符，放在全局段描述符表中，局部的（每个进程自己的）段描述符，放在局部段描述符表中。全局段描述符表的地址和大小存放在gdtr控制寄存器中，而局部段描述符表存放在ldtr寄存器中。 给定逻辑地址，看段选择符的最后一位是0还是1，用于判断选择全局段描述符表还是局部段描述符表。再根据相应寄存器，得到其地址和大小。通过段标识符的前13位，可以在相应段描述符表中索引到具体的段描述符，得到Base字段，和段内偏移量连接起来最终得到转换后的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 页表是一个页表条目（PTE）的数组，虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。每个PTE由一个有效位和一个n位地址字段组成，有效位表明该虚拟页是否被缓存在DRAM中。如果设置了有效位，那么地址字段表示相应的物理页的起始位置；如果没有设置有效位，那么空地址表示虚拟页还未被分配，否则这个地址指向该虚拟页在磁盘的起始位置。 MMU利用页表实现从虚拟地址到物理地址的变换。CPU中的一个控制寄存器，页表基址寄存器指向当前页表。n位的虚拟地址包含一个p位的虚拟页面偏移VPO和一个n-p位的虚拟页号VPN。MMU利用VPN选择适当的PTE，如果这个PTE设置了有效位，则页命中，将页表条目中的物理页号和虚拟地址中的VPO连接起来就得到相应的物理地址。否则会触发缺页异常，控制传递给内核中的缺页异常处理程序。缺页处理程序确定物理内存中的牺牲页，调入新的页面，并更新内存中相应PTE。处理程序返回到原来的进程，再次执行导致缺页的指令，MMU重新进行地址翻译，此时和页命中的情况一样。同时，也可以利用TLB缓存PTE加速地址的翻译。 图7-1线性地址到物理地址的变换 7.4TLB与四级页表支持下的VA到PA的变换 TLB的支持：在MMU中包括一个关于PTE的缓存，称为翻译后备缓冲器（TLB）。TLB是一个小的、虚拟寻址的缓存，每一行保存着一个由单个PTE组成的块。由于VA到PA的转换过程中，需要使用VPN确定相应的页表条目，因此TLB需要通过VPN来寻找PTE。和其他缓存一样，需要进行组索引和行匹配。如果TLB有2t个组，那么TLB的索引TLBI由VPN的t个最低位组成，TLB标记TLBT由VPN中剩余的位组成。 图7-2TLB 当MMU进行地址翻译时，会先将VPN传给TLB，看TLB中是否已经缓存了需要的PTE，如果TLB命中，可以直接从TLB中获取PTE，将PTE中的物理页号和虚拟地址中的VPO连接起来就得到相应的物理地址。这时所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。如果TLB不命中，那和7.3中描述的过程类似，需要从cache或者内存中取出相应的PTE。 图7-3TLB支持下的线性地址到物理地址的变换 四级页表的支持：多级页表可以用来压缩页表，对于k级页表层次结构，虚拟地址的VPN被分为k个，每个VPNi是一个到第i级页表的索引。当1≤j≤k-1时，第j级页表中的每个PTE指向某个第j+1级页表的基址。第k级页表中的每个PTE和未使用多级页表时一样，包含某个物理页面的PPN或者一个磁盘块的地址。对于IntelCorei7，使用了4级页表，每个VPNi有9位。当TLB未命中时，36位的VPN被分为VPN1、VPN2、VPN3、VPN4，每个VPNi被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址，VPN1提供到一个L1PTE的偏移量，这个PTE包含某个L2页表的基址。VPN2提供到这个L2页表中某个PTE的偏移量，以此类推。最后得到的L4PTE包含了需要的物理页号，和虚拟地址中的VPO连接起来就得到相应的物理地址。 图7-4四级页表支持下的线性地址到物理地址的变换 7.5三级Cache支持下的物理内存访问 当MMU完成了从虚拟地址到物理地址的转换后，就可以使用物理地址进行内存访问了。IntelCorei7使用了三级cache来加速物理内存访问，L1级cache作为L2级cache的缓存，L2级cache作为L3级cache的缓存，而L3级cache作为内存（DRAM）的缓存。 进行物理内存访问时，会首先将物理地址发送给L1级cache，看L1级cache中是否缓存了需要的数据。L1级cache共64组，每组8行，块大小64B。因此将物理地址分为三部分，块偏移6位，组索引6位，剩下的为标记位40位。首先利用组索引位找到相应的组；然后在组中进行行匹配，对于组中的8个行，分别查看有效位并将行的标记位与物理地址的标记位匹配，当标记位匹配且有效位是1时，缓存命中，根据块偏移位可以直接将cache中缓存的数据传送给CPU。如果缓存不命中，需要继续从存储层次结构中的下一层中取出被请求的块，将新块存储在相应组的某个行中，可能会替换某个缓存行。 L1级cache不命中时，会继续向L2级cache发送数据请求。和L1级cache的过程一样，需要进行组索引、行匹配和字选择，将数据传送给L1级cache。同样L2级cache不命中时，会继续向L3级cache发送数据请求。最后，L3级cache不命中时，只能从内存中请求数据了。 值得注意的是，三级cache不仅仅支持数据指令的访问，也支持页表条目的访问，在MMU进行虚拟地址到物理地址的翻译过程中，三级cache也会起作用。 图7-5三级Cache下的物理内存访问 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。内核给新进程创建虚拟内存，创建当前进程的mm_struct、区域结构和页表的原样副本，将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，为每个进程保持了私有地址空间的抽象概念。同时延迟私有对象中的副本直到最后可能的时刻，充分利用了稀有的物理内存。 7.7hello进程execve时的内存映射 exceve()函数在当前进程的上下文中加载并运行我们需要的hello程序。execve函数加载并运行可执行文件filename，且带参数列表argv和环境变量envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。 execve函数用hello程序有效替代当前程序，需要以下几个步骤： （1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 （2）映射私有区域。为新程序（即hello）的代码、数据、bss和栈区域等创建新的区域结构。所有这些区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。 （3）映射共享区域。如果hello程序与共享对象（或目标）链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 （4）设置程序计数器。最后设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 当内核调度这个进程时，它就将从这个入口点开始执行。Linux根据需要换入代码和数据页面。 图7-6execve时的内存映射 7.8缺页故障与缺页中断处理 缺页故障的产生：CPU产生一个虚拟地址给MMU，MMU经过一系列步骤获得了相应的PTE，当PTE的有效位未设置时，说明虚拟地址对应的内容还没有缓存在内存中，这时MMU会触发缺页故障。 缺页故障的处理：缺页异常导致控制转移到内核的缺页处理程序。处理程序随后执行以下步骤：（1）判断虚拟地址是否合法。缺页处理程序搜索区域结构的链表，把虚拟地址和每个区域结构中的vm_start和vm_end做比较。如果指令不合法，缺页处理程序会触发一个段错误，从而终止这个进程。（2）判断内存访问是否合法。比如缺页是否由一条试图对只读页面进行写操作的指令造成的。如果访问不合法，缺页处理程序会触发一个保护异常，从而终止这个进程。（3）这时，内核知道缺页是由合法的操作造成的。内核会选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。处理程序返回时，CPU重新执行引起缺页的指令，这条指令将再次发送给MMU。这次，MMU能正常地进行地址翻译，不会再产生缺页中断了。 图7-7缺页中断处理 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间的细节不同，但不失通用性，假设堆是一个请求二进制零的区域，紧接在未初始化数据区域后开始，向上生长。对每个进程，内核维护一个全局变量brk指向堆顶。分配器将堆视为一组不同大小的块的集合来维护。每个块是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留，供应用程序使用；空闲块可用来分配。空闲块保持空闲，直到空闲块显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的（即显式分配器），要么是内存分配器自身隐式执行的（即隐式分配器）。显式分配器和隐式分配器是动态内存分配器的两种基本风格。两种风格都要求应用显式地分配块，不同之处在于由哪个实体来负责释放已分配的块。显式分配器要求应用显式地释放任何已分配的块。隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集。 图7-8动态内存分配的区域 堆 显式分配器必须在一些约束条件下工作：处理任意请求序列；立即响应请求；只使用堆；对齐要求；不修改已分配的块。在这些限制条件下，分配器试图实现吞吐率最大化和内存使用率最大化，但这两个性能目标通常是相互冲突的。 分配器的具体操作过程以及相应策略： （1）放置已分配块：当一个应用请求一个k字节的块时，分配器搜索空闲链表。查找一个足够大可以放置所请求的空闲块。执行这种搜索的常见策略包括首次适配、下一次适配和最佳适配等。 （2）分割空闲块：一旦分配器找到了匹配的空闲块，需要决定分配这个空闲块中多少空间。可以选择用整个块，但会造成额外的内部碎片；也可以选择将空闲块分割为两部分，第一部分变成已分配块，剩下的变成新的空闲块。 （3）获取额外的堆内存：如果分配器不能为请求块找到空闲块，分配器通过调用sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块，将这个块插到空闲链表中，然后被请求的块放在这个新的空闲块中。 （4）合并空闲块：分配器释放一个已分配块时，要合并相邻的空闲块。分配器决定何时执行合并，可以选择立即合并或者推迟合并。合并时需要合并当前块和前面以及后面的空闲块。 组织空闲块的形式有很多，包括隐式空闲链表、显式空闲链表、分离的空闲链表等等。 带边界标签的隐式空闲链表分配器：一个块由一个字的头部、有效载荷、可能的一些额外的填充以及一个脚部。头部位于块的开始，编码了这个块的大小（包括头部、脚部和所有的填充）以及这个块是已分配的还是空闲的。由于对齐要求，头部的高位可以编码块的大小，而剩余的几位（取决于对齐要求）总是零，可以编码其他信息。使用最低位作为已分配位，指明这个块是已分配的还是空闲的。脚部位于每个块的结尾，是头部的一个副本，是为了方便释放块时的合并操作。头部后面就是调用分配器时请求的有效载荷，有效载荷后面是一片不使用的填充块，其大小可以是任意的。填充的原因取决于分配器的策略。如果块的格式是如上所述，就可以将堆组织成一个连续的已分配块和空闲块的序列，这种结构为隐式空闲链表。空闲块通过头部的大小字段隐含地连接，可以通过遍历堆中所有的块间接遍历整个空闲块的集合。同时，需要一个特殊标记的结束块（设置分配位而大小为零的头部），这种设置简化了空闲块合并。 图7-9隐式链表的块结构 显式空间链表：已分配块的块结构和隐式链表的相同，由一个字的头部、有效载荷、可能的一些额外的填充以及一个脚部组成。而在每个空闲块中，增加了一个前驱指针和后继指针。通过这些指针，可以将空闲块组织成一个双向链表。空闲链表中块的排序策略包括后进先出顺序、按照地址顺序维护、按照块的大小顺序维护等。显式空闲链表降低了放置已分配块的时间，但空闲块必须足够大，以包含所需要的指针、头部和脚部，这导致了更大的最小块大小，潜在提高内部碎片程度。 图7-10显式链表的块结构 而malloc采用的是分离的空闲链表。分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小升序排列，当分配器需要一个大小为n的块时，就搜索相应大小类对应的空闲链表。如果不能找到合适的块，就搜索下一个链表，以此例推。 7.10本章小结 本章总结了hello运行过程中有关内存管理的内容。简述了TLB、多级页表支持下的地址翻译、cache支持下的内存访问、缺页的处理、fork+execve过程的内存映射以及动态存储分配的过程。 （第7章2分) 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m个字节的序列： B0,B1,B2……Bm-1 所有的IO设备（例如网络、磁盘和终端）都被模型化为文件，所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，使得所有的输入和输出都能以一种统一且一致的方式来执行。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixIO接口，使得所有的输入和输出都能以一种统一且一致的方式来执行： （1）打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，即描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 （2）Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件中的常量可以代替显式的描述符值。 （3）改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 （4）读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发EOF条件，应用程序能检测到这个条件。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 （5）关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数: （1）进程通过调用open函数打开一个存在的文件或者创建一个新文件。 intopen(char*filename,intflags,mode_tmode); open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件；mode参数指定了新文件的访问权限位。 （2）进程通过调用close函数关闭一个打开的文件。 intclosefd; fd是需要关闭的文件描述符，成功返回0，错误返回-1。关闭一个已关闭的描述符会出错。 （3）应用程序通过分别调用read和write函数来执行输入和输出。 ssize_tread(intfd,void*buf,size_tn); ssize_twirte(intfd,constvoid*buf,size_tn); read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则返回值表示的是实际传送的字节数量。write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 printf的源代码： int printf(const char *fmt,  ) { int i; char buf[256]; va_list arg = (va_list)((char*)(&fmt) + 4); i = vsprintf(buf, fmt, arg); write(buf, i); return i; } printf函数是格式化输出函数,一般用于向标准输出设备按规定格式输出信息。printf中调用了两个函数，分别为vsprintf和write。 vsprintf函数根据格式串fmt，并结合args参数产生格式化之后的字符串结果保存在buf中，并返回结果字符串的长度。 write函数将buf中的i个字符写到终端，由于i保存的是结果字符串的长度，因此write将格式化后的字符串结果写到终端。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar的源代码： int getchar(void) { static char buf[BUFSIZ]; static char* bb=buf; static int n=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsigned char)*bb++:EOF; } getchar函数会从stdin输入流中读入一个字符。调用getchar时，会等待用户输入，输入回车后，输入的字符会存放在缓冲区中。第一次调用getchar时，需要从键盘输入，但如果输入了多个字符，之后的getchar会直接从缓冲区中读取字符。getchar的返回值是读取字符的ASCII码，若出错则返回-1。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章介绍了Linux的IO设备管理方法和UnixIO接口及其函数，并分析了printf和getchar函数的实现。 （第8章1分） 结论 hello所经历的过程： 源程序：在文本编辑器或IDE中编写C语言代码，得到最初的hello.c源程序。 预处理：预处理器解析宏定义、文件包含、条件编译等，生成ASCII码的中间文件hello.i。 编译：编译器将C语言代码翻译成汇编指令，生成一个ASCII汇编语言文件hello.s。 汇编：汇编器将汇编指令翻译成机器语言，并生成重定位信息，生成可重定位目标文件hello.o。 链接：链接器进行符号解析、重定位、动态链接等创建一个可执行目标文件hello。此时，hello才真正地可以被执行。 fork创建进程：在shell中运行hello程序时，shell会调用fork函数创建子进程，供之后hello程序的运行。 execve加载程序：子进程中调用execve函数，加载hello程序，进入hello的程序入口点，hello终于要开始运行了。 运行阶段：内核负责调度进程，并对可能产生的异常及信号进行处理。MMU、TLB、多级页表、cache、DRAM内存、动态内存分配器相互协作，共同完成内存的管理。UnixI/O使得程序与文件进行交互。 终止：hello进程运行结束，shell负责回收终止的hello进程，内核删除为hello进程创建的所有数据结构。hello的一生到此结束，没有留下一丝痕迹。 对计算机系统的设计与实现的深切感悟： hello从诞生到结束，经历了千辛万苦，在硬件、操作系统、软件的相互协作配合下，终于完美地完成了它的使命。这让我认识到，一个复杂的系统需要多方面的协作配合才能更好地实现功能。同时，计算机系统提供的一系列抽象使得实际应用与具体实现相互分离，可以很好地隐藏实现的复杂性，降低了程序员的负担，使得程序更加容易地编写、分析、运行。这让我认识到抽象是十分重要的，是计算机科学中最为重要的概念之一。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.i：C预处理器产生的一个ASCII码的中间文件，用于分析预处理过程。 hello.s：C编译器产生的一个ASCII汇编语言文件，用于分析编译的过程。 hello.o：汇编器产生的可重定位目标程序，用于分析汇编的过程。 hello：链接器产生的可执行目标文件，用于分析链接的过程。 hello.txt：hello.o的反汇编文件，用于分析可重定位目标文件hello.o。 hellold.txt：hello的反汇编文件，用于分析可执行目标文件hello。 helloelf.txt：hello.o的ELF格式，用于分析可重定位目标文件hello.o。 helloldelf.txt：hello的ELF格式，用于分析可执行目标文件hello。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] RANDALE.BRYANT,DAVIDR.O‘HALLARON.深入理解计算机系统[M].机械工业出版社,2011. [2] https://www.cnblogs.com/clover-toeic/p/3851102.html [3] https://www.runoob.com/linux/linux-comm-pstree.html [4] https://www.runoob.com/cprogramming/c-function-vsprintf.html [5] https://www.cnblogs.com/pianist/p/3315801.html （参考文献0分，缺失-1分） 

HIT计算机系统大作业-Hello‘sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 班 级 学 生 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文阐述了一个简单的入门程序“hello”在Linux系统下的全寿命周期所经历的全部阶段，从一个文本文件经过预处理，编译，汇编，链接生成了可执行文件的全过程。然后对hello文件在shell下的进程管理，系统下存储管理和I/管理。通过对hello这位老前辈一生的探索，加深了我们对计算机系统的理解。 关键词：Hello；预处理；编译；汇编；链接；进程；存储；虚拟内存；I/O； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1 预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 Hello’sP2P:FromProgramtoProcess,含义就是从用高级语言写出一个.c文件开始，在经过预处理器（cpp）的预处理生产hello.i（修改了的源程序），在经过编译器（cc1）的编译生成hello.c文件，然后通过汇编器（as），生成可重定位的目标文件（二进制）然后与预编译的库函数通过链接器（ld）进行链接，生成可执行文件hello。在shell中启动该程序操作系统会为其fork产生子进程，再调用execve函数加载进程。自此，hello的P2P结束。 Hello’s020:Fromzerotozero,操作系统调用execve函数后会映射到虚拟内存中，删除当前的虚拟地址中的数据并为hello创建新的区域，从程序入口进入物理存储地址，然后再执行hello程序中的main函数。代码完成后，父进程回收hello进程，内核删除其相关的数据结构。 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位 开发与调试工具：gcc，vim，Codeblocks，edb，readelf，HexEdit 1.3中间结果 1.4本章小结 本章主要介绍了Hello程序一生经历的两个过程P2P和020，同时给出了实验时的软硬件开发环境和本次大作业中所涉及到的中间文件它们的名称和其含义。很简略的介绍。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 预处理的概念：预处理器根据以字符“#”开头的命令，包括宏命令和条件编译，来修改最原始的c程序将所有引用的库展开后合并成一个完整的文本文件。 预处理阶段作用： 使用预处理功能便于程序的修改，阅读，移植和调试，也便于实现程序模块化设计。文件包含是预处理的一个重要功能。可以用来把多个源文件连接成一个源文件进行编译，结果生成一个目标文件。条件编译也是预处理阶段的一个重要作用。允许只编译满足条件的程序段，使生成的目标程序变短，从而减少了内存的开销，提高了程序效率。处理宏定义也是重要作用之一。预处理把程序所有的宏定义语句进行替换，例如#definePI3.14语句，在预处理过程中把程序里所有的PI进行替换。 2.2在Ubuntu下预处理的命令 命令：gcchello.c-E-ohello.i 图2.1Ubuntu下的hello程序预处理命令 2.3Hello的预处理结果解析 图2.2预处理后的hello.i文件（节选） 进行了预处理操作以后，我们发现一个只有十几行的hello.c文件被展开成立几千行的文本文件，然后阅读hello.i文件发现，增加的行数其实是对hello.c文件头文件的展开，还对一些宏定义的#define命令进行了相应符号的替换。 2.4本章小结 本章概括性的介绍了预处理阶段的作用和概念，同时给出了在ubuntu下的c语言预处理命令，并分析了预处理后生成的hello.i文本文件。hello的受精卵时期已经结束了。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的概念：编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含main函数的定义，将定义中的每条语句都以一种文本格式描述了一条机器语言指令。 编译的作用：基本功能是把源程序翻译成目标程序作为输出。编译的功能不只有基本功能。在编译阶段，对程序的编译还具有语法检查，调试措施，覆盖处理，目标程序优化等其它的重要功能。 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令 命令：gcc-Shello.i-ohello.s 图3.1Ubuntu下的编译指令 3.3Hello的编译结果解析 3.3.1汇编指令的介绍 图3.2hello.s中的相关汇编指令 .file:声明源文件.text：代码节.section:（定义内存段）.rodata:只读代码段.align：数据或者指令的地址对其方式.string：声明一个字符串.global：声明全局变量.type:声明一个符号是数据类型还是函数类型 3.3.2数据类型 1.局部变量：main函数声明了一个局部变量，编译时编译器会把局部变量放入堆栈中。如图3.3所示。 图3.3 字符串：程序中有两个字符串，从.s文件中的.string中可以看出（.LC0,.LC1） 图3.4 立即数:从汇编代码中可以直接看出来，形如“$0”这种表示风格的就是立即数。数组：hello.c中唯一涉及到的数组就是main函数传入的参char*argv[]；数组的每一个元素都是一个指向字符类型的指针。数组的起始地点是栈帧减去32的位置，然后被两次调用argv[0]和argv[1]传入printf函数中。如图3.5所示。 图3.5 全局函数：main函数。由hello.c可知，hello.c声明了一个全局函数intmain(intargc,char*argv[])，经过编译之后，main函数中使用的字符串常量也被存放在数据区。由下图可以看出。 图3.6 全局变量：由hello.c可知，hello.c声明了一个全局变量sleepsecs。经过编译以后，初始化了的全局变量sleepsecs处在数据段。可由图3.7看出。 图3.7 指针：hello.c中main函数的第二个参数char*argv[]，就是指针字符数组在。这里可以看出指针与数组紧密相连。但因为数组那介绍过了，所以这里不在赘述。结构：hello.c中未涉及到结构体这样数据类型，所以也不进行详述；但给出简单的定义：可以将不同类型的对象聚集到一个对象中，用名字来引用各个部分。 3.3.3各类操作 1.赋值操作：程序中的赋值操作主要有：i=0这条赋值操作在汇编代码主要使用mov指令来实现，而根据数据的类型又有好几种不一样的后缀b:一个字节w：两个字节l：四个字节q：八个字节 算数操作：hello.c中的算数操作由i++，因为i是int类型的，所以只需要add指令就可以实现。 下面给出各种算数运算的汇编指令： （1）加：x=x+y汇编语言是：addqy，x （2）减：x=x-y汇编语言是：subqy，x （3）乘：x=x*y汇编语言是：imulq：y，x （4）除：z=x/y汇编语言是:：movqx,z cqto idivqy 复合语句就是上面的组合，或者也有复合的汇编语句：z=x+Ay+B（A，B都是立即数）的汇编语言是leaqB(x，y，A)z 关系操作： hello.c中出现了if（argc！=3）的！=的关系操作符号，这条指令被编译为：cmpl$3,-20(%rbp)，同时这条cmpl的指令还有设置条件码的作用，当根据条件码来判断是否需要跳转到分支中。hello.c中还出现了i<10的关系判断符号，在汇编代码中被翻译为cmpl$9,-4(%rbp),同时设置条件码，来判断是否满足跳出循环的条件。 控制转移指令：汇编语言中通过上一步关系判断设置条件码，来进行下一步的转移跳转的指令。 图3.8hello.s中的两条转移跳转指令 有上一小节的关系操作中，我们了解到通过判断设置的条件码，可以判断是否执行跳转命令。相关跳转命令如下图： 图3.9一些汇编跳转指令 函数操作： 传递参数：是在程序运行过程中，实际参数就会将参数值传递给相应的形式参数，然后在函数中实现对数据处理和返回的过程，方法有按值传递参数，按地址传递参数和按数组传递参数函数调用：计算机编译或运行时，使用某个函数来完成相关命令。对无参函数调用时则无实际参数表。实际参数表中的参数可以是常数、变量或其它构造类型数据及表达式。各实参之间用逗号分隔。分配空间和释放内存：在开始时，函数要为局部变量分配空间，而在返回前，要释放这些空间。函数返回：返回一个结果或者void类型函数无返回值。 在hello.c中，涉及到的函数操作有： main函数调用printf，exit，sleep，getchar函数main函数的参数是argc和argv；printf函数的参数也是argc和argv；exit的参数是1；sleep的参数是全局变量sleepsecs。函数的返回值存在寄存器%rax（%eax)中。 图3.10hello.c函数中一些函数操作 6.类型转换：hello.c中并未涉及到相关类型转换操作。但根据实验二我们知道类型转换可以强制类型转换，例如inta=(int)c;或者调用相关类型转化函数，例如atoi等。未涉及到就不进行详细的展开介绍了。 3.4本章小结 本章主要讲述了编译阶段中编译器如何处理各种数据和操作，以及c语言中各种类型和操作所对应的的汇编代码。通过理解了这些编译器编译的机制，我们可以很容易的将汇编语言翻译成c语言。从此，hello已经进入了胚胎阶段。 （以下格式自行编排，编辑时删除） （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编的概念：汇编器（as）将.s文件翻译成机器语言指令，并把这些指令打包成一种叫可重定位目标程序的格式，并将结果保存在.o文件中。 汇编阶段的作用：将编译生成的汇编代码在汇编阶段生成机器可理解的，由0，1组成的二进制机器代码指令。 4.2在Ubuntu下汇编的命令 命令：gcchello.s-c-ohello.o 图4.1Ubuntu下的汇编阶段指令 4.3可重定位目标elf格式 1.ELFHEADER：在Ubuntu下用命令readelf-hhello.o查看其ELF头部表结构； 图4.2hello.o的ELF头 ELF头：从16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量等信息。 SectionHeader：在Ubuntu下用命令readelf-Shello.o查看其节头部表结构： 图4.3hello.o的节头部表 SectionHeader：节头部表，包含了文件中出现的各个节的语义，包括节的类型、位置和大小等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小，同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。 符号表（.symtab）：在Ubuntu下用命令readelf-shello.o查看其符号表结构： 图4.4hello.o的符号表 符号表（.symtab）： 存放程序中定义和引用的函数和全局变量的信息。name是符号名称，对于可重定位目标模块，value是符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址。size是目标的大小，type是该符号的类型。 重定位节：在Ubuntu下用readelf -ahello.o查看hello.o的全部elf信息，其中包括重定位节(.rel.text): 图4.5hello.o的重定位节 重定位节：一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。 4.4Hello.o的结果解析 （以下格式自行编排，编辑时删除） objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 图4.6hello.o的反汇编代码 图4.7hello.s中的main反汇编代码 通过这两段反汇编代码的比较，发现其汇编指令不存在不相同的地方，只是反汇编代码中还显示其汇编指令对应的相关机器代码。将汇编指令分成操作数和操作码，则可在机器指令与汇编指令中建立一种美妙的双射，进而可以将汇编指令转换为电脑可以直接识别的机器指令。但还是存在一些不同的地方。接下来进行分析： 分支转移：汇编代码的跳转是段名称比如.L2这类段跳转，而机器指令的跳转是跳转到确定的一个地址。函数调用：汇编代码的跳转命令后往往跟的是调用函数的名称，而在反汇编代码中call的目标地址是当前的下一条指令，后面跟的操作数是调用函数地址距离当前PC的相对偏移量。但这些需要动态连接时才可被确定，所以在反汇编成机器代码时，不确定相对地址，则将call指令后的相对地址全设为0；然后后在.rela.text重定位节中为其添加重定位条目，等待静态链接的进一步确定。 4.5本章小结 本章我们对hello.s进行了汇编操作，生成了可重定位目标文件hello.o，并且分析了其elf中的各种段种的信息，包括ELF头，重定位表，节头部表和符号表。然后在此基础上对hello.s和hello.o中的反汇编代码进行了比较，明确了汇编指令与机器指令间令人愉悦的美妙双射关系。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载到内存中并执行。链接可以发生在编译时，也可以发生在加载时，甚至执行在运行时。在现代系统中，链接是由较做链接器的程序自动执行的。 链接的作用：使得“分离编译”成为可能。我们不用将一个大型的应用组织成为一个大的源文件，而是可以把它分解成为更小的，更好管理的模块，可以独立的修改这些模块，我们改变这些其中一个时，只需简单的重新编译它，并重新链接，而不需要重新编译其他文件。 5.2在Ubuntu下链接的命令 命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1动态链接命令 5.3可执行目标文件hello的格式 1.ELF头：与hello.o的不同之处是类型变为了exec可执行文件，同时节头数量变为了25。 图5.2hello的ELF头 2.Section头节头表记录了各个节的信息，Address是程序被载入到虚拟地址的起始地址，off是在程序中的偏移量，size是节的大小。 图5.3hello的节头部表 重定位节： 图5.4hello的重定位节 符号表： 图5.5hello的符号表 5.4hello的虚拟地址空间 用edb查看程序hello，发现程序在地址0x400000~0x401000中被载入，从0x400000开始到0x400fff结束，这之间每个节的排列同节头部表中Address中声明。在0x400fff之后存放的是.dynamic~.shstrtab节。 图5.6datadump中0x400000内容 如图所示，开头是ELF头部分内容。 查看地址0x0x400200，发现是.interp节，保存着linux动态共享库的路径。 图5.7datadump查看地址0x400200内容 查看地址0x0x400298，发现是.dynsym节，保存动态符号表。 图5.8datadump查看地址0x400298内容 节头部表中的其他节都可以按照此方法一一查看其地址和内容。 5.5链接的重定位过程分析 两者main函数的汇编指令完全相同，除了地址由相对偏移变成了可以由CPU直接寻址的绝对地址。链接器把hello.o中的偏移量加上程序在虚拟内存中的起始地址0x400000和.text节的偏移量就得到了hello1中的地址。函数内的控制转移即jmp指令后的地址由偏移量变为了偏移量+函数的起始地址；call后的地址由链接器执行重定位后计算出实际地址。 除了main函数，hello比hello.o多出了几个函数：printf、sleep、puts、getchar、atoi、exit。 除了.text节的区别外，hello比hello.o多出了几个节：.init节、.plt节、.fini节。其中.init节是程序初始化需要执行的代码，.fini节是程序正常终止时需要执行的代码，.plt节是动态链接中的过程链接表。 函数调用：链接器解析重定条目时发现对外部函数调用的类型为R_X86_64_PLT32的重定位，此时动态链接库中的函数已经加入到了PLT中，.text与.plt节相对距离已经确定，链接器计算相对距离，将对动态链接库中函数的调用值改为PLT中相应函数与下条指令的相对地址，指向对应函数。对于此类重定位链接器为其构造.plt与.got.plt。 rodata引用：链接器解析重定条目时发现两个类型为R_X86_64_PC32的对.rodata的重定位（printf中的两个字符串），.rodata与.text节之间的相对距离确定，因此链接器直接修改call之后的值为目标地址与下一条指令的地址之差，指向相应的字符串。 图5.9hello的反汇编代码 图5.12edb查询函数执行流程图 5.7Hello的动态链接分析 对于动态共享链接库中PIC函数，编译器没有办法预测函数的运行时地址，所以需要添加重定位记录，等待动态链接器处理，为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT+全局偏移量表GOT实现函数的动态链接，GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。 PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 根据段头部表查看GOT表的值： 图5.13hello的GOT表（未调用init前） 图5.15GOT表内地址对应内容 5.8本章小结 本章介绍了链接的概念和作用，对链接后生成的可执行文件hello的elf格式文件进行了分析，分析了hello的虚拟地址空间、重定位过程、执行过程的各种处理操作。我们的hello程序终于出生了！ （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程就是一个执行中程序的实例。每次用户向shell中输入一个可执行文件的名字，运行程序时，shell就会创建一个新的进程。 进程的作用：进程为用户提供一种假象，我们的程序好像时系统中当前运行的唯一程序，我们的程序好像是独占处理器和内存，我们的程序代码和对象就像是系统内存中唯一存在的对象；处理器好像是无间断的执行和处理我们程序中的指令。 6.2简述壳Shell-bash的作用与处理流程 shell-bash的作用：shell-bash是一个C语言程序，它代表用户执行进程，它交互性地解释和执行用户输入的命令，能够通过调用系统级的函数或功能执行程序、建立文件、进行并行操作等。同时它也能够协调程序间的运行冲突，保证程序能够以并行形式高效执行。bash还提供了一个图形化界面，提升交互的速度。 shell-bash的处理流程： (1)终端进程读取用户由键盘输入的命令行。 (2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量 (3)检查第一个命令行参数是否是一个内置的shell命令，如果不是内部命令，调用fork()创建新进程/子进程 (4)在子进程中，用步骤2获取的参数，调用execve()执行指定程序。 (5)如果用户没要求后台运行(命令末尾没有&号）否则shell使用waitpid等待作业终止后返回。 (6)如果用户要求后台运行(如果命令末尾有&号），则shell返回； 6.3Hello的fork进程创建过程 首先打开terminal输入./hello1190200820李宇，接下来shell会分析这条命令，由于./hello不是一条内置的命令，于是判断./hello的语义是执行当前目录下的可执行目标文件hello，然后Terminal会调用fork创建一个新的运行的子进程，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，这就意味着，当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程与子进程之间的区别在于它们拥有不同的PID。 图6.1fork创建子进程流程图 6.4Hello的execve过程 在fork之后，子进程调用execve函数，execve函数在新创建的子进程的上下文中加载并运行hello程序。execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有发生错误时execve才会返回到调用程序。所以，execve调用一次且从不返回。 execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行程序,加载器删除子进程现有的虚拟内存段,并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零,通过将虚拟地址空间中的页映射到可执行文件的页大小的片,新的代码和数据段被初始化为可执行文件中的内容。最后加载器设置PC指向_start地址,_start最终调用main函数.除了一些头部信息,在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制,这时,操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 6.5Hello的进程执行 相关术语概念： 逻辑控制流：一系列程序计数器PC的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。（2）时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。（3）用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。（4）上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程的决定叫做调度。上下文切换的流程是： 保存当前进程的上下文。恢复某个先前被抢占的进程被保存的上下文。将控制传递给这个新恢复的进程。 图6.2上下文切换流程 然后分析hello的进程：hello初始运行在用户模式，调用sleep后进入内核模式，内核对休眠进行处理，并请求主动释放当前进程，并将hello从运行队列加入等待队列，定时器开始计时，此时内核把上下文切换的权限交给其他进程，2.5s后定时器发送中断信号，hello从等待队列移入运行队列，成为就绪状态，然后一切恢复，可以进行自己的控制逻辑流了。 6.6hello的异常与信号处理 6.6.1异常 hello执行过程中可能出现四类异常：中断、陷阱、故障和终止。 （1）中断是来自I/O设备的信号，异步发生，中断处理程序对其进行处理，返回后继续执行调用前待执行的下一条代码，就像没有发生过中断。 （2）陷阱是有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。帮助程序从用户模式切换到内核模式。 （3）故障是由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。 （4）终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程序会将控制返回给一个abort例程，该例程会终止这个应用程序。 6.6.2信号 图6.3信号的种类名称 6.6.3信号的处理 （1）正常运行hello程序。可以看出，程序在执行结束后，进程被回收。 图6.4正常执行hello （2）随便乱按。发现乱按会将输入的内容保存在缓冲区，等进程结束后作为命令行的内容输入。 图6.5随意乱按hello的执行结果 （3）运行过程中按下Ctrl-C。发现会向进程发送SIGINT信号。信号处理程序终止并回收进程。 图6.6输入crtl-c的hello执行结果 （4）运行过程中按下Ctrl-Z。当按下Ctrl-Z之后，shell进程收到SIGSTP信号，信号处理函数的逻辑是打印屏幕回显、将hello进程挂起。 图6.7输入crtl-Z后程序被挂起 图6.9kill杀死挂起的hello进程 （6）pstree命令 图6.10pstree指令执行 6.7本章小结 本章简述了进程管理的一些简要信息，比如进程的概念作用，shel的基本原理，shell如何调用fork和execve我们的hello进程，我们的hello进程在执行时会遇到什么样的情况（包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill 等命令的处理），它对这些情况如何做出反应。又介绍了一些常见异常和其信号处理方法。我们的hello出生后就进入了错综复杂的环境，他也要学习相关知识，来处理处理常伴身边的信号。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：是指由程序产生的与段相关的偏移地址部分。又称绝对地址。其表达形式为“段地址：段内偏移地址”。 虚拟地址：CPU启动保护模式后，程序运行在虚拟地址空间中。与物理地址相似，虚拟内存被组织为一个存放在磁盘上的N个连续的字节大小的单元组成的数组，其每个字节对应的地址成为虚拟地址。虚拟地址包括VPO（虚拟页面偏移量）、VPN（虚拟页号）、TLBI（TLB索引）、TLBT（TLB标记）。 线性地址：是逻辑地址到物理地址变换之间的中间层。程式代码会产生逻辑地址，或说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。 物理地址： 是指出目前CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。 由图可以看出，400532是逻辑代码的偏移量，加上.text段的基地址就能得到main的虚拟内存地址。 图7.1hello的汇编代码 7.2Intel逻辑地址到线性地址的变换-段式管理 原理：在段式存储管理中，将程序的地址空间划分为若干个段(segment)，这样每个进程有一个二维的地址空间。在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在段式存储管理系统中，则为每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续，物理内存的管理采用动态分区的管理方法。 为了实现段式管理，操作系统需要如下的数据结构来实现进程的地址空间到物理内存空间的映射，并跟踪物理内存的使用情况，以便在装入新的段的时候，合理地分配内存空间。 ·进程段表：描述组成进程地址空间的各段，可以是指向系统段表中表项的索引。每段有段基址(baseaddress)，即段内地址。 在系统中为每个进程建立一张段映射表： 图7.2段映射表 在段式管理系统中，整个进程的地址空间是二维的，即其逻辑地址由段号和段内地址两部分组成。为了完成进程逻辑地址到物理地址的映射，处理器会查找内存中的段表，由段号得到段的首地址，加上段内地址，得到实际的物理地址(见图4 5)。这个过程也是由处理器的硬件直接完成的，操作系统只需在进程切换时，将进程段表的首地址装入处理器的特定寄存器当中。这个寄存器一般被称作段表地址寄存器。 图7.3段式内存管理流程 7.3Hello的线性地址到物理地址的变换-页式管理 原理：将程序的逻辑地址空间划分为固定大小的页，而物理内存划分为同样大小的页框。程序加载时，可将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是VPN（虚拟页号），后一部分是VPO（虚拟页偏移量）。 图7.4物理地址结构 相关数据结构--页表：页表将虚拟内存映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。页表是一个页表条目（PTE）的数组。虚拟地址空间的每个页在页表中一个固定偏移量处都有一个PTE。假设每个PTE是由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。 页式内存管理：MMU利用VPN来选择适当的PTE，将列表条目中PPN和虚拟地址中的VPO串联起来，就得到相应的物理地址。 图7.5k级页表的地址翻译 7.4TLB与四级页表支持下的VA到PA的变换 TLB：一个小的，虚拟寻址的缓存，其每一行都保存在着由单个PTE组成的块。TLB通常具有非常高的相联度；如图所示 图7.6虚拟地址访问TLB的组成部分 TLB命中与不命中的步骤： 图7.7TLB操作图 Corei7使用的是四级页表层次结构。在四级页表层次结构的地址翻译中，虚拟地址被划分为4个VPN和1个VPO。每个第i个VPN都是一个到第i级页表的索引，第j级页表中的每个PTE都指向第j+1级某个页表的基址，第四级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN之前，MMU必须访问四个PTE。 图7.8Corei7的页表翻译 7.5三级Cache支持下的物理内存访问 在现代计算机中，存储器被组织成层次结构，因为这样可以最大程度地平衡访存时间和存储器成本。所以在CPU在访存时并不是直接访问内存，而是访问内存之前的三级cache。已知Corei7的三级cache是物理寻址的，块大小为64字节。LI和L2是8路组相联的，而L3是16路组相联的。Corei7实现支持48位虚拟地址空间和52位物理地址空间。 我们拿L1cache的访存来举例： 取出虚拟地址的组索引位，将二进制组索引转化为一个无符号整数，找到相应的组。把虚拟地址的标记为拿去和相应的组中所有行的标记位进行比较，当虚拟地址的标记位和高速缓存行的标记位匹配时，而且高速缓存行的有效位是1，则高速缓存命中。一旦高速缓存命中，我们就知道我们要找的字节在这个块的某个地方。因此块偏移位提供了第一个字节的偏移。把这个字节的内容取出返回给CPU即可不命中如果高速缓存不命中，那么需要从存储层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位所指示的组中的一个高速缓存行中。 所有cache的访存过程都可以分为这些步：组选择，行匹配，字选择，不命中处理； 图7.9i7的地址翻译过程 7.6hello进程fork时的内存映射 当fork被当前进程调用后，内核为新进程创建各种数据结构，并分配给它一个唯一的PID；为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct，区域结构和页表的原样副本。它将两个进程都标为只读，并将两个进程中的每个区域结构都标记为私有的写时复制； 当fork在新进程中返回时，新进程的虚拟内存刚好和调用fork的虚拟内存相同。当两个进程任意一个进行写操作时，写时复制机制就会创建新页面。 图7.10 hello进程fork时的内存映射 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1)删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2）映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3)映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 4）设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 图7.11加载器映射地址空间 7.8缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页，缺页故障是一种常见的故障，当指令引用一个虚拟地址，在MMU中查找页表时发现与该地址相对应的物理地址不在内存中，因此必须从磁盘中取出的时候就会发生故障。 图7.12缺页现象 缺页中断处理：缺页处理程序是系统内核中的代码，选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送VA到MMU，这次MMU就能正常翻译VA了。 图7.13缺页中断处理-牺牲页 7.9动态存储分配管理 动态内存分配器：动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护，每个块要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 图7.14堆 分配器有两种类型：显式分配器和隐式分配器； 显示分配器：要求应用显示的释放任何已分配的块。例如C标准库提供一个叫做malloc程序包的显示分配器。 隐式分配器：要求分配器检测一个已分配块何时不再被程序使用，那么就释放这个块。例如java等高级语言中的自动垃圾回收； 隐式空闲链表分配器； 任何实际的分配器都需要一些数据结构，允许它区别块边界，区别已分配块和空闲块；隐式分配器采取一种简单的方法： 图7.15简单的堆块格式 然后我们就可以将堆组织成一个连续的已分配块和空闲块组成的序列： 图7.16隐式空间链表组织堆 隐式空闲链表分配方式： (1)放置已分配的块：当一个应用请求一个k字节的块时，分配器搜索空闲链表。查找一个足够大可以放置所请求的空闲块。分配器搜索方式的常见策略是首次适配、下一次适配和最佳适配。 分割空闲块：一旦分配器找到一个匹配的空闲块，就必须做一个另策决定，那就是分配这个块多少空间。分配器通常将空闲块分割为两部分。第一部分变为了已分配块，第二部分变为了空闲块。 获取额外堆内存如果分配器不能为请求块找到空闲块，一个选择是合并那些在物理内存上相邻的空闲块，如果这样还不能生成一个足够大的块，分配器会调用sbrk函数，向内核请求额外的内存。 合并空闲块:如图所示： 图7.17合并空闲块的四种情况 显式空闲链表分配器：显示空闲链表是将空闲块组织为某种形式的显示数据结构。堆被组织为一个双向空闲链表，在每个空闲块中，都包含一个前驱和后继的指针。 图7.18双向空闲链表堆块 使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以使线性的，也可以是一个常数，这取决于我们选择的空闲链表中块的排序策略。 链表的维护方式有两种： 一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在线性时间内完成。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 一般而言，显示链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部，这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。 7.10本章小结 本章主要介绍了hello的存储管理，介绍了四种地址的概念，同时对地址的段页式管理进行了介绍，介绍了TLB与四级页表的支持下虚拟地址到物理地址的变化流程，同时也介绍了三级cache支持的物理地址访问；在此基础上回顾fork和execve的内存映射。然后介绍了缺页故障的处理方法和动态内存分配器的内存管理。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m字节的序列：B0,B1,B2……Bm所有的IO设备(如网路、磁盘、终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O,这使得所有的输入和输出都被当做相应文件的读和写来执行 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixI/O接口的几种操作： （1）打开文件：程序要求内核打开文件，内核返回一个小的非负整数（描述符），用于标识这个文件。程序在只要记录这个描述符便能记录打开文件的所有信息。 （2）shell在进程的开始为其打开三个文件：标准输入、标准输出和标准错误。 （3）改变当前文件的位置：对于每个打开的文件，内核保存着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作显式地设置文件的当前位置为k。 （4）读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会出发一个称为EOF的条件，应用程序能检测到这个条件，在文件结尾处并没有明确的EOF符号。 （5）关闭文件：内核释放打开文件时创建的数据结构以及占用的内存资源，并将描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： （1）intopen(char*filename,intflags,mode_tmode);open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。 （2）intclose(intfd);关闭一个打开的文件，返回操作结果。 （3）ssize_tread(intfd,void*buf,size_tn);read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF，否则返回值表示的是实际传送的字节数量。 （4）ssize_twrite(intfd,constvoid*buf,size_t);write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 printf函数源代码： `staticintprintf(constchar*fmt, ) { va_listargs; inti; va_start(args,fmt); write(1,printbuf,i=vsprintf(printbuf,fmt,args)); va_end(args); returni; } printf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。 write函数内容： write: moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL 其中intINT_VECTOR_SYS_CALLA代表通过系统调用syscall。 Syscall内容： sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret syscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中。 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar的源代码为： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章介绍了Linux中I/O设备的管理方法，UnixI/O接口和函数，并且分析了printf和getchar函数是如何通过UnixI/O函数实现其功能的。 （第8章1分） 结论 Hello精彩有坎坷的一生结束了，这一世hello经历过的重要阶段有： 通过文本编辑器编写，从空白文档变为hello.c文件；预处理：经过cpp的预处理，展开文件开头的宏和引用的文件；生成hello.i;编译阶段：经过编译器的编译得到hello.s文本文件；汇编阶段：经过汇编器的翻译将编译得到的hello.s文件翻译成为机器可以读懂的机器代码；同时将重定位信息加入，生成可重定位目标文件；链接阶段：链接器ld将hello.o与动态链接库链接生成可执行目标文件hello，从此，hello程序正式诞生；运行阶段：在shell中输入./hello1190200820李宇，hello开始运行；创建子进程：shell进程调用fork为其创建子进程加载：shell调用execve，execve调用启动加载器，加映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数。执行：CPU为hello分配时间片，hello执行自己的控制逻辑流访存：CPU为hello申请一个虚拟地址在，再通过mmu来翻译成物理地址并利用cache来访问内存；动态分配内存：printf会调用malloc向动态内存分配器申请堆中的内存。信号处理：shell处理hello运行过程中输入的各种信号；结束，被回收：shell父程序回收子进程内核删除跟这个进程有关的地址和数据，hello过完了自己的一生； 感悟：计算机的底层原理其实还是复杂而精巧的，一个最简单的hello.c程序的一生也经历了若如此奇幻的过程。从最底层的二进制机器代码，到cpu对程序的执行，越来越抽象；同时也敬佩计算机前辈们的头脑，设计出如此全面美妙的计算机系统；这次大作业是一边复习一边完成，加深了对书本上和老师讲解内容的理解； （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 （附件0分，缺失-1分） 文件名称文件内容hello.c源文件hello.i预处理后的文本文件hello.o可重定位目标执行文件hello连接以后的可执行文件hello.elfhello.o的elf表hello.txthello的反汇编代码hello.s编译之后的汇编文件helloo.txthello.o的反汇编代码 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42. [2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998 [1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] https://blog.csdn.net/hit_shaoqi/article/details/78516508 [7] file:///C:/Users/m1777/Desktop/深入理解计算机系统原书第3版 [8] https://www.cnblogs.com/pianist/p/3315801.html （参考文献0分，缺失-1分） 

哈工大2021春计算机系统大作业程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P 专业计算机 学号1190200828 班级1936601 学生赵英帅 指导教师刘宏伟 计算机科学与技术学院 2021年6月 摘要 大作业名为程序人生。人生大家都懂，是从出生到死亡的过程。那么，程序的一生都会经历些什么呢？通过PPT中Hello的自白，我们可以略知一二。本文将较为完整详细地阐述hello程序的生命周期，探讨hello程序从hello.c经过预处理、编译、汇编、链接到可执行文件诞生的全过程。并且我们将分析我们的计算机系统是如何“见证”hello的成长、表演直到谢幕回收hello，即Bash与OS对hello进行的进程管理、存储管理和I/O管理。通过对hello的程序人生，我们对计算机系统将有更深的了解。 **关键词：**计算机系统，Linux，Hello程序，预处理，编译，汇编，链接，进程，存储，虚拟内存，I/O **** 目录 第1章概述-4- 1.1Hello简介-4- 1.2环境与工具-4- 1.3中间结果-5- 1.4本章小结-5- 第2章预处理-6- 2.1预处理的概念与作用-6- 2.2在Ubuntu下预处理的命令-6- 2.3Hello的预处理结果解析-6- 2.4本章小结-7- 第3章编译-8- 3.1编译的概念与作用-8- 3.2在Ubuntu下编译的命令-8- 3.3Hello的编译结果解析-8- 3.3.1全局变量sleepsecs-8- 3.3.2输出字符串-9- 3.3.3main函数参数argc、数组argv-9- 3.3.4局部变量i-10- 3.3.5main函数-10- 3.3.6关系操作-10- 3.3.7函数操作-10- 3.3.8其他操作-11- 3.4本章小结-11- 第4章汇编-12- 4.1汇编的概念与作用-12- 4.2在Ubuntu下汇编的命令-12- 4.3可重定位目标elf格式-12- 4.4Hello.o的结果解析-14- 4.5本章小结-15- 第5章链接-16- 5.1链接的概念与作用-16- 5.2在Ubuntu下链接的命令-16- 5.3可执行目标文件hello的格式-16- 5.4hello的虚拟地址空间-18- 5.5链接的重定位过程分析-19- 5.6hello的执行流程-21- 5.7Hello的动态链接分析-21- 5.8本章小结-22- 第6章hello进程管理-23- 6.1进程的概念与作用-23- 6.2简述壳Shell-bash的作用与处理流程-23- 6.3Hello的fork进程创建过程-23- 6.4Hello的execve过程-24- 6.5Hello的进程执行-24- 6.6hello的异常与信号处理-25- 6.7本章小结-28- 第7章hello的存储管理-29- 7.1hello的存储器地址空间-29- 7.2Intel逻辑地址到线性地址的变换-段式管理-29- 7.3Hello的线性地址到物理地址的变换-页式管理-30- 7.4TLB与四级页表支持下的VA到PA的变换-31- 7.5三级Cache支持下的物理内存访问-32- 7.6hello进程fork时的内存映射-32- 7.7hello进程execve时的内存映射-32- 7.8缺页故障与缺页中断处理-33- 7.9动态存储分配管理-33- 7.10本章小结-36- 第8章hello的IO管理-37- 8.1Linux的IO设备管理方法-37- 8.2简述UnixIO接口及其函数-37- 8.3printf的实现分析-38- 8.4getchar的实现分析-40- 8.5本章小结-40- 结论-41- 附件-42- 参考文献-43- 第1章概述 1.1Hello简介 hello是一个基础却最重要的程序，它的一生都在计算机系统的“照顾”下，因此从其运行的过程，我们可以学到计算机系统各个方面的知识。hello的运行过程大致分为两个阶段 P2P和020： P2P： FromProgramtoProcess的缩写，即从程序到进程的转换过程。该过程中，hello.c文件首先经历的是来自cpp的预处理，cpp并不尝试着理解C语言语法，而是在编译之前给hello“换身衣服”，即实现文本替换功能(.i)。紧接着它将经历来自ccl的编译，它将hello改头换面，转换成了我们这学期刚认识的“新朋友”，汇编代码(.s)，这已经很贴近计算机硬件了。然后as也来凑热闹，将刚刚得到的汇编代码翻译成一定格式的机器码(.o)。最后，经过ld的链接，最终形成了可执行文件(.out)。在在shell中键入启动命令后，shell为其fork产生一个子进程，然后hello便从程序变为了进程。 020: FromZerotoZero的缩写，即进程从初始到回收的过程。该过程中，shell为hello进程execve、mmap，进入程序入口后程序开始载入物理内存，然后进入main函数执行目标代码，TLB、Cache努力地让hello快点登上舞台，CPU为运行的hello分配时间片执行逻辑控制流，I/O管理与信号处理软硬结合，在各种软硬件的支持下，hello开始了它的表演。hello的表演转瞬而逝，完美谢幕，shell父进程回收hello进程，内核删除相关数据结构。 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上； 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位； 开发工具：GDB/OBJDUMP；EDB；GCC，readelf，HexEdit等。 1.3中间结果 文件名文件作用hello.ihello.c经过预处理得到的文本文件hello.shello.i编译生成的汇编文件hello.ohello.s经过汇编生成的可重定位目标文件hello.txthello.o反汇编后生成的汇编语言文本文件hello.out链接后生成的可执行文件asm.shello.o反汇编后生成的汇编语言文本文件 1.4本章小结 本章对hello进行了总体的介绍，结合hello的自述，主要简述了hello的P2P和020过程、实验的环境和工具以及实验中生成了的文件及其作用。后文将依据本章作详细展开。 第2章预处理 2.1预处理的概念与作用 预处理的概念预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。对于C语言，由预处理器CPP对程序源代码文本进行处理，得到的结果再由编译器核心进一步编译。这个过程并不对程序的源代码进行解析，但它把源代码分割或处理成为特定的单位。预处理的作用预处理中会展开以#起始的行，试图将它们解释为预处理指令，包括#if/#ifdef/#ifndef/#else/#elif/#endif（条件编译）、#define（宏定义）、#include（头文件包含）、#line（行控制）、#error（错误指令）、#pragma（和实现相关的杂注）以及单独的#（空指令）。预处理指令一般被用来使源代码在不同的执行环境中被方便的修改或者编译。 2.2在Ubuntu下预处理的命令 预处理的命令为：cpphello.c>hello.i，当然也可以是gcc-Ehello.c-ohello.i。这两个指令都可以得到预处理得到的文件，即hello.i。 由下截图可知，预处理成功，我们得到了hello.i文件。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-1iupoXLS-1624591156865)(media/c4ebb97fc1e832d01f294f267dbc0530.png)] 2.3Hello的预处理结果解析 打开hello.i文件，我们发现，该文件与hello.c相比，hello.i明显多了许多内容。结合预处理的概念及作用，不难得知，多出来的内容为预处理得到的头文件stdio.h、unistd.h、stdlib.h的具体内容。将文件翻到最后可以看到，hello.c中的C语句内容并未发生改变，进一步说明预处理并不对程序的源代码进行解析。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BdH5NJVP-1624591156867)(media/482cccaee3e7609d8fbdfae080c9c735.png)] 2.4本章小结 本章对hello的P2P阶段的第一步，即来自cpp的预处理过程进行介绍，主要介绍了预处理的概念及作用、在Ubantu中对hello.c的预处理命令以及预处理的结果，了解到预处理是对头文件包含、宏定义等行进行解释，并不对程序的源代码进行解析。 第3章编译 3.1编译的概念与作用 编译的概念编译是指编译器ccl将文本文件hello.i翻译成文本文件hello.s的过程，翻译得到的hello.s中包含一个汇编语言程序。编译的作用首先ccl将检查代码的正确性，即进行词法分析、语法分析、语义分析等，检查无误后，ccl将源代码翻译为汇编代码。 3.2在Ubuntu下编译的命令 编译的命令为：gcc-Shello.c-ohello.s； 由下截图知，编译成功，我们得到了hello.s文件。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c4bVdUfp-1624591156869)(media/e4d5e69d9a419946ea7d1c709a933073.png)] 3.3Hello的编译结果解析 3.3.1全局变量sleepsecs 对于全局变量sleepsecs的定义的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QqLfRhuT-1624591156870)(media/8674fe0877735d563787f14c385fe0b9.png)] 分析首先，globl声明该变量为全局变量，align为其地址对齐方式，type声明该变量为数据类型而非函数类型，.rodata声明只读代码段。因为sleepsecs变量为int型，所以size为4；其次，对于后续对sleepsecs的定义中，.long为2表明该变量的值为2，其他声明作用同上；最后，读C语言代码可知，sleepsecs=2.5，但是在汇编代码中.long却是2，这是因为sleepsecs类型为int而非float，相当进行一个隐式类型转换操作，即intsleepsces=(int)2.5，于是编译后其值为2。 3.3.2输出字符串 对于两个输出字符串的定义的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OCL0sJN9-1624591156871)(media/51d5588a4cf0314c9138707f10504d24.png)] 分析：根据后续代码结合源文件可知，这两个字符串将作为调用printf函数的参数，具体方法将在后续分析中给出。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IHI5lJQP-1624591156872)(media/300b955e4c5ffa87ad8bc6cfa05daa49.png)][外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Cd7n70lF-1624591156872)(media/5dad954b83aa76944c1e96384b17ae9d.png)] 3.3.3main函数参数argc、数组argv 处理argc、数组argv的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cJkVV28y-1624591156873)(media/c4ea6313165cf5951cfc354abd9e23d5.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kvq7804e-1624591156873)(media/d314f93e4bbb2222f7c80003957eac0c.png)] 分析：第29行和30行进行的是将参数argc与数组argv的地址压栈的过程，主要判断依据是第31行的操作，即将存在地址%rbp–20处的值与3进行比较，由hello.c的代码可知，第31行实际上正是参数argc与3的比较；而在第41到50行进行的数组操作是，将数组argv中的argv[1]和argv[2]两个值作为调用printf函数输出字符串LC1的两个参数。 3.3.4局部变量i 处理i的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mIH4p0Hm-1624591156874)(media/acc1abfccbd59e99e89f0d9720ebe97a.png)] 分析：局部变量i被压入栈中，保存在地址%rbp-4中。局部变量作为循环变量，除赋初值为0外，还需要进行的算数操作是每次循环加1，即每次循环中的代码执行完毕，i++，相应的汇编代码出现在L4中： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kTn19uAy-1624591156874)(media/31d8f7d5ac9a7ef1e77d13ff8c3e0c5b.png)] 3.3.5main函数 对于main函数的说明的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ro5gbaJK-1624591156874)(media/cee49dfcaf216f3d6ee63856dd5e1b13.png)] 分析：对于main函数，首先.globl声明main为全局变量，而type则声明main为函数类型而非数据类型，因此main为全局函数。main函数为主函数，是程序执行的起点。 3.3.6关系操作 hello.c中包括的关系操作有argc!=3和i<10，相应的源码及其翻译而成的汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wjp4yufU-1624591156875)(media/146f9e06e951aa4922d4770e01fc7110.png)]=>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7gYYxwzh-1624591156875)(media/66df1470711f076f5d8b6a4b01988cb6.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pllTMzzL-1624591156876)(media/8ea832f2c7867c999d0b06dc939af2c4.png)]=>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zPpK7XDx-1624591156876)(media/faafec942e016315f819a229ef9d6c63.png)] 分析：关系操作argc!=3在汇编代码中被翻译为cmpl，而cmpl后将进行跳转je操作，即控制转移。当argc等于3时，不满足条件，则跳过if跳转至L2，执行L2中的操作即将i的初值设置为0，然后跳转L3执行if之后的for循环语句；否则将执行if中的语句。关系操作i<10在汇编代码中被翻译为cmpl和jle，在L3中判断循环条件，即i是否小于等于9，即i小于10。若满足循环条件，则跳转至L4继续进行循环，L4执行完最后一句时自动进入L3，再次判断循环条件，若满足循环条件则再次跳进L4，直到i<10不成立即循环条件不满足时，循环结束。 3.3.7函数操作 hello.c中有关函数的操作有main函数的执行，调用printf函数、exit函数、sleep函数、getchar函数，以及main函数的返回return，相关汇编代码如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-55z4GV9z-1624591156876)(media/815ac5bc6d2a9f04fb83ff79ba5b43f2.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IEtIgoVv-1624591156877)(media/9a6bbc66fdd8b6c6d3072c98f32652e8.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zonNGyCn-1624591156877)(media/c60c3da79c8d20ae7b1c57d0c7b9b4d6.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-e9grMHMz-1624591156877)(media/3924f79f039565c3f0fbf5fefe605f65.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-phVZ5oxP-1624591156878)(media/2e2c94abf7c31d6aac2c8e27af7da147.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-O9XWehfG-1624591156878)(media/79d2b2d2ad860e406f800f5a91711127.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vWQvPkCt-1624591156879)(media/561a77bd763d8e79262f5ba8d70b2d4c.png)] 分析：首先，main函数是主函数，是程序执行的起点。main函数中，进行了两次输出函数printf的调用，但是汇编代码中却并不都是call的printf，其中第一次call的是puts，我认为原因在于该次调用输出函数并不需要传递参数，于是调用puts，将字符串输出即可。而第二次调用printf是在循环中，这次调用输出函数需要有参数，即argv[1]和argv[2]，传参过程及汇编代码已经在3.3.3中展示，不再重复；将1作为参数调用exit函数，表示异常退出；将全局变量sleepsecs作为参数调用sleep函数，让进程休眠2秒；调用getchar函数，吸收缓存区的所有字符；return0，即main函数的返回值为0。 3.3.8其他操作 赋值操作：主要是对全局变量sleepsecs和局部变量i的赋值，翻译为汇编代码的赋值操作为mov，在3.3.1和3.3.4中已经展示，不再重复；【注】mov具体包括：movb一个字，movw两个字节，movl四个字节，movq八个字节，遍布整个汇编代码；类型转换：在3.3.1中已经展示全局变量sleepsecs赋值时的隐式转换，不再重复；算术操作：主要是for循环中i++操作，翻译为汇编代码为add，在3.3.4中已经展示，不再重复；数组操作：主要是argv的数组操作，在3.3.3中已经展示，不再重复；控制转移：在3.3.6中已经与关系操作一同展示，不再重复。 3.4本章小结 本章主要介绍了编译的概念及作用，结合PPT中的提示，重点展示了在编译阶段中，编译器如何处理hello.c中的各种数据和操作，以及各类型数据和操作经过编译器翻译后对应的汇编代码。 第4章汇编 4.1汇编的概念与作用 汇编的概念 汇编语言是为特定计算机或计算机系列设计的一种面向机器的语言，由汇编执行指令和汇编伪指令组成。采用汇编语言编写程序虽不如高级程序设计语言简便、直观，但是汇编出的目标程序占用内存较少、运行效率较高，且能直接引用计算机的各种设备资源。它通常用于编写系统的核心部分程序，或编写需要耗费大量运行时间和实时性要求较高的程序段。 汇编的作用 汇编程序是指把汇编语言书写的程序翻译成与之等价的机器语言程序的翻译程序。汇编程序输入的是用汇编语言书写的源程序，输出的是用机器语言表示的目标程序。 4.2在Ubuntu下汇编的命令 预处理的命令为：ashello.s-ohello.o； 由下截图知，编译成功，我们得到了hello.o文件 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eMnGQpC0-1624591156879)(media/589bcf23f7c6c5bffeffe8d80bd1837e.png)] 4.3可重定位目标elf格式 readelf-hhello.o查看ELF头ELFHeader，结果如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Kk5qPLL6-1624591156880)(media/c01877ab26f54675771226dfc854e94a.png)] 在ELFHeader中可以看到ELF类型、版本、大小端等信息。根据头文件的信息，可以知道该文件是可重定位目标文件，有14个节。 readelf-Shello.o查看节头表SectionHeaders，结果如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-We4UOmU3-1624591156881)(media/6ffb1579d2b8d1e3dde0d98cc2fd71ad.png)] 在SectionHeaders中可以看到，目标文件中的每个节都有一个固定的条目体现在这个表中，指明了各个节的信息，包括名称、类型、起始地址和偏移量等。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。同时从信息中可以观察到，代码段可执行，但是不可写；数据段和只读数据段都不可执行，只读数据段不可写等。 readelf-rhello.o查看重定位节.rela.text，结果如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tG10x8ey-1624591156881)(media/6f85b4287c03aec8aa67db9ec82063d0.png)] 重定位节中保存的即是可重定位文件必须包含的说明如何修改其节内容的信息。当汇编器生成一个目标模块时，它并不知道数据和代码最终存放在内存中的什么位置，也不知道这个模块引用的任何外部定义的函数和全局变量的位置。而通过重定位节中保存的修改信息，链接器就能知道在将目标文件链接成可执行文件时如何修改这些未知引用。 readelf-shello.o查看符号表.symtab，结果如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZtYrEtCh-1624591156882)(media/cb189620be29b694e9522e3f2cce7cda.png)] 符号表：存放程序中定义和引用的函数和全局变量的信息。 Name：符号名称；Value：符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址；Size：目标的大小；Type：声明是数据类型还是函数类型；Bind：声明符号是局部的还是全局的。 4.4Hello.o的结果解析 objdump-d-rhello.o>hello.txt对hello.o进行反汇编，并将结果保存至hello.txt文件中；分析： 由反汇编生成的hello.txt与hello.s的比较可知，hello.txt中的汇编代码部分与hello.s功能上基本没有区别，形式上略有区别，例如： .s文件中由对于输出字符串、全局变量的定义，而反汇编代码中没有，这就导致了访问只读字符串、全局变量时方法的改变；[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uk1JgTiI-1624591156883)(media/518a5626e455a3b3548ddd3e78714404.png)]VS[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3MQrWhUY-1624591156883)(media/30b2a6232e9ce271a757a141a21b80c5.png)]在.s文件中的操作数为十进制，而在反汇编文件中为十六进制；[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-p4UU4tzW-1624591156884)(media/f616c9d335d6d3946e684778e046bcfe.png)]VS[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7fq8Vhvq-1624591156884)(media/36bb69e951ca0fead8f53803c1c1792a.png)].s文件中，调用转移函数时，控制转移到的地址是用L2等段名称表示，而反汇编文件中是用确定的地址； [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VE8zps4C-1624591156885)(media/1e08eeb5c0bde86e4827c2631565f4b7.png)]VS[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SNV3Z959-1624591156885)(media/1c3322044dc5237dd2b2ed9b2035ae5d.png)] 调用函数时，.s文件中是调用函数名，而反汇编代码中是调用函数链接修改后的相对偏移地址；[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vErc9Gql-1624591156885)(media/5756bb90b88f5f06cf3b93aff0a50747.png)]VS[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vV4E8YZG-1624591156886)(media/83c0a4b11f4a48a91800c0d361bcd55a.png)] 相对于汇编代码形式上的些许差别，两文件最大的不同是反汇编代码中包括了机器语言代码。 机器语言程序的是二进制机器指令的集合，是纯粹的二进制数据表示的语言，是电脑可以真正识别的语言。机器指令由操作码和操作数构成，汇编语言是人们比较熟悉的词句直接表述CPU动作形成的语言，是最接近CPU运行原理的语言。每一条汇编语言操作码都可以用机器二进制数据来表示，进而可以将所有的汇编语言和二进制机器语言建立一一映射的关系，因此可以将汇编语言转化为机器语言。 4.5本章小结 本章对hello.s进行了汇编，生成了hello.o可重定位目标文件，并且分析了可重定位文件的ELF头、节头表、可重定位节和符号表。本章还对hello.s进行了反汇编，比较了hello.s和hello.o反汇编代码的略微不同之处，介绍了机器语言的概念，并分析了从汇编语言到机器语言的一一映射关系。 第5章链接 5.1链接的概念与作用 链接的概念 链接是指在电子计算机程序的各模块之间传递参数和控制命令，并把它们组成一个可执行的整体的过程。 链接的作用 链接器将多个可重定位目标文件合并，生成可执行目标文件，这个文件可以被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。这使得分离编译成为可能。 5.2在Ubuntu下链接的命令 链接的指令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o-ohello.out 由下截图知，连接成功，生成了hello.out文件。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9tOGDDMG-1624591156886)(media/6a8d3e78968621881e4310f9b9eab67a.png)] 5.3可执行目标文件hello的格式 查看hello.out的ELF头： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dEqamn3G-1624591156887)(media/5d98f37c68562a799e5b5b55bf373100.png)] 从ELF头中可以知道，hello.out为可执行文件，并且包含27个节； 查看节头表： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OWuDfAOJ-1624591156887)(media/e8fabd4d45368783206bc03866068ff8.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lyne0WGJ-1624591156888)(media/e878b786a4012fa34f342d3651b1bda5.png)] 节头部表SectionHeaders对hello.out中所有的节信息进行了声明，包括大小、类型、地址、偏移量等，其中地址是指程序被载入到虚拟地址的起始地址。根据SectionHeaders中的信息我们就可以用HexEdit定位各个节所占的区间（起始位置，大小）。 查看链接后的重定位节： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E1PtDV52-1624591156889)(media/9bf636aea04351d67588c81871039bca.png)] 查看符号表： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eZyv8w9q-1624591156889)(media/0b341ccf978f7c0c9614b2ba880edb4b.png)] 5.4hello的虚拟地址空间 通过edb查看hello.out的虚拟地址空间各段的信息： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LOG5eXLp-1624591156890)(media/f17131a001e7a21248df7ff9498545b1.png)] 结合5.3中的节头表中各节的起始地址信息，可以通过edb的MemoryReigions找到各个节段的信息，例如.rodata节，起始地址为0x402000，大小为0x3A，在EDB中查看如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-P8lV5MGV-1624591156890)(media/bf8ec4bcb45f865573f4186108f7c2da.png)] 其他段的信息查看方式与.rodata节相同。 5.5链接的重定位过程分析 用命令objdump-d-rhello.out>asm.txt获得hello的反汇编代码并存入asm.txt文件中，由下截图知反汇编成功，生成了asm.txt文件。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xfSjAnrv-1624591156890)(media/73258818341aa1a325d9226dc5a1fa83.png)] 分析hello.out与hello.o的不同：hello.out反汇编的代码中多了很多的节以及其函数的汇编代码，如.init节、.plt节等，如下截图所示： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mTSTqU6d-1624591156891)(media/b5e78b99952a70dd7d8815ee27834c8a.png)] hello.out反汇编的代码有确定的虚拟地址，也就是说已经完成了重定位,而hello.o反汇编代码中代码的虚拟地址均为0，未完成可重定位的过程。例如下面两个截图，第一行为hello.out反汇编的代码而第二行为hello.o反汇编代码中与第一行对应的的代码： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-h5ivYucZ-1624591156892)(media/1104758b052b99ab76f628d6356ebf7f.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GvDfdu92-1624591156892)(media/8115a13f0e32b77f4db5c98248fde80c.png)] 链接与重定位过程：符号解析：目标文件(.o)定义和引用了符号，每个符号对应着一个函数、一个全局变量、一个静态变量等。符号解析的作用就是给每个符号引用分配一个精确的符号定义。链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对于那些引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。但是，对全局符号的引用解析要棘手得多。当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条(通常很难阅读的)错误信息并终止。重定位：重定位条目：当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在rel.text中。已初始化数据的重定位条目放在，rel.data中。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vk1XWYZ6-1624591156893)(media/061db4fd07eeca2127e5dc012014578e.png)] 重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节；重定位节中的符号引用：链接器依赖于可重定位目标模块中的重定位条目，修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。举例分析hello.out中的重定位过程： puts()： 重定位算法： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-x2OuOrVv-1624591156893)(media/de36c033475d7e7404986483b92d758d.jpeg)] 由puts的重定位条目，可得：r.offset=0x21;r.type=R_X86_64_PLT32;r.symble=puts;r.attend=-4;确定ADDR(s)=0x401105;由重定位算法，公式为：refaddr=ADDR(s)+r.offset=0x401105+0x21=0x401126*refptr=(unsigned)(ADDR(r.symbol)+r.addend-refaddr)=(0x401080+(-4)-0x401126)=-0xaa=(unsigned)(0xffffff56） 经验证，计算正确！相关截图如下： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FLHKqUei-1624591156893)(media/ebfd747ea49acd0aa745b766b3f40b33.png)] 5.6hello的执行流程 ld-linux-x86-64.so!_dl_start ld-linux-x86-64.so!_dl_init hello!_start hello!__libc_csu_init hello!_init libc.so!_setjmp hello!main hello!puts@plt ld-linux-x86-64.so!_dl_runtime_resolve_xsave ld-linux-x86-64.so!_dl_fixup ld-linux-x86-64.so!_dl_lookup_symbol_x hello!exit@plt libc.so!exit hello!_fini 5.7Hello的动态链接分析 动态链接简介动态链接，在可执行文件装载时或运行时，由操作系统的装载程序加载库。动态链接库中的函数在程序执行的时候才会确定地址，所以编译器无法确定其地址。为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。延迟绑定通过两个数据结构之间简洁但又有些复杂的交互来实现，即过程链接表（PLT）和全局偏移量表（GOT）。 PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 dl_init调用前后.got.plt的变化：由节头表可得.got.plt的地址为0x404000，大小为0x40： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jlONDXQb-1624591156894)(media/a9314c8778a39a81ca686a95b615b819.png)] 【注】蓝色选中区域即为.got.plt： 调用dl_init前： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-z1IH7jDG-1624591156894)(media/60b0fdd7bc35239b26d29494e3a6e2b8.png)] 调用dl_init后： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AqO1xalA-1624591156895)(media/310f78a6d769b2415a777bdd8ffd10de.png)] 对比信息，可见动态链接器解析函数的地址加入了信息中。 5.8本章小结 在本章中主要介绍了链接的概念与作用，并且详细阐述了hello.o链接成为一个可执行目标文件的过程，介绍了hello.o的ELF格式和某些节的含义，分析了hello.out的虚拟地址空间、重定位过程、执行流程、动态链接过程。经历了预处理、编译、汇编、链接，可执行的hello终于诞生了！虽然它在我这里叫做hello.out，但这对它的功能并没有什么影响。在以下的实验中，hello.out简称为hello。 第6章hello进程管理 6.1进程的概念与作用 进程的概念 进程是计算机科学中最深刻、最成功的概念之一，其经典定义为一个执行中程序的实例。 进程的作用 我们将关注它提供给应用程序两个关键抽象：一是一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器；二是一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 shell本身是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。作为命令语言，它交互式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支； shell的处理流程： 从终端读入输入的命令；将输入字符串切分获得所有的参数；如果是内置命令则立即执行，否则调用相应的程序执行；shell应该接受键盘输入信号，并对这些信号进行相应处理 6.3Hello的fork进程创建过程 当输入的命令不是内置shell命令时，父进程调用fork()函数创建一个新的子进程，子进程得到与父进程完全相同（但是独立）的一个副本，包括代码段、段、数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和子进程最大的不同时他们的PID是不同的。 有关hello的fork进程创建过程，例如当我在终端运行hello，输入运行指令./helloxy时，首先shell判断我输入的指令是否是shell内置命令，很显然不是，因此会调用fork为hello创建一个新的进程。 6.4Hello的execve过程 成功创建hello子进程之后，将调用execve函数在当前子进程的上下文加载并运行一个新的程序即hello程序。 当执行成功时，execve()并不会返回,调用execve的程序的代码段，data段，bss段和stack都将被加载的新程序的内容重写．这种状况其实就是金蝉脱壳，能够使用该函数来作程序的自更新；当调用失败时，返回-1,errno也被当即更新。 6.5Hello的进程执行 进程执行的相关概念两个抽象： 一个独立的逻辑控制流，它提供一个假象，好像我们的进程独占的使用处理器；一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用CPU内存。 逻辑并发流： 即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做逻辑控制流，或者简称逻辑流。 并发与时间片： 一个逻辑流的执行在时间上与另一个流重叠，称为并发流； 多个流并发地执行的一般现象被称为并发； 一个进程执行它的控制流的一部分的每一时间段叫做时间片。 私有地址空间： 进程为每个程序都提供一种假象，好像它独占地使用系统地址空间。一般而言，和地址空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，在这个意义上，这个地址空间是私有的。 用户模式和内核模式 处理器提供了一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常是用某个控制寄存器中的一个模式位(modebit)来提供这种功能的,该寄存器描述了进程当前享有的特权。 当设置了模式位时，进程就运行在内核模式中，一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置；没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令，也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。 运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序,处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。 上下文切换： 内核为每个进程维持一个上下文(context)。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度，是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换1)保存当前进程的上下文，2)恢复某个先前被抢占的进程被保存的上下文，3)将控制传递给这个新恢复的进程。 hello进程的执行 进程调用execve函数之后，进程已经为hello程序分配了自己的私有地址空间。当自定义参数有两个，分别是我的姓名和学号时，一开始，hello运行在用户模式下，输出Hello1190200828赵英帅，然后hello调用sleep函数之后进程转变为内核模式，内核不会等待sleep函数调用结束，而是休眠并释放hello进程，并将hello进程从当前运行队列中移出加入待运行队列，并转换回用户模式。随后定时器开始计时，内核进行上下文切换将当前进程的控制权交给其他进程。2秒后，休眠结束，定时器发送一个中断信号，进入内核模式处理中断，并将hello进程从待运行队列重新移入到运行队列，然后hello进程就又可以“登场表演”了。当然，再次输出Hello1190200828赵英帅后将重复以上过程，直到运行10次。而当自定义参数不为2时，则要简单的多，因为不会调用sleep也就没有模式转换，也就没有额外的上下文切换，hello表演转瞬即逝，直接退场。 6.6hello的异常与信号处理 异常的分类 异常可以分为四类：中断、陷阱、故障和终止，下图为对这些类别异常的属性做了小结。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yNDuU44i-1624591156895)(media/77b8b62534babb014b4c612bad70d1be.jpeg)] 中断中断是异步发生的，是来自处理器外部的I/O设备信号的结果。硬件中断不是任何一条专门的指令造成的，从这个意义上来说它是异步的。处理器从系统总线读取异常信号，然后调用适当的中断处理程序。当处理程序返回时，它将控制返回下一条指令，程序继续执行，就像没有发生中断一样。陷阱：陷阱是有意的异常，是执行一条指令的结果。像中断处理程序一样，陷阱处理程序将控制返回下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，称为系统调用。用户程序经常需要向内核请求服务，为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的“syscalln”指令，当用户程序想要请求服务n时，可以执行这条指令。执行该指令会导致一个异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。故障：故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。终止：终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。hello会出现的异常及信号在hello程序执行的过程中可能会出现外部I/O设备引起的异常，造成中断；hello执行sleep函数的时候会出现陷阱；执行hello程序的时候，可能会发生缺页故障；hello执行过程可能会出现DRAM或者SRAM位损坏的奇偶错误，引起终止。常见信号： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TrJZf8LA-1624591156895)(media/8ac0289d4bdb73eb883375525cbec3d5.jpeg)] 程序运行过程的键盘输入随便输入： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9MEyCiGS-1624591156896)(media/28921418fd2ddd2cd1e04c8fd004f519.png)] 可以发现，随便输入只是将屏幕的输入缓存，当打印结束执行getchar时，会读入一个回车结尾的字串作为一次输入，而其他字符串包括回车会在程序结束后当做shell命令行输入呈现。 Ctrl-z后分别运行psjobspstreefgkill等命令： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kGiKagRf-1624591156896)(media/8aa0b4af68f166e9b730b875cc4af2a4.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-PyT7f711-1624591156897)(media/49e1da59dd72c1debc455ff16f14d4d7.png)] [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mQfQcc0m-1624591156898)(media/1ca30a536f4fd78dcc66ae0a60ba50c5.png)] Ctrl-z后运行ps可以看出，hello并未被回收，而是被挂在了后台，jobs显示hello进程已停止，由于pstree太长，此处知识截了一部分的图。运行fg命令，发现hello进程又一次来到了前台继续运行。再次Ctrl-z，然后运行命令kill-93827，即向hello进程发送SIGKILL信号杀死程序，再向用fg将hello调回前台运行时发现任务已被杀死。 Ctrl-C：输入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况是终止前台作业，如下截图所示，用ps查看前台进程组发现没有hello进程信息。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-i1s8fWHN-1624591156898)(media/a508dadeff093ee25e7fc043568e8e8c.png)] 6.7本章小结 本章阐述进程的概念与作用，同时介绍了shell对命令的一般处理流程和shell的作用，着重分析了调用fork创建新进程，调用execve函数加载并执行hello，hello进程的执行，以及hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：指由程式产生的和段相关的偏移地址部分。例如，在进行C语言指针编程中，能读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，他是相对于你当前进程数据段的地址，与绝对物理地址不相关。只有在Intel实模式下，逻辑地址才和物理地址相等（因为实模式没有分段或分页机制,Cpu不进行自动地址转换）；逻辑也就是在Intel保护模式下程式执行代码段限长内的偏移地址（假定代码段、数据段如果完全相同）。线性地址：是逻辑地址到物理地址变换之间的中间层。程式代码会产生逻辑地址，或说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。虚拟地址：指由程序产生的由段选择符和段内偏移地址组成的地址，实际上就是线性地址；物理地址：用于内存芯片级的单元寻址，与处理器和CPU链接的地址总线相对应。可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部份组成，段标识符:段内偏移量。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aqytV7a0-1624591156899)(media/d513e506ac08ee67a57dc2f605be34a0.png)] 段式管理的特点： 段式管理以段为单位分配内存，每段分配一个连续的内存区；由于各段长度不等，所以这些存储区的大小不一；同一进程包含的各段之间不要求连续；段式管理的内存分配与释放在作业或进程的执行过程中动态进行。 逻辑地址转换为线性地址的一般步骤： 首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]； 看段选择符的T1=0还是1，判断当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，求其地址和大小，得到一个数组；拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，得到基地址base；base+偏移量就是要转换的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 虚拟寻址形式： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NpU0jjdO-1624591156900)(media/8c0c8ea87cd778cf9acfd241d2bb02ff.jpeg)] 虚拟页和物理页：虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘(较低层)上的数据被分割成块，这些块作为磁盘和主存(较高层)之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页(VirtualPage,VP)的大小固定的块来处理这个问题。每个虚拟页的大小为P=2p字节。类似地，物理内存被分割为物理页(PhysicalPage，PP)，大小也为P字节(物理页也被称为页帧(pageframe))。在任意时刻，虚拟页面的集合都分为三个不相交的子集：未分配的：VM系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间；缓存的：当前已缓存在物理内存中的已分配页；未缓存的：未缓存在物理内存中的已分配页。SRAM和DRAM：SRAM缓存表示位于CPU和主存之间的2高速缓存L1、L2和L3；DARRAM缓存表示虚拟内存系统的缓存，它在主存中缓存虚拟页。在存储层次结构中，DRAM缓存的位置对它的组织结构有很大的影响。DRAM比SRAM要慢大约10倍，而磁盘要比DRAM慢大约100000多倍。因此DRAM缓存中的不命中比起SRAM缓存中的不命中要昂贵得多，这是因为DRAM缓存不命中要由磁盘来服务，而SRAM缓存不命中通常是由基于DRAM的主存来服务的。因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是4KB~2MB。由于大的不命中处罚，DRAM缓存是全相联的，即任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的处罚也非常之高。页表：页表是一个存放在物理内存中的数据结构，页表将虚拟页映射到物理页，配合硬件确定虚拟页在磁盘中的位置。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。地址翻译：形式上来说，地址翻译是一个N元素的虚拟地址空间中的元素和一个M元素的物理地址空间中元素之间的映射。虚拟地址(VA)由VPN和VPO组成，其中VPO是虚拟页面偏移量，取值区间在0到2p-1,因此VPO为虚拟地址的低p位；VPN围殴虚拟页号，包含了TLB索引(TLBI)和TLB标记(TLBT)；物理地址(PA)由PPN和PPO组成，其中PPN为物理页号，PPO为物理页面偏移量。物理地址可以被分为CO、CI、CT，即缓冲块内的字节偏移量、缓存索引和缓存标记。由虚拟地址VPN中的TLBI和TLBT结合TLB表可以知道该次访存命中还是缺页，若命中则由TLB表可得PPN，而PPO与VPO相等，而PPN与PPO合在一起就构成了物理地址。若缺页，则引发缺页故障，从磁盘中将待访问页拿出来，用优良的替换算法进行页替换。 7.4TLB与四级页表支持下的VA到PA的变换 Corei7地址翻译的概况图 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TH7mKjLq-1624591156900)(media/651c663aecf6434a9c078e6622793a9b.jpeg)] 由上图不难得知，该虚拟地址共48位，其中前36位为VPN，后12位为VPO，TLB为16组级联，共64个条目，所以TLBI应为4位，TLBT位36-4等于32位。由于是四级页表，VPN可以分为VPN1~4，对应一到四级页表。地址翻译：基本与7.3.5中单页表中的地址翻译方式相同，此处不再重复。 7.5三级Cache支持下的物理内存访问 分析：由7.4中的概况图，因为有64组，所以组索引应有6位；每行64B，所以块偏移为6位；所以标记位为52-6-6=40位。物理访存过程：通过组索引选择相应的组；检查高速缓存是否命中，即该组中是否某一行的标记位与物理地址的标记位相同且该行的有效位为1；若命中，则通过块偏移找到返回的缓存字节；若未命中，则需要从存储层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位所指示的组中的一个高速缓存行中。一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置；否则组内都是有效块，产生冲突，最好采用最近最少使用策略LFU进行替换。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了当前进程的mn_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在hello进程中返回时，hello现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并运行包含在可执行目标文件hello.out中的程序，用hello.out程序有效地替代了当前程序。加载并运行hello.out需要以下几个步骤： 删除已存在的用户区域，即删除当前进程虚拟地址的用户部分中的已存在的区域结构；映射私有区域，即为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello.out文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello.out中。栈和堆地址也是请求二进制零的，初始长度为零；映射共享区域，即hello程序与共享对象标准C库libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内；设置程序计数器（PC），即设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 某指令引用的某字并未缓存在DRAM中；地址翻译硬件从内存中读取该字,并且触发一个缺页异常；缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，；如果牺牲页已经被修改过，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改牺牲页的页表条目，反映出该页不再缓存在主存中这一事实；内核从磁盘复制待缓存的页到内存中牺牲页的物理地址，更新PTE，随后返回；重新启动导致缺页的命令，该命令会把导致缺页的虚拟地址重发送到地址翻译硬件；当指令再次执行时，相应的物理页面已经驻留在内存中，页命中，因此指令可以没有故障的运行完成。 7.9动态存储分配管理 动态内存分配器的基本原理 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Hlo5E8uJ-1624591156901)(media/c377ec21fdb980d57f2570f4d4bbbce1.jpeg)]动态内存分配器维护着一个进程的虚报内存区域，移为地(heap)。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长(向更高的地址)。对于每个进程，内核维护着一个变量brk(读做“break”)，它指向堆的顶部。 分配器将堆视为一组不同大小的块(block)的集合来维护，每个块就是一个连续的虚摇内存片(chunk)，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用、空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格，两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器(explicitallocator)，要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过谓用malloc函数来分配一个块，并通过调用free函数来释放一个块，C++中的new和delete操作符与C中的malloc和free相当。 隐式分配器(implicitallocator)，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器(garbagecollector)，而自动释放未使用的已分配的块的过程叫做垃圾收集(garbagecollection)。例如，诸如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 带边界标签的隐式空闲链表分配器 隐式空闲链表区别块的边界、已分配块和空闲块的方法如图所示： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xdInLrb9-1624591156901)(media/4e2c991c761f5a3ce6242e10d627b44f.jpeg)] 这种情况下，一个块是由一个字的头部、有效载荷，以及可能的填充组成。头部编码了这个块的大小(包括头部和所有的填充),以及这个块是已分配的还是空闲的。块的头最后一位指明这个块是已分配的还是空闲的。 头部后面是应用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。块的格式如图所示，空闲块通过头部块的大小字段隐含的连接着，所以我们称这种结构就隐式空闲链表。 放置已分配的块 当一个应用请求一个k字节的块时，分配器搜索空闲链表。查找一个足够大可以放置所请求的空闲块。分配器搜索方式的常见策略是首次适配、下一次适配和最佳适配。 分割空闲块 一旦分配器找到一个匹配的空闲块，就必须做一个另策决定，那就是分配这个块多少空间。分配器通常将空闲块分割为两部分。第一部分变为了已分配块，第二部分变为了空闲块。如图所示。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ROCqwgTR-1624591156902)(media/d76de44948cd2b3038d346220b868188.jpeg)] 获取额外堆内存 如果分配器不能为请求块找到空闲块，一个选择是合并那些在物理内存上相邻的空闲块，如果这样还不能生成一个足够大的块，分配器会调用sbrk函数，向内核请求额外的内存。 合并空闲块 合并的情况一共分为四种：前空后不空，前不空后空，前后都空，前后都不空。对于四种情况分别进行空闲块合并，我们只需要通过改变头部的信息就能完成合并空闲块。Knuth提出了一种采用边界标记的技术快速完成空闲块的合并。如图所示。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EU5StDV2-1624591156902)(media/886f30c2dc04b93916698856027e231c.jpeg)] 显式空间链表的基本原理 隐式空闲链表为我们提供了一种介绍一些基本分配器概念的简单方法。然而，因为块分配与堆块的总数呈线性关系，所以对于通用的分配器，隐式空闲链表是不适合的(尽管对于堆块数量预先就知道是很小的特殊的分配器来说它是可以的)。 一种更好的方法是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred(前驱)和succ(后继)指针，如图所示。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XUzPDus0-1624591156903)(media/0d5972340b7bf7493cba8ee7ccc0b35c.jpeg)] 使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略。 一种方法是用后进先出(LIFO)的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 动态分区分配策略最先匹配：分配n个字节，使用第一个可用空间比n大的空闲区。 原理：空闲分区列表按照地址顺序排序；分配过程中，搜索第一个适合的分区；释放分区时，检查是否可与临近的空闲分区合并； 优点：简单；在高地址空间有大块的空闲分区； 缺点：外部碎片；分配大块使较慢。 最佳匹配：分配n个字节时，查找并使用不小于n的最小空闲分区。 原理：空闲分区列表按照大小排序；分配时，查找一个合适的分区；释放时，查找并且合并临近的空闲分区； 优点：避免大的空闲分区被拆分；可减小外部碎片的大小； 缺点：外部碎片；释放分区较慢；容易产生很多无用的小碎片 最差匹配；分配n个字节时，查找并使用不小于n的最大空闲分区。 原理：空闲分区列表按照从大到小排序；分配时，选最大的分区；释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序； 优点：中等大小的分配较多时，分配效果最好；避免出现太多的小碎片； 缺点：释放分区较慢；外部碎片；容易破坏大的空闲分区，因此后续难以分到大的分区 7.10本章小结 本章主要介绍了hello.out的存储器的地址空间，介绍了四种地址空间的概念和地址的相互转换。同时介绍了hello.out的四级页表的虚拟地址空间到物理地址的转换、三级cashe的物理内存访问、进程fork、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理等相关知识。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行，这就是UnixI/O接口。 8.2简述UnixIO接口及其函数 UnixI/O接口的统一输入输出方式： 打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访间一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符；Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO、STOOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值；改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k,初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k；读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k；关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O接口函数： intopen(char*filename,intflags,mode_tmode);函数功能：open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符；函数参数：filename：要打开的文件名；flags：指明进程将如何访问这个文件；mode：指定新文件的访问权限位；intclose(intfd);函数功能：关闭一个打开的文件，返回操作结果； 函数参数： fd：要关闭的文件的描述符； ssize_tread(intfd,void*buf,size_tn);函数功能：read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF，否则返回值表示的是实际传送的字节数量； 函数参数： fd：要读的文件的描述符； buf：将要读入到的内存位置； n：复制字节上限； ssize_twirte(intfd,constvoid*buf,size_tn);函数功能：从内存位置buf复制至多n个字节到描述符为fd的当前文件位置； 函数参数： fd：要读的文件的描述符； buf：将要读入到的内存位置； n：复制字节上限； 8.3printf的实现分析 printf的函数体： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-baHeOfAb-1624591156903)(media/44d8c86b550e633eacb1e6b7885b4053.png)] printf函数的内容： 首先将第一个参数入栈，然后调用vsprint函数，该函数作用为格式化输出字符串，返回值为要打印的字符串长度i。再调用write函数，将i位字符串写入终端，将栈中参数放入寄存器。intINT_VECTOR_SYS_CALLA代表通过系统调用syscall，该函数功能是不断打印出字符。字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。于是字符串被打印到了屏幕上。 【补】vsprint函数： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Xi9NBFWA-1624591156904)(media/9650c78a154fcc2334b50ff5eb9846eb.png)] sys_call的实现： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J5uL5lMn-1624591156904)(media/9d1b1859ed232e957a9a0b97babcfa49.png)] 8.4getchar的实现分析 异步异常-键盘中断的处理：当用户按键时，键盘接口会得到一个代表该按键的键盘扫描码，同时产生一个中断请求，中断请求抢占当前进程运行键盘中断子程序，键盘中断子程序先从键盘接口取得该按键的扫描码，然后将该按键扫描码转换成ASCII码，保存到系统的键盘缓冲区之中。getchar函数返回原理：当程序调用getchar()时，程序就等着用户按键。用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止(回车字符也放在缓冲区中)。当用户键入回车之后，getchar()才开始调用read系统函数，从输入流中每次读入一个字符。getchar()函数的返回值是用户输入的第一个字符的ASCII码,如出错返回EOF。如用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中，待后续getchar()调用读取。也就是说，后续的getchar()调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完为后，才等待用户按键。getchar函数作用：从标准输入流只读取一个字符(包括空格、回车、tab)，读到回车符(’\n’)时退出，键盘输入的字符都存到缓冲区内，一旦键入回车，getchar就进入缓冲区读取字符，一次只返回第一个字符作为getchar函数的值；如果有循环或足够多的getchar语句，就会依次读出缓冲区内的所有字符直到’\n’。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法、UnixIO接口及其函数，并且分析了printf函数和getchar函数的实现。 结论 首先程序员编写hello.c文件；下面分析hello.c在计算机中的历程： hello.c文件首先经历的是来自cpp的预处理，生成hello.i；hello.i将经历来自ccl的编译，生成hello.s；hello.s将经历as的翻译，生成一定格式的机器码文件hello.o；经过ld的链接，形成了可执行文件hello.out；在在shell中键入运行命令./hello.out1190200828赵英帅；因为输入的不是shell的内置命令，所以为其fork产生一个子进程，然后hello便从程序变为了进程；调用execve函数加载运行hello.out，映射虚拟内存，开始载入物理内存，进入main函数；当hello程序执行printf函数时，会调用malloc向动态内存分配器申请堆中的内存；打印完成后，hello调用sleep函数之后进程陷入内核模式，处理休眠请求主动释放当前进程，内核进行上下文切换将当前进程的控制权交给其他进程，2秒后休眠结束，内核执行上下文切换将控制传递给hello进程；若无输入信号干扰，8、9将重复执行10次；若输入CtrlZ，内核会发送SIGTSTP信号给hello进程，使之停止前台作业并挂起，后续执行fg将使之再次成为前台程序，继续执行；若输入CtrlC，内核会发送SIGINT信号给进程并终止hello进程；输入为其他字符时，第一次回车后再输入的字符将在hello进程运行结束后被当作命令行输入进行解释；当hello进程执行完成时，内核安排父进程回收hello进程，并将hello进程的退出状态传递给父进程。 hello程序短暂的一生就此结束啦！ 完结撒花！ 附件 文件名文件作用hello.ihello.c经过预处理得到的文本文件hello.shello.i编译生成的汇编文件hello.ohello.s经过汇编生成的可重定位目标文件hello.txthello.o反汇编后生成的汇编语言文本文件hello.out链接后生成的可执行文件asm.shello.o反汇编后生成的汇编语言文本文件 参考文献 [1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp.内核模式，处理休眠请求主动释放当前进程，内核进行上下文切换将当前进程的控制权交给其他进程，2秒后休眠结束，内核执行上下文切换将控制传递给hello进程； 若无输入信号干扰，8、9将重复执行10次；若输入CtrlZ，内核会发送SIGTSTP信号给hello进程，使之停止前台作业并挂起，后续执行fg将使之再次成为前台程序，继续执行；若输入CtrlC，内核会发送SIGINT信号给进程并终止hello进程；输入为其他字符时，第一次回车后再输入的字符将在hello进程运行结束后被当作命令行输入进行解释；当hello进程执行完成时，内核安排父进程回收hello进程，并将hello进程的退出状态传递给父进程。 hello程序短暂的一生就此结束啦！ 完结撒花！ 附件 文件名文件作用hello.ihello.c经过预处理得到的文本文件hello.shello.i编译生成的汇编文件hello.ohello.s经过汇编生成的可重定位目标文件hello.txthello.o反汇编后生成的汇编语言文本文件hello.out链接后生成的可执行文件asm.shello.o反汇编后生成的汇编语言文本文件 参考文献 [1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 

FirstBlog 没有什么内容，用来测试一下 

CSAPP程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机 学 号 1190200913 班 级 1936602 学 生 林煜鹏 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文简述了一个c文件从源文件到程序，再到进程，最后被回收的全流程。其中，c文件通过预处理，编译，汇编，链接，最后生成可执行程序。而可执行程序通过shell创建和运行，成为一个进程。进程在经过存储管理和IO管理后，顺利运行，并最终被回收。本文就对这些过程进行一一详述。 关键词：CSAPP；编译；缓存；进程；系统流程； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 P2P:hello.c源文件在cpp,ccl,as,ld的作用下，经过预处理 编译 汇编 链接这四个步骤生成一个名为hello的可执行文件。最终在shell中新建进程运行。这就是所谓fromProgramtoProcess(P2P)。 020：hello进程从不存在开始，在shell的作用下通过execve在fork产生的子进程中生成hello，为hello的代码、数据、bss和栈映射虚拟内存。在hello开始运行时分配并载入物理内存，cpu为hello分配时间片并执行逻辑控制流，UNIXI/O管理输入输出，最终hello进程结束，shell回收其内存空间，hello不复存在。这就是所谓的fromZero-0toZero-0(020) 1.2环境与工具 硬件环境：CPU:IntelCorei7-10870H；32GDDR43200hzRAM；2TBSSDDisk 软件环境：MicrosoftWindows10Home64位；VMwareWorkstaion15.5Pro;Ubuntu18.04 开发工具gcc readelf edb wxHexeditor codeblocks 1.3中间结果 文件名称作用hello.c源代码文件hello.i经过预处理得到的C语言文件hello.s经过编译得到的汇编文件hello.0经过汇编之后的可重定位目标执行文件hello经过链接之后的可执行文件 1.4本章小结 本章主要介绍了什么是P2P、020，以及hello的P2P、020过程，给出了本次实验的软硬件信息和开发工具，以及文件的中间结果 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 2.1.1何为预处理 预处理即在编译驱动程序处理程序源代码，使之转化为目标程序的过程中，首先执行的行为。预处理将源代码分割或处理成为特定的单位，用来支持语言特性。在C、C++语言中，预处理会对源代码文件中以字符#开头的代码行进行处理。 2.1.2预处理的作用 具体处理内容包括宏定义、源文件包含、条件编译、行控制、错误指令等。预处理指令一般被用来使源代码在不同的执行环境中被方便的修改或者编译。 预处理指令主要有以下4类 宏定义指令 如#defineNameTokenString，#undef等。对于前一个预处理指令，预处理所要做的是将程序中的所有名为Name的字符用TokenString替换，但作为字符串常量的Name则不被替换。对于后者，则将取消对某个宏的定义，使以后该串的出现不再被替换。 条件编译指令 如#ifdef，#ifndef，#else，#elif，#endif,等等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉 源文件包含指令 如#include"FileName"或者#include等。在头文件中一般用伪指令#define定义了大量的宏(最常见的是字符常量)，同时包含有各种外部符号的声明。采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用。因为在需要用到这些定义的C源程序中，只需加上一条#include语句即可，而不必再在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。 包含到c源程序中的头文件可以是系统提供的，这些头文件一般被放在/usr/include目录下。在程序中#include它们要使用尖括号(<>)。另外开发人员也可以定义自己的头文件，这些文件一般与c源程序放在同一目录下，此时在#include中要用双引号("")。 特殊符号 预编译程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号(十进制数)，FILE则被解释为当前被编译的.C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。 预编译程序所完成的基本上是对源程序的“替换”工作。经过此种替换，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。这个文件的含义同没有经过预处理的源文件是相同的，但内容有所不同。下一步，此输出文件将作为编译程序的输出而被翻译成为机器指令。 2.2在Ubuntu下预处理的命令 gcc-Ehello.c-ohello.i 图2.1预处理前 图2.2预处理后 2.3Hello的预处理结果解析 预处理之后，我们打开两个文件，查看内部内容 图2.3预处理后文件内容比较 通过比较我们可以发现，经过预处理后，#include指令消失，被头文件内容代替，并且//注释也消失了。可以看到main函数部分没有变化，说明预处理只是简单的替换和删除，并没有真正开始程序的编译等过程。 2.4本章小结 预处理过程是计算机对源程序进行操作的第一步，在这个过程中预处理器（cpp）会对hello.c文件进行初步的处理，对头文件、宏定义和注释进行操作，将程序中涉及到的库中的代码补充到程序中，将注释这个对于执行没有用的部分删除，最后将初步处理完成的文本保存在hello.i中，方便以后的编译过程。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 3.1.1编译的概念 编译阶段是在预处理之后的下一个阶段，在预处理阶段过后，我们获得了一个hello.i文件，编译阶段就是编译器（ccl）对hello.i文件进行处理的过程。此阶段编译器会完成对代码的语法和语义的分析，生成汇编代码，并将这个代码保存在hello.s文件中。 3.1.2编译的作用 代码在编译阶段会进行语法的检查。如果出现语法错误，则会编译失败。如 果语法不存在问题，编译器会将代码转换为汇编代码。 3.2在Ubuntu下编译的命令 gcc-Shello.i-ohello.s 图3.1编译前 图3.2编译后 3.3Hello的编译结果解析 3.3.1数据 （1）全局变量 查看源代码，可以知道我们的全局变量是int类型，标识符为sleepsecs 图3.3源代码的全局变量 查看汇编代码 图3.4汇编代码中的全局变量定义 可以看出，汇编代码中.globl代表的是全局变量，.type说明这个是一个数据，而.size表示其占有的字节大小，为4个字节。 （2）局部变量 查看源代码，可知我们定义了一个局部变量inti 查看汇编代码，我们并没有发现inti的定义，但是在赋值部分可以看到i 影子，这个下一部分讨论 3.3.2赋值 我们观察源代码可知，在最初定义全局变量的时候就进行了赋值 查看汇编代码，赋值语句是这样的形式 图3.5汇编代码中全局变量的赋值 可以看见有三行，第一行声明了变量名称sleepsecs，第二行为变量的值，第三行为储存的位置，由代码可知为.rodata节。 我们可以看出，当时赋值语句是将2.5赋值给这个变量，但是他保存的值却是2，这其中实际上发生了一次隐式类型转换，这个下一部分讨论 我们观察局部变量的赋值 图3.6汇编代码中局部变量的赋值 可以看出，局部变量是存储在栈中的，需要使用的时候，通过mov指令进行赋值 3.3.3类型转换 上节指出，sleepersec赋值时发生了隐式的类型转换。这是由于sleepersec是int型，而赋值的数据为2.5，为float型，因此自动发生了类型转换。查看代码我们可以看到，这一步是直接赋值为2，而没有其他特殊的操作。 3.3.4算数运算 源代码中只出现了一次算数操作，即i++。 在汇编代码中是这样显示的 图3.7汇编代码中算数操作 3.3.5关系操作 两个关系操作，阅读源代码可知，一个为不等于操作，另一个为小于操作 图3.8关系操作 这里我们可以看出，无论是哪种关系操作，在汇编代码中都是使用cmp进行比较，比较之后设定条件码，为之后的条件跳转打下基础 3.3.6控制转移 我们知道，在c语言中的逻辑结构，如循环，条件判断等，转换为汇编语言后就变成了控制转移。 控制转移主要通过jX指令执行，其中X为条件，即上一节谈到的条件码。当条件码满足跳转条件时，就会进行跳转。 jX指令有11条，条件类型有无条件，是否相等，是否为负，是否大于（等于），是否小于，并且有符号数和无符合数的跳转指令略有区别。 在hello.s中，有if语句的控制转移和循环体的控制转移，我们分别分析 if语句 图3.9if语句的控制转移 我们可以简单看出，在使用cmpl比较了3和argc之后，进行了一个条件跳转，若相等则跳转到L2（if语块之后），即不运行je之后的语句而直接跳转到循环体部分。因此，这个比较和跳转即为if语句转换为汇编代码的形态。 循环体 图3.10循环体的控制转移 分析代码可以看出，先进行了一个赋值操作（即i=0），然后无条件跳转到L3部分。L3部分将i和9进行对比，若i<=9，则跳转到L4，每次运行完成L4的部分时，i都会加1，然后再与9比较大小。与源代码对比，可以很清楚看出这个部分就是原来的循环体。因此，循环体转换为汇编代码时，会先进行一个无条件跳转到循环体的退出部分进行条件判断，若满足条件则正常退出，若不满足则跳转回循环体的开头执行指令，在执行完所有指令后进行自加一（或者其他操作改变值），然后再进行条件判断，以此反复直到完成循环。 3.3.7数组/指针/结构操作 阅读源代码，可以知道我们调用了argv[]里面的元素。对比汇编代码，我们可以看出汇编代码中已经没有数组、结构等概念，只存在地址和地址指向的值。对于数组的储存，在汇编中我们只保存了其起始地址，即argv[0]的地址，由于数组的储存是连续的地址，若要访问数组中其他元素只需要起始地址加上偏移量即可。 图3.11数组操作 分析代码，我们可以知道%rbp-32储存的是argv[0]的地址，由于argv[]是char*型，因此一个元素占8字节。先将argv[0]的地址赋给%rax，然后再将%rax加16，我们可以知道，此时的%rax中储存的是argv[2]的地址，下面类似的调用了argv[1]的地址，并将它们分别赋值给了%rdx和%rsi，在下一节中我们会清楚这些寄存器是用来做什么的 3.3.8函数操作 源代码中存在多个函数和函数调用。包括main函数，printf函数，exit函数，sleep函数，getchar函数，我们仅分析比较复杂的main函数，printf函数 首先我们先说明一下函数调用的过程。 （1）在调用者角度，我们需要向被调用函数传递参数，唤出被调用函数，然后接收返回值。对于传参操作，在参数比较少的情况，就直接存储在特定寄存器中，如%rdi，%rsi，%rdx，%rcx就分别用来存储第一至四个参数。X86的及其一共为我们提供了6个寄存器来保存参数。如果参数多于6个，那么就只能放在栈中保存了。传递参数完成后，我们使用call命令调用函数。call指令的操作原理是将call之后下一条指令的地址压入栈中，然后将被调用函数的首地址压入%rip中，从而达到调用的目的。调用完成后，返回值会储存在%rax中 （2）在被调用者角度，首先需要先将原先的栈底%rbp压栈，然后把原先栈顶%rsp的地址存入栈底%rbp中。这个操作的目的是保存原先被调用者的状态，并且方便在调用完成之后恢复到原先的状态。之后%rsp会减去一定数量的字节，这个步骤即为新内容分配空间（当前栈帧），然后将参数依次压入栈中，排序越靠前的参数，其压入栈的地址越高。之后执行完成后会先使用leave指令，让被调用者的状态返回到被调用前。leave指令的具体操作是将%rbp的值赋值回%rsp，然后将原%rbp弹出，以达到恢复的效果。然后最后使用ret指令，将返回地址弹出并压入%rip中，继续执行原指令。 汇编代码分析 （1）main函数 图3.12被调用函数的初始化 main函数开始运行时，进行的保存原寄存器值，分配栈帧，保存局部变量的操作。.cfi代码是debug使用的，我们分析时可以无视。观察代码，我们可以很明显的看出，main函数首先先将%rbp的原先值进行储存，然后对%rsp-32，分配了大小为32字节的栈帧空间。由于我们知道main函数有两个参数，即argc和argv[]，根据顺序分别保存在%rdi和%rsi中，之后的mov操作将这两个参数储存在栈中。初始化完成后开始正式运行 图3.13被调用函数的退出 main函数完成运行后，将返回值0压入%rax中，然后使用leave指令将保存的%rbp的值恢复，最后使用ret完成调用，释放栈帧，回到当初调用main的位置（即结束）。 （2）printf函数 图3.14调用函数前的初始化 这是第二次调用printf的时候，printf有三个参数：原来要输出的字符串（即"Hello%s%s\n"），argv[1],argv[2]。通过上面的代码我们可以清楚看出，参数按顺序存储在%rdi，%rsi，%rdx中，然后再使用call指令调用printf函数 3.4本章小结 本章我们主要介绍了编译器是如何将文本编译成汇编代码的。可以发现，编译器并不是死板的按照我们原来文本的顺序，逐条语句进行翻译下来的。编译器在编译的过程中，不时会对我们的代码做一些隐式的优化，而且会将原来代码中用到的跳转，循环等操作操作用控制转移等方法进行解析。最后生成我们需要的hello.s文件。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编器（as）将hello.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在hello.o中。这里的hello.o是一个二进制文件。 4.2在Ubuntu下汇编的命令 gcc-chello.s-ohello.o 图4.1通过汇编生成可重定位文件的过程 4.3可重定位目标elf格式 一般来说，elf文件的格式是这个样子的 图4.2ELF文件的通用结构 而由于可重定向目标文件和可执行文件的不同，我们阅读ELF文件中又存在两种不同的视图，分别是链接视图和执行视图 链接视图是以节（section）为单位，执行视图是以段（segment）为单位。链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。上图左侧的视角是从链接来看的，右侧的视角是执行来看的。总个文件可以分为四个部分： -ELFheader：描述整个文件的组织。 -ProgramHeaderTable:描述文件中的各种segments，用来告诉系统如何创建进程映像的。 -sections或者segments：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略programheadertable来处理此文件，在运行阶段可以忽略sectionheadertable来处理此程序（所以很多加固手段删除了sectionheadertable）。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。 -SectionHeaderTable:包含了文件各个section的属性信息。 图4.3两种不同视图的ELF阅读方式 由于我们的hello.o为可重定向目标文件，因此我们用链接视图阅读 使用指令readelf-ahello.o阅读hello.o的ELF文件 （1）ELFheader 图4.4ELF头的信息 第1行，ELFHeader:指名ELF文件头开始。 第2行，Magic魔数，用来指名该文件是一个ELF目标文件。第一个字节7F是固定的；后面的3个字节正是E,L,F三个字母的ASCII形式。之后的02表示的是文件类型，其中0为无效文件，1为ELF32位文件，2为ELF64位文件。接下去的01表示的是字节序，其中0为无效格式，1为小端序，2为大端序，再之后的01为ELF版本，再之后的字节没有定义，一般填零。用图可以表示如下 图4.5ELF魔数的构造 第3行，CLASS表示文件类型，这里是64位的ELF格式。 第4行，Data表示文件中的数据是按照什么格式组织(大端或小端)的，不同处理器平台数据组织格式可能就不同。 第5行，当前ELF文件头版本号，这里版本号为1。 第6行，OS/ABI，指出操作系统类型，ABI是ApplicationBinaryInterface的缩写。 第7行，ABI版本号，当前为0。 第8行，Type表示文件类型。ELF文件有3种类型，一种是如上所示的Relocatablefile可重定位目标文件，一种是可执行文件(Executable)，另外一种是共享库(SharedLibrary)。[这里就是区分上面三种类型的ELF文件] 第9行，机器平台类型，这里是在X86-64位机器。 第10行，当前目标文件的版本号。 第11行，程序的虚拟地址入口点，因为这还不是可运行的程序，故而这里为零。如果是可运行程序，这个地址并不是main函数的地址，而是_start函数的地址，_start由链接器创建，_start是为了初始化程序。 第12行，与11行同理，这个目标文件没有ProgramHeaders。 第13行，sections头开始的地址偏移，这里1320是十进制. 第14行，是一个与处理器相关联的标志，x86平台上该处为0。 第15行，ELF文件头的字节数。64bytes 第16行，因为这个不是可执行程序，故此处大小为0。 第17行，同理于第16行。 第18行，sectionsheader的大小，这里每个section头大小为64bytes。 第19行，一共有多少个section头，这里是14个。 第20行，section头字符串表索引表（.strtab）。表中存储的信息是用来链接使用的，主要包括：程序代码、程序数据（变量）、重定向信息等。比如：.text保存的是代码，.data保存的是初始化或未初始化的数据，等等。 （2）节头部表（sectionsheader） 图4.6节头部表 .text：已编译程序的机器代码。.rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。.data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。.bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。.rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。.common：现代编译器用.COMMON和.bss来更细化的区分这些变量，将未初始化的全局变量分配至.COMMON中。.eh_frame&.rela.eh_frame：gcc编译的过程中用于处理异常的部分.symtab：一个符号表（symboltable），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。.shstrtab：此节区包含节区名称。 （3）重定位节 图4.7重定位节 接下来可以看到.text节重定位的信息。重定位节中包括所有需要重定位的符号的信息，包括偏移量、信息、类型、符号值和符号名称+加数。当链接器把这个可重定位目标文件与其他文件相结合时，需要修改这些符号的位置。 其中，这些符号有两种类型。第一种类型为R_X86_64_PC32，表示重定位PC相对引用。链接器首先计算出引用的运行时地址，refaddr=ADDR(.text)+偏移量，然后更新该引用，使得它在运行时指向符号。这里的加数就是r.append,偏移量就是r.offset。故*refptr=ADDR（运行时地址）+r.append-refaddr，因此PC的值为PC+refptr，之后CPU调用call指令。 第二种类型为R_X86_64_PLT32，为位置无关代码，即无需重定位的代码。 另外，还有一种类型在这里没有显示，R_X86_64_32，表示重定位PC绝对引用。地址计算为fefptr=ADDR(运行时地址)+r.append 在.rela.text表之后是.rela.eh_frame，保存eh_frame的重定位信息。 （4）符号表.symtab 图4.8符号表 接下来我们可以看到.symtab表，记录了hello.c中调用的函数和全局变量的的名称，类型，地址等信息。 value地址信息，在可重定位文件中是起始位置的偏移量。 size表示符号的尺寸大小。例如main符号代表的就是main函数代码的总体大小 type为符号的定义，如object表示数据，func表示函数，notype表示暂未定义 bind表示符号是全局的还是本地的。 ndx表示每个符号表项与其他节区的关系，代表的就是此成员所在的节区的头部表索引，UND表示为在本文件中定义的符号。 4.4Hello.o的结果解析 objdump-d-rhello.o 图4.9反汇编代码 机器语言的构成 机器语言是计算机能直接识别的二进制代码，在hello.o的反汇编文件中，使用16进制表示机器代码，每个字节使用两个16进制数表示 机器语言和汇编语言的映射关系 汇编语言的每一条语句由机器语言中多个字节表示，而每一组特定的字节都可以翻译会汇编语言。 操作数 hello.s中使用十进制表示操作数，而反汇编语言中使用16进制表示操作数 函数调用 hello.s中函数调用只需使用call+函数名的方式即可，但是经过汇编后可以看出，链接器为每个函数调用找到了匹配的可执行代码的地址，并且需要经过重定位确定最后的实践地址。 分支转移 hello.s中的跳转指令是类似jX.L1的格式，其中.L1是标签，指代了某一句指令的位置。而经过汇编后，跳转指令是直接跳转到某个地址，可以是具体的地址，也可以是相对的地址。 4.5本章小结 本章中我们汇编了hello.s，将其转换为可重定位目标文件，并具体分析了可重定位文件的ELF格式和具体内容。并且反汇编了可重定位目标文件，并将其与原先的汇编代码进行对比。 通过这章，我们了解到汇编器将汇编代码处理成机器可以看懂的机器码，也就是二进制代码。二进制代码较汇编代码来说，虽然可读性变得比较差，但是在执行效率方面有了非常大的提升，汇编代码虽然已经在原来的文本的基础上进行了优化，但是还是存在着一些字符等不能够直接处理的数据。但是二进制代码中，已经将所有的指令、函数名字等量变成了相应的存储地址，这样机器就可以直接读取这些代码并执行。所以总的来说hello.o已经非常接近一个机器可以执行的代码了。 （第4章1分） 第5章链接 5.1链接的概念与作用 5.1.1链接的概念 链接是通过链接器（ld）将各种代码和数据片断收集并组合成一个单一文件的过程。这个文件可以被加载（复制）到内存并执行。链接包含符号解析和重定位两步。链接器将每个符号引用与符号的定义相关联，将符号在可重定位文件的位置重定位至可执行文件的位置。 5.1.2链接的作用 因为有了链接这个概念的存在，所以我们的代码才会变得比较方便和简洁，同时可移植性强，模块化程度比较高。因为链接的过程可以使我们将程序封装成很多的模块，我们在编程的过程中只需要考虑主程序的部分，对于其他的外部函数我们可以直接调用模块，就像C中调用printf一样。 同时我们可以将一个大型的应用程序分解成更小、更好管理的模块，可以独立地修改和编译这些模块，当我们改变这些模块中的一个时，只需要简单地重新编译，并重新链接应用，而不必重新编译其他文件。 5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1经过链接之后的可执行文件hello 5.3可执行目标文件hello的格式 总体的来说，ELF内部结构发生了一定的变化，链接完成后，ELF中多了程序头部表，这个是用来记录有哪些段（segments）的，多了不少的section和表，接下来我们依次说明 ELF头 图5.2可执行程序的ELF头 与上一章的ELF头相比，最大的变化发生在ELF类型，可以看到ELF类型已经变成可执行文件。同时我们发现相比与之前多了程序头，段数目，节的数量也有增加。同时入口点位置也不是虚拟地址0x0了，现在的入口地址是一个真实的物理地址 节头 图5.3可执行程序的节头表 多了几个节，我们来简单介绍一下 .interp：用于保存动态链接器的绝对地址，如/lib/ld-linux.so.hash：使用哈希技术存储的符号表，方便快速查找.dynsym：动态链接符号表.dynstr：动态链接字符串表，存放着所有符号名称的字符串，与.shstrtab类似.init：初始化信息，包括_start的地址，可以通过_start进入main函数.got：全局偏移量表，用来支持位置无关代码（PIC，PositionIndependentCode），存储的是所有引用的符号的地址，以实现对这些符号的间接访问。.plt.got：过程链接表，用来支持所引用函数的延迟绑定（即只有当该函数被第一次调用时才确定它的实际地址）.dynamic：动态链接信息表 程序头 图5.4程序头和段-节映射表 可以看到，此时的程序已经分配了真实的物理地址，因而可以运行 同时我们看到，多个节映射到一个段内。 动态链接信息表 图5.5动态链接信息表 动态链接信息表的数据结构非常简单，一个成员表示类型，另一个成员表示该类型的值（整数或地址） 重定位节 图5.6重定位节 .rel.dyn和.rel.plt是动态定位辅助段。由连接器产生，存在于可执行文件或者动态库文件内。借助这两个辅助段可以动态修改对应.got和.got.plt段，从而实现运行时重定位。 .rel.dyn：重定位的地方在.got段内。主要是针对外部数据变量符号。例如全局数据。重定位在程序运行时定位，一般是在.init段内。定位过程：获得符号对应value后，根据rel.dyn表中对应的offset，修改.got表对应位置的value。另外，.rel.dyn含义是指和dyn有关，一般是指在程序运行时候，动态加载。区别于rel.plt，rel.plt是指和plt相关，具体是指在某个函数被调用时候加载。我个人理解这个Section的作用是，在重定位过程中，动态链接器根据r_offset找到.got对应表项，来完成对.got表项值的修改。 .rel.plt：重定位的地方在.got.plt段内（注意也是.got内,具体区分而已）。主要是针对外部函数符号。一般是函数首次被调用时候重定位。首次调用时会重定位函数地址，把最终函数地址放到.got内，以后读取该.got就直接得到最终函数地址。我个人理解这个Section的作用是，在重定位过程中，动态链接器根据r_offset找到.got对应表项，来完成对.got表项值的修改。 动态符号表 图5.7动态符号表 符号表 图5.8符号表（部分） 5.4hello的虚拟地址空间 用edb打开hello，使用symbolview查看虚拟地址各段信息 图5.9动态库各段的虚拟地址 我们查看与节头表类似的部分 图5.10 与5.3的节头表对比，我们可以发现，基本每个节都被展开了，实际运行时占用内存更多，并且多了不少重定位之后的的外部函数地址。 5.5链接的重定位过程分析 图5.11可执行文件的反汇编代码 hello与hello.o相比，还是有很大不同的。 可以看到，在hello.o的反汇编代码中，只有一个main函数，但是对于hello的反汇编代码来说，可以看到很多如_init样子的函数。这些函数都是在链接的过程中，被加载到可执行文件中的。 同时，地址发生了很大的改变。链接之前，.o文件中main函数的反汇编代码从地址0开始往下，可以认为是相对偏移地址，而在链接之后，在main函数之前还链接上了其他的库文件，因此hello的main函数是从地址0x401105开始的，这时，在main函数中每一条指令的地址，每一个函数的地址都可认为是绝对地址，是CPU可以直接访问的地址。在hellomain函数中的绝对地址是通过可重定位文件中地址的偏移量加上起始地址得到的。 链接主要包括解析符号和重定位两步。在重定位之前，汇编器在hello.o文件的重定位段记录了需要重定位的符号和相应的类型和偏移量。链接器通过对符号的解析（包括局部符号和全局符号），将每个符号的引用和符号的定义相关联。这之后还需要将命令行输入的静态库链接，然后就开始重定位，在重定位过程中，将合并输入模块，并为每个符号分配运行时的地址。 首先需要对符号和节进行重定位。链接器将所有相同类型的节合并为同一类型的新的聚合节，然后链接器将运行时内存地址赋给新的聚合节，赋给定义的每个节和符号，此时程序中的每条指令和全局变量都有唯一的运行时内存地址。 然后重定位节中的符号引用，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。 5.6hello的执行流程 hello在执行的过程中一共要执行三个大的过程，分别是载入、执行和退出。 函数名阶段_dl_start加载_dl_init加载hello!start开始执行_libc_start_main开始执行_al_fixup开始执行_libc_csu_init开始执行_setjmp开始执行_main执行_printf执行_exit执行__sleep执行_getchar执行_dl_fixup退出exit退出 5.7Hello的动态链接分析 编译器在数据段开始的地方创建全局偏移量表（GOT），在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。 每个被可执行程序调用的库函数都有它自己的PTL条目，每个条目负责调用一个具体的函数。 查看dl_init运行前，.got.plt的值 .got.plt的起始地址是0x404000 在dl_init之前 图5.12 在dl_init之后 图5.13 5.8本章小结 链接的过程，是将原来的只保存了你写的函数的代码与代码用所用的库函数合并的一个过程。在这个过程中链接器会为每个符号、函数等信息重新分配虚拟内存地址，方法就是用每个.o文件中的重定位节与其它的节想配合，算出正确的地址。同时，将你会用到的库函数加载（复制）到可执行文件中。这些信息一同构成了一个完整的计算机可以运行的文件。链接让我们的程序做到了很好的模块化，我们只需要写我们的主要代码，对于读入、IO等操作，可以直接与封装的模块相链接，这样大大的简化了代码的书写难度。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程是一个执行中程序的实例，系统的每个程序都运行在某个进程的上下文中，上下文是由程序正确运行所需的状态组成的。包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 进程的作用：提供给应用程序一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器；提供给应用程序一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 shell是一个linux中提供的应用程序，他在操作系统中为用户与内核之间提供了一个交互的界面，用户可以通过这个界面访问操作系统的内核服务。他的处理流程如下： 从界面中读取用户的输入。将输入的内容转化成对应的参数。如果是内核命令就直接执行，否则就为其分配新的子进程继续运行。在运行期间，监控shell界面内是否有键盘输入的命令，如果有需要作出相应的反应 6.3Hello的fork进程创建过程 首先先来了解一下fork函数的机制。父进程通过调用fork函数创建一个新的子进程。新创建的子进程几乎但不完全与子进程相同。在创建子进程的过程中，内核会将父进程的代码、数据段、堆、共享库以及用户栈这些信息全部复制给子进程，同时子进程还可以读父进程打开的副本。唯一的不同就是他们的PID，这说明，虽然父进程与子进程所用到的信息几乎是完全相同的，但是这两个程序却是相互独立的，各自有自己独有的用户栈等信息。 fork函数虽然只会被调用一次，但是在返回的时候却有两次。在父进程中，fork函数返回子进程的PID；在子进程中，fork函数返回0。这就提供了一种用fork函数的返回值来区分父进程和子进程的方法。 同时fork在使用的过程中，有一个令人比较头疼的问题，就是父进程和子进程是并发执行的所以我们不能够准确的知道那个进程先执行或者先结束。这也就造成了每次执行的输出结果可能是不同的，也是不可预测的。 我们实际的执行一下，在命令行输入./hello1190200913lyp，shell检查该命令是否为内置命令，显然这不是内置命令。于是，shell调用fork函数创建一个新的子进程，子进程得到与父进程用户级虚拟地址空间相同的一份副本，这意味着父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大区别在于有不同的PID。 之后，更改进程组编号，准备hello的execve。 6.4Hello的execve过程 execve函数的作用是在当前进程的上下文中加载并运行一个新的程序。与fork函数不同的是，fork函数创建了一个新的进程来运行另一个程序，而execve直接在当前的进程中删除当前进程中现有的虚拟内存段，并穿件一组新的代码、数据、堆和用户栈的段。将栈和堆初始化为0，代码段与数据段初始化为可执行文件中的内容，最后将PC指向_start的地址。在CPU开始引用被映射的虚拟页的时候，内核才会将需要用到的数据从磁盘中放入内存中。 在shell新创建的子进程中，execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp，只有出现错误是，execve才会返回到调用程序。 在execve加载hello之后，调用启动代码来执行hello，新的代码和数据段初始化为可执行文件的内容，跳转到_start调用libc_start_main设置栈，并将控制传递给新程序的主函数， 6.5Hello的进程执行 在执行hello程序之后，hello进程一开始运行在用户模式，进程从用户模式变为内核模式的唯一方法是通过中断、故障等异常的调用，当进程处于内核模式时，可以访问任何内存位置，调用任何指令。当处理程序返回到应用程序代码时，从内核模式改为用户模式。 内核为每一个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态。包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构。 当内核选择一个新的进程运行时，即内核调度这个进程，内核使用上下文切换的机制来控制转移到新的进程：保存当前进程的上下文，恢复某个先前被强占的进程被保存的上下文，将控制传递给这个新恢复的进程。 在hello程序运行时，会有其他进程并发地运行，这些进程时间与hello重叠，为并发流，这些进程轮流运行，一个进程执行它的控制流的一部分的每一时间段叫做时间片。 接下来根据上述知识分析一下hello的进程调度。hello一开始运行在用户模式，内核保存一个上下文，继续运行调用printf函数，系统调用使得进程从用户模式变成内核模式，在printf函数执行完之后又返回到用户模式，继续运行调用sleep函数，此时会有些不同，由于该进程进行休眠，内核进行上下文切换，调用其他进程运行，同时计数器记录休眠的时间，等到休眠的时间到时，系统发生中断，再次进行上下文切换，转换到hello进程原先运行的位置。继续运行，遇到循环之后，hello进程会多次进行用户模式和内核模式的转变。之后调用getchar函数，进入内核模式，需要完成从键盘缓冲区到内存的数据传输，故上下文切换，运行其它进程，当数据传输结束，发生中断，再次上下文切换，回到hello进程，此时hello进程就运行结束了，return，hello进程运行终止。 6.6hello的异常与信号处理 hello的异常种类 中断 中断是异步发生的，是来自处理器外部的I/O设备的信号的结果，中断处理程序运行之后，返回到下一条指令。 陷阱和系统调用 陷阱是有意的异常，是执行一条指令的结果，就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令，在用户程序和内核之间提供一个像过程一样的接口，即系统调用。如读一个文件、创建一个进程、加载一个新的程序等。 故障 故障是由错误情况引起的，当故障发生时，将控制转移给故障处理程序，如果错误情况可以修正，则将控制返回到引起故障指令，重新执行，否则处理程序返回到内核abort，终止故障的应用程序。 终止 终止是不可恢复的致命错误造成的结果，会终止应用程序。 hello的信号 图6.1正常运行 可以看到在执行ps命令之后，程序后台并没有hello进程正在执行了，说明进程正常结束，已经被回收了。 在程序执行过程中，可以在命令行中乱按，包括回车，对于程序运行来说没有影响。 SIGTSTP信号 输入ctrl-z会发送一个SIGTSTP信号到前台进程组中的每个进程，默认情况下，停止（挂起）前台作业。 图6.2执行ctrl+z（挂起） 通过ps命令我们可以看到hello进程的pid，ctrl-z后hello进程被挂起，jobs命令看到hello进程的状态 图6.3通过pstree命令在进程树中找到bash的hello进程 使用fg将JID最大的放到前台，即继续运行hello 图6.4使用fg命令继续运行hello 使用kill-9PID杀死hello进程 图6.5使用kill命令终止hello进程 SIGINT信号 当用户输入ctrl-c时产生中断信号，导致内核发送一个SIGINT信号到前台工作组中的每个进程，默认终止前台作业，在这里，hello被终止。 图6.6使用ctrl+c终止hello进程 6.7本章小结 这一章介绍了hello可执行文件在进程中的执行过程。介绍了shell-bash的工作流程，shell利用fork和execve运行hello程序的过程，用户模式和内核模式，上下文的切换。最后，通过在命令行的各种命令的演示，讲述了hello进程的异常处理和信号机制。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：由程序产生的段偏移地址。由段标识和段偏移量组成。以段标识为下标到GDT/LDT查表获得段地址。段地址+端偏移量=线性地址 线性地址：一个非负整数地址的有序集合，如果此时地址是连续的，则称这个空间为线性地址空间。 虚拟地址：在保护模式下，程序运行在虚拟内存中。虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。虚拟地址由VPO（虚拟页面偏移量）、VPN（虚拟页号）、TLBI（TLB索引）、TLBT（TLB标记）组成。 物理地址：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每字节都有一个唯一的物理地址，比如第一个字节地址为0，第二个地址为1，以此类推。物理地址空间对应于系统中物理内存的M个字节：{0,1,2……M-1}。 在hello中，main函数的地址为0x401105，这是逻辑地址中的段偏移量，加上段地址就是main函数的虚拟地址，虚拟地址与物理地址之间存在一种映射关系，MMU利用页表实现这种映射，可得到实际的物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 实模式：逻辑地址CS:EA=EA+16*CS 保护模式：逻辑地址由段标识和段偏移量组成。以段标识为下标，去索引段描述符表，若T1=0，索引全局段描述符表（GDT），若T1=1，索引局部段描述符表（LDT）。将段描述符表中的段地址（base字段）加上段偏移量，即为线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 hello的线性地址到物理地址的变换，也就是从虚拟地址寻址物理地址，在虚拟地址和物理地址之间存在一种映射，MMU通过页表实现这种映射。 虚拟地址由虚拟页号（VPN）和虚拟页偏移量（VPO）组成，页表中由有效位和物理页号组成，VPN作为到页表的索引，去页表中寻找相应的PTE，其中PTE有三种情况，分别为已分配，未缓存，未分配。已分配表示已经将虚拟地址对应到物理地址，有效位为1，物理页号不为空。未缓存表示还未将虚拟内容缓存到物理页表中，有效位为0，物理页号不为空。未分配表示未建立映射关系，有效位为0，物理页号为空。 如果有效位为0，表示缺页，进行缺页处理，从磁盘读取物理页到内存，若有效位为1，则可以查询到相对应的PPN，物理页偏移量和VPO相同，PPN和PPO组成物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 首先介绍一下TLB。为减少内存读取数据的次数，在MMU中包括了一个关于PTE的小的缓存，即TLB，每一行都保存着一个由单个PTE组成的块。TLB索引由VPN的t个最低位组成，剩余的为为TLB标记。 其次我们来介绍一下多级页表的概念。在前面我们了解了一级页表是如何进行工作的。可以发现一级页表有一个弊端，就是对于每一个程序，内核都会给他分配一个固定大小的页表，这样有一些比较小的程序会用不到开出的页表的一些部分，就造成了空间的浪费，多级页表就很好的解决了这个问题。以二级页表为例，首先我们先开一个比较小的一级页表，我们将完整的页表分组，分别对应到开出来的一节页表的一个PTE中，在执行程序的过程中，如果我们用到了一个特定的页表，那么我们就在一级页表后面动态的开出来，如果没用到就不开，这样就大大的节省了空间。 CPU产生一个虚拟地址,当TLB命中时，MMU从TLB中取出相应的PTE，MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存中，高速缓存/主存将所请求的数据字返回给CPU。若TLB不命中，MMU必须从页表中的PTE取出PPN复制到PTE，而在得到PTE还会发生缺页或者是缓存不命中的情况。 7.5三级Cache支持下的物理内存访问 知道虚拟地址对应的物理地址之后，需要对物理地址进行访问。CPU访问物理地址是访问三级cacheL1、L2、L3。MMU将物理地址发送给L1缓存，从物理地址中得出CT（缓存标记）、CI（缓存组索引）、CO（缓存偏移）。根据缓存组索引找到L1缓存中对应的组，若缓存标记为1，根据缓存偏移直接从缓存中读取数据并返回。如果缓存标记为0，即缓存不命中，需要从L2、L3中去读取，如果在三级缓存中都不存在，需要到主存中读取。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本，它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello有效替代当前程序。加载并运行hello需要以下几个步骤： 删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 映射私有区域。为hello程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data段，bss是请求二进制零的，映射到匿名文件，大小包含在hello中，栈和堆也是请求二进制零的，初始长度为0。 映射共享区域。如果hello程序与共享对象链接，如libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 设置程序计数器。execve做的最后一件事就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时将从这个入口点开始执行。 7.8缺页故障与缺页中断处理 缺页现象的发生是由于页表只相当于磁盘的一个缓存，所以不可能保存磁盘中全部的信息，对于有些信息的查询就会出现查询失败的情况，也就是缺页。 对于一个访问虚拟内存的指令来说，如果发生了缺页现象，CPU就会触发一个缺页异常。缺页异常会调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果牺牲页已经被更改，那就先将其存回到磁盘中。 找到了要存储的页后，内核会从磁盘中将需要访问的内存，并且将PTE中的信息更新，这样就成功的将一个物理地址缓存在了页表中。当异常处理返回的时候，CPU会重新执行访问虚拟内存的操作，这个时候就可以正常的访问，不会发生缺页现象了。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆，分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 动态内存分配器分为显式分配器和隐式分配器两种。 7.9.1、带标签的隐式空闲链表 将堆组织为一个连续的已分配块和空闲块的序列的结构是隐式空闲链表，空闲块通过头部的大小字段隐含地链接。而带边界标签的隐式空闲链表则在每个块的结尾处添加一个脚部 头部的副本，脚部总是在距当前块开始位置一个字的距离。分配器可以通过检查它的脚部，判断前面一个块的起始位置和状态。 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以防止所请求块的空闲块。这种搜索方式由放置策略确定，包括首次适配、下一次适配和最佳适配。 一旦分配器找到匹配的空闲块之后，作出另一个决定 分配这个空闲块多少空间。通常选择将空闲块分割成两个部分，剩下的一部分变成新的空闲块。 当分配器释放一个已分配块之时，可能有其他空闲块与新释放的空闲块相邻，可能会导致假碎片问题，因此需要合并相邻的空闲块。而带有边界标签的隐式空闲链表分配器就可以在常数时间内完成对前面块的合并。简单来说，就是双向合并。 7.9.2、显式空闲链表 将空闲块组织成某种形式的显式数据结构，实现这个数据结构的指针可以存放在这些空闲块的主体里。堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个前驱和后继指针。 这样做的好处就是在我们在malloc的时候，隐式的方法是要遍历所有的块，包括空闲块了分配块。但是显式的结构只需要在空闲块中维护的链表检索就可以了，这样降低了在malloc时候的复杂度。 一种方法是后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处，分配器会最先检查最近使用过的块。.这样在malloc的时候会首先看一下最后被free的块是否符合要求。这样的好处是释放一个块的时候比较高效，直接放在头部就可以。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索定位合适的前驱。 7.10本章小结 这一章介绍了hello的存储器地址空间的概念和相关的地址计算方法，缺页和缺页处理，重点介绍了虚拟地址转换成物理地址的过程，包括四级页表、TLB加速、三级cache等。除此以外，介绍了内存映射，以及fork创建进程和execve函数运行hello时的具体过程。最后讲述了动态内存分配管理的不同结构的链表的操作。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行，这就是UnixI/O接口。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 （1）打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个叫做描述符的小的非负整数，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息，应用程序只需记住这个描述符。 对应的函数为intopen(char*filename,intflags,mode_tmode);filename为文件名，flags参数指明了进程打算如何访问这个文件，可以是只读、只写、可读可写。mode参数指定了新文件的访问权限位。若open成功则返回新文件描述符，若失败则返回-1. （2）Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。 （3）改变当前文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 （4）读写文件：一个读操作就是从文件复制n个字节到内存,从当前文件位置k开始，然后k增加到k+n,给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个EOF的条件，应用程序能检测到这个条件，在文件结尾处并没有明确地EOF符号。 类似的，写操作就是从内存复制n个文件到一个文件，从当前文件位置k开始，更新k。 读文件对应的函数为ssize_tread(intfd,void*buf,size_tn);fd为当前文件的描述符，buf是内存位置，n是复制最多n个字节。若成功则为读的字节数，若EOF则为0，若出错-1。 写文件对应的函数是sisze_twrite(intfd,constvoid*buf,size_tn);若成功则为写的字节数，若出错则为-1。 （5）关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核丢回关闭所有打开的文件并释放他们的内存资源。 关闭文件的函数为intclose(intfd);若成功为0，若出错为-1.关闭一个已经关闭的描述符会出错。 8.3printf的实现分析 首先观察一下Linux下printf的函数体 staticintprintf(constchar*fmt, ) { va_listargs; inti; va_start(args,fmt); write(1,printbuf,i=vsprintf(printbuf,fmt,args)); va_end(args); returni; } printf需要做的事情是：接受一fmt的格式，然后将匹配到的参数按照fmt格式输出。图8-1是printf的代码，我们可以发现，他调用了两个外部函数，一个是vsprintf，还有一个是write。 定义va_list型变量args，指向参数的指针。va_start和va_end是获取可变长度参数的函数，首先调用va_start函数初始化args指针，通过对va_arg返回可变的参数，然后va_end结束可变参数的获取。 重点需要看write函数和vsprintf函数。 vsprintf函数的作用是以fmt为格式字符串，根据args中的参数，向printfbuf输出格式化后的字符串。然后调用write函数，write函数是UnixI/O函数，用以在屏幕上输出长度为i的在printfbuf处的内容。查看write函数的汇编代码可以看出它将栈中参数存入寄存器，然后执行INT_VECTOR_SYS_CALL,代表通过系统调用syscall，syscall将寄存器中存储的字符串通过总线复制到显卡的现存中，字符显示驱动子程序通过ASCII码在字模库中找到点阵信息并将其存储到vram中。接下来显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。此时在屏幕上显示一个已经格式化的字符串。 8.4getchar的实现分析 intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf;` } return(--n>=0)?(unsignedchar)*bb++:EOF; } getchar函数通过调用read函数来读取字符，read函数的返回值是读入字符的个数，若出错则返回-1.read函数通过调用内核中的系统函数，读取键盘缓冲区的ASCII码，直到读到回车为止，然后将整个字符串返回。 8.5本章小结 这一章介绍了Linux的I/O管理方法、I/O接口及其函数，以及通过阅读printf函数和getchar函数的代码了解如何通过UnixI/O实现功能。总的说，UnixI/O使得所有的输入和输出都能以一种统一且一致的方式来执行。 （第8章1分） 结论 hello的一生是这样度过的 我们通过各种方法，编写得到hello.c源文件预处理器将hello.c文件初步修改为hello.i文件编译器将hello.i文件编译成汇编代码存储在hello.s文件中汇编器将hello.s文件处理成可重定位目标文件hello.o，这时候的hello.o已经和之后能够实际运行的机器代码相差不大了链接器将hello.o与库进行链接，完成能实际运行的可执行文件hello当我们在shell中运行hello文件时，内核会为我们分配运行程序所需的堆栈，虚拟内存等信息，方便我们执行hello在运行过程中遇到各种信号和键盘输入，shell为其提供信号处理程序hello访存时，请求的地址为虚拟地址，通过MMU、TLB、四级页表等得到对应的物理地址，在三级cache中进行访存hello输入输出调用的getchar函数和printf函数，通过UnixI/O接口进行实现当hello执行完成所有工作之后，最终被shell回收，结束了程序的一生 通过这次大作业，我更加全面系统的了解了这门课程，对书中的知识有了更加全面的认识。同时感受到了计算机系统的复杂性以及严密性。我们一个程序的成功运行需要多少计算机硬件和软件的共同配合。 （结论0分，缺失-1分，根据内容酌情加分） 附件 文件名称作用hello.c源代码文件hello.i经过预处理得到的C语言文件hello.s经过编译得到的汇编文件hello.0经过汇编之后的可重定位目标执行文件hello经过链接之后的可执行文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 

计算机系统大作业 文章目录 1.C语言的语言元素1.1程序结构1.1.1循序结构1.1.2分支if语句switch语句 1.1.3循环for循环while循环do-while循环 1.2变量1.2.1全局变量1.2.2局部变量1.2.3寄存器变量 1.3数据类型1.3.1常量1.3.2整型数1.3.3浮点数1.3.4数组1.3.5指针1.3.6引用1.3.7结构体 1.4函数 2.汇编语言的语言元素2.1程序结构2.1.1整体结构2.1.2寄存器2.1.3寻址2.1.4数据传送2.1.5压栈与弹栈2.1.6算术与逻辑操作2.1.7控制2.18栈 2.2宏定义2.3变量2.3.1全局变量2.3.2局部变量2.3.3整型变量2.3.4浮点变量 2.4函数2.4.1参数传递的规则2.4.2调用语句2.4.3返回值传递 3.C语言的汇编实现3.1数据类型3.1.1整型3.1.2浮点型3.1.3类型转换 3.2变量与数据的寻址3.3分支、循环结构的实现3.4代码优化对循环的影响3.5函数3.6指针3.7引用 4.C与汇编的优缺点分析4.1开发速度4.2软件运行速度4.3CPU新特性的支持程度4.4软件的可移植性4.5个人体会 5.参考文献 1.C语言的语言元素 1.1程序结构 对于任意一个程序来说，其都是从main函数开始执行。 1.1.1循序结构 intsum(inta,intb) { intc; c=a+b; returnc; } 如图中所示的循序结构函数的代码，循序结构又称顺序结构，其按照语句出现的先后顺序依次执行语句。对于循序结构来说，在忽略某个语句调用了其他函数并导致其他结构出现的情况下，其中的语句都会被执行，但每个语句只会执行一次。 1.1.2分支 C语言中实现分支结构的语句有两种：if语句和switch语句。分支结构先谷底循序结构来说，在忽略某个语句调用了其他函数并导致其他结构出现的情况下，其中的语句会被执行一次或不执行，并且总存在不执行的分支（if和else分支都存在的情况下）。 if语句 intfunction_if(intx) { if(x<0) return0; else returnx; } 如图所示的ReLU函数为典型的if语句实现。if根据括号后表达式的真假决定是否执行该分支。对于有着多种选择的情况，可以有两种实现方法：第一种：嵌套if语句，即在if语句的某个分支中再写入一个if语句。这种实现方法可以在多种分支存在共同的前置条件时使用。将前置条件作为外层if的判断，后置条件则放入内层if语句中第二种：使用elseif。以图中代码举例，若x需要选择大于0、小于0、等于0三个分支时，利用if，elseif，else实现三个分支，执行时会依次测试其中的分支，选中时直接进入。if语句在逻辑上有着较为清楚的实现，但当分支过多时，依次对比会导致执行速度下降。 switch语句 voidfunction_switch(charc) { switch(c) { case'a': cout<<1<<endl; break; case'b': cout<<2<<endl; break; default: cout<<3<<endl; break; } } 如图所示为一个switch语句的实现。switch语句在逻辑上比较清晰，但不能像if语言一样处理复杂分支。switch语句主要面向一个条件有着多个可能实现的分支的情况。其在对比的时候，因底层实现与if语句不同，只需要一次对比即可选中所需分支，在有着大量分支的情况下效率远高于if语句，但switch语句空间占用较大，是典型的空间换时间的策略。 1.1.3循环 C语言中有三种语句可以实现循环结构：for、while、do-while。循环结构与上述两种结构最大的不同在于，循环结构内的语句可以执行不止一次，并且存在不执行的情况，即循环0次。下面以计算从start到end的连续自然数之和的程序为例，介绍三种循环结构。 for循环 intfunction_for(intstart,intend) { intsum=0; for(registerinti=start;i<=end;i++) sum+=i; returnsum; } for循环的一般形式为：for（单次表达式；条件表达式；末尾循环体）{中间循环体}其中，表示式皆可以省略，但分号不可省略，因为“;”可以代表一个空语句，省略了之后语句减少，即为语句格式发生变化，则编译器不能识别而无法进行编译。for循环小括号里第一个分号前为一个为不参与循环的单次表达式，其可作为某一变量的初始化赋值语句,用来给循环控制变量赋初值；也可用来计算其它与for循环无关但先于循环部分处理的一个表达式。分号之间的条件表达式是一个关系表达式，其为循环的正式开端，当条件表达式成立时执行中间循环体。执行末尾循环体后将再次进行条件判断，若条件还成立，则继续重复上述循环，当条件不成立时则跳出当下for循环。for循环在实现访问连续内存空间时较为方便，逻辑清晰。 while循环 intfunction_while(intstart,intend) { intsum=0; while(start<=end) { sum+=start; start++; } returnsum; } while循环与for循环等价。但语法中只保留用于判断是否退出循环的条件表达式。其余需要在对应位置实现。while循环在实现例如遍历链表等访问不连续内存空间时使用方便，逻辑清晰 do-while循环 intfunction_dowhile(intstart,intend) { intsum=0; inti=start-1; do { i++; sum+=i; }while(i<end); returnsum; } do-while循环与上述两种循环的不同点在于：只要循环条件设置的好，上述的两种循环可以不执行循环体内的语句，而do-while循环至少会执行一次循环体内的语句。其他基本与while循环等价。do-while循环时候实现至少执行一次的循环，适合实现至少需要执行一次的循环。例如：用于迭代的计数器初值为0时计算1到n的累加和。 1.2变量 1.2.1全局变量 intinteger=0; unsignedintuinteger=0; floatreal=3.14; intintegers[2]={0,1}; int*pinteger=&integer; int&qinteger=integer; 全局变量能被程序中所有的函数以及对象调用。换句话说它的作用域为整个程序。全局变量被保存在可执行文件的数据段或者.bss段中。全局变量可以被extern和static修饰。对于一个拥有多个源文件的工程来说，每个文件都可以拥有自己的全局变量，并且对于任意文件都可调用。而被extern修饰的全局变量声明表示该全局变量在其他文件中。被static修饰的全局变量则只能被当前源文件内的函数与对象调用。 1.2.2局部变量 intfunction_for(intstart,intend) { intsum=0; for(registerinti=start;i<=end;i++) sum+=i; returnsum; } 以for循环的代码为例，其中出现的所有变量均为局部变量局部变量的作用域为：定义局部变量时，程序执行到的语句所在的花括号包围的范围。与全部变量不同，局部变量被保存在被称为栈的结构中进行管理。 1.2.3寄存器变量 intfunction_for(intstart,intend) { intsum=0; for(registerinti=start;i<=end;i++) sum+=i; returnsum; } 以for循环的代码为例，其中用于计数的i即为寄存器变量寄存器变量与上述两种变量不同，其被保存在存取速度最快的寄存器当中。用register修饰局部变量即可定义寄存器变量 1.3数据类型 1.3.1常量 #defineINTEGER20 #defineREAL3.14 #defineCHARACTER'c' #defineSTRING"string" 常数可分为整型常量（图中INTEGER）、实型常量（图中REAL）、字符型常量（图中CHARACTER）与字符串型常量（STRING）。对于每一种常量，其在底层的实现与其对应的变量相同，但常量的值不能更改，并且存储在文件的只读区域。整型常量、实型常量与字符型常量直接存储在代码段当中，当被使用时，在取指令阶段即可取出。字符串型常量略有不同，由于其一般内存占用较大，不能直接写入代码中，因此被存储在只读数据段中，代码段只保留其首地址。 1.3.2整型数 intinteger=0; unsignedintuinteger=0; 整型数分为有符号整型与无符号整型。二者所能表示的数的数量相同，但区间不同。对于一个k位的整型数来说，有符号整型表示-2(k-1)~2(k-1)-1范围内的所有整数，而无符号整型表示02^k-1范围内的所有整数。二者直接存在着互相转换的情况。当二者均在02(k-1)-1这个区间内时，二者的值相等，类型转换并不会带来值的改变；但是当有符号数在-2(k-1)0或无符号数在2^(k-1)2k-1时，类型转换会导致值的变化，其关系可表示为公式：有符号数+2k=无符号数。 1.3.3浮点数 floatreal=3.14; 与整型数可以精确表示整数不同，浮点数只能精确表示部分实数。对于大部分实数来说，浮点数只能近似表示。根据近似的精度不同，浮点数可以分为单精度浮点型与双精度浮点型。二者在组成上一致，只在二进制位数上不同，从而导致了精度的不同。对于一个浮点数，其二进制代码可分为三个部分：符号位，阶码和尾数。将一个待转换的实数用科学计数法的二进制形式表示，其符号对应着符号位，数量级对应着阶码，精确值的小数部分的前n位对应着尾数，n为尾数的位数。 1.3.4数组 intintegers[2]={0,1}; 数组即为一定数量的某种数据类型的集合。数组在内存中占用一段连续的存储单元，因此可以快速访问其中的元素。字符串类型的变量在底层实现上为一个以\0结尾的字符型数组。数组名的本质是一个指针，指向数组的起始地址。 1.3.5指针 int*pinteger=&integer; 指针的本质为一个整数，它表示指针所指向的对象在虚拟内存中的首地址。 1.3.6引用 int&qinteger=integer; 引用本质上相当于给它表示的对象起了一个别名，二者指向的是内存中的同一个对象，对其中一个的修改也会导致另一个的改变。 1.3.7结构体 structst { charname[20]; unsignedage; unsignedid; }ics_me; 有了上述的数据类型，已经足够实现C语言所有的功能了。但是，在具体使用时仍然会存在问题。首先，抽象层次不够高，不利于人的理解。其次，无法同时管理不同的数据类型，或者说给不同数据类型之间显式的建立关系。因此，C语言提供了结构体。结构体将一系列数据结构封装为用户自定义的一种数据结构，提高了抽象水平，更有利于人类理解。结构体占用的空间并不简单的等于其中所有数据结构的内存大小相加，而是大于等于相加之和，这是由于对齐的存在。其对齐要求与结构体中内存占用最大的那个类型的对齐要求相同。以将图中的结构体的第一个字段改为单一字符后的结构体为例，其空间占用为4+4+4=12字节，而不是2+4+4=10字节。因为对于无符号型来说，其需要满足地址可被4整除的地址要求，因此整个结构体的地址也需满足该要求。带来的结果是：字符型后面的2字节被空在那不被使用。 1.4函数 函数是指一段可以直接被另一段程序或代码引用的程序或代码，例如程序结构当中所具的函数的例子。对于函数来说，其内部代码本可以写入主程序当中。但是，假如一段程序调用了100次某函数，如果该函数存在错误，我们只需修改函数一次；对于写在主程序中的情况，则需要找到这100次并修改。因此封装成函数有利于代码复用，并且提高了程序的可读性。函数的通用形式为：返回类型名字(形式参数表列){函数体语句return表达式;}参数传递方式有三种，传值，传地址，传引用。传值的情况下，函数将实参的值复制给形参，函数体对形参的修改并不会导致实参的变化。对于传地址与传引用这两种形式，本质上都是传入了一个指向实参的一个对象，对形参的修改会同时修改实参。 2.汇编语言的语言元素 2.1程序结构 2.1.1整体结构 当一个程序加载到内存时，其具有五个主要部分：代码段、数据段、堆、共享模块、栈。代码段存储了我们在源文件中所有语句对应的机器指令，以及常数。在程序的执行过程中，处理器按照%rip寄存器所保存的地址依次读取代码段中的指令执行，并根据指令修改寄存器中的值或将值写入内存。代码段在执行过程中不可被修改。数据段中保留了程序中所定义的全局变量，其中已初始化的全局变量被保存在.data段中，未初始化的全局变量被保存在.bss段中。在执行过程中，程序可以读取数据段中的数据并加以修改。堆是保留给程序在执行阶段动态分配内存的区域。由malloc函数向操作系统申请堆的空间，并由free函数释放空间。共享模块是用于节省内存使用空间而引入的一个内存区域。程序中需要大量使用的代码，若每个进程都保留一个副本，则会造成内存的极大占用。而共享模块则只保留每个进程调用这段代码所需的数据，代码本事只在程序中包含一个副本，从而减少了内存开销。栈是程序中局部变量保存的地点以及辅助函数调用的结构。栈内的数据遵循一个规律：后进先出。栈顶地址由一个寄存器%rsp保存。每当进入一个函数时，程序会通过压栈的方式在栈中预先分配好局部变量所需的空间；当退出一个函数时，程序会通过弹栈的方式回收局部变量占用的空间。当函数调用另一个函数时，程序将当前函数的状态，即寄存器中保存的值，通过压栈的方式存入栈中；函数返回时则通过弹栈的方式恢复函数的状态，从而继续执行函数。 2.1.2寄存器 一个x86-64的CPU包含一组16个存储的64位值的通用目的寄存器。各个寄存器的名称与功能如下表 64位名称32位名称16位名称8位名称功能%rax%eax%ax%al返回值%rbx%ebx%bx%bl被调用者保存%rcx%ecx%cx%cl第4个参数%rdx%edx%dx%dl第3个参数%rsi%esi%si%sil第2个参数%rdi%edi%di%dil第1个参数%rbp%ebp%bp%bpl被调用者保存%rsp%esp%sp%spl栈指针%r8%r8d%r8w%r8b第5个参数%r9%r9d%r9w%r9b第6个参数%r10%r10d%r10w%r10b调用者保存%r11%r11d%r11w%r11b调用者保存%r12%r12d%r12w%r12b被调用者保存%r13%r13d%r13w%r13b被调用者保存%r14%r14d%r14w%r14b被调用者保存%r15%r15d%r15w%r15b被调用者保存 2.1.3寻址 对于大多数指令来说，其至少有一个操作数，指出源操作数的位置，以及结果存放位置。其格式主要有三种形式：1、立即数寻址$Imm，对应的操作数值为Imm2、寄存器寻址ra，对应的操作数值为ra中的值3、地址寻址Imm(ra,rb,s)，对应的操作数为地址Imm+ra+rb*s所指向的内存。s的值必须为1，2，4，8.其中的各部分均可以省略Imm省略时默认为0，ra与rb省略时默认值为0，s省略时默认为1。 2.1.4数据传送 数据传送指令 MOV类将数据从源位置复制到目的位置而不改变数据。MOV类指令由四条指令组成，movb，movw，movl，movq，分别移动1、2、4、8个字节。然而，数据的源位置与目的位置的数据大小并不一定相等。当源位置的数据大小大于目的位置时，CPU采用截断的方式缩小数据，即舍弃目的位置存不下的那部分数据；小于时，则需要扩展源数据以匹配目的位置的大小。扩展方式有两种： 零扩展MOVZ，在数据前面补充0。但这会导致有符号数在负数范围内出错。具体指令见下表符号扩展MOVS，在数据前面补充符号位数据。这可以保证有符号数的值不发生变化，但无符号数则会发生变化。具体指令见下表 2.1.5压栈与弹栈 pushq指令将一个四字从寄存器压入栈中，并修改栈顶指针的值。popq指令将一个四字从栈取出到寄存器中，并修改栈顶指针的值。 2.1.6算术与逻辑操作 处理器通过下表中的各种指令完成对数据的算数操作或者逻辑操作 2.1.7控制 对于循环和控制两种结构中的跳转，均需要通过比较来控制。CPU提供了一组单个位的条件码寄存器，描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支。常用的条件码有： CF：进位标志，用于检查无符号数的溢出ZF：零标志SF：符号标志OF：溢出标志，用于检查有符号数的溢出除了算术和逻辑相关指令会修改条件码之外，有两类特殊的指令：CMP指令和TEST指令只修改条件码而不修改其他寄存器的值。可通过这两种指令为循环与分支的触发条件设置对应的条件码：jmp指令则通过检测条件码来判断是否满足跳转条件。各指令对应的跳转条件如下图 2.18栈 栈的功能除了传递参数（见函数部分）、存储局部变量（见变量部分）、保存函数信息（见函数部分）以外，还可以用来保存暂时存储数据。由于寄存器的数量是有限的，当数据无法在寄存器中存下时，程序会将多余的有用的数据压入栈中暂存，当有需要时在将其取出。 2.2宏定义 对于不包含变量的宏定义，编译器会将程序中的宏直接替代，若是计算式则替代计算结果。如图中所示的def（）函数，最终的汇编代码直接返回20而省略计算 #defineDEF2*10 intdef() { returnDEF; } 0000000000401377<_Z3defv>: 401377:55push%rbp 401378:4889e5mov%rsp,%rbp 40137b:b814000000mov$0x14,%eax 401380:5dpop%rbp 401381:c3retq 对于包含变量的宏定义，编译器会将宏替换为对应的表达式。如图中所示的def（intx）函数，编译器将F1（x）的调用替换为了x+x #defineF1(x)x<<1 intdef(intx) { returnF1(x); } 0000000000401382<_Z3defi>: 401382:55push%rbp 401383:4889e5mov%rsp,%rbp 401386:897dfcmov%edi,-0x4(%rbp) 401389:8b45fcmov-0x4(%rbp),%eax 40138c:01c0add%eax,%eax 40138e:5dpop%rbp 40138f:c3retq 2.3变量 2.3.1全局变量 全局变量存储在程序的数据段中，代码段中存储的为全局变量在数据段中的地址。全局变量可分为强符号和弱符号。强符号为初始化的全局变量，而弱符号为未初始化的全局变量。一个程序中同名的强符号只能存在一个，若存在同名的全局变量，连接器会将弱符号解释为对应的强符号。 2.3.2局部变量 局部变量存储在程序的栈中，用于统一管理。以x86-64为例，在进入每个程序块时，指令控制处理器进行压栈操作为块内每个局部变量分配好空间，并且通过弹栈的方式控制变量的作用域。 2.3.3整型变量 按照字节数，整型变量可分为字节（一个字节）、字（两个字节）、双字（四个字节）、四字（八个字节），分别对应了c程序中的char、short、int、long。char类型数据均为无符号数，因此不需要考虑符号问题。对于其余三种数据类型，均存在有符号和无符号两种情况。有符号数以补码的方式存储，而无符号数以原码的方式存储。在运算过程中，若同时存在有符号数与无符号数，编译器会隐式的将有符号数转换成无符号数进行计算。当二者进行类型转换时，处理器不改变二进制形式，而是将补码（原码）直接解释成原码（补码）。 2.3.4浮点变量 处理器的浮点体系结构包含了16个浮点寄存器，从%ymm0到%ymm15。每个浮点寄存器可以存储一个双精度浮点或两个两个单精度浮点，并且可以并行计算。对于浮点体系来说，其包含了另一套指令，包括： 数据传送转换为整型数从整型数转换而来计算部分没学。 2.4函数 2.4.1参数传递的规则 仅考虑整型数。函数在传入参数的时候，首先使用寄存器。其按照%rdi、%rsi、%rdx、%rcx、%r8、%r9的顺序传入前6个参数。当参数数量超过6个时，程序会将这些参数压入栈中，通过栈将数据传入函数。所有通过栈传递的参数都向8的倍数对齐 2.4.2调用语句 函数通过call指令调用其他函数，并通过ret指令返回调用者。在执行过程中，每个函数都拥有一个栈帧 栈中属于该函数的一块连续的区域。每个栈帧的最后一个数据都是需要返回的函数地址 调用指令下一条指令的地址，在此之前栈帧中保存的数据为本函数作为调用者所需保存的参数。每个栈帧前几个数据都是本函数作为被调用者所需保存的参数。这些数据的保存均由call指令完成。同样，ret指令也会将这些数据恢复。当栈弹出返回地址时，PC就被修改为返回地址的值，从而达到了返回函数下一条语句的目的。递归调用则是上述函数调用过程对本函数的反复使用。具体代码和全局变量都在同一个数据段与代码段中，而栈帧又为每次递归调用提供了私有的同名局部变量；返回地址又保证了递归可以从深层返回回调用处。 2.4.3返回值传递 对于函数的返回值，整型数据保存在%rax中，浮点型数据保存在%ymm0中。 3.C语言的汇编实现 3.1数据类型 3.1.1整型 整型数可以分为有符号数与无符号数。对于一个长为k的二进制数，用xk-1,xk-2,…,x0来表示其对应的所有位。对于一个无符号数，其二进制编码形式与十进制数与二进制数和十进制数在数学中的关系相同，对应公式为 B 2 U ( x ) = ∑ i = 0 k − 1 x i 2 i B2U(x)=\sum\limits_{i=0}^{k-1}x_i2^i B2U(x)=i=0∑k−1​xi​2i对于有符号数来说，为了表示正负，其二进制编码的最高位被定义为符号位。其余位与无符号数表示意义相同。对应公式为 B 2 T ( x ) = − x k − 1 2 k − 1 + ∑ i = 0 k − 2 x i 2 i B2T(x)=-x_{k-1}2^{k-1}+\sum\limits_{i=0}^{k-2}x_i2^i B2T(x)=−xk−1​2k−1+i=0∑k−2​xi​2i 3.1.2浮点型 一个浮点型数据在底层编码上可以分为三个部分：符号位、尾数与阶码。符号位以1来表示负数，0表示正数。对于任意一个实数，将其绝对值表示成二进制的科学计数法，则其数量级即是阶码表示的部分，系数的小数部分即尾数表示的部分。当阶码全为1，尾数全为0时，该数表示无穷大，结合符号位即可表示正无穷大或负无穷大。当阶码全为1，尾数不全为0时，该数表示NAN（Notanumber）。为了便于比较，阶码放在尾数之前。如图所示，单精度浮点数有着8位阶码，23位尾数；双精度浮点数有着11位阶码，52位尾数。 3.1.3类型转换 对于c语言中的运算，存在着显式和隐式的类型转换。隐式类型转换会发生在赋值以及计算的时候。转换有着以下集中类型有符号数与无符号数之间的转换：当着二者发生转换时，由于均为整型数，其底层二进制编码不会改变，仅仅修改解码方式。小整型向大整型转换：小整型向大整型转换需要在多出的位上填充0或者1，即零扩展和符号扩展。对于有符号数来说，符号扩展能保证扩展后的值不发生改变；对无符号数来说，零扩展能保证扩展后的值不发生变化。大整型数向小整型数转换：大整型数相对小型整数来说具有更长的二进制位，因此需要截断多余的位来满足小整型数的位数要求。当大整型数的值本身在小整型数的表示范围内时，截断并不会改变数的值；但当大整型数的值不在小整型数的表示范围内时，截断会由于溢出而发生值的改变。如图中程序及输出所演示。 longlonga=1<<2; longlongb=(longlong)1<<40; cout<<(int)a<<endl; cout<<(int)b<<endl; 整型数转化为浮点数：此时类型转换不会发生溢出，但是由于尾数长度有限，可能会发生舍入浮点数转化为整型数：浮点数会舍弃小数部分，向0取整。 3.2变量与数据的寻址 在程序中，变量要么存储在寄存器中，要么存储在内存中。对于存储在寄存器当中的数据，如函数传入的参数，处理器会直接对寄存器访问或者修改。对于存储在内存当中的变量，编译器在编译链接阶段就确定了其地址。需要使用时，程序将地址存入某个寄存器，再使用寄存器进入内存中访问或者修改该变量。数据的情况与变量类似，但数据只存在于内存当中（这里特指写在数据段或者只读数据段的数据）。唯一的不同点在于，变量可以不用写回内存中，但数据则必须写回。进一步，只读数据只能读取，不可写入。 3.3分支、循环结构的实现 对于现代编译器生成的机器指令，循环以及分支语句通过均通过跳转指令实现。通过跳转到之前执行过的指令，再顺序执行到跳转指令处实现循环结构。以图中的function_jump函数为例，其前一部分为for循环，后一部分为选择语句。 intfunction_jump(intn) { intx=0; intsum=0; for(inti=0;i<n;i++) x+=i; if(n<=0) sum=0; else sum=x; returnsum; } 如图所示汇编代码，40134f处的jge指令判断i是否小于n，以控制是否继续循环；而40135b处的jmp指令则是跳回到循环的开始处。当不再继续循环时，程序在401234f处跳转到40135d，越过40135b从而进入分支部分。 401349:8b45f4mov-0xc(%rbp),%eax 40134c:3b45eccmp-0x14(%rbp),%eax 40134f:7d0cjge40135d<_Z13function_jumpi+0x30> 401351:8b45f4mov-0xc(%rbp),%eax 401354:0145fcadd%eax,-0x4(%rbp) 401357:8345f401addl$0x1,-0xc(%rbp) 40135b:ebecjmp401349<_Z13function_jumpi+0x1c> 通过跳转到不同的未执行过的指令，顺序执行到分支结束处，再通过跳转会和从而达到分支的功能。如图所示汇编代码，401361处的jg指令控制程序进入40136c之后的指令所对应的分支，另一条分支则为401363对于的语句。40136a处的jmp指令控制两条分支在401372处汇合，之所以只存在一个jmp指令，是因为40136c处的分支只需顺序运行下去即可达到401372处，无需跳转 40135d:837dec00cmpl$0x0,-0x14(%rbp) 401361:7f09jg40136c<_Z13function_jumpi+0x3f> 401363:c745f800000000movl$0x0,-0x8(%rbp) 40136a:eb06jmp401372<_Z13function_jumpi+0x45> 40136c:8b45fcmov-0x4(%rbp),%eax 40136f:8945f8mov%eax,-0x8(%rbp) 401372:8b45f8mov-0x8(%rbp),%eax 3.4代码优化对循环的影响 voidfunction_o3_1(int**A,int**B) { for(inti=0;i<100;i++) for(intj=0;j<100;j++) B[i][j]=A[j][i]; } voidfunction_o3_2() { intx=0; for(inti=0;i<5;i++) x+=5; } 以上图中两个函数为例，第一个为求100x100的矩阵转置，第二个为求前0+1+2+3+4。在不开优化的情况下，编译器按照程序所写的语句，依次将其转为汇编语言。当开启O3优化后，变化如下 0000000000401690<_Z13function_o3_1PPiS0_>: 401690:4989f0mov%rsi,%r8 401693:31c9xor%ecx,%ecx 401695:498b3448mov(%r8,%rcx,2),%rsi 401699:31c0xor%eax,%eax 40169b:0f1f440000nopl0x0(%rax,%rax,1) 4016a0:488b14c7mov(%rdi,%rax,8),%rdx 4016a4:8b140amov(%rdx,%rcx,1),%edx 4016a7:891486mov%edx,(%rsi,%rax,4) 4016aa:4883c001add$0x1,%rax 4016ae:4883f864cmp$0x64,%rax 4016b2:75ecjne4016a0<_Z13function_o3_1PPiS0_+0x10> 4016b4:4883c104add$0x4,%rcx 4016b8:4881f990010000cmp$0x190,%rcx 4016bf:75d4jne401695<_Z13function_o3_1PPiS0_+0x5> 4016c1:c3retq 4016c2:66662e0f1f8400data16nopw%cs:0x0(%rax,%rax,1) 4016c9:00000000 4016cd:0f1f00nopl(%rax) 首先，编译器会将循环打开，如图中所示汇编代码，编译器将整个矩阵拆分成以64为单位的块，每次对一个块进行转置操作，以补偿程序cache不命中的代价。 00000000004016d0<_Z13function_o3_2v>: 4016d0:c3retq 4016d1:662e0f1f840000nopw%cs:0x0(%rax,%rax,1) 4016d8:000000 4016db:0f1f440000nopl0x0(%rax,%rax,1) 其次，编译器会舍弃无用计算，例如将常数表达式替换成常数，或如图所示，不需要执行的操作不予生成。 3.5函数 每个函数在代码段中都有自己的位置。在执行阶段，每个函数都会在栈中拥有自己的栈帧。栈帧结构如下图所示。函数的参数通过寄存器传入，对于多余6个的，则通过栈传入（见2.4.1）。函数的调用通过call指令实现，其本质为保存原函数的内容并修改下一条指令的地址为被调用函数；函数返回通过ret指令实现，其本质为从栈中恢复寄存器当中的内容并修改下一条指令的地址为调用函数指令的下一条指令。 3.6指针 指针的本质为一个地址。每一个变量的使用在函数底层都是指针。指针在赋值时，若从另一个指针处获得值，则通过mov指令即可实现；若为某个变量经过取地址操作进行赋值，则通过leaq指令将变量的地址赋值给保存当前指针的寄存器。指针指向的地址为虚拟地址。在编译阶段，为了便于编译器实现以及满足操作系统的某些功能，生成的程序均以虚拟内存作为内存。当处理器需要提取某个指针指向的值时，处理器将指针表示的虚拟内存送入MMU中进行地址翻译，最终cache或内存返回数值供处理器使用。 3.7引用 引用在底层是通过指针实现的 intinteger=0; unsignedintuinteger=0; floatreal=3.14; intintegers[2]={0,1}; int*pinteger=&integer; int&qinteger=integer; intquota() { intx=integer; x=qinteger; returnx; } 以上图中的函数为例，其对应的汇编代码为 0000000000401436<_Z5quotav>: 401436:55push%rbp 401437:4889e5mov%rsp,%rbp 40143a:8b05602d0000mov0x2d60(%rip),%eax#4041a0<integer> 401440:8945fcmov%eax,-0x4(%rbp) 401443:b8a0414000mov$0x4041a0,%eax 401448:8b00mov(%rax),%eax 40144a:8945fcmov%eax,-0x4(%rbp) 40144d:8b45fcmov-0x4(%rbp),%eax 401450:5dpop%rbp 401451:c3retq 我们可以注意到，在0x40143a处第一次使用integer赋值时，integer的地址为0x4041a0，而在0x401443/0x401448处第二次使用引用赋值时，程序通过integer的指针取出integer的值从而实现引用。 4.C与汇编的优缺点分析 4.1开发速度 从开发速度的角度来说，C语言远快于汇编语言。C语言作为高级语言，更贴合人类的语言习惯。在开发过程中，C语言大部分只需要考虑逻辑上如何实现功能，极少部分时间由于bug的存在需要考虑底层实现；而汇编代码的每一个语句都需要考虑底层实现以及各种硬件资源，以防止有用数据丢失。 4.2软件运行速度 在运行速度上，经过设计的汇编语言比C语言快得多。因为人工设计的汇编程序能够有效的利用硬件资源；而编译器生成的汇编程序，由于需要保证程序的正确性，编译器会牺牲性能，除此之外，编译器也无法加入人工可以设计的技巧进行加速。 4.3CPU新特性的支持程度 汇编语言对CPU的新特性支撑程度更高。汇编语言中的指令往往能直接利用CPU的新特性。而C语言的底层实现不依赖于C程序，而依赖于编译器。当编译器不支持CPU的新特性时，C语言便不支持CPU的新特性。 4.4软件的可移植性 C语言的可移植性远高于汇编语言。对于不同类型的机器来说，其指令集往往是不同的，因此实现同样的功能，其汇编语言也往往不同，可移植性极差。而C语言不依赖于底层汇编，其描述的只是程序需要的逻辑，因此C程序可以在各种机器上移植，每中机器只需要提供对应的编译器即可。 4.5个人体会 当只能使用C语言或汇编语言时，若需要实现复杂功能，则必选C语言而不选择汇编语言。但是，当程序遇到速度瓶颈，而针对C程序的优化仍无法胜任时，需要在C程序的关键部分中插入人工设计的汇编语言以提高性能。除此之外，当遇到一台新机器，并且该机器缺少编译器的时候，则只能使用汇编语言。在开发一些嵌入式的简单程序时，使用汇编语言往往能达到更好的效果。 5.参考文献 [1]深入理解计算机系统（第三版）[2]http://www.360doc.com/content/17/0308/22/40101294_635112591.shtml 

信息安全课作业1：老师迷惑的打油诗 2021/5/25 网上除了老师的微博，上一届学长写的还不是这个作业，所以写下来造福下以后的学弟学妹，不要浪费时间在这上面 声明：图片都是作业自带的，跟我没关系（真的） 第一题 “二八”妙龄写密码，看谁聪明“爱死他”。 密文：76 6C 72 73 62 6F 76 70 6A 5E 6F 71 5F 72 71 76 6C 72 70 6D 62 6B 71 71 6C 6C 71 66 6A 62 明文：you very smart but you spent too time 思路：爱死它表示为ascii编码（能从密文看出来），而，所以这个是一个偏移量为3的凯撒密码（原因是后找的，实际是枚举0到10枚举出来的） 第二题 无题警示： 锦瑟无端五十弦，一弦一柱思华年， 千帆远眺蝴蝶梦，万国赛马撩人眼。 沧海月明珠有泪，蓝田日暖玉生烟， 此情可待成追忆，他年饮酒泪涟涟。 密文：24205299922620426799368643468534687 明文：庄生晓梦迷蝴蝶 思路：和上一题思路差不多，“万国马”就是Unicode，“饮酒”对应09，然后还是一个凯撒密码 后面的题开始坑爹了起来 网上找的能用的Des在线加密解密网页http://www.jsons.cn/desencrypt/ 第三题：黛丝打靶 日落西山红霞飞，战士打靶把营归。 五发中靶二十二，黛丝秘诀子弹飞。 密文：U2FsdGVkX18HM4A1Xow2e412F0IMPUSDVw/lNeTEtwDYAjSHsx61CQ== 明文：youareveryclover 思路：“黛丝”对应Des算法；“日落西山红霞飞，战士打靶把营归”是打靶归来的第一句，里面有句“misolamiso，lasomidore”，对应的简谱为35635,65312。而3+5+6+3+5=22，所以密钥是35635 第四题：迷人的黛丝 打靶通关密语 日落西山红霞飞，战士打靶把营归。 张三成绩二十二，李四十七把牛吹。 我的成绩比你好，先后起来你悲催； 美女黛丝抿嘴笑，再来一次子弹飞。 密文：U2FsdGVkX1+YN8tsns+7jvoarVmsqg316iBBvFP3ZemnrYEOGsI6bH5CvIVFSN0Y px1ka4fSPGj7cDvg81wU8BlnJYoDdhvl83cBIQDHk0JQnpaKXU3ZRA== 明文：Youareamazing 思路：这题大部分和上一题一样，3+5+6+3+5=22，6+5+3+1+2=17，但如果直接用这俩，不管怎么拼接都不行。“再来一次子弹飞”可以看出需要解密两次。 第一层：第三句“我的成绩比你好，先后起来你悲催”是关键，原本以为是拼接35635和65312的顺序，结果半天搞不定，甚至考虑了数字的单调性是不是对应“先后”这俩字。结果密钥是65312-35635=29677得到字符串“xxaqdl(p25-12-bstring)U2FsdGVkX199XCqgBzG3McJ1NuWuuPclqBS9lekxPpE=” 第二层：你看这字符串的开头啊：信息安全导论（xxaqdl）第二十五页（p25）第十二行（12）二进制数对应的字符串（bstring5），诶，孤零零一个01000011，第二层密钥就它了，解密时记得把xxaqdl(p25-12-bstring)去掉，后面的才是密文 

循环素数python 题目内容 数字197可以被称为循环素数，因为197的三个数位循环移位后的数字：197,971,719均为素数。100以内这样的数字包括13个，2,3,5,7,11,13,17,31,37,71,73,79,97。要求任意正整数n以内一共有多少个这样的循环素数。 输入格式 一个正整数n。 输出格式 n以内循环素数的数目。 输入样例 100 输出样例 13 importmath defIs_prime(x): foriinrange(2,int(math.sqrt(x))+1): ifx%i==0:returnFalse returnTrue n=int(input()) sum=0 foriinrange(2,n): flag=True num=str(i) forjinrange(len(num)): num=num[1:]+num[:1] temp=int(num) ifnotIs_prime(temp): flag=False break ifflag:sum+=1 print(sum) 

QQ小程序下载文件到本地 通过QQ小程序自带的qq.cloud.downloadFile可将文件从云端下载，并保存至一个临时目录。这时如果我想把文件保存到手机本地怎么办呢？第一个想法是通过QQ小程序自带的qq.saveFile这个API，但是经过尝试后发现，这个保存的文件只有在小程序内部才能查看，而在手机的内部存储中找不到这个文件。所以才有了下面这个比较麻烦的方法，但是可以保存至手机本地。 思路：先将文件转化为图片，再把图片保存至系统相册，最后在手机存储中找到该图片再转化为原文件即可。 （假设下载的是PDF文件） qq.cloud.downloadFile({ fileID:'填入待下载文件的fileID' }) .then((res)=>{ console.log(res.tempFilePath) constsavePath=qq.env.USER_DATA_PATH+'/123.pdf.jpg' qq.getFileSystemManager().saveFile({ tempFilePath:res.tempFilePath, filePath:savePath, success(res){ console.log('save->',res) qq.saveImageToPhotosAlbum({ filePath:savePath, success:(res)=>{ qq.showModal({ title:'文件已保存到手机相册', content:'可在相册中查看文件详细位置，找到文件后将保存的文件后缀名改为[.pdf]即可', confirmColor:'#0bc183', confirmText:'知道了', showCancel:false }) } }) }, fail(){ console.log("下载失败") } }) }) 

主存与内存 计算器内存条采用的是DRAM(动态随机存储器)，即计算机的主存。我们通常所说的内存容量即指内存条DRAM的大小。 但是，严格地说，内存是包括主存与高速缓存(Cache，基于SRAM)的。可能是由于Cache相较内存条容量很小，毕竟内存容量只计内存条大小，加上重要性也不及内存条，所以就忽略了高速缓存Cache，直接将主存等同于内存了。 上图为计算机中存储器的层次结构。早期计算机系统的存储器层次结构只有三层：CPU寄存器、DRAM主存和磁盘存储。不过，由于CPU和主存之间速度差距较大，系统设计者被迫在CPU寄存器和主存之间增加了SRAM高速缓存（Cache）。 

QQ小程序更新数据库记录 QQ小程序的云开发文档中有关于数据库更新数据的相关教程（链接），但是它存在着一个致命的缺陷 不能根据某个或某几个索引进行查找后更新相关记录的数据。但是这个功能其实是很常用的，下面是一种替代方法。 思路：先通过某个索引查找相应记录，再将原记录删除；更新相应属性后，插入新的记录。 首先是数据库的初始化： constdb=qq.cloud.database({ env:'自己创建的云环境ID' }); conststudent=db.collection('student')//取名为"student"的集合索引 删除学号为123456的记录 student.where({ number:'123456' }).remove().then((res)=>{ console.log('删除一条记录',res.data); }); 将相应属性进行更新后，插入新记录 student.add({ data:{//这里一定要把所有属性都写出来 number:'123456', name:'张三',//例：更改姓名属性 } }).then((res)=>{ console.log('增加一条记录：',res.data); }); 这样便可以替代实现根据索引进行查找后更新相应记录的功能。 

Python实现 依次计算一系列给定字符串的字母值，字母值为字符串中每个字母对应的编号值（A对应1，B对应2，以此类推，不区分大小写字母，非字母字符对应的值为0）的总和。 题目内容：依次计算一系列给定字符串的字母值，字母值为字符串中每个字母对应的编号值（A对应1，B对应2，以此类推，不区分大小写字母，非字母字符对应的值为0）的总和。例如，Colin的字母值为3+15+12+9+14=53 输入格式:一系列字符串，每个字符串占一行。 输出格式：计算并输出每行字符串的字母值。 输入样例：ColinABC 输出样例：536 importsys defvalue(s): sum=0 forwordins: ifwordin'abcdefghijklmnopqrstuvwxyz': sum+=ord(word)-ord('a')+1 elifwordin'ABCDEFGHIJKLMNOPQRSTUVWXYZ': sum+=ord(word)-ord('A')+1 returnsum forlineinsys.stdin: line=line.strip() print(value(line)) 

Python实现 汉诺塔问题 题目内容：如在汉诺塔游戏中，我们希望将塔A上的n个盘子，通过塔B移动到塔C，则对于任意输入的n，给出移动的步骤。 输入格式:一个正整数n 输出格式：移动的步骤 输入样例：2 输出样例：Move1fromAtoBMove2fromAtoCMove1fromBtoC defhanoti(n,a,b,c): ifn==1: print('Move',n,'from',a,'to',c) else: hanoti(n-1,a,c,b) print('Move',n,'from',a,'to',c) hanoti(n-1,b,a,c) n=int(input()) hanoti(n,'A','B','C') 

单词计数（python） 使用python实现英文小说中简单的单词计数（去除标点、空格，忽略大小写），统计出现最频繁的50个单词。 importre f=open('emma.txt') d={} forlineinf: words=line.strip().lower().split() words_new=[] forwordinwords: word_new=re.sub(r'[\s+\.\!\/_,$%^*(+\"\']+|[+ ！，。？、~@#￥%……&*（）]+','',word)#过滤中英文标点 words_new.append(word_new) forwordinwords_new: ifwordind: d[word]+=1 else: d[word]=1 word_freq=sorted(d.items(),key=lambdax:x[1],reverse=True)#按出现次数从大到小排序 print(word_freq[:50])#打印出现次数最多的前50个单词 f.close() 测试小说样例下载 

哈工大数字逻辑与数字系统设计大作业（数字密码锁） 哈工大2020数字逻辑大作业 1.设计要求 1.1主要设计要求 （1）设计一个开锁密码至少为4位数字（或更多）的密码锁。（2）当开锁按扭开关（可设置8位或更多，其中只有4位有效，其余位为虚设）的输入代码等于所设密码时启动开锁控制电路，并且用绿灯亮、红灯灭表示开锁状态。（3）从第一个按扭触动后的5秒内若未能将锁打开，则电路自动复位并发出报警信号，同时用绿灯灭、红灯亮表示关锁状态。 1.2附加功能 （1）可以设置密码，在解锁状态下通过设置密码按钮SP设置密码。（2）五秒计时采用倒计时（即从5s计时到0）的方式，将秒数显示在开发板的七段数码管上。五秒后发出警报（警示灯亮）。（3）可以清空密码输入，重新输入密码（不中止计时器）。（4）设置密码及输入密码时，所键入的密码均会显示在开发板的七段数码管上。（5）输入密码错误、设置密码成功、输入密码成功，均会有相应的提示灯亮。 2.工作原理及系统方框图 2.1工作原理 根据系统功能来分析，可将整个系统分为以下4个主要功能模块。（1）编码模块：将输入的4位密码分别转换成8421-BCD码；（2）存储模块：在设置密码后，将密码保存；（3）比较模块：将之后输入的密码和存储的密码进行比较；（4）计时模块：主要体现五秒倒计时的功能。首先通过输入端输入密码，进而通过编码模块将十进制的密码转化成8421-BCD码进行保存，如果是设计密码的状态，则直接将密码保存下来，否则在输入4位密码后调用比较模块，将输入的密码与之前保存的密码进行比较。一旦输入的密码与设置的密码相等，则绿灯亮；否则，会有相应的指示灯闪烁表示输入密码错误。另外，在输入的第一位密码被读取的瞬间，计时模块启动，5s倒计时开始。如果在倒计时期间成功解锁，则立刻中止计时；如果倒计时结束后仍未解锁，则密码锁进入锁死状态，同时警示灯亮起。 2.2系统框图 系统的结构框图如下图所示。 3.各部分模块具体功能及设计思路 3.1编码模块 编码模块的核心功能是将输入的十进制数（0~7）编码为3位二进制数，功能类似于一个8-3编码器，它的主要作用是为其他模块提供数据来源。编码模块的输入和输出都是高电平有效的。 3.2存储模块 通过编码模块，我们已经将输入的十进制数转换成了二进制数。显然，由于需要输入4位密码，也就是4个十进制数，我们就需要保存下4个3位二进制数。我们想通过4个3位寄存器来分别存储这4个3位二进制数。但是，四位密码是依次输入的，这也就意味着4个寄存器是依次工作的，并且一次只能有一个寄存器工作。这里的依次存储功能可以通过一个4位计数器和一个2-4译码器的组合来实现。计数器负责选择每位数，从1-4位计数。为了知道已经输入几位密码而且依次准确地存储，我们将计数器的时钟端脉冲设置为密码输入端按下时产生的上升沿，用来驱动计数器，让计数器从00记到11。进而将计数器的输出端接到译码器的输入端，并且将译码器的输出端分别与4个寄存器的使能端相连接，从而完整实现分别使能四个寄存器，依次存储的功能。另外，要想使每次密码输入端按下时都产生一个脉冲，我们可以用或门来实现，开始时密码输入端都为低电平，只要有一个高电平输入，输出的时钟信号就是高电平，计数器就向下计一个数。另外为了便于用户设置以及输入密码，每当用户输入一位密码（无论是设置密码时还是尝试解锁时），均有一个提示灯闪烁一下表示输入成功。与此同时，用户所输入的密码会通过开发板上的七段数码管显示出来，以便于用户操作。 3.3比较模块 比较模块的核心工作是判断输入的密码与存储模块存储的密码是否相同。我们设计了4个3位的数值比较器来实现比较的功能，如果当前输入的3位二进制数与之前保存的数均相等，则输出1（高电平）。因此，当每个比较器的输出端都为1（表示数值相等）时，密码正确。我们将4个输出端用与门连接，当与门输出1时绿灯亮。每输入一位密码，就会产生一个脉冲，从而触发比较器的工作，依次输入四个密码如果都正确，那么密码锁就会打开。一旦密码正确，绿灯就会亮起，表示解锁成功，与此同时计时器会停止计时，其他的所有指示灯均熄灭。而如果输入的4位密码有误，会有指示灯闪烁以做出提示，此时计时器模块不停止工作。 3.4计时模块 计时模块主要包括分频器、计数器和显示器，能准确通过7段数码管显示秒数，并且能在计时5s后，发出警告（alarm警示灯亮），且使红灯亮。此时，进入复位状态（清空输入，设置的密码保存），即使输入正确密码也不能再使绿灯亮。这里的计时5s可以通过计数器和分频器的组合来实现，由于开发板的时钟频率是100Mhz，可以先将它分频100M，然后计数器每计数1次就代表1s，并且通过一个多多译码器在7段数码管上显示对应的秒数。当输入0~7数字中的任何一个（即开始输入密码）时，5秒倒计时开始，此时复位信号is_locked=0（低电平），其他模块均可以正常工作。一旦5s倒计时结束，就把is_locked设置为1（高电平），即进入锁死状态，并且警示灯亮起。 4.调试过程 4.1计时器的调试 计时器的主要功能是5s倒计时，并且将秒数显示在七段数码管上。倒计时的功能其实相对容易，只要调整分频参数即可实现。最需要调试的其实是计时器的启动和终止，因为尽管计时器是一个相对独立的模块，它的开始和停止很大程度上受到输入密码的控制。我们规定，在设置密码的状态下，计时器不会启动；在尝试解锁时，输入第一位密码后，计时器启动；输入密码正确时，计时器中止；倒计时结束后，计时器中止，如不手动复位，则计时器不再启动。上述功能我们是通过向计时器（timer）模块传递一个start参数进行实现的。首先初始化start<=0。在任何时候，一旦sp==1（即进入设置密码状态），start保持为0；而一旦密码锁已经上锁，尝试输入密码时，更改start<=1；如果倒计时未停止且解锁成功，便立刻将start赋值为0，停止计时。这三种情况都比较好实现，相对复杂的是最后一种情况，即倒计时结束后，计时器需要立刻中止。因为start是传入timer模块的参数，所以在模块内部是不能给start赋值的，正是这一点造成了这种情况的复杂性。不过由于计时器倒计时结束alarm便会变成高电平，我们可以在主模块内部对alarm的值进行判断，一旦alarm==1，则start<=1。 4.2设置及输入密码的调试 我最初的设想是只要pw（输入的密码）值改变，并且是有效值，就把输入转为二进制后保存下来。但是这样做存在一个致命的问题 对于一个reg类型的变量，verilog是不允许它在不同的两个always语句块中被赋值的，比如说我设置了一个clr按钮，一旦按下就清空当前输入的密码，那么清空操作触发的信号其实是posedgeclr，这个操作改变了暂存密码的几个寄存器的值；而在always@(pw)语句块中，肯定也需要修改这几个寄存器的值，这就产生了矛盾。而如果将这两个always语句块合并，又与预期的功能不符，所以这个设想被否定了。我在最后的代码里采用的想法是将这几个模块的处理统一放在一个always@(div_clk)语句块中，在语句块里检测sp，clr是否按下，pw是否有效等等。相对于之前的设想，这里对密码输入、clr操作等的检测的灵敏度一定程度上都下降了，但却能保证所有功能的正常实现。这里div_clk是对系统时钟的一个分频，这里分频的目的是便于用户输入密码 如果时钟频率过高，系统可能会一次读入多个密码；而如果频率过低，输入密码、clr、sp操作的效率就会下降。而只要分频合适，就能够兼顾上述功能的实现。以下是分频以及clr操作的部分代码。 4.3七段数码管显示的调试 七段数码管在开发板的左上方，一共有8组数码管。下图是七段数码管的实物图。但是在这8组数码管下方只标出了两组接口（图中较大的矩形框），这表明一次最多使用两个数码管。另外，在调试中我发现如果只对这两组接口进行赋值，七段数码管是不会有任何显示的，这就类似于数码管没有使能。经过更仔细的观察，我发现在每个七段数码管上方都有一个对应的接口（图中较小的蓝色矩形框），可以把这个看做数码管的使能端，只有在对应接口输入高电平数码管才能正常工作。 4.4各类指示灯的调试 整个系统里有6个指示灯 alarm（警示灯）、red（红灯）、green（绿灯）、work（输入有效）、sp_success（设置密码成功）、fail（输入密码错误）。这些指示灯的设置一方面是便于用户使用，另一方面也是便于调试。指示灯的调试其实是对不同状态的调试，指示灯不同代表密码锁进入了不同的状态。以下是密码锁的几个主要状态以及对应指示灯的情况：（1）复位状态：密码锁启动后的状态 只有红灯亮；（2）设置或输入密码状态：每输入一个有效密码 work灯闪烁一次；（3）设置密码成功状态：设置密码状态下连续读入4位有效密码 sp_success灯闪烁一次；（4）输入密码错误状态：尝试解锁时输入的4位密码错误 fail灯闪烁一次；（5）解锁成功状态 只有绿灯亮；（6）锁死状态：倒计时结束 alarm灯亮。在调试过程中，经常出现的问题是在控制相应灯亮起的同时会忽略关闭其他指示灯，这会造成很多指示灯同时亮起，导致对状态辨别的困难。例如，一旦输入密码正确，便会进入解锁状态，绿灯亮起，但如果忘记对其他指示灯操作，很有可能红灯也是亮起状态，这就产生了一个没有规定过的状态。如果这时又按下了sp按钮，绿灯就必须立马熄灭，因为进入了设置密码状态。下面这段代码展示的是在解锁后对指示灯的配置。 5.设计结论 我设计的电子密码锁有8个数字输入端，能存储4位密码，可以设置、修改密码，能够用绿灯亮表示密码输入正确，警示灯亮表示锁死。除了基本的功能外，我设计的电子密码锁还加入了一些对用户进行提示的功能。例如，倒计时和输入的密码均可以通过七段数码管显示出来，用户可以时刻了解到剩余的开锁时间、输入的密码；为了防止用户误输了密码，我还增加了清空密码输入的clr按钮，一旦按下就会清空密码输入；当设置密码成功、尝试输入密码错误时均会有相应指示灯亮起，以提示用户。在现有基础上，密码锁还可以实现更多的功能。比如增加密码的位数，又比如在设置密码时也可以清空输入，这些都是密码锁可以优化、改进的地方。 6.设计心得与总结 （1）模块化将整个系统划分成若干子模块是非常重要的。模块化的过程是对整个问题分析、理解的过程，也有助于理清整个问题的实现思路。尽管我最后的代码并没有完全依照模块的划分去实现，但是总的思路偏差不大。除此之外，模块化还有一个好处在于如果想添加新的功能，只需要在相应模块里修改即可，而无需考虑整个代码。（2）加注释在编写一个较为复杂的工程时，及时地添加必要的注释是很重要的。写注释不仅仅是为了让别人看懂你的代码，更重要的是为自己理清思路，也便于后续的修改。对我而言，我不是很擅长变量命名，所以我在每个变量后面都加上了注释，如图所示。这样一来，即使我一时忘记了某个变量的含义，也可以通过查看注释很快回想起来。而在主程序中，也可以在if语句、case语句后加上注释，标明某段代码的功能。（3）仿真文件仿真文件可以帮助我验证某段代码的正确性，但一旦代码过多、输入输出变量个数过多，编写仿真文件反而成了一件麻烦的事情。我采取的方法是只针对子模块编写仿真程序，而不对整个工程编写仿真程序，因为那样做不仅费时费力，而且一旦某个变量出错还难以发现。仿真文件测试通过也不能完全保证代码的正确性。有的问题只有把程序烧到板子上的时候才能发现。比如七段数码管的问题，如果只看仿真波形图的话，不会有一点问题，但是在板子上一测试就会发现数码管是不亮的，这时候才会发现问题所在。在板子上进行测试的另一个好处就是直观，也更容易发现一些隐藏的问题。比如我的密码锁共有6个指示灯，如果只看仿真波形图，很不直观，也很难发现问题，而在板子上一测试就会发现有些指示灯没控制好。 总结 这次的大作业很好的锻炼了我独立完成整个工程的能力。我收获到的不仅是代码的编写、调试能力的提升，还有自信心的提升。在代码的编写方面，我体会到了模块化、添加注释的重要性，其实这些都不会花费很多时间，但如果不去做的话就会给后续的调试带去很大的麻烦。而代码的调试也是很有讲究的，在我看来，编写仿真文件、看仿真波形是粗调，可以大致验证代码的正确性；验证通过后再将代码烧录到板子上细调，如果直接烧到板子上调理论上也可以，不过若代码错误较多，是不方便定位错误的。在自信心方面，这次的大作业对我的自信心是一次很大的提升。刚看到这道题目的时候，我是没有什么思路的。但经过细细分析，将问题逐渐分解，编写子模块的代码，组合代码等一系列过程后，我不但基本上完成了整个电子密码锁程序的编写，而且很有成就感，对于解决类似工程问题的信心增加了。 参考文献 [1]李建军,胡苗苗.基于FPGA的电子密码锁系统的设计[J].智能计算机与应用,2019(02):187-188+192.[2]熊军洲.基于FPGA的电子密码锁控制电路设计[J].石家庄职业技术学院学报,2018(06):11-15.[3]王俊博.关于FPGA的电子密码锁系统的设计[J].科学技术创新,2019(26):89-90.[4]康浩,叶翔,王建国,鄢梦林,杨斐.基于FPGA的智能电子密码锁的设计[J].湖北理工学院学报,2014(03):45-49.[5]肖萌萌.电子密码锁控制电路设计[J].黑龙江科技信息,2017(15):38. 附录 附录一：总体设计图 附录二：各模块仿真截图 以下为各个模块的仿真结果截图。 附录三：组员所做工作说明 所有工作均由本人独立完成。 

Ubuntu16.04编译安装最新的OpenCV4.4.0 -获取OpenCV源代码 $gitclonehttps://github.com/opencv/opencv.git 当然了，这个命令要想成功执行首先要安装git库，可通过以下命令行安装 $sudoapt-getinstallgit 执行完这条语句后，第一条语句就可以正常执行了，OpenCV也可以安装完成。但是Linux的网速通常比较慢（也取决于自家Wifi），如果以这种方式安装可能要等较长一段时间，还有可能安装失败。这里推荐大家到网上找OpenCV的Linux版本安装包（.tar.gz结尾），可在Windows上下载，再发送到Linux系统上，这样比较快。 -安装依赖库 #安装cmake $sudoapt-getinstall-ycmake #借助系统自带的opencv简化依赖安装步骤 $sudoapt-getinstall-ylibopencv-dev -编译源代码 $cdopencv $mkdirbuild $cdbuild $cmake.. $make-j10 在cmake编译源代码这部分，网上有很多种版本，但我个人觉得上述写法最为简单，且亲测有效。 -替换已经安装的版本 $sudomakeinstall 到此为止，如果执行正常的话，Ubuntu系统配置OpenCV的目标已经实现！ -Ubuntu系统安装Clion 进而，可通过在Ubuntu系统安装Clion、Clion配置OpenCV实现完整的环境搭建。具体教程见以下博客 Clion安装及配置OpenCV 

Ubuntu16.04双系统安装 1.访问官网下载Ubuntu16.04系统镜像文件 下载地址 2.下载“软碟通”软件，制作系统盘 下载地址（免费下载试用）【制作步骤】 3.磁盘分区，为Ubuntu16.04系统划分存储空间 【分区步骤】：右击计算机 >管理【分区步骤】：右击计算机 >管理 >磁盘管理【分区步骤】：右击计算机 >管理 >磁盘管理 >选择要压缩的盘，右击 >压缩卷【分区步骤】：右击计算机 >管理 >磁盘管理 >选择要压缩的盘，右击 >压缩卷卷 >输入压缩空间量(单位：M，这里压缩50G=51200M）【分区步骤】：右击计算机 >管理 >磁盘管理 >选择要压缩的盘，右击 >压缩卷卷 >输入压缩空间量(单位：M，这里压缩50G=51200M） >压缩后得到50G未分配空间 >分区完成 4.重启电脑，进入BIOS，选择从U盘启动 5.进入系统安装引导 

python实现 检索任意一个整数在prime()函数生成的素数列表中位置（索引）的功能，并返回该位置的索引值，若该数不存在则返回-1。 题目内容：定义一个prime()函数求整数n以内（不包括n）的所有素数（1不是素数），并返回一个按照升序排列的素数列表。使用递归来实现一个二分查找算法函数bi_search()，该函数实现检索任意一个整数在prime()函数生成的素数列表中位置（索引）的功能，并返回该位置的索引值，若该数不存在则返回-1。 输入格式:第一行为正整数n接下来若干行为待查找的数字，每行输入一个数字 输出格式：每行输出相应的待查找数字的索引值 输入样例：102467 输出样例：0-1-13 importmath importsys defprime(n): list=[] foriinrange(2,n): flag=True forjinrange(2,int(math.sqrt(i))+1): ifi%j==0: flag=False break ifflag: list.append(i) returnlist defsearch(list,x): l=0 r=len(list)-1 whilel<=r: mid=(l+r)//2 iflist[mid]==x: returnmid eliflist[mid]>x: r=mid-1 else: l=mid+1 iflist[l]==x: returnl else: return-1 n=int(input()) result=prime(n) forlineinsys.stdin: num=int(line) ifnum<2ornum>=n:#防止越界 print(-1) else: print(search(result,num)) 

欧拉图的判定 通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。而具有欧拉回路的无向图称为欧拉图。本文将通过C语言实现欧拉图的判定。用C语言程序完成欧拉图的判定，主要分为两步，分别是：判断每个顶点的度是否为偶数、判断图是否连通。具体代码如下： #include<stdio.h> #include<stdlib.h> #definemaxn500 inta[maxn][maxn]={0},n; voidinput(void);//输入邻接矩阵 intIs_Even(void);//判断是否每个点度数都为偶数 intWarshall(void);//判断是否连通 intmain() { input(); if(Is_Even()&&Warshall())printf("Yes\n");elseprintf("No\n"); return0; } voidinput(void) { inti,j; printf("请输入顶点个数："); scanf("%d",&n); printf("请输入图的邻接矩阵：\n"); for(i=0;i<n;i++) { for(j=0;j<n;j++) { scanf("%d",&a[i][j]); } } } intIs_Even(void) { intcount,i,j; for(i=0;i<n;i++) { count=0; for(j=0;j<n;j++) { count+=a[i][j]; } if(count%2)return0; } return1; } intWarshall(void) { inti,j,k; for(i=0;i<n;i++) for(j=0;j<n;j++) { if(a[j][i]==1) { for(k=0;k<n;k++) a[j][k]=a[j][k]+a[i][k]-a[j][k]*a[i][k]; } } for(i=0;i<n;i++) for(j=0;j<n;j++) if(a[i][j]==0)return0; return1; } 代码下载 

Ubuntu系统安装Clion及Clion配置OpenCV JetBrainsCLion是由JetBrains公司开发的一款跨平台的C++IDE。通过修改CMakeLists.txt文件可以很方便地链接OpenCV库。 -Ubuntu安装Clion 教程 -Clion配置OpenCV 教程 

杨辉三角形（python） 题目内容：帕斯卡三角形，又称杨辉三角形是二项式系数在三角形中的一种几何排列。帕斯卡三角形通常从第0行开始枚举，并且每一行的数字是上一行相邻两个数字的和。在第0行只写一个数字1，然后构造下一行的元素。将上一行中数字左侧上方和右侧上方的数值相加。如果左侧上方或者右侧上方的数字不存在，用0替代。下面给出6行的帕斯卡三角形：11112113311464115101051编写程序，输入帕斯卡三角形的高度n，然后生成和上面例子一样风格的三角形。 输入格式:一个正整数n 输出格式：相应高度的帕斯卡三角形，两个数字之间有一个空格 输入样例：6 输出样例：11112113311464115101051 importmath defC(m,n): ifm==0orm==n: return1 else: returnmath.factorial(n)//(math.factorial(m)*math.factorial(n-m)) n=int(input()) foriinrange(n): print(''*(n-1-i),end='') forjinrange(i+1): print(C(j,i),end='') print('\n') 

Python实现 实现逆向最大匹配分词算法，即从右向左扫描，找到最长的词并切分。 题目内容：实现逆向最大匹配分词算法，即从右向左扫描，找到最长的词并切分。如句子“研究生命的起源”，逆向最大匹配分词算法的输出结果为“研究生命的起源”。 输入格式:第一行是以utf-8格式输入的词表，每个词之间以空格分隔。接下来是若干行以utf-8格式输入的中文句子。 输出格式：以utf-8格式输出的逆向最大匹配的分词结果，每个词之间使用空格分隔。每个输入对应一行输出。 输入样例：你我他爱北京天安门研究研究生命生命的起源研究生命的起源我爱北京天安门 输出样例：研究生命的起源我爱北京天安门 注：以下是Python3.8的代码实现，如果要用Py2实现需要作相应修改。 #字典生成 defload_dic(s): words=s.split() word_dic=set() max_length=1 forwordinwords: word_dic.add(word) iflen(word)>max_length: max_length=len(word) returnmax_length,word_dic #逆向最大匹配分词 deffmm_word_seg(sentence,word_dic,max_length): end=len(sentence) words=[] whileend>0: forbegininrange(max(end-max_length,0),end): word=sentence[begin:end] ifwordinword_dicorend==begin+1: words.append(word) break end=begin returnwords max_len,word_dic=load_dic(input()) forlineinsys.stdin: words=fmm_word_seg(line,word_dic,max_len) foriinrange(len(words)-1,0,-1): print(words[i],end='') print(words[0]) 亦可参考博客：中文分词 

程序人生-Hello’sP2P（哈工大计算机系统大作业） 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190201018 班 级 1936603 学 生 李昆泽 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘要 本文从多个方面详细分析了hello程序在Linux系统下从诞生到执行结束的整个过程，并且结合课本的相关章节，运用相关的操作工具，对hello在整个过程中出现的各种现象、结果进行了分析与测试，力求加深对计算机系统的理解。 关键词：Linux；hello程序；计算机系统 目录 第1章概述1.1Hello简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2在Ubuntu下编译的命令3.3Hello的编译结果解析3.3.1数据3.3.3类型转换3.3.4算术操作3.3.5关系操作3.3.6数组/指针/结构操作3.3.7控制转移3.3.8函数操作 3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令4.3可重定位目标elf格式4.4Hello.o的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式5.4hello的虚拟地址空间5.5链接的重定位过程分析5.6hello的执行流程5.7Hello的动态链接分析5.8本章小结 第6章hello进程管理6.1进程的概念与作用6.2简述壳Shell-bash的作用与处理流程6.3Hello的fork进程创建过程6.4Hello的execve过程6.5Hello的进程执行6.6hello的异常与信号处理6.7本章小结 第7章hello的存储管理7.1hello的存储器地址空间7.2Intel逻辑地址到线性地址的变换-段式管理7.3Hello的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.5三级Cache支持下的物理内存访问7.6hello进程fork时的内存映射7.7hello进程execve时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章hello的IO管理8.1Linux的IO设备管理方法8.2简述UnixIO接口及其函数8.3printf的实现分析8.4getchar的实现分析8.5本章小结 结论附件参考文献 第1章概述 1.1Hello简介 P2P： GCC编译器驱动程序读取源程序文件并把它翻译成一个可执行目标文件。下图展示了编译系统把hello.c的源程序转化为可执行文件hello的完整过程。 在预处理阶段，预处理器cpp读取需要的系统头文件内容，并把它直接插入程序文本中，结果得到hello.i。 在编译阶段，编译器ccl间文本文件hello.i翻译成hello.s，这是一个汇编语言的程序。 在汇编阶段，汇编器as将hello.s翻译成机器语言指令，并将结果保存在目标文件hello.o中，它以可重定位目标程序的格式存储。 在链接阶段，链接器ld需要将一些库函数合并到hello.o的程序中，最终得到hello的可执行文件。 用户在Ubuntushell键入./hello启动此程序，shell调用fork函数为其产生子进程，hello便成为了进程（process）。O2O： OS的进程管理调用fork函数产生子进程，调用execve函数，进行虚拟内存映射（mmp），并为运行的hello分配时间片以执行取指译码流水线等操作；OS的储存管理以及MMU解决VA到PA的转换，cache、TLB、页表等加速访问过程，IO管理与信号处理综合软硬件对信号等进行处理；程序结束时，shell回收hello进程，内核将其所有痕迹从系统中清除。 1.2环境与工具 硬件环境：IntelCorei7-9750HCPU；2.60GHz；8GBRAM软件环境：Windows1064位；Ubuntu16.04LTS64位开发与调试工具：gcc；edb；gdb；objdump；readelf；codeblocks 1.3中间结果 文件名文件作用hello.i预处理器生成的文件，分析预处理器行为hello.s编译器生成的汇编语言程序，分析编译器行为hello.o可重定位目标程序，分析汇编器行为hello可执行目标程序，分析链接器行为hello.elfhello.o的elf格式，分析汇编器和链接器行为hello.asmhello.o的反汇编，主要是为了分析hello.o_hello.elf可执行文件hello的elf格式，作用是重定位过程分析_hello.asm可执行文件hello的反汇编，作用是重定位过程分析 1.4本章小结 本章主要简要介绍了hello程序P2P、020的过程，列出了实验中生成的中间文件，列出了实验使用的软硬件环境、调试工具等等。 第2章预处理 2.1预处理的概念与作用 概念：根据以符号“#”开头的预处理命令，将所需系统头文件的内容插入到程序文本中，它是在编译之前进行的处理。作用：（1）宏定义：将宏名替换为对应文本；（2）文件包含：根据以字符#开头的命令，修改原始的C程序。主要执行的操作是获取所需的系统头文件，并把它直接插入程序文本中,该过程递归进行，及被包含的文件可能还包含其他文件。（3）条件编译：对于满足if条件的代码进行筛选，只有满足的代码才进行编译。 2.2在Ubuntu下预处理的命令 预处理命令：cpphello.c>hello.i 2.3Hello的预处理结果解析 使用notepad++打开hello.i文件，可以发现整个文件已经被扩展成了3127行。而前面的3000多行就是.c文件中包含的头文件，这里体现的就是预处理器根据以字符“#”开头的命令，修改原始的C程序的结果。 2.4本章小结 本章主要介绍了预处理的概念与作用。对hello.c执行预处理的命令，并结合生成的hello.i文件，解析了hello的预处理结果。 预处理过程是后续所有操作的基础，是不可或缺的重要过程。 第3章编译 3.1编译的概念与作用 编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含函数main的定义，这个过程称为编译。 编译的作用就是将高级语言源程序翻译成等价的目标程序，并且进行语法检查、调试措施、修改手段、覆盖处理、目标程序优化等步骤。 3.2在Ubuntu下编译的命令 命令：gcc–Shello.i–ohello.s 3.3Hello的编译结果解析 3.3.1数据 变量（1）全局变量在程序中sleepsecs被声明为int类型全局变量，且已经被赋值。由于.data节存放已经初始化的全局和静态C变量，编译器首先将sleepsecs在.text代码段中声明为全局变量，然后在.data节设置对齐方式（.align）为4字节对齐，设置类型（.type）为对象，设置大小（.size）为4字节，设置为long类型（.long），其值为2，如下图所示。 我们发现全局变量sleepsecs的类型本来是int，却被转化为了long类型。这是因为隐式转换的规则，并且int转化为long不会丢失数据。（2）局部变量 编译器将局部变量存储在寄存器或者栈空间中。在hello.s中编译器将i存储在栈上空间-4(%rbp)中，如下图所示。（3）对于intargc argc是我们main函数的第一个参数。分析.s文件，我们发现argc首先被保存在了寄存器%edi中，又由于argc后续需要参与判断，编译器还将argc赋值给了-20(%rbp)。（4）字符串 从源程序中可以看出，程序中主要出现了两个字符串 “Usage:Hello学号姓名！\n”和“Hello%s%s\n”。argv[]中也保存的是字符串，这个我们在后续分析数组的时候再具体分析。 在hello.s中我们可以看到字符串“\345\255\246\345\217\267\345\247\223\345\220\215\357\274\201”，这些其实是“学号姓名”的UTF-8格式。 我们可以看到，这两个字符串都是在.rodata声明的，如下图所示。常量 这里的常量主要指常数立即数。常数立即数是直接在汇编代码中存在的，以“$+常数”的形式出现在汇编代码中。3.3.2赋值 源程序中的赋值操作主要有：intsleepsecs=2.5、i=0和i++。 对于intsleepsecs=2.5，根据前一部分的分析，sleepsecs是全局变量，并且直接在.data节中就已经将sleepsecs声明为值为2的long类型数据（隐式转换）。 对于i=0。在hello.s文件中是通过汇编语句movl$0,-4(%rbp)将立即数赋值给局部变量i的。这里使用的是“movl”，这是因为局部变量i是int类型的数据，占4个字节，如下图所示。 而对于i++，在汇编代码中是通过语句addl$1,-4(%rbp)实现的，这里-4(%rbp)中保存的是i的值，因此通过addl达到每次循环让i加1的目的。 3.3.3类型转换 源程序中用到的类型转换主要是隐式类型转换，即intsleepsecs=2.5，将浮点数2.5转化为int类型的整数2，然后由于编译器缺省，int类型又被转换为了long类型。 值得注意的是，2.5被隐式转换之后，变成了2而不是3。这是由于当double或float向int进行类型转换的时候，程序遵循向零舍入的原则。 3.3.4算术操作 汇编语言中算术操作的相关指令如下。 具体到我们的源程序中，算术操作有i++（即i=i+1），这个是通过汇编语句addl$1,-4(%rbp)实现的。除此之外，还有汇编语句subq$32,%rsp。这里对栈指针进行减法操作，目的是开辟一段新的栈空间。 3.3.5关系操作 关系操作的主要汇编指令如下。 比较和测试指令不修改任何寄存器的值，只是设置条件码。汇编代码中主要有两处涉及到关系操作，分别是cmpl$3,-20(%rbp)和cmpl$9,-4(%rbp)。 第一处对应的源代码是argc!=3，汇编代码将其优化为如果argc==3则跳转至后续的语句，如下图所示。 第二处对应的源代码是i<10，这里汇编代码将它优化为了i<=9，编译器会计算-4(%rbp)-9，并设置条件码，随之jle语句利用这些条件码，进行相应的跳转处理。 3.3.6数组/指针/结构操作 源代码中出现的数组主要是argv[]，在向main函数传参时，通过movq%rsi,-32(%rbp)进行参数的传递，把argv数组的首地址保存在栈中。 在后面的循环中，读取了argv中的元素，分别读取了argv[1]和argv[2]，这是通过下述汇编代码实现的。 首先将数组的首地址放到%rax中，然后将它加8或者16，分别获取argv[1]和argv[2]的地址（argv中保存的是指针，占8个字节），然后再通过movq(%rax),%rdx的方式将%rax里保存的地址处的值转移到%rdx中。 3.3.7控制转移 控制转移常常是配合指令CMP和TEST存在的。汇编代码中有两处出现了控制转移。第一处如下图所示。 这里对应的是源代码中的argc!=3，但编译器把它优化为了如果argc==3，则跳转至.L2。 第二处如下图所示。 这里能很明显的看出是一个循环，体现了编译器一种jumptomiddle的翻译方法，-4(%rbp)保存的是i的值，如果i<=9就跳转到.L4，执行循环，否则就执行后面的语句。 3.3.8函数操作 （1）main函数函数调用：main函数被系统启动函数__libc_start_main调用，call指令将下一个指令的地址压入栈中，然后跳转到main执行。参数传递：向main函数传递的参数是argc和argv，分别使用%rdi（%edi）和%rsi存储。函数返回：函数设置%eax为0后就正常退出，使用leave退出。（2）printf函数第一次函数调用：printf函数在具体的汇编代码中被优化为puts函数。第一次参数传递：首先将rdi赋值为字符串“Usage:Hello学号姓名！\n”字符串的首地址（leaq.LC0(%rip),%rdi），然后调用了puts函数，将字符串参数传入。第二次函数调用：这次是直接调用printf函数。第二次参数传递：这次需要传递3个参数，%rdi保存的是“Hello%s%s\n”的首地址，%rsi保存的是argv[1]，%rdx保存的是argv[2]。（3）sleep函数函数调用：通过汇编语句callsleep@PLT调用。参数传递：传入参数的过程为movlsleepsecs(%rip),%eax和movl%eax,%edi，对应于全局变量sleepsecs。（4）getchar函数函数调用：通过汇编语句callgetchar@PLT调用。（5）exit函数函数调用：通过汇编语句callexit@PLT调用。参数传递：通过汇编语句movl$1，%edi将%edi寄存器内容设置为1。 3.4本章小结 本章首先介绍了编译的概念与作用，以及在Ubuntu下编译的指令，然后我们具体到对hello.s文件进行数据、赋值、类型转换、算术操作、关系操作、数组/指针/结构操作以及控制转移和函数操作进行了详细的分析和研究。 第4章汇编 4.1汇编的概念与作用 概念：汇编器（as）将.s汇编程序翻译成机器语言，把这些机器语言指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，这个过程就叫做汇编。作用：汇编的作用就是将高级语言转化为机器可直接识别执行的机器指令代码文件。 4.2在Ubuntu下汇编的命令 汇编的命令：ashello.s-ohello.o 4.3可重定位目标elf格式 键入命令行readelf-ahello.o>hello.elf将elf可重定位目标文件输出定向到文本文件hello.elf中，如下图所示。 ELF格式的可执行目标文件的各类信息如下： ELF头：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型（如x86-64）、节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量。具体截图如下。 .text：已编译程序的机器代码； .rodata：只读数据，比如printf语句中的格式串和开关语句的跳转表； .data：已初始化的全局和静态C变量（局部C变量在运行时保存在栈中）； .bss：未初始化的全局和静态C变量以及所有被初始化为0的全局和静态变量（不占据实际空间）； .symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息，截图如下。 .rel.text：一个.text节中位置的列表，链接器链接时会修改位置，具体截图如下。 该节包括的内容是：偏移量、信息、类型、符号值、符号名称和加数。 其中，偏移量表示需要进行重定向的代码在.text或.data节中的偏移位置；信息包括symbol和type两部分，其中symbol占前4个字节，type占后4个字节，symbol代表重定位到的目标在.symtab中的偏移量，type代表重定位的类型；符号名称是重定位目标的名字；最后的加数表示重定位过程需要加减的常量。 .rel.data：被模块引用或定位的重定位信息（需要被修改）； .debug：一个调试符号表，其条目时程序中定义的全局变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件； .line：原始C源程序的行号和.text节中机器指令之间的映射； .strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。 节头部表：节头表包括节名称，节的类型，节的属性（读写权限），节在ELF文件中所占的长度以及节的对齐方式和偏移量，具体如下图所示。 4.4Hello.o的结果解析 命令行输入：objdump-dhello.o>hello.asm 机器语言指的是二进制的机器指令集合，而机器指令是由操作码和操作数构成的。汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式。 除此之外，还有如下几个具体的区别：（1）分支转移 hello.s文件中分支转移是使用段名称进行跳转的（见图22），而hello.o文件中分支转移是通过地址（重定位地址）进行跳转的（见图23）。（2）函数调用 hello.s文件中，函数调用call后跟的是函数名称（见图24）；而在hello.o文件中，因为这些函数都是共享库函数，它们的地址是不确定的，因此call指令将相对地址全部设置为0，然后在.rela.text节中为其添加重定位条目，等待链接的进一步确定（见图25）。（3）全局变量 hello.s文件中，全局变量的地址是通过段地址+%rip确定的（见图26）；对于hello.o的反汇编来说，则是0+%rip，因为.rodata节中的数据是在运行时确定的，也需要重定位，现在填0占位，并为其在.rela.text节中添加重定位条目（见图27）。 4.5本章小结 本章讨论了从hello.s到hello.o的汇编过程，通过readelf命令查看了可重定位目标elf格式。除此之外，使用了objdump工具得到了hello.o的反汇编代码，并和hello.s进行比较，从而更深刻地理解汇编这一过程。 第5章链接 5.1链接的概念与作用 概念： 链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。作用： 链接使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，我们可以独立的修改和编译那些更小的模块，这也更便于我们维护管理我们的代码。 5.2在Ubuntu下链接的命令 链接命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o或gcchello.o-ohello截图如下。 5.3可执行目标文件hello的格式 输入命令：readelf-ahello>_hello.elf，截图如下。 节头部表截图如下图所示。 5.4hello的虚拟地址空间 使用edb加载hello，通过观察edb的Symbols小窗口，我们发现从虚拟地址从0x400000开始和5.3节中的节头表几乎是一一对应的，如下图所示。 5.5链接的重定位过程分析 命令行：objdump-d-rhello 反汇编截图如下。 下面是对hello.o和hello反汇编后结果的一些对比。（1）_hello.asm比hello.asm多了许多文件节 在hello.asm文件中，我们发现只有.text节。而在_hello.asm（hello的反汇编结果）中，不仅有很多其他的节（例如.init节，.plt节等），而且.text节中的内容也比之前有所增加。（2）hello.asm中的大多是相对偏移地址，而_hello.asm文件中的地址是虚拟地址 在原来的hello.o的反汇编文件中，所用的地址基本上是相对偏移地址。例如把main函数的地址设置为0，其他函数或者跳转在计算地址时都是在此基础上加一个相对偏移量。 而在_hello.asm文件中，由于hello已经是可执行文件了，相关的重定位工作必须已经完成，所有虚拟地址也必须确定。尽管每次链接时动态库的虚拟地址都可能不同，但是当每次链接完成时，所有虚拟地址是唯一确定的。（3）_hello.asm中增加了许多外部链接的共享库函数 链接过程本身就是要把一些外部已经编译好的共享库添加到可执行文件中，所以在反汇编文件中出现这些共享库函数一点都不奇怪，截图如下所示。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。重定位分析： 当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置，它也不知道这个模块引用的外部函数或者全局变量的位置。所以针对最终位置未知的目标引用，它会生成一个重定位条目，告诉链接器在生成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。在把hello.o链接为可执行文件hello的过程中，链接器就是根据.rel_data和.rel_text节中保存的重定位信息对符号或者函数进行重定位的。具体的重定位过程我通过下面的一个例子给出。 以sleepsecs为例，通过查看.rela.text中的重定位信息，我们得到有关sleepsecs的重定位条目如下： r.offset=0x60 r.symbol=sleepsecs r.type=R_X86_64_PC32 r.addend=-4 这些字段告诉链接器修改开始于偏移量0x60处的32位PC相对引用，这样在运行时它会指向sleepsecs变量。对应的重定位算法如下图所示。 下面我们来手动模拟一下计算出sleepsecs虚拟地址的过程。 由于ADDR(s)=ADDR(main)=0x400627，r.offset=0x60， 所以refaddr=ADDR(s)+r.offset=0x4005B0； 又由于ADDR(r.symbol)=0x601058，r.addend=-0x4， 所以*refptr=ADDR(r.symbol)+r.addend–refaddr=0x2009CD 通过如下截图可验证算法的正确性。 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。（1）终端输入：./hello 子程序名程序地址ld-2.23.so!_dl_start0x7f9fb3c11c33ld-2.23.so!_dl_init0x7f9fb3c11c65hello!__libc_start_main@plt0x400574hello!puts@plt0x400643hello!exit@plt0x40064d （2）终端输入：./hello1190201018李昆泽 子程序名程序地址ld-2.23.so!_dl_start0x7fd2a03bcc33ld-2.23.so!_dl_init0x7fd2a03bcc65hello!__libc_start_main@plt0x400574hello!printf@plt（循环调用了10次）0x400680hello!sleep@plt（循环调用了10次）0x40068dhello!getchar@plt0x40069c 5.7Hello的动态链接分析 对于动态共享链接库中位置无关代码，编译器没有办法预测函数的运行时地址，所以需要添加重定位记录，等待动态链接器处理。 在dl_init之前，为了引用全集变量PIC，编译器利用了数据段与代码段的距离是一个运行时常量的事实，在数据段开始的地方创建了全局偏移量表GOT。每个被这个目标模块引用的全局数据目标都有一个8字节条目，还会生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含正确的绝对地址。 在之后的函数调用时，首先跳转到PLT执行.plt中操作，第一次访问跳转时，GOT地址为下一条指令，将函数序号压栈，然后跳转到PLT[0]，在PLT[0]中将重定位表地址压栈，然后访问动态链接器，在动态链接器中使用函数序号和重定位表确定函数运行时地址，重写GOT，再将控制传递给目标函数。之后如果对同样函数调用，第一次访问跳转直接跳转到目标函数。 5.8本章小结 本章首先介绍了链接的概念及作用，以及在linux下链接的命令行；接着对hello的elf格式进行了较为详细的分析，并分析了hello的虚拟地址空间；关于重定位过程的分析，本章通过对比hello和hello.o的反汇编文件，发现了它们之间的差异，了解了重定位在链接和汇编过程中的不同；除此之外，也对整个hello的执行过程进行了跟踪，在最后对hello进行了动态链接分析。 第6章hello进程管理 6.1进程的概念与作用 概念：狭义定义：进程是计算机科学中最深刻，最成功的概念之一。进程的经典定义就是一个执行中程序的实例，进程拥有一个独立的逻辑控制流和私有的地址空间。广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。作用： 在现代计算机中，进程为用户提供了以下假象：我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 作用： Shell是用户与操作系统之间完成交互式操作的一个接口程序，它为用户提供简化了的操作。Shell最重要的功能是命令解释，从这种意义上说，Shell是一个命令解释器。Linux系统上的所有可执行文件都可以作为Shell命令来执行。当用户提交了一个命令后，Shell首先判断它是否为内置命令，如果是就通过Shell内部的解释器将其解释为系统功能调用并转交给内核执行；若是外部命令或实用程序就试图在硬盘中查找该命令并将其调入内存，再将其解释为系统功能调用并转交给内核执行。在查找该命令时分为两种情况：（1）用户给出了命令的路径，Shell就沿着用户给出的路径进行查找，若找到则调入内存，若没找到则输出提示信息；（2）用户没有给出命令的路径，Shell就在环境变量PATH所制定的路径中依次进行查找，若找到则调入内存，若没找到则输出提示信息。处理流程： Shell从终端读入输入命令。如果是内置命令则立即执行。否则调用相应的程序为其分配子进程并运行。总之就是对其求值。1．Shell首先从命令行中找出特殊字符（元字符），在将元字符翻译成间隔符号。元字符将命令行划分成小块tokens。Shell中的元字符如下所示：SPACE,TAB,NEWLINE,&,;,(,),<,>,|2．程序块tokens被处理，检查看他们是否是shell中所引用到的关键字。3．当程序块tokens被确定以后，shell根据aliases文件中的列表来检查命令的第一个单词。如果这个单词出现在aliases表中，执行替换操作并且处理过程回到第一步重新分割程序块tokens。4．Shell对~符号进行替换。5．Shell对所有前面带有$符号的变量进行替换。6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用$(command)标记法。7．Shell计算采用$(expression)标记的算术表达式。8．Shell将命令字符串重新划分为新的块tokens。这次划分的依据是栏位分割符号，称为IFS。缺省的IFS变量包含有：SPACE,TAB和换行符号。9．Shell执行通配符*?[]的替换。10．shell把所有從處理的結果中用到的注释删除，並且按照下面的顺序实行命令的检查：A.内建的命令B.shell函数（由用户自己定义的）C.可执行的脚本文件（需要寻找文件和PATH路径）11．在执行前的最后一步是初始化所有的输入输出重定向。12．最后，执行命令。 6.3Hello的fork进程创建过程 父进程通过调用fork函数就创建一个新的运行的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈.子进程进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。其函数原型为pid_tfork(void)；对于返回值，若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1。 而对于hello来说，我们想要运行hello这个可执行文件时，需要在终端输入命令（例如./hello），我们输入的命令会被判断为非内置命令，然后shell试图在硬盘上查找该命令（即hello可执行程序），并将其调入内存，然后shell将其解释为系统功能调用并转交给内核执行。 shell执行fork函数，创建一个子进程。这时候我们的hello程序就开始运行了。hello子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。于此同时Linux将复制父进程的地址空间给子进程，因此，hello进程就有了独立的地址空间。 6.4Hello的execve过程 execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有当出现错误时，（例如找不到filename时），execve才会返回到调用程序。所以，与fork一次调用返回两次不同，execve调用一次并从不返回。 execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行程序，加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。最后加载器设置PC指向_start地址，_start最终调用main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制。这时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 对于hello来说，execve首先在当前进程的上下文中加载并运行新程序hello，然后调用启动代码，启动代码设置栈，并将控制传递给新程序的主函数，该函数有以下原型：intmain(intargv,char**argv,char**envp)或者等价的intmain(intargc,char*argv[],char*envp)。 当主函数开始执行时，用户栈的组织结构如下图所示。从栈底往栈顶看，首先是参数和环境字符串。紧随其后的是以null结尾的指针数组，其中每个指针都指向栈中的一个环境变量字符串。全局变量environ指向这些指针中的第一个envp[0]。紧随环境变量之后的是以null结尾的argv[]数组，其中每个元素都指向栈中的一个参数字符串。在栈的顶部是系统启动函数libc_start_main的栈帧。 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占进程所需的状态。它包含进程运行所需要的一些寄存器、用户栈以及数据结构等等。在内核调度了一个新的进程运行时，它会首先保存当前进程的上下文，然后恢复某个先前被强占的进程被保存的上下文，最后将控制传递给这个新恢复的进程。 调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被强占的进程。这种决策就叫调度（是由内核中的调度器的代码处理的）。在调度的过程中，可能会出现多个进程轮流运行的情况，这个概念就称为多任务，而多任务也叫做时间分片。用户态与核心态转换： 进程hello一开始运行在用户模式中，直到它通过执行系统调用函数sleep或者exit时便进入到内核模式。由于sleep函数的特殊性，内核此时可能会将hello进程休眠，转而执行一个其他的进程。待内核中的处理程序完成对系统函数的调用后，再执行上下文切换，将控制返回给进程hello系统调用之后的那条语句。 6.6hello的异常与信号处理 异常可以分为四类：中断、陷阱、故障和终止。下图对这些类别的属性做了小结。 而在hello的执行过程中，主要会遇到中断（键盘上敲击CTRL-C或者CTRL-Z）和陷阱（系统调用）的异常； 主要会产生SIGINT（来自键盘的中断），SIGSTP（来自终端的停止信号）等信号； 对于中断异常，处理情况如图； 对于陷阱，处理情况如图。运行截图（1）CTRL-Z（2）ps（3）jobs（4）pstree（5）fg（6）kill（7）输入乱码（8）CTRL-C异常与信号的处理 对于CTRL-C或者CTRL-Z，键盘键入后，内核就会发送SIGINT或者SIGSTP信号。SIGINT信号默认终止前台作业，即终止程序hello，SIGSTP默认挂起前台的hello作业。 对于fg信号，内核发送SIGCONT信号，我们刚刚挂起的程序hello重新在前台运行。 对于kill-93381。内核发送SIGKILL信号给我们指定的pid（hello程序），结果杀死了hello程序。 6.7本章小结 在本章中，首先简单介绍了进程的概念和作用，并在此基础上简述了壳Shell-bash的作用与处理流程。然后对可执行文件hello进行了具体的分析，分别分析了hello的fork过程、execve过程、进程执行过程，最后分析了hello在执行过程中可能遇到的异常和信号处理，并进行了测试。 第7章hello的存储管理 7.1hello的存储器地址空间 （1）逻辑地址 逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址，是由一个段标识符加上一个指定段内相对地址的偏移量。（2）线性地址 线性地址是逻辑地址到物理地址变换之间的中间层。hello程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。（3）虚拟地址 虚拟地址是程序运行在保护模式下，程序访问存储器所使用的逻辑地址称为虚拟地址。在保护模式中，在程序从磁盘加载进内存的中间加了一个中间层，即就是虚拟地址，在程序编译，链接的时候先映射进虚拟地址，在运行的时候会再映射进物理地址。这样的好处在于，在虚拟地址中，hello程序的虚拟地址，不管通过如何偏移，它都在虚拟地址中，最后再映射进物理地址，不会影响到其他的程序，起到了进程隔离，保护了其他的进程。（4）物理地址 物理地址用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。这个概念应该是这几个概念中最好理解的一个，但是值得一提的是，虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽象，内存的寻址方式并不是这样。另外，如果启用了分页机制，那么hello的线性地址会使用页目录和页表中的项变换成hello的物理地址；如果没有启用分页机制，那么hello的线性地址就直接成为物理地址了。 7.2Intel逻辑地址到线性地址的变换-段式管理 分段过程实质就是从逻辑地址到线性地址的过程。整个过程如下图所示。 逻辑地址实际是由48位组成的，前16位是段选择符，后32位是段内偏移量。通过段选择符，我们可以获得段基址，再与段内偏移量相加，即可获得最终的线性地址。 段选择符的16位格式如下图所示。其中， 索引：“描述符表”的索引； TI：如果TI是0，那么描述符表是全局描述符表（GDT）；如果TI是1，描述符表是局部描述表（LDT）。 RPL：表示段的级别。为0，位于最高级别的内核态；为11，位于最低级别的用户态。在linux中也仅有这两种级别。 被选中的段描述符先被送至描述符的cache中，每次从描述符cache中取出32位段基址，再与32位段内偏移量（有效地址）相加得到线性地址，截图如下。 7.3Hello的线性地址到物理地址的变换-页式管理 如果不考虑TLB与多级页表，虚拟地址可以分为虚拟页号VPN和虚拟页偏移量VPO。其中，VPN可以作为到页表中的索引。进而，通过页表基址寄存器（PTBR）我们可以在页表中获得条目PTE。一条PTE中包含有效位和物理页号（PPN）。如果有效位是0，则代表页面不在存储器中（缺页）；如果有效位是1，则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，再与物理页偏移量（PPO）共同构成物理地址PA。具体截图如下。 注意，因为物理和虚拟页面都是P字节的，所以PPO和VPO是相同的。 当页面命中时CPU硬件执行的步骤： 第1步：处理器生成一个虚拟地址，并把它传送给MMU； 第2步：MMU生成PTE地址，并从高速缓存/主存请求得到它； 第3步：高速缓存/主存向MMU返回PTE； 第4步：MMU构造物理地址，并把它传送给高速缓存/主存； 第5步：高速缓存/主存返回所请求的数据字给处理器。 7.4TLB与四级页表支持下的VA到PA的变换 TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块，TLB通常具有高度的相联度。 用以组选择和行匹配的索引和标记字段是从虚拟地址的虚拟页号中提取出来的，在TLB中寻址的过程其实和在cache中寻址的过程有点类似。下图展示了当TLB命中时（通常情况）所包括的步骤，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。 第1步：CPU产生一个虚拟地址； 第2步和第3步：MMU从TLB中取出相应的PTE； 第4步：MMU将这个虚拟地址翻译成一个物理地址，并将它发送到高速缓存/主存； 第5步：高速缓存/主存将所请求的数据字返回给CPU。四级页表： 使用层次结构的页表是为了压缩页表所占的空间。 在Corei7MMU中，36位VPN被划分成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 7.5三级Cache支持下的物理内存访问 通过上一节中的页表翻译，我们终于得到了物理地址PA，下面我们的工作时利用物理地址寻找相应的数据。 首先使用物理地址的CI进行组索引（每组8路），对8个块分别对CT进行标志位的匹配。如果匹配成功且块的有效位为1，则成功命中。然后根据数据偏移量CO取出相应的数据并返回。这里的数据是保存在L1中的，也就是一级Cache。 如果没有命中，或者没找到相匹配的标志位，那么就会在下一级Cache中寻找，这里可能是二级Cache甚至三级Cache，只要本级Cache中没找到就要去下一级的Cache中寻找数据，然后逐级写入Cache。 在更新Cache的时候，首先需要判断是否有有效位为0的块。若有，则直接写入；若不存在，则需要驱逐一个块（LRU策略），再进行写入。 7.6hello进程fork时的内存映射 虚拟内存和内存映射解释了fork函数如何为hello进程提供私有的虚拟地址空间。 当fork函数被hello进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello创建出的这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 在fork在新进程中返回时，新进程的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任意一个进行写操作时，由于写时复制机制的作用，会创建一个新的页面，也就为每个进程保持了私有地址空间的概念。 7.7hello进程execve时的内存映射 虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。假设运行在当前进程中的程序执行了如下的execve调用： execve(“hello”,NULL,NULL); 加载并运行hello需要以下的几个步骤：（1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。（2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆地址也是请求二进制零的，初始长度为零。（3）映射共享区域。hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。（4）设置程序计数器（PC）。execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，他将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 7.8缺页故障与缺页中断处理 处理缺页要求硬件和操作系统内核协作完成，具体操作如下。 第1步：处理器生成一个虚拟地址，并把它传送给MMU； 第2步：MMU生成PTE地址，并从高速缓存/主存请求得到它； 第3步：高速缓存/主存向MMU返回PTE； 第4步：PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序； 第5步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘； 第6步：缺页处理程序页面调人新的页面，并更新内存中的PTE； 第7步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令，CPU将地址重新发送给MMU。因为虚拟页面现在已经缓存在物理内存中，所以会命中，主存将所请求字返回给处理器。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器(explicitallocator)，要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。C++中的new和delete操作符与C中的malloc和free相当。 隐式分配器(implicitallocator)，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器(garbagecollector)，而自动释放未使用的已分配的块的过程叫做垃圾收集(garbagecollection)。例如，诸如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 显式分配器必须在严格的约束条件下工作，约束有：必须处理任意请求序列；立即响应请求；只使用堆；对齐块；不修改已分配的块。分配器的编写应该实现：吞吐率最大化；内存使用率最大化（两者相互冲突）。 在分配器的具体实现中，主要有以下几种实现方法：（1）隐式空闲链表 隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要求对空闲链表进行搜索，该搜索时间与堆中已分配块和空闲块的总数呈线性关系。（2）带边界标记的隐式空闲链表 这种方式可以允许在常数时间进行对前面块的合并，并且它对许多不同类型的分配器和空闲链表组织都是通用的。然而它也存在一个潜在的缺陷。它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销。（3）显式空闲链表 堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。这样一来，会使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。显式空闲链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。 7.10本章小结 本章就hello的地址管理展开了一系列讨论。首先介绍了各类地址的概念以及在程序运行中充当的角色，接着进一步分析了从逻辑地址到线性地址的变化（段式管理），以及从线性地址到物理地址的变化（页式管理）。然后借TLB与四级页表支持下的VA到PA的变换详细分析了地址翻译的过程。紧接着分析了三级Cache支持下的物理内存访问，以及hello进程fork和execve时的内存映射，还有缺页故障与缺页中断处理的操作过程。最后通过动态存储分配管理这一节对之前的内容进行了一个整体的梳理，较为完整地阐明了动态内存分配的过程。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，所有的输入输出都被当作对相应文件的读和写来执行。设备管理：unixio接口 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 UnixI/O接口（1）打开文件 一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息，应用程序只需要记住这个描述符。（2）linuxshell 创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO、STOOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值。（3）改变当前的文件位置 对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。（4）读写文件 一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。（5）关闭文件 当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。函数（1）打开文件 函数原型：intopen(char*filename,intflags,mode_tmode); open函数将filename转换为一个文件描述符，并且返回描述符数字。flags参数指明了进程打算如何访问这个文件，mode参数则指定了新文件的访问权限位。（2）关闭文件 函数原型：intclose(intfd); 关闭描述符为fd的文件，关闭一个已关闭的描述符会出错。（3）读和写文件 函数原型： ssize_tread(intfd,void*buf,size_tn); ssize_twrite(intfd,constvoid*buf,size_tn); read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。返回值：成功则返回写的字节数，出错则为-1。 8.3printf的实现分析 我们先来看printf的源码： 这里va_list是char类型的指针，表示arg是…中的第一个参数的地址。另外，我们发现在printf函数里分别调用了vsprintf和write函数，下面对这两个函数一一分析。 很容易看出，vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 我们发现vsprintf函数中也调用了write函数，下面我们来追踪一下write函数的汇编代码。 在write函数中，将栈中参数放入寄存器，ecx存放字符个数，ebx存放第一个字符地址，intINT_VECTOR_SYS_CALLA代表通过系统调用sys_call。从这里我们也可以看出write是一个系统函数。下面是sys_call的汇编代码。 sys_call函数实现的功能就是把将要输出的字符串从总线复制到显卡的显存中。显存中存储的是字符的ASCII码。字符显示驱动子程序通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。至此，就完成了对printf函数的分析，也完成了字符串的整个输出过程。 8.4getchar的实现分析 （1）当运行到getchar函数时，程序将控制权交给os。在进行输入时，内容会先进入缓存区，并在屏幕上回显。直到我们键入Enter，通知os输入完成，这时才再将控制权交还给程序。（2）异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。（3）getchar调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章介绍了Linux的I/O设备管理方法，简述了UnixIO接口及其函数，并对printf和getchar的实现进行了较为具体的分析。 结论 hello所经历的过程：（1）编写阶段，通过编写工具编写出hello.c；（2）预处理阶段，预处理器cpp读取需要的系统头文件内容，并把它直接插入程序文本中，结果得到hello.i；（3）编译阶段，编译器ccl间文本文件hello.i翻译成hello.s；（4）汇编阶段，汇编器as将hello.s翻译成机器语言指令，并将结果保存在目标文件hello.o中；（5）链接阶段，链接器ld需要将一些库函数合并到hello.o的程序中，最终得到hello的可执行文件；（6）运行阶段：用户在Ubuntushell键入./hello启动此程序，shell调用fork函数为其产生子进程，并由execve函数加载运行当前进程的上下文中加载并运行新程序hello；（7）进程执行：内核为每个进程维持一个上下文，在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被强占的进程。所以hello进程不是一直在执行的；（8）存储管理：在hello所经历的过程中，会产生各种地址，但最终我们真正期待的是物理地址，MMU将程序中使用的虚拟内存地址通过页表映射成物理地址；（9）信号与异常：在hello的运行过程中可能会出现各种信号或者异常，内核会对这些信号进行处理；（10）结束：hello最终被shell父进程回收，内核会收回为其创建的所有信息。感悟： 这本教材的名字叫《深入理解计算机系统》，而我才刚刚入了门，远远谈不上是“深入理解”。但是仅凭目前这一点对计算机系统的初步认识，我就已经觉得这是一个无比复杂，同时也无比精妙的系统。计算机是由很多部分组成的，这些部分既有明确的分工，又相互合作，最终成就了现在的计算机。这些部分在现在看来合情合理，但是在第一台计算机出现之前，没有人知道计算机应该由哪些部分组成，应该怎样去计算。 计算机系统这门课的学问很深，其中包含的是一代代计算机科学家的心血，这些不是仅仅通过这一门课所能够学完的，我们还需要在以后的实践中沉下心来，细细研究其中的学问。 附件 文件名文件作用hello.i预处理器生成的文件，分析预处理器行为hello.s编译器生成的汇编语言程序，分析编译器行为hello.o可重定位目标程序，分析汇编器行为hello可执行目标程序，分析链接器行为hello.elfhello.o的elf格式，分析汇编器和链接器行为hello.asmhello.o的反汇编，主要是为了分析hello.o_hello.elf可执行文件hello的elf格式，作用是重定位过程分析_hello.asm可执行文件hello的反汇编，作用是重定位过程分析 参考文献 [1]RandalE.Bryant,DavidR.O’Hallaon.深入理解计算机系统.第三版.北京：机械工业出版社[M].2018：1-737.[2]伍之昂.LinuxShell编程从初学到精通.北京：电子工业出版社.2011：1-59.[3]Cjacker.CmakePractice.1-47.[4]yjbjingcha.进程控制在进程管理中的作用.https://www.cnblogs.com/yjbjingcha/p/7040290.html.[5]madao756.段页式访存 逻辑地址到线性地址的转换.https://www.jianshu.com/p/fd2611cc808e.[6]madao756.段页式访存 线性地址到物理地址的转换.https://www.jianshu.com/p/c78cdf6214b5.[7]Pianistx.printf函数实现的深入剖析.https://www.cnblogs.com/pianist/p/3315801.html 

Python实现 若已知1800年1月1日为星期3，则对于一个给定的年份和月份，输出这个月的最后一天是星期几。 题目内容：若已知1800年1月1日为星期3，则对于一个给定的年份和月份，输出这个月的最后一天是星期几。 输入格式:两行整数，分别代表年份和月份 输出格式：星期数，0代表星期日 输入样例：203312 输出样例：6 defIs_leap_year(year): ifyear%400==0oryear%4==0andyear%100!=0: returnTrue else: returnFalse defDays_in_months(year,month): ifmonthin(1,3,5,7,8,10,12): return31 elifmonthin(4,6,9,11): return30 elifIs_leap_year(year): return29 else: return28 defTotal_days(year,month): days=0 foryinrange(1800,year): ifIs_leap_year(y): days+=366 days%=7 else: days+=365 days%=7 forminrange(1,month+1): days+=Days_in_months(year,m) days%=7 return(days+2)%7 year=int(input()) month=int(input()) print(Total_days(year,month)) 

学生成绩管理系统（C语言大作业） 设计一个学生成绩管理系统，包括学生成绩数据的增删改查等基本操作，通过编程实现如下菜单驱动的学生成绩管理系统：（1）录入每个学生的学号、姓名和各科考试成绩；（2）计算每门课程的总分和平均分；（3）计算每个学生的总分和平均分；（4）按每个学生的总分由高到低排出名次表；（5）按每个学生的总分由低到高排出名次表；（6）按学号由小到大排出成绩表；（7）按姓名的字典顺序排出成绩表；（8）按学号查询学生排名及其考试成绩；（9）按姓名查询学生排名及其考试成绩；（10）按优秀（90-100）、良好（80-89）、中等（70-79）、及格（60-69）、不及格（0-59）5个类别，对每门课程分别统计每个类别的人数以及所占的百分比；（11）输出每个学生的学号、姓名、各科考试成绩，以及每门课程的总分和平均分；（12）将每个学生的记录信息写入文件；（13）从文件中读出每个学生的记录信息并显示。 输入 首先，用户输入菜单选项（自然数0-13），程序会对非法输入进行判断，并提示用户重新输入。另外，当用户输入0-13中的某个数时，未必都是合法的。例如在输入1或13之前输入其他数字，即在录入成绩之前进行其他操作。程序亦会对此类非法输入进行判断并提示重新输入。 程序支持用户先后输入多个菜单选项，程序会在完成当前菜单选项的任务之后再次在屏幕上打印出菜单，以供用户再次选择，直至用户输入0终止程序。 为了节省空间，程序会采用动态分配内存的方式，这也就要求程序必须预先知道所需空间的大小。为了达到这一目的，在录入成绩时，程序会提示用户输入学生人数、课程门数（均为整型）以确定所需空间大小。 进而，在录入成绩的时候会涉及到不同类型的变量（学号（长整型）、姓名（字符串）、成绩（整型））。程序会提供表头，用户只需对应表头输入相应信息即可。在这里，程序默认输入的学生姓名无空格。 除此之外，用户无需输入大量数据，在个别菜单选项中，用户只需根据提示信息输入少量数据即可。若输入数据不合法，程序亦会提示用户重新输入。并且，程序中加入了对文件打开失败、动态内存分配不成功等异常情况的处理，以增强程序的健壮性。 输出 考虑到表格更直观，可读性更好，程序的输出主要以表格的形式。 另外，由于每次录入的学生学号、姓名长度会有所不同，程序中加入了对它们长度的判断，以较为对齐的方式输出表格，让用户阅读时更为舒适且不易出错。 当然，对于一些重要信息（例如学生的排名）程序是换行单独输出的，这样的考虑是为了让用户能更清楚地了解到一些重要信息。 代码 代码下载 #include<stdio.h> #include<stdlib.h> #include<string.h> #include"windows.h" intNumOfStudent,NumOfCourse,flag,*Total; typedefstructstudent { longintnum; charname[100]; intscore[10]; intrank; }STUDENT; STUDENT*stu; voidMenu();//函数、变量声明 intInput_Choice(); voidTable_Head(); voidData(); intLegal_Input(); voidInput_Data(); voidCourse_Score(STUDENTstu[]); voidStudent_Score(STUDENTstu[]); voidDownSort(int*Total); voidUpSort(int*Total); voidID_Sort(STUDENTstu[]); voidName_Sort(STUDENTstu[]); voidQuickSort(inta[],STUDENTb[],intlow,inthigh); voidswap(inta[],STUDENTb[],intlow,inthigh); intpartion(inta[],STUDENTb[],intlow,inthigh); voidSearch_Number(); voidSearch_Name(); voidStatistic(); voidOutput_Data(); voidwfile(); voidrfile(); voidMenu()//显示菜单 { printf("1.Inputrecord\n"); printf("2.Calculatetotalandaveragescoreofeverycourse\n"); printf("3.Calculatetotalandaveragescoreofeverystudent\n"); printf("4.Sortindescendingorderbytotalscoreofeverystudent\n"); printf("5.Sortinascendingorderbytotalscoreofeverystudent\n"); printf("6.Sortinascendingorderbynumber\n"); printf("7.Sortindictionaryorderbyname\n"); printf("8.Searchbynumber\n"); printf("9.Searchbyname\n"); printf("10.Statisticanalysisforeverycourse\n"); printf("11.Listrecord\n"); printf("12.Writetoafile\n"); printf("13.Readfromafile\n"); printf("0.Exit\n"); printf("Pleaseenteryourchoice:\n"); } intInput_Choice()//输入菜单选项 { intchoice,check; B: check=scanf("%d",&choice); while(check!=1||choice<0||choice>13) { while(getchar()!='\n'); printf("InputError!Pleaseenteryourchoiceagain:\n"); check=scanf("%d",&choice); } if(choice==1||choice==13||choice==0)flag=1; if(!flag) { printf("InputError!Pleaseenteryourchoiceagain:\n"); gotoB; } elsereturnchoice; } voidTable_Head()//输出成绩表表头 { inti; printf("IDnumberName"); for(i=1;i<=NumOfCourse;i++)printf("Course%d",i); printf("\n"); for(i=1;i<=NumOfCourse*9+14;i++)printf("-"); printf("\n"); } voidData()//输出成绩表主体数据 { inti,j; for(i=0;i<NumOfStudent;i++) { printf("%8ld%s",stu[i].num,stu[i].name); for(j=0;j<NumOfCourse;j++)printf("%3d",stu[i].score[j]); printf("\n"); } } intLegal_Input()//合法化输入 { intn,check; check=scanf("%d",&n); while(check!=1||n<0) { while(getchar()!='\n'); printf("InputError!Pleaseenteragain:\n"); check=scanf("%d",&n); } returnn; } voidInput_Data()//功能1：录入每个学生的学号、姓名和各科考试成绩 { inti,j; printf("Pleaseenterthenumberofstudents:\n"); NumOfStudent=Legal_Input(); printf("Pleaseenterthenumberofcourses:\n"); NumOfCourse=Legal_Input(); stu=(STUDENT*)calloc(NumOfStudent,sizeof(STUDENT)); Total=(int*)calloc(NumOfStudent,sizeof(int)); if(stu==NULL||Total==NULL) { printf("callocerror!\n");//内存申请不成功的处理 } Table_Head(); for(i=0;i<NumOfStudent;i++) { scanf("%ld",&stu[i].num); scanf("%s",stu[i].name); for(j=0;j<NumOfCourse;j++) { stu[i].score[j]=Legal_Input(); Total[i]+=stu[i].score[j]; } } QuickSort(Total,stu,0,NumOfStudent-1); for(i=NumOfStudent-1;i>=0;i--)stu[i].rank=NumOfStudent-i; } voidCourse_Score(STUDENTstu[])//功能2：计算每门课程的总分和平均分 { longinttotal=0; inti,j; printf("totalaverage\n"); for(i=0;i<NumOfCourse;i++) { total=0; for(j=0;j<NumOfStudent;j++) total+=stu[j].score[i]; printf("Course%d:%5ld%.2f\n",i+1,total,(double)total/NumOfStudent); } } voidStudent_Score(STUDENTstu[])//功能3：计算每个学生的总分和平均分 { inti; printf("totalaverage\n"); for(i=0;i<NumOfStudent;i++) { printf("%s:%5d%.2f\n",stu[i].name,Total[i],(double)Total[i]/NumOfCourse); } } voidDownSort(int*Total)//功能4：按每个学生的总分由高到低排出名次表 { inti,j; QuickSort(Total,stu,0,NumOfStudent-1); Table_Head(); for(i=NumOfStudent-1;i>=0;i--) { stu[i].rank=NumOfStudent-i; printf("%8ld%s",stu[i].num,stu[i].name); for(j=0;j<NumOfCourse;j++)printf("%3d",stu[i].score[j]); printf("\n"); } } voidUpSort(int*Total)//功能5：按每个学生的总分由低到高排出名次表 { QuickSort(Total,stu,0,NumOfStudent-1); Table_Head(); Data(); } voidID_Sort(STUDENTstu[])//功能6：按学号由小到大排出成绩表 { longintnumber[100]; inti; for(i=0;i<NumOfStudent;i++)number[i]=stu[i].num; QuickSort(number,stu,0,NumOfStudent-1); Table_Head(); Data(); } voidName_Sort(STUDENTstu[])//功能7：按姓名的字典顺序排出成绩表 { inti,j; STUDENTtemp; for(i=0;i<NumOfStudent-1;i++) for(j=i+1;j<NumOfStudent;j++) { if(strcmp(stu[i].name,stu[j].name)>0) { temp=stu[i]; stu[i]=stu[j]; stu[j]=temp; } } Table_Head(); Data(); } voidQuickSort(inta[],STUDENTb[],intlow,inthigh)//快速排序 { intpoint; if(low<high) { point=partion(a,b,low,high); QuickSort(a,b,low,point-1); QuickSort(a,b,point+1,high); } } voidswap(inta[],STUDENTb[],intlow,inthigh) { inttemp=a[low]; a[low]=a[high]; a[high]=temp; STUDENTtemp2; temp2=b[low]; b[low]=b[high]; b[high]=temp2; } intpartion(inta[],STUDENTb[],intlow,inthigh) { intkey=a[low]; while(low<high) { while(low<high&&a[high]>=key) { high--; } swap(a,b,low,high); while(low<high&&a[low]<=key) { low++; } swap(a,b,low,high); } returnhigh; } voidSearch_Number()//功能8：按学号查询学生排名及其考试成绩 { longintnumber[100],key; inti,j,l,r,mid; for(i=0;i<NumOfStudent;i++)number[i]=stu[i].num; QuickSort(number,stu,0,NumOfStudent-1); printf("Enterthenumberyouwanttosearch:\n"); scanf("%ld",&key); l=0;r=NumOfStudent-1; while(l<r) { mid=(l+r)/2; if(key==number[mid]) { Table_Head(); printf("%8ld%s",stu[mid].num,stu[mid].name); for(j=0;j<NumOfCourse;j++)printf("%2d",stu[mid].score[j]); printf("\n"); printf("rank:%d\n",stu[mid].rank); return; } if(key>number[mid])l=mid+1; if(key<number[mid])r=mid-1; } if(key==number[r]) { Table_Head(); printf("%8ld%s",stu[r].num,stu[r].name); for(j=0;j<NumOfCourse;j++)printf("%2d",stu[r].score[j]); printf("\n"); printf("rank:%d\n",stu[r].rank); return; } printf("Notfound!\n"); } voidSearch_Name()//功能9：按姓名查询学生排名及其考试成绩 { charkey[100]; inti,j,k,len,flag,count=0; printf("Enterthenameyouwanttosearch:\n"); scanf("%s",key); len=strlen(key); for(i=0;i<NumOfStudent;i++) { for(j=0;j<=strlen(stu[i].name)-len;j++) { flag=1; for(k=j;k<j+len;k++) { if(stu[i].name[k]!=key[k-j]) { flag=0; break; } } if(flag) { if(!count)Table_Head(); count++; printf("%8ld%s",stu[i].num,stu[i].name); for(k=0;k<NumOfCourse;k++)printf("%2d",stu[i].score[k]); printf("\n"); printf("rank:%d\n",stu[i].rank); break; } } } if(!count)printf("Notfound!\n"); } voidStatistic()//功能10：按优秀（90~100）、良好（80~89）、中等（70~79）、及格（60~69）、不及格（0~59）5个类别，对每门课程分别统计每个类别的人数以及所占的百分比 { inti,j,a,b,c,d,e; printf("ABCDE\n"); for(i=0;i<NumOfCourse;i++) { printf("Course%d",i+1); a=b=c=d=e=0; for(j=0;j<NumOfStudent;j++) { switch(stu[j].score[i]/10) { case10: case9:a++; break; case8:b++; break; case7:c++; break; case6:d++; break; default:e++; } } printf("%2d(%.1f%%)",a,(double)a/NumOfStudent*100); printf("%2d(%.1f%%)",b,(double)b/NumOfStudent*100); printf("%2d(%.1f%%)",c,(double)c/NumOfStudent*100); printf("%2d(%.1f%%)",d,(double)d/NumOfStudent*100); printf("%2d(%.1f%%)\n",e,(double)e/NumOfStudent*100); } } voidOutput_Data()//功能11：输出每个学生的学号、姓名、各科考试成绩，以及每门课程的总分和平均分 { Table_Head(); Data(); Course_Score(stu); } voidwfile()//功能12：将每个学生的记录信息写入文件 { FILE*fout; inti,j; fout=fopen("E://output.txt","w"); if(fout==NULL) { printf("Failedtowrite!\n");//文件打开失败的处理 exit(0); } fprintf(fout,"IDnumberName"); for(i=1;i<=NumOfCourse;i++)fprintf(fout,"Course%d",i); fprintf(fout,"\n"); for(i=1;i<=NumOfCourse*9+14;i++)fprintf(fout,"-"); fprintf(fout,"\n"); for(i=0;i<NumOfStudent;i++) { fprintf(fout,"%8ld%s",stu[i].num,stu[i].name); for(j=0;j<NumOfCourse;j++)fprintf(fout,"%2d",stu[i].score[j]); fprintf(fout,"\n"); } fclose(fout); } voidrfile()//功能13：从文件中读出每个学生的记录信息并显示 { FILE*fin; inti,j; fin=fopen("E://input.txt","r"); if(fin==NULL) { printf("Failedtoopenafile!\n");//文件打开失败的处理 exit(0); } fscanf(fin,"%d",&NumOfStudent); fscanf(fin,"%d",&NumOfCourse); stu=(STUDENT*)calloc(NumOfStudent,sizeof(STUDENT)); Total=(int*)calloc(NumOfStudent,sizeof(int)); for(i=0;i<NumOfStudent;i++) { fscanf(fin,"%ld",&stu[i].num); fscanf(fin,"%s",stu[i].name); for(j=0;j<NumOfCourse;j++) { fscanf(fin,"%d",&stu[i].score[j]); Total[i]+=stu[i].score[j]; } } QuickSort(Total,stu,0,NumOfStudent-1); for(i=NumOfStudent-1;i>=0;i--)stu[i].rank=NumOfStudent-i; Table_Head(); Data(); } intmain() { A: Menu(); switch(Input_Choice()) { case1:Input_Data(); system("pause"); system("cls"); gotoA; case2:Course_Score(stu); system("pause"); system("cls"); gotoA; case3:Student_Score(stu); system("pause"); system("cls"); gotoA; case4:DownSort(Total); system("pause"); system("cls"); gotoA; case5:UpSort(Total); system("pause"); system("cls"); gotoA; case6:ID_Sort(stu); system("pause"); system("cls"); gotoA; case7:Name_Sort(stu); system("pause"); system("cls"); gotoA; case8:Search_Number(); system("pause"); system("cls"); gotoA; case9:Search_Name(); system("pause"); system("cls"); gotoA; case10:Statistic(); system("pause"); system("cls"); gotoA; case11:Output_Data(); system("pause"); system("cls"); gotoA; case12:wfile(); system("pause"); system("cls"); gotoA; case13:rfile(); system("pause"); system("cls"); gotoA; default:free(stu); free(Total);//动态数组内存的释放 exit(0); } return0; } 优点 程序可执行多个选项，每次输入选项前清除缓存，并重新显示菜单。对输入菜单选项以及输入数据进行合法性检验。表格的打印较为整齐。采用动态数组存储数据，占用内存空间更少。使用模糊查询算法，若对查询内容稍有遗忘亦可查询到相关内容。使用文件输入输出，使输入更便捷。 创新之处 对输入菜单选项顺序的问题进行了考虑，如果在输入1、13、0之前输入其他选项，均视为非法输入。对数据的排序使用了快速排序算法，提高程序的运行效率。对姓名的查询采用了模糊查询算法，提高程序的容错率。程序加入了让输出结果停留与清除屏幕上原先输出结果的功能，使输出界面更简洁。 不足之处 表格的打印还无法做到对所有数据均输出整齐对部分数据的合法性缺少判断 收获与学习体会 当我们的程序只需执行单个功能时，我们也许无需太过在意内存空间的占用、变量或函数的命名这些细节问题；但一旦我们需要编写一段执行多种功能的复杂程序，这些细节的重要性就凸显出来了。在这次的编程过程中，我会有意识地去使用一些英文单词加“_”这样的组合去命名一个变量或者是函数名，尽管这样的名称会显得相对较长，但却能随时提醒我变量、函数的作用，给我的编程带来方便。编程时，思维的连贯性是很重要的，我不希望这些小细节影响了整个思维的连贯性。另外，加注释也有助于编程，当一个函数名旁边有了注释的时候，我就会很清楚这个函数的作用是什么，编写起来就相对比较容易。 也同样是由于程序复杂性的增加，我们自行发现代码bug的难度上升了。我一般采用增加中途输出的方法对程序的问题或者漏洞进行定位。在这一过程中，我发现很多错误都发生在一些简单的算法上，而由于思维的习惯，我们一般会以为简单的地方不会犯错，这无形中又增加了发现bug的难度。通过几次痛苦的debug，我明白了要不断增加对于简单算法的掌握程度与熟练度，这会大大提升调试代码的速度，也会让我在编写较长代码时变得更轻松。 在调试程序过程中，我还注意到，分模块调试是最有效的一种调试方法。先通过输出的数据猜测可能出错的模块，再针对单个模块进行调试。我觉得这一点对我写程序的顺序也有所启发。比如，如果我实现知道在某段代码中我可能要用到一个我之前不太熟悉的算法或者语句，那我可以先用一些可以实现同样功能的语句替代它们的功能，待程序整体调试完成，再将这些复杂的语句或者是程序块添加到程序中，如果测试有问题，我也会明确知道问题发生的具体语句。 说了那么多有关调试的问题，调试本身也是极为重要的。很少有人能一遍就把代码写得很完美、滴水不漏，这就需要我们能够及时找出问题所在并迅速想出解决方法，有时甚至需要我们自己去发现自己程序的漏洞并尝试修复它。敲完代码绝不意味着程序的完成，调试往往意味着更严峻的考验。 

舰船通道路线优化 1.研究背景及意义 考虑一个若干层的舰船，各房间的空间位置已知，房间之间有若干距离、拥挤程度不同的通道，各位置处人群密度随时间变化，相应的通过速度、所需通过时间也会不同。需要设计一个算法，对于船上的任意一点均可找出通往指定位置所需时间最短的路径。 舰船是一个人群密度相对较大、人群流动频繁的场所。移动路线的选择很大程度上影响了人的行动效率。优化的路线设计不仅可以提高船舶人流、物流的效率，而且非常有助于对舰船上管网电网布置、逃生消防等诸多方面的设计。可以说，这样的一个路线优化算法具有较高的应用价值。 2.建模方法 建立一个边带权图 G = ( V , E , g ) G=(V,E,g) G=(V,E,g)，其中： V V V是所有房间和通道交叉点的集合， E E E是所有通道的集合， g : E → R g:E→R g:E→R， ∀ e ∈ E ∀e∈E ∀e∈E， g ( e ) g(e) g(e)表示边e的长度。任一边上的人群密度函数为 ρ ( e , t ) , e ∈ E ρ(e,t),e∈E ρ(e,t),e∈E， t t t表示时间，假设人行走速度 υ υ υ受人群密度 ρ ρ ρ影响，且 υ υ υ与 ρ ρ ρ满足函数关系 υ = υ ( ρ ) υ=υ(ρ) υ=υ(ρ)。这样一来，根据边的权值与当前时刻人的行走速度可以计算出人通过某一条边的时间。问题转化为，对 ∀ u , v ∈ V ∀u,v∈V ∀u,v∈V，需找到一条从 u u u到 v v v的路使所需时间最短。 3.可能遇到问题及解决方案 3.1人群密度的变化问题 普通的最短路径问题边的权值是固定不变的，但在这个工程问题中，人群密度是在随时间不断变化的，这就给求解带来了很大的挑战。由于人群密度的不断变化，每到一个顶点，都需要重新规划最短路径，但仍不能保证随着时间的推移，这条路径仍是最短的。 在我看来，如果在每一点都求解那一时刻的最短路径，计算量是很大的，并且仍不能保证最优解。不如直接放弃寻找最优解，尝试寻找次优解。可以采用贪心算法，对当前节点 w w w，只考虑与它相关的若干条边的人群密度，且通过该边到达 w ′ w' w′后， d ( w , v ) > d ( w ′ , v ) d(w,v)>d(w',v) d(w,v)>d(w′,v)。在符合条件的若干边中选择所需时间最短的。 或者，统计一段较长时间内任一边人群的平均密度 ρ ′ ( e ) , e ∈ E ρ'(e),e∈E ρ′(e),e∈E，定义边的权值 g ′ ( e ) = g ( e ) / ( υ ( ρ ′ ) ) , e ∈ E g'(e)=g(e)/(υ(ρ')),e∈E g′(e)=g(e)/(υ(ρ′)),e∈E，进而转化为普通的最短路径问题进行求解，这样仍不能保证最优解，但与最优解已相当接近。 3.2对通道的通行状况刻画不到位问题 通道的通行不仅与距离、人群密度有关，还和通道的地面平整程度、光线明暗度等多方面因素相关，并且这些因素一定程度上也与时间有关，这样一来，问题将会变得更复杂。 如果把这些因素都看成时间的函数，问题无疑会变得复杂很多。在我看来，这些因素相比于人群密度而言变化幅度很小，可以把它们当作是边的权值的一部分，通过一些换算关系调整原先边的权值，使讨论更精确。 参考：基于图论的舰船通道路线优化 

物理内存和虚拟内存 物理内存就是电脑本身的内存大小。 而虚拟内存技术，是拿出一部分硬盘空间来充当内存使用，当内存被占用完时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。但是不要把虚拟内存跟真实的插在主板上的内存条相挂钩，虚拟内存它不是虚拟的，不存在的内存，它只是内存管理的一种抽象！ 所以，可以说计算机的内存大小等于实际物理内存容量加上“分页文件”（就是交换文件）的大小。 RAM是高速缓存，通电就具有记忆功能，断电就失去，也就是运行内存，就是用来存放临时文件，而“内存”就是RAM的一种物理硬件，广义来说两者也可以说是同一概念。而虚拟内存是系统利用硬盘分出来的具有辅助内存工作的虚拟RAM，不是硬件，但又依靠硬盘。 虚拟内存并不是把硬盘当作内存，而是在硬盘上创建的交换文件。当物理内存用完后，虚拟内存管理器选择最近没有用过的，低优先级的内存部分写到交换文件（页面文件）上，并将需要访问内存的程序的内容从页面文件中换入到物理内存。 正在运行的一个进程，所需的内存是有可能大于内存条容量之和的，那么不是所有数据都能一起加载到内存（物理内存）中，势必有一部分数据要放到其他介质中（比如硬盘）。待进程需要访问那部分数据时，再通过调度进入物理内存。所以，虚拟内存是进程运行时所有内存空间的总和，并且可能有一部分不在物理内存中，而物理内存就是我们平时所了解的内存条。有的地方呢，也叫这个虚拟内存为内存交换区。 什么是虚拟内存地址和物理内存地址呢。假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址00xFFFFFFFF（4G）的地址空间。但如果你的计算机只有256M的物理内存0x0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？回答这个问题前，先说明计算机的内存分页机制。 计算机会对虚拟内存地址空间（32位为4G）分页产生页（page），对物理内存地址空间（假设256M）分页产生页帧（pageframe），这个页和页帧的大小是一样大的，所以呢，在这里，虚拟内存页的个数势必要大于物理内存页帧的个数。在计算机上有一个页表（pagetable），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射，而且是一对一的映射。但是问题来了，虚拟内存页的个数>物理内存页帧的个数，岂不是有些虚拟内存页的地址永远没有对应的物理内存地址空间？不是的，操作系统是这样处理的。操作系统有个页面失效（pagefault）功能。操作系统找到一个最少使用的页帧，让他失效，并把它写入磁盘，随后把需要访问的页放到页帧中，并修改页表中的映射，这样就保证所有的页都有被调度的可能了。这就是处理虚拟内存地址到物理内存的步骤。 可以认为虚拟空间都被映射到了磁盘空间中，并且由页表记录映射位置，当访问到某个地址的时候，通过页表中的有效位，可以得知此数据是否在内存中，如果不是，则通过缺页异常，将磁盘对应的数据拷贝到内存中，如果没有空闲内存，则选择牺牲页面，替换其他页面。 

中文分词（python） 今天研究了一下中文分词，下面用两种简单的算法（正向最大匹配分词算法和逆向最大匹配分词算法）实现。 #字典生成 defload_dic(filename): f=open(filename,'r',encoding='utf-8') word_dic=set() max_length=1 forlineinf: word=line.strip() word_dic.add(word) iflen(word)>max_length: max_length=len(word) returnmax_length,word_dic #正向最大匹配分词 deffmm_word_seg(sentence,word_dic,max_length): begin=0 words=[] whilebegin<len(sentence): forendinrange(min(begin+max_length,len(sentence)),begin,-1): word=sentence[begin:end] ifwordinword_dicorend==begin+1: words.append(word) break begin=end returnwords max_len,word_dic=load_dic('lexicon.txt')#中文词汇库 words=fmm_word_seg(input(),word_dic,max_len) forwordinwords: print(word) #字典生成 defload_dic(s): words=s.split() word_dic=set() max_length=1 forwordinwords: word_dic.add(word) iflen(word)>max_length: max_length=len(word) returnmax_length,word_dic #逆向最大匹配分词 deffmm_word_seg(sentence,word_dic,max_length): end=len(sentence) words=[] whileend>0: forbegininrange(max(end-max_length,0),end): word=sentence[begin:end] ifwordinword_dicorend==begin+1: words.append(word) break end=begin returnwords max_len,word_dic=load_dic(input()) words=fmm_word_seg(input(),word_dic,max_len) foriinrange(len(words)-1,-1,-1): print(words[i])#逆序打印 两种算法略有不同，但总体思路类似。对于不同的中文句子，两种算法可能有的适用，有的不适用。例如 研究生命的起源 这句话，使用正向最大匹配分词算法时，会被分成 研究生命的起源 ，但使用逆向最大匹配分词算法就可以得到正确结果。当然逆向最大匹配分词算法也不是对所有句子都适用。 总的来看，两种算法都能一定程度上实现中文句子的分词，但都不完善，现阶段也没有百分百准确的分词算法，这一领域还有较大的研究空间。 

判断给定的字符串是否为合法的Python标识符 判断给定的字符串是否为合法的Python标识符，一个合法的Python标识符应当符合以下几个命名规则： 只能包含数字、字母或者下划线"_"只能以字母或者下划线开头不能为Python保留关键字 以下是Python的程序实现，从以上三个方面对输入字符串是否为合法的Python标识符进行判断。 importkeyword defIs_legalword(s):#判断是否是合法字符（数字、字母或下划线） forkeyins: ifnotkeyin'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_': returnFalse returnTrue defIs_legal(s): ifs[0]=='_'ors[0].isalpha():#开头为字母或下划线 ifkeyword.iskeyword(s):#判断是否为Python保留关键字 returnFalse elifIs_legalword(s): returnTrue else: returnFalse else: returnFalse line=input() print(Is_legal(line)) 正好，一道Python编程题的内容与判断Python标识符的合法性有关，具体题目如下。 Python编程题 题目内容：依次判断一系列给定的字符串是否为合法的Python标识符。 输入格式:一系列字符串，每个字符串占一行。 输出格式：判断每行字符串是否为合法的Python标示符，如果合法则输出True，否则输出False。 输入样例：abc_def21gh 输出样例：TrueTrueFalse 我们发现，这道编程题与我们之前考虑的问题略有不同，最大的不同点在于这道编程题要求输入一系列字符串，这要求代码能够实现多行输入。而以下代码可以解决这个问题。 importkeyword importsys defIs_legalword(s): forkeyins: ifnotkeyin'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_': returnFalse returnTrue defIs_legal(s): ifs[0]=='_'ors[0].isalpha(): ifkeyword.iskeyword(s): returnFalse elifIs_legalword(s): returnTrue else: returnFalse else: returnFalse list=[] list_new=[] forlineinsys.stdin: list_new=line.split() list.extend(list_new) forlineinlist: print(Is_legal(line)) 

word2019关闭时无响应 今天在关闭word文档时突然遇到了无响应的情况，网上有的资料说取消隐私设置里的所有对勾项，我尝试了一下之后失败了。最后我是通过下述方法解决的。 步骤 最好新建一个word文档进行操作以Office安全模式启动Word（按下CTRL键，双击打开word文档）。打开新建的文档，再关闭，检查问题是否依然存在。如果问题在安全模式下不存在，这说明是由加载项引起的。点击文件>选项>加载项>在管理列表中，单击COM加载项，然后单击转到,取消勾选在COM加载项对话框中列出的加载项，如果有多个，需要逐个取消勾选进行测试。此过程有助于确定哪个加载项是导致该问题的原因。最后COM加载项的页面如上图所示，我的word里共有6个加载项。后面4个其实是office自带的一些加载项，而我这个问题是最近才出现的，应该和这几个关系不大。我直接尝试关闭了前两个加载项（百度网盘、福昕PDF编辑器），问题成功解决。 

QQ小程序云开发 QQ小程序的开发有时候需要使用云开发能力，下面是我自己总结的云开发初始化的相关教程。注：在最初构建项目时要选择使用云服务。 1.下载Nodejs 下载地址，全部选择默认安装即可。（下图中版本号可能不对） 2.在小程序根目录打开终端，执行npminit，全部按回车 cmd切换到指定目录方法：相关博客 3.在终端输入npminstall--save@cloudbase/extension-ci，等待执行完毕。 4.点击QQ小程序开发者顶部栏-工具-构建npm 5.在QQ小程序需要云开发的页面加入如下代码即可。 constextCI=require('@cloudbase/extension-ci'); Page({ .. onLoad:function(){ //初始化环境 qq.cloud.init({ env:'此处填入自己注册的环境ID' }) //注册云开发扩展 qq.cloud.registerExtension(extCI); } .. }) 

Python实现 两位整数相乘形成的最大回文数是9009=99×91。编写程序，求得任意输入的n位整数相乘形成的最大回文数。 题目内容：两位整数相乘形成的最大回文数是9009=99×91。编写程序，求得任意输入的n位整数相乘形成的最大回文数。 输入格式:正整数n 输出格式：n位整数相乘形成的最大回文数 输入样例：2 输出样例：9009 【基本思路】从大到小枚举可能的n位数因子，从中找到最大的回文数乘积。【优化】试图缩小因子的取值范围，减少循环次数。【分析】设两个因子分别为 i i i和 j j j，取 i i i等于因子可能的最大值 1 0 n − 1 10^n-1 10n−1，从大到小枚举 j j j，一定可以找到回文数 N N N，设此时 j = j 0 j=j_0 j=j0​。则 i > j 0 i>j_0 i>j0​， j > = j 0 j>=j_0 j>=j0​，否则 i ∗ j < N i*j<N i∗j<N， i ∗ j i*j i∗j不可能是最大回文数。根据这个思路进行编程，代码如下： defIs_palindrome(s):#判断回文数 l=len(s) foriinrange((l-1)//2+1): ifs[i]!=s[l-1-i]:returnFalse returnTrue deffind(n): base=10**n-1#因子的基准值（从10^n-1开始减小） forjinrange(base,0,-1): ifIs_palindrome(str(base*j)): max=base*j mini=j#因子可能的最小值（如果i或者j小于mini的话，i*j一定小于base*mini） break foriinrange(base,mini,-1): forjinrange(i,mini,-1): ifIs_palindrome(str(i*j)): ifi*j>max:max=i*j returnmax n=int(input()) print(find(n)) 

C语言个人笔记 C语言个人笔记 在这里，我将整理我个人在学习C/C++遇到的一些零碎的问题或者知识点。它们零零碎碎，不成体系。这只是一篇笔记。 1.strcmp()函数 头文件<string.h>函数原型intstrcmp(constchar*str1,constchar*str2)功能描述用于比较两个字符串并根据比较结果返回整数返回值(ret)①str1<str2，ret<0②str1>str2，ret>0③str1=str2，ret=0 2.isdigit()函数 头文件<ctype.h>函数原型intisdigit(intc)功能描述检查所传的字符是否是十进制数字字符返回值(ret)①c是一个数字，ret非零值②否则，ret=0 C语言里没有boolean型，C++里有。 3.atoi()函数 头文件<stdlib.h>函数原型intatoi(constchar*str)功能描述把参数str所指向的字符串转换为一个int整数返回值(ret)①该函数返回转换后的长整数②，如果没有执行有效的转换，则返回零。 菜鸟教程：link 4.sigfillset()函数 头文件<signal.h>函数原型intsigfillset(sigset_t*set)功能描述用来将参数set信号集初始化,将所有信号加到信号集set中返回值(ret)①执行成功，ret=0②有错误，ret=-1 菜鸟教程：link 5.getopt()函数 头文件<unistd.h>函数原型intgetopt(intargc,char*constargv[],constchar*optstring)功能描述getopt()用来分析命令行参数 C语言中文网：link 

Linux学习笔记 Linux学习笔记 1. makeclean//清除上次的make命令所产生的object文件（后缀为“.o”的文件）及可执行文件。 make//根据Makefile文件编译源代码、连接、生成目标文件、可执行文件。 2. 如何生成.o文件 gcc-Ehello.c-ohello.i gcc-Shello.i-ohello.s gcc-Chello.s-ohello.o 

程序人生-Hello’sP2P哈工大计算机系统大作业 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 学 号 班 级 学 生 指导教师 计算机科学与技术学院 2021年6月 摘 要 本文将分析hello程序运行的全部过程，给出在执行每一步操作时计算机系统的操作方式来展现hello程序从开始到结束的生命历程。旨在通过hello程序的分析，更加深入地理解计算机系统各个部分地运作方式和作用，使读者能够对计算机系统产生一个较为整体的认知，同时对计算机系统中不同部分的任务和实现方式获得一定程度了解。 关键词：计算机系统；编译；链接；进程管理；存储管理 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P：FromProgramtoProcess 分为两步，第一步是生成可执行目标文件。在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的： linux>gcc-ohellohello.c GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。这个翻译过程可分为四个阶段完成，如下图。预处理阶段，预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。编译阶段，编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。汇编阶段，汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成可重定位目标程序（relocatableobjectprogram），并将结果保存在目标文件hello.o中。链接阶段。合并printf.o到hello.o程序中，得到hello文件，可执行目标文件。 第二步是加载到内存中运行。在Unix系统上运行，要输入文件名到shell中： linux>./hello 然后shell执行fork和execve加载可执行的hello文件，将hello目标文件中的代码和数据从磁盘复制到主存，处理器开始执行hello程序的main程序中的机器语言指令。在操作系统调度hello进程时，hello进程运行。 O2O:FromZero-0toZero-0 加载hello程序时，首先给对应进程一个虚拟内存。由虚拟内存地址到物理地址的翻译是OS和MMU合作完成。虚拟内存到物理内存的映射由4级页表储存，页表的缓存是TLB。内存有3级缓存cache。通过mmap程序从硬盘加载到虚拟内存。hello运行结束后内核回收内存，from0to0. 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 硬件：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件：Windows1064位；Vmware16；Ubuntu20.04LTS64位/ 开发工具：gcc/gdb/readelf 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 hello.c/hello.i/hello.s/hello.o/hello/hello.elf/objdump/objdump.s 1.4本章小结 本章对hello做了总体的介绍，简述了hello的p2p和020过程，列出并介绍了本次实验的环境和工具，阐明了这次实验中产生了中间产物。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 在编译之前进行的处理。C语言的预处理主要有三个方面的内容：1.宏定义；2.文件包含；3.条件编译。预处理命令以符号“#”开头。 2.2在Ubuntu下预处理的命令 应截图，展示预处理过程！ 2.3Hello的预处理结果解析 可以看到，预处理后的hello.i变成了3000多行，是因为#include的文件stdio.h等内容直接插入到程序文本中。 2.4本章小结 本章介绍了预处理的概念和作用，在ubuntu下预处理的方法，对预处理结果进行解析。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 利用编译程序从源语言编写的源程序产生目标程序的过程。编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含函数main的定义。 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令 应截图，展示编译过程！ 3.3Hello的编译结果解析 3.3.1数据 已初始化的全局变量sleepsecs放在data中。 局部变量放在栈中或寄存器中。如argc和argv从寄存器移动到栈中： 变量i储存在栈中： 字符串常量将储存在rodata中。 表达式和局部变量类似，会储存在栈和局部变量中，分步计算出结果。如argv[1]的计算： 3.3.2赋值 对全局变量sleepsecs的赋值应该是将要直接写入文件的data部分。 局部变量i的赋值通过mov指令实现。 3.3.3类型转换 处理int型变量sleepsecs时出现了隐式类型转换，把2.5转换成了2.C语言处理类型转换的方法如下： 3.3.4算术操作 i++编译为add指令。 3.3.5关系操作 可以看到，关系操作都编译为cmp指令。cmp指令设置条件码，读取不同的条件码获得不同的关系操作结果。 3.3.6数组操作 第41行和44行体现出取数组内容的方法。是通过mov指令中地址的偏移量处理的。 3.3.7控制转移 if控制编译为cmp命令结合je条件跳转命令。 for循环编译为3段，.L2初始化，.L3判断跳转，.L4为循环主体。 3.3.8函数操作 main函数的参数argc和argv分别在寄存器%edi和%rsi中被传递。 printf函数的参数通过%rdi,%rsi等传递，由call指令调用。 main函数结束后由leave指令返回。leave相当于popq%rbp+ret。 此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~3.3.x等按照类型和操作进行分析，只要hello.s中出现的属于大作业PPT中P4给出的参考C数据与操作，都应解析。 3.4本章小结 本章指出了编译的概念、命令，解析了编译结果中对C语言的数据和操作的具体处理方法。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编器（as）将汇编代码翻译成机器语言指令，把这些指令打包成可重定位目标程序（relocatableobjectprogram）。翻译成机器语言指令后机器可以直接读取分析。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。 4.2在Ubuntu下汇编的命令 应截图，展示汇编过程！ 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 ELF头 ELF头（ELFheader）以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型、机器类型、节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量。 节头部表 节头部表描述不同节的位置和大小，其中目标文件中每个节都有一个固定大小的条目（entry）。 重定位节 汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。 ELF重定位条目格式： 偏移量即offset，是需要被修改的引用的节偏移。信息包括symbol和type，symbol标识被修改引用应该指向的符号。ELF定义了32种不同的重定位类型，其中两种最基本的是R_X86_64_PC32和R_X86_64_32。加数即addend，是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。 符号表 符号表是由汇编器构造的，使用编译器输出到汇编语言.s文件中的符号。.symtab节中包含ELF符号表。这张符号表包含一个条目的数组。 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 机器语言指的是二进制的机器指令集合,而机器指令是由操作码和操作数构成的.汇编语言的主体是汇编指令.汇编指令和机器指令的差别在于指令的表示方法上,汇编指令是机器指令便于记忆的书写格式. 通过对比可以看出，操作数在汇编语言hello.s中用十进制表示，而在反汇编中objdump.s用十六进制表示，即在机器语言中是二进制表示。 分支转移地址表示，hello.s上为".L1"等段名称，在objdump.s为相对偏移的地址. 函数调用的地址表示在hello.s上为函数名，在objdump.s上为全0.这是因为还没有重定位，重定位后机器语言将用地址相对偏移量表示。 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 4.5本章小结 本章介绍了汇编，分析了可重定位目标文件，对比了汇编程序和机器程序的差别。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。 注意：这儿的链接是指从hello.o到hello生成过程。 5.2在Ubuntu下链接的命令 使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 首先是ELF头。 其余节的信息在节头部表中说明。 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 举例.interp 在节头部表信息如下： 在edb中： 该节的位置,大小都和节头部表描述一致,其他类推. 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 本次生成的汇编代码和hello.o生成的汇编代码的不同： 1. hello汇编代码中出现了更多函数，hello.o的汇编代码中只出现了main函数的名字，而hello的汇编代码中出现了_init，.plt等函数名。这体现了很多非hello.c源程序中生命的函数被链接到了hello中。 2.函数调用地址变化，在hello.o汇编代码中函数的地址不确定，在hello汇编代码中地址确定下来。 3.数据引用地址变化，在hello.o汇编代码中很多数据的地址不确定，在hello汇编代码中地址确定下来。 链接的过程： 1.在使用ld命令链接的时候,指定了动态链接器为64的/lib64/ld-linux-x86-64.so.2,_start程序调用hello.c中的main函数,libc.so是动态链接共享库,其中定义了hello.c中用到的printf、sleep、getchar、exit函数和_start中调用的__libc_csu_init,__libc_csu_fini,__libc_start_main.链接器将上述函数加入. 2.将所有的R_X86_64_PC32和R_X86_64_PLT32替换成计算好的地址。 重定位算法如下： 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 hello执行流程如下： （1）ld-linux-x86-64.so!_dl_start （2）ld-linux-x86-64.so!_dl_init （3）hello!_start （4）hello!__libc_csu_init （5）hello!_init （6）libc.so!_setjmp （7）hello!main （8）hello!puts@plt （9）ld-linux-x86-64.so!_dl_runtime_resolve_xsave （10）ld-linux-x86-64.so!_dl_fixup （11）ld-linux-x86-64.so!_dl_lookup_symbol_x （12）hello!exit@plt （13）libc.so!exit （14）hello!_fini 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 动态链接库中的函数在程序执行的时候才会确定地址，所以编译器无法确定其地址。为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。延迟绑定通过两个数据结构之间简洁但又有些复杂的交互来实现，即过程链接表（PLT）和全局偏移量表（GOT）。 过程链接表（PLT）：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。每个条目都负责调用一个具体的函数。 全局偏移量表（GOT）：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 对比信息，可见动态链接器解析函数的地址加入了信息中。 5.8本章小结 本章主要介绍了链接的概念与作用、hello的ELF格式,分析了hello的虚拟地址空间、重定位过程、执行流程、动态链接过程. （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 进程为用户提供了这样的假象，我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断地执行我们程序中地指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 Shell俗称壳，是指"为使用者提供操作界面"的软件。同时它又是一种程序设计语言。作为命令语言，它交互式解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令。它作为用户操作系统与调用其他软件的工具。 处理流程： （1）从终端读入输入的命令。 （2）将输入字符串切分，分析输入内容，解析命令和参数。 （3）如果命令为内置命令则立即执行，如果不是内置命令则创建新的进程调用相应的程序执行。 （4）在程序执行期间始终接受键盘输入信号，并对输入信号做相应处理。 6.3Hello的fork进程创建过程 由于hello不是一个内置命令，故解析后执行当前目录下的可执行目标文件hello，shell作为父进程通过fork函数为hello创建一个新的进程作为子进程。通过fork函数，子进程得到与父进程用户级虚拟地址空间相同但独立的一份副本，包括代码和数据段、堆、共享库、用户栈。hello进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程还可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。 6.4Hello的execve过程 子进程创建后，shell调用execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp。之后当出现错误时，例如找不到hello，execve才会返回到调用程序。 在execve加载了hello后，它调用启动代码，启动代码设置栈，并将控制转移给新程序的主函数main，此时用户栈已经包含了命令行参数和环境变量，进入main函数后开始逐步运行程序。 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象构成。 时间片：一个进程执行它的控制流的一部分的每一个时间段。 调度：在执行过程中，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。 用户态：进程运行在用户模式中时，不允许执行特权指令，比如停止处理器、改变模式位，或者发起一个I/O操作，也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。 核心态：进程运行在内核模式中时，可以执行指令集中的任何指令，并且可以访问内存中的任意位置。 用户态与核心态转换：程序在涉及到一些操作时，例如调用一些系统函数，内核需要将当前状态从用户态切换到核心态，执行结束后再改回用户态。 hello执行时存在逻辑控制流，多个进程的逻辑控制流在时间上可以交错，表现为交替运行。进程控制权的交换需要上下文切换。操作系统内核使用一种成为上下文切换的较高层形式的异常控制流来实现多任务。内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。 例如hello中对sleep的调用，内核中的调度器将hello进程挂起，进入内核模式，在执行结束后，内核会恢复hello被抢占时的上下文，回到用户模式。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 会出现四种异常：中断、陷阱、故障、终止。 会出现的信号：SIGSTP、SIGCONT、SIGKILL、SIFGINT等。 中断是来自I/O设备的信号，异步发生，中断处理程序对其进行处理，返回后继续执行调用前待执行的下一条代码，就像没有发生过中断。 陷阱是有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。帮助程序从用户模式切换到内核模式。 故障是由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。 终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程序会将控制返回给一个abort例程，该例程会终止这个应用程序。 程序运行时通过键盘操作给信号： （1）运行中不停乱按，将所输内容输出到屏幕上。 （2）运行中按ctrl-c，shell父进程收到SIGINT信号，信号处理函数将hello进程终止并回收。 （3）运行中按ctrl-z，shell父进程收到SIGSTP信号，信号处理函数将hello进程挂起。 （4）ctrl-z后运行fg命令发送SIGCONT信号继续执行hello。 （5）ctrl-z后运行kill命令发送SIGKILL信号杀死hello。 （6）ctrl-z后运行ps、jobs、pstree命令，输出相关信息。ps命令输出当前系统中的进程；jobs命令输出当前已启动的任务状态；pstree命令输出进程间的树状关系。 6.7本章小结 本章介绍了进程的概念和作用，结合fork和execve函数说明了hello进程的执行过程，之后分析了进程执行过程中异常和信号的处理问题。至此，可执行目标文件成功被加载至内存并执行。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 逻辑地址：程序代码经过编译后出现在汇编程序中地址.逻辑地址指的是机器语言指令中,用来指定一个操作数或者是一条指令的地址. 线性地址&虚拟地址：逻辑地址经过段机制后转化为线性地址（虚拟地址）,是逻辑地址到物理地址变换之间的中间层.在分段部件中逻辑地址是段中的偏移地址,然后加上基地址就是线性地址.是一个32位无符号整数,可以用来表示高达4GB的地址,也就是,高达4294967296个内存单元.线性地址通常用十六进制数字表示,值得范围从0x00000000到0xfffffff）程序代码会产生逻辑地址,通过逻辑地址变换就可以生成一个线性地址.如果启用了分页机制,那么线性地址可以再经过变换以产生一个物理地址.如果没有启用分页机制,那么线性地址直接就是物理地址. 物理地址：CPU地址总线传来的地址,由硬件电路控制（现在这些硬件是可编程的了）其具体含义.物理地址中很大一部分是留给内存条中的内存的,但也常被映射到其他存储器上（如显存、BIOS等）.在没有使用虚拟存储器的机器上,虚拟地址被直接送到内存总线上,使具有相同地址的物理存储器被读写；而在使用了虚拟存储器的情况下,虚拟地址不是被直接送到内存地址总线上,而是送到存储器管理单元MMU,把虚拟地址映射为物理地址. 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理是实现逻辑地址到线性地址转换机制的基础，段的特征有段基址、段限长、段属性。这三个特征存储在段描述符中，用以实现从逻辑地址到线性地址的转换。段描述符存储在段描述符表中，通常，我们使用段选择符定位段描述符在这个表中的位置。每个逻辑地址由16位的段选择符和32位的偏移量组成。 段基址规定了线性地址空间中段的开始地址。在保护模式下，段基址长32位。因为基址长度和寻址地址的长度相同，所以段基址可以是0-4GB范围内的任意地址。 和一个段有关的信息需要8个字节来描述，这就是段描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里所有的描述符都在一起集中存放，这就构成了一个描述符表，描述符表分为两种，GDT和LDT。 一些全局的段描述符，就放在"全局段描述符表(GDT)"中，一些局部的，例如每个进程自己的段描述符，就放在的"局部段描述符表(LDT)"中。 介绍一个完整的变换过程，给出一个完整的逻辑地址[段选择符：段内偏移地址]。首先看段选择符判断当前转换时GDT中的段还是LDT中的段，再根据相应寄存器得到其地址和大小。之后拿出段选择符中的前13位，在对应地址中查找到对应的段描述符，这样就知道了基址。根据基址和偏移量结合，就得到了所求的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 分页机制是实现虚拟存储的关键，位于线性地址与物理地址的变换之间设置。虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次结构中其他缓存一样，磁盘上的数据被分割成块，这些块作为磁盘和主存之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页为大小固定的块来处理这个问题。每个虚拟页的大小固定。类似地，物理内存被分割为物理页，大小与虚拟页相同。 同任何缓存一样，虚拟内存系统必须用某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM，替换这个牺牲页。 页表是一个存放在物理内存中的数据结构，将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时读取页表。操作系统负责维护页表中的内容，以及再磁盘与DRAM之间来回传送页。 内存分页管理的基本原理是将整个内存区域划分成固定大小的内存页面。程序申请使用内存时就以内存页位单位进行分配。转换通过两个表，页目录表PDE（也叫一级目录）和二级页表PTE。进程的虚拟地址需要首先通过其局部段描述符变换为CPU整个线性地址空间中的地址，然后再使用页目录表和页表PTE映射到实际物理地址上。 7.4TLB与四级页表支持下的VA到PA的变换 36位VPN被划分成四个9位的片,每个片被用作到一个页表的偏移量.CR3寄存器包含L1页表的物理地址.VPN1提供到一个L1PET的偏移量,这个PTE包含L2页表的基地址.VPN2提供到一个L2PTE的偏移量,以此类推. 在对地址翻译的讨论中,我们描述了一个顺序的两个步骤的过程,1)MMU将虚拟地址翻译成物理地址,2)将物理地址传送到L1高速缓存.然而,实际的硬件实现使用了一个灵活的技巧,允许这些步骤部分重叠,因此也就加速了对L1高速缓存的访问.例如,页面大小为4KB的系统上的一个虚拟地址有12位的VPO,并且这些位和相应物理地址中的PPo的12位是相同的.因为八路组相联的、物理寻址的L1高速缓存有64个组和大小为64字节的缓存块,每个物理地址有6个(log264)缓存偏移位和6个(log264)索引位.这12位恰好符合虚拟地址的VPO部分,这绝不是偶然!当CPU需要翻译一个虚拟地址时,它就发送VPN到MMU,发送VPO到高速L1缓存.当MMU向TLB请求一个页表条目时,L1高速缓存正忙着利用VPO位查找相应的组,并读出这个组里的个标记和相应的数据字.当MMU从TLB得到PPN时,缓存已经准备好试着把这个PPN与这8个标记中的一个进行匹配了. 7.5三级Cache支持下的物理内存访问 得到物理地址PA后，通过其访问物理内存，物理地址由CI（组索引）、CT（标记位）、CO（偏移量）组成。首先使用CI进行组索引，每组8路，对8路的块分别匹配标记位CT，如果匹配成功且块的有效位为1则命中，根据数据偏移量CO取出数据返回。如果没有匹配成功则不命中，向下一级缓存中查询数据，顺序是L1缓存到L2缓存到L3缓存到主存。查询到数据后，放置策略是如果映射到的组有空闲块则直接放置，否则产生冲突，采用最近最少使用策略驱逐块并替换新块进入。 下图给出了三级Cache的大致构造： 7.6hello进程fork时的内存映射 Shell通过fork函数为hello创建新进程，当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面。 7.7hello进程execve时的内存映射 hello调用execve后，execve在当前进程中加载并运行包含在可执行目标文件中的程序，用hello程序有效地代替了当前程序。当加载并运行可执行目标文件时，需要以下几个步骤： （1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 （2）映射私有区域。为hello的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。 （3）映射共享区域。如果hello程序与共享对象（或目标）链接，比如标准C库libc.so,那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。下图给出了私有区域和共享区域在内存映射时的位置。 （4）设置程序计数器PC。execve做的最后一件事是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 物理内存缓存不命中称为缺页。假设CPU引用了磁盘上的一个字，而这个字所属的虚拟页并没有缓存在DRAM中。地址翻译硬件会从内存中读取虚拟页对应的页表，说明这个虚拟页没有被缓存，触发一个缺页故障。 这个异常导致控制转移到内核的缺页处理程序，处理程序首先判断虚拟地址A是否合法，如果不合法则触发段错误终止进程。如果合法则判断试图进行的内存访问是否合法，如果不合法则出发保护异常终止进程。如果合法则根据页式管理的规则，选择一个牺牲页，用新页替换掉，更新页表并再次触发地址翻译硬件进行翻译。 7.9动态存储分配管理 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器分为两种：显式分配器和隐式分配器。显式分配器要求应用显式地释放人设已分配地块。隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾回收器，而自动释放未使用的已经分配的块的过程叫做垃圾收集。 malloc使用的是显式分配器，通过free函数释放已分配的块。 下面分别介绍两种分配器： （1）隐式空闲链表分配器。我们可以将堆组织为一个连续的已分配块和空闲块的序列，空闲块是通过头部中的大小字段隐含地连接着的，这种结构为隐式空闲表。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块地集合。一个块是由一个字的头部、有效载荷、可能的填充和一个字的脚部，其中脚部就是头部的一个副本。头部编码了这个块的大小以及这个块是已分配还是空闲的。分配器就可以通过检查它的头部和脚部，判断前后块的起始位置和状态。 （2）显示空闲链表分配器。将堆组成一个双向空闲链表，在每个空闲块中，都包含一个pred和succ指针。一种方法是用后进先出（LIFO）的顺序来维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用。一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在的提高了内部碎片的程度。 7.10本章小结 本章介绍了hello的存储地址和存储空间，说明了虚拟内存相关知识，展示了各种地址表示的一步步转化，模拟了系统内部的一部分操作。并分析了进程的内存映射、缺页故障和缺页故障处理，还对动态内存分配器有了一定的了解。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 UnixI/O接口的统一操作： （1）打开文件。一个应用程序要求通过内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个标识符。 （2）Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。 （3）改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开始的字节偏移量。应用程序能够通过执行seek操作，现显式地设置文件的位置为k。 （4）读写文件。一个读操作就是从文件复制n个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个称为end-of-file的条件，应用程序能够检测到这个条件。在文件结尾处并没有明确的"EOF符号"。 （5）关闭文件。当应用程序完成了对文件的访问后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。 UnixI/O函数接口提供了以下函数共应用程序调用： （1）open：进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的。open将filename转换为一个文件描述符，并且放回描述符数字。 （2）close：进程通过调用close函数关闭一个打开的文件。关闭一个已关闭的描述符会出错。 （3）read：应用程序通过read函数来执行输入。read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误；返回值0表示EOF；否则，返回值表示的是实际传扫的字节数量。 （4）write：应用程序通过write函数来执行输出。write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章介绍了Linux的IO设备管理方法、UnixIO接口及其函数，并分析了printf函数和getchar函数。 （第8章1分） 结论 hello的一生经历了这些过程： （1）编写程序：源程序hello.c在编译器中完成。 （2）预处理：预处理器（cpp）将修改源程序，生成hello.i文件。 （3）编译：编译器（ccl）将hello.i文件翻译为汇编文件hello.s。 （4）汇编：汇编器（as）将hello.s文件翻译为二进制机器语言，生成可重定位目标文件hello.o。 （5）链接：链接器（ld）将可重定位目标文件hello.o和其他目标文件链接成为可执行文件hello。 （6）创建进程：shell进程调用fork函数为hello创建新进程，并调用execve函数运行hello。 （7）访问内存：通过MMU将需要访问的虚拟地址转化为物理地址，并通过缓存系统访问内存。 （8）动态申请内存：hello运行过程中可能会通过malloc函数动态申请堆中的内存。 （9）异常：hello运行过程中可能会产生各种异常和信号，系统会针对出现的异常和收到的信号做出反应。 （10）终止：hello运行结束后被父进程回收，内核删除相关数据。 以上，就是hello程序的一生。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.c源文件 hello.i预处理后的源文件 hello.s编译后的汇编代码 hello.o汇编后的可链接目标文件 hello可执行目标文件 hello.elf可执行目标文件的elf信息 hello.o.elf可链接目标文件的elf信息 objdump可执行目标文件的反汇编 objdump.s可链接目标文件的反汇编 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 《深入理解计算机系统第三版》 [2] 程序人生-Hello’sP2P_leolin037的博客-CSDN博客 [3] 程序人生-Hello’sP2P-dugudashen-博客园(cnblogs.com) （参考文献0分，缺失-1分） 

2021-06-23 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算学部学 号1190201120班 级1936602学生卜铎 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文通过以hello.c程序为例，介绍了程序在计算机上的执行过程，包括预处理，编译，汇编，链接，进程管理等过程。 关键词：CSAPP；程序的生命周期；P2P；020 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介hello.c经过预处理，编译，汇编，链接之后，最终可以作为目标程序执行。在shell中启动后，shell会使用fork为其创建并生成子进程，这样hello从Program转换为Process，这是P2P的过程。完成P2P过程后进入020过程shell为程序调用execve函数，execve函数启动加载器，为该进程分配独立的虚拟内存。进入程序后，程序加载物理内存，然后进入main函数执行目标代码。CPU为程序分配时间片执行指令，调用系统I/O。程序结束后shell父进程回收hello进程，释放占用的内存，删除数据结构。这是020过程。1.2环境与工具Ubuntu20.02，Window10gdb，edb，vim，hexedit，objdump，Code::BlocksIDE1.3中间结果hello.c(C语言源程序) hello.i(hello.c预处理之后的程序文本) hello.s(hello.i编译成汇编语言之后的程序文本) hello.o(hello.s生成的二进制文件) hello(可执行的hello二进制文件) 1.4本章小结本章总括了本次实验的主要内容。（第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理是预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如hello.c中第一行的#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件拓展名。 2.2在Ubuntu下预处理的命令gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析预处理后hello.c中包含#的语句变成以#开头的字符串，描述的是运行库在计算机中的位置，以便于接下来的编译阶段。 2.4本章小结本章介绍了预处理的概念及作用，在Ubuntu下预处理的语句，以及预处理后的文件变化。预处理是一个.c源程序转化为可执行文件的第一步。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译是编译器将预处理得到的.i文件生成相应的汇编文件的过程，以.s作为文件拓展名注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 3.3Hello的编译结果解析1） 该字符串对应"Usage:Hello学号姓名！\n"，中文被编码为UTF-8格式 2）全局变量sleepsecs 初始化为2后存放在.rodata字节，即只读数据节。3）控制转移 如上图表示比较即时数3和地址%rbp-0x20处的值，如果相等则跳转到.L2函数。4）赋值操作 如上图5）算术操作 设%rax中存储的数为x，则上述表达式为x=x+166）数组 7）函数操作 3.4本章小结本章介绍了编译的概念和作用，以及Ubuntu中的编译指令，简单分析了汇编文件及其中的汇编代码。 （第3章2分） 第4章汇编4.1汇编的概念与作用 汇编是汇编器（as）将hello.s翻译成机器语言指令的过程。在汇编阶段，汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。4.2在Ubuntu下汇编的命令ashello.s-ohello.o 4.3可重定位目标elf格式 ELF头：以一个描述了生成该文件的系统的字的大小和字节顺序的16字节的序列开始。 节头表，包含魏晋之出现的各个节的类型，地址，偏移量，大小，旗标，链接，对齐等信息。.text已编译程序的机器代码，类型为PROBITS，旗标为AX，即分配内存且可执行.rel.text一个.text节中位置的列表.data已初始化的全局和静态变量，类型为PROBITS，旗标为WA，即分配内存且可修改.bss未初始化的全局和静态变量，类型为NOBITS，即暂无存储空间。该节在开始时不占据实际的空间.rodata只读数据.symtab符号表，装载符号信息.comment包含了版本控制信息.note.CNU-stack标记可执行堆栈.strtab一个字符串表，包含.symtab和.debug节中的符号表，以及节头部的节名字 符号表，包含main定义和引用的符号信息4.4Hello.o的结果解析 在hello.o中，在只读数据的使用上，反汇编得到的结果是先用$0x0替代，且在替代的同时，反汇编代码也在下方标注了一些重定位信息；而在hello.s中我们使用.LC0,.LC1来替代汇编代码中只读变量的出现。在hello.o中，对函数的调用上，在call之后使用的是对应命令在main函数中的便宜了而非函数名；而在hello.s中，直接call函数名。说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。4.5本章小结本章介绍了汇编的作用及概念，在Ubuntu中汇编指令的使用，同时通过readelf工具查看了汇编器生成的可重定位目标elf格式并进行了简单分析。在这一章中，hello.c由文本文件变成了二进制文件，汇编器将我们之前得到的hello.s转化成机器语言。 （第4章1分） 第5章链接5.1链接的概念与作用链接是将各种代码和数据片段收集并组合成一个单一文件的过程注意：这儿的链接是指从hello.o到hello生成过程。5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式ELF头： 节头部表： 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 各指令对应的地址为重定位之后的虚拟内存的地址，从0x400000开始，而hello.o是从0000000开始此外在开头hello还多了.init，.fini，.plt，.plt.got节，分别是程序初始化执行的代码，程序终止时需要执行的代码，动态链接中的过程连接表，动态链接中的全局偏移表5.6hello的执行流程 ld-2.27.so!_dl_start0x7f54dc67cdf0ld-2.27.so!_dl_init0x7f54dc6a85f8hello!_start0x400500libc-2.27.so!__libc_start_main0x7fbdf0cccab0hello!puts@plt0x400410hello!exit@plt0x400440hello!printf@plt0x4004c0hello!getchar@plt0x4004f05.7Hello的动态链接分析 通过之前使用readelf时得到的可执行文件hello各节的相关信息，我们可以得到.got和.got.plt的地址。 在DataDump中查看对应地址的内容: 可以看到在_dl_init之前，对应的地址内容为空。而在DataDump之后，对应地址内容不再为空，而是根据延迟绑定的策略调整对应的内容。5.8本章小结本章介绍了链接的概念及作用，链接是完成hello.c向可执行文件转换的最后一步。在本章中，通过readelf查看了可执行文件hello的格式，通过edb查看了hello的虚拟空间。对hello的重定位过程和执行流程以及动态链接过程进行了简单的分析。（第5章1分） 第6章hello进程管理6.1进程的概念与作用进程是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。通过进程，我们会得到一种假象，好像我们的程序是当前唯一运行的程序，我们的程序独占处理器和内存，我们程序的代码和数据好像是系统内存中唯一的对象。6.2简述壳Shell-bash的作用与处理流程Shell是一个命令解释器，主要用于用户和系统的交互，它解释由用户输入的命令并把它们送到内核。shell是操作系统内核常驻内存的部分，可以被看作一个由C语言编写的终端程序。Bash，全称为Bourne-AgainShell。它是一个为GNU项目编写的Unixshell。bash脚本功能非常强大，尤其是在处理自动循环或大的任务方面可节省大量的时间。处理流程： //解析引用并分割命令行为各个单词，各单词称为token。其中重定向所在的token会被保存下来，直到扩展步骤结束后才进行相关处理，如进行扩展、截断文件等//检查命令行结构。主要检查是否有命令列表、是否有shell编程结构的命令，如if判断命令、循环结构的for/while/select/until，这些命令属于保留关键字，需要特殊处理。//对第一个token进行别名扩展。如果检查出它是别名，则扩展后回到(2)再次进行token分解过程。如果检查出它是函数，则执行函数体中的复合命令。如果它既是别名，又是函数(即命令别名和函数同名称的情况)，则优先执行别名。在概念上，别名的临时性最强，优先级最高。//进行各种扩展。扩展顺序为：大括号扩展；波浪号扩展；参数、变量和命令替换、算术扩展(如果系统支持，此步还进行进程替换)；单词拆分；文件名扩展。6.3Hello的fork进程创建过程./hello运行之前生成的可执行文件hello，shell先判断是否是内置命令，shell判断出不是内置命令，加载可执行文件hello，通过fork创建一个子进程，子进程得到与父进程用户级虚拟地址空间相同的一份副本。子进程与父进程有不同的PID。 6.4Hello的execve过程子进程通过调用execve函数来调用加载器，加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。6.5Hello的进程执行系统中的每个程序都运行在某个进程的上下文中。上下文由程序正确运行所需的状态组成，这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。开始时由于我们再shell中运行hello，所以hello初始运行在用户模式，在hello进程调用sleep之后陷入内核模式，内核处理休眠请求主动释放当前进程，并将hello进程从运行队列中移出加入等待队列，定时器开始计时，内核进行上下文切换并将当前进程的控制权交给其他进程。当定时器计数到我们作为参数传入的暂停秒数之后会发送一个中断信号，此时进入内核状态，内核处理信号将hello进程从等待队列中移出重新加入到运行队列，恢复之前保存的hello的上下文，hello进程继续运行。 6.6hello的异常与信号处理 图6.6.1正常运行 图6.6.2按下Ctrl-C后程序停止 图6.6.3输入乱码时后续正常运行 图6.6.4输入回车时换行 图6.6.5输入Ctrl-Z后程序停止运行 图6.6.6输入Ctrl-Z程序停止后再输入ps，可以看到hello进程未被回收，只是被挂起。 图6.6.7输入jobs可以看到hello的状态是停止 图6.6.8输入fg后，程序重新开始运行 图6.6.9输入pstree后 图6.6.10使用kill命令杀死进程[4] 6.7本章小结本章阐述了进程的概念及作用，简要说明了Shell-Bash的概念和作用以及shell的处理流程。分析了hello的fork进程创建过程和execve过程，hello的进程执行。并且简要实践的hello的异常与信号处理。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址 逻辑地址：程序代码经过编译后出现在汇编程序中地址。逻辑地址由选择符（在实模式下是描述符，在保护模式下是用来选择描述符的选择符）和偏移量（偏移部分）组成。 线性地址：逻辑地址经过段机制后转化为线性地址，为描述符:偏移量的组合形式。分页机制中线性地址作为输入7.2Intel逻辑地址到线性地址的变换-段式管理段式内存管理方式就是直接将逻辑地址转换成物理地址，也就是CPU不支持分页机制。其地址的基本组成方式是段号+段内偏移地址。 在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值(index)。 首先给定一个完整的逻辑地址[段选择符：段内偏移地址], 1）看段选择描述符中的T1字段是0还是1，可以知道当前要转换的是GDT中的段，还是LDT中的段，再根据指定的相应的寄存器，得到其地址和大小，我们就有了一个数组了。 2）拿出段选择符中的前13位，可以在这个数组中查找到对应的段描述符，这样就有了Base，即基地址就知道了。 3）把基地址Base+Offset,就是要转换的下一个阶段的地址。 7.3Hello的线性地址到物理地址的变换-页式管理系统将每个段分割为被称为虚拟页（VP）的大小固定的块来作为进行数据传输的单元，虚拟地址分为虚拟页号VPN和虚拟页偏移量VPO，根据位数限制分析可以确定VPN和VPO分别占多少位是多少。 通过页表基址寄存器PTBR+VPN在页表中获得条目PTE，一条PTE中包含有效位、权限信息、物理页号。 如果有效位是0+NULL则代表没有在虚拟内存空间中分配该内存。 如果是有效位0+非NULL，则代表在虚拟内存空间中分配了但是没有被缓存到物理内存中。 如果有效位是1则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，与虚拟页偏移量共同构成物理地址PA7.4TLB与四级页表支持下的VA到PA的变换根据当前当前使用页的大小确定VPO的位数，再根据虚拟地址的位数，求出VPN的位数。 根据TLB的结构确定TLBI的位数，结合已求出的VPN就能得到对应的TLBT。根据TLBI和TLBT找到对应的TLB存储块，块中的内容就是PPN，又PPO和VPO相等。所以将得到的PPN和PPO组合起来就得到了PA。7.5三级Cache支持下的物理内存访问先将虚拟地址转换为物理地址，再对物理地址进行分析，物理地址一般由CT、CI、CO组成，用CI位进行索引，如果匹配成功且valid值为1，则称为命中，根据偏移量在L1cache中取数，如果不命中，在分别到L2、L3和主存中重复上述过程7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct，区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任意一个后来进行写操作时，写时复制机就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理在虛拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。图9-6展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页,在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。 接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图9-7展示了在缺页之后我们的示例页表的状态。 7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域，称为堆(heap)(见图9-33)。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长(向更高的地址)。对于每个进程，内核维护着一个变量brk(读做“break")，它指向堆的顶部。 分配器将堆视为一组不同大小的块(block)的集合来维护。每个块就是一个连续的虚拟内存片(chunk)，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 ●显式分配器(explicitallocator)，要求应用显式地释放任何已分配的块。例如，C标准库提供–种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。C++中的new和delete操作符与C中的malloc和free相当。 ●隐式分配器(implicitallocator)，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器(garbagecollector)，而自动释放未使用的已分配的块的过程叫做垃圾收集(garbagecollection)。例如，诸如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。7.10本章小结本章简单介绍了hello的存储器地址空间、intel的段式管理、hello的页式管理，TLB与四级页表支持下的VA到PA的变换，三级Cache支持下的物理内存访问，还介绍了hello进程fork时的内存映射，hello进程execve时的内存映射，缺页故障与缺页中断处理，动态存储分配管理。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件设备管理：unixio接口8.2简述UnixIO接口及其函数接口： 1）打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 2）Shell创建的每个进程都有三个打开的文件。标准输入（描述符为0），标准输出（描述符为1），标准错误（描述符为2）。 3）改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置k。 4）读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时执行读操作会触发一个称为end-of-file（EOF）的条件，应用程序能检测到这个文件。在文件结尾处并没有明确的“EOF符号”。 类似的，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 5）关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。 函数： 8.3printf的实现分析printf函数的源代码 vsprintf函数的源代码： intvsprintf(char*buf,constcharfmt,va_listargs){charp;chartmp[256];va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!='%'){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); } 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章主要介绍了hello的IO管理，包括：Linux的IO设备管理方法，UnixIO接口及其函数，printf和getchar的实现分析。（第8章1分）结论 hello.c经历了预处理，编译，汇编，链接，运行，程序结束回收进程等过程。hello.c在经过预处理，编译，汇编，链接过程后，一步步转化为可执行文件。而在运行过程中，又获得了跌宕起伏的冒险经历，创建子进程，运行程序，执行命令，对异常和信号进行处理。 （结论0分，缺失-1分，根据内容酌情加分） 附件hello.c(C语言源程序) hello.i(hello.c预处理之后的程序文本) hello.s(hello.i编译成汇编语言之后的程序文本) hello.o(hello.s生成的二进制文件) hello(可执行的hello二进制文件) （附件0分，缺失-1分） 参考文献为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp.（参考文献0分，缺失-1分） 

2021-07-01 目 录 第1章C语言的语言元素-5- 1.1程序结构-5- 1.1.1循序结构-5- 1.1.2分支-5- 1.1.3循环-6- 1.1.3.1for语句-6- 1.1.3.2while语句-6- 1.1.3.3do-while语句-6- 1.1.3.4break语句和continue语句-7- 1.2类型-7- 1.2.1整数类型-7- 1.2.2浮点类型-8- 1.2.3数组类型-8- 1.2.4结构体类型-8- 1.3量-8- 1.3.1常量-8- 1.3.2变量-9- 1.3.2.1全局变量-10- 1.3.2.2局部变量-10- 1.4指针与引用-10- 1.5函数-11- 第2章汇编语言的语言元素-12- 2.1内存映像与ELF文件-12- 2.2程序结构-13- 2.2.1整体结构-13- 2.2.2 分支-14- 2.2.3循环-17- 2.3类型-18- 2.3.1整数类型-18- 2.3.2浮点类型-18- 2.4栈和寄存器-19- 2.5函数-19- 2.5.1调用约定-19- 2.5.1.1cdecl约定-19- 2.5.1.2fastcall约定-20- 2.5.1.3thiscall约定-20- 2.5.1.4stdcall约定-20- 2.5.2示例-20- 第3章C语言的汇编实现-22- 3.1基本数据类型的操作-22- 3.1.1整数类型的计算-22- 3.1.1.1加法，减法-22- 3.1.1.2乘法，除法，求模-24- 3.1.1.3左移，右移-28- 3.1.1.4与，或，非-29- 3.1.1.5比较-31- 3.1.1.6求补（取反），异或-33- 3.1.2浮点类型的加载与运算-34- 3.1.2.1浮点数传送-35- 3.1.2.2浮点数四则运算-35- 3.1.2.3浮点数比较-37- 3.1.3基本类型的转换-38- 3.1.3.1整数与整数-38- 3.1.3.2整数与浮点数-41- 3.1.3.3浮点数与浮点数-43- 3.2寻址问题-43- 3.3函数-44- 3.4C语言程序结构的实现-44- 3.4.1分支-44- 3.4.2循环-44- 3.4.3编译器优化循环-45- 3.5指针-46- 3.6C++语言-46- 第4章C与汇编的优缺点分析-48- 参考文献-49- 第1章C语言的语言元素 满分15分 C语言是一种面向过程的编译型语言。下面，我们来说一说C语言的各种语言元素。 任何程序，本质上是数据和操作步骤（即计算）的结合体。要解读一中编程语言，可以从其对数据的描述和对计算方法的描述两个角度考察。 1.1程序结构 1.1.1循序结构 循序结构是最基本的程序结构。在C语言中，一系列语句按顺序罗列即为循序结构。使用{}将语句包围，形成语句块（body），同时成为变量的作用域。关于作用域，在后文还会提及。 1.1.2分支 if语句，或者说条件判断，可以说是所有程序的灵魂，镶嵌于循序语句们中。没有条件判断实际上是写不成真正意义上的程序的。C语言中if语句结构如下： if(/*条件1*/){ /*满足条件1执行*/ } elseif(/*条件2*/){ /*满足条件2执行*/ } else{ /*不满足上述条件执行*/ } 在if和else的组合中，无论条件如何，两个语句块（body，一条语句或由{}包围的多条语句）只会执行一个而另一个不执行，然后就离开if-else语句。if-else将两个语句块连接成了一个语句块，可见elseif其实是else与if的组合。上述结构等价于： if(/*条件1*/){ /*满足条件1执行*/ } else{ if(/*条件2*/){ /*满足条件2执行*/ } else{ /*不满足上述条件执行*/ } } 1.1.3循环 1.1.3.1for语句 在C语言中，有三种形式的循环语句：for，while，do-while。 for语句最为常用。 for(/*初始化*/;/*循环条件*/;/*步长操作*/){ /*循环体*/ } 在初始化语句中一般对要用于循环遍历和条件判断的变量进行初始化。在C99标准中，允许在初始化语句中声明变量。初始化语句只执行一次。每次执行循环体前，先判断循环条件是否为真（非零），只有为真在执行，否则程序离开循环语句。执行完循环体后，执行步长操作，通常操作用于循环遍历和条件判断的变量。然后，流程回到执行循环条件判断之前，开始下一次循环。 1.1.3.2while语句 其次while语句也比较常用。 while(/*循环条件*/){ /*循环体*/ } 每次执行循环体之前，先判断是否满足循环条件。循环条件为真就执行循环体。否则不执行，程序离开while语句。执行完循环体后程序流程回到判断循环条件前，准备进入下一次循环。 while相当于for的简化版，因此也有人喜欢这样写： for(;/*循环条件*/;){ /*循环体*/ } 1.1.3.3do-while语句 do-while语句使用得比较少。它与while语句类似。 do{ /*循环体*/ } while(/*循环条件*/); 不同的是，先执行循环体、后判断循环条件。 1.1.3.4break语句和continue语句 提到循环就必须提到break和continue，它们使流程控制在没有goto的情况下也足够灵活。在循环体中使用break语句，实现不执行完循环体直接离开循环语句。显然，对于for语句，也不会再执行循环条件判断或步长操作。在循环体中使用continue语句，实现将流程直接跳到本次循环体执行结束。可知，对于for语句，continue之后还会执行步长操作，然后进入下一次循环。 加上break和continue，三种循环语句一定程度上可以互相转化（但还是有一些细节差别）。 1.2类型 在C语言中，类型的概念非常重要，任何数据的表示都离不开类型。类型的本质，就是对数据的存储方式的抽象而又具体的描述。从实现上看，类型最终就是数据总大小以及数据成员的偏移量。同面向对象的编程语言不同，在C语言中，操作不是严格绑定在类型中的，而属于外置的。因为对于存储器上的一段数据，C语言允许将它描述成任意类型，并强制实施操作，而其正确性由程序员保证。 话虽如此，类型之间有区别，操作的不同非常关键。我们说到类型的实现，最终还是要说操作的实现。对于典型的数据类型，C语言确保通过编译器给出良好的操作实现。以下是几个典型的类型。 1.2.1整数类型 C语言提供了非常多的整数类型，虽然到具体平台，这些类型的实现只有几种。在C语言中，整数类型首先分为： signed：有符号类型，不明确标注默认为有符号类型 unsigned：无符号类型 有无符号在存储上没有本质区别，仅仅在于是否将最高有效位解释为符号位，主要区别在涉及大小判断时发生。一些常用类型如下，都可以标记为有符号或无符号： char：又称字符型，1字节 short：短整型，2字节 int：整型，4字节 longlong：长长整型，8字节 然而，由于历史原因，C语言标准不严格保证上述常用类型的大小严格等于上述经典大小。因此，当程序中需要特别严格指定整型数据大小时，出于移植性考虑，需要使用标准intN_t和uintN_t类型： int8_t与uint8_t：1字节的有符号和无符号整数 int16_t与uint16_t：2字节的有符号和无符号整数 int32_t与uint32_t：4字节的有符号和无符号整数 int64_t与uint64_t：8字节的有符号和无符号整数 等等。 1.2.2浮点类型 C语言中通常使用两种浮点类型： float：在遵循IEEE754的机器上对应规定中的中32位单精度浮点的规定。 double：在遵循IEEE754的机器上对应规定中的中64位双精度浮点的规定。 现在的机器大都遵循IEEE754标准。在许多情况下，我们使用浮点数做数学计算，只需要符合一些浮点数的基本要求就可以，并不特别关心细节。 1.2.3数组类型 C语言中的数组类型，本质上是将相应的类型的数据在存储器上地址连续地存储数组长度那么多个。因此，在实质上与多个在存储器上地址连续的相应类型的数据没有区别，只是可以使用一个数组名加索引号的方式访问。具体而言，即是通过数组名得到基址、索引号计算得到偏移地址，最终计算出相应数组元素的地址并访问。 1.2.4结构体类型 结构体对于描述复杂数据非常实用。本质上是将相应类型的数据依结构体描述的次存放在该结构体类型数据的存储空间上。因此，在实质上与多个在存储器上对应位置的相应类型的数据没有区别，只是可以使用结构体名加成员名的方式访问。具体而言，即是通过结构体名得到基址、成员名计算得到偏移地址，最终计算出相应结构体成员的地址并访问。可以说数组就是一种结构体，而其成员的名称分别为0,1,2 这样的数字（索引号）。 1.3量 C语言中量可分为常量和变量。本质上都是某种类型的数据在程序中的具体安排。 1.3.1常量 常量即程序运行过程中不可改变的量，我们编写程序的过程中已经明确写定的各种数值、const结构体等都是常量。常量可以分为两种，一般来说，各种写定的数字是无名的（因而他们会在机器指令的立即数中记录，后文会提及），另一种是通过const关键字定义的，是有名的，本质上就是一种从未改变的变量，后文对变量的讨论对其也适用。 1.3.2变量 变量的本质就是与变量名关联的一段存储空间，通过使用变量名实现对该存储空间的直接引用。变量最基本的属性，除了类型，就是存储位置。当然，变量的其他属性还包括作用域，权限等。const关键字，可以将变量声明为前文所述的常量，其保证通过变量名直接引用该变量时，不能有修改操作，否则产生编译错误。 C语言中，变量存在作用域。只有在合适的作用域中才能访问相应的变量，其基本规则为，源文件作为顶级域，{}包围产生的语句块（body）嵌套组合形成一级一级的作用域。变量的作用域是自身所在的域加上这个域的所有下级域。但是。C语言中，变量是可以重名的，这就需要屏蔽规则确定当前在访问哪个变量。对于某个作用域，在一个级别中不能存在两个同名的变量。这就是说，与某个变量同名的变量或来自上级域，或来自下级域，或在另一个无关域。 inti=0; //顶级域 intget(){ inti=1; //函数域 Intj=-1; //语句块1 { inti=2; //语句块1的域 { inti=3; //语句块1中的次级域 printf("i=%d\n",i); //打印i=3 printf("j=%d\n",j); //打印j=-1 } printf("i=%d\n",i); //打印i=2 } //语句块2 { inti=4;//语句块2的域 printf("i=%d\n",i);//打印i=4 } //定义重名变量导致编译错误 //inti=5; } printf都只能访问到本级定义的那个i，来自上级的i被屏蔽了，但来自上级的j没有被屏蔽，下级的i属于下级的语句块，即属于其他语句块，是不可见的。 1.3.2.1全局变量 一般来说全局变量可以分为两种，它们都是直接声明在源文件里，没有放进任何{}包围的块。 普通全局变量 在源文件中简单地按照类型+名称的格式声明即可。其作用域是整个程序，在所有函数、语句块（即所有域）中都可以通过变量名直接引用这个变量。extern关键字非常有用，extern之后加上相应变量原来的声明构成一个所谓的外部引用声明。表示引用的变量可能不在本文件中，需要在链接阶段从其他可重定位文件夹中寻找，或在动态链接阶段在其他共享库中查找。可见，通过extern实现了整个程序的作用域。 静态全局变量 与普通全局变量类似。其作用域是本源文件。程序的其他部分不能通过变量名直接引用这个变量。 1.3.2.2局部变量 局部变量分为两种。局部变量在函数或函数下的语句块声明，作用域是所在的域及其各个下级域（若没有被屏蔽）。 （1）普通局部变量 是我们通常意义上的局部变量，存储在栈空间。也就是说，每次调用相应的函数，分配的局部变量都是不同的，和上一次调用分配的局部变量无关。 （2）静态局部变量 声明局部变量时加上static关键字。其不同于普通局部变量，只会在程序初始化时分配一次空间，之后通过变量名引用的都是同一个变量。可以看成是语句块中的静态全局变量。 寄存器变量 使用register关键字，提示编译器将这个变量放在寄存器中，以优化程序。显然，由于种种原因，编译器不保证遵循这个建议。 1.4指针与引用 在C语言中，指针的本质是一种整型变量，意义为指向存储空间（通常为虚拟内存）的某些单元（即内存单元的索引号）。其大小是平台相关的，一般而言，当编译到32位，其大小为4字节；编译到64位，其大小为8字节。通过指针实现对变量的间接引用，方便了数据的访问。在C语言中，传递结构体等复杂类型的数据通常传递指针。 前文提及，const确保通过变量名直接引用变量并做修改操作会导致编译错误。那么对于通过指针间接引用变量，const还能发挥作用吗？一般来说，函数中声明的const局部变量存储在栈上，通过指针间接引用仍旧可以修改。而const全局变量存储于只读的虚存空间，便、通过指针间接引用并修改虽然不会产生编译错误，运行时却产生段错误。可见const的对全局变量更为严格。 1.5函数 在C语言中，函数的本质是一系列操作指令。通过函数名，可以访问这些操作指令，不仅可以调用函数，也可以读取具体的操作指令的机器码。函数本质上抽象为对指定数据集的一系列操作。在C语言中，函数是可以嵌套调用（在任何函数的语句都可以调用其他函数），递归调用（任何函数都可以递归地调用自己，实现递归算法）的。 函数指针是一种特殊的指针，将其赋值为不同的函数的地址，然后通过它间接引用函数，可以实现对一组规约相同的函数的动态调用。在面向对象的C++语言中，即是通过函数指针的数组vtable实现多态。 C语言中，函数的参数传递总是按值传递的，即参数列表中的参数变量是值和传递时所传递变量相同但存储在不同位置的另一个变量，即便对于参数是结构体类型也是如此。但是，数组除外，C语言实质上不支持将数组作为参数按值传递。当数组作为参数传递时，特殊的语法将它取了地址并传递了数组的指针，函数里访问传递的数组，也通过指针间接引用了原来的数组。 第2章汇编语言的语言元素 满分30分 汇编语言属于低级语言，与机器指令一一对应，是机器码更便于人识记的形式。下面，我们以IA-32/Linux为例，简要介绍一段汇编程序的代码结构。汇编程序直接描述了要汇编生成的ELF目标文件的结构。因此，有必要了解Linux上程序的内存映像以及ELF的一些基本知识。 2.1内存映像与ELF文件 ELF文件中有不同的节，存储不同的内容。.interp节记录动态链接器的路径，内核加载这个可执行文件时，会加载相应的动态链接器完成一些工作。.dynsym.symtab节记录ELF的符号信息，即这个ELF导出的自己的以及引用的外部的变量和函数等，在动态链接时有很大的作用。.dynstr.shstrtab.strtab等节记录一系列字符串，包括节的名称、符号的名称、程序字符串常量以及ELF中其他字符串信息。.rela.dyn.rela.plt等节记录重定位信息，帮助链接器完成各种重定位。.init.fini.init_array.fini_array等节记录了程序初始化、结束时需要执行的代码的地址，由动态链接器在相应的时候调用。 .data.rodata.bss是程序中使用的各种全局变量（只读、读写、有初始化、无初始化）所在的节。.text是程序机器指令主要存在的节，各种可执行的函数、代码都在这里。 .dynamic存放动态链接时需要的重要信息。.plt.plt.got.got.got.plt与内部外部的全局变量的访问有关系，是所谓的跳板。 内核或者外部的ELF装载器将ELF文件装载到内存中时，是按段来装载的。段头（程序头）记录了应该怎样把文件中的内容映射到进程虚存空间。 代码段指虚存空间中可读可执行的页面区域，装载了ELF文件中可以执行的机器码（如.text节）。数据段指虚存空间中可读的页面区域，其中一部分可写，装载了ELF文件中的.bss.data等数据内容。堆是一段大小可以动态改变的区域（调用sbrk系统调用移动堆的界限，向上延伸），一般由动态内存分配器管理，存储程序运行过程中动态分配空间的变量。栈用于维护函数调用、参数传递、局部变量，实现函数的抽象。 2.2程序结构 2.2.1整体结构 在汇编程序（.S文件）中，“.”开头的行代表汇编器相关指令，不以“.”开头的行则为程序机器指令和程序标签。汇编器指令主要是向汇编器提供机器指令之外的信息，如ELF节，ELF符号等。下面是一些汇编器指令的例子和说明： .data#告诉汇编器，接下来的内容是ELF的.data节 .text#告诉汇编器，接下来的内容是ELF的.text节，汇编指令就写在后面 .align 4 #接下来的数据按照4字节对齐 .globlmInt#定义一个全局ELF符号mInt .typemInt,@object#ELF符号mInt类型为object类型 .sizemInt,4#ELF符号mInt大小为4 .long-1#放置4字节有符号整数-1 .value-1 #放置2字节有符号整数-1 .byte-1 #放置1字节有符号整数-1 简单按顺序罗列机器指令，即构成相应的循序程序。使用jmp，call等指令控制程序跳转到其他位置而不是严格按照地址递增的顺序执行，是程序调用和循环结构的基础。 2.2.2 分支 前文提到，条件判断在程序中非常重要。与ARM不同，IA-32并不各种指令的条件执行，分支结构主要靠条件跳转指令jcc实现，jcc指令描述如下： 可以看到条件码还是很多的，可以满足各种场景。这些条件码也可用于cmovcc，fcmovcc，loopcc，setcc等条件执行的指令。 在汇编程序中使用jcc指令，前面一般结合cmp或test指令，计算要比较的内容并影响EFLAGS中的条件码相关标志位，然后jcc根据当前条件码标志位判断，满足条件码要求则跳转到指定标签处。 2.2.3循环 循环同样使用jcc来实现，不同于简单分支结构，循环结构中一定会有一条往回跳的指令（这里是jcc往回跳，但其实结合jmp也可以）。 2.3类型 在汇编语言中，实际上已经不强调类型的概念了。在这里，对各种数据类型，其操作都分解为基本的计算操作和访存操作。正如前文所述，讲类型就是讲操作。单条指令级别的操作是针对基本数据类型设计的。 2.3.1整数类型 IA-32是一种32位ISA，有针对1字节、2字节和4字节整数的单条指令级别的操作。但是没有针对8字节64位整数的单条指令级别的操作，要对64位整数做计算，需要多条指令配合（adc，sbb等指令在这里就非常重要）。机器做整数加减计算（使用add，sub指令）时，无所谓是有符号数还是无符号数，两种结果都会给出（结果的二进制位模式一样，状态标志位条件码不同），编写程序时选取一种结果进一步解释即可。对于乘法和除法运算，需要明确指定使用有符号数操作（mul，div指令）还是无符号数操作（imul，idiv指令）。 关于放置整数的汇编器指令，参考2.2.1。 2.3.2浮点类型 IA-32遵循IEEE754标准，有支持32位单精度浮点和64位双精度浮点运算的浮点协处理器及相应的指令。此外，还支持80位扩展精度浮点。在LinuxGCC中，为了严格和i386保持兼容，编译32位程序不会使用mmx，sse等功能更为强大的指令，只使用x87FPU的浮点指令。 2.4栈和寄存器 IA-32是非常典型的CISC架构的ISA，寄存器很少，而且在不少指令中有特殊语义。下面是8个通用寄存器： 其中，16位寄存器与32位寄存器低16位重合，而8位寄存器相应地与16位寄存器的高8位和低8位重合。eax，ecx，edx，ebx在指令中的特殊语义可以简短指令长度，实现优化，不使用特殊语义也是可以的，因此这4个寄存器通用性比较好。 esp固定作为栈指针其实不太具有通用意义。栈用于保存函数调用上下文，保存局部变量，非常重要。在IA-32中，栈是严格4字节对齐的。push指令向栈中压入元素，使esp向下移动，pop则将元素弹出，使esp向上移动。call指令将当前eip压入栈顶，保存调用返回地址，而ret指令将栈顶元素弹入eip，实现返回。 2.5函数 汇编语言本身是没有函数这样的概念的，可以说机器也不需要函数这样抽象的概念。但是，模块化的要求促使我们逐渐在汇编语言中引入子过程、函数这样的概念。总的来说，函数就是一段汇编代码加上一定的调用约定，函数对传递进来的参数做一系列操作。 2.5.1调用约定 理论上，在汇编语言中关于函数的调用、参数传递、返回值传递等可以做任意的规定。实际运用中，为了将汇编程序与高级语言程序如C、Pascal程序结合在一起使用，通常遵循高级语言汇编实现的调用约定。最常用的是cdecl，IA-32上的C语言标准调用约定。此外还有fastcall，thiscall，stdcall等。 2.5.1.1cdecl约定 cdecl约定是IA-32上C语言实现的默认约定，最为常用。其完全使用栈传递参数，参数从右到左依次压入栈中，call指令最后把函数返回地址压入栈中，然后跳转到函数第一条指令处。例如，函数有两个参数：(charc,inti)，call跳转后，参数列表中左起第一个参数c位于[esp+4]处，第二个参数i位于[esp+8]处，尽可能保持4字节对齐。函数返回时，需要清理自己使用的栈，确保此时栈顶是原来的返回地址（注意，传递的参数不属于被调用函数自己使用的栈，不用清理，调用者会清理这部分），然后使用ret指令返回原来call指令的下一条指令。使用eax寄存器传递4字节以内的返回值，使用eax寄存器及edx寄存器共同传递8字节以内的返回值。一般来说这些已经足够应付绝大部分情况了。 2.5.1.2fastcall约定 前两个4字节以内的参数分别使用ecx和edx寄存器传递，剩余参数从右到左依次压入栈中，call指令最后把函数返回地址压入栈中。函数返回时，需要先清理自己使用的栈，确保此时栈顶是原来的返回地址，然后使用ret指令返回的同时清理参数传递使用的栈（称为自动清理）。使用寄存器传递两个参数并使用自动清理，速度更快，代码量更小。对于可变参数的函数，不使用寄存器传参。 2.5.1.3thiscall约定 第一个4字节以内的参数分别使用ecx寄存器传递，剩余参数从右到左依次压入栈中，call指令最后把函数返回地址压入栈中。函数返回时，需要先清理自己使用的栈，确保此时栈顶是原来的返回地址，然后使用ret指令返回的同时清理参数传递使用的栈（称为自动清理）。使用寄存器传递一个参数并使用自动清理，速度更快，代码量更小。对于可变参数的函数，不使用寄存器传参。这个调用约定主要用于C++的非静态成员函数，ecx就用于传递隐藏的第一个参数this指针。 2.5.1.4stdcall约定 参数从右到左依次压入栈中，call指令最后把函数返回地址压入栈中。函数返回时，需要先清理自己使用的栈，确保此时栈顶是原来的返回地址，然后使用ret指令返回的同时清理参数传递使用的栈（称为自动清理）。使用自动清理，代码量更小。一般不用于可变参数函数。 2.5.2示例 实现同样操作计算a-b-c的四种不同调用约定的函数。函数前使用汇编器指令.global.type声明ELF符号信息，标签之后是函数的汇编指令，最后还使用.size汇编器指令声明函数大小。 第3章C语言的汇编实现 满分40分 C语言是一种高级语言，有一些高级、抽象的概念，有些内容层次较高，本质上可由C语言中层次较低的元素去实现，例如前文提到了数组和结构体实际上不过提供了一种基于指针和偏移量的更便捷的变量组织、寻址方式。下面我们介绍C那些特别基本而重要的操作在汇编语言中是如何实现的。 3.1 基本数据类型的操作 复杂的数据类型是基本数据类型的逻辑组合。类型最重要的特性是其操作。因此，必须清楚对基本数据类型的操作是如何实现的。 3.1.1整数类型的计算 C语言中支持很多整数类型的计算。 3.1.1.1加法，减法 在IA-32上，加法指令（add）和减法指令（sub）支持对8位整数，16位整数以及32位整数做计算。对于加法和减法，有符号数与无符号数没有区别，两种情况的结果标志位都会反映在eflags中。 但是，IA-32没有64位整数的加法和减法运算指令，需要编译器利用adc指令和sbb指令实现相应的内部例程。adc指令和sbb指令利用eflags中的进位借位信息，可以很方便地实现长地整数的加减法。 如图，对64位整数的加减法，先用add、sub指令计算低32位并保存进位借位信息到eflags。再使用adc、sbb指令，结合进借位信息计算高32位。 3.1.1.2乘法，除法，求模 和加法减法不同，乘法除法对于有符号数和无符号数，结果的二进制位模式不同。在IA-32上，同时提供适用于有符号数和无符号数的乘法与除法。mul与div指令分别是无符号乘法与除法，imul与idiv指令分别是有符号乘法与除法。同样地，有8位、16位、32位整数的指令但没有64位整数的指令。由于乘法与除法比较复杂，为了简化指令编码，使用了寄存器的特殊语义。 上面截图自intel的手册，其中的64位指令属于x86_64，在IA-32上是没有的。 然而，在C语言中，整数乘法的结果总是截断到参与运算的类型的大小。对于整数乘法，无符号数乘法与有符号数乘法的结果截断后位模式相同，实际上编译器不会在意mul与imul指令的选择，几乎总是使用imul。 对有符号数和无符号数都使用了imul指令实现乘法计算。 与乘法不同，对于除法，有符号数除法使用idiv指令实现，无符号数的除法使用了div指令实现。 求模运算就是除法取余运算，因此同样使用除法的指令实现，不过还要从特殊语义的寄存器dx，edx取出余数结果。 3.1.1.3左移，右移 C语言中支持左移和右移操作。其中右移分为逻辑右移与算术右移，分别可以看成无符号数除2的幂与有符号数除2的幂。 可见左移只有一种，右移有两种。其实有一个sal指令，是shl指令的别名。C语言中一般对有符号数做算术右移，无符号数做逻辑右移，但是这个不是C语言标准中明确要求的，只是绝大部分编译器都这样实现。 3.1.1.4与，或，非 C语言中没有专门的布尔类型，普通的整数可以做布尔类型参与逻辑与、或、非运算。同时整数也可做位与、或、非运算。在IA-32中，有专门的指令做位级的与、或、非运算，分别是and指令，or指令和not指令。逻辑与、或、非运算需要结合计算结果的标志位信息做条件判断。 3.1.1.5比较 C语言中，整数比较运算根据两个数的大小关系给出逻辑结果。在IA-32中，有一个专门用于整数比较的指令cmp，其本质与sub相同，都是将两数相减。不同之处在于，cmp只影响体现大小关系的结果标志位，不会把最终计算结果送到目标处。cmp指令通常结合条件执行的指令jcc，setcc，cmovcc等。在第二章我们提到，IA-32条件执行码很多，可以应对各种情况，也可用于优化。这里仅列出一部分： 3.1.1.6求补（取反），异或 C语言中，求有符号数的相反数，也就是求补运算也很常用。此外还有一个很少用但有趣的运算：位异或运算。在IA-32中，有专门的指令实现这两个运算。 3.1.2浮点类型的加载与运算 一般来说，C语言中的float类型对应IEEE754标准中的32位单精度浮点，double类型对应IEEE754标准中的64位双精度浮点。IA-32是小端序的，根据标准，float和double类型的存储方式如下： 在IA-32上，有专门的x87浮点协处理器做浮点运算。后来还有更现代的mmx，sse等指令用于处理浮点数。在Linux上，GCC为了保持与i386的严格兼容，不会主动使用现代的扩展指令集实现浮点运算，只使用x87浮点指令。x87FPU的指令很有特点，所有计算、转换操作都是围绕一个特殊的浮点工作栈进行的。因此，进行浮点计算不像整数计算那么简单，首先要使用专门的装载指令将浮点数压入浮点栈。 3.1.2.1浮点数传送 fld、fst系列的指令专门负责将浮点数从通用的内存引用移送到浮点栈、将浮点数移送到通用的内存引用。通用寄存器不能用于保存浮点数。 3.1.2.2浮点数四则运算 x87FPU的浮点计算指令能支持32位单精度浮点数、64位双精度浮点数以及80位扩展精度浮点数的运算。 可以看到每一个函数的实现中都有fld指令负责将浮点数从通用栈传送到浮点栈。和整数计算指令一样，浮点数计算指令也可以将通用内存引用作为参数。 3.1.2.3浮点数比较 一般来说，C语言中浮点数比较运算主要用“>”和“<”，通常来说计算结果是有误差的，比较是否严格相等没有意义。在x87中，使用fcomi，fcomip，fucomi，fucomip比较浮点数并在eflags里设置结果标志位。 3.1.3基本类型的转换 3.1.3.1整数与整数 当两个类型大小相等时，汇编代码层面不做任何转换。这是因为有符号数与无符号数存储方式完全一样，C语言转换后，后续进行操作，使用相应的（无符号数或有符号数的）指令即可。 由图可见没有任何转换指令。 当目标类型大小比原类型小时，直接截取低位做截断，对有符号数也是如此。在IA-32中，利用寄存器之间的重合关系可以很方便地做整数截断。 当目标类型大小比原类型大时，根据是有符号数还是无符号数，选用相应的扩展操作。IA-32中，movzx传送数据同时进行零扩展，适用于无符号数；movsx传送数据同时进行符号扩展，适用于有符号数。 3.1.3.2整数与浮点数 整数与浮点数的转换不能直接进行，必须做一些运算。在x87中，fist、fild指令传送数据的同时可以进行浮点数与整数之间的转换，fiadd、fisub、fimul、fidiv指令在计算前将整数转换为浮点数参与计算（编译器可能不会使用这些指令进行优化）。但是，这些转换都是将整数看成有符号整数的。要对无符号整数进行转换，需要将它用更大的有符号数表示，可能还要其他算法。 3.1.3.3浮点数与浮点数 这是x87FPU的浮点工作栈一个很有意思的地方。当把数据压进浮点栈时，将它看成一种抽象的浮点数，之后进行计算时我们不关心浮点数的类型；当把数据从浮点栈弹出传送到通用内存引用时，自动转换为相应的浮点类型。 3.2 寻址问题 在C语言中，除了寄存器类型的变量，其他变量都对应虚拟内存上一个存储空间。IA-32采用平坦模型，程序中使用统一的虚拟地址即可，不需要考虑分段寻址的问题。基本类型的变量编译器都分配了绝对或相对的地址，使用这个地址即可。在C语言中对变量使用“&”运算符，可明确得到其地址。对于浮复杂类型如数组和结构体，在第一章讲述了成员寻址的方式，这里不再重复。 3.3函数 汇编程序中的函数就是C语言程序中的函数的实现。某种意义上说，我们在汇编里写函数就是模仿编译器生成函数。使用栈保存局部变量与调用上下文，实现了函数的封装，使函数内可以调用任何函数。 3.4C语言程序结构的实现 3.4.1分支 编译器分别为分支的两个情况（if和else）生成相应的代码片段，其中包括离开分支结构的代码。然后在前面生成进入分支结构的代码，即判断和条件跳转。 3.4.2循环 这里我们以典型的for循环为例。首先是循环体的代码片段，然后在合适的位置插入判断以及条件跳转（往后跳离开循环还是往前跳继续循环），最后补上初始化语句与步长增加语句。 3.4.3编译器优化循环 我们继续看3.4.3中的例子，使用-O3选项进行优化后，明显可以看到编译器更多使用寄存器，并且调整了程序结构，比如，首次判断与后面的判断分开了，步长增加操作混在循环体中。但是，编译器保证这样的结构仍旧与原循环效果一致。 3.5指针 在第一章我们提到过，C语言中指针的本质其实是整数类型。指针的运算（加法减法）也是用整数的运算实现。但是，涉及到指针的运算有一些普通整数运算不具有的特点，因此，在IA-32上，常常使用lea指令优化指针运算。 指针有别于普通整数类型的最关键点是，“*”算符的解引用运算。通过这个运算，可以间接引用C语言中的其他变量。在IA-32中，因为指令支持内存引用作为操作数，指针解引用运算可以由各种指令实现（与IA-32这种CISC架构不同，在典型RISC架构如ARM中，只有专门的ld、st类的指令才能一般性地引用内存）。常用mov指令实现指针解引用，实现对指定虚拟地址空间的访问。 3.6C++语言 C++语言是在C语言的基础上增加面向对象、模版编程等高级内容设计而成的，和C语言一样可以直接编译成机器可执行文件。而C语言既有足够的抽象能力，又接近底层。因此，C++语言的各种特性，一部分是语言高级特性，由编译器在较高层次支持；另一部分要使用汇编语言实现的内容，其实完全都可以使用C语言实现。这就是说，我们只需要考虑如何将C++语言的特性在C语言中妥善地表示出来就可以了。 例如，C++中非静态成员函数可以访问this指针，指向调用该函数的对象。用C语言表示，可以看成是成员函数有第0个隐藏的参数this。编译器只需要将成员函数改写成适当的C函数，再生成调用代码就可以了。这部分内容在第二章thiscall也有涉及。 又例如，C++中传递参数可以传递对象的引用。而普通的引用，究其本质是C语言中的指针，只不过传参的时候编译器自动帮我们做了取地址运算而已。 类是C++语言中非常重要的特性。实际上，类与C语言中的结构体是完全一样的实现方式，即对于成员变量，提供一个从成员名到偏移量的映射关系，便于进行访问。而成员函数本质上是外置的函数，和C语言中的函数没有本质区别。对于具有virtual函数的类，在类的成员变量开头有一个隐藏的成员变量，是一个指针，指向一个记录本类虚函数函数指针的数组，称为vtable。 第4章C与汇编的优缺点分析 满分15分 关于C语言：有良好的抽象同时能满足底层的开发要求。因此使用C语言开发程序，开发速度快。相比于其他高级语言，更接近底层，因而软件性能损失很小。遵循保持程序可移植性的各项原则，使得移植一般通用的C语言程序心智负担很小。但是，由于编译器出于通用性、兼容性、实现复杂性等方面考虑，不会激进地使用CPU的新特性，使用C语言编程难以充分利用CPU的新特性进行优化。尽管编译器会不断支持新硬件并放弃旧硬件，这个过程相比于CPU的迭代总是落后的。 关于汇编语言：一般来说是最为接近底层的，可以更好地掌控程序的运行，控制CPU的状态。不仅能做C语言能做的，还能做其不能做的。一般来说，编译器套装中汇编器更新是比较快的，因而使用汇编语言可以很快就用上CPU的新特性。针对CPU的特点，并运用新特性，可以有效提高程序的运行速度。但是由于汇编比较难懂，能熟练使用汇编语言的程序员相对较少。汇编很繁琐，导致开发速度不可能很快。汇编与具体的CPU相关，抽象不足，可移植性很差，每移植到一个新指令集的CPU都需要重写。 根据C语言和汇编语言的优缺点可知，为了降低开发成本、减少不必要的工作，应该尽可能使用C语言。事实上，现在即使在像linux内核这样非常底层的软件的开发中，也是严格限制汇编的使用的。但是，有些情况下必须使用汇编。有可能是相关的操作在C语言能力范围之外：例如execve()系统调用结束时更改用户进程的栈寄存器，C语言不提供这样的能力，只能使用汇编完成。有可能是使用汇编带来的收益很大，可以接受其带来的麻烦：例如在使用CPU渲染的OpenGL驱动程序中，使用汇编语言编写关键操作，可以充分利用SSE，AVX，armneon等高性能指令集，带来显著的性能提升。可见，现如今虽然汇编已经写得很少了，但不能一味排斥，必须具体问题具体分析，在合适的情况使用它。 参考文献 Intel®64andIA-32Architectures SoftwareDeveloper’sManual Volume2(2A, 2B,2C&2D):InstructionSetReference,A-ZAndroid社区源代码在线阅读https://www.androidos.net.cn/ 

CSAPP大作业 计算机系统 大作业 摘 要 回顾本学期计算机系统所学的内容，复习所学知识。在对hello程序运行的分析，研究在linux下p2p与020。巩固了预处理、编译、汇编、链接等的知识。 关键词：编译；汇编；链接；预处理；hello的进程管理；p2p；020 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 P2P：经过预处理、编译、汇编、链接之后，hello.c变成目标程序执行，在shell里启动之后，shell调用fork创建子进程。 020：shell映射虚拟内存，加载进物理内存执行代码，结束后shell父进程回收hello进程，释放内存并删除数据结构。 1.2环境与工具 X64CPU，2GHz，16GRAM，1TSSD； Win10，VMware，Ubuntu20.04 1.3中间结果 hello.i：预处理 hello.s：所得汇编代码 hello.o：所得的可重定位目标执行文件 hello.out：链接后所得二进制文件 hello：可执行程序 1.4本章小结 对hello做了简单介绍，；列举所需的环境与工具和中间结果的文件。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 C/C++程序中的源代码中包含以#开头的各种编译指令，这些指令称为预处理指令。预处理指令不属于C/C++语言的语法，但在一定意义上可以说预处理扩展了C/C++。 C预处理器提供了四个独立的功能：包含头文件（可以替换到程序中的声明文件）；宏扩展（可以定义宏，C预处理器将在整个程序中用宏的定义替换宏）；条件编译（使用特殊的预处理指令，可以根据不同的条件包括或排除部分程序）；和行控制（如果使用程序将源文件合并或重新排列为一个中间文件，然后编译该文件，则可以使用行控制通知编译器每个源代码行的起源位置）。 2.2在Ubuntu下预处理的命令 gcc-E-ohello.ihello.c 图表1预处理截图 2.3Hello的预处理结果解析 预处理后文件最开头的三个#include消失，一段代码代替了三个#include。方便下一部处理。 图表2hello.i文件 2.4本章小结 了解预处理的概念及作用，还有如何在linux进行预处理，并分析所得的.i文件。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译(compilation,compile)利用编译程序从源语言编写的源程序产生目标程序的过程。用编译程序产生目标程序的动作。编译就是把高级语言变成计算机可以识别的二进制语言。编译程序把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。 3.2在Ubuntu下编译的命令 gcc-Shello.i-ohello.s 图表3编译截图 3.3Hello的编译结果解析 3.3.1hello.s文件 图表4hello.s文件 3.3.2数据 （1）字符串 即Usage:Hello学号姓名！\n Hello%s%s\n （2）变量 全局变量sleepsecs，先初始化为2，然后存放在.rodata节 局部变量inti 参数intargc （3）数组 argv作为一个指针数组，每个地址是8位 3.3.3关系操作 cmpl$9,-4(%rbp) i<10优化变成i<=9 cmpl$3,-20(%rbp) argc!=3 3.3.4算术操作 addl$1,-4(%rbp) i加一 leaq.LC1(%rip),%rdi 计算格式串地址 3.3.5函数操作 main call指令将下一条指令的地址压入栈中，然后跳转到main函数，main将%eax设置为0返回 exit callexit@PLT printf 第一次callputs@PLT 第二次callprintf@PLT sleep callsleep@PLT getchar callgetchar@PLT 3.4本章小结 对hello.s文件的分析，明白各个部分的作用，了解机器指令是如何操作的。 第4章汇编 4.1汇编的概念与作用 通过汇编器，把汇编语言翻译成机器语言。作用：通过汇编这个过程，把汇编代码转化成了计算机完全能够理解的机器代码。 4.2在Ubuntu下汇编的命令 gcchello.s-s-ohello.o 图表5汇编截图 4.3可重定位目标elf格式 readelf-hhello.o 图表6文件头截图 可以看出文件的各类信息。 图表7节头部表 节头部表包含节的名称，类型等等。 图表8符号表 包含main定义和引用的符号的信息。每个可重定位目标模块都有一个符号表，它包含m的定义和引用的符号的信息。符号表是由汇编器构造，使用编译器输出到汇编语言.s文件中的符号。每个符号表是一个条目的数组。 4.4Hello.o的结果解析 Objdump-d-rhello.o>hello.txt 图表9hello.o反汇编截图 hello.o与hello.s的不同： 1、hello.o中分支转移是通过地址跳转，而hello.s是用段名称跳转。 2、为了机器识别，hello.o左边多了机器码。 3、hello.s文件中，全局变量是通过语句：段地址+%rip完成的，而在hello.o中，则是：0+%rip。 机器语言： 机器语言是二进制的机器指令的集合，其特点是灵活、速度快和直接执行，机器指令是由操作码和操作数构成。 汇编语言：主体是汇编指令，是机器指令便于记忆的表示形式。汇编指令和机器指令在指令的表示方法上有所不同。 4.5本章小结 对汇编进行介绍，包括汇编的概念与作用，对可重定位目标elf格式进行分析，对hello.o与hello.s文件进行比较，加深对汇编的理解。 第5章链接 5.1链接的概念与作用 概念：将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件。目标文件是包括机器码和链接器可用信息的程序模块。 作用：链接器的工作就是解析未定义的符号引用，将目标文件中的占位符替换为符号的地址。链接器还要完成程序中各目标文件的地址空间的组织，这可能涉及重定位工作。 5.2在Ubuntu下链接的命令 图表10链接截图 命令行：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 图表11hello的elf 节头部表： 图表12节头部表 图表13节头部表 符号表： 图表14符号表 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息。 图表15edb 窗口显示虚拟地址由0x401000开始，到0x402000结束，这之间的每一个节对应5.3中的每一个节头表的声明。 5.5链接的重定位过程分析 图表16objdump 各地址为重定位之后的虚拟内存的地址，从0x401000开始。hello.o是从0000000开始。在开头hello多了.init，.fini，.plt，.plt.got节，分别是程序初始化执行的代码，程序终止时需要执行的代码，动态链接中的过程连接表，动态链接中的全局偏移表。 5.6hello的执行流程 使用edb执行hello，从加载hello到_start，到callmain,以及程序终止的主要过程如下： 子程序名程序地址（16进制）ld-2.27.so!_dl_start7efbff4d8ea0ld-2.27.so!_dl_init7efbff4e7630hello!_start400500libc-2.27.so!__libc_start_main7efbff100ab0hello!puts@plt4004b0hello!exit@plt4004e0 5.7Hello的动态链接分析 动态链接使我们在调用一个共享库定义的函数可以在运行时找到函数的地址。但是在调用时编译器没办法预测这个函数（共享库定义）的运行时地址，因为定义它的共享模块可以在运行时加载到任何位置。但是GNU编译系统通过延迟绑定技术来解决这个问题，将过程地址的绑定推迟到第一次调用该过程中。 延迟绑定通过：GOT和PLT实现，如果一个目标模块调用定义在共享库中的任何函数，那么他就有自己的GOT和PLT。 第一次调用共享库函数时，不调用共享库函数，直接进入函数对应的PLT中，接着PLT指令通过对应的GOT指令进行间接跳转，由于每个GOT指令初始时都指向他对应的PLT条目的第二条指令，所以这个间接跳转只是简单的把控制传回PLT条目的下一条指令。接着把函数的ID入栈PLT跳转到PLT[0]，PLT[0]再将动态链接器的一个参数入栈，然后间接跳转到动态链接器中。动态链接器依据两个栈条目确定函数的运行位置，重写对应的GOT条目，再把控制传给函数。 所以，在运行dl_init前，GOT表中存放的都是对应PLT条目的第二条指令，在运行dl_init后，GOT表中存放的就是对应的函数的地址。 5.8本章小结 本章结合实验中的hello可执行程序依此介绍了链接的概念及作用，在Ubuntu下链接的命令行；并对hello的elf格式进行了详细的分析对比，同时注意到了hello的虚拟地址空间知识；并通过反汇编hello文件，将其与hello.o反汇编文件对比，详细了解了重定位过程；遍历了整个hello的执行过程，在最后对hello进行了动态链接分析。 第6章hello进程管理 6.1进程的概念与作用 概念：进程是一个执行中的程序的实例，系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 作用：进程提供给应用程序两个关键抽象： 1、逻辑控制流 每个程序似乎独占地使用CPU 通过OS内核的上下文切换机制提供 2、私有地址空间 每个程序似乎独占地使用内存系统 OS内核的虚拟内存机制提供 6.2简述壳Shell-bash的作用与处理流程 Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等。 Shell处理流程： 1.打印提示信息 2.等待用户输入 3.接受命令 4.解释命令 5.找到该命令，执行命令，如果命令含有参数，输入的命令解释它 6.执行完成，返回第一步 6.3Hello的fork进程创建过程 shell先判断出不是内置命令，于是加载可执行文件hello，通过fork创建一个子进程，子进程得到与父进程用户级虚拟地址空间相同的一份副本。子进程还获得与父进程任何打开文件描述符相同的副本。子进程与父进程有不同的pid。fork被调用一次，返回两次。在父进程中fork返回子进程的pid，在子进程中fork返回0.父进程与子进程是并发运行的独立进程。 6.4Hello的execve过程 在shell创建的子进程中将会调用execve函数，来调用加载器，加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。每个程序都有一个运行时内存映像，如图6.2所示。当加载器运行时，它创建类似图6.2所示的内存映像。在程序头部表的引导下，加载器将可执行文件的片（chunk）复制到代码段和数据段。接下来，加载器跳转到程序的入口点，也就是_start函数的地址。这个函数是在系统目标文件ctrl.o中定义的，对所哟额C程序都是一样的。_start函数调用系统启动函数__libc_start_main，该函数定义在libc.so中，它初始化执行环境，调用用户层的main函数，处理main函数的返回值，并且在需要的时候把控制返回给内核。 6.5Hello的进程执行 系统中的每个程序都运行在某个进程的上下文中。上下文由程序正确运行所需的状态组成，这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 内核调度hello的进程开始进行，输出Hello与之前输入的内容，然后执行sleep函数，这个函数是系统调用，它显示地请求让调用进程休眠。内核转而执行其他进程，这时就会发生一个上下文转换。2s后，又会发生一次进程转换，恢复hello进程的上下文，继续执行hello进程。重复9次这个过程。 循环结束后，后面执行到getchar函数，这时读取数据一般需要很长的时间，所以将会发生一个上下文切换转而执行其他进程，当数据已经被读取到缓存区中，将会发生一个中断，使内核发生上下文切换，重新执行hello进程。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 图表17回车 回车：进程被回收 图表18Ctrl+Z Ctrl+Z：停止前台作业 图表19Ctrl+C Ctrl+C：程序终止 图表20乱按 乱按：乱按的内容保存在缓冲区，按下回车会在程序停止后执行这些内容，不按回车则不执行 6.7本章小结 异常控制流发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。 1）在硬件层，异常是由处理器中的事件触发的控制流中的突变 2）在操作系统层，内核用ECF提供进程的基本概念。 3）在操作系统和应用程序之间的接口处，应用程序可以创建子进，等待他们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。 4）最后在应用层，C程序可以使用非本地跳转来规避正常的调用/返回栈规则，并且直接从一个函数分支到另一个函数。 同时还有四种不同类型的异常：中断，故障，终止和陷阱。 第7章hello的存储管理 7.1hello的存储器地址空间 物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址。 逻辑地址：程序代码经过编译后出现在汇编程序中地址。逻辑地址由选择符（在实模式下是描述符，在保护模式下是用来选择描述符的选择符）和偏移量（偏移部分）组成。 线性地址：逻辑地址经过段机制后转化为线性地址，为描述符:偏移量的组合形式。分页机制中线性地址作为输入。 7.2Intel逻辑地址到线性地址的变换-段式管理 段式内存管理方式就是直接将逻辑地址转换成物理地址，也就是CPU不支持分页机制。其地址的基本组成方式是段号+段内偏移地址。 在x86保护模式下，段的信息即段描述符占8个字节，段信息无法直接存放在段寄存器中。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值。 首先给定一个完整的逻辑地址 1.看段选择描述符中的T1字段是0还是1，可以知道当前要转换的是GDT中的段，还是LDT中的段，再根据指定的相应的寄存器，得到其地址和大小，我们就有了一个数组了。 2.拿出段选择符中的前13位，可以在这个数组中查找到对应的段描述符，这样就有了Base，即基地址就知道了。 3.把基地址Base+Offset,就是要转换的下一个阶段的地址。 7.3Hello的线性地址到物理地址的变换-页式管理 线性地址的表示方式是：前部分是虚拟页号后部分是虚拟页偏移。 CPU通过将逻辑地址转换为虚拟地址来访问主存，这个虚拟地址在访问主存前必须先转换成适当的物理地址。CPU芯片上叫做内存管理单元（MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址。然后CPU会通过这个物理地址来访问物理内存。 页表结构：在物理内存中存放着一个叫做页表的数据结构，页表将虚拟页映射到物理页，每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。 页表就是一个页表条目（PTE）数组，虚拟地址空间中的每个页在页表中的一个固定偏移量处都有一个PTE。PTE是由一个有效位和一个n个字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置。 MMU利用虚拟页号（VPN）来在虚拟页表中选择合适的PTE，当找到合适的PTE之后，PTE中的物理页号（PPN）和虚拟页偏移量（VPO）就会组合形成物理地址。其中VPO与PPO相同，因为虚拟页大小和物理页大小相同，所需要的偏移量位数也就相同。此时，物理地址就通过物理页号先找到对应的物理页，然后再根据物理页偏移找到具体的字节。 7.4TLB与四级页表支持下的VA到PA的变换 在酷睿i7中，36位的虚拟地址被分割成4个9位的片。CR3寄存器包含L1页表的物理地址。VPN1有一个到L1PTE的偏移量，找到这个PTE以后又会包含到L2页表的基础地址；VPN2包含一个到L2PTE的偏移量，找到这个PTE以后又会包含到L3页表的基础地址；VPN3包含一个到L3PTE的偏移量，找到这个PTE以后又会包含到L4页表的基础地址；VPN4包含一个到L4PTE的偏移量，找到这个PTE以后就是相应的PPN。 7.5三级Cache支持下的物理内存访问 酷睿i7MMU使用四级页表来将虚拟地址翻译成物理地址，得到了物理地址PA。现在分析三级cache支持下的物理内存访问。 L1Cache是8路64组相联。块大小为64B。因此CO和CI都是6位，CT是40位。根据物理地址（PA），首先使用CI组索引，每组8路，分别匹配标记CT。如果匹配成功且块的有效位是1，则命中，根据块偏移CO返回数据。 如果没有匹配成功或者匹配成功但是标志位是1，则不命中，向下一级缓存中取出被请求的块，然后将新的块存储在组索引指示的组中的一个高速缓存行中。一般而言，如果映射到的组内有空闲块，则直接放置，否则必须驱逐出一个现存的块，一般采用最近最少被使用策略LRU进行替换。 7.6hello进程fork时的内存映射 在用fork创建虚拟内存的时候，要经历以下步骤： 1.创建当前进程的mm_struct，vm_area_struct和页表的原样副本 2.两个进程的每个页面都被标记为只读页面 3两个进程的每个vm_area_struct都被标记为私有 7.7hello进程execve时的内存映射 exceve函数加载和执行程序Hello，需要以下几个步骤： 1.删除已存在的用户区域。 2.映射私有区域。为Hello的代码、数据、bss和栈区域创建新的区域结构，所有这些区域都是私有的、写时复制的。 3.映射共享区域。比如Hello程序与标准C库libc.so链接，这些对象都是动态链接到Hello的，然后再用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC）。exceve做的最后一件事就是设置当前进程的上下文中。 7.8缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3,从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。 缺页处理程序从磁盘上用VP3的副本取代VP4，在缺页处理程序重新启动导致缺页的指令之后，该指令将从内存中正常地读取字，而不会再产生异常。 7.9动态存储分配管理 基本方法：维护一个虚拟内存区域“堆”，将堆视为一组不同大小的块的集合来维护，每个块要么是已分配的，要么是空闲的，需要时选择一个合适的内存块进行分配。 1记录空闲块，可以选择隐式空闲链表，显示空闲链表，分离的空闲链表和按块大小排序建立平衡树。 2放置策略，可以选择首次适配，下一次适配，最佳适配。 3合并策略，可以选择立即合并，延迟合并。 4需要考虑分割空闲块的时机，对内部碎片的忍耐阈值。 7.10本章小结 1）虚拟内存是对主存的一个抽象。支持虚拟内存的处理器通过使用一种叫做虚拟内存寻址的间接形式来引用主存。处理器产生一个虚拟地址，在被发送到主存之前，这个地址被翻译成一个物理地址。从虚拟地址空间到物理地址空间的地址翻译要求硬件和软件紧密合作。专门的硬件使用页表来翻译虚拟地址，而页表的内容是由操作系统提供的。 2）虚拟内存提供三个功能：简化了内存保护；简化了内存管理；在主存中自动缓存最近使用的存放在磁盘上的虚拟地址空间的内容。 3）地址翻译的过程必须和系统中的所有的硬件缓存的操作集成在一起。 4）内存映射为共享数据、创建进程以及加载程序提供了一种高效的机制。 5）动态内存分配器直接操作内存，无需类型系统的很多帮助。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 文件的类型： 普通文件：包含任意数据的文件。 目录：包含一组链接的文件，每个链接都将一个文件名映射到一个文件（他还有另一个名字叫做“文件夹”）。 套接字：用来与另一个进程进行跨网络通信的文件 命名通道 符号链接 字符和块设备 设备管理：unixio接口 打开和关闭文件 读取和写入文件 改变当前文件的位置 8.2简述UnixIO接口及其函数 1.UnixIO接口： 打开文件：一个应用程序通过要求内核打开相应的文件，宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符。它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 shell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。 改变当前的文件位置：对于每个打开的文件，内核保持着一个文件的位置k，初始为0，这个文件的位置是从文件开头起始的字符偏移量。应用程序能够通过执行seek操作，将文件的当前位置设置为k。 读写文件：读操作就是从文件中复制n>0个字节到内存中，从当前文件位置k开始，然后将k增加到k+n。而写操作就是从内存复制字节到文件中。 关闭文件：当应用完成了对文件的访问后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 2.UnixIO函数： open函数:调要open函数可以打开或创建一个文件。 create函数：创建一个文件，也可通过以特定参数使用open来实现。 close函数：读文件进行关闭。 Iseek函数：为一个打开的文件设置其偏移量。 read函数：从打开的文件中读数据到buf。 write函数：写入文件。 pread,prwrite函数：主要用于解决文件共享问题。 dup函数 syns函数：用于解决延迟写问题，保证磁盘上实际文件系统和缓冲区高速缓存中内容的一致性。 8.3printf的实现分析 intprintf(constcharfmt,…) { inti; charbuf[256]; va_listarg=(va_list)((char)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 调用了两个函数vsprintf，write。 vsprintf函数的作用是将所有的参数内容格式化之后存入buf，然后返回格式化数组的长度。 write函数是将buf中的i个元素写到终端的函数。 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(–n>=0)?(unsignedchar)*bb++:EOF; } getchar函数调用read函数，将整个缓冲区都读到buf里，并将缓冲区的长度赋值给n。返回时返回buf的第一个元素，除非n<0。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 了解了hello的IO管理，以及读写的两个函数的实现 结论 C语言编写hello.c； 预处理hello.c，得到hello.i； 编译hello.i成为汇编文件hello.s； 汇编hello.s，将其变为可重定位目标文件hello.o； 链接，将hello.o与可重定位目标文件和动态链接库链接成为可执行程序hello 运行hello，在shell中输入./hello1190201214zzq shell调用fork创建子进程 shell调用execve，映射虚拟内存 进入程序，载入物理内存，进入main函数 执行指令：CPU为其分配时间片，在一个时间片中，hello享有CPU资源，顺序执行自己的控制逻辑流 访问内存：MMU将程序中使用的虚拟内存地址通过页表映射成物理地址。 动态申请内存：printf会调用malloc向动态内存分配器申请堆中的内存。 信号：运行途中键入不同指令，做出不同反应。 结束：shell父进程回收子进程，内核删除为这个进程创建的所有数据结构。 附件 列出所有的中间产物的文件名，并予以说明起作用。 hello.c 源文件 hello.i 预处理得到的文件 hello.s 编译得到汇编语言文件 hello.o 得到可重定位目标文件 hello 得到可执行目标文件 参考文献 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 

2021-06-30 摘要 为了学习计算机系统并对计算机有更好的了解，本文通过一个简单的小程序hello.c从产生到死亡的一生，来介绍Linux系统下的程序从代码到运行再到最后终止过程的底层实现进行了分析，描述了与之相关的计算机组成与操作系统的相关内容。过gcc、objdump、gdb、edb等工具对一段程序代码预处理、编译、汇编、链接与反汇编的过程进行分析与比较，并且通过shell及其他Linux内置程序对进程运行过程进行了分析。关键词：计算机系统；汇编；计算机组成原理； 第1章概述 Hello简介 简述Hello的P2P，020的整个过程。P2P（FromProgramtoProcess）：Hello.c（program）文件通过预处理，编译，汇编，链接，生成可执行文件hello，随后在Bash里，OS为该文件fork出子进程（process），并将文件execve入内存，再进行mmap映射，在分配的时间片得以执行，在Hardware上运行。完成P2P的过程。020（FromZero-0toZero-0）：shell为其execve映射虚拟内存。进入程序入口后，程序开始加载物理内存，然后进入main函数执行目标代码。CPU为正在运行的hello分配时间片以执行逻辑控制流。程序完成后，shell父进程负责恢复hello进程，内核删除相关的数据结构这就是hello的020过程； 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。Ubuntu64位，Windows1064位codeblocks,gdb,edb,visualstudio2019 1.3中间结果 文件名文件作用hello.c:源代码hello.i:hello.c文本预处理后得到的程序文件hello.s:hello.i编译后得到的汇编程序文件hello.o:hello.s汇编后得到的可重定位目标程序文件hello:链接后得到的可执行目标程序文件 1.4本章小结 初步介绍了hello程序的过程。 第2章预处理 2.1预处理的概念与作用 预处理的概念：编译预处理是C语言编译程序的组成部分，用于解释处理C语言源程序种的各种预处理指令，形式上都以#开头不属于C语言种真正的语句，但增强了C语言的编程功能，提高编程效率，C程序的编译处理用于把每一条C语句用若干条机器指令来实现，生成目标程序。由于#define等编译预处理指令不是语句，不能被编译程序翻译，需要在真正编译之前做一个预处理，解释完成编译预处理指令，从而把预处理指令转换成相应的C程序段，最终称为由纯粹C语句构成的程序，经编译后得到目标代码。作用：方便编译器的编译工作，1.宏定义；2.文件包含；3.条件编译。预处理命令以符号“#”开头。 2.2在Ubuntu下预处理的命令 gcc-Ehello.c-ohello.i Hello的预处理结果解析 hello.c程序中只包含三条预处理指令#include<stdio.h>#include<unistd.h>#include<stdlib.h>经过预处理后，Hello.c中的注释删除（见附件hello.i）前面三个消失了，出现了一大段代码（见附件hello.i及截图） 本章小结 描述了预处理的概念和作用，对hello.c进行了预处理，并分析结果。 第3章编译 3.1编译的概念与作用 概念：1、是利用编译程序将一段程序转换为指令集的过程。不同架构的指令集自然是不同的，带来的影响就是同一段代码，编译过后只能运行在对应的指令集上，比如一段C代码，在X86下编译完了，只能在X86下运行，而不能运行在ARM架构下运行。而事实上，编译得到的结果，更是操作系统相关的。假设，一段程序被编译成了X86下的硬程序，但是无法同时运行在Windows上和Linux上（Windows和Linux操作系统都可以装在X86架构的CPU上），如果程序一开始是在Windows操作系统下编译的，那这段程序就无法运行在其他比如Linux操作系统中。也就是说，编译与操作系统和CPU这二者都是相关的。作用：它把高级语言翻译成更接近机器语言的汇编语言 3.2在Ubuntu下编译的命令 gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 1.全局变量：全局变量在data节中定义它，并且解释了它。2.局部变量：局部变量会在栈中储存它，给他分配一个大小符合的字节大小。3.控制符及其跳转：利用jump，set，cmp等指令对程序进行跳转。4.main函数：.text在text节中定义.globlmain声明全局符号global.typemain,@function将main声明为函数随后定义main:标签，后跟main函数伪汇编指令 5.printf(“Usage:Hello学号姓名！\n”);Movl$.LC0,%ediCallputs第一处printf用puts替换，即可以读入缓冲区数据 将.LC0的部分传入参数，执行printf.LC0定义在.rodata节中，是一个字符常量.LC0:.string“Usage:Hello1190201226\345\215\223\345\215\216\357\274\201”6.字符串“Usage:Hello1190201226\345\215\223\345\215\216\357\274\201”对应Usage:Hello1190201226卓华！\n中文被编码为UTF-8格式“Hello%s%s\n”对应第二个printf中的格式化参数7.数组：Hello.c里有一个数组，就是main函数的第二个参数argv[]，argv作为一个指针数组，每个地址是8位，访问数组的地址，就是知道首地址之后，在这个地址基础上加上数据元素的大小，就到了下一位。分别取了argv[1]和argv[2]。9.函数：1.exit函数： 参数传递：传入的参数为0，再执行退出命令函数调用：if判断条件满足后被调用2.sleep函数：参数传递：传入参数sleepsecs，传递控制：callsleep函数调用：for循环下被调用3.getchar函数传递控制：callgetchar函数调用：在main中被调用 3.4本章小结 第4章汇编 4.1汇编的概念与作用 概念：通过汇编器把汇编语言翻译成机器语言的过程作用：通过汇编过程把汇编代码转换成机器代码 4.2在Ubuntu下汇编的命令 ashello.s-shello.o 4.3可重定位目标elf格式分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 在linux下生成hello.o文件elf格式的命令：readelf-ahello.o>hello.elf在未装入内存运行前的elf文件信息：ELF头：文件格式节头表：节头表中各段含义：.text：已经编译程序的机器代码.rodata：只读数据.data：初始化的全局和静态变量.bss：未初始化的全局和静态变量.symtab：符号表，是用来存放程序中定义和引用的全局变量和函数的信息。Name：是符号名，用来可重定位，value：是符号相对于目标节的起始位置偏移，size：是目标的大小，type：是数据还是函数，bind表明是全局还是局部。.rel.text：一个.text节中位置的列表.rel.data：别模块引用或定义的所有全局变量和重定位信息.debug：调试符号表.line：行号与.text的机器指令之间的映射.strtab：一个字符串表重定位节：重定位节表明了链接过程中的重要数据，而其中的符号值则可以区分动态链接和静态链接PC32说明链接内容是静态链接，而PLT32说明链接内容是动态链接内容eh_frame即exceptionhandleframe即异常处理框架就是说,这是与重定位相关的一个异常处理单元符号表：符号表中有hello.o中定义和引用的函数和全局变量，信息，其中包含大小、类型、名字等信息 4.4Hello.o的结果解析 反汇编：hello.shello.txt反汇编后与第三章中hello.s的比较发现：汇编器在汇编hello.s时：1：为每条语句加上了具体的地址，全局变量和常量都被安排到了具体的地址里面。2：操作数在hello.s里面都是十进制，在到hello.o里面的机器级程序时都是十六进制。3：跳转语句jx&jxx原来对应的符号都变成了相对偏移地址。4：函数调用时原来的函数名字也被替换成了函数的相对偏移地址。说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致、分支转移函数调用等。 4.5本章小结 介绍了汇编的概念与作用，分析了ELF格式文件，节头目表，符号表以及可重定位节。 第5章链接 第5章链接 5.1链接的概念与作用 概念：链接是将各种代码和数据片段收集并组合成一个可被加载到内存并执行的文件的过程。作用：将各种代码和数据片段收集并组合成一个文件 5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib/ld-linker.so.2/usr/lib/crt1.o/usr/lib/crti.o-lhello.o/usr/lib/ctrn.o 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。Elf头：节头表： 如图：共29个表项，地址和偏移量标注了起始地址，大小则标注了各段的大小 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。Hello的虚拟地址空间的起始为0x400000，结束与0x400ff0；而。Text节的起始地址为：0x400550，大小为0x132 5.5链接的重定位过程分析 hello中包含一些外部文件的宏定义、变量、库函数和操作系统的启动代码等，且.o文件.text节从0开始，而可执行文件.text节并非从0开始。过程：分为符号解析和重定位两步1.符号解析：目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。链接器将每个符号引用与一个确定的符号定义关联起来如图：节头与符号表中即可知道符号定义与引用，详见附件。2.hello重定位的过程：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。如图：左边跳转信息在重定位表中（见附件hello.elf）而右边则准确标注了跳转的地址。(1)重定位节和符号定义链接器将所有类型相同的节合并在一起后，这个节就作为可执行目标文件的节。然后链接器把运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号，当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。(2)重定位节中的符号引用这一步中，连接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。执行这一步，链接器依赖于可重定位目标模块中称为的重定位条目的数据结构。(3)重定位条目当编译器遇到对最终位置未知的目标引用时，它就会生成一个重定位条目。 5.6hello的执行流程 子程序名程序地址（16进制）ld-2.27.so_dl_start7efbff4d8ea0ld-2.27.so_dl_init7efbff4e7630hello_start400500libc-2.27.so__libc_start_main7efbff100ab0Hello_printf@plt（调用了10次）4004c0Hello_sleep@plt（调用了10次）4004f0hello!getchar@plt4004d0libc-2.27.so!exit7efbff122120 5.7Hello的动态链接分析 基本思想是：程序按照模块拆分成各个相对独立部分，在程序运行时将它们链接在一起形成一个完整的程序，不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时，还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。 5.8本章小结 介绍链接的概念与作用，对hello.o进行链接得到hello文件，并对结果进行分析 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程是计算机程序需要进行对数据集合进行操作所运行的一次活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程的作用：进程为用户提供了以下假象：我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 shell俗称壳，它是指UNIX系统下的一个命令解析器；主要用于用户和系统的交互。UNIX系统上有很多种Shell。首个shell，即BourneShell，于1978年在V7(AT&T的第7版)UNIX上推出。后来，又演变出Cshell、bash等不同版本的shell。Shell处理流程：1.打印提示信息2.等待用户输入3.接受命令4.解释命令5.找到该命令，执行命令，如果命令含有参数，输入的命令解释它6.执行完成，返回第一步 6.3Hello的fork进程创建过程 调用fork函数先创造出一个子进程，然后形成自身的一个子进程 6.4Hello的execve过程 在shell的子进程中执行execve函数，将参数传给Hello程序，并执行Hello 6.5Hello的进程执行 一开始，Hello运行在用户模式，当程序收到一个信号时，进入内核模式，运行信号处理程序，之后再返回用户模式。在Hello运行的过程中，cpu不断切换上下文，使Hello程序运行过程被切分成时间片，与其他进程交替占用cpu，实现进程的调度。结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 6.6hello的异常与信号处理 故障：缺页异常，hello进程的页表被映射到hello文件，然而实际代码拷贝至内存仍未完成，在执行到相应地址的代码时会引发缺页异常。终止：不可恢复错误发生。中断：接受到键盘键入的信号，如ctrlZ,ctrlC等hello执行中处理的信号:SIGINT,SIGSTP,SIGCONT,SIGWINCH信号处理：Crtlc：退出程序Ctrlz：挂起使用ps查看进程号：PID：3048以及3056即为挂起的hello程序Fg:前台运行 kill进程：使用pstree查看： 6.7本章小结 介绍了进程的概念与作用，分析了hello的执行过程（第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址。逻辑地址：程序代码经过编译后出现在汇编程序中地址。逻辑地址由选择符（在实模式下是描述符，在保护模式下是用来选择描述符的选择符）和偏移量（偏移部分）组成。线性地址(linearaddress)或也叫虚拟地址(virtualaddress)跟逻辑地址类似，它也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件页式内存的转换前地址。 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 7.2Intel逻辑地址到线性地址的变换-段式管理 8086共设计了20位宽的地址总线，通过将段寄存器左移4位加上偏移地址得到20位地址，这个地址就是逻辑地址。将内存分为不同的段，段有段寄存器对应（段寄存器主要是由mmu管理），段寄存器有一个栈、一个代码、两个数据寄存器。在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值(index)。 7.3Hello的线性地址到物理地址的变换-页式管理 首先先将线性地址分为VPN+VPO的形式，然后再将VPN拆分成TLBT+TLBI，然后去TLB缓存里找所对应的PPN，如果发生缺页情况则直接查找对应的PPN，找到PPN之后，将其与VPO组合变为PPN+VPO就是生成的物理地址了。 7.4TLB与四级页表支持下的VA到PA的变换 将VPN分成三段，对于TLBT和TLBI来说，可以在TLB中找到对应的PPN，但是有可能出现缺页的情况，需要到页表中去找。VPN被分成了更多段（这里是4段）CR3是对应的L1PT的物理地址，然后一步步递进往下寻址，越往下一层每个条目对应的区域越小，寻址越细致，在经过4层寻址之后找到相应的PPN让你和和VPO拼接起来。 7.5三级Cache支持下的物理内存访问 先将虚拟地址转换为物理地址，再对物理地址进行分析，物理地址由CT、CI、CO组成，然后在一级cache内部找，用CI位进行索引，如果匹配成功且valid值为1，则称为命中，根据偏移量在L1cache中取数，如果不命中，在分别到L2、L3和主存中重复上述过程 7.6hello进程fork时的内存映射 执行新进程（hello）时，为这个新进程创建虚拟内存 创建当前进程的的mm_struct,vm_area_struct和页表的原样副本两个进程的每个页面都标记为只读页面两个进程中的每个区域结构（vm_area_struct）都标记为私有。当需要写时，则需要再创建一个段，将需要写入的东西写入到该段中去。 7.7hello进程execve时的内存映射 删除已存在的用户区域；创建新私有区域结构；创建新共享区域；设置PC，指向代码的入口点 7.8缺页故障与缺页中断处理 （1）段错误：首先判断这个缺页的虚拟地址是否合法，遍历所有的合法区域结构，如果这个虚拟地址对所有的区域结构都无法匹配，就返回一个段错误。（2）非法访问：查看地址的权限，判断一下进程是否有读写改这个地址的权限。（3）如果不是上面两种情况那就是正常缺页，就选择一个页面换入新的页面并更新到页表。 7.9动态存储分配管理 基本方法：维护一个虚拟内存区域“堆”，将堆视为一组不同大小的块的集合来维护，每个块要么是已分配的，要么是空闲的，需要时选择一个合适的内存块进行分配。1记录空闲块，可以选择隐式空闲链表，显示空闲链表，分离的空闲链表和按块大小排序建立平衡树2放置策略，可以选择首次适配，下一次适配，最佳适配3合并策略，可以选择立即合并，延迟合并4需要考虑分割空闲块的时机，对内部碎片的忍耐阈值. 7.10本章小结 描述了存储的概念，进程fork和execve内存映射的内容，以及缺页问题和动态存储分配问题。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：将设备抽象成文件设备管理：通过unixio接口管理 8.2简述UnixIO接口及其函数 打开和关闭文件:open()andclose()读写文件:read()andwrite()改变当前的文件位置lseek() 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall等.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 （以下格式自行编排，编辑时删除）异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 了解了hello的IO管理。结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。先用C语言编写hello.c,作为源代码。预处理hello.c，将hello.c调用的所有外部的库合并到一个hello.i文件中。然后进行编译，成为汇编文件hello.s；汇编hello.s,会变成为可重定位目标文件hello.o；链接，将hello.o与可重定位目标文件和动态链接库链接成为可执行目标程序hello；shell中运行hello；Shell调用fork创建子进程；运行程序：shell调用execve，execve调用启动加载器，加映射虚拟内存，进入程序入口后程序开始载入物理内存，然后进入main函数；CPU分配时间片，hello在一个时间片中顺序执行；访问内存，MMU将程序中使用的虚拟内存地址通过页表映射成物理地址；.动态申请内存：printf会调用malloc向动态内存分配器申请堆中的内存；如果运行途中键入中断，则调用shell的信号处理函数分别停止、挂起；shell父进程回收子进程，内核删除为这个进程创建的所有数据结构。如果父程序不能回收该子程序，则由中断直接收回。 附件 hello.c用C语言编写的hello程序源代码hello.i经预处理处理得到的文本文件hello.s编译后得到的汇编代码hello.o汇编操作得到的可重定位目标执行文件hello可执行程序 参考文献 为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 

HITCSAPP程序人生大作业 

HITCSAPP2021大作业程序人生Hello‘sP2P 题 目 程序人生-Hello’sP2P 专 业 计算机学院 学 号 ******** 班 级 ********* 学 生 ******* 摘 要 本文主要参照《深入理解计算机系统》一书，结合CSAPP课程内容来介绍hello程序的一生，并对该过程中的知识点进行梳理，所有操作均在Ubuntu虚拟机完成，运用了多种调试工具，有助于加深对计算机系统的理解。 关键词：Ubuntu；CSAPP；深入理解计算机系统；程序生命周期 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.2.1硬件环境 -4- 1.2.2软件环境 -4- 1.2.3开发工具 -4- 1.3中间结果 -4- 1.4本章小结 -5- 第2章预处理 -6- 2.1预处理的概念与作用 -6- 2.2在Ubuntu下预处理的命令 -6- 2.3Hello的预处理结果解析 -7- 2.4本章小结 -9- 第3章编译 -10- 3.1编译的概念与作用 -10- 3.2在Ubuntu下编译的命令 -10- 3.3Hello的编译结果解析 -11- 3.3.1部分汇编伪指令 -11- 3.3.2数据 -11- 3.3.3赋值 -12- 3.3.4类型转换 -13- 3.3.5算数操作 -13- 3.3.6关系操作 -14- 3.3.7数组、指针、结构操作 -14- 3.3.8控制转移操作 -14- 3.3.9函数操作 -15- 3.4本章小结 -15- 第4章汇编 -16- 4.1汇编的概念与作用 -16- 4.2在Ubuntu下汇编的命令 -16- 4.3可重定位目标elf格式 -17- 4.4Hello.o的结果解析 -19- 4.5本章小结 -20- 第5章链接 -21- 5.1链接的概念与作用 -21- 5.2在Ubuntu下链接的命令 -21- 5.3可执行目标文件hello的格式 -22- 5.4hello的虚拟地址空间 -22- 5.5链接的重定位过程分析 -23- 5.6hello的执行流程 -24- 5.7Hello的动态链接分析 -25- 5.8本章小结 -25- 第6章hello进程管理 -26- 6.1进程的概念与作用 -26- 6.2简述壳Shell-bash的作用与处理流程 -26- 6.3Hello的fork进程创建过程 -26- 6.4Hello的execve过程 -27- 6.5Hello的进程执行 -27- 6.6hello的异常与信号处理 -28- 6.7本章小结 -31- 第7章hello的存储管理 -32- 7.1hello的存储器地址空间 -32- 7.2Intel逻辑地址到线性地址的变换-段式管理 -32- 7.3Hello的线性地址到物理地址的变换-页式管理 -33- 7.4TLB与四级页表支持下的VA到PA的变换 -34- 7.5三级Cache支持下的物理内存访问 -35- 7.6hello进程fork时的内存映射 -35- 7.7hello进程execve时的内存映射 -35- 7.8缺页故障与缺页中断处理 -36- 7.9动态存储分配管理 -36- 7.10本章小结 -38- 第8章hello的IO管理 -39- 8.1Linux的IO设备管理方法 -39- 8.2简述UnixIO接口及其函数 -39- 8.3printf的实现分析 -39- 8.4getchar的实现分析 -40- 8.5本章小结 -41- 结论 -41- 附件 -42- 参考文献 -43- 第1章概述 1.1Hello简介 P2P简介 P2P，英文是Fromprogramtoprocess。用户首先通过各种文本编辑器编写代码，得到hello.c文件，然后在Ubuntu下，调用C预处理器得到ASCII码的中间文件hello.i，然后调用C编译器得到ASCII汇编语言文件hello.s，然后运行汇编器得到可重定位目标文件hello.o，最后通过链接器得到可执行目标文件hello，用户可以在终端输入./hello来启动程序。 O2O简介 O2O，英文是FromZero-0toZero-0。用户输入命令后，shell根据命令调用fork函数生成子进程，子进程中execve函数运行hello，这要为hello各段创建新的空间。首次加载会产生缺页，调用缺页中断处理子程序，多次调用后hello就加载到内存中。在运行过程中会收到外部的信号（比如用户输入），因此还要相对的信号处理程序。hello执行完毕，hello结束，等待被父进程回收。 1.2环境与工具 1.2.1硬件环境 X64CPU；2.10GHz；16GRAM；512GSSDDisk 1.2.2软件环境 Windows1064位；VirtualBox6.0；Ubuntu20.04LTS64位 1.2.3开发工具 Gcc、vim、gdb、edb、readelf、HexEdit等 1.3中间结果 中间结果文件 文件作用 hello.i 预处理生成的文本文件hello.i hello.s 编译产生的文本文件hello.s hello.o 汇编后生成的可重定位目标文件hello.o helloo.elf hello.o的elf文件 helloo.objdump objdumphello.o生成的hello.o的反汇编代码文件 hello 链接生成的可执行文件hello hello.elf hello的elf文件 hello.objdump objdumphello生成的hello的反汇编代码文件 1.4本章小结 本章简要介绍了hello.c的P2P和O2O，然后介绍了hello从开始到结束的过程及中间生成的一些文件。可以大致知道其过程：hello.c经过预处理生成hello.i，然后经过编译生成hello.s，再汇编生成hello.o，再链接生成hello这个可执行文件。接着hello运行O2O的过程，最后被父进程回收，结束hello。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 预处理的概念： 预处理器（即cpp）根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将原始C程序引用的所有库展开，处理所有原始C程序的条件编译，并执行原始C程序所有的宏定义，得到另一个通常是以.i作为文件扩展名的、文件名与原始C程序相同的文本文件。 预处理的作用： 将源文件中用#include形式声明的文件复制到新的程序中。比如hello.c第6-8行中的#include<stdio.h>等命令告诉预处理器读取系统头文件stdio.hunistd.hstdlib.h的内容，并把它直接插入到程序文本中。用实际值替换用#define定义的字符串根据#if后面的条件决定需要编译的代码 2.2在Ubuntu下预处理的命令 预处理的命令：cpphello.c>hello.i(或gcc-Ehello.c-ohello.i) 图1使用cpp命令 图2使用gcc命令 （经过简单比对，两文件都有3065行，故认为两文件相同，为简单起见，后文只使用cpp命令得到的文件进行实验） 2.3Hello的预处理结果解析 使用文本编辑器打开hello.i，发现此时程序由之前的28行扩展为3065行，我们使用ctrl+f查找main函数所在位置。 图3main函数所在位置 可以看到main函数于3049行出现，hello.c文件原始代码于3046行出现。 经过预处理器处理后，hello.c文件转化为hello.i文件，打开文件后发现文件的内容大大增加，但该文件还是可以使用文本编辑器正常打开阅读的文本文件，进行粗略观察，发现hello.i对原文件中的宏进行了宏展开，将头文件中的内容包含进了该文件，比如一些标准库中的函数、结构体的定义、变量的定义等。 如果代码中有#define命令，预处理器还会对相应的符号进行替换。 我们在文本编辑器中使用ctrl+f查找头文件stdio.h， 图4查找stdio.h 去该路径找到该文件，可以看到该文件中还是有很多#开头的宏定义内容 图5<stdio.h>的内容 这是由于cpp对引入头文件是进行递归展开，所以最终.i程序中是没有#define语句的。我们还发现其中使用了大量的#ifdef#ifndef的语句，cpp会对条件值进行判断来决定是否执行包含其中的逻辑。其他宏定义是类似的。 2.4本章小结 Hello.c程序要想真正的运行起来，需要很多的前置准备。 本章主要介绍了预处理的概念及作用，并结合hello.c处理后的hello.i对处理过程进行分析。根据hello.i文件的内容对cpp预处理的机制进行了简单的探索。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的概念： 编译即编译器将文本文件hello.i翻译成另一个文本文件hello.s的过程。 编译的作用： 其作用在于以高级程序设计语言书写的源程序作为输入，而以汇编语言或机器语言表示的目标程序作为输出。 编译器的构建流程主要分为3个步骤： 词法分析器，用于将字符串转化成内部的表示结构。语法分析器，将词法分析得到的标记流（token）生成一棵语法树。目标代码的生成，将语法树转化成目标代码。 3.2在Ubuntu下编译的命令 编译的命令：gcc-Shello.i-ohello.s 图6使用gcc-S命令进行编译 3.3Hello的编译结果解析 3.3.1部分汇编伪指令 指令含义.file声明源文件.text以下是代码段.section.rodata以下是rodata节.globl声明一个全局变量.type用来指定是函数类型或是对象类型.size声明大小.long、.string声明一个long、string类型.align声明对指令或者数据的存放地址进行对齐的方式 3.3.2数据 hello.s中用到的C数据类型有：字符串、整数、数组。 Ⅰ字符串 在hello.c程序中使用到的字符串有： “Usage:Hello学号姓名！\n” “Hello%s%s\n” 编译器一般会将printf打印输出的格式串放在.rodata节，在hello.s中，这两个字符串存储格式如下：其中可以看到汉字被编码为UTF-8格式，一个汉字占三个字节，每个字节以\开始。 图7字符串在hello.s中的存储格式 Ⅱ整数 在hello.c中使用到的整形变量有sleepsecs、argc和i。 sleepsecs在C程序中被声明为全局变量，且已经被赋值，编译器处理时将会在.data节声明该变量，.data节存放已经初始化的全局和静态C变量。 在图8sleepsecs在hello.s中可以看到，编译器首先将sleepsecs在.text代码段中声明为全局变量，其次在.data段中，设置对齐方式为4、设置类型为对象、设置大小为4字节、设置为long类型其值为2（进行了隐式转换）（long类型在linux下与int相同为4字节，将int声明为long应该是编译器的偏好选择）。 图8sleepsecs在hello.s中 argc是从终端传入的参数个数，也是main函数的第一个参数，故由寄存器%edi进行保存。 i是局部变量，编译器将局部变量存储在寄存器或者栈空间中，在hello.s中编译器将i存储在栈上空间-4(%rbp)中，可以看出i占据了栈中的4字节。 Ⅲ数组 在hello.c程序中使用到的数组有：char*argv[]main 该数组存储函数执行时输入的命令行，argv作为存放char指针的数组，也同时作为第二个参数传入。 图9数组argv[]的使用 argv单个元素char*大小为8B，argv指针指向已经分配好的、一片存放着字符指针的连续空间，起始地址为argv，main函数中每次先获得数组的起始地址，然后通过加8*i来访问之后的字符指针，之后通过获得的字符指针寻找字符串在hello.s中，使用两次(%rax)寻址取值（两次rax分别为argv[1]和argv[2]的地址）取出其值。 3.3.3赋值 在hello.c程序中涉及的赋值操作有： intsleepsecs=2.5：因为sleepsecs是全局变量，所以直接在.data节中将sleepsecs声明为值2的long类型数据。i=0：整型数据的赋值使用mov指令完成，根据数据的大小不同使用不同后缀，分别为：一字节：b，一字：w，双字：l，四字：q。 i为4B双字的int类型，故使用movl进行赋值： 图10对局部变量i进行0赋值 3.3.4类型转换 在hello.c程序中涉及隐式类型转换的是： intsleepsecs=2.5，本条语句将浮点数类型的2.5转换为int类型。 当在double或float向int进行类型转换的时候，程序改变数值和位模式的原则是：值会向零舍入。例如1.999将被转换成1，-1.999将被转换成-1。进一步来讲，可能会产生值溢出的情况，一个浮点数到整数的转换，如果不能为该浮点数找到一个合适的整数近似值，就会产生一个整数不确定值。 浮点数默认类型为double，所以上述强制转化是double强制转化为int类型。遵从向零舍入的原则，将2.5舍入为2。 3.3.5算数操作 汇编语言中有如下几种算术操作： 指令行为描述incDD=D+1加1decDD=D-1减1negDD=-D取反addS,GD=D+SD加SsubS,DD=D-SD减SimulS,DD=D*SD乘SimulqSR[%rdx]:R[%rax]=S*R[%rax]有符号乘法mulqSR[%rdx]:R[%rax]=S*R[%rax]无符号乘法idivqSR[%rdx]=R[%rdx]:R[%rax]modSR[%rax]=R[%rdx]:R[%rax]divS有符号除法divqSR[%rdx]=R[%rdx]:R[%rax]modSR[%rax]=R[%rdx]:R[%rax]divS无符号触发leaqS,DD=&S加载有效地址 在hello.c程序中涉及算数操作的是：循环变量i的自增，如下： 图11循环变量i的自增 3.3.6关系操作 指令效果描述CMPS1,S2S2-S1比较S2-S1设置条件码TESTS1,S2S1&S2测试S1&S2设置条件码SETXX DD=XX按照XX将条件码设置DJXX 根据XX与条件码进行跳转 C语言中的关系操作有==、!=、>、<、>=、<=，这些操作在汇编语言中主要依赖于cmp和test指令实现，cmp指令根据两个操作数之差来设置条件码。cmp指令与SUB指令的行为是一样，而test指令的行为与and指令一样，除了它们只设置条件码而不改变目的寄存器的值。 在hello.c中有两处用到了关系操作，在cmp之后设置条件码，为之后的je和jle提供判断依据。 3.3.7数组、指针、结构操作 hello.s中取argv首地址，通过首地址加8字节找到argv[1]的地址，然后通过argv[1]中的内容找到对应的字符串，保存在寄存器%rax中，对argv数组其他元素所指的字符串也同理。 3.3.8控制转移操作 Hello.c程序涉及到的控制转移有两处。 第一处是判断argc是否与3相等，在hello.s中如图所示，cmpl比较argc和3设置条件码之后，通过判断条件码ZF位是否为零决定是否跳转到.L2，如果为0，说明argc等于3，代码跳转到.L2继续执行，如果不为0，则顺序执行指令。另一处基本同理。 图12控制转移 3.3.9函数操作 函数是一种过程，过程提供了一种封装代码的方式，用一组指定的参数和可选的返回值实现某种功能。P中调用函数Q包含以下动作： 传递控制：进行过程Q的时候，程序计数器必须设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。 传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P中返回一个值。 分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。 函数的程序参数存储顺序如下表： 第一个第二个第三个第四个第五个第六个第七个及之后%rdi%rsi%rdx%rcx%r8%r9栈中 函数调用使用call指令即可。 3.4本章小结 本章主要阐述了编译器是如何处理C语言的各个数据类型以及各类操作的，基本都是先给出原理然后结合hello.cC程序到hello.s汇编代码之间的映射关系作出合理解释。 编译器将.i的拓展程序编译为.s的汇编代码。经过编译之后，我们的hello自C语言解构为更加低级的汇编语言。通过理解了这些编译器编译的机制，我们可以很容易的将汇编语言翻译成伪C语言。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编器（as）将.s汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码。这个过程称为汇编，亦即汇编的作用。 4.2在Ubuntu下汇编的命令 汇编的命令：ashello.s-ohello.o（gcc-chello.s-ohello.o） 图13汇编的命令 图14使用gcc进行汇编 4.3可重定位目标elf格式 使用readelf-ahello.o>helloo.elf指令获得hello.o文件的ELF格式。其组成如下： ELFHeader：以16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量等信息。 图15ELF头信息 节头部表 节头部表包含了文件中出现的各个节的含义，包括节的地址、偏移量、大小等信息。 图16节头部表 .rela.text节 一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。 图17.rela.text节 .rela节的包含的信息有（readelf显示与hello.o中的编码不同，以hello.o为准）： Offset需要进行重定向的代码在.text或.data节中的偏移位置，8个字节。Info包括symbol和type两部分，其中symbol占前4个字节，type占后4个字节，symbol代表重定位到的目标在.symtab中的偏移量，type代表重定位的类型。Addend有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。Type重定位到的目标的类型。Name重定向到的目标的名称。 .rela.eh_frame节 .eh_frame节的重定位信息。 .symtab节 符号表，用来存放程序中的定义和引用函数的全局变量的信息。重定位需要引用的符号都在其中声明。name是字符串表中的字节偏移，指向符号的以null结尾的字符串名字，value是符号的地址，对于可重定位的模块来说，value是距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时地址，size是目标的大小，type通常要么是数据，要么是函数，binding表示符号是本地的还是全局的。ABS代表不该被重定位的符号，UNDEF代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号，COMMON表示还未被分配位置的未初始化的数据目标。 图18.symtab节 4.4Hello.o的结果解析 使用objdump-d-rhello.o>helloo.objdump获得反汇编代码。 机器语言是计算机能直接理解的语言，完全由二进制数构成，为了阅读的方便显示成了16进制。每两个16进制数构成一个字节编码，是机器语言中能解释一个运算符或操作数的最小单位。 机器语言由三种数据构成。一是操作码，它具体说明了操作的性质和功能，每一条指令都有一个相应的操作码，计算机通过识别该操作码来完成不同的操作；二是操作数的地址，CPU通过地址取得所需的操作数；三是操作结果的存储地址，把对操作数的处理所产生的结果保存在该地址中，以便再次使用。 总体观察后发现，除去显示格式之外两者差别不大，主要差别如下： 分支转移：反汇编代码跳转指令的操作数使用的不是段名称如.L3，因为段名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后显然不存在，而是确定的地址。 函数调用：在.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0（目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。 全局变量访问：在.s文件中，访问rodata（printf中的字符串），使用段名称+%rip，在反汇编代码中0+%rip，因为rodata中数据地址也是在运行时确定，故访问也需要重定位。所以在汇编成为机器语言时，将操作数设置为全0并添加重定位条目。 4.5本章小结 本章主要介绍了从hello.s到hello.o的汇编过程，通过查看hello.o的elf格式和使用objdump得到反汇编代码与hello.s进行比较，间接了解到从汇编语言映射到机器语言汇编器需要实现的转换。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。在现代系统中，链接是由较做链接器的程序自动执行的。 链接的作用：链接器使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。 5.2在Ubuntu下链接的命令 链接的命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图19链接的过程 5.3可执行目标文件hello的格式 使用使用readelf-ahello>hello.elf命令生成hello程序的ELF格式文件。查看hello的elf格式，节头表记录了各个节的信息，Address是程序被载入到虚拟地址的起始地址，off是在程序中的偏移量，size是节的大小。 图20hello文件的节头 5.4hello的虚拟地址空间 用edb查看程序hello，发现程序在地址0x400000~0x401000中被载入，从0x400000开始到0x400fff结束，在0x400fff之后存放的是.dynamic~.shstrtab节。在DataDump中查看地址0x400000开始的内容，可以看到开头是ELF头部分。 图21ELF头部分 查看地址0x0x4002e0，发现是.interp节，保存着linux动态共享库的路径。 图22linux动态共享库 查看地址0x0x402000，发现是.rodata节，其中保存着hello.c中的两个字符串。 图23.rodata节 其他节也可以通过节头部表用DataDump找到，这里不再赘述。 5.5链接的重定位过程分析 使用objdump-d-rhello>hello.objdump获得hello的反汇编代码。 图24两份反汇编代码 通过比较hello.objdump和helloo.objdump了解链接器。 函数个数：在使用ld命令链接的时候，指定了动态链接器为64的/lib64/ld-linux-x86-64.so.2，crt1.o、crti.o、crtn.o中主要定义了程序入口_start、初始化函数_init，_start程序调用hello.c中的main函数，libc.so是动态链接共享库，其中定义了hello.c中用到的printf、sleep、getchar、exit函数和_start中调用的__libc_csu_init，__libc_csu_fini，__libc_start_main。链接器将上述函数加入。 函数调用：链接器解析重定条目时发现对外部函数调用的类型为R_X86_64_PLT32的重定位，此时动态链接库中的函数已经加入到了PLT中，.text与.plt节相对距离已经确定，链接器计算相对距离，将对动态链接库中函数的调用值改为PLT中相应函数与下条指令的相对地址，指向对应函数。对于此类重定位链接器为其构造.plt与.got.plt。 .rodata引用：链接器解析重定条目时发现两个类型为R_X86_64_PC32的对.rodata的重定位（printf中的两个字符串），.rodata与.text节之间的相对距离确定，因此链接器直接修改call之后的值为目标地址与下一条指令的地址之差，指向相应的字符串。这里以计算第一条字符串相对地址为例说明计算相对地址的算法： refptr=s+r.offset=Pointerto0x4010dd refaddr=ADDR(s)+r.offset=ADDR(main)+r.offset=0x4010c1+0x1c=0x4010dd *refptr=(unsigned)(ADDR(r.symbol)+r.addend-refaddr) =ADDR(str1)+r.addend-refaddr =0x402008-0x4010dd=(unsigned)0xf2b 5.6hello的执行流程 使用edb执行hello 子程序名： ld-2.27.so!_dl_start ld-2.27.so!_dl_init hello!_start libc-2.27.so!__libc_start_main libc-2.27.so!__cxa_atexit libc-2.27.so!__libc_csu_init libc-2.27.so!_setjmp hello!main hello!puts@plt hello!exit@plt hello!printf@plt hello!sleep@plt hello!getchar@plt ld-2.27.so!_dl_runtime_resolve_xsave ld-2.27.so!_dl_fixup ld-2.27.so!_dl_lookup_symbol_x libc-2.27.so!exit 5.7Hello的动态链接分析 在进行动态链接前，首先进行静态链接，生成部分链接的可执行目标文件hello。此时共享库中的代码和数据没有被合并到hello中。加载hello时，动态链接器对共享目标文件中的相应模块内的代码和数据进行重定位，加载共享库，生成完全链接的可执行目标文件。 动态链接采用了延迟加载的策略，即在调用函数时才进行符号的映射。使用偏移量表GOT+过程链接表PLT实现函数的动态链接。GOT中存放函数目标地址，为每个全局函数创建一个副本函数，并将对函数的调用转换成对副本函数调用。 从图中可以看到.got.plt的条目发生变化。在之后的函数调用时，首先跳转到PLT执行.plt中逻辑，第一次访问跳转时，GOT地址为下一条指令，将函数序号压栈，然后跳转到PLT[0]，在PLT[0]中将重定位表地址压栈，然后访问动态链接器，在动态链接器中使用函数序号和重定位表确定函数运行时地址，重写GOT，再将控制传递给目标函数。之后如果对同样函数调用，第一次访问跳转直接跳转到目标函数。 5.8本章小结 在本章中介绍了链接的方法，分析了可执行文件hello的elf格式，同时反汇编hello文件，将其与hello.o的反汇编文件进行对比，最后对hello进行动态链接分析。涉及了重定位和符号解析的知识，加强了对重定位和链接的理解。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的概念 进程就是一个执行中的程序的示例，系统中的每个程序都运行在某个进程的上下文中，上下文是由程序正确运行所需的状态（包括存放在内存中的程序的代码和数据、栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符等）组成的。 进程的作用 进程提供给应用程序关键的抽象：一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器；一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 Shell的作用：Shell是一个用C语言编写的程序，他是用户使用Linux的桥梁。Shell是用户与操作系统之间完成交互式操作的一个接口程序，为用户提供简化了的操作，进一步开发出BorneAgainShell，简称bash，是Linux系统中默认的shell程序。提供了一个界面，用户通过这个界面访问操作系统内核的服务。 处理流程： 1）从终端读入输入的命令。 2）将输入字符串切分获得所有的参数 3）如果是内置命令则立即执行 4）否则调用相应的程序为其分配子进程并运行 5）shell应该接受键盘输入信号，并对这些信号进行相应处理 6.3Hello的fork进程创建过程 执行中的进程调用fork()函数，就创建了一个子进程。 函数原型：pid_tfork(void); 返回值：若成功调用则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1。 对于hello进程，终端的输入被判定为非内置命令，shell试图在硬盘上查找该命令（即hello可执行程序），并将其调入内存，然后shell将其解释为系统功能调用并转交给内核执行。shell执行fork函数，创建一个子进程，这时候程序开始运行。hello子进程是父进程的副本，将获得父进程数据空间、堆、栈等资源的副本。同时linux将复制子进程的地址空间给子进程，因此，hello进程就有了独立的地址空间。 6.4Hello的execve过程 函数原型intexecve(constchar*filename,constchar*argv[],constchar*envp[]); 如果成功，则不返回；如果错误，则返回-1。 在execve加载hello之后，它调用启动代码。启动代码设置栈，并将控制传递给hello主函数（main函数）。 main函数原型：intmain(intargc,char*argv[],char*envp[])。 过程如下：hello子进程通过execve系统调用启动加载器；加载器删除子进程所有的虚拟地址段，并创建一组新的代码、数据、堆段。新的栈和堆段被初始化为0；通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容；最后加载器跳到_start地址，最终调用hello的main函数。 除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制，直到CPU引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 6.5Hello的进程执行 进程时间片：一个进程执行他的控制流的一部分的每一个时间段叫做时间片，多任务也叫时间分片。 进程上下文切换：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程，这种决策叫做调度。在内核调度一个新的进程运行时，它抢占当前进程，并使用一种上下文切换的机制来控制转移到新的进程。 过程：1.保存当前进程的上下文。2.恢复某个先前被强占的进程被保存的上下文。3.将控制传递给这个新恢复的进程。 hello在刚开始运行时内核为其保存一个上下文，进程在用户模式下运行，当没有异常或中断信号的产生，hello将一直正常地执行，而当出现异常或系统中断时，内核将启用调度器休眠当前进程，并在内核模式中完成上下文切换，将控制传递给其他进程。 6.6hello的异常与信号处理 hello的异常： 1）中断：来自处理器外部的I/O设备的信号的结果（例如：在键盘上敲击Ctrl-C或者Ctrl-Z） 2）陷阱：有益的，执行指令的结果（例如：系统调用） 产生的信号： SIGINT,SIGSTP,SIGCONT,SIGWINCH 下面我们对hello执行过程中的几种可能异常进行分析： 首先尝试运行过程中敲击回车，除了换行外没有其他情况： 图25敲击回车 之后在ctrl-z后测试psjobspstreefgkill命令： 图26使用ctrl+z挂起进程 使用ps命令查看，发现hello进程在后台正常存在 图27ps命令查看进程 使用jobs命令，可以看到已停止的hello进程 图28jobs命令查看进程 Pstree查看： 图29pstree命令 Fg命令恢复 图30fg命令恢复进程 Kill命令杀死进程： 图31kill命令杀死进程 测试ctrl+c： 图32程序ctrl+c被终止 测试任意字符：不影响运行。 图33进行任意字符输入 信号处理： 1）Ctrl-CCtrl-Z：键盘输入后，内核发送SIGINT（默认终止前台job即程序hello）或者SIGSTP（默认挂起前台hello作业）。 2）fg信号：内核发送SIGCONT信号，让刚刚挂起的程序hello重新在前台运行。 3）kill-923166：内核发送SIGKILL信号给我们指定的pid，这样就杀死了hello程序。 6.7本章小结 本章主要介绍了进程的概念与作用，同时介绍了Shell的一般处理流程和作用，并且着重分析了调用fork创建新进程，调用execve函数执行hello，hello的进程执行，以及hello的异常与信号处理。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：在有地址变换功能的计算机中，访内指令给出的地址(操作数)叫逻辑地址，也叫相对地址。分为两个部分，一个部分为段基址，另一个部分为段偏移量。 线性地址：逻辑地址经过段机制后转化为线性地址，为描述符:偏移量的组合形式。分页机制中线性地址作为输入。 虚拟地址：CPU启动保护模式后，程序运行在虚拟地址空间中。与物理地址相似，虚拟内存被组织为一个存放在磁盘上的N个连续的字节大小的单元组成的数组，其每个字节对应的地址成为虚拟地址。虚拟地址包括VPO（虚拟页面偏移量）、VPN（虚拟页号）、TLBI（TLB索引）、TLBT（TLB标记）。 物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 实模式下：逻辑地址CS：EA=->物理地址CS*16+EA 保护模式下：以段描述符作为下标，到GDT/LDT表查表获得段地址，段地址+偏移地址=线性地址。 段选择符各字段含义，如图 TI=0，选择全局描述符表（GDT），TI=1，选择局部描述符表（LDT） RPL=00，为第0级，位于最高级的内核态，RPL=11，为第3级，位于最低级的用户态，第0级高于第3级 高13-8K个索引用来确定当前使用的段描述符在描述符表中的位置，如下图： 被选中的段描述符先被送至描述符cache，每次从描述符cache中取32位段基址，与32位段内偏移量（有效地址）相加得到线性地址，如下图： 7.3Hello的线性地址到物理地址的变换-页式管理 1.基本原理 将程序的逻辑地址空间划分为固定大小的页，而物理内存划分为同样大小的页框。程序加载时，可将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是VPN（虚拟页号），后一部分是VPO（虚拟页偏移量）。 页式管理方式的优点：没有外碎片；一个程序不必连续存放；便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。 页式管理方式的缺点：要求程序全部装入内存，没有足够的内存，程序就不能执行。 2.页式管理的数据结构 在页式系统中进程建立时，操作系统为进程中所有的页分配页框。当进程撤销时收回所有分配给它的页框。在程序的运行期间，如果允许进程动态地申请空间，操作系统还要为进程申请的空间分配物理页框。操作系统为了完成这些功能，必须记录系统内存中实际的页框使用情况。操作系统还要在进程切换时，正确地切换两个不同的进程地址空间到物理内存空间的映射。这就要求操作系统要记录每个进程页表的相关信息。为了完成上述的功能， 个页式系统中，一般要采用如下的数据结构。 页表：页表将虚拟内存映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。页表是一个页表条目（PTE）的数组。虚拟地址空间的每个页在页表中一个固定偏移量处都有一个PTE。假设每个PTE是由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。 3.页式管理地址变换 MMU利用VPN来选择适当的PTE，将列表条目中PPN和虚拟地址中的VPO串联起来，就得到相应的物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 为了消除每次CPU产生一个虚拟地址MMU就查阅一个PTE带来的时间开销，许多系统都在MMU中包括了一个关于PTE的小的缓存，称为翻译后被缓冲器（TLB），TLB的速度快于L1cache。 TLB通过虚拟地址VPN部分进行索引，分为索引（TLBI）与标记（TLBT）两个部分。这样，MMU在读取PTE时会直接通过TLB，如果不命中再从内存中将PTE复制到TLB。 同时，为了减少页表太大而造成的空间损失，可以使用层次结构的页表页压缩页表大小。 Corei7使用的是四级页表。如图7.9所示，在四级页表层次结构的地址翻译中，虚拟地址被划分为4个VPN和1个VPO。每个第i个VPN都是一个到第i级页表的索引，第j级页表中的每个PTE都指向第j+1级某个页表的基址，第四级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN之前，MMU必须访问四个PTE。 7.5三级Cache支持下的物理内存访问 得到了物理地址PA，首先使用物理地址的CI进行组索引（每组8路），对8路的块分别匹配CT进行标志位匹配，如果匹配成功且块的valid标志位为1，则命中hit，然后根据数据偏移量CO取出数据并返回。 若没找到想匹配的或者标志位为0，则miss，那么cache向下一级cache，这里是二级cache甚至三级cache中寻找查询数据，然后逐级写入cache。 在更新cache的时候，需要判断是否有空闲块：若有空闲块（即有效位为0），则写入；若不存在，则进行驱逐一个块（LRU策略）。 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给他一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障是一种常见的故障，当指令引用一个虚拟地址，在MMU中查找页表时发现与该地址相对应的物理地址不在内存中，因此必须从磁盘中取出的时候就会发生故障。 缺页中断处理：缺页处理程序是系统内核中的代码，选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送VA到MMU，这次MMU就能正常翻译VA了。 7.9动态存储分配管理 1.动态内存分配器的基本原理 在程序运行时程序员使用动态内存分配器(比如malloc)获得虚拟内存。动态内存分配器维护者一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护，每个块要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器的类型有两种：显式分配器和隐式分配器。 显式分配器：要求应用显式地释放任何已分配的块。例如，C语言中的malloc函数申请了一块空间之后需要free函数释放这个块 隐式分配器：应用检测到已分配块不再被程序所使用，就释放这个块。比如Java，ML和Lisp等高级语言中的垃圾收集。 2.带边界标签的隐式空闲链表分配器原理 带边界标签的隐式空闲链表的堆块结构如图7.13。一个块是由一个字的头部、有效载荷、可能的一些额外的填充，以及在块的结尾处的一个字的脚部组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是0。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。 寻找一个空闲块的方式有三种： （1）首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块：可以取总块数（包括已分配和空闲块）的线性时间，但是会在靠近链表起始处留下小空闲块的“碎片”。 （2）下一次适配：和首次适配相似，只是从链表中上一次查询结束的地方开始，优点是比首次适应更快：避免重复扫描那些无用块。但是一些研究表明，下一次适配的内存利用率要比首次适配低得多。 （3）最佳适配：查询链表，选择一个最好的空闲块适配，剩余最少空闲空间，优点是可以保证碎片最小 提高内存利用率，但是通常运行速度会慢于首次适配。 3.关于堆块的合并有四种情况。在情况1中，两个邻接的块都是已分配的，因此不可能进行合并。所以当前块的状态只是简单地从已分配变成空闲。在情况2中，当前块与后面的块合并。用当前块和后面块的大小的和来更新当前块的头部和后面块的脚部。在情况3中，前面的块和当前块合并。用两个块大小的和来更新前面块的头部和当前块的脚部。在情况4中，要合并所有的三个块形成一个单独的空闲块，用三个块大小的和来更新前面块的头部和后面块的脚部。在每种情况中，合并都是在常数时间内完成的。 3.显式空间链表的基本原理 显式空间链表是一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。双向链表使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以使线性的，也可以是一个常数，这取决于我们选择的空闲链表中块的排序策略。 链表的维护方式有两种：一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在线性时间内完成。另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 一般而言，显示链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部，这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。 malloc采用分离适配的方法。 适配块策略：首次适配、下一次适配、最佳适配。首次适配利用率较高，下一次适配时间较快，最佳适配可以很好的减少碎片的产生。在分离适配的时候采取的策略一般是首次试配（因为对分离空闲链表的简单首次适配的内存利用效率近似于整个堆的最佳适配的利用效率）。 7.10本章小结 本章引入了物理地址和虚拟地址的概念，以及相互转化的过程，需要了解段式空间和页面管理的相关知识。同时讨论了页命中和页不命中的相关操作，对fork和execve有了进一步的认知，了解了动态内存分配的方式和放置策略。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m字节的序列。所有的IO设备(如网路、磁盘、终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O,这使得所有的输入和输出都被当做相应文件的读和写来执行： 8.2简述UnixIO接口及其函数 接口： 1.打开文件：一个应用程序通过要求内核打开相应的文件来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个文件的所有信息，应用程序只需要记住这个描述符。 2.linuxshell创建进程的时候会打开三个文件 标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，可以代替显式的描述符值。 3.改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地改变当前文件位置k。 4.读写文件：一个读操作就是文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为EOF的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF”符号，类似地，写操作就是不从内存复制n>0个字节到一个文件，从当前文件位置k开始，更新k。 5.关闭文件：当应用完成对文件的访问后，通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 8.3printf的实现分析 staticintprintf(constchar*fmt, ) { va_listargs; inti; va_start(args,fmt); write(1,printbuf,i=vsprintf(printbuf,fmt,args)); va_end(args); returni; } vsprintf作用是格式化，接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 syscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。于是我们的打印字符串就显示在了屏幕上。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } 1.运行getchar()时，程序将控制权交给os，键入时，内容进入缓存并在屏幕显示，enter后，通知os输入完成，这时再将控制权交还给程序。 2.异步异常-键盘中断处理：键盘中断处理子程序，接受按键扫描码转成ASCII码，保存到系统的键盘缓冲区。 3.getchar调用read系统函数，通过系统调用读取按键ASCII码，直到接受到回车键才返回。 8.5本章小结 本章介绍了Linux中I/O设备的管理方法，UnixI/O接口和函数，并且分析了printf和getchar函数是如何通过UnixI/O函数实现其功能的，最后对printf和getchar两个函数进行分析。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 Hello.c程序首先经过程序员的编写，以文件形式存储在磁盘上，之后经过预处理得到hello.i文件，hello.i文件经过编译器后得到汇编代码hello.s汇编文件，hello.s经过汇编，得到二进制可重定位目标文件hello.o，hello.o经过链接，生成了可执行文件hello。 bash进程是一个shell，它调用fork函数，生成子进程，并由execve函数加载运行当前进程的上下文中加载并运行新程序hello，hello运行过程中会调用各种函数，例如printf函数，与linuxI/O密切相关。hello最终被shell父进程回收，内核回收为其创建的所有信息。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 计算机系统是一个复杂却精密的系统，这一部分拥有着细碎繁多但却都不可忽视的知识点。《深入理解计算机系统》一书可以带着我们逐步理解计算机系统，但是这只是一种启蒙，为了更好的学习计算机系统，我们还需要更多的实践，我相信在未来课程的学习中，我会更好的利用、加深计算机系统知识。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 中间结果文件文件作用hello.i预处理生成的文本文件hello.ihello.s编译产生的文本文件hello.shello.o汇编后生成的可重定位目标文件hello.ohelloo.elfhello.o的elf文件helloo.objdumpobjdumphello.o生成的hello.o的反汇编代码文件hello链接生成的可执行文件hellohello.elfhello的elf文件hello.objdumpobjdumphello生成的hello的反汇编代码文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 兰德尔E.布莱恩特.深入理解计算机系统.龚奕利译. [2] 库函数getchar()详解https://blog.csdn.net/hulifangjiayou/article/details/40480467 [3] Linux进程虚拟地址空间https://www.cnblogs.com/xelatex/p/3491305.html [4] printf函数实现的深入剖析. https://www.cnblogs.com/pianist/p/3315801.html [5] getchar函数的分析https://www.runoob.com/cprogramming/c-function-getchar.html （参考文献0分，缺失-1分） 

程序人生-Hello’sP2P 摘 要 本文从一个hello程序入手，漫步计算机系统世界。文章将解析hello程序从hello.c经过预处理、编译、汇编和链接生成可执行文件的全过程，阐述计算机系统对hello进行的进程管理、存储管理和IO管理，展示hello程序在Linux系统里的完整生命周期。在对hello程序生命周期探索的过程中，将会使用到Ubuntu虚拟机、edb和gcc等实用的工具，融合CS:APP中各章的重点知识，进一步提升读者对Linux系统操作的熟练度，加深读者对计算机系统的认识。 关键词：hello程序；预处理；编译；汇编；链接；进程；存储；IO 目 录 第1章概述 -4- 1.1hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -5- 第2章预处理 -6- 2.1预处理的概念与作用 -6- 2.2在Ubuntu下预处理的命令 -6- 2.3hello的预处理结果解析 -6- 2.4本章小结 -8- 第3章编译 -9- 3.1编译的概念与作用 -9- 3.2在Ubuntu下编译的命令 -9- 3.3hello的编译结果解析 -9- 3.3.1数据类型 -9- 3.3.2赋值操作 -11- 3.3.3算术操作 -11- 3.3.4关系操作 -11- 3.3.5数组操作 -11- 3.3.6控制转移 -12- 3.3.7函数操作 -13- 3.4本章小结 -14- 第4章汇编 -15- 4.1汇编的概念与作用 -15- 4.2在Ubuntu下汇编的命令 -15- 4.3可重定位目标elf格式 -15- 4.4hello.o的结果解析 -18- 4.5本章小结 -20- 第5章链接 -21- 5.1链接的概念与作用 -21- 5.2在Ubuntu下链接的命令 -21- 5.3可执行目标文件hello的格式 -21- 5.4hello的虚拟地址空间 -24- 5.5链接的重定位过程分析 -25- 5.6hello的执行流程 -27- 5.7hello的动态链接分析 -28- 5.8本章小结 -29- 第6章hello的进程管理 -30- 6.1进程的概念与作用 -30- 6.2简述壳shell-bash的作用与处理流程 -30- 6.3hello的fork进程创建过程 -31- 6.4hello的execve过程 -31- 6.5hello的进程执行 -31- 6.6hello的异常与信号处理 -32- 6.7本章小结 -35- 第7章hello的存储管理 -36- 7.1hello的存储器地址空间 -36- 7.2Intel逻辑地址到线性地址的变换-段式管理 -36- 7.3Hello的线性地址到物理地址的变换-页式管理 -36- 7.4TLB与四级页表支持下的VA到PA的变换 -37- 7.5三级Cache支持下的物理内存访问 -38- 7.6hello进程fork时的内存映射 -39- 7.7hello进程execve时的内存映射 -39- 7.8缺页故障与缺页中断处理 -40- 7.9动态存储分配管理 -41- 7.10本章小结 -44- 第8章hello的IO管理 -45- 8.1Linux的IO设备管理方法 -45- 8.2简述UnixIO接口及其函数 -45- 8.3printf的实现分析 -46- 8.4getchar的实现分析 -47- 8.5本章小结 -48- 结论 -49- 附件 -51- 参考文献 -52- 第1章概述 1.1hello简介 P2P:FromProgramtoProcess 用C语言编写得到的hello.c经过cpp的预处理变为hello.i，然后经过cc1的编译变为hello.s，再经过as的汇编变为hello.o，最后经过ld的链接成为可执行目标文件hello，如图1-1所示。当我们在shell中键入执行命令后，shell创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。 图1-1编译系统 020:FromZerotoZero Shell生成的子进程通过execve加载并运行hello，操作系统为其分配虚拟内存空间，再将虚拟内存空间映射到物理内存空间，然后进入main函数执行目标代码。CPU为运行的hello分配时间片，执行逻辑控制流。IO和信号处理使得hello中的内容能顺利显示到屏幕上。程序运行结束后，shell接收信号，回收hello进程，内核将会清除与hello相关的数据。 1.2环境与工具 硬件环境：X64CPU；2.5GHz；8GRAM；256GHDDisk 软件环境：Windows1064位；VMware16；Ubuntu20.04LTS64位 工具：gcc；edb；objdump；readelf等 1.3中间结果 文件名文件作用hello.ihello.c预处理后的文本文件，用于分析预处理结果hello.shello.i编译后的汇编文件，用于分析编译结果hello.ohello.s汇编后的可重定位目标文件，用于分析汇编结果elf.txthello.o的ELF格式，用于分析hello.oobjdump.txthello.o的反汇编代码，用于分析hello.ohellohello.o链接后的可执行目标文件elf2.txthello的ELF格式，用于分析helloobjdump2.txthello的反汇编代码，用于分析hello 1.4本章小结 本章简述了hello程序P2P和020的整个过程，介绍了实验所用到的环境和工具，并给出了hello程序走完整个生命周期将会经历的中间文件。 第2章预处理 2.1预处理的概念与作用 概念： 预处理是指预处理器根据以字符#开头的命令（包括宏定义、条件编译和源文件包含等），修改原始的C程序，插入指定文件，扩展指定的宏，得到一个完整的文本文件。 作用： 1.对宏定义进行宏替换。 2.处理条件编译命令，过滤不需要编译的代码。 3.将需包含的源文件的内容插入程序文本中。 4.过滤掉所有的注释。 5.使得源代码在不同的执行环境中被方便的修改或编译。 2.2在Ubuntu下预处理的命令 预处理命令：gcchello.c-E-ohello.i 图2-1预处理命令 2.3hello的预处理结果解析 将得到的hello.i以文本文件形式打开，会发现原本几十行的hello.c（如图2-2）变成了数千行。文件的最后末端部分是hello.c的主体内容（如图2-3），前面部分（如图2-4）将指定的源文件包含了进来，说明已经将hello.c进行了预处理。 图2-2hello.c代码 图2-3hello.i前面部分代码（仅展示了前50行） 图2-4hello.i末端部分代码 2.4本章小结 本章介绍了预处理的概念及作用，并演示了在Ubuntu虚拟机下对hello.c进行预处理的过程，分析了预处理结果hello.i。 第3章编译 3.1编译的概念与作用 概念： 编译是指编译器将预处理后得到的.i文件（文本文件）处理成为.s文件（文本文件），它包含一个汇编语言程序。 作用： 编译器能将不同的高级语言写出的源程序转换为使用通用的汇编语言的汇编语言程序，为后续生成机器语言的代码做好准备。值得一提的是，除了实现上述基本功能，编译器还可以实现语法检查、程序优化等功能。 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序。 3.2在Ubuntu下编译的命令 编译命令：gcchello.i-S-ohello.s 图3-1编译命令 3.3hello的编译结果解析 3.3.1数据类型 1.全局变量intsleepsecs 全局变量sleepsecs被存储在了数据段（如图3-2），其值大小不是2.5，而是2，这是因为sleepsecs的类型被定义为了int，这里进行了一个隐式的转换。 图3-2全局变量sleepsecs的编译结果 2.main函数参数intargc argc作为第一个参数，被存储在寄存器%rdi中。 图3-3main函数参数argc的编译结果 3.main函数参数char*argv[] argv作为第二个参数，被存储在寄存器%rsi中。注意argv是作为一个char型数组的首地址被存在%rsi中的。 图3-4main函数参数argv的编译结果 4.局部变量inti 局部变量通常储存在栈上，在hello.s中，我们能发现局部变量i存储在了栈上-4(%rbp)处。 图3-5局部变量i的编译结果 5.常量 代码中出现的常量，均以立即数的形式出现在hello.s中（如图3-6）。 图3-6常量的编译结果 6.字符串 字符串被放在只读数据段，如图3-7。 图3-7字符串的编译结果 3.3.2赋值操作 程序中的赋值操作i=0，由movl实现（如图3-5）。其中l表示传送的是双字大小，即4个字节。 3.3.3算术操作 程序中算术操作i++，由addl实现（如图3-8）。 图3-8i++的编译结果 3.3.4关系操作 1.argc!=3 判断main函数参数argc与3的大小时，用到了cmpl（如图3-9），然后设置条件码，为后续跳转做准备。 图3-9argc!=3的编译结果 2.i<10 判断局部变量i和10的大小时，用到了cmpl（如图3-10），然后设置条件码，为后续跳转做准备。 图3-10i<10的编译结果 3.3.5数组操作 程序中涉及到读取argv[1]和argv[2]的操作（如图3-11），可以看到先是将argv[0]的地址传入%rax，然后将%rax加16，即可得到argv[2]的地址，再将%rax中的值作为地址，将内存中对应地址处的值传给%rdx，至此便成功将argv[2]中的值读取出来存储到%rdx中了。读取argv[1]的值方法类似，不过在将%rax加16处改为了将%rax加8，使得%rax中存储的是argv[1]的地址，而不是argv[2]的地址。 图3-11argv[1]和argv[2]的编译结果 3.3.6控制转移 1.if(argc!=3) 3.3.4中的关系操作会使得条件码被设置，当条件满足时（ZF被设置，即两数相等），指令会跳转到指定处（.L2），如图3-12。 图3-12if(argc!=3)的编译结果 2.for(i=0;i<10;i++) 第一次循环开始前，先给i赋初值，然后无条件跳转到循环条件判断处（.L3），之后每次循环开始前都会比较i与10的大小，设置条件码，从而根据条件码判断是否需要继续跳转到循环体开始处（.L4），如图3-13。 图3-13if(argc!=3)的编译结果 3.3.7函数操作 函数被调用之前，需要先在寄存器中存好要传的参数（存储器使用顺序为%rdi、%rsi、%rdx、%rcx、%r8、%r9），然后用call来调用函数，函数的返回值会被存放到寄存器%rax中。 1.main函数 参数传递：main函数的传入参数argc和argv，分别用寄存器%rdi和%rsi存储，前面已经详细叙述过。 函数调用：main函数的调用是由_start函数调用的系统启动函数__libc_start_main来完成的，main的返回值也将由它处理，并且在需要的时候会将控制返回给内核。 函数返回：设置%eax为0并且leave，如图3-14，对应return0。 图3-14main函数返回的编译结果 2.printf函数 参数传递：第一次调用时，将字符串“Usage:Hello学号姓名！\n”的有效地址传入%rdi作为参数，调用puts，如图3-15。第二次调用时，将字符串“Hello%s%s\n”的有效地址传入%rdi，将argv[1]和argc[2]的值分别传入%rsi和%rdx作为参数，调用puts，如图3-16。 图3-15第一次调用printf函数 图3-16第二次调用printf函数 函数调用：在if条件判断中被main函数调用一次（如图3-15），在for循环中被main函数调用一次（如图3-16）。 3.exit函数 参数传递：传入的参数为1，存储在%rdi中，如图3-17。 函数调用：在if条件判断中被main函数调用，如图3-17。 图3-17调用exit函数 4.sleep函数 参数传递：传入的参数为sleepsecs，存储在%rdi中，如图3-18。 函数调用：在for循环中被main函数调用，如图3-18。 图3-18调用sleep函数 5.getchar函数 函数调用：在main函数中，最后返回前被调用，如图3-19。 图3-19调用getchar函数 3.4本章小结 本章介绍了编译的概念及作用，演示了在Ubuntu虚拟机下对hello.i进行编译得到hello.s的过程，并分析了编译结果。在结果分析部分，对hello.c中存在的数据类型、赋值操作、算术操作、关系操作、数组操作、控制转移和函数操作均进行了具体的分析，详细解读了hello的编译结果。 第4章汇编 4.1汇编的概念与作用 概念： 汇编是指汇编器将编译后得到的.s文件（文本文件）翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在目标文件.o（二进制文件）中。 作用： 将汇编代码转为机器语言指令，使代码真正能被机器识别并执行。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。 4.2在Ubuntu下汇编的命令 汇编命令：ashello.s-ohello.o 图4-1汇编命令 4.3可重定位目标elf格式 首先使用指令readelf-ahello.o>elf.txt获得hello.o的ELF可重定位目标文件，如图4-2。 图4-2生成elf.txt 1.ELF头 ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。 如图4-3，可以看出该系统字的大小为64位，采用小端序，机器类型为x86-64，这个ELF头的大小为64字节，有14个节头，文件是可重定位目标文件。 图4-3ELF头 2.节头部表 节头部表是描述目标文件的节，它会描述目标文件中不同节的编号、名称、类型、地址、偏移量、大小、全体大小、旗标、链接、信息和对齐等，如图4-4。 图4-4节头部表 3.重定位节 重定位节中的偏移量是指需要被修改的引用的节偏移；类型告知链接器如何修改新的引用；符号名称标识被修改引用应该指向的符号；加数是一个有符号常数，一些重定位要使用它对被修改引用的值做偏移调整。具体的重定位过程将在第5章进行叙述，此处只介绍相关概念。 .rela.text（如图4-5）是一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。 图4-5.rela.text节 类似地，.rela.eh_frame（如图4-6）中包含.eh_frame节中需要进行重定位的信息。 图4-6.rela.eh_frame节 4.符号表 .symtab是一个符号表（如图4-7），它存放在程序中定义和引用的函数和全局变量的信息。每个可重定位目标文件在.symtab中都有一张符号表（除非特意用STRIP命令去掉它）。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。 图4-7符号表 4.4hello.o的结果解析 首先使用objdump-d-rhello.o>objdump.txt得到hello.o的反汇编代码，如图4-8。 图4-8生成objdump.txt 查看objdump.txt的内容，如图4-9。 图4-9objdump.txt 将objdump.txt与hello.s比较，会发现两者具有一定的相似性，即在汇编指令部分几乎完全一致，涉及到函数调用的部分汇编指令发生了变化，引入了重定位条目。而且objdump.txt中出现了hello.s中没有的机器语言。 机器语言是纯粹的二进制数据表示的语言，能真正被机器识别并执行；汇编语言是容易被人理解的直接描述CPU行为的语言，但机器并不能直接识别和执行。每一条汇编语言的指令都能被转换为唯一确定的机器语言指令，即两者间存在着一一对应的映射关系。 机器语言中的操作数是由寄存器指示符字节指明用到的寄存器，用常数字指明立即数数据、地址指示符的偏移量及分支和调用的目的地址；而汇编语言用立即数、寄存器和内存引用的方式指明操作数。 hello.s中，程序为了进行分支转移，进行了分段并命名（如.L3），这是在编译时候标记的助记符。在汇编成机器语言之后，为了明确下一条指令的位置，不能再使用这种段名称的标记方式，所以objdump.txt得到的反汇编代码中的跳转指令用的不再是段名称，而是确定的地址。 hello.s中，函数调用后面直接跟着被调用函数的名称，而objdump.txt中，call的目标地址是下一条指令。这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器来确定函数运行时的目标地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0(即设为下一条指令），并在.rela.text节中添加重定位条目，等待后续的重定位。 4.5本章小结 本章介绍了汇编的概念及作用，演示了在Ubuntu虚拟机下对hello.s进行汇编得到hello.o的过程，并分析了汇编结果。在分析结果时，先是用readelf查看了hello.o的ELF文件，从ELF头、节头部表、重定位节和符号表的角度分别进行了分析，介绍一些基本概念，为第5章做好准备。同时也使用objdump查看了hello.o的反汇编代码，从操作数、分支转移和函数调用等方面分析了机器语言和汇编语言的差异。 第5章链接 5.1链接的概念与作用 概念： 链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。 作用： 链接使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其它文件。 注意：这儿的链接是指从hello.o到hello生成过程。 5.2在Ubuntu下链接的命令 链接命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5-1链接命令 5.3可执行目标文件hello的格式 首先使用指令readelf-ahello>elf2.txt获得hello的ELF可执行目标文件，如图5-2。 图5-2生成elf2.txt 1.ELF头 如图5-3，可以看出ELF头中部分信息与链接前相比发生了变化，文件类型变成了可执行目标文件，节头和程序头均增加，还获得了程序的入口点地址。 图5-3ELF头 2.节头部表 如图5-4，此时节的数量增多，各节已被重定位到最终运行时的内存地址处，地址、偏移量、大小等数据发生了变化。 图5-4节头部表 3.程序头部表 可执行文件的连续的片被映射到连续的内存段，程序头部表描述了这种映射关系。如图5-5，offset表示目标文件中的偏移，viraddr是虚拟地址，phyaddr是内存地址，filesize是目标文件中段的大小，memsiz是内存中段的大小，flags是运行时的访问权限，align是对齐要求。 PHDR指保存了二进制的程序头表，INTERP指定程序已经从可执行文件映射到具体的内存区域后，必须调用的解释器（如动态链接器）的路径，LOAD表示可加载的程序段，DYNAMIN保存了由动态链接器使用的信息，NOTE保存辅助信息，GNU_STACK标志栈是否可执行，GNU_RELRO指定重定位后需被设置成只读的内存区域。 图5-5程序头部表 5.4hello的虚拟地址空间 下面在DataDump中查看5.3中出现的段，以标为INTERP和第三个标为LOAD的段为例。 图5-6INTERP段 图5-7LOAD段 以这两个段为例，能看到在程序头表中描述的段的各类信息（类型、起始地址和大小等）均和DataDump查看结果一致。实际上，所有段的虚拟地址信息都被正确而完整地记录在了程序头表中。 5.5链接的重定位过程分析 首先使用objdump-d-rhello>objdump2.txt得到hello的反汇编代码，如图5-8。 图5-8生成objdump2.txt 查看objdump2.txt的内容，如图5-9。 图5-9objdump2.txt（仅包含main函数部分） 和上次反汇编的结果进行比较，有一些不同之处： （1）hello反汇编得到的汇编代码中，已经有了确定的地址，即完成了重定位；而hello.o反汇编的结果尚未进行重定位，仅仅标注出了需要重定位的部分。 （2）hello反汇编的结果中出现了更多函数的汇编代码，节也增多了，这是因为链接使得多个文件合并，更多的节以及更多的函数都被引入了。 ELF有多种重定位类型，其中最基本的两种是R_X86_64_PC32和R_X86_64_32，这两种重定位算法的伪代码如图5-10所示，其中r表示重定位条目，s表示节。 图5-10重定位算法 图5-11exit重定位后的地址 现在以exit为例，分析其重定位的实现过程：查看图4-9中的代码和重定位条目，再结合图4-5中的重定位节的信息，可知main函数引用了exit，且需使用32位PC相对地址进行重定位（R_X86_64_PLT32同R_X86_64_PC32一样是相对寻址）。 若exit的重定位条目为r，则由图4-9知，有： r.offset=0x2b r.symbol=exit r.type=R_X86_64_PLT32 r.addend=-4 且s满足： ADDR(s)=0x401105（如图5-9） 此外： ADDR(r.symbol)=ADDR(exit)=0x4010b0（如图5-11） 由图5-10中的公式知： refaddr=ADDR(s)+r.offset=0x401105+0x2b=0x401130 *refptr=(unsigned)(ADDR(r.symbol)+r.addend-refaddr) =(unsigned)(0x4010b0+(-4)-0x401130) =(unsigned)(0xffffff7c) 如图5-12，重定位结果正确。 图5-12hello中调用exit处代码 5.6hello的执行流程 ld-2.31.so!_dl_start ld-2.31.so!_dl_init hello!_start callmain ld-2.31.so!__libc_start_main hello!_init hello!main hello!puts@plt hello!exit@plt 5.7hello的动态链接分析 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的。共享库也称为共享目标，在Linux系统中通常用.so后缀来表示。 动态链接器使用过程链接表PLT+全局偏移量表GOT实现函数的动态链接，GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。如果一个目标模块调用定义在共享库中的任何函数，那么就有自己的GOT和PLT。 过程链接表（PLT）。PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 全局偏移表（GOT）。GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。初始时，每个GOT条目都指向对应PLT条目的第二条指令。 .got.plt起始地址是0x404000（如图5-4），在dl_init前，内容如图5-13所示。 图5-13dl_init前.got.plt内容 在dl_init后，内容如图5-14所示。 图5-14dl_init后.got.plt内容 5.8本章小结 本章介绍了链接的概念及作用，演示了在Ubuntu虚拟机下对hello.o进行链接得到hello的过程，并分析了链接结果。在分析结果时，先是用readelf查看了hello的ELF文件，从ELF头、节头部表和程序头部表的角度分别进行了分析，验证了段在虚拟地址空间的位置。同时也使用objdump查看了hello的反汇编代码，发现链接后的目标文件函数和节都增加了，重定位也完成了，还以exit为例解释了重定位算法的具体实现。除了静态的链接，链接器还会动态链接共享库，在最后还展示了hello的执行流程，分析了hello的动态链接。 第6章hello的进程管理 6.1进程的概念与作用 概念： 进程的经典定义就是一个执行中的程序的实例。系统的每一个程序都是运行在某一个进程上下文中。上下文是由程序正确运行所需要的状态构成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及上下文描述符的集合。 作用： 1.每次用户通过向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在新进程的上下文中运行它们自己的代码或其他应用程序。 2.进程提供给应用程序的关键抽象：一个独立的逻辑控制流，好像我们的程序独占地使用处理器；一个私有的地址空间，好像我们的程序独占地使用内存系统。 6.2简述壳shell-bash的作用与处理流程 作用： shell是一个应用程序，是操作系统中用户与系统内核进行交互的界面。 处理流程： 1.读取用户由键盘输入的命令行。 2.分析命令，以命令名作为文件名，并将其它参数改造为系统调用execve()内部处理所要求的形式。 3.终端进程调用fork()建立一个子进程。 4.终端进程本身调用wait()来等待子进程完成（如果是后台命令，则不等待）。当子进程运行时调用execve()，子进程根据文件名到目录中查找有关文件，调入内存，执行这个程序。 5.如果命令末尾有&,则终端进程不用执行系统调用wait()，立即发提示符，让用户输入下一条命令；否则终端进程会一直等待，当子进程完成工作后，向父进程报告，此时中断进程醒来，作必要的判别工作后，终端发出命令提示符，重复上述处理过程。 6.3hello的fork进程创建过程 父进程通过调用fork函数创建一个新的运行的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同但是独立的一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本。父进程和子进程最大的区别在于他们有不同的PID。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流中的指令。 在这里，shell作为父进程通过fork函数为hello创建一个新的子进程，在这个新进程的上下文中运行hello。 6.4hello的execve过程 子进程调用exceve函数在当前子进程的上下文加载并运行一个新的程序，此处即hello程序。exceve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量argc。加载器会删除现有的用户区域；映射私有空间，创建新的代码、数据、堆和栈区域，将代码段和数据段初始化为hello的代码和数据，堆和栈被置空；映射共享区域，实现动态链接；设置PC，将其指向hello程序的起始位置，即从下条指令开始执行hello程序。 6.5hello的进程执行 多个流并发地执行的一般现象被称为并发。一个进程和其他进轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片。因此，多任务也叫做时间分片。 内核为每个进程维持了一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策叫做调度。在内核调度了一个新的进程运行后，它就抢占当前进程，使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换1）保存当前进程的上下文，2）恢复某个先前被抢占的进程被保存的上下文，3）将控制传递给这个新恢复的进程。 最初hello运行在用户模式下，内核将控制给hello，为hello分时间片，上下文为hello的上下文。hello正常运行，当遇到sleep函数时，内核会因显式的请求抢占hello，进行上下文切换，将控制转移给sleep，直到sleep结束，内核再进行上下文切换，将控制传递给hello，过程如图6-1。其他的函数调度过程类似。 图6-1进程调度（以sleep为例） 6.6hello的异常与信号处理 可能出现的异常一共有四种：中断、陷阱、故障、终止。它们的产生原因及处理如图6-2。 图6-2异常类别及处理 在发生异常时会发出信号，常见信号种类如图6-3所示。 图6-3信号种类及处理 图6-4展示了正常运行hello至结束的情况。 图6-4正常运行 若在运行过程中乱按键盘，如图6-5。可以看到只是将字符缓存到stdin，直到按下’\n’，被当作命令读入。 图6-5乱按键盘 若在运行过程中按下Ctrl+C，内核发送一个SIGINT信号到前台进程组的每个进程，默认情况是终止前台作业，hello将会被立即终止，用ps查看发现无hello，如图6-6。 图6-6按下Ctrl+C 若在运行过程中按下Ctrl+Z，内核发送一个SIGTSTP信号到前台进程组的每个进程，默认情况是停止前台作业，此时hello未被回收，而运行在后台，用ps查看发现有hello，如图6-7。 图6-7按下Ctrl+Z 用jobs查看当前进程情况，用pstree查看相关进程关系，如图6-8。 图6-8jobs和pstree查看相关信息 用fg1将hello调回前台，此时会先打印执行hello的命令行命令，然后hello继续运行打印剩下的7个输出，最后输入字串，程序结束，同时进程被回收，如图6-9。 图6-9用fg调回hello 6.7本章小结 本章阐述了进程的概念与作用，介绍了Shell的作用和一般处理流程，分析了调用fork创建新进程，调用execve加载并执行hello以及hello的进程调度。还以乱按键盘、按下Ctrl+C和按下Ctrl+Z为例，着重分析了hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：程序产生的和段相关的偏移地址，由一个标识符加上一个指定段内的相对地址的偏移量构成。 线性地址（虚拟地址）：逻辑地址到物理地址变换之间的中间层。段中的偏移地址加上相应段的基地址就生成了一个线性地址。 物理地址：指出目前CPU外部地址总线上的寻址物理内存的地址信号，用于内存级芯片的单元寻址，是地址变换的最终结果地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由段标识符和段内偏移量两部分组成。段标识符是由一个16位长的字段组成，其中前13位是一个索引号，后3位是T1字段，索引号是段描述符的索引，很多个段描述符组成了一个段描述符表。先判断T1字段，看看这个段描述符究竟是在局部段描述符表(ldt)中还是全局段描述符表(gdt)中，通过索引号在描述符表内找到一个具体的段描述符。找到的段描述符加上偏移量即为线性地址。 7.3hello的线性地址到物理地址的变换-页式管理 系统将虚拟页作为进行数据传输的单元。虚拟内存分割被成为虚拟页，物理内存也被分割为物理页，大小和虚拟页相同。任意时刻虚拟页都被分为三个不相交的子集：未分配的（VM系统还未分配的页）、缓存的（当前已经缓存在物理内存的已分配页）、未缓存的（当前未缓存在物理内存的已分配页）。 每次将虚拟地址转换为物理地址，都会查询页表来判断一个虚拟页是否缓存在DRAM的某个地方，如果不在DRAM的某个地方，通过查询页表条目可以知道虚拟页在磁盘的位置。页表将虚拟页映射到物理页，如图7-1。 图7-1页表 7.4TLB与四级页表支持下的VA到PA的变换 先将虚拟地址分为虚拟页号（VPN），虚拟页偏移量（VPO），依据VPN（TLBT+TLBI）先在TLB中寻找，若找不到，则在高速缓存/内存中寻找，若找到对应的物理页号（PPN），再将PPN与VPO组合成物理地址，若还是查找不到，则需要缺页处理，在磁盘中查找，并将新的页更新入内存中，如图7-2。 图7-2使用页表的地址翻译 如图7-3，36位的VPN被分成4个9位的片，每个片被用做到一个页表的偏移量。CR3寄存器包含一级页表的基地址。VPN1提供一个一级PTEi的偏移量，它包含二级页表的基地址，VPN2再提供一个偏移量，以此类推。 图7-3TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 图7-4物理地址的划分 如图7-4，将已得到的物理地址拆分为CT（标记），CI（组索引），CO(块偏移)，在L1Cache中依据组索引，找到对应的组，再依据标记查找是否存在并判断是否有效，最后根据块偏移找到块，如图7-5。如果上述条件均满足则命中，否则按顺序对L2Cache、L3Cache、内存进行相同操作，直到命中，然后向上级返回。如果有空闲块则将目标块放置到空闲块中，否则将缓存中的某个块驱逐，将目标块放到被驱逐块的位置。 图7-5高速缓存组织结构 7.6hello进程fork时的内存映射 当fork函数被shell调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了hello进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序，如图7-6。加载并运行hello需要以下几个步骤： (1)删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 (2)映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 (3)映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 (4)设置程序计数器(PC)，execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 图7-6加载器映射用户地址空间的区域 7.8缺页故障与缺页中断处理 当指令引用一个虚拟地址，而与改地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生缺页故障。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。上述过程如图7-7所示。 图7-7缺页故障的处理 在发生缺页中断之后，系统会调用内核中的一个缺页处理程序。处理缺页要求硬件和操作系统内核协作完成，具体的操作过程如图7-8所示： (1)处理器生成一个虚拟地址，并把它传送给MMU。 (2)MMU生成PTE地址，并从高速缓存/主存请求得到它。 (3)高速缓存/主存向MMU返回PTE。 (4)PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。 (5)缺页处理程序确定出物理内存中的牺牲页，如果这个页面己经被修改了，则把它换出到磁盘。 (6)缺页处理程序页面调入新的页面，并更新内存中的PTE。 (7)缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，主存将所请求字返回给处理器。 图7-8缺页处理流程 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器，要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。C++中的new和delete操作符与C中的malloc和free相当。 隐式分配器，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集，例如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 下面介绍两种常见的分配器： 1.带边界标签的隐式空闲链表 一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是0。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。 头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。 我们称这种结构称为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。注意：此时我们需要某种特殊标记的结束块，可以是一个设置了已分配位而大小为零的终止头部。 Knuth提出了边界标记的技术，是在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面的一个块的起始位置和状态，这个脚部总是在据当前块开始位置一个字的距离。 考虑当分配器释放当前块时可能存在的所有情况： 1）前面的块和后面的块都是已分配的。 2）前面的块是已分配的，后面的块是空闲的。 3）前面的块是空闲的，而后面的块是已分配的。 4）前面的和后面的块都是空闲的。 按照图7-9分类处理即可： 图7-9使用边界标记的4种合并情况 然而这种方法也存在一个潜在的缺陷。它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销。 幸运的是，有一种非常聪明的边界标记的优化方法，能够使得在已分配块中不再需要脚部。把前面块的已分配位/空闲位存放在当前块中多出来的低位中，那么已分配的块就不需要脚部了，这样我们就可以将这个多出来的空间用作有效载荷了。不过空闲块仍然需要脚部。 2.显式空间链表 根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里。例如，堆可以组织成一个双向空闲链表。在每个空闲块中，都包含一个前驱和后继指针，如图7-10。 图7-10使用双向空闲链表的堆块的格式 使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块的线性时间。不过，释放一个块的时间也可以是线性的，也可能是某个常数，这取决于我们所选择的空闲链表中块的排序策略。 一种方法是使用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 另一种方式是按照地址顺序来维护链表，其中链表上每一个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。 7.10本章小结 本章主要介绍了hello的存储管理，讲解了存储器地址空间，段式管理和页式管理的机制，TLB与四级页表支持下的VA到PA的变换和三级Cache支持下的物理内存访问，并且回顾了hello进程fork时和execve时的内存映射，分析了缺页故障与缺页中断处理的流程，最后介绍了动态存储分配管理的方式。这一章的知识有助于编写高速缓存友好代码，优化程序。 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m个字节的序列，所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 UnixI/O接口使得所有输入和输出都能以一种统一且一致的方式来执行： (1)打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。 (2)Linuxshell创建的每个进程都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。 (3)改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 (4)读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k³m时，执行读操作会触发EOF条件，应用程序能检测到这个条件。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 (5)关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： (1)intopen(char*filename,intflags,mode_tmode)：进程通过调用open函数来打开一个已存在的文件或是创建一个新文件。open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件。mode参数指定了新文件的访问权限位。 (2)intclose(intfd)：进程通过调用close函数来关闭一个打开的文件。 (3)ssize_tread(intfd,void*buf,size_tn)：read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF。否则返回值表示的是实际传送的字节数量。 (4)ssize_twirte(intfd,constvoid*buf,size_tn)：write函数从内存位置buf复制至多n个字节到描述符为fd的当前文件位置。 8.3printf的实现分析 首先查看printf的代码： intprintf(constchar*fmt,…) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 其中va_list的定义为：typedefchar*va_list；这说明它是一个字符指针。 (char*)((&fmt)+4)表示的是…中的第一个参数。 vsprintf返回的是要打印出来的字符串的长度，它的作用就是格式化。它接受确定输出格式的格式字符fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 再看看write: moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL 其中INT_VECTOR_SYS_CALL的实现为：init_idt_desc(INT_VECTOR_SYS_CALL,DA_3861Gate,sys_caII,PRIVILEGE_USER); 其中intINT_VECTOR_SYS_CALL表示要通过系统来调用sys_call这个函数。 sys_call函数如下： callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret callsave是为了保存中断前进程的状态。 sys_call最终实现显示格式化的字符串的功能。它将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量），于是打印字符串就显示在了屏幕上。 8.4getchar的实现分析 异步异常-键盘中断的处理：当用户按键时，键盘接口会得到一个代表该按键的键盘扫描码，同时产生一个中断请求，中断请求抢占当前进程，运行键盘中断子程序。键盘中断子程序先从键盘接口取得该按键的扫描码，然后将该按键扫描码转换成ASCII码，保存到系统的键盘缓冲区。 查看getchar的代码如下： int getchar(void) { static char buf[BUFSIZ]; static char*bb=buf; static int n=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return (--n>=0)?(unsigned char)*bb++:EOF; } getchar函数落实到底层调用了系统函数read，通过系统调用read读取存储在键盘缓冲区中的ASCII码，直到读到回车符然后返回整个字串，getchar对其进行封装，读取字符串的第一个字符然后返回。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法，引出了UnixI/O接口的概念，又进一步介绍了UnixI/O的函数，最后简单分析了printf函数和getchar函数的实现。 结论 至此，hello已经走完它短暂的一生。我们在这里对它的人生历程再进行一次回顾。 Hello出生于名为hello.c的文本文件里，程序员通过对键盘的一次次敲击赋予了它生命。 刚出生不久的hello来到了预处理器的怀抱里，它在这里被修改 插入指定文件，扩展指定的宏，变成了一个更完整的文本文件hello.i。 然后，在编译器的帮助下，它把自己从原本的高级语言源程序变成了汇编语言程序hello.s，努力向着被机器识别并执行的方向前进着。 接下来，汇编器再助它一臂之力，将它翻译成机器语言指令，并把这些指令打包成可重定位目标程序的格式保存在二进制文件hello.o中。 虽然已经能被机器识别并运行了，hello却发现自身还需要进一步完善。它又去寻求了链接器的帮助，经过静态链接和动态链接的它终于成为了可执行目标文件hello。 当我们在shell中输入指令执行hello的那一刻，hello变身成为进程。这一刻意义巨大，这标志着hello完成了人生中的第一个阶段 P2P(FromProgramtoProcess)。 Shell调用fork函数生成一个新的子进程，这个子进程通过调用execve函数启动加载器加载hello，为其分配虚拟内存空间，再将虚拟内存空间映射到物理内存空间，然后进入main函数执行目标代码。CPU为运行的hello分配时间片，执行逻辑控制流。 在运行过程中，OS与MMU为hello的VA到PA操碎了心，TLB、四级页表和三级Cache等等各显神通为hello加速。 IO帮助hello中的内容顺利显示到屏幕上。 程序运行结束后，shell接收信号，回收hello进程，内核将会清除与hello相关的数据。Hello走完人生最后一个阶段 020(FromZerotoZero)，完美谢幕！ 通过对hello程序人生的分析，我感受到计算机系统的设计是环环相扣、精妙无比的。这次的计算机系统漫游使我对计算机的底层实现有了更深的理解，还学习到了避免由计算机表示数字方式引起数字错误的实践技巧、避免诸如缓冲区溢出等安全漏洞的方法、优化代码以充分利用现代处理器和存储器系统的设计。有了软件和硬件的相互配合，才有了高效的计算机系统。深入了解这些组件是如何工作的以及这些组件如何影响程序的正确性和性能，能大大提升计算机从业者的技能。 附件 文件名文件作用hello.ihello.c预处理后的文本文件，用于分析预处理结果hello.shello.i编译后的汇编文件，用于分析编译结果hello.ohello.s汇编后的可重定位目标文件，用于分析汇编结果elf.txthello.o的ELF格式，用于分析hello.oobjdump.txthello.o的反汇编代码，用于分析hello.ohellohello.o链接后的可执行目标文件elf2.txthello的ELF格式，用于分析helloobjdump2.txthello的反汇编代码，用于分析hello 参考文献 [1] RandalE.Bryant,DavidR.O’Hallaron.深入理解计算机系统（原书第3版）[M].机械工业出版社，2016.7 [2] https://www.cnblogs.com/pianist/p/3315801.html [3] https://blog.csdn.net/weixin_30438795/article/details/117124493 [4] https://blog.csdn.net/wohenfanjian/article/details/105869692 

HIT-CSAPP大作业程序人生 

HIT计算机系统大作业 程序人生 计算机系统 大作业 计算机科学与技术学院 2021年6月 摘 要 底层实现在计算机领域至关重要，而在平时又难以直观感受，观察并研究hello.c程序在Linux环境下的底层编译、执行过程，了解汇编，链接，加载，执行等过程的概念和实现原理，对今后的学习非常有帮助 关键词：计算机系统；汇编语言；预处理；编译；汇编；链接；OS； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 1.P2P：ProgramtoProgress,文本格式的hello.c文件经过cpp的预处理生成hello.i预处理文件，之后交给ccl进行编译，生成hello.s汇编文件。再将汇编文件交给as生成可重定位文件hello.o，最后经由链接器ld，生成可执行文件hello，由上述过程生成可执行目标文件。 2.O2O：FromZreo-OtoZero-O。shell执行可执行目标文件，管理hello进程，对其进行存储管理，分配映射虚拟内存、分配物理内存，输出结果到显示器，最后结束hello进程，回收其内存空间。 1.2环境与工具 1.2.1硬件环境 Intel(R)Core(TM)i7-9750HCPU@2.60GHz；16GBRAM； 1.2.2软件环境 Windows1064位；VMware：Ubuntu20.04.2LTS64位VMware 1.2.3开发工具 Vim8.1.226964位；Visualstudio201964位；CodeBlocks20.0364位 1.3中间结果 1.hello.c：C语言源文件。 2.hello.i：预处理文本文件。 3.hello.s：汇编代码文件。 4.hello.o：可重定位目标文件。 5.hello：可执行目标文件。 6.hello.asm：由hello.o反汇编生成的汇编代码。 8.hello_o.asm：由hello反汇编生成的汇编代码文本。 7.hello.elf：hello.o的elf信息文本。 9.hello_o.elf：hello的elf信息文本。 1.4本章小结 解释了P2P和O2O的概念和过程，以及本次实验的实验环境即过程中的中间文件 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 概念：预处理器根据以字符#开头的命令，修改原始的C程序，如头文件、宏定义和条件编译。生成一个.i文本文件。 作用：预处理器加入头文件、执行宏替换和条件编译。再进行正式的编译工作，便于编译的高效进行。 2.2在Ubuntu下预处理的命令 图2-1 图1-2 2.3Hello的预处理结果解析 源文件hello.c内容如下 图2-3 预处理文件hello.i内容如下 图2-4 可以看到预处理文件比源文件多出几千行，其内容为对头文件的引入： 图2-5 其中描述了各运行库在计算机中的位置： 图2-6 声明了其中用到的函数名： 图2-7 2.4本章小结 本章介绍了预处理的概念和作用，将hello.c预处理为hello.i，并对预处理结果进行了分析。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译器将预处理文本文件hello.i翻译成汇编语言文本文件hello.s，该文件用汇编语言描述了程序的内容 作用：经过词法分析，语法分析，语义分析，和一定的优化来生成可以实现对应程序功能的汇编代码文件，与高级语言相比，汇编语言更接近计算机能够理解的语言，进一步有利于二进制机器语言的生成。 3.2在Ubuntu下编译的命令 图3-1 图3-2 3.3Hello的编译结果解析 生成的hello.s文件内容如下： 图3-3 3.3.1变量的处理 全局变量：源文件中声明了全局变量sleepsecs，在汇编语言中它存放在了.data区域 图3-4 局部变量：源文件中声明了局部变量i（int类型），局部变量不在数据段表现，观察汇编文件的代码段： 图3-5 可发现源文件中的变量i作为循环条件存在，而汇编代码中参与循环判断的是-4(%rbp)，故i的值存放在该位置 图3-6 3.3.2赋值、算数操作及条件判断与跳转 赋值操作： 该步对应了源代码中i=0的操作 算数操作： 该步对应源代码中i++ 条件判断与跳转： 该步对应了源代码中判断i<10，带汇编语言中表现为判断i是否小于等于9，若是则跳转到循环内部（.L4） 3.3.3函数调用 汇编语言中用call指令实现函数调用的操作 3.3.4数组、指针 该步对应了源代码中对argv[]数组的操作，汇编代码中对数组的实现表示为对数组头加上偏移量的形式实现 3.4本章小结 本章将预处理的文本文件编译为汇编语言表示的.s文件，用以后续生成过程，并对程序中出现的汇编代码进行了解析，使其与源代码中的命令对应 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：把汇编语言翻译成机器语言的过程，形成可重定位目标文件。作用：把汇编语言一一对应地翻译成机器可以理解并直接执行的机器指令。 4.2在Ubuntu下汇编的命令 图4-1 图4-8 4.3可重定位目标elf格式 ELF头：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。 节头：指明各个节的名称、类型、起始地址和偏移量 重定位节： 重定位节记录了程序的偏移信息，使程序可以在链接后正确生成可执行文件 4.4Hello.o的结果解析 图4-9 对比反汇编结果与hello.s可知二者不同： hello.s中分支跳转语句通过跳转到目标节.L3/.L4等来表示，而反汇编文件则通过直接跳转到对应目标地址来实现分支跳转hello.s中函数调用通过call对应函数名实现，而反汇编文件通过call对应函数所在地址来实现hello.s中可以通过直接访问数据段来访问全局变量，而反汇编文件中数据段位置不确定，故需要借助重定位信息进行访问 4.5本章小结 本章将汇编语言文件汇编为可重定位目标文件hello.c，并查看了elf头，分析了elf头中各节的作用，并通过反汇编了解了机器语言的底层实现 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：链接器把多个可重定位文件链接成一个完整的可执行文件。 作用：链接可以在编译、汇编、加载和运行时执行。链接方便了模块化编程。 5.2在Ubuntu下链接的命令 图5-1 图5-2 图5-3 5.3可执行目标文件hello的格式 elf头： 节头： 程序头：在hello_o.elf中没有这部分内容 重定位节: 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明 init:0x00401000 .text:0x004010d0 5.5链接的重定位过程分析 hello.asm中多出的段包括： .interp：保存ld.so的路径 .note.ABI-tag .note.gnu.build-i：编译信息表 .gnu.hash：gnu的扩展符号hash表 .dynsym：动态符号表 .dynstr：动态符号表中的符号名称 .gnu.version：符号版本 .gnu.version_r：符号引用版本 .rela.dyn：动态重定位表 .rela.plt：.plt节的重定位条目 .init：程序初始化 .plt：动态链接表 .fini：程序终止时需要的执行的指令 .eh_frame：程序执行错误时的指令 .dynamic：存放被ld.so使用的动态链接信息 .got：存放程序中变量全局偏移量 .got.plt：存放程序中函数的全局偏移量 .data：初始化过的全局变量或者声明过的函数 5.6hello的执行流程 加载程序： ld-2.27.so!_dl_start ld-2.27.so!_dl_init hello!_start callmain： libc-2.27.so!__libc_start_main hello!main hello!puts@pl 终止： exit 5.7Hello的动态链接分析 由elf文件可知.got.plt的地址 图5-8 使用edb查看运行前GOTPLT表的内容 图5-9 运行dl_start和dl_init后GOTPLT表内容发生变化 图5-10 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 5.8本章小结 本章通过链接成功生成了可执行的目标文件，并介绍了动态链接库等内容 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、以及打开文件描述符的集合。 作用：进程给应用程序提供的关键抽象有两种： a)一个独立的逻辑控制流，提供一个假象，程序独占地使用处理器。 b)一个私有的地址空间，提供一个假象，程序在独占地使用系统内存。 6.2简述壳Shell-bash的作用与处理流程 shell是用户与系统交互作用界面。Shell是一个命令解释程序，也是一种程序设计语言。 1.读入命令行、注册相应的信号处理程序、初始化进程组。 2.通过paraseline函数解释命令行，如果是内置命令则直接执行，否则阻塞信号后创建相应子进程，在子进程中解除阻塞，将子进程单独设置为一个进程组，在新的进程组中执行子进程。父进程中增加作业后解除阻塞。如果是前台作业则等待其变为非前台程序，如果是后台程序则打印作业信息。 6.3Hello的fork进程创建过程 intfork(void)函数： 子进程返回0，父进程返回子进程的PID 新创建的子进程几乎但不完全与父进程相同： 子进程得到与父进程虚拟地址空间相同的（但是独立的）一份副本。 子进程获得与父进程任何打开文件描述符相同的副本。 子进程有不同于父进程的PID fork()调用一次，返回两次。 在shell中如果fork返回值小于0，说明fork时出现了一些问题这时需要进行处理。否则就成功创建了子进程。 6.4Hello的execve过程 调用fork函数之后，子进程将会调用execve函数，来运行hello程序，如果成功调用则不再返回，若未成功调用则返回-1。 完整的加载运行hello程序需要以下几个步骤 首先加载器会删除当前子进程虚拟地址端。，然后创建一组新的代码、数据、堆端，并初始化为0。 接着映射私有区域和共享区域，将新的代码和数据段初始化为可执行文件中的内容 最后设置程序计数器，使其指向代码区的入口，下一次调度这个进程时，将直接从入口点开始执行 6.5Hello的进程执行 Linux系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制。子进程通过execve系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片(chunk),新的代码和数据段袚初始化为可执行文件的内容。最后，加载器跳转到_start地址，它最终会调用应用程序的main函数。 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 6.6hello的异常与信号处理 1.可能出现的异常 中断：来自I/O设备的信号。比如输入CTRL-C或者CTRL-Z 陷阱：有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。 故障是由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。 终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程序会将控制返回给一个abort例程，该例程会终止这个应用程序。 2.可能产生的信号：SIGINT,SIGSTP,SIGCONT,SIGWINCH等 3．异常处理：3.1:运行过程中按CTRL-C，给进程发送SIGINT信号，程序将被终止回收 图6-1 3.2：运行过程中按CTRL-Z，给进程发送SIGSTP信号，程序将被挂起，用fg命令，可以让程序回到前台继续运行。 图6-2 3.3：挂起中输入pstree时 图6-3 6.7本章小结 本章完成了程序从运行到结束的运行过程，体现了hello的进程管理 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：由程序产生的与段相关的偏移地址部分。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。 线性地址：地址空间中的整数是连续的。 虚拟地址：在一个带虚拟内存的系统中，CPU从一个有N=2"个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间。 物理地址：计算机系统的主存被组织成一个个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。 在hello加载进内存时会分配虚拟内存，总是从0x00401000开始 7.2Intel逻辑地址到线性地址的变换-段式管理 每个段的首地址就会被储存在各自的段描述符里面,所以的段描述符都将会位于段全局描述符表中(每个段的全局描述符表一个局部称为gdgdt和另一个局部的的段描述符表一个局部称为ldldt),通过段选择符我们可以快速寻找到某个段的段全局描述符。逻辑上段地址的偏移量结构就是段选择符+偏移量。 段选择符的索引位组成和定义如下,分别指的是索引位,ti,rpl,当索引位ti=0时,段描述符表在rpgdt中,ti=1时,段描述符表在rpldt中。而索引位index就类似一个数组,每个元素内都存放一个段的描述符,索引位首地址就是我们在查找段描述符时再这个元素数组当中的索引。一个段描述符的首地址是指含有8个元素的字节,我们通常可以在查找到段描述符之后获取段的首地址,再把它与线性逻辑地址的偏移量进行相加就可以得到段所需要的一个线性逻辑地址。 在分段保护模式下,分段有两种机制:段的选择符在段的描述符表->分段索引->目标段的段描述符条目->目标段的描述符基地址+偏移量=转换为线性段的基地址。由于现代的macosx86系统内核使用的描述符是基本扁平的逻辑模型,即目标段的逻辑地址=线性段的描述符=转换为线性段的基地址,等价于描述符转换为线性地址时关闭了偏移量和分段的功能。这样逻辑段的基地址与转换为线性段的基地址就合二为一了。 7.3Hello的线性地址到物理地址的变换-页式管理 系统将每个段分割为被称为虚拟页（VP）的大小固定的块来作为进行数据传输的单元，在linux下每个虚拟页大小为4KB，类似地，物理内存也被分割为物理页（PP/页帧），虚拟内存系统中MMU负责地址翻译，MMU使用存放在物理内存中的被称为页表的数据结构将虚拟页到物理页的映射，即虚拟地址到物理地址的映射。 7.4TLB与四级页表支持下的VA到PA的变换 将VPN分成三段，对于TLBT和TLBI来说，可以在TLB中找到对应的PPN，但是有可能出现缺页的情况，这时候就需要到页表中去找。此时，VPN被分成了更多段（这里是4段）CR3是对应的L1PT的物理地址，然后一步步递进往下寻址，越往下一层每个条目对应的区域越小，寻址越细致，在经过4层寻址之后找到相应的PPN让你和和VPO拼接起来。 7.5三级Cache支持下的物理内存访问 得到物理地址之后，先将物理地址拆分成CT（标记）+CI（索引）+CO（偏移量），然后在一级cache内部找，如果未能寻找到标记位为有效的字节（miss）的话就去二级和三级cache中寻找对应的字节，找到之后返回结果。 7.6hello进程fork时的内存映射 shell通过一个调用fork的函数让进程内核自动创建一个新的进程,这个新的进程拥有各自新的数据结构,并且被内核分配了一个唯一的pid。它有着自己独立的虚拟内存空间,并且还拥有自己独立的逻辑控制流,它同样可以拥有当前已经可以打开的各类文件信息和页表的原始数据和样本,为了有效保护进程的私有数据和信息,同时为了节省对内存的消耗,进程的每个数据区域都被内核标记起来作为写时复制。 7.7hello进程execve时的内存映射 execve函数在当前代码共享进程的上下文中加载并自动运行一个新的代码共享程序,它可能会自动覆盖当前进程的所有虚拟地址和空间,删除当前进程虚拟地址的所有用户虚拟和部分空间中的已存在的代码共享区域和结构,但没有自动创建一个新的代码共享进程。新的运行程序仍然在堆栈中拥有相同的区域pid。之后为新运行程序的用户共享代码、数据、bss和所有堆栈的区域结构创建新的共享区域和结构,新代码共享区域可能是在运行时私有的、写时复制的。它首先映射到一个共享的区域,hello这个程序与当前共享的对象libc.so链接,它可能是首先动态通过链接映射到这个代码共享程序上下文中的,然后再通过映射链接到用户虚拟地址和部分空间区域中的另一个共享代码区域内。为了设置一个新的程序计数器,execve函数要做的最后一件要做的事情就是自动设置当前代码共享进程上下文的一个程序计数器,使之成为指向所有代码共享区域的一个入口。 7.8缺页故障与缺页中断处理 段错误：首先判断这个缺页的虚拟地址是否合法，遍历所有的合法区域结构，如果对所有的区域结构都无法匹配，返回段错误。 非法访问：查看地址的权限，判断进程是否有读写权限。 若上述情况都不符合则为正常缺页，选择一个页面换入新的页面并更新到页表。 7.9动态存储分配管理 分配器通过维护虚拟内存（堆）来实现动态存储分配管理，存在两种维护方式： 隐式空闲链表：分配器检测一个已分配块何时不再被程序所使用,那么就释放这个块 显式空闲链表：每次声明内存空间都保证至少分配size_t大小的内存，双字对齐，每次必须从空闲块中分配空间，在申请空间时将空闲的空间碎片合并，以尽量减少浪费。 7.10本章小结 本章概括了进程的存储管理，介绍了了虚拟地址、物理地址、线性地址、逻辑地址的概念以及进程fork和execve的内存映射。描述了系统应对缺页异常的方法和malloc的内存分配管理机制。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 打开：open()，打开或创建目标文件。 关闭：close()，关闭文件。 读取：read()，从当前文件位置读取字节到内存中。 写入：write()，从内存复制字节到当前文件位置。 更改文件位置：lseek()，将文件位置更改为目标位置 8.3printf的实现分析 printf函数中调用了sprintf函数和write函数 sprintf函数将所有的参数内容格式化为字符串并存入buf，然后返回格式化数组长度。 write函数将buf中的元素写到终端。 vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量） 8.4getchar的实现分析 当buf为空时，getchar调用read函数，否则直接读取buf中的首元素。 read函数把整个缓冲区读到buf中，返回缓冲区长度。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章概括了Linux系统的IO管理，对IO相关函数进行了介绍和分析 （第8章1分） 结论 1.预处理源文件hello.c，将外部库合并并生成预处理文件hello.i 2.将hello.i编译为汇编语言文件hello.s 3.将汇编文件hello.s汇编为可重定位目标文件hello.o 4.将hello.o与动态链接库链接形成最终的hello可执行目标文件 5.在shell中输入命令运行目标文件hello 6.shell调用fork创建子进程 7.shell调用execve，为程序分配物理内存，映射虚拟内存，执行main函数 8.main函数执行程序命令，执行申请动态内存等操作 9.收到信号或运行完毕，程序终止，进程结束，内核回收该子进程 本次大作业是对本学习计算机系统学习内容的一次总结和回顾，运用到了课程各章节介绍的原理和方法，通过这门课我了解到计算机的底层实现原理非常重要，我们在编程中也应该更多考虑底层原理与问题，这样可以更深入地理解计算机系统 （结论0分，缺失-1分，根据内容酌情加分） 附件 1.hello.c：C语言源文件。 2.hello.i：预处理文本文件。 3.hello.s：汇编代码文件。 4.hello.o：可重定位目标文件。 5.hello：可执行目标文件。 6.hello.asm：由hello.o反汇编生成的汇编代码。 8.hello_o.asm：由hello反汇编生成的汇编代码文本。 7.hello.elf：hello.o的elf信息文本。 9.hello_o.elf：hello的elf信息文本。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1]Linux命令（65） ld命令.https://blog.csdn.net/K346K346/article/details/89088652 [2]分段和分页内存管理.https://blog.csdn.net/sinat_31135199/article/details/73605628 [3][转]printf函数实现的深入剖析.https://www.cnblogs.com/pianist/p/3315801.html [4]RandalE.Bryant,DavidR.O’Hallaron著，龚奕利，贺莲译深入理解计算机系统[M].北京：机械工业出版社，2016.7. （参考文献0分，缺失-1分） 

HIT计算机系统大作业 程序人生 计算机系统 大作业 计算机科学与技术学院 2021年6月 摘 要 底层实现在计算机领域至关重要，而在平时又难以直观感受，观察并研究hello.c程序在Linux环境下的底层编译、执行过程，了解汇编，链接，加载，执行等过程的概念和实现原理，对今后的学习非常有帮助 关键词：计算机系统；汇编语言；预处理；编译；汇编；链接；OS； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 1.P2P：ProgramtoProgress,文本格式的hello.c文件经过cpp的预处理生成hello.i预处理文件，之后交给ccl进行编译，生成hello.s汇编文件。再将汇编文件交给as生成可重定位文件hello.o，最后经由链接器ld，生成可执行文件hello，由上述过程生成可执行目标文件。 2.O2O：FromZreo-OtoZero-O。shell执行可执行目标文件，管理hello进程，对其进行存储管理，分配映射虚拟内存、分配物理内存，输出结果到显示器，最后结束hello进程，回收其内存空间。 1.2环境与工具 1.2.1硬件环境 Intel(R)Core(TM)i7-9750HCPU@2.60GHz；16GBRAM； 1.2.2软件环境 Windows1064位；VMware：Ubuntu20.04.2LTS64位VMware 1.2.3开发工具 Vim8.1.226964位；Visualstudio201964位；CodeBlocks20.0364位 1.3中间结果 1.hello.c：C语言源文件。 2.hello.i：预处理文本文件。 3.hello.s：汇编代码文件。 4.hello.o：可重定位目标文件。 5.hello：可执行目标文件。 6.hello.asm：由hello.o反汇编生成的汇编代码。 8.hello_o.asm：由hello反汇编生成的汇编代码文本。 7.hello.elf：hello.o的elf信息文本。 9.hello_o.elf：hello的elf信息文本。 1.4本章小结 解释了P2P和O2O的概念和过程，以及本次实验的实验环境即过程中的中间文件 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 概念：预处理器根据以字符#开头的命令，修改原始的C程序，如头文件、宏定义和条件编译。生成一个.i文本文件。 作用：预处理器加入头文件、执行宏替换和条件编译。再进行正式的编译工作，便于编译的高效进行。 2.2在Ubuntu下预处理的命令 图2-1 图1-2 2.3Hello的预处理结果解析 源文件hello.c内容如下 图2-3 预处理文件hello.i内容如下 图2-4 可以看到预处理文件比源文件多出几千行，其内容为对头文件的引入： 图2-5 其中描述了各运行库在计算机中的位置： 图2-6 声明了其中用到的函数名： 图2-7 2.4本章小结 本章介绍了预处理的概念和作用，将hello.c预处理为hello.i，并对预处理结果进行了分析。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译器将预处理文本文件hello.i翻译成汇编语言文本文件hello.s，该文件用汇编语言描述了程序的内容 作用：经过词法分析，语法分析，语义分析，和一定的优化来生成可以实现对应程序功能的汇编代码文件，与高级语言相比，汇编语言更接近计算机能够理解的语言，进一步有利于二进制机器语言的生成。 3.2在Ubuntu下编译的命令 图3-1 图3-2 3.3Hello的编译结果解析 生成的hello.s文件内容如下： 图3-3 3.3.1变量的处理 全局变量：源文件中声明了全局变量sleepsecs，在汇编语言中它存放在了.data区域 图3-4 局部变量：源文件中声明了局部变量i（int类型），局部变量不在数据段表现，观察汇编文件的代码段： 图3-5 可发现源文件中的变量i作为循环条件存在，而汇编代码中参与循环判断的是-4(%rbp)，故i的值存放在该位置 图3-6 3.3.2赋值、算数操作及条件判断与跳转 赋值操作： 该步对应了源代码中i=0的操作 算数操作： 该步对应源代码中i++ 条件判断与跳转： 该步对应了源代码中判断i<10，带汇编语言中表现为判断i是否小于等于9，若是则跳转到循环内部（.L4） 3.3.3函数调用 汇编语言中用call指令实现函数调用的操作 3.3.4数组、指针 该步对应了源代码中对argv[]数组的操作，汇编代码中对数组的实现表示为对数组头加上偏移量的形式实现 3.4本章小结 本章将预处理的文本文件编译为汇编语言表示的.s文件，用以后续生成过程，并对程序中出现的汇编代码进行了解析，使其与源代码中的命令对应 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：把汇编语言翻译成机器语言的过程，形成可重定位目标文件。作用：把汇编语言一一对应地翻译成机器可以理解并直接执行的机器指令。 4.2在Ubuntu下汇编的命令 图4-1 图4-8 4.3可重定位目标elf格式 ELF头：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。 节头：指明各个节的名称、类型、起始地址和偏移量 重定位节： 重定位节记录了程序的偏移信息，使程序可以在链接后正确生成可执行文件 4.4Hello.o的结果解析 图4-9 对比反汇编结果与hello.s可知二者不同： hello.s中分支跳转语句通过跳转到目标节.L3/.L4等来表示，而反汇编文件则通过直接跳转到对应目标地址来实现分支跳转hello.s中函数调用通过call对应函数名实现，而反汇编文件通过call对应函数所在地址来实现hello.s中可以通过直接访问数据段来访问全局变量，而反汇编文件中数据段位置不确定，故需要借助重定位信息进行访问 4.5本章小结 本章将汇编语言文件汇编为可重定位目标文件hello.c，并查看了elf头，分析了elf头中各节的作用，并通过反汇编了解了机器语言的底层实现 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：链接器把多个可重定位文件链接成一个完整的可执行文件。 作用：链接可以在编译、汇编、加载和运行时执行。链接方便了模块化编程。 5.2在Ubuntu下链接的命令 图5-1 图5-2 图5-3 5.3可执行目标文件hello的格式 elf头： 节头： 程序头：在hello_o.elf中没有这部分内容 重定位节: 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明 init:0x00401000 .text:0x004010d0 5.5链接的重定位过程分析 hello.asm中多出的段包括： .interp：保存ld.so的路径 .note.ABI-tag .note.gnu.build-i：编译信息表 .gnu.hash：gnu的扩展符号hash表 .dynsym：动态符号表 .dynstr：动态符号表中的符号名称 .gnu.version：符号版本 .gnu.version_r：符号引用版本 .rela.dyn：动态重定位表 .rela.plt：.plt节的重定位条目 .init：程序初始化 .plt：动态链接表 .fini：程序终止时需要的执行的指令 .eh_frame：程序执行错误时的指令 .dynamic：存放被ld.so使用的动态链接信息 .got：存放程序中变量全局偏移量 .got.plt：存放程序中函数的全局偏移量 .data：初始化过的全局变量或者声明过的函数 5.6hello的执行流程 加载程序： ld-2.27.so!_dl_start ld-2.27.so!_dl_init hello!_start callmain： libc-2.27.so!__libc_start_main hello!main hello!puts@pl 终止： exit 5.7Hello的动态链接分析 由elf文件可知.got.plt的地址 图5-8 使用edb查看运行前GOTPLT表的内容 图5-9 运行dl_start和dl_init后GOTPLT表内容发生变化 图5-10 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 5.8本章小结 本章通过链接成功生成了可执行的目标文件，并介绍了动态链接库等内容 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：进程的经典定义就是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量、以及打开文件描述符的集合。 作用：进程给应用程序提供的关键抽象有两种： a)一个独立的逻辑控制流，提供一个假象，程序独占地使用处理器。 b)一个私有的地址空间，提供一个假象，程序在独占地使用系统内存。 6.2简述壳Shell-bash的作用与处理流程 shell是用户与系统交互作用界面。Shell是一个命令解释程序，也是一种程序设计语言。 1.读入命令行、注册相应的信号处理程序、初始化进程组。 2.通过paraseline函数解释命令行，如果是内置命令则直接执行，否则阻塞信号后创建相应子进程，在子进程中解除阻塞，将子进程单独设置为一个进程组，在新的进程组中执行子进程。父进程中增加作业后解除阻塞。如果是前台作业则等待其变为非前台程序，如果是后台程序则打印作业信息。 6.3Hello的fork进程创建过程 intfork(void)函数： 子进程返回0，父进程返回子进程的PID 新创建的子进程几乎但不完全与父进程相同： 子进程得到与父进程虚拟地址空间相同的（但是独立的）一份副本。 子进程获得与父进程任何打开文件描述符相同的副本。 子进程有不同于父进程的PID fork()调用一次，返回两次。 在shell中如果fork返回值小于0，说明fork时出现了一些问题这时需要进行处理。否则就成功创建了子进程。 6.4Hello的execve过程 调用fork函数之后，子进程将会调用execve函数，来运行hello程序，如果成功调用则不再返回，若未成功调用则返回-1。 完整的加载运行hello程序需要以下几个步骤 首先加载器会删除当前子进程虚拟地址端。，然后创建一组新的代码、数据、堆端，并初始化为0。 接着映射私有区域和共享区域，将新的代码和数据段初始化为可执行文件中的内容 最后设置程序计数器，使其指向代码区的入口，下一次调度这个进程时，将直接从入口点开始执行 6.5Hello的进程执行 Linux系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制。子进程通过execve系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片(chunk),新的代码和数据段袚初始化为可执行文件的内容。最后，加载器跳转到_start地址，它最终会调用应用程序的main函数。 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 6.6hello的异常与信号处理 1.可能出现的异常 中断：来自I/O设备的信号。比如输入CTRL-C或者CTRL-Z 陷阱：有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。 故障是由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。 终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程序会将控制返回给一个abort例程，该例程会终止这个应用程序。 2.可能产生的信号：SIGINT,SIGSTP,SIGCONT,SIGWINCH等 3．异常处理：3.1:运行过程中按CTRL-C，给进程发送SIGINT信号，程序将被终止回收 图6-1 3.2：运行过程中按CTRL-Z，给进程发送SIGSTP信号，程序将被挂起，用fg命令，可以让程序回到前台继续运行。 图6-2 3.3：挂起中输入pstree时 图6-3 6.7本章小结 本章完成了程序从运行到结束的运行过程，体现了hello的进程管理 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：由程序产生的与段相关的偏移地址部分。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。 线性地址：地址空间中的整数是连续的。 虚拟地址：在一个带虚拟内存的系统中，CPU从一个有N=2"个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间。 物理地址：计算机系统的主存被组织成一个个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。 在hello加载进内存时会分配虚拟内存，总是从0x00401000开始 7.2Intel逻辑地址到线性地址的变换-段式管理 每个段的首地址就会被储存在各自的段描述符里面,所以的段描述符都将会位于段全局描述符表中(每个段的全局描述符表一个局部称为gdgdt和另一个局部的的段描述符表一个局部称为ldldt),通过段选择符我们可以快速寻找到某个段的段全局描述符。逻辑上段地址的偏移量结构就是段选择符+偏移量。 段选择符的索引位组成和定义如下,分别指的是索引位,ti,rpl,当索引位ti=0时,段描述符表在rpgdt中,ti=1时,段描述符表在rpldt中。而索引位index就类似一个数组,每个元素内都存放一个段的描述符,索引位首地址就是我们在查找段描述符时再这个元素数组当中的索引。一个段描述符的首地址是指含有8个元素的字节,我们通常可以在查找到段描述符之后获取段的首地址,再把它与线性逻辑地址的偏移量进行相加就可以得到段所需要的一个线性逻辑地址。 在分段保护模式下,分段有两种机制:段的选择符在段的描述符表->分段索引->目标段的段描述符条目->目标段的描述符基地址+偏移量=转换为线性段的基地址。由于现代的macosx86系统内核使用的描述符是基本扁平的逻辑模型,即目标段的逻辑地址=线性段的描述符=转换为线性段的基地址,等价于描述符转换为线性地址时关闭了偏移量和分段的功能。这样逻辑段的基地址与转换为线性段的基地址就合二为一了。 7.3Hello的线性地址到物理地址的变换-页式管理 系统将每个段分割为被称为虚拟页（VP）的大小固定的块来作为进行数据传输的单元，在linux下每个虚拟页大小为4KB，类似地，物理内存也被分割为物理页（PP/页帧），虚拟内存系统中MMU负责地址翻译，MMU使用存放在物理内存中的被称为页表的数据结构将虚拟页到物理页的映射，即虚拟地址到物理地址的映射。 7.4TLB与四级页表支持下的VA到PA的变换 将VPN分成三段，对于TLBT和TLBI来说，可以在TLB中找到对应的PPN，但是有可能出现缺页的情况，这时候就需要到页表中去找。此时，VPN被分成了更多段（这里是4段）CR3是对应的L1PT的物理地址，然后一步步递进往下寻址，越往下一层每个条目对应的区域越小，寻址越细致，在经过4层寻址之后找到相应的PPN让你和和VPO拼接起来。 7.5三级Cache支持下的物理内存访问 得到物理地址之后，先将物理地址拆分成CT（标记）+CI（索引）+CO（偏移量），然后在一级cache内部找，如果未能寻找到标记位为有效的字节（miss）的话就去二级和三级cache中寻找对应的字节，找到之后返回结果。 7.6hello进程fork时的内存映射 shell通过一个调用fork的函数让进程内核自动创建一个新的进程,这个新的进程拥有各自新的数据结构,并且被内核分配了一个唯一的pid。它有着自己独立的虚拟内存空间,并且还拥有自己独立的逻辑控制流,它同样可以拥有当前已经可以打开的各类文件信息和页表的原始数据和样本,为了有效保护进程的私有数据和信息,同时为了节省对内存的消耗,进程的每个数据区域都被内核标记起来作为写时复制。 7.7hello进程execve时的内存映射 execve函数在当前代码共享进程的上下文中加载并自动运行一个新的代码共享程序,它可能会自动覆盖当前进程的所有虚拟地址和空间,删除当前进程虚拟地址的所有用户虚拟和部分空间中的已存在的代码共享区域和结构,但没有自动创建一个新的代码共享进程。新的运行程序仍然在堆栈中拥有相同的区域pid。之后为新运行程序的用户共享代码、数据、bss和所有堆栈的区域结构创建新的共享区域和结构,新代码共享区域可能是在运行时私有的、写时复制的。它首先映射到一个共享的区域,hello这个程序与当前共享的对象libc.so链接,它可能是首先动态通过链接映射到这个代码共享程序上下文中的,然后再通过映射链接到用户虚拟地址和部分空间区域中的另一个共享代码区域内。为了设置一个新的程序计数器,execve函数要做的最后一件要做的事情就是自动设置当前代码共享进程上下文的一个程序计数器,使之成为指向所有代码共享区域的一个入口。 7.8缺页故障与缺页中断处理 段错误：首先判断这个缺页的虚拟地址是否合法，遍历所有的合法区域结构，如果对所有的区域结构都无法匹配，返回段错误。 非法访问：查看地址的权限，判断进程是否有读写权限。 若上述情况都不符合则为正常缺页，选择一个页面换入新的页面并更新到页表。 7.9动态存储分配管理 分配器通过维护虚拟内存（堆）来实现动态存储分配管理，存在两种维护方式： 隐式空闲链表：分配器检测一个已分配块何时不再被程序所使用,那么就释放这个块 显式空闲链表：每次声明内存空间都保证至少分配size_t大小的内存，双字对齐，每次必须从空闲块中分配空间，在申请空间时将空闲的空间碎片合并，以尽量减少浪费。 7.10本章小结 本章概括了进程的存储管理，介绍了了虚拟地址、物理地址、线性地址、逻辑地址的概念以及进程fork和execve的内存映射。描述了系统应对缺页异常的方法和malloc的内存分配管理机制。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 打开：open()，打开或创建目标文件。 关闭：close()，关闭文件。 读取：read()，从当前文件位置读取字节到内存中。 写入：write()，从内存复制字节到当前文件位置。 更改文件位置：lseek()，将文件位置更改为目标位置 8.3printf的实现分析 printf函数中调用了sprintf函数和write函数 sprintf函数将所有的参数内容格式化为字符串并存入buf，然后返回格式化数组长度。 write函数将buf中的元素写到终端。 vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量） 8.4getchar的实现分析 当buf为空时，getchar调用read函数，否则直接读取buf中的首元素。 read函数把整个缓冲区读到buf中，返回缓冲区长度。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章概括了Linux系统的IO管理，对IO相关函数进行了介绍和分析 （第8章1分） 结论 1.预处理源文件hello.c，将外部库合并并生成预处理文件hello.i 2.将hello.i编译为汇编语言文件hello.s 3.将汇编文件hello.s汇编为可重定位目标文件hello.o 4.将hello.o与动态链接库链接形成最终的hello可执行目标文件 5.在shell中输入命令运行目标文件hello 6.shell调用fork创建子进程 7.shell调用execve，为程序分配物理内存，映射虚拟内存，执行main函数 8.main函数执行程序命令，执行申请动态内存等操作 9.收到信号或运行完毕，程序终止，进程结束，内核回收该子进程 本次大作业是对本学习计算机系统学习内容的一次总结和回顾，运用到了课程各章节介绍的原理和方法，通过这门课我了解到计算机的底层实现原理非常重要，我们在编程中也应该更多考虑底层原理与问题，这样可以更深入地理解计算机系统 （结论0分，缺失-1分，根据内容酌情加分） 附件 1.hello.c：C语言源文件。 2.hello.i：预处理文本文件。 3.hello.s：汇编代码文件。 4.hello.o：可重定位目标文件。 5.hello：可执行目标文件。 6.hello.asm：由hello.o反汇编生成的汇编代码。 8.hello_o.asm：由hello反汇编生成的汇编代码文本。 7.hello.elf：hello.o的elf信息文本。 9.hello_o.elf：hello的elf信息文本。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 

信息安全概论复习笔记 目录 1.信息安全体系架构 2.密码体制的五要素 3.仿射密码 4.数据加密标准DES的算法结构和特点 5.公钥密码的思想（数学描述） 6.离散对数问题 7.Diffie-Hellman密钥交换协议 8.RSA公钥算法 9.散列函数的特点和作用 10.EMI、EMC、防电磁泄漏主要方法 11.容错与容灾的概念及主要技术方法 12.windows的网络认证 13.利用公开密钥和对称密钥设计认证协议获得会话密钥 14.Kerberos工作原理 15.PKI的体系结构及工作原理 16.访问控制的概念 17.DAC、MAC、RBAC的工作原理及特点 18.Windows安全体系结构、活动目录与组策略 19.传统病毒、蠕虫、木马的结构原理 20.拒绝服务攻击、缓冲区溢出、举例 21.防火墙主要技术概述 22.Netfilter／iptables的工作原理 23.基于网络和基于主机的入侵检测系统的优缺点 24.snorts的工作原理 25.IPSEC协议的体系结构 26.传输方式和隧道方式的区别 27.SSL握手协议 28.双签名技术原理（DS） 29.DRM结构原理 30.数字水印的工作原理 31.cc与bs7799的区别 32.风险评估的主要方法 33.网络安全法（非教材） 34.等级保护2.0（非教材） 35.工程伦理道德 1.信息安全体系架构 面向目标的知识体系结构：CIA三元组（机密性，完整性，可用性） 面向应用的层次型技术体系架构：人员（管理安全），信息（内容安全，数据安全），系统（运行安全，物理安全） 面向过程的信息安全保障体系：PDRR（保护，检测，反应，恢复） OSI开放系统互连安全体系结构：安全服务（鉴别服务，访问控制，数据完整性，数据机密性，抗抵赖性），安全机制（加密，数字签名，访问控制，数据完整性，鉴别交换，业务流填充，路由控制，公证），OSI参考模型（物理层，链路层，网络层，传输层，会话层，表示层，应用层） 2.密码体制的五要素 M,C,K,E,D M可能明文的有限集，称为明文空间 C可能密文的有限集，称为密文空间 K是一切可能密钥构成的有限集，称为密钥空间 E为加密算法，对于密钥空间的任一密钥加密算法都能够有效的计算 D为解密算法，对于密钥空间的任一密钥解密算法都能够有效的计算 3.仿射密码 加密变换Ek(m)=(k1m+k2)modq 密钥(k1,k2)k1,k2∈{0,q},且k1和q是互素的。 解密算法Dk(c)=k1-1(c-k2)modq 例题 4.数据加密标准DES的算法结构和特点 DES是一种对二进制数据进行分组加密的算法，它以64位为分组对数据，DES的密钥也是长度为64位的二进制数，其中有效位数为56位（因为每个字节第8位都用作奇偶校验），加密算法与解密算法很相似，唯一的区别在于子密钥的使用顺序正好相反。DES的整个密码体制是公开的，系统的安全性完全依赖于密钥的保密性。 DES的算法的过程是在一个初始置换IP后，明文组被分成左半部分和右半部分，输入到复合函数fk中，重复16轮迭代变换，将数据与密钥结合起来。16轮后，左，右两部分在连接起来，经过一个初始逆置换IP-1算法结束。在密钥的使用上，将64位密钥中的56位有效位经过循环位移和置换产生16个子密钥，用于16轮复合函数fk的变换。 5.公钥密码的思想（数学描述） 如果函数f(x)被称为单向陷门函数，必须满足以下三个条件。 给定x，计算y=f(x)是容易的 给定y，计算x使y=f(x)是困难的（所谓计算x=f-1(y)困难是指计算上相当复杂，已经无实际意义） 存在σ，已知σ时对给定的任何y，若相应的x存在，则计算x使y=f(x)是很容易的。 6.离散对数问题 若a是素数p的一个原根，则相对于任意整数b(bmodp!=0),必然存在唯一的整数i（1<=i<=p-1），使得b=aimodp,i称为b的以a为基数且模p的幂指数，及离散对数。 7.Diffie-Hellman密钥交换协议 Alice和Bobby协商好一个大的素数p和大的整数g，1<g<p，g是p的原根。P和g无须保密，可为网络上的所有用户共享。当Alice和Bob要进行信息保密通信时，它们可以按照如下步骤来做。 Alice选取大的随机数x<p,并计算Y=gx(modP)Bob选取大的随机数x’=gx’(modP)Alice将Y传送给Bob，Bob将Y’传送给AliceAlice计算K=(Y’)X(modP),Bob计算K’=(Y)x’(modP) 此时K=K’=gxx’(modP)，即Alice和Bob已经获得了相同的秘密值K。双方以K作为加解密钥，以传统对称密钥算法进行保密通信。 8.RSA公钥算法 RSA密钥生成步骤： 选择两个互异的素数p和q，计算n=pq,ϑ(n)=(p-1)(q-1)。选择整数e，使gcd(ϑ(n),e)=1,且1<e<ϑ(n).计算d，使d==e-1modϑ(n),即d为模ϑ(n)下e的乘法逆元。 则公开密钥Pk={e,n}，私用密钥Sk={d,n,p,q}。当明文是m，密文为c，加密时使用公开密钥Pk，加密算法c=memodn;解密时使用私用密钥Sk，m=cdmodn。故e也称为加密指数，d被称为解密指数。 9.散列函数的特点和作用 散列函数的目的是将任意长的消息映射成一个固定长度的散列值（Hash值），也称为消息摘要。消息摘要可以作为认证符，完成消息认证。 如果使用消息摘要作为认证符，必须要求散列函数具有健壮性，可以抵抗各种攻击，使消息摘要可以代表消息原文。当消息原文产生改变时，使用散列函数求得的消息摘要必须相应的变化，这就要求散列函数具有无碰撞特性和单向性。 弱无碰撞性：散列函数h被称为是弱无碰撞的，是指在消息特定的明文空间X中，给定消息x∈X，在计算机上几乎找不到不同于x的x’，x’∈X,使得h(x)=h’(x). 强无碰撞特性：散列函数h被称为是强无碰撞的，是指计算机上难以找到与x相异的x’，满足h(x)=h’(x)，x’可以不属于X。 单向性：散列函数h被称为单向的，是指通过h的逆函数h-1来求得散列值h(x)的信息原文，在计算上不可行。 10.EMI、EMC、防电磁泄漏主要方法 电磁干扰（EMI）指一切与有用信号无关的，不希望有的或对电器即电子设备产生不良影响的电池发射。防止EMI可以从两个方面考虑，一方面要减少电子设备的电磁发射，另一方面要提高电子设备的电磁兼容性（EMC）。电磁兼容性是指电子设备在自己正常工作时产生的电磁环境，与其他电子设备之间互相不影响的电磁特性。防电磁泄漏的方法：屏蔽法，频域法，时域法。 11.容错与容灾的概念及主要技术方法 容错的基本思想是即使出现了错误，系统也可以执行一组规定的程序；或者说，程序不会因为系统中的故障而中断或被修改，并且故障也不会引起运行结果的差错。简单地说，容错就是让系统具有抵抗错误带来的能力。 容灾是针对灾害而言的。是对偶然事故的预防与恢复。 空闲设备 镜像 复现 负载均衡 12.windows的网络认证 采用对称密钥加密来完成的。每一个试图登录windows网络的用户必须是已经在主域控制器上进行了有效注册的合法用户，用户与主域控制器共享口令，在域控制器的安全用户管理数据库中保存注册用户的用户名，口令的散列即其他信息。 用户首先激活Winlogon窗口，并输入用户名与口令，然后向域控制器发送登录请求，同时计算出口令的散列，口令及其散列不包含在登录请求信息中。域控制器收到登录请求后产生一个8字节的质询并发送给客户端，同时取出给用户的口令散列，用此口令散列对质询进行散列计算，得到质询散列。客户端收到8字节的质询后，首先使用前边计算得到的口令散列对质询进行散列计算，得到质询散列，随后将计算出的质询散列作为应答发送给域控制器。域控制器对比其计算出的质询散列和用户应答回送的质询散列，如果系统则登录认证通过，否则登录认证失败，同时向用户发送登录验证结果。 13.利用公开密钥和对称密钥设计认证协议获得会话密钥 对称密钥：挑战 应答A->B:IDa|IDbB->A:NbA->B:Ek(Nb) 公开密钥:不会A->B:EKub[IDa||Ra]B->A:EKua[Ra||Rb]A->B:EKub[Rb] 14.Kerberos工作原理 第三方认证服务，通过传统的共享密码技术来执行认证服务，每个用户或应用服务器均与Kerberos分享一个对称密钥。Kerberos由两个部分构成，分别是AS和TGS。Kerberos提供的认证服务，允许一个用户通过交换加密消息在整个网络上与另一个用户或应用服务器互相证明身份，一旦身份得以认证，Kerberos向通信双方提供对称密钥，对方进行安全通信对话。在Kerberos体系中，票据Ticket是客户端访问服务器时，提交的用于证明自己的身份，并可传递通信会话密钥的认证资料。AS负责签发访问TGS服务器的票据，TGS负责签发访问其他应用服务器的票据。 身份验证服务交换：完成身份验证，获得访问TGS的票据。 票据授予服务交换：获得访问应用服务器的数据。 客户与服务器身份验证交换：获得服务 15.PKI的体系结构及工作原理 利用公钥理论和技术建立的提供安全服务的基础设施，PKI采用数字证书技术来管理公钥，通过第三方的可信任机构 CA认证中心把用户的公钥和用户的其他标识消息绑在一起，在互联网上验证用户的身份。中心位置为核心技术，即公钥算法和数字证书技术，再次技术的基础上实现的PKI平台包括四个基本功能模块和一个应用接口模块。 认证机构CA 证书库 密钥备份即恢复 证书撤销处理 PKI应用接口 16.访问控制的概念 访问控制技术就是用来管理用户对系统资源的访问，对提高信息系统的安全性起到至关重要的作用。针对越权使用资源的防御措施，从而使系统资源在合法的范围内使用。 17.DAC、MAC、RBAC的工作原理及特点 自主访问控制模型（DAC）允许合法用户以用户或用户组的身份来访问系统控制策略许可的客体，同时阻止非授权用户访问客体，某些用户还可以自主的把自己所拥有的客体的访问权限授予其他用户。访问控制表，访问控制能力表，访问控制矩阵。 强制访问控制（MAC）是一种多级访问控制策略，系统事先给访问主体和受控客体分配不同的安全级别属性，在实施访问控制时，系统先对访问主体和受控客体的安全级别属性进行比较，在决定访问主体是否访问该受控客体。向下读，向上读，向下写，向上写。 基于角色的访问控制（RBAC）将访问权限分配给一定的角色，用户通过饰演不同的角色获得角色所拥有的访问许可权。最小特权原则，最小泄露原则，多级安全策略。 18.Windows安全体系结构、活动目录与组策略 Windows系统采用的是层次性的安全架构，整个安全架构的核心是安全策略，完整的安全策略决定了系统的安全性。安全策略明确了系统各个安全组件如何协调工作，Windows系统安全开始于用户认证，他是其他安全机制能够有效实施的基础，处于安全构架的最外层，加密和访问控制处于用户认证之后，是保证系统安全的主要手段，加密保证了系统与用户之间的通信即数据存储的机密性；访问控制则维护了用户访问的授权原则。审计和管理处于系统的内核层，负责系统的安全配置和事故处理，审计可以发现系统是否曾经遭受过攻击或者正在遭受灾难，并进行追查；管理则是为用户有效控制系统提供功能接口。 活动目录（AD）目录服务，它存储了有关网络对象的信息，并让管理员和用户能够轻松的查找和使用这些信息。功能基于目录的用户和资源管理，基于目录的网络服务，基于网络的应用管理。 组策略（GP）依据特定用户或计算机的安全需求制定的安全配置规则。 19.传统病毒、蠕虫、木马的结构原理 传统病毒三个模块，启动模块，传染模块，破坏模块。当系统执行力感染病毒的文件时，病毒的启动模块开始驻留在系统内存中。传染模块和破坏模块的发作均为条件触发，当满足了条件，病毒开始传染别的文件或破坏系统。 蠕虫病毒不需要寄生在宿主文件中，传播途径以计算机为载体，以网络为攻击对象，利用漏洞。主体驻留模块，传播模块。 木马是有隐藏性的，传播性的，可用来进行恶意行为的程序。一般不会对计算机产生危害，主要以控制计算机为目的。三部分，客户端，黑客用来控制远程计算机的木马程序；服务器端，是木马的核心，是潜入被感染的计算机内部，获取其操作权限的程序；木马配置程序，伪装隐藏木马程序，并确定反馈信息的传输路径。 20.拒绝服务攻击、缓冲区溢出、举例 拒绝服务攻击所表现出来的结果最终使得目标系统因遭受某种程度的破坏而不能提供正常的服务，导致物理上的瘫痪或崩溃。PingofDeath，Smurf，Teardrop，SynFlood，电子邮件炸弹。 缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖了合法数据。 21.防火墙主要技术概述 ACL：一系列允许和拒绝匹配规则的集合，利用这些规则来告诉防火墙那些数据包允许通过，那些数据包被拒绝。 静态包过滤：防火墙根据定义好的包过滤规则审查每个数据包，以便确定其是否与某一条包过滤规则匹配。 动态包过滤：采用动态配置包过滤规则的方法。 应用代理网关： 电路级网关： NAT：私有地址->合法IP地址的技术 VPN：通过公用网络建立一个临时的，安全的连接。 22.Netfilter／iptables的工作原理 设计思想是采用两层结构，处于内核层的Netfilter组件是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤的规则集。Iptables组件位于用户层，是一种管理包过滤规则的规则，可以完成插入，修改和删除包过滤的规则。 23.基于网络和基于主机的入侵检测系统的优缺点 基于主机的入侵检测系统优点：性价比高，不需要增加专门的硬件平台，当主机数量较少时性价比尤其突出；准确率高，主要监测用户在系统中的行为活动，这些行为能够准确的反映系统实时的状态，便于区分正常的行为和非法行为；对网络流量不敏感，不会因为网络流量的增加而丢掉对网络行为的监视；适合加密环境下的入侵检测。缺点：与操作系统平台相关，可移植性差；需要在每个被检测主机上安装入侵检测系统，维护比较复杂；难以检测针对网络的攻击。 基于网络的入侵检测系统优点：对用户透明，隐蔽性好，使用便捷，不容易遭受来自网络上的攻击；与被检测的系统平台无关；利用独立的计算机完成检测工作，不会给运行关键业务的主机带来负载上的增加；攻击者不易转移证据。缺点：无法检测到来自网络内部的攻击及内部合法用户的误用行为；无法分析所传输的加密数据报文；需要对所有的网络报文进行采集分析，主机的负荷比较大，且易受DoS攻击。 24.snorts的工作原理 一种网络入侵检测系统，包括数据包捕获模块，预处理模块，检测引擎和输出模块四部分。数据包捕获模块，将数据包从网络适配器中以原始状态捕获，并提交给预处理模块；预处理程序对数据包进行解码，检查及相关处理后将它们交给检测引擎；检测引擎对每个包进行检验以判断是否存在入侵；最后输出模块根据检测引擎的结果给出相应的输出，即写日志或报警。 25.IPSEC协议的体系结构 包括两个基本协议，分别封装安全有效负荷协议（ESP）和认证头协议（AH）。这两个协议的有效工作依赖于四个要件，分别为加密算法，认证算法，解释域以及密钥管理。 26.传输方式和隧道方式的区别 在传输模式下，AH和ESP主要对上一层的协议提供保护，只对IP数据包的有效负载进行加密或认证，继续使用之前的IP头部，只对IP头部的部分域进行修改，而IPSec协议头部插入到IP头部和传输层头部之间；在隧道模式下，AH和ESP则用于封装整个IP数据报文，对整个IP数据包进行加密或认证，此时需要产生新的IP头部，IPSec头部被放置在新产生的IP头部和以前的IP数据包之间，从而组成一个新的IP头部。 27.SSL握手协议 报文格式：类型（1），长度（3），内容（>=1） 通过在客户端和服务器之间传递消息报文，完成协商谈判。 四个阶段：建立起安全能力；服务器认证与密钥交换；客户端认证与密钥交换；结束； 28.双签名技术原理（DS） 将OI与PI这两个部分的摘要绑定在一起，确保交易的有效性与安全性。同时分离OI与PI，确保商家不知道顾客的支付卡信息，银行不知道顾客的订购细节。 29.DRM结构原理 分为服务器和客户端两个部分。服务器主要功能是管理版权文件的分发与授权。客户端的主要功能是依据受版权保护文件提供的信息申请授权许可证，并依据授权许可信息解密受保护文件，提供给客户使用。 30.数字水印的工作原理 一般包括三个基本方面：水印的形成，水印的嵌入和水印的检测。水印的形成是指选择有意义的数据，以特定的方式形成水印信息。水印的嵌入分为输入，嵌入处理与输出三部分，输入包括原始宿主文件，水印信息与密码；嵌入处理的主要任务是对原始文件进行分析选择嵌入点，将水印信息以一种特定的方式嵌入到一个或多个嵌入点，在整个过程中可能需要密码参与。输出是指将处理的数据整理为带有水印的信息文件。水印的检测分为两个工作，分别为检测水印是否存在（盲水印检测和非盲水印检测）和提取水印信息。 31.cc与bs7799的区别 cc是目前最全面的评价准则，充分突出了“保护轮廓”的概念，侧重点放在系统和产品的技术指标评价上。Bs7799采用层次化形式定义了11个安全管理要素，还给出了39个主要执行目标和133个具体控制措施，明确了组织机构信息安全管理建设的内容。 32.风险评估的主要方法 基线评估 详细评估 组合评估 33.网络安全法（非教材） 2016年11月7日通过 2017年6月1日起施行 34.等级保护2.0（非教材） 2019年5月13日，网络安全等级保护制度2.0标准正式发布，同时这些标准将于12月1日正式实施，我国迈入2.0时代。 35.工程伦理道德 要有工程伦理道德 

程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机 学 号 班 级 学 生 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文就hello.c文件为研究对象，通过分析从hello.c到可执行文件hello，再到运行该可执行文件到该文件结束运行的一系列过程，了解计算机系统的相应知识。 关键词：计算机系统；程序一生； 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -6- 2.1预处理的概念与作用 -6- 2.2在Ubuntu下预处理的命令 -6- 2.3Hello的预处理结果解析 -6- 2.4本章小结 -7- 第3章编译 -8- 3.1编译的概念与作用 -8- 3.2在Ubuntu下编译的命令 -8- 3.3Hello的编译结果解析 -8- 3.4本章小结 -11- 第4章汇编 -12- 4.1汇编的概念与作用 -12- 4.2在Ubuntu下汇编的命令 -12- 4.3可重定位目标elf格式 -12- 4.4Hello.o的结果解析 -14- 4.5本章小结 -14- 第5章链接 -15- 5.1链接的概念与作用 -15- 5.2在Ubuntu下链接的命令 -15- 5.3可执行目标文件hello的格式 -15- 5.4hello的虚拟地址空间 -18- 5.5链接的重定位过程分析 -20- 5.6hello的执行流程 -21- 5.7Hello的动态链接分析 -22- 5.8本章小结 -23- 第6章hello进程管理 -24- 6.1进程的概念与作用 -24- 6.2简述壳Shell-bash的作用与处理流程 -24- 6.3Hello的fork进程创建过程 -24- 6.4Hello的execve过程 -25- 6.5Hello的进程执行 -25- 6.6hello的异常与信号处理 -26- 6.7本章小结 -27- 第7章hello的存储管理 -28- 7.1hello的存储器地址空间 -28- 7.2Intel逻辑地址到线性地址的变换-段式管理 -28- 7.3Hello的线性地址到物理地址的变换-页式管理 -28- 7.4TLB与四级页表支持下的VA到PA的变换 -29- 7.5三级Cache支持下的物理内存访问 -31- 7.6hello进程fork时的内存映射 -32- 7.7hello进程execve时的内存映射 -32- 7.8缺页故障与缺页中断处理 -33- 7.9动态存储分配管理 -36- 7.10本章小结 -37- 第8章hello的IO管理 -38- 8.1Linux的IO设备管理方法 -38- 8.2简述UnixIO接口及其函数 -39- 8.3printf的实现分析 -39- 8.4getchar的实现分析 -39- 8.5本章小结 -40- 结论 -40- 附件 -41- 参考文献 -42- 第1章概述 1.1Hello简介 P2P：用C语言写出hello.c文件（Program），经过预处理器（ccp），编译器（ccl），汇编器（as）的预处理编译汇编分别生成.i，.s，.o文件，最后经过链接器链接可执行文件。在Bash中，进程管理（OS）利用fork生成子程序（Process）。 020：在输入hello的运行命令后，shell利用fork生成子进程，再利用execve加载。经历访存，内存分配等进程结束后被回收。 1.2环境与工具 软件：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位。 硬件：X64CPU；2GHz；2GRAM；256GHDDisk以上 开发及调试工具：Codeblocksgcccppedb 1.3中间结果 文件名字描述hello.i修改了的源程序(文本）hello.s汇编程序(文本）hello.o可重定位目标程序(二进制）hello.txthello.o的ELF格式objdump.txthello.o的反汇编文件hello可执行目标文件helloelf.txthello的ELF格式diff.txt分析hello与hello.o的不同的文本文件。 1.4本章小结 通过第一章的描述，使我们了解了在整个研究过程中，hello的FromProgramtoProcess与FromZero-0toZero-0的基本过程。还了解了本次研究所需要的硬件软件与开发调试工具和本次研究的中间结果，让我们对本次研究有了基本的了解。 第2章预处理 2.1预处理的概念与作用 2.1.1预处理的概念 预处理阶段。预处理器（CPP)根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件扩展名。 2.1.2预处理的作用 扩展源代码，插人所有用include命令指定的文件，并扩展所有声明指定的宏。 2.2在Ubuntu下预处理的命令 预处理命令：cpphello.c>hello.i生成.i文件。 2.3Hello的预处理结果解析 .i文件： 生成了三千余行的文本文件，将所有用include命令指定的文件与所有声明指定的宏插入。 例如在.i文件中插入的stdio.h头文件中的一部分。 该部分在stdio.h头文件中也存在。 文件最后的部分与.c文件相同。 2.4本章小结 本章就预处理操作，使我了解了预处理的概念与作用，预处理的命令与预处理结果。 第3章编译 3.1编译的概念与作用 3.1.1编译的概念 编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。 3.1.2编译的作用 编译是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。 3.2在Ubuntu下编译的命令 gcc-Shello.c-ohello.s生成.s文件 3.3Hello的编译结果解析 3.3.1编译结果 .s文件： 3.3.2数据 常量： 字符串常量存储在.text段中 例如代码中的printf中的两个字符串。 变量： 局部变量存储在堆栈段。 例如代码中的inti存储在栈的-4(%rbp)中，大小为4个字节。 例如代码中的argc存储在edi中 初始化的全局变量存储在数据段（.data段）。 例如代码中的intsleepsecs=2.5。 可以看到sleepsecs在.data段中。 赋值： mov例如给i赋值为0。 3.3.3类型转换 隐式： 例如代码中的intsleepsecs=2.5隐式类型转换。 3.3.4算术操作 例如hello中i+1表示为： 3.3.5关系操作 例如在比较i<10时： 比较i与9 例如比较argc!=3时： 比较3与argc 3.3.6数组操作 例如在访问数组argv[]时： 利用rax先后读取argv[1]与argv[2] 3.3.7控制转移 if(argc!=3)若条件成立，则跳转到L2。 for(i=0;i<10;i++)若条件不成立，则跳转到L4，否则i+1。 3.3.8函数操作 main函数：传递参数argc与argv[]存储在edi与rsi中。 printf函数： printf("Usage:Hello学号姓名！\n");传递参数为打印的字符串的首地址。利用call调用函数。 printf("Hello%s%s\n",argv[1],argv[2]);传递参数为打印的字符串的首地址。利用call调用函数。 getchar函数： 直接利用call调用。 exit函数： 利用call调用，传递参数为edi为1. Sleep函数： 传递参数eax作为sleep的参数。利用call调用 3.4本章小结 本章就编译操作的分析，使我了解了编译的概念与作用，编译的命令与Hello的编译结果。 第4章汇编 4.1汇编的概念与作用 汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatableobjectprogram)的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。 4.2在Ubuntu下汇编的命令 ashello.s-ohello.o产生.o文件 4.3可重定位目标elf格式 Readelf-ahello.o>hello.txt生成elf格式文件 ELF头（ELFheader)：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如X86-64)节头部表（sectionheadertable)的文件偏移，以及节头部表中条目的大小和数量。 节头部表：不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry)。 重定位节：链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输人模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输人模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 offset是需要被修改的引用的节偏移。symDol标识被修改引用应该指向的符号。type告知链接器如何修改新的引用。addend是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。 符号表：在编译时，编译器向汇编器输出每个全局符号，或者是强（strong)或者是弱（weak)，汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 4.4Hello.o的结果解析 objdump-d-rhello.o>objdump.txt 机器语言由机器指令集构成，能够直接被机器执行。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。简单来说，汇编语言是机器语言（二进制指令）的文本形式，与指令是一一对应的关系。在机器语言中，调用函数时并没有像汇编语言一样使用函数的目标地址，而是调用目标函数相对地址的下一条地址。在汇编语言中程序对不同分支进行了分段，以便访问这些分支，而机器语言调用了明确的地址。 4.5本章小结 本章就对汇编过程的分析，使我们了解了汇编的概念与作用，可重定位目标elf格式及机器语言与汇编语言的关系。 第5章链接 5.1链接的概念与作用 链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。 5.2在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 readelf-ahello>helloelf.txt ELF头（ELFheader)：ELF头描述文件的总体格式。它还包括程序的入口点（entrypoint),也就是当程序运行时要执行的第一条指令的地址。.text.rodata和.data节与可重定位目标文件中的节是相似的。 节头部表：不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry)。 重定位节：链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输人模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输人模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 offset是需要被修改的引用的节偏移。symDol标识被修改引用应该指向的符号。type告知链接器如何修改新的引用。addend是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。 符号表：在编译时，编译器向汇编器输出每个全局符号，或者是强（strong)或者是弱（weak)，汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 动态符号表： 动态节：存储着动态链接器使用的信息。 程序头部表：ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片（chunk)被映射到连续的内存段。程序头部表（programheadertable)描述了这种映射关系。 5.4hello的虚拟地址空间 从程序头部表，我们会看到根据可执行目标文件的内容初始化两个内存段。第1行和第2行告诉我们第一个段（代码段）有读/执行访问权限，开始于内存地址0x400000处，总共的内存大小是0x76c字节，并且被初始化为可执行目标文件的头0x76c个字节，其中包括ELF头、程序头部表以及.init.text和.rodata节。 PHDR段：开始于内存地址0x400040处，总共的内存大小是0x1c0字节， 与5.3对比可以明显看出这部分存储着程序头部表。 INTERP段：开始于内存地址0x400200处，总共的内存大小是0x1c字节 可以明显看出这部分存储解释器。 NOTE:开始于内存地址0x40021c处，总共的内存大小是0x20字节 保存辅助信息。 第3行和第4行告诉我们第二个段（数据段）有读/写访问权限，开始于内存地址0x600e50处，总的内存大小为0x1f8字节，并用从目标文件中偏移0xe50处开始的.data节中的0x1f8个字节初始化。 DYNAMIC段:开始于内存地址0x600e50处，总共的内存大小是0x1a0字节 与5.3对比可以明显看出这部分存动态节的数据。 5.5链接的重定位过程分析 Objdump-d-rhello>diff.txt生成分析hello与hello.o的不同的文本文件。 链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。 hello增加了.init节与.plt节与.fini节： Hello还在增加的三个节中加入了hello所需要的_init,puts,printf,_libc_start_main,getchar,sleep,exit,.plt.got，_start,_libc_cus_init,libc_csu_fini,_fini 函数。 hello的地址较hello.s的地址发生了偏移。 重定位由两步组成： 重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输人模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输人模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。 重定位举例： 从hello的符号表中，变量sleepsecs的ADDR(symbol)=ADDR(sleepsecs)=0x600904; 从hello.o的重定位节中获取sleepsec的重定位信息type=R_X86_64_PC32，offset=0x5c,addend=-4。 在可执行文件的反汇编文件中得到ADDR(s)=ADDR(.text)=0x4004fa。 refaddr=ADDR(s)+offset=0x4004fa+0x5c=0x400556 *refptr=(unsigned)(ADDR(symbol)+addend-refaddr)=(unsigned)(0x600904–0x4-0x400556)=(unsigned)(0x2003aa)小端存储 在可执行文件的反汇编文件中对计算结果进行验证：发现计算正确 5.6hello的执行流程 _init 0x0000000000400488 _start() 0x000000000040052a __libc_start_main 0x000000000040052a __libc_csu_init() 0x0000000000400624 _init() 0x0000000000400488 main() 0x00000000004005b2 _IO_puts 0x00000000004004b5 __GI_exit 0x00000000004004e5 _fini() 0x000000000040063c _init 0x0000000000400488 _start 0x000000000040052a __libc_csu_init 0x0000000000400624 _init 0x0000000000400488 main 0x00000000004005b2 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 __sleep 0x00000000004004f5 __printf 0x00000000004004b5 getchar() 0x00000000004004d5 __GI_exit 0x00000000004004e5 _fini() 0x000000000040063c 5.7Hello的动态链接分析 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接。 假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址,因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是PIC，因为它需要链接器修改调用模块的代码段，GNU编译系统使用了一种很有趣的技术来解决这个问题，称为延迟绑定(lazybinding)将过程地址的绑定推迟到第一次调用该过程时。延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：GOT和过程链接表（ProcedureLinkageTable,PLT)，如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。 可以看到.got大小为0x10，地址为0x600ff0。 可以看到.got.plt大小为0x40，地址为0x601000。 在运行dl_start前.got与.got.plt的存储如下： 在运行dl_start后.got与.got.plt的存储如下： 可以很明显的发现这些段发生了变化。 5.8本章小结 本章就链接的概念与作用，在Ubuntu下链接的命令，可执行目标文件hello的格式，hello的虚拟地址空间，链接的重定位过程分析，hello的执行流程，Hello的动态链接分析对链接进行了分析。 第6章hello进程管理 6.1进程的概念与作用 在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context)中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。每次用户通过向shell输人一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。 6.2简述壳Shell-bash的作用与处理流程 Shell是一个交互型的应用级程序，它代表用户运行其他程序。最早的shell是sh程序，后面出现了一些变种，比如csh，tcsh，ksh和bash，shell执行一系列的读/求值（read/evaluate)步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的运行的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。 fork函数只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork返回子进程的PID在子进程中，fork返回0。因为子进程的PID总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。 hello创建进程 观察hello进程 6.4Hello的execve过程 execve函数在当前进程的上下文中加载并运行一个新程序。execve函数加载并运行可执行目标文件filename,且带参数列表argv和环境变量列表envp只有当出现错误时，例如找不到filename才会返回到调用程序。所以，与fork 次调用返回两次不同，execve调用一次并从不返回。 6.5Hello的进程执行 多个流并发地执行的一般现象被称为并发（concurrency)。一个进程和其他进程轮流运行的概念称为多任务（multitasking)。一个进程执行它的控制流的一部分的每一时间段叫做时间片因此，多任务也叫做时间分片（timeslicing)。 为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。 处理器通常是用某个控制寄存器中的一个模式位（modebit)来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中（有时叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。 没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令(privilegedinstruction),比如停止处理器、改变模式位，或者发起一个I/O操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。 运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷人系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。 操作系统内核使用一种称为上下文切换(contextswitch)的较高层形式的异常控制流来实现多任务。内核为每个进程维持一个上下文（context)。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度（scheduling),是由内核中称为调度器（scheduler)的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换1)保存当前进程的上下文，2)恢复某个先前被抢占的进程被保存的上下文，3)将控制传递给这个新恢复的进程。 当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，hello中的sleep系统调用，它显式地请求让调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每1毫秒或每10毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。 6.6hello的异常与信号处理 正常运行： 可以看到程序结束后无该进程，说明上述进程被回收。 在键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程。结果是终止前台作业。 可以看到Ctrl+C后无该进程，说明上述进程被回收。 输入Ctrl+Z会发送一个SIGTSTP信号到前台进程组中的每个进程。结果是停止（挂起)前台作业。 可以看到Ctrl+Z后有进程，说明上述进程未被回收。 发现为停止（挂起)前台作业 可继续运行该进程 也可终止该进程 不停乱按键盘 进程忽略该信号 6.7本章小结 本文就hello进程管理，使我了解了进程的概念与作用，壳Shell-bash的作用与处理流程，Hello的fork进程创建过程，Hello的execve过程，Hello的进程执行，hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 物理地址：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。第一个字节的地址为0,接下来的字节地址为1，再下一个为2,依此类推。给定这种简单的结构，CPU访问内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址。 逻辑地址：这存储单元的地址就可以用段基址(段地址)和段内偏移量(偏移地址)来表示,段基址确定它所在的段居于整个存储空间的位置,偏移量确定它在段内的位置,这种地址表示方式称为逻辑地址,通常表示为段地址:偏移地址的形式。 线性地址：是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。 虚拟地址：虚拟地址是程序运行在保护模式下，这样程序访问存储器所使用的逻辑地址称为虚拟地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理（segmentation），是指把一个程序分成若干个段（segment）进行存储，每个段都是一个逻辑实体（logicalentity），程序员需要知道并使用它。它的产生是与程序的模块化直接有关的。段式管理是通过段表进行的，它包括段号或段名、段起点、装入位、段的长度等。此外还需要主存占用区域表、主存可用区域表。 7.3Hello的线性地址到物理地址的变换-页式管理 同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。 这些功能是由软硬件联合提供的，包括操作系统软件、MMU(内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表（pagetable)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。 7.4TLB与四级页表支持下的VA到PA的变换 TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。如图9-15所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有：T=2t个组，那么TLB索引（TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的。 图9-16a展示了当TLB命中时(通常情况)所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。 •第1步：CPU产生一个虚拟地址。 •第2步和第3步：MMU从TLB中取出相应的PTE •第4步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。 •第5步：高速缓存/主存将所请求的数据字返回给CPU 当TLB不命中时，MMU必须从L1缓存中取出相应的PTE,如图9-16b所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。 用来压缩页表的常用方法是使用层次结构的页表。用一个具体的示例是最容易理解这个思想的。假设32位虚拟地址空间被分为4KB的页，而每个页表条目都是4字节。还假设在这一时刻，虚拟地址空间有如下形式：内存的前2K个页面分配给了代码和数据，接下来的6K个页面还未分配，再接下来的1023个页面也未分配，接下来的1个页面分配给了用户栈。图9-17展示了我们如何为这个虚拟地址空间构造一个两级的页表层次结构。 一级页表中的每个PTE负责映射虚拟地址空间中一个4MB的片（chunk)，这里每一片都是由1024个连续的页面组成的。比如，PTE0映射第一片，PTE1映射接下来的一片，以此类推。假设地址空间是4GB，1024个PTE已经足够覆盖整个空间了。 如果片i中的每个页面都未被分配，那么一级PTEi就为空。例如，图9-17中，片2到7是未被分配的。然而，如果在片i中至少有一个页是分配了的，那么一级PTEi就指向一个二级页表的基址。例如，在图9-17中，片0、1和8的所有或者部分已被分配，所以它们的一级PTE就指向二级页表。 二级页表中的每个PTE都负责映射一个4KB的虚拟内存页面，就像我们查看只有一级的页表一样。注意，使用4字节的PTE。每个一级和二级页表都是4KB字节，这刚好和一个页面的大小是一样的。 图9-25描述了使用4级页表层次结构的地址翻译。虚拟地址被划分成为4个VPN和1个VPO。每个VPNi都是一个到第i级页表的索引，其中1<=i<=4。第j级页表中的每个PTE，1<=j<=3,都指向第j+1级的某个页表的基址。第4级页表中的每个PTE包含某个物理页面的PPN,或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN之前，MMU必须访问4个PTE。对于只有一级的页表结构，PPO和VPO是相同的。 7.5三级Cache支持下的物理内存访问 位于处理器芯片上的L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的L2高速缓存通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5到10倍。L1和L2高速缓存是用一种叫做静态随机访问存储器（SRAM)的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：LI，L2和L3系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。 在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构，如图1-9所示。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第0级或记为L0，这里我们展示的是三层高速缓存L1到L3,占据存储器层次结构的第1层到第3层。主存在第4层，以此类推。 存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID为了给这个新进程创建虚拟内存，它创建了当前进程的构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 要运行可执行目标文件hello,我们可以在Linuxshell的命令行中输入它的名字 ./hello1190201619惠羿 因为hello不是一个内置的shell命令，所以shell会认为hello是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器（loader)的操作系统代码来运行它。任何Linux程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。 虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。我们就能够理解execve函数实际上是如何加载和执行程序的。假设运行在当前进程中的程序执行了如下的execve调用： execve(“hello”,NULL,NULL); 函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤: 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。 映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。图9-31概括了私有区域的不同映射。 映射共享区域。如果hello程序与共享对象（或目标）链接，比如标准C库libc.so。那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 设置程序计数器（PC)。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的人口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 7.8缺页故障与缺页中断处理 在有些情况中，被引用的存储器位置实际上是存储在磁盘存储器上的。此时，硬件会产生一个缺页（pagefault)异常信号。同其他异常一样，这个异常会导致处理器调用操作系统的异常处理程序代码。然后这段代码会发起一个从磁盘到主存的传送操作。一旦完成，操作系统会返回到原来的程序，而导致缺页的指令会被重新执行。这次，存储器引用将成功，虽然可能会导致高速缓存不命中。让硬件调用操作系统例程，然后操作系统例程又会将控制返回给硬件，这就使得硬件和系统软件在处理缺页时能协同工作。因为访问磁盘需要数百万个时钟周期，0S缺页中断处理程序执行的处理所需的几百个时钟周期对性能的影响可以忽略不计。 从处理器的角度来看，将用暂停来处理短时间的高速缓存不命中和用异常处理来处理长时间的缺页结合起来，能够顾及到存储器访问时由于存储器层次结构引起的所有不可预测性。 故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。图8-7概述了一个故障的处理。 一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第9章中看到的那样，一个页面就是虚拟内存的一个连续的块（典型的是4KB)缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页（pagefault)，图9-6展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3,从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。 接下来，内核从磁盘复制VP3到内存中的PP3,更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图9-7展示了在缺页之后我们的示例页表的状态。 假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤： 1)虚拟地址A是合法的吗？换句话说，A在某个区域结构定义的区域内吗？为了回答这个问题，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图9-28中标识为“1”。因为一个进程可以创建任意数量的新虚拟内存区域所以顺序搜索区域结构的链表花销可能会很大。因此在实际中，Linux使用某些我们没有显示出来的字段，Linux在链表中构建了一棵树，并在这棵树上进行査找。 2)试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。这种情况在图9-28中标识为“2”。 3)此刻，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU。这次，MMU就能正常地翻译A而不会再产生缺页中断了。 7.9动态存储分配管理 虽然可以使用低级的mmap和munmap函数来创建和删除虚拟内存的区域，但是C程序员还是会觉得当运行时需要额外虚拟内存时，用动态内存分配器更方便，也有更好的可移植性。 动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap)(见图9-33)。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块（block)的集合来维护。每个块就是一个连续的虚拟内存片（chunk),要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器（explicitallocator),要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。 隐式分配器（implicitallocator)，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器,而自动释放未使用的已分配的块的过程叫做垃级收集例如，诸如Lisp，ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 7.10本章小结 本章就hello的存储管理，使我了解了hello的存储器地址空间，Intel逻辑地址到线性地址的变换-段式管理，Hello的线性地址到物理地址的变换-页式管理，TLB与四级页表支持下的VA到PA的变换，缺页故障与缺页中断处理，hello进程fork时的内存映射，hello进程execve时的内存映射，缺页故障与缺页中断处理，动态存储分配管理。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 一个Linux文件就是一个m个字节的序列，所有的I/O设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。 设备管理：unixio接口 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O,这使得所有的输人和输出都能以一种统一且一致的方式来执行： 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入(描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO，STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。 改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为是k。 读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。 类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 8.2简述UnixIO接口及其函数 进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的： open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件。mode参数指定了新文件的访问权限位。 进程通过调用close函数关闭一个打开的文件。 关闭一个已关闭的描述符会出错。 应用程序是通过分别调用read和write函数来执行输入和输出的。 read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1，表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章就hello的IO管理，使我了解了Linux的IO设备管理方法，UnixIO接口及其函数，printf的实现，getchar的实现。 结论 Hello的一生： 源代码：用C语言编写hello.c的代码。预处理：预处理器将hello.c处理成hello.i。编译：编译器将hello.i翻译成hello.s。汇编：汇编器将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。输入命令：在shell中输入./hello1190201619惠羿 shell识别并发送信号创建子进程：进程管理shell通过fork()创建子进程。运行：进程管理shell利用execve加载进程。执行：进程管理分配mmap，时间片。访存：MMU将CPU给出的虚拟地址翻译为物理地址，再根据物理地址去内存中寻找数据。动态申请内存：通过调用malloc，从堆中申请内存。结束：shell父进程回收子进程。 这就是hello的一生，虽然它的一生在机器中很短暂，但它的一生基本上囊括了计算机系统的所有知识。虽然hello的一生看起来简单，但对hello的一生的研究对我们了解计算机系统有着重要的作用。 附件 文件名字描述hello.i修改了的源程序(文本）hello.s汇编程序(文本）hello.o可重定位目标程序(二进制）hello.txthello.o的ELF格式objdump.txthello.o的反汇编文件hello可执行目标文件helloelf.txthello的ELF格式diff.txt分析hello与hello.o的不同的文本文件。 参考文献 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 

HITCSAPP大作业-程序人生 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机 学 号 1190201628 班 级 1936601 学 生 尹岩泉 指导教师 刘宏伟 摘要 摘要是论文内容的高度概括，应具有独立性和自含性，即不阅读论文的全文，就能获得必要的信息。摘要应包括本论文的目的、主要内容、方法、成果及其理论与实际意义。摘要中不宜使用公式、结构式、图表和非公知公用的符号与术语，不标注引用文献编号，同时避免将摘要写成目录式的内容介绍。 关键词：计算机系统，预处理，编译，汇编，链接，进程，储存，IO 本文将从程序预处理开始一直到进程被回收的过程，解析hello.c程序的生命周期的过程，在过程中具体分析各个阶段的内容与实现机制。通过对进程的操作的了解，深入理解计算机系统。 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1 预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.3.1 数据 3.3.2数组 3.3.3赋值 3.3.4算数操作 3.3.5关系操作 3.3.6控制转移操作 3.3.7函数操作 3.3.8类型转换操作 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.3.1ELF头 4.3.2节头 4.3.3重定位节 4.3.4符号表 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.3.1ELF头 5.3.2节头 5.3.3重定位节 5.3.4符号表 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 P2P：FromProgramtoProcess，即从程序到过程。在linux中，hello.c文件经过编译器的预处理成为hello.i、再经过编译器的编译成为hello.s、接着被汇编为hello.o、最终链接成为可执行目标程序hello，操作系统执行此文件，然后，操作系统会为其fork产生子进程，再调用execve函数加载进程（Process）。至此，P2P结束。 020：FromZero-0toZero-0，shell通过execve加载并执行hello，操作系统映射虚拟内存。进入程序入口后，程序开始载入物理内存空间，然后进入main函数，执行目标代码，CPU为运行的hello分配时间片执行逻辑控制流。当程序运行结束后，shell父进程负责回收hello进程，内核删除相关数据结构。至此，020结束。 1.2环境与工具 X64CPU;1.80GHZ;8GROM;256GHDDISK。 Windows10;VmwareWorkstation Pro 15.5;Ubuntu18.0464位 CodeBlocks；VisualStdio；edb 1.3中间结果 hello.c：源程序 hello.i：经过预处理的源程序 hello.s：hello.i经过编译的汇编程序 hello.o：hello.s经过汇编的可重定位目标程序 hello：hello.o经过链接后的可执行目标程序 hello.elf：hello生成的elf文件 hello.o.elf：hello.o生成的elf文件 hello.asm：hello的反汇编代码 hello.o.asm：hello.o的反汇编代码 1.4本章小结 本章简单介绍了hello的P2P，O2O，介绍了实验用到的工具，中间结果。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 预处理的概念：预处理器cpp根据以字符#开头的命令（宏定义、条件编译），读取对应系统头文件的内容，并把它直接插入到程序文本中来修改原始的C程序，结果合并成为一个完整的文本文件。 预处理的作用： 1.头文件包含指令处理，将源文件中以”include”格式包含的文件复制到编译的源文件中。 2.宏定义指令处理，用实际值替换用“#define”定义的字符串，进行宏替换。 3.条件编译指令处理，根据“#if”后面的条件决定需要编译的代码。 4.特殊符号，预处理程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预处理程序对于在源程序中出现的这些串将用合适的值进行替换。为下一阶段的编译做准备。 2.2在Ubuntu下预处理的命令 命令：gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析 经过预处理之后，hello.c转化为hello.i文件，可以发现该文件的内容明显增加，但仍为可以阅读的C语言程序文本文件，符合C语言的语法。 可以发现命令对原文件中的宏进行了宏展开，头文件中三个#include的内容被替换进该文件中。源程序hello.c中没有定义宏常量，所以没有体现宏替换，但如果代码中有#define命令还会对相应的符号进行替换。 2.4本章小结 本章简述了hello程序生命周期中预处理阶段的概念作用及实现，预处理器以#开头的预处理命令，完成将对应的头文件插入程序文本中，进行宏替换等任务。生成的hello.i将进行下一阶段的编译。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的概念：将源程序（.i）翻译成汇编语言程序（.s）。 编译的作用：以高级程序设计语言书写的源程序翻译成汇编语言程序后，以汇编语言或机器语言表示的目标程序作为输出，之后更容易转化成机器可以看懂的二进制代码。 3.2在Ubuntu下编译的命令 命令：gcc-Ehello.c-ohello.i 3.3Hello的编译结果解析 3.3.1 数据 字符串 程序中有两个字符串，由图可知，这两个字符串都存放在只读数据段中。 2.全局变量 程序中有一个全局变量sleepsecs，定义为int类型，赋值为2.5。在编译过程中其实已经进行了一个隐式强制类型转换，在初始化后数值已经变成了2。 3.局部变量 main函数中声明了一个局部变量i，编译器进行编译时会将局部变量i放在堆栈中，在此程序中根据movl$0,-4(%rbp)，可知i在栈中的-4(%rbp)位置上。 4.main函数 main的参数argc储存在栈中。由cmpl$3,-20(%rbp)和je.L2可以看出argc在-20(%rbp)中。 5.立即数 立即数直接体现在汇编的代码中。 3.3.2数组 程序中唯一一个数组是char*argv[]，作为main函数的一个参数出现，每个元素都是指向字符类型的指针。由movq-32(%rbp),%rax可知数组的起始地址存放在栈的-32(%rbp)的位置，由于一个char*的大小是8字节，所以两个分别对应头指针+8和头指针+16，两次进行addq和movq的操作分别获取了argv[1]和argv[2]的地址。 3.3.3赋值 程序中的赋值操作一共有两个一个是intsleepsecs=2.5，一个是i=0。sleepsecs为全局变量，直接进行了强制类型转化；i=0在汇编代码中依靠movl指令来实现。 3.3.4算数操作 hello.c中实现的算数操作有i++。如在汇编代码中的addl$1,-4(%rbp)就是对位于-4(%rbp)的i加1。 常用的整数算数操作有如下图： 3.3.5关系操作 关系操作往往与条件跳转有关。程序通过判断两个变量的关系，来实现程序的逻辑控制。在本程序中有两个关系操作，分别如下： 1.argc!=3，进行编译时，这条指令被编译为cmpl$3,-20(%rbp)，同时这条cmpl的指令还有设置条件码的作用，当根据条件码来判断是否需要跳转到分支中，即下一句的je.L2。 2.i<10，在hello.c作为判断循环条件，在汇编代码被编译为cmpl$9,-4(%rbp)，计算i-9然后设置条件码，为下一步jle利用条件码进行跳转做准备，即jle.L4。 3.3.6控制转移操作 在本程序中有两个控制转移操作，一个if，一个for，具体如下： 1.if(argc!=3)：判断argc是否等于3，如果等于3，则不执行if中的语句，否则执行。对应的汇编代码为： 2.for(i=0;i<10;i++)，通过每次判断i是否满足小于10来判断是否需要跳转至循环语句中，对应的汇编代码为： 3.3.7函数操作 程序运行时先进入程序入口处，然后自动调用main函数。若程序员需要调用函数，在汇编代码中需要使用call指令，在使用之前需要先设置好参数（放在寄存器或者栈）。在hello.c中有调用main，puts，printf，sleep，exit，getchar函数。main函数的参数是argc和argv[]；两次printf函数的参数为两个只读数据段中的字符串；exit参数是1；sleep函数参数是sleepsecs。对应在hello.s中的操作如下： 3.3.8类型转换操作 在全局变量阶段已经有介绍。程序中有一个全局变量sleepsecs，定义为int类型，赋值为2.5。在编译过程中其实已经进行了一个隐式强制类型转换，在初始化后数值已经变成了2。 3.4本章小结 本章主要讲述了什么是编译，编译阶段中编译器如何处理各种数据和操作，以及c语言中各种类型和操作所对应的的汇编代码。理解了这些编译器编译的机制和一些汇编指令的含义和作用。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编器（as）将汇编代码（.s）翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在（.o）目标文件中，.o文件是一个二进制文件，它包含程序的指令编码，更便于机器在此后的链接与运行。 4.2在Ubuntu下汇编的命令 命令：gcc-chello.s-ohello.o 4.3可重定位目标elf格式 通过命令readelf-ahello.o查看内容进行分析。 4.3.1ELF头 首先是以一个16字节的序列Magic开始，描述了生成该文件的系统的字的大小和字节顺序。剩下部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、程序头的大小、文件类型为可重定位文件等信息。 4.3.2节头 节头包含了文件中出现的各个节的语义，包括节的类型、位置、大小和偏移量等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小。 4.3.3重定位节 重定位节包含了需要被修改的引用节的偏移量、信息、重定位的类型、符号值和重定位需要对被引用值的偏移调整量等。图中‘.rela.text’为一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。 4.3.4符号表 图中为程序符号表的信息，用来存放程序中定义和引用的函数和全局变量的信息。Value是符号相对于目标节的起始位置偏移、Size是目标的大小、Type为类型。Bind字段表明符号是本地的还是全局的。可以看到标号为11~16的符号都没有找到所在节，而sleepsecs在标号为3的节中，main在标号为1的节中。 4.4Hello.o的结果解析 命令：objdump-d-rhello.o，得到反汇编结果如下： hello.s的内容如下： 通过反汇编的代码和hello.s进行比较，发现从机器语言反汇编成汇编语言，与原本的汇编语言相差不大。但是通过对机器代码的分析也可以发现以下不同之处： （1）hello.s中没有对指令编码二进制的地址，而hello.o的反汇编代码中有。因为反汇编代码所显示的不仅仅是汇编代码，还有机器代码，机器语言程序的是二进制机器指令的集合，是纯粹的二进制数据表示的语言，是电脑可以真正识别的语言，这样才有编码和指令的对应。 （2）跳转指令：hello.s中采用的是段名称.L2,.L3等，反汇编用的则是确定的地址。因为，因为段名称只是在汇编语言中便于编写的助记符，而在反汇编代码中，由于已经得到每个指令的地址，就被替换成了具体的地址。 （3）对于函数调用，在hello.s中函数调用后直接加函数名称，而在反汇编指令中，采用的是call后直接为下一条指令。主要是因为，在反汇编代码中，还没有进行重定位，对于不确定地址的函数调用，需要添加重定位条目，等待链接时为其填上对应的值。 4.5本章小结 本章对hello.s进行了汇编，生成了hello.o可重定位目标文件，使用readelf方法分析了可重定位文件的ELF头、节头部表、符号表和可重定位节，比较了hello.s和hello.o反汇编代码的不同之处，分析了从汇编语言到机器语言的一一映射关系，体会了重定位的作用和意义。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载到内存并执行。链接由链接器自动执行。 链接的作用：链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。 5.2在Ubuntu下链接的命令 命令： ld-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.o/usr/lib/gcc/x86_64-linux-gnu/7/crtbegin.ohello.o-lc/usr/lib/gcc/x86_64-linux-gnu/7/crtend.o/usr/lib/x86_64-linux-gnu/crtn.o-zrelro-ohello 5.3可执行目标文件hello的格式 通过命令readelf-ahello.o查看内容进行分析。 5.3.1ELF头 hello的ELF头和hello.o的不同之处在于类型为EXEC（可执行文件），共有28个节。 5.3.2节头 节头包含了文件中出现的各个节的语义，包括节的类型、位置、大小和偏移量等信息。 5.3.3重定位节 重定位节包含了需要被修改的引用节的偏移量、信息、重定位的类型、符号值和重定位需要对被引用值的偏移调整量等。 5.3.4符号表 图中为程序符号表的信息，用来存放程序中定义和引用的函数和全局变量的信息。 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 通过DataDump可以看出hello的虚拟空间开始于0x400000，结束于0x400ff0。 根据上文得到的节头表，可以找到各个节的信息，如.txt节，虚拟地址开始于0x400500。 5.5链接的重定位过程分析 命令：objdump-d-rhello 下图为hello.out的反汇编代码： 可以明显看出，hello与hello.out对比，可以看出以下不同： hello的反汇编代码有确定的虚拟地址，重定位也已经完成，对应的跳转地址，全局变量调用等都已经加入了正确的值。hello的反汇编代码多出来了.init等节和很多函数的汇编代码。并且指令的地址也不相同，由于链接器将hello的代码映射到虚拟内存上，所以他们的地址不同。 下面举例介绍hello的重定位过程： 以hello.o中的.rodata节作为例子： 重定位算法如图所示： ADDR(S)=ADDR(main)=0x004005e7 refaddr=ADDR(S)+r.offest=0x004005e7+0x18=0x004005ff ADDR(r.symtab)=ADDR(.L0)=0x4006f4 所以最后填入的地址是0x4006f4-0x4005ff-0x4=0xf1 所以开始的四个字节为f1000000 验证可得正确。 5.6hello的执行流程 子程序名程序地址ld-2.27.so!_dl_start0x00007f38:3ebddea0ld-2.27.so!_dl_init0x00007f21:0198d760hello!_start0x00000000:00400500libc-2.27.so!__libc_start_main0x00007fc6:b7a2db12libc-2.27.so!__cxa_atexit0x00007fb9:b7a4f550hello!__libc_csu_init0x00000000:00400677hello!_init0x00000000:00400488libc-2.27so!_setjmp0x00007fa1:0198cef8 libc-2.27.so!__sigsetjmp0x00007f21:01993270libc-2.27.so!__sigjmp_save0x00007f21:01991840hello!main0x00000000:004005e7hello!puts@plt0x00000000:004004b0hello!printf@plt0x00000000:004004c0hello!sleep@plt0x00000000:004004f0hello!getchar@plt0x00000000:004004d0hello!exit@plt0x00000000:004004e0ld-2.27.so!_dl_runtime_resolve_xsave0x00007fad:1c1d08f0ld-2.27.so!_dl_fixup0x00007fad:1c1c8f80ld-2.27.so!_dl_lookup_symbol_x0x00007fad:1c1c4260libc-2.27.so!_exit0x00007fa1:01993210 5.7Hello的动态链接分析 由于编译器无法预测函数的运行时地址，所以需要添加重定位记录。为避免运行时修改调用模块的代码段,链接器采用延迟绑定的策略，使用全局偏移量表和 过程链接表（PLT+GOT）实现函数的动态链接。PLT使用GOT中的地址跳到目标函数，在加载时，连接器会重定位GOT，使得他包含目标的正确的绝对地址。 在dl_init调用之前，函数调用都指向PLT中的代码逻辑。第一次执行dl_init时，为GOT赋上相应的偏移量，初始化了函数调用。此后每次执行时不需要经过如此操作，每次都直接跳转到目标函数的地址。 5.8本章小结 在本章中主要介绍了链接的概念与作用，并且详细阐述了hello.o是怎么链接成为一个可执行目标文件的过程，详细介绍了hello.o的ELF格式和各个节的含义，并且分析了hello的虚拟地址空间、重定位过程、执行流程、动态链接过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context)中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。 6.2简述壳Shell-bash的作用与处理流程 Shell是一个交互型应用级程序，它可以读取用户输入的命令，执行相应的操作。Shell应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 其基本功能是解释并运行用户的指令，重复如下处理过程： 当从shell里输入命令（字符串）时，第一个单词是可执行程序的名称，后面 则是参数列表。shell会传进参数列表来执行对应程序，创建进程，并在进程终止后回收进程。 读入后，shell先解析字符串，得到命令行参数（char**argv）。检查第一个(首个、第0个）命令行参数是否是一个内置的shell命令，如果不是内部命令，调用fork()创建新进程/子进程。在子进程中，调用execve()执行指定程序若命令行。若参数的最后一个单词是&，表示要在后台执行，shell可以继续输入命令来做其他工作，否则则为前台执行，必须等待该进程结束并回收。 6.3Hello的fork进程创建过程 当程序调用fork函数时，将创建一个跟当前进程一模一样的进程副本（共享代码，有独立的地址空间，子进程可以读写父进程中打开的任何文件），进程分裂成父进程和子进程，它们拥有不同的PID。二者fork的返回值不同：父进程中fork的返回值是子进程的pid，子进程中fork的返回值是0。父进程和子进程独立运行，二者结束顺序不可知。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。 例如在hello中，当输入./hello1190201628尹岩泉时，这不是一个内置命令，故shell会调用fork新建一个子进程。 6.4Hello的execve过程 fork创建子进程之后，子进程调用execve函数（传入命令行参数）在当前进程的上下文中加载并运行一个新程序即hello程序。 execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行hello程序，加载器删除子进程现有的用户虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。换句话说，execve函数将用目标程序的进程替换当前进程，并传入相应的参数和环境变量，控制转移到新程序的main函数。 6.5Hello的进程执行 （1）逻辑控制流:：一系列程序计数器（PC）的值的序列叫做逻辑控制流。 （2）并发流：一个逻辑流的执行时间与另一个流重叠，成为并发流，这两个流被称为并发地运行。 （3）私有地址空间：进程为每个流都提供一种假象，好像它是独占的使用系统地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。 （4）用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 （5）上下文切换：当内核选择一个新的进程运行时，则内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程： 1）保存当前进程的上下文 2）恢复某个先前被抢占的进程被保存的上下文 3）将控制传递给这个新恢复的进程 最初hello运行在用户模式下，正常输出用户输入的内容，但是程序调用了sleep函数，进入内核模式，进程主动请求休眠释放当前进程，并将hello进程从运行队列中移出加入等待队列，定时器开始计时，内核进行上下文切换将当前进程的控制权交给其他进程。当计时器结束后，发送中断信号，此时进入内核状态执行中断处理，将hello进程从等待队列中移出重新加入到运行队列，从内核模式转换为用户模式，hello进程就可以继续进行自己的控制逻辑流了。 当hello调用getchar的时候，实际执行了read的调用，产生了上文所述的上下文切换。当完成键盘缓冲区到内存的数据传输时，内核从其他进程进行上下文切换回hello。 6.6hello的异常与信号处理 异常和信号异常一共可以分为4种： 在hello程序中可能出现： 中断：时钟中断。陷阱：调用了系统命令，如sleep，exit等。故障：可能发生缺页故障。 键盘上可能导致的异常： 1.首先给出正常运行的结果。 2.Ctrl+Z 输入Ctrl+z默认结果是挂起前台的作业，hello进程并没有回收，而是运行在后台下。 可以用ps命令看到hello进程并没有被回收。同时调用jobs，pstree观察。 继续调用fg1将其调到前台，此时shell程序首先打印hello的命令行命令，然后继续运行直至程序结束，同时进程被回收。 也可以通过kill命令操作。 3.Ctrl+C 在键盘上输入Ctrl+C默认情况是终止前台作业。 此时可以调用ps命令看到没有hello进程。 4.乱按键盘 可以看到乱按只是将屏幕的输入缓存到stdin，当getchar()的时候读出一个字符串，其他字串会当做shell命令行输入。 6.7本章小结 本章说明了进程的定义与作用，介绍了Shell-bash 的作用和处理流程，以及调用fork创建新进程，execve的过程，hello的进程执行的过程，系统对hello的异常与异常信号的处理。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：程序代码经过编译后出现在汇编程序中产生的与段相关的偏移地址。由段选择符+偏移地址构成。其中段选择符位于段寄存器（16位，CS、SS等）中。而偏移地址即为汇编、c代码中显示的地址。常见段寄存器有CS（代码段）、DS（数据段）、SS（栈）等。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相关。 线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址，用于描述程序分页信息的地址。以hello为例，线性地址就是hello应该在内存的哪些块上运行。 虚拟地址：同线性地址。 物理地址：物理地址为加载到内存地址寄存器中的地址，处理器通过地址总线的寻址，找到真实的物理内存对应地址。是内存单元的真实地址。以hello为例，物理地址就是hello真正应该在内存的哪些地址上运行 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理，是指把一个程序分成若干个段进行存储，每个段都是一个逻辑实体，程序员需要知道并使用它。它的产生是与程序的模块化直接有关的。段式管理是通过段表进行的，它包括段号或段名、段起点、装入位、段的长度等。此外还需要主存占用区域表、主存可用区域表。 逻辑地址是程序代码经过编译后出现在汇编程序中产生的与段相关的偏移地址，即在不同的机器上，使用相同的编译器来编译同一个源程序，则其逻辑地址是相同的，但是相同的逻辑地址，在不同的机器上运行，其生成的线性地址又不相同，因为把逻辑地址转换成线性地址的公式是： 线性地址=段基址*16+偏移的逻辑地址，而段基址由于不同的机器其任务不同，其所分配的段基址也会不相同，因此，其线性地址会不同。 即使，对于转换后线性地址相同的逻辑地址，也因为在不同的任务中，而不同的任务有不同的页目录表和页表把线性地址转换成物理地址，因此，也不会有相同的物理地址冲突。 下图为逻辑地址采用段式管理转化为线性地址的过程： 7.3Hello的线性地址到物理地址的变换-页式管理 首先给出一些概念，如图： 页表： 使用页表的地址翻译： 线性地址转换成物理地址的过程如下： n位的虚拟地址包含两个部分:一个p位的虚拟页面偏移（VirtualPageOffset，VPO)和一个(n-p)位的虚拟页号（Virtual PageNumber,VPN)。MMU利用VPN来选择适当的PTE。例如，VPNO选择PTEO，VPN1选择PTE1。以此类推。将页表条目中物理页号(PhysicalPageNumber,PPN)和虚拟地址中的VPO串联起来，就得到相应的物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 二级页表如图所示： k级页表如图所示： 对于多级页表，与上图类似。将VPN分为多级，在每一级都找到对应的位置。当到达最后一层时会得到PPN，与VPO连接就得到了最终的物理地址。 7.5三级Cache支持下的物理内存访问 图为地址翻译后返回结果。左侧是四级页表支持的虚拟地址翻译成物理地址，之后将物理地址分为三块。首先是从L1cache里寻找结果，行匹配把虚拟地址的标记为拿去和相应的组中所有行的标记位进行比较，判断是否命中。若字选择一旦高速缓存命中，则将寻址结果直接返回给CPU；否则需要向低一层的缓存中寻找，取出被请求的块，将新的块储存在组索引位所指示的组的一个高速缓存行中，并设置好tag和valid位。寻找到结果后返回。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，即创建hello进程时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，他创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork函数在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。也就是说，此时新进程并不包括hello程序的相关内容，只有在新进程调用execve加载hello程序，要对虚拟内存进行写操作时，写时复制机制就会创建新页面，将hello的各个段映射到相对应区域。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的概念。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1）删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2）映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3）映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 4）设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 execve只是建立了映射关系，并未加载程序到物理内存中，当开始调度这个进程开始运行的时候，产生缺页故障，然后才会所需要的页面加载进去。 7.8缺页故障与缺页中断处理 处理器首先生成一个虚拟地址，并把它传给MMU。MMU生成PTE地址，并从高速缓存/主存中请求得到它。高速缓存/主存向MMU返回PTE。PTE中的有效位为0，那么此时MMU就触发了一次异常，这个异常导致控制转移到内核的缺页处理程序，传递CPU中的控制到操作系统内核中的缺页异常处理程序。处理程序随后就执行下面的步骤： 1)虚拟地址A是合法的吗？换句话说，A在某个区域结构定义的区域内吗？为了回答这个问题，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图9-28中标识为“1”。 因为一个进程可以创建任意数量的新虚拟内存区域，所以顺序搜索区域结构的链表花销可能会很大。因此在实际中，Linux使用某些我们没有显示出来的字段，Linux在链表中构建了一棵树，并在这棵树上进行査找。 2)试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。这种情况在图9-28中标识为“2”。 3)此刻，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，缺页处理程序调入新的页面，并更新内存中的PTE。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，这次，MMU就能正常地翻译A，而不会再产生缺页中断了。 7.9动态存储分配管理 Printf会调用malloc，下面简述动态内存管理的基本方法与策略。 动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块（block）的集合来维护。每个块就是一个连续的虚拟内存片（chunk）,要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 隐式空闲链表分配器方法： 隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器。 我们可以将堆组织为一个连续的已分配块和空闲块的序列，这种结构被称为隐式空闲链表。以下为几种操作： 放置： （1）首次适配：从头开始搜素空闲链表，选择第一个合适的空闲块。 （2）下一次适配：从上一次查询结束的地方开始搜素空闲链表，选择第一个合适的空闲块。 （3）最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块。 分割空闲块合并： 可以分为立即合并和推迟合并。立即合并是指在每次一个块被释放时，就合并所有的相邻块；推迟合并是指直到某个分配请求失败时，扫描整个堆，合并所有的空闲块。 同时合并具有四种情况： （1）前后的块都为已分配块：不需要合并 （2）前面的块是已分配的，后面的块是空闲的：用当前块和后面块的大小的和来更新当前块的头部和后面块的脚部。 （3）前面的块是空闲的，后面的块是已分配的：用当前块和前面块的大小的和来更新前面块的头部和当前块的脚部。 （4）前后块都为空闲块：用三个块大小的和来更新前面块的头部和后面块的脚部。 显式空闲链表分配器方法： 显式空闲链表中的堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略。 一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检査最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 7.10本章小结 本章节介绍了储存器的四种地址空间的概念，介绍了段式管理和页式管理，解析了TLB与四级页表支持下的VA到PA的变换，以及三级cache支持下的物理内存访问，分析了fork和execve函数的内存映射，缺页故障和缺页中断处理，以及动态存储分配管理。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m字节的序列： 所有的IO设备(如网路、磁盘、终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行： 打开文件；改变当前的文件位置；读写文件；关闭文件。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixIO接口： （1）打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息 （2）Linux shell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0），标准输出（描述符为1），标准错误（描述符为2）. （3）改变当前文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。 （4）读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时执行读操作时触发EOF的条件。 类似的，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 （5）关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件，作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixIO函数： 打开和关闭函数： 进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的： O_RDONLY：只读 O_WRONLY：只写 O_RDWR：读写 进程通过调用close函数关闭一个打开的文件： 关闭一个已关闭的文件会出错。 读和写函数 应用程序是通过分别调用read和write函数来执行输入和输出的： read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值为-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 printff函数的实现代码如下： （来源https://www.cnblogs.com/pianist/p/3315801.html） va_listarg=(va_list)((char*)(&fmt)+4);这句表示将 中的第一个参数定义为arg。 vsprintf(buf,fmt,arg)函数如下： vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 write(buf,i)函数如下： write是将参数放入寄存器，然后调用sys_call sys_call的实现如下： syscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码，符显示驱动子程序：在字模库找到点阵信息储存到vram（存储每一个点的RGB颜色信息）中。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：当用户按键时，键盘接口会得到一个代表该按键的键盘扫描码，键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章节介绍了Linux 的IO设备管理方法，接口及其函数，分析了printf和getchar函数的实现。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 hello所经历的过程总结如下： 编写代码：程序员用高级语言写.c文件，命名保存为hello.c。预处理：从hello.c经过预处理器生成hello.i文件，将hello.c中调用的外部库展开合并到hello.i中。编译：由hello.i经过编译器生成hello.s的汇编文件。汇编：将汇编程序hello.s经过汇编器翻译成机器语言指令文件hello.o，一种可重定位目标程序的格式。连接：将hello.o和各种动态链接库连接成为可重定位目标程序hello。运行：在shell中输入参数，命令，运行hello。创建子进程：shell调用fork函数，创建函数的子进程。加载：shell调用execve函数，加载进程。执行指令：CPU为进程分配时间片，加载器将计数器预置在程序入口点，则hello可以顺序执行自己的逻辑控制流，hello进程与其它进程并发运行。访问内存：hello有系统分配的地址空间，当进行访问内存的操作时，MMU将虚拟内存映射为物理内存地址，通过三级cache来访问内存。动态内存分配：系统根据程序需要申请动态内存。异常信号：根据用户输入的信号和程序内部的命令，shell可以利用信号处理函数处理程序的异常和用户的请求，系统会触发上下文切换，hello会在用户态和内核态切换。终止信号：程序执行完成，回收子进程。 感悟： 我感受到了计算机系统的复杂。并且懂得了要一个行之有效的系统都是对每个部分进行抽象从而实现的，如信息的表示用二进制表示抽象，实现操作系统管理硬件的抽象，它能让系统使用一些一致的操作来对系统中的每个任务进行有效的管理。而且计算机系统的设计巧妙，考虑全面，是一个严密而精致的过程。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 hello.c：源程序 hello.i：经过预处理的源程序 hello.s：hello.i经过编译的汇编程序 hello.o：hello.s经过汇编的可重定位目标程序 hello：hello.o经过链接后的可执行目标程序 hello.elf：hello生成的elf文件 hello.o.elf：hello.o生成的elf文件 hello.asm：hello的反汇编代码 hello.o.asm：hello.o的反汇编代码 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42. [2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998 [1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL]. Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/ collection/anatmorp. （参考文献0分，缺失-1分） 

2021-06-29 程序人生-Hello’sP2P 摘要本文简要分析了hello这一程序的生命周期，并介绍了相应的计算机系统组成成分（主要包括预处理，编译，汇编，链接，进程管理，存储管理，I/O管理几个部分）在其中的作用以及工作方法。关键词：hello，预处理，编译，汇编，链接，进程管理，存储管理，I/O管理；目录 第1章概述-4-1.1HELLO简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在UBUNTU下预处理的命令-5-2.3HELLO的预处理结果解析-5-2.4本章小结-7-第3章编译-8-3.1编译的概念与作用-8-3.2在UBUNTU下编译的命令-8-3.3HELLO的编译结果解析-8-3.4本章小结-12-第4章汇编-13-4.1汇编的概念与作用-13-4.2在UBUNTU下汇编的命令-13-4.3可重定位目标ELF格式-13-4.4HELLO.O的结果解析-16-4.5本章小结-17-第5章链接-18-5.1链接的概念与作用-18-5.2在UBUNTU下链接的命令-18-5.3可执行目标文件HELLO的格式-18-5.4HELLO的虚拟地址空间-24-5.5链接的重定位过程分析-25-5.6HELLO的执行流程-27-5.7HELLO的动态链接分析-28-5.8本章小结-29-第6章HELLO进程管理-30-6.1进程的概念与作用-30-6.2简述壳SHELL-BASH的作用与处理流程-30-6.3HELLO的FORK进程创建过程-30-6.4HELLO的EXECVE过程-30-6.5HELLO的进程执行-30-6.6HELLO的异常与信号处理-31-6.7本章小结-32-第7章HELLO的存储管理-34-7.1HELLO的存储器地址空间-34-7.2INTEL逻辑地址到线性地址的变换-段式管理-34-7.3HELLO的线性地址到物理地址的变换-页式管理-34-7.4TLB与四级页表支持下的VA到PA的变换-34-7.5三级CACHE支持下的物理内存访问-34-7.6HELLO进程FORK时的内存映射-35-7.7HELLO进程EXECVE时的内存映射-35-7.8缺页故障与缺页中断处理-35-7.9动态存储分配管理-35-7.10本章小结-35-第8章HELLO的IO管理-37-8.1LINUX的IO设备管理方法-37-8.2简述UNIXIO接口及其函数-37-8.3PRINTF的实现分析-37-8.4GETCHAR的实现分析-38-8.5本章小结-38-结论-38-附件-39-参考文献-40-第1章概述1.1Hello简介P2P是指fromprogramtoprocess，对原程序hello.c进行包括预处理，编译，汇编，链接的一系列操作后，形成可执行文件。执行该文件时，OS为该文件fork产生子进程（process）。020是指fromzerotozero。程序开始执行后，OS为其映射到虚拟内存，执行目标代码，然后mmap分配时间片，最终在硬件上实现。实现后由内核使内存等恢复到程序执行前的状态，即020。1.2环境与工具硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位开发与调试工具：gcc，vim，edb，readelf，HexEdit1.3中间结果Hello.c:源文件Hello.i:预处理之后的文件Hello.s:编译之后的汇编文件Hello.o：汇编输出文件Hello：链接输出文件。1.4本章小结本章简要介绍了文章的创作环境以及过程文件，简述hello程序从.c到可执行文件hello的大致过程。 第2章预处理2.1预处理的概念与作用概念：在编译之前预处理器cpp根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件。作用：1.宏替换，将宏名替换为文本；2.加载头文件；3.处理条件编译；4.处理特殊符号。2.2在Ubuntu下预处理的命令tu图2.3Hello的预处理结果解析预处理之后hello.c文件转化为hello.i文件，阅读hello.i，可见预处理对源文件保持main部分不变，头文件部分展开，宏定义也被处理。若文件存在嵌套关系，cpp也会逐层展开，这样hello.i就可以直接被译为.s文件。2.4本章小结本章主要介绍了预处理的概念和作用，并且对hello.c文件进行预处理且分析结果。第3章编译3.1编译的概念与作用概念：将程序员所撰写的编程语言翻译成汇编语言的过程：编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。其以高级程序设计语言书写的源程序作为输入，而以汇编语言或机器语言表示的目标程序作为输出。作用：通过语法检验，代码优化等过程，将程序员便于记忆和认知的编程语言转化为机器可识别的预言。注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令应截图，展示编译过程！3.3Hello的编译结果解析3.3.1汇编指令.file：声明源文件；.text：代码节.rodata：只读代码段；.align：数据或者指令的地址对齐方式；.string：声明一个字符串（.LC0，.LC1）；.global：声明全局变量；.type：声明一个符号是数据类型还是函数类型。3.3.2数据3.3.2.1字符串两个字符串都在只读数据段中，作为printf函数的参数。3.3.2.2全局变量函数声明一个全局变量i，编译器进行编译的时候将局部变量i放到堆栈中。3.3.2.3main函数参数argc作为用户传给main的参数，也是被放到堆栈里的。3.3.2.4各种立即数立即数直接体现在汇编代码中。3.3.2.5数组main函数的第二个参数是数组，每一个元素都是指向字符类型的指针。.L4中能看到它的起始地址等3.3.3全局变量hello.c文件中声明了全局函数intmain(intargc,char*argv[])，经过编译后，main函数中使用的字符串常量也被放在数据区。.globalmain说明main函数是全局变量。3.3.4赋值i=0;用mov实现，根据数据类型选择movqmovl等。3.3.5算数i++;用add实现，因为是int型。3.3.6关系操作3.3.6.1argc!=3;编译成cmpl$3,-20(%rbp)同时还有条件码判断是否需要跳转je.L23.3.6.2i<10;编译成cmpl$9,-4(%rbp)然后还设置条件码进行判断或跳转jle.L43.3.7控制转移指令3.3.7.1汇编为cmpl$3,-20(%rbp)je.L23.3.7.2 汇编为.L2:movl$0,-4(%rbp)jmp.L3.L3:cmpl$9,-4(%rbp)jle.L43.3.8函数操作调用函数时有以下操作：传递控制：进行过程B的时候，程序计数器必须设置为B的代码的起始地址，然后在返回时，要把程序计数器设置为A中调用B后面那条指令的地址。传递数据：A必须能够向B提供一个或多个参数B必须能够向A中返回一个值。分配和释放内存：在开始时，B可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。（假设函数A调用函数B）hello.C涉及的函数操作有：main函数，printf，exit，sleep，getchar函数main函数的参数是argc和argv；两次printf函数的参数恰好是那两个字符串exit参数是1，sleep函数参数是atoi（argv[3]）函数的返回值存储在%eax寄存器中。3.3.9类型转换atoi（argv[3]），将字符串类型转换为整数类型。此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~3.3.x等按照类型和操作进行分析只要hello.s中出现的属于大作业PPT中P4给出的参考C数据与操作，都应解析。3.4本章小结本章简要介绍了编译的概念和作用，以及编译阶段中编译器如何处理各种数据和操作，以及c语言中各种类型和操作所对应的的汇编代码并对hello.c和hello.s进行分析。第4章汇编4.1汇编的概念与作用概念：把汇编语言翻译成机器语言的过程。作用：汇编语言的诞生是由于机器代码难以记忆，所以用助记符代替操作码形成的方便记忆的语言，这种机器不能直接识别。用程序将其翻译为机器语言后，才可以被识别运行。注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。4.2在Ubuntu下汇编的命令4.3可重定位目标elf格式4.3.1ELFHeader以16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解##标题释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量等信息。4.3.2SectionHeaders:节头部表，包含了文件中出现的各个节的语义，包括节的类型、位置和大小等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小，同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。4.3.3.symtab：存放程序中定义和引用的函数和全局变量的信息。name是符号名称，对于可冲定位目标模块，value是符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址。size是目标的大小，type要么是数据要么是函数。Bind字段表明符号是本地的还是全局的。4.3.4重定位节.rela.text中包含.text节的重定位信息，在链接时程序将通过这些信息和代码提供的偏移找到正确的需要调用的函数地址。本程序中，需要重定位的包括.rodata节中的两个数据，全局变量sleepsecs,函数puts,exit,printf,sleep,getchar。分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。4.4Hello.o的结果解析通过对比可以发现，两者汇编代码有一些不同，而这些就是汇编过程实现的操作：1.o文件中每条语句都有了一个偏移量，便于跳转寻址。2去掉了面向程序员的助记符，跳转/调用指令后的函数名/助记符替换为了相对偏移地址。由于尚未进行链接，无法确定函数地址，所以偏移暂时为零。同时，在重定位节中添加相应条目。3为全局变量提供偏移量寻址。由于尚未进行链接，无法确定具体地址，所以偏移暂时为零。同时，添加重定位条目，等待链接。objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。4.5本章小结本章简要介绍了汇编的概念和作用，提供了Ubuntu下汇编的命令。对hello.s进行了汇编，生成了hello.o可重定位目标文件，并且分析了可重定位文件的ELF头、节头部表、符号表和可重定位节，比较了hello.s和hello.o反汇编代码的不同之处。第5章链接5.1链接的概念与作用概念：将各种代码和数据片段收集并合并成一个单一文件的过程，这个文件可以被加载到内存中执行。作用：使分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而实可以分解为更小的、更好管理的模块，可以独立地修改和编译单一模块。注意：这儿的链接是指从hello.o到hello生成过程。5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式以上。通过对比发现多了一个链接信息。分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。5.4hello的虚拟地址空间在edb中打开hello使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。5.5链接的重定位过程分析hello重定位的过程： 重定位节和符号定义链接器将所有类型相同的节合并在一起后，这个节就作为可执行目标文件的节。然后链接器把运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号，当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。重定位节中的符号引用这一步中，连接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。执行这一步，链接器依赖于可重定位目标模块中称为的重定位条目的数据结构。重定位条目当编译器遇到对最终位置未知的目标引用时，它就会生成一个重定位条目。代码的重定位条目放在.rel.txt。通过本图以及对比节头信息可以发现：1增加了一些外部函数。2增加了包括.init,.plt,.fini在内的一些节。3相对偏移地址变为了虚拟内存的地址。链接时，链接器通过符号表和节头了解到.data和.text在每个文件中的偏移和大小，进行合并，然后为新的合并出来的数据和代码节分配内存，并映射虚拟内存地址。最后修改对各种符号的引用，完成重定位。objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。结合hello.o的重定位项目，分析hello中对其怎么重定位的。5.6hello的执行流程使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。5.7Hello的动态链接分析动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。在调用共享库函数时，编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。GNU编译系统使用延迟绑定(lazybinding),将过程地址的绑定推迟到第一次调用该过程时。延迟绑定是通过GOT和PLT实现的。GOT是数据段的一部分，而PLT是代码段的一部分。两表内容分别为：PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。5.8本章小结本章简要介绍了链接的概念和作用以及Ubuntu下的链接命令。并对hello文件查看链接后的文件格式，对虚拟地址分配、重定位、动态链接等并分析。第6章hello进程管理6.1进程的概念与作用概念：操作系统对一个正在运行的程序的一种抽象。作用：一个程序在系统上运行时，操作系统会提供一种，程序在独占这个系统，包括处理器，主存，I/O设备的假象。处理器看上去在不间断地一条一条执行程序中的指令…这些假象都是通过进程的概念实现的。6.2简述壳Shell-bash的作用与处理流程Shell指操作界面，可以接收用户命令并调用相关程序。处理流程如下：读取输入命令并处理得到参数。判断输入命令是内置还是外部命令，内置命令立刻执行，外部命令则调用相关程序。根据后续输入向相应进程发送信号。处理接收到的信号，更新进程状态。6.3Hello的fork进程创建过程（Fork函数再进程的当前位置创建一个新进程，新进程具有与原进程完全相同的状态（除PID）。创建过程如下：为新进程复制父进程的堆栈等数据空间。创建新进程。6.4Hello的execve过程Execve函数在当前进程的上下文中加载并运行一个新程序。当读取文件出现错误时，返回原程序，否则不返回。具体步骤如下：根据第一个参数加载文件，通过启动代码对栈进行设置，并完成控制传递;顺序执行，用第二，三个参数调用main函数6.5Hello的进程执行系统执行进程时，内核可以暂停当前进程，并启用其他进程，这个过程称为调度，而这些进程以及它们的PC值所构成的序列就是逻辑控制流。当进程被执行时，内核代码不断地根据上下文信息，时间片等进行判断，并根据其结果转移控制权，完成调度。上下文信息：指内核重新启动一个被抢占的进程所需要的状态，由通用寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈等构成。时间片：一个进程执行它的控制流的每一时间段。结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。6.6hello的异常与信号处理hello程序出现的异常可能有：中断：在hello程序执行的过程中可能会出现外部I/O设备引起的异常。陷阱：陷阱是有意的异常，是执行一条指令的结果，hello执行sleep函数的时候会出现这个异常。故障：在执行hello程序的时候，可能会发生缺页故障。终止：终止时不可恢复的错误，在hello执行过程可能会出现DRAM或者SRAM位损坏的奇偶错误。在发生异常时会发出信号，比如缺页故障会导致OS发生SIGSEGV信号给用户进程，而用户进程以段错误退出。常见信号种类如下表所示。按下Ctrl+c的结果，在键盘上输入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况是终止前台作业按下ctrl-z的结果，输入ctrl-z默认结果是挂起前台的作业，hello进程并没有回收，而是运行在后台下，运行其他命令如下： 按下回车程序会一直执行直达用controlc停止为止。hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。6.7本章小结本章简要介绍了进程的概念和作用以及shell的处理流程。同时对hello文件分析了fork、execve、进程执行、异常以及信号处理过程。第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：由程序产生的与段相关的偏移地址。分为段标识符和段内偏移。线性地址：到物理地址的过渡，分为目录索引，页索引和页内偏移。虚拟地址：为更有效地管理内存并减少不同程序间内存冲突的问题，现代系统提供的一种对主存的抽象概念。物理地址：在主存中的地址。结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。7.2Intel逻辑地址到线性地址的变换-段式管理1．观察段选择符，0则转换的是GDT（全局）中的段，否则就是LDT（局部）中的段。2．根据相应寄存器，找到其起始地址。3．通过段标识符找到对应的基地址。4．用基地址加上偏移，得到线性地址。7.3Hello的线性地址到物理地址的变换-页式管理1．根据线性地址前十位找到对应页表的地址。2．根据线性地址中间十位找到对应页的起始地址。3．页的起始地址加上线性地址最后十二位，得到物理地址。7.4TLB与四级页表支持下的VA到PA的变换将VA分为四段。依次通过每段地址找到对应的PML4,PGD,PMD,PTE表，找到对应地址，组合得到PA。7.5三级Cache支持下的物理内存访问物理地址分为标记，组索引和块偏移。首先，在L1中匹配组索引位，若匹配成功，则根据标记和偏移的匹配结果决定缺失或是命中。若组索引匹配不成功，则进入下一级cache，重复直至进入内存。7.6hello进程fork时的内存映射Fork会为新进程（子进程）复制一个与父进程完全相同只读数据空间，并为其分配另一片内存和虚拟地址。分配时会将其标记为私有，防止过程中被父进程影响。7.7hello进程execve时的内存映射调用Execve时，系统首先删除了当前进程中用户部分已有的结构，然后映射私有区域（建立新的文件结构，包括.data在内的各种节），共享区域（当前进程的动态链接），并设置PC。7.8缺页故障与缺页中断处理1．段错误：地址不合法，即无法匹配到已有的区域结构中；2．非法访问：没有应有的读写权限；3．正常缺页：选择一页进行替换。7.9动态存储分配管理分配器有两种风格，显示分配器（要求应用显式地释放任何已分配的块），隐式分配器（要求分配器检测一个已分配块是否仍然需要，不需要则释放）。分配策略：1．空闲链表：（1）隐式：在每块的头，尾部增加32位存储块大小，以及是否空闲。（2）显式：在隐式的基础上在头部增加对前后空闲块的指针。（3）分离：同时维护多个空闲链表。2．带边界标记的合并：利用每块头尾的大小和空闲状态信息合并空闲块。3．无合适空闲块时，申请额外的堆空间。Printf会调用malloc，请简述动态内存管理的基本方法与策略。7.10本章小结本章简要介绍了hello的存储器的地址空间，介绍了四种地址空间的差别和地址的相互转换。同时介绍了hello的四级页表的虚拟地址空间到物理地址的转换。阐述了三级cashe的物理内存访问、进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件包括：1.普通文件（Is-al第一个属性为“-”）2.目录文件（Is-al第一个属性为“d”）3.设备文件设备管理：unixio接口包括：1.开关文件2.读写文件3.改变当前文件的位置8.2简述UnixIO接口及其函数 open：打开已存在的文件或建立新文件。close：关闭已打开的文件，会返回结果状态。ssize_tread：在文件的指定位置赋值。8.3printf的实现分析Vsprintf：接受一个格式化的命令，并把制定的匹配的参数格式化输出。Write：把字符串中n个元素的值写到终端（n为第二个参数）系统调用：显示格式化的字符串。https://www.cnblogs.com/pianist/p/3315801.htmlsyscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。于是我们的打印字符串就显示在了屏幕上。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章简要介绍了hello文件的I/O管理，包括设备管理方法，接口函数，读写函数的实现分析。结论Hello从原程序.c文件经过预处理，编译，汇编，链接得到了可执行文件。执行时，通过os对命令的处理结果，hello被分配到了自己的存储空间，虚拟内存地址和时间片。过程中，I/O不断接受信号并对其进行处理。运行结束后，内核清除已分配的数据空间，还原系统状态。附件列出所有的中间产物的文件名，并予以说明起作用。Hello.c:源文件Hello.i:预处理输出文件Hello.s:编译输出文件Hello.o：汇编输出文件Hello：链接输出文件参考文献为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 

CS大作业 

HIT-CSAPP2021大作业 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 xxxxxxxxxx 班 级 xxxxxx 学 生 xxx 指导教师 xxx 计算机科学与技术学院 2021年6月 摘 要 本文以hello小程序为例，通过对其在Linux系统下的P2P、020过程的分析梳理，来完成对计算机系统课程的整体内容的梳理，借由Ubuntu虚拟机，gcc、gdb、edb等工具的操作过程，体现个人对计算机系统课程的学习体会与理解，展示各人的收获。 关键词：hello程序的一生；计算机系统；Linux；Ubuntu 目 录 第1章概述-4- 1.1Hello简介-4- 1.2环境与工具-4- 1.3中间结果-5- 1.4本章小结-5- 第2章预处理-6- 2.1 预处理的概念与作用-6- 2.2在Ubuntu下预处理的命令-6- 2.3Hello的预处理结果解析-6- 2.4本章小结-7- 第3章编译-8- 3.1编译的概念与作用-8- 3.2在Ubuntu下编译的命令-8- 3.3Hello的编译结果解析-8- 3.3.1字符串-9- 3.3.2全局函数-10- 3.3.3赋值操作-10- 3.3.4算术操作-10- 3.3.5关系操作-11- 3.3.6控制转移指令-11- 3.3.7函数操作-12- 3.3.8类型转换-13- 3.4本章小结-13- 第4章汇编-14- 4.1汇编的概念与作用-14- 4.2在Ubuntu下汇编的命令-14- 4.3可重定位目标elf格式-14- 4.4Hello.o的结果解析-16- 4.5本章小结-17- 第5章链接-18- 5.1链接的概念与作用-18- 5.2在Ubuntu下链接的命令-18- 5.3可执行目标文件hello的格式-18- 5.4hello的虚拟地址空间-20- 5.5链接的重定位过程分析-22- 5.6hello的执行流程-23- 5.7Hello的动态链接分析-23- 5.8本章小结-24- 第6章hello进程管理-25- 6.1进程的概念与作用-25- 6.2简述壳Shell-bash的作用与处理流程-25- 6.3Hello的fork进程创建过程-25- 6.4Hello的execve过-25- 6.5Hello的进程执行-26- 6.6hello的异常与信号处理-26- 6.7本章小结-30- 第7章hello的存储管理-31- 7.1hello的存储器地址空间-31- 7.2Intel逻辑地址到线性地址的变换-段式管理-31- 7.3Hello的线性地址到物理地址的变换-页式管理-31- 7.4TLB与四级页表支持下的VA到PA的变换-32- 7.5三级Cache支持下的物理内存访问-34- 7.6hello进程fork时的内存映射-35- 7.7hello进程execve时的内存映射-35- 7.8缺页故障与缺页中断处理-35- 7.9动态存储分配管理-35- 7.10本章小结-36- 第8章hello的IO管理-37- 8.1Linux的IO设备管理方法-37- 8.2简述UnixIO接口及其函数-37- 8.3printf的实现分析-37- 8.4getchar的实现分析-37- 8.5本章小结-38- 结论-38- 附件-39- 参考文献-40- 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P：FromProgramtoProcess Program：在编辑器中编写hello.c的具体代码内容 Process：在Linux中，先通过预处理器（cpp）修改原始的c文件得到另一个以.i为文件扩展名的C程序；接着，编译器（ccl）将文本文件hello.i翻译成hello.s，这个文件包含一个汇编语言程序；然后，汇编器（as）将.s文件翻译成机器语言指令，将这些指令打包成可重定位目标程序的格式，并将结果保存在hello.o文件中；最后链接器（ld）负责处理.o文件的合并，来实现函数的正确调用，并得到最后的可执行文件hello，可以被加载到内存中由系统执行。 020：FromZerotoZero shell接受到./hello的指令之后就调用fork开辟进程，execve映射虚拟内存，进入程序入口后程序开始载入物理内存。之后程序由CPU控制其逻辑流的运行，运行结束后，shell父进程负责回收资源，这就是hello的020. 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 硬件环境： 软件环境： VirtualBox；Ubuntu20.04LTS64位 开发工具： VisualStudio201964位；CodeBlocks；vim+gcc 调试工具： gdb；edb 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 中间结果文件文件作用hello.i预处理得到的文件ASCII码的中间文件hello.sASCII汇编语言文件hello.oas得到可重定位目标文件Disas_hello.s反汇编得到的文本文件elf.txthello.o的elf文件hellold得到可执行目标文件hello_5.3.elfhello的elf文件hello_objdump.shello的反汇编文件 1.4本章小结 本章简单阐述了Hello的P2P，020的整个过程，介绍了编写本文过程所处的软硬件环境和生成的中间文件。 第2章预处理 2.1 预处理的概念与作用 预处理的概念： 预处理器（cpp）根据以字符#开头的命令，修改原始的C程序，试图解释为预处理指令(preprocessingdirective)。 ISOC/C++要求支持的预处理指令包括： #if、#ifdef、#ifndef、#else、#elif、#endif（条件编译）、#define（宏定义）、#include（源文件包含）、#line（行控制）、#error（错误指令）、#pragma（和实现相关的杂注）以及单独的#（空指令）。 预处理指令一般被用来使源代码在不同的执行环境中被方便的修改或者编译。 预处理的作用： 宏定义：宏定义将代码中的宏名与实际字符串进行替换，可以增强代码的可读性；文件包含处理：将include头文件复制到#处替换，减少重复的工作，加强代码模块化；条件编译处理：决定哪些具体代码会被编译处理。 2.2在Ubuntu下预处理的命令 cpphello.c>hello.i 截图2-1 截图2-2 2.3Hello的预处理结果解析 浏览hello.i文件可发现，只有28行的源码已经扩展至3065行，hello.i程序的开始是c程序头文件stdio.hunistd.hstdlib.h的依次展开，这三个头文件都被复制进来了。 截图2-3 2.4本章小结 本章简单介绍的与处理的概念及作用，完成了对hello.c文件的预处理操作，并简单解析了hello.i的预处理结果。 第3章编译 3.1编译的概念与作用 编译的概念：编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。其以高级程序设计语言书写的源程序作为输入，而以汇编语言或机器语言表示的目标程序作为输出。这个过程称为编译，同时也是编译的作用。 编译的作用：编译程序的基本功能是把源程序(高级语言)翻译成目标程序。除了基本功能之外，编译程序还具备语法检查、调试措施、修改手段、覆盖处理、目标程序优化、不同语言合用以及人际联系等重要功能。 3.2在Ubuntu下编译的命令 截图3-1 3.3Hello的编译结果解析 截图3-4、3-5 局部变量i main函数声明了一个局部变量i，编译器进行编译的时候会将局部变量i存在堆栈中。如图所示，局部变量i放在栈上-4（%rbp）的位置。 截图3-6 main函数 参数argc作为用户传给main的参数存放在堆栈中。 立即数 立即数直接体现在汇编代码中 数组char*argv[] 数组char*argv[]是作为main函数的第二个参数，其中的每个元素都是一个指向字符类型的指针。数组的起始地址存放在栈中-32（%rbp）的位置，被两次调用将参数传给printf函数 截图3-7 其中： movq-32（%rbp）,%rax表示数组argv存放的位置-32（%rbp） movq（%rax），%rdx movq（%rax），%rax分别获取argv[1]和argv[2]的地址 movq（%rax），%rsi 3.3.2全局函数 由c程序可知，hello.c声明了一个全局函数intmain(intargc,char*argv[])，经过编译之后，main函数中使用的字符串常量也被存放在数据区。 截图3-8 这行汇编代码说明main函数是全局函数。 3.3.3赋值操作 hello.c程序中的赋值操作为i=0 该操作在汇编代码中由mov指令实现，具体为： movb:一个字节 movw：两个字节 movl：四个字节 movq：八个字节 3.3.4算术操作 hello.c程序中的算术操作为：i++。因为i为int类型，故汇编代码只用addl就能实现其他的操作有 指令效果leaqS,DD=&SINCDD+=1DECDD-=1NEGDD=-DADDS,DD=D+SSUBS,DD=D-S 3.3.5关系操作 （1）argc!=3;是在一条件语句中的条件判断：argc!=3，进行编译时，这条指令被编译为：cmpl$3,-20(%rbp)，同时这条cmpl的指令还有设置条件码的作用，当根据条件码来判断是否需要跳转到分支中。 截图3-9 （2）i < 8，在hello.c作为判断循环条件，在汇编代码被编译为：cmpl$9，-4(%rbp)，计算i-7然后设置条件码，为下一步jle利用条件码进行跳转做准备。 截图3-10 3.3.6控制转移指令 首先设置条件码，然后根据条件码来进行控制转移。hello.c中有以下控制转移指令： 判断i是否为3，如果i等于3，则不执行if语句，否则执行if语句： 截图3-11 for(i = 0;i < 8;i++)，通过每次判断i是否满足小于8来判断是否需要跳转至循环语句中： 截图3-12 第一处画圈：i赋初值0，然后无条件跳转至判断条件的代码中 第二处画圈：判断i是否符合循环的条件，符合直接跳转至循环体的内部，即L4 3.3.7函数操作 调用函数时有以下操作： （假设函数P调用函数Q） （1）传递控制：进行过程Q的时候，程序计数器设置为Q的代码的起始地址；返回时，把程序计数器设置为P中调用Q后面那条指令的地址。 （2）传递数据：P能够向Q提供一个或多个参数，而Q能够向P中返回一个返回值。 （3）分配和释放内存：开始时，Q可能需要为局部变量分配空间，而在返回前需释放这些空间。 hello.c程序中涉及的函数操作有： main函数，printf，exit，sleep，getchar函数 main函数的参数是argc和argv；两次printf函数的参数恰好是那两个字符串 exit参数是1，sleep函数参数是atoi（argv[3]） 函数的返回值存储在%eax寄存器中。 3.3.8类型转换 hello.c中涉及的类型转换是：atoi（argv[3]），将字符串类型转换为整数类型其他的类型转换还有int、float、double、short、char之间的转换。 3.4本章小结 本章主要阐述了编译阶段中编译器是如何处理各种数据和操作的，以及简单分析了c语言中各种类型和操作所对应的的汇编代码。 第4章汇编 4.1汇编的概念与作用 汇编的概念：驱动程序运行汇编器as，将汇编语言翻译成机器语言的过程称为汇编，同时这个机器语言文件也是可重定位目标文件。 汇编的作用：汇编是将高级语言转化为机器可直接识别执行的代码文件的过程，汇编器将.s汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码。 4.2在Ubuntu下汇编的命令 截图4-1 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 截图4-2 ELF头：包含了系统信息、编码方式、ELF头大小、节的大小和数量等信息。 截图4-3 节头部表：描述了.o文件中出现的各个节的类型、位置、所占空间大小等信息。 截图4-4 重定位节：表述了各个段引用的外部符号等，在链接时，需要通过重定位节对这些位置的地址进行修改。链接器会通过重定位条目的类型判断该使用什么养的方法计算正确的地址值，通过偏移量等信息计算出正确的地址。 hello.c需要重定位的信息有：.rodata中的模式串、puts、exit、printf、slepsecs、sleep、getchar等符号。 截图4-5 符号表：symtab是一个符号表，负责存放在程序中定义和引用的函数和全局变量的信息。 截图4-6 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 截图4-7 截图4-8 数的表示：hello.s中的操作数时十进制，hello.o反汇编代码中的操作数是十六进制。分支转移：跳转语句之后，hello.s中是.L2和.LC1等段名称，而反汇编代码中跳转指令之后是相对偏移的地址，即间接地址。函数调用：hello.s中，call指令使用的是函数名称，而反汇编代码中call指令使用的是main函数的相对偏移地址。因为函数只有在链接之后才能确定运行执行的地址，因此在.rela.text节中为其添加了重定位条目。 4.5本章小结 本章对hello.s的结果进行了阐述，分析了可重定位文件的ELF头、节头部表、符号表和可重定位节，比较了hello.s和hello.o反汇编代码的区别，分析了机器语言的构成与汇编语言的映射关系。 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种不同文件的代码和数据部分收集（符号解析和重定位）起来并组合成一个单一文件的过程。 链接的作用：令源程序节省空间而未编入的常用函数文件进行合并，生成可以正常工作的可执行文件。这令分离编译成为可能，节省了大量的工作空间。 5.2在Ubuntu下链接的命令 指令： ld -ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 截图5-1 5.3可执行目标文件hello的格式 指令： ELF头：hello的文件头和hello.o文件头的不同之处如下图标记所示，Type类型为EXEC表明hello是一个可执行目标文件，有27个节头。 截图5-2 节头：描述各个节的大小、偏移量和其他属性。链接器链接时，会将各个文件的相同段合并成一段，并且根据该段的大小以及偏移量重新设置各个符号的地址。 截图5-3 截图5-4 重定位节 截图5-5 符号表 截图5-6 5.4hello的虚拟地址空间 在edb中加载hello可执行文件 截图5-7 观察edb的DataDump窗口。窗口显示虚拟地址由0x400000开始，到0x400fff结束，这之间的每一个节对应5.3中的每一个节头表的声明。 截图5-8 观察edb的Sympols Viewer，发现确实从虚拟地址从0x400000开始和5.3节中的节头表是对应的。 截图5-9 根据5.3中的的节头，可以在edb中找到各个节的信息。比如.rodata节，虚拟地址开始于0x402000，大小为0x2f 截图5-10 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 指令： 截图5-11 hello与hello.o的不同： 截图5-12 hello中增加了.init和.plt节，和一些节中定义的函数。hello中链接加入了在hello.c中用到的如exit、printf、sleep、getchar等函数。hello反汇编文件中的地址是虚拟地址，而hello.o反汇编节中的是相对偏移地址。hello中无hello.o中的重定位条目，并且跳转和函数调用的地址在hello中都变成了虚拟内存地址。对于hello.o的反汇编代码，函数只有在链接之后才能确定运行执行的地址，因此在.rela.text节中为其添加了重定位条目。 链接的过程： 链接就是链接器（ld）将各个目标文件（各种.o文件）组装在一起，文件中的各个函数段按照一定规则累积在一起。 链接的重定位过程说明： 要合并相同的节，确定新节中所有定义符号在虚拟地址空间中的地址，还要对引用符号进行重定位（确定地址），修改.text节和.data节中对每个符号的引用（地址），而这些需要用到在.rel_data和.rel_text节中保存的重定位信息。 5.6hello的执行流程 截图5-13 子程序地址： 7efbff4d8ea07efbff4e7630004004c0004004c0004004a000400500004004d0004004f07efbff122120 5.7Hello的动态链接分析 对于动态共享链接库中PIC函数，编译器没有办法预测函数的运行时地址，所以需要为其添加重定位记录，并等待动态链接器处理。为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT和全局偏移量表GOT实现函数的动态链接。其中GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。 在elf文件中可以找到： 截图5-14 edb执行init之前的地址： 截图5-15 edb在执行init之后的地址： 截图5-16 GOT表位置在调用dl_init之前0x600920后的16个字节均为0，调用后发生了变化。 之后的函数调用时，首先跳转到PLT执行.plt中逻辑，第一次访问跳转时，GOT地址为下一条指令，将函数序号压栈，然后跳转到PLT[0]，在PLT[0]中将重定位表地址压栈，然后访问动态链接器，在动态链接器中使用函数序号和重定位表确定函数运行时地址，重写GOT，再将控制传递给目标函数。之后如果对同样函数调用，第一次访问跳转直接跳转到目标函数。 5.8本章小结 本章温习了在linux中链接的过程。通过查看hello的虚拟地址空间，对比hello与hello.o的反汇编代码，进一步掌握了链接与中重定位的过程；遍历了整个hello的执行过程，在最后对hello进行了动态链接分析 第6章hello进程管理 6.1进程的概念与作用 进程的概念： 进程是执行中程序的抽象，是一个执行中程序的实例。 进程的作用： 能够实现计算机并行实现不同任务的构想，使得程序的模式切换更加自如迅速，效率更高。 进程提供给应用程序的关键抽象：一个独立的逻辑控制流，如同程序独占处理器；一个私有的地址空间，如同程序独占内存系统。 6.2简述壳Shell-bash的作用与处理流程 作用： 解释命令，连接用户和操作系统以及内核。 流程： ·终端进程读取用户由键盘输入的命令行。 ·分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量 ·检查第一个(首个、第0个）命令行参数是否是一个内置的shell命令 ·如果不是内部命令，调用fork()创建新进程/子进程 ·在子进程中，用步骤2获取的参数，调用execve()执行指定程序。 ·如果用户没要求后台运行(命令末尾没有&号）否则shell使用waitpid（或wait…等待作业终止后返回。 ·如果用户要求后台运行(如果命令末尾有&号），则shell返回； 6.3Hello的fork进程创建过程 在shell的命令行，用户完成输入命令。shell在解析输入命令之后创建argv、envp等参数列表，以及参数个数argc。shell作为父进程创建新子进程。子进程与父进程拥有完全相同的虚拟内存地址以及副本，但虚拟地址确是独立的，而且PID也不相同。 6.4Hello的execve过 fork之后子进程调用execve函数在当前进程的上下文中加载并运行一个新程序即hello程序。execve加载并运行可执行目标文件，且带参数列表argv和环境变量列表envp，并将控制传递给main函数。 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 逻辑控制流：一系列程序计数器PC的值的序列叫做逻辑控制流，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 用户模式和内核模式：shell使得用户可以有机会修改内核，所以需要设置一些防护措施来保护内核，如限制指令的类型和可以作用的范围。 上下文切换：上下文就是内核重新启动一个被抢占的进程所需要的状态，是一种比较高层次的异常控制流。 开始Hello运行在用户模式，收到信号后进入内核模式，运行信号处理程序，之后再返回用户模式。运行过程中，cpu不断切换上下文，使运行过程被切分成时间片，与其他进程交替占用cpu，实现进程的调度。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 hello的异常： 1）中断：来自处理器外部的I/O设备的信号的结果。 键盘上敲击CTRL-C或者CTRL-Z 陷阱：有意的，执行指令的结果（例如：系统调用） 产生的信号： SIGINT,SIGSTP,SIGCONT,SIGWINCH 运行截图： Ctrl+C（截图6-1） Ctrl+Z（截图6-2） Ctrl+Z后ps、jobs（截图6-3） 截图6-4 截图6-5 截图6-6 截图6-7 Pstree（截图6-8） fg（截图6-9） kill（截图6-10） 6.7本章小结 本章概述了进程的概念，简要介绍了shell处理过程的方式，介绍了fork和execve两个函数的执行过程以及信号异常的处理。 第7章hello的存储管理 7.1hello的存储器地址空间 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 逻辑地址：格式为“段地址:偏移地址”，是CPU生成的地址，在内部和编程使用，并不唯一。 物理地址：加载到内存地址寄存器中的地址，内存单元的真正地址。CPU通过地址总线的寻址，找到真实的物理内存对应地址。在前端总线上传输的内存地址都是物理内存地址。 虚拟地址：有时我们也把逻辑地址称为虚拟地址。因为与虚拟内存空间的概念类似，逻辑地址也是与实际物理内存容量无关的，是hello中的虚拟地址。 物理地址：指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么hello的线性地址会使用页目录和页表中的项变换成hello的物理地址；如果没有启用分页机制，那么hello的线性地址就直接成为物理地址了。 7.2Intel逻辑地址到线性地址的变换-段式管理 分段功能在实模式和保护模式下有所不同。 实模式：逻辑地址=线性地址=实际的物理地址。段寄存器存放真实段基址，同时给出32位地址偏移量，则可以访问真实物理内存。 保护模式：线性地址还需要经过分页机制才能够得到物理地址，线性地址也需要逻辑地址通过段机制来得到。 段寄存器用于存放段选择符，通过段选择符可以得到对应段的首地址。处理器在通过段式管理寻址时，首先通过段描述符得到段基址，然后与偏移量结合得到线性地址，从而得到了虚拟地址。 7.3Hello的线性地址到物理地址的变换-页式管理 将各进程的虚拟空间划分成若干个长度相等的页(page)，页式管理把内存空间按页的大小划分成片或者页面（pageframe），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。 7.4TLB与四级页表支持下的VA到PA的变换 使用K级页表的地址翻译 截图7-1 四级页表翻译 截图7-2 针对corei7页表翻译 截图7-3 Corei7 1-3级页表条目格式 截图7-4 其中，每个条目引用一个4KB子页表: 1）P:子页表在物理内存中(1)不在(0). 2）R/W:对于所有可访问页，只读或者读写访问权限. 3）U/S:对于所有可访问页，用户或超级用户(内核)模式访问权限. 4）WT:子页表的直写或写回缓存策略. 5）A: 引用位(由MMU在读或写时设置，由软件清除). 6）PS: 页大小为4KB或4MB(只对第一层PTE定义). 7）Pagetablephysicalbaseaddress:子页表的物理基地址的最高40位(强制页表4KB对齐) 8）XD:能/不能从这个PTE可访问的所有页中取指令。 Corei7第4级页表条目格式 截图7-5 P:子页表在物理内存中(1)不在(0). R/W:对于所有可访问页，只读或者读写访问权限. U/S:对于所有可访问页，用户或超级用户(内核)模式访问权限. WT:子页表的直写或写回缓存策略. A:引用位(由MMU在读或写时设置，由软件清除). D:修改位(由MMU在读和写时设置，由软件清除) Pagetablephysicalbaseaddress:子页表的物理基地址的最高40位(强制页表4KB对齐) XD:能/不能从这个PTE可访问的所有页中取指令. 7.5三级Cache支持下的物理内存访问 1、CPU给出VA 2、MMU用VPN到TLB中找寻PTE，若命中，得到PA；若不命中，利用VPN（多级页表机制）到内存中找到对应的物理页面，得到PA。 3、PA分成PPN和PPO两部分。利用其中的PPO，将其分成CI和CO，CI作为cache组索引，CO作为块偏移，PPN作为tag。 先访问一级缓存，不命中时访问二级缓存，再不命中访问三级缓存，再不命中访问主存，如果主存缺页则访问硬盘 截图7-6 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 删除已存在的用户区域。 映射私有区域：为新程序的代码、数据、.bss和栈区域创建新的区域结构。 映射共享区：hello与系统执行文件链接映射到共享区域。 设置程序计数器PC：设置当前进程上下文中的PC，指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障是一种常见的故障，要访问的主页不在主存，需要操作系统调入才能访问。缺页中断处理函数为do_page_fault函数。 截图7-7 7.9动态存储分配管理 基本方法与策略：通过维护虚拟内存（堆），一种是隐式空闲链表，一种是显式空闲链表。显式空闲链表法是malloc(size_tsize)每次声明内存空间都保证至少分配size_t大小的内存，双字对齐，每次必须从空闲块中分配空间，在申请空间时将空闲的空间碎片合并，以尽量减少浪费。 7.10本章小结 本章主要介绍了hello的存储器的地址空间，介绍了四种地址空间的差别和地址的相互转换。同时介绍了hello的四级页表的虚拟地址空间到物理地址的转换。简要阐述了三级cashe的物理内存访问、进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理以及动态存储分配管理。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件：所有的I/O设备都被模型化为文件，甚至内核也被映射为文件 设备管理：unixio接口：所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 Linux以文件的方式对I/O设备进行读写，将设备均映射为文件。对文件的操作，内核提供了一种简单、低级的应用接口，即UnixI/O接口。 打开文件：intopen(char*filename,intflags,mode_tmode); 关闭文件：intclose(intfd); 读文件：ssize_tread(intfd,void*buf,size_tn); 写文件：ssize_twrite(intfd,constvoid*buf,size_tn); 8.3printf的实现分析 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法、UnixIO接口及函数，简要分析了printf和getchar函数的实现。 结论 hello程序的过程可总结如下： 1、编写代码：用高级语言写.c文件 2、预处理：hello.c经过预编译，拓展得到hello.i文本文件 3、编译：由.i文件生成.s汇编文件 4、汇编：经过汇编，.s文件被翻译为机器语言指令，并打包成可重定位目标程序hello.o 5、链接：将.o可重定位目标文件和动态链接库链接成可执行目标程序hello。P2P过程完成。 6、运行：在shell中输入命令 1）创建子进程：shell嗲用fork为程序创建子进程 2）加载：shell调用execve函数,将hello程序加载到该子进程，映射虚拟内存 3）执行指令：CPU为进程分配时间片，加载器将计数器预置在程序入口点，则hello可以顺序执行自己的逻辑控制流 4）访问内存：MMU将虚拟内存地址映射成物理内存地址，CPU通过其来访问 5）动态内存分配：根据需要申请动态内存 6）信号：shell的信号处理函数可以接受程序的异常和用户的请求 7、终止：执行完成后父进程回收子进程，内核删除为该进程创建的数据结构 至此，hello运行结束。 附件 中间结果文件文件作用hello.i预处理得到的文件ASCII码的中间文件hello.sASCII汇编语言文件hello.oas得到可重定位目标文件Disas_hello.s反汇编得到的文本文件elf.txthello.o的elf文件hellold得到可执行目标文件hello_5.3.elfhello的elf文件hello_objdump.shello的反汇编文件 注：由于后期虚拟机运行突然出现问题，所以最后的附件是在同学的虚拟机下生成的，可能与报告中的截图内容存在一些冲突。 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42. [2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998 [1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL]. Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/ collection/anatmorp. （参考文献0分，缺失-1分） 

2021-06-29 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机专业学 号1190201722班 级1936603学生武晏峰 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文在linux操作系统下对C语言程序hello.c的运行全过程进行了分析。分析了从c文件转化为可执行文件过程中的预处理、编译、汇编和链接阶段，和可执行文件执行过程中的进程管理、存储空间管理和I/O管理的原理。（摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。P2P：FromProgramtoProcess在编译器的处理下，hello.c文件经过预处理、编译、汇编、链接变为可执行文件（program），然后由shell为其建立一个新的进程（process）并运行他。020：FromZerotoZero在他还没有被执行的时候（zero），在shell通过fork为其创建新的子进程后，通过exceve在进程的上下文中加载并运行hello，把他映射到虚拟内存，并载入物理内存，在CPU下执行，在程序运行结束后，父进程会对其进行回收，内核把他从系统中清除（zero）。1.2环境与工具列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位开发工具：GDB/OBJDUMP；EDB；gedit+gcc；CodeBlocks64位等。1.3中间结果列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。1.4本章小结本章简要介绍了Hello的P2P，020的整个过程以及实验的环境、工具和中间产物。（第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理是指在进行第一次编译之前所做的工作，预处理器根据以字符#开头的命令，如#define（宏定义），#include（文件包含），#ifdef（条件编译），修改原始的C程序。例如将头文件从库中提取出来插入到程序文本中，得到完整的源程序，通常以.i作为文件的扩展名。2.2在Ubuntu下预处理的命令gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析可见hello.i与hello.c相比，代码大大增多，而源程序hello.c中除注释和头文件部分位于hello.i的最后。 Cpp到默认的环境变量下寻找stdlib.h,打开/usr/include/stdlib.h,其中可能仍然会有#define语句，cpp对此进行递归展开，最终hello.i文件中只有对外部变量的声明，函数声明，没有宏定义。 2.4本章小结本章介绍了hello.c在编译前需要做的准备工作，预处理的内容与结果。cpp（预处理器）将hello.c转换为hello.i文件。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译是指将预处理后的程序转化为特定的汇编程序的过程。输入.i文件，输出.s文件。这个过程将较偏向自然语言的c文件，转换为偏机器语言的汇编文件，为下一步的汇编生成机器码创造了条件，同时也保持了一定的可读性，和微弱的可移植性。3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 1.程序中的字符串分别是：1）“Usage:Hello学号姓名！\n”，printf传入的格式化参数。在hello.s中声明如下图，注意到字符串使用UTF-8的格式编码的，一个汉字在UTF-8中占三个字节。2）“Hello%s%s\n”，仍然是由printf函数传入的格式化参数，hello.s声明如下。2.数字常量：hello.s中出现的常量有以下几个地方：对全局变量赋值2，将argc与3比较，循环中每次给i加1，循环中止条件i<10的判断。 3.数字变量：全局变量：有一个全局变量intsleepsecs，可见它作为全局变量被放在.data节中，设置了大小为4字节，并初始化为2。 局部变量：中局部变量intargc存放在栈中-20(%rbp)的位置，通过与3的比较操作可以找到它；局部变量inti存放在栈中-4(%rbp)的位置，从与9的比较和循环中每次加1的操作可以找到它；还有一个局部变量数组charargv[]，可以通过L4（循环部分）中输出函数前的两次取值找到argv[1],argv[2]的位置。 4.赋值：赋值操作共有两个，一个是对全局变量sleepsecs的赋值，源程序里令intsleepsecs=2.5。而因为sleepsecs为整型变量，所以编译时直接对其赋值为2。另一个是对局部变量i赋值，之前已经得知i存在栈中-4(%rbp)的位置。5.类型转换：对全局变量sleepsecs的赋值存在一个隐式类型转换。intsleepsecs=2.5因为它把一个浮点数赋给整型变量，所以它会把浮点数2.5强制转换为2（浮点数转整数时向零舍入）。6.算术操作：存在一个算术操作i++，即在每次循环中对变量i加1，之前已经得知i存在栈中-4(%rbp)的位置，那么通过add每次对-4(%rbp)中内容加1即可。7.关系操作：存在两个关系操作，第一个是判断argc!=3，即将argc(栈中-20(%rbp)的内容)与3通过cmp进行比较。第二个是判断i<10，即将i(栈中-4(%rbp)的内容)与9通过cmp进行比较（即判断i<=9）。8.数组/指针/结构操作：存在一个对数组argv的操作，在printf函数中引用了数组argv的两个元素argv[1],argv[2],可以通过L4（循环部分）中输出函数前的两次取值找到argv[1],argv[2]的位置。9.控制转移：第一处是判断argv是否等于3，若不等于，则继续执行，若等于，则跳转至L2处（循环前对i初始化）继续执行。第二处是对i初始化为0后的无条件跳转，以跳到L4,即循环部分代码。第三处是判断是否达到循环终止条件（i<10），这里用i与9进行比较，若小于等于则跳回L4重复循环，否则执行循环外的下一步。这里将i<10的比较改为了与其等价的i<=9。10.函数调用：共有三次函数调用，第一次调用puts函数输出一个字符串常量，参数存在%rdi中；第二次调用printf函数输出字符串常量以及两个局部变量数组的元素，字符串常量作为参数1存在%rdi中，两个数组元素作为参数2、3分别存在%rsi和%rdx中。第三次调用sleep函数，以sleepsecs为参数，参数存在%edi中。3.4本章小结汇编语言是高级语言和机器语言的中介，一方面具有可读性，但是不像高级语言那样易懂，但是一方面反映了机器的一些特征，汇编语言一定程度上翻译了指令集体系的架构。但是从高级语言到汇编语言的映射转化是不容易的。ccl(编译器)将hello.i转换成hello.s文件。 （第3章2分） 第4章汇编4.1汇编的概念与作用 汇编器as将hello.s翻译成机器语言指令，把这些指令打包成一种叫可重定位目标程序的格式，并将结果保存在目标文件hello.o中。（hello.o是一个二进制文件）。作用：把汇编语言翻译成机器语言，用二进制码代替汇编语言中的符号，即让它成为机器可以直接识别的程序。4.2在Ubuntu下汇编的命令ashello.s-ohello.o 4.3可重定位目标elf格式分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。readelf-ahello.oELF可重定位目标文件中首先是ELF头，它以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息：包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量。 然后是节头部表，它描述了不同节的位置和大小，目标文件中的每一个节都有一个固定大小的条目。 重定位项目,其中.rela.text节是一个.text节中位置的列表。当链接器把这个目标文件和其他文件组合时，需要修改这些位置。.rela.eh_frame节包含了对en_frame节的重定位信息。其中，Offset是需要被修改的引用的字节偏移（在代码节或数据节的偏移），Info指示了重定位目标在.symtab中的偏移量和重定位类型，Type表示不同的重定位类型，例如图中R_X86_64_PC32就表示重定位一个使用32位PC相对地址的引用。Sym.Name表示被修改引用应该指向的符号，Append用于一些类型的重定位要使用它对被修改引用的值做偏移调整。可见下图中，在链接时需要对.rodata中的两个字符串常量（用于printf函数中），全局变量sleepsecs，以及函数puts，exit，printf，sleep，getchar进行重定位。 符号表,它存放了程序中定义和引用的函数和全局变量的信息（不包含局部变量的条目）。 4.4Hello.o的结果解析通过objdump可以得到hello.o的反汇编代码，在汇编时从main开始（地址为0）依次为每一行指令都分配了一个地址。可以在下图中看到汇编所得到的机器语言，机器语言由二进制的操作码和操作数构成，图中给出了一个示例。每一条汇编指令能翻译成一条对应的机器指令，汇编语言可以看作是二进制机器语言的助记符。 1）可以看出，汇编语言中操作数是十进制的，而机器语言反汇编得到的操作数是十六进制的。2）对全局变量（即字符串常量）的引用，汇编语言中是用的全局变量所在的那一段的名称加上%rip的值，而hello.o中用的是0加%rip的值，因为当前为可重定位目标文件，之后还需经过重定位方可确定其具体位置，所以这里都用0来代替。3）对分支转移，hello.s的汇编语言中在跳转指令后用对应段的名称（如.L3）表示跳转到的位置，而hello.o中因为每行指令都被分配了对应的地址（从main函数第一条指令地址为0开始），在跳转指令后用跳转目的的地址来表示跳转到的位置。4）函数调用，hello.s中的汇编语言在函数调用时，在call指令后用函数的名字表示对其调用，而反汇编指令在call指令后加上下一条指令的地址来表示，观察机器语言，发现其中操作数都为0，即函数的相对地址为0，因为再链接生成可执行文件后才会生成其确定的地址，所以这里的相对地址都用0代替。4.5本章小结在汇编过程中，hello实现了由汇编语言到机器语言的转变，hello第一次称为了机器可以读懂的代码，它的每条指令得到了一个暂时的地址，并通过在不同地址间的跳转把程序连接成了一个整体。hello也第一次由文本程序变成了二进制程序。as（汇编器）将hello.s转换成hello.o文件。 （第4章1分） 第5章链接5.1链接的概念与作用链接器，将程序调用的外部函数（.o文件）与当前.o文件以某种方式并，并得到./hello可执行目标文件的的过程成为链接。且该二进制文件可被加载到内存，并由系统执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。基于此特性的改进，以提高程序运行时的时间、空间利用效率。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。它将巨大的源文件分解成更小的模块，易于管理。我么可以通过独立地修改或编译这些模块，并重新链接应用，不必再重新编译其他文件。5.2在Ubuntu下链接的命令ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。可通过readelf-a来查看可执行目标文件hello的ELF文件各节基本信息（包含在节头部表中），他描述了不同节的位置和大小等基本信息。其中，它的第一列按地址顺序列出了各段的名称及大小，第三列列出来各段的起始地址，最后一列列出来各段的偏移量。 5.4hello的虚拟地址空间通过readelf查看hello的ProgramHeaders，可发现其中列出的虚拟地址在edb的DataDump中都能找到对应的位置。 5.5链接的重定位过程分析通过readelf查看hello的ProgramHeaders，可发现其中列出的虚拟地址在edb的DataDump中都能找到对应的位置。 5.6hello的执行流程1）在hello.o中，我们看不到各函数的代码段，而在hello中，存在了各个函数的代码段并且，并且每个函数（以及其每条）指令都有了对应的虚拟地址。2）在hello.o中main函数的起始地址为0，往后依次得到每条指令的简单地址，而hello中每条指令都拥有一个虚拟地址，main函数也不是从0开始了。 3）对于全局变量的引用，hello.o中用0加上%rip的值来表示全局变量的位置，因为当时并未对全局变量进行定位，而在hello中，因为全局变量都有了确定的位置，所以用实际的相对偏移加%rip的值来描述其位置。4）对于函数的调用，因为hello.o中尚未对函数定位，所以在调用时都用call加下一条指令地址来表示，而hello中各函数已拥有了各自的虚拟地址，所以在call后加其虚拟地址来实现函数调用。5）对于跳转指令，hello.o中在其后加上目的地址，为main从0开始对每条指令分配的地址；而hello中同样加上目的地址，但这里是每条指令的虚拟地址。6）_dl_start地址：0x7ff806de3ea0_dl_init地址：0x7f75c903e630_start地址：0x400500_libc_start_main地址：0x7fce59403ab0_cxa_atexit地址：0x7f38b81b9430_libc_csu_init地址：0x4005c0_setjmp地址：0x7f38b81b4c10_sigsetjmp地址：0x7efd8eb79b70_sigjmp_save地址：0x7efd8eb79bd0main地址：0x400532(puts地址：0x4004b0exit地址：0x4004e0)(argc!=3时)print地址：0x4004c0sleep地址：0x4004f0(以上两个在循环体中执行10次)getchar地址：0x4004d0_dl_runtime_resolve_xsave地址：0x7f5852241680_dl_fixup地址：0x7f5852239df0_uflow地址：0x7f593a9a10d0exit地址：0x7f889f6721205.7Hello的动态链接分析当程序调用一个由共享库定义的函数时，编译器无法预测这个函数运行时的地址，因为定义它的共享模块在运行时可以加载到任何位置。这时，编译系统提供了延迟绑定的方法，将过程地址的绑定推迟到第一次调用该过程时。他通过GOT和过程链接表PLT的协作来解析函数的地址。在加载时，动态链接器会重定位GOT中的每个条目，使它包含正确的绝对地址，而PLT中的每个函数负责调用不同函数。那么，通过观察edb，便可发现dl_init后.got.plt节发生的变化。通过readelf可以发现.got.plt节在地址为0x601000的地方开始。而它后面的.data节从地址0x601040开始。那么中间部分便是.got.plt的内容。5.8本章小结本章介绍了链接的概念和作用，分析了hello的格式、虚拟地址空间、重定位过程、执行流程和动态链接分析。（第5章1分） 第6章hello进程管理6.1进程的概念与作用概念：进程是一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。作用：在现代系统上运行一个程序时，我们会得到一个假象，好像我们的程序是系统中唯一运行的程序一样。我们的程序好像独占处理器和内存。处理器好像无间断地一条接一条执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象是通过进程的概念提供的。进程提供给应用程序的关键抽象：1）一个独立的逻辑控制流，提供一个程序独占处理器的假象；2）一个私有的地址空间，提供一个程序独占地使用内存系统的假象。6.2简述壳Shell-bash的作用与处理流程作用：shell执行一系列的读/求值步骤，然后终止。读步骤读取来自用户的一个命令行，求值步骤解析命令行，并代表用户运行程序。处理流程：shell打印一个命令行提示符，等待用户在stdin上输入命令行，然后对命令行求值，即解析以空格分隔的命令行参数，第一个参数被假设为要么是一个内置的shell命令名，马上就会解释这个命令并执行相应操作；要么是一个可执行目标文件，会通过fork创建一个新的子进程，并在新的子进程的上下文中通过execve加载并运行这个文件。如果用户要求在后台运行该程序，那么shell返回到循环的顶部，等待下一个命令行。否则，shell使用waitpid函数等待作业终止并回收。当作业终止时，shell开始下一轮的迭代。6.3Hello的fork进程创建过程父进程通过调用fork函数创建一个新的运行的子进程。调用fork函数后，新创建的子进程几乎但不完全与父进程相同:子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本（包括代码、数据段、堆、共享库以及用户栈），子进程获得与父进程任何打开文件描述符相同的副本，这意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。fork被调用一次，却返回两次,子进程返回0，父进程返回子进程的PID。子进程有不同于父进程的PID。6.4Hello的execve过程exceve函数在当前进程的上下文中加载并运行一个新程序。exceve函数加载并运行可执行目标文件，并带参数列表和环境变量列表。只有当出现错误时，exceve才会返回到调用程序，否则，exceve调用一次且从不返回。在exceve加载了可执行目标文件后，他调用启动代码，启动代码设置栈，将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序，由此将控制传递给新程序的主函数。6.5Hello的进程执行系统中通常有许多程序在运行，那么进程会为每个程序提供一个好像它在独占地使用处理器的假象。这时依赖于进程提供的独立的逻辑控制流（由上下文切换机制提供）。如一个系统运行着多个进程，那么处理器的一个物理控制流就被分成了多个逻辑控制流，每个进程1个。这些逻辑流的执行是交错的，它们轮流使用处理器，会存在并发执行的现象。其中，一个进程执行它的控制流的一部分的每一时间段叫做时间片。这样的机制使进程在执行时仿佛独占了处理器。处理器用某个控制寄存器中的一个模式位来限制一个应用可以执行的指令以及它可以访问的地址空间范围。没有设置模式位时，进程运行在用户模式中，它必须通过系统调用接口才可间接访问内核代码和数据；而设置模式位时，它运行在内核模式中，可以执行指令集中的任何指令，访问系统内存的任何位置。异常发生时，控制传递到异常处理程序，由用户模式转变到内核模式，返回至应用程序代码时，又从内核模式转变到用户模式。操作系统内核使用上下文切换来实现多任务。内核为每个进程维持一个上下文，它是内核重启被抢占的进程所需的状态，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构的值。进程执行到某些时刻，内核可决定抢占该进程，并重新开启一个先前被抢占了的进程，这种决策称为调度。内核调度一个新的进程运行后，通过上下文切换机制来转移控制到新的进程：1）保存当前进程上下文；2）恢复某个先前被抢占的进程被保存的上下文3）将控制转移给这个新恢复的进程。当内核代表用户执行系统调用时，可能会发生上下文切换，这时就存在着用户态与核心态的转换。6.6hello的异常与信号处理hello执行过程中会出现的异常有：中断：他由处理器外部的I/O设备的信号引起（如Ctrl-Z，Ctrl-C），可能产生信号SIGSTP，它会将程序挂起，直到有下一个SIGCONT信号；也可能产生信号SIGINT，它会将进程终止。1）运行程序在终端运行程序，打印十次Hello姓名学号后，输入hello(任意)回车，程序执行完成，进程被回收。 2）运行时不停乱按（包括回车）发现他会把乱按的字符打印出来，按回车它会换一行，但是这些都不影响程序的正常执行，因为当程序执行时他不会受到外部输入的影响，它会阻塞这些操作产生的信号，而因为之前将大量字符（包括回车）输入到了屏幕上，所以最后不用自己再输入字符来结束程序，而是直接读取之前的输入。 3）运行程序时按Ctrl-Z程序运行时按Ctrl-Z，这时，产生中断异常，它的父进程会接收到信号SIGSTP并运行信号处理程序，然后便发现程序在这时被挂起了，并打印了相关挂起信息。 4）运行程序时按Ctrl-C运行hello时按Ctrl-C，会导致一个中断异常，从而内核产生信号SIGINT，父进程受到它后，向子进程发生SIGKILL来强制终止子进程hello并回收它。这时在运行ps，可以发现并没有进程hello，可以说明他已经被终止并回收了。 6.7本章小结hello开始真正在系统上运行时，离不开shell给它提供的平台，也离不开进程机制的支持和各种信号的通知。从创建进程，到在进程中加载程序，信号以及上下文切换使其可以自如的运行在计算机中，就好像独占了整个CPU。而当hello的进程生命结束，同样需要各种信号与系统的配合来对它进行终止，回收。程序的高效运行离不开异常、信号、进程等概念，正是这些机制支持hello能够顺利地在计算机上运行。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：逻辑地址指由程序产生的与段相关的偏移地址部分。在有地址变换功能的计算机中，访内指令给出的地址(操作数)叫逻辑地址，也叫相对地址。要经过寻址方式的计算或变换才得到内存储器中的实际有效地址，即物理地址。从hello的反汇编代码中看到的地址，它们需要通过计算，即加上对应段的基地址才能得到真正的地址，这些便是hello中的逻辑地址。线性地址：线性地址是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，其偏移量加上基地址就是线性地址。hello的反汇编文件中看到的地址（即逻辑地址）中的偏移量，加上对应段的基地址，便得到了hello中内容对应的线性地址。虚拟地址：使用虚拟寻址时，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送至内存前先转换成适当的物理地址。虚拟地址转化成物理地址的过程叫做地址翻译。在linux中，虚拟地址数值树等于线性地址，即hello中看到的地址加上对应段基地址的值。物理地址：计算机系统的主存被组织成一个M个连续字节大小的单元组成的数组，每字节都有一个独立的物理地址。它是物理内存中实际对应的地址，在hello的运行中，在访问内存时需要通过CPU产生虚拟地址，然后通过地址翻译得到一个物理地址，并通过物理地址访问内存中的位置。7.2Intel逻辑地址到线性地址的变换-段式管理逻辑地址由段选择符和偏移量组成，线性地址为段首地址与逻辑地址中的偏移量组成。其中，段首地址存放在段描述符中。而段描述符存放在描述符表中，也就是GDT（全局描述符表）或LDT（局部描述符表）中。7.3Hello的线性地址到物理地址的变换-页式管理线性地址（虚拟地址）由虚拟页号VPN和虚拟页偏移VPO组成。首先，MMU从线性地址中抽取出VPN，并且检查TLB，看他是否因为前面某个内存引用缓存了PTE的一个副本。TLB从VPN中抽取出TLB索引和TLB标记，查找对应组中是否有匹配的条目。若命中，将缓存的PPN返回给MMU。若不命中，MMU需从页表中的PTE中取出PPN，若得到的PTE无效或标记不匹配，就产生缺页，内核需调入所需页面，重新运行加载指令，若有效，则取出PPN。最后将线性地址中的VPO与PPN连接起来就得到了对应的物理地址。7.4TLB与四级页表支持下的VA到PA的变换虚拟地址VA虚拟页号VPN和虚拟页偏移VPO组成。若TLB不命中时，VPN被划分为四个片，每个片被用作到一个页表的偏移量，CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，依次类推。最后在L4页表中对应的PTE中取出PPN，与VPO连接，形成物理地址PA。7.5三级Cache支持下的物理内存访问MMU将物理地址发给L1缓存，缓存从物理地址中取出缓存偏移CO、缓存组索引CI以及缓存标记CT。若缓存中CI所指示的组有标记与CT匹配的条目且有效位为1，则检测到一个命中，读出在偏移量CO处的数据字节，并把它返回给MMU，随后MMU将它传递给CPU。若不命中，则需到低一级Cache（若L3cache中找不到则到主存）中取出相应的块将其放入当前cache中，重新执行对应指令，访问要找的数据。7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给他一个唯一的pid。为了给这个新进程创建虚拟内存，他创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有写时复制。当fork从新进程返回，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要：1）删除已存在的用户区域：删除当前进程虚拟地址的用户部分中的已存在的区域结构。2）映射私有区域:为新程序hello的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。3)映射共享区域:如果hello程序与共享对象（或目标）链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。4)设置程序计数器(PC):设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。7.8缺页故障与缺页中断处理对虚拟内存来说，DRAM缓存不命中称为缺页。如下例所示，CPU引用了VP3中的一个字，而VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，因为有效位0，所以并未缓存，引发了缺页异常，调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，这里以存放在PP3中的VP4为例。若VP4被修改了，那么内核会将它复制回磁盘。内核会修改VP4的页表条目，反映出VP4以不在主存中。然后，内核从磁盘复制VP3到内存中PP3位置，然后处理程序返回，重新启动导致缺页的指令。这时，VP3已存在主存中，不会在导致缺页，可以正常读取。7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。1）隐式空闲链表：空闲块通过头部中的大小字段隐含地连接着。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。放置策略：首次适配、下一次适配、最佳适配。首次适配从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配从上一次查询结束的地方开始。最佳适配检查每个空闲块，选择适合所需请求大小的最小空闲块。合并策略：立即合并、推迟合并。立即合并就是在每次一个块被释放时，就合并所有的相邻块；推迟合并就是等到某个稍晚的时候再合并空闲块。2）显式空闲链表：每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。使用双向链表使首次适配的时间减少到空闲块数量的线性时间。空闲链表中块的排序策略：一种是用后进先出的顺序维护链表，将新释放的块放置在链表的开始处，另一种方法是按照地址顺序来维护链表，链表中每个块的地址都小于它后继的地址。分离存储：维护多个空闲链表，每个链表中的块有大致相等的大小。将所有可能的块大小分成一些等价类，也叫做大小类。分离存储的方法：简单分离存储和分离适配。7.10本章小结本章讨论了存储器地址空间，段式管理、页式管理，TLB与四级页表支持下的VA到PA的变换，三级Cache支持下的物理内存访问，hello进程fork时和execve时的内存映射，缺页故障与缺页中断处理和动态存储分配管理。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。8.2简述UnixIO接口及其函数1.打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。2.Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。3.改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0.这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会触发一个称为end-of-file（EOF）的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。5.关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。函数：1.intopen(char*filename,intflags,mode_tmode)进程通过调用open函数来打开一个已存在的文件或者创建一个新文件。open函数将filename转换为一个文件描述符，而且返回描述符数字。flags参数指明了进程打算如何访问这个文件。mode参数指定了新文件的访问权限位。2.intclose(intfd)进程通过调用close函数关闭一个打开的文件。3.ssize_tread(intfd,void*buf,size_tn)应用程序通过调用read函数来执行输入。read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，返回值0表示EOF。否则返回值表示的是实际传送的字节数量。4.ssize_twrite(intfd,constvoid*buf,size_tn)应用程序通过调用write函数来执行输出。write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。8.3printf的实现分析printf的代码： intprintf(constchar*fmt,…){inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } vsprintf的代码： intvsprintf(char*buf,constchar*fmt,va_listargs){char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!='%'){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); } write的代码：moveax,_NR_writemovebx,[esp+4]movecx,[esp+8]intINT_VECTOR_SYS_CALL sys_cal: sys_call：callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret syscall将字符串中的字节从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析1.intgetchar(void)2.{3.staticcharbuf[BUFSIZ];4.staticchar*bb=buf;5.staticintn=0;6.if(n==0)7.{8.n=read(0,buf,BUFSIZ);9.bb=buf;10.}11.return(–n>=0)?(unsignedchar)*bb++:EOF;12.} getchar函数调用read函数，将整个缓冲区都读到buf里，并将缓冲区的长度赋值给n。返回时返回buf的第一个元素，除非n<0。异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章简述了Linux的I/O设备管理机制，UnixI/O接口及函数，并简要分析了printf函数和getchar函数的实现。（第8章1分）结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。1）GCC编译器驱动程序读取源程序文件hello.c。2）预处理器cpp将其预处理为一个修改了的源程序hello.i（如读取并插入头文件内容等）。3）编译器ccl将其翻译成汇编语言程序hello.s。4）汇编器as将其翻译成机器语言指令，得到可执行目标文件hello.o。5）链接器ld将重定位目标文件链接为可执行目标文件hello。6）在shell中输入运行hello的指令，shell通过fork为其创建新的进程。7）通过execve将hello程序加载并运行。把它映射到对应虚拟内存区域，并依需求载入物理内存。8）在CPU的帮助下，它的指令被一步步执行，实现它拥有的功能。9）在程序运行结束后，父进程会对其进行回收，内核把它从系统中清除。这样，hello便完成了它的程序人生。计算机系统的设计复杂而严密，对内存，CPU等各个实现都有着精密的处理设计，以涵盖在系统运行时可能遇到的各种情况。计算机系统的运行需要内存，CPU，信号等机制的密切配合，来实现在系统上正确而又高效地运行程序。（结论0分，缺失-1分，根据内容酌情加分） 附件列出所有的中间产物的文件名，并予以说明起作用。hello.i预处理后修改了的源程序hello.s汇编生成的hello的汇编程序hello.o编译生成的hello的可重定位目标程序hello链接生成的hello的可执行目标程序asm.txthello.o的反汇编文件（附件0分，缺失-1分） 参考文献[1]动态链接原理分析https://blog.csdn.net/shenhuxi_yu/article/details/71437167[2]printf函数实现的深入剖析https://www.cnblogs.com/pianist/p/3315801.html[3]getchar函数浅谈https://blog.csdn.net/zhuangyongkang/article/details/38943863[4]https://baike.baidu.com/item/逻辑地址/3283849?fr=aladdin[5]https://baike.baidu.com/item/线性地址[6]https://baike.baidu.com/item/虚拟地址[7]https://www.cnblogs.com/huangwentian/p/7487670.html[8]https://blog.csdn.net/youyou519/article/details/82659007为完成本次大作业你翻阅的书籍与网站等（参考文献0分，缺失-1分） 

最短路（4）--差分约束 差分约束的实质就是把多种约束连起来，比如x-y<=a和y-z<=b，把他们连起来就成了x-z<=a+b，这样很容易就可以想到把x-y看成一条由x指向y，权值为a的边，那么对于一堆约束条件，就可以转化为求最短路或最长路的问题 对于不同的一堆约束条件，有： 如果约束条件形如x-y<=a，则实际问题为求差的最大值，操作是求最短路如果约束条件形如x-y>=a，则实际问题为求差的最小值，操作是求最长路（此处较难理解，需要用到数学中交并集的知识）解释：对于一堆约束条件建立的如下的图：两种约束条件原理类似，拿<=举例：可见，算出1和3的关系有两钟解，一种是<=4，另一种是<=3，但是，因为要满足所有的约束条件，所以对于1和3的最大差值，只能取两个取值范围的交集，即<=3，这就使最短路 举例：POJ3159（模板题） *题目大意： 把糖分给n个小朋友，总共有m个约束条件，表示编号为i,j的小朋友之间分到的糖果数之差不大于一个值，求分完后第n个小朋友和第1个小朋友之间的最大差值* 完全是模板题，直接上代码（SPFA）这道题是我做过的最恶心的一道题，不能用queue，只能用stack就不说啥了，竟然连cin都不能用，只能用scanf。。。。白白浪费了我一个小时的时间，气的我想当场砸电脑 //poj3159 #include<cstdio> #include<queue> #include<stack> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=30000+10; constintMAXM=150000+10; constintINF=0x3f3f3f3f; intn,m; stack<int>q; intd[MAXN],vis[MAXN]; structedge { intto,next,w; }e[MAXM]; inthead[MAXN],cnt; voidadd(intu,intv,intw) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].w=w; } intmain() { scanf("%d%d",&n,&m); for(inti=1;i<=m;i++) { intu,v,w; scanf("%d%d%d",&u,&v,&w); add(u,v,w); } for(inti=1;i<=n;i++) d[i]=INF; d[1]=0; q.push(1);vis[1]=1; while(!q.empty()) { intu=q.top(); intv,w; q.pop(); vis[u]=0; for(inti=head[u];i;i=e[i].next) { v=e[i].to; w=e[i].w; if(d[v]>d[u]+w) { d[v]=d[u]+w; if(!vis[v]){q.push(v);vis[v]=1;} } } } printf("%d\n",d[n]); return0; } 

2-sat问题 2-sat问题： 给定一堆约束条件，每个都形如“xi为真/假或xj为真/假”，即：xi为真/假和xj为真/假中必有一个成立，现在问是否可以全部满足 思路： 可以把xi为真看成两个节点：2i,2i+1（因为2i^1=2i+1，可以互相转化）假如说约束条件为“xi为真或xj为假”，那么2i表示“xi为真”为真，2i+1表示“xi为真”为假；2j表示“xj为假”为真，2j+1表示”xj为假“为假则，由2j+1为真可以推出2i为真，同理，由2i+1可以推出2j为真所以，可以从2j+1到2i；2i+1到2j连两条有向边对于起点u，可以假设他为真，并对他进行深搜，如果过程中发现有点的两个结点都为真，则不能再假设他为假，再深搜，如果他还是不能，则不能建图 例题： 有n架飞机要着陆，每个都可以选择早着陆或晚着陆，请安排着陆方式，要求着陆时间差值的最小值最大 思路：”最小值最大“可以用二分，问题即可转化成着陆时间差值不大于mid是否成立，所以着陆时间小于mid的两个点，至多有一个成立，等价于这两个点的补至少有一个成立，这样就转化为了2-sat 代码：（调了一个上午，参考刘汝佳《算法竞赛入门经典训练指南》） #include<cstdio> #include<cstring> #include<string> #include<vector> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=2000+10; structtwosat { vector<int>G[MAXN*2]; boolmark[MAXN*2]; ints[MAXN*2],c; intn;//外面的n booldfs(intu) { if(mark[u^1])returnfalse; if(mark[u])returntrue; mark[u]=true; s[c++]=u; for(inti=0;i<G[u].size();i++) { intv=G[u][i]; if(!dfs(v))returnfalse; } returntrue; } voidinit(intn) { this->n/*这个是外面的n*/=n;//将外面的n赋值为里面的n for(inti=0;i<2*n;i++)G[i].clear(); memset(mark,0,sizeof(mark)); } voidadd(intx,intxval,inty,intyval)//x==xvalory==yval { x=2*x+xval;//2i y=2*y+yval;//2j G[x^1].push_back(y); G[y^1].push_back(x); } boolsolve() { for(inti=0;i<2*n;i+=2) if(!mark[i]&&!mark[i+1]) { c=0; if(!dfs(i)) { while(c>0)mark[s[--c]]=false;//如果深搜它不成功，则所有的假设都错误 if(!dfs(i+1))returnfalse;//如果假设他为真假都不对，不能成图 } } returntrue; } }; twosatsolver; intt[MAXN][2],n; booltest(intmid) { solver.init(n); for(inti=0;i<n;i++)for(inta=0;a<=1;a++) for(intj=i+1;j<n;j++)for(intb=0;b<=1;b++) { if(abs(t[i][a]-t[j][b])<mid)solver.add(i,a^1,j,b^1); } returnsolver.solve(); } intmain() { cin>>n; intl=0,r=0; for(inti=0;i<n;i++)for(inta=0;a<=1;a++) { cin>>t[i][a]; r=max(r,t[i][a]); } while(l<r) { intmid=l+(r-l+1)/2;//令相邻两个着陆时间都大于等于mid//时间差小于mid的两个时间不能同时满足 if(test(mid))l=mid;elser=mid-1; } cout<<l; return0; } 

状态压缩DP（入门） 可以把一个难以描述的状态压缩为一个二进制数，即将状态用一个数字表示 例题： 给定一个n*m的方格，每次可以填一个1*2或2*1的矩形，若要将其填满，共有多少种填法(1<=n<=5,1<=m<=1000) 分析： 因为n的范围很小，所以我们可以把每一列都用一个二进制数表示，作为一个状态，则dp[i][j]表示前i列，第i列的装态为j时的最大填法数用dfs(i,j,now,next)表示深搜第i列，第j行，而第i列的状态为now,因为如果填1*2的矩形，则会对后面的状态有影响，所以用next记录对后面的影响当j==n即第i列已经讨论完时，给d[i+1][next]的值加上dp[i][now]的值 下面是代码 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=2000+10; intn,m; intdp[MAXN][MAXN];//dp[i][j]表示讨论到了第i列，当前列的状态是j时的方式数d[i][j]=sum(d[i-1][1~1<<n]) voiddfs(inti,intj,intnow,intnext)//第i列,当前讨论到第i列的第j个,当前列的状态为now,这一列对下一列影响后下一列的状态为next { if(j==n) { dp[i+1][next]+=dp[i][now];//这一列讨论完后更新下一列的dp值 return; } if(((1<<j)&now)) dfs(i,j+1,now,next); if(!((1<<j)&now)) dfs(i,j+1,now,next|(1<<j)); if((j+1)<n&&!((1<<j)&now)&&!((1<<(j+1))&now)) dfs(i,j+2,now,next); return; } intmain() { cin>>n>>m; dp[1][0]=1; for(inti=1;i<=m;i++) for(intj=0;j<(1<<n);j++) if(dp[i][j])dfs(i,0,j,0); cout<<dp[m+1][0]; return0; } 

优先队列的基本用法（初步） 优先队列的基本用法（初步） 优先队列实际上就是堆，可以用它来维护大根堆和小根堆 //优先队列 #include<queue> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; priority_queue<int>da;//大根堆 priority_queue<int,vector<int>,greater<int>>xiao;//小根堆，两个>之间要有空格 intmain() { intn; cin>>n; for(inti=1;i<=n;i++) { intu;cin>>u; da.push(u); xiao.push(u); } cout<<da.top(); cout<<endl<<xiao.top(); return0; } 重载运算符（较难理解） #include<cstdio> #include<cstdlib> #include<queue> #include<iostream> #include<algorithm> usingnamespacestd; structcmp { booloperator()(constinta,constintb)//如果a的优先级比b小返回true { returna%10>b%10;//定义“优先级小”为a%10>b%10时，a的优先级小 } }; priority_queue<int>q;//按照优先级从大到小排列，即把a拍在后面 intmain() { q.push(18); q.push(21); cout<<q.top(); return0; } 当然还有很多复杂而神奇的用法，但是对我目前用处不大，先不深入了解 

HelloWorld #include<iostream> usingnamespacestd; intmain() { cout<<"HelloWorld"; return0; } 

最短路（2）--bellman-ford和SPFA bellman-ford 首先，如果最短路存在，那么一定有一条不含环的最短路，因为如果是正环或零环，都可以直接去除，如果有负环，则最短路不存在，所以最短路顶多经过n-1个顶点，那么我们至多只需要进行n-1次松弛操作，每次操作中遍历所有边，如果该边的起点不是INF（已经松弛过）那么就对该边的终点松弛。这样就一定可以把最短路经过的所有点都松弛一遍，即求出了最短路（因为只要可以松弛，就一定有更短的方案）。 //bellmanford #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; constintINF=0x3f3f3f3f; intu[MAXN],v[MAXN],w[MAXN]; intd[MAXN]; intn,m; intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=m;i++) { cin>>u[i]>>v[i]>>w[i]; u[i+m]=v[i],v[i+m]=u[i],w[i+m]=w[i]; } d[1]=0; for(inti=2;i<=n;i++)d[i]=INF; for(intk=1;k<n;k++) for(inti=1;i<=2*m;i++) if(d[u[i]]<INF)d[v[i]]=min(d[v[i]],d[u[i]]+w[i]); for(inti=1;i<=n;i++) cout<<d[i]<<""; return0; } SPFA 思路： 把除起点外的所有点距离设为无限，然后让起点进入队列每次取出队列的第一个点，讨论他的所有只向点进行松弛操作，如果松弛成功并且该点并不在队列中，将该点放入队列，直到队列中没有点为止 和dijkstra的比较 dijkstra每次取出的是当前距离最小点，在后面的讨论中不可能再更新该点的值，所以每个点只用讨论一次SPFA每次取出的只是一个松弛过的点，很有可能再次讨论回来，所以一个点要讨论多次但是因为dijkstra中每次找距离最小点需要时间复杂度，所以O(mlogn)而SPFA没有这个需要，所以O(kn)，k是常数，而一般不会超过2而且dijkstra只能解决没有负权的问题，而SPFA可以解决，但不能解决有负环的问题，因为有负环的图没有最短路，他还可以判定负环，当一个点的进队次数超过n后，可以判定图中有负环 下面是SPFA的代码 //SPFA #include<cstdio> #include<cstdlib> #include<queue> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; constintINF=0x3f3f3f3f; queue<int>q; intn,m; intd[MAXN]; intvis[MAXN]; structedge { intto,next,w; }e[MAXN]; inthead[MAXN],cnt; voidadd(intu,intv,intw) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].w=w; } intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=m;i++) { intu,v,w; cin>>u>>v>>w; add(u,v,w);add(v,u,w); } for(inti=2;i<=n;i++) d[i]=INF; q.push(1);vis[1]=1; while(!q.empty()) { intu=q.front();q.pop();vis[u]=0; for(inti=head[u];i;i=e[i].next) { intv=e[i].to; if(d[v]>d[u]+e[i].w) { d[v]=d[u]+e[i].w; if(!vis[v]){q.push(v);vis[v]=1;} } } } for(inti=1;i<=n;i++) cout<<d[i]<<""; return0; } 

VMware创建ubuntu虚拟机后无法安装vmwaretools 在每次安装完vmtools上的ubuntu虚拟机后安装vmware-tools时，会提示如下并且vmwaretools中没有东西 按照网上方法更改CD文件为linux.iso问题仍然存在 更改完后需要重启vmwaretools即可解决 

POJ2349（最小生成树） 题目大意：给定n个点，其中任意点都可以用无线电链接，但是无线电的连接范围不能超过D，D越大费用越高，现在可以给其中的S个点接上卫星，卫星范围无限，现在要求所有点都直接或间接的连接，求最小的D 思路： 把所有点都连接上后，需要把他们分成s个联通块，每个连通块里放一个卫星（不管是那个点），这样，两个连通块里的所有点都可以通过卫星连接，分成s个连通块需要删掉s-1条路既然要求D最小，那么就一定要删最大的s-1条边那么我就需要形成生成树的所有的边都尽量小因为最小生成树是按照边权从小到大排列的，满足条件所以求解的步骤就是先用Kruskal求出最小生成树，求的过程中把要形成生成树的边存起来，最后删除最大的s-1条边，然后输出最大边即可 //poj2349 #include<cmath> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> #include<queue> usingnamespacestd; constintMAXN=500*500+10; intx[MAXN],y[MAXN]; intfa[MAXN]; ints,n; intans; structedge { intu,v; doublew; }e[MAXN]; doubledist(intu,intv) { returnsqrt((double)(x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v])); } boolcmp(edgea,edgeb) { returna.w<b.w; } intfind(intx) { //if(fa[x]!=x)returnfa[x]=find(fa[x]); //elsereturnx; if(fa[x]==x)returnx; elsereturnfa[x]=find(fa[x]); } doubleq[MAXN]; voidkruskal(intcnt) { memset(q,0,sizeof(q)); for(inti=1;i<=n;i++) fa[i]=i; for(inti=1;i<=cnt;i++) { inta=e[i].u,b=e[i].v; intfx=find(a),fy=find(b); if(fx!=fy){fa[fy]=fx;q[++ans]=e[i].w;} } } intmain() { intt; cin>>t; while(t--) { cin>>s>>n; for(inti=1;i<=n;i++) cin>>x[i]>>y[i]; intcnt=0; for(inti=1;i<=n;i++) for(intj=i+1;j<=n;j++) { e[++cnt].w=dist(i,j); e[cnt].u=i,e[cnt].v=j; } sort(e+1,e+1+cnt,cmp); ans=0; kruskal(cnt); intto=ans-s+1; while(ans!=to) ans--; printf("%.2f\n",q[ans]); //cout<<q[ans]<<endl; } return0; } 

线段树基本操作（2） 线段树基本操作（2） 区间修改 假如指定一个操作给一段区间的所有值加2，求任意区间的最小值 修改区间时依然要按照线段树的结点搜索，但是如果一直搜索到底的话复杂度过大所以需要用到延迟标记当我指定一段区间进行修改时，依然按照线段树查找区间的方法逐层查找，但是区别是当刚好找到某结点的左右值刚好等于当前要改的左右值时，不用再继续查找下去，只需要在这个节点上加个延迟标记设要查找的区间为(ll,rr)，已知区间为lt,rt当(ll>=lt&&rr<=rt)时，如果此时这个区间上有延迟标记，则将他加载现在区间的值上，然后把延迟标记释放给子节点，如果此时lt==ll&&rr==rt，则返回当前结点的值即可注意，如果一直查到了叶子结点，但这个叶子上没有延迟标记，也要返回该叶子节点的值讨论完左右叶子节点后要更新当前节点的值 更新：才发现在change是就更改结点值而查询时只释放结点会更快，下面摘自网上 对于任意区间的修改，我们先按照查询的方式将其划分成线段树中的结点，然后修改这些结点的信息，并给这些结点标上代表这种修改操作的标记。在修改和查询的时候，如果我们到了一个结点p，并且决定考虑其子结点，那么我们就要看看结点p有没有标记，如果有，就要按照标记修改其子结点的信息，并且给子结点都标上相同的标记，同时消掉p的标记。 下面是代码 //线段树区间修改 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; intn; intval[2*MAXN],p[MAXN]; intsign[2*MAXN];//延迟标记 voidbuild(intnode,intlt,intrt)//建树 { if(lt==rt){val[node]=p[lt];return;} intmid=(lt+rt)>>1; build(node*2,lt,mid);build(node*2+1,mid+1,rt); val[node]=min(val[node*2],val[node*2+1]); return; } voidchange(intnode,intlt,intrt,intll,intrr)//区间修改 { if(lt==ll&&rr==rt){sign[node]++;return;} intmid=(lt+rt)>>1; if(rr<=mid){change(node*2,lt,mid,ll,rr);return;} if(ll>mid){change(node*2+1,mid+1,rt,ll,rr);return;} change(node*2,lt,mid,ll,mid); change(node*2+1,mid+1,rt,mid+1,rr); } intquery(intnode,intlt,intrt,intll,intrr)//区间查询 { if(ll>=lt&&rr<=rt&&sign[node]) { val[node]+=2*sign[node]; sign[node*2]+=sign[node]; sign[node*2+1]+=sign[node]; sign[node]=0; if(ll==lt&&rr==rt)returnval[node]; } if(lt==rt)returnval[node]; intmid=(lt+rt)>>1; if(rr<=mid)returnquery(node*2,lt,mid,ll,rr); if(ll>mid)returnquery(node*2+1,mid+1,rt,ll,rr); intv1=query(node*2,lt,mid,ll,mid); intv2=query(node*2+1,mid+1,rt,mid+1,rr); returnval[node]=min(v1,v2); } intmain() { freopen("tree.in","r",stdin); cin>>n; for(inti=1;i<=n;i++) cin>>p[i]; build(1,1,n); change(1,1,n,2,4); intans=query(1,1,n,1,n); //cout<<ans; //for(inti=1;i<=2*n;i++) //cout<<sign[i]<<""; //cout<<endl; for(inti=1;i<=2*n;i++) cout<<val[i]<<""; } 

CODEVS1134noip2011铺地毯 懒得用结构体 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; inta[MAXN],b[MAXN],g[MAXN],k[MAXN]; intmain() { intn; intx,y; intans=-1; cin>>n; for(inti=1;i<=n;i++) cin>>a[i]>>b[i]>>g[i]>>k[i]; cin>>x>>y; for(inti=1;i<=n;i++) { if(x>=a[i]&&x<=a[i]+g[i]&&y>=b[i]&&y<=b[i]+k[i]) ans=i; } cout<<ans; return0; } 

vijos1012平面最近点对(模板) vijos1012平面最近点对(模板) 半年没摸键盘了，为了PKUSC要做恢复性训练了裸的平面最近点对模板题，要用到分治算法，O（nlogn)，但是这道题暴力也能过 暴力 纯暴力肯定用不了，要用到一些剪枝 先把数组以x为第一次序，y为第二优先次序排序在两层循环中，如果p[i].x和p[j].x的差值已经大于当前算的最小距离了，那以后的就肯定不能取了，直接剪掉 //100 #include<cstdio> #include<cmath> #include<cstdlib> #include<iostream> #include<algorithm> #definelllonglong usingnamespacestd; intn; constintMAXN=100000+10; constintINF=0x3f3f3f3f; structnode { llx,y; }p[MAXN]; boolcmp(nodea,nodeb) { if(a.x==b.x)returna.y<=b.y; elsereturna.x<b.x; } doubledist(inta,intb) { returnsqrt((double)((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y))); } intmain() { //freopen("point.in","r",stdin); cin>>n; for(inti=1;i<=n;i++) cin>>p[i].x>>p[i].y; sort(p+1,p+1+n,cmp); doubleans=INF; for(inti=1;i<=n;i++) for(intj=i+1;j<=n;j++) { if((p[j].x-p[i].x)>ans)break; ans=min(ans,dist(i,j)); } printf("%.3f",ans); return0; } 分治 肯定还是要排序solve(i,j)表示点i到j之间的所有点可以形成的最小点对大小计算时运用分治法可以大量简化时间复杂度（我个人觉得这实际上是一种DP)对于一段区间[i,j]，找到他们的中间点mid=(i+j)>>1然后分别计算左右两区间的最小点对大小，再进行比较，即d=min(solve(i,mid),solve(mid+1,j))到这一步当然还不够，如果这两个区间之间的点对存在更小的情况呢？先取出中间点的横坐标midx因为事先已经排好序，所以如果存在上文说到的点对，则他们的横坐标的范围顶多在(midx-d,midx+d)之间把所有这样的点都找出来，再在这些点之间找出最小距离值和d比较就可以了再找这些点的时候可以用到与上面暴力相似的优化 代码如下 //AC #include<string> #include<cstring> #include<cmath> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; intn; constintMAXN=100000+10; constintINF=0x3f3f3f3f; structnode { longlongx,y; }p[MAXN]; nodetemp[MAXN]; boolcmp(nodea,nodeb) { if(a.x==b.x)returna.y<=b.y; elsereturna.x<b.x; } //doubledist(inta,intb) //{ //returnsqrt((double)((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y))); //} doubledist(nodea,nodeb) { returnsqrt((double)((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))); } doublejue(longlonga) { if(a>=0)returna; elsereturn-a; } boolcmpy(nodea,nodeb) { returna.y<b.y; } doublesolve(intlt,intrt) { doubleans=INF; if(lt==rt)returnans; intmid=(lt+rt)>>1; doubleans1=solve(lt,mid); doubleans2=solve(mid+1,rt); ans=min(ans1,ans2); intmidx=p[mid].x; intll=midx-ans,rr=midx+ans; intld=p[lt].x,rd=p[rt].x; intcnt=0; //for(inti=1;i<=n;i++) //if(p[i].x>=ll&&p[i].x<=rr&&p[i].x>=ld&&p[i].x<=rd)temp[++cnt]=p[i]; for(inti=lt;i<=rt;i++) if(jue(p[mid].x-p[i].x)<=ans)temp[++cnt]=p[i]; sort(temp+1,temp+1+cnt,cmpy); for(inti=1;i<=cnt;i++) for(intj=i+1;j<=cnt;j++) { nodeu=temp[i],v=temp[j]; if((v.y-u.y)>ans)break; doubleans3=dist(u,v); ans=min(ans,ans3); } returnans; } intmain() { freopen("point.in","r",stdin); cin>>n; for(inti=1;i<=n;i++) cin>>p[i].x>>p[i].y; sort(p+1,p+1+n,cmp); printf("%.3f",solve(1,n)); } 

最短路（3）--floyd和用floyd求最小环 先介绍floyd算法，这种算法可以用来求图中任意两点间的最短路 思路： 用d[i][j]表示点i到点j的最小距离如果要从点i到点j，有两种方法，一种是直接去，另一种是通过另一个点中转而他们可以通过一个点中转，也可以是两个，也可以是三个。。。。假设他们只能通过点1中转，则松弛操作为d[i][j]=min(d[i][j],d[i][1]+d[1][j])在循环完所有i,j后，再更新了最短路的基础上再讨论经过点2中转，以此类推，即for(intk=1;k<=n;k++)for(inti=1;i<=n;i++)for(intj=1;j<=n;j++)if(d[i][k]<INF&&d[k][j]<INF)d[i][j]=min(d[i][j],d[i][k]+d[k][j]); 下面是整个程序的代码 //floyd #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; constintINF=0x3f3f3f3f; intd[MAXN][MAXN]; intn,m; intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=n;i++) for(intj=1;j<=n;j++) if(i!=j)d[i][j]=INF; for(inti=1;i<=m;i++) { intu,v,w; cin>>u>>v>>w; d[u][v]=w; } for(intk=1;k<=n;k++) for(inti=1;i<=n;i++) for(intj=1;j<=n;j++) if(d[i][k]<INF&&d[k][j]<INF) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); for(inti=1;i<=n;i++) { for(intj=1;j<=n;j++) cout<<d[i][j]<<""; cout<<endl; } return0; } floyd求最小环 思路： 如果我们要求包含点i,j的最小环，在已经算出来i,j之间的最短路d[i][j]的情况下（假设他们之间是经过点k中转的），还需要计算有j到i且不经过点k的最短路我们令k为这个最小环里的最大编号的点，则在前面计算d[i][j]时，一定没有经过点k，所以当第一层循环循环到k时，枚举所有小于k的点对，计算d[i][j]+m[j][k]+m[k][i]，更新最小环的值*把上面的程序放在正常求floyd时遍历i,j循环的前面* //floyd求最小环 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; constintINF=0x3f3f3f3f; intd[MAXN][MAXN]; intmap[MAXN][MAXN];//两点之间的距离，这个数组是固定的，不会更新 intn,m; intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=n;i++) for(intj=1;j<=n;j++) if(i!=j)d[i][j]=map[i][j]=INF; for(inti=1;i<=m;i++) { intu,v,w; cin>>u>>v>>w; d[u][v]=map[u][v]=w; } intans=INF; for(intk=1;k<=n;k++) { for(inti=1;i<k;i++) for(intj=i+1;j<k;j++) ans=min(ans,map[k][i]+map[j][k]+d[i][j]); for(inti=1;i<=n;i++) for(intj=1;j<=n;j++) if(d[i][k]<INF&&d[k][j]<INF) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); } //for(inti=1;i<=n;i++) //{ //for(intj=1;j<=n;j++) //cout<<d[i][j]<<""; //cout<<endl; //} cout<<ans; return0; } 

最短路（1）--dijkstra dijkstra是求单元最短路的基本算法，大体思路为： 循环n次每次找出离起点最近的点，（如果这个点已经讨论过，跳过下一个），讨论它能到达的所有下一个点v，如果起点到v的距离大于起点到u的距离加上边的权值，则更新起点到v的距离，称为松弛操作因为一个点讨论过就不会再讨论，所以总共循环n次 //dijkstra #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; constintINF=0x3f3f3f3f; intvis[MAXN],d[MAXN]; intn,m; structedge { intto,next,w; }e[MAXN]; intcnt,head[MAXN]; voidadd(intu,intv,intw) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].w=w; } intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=m;i++) { inta,b,c; cin>>a>>b>>c; add(a,b,c);add(b,a,c); } for(inti=2;i<=n;i++)d[i]=INF; d[1]=0; for(inti=1;i<=n;i++)//每有一个点被取出进行松弛后就必再松弛，所以总共循环n { intminn=INF; intu; for(inti=1;i<=n;i++)if(!vis[i]&&d[i]<minn)minn=d[i],u=i; vis[u]=1; for(inti=head[u];i;i=e[i].next) if(d[e[i].to]>d[u]+e[i].w)d[e[i].to]=d[u]+e[i].w; } return0; } 因为找距离最小的点和找所有中点都要遍历，所以复杂度较高（当然，这已经比用邻接矩阵存储好的多了），所以在找距离最小的点时可以用到优先队列，每次只取取出队首元素就行了，但是这取出的只是队首元素的值，我需要用到它的下标，所以我们可以将它的值和它的下标打包 typedefpair<int,int>pii; 然后再放到优先队列中去 priority_queue<pii,vector<pii>,greater<pii>>; 因为优先队列需要按权值比较，所以应该把权值放在第一位 q.push(make_pair(d[i],i)); 其他的部分和优化前区别不大，下面是代码 //dijkstra优先队列优化 #include<cstdio> #include<cstdlib> #include<queue> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; constintINF=0x3f3f3f3f; intvis[MAXN],d[MAXN]; intn,m; structedge { intto,next,w; }e[MAXN]; intcnt,head[MAXN]; voidadd(intu,intv,intw) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].w=w; } typedefpair<int,int>pii;//因为不仅要去出优先队列中最小的元素，还要知道它对应的点的下标，所以将它和下标打包 priority_queue<pii,vector<pii>,greater<pii>>q; intmain() { freopen("sp.in","r",stdin); cin>>n>>m; for(inti=1;i<=m;i++) { inta,b,c; cin>>a>>b>>c; add(a,b,c);add(b,a,c); } for(inti=2;i<=n;i++)d[i]=INF; q.push(make_pair(d[1],1)); while(!q.empty()) { piit=q.top();q.pop(); intu=t.second; if(vis[u])continue; vis[u]=1; for(inti=head[u];i;i=e[i].next)if(d[e[i].to]>d[u]+e[i].w) { d[e[i].to]=d[u]+e[i].w; q.push(make_pair(d[e[i].to],e[i].to)); } } for(inti=1;i<=n;i++) cout<<d[i]<<""; return0; } 

POJ2823(单调队列初步) POJ2823(单调队列初步) 滚动窗口问题，单调队列的入门题 假设我要求最大值 思路是创建一个队列，每读入一个数据就和队尾的元素比较如果他大于对尾的元素，队尾就被删除，队尾再往前一个，直到这个数据比队尾小因为是窗口滚动，如果窗口已经离开队首元素，则删除队首元素，对手元素的下一个为队首因为此时要用到下标，所以队列里的值应该是元素的下标 对于这种有指针的题，代码细节非常重要，也是我最讨厌的 在开始循环之前，把1~k-1的元素都放进去先循环删队尾，删完后再把要放的元素放进去队列删空后立刻停止l,r都是直接指向队列的首位元素的当i-k>=q[l]时，需要删除队首元素应该先把要放的元素放进去，再考虑删除队首元素的问题 下面是代码 //单调队列 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1e+6+10; intl=1,r=0;//单调队列的左右指针 intp[MAXN],q[MAXN]; intn,k; intmain() { cin>>n>>k; for(inti=1;i<=n;i++) cin>>p[i]; q[++r]=1; if(k==1)cout<<p[q[l]]<<""; for(inti=2;i<=n;i++) { while(p[i]<p[q[r]]) { r--; if(r<l)break; } q[++r]=i; if((i-k)>=q[l])l++; if(i>=k)cout<<p[q[l]]<<""; } cout<<endl; memset(q,0,sizeof(q)); r=0,l=1; q[++r]=1; if(k==1)cout<<p[q[l]]<<""; for(inti=2;i<=n;i++) { while(p[i]>p[q[r]]) { r--; if(r<l)break; } q[++r]=i; if((i-k)>=q[l])l++; if(i>=k)cout<<p[q[l]]<<""; } return0; } 

计算机系统大作业 计算机科学与技术学院 2021年6月 摘 要 本文通过现场加载并执行一个hello.c程序，串联概括了一个程序在整个执行的过程中所经历的处理与链接等操作，是对《深入理解计算机系统》的实践和高度概括，可以帮助我们理解linux执行程序的机制和汇编语言的核心知识 关键词：计算机系统，linux （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 hello.c首先经过cpp进行预处理，然后通过ccl进行编译，as对其进行汇编，再经过ld的链接后生成可执行目标程序hello，使用shell运行fork后生成子程序，在在其中使用execve进行加载程序，hello从程序变为进程，即从program变为process，即为p2p。之后映射虚拟内存，载入物理内存，执行代码，为程序分配时间片，程序运行结束后，父进程回收子进程，即为020。 1.2环境与工具 CPUAMD4900HS16GRAM256GSSD Unbuntu16 Dev,vi,readelf,edb,hexedit 1.3中间结果 hello.i:预处理文件；hello.s编译后文件；hello.o:可重定位目标文件；hello可执行目标文件；helloobj.objdmp：反汇编代码helloelf.elf：hello.o的elf格式文件 1.4本章小结 介绍了程序运行过程和实验环境文件等信息 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 （以下格式自行编排，编辑时删除） 概念：cpp为预处理器，根据命令修改c程序，将引用的所有库和源代码合并成一个完整的文本文件。 功能： 将#include语句中提到的文件添加到源代码中用常量替换#define定义的值根据#if后面的条件决定需要编译的代码 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析打开hello.i后我们可以发现其中增加了许多代码，都是#include引用的库中的代码，在这里直接添加到了我们的程序中，保证我们引用的库中的函数可以正常运行 2.4本章小结 预处理过程是将我们编写代码时为了简化使用的库还原成真正可以直接运行的程序，方便在后面的过程中进行编译和运行。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译是将生成的与处理文件转换成汇编语言的程序的过程 作用：编译转换为汇编程序后，会更接近计算机的底层执行程序的逻辑，方便后面进一步的转换为机器代码，并生成可执行目标程序。 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.3.1数据 在这次我们的hello程序中有三种数据类型，整数，字符数组和数组 首先对于字符数组即字符串，我们使用文本编辑器打开生成的hello.s汇编文件，可以轻易找到我们再.c程序中定义的字符串，前面使用string表示，在汇编程序中，被转化为utf8编码，放在特定的位置中，hello也是同理 其次对于整型，其中有全局变量，局部变量，和立即数对于全局变量，与上面的字符串类似，放在了特定的位置中直接进行了定义 对于局部变量，inti，编译器使用了将其存储在栈中的策略，在汇编代码中使用%rbp即可对栈顶进行访问；而立即数则直接转化为了数字出现在汇编代码中 对于数组，我们以argv[]为例，其中存储着只想参数的指针，在编译的过程中，编译器将数组放在指针连续的空间中，并以头部作为起始地址，访问数组中对应的元素时，只需要指定一个索引寄存器，并使用对齐修改值的操作修改，直接访问数组即可，例如途中，rax即为索引，对其加8，即可访问下一元素 3.3.2赋值 我们以对i的赋值为例，在汇编语言中往往也会使用对应的赋值语句操作，例如movl，对i对应的寄存器赋值为0 3.3.3类型转换 程序中有一个运行类型转换操作，当使用intsleepsecs=2.5语句时，对sleepsecs的定义为一个int整型，而对它的赋值确实一个浮点数，这里会对2.5进行类型转换为int，编译器一般会使用向0舍入的原则，直接将其变为2，并将其放在汇编代码中赋值给sleepsecs。 3.3.4计算 上面对数组的操作中已经提到了一些计算的操作，例如addq等，它们会以对应的寄存器为初始目标，并在其上在进行对应操作，c程序中我们一般的计算操作都可以转换为对应的汇编操作，例如i++就是在其对应的寄存器上再加上8访问数组中下一元素的 3.3.5比较与跳转 为了实现分支语句和循环语句，汇编语言中比较和跳转的操作，在跳转时，我们可以直接跳转，也可以使用比较后，根据结果进行跳转的选择，例如在我们的程序中， 这里我们将i与9进行比较，如果i<=9则使用jle语句进入L4。 3.3.6函数调用 在一个函数调用另一个函数时，首先将本函数的返回地址先存在栈中，在向被调用函数传递参数，前六个函数使用规定好的顺序的寄存器，按照顺序分别为rdi,rsi,rdx,rcx,r8,r9，对于剩下需要传递的参数，我们将其保存在栈中传递给被调用函数，当被调用函数返回时，一定会正好清空该函数构造的栈帧，最终栈顶会指向我们最初存下的函数返回地址，使用ret指令即可将PC更新为该返回地址后回到调用函数。 3.4本章小结 本章叙述了汇编语言对应与我们的c程序的一些对应关系和对应转换，可以看出汇编代码的逻辑更加接近机器的底层逻辑。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编会将我们刚刚生成的汇编语言代码生成机器语言，并将其打包为可重定位目标文件，保存在hello.o中 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 分使用命令查看hello.o的elf格式： 打开生成的elf文件 我们可以在其中直观的看到程序的各个信息，Magic描述了生成该文件的系统的字的大小和字节顺序，剩下的部分包括ELF头的大小、目标文件的类别、机器类型、以及节头部表中条目的大小和数量等信息。 接下来是节头，即节头部表 其中为文件中各个接的类型，位置大小等信息 重定位节 其中包含了各个变量和函数的重定位信息，主要包含两种类型，相对寻址即R_X86_64_32，相对寻址即R_X86_64_32_PC，在后面链接为程序时，程序即可根据重定位的信息重新找到变量或函数对应的地址，并进行修改和添加，使得每个变量或函数的信息都是唯一且确定的。 4.4Hello.o的结果解析 使用命令获得反汇编代码 与前面生成的hello.s进行对比，查看差别 1.在直接生成汇编语言时，我们的跳转使用的是形如L1,L2等的跳转标记，但是在反汇编生成的代码中，我们可以发现对应的位置变成了直接的地址。 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 2.之前生成的汇编语言中，函数调用是直接使用函数名称进行的，但是在这里面，需要进行重定位的符号或者函数，目前的跳转地址都是0，需要根据相对或绝对寻址方式在后面连接的过程中生成新的地址。 4.5本章小结 本章介绍了汇编语言转化为.o文件的过程，并介绍了可重定位文件中的对应信息等，并将反汇编文件和正向生成的汇编语言文件进行了比较。 （第4章1分） 第5章链接 5.1链接的概念与作用 在前面生成可重定位文件的基础上，链接会将对应的多个可重定位文件链接加载到一块，链接可以执行于编译时，链接可以执行于编译时或者在运行时。 5.2在Ubuntu下链接的命令 运行命令 使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 执行命令生成hello.elf文件，查看对应信息 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 使用edb打开后，可以研究发现，首先在从0x400000的部分到0x401000的地址中加载程序，一直到0x400fff中的每个节都对应了上图中的地址部分，而0x400fff之后存放了程序的.dynamic-.shstrtab节，我们可以查看程序头 其中提供了各个段在虚拟地址和物理地址中的大小位置标志等信息，例如VirAddr注明了对应的虚拟地址，PhysAddr注明了对应的物理地址。 5.5链接的重定位过程分析 运行命令 通过与helloobj.objdump进行对比，我们可以看到其中多出来了一些节内容，列举如下 .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rala.plt .init .plt .fini .en_frame .dynamic .got .got.plt .data .comment 我们可以归纳出以下结论 在进行链接时，我们同时引用了动态链接器加载入了/lib64/ld-linux-x86-64.so.2，crto、crti.o,crtn.o，添加了许多模块，例如程序入口，初始化函数等，而另一个动态链接共享库中真正定义了我们一般正常使用的函数入printf,sleep等。与上面所说的相对PC寻址和绝对寻址，一些重定位条目中需要进行重定位的内容，根据它的类型是R_X86_64_32还是_X86_64_32_PC，连接器将它们重新分配正确的调用地址。 5.6hello的执行流程 （以下格式自行编排，编辑时删除） 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 子程序列举如下： ld-2.27.so!_dl_startld-27.so!_dl_inithello!_startlibc-2.27.so!__libc_start_main-libc-2.27.so!__cxa_atexit-libc-2.27.so!__libc_csu_inithello!_initlibc-2.27.so!_setjmp-libc-2.27.so!_sigsetjmp--libc-2.27.so!__sigjmp_savehello!mainhello!puts@plthello!exit@plt*hello!printf@plt*hello!sleep@plt*hello!getchar@pltld-2.27.so!_dl_runtime_resolve_xsave-ld-2.27.so!_dl_fixup--ld-2.27.so!_dl_lookup_symbol_xlibc-2.27.so!exit 5.7Hello的动态链接分析 对于动态共享链接库中PIC函数，需要添加重定位记录，等待动态链接器处理，为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT+全局偏移量表实现函数的动态链接。 5.8本章小结 本章介绍了链接的过程以及相比于之前没有连接的程序，程序增加的部分，以及重定位寻址等知识的具体操作。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中的程序的实例，包括文本区域、数据区域、和堆栈。 CPU的处理过程为每个进程提供了一种抽象的假象，我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 Shell是系统运行用户程序的方式，Shell应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 首先，shell通过命令行分析函数分析用户输入的命令行，并声称argv和envp，接下来，shell将判断程序是否为shell的内置程序，如果是则立刻执行，如果不是则使用fork创建子进程，并使用execve加载我们输入的制定运行程序，接下来即判断用户是否要求后台运行，如果不是则让父进程等待回收子进程。 6.3Hello的fork进程创建过程 与上面的运行过程相同，shell会首先受到我们运行hello的命令和我们输入的其他参数，例如学号等，接下来，shell会判断我们运行的程序不是shell中内置程序，所以使用fork，fork函数调用一次，返回两次，给子进程返回0，给父进程返回子进程的PID，父进程和子进程拥有不同的PID，并并行运行，具体的内部运行顺序由CPU随机决定。 6.4Hello的execve过程 excve函数会在保存当前进程的上下文，并在其中加载并运行新的程序，在这里即为我们的hello程序，execve被称为启动加载器的操作系统代码来执行hello程序，加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。 在新程序的内存映像中，与源程序是私有的写时复制区域 6.5Hello的进程执行 逻辑控制流：一系列程序计数器PC的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 内核态和用户态的转换：hello进程在正常运行时处于用户态阶段，当hello程序需要进行系统调用时，会转换进入内核态，在这个过程中会进行上下文切换，在内核态时可以访问内核所有信息，在完成系统调用切换会用户态时，系统会检查信号的状况并选择一个执行对应操作。 6.6hello的异常与信号处理 （以下格式自行编排，编辑时删除） hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 按下ctrl-z之后，shell父进程收到SIGSTP信号,将hello进程挂起，通过ps命令我们可以看出hello进程没有被回收 按下ctrl-c之后，shell父进程收到SIGINT信号，信号处理函数的逻辑是结束hello，并回收hello进程 乱按只是将屏幕的输入缓存到stdin，当下次运行到有关输入的函数例如gets等后，其他字串会当做shell命令行输入 6.7本章小结 本章叙述了hello在被shell调用过程中整个系统的进程调用和信号过程。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 物理地址：CPU通过地址总线的寻址，找到真实的物理内存对应地址。 逻辑地址：程序代码经过编译后出现在 汇编程序中地址。 线性地址：逻辑地址经过段机制后转化为线性地址，为描述符:偏移量的组合形式。 虚拟地址类似线性地址 7.2Intel逻辑地址到线性地址的变换-段式管理 在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值。逻辑地址的格式为段选择符：段内偏移地址 我们首先观察段选择描述符中的T1字段是0or1，得知当前要转换的是GDT中的段，还是LDT中的段，再根据指定的相应的寄存器，得到其地址和大小，得到一个数组，接下来拿出段选择符中的前13位，可以在这个数组中查找到对应的段描述符，即基地址，基地址加上Offset即为要转换的下一个阶段的地址。 7.3Hello的线性地址到物理地址的变换-页式管理 分页把内存划分成大小固定的若干单元，每个单元称为一页，每页包含4k字节的地址空间。每一页的起始地址都是4k字节对齐的。为了能转换成物理地址，我们需要给CPU提供当前任务的线性地址转物理地址的查找表，即页表 为了节约页表占用的内存空间，x86将线性地址通过页目录表和页表两级查找转换成物理地址。32位的线性地址被分成3个部分：最高10位页目录表偏移量，中间10位页表偏移量，最低12位是物理页内的字节偏移量。页目录表的大小为4k，包含1024项，每个项4字节，项目里存储的内容就是页表的物理地址。如果页目录表中的页表尚未分配，则物理地址填0。页表的大小也是4k，同样包含1024项，每个项4字节，内容为最终物理页的物理内存起始地址。 7.4TLB与四级页表支持下的VA到PA的变换 MMU根据VPN访问TLB和页表，获取其中的PPN，并与VPO进行合并，即可得到PA 7.5三级Cache支持下的物理内存访问 首先直接访问一级缓存，不命中时访问二级，再不命中访问三级，接下来主存，访问到后即逐步将新的内容加载到上级缓存中，必要时会进行驱逐。 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程分配一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本，将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 首先删除已存在的用户区域创建新的区域结构:代码和初始化数据映射到.text和.data区（目标文件提供）,.bss和栈映射到匿名文件设置PC，指向代码区域的入口点 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 维护一个虚拟内存区域“堆”，将堆视为=不同大小的块的集合来维护，分为已分配块和空闲块 隐式空闲链表为所有的块构成一个链表，为了方便合并空闲块，每个空闲块存在头部和脚部，可以分为三种情况进行合并，分别为这个空闲块的前面为空闲块，后面不是，或者后面是，前面不是，或者后面前面都是。在这三种情况下分别进行头部脚部的更新操作，即可极大的减少外部碎片发生的几率 对于显式空闲链表，是所有的空闲块构成一个链表，这样在我们寻找空闲块的过程中，就不需要搜索所有块了，只需要寻找所有的空闲块。 7.10本章小结 本章主要介绍了计算机的虚拟内存和物理内存的对应关系，以及在程序运行时，分配内存等操作。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 （以下格式自行编排，编辑时删除） 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 1.打开和关闭文件:open()andclose() 2.读写文件:read()andwrite() 3.改变当前的文件位置lseek() 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(–n>=0)?(unsignedchar)*bb++:EOF; } 8.5本章小结 本章主要阐述了LinuxI/O和UnixI/O接口的关系方式和信息，并分析了一些经典函数例如printf和getchar （第8章1分） 结论 Hello.c程序到最后经过了以下的过程预处理---编译---汇编---链接---运行---创建子进程---运行程序---执行指令 预处理将我们引用的库转换为代码放到代码中，编译将完全体的代码转换为汇编代码，汇编将汇编代码生成可重定位目标文件，链接将我们运行时需要的库加载进来，并进行重定位操作。运行调用shell，创建进程加载我们的程序，执行指令即为CPU将我们的程序转换为底层的指令信息。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.i:预处理文件；hello.s编译后文件；hello.o:可重定位目标文件；hello可执行目标文件；helloobj.objdmp：反汇编代码helloelf.elf：hello.o的elf格式文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 

Trie树 字符串的插入和查找 如果给定n个字符串，要你在其中寻找字符串s 思路： 暴力算法：挨个比较，直到找出O(nm)如何让他的复杂度变回线性呢，就要用到Trie树了建立一个树，每个节点对应一个编号，表示一个字母，如果要在这个节点下再加入一个字母，则节点编号数++ 用ch[i][a]表示一条边，i是父亲节点的编号，a是一个字母，如果父亲对这个字母有连边，ch[i][a]=sz(编号）++，所以ch[i][a]对应字母a的编号，继续插入时从sz继续讨论当一个字符串插入完成后，在这个字符串的最后字母上加上附加值，表示这个字母是一个字符串的终点，当附加值==0时，表示他不是任何字符串的终点，这个附加值可以是字符串的标号 建成的树如图（出自刘汝佳《算法竞赛入门经典训练指南》） #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=2000+10; intd[MAXN]; //字母表为全体小写字母的Trie structTrie { intsz; intch[MAXN][26]; voidclear(){sz=1;memset(ch[0],0,sizeof(ch[0]));sz=1;}//初始时只有一个根结点 intval[MAXN]; intcal(chara){returna-'a';} //插入字符串s，附加信息为v。注意v必须非0，因为0代表“本结点不是单词结点” voidinsert(constchar*s,intv) { intu=0; intn=strlen(s); for(inti=0;i<n;i++) { intc=cal(s[i]); if(!ch[u][c])//结点不存在 { memset(ch[sz],0,sizeof(ch[sz]));//相当于申请新的内存空间（把即将加入的节点编号初始化） val[sz]=0;//中间结点的附加信息为0 ch[u][c]=sz++;//新建结点 } u=ch[u][c];//往下走 } val[u]=v;//字符串的最后一个字符的附加信息为v } //找出字符串s并返回它的附加信息 intfind(constchar*s)//查找 { intu=0; intn=strlen(s); for(inti=0;i<n;i++) { intc=cal(s[i]); if(ch[u][c])u=ch[u][c];//如果下一个字符在树中，往下走 elsereturn0; } if(!val[u])return0;//如果最后一个字符没有附加信息，则没有该字符串 elsereturnval[u]; } }; Trietrie; charstr[MAXN]; intmain() { trie.clear(); while(scanf("%s",str)==1) { trie.insert(str,3); cout<<trie.find(str)<<endl; } return0; } 

洛谷1011车站（数学，模拟） LUOGU-P1011车站（数学，模拟） 题目描述 火车从始发站（称为第1站）开出，在始发站上车的人数为a，然后到达第2站，在第2站有人上、下车，但上、下车的人数相同，因此在第2站开出时（即在到达第3站之前）车上的人数保持为a人。从第3站起（包括第3站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第n-1站），都满足此规律。现给出的条件是：共有N个车站，始发站上车的人数为a，最后一站下车的人数是m（全部下车）。试问x站开出时车上的人数是多少？ 输入格式：a(<=20)，n(<=20)，m(<=2000)，和x(<=20)， 输出格式：从x站开出时车上的人数。 输入输出样例 输入样例#1：57324输出样例#1：13 分析： 因为“上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数”，所以实际上这一站添加的人数相当于前一站上车的人数设第二站上车人数为b，因为“上车的人数都是前两站上车人数之和“，递推出每一站的上车人数： 1234567…aba+ba+2b2a+3b3a+5b5a+8b 所以可以初始化上车人数数组，用ac[i]表示a的系数，用bc[i]表示b的系数 voidinit_c() { ac[1]=1;ac[2]=0; bc[1]=0;bc[2]=1; for(inti=3;i<=n;i++) { ac[i]=ac[i-1]+ac[i-2]; bc[i]=bc[i-1]+bc[i-2]; } } 所以第x站的人数=a*(ac[1]+ac[2]+ac[3]+…+ac[x])+b*(bc[1]+bc[2]+bc[3]+…+bc[x])用sac[i]表示(ac[1]+ac[2]+ac[3]+…+ac[i])，sbc[i]同理 voidinit_sc() { for(inti=1;i<=n;i++) { sac[i]=ac[i]+sac[i-1]; sbc[i]=bc[i]+sbc[i-1]; } } 然后根据最后一站（第n站）下车的人数即可推出b，即 b=m−(a+a∗sac[n−3])sbc[n−3] 注意：因为第n站为终点站，所以该站下车的人数等于从n-1站开出是的人数，所以要在n-1的基础上-2，即sac[n-3]那么从第x站开出时车上人数（此时不用-1）： x=a+a∗sac[x−2]+b∗sbc[n−2] 代码： #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=100+10; intac[MAXN],bc[MAXN];//a的系数和b的系数,代表上车的人数 intsac[MAXN],sbc[MAXN]; inta,n,m,x,b; voidinit_c() { ac[1]=1;ac[2]=0; bc[1]=0;bc[2]=1; for(inti=3;i<=n;i++) { ac[i]=ac[i-1]+ac[i-2]; bc[i]=bc[i-1]+bc[i-2]; } } voidinit_sc() { for(inti=1;i<=n;i++) { sac[i]=ac[i]+sac[i-1]; sbc[i]=bc[i]+sbc[i-1]; } } intmain() { cin>>a>>n>>m>>x; init_c(); init_sc(); b=(m-a-a*sac[n-3])/sbc[n-3]; intans=a+a*sac[x-2]+b*sbc[x-2]; cout<<ans; return0; } 

线段树基本操作（1） 线段树基本操作（1） （建树，查询和单点修改） 用途 线段树可以快速的对一段区间进行操作，包括求区间最值，并在对某点修改后再次求区间最值，对一个区间上的所有点进行修改等不需要对区间上的元素进行循环，而是一种类似于二分，分治的思想 方法 把一段长度为2^k的区间逐次对半分，可以总共分成2^(k+1)-1各节点，变成了一棵二叉树对于区间[lt,rt]，它的子节点为区间[lt,mid]和区间[mid+1,rt]查询时只要要查询的区间的左右边界刚好等于已知区间的边界，就可以返回值了，不需要一搜到底对于单点修改，基本上和二分查找差不多（查找时查找的值是该点的下标） //线段树 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; intn; intval[2*MAXN],p[MAXN]; voidbuild(intnode,intlt,intrt)//建树 { if(lt==rt){val[node]=p[lt];return;} intmid=(lt+rt)>>1; build(node*2,lt,mid);build(node*2+1,mid+1,rt); val[node]=min(val[node*2],val[node*2+1]); return; } intquery(intnode,intlt,intrt,intll,intrr)//区间查询 //lt,rt：点node的左右区间ll,rr：要查的左右区间 { if(lt==ll&&rt==rr)returnval[node]; intmid=(lt+rt)>>1; if(rr<=mid)returnquery(node*2,lt,mid,ll,rr); if(ll>mid)returnquery(node*2+1,mid+1,rt,ll,rr); intv1=query(node*2,lt,mid,ll,mid); intv2=query(node*2+1,mid+1,rt,mid+1,rr); returnmin(v1,v2); } //使用条件：相邻的区间的信息可以被合并成两个区间的并区间的信息 voidchange(intnode,intlt,intrt,intu,intadd)//单点修改 //u要修改的值的下标，add要给修改的值加上的值 { if(lt==rt){val[node]+=add;return;} intmid=(lt+rt)>>1; if(u<=mid)change(node*2,lt,mid,u,add); if(u>mid)change(node*2+1,mid+1,rt,u,add); val[node]=min(val[node*2],val[node*2+1]);//回溯修改 } intmain() { cin>>n; for(inti=1;i<=n;i++) cin>>p[i]; build(1,1,n); //intl,r; //cin>>l>>r; //cout<<query(1,1,n,l,r); intu,d; cin>>u>>d; change(1,1,n,u,d); cout<<query(1,1,n,2,4); return0; } 

有向图的强连通分量（Tanjan） 给定一个有向图，定义： 强连通分量：在一堆点中，任意两点都可以互相到达 求所有的强联通分量 思路： 记录一个点的时间戳和他能到达的最早点每深搜到一个点进队列，直到发现一个点能到达的最早点就是他自己，则把队尾一直到他的所有点输出，这就是一个强联通分量里的所有点 //Tanjan求强连通分量 #include<stack> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; intn,m; intlowlink[MAXN],qiang[MAXN],qiang_cnt; intpre[MAXN],tim; stack<int>s; inthead[MAXN],cnt; structedge { intto,next,num; }e[MAXN]; voidadd(intu,intv,inty) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].num=y; } voiddfs(intu) { pre[u]=lowlink[u]=++tim; s.push(u); for(inti=head[u];i;i=e[i].next) { intv=e[i].to; if(!pre[v]) { dfs(v); lowlink[u]=min(lowlink[u],lowlink[v]);//用后代所能到达的最早点更新u所能到达的最早点 } elseif(!qiang[v])lowlink[u]=min(lowlink[u],pre[v]);//如果遇到一个点已经讨论过，但是还没有加入任何强连通分量，则将他的时间戳与lowlink更新 } if(lowlink[u]==pre[u]) { qiang_cnt++; while(1) { intx=s.top();s.pop(); qiang[x]=qiang_cnt; if(x==u)break; } } } intmain() { intn,m; cin>>n>>m; for(inti=1;i<=m;i++) { intu,v;cin>>u>>v; add(u,v,i); } for(inti=1;i<=n;i++) if(!pre[i])dfs(i); for(intk=1;k<=qiang_cnt;k++) { for(inti=1;i<=n;i++) if(qiang[i]==k)cout<<i<<""; cout<<endl; } return0; } 

拓扑排序 给定一些关系，如a>b，要求生成拓扑序，即对于所有形如a>b的关系，最后生成的点的序列中a必须在b的前面 可以把每个关系看成一条有向边，很明显，如果可以生成序列，则这个图一定是无环的所以问题转化成了遍历有向图，生成序列，后搜索到的节点一定在先搜索到的节点的后面可以用dfs处理，每搜索到一个元素，如果他后面不会生成环，就把他放入队首，因为当当前dfs退出时，新的当前dfs的元素要放在上一个前面，所以在放在队首即可如何判断是否形成了环呢？可以定义一个标记，如果u的指向v的标记值为-1，表示这个点正在dfs的上面某层中，即当前讨论的点u一定是从点v连过来的，（即递归调用dfs(v)正在栈帧中，尚未返回），就形成环了，直接returnfalse如果标记值为-1，表示没有讨论过因为每个点只能进队一次，所以标记值为1时，表示已经进过队了，不再讨论 下面是代码 //拓扑排序 #include<cstdio> #include<stack> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=10000+10; intn,m; stack<int>s; structedge { intnext,to; }e[MAXN]; inthead[MAXN],cnt; voidadd(intu,intv) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; } intvis[MAXN];//在dfs中，判断点i的状态，如果为-1表示该点正在被访问，0表示为被访问过，1表示已经访问过 booldfs(intu) { vis[u]=-1; for(inti=head[u];i;i=e[i].next) { intv=e[i].to; if(vis[v]==-1)returnfalse; if(!vis[v]&&!dfs(v))returnfalse; } vis[u]=1; s.push(u);//因为DFS会一直到底，所以到底后把元素放入队首，return后到上一层函数后在放入队首，可以保证正序 returntrue; } voidprint_ans() { while(!s.empty()) {cout<<s.top()<<"";s.pop();} } booltapo() { memset(vis,0,sizeof(vis)); for(inti=1;i<=n;i++)if(!vis[i]) if(!dfs(i))returnfalse; returntrue; } intmain() { cin>>n>>m; for(inti=1;i<=m;i++) { intu,v; cin>>u>>v; add(u,v); } if(tapo())print_ans(); elsecout<<"NO"; return0; } 

二分图（1）--染色问题 题目大意：给定一个连通图，让你对它进行染色，总共黑白两种颜色，相邻两个节点不能是同一种颜色，问是否可以染 解析： 二分图：对于一个无向连通图，如果可以把所有点分成不相交的两部分，使所有边的起点和终点分别在两个部分内，称为二分图（即不能有边的起点和终点在一个部分内）转化为本题即为不能有边的起点和终点是同一种颜色 如图 代码实现： 定义数组color[]，1表示白色，2表示黑色，0表示未访问用dfs，对于dfs(u)，遍历它的所有v，如果有v访问过并且与他同色，返回false对于未访问过的v,对他染色并dfs(v)，如果dfs(v)不成功dfs(u)也不成功 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; intcolor[MAXN]; intn,m; inthead[MAXN],cnt; structedge { intto,next; }e[MAXN]; voidadd(intu,intv) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; } boolerfen(intu) { for(inti=head[u];i;i=e[i].next) { intv=e[i].to; if(color[u]==color[v])returnfalse; if(!color[v]) { color[v]=3-color[u]; if(!erfen(v))returnfalse; } } returntrue; } intmain() { cin>>n>>m; for(inti=1;i<=m;i++) { intu,v; cin>>u>>v; add(u,v);add(v,u); } color[1]=1; if(erfen(1))cout<<"YES"; elsecout<<"NO"; return0; } 

POJ2393USACOMarchGold 对于每周的货物，讨论他之前的星期，如果提前生产费用就是c[i]+(j-i)*s,会TLE，所以要进行剪枝 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; longlongn,s,ans; constintMAXN=10000+10; longlongc[MAXN],y[MAXN],vis[MAXN]; intmain() { cin>>n>>s; for(inti=1;i<=n;i++) cin>>c[i]>>y[i]; for(inti=2;i<=n;i++) for(intj=i-1;j>=1;j--) { if((c[j]+(i-j)*s)<c[i])c[i]=c[j]+(i-j)*s; if(vis[j])break; elsevis[j]=1; } for(inti=1;i<=n;i++) ans+=y[i]*c[i]; cout<<ans; return0; } 

Havel-Hakimi定理 Havel定理是用来判断是否成图的，对于一个点的序列，现在已知每个点的度，要求判定是否可以按要求组成一个图 判定过程： 把所有点按照度的大小从大到小排序对首元素的度为s1，则删除该元素，把他后面的s1个元素的度都-1，然后重新排序不断重复这个循环，如果过程中有点的度变成了-1，则不能成图，如果最后所有点的度都为0，则可以成图可以在给点的度-1的时候把s1和后面的连起来，就可以输出图了 //Havel-Hakimi boolHavel() { for(inti=1;i<n;i++) { sort(s+i,s+1+n,cmp); if(i+s[i]>=n)returnfalse;//如果改点的度大于所剩的点，无法成图 intu=s[i]; for(intj=i+1;j<=i+u;j++) { s[j]--; if(s[j]<0)returnfalse; } } if(s[n-1]!=0)returnfalse; returntrue; } 例题：POJ1659（模板题，要输出图） （时间关系暂时不做） 

无向图的割顶和桥 给定一个无向连通图，有以下定义： 割顶：如果去掉一个节点，可以把这个无向连通图变成两个连通图，称其为割顶桥：同理，如果去掉一条边，可以把这个连通图变成两个，称其为桥 求割顶和桥： 令一个点为根，从这个点开始dfs用pre表示时间戳，每搜到一个还未搜到的点，标记搜到他的时间用low[]表示一个点可以连接的时间最早的点，而如果这个值还没有它的父亲的时间早或等于他父亲的时间，那么这个点的父亲一定是割顶如图（出自《算法竞赛入门经典训练指南》–刘汝佳）而如果这个值严格大于他父亲的时间，则连接他父亲和他的的这条边一定是桥如果一个点没有父亲，且只有一个儿子，那么他是根且一定不是割顶 //无向连通图的割顶与桥 #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; constintMAXN=1000+10; intn,m; intiscut[MAXN];//是否为割顶 intisbri[MAXN];//是否为桥 inttim; intlow[MAXN],pre[MAXN]; inthead[MAXN],cnt; structedge { intto,next,num; }e[MAXN]; voidadd(intu,intv,inty) { e[++cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; e[cnt].num=y; } intdfs(intu,intfa) { intlowu=pre[u]=++tim; intchild=0; for(inti=head[u];i;i=e[i].next) { intv=e[i].to; if(!pre[v]) { child++; intlowv=dfs(v,u); lowu=min(lowu,lowv);//用其子节点的low更新low值 if(lowv>=pre[u])//如果v点的后代只能连到v自己，则该边为桥，且u为割顶，若还可以连到u，则u仍为割顶且该边不为桥 { if(lowv>pre[u])isbri[e[i].num]=true; iscut[u]=true; }//{iscut[u]=true;isbri[e[i].num]=true;} } elseif(pre[v]<pre[u]&&v!=fa)lowu=min(lowu,pre[v]);//从他连到其父亲的边不是反向边，如果删除他父亲是不能连通的，重点 } if(fa<=0&&child==1)iscut[u]=0;//如果u为根且只有一个儿子，不是割顶 low[u]=lowu; returnlow[u]; } intmain() { intn,m; cin>>n>>m; for(inti=1;i<=m;i++) { intu,v;cin>>u>>v; add(u,v,i);add(v,u,i); } dfs(1,0); for(inti=1;i<=n;i++) if(iscut[i])cout<<i<<""; cout<<endl; for(inti=1;i<=m;i++) if(isbri[i])cout<<i<<""; return0; } 

2021-06-30 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算学部学 号1190201820班 级1936603学生金翰廷 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要通过在linux系统中对hello.c的分析，结合书上的材料，我们又把程序的预处理、编译、汇编、链接的过程复习了一遍，使我们对计算机系统这门课的理解更加深入。关键词：linux；计算机系统；汇编； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录 第1章概述-4-1.1HELLO简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在UBUNTU下预处理的命令-5-2.3HELLO的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在UBUNTU下编译的命令-6-3.3HELLO的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在UBUNTU下汇编的命令-7-4.3可重定位目标ELF格式-7-4.4HELLO.O的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在UBUNTU下链接的命令-8-5.3可执行目标文件HELLO的格式-8-5.4HELLO的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6HELLO的执行流程-8-5.7HELLO的动态链接分析-8-5.8本章小结-9-第6章HELLO进程管理-10-6.1进程的概念与作用-10-6.2简述壳SHELL-BASH的作用与处理流程-10-6.3HELLO的FORK进程创建过程-10-6.4HELLO的EXECVE过程-10-6.5HELLO的进程执行-10-6.6HELLO的异常与信号处理-10-6.7本章小结-10-第7章HELLO的存储管理-11-7.1HELLO的存储器地址空间-11-7.2INTEL逻辑地址到线性地址的变换-段式管理-11-7.3HELLO的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级CACHE支持下的物理内存访问-11-7.6HELLO进程FORK时的内存映射-11-7.7HELLO进程EXECVE时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章HELLO的IO管理-13-8.1LINUX的IO设备管理方法-13-8.2简述UNIXIO接口及其函数-13-8.3PRINTF的实现分析-13-8.4GETCHAR的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介Hello从出生到死亡，经历了cpp的预处理，ccl的编译，as的汇编，ld的链接。从hello.c到hello.i，从hello.s到hello.o。用户在运行此程序时，shell调用fork产生子进程，hello便成了进程。1.2环境与工具1.2.1硬件环境AMDRyzen75800HwithRadeonGraphicsCPU3.20GHz16GBRAM512GcSSDNVIDIAGeForceRTX3060LaptopGPU1.2.2软件环境Windows1064位VMware15.5.1Ubuntu16.04LTS64位1.2.3开发工具GDBEDBGCCvigedit1.3中间结果hello.i预处理后的文件hello.s汇编代码hello.o二进制文件hello.out可执行程序1.4本章小结本章主要介绍了什么是hello，本文用到的环境和工具，以及一些中间结果 第2章预处理2.1预处理的概念与作用预处理是指在源代码编译之前对其进行的处理。它会将以#include格式包含的文件复制到编译的源文件中。用实际值替换#define定义的字符串。2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 这是hello.i部分结果的截图。由于#include文件被展开，hello.i的行数相较于hello.c急剧增加。2.4本章小结本章讲述了预处理的命令，预处理的概念和作用，以及预处理之后的结果变化。 第3章编译3.1编译的概念与作用ccl的编译使.i文件变成.s文件。编译的时候可以选取适当的优化等级。编译的主要目的是把源程序翻译成目标程序，即高级语言变成汇编语言。3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析3.3.1赋值 3.3.2关系操作 3.3.3函数调用 3.3.4数组访问 3.3.5算术操作 3.3.6数据 int在赋值之前不占空间，使用时保存在寄存器中。字符串类型保存在只读数据区。各种立即数直接在汇编代码中显示。3.3.7局部变量 3.3.8全局函数 3.4本章小结本章讲述了编译的概念和作用，并给出了在Ubuntu下如何获得.s文件。以及在.s中各种命令的解释，各种操作和数据对应的汇编代码。 第4章汇编4.1汇编的概念与作用汇编器as将.s变成.o文件。相当于把机器语言指令打包成可重定位目标程序的格式。4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 Elf头信息位于文件最开始的部分，包括整个文件的结构信息，后面的内容包括Elf的头的大小，机器类型，节头部表，文件偏移，节头部表中条目的大小和数量。节头信息描述了hello.o文件中各个节的信息。重定位条目与符号表信息包括重定位类型与符号所在的位置，用于在链接时提供修改所需的信息。4.4Hello.o的结果解析 反汇编代码 hello.s反汇编代码相比于hello.s要多出机器代码。机器语言是二进制机器指令，是给电脑看的，汇编语言是使用代码描述CPU的动作，是给人看的。二者的映射大部分相同，在细微的地方有一些不同之处。变量符号与函数的调用地址被地址或重定位符号所取代。除此之外，hello.s的操作数是十进制的，但反汇编中的操作数是十六进制的。4.5本章小结本章介绍了一些linux下的代码，hello.o的elf信息和hello.o的反汇编文件与hello.s的异同。 第5章链接5.1链接的概念与作用链接是指将各种代码和数据片段收集并组合成一个单一文件的过程。链接可以在源代码编译成机器代码的时候，程序被加载器加载到内存并执行的时候，应用程序执行时使用。5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 代码区，数据区，共享区，栈，只读数据区，少了重定位段，符号表，GOT5.5链接的重定位过程分析 hello反汇编代码完成了重定位，有确定的虚拟地址，hello.o的反汇编代码未完成重定位，代码中的虚拟地址均为0。hello重定位的过程：(1)重定位节和符号定义链接器将所有类型相同的节合并在一起后，这个节就作为可执行目标文件的节。然后链接器把运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号，当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。(2)重定位节中的符号引用这一步中，连接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。执行这一步，链接器依赖于可重定位目标模块中称为的重定位条目的数据结构。(3)重定位条目当编译器遇到对最终位置未知的目标引用时，它就会生成一个重定位条目。代码的重定位条目放在.rel.txt。5.6hello的执行流程使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。5.7Hello的动态链接分析（以下格式自行编排，编辑时删除）分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 5.8本章小结本章主要介绍了链接的概念与作用。详细介绍了hello.o链接成可执行目标文件的过程。 第6章hello进程管理6.1进程的概念与作用进程是程序的一次执行，进程是程序及其数据在CPU下顺序执行时所发生的活动，进程是具有独立功能的程序在数据集上运行的过程，它是系统进行资源分配和调度的一个独立单位。进程控制是进程管理中最主要的功能。它用于创建一个新进程，终止一个已完毕的进程。或者去终止一个因出现某事件而使其无法执行下去的进程。还可负责进程执行中的状态转换。6.2简述壳Shell-bash的作用与处理流程shell俗称壳,是一种指"为使用者提供操作界面"的嵌入式软件(也被称为命令解析器)。软件提供了一种允许用户与其他操作系统之间进行通讯的一种方式。这种简单的通讯方式可以以交互方式(从键盘输入,并且用户可以立即地得到命令响应),或者以交互方式shellscript(非交互)的方式允许用户执行。shell（即壳）它是一个简单的命令解释器,它允许系统接收到一个用户的命令,然后自动调用相应的命令执行应用程序。Shell的处理流程：shell读取用户从终端使用外部设备输入（通常是键盘输入）的指令。解析所读取的指令，如果这个指令是一个内部指令则立即执行，否则，加载调用一个应用程序为申请的程序创建新的子进程，在子进程的上下文中运行。同时shell还允许接收从键盘读入的外部信号，（如：kill）并根据不同信号的功能进行对应的处理。6.3Hello的fork进程创建过程用户在终端输入对应的指令，这时shell就会读取输入的命令，并开始进行以下操作：第一步：判断hello不是一个内置的shell指令，所以调用应用程序，找到当前所在目录下的可执行文件hello，准备执行。Shell会自动的调用fork（）函数为父进程创建一个新的子进程，子进程就会因此得到与父进程（即shell）虚拟地址空间相同的一段各种的数据结构的副本（包括代码和数据段，堆，共享库和用户栈）。父进程与子进程最大的不同在于他们分别拥有不同的PID，父进程与子进程分别是两个并发的进程，在子进程中程序运行的这个过程中，父进程在原位置等待着程序的运行完毕。6.4Hello的execve过程Execve函数加载并运行可执行目标文件hello，且且包含相对应的一个带参数的列表argv和环境变量的列表exenvp,，只有当出现错误时，例如找不到hello文件时，execve才会返回-1到调用程序，execve调用成功则不会产生返回。在shell调用fork函数之后，execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行程序，使用启动加载器，子进程调用execve函数，在当前进程即子进程的上下文中加载新程序hello，这个程序覆盖当前正在执行的进程的所有的地址空间，但是这样的操作并没有创建一个新的进程，新的进程有和原先进程相同的PID，并且它还继承了打开hello调用execve函数之前所有已经打开的文件描述符。新的栈和堆段都会被初始化为零，新的代码和数据段被初始化为可执行文件中的内容。只有一些调用程序头部的信息才可能会在加载的过程中被从可执行磁盘复制到对应的可执行区域的内存6.5Hello的进程执行进程向每个程序人员提供一种假象,好像他们在一个独占的程序中使用了处理器,这种处理效果的具体实现效果本身就是一个逻辑控制流,它指的是一系列可执行程序的计数器pc的值,这些计数值唯一的定义对应于那些包含在程序的可执行文件目标对象中的可执行指令,或者说它指的是那些包含在程序运行时可以动态通过链接触到可执行程序的共享文件对象的可执行指令。时间片是指一个进程在执行控制流时候所处在的每一个时间段。处理器通过设置在某个控制寄存器中的一个模式位来限制一个程序可以可以执行的指令以及它可以访问的地址空间。没有设置模式位时，进程就运行在用户模式中。用户模式下不允许执行特权指令，不允许使用或者访问内核区的代码或者数据。设置模式位时，进程处于内核模式，该进程可以访问系统中的任何内存位置，可以执行指令集中的任何命令。进程从用户模式变为内核模式的唯一方式是使用诸如中断，故障或陷入系统调用这样的异常。异常发生时，控制传递到异常处理程序，处理器从用户模式转到内核模式。上下文在运行时候的状态这也就是一个进程内核重新开始启动一个被其他进程或者对象库所抢占的网络服务器时该进程所可能需要的一个下文状态。它由通用寄存器、浮点数据寄存器、程序执行计数器、用户栈、状态数据寄存器、内部多核栈和各种应用内核数据结构等各种应用对象的最大值数据寄存器组合构成。在调用进程发送sleep之前,hello在当前的用户内核模式下进程继续运行,在内核中进程再次调用当前的sleep之后进程转入用户内核等待休眠模式,内核中所有正在处理等待休眠请求的应用程序主动请求释放当前正在发送处理sleep休眠请求的进程,将当前调用hello的进程自动加入正在执行等待的队列,移除或退出正在内核中执行的进程等待队列。之后设置定时器，休眠的时间等于自己设置的时间，当计时器时间到时候，发送一个中断信号。内核收到中断信号进行中断处理，hello被重新加入运行队列，等待执行，这时候hello就可以运行在自己的逻辑控制流里面了。6.6hello的异常与信号处理中断（在hello程序执行的过程中可能会出现外部I/O设备引起的异常），异步，总是返回到下一条指令。陷阱（有意的异常，是执行一条指令的结果，hello执行sleep函数的时候会出现这个异常。），同步，总是返回到下一条指令。故障（在执行hello程序的时候，可能会发生缺页故障。），同步，可能返回到当前指令。终止（不可恢复的错误，在hello执行过程可能会出现DRAM或者SRAM位损坏的奇偶错误。），同步，不会返回。 正常结果 输入ctrl+z 运行在后台输入ps fg1 通过fg1可以调到前台 Ctrl+c 在键盘上输入Ctrl+c会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况是终止前台作业。乱按 乱按只是将屏幕的输入缓存到stdin。6.7本章小结本章介绍了shell的流程作用，hello的进程执行，相关异常处理和信号处理。 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：程序经过编译后出现在汇编代码中的地址。逻辑地址用来指定一个操作数或者是一条指令的地址。是由一个段标识符加上一个指定段内相对地址的偏移量，表示为[段标识符：段内偏移量]。线性地址：也叫虚拟地址，和逻辑地址类似，也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件也是内存的转换前地址。虚拟地址：也就是线性地址。物理地址：用于内存芯片级的单元寻址，与处理器和CPU链接的地址总线相对应。可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。7.2Intel逻辑地址到线性地址的变换-段式管理每个段的首地址就会被储存在各自的段描述符里面,所以的段描述符都将会位于段全局描述符表中(每个段的全局描述符表一个局部称为gdgdt和另一个局部的的段描述符表一个局部称为ldldt),通过段选择符我们可以快速寻找到某个段的段全局描述符。逻辑上段地址的偏移量结构就是段选择符+偏移量。段选择符的索引位组成和定义如下,分别指的是索引位(index),ti,rpl,当索引位ti=0时,段描述符表在rpgdt中,ti=1时,段描述符表在rpldt中。而索引位index就类似一个数组,每个元素内都存放一个段的描述符,索引位首地址就是我们在查找段描述符时再这个元素数组当中的索引。一个段描述符的首地址是指含有8个元素的字节,我们通常可以在查找到段描述符之后获取段的首地址,再把它与线性逻辑地址的偏移量进行相加就可以得到段所需要的一个线性逻辑地址。在分段保护模式下,分段有两种机制:段的选择符在段的描述符表->分段索引->目标段的段描述符条目->目标段的描述符基地址+偏移量=转换为线性段的基地址。由于现代的macosx86系统内核使用的描述符是基本扁平的逻辑模型,即目标段的逻辑地址=线性段的描述符=转换为线性段的基地址,等价于描述符转换为线性地址时关闭了偏移量和分段的功能。这样逻辑段的基地址与转换为线性段的基地址就合二为一了。7.3Hello的线性地址到物理地址的变换-页式管理在分页的机制下地址转化管理机制主要实现了虚拟地址(它也即非非线性内存地址)向虚拟地址物理页或内存地址的非线性分页转化。vm内存系统将虚拟内存的块大小分割成作为一个被我们称为基于虚拟页的内存大小固定的块块用来进行处理这个固定大小的内存问题,每个称为虚拟页的内存大小可以固定为2p=2p个单位字节。类似的,物理块和虚拟内存被再一次细分为一个物理页(也被通常称为页帧),大小与每一个虚拟页的地址大小与其对应的值相等。例如:一个32位的虚拟机器,线性的地址可以最大达到4gb,用4kb为一个页来进行划分,也可以分为1m个页,通过页表处理和查找这些虚拟页的数据,方便对线性地址的大小进行管理。之后计算机会进行一个翻译操作,把一个n元素的虚拟地址空间中的虚拟元素与一个m元素的另一个物理虚拟地址空间相互进行映射,这个翻译操作被我们称为地址翻译。虚拟地址由对应的虚拟物理页号(vpn)和虚拟页偏移量(vpo)共同组成,类似的,物理地址由虚拟物理页偏移号(ppn)和对应的物理页偏移量(ppo)共同分配组成(这里没有特别考虑tlb快表的物理地址结构)。页表中物理地址存在三种常见的情况:未分配:没有在虚拟内存的空间中分配该条目的内存。未分配缓存:在虚拟内存的空间中已经分配了但是没有被直接缓存到对应物理地址的内存中。已分配已缓存:内存已经缓存在了对应物理地址的内存中。页表的基址寄存器paptbr+vpn在页表中可以获得条目pte,通过对比条目对应的有效位判断物理地址是上述哪一种的情况,如果有效则通过提取得出对应物理地址的页号寄存器ppn,与对应的虚拟页偏移量共同分配构成了物理地址寄存器pa。当页面命中时CPU硬件执行的步骤：第1步:处理器会产生一个虚拟地址,并且将它传送给地址管理单元MMU。第2步:MMU生成PTE地址,并从高速缓存/主存请求得到它。第3步:高速缓存或者主存向MMU返回PTE。第4步:MMU构造物理地址,并把它传送给高速缓存/主存。第5步:高速缓存或者主存会返回所请求的数据字给处理器。7.4TLB与四级页表支持下的VA到PA的变换如果按照上述模式，每次CPU产生一个虚拟地址并且发送给地址管理单元，MMU就必须查找一个PTE行来用将虚拟地址翻译成物理地址。为了消除这种操作带来的大量时间开销，MMU中被设计了一个关于PTE的小的缓存，称为翻译后备缓冲器（TLB）也叫快表。例如当每次cpu发现需要重新翻译一个虚拟地址时,它就必须发送一个vpn得到虚拟地址mmu,发送一个vpo位得到一个l1高速缓存.例如当我们使用mmu向一个tlb的组请求一个页表中的条目时,l1高速缓存通过一个vpo位在页表中查找一个相应的数据标记组,并在页表中读出这个组里的个数据标记和相应的数据关键字.当mmu从一个tlb的组得到一个ppn时,代表缓存的工作在这个组的请求之前已经完全准备好,这个组的ppn与就已经可以与这些数据标记文件中的一个虚拟地址进行很好的匹配了。corei7采用四级页表层次结构,每个四级页表进程都有他自己私有的页表层次结构,这种设计方法从两个基本方面就是减少了对内存的需求,如果一级页表的pte全部为空,那么二级页表就不会继续存在,从而为进程节省了大量的内存,而且也只有一级页表才会有需要总是在一个内存中。四级页表的层次结构操作流程如下:36位虚拟地址被寄存器划分出来组成四个9位的片,每个片被寄存器用作到一个页表的偏移量。cr3寄存器内储存了一个l1页表的一个物理起始基地址,指向第一级页表的一个起始和最终位置,这个地址是页表上下文的一部分信息。vpn1提供了到一个l1pet的偏移量,这个pte寄存器包含一个l2页表的起始基地址.vpn2提供了到一个l2pte的偏移量,一共四级,逐级以此层次类推。7.5三级Cache支持下的物理内存访问L1,L2,L3原理相同，此处以L1为例。由于L1Cashe有64组，所以组索引位s为6，每组有8个高速缓存行，由于每个块的大小为64B，所以块偏移为为6，因此标记位为52-6-6=40位。因此L1Cashe的物理访存大致过程如下：(1)组选择取出虚拟地址的组索引位，将二进制组索引转化为一个无符号整数，找到相应的组(2)行匹配把虚拟地址的标记为拿去和相应的组中所有行的标记位进行比较，当虚拟地址的标记位和高速缓存行的标记位匹配时，而且高速缓存行的有效位是1，则高速缓存命中。(3)字选择一旦高速缓存命中，我们就知道我们要找的字节在这个块的某个地方。因此块偏移位提供了第一个字节的偏移。把这个字节的内容取出返回给CPU即可(4)不命中如果高速缓存不命中，那么需要从存储层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位所指示的组中的一个高速缓存行中。一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换。7.6hello进程fork时的内存映射当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。7.7hello进程execve时的内存映射execve函数在当前代码共享进程的上下文中加载并自动运行一个新的代码共享程序,它可能会自动覆盖当前进程的所有虚拟地址和空间,删除当前进程虚拟地址的所有用户虚拟和部分空间中的已存在的代码共享区域和结构,但是它并没有自动创建一个新的代码共享进程。新的运行程序仍然在堆栈中拥有相同的区域pid。之后为新运行程序的用户共享代码、数据、bss和所有堆栈的区域结构创建新的共享区域和结构,这一步叫通过链接映射到新的私有代码共享区域,所有这些新的代码共享区域都可能是在运行时私有的、写时复制的。它首先映射到一个共享的区域,hello这个程序与当前共享的对象libc.so链接,它可能是首先动态通过链接映射到这个代码共享程序上下文中的,然后再通过映射链接到用户虚拟地址和部分空间区域中的另一个共享代码区域内。为了设置一个新的程序计数器,execve函数要做的最后一件要做的事情就是自动设置当前代码共享进程上下文的一个程序计数器,使之成为指向所有代码共享区域的一个入口点(即_start函数)。7.8缺页故障与缺页中断处理缺页故障：当指令引用一个相应的虚拟地址，而与改地址相应的物理页面不再内存中，会触发缺页故障。通过查询页表PTE可以知道虚拟页在磁盘的位置。缺页处理程序从指定的位置加载页面到物理内存中，并更新PTE。然后控制返回给引起缺页故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，因此指令可以没有故障的运行完成。7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域,称为堆.系统之间细节不同,但是不失通用性,假设堆是一个请求二进制零的区域,它紧接在未初始化的数据区域后开始,并向上生长（向更高的地址）.对于每个进程,内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护.每个块就是一个连续的虚拟内存片,要么是已分配的,要么是空闲的.已分配的块显式地保留为供应用程序使用.空闲块可用来分配.空闲块保持空闲,直到它显式地被应用所分配.一个已分配的块保持已分配状态,直到它被释放,这种释放要么是应用程序显式执行的,要么是内存分配器自身隐式执行的。分配器有两种基本风格.两种风格都要求应用显式地分配块.它们的不同之处在于由哪个实体来负责释放已分配的块显式分配器(explicitallocator)：要求应用显式地释放任何已分配的块.例如,C标准库提供一种叫做malloc程序包的显式分配器.C程序通过调用malloc函数来分配一个块,并通过调用free函数来释放一个块.C++中的new和delete操作符与C中的malloc和free相当.隐式分配器(implicitallocator)：要求分配器检测一个已分配块何时不再被程序所使用,那么就释放这个块.隐式分配器也叫做垃圾收集器(garbagecollector),而自动释放未使用的已分配的块的过程叫做垃圾收集(garbagecollection).例如,诸如Lisp、ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。一个块是由一个字的头部,有效载荷,以及可能的一些额外的填充组成的.头部编码了这个块的大小,以及这个块是已分配的还是空闲的.如果我们强加一个双字的对齐约束条件,那么块大小就总是8的倍数,且块大小的最低3位总是零.因此,我们只需要内存大小的29个高位,释放剩余的3位来编码其他信息.在这种情况中,我们用其中的最低位(已分配位)来指明这个块是已分配的还是空闲的。7.10本章小结本章主要通过对hello程序运行时虚拟地址的变化进行分析,解析了适用于hello应用程序的虚拟存储地址空间,分析了虚拟地址,线性地址和虚拟物理线性地址之间的互相转换,页表的命中与不页表的命中,使用动态快表缓存作为页表的高速缓存以及如何加速页表,动态内存管理的操作,fork时的动态内存中断与映射、execve时的动态内存中断与映射、缺页的中断与缺页映射和中断的处理。第8章hello的IO管理8.1Linux的IO设备管理方法一个Linux文件就是一个m个字节的序列，：所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。8.2简述UnixIO接口及其函数UnixI/O接口：1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。2.Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。3.改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。5.关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。UnixI/O函数:1.intopen(char*filename,intflags,mode_tmode)，进程通过调用open函数来打开一个存在的文件或是创建一个新文件的。open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程中当前没有打开的最小描述符，flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。2.intclose(fd)，fd是需要关闭的文件的描述符，close返回操作结果。3.ssize_tread(intfd,void*buf,size_tn)，read函数从描述符为fd的当前文件位置赋值最多n个字节到内存位置buf。返回值-1表示一个错误，0表示EOF，否则返回值表示的是实际传送的字节数量。4.ssize_twirte(intfd,constvoidbuf,size_tn)，write函数从内存位置buf复制至多n个字节到描述符为fd的当前文件位置。8.3printf的实现分析printf的函数体：intprintf(constcharfmt,…){inti;charbuf[256];va_listarg=(va_list)((char)(&fmt)+4);i=vsprintf(buf,fmt,arg);write(buf,i);returni;}va_listarg=(va_list)((char)(&fmt)+4);vsprintf返回的是要打印出来的字符串的长度，它的作用就是产生格式化输出。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章描述了Linux的IO接口及设备的管理。简要的对printf函数的设计和实现做了讲解。结论hello程序最初是一个.c文件，它的内容是程序员所写。写完之后会把hello进行预处理操作从而生成hello.i。随后需要把它转换成.s文件。由于计算机只能识别二进制文件。所以还需要把.s文件转换成.o文件，即可重定位文件。下一步是动态链接过程，hello.o和动态链接库共同链接成可执行目标程序hello。然后hello就可以运行了。运行时shell里面输入./hello1190201820jht。然后fork和execve函数加载映射虚拟内存，为hello创建新的代码数据堆栈段。CPU为hello分配一个时间片，在程序计数器中加入自己的代码，按顺序执行他们。之后程序从cache中很快的取得需要的数据，或者从内存中取出需要的数据，又或是从磁盘加载数据。在此过程中键入ctrl-z就可以让程序挂起，键入ctrl-c，可以停止这个进程。最后，shell回收子进程，内核会删除这个进程使用所需要创建的一系列数据结构。至此，hello程序结束。 附件列出所有的中间产物的文件名，并予以说明起作用。 hello.i经过预处理器处理的源代码，用来查看与源代码的区别。hello.s通过编译器生成的编译程序，用来分析汇编代码与源代码的对应。hello.o可重定位目标程序,分析汇编器行为，通过反汇编与.o进行对比。hello可执行目标程序,分析链接的作用参考文献为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp.[7]https://baike.baidu.com/item/shell/99702?fr=aladdin[8]RandalE.Bryant,DavidR.O’Hallaron.深入理解计算机系统[M].北京：机械工业出版社，2016.7 

计算机系统大作业（程序人生） 摘 要 摘要是论文内容的高度概括，应具有独立性和自含性，即不阅读论文的全文，就能获得必要的信息。摘要应包括本论文的目的、主要内容、方法、成果及其理论与实际意义。摘要中不宜使用公式、结构式、图表和非公知公用的符号与术语，不标注引用文献编号，同时避免将摘要写成目录式的内容介绍。 本文介绍了hello程序在Linux下的生命周期，从被创建到运行，最后被终止等一系列的过程。在结合了书本有关知识的基础上，进一步对hello程序的相关知识进行阐述，并借此来加深对于计算机系统的理解。 关键词：关键词1；关键词2；……； 关键词1：计算机系统 关键词2：程序 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P：hello.c预处理成为hello.i，编译得到hello.s，汇编后得到hello.o，最后通过链接，执行程序得到hello 020：shell启动后通过fork函数激活子进程，子进程调用exceve函数，在引入参数后，映射虚拟内存，然后载入物理内存，进入主函数开始执行代码，CPU为程序分配时间片执行逻辑控制流。在程序运行结束后，父进程对子进程进行回收，，内核删除有关的数据结构。 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位 开发与调试工具：gcc，vim，edb，codeblocks 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 Hello.i hello.c预处理之后的文本文件 Hello.s hello.i编译后的汇编文件 Hello.o hello.s汇编后的可重定位目标文件 Hello 链接后的执行目标文件 Hello.out hello反汇编之后的可重定位文件 1.4本章小结 （第1章0.5分） 本章主要介绍了hello的P2P，020过程，描述了实验的环境，列出了实验中的一些过程文件 第2章预处理 2.1预处理的概念与作用 概念：预处理器根据命令，修改原始C程序 作用：对预处理命令进行处理，1、宏定义2、文件包含3、条件编译 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 预处理之后hello.c转化为hello.i文件，其中文件的内容增加了，这些增加的代码就是头文件的源代码，随后进行宏定义以及拓展和条件编译 2.4本章小结 本章描述了有关hello.i的内容，与hello.c进行比较，加深了解 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译器把hello.i翻译成hello.s，利用处理后的源文件生成一个汇编语言程序 作用：把C语言文件转换成了汇编语言文件 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令 应截图，展示编译过程！ 3.3Hello的编译结果解析 3.3.1数据 局部变量：i:作为再函数中船舰的局部变量i被储存在栈中，在这个程序中i被储存在%rbp-4 3.3.2赋值 唯一的赋值是i=0，i在栈上，用mov赋值 3.3.3算数操作 i++，在本实验中用addl实验 3.3.4关系操作 通过cmpl和标志位的状态来实现 3.3.5数组/指针/结构 Argv数组是传入的参数，储存在栈上，在找到argv的地址后就能通过偏移argv+8和argv+16找到argv[1]和argv[2]的地址 3.3.6控制转移 在汇编语言中控制转移通过cmp再加上jXX来实现，cmp指令来改变标志位，然后再用JXX根据标志位来决定是否跳转 3.3.8函数操作 Main函数，printf函数，exit函数，sleep函数 此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~3.3.x等按照类型和操作进行分析，只要hello.s中出现的属于大作业PPT中P4给出的参考C数据与操作，都应解析。 3.4本章小结 本章描述了如何在编译阶段中系统如何把源代码转换成汇编代码，了解了有关汇编的操作 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：把汇编语言翻译成机器语言的过程 作用：汇编器将hello.s翻译成机器语言指令，并把这些指令打包成一种叫做可重定位目标程序的格式，将结果存在目标文件hello.o中。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。 4.2在Ubuntu下汇编的命令 （以下格式自行编排，编辑时删除） 应截图，展示汇编过程！ 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 ELF格式：以一个16字节序列开始，该序列描述了生成该文件的系统的字的大小和字节顺序，其余信息帮助链接器语法分析和解释目标文件信息 节头部表记录了各节名称、类型、地址、偏移量、大小、全体大小、旗标、连接、信息、对齐信息 重定位节，描述了.text节中需要重定位的信息，即当链接器链接该目标文件时需要修改的信息 符号表：程序中定义和引用函数和全局变量的信息，声明重定位需要引用的符号 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 在跳转时，hello.s是直接利用段的名字进行跳转，而在反汇编中则使用相对寻址来进行跳转 Hello.s用十进制，而反汇编用十六进制 Hello.o用函数的名字来调用函数，但反汇编则是用相对寻址来调用函数，并且因为还没有进行重定位所以操作数全是0 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 4.5本章小结 本章描述了可重定位目标程序的ELF格式，以及ELF表所包含的各项信息及其作用 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：将各种代码和数据片段组合成一个单一文件的过程 作用：链接使分离编译成为可能，我们可以独立的修改或编译与文件中的一个个块，在改变这些块之后只需要简单的重新编译即可，同时也提高了效率 注意：这儿的链接是指从hello.o到hello生成过程。 5.2在Ubuntu下链接的命令 使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小，目标文件的类型，及其类型，节头部表的文件偏移，节头部表中条目的大小和数量。如图，ELF包括类别,数据，类型，入口点地址，程序头起点地址，本头大小，节头部大小 节头部表对hello中所有的节信息进行说明 重定位节： 符号表： 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 通过查看edb，看出hello的虚拟地址空间开始于0x400000,结束与0x400ff0 Init段存在于0x401000 Rodata段 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 在完成符号解析之后，链接器将代码中的每个符号引用和符号定义关联，于是链接器就得到了代码节和数据节的大小。然后先进行重新定位，所有同类型的数据都会被重定位到一个节上，然后再对每个节赋予不同的地址，以及节中的每个符号，这个操作保证了程序中的每个节和每个符号都有相应的地址。之后对代码节和数据节中有地址操作的命令或者是数据进行修改，使他们能调用正确的地址。链接器完成符号解析后，将代码中每个符号引用和一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来，此时，链接器就知道了它的输入目标模块中的代码节和数据节的确切大小 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 每个节的位置确定：用已知的每个节的大小加上每个节与头部之间的相对距离来确定具体的位置。 节中每个命令的位置确定：因为已经把接的位置固定了，那么每条命令的位置只需要用每个命令的相对偏移加上节的位置就能得到每条命令的位置。 在重定位之后的变化：原来的可重定位文件中的地址都是相对偏移地址，有一些有关函数调用的地址甚至直接用0来省略了。但hello中的地址都是真正的地址，从这些地址上我们可以取到相应数据。在重定位之后，函数以及各种跳转都是通过虚拟地址或者是偏移量来直接完成的。同时，重定位之后，程序中也新增加了一些函数，这是本程序引用的，且不由本程序自己创建的函数。 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 hello!_start0x401090 __libc_start_main0x403ff0 main0x4010c1 hello!puts@plt0x401030 hello!exit@plt0x401070 hello!printf@plt0x401040 hello!atoi@plt0x401060 hello!sleep@plt0x401080 hello!getchar@plt0x401050 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 执行之前global表是全0的，执行之后被赋予了一个新的地址，我们推断出因为其中一个外部函数属于动态链接符号，所以重定位的过程会从链接阶段延后到dl_init阶段 在dlinit前 在dlinit后 5.8本章小结 本章讲述了链接，分析了链接前后elf表的变化还有重定位之后的ELF表在栈中的储存。在讲述了冲的为的操作流程之后我们分析了重定位前后代码的变化，主要对重定位之后的地址做了解析。最后我们对动态链接进行了分析，通过edb来清晰的观测了动态链接的重定位过程 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础 作用：通过进程，我们能得到假象：我们的程序是系统中当前运行的唯一的程序一样，我们的程序好像是在独占使用处理器和内存，处理器好像是一条无间断地一条接着一条的执行我们程序中的命令，我们程序中的代码好像是系统中唯一的对象 6.2简述壳Shell-bash的作用与处理流程 作用：是一个交互型的应用级程序，可以接受用户输入的命令，然后再系统中运行相应的程序，是用户与系统之间的桥梁 处理流程：读取用户输入的命令，将命令分开，判断是否为内置命令，如果是那就立刻执行，如果不是那就调用fork和execve函数来运行程序完成命令，同时在运行的时侯Shell依然可以读取用户的输入来对当前正在执行的命令进行其他操作，如果找不到能执行这条命令的应用，就显示错误。 6.3Hello的fork进程创建过程 Shell解析命令，然后通过调用fork函数创建子进程，子进程得到一个完全独立的副本，父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成 6.4Hello的execve过程 删除已存在的用户区域映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构映射共享区域 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 进程上下文信息，就是内核重新启动一个被抢占的程序所需的状态，它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈、和各种内核数据结构。 进程时间片，是指一个进程和执行它的控制流的一部分的每一时间段。用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这个决策就叫做调度。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用上文所述的上下文切换的机制将控制转移到新的进程。内核代表的用户执行系统调用时，可能会发生上下文切换；中断也有可能引发上下文切换。 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。 终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的错误 6.7本章小结 本章介绍了进程的定义和作用，Shell的处理流程，如何调用fork（）创建子进程，如何调用execve函数执行可执行程序以及hello进程执行时的异常处理情况 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：包含在机器语言中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离 线性地址：逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。是hello中的虚拟内存地址 虚拟地址：CPU执行单元发出的内存地址将被MMU接收，从CPU到MMU的地址称为虚拟地址 物理地址;CPU通过地址来访问内存中的单元，地址有虚拟地址和物理地址之分，如果CPU没有MMU，或者有MMU但没有启用，CPU核在取指令或访问内存时发出的地址将直接传到CPU芯片的外部地址引脚上，直接被内存芯片接收，这称为物理地址 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理：逻辑地址->线性地址==虚拟地址 当TI=0则选择GDT首地址，当TI=1则选择LDT首地址。选取段选择符的前13位乘8再加上根据TI所选的首地址，之后根据得到的结果就能在描述符表中找到段描述符。再将其中的32位基地址和32位段内偏移量相加，就能得到32位线性地址 7.3Hello的线性地址到物理地址的变换-页式管理 页式管理是把物理空间划分成许多块。相应地，把逻辑地址空间划分成许多页页号和页内地址构成线性地址，我们通过页号找到页的起始地址，再加上页内地址就可以得到物理地址 7.4TLB与四级页表支持下的VA到PA的变换 TLB是一个小的虚拟寻址的缓存，其中每一行都保存着一个有单个PTE组成的块。TLB通常有高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号提取的 TLB命中时的步骤： 1、CPU产生一个虚拟地址 2、MMU从TLB中取出相应的PTE 3、MMU将这个虚拟地址翻译成一个物理地址，并且将它送到高速缓存或主存 4、高速缓存或主存将所请求的字返回给CPU 多级页表：一级页表中的每个PTE负责映射虚拟地址空间中的一个4MB的片，这里每一个是由1024个连续的页面组成的。比如PTE0映射第一篇，PTE1映射接下来的一篇，以此类推。假设地址空间是4GB，1034个PTE已经足够覆盖整个空间了。如果片i中的每个页面都未被分配，那么以及PTE就为空，以此类推。 这种方法从俩个方面减少了内存需求，第一，如果第一个PTE为空那么二级页表就不会存在。第二，只有一级页表才需要总是在主存中，系统可以在需要是才创建、调入、调出二级页表 7.5三级Cache支持下的物理内存访问 1.组选择取出虚拟地址的组索引位，将二进制组索引转化为一个无符号整数，找到相应的组 2.行匹配把虚拟地址的标记为拿去和相应的组中所有行的标记位进行比较，当虚拟地址的标记位和高速缓存行的标记位匹配时，而且高速缓存行的有效位是1，则高速缓存命中。 3.字选择一旦高速缓存命中，我们就知道我们要找的字节在这个块的某个地方。因此块偏移位提供了第一个字节的偏移。把这个字节的内容取出返回给CPU即可 4.不命中如果高速缓存不命中，那么需要从存储层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位所指示的组中的一个高速缓存行中。一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点 7.8缺页故障与缺页中断处理 缺页故障：当指令引用一个相应的虚拟地址，而与改地址相应的物理页面不再内存中，会触发缺页故障。通过查询页表PTE可以知道虚拟页在磁盘的位置。缺页处理程序从指定的位置加载页面到物理内存中，并更新PTE。然后控制返回给引起缺页故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，因此指令可以没有故障的运行完成 7.9动态存储分配管理 分配器有两种基本风格。两种风格都是要求显示的释放分配块。 显式分配器：要求应用显示的释放任何已分配的块。例如C标准库提供一个叫做malloc程序包的显示分配器。隐式分配器：要求分配器检测一个已分配块何时不再被程序使用，那么就释放这个块。隐式分配器也叫垃圾收集器。 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 使用后进先出的顺序维护链表，将新释放的块在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块，在这种情况下，释放一个块可以在线性的时间内完成，如果使用了边界标记，那么合并也可以在常数时间内完成。 按照地址顺序来维护链表，其中链表中的每个块的地址都小于它的后继的地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序首次适配比LIFO排序的首次适配有着更高的内存利用率，接近最佳适配的利用率。 7.10本章小结 本章主要介绍了hello的存储器的地址空间，介绍了四种地址空间的差别和地址的相互转换。同时介绍了hello的四级页表的虚拟地址空间到物理地址的转换。阐述了三级cashe的物理内存访问、进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m个字节的序列：B0,B1,B2….Bk,….,Bm-1 所有的I/O设备都被模型化为文件而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。 设备的模型化：文件 设备管理：unixio接口 8.2简述UnixIO接口及其函数 UnixIO接口： 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告他想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，他在后续对此文件的所有操作中标识这个文件。 Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（文件描述符0）、标准输出（描述符为1），标准出错（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，他们可用来代替显式的描述符值。 UnixIO函数： open（）函数 功能描述：用于打开或创建文件，在打开或创建文件时可以指定文件的属性及用户的权限等各种参数。 函数原型:intopen(constchar*pathname,intflags,intperms) 参数：pathname:被打开的文件名（可包括路径名如"dev/ttyS0"）flags:文件打开方式, 返回值：成功：返回文件描述符；失败：返回-1 close（）函数 功能描述：用于关闭一个被打开的的文件 所需头文件：#include<unistd.h> 函数原型:intclose(intfd) 参数：fd文件描述符 函数返回值：0成功，-1出错 read（）函数 功能描述：从文件读取数据。 所需头文件：#include<unistd.h> 函数原型：ssize_tread(intfd,void*buf,size_tcount); 参数：fd：将要读取数据的文件描述词。buf：指缓冲区，即读取的数据会被放到这个缓冲区中去。count：表示调用一次read操作，应该读多少数量的字符。 返回值：返回所读取的字节数；0（读到EOF）；-1（出错）。 write（）函数 功能描述：向文件写入数据。 所需头文件：#include<unistd.h> 函数原型：ssize_twrite(intfd,void*buf,size_tcount); 返回值：写入文件的字节数（成功）；-1（出错） 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 fmt是一个指针，这个指针指向第一个const参数（constchar*fmt)中的第一个元素而vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 Getchar中的read函数将缓冲区都读入buf数组中，返回缓冲区的长度。当buf数组为空，调用read函数，如果不空就返回buf中的第一个元素。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章讲述了IO设备的管理方法，IO接口及其函数，最后分析了printf和getchar函数的实现方法。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 1.编写hello代码，通过IDE将代码键入hello.c 2.预处理，hello.c经过预处理器处理得到文本文件hello.i 3.编译，hello.i编译成汇编文件hello.s 4.汇编，hello.s经汇编器翻译成机器语言指令，打包成为可重定位目标文件hello.o 5.链接，hello.o与可重定位目标文件和动态链接库链接成可执行目标程序hello 6.在shell中运行hello，shell进程调用fork为hello创建子进程 7.运行程序：子进程调用execve，execve调用启动加载器，映射虚拟内存，进入程序入口后程序载入物理内存，进入main函数。 8.执行指令：CPU为进程分配时间片，执行的控制逻辑流 9.访问内存：MMU将虚拟内存地址通过页表映射成物理地址。 10.动态申请内存：printf调用malloc向动态内存分配器申请堆中的内存。 11.信号：内核通过信号系统来处理程序执行中的用户请求和异常 12.结束：shell父进程回收子进程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 通过本学期的学习，我对于计算机系统有了一定程度的了解，并在不断地实验中锻炼自己的操作能力，更加深入的学习了有关计算机的知识。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 hello.c C语言源程序 hello.ihello.c 预处理后生成的文本文件 hello.s hello.i 经编译器翻译后生成的文本文件 hello.ohello.s 经过汇编器翻译后生成的可重定位目标文件 hellohello.o 链接后的可执行文件 hello.elf elf格式文件 （附件0分，缺失-1分） 

程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190201924 班 级 1936601 学 生 朱健坤 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 摘本论文将CSAPP课程所学内容通过hello小程序的一生，对我们所学进行全面的梳理与回顾。我们主要在Ubuntu下进行相关操作，合理运用了Ubuntu下的操作工具，进行细致的历程分析，目的是加深对计算机系统的了解。 关键词：hello；程序的一生；计算机系统；Ubuntu （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述-4- 1.1Hello简介-4- 1.2环境与工具-4- 1.3中间结果-4- 1.4本章小结-5- 第2章预处理-6- 2.1预处理的概念与作用-6- 2.2在Ubuntu下预处理的命令-6- 2.3Hello的预处理结果解析-6- 2.4本章小结-8- 第3章编译-9- 3.1编译的概念与作用-9- 3.2在Ubuntu下编译的命令-9- 3.3Hello的编译结果解析-9- 3.4本章小结-13- 第4章汇编-14- 4.1汇编的概念与作用-14- 4.2在Ubuntu下汇编的命令-14- 4.3可重定位目标elf格式-14- 4.4Hello.o的结果解析-15- 4.5本章小结-18- 第5章链接-19- 5.1链接的概念与作用-19- 5.2在Ubuntu下链接的命令-19- 5.3可执行目标文件hello的格式-19- 5.4hello的虚拟地址空间-20- 5.5链接的重定位过程分析-21- 5.6hello的执行流程-22- 5.7Hello的动态链接分析-23- 5.8本章小结-24- 第6章hello进程管理-25- 6.1进程的概念与作用-25- 6.2简述壳Shell-bash的作用与处理流程-25- 6.3Hello的fork进程创建过程-25- 6.4Hello的execve过程-26- 6.5Hello的进程执行-26- 6.6hello的异常与信号处理-27- 6.7本章小结-28- 第7章hello的存储管理-29- 7.1hello的存储器地址空间-29- 7.2Intel逻辑地址到线性地址的变换-段式管理-29- 7.3Hello的线性地址到物理地址的变换-页式管理-30- 7.4TLB与四级页表支持下的VA到PA的变换-30- 7.5三级Cache支持下的物理内存访问-31- 7.6hello进程fork时的内存映射-31- 7.7hello进程execve时的内存映射-32- 7.8缺页故障与缺页中断处理-32- 7.9动态存储分配管理-32- 7.10本章小结-33- 第8章hello的IO管理-34- 8.1Linux的IO设备管理方法-34- 8.2简述UnixIO接口及其函数-34- 8.3printf的实现分析-34- 8.4getchar的实现分析-35- 8.5本章小结-35- 结论-36- 附件-37- 参考文献-38- 第1章概述 1.1Hello简介 P2P： Program：在editor中键入代码得到hello.c程序 Process：hello.c（在Linux中），经过过cpp的预处理、ccl的编译、as的汇编、ld的链接最终成为可执目标程序hello。在shell中键入启动命令后，shell为其fork，产生子进程。 020： shell为hello进程execve，映射虚拟内存，进入程序入口后程序开始载入物理内存。 进入main函数执行目标代码，CPU为运行的hello分配时间片执行逻辑控制流。 当程序运行结束后，shell父进程负责回收hello进程，内核删除相关数据结构。 1.2环境与工具 硬件环境：处理器：Intel®Core™i7-8550UCPU@1.80GHz1.99GHz RAM：8.00GB系统类型：64位操作系统，基于x64的处理器 软件环境：Windows1064位；Ubuntu19.04 开发与调试工具：gcc，as，ld，vim，edb，readelf，VScode 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 预处理后的文件hello.i 编译之后的汇编文件hello.s 汇编之后的可重定位目标文件hello.o 链接之后的可执行目标文件Hello Hello.o的ELF格式Elf.txt Hello.o的反汇编代码Disas_hello.s hello的ELF格式hello1.elf hello的反汇编代码hello1_objdump.s 1.4本章小结 简述的P2P，020，分析列举了实验的前期工具，环境准备和实验中可能产生的中间文件 第2章预处理 2.1 预处理的概念与作用 概念：预处理器cpp根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件。 主要功能如下：1：将源文件中用#include形式声明的文件复制到新的程序中。2：用实际值替换用#define定义的字符串3：根据#if后面的条件决定需要编译的代码 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 打开hello.i，发现原来的helloc.c已经被拓展成几千行，前面的内容是hello.c的三个#include指令包含的头文件的代码，先寻找main函数，如下图。 再看之前的头文件的处理，以第一条#include指令为例，cpp到默认的环境变量下搜索stdio.h头文件，打开/usr/include/stdio.h，发现其中仍有#include指令，于是再去搜索包含的头文件，直到最后的文件中没有#include指令，并把所有文件中的所有#define和#ifdef指令进行处理，执行宏替换和通过条件确定是否处理定义的指令。 2.4本章小结 .c文件中包含有头文件也就是有外部文件的，还有一些程序员需要但是对于程序执行没有任何帮助的宏定义以注释，和一些程序员需要的条件编译和完善程序文本文件等操作都需要通过预处理来实现。预处理可以使得程序在后序的操作中不受阻碍，是非常重要的步骤。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 编译的概念：编译器将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。其以高级程序设计语言书写的源程序作为输入，而以汇编语言或机器语言表示的目标程序作为输出。这个过程称为编译，同时也是编译的作用。 编译程序的基本功能是把源程序(高级语言)翻译成目标程序。除了基本功能之外，编译程序还具备语法检查、调试措施、修改手段、覆盖处理、目标程序优化、不同语言合用以及人际联系等重要功能。 3.2在Ubuntu下编译的命令 图3.1hello.i编译生成hello.s 3.3Hello的编译结果解析 1.字符串 程序中用到的字符串有：“用法:Hello学号姓名秒数！\n”和“Hello%s%s\n”。编译器一般将字符串存放在.rodata节，这两个个字符串在hello.s中的存储如下图，可以看到第一个字符串中的汉字被编码成UTF-8格式，一个汉字占三个字节，每个字节用\分隔。第二个字符串中的两个%s为用户在终端运行hello时输入的两个参数。 图3.2hello.s存储的两个字符串 2.整数 hello.c中的整型变量有argc和i。 其中argc是从终端传入的参数个数，也是main函数的第一个参数，所以由寄存器%edi进行保存。由图3.3可知，argc又被存入了栈中-20(%rbp)的位置。 图3.3argc被保存在栈中 i则是局部变量，用来控制循环次数的计数器，编译器会将局部变量保存在寄存器或者栈中，由图3.4的30行看出hello.s将i存储在栈中-4(%rbp)的位置。 数组 hello.c中数组是main函数的第二个参数，char*argv[]，是字符指针数组，由于是第二个参数因而被保存在寄存器%rsi中，由图3.5可知它随后又被保存在了栈中-32(%rbp)的位置。 在访问argv[]所指向的内容时，每次先获得数组的起始地址，如图3.6的第33、36、43行，然后通过加8*i来访问之后的字符指针，如图3.6中的第34、37、44，原因是每个字符指针所占的空间大小围为8个字节。然后通过获得的字符指针寻找字符串。 赋值 hello.c中的赋值操作只有i=0这一条，这条语句在汇编中用mov指令实现，由于int占4个字节，所以以‘l’作为后缀。如图3.7。 算术操作 数据算术操作汇编指令： 指令效果 leaqS,DD=&S INCDD+=1 DECDD-=1 NEGDD=-D ADDS,DD=D+S SUBS,DD=D-S IMULQSR[%rdx]:R[%rax]=SR%rax MULQSR[%rdx]:R[%rax]=SR%rax IDIVQSR[%rdx]=R[%rdx]:R[%rax]modS(有符号) R[%rdx]=R[%rdx]:R[%rax]divS DIVQSR[%rdx]=R[%rdx]:R[%rax]modS(无符号) R[%rdx]=R[%rdx]:R[%rax]divS 程序中涉及的算数操作有： 1：i++，对计数器i自增，使用程序指令addl，后缀l代表操作数是一个4B大小的数据。 2：汇编中使用leaq.LC1(%rip),%rdi，使用了加载有效地址指令leaq计算LC1的段地址%rip+.LC1并传递给%rdi。 类型转换 程序中涉及隐式类型转换的是：intsleepsecs=2.5，将浮点数类型的2.5转换为int类型。 当在double或float向int进行类型转换的时候，程序改变数值和位模式的原则是：值会向零舍入。如果不能为该浮点数找到一个合适的整数近似值，就会产生一个整数不确定值。 浮点数默认类型为double，所以上述强制转化是double强制转化为int类型。遵从向零舍入的原则，将2.5舍入为2。 控制转移编译器将if，for等控制转移语句都使用了cmp来比较然后使用了条件跳转指令来跳转。编译器将if(argc!=3)编译成： 将for循环里面的比较和转移编译成： 函数操作printf(“Usage:Hello学号姓名！\n”)；编译结果 printf(“Hello%s%s\n”,argv[1],argv[2])；编译结果：图3.10printf(“Hello%s%s\n”,argv[1],argv[2])；汇编代码 sleep(sleepsecs);编译结果： 3.4本章小结 在编译阶段，编译器将高级语言编译成汇编语言。汇编语言是直接面向处理器的程序设计语言。处理器是在指令的控制下工作的，处理器可以识别的每一条指令称为机器指令。每一种处理器都有自己可以识别的一整套指令，称为指令集。处理器执行指令时，根据不同的指令采取不同的动作，完成不同的功能，既可以改变自己内部的工作状态，也能控制其它外围电路的工作状态。 汇编语言的另一个特点就是它所操作的对象不是具体的数据,而是寄存器或者存储器，也就是说它是直接和寄存器和存储器打交道，这也是为什么汇编语言的执行速度要比其它语言快，但同时这也使编程更加复杂，因为既然数据是存放在寄存器或存储器中，那么必然就存在着寻址方式，也就是用什么方法找到所需要的数据。例如上面的例子，我们就不能像高级语言一样直接使用数据，而是先要从相应的寄存器中把数据取出。这也就增加了编程的复杂性，因为在高级语言中寻址这部分工作是由编译系统来完成的，而在汇编语言中是由程序员自己来完成的，这无异增加了编程的复杂程度和程序的可读性。 然后，汇编语言指令是机器指令的一种符号表示，而不同类型的CPU有不同的机器指令系统，也就有不同的汇编语言,所以，汇编语言程序与机器有着密切的关系。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 驱动程序运行汇编器as，将汇编语言（这里是hello.s）翻译成机器语言（hello.o）的过程称为汇编，同时这个机器语言文件也是可重定位目标文件。 汇编就是将高级语言转化为机器可直接识别执行的代码文件的过程，汇编器将.s汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中，.o文件是一个二进制文件，它包含程序的指令编码。 4.2在Ubuntu下汇编的命令 gcchello.s-c-ohello.o4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 ELFHeader:用命令：readelf-hhello.o，如图4.3.1ELFHeader ELFHeader：以16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解##标题释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表的文件偏移，以及节头部表中条目的大小和数量等信息。 (2)SectionHeaders:命令：readelf-Shello.o SectionHeaders:节头部表，包含了文件中出现的各个节的语义，包括节的类型、位置和大小等信息。由于是可重定位目标文件，所以每个节都从0开始，用于重定位。在文件头中得到节头表的信息，然后再使用节头表中的字节偏移信息得到各节在文件中的起始位置，以及各节所占空间的大小，同时可以观察到，代码是可执行的，但是不能写；数据段和只读数据段都不可执行，而且只读数据段也不可写。 符号表.symtab：命令readelf-shello.o如图4.3.4 .symtab：存放程序中定义和引用的函数和全局变量的信息。name是符号名称，对于可冲定位目标模块，value是符号相对于目标节的起始位置偏移，对于可执行目标文件，该值是一个绝对运行的地址。size是目标的大小，type要么是数据要么是函数。Bind字段表明符号是本地的还是全局的。 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 通过反汇编的代码和hello.s进行比较，发现汇编语言的指令并没有什么不同的地方，只是反汇编代码所显示的不仅仅是汇编代码，还有机器代码，机器语是二进制机器指令的集合，是纯粹的二进制数据表示的语言，是电脑可以真正识别的语言。机器指令由操作码和操作数构成，汇编语言是人们比较熟悉的词句直接表述CPU动作形成的语言，是最接近CPU运行原理的语言。每一条汇编语言操作码都可以用机器二进制数据来表示，进而可以将所有的汇编语言(操作码和操作数）和二进制机器语言建立一一映射的关系，因此可以将汇编语言转化为机器语言，通过对机器代码的分析可以看出一下不同的地方。 (1)分支转移:反汇编的跳转指令用的不是段名称比如.L3，二是用的确定的地址，因为，因为段名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后显然不存在，而是确定的地址。 (2)函数调用:在.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0(目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。 4.5本章小结 本章对汇编结果进行了详尽的介绍。经过汇编器的操作，汇编语言转化为机器语言，hello.o可重定位目标文件的生成为后面的链接做了准备。通过对比hello.s和hello.o反汇编代码的区别，令人更深刻地理解了汇编语言到机器语言实现地转变，和这过程中为链接做出的准备，对可重定位目标elf格式进行了详细的分析，侧重点在重定位项目上。同时对hello.o文件进行反汇编，将Disas_hello.s与之前生成的hello.s文件进行了对比。使得我们对该内容有了更加深入地理解。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接器概念： 链接是将各种不同文件的代码和数据部分收集（符号解析和重定位）起来并组合成一个单一文件的过程。 链接器作用： 令源程序节省空间而未编入的常用函数文件（如printf.o）进行合并，生成可以正常工作的可执行文件。这令分离编译成为可能，节省了大量的工作。 5.2在Ubuntu下链接的命令 ldhello.o-lc-ohello.out或gcchello.o-ohello.out 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 可见包含一个elf头表，29个节头，1个程序头，2个重定位节，2个符号表等，相比之前多了很多内容。图中含有地址，大小等信息 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 虚拟地址从0x00400000开始，到0x004001000 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 分析hello与hello.o的不同： 1.链接增加新的函数： 在hello中链接加入了在hello.c中用到的库函数，如exit、printf、sleep、getchar等函数。 2.增加的节： hello中增加了.init和.plt节，和一些节中定义的函数。 3.函数调用： hello中无hello.o中的重定位条目，并且跳转和函数调用的地址在hello中都变成了虚拟内存地址。对于hello.o的反汇编代码，函数只有在链接之后才能确定运行执行的地址，因此在.rela.text节中为其添加了重定位条目。 4.地址访问： hello.o中的相对偏移地址变成了hello中的虚拟内存地址。而hello.o文件中对于某些地址的定位是不明确的，其地址也是在运行时确定的，因此访问也需要重定位，在汇编成机器语言时，将操作数全部置为0，并且添加重定位条目。 链接的过程： 根据hello和hello.o的不同，分析出链接的过程为： 链接就是链接器（ld）将各个目标文件（各种.o文件）组装在一起，文件中的各个函数段按照一定规则累积在一起。 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 5.6hello的执行流程 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。 在调用共享库函数时，编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。GNU编译系统使用延迟绑定(lazybinding),将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定是通过GOT和PLT实现的。GOT是数据段的一部分，而PLT是代码段的一部分。两表内容分别为： PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 5.8本章小结 在本章中主要介绍了链接的概念与作用，并且详细阐述了hello.o是怎么链接成为一个可执行目标文件的过程，详细介绍了hello.o的ELF格式和各个节的含义，并且分析了hello的虚拟地址空间、重定位过程、执行流程、动态链接过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中的程序的实例，每一个进程都有它自己的地址空间，一般情况下，包括文本区域、数据区域、和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储区着活动过程调用的指令和本地变量。 作用：进程为用户提供了以下假象： (1)我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存。 (2)处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 Linux系统中，Shell是一个交互型应用级程序，代表用户运行其他程序(是命令行解释器，以用户态方式运行的终端进程)。 其基本功能是解释并运行用户的指令，重复如下处理过程： (1)终端进程读取用户由键盘输入的命令行。 (2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量 (3)检查第一个(首个、第0个）命令行参数是否是一个内置的shell命令 (4)如果不是内部命令，调用fork()创建新进程/子进程 (5)在子进程中，用步骤2获取的参数，调用execve()执行指定程序。 (6)如果用户没要求后台运行(命令末尾没有&号）否则shell使用waitpid（或wait…等待作业终止后返回。 (7)如果用户要求后台运行(如果命令末尾有&号），则shell返回； 6.3Hello的fork进程创建过程 终端程序通过调用fork()函数创建一个子进程，子进程得到与父进程完全相同但是独立的一个副本，包括代码段、段、数据段、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，父进程和子进程最大的不同时他们的PID是不同的。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。 以我们的hello为例，当我们输入的时候，首先shell对我们输入的命令进行解析，由于我们输入的命令不是一个内置的shell命令，因此shell会调用fork()创建一个子进程。 6.4Hello的execve过程 当创建了一个子进程之后，子进程调用exceve函数在当前子进程的上下文加载并运行一个新的程序即hello程序，加载并运行需要以下几个步骤： (1)删除已存在的用户区域。删除当前进程虚拟地址的用户部分中已存在的区域结构。 (2)映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些区域结构都是私有的，写时复制的。虚拟地址空间的代码和数据区域被映射为hello文件的.txt和.data区。bss区域是请求二进制零的，映射匿名文件，其大小包含在hello文件中。栈和堆区域也是请求二进制零的，初始长度为零。 (3)映射共享区域。如果hello程序与共享对象链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域。 (4)设置程序计数器（PC）。exceve做的最后一件事就是设置当前进程的上下文中的程序计数器，使之指向代码区域的入口点。下一次调用这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 6.5Hello的进程执行 进程提供给应用程序的抽象： (1)一个独立的逻辑控制流，它提供一个假象，好像我们的进程独占的使用处理器 (2)一个私有的地址空间，它提供一个假象，好像我们的程序独占的使用CPU内存。 hello进程的执行是依赖于进程所提供的抽象的基础上，下面阐述操作系统所提供的的进程抽象： ①逻辑控制流:：一系列程序计数器PC的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。 ②并发流：一个逻辑流的执行时间与另一个流重叠，成为并发流，这两个流成为并发的运行。多个流并发的执行的一般现象成为并发。 ③时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 ④私有地址空间：进程为每个流都提供一种假象，好像它是独占的使用系统地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，在这个意义上，这个地址空间是私有的。 ⑤用户模式和内核模式：：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 ⑥上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 ⑦上下文切换：当内核选择一个新的进程运行时，则内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程： 1）保存以前进程的上下文 2）恢复新恢复进程被保存的上下文， 3）将控制传递给这个新恢复的进程，来完成上下文切换。 现在我们再来看一下hello进程执行，再进程调用execve函数之后，由上面分析可知，进程已经为hello程序分配了新的虚拟的地址空间，并且已经将hello的.txt和.data节分配虚拟地址空间的代码区和数据区。最初hello运行在用户模式下输出，然后hello调用sleep函数之后进程陷入内核模式，内核不会选择什么都不做等待sleep函数调用结束，而是处理休眠请求主动释放当前进程，并将hello进程从运行队列中移出加入等待队列，定时器开始计时，内核进行上下文切换将当前进程的控制权交给其他进程，当定时器到时发送一个中断信号，此时进入内核状态执行中断处理，将hello进程从等待队列中移出重新加入到运行队列，成为就绪状态，hello进程就可以继续进行自己的控制逻辑流了。 6.6hello的异常与信号处理 hello程序出现的异常可能有： 中断：在hello程序执行的过程中可能会出现外部I/O设备引起的异常。 陷阱：陷阱是有意的异常，是执行一条指令的结果，hello执行sleep函数的时候会出现这个异常。 故障：在执行hello程序的时候，可能会发生缺页故障。 终止：终止时不可恢复的错误，在hello执行过程可能会出现DRAM或者SRAM位损坏的奇偶错误。 在发生异常时会发出信号，比如缺页故障会导致OS发生SIGSEGV信号给用户进程，而用户进程以段错误退出。常见信号种类如下表所示。 6.7本章小结 本章阐明了进程的定义与作用，介绍了Shell的一般处理流程，以及调用fork创建新进程，调用execve执行hello，hello的进程执行的过程，还有系统对于异常与信号的处理。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：程序经过编译后出现在汇编代码中的地址。逻辑地址用来指定一个操作数或者是一条指令的地址。是由一个段标识符加上一个指定段内相对地址的偏移量，表示为[段标识符：段内偏移量]。 线性地址：也叫虚拟地址，和逻辑地址类似，也是一个不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件也是内存的转换前地址。 虚拟地址：也就是线性地址。 物理地址：用于内存芯片级的单元寻址，与处理器和CPU链接的地址总线相对应。可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部份组成，段标识符:段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，表示具体的是代码段寄存器还是栈段寄存器抑或是数据段寄存器，如图7.2.1所示。 索引号就是“段描述符(segmentdescriptor)”的索引，段描述符具体地址描述了一个段。很多个段描述符，就组了一个数组，叫“段描述符表”，这样，可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符，这句话很关键，说明段标识符的具体作用，每一个段描述符由8个字节组成，如图7.3.2所示 Base字段，表示的是包含段的首字节的线性地址，也就是一个段的开始位置的线性地址。一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。那究竟什么时候该用GDT，什么时候该用LDT呢？这是由段选择符中的T1字段表示的，=0，表示用GDT，=1表示用LDT，GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。 7.3Hello的线性地址到物理地址的变换-页式管理 由课本知识点可知，线性地址（也就是虚拟地址VA）到物理地址（PA）之间的转换通过分页机制完成。而分页机制是对虚拟地址内存空间进行分页。 这里我们不考虑TLB和多级页表，这将在下面探讨。 使用虚拟寻址，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址被送到内存之前首先转换为适当的物理地址。将一个虚拟地址转换为物理地址叫做地址翻译，需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做内存管理单元(MMU)的住哪用硬件，利用主存中的查询表来动态翻译虚拟地址。 虚拟地址作为到磁盘上存放字节的数组的索引，磁盘上的数组内容被缓存在主存中。同时，磁盘上的数据被分割成块，这些块作为磁盘和主存之间的传送单元。虚拟内存分割被成为虚拟页。物理内存被分割为物理页，物理页和虚拟页的大小时相同的。 任意时刻虚拟页都被分为三个不相交的子集： 未分配的：VM系统还未分配的页 缓存的：当前已经缓存在物理内存的已分配页 未缓存的：当前未缓存在物理内存的已分配页 每次将虚拟地址转换为物理地址，都会查询页表来判断一个虚拟页是否缓存在DRAM的某个地方，如果不在DRAM的某个地方，通过查询页表条目可以知道虚拟页在磁盘的位置。页表将虚拟页映射到物理页。如图7.3.1所示，页表就是一个页表条目的数组，每一个页表条目是由一个有效位和一个n为地址字段组成。有效位表明虚拟页是否缓存在DRAM中，n位地址字段是物理页的起始地址或者虚拟页在次胖的起始地址。 7.4TLB与四级页表支持下的VA到PA的变换 在IntelCorei7环境下研究VA到PA的地址翻译问题。前提如下：虚拟地址空间48位，物理地址空间52位，页表大小4KB，4级页表。TLB4路16组相联。CR3指向第一级页表的起始位置（上下文一部分）。解析前提条件：由一个页表大小4KB，一个PTE条目8B，共512个条目，使用9位二进制索引，一共4个页表共使用36位二进制索引，所以VPN共36位，因为VA48位，所以VPO12位；因为TLB共16组，所以TLBI需4位，因为VPN36位，所以TLBT32位。 CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（前32位）+TLBI（后4位）向TLB中匹配，如果命中，则得到PPN（40bit）与VPO（12bit）组合成PA（52bit）。如果TLB中没有命中，MMU向页表中查询，CR3确定第一级页表的起始地址，VPN1（9bit）确定在第一级页表中的偏移量，查询出PTE，如果在物理内存中且权限符合，确定第二级页表的起始地址，以此类推，最终在第四级页表中查询到PPN，与VPO组合成PA，并且向TLB中添加条目。如果查询PTE的时候发现不在物理内存中，则引发缺页故障。如果发现权限不够，则引发段错误。 7.5三级Cache支持下的物理内存访问 我们只讨论Cashe1的物理内存访问，Cashe2，Cashe3原理相同。 由于L1Cashe有64组，所以组索引位s为6，每组有8个高速缓存行，由于每个块的大小为64B，所以块偏移为为6，因此标记位为52-6-6=40位。 因此L1Cashe的物理访存大致过程如下： (1)组选择取出虚拟地址的组索引位，将二进制组索引转化为一个无符号整数，找到相应的组 (2)行匹配把虚拟地址的标记为拿去和相应的组中所有行的标记位进行比较，当虚拟地址的标记位和高速缓存行的标记位匹配时，而且高速缓存行的有效位是1，则高速缓存命中。 (3)字选择一旦高速缓存命中，我们就知道我们要找的字节在这个块的某个地方。因此块偏移位提供了第一个字节的偏移。把这个字节的内容取出返回给CPU即可 (4)不命中如果高速缓存不命中，那么需要从存储层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位所指示的组中的一个高速缓存行中。一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换。 7.6hello进程fork时的内存映射 当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1)删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2）映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3)映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 4）设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障：当指令引用一个相应的虚拟地址，而与改地址相应的物理页面不再内存中，会触发缺页故障。通过查询页表PTE可以知道虚拟页在磁盘的位置。缺页处理程序从指定的位置加载页面到物理内存中，并更新PTE。然后控制返回给引起缺页故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，因此指令可以没有故障的运行完成。 7.9动态存储分配管理 动态储存分配管理使用动态内存分配器来进行。动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配的状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。动态内存分配主要有两种基本方法与策略： 带边界标签的隐式空闲链表分配器管理 带边界标记的隐式空闲链表的每个块是由一个字的头部、有效载荷、可能的额外填充以及一个字的尾部组成的。 隐式空闲链表：在隐式空闲链表中，因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。其中，一个设置了已分配的位而大小为零的终止头部将作为特殊标记的结束块。 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大的可以放置所请求块的空闲块。分配器有三种放置策略：首次适配、下一次适配合最佳适配。分配完后可以分割空闲块减少内部碎片。同时分配器在面对释放一个已分配块时，可以合并空闲块，其中便利用隐式空闲链表的边界标记来进行合并。 显示空间链表管理 显式空闲链表是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。如，堆可以组织成一个双向链表，在每个空闲块中，都包含一个前驱与一个后继指针。 显式空闲链表：在显式空闲链表中。可以采用后进先出的顺序维护链表，将最新释放的块放置在链表的开始处，也可以采用按照地址顺序来维护链表，其中链表中每个块的地址都小于它的后继地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。 7.10本章小结 本章主要介绍了hello的存储器地址空间、intel的段式管理、hello的页式管理，在指定环境下介绍了VA到PA的变换、物理内存访问，还介绍hello进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化 文件（所有的I/O设备都被模型化为文件，甚至内核也被映射为文件） 设备管理 unixio接口 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。 我们可以对文件的操作有：打开关闭操作open和close；读写操作read和write；改变当前文件位置lseek等 8.2简述UnixIO接口及其函数 打开文件：内核返回一个非负整数的文件描述符，通过对此文件描述符对文件进行所有操作。 Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（文件描述符0）、标准输出（描述符为1），标准出错（描述符为2）。头文件定义了常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，他们可用来代替显式的描述符值。 改变当前的文件位置，文件开始位置为文件偏移量，应用程序通过seek操作，可设置文件的当前位置为k。 读写文件，读操作：从文件复制n个字节到内存，从当前文件位置k开始，然后将k增加到k+n；写操作：从内存复制n个字节到文件，当前文件位置为k，然后更新k 关闭文件：当应用完成对文件的访问后，通知内核关闭这个文件。内核会释放文件打开时创建的数据结构，将描述符恢复到描述符池中 8.3printf的实现分析 其中调用的vsprintf函数的作用是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。Write则将vsprintf的输出逐个的写到终端。 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 以下格式自行编排，编辑时删除） 异getchar有一个int型的返回值.当程序调用getchar时.程序就等着用户按键.用户输入的字符被存放在键盘缓冲区中.直到用户按回车为止(回车字符也放在缓冲区中).当用户键入回车之后,getchar才开始从stdin流中每次读入一个字符.getchar函数的返回值是用户输入的第一个字符的ASCII码,如出错返回-1,且将用户输入的字符回显到屏幕.如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取.也就是说,后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 表述了UnixIO接口及其4个函数，简单了解了一下printf，getchar的实现 （第8章1分） 结论 用hello所经历的过程总结如下： 1、编写代码：用高级语言写.c文件 2、预处理：从.c生成.i文件，将.c中调用的外部库展开合并到.i中 3、编译：由.i生成.s汇编文件 4、汇编：将.s文件翻译为机器语言指令，并打包成可重定位目标程序hello.o 5、链接：将.o可重定位目标文件和动态链接库链接成可执行目标程序hello 6、运行：在shell中输入命令 7、创建子进程：shell嗲用fork为程序创建子进程 8、加载：shell调用execve函数,将hello程序加载到该子进程，映射虚拟内存 9、执行指令：CPU为进程分配时间片，加载器将计数器预置在程序入口点，则hello可以顺序执行自己的逻辑控制流 10、访问内存：MMU将虚拟内存地址映射成物理内存地址，CPU通过其来访问 11、动态内存分配：根据需要申请动态内存 12、信号：shell的信号处理函数可以接受程序的异常和用户的请求 13、终止：执行完成后父进程回收子进程，内核删除为该进程创建的数据结构 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1][美]大卫R.奥哈拉伦，兰德尔·E.布莱恩特.深入理解计算机系统[M].龚奕利，贺莲译.北京：机械工业出版社,2016.7. [2]博客园.printf函数的深入剖析.http://www.cnblogs.com/pianist/p/3315801.html,2013-9-11. [3]程序头表. https://blog.csdn.net/ylcangel/article/details/18145155 [4]C语言文件的编译与执行的四个阶段并分别描述.https://blog.csdn.net/yimingsilence/article/details/52800987 [5]C语言中的预处理详解. https://blog.csdn.net/dlutbrucezhang/article/details/8753765 （参考文献0分，缺失-1分） 

哈尔滨工业大学计算机系统大作业 摘 要 本实验主要对hello这一c程序的整个生命周期展开研究。我们从hello.c源程序为起点，从预处理、编译、汇编、链接，到加载、运行，再到终止、回收逐一进行分析综合，并结合对《深入理解计算机系统》一书的内容及计算机系统课上老师的讲授，在Ubuntu系统下对hello程序展开编译、链接、调试、运行等实际操作，顺着hello.c文件在计算机中执行的生命周期，在整个计算机系统中漫游，并把计算机系统的体系整体串联在一起 关键词：Linux；hello程序；生命周期；计算机系统； 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 P2P：首先hello.c利用I/O设备通过总线存储进内存中。GCC编译器驱动然后读取源程序文件hello.c，通过预处理器cpp转化为hello.i，再利用编译器ccl读入hello.s（汇编语言），然后用as将其汇编，转化为机器友好的二进制代码并保存在hello.o中。最后，它通过链接器ld与标准C库动态链接，并最终成为hello可执行目标程序。 接下来是在shell中输入字符串“./hello”。shell程序将字符串读入寄存器并解析。然后shell调用fork函数来创建一个新的子进程。子进程是父进程shell的副本，再通过execve函数调用启动加载器。加载程序删除子进程现有的虚拟内存段，然后使用mmap函数创建新的内存区域，创建一组新的代码、数据、堆栈段。新的堆栈段被初始化为零。通过将虚拟地址空间中的页面映射到可执行文件的页面大小块，新的代码和数据段被赋值为可执行文件的对应内容。最后，加载器跳转到_start的地址运行应用main函数。 O2O：shell使用execve函数运行hello程序，映射虚拟内存，并从程序入口开始载入物理内存，再进入main函数执行目标代码，此时CPU为运行的hello分配时间片执行逻辑控制流，并通过流水线机制运行该程序，在此过程中，计算机通过TLB、4级页表、3级Cache，Pagefile等机制加速hello程序的运行，程序结束后，shell父进程负责回收hello进程，内核删除相关的数据结构。 1.2环境与工具 硬件环境：CPU：IntelCorei7-9300H2.40GHz；RAM：16GB 软件环境：Windows1064位；Ubuntu16.04.2LTS 开发与调试工具：objdump，gcc，as，ld，edb，readelf，VScode 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 文件名文件的作用hello.i预处理之后的文件hello.s编译之后的文件hello.o汇编之后的文件hello链接之后的文件hello_elfhello.o的elf格式hellold_elfhello的elf格式（链接之后）hello_objdumphello.o的反汇编代码hello_objdump0hello的反汇编代码（链接之后） 1.4本章小结 本章主要简单介绍了hello的P2P，020过程，列出了本次实验的环境、中间结果。也列出了该篇论文完成所需要生成的一些中间文件，为后续实验提供了基本思路。第一章简单解释了P2P和020的概念，说明了本次大作业的环境和工具，列出了为编写本论文，生成的中间结果文件并解释了其作用。 第2章预处理 2.1预处理的概念与作用 预处理的概念：预处理器（cpp）是根据以字符#开头的命令，修改原始的C程序：是指在进行编译的第一遍扫描之前所做的工作。该过程由预处理程序负责完成。当对一个c源文件进行预处理时，系统自动引用预处理程序以解析以字符#开头的预处理命令，比如#include<stdio.h>等命令来修改原始的C程序，待预处理进行完毕之后自动进入对源程序的编译。 预处理的主要作用如下： 1．删除宏定义“#define”展开并解析所定义的宏。 2．处理所有条件预编译指令，如“#if”,“#ifdef”,“#endif”等。 3．插入include后面的文件到“#include”处。 4．删除所有的注释“//”和“/**/”。 2.2在Ubuntu下预处理的命令 命令内容：>cpphello.chello.i 2.3Hello的预处理结果解析 观察hello.i文件可以发现，文件main函数之前的内容变多，main函数C语言程序文本文件，只是对原文件中的宏进行了宏展开，头文件中的内容被加入此文件中。如果代码中有#define命令还会替换程序中对相应的符号。 该文件扩展到了3061行之多，且原本的C代码被放置在了整个文件的末尾。 2.4本章小结 本章介绍了linux环境下对C语言程序进行预处理的命令，同时简要介绍了预处理的概念和作用，然后用简单的hello程序实际演示了从hello.c到hello.i的过程并结合具体代码对预处理结果进行了简单的分析。 第3章编译 3.1编译的概念与作用 编译的概念：编译是利用编译器从hello.i产生汇编文本文件hello.s的过程。主要包含五个阶段：词法分析、语法分析、语义检查、中间代码生成、目标代码生成。 编译的作用：将文本文件hello.i翻译成文本文件hello.s，并提示出现的语法错误。 3.2在Ubuntu下编译的命令 命令内容：>gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 3.3.1数据 局部变量：作为函数中的局部变量i被储存在栈中，栈地址：%rbp-4 argc：传入的参数，存在栈里，位于%rbp-20。 argv[]：传入的数组，存在栈里，argv的地址位于%rbp-32，利用argv的地址加i*8，就能得到argv[i]。 立即数：储存在.data段中，在运行需要时加入寄存器中，如果无空闲寄存器则放入栈中。 表达式：存在代码段的.rodata中 3.3.2赋值 为栈上的局部变量i赋初值=0，用movl赋值。 movl $0,-4(%rbp) 3.3.3类型转换 atoi函数将字符型argv[3]转换为整型数。 3.3.4算术操作 编译器将i++编译成 addl$1,-4(%rbp) 3.3.5关系操作 编译器将i<8与跳转编译成 cmpl$7,-4(%rbp) jle.L4 将argc!=4编译成 cmpl$4,-20(%rbp) je.L2 3.3.6数组/指针/结构操作 argv数组是传入的参数，储存在栈上。 初始地址位于%rbp-32，利用argv的地址加i*8，就能得到argv[i] 3.3.7控制转移 编译器将if，for等控制转移语句都使用了cmp来比较然后使用了条件跳转指令来跳转。编译器将if(argc!=3)编译成： cmpl$3,-20(%rbp) je.L2 将for循环里面的比较和转移编译成： cmpl$9,-4(%rbp) jle.L4 3.3.8函数操作 编译器将printf("用法:Hello学号姓名秒数！\n");编译为： 将printf("Hello%s%s\n",argv[1],argv[2]);编译为: 将sleep(atoi(argv[3]));编译为： 3.4本章小结 本章介绍了linux环境下对C语言程序进行预处理之后的文件进行编译的命令，同时简要介绍了编译的概念和作用，然后用简单的hello程序实际演示了从hello.i到hello.s的过程并结合具体代码对编译结果进行了简单的分析，通过源程序与汇编语言程序的对比，简要说明了编译器是怎么处理C语言的各个数据类型以及各类操作的，分数据，赋值，算数操作，关系操作，数组，控制转移，函数操作等方面按照类型和操作进行了分析。 第4章汇编 4.1汇编的概念与作用 汇编的概念：汇编器（as）将.s汇编程序翻译成机器语言，把这些机器语言指令打包成可重定位目标程序的格式，并将结果保存在.o目标文件中。这个过程就叫做汇编。 汇编的作用：将汇编语言翻译成机器语言，因为机器语言是计算机能直接识别和执行的一种语言。 4.2在Ubuntu下汇编的命令 命令内容：>gcc-chello.s-ohello.o 4.3可重定位目标elf格式 命令：readelf-ahello.o>hello.elf 4.3.1ELF头 描述了生成该文件的系统的字大小、字节顺序（大/小）、ELF头的大小、目标文件的类型、机器类型（如x86-64）、节头部表的偏移、节头部表中条目的大小和数量。 4.3.2节头部表 节头部表描述了不同节的偏移量和大小，其中目标文件中每个节都有一个固定大小的条目。具体的描述包括节的名称、类型、地址和偏移量等。 4.3.3重定位节 表述了各个段引用的外部符号等，在链接时，需要通过重定位节对这些位置的地址进行修改。链接器会通过重定位条目的类型判断该使用什么养的方法计算正确的地址值，通过偏移量等信息计算出正确的地址。 4.3.4符号表 存放在程序中定义和引用的函数和全局变量的信息。 4.4Hello.o的结果解析 命令内容：>objdump-d-rhello.o 与第三章对比可发现以下不同： 1.操作数进制表示： 可以看出，hello.s文件采用10进制，而反汇编的采用16进制。 2.函数调用 可以看出，hello.s中的函数调用是call函数名，而反汇编得到的是call相对地址，因为反汇编的代码已经经过了链接与重定位，知道了相对位置。 3.跳转分支 可以看出，hello.s文件的分支跳转是通过跳转到类似于.L2的形式来表示，而反汇编的代码使用跳转到某个相对位置来表示。 4.5本章小结 本章介绍了hello从hello.s到hello.o的汇编过程，分析了可重定位文件的结构和各个组成部分，以及它们的内容和功能；还查看了hello.o的elf格式，并使用objdump得到反汇编代码与hello.s进行比较，了解从汇编语言映射到机器语言汇编器需要实现的转换。在这个过程中，生成了重定位条目，为之后的链接中的重定位过程奠定了基础。 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。 链接的作用：链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。 5.2在Ubuntu下链接的命令 命令内容： >ld-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.o/usr/lib/gcc/x86_64-linux-gnu/9/crtbegin.o /usr/lib/gcc/x86_64-linux-gnu/9/crtend.o/usr/lib/x86_64-linux-gnu/crtn.o hello.o -lc -zrelro-ohello 5.3可执行目标文件hello的格式 5.3.1ELF头 ELF头描述文件的总体格式。包括程程序运行时要执行的第一条指令的地址。程序头部大小和数目也确定了下来。其余的部分基本与可重定位目标文件相同。 5.3.2节头 节头对hello中所有的节信息进行了声明，对于节的分类也更加详细，也确定了每个节在运行时的实际起始地址以及偏移量。其余部分都与可重定位目标文件的节头相同。 5.3.3程序头 程序头一共有8个段： （1）PHDR：包含程序头表本身； （2）INTERP：只包含了一个节，在这个节中，包含了动态链接过程中所使用的解释器路径和名称。 （3）两个LOAD段：第一个是代码段，第二个是数据段。在程序运行时需要映射到虚拟空间地址。 （4）DYNAMIC：保存了由动态链接器使用的信息。 （5）NOTE：保存了辅助信息。 （6）GNU_STACK：堆栈段。 （7）GNU_RELRO：在重定位之后哪些内存区域需要设置只读。 5.3.4重定位节 文件的重定位节已经完成重定位，符号表中的符号的信息都被记录在这里。 5.4hello的虚拟地址空间 使用edb加载hello，可以查看加载到虚拟地址中的hello程序。查看ELF格式文件中的ProgramHeaders，它告诉链接器运行时加载的内容并提供动态链接的信息。每一个表项提供了各段在虚拟地址空间和物理地址空间的各方面的信息。 查看ELF文件的程序头，程序头在为链接器提供运行时的加载内容和提供动态链接的信息，每一个表项提供了各段在虚拟地址空间大小和物理地址空间大小，位置，标志，访问权限和对齐方式。 可以看出，程序头包括8个段，正如5.3中所提到的： PHDR段； INTERP段； 两个LOAD段； DYNAMIC段； NOTE段； GNU_STACK段； GNU_RELRO段。 5.5链接的重定位过程分析 命令内容：>objdump-d-rhello 不同： 跳转：hello.o为相对偏移地址，hello为虚拟内存地址。 Hello含有外部链接得到的函数。 hello相对hello.o增加了部分节（.init,.plt等）。 重定位： 一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义(即其一个输入目标模块中的一个符号表条目)关联起来。此时，链接器就知道其输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成： 重定位节和符号定义：在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。 当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 重定位节中的符号引用：在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目(relocationentry)的数据结构，我们接下来将会描述这种数据结构。 5.6hello的执行流程 hello!_start0x401090 __libc_start_main0x403ff0 main0x4010c1 hello!puts@plt0x401030 hello!exit@plt0x401070 hello!printf@plt0x401040 hello!atoi@plt0x401060 hello!sleep@plt0x401080 hello!getchar@plt0x401050 5.7Hello的动态链接分析 动态链接： 共享库(sharedlibrary)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链楼(dynamiclinking)，是由一个叫做动态链接器(dytamiclinkeg的程序来执行的。共享库也称为共享目标(sharedobject)，在Linux系统中通常用，s0后缀来表示，微软的操作系统大量地使用了共享库，它们称为DLL(动态链接库)。 共享库是以两种不同的方式来“共享”的。首先，在任何给定的文件系统中，对于一个库只有一个.so文件。所有引用该库的可执行目标文件共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。其次，在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。 比如说：GOT：GOT是一个数组，其中元素是8字节的地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时需要用到的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。根据hello的ELF文件可知GOT起始表位置为0x404000。 Dl_init执行前0x404000的16个字节均为0： Dl_init执行后0x404000的16个字节有所改变： 5.8本章小结 第五章中主要介绍了链接的概念与作用，并且详细说明了hello.o是怎么与其他.o(.so)文件链接成为一个可执行目标文件的过程，展示了hello.o的ELF文件形式和各个节的含义，分析了hello的虚拟地址空间、重定位过程与动态链接过程。 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程是一个正在运行的程序的实例。系统中的每个程序都在某个进程的上下文中运行。上下文由程序正确运行所必需的状态组成。这种状态包括存储在内存中的代码和程序数据、堆栈、通用寄存器的内容、程序计数器、环境变量和文件描述符的集合。 进程的功能：进程为应用程序提供了两种抽象，一种是独立的逻辑控制流，一种是私有地址空间。提高CPU执行效率，减少因程序等待造成的CPU空闲和其他计算机软硬件资源的浪费。 6.2简述壳Shell-bash的作用与处理流程 shell是一个应用程序，他在操作系统中提供了一个用户与系统内核进行交互的界面。他的处理过程一般是这样的：首先从终端读入输入的命令，并将输入字符串分割获取参数，如果是内置命令则立即执行，如果不是内置命令则调用对应的程序并运行。Shell还可以接受键盘输入的信号比如ctrlc，并对这些信号进行处理。 6.3Hello的fork进程创建过程 根据shell的处理流程，可以推断，输入命令执行hello后，父进程如果判断不是内部指令，即会通过fork函数创建子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到一份与父进程用户级虚拟空间相同的（但是独立的）副本，包括数据段、代码、共享库、堆和用户栈。父进程打开的文件，子进程也可读写。二者之间最大的不同或许在于PID的不同。fork函数只会被调用一次，但会返回两次，在父进程中，fork返回子进程的PID，在子进程中fork返回0。 6.4Hello的execve过程 当fork之后，子进程调用execve函数在当前进程的上下文中加载并运行一个新程序即hello程序，execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行hello程序，加载器删除子进程现有的用户虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。最后加载器设置PC指向_start地址，_start最终调用hello中的main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，这时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 6.5Hello的进程执行 逻辑控制流：一系列程序计数器PC的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占，然后轮到其他进程。 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 在hello运行过程中，若hello进程不被抢占，则正常执行；若被抢占，则进入内核模式，进行上下文切换，转入用户模式，调度其他进程。 这里有个特殊的情况，当hello执行到sleep()的时候，为了不浪费处理器资源，hello进程会被抢占，直到sleep()返回，触发一个中断，使得hello进程重新被调度。 6.6hello的异常与信号处理 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 Ctrl+Z： 运行时按Ctrl-Z之后，将会发送一个SIGTSTP信号给shell。然后shell将转发给当前执行的前台进程组，使hello进程停止。 再输入ps查看当前进程，截图；输入jobs命令，截图；可见该进程已经停止。再输入pstree，可见这是一个树状图，显示了进程之间的关系。再输入fg（一个继续运行的命令），可以看出，刚才停止的程序继续运行，此时正在等我们输入一个字符。再运行一次这个程序，使用ctrl-z停止后再用kill杀死程序，并截图。 乱按： 程序运行情况正常，shell将乱输入的第一个字符当做getchar的输入，其余都当做新的shell命令，在hello进程结束被回收之后，将会在命令行中尝试解释这些命令。 6.7本章小结 本章简述了进程管理以及shell的一些信息，包括进程的概念与作用，shell的作用和处理流程，shell如何调用fork和execve运行我们的hello进程，以及hello是如何被执行的，当hello进程在执行时遇到特殊情况（比如回车，Ctrl-Z，Ctrl-C等）会如何处理。又介绍了一些常见异常和其信号处理方法。我们可以看出，一个进程的运行与信号密切相关，受到信号的调控。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：程序代码经过编译后出现在汇编程序中地址，逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。 线性地址与虚拟地址：逻辑地址经过段机制后转化为线性地址（虚拟地址）,是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。线性地址通常用十六进制数字表示，程序代码会产生逻辑地址，通过逻辑地址变换就可以生成一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换以产生一个物理地址。如果没有启用分页机制，那么线性地址直接就是物理地址。 物理地址：CPU地址总线传来的地址,由硬件电路控制。物理地址中很大一部分是留给内存条中的内存的，但也常被映射到其他存储器上。在没有使用虚拟存储器的机器上，虚拟地址被直接送到内存总线上，使具有相同地址的物理存储器被读写；而在使用了虚拟存储器的情况下，虚拟地址不是被直接送到内存地址总线上，而是送到存储器管理单元MMU，把虚拟地址映射为物理地址。 在hello程序中，他就表示了这个程序运行时的一条确切的指令在内存地址上的具体哪一块进行执行。 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理是从逻辑地址到线性地址的变换： 一个逻辑地址由两部分组成，段标识符、段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号，后面3位包含一些硬件细节，索引号，是“段描述符”，段描述符具体地址描述了一个段。这样，很多个段描述符，就组了一个数组，叫“段描述符表”，这样，可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符，这个描述符就描述了一个段，由8个字节组成。 给定一个逻辑地址[段选择符：段内偏移地址]，转换过程如下： 1、首先根据段选择符判断当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。这样就得到了一个数组。 2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。 3、Base+offset就是要转换的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 页式管理是从线性地址到物理地址的变换： Linux有一个的虚拟内存系统，其虚拟内存组织形式如下图。Linux将虚拟内存组织成一些区域（称为段）的集合，段之外的虚拟内存不存在因此不需要记录。内核为hello进程维护一个单独的任务结构即图中的task_struct，其中条目mm指向一个mm_struct，它描述了虚拟内存的当前状态，pgd指向第一级页表的基地址（结合一个进程一串页表），mmap指向一个vm_area_struct的链表，每个vm_area_struct都维护者一个区域。 物理内存被划分为一小块一小块的帧。分配内存时，帧是分配时的最小单位，最少也要给一帧。在虚拟内存中，与帧对应的概念就是页。线性地址的表示方式是：前部分是虚拟页号后部分是虚拟页偏移。 CPU通过将逻辑地址转换为虚拟地址来访问主存，这个虚拟地址在访问主存前必须先转换成适当的物理地址。CPU通过内存管理单元（MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址。然后CPU会通过这个物理地址来访问物理内存。 页表就是一个页表条目（PTE）数组，虚拟地址空间中的每个页在页表中的一个固定偏移量处都有一个PTE。PTE是由一个有效位和一个n个字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置。 MMU利用虚拟页号（VPN）来在虚拟页表中选择合适的PTE，当找到合适的PTE之后，PTE中的物理页号（PPN）和虚拟页偏移量（VPO）就会组合形成物理地址。其中VPO与PPO相同，因为虚拟页大小和物理页大小相同，所需要的偏移量位数也就相同。此时，物理地址就通过物理页号先找到对应的物理页，然后再根据物理页偏移找到具体的字节： 1.如果有效位是0，PPN为NULL则代表没有在虚拟内存空间中分配该内存； 2.如果是有效位0，PPN不为NULL，则代表在虚拟内存空间中分配了但是没有被缓存到物理内存中； 3.如果有效位是1则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，与虚拟页偏移量共同构成物理地址PA。 7.4TLB与四级页表支持下的VA到PA的变换 TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。下图展示了当TLB命中时所包括的步骤，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。 第1步:CPU产生一个虚拟地址。 第2步和第3步:MMU从TLB中取出相应的PTE。 第4步:MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。 第5步:高速缓存/主存将所请求的数据字返回给CPU。当TLB不命中时，MMU必须从Ll缓存中取出相应的PTE。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。 Corei7MMU如何使用四级的页表来将虚拟地址翻译成物理地址？36位VPN被划分成四个9位的片，每个片被用作到移个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个LlPET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 7.5三级Cache支持下的物理内存访问 CPU发送一条虚拟地址，随后MMU按照上述操作获得了物理地址PA。根据cache大小组数的要求，将PA分为CT，CS，CO。根据CS寻找到正确的组，比较每一个cacheline是否标记位有效以及CT是否相等。如果命中就直接返回想要的数据，如果不命中，就依次去L2,L3,主存判断是否命中，当命中时，将数据传给CPU同时更新各级cache的cacheline（如果cache已满则要采用换入换出策略）。 7.6hello进程fork时的内存映射 虚拟内存和内存映射解释fork函数如何为每个新进程提供私有的虚拟地址空间，在shell运行hello进程时，shell为hello进程创建虚拟内存创建当前进程的的mm_struct,vm_area_struct和页表的原样副本，两个进程中的每个页面都标记为只读两个进程中的每个区域结构（vm_area_struct）都标记为私有的写时复制（COW）在新进程中返回时，新进程拥有与调用fork进程相同的虚拟内存随后的写操作通过写时复制机制创建新页面。 7.7hello进程execve时的内存映射 shell进程调用execve函数在当前进程中加载并运行新程序hello的步骤： 删除已存在的用户区域，创建新的区域结构私有的、写时复制，代码和初始化数据映射到.text和.data区（目标文件提供），.bss和栈堆映射到匿名文件，栈堆的初始长度0，共享对象由动态链接映射到本进程共享区域，设置PC，指向代码区域的入口点，Linux根据需要换入代码和数据页面。 7.8缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。下图展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。 接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。下图展示了在缺页之后我们的示例页表的状态。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块(block)的集合来维护。每个块就是一个连续的虚拟内存片(chunk),要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格，它们都要求应用显式地分配块，而不同之处在于由哪个实体来负责释放已分配的块： 显式分配器，要求应用显式地释放任何已分配的块；而隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。因此隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集。 7.10本章小结 本章简要地介绍了hello进程的内存地址空间管理，并对intel的段式管理和页式管理做了介绍，对TLB与四级页表支持下的VA到PA的变换和三级Cache支持下的物理内存访问进行了介绍，进而结合hello进程对fork与execve从虚拟内存视角进行了分析。最后介绍了缺页故障与缺页中断处理和动态存储分配管理。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 一个Linux文件是一个m字节的序列，所有的I/O设备（如网络、磁盘和终端）都被建模为文件。并且所有的输入和输出都被认为是对相应文件的读取和写入并执行。这种将设备映射到文件的方法允许Linux内核在称为UnixI/O上运行一个简单的低级应用程序接口，它允许输入和输出以一致和一致的方式运行。 应用程序通过要求内核打开相应的文件来声明它要访问I/O设备。内核返回一个小的非负整数称为描述符，文件的关联数据由内核保存，应用程序只需要保存这个描述符。 Linuxshell创建的每个进程都包含三个文件： 标准输入、标准输出和标准错误以供操作时使用 对于每个打开的文件内核维护文件位置k，它从0开始，它是从文件开头的字节偏移量。应用程序可以通过执行搜索显式更改该值。 对于读操作，从文件复制n个字节到内存，文件位置k增加到k+n，当k大于等于文件大小时，触发EOF条件，即结束文件被读取。 最后，在文件访问结束后。该文件将被内核关闭。内核释放文件打开时创建的数据结构，并将描述符恢复到现有的描述符池中。 8.2简述UnixIO接口及其函数 (1)打开文件：一个应用程序同步异常（陷阱）请求内核打开某文件，表示其要访问一个I/O设备，内核返回一个小的非负整数（描述符），然后对此文件的所有操作中标识这个文件，内核把有关这个文件的所有信息进行记录。 (2)Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。 (3)更改当前的文件位置：对于已打开的某个文件，内核保存着一个文件位置，初始化为0，是从文件开头起始的字节偏移量是这个文件的位置，应用程序能够通过执行seek函数更改当前文件位置。 (4)读写文件：对于读操作，从文件复制n个字节到内存，文件位置k增加到k+n，当k大于等于文件大小时，触发EOF条件，即结束文件被读取。同理写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，写完成后更新k。 (5)关闭文件：内核释放文件打开时创建的数据结构，并将描述符恢复到现有的描述符池中。 UnixI/O函数: (1)intopen(char*filename,intflags,mode_tmode)，通过调用open函数打开现有文件或创建新文件的过程。open函数将文件名转换为文件描述符并返回描述符编号。返回的描述符始终是进程标志中未打开的最小描述符参数。指定进程打算如何访问文件。mode参数指定新的文件访问权限位。 (2)intclose(fd)，fd是需要关闭的文件的描述符，close返回操作结果（一个整型数）。 (3)ssize_tread(intfd,void*buf,size_tn)，read函数从当前带有fd描述符的文件位置到buf内存位置最多分配n个字节，返回值-1表示错误，0表示EOF；否则返回值表示实际传输的字节数。 4）ssize_twirte(intfd,constvoid*buf,size_tn)，write函数从内存位置buf复制至多n个字节到当前描述符为fd的文件位置。 8.3printf的实现分析 printf函数的函数体如下： intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } printf程序按照格式fmt结合参数args生成字符串，并返回串的长度。 然后是write函数： write: moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL 在printf中调用系统函数write将长度为i的buf输出，在write函数中，将栈中参数放入寄存器，ecx是字符个数，ebx存放第一个字符地址。 intINT_VECTOR_SYS_CALLA表示通过调用系统syscall。 然后是sys_call的实现： sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret sys_call函数通过总线将字符串中的字节从寄存器复制到显卡的显存。显存存储ASCII字符码，字符显示驱动子程序通过ASCII码在字体库中查找点阵信息，将点阵信息存储在vram中。 显示芯片根据刷新频率逐行读取vram。并通过信号线将每个点（RGB分量）发送到液晶显示器。所以我们的输入字符串出现在屏幕上。从vsprintf生成显示数据，写系统函数，int0x80拦截系统调用，或者sys_call字符显示驱动子程序：从ASCII到字体库显示vram。（采集每个点的RGB颜色数据） 显示芯片根据刷新频率逐行读取vram。并通过vsprintf的信号线将每个点（RGB分量）发送到液晶显示器，生成显示数据。编写write函数，然后到陷阱-系统调用int0x80或sys_call等。 字符显示驱动子程序：从ASCII到字体库显示vram（存储每个点的RGB颜色数据），显示芯片相应地逐行读取vram刷新频率并通过信号线将每个点（RGB分量）发送到液晶显示器。 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar的源代码为： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(--n>=0)?(unsignedchar)*bb++:EOF; } 异步异常-键盘中断的处理：当用户按下一个键时，键盘接口会得到一个代表该键的键盘扫描码，同时产生一个中断请求。中断请求抢占当前进程运行键盘中断子程序。键盘中断子程序首先从键盘接口获取按键的扫描码。然后将按键扫描码转换成ASCII码保存在系统的键盘缓冲区中。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 第八章讲述了IO设备的管理方法，IO接口及其函数，最后分析了printf和getchar函数的实现方法。 结论 用计算机系统的语言，逐条总结hello所经历的过程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 编写：通过编辑器将代码输入hello.c。 预处理：将hello.c调用的所有外部库和宏替换预处理、扩展和合并到一个hello.i文件中。 编译：将hello.i编译成汇编文件hello.s。 汇编：把hello.s汇编成可重定位的目标文件hello.o。 链接：将hello.o与可重定位的目标文件和动态链接库链接成可执行的目标程序hello。 运行：在shell命令行中输入./hello1190202008赵加毅2。 创建子进程：shell进程调用fork为其创建子进程。 运行程序：shell调用execve，execve调用loader，添加映射的虚拟内存，程序进入程序入口后开始加载物理内存，然后进入main函数。 执行指令：CPU为其分配时间片，在一个时间片内，hello可以使用CPU，依次执行自己的控制逻辑流。 上下文切换：hello调用sleep函数之后进程进入内核模式，内核进行上下文切换将当前进程的控制权交给其他进程，当sleep函数调用完成时，内核执行上下文切换将控制返还给hello进程。 访问内存：MMU将程序中使用的虚拟内存地址通过页表映射到物理地址。 动态内存申请：printf调用malloc动态内存分配器在堆中申请内存。 信号：如果在运行时输入ctr-cctr-z，会分别调用shell的信号处理函数终止和停止。 结束：shell父进程或ini养父进程回收子进程，内核删除为这个进程创建的所有数据结构。 计算机系统的设计思想和实现是基于抽象实现的：抽象体现在：用二进制01表示的最低层信息，操作系统管理硬件，进程是处理器、主存和I/O设备的抽象。虚拟内存是主内存与磁盘设备联系的抽象等。 计算机系统的设计是统筹兼顾的：计算机系统的设计考虑了所有可能的实际情况，并相应地设计了一系列的处理方法来适应不同的情况。 计算机系统设计精巧：为了解决快设备小存储与大存储设备慢存储的不平衡，设计了Cache和TLB等缓存设备作为下层存储设备的缓存，很大程度上提高了CPU运行的速度。 

程序人生-Hello’sP2P 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190202026 班 级 1936601 学 生 周俣生 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文详细分析分析了C语言程序hello.c在Ubuntu下的执行过程，主要介绍了hello.c的预处理、编译、汇编、链接、进程管理、存储管理以及I/O管理。 通过跟踪hello程序的执行过程，带我们认识了计算机系统的工作方式。 关键词：预处理；编译；汇编；链接；进程；I/O；虚拟内存 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 程序员利用C语言编写了C程序hello.c，经过预处理、编译、汇编、链接，生成了可执行文件：hello。 在Bash中输入命令，OS进程管理为hello程序fork进程，调用execve加载，为进程mmap，分时间片，让hello程序得以在Hardware(CPU/RAM/IO)上执行（取指译码执行/流水线等）。 OS（存储管理）与MMU为hello程序翻译从VA到PA；TLB、4级页表、3级Cache，Pagefile等等为hello程序加速；IO管理与信号处理，软硬结合，才使hello程序最终在屏幕上显示。 Bash在运行结束后回收了进程。 O2O:FromZero-0toZero-0。 P2P:FromProgramtoProcess 1.2环境与工具 1.硬件环境： Win10_64位 处理器：Intel(R)Core(TM)i7-9750HCPU@2.60GHz 2.59GHz 机带RAM：8.00GB 2.软件环境： Windows10、Ubuntu 3.开发工具 EDB、GDB、VIM、Objdump、readelf 1.3中间结果 hello.c：C语言程序 hello.i：C语言程序hello.c预处理后得到的新的C程序 hello.s：将hello.c编译后得到汇编语言文本文件 hello.o：将hello.c汇编后得到的机器语言指令的可重定位目标程序 hello：将hello.o链接后得到的可执行文件 elf.txt：hello.o的ELF文件 elf1.txt：hello的ELF文件 hello.txt：hello.o反汇编后得到的汇编语言代码 hello1.txt：hello反汇编后得到的汇编语言代码 1.4本章小结 本章系统的介绍了hello程序P2P，020的过程。给出了本次实验的系统环境以及所使用的工具，并列出了实验过程中所产生的中间文件。 第2章预处理 2.1预处理的概念与作用 概念： 预处理是指在程序源代码被编译之前，由预处理器对程序源代码进行的处理。这个过程并不对程序的源代码进行解释，但它把源代码分割或处理成为特定的符号用来支持宏调调用。在C语言源程序中可以加入一些预处理命令，以改进程序设计环境，提高编程效率，这些预处理伪字符是统一规定的，但是它们不是C语言本身的组成部分，不能直接对它们进行编译。 C提供的预处理命令功能主要有以下3种： （1）宏定义 （2）文件包含 （3）条件编译 分别用宏定义伪命令，文件包含命令，条件编译命令来实现，为了与一般C语句相区别，这些命令以符号#开头。 2.2在Ubuntu下预处理的命令 cpphello.chello.i gcc-Ehello.c-ohello.i 图2.1Ubuntu下预处理命令 2.3Hello的预处理结果解析 使用命令cpp-Ehello.c，在终端查看预处理结果。 或者打开hello.i，直接在文本中查看。 图2.2Ubuntu下预处理结果 预处理命令的功能主要有三种（1）宏定义（2）文件包含（3）条件编译。 hello.c文件中共有三条预处理指令： 图2.3hello.c头文件 预处理器读取系统头文件的内容，然后将它们直接插入程序文本中。 从hello.i文本中可以看到stdio.h的位置在/usr/include中，我们在/usr/include中利用ls命令查看文件。 图2.4/usr/include下的文件 2.4本章小结 在C语言程序中加入一些预处理命令，以改进程序设计环境，提高编程效率，这此预处理伪字符是统一规定的，但它不是C语言本身的组成部分，不能直接对它们进行编译。预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。结果就得到了另一个C程序，通常是以.i作为文件扩展名。 第3章编译 3.1编译的概念与作用 编译是编译器将预处理文本翻译为汇编文本的过程。 编译器是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序。编译器（ccl）将文本文件hello.i翻译成hello.s，它包含一个汇编语言程序。该程序包含函数main的定义。 3.2在Ubuntu下编译的命令 gcc-Shello.c-ohello.s 图3.1Ubuntu下编译命令 3.3Hello的编译结果解析 3.3.1 在hello.c中定义了int型全局变量sleepsecs。 图3.2hello.c中定义的全局变量 在程序中被声明为long类型的全局变量，并为其分配四个字节的空间。 图3.3编译结果 将sleepsecs赋值为2。 图3.4编译结果 在复制过程中有一次隐式类型转换。 从float或者double转换成int,值将会向零舍人。例如,1.999将被转换成1,而-1.999将被转换成-1。进一步来说,值可能会溢出。C语言标准没有对这种情况指定固定的结果。与Intel兼容的微处理器指定位模式[10⋯00]为整数不确定值。一个从浮点数到整数的转换,如果不能为该浮点数找到一个合理的整数近似值,就会产生这样一个值。因此,表达式(int)+1e10会得到-21483648,即从一个正值变成了一个负值。 3.3.2 在hello.c中定义了int型局部变量i。 编译器将局部变量存储在寄存器或栈空间中。在hello.s中编译器将局部变量i存放在栈空间%rbx中。 图3.5编译结果 将i赋值为0。 图3.6编译结果 3.3.3 在hello.c中共有两条print语句。 图3.7hello.c中的print语句 在hello.s中分别将两条字符串存储在.LC0中和.LC1中。 图3.8编译结果 3.3.4 在hello.c中有一条条件语句。 图3.9hello.c中的if语句 编译器将argc放在寄存器%edi中。如果%edi中的值不等于3，则跳转到.L6。 图3.10编译结果 加载字符串.LC0的地址。调用printf函数打印字符串。 将立即数1写入寄存器%edi，调用exit（）函数。 图3.11编译结果 3.3.5 在hello.c中有for循环语句。 图3.12hello.c中的for语句 用寄存器%ebx保存局部变量i，赋值为0，然后跳转到.L2。 图3.13编译结果 如果寄存器%ebx中的值（i）小于等于9，则跳转到.L3。进入循环内部。 图3.14编译结果 将16（%rbp）中的参数argv[1]写入%rcx，将8（%rbp）中的参数argv[2]写入%rdx，加载字符串.LC1的地址到%rsi。调用printf函数。将sleepsecs赋值给%edi，作为参数传递给sleep函数。将%edi（i）加1。 图3.15编译结果 3.3.6 汇编语言中的寻址模式。 图3.16汇编语言中的寻址模式 参数argv[1]，argv[2]存放的地址分别16（%rbp）和8（%rbp）。 图3.17编译结果 3.3.7 C语言的算术操作对应的汇编语言。 图3.18C语言的算术操作对应的汇编语言 3.4本章小结 本章节主要结合了C语言中的各种数据类型，各种运算以及各种函数操作，逐个分析了编译器产生的汇编代码，介绍了编译器是如何处理C语言程序的。 在编译阶段，编译器将高级语言编译成汇编语言。汇编语言不具有可移植性，是直接面向处理器的语言，是机器指令的一种符号表示，不同类型的计算机系统有不同的机器指令系统，也就有不同的汇编语言。 第4章汇编 4.1汇编的概念与作用 汇编是将汇编语言翻译为机器语言的过程。 汇编器（as）将hello.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。 4.2在Ubuntu下汇编的命令 ashello.s-ohello.o 4.1Ubuntu下汇编命令 4.3可重定位目标elf格式 用readelf-ahello.o>elf.txt生成hello.o的ELF文件。 4.2Ubuntu下生成ELF文件命令 ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节序列。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。 图4.3ELF头 共13个节头。 图4.4节头 图4.5重定位节信息 可知，需要重定位的信息有.LC0，puts，exit，.LC1，__printf_chk，sleepsecs，sleep，stdin，和_IO_getc。 4.4Hello.o的结果解析 输入命令objdump-d-rhello.o>hello.txt，获得hello.o的反汇编代码，保存在hello.txt文件中。 图4.6反汇编hello.o命令 打开hello.txt，查看反汇编代码。 图4.7反汇编代码hello.txt 图4.8hello.s 机器语言完全由二进制0、1构成，在这里的反汇编代码中，以16进制格式显示。两个16进制数组成一个字节编码，表示一个运算符或者操作数。 将hello.o反汇编后得到的代码与hello.s大体相同，存在部分差异： 在反汇编得到的代码中，跳转指令后跟着的是地址，而在hello.s中，跳转指令后跟着的是.L2、.L3这样的代码段标签。在反汇编得到的代码中，call后面跟随的地址是相对地址，而在hello.s中，call后面跟随的是函数名。 4.5本章小结 本章节介绍了汇编过程，汇编器将hello.s汇编得到hello.o，查看了hello.o的ELF。使用objdump工具对hello.o进行了反汇编，得到了反汇编代码，并与之前得到的hello.s进行比较。通过观察二者之间的异同，了解分析汇编器将汇编语言翻译到机器语言的这一过程。 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序自动执行的。 5.2在Ubuntu下链接的命令 在终端中输入链接命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1Ubuntu下链接命令 5.3可执行目标文件hello的格式 用readelf工具，将hello的ELF文件保存在elf1.txt中。 输入命令：readelf-ahello>elf1.txt 查看ELF头信息： 图5.2ELF头信息 节头部表包含了hello中的每一个节，包含了名称、类型、地址、偏移量、大小、全体大小、旗标、链接、信息、对齐。 节头： 图5.3节头信息 5.4hello的虚拟地址空间 使用edb加载hello。 图5.4edb下打开hello 图5.5在节头部表中的信息 图5.6在edb中查看的节头部表的信息 5.5链接的重定位过程分析 objdump-d-rhello>hello1.txt 图5.7反汇编命令 打开hello1.txt，查看hello的反汇编代码。 图5.8hello反汇编代码 在使用ld命令链接的时候,指定了动态链接器为/lib64/ld-linux-x86-64.so.2，_start程序调用hello.c中的main函数，libc.so是动态链接共享库，其中定义了hello.c中用到的printf、sleep、getchar、exit函数和_start中调用的__libc_csu_init，__libc_csu_fini，__libc_start_main。链接器将上述函数加入。 链接器将所有R_X86_64_PC32和R_X86_64_PLT32换成计算好的地址。 以sleepsecs为例： 图5.9反汇编代码 相应的重定位条目r由4个字段组成： r.offset=0x4b; r.symbol=sleepsecs; r.type=R_X86_64_PC32; r.addend=-4; R_X86_64_PC32重定位算法如下： 图5.10R_X86_64_PC32重定位算法 refaddr=0x4005a2+0x4b=0x4005ed *refptr=(unsigned)(ADDR(r.sleepsecs)+r.addend-refaddr)=0x601044+(-0x4)-0x4005ed=(unsigned)0x200a53 图5.11反汇编代码 5.6hello的执行流程 0x7f4355798061 ld-2.27.so!oom 0x7f4355798090 ld-2.27.so!_start 0x7f4355798098 ld-2.27.so!_dl_start_user 0x7f43557980e0 ld-2.27.so!rtld_lock_default_lock_recursive 0x7f43557980f0 ld-2.27.so!rtld_lock_default_unlock_recursive 0x7f4355798100 ld-2.27.so!lookup_doit 0x7f4355798160 ld-2.27.so!dlmopen_doit 0x7f43557981b0 ld-2.27.so!print_unresolved 0x7f43557981f0 ld-2.27.so!print_missing_version 0x7f4355798230 ld-2.27.so!do_preload 0x7f43557982e0 ld-2.27.so!map_doit 0x7f4355798ea0 ld-2.27.so!_dl_start 0x4004f0 hello!_init 0x400520 hello!puts@plt 0x400530 hello!_IO_getc@plt 0x400540 hello!__printf_chk@plt 0x400550 hello!exit@plt 0x400560 hello!sleep@plt 0x400570 hello!_start 0x4005a0 hello!_dl_relocate_static_pie 0x4005a2 hello!main 0x400620 hello!__libc_csu_init 0x400690 hello!__libc_csu_fini 0x400694 hello!_fini 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 动态链接器使用过程链接表PLT+全局偏移量表GOT实现函数的动态链接，GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。下面是程序在run前后的（即执行dl_init函数前后）的GOT表变化情况。 图5.12节头部表 0x600000处偏移0x1000个字节，起始位置为0x601000。 图5.13edb中查看 运行完成dl_init之后。 图5.14edb中查看 5.8本章小结 本章介绍了链接的概念、作用、可执行目标文件hello的格式、hello的虚拟地址空间、链接的重定位过程分析、hello的执行流程以及hello的动态链接分析。 链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。 第6章hello进程管理 6.1进程的概念与作用 进程是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 进程给应用程序提供两个关键的抽象： 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 shell是一个交互型应用级程序，代表用户运行其他程序。是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。 其基本功能是解释并运行用户的指令，重复如下处理过程： (1)终端进程读取用户由键盘输入的命令行。 (2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量 (3)检查第一个命令行参数是否是一个内置的shell命令 (4)如果不是内部命令，调用fork()创建子进程 (5)在子进程中，用步骤2获取的参数，调用execve()执行指定程序。 (6)如果用户没要求后台运行(命令末尾没有&号）则shell使用waitpid（或wait)等待作业终止后返回。 (7)如果用户要求后台运行(如果命令末尾有&号），则shell返回。 6.3Hello的fork进程创建过程 在终端中输入命令./hello1190202026zys。 shell首先对命令进行解析，判断它是否是一个内置的shell命令。然后发现这并不是一个内置命令，而是当前目录下的一个可执行目标文件。然后调用fork函数为hello创建一个子进程。 新创建的子进程几乎但不完全与父进程相同：子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本，子进程获得与父进程任何打开文件描述符相同的副本，子进程有不同于父进程的PID。 图6.1hello进程图 6.4Hello的execve过程 execve函数加载并运行可执行目标文件filename，且带参数列表和环境变量列表envp。只有当出现错误时，例如找不到filename时，execve才会返回到调用程序。与fork一次调用返回两次不同，execve调用一次并从不返回。 图6.2execve函数 当shell为hello创建了一个子进程之后，得到的子进程与父进程几乎相同。fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。此时调用execve函数，在当前进程的上下文中加载并运行hello。它会覆盖当前进程的地址空间，但并没有创建一个新的进程。此时的新的进程仍有与原先相同的PID，并且继承了调用execve函数时已打开的所有文件描述符。 6.5Hello的进程执行 处理器提供了一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常用某个控制寄存器中的一个模式位来提供这种功能，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中。一个运行在内核模式中的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令，比如停止处理器、改变模式位，或者发起一个I/O操作。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度，是由内核中成为调度器的代码处理的。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种成为上下文切换的机制来控制转移到新的进程： 1）保存当前进程的上下文 2）恢复某个先前被抢占的进程被保存的上下文 3）将控制传递给这个新恢复发进程 当hello调用sleep函数时，它显示地请求了让进程休眠。此时，hello进程被挂起，从运行队列加入等待队列，定时器开始计时2s。调度器通过上下文切换，重新开始一个之前被抢占了的进程。当sleep调用完毕的时候，会发送一个中断信号，此时内核将当前进程挂起（或终止）并返回到hello进程。 图6.3上下文切换 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 图6.4hello正常运行过程 图6.5运行过程中按下回车 在运行过程中按下回车不影响进程输出，不会让进程终止或挂起。 图6.6运行过程中按下Ctrl-Z 运行过程中按下Ctrl-Z后，显示进程已停止（挂起）。 图6.7按下Ctrl-Z后执行ps 按下Ctrl-Z后执行ps命令，可以看到hello进程并没有结束。 图6.8按下Ctrl-Z后执行jobs 按下Ctrl-Z后执行jobs命令，查看hello和jid。 图6.9（1）按下Ctrl-Z后执行pstree 图6.9（2）按下Ctrl-Z后执行pstree 按下Ctrl-Z后执行pstree命令，以树状图结构显示进程之间的关系。输入pstree-p21808（bash进程的PID），以bash进程为根节点查看。 图6.10按下Ctrl-Z后执行fg 按下Ctrl-Z后执行fg命令，继续执行hello程序，继续输出没有输出的内容。 图6.11按下Ctrl-Z后执行kill 按下Ctrl-Z后执行kill命令，杀死hello进程。输入ps命令查看，可以看到hello进程显示已杀死。 图6.12按下Ctrl-C 按下Ctrl-C后，发现进程立即结束了。输入ps命令，可以看到hello进程已经终止。 进程运行时按下Ctrl-Z，对应的是shell接收到SIGTSTP信号，默认情况是停止（挂起）前台作业，而Ctrl-C会导致内核发送一个SIGINT信号，默认情况是终止前台作业。 图6.13部分信号及相应事件 6.7本章小结 本章节介绍了进程的概念与作用，介绍了shell的作用与处理流程，分析了shell如何调用fork创建进程以及如何调用execve执行hello进程。结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等，分析了hello的进程执行过程。通过在shell中执行各种命令操作，分析了hello的异常与信号处理。 异常控制流发生在计算机系统的各个层次。在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。一个一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：又称相对地址。由段地址加上偏移地址构成，它是描述一个程序运行段的地址。 线性地址：是经过段机制转化之后用于描述程序分页信息的地址。它是对程序运行区块的一个抽象映射。 虚拟地址：虚拟地址跟线性地址相同，都是对程序运行区块的相对映射。 物理地址：程序运行时加载到内存地址寄存器中的地址，内存单元的真正地址。它是在前端总线上传输的而且是唯一的。物理地址中很大一部分是留给内存条中的内存的，但也常被映射到其他存储器上。 在没有使用虚拟存储器的机器上，虚拟地址被直接送到内存总线上，使具有相同地址的物理存储器被读写；而在使用了虚拟存储器的情况下，虚拟地址不是被直接送到内存地址总线上，而是送到存储器管理单元MMU，把虚拟地址映射为物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部分构成，段标识符和段内偏移量。段标识符是由一个16位长的字段组成，成为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节。 一些全局的段描述符，就放在“全局段描述符表（GDT）”中；一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表（LDT）”中。什么时候使用GDT，什么时候使用LDT中是由段选择符中的TI字段表示的。 7.3Hello的线性地址到物理地址的变换-页式管理 CPU的页式内存管理单元负责把一个线性地址转换为物理地址。从管理和效率的角度出发，线性地址被划分成固定长度单位的数组，称为页。例如，一个32位的机器，线性地址可以达到4G，用4KB为一个页来划分，这样，整个线性地址就被划分为一个2^20次方的的大数组，共有2的20次方个页，也就是1M个页，我们称之为页表，该页表中每一项存储的都是物理页的基地址。 类似地，物理内存也被分割为物理页（PP），是分页单元将所有的物理内存都划分成了固定大小的单元为管理单位，其大小一般与内存页大小一致。 图7.1地址翻译符合小结 CPU中的一个控制寄存器，页表基址寄存器（PTBR）指向当前页表。N位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。MMU利用VPN来选择适当的PTE。当页表条目中的物理页号（PPN）和虚拟地址中的VPO串联起来，就得到相印的物理地址。注意，因为物理和虚拟页面都是P字节的，所以物理页面偏移（PPO）和VPO是相同的。 图7.2使用页表的地址翻译 当页面命中时，CPU的执行步骤： 1.处理器生成一个虚拟地址，并把它传送给MMU。 2.MMU生成PTE地址，并从高速缓存/主存请求得到它。 3.高速缓存/主存向MMU返回PTE。 4.MMU构造物理地址，并把它传送给高速缓存/主存。 5.高速缓存/主存返回所请求的数据字给处理器。 图7.3页面命中的操作图 页面命中完全是由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成。 1~3.和页面命中的第1步到第3步相同。 4.PTE中的有效位是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。 5.缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。 6.缺页处理程序页面调入新的页面，并更新内存中的PTE。 7.缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中。 图7.4缺页的操作图 7.4TLB与四级页表支持下的VA到PA的变换 翻译后备缓冲器（TLB）是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单一PTE组成的块。TLB通常有高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有T=2^t个组，那么TLB索引（TLBI）是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。 36位VPN被划分成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 图7.5虚拟地址中用以访问TLB的组成部分 图7.6Corei7页表翻译 优化地址翻译： 在对地址翻译的讨论中，我们描述了一个顺序的两个步骤的过程 1)MMU将虚拟地址翻译成物理地址 2)将物理地址传送到L1高速缓存 然而，实际的硬件实现使用了一个灵活的技巧，允许这些步骤部分重叠，因此也就加速了对L1高速缓存的访问。例如,页面大小为4KB的Corei7系统上的一个虚拟地址有12位的VPO，并且这些位和相应物理地址中的PPO的12位是相同的。因为八路组相联的、物理寻址的L1高速缓存有64个组和大小为64字节的缓存块，每个物理地址有6个（log264）缓存偏移位和6个（log264）索引位。这12位恰好符合虚拟地址的VPO部分，这绝不是偶然！当CPU需要翻译一个虚拟地址时，它就发送VPN到MMU，发送VPO到高速L1缓存。当MMU向TLB请求一个页表条目时，L1高速缓存正忙着利用VPO位查找相应的组，并读出这个组里的个标记和相应的数据字。当MMU从TLB得到PPN时，缓存已经准备好试着把这个PPN与这8个标记中的一个进行匹配了。 7.5三级Cache支持下的物理内存访问 获得了物理地址VA之后，使用CI进行组索引，每组8路，对8路的块分别匹配CT，如果匹配成功且块的valid标志位为1，则命中，根据数据偏移量CO取出数据返回。 如果没有匹配成功或者匹配成功但是标志位不是1，则不命中，向下一级缓存中查询数据（L2Cache、L3Cache、主存）。查询到数据之后，一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突，则采用最近最少使用策略LFU进行替换。也就是替换掉最不经常访问的一次数据。 7.6hello进程fork时的内存映射 当shell调用fork函数时，内核为新进程hello创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在进程hello中返回时，进程hello现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。映射私有区域。为新的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。映射共享区域。如果hello程序与共享对象（或目标）链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。设置程序计数器。execve做的最后一件事就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 图7.7加载器是如何映射用户地址空间的区域的 7.8缺页故障与缺页中断处理 处理缺页要求硬件和操作系统内核协作完成： 处理器生成一个虚拟地址，并把它传送给MMU。MMU生成PTE地址，并从高速缓存/主存请求得到它。高速缓存/主存向MMU返回PTE。PTE中的有效位是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。缺页处理程序页面调入新的页面，并更新内存中的PTE。缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器:要求应用显式地释放任何已分配的快。例如，C语言中的malloc和free。 隐式分配器:应用检测到已分配块不再被程序所使用，就释放这个块。比如Java，ML和Lisp等高级语言中的垃圾收集。 隐式空闲链表： 图7.8一个简单的堆块的格式 一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小，以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是零。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。 图7.9用隐式空闲链表来组织堆 、 图7.10使用边界标记的堆块的格式 在隐式空闲链表堆块的基础上，在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离，这样就允许在常数时间内进行对前面块的合并。 释放当前块的所有可能的情况： 前面的块和后面的块都是已分配的前面的块是已分配的，后面的块是空闲的前面的块是空闲的，后面的块是已分配的前面的和后面的块都是空闲的 显示空闲链表 一种更好的方法是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个前驱和后继指针。 图7.11使用双向空闲链表的堆块的格式 释放一个块的时间可以是线性的，也可能是个常数。 一种方法是用先进后出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址顺序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 7.10本章小结 本章主要介绍了hello的存储器地址空间、Intel的段式管理与页式管理、TLB与四级页表支持下的VA到PA的变换、三级Cache支持下的物理内存访问、hello进程fork时的内存映射、hello进程execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理等内容。 理解虚拟内存将帮助程序员更好地理解系统是如何工作的，理解虚拟内存将帮助程序员利用虚拟内存的强大功能在应用程序中添加动力，理解虚拟内存以及诸如malloc之类的管理虚拟内存的分配程序，可以帮助程序员避免很多错误。 理解存储器层次结构，因为它对应用程序的性能有着巨大的影响。如果我们的程序需要的数据是存储在CPU寄存器中的，那么在指令的执行期间，在0个周期内就能访问到它们。如果存储在高速缓存中，需要4~75个周期。如果存储在主存中，需要上百个周期。而如果存储在磁盘上，需要大约几千万个周期。理解存储器层次结构，对于我们以后编写一些运行速度更快的代码十分重要。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 一个Linux文件就是一个m个字节的序列： B0，B1，…，Bk，…，Bm-1 所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行，这种方式称为UnixI/O接口。 8.2简述UnixIO接口及其函数 UnixI/O接口： 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访间一个I/O设备。内核返回一个小的非负整数，叫做描述，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： 打开和关闭文件： 打开文件 进程是通过调用open函数来打开一个已经存在的文件或者创建一个新文件的。 open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件： O_RDONLY：只读 O_WRONLY：只写 O_RDWR：读写 图8.1open函数 关闭文件 进程通过调用close函数关闭一个打开的文件。 图8.2close函数 读和写文件 read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。下图展示了一个程序使用read和write调用一次一个字节地从标准输入复制到标准输出。返回：若成功则为写的字节数。若出错则为-1。 图8.3read函数、write函数 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 研究printf的实现，首先来看看printf函数的函数体 intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 分析printf函数的内容 ： va_listarg=(va_list)((char*)(&fmt)+4); va_list的定义：typedefchar*va_list 这说明它是一个字符指针。其中的：(char*)(&fmt)+4)表示的是“ ”中的第一个参数。C语言中，参数压栈的方向是从右往左，也就是说，当调用printf函数的适合，先是最右边的参数入栈。fmt是一个指针，这个指针指向第一个const参数（constchar*fmt)中的第一个元素。fmt也是个变量，它的位置，是在栈上分配的，它也有地址。对于一个char*类型的变量，它入栈的是指针，而不是这个char*型变量。 图8.4vsprintf(buf,fmt,arg)函数 它接受一个格式化的命令，并把指定的匹配的参数格式化输出。vsprintf返回的是一个长度。 vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 write(buf,i)： write，顾名思义：写操作，把buf中的i个元素的值写到终端。 图8.5write函数结构体 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章讲述了Linux的I/O设备管理方法、UnixI/O接口及其函数、printf的实现分析、getchar的实现分析。 了解UnixI/O将帮助程序员理解其他的系统概念，有时候除了使用UnixI/O以外别无选择。 Linux提供了少量的基于UnixI/O模型的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行I/O重定向。Linux的读和写操作会出现不足值，应用程序必须能正确的预计和处理这种情况。应用程序不应直接调用UnixI/O函数，而应该使用RIO包，RIO包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。 结论 用计算机系统的语言，逐条总结hello所经历的过程。 编写C语言程序。预处理：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。结果就得到了另一个C程序，通常是以.i作为文件扩展名。编译：在编译阶段，编译器将高级语言编译成汇编语言。汇编语言不具有可移植性，是直接面向处理器的语言，是机器指令的一种符号表示，不同类型的计算机系统有不同的机器指令系统，也就有不同的汇编语言。汇编：在汇编阶段，汇编器将汇编语言指令翻译成机器可执行的机器语言指令。链接：链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。进程管理：进程是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。进程给应用程序提供两个关键的抽象：一个独立的逻辑控制流，一个私有的地址空间。存储管理：CPU上的内存管理单元MMU根据页表将CPU生成的虚拟地址翻译成物理地址，进行相应的页面调度。在这个过程中，TLB，三级cache结构的使用加快了访存速度。I/O管理：Linux提供了少量的基于UnixI/O模型的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行I/O重定向。Linux的读和写操作会出现不足值，应用程序必须能正确的预计和处理这种情况。应用程序不应直接调用UnixI/O函数，而应该使用RIO包，RIO包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。 附件 hello.c：C语言程序 hello.i：C语言程序hello.c预处理后得到的新的C程序 hello.s：将hello.c编译后得到汇编语言文本文件 hello.o：将hello.c汇编后得到的机器语言指令的可重定位目标程序 hello：将hello.o链接后得到的可执行文件 elf.txt：hello.o的ELF文件 elf1.txt：hello的ELF文件 hello.txt：hello.o反汇编后得到的汇编语言代码 hello1.txt：hello反汇编后得到的汇编语言代码 参考文献 [1] RandalE.Bryant ,DavidO'Hallaron.ComputerSystems:AProgrammer'sPerspective.中国电力出版社. 

计算机系统大作业程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算学部学 号1190202107班 级1936602学生姚舜宇 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文利用计算机系统这门课所学的知识，以hello.c程序为例，描述了它的从编写完成到终止的历程。包括预处理、编译、汇编、链接、进程管理、存储管理、IO管理的知识，加强了我们对于计算机系统和程序执行流程的理解。关键词：计算机系统；hello 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介P2P:Program:用户在编辑器或IDE中键入代码得到程序。Process:在Linux中，hello.c经过C预处理其cpp的预处理成为文本文件hello.i，C编译器ccl的编译成为汇编文件hello.s，汇编其as的汇编成为二进制可重定位目标文件hello.o，最终经过ld的链接，成为可执行程序hello。020：OS进程管理通过fork和execve产生子进程和加载并运行程序，进行虚拟内存的映射。CPU通过取指，译码，执行，访存，写回，更新PC的操作，一条一条执行指令。涉及到输入输出时，IO管理对函数进行处理。运行结束后，shell回收hello进程，并消除相关的数据等痕迹。1.2环境与工具硬件工具：X64IntelCorei5-8300HCPU,2.30GHz,8GRAM,512GHDDISK软件工具：Windows1064位，VMwareWorkstation16Pro,Ubuntu20.04.2.0开发与调试工具：Codeblocks,gccgdb,vim,readelf,objdump等1.3中间结果hello.i对hello.c进行预处理得到的文件hello.s对hello.i进行编译得到的文件hello.o对hello.s进行汇编得到的文件hello对hello.o进行链接得到的可执行文件hello.elfhello.o的ELF格式hello-run.elfhello的ELF格式hello_objdump.txt对hello.o进行反汇编得到的文件hello-d-r.txt对hello进行反汇编得到的文件1.4本章小结本章对hello进行了一个简介，并对其运行流程进行了一个总体的概括。然后介绍了所有操作的环境与工具，以及描述了中间产生的文件信息。 第2章预处理2.1预处理的概念与作用预处理是在编译之前对源文件提前进行的处理，可以算是一种展开。预处理通过扫描源代码，对其进行初步转换，产生新的源代码提供给编译器。预处理过程读入源代码，检测包含预处理指令的语句和宏定义，并进行相应的转换，以及删除注释和多余的空白符。预处理的主要作用如下：1.将源文件中以”include”格式包含的文件复制到编译的原文件中；2.用实际值替换以”#define”定义的字符串；3.根据”#if”后面的条件决定需要编译的代码，即条件编译；4.删除文件中的注释和多余的空白符。2.2在Ubuntu下预处理的命令gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析可以看到，原本很短的hello.c经过预处理之后生成的hello.i有数千行，这是预处理过程完成了对头文件的展开、宏定义的替换、去除注释、条件编译等内容。例如，头文件<stdio.h>在hello.i文件中的展开情况是从第13行到728行，里面包含了各种typedef和extern函数等。 在hello.i文件的末尾处，是源程序的主体部分。 2.4本章小结本节主要介绍了预处理的概念和功能，预处理是一个编写完的程序要进行的第一个步骤。预处理主要由预处理器完成，内容主要是展开头文件，宏定义替换，条件编译，去除无关注释。 第3章编译3.1编译的概念与作用编译是把通常为高级语言的源代码（这里指经过预处理而生成的hello.i）到能直接被计算机或虚拟机执行的目标代码（这里指汇编文件hello.s）的翻译过程。编译的主要作用如下：1.词法分析，词法分析器读入组成源程序的字符流并将其组成有意义的词素的序列，即将字符序列转换为单词序列的过程。2.语法分析，语法分析器使用词法分析器生成的各词法单元的第一个分类来创建树形的中间表示，在词法分析的基础上将单词序列组合成各类语法短语。该中间表示给出了词法分析产生的词法单元的语法结构，常用的表示方法为语法树。3.语义分析，语义分析器使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致，它同时收集类型信息，并存放在语法树或符号表中，为代码生成阶段做准备。4.代码生成和优化，在源程序的语法分析和语义分析完成后，会生成一个明确的低级的或类及其语言的中间表示。代码优化试图改进中间代码，生成执行所需要时间和空间更少。最后代码生成以中间表示形式为输入，并把它映射为目标语言。3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 3.3Hello的编译结果解析3.3.1文件内容简介 .file文件命名.text代码段.global全局变量.data数据段.align对齐方式.type类型.size大小.longlong类型.stringstring类型.section.rodata只读数据段 3.3.2数据hello.s中使用到的数据包括：sleepsecs,argc,argv,i,字符串,立即数。1.sleepsecs:这是定义时被初始化的全局变量。.data节保存已初始化的全局和静态C变量，所以编译器首先将sleepsecs在.text节中声明为全局变量，然后将其保存在.data节中，并设置对齐方式为4字节，类型为object，大小为4字节。在后面，sleepsecs又被标记为long类型，值为2，保存在只读代码段中。2.argc:这是传给main函数的第一个参数，表示命令行参数的个数。根据hello.c和hello.s文件推断，argc保存在地址为-20(%rbp)的栈中。 3.argv:它的完整声明为char*argv[]，是一个数组，main函数的第二个参数。它的首地址保存在地址为-32(%rbp)的栈中。 后续调用时，通过对地址进行加法运算，调用数组内部的元素。下图中先让寄存器%rax指向数组首地址，然后加偏移量16，再解引用。再次让寄存器%rax指向数组首地址，然后加偏移量8，再解引用，这样就调用了数组的第一个和第二个元素。 4.i:这是程序运行中定义的局部变量。根据hello.c文件中的循环可以推断，i保存在地址为-4(%rbp)的栈中。 5.字符串：在hello.c中，可以看到两个字符串。 在hello.s中，可以看到字符串 调用字符串时，使用语句 将这两个字符串作为printf函数的参数。6.立即数：立即数不需要寄存器或者栈的空间，直接表示在汇编代码中。 3.3.2控制与操作1.赋值操作赋值操作在hello.c中有对全局变量sleepsecs的初始化，对局部变量i的初始化以及自增运算i++。1)intsleepsecs=2.5sleepsecs是已经初始化的全局变量，在.data节中，值为2，数据类型为long。2)inti=0这是在循环入口处进行的初始化。 在hello.s文件的.L2处，可以看到局部变量i存储在-4(%rbp)处，并且用movl指令将其赋值为0。3)i++这是在每次循环结束时对i进行自增操作。 在hello.s文件的.L4末尾，用addl指令将存储在-4(%rbp)处的i加1。2.类型转换出现类型转换的位置是全局变量sleepsecs。在主函数main之外，使用intsleepsecs=2.5进行初始化。但后来被转换为值为2的long型变量。因为在初始化的时候，赋的数据是2.5，是浮点类型。所以进行向0舍入到2。而默认的浮点类型为8字节的double，所以后来强制转换为整型时转换为8字节的long型。 3.算术操作一般而言，算数操作包括加、减、乘、除、模等，但因为hello.c中出现的算术操作较少，所以这里只讨论加减运算和hello.s中涉及加减的汇编指令。1)i++在hello.s文件中，i++对应的汇编指令为addl$1,-4(%rbp)。即将地址为-4(%rbp)的数据进行加1。2)汇编指令中的算术操作subq$32,%rsp这里是将%rsp的值减32。因为%rsp是栈顶指针，所以这条指令的意义是在栈顶处开辟4字节的空间。leaq.LC1(%rip),%rdi这是加载有效地址的语句，也是算数操作，因为它涉及到计算有效地址。这句指令的意义是计算地址.LC1+%rip，并且传递给%rdi。addl$1,-4(%rbp)这里是将i的值加1。前面已经讨论过，i就局部变量，地址是-4(%rbp)。4.逻辑/位操作一般而言，逻辑/位操作包括与、或、非、异或、同或、移位等。在hello.c和hello.s中，并未出现逻辑/位操作，所以这里不予讨论。5.关系操作常见的涉及到关系操作的汇编指令包括cmp、test、jmp以及条件跳转等。下面就文件中出现的关系操作进行讨论。1)这条指令是将地址为-20(%rbp)的值与立即数3进行比较，并设置条件码。根据条件码的值，进行下一步的执行。下一条指令为je.L2，表示如果地址为-20(%rbp)的值等于3，则跳转到.L2的首地址开始执行。对应的C语言的语句为 但这里是如果参数不等于3则执行括号里的内容。对于汇编代码，对其进行了一定的优化，如果参数等于3，则执行相关内容。2)这一条指令同上一条类似，将地址为-4(%rbp)的值即局部变量i与立即数9进行比较，如果i小于或等于9，则跳转到.L4的首地址开始执行。在hello.c中，循环的判断条件是i<10，编译过程中将其优化为i<=9。6.数组/指针/结构操作1)数组与指针操作hello.c中涉及到的数组操作只有char*argv[]。这是一个数组指针。先查看汇编代码。 首先在这里，是将保存在寄存器里的参数放入内存中，将%edi的内容赋给-20(%rbp)地址的内容，将%rsi的内容赋给-32(%rbp)地址的内容，现在-32(%rbp)就是指向数组首地址的指针。 这里是引用数组下标为1和2的元素，即argv[1]和argv[2]。首先将数组首地址赋给%rax，然后%rax+16即第三个元素的首地址，然后将该地址的内容取出，赋给%rdx。下面再将数组首地址赋给%rax，然后%rax+8即第二个元素的首地址，然后将该地址的内容取出，赋给%rax。2)结构操作在hello.c中，没有定义结构，所以这里不予讨论。7.控制转移控制转移在上文的关系操作中有了一定的解释，一般的控制转移指令有jmp、je、jle、ja等，针对不同的条件码进行转移。1)控制转移指令为je.L2，表示如果地址为-20(%rbp)的值等于3，则跳转到.L2的首地址开始执行。对应的C语言的语句为 控制转移指令为jle.L4，如果i小于或等于9，则跳转到.L4的首地址开始执行。3)在.L2中，有一条无条件跳转指令jmp。 这条指令将会让程序无条件跳转到.L3首地址的位置开始执行。8.函数操作1)参数传递main函数：函数有两个参数，intargc,char*argv[]，第一个参数是一个int型整数，第二个参数是一个指针，即值是一个地址，它们分别存储在寄存器%edi和%rsi中，在函数中，将参数放入栈中保存。 printf函数：在编译过程中，有一处printf函数被优化为puts函数。在整个程序中，调用了两次输出的函数。第一处调用在判断体中。 在调用函数之前，将.LC0(%rip)的值即字符串"Usage:Hello1190202107姚舜宇！\n"的首地址传递给%rdi，所以%rdi为传入给函数puts的参数。第二处调用在循环体中。 在调用函数之前，将.LC1(%rip)的值即字符串"Hello%s%s\n"的首地址传递给%rdi，所以%rdi为传入给函数printf的参数。sleep函数：查看hello.c文件的内容，知道函数sleep的参数有一个，sleepsecs。查看hello.s文件的内容，在调用函数之前，执行movlsleepsecs(%rip),%eax、movl%eax,%edi将参数sleepsecs传入函数sleep。 exit函数：对于exit函数，传参较为简单。将寄存器%edi的值赋为1，然后调用函数。 getchar函数：并没有设置参数，进行条件判断之后直接调用函数。 2)函数调用main函数：由系统调用，首先在运行时通过动态链接，调用libc库里的函数__libc_start_main，然后这个函数会初始化程序，执行__init，注册退出处理程序，再调用main函数。printf函数：由指令callprintf@PLT调用。先将该指令的下一条指令地址压入栈中，然后进入该函数，函数执行结束后，执行调用printf函数指令下一条指令的地址。 sleep函数：由指令callsleep@PLT调用，过程同上。 exit函数：由指令callexit@PLT调用，过程同上。 getchar函数：由指令callgetchar@PLT调用，过程同上。 3)函数返回main函数：程序结束时，将%eax设置为0，然后调用leave。leave相当于调用mov%rbp,%rsp和pop%rbp，将栈恢复为最初的状态。然后调用ret返回。 其他函数返回时将栈恢复为调用该函数之前的状态，此时栈顶的元素就是调用该函数的指令的下一条指令的地址。然后执行该下一条指令即可。3.4本章小结本章着重介绍了编译的概念和作用，并且以hello.i到hello.s为例，分析了编译器是如何处理C语言的各个数据类型以及各类操作，包括字符串等各类数据，赋值操作，类型转换，算术操作，逻辑/位操作，关系操作，数组/指针/结构操作，控制转移，函数操作的内容。经过这部分的讨论与分析，对编译更加了解了。 第4章汇编4.1汇编的概念与作用编译完成生成hello.s文件后，驱动程序运行汇编器as，将hello.s翻译成一个可重定位目标文件hello.o，这个过程就是汇编。汇编的作用主要就是将编译的结果hello.s转化为机器可识别并执行二进制文件。4.2在Ubuntu下汇编的命令gcc-chello.s-ohello.o 4.3可重定位目标elf格式分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。1)可重定位目标文件的ELF格式简介ELF头包括16字节标识信息、文件类型、机器类型、节头表的偏移、表项大小及个数.text节编译后的代码部分.rodata节只读数据.data节已初始化的全局和静态C变量.bss节未初始化的全局和静态C变量.symtab节符号表，存放在程序中定义和引用的函数和全局变量的信息.rel.txt节一个.text节中位置的列表.rel.data节被模块引用或定义的所有全局变量的重定位信息.debug节一个调试符号表，条目是程序中定义的局部变量和类型定义.strtab节一个字符串表，内容包括.symtab和.debug节中的符号表，以及节头部中的节名字.line节原始C源程序中的行号和.text节中机器指令之间的映射Sectionheadertable（节头部表）每个节的节名、偏移和大小 2)读取可重定位目标文件的ELF格式命令：readelf-ahello.o>hello.elf 3)可重定位目标文件ELF格式的分析ELF头：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如X86-64）、节头部表的文件偏移，以及节头部表中条目的大小和数量。hello.o的ELF格式的ELF头如下图： 节头部表：详细标识了每个节的名称、类型、地址、偏移量、大小、读写权限、对齐方式等。如.text节，类型为PROGBITS，起始地址为0，偏移量为40，大小为85，属性为AX，即可装入可执行，对齐方式为1字节。 完整的节头部表如下图： .rel重定位节：在hello.elf里出现了重定位节.rela.text和重定位节.rela.eh_frame。它的内容有偏移量、信息、类型、符号值、符号名称、加数。在重定位节.rela.text中，可以看到符号名称有：.rodata，puts，exit，.rodata，printf，sleepsecs，sleep，getchar。具体数据如下图： .symtab节：存放在程序中定义和引用的函数和全局变量的信息，具体数据如下图： 这里存放了17个条目，可以看到序号为10到17的条目存放了全局变量sleepsecs，_GLOBAL_OFFSET_TABLE，以及各种函数：main，puts，exit，printf，sleep，getchar。4.4Hello.o的结果解析objdump-d-rhello.o>hello_objdump.txt 打开txt文件，发现它是根据.text节进行的反汇编。接下来分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。通过比较可以发现，在以下方面存在区别：控制转移的结构、全局变量的引用方式、函数调用的方法。1)控制转移的结构首先观察hello.s中的控制转移结构： 可以看到编译过程以.L1、.L2、.L3等名称来标记各个段，跳转指令直接描述需要跳转到的段的名称。再看反汇编得到的汇编代码： 可以看出是根据指令的位置相对于main函数地址的偏移量进行定位并且跳转的。2)全局变量的引用方式对全局变量sleepsecs的引用，两者也存在差别。在hello.s中，如下图，是根据段的首地址加%rip得到保存在%eax中，然后转递给%edi。 在hello.o反汇编得到的汇编代码中，如下图，看上去也是通过%rip加一个偏移量得到保存在%eax中，然后转递给%edi。但不同的是，这个偏移量是0。这是因为全局变量的地址在运行时通过重定位确定，在当前情况下通过0来占位。 3)函数调用的方法以sleep函数为例，在hello.s中，指令call后直接加函数名称。 在反汇编代码中，call后的地址就是该条指令下一条指令的地址，并没有函数的首地址。这是因为这些函数需要通过动态链接确定地址，所以当前只是在.rela.text重定位节中保留了函数的信息，等待动态链接进行调用。 最后来说明机器语言的构成，与汇编语言的映射关系。机器语言是一种二进制语言，每一条指令、数据都由二进制来表示。汇编语言用了助记符，对于很多指令的二进制编码，用一个字符串来表示，让程序员更容易读懂。另外反汇编代码不仅显示了汇编代码，还显示了二进制代码。综上可以认为机器语言和汇编语言的映射是一种双射。4.5本章小结本章着重介绍了汇编的概念和作用，并且以hello.s到hello.o为例，介绍并分析了可重定位目标文件的ELF格式，以及对hello.o的结果进行了解析，将编译的结果hello.s与对hello.o的反汇编代码hello_objdump.txt进行比较，了解了汇编代码和反汇编代码的一些结构和内容上的区别。通过这些讨论，增强了对汇编过程的理解。 第5章链接5.1链接的概念与作用汇编过程结束生成hello.o文件后，驱动程序运行链接器程序ld，将hello.o和其他一些必要的系统目标文件组合起来，创建一个可执行目标文件。这个过程就是链接。作用：链接可以将各种代码和数据片段收集并组合策划归纳为一个可以加载到内存并执行的单一文件。它使得分离编译成为可能，可以将一个大型的应用程序分解为更小，更好管理的模块，便于独立修改和编译。链接让程序员能够利用共享库，通过动态链接为程序提供动态内容。5.2在Ubuntu下链接的命令命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。1)可执行目标文件的ELF格式简介可执行目标文件的ELF格式与可重定位目标文件的ELF格式较为相似，稍有不同。ELF头字段e_entry给出执行程序时第一条指令的地址只读代码段程序头表结构数组.init节用于定义_init函数，该函数用来进行可执行目标文件开始执行的初始化工作.text节编译后的代码部分.rodata节只读数据.data节已初始化的全局和静态C变量读写数据段.bss节未初始化的全局和静态C变量.symtab节符号表，存放在程序中定义和引用的函数和全局变量的信息无需装入到存储空间的信息.debug节一个调试符号表，条目是程序中定义的局部变量和类型定义.strtab节一个字符串表，内容包括.symtab和.debug节中的符号表，以及节头部中的节名字.line节原始C源程序中的行号和.text节中机器指令之间的映射节头表每个节的节名、偏移和大小2)读取可执行目标文件的ELF格式命令：readelf-ahello>hello-run.elf 3)可执行目标文件ELF格式的查看ELF头标记了这是一个可执行文件，并且给定了入口点地址。 节头给定了各个部分的具体信息，具体地址。（由于节头过长不宜截图，所以这里仅为节头的一部分） 程序头表，给定了各个部分的具体信息，包括虚拟地址，物理地址。 5.4hello的虚拟地址空间使用edb加载hello，如下图： 根据下图，可以看出hello的虚拟地址从0x401000开始，到0x402000结束。 接下来将此与5.3中的节头进行对比。1).init节，起始地址0x401000，大小0x1b 2).plt节，起始地址0x401020，大小0x60 3).plt.sec节，起始地址0x401080，大小0x50 4).text节，起始地址0x4010d0，大小0x135 5).fini节，起始地址0x401208，大小0xd 5.5链接的重定位过程分析（以下格式自行编排，编辑时删除）objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。结合hello.o的重定位项目，分析hello中对其怎么重定位的。利用命令objdump-d-rhellohello-d-r.txt，将反汇编文件输出到txt文本中。1)hello与hello.o的不同以及链接的过程首先看到使用hello反汇编得到的文件中，对于每一条指令、节、函数，都有了一个以40开头的虚拟地址，和上一节在edb中看到的地址相同。而hello.o反汇编得到的文件中，在相应位置都是由相对偏移量来表示的。 可以观察到hello-d-r.txt比hello_objdump.txt要多出很多内容。包括.init节、.plt节、.plt.sec节、.fini节等。而hello_objdump.txt只有.text节。并且动态链接库里面的函数也已经在.plt.sec节中了，如下图： 链接的过程：1.符号解析。程序中有定义和引用的符号，存放在符号表.symtab节中。这是一个结构数组，存放在程序中定义和引用的函数和全局变量的信息。编译器将符号的引用存放在重定位节.rel.text节以及.rel.data节中，链接器将每一个符号的引用都与一个确定的符号定义建立关联。2.重定位。将多个代码段和数据段分别合并为一个完整的代码段和数据段，计算每一个定义的符号在虚拟地址空间的绝对地址而不是相对偏移量，将可执行文件中的符号引用处修改为重定位后的地址信息。 2)hello中如何重定位下图是链接器重定位算法的伪代码。假设每个节s是一个字节数组，每个重定位条目r是一个类型为Elf64_Rela的结构，定义如下。另外，假设算法运行时，链接器已经为每个节（用ADDR(s)表示）和每个符号都选择了运行时地址（用ADDR(r.symbol)表示）。算法首先计算需要被重定位的4字节引用的数组s中的地址。如果这个引用是PC相对寻址，则用第一个if结构进行处理。如果该引用使用的是绝对寻址，则通过第二个if结构处理。 接下来以函数sleep进行举例说明。在hello_objdump.txt中，函数main调用sleep函数。Call指令开始于节偏移0x6a的地方，包括1字节的操作码0xe8，后面跟着的是对目标sleep的PC相对引用的占位符。 在代码的重定位节.rela.text中，可以看到偏移量r.offset=0x6b，用于偏移调整的值r.addend=-4。 在hello的反汇编文件中，查找到sleep的首地址为0x4010c0，即ADDR(r.symbol)=0x4010c0。 最后ADDR(s)=0x401105。 由重定位算法，链接器首先计算出引用的运行时地址。refaddr=ADDR(S)+r.offset=0x401105+0x0x6b=0x401170。然后，更新该引用，使得它在运行时指向sleep函数。*refaddr=(unsigned)(ADDR(r.symbol)+r.addend-refaddr)=(unsigned)(0x4010c0+(-4)-0x401170)=(unsigned)(0xffffff4c)验证，与hello的反汇编结果一致。 5.6hello的执行流程使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。函数名地址<do_init>0x00007f3f02e9edf0<hello!_start>0x00000000004010d0libc-2.31.so!__libc_start_main>0x00007f3f02cbafc0<libc-2.31.so!__cxa_atexit>0x00007f3f02cddf60<hello!__libc_csu_init>0x0000000000401190<libc-2.31.so!_setjmp>0x00007f3f02cd9e00<hello!main>0x0000000000401105<hello!puts@plt>0x0000000000401030<hello!exit@plt>0x0000000000401060 5.7Hello的动态链接分析对于动态共享库中的PIC函数，编译器无法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任何位置，一般是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。编译器使用延迟绑定的技术将过程地址的绑定推迟到第一次调用过程时。延迟绑定通过GOT和过程链接表（PLT）这两个数据结构的交互来实现。GOT是数据段的一部分，PLT是代码段的一部分。GOT和PLT通过协作在运行时解析函数的地址。GOT和PLT在dl_init被第一次调用时，延迟解析它的运行时地址的步骤：1.不直接调用dl_init，程序调用进入PLT[2]，这是dl_init的PLT条目。2.第一条PLT指令通过GOT[4]进行间接跳转。因为每个GOT条目初始时都指向它对应的PLT条目的第二条指令，这个间接跳转只是简单地把控制传送回PLT[2]中的下一条指令。3.在把dl_init的ID压入栈中之后，PLT[2]跳转到PLT[0]。4.PLT[0]通过GOT[1]间接地把动态链接器的一个参数压入栈中，然后通过GOT[2]间接跳转进动态链接器中。动态链接器使用两个栈条目来确定dl_init的运行时位置，用这个地址重写GOT[4]，再把控制流传递给dl_init。下图是在命令行中用readelf命令查看.got.plt信息的结果，其首地址为0x404000，大小为0x40字节。 dl_init函数之前： 调用dl_init函数： dl_init函数之后： 对比这两个表，发现地址0x404008处的内容由0000000000000000变成了90c1ec023f7f0000。用小端法表示为00007f3f02ecc190。地址0x404010的内容由0000000000000000变成了b05beb023f7f0000。用小端法表示为00007f3f02eb5bb0。这里的变化是因为在程序调用函数dl_init前，编译器无法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。所以使用延迟绑定技术，将过程地址的绑定推迟到调用这个函数的时刻。在调用这个函数时，.got.plt的某些条目就发生了变化。5.8本章小结本章介绍了链接的概念和作用，以及以hello为例，分析了可执行文件的ELF格式、虚拟地址空间、将hello的反汇编文件和hello.o的反汇编文件进行比较，并举例计算了重定位的过程。经过这一部分的讨论，我对链接的过程更加理解了。 第6章hello进程管理6.1进程的概念与作用概念：进程就是一个执行中程序的实例。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。作用：在现代系统上运行一个程序时，进程会提供一个假象，好像我们的程序是系统中当前运行的唯一的程序一样。程序好像是独占地适用处理器和内存，处理器就好像是无间断地一条接一条地执行我们程序中的指令，而且程序中的代码和数据好像是系统内存中唯一的对象。进程提供给程序的关键抽象，一是一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地适用处理器。二是一个私有的地址空间，它提供一个假象，好像我们的程序独占地适用内存系统。6.2简述壳Shell-bash的作用与处理流程作用：shell最重要的功能是命令解释。shell是一个命令解释器。用户提交了一个命令后，shell首先判断它是否为内置命令，如果是就通过shell内部的解释器将其解释为系统功能调用并转交给内核执行；若是外部命令或使用程序就试图在硬盘中查找该命令并将其调入内存，再将其解释为系统功能调用并转交给内核执行。处理流程：shell打印一个命令行提示符，等待用户在stdin上输入命令行，然后对这个命令行求值。命令行求值的首要任务是调用parseline函数，这个函数解析了以空格分割的命令行参数，并构造最终会传递给execve的argv向量。第一个参数被假设为要么是一个内置的shell命令名，马上就会解释这个命令，要么是一个可执行目标文件，会在一个新的子进程的上下文中加载并运行这个文件。在解析了命令行之后，eval函数调用builtin_command函数，该函数检查第一个命令行参数是否是一个内置的shell命令。如果是，它就会易理解释这个命令，并返回值1。否则返回0，shell创建一个子进程，并在子进程中执行所请求的程序。如果用户要求在后台印象该程序，那么shell返回到循环的顶部，等待下一个命令行。否则，shell使用waitpid函数等待作业终止。当作业终止时，shell就回收子进程，并开始下一轮迭代。6.3Hello的fork进程创建过程父进程通过调用fork函数创建一个新的运行的子进程。fork函数只被调用一次，但会返回两次。一次是在调用进程中，一次是在新创建的子进程中。在父进程中，fork返回子进程的pid，在子进程中，fork返回0。创建过程：1.给新进程分配一个标识符。2.在内核中分配一个PCB（进程管理块），将其挂在PCB表上。3.复制它的父进程的环境（PCB中大部分的内容）。4.为其分配资源（程序、数据、栈等）。5.复制父进程地址空间里的内容（代码共享，数据写时拷贝）。6.将进程设置成就绪状态，并将其放入就绪队列，等待CPU调度。6.4Hello的execve过程execve函数在当前进程的上下文中加载并运行一个新程序。Intexecve(constchar*filename,constchar*argv[],constchar*envp[]);execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境遍历列表envp。只有当出现错误时，execve才会返回到调用程序。所以，execve调用一次并从不返回。在execve加载了filename后，调用启动代码，启动代码设置栈，并将控制转移传递给新程序的主函数。当main开始执行时，用户栈的组织结构如下。从栈底（高地址）往栈顶（低地址）依次观察。首先是参数和环境字符串。栈往上是以null结尾的指针数组，其中每个指针都指向栈中的一个环境变量字符串。全局变量environ指向这些指针中的第一个envp[0]。紧随环境变量数组之后的是以null结尾的argv[]数组，其中每个元素都指向栈中的一个参数字符串。在栈的顶部是系统启动函数libc_start_main的栈帧。 6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。进程的上下文：上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。进程时间片：一个进程执行它的控制流的一部分的每一个时间段叫做时间片。进程的调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。当内核选择一个新的进程运行时，就说内核调度了这个进程。当内核调度了一个新的进程运行后，它就抢占当前进程，并通过上下文切换的机制将控制转移到新的进程。上下文切换会保存当前进程的上下文，恢复某个先前被抢占的进程被保存的上下文，将控制传递给这个新恢复的进程。当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个时间发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。中断也可能引发上下文切换。用户态与内核态的转换：进程为hello程序分配了虚拟地址空间，并将hello的代码节和数据节分配到虚拟地址空间的代码区和数据区。首先hello在用户模式下运行，调用系统函数sleep，显式地请求让调用进程休眠。这时就发生了进程的调度。用户模式和内核模式的转换示意图如下： 6.6hello的异常与信号处理hello的异常（中断、陷阱）以及其处理方式。1.中断：中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。处理方式：在当前指令完成执行后，处理器注意到中断引脚的电压变高，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令。结果是程序继续执行，就像没有发生过中断一样。示意图如下： 2.陷阱：陷阱是有意的异常，是执行一条指令的结果。处理方式：陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。用户程序经常需要像内核请求服务，为了允许这些内核服务的受控的访问，处理器提供了一条特殊的“syscalln”指令每当用户程序想要请求服务n时，可以执行这条命令。执行syscall指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。示意图如下： 运行时按Ctrl-Z：内核发送一个SIGTSTP信号到前台进程组中的每个进程。默认情况下，结果是停止前台作业。 之后运行ps命令：ps命令用于显示当前进程的状态。 之后运行jobs命令：用于显示任务列表和任务状态。 之后运行pstree命令：查看进程树之间的关系。 之后运行fg命令：将后台作业（在后台运行或在后台挂起）放到前台运行。 之后运行kill-9%1命令：kill命令用于发送一个信号到一个进程。 重新运行时按Ctrl-C：内核发送一个SIGINT信号到前台进程组中的每个进程。默认情况下结果是终止前台作业。 运行过程中乱按键盘：不会影响程序的运行。 信号的处理：1.对于Ctrl-Z：内核发送一个SIGTSTP信号到前台进程组中的每个进程。默认情况下，结果是停止前台作业。2.对于Ctrl-C：内核发送一个SIGINT信号到前台进程组中的每个进程。默认情况下结果是终止前台作业。3.对于fg信号：将后台作业（在后台运行或在后台挂起）放到前台运行。4.对于kill命令发送的信号：信号编号是9，即SIGKILL，终止。kill-9%1是杀死后台hello程序。6.7本章小结这一章主要学习了异常控制流，进程，信号的处理。这一章的重要性在于讲述了应用是如何与操作系统交互的。这些交互都是围绕着ECF（异常控制流）的。从异常开始，异常位于硬件和操作系统交界的部分。系统调用是为应用程序提供到操作系统的入口点的异常。还有进程和信号，它们位于应用和操作系统的交界之处。学习这一章对于理解用户程序和系统内核的交互有重要的作用。 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：是在有地址变换功能的机器中访内指令给出的地址。也叫相对地址，也就是在机器语言指令中，用来指定一个操作数或是一条指令的地址。要经过寻址方式的计算才能得到内存储器中的实际有效地址。在hello中，生成的hello.o文件中的地址即偏移量，都是逻辑地址。线性地址：如果地址空间中的整数是连续的，那么就说它是一个线性地址空间。在这里讨论的线性地址就是虚拟地址。虚拟地址：是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。通常是一个32为无符号整数，可以用来表示4GB的地址。线性地址通常用十六进制数字表示。程序会产生逻辑地址，通过变换就可以生成线性地址，如果有分页机制，则线性地址可以再映射出一个物理地址。在hello中，对hello可执行文件进行反汇编得到的文本文件中的地址都是虚拟地址，在这里也就是线性地址。物理地址：真实的存储器中的地址，由CPU地址总线传来，硬件电路控制其具体含义。物理地址中很大一部分是留给内存条中的内存的，也常常被映射到其他的存储器上。在没有使用虚拟存储的机器上，虚拟地址被直接送到内存总线上，使用具有相同地址的物理存储器被读写。在使用了虚拟存储的机器上，虚拟地址经过MMU地址翻译后映射成为物理地址，在内存中进行读写。7.2Intel逻辑地址到线性地址的变换-段式管理逻辑地址向线性地址的转换过程如下图。逻辑地址包含16位的段选择符和32位的段内偏移量。MMU首先根据段选择符中的TI确定选择全局描述符表GDT还是局部描述符表LDT。确定描述符表后，再通过段选择符内的13位索引值从被选中的描述符表中找到对于的段描述符。因为每个段描述符占8个字节，所以位移量位索引值乘8，加上描述符表首地址，就可以确定选中的段描述符的地址，从中取出32位的基地址，与逻辑地址中32位的段内偏移量相加，就得到了32位线性地址。 通常情况下，MMU不需要到主存中访问GDT或LDT，只要根据段寄存器对于的描述符cache中的基地址、限界和存取权限来进行逻辑地址到线性地址的转换，如下图。 7.3Hello的线性地址到物理地址的变换-页式管理如下图。线性地址向物理地址的转换过程如下：首先，根据控制寄存器CR3给出的页目录表首地址找到页目录表，由DIR字段提供的页目录索引找到对应的页目录项；然后根据页目录项中的基地址指出的页表首地址找到对应的页表，再根据线性地址中间的页表索引找到页表中的页表项；最后将页表项中的基地址和线性地址中的12位页内偏移量组合成32位物理地址。 其中页目录项和页表项的格式如下图。 P：P=1表示页表或页在主存中；P=0表示页表或页不在主存中。R/W：该位为0时表示页表或页只能读不能写；为1时表示可读可写。U/S：该位为0时表示用户进程不能访问；为1时允许用户进程访问。PWT：用来控制页表或页对应的cache写策略是直写还是写回。PCD：用来控制页表或页能否被缓存到cache中。A：A=1表示指定页表或页被访问过，初始化时操作系统将其清0。D：脏位，只在页表项中有意义。D=1表示被修改过，否则表示为被修改，操作系统将页面替换出主存时，无须将页面写入硬盘。页目录项和页表项中的高20位是页表或页在主存中的首地址对应的页框号，即首地址的高20位。每个页表的起始位置都按4kb对齐。7.4TLB与四级页表支持下的VA到PA的变换TLB：翻译后备缓冲器，是在MMU中的一个关于PTE的小的缓存。TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。虚拟地址中用以访问TLB的组成部分如下。 TLB命中时的地址翻译步骤有：1.CPU产生一个虚拟地址。2.MMU从TLB中取出相应的PTE。3.MMU将这个虚拟地址翻译成一个物理地址，并将它发送到高速缓存或主存。4.高速缓存或主存将所请求的数据字返回给CPU。当TLB不命中时，MMU必须从L1缓存中取出相应的PTE。新取出的PTE存放在TLB中，可能回覆盖一个已经存在的条目。四级页表下的VA到PA的变换：下面是使用四级页表进行地址翻译的示意图。虚拟地址被划分位4个VPN和1个VPO。每个VPN都是一个到某一级页表的索引。36位VPN被划分为4个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 7.5三级Cache支持下的物理内存访问下图给出了在四级页表和三级cache下的物理内存访问示意图。四级页表下的虚拟地址到物理地址的转换已经有过阐述，接下来描述物理内存的访问。图中的L1cache有64组，八路组相连，每块64字节。所以块偏移CO是6位，组索引CI是6位，剩下的40位为标记CT。现有物理地址52位，低6位是CO，CO的左边高6位是CI，剩余的是CT。根据组索引CI，定位到L1cache中的某一组，遍历这一组中的每一行，如果某一行的有效位为1且标记位等于CT，则命中，根据块偏移CO取出数据。如果未命中，则向下一级cache寻找数据。更新cache时，首先判断是否有空闲块。如果有，则写入这个块，否则根据替换算法驱逐一个块后再写入。 7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数在当前进程中加载并允许包含了可执行文件hello中的程序，用hello程序有效地替代了当前程序。加载并允许hello需要以下一个步骤：1.删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。2.映射私有区域。为hello程序的代码、数据、bss和栈区域创建新的区域结构。3.映射共享区域。如果hello与共享对象或目标链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。4.设置程序计数器PC。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux根据需要换入代码和数据页面。下面是加载器如果映射用户地址空间的区域的示意图。 7.8缺页故障与缺页中断处理在异常控制流中学过，缺页异常是一种经典的故障。发生故障时，处理器将控制转移给故障处理程序。如果处理程序额能够修正这个错误的情况，它就将控制返回到引起故障的指令，重新执行。否则处理程序返回到内核中的abort例程，abort例程会终止引起故障的应用程序。 一般的缺页情况如下：CPU引用了VPi中的一个字，VPi并未缓存在物理内存中。地址翻译硬件从内存中读取PTEi，从有效位推断出VPi未被缓存，并且触发了一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序选择一个牺牲页，假设是VPj。如果VPj已经被修改了，那个内核就会将它复制回磁盘。无论那种情况，内核都会修改VPj的页表条目，反应出VPj不再缓存在主存中。接下来，内核从磁盘复制VPi到内存中的PPi，更新PTEi，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。现在，VPi已经缓存在主存中了，那么页命中页能由地址翻译硬件正常处理了。7.9动态存储分配管理动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护者一个变量brk，指向堆的顶部。堆的示意图如下。 分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。一个已分配的块保持已分配状态，直到它被释放。分配器有两种基本风格，显式的和隐式的。显式分配器，要求应用显式地释放任何已分配的块。如C标准库提供的malloc程序包显式分配器。C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。隐式分配器，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。一个实际的分配器需要考虑以下几个问题：1.空闲块组织：如何记录空闲块？2.放置：如何选择一个合适的空闲块来放置一个新分配的块？3.分割：在将一个新分配的块放置到某个空闲块之后，如何处理这个空闲块中的剩余部分？4.合并：如何处理一个刚刚被释放的块？一种较为简单的叫隐式空闲链表的数据结构可以较好地解决这些问题。结构示意图如下： 每一个堆块内有一些字，每个字有4个字节。第一个字记录这个堆块的大小，以及是已分配的还是空闲的。这里介绍的堆块是双字对齐的，所以块大小一定为8的倍数，二进制的低第三位是0。所以用最低位来表示这个块是以分配的还是空闲的。有效载荷就是用户申请的空间，填充是不使用的，大小任意，填充可能是分配器策略的一部分，用来对付外部碎片，或者用它来满足对齐要求。动态存储的分配管理主要包括以下几个操作：1.放置已分配的块当应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大的可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略确定的，有首次适配、下一次适配、最佳适配等。首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配：从上一次查询结束的地方开始搜索。最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块。2.分割空闲块一旦分配器找到一个匹配的空闲块，就必须考虑分配这个空闲块中的多少空间。如果匹配不太友好，则分配器通常会选择将这个空闲块分割为两部分。第一部分变成分配块，剩下的部分变成一个新的空闲块。例如，目前的堆情况如下图所示： 现在有一个3个字的分配请求，因为第一个空闲块空间不够，所以将第二个空闲块分割来分配。分配情况如下图，红色方框的位置即为新分配的块。第一个字保存这个分配块的信息，后三个字保存有效载荷。 3.获取额外的堆内存如果分配器不能为请求块找到合适的空闲块，可以通过合并那些在内存中物理相邻的空闲块来创建一个更大的空闲块。如果这样还是不能生成一个足够大的块，则分配器会调用sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化为一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。4.合并空闲块当分配器释放一个已分配块石，可能有其他空闲块与这个新释放的空闲块相邻，如下图所示。 可以看到，有两个相邻的空闲块。此时如果请求一个4字的空闲块，分配器发现当前的空闲块无法满足要求，就会合并空闲块，将上图中两个相邻的空闲块合并成为一个大的空闲块。有一中更加优化的数据结构能够在常数时间内进行合并。 相比于前面的隐式空闲链表结构，这种结构在块的尾部有一个头部的副本，这样无论是从当前的块向前还是向后合并，都可以检查前一个块或者是后一个块是否是空闲的。如果是，就将它的大小简单地加到当前块头部的大小上，使得这两个块在常数时间内被合并。7.10本章小结本章重点介绍了计算机中的存储，包括地址空间的分类，地址的变换规则，虚拟内存的原理，cache的工作，和动态内存的分配。虚拟内存存在于磁盘中，处理器产生一个虚拟地址，然后虚拟地址通过页表映射等相关规则被转化为物理地址，再通过cache和主存访问物理地址内保存的内容，返回给处理器。通过这一章的学习和总结，我对于计算机的存储方式、缓存、寻址更加理解了。 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件。一个linux文件就是一个m个字节的序列。所有的IO设备都被模型化为文件，包括网络、磁盘、终端等。设备管理：unixio接口。所有的IO设备都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许linux内核引出一个简单、低级的应用接口，成为unixIO，这使得所有的输入和输出都能以一种统一且一致的方式来执行。8.2简述UnixIO接口及其函数Unixio接口：打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）、标准错误（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。改变当前文件的位置。对于每个打开的文件，内核保持着一个文件位置k，初始0.这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。UnixIO函数：open()函数。进程通过调用open函数来打开一个已存在的文件或者创建一个新文件。函数原型：intopen(char*filename,intflags,mode_tmode);open函数将filename转换成一个文件描述符，并且返回描述符字。返回的描述符总是在进程中当前没有的打开的最小描述符。flags参数指明了进程打算如何访问这个文件。close()函数。进程通过调用close函数关闭一个打开的文件。函数原型：intclose(intfd);若返回成功则为0，若出错则为-1。read()函数和write()函数。read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。函数原型：ssize_tread(intfd,void*buf,size_tn);write函数从内存位置buf复制至多n个字节到描述符fd的当前位置。函数原型：ssize_twrite(intfd,constvoid*buf,size_tn);若成功则返回写的字节数，若出错则返回-1。lseek函数。通过调用lseek函数，应用程序能够显式地修改当前文件的位置。函数头文件和原型如下。#include<sys/types.h>#include<unistd.h>off_tlseek(intfd,off_toffset,intwhence);它能够调整读写的位置。若调用成功，则返回当前读写位置相对于文件开始位置的偏移量。若调用失败，则返回-1，并给errno设置错误号。8.3printf的实现分析printf函数的函数体：intprintf(constcharfmt,…){inti;charbuf[256]; va_listarg=(va_list)((char)(&fmt)+4); i=vsprintf(buf,fmt,arg);write(buf,i); returni;}fmt是一个指针，指向第一个const参数中的第一个元素。((char*)(&fmt)+4)表示的是…中的第一个参数的地址。接下来是vsprinff(buf,fmt,arg)。vsprintf函数如下：intvsprintf(char*buf,constcharfmt,va_listargs){charp;chartmp[256];va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!='%'){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); }vsprintf返回的是要打印出来的字符串的长度，作用是格式化，它接受确定输出格式的格式字符串fmt，用格式字符串对个数变化的参数进行格式化，产生格式化输出。下一步是write(buf,i)。通过反汇编跟踪，发现这里是给几个寄存器传递了参数，然后一个int结束。这样的int表示要调用中断门了。通过中断门，来实现特定的系统服务。可以找到INT_VECTOR_SYS_CALL的实现：init_idt_desc(INT_VECTOR_SYS_CALL,DA_386TGate,sys_call,PRIVILEGE_USER);它表示通过系统来调用sys_call这个函数。它的实现如下：sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret开头的一个callsave，是为了保存中断前进程的状态。sys_call的功能就是显示格式化了的字符串。到这里，printf的底层实现就基本结束了。字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析getchar由宏实现：#definegetchar()getc(stdin)。getchar有一个int型的返回值。当程序调用getchar时，程序就等着用户按键。用户输入的字符被存放在键盘缓冲区中。直到用户按回车为止。当用户键入回车之后，getchar才开始从stdin流中每次读入一个字符。getchar函数的返回值是用户输入的字符的ASCII码，若文件结尾则返回-1(EOF)，且将用户输入的字符回显到屏幕。如用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中，等待后续getchar调用读取。也就是说，后续的getchar调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才等待用户按键。异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章着重介绍了Linux的IO设备管理方法，UnixIO接口及其函数，以及printf,getchar的实现和工作过程。这增强了对平时经常调用的一些函数的理解。 结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。hello.c编写完成后，要运行需要经过一下几个步骤：1.hello.c经过预处理，生成文本文件hello.i。2.hello.i经过编译，生成汇编文件hello.s。3.hello.s经过汇编，生成二进制可重定位目标文件hello.o。4.hello.o经过链接，生成可执行文件hello。到这里，hello已经可以成功运行了。在hello的运行过程中，涉及到调用fork函数生成子进程，并有execve函数加载并运行程序。在访存等过程中，涉及到存储管理，包括利用局部性的高速缓存cache和虚拟内存。涉及到输入输出时，又会利用IO管理，设备模拟化为文件等等。总之，hello.c虽然只是一个简单的程序，但从它的编写完成到执行，再到终止，经过了一系列复杂的过程。通过学习计算机系统这门课，像编译、存储、进程并行并发等知识，尤其是编译那一部分，编译器的功能如此的强大，我深深地体会到了计算机科学的伟大。计算机科学当前发展了几十年，汇聚了各路科学家的智慧，在人类社会发挥这越来越重要的作用。在计算机系统、底层的领域一定还会有更加具有智慧的突破出现。 附件列出所有的中间产物的文件名，并予以说明起作用。hello.i对hello.c进行预处理得到的文件hello.s对hello.i进行编译得到的文件hello.o对hello.s进行汇编得到的文件hello对hello.o进行链接得到的可执行文件hello.elfhello.o的ELF格式hello-run.elfhello的ELF格式hello_objdump.txt对hello.o进行反汇编得到的文件hello-d-r.txt对hello进行反汇编得到的文件 参考文献为完成本次大作业你翻阅的书籍与网站等[1]RandalE.Bryant,DavidR.O’Hallaon.深入理解计算机系统.第三版.北京市：机械工业出版社[M].2018：1-737.[2]物理地址、虚拟地址（线性地址）、逻辑地址以及MMU的知识.CSDNhttps://blog.csdn.net/macrossdzh/article/details/5.[3]lseek函数，lseek函数详细说明，函数原型和头文件，lseek函数的详细使用，补充命令（文件IO）[linux]。https://blog.csdn.net/qq_43648751/article/details/104133348[4]printf函数实现的深入剖析。https://www.cnblogs.com/pianist/p/3315801.html。[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 

Hello的一生 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190202111 班 级 1936601 学 生 付一丁 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文介绍了C代码hello.c从一个C文件转化为一个进程、进程从产生到结束的全过程。中间夹杂着与之相关的知识点总结，是对这学期学过的知识的一次汇总。 关键词：预处理；编译；汇编；链接；进程；存储；IO 目 录 第1章概述 -5- 1.1Hello简介 -5- 1.2环境与工具 -5- 1.2.1硬件环境 -5- 1.2.2软件环境 -5- 1.3中间结果 -5- 1.4本章小结 -6- 第2章预处理 -7- 2.1预处理的概念与作用 -7- 2.2在Ubuntu下预处理的命令 -7- 2.3Hello的预处理结果解析 -8- 2.4本章小结 -10- 第3章编译 -11- 3.1编译的概念与作用 -11- 3.2 在Ubuntu下编译的命令 -11- 3.3Hello的编译结果解析 -11- 3.4本章小结 -19- 第4章汇编 -20- 4.1汇编的概念与作用 -20- 4.2在Ubuntu下汇编的命令 -20- 4.3可重定位目标elf格式 -20- 4.4Hello.o的结果解析 -20- 4.5本章小结 -24- 第5章链接 -26- 5.1链接的概念与作用 -26- 5.2在Ubuntu下链接的命令 -26- 5.3可执行目标文件hello的格式 -26- 5.4hello的虚拟地址空间 -28- 5.5链接的重定位过程分析 -29- 5.6hello的执行流程 -31- 5.7Hello的动态链接分析 -31- 5.8本章小结 -32- 第6章hello进程管理 -34- 6.1进程的概念与作用 -34- 6.2简述壳Shell-bash的作用与处理流程 -34- 6.3Hello的fork进程创建过程 -35- 6.4Hello的execve过程 -35- 6.5Hello的进程执行 -36- 6.6hello的异常与信号处理 -37- 6.7本章小结 -41- 第7章hello的存储管理 -42- 7.1hello的存储器地址空间 -42- 7.2Intel逻辑地址到线性地址的变换-段式管理 -43- 7.3Hello的线性地址到物理地址的变换-页式管理 -44- 页式管理是一种内存空间存储管理的技术，页式管理分为静态页式管理和动态页式管理。 -44- 7.4TLB与四级页表支持下的VA到PA的变换 -44- 7.5三级Cache支持下的物理内存访问 -46- 7.6hello进程fork时的内存映射 -47- 7.7hello进程execve时的内存映射 -47- 7.8缺页故障与缺页中断处理 -48- 7.9动态存储分配管理 -49- 7.10本章小结 -50- 第8章hello的IO管理 -51- 8.1Linux的IO设备管理方法 -51- 8.2简述UnixIO接口及其函数 -51- 打开、关闭文件 -51- 读、写文件 -51- 改变当前的文件位置 (seek)-52- 8.3printf的实现分析 -52- 8.4getchar的实现分析 -54- 8.5本章小结 -55- 结论 -55- 附件 -56- 参考文献 -57- 第1章概述 1.1Hello简介 hello从一段C代码，经过预处理变成hello.i，插入头文件，替换宏定义等等。又经过编译器变成汇编程序文本，经过汇编器变成可重定位目标文件。最后经过链接器变成可执行目标程序。 在可执行目标程序运行后，hello完成了从程序到进程的过程，在hello运行的过程中，涉及到了进程与信号的管理，内存的管理和分配，IO的管理，最后执行完毕后被系统回收，正式完成了从无到有，从有又重新化为零的过程。 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 1.2.1硬件环境 X64CPU；2.59GHz；16GRAM；512GHDDisk1.2.2 1.2.2软件环境 Windows1064位；VMwareWorkstation16Player(版本：16.1.0)；Ubuntu20.04.2LTS64位；VMwareWorkstationPro16，gcc，gdb，edb。 1.3中间结果 hello.i cpphello.c >hello.i hello.c经过预处理器(cpp),生成的修改了的源程序(文本)，将系统头文件插入程序文本，将宏定义替换程序文本。 hello.s gcc-Shello.c-ohello.s gcc运行编译器，产生一个汇编文件hello.s hello.o as hello.s–ohello.o hello.s汇编生成hello.o Hello.s objdump-d-rhello.o>Hello.s hello.o反汇编生成的Hello.s hello ld-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o-lc/usr/lib/x86_64-linux-gnu/crtn.o-zrelro-ohello 链接生成。 1.4本章小结 这里作为序言部分，概括的介绍了hello的一生需要经历的过程，后面附有实验运行环境和中间结果文件。 第2章预处理 2.1预处理的概念与作用 预处理器(cpp)根据以字符开头#开头的命令，修改原始的C程序。比如hello.c中的第一行的#include命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件扩展名。 预处理的三种主要作用： 宏定义 在预处理过程中会进行宏展开：将宏名替换成字符串，除了一般的字符串替换，还要做参数代换。但是宏替换只是做替换，不会去计算和求表达式的解。 文件包含 将多个源文件连接成一个源文件进行编译。将头文件插入程序文本中。 条件编译根据条件编译的指令（#if，#elif#else#endif等等），选择需要编译的代码送到编译器进行编译。 除此之外还会进行删除注释内容，处理#error（预处理过程中遇到#error停止编译输出用户自定义的错误信息，经常与条件编译的指令一起使用）等行为。 2.2在Ubuntu下预处理的命令 cpphello.c >hello.i 图1 预处理指令执行截图 生成hello.i 图2 生成hello.i 2.3Hello的预处理结果解析 我们可以看到相比于hello.c代码量增加了不少。这些都是在编译预处理过程中插入头文件的代码。 在hello.c中头文件有三个 图3 hello.c头文件 在这里截取这三个头文件在hello.i中的出现以证明插入。 图4 hello.i中的stdio.h 图5 hello.i中的stdlib.h 图6 hello.i中的unistd.h 但是在实际执行的过程中，我们根据地址找到stdio.h文件，stdio.h的内部也有需要include的头文件，预处理过程会将他们全部插入到文本中，类似递归的操作直到最后没有文本需要插入为止。 图7 hello.i中的stdio_lim.h 这是在hello.i中找到在stdio.h中include的stdio_lim.h 图8 hello.i中的stdio.h 其他头文件的插入过程与这个类似。 除此之外，我们发现并不能找到原本位于hello.c中我们写的注释，说明注释在预处理过程中被删除了 图9 注释已删除 2.4本章小结 预处理是hello.c向进程转化的第一步，在这个过程中hello插入必要的文件，执行了替换操作，删除了不必要的注释内容，选择了合适的条件编译部分，为编译做好了准备。 第3章编译 3.1编译的概念与作用 编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言文件程序。 编译的作用： 编译器将高级语言的声明、表达式、过程(函数)翻译成低级(底层)的指令序列。 在编译过程中编译器主要做了以下事情：扫描（词法分析）、语法分析、语义分析。在程序检查无错误之后，会将相应的高级语言转化成对应的汇编语言。而在这个过程中可以根据编译的选项或者实际需要对代码进行不同程度的优化。较高级别的优化能够提升程序的性能，但是也会使得程序变得令人难以理解。 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 在Ubuntu下编译的命令 gcc-Shello.c-ohello.s 图10 编译 3.3Hello的编译结果解析 观察hello.s,我们可以找到main函数 图11 hello.s 3.3.1 变量与常量 全局变量 观察全局变量sleepsecs在汇编代码中的表示 图12 sleepsecs 我们可以hello.s中查找到，观察知，它被赋值为2。 局部变量 观察hello.c中的局部变量i，观察以下两行，可知 图13 局部变量i 可知局部变量保存在-4(%rbp)的位置上，局部变量保存在栈中。 argc保存在-20(%rbp)。 图14 argc argv[1]保存在-24(%rbp) argv[2]保存在-16(%rbp)。通过观察rdx和rsi中保存值的由来可知。 图15 argv 常量 列举hello.c中存在的常量在汇编语言中的表示。 图16 常量sleepsecs 这里是将2赋值给全局变量sellpsecs的常数2. 图17 常数3 对应hello.c第16行常数3 图18 常数9 循环变量判断是否小于0，被转化成了判断是否小于等于9. 图19 exist(1) 一些字符串常量： 图20 字符串常量1 图21 printf参数常量 3.3.2 数组/指针/结构 argv[1]保存在-24(%rbp) argv[2]保存在-16(%rbp)。通过观察rdx和rsi中保存值的由来可知。 图21 argv 我们可以知道argv是char**类型，所以起始地址位于-32(%rbp)也就是argv[0]而角标每加一相当于地址加8. 3.3.3 赋值运算 图22 赋值 通过movl命令实现。 3.3.4 类型转换 图23 强制类型转换 在hello.c中原本给sleepsecs赋值2.5但是由于sleepsecs是int类型所以转化为赋值2. ​​​​​​​ ​​​​​​​3.3.5 关系操作 图24 比较== 图25 比较<= 用cmp命令来实现。 ​​​​​​​​​​​​​​ ​​​​​​​3.3.6 控制转移 图26 if(argc!=3) 图27 for循环控制 框起来三部分实现for(i=0;i<10;i++),37行实现i=0，53行实现i++，55和56行实现i<=9的判断和进入循环体。38行实现第一次判断。 函数操作传参 图28 main函数传参argc和argv 图29 printf传参 图30 sleep传参 图31 exist传参 图32 puts传参 函数调用 图33 函数调用 函数返回 上图61行main函数返回。 此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~3.3.x等按照类型和操作进行分析，只要hello.s中出现的属于大作业PPT中P4给出的参考C数据与操作，都应解析。 3.4本章小结 根据对变量、常量，函数、操作符等等的解析，我们理解了他们在汇编代码中的表示形式，也逐渐掌握了汇编代码的含义。hello.c正逐渐向着可执行的目标文件转换。 第4章汇编 4.1汇编的概念与作用 汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数marin的指令编码。 汇编作用：将hello.s中的汇编语言翻译成机器语言指令，生成可重定位目标文件。 注意：这儿的汇编是指从.s到.o即编译后的文件到生成机器语言二进制程序的过程。 4.2在Ubuntu下汇编的命令 as hello.s–ohello.o 应截图，展示汇编过程！ 图34 汇编 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 4.4Hello.o的结果解析 objdump-d-rhello.o 分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 图35 反汇编 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 这里之前写错写的HELLO.O后来重新执行了正确的命令 objdump-d-rHello.s 4.4.1 汇编语言与机器语言的对应关系 我们可以通过观察发现，机器语言指令和汇编语言指令是逐行一一对应的。一条汇编指令对应一条机器指令。机器指令在计算机内是以二进制串的形式表示，但是这里为了方便阅读表示为按字节断的十六进制数。 4.4.1 GCC汇编代码和反汇编生成的汇编代码的一些语法不同 我们可以观察到发挥便生成的汇编代码和GCC生成的汇编代码是有一定的区别的。它省略了很多指令末尾的’q’。这些后缀是大小提示符，在大多数情况中可以省略。相反，反汇编器给call和ret指令添加了’q’后缀，同样省略这些后缀也没有问题。另外，在GCC生成的汇编代码中，使用的常数是十进制，在反汇编生成的代码中被转换成了十六进制。 图36 汇编代码 图37 反汇编代码 4.4.2 机器语言的构成 机器语言是由操作码和操作数构成。以上图的第7e行命令为例，其中后四位就是操作数，前面的是操作码。 4.4.3 机器语言和汇编语言操作数的不同。 在汇编语言中，调用全局变量的时候，是用段的名字，或者全局变量的名字在加上rip的值来寻址 图38 汇编代码寻址 但是在转换成机器语言之后 图39 反汇编代码寻址 会用0占位，并且标记在段中的偏移量，等待链接之后确定真实的地址。 4.4.4 分支转移 在汇编代码中，通过跳转到段名所标记的位置的方式来确定跳转的位置 图40 汇编跳转 在汇编语言中通过计算现在跳转的指令相对于函数开头的偏移量来实现。 图41 反汇编跳转 4.4.5 函数调用 在汇编语言中，函数调用是直接调用函数的名字 图42 汇编函数调用 在机器语言中，函数调用的指令的操作数暂时被填0占位，因为只有链接之后才能确定具体的地址。我们观察右侧的反汇编代码，可以看到这个地址用相对当前地址的偏移量表示 图43 反汇编函数调用 4.5本章小结 在汇编过程中，hello由汇编代码转换为了机器代码。但是还是有很多地方没有确定：与其他文件还没有建立联系，目前由于地址没有确定所以在跳转，调用函数和全局变量中使用的地址还是暂时占位的地址。而这些需要在接下来的步骤中实现。 第5章链接 5.1链接的概念与作用 链接是将各种代码是数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存中并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的，在现代计算机系统中，链接是由叫链接器的程序自动执行的。 注意：这儿的链接是指从hello.o到hello生成过程。 5.2在Ubuntu下链接的命令 ld-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o-lc/usr/lib/x86_64-linux-gnu/crtn.o-zrelro-ohello 图44 链接 使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 执行readelf-ahello 查看各段信息。 图45 节头表 图46 节头表后半 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 用edb打开文件，发现能够根据在readelf中看到的地址在edb中查找到对应位置。 图48 edb查看虚拟内存 图49 查看内存区域 打开memoryregions窗口，可以看到这里标记着不同部分的程序的信息的位置。我们根据之前readelf看到的头部表，可以发现他们位于0000000000400000所在的区间里，我们只需要在memoryregions点击就能跳转到这个内存区域，然后再在DataDump里根据地址查找我们想看的不同段的信息。 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 执行上述命令。 图50 hello.s 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 图51 全局变量、地址与重定位 比较这两处可以发现，在链接过程中，成功确定了全局变量的位置，给与了它真实的地址并且将其填写到这里，覆盖原本用来占位的0. 而且观察前面每行汇编命令的地址。Hello.s中只是相对于开头的偏移量。而在重定位之后，给予了每条语句确切的地址。 分支转移 图52 分支转移 可以看到在分支处跳转的时候，也将偏移量替换成了虚拟地址。 函数调用 图53 函数调用 函数调用的时候也将替换成了虚拟地址。 除去这些之外在重定位之后代码显著边长将链接前各个文件中的内容汇合在了一起。 5.6hello的执行流程 图54 按顺序列出函数 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 我不太明白如何用edb列出所有函数调用，但是我可以用gdb实现这个任务。 5.7Hello的动态链接分析 共享库是一个致力于解决静态库缺陷的现代创新产物。共享库是一个目标模块，在运行或者加载的时候，可以加载到任意内存地址，并和一个在内存中的程序链接起来执行的。共享库也被称为共享目标在linux里通常用.so后缀来表示。 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 我们观察函数.got.plt，在gdb中的地址。 图55 查看.got.plt 图56 运行前 图57 运行后 发现0x404000附近的值发生了变化。hello程序有很多函数需要共享调用，比如puts，等等，GNU使用延迟绑定的方法来处理这种情况，将过程地址的绑定退出到第一次调用的时候。在加载之后，动态链接器重定位GOT中的条目，使得它指向绑定后的正确的地址，也就是7f8f0b34abb0。 5.8本章小结 经过一系列程序hello终于在链接之后变成可以执行的可执行文件，在链接的过程中进行了符号解析和重定位，将各个需要的代码和数据片段合并到了一起，成为一个完整的，可以运行的程序。因为链接的存在，我们可以在开发的时候分别对不同文件开发，编译，而不需要每次对整个工程进行编译，极大地提高了开发的小笼包和管理的成本。 接下来可执行目标文件hello，将要正式走向运行。 第6章hello进程管理 6.1进程的概念与作用 在现代系统上运行一个程序的时候，我们会得到一个假象，就好像我们的程序是系统当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的命令。最后我们程序中的代码和数据就好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都在运行在某个进程的上下文当中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。每次用户通过shell输入一个可执行文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个进程的上下文中运行它们自己的代码或其他应用程序。 6.2简述壳Shell-bash的作用与处理流程 bash原来就是能够解释从标准输入和文件的命令，能够让人通过键盘输入特定命令的方式，调用相应的应用程序。 我们可以通过观察linux的进程树来理解bash的处理流程 在调用一次pstree之后 图58 pstree 我又输入了一次/bin/bash 图59 pstree(2) 可以看出来在进程树中bash创建了一个新进程bash，然后在新进程中衍生创建出了进程pstree。这个个多出来的中间的bash，就是我刚刚输入命令/bin/bash创建出来的。 在bash执行的时候，如果遇到fork()，将会派生出一个子进程，大致如下图。 图60 进程图 shell在处理的过程中，先打印一个标识符，表明在等待用户输入命令行(在ubuntu下通常为#或者$)。然后用户输入命令字符串。shell程序会调用parseline函数对这个字符串进行解析，拆解以空格分割命令中的词，存入argv数组。假设数组的第一个词是一个系统内置命令，那么shell将会立刻执行该命令。假设最后一个参数为’&’,那么这个程序将会转入后台执行，parseline返回1，否则返回0，表示应该在前台处理这个程序。 如果最后发现不是系统内置命令而是需要执行一个可执行文件，那么shell将会新创建一个子进程，并在这个子进程中去运行这个可执行文件。如果子进程终止，那么shell需要对僵尸进程进行回收。 6.3Hello的fork进程创建过程 我们在shell中键入./hello1190202111付一丁之后，shell会判断这个命令行是不是系统的内置命令。在发现不是之后，会调用fork创建一个子进程对其进行处理。新创建的子进程几乎但是不完全与父进程相同。子进程得到与父进程用户及虚拟地址空间相同的（但是独立的）一份副本，包括代码与数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这意味着父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别是他们有不同的PID。 fork函数只被调用一次，但是会返回两次：一次实在调用进程（父进程）中，一次是在新创建的进程子进程中。在父进程中，fork返回子进程的PID。在子进程中，fork返回0。 6.4Hello的execve过程 execve函数在当前进程的上下文中加载并运行一个新程序。 intexecve(char*filename,char*argv[],char*envp[]) execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到hello，execve才会返回到调用程序。所以与fork调用一次返回两次不同，execve调用一次从不返回。 调用execve会覆盖掉当前进程的代码、数据、栈，保留相同的PID。继承已打开的文件描述符和信号上下文。 6.5Hello的进程执行 时间片：一个进程执行它的控制流的一部分的每一个时间段叫做时间片。 内核模式：处理器必须提供一种机制，来限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常是用某个控制寄存器的一个模式位来提供这种功能。该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式（有时候叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。 用户模式：没有模式位的时候，进程就运行在用户模式中，用户模式不允许进程执行特权命令，也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。 内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。在进程执行的某些时刻，内核可以决定抢占当前进程，并且重新开始一个之前被抢占的进程。这种决策叫做调度。在内核调度了一个新进程运行后，它就抢占当前进程，并使用一种叫做上下文切换的进制将控制转移到当前的进程。 上下文切换的工作：保留当前进程的上下文；恢复某个先前被抢占的进程的被保存的上下文；将控制传递给这个进程。 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。在进程A和进程B之间进行上下文切换的例子如图 图61 A和B之间上下文切换 6.6hello的异常与信号处理 程序正常运行实例： 图62 正常运行 程序会打印十行Hello1190202111付一丁，然后输入一个字符并按回车之后终止程序。 6.6.1 在执行时输入ctrl-Z 图63 ctrl-z 输入ctrl-Z，程序停止 我们接着输入ps-ef|grephello。发现程序依旧存在只是暂时被停止了。 图64 查看进程是否存在 输入fg继续转入前台执行直到结束。 图65 恢复前台继续运行 这个实验我写到这里是晚上7点，之前虚拟机挂起了所以很早运行过hello，所以前面有一些记录。 图66 记录时间 再执行一次。 图67 停止 图68 查看进程 然后kill这个进程 图69 杀死进程 图70 终止进程 调用jobs命令查看 图71 调用jobs查看 我无意中有一个之前没有注意到的地方。 我在另一个为其他任务执行的shell中输入jobs 图72 另一个shell查看 得到的结果是不同的。 于是我使用pstree命令。 图73 查看进程树 可以查看整个进程树。找到bash和hello相关。 图74 查看bash分支 看到这里就明白了，在bash中调用jobs，只会在以当前bash为根的进程树的子树下查找jobs。所以在两个bash下显示的jobs的结果不同。 6.6.2 程序执行的时候输入ctrl-C 程序运行时输入ctrl-C，程序终止。 图75 查看进程 发现晚上7点运行的hello已经被终止了。 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 6.7本章小结 在这一章中hello正式由静止的程序，走向了执行中的进程。hello执行的过程，离不开他所依赖的shell，进程管理机制和各种信号异常的调控的支持。正是因为他们的存在，给与了hello良好的运行环境。让一个运行的进程顺利的完成从产生到终止的全过程。 第7章hello的存储管理 7.1hello的存储器地址空间 线性地址如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。为了简化讨论，我们总是假设使用的是线性地址空间。 物理地址:计算机系统的主存被组织为一个由M个连续字节大小的单元组成的数组。每字节都有一个由M个连续字节大小的单元组成的数组。每字节都有一个唯一的物理地址。第一个字节的地址为，剩下的字节地址顺序依次加一。 虚拟地址：使用虚拟寻址的时候，CPU生成一个虚拟地址，来访问主存，这个虚拟地址在被送到内存之前先转换成一个适当的物理地址。hello的虚拟地址在linux环境中和线性地址相等。等于逻辑地址加上段的基地址。 图76 查看各段地址 逻辑地址：在代码中相对于当前段的偏移量，或者说偏移地址，在程序机器码中的显示的地址，或者说在反汇编中看到的地址都是逻辑地址。他们需要加上对应段的基地址才是实际的地址。hello的反汇编看到的是逻辑地址。gdb看到的也是虚拟地址。 图77 前面的地址是逻辑地址 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 7.2Intel逻辑地址到线性地址的变换-段式管理 段式管理：段式管理是不连续分配技术的一种。它按照用户的思考方式，将程序按照程序段，数据段等具有明确逻辑含义的“段”，分配内存空间。段的管理是通过在节头表中保存的各段的信息实现的。在段式管理中，可以每个段不连续的地放在内存的不同分区中，但是每个段内部是连续的，操作系统以段为单位分配连续的内存。 图78 段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 页式管理是一种内存空间存储管理的技术，页式管理分为静态页式管理和动态页式管理。 将各进程的虚拟空间划分成若干个长度相等的页(page)，页式管理把内存空间按页的大小划分成片或者页面（pageframe），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。 图79 页式管理 7.4TLB与四级页表支持下的VA到PA的变换 我们先关注TLB的作用。TLB作为在CPU中的小的，虚拟寻址缓存，其中每一行都保存一个单个PTE组成的块， 图80 TLB 在拿到虚拟地址之后，可在VPN中根据TLB的组数，将VPN分成TLBT和TLBI两部分，根据TLBI查找到TLB对应组，根据TLBT确定指定虚拟地址是否在TLB中存在，若存在，则获取PTE生成完整的物理地址，MMU将物理地址传送到告诉缓存/主存，然后高速缓存/主存返回所请求的数据给处理器。这也就是下图的执行过程。 图81 命中 如果TLB不命中，那么MMU必须从L1缓存中取出相应的PTE。新取出的PTE存放在TLB中，可能会覆盖一个已有的条目。 图82 TLB不命中 那在具体实现的时候是怎么访问四级页表的呢。 图83 多级列表 页表的基地址寄存器指向一级页表的首地址。虚拟地址的VPN部分根据K级页表的结构分成K段，通过VPN1指向的一级页表的位置，寻找到对应的二级页表，再由VPN2指向的二级页表的位置寻找到对应的三级页表，以此类推。最终在k级页表里找到最终的PPN。PPN和VPO也就是PPO组合在一起，获得最终的物理地址。 7.5三级Cache支持下的物理内存访问 图84 三级cache示意 以IntelCorei7内存系统为例。 这张图展示了，一个有着三级cache的系统如何进行物理内存访问。 图85 物理内存访问流程 CPU先在根据当前的虚拟地址，在L1TLB中查找需要的PTE，如果命中，那么直接获得PPN生成物理地址。如果不命中需要在多级列表中继续查找PTE。在获得物理地址之后，需要将物理地址分成target，Index和偏移量三部分，现在L1d-cahce中查找，如果在L1中存在则直接将结果返回给CPU，如果L1中不存在则需要继续在下一级缓存/主存中查找，直到命中将结果返回给CPU。 7.6hello进程fork时的内存映射 程序调用hello命令，会新创建一个子进程，子进程会获得一个和父进程用户级虚拟地址空间相同的，但是独立的一个副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开的文件描述符相同的副本。 7.7hello进程execve时的内存映射 当hello进程开始执行的时候，会在当前的进程载入并运行一个新的程序，而不是像fork新创建一个进程。这就意味着会覆盖当前进程的代码，数据和栈。 新程序的main开始执行之后用户栈的结构如图所示。 图86 用户栈的结构 7.8缺页故障与缺页中断处理 图87 缺页的情况 该图显示了缺页的处理过程。CPU引用了VP3中的一个字，但是VP3并没有被缓存在DRAM中。地址翻译硬件从内存中调用VP3从有效位判断其未被缓存，则触发缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中牺牲页是存放在PP3中的VP4.如果VP4已经被修改了，那么内核就会将它复制回磁盘。接下来内核从磁盘中复制VP3到内存的PP3中，更新PTE3，然后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送到地址翻译硬件。但是现在，VPT3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。 图88 更新之后 7.9动态存储分配管理 （以下格式自行编排，编辑时删除） Printf会调用malloc，请简述动态内存管理的基本方法与策略。 动态内存分配器维护着一个进程的虚拟内存区域，称之为堆。假设堆是一个请求二进制零的区域，它紧邻在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每一个进程，内核维护着一个变量brk，它指向堆的顶部。堆维护一些大小不同的块的集合，每个块是连续的虚拟内存片，要么是已分配的，要么是空闲的。 内存分配管理有多种方法，有隐式空闲链表，显示空闲链表，红黑树等等。这里以隐式空闲链表为例，说明如何进行动态内存分配管理。 图89 隐式空闲链表 隐式空闲链表包含一个序言块和结尾块，用来标记头和尾。中间普通块包含头部和脚部，记录着当前块的大小，以及是否空闲。 当需要新分配一个大小为n的块的时候，需要调用一个查找适配块的函数，查找大于n的所有块，找到一个用来分配。 这个匹配的方法一般有三种： 首次适配。每次从链表的头部开始遍历直到找到一个块满足要求。 下一次适配。从上一次遍历的结束位置继续向下查找。 最佳适配。找到能分配的最合适的块（最小但是满足需求的）。但是需要查找的时间更长。 释放块：这个过程需要首先根据地址找到对应块，然后将需要释放的块标记为空闲。接下来需要查看是否需要与该块前后位置的两个块合并。 一共有四种情况：前面块空闲，后面已分配；前面块已分配，后面空闲；前面块已分配，后面已分配；前面块空闲，后面空闲。需要根据这四种情况分别进行处理，更新新的合并后的块的头部和脚部。 7.10本章小结 这一章涉及到hello在运行过程中的内存管理，涉及到了段式管理，页式管理，以及包含TLB，多级cache，多级页表下的综合情况。以及动态内存分配等相关内容。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 所有的I/O设备（例如网络、磁盘和终端）都被模式化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种设备优雅地映射成文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnitI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 打开、关闭文件 open()、close() intopen(char*filename,intflags,mode_tmode); intclose(intfd); open函数是将filename文件转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在当前进程中没有打开的最小描述符。flag指明了应该用什么读方式打开一个已经存在的文件： O_RDONLY 只读 O_WRONLY 只写 O_RDWR 可读可写 也可以是一个或者更多掩码的或 O_CREAT 如果文件不存在那么就创建一个截断的（空）文件 O_TRUNC 如果文件已经存在，那么就截断它。 O_APPEND 在每次写操作前，设置文件位置到文件的结尾处。 读、写文件 read()、write() 读文件从当前文件位置复制字节到内存位置，然后更新文件位置，返回值表示的是实际传送的字节数量。 写文件从内存复制字节到当前文件位置，然后更新文件位置，返回值表示的是从内存向文件fd实际传送的字节数量。 读文件和写文件不足值的情况是可能的(nbytes<sizeof(buf))，不是错误，但是两个函数的返回值若是小于0则是发生了错误。 改变当前的文件位置 (seek) 指示文件要读写位置的偏移量 lseek() 读取文件元数据 stat() 元数据是关于文件的信息 用户通过调用stat和fstat访问元数据 图90 元数据 这些都是异步信号安全的函数。 8.3printf的实现分析 先观察printf的函数 intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 这里面包含一个函数VSprintf intvsprintf(char*buf,constchar*fmt,va_listargs) { char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++) { if(*fmt!='%') { *p++=*fmt; continue; } fmt++; switch(*fmt) { case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); } 这个vsprintf的作用就是将我们在汇编看到的printf的第一个参数的字符串格式化，查找这个字符串里一些特定标志的是否存在，如%x，%s等等，这里应该只列出了一部分。然后将他们转换成实际对应的变量。就是一个将字符串内的符号和参数匹配的过程。 printf在调用vsprintf之后，调用了write函数，显然，他是将重新整合之后，也就是我们最终想输出的字符串，通过文件写的形式调用设备，输出到终端上。 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret 格式化在设备上输出字符串，这个过程需要到库中去查找需要输出的字符的点阵字模，然后在屏幕上通过LED灯显示。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 intgetchar(void) { charc; return(read(0,&c,1)==1)?(unsignedchar)c:EOF //EOF定义在stdio.h文件中 } 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 这里主要讨论hello在运行的时候如何与我们进行“交互”的一些内容，介绍了linux下I/O是如何管理的，一些UnixI/O接口函数，并且对printf和getchar的原理与实现进行了一些介绍。 结论 1.首先通过IDE完成对hello.c文件的编写 2.通过预处理器插入头文件，替换宏定义等操作。 3.通过编译器进行编译生成汇编代码。 4.汇编器将汇编代码转化为可重定位目标文件 5.链接器进行链接，生成和执行文件hello。 6.shell中键入命令，运行hellp程序。 7.shell调用fork为运行hello生成子进程。在这个过程中处理用户输入的命令和信号 8.内存管理系统将页表载入内存。如果缺页则进行处理在程序运行中 9.程序通过I/O管理获取设备的输入，并把输出打印在屏幕上。 10.hello运行结束之后，shell回收hello进程，释放内存。 感受；没有什么创新理念哈哈，这对于我来说还是为时过早了。但是真的学了这门课觉得发现几十年积淀设计出来的计算机真的是精致，这段学习的历程不虚此行。而且这门学到的知识这学期立刻就在自己的日常生活中和其他课的实验中应用到，还是受益很多。 附件 hello.i cpphello.c >hello.i hello.c经过预处理器(cpp),生成的修改了的源程序(文本)，将系统头文件插入程序文本，将宏定义替换程序文本。 hello.s gcc-Shello.c-ohello.s gcc运行编译器，产生一个汇编文件hello.s Hello.s objdump-d-rhello.o>Hello.s hello.o反汇编生成的Hello.s hello ld-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o-lc/usr/lib/x86_64-linux-gnu/crtn.o-zrelro-ohello 链接生成。 参考文献 [1] ComputerSystems:AProgrammer'sPerspective(3rdEdition). 北京：机械工业出版社，2016 [2] https://blog.csdn.net/shiyongraow/article/details/81454995 [3] https://blog.csdn.net/renlonggg/article/details/101034096 [4] https://blog.csdn.net/weixin_33262687/article/details/117052224 [5] https://blog.csdn.net/qq_36299025/article/details/90927980 [6] https://www.cnblogs.com/marsqi/p/6284272.html [7] https://www.cnblogs.com/pianist/p/3315801.html [8]https://zhengkang.blog.csdn.net/article/details/51680017?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.base [9] https://blog.csdn.net/qq_41824181/article/details/85860975 [10] https://baike.baidu.com/item/%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86/6984316?fr=aladdin 

哈尔滨工业大学-计算机系统大作业-程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号119020XXX班 级1936XXX学生XXX 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文以hello.c程序为例,阐述程序在Linux系统中的整个生命周期和操作系统在此过程中进行的各种管理，具体阐述了hello程序经过预处理、编译、汇编、链接生成可执行文件、产生进程直至进程终止回收的过程、操作系统的进程管理、存储管理和I/O管理。 关键词：Linux；计算机系统、程序、进程； 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-4-1.4本章小结-4-第2章预处理-5-2.1预处理的概念与作用-5-2.2在Ubuntu下预处理的命令-5-2.3Hello的预处理结果解析-5-2.4本章小结-5-第3章编译-6-3.1编译的概念与作用-6-3.2在Ubuntu下编译的命令-6-3.3Hello的编译结果解析-6-3.4本章小结-6-第4章汇编-7-4.1汇编的概念与作用-7-4.2在Ubuntu下汇编的命令-7-4.3可重定位目标elf格式-7-4.4Hello.o的结果解析-7-4.5本章小结-7-第5章链接-8-5.1链接的概念与作用-8-5.2在Ubuntu下链接的命令-8-5.3可执行目标文件hello的格式-8-5.4hello的虚拟地址空间-8-5.5链接的重定位过程分析-8-5.6hello的执行流程-8-5.7Hello的动态链接分析-8-5.8本章小结-9-第6章hello进程管理-10-6.1进程的概念与作用-10-6.2简述壳Shell-bash的作用与处理流程-10-6.3Hello的fork进程创建过程-10-6.4Hello的execve过程-10-6.5Hello的进程执行-10-6.6hello的异常与信号处理-10-6.7本章小结-10-第7章hello的存储管理-11-7.1hello的存储器地址空间-11-7.2Intel逻辑地址到线性地址的变换-段式管理-11-7.3Hello的线性地址到物理地址的变换-页式管理-11-7.4TLB与四级页表支持下的VA到PA的变换-11-7.5三级Cache支持下的物理内存访问-11-7.6hello进程fork时的内存映射-11-7.7hello进程execve时的内存映射-11-7.8缺页故障与缺页中断处理-11-7.9动态存储分配管理-11-7.10本章小结-12-第8章hello的IO管理-13-8.1Linux的IO设备管理方法-13-8.2简述UnixIO接口及其函数-13-8.3printf的实现分析-13-8.4getchar的实现分析-13-8.5本章小结-13-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介Hello的P2P（FromProgramtoProcess）过程：hello程序的生命周期从高级C语言程序开始，为了在系统上运行hello.c文件，首先要完成从源文件到可执行目标文件的过程，这包括四个阶段：预处理、编译、汇编、链接。在得到可执行目标文件hello之后，在shell中运行这个目标程序，shell将为其分配进程空间，加载目标程序并运行。这个过程就是P2P（FromProgramtoProcess）的过程。Hello的020（FromZerotoZero）过程：程序运行前，shell调用execve函数将hello程序加载到相应的上下文中，将程序内容载入物理内存，并从main函数开始执行目标代码；程序结束后，父进程回收终止进程，内核清除相关痕迹。hello程序从不存在（0）到产生再到被回收（0）的过程，即是020的过程。1.2环境与工具硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位；开发工具：VisualStudio201064位以上；GDB/OBJDUMP；DDD/EDB；GCC；vim;readelf；HexEdit1.3中间结果hello.c:c语言编写的源文件，以ASCII码编码hello.i:hello.c经预处理得到的文本文件hello.s:hello.i经编译得到的文本文件，包含汇编语言程序hello.o:hello.s经汇编得到的可重定位目标文件hello:经链接得到的可执行目标文件hello.out:hello的反汇编文件 1.4本章小结本章简要介绍了hello文件的P2P和020过程，介绍了将要使用的环境与工具，列出了过程中产生的中间结果。 （第1章0.5分） 第2章预处理2.1预处理的概念与作用预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的#include<stdio.h>命令告诉预处理器读取头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件拓展名。2.2在Ubuntu下预处理的命令命令：gcc-Ehello.c-ohello.i 图2.1对hello.c的预处理过程2.3Hello的预处理结果解析 图2.2hello.c的预处理结果–hello.i文件 打开经预处理得到的hello.i文件，可以看到文件的内容增多，所做的处理包括1）处理宏定义指令，如对#define指令进行替换，对#undef取消对某个宏的定义2）处理条件编译指令，如#ifdef、#ifndef、#else、#elif、#endif等，过滤不必要的代码3）处理头文件包含指令，即#include，把头文件中的定义添加到文件中4）处理特殊符号，对LINE、FILE等符号用何时的值进行替换可以看到main函数在文件的最底部。 图2.3最底部的main函数 2.4本章小结本章简要介绍了hello.c的预处理过程，分析了hello.i文件，阐述了预处理过程中所进行的操作。 （第2章0.5分） 第3章编译3.1编译的概念与作用编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序，以文本格式描述低级机器语言指令。汇编语言为不同高级语言的不同编译器提供了通用的输出语言。3.2在Ubuntu下编译的命令命令：gcc-Shello.i-ohello.s 图3.1hello.i的编译过程3.3Hello的编译结果解析3.3.1汇编指令 图3.2汇编指令 .file“源文件名”，声明源文件.text定义一个代码段，处理器开始执行代码的地方，代表后面是代码.global定义声明全局变量.data定义初始化数据段.align对齐方式.type指明一个符号的类型（对象类型/函数类型）（typesleepsecs,@object声明sleepsecs是对象类型typemain,@function声明main是函数类型）.size大小.long定义一个长整形，并为它分配空间，占4字节.section.rodata定义只读数据段.string定义一个字符串，并为它分配空间 综上，hello.s文件的第一部分，声明文件名是“hello.c”；数据以4字节方式对齐；声明了一个全局变量sleepsecs，是对象类型的，大小是4字节，类型是Long，数值是2；在只读数据段存放了两个字符串；声明了一个全局变量main，它是函数类型的。3.3.2数据1.全局变量1）程序中定义了一个全局变量sleepsecs，在hello.c文件中，它在main函数前被定义（如图3.3）为int类型，值是2.5 图3.3sleepsecs在hello.c中的定义在hello.s中，它在程序开头，通过.global关键字被定义，并在初始化数据段指明了它的类型、大小和值：对象类型，4字节大小，Long型，值为2 图3.4speepsecs在hello.s中的定义这里需要注意的是，由于整型不能带有小数部分，可以看到，实际上2.5被隐含的强制类型转换取整数值2。2）hello.c中还定义了一个全局变量main，它是函数类型的，被声明在代码段 图3.5hello.s中声明的全局变量main2.局部变量程序中定义了一个局部变量i，初始化后被存储在栈中，地址为-4（%rbp） 图3.6存储在栈中的变量i被赋值为0 3.字符串在hello.c中一共有两个字符串，是作为printf的参数传入的，存储在只读数据段.rodata中 图3.7hello.c中的字符串1 图3.8hello.c中的字符串2 图3.9存储在只读数据段的字符串 图3.10作为printf参数传入的字符串1 图3.11作为printf参数传入的字符串24.函数参数main函数有两个参数，整型变量argc和指针数组argv，都存储在栈中，其中argv包含指向上述两个字符串的指针。 图3.12main函数的两个参数 图3.13存储在栈中的argc 图3.14存储在栈中的两个字符指针5.立即数在汇编代码中，许多立即数出现在指令中 图3.15出现在汇编代码中的立即数（1） 图3.16出现在汇编代码中的立即数（2）3.3.3赋值hello.c中有两个赋值操作，分别是给全局变量sleepsecs赋值为2.5，和给局部变量i赋初值为0。 图3.17给全局变量sleepsecs赋值 图3.18给局部变量i赋初值0在汇编文件hello.s中，给sleepsecs赋值体现在初始化数据段.data中，给i赋值则通过汇编指令movl完成，这里的后缀l表示传送四个字节。 图3.19给sleepsecs赋值 图3.20给局部变量i赋值MOV是一类数据传送指令，按照传送的数据大小和进行的拓展有不同的后缀，具体如下表 图3.21简单的数据传送指令 图3.22零拓展数据传送指令 图3.23符号拓展数据传送指令3.3.4类型转换程序中包含一个隐式类型转换，即给全局变量sleepsecs的赋值，由于sleepsecs被声明的类型是int型，而hello.c程序试图将一个浮点值2.5赋值给它，所以程序进行了隐式类型转换，将2.5的整数值2赋给了sleepsecs，在hello.s汇编文件中可以看出。 图3.24不正确的赋值 图3.25汇编代码给sleepsecs赋值为2 3.3.5算数操作hello.c中只包含一个局部变量i的自加一的算数操作，由汇编指令add实现。 图3.26add指令实现自加一其他的整数算数操作汇编指令如下表： 图3.27整数算数操作 3.3.6关系操作程序中包含两个关系操作：argc！=3和i<10，均由cmpl指令实现，这两个指令同时设置条件码，用于条件跳转。 图3.28两个关系操作 图3.29两个比较指令3.3.7数组/指针/结构操作main函数的参数argv是一个指针数组，argv[0]指向可执行文件的文件名,argv[1]、argv[2]分别指向开始的两个字符串，使argv[1]、argv[2]指向字符串的操作是通过leaq指令将存放字符串的地址放置到指针所指的寄存器来实现的。 图3.30使指针指向寄存器 图3.31将存放字符串的地址存到寄存器里3.3.8控制转移函数中包含两个控制转移：1）if（argc！=3）2）for(i=0;i<10;i++)这两个控制转移根据关系操作中设置的条件码进行条件跳转：1）如果argc=3，跳过if括号里的操作（跳转到L2）。2）如果i<=9,进入for循环（跳转到L4）在汇编代码中的实现如下： 图3.32跳转到L2 图3.33跳转到L43.3.9函数操作程序中涉及多个函数的操作：1）main函数：参数argc、argv2）printf函数3）exit函数：参数14）sleep函数：参数sleepsecs5）getchar函数以hello.c中调用的第一个printf为例：首先第一个字符串被存储在%rdi寄存器里，作为第一个参数，之后通过call指令调用puts函数，第一个参数被传递进来，如果要使用返回值，返回值应当被存储在%rax寄存器中。需要强调的是，在函数调用时，程序会在栈上给被调用者分配空间，保存一些寄存器的值，当函数调用结束时，栈又会恢复到调用之前的状态，并恢复需要恢复的寄存器值。3.4本章小结本章详细的叙述了程序编译过程中编译器所进行的各种操作，并将c语言的数据与操作对应到汇编代码。（第3章2分） 第4章汇编4.1汇编的概念与作用汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成可重定位目标文件的格式，并将结果保存在hello.o中。hello.o是一个二进制文件，包含main函数的指令编码。4.2在Ubuntu下汇编的命令命令：gcc-chello.s-ohello.o 4.3可重定位目标elf格式分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。4.3.0典型的ELF可重定位目标文件的格式（如图4.1）： 图4.1典型的ELF格式ELF头：以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分描述包含帮助链接器语法分析和解释目标文件的信息：ELF头的大小、目标文件的类型、机器类型、节头目表的文件偏移，节头目表中条目的大小和数量。.text：已编译程序的机器代码.rodata：只读数据.data：已初始化的全局和静态C变量.bss：未初始化的全局和静态C变量.symtab：一个符号表，存放在程序中定义和引用的函数和全局变量的信息.rel.text：一个.taxt节中位置的列表，当链接器把这个目标文件和其他的文件组合时，需要修改这些位置。.rel.data：被模块引用或定义的所有全局变量的重定位信息.debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中引用的全局变量，以及原始的C文件.line：原始C源程序中的行号和.text节中机器指令之间的映射.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字节头部表：描述目标文件的节4.3.1ELF头(如图4.2)命令：readelf-hhello.o由图4.2可以看出，这是一个64位ELF文件；数据以2的补码、用小端法表示；是可重定位文件；机器类型X86-64；入口点地址是0；程序头开始地址是0；节头部开始地址是1152字节；ELF头的大小是64字节；节头部的大小是64字节；共有13个节头，节头部的字符串表索引是12。 图4.2用readelf查看的ELF头信息 4.3.2节头部表（图4.3）命令：readelf-Shello.o可重定位目标文件的每个节都从0开始，当在文件头中得到节头部的信息后，将使用节头部表中的偏移量和大小，确定各节在文件中的起始位置及大小。图4.3显式了各个节的信息，包括名字、类型、地址、偏移量、大小、对齐方式、读写权限等。可以看到，代码段不可写，可执行；.data和.bss段可读可写，不可执行；只读数据段不可写、不可执行。 图4.3用readelf查看的节头部表信息4.3.3符号表（如图4.4）命令：readelf-shello.oName是字符串表中的字节偏移，指向符号的以null结尾的字符串名字；value是符号的地址，对于可重定位的模块来说，value是句定义目标的节的起始位置的偏移，对于可执行目标文件来说，该值是一个绝对运行时地址；size是目标的大小（字节）；type指明是数据、函数、对象等；bingding指明是符号是全局的还是本地的；Ndx指示所在节索引数，UND为未定义，ABS为无需重定位。 图4.4用readelf查看的符号表信息4.3.4rel.data(如图4.5)命令：readelf-rhello.o重定位条目的格式：Offset：需要被修改的引用的节偏移Info：包含symbol（前4字节）和type（后4字节）的信息Addend：一个有符号常数，一些类型的重定位要用它对被修改引用的值做偏移调整Symbol：标识被修改引用应该指向的符号Type:重定位类型，告知链接器如何修改新的引用，包括两种最基本的重定位类型：R_X86_64_PC32:重定位一个使用32位PC相对地址的引用。一个PC相对地址就是距程序计数器的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就在指令中编码的32位值加上PC当前运行时值，得到有效地址，PC值通常是下一条指令在内存中的地址。R_X86_64_32:重定位一个使用32位绝对地址的引用，通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。 图4.5用readelf查看的rel.data信息 4.4Hello.o的结果解析hello.o的反汇编结果： 图4.6hello.o的反汇编结果 图4.7hello.s反汇编的过程是反汇编器根据机器代码生成一种类似于汇编代码的格式，在反汇编文件中，左侧列出机器代码，右侧列出与它等价的汇编语言。机器代码与它的反汇编有一些特性：1）X86_64的指令长度从1到15个字节不等，常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用的或者操作数较多的指令所需字节数较多。2）设计指令格式的方式是，从某个给定位值开始，可以将字节唯一地解码成机器指令。3）反汇编器指示基于机器代码文件中的字节序列来确定汇编代码，他不需要访问该程序的源代码或汇编代码。4）反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微差别，它省略了很多指令结尾的大小指示符，但给call和ret添加了q后缀。在分支转移中，反汇编使用的不是段名称，而是确定的地址。在函数调用中，反汇编的call的目标不是函数名称，而是下一条指令。4.5本章小结本章分析了hello.s汇编后得到的可重定位目标文件hello.o，并对可重定位目标文件的各部分进行了分析比较了机器语言与汇编语言的区别。 （第4章1分） 第5章链接5.1链接的概念与作用链接是将各种代码和数据片段收集并组合为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行与编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并运行时；甚至执行于运行时，也就是由应用程序来执行。在现代系统中，链接是由叫做链接器的程序自动执行的。链接器在软件开发中扮演着一个关键的角色，使得分离编译称为可能。5.2在Ubuntu下链接的命令命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1链接生成可执行目标文件的过程5.3可执行目标文件hello的格式典型的可执行目标文件ELF格式如图5.2 图5.2典型的ELF可执行目标文件可执行目标文件的格式类似于可冲定位目标文件的格式。.text、.rodata、。data节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终运行的内存地址以外。.init节定义了一个小函数，叫做_init,程序的初始化代码会用调用它，因为可执行文件是完全链接的（已重定位的），所以它不再需要.rel节 5.3.1ELF头(如图5.3)命令：readelf-hhello由图4.2可以看出，这是一个64位ELF文件；数据以2的补码、用小端法表示；是可执行文件；机器类型X86-64；入口点地址是0x400500；程序头开始地址是64；节头部开始地址是5928字节（指明程序运行时要执行的第一条指令的地址）；ELF头的大小是64字节；节头部的大小是64字节；共有25个节头，节头部的字符串表索引是24。 图5.3用readelf查看的ELF头信息 5.3.2节头部表（图5.4）命令：readelf-Shello图4.3显示了各个节的信息，包括名字、类型、地址、偏移量、大小、对齐方式、读写权限等，根据节头部中的信息可以确定每个节的起始位置和大小。 图5.4用readelf查看的节头部表信息 5.3.3符号表（如图5.5）命令：readelf-shello 图5.5用readelf查看的符号表信息5.4hello的虚拟地址空间hello的虚拟地址为0x400000~0x400ff0 图5.6hello虚拟空间的开始地址 图5.7hello虚拟空间的结束地址利用节头部表中的信息： 图5.8节头部表中信息.init段开始与0x400488,大小为0x017 图5.9.init段信息 .text段开始与0x400500,大小为0x132 图5.10.text段信息.rodata段开始与0x400640,大小为0x008 图5.11.rodata段信息 5.5链接的重定位过程分析 图5.12hello的反汇编hello.out与hello.o的不同：1）hello.out中增加的许多节和在hello.c中用到的函数的汇编代码2）因为可执行文件是完全链接的（已重定位的），所以它不再需要.rel节3）hello.o中用相对偏移表示的地址在hello.out中替换成了虚拟内存地址。 图5.13hello.out重定位过程：1）重定位节和符号定义:在这一步中，链接器将所有相同类型的节合并为同一个类型的新的聚合节，然后，链接器将运行时内存地址赋给新的聚合节，赋给输出模块定义的每个节，体积赋给输出模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。2）重定位节中的符号引用:在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的地址，要执行这一步，链接器依赖于可冲定位目标模块中称为重定位条目的数据结构。 图5.14重定位条目ELF定义了32种不同的重定位类型，其中最基本的两种：R_X86_64_PC32:重定位一个使用32位PC相对地址的引用。一个PC相对地址就是距程序计数器的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就在指令中编码的32位值加上PC当前运行时值，得到有效地址，PC值通常是下一条指令在内存中的地址。R_X86_64_32:重定位一个使用32位绝对地址的引用，通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。 图5.15重定位算法 5.6hello的执行流程ld-2.27.so!_dl_start0x7f8c4587893ld-2.27.so!_dl_init0x7f8c458070c5hello!_start0x400500libc-2.27.so!_libc_start_main0x7f8c45206534-libc-2.27.so!_cxa_atexit0x7f8c452488647-libc-2.27.so!_libc_csu_init0x4005c0libc-2.27.so!_setjmp0x7f8c45248672libc-2.27.so!exit0x7f8c452464255.7Hello的动态链接分析动态链接项目：global_offset表,全局偏移表通过hello信息可以看到，GOT起始表的位置是0x601000 dl_init前： dl_init后： 表中数据变成了相应的偏移量。5.8本章小结本章针对于链接过程，分析了ELF格式的可重定位目标文件、可执行目标文件和动态链接，分析了程序的执行流程。（第5章1分） 第6章hello进程管理6.1进程的概念与作用进程是一个执行中程序的实例，是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。进程给应用程序提供两个关键的抽象：一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器；一个私有的地址空间，他提供一个假象，好像我们的程序独占地使用内存系统。6.2简述壳Shell-bash的作用与处理流程1)shell：Shell是一个连接了用户和Linux内核的应用程序，是一个命令解释器，它通过接受用户输入的Shell命令来启动、暂停、停止程序的运行或对计算机进行控制。2）shell的功能：Shell除了能解释用户输入的命令，将它传递给内核，还可以调用其他程序，给其他程序传递数据或参数，并获取程序的处理结果；在多个程序之间传递数据，把一个程序的输出作为另一个程序的输入，Shell本身也可以被其他程序调用。因为shell可以调用其他程序，所以shell完全能够胜任Linux的日常管理工作，如文本或字符串检索、文件的查找或创建、大规模软件的自动部署、更改系统设置、监控服务器性能、发送报警邮件、抓取网页内容、压缩文件等。我们还可以在shell中编程。2）处理命令行的流程：1．Shell首先从命令行中找出特殊字符（元字符），在将元字符翻译成间隔符号。元字符将命令行划分成小块tokens。Shell中的元字符如下所示：SPACE,TAB,NEWLINE,&,;,(,),<,>,|2．程序块tokens被处理，检查看他们是否是shell中所引用到的关键字。3．当程序块tokens被确定以后，shell根据aliases文件中的列表来检查命令的第一个单词。如果这个单词出现在aliases表中，执行替换操作并且处理过程回到第一步重新分割程序块tokens。4．Shell对~符号进行替换。5．Shell对所有前面带有 符 号 的 变 量 进 行 替 换 。 6 ． S h e l l 将 命 令 行 中 的 内 嵌 命 令 表 达 式 替 换 成 命 令 ； 他 们 一 般 都 采 用 符号的变量进行替换。6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用 符号的变量进行替换。6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用(command)标记法。7．Shell计算采用$(expression)标记的算术表达式。8．Shell将命令字符串重新划分为新的块tokens。这次划分的依据是栏位分割符号，称为IFS。缺省的IFS变量包含有：SPACE,TAB和换行符号。9．Shell执行通配符*?[]的替换。10．shell把所有从处理的结果中用到的注释删除，并且按照下面的顺序实行命令的检查：A.内建的命令B.shell函数（由用户自己定义的）C.可执行的脚本文件（需要寻找文件和PATH路径）11．在执行前的最后一步是初始化所有的输入输出重定向。12．最后，执行命令。 6.3Hello的fork进程创建过程父进程通过调用fork（）函数创建一个新的运行的子进程。新创建的子进程几乎但并不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同（但是独立的）一份副本包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork是，子进程可以读写父进程中代开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。当我们输入执行这个hello程序的命令时，shel解析命令，并调用fork创建一个子进程。6.4Hello的execve过程execve函数在当前进程的上下文中加载并运行hello程序，加载并运行程序需要以下几个步骤：1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。图6.1概括了私有区域的不同映射。3）映射共享区域。如果a.out程序与共享对象(或目标)链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。4）设置程序计数器(PC)。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 图6.1加载器是如何映射用户地址空间的区域的6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。概念：1）进程上下文信息：上下文是由程序正常运行所需的状态组成的，这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。2）进程时间片：一个进程控制它的控制流的一部分的每一时间段。3）用户模式与内核模式：处理器通过控制某个寄存器的一个模式位来切换用户模式与内核模式；执行在内核模式下的进程，可以执行指令集中的任何指令，访问系统中的任何内存模式；用户程序则必须通过调用系统接口间接的访问内核代码和数据。4）调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个之前被抢占了的进程所需的状态，这种决策就叫调度。hello程序开始时运行在用户模式，当它调用sleep函数后，进程进入内核模式。内核处理休眠，将hello进程从运行队列移入等待队列，切换上下文，移交控制给其他进程。hello休眠的计时器到达时间后发送信号给内核，内核执行中断，将hello重新添加进运行队列，继续执行。程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行psjobspstreefgkill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。hello调用getchar时，程序也从用户模式切换成内核模式，接受数据传输，内核移交控制给其他进程，数据传输结束后，内核接受中断信号，切换上下文，移交控制给hello。6.6hello的异常与信号处理可能出现的异常： 图6.2可能出现的异常我们可以通过键盘输入发送中断信号SIGTSTP信号和终止信号SIGINT给进程。1）Ctrl+z发送一个SIGTSTP中断信号给进程，进程挂起但不结束，使用ps仍能看到hello程序，调用fg，将hello调度到前台，hello继续运行，完成后续步骤。 图6.3ctrl+Z的处理2）Ctrl+c发送一个SIGINT信号给进程，默认行为是终止进程，调用ps不再看到hello。 图6.4ctrl+C的处理3）不停乱按：正常运行时不停乱按，输入的字符只是进入缓冲区，非命令的输入都不会得到处理。 图6.5乱按的处理 6.7本章小结本章介绍了进程创建、执行到回收的过程，以hello为例，分析了程序对常见信号的处理。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间1）逻辑地址：CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。对逻辑地址要求，“一个逻辑地址，是由一个段标识符加上一个指定段内相对地址的偏移量，表示为[段标识符：段内偏移量]。对hello程序来说，它是出现在汇编代码中的地址。2）线性地址（虚拟地址）：跟逻辑地址类似，它也是一个不真实的地址，线性地址对应了硬件页式内存的转换前地址3）物理地址：用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。加载到内存地址寄存器中的地址，内存单元的真正地址。在前端总线上传输的内存地址都是物理内存地址，编号从0开始一直到可用物理内存的最高端。这些数字被Nortbridgechip映射到实际的内存条上。物理地址是明确的、最终用在总线上的编号，不必转换，不必分页，也没有特权级检查7.2Intel逻辑地址到线性地址的变换-段式管理逻辑地址由48位组成的，前16位为“段选择符”（段标识符），后32位是段内偏移量。1）段选择符的格式如图： 图7.1段选择符前13位是在（全局/局部）描述符表中的索引；之后一位是TI，如果TI是0，那么前面的索引是在全局描述符表GDT中的索引；如果TI是1，那么前面的索引是在局部描述符表中的索引；最后两位是RPL，它指明段的级别。为00，位于最高级别的内核态。为11，位于最低级别的用户态。2）全局描述符GDT：只有一个，用来存放系统内用来存放系统内每个任务共用的描述符，例如，内核代码段、内核数据段、用户代码段、用户数据段以及TSS（任务状态段）等都属于GDT中描述的段。局部描述符表LDT：存放某任务（即用户进程）专用的描述符3）描述符表存放这段描述符，每个段描述符是8字节：BASE(32位)：段首地址的线性地址。 G：为0代表此段长度以字节为单位，为1代表此段长度以4K为单位。 LIMIT(20位)：此最后一个地址的偏移量，也相当于长度，G=0，段大小在11MB，G=1，段大小为4KB4GB。 S：为0表示是系统段，否则为代码段或数据段。 Type：描述段的类型和存取权限。 DPL：描述符特权级，表示访问这个段CPU要求的最小优先级(保存在cs寄存器的CPL特权级)，当DPL为0时，只有CPL为0才能访问，DPL为3时，CPL为0为3都可以访问这个段。 P：表示此段是否被交换到磁盘，总是置为1，因为linux不会把一个段都交换到磁盘中。 D或B：如果段的LIMIT是32位长，则置1，如果是16位长，置0。(详见intel手册) AVL：A=1已被访问过，A=0未被访问过。（通常A包含在TYPE字段中）4）下面来进行转换：①首先，由段选择符列TI确定在全局还是局部描述符表里查找②然后根据段选择符中的索引确定要选择的表项（段描述符）③应用段选择符的RPL确定的权限④把段描述符中取到的段基地址加到汇编语言中的地址（偏移量）上，形成线性地址7.3Hello的线性地址到物理地址的变换-页式管理概念：1）虚拟页面：虚拟内存被组织为一个有存放在磁盘上的N个连续的字节大小的单元组成的数组，每字节都有一个唯一的虚拟地址，作为到数组的索引。VM系统将虚拟内存分割为称为虚拟页（VP）的固定大小的块。类似的，物理内存也被分割为屋里也（PP）。虚拟页和物理页的大小是相同的。在任意时刻，虚拟页面的集合都分为三个不相交的子集:①未分配的:VM系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。②缓存的:当前已缓存在物理内存中的已分配页。③未缓存的:未缓存在物理内存中的已分配页。2）DRAM缓存作为虚拟内存系统的缓存，在主存中缓存虚拟页。3）页表是一个页表条目（PTE）的数组（如图7.2），虚拟地址空间中的每个页在页表中一个固定的偏移量处都有一个PTE。 图7.2页表每个PTE有一个有效位和一个n位地址字段组成。有效位表明了该虚拟页当前是否被缓存在DRAM中。①如果设置了有效位,那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。（缓存的）②如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。（未分配的）③否则，这个地址就指向该虚拟页在磁盘上的起始位置。（未缓存的）4）缺页异常：访问某个虚拟页时，它的PTE的有效位为0，说明它没有被缓存到物理页，但是物理页已经都有存储的信息了，那么缺页处理程序从物理页中选择一个牺牲页，把现在要访问的这个页存到这个物理页里，如果这个物理页之前被修改过，就把物理页的内容写回内存，否则直接覆盖。下面叙述线性地址翻译成物理地址的过程：一个n位的虚拟地址包含两部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。处理器生成一个虚拟地址，把它传送给MMU，MMU选择VPN对应的PTE，如果有效位是1，那么取出后续的物理页的起始位置，把它和VPO拼接在一起，构成一个物理地址。如果有效位是0，触发缺页异常，处理异常后，重新访问PTE，取出后续物理页的起始地址，与VPO组成物理地址。即以VPO作为偏移量，以物理页起始地址为基址，进行。7.4TLB与四级页表支持下的VA到PA的变换 图7.3如图7.3，虚拟地址是48位的，物理地址是52位的，每个页表的大小是4KB，共四级页表，每级页表以VPN的9位为索引，LITLB是4路16组相联的，L1高速缓存的块大小是64字节。CPU产生一个48位的虚拟地址，MMU将36位VPN的钱32位作为TLBT，后四位作为TLBI，如果在TLB中命中，直接得到PTE，得到四十位物理页起始地址，与12位VPO组合成物理地址；如果TLB不命中，以VPN前9位为第一季页表索引，确定二级页表基址，以此类推，在四级页表中得到四十位PPN，与12为VPO组合得到物理地址。上述过程中，如果PTE有效位为0，引发缺页异常，处理后重新访问PTE。7.5三级Cache支持下的物理内存访问以图7.3的L1d-cache为例，组数是64=26，所以组索引位数是6，每组8行，块大小是64=26字节，所以偏移量也是6位，所以标记位是52-6-6=40位。当有一个52位的物理地址1）首先根据组索引确定LI缓存的组数2）然后把标记位与组里每个行的标记位比较，如果有标记位一致且有效位为1的行，则根据偏移量选择出需要的块。3）如果没有符合条件的行，从下一级存储结构里取出这个块，放到刚才的组里，如果组里有空行，直接放置在空行上；如果组已满，那么采用一种驱逐策略，驱逐一个行，把这个块存进去。7.6hello进程fork时的内存映射当shell为hello程序调用fork函数时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数加载并运行hello程序需要以下几个步骤：1）删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。2）映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。图6.1概括了私有区域的不同映射。3）映射共享区域。如果a.out程序与共享对象(或目标)链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。4）设置程序计数器(PC)。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。图7.4展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。 图7.4缺页前接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图9-7展示了在缺页之后我们的示例页表的状态。 图7.5缺页后7.9动态存储分配管理1）动态内存分配器维护着一个进程的虚拟内存区域，称为堆。假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进城，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块（block）的集合来维护。每个块就是一个连续的虚拟内存片（chunk），要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，知道它显式地被应用所分配。一个已分配的块保持已分配状态，知道它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。内存分配器有两种基本风格：显式分配器要求应用显式地释放任何已分配的块；隐式分配器，要求分配器检测一个已分配的块何时不再被程序所使用，那么就释放这个块。2）带边界标签的隐式空闲链表：分配器将用来区分块边界、区分已分配块和空闲块的数据结构嵌入块本身，在这种情况下，一个块是由一个字的头部、有效载荷，以及一些可能的额外的填充组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐条件，那么块的大小就总是8的倍数，且块的最低3位总是零。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配为）来指明这个块是已分配的还是空闲的。头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。我们将组堆织为一个连续的已分配块和空闲块的序列，称为隐式空闲链表。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。此时需要某种特殊标记的结束块。Knuth提出了一种边界标记技术（如图7.6），允许在常数时间内进行对前面块的合并。这种思想是在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。 图7.6使用边界标记的堆块的格式将空闲链表组织成一个隐式空闲链表，有如图7.7的恒定格式 图7.7隐式空闲链表的恒定格式第一个字是一个双字边界对齐的不使用的填充字。填充后面紧跟着一个特殊的序言块(prologueblock)，这是一个8字节的已分配块，只由一个头部和一个脚部组成。序言块是在初始化时创建的，并且永不释放。在序言块后紧跟的是零个或者多个由malloc或者free调用创建的普通块。堆总是以一个特殊的结尾块(epilogueblock)来结束，这个块是一个大小为零的已分配块，只由一个头部组成。序言块和结尾块是一种消除合并时边界条件的技巧。分配器使用一个单独的私有(static)全局变量(heap_listp)，它总是指向序言块。(作为一个小优化，我们可以让它指向下一个块，而不是这个序言块。)7.10本章小结这一章首先叙述了不同的地址概念和他们之间的转换，由此引出了存储结构、和访存的相关知识，最后又重温了内存映射，复习了动态内存分配的方法策略。（第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件设备管理：unixio接口一个Linux文件就是一个m个字节的序列：B0，B1,…,Bk,…,Bm-1所有的I/О设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。8.2简述UnixIO接口及其函数UnixI/O接口;1）打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。2）Linuxshell创建的每个进程开始时都有三个打开的文件:标准输入(描述符为0)、标准输出(描述符为1)和标准错误(描述符为2)。头文件<unistd.h>定义了常量sTDINFILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。3）改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。4）读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k十n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置é开始，然后更新é。5）关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数：1）open函数：intopen(char*filename,intflags,mode_tmode)返回：若成功则为新文件描述符，若出错则为-1Open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。Flags参数指明了进程打算如何访问这个文件，mode参数指明了新文件的访问权限位。2）close函数：intclose（intfd）返回：若成功则为0，出错则为-1.进程通过调用close函数关闭一个打开的文件。3）read函数ssize_tread(intfd,void*buf,size_tn)read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值一1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。4）write函数ssize_twrite(intfd,constvoid*buf,size_tn)write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。5)lseek函数通过调用了lseek函数，应用程序能够显式地修改当前文件的位置。8.3printf的实现分析Printf函数原型： 图8.1printf函数原型printf函数调用vsprintf函数，这个函数的作用是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出，它返回要打印的字符串长度接着printf函数调用UnixI/O函数write（buf，i），打印出长度为i的buf。 图8.2write函数intINT_VECTOR_SYS_CALL表示要通过系统来调用sys_call这个函数，sys_call函数显示格式化字符串。https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析getchar源码：intgetchar(void){staticcharbuf[BUFSIZ];staticchar*bb=buf;staticintn=0;if(n==0){n=read(0,buf,BUFSIZ);bb=buf;}return(–n>=0)?(unsignedchar)*bb++:EOF;}异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章主要介绍了UnixI/O的概念和相关函数，并以printf和getchar函数为例，展现了UnixI/O函数的应用。（第8章1分）结论用计算机系统的语言，逐条总结hello所经历的过程。1.hello.c:c语言编写的源文件，以ASCII码编码2.hello.i:hello.c经预处理得到的文本文件3.hello.s:hello.i经编译得到的文本文件，包含汇编语言程序4.hello.o:hello.s经汇编得到的可重定位目标文件5.hello:经链接得到的可执行目标文件6.运行：在shell中键入运行命令，1）shell调用fork为hello创建子进程2）shell调用execve加载并执行hello3）hello调用函数，或shell接受信号，shell进行上下文切换，传递控制4）shell为hello动态分配内存5）hello运行结束或接收信号而终止，shell安排父进程回收hello进程，清除相关痕迹。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。计算机系统设计是一个复杂而庞大的工程，系统中一个小程序的运行也是诸多部分共同工作的结果。计算机的设计首先体现了准确性：各种操作清晰明确，每一种操作在当时的情况下都是确定的；其次体现了全面性，计算机系统的设计必须考虑所有可能的情况，避免错误的发生；最后体现了平衡性，计算机系统协调的设计，追求时间、空间与经济上的平衡。 （结论0分，缺失-1分，根据内容酌情加分） 附件（附件0分，缺失-1分）hello.c:c语言编写的源文件，以ASCII码编码hello.i:hello.c经预处理得到的文本文件hello.s:hello.i经编译得到的文本文件，包含汇编语言程序hello.o:hello.s经汇编得到的可重定位目标文件hello:经链接得到的可执行目标文件hello.out:hello的反汇编文件 参考文献为完成本次大作业你翻阅的书籍与网站等[1]预处理阶段所要做的工作_yuer的博客-CSDN博客_预处理阶段有哪些操作https://blog.csdn.net/u010141928/article/details/74200737?ops_request_misc=&request_id=&biz_id=102&utm_term=%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C&utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-1-.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187[2] [2]https://blog.csdn.net/qq_38769551/article/details/100901907?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162441678416780261963856%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162441678416780261963856&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2allbaidu_landing_v2~default-1-100901907.first_rank_v2_pc_rank_v29&utm_term=%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4&spm=1018.2226.3001.4187[3]https://blog.csdn.net/sphone89/article/details/5962699?ops_request_misc=&request_id=&biz_id=102&utm_term=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2&utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-4-.nonecase&spm=1018.2226.3001.4187[4]https://blog.csdn.net/genghaihua/article/details/89450057?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162452282716780261991449%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162452282716780261991449&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2alltop_positive~default-1-89450057.first_rank_v2_pc_rank_v29&utm_term=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80&spm=1018.2226.3001.4187[5]https://blog.csdn.net/Pipcie/article/details/105670156?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162452327216780264020679%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162452327216780264020679&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2allbaidu_landing_v2~default-1-105670156.first_rank_v2_pc_rank_v29&utm_term=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E6%8D%A2&spm=1018.2226.3001.4187[6]https://blog.csdn.net/asdfsadfasdfsa/article/details/98223811?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162452327216780262512185%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162452327216780262512185&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_v2~rank_v29-4-98223811.first_rank_v2_pc_rank_v29&utm_term=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E6%8D%A2&spm=1018.2226.3001.4187 （参考文献0分，缺失-1分） 

刷题心得-Q1最大子列和问题 01-复杂度1最大子列和问题(20分)给定K个整数组成的序列。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{-2,11,-4,13,-5,-2}，其连续子列{11,-4,13}有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下： 数据1：与样例等价，测试基本正确性；数据2：102个随机整数；数据3：103个随机整数；数据4：104个随机整数；数据5：105个随机整数；输入格式:输入第1行给出正整数K(≤100000)；第2行给出K个整数，其间以空格分隔。 输出格式:在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 输入样例:6-211-413-5-2输出样例:20两种巧妙的方法 第一种：采用分治的策略 子列和可以分成三块 左边的最大子列和，右边的最大子列和，从中间开始，包含左边与右边的子列和 那么，按照这种方法，问题的时间复杂度就成为了O(n/2)+O(n/2)+O(N) 就是n*log(n)的规模 #include<stdio.h> #include<stdlib.h> intcom2(intn1,intn2) { if(n1>n2) { returnn1; } else{ returnn2; } } intcom3(intn1,intn2,intn3) { inta=com2(n1,n2); intb=com2(a,n3); returnb; } intslovemax(int*ar,intn,inthead,intlast)//有些细节要严谨注意！！！ { if(head==last) { if(ar[head]<0){ returnar[head];} else { return0; } } intzuo=slovemax(ar,n,head,(last+head)/2); intyou=slovemax(ar,n,((last+head)/2)+1,last); inti,j,k; intzj_zuo=0,zj_you=0,zm=0,ym=0; i=j=(last+head)/2; for(;i>=head;i--) { zj_zuo+=ar[i]; if(zm<zj_zuo) { zm=zj_zuo; } } j++; for(;j<=last;j++) { zj_you+=ar[j]; if(ym<zj_you) { ym=zj_you; } } inttol=zm+ym; intmore1=com3(zm,ym,tol); returncom3(zuo,you,more1); } intmain() { intn; scanf("%d",&n); intar[n]; inti,j,k; for(i=0;i<n;i++) { scanf("%d",&ar[i]); } intmaxsum=0,thissum=0; printf("%d",slovemax(ar,n,0,n-1)); } 第二种方法：线性扫描的方法 从左往右扫描，最大和先初始为零，现在和+=a[i]，如果现在和为负，现在和=0， 每次如果现在和大于最大和，更新 这种方法，保证了在i固定时，最大和一定是前i个元素里面最大的。 #include<stdio.h> #include<stdlib.h> intmain() { intn; intmax=0,tm=0; scanf("%d",&n); inti,j,k,temp; for(i=0;i<n;i++) { scanf("%d",&temp); tm+=temp; if(tm<0) { tm=0; } if(tm>max) { max=tm; } } printf("%d",max); } 

最短路径问题学习心得 最短路径问题（浙大MOOC学习笔记） 单源最短路（时间最短，路程最短，边的个数。。。）：源点固定的 ​无权图 ​有权图 多源最短路：任意两个顶点之间 无权图的单源最短路 就是一次BFS，借助队列，很好实现 当然了，我们需要把BFS里面的Visitied改一下，改为源点到各个点的最短距离dist （初始化：正无穷，负无穷，-1）（与visitied的作用类似） 还有一个细节，我们需要用一个数组path，来存储路径 path存什么？ 前一个顶点！ 我们最后求解结束以后，从V点倒推到原点，利用堆栈，可以很好的实现反向。 伪码如下： voidUnweighted(VertexS) {Enqueue(S,Q); while(!IsEmpty(Q)){ V=Dequeue(Q); for(V的每个邻接点W) if(dist[W]==-1){ dist[W]=dist[V]+1; path[W]=V; Enqueue(W,Q); } } } 这种方法的时间复杂度应该是O（V+E) 有权图的单源最短路 （首先声明：图里面没有负值圈，因为会挂,也暂时没有负边） 与无权图的算法的类似之处：路径的长度是依次递增的。 Dijkstra算法的基本描述 设V为点集，E为带权值的边集，v0为原点，那么，我们进行如下的操作： 每次更新集合V的划分V1，V2（其中V1是已经确定最短距离的点集）V2是待确定的点集 我们要做的：从V2里面取一个与v0距离最短的点p，放到V1里面。 更新所有与p邻接的点的与v0距离（即考虑以p作为中介顶点带来的影响） 若V2为空集，结束 算法细节的简化版证明 最短路径一定仅经过V1里面的顶点pf：如果在V2里面存在顶点m，使得V1-m-p的长度小于V1-p，那么由于路径长度是从小到大递增的，导出m-V1的距离，小于p-V1，m应该在先于p出现在V1里面，矛盾!每次p收到V1里面后，仅对V2里面与p邻接的点进行更新就可以了pf：因为V1里面的点的距离已经是最短了，无需更新，而V2里面的点，由于p的最短距离的确定，会影响与p邻接的顶点与v0的已知最短距离，所以，更新与p邻接的顶点。dist[W]=min(dist[W],dist[p]+<p,W>) 算法的实现细节 V1与V2的划分，我们利用collected数组实现距离的存储我们利用dist数组实现，初始化应该利用正无穷path[W]=V，来存路径。 伪码描述: voidDijkstra(Vertexs) {while(1){ V=未收录顶点中dist最小者; if(这样的V不存在) break; collected[V]=true; for(V的每个邻接点W) if(collected[W]==false) if(dist[V]+E<V,W><dist[W]){ dist[W]=dist[V]+E<V,W>; path[W]=V; } } } 有权图的多源最短路 引入floyd算法 for(i=1;i<=v;i++) { for(j=1;j<=v;j++) {D[i][j]=g[i][j];}//初始化D（-1） } for(k=1;k<=v;k++) { for(i=1;i<=v;i++) { for(j=1;j<=v;j++) { if((D[i][k]+D[k][j])<D[i][j]) { D[i][j]=D[i][k]+D[k][j]; } } } } 其中，如果想要导出路径，我们利用path来解决问题 i-j经过k 所以，找i-j转化为i-k与k-j 问题解决 最后，咱还得那几道题目来检验下自己的水平： 第一题哈利波特的考试 07-图4哈利·波特的考试(25分) 哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。 现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。 输入格式: 输入说明：输入第1行给出两个正整数N(≤100)和M，其中N是考试涉及的动物总数，M是用于直接变形的魔咒条数。为简单起见，我们将动物按1~N编号。随后M行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。 输出格式: 输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。 输入样例: 611 3470 121 5450 2650 5660 1370 4660 3680 51100 2460 5280 输出样例: 470 蛮简单的，直接floyd一遍，找出每行最小，再找出所有的最小 代码见下： #include<iostream> #include<queue> #include<stdio.h> #defineMAXVALUE99999 usingnamespacestd; intg[120][120]; intv,e; voidstart() { cin>>v>>e; inti,j,x,y,value; for(i=0;i<e;i++) { cin>>x>>y>>value; g[x][y]=value; g[y][x]=value; } for(x=1;x<=v;x++) { for(y=1;y<=v;y++) { if(g[x][y]==0) { g[x][y]=MAXVALUE; } } } } voidfloyd() { inti,j,k,n; intD[120][120]; for(i=1;i<=v;i++) { for(j=1;j<=v;j++) {D[i][j]=g[i][j];}//初始化D（-1） } for(k=1;k<=v;k++) { for(i=1;i<=v;i++) { for(j=1;j<=v;j++) { if((D[i][k]+D[k][j])<D[i][j]) { D[i][j]=D[i][k]+D[k][j]; } } } } intanimals[120],tempmax; for(i=1;i<=v;i++) { tempmax=0; for(j=1;j<=v;j++) { if(i!=j) { if(D[i][j]>tempmax) { tempmax=D[i][j]; } } } animals[i]=tempmax; } intminvalue=MAXVALUE,minloca=-1,temp; for(i=1;i<=v;i++) { if(minvalue>animals[i]) { minvalue=animals[i]; minloca=i; } } if(minloca==-1) { cout<<"0"; } else { cout<<minloca<<""<<minvalue; } } intmain() { start(); floyd(); } 练习2旅游规划 （居然一遍编译就AC了，233333） 蛮简单，把正常的Dij算法里面的path变成money，问题就结束了。。。 07-图6旅游规划(25分) 有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。 输入格式: 输入说明：输入数据的第1行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0~(N−1)；M是高速公路的条数；S是出发地的城市编号；D是目的地的城市编号。随后的M行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。 输出格式: 在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。 输入样例: 4503 01120 13230 03410 02220 23120 输出样例: 340 代码如下： #include<iostream> #defineinf9999999 usingnamespacestd; structway { intlenth; intprice; /*data*/ }graph[530][530]; intN,M,S,D; intmoney[530]; intdist[530]; intcollect[530]; voidini() { cin>>N>>M>>S>>D; inti; intx,y,l,p; for(i=0;i<M;i++) { cin>>x>>y>>l>>p; graph[x][y].lenth=l; graph[x][y].price=p; graph[y][x].lenth=l; graph[y][x].price=p; } } intfind_mindist() { inti,tem=inf-5,rem=-1; for(i=0;i<N;i++) { if(dist[i]<tem&&collect[i]==0) { tem=dist[i]; rem=i; } } returnrem; } intmin(inta,intb) { if(a<b) {returna;} else { returnb; } } voidda() { inti,j,k; intp; for(i=0;i<N;i++) { dist[i]=inf; } dist[S]=0; money[S]=0; while(1) { p=find_mindist(); if(p==-1) { break; } else { collect[p]=1; for(i=0;i<N;i++) { if(graph[p][i].lenth!=0&&collect[i]==0) { if((graph[p][i].lenth+dist[p])<dist[i]) { dist[i]=graph[p][i].lenth+dist[p]; money[i]=money[p]+graph[p][i].price; } if((graph[p][i].lenth+dist[p])==dist[i]&&money[i]>(money[p]+graph[p][i].price)) { dist[i]=graph[p][i].lenth+dist[p]; money[i]=money[p]+graph[p][i].price; } } } } } cout<<dist[D]<<""<<money[D]; } intmain() { ini(); da(); } 

归并排序-动手操作练习 归并排序 其实思想不难，体现分治的思想，时间复杂度O(nlogn) 主要是实现起来的细节。 首先是最基础的归并函数 然后是体现递归分治的函数（基准情形：左边下标L，大于等于右下标R时，直接PASS） 最后是函数接口的设计 这里，申请tempa[]数组 体现效率的地方：tempa[]数组只用申请一遍，提高运行效率 实际操作代码见下： #include<iostream> usingnamespacestd; voidmmerge(intL,intR,intRend,inta[],inttempa[])//传入5个参数，利用相邻归并的特性，计算Lend与元素个数 { intlend=R-1; intelements=Rend-L+1; inttemp=L; while(L<=lend&&R<=Rend)//赋值 { if(a[R]<=a[L]){ tempa[temp++]=a[R++]; } else { tempa[temp++]=a[L++]; } } while(L<=lend)//1.基本上就是上个循环里面的，可以省时间CV2.两个while只进行一遍 { tempa[temp++]=a[L++]; } while(R<=Rend) { tempa[temp++]=a[R++]; } for(inti=0;i<elements;i++,Rend--)//利用Rend还没变，从后往前，赋值 { a[Rend]=tempa[Rend]; } } voidmerge_sort(intL,intR,inta[],inttempa[]) { intcenter; if(L<R)//在L<R时才需要处理 { center=(L+R)/2; merge_sort(L,center,a,tempa);//递归左边 merge_sort(center+1,R,a,tempa);//右边 mmerge(L,center+1,R,a,tempa);//合并 } } voidmerge_init(inta[],intn) { int*tempa=newint[n];//如果C，应进行检查是否为空 merge_sort(0,n-1,a,tempa); } intmain() { inti,n; cin>>n; int*a=newint[n]; for(i=0;i<n;i++) { cin>>a[i]; } merge_init(a,n); for(i=0;i<n-1;i++) { cout<<a[i]<<""; }cout<<a[i]; } 

利用Prim算法解决最小生成树 最小生成树 定义：图G的生成子图T，如果满足： （1）是树（去掉任意边，图不联通） （2）边的权值之和最小 则T叫做最小生成树 求解策略：贪心算法 约束：1.只是图里面的边2.正好|V|-1条边3.没有圈 这里，有两种算法 首先介绍Prim-小树长大算法 每次从已经建立好的树外面，找到一个距离现在的树最近的点，然后把它联上树，问题解决。 实现的方式，类似Dijkstra算法的搜索可以将算法的时间复杂度降到O(V*V)的数量级 利用dists[]数组，找一个最近的点，每次更新距离树的距离 例子： 08-图7公路村村通(30分) 现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。 输入格式: 输入数据包括城镇数目正整数N（≤1000）和候选道路数目M（≤3N）；随后的M行对应M条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到N编号。 输出格式: 输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。 输入样例: 615 125 133 147 154 162 234 246 252 266 346 351 361 4510 468 563 输出样例: 12 这题就是求最小生成树的权重，在加边时，进行累加操作就可以了。 我一开始是盲搜最近的边，没有进行优化，结果时间复杂度到了O(v^3),后来发现这不是Prim正统思想。 后来的代码见下： #include<iostream> #defineinf9999999 usingnamespacestd; structway { intprice; /*data*/ }graph[5300][5300]; intN,M; intintree[5300]; intdists[5300]; intcost; voidini() { cin>>N>>M; inti,x,y,c; for(i=1;i<=M;i++) { cin>>x>>y>>c; graph[x][y].price=c; graph[y][x].price=c; } } intnear_by_intree(intn) { inti; for(i=1;i<=N;i++) { if(graph[i][n].price!=0&&intree[i]==0){ return0; } } return1; } intfind_dmin() { inti; intmd=inf-8,loca=-1; for(i=1;i<=N;i++) { if(intree[i]==0&&dists[i]<md) { md=dists[i]; loca=i; } } if(loca==-1) { return-1; } else { cost+=md; returnloca; } } intminer(inta,intb) { if(a>b){ returnb; } else { returna; } } intprim(intstart) { intree[start]=0; intp=start; inti,j,k; for(i=0;i<N+1;i++) { dists[i]=inf; } dists[start]=0; while(1) { p=find_dmin(); if(p==-1) { break; } intree[p]=1; for(i=1;i<=N;i++) { if(graph[i][p].price!=0&&intree[i]==0) { dists[i]=miner(graph[i][p].price,dists[i]); } } } for(i=1;i<=N;i++) { if(intree[i]==0) { cout<<"-1"; return0; } } cout<<cost; } intmain() { ini(); inti,j; intpri[20000]; prim(1); } 

哈尔滨工业大学CSAPP大作业程序人生 计算机系统 大作业 题目程序人生-Hello’sP2P 专业计算学部 学号1190202126 班级1936602 学生李映泽 指导教师刘宏伟 计算机科学与技术学院 2021年6月 摘要 HellowWorld！ 表面上是平平无奇的hello在进行表演，可是它所表演背后的舞台，进程管理，虚拟内存系统，每一个步骤背后的ISA支持，是幕后的英雄。而本文就致力于探究hello一生背后的秘密。 本文通过对一个简简单单的hello程序进行分析，围绕着其全生命流程，展开了分析，从预处理，到编译，汇编，链接成.o文件，再到被加载入内存，成为进程，从进程管理，存储管理，IO管理的角度，对这个程序进行了进一步的探讨。 通过对计算机系统的漫游，从最外面的文本文件，一步一步，到了最底层的硬件实现，和操作系统的配合，使得对计算机系统的理解，更加深入。 **关键词：**汇编；编译；链接；操作系统；虚拟内存；硬件IO **** 目录 -第1章概述-5- 1.1Hello简介-5- 1.2环境与工具-5- 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上-5- 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位-5- 开发与调试工具：gcc，vim，edb，readelf，HexEdit-5- 1.3中间结果-5- 1.4本章小结-5- 。第2章预处理-7- 2.1预处理的概念与作用-7- 2.2在Ubuntu下预处理的命令-7- 2.3Hello的预处理结果解析-7- 2.4本章小结-9- 第3章编译-10- 3.1编译的概念与作用-10- 3.2在Ubuntu下编译的命令-10- 3.3Hello的编译结果解析-11- 数据：-11- 赋值：-13- 类型转换：-14- 算术操作-14- 关系操作：-15- 控制转移：-15- 指针/数组操作-16- 函数操作：-17- 开头：-18- 3.4本章小结-18- 第4章汇编-19- 4.1汇编的概念与作用-19- 4.2在Ubuntu下汇编的命令-19- 4.3可重定位目标elf格式-19- 4.4Hello.o的结果解析-21- 4.5本章小结-22- 第5章链接-23- 5.1链接的概念与作用-23- 5.2在Ubuntu下链接的命令-23- 5.3可执行目标文件hello的格式-24- 5.4hello的虚拟地址空间-25- 5.5链接的重定位过程分析-29- 5.6hello的执行流程-32- 5.7Hello的动态链接分析-33- 5.8本章小结-34- 第6章hello进程管理-35- 6.1进程的概念与作用-35- 6.2简述壳Shell-bash的作用与处理流程-35- 6.3Hello的fork进程创建过程-36- 6.4Hello的execve过程-37- 6.5Hello的进程执行-38- 6.6hello的异常与信号处理-39- 6.7本章小结-44- 第7章hello的存储管理-45- 7.1hello的存储器地址空间-45- 7.2Intel逻辑地址到线性地址的变换-段式管理-46- 7.3Hello的线性地址到物理地址的变换-页式管理-48- 7.4TLB与四级页表支持下的VA到PA的变换-50- 7.5三级Cache支持下的物理内存访问-52- 7.6hello进程fork时的内存映射-53- 7.7hello进程execve时的内存映射-54- 7.8缺页故障与缺页中断处理-54- 7.9动态存储分配管理-55- 7.10本章小结-57- 第8章hello的IO管理-59- 8.1Linux的IO设备管理方法-59- 8.2简述UnixIO接口及其函数-59- 8.3printf的实现分析-60- 8.4getchar的实现分析-62- 8.5本章小结-63- 结论-63- 附件-64- 参考文献-65- 第1章概述 1.1Hello简介 P2P:FromProgramtoProcess从程序到进程 Hello在一开时,仅仅是内存里面的一段程序代码.在Bash里面,OS进程管理通过fork了一个新Process,然后对子进程进行execve,载入装载hello,并分给它时间片,让它得以成为进程. 020:FromZero-0toZero-0从零到零 本来没有Hello,是程序员用手,打出了文本文件,hello.c.然后,通过预处理,编译,汇编,链接,得到了ELF格式hello文件.当我们在Bash里面执行hello的时候,hello被装载进去.最后,执行结束以后,shell的父进程负责回收hello,而内核来删除相关的数据结构.最后,什么也没有留下. 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位 开发与调试工具：gcc，vim，edb，readelf，HexEdit 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 1.4本章小结 介绍了hello的p2p,o2o过程,对hello的一生,进行了大体的定性说明. 罗列了本次实验的基本信息.环境与工具,中间结果. 并对中间结果进行了列表说明. （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 **概念：**预处理器（cpp）根据以字符#开头的命令，修改原始C程序。 例如：#include<stdio.h>将系统头文件里面的内容，直接插入到程序文本里面。得到了另外一个以.i结尾的C语言程序 **作用：**扩展C语言程序设计的环境。插入用#include的环境。同时拓展#define定义的宏。 2.2在Ubuntu下预处理的命令 通过命令： gcc-Ehello.c-ohello.i 进行预处理 对比： 左边是hello.i右边是hello.c 可以发现，在原有的基础上，又增加了许多的系统头文件的内容 2.3Hello的预处理结果解析 在原hello.c里面有，但hello.i里面没有的： 注释内容，在预处理时，已经把程序里面的注释给删了。 在原hello.c里面有，在hello.i里面也有的： 主程序部分。 对比： Hello.iHello.c 在原hello.c里面没有，但在hello.i里面有的： 通过#include插入的一系列运行库的位置 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WAXrMasl-1624784252313)(media/9cbadafa0a6ba334cf333eed7fac3b95.png)] 一些定义的结构体 还有一些定义的变量 和一些外部函数的名字 2.4本章小结 本章通过介绍预处理阶段的概念以及在C语言程序中的作用 并在Linus环境里面对hello.c程序进行了预处理 初步探究了预处理的执行情况。 并对预处理的结果进行了解析 第3章编译 3.1编译的概念与作用 **概念：**编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。每条语句都是以文本形式描述的低级机器指令 **作用：**为高级语言的不同编译器提供了通用的输出语言。例如：C编译器与Fortran编译器产生的输出文件用的是同样的，依赖于自己CPU的语言。 3.2在Ubuntu下编译的命令 首先：于键盘里面，按下： gcc-Shello.i-ohello.s 然后打开编译完成的文本文件 3.3Hello的编译结果解析 数据： 通过观察C语言程序，发现其中存在如下变量 sleepsecs 这个变量是全局变量，于main函数外部声明。 argc/argv 这个变量，是局部的，而且是调用main函数里面进行传入的参数。在IA64里面，它存放在rdi里面。 对main函数的汇编代码进行分析。 Hello.sHello.c | | 在汇编的代码中，是将这个数据一开始放于寄存器rdi里面，然后，调用main函数的。 然后再进入main后，又将其放入堆栈里面进行保存。 再在后面如果是要使用到rdi与rsi时，均是从堆栈里面调数据 i i作为hello.c里面的局部变量，在main里面的循环中出现。 观察汇编代码发现，i在堆栈里面出现，并作为每次循环都进行更新的变量。 这种风格的汇编代码，每次都需要将变量放到栈里面进行读写，性能上，并不占优势。于是我开了O2优化 开O2优化以后 观察： 发现在开启优化后，程序将i就保存与%ebx里面。而不是存于栈中，减小了内存的读取。 赋值： 观察C语言程序，赋值出现了两次。 首先是全局变量的赋值： 在汇编里面观察,发现 即赋初值的全局变量为在程序运行前便已经赋值了的. 然后是局部变量的赋值. 在这里,i被初始化为0 观察相应汇编代码里面的: 即,局部变量于运行时对变量进行赋初值.行为与程序里面保持一致 同时,看其对应的汇编代码: 是movl,即是对32位的数据进行移动,正好对应int的四字节的要求 类型转换： 全局变量sleepsecs的类型转换 在C代码里面时int/赋值时float/最后在汇编的结果时long 注意，它是int，不过却是赋值2.5. 我们看看汇编代码里面是如何处理的。 编译器将这个变量已经转变成2了 在用到sleepsecs的时候， 不难发现，这个转换是隐式转换。自动将2.5转换为了2，而且，类型由int转为了long 算术操作 C语言里面的++ 注意到循环里面的i++ 于是在汇编里面寻找对应 即正好对应在里面的值进行加1 注意到i是int类型,所以是进行32位的加法,即位addl 关系操作： 在程序里面存在两处关系操作,第一处是if条件里面的!=3判断 第二处是在循环里面的边界的判定 对应到汇编里面,其对应的语句就是: 与 对应的cmpl正是32位的比较, 控制转移： 在C代码里面有if与while语句,下面对其展开分析 针对C里面的if语句: C汇编 这种汇编的转换于CSAPP课本P143页里面提及. 针对C里面的while语句: C汇编 这个for循环是采用先赋初值,然后采用Jumptomiddle策略改变的循环结构 将汇编代码改写为等价含义的C语言代码: C由汇编转换后的C 指针/数组操作 程序对传入的argv数组进行了引用. argv数组是一个指针数组,即数组里面装的是指针 程序引用了argv[1]与argv[2] 和字符串一起,作为printf的三个参数,藏在for循环里面 下面进行分析: 首先在汇编代码里面定位到printf引用的这三个参数 引用的流程如下: 将数组的基地址取出=>对基地址进行计算偏移量=>取出内存里面的相应值 即最后一步其实是以argv[2]里面的内容为地址去访问内存.等价于*(argv[2]) 函数操作： main函数里面一共调用了4个函数:printf/exit/sleep/getchar 下面依次进行分析: 注意:这里所有的函数后缀都有@PLT这是动态链接的内容,我们将在链接章节里面介绍这两个函数! printf 引用了两次.第一次是仅仅输出字符串,第二次是含参数的格式化输出. 第一处的printf 观察汇编代码,不难发现,第一处的输出字符串是被替换为了puts@PLT 这里面隐藏着gcc编译器的默认优化,即,如果只是输出一组字符串+\n的话,会被默认优化为puts()指令 同时,看看传入的参数,不难发现,即这个rdi里面存的是.LC0,.LC0里面装的正好就是字符串.“Usage:Hello学号姓名！\n” 有关更细致的分析,将在下一章里面继续说明 exit main函数是将1传给rdi里面后就直接调用exit@PLT了 sleep函数: 也是将参数传给rdi以后直接调用 getchar 开头： 注意： 这里，已经在头部对这个.s文件进行了一定的说明。 .file:说明文件名字为从hello.c编译而来 .text代码段 .globl全局变量：说明sleepsecs是全局变量 .data数据段 .align对齐方式，.align4说明是按四个字节对齐 .typesleepsec，说明这个变量是对象类型 .size大小，说明这个变量占用的大小为4字节 .long说明sleepsec的类型是long .section说明sleepsecs的节在于只读数据段 .LC0与.LC1说明这是两个字符串，最后是需要被连接器进行重定位的。 最后是对main函数的定义： Main函数在.text段里面，main是全局符号，然后它的type是function即函数 本章小结 本章具体讨论编译. 对编译的概念与作用,Ubuntu下编译的命令,Hello的编译结果解析进行了分析说明 其中,对Hello的编译结果同C语言里面的数据/变量赋值(局部/全局)/类型转换/算术操作/关系操作/控制转移/指针数组操作/函数操作进行了细致的探讨 第4章汇编 4.1汇编的概念与作用 **概念:**将.s文件翻译成机器语言指令,并将这些指令打包成可重定位目标程序的格式.将结果保存到.o文件里面 **作用:**将给人看的汇编文本文件,翻译成给机器看的二进制代码. 4.2在Ubuntu下汇编的命令 命令: ashello.s-ohello.o 生成了hello.o文件 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 通过readelf-a命令进行查看: ELF头 节头部表: 描述了每一节的名字/大小,类型/条目size,地址/标志/链接/信息,偏移量/对齐方式, 文件里面没有动态节/程序头/节组 重定位节 注意到这些重定位的有些是静态链接,有些是动态链接.如R_X86_64PC32的是静态链接内容/而PLT_32则为动态链接内容. 还有一个与重定位有关的:.rela.eh_frame .rela.eh_frame eh_frame即exceptionhandleframe即异常处理框架 就是说,这是与重定位相关的一个异常处理单元 最后是符号表 它有18个条目 4.4Hello.o的结果解析 （以下格式自行编排，编辑时删除） objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。 对比示意:左方为.o文件反汇编的结果.右方为.s 注意到基本的逻辑并没有改变,但是发现 1原来的十进制数已经被翻译成了16进制数. 2原来引用的一些全局变量,已经由<符号>(%rip)变成了0x0(%rip),原来的符号蕴含的重定位信息被放到了表里面.(右方的信息是Objdump自己给我们辅助生成的) 3.原来引用的一些函数,也是由<符号>(%rip)变成了0x0(%rip),原来的符号蕴含的重定位信息被放到了表里面.(右方的信息是Objdump自己给我们辅助生成的) 控制跳转指令的跳转位置,从jmp符号直接被转换为jmp指令族,其后方的二进制数代表了相对位置 4.5本章小结 本章讨论汇编 对汇编的概念与作用/在Ubuntu下汇编的命令/可重定位目标elf格式/Hello.o的结果解析进行了分析与阐述 并探究了hello.o文件的Objdump与之前原来汇编格式之间的差异 第5章链接 5.1链接的概念与作用 概念*:链接时将各种代码和数据片段收集并组合成为一个单一文件的过程.这个文件可以被加载到内存里面执行.* **作用:**在软件开发里面扮演着重要角色,使分离编译成为可能. 5.2在Ubuntu下链接的命令 第一种方法: 指令:ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 第二种方法:直接使用gcc进行操作 指令:gcchello.o-ohello 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 使用readelf进行分析,输入: readelf-ahello>hello_2_elf 进行对ELF文件进行查看: 如图,其各段的基本信息，如起始地址，大小等信息等,已被罗列如上. 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 首先,打开edb并加载程序文件 下面,开始查看hello的虚拟空间各个段的信息. 我们将对照之前笔者画的图片,挨个进行分析. 这个,是X86-64的虚拟空间示意图 我们利用edb的内存区域选项进行对内存区域的查看 两图一项一项的进行对照 在Memregions里面最下面一行的权限是只读区域,而且是不能执行的 我们对其进行dump 发现这个就是ELF的头！ 其内容，是和我们之前readelf读的是一致的 往上，是权限是r-x权限的内存区域，即这个区域是可以执行的。 正好与我们在EDB里面看到的指令装载的地址一致 在往上看,权限是只读的。我们对其进行分析： 对之进行dump后发现这个区域是只读数据域，保存了我们代码里面的如字符串之类的数据 继续往上，发现权限是可读可写，这个是运行时堆，运行时，由malloc进行管理这部分内存的分配 往上，内存地址发生了较大变化，一共有三段，MemoryRegions指示我们，这个区域是共享库的区域。 再最后往上，到了我们的用户栈 不难发现，这个用户栈的结构，和书中一致，即返回地址，以及其上面的环境变量 最上面的是内核区域，我们没有办法访问。 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 1)首先使用objdump-d-rhello指令，生成对hello的反汇编文件 2)然后如图，进行对比 不难发现，左图中的hello.o文件里面只有一个函数即main函数，而右方的对hello进行反汇编的结果里面有一整套的函数。比如：.init段的_init函数 含汇编代码的段增多 从原来的只有的.text段，扩增为了不仅有.text段，也有.init段、.plt段、.fini段等等。 .text段的内容增多了。 左右均是.text段的内容，不过左方的.text段只有main函数，右方的.text段不仅包含.main，更包含main函数的很多入口函数，如_start之类。 增加了外部的共享库函数 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 为了分析重定位，我们采用-no-pie指令对hello.c进行重新编译。 我们以原来在main函数中的第一条需要重定位的代码为例展开分析： 重定位PC相对引用 它在elf文件里面的信息是： 这个条目r的类型是R_X86_64_PC32的类型 条目信息：r.offset=0x1cr.symbol=.rodatar.type=R_X86_64_PC32r.addend=-4 下面开始对重定位的refptr进行计算： 通过链接器的计算，其已经确定如下信息： 在hello里面其.rodata的地址为：0x402000 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627172643714.png) 而main函数的地址是：0x4011b6 需要引用的字符串的地址Addr(r.symbol)=0x402004 调用CSAPP第三版第480页的重定位算法，进行计算： 计算过程：refaddr=Addr(s)+r.offset=0x4011b6+0x1c=0x4011d2*refptr=(unsigned)(Addr(r.symbol)+r.addend-refaddr)=(unsigned)(0x402004+(-4)-0x4011d2)=0xe2e 这个重定位计算得来的信息，正好与汇编代码里面的一致！ 在得到的可执行目标文件里面，lea指令有着如下的形式： 以上，便是链接器对代码里面的条目进行重定位的过程 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 打开edb载入hello ** ** 列出所有过程： 输入: ./hello1190202126李映泽 子程序名程序地址（16进制）ld-2.27.so_dl_start7efbff4d8ea0ld-2.27.so_dl_init7efbff4e7630hello_start400500libc-2.27.so__libc_start_main7efbff100ab0Hello_printf@plt（调用了10次）4004c0Hello_sleep@plt（调用了10次）4004f0hello!getchar@plt4004d0libc-2.27.so!exit7efbff122120 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 关于PLT与GOT表的介绍:对于动态共享链接库中PIC函数，编译器没有办法预测函数的运行时地址，所以需要为其添加重定位记录，并等待动态链接器处理。为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT和全局偏移量表GOT实现函数的动态链接。其中GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。 dl_init前后变化 在dl_init之前 利用gdb来进行打印内存地址内容: 在dl_init之后, 发现内容已经不同比如说 puts@got.plt函数的地址,已经在dl_init之后,被改写了 进入这个地址 0x7ffff7e475a0 发现,是_GI_IO_PUTS函数 5.8本章小结 本章讨论链接 对链接的概念与作用在Ubuntu下链接的命令可执行目标文件hello的格式hello的虚拟地址空间链接的重定位过程/执行流程展开了分析 根据X86-64的虚拟地址空间模型,以hello为例,一一进行了对照比较分析. 同时,根据CSAPP书中所述的重定位算法,对链接的重定位过程进行了分析 并使用gdb作为工具,对hello的执行流程/动态链接过程进行了分析 第6章hello进程管理 6.1进程的概念与作用 **概念:**进程是一个执行中程序的实例. 进程定义： 狭义定义：进程是正在运行的程序的实例（aninstanceofacomputerprogramthatisbeingexecuted）。 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元 进程作用： （以下内容节选自CSAPPP508） 1）进程为用户提供了以下假象： 我们的程序好像是系统中当前运行的唯一程序一样，我们的程序好像是独占的使用处理器和内存，处理器好像是无间断的执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。 2）方便shell程序的构造 每次用户通过向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。 3）两个关键抽象 进程提供给应用程序两个关键抽象：一个独立的逻辑控制流；一个私有的地址空间。 6.2简述壳Shell-bash的作用与处理流程 （以下格式自行编排，编辑时删除） Shell的概念: shell是一个交互型应用级程序，代表用户运行其他程序。是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。 Shell的功能: 它代表用户运行其他程序.接收用户输入的命令并把它送入内核去执行。.实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。 处理流程: shell首先检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux本身的实用程序，如ls和rm，也可以是购买的商业程序，如xv，或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能够成功找到命令，该内部命令或应用程序将被分解为系统调用并传给Linux内核。 6.3Hello的fork进程创建过程 运行中的进程可以通过fork()函数创建子进程。 fork()函数简介：#include<sys/types.h>#include<unistd.h>pid_tfork(void);//返回:子进程返回0;父进程返回子进程的PID如果出错,返回-1 对于我们打开的shell而言： 首先读入我们敲入的命令行 将串”./hello1190202126李映泽”读入，作为一组参数。 对串进行解析 串被分割为**./hello与1190202126与李映泽**三个子串 读取第一个参数： 发现**./hello并不是内置参数，于是fork一个子进程，子进程去execvehello命令，带上参数：”./hello1190202126李映泽**” 进程图： 6.4Hello的execve过程 Shell产生的子进程利用的是execve函数进行对新程序的加载与运行。 execve函数在当前调用的进程的上下文里面加载并运行一个程序。 exceve函数的说明#include<unistd.h>intexecve(constchar*filename,constchar*argv[]constchar*envp[]);//如果加载成功,那么不返回,如果错误,返回-1//这个函数加载并运行可执行目标文件filename//且带参数列表argv与环境变量envp//只有出现错误，才返回-1；//否则不会返回 在加载了hello以后，通过调用启动代码，设置完成启动栈的结构，并转移控制权给main函数 如图：新程序开始后，用户栈的典型结构如下： 6.5Hello的进程执行 （以下格式自行编排，编辑时删除） 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 **进程时间片：**分时操作系统分配给每个正在运行的进程微观上的一段CPU时间。或者说，一个进程执行它的控制流的一部分的每一时间段。 **进程上下文信息：**进程执行活动全过程的静态描述。为内核重新启动一个被抢占的进程所需要的状态。由如：通用目的寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈以及各类内核数据结构组成。 **调度：**在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被强占的进程。这种决策就叫调度（是由内核中的调度器的代码处理的） *进程调度的过程：*上下文切换 保存当前进程的上下文恢复某个之前被抢占的进程的上下文将控制转移给这个新恢复的进程 用户态与核心态的转换： 即用户模式切换到内核模式 Hello一开始是运行在用户模式里面，在调用sleep、exit函数时，通过陷阱异常，实现syscall，将控制权给内核开始系统调用。在执行结束以后，控制权转移给main的用户模式。 6.6hello的异常与信号处理 （以下格式自行编排，编辑时删除） hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 hello执行中出现的异常: 中断*:接收到来自处理器外部的I/O设备的信号.* 比如:我们在键盘里面敲入CtrlC/Z.,使得在处理器执行时,中断引脚的电压变高了…在处理完当前指令后,控制转移给处理程序;中断处理程序进行执行.执行结束后,返回到下一条指令. 陷阱*:有意的异常.例如为了进行系统调用.* 在hello的执行过程中,需要调用系统函数来进行一系列的操作:如printf进行的显示屏输出/sleep的睡眠/exit进行退出等等.这些系统调用,均要进行syscall,即陷阱,从用户模式转内核模式 hello执行中处理的信号: SIGINT,SIGSTP,SIGCONT,SIGWINCH 信号处理演示: Ctrl-Z Ctrl-C(中断) |在ctrl-z以后的ps||****||按下fg,在前台进行||||kill-9PID(杀死进程)||||杀死后ps||||pstree|| 将输出重定向至文本文件里面 ||kill-19与kill-18的组合||首先将进程进行挂起: -19sigstop将进程进行停止 -18SIGCONT将进程继续 | 说明: 按下键盘的时候: 中断异常示例: 引发了中断异常.如图: 而当程序在进行显示屏输出的时候: 引发的是陷阱: 通过陷阱,调用系统函数.将字符串打印到屏幕上面 信号处理: 对于kill-98810: 直接将SIGKILL发送到8810进程,使其直接终止. 对于CTRLC/Z 将SIGINT/SIGSTP由内核发送到8810号进程.SIGINT直接终止8810.而SIGSTP将8810号进程进行停止与挂起. 6.7本章小结 本章讨论hello的进程管理 对进程的概念与作用壳Shell-bash的作用与处理流程Hello的fork进程创建过程/execve过程/的进程执行/异常与信号处理 进行深入的探讨,并以图示的方式展开了说明 第7章hello的存储管理 7.1hello的存储器地址空间 （以下格式自行编排，编辑时删除） 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 逻辑地址:段内偏移地址.程序产生的和段相关的偏移地址部分.也就是hello在“段基址+段内偏移地址”访问模式下的段内偏移地址. 线性地址:是逻辑地址到物理地址变换之间的中间层。逻辑地址是段里面的偏移地址,加上生成的段的基地址就是线性地址.在执行hello时,我们位于保护模式下,于是我们的段基址寄存器通过段选择子在GDT里面找到真正的段基址,加上段内偏移地址,作为一个整体,这个地址叫做线性地址. **虚拟地址:**如果开启分页,那么线性地址将作为虚拟地址,给CPU,通过查找页表,找到对应的物理地址.以hello为例,由于我们是在保护模式下,我们的虚拟地址就是和线性地址一样,其示例正如下图所示: **物理地址:**是内存单元的绝对地址,也是存储管理的终点.由CPU发出的地址最终会被转化为物理地址.结合hello为例:就是最后hello在内存里面存的地址 7.2Intel逻辑地址到线性地址的变换-段式管理 （以下格式自行编排，编辑时删除） 段式管理:把一个程序分成若干个段（segment）进行存储，每个段都是一个逻辑实体（logicalentity），程序员需要知道并使用它。它的产生是与程序的模块化直接有关的。段式管理是通过段表进行的，它包括段号或段名、段起点、装入位、段的长度等。此外还需要主存占用区域表、主存可用区域表。 通俗的说:这个变换,就是将逻辑地址,映射到线性地址. **逻辑地址=**段标识符+段内偏移量 段内偏移量,是保持不变的.直接送到最后的加法器,用于合成线性地址 段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图： 索引号,是在**”段描述符表”**的索引. 段描述表,可以细分为全局段描述符表(GDT)与局部段描述符表(LDT) 这两者的寻找的切换,是由上图的TI即表指示器进行决定的. (Intel设计的本意是，一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。) 通过在段描述符表里面进行索引寻找,它可以寻找到段描述符(segmentdescriptor) 这个段描述符描述了一个段，由8个字节组成，如下图： 我们只关心BASE段,即描述了一个段的开始位置的线性地址.它与之前逻辑地址里面的offset偏移量加加在一起,就成了线性地址. 故大体流程如下: 段式管理对逻辑地址进行分割成:段选择符+Offset看段选择符的TI,如果是0,那么切换到GDT,如果是1,那么切换到LDT利用段选择符里面的索引号在相应的表里面进行取出段描述符对段描述符里面的Base进行取出线性地址<=Base+Offset 7.3Hello的线性地址到物理地址的变换-页式管理 由于我们开启了分页,所以,Hello将进行由线性地址->物理地址的变换 首先引入页的概念: 页:将N个连续字节的数组,成为页 页可分为虚拟页(PP)与物理页(PP) 如果不考虑多级页表等更加精细的机制,我们的地址映射将是这样进行的. 线性地址,即虚拟地址. 被分成了两部分 线性地址=VPN(虚拟页号)+VPO(虚拟页偏移量) 虚拟页号是一个索引,在当前进程的CR3寄存器指向当前的页表里面寻找虚拟页,并把里面存的物理页号PPN返回与物理页偏移量PPO一道,进行返回. 即 物理地址=PPN(物理页号)+PPO(物理页偏移量) 7.4TLB与四级页表支持下的VA到PA的变换 （以下格式自行编排，编辑时删除） TLB支持下的VA到PA的变换 目的:利用局部性原理,加快地址翻译速度. TLB:翻译后备缓冲器(TranslationLookasideBuffer,TLB)为了加速地址翻译 它就是一个Cache 具有以下特性: ▪MMU中一个小的具有高相联度的集合 ▪实现虚拟页号向物理页号的映射 ▪页数很少的页表可以完全放在TLB中 如果缓存了的话,那么TLB可以直接将VPN映射到PTE,以上步骤都是在CPU内部的MMU单元完成的,极快! 四级页表支持下的VA到PA的变换 目的:利用多级页表,降低内存占用. 如果我们的页面大小4KB,48位地址空间,8字节的PTE,那么,我们的页表占用的空间至少应该是: 2^48*8/4KB=2^(48+3-12)=2^39Byte 即我们需要512G的页表,这显然不现实,我们发现,其实有很多页,我们并没有用上,于是,可以直接索性不放入PTE里面,采用多级页表的处理思路. 以4级页表为例: **大致流程:**由CR3寄存器指向L1的PT,然后由VPN1作为索引,进行寻找,找到PTE以后,以PTE条目里面的Base作为基址,再以VPN2作为索引,重复上述操作,直到找到L4的PT里面的PTE,以这个作为PPN,并上PPO,作为虚拟地址. Corei71-3级页表条目格式每个条目引用一个4KB子页表:P:子页表在物理内存中(1)不在(0)R/W:对于所有可访问页，只读或者读写访问权限U/S:对于所有可访问页，用户user或超级用户supervisor(内核)模式访问权限WT:子页表的直写或写回缓存策略A:引用位(由MMU在写时设置，由软件清除)PS:页大小为4KB或4MB(只对第一层PTE定义)页表物理基地址:子页表物理基地址的最高40位(强制物理页表4KB对齐)XD:能/不能从这个PTE可访问的所有页中取指令Corei7第4级页表条目格式每个条目引用一个4KB的页:P:子页表在物理内存中(1)不在(0)R/W:对于所有可访问页，只读或者读写访问权限U/S:对于所有可访问页，用户或超级用户(内核)模式访问权限WT:子页表的直写或写回缓存策略SD：能/不能缓存(Cachedisabledorenabled)A:引用位(由MMU在读或写时设置，由软件清除)D:修改位(Dirtybit,由MMU在写时设置，由软件清除)页表物理基地址:物理页基地址的最高40位(强制物理页4KB对齐)XD:能/不能从这个PTE可访问的所有页中取指令 7.5三级Cache支持下的物理内存访问 以Corei7为例 对于给定的物理地址PA,首先在L1里面进行寻找. (1)将PA分割成CTCICO CI是组号,定位了应该出现的组,CO是offset定位了偏移量.CT是tag即标识的tag. (2)对本层的Cache进行寻找 硬件会定位到CI的组(组索引),然后对组里面的每一行,(L1里面有8行)进行比较tag,如果tag相同且有效,那么找到了 (3)如果找到,那么直接返回数据 (4)如果找不到,那么就会到L2里面进行寻找,重复上述操作直到找到为止. (5)更新时,如果存在空闲的(有效0),那么直接替换,如果没有,根据LRU策略,找一个块进行驱逐. 7.6hello进程fork时的内存映射 （以下格式自行编排， 为新进程创建虚拟内存 ▪创建当前进程的mm_struct、vm_area_struct和页表的原样副本。 ▪两个进程中的每个页面都标记为只读 ▪两个进程中的每个区域结构(vm_area_struct)都标记为私有的写时复制(COW) 在新进程中返回时，新进程拥有与调用fork的父进程相同的虚拟内存 随后的写操作通过写时复制机制创建新页面 7.7hello进程execve时的内存映射 execve函数进行了以下步骤: 删除已存在的用户区域 删除当前进程虚拟地址的用户部分中已存在的内存区域 映射私有区域 将目标文件hello的代码和初始化的数据映射到.text和.data区 同时,将.bss和栈映射到匿名文件 映射共享区域: 将libc.so等内容映射到共享库里面的映射区域. 设置PC,指向代码区域的入口点 7.8缺页故障与缺页中断处理 1)处理器生成一个虚拟地址，并将其传送给MMU 2)MMU生成PTE地址(PTEA)，并从高速缓存/主存请求得到PTE 3)高速缓存/主存向MMU返回PTE 4)PTE的有效位为零,因此MMU触发缺页异常 5)缺页处理程序确定物理内存中的牺牲页(若页面被修改，则换出到磁盘 写回策略) 6)缺页处理程序调入新的页面，并更新内存中的PTE 7)缺页处理程序返回到原来进程，再次执行导致缺页的指令 7.9动态存储分配管理 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 **动态内存管理:**需要维护着进程的一个虚拟内存区域，称为堆. 我们这里的管理,用到的时malloc,这个是显示分配器,即要求应用显式地释放任何已分配的块 约束条件: ▪可以处理任意的分配(malloc)和释放(free)请求序列 ▪只能释放已分配的块,无法控制分配块的数量或大小 ▪立即响应malloc请求 ▪不允许分配器重新排列或者缓冲请求 ▪必须从空闲内存中分配块 ▪必须对齐块，使它们可以保存任何类型的数据对象 ▪在Linux上：8字节(x86)or16字节(x86-64)对齐 ▪只能操作或改变空闲块 ▪一旦块被分配，就不允许修改或移动它了 目标:最大化吞吐量，最大化内存利用率 基本方法与策略: 隐式空闲链表(Implicitlist) 通过头部中的大小字段隐含地连接空闲块 通过这些形式已经组织好了的块,进行连接在一起,维护了空闲块的结构 阴影:已分配块 空白:空闲块 头:大小/分配位 显式空闲链表(Explicitlist) 在空闲块中使用指针连接空闲块 实例: 分离的空闲列表(Segregatedfreelist) 空闲块按尺寸size分类/组，每个类/组使用一个空闲链表。 当分配器需要一个大小为n的块时: ▪搜索相应的空闲链表，其大小要满足m>n ▪如果找到了合适的块: ▪拆分块，并将剩余部分插入到适当的可选列表中 ▪如果找不到合适的块,就搜索下一个更大的大小类的空闲 链表 ▪直到找到为止。 如果空闲链表中没有合适的块: ▪向操作系统请求额外的堆内存(使用sbrk()) ▪从这个新的堆内存中分配出n字节 ▪将剩余部分放置在适当的大小类中 7.10本章小结 本章讨论hello的存储管理. 讨论了由硬件与操作系统支持的线性地址空间/虚拟地址空间/物理地址空间/逻辑地址空间之间的转化.对hello的存储器地址空间,进行了分析. 基于IntelCorei7,对/Hello的线性地址到物理地址的变换-页式管理/Intel逻辑地址到线性地址的变换-段式管理/TLB与四级页表支持下的VA到PA的变换/三级Cache支持下的物理内存访问进行了说明 同时,基于虚拟内存的概念,对hello进程fork时的内存映射/进程execve时的内存映射/缺页故障与缺页中断处理/动态存储分配管理等内容进行了分析说明 第8章hello的IO管理 8.1Linux的IO设备管理方法 （以下格式自行编排，编辑时删除） 设备的模型化：文件 一个Linux文件就是一个m字节的序列: B0,B1,…,Bk,…,Bm-1 设备管理：unixio接口 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O: 8.2简述UnixIO接口及其函数 （以下格式自行编排，编辑时删除） 接口描述如下： 打开文件：应用程序请求内核打开相应的文件，宣告其想要访问IO设备 对应的函数： 改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k。 应用程序执行seek操作，显示设置文件的当前位置为k。 读写文件：一个读操作是从文件里面复制n>0个字节到内存里面。从当前文件位置k开始，增加k到k+n。给定大小m文件，k>=m时，触发EOF条件，然后应用程序检测到。类似，写操作是从内存里面复制n>0字节到文件里面，从当前文件位置k开始，然后更新k。 关闭文件：应用程序完成了文件访问以后，通知内核来关闭文件。 打开文件的函数：#include<sys/types.h>#include<sys/stat.h>#include<fcntl.h>intopen(char*filename,intflags,mode_tmode); 关闭文件的函数#include<unistd.h>intclose(intfd); 读写文件函数#include<unistd.h>//读文件函数ssize_tread(intfd,void*buf,size_tn);//写文件函数ssize_twrite(intfd,constvoid*buf,size_tn); 8.3printf的实现分析 （以下格式自行编排，编辑时删除） https://www.cnblogs.com/pianist/p/3315801.html 首先观察printf的函数体： printf函数体：intprintf(constchar*fmt,…){inti;charbuf[256];va_listarg=(va_list)((char*)(&fmt)+4);i=vsprintf(buf,fmt,arg);write(buf,i);returni;} 其中，调用了函数vsprrintf与write vsprintf生成显示信息: vsprintfintvsprintf(char*buf,constchar*fmt,va_listargs){char*p;chartmp[256];va_listp_next_arg=args;for(p=buf;*fmt;fmt++){if(*fmt!=‘%’){*p++=*fmt;continue;}fmt++;//将fmt字符串拷贝到buf缓冲里面,直到出现格式化串switch(*fmt)//出现格式化串,针对不同的串,进行相应的操作{case‘x’:itoa(tmp,*((int*)p_next_arg));strcpy(p,tmp);p_next_arg+=4;p+=strlen(tmp);break;case‘s’:break;default:break;}}return(p-buf);} 经过分析可知： vsprintf是一个系统函数 vsprintf返回的是一个要打印的字符串的长度 通过接受确定输出格式的格式化字符串，对参数进行格式化，输出到格式化buf里面，然后将buf传给write，利用write进行输出 write系统函数 write1.write:2.moveax,_NR_write3.movebx,[esp+4]4.movecx,[esp+8]5.intINT_VECTOR_SYS_CALL Write干的就是给寄存器传好参然后进入一个陷阱-系统调用 下面进入syscall函数进行刨析： syscallsys_call:;ecx中是要打印出的元素个数;ebx中的是要打印的buf字符数组中的第一个元素;这个函数的功能就是不断的打印出字符，直到遇到：’\0’;[gs:edi]对应的是0x80000h：0采用直接写显存的方法显示字符串xorsi,simovah,0Fhmoval,[ebx+si]cmpal,’\0’je.endmov[gs:edi],axincsiloop:sys_call.end:ret Syscall在这里，只有一个功能：显示格式化了的字符串。 它将串里面的字节，从寄存器里面通过总线，复制到显卡显存里面，存放Ascll码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。最后我们的打印字符串就显示在了屏幕上。 8.4getchar的实现分析 （以下格式自行编排，编辑时删除） 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 对个getchar的实现分析： getchar1.intgetchar(void)2.{3.staticcharbuf[BUFSIZ];4.staticchar*bb=buf;5.staticintn=0;6.if(n==0)7.{8.n=read(0,buf,BUFSIZ);9.bb=buf;10.}11.return(–n>=0)?(unsignedchar)*bb++:EOF;12.} 用户通过按下键盘，键盘的接口得到了代表按键的键盘码，产生了中断，这个中断，抢占了当前的进程，通过上下文切换机制，进入键盘中断子程序，子程序从键盘接口（文件），获得键盘按下的扫描码，让那后将这个扫描码转为ASCII码的形式，存到键盘的缓冲区里面。 对于getchar函数来说，调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。gethar对这个进行的是一次封装过程。即在按下回车以后读走一个字符。 8.5本章小结 本章具体讨论看hello的IO管理 通过分析说明Linux的IO设备管理方法/UnixIO接口及其函数/printf的实现分析/getchar的实现分析 探讨了小小hello程序背后支撑着它的IO基础 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 逐条总结hello所经历的过程： 从被程序员，一个键盘，一个键盘的敲到文本文件里面，以ASCII码进行呈现，Hello便以文本形式进行了诞生 1.通过预处理器的预处理，hello进行了补全，但仍然是C语言格式的 2.被编译器编译后，成了汇编语言，文本格式，但是语言已经成立汇编的语言了。 继续向前，被汇编器处理成为了二进制代码，hello.o，这个文件的格式是ELF文件格式，有待于进一步被链接 链接器收到.o格式的hello，对hello进行符号解析与重定位。将最后已经链接成功的文件，输出到a.out里面。 我们在bash的shell里面，输入了执行命令./a.out,加载器替我们进行对hello进行加载，fork一个子进程，对子进程通过调用exceve函数，对虚拟内存进行了映射，hello就开始在子进程里面进行运行。 6.在hello的main函数结束后，子进程进入终止状态，由父进程进行对子进程回收。 计算机系统的设计与实现的深切感悟 通过对小小的hello背后的计算机系统的探究，丰富了我对于hello的认识 表面上，只是一个小小的hello，但它的背后，是一群强大的抽象。 从指令集的ISA，到虚拟内存系统，再到进程的管理。 背后，是一个复杂的系统 一环套一环，为抽象进行服务。 搭起了计算机系统的高楼大厦 附件 列出所有的中间产物的文件名，并予以说明起作用。 文件名介绍 hello.c原始的hello文件(C语言) hello.i经过预处理之后的hello文件 hello.s经过编译之后的hello文件,由汇编代码写成 hello.ohello经过汇编之后生成的可重定位的目标文件(二进制代码) hellohello.o经过链接之后生成的目标文件,可以执行 参考文献 [1]CSAPP深入理解计算机系统第三版 [2]程序员的自我修养-链接装载与库 [3]https://www.cnblogs.com/diaohaiwei/p/5094959.html. [4]https://www.cnblogs.com/pianist/p/3315801.html 

拓扑排序以及其C++实现 拓扑排序 啥是拓扑排序？ 直观理解就是在AOE/AOV网络里面，把图的一种先后顺序，对图进行遍历 进行的算法也不难 直接每次选取入度为0的点，进行入队 然后每次出队一个，并对其邻接的顶点进行度的减一操作。 如果出队的顶点数小于总的顶点数，那么，表明存在圈 所以，该算法也能用于有向图的圈的判定问题。 咱们利用一道例题说明： 08-图8HowLongDoesItTake(25分) Giventherelationsofalltheactivitiesofaproject,youaresupposedtofindtheearliestcompletiontimeoftheproject. InputSpecification: Eachinputfilecontainsonetestcase.EachcasestartswithalinecontainingtwopositiveintegersN(≤100),thenumberofactivitycheckpoints(henceitisassumedthatthecheckpointsarenumberedfrom0toN−1),andM,thenumberofactivities.ThenMlinesfollow,eachgivesthedescriptionofanactivity.Forthei-thactivity,threenon-negativenumbersaregiven:S[i],E[i],andL[i],whereS[i]istheindexofthestartingcheckpoint,E[i]oftheendingcheckpoint,andL[i]thelastingtimeoftheactivity.Thenumbersinalineareseparatedbyaspace. OutputSpecification: Foreachtestcase,iftheschedulingispossible,printinalineitsearliestcompletiontime;orsimplyoutput“Impossible”. SampleInput1: 912 016 024 035 141 241 352 540 469 477 574 682 784 SampleOutput1: 18 SampleInput2: 45 011 022 213 134 325 SampleOutput2: Impossible 题目的大致意思，就是：每项工作，用图G里面的边进行表示，节点表示任务结束（AOE/activityonedge网络），求最小完成时间 我们需要做的，实现之前的拓扑排序算法 对于最短时间，我们只需要弄一个数组earlist，每次入度减一时，进行最大的更新操作 PS：一开始，没看清楚权重为0的边，表明我们在对图的初始化时，要当心。调试程序真的是让人头秃啊。。。。。 代码见下： #include<iostream> #include<queue> #defineinf9999999 intn,m; intgraph[200][200]; intru_du[200]; usingnamespacestd; voidini() { cin>>n>>m; inti,j,k,x,y; for(i=0;i<200;i++) { for(j=0;j<200;j++) { graph[i][j]=-100; } } for(i=0;i<m;i++) { cin>>x>>y; cin>>k; graph[x][y]=k; ru_du[y]++; } } intmaxx(inta,intb) { if(a>b) { returna; } else { returnb; } } voidslove() { queue<int>qq; inti,j,k; for(i=0;i<n;i++) { if(ru_du[i]==0) { qq.push(i); } } intcounnt=0; intearlist[2000]={0}; while(!qq.empty()) { intt=qq.front(); qq.pop(); counnt++; for(i=0;i<n;i++) { if(graph[t][i]!=-100) { ru_du[i]--; earlist[i]=maxx(earlist[i],earlist[t]+graph[t][i]); if(ru_du[i]==0) { qq.push(i); } } } } if(counnt!=n) { cout<<"Impossible"; return; } else { intt=0; for(i=0;i<n;i++) { t=maxx(earlist[i],t); } cout<<t; return; } } intmain() { ini(); slove(); } 

数学建模1-评价类问题 数学建模-评价类问题 问题的引入： 假设小明同学高考结束，准备选择EE或者是CS里面的一个，现在，我们需要帮助小明做出符合数学的抉择。 （其实是一类问题，问题本身是非数学的，再比如，你母亲和女友同时落水，你准备救哪一个，但是，我们需要根据我们所学的数学知识，做出抉择） 那么我们就打分吧。 一个显然的想法：确定好打分指标，然后，对每个方案进行打分。 但是，问题在于，怎么打分？毕竟，打分这事，有点主观性过强。 所以，接下来，介绍的，评价类算法，就是告诉我们，怎么打分。 首先上场的是层次分析法 简单的介绍：（此处引用他人的博客。。） 说白了，就是几步，我画了个流程图来概括其大致思路。 根据问题，确定目标层 根据文献（自己的推测？）确定准则层与决策层（个数小于15） 然后两两确定，写出判断矩阵，再进行一致性检验， 在一致性检验通过的时候，求解权重 （P.S这种方法，也可以进行判断比较并确定其它评价方法里面准则的权重）（套娃？？） 然后上场的，是TOPSIS方法（优劣解距离法） 上种方法评价的决策层不能太多，否则，差异太大 如果我们已经得到了数据，那么，层次分析法就显得太主观了，引入数据来分析，更加客观。 此处再次引用他人博客 基本的思路 对指标进行分类： ​极大（小）型指标：越大（小）越好 ​中间（区间）型：居中（某一个区间）就好 然后极小型（中间型）转极大型 标准化消去指标间的量纲 最后进行归一化： （抽象的来看，就是导出评价对象在评价域这个向量空间里面，与我们最大（小）值向量的距离，并以此来进行排序） 导出与最大/最小 所以，方法的核心就是：对我们手中所得到的数据进行处理，找出指标，处理掉指标的量纲影响，确定一个评价空间，在这个向量空间里面，找出每一个对象距离最大值与最小值的距离。 二话不说，上流程图： 在TOPSIS方法里面，每个指标对应的权重，是可以根据层次分析法进行赋值的，不过，这种方法主观性太强了。还有一种方法，也可以对指标进行赋值 熵权法 指标的变异程度越小，反应的信息量越小，对应的权值应该越低 而概率越大的事件，其信息量应该越少，概率越小，信息量应该越多。 基本原理：引用他人博客 基本的流程: 1）数据处理，归一化 2）计算信息熵 3）计算权重 换一种角度，还有方法进行评价-模糊综合评价 其实，所有的评价类问题的方法，抽象的来看，说的都是一个东西。 定义： ​因素集：所研究的问题，可以从多个角度看，因素集，即问题空间中的一组基。 ​评语集：将问题空间里面的元素经映射后，对应的结果（值域）。 ​权重集：各因素集元素在某一次至评语集映射中所占权重。 我们在评价类问题里面需要解决的要做的：把论域中的对象对应至评语集中指定的评语。不同的评价类方法，就是不同的映射。将论域V里面的问题，映射到我们的评价域U。 上面的比较抽象，其实简单的来说，就是对某一特定对象给出一个评价。或者，将把评价换成方案。 那么，回到原点，什么是模糊综合评价？ 简单的来说，就是引入模糊数学里面的概念，通过隶属函数（模糊）/模糊统计法，确定好各因素在评语集里面所占的份量，最后，赋予权重，找最大的权值的评语作为我们的结论。 详细的解说：别人的博客 我对上述过程画了一张图来帮助理解。 

哈工大计算机系统大作业-C、C++底层实现分析 哈工大计算机系统大作业-C、C++底层实现分析 第1章C语言的语言元素1.1程序结构1.1.1循序结构1.1.2分支（1）if语句（2）switch语句 1.1.3循环（1）while语句（2）do-while语句（3）for语句 1.2变量1.2.1全局变量1.2.2局部变量1.2.3整型变量1.2.4浮点变量1.2.5寄存器变量1.2.6指针变量1.2.7结构体1.2.8共用体1.2.9枚举类型1.2.10数组1.2.11常量 1.3函数1.3.1函数格式1.3.2参数传递 1.4其他1.4.1类型转换1.4.2运算符 第2章汇编语言的语言元素2.1程序结构2.1.1整体结构2.1.2分支2.1.3循环 2.2数据2.2.1数据存储2.2.2整数2.2.3浮点数2.2.4数据格式 2.3函数2.3.1参数传递的规则2.3.1调用语句2.3.2返回值传递 第3章C语言的汇编实现3.1数据类型的实现3.1.1整型3.1.2浮点型3.1.3指针与数组、结构3.1.4类型转换3.1.5寻址问题 3.2代码结构的实现3.2.1循序3.2.2分支3.2.3循环3.2.4优化对循环的影响 3.3函数的实现 第4章C与汇编的优缺点分析4.1C语言4.1.1优势4.1.2劣势4.1.3应用场景 4.2汇编语言4.2.1优势4.2.2劣势4.2.3应用场景 4.3总结 参考文献 第1章C语言的语言元素 1.1程序结构 1.1.1循序结构 C语言中程序的执行方式为顺序执行，即当某一代码块中没有可能会导致跳转的语句，例如循环、分支、函数等时，程序从这一代码块的第一条指令，逐条执行到最后一条指令。例如在某一.c文件中写入下列代码： intmain() { A=1; B=2; A=A+B; return0; } 在这一程序中，main函数所运行的代码为完全的循序结构。 1.1.2分支 （1）if语句 在C语言中，if语句的格式为： if(条件表达式1) {代码1} elseif(条件表达式2) {代码2} 。。。 else {代码n} 其中elseif和else不是必须的。在每个if和elseif后的括号中，为运行其后代码所需要的条件，当所有条件表达式均为否时，则执行else后面的代码，若没有else，则不做任何操作。在C语言中，当条件表达式的值为0时，则认为条件表达式为否，而当条件表达式为任意非0值时，则认为条件表达式为真。除此之外，C++中还定义了bool类型，true表示真，false表示否，且true可视作为1，false可视作0。 （2）switch语句 在C语言中，switch语句的格式为： switch(变量a) { case情况1: 代码1 case情况2: 代码2 。。。 default: 代码n } 其中，变量为某一基本类型变量a，即char、int、float、double等类型变量。并且default标记不是必要的。case后面的情况为a所可能的各种取值，当a满足其取值为某种情况时，程序将跳转到这一情况对应case后面的代码，并且程序将运行后面全部代码，包括其他case的代码，直到遇到break语句或运行完其后续的所有代码，才会退出switch代码块。当a没有满足任何列出的情况时，程序将跳转到default后面的语句，运行情况同case。另外，当没有default时，程序将直接退出switch代码块。 1.1.3循环 （1）while语句 在C语言中，while语句的格式如下： while(条件表达式) { 代码 } 当条件表达式为真时，程序将执行代码块中的代码。 （2）do-while语句 在C语言中，do-while语句的格式如下： do { 代码 }while(条件表达式); 程序将先执行一遍代码块中的代码，然后判断条件表达式是否为真，若为真，则重复执行代码块中的代码。 （3）for语句 在C语言中，for循环的语句格式如下： for(初始化表达式;条件表达式;迭代表达式) { 代码 } 程序先根据初始化表达式进行初始化，并判断条件表达式是否为真，若为真则运行代码块中的代码，随后运行迭代表达式，再重新判断条件表达式是否为真，当条件表达式不为真时，退出循环，否则继续运行代码块。 1.2变量 1.2.1全局变量 在C语言中，定义在函数外的变量为全局变量，其作用域为文件中的全体函数，以及调用该文件的其他文件中的全体函数，当其用static进行修饰时，其作用域仅为当前文件中的全部函数。当用extern进行修饰时，说明该全局变量需要在其他C文件中定义。任何数据类型的变量均可被定义为全局变量，且全局变量的生命周期为整个程序的生命周期，当程序结束时，其内存才被释放，在此之前，其内存一直存在。当代码中未对全局变量进行初始化时，其将被初始化为0。 1.2.2局部变量 在C语言中，局部变量定义在函数内部或函数内部某一代码块中，其作用域为函数内部或代码块内部，以及函数内部的代码块中。局部变量的生命周期为整个函数或代码块，当局部变量没有被显示初始化时，其值为一伪随机数，所以局部变量需要在使用前进行初始化。但当局部变量用static进行修饰时，其值不会因为其所在函数结束而被修改，而是会在再次执行到这一函数时存储其先前的值。另外静态局部变量若没有进行显示初始化，其初始值为0。 1.2.3整型变量 在C语言中，整型变量包括char、short、int、long、longlong几种类型，其区别在于所需存储空间的大小以及其所能表示数字的大小，long类型在不同系统中往往有着不同的容量。在C语言中，整形数据均采用补码存储，除char类型外，其他类型均默认为有符号整数，可以通过在int等关键字前添加unsigned关键字来声明无符号的数据类型，同理可以通过在char关键字前添加signed关键字特别声明有符号的以表示单字节变量。另外，char类型大部分时候均用来表示ASCII码，并不经常用来表示数字。 1.2.4浮点变量 在C语言中，浮点变量包括float、double、longdouble几种类型，其区别同样是其存储空间大小及其表数范围、表数精度。其中longdouble在不同系统中往往有不同的容量。C语言中，浮点类型通过IEEE754编码实现。浮点变量通常用于表示小数以及过大的数，但其对于大部分数字而言只能存储近似值，不能保证绝对精确，而精确程度与其存储空间有关。 1.2.5寄存器变量 在C语言中，需要频繁进行使用的变量可以通过register关键字将其定义为寄存器变量，寄存器变量总是保存在CPU的寄存器中，可以有最高的运行效率。32位下由于寄存器空间的限制，寄存器变量只能为char、short、int类型。而且由于寄存器变量不存储在内存中，所以不可以对其用取地址运算符。 1.2.6指针变量 在C语言中，指针变量存储一个虚拟内存的地址，任何数据类型均有与其对应的指针类型，除此之外，还有指向函数的函数指针。指针类型在32位编译模式下大小为4字节，在64为编译模式先大小为8字节。可以通过取地址运算符&获取某一变量的地址，也可以通过*运算符访问一个指针所指向的内存空间。除此之外，当指针为结构体指针时，可以通过->运算符读取该指针所指向结构体的成员变量。 1.2.7结构体 在C语言中，结构体是一种抽象数据类型，它一般表示某种需要通过多种数据类型才能精准表示的事物。一般定义结构体数据类型的代码格式如下： struct类型名 { 数据类型1变量A; 。。。 数据类型n变量N; }; 在定义结构体类型后，需要通过以下格式声明一个结构体类型变量：struct结构体类型名变量名;若想访问或修改结构体变量的某个具体属性，需要通过圆点运算符.进行读取。 1.2.8共用体 C语言中，可以通过共用体对同一段内存进行不同种数据类型的存储、读取。其定义格式如下： union共用体类型名 { 可能的数据类型变量; }; 在定义共用体类型后，需要通过以下格式声明一个共用体类型变量：union共用体类型名变量名;并通过原点操作符.来选择其存储哪种数据类型并进行读写。共用体所占空间大小与其内部最大空间的数据类型相同，当用较小的数据类型模式读取存储较大数据类型的共用体时，只会读取内存的前几个字节，且具体读出的结果与大小端模式有关。 1.2.9枚举类型 C语言中，对于某一概念中包括多种常量时，可以使用枚举类型，其定义格式为： enum枚举类型名 { 常量名1; 。。。 常量名n; }; 枚举类型的常量可以直接对其常量名进行访问，另外在枚举类型定义时可对其各个常量进行赋值，用以使其用来表示某个整数值。若没有在枚举类定义中设置常量值，则程序将从第一个常量从0开始顺序赋值；若只对第一个常量进行赋值，程序将从这个值开始为后续常量顺序赋值。除此之外，枚举常量作为常量，不能被程序进行修改，只能将其赋值给某一变量。 1.2.10数组 C语言中，所有类型的变量都可以在其声明时在其变量名后添加[]使其被定义为数组变量，通常[]中应以常量注明数组大小，但当数组被初始化时，数组大小可不进行注明。另外，变量名后可添加多个[]表示多维数组，但只有第一个[]可以不注明数组大小。除此之外，char数组足够大时可被直接用来存储字符串，字符串可被视作以\0字符结尾的字符数组。 1.2.11常量 C语言中，常量包括数字、字符串、宏常量、const常量几种数字包括整数与小数，其中整数可以通过在数字前标注0前缀表示8进制，标注0x前缀表示16进制，另外可以通过在数字后加U后缀表示该数字为无符号数字，后缀L表示数字为long类型，否则将其视为十进制有符号int类型。而浮点类型可以通过在数字后加F表示该数字为float类型，否则为double类型。在代码中所有显示出现的字符串均被视为常量，不可以对其进行修改，否则会报错。C语言中可以通过预处理命令定义宏常量，会在预处理阶段将宏常量转化为其对应的常量，其定义格式为：#define常量名常量数值C语言中，还可以通过const关键字使某一变量值除定义时的初始化外，无法进行修改，即使其成为常量，但该常量的作用域仍与其定义位置有关。另外，当一个指针变量被const关键字修饰时，其所指向的内存也不可通过这个指针变量进行修改。 1.3函数 1.3.1函数格式 在C语言中，函数表示某一段执行特定功能的代码，可以由其他函数进行调用，其定义格式为： 返回值类型函数名(数据类型1变量A,。。。,数据类型n变量N) { 代码 return返回值; } 当返回值类型为void时，return语句可以不写，也可以仅为return;用以标志程序退出位置。通常情况，函数应该在编写实现代码前进行声明，函数声明格式如下：返回值类型函数名(数据类型1变量A,。。。,数据类型n变量N);当在函数声明前添加static关键字时，可以将函数的使用范围限定在当前文件中。当在函数声明前添加extern关键字时，函数被视作需要从其他C文件中引用，因而不需要函数体。另外，在每一个可以被编译为可执行程序的C文件中均有一个程序开始执行的入口函数，对于命令行程序而言，其入口函数为main函数，程序总是从main函数的第一行开始执行，且main函数无论通过直接或间接方法都无法访问到的函数通常可以被认为永远无法被执行。 1.3.2参数传递 在调用某一函数时，开发者需要按照函数声明向函数输入约定参数进行调用，并接收其返回值。函数在被调用时所接受的参数存储在其自身的局部变量中，对传递进来的参数进行修改，不会影响到传递的参数的值，但对于指针参数而言，其所指向的位置依然相同，因此对指针所指向的空间操作会影响到其他函数的运行，所以当有不想被函数修改指向空间的指针变量时，可以在其声明中加以const关键字修饰。当函数的参数为数组或结构体时，可以视为传递的为数组或结构体的指针，对他们进行操作时也会导致其内部结构发生改变。在C++中，可以在声明中通过引用变量直接对传递进来的参数进行操作，修改其数值。另外，通常函数在运行时，只能直接访问其内部的局部变量以及各全局变量，不能访问到其他函数的局部变量。 1.4其他 1.4.1类型转换 在C语言中，类型转换分为隐式转换与显示转换。隐式类型转换发生在小数据类型与大数据类型进行运算时，以及整数数据类型与浮点数据类型运算的时候。当某一小数据类型与大数据类型进行运算时，小数据类型会被转换为大数据类型再进行运算，并且计算结果为大数据类型。当整数数据类型与浮点数据类型进行计算时，整数数据类型会被转换为浮点类型再进行计算。另外在用整数数据类型变量接收浮点类型时，会自动将浮点类型转换为舍入到整数位的整数类型，再进行赋值；当用大数据类型接受小数据类型时，会自动将小数据类型转化为大数据类型，再进行赋值。显示转换也叫强制类型转换，一般发生在大数据类型转换为小数据类型、将某一数字常量强制视为另一种类型的常量进行运算、强制将某一变量通过另一变量的格式进行解读时。需要注意的是，第一种情况下，强制类型转换可能会导致数据溢出和舍入。除此之外，有符号整数与无符号整数之间的强制类型转换，满足数据的位模式不变。 1.4.2运算符 C语言中有大量运算符，他们在计算过程中会按照优先级进行运算，下列是运算符优先级及功能表||| 优先级运算符名称或含义使用形式结合方向说明1[]数组下标数组名[常量表达式]左到右–1()圆括号(表达式）/函数名(形参表)左到右–1.成员选择（对象）对象.成员名左到右–1->成员选择（指针）对象指针->成员名左到右–2-负号运算符-表达式右到左单目运算符2~按位取反运算符~表达式右到左单目运算符2++自增运算符++变量名/变量名++右到左单目运算符2–自减运算符–变量名/变量名–右到左单目运算符2*取值运算符*指针变量右到左单目运算符2&取地址运算符&变量名右到左单目运算符2!逻辑非运算符!表达式右到左单目运算符2(类型)强制类型转换(数据类型)表达式右到左–2sizeof长度运算符sizeof(表达式)右到左–3/除表达式/表达式左到右双目运算符3*乘表达式*表达式左到右双目运算符3%余数（取模）整型表达式%整型表达式左到右双目运算符4+加表达式+表达式左到右双目运算符4-减表达式-表达式左到右双目运算符5<<左移变量<<表达式左到右双目运算符5>>右移变量>>表达式左到右双目运算符6>大于表达式>表达式左到右双目运算符6>=大于等于表达式>=表达式左到右双目运算符6<小于表达式<表达式左到右双目运算符6<=小于等于表达式<=表达式左到右双目运算符7==等于表达式==表达式左到右双目运算符7!=不等于表达式!=表达式左到右双目运算符8&按位与表达式&表达式左到右双目运算符9^按位异或表达式^表达式左到右双目运算符10|按位或表达式表达式左到右11&&逻辑与表达式&&表达式左到右双目运算符12||逻辑或表达式||表达式左到右双目运算符13?:条件运算符表达式1?表达式2:表达式3右到左三目运算符14=赋值运算符变量=表达式右到左–14/=除后赋值变量/=表达式右到左–14*=乘后赋值变量*=表达式右到左–14%=取模后赋值变量%=表达式右到左–14+=加后赋值变量+=表达式右到左–14-=减后赋值变量-=表达式右到左–14<<=左移后赋值变量<<=表达式右到左–14>>=右移后赋值变量>>=表达式右到左–14&=按位与后赋值变量&=表达式右到左–14^=按位异或后赋值变量^=表达式右到左–14|=按位或后赋值变量|=表达式右到左–15，逗号运算符表达式,表达式,…左到右– 第2章汇编语言的语言元素 2.1程序结构 2.1.1整体结构 注意，下面所说的汇编语言均以AT&T为例。汇编程序中每个节由.section进行标识，每个汇编程序通常有.data、.text、.bss三个节，其功能如下.data节存储已初始化的变量，且其可读也可写，可以在代码中对其进行读写。.bss节存储未初始化的变量，当使用这些变量时，可以视作他们都被初始化为0。.data节与.bss节共同构成了程序的数据段，用来存储汇编程序中的各种变量。.text节存储程序的指令代码，该节中的代码为只读模式，不可进行修改。每一个可执行汇编程序中都应该至少有一个.text节。通常在.text节的第一行代码中定义.global_start符号或.global_main符号，并在后面编写其程序体，以此作为程序的入口函数，并按照该函数中的代码顺序运行。.text节也被视作汇编程序的代码段，用来存储程序中的各个函数的指令代码。汇编程序中的栈段并不会在代码中显示定义，但代码段中有各种用于对栈进行操作的指令，例如push，pop等，另外程序可以通过对栈顶指针相对寻址的方式来间接使用栈段。栈段的数据为可读写模式。 2.1.2分支 在汇编语言中，分支通过jmp等指令修改%rip寄存器实现，其中，jmp为无条件强制跳转，而其他跳转指令则是根据当前各条件位的状态判断是否跳转到其他指令地址。例如je指令在判断ZF条件码为1时才会跳转到其参数的地址。在跳转指令中，可以通过*运算符来进行间接跳转，例如跳转到某寄存器所存内存地址等情况。需要注意的是，汇编语言中的跳转指令通常可以跳转到任何位置，操作不当可能会造成严重错误，所以通常应该只用于函数内部的跳转。 2.1.3循环 在汇编语言中，并没有直接提供用来构造循环的语法，但是可以通过设置循环起点以及循环终止条件，当终止条件不满足时，使用je等指令跳转到循环起点，从而实现循环的功能。通常，循环起点被标注为loop符号。 2.2数据 2.2.1数据存储 在汇编语言中，数据分为立即数、寄存器数据、内存数据三种。常数通常直接使用立即数进行表示，在任何操作中，立即数均不能作为指令的接收部分。在AT&T中，立即数的表示方法为在数字前加$符号。另外，可以在数字前加0x前缀以表示十六进制数字。变量通常使用寄存器与内存进行存储，对于使用频率极高的变量，可以将其存储于寄存器中，以提高读取速度，而通常的变量，均存放在内存中。许多指令都只支持寄存器作为参数，所以许多时候，变量需要先读取至存储器中，才能进行操作，这种情况，存储器相当于一个实现功能所需的缓存。另外，由于存储器数量比较少，所以大部分的数据通常都存放在内存中，对于作用域比较小的变量，通常通过%rsp和%rbp两个寄存器，将其存放在栈中，并使用他们对其进行读写。而对于全局性变量来说，通常使用绝对取址或通过%rip寄存器运算获取其位置，并进行读写操作。 2.2.2整数 在汇编语言中，整数通过补码进行表示，且不区分有符号整数与无符号整数，同一位模式的数据既可以作为有符号整数操作，也可以作为无符号整数操作。但汇编语言中有各种针对相同位模式，分有符号和无符号两种对数据进行操作的指令。另外，整数数据也按照大小分为单字节、单字、双字、四字四种类型，分别对应一个字节、两个字节、四个字节、八个字节四种情况，每种类型对应的指令分别有b、w、l、q四种后缀，以针对这四种类型的数据进行操作。需要注意的是，当寄存器中大数据强行作为小数据使用时，其高位数据通常会被保留，但四字数据强行转换为双字数据时，其高四位将被清零。 2.2.3浮点数 在汇编语言中，浮点数也通过IEEE754编码进行表示，并且浮点数的存储方式与正常数据相同，但读取一个浮点数不应使用%rax等整数寄存器，而是应该使用%xmm、%ymm系列寄存器，并使用浮点数专用的指令进行浮点运算。 2.2.4数据格式 在汇编语言中，指令的操作数按照下图的格式进行输入： 2.3函数 2.3.1参数传递的规则 在32位汇编程序中，参数的传递一般是按照将函数的参数从左到右依次压入栈中，然后通过函数的栈指针对各参数进行读取与修改。在64位汇编程序中，参数的传递一般结合了寄存器实现，参数会依次存入%rdi、%rsi、%rdx、%rcx、%r8、%r9中，当参数多于6个时，其余参数会被压入栈中，并通过栈指针进行读取与修改。 2.3.1调用语句 在汇编语言函数开始调用时，call指令会先将%rip中的数据进行压栈，然后将%rip修改为该函数的第一条语句，前几条语句通常是用来构建函数栈的，并按照顺序逐条执行函数中的语句，同时，当需要使用局部变量时，函数会将其存放在。最终，函数通常将运行leave和ret指令，从而将控制权转移回调用它的函数，并将栈清空。 2.3.2返回值传递 通常，当函数有返回值时，该函数会在结束运行前将计算得到的返回值保存到%rax寄存器中，并在调用者函数中通过访问%rax寄存器进行对函数返回值的接受。 第3章C语言的汇编实现 3.1数据类型的实现 3.1.1整型 在C语言被编译为汇编语言的过程中，表示整型数据的全局变量被翻译为汇编语言中的各种全局符号，表示整型数据的局部变量被转换为对应函数栈帧中的特定位置内存，而C源代码中出现的各整数常量则被翻译为立即数。具体实现过程描述如下：对于全局变量，汇编代码中会将其翻译为全局符号，对于有初始值的全局变量，其在汇编代码中会被标志为.data节，并在符号内部填充相应初始值；而对于无初始值的全局变量而言，其会被标志为.bss节。但其具体使用相似，都是被编译为在汇编指令中直接使用相应全局符号。而对于局部变量而言，汇编代码中，会将C语言各函数中的局部变量名无视，直接将局部变量存储在函数的栈帧中，并使用寄存器进行寻址来读写局部变量。需要注意的是，静态局部变量会被编译器解释为符号，并按照与全局变量相同的方式进行存储于使用，但其使用范围会被限制在相应的函数中。另外，代码中出现的整型常量通常被直接翻译为汇编代码中的立即数，作为汇编指令的源操作数。 3.1.2浮点型 对于浮点数，C语言在编译后会将表示浮点数的IEEE754编码按照十六进制数字整数进行存储、读取，但浮点数运算部分，代码会被编译为使用%xmm等寄存器并使用各种浮点数运算指令进行相关的浮点运算。 3.1.3指针与数组、结构 当C语言被编译为汇编时，C语言中的指针会被视为整型变量，唯一区别是，C语言中针对指针的各种操作会被编译为一套特定的汇编代码，而通常的整型变量不可以使用这些操作，从而不可能出现非指针变量被编译后出现这些指令序列的情况。数组通过在内存中对同一数据类型连续存储实现，访问数组某一元素，只需根据首字节地址以及其与首字节的偏移量即可实现。结构和数组的结构相似，但其内部的数据类型不同，占用空间也不同，每种数据类型的存储位置按照其在结构体中定义的顺序，而且每一个数据其距离结构体首字节的距离满足其自身大小的整数倍，从而实现对齐。另外，在数组、结构等数据类型被编译为汇编语言时，其内部数据通常存储在栈中，而用表示其首字节地址的整型变量作为其位置的标识，并根据其内部结构进行相对寻址从而读写他们内部的数据。 3.1.4类型转换 C语言中的整数间类型转换在汇编语言中通过movzbl等指令以及CPU寄存器特性等功能实现。对于自动类型转换而言，相应计算代码会被编译为先使用类型转换命令将小数据转换为大数据类型随后将两个相同数据类型的数据再进行运算。而强制类型转换也是通过这些指令来进行的，区别仅在于C语言中的限制。对于与浮点数有关的类型转换，均是通过浮点数指令来进行的，例如通过vcvtsi2ss指令将整数转换为单精度浮点数。 3.1.5寻址问题 在C语言被编译为汇编语言的过程中，全局变量的寻址通常使用与%rip共同使用来间接访问某一绝对地址的方式实现，而局部变量的寻址则是通过在其所在函数的栈帧中，通过%rsp进行相对寻址来实现。 3.2代码结构的实现 3.2.1循序 当C语言被编译为汇编语言时，C语言中的循序代码会被逐条翻译为相应的汇编代码，其运行顺序不变，从而实现了C源代码编译后的汇编代码依然循序。 3.2.2分支 当C语言被编译为汇编语言时，if语句会被翻译为先进行条件判断，当满足条件时跳转到相应代码，不满足条件时顺序执行的汇编结构。而switch语句将会构建一个跳转表，对于每一种情况，都将其代码进行标记，并将标记存放在跳转表中，当满足条件时，控制将会跳转到相应代码并顺序执行。 3.2.3循环 C语言中包含三种循环，其被翻译为汇编代码时有不同的表现，细节如下：对于do-while循环，其汇编代码实现方式为在代码第一行前通过一个符号进行标志，当运行结束这段代码时，判断循环条件，若满足条件，则跳转到前面的符号，从而实现循环功能。对于while循环，程序会在代码部分和条件判定部分分别进行标记，在开始循环前，程序会跳转到条件判定部分，当条件满足时，再跳转到代码部分并循序执行相应代码，执行结束时，控制会回到条件判定部分，从而实现循环功能。对于for循环，程序会在循环条件判定部分及循环体部分进行标记。在循环代码执行前执行循环初始化代码，随后将控制转移到条件判定标志，当条件满足时，执行循环体，紧接着执行循环迭代代码，再进行条件判定，从而实现for循环功能。 3.2.4优化对循环的影响 当编译器开启了优化选项时，编译器可以对循环生成的代码进行优化，从而实现效率的提升，其具体实现可以分成以下几点：首先，当某一循环体为空时，优化会导致程序忽略该循环。其次，当循环中的运算结果若在后续代码中未被使用，循环将直接被优化删除。除此之外，优化可能为了提高程序效率调整部分代码次序或删除部分代码。另外，当代码中重复计算相同的数据时，该部分代码会被编译器移出循环。需要注意的是，用于实现等待一段时间的循环通常会被编译器优化。 3.3函数的实现 C语言被编译为汇编语言时，函数名会被翻译为一个.text节符号，并在它的内部定义函数的具体实现代码。每个函数的前几行指令，通常为开辟新的函数栈帧以保存其内部局部变量等信息，并在最后几行调用leave、ret等指令，将控制转移回其调用函数。对于函数各个参数的传入，以64位系统为例，调用函数需要在调用所需函数前将函数所需要的各个参数存放在相应寄存器中，当参数数目过多，寄存器无法容纳时，函数栈帧将会有一块专门的参数构造区，用以存储参数7之后的参数，并通过%rsp、%rbp进行相对寻址从而对其进行读写操作。需要注意的是，若在C语言代码中对变量进行取地址运算，则该变量通常会被保存在栈中。当函数代码运行完毕前，需要将要返回的数据保存在%rax中，并在调用函数中接收并进行相应的操作。 第4章C与汇编的优缺点分析 4.1C语言 4.1.1优势 C语言作为一种高级编程语言，其抽象程度比汇编语言更强，也更加贴近于人的理解过程。它的优点包括以下几个方面：C语言，将对内存中各个地址的数据的操作抽象为对一个个变量的操作，只需要专注于某个算法的具体实现流程，而无需过多考虑底层硬件，这一特点使得它相比于汇编语言能让人更好的了解与设计某段程序的功能以及其运行过程，使得其编程思路相比于汇编语言也更加人性化。所以，C语言的开发速度相比汇编语言大大提高，同时其也大大降低了编程的门槛与难度。除此之外，若一个C程序不调用任何与某个特定平台相关的库以及其中的函数，则将它的源代码复制到不同的平台，并使用该平台上的编译器，则其编译后的程序的运行效果将完全相同，而不受平台的影响，其可移植性相比汇编语言更强。另外，C语言也是程序员入门的较好的编程语言，他的内容比较少，而且与底层硬件紧密相关，能够帮助学习者更快地了解计算机的相关知识。 4.1.2劣势 C语言作为一个高级编程语言也有着不少缺点，当CPU出现某些新特性时，要想利用他们，C语言的编译器可能不得不进行改变，甚至对于某些特定的特性，C语言很难将其进行利用，进而导致程序对CPU无法进行充分地利用。另外，C语言虽然是一种比较高效的高级语言，但对于一个熟练的汇编语言程序员来说，汇编代码的效率往往比C语言更高。 4.1.3应用场景 当某个学生希望学习编程相关知识时，应该首先考虑内容较少但却与底层硬件紧密相关的C语言作为入门编程语言。当编写操作系统时，对于一些抽象程度较高的功能，应该使用C语言进行编写，从而简化编写过程，将注意力更多地放在程序的功能上，并减少潜在的BUG。当编写一些功能众多、体量巨大又追求较好的效率，但与计算机底层关系并不是很大却也有部分相关的项目时，也应该采用C语言以提高开发效率。当编写一些嵌入式设备的程序时，但开发者对该设备CPU所使用的汇编语言不了解时，也应采用C语言，从而完成任务。当编写的程序可能需要在多个平台发布时，相比于汇编语言也应该考虑C语言，从而简化移植过程。 4.2汇编语言 4.2.1优势 汇编语言作为一种抽象程度较低的，比较原始的编程语言，其优点在于好的汇编程序员可以使程序占用更少的空间、发挥更好的效率，以及它可以支持CPU的全部特性两方面。相比与高级语言编译生成的汇编代码而言，由熟练的汇编程序员所编写的代码往往可以减少各种不必要的操作，更加充分地使用各种数据，并通过各种技巧来提高程序的效率，进而使相同功能的汇编代码有着更高的效率。另外，汇编代码中可以应用无法直接在高级语言中使用的CPU的特性，从而使汇编代码在某些场合下相比于高级语言程序有着更好的功能性，极大提高特定工作的效率。 4.2.2劣势 汇编语言也有自己的劣势，具体表现为以下几个方面：汇编语言相比于C语言需要对计算机底层的知识有更加充分的掌握，否则很难编写出优质的汇编代码，另外，想要编写出比高级语言效率更高的代码，需要程序员大量的经验，上手难度较高。汇编语言需要对每一步机器运行过程进行编写，需要消耗程序员大量精力，同时也使程序的开发效率极大降低。汇编语言往往在不同架构的CPU上有不同的具体指令，将程序从一个平台向另一个平台需要进行大量工作，甚至完全重写代码，可移植性极差。 4.2.3应用场景 当编写计算机操作系统时，其最基本的功能应提供汇编语言实现，从而提高效率。当编写效率要求较高、功能性较强、存储空间较少的程序时，应使用汇编语言实现。当编写高级语言的解释器、系统函数库等高级语言基本组件时，应用汇编语言实现，以提高效率。当编写特殊环境下的嵌入式设备时，应使用汇编语言编写以最大可能避免各种问题。 4.3总结 C语言与汇编语言的各种特性决定了不可能有某一方完全代替另一方。当要求开发速度快、可以移植性强、学习简单，但对运行效率没有极度追求，程序功能性也不需要太强，例如通常的软件编写等情况下，C语言无疑为更好的选择；而在要求运行效率高，程序功能性强，但对开发效率、可移植性没有太高要求时，例如航天设备软件编写等情况下，汇编语言无疑更加实用。总的来说，C语言主要应用于抽象程度较高的领域，而汇编应用主要应用于抽象程度较低的领域。所以，无论是汇编语言还是C语言都有着其各自的用武之地，两种语言均需要培养相应的人才。 参考文献 [1]C语言运算符优先级（超详细）：http://blog.csdn.net/huangblog/article/details/8271791[2]ATT汇编语言格式：https://max.book118.com/html/2017/0906/132304926.shtm[3]第二部分ATT汇编语言：https://wenku.baidu.com/view/4bb1dad9777f5acfa1c7aa00b52acfc788eb9f6e.html[4]百度百科-汇编语言：https://baike.baidu.com/item/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/61826?fr=aladdin#5_1 本文为作者原创，部分内容表述可能并不准确，请读者仅将本文作为一份参考，若发现错误请酌情提醒本人改正另附本人关于本次大作业所上交实验代码的下载网址 

哈工大信息安全概论复习笔记(3) 哈工大信息安全概论复习笔记（3） 考点十五PKI的体系结构及工作原理 公钥基础设施(PKI)采用数字证书技术来管理公钥，通过第三方的可信任机构 CA认证中心把用户的公钥和用户的其他标识信息捆绑到一起，在互联网上验证用户的身份。在PKI的组成结构中，处在中心位置的是构建PKI的核心技术，即公钥算法和数字证书技术，在此技术基础上实现的PKI平台包括四个基本功能模块和一个应用接口模块。 1.认证机构CA：CA是PKI的核心执行机构，也称为认证中心。其主要功能包括数字证书的申请注册、证书签发和管理。 2.证书库：证书库是CA颁发证书和撤销证书的集中存放地，它像网上的“白页”一样，是网上的公共信息库，可供公众进行开放式查询。 3.密钥备份和恢复：密钥备份和恢复是密钥管理的主要内容，PKI提供了密钥备份和密钥恢复机制，即当用户证书生成时，密钥被CA备份存储，当需要恢复时，用户只需向CA提出申请，CA就会为用户自动进行密钥恢复。 4.证书撤销处理：被撤销的CA证书将进入证书库的"黑名单"，用于公众来核实证书的有效性。 5.PKI应用接口：PKI应用接口使使用者与PKI交互的唯一途径，PKI应用接口也可以看成是PKI的客户端软件。 考点十六访问控制的概念 访问控制：是针对越权使用资源的防御措施，从而使系统资源在合法范围内使用。 访问控制的基本组成元素：1.主体-值提出访问请求的实体，主体是动作的发起者，但不一定是动作的执行者，可以是用户或其他代理用户行为的实体(如进程、作业和程序等)2.客体-是指可以接受主体访问的被动实体。凡是可以被操作的信息、资源、对象都可以认为是客体。3.访问控制策略-指主体对客体的操作行为和约束条件的关联集合 考点十七DAC、MAC、RBAC的工作原理及特点 自主访问控制DAC 自主访问控制(DAC):允许合法用户以用户或用户组的身份来访问系统控制策略许可的客体，同时阻止非授权用户访问客体，某些用户还可以自主地把自己所拥有的客体的访问权限授予其他用户。实现上：首先要对用户的身份进行鉴别，然后就可以按照访问控制列表所赋予用户的权限允许或限制用户访问客体资源。主体控制权限的修改通常由特权用户或特权用户组实现。 强制访问控制MAC 强制访问控制(MAC)：系统事先给访问主体和受控客体分配不同的安全级别属性，在实施访问控制时，系统先对访问主体和受控客体的安全级别属性进行比较，再决定访问主体能否访问该受控客体。主体对客体的访问可以分为以下四种形式：1.向下读2.向上读3.向下写4.向上写向下读向上写，防止机密信息向下级泄露，保护机密性向上读向下写，保护数据的完整性 基于角色的访问控制RBAC 组：具有相同性质(访问权限)的用户集合角色；一个与特定行为关联的行为与责任的集合RBAC思想：将访问权限分配给角色，用户饰演角色获得访问许可权。一个用户可当多个角色 考点十八Windows安全体系结构、活动目录与组策略 整个安全架构的核心是安全策略，完善的安全策略决定了系统的安全性。Windows系统的安全策略明确了系统各个安全组件如何协调工作。 Windows系统安全开始于用户认证，它是其他安全机制能够有效实施的基础，处于安全框架的最外层。 加密和访问控制处于用户认证之后，是保证系统安全的主要手段，加密保证了系统与用户之间的通信及数据存储的机密性；访问控制则维护了用户访问的授权原则。 审计和管理处于系统的内核层，负责系统的安全配置和事故处理，审计可以发现系统是否曾经遭受过攻击或者正在遭受攻击，并进行追查；管理则是为用户有效控制系统提供功能接口。 活动目录(AD)存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。 组策略(GP)是AD安全性地重要体现，可理解为依据特定地用户或计算机地安全需求定制地安全配置规则 考点十九传统病毒、蠕虫、木马的结构原理 传统病毒一般由三个主要模块组成，包括启动模块、传染模块和破坏模块。当系统执行了感染病毒地文件时，病毒的启动模块开始驻留在系统内存中。传染模块和破坏模块的发作均为条件触发，当满足了传染条件，病毒开始传染别的文件；满足了破坏条件，病毒就开始破坏系统。 蠕虫病毒一般不需要寄生在宿主文件中，这一点与传统病毒存在差别，蠕虫病毒具有传染性，它是通过在互联网环境下复制自身进行传播。蠕虫病毒的传染目标是互联网内的所有计算机，传播途径主要包括局域网内的共享文件夹、电子邮件、网络中的恶意网页和大量存在着漏洞的服务器等。可以说蠕虫病毒是以计算机为载体，以网络为攻击对象。 木马是有隐藏性的、传播性的、可被用来进行恶意行为的程序。木马一般不会直接对计算机产生危害，主要以控制计算机为目的。木马的传播方式主要通过电子邮件附件、被挂载木马的网页以及捆绑了木马程序的应用软件。木马被下载后完成修改注册表、驻留内存、安装后门程序、设置开机加载等，甚至能够使杀毒程序、个人防火墙等防范软件失效。 考点二十拒绝服务攻击、缓冲区溢出、举例 拒绝服务攻击(DoS)也被称为业务否定攻击，不是一种具体的攻击方式，二十攻击所表现的结果最终使得目标系统因遭受某种程度的破坏二不能继续提供正常的服务，甚至导致物理上的瘫痪或崩溃。通常拒绝服务攻击可分为两种类型，第一类是利用网络协议的缺陷，通过发送一些非法数据包致使主机系统瘫痪，如PingofDeath；第二类攻击是通过构造大量网络流量致使主机通信或网络堵塞，使系统不能相应正常的服务，如Smurf。 缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖了合法数据。利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果，更为严重的是可以利用它执行非授权指令，甚至可以取得系统特权并控制主机，进行各种非法操作。 考点二十一防火墙主要技术概述 依据防火墙的技术特征，常见的防火墙可以分为包过滤防火墙、代理防火墙和个人防火墙。 包过滤防火墙是面向网络底层数据流进行审计和控管，因此其安全策略主要根据数据包头的源地址、目的地址、端口号和协议类型等标志来指定，可见其主要工作在网络层和传输层。 代理防火墙是基于代理(Proxy)技术，使防火墙参与到每一个内、外网络之间的连接过程，防火墙需要理解用户使用的协议，对内部节点向外部节点的请求进行还原审查后，转发给外部服务器；外部节点发送来数据也需要进行还原审查，然后封装转发给内部节点。代理防火墙主要工作在应用层，有时也称为应用级网关。 个人防火墙使目前普通用户最常用的一种。个人防火墙是一种能保护个人计算机系统安全的软件，它可以直接在用户的计算机上运行，有效地帮助普通用户对系统进行监控及管理，使个人计算机免受各种攻击 

哈工大信息安全概论复习笔记(1) 哈工大信息安全概论复习笔记（1） 文章目录 哈工大信息安全概论复习笔记（1）考点一信息安全架构1面向目标的知识体系结构2面向应用的层次型技术架构3面向过程的信息安全保障体系4OSI开放系统互联安全体系结构 考点二密码体制的五要素考点三仿射密码考点四数据加密标准DES的算法结构和特点1S-DES(简化DES)算法结构：2DES的特点 考点五公钥密码的思想（数学描述）考点六离散对数问题1素数的原根2离散对数3求解离散对数 考点七Diffie-Hellman密钥交换协议 考点一信息安全架构 1面向目标的知识体系结构 信息安全CIA三元组(信息安全的三个最基本的目标)：C-机密性：信息在存储、传输、使用过程中，不会泄露给非授权用户或实体I-完整性：信息在存储、传输、使用过程中，不会被非授权用户篡改或防止授权用户对信息进行不恰当的篡改A-可用性：凡是为了确保授权用户或实体对信息资源的正常使用不会被异常拒绝，允许其可靠而及时地访问信息资源地相关理论技术均属于可用性范畴 如果组织最关心地是对私密信息地保护，就会特别强调机密性原则，如果组织最关心的是随时随地向客户提供正确的信息，那就会突出完整性和可用性的要求。 DAD三元组(信息安全面临的最普遍的三类风险)：D-泄漏、A-篡改、D-破坏 2面向应用的层次型技术架构 信息系统的基本要素：人员、信息、系统；人员-管理安全信息-内容安全、数据安全系统-运行安全、物理安全三者的五个层次安全有一定顺序关系，每个层次均为其上层提供基础安全保证 3面向过程的信息安全保障体系 信息安全保障体系包括四部分内容(PDRR)P-保护：指预先采取安全措施，阻止攻击可以发生的条件形成，让攻击者无法顺利地入侵。保护是被动防御，不可能完全阻止各种对信息系统的攻击行为。 D-检测：指依据相关安全策略，利用有关技术措施，针对可能被攻击者利用的信息系统的脆弱性进行具有一定实时性的检查，根据结果形成检测报告。 R-反应：指对于危及安全的事件、行为、过程及时做出适当的响应处理，杜绝危害事件进一步扩大，将信息系统受到的损失降低到最小。 R-恢复：指当危害事件发生后把系统恢复到原来状态或比原来状态更安全的状态，将危害的损失降到最小。 保护是最基本的被动防御措施，也是第一道防线；检测的重要目的之一是针对突破“保护防线”后的入侵行为进行探测预警；而反应是在检测报警后针对入侵采取的控制措施；恢复是针对攻击入侵带来的破坏进行弥补，是最后的减灾方法，如果前面的保障过程有效地控制了攻击行为，恢复过程则无须进行。 4OSI开放系统互联安全体系结构 安全服务：1.鉴别服务-用于确保某个实体身份的+可靠性2.访问控制-防止对任何资源的非授权访问3.数据机密性-确保只有经过授权的实体才能理解受保护的信息4.数据完整性-防止对数据的未授权修改和破坏5.抗抵赖性-也称不可否认性，用于防止对数据源以及数据提交的否认 安全机制：1.加密-用于保护数据的机密性2.数字签名-保证数据完整性及不可否认性的一种重要手段3.访问控制-与实体认证密切相关4.数据完整性-用于保护数据免受未经授权的修改5.鉴别交换-用于实现通信双方的实体身份鉴别(身份认证)6.业务流填充-针对的是对网络流量进行分析的攻击7.路由控制-可以指定数据报文通过网络的路径8.公证机制-由通信各方都信任的第三方提供 考点二密码体制的五要素 通常一个完整密码体制要包括如下五个要素，分别是M、C、K、E和D，具体定义如下： M-是可能明文的有限集，称为明文空间C-是可能密文的有限集，称为密文空间K-是一切可能密钥构成的有限集，称为密钥空间E-为加密算法，对于密钥空间的任一密钥加密算法都能够有效地计算D-为解密算法，对于密钥空间地任一密钥解密算法都能够有效地计算 一个密码体系如果是实际可用的，必须满足如下特性：1.加密算法 ( E k : M → C ) (E_k:M\rightarrowC) (Ek​:M→C)和解密算法 ( D k : C → M ) (D_k:C\rightarrowM) (Dk​:C→M)满足 D k ( E k ( x ) ) = x D_k(E_k(x))=x Dk​(Ek​(x))=x，这里 x ∈ M x\inM x∈M；2.破译者取得密文后，不能在有效的时间内破解出密钥k或明文x 考点三仿射密码 仿射密码是替换密码的一个特例，可以看做是移位密码和乘数密码的结合。其加密变换如下： E k ( m ) = ( k 1 m + k 2 ) m o d q E_k(m)=(k_1m+k_2)mod\spaceq Ek​(m)=(k1​m+k2​)mod q仿射密码的密钥为 ( k 1 , k 2 ) (k_1,k_2) (k1​,k2​)，其中， k 1 , k 2 ∈ ( 0 , q ) k_1,k_2\in(0,q) k1​,k2​∈(0,q)，且 k 1 k_1 k1​和q是互素的。其密码体系描述如下： M = C = Z / ( 26 ) ; q = 26 ; K = { k 1 , k 2 ∈ Z ∣ 0 < k 1 , k 2 < 26 , g c d ( k 1 , 26 ) = 1 } ; E k ( m ) = ( k 1 m + k 2 ) m o d q ; D k ( c ) = k 1 − 1 ( c − k 2 ) m o d q ; M=C=Z/(26);\\q=26;\\K=\{k_1,k_2\inZ|0<k_1,k_2<26,gcd(k_1,26)=1\};\\E_k(m)=(k_1m+k_2)mod\spaceq;\\D_k(c)=k_1^{-1}(c-k_2)mod~q; M=C=Z/(26);q=26;K={k1​,k2​∈Z∣0<k1​,k2​<26,gcd(k1​,26)=1};Ek​(m)=(k1​m+k2​)mod q;Dk​(c)=k1−1​(c−k2​)mod q;其中， k 1 − 1 k_1^{-1} k1−1​为 k 1 k_1 k1​在模q下的乘法逆元(不是倒数) gcd(k,q)=1表示k与q的最大公因子为1，即两者互素。 乘法逆元定义： k − 1 为 k 在 模 q 下 的 乘 法 逆 元 ， 其 定 义 为 k − 1 ∗ k m o d q = 1 k^{-1}为k在模q下的乘法逆元，其定义为k^{-1}*k~mod~q=1 k−1为k在模q下的乘法逆元，其定义为k−1∗k mod q=1 考点四数据加密标准DES的算法结构和特点 1S-DES(简化DES)算法结构： S-DES加密算法输入为一个8位的二进制明文组和一个10位的二进制密钥，输出为8位二进制密文组；解密与加密基本一致。算法共射击8个函数，两个与密钥变换有关的分别是置换函数P8、P10和循环移位函数Shift；4个基本函数用于数据加密变换，包括初始置换IP、复合函数 f k f_k fk​、转换函数SW以及末尾置换 I P − 1 IP^{-1} IP−1加密过程表达式： 密 文 = I P − 1 ( f k 2 ( S W ( f k 1 ( I P ( 明 文 ) ) ) ) ) 密文=IP^{-1}(f_{k_2}(SW(f_{k_1}(IP(明文))))) 密文=IP−1(fk2​​(SW(fk1​​(IP(明文)))))式中 k 1 = P 8 ( S h i f t ( P 10 ( k e y ) ) ) k 2 = P 8 ( S h i f t ( S h i f t ( P 10 ( k e y ) ) ) ) k_1=P8(Shift(P10(key)))\\k_2=P8(Shift(Shift(P10(key)))) k1​=P8(Shift(P10(key)))k2​=P8(Shift(Shift(P10(key))))解密过程表达式： 明 文 = I P − 1 ( f k 1 ( S W ( f k 2 ( I P ( 密 文 ) ) ) ) ) 明文=IP^{-1}(f_{k_1}(SW(f_{k_2}(IP(密文))))) 明文=IP−1(fk1​​(SW(fk2​​(IP(密文))))) 2DES的特点 DES是一种对二进制数据进行分组加密的算法，以64位为分组对数据加密，DES的密钥也是长度为64位的二进制数。加密算法和解密算法非常相似，唯一的区别在于子密钥的使用顺序正好相反。DES的整个密码体制是公开的，系统的安全性完全依赖于密钥的保密性。 考点五公钥密码的思想（数学描述） 公开密钥的核心思想：单向陷门函数如果函数 f ( x ) f(x) f(x)被称为单向陷门函数，必须满足以下三个条件 1.给定x，计算y=f(x)是容易的2.给定y，计算x使y=f(x)是困难的(所谓计算 x = f − 1 ( y ) x=f^{-1}(y) x=f−1(y)困难是指计算上相当复杂，已无实际意义)3.存在 δ \delta δ，已知 δ \delta δ时对给定的任何y，若相应的x存在，则计算x使y=f(x)是容易的注：（1）仅满足1、2条的称为单向函数；第3条称为陷门性， δ \delta δ称为陷门信息（2）当用陷门函数f作为加密函数时，可将f公开，这相当于公开加密密钥 P k P_k Pk​。f函数的设计者将 δ \delta δ保密，用做解密密钥，此时 δ \delta δ称为秘密钥匙 S k S_k Sk​。由于加密函数是公开的，任何人都可以将信息x加密成y=f(x)，然后发送给函数的设计者。由于设计者拥有 S k S_k Sk​，他自然可以利用 S k S_k Sk​求解 x = f − 1 ( y ) x=f^{-1}(y) x=f−1(y)。（3）单向陷门函数的第2条性质表明窃听者由截获的密文y=f(x)推测x是不可行的。 考点六离散对数问题 1素数的原根 若a是素数p的原根，则1. a m o d p , a 2 m o d p , … … , a p − 1 m o d p a~mod~p,a^2~mod~p,……,a^{p-1}~mod~p a mod p,a2 mod p,……,ap−1 mod p是不同的2.包含从1到p-1间所有正数的某种排列，对 ∀ b ∈ Z \forallb\inZ ∀b∈Z，有唯一的i，满足 b ≡ a i m o d p , ( 1 ≤ i ≤ p − 1 ) b\equiva^i~mod~p,(1\lei\lep-1) b≡ai mod p,(1≤i≤p−1)。注： b ≡ a i m o d p b\equiva^i~mod~p b≡ai mod p等价于 b m o d p = a i m o d p b~mod~p=a^i~mod~p b mod p=ai mod p，称为b与a模p同余。 2离散对数 若a是系数p的一个原根，则 ∀ b ∈ Z ( b m o d p ≠ 0 ) \forallb\inZ(b~mod~p\ne0) ∀b∈Z(b mod p​=0),必有在唯一的 i ( 1 ≤ i ≤ p − 1 ) , s . t . b ≡ a i m o d p 。 i(1\lei\lep-1),s.t.b\equiva^i~mod~p。 i(1≤i≤p−1),s.t.b≡ai mod p。i称为b的以a为基数且模p的幂指数，即离散对数。 3求解离散对数 对 y ≡ g x m o d p y\equivg^x~mod~p y≡gx mod p(g为系数p的原根，x与y均为正整数)，则1.从g，x，p计算y是容易的2.从g，y，p计算x是困难的注：离散对数的求解为数学界公认的困难问题 考点七Diffie-Hellman密钥交换协议 DH密钥交换算法的描述如下：Alice和Bob协商好一个大素数p和大的整数g，1<g<p，g是p的原根。p和g无须保密，可为网络上的所有用户共享。当Alice和Bob要进行保密通信时，他们可以按如下步骤来做 1.Alice选取大的随机数 x < p x<p x<p，并计算 Y = g x ( m o d P ) Y=g^x(mod~P) Y=gx(mod P)。2.Bob选取大的随机数 x ′ < p x^{'}<p x′<p，并计算 Y ′ = g x ′ ( m o d P ) Y^{'}=g^{x^{'}}(mod~P) Y′=gx′(mod P)。3.Alice将Y传送给Bob，Bob将 Y ′ Y^{'} Y′传送给Alice。4.Alice计算 K = ( Y ′ ) X ( m o d P ) K=(Y^{'})^X(mod~P) K=(Y′)X(mod P)，Bob计算 K = ( Y ) X ′ ( m o d P ) K=(Y)^{X^{'}}(mod~P) K=(Y)X′(mod P)。显而易见， K = K ′ = g x x ′ ( m o d P ) K=K^{'}=g^{xx^{'}}(mod~P) K=K′=gxx′(mod P)，即Alice和Bob已获得了相同的秘密值K。双发以K作为加解密钥，以传统对称密钥算法进行保密通信。 

哈工大信息安全概论复习笔记(2) 哈工大信息安全概论复习笔记（2） 文章目录 哈工大信息安全概论复习笔记（2）考点八RSA公钥算法考点九散列函数的特点和作用考点十EMI、EMC、防电磁泄漏主要方法考点十一容错与容灾的概念及主要技术方法考点十二windows的网络认证考点十三利用公开密钥和对称密钥设计认证协议获得会话密钥1基于对称密钥的认证协议2基于公开密钥的认证协议 考点十四Kerberos工作原理 考点八RSA公钥算法 RSA算法的数学基础是初等数论中的欧拉定理以及大整数因子分解问题。RSA密码体制是一种分组密码，明文和密文均是0到n之间的整数，n的大小通常为1024位二进制数或309位十进制数，因此，明文空间P=密文空间C= { x ∈ Z ∣ 0 < x < n , Z 为 整 数 集 合 } \{x\inZ|0<x<n,Z为整数集合\} {x∈Z∣0<x<n,Z为整数集合}。 RSA密码的密钥生成具体步骤如下。1.选择两个互异的素数p和q，计算 n = p q n=pq n=pq， ϕ ( n ) = ( p − 1 ) ( q − 1 ) \phi(n)=(p-1)(q-1) ϕ(n)=(p−1)(q−1)。2.选择整数e，使 g c d ( ϕ ( n ) , e ) = 1 gcd(\phi(n),e)=1 gcd(ϕ(n),e)=1，且 1 < e < ϕ ( n ) 1<e<\phi(n) 1<e<ϕ(n)。3.计算d，使 d ≡ e − 1 m o d ϕ ( n ) d\equive^{-1}~mod~\phi(n) d≡e−1 mod ϕ(n)，即d为模 ϕ ( n ) \phi(n) ϕ(n)下e的乘法逆元 则公开密钥 P k = { e , n } P_k=\{e,n\} Pk​={e,n}，私用密钥 S k = { d , n , p , q } S_k=\{d,n,p,q\} Sk​={d,n,p,q}。当明文为m，密文为c，加密时使用公开密钥 P k P_k Pk​，加密算法 c = m e m o d n c=m^e~mod~n c=me mod n；解密时使用私用密钥 S k ， m = c d m o d n S_k，m=c^d~mod~n Sk​，m=cd mod n。故e也被称为加密指数，d被称为解密指数。 考点九散列函数的特点和作用 散列函数的目的：将任意长的消息映射成一个固定长度的散列值(Hash值)，也称为消息摘要。消息摘要可以作为认证符，完成消息认证。健壮性：1.弱无碰撞性：指在消息特定的明文空间X中，给定消息 x ∈ X x\inX x∈X，在计算机上几乎找不到不同于x的 x ′ , x ′ ∈ X ， 使 得 h ( x ) = h ( x ′ ) x^{'},x^{'}\inX，使得h(x)=h(x^{'}) x′,x′∈X，使得h(x)=h(x′)。2.强无碰撞性：指在计算机上几乎找不到不同于x的 x ′ ， 使 得 h ( x ) = h ( x ′ ) ， x ′ 可 以 不 属 于 X x^{'}，使得h(x)=h(x^{'})，x^{'}可以不属于X x′，使得h(x)=h(x′)，x′可以不属于X。注：强无碰撞自然包含弱无碰撞3.单向性：指通过h的逆函数 h − 1 h^{-1} h−1来求得散列值h(x)的消息原文x在计算上不可行。 考点十EMI、EMC、防电磁泄漏主要方法 电磁干扰(EMI)：指一切与有用信号无关的、不希望有的或对电器及电子设备产生不良影响的电磁发射。防止EMI要从两方面考虑，一方面要减少电子设备的电磁发射，另一方面要提高电子设备的电磁兼容性(EMC)。 电磁兼容性(EMC)：指电子设备在自己正常工作时产生的电磁环境，与其他电子设备之间相互不影响的电磁特性。 防电磁信息泄漏的基本思想主要包括三个层面：1.抑制电磁发射2.屏蔽隔离3.相关干扰 常用的防电磁泄漏的方法有三种：1.屏蔽法-主要用来屏蔽辐射及干扰信号2.频域法-主要解决正常的电磁发射受干扰问题3.时域法-与频域法相似，时域法也是用来回避干扰信号 考点十一容错与容灾的概念及主要技术方法 容错基本思想：即使出现了错误，系统也可以执行一组规定的程序；或者说，程序不会因为系统中的故障而中断或被修改，并且故障也不会引起运行结果的差错。简单地说，容错就是让系统具有抵抗错误带来的能力。 容错系统可分为五种类型：1.高可用度系统2.长寿命系统3.延迟维修系统4.高性能系统5.关键任务系统 常用数据容错技术主要有以下四种：1.空闲设备-当正常运行的部件出现故障时，原来空闲的一台立即替补2.镜像-把一份工作交给两个相同的部件同时进行3.复现-也称延迟镜像，原系统故障时，辅助系统只能在接近故障点的地方开始工作。同一时间只需要管理一套设备4.负载均衡-将一个任务分解成多个子任务，分配给不同的服务器执行。 容灾含义：对偶然事故的预防和恢复 解决方案：一是对服务的维护和恢复，二是保护或恢复丢失的、被破坏的或被删除的信息。只有两者结合起来才能提供完整的灾难恢复方案。 常用恢复策略：1.做最坏的打算2.充分利用现有资源3.既重视灾后恢复也重视灾前措施 考点十二windows的网络认证 用户登入时的身份认证过程也是采用对称密钥加密来完成的用户与主域控制器共享口令，在域控制器的安全用户管理(SAM)数据库中保存注册用户的用户名、口令的散列以及其他信息。 用户登录具体过程：1.用户先激活winlogon窗口，并输入用户名和口令，然后向域控制器发送登录请求，同时计算出口令的散列，口令及其散列不包含在登录请求信息中。2.域控制器收到登录请求后产生一个8字节的质询(挑战)并发送给客户端，同时取出给用户的口令散列，用此口令散列对质询进行散列计算(也称加密)，得到质询散列。3.客户端收到8字节的质询后，首先使用前边计算得到的口令散列对质询进行散列计算，得到质询散列，随后将计算出的质询散列作为应答发送给域控制器。4.域控制器比对其算出的质询散列和用户应答回送的质询散列，如果相同则登录认证通过，否则登录认证失败，同时向用户发送登录认证结果。 考点十三利用公开密钥和对称密钥设计认证协议获得会话密钥 描述符号： A → B A\rightarrowB A→B表示A向B发送信息 E k ( x ) E_k(x) Ek​(x)表示使用共享密钥k对信息进行加密 x ∣ ∣ y x||y x∣∣y表示信息串x和y相连接 1基于对称密钥的认证协议 只有少量用户的封闭网络系统，使用挑战-应答方式认证对于规模较大的网络系统，依靠可靠的第三方完成认证 基于挑战应答方式的认证协议：1. A → B : I D a ∣ ∣ I D b A\rightarrowB:ID_a||ID_b A→B:IDa​∣∣IDb​2. B → A : N b B\rightarrowA:Nb B→A:Nb3. A → B : E k ( N b ) A\rightarrowB:E_k(Nb) A→B:Ek​(Nb) 2基于公开密钥的认证协议 A要认证B，有以下两种方式：（1）1.A向B发送明文挑战(挑战因子/随机数)2.B用私钥加密(签名)，返回给A3.A用B的公钥解密，比对，完成认证（2）1.A用B的公钥加密挑战因子(或随机数)发送给B2.B用私钥解密，返回明文给A3.A比对，完成认证 考点十四Kerberos工作原理 Kerberos协议的认证过程分为三个阶段，六个步骤第一阶段身份验证服务交换：完成身份认证，获得访问TGS的票据(1) C → A S : I D C ∣ ∣ I D t g s ∣ ∣ T S 1 C\rightarrowAS:ID_C||ID_{tgs}||TS_1 C→AS:IDC​∣∣IDtgs​∣∣TS1​(2) A S → C : E K C [ K C , t g s ∣ ∣ I D t g s ∣ ∣ T S 2 ∣ ∣ L i f e t i m e 2 ∣ ∣ T i c k e t t g s ] AS\rightarrowC:E_{KC}[K_{C,tgs}||ID_{tgs}||TS_2||Lifetime_2||Ticket_{tgs}] AS→C:EKC​[KC,tgs​∣∣IDtgs​∣∣TS2​∣∣Lifetime2​∣∣Tickettgs​] 注：步骤(1)为请求TGS票据 I D C : ID_C: IDC​:ClientC的用户标识 I D t g s : ID_{tgs}: IDtgs​:用请求访问的TGS的标识 T S 1 : TS_1: TS1​:让AS验证ClientC的时钟是与AS的时钟是否同步的 步骤(2)为返回TGS票据 E K C : E_{KC}: EKC​:基于用户口令的加密，使得AS和ClientC可以验证口令，并保护消息 K C , t g s : K_{C,tgs}: KC,tgs​:由AS产生，用于在TGS和ClientC之间信息的安全交接 I D t g s : ID_{tgs}: IDtgs​:确认这个ticket是为特定TGS制作的 T S 2 : TS_2: TS2​:告诉用户该ticket签发的时间 L i f e t i m e 2 : Lifetime_2: Lifetime2​:告诉用户该ticket的有效期 T i c k e t t g s : Ticket_{tgs}: Tickettgs​:用户用来访问TGS的ticket，可重用，避免多次认证输入口令，其中， T i c k e t t g s = E K t g s [ K C , t g s ∣ ∣ I D c ∣ ∣ A D C ∣ ∣ I D t g s ∣ ∣ T S 2 ∣ ∣ L i f e t i m e 2 ] Ticket_{tgs}=E_{Ktgs}[K_{C,tgs}||ID_c||AD_C||ID_{tgs}||TS_2||Lifetime_2] Tickettgs​=EKtgs​[KC,tgs​∣∣IDc​∣∣ADC​∣∣IDtgs​∣∣TS2​∣∣Lifetime2​] 第二阶段票据授予服务交换：获得访问应用服务器的票据。(3) C → T G S : I D V ∣ ∣ T i c k e t t g s ∣ ∣ A u t h e n t i c a t o r C C\rightarrowTGS:ID_V||Ticket_{tgs}||Authenticator_C C→TGS:IDV​∣∣Tickettgs​∣∣AuthenticatorC​(4) T G S → C : E K C , t g s [ K C , V ∣ ∣ I D V ∣ ∣ T S 4 ∣ ∣ T i c k e t V ] TGS\rightarrowC:E_{K_{C,tgs}}[K_{C,V}||ID_V||TS_4||Ticket_V] TGS→C:EKC,tgs​​[KC,V​∣∣IDV​∣∣TS4​∣∣TicketV​] 注：步骤(3)为请求应用服务器票据 I D V : ID_V: IDV​:告诉TGS用户要访问应用服务器V T i c k e t t g s : Ticket_{tgs}: Tickettgs​:向TGS证实该用户已被AS认证 A u t h e n t i c a t o r C : Authenticator_C: AuthenticatorC​:由用户生成，用于验证时效性 A u t h e n t i c a t o r C = E K C , t g s [ I D C ∣ ∣ A D C ∣ ∣ T S 3 ] Authenticator_C=E_{K_{C,tgs}}[ID_C||AD_C||TS_3] AuthenticatorC​=EKC,tgs​​[IDC​∣∣ADC​∣∣TS3​] 步骤(4)为返回应用服务器票据 E K C , t g s [ ] : E_{K_{C,tgs}}[]: EKC,tgs​​[]:使用ClientC和TGS共享的密钥加密，用以保护本消息 K C , V : K_{C,V}: KC,V​:由TGS生成，用于ClientC和ServerV之间信息的安全交换； I D V : ID_V: IDV​:确认该ticket是签发给setcerV的 T S 4 : TS_4: TS4​:告诉用户该ticket签发的时间 T i c k e t V : Ticket_V: TicketV​:用户用以访问应用服务器V的ticket，其中， T i c k e t V = E K V [ K C , V ∣ ∣ I D C ∣ ∣ A D C ∣ ∣ I D V ∣ ∣ T S 4 ∣ ∣ L i f e t i m e 4 ] Ticket_V=E_{KV}[K_{C,V}||ID_C||AD_C||ID_V||TS_4||Lifetime_4] TicketV​=EKV​[KC,V​∣∣IDC​∣∣ADC​∣∣IDV​∣∣TS4​∣∣Lifetime4​] E K V [ ] : E_{K_V}[]: EKV​​[]:Ticket用只有TGS和ServerV共享的密钥加密，以预防篡改 第三阶段客户与服务器身份验证交换：获得服务(5) C → V : T i c k e t V ∣ ∣ A u t h e n t i c a t o r C\rightarrowV:Ticket_V||Authenticator C→V:TicketV​∣∣Authenticator(6) V → C : E K C , V [ T S 5 + 1 ] ( f o r m u t u a l a u t h e n t i c a t i o n ) V\rightarrowC:E_{K_{C,V}}[TS_5+1](for~mutual~authentication) V→C:EKC,V​​[TS5​+1](for mutual authentication) 注：步骤(5)为向应用服务器发起服务请求。 T i c k e t V : Ticket_V: TicketV​:向服务器证实该用户已被AS认证 A u t h e n t i c a t o r C : Authenticator_C: AuthenticatorC​:由ClientC生成用于验证时效性 A u t h e n t i c a t o r C = E K C , V [ I D C ∣ ∣ A D C ∣ ∣ T S 5 ] Authenticator_C=E_{K_{C,V}}[ID_C||AD_C||TS_5] AuthenticatorC​=EKC,V​​[IDC​∣∣ADC​∣∣TS5​] E K C , V [ ] : E_{K_{C,V}}[]: EKC,V​​[]:使用ClinetC和ServerV的共享密钥加密，来验证身份并保护本信息 步骤(6)为服务器对客户机可选的身份认证 T S 5 + 1 : TS_5+1: TS5​+1:向ClientC证明这不是重放攻击的应答 

计算机系统大作业 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机 学 号 1190202210 班 级 1936602 学 生 XXX 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本文简述了hello.c程序从编写完成后，经过预处理，编译，汇编，链接等过程，形成可执行目标文件hello的过程，以及从进程hello的创建到执行，最后被回收的过程，并结合hello分析了内存地址，内存分配，I/O设备管理等知识，从而对计算机系统有了更加深入的理解。 关键词：预处理；编译；汇编；链接；进程；存储管理；I/O管理 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 Hello的P2P：（fromprogramtoprocess） hello.c文件经过预处理器cpp生成.i文件，再经过编译器编译，将高级语言转化为指令，生成.s文件，再经过汇编(as)生成二进制.o文件，最后经过链接器与c标准库动态链接，生成可执行的二进制目标文件hello。在shell中输入./hello参数1参数2，shell调用fork函数，execve函数创建新的进程。 020的过程：（fromzerotozero）: shell调用fork创建新的子程序，在子程序中调用execve，加载并运行helllo,映射虚拟内存，进入main函数执行目标代码。当程序运行结束后，shell父进程回收hello进程，内核删除相关数据结构。 1.2环境与工具 硬件环境：IntelCorei58265U 软件环境：Ubuntu18.04.1,Windows10 开发与调试工具:CodeBlocks，vim，gcc，edb，readelf，gdb 1.3中间结果 hello.i：预处理器cpp预处理之后的文件 hello.s：生成的汇编文件 hello.o：可重定位目标文件 hello：链接后生成的可执行目标文件 hello_elf.txt：hello的ELF分析 hello_o_elf.txt：hello.o的ELF分析 hello_o.txt：hello.o的反汇编文件 hello_obj.txt:hello的反汇编文件 1.4本章小结 本章简要介绍了hello的p2p,020过程，以及开发环境和生成的中间文件。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 概念：预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。预处理器（cpp）根据以字符#开头的命令，修改原始的c程序 作用： 根据以字符#开头的命令，修改原始的c程序 1#include 预处理指令，包含头文件的操作，将所包含头文件的指令替代 （如果头文件中包含了其他头文件，也需要将头文件展开包含） 2#define宏定义 将所有的#define删除，并且展开所有的宏定义 3处理所有条件编译指令，如#if等 4删除用户的注释 2.2在Ubuntu下预处理的命令 图2.1预处理命令 2.3Hello的预处理结果解析 1）例如在Hello.c中，#include<stdio.h>命令告诉预处理器读取系统头文件 stdio.h的内容,并把它插入程序中。其他命令类似，结果就得到了hello.i 图2.2hello.i 2）如图，发现hello.c中的注释被删除，加入了头文件 图2.3hello.i 2.4本章小结 本章介绍了hello.c经过预处理后生成hello.i文件的过程，以及预处理的概念和作用。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：利用编译程序从源语言编写的源程序产生目标程序的过程。 作用：编译器(ccl)将文本文件hello.i翻译咸文本文件hello.s,它包含一个汇编语言程序。汇编语言为不同高级语言的不同编译器提供通用的输出语言. 3.2在Ubuntu下编译的命令 图3.1编译命令 3.3Hello的编译结果解析 图3.2hello.s文件 图3.3hello.s文件 3.3.1数据 字符串常量 Printf中的字符串常量，放在.rodata段 （2）局部变量inti 是局部变量，保存在栈上，存储在-4(%rbp)处 （3）全局变量intsleepsec=2.5 图3.4sleepsec globl代表sleepsecs是全局变量，将sleepsecs存放在.data节，类型是对象,分配大小4字节，.long定义为长整型数2。 （4）参数intargc 参数，程序中通过访问栈上-20(%rbp)的位置访问。表示参数个数 （5）数组char*argv[] 是main函数的参数，在此程序hello中存放着输入的字符串姓名和学号 3.3.2赋值 （1）i=0 图3.5i=0赋值 使用指令movl将立即数0存入-4（%rbp）处 i++ 图3.6i++赋值 用addl指令完成i=i+1 3.3.3关系操作 （1）if(argc!=3) 图3.7关系比较 cmpl比较argc和3，并设置条件码，je判断是否相等，是则跳转 循环测试条件i<10 图3.8关系比较 cmpl比较i和9，jle判断若i<=9则跳转至.L4 3.3.4控制转移 （1）if(argc!=3) 图3.9条件跳转 je判断argc和3是否相等，是则跳转至.L2 for(i=0;i<10;i++) 图3.10条件跳转 jle判断若i<=9则跳转至.L4 3.3.5函数操作 （1）main main函数有两个参数，argc，和*argv[]，传参过程中，argc保存在寄存器rsi，*argv[]保存在运行时栈中 printf 图3.11调用printf 参数在%eax中准备 exit 图3.12调用exit 准备参数，参数是1 getchar 图3.13调用getchar 循环结束后被调用，无参数传递 sleep 参数被保存在%edi中传递，然后使用call调用sleep 图3.14调用sleep 3.4本章小结 本章介绍了编译的过程，通过对文件hello.s的分析，对汇编语言有了进一步理解，汇编语言为不同高级语言的不同编译器提供通用的输出语言。同时本章分析了编译过程中对赋值语句，控制转移，函数调用等过程的处理，进一步理解了编译过程。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：把汇编语言书写的程序翻译成与之等价的机器语言程序。汇编语言是为特定计算机或计算机系列设计的一种面向机器的语言，由汇编执行指令和汇编伪指令组成。 作用：汇编器（as）将hello.s翻译成机器语言指令，并把这些指令打包成可重定位目标程序的格式，将结果保存在二进制目标文件hello.o中。 4.2在Ubuntu下汇编的命令 图4.1汇编命令 4.3可重定位目标elf格式 （1）各节的基本信息： 图4.2ELF头 图4.2各节信息 .text:代码节 .rela.text一个.text节中位置的列表 .data:已初始化的全局变量，静态c变量， .bss：未初始化的全局变量和静态c变量，。 .rodata:只读数据，如printf中的格式串和switch中的跳转表， .symtab:装载符号信息 （2）重定位节 图4.3重定位节 重定位节：.rela.text,一个.text节中位置的列表，包含.text节中需要进行重定位的信息，链接时需要修改这些位置。调用本地函数的指令则不需要修改。 offset：需要进行重定向的代码在.text或.data节中的偏移位置 type：代表重定位的类型（PC相对寻址或PC绝对寻址） 符号名称：重定向到的目标对象的名称 （3）符号表 图4.4符号表 程序中定义和引用符号的信息 4.4Hello.o的结果解析 图4.5反汇编命令 汇编语言根据规则编码成机器指令，每个指令1-10个字节。 图4.6反汇编文件 图4.6反汇编文件 以上图第一个圈中的指令为例，488d3800000000中的00000000是占位符，此处需要在链接时进行重定位，通过PC相对寻址确定最终的指令字节，其余几处操作数与.s文件中不同的情况类似。以第二个圈为例，分支转移和函数调用时，同样需要在链接时通过重定位确定最后的地址，以重定位后的地址字节替换现在的机器指令中的占位符00000000 4.5本章小结 本章分析了汇编的概念及作用，分析了汇编语言和机器语言的关系，并介绍了机器指令中操作数与汇编语言不同的情况，对汇编过程以及重定位有了进一步认识。 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：链接是指将各种代码和数据片段收集并组合成为一个单一文件的过程。这个文件可以被加载到内存并执行。 作用：链接使得分离编译成为可能，不用将大型应用组织为一个巨大的源文件，而是可以将它们分解为更小，更好管理的模块，可以独立地修改和编译这些模块。当改变这些模块中地一个时，只需要重新编译它，并重新链接应用，而不必重新编译其他文件。 5.2在Ubuntu下链接的命令 命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1链接命令 链接后执行： 图5.2执行程序 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 图5.3readelf命令 ELF头： 图5.4ELF头 各段的起始地址及大小信息： 图5.5各节信息 图5.6各节信息 图5.7各节信息 5.4hello的虚拟地址空间 代码段地址从0x401000开始 图5.8edb调试 与5.3对照： .interp节，地址从0x400200开始 图5.9edb调试 .dynstr节，从0x400359开始 图5.10edb调试 .text节 地址从0x400500开始 图5.11edb调试 图5.12edb调试 .rodata节 地址从0x400640开始，printf中的格式字符串等存放在这里 图5.13edb调试 各节的起始地址及大小信息与5.3中一样 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同 图5.14objdump命令 不同： （1）hello中比hello.o中多了.init和.plt部分 图5.15对比不同 （2）增加了put,printf,getchar,exit,sleep函数，说明链接器将库里被应用程序引用的目标模块复制过来了 图5.16 对比不同 （3）重定位 在hello.o由占位符0x00占位的指令编码在hello中完成了重定位 图5.17重定位 图5.18重定位 以调用exit函数为例，在确定.text节起始地址为0x400500及exit函数地址为0x4004e0后，由refaddr=ADDR(s)+r.offset=0x400559计算出引用的运行时地址， 再由*refptr=(unsigned)(0x4004e0+(-4)–0x400559)=0xff83更新引用时的call指令为e883ffffff（在hello.o中是e800000000），完成一个重定位。 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 Edb执行过程： 图5.19 edb执行 Gdb调试过程： 图5.20gdb调试 1.从加载hello到_start调用及跳转的子程序名及地址 图5.21gdb调试 2.从_start到callmain调用及跳转的子程序名及地址 图5.22gdb调试 3.从callmain到程序终止调用及跳转的子程序名及地址 图5.23gdb调试 5.7Hello的动态链接分析 dl_init前 图5.24edb调试 dl_init后 图5.25edb调试 GOT与dl_init之前不同，即发生了动态链接 5.8本章小结 本章介绍了链接器将hello.o与动态库函数链接，最终生成可执行文件按hello的过程，包括符号解析和重定位，分析ELF头等，对链接的相关知识有了进一步了解。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：一个正在运行的程序的实例 作用：进程提供给应用程序两个关键抽象：一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器；一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 shell 是一个交互型应用级程序，代表用户运行其他程序 （1）作用：解释由用户输入的命令并且把它们送到内核 （2）处理流程： 1.读取用户由键盘输入的命令； 2.对命令进行分析，以命令名为文件名，并将其他参数改造为系统调用execve()参数处理所要求的格式； 3.终端进程(shell)调用fork()建立一个子进程； 4.子进程根据文件名（命令名）到目录中查找有关文件，将他调入内存，并创建新的文本段，并根据写时拷贝的方式创建相应的数据段、堆栈段； 5.当子进程完成处理或者出现异常后，通过exit()或_exit()函数向父进程报告； 6.终端进程调用wait函数来等待子进程完成，并对子进程进行回收； 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的、处于运行状态的子进程： intfork(void) 子进程返回0，父进程返回子进程的PID 新创建的子进程几乎但不完全与父进程相同： 子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本 子进程获得与父进程任何打开文件描述符相同的副本 子进程有不同于父进程的PID （fork函数：被调用一次，却返回两次） 6.4Hello的execve过程 intexecve(char*filename,char*argv[],char*envp[]) execve函数加载并运行可执行文件hello,在当前进程中载入并运行程序，覆盖当前进程的代码、数据、栈，继承已打开的文件描述符和信号上下文，调用一次并从不返回 6.5Hello的进程执行 一个进程执行它的控制流的一部分的每一时间段叫做时间片。内核为每个进程维持一个上下文，在进程执行地某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策叫调度。内核调度了新进程后，使用上下文切换的机制将控制转移到新的进程。 上下文切换：1.保存当前进程的上下文。2.恢复某个先前被抢占的进程保存的上下文。3.将控制传递给这个新恢复的进程。 执行hello时，调用sleep函数时，它显式地请求让调用进程休眠，进程可以执行上下文切换，运行另一个进程，休眠结束后，内核再次执行上下文切换，将控制转移到此进程。 当hello调用getchar时，实际上是执行系统read。hello运行在用户模式中，直到它通过执行系统调用read陷入内核。内核中的陷阱处理程序请求来自磁盘控制器的DMA传输，并且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。磁盘读取数据要用一段相对较长的时间，所以内核决定执行上下文切换。直到磁盘发出一个中断信号，表示数据读入内存，内核再进行上下文切换，将控制返回给hello。 图6.1 上下文切换 6.6hello的异常与信号处理 Hello执行过程中，调用printf,getchar函数时会产生的异常是陷阱，向内核请求服务；键盘按下Ctrl-Z，Ctrl-C时产生的异常是中断。 Ctrl-C 内核发送SIGINT信号给到前台进程组中的每个进程，通过ps和jobs,fg等查看，发现hello进程被回收 图6.2ctrl-c 图6.3ctrl-c （2）Ctrl+z Ctrl+z的输入发送一个SIGTSTP信号让进程停止，运行ps,jobs,fg命令查看，发现hello进程被停止 图6.4ctrl-z （3）乱按和回车 按下回车后，乱输入的字符会被当做命令处理 图6.5乱按加回车 6.7本章小结 本章介绍了进程的相关知识，包括进程的创建，回收，以及上下文切换，信号处理等知识，分析了hello进程的执行过程，具体分析了fork函数，execve函数，异常和信号处理过程，对相关知识有了进一步理解。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 （1）虚拟地址由hello程序产生的由段选择符和段内偏移地址组成的地址。 （2）逻辑地址指由程序产生的段内偏移。有时候直接把逻辑地址当做虚拟地址。例如hello中jump等跳转指令的地址。 （3）线性地址指虚拟地址到物理地址变换的中间层，是处理器可寻址的内存空间中的地址。程序代码会产生逻辑地址，也就是段中的偏移地址，加上相应的段基址就成了线性地址。如果开启了分页机制，那么线性地址需要再经过变换，转为为物理地址。如果无分页机制，那么线性地址就是物理地址。 （4）物理地址指CPU外部地址总线上寻址物理内存的地址信号，是地址变换的最终结果。计算机系统的主存被组织成一个连续的字节的单元组成的数组，每字节有唯一的物理地址 7.2Intel逻辑地址到线性地址的变换-段式管理 逻辑地址实际是由 48 位组成的，前 16 位包括段选择符,后 32 位段内偏移量(段指可执行文件hello中的代码段、数据段等)，通过索引在描述符表中找到段基址（Linux中段基址为0），例如指令movl8(%ebp)中有效地址EA=R[%ebp]+8,最后得到线性地址LA=段基址+EA。 7.3Hello的线性地址到物理地址的变换-页式管理 从线性地址（虚拟地址）（VA）到物理地址(PA)的变换是通过分页机制来实现的。VM系统将虚拟内存分割为称为虚拟页（VP）的大小固定块，在linux下为4KB。相应地，物理内存被分割为物理页，大小也为4KB。 CPU的页式内存管理单元MMU负责把一个线性地址转换为物理地址。例如，一个32位的机器，线性地址可以达到4G，若页大小为4KB，则划分为1M个页，即需要1M个PTE，每一项PTE存储的都是对应物理页的基地址。 7.4TLB与四级页表支持下的VA到PA的变换 TLB是一个小的，虚拟寻址的缓存，每一行保存着由单个PTE组成的块。用来压缩页表的常用方式是层次结构的页表。四级页表支持下，虚拟地址（VA）被划分为4个VPN和一个VPO，每个VPNi都是一个到第i级页表的索引，第j级页表中的每个PTE都指向第某个j+1级页表的基址。CPU产生一个VA，MMU根据VPN在TLB中搜索PTE，若命中，MMU取出相应的PTE，根据PTE将VA翻译成PA；若不命中，则通过多级页表查询PTE是否在页中，若在页中，找到对应的PTE，MMU将VA翻译成PA，若没有在页中，则进行缺页处理。如下图，L4PTE指向页的物理地址（物理页号PPN）,PPN和PPO（偏移量，和VPO相同）组成了物理地址（PA）。 图7.1 四级页表下的地址转换 7.5三级Cache支持下的物理内存访问 物理地址PA在cache的机制下由块偏移（CO）、组索引（CI）和标记（CT）组成。首先，在L1-cache中，使用组索引CI找到对应的组，在组中若存在标记位为CT且有效位为1的块，则命中，根据块偏移CO取出相应的字节发送到CPU；若不命中，则向下一级缓存中查找块（L2-cache是L1的下一级缓存，L3-cache是L2的下一级缓存，主存是L3的下一级缓存）。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核创建了一个新进程，为新进程创建各种数据结构，并分配给它唯一的PID。为了创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本，它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。任一进程进行写时操作时，写时复制机制创建新页面，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 加载并运行hello需要以下步骤： 删除当前进程虚拟地址已存在的用户区域映射私有区域。为代码，数据，bss和栈区域创建新的区域结构映射共享区域。Hello程序与C标准库libc.so等链接，这些对象都是动态链接到这个程序，然后再映射到用户虚拟地址空间中的共享区域内。设置PC，使之指向代码区域的入口点。 图7.2 内存映射 7.8缺页故障与缺页中断处理 MMU翻译虚拟地址时若触发一个缺页，控制转移到内核的缺页处理程序，执行以下步骤： 虚拟地址A是否合法，若不合法，触发段错误，终止进程。试图进行的内存访问是否合法，若不合法，触发保护异常，终止进程。若是合法操作，选择一个牺牲页面交换出去，换入新的页面并更新页表。缺页处理程序返回时，CPU重新启动引起缺页的指令，再次发送A到MMU，这时MMU正常翻译虚拟地址A，不会产生缺页。 图7.3缺页处理 7.9动态存储分配管理 分配器将堆视为一组不同大小的块(blocks)的集合来维护，每个块要么是已分配的，要么是空闲的，需要时选择一个合适的内存块进行分配。分配器有两种基本风格：显式分配器和隐式分配器。两种风格都要求应用显式的分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 分配器利用隐式空闲链表管理块的策略： 1.放置已分配的块 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲块。常见的放置策略有：首次适配、下一次适配、最佳适配。 （1）首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。 （2）下一次适配：从上一次查询结束的地方开始，搜索空闲链表，选择第一个合适的空闲块 （3）最佳适配：检查每个空闲块，选择合适所需请求大小的最小空闲块。 2.分割空闲块 如果匹配不太好，那么分配器通常会选择将这个空闲块分割为两部分。第一部分变成分配块，而剩下的变成一个新的空闲块。 3.合并空闲块 分配器可以选择立即合并或者推迟合并。立即合并就是在每次一个块被释放时，就合并所有的相邻块。推迟合并是等到某个稍晚的时候再合并空闲块。 7.10本章小结 本章分析了存储管理的相关知识，以hello为例分析了从逻辑地址到线性地址，再到物理地址的地址转换与寻址过程，介绍了hello运行时的内存映射，以及缺页故障的处理过程。此外，还分析了动态存储分配管理的基本方式和几种策略，对存储管理的相关知识有了更深入的了解。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 Linux以文件的方式对I/O设备进行读写，将设备均映射为文件。对文件的操作，内核提供了一种简单、低级的应用接口，即UnixI/O接口。 函数： 1）open 打开文件返回一个小的非负整数，即描述符。用描述符来标识文件。每个进程都有三个打开的文件：标准输入（0）、标准输出（1）、标准错误（2） 函数原型：intopen(char*filename,intflags,mode_tmode); （flags:进程打算如何访问文件； O_RDONLY:只读 O_WRONLY:只写 O_RDWR:可读可写 mode:指定新文件的访问权限位） 2）lseek 函数原型：off_tlseek(intfd,off_toffset,intwhence); 返回值：成功返回新的文件偏移量，失败-1 3）read 读操作：从文件拷贝n个字节到存储器，从当前文件位置k开始，将k增加到k+n，对于一个大小为m字节的文件，当k>=m时，读操作触发一个EOF的条件。 函数原型：ssize_tread(intfd,void*buf,size_tn); 返回值是文件读取字节数 4）write 写操作：从存储器拷贝n个字节到文件，k更新为k+n 函数原型：ssize_twrite(intfd,constvoid*buf,size_tn); 返回值：文件写入字节数 5）关闭文件 内核释放文件打开时创建的数据结构，并恢复描述符到描述符池中，进程通过调用close函数关闭一个打开的文件。（关闭一个已关闭的描述符会出错） 函数原型 intclose(intfd) 返回值：成功返回0 失败-1 8.3printf的实现分析 printf函数的函数体： intprintf(constchar*fmt, ){inti;charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } 实现过程： 1）.vsprintf生成显示信息：vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 2）.调用write系统函数， write: moveax,_NR_write movebx,[esp+4] movecx,[esp+8] intINT_VECTOR_SYS_CALL 3）.陷阱-系统调用int0x80或syscall. sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret 4）.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 最终，屏幕上显示出要显示的字符。 8.4getchar的实现分析 getchar函数的函数体： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(–n>=0)?(unsignedchar)*bb++:EOF; } 实现过程： 1）异步异常-键盘中断的处理：系统调用键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 2）getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。当用户键入回车之后，getchar才开始从stdio流中每次读入一个字符。函数的返回值是用户输入的字符的ASCII码，若读到文件结尾(End-Of-File)则返回-1(EOF)，且将用户输入的字符回显到屏幕。 8.5本章小结 本章介绍了hello的IO管理，包括对UnixIO的简介以及对printf函数和getchar函数的详细分析，对Linux的IO设备管理有了进一步认识。 （第8章1分） 结论 Hello的一生走过了以下历程： 用高级语言编写成代码hello.c,先经过预处理，生成hello.i,再经过编译，生成hello.s文件，经过汇编，生成可重定位的hello.o二进制文件。接着，链接器将hello.o与动态库函数链接到一起，生成最后的可执行文件hello。在shell中执行./hello,开始为hello创建进程并将hello程序加载到内存中运行，如遇到异常则要进行异常，最后程序执行结束，进程被回收，hello结束了它的一生。 我对计算机系统的设计与实现的感悟：本门课程的知识量很丰富，计算机系统的设计与实现是一个复杂的过程，其中需要考虑各种各样的因素，为了更好的性能还需要不断尝试和创新。 （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.i：预处理器cpp预处理之后的文件 hello.s：编译生成的汇编文件 hello.o：汇编后的可重定位目标文件 hello：链接后生成的可执行目标文件 hello_elf.txt：hello的ELF分析 hello_o_elf.txt：hello.o的ELF分析 hello_o.txt：hello.o的反汇编 hello_obj.txt:hello的反汇编文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1]兰德尔E.布莱恩特,大卫R.奥哈拉伦.深入理解计算机系统.机械工业出版社 [2]虚拟地址、逻辑地址、线性地址、物理地址-简书(jianshu.com) [3]https://baike.baidu.com/item/%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/10204389?fr=aladdin百度百科：预处理命令 [4]https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343?fr=aladdin百度百科：编译 [5]编译原理入门篇|一篇文章理解编译全过程-fishers-博客园(cnblogs.com) 

李宏毅机器学习（1） Regression 1.什么是Regression Regression，有道词典翻译为拟合，就是构建一个函数，通过输入特征值，得到预测的结果。举例说明：①股市预测②自动驾驶③商品推荐由此可见，Regression可以做很多东西，其主要功能还是预测。 Regression的步骤 一个有趣的例子就是预测宝可梦进化后的CP（战斗力）值。问题可以描述为： 输入：宝可梦进化前的CP值，种类，属性，血量，重量，高度。输出：宝可梦进化后的CP值。 Step1确定模型 模型的种类有很多，但最经典的还是多项式模型，其中最简单的就是线性模型。这一题中用的就是多项式函数模型，不妨先认为进化前的cp值（x值）和进化后的cp值（y值）满足线性关系。 y=w·x+b 显然我们要求的就是w和b值。 Step2GoodnessofFunction 1、获取trainingdata 为了让我们的函数走向正确的道路，我们还需要采集数据，形成trainingdataset，引导函数参数的变化。 2、设计LossFunction 为了评价我们设计的function的好坏（goodnessoffunction），还需要设计一个LossFunction，它将构建好的函数作为参数，输出一个数值。LossFunction的值越小，则代表这个函数越好。本题中，使用了最小二乘法的Lossfunction。 Step3找到最好的函数BestFunction 1、什么是最好的函数 很显然，最好的函数就是预测最准的函数，即：令L(f)最小的函数。记为argminL(f)。尽管用线性代数就能解决这个问题，但为了后续更复杂问题的解决，要使用下面的方法。 2、GradientDescent梯度下降法 在本题中，函数比较简单，是普通多项式函数，且为linerfunction，直接给出GradientDescent的步骤： 设 f ( x 1 , x 2 . . . x n ) f(x_1,x_2 x_n) f(x1​,x2​ xn​)对 x 1 , x 2 . . x n x_1,x_2..x_n x1​,x2​..xn​都可求微分设计一个值 η > 0 η>0 η>0，称这个 η \eta η为learningrate随机的选择一个点 P 0 ( x 1 , x 2 . . . x n ) P_0(x_1,x_2 x_n) P0​(x1​,x2​ xn​)每次通过迭代从 P m P_m Pm​得到 P m + 1 P_{m+1} Pm+1​： x 1 ′ = x 1 − η α L α x 1 ∣ P m x_{1}^{'}=x_1-η\frac{αL}{αx_1}|_{P_m} x1′​=x1​−ηαx1​αL​∣Pm​​, x 2 ′ = x 2 − η α L α x 2 ∣ P m x_{2}^{'}=x_2-η\frac{αL}{αx_2}|_{P_m} x2′​=x2​−ηαx2​αL​∣Pm​​… x n ′ = x n − η α L α x n ∣ P m x_{n}^{'}=x_n-η\frac{αL}{αx_n}|_{P_m} xn′​=xn​−ηαxn​αL​∣Pm​​经过多次迭代，得到globaloptimal（全局最优解）‘’ 原理：因为这里的LossFunctionL是凸的，linerregression没有localoptimal。 

程序人生-Hello’sP2P 摘要本文介绍了在Linux操作系统下hello的整个生命周期。借助gcc，objdump等工具，对hello的预处理、编译、汇编、链接等过程进行分析。并对程序hello运行过程中的动态链接库调用、内存管理、系统级I/O等进行介绍。关键词：预处理；编译；汇编；链接；进程；内存管理；IO； 目录 第1章概述-4-1.1Hello简介-4-1.2环境与工具-4-1.3中间结果-5-1.4本章小结-5-第2章预处理-6-2.1预处理的概念与作用-6-2.2在Ubuntu下预处理的命令-6-2.3Hello的预处理结果解析-6-2.4本章小结-7-第3章编译-8-3.1编译的概念与作用-8-3.2在Ubuntu下编译的命令-8-3.3Hello的编译结果解析-8-3.4本章小结-14-第4章汇编-15-4.1汇编的概念与作用-15-4.2在Ubuntu下汇编的命令-15-4.3可重定位目标elf格式-15-4.4Hello.o的结果解析-19-4.5本章小结-20-第5章链接-21-5.1链接的概念与作用-21-5.2在Ubuntu下链接的命令-21-5.3可执行目标文件hello的格式-21-5.4hello的虚拟地址空间-26-5.5链接的重定位过程分析-27-5.6hello的执行流程-29-5.7Hello的动态链接分析-30-5.8本章小结-30-第6章hello进程管理-31-6.1进程的概念与作用-31-6.2简述壳Shell-bash的作用与处理流程-31-6.3Hello的fork进程创建过程-31-6.4Hello的execve过程-32-6.5Hello的进程执行-33-6.6hello的异常与信号处理-33-6.7本章小结-35-第7章hello的存储管理-36-7.1hello的存储器地址空间-36-7.2Intel逻辑地址到线性地址的变换-段式管理-36-7.3Hello的线性地址到物理地址的变换-页式管理-37-7.4TLB与四级页表支持下的VA到PA的变换-42-7.5三级Cache支持下的物理内存访问-43-7.6hello进程fork时的内存映射-44-7.7hello进程execve时的内存映射-45-7.8缺页故障与缺页中断处理-46-7.9动态存储分配管理-47-7.10本章小结-50-第8章hello的IO管理-51-8.1Linux的IO设备管理方法-51-8.2简述UnixIO接口及其函数-51-8.3printf的实现分析-52-8.4getchar的实现分析-53-8.5本章小结-54-结论-14-附件-15-参考文献-16- 第1章概述1.1Hello简介P2P：C语言源代码文件（Program）hello.c被GCC编译器的驱动程序读取，通过四个步骤被翻译为可执行文件hello：预处理阶段：C预处理器根据#include命令和#define声明拓展源代码，生成了另一个C程序hello.i；编译阶段：编译器（ccl）产生源文件的汇编代码hello.s；汇编阶段：接下来，汇编器（as）会将汇编代码hello.s转化成二进制目标代码hello.o；链接阶段：最后，链接器（ld）将目标代码文件hello.o与实现库函数的代码合并，并生成最终的可执行代码文件hello。之后执行该文件会将该文件加载在内存中，由系统执行。这时，在shell中运行它，OS（进程管理）会通过fork来为其创建一个新的进程（Process）。这样就完成了P2P（FromProgramtoProcess）过程。 O2O：可执行文件hello运行时shell会为其分配对应的虚拟内存空间。在开始运行进程的时候分配并载入物理内存，开始执行hello的程序，在CPU的帮助下，它的指令被一步步执行，成功在屏幕上输出程序运行完成后系统会回收hello进程并且删除内存中对应的数据，完成O2O（FromZero-0toZero-0）过程。1.2环境与工具1.2.1硬件环境联想拯救者y7000CPU:Intel®_Core™i7-9750HF_CPU@_2.60GHz内存(RAM):16GB硬盘:WDCWDS100T2B0C-00PXH01.2.2软件环境Windows10家庭中文版Ubuntu18.04LTS64位1.2.3开发工具gcc(GCC)9.2.0GNUMake4.2.1GNUEmacs26.31.3中间结果hello.i预处理后修改了的源程序hello.s汇编生成的hello的汇编程序hello.o编译生成的hello的可重定位目标程序hello链接生成的hello的可执行目标程序asm.txthello.o的反汇编文件1.4本章小结本章简述了hello的P2P，O2O过程，介绍了编写本文时的工作环境。 第2章预处理2.1预处理的概念与作用概念：预处理就是预处理器根据#标识的命令（头文件、宏定义、条件编译等），修改原始c代码，将包含的头文件插入到c代码中，并将宏定义进行替换，去除注释等，形成一个.i文本文件。作用：1.程序的预处理过程就是将预处理指令（可以简单理解为#开头的正确指令）转换为实际代码中的内容（替换）2.#include<stdio.h>,这里是预处理指令，包含头文件的操作，将所包含头文件的指令替代3.如果头文件中包含了其他头文件，也需要将头文件展开包含2.2在Ubuntu下预处理的命令cpphello.c>hello.i 图21hello.c的预处理2.3Hello的预处理结果解析 图2-2hello.c 图2-3hello.i可以观察到，预处理后文件变大了很多，原本的#include全部消失，变为stdio.h等头文件的代码。但主体代码缺没有任何改变。2.4本章小结本章节简单介绍了c语言在编译前的预处理过程，简单介绍了预处理过程的概念和作用，对预处理过程进行演示，并举例说明预处理的结果还有解析预处理的过程。 第3章编译3.1编译的概念与作用编译：即编辑器将某种编程语言转化为汇编代码的过程。在本例中就是将hello.i转化为hello.s。作用：将高级语言源程序翻译成等价的目标程序,并且进行语法检查、调试措施、修改手段、覆盖处理、目标程序优化等步骤。3.2在Ubuntu下编译的命令gcc-m64-no-pie-fno-PIC-Shello.i-ohello.s 图3-1编译指令3.3Hello的编译结果解析3.3.1.数据本例中，hello.c中数据类型有：整型，字符串和数组。3.3.1.1.整型C程序的全局变量，已初始化的存放在.data节，未初始化的或初始化为0的存放在.bss节。hello中没有全局变量。对于局部变量，程序要么存在寄存器中，要么存在用户栈中，函数返回时恢复栈帧。例如，在hello.s中，循环变量i采用了存放在用户栈中的方法（如图3-2所示），-4(%rbp)就是循环变量i。 图3-2临时变量i3.3.1.2.字符串hello.c中有两个字符串，即：1.printf(“Usage:Hello学号姓名！\n”);2.printf(“Hello%s%s\n”,argv[1],argv[2]);字符串都声明在.section与.rodata中，在hello.s中以如下形式出现： 图3-3字符串在汇编代码的存储3.3.1.3.数组main函数中的第二个参数char*argv存储在栈上。在汇编代码中，存放在-32(%rbp)。 图3-4argv在汇编代码的体现3.3.2.赋值赋值操作一般用movq指令实现。如hello.s中，就将循环变量i的初始值设为0（图3-3的第二个红框）。已初始化全局变量的初始值直接保存在.data段内，无需mov指令。3.3.3.算术操作常见的算数操作指令如图3-5所示： 图3-5算数操作汇编指令 hello.s中只有一处算数操作，即i++运算。在汇编代码中用addl指令实现。 图3-6算数操作汇编指令hello.s中无逻辑运算操作。3.3.4.关系操作hello.c中有用到的关系操作有：“!=”和“<”。（1）“!=”运算比较通过cmp来实现，指令根据两个操作数之间的差值来设置条件码。如果两个操作数相等，则标记条件码ZF=1，表示两个数是相等的。如果第一个操作数比第二个小，则设置条件码SF=1,表示比较结果为负数，计算机会根据这些条件码来决定跳转。所以“!=”通过如下代码实现： 图3-7不等语句在汇编代码的体现（2）“<”运算类比与“!=”实现： 图3-8小于语句在汇编代码的体现3.3.5.数组操作hello.c中，argv是char*型的数组。argv作为hello的第二个参数，其首元素地址存放在寄存器%rdi中，之后被放进栈空间中的-32(%rbp)位置。引用数组元素时，用“基地址加偏移量”的方式寻址，如图3-4所示。 图3-9hello中argv数组的引用方式3.3.6.控制转移第一处是判断argv是否等于3，若不等于，则继续执行，若等于，则跳转至L2处（循环前对i初始化）继续执行。 图3-10第一处控制转移第二处是对i初始化为0后的无条件跳转，以跳到L4,即循环部分代码。 图3-11第二处控制转移第三处是判断是否达到循环终止条件（i<10），这里用i与9进行比较，若小于等于则跳回L4重复循环，否则执行循环外的下一步。这里将i<10的比较改为了与其等价的i<=9。 图3-12第三处控制转移3.3.7.函数操作hello.c中涉及函数main，printf，exit，sleep，atoi和getchar。（1）main函数main是整个程序的入口，系统传入参数argc，argv，通过寄存器%rdi（%edi）和%rsi传入，在开始时将这两个参数圧入栈中便于使用寄存器，由系统调用。如下： 图3-13main函数将参数压入栈在汇编代码的体现最后main函数返回值为0，通过%rax（%eax）。 图3-14main函数返回语句在汇编代码的体现（2）prinft函数第一次调用及其汇编代码： 图3-16第一次调用printf语句及其汇编代码其中$.LC0就是字符串"Usage:Hello学号姓名！\n"对应的地址。由于原字符串以’\n’结束，且printf没有其他参数用于格式化，所以编译器优化为puts函数。第二次调用及其汇编代码： 图3-17第二次调用printf语句及其汇编代码由于argv已经被圧入栈了，所以要通过-32(%rbp)+bias来访问。然后我们就可以将参数放入%rdi（%edi）、%rsi和%rdx三个寄存器中。（3）exit函数exit的作用是直接结束程序，同样通过%edi传入参数，就是整个程序的返回值。 图3-18调用exit语句的汇编代码（4）sleep函数sleep传入的参数是atoi的返回值，通过%edi传入。 图3-19调用sleep语句的汇编代码（5）getchar函数getchar可以直接调用，会返回输入的字符。其结果保存在寄存器%eax中。。 图3-20调用getchar语句的汇编代码3.4本章小结本章显示简述了编译的概念和作用，具体分析了一个c程序是如何被编译器编译成一个汇编程序的过程，还详细分析了不同的c语句和翻译成汇编语句之后的表示方法。 第4章汇编4.1汇编的概念与作用概念：汇编器as将汇编程序hello.s文件转化为二进制机器码文件hello.o的过程叫做汇编，它把汇编指令打包成一种叫做可重定位目标程序的格式。作用：利用汇编器将汇编指令翻译成二进制字节码，形成可执行可链接格式文件（即ELF文件），使之在链接后能够被机器执行。4.2在Ubuntu下汇编的命令ashello.s-ohello.o 图4-1汇编指令4.3可重定位目标elf格式4.3.1.ELF文件信息输入如下命令可以查看hello.o的ELF信息：readelf-ahello.oELF是一种Unix二进制文件，它可能是可链接文件，也可能是可执行文件。图4-2概括了一个典型的ELF文件中的各类信息。 图4-2ELF可执行文件的结构 4.3.2.ELF头ELF头的信息如图4-3所示。可以看到，ELF头以一个16字节的序列（7f454c46020101000000000000000000）开始，描述了使该文件得以运行的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器.语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移、以及节头部表的大小和数目。 图4-3ELF头信息4.3.3.节头部表节头部表如图4-4所示。描述了ELF文件中各节的基本信息，包括位置和大小等。此外，节的一般属性和功能，由旗标描述。为了保持内存对齐，各节往往还需要一定大小的对齐填充，这个大小也在表中。 图4-4hello.o的节头部表4.3.4.重定位节接下来是重定位条目表，如图4-5所示。汇编器每遇到一个对最终位置的目标的引用，就会生成一个重定位条目。表有五列，分别是偏移量、信息、类型、符号值和符号名称+加数。 图45重定位条目表(1)偏移量，是指所引用的符号的相对偏移，或者说符号应该填在程序的哪个位置。例如，第二行中，puts的偏移量为0x00000000001b。这就相当于告诉链接器，需要修改开始于偏移量0x1b处的32位PC相对引用，使它在运行时指向puts函数。(2)信息，包括符号和类型两部分，共占8个字节。其中，前4个字节表示符号，后4个字节表示类型。符号代表重定位到的目标在.symtab节中的偏移量，类型则包括相对地址引用和绝对地址应用。(3)类型，就是对第二列中类型信息的翻译。(4)符号值，就是符号代表的值。(5)第五列分为两部分。符号名称是重定位目标的名字，可能是节名、变量名、函数名等；加数则是用于对被修改的引用值做偏移调整。最后是.symtab节，即符号表。它保存了程序中所用的各种符号的信息，包括文件名、函数名、全局变量名、静态（私有）变量名等，如图4-6所示。 图46符号表4.4Hello.o的结果解析使用objdump反汇编的结果如下： 图4-7hello.o的反汇编代码与第3章的hello.s进行对照我们会发现：（1）伪指令消失原本hello.s中的许多以’.'开始的伪指令，在反汇编代码中都消失了。（2）条件分支变化我们可以发现，在hello.s中跳转到的目标位置都是用.L3/.L4来表示的，在hello.o反汇编之后，这些目标被用具体的地址位置代替。（3）函数调用变化反汇编代码中的函数调用call指令是用相对地址寻址的，而在汇编码中中则是用函数名（符号）。这是因为hello.c源代码中调用的函数是共享库中的函数（如printf、getchar等），在动态链接器链接之前无法确定函数运行时的实际地址。所以，对于这些地址不确定的函数调用，在编译时要用符号占位，汇编时则要使用相对地址（偏移）。（4）数据访问变化汇编码中，访问全局变量时，使用段名称+%rip，在反汇编代码中则是X+%rip（其中X显示为全0，实际上是重定位条目）。这是因为.rodata段的地址也是在运行时方能确定，所以对.rodata中数据的访问也需要重定位。而设置重定位条目的工作是在汇编阶段完成，从而造成汇编码和返回编码的不同。4.5本章小结本章介绍了汇编。汇编器（as）将汇编代码hello.s转化为可重定位目标文件hello.o，得到一个可以用于链接的二进制文件。通过readelf我们可以查看hello.o的elf信息和重定位信息。通过对比hello.o的反汇编和第3章的hello.s，对汇编过程有更深的理解。 第5章链接5.1链接的概念与作用概念：链接是将各种代码和数据片段收集并组合称为一个单一文件的过程。作用：链接可以执行于编译时,也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。5.2在Ubuntu下链接的命令ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5-1链接指令5.3可执行目标文件hello的格式输入如下命令可以查看hello的ELF信息：readelf-ahelloELF头信息如图5-2所示 图52hello的ELF头各节信息如图5-3所示。信息包括各节的名称、大小、属性和相对偏移量等。 图53hello的ELF各节信息程序头部表如图54所示。 图54hello的程序头部表段映射和动态节项目信息如图55所示。 图55hello的段映射和动态节项目重定位条目信息如图56所示。 图56hello的重定位条目符号表信息如图57所示。 图57hello的符号表（部分）5.4hello的虚拟地址空间用edb打开hello。如图58所示，从DataDump窗口中不难看出，hello隔断的虚拟地址空间被限制在0x400000到0x401000之间。 图5-8hello的虚拟内存不难发现，DataDump中展示的虚拟内存内容和readelf展示的节表是相对应的，根据图52得到的各节起始地址，可以在edb中查找得到对应内容，如图59所示。 图59ELF节信息与DataDump对照展示5.5链接的重定位过程分析输入objdump-d-rhello得到反汇编代码。 图5-10hello的反汇编代码对比与反汇编hello.o得到的代码可以发现：(1)hello的反汇编代码含有更多的函数。hello.o的反汇编代码中只有一个函数main，而在hello的反汇编代码中还出现了_init，.plt，puts@plt等函数。很多外部的被hello.c调用的函数以及一些初始函数（如_init）都被链接到hello中。(2)函数调用变化。在hello.o中函数的地址是不确定的，但是在hello中外部函数调用的地址确定，不再是0。如puts的地址就明确为0x401030。 图5-11函数调用对比(3)数据引用变化。和函数类似，hello.o中一些数据的地址是不确定的，但是在hello中它们的地址确定了。如.rodata+0x22的地址就明确为0x40202e。链接主要分为两个过程：符号解析和重定位。1）符号解析：目标文件定义和引用符号，符号解析将每个符号引用和一个符号定义关联起来。2）重定位：编译器和汇编器生成从0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。通过上面的分析可以得出在重定位过程中，链接器在完成符号解析以后，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。然后就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时的地址。5.6hello的执行流程使用edb执行hello，观察从加载hello到_start，到main，以及程序终止的所有过程。下面列出调用与跳转的子程序名和子程序地址，如表51所示。程序名程序地址加载hellold-linux-x86-64.so!_dl_start0x00007ffff7fd4d30ld-linux-x86-64.so!_dl_init0x00007ffff7fe27b0hello!_start0x0000000000401090hello!__libc_csu_init0x00000000004010d0hello!_init0x0000000000401000libc.so!_setjmp0x00007ffff7e08b10程序运行hello!main0x0000000000401149hello!puts@plt0x0000000000401030ld-linux-x86-64.so!_dl_runtime_resolve_xsave0x00007ffff7fe87a0ld-linux-x86-64.so!_dl_fixup0x00007ffff7fe1de0ld-linux-x86-64.so!_dl_lookup_symbol_x0x00007ffff7fdd610退出程序hello!exit@plt0x0000000000401070libc.so!exit0x00007ffff7e0b840hello!_fini0x00000000004011d4表51hello从加载到终止过程中调用或跳转的主要子程序5.7Hello的动态链接分析函数调用一个由共享库定义的函数时，编译器无法预先判断出函数的地址，因为定义它的共享模块在运行时可以加载到任意位置。GNU编译系统使用延迟绑定的方式解决该问题，在运行时动态载入。现代编译器会将共享模块的代码段编译为位置无关代码（PIC）。这种代码可以加载到内存的任何位置而无需连接器修改。这样一来，多个进程就可以共同使用共享模块的同一副本。延迟绑定是通过两个数据结构之间简洁但乂有些复杂的交互来实现的，这两个数据结构是：全局偏移量表（GOT）和过程链接表（PLT）。如果一个目标模块调用了定义在共享库中地函数，那么它就有自己的GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。通过readelf获得的节头部表可以知道.got.plt的起始位置为0x0000000000404000。在调用_dl_start之前对应的内存为： 图5-12_dl_start调用前.got.plt对应内存对应的内存全为0，而_dl_start之后： 图5-13_dl_start调用后.got.plt对应内存对应的内存有了动态链接器在解析函数地址时会使用的信息。5.8本章小结本章展示了hello.o经过链接成为hello可执行文件的全过程，着重介绍了重定位和动态链接的流程，深入学习了hello.o可重定位文件到hello可执行文件的流程，和链接的各个过程介绍了链接器如何将hello.o可重定向文件与动态库函数链接起来。 第6章hello进程管理6.1进程的概念与作用概念：进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。作用：进程是计算机科学中最深刻、最成功的概念之一。它令我们得到一种假象：我们的程序好像是系统中当前运行的唯一的程序一样；我们的程序好像是独占地使用处理器和内存；处理器好像是不间断地执行着指令；我们程序中的代码和数据好像是系统内存中唯一的对象。6.2简述壳Shell-bash的作用与处理流程作用：Shell是系统的用户界面，它为用户提供了一种与内核进行交互操作的接口，即接收用户输入的命令并把它送入内核执行。处理流程：Shell首先读取用户的输入。然后分析输入内容，获得输入参数。如果是内核命令则直接执行，否则调用相应的程序执行命令。在程序运行期间，shell需要监视键盘的输入内容，并且做出相应的反应。6.3Hello的fork进程创建过程父进程可以通过fork函数创建一个新子进程。函数原型为pid_tfork(void);新创建的子进程与父进程几乎完全相同。子进程得到与父进程用户级虚拟地址空间相同（但是独立的）一份副本，包括代码段和数据段、堆、共享库以及用户栈。子进程还会获得父进程所打开的文件描述符的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的差别在于它们有不同的PID。函数返回值分两种情形，父进程内返回子进程的PID，子进程内返回0。fork函数有一些微妙的地方。(1)调用一次，返回两次。父进程调用一次fork，有一次是返回到父进程，而另一次是返回到子进程的。(2)并发执行。父进程和子进程是并发运行的独立进程，内核可以以任意方式交替执行它们的逻辑控制流中的指令。我们不能对不同进程中指令的交替执行做任何假设。(3)相同但独立的地址空间。两个进程有相同的用户栈、运行时堆和本地变量值等，但它们对各自内存空间的修改是相互独立的。事实上，在物理内存中，一开始，两个进程指向的地址确实是相同的；但是，一旦一方对部分共享空间做了修改，这部分空间就会被拷贝出去，不再共享。这种技术被称作写时复制。写时复制会在7.6节中详细阐述(4)共享文件。子进程会继承父进程打开的所有文件。 6.4Hello的execve过程execve函数在当前进程的上下文中加载并运行一个新程序。其原型为： 图62execve函数原型execve函数加载并运行可执行目标文件filename，带上参数列表argv和环境变量列表envp。函数返回值，只有出现错误返回-1，否则不返回。execve加载了filename之后，程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据段并重新初始化栈空间和堆空间。接着，CPU为新进程进程分配时间片执行逻辑控制流，跳转到程序的入口点，也就是_start函数的地址。_start函数调用系统启动函数__libc_start_main，该函数定义在libc.o中。它初始化执行环境，调用main函数，处理main函数的返回值。main开始执行时，用户栈的组织结构如图62所示。可以看到，低地址部分有环境变量和参数字符串数组等，栈顶就是系统启动函数__libc_start_main。 图63新程序开始时用户栈的典型组织结构 6.5Hello的进程执行系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。内核为每个进程维护了一个上下文。当内核选择的一个新的进程运行时，我们说内核调度了这个进程。所以当内核调度了hello这个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换会首先保存当前进程的上下文，然后恢复新恢复进程被保存的上下文，最后控制传递给这个新恢复的进程，来完成上下文切换。过程如下： 图6-4进程间切换上图是对于上下文切换的剖析的一个实例。hello调用sleep和getchar函数时都会有类似的上下文切换。6.6hello的异常与信号处理hello执行时，可能产生如表61所示的四种类别的异常：类别原因同步/异步返回行为中断来自I/O设备的信号异步总是返回到下一条指令陷阱有意的异常同步总是返回到下一条指令故障潜在可恢复的错误同步可能返回到当前指令终止不可恢复的错误同步不会返回表61系统异常的四个类别hello执行时，还可以发送或接收信号。信号是一种系统消息，它用于通知进程系统中发生了某种类型的事件，是一种更高层的软件形式的异常。不同的事件对应不同的信号类型。信号传送到目的进程由发送和接收两个步骤组成。信号的发送者一般是内核，接收者是进程。发送信号可以有如下两种原因：(1)内核检测到一个系统事件（如除零错误或者子进程终止）；(2)一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。接收信号是内核强迫目的进程做出的反应。进程可以以默认方式做出反应，也可以通过信号处理程序捕获这个信号。每个信号只会被处理一次。待处理信号指的是已经发送而没有接收的信号。任何时候，一种信号类型至多有一个待处理信号，即信号不会排队。进程可以有选择性地阻塞接收某种信号。被阻塞的信号仍可以发出，但不会被目标进程接收。信号种类繁多，现列举如表62所示。编号信号名称默认行为说明1SIGHUP终止终止控制终端或进程2SIGINT终止键盘产生的中断3SIGQUITdump键盘产生的退出4SIGILLdump非法指令5SIGTRAPdumpdebug中断6SIGABRT／SIGIOTdump异常中止7SIGBUS／SIGEMTdump总线异常/EMT指令8SIGFPEdump浮点运算溢出9SIGKILL终止强制进程终止10SIGUSR1终止用户信号,进程可自定义用途11SIGSEGVdump非法内存地址引用12SIGUSR2终止用户信号，进程可自定义用途13SIGPIPE终止向某个没有读取的管道中写入数据14SIGALRM终止时钟中断(闹钟)15SIGTERM终止进程终止16SIGSTKFLT终止协处理器栈错误17SIGCHLD忽略子进程退出或中断18SIGCONT继续如进程停止状态则开始运行19SIGSTOP停止停止进程运行20SIGSTP停止键盘产生的停止21SIGTTIN停止后台进程请求输入22SIGTTOU停止后台进程请求输出23SIGURG忽略socket发生紧急情况24SIGXCPUdumpCPU时间限制被打破25SIGXFSZdump文件大小限制被打破26SIGVTALRM终止虚拟定时时钟27SIGPROF终止剖析定时器期满28SIGWINCH忽略窗口尺寸调整29SIGIO/SIGPOLL终止I/O可用30SIGPWR终止电源异常31SIGSYS／SYSUNUSEDdump系统调用异常表62信号的种类 图6-5Ctrl-ZCtrl-Z操作向进程发送了一个SIGTSTP信号，让进程暂时挂起，输入jobs、ps指令可以发现hello进程在后台挂起，通过fg指令可以恢复运行。 图6-6Ctrl-CCtrl-C操作向进程发送了一个SIGINT信号，让进程终止，输入jobs、ps指令可以发现hello进程已经被回收。6.7本章小结为了描述程序运行，进程的概念不得不提，它是计算机科学中最深刻、最成功的概念之一。进程为程序提供的抽象环境，使得进程可以同时地、并发地执行。为了高效地描述系统中发生的各类事件，则需要用到信号，这是一种更高层级的软件形式的异常。利用信号，内核和进程之间得以高效地传递信息并对各类事件做出相应的反应。 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：在计算机体系结构中逻辑地址是指应用程序角度看到的内存单元、存储单元、网络主机的地址，即hello.o里面的相对偏移地址。在x86系统中，有一种被称作“段式内存管理”的内存映射方式。在x86架构下，访问指令给出的地址（操作数）叫逻辑地址，也叫相对地址、有效地址。逻辑地址往往不同于物理地址，通过地址翻译器或映射函数可以把逻辑地址转化为物理地址。线性地址：即虚拟地址。虚拟地址：虚拟地址是程序用于访问物理内存的逻辑地址，即线性地址，在hello中为虚拟地址，等于逻辑地址加上基地址。逻辑地址可转化为线性地址，其地址空间是一个非负整数地址的有序集合，如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。物理地址：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有唯一的物理地址，它是指在地址总线上、以电子形式存在的、使得数据总线可以访问主存的某个特定存储单元的内存地址。在hello程序中，他就表示了这个程序运行时的一条确切的指令在内存地址上的具体哪一块进行执行。7.2Intel逻辑地址到线性地址的变换-段式管理内存分段是为了支持多任务并发执行，每一个任务对应各自的段空间，段之间支持保护访问限制，实现了程序和数据从物理地址空间到虚拟地址空间的重映射，从而达到隔离的效果。如上所述，在段式内存管理中，程序的地址空间被划分为若干段，每个进程都有一个“二维”的地址空间。系统为每个段分配一个连续分区，而进程中的各个段可以不连续地存放在内存的各个分区中。程序加载时，操作系统为所有段分配其所需内存，这些段不必连续，物理内存的管理采用动态分区的管理方法。程序过来一个逻辑地址，使用其段标识符（也即段选择符）的Index字段去索引段描述符表，若TI=0，索引全局段描述符表，TI=1，索引局部段描述符表，表的地址在相应的寄存器中。通过Index字段和段描述符表的位置能找到某项具体的段描述符。将段描述符中的base字段和逻辑地址中的offset字段合并即得到了线性地址。按照Intel的本意，全局的用GDT，每个进程自己的用LDT 不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。[1]中有介绍，四个段的基地址全为0。这样，给定一个段内偏移地址，按照前面转换公式，0+段内偏移，转换为线性地址，可以得出重要的结论，“在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。”所以如果做linux下内核开发，对于上述的x86的段式管理可以完全不用理会，我们可以认为linux根本没有用intel弄出来的这个段式管理，而是以页式管理完成了所有的内存管理工作。 图71段式内存管理的地址变换需要特别注意的是，段式内存管理是Intelx86系统的产物。amd64架构虽然支持x86所有形式的段，但在64位模式下，段式的设计已被取消，转而使用平坦内存模型。在这种模型下，分段机制虽仍然存在，但所有的段基址都是0，段大小被忽略。这就使得逻辑地址可以访问处理器支持的所有虚拟内存空间。也就是说，amd64架构中，段式地址转换形同虚设，逻辑地址（相对地址、有效地址）与虚拟地址（线性地址）是相同的。为了表述方便，接下来针对amd64架构的叙述，全部使用“虚拟地址”一词。7.3Hello的线性地址到物理地址的变换-页式管理7.3.1基本原理虚拟内存系统将程序的虚拟地址空间划分为固定大小的虚拟页（每个大小为P=2^p），物理内存被划分为同样大小的物理页（也被称作页帧，大小也为P字节）。在页式储存管理方式中地址结构由两部构成，前一部分是虚拟页号（VPN），后一部分为虚拟页偏移量（VPO）。在任意时刻，虚拟页面的集合都分为三个不相交的子集：(1)未分配页。虚拟内存系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间(2)缓存页。当前已缓存在物理内存中的已分配页(3)未缓存页。未缓存在物理内存中的已分配页从存储位置上看，物理内存存储在主存中，而虚拟内存存储在磁盘中。7.3.2页表同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。这些功能是由软硬件联合提供的，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。图72展示了一个页表的基本组织结构。 图72页表页表就是一个页表条目的数组。虚拟地址空间中的每个页在页表中的各固定偏移量处都有一个PTE。都有一个为方便理解，我们假设每个页表条目都是由一个有效位和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。如果设置了有效位为真，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。注意，因为DRAM缓存是全相联的，所以任意物理页都可以包含任意虚拟页。7.3.3页命中为了访问物理页，CPU中的地址翻译硬件会先把虚拟地址作为索引去访问页表。若对应的表项有效位为真，那么，该项中的地址字段就是我们所要的物理页的起始地址。以图7-3中的虚拟页2为例，由于对应页表条目有效位是1，所以发生页命中，即这个页已经被缓存到主存中了。于是，直接访问地址字段指向的物理内存物理页2即可。 图73页命中7.3.4缺页在虚拟内存的习惯说法中，DRAM缓存不命中被称为缺页（pagefault）。图7-4展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在PP3中的VP4。如果虚拟页4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改虚拟页4的页表条目，反映出VP4不再缓存在主存中这一事实。接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在VP3已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了，图75展示了在缺页后我们的示例页表的状态。 图74缺页后的页表状态7.3.5地址翻译从形式上说，地址翻译要做的是把N元素的虚拟地址空间（VAS）映射到M元素的物理地址空间（PAS）中。如果虚拟地址A处的数据在物理地址A’处，那么映射值就是A’；否则，若A处的数据不在物理内存中，映射值就是空。 图75地址翻译流程图75展示了MMU如何利用页表来实现这种映射。CPU中的一个控制寄存器，页表基址寄存器指向当前页表。n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个(n-p)位的虚拟页号（VPN）。MMU利用VPN来选择对应的页表项目。将页表条目中物理页号（PPN）和虚拟地址中的VPO串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是p字节的，所以物理页面偏移（PPO）和VPO是相同的。图76a展示的是页命中时CPU硬件执行的步骤：(1)处理器生成一个虚拟地址，并把它传送给MMU(2)MMU生成对应的页表项目地址，并访问高速缓存或主存获得其内容(3)高速缓存或主存向MMU返问页表项目(4)有效位为真，MMU构造物理地址，并把它传送给高速缓存或主存(5)高速缓存或主存返冋所请求的数据字给处理器页命中完全由硬件处理，而缺页则需要硬件和操作系统内核协作完成。如图76b所示：(1)与页命中的第1步操作相同(2)与页命中的第2步操作相同(3)与页命中的第3步操作相同(4)页表项目的有效位是0，MMU触发异常，CPU的控制传送到操作系统内核中的缺页异常处理程序(5)缺页处理程序确定出物理内存中的牺牲页。如果这个页被修改过，还需要把它换出到磁盘(6)缺页处理程序页面调入新的页，并更新内存中的页表项目(7)缺页处理程序返回到原来的进程，再次执行那个导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。现在，所需的虚拟页已经缓存在物理内存中了，所以会发生页命中。在MMU执行了图7-6a中的步骤之后，主存就会将所请求字返回给处理器 图76页命中和缺页的操作图7.4TLB与四级页表支持下的VA到PA的变换36位VPN被划分成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含Ll页表的物理地址。VPN1提供到一个LlPET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 图7-7四级页表支持下的VA到PA的变换7.5三级Cache支持下的物理内存访问我们通过MMU获得对应的物理内存地址后，就需要在物理内存中得到对应的数据。此时我们会通过高速缓存来加速数据读取。首先L1高速缓存会通过地址解析出缓存的索引和偏移，对缓存进行访问，匹配标记查找是否含有相关的字，如果命中，则将数据发送给CPU，如果没有命中，则访问L2缓存，依次类推，直到主存，然后取出这个字，存入高一级缓存，最后返回数据给CPU。 图7-8三级Cache支持下的物理内存访问7.6hello进程fork时的内存映射当fork函数被shell调用时，内核为hello创建各种数据结构，并分配一个唯一的PID。创建当前进程的mm_struct,vm_area_struct和页表的原样副本。两个进程的每个页面都标记为只读页面。两个进程的每个vm_area_struct都标记为私有，这样就只能在写入时复制。当fork在hello进程中返回时，hello现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新的页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 图7-9私有的写时复制对象7.7hello进程execve时的内存映射虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。假设运行在当前进程中的程序执行了如下的execve调用execve(“hello”,NULL,NULL);正如6.4节所说，execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤：(1)删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。(2)映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。图717概括了私有区域的不同映射。(3)映射共享区域。如果hello程序与共享对象（或目标）链接，比如标准C库libc.so，那么这些对象都先是动态链接到程序，再映射到用户虚拟地址空间中的共享区域内的。(4)设置程序计数器PC。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的人口点。下一次调度这个进程时，它将从这个人口点开始执行。Linux将根据需要换人代码和数据页面。 图710加载器映射用户地址空间区域的方法7.8缺页故障与缺页中断处理假设MMU在试图翻译某个虚拟地址A时，触发了缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤（如图711所示）：(1)虚拟地址A是合法的吗？换句话说，A在某个区域结构定义的区域内吗？缺页处理程序会搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图711标识为“1”。(2)试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。这个情况在图711标识为“2”。(3)若不满足以上两种情形，内核明白这个缺页是由于对合法的虚拟地址进行合法的操作造成的。接下来，内核会遵循7.3.3节中的步骤进行处理，这里不再重复。 图711Linux缺页处理7.9动态存储分配管理7.9.1动态内存分配器虽然可以使用低级的mmap和munmap函数创建和删除虚拟内存的区域，但使用动态内存分配器（dynamicmemoryallocator）更方便，也有更好的移植性。动态内存分配器用于分配和维护一个进程的虚拟内存区域，称为堆（如图712所示）。堆在系统内存中向上生长。对于每个进程，系统维护着一个堆顶指针brk。 图712虚拟内存区域 堆分配器将堆视为不同大小的块（block）组成的集合。每个块就是一段连续的虚拟内存片（chunk），要么是已分配的（allocated），要么是空闲的（free）。已分配的块显式地保留给应用程序使用，空闲块留待分配。1.显式分配器。显式分配器要求程序显式地释放已分配块。例如，C标准库就提供了malloc库这一显式分配器。它需要满足如下的约束条件：能够处理任意请求序列；立即响应请求；仅使用堆；块对齐；不修改已分配块。在满足这些限制条件的前提下，其分配吞吐速率越大、内存使用率越高，其性能越优秀。然而，这两个要求是冲突的。为了把握好平衡，就需要分配器有效地组织空闲块，精心设计放置、分割和合并的处理方式。2.隐式分配器（也叫垃圾收集器）能够检测已分配块何时不再被程序使用，并将其自动释放。这种分配器将内存视为一张有向可达图，凡不能从根到达的节点都是垃圾节点，代表程序无法再访问使用的内存空间。垃圾收集器能够以某种方式维护这张图，释放不可达节点并将其返还给空闲链表，从而达到定期回收内存的目的。7.9.2隐式空闲链表我们可以将堆组织为一个连续的已分配块和空闲块的序列。一个块是由一个字的头部、有效载荷、可能的填充和一个字的脚部，其中脚部就是头部的一个副本。头部和脚部包含这个块的大小和是否空闲（1为已分配，0为空闲）。空闲块是通过头部中的大小字段隐含地连接着的，这种结构为隐式空闲表。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块地集合。 图7-13隐式空闲链表的一个块7.9.3显式空闲链表将堆组成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。一种方法是用后进先出（LIFO）的顺序来维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址地址排序的首次适配比LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用。一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小快大小，也潜在的提高了内部碎片的程度。 图7-14显式空闲链表的一个块7.9.4分离空闲链表一般的单向空闲链表，其查找和分配所需时间都是线性的。为了减少分配时间，可以按块大小对空闲块分类，每个类都单独维护一个链表，类中的块大小大致相同，这被称为“分离”的显式空闲链表。例如，可以按照2的幂来划分块大小：{1},{2},{3,4},{5~8},…,{1025~2048},{2049~4096},{4097~∞}链表的头元素存储在静态数组中。链表内部的元素以块大小按升序排列。当分配器需要一个对齐后大小为n的块时，它就会搜索相应的空闲链表。如果不能找到合适的块与之相匹配，就搜索下一个链表，以此类推。7.10本章小结本章具体分析了存储管理。包括逻辑地址、线性地址、虚拟地址和物理地址、其中的转化过程、三级高速缓存、fork与execve和动态内存分配等。其中，虚拟内存是重中之重，是计算机系统最重要的概念之一，可以为每个进程分配一个独立的虚拟内存空间而不不会受到其他进程影响，而动态内存分配器则可以提高内存的利用率和效率。 第8章hello的IO管理8.1Linux的IO设备管理方法一个Linux文件就是一个m个字节的序列：B0,B1,…,Bk,…,Bm-1所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。8.2简述UnixIO接口及其函数所有的输入和输出都能以一种统一且一致的方式来执行：(1)打开文件。一个应用程序要求通过内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个标识符。(2)Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。(3)改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开始的字节偏移量。应用程序能够通过执行seek操作，现显式地设置文件的位置为k。(4)读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个称为end-of-file的条件，应用程序能够检测到这个条件。在文件结尾处并没有明确的“EOF符号”。(5)关闭文件。当应用程序完成了对文件的访问后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。UnixI/O函数原型有：(1)intclose(intfd)该函数可以关闭一个打开的文件，其中fd是需要关闭的文件的描述符。(2)intopen(char*filename,intflags,mode_tmode)进程通过调用open函数来打开已存在的文件或是创建新文件。(3)size_twrite(intfd,constvoid*buf,size_tn)该函数从内存位置复制至多n个字节到描述符为fd的当前文件位置。(4)size_tread(intfd,void*buf,size_tn)该函数从描述符为fd的文件位置赋值最多n个字节到内存位置buf。返回-1表示出现错误，0表示EOF；否则返回值表示的是实际传送的字节数量。8.3printf的实现分析printf函数实现如下：1.intprintf(constchar*fmt,…){2.inti;3.charbuf[256];4.5.va_listarg=(va_list)((char*)(&fmt)+4);6.i=vsprintf(buf,fmt,arg);7.write(buf,i);8.9.returni;10.} 用vsprintf函数生成显示信息，实现如下：1.intvsprintf(char*buf,constchar*fmt,va_listargs){2.char*p;3.chartmp[256];4.va_listp_next_arg=args;5.for(p=buf;*fmt;fmt++){6.if(*fmt!=‘%’){7.*p++=*fmt;8.continue;9.}10.fmt++;11.switch(*fmt){12.case‘x’:13.itoa(tmp,*((int*)p_next_arg));14.strcpy(p,tmp);15.p_next_arg+=4;16.p+=strlen(tmp);17.break;18.case‘s’:19.break;20.default:21.break;22.}23.}24.return(p-buf);25.} write的汇编代码：1.moveax,_NR_write2.movebx,[esp+4]3.movecx,[esp+8]4.intINT_VECTOR_SYS_CALL write函数中，%ecx中存储字符个数，%ebx中存储字符串首地址，intINT_VECTOR_SYS_CALL的意思是通过系统调用sys_call。这个函数的功能就是不断地打印出字符，直到遇到\0。追踪sys_call，得到其汇编实现如下：1.sys_call：2.callsave3.pushdword[p_proc_ready]4.sti5.pushecx6.pushebx7.call[sys_call_table+eax*4]8.addesp,4*39.mov[esi+EAXREG-P_STACKBASE],eax10.cli11.ret 接着，字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析getchar函数的声明在stdio.h头文件中。一种实现如下：1.intgetchar(){2.charc;3.return(read(0,&c,1)==1)?c:EOF;4.} 这个getchar每次从标准输入中读取一个字符。具体来说，若当前I/O未被锁定，它就调用系统_IO_getc_unlocked内置宏，读取一个字符。简单地说，我们用一个指针_IO_read_ptr指向缓冲区，用另一个指针_IO_read_end指向缓冲区的末尾。调用_IO_getc_unlocked时，先检查指针是否越界。如果没有，就返回_IO_read_ptr所指向的字符并自增_IO_read_ptr。若已越界，就调用_uflow（内部使用了系统read），用这个函数重新填充缓冲区并返回重新读入的字符。对于异步异常和键盘中断的处理：键盘中断处理子程序；接受按键扫描码转成ASCII码，保存到系统的键盘缓冲区。也就是说，getchar等调用read系统函数，通过系统调用读取按键ASCII码，直到接受到回车键才返回。 8.5本章小结本章主要介绍了Linux的IO设备管理方法、UnixIO接口及其函数，分析了printf函数和getchar函数。 结论hello的一生包含如下阶段：(1)预处理：将hello.c根据以字符#开头命令，修改原始c程序，得到hello.i。(2)编译：将hello.i翻译为hello.s的汇编程序，中间对代码进行语法检查和优化。(3)汇编：将hello.s翻译为二进制机器码，得到可重定位目标文件hello.o。(4)链接：将hello.o同等动态库等连接，生成可执行目标文件hello。(5)创建进程：通过shell运行hello程序。shell通过fork创建子进程，通过execve运行hello。(6)访问内存：通过MMU将hello中的虚拟地址转换为实际的物理地址，再通过多级缓存读取数据。(7)异常：程序执行过程中，如果从键盘输入Ctrl-C等命令，会给进程发送一个异常信号，然后通过信号处理函数对信号进行处理。(8)结束：hello运行完后会由父进程（shell进程）回收，内核会删除对应的数据结构。至此，我们对于hello的分析已经完成。通过写大作业，将本学期大部分所学内容串联了起来。从一个hello.c的到详细的进程执行。这样，我们才能够真正理解硬件、操作系统和编译系统对应用程序的性能和正确性的影响，为将来设计和构造大型软件产品提供更基础、更底层的角度和思路。 附件文件名称文件作用hello.chello的C语言源代码hello.ihello.c预处理生成的代码hello.shello.i编译生成的汇编代码hello.ohello.s汇编生成的可重定位目标文件hellohello.o链接生成的可执行文件hello_o_objdump.asmhello.o的反汇编代码hello_objdump.asmhello的反汇编代码hello_o_elf.txthello.o的ELF信息概述hello_elf.txthello的ELF信息概述 参考文献[1]兰德尔E.布莱恩特.大卫R.奥哈拉伦.等深入理解计算机系统[M].北京：机械工业出版社.2019.[2]printf函数实现的深入剖析https://www.cnblogs.com/pianist/p/3315801.html 

HelloWorld！ HelloWorld！ 

GraphPoet翻译 ClassGraphPoet java.lang.Object poet.GraphPoet publicclass GraphPoetextendsObject 一个基于图的诗歌派生器。 GraphPoet由文本语料库初始化，它用这个语料库来派生一个单词亲和图wordaffinitygraph。单词words用图中的顶点vertices表示。单词是不包括空格和换行符的不区分大小写的非空字符串，它们在语料库中由空格、换行符或EOF分隔。图中的各边表示邻接的数量：从w1到w2的边的权重定义为语料库中“w2”紧跟在“w1”后面的次数。 举个栗子，给定这个语料库: Hello,HELLO,hello,goodye! 生成的图应该包含两条边： (“hello,”)->(“hello,”)权重为2(“hello,”)->(“goodbye!”)权重为1 两个点表示为不区分大小写的“hello,”和“goodbye!” 给定输入字符串，GraphPoet通过尝试在输入中的每对相邻单词之间插入一个桥接词bridgeword来生成一首诗。单词由语料库中的单词定义和分隔。输入词“w1”和“w2”之间的桥接词“b”使得w1->b->w2成为一条包含两条边的路径，满足在这个诗人(GraphPoet)的单词亲和图中的所有从w1到w2的包括两条边路径中，具有最大权重。如果没有这样的路径，则不会插入桥接词。在输出的诗句中，输入词保留了原来的大小写，而桥词则是小写。诗中每个字之间的空白是一个空格，开头和结尾没有空格。 再举个栗子，给定这个语料库： ThisisatestoftheMugarOmniTheatersoundsystem. 对于这个输入： Testthesystem. 输出的诗句将会是： Testofthesystem. 说明：这是一个有要求的ADT类，并且你不能弱化要求的规约specifications。但是，你可以强化规约，也可以添加额外方法。你必须在你的属性rep中使用Graph类，但是除此之外这个类的实现取决于你。 ConstructorSummary GraphPoet (File corpus)使用从corpus生成的图创建一个新的诗人。 MethodSummary String poem (String input)生成一首诗。 从java.lang.Object类继承的方法 equals, getClass, hashCode, notifyAll, toString, wait, wait, wait ConstructorDetail GRAPHPOET publicGraphPoet(Filecorpus)throwsIOException 使用从corpus生成的图创建一个新的诗人。 parameters corpus-生成诗人的单词亲和图的文本文件 Throws IOException-如果无法找到或无法读corpus文件 MethodDetail POEM publicStringpoem(Stringinput)派生一首诗。 Parameters input-派生一首诗的源字符串 Returns poem-(如上文所说) 声明：翻译自MIT6.031的 GraphPoet(ProblemSet2:PoeticWalks)仅供个人学习个人水平有限，如有疏漏和错误恳请批评指正 

删除.dll文件时遇到的一点问题（操作无法完成因为在资源管理器中打开、系统找不到指定路径） 本人之前误下了一个流氓软件，不仅每天弹窗很多广告，找到它安装路径的文件夹还发现了许多其他软件的.exe。在删除多数文件后有两个文件一直删不掉，显示为“操作无法完成，因为文件已在windows资源管理器打开”。这种一般是.dll文件。 0.先复制要删除的文件路径，包括文件名字。 1.按住Ctrl+Alt+Del,出现如下界面： 选择任务管理器。 2. 如图，在详细信息中找到explorer.exe,右键后选择结束任务（不是结束进程树），这时候屏幕最下方一行会消失。 3.接着选择上方文件，点击选择运行新任务，打开cmd窗口。 4.输入del+空格+所要删除的文件路径（带文件名） 正常来说到这一步就能删除了。但是有可能命令行会显示系统找不到指定路径，是因为路径太复杂了，需要把路径弄短一点，比如把待删除文件直接剪切粘贴到桌面或C盘下。 5.回到任务管理器，依然是点上方文件+运行新任务，在输入栏里输入explorer,如果确定栏是灰的不能点就点一下一系统管理权限创建此任务再点确定。 完成。 

HIT计算机系统大作业：hello的一生 目 录 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 Hello的P2P：从hello.c的源文件开始，通过GCC编译器驱动程序对它进行预处理后生成hello.i文件，再通过编译器生成汇编程序hello.s，汇编程序再通过汇编器生成可重定位目标程序，最后再与标准库函数进行链接生成可执行文件。然后在shell中运行可执行文件，shell通过fork()函数为它开辟新的子进程。Hello.c就从Program变成了Process。 Hello的020：Hello变成进程后，shell再调用execve()函数将程序加载进来：先删除已存在的用户区域，再为Hello映射新的私有区域，映射共享区域。CPU来控制Hello的运行，为它分配资源。当进程结束后，通过父进程回收，通过内核将数据删除，将Hello运行的所有记录消除。 1.2环境与工具 软件环境：VMware®Workstation14Player，Ubuntu16.04LTS64位。硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk。开发调试工具：GCC编译器，EDB，as，ld，readelf。 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 Hello.c Hello的c语言代码 Hello.i 预处理之后的文本文件 Hello.s 编译之后产生的汇编文件 Hello.ld 链接后的文件 Hello.o 可重定位的目标文件 Hello 可执行文件hello Helloo.objdump Hello.o反汇编文件 Hello.elf Hello的ELF格式 Hello.objdump Hello的反汇编文件 1.4本章小结 即使是对于再简单的hello，也同样涉及到了关于计算机系统的从硬件到软件的各个部分的共同配合才能实现一个hello的功能。因此我们要根据hello来了解计算机系统的各个组成部分,从顶层到底层,然后再由底层到顶层,这样我们就进一步了解计算机系统是如何构造和运作的,便于我们更加深刻的了解计算机系统。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 预处理是指在编译之前的预处理阶段，预处理程序对程序进行的操作.预处理器根据以字符#开头的命令（宏定义、条件编译），修改原始的C程序，将引用的所有库展开合并成为一个完整的文本文件。 1.将所有的#define删除，并展开所有的宏定义； 2.处理所有的预编译指令，例如：#if,#elif,#else,#endif; 3.处理#include预编译指令，将被包含的文件插入到预编译指令的位置； 4.添加行号信息文件名信息，便于调试； 5.删除所有的注释：///**/; 6.保留所有的#pragma编译指令，因为在编写程序的时候,我们经常要用到#pragma指令来设定编译器的状态或者是指示编译器完成一些特定的动作。 生成.i文件。 包括:1.宏定义2.文件包含(文件包含是指把指定文件的全部内容包括到当前源程序文件中。)3.条件编译(指在特定的条件下，对满足条件和不满足条件的情况分别进行处理 满足条件时编译某些语句，不满足条件时编译另一些语句。) 预处理的主要作用仅仅是对程序代码文本进行替换操作，如将以#include格式包含的文件内容复制到编译的源文件中，用实际值替换#define定义的宏，以及根据#if的条件决定需要编译的代码。预处理过后程序代码中的预处理指令会被删除。所以预处理器的输出是原程序的一个编辑后的、不包含指令的版本。 2.2在Ubuntu下预处理的命令 预处理命令行：gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析 经过预处理程序处理hello.c源文件由23行扩展成为3000多行，main函数被放在了最后，而前面3000多行是hello.c引用的头文件，如stdio.h。预处理过程中预处理器（cpp）识别到#include这种指令就会在环境中搜寻该头文件并将其递归展开。 #include,#include‘stdio.h’这两种表示形式有区别，第一种系统会直接在c库函数头文件所在的目录中查找要包含的文件，第二种是用户在当前目录中查找，如果找不到才回到c库函数头文件所在目录中华查找要包含的文件，一般用于自己编写的头文件 2.4本章小结 通过本章我们了解到了预处理.预处理是整个编译过程的第一步，在翻译器中，C预处理器（cpp）将源文件翻译成一个ASCII码的中间文件。在这个过程中仅仅是将一些.c文件里面用到的、涉及到的函数库头文件复制到程序源文件中、在程序代码中替换宏定义，并根据条件编译的条件保留相应的内容,直到预处理文件中不包含任何预处理命令为止,就这样完成了预处理的指令，为其继续翻译成机器能够识别的汇编语言文件打下基础。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译是指编译器（ccl）将文本文件hello.i翻译成文本文件hello.s的过程，这个文本文件内包含了一个汇编语言程序。 作用：编译过程编译器实现了经过词法分析、语法分析、语义分析等过程，在检查无错误后将代码翻译成汇编语言。得到的汇编语言代码可供编译器进行生成机器代码、链接等操作。由于计算机并不能直接接受和执行用高级语言编写的源程序（此处指.c，.i文件），因而利用编译器，能将高级语言编写的程序全盘扫描，翻译成用机器语言表示的与之等价的目标程序（此处指.s，即汇编语言程序），该目标程序能被计算机接受和执行，以便后续翻译等操作进行。 3.2在Ubuntu下编译的命令 编译命令行：gcc-Ehello.c-ohello.s 结果展示为： 3.3Hello的编译结果解析 文件声明： .file源文件 .text代码段 .globel全局变量 .align对齐格式 .type对象类型或函数类型 .size数据空间大小 .section.rodata只读代码段 .string字符串 数据： .s文件中主要数据类型为：整形，字符串，指针数组 1.整形 （1）.main参数intargc： Argc是函数传入的第一个int的参数，存储在%edi中，表示终端输入的参数的个数多少。 （2）.main函数中的局部变量inti： 函数内部的局部变量存于堆栈中，其中用movl$0,-4(%rbp)进行数据在堆栈内的存储，并且由于-4所以可知i占用了4字节大小的栈空间 2.字符串： （1）第一个字符串.LC0中包含汉字，其中汉字的编码方式为utf-8编码，汉字被编码为三个字节。 （2）第二个字符串.LC1其中的两个%S对应与输入的两个参数：argv[1]和argv[2]。 3.指针数组argv[]: 作为main函数的参数出现在栈帧中。 赋值： 1.对局部变量的赋值： 通过movl指令，利用寄存器和$0,-4(%rbp)指令对局部变量进行赋初值0 算术操作： Hello.c中的主要的算术操作为循环遍历增加（i++）以及语句argc！=4 编译器将i++翻译为addl$1,-4(%rbp) 关系操作： Hello.c中的主要的算术操作为循环的控制（i<10）以及语句argc！=4 编译器将i<8翻译为$7,4(%rbp) 将argc！=4翻译为cmpl$4,-20(%rbp) 数组/指针/结构操作 指针数组(char*argv[])： 在argv数组中，argv[0]指向输入程序的路径和名称，argv[1]和argv[2]和argc[3]分别指向两个用户从终端输入的字符串分别对应学号姓名时间。根据图3-11，可知通过%rax+16和%rax+24%rax+8中存储的地址，(语句：addq$24,%raxaddq$16,%rax以及addq$8,%rax)分别得到argv[1]和argc[2]和argc[3] 控制转移： hello.c内部的控制转移主要有if语句以及for循环内部的控制转移 1.for(i=0;i<8;i++)： for循环的控制时比较cmpl$7,-4(%rbp)，当i大于9时跳出循环，否则进入.L4循环体内部执行 2.if(argc!=4)： 当argc不等于4时进行跳转。cmpl语句比较-20(%rbp)和-4，设置条件码，然后根据ZF进行判断，如果最近的操作得出的结果为0，则跳到.L2中，否则顺序执行下一条语句。 函数操作： 内部主要有5个函数：main(),printf(),exit(),atoi(),sleep(),getchar() 1.main()： 参数传递：传入参数argc和argv，分别用寄存器%rdi和%rsi存储 函数调用：被系统启动函数调用， 函数返回：设置%eax为0并且返回 函数作用：作为程序运行的唯一入口 2.printf()： 参数传递：callputs时只传入了字符串参数首地址；for循环中callprintf时传入了argv[1]和argc[2]的地址。 函数调用：在for循环中被调用 函数作用：用来打印信息 3.exit()： 参数传递：传入一个布尔变量 函数调用：if判断条件满足后被调用 函数作用：如果传入的参数为1，则执行退出命令 4.atoi()： 参数传递：传入参数argv[3] 传递控制：callatoi 函数调用：for循环下被调用 函数作用：将传入的参数从字符串形式转化为int整形 5.sleep()： 参数传递：传入参数argv[3]经过atoi函数的输出值 传递控制：callsleep 函数调用：for循环下被调用 函数作用：使计算机程序（进程，任务或线程）进入休眠 6.getchar(): 传递控制：callgetchar 函数调用：在main中被调用 函数作用：用来读取字符串 3.4本章小结 编译器将预处理后的文本进行汇编处理，对于常量，编译器将它储存到一个特定的位置，记录它的一些信息，比如类型；对于一些特定的常量，比如printf()函数中的信息，编译器会把它提取出来保存。程序中的语句，例如赋值语句，编译器通过寄存器，栈等结构进行赋值；分支语句用je,jle,jge等条件跳转语句进行实现。每种语句都有对应的实现方法。程序中的函数，如果不是库函数，则会对函数进行逐句的语法分析和解析，如果是标准的库函数，编译器可以直接用call语句进行调用。 在本章中，编译器将高级语言编译成汇编语言，在以上的分析过程中，详细的分析了编译器是怎么处理C语言的各个数据类型以及各类操作的，按照不同的数据类型和操作格式，解释了hello.c文件与hello.s文件间的映射关系。在此阶段，编译器将hello.i文件编译成更抽象更低级的hello.s汇编语言文件，为汇编阶段产生机器可识别的机器语言指令打下基础。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 汇编的概念：通过汇编器将汇编语言转化为机器语言。 汇编的作用：汇编器将hello.s翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在hello.o中，hello.o是二进制文件。 4.2在Ubuntu下汇编的命令 汇编命令行：gcc-chello.s-ohello.o 应截图，展示汇编过程！ 4.3可重定位目标elf格 ELF可重定位目标文件的格式： 汇编器在对hello.s文件转化为机器代码后，对程序做出了最基本的处理，在rel.text对每个调用的标准库函数和全局变量给出了偏移量，以及在信息一类中给出的符号在symbol节中的偏移量，以及符号的类型。 4.4Hello.o的结果解析 说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 反汇编后的汇编代码已经进行了初始化的定位，形成EIF可重定位文件，并且每条指令都给出了对应的机器码。 1）对于条件分支：.s文件中通过使用.Ln等助记符来标记跳转位置，而在反汇编文件中去掉了这种记号，直接使用偏移地址来进行跳转。 hello.s文件： 反汇编文件： 2）对于函数调用：在.s文件中，call指令后面接的是函数名，并没有给出地址，而在反汇编文件中，给出了函数的偏移地址。因为在汇编的过程中，对于程序中的函数，汇编器在EIF文件的rel.text段中给出了定位，所以反汇编中函数就有了相对于首地址的偏移地址。 hello.s文件： 反汇编文件： 3）对于全局变量调用：.s文件中通过全局变量的名字加上%rip的值来调用，而在反汇编代码中通过0x0加上%rip的值来调用。因为在.s文件中并没有给出全局变量地址的信息，所以只能通过变量名来标记；在反汇编代码中，已经对全局变量作出了定位处理，当后续操作进行链接后就可以给出绝对地址了。 hello.s文件: 反汇编文件： 4.5本章小结 汇编器对hello.s文件进行汇编，生成了可重定位文件。对文件的全局变量，函数，程序语句都进行了分析，给出了初始的相对位置信息，相当于对整个文件做出了一个初始的整理，为后面的链接等操作做准备。 （以下格式自行编排，编辑时删除） （第4章1分） 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。链接是由叫做链接器的程序执行的。链接器使得分离编译成为可能。 5.2在Ubuntu下链接的命令 执行命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5-1链接截图 5.3可执行目标文件hello的格式 执行命令：readlf-ahello 得到Sectionheader的信息截图如下，其中offset为各section的在程序中的地址偏移量，size为各段的大小，基本信息与可重定位文件相似，见4.3节。这里的Sectionheader与可重定位文件有一个明显的区别就是address不再都是0了，被分配了相应的虚拟空间的地址。 图5-2hello的ELF文件sectionheader 5.4hello的虚拟地址空间 通过view->memoryregions开业查看程序运行各个段的地址。 第一段0x400000~0x401000为1~11段的地址 第二段0x401000~0x402000为12~16段的地址 第三段0x402000~0x403000为17~28段的地址。 第四段0x403000~0x405000为19~22段的地址。 剩下的.so为共享库的地址，还有[stack]堆栈的地址。 在0x400000~0x405000段中，程序被载入，自虚拟地址0x400000开始，自0x404fff结束，这之间每个节（开始~.data节）的排列即开始结束同图5.2中Address中声明。 图5-3hello程序的虚拟内存区域 5.5链接的重定位过程分析 （以下格式自行编排，编辑时删除） objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 与hello.o反汇编文本helloo.objdump相比，在hello.objdump中多了许多节，列在下面。通过比较hello.objdump和helloo.objdump了解链接器。 1.函数个数：在使用ld命令链接的时候，指定了动态链接器为64的/lib64/ld-linux-x86-64.so.2，crt1.o、crti.o、crtn.o中主要定义了程序入口_start、初始化函数_init，_start程序调用hello.c中的main函数，libc.so是动态链接共享库，其中定义了hello.c中用到的printf、sleep、getchar、exit函数和_start中调用的__libc_csu_init，__libc_csu_fini，__libc_start_main。链接器将上述函数加入。 2.函数调用：链接器解析重定条目时发现对外部函数调用的类型为R_X86_64_PLT32的重定位，此时动态链接库中的函数已经加入到了PLT中，.text与.plt节相对距离已经确定，链接器计算相对距离，将对动态链接库中函数的调用值改为PLT中相应函数与下条指令的相对地址，指向对应函数。对于此类重定位链接器为其构造.plt与.got.plt。 3. rodata引用：链接器解析重定条目时发现两个类型为R_X86_64_PC32的对.rodata的重定位（printf中的两个字符串），.rodata与.text节之间的相对距离确定，因此链接器直接修改call之后的值为目标地址与下一条指令的地址之差，指向相应的字符串。 图5-4初始化函数_init反汇编代码 图5-5.plt函数反汇编代码 图5-6 hello调用库函数的反汇编代码 图5-7_start程序（调用hello.c中的main函数）反汇编代码 我们来看main函数反汇编代码，他调用的函数都已经在hello的反汇编代码中显示的定义了出来，有地址有名称，可以直接call这个函数，跳转到函数的地址。他调用的rodata也是可以直接跳转到具体地址的。 图5-8main函数反汇编代码 图5-9调用的动态库的反汇编代码。 5.6hello的执行流程 在edb中加载hello可执行文件列出所有过程(终端输入hello1190301610wangjiaqi) 子程序名地址ld-3.31.so!_dl_start7efbff4d8ea0ld-3.31.so!_dl_init7efbff4e7630Hello!_start400500libc-3.31.so!_libc_start_main7efbff100ab0Hello!printf@plt(10)4004c0Hello!sleep@plt(10)4004f0Hello!getchar@plt4004d0Libc-3.31.so!exit7efbff122120 列出所有过程（未输入） 子程序名地址ld-3.31.so!_dl_start7efbff4d8ea0ld-3.31.so!_dl_init7efbff4e7630Hello!_start400500libc-3.31.so!_libc_start_main7efbff100ab0Hello！puts@plt4004b0Hello！exit@plt4004e0 5.7Hello的动态链接分析 对于动态共享库里面的PIC函数，编译器没有办法预测函数运行时候的地址，所以需要为他天骄重定位记录，并等待动态链接器来处理。为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。动态链接器使用过程链接表PLT和全局偏移量表GOT实现函数的动态链接。其中GOT中存在函数目标地址，PLT使用GOT中的地址跳转到目标函数。 5.8本章小结 本章详细讲述了hello在执行的时候的链接操作，包括链接的概念，作用，在Unbuntu下怎么链接。并对hello的ELF文件进行了详细的解析，同时结合了虚拟地址的空间知识。通过反汇编hello文件，将它与hello.o反汇编文件进行对比，加深了对重定位的理解。最后对hello的动态链接过程进行了分析。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的概念：进程是操作系统一个正在运行的程序的一种抽象。程序在系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器，主存和I/O设备。处理器看上去就像在不间断地一条接一条的执行程序中的指令。 进程的作用：通过进程的概念，系统可以实现多线程，并发运行等操作。 6.2简述壳Shell-bash的作用与处理流程 shell作为父进程通过fork函数为hello创建一个新的进程，供其执行。通过fork函数，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本。 处理流程：shell执行一系列的读／求值(read/evaluate)步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。 6.3Hello的fork进程创建过程 Shell通过调用fork函数创建一个新的运行的子进程。也就是Hello程序，Hello进程几乎但不完全与Shell相同。Hello进程得到与Shell用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。Hello进程还获得与Shell任何打开文件描述符相同的副本，这就意味着当Shell调用fork时，Hello可以读写Shell中打开的任何文件。Sehll和Hello进程之间最大的区别在于它们有不同的PID。 6.4Hello的execve过程 创建进程后，在子进程中通过判断pid即fork()函数的返回值，判断处于子进程，则会通过execve函数在当前进程的上下文中加载并运行一个新程序。execve加载并运行可执行目标文件，且带参数列表argv和环境变量列表envp。只有当出现错误时，execve才会返回到调用程序。 在execve加载了可执行程序之后，它调用启动代码。启动代码设置栈，并将控制传递给新程序的主函数，即可执行程序的main函数。此时用户栈已经包含了命令行参数与环境变量，进入main函数后便开始逐步运行程序。 6.5Hello的进程执行 创建进程后，在子进程中通过判断pid即fork()函数的返回值，判断处于子进程，则会通过execve函数在当前进程的上下文中加载并运行一个新程序。execve加载并运行可执行目标文件，且带参数列表argv和环境变量列表envp。只有当出现错误时，execve才会返回到调用程序。 在execve加载了可执行程序之后，它调用启动代码。启动代码设置栈，并将控制传递给新程序的主函数，即可执行程序的main函数。此时用户栈已经包含了命令行参数与环境变量，进入main函数后便开始逐步运行程序。 6.5Hello的进程执行 逻辑控制流：一系列程序计数器PC的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 用户模式和内核模式：处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权，当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。 hello程序执行过程中存储时间分片，与操作系统的其他进行并发运行。并发执行涉及到操作系统内核采取的上下文交换策略。内核为每个进程维持一个上下文，上下文就是内核重新启动一个先前被抢占的进程所需的状态。 在执行过程中，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程，这个过程称为调度。 在此基础上，hello程序与操作系统其他进程通过操作系统的调度，切换上下文，拥有各自的时间片从而实现并发运行。 程序在涉及到一些操作时，例如调用一些系统函数，内核需要将当前状态从用户态切换到核心态，执行结束后再及时改用户态，从而保证系统的安全与稳定。 6.6hello的异常与信号处理 Ctrl-C命令，hello被终止，如下图。 图6-4 Ctrl-C Ctrl-z命令，hello被暂停，利用ps查看，还可以看到hello仍在进程里面。 图6-5 Ctrl-z后运行ps Ctrl-z命令，hello被暂停，利用jobs查看，还可以看到hello状态为stopped。 图6-6 Ctrl-z后运行jobs Ctrl-z命令，hello被暂停，执行fg，hello继续执行，jobs里面没有hello，hello被父进程回收。 图6-7 Ctrl-z后运行fg 6.7本章小结 在本章中hello已经正式上岗工作运行了，这都多亏于“进程”这个概念的提出。进程给hello提供了抽象的概念，使得进程能够有条不紊的并发执行。各个进程之间也不会产生严重的矛盾和冲突，是进程使得不同的程序能在相安无事的运行直到结束。 本章主要介绍了进程的概念和作用，描述了shell如何在用户和系统内核之间搭建桥梁，介绍了fork函数和execve函数在调用程序中的作用，程序的异常如何处理，不同进程之间是如何进行上下文切换等等内容。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 物理地址：物理地址是内存单元的绝对地址，与地址总线具有对应关系。无论CPU如何处理地址，最终访问的都是物理地址。CPU实模式下段地址+段内偏移地址即为物理地址，CPU可以使用此地址直接访问内存。物理地址的大小决定了内存中有多少个内存单元，物理地址的大小由地址总线位宽决定。 线性地址（虚拟地址）：CPU在保护模式下，“段基址+段内偏移地址”为线性地址，如果CPU在保护模式下未开启分页功能，线性地址将被当成物理地址使用。若开启了虚拟分页功能，线性地址等同于虚拟地址，此时虚拟地址需要通过页部件电路转化为最终的物理地址。虚拟地址是CPU由N=2n个地址空间中生成的，虚拟地址即为虚拟空间中的地址。 逻辑地址：无论cpu在什么模式下，段内偏移地址又称为有效地址/逻辑地址 Hello中的指令地址都是16位的虚拟地址，在程序中虚拟地址和逻辑地址没有明显的界限。 逻辑地址转换成线性地址（虚拟地址），由段式管理执行的 线性地址转换成物理地址，是由页式管理执行的 7.2Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部分组成，段标识符和段内偏移量。段标识符由16位字段组成，前13位为索引号。 索引号是段描述符的索引，很多个描述符，组成了一个数组，叫做段描述表，可以通过段描述标识符的前13位，再这个表中找到一个具体的段描述符，这个描述符就描述了一个段，每个段描述符由八个字节组成。 段描述符中的base字段，描述了段开始的线性地址，一些全局的段描述符，放在全局段描述符表中，一些局部的则对应放在局部段描述符表中。由T1字段决定使用哪个。 以下是具体的转化步骤： 1.给定一个完整的逻辑地址。 2.看段选择符T1，知道要转换的是GDT中的段还是LDT中的段，通过寄存器得到地址和大小。 3.取段选择符中的13位，再数组中查找对应的段描述符，得到BASE，就是基地址。 4.线性地址等于基地址加偏移。 7.3Hello的线性地址到物理地址的变换-页式管理 分页管理机制通过上述页目录表和页表实现32位线性地址到32位物理地址的转换。控制寄存器CR3的高20位作为页目录表所在物理页的页码。首先把线性地址的最高10位(即位22至位31)作为页目录表的索引，对应表项所包含的页码指定页表；然后，再把线性地址的中间10位(即位12至位21)作为所指定的页目录表中的页表项的索引，对应表项所包含的页码指定物理地址空间中的一页；最后，把所指定的物理页的页码作为高20位，把线性地址的低12位不加改变地作为32位物理地址的低12位。 为了避免在每次存储器访问时都要访问内存中的页表，以便提高访问内存的速度，80386处理器的硬件把最近使用的线性 物理地址转换函数存储在处理器内部的页转换高速缓存中。在访问存储器页表之前总是先查阅高速缓存，仅当必须的转换不在高速缓存中时，才访问存储器中的两级页表。页转换高速缓存也称为页转换查找缓存，记为TLB。 在分页机制转换高速缓存中的数据与页表中数据的相关性，不是由80386处理器进行维护的，而必须由操作系统软件保存，也就是说，处理器不知道软件什么时候会修改页表，在一个合理的系统中，页表只能由操作系统修改，操作系统可以直接地在软件修改页表后通过刷新高速缓存来保证相关性。高速缓存的刷新通过装入处理器控制寄存器CR3完成。 7.4TLB与四级页表支持下的VA到PA的变换 TLB可以理解为页表的一个小的，虚拟寻址的高速缓存（类似cache是内存的一个缓存），用于组选择和行匹配的索引和标记字段是从虚拟地址的页号中提取出来的，如下图所示，如果TLB有2^t组，TLB索引（TLBI）由VPN的t个低位组成的，TLB标记（TLBG）是由VPN中剩余的位组成的。 图7-TLB寻址 为了减少页表在内存空间的占用，引入了多级页表的机制，k级页表示意图如下。如果虚拟内存不存在，则不分配页表来记录这段内存。 1级页表指向2级页表，2级页表存储的是3级页表基地址，只有最后一级页表的内容是PTE和物理页号。 图7-K级页表示意图 前提如下：虚拟地址空间48位，物理地址空间52位，页表大小4KB，4级页表。TLB4路16组相联。CR3指向第一级页表的起始位置（上下文一部分）。 解析前提条件：由一个页表大小4KB，一个PTE条目8B，共512个条目，使用9位二进制索引，一共4个页表共使用36位二进制索引，所以VPN共36位，因为VA48位，所以VPO12位；因为TLB共16组，所以TLBI需4位，因为VPN36位，所以TLBT32位。 如图，CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（前32位）+TLBI（后4位）向TLB中匹配，如果命中，则得到PPN（40bit）与VPO（12bit）组合成PA（52bit）。如果TLB中没有命中，MMU向页表中查询，CR3确定第一级页表的起始地址，VPN1（9bit）确定在第一级页表中的偏移量，查询出PTE，如果在物理内存中且权限符合，确定第二级页表的起始地址，以此类推，最终在第四级页表中查询到PPN，与VPO组合成PA，并且向TLB中添加条目。如果查询PTE的时候发现不在物理内存中，则引发缺页故障。如果发现权限不够，则引发段错误。 图7-TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 前提：只讨论L1Cache的寻址细节，L2与L3Cache原理相同。L1Cache是8路64组相联。块大小为64B。 解析前提条件：因为共64组，所以需要6bitCI进行组寻址，因为共有8路，因为块大小为64B所以需要6bitCO表示数据偏移位置，因为VA共52bit，所以CT共40bit。 在上一步中我们已经获得了物理地址VA，使用CI进行组索引，每组8路，对8路的块分别匹配CT（前40位）如果匹配成功且块的valid标志位为1，则命中（hit），根据数据偏移量CO（后六位）取出数据返回。 如果没有匹配成功或者匹配成功但是标志位是1，则不命中（miss），向下一级缓存中查询数据（L2Cache->L3Cache->主存）。查询到数据之后，一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换。 图7-三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 虚拟内存和内存映射解释了fork函数如何为每个新进程提供私有的虚拟地址空间。 为新进程创建虚拟内存。 创建当前进程的的mm_struct,vm_area_struct和页表的原样副本。 两个进程中的每个页面都标记为只读。 两个进程中的每个区域结构（vm_area_struct）都标记为私有的写时复制（COW）。 在新进程中返回时，新进程拥有与调用fork进程相同的虚拟内存。 随后的写操作通过写时复制机制创建新页面。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： 1.删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 2.映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3.映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。图7-8展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3,从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，反映出VP4不再缓存在主存中这一事实。缺页处理程序从磁盘上用VP3的副本取代VP4，在缺页处理程序重新启动导致缺页的指令之后，该指令将从内存中正常地读取字，而不会再产生异常。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器分为两种：显式分配器、隐式分配器。显式分配器：要求应用显式地释放任何已分配的块，例如malloc（）函数。隐式分配器（垃圾收集器）：要求分配器检测一个已分配块何时不再使用，那么就释放这个块；自动释放未使用的已经分配的块的过程叫做垃圾收集。 隐式空闲链表：所谓隐式空闲链表，对比于显式空闲链表，代表并不直接对空闲块进行链接，而是将对内存空间中的所有块组织成一个大链表，其中Header和Footer中的block大小间接起到了前驱、后继指针的作用。 图7- 隐式空闲链表结构 涉及到的操作包括查找空闲块，malloc一个块，合并空闲块等等。其中比较复杂的就是合并空闲块这个操作，因为合并空闲块，不仅要看此块之后是不是空闲块，还要看之前是不是空闲块，这也是加入头部和角标的原因之一。对于此块前后是否为空闲块，分为以下四种情况，对每种情况要分别考虑。 图7- 隐式空闲链表合并空闲块 7.10本章小结 本章着重介绍了被许多现代操作系统所采用的虚拟内存系统，即访存时地址需要从逻辑地址翻译到虚拟地址并进一步翻译成物理地址，并详细阐述了在TLB和四级页表支持下VA到PA的转换，以及得到了PA后，三级cache下的物理内存的访问过程，最后还讨论了malloc堆区的动态内存分配。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化： 所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。 设备管理：unixio接口 设备管理方法：一个linux文件就是一个m个字节的序列：B0,B1,…,Bk,…,Bm-1所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。 8.2简述UnixIO接口及其函数 （UnixI/O接口： 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访间一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 2.Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO、STOOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值。 3.改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k,初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为K。 4.读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 5.关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数： 1.进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的： intopen(char*filename,intflags,mode_tmode); open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。 返回：若成功则为新文件描述符，若出错为-1。 2.进程通过调用close函数关闭一个打开的文件。 intclose(intfd); 返回：若成功则为0,若出错则为-1。 3.应用程序是通过分别调用readwrite函数来执行输入和输出的。 ssize_tread(intfd,void*buf,size_tn); read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 返回：若成功则为读的字节数，若EOF则为0,若出错为-1。 ssize_twrite(intfd,constvoid*buf,size_tn); write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 返回：若成功则为写的字节数，若出错则为-1。 8.3printf的实现分析 首先观察printf函数的实现 我们发现printf函数中，定义了一个字符指针va_list类型的arg，这个函数调用了vsprintf，继续看一下他： 函数主要实现的功能：格式化。接受确定输出格式的字符串fmt，勇哥是字符串对个数变化参数进行格式化，产生格式化输出。 系统函数write 反汇编write函数，发现要调用INT_VECTOR_SYS_CALL，他通过系统调用sys_call这个函数。 再来看sys_call这个函数，通过分析，知道这个函数的主要功能是显示格式化的字符串，将要输出的字符串从总线复制到显卡的显存里面 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。我们要显示的“hello1190301610王家琪”就被打印输出到了显示器上。 8.4getchar的实现分析 getchar有一个int型的返回值.当程序调用getchar时.程序就等着用户按键.用户输入的字符被存放在键盘缓冲区中.直到用户按回车为止(回车字符也放在缓冲区中).当用户键入回车之后,getchar才开始从stdin流中每次读入一个字符.getchar函数的返回值是用户输入的第一个字符的ASCII码,如出错返回-1,且将用户输入的字符回显到屏幕.如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取.也就是说,后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 输入／输出(I/O)是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。Linux本身提供的一些系统函数已经实现了对底层的调用，例如write函数。printf函数正是通过它间接向标准输出这个文件输出内容，它会调用syscall触发中断以内核模式对硬件进行操作。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 hello最开始是一段代码，描述了它想要进行的操作，但它却不能实现操作，因为它缺少各种条件，它只有代码。当系统想要执行它的时候，hello就开始了它的一生： 首先先对hello.c源文件进行预处理，将hello需要的头文件中的信息插入到文本中，生成了hello.i文件；为了更好的翻译为机器代码，hello.i文件被汇编为hello.s汇编文件，对于程序中的函数，变量，语句都进行了语法分析；再将汇编文件编译成为hello.o机器代码文件，是一个二进制文件，并且对于程序中的函数，变量做出了最基础的处理，为它们划分了不同的段，储存了不同的信息，包括偏移量，访问权限等等信息；最后将程序调用的子函数进行链接，并且将逻辑地址转化为虚拟地址，形成了可执行文件。这个时候hello就有了可以被执行的条件，但是它还不能执行，因为它没有系统分配的资源，包括它要运行的空间等等。 当在shell中输入命令行执行hello时，shell首先分析参数，然后调用fork()函数为它开辟新的子进程，这个时候hello就有了资源：它拥有了和父进程完全一样但独立的用户虚拟空间。execxe()函数将hello程序加载到进程。子进程执行hello所请求的操作，并且通过调用异常处理子程序处理执行过程的异常。对于hello的储存管理，处理器采用逻辑控制流的抽象来保证hello的执行，并且采用虚拟内存的抽象，好像hello独占整个内存。系统采用页表来管理hello的虚拟地址，hello的虚拟地址要翻译为物理地址才能找到数据，物理地址首先到cache中找，然后再到主存中找，找到后返回给进程。 hello进程和I/O设备有交互，所以调用了printf()函数。系统对I/O设备采用映射文件的管理方式。 最后hello进程执行完操作后，会由父进程来回收，并且将它所占用的资源删除，这时候hello就结束了。它又变成了一段代码。下一次在用它时，开启的进程是不是和上一个进程是一个呢？还是上一个进程已经永远的结束了呢？ （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 hello.c：hello的c语言源代码 hello.i：预处理后的文本文件 hello.s：hello.i编译后的汇编文件 hello.o：hello.s汇编后的可重定位目标文件 hello.txt：hello.o的elf文件 hello_obj.txt：hello.o的反汇编结果文件 hello：helllo.o与预编译文件链接后的可执行文件 hello_e.txt：可执行文件hello的elf文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42. [2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998 [1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL]. Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/ collection/anatmorp. （参考文献0分，缺失-1分） 

hello的一生 摘要 本文通过对一个简单的hello程序的创建、运行、到终止的跟踪，阐述了预处理、编译、汇编、链接、进程管理、存储管理、IO管理等的原理以及和hello程序结合的内容。 关键词：汇编；链接；进程管理；hello程序的一生； 目录 摘要 第一章概述 1.1hello简介 1.2环境与工具 1.2.1硬件环境 1.2.2软件环境 1.2.3开发与调试工具 1.3中间结果 1.4本章小结 第2章预处理 2.1 预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2在Ubuntu下编译的命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标elf格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 5.5链接的重定位过程分析 重定位算法如下： 以对hello.o中的puts分析为例： 5.6hello的执行流程 5.7Hello的动态链接分析 5.8本章小结 第6章hello进程管理 6.1进程的概念与作用 6.2简述壳Shell-bash的作用与处理流程 6.3Hello的fork进程创建过程 6.4Hello的execve过程 6.5Hello的进程执行 6.6hello的异常与信号处理 6.7本章小结 第7章hello的存储管理 7.1hello的存储器地址空间 7.2Intel逻辑地址到线性地址的变换-段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问 7.6hello进程fork时的内存映射 7.7hello进程execve时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章hello的IO管理 8.1Linux的IO设备管理方法 8.2简述UnixIO接口及其函数 8.3printf的实现分析 8.4getchar的实现分析 8.5本章小结 结论 附件 参考文献 第一章概述 1.1hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 Hello的P2P：首先，在hello.c中编写程序，此时program形成。在linux下，hello.c经过cpp的预处理变为hello.i、经过ccl的编译变为hello.s、经过as的汇编变为hello.o、经过ld的链接变为可执行程序hello。在shell中，输入执行hello的指令之后，shell调用fork函数创建一个子进程，再在子进程中调execve函数，将hello加载到这个子进程中，覆盖掉原子进程，即hello变为了一个进程（process），完成P2P。 Hello的020：在hello成为进程之后，操作系统为该进程划分时间片，让它不断与其他进程上下文切换，并发执行。Hello的执行中，不断从内存中取指令，此时用到了MMU将虚拟内存转换为物理内存，再利用了快表、4级页表、3级cache等来进行加速从内存中取出数据。在Hello的执行中，还可能接收并处理来自键盘等IO设备的信号，还可能产生缺页等异常，还会经过上下文切换进入异常处理程序。在hello执行完毕之后，由其父进程shell来对其进行回收，从此hello进程不复存在，完成020。 1.2环境与工具 1.2.1硬件环境 Intel64CUP；2.6GHZ；RAM16G；256GDisk 1.2.2软件环境 Windows10 64位；Vmware15；Ubuntu18.0464位 1.2.3开发与调试工具 Linux下：gcc，vim，edb，gdb，readelf Windows下：HexEdit 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 文件名作用hello.chello程序的源代码（文本文件）hello.ihello.c预处理处理得到的文件（文本文件）hello.shello.i编译后得到的汇编代码（文本文件）hello.ohello.s汇编后得到的可重定位目标文件（二进制文件）helloHello.o与其他文件链接后得到的可执行文件（二进制文件） 1.4本章小结 本章对hello程序进行了一个P2P、020的简介，列出了编写本论文用到的软硬件环境、工具、中间产物及其作用等。 （第1章0.5分） 第2章预处理 2.1 预处理的概念与作用 预处理概念：在编译之前对源文件提前进行的内存处理。预处理过程扫描源代码，对其进行初步转换，产生新的源代码提供给编译器，可见预处理过程先于编译器对源代码进行处理。预处理格式为：#+指令关键字。 作用：1.预处理过程读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行相应的转换。2.预处理过程还会删除程序中的注释和多余的空白字符。3.预处理还会将源程序引用的所有库导入并且合并成为一个完整的文本文件。 2.2在Ubuntu下预处理的命令 命令：gcchello.c-E-ohello.i 图2.2 2.3Hello的预处理结果解析 图2.3 Hello.i仍然为文本文件。由hello.i与hello.c的对比可以看出，在hello.c的基础上，预处理对其添加了许多内容，其中大量使用了typedef语句，extern关键字以及结构体。hello.c文件的头文件被拷贝进了hello.i文件，而宏定义也被逐一替换。 2.4本章小结 本章对.c文件的预处理进行了介绍，了解了.c文件是如何经过处理头文件，宏替换等一系列操作而被预处理的，阅读了.i文件，了解了其与.c文件的区别。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译阶段是检查语法，生成汇编的过程。就是把代码转化为汇编指令的过程，汇编指令只是CPU相关的。 作用：将.i文件翻译成汇编文件.s。编译过程还具备语法检查、方便调试、加上特定参数还可以使目标程序不同程度的优化、使不同逻辑的高级语言产生相同的汇编语言，便于后续将其一一对应翻译为机器码，而不受高级语言限制。 3.2在Ubuntu下编译的命令 命令：gcc-Shello.i-ohello.s 图3.2 3.3Hello的编译结果解析 3.3.0汇编文件头 开头如下： 图3.3.0 .file：源文件名（.c文件）.text：代码段.globl：全局变量.data：数据段.align：对齐方式，按4字节对齐 .type：指定其为对象类型或者函数类型.size：大小.long：长整型 其值为2 .section.rodata：以西是.rodata节.string：字符串常量 3.3.1数据 常量 在.c程序中出现的常量，在汇编中都以立即数的形式出现：比如: 在汇编中为： 即3表示为$3。 变量 全局变量： 其在汇编中表示为: 可知，全局变量保存在.rodata节中。其值为2（由于2.5强转而来），为对象类型，占据4个字节。 局部变量： 在汇编中表示为： 说明i存放在栈中，地址为%rbp-0x4. main函数的两个参数: 在汇编中体现如下： 说明argc变量存储在%edi中，并且转存在%rbp-0x20中 说明argv变量存储在%rdi中，并且转存在%rbp-0x32中 类型 虽然sleepsecs全局变量在程序中被定义为int类型，但是在汇编中被定义为long类型。 3.3.2赋值 在c语言中的变量的赋值语句在汇编中均使用mov语句来实现 将i赋值为0. 将sleepsecs赋值为2 局部变量保存在栈中，初始化的全局变量保存在.data中 3.3.3类型转换 由此可以看出，c程序对sleepsecs进行了强制类型转换，将float强行转换为int类型，但是实际上汇编把他当作long类型。强制类型转换满足取整数部分的原则 3.3.4算数操作 即为自增运算，其在汇编中实现如下： 3.3.5关系操作 ，在汇编中实现如下： ，在汇编中实现如下： ，采取的和9比较，跳转条件为小于等于，与i<10意义相同。 3.3.6数组操作 在调用printf时，将使用了argv[1],argv[2]来作为printf的参数，在汇编中实现如下： ，其使用了加载有效地址指令leaq来计算LC1的所在段的段地址，为%rip+.LC1并将所计算的地址传递给%rdi作为printf的参数 3.3.7控制转移 ，其汇编实现如下： 先使用cmp指令来比较，再利用设置的条件码来进行条件跳转 ，其汇编实现如下： 与if类似，只不过跳转到的位置为for循环内部的起始代码位置 3.3.8函数操作 参数传递：argc和argv，分别保存在%edi和%rsi。函数调用：系统自动启动。函数返回：将%eax设置为0并且返回，对应于return0 参数传递：单参数的printf函数被汇编为puts，调用时只传入了字符串参数首地址； 而for循环中多参数的printf函数被汇编为printf，调用时传入了argv[1]和argc[2]的地址。 函数调用：if语句成立时调用，for循环中调用 对应的汇编为： 参数传递：传入的参数为立即数$1，执行退出命令函数调用：if语句成立时调用 对应的汇编为： 参数传递：传入参数sleepsecs函数调用：for循环中调用 对应的汇编为： 参数传递：无参数函数调用：在main中被调用 3.4本章小结 本章对.i文件进一步被生成的.s文件进行了了解和解释，分别从8个方面对汇编文件进行了对应解释，更加熟悉了c语言与汇编语言的对应关系，更加熟练了解了汇编语言，更加了解了高级语言对应的汇编层面的实现。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：编译后的文件到生成机器语言二进制程序的过程，机器码可以被CPU直接执行。 作用：可以将汇编语言一一对应翻译为计算机可以识别的机器码，它将汇编语言变为成可重定位目标程序的格式保存，即.o文件，还可以利用汇编产生的.o文件反汇编来调试代码。 4.2在Ubuntu下汇编的命令 命令：gcchello.s-c-ohello.o 图4.2 4.3可重定位目标elf格式 首先输入 readelf-hhello.o查看hello.o的ELF头的信息 图4.3.1hello.o的ELF头的信息 由图4.3.1头信息可得知ELF文件的基本信息，如：该.o文件为可重定位文件；ELF头的大小为64字节，程序头有0个，节头有13个 等等。 输入readelf-Shello.o查看hello.o的节头信息 图4.3.2hello.o的节头信息 再输入readelf-shello.o查看符号表 图4.3.3符号表 再输入readelf-rhello.o查看重定位信息 图4.3.4重定位信息 分析可知，再.rela.text中有8个项目需要重定位，包含1个变量、2个段以及5个函数，.rela.eh_frame有1个项目需要重定位，包含1个段。 输入readelf-ahello.o查看ELF所有信息 图4.3.5 ELF所有信息 由以上可知ELF格式文件由ELF头、节头、符号表、重定位信息等组成。 4.4Hello.o的结果解析 输入objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 输入objdump-d-rhello.o后输出如下： 图4.4.1hello.o的反汇编 而之前的.s文件如下： 图4.4.2hello.s 对比分析可知： 机器语言与汇编语言位一一对应。 区别如下： .s文件中objdump中分支转移类似于.L4的跳转目录指令的地址，如jmp6f函数调用使用函数名称使用函数地址进制使用十进制使用16进制全局变量使用sleepsecs(%rip)访问使用0x0(%rip)访问 4.5本章小结 通过对本章的完成，我深入了解了.o文件，更加熟练地使用了readelf指令查看ELF格式文件，之后还对之前生成的.s文件与objdump反汇编生成的文件进行了对比，明白了两者之间的细微区别。还了解了机器语言与汇编语言的对应关系。 （第4章1分） 第5章链接 5.1链接的概念与作用 概念：分为静态链接和动态链接。静态链接是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息。编译时，加载时，运行时都可以链接。 作用：把多个可重定位文件合并在一起，找到这些文件之间的关系，生成一个大的、有绝对位置的目标程序，使得机器可以执行。 5.2在Ubuntu下链接的命令 使用ld的链接命令，应截图，展示汇编过程！注意不只连接hello.o文件 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.2 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 使用readelf-ahello命令得到如下信息： 图5.3.1ELF头信息 与hello.o不同为：类型为可执行文件，且程序头大小为56字节，有8个程序头，而段头数量也增加为25。 图5.3.2段头信息 对25个段头的信息进行了一一列出，还包含了整体信息，比如名称，类型，载入虚拟地址的起始地址，在程序中偏移量，对齐信息等等。 图5.3.3程序头信息 图5.3.4重定位节信息 图5.3.5符号表信息 等等一系列的信息，具体可以使用readelf-ahello来查看。与上一章的分析基本一致。 5.4hello的虚拟地址空间 使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 使用edb加载hello之后得到如下结果： 图5.4.1 hello程序的虚拟地址从0x400000开始，到0x400ff0结束。 而根据刚刚通过readelf工具查看的ELF格式文件中的节头表可以知道各个段的信息。 比如： 图5.4.2 根据.rodata的地址为0x400640可以查看其内容： 图5.4.3 5.5链接的重定位过程分析 objdump-d-rhello分析hello与hello.o的不同，说明链接的过程。 结合hello.o的重定位项目，分析hello中对其怎么重定位的。 不同之处： hello的反汇编中显示已经被重定位了，虚拟地址以已经给出，而hello.o的反汇编中的地址为相对地址，未完成重定位。 图5.5.1hello的反汇编 图5.5.2hello.o的反汇编 hello的反汇编中增加了一些函数，这些函数都在main中或者函数初始化时用到了。例如： 图5.5.3hello的反汇编 重定位的过程： (1)所有类型相同的节被连接器合并在一起后，此节就作为可执行目标文件的对应的节。之后链接器把运行时的内存地址赋给新的合成的一个“大的”节、赋给输入模块定义的每个节以及输入模块定义的每个符号，至此，程序中每条指令和全局变量都有唯一运行时的地址。 (2)在重定位节中的符号引用这一步中，连接器修改代码节和数据节中对每个符号的引用，使他们指向正确的运行时地址。链接器通过可重定位目标文件中的重定位条目的数据结构来对符号进行重定位。 (3)而重定位条目是当编译器遇到对最终位置未知的目标引用时，生成的一个数据结构。代码的重定位条目放在.rel.txt，如下： 图5.5.4.rel.txt 而其中，这些表头符号含义如下： Offset偏移量Type修改方式Name需要修改的名称Addend偏移调整 重定位算法如下： 图5.5.5重定位算法 以对hello.o中的puts分析为例： 图5.5.6 Refptr=s+r.offset=0x4004b0+1d=0x4004dd 因为r.type==R_x86_64_PLT32,则进入第一个if语句 *refptr=0x4004b0+(-0x4)-(0x40054e+1)=-0xa2=-163=ffffff5d 小端表示为5dffffff结果正确。 5.6hello的执行流程 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 如下： 即为 即为 图5.6 5.7Hello的动态链接分析 分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。 动态链接：要解决空间浪费和更新困难这两个问题最简单的办法就是把程序的模块相互划分开来，形成独立的文件，而不再将他们静态的链接在一起。简单地讲，就是不对那些组成程序的目标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到了运行时再进行，这就是动态链接(DynamicLinking)的基本思想。 在调用共享库函数时，编译器为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。GNU编译系统使用延迟绑定,将过程地址的绑定推迟到第一次调用该过程时。 延迟绑定是通过GOT和PLT实现的。GOT是数据段的一部分，而PLT是代码段的一部分。两表内容分别为： PLT：PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。 GOT：GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[O]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在1d-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。 而由hello的ELF文件可知 图5.7.1hello的ELF文件 .got段起始地址为0x600ff0， .got.plt段起始地址为0x601000,进入edb调试 在未执行dl_init之前，.got段内容为： 图5.7.2.got段 在未执行dl_init之前，.got.plt段内容为： 图5.7.3.got.plt段 发现在0x600ff0之后16字节全为0，0x601008之后的16个字节全为0 执行dl_init之后，.got段内容为： 图5.7.4.got段 执行dl_init之后，.got.plt段内容为： 图5.7.5.got.plt段 发现0x600ff0之后的8个字节发生了变化，变为：0x7f9fe61d4ab0,而0x601008之后的16个字节也发生了变化，0x601008后8个字节变为：0x7f9fe67cd170,0x601010后8个字节变为:7f9fe65bb680，说明hello已经被动态链接。 5.8本章小结 通过对本章的完成，我了解了链接的概念与作用，以及了解了可执行文件hello的格式以及ELF内容，hello的虚拟地址分析，执行流程，动态链接过程分析等等，让我更加对链接有了深入的认识。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：进程是正在运行的程序的实例。 作用：可以让程序实例有两个假象：1.一个运行的程序实例好像独占了整个cpu。2。一个运行的程序实例好像独占了整个内存。进程使得一个物理设备可以并发地执行多个程序实例。 6.2简述壳Shell-bash的作用与处理流程 作用：Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。BASH：是GNU的BourneAgainShell，是GNU操作系统上默认的shell。 处理流程：shell在内存中长时间运行。根据以下程序得知其内部程序： 图6.2 因此shell重复以下过程： (1)终端进程读取用户由键盘输入的命令行。 (2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量 (3)检查第一个命令行参数是否是一个内置的shell命令 (4)如果不是内部命令，调用fork()创建子进程 (5)在子进程中，用步骤2获取的参数，调用execve()执行指定程序 (6)shell使用waitpid等待前台作业终止回收，使用机制信号来回收后台作业 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的、处于运行状态的子进程。 使用函数intfork(void) 子进程返回0，父进程返回子进程的PID 新创建的子进程几乎但不完全与父进程相同： 1.子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本 2.子进程获得与父进程任何打开文件描述符相同的副本 3.子进程有不同于父进程的PID fork函数：被调用一次，却返回两次（分别是父子进程） 6.4Hello的execve过程 使用intexecve(char*filename,char*argv[],char*envp[])函数，在当前进程中载入并运行程序 filename:可执行文件：目标文件或脚本(用#!指明解释器,如#!/bin/bash) argv：参数列表,惯例：argv[0]==filename envp：环境变量列表：如"name=value"strings(e.g.,USER=droh)，getenv,putenv,printenv 覆盖当前进程的代码、数据、栈，保留有相同的PID，继承已打开的文件描述符和信号上下文 调用一次并从不返回，除非有错误，例如：指定的文件不存在 图6.4新程序启动后的栈结构 6.5Hello的进程执行 结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。 以hello中的这个循环为例： 图6.5.1 printf为用户进程中的一部分，而sleep为系统内核进程的一部分，因此此处有上下文切换过程，如下： 图6.5.2上下文切换 6.6hello的异常与信号处理 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。 正常结果： 图6.6.1正常结果 不停乱按： 图6.6.2不停乱按结果 图6.6.3 不停乱按时，乱按输入的字符被缓存到stdin（标准输入），hello中运行到getchar的时读一个“\n”结尾的字串，该字符串会当做shell命令行输入（且为最后一次以\n结尾的字符串）。图中输入了ksafdjbl.\n与fasjnddas.na\n，运行hello程序结束之后屏幕输出了fasjnddas.na作为命令行。 Ctrl-Z： 图6.6.4按下Ctrl_Z Ctrl_Z为挂起前台作业，由图可知该进程被挂起（stopped），但是被挂起的hello进程没有被回收，它的jid为1，在后续输入fg之后，该hello又被唤醒，命令行先输出./hello1190202328江经这个进程名称，再继续接着刚刚中断的位置执行，后续输出与原来一致，也需要等待输入一个字符才能结束该进程。 在按下Ctrl_Z之后继续按下如下命令： ps： 图6.6.5按下ps 显示当前所有进程（图中因为我运行了两个hello程序,按下了两次ctrl_z，因此有两个作业都被挂起，因此有两个hello） jobs： 图6.6.6按下jobs 显示当前所有作业及其状态（图中因为我运行了两个hello程序,按下了两次ctrl_z，因此有两个作业都被挂起） pstree： 图6.6.7按下pstree 显示进程树，由于太多，因此只截图部分示意 fg： 图6.6.8按下fg 将后台的进程调入前台运行，图中我将作业号为1的作业调入前台运行，即刚刚被挂起的hello进程，因此该进程继续输出8个hello1190202328江经后等待一个字符输入，之后结束进程，然后被回收。 kill： 图6.6.9按下kill 发送信号给某个进程或者进程组。图中我发送9号信号（杀死进程）给2582号进程（即为hello的一个进程），因此显示1号任务（对应进程号2582）被杀死（killed）。 Ctrl-C： 图6.6.10按下Ctrl_C Ctrl_C为终止前台作业，由图可知该进程杀死，而输入ps之后观察，进程中已经没有hello（pid=2755）了，hello进程接收到ctrl_c之后就被终止，且被回收。 6.7本章小结 通过对本章的学习，我学会了进程的相关概念，比如：如何通过fork来创建进程，如何通过wait等一系列函数来回收进程，如何通过execve来加载覆盖一个进程。以及信号的一些概念，如信号的发送，阻塞，接收等。对Linux的上下文切换等机制有了更深的了解。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。 逻辑地址：在有地址变换功能的计算机中，访内指令给出的地址(操作数)叫逻辑地址，也叫相对地址。例如hello的反汇编代码中的指令地址。 线性地址：逻辑地址到物理地址变换之间的中间层。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址就直接成为物理地址了。 虚拟地址：即为线性地址。 物理地址：指出现CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 图7.2 步骤如上图。首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]， 1、看段选择符的T1=0还是1，知道当前要转换是（全局段描述符）GDT中的段，还是局部段描述符（LDT）中的段，再根据相应寄存器（GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中），得到其地址和大小。于是就得到了一个数组了。 2、拿出段选择符中前13位即图中的index，可以在这个数组中，查找到对应的段描述符，这样基地址Base就知道了。 3、Base+offset即为被转换的线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 图7.3.1符号表 首先将线性地址分为VPN+VPO的形式，再去页表中寻找PPN，如果页表中没有，则发生缺页，进入缺页异常处理程序，选择一个牺牲页，换入该页，再重新运行访问页面的指令。在查找到对应的PPN之后，将其与VPO组合变为PPN+VPO，即为物理地址。如下图： 图7.3.2翻译示图 7.4TLB与四级页表支持下的VA到PA的变换 如果有TLB，则首先将线性地址分为VPN+VPO的形式，再将VPN分为TLBT+TLBI的形式，根据这标记和索引去TLB中寻找，如果命中，则直接取出其中存放的PPN；如果不命中，则去页表中寻找，此时将VPN分解为VPN1+VPN2+VPN3+VPN4，一级一级地查找，如果到对应的PPN，则取出PPN；如果找不到，则产生异常，进入缺页异常处理程序，选择一个牺牲页，将其替换，再重新执行刚刚的指令，得到PPN。 在查找到对应的PPN之后，将其与VPO组合变为PPN+VPO，即为物理地址。 图7.4i7地址翻译实例 7.5三级Cache支持下的物理内存访问 如上图,在得到物理地址之后，将物理地址拆分为三部分：CT（标记）+CI（组索引）+CO（块偏移），首先在L1cache中寻找，如果未命中，则继续在L2中寻找，如果还未命中，则继续在L3中寻找，如果L3未命中，则去内存中寻找，直到找到，返回结果。 7.6hello进程fork时的内存映射 mm_struct（内存描述符）：描述了一个进程的整个虚拟内存空间 vm_area_struct（区域结构描述符）：描述了进程的虚拟内存空间的一个区间 用fork创建虚拟内存时： 1.fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID 2.创建当前进程的mm_struct,vm_area_struct和页表的原样副本 3.两个进程的每个页面都标记为只读页面 4.两个进程的每个vm_area_struct都标记为私有，这样就只能在写入时复制。 以此保证在fork之后，父子进程的内存映射几乎完全相同。 7.7hello进程execve时的内存映射 函数原型：intexecve(char*filename,char*argv[],char*envp[]) 在当前进程中载入并运行程序，在此例中为shell进程首先fork一个子进程，再在子进程中调用execve函数加载hello进程。 filename:可执行文件，本例中应该为hello argv：参数列表,惯例：argv[0]==filename（hello） envp：环境变量列表 调用execve函数之后覆盖当前进程的代码、数据、栈 保留有相同的PID，继承已打开的文件描述符和信号上下文 如下图： 图7.7execve函数执行后栈 加载hello的具体过程如下： 1.删除已存在的用户区域，删除当前进程（shell调用fork创建的子进程）虚拟地址的用户部分中的已存在的区域结构。 2.映射私有区域，为新程序的代码、数据、.bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，.bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 3.映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC），设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 1.段错误：首先，先判断缺页的虚拟地址是否合法。遍历所有的合法区域结构，如果这个虚拟地址对所有的区域结构都无法匹配，那么就返回一个段错误（segmentfault） 2.非法访问：接着，查看这个地址的权限，判断一下进程是否有读写改这个地址的权限。如下图： 3.如果不是以上两种情况则为正常缺页，通过查询页表PTE可以知道虚拟页所在在磁盘的位置。缺页处理程序从指定的位置加载页面到物理内存中，并更新PTE。然后控制返回给引起缺页故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中，因此指令可以没有故障地运行完成。具体流程如图步骤(1)(2)(3)(4)所示： 图7.8.1段错误示例 图7.8.2缺页处理流程 7.9动态存储分配管理 Printf会调用malloc，请简述动态内存管理的基本方法与策略。 在程序运行时程序员使用动态内存分配器(比如malloc)获得虚拟内存。(数据结构的大小只有运行时才知道。)动态内存分配器维护着一个进程的虚拟内存区域，称为堆。层次关系如图7.9.1。内存镜像如图7.9.2。 图7.9.1层次关系 图7.9.2内存镜像 分配器将堆视为一组不同大小的块(blocks)的集合来维护，每个块要么是已分配的，要么是空闲的。 分配器的类型： 1.显式分配器: 要求应用显式地释放任何已分配的快 例如，C语言中的malloc和free 2.隐式分配器:应用检测到已分配块不再被程序所使用，就释放这个块 比如Java，ML和Lisp等高级语言中的垃圾收集(garbagecollection) 动态内存管理的基本方法与策略： 方法1:隐式空闲链表(Implicitlist)：通过头部中的大小字段 隐含地连接所有块。如图7.9.3 图7.9.3隐式空闲链表 如果块是对齐的，那么一些低阶地址位总是0，因此不要存储这些0位，而是使用它作为一个已分配/未分配的标志。但是读大小字段时，必须将其屏蔽掉。其内部结构如图7.9.4： 图7.9.4块结构 其搜索策略如下： 1.首次适配(Firstfit):从头开始搜索空闲链表，选择第一个合适的空闲块。 为总块数(包括已分配和空闲块)的线性时间，但是在靠近链表起始处留下小空闲块的“碎片”。 2.下一次适配(Nextfit):和首次适配相似，只是从链表中上一次查询结束的地方开始。 比首次适应更快，因为避免重复扫描那些无用块。一些研究表明，下一次适配的内存利用率要比首次适配低得多。 最佳适配(Bestfit):查询链表，选择一个最好的空闲块。 剩余最少空闲空间，保证了碎片最小 提高内存利用率，但是通常运行速度会慢于首次适配。 还可以利用边界标记(Boundarytags)[Knuth73]来实现双向查找，方便合并空闲块。即：在空闲块的“底部”标记“大小/已分配”，这允许我们反查“链表”，但这需要额外的空间。如图7.9.5： 图7.9.5块结构 合并策略： 立即合并(Immediatecoalescing):每次释放都合并 延迟合并(Deferredcoalescing):尝试通过延迟合并，即直到需要才合并来提高释放的性能。例如:1.为malloc扫描空闲链表时可以合并2.外部碎片达到阈值时可以合并。 方法2:显式空闲链表(Explicitlist)：在空闲块中使用指针。如图7.9.6 图7.9.6显式空闲链表 其每块内部结构如图7.9.7 图7.9.7块结构 显式空闲链表维护空闲块链表,而不是所有块， “下一个”空闲块可以在任何地方，因此需要存储前/后指针，而不仅仅是大小（size），还需要边界标记，用于块合并，但是，只需跟踪空闲块，因此可以使用有效载荷区域。 插入原则: 1.LIFO(last-in-first-out)策略：后进先出法，将新释放的块放置在链表的开始处 优点:简单，常数时间 缺点:研究表明碎片比地址顺序法更糟糕 2.地址顺序法(Address-orderedpolicy)，按照地址顺序维护链表:addr(前一个块)<addr(当前回收块)<addr(下一个块) 优点:研究表明碎片要少于LIFO(后进先出法) 缺点:需要搜索 方法3:分离的空闲列表(Segregatedfreelist)：按照大小分类，构成不同大小的空闲链表，如图7.9.8： 图7.9.8分离的空闲列表 每个尺寸类(sizeclass)中的块，构成一个空闲链表，通常每个小的尺寸/size，都是一个单独的类，对于大的尺寸/size:按照2的幂分类。 分离适配策略如下： 申请块： 分配器维护一个空闲链表数组，每个空闲链表和一个大小类关联，链表是显式或隐式的。 当分配器需要一个大小为n的块时:搜索相应的空闲链表，其大小要满足m>n。1.如果找到了合适的块:拆分块，并将剩余部分插入到适当的可选列表中；如果找不到合适的块,就搜索下一个更大的大小类的空闲链表，直到找到为止。 如果空闲链表中没有合适的块:向操作系统请求额外的堆内存(使用sbrk())，从这个新的堆内存中分配出n字节，将剩余部分放置在适当的大小类中。 释放块： 合并，并将结果放置到相应的空闲链表中。 分离适配的优势 方法4:块按大小排序：在每个空闲块中使用一个带指针的平衡树，并使用长度作为权值。 7.10本章小结 通过堆本章的学习，我深入理解了虚拟内存的概念，以及如何将虚拟地址转换为物理地址，再利用物理地址来通过cache寻找内存的相应内容；我还深入理解了执行了fork、execve之后的内存映射；还深入理解了动态内存管理的基本方法与策略。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件 设备管理：unixio接口 一个Linux文件就是一个m字节的序列:§B0,B1, ,Bk, ,Bm-1¢所有的I/O设备都被模型化为文件: 例如： /dev/sda2（用户磁盘分区）/dev/tty2（终端）甚至内核也被映射为文件:§/boot/vmlinuz-3.13.0-55-generic（内核映像）/proc（内核数据结构） 这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O: 8.2简述UnixIO接口及其函数 打开和关闭文件：open()andclose() 读写文件：read()andwrite() 改变当前的文件位置：seek() 指示文件要读写位置的偏移量：lseek() 8.3printf的实现分析 研究printf的实现，首先来看看printf函数的函数体： 图8.3.1printf函数的函数体 在形参列表里有这么一个token： ，这个是可变形参的一种写法。当传递参数的个数不确定时，就可以用这种方式来表示。很显然，我们需要一种方法，来让函数体可以知道具体调用时参数的个数。 先来看printf函数的内容： va_listarg=(va_list)((char*)(&fmt)+4); va_list的定义：typedefchar*va_list 这说明它是一个字符指针。其中的：(char*)(&fmt)+4)表示的是 中的第一个参数。 下面我们来看看下一句： i=vsprintf(buf,fmt,arg); 让我们来看看vsprintf(buf,fmt,arg)是什么函数。 图8.3.2vsprintf(buf,fmt,arg)函数 vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 write系统函数： 图8.3.3write系统函数 INT_VECTOR_SYS_CALL的实现： init_idt_desc(INT_VECTOR_SYS_CALL,DA_386IGate,sys_call,PRIVILEGE_USER); INT_VECTOR_SYS_CALL表示要通过系统来调用sys_call这个函数。 sys_call的实现： 图8.3.4sys_call的实现 其作用可以理解为：显示格式化了的字符串。 因此得知printf函数执行如下： 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar函数源代码如下： 图8.4getchar函数 异步异常-键盘中断的处理：当用户按键时，键盘接口会得到一个代表该按键的键盘扫描码，同时产生一个中断请求，中断请求抢占当前进程运行键盘中断子程序，键盘中断子程序先从键盘接口取得该按键的扫描码，然后将该按键扫描码转换成ASCII码，保存到系统的键盘缓冲区之中。 getchar函数落实到底层调用了系统函数read，通过系统调用read读取存储在键盘缓冲区中的ASCII码直到读到回车符然后返回整个字串。 8.5本章小结 通过对本章的学习，我了解了Linux的IO设备管理方法以及UnixIO接口及其函数；以及深入理解了printf的实现以及getchar的实现。 （第8章1分） 结论 用计算机系统的语言，逐条总结hello所经历的过程。 写代码：hello.c中编写程序预处理：hello.c经过cpp的预处理变为hello.i编译：hello.i经过ccl的编译变为hello.s汇编：hello.s经过as的汇编变为hello.o链接：hello.o经过ld的链接变为可执行程序hello。运行：在shell终端输入命令行运行hello程序创建子进程：在shell中，输入执行hello的指令之后，shell调用fork函数创建一个子进程加载hello程序：shell在子进程中调execve函数，将hello加载到这个子进程中，覆盖掉原子进程，即hello变为了一个进程。上下文切换：操作系统为该进程划分时间片，hello程序执行时间达到该时间片之后，内核进行上下文切换到其他进程执行。或者，当hello程序执行到sleep函数，内核进行上下文切换，进程切换到处理休眠的进程，当sleep函数调用完成时，内核进行上下文切换将控制再次传递给hello进程。执行中取指令：Hello的执行中，不断从内存中取指令，此时用到了MMU将虚拟内存转换为物理内存，再利用了快表、4级页表、3级cache等来进行加速从内存中取出数据。动态内存申请：当hello程序执行printf函数时，printf会调用malloc向动态内存分配器申请堆中的内存。信号处理：在Hello的执行中，还可能接收并处理来自键盘等IO设备的信号，还可能产生缺页等异常，还会经过上下文切换进入异常处理程序。执行完毕：在hello执行完毕之后，由其父进程shell来对其进行回收，从此hello进程不复存在。 你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。 计算机系统的设计与实现的深切感悟：计算机系统的设计最核心的部分就是软硬件的交界面，在这个界面中，既要将硬件抽象为一个个的接口，还要通过软件的设计来运用好这些接口，从而方便更高层应用的使用。而计算机设计的最主要目的是：快！为了加快计算机速度，在计算机内部采用了cache，TLB等一系列结构，充分利用时间空间局部性来加快计算机速度。 创新理念：可以尝试增加cache层级来加快速度，需要实验验证。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明其作用。 文件名作用hello.chello程序的源代码（文本文件）hello.ihello.c预处理处理得到的文件（文本文件）hello.shello.i编译后得到的汇编代码（文本文件）hello.ohello.s汇编后得到的可重定位目标文件（二进制文件）helloHello.o与其他文件链接后得到的可执行文件（二进制文件） （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 RandalE.Bryant and DavidR.O'Hallaron.ComputerSystems:AProgrammer'sPerspective,3/E(CS:APP3e). CarnegieMellonUniversity,2015. https://www.csdn.net https://baike.baidu.com https://www.cnblogs.com/pianist/p/3315801.html （参考文献0分，缺失-1分） 

CSAPP大作业 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算机科学与技术 学 号 1190202402 班 级 1936602 学 生 李培意 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 从hello这一文件看到一个程序背后的故事。围绕我们每个程序员最先写下的能正常运行的程序hello，透过其整个生命的流程，分析出其背后的种种过程以及各种系统中的管理，来反馈出计算机系统这一复杂系统的理解。也了解硬件，操作系统，程序之间的配合关系。也让hello从编程软件中脱离出来，经历预处理、编译、汇编、再到链接。成为一个系统可运行的程序。也从系统的进程管理，存储管理，IO的管理角度进行分析。以及最后被系统回收。从hello的一生，来看计算机系统的运行。 关键词：hello的一生；计算机系统；存储管理；进程管理；预处理、编译、汇编、链接； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。 P2P：FromProgramtoprocess: Hello刚开始只是一段C语言代码，存于内存当中，也就是最初的hello.c程序，也就是最初的program。编译器驱动程序。然后编译器驱动程序在需要时候调用预处理器、编译器、汇编器和链接器。首先是预处理器（cpp）将C语言源程序hello.c预处理为一个中间文件；编译器（ccl）将该中间文件翻译为一个汇编语言文件；汇编器（as）将汇编语言文件翻译为可重定位目标文件；最后链接器（ld）创建一个可执行目标文件。可以通过shell创建一个子进程运行该可执行目标文件。 020：FromZero-0toZero-0 运行可执行目标文件，调用程序wxecve,一次进行对于虚拟内存的映射，物理内存载入，进入主程序运行代码，调用系统函数 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows764位以上；VirtualBox/Vmware11以上；Ubuntu16.04LTS64位/优麒麟64位 开发与调试工具：gcc，vim，edb，readelf，HexEdit 1.3中间结果 hello.c (C语言源程序) hello.i (hello.c预处理之后的中间文件) hello.s (hello.i编译成汇编语言之后的汇编语言文件) hello.o (hello.s生成的二进制文件，也就是可重定位目标文件) hello (可执行目标文件) 。 1.4本章小结 介绍了Hello的基本信息，介绍了实验的基本环境工具，以及可能生成的实验的中间结果。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 （以下格式自行编排，编辑时删除） 预处理的概念：预处理器根据字符#开头的命令，修改原始程序，将引用的库合并成完整文件。 C语言的预处理主要有三个方面的内容： 1.宏定义（#define）； 2.文件包含（#include）； 3.条件编译（#ifdef/#ifndef/#if/#else/#elseif/#endif）； C预处理器是C语言、C++语言的预处理器。用于在编译器处理程序之前预扫描源代码，完成头文件的包含, 宏扩展, 条件编译, 行控制（linecontrol）等操作。 这样做的目的是使得编译器在对程序进行翻译的时候更加方便。 2.2在Ubuntu下预处理的命令 预处理命令：gcc-Ehello.c-ohello.i 应截图，展示预处理过程！ 2.3Hello的预处理结果解析 原本只有几行的源代码扩展到了3000多行并且在在原有的代码基础上加入了系统库中包含的typedef，结构体，以及外部引用符号。另外还添加了以#开头的语句，这些都是用来辅助表示代码是源自哪个文件以及行号的。 typedef 结构体，#语句 2.4本章小结 本章介绍了C预处理的概念和作用。展示了用linux虚拟机进行预处理的过程以及结果，还有对该结果的分析 （以下格式自行编排，编辑时删除） （第2章0.5分） 第3章编译 3.1编译的概念与作用 将某种高级程序设计语言翻译为低一级的汇编语言并生成汇编语言文件 是高级语言和机器语言之间的媒介，方便程序进一步转换为机器可读的语言。 注意：这儿的编译是指从.i到.s即预处理后的文件到生成汇编语言程序 3.2在Ubuntu下编译的命令 编译命令：gcc-Shello.i-ohello.s 应截图，展示编译过程！ 3.3Hello的编译结果解析 编译结果： .file"hello.c" .text .globl sleepsecs .data .align4 .type sleepsecs,@object .size sleepsecs,4 sleepsecs: .long 2 .section.rodata .align8 .LC0: .string "Usage:Hello1190202402\346\235\216\345\237\271\346\204\217\357\274\201" .LC1: .string "Hello%s%s\n" .text .globl main .type main,@function main: .LFB6: .cfi_startproc endbr64 pushq %rbp .cfi_def_cfa_offset16 .cfi_offset6,-16 movq %rsp,%rbp .cfi_def_cfa_register6 subq $32,%rsp movl %edi,-20(%rbp) movq %rsi,-32(%rbp) cmpl $3,-20(%rbp) je .L2 leaq.LC0(%rip),%rdi callputs@PLT movl $1,%edi callexit@PLT .L2: movl $0,-4(%rbp) jmp.L3 .L4: movq -32(%rbp),%rax addq $16,%rax movq (%rax),%rdx movq -32(%rbp),%rax addq $8,%rax movq (%rax),%rax movq %rax,%rsi leaq.LC1(%rip),%rdi movl $0,%eax callprintf@PLT movl sleepsecs(%rip),%eax movl %eax,%edi callsleep@PLT addl$1,-4(%rbp) .L3: cmpl $9,-4(%rbp) jle .L4 callgetchar@PLT movl $0,%eax leave .cfi_def_cfa7,8 ret .cfi_endproc .LFE6: .size main,.-main .ident "GCC:(Ubuntu10.3.0-1ubuntu1~20.10)10.3.0" .section.note.GNU-stack,"",@progbits .section.note.gnu.property,"a" .align8 .long 1f-0f .long 4f-1f .long 5 0: .string "GNU" 1: .align8 .long 0xc0000002 .long 3f-2f 2: .long 0x3 3: .align8 4: 全局变量：全局变量在data节中定义它，并且解释了它。 .globl sleepsecs 局部变量：局部变量会在栈中储存它，给他分配一个大小符合的字节大小。 argc/argv调用main函数里传入的参数，存放在%rdi中 主函数： main: .LFB6: .cfi_startproc endbr64 pushq %rbp .cfi_def_cfa_offset16 .cfi_offset6,-16 movq %rsp,%rbp .cfi_def_cfa_register6 subq $32,%rsp movl %edi,-20(%rbp) movq %rsi,-32(%rbp) cmpl $3,-20(%rbp) je .L2 leaq.LC0(%rip),%rdi callputs@PLT movl $1,%edi callexit@PLT 其余略， rdi和rsi均为从堆栈中调用数据 i局部变量，在循环中出现，作为每次循环更新的变量保存在%ebx中 赋值 .long 2（全局变量赋值） movl $0,-4(%rbp)（局部变量赋值） 4．类型转换 .type sleepsecs,@object .size sleepsecs,4 sleepsecs: .long 2 movl sleepsecs(%rip),%eax movl %eax,%edi 算数操作 addl$1,-4(%rbp)(对应i++) addq$16,%rax addq$8,%rax subq$32,%rsp 关系操作 cmpl $9,-4(%rbp)（循环中的＜操作 cmpl $3,-20(%rbp)（if语句） 控制转移 je .L2根据条件进行跳转 jmp.L3 ret返回 函数操作 callputs@PLT callexit@PLT callsleep@PLT callgetchar@PLT 头部 .file: 说明文件名字为从hello.c编译而来 .text 代码段 .globl 全局变量：说明sleepsecs是全局变量 .data 数据段 .align 对齐方式，.align4说明是按四个字节对齐 .type sleepsec，说明这个变量是对象类型 .size 大小，说明这个变量占用的大小为4字节 .long 说明sleepsec的类型是long .section说明sleepsecs的节在于只读数据段 注意main为全局符号在.text段中 3.4本章小结 介绍了编译的概念及其作用，利用汇编文件解析了汇编文件中各部分的作用，并与源程序对比，看汇编文件有哪些方面不同，从汇编文件中看源程序。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 通过汇编器，将汇编语言翻译成机器语言，并生成机器语言的二进制程序 转化为了机器能够理解的二进制文本，方便程序的执行。 4.2在Ubuntu下汇编的命令 汇编命令：ashello.s-ohello.o 应截图，展示汇编过程！ 4.3可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。 由图可知，ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或共享的）、机器类型（如x86-64）、节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的头目（entry）。 节头部表，描述了每个节的名字，种类，地址偏移，大小，全体大小，flag，链接，信息，对齐。 但没有这些头： 重定位节：有静态链接内容pc也有动态链接内容plt，也存在一个异常处理单元 符号表 4.4Hello.o的结果解析 hello.o： 文件格式elf64-x86-64 Disassemblyofsection.text: 0000000000000000<main>: 0: f30f1efa endbr64 4: 55 push %rbp 5: 4889e5 mov %rsp,%rbp 8: 4883ec20 sub $0x20,%rsp c: 897dec mov %edi,-0x14(%rbp) f: 488975e0 mov %rsi,-0x20(%rbp) 13: 837dec03 cmpl $0x3,-0x14(%rbp) 17: 7416 je 2f<main+0x2f> 19: 488d3d00000000 lea 0x0(%rip),%rdi #20<main+0x20> 1c:R_X86_64_PC32.rodata-0x4 20: e800000000 callq 25<main+0x25> 21:R_X86_64_PLT32 puts-0x4 25: bf01000000 mov $0x1,%edi 2a: e800000000 callq 2f<main+0x2f> 2b:R_X86_64_PLT32 exit-0x4 2f: c745fc00000000movl $0x0,-0x4(%rbp) 36: eb3b jmp 73<main+0x73> 38: 488b45e0 mov -0x20(%rbp),%rax 3c: 4883c010 add $0x10,%rax 40: 488b10 mov (%rax),%rdx 43: 488b45e0 mov -0x20(%rbp),%rax 47: 4883c008 add $0x8,%rax 4b: 488b00 mov (%rax),%rax 4e: 4889c6 mov %rax,%rsi 51: 488d3d00000000 lea 0x0(%rip),%rdi #58<main+0x58> 54:R_X86_64_PC32.rodata+0x21 58: b800000000 mov $0x0,%eax 5d: e800000000 callq 62<main+0x62> 5e:R_X86_64_PLT32 printf-0x4 62: 8b0500000000 mov 0x0(%rip),%eax #68<main+0x68> 64:R_X86_64_PC32sleepsecs-0x4 68: 89c7 mov %eax,%edi 6a: e800000000 callq 6f<main+0x6f> 6b:R_X86_64_PLT32 sleep-0x4 6f: 8345fc01 addl $0x1,-0x4(%rbp) 73: 837dfc09 cmpl $0x9,-0x4(%rbp) 77: 7ebf jle 38<main+0x38> 79: e800000000 callq 7e<main+0x7e> 7a:R_X86_64_PLT32 getchar-0x4 7e: b800000000 mov $0x0,%eax 83: c9 leaveq 84: c3 retq 十进制数被翻译为了16进制数一些符号信息已经被放入了表中，特别是引用函数中的符号的重定位信息堆栈申请大小不同没有再细分便于理解的各种段地址由相对偏移量转变为了可由cpu直接访问的虚拟地址跳转指令的变化 4.5本章小结 对汇编的概念以及作用的叙述，并且在linux虚拟机中进行了演示，并探究了重定位前和重定位后反汇编的汇编程序的差异。分析了ELF格式文件的组成。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接是将各种代码和数据片段收集并组合成一个单一文件的过程，将一个或多个由编译器或汇编器生成的目标文件外加库，链接为一个可执行文件。这个文件可以被加载到内存并执行。链接可以在编译时实现，也就是在源代码被翻译成机器代码时，也可以在加载时实现，也就是在程序被加载器加载到内存并执行时，甚至可以在运行时实现，也就是由应用程序来执行。 产生一个可以直接被加载到内存并执行的文件。 5.2在Ubuntu下链接的命令 链接命令：gcchello.o-ohello 5.3可执行目标文件hello的格式 5.4hello的虚拟地址空间 前四行为堆栈分配的虚拟空间。 5.5链接的重定位过程分析 （以下格式自行编排，编辑时删除） hello： 文件格式elf64-x86-64 Disassemblyofsection.init: 0000000000001000<_init>: 1000: f30f1efa endbr64 1004: 4883ec08 sub $0x8,%rsp 1008: 488b05d92f0000 mov 0x2fd9(%rip),%rax #3fe8<__gmon_start__> 100f: 4885c0 test %rax,%rax 1012: 7402 je 1016<_init+0x16> 1014: ffd0 callq *%rax 1016: 4883c408 add $0x8,%rsp 101a: c3 retq Disassemblyofsection.plt: 0000000000001020<.plt>: 1020: ff357a2f0000 pushq 0x2f7a(%rip) #3fa0<_GLOBAL_OFFSET_TABLE_+0x8> 1026: f2ff257b2f0000 bndjmpq*0x2f7b(%rip) #3fa8<_GLOBAL_OFFSET_TABLE_+0x10> 102d: 0f1f00 nopl (%rax) 1030: f30f1efa endbr64 1034: 6800000000 pushq $0x0 1039: f2e9e1ffffff bndjmpq1020<.plt> 103f: 90 nop 1040: f30f1efa endbr64 1044: 6801000000 pushq $0x1 1049: f2e9d1ffffff bndjmpq1020<.plt> 104f: 90 nop 1050: f30f1efa endbr64 1054: 6802000000 pushq $0x2 1059: f2e9c1ffffff bndjmpq1020<.plt> 105f: 90 nop 1060: f30f1efa endbr64 1064: 6803000000 pushq $0x3 1069: f2e9b1ffffff bndjmpq1020<.plt> 106f: 90 nop 1070: f30f1efa endbr64 1074: 6804000000 pushq $0x4 1079: f2e9a1ffffff bndjmpq1020<.plt> 107f: 90 nop Disassemblyofsection.plt.got: 0000000000001080<__cxa_finalize@plt>: 1080: f30f1efa endbr64 1084: f2ff256d2f0000 bndjmpq*0x2f6d(%rip) #3ff8<__cxa_finalize@GLIBC_2.2.5> 108b: 0f1f440000 nopl 0x0(%rax,%rax,1) Disassemblyofsection.plt.sec: 0000000000001090<puts@plt>: 1090: f30f1efa endbr64 1094: f2ff25152f0000 bndjmpq*0x2f15(%rip) #3fb0<puts@GLIBC_2.2.5> 109b: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010a0<printf@plt>: 10a0: f30f1efa endbr64 10a4: f2ff250d2f0000 bndjmpq*0x2f0d(%rip) #3fb8<printf@GLIBC_2.2.5> 10ab: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010b0<getchar@plt>: 10b0: f30f1efa endbr64 10b4: f2ff25052f0000 bndjmpq*0x2f05(%rip) #3fc0<getchar@GLIBC_2.2.5> 10bb: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010c0<exit@plt>: 10c0: f30f1efa endbr64 10c4: f2ff25fd2e0000 bndjmpq*0x2efd(%rip) #3fc8<exit@GLIBC_2.2.5> 10cb: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010d0<sleep@plt>: 10d0: f30f1efa endbr64 10d4: f2ff25f52e0000 bndjmpq*0x2ef5(%rip) #3fd0<sleep@GLIBC_2.2.5> 10db: 0f1f440000 nopl 0x0(%rax,%rax,1) Disassemblyofsection.text: 00000000000010e0<_start>: 10e0: f30f1efa endbr64 10e4: 31ed xor %ebp,%ebp 10e6: 4989d1 mov %rdx,%r9 10e9: 5e pop %rsi 10ea: 4889e2 mov %rsp,%rdx 10ed: 4883e4f0 and $0xfffffffffffffff0,%rsp 10f1: 50 push %rax 10f2: 54 push %rsp 10f3: 4c8d05c6010000 lea 0x1c6(%rip),%r8 #12c0<__libc_csu_fini> 10fa: 488d0d4f010000 lea 0x14f(%rip),%rcx #1250<__libc_csu_init> 1101: 488d3dc1000000 lea 0xc1(%rip),%rdi #11c9<main> 1108: ff15d22e0000 callq *0x2ed2(%rip) #3fe0<__libc_start_main@GLIBC_2.2.5> 110e: f4 hlt 110f: 90 nop 0000000000001110<deregister_tm_clones>: 1110: 488d3d012f0000 lea 0x2f01(%rip),%rdi #4018<__TMC_END__> 1117: 488d05fa2e0000lea 0x2efa(%rip),%rax #4018<__TMC_END__> 111e: 4839f8 cmp %rdi,%rax 1121: 7415 je 1138<deregister_tm_clones+0x28> 1123: 488b05ae2e0000 mov 0x2eae(%rip),%rax #3fd8<_ITM_deregisterTMCloneTable> 112a: 4885c0 test %rax,%rax 112d: 7409 je 1138<deregister_tm_clones+0x28> 112f: ffe0 jmpq *%rax 1131: 0f1f8000000000nopl 0x0(%rax) 1138: c3 retq 1139: 0f1f8000000000nopl 0x0(%rax) 0000000000001140<register_tm_clones>: 1140: 488d3dd12e0000 lea 0x2ed1(%rip),%rdi #4018<__TMC_END__> 1147: 488d35ca2e0000 lea 0x2eca(%rip),%rsi #4018<__TMC_END__> 114e: 4829fe sub %rdi,%rsi 1151: 4889f0 mov %rsi,%rax 1154: 48c1ee3f shr $0x3f,%rsi 1158: 48c1f803 sar $0x3,%rax 115c: 4801c6 add %rax,%rsi 115f: 48d1fe sar %rsi 1162: 7414 je 1178<register_tm_clones+0x38> 1164: 488b05852e0000 mov 0x2e85(%rip),%rax #3ff0<_ITM_registerTMCloneTable> 116b: 4885c0 test %rax,%rax 116e: 7408 je 1178<register_tm_clones+0x38> 1170: ffe0 jmpq *%rax 1172: 660f1f440000 nopw 0x0(%rax,%rax,1) 1178: c3 retq 1179: 0f1f8000000000nopl 0x0(%rax) 0000000000001180<__do_global_dtors_aux>: 1180: f30f1efa endbr64 1184: 803d892e000000 cmpb $0x0,0x2e89(%rip) #4014<completed.0> 118b: 752b jne 11b8<__do_global_dtors_aux+0x38> 118d: 55 push %rbp 118e: 48833d622e0000 cmpq $0x0,0x2e62(%rip) #3ff8<__cxa_finalize@GLIBC_2.2.5> 1195: 00 1196: 4889e5 mov %rsp,%rbp 1199: 740c je 11a7<__do_global_dtors_aux+0x27> 119b: 488b3d662e0000 mov 0x2e66(%rip),%rdi #4008<__dso_handle> 11a2: e8d9feffff callq 1080<__cxa_finalize@plt> 11a7: e864ffffff callq 1110<deregister_tm_clones> 11ac: c605612e000001 movb $0x1,0x2e61(%rip) #4014<completed.0> 11b3: 5d pop %rbp 11b4: c3 retq 11b5: 0f1f00 nopl (%rax) 11b8: c3 retq 11b9: 0f1f8000000000nopl 0x0(%rax) 00000000000011c0<frame_dummy>: 11c0: f30f1efa endbr64 11c4: e977ffffff jmpq 1140<register_tm_clones> 00000000000011c9<main>: 11c9: f30f1efa endbr64 11cd: 55 push %rbp 11ce: 4889e5 mov %rsp,%rbp 11d1: 4883ec20 sub $0x20,%rsp 11d5: 897dec mov %edi,-0x14(%rbp) 11d8: 488975e0 mov %rsi,-0x20(%rbp) 11dc: 837dec03 cmpl $0x3,-0x14(%rbp) 11e0: 7416 je 11f8<main+0x2f> 11e2: 488d3d1f0e0000 lea 0xe1f(%rip),%rdi #2008<_IO_stdin_used+0x8> 11e9: e8a2feffff callq 1090<puts@plt> 11ee: bf01000000 mov $0x1,%edi 11f3: e8c8feffff callq 10c0<exit@plt> 11f8: c745fc00000000movl $0x0,-0x4(%rbp) 11ff: eb3b jmp 123c<main+0x73> 1201: 488b45e0 mov -0x20(%rbp),%rax 1205: 4883c010 add $0x10,%rax 1209: 488b10 mov (%rax),%rdx 120c: 488b45e0 mov -0x20(%rbp),%rax 1210: 4883c008 add $0x8,%rax 1214: 488b00 mov (%rax),%rax 1217: 4889c6 mov %rax,%rsi 121a: 488d3d0c0e0000 lea 0xe0c(%rip),%rdi #202d<_IO_stdin_used+0x2d> 1221: b800000000 mov $0x0,%eax 1226: e875feffff callq 10a0<printf@plt> 122b: 8b05df2d0000 mov 0x2ddf(%rip),%eax #4010<sleepsecs> 1231: 89c7 mov %eax,%edi 1233: e898feffff callq 10d0<sleep@plt> 1238: 8345fc01 addl $0x1,-0x4(%rbp) 123c: 837dfc09 cmpl $0x9,-0x4(%rbp) 1240: 7ebf jle 1201<main+0x38> 1242: e869feffff callq 10b0<getchar@plt> 1247: b800000000 mov $0x0,%eax 124c: c9 leaveq 124d: c3 retq 124e: 6690 xchg %ax,%ax 0000000000001250<__libc_csu_init>: 1250: f30f1efa endbr64 1254: 4157 push %r15 1256: 4c8d3d3b2b0000 lea 0x2b3b(%rip),%r15 #3d98<__frame_dummy_init_array_entry> 125d: 4156 push %r14 125f: 4989d6 mov %rdx,%r14 1262: 4155 push %r13 1264: 4989f5 mov %rsi,%r13 1267: 4154 push %r12 1269: 4189fc mov %edi,%r12d 126c: 55 push %rbp 126d: 488d2d2c2b0000 lea 0x2b2c(%rip),%rbp #3da0<__do_global_dtors_aux_fini_array_entry> 1274: 53 push %rbx 1275: 4c29fd sub %r15,%rbp 1278: 4883ec08 sub $0x8,%rsp 127c: e87ffdffff callq 1000<_init> 1281: 48c1fd03 sar $0x3,%rbp 1285: 741f je 12a6<__libc_csu_init+0x56> 1287: 31db xor %ebx,%ebx 1289: 0f1f8000000000nopl 0x0(%rax) 1290: 4c89f2 mov %r14,%rdx 1293: 4c89ee mov %r13,%rsi 1296: 4489e7 mov %r12d,%edi 1299: 41ff14df callq *(%r15,%rbx,8) 129d: 4883c301 add $0x1,%rbx 12a1: 4839dd cmp %rbx,%rbp 12a4: 75ea jne 1290<__libc_csu_init+0x40> 12a6: 4883c408 add $0x8,%rsp 12aa: 5b pop %rbx 12ab: 5d pop %rbp 12ac: 415c pop %r12 12ae: 415d pop %r13 12b0: 415e pop %r14 12b2: 415f pop %r15 12b4: c3 retq 12b5: 66662e0f1f8400data16nopw%cs:0x0(%rax,%rax,1) 12bc: 00000000 00000000000012c0<__libc_csu_fini>: 12c0: f30f1efa endbr64 12c4: c3 retq Disassemblyofsection.fini: 00000000000012c8<_fini>: 12c8: f30f1efa endbr64 12cc: 4883ec08 sub $0x8,%rsp 12d0: 4883c408 add $0x8,%rsp 12d4: c3 retq 汇编代码段增加，增加了.init.plt.plt.sec.fini .text段除了main增加了一些函数，如_start等 增加了外部的共享库函数 0000000000001090<puts@plt>: 1090: f30f1efa endbr64 1094: f2ff25152f0000 bndjmpq*0x2f15(%rip) #3fb0<puts@GLIBC_2.2.5> 109b: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010a0<printf@plt>: 10a0: f30f1efa endbr64 10a4: f2ff250d2f0000 bndjmpq*0x2f0d(%rip) #3fb8<printf@GLIBC_2.2.5> 10ab: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010b0<getchar@plt>: 10b0: f30f1efa endbr64 10b4: f2ff25052f0000 bndjmpq*0x2f05(%rip) #3fc0<getchar@GLIBC_2.2.5> 10bb: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010c0<exit@plt>: 10c0: f30f1efa endbr64 10c4: f2ff25fd2e0000 bndjmpq*0x2efd(%rip) #3fc8<exit@GLIBC_2.2.5> 10cb: 0f1f440000 nopl 0x0(%rax,%rax,1) 00000000000010d0<sleep@plt>: 10d0: f30f1efa endbr64 10d4: f2ff25f52e0000 bndjmpq*0x2ef5(%rip) #3fd0<sleep@GLIBC_2.2.5> 10db: 0f1f440000 nopl 0x0(%rax,%rax,1) 重定位 重定位节和符号：将所有类型相同的节合并在一起后，这个节就作为可执行目标文件的节。然后链接器把运行时的内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号，当这一步完成时，程序中每条指令和全局变量都有唯一运行时的地址。也就是.text段中增加的一些新的函数，这些函数最终合并为同一聚合结。 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行地址。 5.6hello的执行流程 _start0x00000000004010fe _libc_start_main0x00007fffff5d70b3 main0x0000000000401105 printf@plt0x0000000000401090 sleep@plt 0x4010c0 getchar0x7fffff63e6e0 _rtld_global_ro0x7fffff7dd620 5.7Hello的动态链接分析 地址在dl_init后被改写了 进入改写地址后发现进入了一个新的函数，并且实现了GOT的动态链接。PLT使用GOT中的地址跳转到目标函数。 5.8本章小结 介绍了链接器的概念和作用，探讨了程序运行时的虚拟地址空间，分析了可执行文件的ELF，研究了重定位以及动态链接的过程。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 进程的经典定义是一个执行中程序的实例，系统的每个程序都运行在某个进程的上下文。上下文是由程序正确运行所需的状态组成的，这个状态包括存放在内存里的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。 通过进程，我们会得到一种假象，好像我们的程序是当前唯一运行的程序，我们的程序独占处理器和内存，我们程序的代码和数据好像是系统内存中唯一的对象。 6.2简述壳Shell-bash的作用与处理流程 shell俗称壳，它是指UNIX系统下的一个命令解析器；主要用于用户和系统的交互。UNIX系统上有很多种Shell。首个shell，即BourneShell，于1978年在V7(AT&T的第7版)UNIX上推出。后来，又演变出Cshell、bash等不同版本的shell。 Shell接受用户的命令并解释该命令然后将其送入内核执行。 处理流程：：打印一个提示符，等待用户输入命令行，从终端读入输入的命令。将输入的命令行切分得出参数，如果是内置命令则立即执行，否则调用相应的程序为其分配子进程并运行，.shell应该接受键盘输入信号，并对这些信号进行相应处理。并最终回收。 6.3Hello的fork进程创建过程 Shell调用fork函数创建子进程，形成自身的一个拷贝，为运行hello做准备 6.4Hello的execve过程 Shell调用execve函数在当前进程的上下文中加载并运行一个新的程序，即hello程序 6.5Hello的进程执行 逻辑控制流：即为一系列程序计数器PC的值序列进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。 时间片：进程执行它的控制流的部分时间段。 用户模式和内核模式：用户模式即为未设置模式位，不允许执行特权指令直接引用地址空间中内核区内的代码和数据；内核模式为设置模式位时，该进程执行所有命令访问所有数据。 上下文信息：上下文就是内核重启被抢占的进程所需要的状态，它由通用寄存器等各种内核数据构成。分别三个步骤： 保存当前进程的上下文 恢复某个先前被抢占的进程被保存的上下文 将控制传递给这个新恢复的进程。 6.6hello的异常与信号处理 正常运行： 乱按 回车 Ctrl+c Ctrl+z Ps: Jobs: Pstree： Fg： Kill 6.7本章小结 讨论了进程的概念和作用，简单介绍了shell以及其重要功能函数，最后进行了异常信号的处理。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：汇编程序中地址。逻辑地址由选择符和偏移量组成。是经过编译后出现在汇编程序中的地址。 线性地址：逻辑地址经过段机制后转化为线性地址，以描述符：偏移量的组合形式存在。分页机制中线性地址作为输入。 虚拟地址：类似于线性地址 物理地址：真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址 7.2Intel逻辑地址到线性地址的变换-段式管理 最初8086处理器的寄存器是16位的，为了能够访问更多的地址空间但不改变寄存器和指令的位宽，所以引入段寄存器，8086共设计了20位宽的地址总线，通过将段寄存器左移4位加上偏移地址得到20位地址，这个地址就是逻辑地址。将内存分为不同的段，段有段寄存器对应，段寄存器有一个栈、一个代码、两个数据寄存器。 分段功能在实模式和保护模式下有所不同。 实模式，即不设防，也就是说逻辑地址=线性地址=实际的物理地址。段寄存器存放真实段基址，同时给出32位地址偏移量，则可以访问真实物理内存。 在保护模式下，线性地址还需要经过分页机制才能够得到物理地址，线性地址也需要逻辑地址通过段机制来得到。段寄存器无法放下32位段基址，所以它们被称作选择符，用于引用段描述符表中的表项来获得描述符。描述符表中的一个条目描述一个段，构造如下： 7.3Hello的线性地址到物理地址的变换-页式管理 线性地址到物理地址之间的转换通过分页机制完成。而分页机制是对虚拟地址内存空间进行分页。 首先Linux系统有自己的虚拟内存系统，Linux将虚拟内存组织成一些段的集合，段之外的虚拟内存不存在因此不需要记录。内核为hello进程维护一个段的任务结构即图中的task_struct，其中条目mm指向一个mm_struct，它描述了虚拟内存的当前状态，pgd指向第一级页表的基地址（结合一个进程一串页表），mmap指向一个vm_area_struct的链表，一个链表条目对应一个段，所以链表相连指出了hello进程虚拟内存中的所有段。 系统将每个段分割为被称为虚拟页（VP）的大小固定的块来作为进行数据传输的单元，在linux下每个虚拟页大小为4KB，类似地，物理内存也被分割为物理页（PP/页帧），虚拟内存系统中MMU负责地址翻译，MMU使用存放在物理内存中的被称为页表的数据结构将虚拟页到物理页的映射，即虚拟地址到物理地址的映射。 7.4TLB与四级页表支持下的VA到PA的变换 36位的虚拟地址被分割成4个9位的片。CR3寄存器包含L1页表的物理地址。VPN1有一个到L1PTE的偏移量，找到这个PTE以后又会包含到L2页表的基础地址；VPN2包含一个到L2PTE的偏移量，找到这个PTE以后又会包含到L3页表的基础地址；VPN3包含一个到L3PTE的偏移量，找到这个PTE以后又会包含到L4页表的基础地址；VPN4包含一个到L4PTE的偏移量，找到这个PTE以后就是相应的PPN（物理页号）。 7.5三级Cache支持下的物理内存访问 cache：高速缓存，从上图就可以看出高速缓存的高效和高昂，三级cache是为了能在达到效率的前提下降低成本。 获得物理地址VA后，使用CI（后六位再后六位）进行组索引，每组8路，对8路的块分别匹配CT（前40位）如果匹配成功且块的valid标志位为1，则命中（hit），根据数据偏移量CO（后六位）取出数据返回。 如果没有匹配成功或者匹配成功但是标志位是1，则不命中（miss），向下一级缓存中查询数据（L2Cache->L3Cache->主存）。查询到数据之后，一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换 7.6hello进程fork时的内存映射 fork的内存映射是使用特殊文件提供匿名内存映射，而这种内存映射，适用于具有亲缘关系的进程之间；由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。 7.7hello进程execve时的内存映射 exceve函数加载和执行程序hello的步骤为：首先删除已存在的用户区域。然后为hello的代码、数据、bss和栈区域创建新的区域结构，所有这些区域都是私有的、写时复制的。再映射共享区域。比如hello程序与标准C库libc.so链接，这些对象都是动态链接到hello，然后存储在用户虚拟地址空间中的共享区域内。最后设置程序计数器（PC）。 7.8缺页故障与缺页中断处理 DRAM缓存的不命中被称为缺页。DRAM缓存的不命中触发一个缺页故障，缺页故障调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果该牺牲页已经做了更改，那么内核会将它复制回磁盘，否则不会进行复制即写回，然后将牺牲页从DRAM中出去，更新该页的位置放入待取的页面。然后CPU重新执行造成缺页故障的命令此时将可以正常运行。 7.9动态存储分配管理 在程序运行时应使用动态内存分配器给引用程序分配内存，动态内存分配器的维护着一个进程的虚拟内存（堆）。分配器将堆视为一组不同大小的块的集合来进行维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留以供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 分配器分为两种基本风格：显式分配器、隐式分配器。 显式分配器：要求应用显式地释放任何已分配的块。 隐式分配器：要求分配器检测一个已分配块何时不再使用，那么就释放这个块。 7.10本章小结 通过对虚拟内存的介绍了解，学习了TLB和四级页表支持下VA到PA的转换，以及得到了PA后，三级cache下的物理内存的访问过程，掌握了各种函数与虚拟内存的关系。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：所有的IO设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 接口： 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。 2.Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。 3.改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置a，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置a。 4.读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置a开始，然后将a增加到a+n，给定一个大小为m字节的而文件，当a>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置a开始，然后更新a。 5.关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。 函数： open()函数：这个函数回打开一个已经存在的文件或者创建一个新的文件。 close()函数：这个函数关闭一个已经打开的文件。 read()函数：从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，返回值为0表示EOF。否则返回值表示的是实际传送的字节数量。 write()函数：从内存buf位置复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } intvsprintf(char*buf,constchar*fmt,va_listargs) { char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++) { if(*fmt!='%') { *p++=*fmt; continue; } fmt++; switch(*fmt) { case'x': itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case's': break; default: break; } } return(p-buf); } vsprintf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。 在printf中调用系统函数write(buf,i)将长度为i的buf输出 Write: write: mov eax, _NR_write mov ebx, [esp + 4] mov ecx, [esp + 8] int INT_VECTOR_SYS_CALL 在write函数中，将栈中参数放入寄存器，ecx是字符个数，ebx存放第一个字符地址，intINT_VECTOR_SYS_CALLA代表通过系统调用syscall Sys_call: callsave pushdword[p_proc_ready] sti pushecx pushebx call[sys_call_table+eax*4] addesp,4*3 mov[esi+EAXREG-P_STACKBASE],eax cli ret syscall将字符串中的字节“Hello1190202402李培意”从寄存器中通过总线复制到显卡的显存中，显存中存储的是字符的ASCII码。 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 学习了linux中的I/O管理机制，以及其各类的函数的功能等。也对printf和getchar函数有了更多更新的研究。 （第8章1分） 结论 最终跟随着hello程序走完了它的一生，也从它的一生中，了解了计算机系统的种种内容。从开始，到结束，也是我们编写的代码的开始，到可能的将来的结束。但当下，一个hello结束了，我们还要有更多的程序，从编写，到交给系统，再到电脑硬件的执行，最后的结束回收，在这个过程中循环往复。赋能人类的生活。 1.预处理器将hello.c源代码经过初步的修改变成了hello.i文件。 2.编译器处理hello.i文件使之成为汇编代码并保存在hello.s文件中。 3.汇编器将hello.s文件处理成了可重定位的目标程序，也就是hello.o文件，这个时候，我们的程序离可以运行就只差一步了。 4.链接器将我们的hello.o与外部文件进行链接，终于我们得到了可以跑起来的hello文件了。 5.当我们在shell中运行hello程序时，内核会为我们分配好运行程序所需要的堆、用户栈、虚拟内存等一系列信息。使我们的hello程序能够正常的运行。 6.从外部对hello程序进行操控只需要在键盘上给一个相应的信号，hello程序就会按照我们的指令来执行。 7.在hello需要访问磁盘中的信息的时候，MMU会将程序中使用的虚拟内存地址通过页表映射成物理地址。 8.当hello执行结束，shell父进程回收子进程，内核删除为这个进程创建的所有数据结构，hello也就结束了它的一生。 （结论0分，缺失-1分，根据内容酌情加分） 附件 Hello.c C语言源文件 Hello.i 预处理后的文本文件 Hello.o 汇编之后的可重定位目标执行文件 Hello.s 编译后的文本文件 Hello 链接之后的可执行的目标文件 Elf hello.o的ELF Elf2 hello的ELF （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 

CS大作业论文 计算机系统 大作业 题 目 程序人生-Hello’sP2P 专 业 计算学部 学 号 1190202408 班 级 1936601 学 生 闫广泽 指导教师 刘宏伟 计算机科学与技术学院 2021年6月 摘 要 本篇主要通过对hello的一生进行探讨。通过对hello.c文件到进程被回收这个质朴却复杂的计算机系统运行过程进行解释和说明，来对计算机系统的运行加以解释和说明。主要针对程序的编译过程、进程管理、存储管理、IO管理进行研究和探讨。 关键词：P2P；020；程序的生命周期；进程； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目 录 第1章概述 -4- 1.1Hello简介 -4- 1.2环境与工具 -4- 1.3中间结果 -4- 1.4本章小结 -4- 第2章预处理 -5- 2.1预处理的概念与作用 -5- 2.2在Ubuntu下预处理的命令 -5- 2.3Hello的预处理结果解析 -5- 2.4本章小结 -5- 第3章编译 -6- 3.1编译的概念与作用 -6- 3.2在Ubuntu下编译的命令 -6- 3.3Hello的编译结果解析 -6- 3.4本章小结 -6- 第4章汇编 -7- 4.1汇编的概念与作用 -7- 4.2在Ubuntu下汇编的命令 -7- 4.3可重定位目标elf格式 -7- 4.4Hello.o的结果解析 -7- 4.5本章小结 -7- 第5章链接 -8- 5.1链接的概念与作用 -8- 5.2在Ubuntu下链接的命令 -8- 5.3可执行目标文件hello的格式 -8- 5.4hello的虚拟地址空间 -8- 5.5链接的重定位过程分析 -8- 5.6hello的执行流程 -8- 5.7Hello的动态链接分析 -8- 5.8本章小结 -9- 第6章hello进程管理 -10- 6.1进程的概念与作用 -10- 6.2简述壳Shell-bash的作用与处理流程 -10- 6.3Hello的fork进程创建过程 -10- 6.4Hello的execve过程 -10- 6.5Hello的进程执行 -10- 6.6hello的异常与信号处理 -10- 6.7本章小结 -10- 第7章hello的存储管理 -11- 7.1hello的存储器地址空间 -11- 7.2Intel逻辑地址到线性地址的变换-段式管理 -11- 7.3Hello的线性地址到物理地址的变换-页式管理 -11- 7.4TLB与四级页表支持下的VA到PA的变换 -11- 7.5三级Cache支持下的物理内存访问 -11- 7.6hello进程fork时的内存映射 -11- 7.7hello进程execve时的内存映射 -11- 7.8缺页故障与缺页中断处理 -11- 7.9动态存储分配管理 -11- 7.10本章小结 -12- 第8章hello的IO管理 -13- 8.1Linux的IO设备管理方法 -13- 8.2简述UnixIO接口及其函数 -13- 8.3printf的实现分析 -13- 8.4getchar的实现分析 -13- 8.5本章小结 -13- 结论 -14- 附件 -15- 参考文献 -16- 第1章概述 1.1Hello简介 我是一个C语言程序，我每次都会在最后出现在屏幕上，我对我自己有简介： P2P：在Linux中，经过预处理、编译、再链接 P2P：首先从一个写好的源程序程序文件（Program）开始，GCC编译器的驱动程序读取它，依次通过预处理器cpp将其预处理为一个修改了的源程序，通过编译器ccl把它变成汇编程序，汇编器as把它转化为可重定位的目标程序，最后再由链接器ld将其变为可执行的目标程序。这时，在shell中运行它，OS（进程管理）会通过fork来为其创建一个新的进程（Process）。这便是P2P的过程。 020：首先，通过Editor编写出一个源程序hello.c，然后通过GCC编译器的驱动程序读取它，并依次经过预处理，编译，汇编，链接来生成一个可执行文件，然后再shell中输入执行它的指令，shell通过fork为其创建新的子进程，然后通过exceve在进程的上下文中加载并运行hello，把它映射到对应虚拟内存区域，并依需求载入物理内存，在CPU的帮助下，它的指令被一步步执行，实现它拥有的功能，在程序运行结束后，父进程会对其进行回收，内核把它从系统中清除，hello完成了它的一生，这便是020的过程。 1.2环境与工具 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk以上 软件环境：Windows1064位以上；Vmware11以上；Ubuntu16.04LTS64位 开发工具：GDB/OBJDUMP；EDB；gedit+gcc；CodeBlocks64位，gdb等。 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 hello.c源文件 hello.i预处理后的文件 hello.s编译后的汇编文件 hello.o汇编后的可重定位文件 hello链接后的可执行文件 hello.elfhello的elf文件 helloout.elfhello.o的elf文件 hello1.txtobjdumphello的反汇编文件 hello0.txtobjdumphello.o的反汇编文件 1.4本章小结 本章主要介绍了hello的P2P，020过程，以及进行实验时的软硬件环境及开发与调试工具和在本论文中生成的中间结果文件。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 （以下格式自行编排，编辑时删除） 预处理过程是整个编译过程的第一步，预处理输入的文件格式是c文件或者是h文件，经过预处理输出的就是i文件。在预处理过程中，预处理器会分析预处理指令（包括#include头文件和#define宏定义等）以及去除源代码中的注释。通常来说，编译器会直接将c文件编译成o文件，然后再去交给链接器链接为elf文件。如果希望通过命令行仅仅将c文件预处理成为i文件，只要在命令行中加上-E参数，就可以使编译器在预处理后停止下来，输出预处理后的源文件。 2.2在Ubuntu下预处理的命令 例如我们的命令行就是，gcc-Ehello.c-ohello.i，就会生成.i文件 hello.c截图 hello.i截图 2.3Hello的预处理结果解析 可以看到，相比较于hello.c的不到三十行代码，hello.i有3000多行代码，其实就是对源文件中的宏定义进行了展开，增加的代码就是宏定义解析的代码 2.4本章小结 本章节简单介绍了c语言在编译前的预处理过程，简单介绍了预处理过程的概念和作用，对预处理过程进行演示，并举例说明预处理的结果还有解析预处理的过程。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念：编译器ccl将文本文件hello.i翻译成文本文件hello.s。它包含一个汇编语言程序。 作用：编译器做一些语法分析、词法分析、语义分析等，若检查无错误，便将高级程序设计语言（C语言）书写的程序转变为与其等价的汇编语言程序（可能依情况做一些优化），汇编语言是介于高级语言和机器语言之间的中间代码，它为不同高级语言的不同编译器提供了通用的输出语言，使他们产生的输出文件都是用的一样的输出语言。 3.2在Ubuntu下编译的命令 gcc-Shello.i-ohello.s hello.s 3.3Hello的编译结果解析 和刚才动辄3000行代码的.i文件不同，.s文件只有80多行，认真观察hello.s文本，发现他其实只翻译了hello.i中main函数及其周围的部分，头文件里面的内容他并没有翻译。 3.3.1汇编文件伪指令 这部分内容主要声明了源文件的名字（.file），代码段（.text），数据段（.data），全局变量及其大小（.globl，.size），指令及数据存放地址的对齐方式（.align）等文件信息。 3.3.2数据类型 我们可以查看hello.c 发现主要有以下几种类型： 1．常量 字符串型常量，汇编语言中，输出字符串作为全局变量保存。汇编文件hello.s中，共有两个字符串，均作为printf参数，如下图： 2.变量 定义了全局int型变量sleepsecs和局部int型变量i，argc。 其中sleepsecs在开头定义： .c文件中是这样的 .s文件中是 可以看到sleepsecs占用4字节空间并且保存在只读代码段rodata中，并且发生了隐式转换，因为在.c中是定义的sleepsecs是int型全局变量，但是赋值却是浮点型，所以编译器对2.5舍入得2 而i作为局部变量保存在栈中（运行）时，如下（下面为给i赋初值为0） argv也是如此： hello.c中，同时主要定义和使用了argv数组，而在hello.s中，通过以下代码可知 分析可知，argv[1]作为printf第二个参数，应当存于寄存器%rsi中，因此可推断argv[1]地址为-0x2A(%rbp)中，argv[2]作为printf函数的第三个参数，应当存于寄存器%rdx中，因此可推断argv[2]地址为-0x16(%rbp)；数组首地址位于-0x32(%rbp)，以上所占字节数为8。 3.3.3各类操作 1.赋值操作 如在for循环中，初始化局部变量i为0。在hello.s中，可以找到对应的操作，主要使用了数据传送指令，如下图： 在给printf传参数时，使用了加载有效地址指令，如下图： 2.类型转换操作 在前面我们已经介绍，这里不过多赘述 3.关系操作 在hello.c中使用了if语句，其中使用了关系操作，如下图 通过cmpl指令比较了argv与3的大小关系 4.控制转移操作 在hello.c中使用了if语句，那么紧接着就需要转移，当条件不满足时该怎样或者条件满足该怎样，如上，当比较argv和3相等的时候就会跳转到L2 5.算术操作 算术操作对应于hello.c中的i++ hello.s中对应以上操作 6.for循环操作 hello.c中的for循环对应于hello.s中的 使用了条状指令jle和关系操作指令cmpl实现了for循环操作。 7.函数操作。hello.c中调用了许多函数，如printf，exit，getchar，可以通过以下的指令实现，如下图printf的实现，通过过程调用指令call来实现函数操作，同时通过寄存器（如%rdi）来传递参数。 3.4本章小结 编译器将预处理后的文本进行汇编处理，对于常量，编译器将它储存到一个特定的位置，记录它的一些信息，比如类型；对于一些特定的常量，比如printf()函数中的信息，编译器会把它提取出来保存。程序中的语句，例如赋值语句，编译器通过寄存器，栈等结构进行赋值；分支语句用je,jle,jge等条件跳转语句进行实现。每种语句都有对应的实现方法。程序中的函数，如果不是库函数，则会对函数进行逐句的语法分析和解析，如果是标准的库函数，编译器可以直接用call语句进行调用。 汇编语言相对于高级语言来说，它更加靠近底层机器且直接面对硬件的，所以也为高级语言提供了一种统一的面向机器的解释，它具有一些助记符，所以比直接的机器语言好理解，但相对于高级语言又显得难以掌握。汇编语言具有：机器相关性，高速度和高效率，编写和调试的复杂性等特性。 （第3章2分） 第4章汇编 4.1汇编的概念与作用 概念：汇编器as将hello.s翻译成机器语言指令，把这些指令打包成一种叫可重定位目标程序的格式，并将结果保存在目标文件hello.o中。（hello.o是一个二进制文件）。 作用：把汇编语言翻译成机器语言，用二进制码代替汇编语言中的符号，即让它成为机器可以直接识别的程序。 4.2在Ubuntu下汇编的命令 gcc-chello.s-ohello.o 4.3可重定位目标elf格式 使用readelf查看hello.o： 分析.elf文件中的内容： 分析.elf文件中的内容： ELF头：ELF头（ELFheader）以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含了帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是有节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry）。 节头：记录各节名称、类型、地址、偏移量、大小、全体大小、旗标、链接、信息、对齐。 重定位节：.rela.text，保存的是.text节中需要被修正的信息；任何调用外部函数或者引用全局变量的指令都需要被修正；调用外部函数的指令需要重定位；引用全局变量的指令需要重定位；调用局部函数的指令不需要重定位；在可执行目标文件中不存在重定位信息。本程序需要被重定位的是printf、puts、exit、sleepsecs、getchar、sleep和.rodata中的.L0和.L1。 .rela.eh_frame节是.eh_frame节重定位信息。 符号表：.symtab，一个符号表，它存放在程序中定义和引用的函数和全局变量的信息，一些程序员错误地认为必须通过-g选项来编译一个程序，才能得到符号表信息。实际上每个可重定位目标文件在.symtab中都有一张符号表（除非程序员特意用STRIP命令去掉它）。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。 具体内容： 1.ELF头 由图可知，ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 2.重定位节'.rela.text' 节头部表描述了不同节的位置与大小，并且目标文件的每个节都有一个固定大小的条目，其中记录了各节名称、类型、地址、偏移量、大小、全体大小、旗标、连接、信息、对齐信息。 由图可知'.rela.text'是一个.text节中位置的列表，包含.text节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。如图4.4，图中8条重定位信息分别是对.L0（第一个printf中的字符串）、puts函数、exit函数、.L1（第二个printf中的字符串）、printf函数、sleepsecs、sleep函数、getchar函数进行重定位声明。 其中偏移量为需要进行重定向的代码在.text或.data节中的偏移位置，信息包括symbol和type两部分，其中symbol占前4个字节，type占后4个字节，symbol代表重定位到的目标在.symtab中的偏移量，type代表重定位的类型，类型代表重定位到的目标的类型，符号名称和加数则指出了重定向到的目标的名称计算重定位位置的辅助信息。 3.重定位节'.rela.eh_frame' '.rela.eh_frame'包含了eh_frame节的重定位信息。 符号表 .symtab存放着程序中定义和引用函数和全局变量的信息。且不包含局部变量的条目。重定位需要引用的符号都在其中声明。 4.4Hello.o的结果解析 hello.s的内容 hello.o反汇编的内容 比较来看hello.s和hello.o操作数赖看hello.s是十进制，hello.o是十六进制，其中的内容其实大部分是差不太多的，但是左半边hello.o多了很多东西。有前面的机器指令的位置，以及后面的对应每一行汇编语句的机器指令，显然这是给机器读的以为机器是二进制实现的，0和1构成，方便查看所以使用十六进制 4.4.1分支跳转语句 对比来看，不难发现，在hello.s文件中，跳转到的位置都是用.L3/.L4等来进行表示的，但是在hello.o中，跳转目标位置是由确实的地址来表示的。 4.4.2函数调用 hello.s的函数调用是通过使用call+函数名，比如callgetchar@PLT而在hello.o中是call+地址，例如callq7e<main+0x7e>指的是相对于main函数的地址偏移量为7e的函数位置。 4.5本章小结 汇编器对hello.s文件进行汇编，生成了可重定位文件。对文件的全局变量，函数，程序语句都进行了分析，给出了初始的相对位置信息，相当于对整个文件做出了一个初始的整理，为后面的链接等操作做准备。 （第4章1分） 第5章链接 5.1链接的概念与作用 链接的概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器的程序自动执行的。 链接的作用： 链接在软件开发中扮演着一个关键的角色，因为它们使得分离编译成为可能。链接能将各种代码和数据片段收集并组合成为一个单一文件，即链接多个目标文件成一个可执行文件。 在Ubuntu下链接的命令 ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 命令： 5.3可执行目标文件hello的格式 使用readelf来查看hello： ELF的各个作用 1.ELF头：描述文件的总体格式 2.段头部表：将连续的文件映射到运行时的内存段。 3…init节：定义了一个_init函数，程序的初始化代码会调用它。 4…text节：已编译程序的机器代码。 5…rodata节：只读数据，比如printf语句中的格式串和开关语句的跳转表 6…data节：已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中。 7…bss节：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。 8…symtab节：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。 9…debug节：一个调试符号表，其条目是程序中定义的全局变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。 10…line节：原始C源程序的行号和.text节中机器指令之间的映射 11…strtab节：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。 12.节头部表：描述目标文件的节。 首先来看ELF头 我们可以看到sectionheaders节头表有27个 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 5.4hello的虚拟地址空间 在edb的DataDump一栏中可以看到程序的虚拟地址。 代码段开始于0x400000处，程序被载入，然后查看elf文件里面的programheaders，程序头表在执行时被使用，它负责提供链接器加载的内容并提供动态链接的信息分析elf里面的ProgramHeaders： PHDR：程序头表 INTERP：程序执行前需要调用的解释器 LOAD：程序目标代码和常量信息 DYNAMIC：动态链接器所使用的信息 NOTE:：辅助信息 GNU_EH_FRAME：保存异常信息 GNU_STACK：使用系统栈所需要的权限信息 GNU_RELRO：保存在重定位之后只读信息的位 其余的从.dynamic到.strtab节的内容是存放在0x00400fff后面 5.5链接的重定位过程分析 hello的objdump hello.o的objdump 可以明显看出来可执行文件对每个函数给出了重定位处理，给出了它们的绝对物理地址；而在hello.o中，只是给出了每个函数对于程序首地址的偏移地址。 通过上面两个文件，可以了解到链接实现的过程：将可重定位文件中的.text节中函数以及全局变量的相对地址转变为了绝对地址，全局变量的寻址方式0x0%rsp也将0x0改为了确定的地址。 对hello.中的重定位节中的定位：在hello.o中，给出了函数和全局变量相对于EIF头的偏移量，所以在链接后，给定了程序首地址，然后根据偏移量，计算出函数和全局变量的绝对地址 链接主要分为两个过程：符号解析和重定位。 1）符号解析：目标文件定义和引用符号，符号解析将每个符号引用和一个符号定义关联起来。 2）重定位：编译器和汇编器生成从0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。 对于hello来说，链接器把hello中的符号定义都与一个内存位置关联了起来，重定位了这些节，并在之后对符号的引用中把它们指向重定位后的地方。hello中每条指令都对应了一个虚拟地址，而且对每个函数，全局变量也都它关联到了一个虚拟地址，在函数调用，全局变量的引用，以及跳转等操作时都通过虚拟地址来进行，从而执行这些指令。 5.6hello的执行流程 在main函数之前执行的函数有： _start; _libc_start_main@plt; __libc_csu_init; _init; frame_dummy; register_tm_clones; 在main函数之后执行的程序有： Exit(); cxa_thread_atexit_impl; fini; 5.7Hello的动态链接分析 在进行动态链接前，首先进行静态链接，生成部分链接的可执行目标文件hello。此时共享库中的代码和数据没有被合并到hello中。加载hello时，动态链接器对共享目标文件中的相应模块内的代码和数据进行重定位，加载共享库，生成完全链接的可执行目标文件。 动态链接采用了延迟加载的策略，即在调用函数时才进行符号的映射。使用偏移量表GOT+过程链接表PLT实现函数的动态链接。GOT中存放函数目标地址，为每个全局函数创建一个副本函数，并将对函数的调用转换成对副本函数调用。 调用init之前的.got.plt 调用init之后的.got.plt 5.8本章小结 通过本章了解了c语言的链接过程，明白了链接的概念及作用，学会了GCC下链接操作对应的指令，并学会了查看hello运行时的虚拟地址空间，了解了hello的重定位过程，对hello的执行流程有了一定的了解，同时对hello的动态链接过程进行了分析。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 概念：进程的经典定义是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的代码和数据，它的栈、通用目的寄存器中的内容、程序计数器、环境变量和打开文件描述符的集合。进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 作用：在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 6.2简述壳Shell-bash的作用与处理流程 作用：shell是命令行界面，是系统内核的一层壳,作用是用来保护内核同时传递入与计算机交互的信息.它只是系统的一个工具,我们可以使用它来操作计算机。 处理流程： 从终端读入输入的命令。 Shell对用户输入命令进行解析，判断是否为内置命令。 如果是内置命令则立即调用内置命令处理函数，否则调用execve函数创建一个子进程进行运行。 判断是否为前台运行程序，如果是，则调用等待函数等待前台作业结束；否则将程序转入后台，直接开始下一次用户输入命令。 shell应该接受键盘输入信号，并对这些信号进行相应处理。 6.3Hello的fork进程创建过程 父进程通过调用fork函数创建一个新的运行的子进程。调用fork函数后，新创建的子进程几乎但不完全与父进程相同:子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本（包括代码、数据段、堆、共享库以及用户栈），子进程获得与父进程任何打开文件描述符相同的副本，这意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。fork被调用一次，却返回两次,子进程返回0，父进程返回子进程的PID。子进程有不同于父进程的PID。 6.4Hello的execve过程 execve函数加载并运行可执行目标文件，且带参数列表argv和环境变量列表envp。它在加载文件后，调用文件的启动代码，加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。 6.5Hello的进程执行 在获取程序进程ID（PID）之后，hello等待被内核执行，内核为hello保存一个上下文，这个上下文包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构（比如页表、进程表、文件表）等等。 Execve函数在当前进程的上下文中加载并运行一个新程序，当hello在内核中运行的时候，并行的也有其他进程，一个进程执行它的控制流的一部分的每一时间段叫做时间片，所以内核可以控制到底是否需要枪战当前进程，并重新开始一个先前被挂起的进程或者别的进程，这个过程成为调度。 在此前提下，hello程序与操作系统其他的进程通过内核的调度，切换上下文，并行地完成进程。当程序在完成一些操作的时候，例如调用一些系统函数，访问一些系统参数，当前程序需要核心权限，这时候就要让程序从用户态转变为核心态，通过信号函数的作用完成这个转换。 6.6hello的异常与信号处理 hello执行过程中出现的异常种类可能会有：中断、陷阱、故障、终止。 乱按和空格： 这都不会影响程序输出，因为乱按只是将屏幕的输入缓存到stdin，当getchar的时候读出一个’\n’结尾的字串（作为一次输入），其他字串会当做shell命令行输入。 运行时输入Ctrl-Z 可以看到输入Ctrl-Z后，hello进程停止了，原因是shell父进程收到SIGSTP信号，信号处理函数的逻辑是打印屏幕回显、将hello进程挂起。 输入ps命令查看PID 可以看到我们的hello进程被挂起，PID为27094 输入jobs命令： 可以看到hello进程的job号为1 pstree命令是查看进程树 输入fg指令后： 程序会继续运行。 kill命令 运行时输入Ctrl-C 可以看到输入Ctrl-C，hello进程终止了，原因是当按下ctrl-c之后，shell父进程收到SIGINT信号，信号处理函数的逻辑是结束hello，并回收hello进程。 6.7本章小结 在本章中，我们首先总结了进程的概念与作用，然后我们完整地分析并实践了hello程序是如何从头到尾运行的，并分析了可能出现的异常与信号处理，做出总结。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：又称相对地址，是程序运行由CPU产生的与段相关的偏移地址部分。他是描述一个程序运行段的地址。 物理地址：程序运行时加载到内存地址寄存器中的地址，内存单元的真正地址。他是在前端总线上传输的而且是唯一的。在hello程序中，他就表示了这个程序运行时的一条确切的指令在内存地址上的具体哪一块进行执行。 虚拟地址：使用虚拟寻址时，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送至内存前先转换成适当的物理地址。虚拟地址转化成物理地址的过程叫做地址翻译。在linux中，虚拟地址数值树等于线性地址，即hello中看到的地址加上对应段基地址的值。 线性地址：这个和虚拟地址是同一个东西，是经过段机制转化之后用于描述程序分页信息的地址。他是对程序运行区块的一个抽象映射。” 7.2Intel逻辑地址到线性地址的变换-段式管理 在x86保护模式下，段的信息（段基线性地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT或LDT中，而段寄存器存放的是段描述符在GDT或LDT内的索引值(index)。 一个逻辑地址由两部份组成，段标识符:段内偏移量。 首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]， 1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再依据对应寄存器，得到其地址和大小。我们就有了一个数组了。 2、拿出段选择符中前13位，能够在这个数组中。查找到相应的段描写叙述符，这样。它了Base。即基地址就知道了。 3、把Base+offset，就是要转换的线性地址了。 7.3Hello的线性地址到物理地址的变换-页式管理 线性地址即虚拟地址，用VA来表示。VA被分为虚拟页号（VPN）与虚拟页偏移量（VPO），CPU取出虚拟页号，通过页表基址寄存器（PTBR）来定位页表条目，在有效位为1时，从页表条目中取出信息物理页号（PPN），通过将物理页号与虚拟页偏移量（VPO）结合，得到由物理地址（PPN）和物理页偏移量（PPO）组合的物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 36位VPN被划分成四个9位的片，每个片被用作到一个页表的偏移量。CR3寄存器包含Ll页表的物理地址。VPN1提供到一个LlPET的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，以此类推。 Corei7是四级页表进行的虚拟地址转物理地址。48位的虚拟地址的前36位被分为四级VPN区。结合存放在CR3的基址寄存器，由前面多级页表的知识，可以确定最终的PPN，与VPO结合得到物理地址。 7.5三级Cache支持下的物理内存访问 首先取组索引对应位，向L1cache中寻找对应组。如果存在，则比较标志位，并检查对应行的有效位是否为1。如果上述条件均满足则命中。否则按顺序对L2cache、L3cache、内存进行相同操作，直到出现命中。然后向上级cache返回直到L1cache。如果有空闲块则将目标块放置到空闲块中，否则将缓存中的某个块驱逐，将目标块放到被驱逐块的原位置。 7.6hello进程fork时的内存映射 在shell输入命令行后，内核调用fork创建子进程，为hello程序的运行创建上下文，并分配一个与父进程不同的PID。通过fork创建的子进程拥有父进程相同的区域结构、页表等的一份副本，同时子进程也可以访问任何父进程已经打开的文件。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同，当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间。 7.7hello进程execve时的内存映射 execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要以下几个步骤： （1）删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。 （2）映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。 （3）映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。 （4）设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。 7.8缺页故障与缺页中断处理 缺页故障是一种常见的故障，当指令引用一个虚拟地址，在MMU中查找页表时发现与该地址相对应的物理地址不在内存中，因此必须从磁盘中取出的时候就会发生故障。 缺页中断处理：缺页处理程序是系统内核中的代码，选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送VA到MMU，这次MMU就能正常翻译VA了。 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆(heap)。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量brk,它指向堆的顶部。分配器将堆视为一组不同大小的块(block)的集合来维护。每个块就是一个连续的虚拟内存片(chunk),要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 基本方法：这里指的基本方法应该是在合并块的时候使用到的方法，有最佳适配和第二次适配还有首次适配方法，首次适配就是指的是第一次遇到的就直接适配分配，第二次顾名思义就是第二次适配上的，最佳适配就是搜索完以后最佳的方案，当然这种的会在搜索速度上大有降低。 策略：这里的策略指的就是显式的链表的方式分配还是隐式的标签引脚的方式分配还是分离适配，带边界标签的隐式空闲链表分配器允许在常数时间内进行对前面块的合并。这种思想是在每个块的结尾处添加一个脚部，其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离。显式空间链表就是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个前驱和后继指针，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。为了分配一个块，必须确定请求的大小类，并且对适当的空闲链表做首次适配，查找一个合适的块。如果找到了一个，那么就（可选地）分割它，并将剩余的部分插入到适当的空闲链表中。如果找不到合适的块，那么就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。如果空闲链表中没有合适的块，那么就向操作系统请求额外的堆内存，从这个新的堆内存中分配出一个块，将剩余部分放置在适当的大小类中。要释放一个块，我们执行合并，并将结果放置到相应的空闲链表中。 7.10本章小结 本章介绍了储存器的地址空间，讲述了虚拟地址、物理地址、线性地址、逻辑地址的概念，还有进程fork和execve时的内存映射的内容。描述了系统如何应对那些缺页异常，最后描述了malloc的内存分配管理机制（C语言为例）。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m字节的序列。所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。这使得所有输入和输出都能以一种统一且一致的方式来执行： 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。 2.LinuxShell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出、标准错误。 3.改变当前文件的位置。对于每个打开的文件，内核保持着一个文件位置k、初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显示地设置文件的当前位置为k。 4.读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。 5.关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。 8.2简述UnixIO接口及其函数 Linux提供如下IO接口函数： （1）read和write：最简单的读写函数； （2）readn和writen：原子性读写操作； （3）recvfrom和sendto：增加了目标地址和地址结构长度的参数； （4）recv和send：允许从进程到内核传递标志； （5）read和writev：允许指定往其中输入数据或从其中输出数据的缓冲区； （6）recvmsg和sendmsg：结合了其他IO函数的所有特性，并具备接受和发送辅助数据的能力。 8.3printf的实现分析 int printf(constcharfmt,…) { inti; char buf[256]; va_listarg =(va_list)((char)(&fmt)+4); //arg是一个指针，表示的是被省略参数中的第一个参数。 i= vsprintf(buf,fmt,arg); //vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt（输入）。//用格式字符串对个数变化的参数进行格式化，产生格式化输出。 write(buf, i);//接受buf与需要输出的参数个数， //执行写操作，把buf中的i个元素的值写到终端 returni; } 从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall. 字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 int getchar(void) { charc; return (read(0,&c,1)==1)?(unsignedchar)c:EOF //read函数的第一个参数是描述符fd，0代表标准输入 //第二个参数是输入内容的指针，这里是所读取字符的地址 //最后一个参数等于1表示读入字符数为1 } 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 hello进程需要I/O设备的信号来正确执行，而Unix通过将设备映射为文件来管理I/O设备。 printf()和getchar()函数通过调用vprintf()函数处理传入的参数，调用write()函数将数据提交给操作系统，然后操作系统通过管理硬件最后实现终端显示。 （第8章1分） 结论 1、首先有高级语言产生的hello.c文件 2、经过预处理后，hello.c进行了宏替换并且还将库函数.h文件等添加进入文件生成了hello.i 3、再通过编译器编译产生hello.s，变成了汇编语言。 4、再通过汇编器产生了hello.o，变成了可重定位文件。 5、通过链接器，将其他可重定位的文件写入进来变成hello可执行文件。 6、在shell中按要求输入并执行该可执行文件，shell会先fork一个子进程然后execve，加载运行hello。 7、创建了虚拟内存空间，并映射到物理内存。 8、在sleep函数时会发生异常，然后上下文切换。 9、printf函数会使用malloc函数申请堆空间，使用到动态内存管理技术。 10、printf函数会使用IO设备管理进行输出。 11、最后，进程结束被回收。Hello结束。 感想：感觉这门课虽然要结束了，但是要去学的东西还有很多很多，很多地方只是了解了大概，底层东西还是不太清楚，学海无涯，以前总是关注表面的东西，但是这常常导致编程错误，但是在学习了计算机系统之后，通篇读完这本书，包括写完这个大作业，对系统的整体等等有了更深的认识，明白了许多当时犯下的错误是因为什么，明白了做任何事不能在上面人云亦云，就像hello的一生，简单平凡，需要在底层，明白如何完成的，才知道自己该干什么不该干什么。hello的一生到此就结束了，但是我们的学习生涯才算刚刚开始，加油！ （结论0分，缺失-1分，根据内容酌情加分） 附件 hello.c源文件 hello.i预处理后的文件 hello.s编译后的汇编文件 hello.o汇编后的可重定位文件 hello链接后的可执行文件 hello.elfhello的elf文件 helloout.elfhello.o的elf文件 hello1.txtobjdumphello的反汇编文件 hello0.txtobjdumphello.o的反汇编文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1] 林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42. [2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999. [3] 赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）. [4] 谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13. [5] KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064. [6] CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. （参考文献0分，缺失-1分） 

汇编语言小汇总（1） 对于初学者而言，汇编语言晦涩难懂，所谓万事开头难。 初学者寻找汇编以及反汇编指令有些困难。 例如在linux下 我们可以使用Linux命令行，对于mstore.c 可以使用linux>gcc-Og-Smstore.c，使用“-S”，就会给编译器指令产生汇编文件。 如果我们使用“-c”选项，GCC就会编译并汇编该代码。 linux>gcc-Og-cmstore.c 另外，反汇编器的程序也很有用，在Linux中带“-d”命令行标志程序OBJDUMP("表示objectdump")可以充当这个角色。 linux>objdump-dmstorc.o --------------------------------------------- 以下为部分汇编语言总结 --------------------------------------------- C语言数据类型在x86-64中的大小。在64位机器中，指针长8字节 C声明Intel数据类型汇编代码后缀大小（字节）char字节b1short字w2int双字l4long四字q8char*四字q8float单精度s4double双精度q8 操作数的格式 类型格式操作数值名称立即数$ImmImm立即数寻址寄存器r1R[r1]寄存器寻址存储器ImmM[Imm]绝对寻址存储器(r1)M[R[r1]]间接寻址存储器Imm(r1)M[Imm+R[r1]](基址+偏移量)寻址存储器(r1,r2)M[R[r1]+R[r2]]变址寻址存储器Imm(r1,r2)M[Imm+R[r1]+R[r2]]变址寻址存储器(,r1,s)M[R[r1]*s]比例变址寻址存储器Imm(,r1,s)M(Imm+R[r1]*s)比例变址寻址存储器(r1,r2,s)M(R[r1]+R[r2]*s)比例变址寻址存储器Imm(r1,r2,s)M(Imm+R[r1]+R[r2]*s)比例变址寻址 下期更新汇编小汇总（2）包括数据传送指令，条件码，控制等。 

哈工大深入理解计算机系统大作业 文章目录 摘要 第1章概述1.1Hello简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2在Ubuntu下编译的命令3.3Hello的编译结果解析3.3.1数据3.3.2赋值3.3.3类型转换3.3.4算术操作3.3.5关系操作3.3.6数组操作3.3.7控制转移3.3.8函数操作 3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令4.3可重定位目标elf格式4.3.1ELF头4.3.2节头部表4.3.3符号表4.3.4重定位节 4.4Hello.o的结果解析4.4.1结果对比4.4.2机器语言的构成及与汇编语言的映射关系 4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式5.3.1ELF头5.3.2节头部表5.3.3程序头表5.3.4重定位节5.3.5符号表5.3.6动态符号表 5.4hello的虚拟地址空间5.5链接的重定位过程分析5.5.1hello.o与hello区别：5.5.2hello重定位地址计算 5.6hello的执行流程5.7Hello的动态链接分析5.8本章小结 第6章hello进程管理6.1进程的概念与作用6.2简述壳Shell-bash的作用与处理流程6.3Hello的fork进程创建过程6.4Hello的execve过程6.5Hello的进程执行6.6hello的异常与信号处理6.6.1异常处理与信号6.6.2Hello异常分析 6.7本章小结 第7章hello的存储管理7.1hello的存储器地址空间7.2Intel逻辑地址到线性地址的变换-段式管理7.2.1CPU的段寄存器：7.2.2段描述符7.2.3全局描述符表与局部描述符表7.2.4分段机制将逻辑地址转化为线性地址的步骤： 7.3Hello的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.4.1利用TLB加速地址翻译7.4.2单级页表的局限性7.4.3四级页表支持下的VA到PA的变换 7.5三级Cache支持下的物理内存访问7.6hello进程fork时的内存映射7.7hello进程execve时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.9.1动态内存分配器的基本原理7.9.2带边界标签的隐式空闲链表分配器原理7.9.3显式空间链表的基本原理7.9.4分离空闲链表的基本原理 7.10本章小结 第8章hello的IO管理8.1Linux的IO设备管理方法8.2简述UnixIO接口及其函数8.2.1UnixI/O接口 8.2.2UnixI/O函数8.3printf的实现分析8.4getchar的实现分析8.5本章小结 结论附件参考文献 摘要 本文以hello程序的P2P过程（即FromProgresstoProcess）为例，运用gcc,objdump,edb等工具，详细介绍了程序从最初的源代码到可执行的目标文件的整个过程，需要经历预处理、编译、汇编、链接等操作；并详细分析了运行hello程序时系统的进程管理、存储管理与I/O管理的原理与机制。 关键词：hello程序、P2P过程、编译系统、进程、系统级I/O 第1章概述 1.1Hello简介 P2P过程（FromProgramtoProcess）：从hello.c程序到二进制的可执行文件hello的过程。在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。 linux>gcc-ohellohello.c GCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。这个翻译过程由四个阶段完成，如上图，执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统。 O2O过程（FromZero-0toZero-0）：hello进程从无到有再到无的过程。 在shell中，键入命令行执行hello linux>./hello学号（参数1）姓名（参数2） shell通过fork创建一个新的进程，linux加载器execve()将程序计数器设置为程序入口点，并为hello进程映射虚拟内存，虚拟内存机制通过mmap为该进程规划一片空间。2.CPU为执行文件hello分配时间周期，执行逻辑控制流，每条指令在流水线上取值、译码、执行、访存、写回、更新PC。MMU和CPU在执行过程中通过高速缓存和TLB、多级页表在物理内存中存取数据、指令，通过I/O系统输入输出。如果触发异常，则把控制返回给内核进行处理。3.当程序运行结束时，shell回收进程hello以及其僵死子进程。释放内存并且删除有关的上下文。 1.2环境与工具 硬件环境：IntelCorei7-8565Ux64CPU；1.80GHz；8GRAM软件环境：Ubuntu20.04开发与调试工具：gcc，EDB，Hexedit，objdump，readelf，gedit 1.3中间结果 文件名作用hello.c源程序（文本）hello.i预处理之后的程序（文本）hello.s汇编语言程序（文本）hello.o可重定位目标程序（二进制）hello可执行目标程序（二进制）hello1_asm.txthello.o的反汇编文件hello2_asm.txthello的反汇编文件hello1_elf.txthello.o的elf头信息hello2_elf.txt可执行文件hello的elf头信息 1.4本章小结 本章概述了hello从源程序到可执行程序的过程，并且结合shell执行hello进程的整个过程，介绍了开发环境以及中间文件。 第2章预处理 2.1预处理的概念与作用 概念：预处理(pre-treatment)，在程序设计领域，一般是指程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。典型地，由预处理器(preprocessor)对程序源代码文本进行处理，得到的结果再由编译器核心进一步编译。这个过程并不对程序的源代码进行解析，但它把源代码分割或处理为特定的单位。作用：预处理阶段读取C源程序，对其中的预处理指令（以#开头的指令）和特殊符号进行处理。或者说是扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。预处理过程先于编译器对源代码进行处理，读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行转换。预处理过程还会删除程序中的注释和多余的空白字符。预处理指令主要有以下三种：1）包含文件：将源文件中以#include格式包含的文件复制到编译的源文件中，可以是头文件，也可以是其它的程序文件。2）宏定义指令：#define指令定义一个宏，#undef指令删除一个宏定义。3）条件编译：根据#ifdef和#ifndef后面的条件决定需要编译的代码。 2.2在Ubuntu下预处理的命令 预处理命令：gcc-Ehello.c-ohello.i或者cpphello.c>hello.i结果：预处理后生成文件hello.i 2.3Hello的预处理结果解析 查看hello.i文件 main函数体以及全局变量sleepsecs的代码保持不变，在这之前的部分约有三千行，这是由于头文件stdio.h，unistd.h，stdlib.h依次被展开。以stdio.h的展开为例，stdio.h是标准库文件，cpp到Ubuntu中的默认环境变量下寻找stdio.h，打开文件/usr/include/stdio.h，发现其中依然使用了#define预处理语句，cpp对stdio中的宏定义递归展开，最终hello.i文件中没有#define语句。可以发现，其中是用来大量的#ifdef/#ifndef条件编译语句，cpp会根据#ifdef和#ifndef后面的条件决定需要编译的代码。 2.4本章小结 本章主要介绍了预处理相关的概念、作用以及方法，并结合预处理文件对预处理过程进行分析。 第3章编译 3.1编译的概念与作用 概念：编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。编译的过程实质上是把预处理文件进行词法分析、语法分析、语义分析、优化，从C语言等高级语言转换为成机器更好理解的汇编语言程序，转换后的文件仍为ASCII文本文件。 作用：编译后生成的.s汇编语言程序文本文件比预处理文件更容易让机器理解、比.o可重定位目标文件更容易让程序员理解，是对于程序像机器指令的一步关键过程。 3.2在Ubuntu下编译的命令 编译命令：gcc-Shello.c-ohello.s或者cclhello.i-ohello.s结果：生成汇编程序hello.s 3.3Hello的编译结果解析 3.3.1数据 查看hello.c代码（如下图）： 程序中的数据主要有以下几类：①全局变量：sleepsecs②局部变量：整型i；main函数的函数参数：argc,argv③字符串常量：两个printf中的字符串④整型常量：汇编代码中的0、1、2、3、9等整型常量 ①全局变量：由于全局变量sleepsecs被初始化，所以存放在.data节中，由于源程序中声明sleepsecs为int类型，赋初值为2.5，可以发现在汇编代码中数据变为2，小数点后的部分被截断，并规定了对齐字节为4字节。 ②局部变量：i；main函数的参数argc，argv1）局部变量int类型的i：主要起计数作用，存储在运行时的栈中，地址为%rbp-4如图，首先对i变量赋初值为0 然后执行循环，比较i与9的大小，如果i<=9，则执行循环体，跳到.L4 .L4末尾对i进行加一，实现循环变量迭代 2）main函数的参数：int型的argc和字符型指针数组的指针argv。从汇编代码中可以看到，argc开始存储在寄存器rdi中，比较过程中放在了栈中，帧指针为%rbp-20，argv开始存储在寄存器rsi中，使用时放在栈中，帧指针为%rbp-32 第三行代码与if(argc!=3)相对应，如果相等，则跳转到.L2 ③字符串常量程序中存在两个printf中的字符串，分别是"Usage:Hello学号姓名！\n"和“Hello%s%s\n”，如图所示，字符串常量以uft-8格式编码并存储在.rodata段。 由于该文件还未进行汇编，此处仅使用符号.LC0和.LC1代表两个字符串的首地址。 ④整型常量：汇编代码中的0、1、2、3、9等整型常量代码段中的整型常量被改写为汇编语言中的立即数，作为代码段的一部分存储，上文中的0、1、2、3、9等均在此列。 3.3.2赋值 ①对全局变量sleepsecs的赋值intsleepsecs=2.5;对应汇编代码如图，在main函数之前就进行了赋值，赋值为2，并且四字节对齐。 ②对循环变量i的赋值for(i=0;i<10;i++)对应汇编代码 可以看到，对局部变量的赋值语句通过mov指令实现。除此之外也可以通过lea指令实现。 3.3.3类型转换 过程中对sleepsecs进行了隐式类型转换，如3.3.2图所示，要求赋值为2.5，但由于定义为int类型，所以发生了隐式类型转换，数据变为2。 3.3.4算术操作 本程序中唯一的算术运算是for循环对i的自增运算i++，在编译过程中被编译器翻译为ADD类指令，C代码与汇编代码如下所示 3.3.5关系操作 本程序中进行了两次关系操作：①argc!=3使用cmpl语句设置条件码，je语句根据条件码做出是否需要跳转的选择，如图，将argc的值与3比较，如果相等，则跳转到.L2，否则顺序执行。 ②i<10如图，将i的值与9进行比较，如果i小于等于9，则跳转至.L4执行循环体代码，否则继续向下执行。 3.3.6数组操作 程序用到的数组为argv指向的字符串指针数组，打印数组元素argv[1],argv[2]printf(“Hello%s%s\n”,argv[1],argv[2]);对应汇编代码如下，首先对指针argv解引用，加16后对应argv[2]，将argv[2]的值取出放入寄存器rdx中，再对指针argv解引用，加8后对应argv[1]，将argv[1]的值取出放入寄存器rsi中，最后将字符串常量放入寄存器rdi中，调用printf函数进行输出。 3.3.7控制转移 关系操作往往作为控制转移的判定表达式，本实验C代码中共有2处控制转移操作：if分支和for循环，分别对应两次关系操作。①if(argc!=3)控制转移如图，将argc的值与3比较，如果相等，则跳转到.L2，否则顺序执行。控制转移通过je实现。 ②for(i=0;i<10;i++)控制转移for循环在.L2处对循环变量i进行初始化，然后通过jmp跳转到.L3，在.L3中进行了循环终止条件的判断，如果i<=9，则跳转到循环体部分.L4，否则顺序执行。 3.3.8函数操作 本实验中的函数操作主要涉及以下函数：①printf②exit③sleep④getchar。①printf函数第一处：printf("Usage:Hello学号姓名！\n");printf函数在调用之前，首先将.LC0的printf格式串的地址放入寄存器rdi中进行传参，然后由于只有一个参数，编译器采取了一个小trick，将printf函数翻译为puts函数来进行输出。 第二处：printf("Hello%s%s\n",argv[1],argv[2]);printf函数在调用之前，三个参数按顺序依次为.rodato节的.LC1的printf格式串的地址，argv[1]，argv[2]，分别存放在了寄存器rdi，rsi，rdx中。 ②exit函数exit函数调用之前，将立即数1存入rdi中，作为exit的第一参数进行传递。 ③sleep函数 sleep(sleepsecs); sleepsecs放入寄存器rdi中，作为第一参数传递并调用sleep函数。 ④getchar函数 getchar(); 由于getchar函数无参数，直接调用getchar函数如图： 3.4本章小结 本章主要介绍编译操作的过程，主要将预处理后的hello.i文件编译为汇编代码文件hello.s，在此过程中，编译器将会对源文件进行语法分析、词法分析，得到汇编文件hello.s。同时，编译器还会对源代码进行保守的、有限的优化。同时，本章中解析了变量、相关运算，以及各类C语言的基本语句的汇编表示，更便于理解高级语言的底层表示。 第4章汇编 4.1汇编的概念与作用 概念：汇编器(as)将hello.s文件翻译成二进制机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存到目标文件hello.o中。hello.o是一个二进制文件，包含着程序的指令编码，如果用文本编辑器打开，将看到一堆乱码。 作用：在汇编过程中，文件格式将由面向阅读友好的文本文件转化为机器可执行的二进制文件，并且将文本文件中的常量转化为对应的二进制补码，同时，汇编过程也将生成可重定位目标文件的结构信息，Linux系统使用可执行可链接格式(ELF)对目标文件进行组织。 4.2在Ubuntu下汇编的命令 汇编命令：gcc-chello.s-ohello.o或者ashello.s-ohello.o结果：生成可重定位目标程序hello.o 4.3可重定位目标elf格式 4.3.1ELF头 使用readelf命令查看hello.o的elf格式 readelf-ahello.o>hello1_elf.txt ELF头以一个16字节的序列Magic开始，该序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助连接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（可重定位/可执行/共享）、机器类型、节头部表的文件偏移，以及节头部表条目的大小和数量。由hello.o文件的ELF头部分可知：该文件为REL（可重定位目标文件）；机器类型为AMDX86-64；节头部表的文件偏移为0；字节顺序为小端序；节头大小为64字节；节头数量为14。 4.3.2节头部表 Linux系统使用可执行可链接格式(ELF)对目标文件进行组织，其具体结构及其内容如图所示： .text：已编译程序的机器代码.rodata：只读数据.data：已初始化的全局和静态C变量.bss：未初始化的全局和静态C变量.symtab：符号表.rel.text：代码段重定位信息表.rel.data：数据段重定位信息表.debug：调试符号表.line：C代码行号与机器码行号映射表.strtab：字符串表 节头部表包含目标文件各节的语义，包括节的名称、大小、类型、地址、偏移量、是否链接、读写权限等信息。本程序对应的节头部表如下图所示：以.text节为例分析具体节头部表条目的含义，其大小为0x92字节；虚拟内存地址为0x0000000000000000，这是由于hello.o是可重定位目标文件，所以每个节都从0开始，用于重定位；读写权限为AX，即分配内存、可执行；相对于文件头的偏移量为0x40字节。 .rela.text节：一个.text节中的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。.data节：已初始化的静态和全局C变量。类型为PROGBITS，意为程序数据，旗标为WA，即权限为可分配可写。.bss节：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。类型为NOBITS，意为暂时没有存储空间，旗标为WA，即权限为可分配可写。.rodata节：存放只读数据，例如printf中的格式串和开关语句中的跳转表。类型为PROGBITS，意为程序数据，旗标为A，即权限为可分配。.comment节：包含版本控制信息。.note.GNU_stack节：用来标记executablestack（可执行堆栈）。.eh_frame节：处理异常。.rela.eh_frame节:.eh_frame的重定位信息。.shstrtab节：该区域包含节区名称。.symtab节：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。.strtab节：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部的节名字。 4.3.3符号表 符号表是由汇编器构造的，使用编译器输出到汇编语言.s文件中的符号。.symtab节中包含ELF符号表。这张符号表包含一个条目的数组。下图中展示了每个条目的格式： .symtab节 符号表每个条目都对应一个符号的语义，具体包括：①符号名称name：以整型变量存放在符号表中，是字符串表.strtab中的字节偏移，指向符号的以null结尾的字符串名字。②符号地址value：距定义目标的节的起始位置的偏移，对于可执行目标文件来说是一个绝对的运行时地址。③符号类型type：表明符号的类型，通常要么是数据，要么是函数。④符号范围binding：该字段表明符号是本地的还是全局的。⑤分配目标section：该字段是一个到节头部表的索引，表明对应符号被分配至目标文件的某个节；有三个特殊的伪节，它们在节头部表中是没有条目的：ABS代表不该被重定位的符号；UNDEF代表未定义的符号，即本模块中引用的外部符号；COMMON表示还未被分配位置的未初始化的数据目标。⑥目标大小size 在上图中，全局符号sleepsecs定义的条目，它是位于.data节中偏移量为0（即value值）处的4字节目标；全局符号main定义的条目，它是位于.text节中偏移量为0（即value值）处的133字节函数。全局符号puts，exit，printf，sleep，getchar定义的条目，是未定义的符号（UND），为NOTYPE未知类型；局部符号hello.c定义的条目为文件，是不该被重定位的符号（ABS）。 4.3.4重定位节 当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在.rel.data中。 ①offset：需要被修改的引用的字节偏移。②symbol：标识被修改引用应该指向的符号。③type：告知链接器如何修改新的引用。④addend：一些类型的重定位要使用它对被修改引用的值做偏移调整。 其中，重定位类型（type）常见有2种：①R_X86_64_32：重定位绝对引用。重定位时使用一个32位的绝对地址的引用，通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改；②R_X86_64_PC32：重定位PC相对引用。重定位时使用一个32位PC相对地址的引用。一个PC相对地址就是据程序计数器的当前运行值的偏移量。 ·重定位PC相对引用重定位算法如下：refaddr=ADDR(s)+r.offset;*refptr=(unsigned)(ADDR(r.symbol)+r.addend–refaddr);·重定位绝对引用重定位算法如下：*refptr=(unsigned)(ADDR(r.symbol)+r.addend);其中，假设算法运行时，链接器为每个节（用ADDR(s)表示）和每个符号都选择了运行时地址（用ADDR(r.symbol)）表示。 本程序中的重定位节，见下图： 以图中第一个条目.rodata的重定位为例，设它的重定位地址为refptr。第一步，计算引用的运行时地址refaddr=ADDR(s)+r.offset,.rodata的r.offset为0x16，ADDR(s)是由链接器确定的，所以可以计算出refaddr。第二步，更新引用，refptr=(unsigned)(ADDR(r.symbol)+r.addend–refaddr),.rodata的ADDR(r.symbol)也是由链接器确定的，r.addend由上图可知为0，refaddr第一步已经算出来了，所以，可以计算出refptr，即.rodata的重定位的重定位地址。 同时我们可以用objdump结合反汇编代码和查看.rodata节分析：objdump-dhello.o>hello_asm.txt首先查看0x1c附近的代码，可以看到该处代码与第一个格式串相关。 objdump-shello.o>hello_asm1.txt然后，查看.rodata节的内容，.rodata-4对应第一个格式串的位置。 4.4Hello.o的结果解析 4.4.1结果对比 在shell中输入命令objdump-dhello.o>hello_asm.txt查看反汇编文件hello_asm.txt和汇编程序hello.s，比较如下：①跳转语句不同hello.s：代码直接声明具体的段存储位置，操作数为助记符如.LC0，.LC1 反汇编代码：计算出地址，依据地址跳转 ②数据内容不同hello.s：立即数为10进制格式 反汇编代码：立即数为16进制格式 ③有无对应机器码hello.s：只有汇编代码反汇编代码：有对应的机器码④有无重定位条目hello.s：调用函数时采用函数的助记符，直接声明 对全局变量的引用采用助记符 反汇编：生成重定位的条目，在链接时计算运行时的内存地址，然后分配给每一条引用，保证每一条引用最终都能指向正确的地址。 4.4.2机器语言的构成及与汇编语言的映射关系 机器语言的构成：机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指指令系统令的集合。以Y86-64指令集为例（如下图）。指令编码长度从1个字节到10个字节不等。一条指令含有一个单字节的指令指示符，可能含有一个单字节的寄存器指示符，还可能含有一个8字节的常数字。字段fn指明是某个整数操作(OPq)、数据传送条件(cmovXX)或是分支条件(jXX)。所有的数值都用十六进制表示。下图展示了机器语言与汇编语言直接的映射关系： 在这个图中，左边是指令的汇编码表示，右边是字节编码。 4.5本章小结 本章介绍了汇编的整个过程，从汇编语言到机器码，重点关注了生成文件hello.o可重定位这一特性，并且通过objdump反汇编得到的代码与hello.s进行比较，了解了其中的映射机制以及两者之间的区别。 第5章链接 5.1链接的概念与作用 概念：链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可以被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至于运行时，也就是由应用程序来执行。作用：把可重定位目标文件和命令行参数作为输入，产生一个完全链接的，可以加载运行的可执行目标文件，使得分离编译成为可能。 5.2在Ubuntu下链接的命令 链接命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o /usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 结果：生成可执行目标文件hello 5.3可执行目标文件hello的格式 查看hello的ELF格式readelf-ahello>hello2_elf.txt 5.3.1ELF头 ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型(如可重定位、可执行或者共享的)、机器类型(如x86-64)、节头部表(sectionheadertable)的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目(entry)。查看ELF头： hello.o的ELF以一个16进制序列： 7f454c46020101000000000000000000作为ELF头的开头。这个序列描述了生成该文件的系统的字的大小为8字节和字节顺序为小端序。 ELF头的大小为64字节；目标文件的类型为EXEC（可执行文件）；机器类型为AMDX86-64；程序头条目数量为12、大小为56字节；节头条目数量为27、大小为64字节。 5.3.2节头部表 节头部表如下图：与hello.o的节头部表作对比，可以得出：①hello的节头部表增加了若干条目，下图中一共有26个节的信息，而hello.o的节头部表中只有13个节的信息。②所有节被分配了运行时的地址。可以看到下图中某些节地址有所不同，而hello.o的节头部表中所有节的Address为全0。 5.3.3程序头表 可执行文件或共享目标文件的程序头表是一个结构数组。每种结构都描述了系统准备程序执行所需的段或其他信息。 typedefstruct{ Elf64_Wordp_type; Elf64_Wordp_flags; Elf64_Offp_offset; Elf64_Addrp_vaddr; Elf64_Addrp_paddr; Elf64_Xwordp_filesz; Elf64_Xwordp_memsz; Elf64_Xwordp_align; }Elf64_Phdr; p_type：此数组元素描述的段类型或解释此数组元素的信息的方式。表 13-1中指定了类型值及其含义。p_offset：相对段的第一个字节所在文件的起始位置的偏移。p_vaddr：段的第一个字节在内存中的虚拟地址。p_paddr：段在与物理寻址相关的系统中的物理地址。由于此系统忽略了应用程序的物理地址，因此该成员对于可执行文件和共享目标文件具有未指定的内容。p_filesz：段的文件映像中的字节数，可以为零。p_memsz：段的内存映像中的字节数，可以为零。p_flags：与段相关的标志。表 13-2中指定了类型值及其含义。p_align：可装入的进程段必须具有p_vaddr和p_offset的同余值（以页面大小为模数）。此成员可提供一个值，用于在内存和文件中根据该值对齐各段。值0和1表示无需对齐。另外，p_align应为2的正整数幂，并且p_vaddr应等于p_offset（以p_align为模数）。 查看程序头表如下： 5.3.4重定位节 基本概念与4.3.4节一致 5.3.5符号表 如下图所示，hello程序的符号表包含编号Num、Value、Size、Type、Bind、Vis、Ndx、Name字段。其含义可以参照4.3.3内容，在此不做赘述。可以看到，可执行目标文件的符号表表项数目（51entries）明显多于可重定位目标文件的表项数目（18entries）。一方面，可执行目标文件中加入了与调试、加载、动态链接相关的节，使得表示节的符号数增多；另一方面，由于链接器对可重定位目标文件中的符号进行了进一步解析，加入了若干系统调用。 5.3.6动态符号表 动态符号表(.dynsym)用来保存与动态链接相关的导入导出符号，不包括模块内部的符号。而.symtab则保存所有符号，包括.dynsym中的符号。 5.4hello的虚拟地址空间 使用edb加载hello，由图知虚拟空间从0x400000开始。 以.text节和.rodata节为例 由节头部表知.text节起始地址为0x4010d0 结束于内存地址0x401215处 由节头部表知.rodata节起始地址为0x402000，结束于地址0x40202f 5.5链接的重定位过程分析 objdump-dhello>hello2_asm.txt反汇编hello文件 5.5.1hello.o与hello区别： ①虚拟地址不同hello.o：反汇编代码虚拟地址从0开始 hello：反汇编代码虚拟地址从0x400000开始 ②反汇编节数不同hello.o：只有.text节，其中只有main函数的反汇编代码 hello：在main函数之前填充有链接过程中重定位而加入进来各种函数、数据，增加了.init，.plt，.plt.sec等节的反汇编代码。 ③call函数跳转地址，引用全局变量地址不同hello.o： hello 不过注意到，相对地址没有改变。 5.5.2hello重定位地址计算 重定位地址计算伪代码如下图所示：·重定位PC相对引用重定位算法如下： refaddr=ADDR(s)+r.offset; *refptr=(unsigned)(ADDR(r.symbol)+r.addend–refaddr); ·重定位绝对引用重定位算法如下： *refptr=(unsigned)(ADDR(r.symbol)+r.addend); 其中，假设算法运行时，链接器为每个节（用ADDR(s)表示）和每个符号都选择了运行时地址（用ADDR(r.symbol)）表示。 5.6hello的执行流程 本小节中使用edb执行hello，下面列出了hello从加载到程序终止的所有调用与跳转的函数名及其运行时地址函数名运行时地址ld-2.27.so!_dl_start0x00007f294d8086c0ld-2.27.so!_dl_init0x00007f294d808c50hello!_start0x400550hello!init0x401000hello_main0x401105hello!puts@plt0x401080hello!exit@plt0x4010b0hello!printf@plt0x401090hello!sleep@plt0x404044hello!getchar@plt0x404028sleep@plt0x4010c0 5.7Hello的动态链接分析 动态链接项目中，查看dl_init前后项目变化。对于动态共享链接库中PIC函数，编译器加重定位记录，等待动态链接器处理，为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略，将过程地址的绑定推迟到第一次调用该过程。动态链接器使用过程链接表PLT+全局偏移量表GOT实现函数的动态链接，GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。GOT运行时地址为0x403ff0，PLT的运行时地址为0x404000。 在程序调用dl_init前，使用edb查看地址0x404000处的内容，如下所示： 在dl_init调用之前，对于每一条PIC函数调用，调用的目标地址都实际指向PLT中的代码逻辑，初始时每个GOT条目都指向对应的PLT条目的第二条指令。调用前： 调用后： 在dl_init调用前后，0x6008b0和0x6008c0处的两个8字节的数据分别发生改变。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。其中GOT[1]指向重定位表（依次为.plt节需要重定位的函数的运行时地址）用来确定调用的函数地址，GOT[2]是动态链接器ld-linux.so模块中的入口点。 在之后的函数调用时，首先跳转到PLT执行.plt中逻辑，第一次访问时，GOT地址为下一条指令，将函数序号压栈，然后跳转到PLT[0]，在PLT[0]中将重定位表地址压栈，然后访问动态链接器，在动态链接器中使用函数序号和重定位表确定函数运行时地址，重写GOT，再将控制传递给目标函数。之后如果对同样函数调用，第一次访问跳转直接跳转到目标函数。 5.8本章小结 本章首先介绍了链接的概念及作用，详细分析了可执行目标文件hello的ELF格式，并且通过edb调试查看其虚拟地址空间，并分析了重定位过程、执行流程和整个动态链接过程。 第6章hello进程管理 6.1进程的概念与作用 概念：进程是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。作用：进程提供给应用程序关键抽象：①一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。②一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。 6.2简述壳Shell-bash的作用与处理流程 1.shell的定义shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。2.shell的作用实际上shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。3.shell的处理流程shell首先检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux本身的实用程序，如ls和rm，也可以是购买的商业程序，如xv，或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能够成功找到命令，该内部命令或应用程序将被分解为系统调用并传给Linux内核。 6.3Hello的fork进程创建过程 终端程序通过调用fork()函数创建一个子进程，子进程得到与父进程完全相同但是独立的一个副本，包括代码段、数据段、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，父进程和子进程最大的不同时他们的PID是不同的。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。我们在shell上输入./hello，由于这不是一个内置的shell命令，所以shell会认为hello是一个可执行目标文件，通过调用某个驻留在存储器中被称为加载器的操作系统代码来运行它。 6.4Hello的execve过程 execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的PID，并且继承了调用execve函数时已打开所有文件描述符。hello的execve过程可以总结为以下几个步骤：删除已存在的用户区域；映射私有区域；映射共享区域；设置程序计数器。hello加载并运行后栈的结构如下： 6.5Hello的进程执行 上下文切换：操作系统内核使用一种称为上下文切换的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在较低层异常机制之上的。内核为每个进程维持-一个.上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度，是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个read系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。另一个示例是sleep系统调用，它显式地请求让调用进程休眠。hello程序与操作系统其他进程通过操作系统的调度，切换上下文，拥有各自的时间片从而实现并发运行。hello在调用sleep函数时做了上下文切换。 hello初始运行在用户模式中，直到它通过执行系统调用sleep陷入到内核。内核处理休眠请求主动释放当前进程(hello)，同时计时器开始计时，内核进行如上图所示的上下文切换，将当前进程的控制权交给其他进程，当进程达到sleep_secs的时间时，给其他进程发送中断信号，触发中断异常处理子程序，将hello进程从等待队列中移出，重新加入到运行队列。 6.6hello的异常与信号处理 6.6.1异常处理与信号 异常处理可以分为四类，如下表： 一种更高层的软件形式的异常，称为Linux信号，它允许进程和内核中断其他进程。一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。下图展示了Linux系统上支持的30种不同类型的信号。 6.6.2Hello异常分析 hello执行过程中进行如下操作：①键盘随机按键：如果按键过程中没有回车键，会把输入屏幕的字符串缓存起来；如果按键过程中有回车键，则当程序运行完成后，缓存区中的换行符前的字符串会被shell当作指令执行。 ②按Ctrl-Z键输入Ctrl-Z键会发送一个SIGTSTP信号给前台进程组的每一个进程，故hello进程停止。 运行ps命令：显示当前进程的状态运行jobs命令：用于显示Linux中的任务列表及任务状态，包括后台运行的任务。运行fg命令：用于将后台作业（在后台运行的或者在后台挂起的作业）放到前台终端运行。由于后台作业只有hello，于是hello被转到前台运行，继续循环输出字符串。 pstree命令：将所有行程以树状图显示 kill命令kill-9<进程号>：杀死对应进程 ②按Ctrl-C键 如果在程序运行过程中输入Ctrl+C,会让内核发送一个SIGINT信号给到前台进程组中的每个进程，结果是终止前台进程。 6.7本章小结 本章介绍了进程的定义与作用，对hello被加载、执行的过程进行分析，同时介绍shell的一般处理流程和作用，并且着重分析了调用fork函数创建新进程，调用execve函数加载并执行hello，以及hello的异常与信号处理。 第7章hello的存储管理 7.1hello的存储器地址空间 （1）逻辑地址：在有地址变换功能的计算机中,访问指令给出的地址(操作数)叫逻辑地址,也叫相对地址。要经过寻址方式的计算或变换才得到内存储器中的物理地址。（2）物理地址：在存储器里以字节为单位存储信息，为正确地存放或取得信息，每一个字节单元给以一个唯一的存储器地址，称为物理地址（PhysicalAddress），又叫实际地址或绝对地址。（3）虚拟地址： CPU启动保护模式后，程序运行在虚拟地址空间中。注意，并不是所有的“程序”都是运行在虚拟地址中。CPU在启动的时候是运行在实模式的，Bootloader以及内核在初始化页表之前并不使用虚拟地址，而是直接使用物理地址的。（4）线性地址： 线性地址（LinearAddress）是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 7.2.1CPU的段寄存器： 在CPU中，跟段有关的CPU寄存器一共有6个：cs，ss，ds，es，fs，gs，它们保存的是段选择符(或者叫段描述符)。而同时这六个寄存器每个都有一个对应的非编程寄存器，它们对应的非编程寄存器中保存的是段描述符。系统可以把同一个寄存器用于不同的目的，方法是先将其寄存器中的值保存到内存中，之后恢复。而在系统中最主要的是cs，ds，ss这三个寄存器。 7.2.2段描述符 段描述符就是保存在全局描述符表或者局部描述符表中，当某个段寄存器试图通过自己的段选择符获取对于的段描述符时，会将获取到的段描述符放到自己的非编程寄存器中，这样就不用每次访问段都要跑到内存中的段描述符表中获取。 7.2.3全局描述符表与局部描述符表 全局描述符表和局部描述符表保存的都是段描述符，记住要把段描述符和段选择符区别开来，保存在寄存器中的是段选择符，这个段选择符会到描述符表中获取对于的段描述符，然后将段描述符保存到对应寄存器的非编程寄存器中。系统中每个CPU有属于自己的一个全局描述符表(GDT)，其所在内存的基地址和其大小一起保存在CPU的gdtr寄存器中。其大小为64K，一共可保存8192个段描述符，不过第一个一般都会置空，也就是能保存8191个段描述符。第一个置空的原因是防止加电后段寄存器未经初始化就进入保护模式而使用GDT。而对于局部描述符表，CPU设定是每个进程可以创建属于自己的局部描述符表(LDT)，当前被使用的LDT的基地址和大小一起保存在ldtr寄存器中。不过大多数用户态的liunx程序都不使用局部描述符表，所以linux内核只定义了一个缺省的LDT供大多数进程共享。描述这个局部描述符表的局部描述符表描述符保存在GDT中。 7.2.4分段机制将逻辑地址转化为线性地址的步骤： 1）使用段选择符中的偏移值（段索引）在GDT或LDT表中定位相应的段描述符。(仅当一个新的段选择符加载到段寄存器中是才需要这一步)2）利用段选择符检验段的访问权限和范围，以确保该段可访问。3）把段描述符中取到的段基地址加到偏移量(也就是上述汇编语言汇中直接出现的操作地址)上，最后形成一个线性地址。 7.3Hello的线性地址到物理地址的变换-页式管理 Linux采用了分页的方式来记录对应关系。所谓的分页，就是以更大尺寸的单位页来管理内存。在Linux中，通常每页大小为4KB。CPU中的一个控制寄存器，页表基址寄存器(PageTableBaseRegister,PTBR)指向当前页表。n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移(VirtualPageOffsetm,VPO)和一个(n-p)位的虚拟页号(VirtualPageNumber,VPN)。MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE0，VPN1选择PTE1，以此类推。将页表条目中物理页号(PhysicalPageNumber,PPN)和虚拟地址中的VPO串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是P字节的，所以物理页面偏移(PhysicalPageOffset，PPO)和VPO是相同的。下图展示了从虚拟地址到物理地址的基于页表的翻译过程： 下图展示了当页命中时，CPU硬件执行的步骤： 第1步:处理器生成一个虚拟地址，并把它传送给MMU。第2步:MMU生成PTE地址，并从高速缓存/主存请求得到它。第3步:高速缓存/主存向MMU返回PTE。第4步:MMU构造物理地址，并把它传送给高速缓存/主存。第5步:高速缓存/主存返回所请求的数据字给处理器用来压缩页表的常用方法为使用层次结构的页表：以二级页表为例：第一级页表:每个PTE指向一个页表(常驻内存)第二级页表:每个PTE指向一页 下图描述了使用k级页表层次结构的地址翻译： 虚拟地址被划分成为k个VPN和1个VPO。每个VPNi都是一个到第i级页表的索引，其中1≤i≤k。第j级页表中的每个PTE,1≤j≤k-1，都指向第j+1级的某个页表的基址。第k级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN。之前，MMU必须访问k个PTE。对于只有一级的页表结构，PPO和VPO是相同的。访问k个PTE,第一眼看上去昂贵而不切实际。然而，这里TLB能够起作用，正是通过将不同层次，上页表的PTE缓存起来。实际上，带多级页表的地址翻译并不比单级页表慢很多。 7.4TLB与四级页表支持下的VA到PA的变换 7.4.1利用TLB加速地址翻译 正如我们看到的，每次CPU产生一个虛拟地址，MMU就必须查阅一个PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。如果PTE碰巧缓存在L1中，那么开销就下降到1个或2个周期。然而，许多系统都试图消除即使是这样的开销，它们在MMU中包括了一个关于PTE的小的缓存，称为翻译后备缓冲器(TranslationLookasideBuffer，TLB)。TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。如图9-15所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有T=2^t个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的。 TLB具有如下特征：MMU中一个小的相联存储设备实现虚拟页码向物理页码的映射对于页码数很少的页表可以完全包含在TLB中 上图展示了当TLB命中时(通常情况)所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。第1步：CPU产生一个虚拟地址。第2步和第3步：MMU从TLB中取出相应的PTE。第4步：MMU将这个虚拟地址翻译成–个物理地址，并且将它发送到高速缓存/主存。第5步：高速缓存/主存将所请求的数据字返回给CPU。当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，如上图所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。 7.4.2单级页表的局限性 在32位系统中，地址空间有32位，假设每个页面大小为4KB，每个PTE大小为4字节，那么即使所引用的只是虚拟地址空间中很小的一部分，也总是需要一个4MB的页表驻留在内存中，对于地址空间为64位的系统而言，问题将变得更加复杂。为解决上述问题，我们使用层次结构的页表来对其空间进行压缩，其主要思想为：将页表构建出层次结构，高级页表中存储低级页表的低质，最底层页表存储相应的物理内存地址。 7.4.3四级页表支持下的VA到PA的变换 Linux为了在更高层次提供抽像，为每个CPU提供统一的界面。提供了一个四层页管理架构，来兼容这些二级、三级、四级管理架构的CPU。 这四级分别为：①页全局目录PGD（对应刚才的页目录）②页上级目录PUD（新引进的）③页中间目录PMD（也就新引进的）④页表PT（对应刚才的页表）。 具体的翻译步骤参考7.4.3节k级页表层次结构的地址翻译，不再重复叙述。 其一级、二级、三级PTE格式如下所示： 四级PTE格式如下所示： 每次对一个页进行了写之后，MMU都会设置D位，又称修改位或脏位。修改位告诉内核在复制替换页之前是否必须写回牺牲页。内核可以通过调用一条特殊的内核模式指令来清除引用位和修改位。 7.5三级Cache支持下的物理内存访问 对于一个虚拟地址请求，CPU首先将去TLB寻找，看是否已经在TLB中缓存。如果命中的话就直接MMU获取，没有命中的话就先在结合多级页表，得到物理地址PA，L1Cache对PA进行分解，将其分解为标记(CT)、组索引(CI)、块偏移(CO)，检测物理地址是否L1cache命中，若命中，则直接将PA对应的数据内容取出返回给CPU，若不命中则在下一级中寻找，并重复L1cache中的操作。CPU的高速缓存机制具体过程图如下： 7.6hello进程fork时的内存映射 当fork函数被shell调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了hello进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的PID，并且继承了调用execve函数时已打开所有文件描述符。hello的execve过程可以总结为以下几个步骤：删除已存在的用户区域；映射私有区域；映射共享区域；设置程序计数器。hello加载并运行后栈的结构如下： 7.8缺页故障与缺页中断处理 7.8.1缺页故障虚拟内存中的字不在物理内存中(DRAM缓存不命中)即缺页。下图中展示了在缺页之前我们的示例页表的状态。CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。 7.8.2Linux缺页处理假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤： ①判断虚拟地址A是否合法，即A是否在某个区域结构定义的区域内。缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。②判断试图进行的内存访问是否合法。即进程是否有读、写或者执行这个区域内页面的权限。例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的?这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的?如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。③如果不是上述两点，则内核知道这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU。这次，MMU就能正常地翻译A，而不会再产生缺页中断了。 7.9动态存储分配管理 7.9.1动态内存分配器的基本原理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。分配器有两种基本风格，两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体来负责释放已分配的块。①显式分配器：要求应用显式地释放任何已分配的块。例如，c标准库提供一种叫做malloc程序包的显式分配器。c程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块。c++中的new和delete操作符与c中的malloc和free相当。②隐式分配器：另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器，而自动释放未使用的已分配的块的过程叫做垃圾收集，例如Lisp,ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块。 7.9.2带边界标签的隐式空闲链表分配器原理 对于带边界标签的隐式空闲链表分配器，一个块是由一个字的头部、有效载荷、可能的一些额外的填充，以及在块的结尾处的一个字的脚部组成的。 头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8的倍数，且块大小的最低3位总是0。因此，我们只需要内存大小的29个高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。我们称这种结构称为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。注意：此时我们需要某种特殊标记的结束块，可以是一个设置了已分配位而大小为零的终止头部。 7.9.3显式空间链表的基本原理 因为根据定义，程序不需要一个空闲块的主体，所以实现空闲链表数据结构的指针可以存放在这些空闲块的主体里面。 显式空闲链表结构将堆组织成一个双向空闲链表，在每个空闲块的主体中，都包含一个pred（前驱）和succ（后继）指针。使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于空闲链表中块的排序策略。一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址 7.9.4分离空闲链表的基本原理 分离空闲链表的核心思想是分离存储，即维护多个空闲链表，其中每个链表的块有大致相等的大小，实现有两种基本方法：简单分离存储和分离适配。C语言的malloc函数实现方法介绍显示空闲链表加分离适配。 7.10本章小结 在本章中整理了有关内存管理的知识，介绍了四种地址空间，以及intel环境下的段式管理和页式管理，同时以Inteli7处理器为例，介绍了基于四级页表、三级cache的虚拟地址空间到物理地址的转换，阐述了fork和exceve的内存映射，并介绍缺页故障和缺页中断管理机制。 第8章hello的IO管理 8.1Linux的IO设备管理方法 一个Linux文件就是一个m字节的序列：B0，B1，B2……Bm所有的IO设备（如网络、磁盘、终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单低级的应用接口，称为UnixI/O，这使得所有的输入和输出都被当做相应文件的读和写来执行。Coolfact:所有的I/O设备（网络、磁盘、终端）都被模型化为文件:/dev/sda2（用户磁盘分区）/dev/tty2（终端）甚至内核也被映射为文件:/boot/vmlinuz-3.13.0-55-generic（内核映像）/proc（内核数据结构）设备的模型化：文件设备管理：unixio接口 8.2简述UnixIO接口及其函数 8.2.1UnixI/O接口 ①打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息②Shell创建的每个进程都有三个打开的文件：标准输入、标准输出、标准错误。③改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k④读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k⑤关闭文件：内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去 8.2.2UnixI/O函数 ①open函数进程通过调用open函数来打开一个已存在的文件或者创建一个新文件： open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件:O_RDONLY:只读。O_WRONLY:只写。ORDWR:可读可写。 ②close函数进程通过调用close函数关闭一个打开的文件。 ③read和write函数 read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。 8.3printf的实现分析 查看printf函数的函数体： intprintf(constchar*fmt, ) { inti; charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); returni; } printf需要做的事情是：接受一个fmt的格式，然后将匹配到的参数按照fmt格式输出。printf用了两个外部函数，一个是vsprintf，还有一个是write。vsprintf函数作用是接受确定输出格式的格式字符串fmt（输入）。用格式字符串对个数变化的参数进行格式化，产生格式化输出。write函数将buf中的i个元素写到终端。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall。字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 查看getchar函数的函数体： intgetchar(void) { staticcharbuf[BUFSIZ];//缓冲区 staticchar*bb=buf;//指向缓冲区的第一个位置的指针 staticintn=0;//静态变量记录个数 if(n==0) { n=read(0,buf,BUFSIZ); bb=buf;//并且指向它 } return(--n>=0)?(unsignedchar)*bb++:EOF; } getchar有一个int型的返回值。当程序调用getchar时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中直到用户按回车为止(回车字符也放在缓冲区中)。当用户键入回车之后，getchar才开始从stdio流中每次读入一个字符。getchar函数的返回值是用户输入的第一个字符的ASCII码,如出错返回-1,且将用户输入的字符回显到屏幕。如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取。异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章主要介绍了Linux的IO设备管理方法、UnixIO接口及其函数，分析了printf函数和getchar函数的实现。 结论 程序从源代码hello.c到可执行文件hello需要经历编译系统处理的过程，包括预处理、编译、汇编、链接的过程。首先预处理过程预处理器cpp修改源程序hello.c为hello.i，读取头文件内容并插入到程序文本中；编译过程编译器cc1将hello.i翻译为汇编语言程序hello.s；汇编阶段汇编器as将hello.s翻译成机器语言指令，打包成可重定位目标程序hello.o；最后链接器ld将所有可重定位目标程序合并，得到可执行目标文件hello。我们在终端运行hello程序时，shell首先调用fork函数创建子进程，其地址空间与shell父进程完全相同；并调用execve函数在当前进程的上下文中加载并运行hello程序；之后调用hello程序的main函数，hello程序开始在一个进程的上下文中运行；期间，MMU，TLB，多级页表机制，三级cache共同完成对地址的请求；异常处理机制保证了hello对异常信号的处理，使程序平稳运行；UnixI/O让程序能够与文件进行交互。最后，hello运行完毕，shell回收子进程，内核会删除这个进程使用所需要创建的一系列数据结构。至此，hello程序运行结束。hello的一生，从源码到可执行文件，从执行再到运行结束，经历了复杂的过程，需要操作系统、硬件与软件的参与；通过学习这门课，我深深感受到了计算机系统的复杂和奥妙，同时对内部实现的有了更多了解，能更好地编写系统性能优良的代码以及规避掉一些由底层机制带来的bug。 附件 文件名作用hello.c源程序（文本）hello.i预处理之后的程序（文本）hello.s汇编语言程序（文本）hello.o可重定位目标程序（二进制）hello可执行目标程序（二进制）hello1_asm.txthello.o的反汇编文件hello2_asm.txthello的反汇编文件hello1_elf.txthello.o的elf头信息hello2_elf.txt可执行文件hello的elf头信息 参考文献 [1]RandalE.Bryant/DavidO’Hallaron.深入理解计算机系统（原书第3版）[M].机械工业出版社，2016：1-87.[2]段页式存储管理方式详解https://blog.csdn.net/low5252/article/details/106075945 

pycharm使用matploit绘图时无法输出中文解决方法 在代码中加上plt.rcParams[‘font.sans-serif’]=[u’SimHei’]plt.rcParams[‘axes.unicode_minus’]=False 

indexoutofrangeinself的解决方法 现在在使用pytorch中的Embedding层的时候出现了indexoutofrangeinself的报错，报错信息如下，现在记录一下解决方法。发现这个问题主要是由self.entity_embeddings(LongTensor[head]))这一条语句引起的，我的解决方法是把它换成self.entity_embeddings(Variable(LongTensor([head])))换了之后就不报错了，具体原因还没找到。 

网络正常但Chrome不能上网的解决方法 最近经常发生网络正常，但是Chrome无法连接网络的情况，记录解决方法：1.在Chrome的设置中打开电脑的代理设置：2.将自动检测打开之后点击保存：3.如果本来就是开着的可以尝试关闭之后再打开，点击保存。4.注意最后将Chrome浏览器关闭再重新打开，就可以正常上网了。 

leetcode746.使用最小花费爬楼梯c++ 746.使用最小花费爬楼梯 题目数组的每个索引作为一个阶梯，第i个阶梯对应着一个非负数的体力花费值cost【i】(索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为0或1的元素作为初始阶梯。示例1:输入:cost=[10,15,20]输出:15解释:最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。示例2:输入:cost=[1,100,1,1,1,100,1,1,100,1]输出:6解释:最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析这一题使用动态规划算法可以很快解决，但是其中有一些细节需要注意。首先，dp的大小应该是n+1，是因为最终需要站上顶层而不是最后一级台阶，需要将大小+1；其次需要考虑每一层最小的情况的可选区间。 代码 classSolution{ public: intminCostClimbingStairs(vector<int>&cost){ intn=cost.size(); vector<int>dp(n+1); for(inti=2;i<n+1;++i) { dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1]); } returndp.back(); } }; 

计算机系统大作业 程序人生-Hello’sP2P 计算机系统 大作业 题目程序人生-Hello’sP2P专业计算机学 号班 级学生郑晟赫 指导教师刘宏伟 计算机科学与技术学院2021年6月摘要本文主要通过分析hello这个程序的一生，回顾了这学期计算机系统这门课的几乎所有知识。在分析过程中使用ubuntu作为操作系统，并使用了一些工具辅助完成，目的是对于计算机系统的工作与原理有更深的了解。 关键词：计算机系统；程序的一生；P2P；O2O； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） 目录第1章概述-5-1.1HELLO简介-5-1.2环境与工具-5-1.3中间结果-5-1.4本章小结-6-第2章预处理-7-2.1预处理的概念与作用-7-2.2在UBUNTU下预处理的命令-7-2.3HELLO的预处理结果解析-7-2.4本章小结-8-第3章编译-9-3.1编译的概念与作用-9-3.2在UBUNTU下编译的命令-9-3.3HELLO的编译结果解析-9-3.3.1数据-10-3.3.2赋值-12-3.3.3类型转换-12-3.3.4算术操作-13-3.3.5关系操作-13-3.3.6数组/指针/结构操作-14-3.3.7函数调用-14-3.4本章小结-15-第4章汇编-17-4.1汇编的概念与作用-17-4.2在UBUNTU下汇编的命令-17-4.3可重定位目标ELF格式-17-4.3.1命令-17-4.3.2ELF头-17-4.3.3节头表-18-4.3.4重定位节-18-4.3.5符号表-19-4.4HELLO.O的结果解析-19-4.5本章小结-21-第5章链接-22-5.1链接的概念与作用-22-5.2在UBUNTU下链接的命令-22-5.3可执行目标文件HELLO的格式-22-5.3.1ELF头-22-5.3.1节头-23-5.4HELLO的虚拟地址空间-23-5.5链接的重定位过程分析-24-5.6HELLO的执行流程-25-5.7HELLO的动态链接分析-26-5.8本章小结-27-第6章HELLO进程管理-28-6.1进程的概念与作用-28-6.2简述壳SHELL-BASH的作用与处理流程-28-6.3HELLO的FORK进程创建过程-29-6.4HELLO的EXECVE过程-29-6.5HELLO的进程执行-29-6.6HELLO的异常与信号处理-30-6.7本章小结-34-第7章HELLO的存储管理-35-7.1HELLO的存储器地址空间-35-7.2INTEL逻辑地址到线性地址的变换-段式管理-35-7.3HELLO的线性地址到物理地址的变换-页式管理-36-7.4TLB与四级页表支持下的VA到PA的变换-36-7.5三级CACHE支持下的物理内存访问-37-7.6HELLO进程FORK时的内存映射-38-7.7HELLO进程EXECVE时的内存映射-38-7.8缺页故障与缺页中断处理-39-7.9动态存储分配管理-39-7.10本章小结-40-第8章HELLO的IO管理-41-8.1LINUX的IO设备管理方法-41-8.2简述UNIXIO接口及其函数-41-8.3PRINTF的实现分析-42-8.4GETCHAR的实现分析-43-8.5本章小结-43-结论-44-附件-45-参考文献-46- 第1章概述1.1Hello简介根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。P2P：首先，Hello的开始是一段储存在磁盘上的程序文本（Program），在需要使用这一个代码文件的时候，用预处理器处理hello.c文件，生成一个hello.i文件，也就是修改了的源程序，之后，hello.i输入编译器，编译器将生成一个hello.s文件，在这一步之前所有的文件都还是文本形式，还没有转换为二进制机器码格式。生成的hello.s文件将输入汇编器，产生一个hello.o，也就是可重定位程序，可重定位文件经过链接器的链接将生成可执行目标程序hello，此时在shell中调用相关命令将为其创建进程（Process），执行程序。O2O：在shell中输入相关命令后，shell将调用fork函数为这一程序创建进程，之后将通过exceve在进程的上下文中加载并运行hello，将进程映射到虚拟内存空间，并加载需要的物理内存。执行时，在CPU的分配下，指令进入CPU流水线执行。当执行结束后父进程将回收这一进程，内核将清除这一进程的相关信息，这一进程就结束了。1.2环境与工具列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。硬件环境：处理器：Intel®Core™i7-9750HCPU@2.60GHzRAM：32.00GB系统：64位操作系统，基于x64的处理器软件环境：Windows1064位；Ubuntu20.04开发与调试工具：gcc，as，ld，vim，edb，readelf，gedit，gdb1.3中间结果列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 中间结果文件名称文件作用Hello.i预处理后的文件Hello.s汇编程序Hello.o可重定位目标文件Hello可执行目标程序Elf.txtHello.o的ELF格式Dis_hello.txtHello.o的反汇编代码Hello.elfHello的elf格式文件Hello.txtHello的反汇编代码 1.4本章小结这一章主要堆hello在执行的过程中的总体流程进行了简要的概述，以及在实验中使用的软硬件条件以及实验中产生的文件。（第1章0.5分） 第2章预处理2.1预处理的概念与作用概念：预处理器（cpp）根据以字符#开头的命令，修改原始的c程序。作用：1.处理头文件：比如hello.c的第一行的#include<stdio.h>命令告诉预处理器读取系统有文件stdio.h的内容，并把它直接插入程序文本中。2.处理宏定义：对于#define指令，进行宏替换，对于代码中所有使用宏定义的地方使用符号表示的实际值替换定义的符号3.处理条件编译：根据可能存在的#ifdef来确定程序需要执行的代码段。4.处理特殊符号：例如#error等，预编译程序可以识别一些特殊的符号，并在后续过程中进行合适的替换。5.删除c语言源程序中的注释部分。2.2在Ubuntu下预处理的命令cpphello.c>hello.i 图2.1ubuntu下的预处理命令2.3Hello的预处理结果解析可以发现，原本的源代码文件只有28行，预处理后的文件为3074行，原本的源代码部分在3055行之后，在这之前是hello引用的所有的头文件stdio.h,unistd.h,stdlib.h内容的展开。而很显然我们发现插入的部分不止有这三个头文件的内容，还出现了其他的头文件，这是以为这三个头文件中同样使用#include命令引入了其他的头文件，这些头文件同样出现在了hello.i文件中。插入的库文件的具体信息如下图所示： 图2.2头文件信息可以观察如下两张图，我们发现在源代码头部出现的注释在预处理之后的源代码部分已经不可见，因此这一点就印证了我们上面说的在预处理过程中预处理器将删除源代码中的注释部分。由于源代码中不存在宏定义与#ifdef等部分，因此这一部分无法展示。 图2.3预处理后的源代码部分图2.4源代码文件2.4本章小结这一部分介绍了在预处理过程中预处理器的工作（头文件展开，宏替换，删除注释，条件替换等），同时使用ubuntu系统展示了对于hello.c文件的预处理过程与预处理结果。 （第2章0.5分） 第3章编译3.1编译的概念与作用概念：编译器（ccl）将文本文件hello.i翻译成文本文件hello.i，它包含一个汇编语言程序。作用：编译的主要作用可以分为如下几个部分： 扫描（词义分析）：将源代码程序输入扫描器，将源代码中的字符序列分割为一系列c语言中的符合语法要求的字符单元，这一部分可以分为自上而下的分析和自下而上的分析两种方式。语法分析：基于词法分析得到的字符单元生成语法分析树。语义分析：在语法分析完成之后由语义分析妻进行语义分析，主要就是为了判断指令是否是合法的c语言指令，这一部分也可以叫做静态语义分析，并不判断一些在执行时可能出现的错误，例如如果不存在IDE优化，这一步对于1/0这种只有在动态类型检查的时候才会发现的错误，代码将不会报错。中间代码：中间代码的作用是可使使得编译程序的逻辑更加明确，主要是为了下一步代码优化的时候优化的效果更好。代码优化：根据用户指定的不同优化等级对代码进行安全的、等价的优化，这一行为的目的主要是为了提升代码在执行时的性能。生成代码：生成是编译的最后一个阶段。在经过上面的所有过程后，在这一过程中将会生成一个汇编语言代码文件，也就是我们最后得到的hello.s文件，这一文件中的源代码将以汇编语言的格式呈现。 3.2在Ubuntu下编译的命令gcc-Shello.i-ohello.s 图3.1ubuntu下编译的命令3.3Hello的编译结果解析 3.3.1数据①常量数字常量：通过观察我们可以发现在源代码中使用的数字常量都是储存在.text段的，包括在比较的时候使用的数字变量3，在循环的时候使用的循环比较变量等数字常量都是储存在.text节的，具体情况可以见如下截图： 图3.2数字变量储存情况字符串常量：可以发现在printf等函数中使用的字符串常量是储存在.rotate段的，具体储存情况可以见如下截图： 图3.3字符常量储存情况②变量全局变量：在代码中存在一个全局变量，也就是在sleep中需要使用的sleepsecs变量，通过观察编译后的结果我们可以发现这一个全局变量放在了.data段，且大小被设置为4个字节，这一变量的初始化不需要其他的汇编语句，在刚开始的时候就初始化好了，详细情况可见如下截图： 图3.4全局变量储存情况局部变量：可以发现局部变量是储存在栈中的某一个位置的或是直接储存在寄存器中的，对于源代码中的每一个局部变量可以进行逐一分析。局部变量共有三个，一个是循环变量i，以及argc和argv，对于i，我们发现它储存在栈中地址为-4（%rbp）的位置，对于i的操作可见如下截图： 图3.5局部变量i的储存情况对于局部变量argc，标志的是在程序运行的时候输入的变量的个数，可以发现它储存在栈中地址为-20（%rbp）的位置，对于它的操作主要是与3比较之后确定有一部分代码是否执行，具体汇编代码如下截图： 图3.6局部变量argc的储存情况对于局部变量argv，是一个保存着输入变量的数组，观察发现它储存在栈中，具体汇编代码段如下： 图3.7局部变量argv的储存情况3.3.2赋值可以发现对于变量的赋值在代码中出现了两次，一次是对于全局变量sleepsecs的赋值，一次是对于循环变量i的在循环中的赋值，可以分别进行分析。对于全局变量的赋值正如我们在上面看到的图3.4中展示的一样，在编译完成的时候就已经完成了对于全局变量sleepsecs的赋值，因此不需要其他的赋值语句。对于局部变量i，每次循环结束的时候都对齐进行+1操作，具体的操作汇编代码如下: 图3.8对局部变量i的赋值操作3.3.3类型转换对于全局变量sleepsecs事实上是存在一个隐式类型转换的，对于int型的全局变量赋值为2.5，很显然最后sleepsecs的值将会是2，在这里发生了由float向int转换的隐式类型转换，这一点也可以在汇编代码中得到验证： 图3.9sleepsecs发生的隐式类型转换可以发现第9行中sleepsec被初始化为2，这也印证了类型转换的发生。3.3.4算术操作对于局部变量i，由于其是循环变量，因此在每一轮的循环中都要修改这个值，对于这个局部变量的算术操作的汇编代码如下： 图3.10对局部变量i的算术操作3.3.5关系操作源代码中一共出现了两处关系操作，具体情况可以分别分析。第一处是对于argc的判断，当等于3的时候将进行条件跳转，其中源代码片段如下： 图3.11关系操作1源代码而对应的汇编代码如下： 图3.12关系操作1汇编代码另一处是在for循环中对于循环变量i的判断，这一段的汇编代码如下图所示，当循环变量i大于等于9的时候将进行条件跳转。 图3.13关系操作2汇编代码3.3.6数组/指针/结构操作这一段代码中出现的数组操作只有一个，也就是对于argv数组的操作，观察汇编代码可以发现argv储存的两个值都存放在栈中，argv[1]的储存地址是-24（%rbp），而argv[1]的储存地址是-16（%rbp），对于数组操作的汇编代码如下截图： 图3.14数组操作3.3.7函数调用在这一段代码中出现了几个函数调用的情况，首先明确在X86系统中函数参数储存的规则，第1~6个参数依次储存在%rdi、%rsi、%rdx、%rcx、%r8、%r9这六个寄存器中，其余的参数保存在栈中的某些位置。Main函数：参数：传入参数argc和argv，其中argv储存在栈中，argc储存在%rdi中返回：在源代码中最后的返回语句是return0，因此在汇编代码中最后是将%eax设置为0并返回这一寄存器。汇编代码如下： 图3.15main函数汇编代码Printf函数：参数：第一次调用的时候只传入了字符串参数首地址；for循环中调用的时候传入了argv[1]和argc[2]的地址。调用：第一次是满足if条件的时候调用，第二次是在for循环条件满足的时候调用。具体汇编代码如下： 图3.16printf第一次调用 图3.17printf第二次调用Sleep函数：函数以全局变量sleepsecs为参数，这一参数储存在%edi中，这一函数在for循环的条件下被调用，详细汇编代码如下： 图3.18sleep函数调用Exit函数：参数：传入的参数为1，执行退出命令。调用：当if条件满足的时候调用这一函数。具体汇编代码如下： 图3.19exit函数的调用3.4本章小结本章主要介绍了在将修改了的源程序文件转换为汇编程序的时候主要发生的变化以及汇编代码文件中主要存在的部分以及源代码中的一些主要的操作对应的汇编代码中的汇编代码的展现形式。总的来说，编译器做的就是在进行词义分析和语义分析之后判断源代码符合语法要求之后将其转换为汇编代码。（第3章2分） 第4章汇编4.1汇编的概念与作用概念：汇编器as将hello.s翻译成机器语言指令，把这些指令打包成一种叫可重定位目标程序的格式，并将结果保存在目标文件hello.o中。（hello.o是一个二进制文件）。作用：将汇编代码根据特定的转换规则转换为二进制代码，也就是机器代码，机器代码也是计算机真正能够理解的代码格式。4.2在Ubuntu下汇编的命令命令：ashello.s-ohello.o 图4.1ubuntu下的汇编命令4.3可重定位目标elf格式4.3.1命令readelf-ahello.o>./elf.txt使用这一命令导出我们需要的elf的文件 图4.2生成可重定位目标elf格式4.3.2ELF头ELF头以一个16字节的序列开始，这个序列描述了生成该文件系统下的字的大小以及一些其他信息。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息：包括ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数量。具体ELF头的代码如下： 图4.3ELF头4.3.3节头表描述了.o文件中每一个节出现的位置，大小，目标文件中的每一个节都有一个固定大小的条目。具体内容如下图所示： 图4.4节头表4.3.4重定位节重定位节中包含了在代码中使用的一些外部变量等信息，在链接的时候需要根据重定位节的信息对这些变量符号进行修改。链接的时候链接器会根据重定位节的信息对外部变量符号决定选择何种方法计算正确的地址，通过偏移量等信息计算出正确的地址。本程序需要重定位的信息有：.rodata中的模式串，puts，exit，printf，slepsecs，sleep，getchar这些符号同样需要与相应的地址进行重定位。具体重定位节的信息如下图所示： 图4.5重定位节信息4.3.5符号表.symtab是一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。例如本程序中的getchar、puts、exit等函数名都需要在这一部分体现，具体信息如下图所示： 图4.6符号表内容4.4Hello.o的结果解析命令：objdump-d-rhello.o>Disas_hello.s反汇编代码如下： hello.o：文件格式elf64-x86-64 Disassemblyofsection.text: 0000000000000000:0:55push%rbp1:4889e5mov%rsp,%rbp4:4883ec20sub$0x20,%rsp8:897decmov%edi,-0x14(%rbp)b:488975e0mov%rsi,-0x20(%rbp)f:837dec03cmpl$0x3,-0x14(%rbp)13:7416je2b<main+0x2b>15:488d3d00000000lea0x0(%rip),%rdi#1c<main+0x1c>18:R_X86_64_PC32.rodata-0x41c:e800000000callq21<main+0x21>1d:R_X86_64_PLT32puts-0x421:bf01000000mov$0x1,%edi26:e800000000callq2b<main+0x2b>27:R_X86_64_PLT32exit-0x42b:c745fc00000000movl$0x0,-0x4(%rbp)32:eb3bjmp6f<main+0x6f>34:488b45e0mov-0x20(%rbp),%rax38:4883c010add$0x10,%rax3c:488b10mov(%rax),%rdx3f:488b45e0mov-0x20(%rbp),%rax43:4883c008add$0x8,%rax47:488b00mov(%rax),%rax4a:4889c6mov%rax,%rsi4d:488d3d00000000lea0x0(%rip),%rdi#54<main+0x54>50:R_X86_64_PC32.rodata+0x2154:b800000000mov$0x0,%eax59:e800000000callq5e<main+0x5e>5a:R_X86_64_PLT32printf-0x45e:8b0500000000mov0x0(%rip),%eax#64<main+0x64>60:R_X86_64_PC32sleepsecs-0x464:89c7mov%eax,%edi66:e800000000callq6b<main+0x6b>67:R_X86_64_PLT32sleep-0x46b:8345fc01addl$0x1,-0x4(%rbp)6f:837dfc09cmpl$0x9,-0x4(%rbp)73:7ebfjle34<main+0x34>75:e800000000callq7a<main+0x7a>76:R_X86_64_PLT32getchar-0x47a:b800000000mov$0x0,%eax7f:c9leaveq80:c3retq分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。可以发现有如下几点不同： 进制不同：hello.s反汇编之后对于数字的表示是十进制的，而hello.o反汇编之后数字的表示是十六进制的。分支转移：对于条件跳转，hello.s反汇编中给出的是段的名字，例如.L2等来表示跳转的地址，而hello.o由于已经是可重定位文件，对于每一行都已经分配了相应的地址，因此跳转命令后跟着的是需要跳转部分的目标地址。函数调用：hello.s中，call指令后跟的是需要调用的函数的名称，而hello.o反汇编代码中call指令使用的是main函数的相对偏移地址。同时可以发现在hello.o反汇编代码中调用函数的操作数都为0，即函数的相对地址为0，因为再链接生成可执行文件后才会生成其确定的地址，所以这里的相对地址都用0代替。4.5本章小结本章对汇编过程进行了一个简单但是完整的叙述。经过汇编器之后，生成了一个可重定位的文件，为下一步链接做好了准备。通过与hello.s的反汇编代码的比较，更加深入的理解了在汇编过程中发生的变化，这些变化都是为了链接做准备的。（第4章1分） 第5章链接5.1链接的概念与作用概念：链接是将各种不同文件的代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。作用：把预编译好了的若干目标文件合并成为一个可执行目标文件。使得分离编译称为可能，不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为可独立修改和编译的模块。当改变这些模块中的一个时，只需简单重新编译它并重新链接即可，不必重新编译其他文件。5.2在Ubuntu下链接的命令命令：ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5.1ubuntu下的链接命令5.3可执行目标文件hello的格式命令：readelf-ahello>hello1.elf5.3.1ELF头包含内容与汇编中4.3.2节展示的类似，详细内容截图如下：分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 图5.2ELF头5.3.1节头描述了各个节的大小、偏移量和其他属性。链接器链接时，会将各个文件的相同段合并成一个大段，并且根据这个大段的大小以及偏移量重新设置各个符号的地址。详细内容如下： 图5.3节头表部分内容5.4hello的虚拟地址空间使用edb打开hello可执行文件，可以在edb的DataDump窗口看到hello的虚拟地址空间分配的情况，具体内容截图如下： 图5.4edb中的datadump视图可以发现这一段程序的地址是从0x401000开始的，并且该处有ELF的标识，可以判断从可执行文件时加载的信息。接下来可以分析其中的一些具体的内容：其中PHDR保存的是程序头表；INTERP保存了程序执行前需要调用的解释器；LOAD记录程序目标代码和常量信息；DYNAMIC储存了动态链接器所使用的信息；NOTE记录的是一些辅助信息；GNU_EH_FRAME保存异常信息；GNU_STACK使用系统栈所需要的权限信息；GNU_RELRO保存在重定位之后只读信息的位置。5.5链接的重定位过程分析命令：objdump-d-rhello>hello_objdump.s 图5.5hello反汇编代码部分hello与hello.o的不同：1.在链接过程中，hello中加入了代码中调用的一些库函数，例如getchar，puts，printf，等，同时每一个函数都有了相应的虚拟地址。例如exit函数的虚拟地址如下图： 图5.6exit链接后虚拟地址展示2.对于全局变量的引用，由于hello.o中还未对全局变量进行定位，因此hello.o中用0加上%rip的值来表示全局变量的位置，而在hello中，由于已经进行了定位，因此全局变量的的值使用一个确切的值加上%rip表示全局变量的位置。 图5.7hello中全局变量的表示3.hello中增加了.init和.plt节，和一些节中定义的函数。4.hello中无hello.o中的重定位条目，并且跳转和函数调用的地址在hello中都变成了虚拟内存地址。这是由于hello.o中对于函数还未进行定位，只是在.rel.text中添加了重定位条目，而hello进行定位之后自然不需要重定位条目。5．地址访问：在链接完成之后，hello中的所有对于地址的访问或是引用都调用的是虚拟地址地址。例如下图中84行条件跳转代码所示： 图5.8hello中的地址访问链接的过程：链接主要分为两个过程：符号解析和重定位。符号解析：目标文件定义和引用符号，符号解析将每个符号引用和一个符号定义关联起来。重定位：编译器和汇编器生成从0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。5.6hello的执行流程根据反汇编代码可以看出执行函数及虚拟内存地址如下：401000<_init>401020<.plt>401030puts@plt401040printf@plt401050getchar@plt401060atoi@plt401070exit@plt401080sleep@plt401090<_start>4010c0<_dl_relocate_static_pie>4010c1401150<__libc_csu_init>4011b0<__libc_csu_fini>4011b4<_fini> 图5.9使用edb执行hello过程截图5.7Hello的动态链接分析当程序调用一个由共享库定义的函数时，由于编译器无法预测这时候函数的地址是什么，因此这时，编译系统提供了延迟绑定的方法，将过程地址的绑定推迟到第一次调用该过程时。通过GOT和过程链接表PLT的协作来解析函数的地址。在加载时，动态链接器会重定位GOT中的每个条目，使它包含正确的绝对地址，而PLT中的每个函数负责调用不同函数。那么，通过观察edb，便可发现dl_init后.got.plt节发生的变化。首先可以观察elf中.got.plt节的内容 图5.10elf中.got.plt的内容使用edb查看时有如下发现： 图5.11执行init之前的地址 图5.12执行init之后的地址5.8本章小结在链接过程中，各种代码和数据片段收集并组合为一个单一文件。利用链接器，分离编译称为可能，我们不用将应用程序组织为巨大的源文件，只是把它们分解为更小的管理模块，并在应用时将它们链接就可以完成一个完整的任务。经过链接，已经得到了一个可执行文件，接下来只需要在shell中调用命令就可以为这一文件创建进程并执行该文件。（第5章1分） 第6章hello进程管理6.1进程的概念与作用概念：进程是执行中程序的抽象。作用：在现代系统上运行一个程序时，我们会得到一个假象，好像我们的程序是系统中唯一运行的程序一样。我们的程序好像独占处理器和内存。处理器好像无间断地一条接一条执行我们程序中的指令，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象是通过进程的概念提供的。进程提供给应用程序的关键抽象：1）一个独立的逻辑控制流，提供一个程序独占处理器的假象；2）一个私有的地址空间，提供一个程序独占地使用内存系统的假象。6.2简述壳Shell-bash的作用与处理流程作用：shell执行一系列的读/求值步骤，然后终止。读步骤读取来自用户的一个命令行，求值步骤解析命令行，并根据解析结果运行程序。处理流程：1．Shell首先从命令行中找出特殊字符（元字符），在将元字符翻译成间隔符号。元字符将命令行划分成小块tokens。Shell中的元字符如下所示：SPACE,TAB,NEWLINE,&,;,(,),<,>,|2．程序块tokens被处理，检查看他们是否是shell中所引用到的关键字。3．当程序块tokens被确定以后，shell根据aliases文件中的列表来检查命令的第一个单词。如果这个单词出现在aliases表中，执行替换操作并且处理过程回到第一步重新分割程序块tokens。4．Shell对~符号进行替换。5．Shell对所有前面带有 符 号 的 变 量 进 行 替 换 。 6 ． S h e l l 将 命 令 行 中 的 内 嵌 命 令 表 达 式 替 换 成 命 令 ； 他 们 一 般 都 采 用 符号的变量进行替换。6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用 符号的变量进行替换。6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用(command)标记法。7．Shell计算采用$(expression)标记的算术表达式。8．Shell将命令字符串重新划分为新的块tokens。这次划分的依据是栏位分割符号，称为IFS。缺省的IFS变量包含有：SPACE,TAB和换行符号。9．Shell执行通配符*?[]的替换。10．shell把所有从处理的结果中用到的注释删除，并且按照下面的顺序实行命令的检查：A.内建的命令B.shell函数（由用户自己定义的）C.可执行的脚本文件（需要寻找文件和PATH路径）11．在执行前的最后一步是初始化所有的输入输出重定向。12．最后，执行命令。[1]6.3Hello的fork进程创建过程父进程通过调用fork函数创建一个新的运行的子进程。调用fork函数后，新创建的子进程几乎但不完全与父进程相同:子进程得到与父进程虚拟地址空间相同的(但是独立的)一份副本，包括代码、数据段、堆、共享库以及用户栈，子进程获得与父进程任何打开文件描述符相同的副本，这意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。fork被调用一次，却返回两次,子进程返回0，父进程返回子进程的PID。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。6.4Hello的execve过程exceve函数在当前进程的上下文中加载并运行一个新程序。exceve函数加载并运行可执行目标文件，并带参数列表和环境变量列表。只有当出现错误时，exceve才会返回到调用程序。所以，与fork一次调用返回两次不同，在exceve调用一次并从不返回。当加载可执行目标文件后，exceve调用启动代码，启动代码设置栈，将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序，由此将控制传递给新程序的主函数。6.5Hello的进程执行结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。进程调度：即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器（PC）的值，这些值唯一的对应于包含在运行时动态链接到程序的共享对象中的指令。这个PC的序列叫做逻辑控制流，或者简称逻辑流。进程是轮流适用处理器的，每个进程执行它的流的一部分，然后被抢占，然后轮到其他进程。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这种决策就叫做调度，是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行，我们说内核调度了这个进程。在内核调度了一个新的进程运行了之后，它就抢占了当前进程，并使用上下文切换机制来将控制转移到新的进程。内核模式转变到用户模式：操作系统内核使用上下文切换来实现多任务。内核为每个进程维持一个上下文，它是内核重启被抢占的进程所需的状态，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构的值。进程执行到某些时刻，内核可决定抢占该进程，并重新开启一个先前被抢占了的进程，这种决策称为调度。内核调度一个新的进程运行后，通过上下文切换机制来转移控制到新的进程：1）保存当前进程上下文；2）恢复某个先前被抢占的进程被保存的上下文3）将控制转移给这个新恢复的进程。当内核代表用户执行系统调用时，可能会发生上下文切换，这时就存在着用户态与核心态的转换。如下图所示： 图6.1上下文切换6.6hello的异常与信号处理正常执行状态： 图6.2程序正常执行状态异常类型：类别原因异步/同步返回行为中断来自I/O设备的信号异步总是返回到下一条指令陷阱有意的异常同步总是返回到下一条指令故障潜在可恢复的错误同步可能返回到当前指令终止不可恢复的错误同步不会返回处理方式： 图6.3中断处理方式 图6.4陷阱处理方式 图6.5故障处理方式 图6.6终止处理方式不停乱按：将屏幕的输入缓存到缓冲区。乱码被认为是命令，不影响当前进程的执行。 图6.7运行时不停乱按按下Ctrl-Z：程序运行时按Ctrl-Z，这时，产生中断异常，它的父进程会接收到信号SIGSTP并运行信号处理程序，然后便发现程序在这时被挂起了，并打印了相关挂起信息。 图6.8运行时按下Ctrl-ZCtrl-Z后运行ps，打印出了各进程的pid，可以看到之前挂起的进程hello。 图6.9挂起hello后执行psCtrl-Z后运行jobs，打印出了被挂起进程组的jid，可以看到之前被挂起的hello，以被挂起的标识Stopped。 图6.10挂起hello后执行jobsCtrl-Z后运行pstree，可看到它打印出的信息： 图6.11挂起hello后执行pstreeCtrl-Z后运行fg：因为之前运行jobs是得知hello的jid为1，那么运行fg1可以把之前挂起在后台的hello重新调到前台来执行，打印出剩余部分，然后输入hello回车，程序运行结束，进程被回收。 图6.12挂起hello后执行fgCtrl-Z后运行Kill：重新执行进程，可以发现hello的进程号为34230，那么便可通过kill-934230发送信号SIGKILL给进程34230，它会导致该进程被杀死。然后再运行ps，可发现已被杀死的进程hello。 图6.13挂起hello后执行kill按下Ctrl-C：进程收到SIGINT信号，结束hello。在ps中查询不到其PID，在job中也没有显示，可以看出hello已经被彻底结束。 图6.14运行hello时按下Ctrl-C6.7本章小结本章主要介绍了hello可执行文件的执行过程，包括进程创建、加载和终止，以及通过键盘输入等过程。从创建进程到进程并回收进程，这一整个过程中需要各种各样的异常和中断等信息。程序的高效运行离不开异常、信号、进程等概念，正是这些机制支持hello能够顺利地在计算机上运行。（第6章1分） 第7章hello的存储管理7.1hello的存储器地址空间逻辑地址：逻辑地址指由程序产生的与段相关的偏移地址部分，也叫相对地址。要经过寻址方式的计算或变换才得到内存储器中的实际有效地址，即物理地址。从hello的反汇编代码中看到的地址，它们需要通过计算，通过加上对应段的基地址才能得到真正的地址，这些便是hello中的逻辑地址。线性地址：是逻辑地址到物理地址变换之间的中间层。程序hello的代码会产生逻辑地址，hello的反汇编文件中看到的地址（即逻辑地址）中的偏移量，加上对应段的基地址，便得到了hello中内容对应的线性地址。虚拟地址：有时我们也把逻辑地址称为虚拟地址。因为与虚拟内存空间的概念类似，逻辑地址也是与实际物理内存容量无关的，是hello中的虚拟地址。物理地址：是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。在hello的运行中，在访问内存时需要通过CPU产生虚拟地址，然后通过地址翻译得到一个物理地址，并通过物理地址访问内存中的位置。7.2Intel逻辑地址到线性地址的变换-段式管理逻辑地址由段选择符和偏移量组成，线性地址为段首地址与逻辑地址中的偏移量组成。其中，段首地址存放在段描述符中。而段描述符存放在描述符表中，也就是GDT（全局描述符表）或LDT（局部描述符表）中。 图7.1段式管理示意图段式管理特点:1.段式管理以段为单位分配内存，每段分配一个连续的内存区。2.由于各段长度不等，所以这些存储区的大小不一。3.同一进程包含的各段之间不要求连续。4.段式管理的内存分配与释放在作业或进程的执行过程中动态进行。7.3Hello的线性地址到物理地址的变换-页式管理页式管理是一种内存空间存储管理的技术，页式管理分为静态页式管理和动态页式管理。将各进程的虚拟空间划分成若干个长度相等的页(page)，页式管理把内存空间按页的大小划分成片或者页面（pageframe），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。线性地址（虚拟地址）由虚拟页号VPN和虚拟页偏移VPO组成。首先，MMU从线性地址中抽取出VPN，并且检查TLB，看他是否因为前面某个内存引用缓存了PTE的一个副本。TLB从VPN中抽取出TLB索引和TLB标记，查找对应组中是否有匹配的条目。若命中，将缓存的PPN返回给MMU。若不命中，MMU需从页表中的PTE中取出PPN，若得到的PTE无效或标记不匹配，就产生缺页，内核需调入所需页面，重新运行加载指令，若有效，则取出PPN。最后将线性地址中的VPO与PPN连接起来就得到了对应的物理地址。 图7.2Corei7地址翻译7.4TLB与四级页表支持下的VA到PA的变换每次CPU产生一个虚拟地址，MMU（内存管理单元）就必须查阅一个PTE（页表条目），以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会从内存多取一次数据，代价是几十到几百个周期。如果PTE碰巧缓存在L1中，那么开销就会下降1或2个周期。然而，许多系统都试图消除即使是这样的开销，它们在MMU中包括了一个关于PTE的小的缓存，称为翻译后备缓存器（TLB）。虚拟地址VA虚拟页号VPN和虚拟页偏移VPO组成。若TLB命中时，所做操作与7.3中相同；若TLB不命中时，VPN被划分为四个片，每个片被用作到一个页表的偏移量，CR3寄存器包含L1页表的物理地址。VPN1提供到一个L1PTE的偏移量，这个PTE包含L2页表的基地址。VPN2提供到一个L2PTE的偏移量，依次类推。最后在L4页表中对应的PTE中取出PPN，与VPO连接，形成物理地址PA。 图7.3多级页表管理7.5三级Cache支持下的物理内存访问MMU将物理地址发给L1缓存，缓存从物理地址中取出缓存偏移CO、缓存组索引CI以及缓存标记CT。若缓存中CI所指示的组有标记与CT匹配的条目且有效位为1，则检测到一个命中条目，读出在偏移量CO处的数据字节，并把它返回给MMU，随后MMU将它传递给CPU。若不命中，则在下一级cache或是主存中寻找需要的内容，储存到上一级cache后再一次请求读取。 图7.4存储器层次结构7.6hello进程fork时的内存映射当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给他一个唯一的pid。为了给这个新进程创建虚拟内存，系统创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有写时复制。当fork从新进程返回，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，也就为每个进程保持了私有地址空间的抽象概念。7.7hello进程execve时的内存映射execve函数在当前进程中加载并运行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。加载并运行hello需要：(1)删除已存在的用户区域(2)映射私有区域:为新程序hello的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。(3)映射共享区域:如果hello程序与共享对象（或目标）链接，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。(4)设置程序计数器(PC),指向代码的入口点。7.8缺页故障与缺页中断处理页面命中完全是由硬件完成的，而处理缺页是由硬件和操作系统内核协作完成的： 处理器生成一个虚拟地址，并将它传送给MMUMMU生成PTE地址，并从高速缓存/主存请求得到它高速缓存/主存向MMU返回PTEPTE中的有效位是0，所以MMU出发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。缺页处理程序确认出物理内存中的牺牲页，如果这个页已经被修改了，则把它换到磁盘。缺页处理程序页面调入新的页面，并更新内存中的PTE缺页处理程序返回到原来的进程，再次执行导致缺页的命令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面已经换存在物理内存中，所以就会命中。 图7.5缺页操作示意图7.9动态存储分配管理定义：一种内存管理方法。对内存空间的分配、回收等操作在进程执行过程中进行，以便更好地适应系统的动态需求，提高内存利用率。分配器的基本风格： 显示分配器：要求应用显示地释放任何已分配的块。隐式分配器：要求分配器检测一个已分配的块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器。基本方法与策略：1.带边界标签的隐式空闲链表分配器管理带边界标记的隐式空闲链表的每个块是由一个字的头部、有效载荷、可能的额外填充以及一个字的尾部组成的。当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个符合大小的空闲块来放置这个请求块。分配器有三种放置策略：首次适配、下一次适配合最佳适配。在释放一个已分配块的时候需要考虑是否能与前后空闲块合并，减少系统中碎片的出现。2.显示空间链表管理显式空闲链表是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。如，堆可以组织成一个双向链表，在每个空闲块中，都包含一个前驱与一个后继指针。放置策略与上述放置策略一致。7.10本章小结本章主要介绍了hello进程在执行的过程中的虚拟内存与物理内存之间的转换关系，以及一些支持这些转换的硬件或软件机制。同时介绍了在发生缺页异常的时候系统将会如何处理这一异常。最后介绍了动态内存分配的作用以及部分方法与策略。 （第7章2分） 第8章hello的IO管理8.1Linux的IO设备管理方法设备的模型化：文件。所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入输出都被当做对相应文件的读和写来执行。设备管理：unixio接口。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。8.2简述UnixIO接口及其函数UnixIO接口：打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（文件描述符0）、标准输出（描述符为1），标准出错（描述符为2）。头文件<unistd.h>定义了常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，他们可用来代替显式的描述符值。改变当前的文件位置，文件开始位置为文件偏移量，应用程序通过seek操作，可设置文件的当前位置为k。读写文件，读操作：从文件复制n个字节到内存，从当前文件位置k开始，然后将k增加到k+n；写操作：从内存复制n个字节到文件，当前文件位置为k，然后更新k。关闭文件：当应用完成对文件的访问后，通知内核关闭这个文件。内核会释放文件打开时创建的数据结构，将描述符恢复到描述符池中UnixIO函数：(1).打开文件：intopen(char*filename,intflags,mode_tmode);Open函数将filename转换为一个文件描述符，并且返回描述符数字，返回的描述符总是在进程当中没有打开的最小描述符。Flags参数指明了进程打算如何访问这个文件，同时也可以是一个或者更多为掩码的或，为写提供给一些额外的指示。Mode参数指定了新文件的访问权限位。(2).关闭文件：intclose(intfd);调用close函数，通知内核结束访问一个文件，关闭打开的一个文件。成功返回0，出错返回-1。(3).读文件：ssize_tread(intfd,void*buf,size_tn);调用read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示错误，返回值0表示EOF，否则返回值表示的是实际传送的字节数量。(4).写文件：ssize_twrite(intfd,constvoid*buf,size_tn);调用从内存位置buf复制至多n个字节到描述符fd的当前文件位置。返回值-1表示出错，否则，返回值表示内存向文件fd输出的字节的数量。8.3printf的实现分析printf函数：intprintf(constchar*fmt,…){inti;va_listarg=(va_list)((char*)(&fmt)+4);i=vsprintf(buf,fmt,arg);write(buf,i);returni;}可以发现printf的输入参数是fmt，但是后面是不定长的参数，同时在printf内存调用了两个函数，一个是vsprintf，一个是write。intvsprintf(char*buf,constchar*fmt,va_listargs){char*p;chartmp[256];va_listp_next_arg=args;for(p=buf;*fmt;fmt++){if(*fmt!=‘%’){*p++=*fmt;continue;}fmt++;switch(*fmt){case‘x’:itoa(tmp,*((int*)p_next_arg));strcpy(p,tmp);p_next_arg+=4;p+=strlen(tmp);break;case‘s’:break;default:break;}return(p-buf);}}Printf执行流程：vsprintf函数将所有的参数内容格式化之后存入buf，然后返回格式化数组的长度。write函数将buf中的i个元素写到终端。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。8.4getchar的实现分析getchar是读入函数的一种。它从标准输入里读取下一个字符，相当于getc(stdin)。返回类型为int型，为用户输入的ASCII码或EOF。getchar可用宏实现：#definegetchar()getc(stdin)。getchar有一个int型的返回值。当程序调用getchar时.程序就等着用户按键。用户输入的字符被存放在键盘缓冲区中。直到用户按回车为止（回车字符也放在缓冲区中）。当用户键入回车之后，getchar才开始从stdin流中每次读入一个字符。getchar函数的返回值是用户输入的字符的ASCII码，若文件结尾(End-Of-File)则返回-1(EOF)，且将用户输入的字符回显到屏幕。[2]异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。8.5本章小结本章主要介绍了linux系统中的I/O设备基本概念和管理方法，同时简单介绍了printf和getchar函数的实现。（第8章1分） 结论用计算机系统的语言，逐条总结hello所经历的过程。你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。Hello的一生是简单的但是又蕴含着每一个c语言程序执行前的必经之路： 预处理，hello.c文件通过cpp的预处理，得到了扩展后的源程序文件hello.i编译，hello.i通过编译器的处理，被翻译成了汇编语言程序hello.s汇编，在汇编器as的处理下，hello.s生成了可重定位文件hello.o链接，链接器将重定位目标文件链接为可执行目标文件hello生成子进程，在shell中输入指定命令shell调用fork函数为hello生成进程。Execve加载并运行hello程序，将它映射到对应虚拟内存区域，并依需求载入物理内存。I/O设备，在hello程序中存在输入与输出，这些部分与printf，getchar函数有关，这些函数与linux系统的I/O设备密切相关。Hello将在cpu流水线中执行每一条指令程序运行结束后，父进程会对其进行回收，内核把它从系统中清除。这样，hello就结束了它的一生。在计算机系统的设计与实现过程中所必须要满足的就是准确，程序的执行必须能输出准确的结果，在这一基础上进行一定的优化能够让程序执行的更快，包括cache，流水线，超标量等设计都是基于这些的。在完成大作业的过程中相当于回顾了一遍这学期的学习内容，对于计算机系统设计与实现也有了更深切的感悟。（结论0分，缺失-1分，根据内容酌情加分） 附件列出所有的中间产物的文件名，并予以说明起作用。中间结果文件名称文件作用Hello.i预处理后的文件Hello.s汇编程序Hello.o可重定位目标文件Hello可执行目标程序Elf.txtHello.o的ELF格式Dis_hello.txtHello.o的反汇编代码Hello.elfHello的elf格式文件Hello.txtHello的反汇编代码 （附件0分，缺失-1分） 参考文献为完成本次大作业你翻阅的书籍与网站等[1]伍之昂.LinuxShell编程从初学到精通[M].北京：电子工业出版社[2]https://baike.baidu.com/item/getchar/919709?fr=aladdin[3]《深入理解计算机系统》RandalE.BryantDavidR.O’Hallaron机械工业出版社[4]https://blog.csdn.net/wang13342322203/article/details/80862382[5]https://docs.microsoft.com/zh-cn/cpp/build/creating-precompiled-header-files?view=msvc-160[6]CSDN博客ELF可重定位目标文件格式[7]https://www.cnblogs.com/knife-king/p/11090029.html[8]https://baike.baidu.com/item/ELF/7120560?fr=aladdin[9]http://www.elecfans.com/emb/20190402898901.html （参考文献0分，缺失-1分） 

最优贸易题解c++实现 题目 题目描述C国有n个大城市和m条道路，每条道路连接这n个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这m条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为1条。 C国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到C国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设C国n个城市的标号从1~n，阿龙决定从1号城市出发，并最终在n号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有n个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品 水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来C国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设C国有5个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。C国有n个大城市和m条道路，每条道路连接这n个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这m条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为1条。C国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到C国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设C国n个城市的标号从1~n，阿龙决定从1号城市出发，并最终在n号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有n个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品 水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来C国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。假设C国有5个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。 假设1~n号城市的水晶球价格分别为4，3，5，6，1。阿龙可以选择如下一条线路：1->2->3->5，并在2号城市以3的价格买入水晶球，在3号城市以5的价格卖出水晶球，赚取的旅费数为2。阿龙也可以选择如下一条线路1->4->5->4->5，并在第1次到达5号城市时以1的价格买入水晶球，在第2次到达4号城市时以6的价格卖出水晶球，赚取的旅费数为5。 现在给出n个城市的水晶球价格，m条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入格式第一行包含2个正整数n和m，中间用一个空格隔开，分别表示城市的数目和道路的数目。 第二行n个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这n个城市的商品价格。 接下来m行，每行有3个正整数，x，y，z，每两个整数之间用一个空格隔开。如果z=1，表示这条道路是城市x到城市y之间的单向道路；如果z=2，表示这条道路为城市x和城市y之间的双向道路。 输出格式共1行，包含1个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出0。 样例数据 input5543561121141232351452 output5 分析 这一题主要思路就是找到在一条路径上的最大最小值，将其相减就是所求的收益。需要注意的是，最大值需要在最小值之后，那么很容易想到从前往后一次dijkstra求出最小值，从后往前一次dijkstra求出最大值，但是，这样是有问题的。由于对于一个顶点加入集合之后，dijkstra就不再更新该节点，我们不妨看一下下面这种情况，其中加粗的为该点的价格。其测试样例为 910 432157896 121 231 341 421 251 561 671 781 861 691 正确的输出应为8，但是正反两次dijkstra结果是6，这是由于1、2、3结点之间的更新出现一定问题，导致后续出现一定问题。那么这题可以采用正反两次SPFA算法就可以解决啦。以下是正确代码（在洛谷AC，且测试过一定的自己使用的样例） #include<queue> #include<vector> #include<cstdio> #include<cstring> #include<iostream> #defineINF1000000 #defineN1000005 usingnamespacestd; intdis1[N]={0},dis2[N]={0},vis[N]; vector<int>edge1[N],edge2[N];//分别是正向和反向建图 intn,m;//分别表示城市数和道路数 intprice[N]={0}; voidread() { cin>>n>>m; for(inti=1;i<=n;i++) { cin>>price[i]; } intu,v,k; for(inti=1;i<=m;i++) { cin>>u>>v>>k; edge1[u].push_back(v); edge2[v].push_back(u); if(k>1) { edge1[v].push_back(u); edge2[u].push_back(v); } } } voidSPFA1() { memset(dis1,INF,sizeof(dis1)); memset(vis,0,sizeof(vis)); queue<int>Q; Q.push(1); vis[1]=1; while(!Q.empty()) { inttemp=Q.front(); Q.pop(); dis1[temp]=min(dis1[temp],price[temp]); for(inti=0;i<edge1[temp].size();i++) { intv=edge1[temp][i]; if(dis1[temp]<dis1[v]) { dis1[v]=dis1[temp]; if(!vis[v]) { vis[v]=1; Q.push(v); } } } vis[temp]=0;//关键步骤 } } voidSPFA2() { memset(dis2,0,sizeof(dis2)); memset(vis,0,sizeof(vis)); queue<int>Q; Q.push(n); vis[n]=1; while(!Q.empty()) { inttemp=Q.front(); Q.pop(); dis2[temp]=max(dis2[temp],price[temp]); for(inti=0;i<edge2[temp].size();i++) { intv=edge2[temp][i]; if(dis2[temp]>dis2[v]) { dis2[v]=dis2[temp]; if(!vis[v]) { vis[v]=1; Q.push(v); } } } vis[temp]=0; } } intmain() { intres=0; read(); SPFA1(); SPFA2(); for(inti=1;i<=n;i++) { res=max(res,dis2[i]-dis1[i]); } cout<<res<<endl; system("pause"); return0; } 

解决numpy.ndarraysizechanged,mayindicatebinaryincompatibility.报错 目前正在学习使用一个python包的使用，运行示例代码过程中出现了numpy.ndarraysizechanged,mayindicatebinaryincompatibility报错。如下图所示： 实测只需要将numpy更新为最新版本（本人更新为1.20.2）即可解决问题。其中pip过程中可能提示tensorflow与最新版本的numpy不匹配，如下图： 经测试暂时未发现tensorflow运行出现问题。 

leetcode1139.最大的以1为边界的正方形c++ leetcode1139.最大的以1为边界的正方形c++题目给你一个由若干0和1组成的二维网格grid，请你找出边界全部由1组成的最大正方形子网格，并返回该子网格中的元素数量。如果不存在，则返回0。 示例1： 输入：grid=[[1,1,1],[1,0,1],[1,1,1]] 输出：9 示例2： 输入：grid=[[1,1,0,0]] 输出：1 提示： 1<=grid.length<=1001<=grid[0].length<=100grid[i][j]为0或1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/largest-1-bordered-square 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析这道题的解决可以从一个点开始向它的周围进行遍历，寻找符合题意的最大正方形。在代码实现中是通过定义一个点是正方形的右下点，求出可能的最大正方形之后在可能值中求得最优解。代码 classSolution{ public: intlargest1BorderedSquare(vector<vector<int>>&grid){ intlength=grid.size(),width=grid[0].size(); intleft[length][width];//某点左边连续1的个数 intup[length][width];//某点上方连续1的个数 for(inti=0;i<length;i++) { for(intj=0;j<width;j++) { if(j&&grid[i][j-1])left[i][j]=left[i][j-1]+grid[i][j]; elseleft[i][j]=grid[i][j]; if(i&&grid[i-1][j])up[i][j]=up[i-1][j]+grid[i][j]; elseup[i][j]=grid[i][j]; } } intres=0; for(inti=0;i<length;i++) { for(intj=0;j<width;j++) { if(grid[i][j]) { intlen=min(left[i][j],up[i][j]);//可能的最大值 while(res<len) { if(up[i][j-len+1]>=len&&left[i-len+1][j]>=len)//判断可能正方形的左下点和右上点是否符合提议 { res=len; break; } len--;//缩小可能正方形的大小 } } } } returnres*res; } }; 

anaconda中下载pip 一般情况下anaconda中是自带pip的，但是若不小心卸载了pip，那么可以用如下方法解决。1.打开链接https://pypi.org/project/pip/#files2.下载.tar.gz文件3.解压该文件4.使用AnacondaPrompt进入解压之后的文件夹5.运行如下代码 pythonsetup.pyinstall 6.等待安装完成即可 

leetcode刷题一个月心得 leetcode刷题心得： 今天刷题满一个月，在这一个月里，坚持刷题（其实也断了3、4天），从一开始的见题死，或者死磕两个小时才可以做出来，痛苦面具；到后来的轻轻松松半个小时，还可以找到比官方更好的一些算法，刷题刷上瘾。 感觉收获还是蛮大的，在此总结一下这一个月心得 感受方法层面的： 1、网上攻略千千万，自己动手才是真。说实在的，类似的攻略心得我也收藏了不少，但是也就是上个月才开始动手，就是做了简简单单的每日一题，也没有刻意，肯定又不全面的地方，但是我刷题的目的就是提升自己的代码能力，也算是物有所值。 2、坚持死磕是必须的一开始做题，中等难度的对我相当于都是判了死刑，孩子就可以打打简单的，而且效率还不高。但是我对于这种题，一般都是死磕一天，有事没事都想着他，最后也可以大概写出一些（但是也有很多bug，思路混乱不清晰之类的），最后快睡觉了，我才会放弃，看看官方解答。这样慢慢的，大概十几天吧，就发现了自己的一些问题，然后不断改进，最后其实真的进步收获蛮大的 3、不断反思自己的做题习惯对我来说，主要是两个：一个是代码想清楚了再开始打；一个是找bug的能力。 技能知识层面的： 1、边界条件要判断，其实到了最后，我找bug都是找边界条件的判断2、数据结构很有用。很多栈，二叉树，图的思想，当时学的时候的死的，后来在不断解决问题中才渐渐变成自己的3、算法这个很玄妙。我吹爆几个自己很薄弱的算法吧，动态规划（主要是字符串相关的，回文串，最长公共子串，floyd之类的），想法真的很巧妙DFS（深度优先搜索），这个算法其实是暴力算法的一种，我是在图的遍历那里学到的，后来发现自己压根不会举一反三，我很多最终都没有攻克的题目，一般都是搜索+回溯之类的，这个不重不漏真的很难，我现在还是不太懂。递归的应用其实这个我也没太搞明白，大概就是要有递归终止条件，递归主函数、递归方程之类的，这个也是想不明白很难的 下一阶段目标： 可能偶尔还是会刷leetcode，但是想要学习一下几个软件的使用分别是linux下的gdb调试以及各种命令IDA的使用burp的使用最近笔者对信息安全稍微侧重一下吧，前段时间看了一个椭圆方程加密的密码学问题，感觉很有意思 

leetcode 找全部回文子串集合（DFS和动态规划复习） 文章目录 问题一、官方是如何又一次站在大气层的？二、我遇到了那些问题三、得与失的反思 问题 给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。返回s所有可能的分割方案。 示例: 输入:“aab”输出:[[“aa”,“b”],[“a”,“a”,“b”]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindrome-partitioning著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 一、官方是如何又一次站在大气层的？ 我的思路和官方一样，也想过要用递归、搜索，但是写代码能力不行，一直有bug。在深入思索了官方的DFS+动态规划的思路之后，我觉得这是一道好题，有很多知识点可以学习。 官方思路： 由于需要求出字符串ss的所有分割方案，因此我们考虑使用搜索+回溯的方法枚举所有可能的分割方法并进行判断。 假设我们当前搜索到字符串的第i个字符，且s[0…i-1]位置的所有字符已经被分割成若干个回文串，并且分割结果被放入了答案数组ans中，那么我们就需要枚举下一个回文串的右边界j，使得s[i…j]是一个回文串。 因此，我们可以从i开始，从小到大依次枚举j。对于当前枚举的j值，我们使用双指针的方法判断s[i…j]是否为回文串：如果s[i…j]是回文串，那么就将其加入答案数组ans中，并以j+1作为新的i进行下一层搜索，并在未来的回溯时将s[i…j]从ans中移除。 如果我们已经搜索完了字符串的最后一个字符，那么就找到了一种满足要求的分割方法。 细节 我们可以将字符串s的每个子串s[i…j]是否为回文串预处理出来，使用动态规划即可。设f(i,j)表示s[i…j]是否为回文串，那么有状态转移方程： ​ 其中∧表示逻辑与运算，即s[i…j]为回文串，当且仅当其为空串（i>=j），其长度为11（i=j），或者首尾字符相同且s[i+1…j-1]为回文串。 预处理完成之后，我们只需要O(1)的时间就可以判断任意s[i…j]是否为回文串了。 官方代码如下： classSolution{ private: vector<vector<int>>f; vector<vector<string>>ret; vector<string>ans; intn; public: voiddfs(conststring&s,inti){ if(i==n){ ret.push_back(ans); return;//DFS的终止条件 } for(intj=i;j<n;++j){ if(f[i][j]){ ans.push_back(s.substr(i,j-i+1)); dfs(s,j+1); ans.pop_back(); //这个pop一开始很困惑，后来明白，这是把当前找的i到j的字符串去掉， //保证了j可以一直往后遍历，真的是想到了就是想到了，递归真的神了 } } } vector<vector<string>>partition(strings){ n=s.size(); f.assign(n,vector<int>(n,true)); for(inti=n-1;i>=0;--i){//必须从n-1开始 for(intj=i+1;j<n;++j){ f[i][j]=(s[i]==s[j])&&f[i+1][j-1]; } } dfs(s,0); returnret; } }; 为了更深刻的了解DFS的思想内涵，我找到了我之前写的一个图的DFS的代码，加深一下印象 代码如下： /*rooms为一个二维数组，储存图的顶点和边信息， rooms[i]里面的数字都是与i相邻的顶点编号 */ voidtravel(vector<vector<int>>&rooms) { intlen=rooms.size(); for(inti=0;i<len;i++) { visited.push_back(false); }//初始化visited数组，均标记为为访问 for(inti=0;i<len;i++)//防止不是连通图 { if(visited[i]==false) { DFS(i,rooms); } } } voidDFS(inti,vector<vector<int>>&rooms){ visited[i]=true;//标记已经访问过 intl=rooms[i].size();//顶点i连接的其它顶点 cout<<i;//输出当前被访问的节点 for(intj=0;j<l;j++) { if(visited[rooms[i][j]]==false) DFS(rooms[i][j],rooms); } } 2、动态规划判断回文子串：需要注意的是，动态规划如果想要知道ij，就必须要知道i+1，j-1，所以填矩阵的顺序一定是从下往上，从左往右，这是典型的动态规划的套路了。 二、我遇到了那些问题 我的失败代码如下： ```cpp classSolution{ public: vector<string>temp;//回文分割子集 vector<vector<string>>res; booljudge=true; stringfront,back; //判断s是否为回文，是返回0，否则为-1 inthelp(strings){ intn=s.size(); stringback; if(n==0)return0; for(inti=0;i<n;i++){ back.push_back(s[n-1-i]); }//将s反着复制一遍,笨办法 if(s.compare(back)==0){ return0; } elsereturn-1; } //还是写一个递归函数专门找回文吧 voidhui(intindex,strings){ intcopy;//复制尾指针 for(copy=index;copy<s.size();copy++){//生成回文集终止条件 front.clear(); for(i=index;i<copy+1;i++){ front.push_back(s[i]); }//复制部分字符串 //判断是否为回文 inti=help(front); if(i==0){ temp.push_back(front);//前面的已经时回文了，后面的同理 hui(copy+1,strings) //头指针后移 } else{ copy--; } } //主函数 vector<vector<string>>partition(strings){ inti;//循环 intindex=0;//角标，s某个回文开头 inttail;//s某个回文结尾 intcopy; intcount=s.size();//s的大小 tail=count; if(count==1){ temp.push_back(s); res.push_back(temp); returnres; } //目前不需要if(count==0)returnres; //两个指针，枚举方法：一开始的时候，一个固定在开头，另一个从尾端向前移动，发现回文，头指针向后移，尾端重新到最后 //保证枚举的不重不漏（但是这是有漏的），为指针一个一个移动，每一次都判断 while(tail!=-1) {index=0; } if(!temp.empty()) res.push_back(temp); temp.clear(); } returnres; }; }; 怎么说的，改了一个多小时，还是出现失败，我也佛了，感觉没用递归的纯循环就是死亡（大哭） 三、得与失的反思 有时候代码还是要积累和总结的事后诸葛也很重要，要知道很多事前诸葛就是从事后诸葛过来的。 

大创文献阅读 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档 文章目录 前言一、作者和发表年限二、研究内容1.摘要2.具体的东东 三、结论四、缺点 前言 提示：阅读了一篇外文文献SoilMoistureSensingwithCommodityRFIDSystems，在这里整理一下文献的思路。 提示：作者，发表年限，研究内容，研究结论 一、作者和发表年限 JWang†,LiqiongChang‡,ShouryaAggarwal†?,OmidAbari†andSrinivasanKeshav†§†UniversityofWaterloo,‡NorthwestUniversity,?IndianInstituteofTechnologyDelhi,§UniversityofCambridge MobiSys’20,June15–19,2020,Toronto,ON,Canada 二、研究内容 1.摘要 Intelligentirrigationbasedonmeasurementsofsoilmoisturelevelsineverypotinagreenhousecannotonlyimproveplantproductivityandqualitybutalsosavewater.However,existingsoilmoisturesensorsaretooexpensivetodeployineverypot.WethereforeintroduceGreenTag,alow-costRFID-basedsoilmoisturesensingsystemwhoseaccuracyiscomparabletothatofanexpensivesoilmoisturesensor.OurkeyideaistoattachtwoRFIDtagstoaplant’scontainersothatchangesinsoilmoisturecontentarereflectedintheirDifferentialMinimumResponseThreshold(DMRT)metricatthereader.Weshowthatalow-passfilteredDMRTmetricisrobusttochangesbothintheRFenvironment(e.g.,fromhumanmovement)andinpotlocations.Inarealisticsetting,GreenTagachievesa90-percentilemoistureestimationerrorsof5%,whichiscomparabletothe4%errorsusingexpensivesoilmoisturesensors.Moreover,thisaccuracyismaintaineddespitechangesintheRFen-vironmentandcontainerlocations.WealsoshowtheeffectivenessofGreenTaginarealgreenhouse. 大体意义上说，作者把两个RFID标签贴在花盆上，然后通过读写器读取两个标签的无线电能量相关信息，然后一通操作猛如虎，就可以测出土壤湿度。然后作者把自己的论文夸了一通。 2.具体的东东 RFID读取的MRT，RSS和phase都和土壤湿度有一定关系，但是前两者是线性关系。两个标签，一个贴在花盆外的土壤上方，一个贴在中部，两个曲线相减大概就是土壤湿度，然后多项式拟合。最后分析了一下环境的影响。 三、结论 MRT和土壤湿度是多项式函数关系，通过布置RFID标签，可以检测土壤湿度，精确度，持久性什么的都不错。 四、缺点 论文使用的RFID读写器太贵，ImpinjSpeedwayR420reader，人民币大概好几万，不适合普通的学生项目创新，有待改良。 

leetcode 矩阵置零(原地算法) 文章目录 前言一、题目是什么？二、解法1.我的解法2.官方层层递进的三个解法 总结维基百科定义：例题：解：解： 前言 提示：题目不是很难，但关键是怎么减少空间复杂度，我一开始想到的是o（m+n）的，后来看了答案，才知道原来还可以将本来的输入矩阵第一行和第一列进行改造，变成我们需要的标记数组。这样就是o（1）的空间复杂度了 提示：本题涉及到了一个名词，原地算法。 一、题目是什么？ 题目点击这里 二、解法 1.我的解法 我的代码（这是看过官方的第二个分析之后，我自己写的代码）： lassSolution{ public: voidsetZeroes(vector<vector<int>>&matrix){ intm=matrix.size();//row intn=matrix[0].size();//column boolflag1=false; boolflag2=false; for(inti=0;i<n;i++){ if(matrix[0][i]==0){ flag1=true; break; } } for(inti=0;i<m;i++){ if(matrix[i][0]==0){ flag2=true; break; } } for(inti=1;i<m;i++){ for(intj=1;j<n;j++){ if(matrix[i][j]==0){ matrix[i][0]=0; matrix[0][j]=0; } } } for(inti=1;i<n;i++){ if(matrix[0][i]==0){ for(intj=0;j<m;j++){ matrix[j][i]=0; } } } for(intj=1;j<m;j++){ if(matrix[j][0]==0) { for(inti=0;i<n;i++){ matrix[j][i]=0; } } } if(flag1==true){ for(inti=0;i<n;i++){ matrix[0][i]=0; } } if(flag2==true){ for(inti=0;i<m;i++){ matrix[i][0]=0; } } } }; 2.官方层层递进的三个解法 官方解答点这里 总结 我想重点说一说原地算法是什么，因为百度上说的真的有点翻译腔的味道（懂得都懂） 维基百科定义： 在计算机科学中，一个原地算法（in-placealgorithm）基本上不需要额外辅助的数据结构（比如数组、栈，二叉树，堆等）,然而,允许少量额外的辅助变量来转换数据的算法。当算法运行时，输入的数据通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。 一句话总结就是:原地算法不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。 例题： 1、要将具有n项内容的数组a翻转过来。 解： 你可以在开辟一个数组的空间，然后将原数组copy过来；也可以用原地算法，可以直接在原数组上两两对换，只用o（1）的空间即可。 2、给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 解： 这个blog里面有详细代码 

leetcode 132模式（单调栈）+疯狂补丁 文章目录 前言一、题目是什么？二、使用步骤1.第一种极其暴力的解法2.修修补补的第二个解法3、官方解法 总结 前言 这道题我做的就是修修补补，其实就算我的第二个解法最后通过了101个测试例子，但是我还是怀疑是有bug的。这个代码反复提交了有14遍，针对遇到的不同的问题，我在代码上打了有针对性的补丁，完整直接的思路是没有的。 欢迎各位大佬来找bug。。。。。。小弟求之不得，铭感五内 一、题目是什么？ 题目点击这里 二、使用步骤 1.第一种极其暴力的解法 人家别人的暴力解法是o（n^2），我直接三个for循环，很快的，都不带动脑子……代码如下： classSolution{ public: boolfind132pattern(vector<int>&nums){ intn=nums.size(); if(n<3)returnfalse; for(inti=0;i<n;i++){ if(i+1<n){ for(intj=i+1;j<n;j++){ if(nums[i]<nums[j]){ if(j+1<n){ for(intk=j+1;k<n;k++){ if(nums[i]<nums[k]&&nums[k]<nums[j]) returntrue; } } } } } } returnfalse; } }; 提交的过程中，超时了，这大概是一个o（n^3）的解法，不过我觉得正确性是没什么可质疑的，简单直接 2.修修补补的第二个解法 代码如下： classSolution{ public: boolfind132pattern(vector<int>&nums){ intn=nums.size(); if(n<3)returnfalse; inti=0,temp; stack<int>s; s.push(nums[i]); i++; intfront=nums[0]; while(i<n&&!s.empty()){ if(i==n-1){//n-1特殊情况，后面没有可以比较的元素了 if(nums[i]>=s.top())returnfalse; else{ while(!s.empty()&&nums[i]<=s.top()){ s.pop(); } if(s.empty())returnfalse; elsereturntrue; } } if(i<n-1){//大餐开始了 if(nums[i]>=s.top()){ s.push(nums[i]); i++;//维护一个单调递增的栈 } else{//如果出现一个比栈顶元素小的元素 temp=i; while(i<n-1&&nums[i]<nums[i+1]&&i<n-1){//判断另一个单调栈， if(nums[i+1]<s.top()){ i++; } else{ break; } } //单调不下去了 if(i<n-1&&nums[i]>=nums[i+1]){ for(intj=i;j<n;j++){ if(nums[j]<s.top()&&nums[j]>front) returntrue; } } //出来有两种可能，一种i=n-1，一种比top（）大了 while(!s.empty()&&s.top()>=nums[i]){ s.pop(); } if(!s.empty())returntrue; else{ front=nums[temp]; for(intj=temp;j<=i;j++) s.push(nums[j]); i++; } } } } returnfalse; } }; 先说说大概思路吧： 维护一个单调递增的栈s，相当于认为栈底的是1，栈顶的是3，然后一旦遇到比3小的数（单调性被打破），执行以下操作： 从当前数开始，记最后找的元素为key，相当于维护了另一个隐形的单调递增的栈，分为3种情况： 1、一直单调递增到n-1，也就是尾端元素。这个时候啥也不说了，将key与栈内元素比较即可 2、单调递增到了一个比top大的元素那里，这个时候，这个元素之前的，就是key，将它和栈里面的元素比较。如果符合132模式，返回；否则，将这个隐形的单调栈压栈。 3、他不单调了，这个就比较麻烦了，这个我一开始没怎么细想，结果出bug了……出问题的测试例子是这个：[10,12,6,8,3,11]`。 我针对这个例子想了一个暴力方法：就是把top之后的元素，挨个与栈里面的1、3进行比较，看看存不存在132模式，如果存在，皆大欢喜；如果不存在，执行2操作。 3、官方解法 官方解法。。。 总结 有几个小技巧：1、多个判断条件，把判断合法类型的放在前面。不然容易出错，例如 while(!s.empty()&&s.top()>=nums[i]) if(i<n-1&&nums[i]>=nums[i+1]) 判断栈是否为空，数组角标是否越界这种合法性方面的条件放在前面。如果顺序颠倒，会出现bug，我就吃了好几次这样的亏。 2、不知道大家怎么样，反正我找边界条件其实很费劲，那种合法性的啊，n-1，n-2这种其实一开始我根本想不到，都是测试的时候发现了问题，之后慢慢加的。。。但是我觉得这些条件也很重要。 

Unbuntu下的cmake..执行出错 项目场景： unbuntu下安装edb-debugger 问题描述： unbuntu下面安装edb-debugger来看程序的虚拟内存，安装教程如下：首先安装依赖包，然后从github上面安装edb-debugger按步执行既可以 安装#installdependencies sudoapt-getinstallcmakebuild-essentiallibboost-dev\ libqt5xmlpatterns5-devqtbase5-devqt5-default\ libqt5svg5-devlibgraphviz-devlibcapstone-dev 安装#buildandrunedb sudoaptinstallgit gitclone--recursivehttps://github.com/eteran/edb-debugger.git cdedb-debugger mkdirbuild cdbuild cmake..如出错sudoapt-getinstall--reinstallpkg-configcmake-data make ./edb--run执行程序 但是在cmake的时候遇到了这个问题，这步不解决接下来的make执行不了。 原因分析and解决方案： 通过观察错误信息和查阅相关资料一个类似的问题原因应该是没有–init--recursive这两个文件，再重新clone一下就可以了。 执行gitsubmoduleupdate--init--recursive命令即可。 但是与网站不同的是，我执行完了之后还有一些错误提示但是神奇的是不影响之后的make命令和./edb命令了，也算是成功解决了吧。 

leetcode 从先序序列判断是否为二叉树（中等） 文章目录 一、题目是什么？二、解答1.我的解法2.官方解法 总结 哈哈哈，孩子高兴疯了，半个小时的时间编出代码，用时打败100%，内存打败87.91%，孩子从来打代码没有这么爽过。。。。。。 提示：这题感觉属于抖机灵那种，没什么编程技巧，代码量也不大 一、题目是什么？ 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录。 _9_ /\ 32 /\/\ 41#6 /\/\/\ ###### 例如，上面的二叉树可以被序列化为字符串“9,3,4,#,#,1,#,#,2,#,6,#,#”，其中#代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示null指针的‘#’。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如“1,3”。 示例1: 输入:“9,3,4,#,#,1,#,#,2,#,6,#,#”输出:true示例2: 输入:“1,#”输出:false示例3: 输入:“9,#,#,1”输出:false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 二、解答 1.我的解法 我的想法很简单，就是判断字符串里面#的个数是不是数字个数+1.在之前的离散数学，数据结构里，我记得这样一条性质，二叉树里面，度为0的节点（也就是本题的空节点）是度为2的节点的数目+1，具体证明就是算两次，找边和顶点直接的关系，在此就不赘述了。 然后在反复提交修改的过程中，加了三个细节： 1、数字可以为多位的 2、空树的判断 3、null=node（d=2）+1，更完善一些，一旦先序序列的前i个元素满足了上面的关系，此时，如果后面还有元素，这也不是一颗二叉树。 代码如下： classSolution{ public: boolisValidSerialization(stringpreorder){ intn=preorder.size(); intpre=0; inttree=0,node=0; if(preorder[0]=='#'&&n!=1)returnfalse;//空树判断 for(inti=0;i<n;i++){ if(preorder[i]=='#')node++; if(isdigit(preorder[i])&&pre!=i-1){//注意，这里的数字不一定是个位，要考虑到多位的情况 pre=i; tree++;} if(node==tree+1&&i!=n-1)returnfalse;//如果前面已经成树，那么后面就不可能再和前面组成一棵新的二叉树了 } if(node==tree+1)returntrue; elsereturnfalse; } }; 2.官方解法 让我小小的骄傲一下，此时我想大声的说一句话：你个垃圾！！！(心酸，这都是以前我看完官方代码之后对自己说的话，风水轮流转啊。。。嚣张ing) 官方思路：方法一：栈我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。 二叉树的建立也伴随着槽位数量的变化。 如果遇到了空节点，则要消耗一个槽位；如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。此外，还需要将根节点作为特殊情况处理。 我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处剩余槽位的数量，而栈顶元素就对应着下一步可用的槽位数量。当遇到空节点时，仅将栈顶元素减1；当遇到非空节点时，将栈顶元素减1后，再向栈中压入一个2。无论何时，如果栈顶元素变为0，就立刻将栈顶弹出。 遍历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽位数量不足，则序列不合法。 复杂度分析 时间复杂度：O(n)，其中n为字符串的长度。我们每个字符只遍历一次，同时每个字符对应的操作都是常数时间的。 空间复杂度：O(n)。此为栈所需要使用的空间。 方法二：计数能否将方法一的空间复杂度优化至O(1)呢？ 回顾方法一的逻辑，如果把栈中元素看成一个整体，即所有剩余槽位的数量，也能维护槽位的变化。 因此，我们可以只维护一个计数器，代表栈中所有元素之和，其余的操作逻辑均可以保持不变。 PS：个人感觉代码一直在数空槽位的个数 来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 方法二代码如下（示例）： classSolution{ public: boolisValidSerialization(stringpreorder){ intn=preorder.length(); inti=0; intslots=1; while(i<n){ if(slots==0){ returnfalse;//如果没有槽位了，但是还有元素，那么这个树就是错的啦 } if(preorder[i]==','){ i++; }elseif(preorder[i]=='#'){ slots--;//遇到空节点，槽位被占用 i++; }else{ //读一个数字 while(i<n&&preorder[i]!=','){ i++; } slots++;//slots=slots-1+2，遇到非空节点，槽位+1 } } returnslots==0;//判断条件哦 } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/yan-zheng-er-cha-shu-de-qian-xu-xu-lie-h-jghn/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结 本题有两种思路，一种就是我的想法，发掘二叉树的数学性质，找到判断二叉树的充要条件。一种就是官方的，找槽位，他没有深入挖掘二叉树的数学性质，但是想的很直接，只要没有槽位可以让节点填充，那么这个树就是false，然后维护一个计数器。其实这种想法更正统一般一些，有值得学习的地方。 

CSAPP大作业hello的一生 我的github仓库地址 

leecode 螺旋矩阵 文章目录 前言一、题目是什么？二、解答1.我的解答2.官方 总结 前言 提示：前两天leecode上面的题都是和hash映射有关，数据结构倒是讲了相关内容，但是孩子当时没有代码实践。。。总的来说，hash就是一种基于地址直接查找的算法，突破了传统的查找算法，比如，顺序查找，二分查找，B树查找之类的乱七八糟的查找的时间极限。学习了一下代码，倒是没有自己打。 提示：以下是本篇文章正文内容，本次代码思维量较少，还是考察代码功底，注意数组不要越界！ 一、题目是什么？ 给你一个m行n列的矩阵matrix，请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例1： 输入：matrix=[[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例2： 输入：matrix=[[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 二、解答 1.我的解答 大致思路是这样的，由于每次读一圈，规律都是相似的，所有考虑递归。本质上就是坐标（i,j）在边界上的循环。 值得注意的是，当写递归主函数的时候，有一些特殊情况要判断，比如只有一行，只有一列，只有两行，只有两列等等，避免重复。 本次代码用时，大概1：30分钟，中间debug主要是两个问题：1、递归函数传入参数的意义没有特别清楚，其实之前我还尝试过首坐标加行数之类的，但是写着写着自己就搞混了，导致了一些bug。 2、数组越界问题，我记得C语言里面，对于数组越界是没有专门的防护机制的，但是这个C++好像有哦（good！）出现了runtimeerror的问题，就是数组角标出现了-1之类的。 代码如下： classSolution{ public: vector<int>result; voidyouCanTry(vector<vector<int>>&matrix,inta,intb,intc,intd){ //a,b,行首(尾)坐标，c,d,列首（尾）坐标 if(b<a||d<c)return;//数组坐标越界检查，也是终止条件 if(b==a&&d==c){//只有一行一列 result.push_back(matrix[a][c]); return; } for(inti=c;i<=d;i++){ result.push_back(matrix[a][i]); //cout<<matrix[a][i]<<""; } if(b==a)return;//只有一行 for(inti=a+1;i<=b;i++){ //cout<<"wrong"; result.push_back(matrix[i][d]); //cout<<matrix[m-1][i]<<""; //向下 } if(d==c)return;//只有一列 for(inti=d-1;i>=c;i--){ result.push_back(matrix[b][i]); } //<- if(a==b-1)return;//只有两行 for(inti=b-1;i>a;i--){ result.push_back(matrix[i][c]); } youCanTry(matrix,a+1,b-1,c+1,d-1); } vector<int>spiralOrder(vector<vector<int>>&matrix){ intm=matrix.size();//行 intn=matrix[0].size();//列 youCanTry(matrix,0,m-1,0,n-1); returnresult; } }; 性能：执行用时：0ms,在所有C++提交中击败了100.00%的用户内存消耗：6.8MB,在所有C++提交中击败了42.19%的用户毕竟用了递归嘛，内存肯定是比纯循环要大的。 2.官方 leetcode官方解答<-点击这里官方解答很详细了，我总结一些就OK了，官解有两个，一个和我想的差不多，就是循环遍历矩阵，不过官方更厉害一点，他直接就是一个循环，而且代码写的也很漂亮！另一个是有点意思的，模拟：他规定了四个方向向量（注意，这个顺序也是有讲究的，符合这个螺旋方向的优先级）还有一个visited数组，标志是否当前节点被访问过。值得细细琢磨。 classSolution{ private: staticconstexprintdirections[4][2]={{0,1},{1,0},{0,-1},{-1,0}}; public: vector<int>spiralOrder(vector<vector<int>>&matrix){ if(matrix.size()==0||matrix[0].size()==0){ return{}; } introws=matrix.size(),columns=matrix[0].size(); vector<vector<bool>>visited(rows,vector<bool>(columns)); inttotal=rows*columns; vector<int>order(total); introw=0,column=0; intdirectionIndex=0; for(inti=0;i<total;i++){ order[i]=matrix[row][column]; visited[row][column]=true; intnextRow=row+directions[directionIndex][0],nextColumn=column+directions[directionIndex][1]; if(nextRow<0||nextRow>=rows||nextColumn<0||nextColumn>=columns||visited[nextRow][nextColumn]){//判断条件：越界，被访问过。 directionIndex=(directionIndex+1)%4; } //下一个方向向量一定就是了，如果不放心，可以把if改成while。 //我试了一下，改成while超出了时间限制，还是if把，因为它之前设的方向向量的顺序，就默认了下一个就是对的。 row+=directions[directionIndex][0]; column+=directions[directionIndex][1]; } returnorder; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结 好好学习，天天向上！！！多尝试，多实践！！！CSAPP我来了！！！ 

leetcode 不同的子序列（动态规划） 文章目录 前言一、题目二、解答1.我的超时方法2.答案的解答 总结 前言 字符串的动态规划问题，感觉找两个字符串之间的某种关系，比如最长公共子序列，回文序列之类的，都用到了动态规划。我记得floyd算法也是典型的动态规划问题。当初讲算法导论的时候，动态规划这里就听的迷迷糊糊的，我印象中好像就是填一个矩阵，这个矩阵有一些数很容易求，关键是找关系方程。实践倒是很少，这道题也算一个锻炼吧。 提示：代码大概20分钟打出来了，但是清晰的找到状态转移方程这个过程倒是摸索了很久，但是不幸的是，只用递归加状态转移方程超时了，因为有大量的重复计算。但是相同的思路，用上了动态规划，多了一步矩阵的转换和运算，就很好。 一、题目 给定一个字符串s和一个字符串t，计算在s的子序列中t出现的个数。字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE”是“ABCDE”的一个子序列，而“AEC”不是）题目数据保证答案符合32位带符号整数范围。 示例1： 输入：s=“rabbbit”,t=“rabbit”输出：3解释：如下图所示,有3种可以从s中得到“rabbit”的方案。(上箭头符号^表示选取的字母)rabbbit^^^^^^rabbbit^^^^^^rabbbit^^^^^^示例2： 输入：s=“babgbag”,t=“bag”输出：5解释：如下图所示,有5种可以从s中得到“bag”的方案。(上箭头符号^表示选取的字母)babgbag^^^babgbag^^^babgbag^^^babgbag^^^babgbag^^^ 提示： 0<=s.length,t.length<=1000s和t由英文字母组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/distinct-subsequences著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 二、解答 1.我的超时方法 解题思路“aabdbaabeeadcbbdedacbbeecbabebaeeecaeabaedadcbdbcdaabebdadbbaeabdadeaabbabbecebbebcaddaacccebeaeedababedeacdeaaaeeaecbe”“bddabdcae”这个测试用例，在leetcode上超出时间限制，自己用编译器打了一下，发现数是一样的，好难受。。。 大体的思路相当于是递归+发现状态转移方程s：a0a1…an-1t：b0b1…bm-1（1）如果a0！=b0，那么相当于对s：a1…an-1;t：b0b1…bm-1计算（2）如果a0==b0，分两种情况1、相当于对s：a1…an-1;t：b1…bm-1计算2、相当于对s：a1…an-1;t：b0b1…bm-1计算1、2加起来即可 代码如下： classSolution{ public: intnumDistinct(strings,stringt){ if(s.size()<t.size()||s.empty()||t.empty())return0; if(s.size()==t.size()&&s.compare(t)==0)return1; //if(s.size()==t.size()&&s.compare(t)!=0)return0; if(t.size()==1){ inti=0; intm=0; for(i=0;i<s.size();i++){ if(s[i]==t[0])m++; } returnm; } if(s.size()==1)returns[0]==t[0]; //终止条件 //递归主函数 if(s[0]!=t[0])returnnumDistinct(s.substr(1),t); elseif(s[0]==t[0])returnnumDistinct(s.substr(1),t.substr(1))+numDistinct(s.substr(1),t); elsereturn-1; } 2.答案的解答 leetcode官方解答很详细了，点击这里就好了 总结 状态转移方程结合动态规划使用更加哦，而且听说这还是一个典型的动态规划问题。。。。。。 

gcc编译32位代码出错 项目场景： vmware上的unbuntu终端，用gcc编译文件出错 问题描述： 前几天用vmware上的unbuntu终端，用gcc编译文件，出现了如下bug /usr/bin/ld:cannotfindScrt1.o:Nosuchfileordirectory /usr/bin/ld:cannotfindcrti.o:Nosuchfileordirectory /usr/bin/ld:skippingincompatible/usr/lib/gcc/x86_64-linux-gnu/9/libgcc.awhensearchingfor-lgcc /usr/bin/ld:cannotfind-lgcc /usr/bin/ld:skippingincompatible/usr/lib/x86_64-linux-gnu/libgcc_s.so.1whensearchingforlibgcc_s.so.1 /usr/bin/ld:cannotfindlibgcc_s.so.1 /usr/bin/ld:skippingincompatible/usr/lib/gcc/x86_64-linux-gnu/9/libgcc.awhensearchingfor-lgcc /usr/bin/ld:cannotfind-lgcc collect2:error:ldreturned1exitstatus 原因分析： 错误提示显示好几个文件都找不到，而且我之前用gcc编译文件也没有出现这个问题，-m32也用过。我上网查了很多办法，有的说要设置环境变量，有的说要重下（我之前其实下过）32位的包（一般下载的gcc默认是64位的），但是我试过，都没有用，气得我把unbuntu卸载了之后重装，发现还是一样的提示。 解决方案： 最后在stackflow上找到了答案https://stackoverflow.com/questions/6329887/compiling-problems-cannot-find-crt1-o（网站有时候不稳定，多试几次就OK） 只要执行这个命令，下载一个东西就可以正常编译了。 sudoaptinstallgcc-multilib stackflow解释：Theproblemisyoulikelyonlyhavethegccforyourcurrentarchitectureandthat’s64bit.Youneedthe32bitsupportfiles.Forthat,youneedtoinstallthem 

leetcode 栈 文章目录 前言一、题目是什么？二、解法1.我的解法 很简单的暴力算法2.官方解法 栈 总结 前言 抱怨两句：前两天leetcode上的每日一题都是找回文串子集之类的题目，对于菜鸟的我来说有点难，确实写了很久还有bug，题目难度分别为中等，困难。今天这道题是简单的，思路比较直接，代码也比较简洁 一、题目是什么？ 给出由小写字母组成的字符串S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在S上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 输入：“abbaca”输出：“ca”解释：例如，在“abbaca”中，我们可以删除“bb”由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串“aaca”，其中又只有“aa”可以执行重复项删除操作，所以最后的字符串为“ca”。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string 二、解法 1.我的解法 很简单的暴力算法 个人想的很简单，就是循环遍历字符串，每次遍历的时候看看有没有可以删除的字符对，结束判断条件就用一个flag标记就OK了另外一点，C++是没有数组越界检查的（CSAPP曰），所以本人非常怕越界出bug，在很多必要不必要的地方都加了一些越界检查代码如下： classSolution{ public: stringremoveDuplicates(stringS){ inti; if(S.size()==1)returnS;//简单情况单独判断 boolflag;//标记是否已经完成删除 do{ flag=false; i=0; while(i<S.size()){ if(S[i]==S[i+1]) {S.erase(i,2); flag=true; } else{ i++; } if(S.size()==1)returnS; } if(flag==false)//没有修改 break; } while(flag==true); returnS; } }; 作者：kolerk 链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/kan-lai-wo-zhi-neng-zuo-chu-lai-jian-dan-ugs5/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2.官方解法 栈 先说一下两个解法的不同吧，官方因为调用了栈，所有内存更多，但是时间变少了，只要o（n）即可，但是个人解法就是内存少，但是时间多，而且时间复杂度依赖于string结构。其实我看到栈这个字的时候，我瞬间就想到了 妙啊！只要将栈顶的元素和下一个元素比较就好了，相同就弹出；不同就压栈。数据结构，永远的神！代码如下： classSolution{ public: stringremoveDuplicates(stringS){ stringstk; for(charch:S){ if(!stk.empty()&&stk.back()==ch){ stk.pop_back(); }else{ stk.push_back(ch); } } returnstk; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/shan-chu-zi-fu-chuan-zhong-de-suo-you-xi-4ohr/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结 下一次做题，可以想想栈啊，队列啊，树啥的，傻循环确实有点low。。。 

leetcode 基础计算器（中等） 文章目录 前言一、题目是什么？二、解答1.我的解答2.官方 总结 前言 基础运算器，没有括号，只有加减乘除，运算数字不一定是只有一位的0~9，可能是多位。在提交了7遍之后，终于通过了。。。（大哭） 提示：本题思路及其简单直接，关键就是一些编程技巧，用得好可以简化代码 一、题目是什么？ 给你一个字符串表达式s，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。 示例1： 输入：s=“3+2*2”输出：7示例2： 输入：s="3/2"输出：1示例3： 输入：s="3+5/2"输出：5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/basic-calculator-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 注：虽然示例给的是个位数，但是题目要求是对于十进制数都可以的，要考虑如何把字符串转化为数字。 二、解答 1.我的解答 分析：先乘除，后加减。运算符号和数字分别压栈乘除：遍历一遍字符串：1、遇到space，直接跳过2、遇到数字，判断它到底有几位，利用ASCLL将字符串转化为longint整型(之前用过int整型，但是在测试中出现了溢出现象)3、遇到加减，符号压栈3、遇到*\，将这个符号前后两个数运算，将计算结果代替原来的top()。 加减：乘除中，我是在字符串从前往后这么遍历的，这就导致一个问题，之后进行加减运算的时候，还要把栈中元素的顺序reverse。所以我在想，从后往前，会不会节省内存，这样就不用在reverse栈了。 classSolution{ public: //第一遍先算乘除，第二遍算加减 // intcalculate(strings){ stack<longint>symbol;//储存运算符号 stack<int>num; stack<longint>symbol1;//储存运算符号 stack<int>num1; intn=s.size(); longinttemp=0;//溢出 longinthelp=0; inti=0,j=-1; //先乘除 while(i<n){ if(s[i]==32)i++; elseif(s[i]>='0'&&s[i]<='9'){ if(j==i-1&&j!=-1){ temp=num.top(); num.pop(); temp=temp*10+s[i]-'0'; num.push(temp); j=i; i++;//考虑一下十位数 } else{ num.push(s[i]-'0'); j=i; i++; } } elseif(s[i]==43){//+ symbol.push(1); i++; } elseif(s[i]==45){//- symbol.push(-1); i++; } elseif(s[i]==42){//* temp=num.top(); num.pop(); j=1; while(s[i+j]==32)j++; i=i+j;//开始下一个数 help=0; while(s[i]>='0'&&s[i]<='9'){ help=help*10+s[i]-'0'; i++; } temp=temp*help; num.push(temp); } elseif(s[i]==47){/// temp=num.top(); num.pop(); j=1; while(s[i+j]==32)j++; i=i+j;//开始下一个数 help=0; while(s[i]>='0'&&s[i]<='9'){ help=help*10+s[i]-'0'; i++; } temp=temp/help; num.push(temp); } else{ cout<<"wrong!"<<endl; } } while(!symbol.empty()){ symbol1.push(symbol.top()); symbol.pop(); } while(!num.empty()){ num1.push(num.top()); num.pop(); } //后加减 while(!symbol1.empty()){ if(symbol1.top()==1){ temp=num1.top(); num1.pop(); temp=temp+num1.top(); num1.pop(); num1.push(temp); symbol1.pop(); } elseif(symbol1.top()==-1){ temp=num1.top(); num1.pop(); temp=temp-num1.top(); num1.pop(); num1.push(temp); symbol1.pop(); } else{ cout<<"wrong!"<<endl; } } temp=num1.top(); returntemp; } }; 2.官方 由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值。 基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。 具体来说，遍历字符串ss，并用变量\textit{preSign}preSign记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据\textit{preSign}preSign来决定计算方式： 加号：将数字压入栈；减号：将数字的相反数压入栈；乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新preSign为当前遍历的字符。 遍历完字符串s后，将栈中元素累加，即为该字符串表达式的值。 作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/basic-calculator-ii/solution/ji-ben-ji-suan-qi-ii-by-leetcode-solutio-cm28/来源：力扣（LeetCode） 优点：将加减统一为加（减去相反数）。减少内存和时间。 classSolution{ public: intcalculate(strings){ vector<int>stk; charpreSign='+'; intnum=0; intn=s.length(); for(inti=0;i<n;++i){ if(isdigit(s[i])){//专门判断数字的函数 num=num*10+int(s[i]-'0'); } if(!isdigit(s[i])&&s[i]!=''||i==n-1){//判断符号,多个判断条件一起考虑 //排除space，确定终止条件 switch(preSign){ case'+': stk.push_back(num); break; case'-': stk.push_back(-num); break; case'*': stk.back()*=num; /*temp=stk.top(); stk.pop(); temp=temp*num; stk.push(temp); */ break; default: stk.back()/=num; } preSign=s[i]; num=0; } } returnaccumulate(stk.begin(),stk.end(),0);//另一个高级函数，计算栈里面的元素之和 } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/basic-calculator-ii/solution/ji-ben-ji-suan-qi-ii-by-leetcode-solutio-cm28/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结 之前学习数据结构的时候，在栈的应用那一节，详细讲了如何通过栈进行四则运算，记得还有专门的后缀，前缀写法。现在都已经忘得七七八八了，只记得如果遇到右括号，就一直弹栈，直到弹到第一个左括号为止。但是面对千奇百怪的问题变形，记得理论什么的可能也没多大用了，一些基本的思想，包括实践的经验还有待慢慢积累练习。。。。。。 

leetcode 单调栈 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档 文章目录 题目一、我的代码二、看了答案之后我悟了1.先上官方代码2.我的解读单调栈是什么？ 总结 题目 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字x的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出-1。 示例1:输入:[1,2,1]输出:[2,-1,2]解释:第一个1的下一个更大的数是2；数字2找不到下一个更大的数；第二个1的下一个最大的数需要循环搜索，结果也是2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/next-greater-element-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 提示：以下是本篇文章正文内容，下面案例可供参考 一、我的代码 思路很简单，就是两个循环便利，既然找后一个大的，我就一直往后找嘛，可以说是暴力算法 classSolution{ public: vector<int>nextGreaterElements(vector<int>&nums){ vector<int>res; if(nums.empty())returnnums; intlen=nums.size(); inti,j; for(i=0;i<len;i++){ j=(i+1)%len; while(nums[j]<=nums[i]){ if(j==i){ res.push_back(-1); break; } else { j=(j+1)%len; } } if(j!=i) res.push_back(nums[j]); } returnres; } }; 二、看了答案之后我悟了 1.先上官方代码 代码如下（示例）： classSolution{ public: vector<int>nextGreaterElements(vector<int>&nums){ intn=nums.size(); vector<int>ret(n,-1); stack<int>stk; for(inti=0;i<n*2-1;i++){ while(!stk.empty()&&nums[stk.top()]<nums[i%n]){ ret[stk.top()]=nums[i%n]; stk.pop(); } stk.push(i%n); } returnret; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/next-greater-element-ii/solution/xia-yi-ge-geng-da-yuan-su-ii-by-leetcode-bwam/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2.我的解读 代码如下（示例）： 思路是单调栈+一次循环我是这样想的：你看，在我们之前的暴力算法的时候，是不是有一些重复的比较，比如a>b>c但是他们之后的d比a还要大，那么a，b，c的后一个最大不就都是d了，这样就省去了b和c的比较。所以基于这个小发现，我们想到了单调栈这个高级名词， 单调栈是什么？ 就是这个栈的栈底到栈顶的元素都是单调的，在本题里面，就是单调不升。这样当你遇到了一个命中注定的d之后，就可以把栈里面的元素都弹出，他们对应的元素都是d了。另外，对于循环这个东西，在数组后面复制前面的n-1个元素就可以了，官方说这是把数组拉直，其实就是取模（哭） 该处使用的url网络请求的数据。 总结 好久没有打代码了，手都生了，好多之前的语法之类的都忘的差不多了，比如vector，stack等基本操作，bug也出的莫名其妙，居然是数组名写串了。。。新学期，希望可以坚持刷题 leetcode每日一题之单调栈 题目一、我的代码二、看了答案之后我悟了1.先上官方代码2.我的解读单调栈是什么？ 总结 

软构复习【5】 

【软构课堂笔记3：面向对象编程】 

CSAPP2021helloP2P 计算机系统 大作业 题目*程序人生-Hello’sP2P* 专业*计算机科学与技术* 学 号*1190301804* 班 级*1936602* 学生*梁成 * 指导教师*刘宏伟 * 计算机科学与技术学院 2021年6月 [[]{#_Toc250450163.anchor}]{#_Toc225579639.anchor}摘要 hello’P2P介绍了hello.c程序从诞生到结束的全过程，包括预处理、编译、汇编、链接、进程等。我们主要使用gcc,edb,gdb等工具在linus下对hello进行一系列操作和分析，在这个过程中搭建起了认识计算机底层的框架，加深对CSAPP课本知识点的理解。 **关键词：**hello；P2P；计算机系统；Ubuntu；CSAPP； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） **** 目录 第1章概述-5- 1.1.Hello简介-5- 1.2.环境与工具-5- 1.3.中间结果-5- 1.4.本章小结-5- 第2章预处理-7- 2.1.预处理的概念与作用-7- 2.2.在Ubuntu下预处理的命令-7- 2.3.Hello的预处理结果解析-7- 2.4.本章小结-8- 第3章编译-9- 3.1.编译的概念与作用-9- 3.2.在Ubuntu下编译的命令-9- 3.3.Hello的编译结果解析-10- 3.3.1.文件声明解析-10- 3.3.2.数据与赋值解析-10- 3.3.3.算术操作-11- 3.3.4.关系操作与转移控制-11- 3.3.5.数组/指针/结构操作-11- 3.3.6.函数操作-12- 3.3.7.类型转换-13- 3.4.本章小结-13- 第4章汇编-14- 4.1.汇编的概念与作用-14- 4.2.在Ubuntu下汇编的命令-14- 4.3.可重定位目标elf格式-14- 4.3.1.获取ELF文件的命令-14- 4.3.2.ELF文件结构：-15- 4.3.3.ELFHeader-15- 4.3.4.SectionHeader-16- 4.3.5.重定位节-16- 4.3.6.符号表-17- 4.4.Hello.o的结果解析-18- 4.5.本章小结-19- 第5章链接-21- 5.1.链接的概念与作用-21- 5.2.在Ubuntu下链接的命令-21- 5.3.可执行目标文件hello的格式-21- 5.4.hello的虚拟地址空间-23- 5.5.链接的重定位过程分析-25- 5.5.1.hello相对hello.o的内容变化-25- 5.5.2.链接的过程-27- 5.6.hello的执行流程-27- 5.7.Hello的动态链接分析-28- 5.8.本章小结-29- 第6章hello进程管理-30- 6.1.进程的概念与作用-30- 6.2.简述壳Shell-bash的作用与处理流程-30- 6.3.Hello的fork进程创建过程-30- 6.4.Hello的execve过程-31- 6.5.Hello的进程执行-31- 6.6.hello的异常与信号处理-32- 6.7.本章小结-35- 第7章hello的存储管理-36- 7.1.hello的存储器地址空间-36- 7.2.Intel逻辑地址到线性地址的变换-段式管理-36- 7.3.Hello的线性地址到物理地址的变换-页式管理-37- 7.4.TLB与四级页表支持下的VA到PA的变换-39- 7.5.三级Cache支持下的物理内存访问-40- 7.6.hello进程fork时的内存映射-41- 7.7.hello进程execve时的内存映射-41- 7.8.缺页故障与缺页中断处理-42- 7.9.动态存储分配管理-43- 7.10.本章小结-45- 第8章hello的IO管理-46- 8.1.Linux的IO设备管理方法-46- 8.2.简述UnixIO接口及其函数-46- 8.3.printf的实现分析-47- 8.4.getchar的实现分析-49- 8.5.本章小结-49- 第9章结论-50- 第10章附件-51- 第11章参考文献-52- 概述 Hello简介 P2P过程：将hello.c经过预处理->编译->汇编->链接四个步骤生成hello的二进制可执行文件，在shell中为其fork出进程并执行。 020过程：shell开始执行并为其映射出虚拟内存，然后在开始运行进程的时候分配并载入物理内存，开始执行hello的程序，将output显示到屏幕，最后hello进程结束，shell回收内存空间。 环境与工具 硬件环境：处理器：Intel®Core™i7-8550UCPU@1.80GHz1.99GHz RAM：8.00GB系统类型：64位操作系统，基于x64的处理器 软件环境：Windows1064位；Ubuntu19.04 开发与调试工具：gcc，as，ld，vim，edb，readelf，VS 中间结果 文件的作用文件名*预处理后的文件hello.i*编译之后的汇编文件hello.s*汇编之后的可重定位目标文件hello.o*链接之后的可执行目标文件Hello*Hello.o的ELF格式elf.txt*Hello.o的反汇编代码disassemble_hello.s*hello的ELF格式helloELF.elfhello的反汇编代码disassemble_hello_o.s 本章小结 本章主要介绍了hello的P2P，020过程，以及进行实验时的软硬件环境及开发与调试工具和在本论文中生成的中间结果文件。 （第1章0.5分） 预处理 预处理的概念与作用 预处理概念： 预处理以展开的#开头，试图解释为预处理指令。其中ISOC/C++要求支持的包括#if、#ifdef、#ifndef、#else、#elif、#endif（条件编译）、#define（宏定义）、#include（源文件包含）、#line（行控制）、#error（错误指令）、#pragma（和实现相关的杂注）以及单独的#（空指令）。预处理指令一般被用来使源代码在不同的执行环境中被方便的修改或者编译 预处理作用： 将源文件中用#include形式声明的文件复制到新的程序中。比如hello.c第6-8行中的#include<stdio.h>等命令告诉预处理器读取系统头文件stdio.hunistd.hstdlib.h的内容，并把它直接插入到程序文本中。特殊符号，预编译程序可以识别一些特殊的符号，预编译程序对于在源程序中出现的这些串将用合适的值进行替换。用实际值替换用#define定义的字符串根据#if后面的条件决定需要编译的代码 在Ubuntu下预处理的命令 命令：cpphello.c>hello.i [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3tz6vfao-1623927515230)(media/image2.png)]{width=“5.340972222222222in”height=“0.2048611111111111in”} 图1cpp命令 Hello的预处理结果解析 预处理器（cpp）根据以字符#开头的命令，修改原始的c程序。比如hello.c中第1行的#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并将它直接插入到程序文本中。 打开hello.i，原来以#开头的行发生了扩展。总内容扩展到了3065行，而hello.c的内容出现在3046行，在其之前的内容是#号对应宏展开(stdio.h,unistd.h,stdlib.h)。 本章小结 本章主要介绍了预处理（包括头文件的展开、宏替换、去掉注释、条件编译）的概念和应用功能，以及Ubuntu下预处理的两个指令，同时具体到我们的hello.c文件的预处理结果hello.i文本文件解析，详细了解了预处理的内涵 （第2章0.5分） 编译 编译的概念与作用 编译的概念： 编译阶段将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级程序机器语言指令。 编译包括以下基本流程： 语法分析：编译程序的语法分析器以单词符号作为输入，分析单词符号串是否形成符合语法规则的语法单位，方法分为两种：自上而下分析法和自下而上分析法。中间代码：源程序的一种内部表示，或称中间语言。中间代码的作用是可使编译程序的结构在逻辑上更为简单明确，特别是可使目标代码的优化比较容易实现中间代码。代码优化：指对程序进行多种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。目标代码：生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。此处指汇编语言代码，须经过汇编程序汇编后，成为可执行的机器语言代码。 编译的作用： 它把高级语言翻译成更接近机器语言的汇编语言，使生成过程更加方便顺畅，以便机器读取。还具有语法检查，调试措施，修改手段。 在Ubuntu下编译的命令 命令：gcc-Shello.i-ohello.s [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XskExuND-1623927515231)(media/image3.png)]{width=“5.280555555555556in”height=“0.25in”} 图2gcc命令 Hello的编译结果解析 文件声明解析 声明含义.file源文件.text代码段.data数据段，存储已初始化的全局和静态c变量.align对齐格式.type符号类型.size数据空间大小.sectionrodata只读代码段.global全局变量.string字符串类型数据.long长整型数据 数据与赋值解析 全局变量 定义sleepsecs全局变量在汇编文件中sleepsecs的内容 intsleepsecs=2.5;.text .globlsleepsecs .data .align4 .typesleepsecs,@object .sizesleepsecs,4 .globl声明了这是一个全局变量；.type说明了类型是一个数据；.size说明了这个变量的大小，这里sleepsecs变量占了4个字节 常量 printf打印字符串字符串内容保存 printf(“Usage:Hello学号姓名！\n”);.LC0: printf(“Hello%s%s\n”,argv[1],argv[2]);.string“Usage:Hello\345\255\246\345\217\267\345\247\223\345\220\215\357\274\201” .LC1: .string"Hello%s%s\\n" printf()函数的字符串常量被存储在.rodata节中 局部变量 初始化i=0将0存入-4(%rbp)处 for(i=0;i<10;i++).L2: movl\$0,-4(%rbp) jmp.L3 局部变量存储在寄存器或者栈中。 在这里局部变量i被存储在-4(%rbp)处。 算术操作 循环过程的自加操作addl操作，栈上存储的变量+1 for(i=0;i<10;i++)addl$1,-4(%rbp) cmpl\$9,-4(%rbp) jle.L4 关系操作与转移控制 判断参数argc是否小于4cmpl操作 if(argc!=3)cmpl\$3,-20(%rbp) je.L2 循环过程中判断i是否<10cmpl操作 for(i=0;i<10;i++)cmpl$9,-4(%rbp) jle.L4 利用cmpl操作和je指令，实现转移控制 数组/指针/结构操作 字符指针数组char*argv[]:存储用户输入的命令行信息地址 argv[0]指向输入程序的路径与名称，argv[1]argv[2]指向字符串（学号/姓名） 该数组中每个元素大小为8bit，argv既是数组名也是数组的首地址 main函数中访问数组元素argv[1],argv[2]时，按照起始地址argv大小8B计算数据地址取数据，在hello.s中，使用两次(%rax)（两次rax分别为argv[1]和argv[2]的地址）取出其值。 如下图： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bWM4ispI-1623927515233)(media/image4.png)]{width=“3.1590277777777778in”height=“0.8715277777777778in”} 图3main函数的参数 函数操作 函数是一种过程，过程提供了一种封装代码的方式，用一组指定的参数和可选的返回值实现某种功能。P中调用函数Q包含以下动作： 1）传递控制：进行过程Q的时候，程序计数器必须设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。 2）传递数据：P必须能够向Q提供一个或多个参数，Q必须能够向P中返回一个值。 3）分配和释放内存：在开始时，Q可能需要为局部变量分配空间，而在返回前，必须释放这些空间。 X86-64中,过程调用传递参数规则： 第1~6个参数一次储存在%rdi、%rsi、%rdx、%rcx、%r8、%r9这六个寄存器中，剩下的参数保存在栈当中。 main() 传递控制：被系统启动函数调用。 传递数据：传入参数argc和argv[]，分别用寄存器%rdi和%rsi存储。 返回内容：设置%eax为0并且返回，对应return0 printf() printf(“Usage:Hello学号姓名！\n”);leaq.LC0(%rip),%rdi callputs@PLT 传递控制：if判断满足条件后调用 传递数据：callputs时只传入了字符串参数的首地址；（%rdi） printf(“Hello%s%s\n”,argv[1],argv[2]);.L4: movq-32(%rbp),%rax addq\$16,%rax **movq**(%rax),%rdx*//第三个参数：获得argv\[1\]的内容* movq-32(%rbp),%rax addq\$8,%rax **movq**(%rax),%rax movq%rax,%rsi*//第二个参数：传入参数argv\[2\]* leaq.**LC1**(%rip),%rdi*//第一个参数：.LC1的首地址* movl\$0,%eax callprintf@PLT 传递控制：在for循环中调用 传递数据：callprintf时还传入了argv[1]和argv[2]的地址。(%rsi%rdx) exit() 传递控制：在if判断满足后调用 传递数据：传入参数为1（%edi） exit(1);movl$1,%edi callexit@PLT sleep() 传递控制：在循环内部用 传递数据：传入sleepsecs（%edi） sleep(sleepsecs);movl%eax,%edi callsleep@PLT getchar() getchar();callgetchar@PLT 类型转换 程序中涉及隐式类型转换的是： intsleepsecs=2.5; 当在double或float向int进行类型转换的时候，程序改变数值和位模式的原则是：值会向零舍入。例如1.999将被转换成1，-1.999将被转换成-1。进一步来讲，可能会产生值溢出的情况，与Intel兼容的微处理器指定位模式[10…000]为整数不确定值，一个浮点数到整数的转换，如果不能为该浮点数找到一个合适的整数近似值，就会产生一个整数不确定值。 浮点数默认类型为double，所以上述强制转化是double强制转化为int类型。遵从向零舍入的原则，将2.5舍入为2。 本章小结 本章主要介绍了编译的概念与作用，同时通过对hello.s汇编代码的分析，分析了C语言的各个数据类型与操作在汇编代码中的实现。 通过本章内容，我更深刻地理解了C语言与汇编语言之间的关系，也进一步熟悉了汇编代码，理解了编译的概念。 汇编 汇编的概念与作用 概念 驱动程序运行汇编器as，将汇编语言（hello.s）翻译成机器语言（hello.o）的过程称为汇编。 （hello.o也是可重定位目标文件） 作用 将高级语言转化为机器可直接识别执行的代码文件：将.s汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序格式并保存在.o二进制文件中。 在Ubuntu下汇编的命令 Linus>ashello.s-ohello.o [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OZm7AQ4k-1623927515234)(media/image5.png)]{width=“4.310416666666667in”height=“0.9923611111111111in”} 图4as命令获取hello.o 可重定位目标elf格式 获取ELF文件的命令 Linus>readelf-ahello.o>./elf.txt获得ELF.txt文件 ELF文件结构： 如图，夹在ELF头和节头部表之间的都是节，ELF中存储了很多不同的节的信息，每一个节中保存了程序中对应的一些变量或者重定位等这些信息。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-cCv4D1TI-1623927515235)(media/image6.png)] 图5ELF文件结构 ELFHeader 从16B的序列Magic开始，Magic描述了生成该文件的系统的字的大小和字节顺序，ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型、字节头部表（sectionheadertable的文件偏移，以及节头部表中条目的大小和数量等信息。 ELFHeader: Magic:7f454c46020101000000000000000000 Class:ELF64 Data:2’scomplement,littleendian Version:1(current) OS/ABI:UNIX-SystemV ABIVersion:0 Type:REL(Relocatablefile) Machine:AdvancedMicroDevicesX86-64 Version:0x1 Entrypointaddress:0x0 Startofprogramheaders:0(bytesintofile) Startofsectionheaders:1232(bytesintofile) Flags:0x0 Sizeofthisheader:64(bytes) Sizeofprogramheaders:0(bytes) Numberofprogramheaders:0 Sizeofsectionheaders:64(bytes) Numberofsectionheaders:14 Sectionheaderstringtableindex:13 SectionHeader 节头部表描述不同节的位置和大小，目标文件中1每个节都有一个固定大小的条目，相关信息包括节的名称，类型，地址，偏移量，对齐，旗标等 SectionHeaders: [Nr]NameTypeAddressOffset SizeEntSizeFlagsLinkInfoAlign [0]NULL000000000000000000000000 00000000000000000000000000000000000 [1].textPROGBITS000000000000000000000040 00000000000000850000000000000000AX001 [2].rela.textRELA000000000000000000000380 00000000000000c00000000000000018I1118 [3].dataPROGBITS0000000000000000000000c8 00000000000000040000000000000000WA004 [4].bssNOBITS0000000000000000000000cc 00000000000000000000000000000000WA001 [5].rodataPROGBITS0000000000000000000000cc 000000000000002b0000000000000000A001 [6].commentPROGBITS0000000000000000000000f7 000000000000002b0000000000000001MS001 [7].note.GNU-stackPROGBITS000000000000000000000122 00000000000000000000000000000000001 [8].note.gnu.propertNOTE000000000000000000000128 00000000000000200000000000000000A008 [9].eh_framePROGBITS000000000000000000000148 00000000000000380000000000000000A008 [10].rela.eh_frameRELA000000000000000000000440 00000000000000180000000000000018I1198 [11].symtabSYMTAB000000000000000000000180 00000000000001b0000000000000001812108 [12].strtabSTRTAB000000000000000000000330 000000000000004d0000000000000000001 [13].shstrtabSTRTAB000000000000000000000458 00000000000000740000000000000000001 KeytoFlags: W(write),A(alloc),X(execute),M(merge),S(strings),I(info), L(linkorder),O(extraOSprocessingrequired),G(group),T(TLS), C(compressed),x(unknown),o(OSspecific),E(exclude), l(large),p(processorspecific) 从节头部表中我们得知，hello.o一共有13个节。 重定位节 表述了各个段引用的外部符号等。在链接时，需要通过重定位节对这些位置的地址进行修改。链接器会通过重定位条目的类型通过偏移量等信息计算出正确的地址。 Relocationsection‘.rela.text’atoffset0x380contains8entries: OffsetInfoTypeSym.ValueSym.Name+Addend 00000000001c000500000002R_X86_64_PC320000000000000000.rodata-4 000000000021000d00000004R_X86_64_PLT320000000000000000puts-4 00000000002b000e00000004R_X86_64_PLT320000000000000000exit-4 000000000054000500000002R_X86_64_PC320000000000000000.rodata+1a 00000000005e000f00000004R_X86_64_PLT320000000000000000printf-4 000000000064000a00000002R_X86_64_PC320000000000000000sleepsecs-4 00000000006b001000000004R_X86_64_PLT320000000000000000sleep-4 00000000007a001100000004R_X86_64_PLT320000000000000000getchar-4 Relocationsection‘.rela.eh_frame’atoffset0x440contains1entry: OffsetInfoTypeSym.ValueSym.Name+Addend 000000000020000200000002R_X86_64_PC320000000000000000.text+0 以上8条重定位信息分别是对.L0（第一个printf中的字符串）、puts函数、exit函数、.L1（第二个printf中的字符串）、printf函数、sleepsecs、sleep函数、getchar函数进行重定位声明。 Offset需要修改的引用的节偏移Info包括symbol和type两部分，其中symbol占前4个字节，type占后4个字节，symbol代表重定位到的目标在.symtab中的偏移量，type代表重定位的类型Type重定位到的目标的类型Sys.value重定向到的目标的名称Sys.Name+addend计算重定位位置的辅助信息，共占8个字节 符号表 .symtab是一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。 Symboltable‘.symtab’contains18entries: Num:ValueSizeTypeBindVisNdxName 0:00000000000000000NOTYPELOCALDEFAULTUND 1:00000000000000000FILELOCALDEFAULTABShello.c 2:00000000000000000SECTIONLOCALDEFAULT1 3:00000000000000000SECTIONLOCALDEFAULT3 4:00000000000000000SECTIONLOCALDEFAULT4 5:00000000000000000SECTIONLOCALDEFAULT5 6:00000000000000000SECTIONLOCALDEFAULT7 7:00000000000000000SECTIONLOCALDEFAULT8 8:00000000000000000SECTIONLOCALDEFAULT9 9:00000000000000000SECTIONLOCALDEFAULT6 10:00000000000000004OBJECTGLOBALDEFAULT3sleepsecs 11:0000000000000000133FUNCGLOBALDEFAULT1main 12:00000000000000000NOTYPEGLOBALDEFAULTUND\_GLOBAL\_OFFSET\_TABLE\_ 13:00000000000000000NOTYPEGLOBALDEFAULTUNDputs 14:00000000000000000NOTYPEGLOBALDEFAULTUNDexit 15:00000000000000000NOTYPEGLOBALDEFAULTUNDprintf 16:00000000000000000NOTYPEGLOBALDEFAULTUNDsleep 17:00000000000000000NOTYPEGLOBALDEFAULTUNDgetchar Hello.o的结果解析 执行objdump-d-rhello.o>disassemble_hello.s，得到hello.o的反汇编如下： hello.o:fileformatelf64-x86-64 Disassemblyofsection.text: 0000000000000000<main>: 0:f30f1efaendbr64 4:55push%rbp 5:4889e5mov%rsp,%rbp 8:4883ec20sub$0x20,%rsp c:897decmov%edi,-0x14(%rbp) f:488975e0mov%rsi,-0x20(%rbp) 13:837dec03cmpl$0x3,-0x14(%rbp) 17:7416je2f<main+0x2f> 19:488d3d00000000lea0x0(%rip),%rdi#20<main+0x20> 1c:R\_X86\_64\_PC32.rodata-0x4 20:e800000000callq25<main+0x25> 21:R\_X86\_64\_PLT32puts-0x4 25:bf01000000mov$0x1,%edi 2a:e800000000callq2f<main+0x2f> 2b:R\_X86\_64\_PLT32exit-0x4 2f:c745fc00000000movl$0x0,-0x4(%rbp) 36:eb3bjmp73<main+0x73> 38:488b45e0mov-0x20(%rbp),%rax 3c:4883c010add$0x10,%rax 40:488b10mov(%rax),%rdx 43:488b45e0mov-0x20(%rbp),%rax 47:4883c008add$0x8,%rax 4b:488b00mov(%rax),%rax 4e:4889c6mov%rax,%rsi 51:488d3d00000000lea0x0(%rip),%rdi#58<main+0x58> 54:R\_X86\_64\_PC32.rodata+0x1a 58:b800000000mov$0x0,%eax 5d:e800000000callq62<main+0x62> 5e:R\_X86\_64\_PLT32printf-0x4 62:8b0500000000mov0x0(%rip),%eax#68<main+0x68> 64:R\_X86\_64\_PC32sleepsecs-0x4 68:89c7mov%eax,%edi 6a:e800000000callq6f<main+0x6f> 6b:R\_X86\_64\_PLT32sleep-0x4 6f:8345fc01addl$0x1,-0x4(%rbp) 73:837dfc09cmpl$0x9,-0x4(%rbp) 77:7ebfjle38<main+0x38> 79:e800000000callq7e<main+0x7e> 7a:R\_X86\_64\_PLT32getchar-0x4 7e:b800000000mov$0x0,%eax 83:c9leaveq 84:c3retq 与第三章的hello.s对照主要差别如下： 分支转移函数 反汇编结果hello.s17:7416je2f<main+0x2f>je.L2 反汇编代码中可以看出相对偏移地址取代了hello.s中的标志位。反汇编代码跳转指令的操作数使用的不是段名称如.L2，因为段名称只是在汇编语言中便于编写的助记符，所以在汇编成机器语言之后显然不存在，而是确定的地址。 函数调用 反汇编结果hello.s 6a:e800000000callq6f&lt;main+0x6f&gt;callsleep@PLT 6b:R\_X86\_64\_PLT32sleep-0x4 在hello.s文件中，函数调用之后直接跟着函数名称，而在反汇编程序中，call的目标地址是当前下一条指令。 这是因为hello.c中调用的函数都是共享库中的函数，最终需要通过动态链接器才能确定函数的运行时执行地址，在汇编成为机器语言的时候，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全0（目标地址正是下一条指令），然后在.rela.text节中为其添加重定位条目，等待静态链接的进一步确定。 全局变量访问 反汇编结果 62:8b0500000000mov0x0(%rip),%eax\#68&lt;main+0x68&gt; 64:R\_X86\_64\_PC32sleepsecs-0x4 hello.s movq-32(%rbp),%rax addq\$8,%rax 在hello.s文件中对于全局变量的访问为LC0和sleepsecs（%rip）,而在反汇编代码中是$0x0和0（%rip），原因与函数调用一样，全局变量的地址也是在运行时才确定，访问也需要经过重定位。 进制表示 反汇编结果hello.s 43:488b45e0mov-0x20(%rbp),%raxmovq-32(%rbp),%rax 47:4883c008add\$0x8,%raxaddq\$8,%rax 反汇编后用16进制，hello.s用的是十进制。 本章小结 经过汇编过程后，hello.s被汇编器变为hello.o文件,此时hello.o已经是可以被机器读懂的二进制文件了。hello.o可重定位目标文件也为后面进行链接做好了准备。但是此时的hello仍然不能“上岗工作”，还需要进行最后一步链接才能变为可以被系统执行的可执行文件。 通过反汇编hello.o并与之前的hello.s进行比较，我进一步了解了汇编代码和机器代码之间的区别和联系。 （第4章1分） 链接 链接的概念与作用 链接的概念 链接是将各种不同文件的代码和数据部分收集（符号解析和重定位）起来并组合成一个单一文件的过程。 链接的作用 令源程序节省空间而未编入的常用函数文件（如printf.o）进行合并，生成可以正常工作的可执行文件。这令分离编译成为可能，节省了大量的工作空间。 在Ubuntu下链接的命令 执行命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 得到hello的可执行目标文件 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3eyx8Dwz-1623927515236)(media/image7.png)]{width=“5.901388888888889in”height=“1.6284722222222223in”} 图6链接得到hello的可执行文件 可执行目标文件hello的格式 使用命令:**readelf-ahello>helloELF.elf** ELFheader ELFHeader: Magic:7f454c46020101000000000000000000 Class:ELF64 Data:2’scomplement,littleendian Version:1(current) OS/ABI:UNIX-SystemV ABIVersion:0 Type:EXEC(Executablefile) Machine:AdvancedMicroDevicesX86-64 Version:0x1 Entrypointaddress:0x4010d0 Startofprogramheaders:64(bytesintofile) Startofsectionheaders:14200(bytesintofile) Flags:0x0 Sizeofthisheader:64(bytes) Sizeofprogramheaders:56(bytes) Numberofprogramheaders:12 Sizeofsectionheaders:64(bytes) Numberofsectionheaders:27 Sectionheaderstringtableindex:26 SectionHeader SectionHeader中包含了各节的名称，类型，地址，偏移量等信息。 可以看出此时节的数目由hello.o的14个增加到了27个，说明在链接过后有很多文件有添加进来。 Address：该节的虚拟地址（绝对地址） Offset：该节在程序中地址的偏移量（相对地址） SectionHeaders: [Nr]NameTypeAddressOffset SizeEntSizeFlagsLinkInfoAlign [0]NULL000000000000000000000000 00000000000000000000000000000000000 [1].interpPROGBITS00000000004002e0000002e0 000000000000001c0000000000000000A001 [2].note.gnu.propertNOTE000000000040030000000300 00000000000000200000000000000000A008 [3].note.ABI-tagNOTE000000000040032000000320 00000000000000200000000000000000A004 [4].hashHASH000000000040034000000340 00000000000000340000000000000004A608 [5].gnu.hashGNU_HASH000000000040037800000378 000000000000001c0000000000000000A608 [6].dynsymDYNSYM000000000040039800000398 00000000000000c00000000000000018A718 [7].dynstrSTRTAB000000000040045800000458 00000000000000570000000000000000A001 [8].gnu.versionVERSYM00000000004004b0000004b0 00000000000000100000000000000002A602 [9].gnu.version_rVERNEED00000000004004c0000004c0 00000000000000200000000000000000A718 [10].rela.dynRELA00000000004004e0000004e0 00000000000000300000000000000018A608 [11].rela.pltRELA000000000040051000000510 00000000000000780000000000000018AI6218 [12].initPROGBITS000000000040100000001000 000000000000001b0000000000000000AX004 [13].pltPROGBITS000000000040102000001020 00000000000000600000000000000010AX0016 [14].plt.secPROGBITS000000000040108000001080 00000000000000500000000000000010AX0016 [15].textPROGBITS00000000004010d0000010d0 00000000000001350000000000000000AX0016 [16].finiPROGBITS000000000040120800001208 000000000000000d0000000000000000AX004 [17].rodataPROGBITS000000000040200000002000 000000000000002f0000000000000000A004 [18].eh_framePROGBITS000000000040203000002030 00000000000000fc0000000000000000A008 [19].dynamicDYNAMIC0000000000403e5000002e50 00000000000001a00000000000000010WA708 [20].gotPROGBITS0000000000403ff000002ff0 00000000000000100000000000000008WA008 [21].got.pltPROGBITS000000000040400000003000 00000000000000400000000000000008WA008 [22].dataPROGBITS000000000040404000003040 00000000000000080000000000000000WA004 [23].commentPROGBITS000000000000000000003048 000000000000002a0000000000000001MS001 [24].symtabSYMTAB000000000000000000003078 00000000000004c8000000000000001825308 [25].strtabSTRTAB000000000000000000003540 00000000000001500000000000000000001 [26].shstrtabSTRTAB000000000000000000003690 00000000000000e10000000000000000001 KeytoFlags: W(write),A(alloc),X(execute),M(merge),S(strings),I(info), L(linkorder),O(extraOSprocessingrequired),G(group),T(TLS), C(compressed),x(unknown),o(OSspecific),E(exclude), l(large),p(processorspecific) hello的虚拟地址空间 使用edb加载hello，DataDump窗口可以查看加载到虚拟地址中的hello程序。 可以看出在0x400000~0x401000段中，程序被载入。这之间每个节的排列顺序与SectionHeaders中声明的顺序相同。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oZRd4VkE-1623927515237)(media/image8.png)]{width=“4.916666666666667in”height=“1.992361111111111in”} 图7edb中节的内容 ProgramHeaders ProgramHeaders: TypeOffsetVirtAddrPhysAddr FileSizMemSizFlagsAlign PHDR0x00000000000000400x00000000004000400x0000000000400040 0x00000000000002a00x00000000000002a0R0x8 INTERP0x00000000000002e00x00000000004002e00x00000000004002e0 0x000000000000001c0x000000000000001cR0x1 \[Requestingprograminterpreter:/lib64/ld-linux-x86-64.so.2\] LOAD0x00000000000000000x00000000004000000x0000000000400000 0x00000000000005880x0000000000000588R0x1000 LOAD0x00000000000010000x00000000004010000x0000000000401000 0x00000000000002150x0000000000000215RE0x1000 LOAD0x00000000000020000x00000000004020000x0000000000402000 0x000000000000012c0x000000000000012cR0x1000 LOAD0x0000000000002e500x0000000000403e500x0000000000403e50 0x00000000000001f80x00000000000001f8RW0x1000 DYNAMIC0x0000000000002e500x0000000000403e500x0000000000403e50 0x00000000000001a00x00000000000001a0RW0x8 NOTE0x00000000000003000x00000000004003000x0000000000400300 0x00000000000000200x0000000000000020R0x8 NOTE0x00000000000003200x00000000004003200x0000000000400320 0x00000000000000200x0000000000000020R0x4 GNU_PROPERTY0x00000000000003000x00000000004003000x0000000000400300 0x00000000000000200x0000000000000020R0x8 GNU_STACK0x00000000000000000x00000000000000000x0000000000000000 0x00000000000000000x0000000000000000RW0x10 GNU_RELRO0x0000000000002e500x0000000000403e500x0000000000403e50 0x00000000000001b00x00000000000001b0R0x1 参数说明： PHDR：保存程序头表 INTERP：动态链接器的路径 LOAD：可加载的程序段 DYNAMIN：保存了由动态链接器使用的信息 NOTE保存辅助信息 GNU_STACK：标志栈是否可执行 GNU_RELRO：指定重定位后需被设置成只读的内存区域 链接的重定位过程分析 使用objdump-d-rhello获得hello的反汇编代码。 hello相对hello.o的内容变化 与hello.o反汇编文本相比，在hello的反汇编文件中内容发生了变化。 链接中新增了.plt.sec节，其中是一些函数如：puts、printf、getchar等 Disassemblyofsection.plt.sec: 0000000000401080<puts@plt>: 401080:f30f1efaendbr64 401084:f2ff258d2f0000bndjmpq*0x2f8d(%rip)#404018<puts@GLIBC_2.2.5> 40108b:0f1f440000nopl0x0(%rax,%rax,1) 0000000000401090<printf@plt>: 401090:f30f1efaendbr64 401094:f2ff25852f0000bndjmpq*0x2f85(%rip)#404020<printf@GLIBC_2.2.5> 40109b:0f1f440000nopl0x0(%rax,%rax,1) 00000000004010a0<getchar@plt>: 4010a0:f30f1efaendbr64 4010a4:f2ff257d2f0000bndjmpq*0x2f7d(%rip)#404028<getchar@GLIBC_2.2.5> 4010ab:0f1f440000nopl0x0(%rax,%rax,1) 00000000004010b0<exit@plt>: 4010b0:f30f1efaendbr64 4010b4:f2ff25752f0000bndjmpq*0x2f75(%rip)#404030<exit@GLIBC_2.2.5> 4010bb:0f1f440000nopl0x0(%rax,%rax,1) 00000000004010c0<sleep@plt>: 4010c0:f30f1efaendbr64 4010c4:f2ff256d2f0000bndjmpq*0x2f6d(%rip)#404038<sleep@GLIBC_2.2.5> 4010cb:0f1f440000nopl0x0(%rax,%rax,1) 链接中新增.init节和.plt节和.plt.sec节和.fini节 Disassemblyofsection.init: … Disassemblyofsection.plt: … Disassemblyofsection.plt.sec: … Disassemblyofsection.text: … Disassemblyofsection.fini: … 寻址方式变化 hello.o中相对寻址： 19:488d3d00000000lea0x0(%rip),%rdi#20<main+0x20> hello中直接寻址 40111e:488d3ddf0e0000lea0xedf(%rip),%rdi#402004<_IO_stdin_used+0x4> 这是因为hello.o文件中对于某些地址定位暂时不明确，其地址也是在运行时确定的，因此访问需要重新定位。 函数调用方式变化 hello.o调用函数相对地址全设置为0 2a:e800000000callq2f<main+0x2f> 2b:R\_X86\_64\_PLT32exit-0x4 hello调用函数有具体地址 40112f:e87cffffffcallq4010b0<exit@plt> hello无需重定位所以没有hello.o中的重定位条目，跳转地址和函数调用地址在hello中都变成了虚拟内存地址。链接器将hello.o中的偏移量加上程序在虚拟内存中的起始地址0x0040000和.text节中的偏移量就得到了反汇编代码hello中的地址。 下面简要分析一下callqexit的重定位PC相对引用： 在ELF文件中能够找到exit对应的重定位条目如下 OffsetInfoTypeSym.ValueSym.Name+Addend 00000000001c000500000002R_X86_64_PC320000000000000000.rodata-4 000000000021000d00000004R_X86_64_PLT320000000000000000puts-4 00000000002b000e00000004R_X86_64_PLT320000000000000000exit-4 可得： r.offset=0x2b r.addend=0x-4 <exit>的首地址(Addr(s)) 00000000004010b0<exit@plt>: <main>的首地址(Addr(r.symbol)) 0000000000401105<main>: 由相对地址重定位计算公式 refaddr=Addr(s)+r.offset=0x4010b0+0x2b *refptr=(unsigned)(ADDR(r.symbol)+r.addend-refaddr) =(unsigned)[0x4010b0-0x4-(0x4010b0+0x2b)] =(unsigned)[0x-84] =0xffffff7c 由于是小端序存储，所以callq的机器码为e87cffffff 链接的过程 链接的方式有静态和动态两种。最基本的链接叫做静态链接，就是将每个模块的源代码文件编译成目标文件（Linux：.oWindows：.obj），然后将目标文件和库一起链接形成最后的可执行文件。 链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。链接的过程如下： 地址和空间的分配符号决议（用符号来标识一个地址）重定向 hello的执行流程 用gdb调试记录下执行过程中call命令进入的函数 程序名称>程序地址ld-2.27.so!_dl_start>0x7fce8cc38ea0ld-2.27.so!_dl_init>0x7fce8cc47630hello!_start>0x400500libc-2.27.so!libc_start_main>0x7fce8c867ab0-libc-2.27.so!cxa_atexit>0x7fce8c889430-libc-2.27.so!libc_csu_init>0x4005c0hello!_init>0x400488libc-2.27.so!_setjmp>0x7fce8c884c10-libc-2.27.so!_sigsetjmp>0x7fce8c884b70–libc-2.27.so!sigjmp_save>0x7fce8c884bd0hello!main>0x400532hello!puts@plt>0x4004b0hello!exit@plt>0x4004e0*hello!printf@plt>–*hello!sleep@plt>–*hello!getchar@plt>–ld-2.27.so!_dl_runtime_resolve_xsave>0x7fce8cc4e680-ld-2.27.so!_dl_fixup>0x7fce8cc46df0–ld-2.27.so!_dl_lookup_symbol_x>0x7fce8cc420b0libc-2.27.so!exit>0x7fce8c889128 Hello的动态链接分析 在进行动态链接前，首先进行静态链接，生成部分链接的可执行目标文件hello。此时共享库中的代码和数据没有被合并到hello中。加载hello时，动态链接器对共享目标文件中的相应模块内的代码和数据进行重定位，加载共享库，生成完全链接的可执行目标文件。 动态链接采用了延迟加载的策略，即在调用函数时才进行符号的映射。使用偏移量表GOT+过程链接表PLT实现函数的动态链接。GOT中存放函数目标地址，为每个全局函数创建一个副本函数，并将对函数的调用转换成对副本 在elf文件中可以找到： [20].gotPROGBITS0000000000403ff000002ff0 00000000000000100000000000000008WA008 [21].got.pltPROGBITS000000000040400000003000 00000000000000400000000000000008WA008 进入edb查看： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XsucLq1u-1623927515238)(media/image9.png)]{width=“5.492361111111111in”height=“1.2951388888888888in”} 图8edb执行init前的地址 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mTfL3gvV-1623927515239)(media/image10.png)]{width=“5.477083333333334in”height=“1.2652777777777777in”} 图9edb执行init后的地址 对于变量而言，我们利用代码段和数据段的相对位置不变的原则计算正确地址。对于库函数而言，需要plt、got合作，plt初始存的是一批代码，它们跳转到got所指示的位置，然后调用链接器。初始时got里面存的都是plt的第二条指令，随后链接器修改got，下一次再调用plt时，指向的就是正确的内存地址。plt就能跳转到正确的区域。 本章小结 在本章中主要介绍了链接的概念与作用、hello的ELF格式，分析了hello的 虚拟地址空间、重定位过程、执行流程、动态链接过程。 （第5章1分） hello进程管理 进程的概念与作用 进程的概念： 进程是执行中程序的抽象。 进程的作用： 每次运行程序时，shell创建一新进程，在这个进程的上下文切换中运行这个可执行目标文件。应用程序也能够创建新进程，并且在新进程的上下文中运行它们自己的代码或其他应用程序。进程提供给应用程序的关键抽象：一个独立的逻辑控制流，如同程序独占处理器；一个私有的地址空间，如同程序独占内存系统。 简述壳Shell-bash的作用与处理流程 Shell-bash的作用 Shell是一个用C语言编写的程序，是用户使用Linux的桥梁，它提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Shell-bash的处理流程 1）从终端读入输入的命令。 2）将输入字符串切分获得所有的参数 3）如果是内置命令则立即执行，否则调用相应的程序为其分配子进程并运行 shell应该接受键盘输入信号，并对这些信号进行相应处理。 Hello的fork进程创建过程 在终端输入./hello1190301804liangcheng运行的终端程序会对输入的命令行进行解析，因为hello不是一个内置的shell命令所以解析之后终端程序判断./hello的语义为执行当前目录下的可执行目标文件hello，之后终端程序首先会调用fork函数创建一个新的运行的子进程，新创建的子进程几乎但不完全与父进程相同：子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。 父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。 Hello的execve过程 exceve函数在当前进程的上下文中加载并运行一个新程序，execve函数加载并运行可执行目标文件hello，执行一次，并且从不返回。删除子进程现有的虚拟内存段，新的栈和堆段被初始化为零，新的代码和数据段被初始化为可执行文件中的内容。 Hello的进程执行 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片。 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程，这个决策就叫做调度，是由内核中称为调度器的代码处理的。 在内核调度了一个新的进程运行后，它就抢占当前进程，并使用上文所述的上下文切换的机制将控制转移到新的进程。内核代表的用户执行系统调用时，可能会发生上下文切换；中断也有可能引发上下文切换。 通过内核模式用户模式的切换描述用户态核心态转换的过程，在切换的第一部分中，内核代表进程A在内核模式下执行指令。然后在某一时刻，它开始代表进程B(仍然是内核模式下)执行指令。在切换之后，内核代表进程B在用户模式下执行指令。随后，进程B在用户模式下运行一会儿，直到磁盘发出一个中断信号，表示数据已经从磁盘传送到了内存。内核判定进程B已经运行了足够长的时间，就执行一个从进程B到进程A的上下文切换，将控制返回给进程A中紧随在系统调用read之后的那条指令。进程A继续运行，直到下一次异常发生，依此类推。 hello的异常与信号处理 异常类型： 类别原因异步/同步返回行为中断来自I/O设备的信号异步总是返回到下一条指令陷阱有意的异常同步总是返回到下一条指令故障潜在可恢复的错误同步可能返回到当前指令终止不可恢复的错误同步不会返回 处理方法： 中断 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4Sy6ukDC-1623927515239)(media/image11.png)]{width=“3.6215277777777777in”height=“1.1819444444444445in”} 图10中断的处理 陷阱 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lZpLx6U5-1623927515240)(media/image12.png)]{width=“3.6819444444444445in”height=“1.2270833333333333in”} 图11陷阱的处理 故障 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hrYlt9kO-1623927515241)(media/image13.png)]{width=“3.848611111111111in”height=“1.1895833333333334in”} 图12故障的处理 终止 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-emmalDtt-1623927515241)(media/image14.png)]{width=“3.598611111111111in”height=“1.257638888888889in”} 图13终止的处理 执行过程中按键盘： 正常执行。如下图所示，为hello程序正常运行的结果，接着输入命令ps后执行，程序后台并没有hello进程正在执行了，说明进程正常结束，已经被回收了。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xK7TKElI-1623927515242)(media/image15.png)]{width=“5.90625in”height=“2.1659722222222224in”} 图14正常执行 不停乱按：结果是程序运行情况和前面的相同，不同之处在于shell将我们刚刚乱输入的字符除了第一个回车按下之前的字符当做getchar的输入之外，其余都当做新的shell命令，在hello进程结束被回收之后，将会在命令行中尝试解释这些命令。中间没有任何对于进程产生影响的信号被产生。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fmei8dhM-1623927515242)(media/image16.png)]{width=“5.901388888888889in”height=“4.007638888888889in”} 图15键盘乱按 ctrl+c 在hello程序运行时输入CTRL+C会导致内核发送一个SIGINT信号到前台进程组的每个进程。默认情况下，结果是终止前台作业。 用ps和jobs观察，发现进程已经被终止。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3CkUDTuQ-1623927515243)(media/image17.png)]{width=“5.901388888888889in”height=“1.0152777777777777in”} 图16ctrl+c ctrl+z 将会发送一个SIGTSTP信号给shell。然后shell将转发给当前执行的前台进程组，使hello进程挂起。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KXLOj8kD-1623927515243)(media/image18.png)]{width=“5.90625in”height=“0.5527777777777778in”} 图17ctrl+z 我们输入ps命令，hello进程仍然存在 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XRkAvPrp-1623927515244)(media/image19.png)]{width=“5.552777777777778in”height=“0.8104166666666667in”} 图18ctrl+z用ps观察 输入jobs命令：hello已经停止，进程号为1 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ku241pOu-1623927515244)(media/image20.png)]{width=“5.333333333333333in”height=“0.3861111111111111in”} 图19ctrl+z用jobs观察 使用fg1（1是进程号）命令将其调回前台，继续执行： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pBpkJHre-1623927515245)(media/image21.png)]{width=“5.409027777777778in”height=“1.6972222222222222in”} 图20ctrl+z后用fg调回 kill命令：kill后无法用ps看到进程号，jobs也为空。进程已经被杀死。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EvMcYhyr-1623927515245)(media/image22.png)]{width=“5.90625in”height=“0.9083333333333333in”} 图21kill指令 本章小结 本章了解了hello进程的执行过程。主要讲hello的创建、加载和终止，通过键盘输入。程序是指令、数据及其组织形式的描述，进程是程序的实体。可以说，进程是运行的程序。在hello运行过程中，内核有选择对其进行管理，决定何时进行上下文切换。也同样是在hello的运行过程中，当接受到不同的异常信号时，异常处理程序将对异常信号做出相应，执行相应的代码，每种信号都有不同的处理机制，对不同的异常信号，hello也有不同的处理结果。 （第6章1分） hello的存储管理 hello的存储器地址空间 逻辑地址 逻辑地址（LogicalAddress）是指由程序hello产生的与段相关的偏移地址部分（hello.o）。 线性地址 线性地址（LinearAddress）是逻辑地址到物理地址变换之间的中间层。程序hello的代码会产生逻辑地址，或者说是（即hello程序）段中的偏移地址，它加上相应段的基地址就生成了一个线性地址。 虚拟地址 有时我们也把逻辑地址称为虚拟地址。因为与虚拟内存空间的概念类似，逻辑地址也是与实际物理内存容量无关的，是hello中的虚拟地址。 物理地址 物理地址（PhysicalAddress）是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么hello的线性地址会使用页目录和页表中的项变换成hello的物理地址；如果没有启用分页机制，那么hello的线性地址就直接成为物理地址了。 Intel逻辑地址到线性地址的变换-段式管理 一个逻辑地址由两部份组成，段标识符、段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如下图： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ygFgYtKM-1623927515245)(media/image23.png)] 图22段选择符 索引号，是“段描述符(segmentdescriptor)”，段描述符具体地址描述了一个段。这样，很多个段描述符，就组了一个数组，叫“段描述符表”，这样，可以通过段标识符的前13位，直接在段描述符表中找到一个具体的段描述符，这个描述符就描述了一个段，由8个字节组成，如下图 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lms1Zy40-1623927515246)(media/image24.png)] 图23段描述符 Base字段：它描述了一个段的开始位置的线性地址。Intel设计的本意是，一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。 当段选择符中的T1字段=0，表示用GDT；若为1，表示用LDT。GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。再看图7-3比起来要直观些： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nEFQLTnV-1623927515246)(media/image25.png)] 图24逻辑地址转线性地址 首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]， 1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。 2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，Base（基地址）就知道了。 3、把Base+offset，就是要转换的线性地址了。 Hello的线性地址到物理地址的变换-页式管理 页式管理是一种内存空间存储管理的技术，页式管理分为静态页式管理和动态页式管理。将各进程的虚拟空间划分成若干个长度相等的页(page)，页式管理把内存空间按页的大小划分成片或者页面（pageframe），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。 Linux将虚拟内存组织成一些段的集合，段之外的虚拟内存不存在因此不需要记录。内核为hello进程维护一个段的任务结构即图中的task_struct，其中条目mm指向一个mm_struct，它描述了虚拟内存的当前状态，pgd指向第一级页表的基地址（结合一个进程一串页表），mmap指向一个vm_area_struct的链表，一个链表条目对应一个段，所以链表相连指出了hello进程虚拟内存中的所有段。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-d3iltck0-1623927515247)(media/image26.png)]{width=“4.280555555555556in”height=“2.6284722222222223in”} 图25段集合示意图 而物理内存被划分为一小块一小块，每块被称为帧(Frame)。分配内存时，帧是分配时的最小单位，最少也要给一帧。 在虚拟内存中，与帧对应的概念就是页(Page)。虚拟地址的表示如下，由虚拟页号VPN与虚拟页偏移量VPO组成。 MMU利用虚拟页号（VPN）来在虚拟页表中选择合适的PTE，当找到合适的PTE之后，PTE中的物理页号（PPN）和虚拟页偏移量（VPO）就会组合形成物理地址。其中VPO与PPO相同，因为虚拟页大小和物理页大小相同，所需要的偏移量位数也就相同。此时，物理地址就通过物理页号先找到对应的物理页，然后再根据物理页偏移找到具体的字节： 1.如果有效位是0+NULL则代表没有在虚拟内存空间中分配该内存； 2.如果是有效位0+非NULL，则代表在虚拟内存空间中分配了但是没有被缓存到物理内存中； 3.如果有效位是1则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，与虚拟页偏移量共同构成物理地址PA。 如下图所示， [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kgDd1sEf-1623927515248)(media/image27.png)]{width=“3.265277777777778in”height=“1.6895833333333334in”} 图26页式管理示意图 页式管理优缺点分析： 优点： 1、由于它不要求作业或进程的程序段和数据在内存中连续存放，从而有效地解决了碎片问题。 2、动态页式管理提供了内存和外存统一管理的虚存实现方式，使用户可以利用的存储空间大大增加。这既提高了主存的利用率，又有利于组织多道程序执行。 缺点： 1、要求有相应的硬件支持。例如地址变换机构，缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。这增加了机器成本。 2、增加了系统开销，例如缺页中断处理机， 3、请求调页的算法如选择不当，有可能产生抖动现象。 4、虽然消除了碎片，但每个作业或进程的最后一页内总有一部分空间得不到利用果页面较大，则这一部分的损失仍然较大。 TLB与四级页表支持下的VA到PA的变换 VA由VPN和VPO组成。PA由PPN与PPO组成。 VPN可以作为在TLB中的索引，如下图所示，TLB可以看作是一个PTE的cache，将常用的PTE缓存到TLB中，加速虚拟地址的翻译。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-o2V1iSP9-1623927515248)(media/image28.png)]{width=“3.9923611111111112in”height=“2.848611111111111in”} 图27core-i7地址翻译情况 如果能够在TLB中找到与VPN对应的PTE，即为TLB命中，TLB直接给出PPN，然后PPO即为VPO，这样就得到了物理地址PA。如果TLB没有命中，那么就需要到四级页表中寻址： 将虚拟地址的VPN划分为相等大小的四部分，每个部分用于寻找由上一级确定的页表基址对应的页表条目。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-N7ZWECIe-1623927515249)(media/image29.png)]{width=“3.901388888888889in”height=“2.3784722222222223in”} 图28core-i7页表翻译 然后解析VA，利用前m位vpn1寻找一级页表位置，接着一次重复4次，在第4级页表获得了页表条目，将PPN与VPO组合获得PA。 三级Cache支持下的物理内存访问 MMU获得PA后，根据cache大小将PA分为(CT，CI，CO)三部分。 然后根据CI（倒数7-12位）进行组索引，每组8路。对8路的块分别匹配CT（前40位）。 如果匹配成功且块内valid位为1，则命中。命中后根据CO（后六位）取出数据并返回。如果不命中，则需要向下一级缓存中查询数据(L2cache–>L3cache–>内存),查询到数据后，用相应的放置策略更新各级cache。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yPJz7rYO-1623927515249)(media/image30.png)]{width=“3.8027777777777776in”height=“2.6215277777777777in”} 图29三级cache下物理内存访问 hello进程fork时的内存映射 理解了虚拟内存和内存映射，那么我们就可以清晰地知道fork函数是如何创建一个带有自己独立虚拟地址空间的新进程的。 当fork函数被shell调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID。为了给hello进程创建虚拟内存，它创建了hello进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 hello进程execve时的内存映射 在bash中的进程中执行了如下的execve调用：execve(“hello”,NULL,NULL)； execve函数在当前进程中加载并运行包含在可执行文件hello中的程序，用hello替代了当前bash中的程序。 下面是加载并运行hello的几个步骤： 删除已存在的用户区域。映射私有区域映射共享区域设置程序计数器（PC）exceve做的最后一件事是设置当前进程的上下文中的程序计数器，是指指向代码区域的入口点。而下一次调度这个进程时，他将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KHe5ZOBT-1623927515250)(media/image31.png)]{width=“3.2729166666666667in”height=“2.454861111111111in”} 图30加载器映射用户地址区域 缺页故障与缺页中断处理 在虚拟内存的习惯说法中，DRAM缓存不命中称为缺页(pagefault)。页面命中完全是由硬件完成的，而处理缺页是由硬件和操作系统内核协作完成的。 假设MMU在试图翻译某个虚拟地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤: 先确认是不是一个合法的地址：即通过不断将这个地址与每个区域的vm_start&vm_end进行比对，如果并不是在一个区域里的话，就给出segmentationfault，因为它引用了一个不合法的地址确认访问权限是不是正确的：即如果这一页是只读页，但是却要做出写这个动作，那明显是不行的。如果做出了这类动作，那么处理程序就会触发一个保护异常，默认行为是结束这个进程当确认了是合法地址并且是符合权限的访问，那么就用某个特定算法选出一个牺牲页，如果该页被修改了，就将此页滑出（swapout）并且swapin那个被访问的页，并将控制传递到触发缺页中断的那条指令，这条指令继续执行的时候就不会触发缺页中断，这样就可以继续执行下去。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n4xHoz8S-1623927515251)(media/image32.png)]{width=“4.038194444444445in”height=“2.401388888888889in”} 图31linus缺页处理 动态存储分配管理 动态储存分配管理使用动态内存分配器来进行。动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配的状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。 动态内存分配主要有两种基本方法与策略： 带边界标签的隐式空闲链表分配器管理 带边界标记的隐式空闲链表的每个块是由一个字的头部、有效载荷、可能的额外填充以及一个字的尾部组成的。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-JCJUY07h-1623927515252)(media/image33.png)]{width=“4.424305555555556in”height=“1.9618055555555556in”} 图32隐式空间链表的堆块示意图 隐式空闲链表：在隐式空闲链表中，因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。其中，一个设置了已分配的位而大小为零的终止头部将作为特殊标记的结束块。 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大的可以放置所请求块的空闲块。分配器有三种放置策略：首次适配、下一次适配合最佳适配。分配完后可以分割空闲块减少内部碎片。同时分配器在面对释放一个已分配块时，可以合并空闲块，其中便利用隐式空闲链表的边界标记来进行合并。 显式空间链表管理 显式空闲链表是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。如，堆可以组织成一个双向链表，在每个空闲块中，都包含一个前驱与一个后继指针。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VBhOSSko-1623927515253)(media/image34.png)]{width=“4.727083333333334in”height=“2.3784722222222223in”} 图33显式空闲表的堆块示意图 显式空闲链表：在显式空闲链表中。可以采用后进先出的顺序维护链表，将最新释放的块放置在链表的开始处，也可以采用按照地址顺序来维护链表，其中链表中每个块的地址都小于它的后继地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。 本章小结 本章主要介绍了hello的存储器地址空间、intel的段式管理、hello的页式管理，在指定环境下介绍了VA到PA的变换、物理内存访问，还介绍hello进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。 （第7章2分） hello的IO管理 Linux的IO设备管理方法 设备的模型化：所有的IO设备都被模型化为文件，而所有的输入输出都被当作对相应文件的读和写来执行。设备管理：将设备优雅地映射为文件的方式,允许Linux内核引出一个简单、低级的应用接口,称为UnixI/O,这使得所有的输入和输出都能以一种统一且一致的方式来执行,这就是UnixI/O接口。 简述UnixIO接口及其函数 UnixI/O接口统一操作： 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息。Shell创建的每个进程都有三个打开的文件：标准输入，标准输出，标准错误。改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行seek，显式地将改变当前文件位置k。读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n，给定一个大小为m字节的而文件，当k>=m时，触发EOF。类似一个写操作就是从内存中复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中去。 UnixI/O函数： open（）函数 功能描述：用于打开或创建文件，在打开或创建文件时可以指定文件的属性及用户的权限等各种参数。 函数原型:intopen(constchar*pathname,intflags,intperms) 参数：pathname:被打开的文件名（可包括路径名如"dev/ttyS0"）flags:文件打开方式, 返回值：成功就返回文件描述符；失败就返回-1 close（）函数 功能描述：用于关闭一个被打开的的文件 所需头文件：#include<unistd.h> 函数原型:intclose(intfd) 参数：fd文件描述符 函数返回值：0成功，-1出错 read（）函数 功能描述：从文件读取数据。 所需头文件：#include<unistd.h> 函数原型：ssize_tread(intfd,void*buf,size_tcount); 参数：fd：将要读取数据的文件描述词。buf：指缓冲区，即读取的数据会被放到这个缓冲区中去。count：表示调用一次read操作，应该读多少数量的字符。 返回值：返回所读取的字节数；0（读到EOF）；-1（出错）。 write（）函数 功能描述：向文件写入数据。 所需头文件：#include<unistd.h> 函数原型：ssize_twrite(intfd,void*buf,size_tcount); 返回值：写入文件的字节数（成功）；-1（出错） lseek（）函数 功能描述：用于在指定的文件描述符中将将文件指针定位到相应位置。 所需头文件：#include<unistd.h>，#include<sys/types.h> 函数原型：off_tlseek(intfd,off_toffset,intwhence); 参数：fd;文件描述符。offset:偏移量，每一个读写操作所需要移动的距离，单位是字节，可正可负（向前移，向后移） 返回值：成功：返回当前位移；失败：返回-1 printf的实现分析 printf函数体： intprintf(constchar*fmt,…) { inti; charbuf[256]; va\_listarg=(va\_list)((char\*)(&fmt)+4); i=**vsprintf**(buf,fmt,arg); **write**(buf,i); returni; } 下面分析一下printf函数内容： va_listarg=(va_list)((char*)(&fmt)+4); 将所有的参数内容格式化之后存入buf，然后返回格式化数组的长度i。 vsprintf函数 intvsprintf(char*buf,constchar*fmt,va_listargs) { char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!=‘%’){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case‘x’: itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case‘s’: break; default: break; } } return(p-buf); } vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 write(buf,i); 用write函数将buf中的i个元素写到终端。 write函数 write: moveax,\_NR\_write movebx,\[esp+4\] movecx,\[esp+8\] intINT_VECTOR_SYS_CALL 在write函数中，ecx:字符个数，ebx:第一个字符的地址，最后调用syscall。 syscall 实现较为复杂。功能：不断打印出字符，直到遇到‘\0’停止。 printf实现流程如下： （1）：vsprintf格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 （2）：vsprintf的输出到write系统函数中。在Linux下，write通过执行syscall指令实现了对系统服务的调用，从而使内核执行打印操作。内核会通过字符显示子程序，根据传入的ASCII码到字模库读取字符对应的点阵，然后通过vram（显存）对字符串进行输出。 （3）：显示芯片将按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量），最终实现printf中字符串在屏幕上的输出。 getchar的实现分析 getchar有一个int型的返回值。当程序调用getchar时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中直到用户按回车为止(回车字符也放在缓冲区中)。 当用户键入回车之后，getchar才开始从stdio流中每次读入一个字符。getchar函数的返回值是用户输入的第一个字符的ascii码,如出错返回-1,且将用户输入的字符回显到屏幕。 如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取。也就是说,后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键。 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 本章小结 本章介绍了Linux的I/O设备的基本概念和管理方法，以及UnixI/O接口及其函数。最后分析了printf函数和getchar函数的工作过程。 （第8章1分） 结论 hello程序终于完成了它艰辛的一生，它的一生有这么几件大事： hello.c经过预编译，拓展得到hello.i文本文件hello.i经过编译，得到汇编代码hello.s汇编文件hello.s经过汇编，得到二进制可重定位目标文件hello.ohello.o经过链接，生成了可执行文件hellobash进程调用fork函数，生成子进程；hello由execve函数加载运行当前进程的上下文中加载并运行新程序hello通过解析得到物理地址PA。hello再运行时会调用一些函数，比如printf函数，这些函数与linuxI/O的设备模拟化密切相关。hello最终被shell父进程回收，内核会收回为其创建的所有信息 个人感悟：CSAPP不愧是本科期间收获最大的一门课，大作业也设计得如此精巧！它带我们领略的计算机内部的美丽风景，从浅入深地剖析讲解了计算机的方方面面，领我们从顶层到达了底层！体验完了hello一生，我也对计算机系统有了更深入的了解！ （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 文件的作用文件名*预处理后的文件hello.i*编译之后的汇编文件hello.s*汇编之后的可重定位目标文件hello.o*链接之后的可执行目标文件Hello*Hello.o的ELF格式elf.txt*Hello.o的反汇编代码disassemble_hello.s*hello的ELF格式helloELF.elfhello的反汇编代码disassemble_hello_o.s （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 RandalE.Bryant,DavidO’Hallaron,龚奕利,等.深入理解计算机系统[J].中国电力出版社,2004.刘兵,吴煜煌.Linux实用教程[J].中国水利水电出版社,2004.C.Linus操作基础[M/OL].CSDN,2018-05-27.李洛,黄达峰.Linux教程[M].清华大学出版社,2005.ELF构造：https://www.cs.stevens.edu/~jschauma/631/elf.html进程的睡眠、挂起和阻塞：https://www.zhihu.com/question/42962803printf函数剖析https://blog.csdn.net/zhengqijun_/article/details/72454714虚拟地址https://baike.baidu.com/item/虚拟地址/1329947?fr=aladdin （参考文献0分，缺失-1分） 

将python项目用docker部署到服务器上的全过程 任务描述 由于笔记本算力有限，要将python项目部署到服务器上。在查阅了大量资料后，踩了无数坑后，今天记录一下全过程，希望对大家有帮助。 配置要求 需要部署的python项目虚拟机/linusdocker安装服务器端口 大致流程 shareFile Docker pythonproject linus image.tar 服务器 1.Docker的打包 docker官网安装教程docker安装菜鸟教程 项目最终结构： docker_test├──Dockerfile├──pythonproject│││└──tset.py│││└──其他配置文件└──requirements.txt 生成requirements.txtcd进入到main.py目录或者直接在pycharm的Terminal下执行 pipenvlock--requirements>requirements.txt //或者 pipfreeze>>requirements.txt 得到requirement文件 dockFile的编写建议直接在linus下编写 #将官方Python运行时用作父镜像 FROMpython:3.8.2 #将工作目录设置为/pythonproject WORKDIR./pythonproject #将当前目录内容复制到位于/pythonproject中的容器中 ADD.. #安装requirements.txt中指定的任何所需软件包 RUNpipinstall-rrequirements.txt #在容器启动时运行tset.py CMD["python3","./pythonproject/tset.py"] 镜像的生成在linus下，cd到Dockerfile文件下 dockerbuild-tcowsay. 详细信息： dockerbuild-timagenameDockerfilepath #imagename：镜像名称，自定义 #Dockerfilepath：Dockerfile所在文件夹名称，当前名录为“.” 生成镜像 dockerbuild-timagenameDockerfilepath 运行镜像 dockerrun--rmcowsay --rm:跑完就删除（因为有时候container比较占空间） 在这里给大家总结一下一些docker命令dockerimagels列出镜像dockerps列出container（正在运行的）（可以加-a列出所有的）dockerrmcontainerID删除containerdockerrmiImageID删除imagedockerexec-itcontainerIDbash进入container IMAGE.tar的生成（Image打包） dockersavef660ca2347c0>image.tar //输出镜像文件到tar文件中 660ca2347c0是Image的ID号，可以通过dockerimagels查看 至此，我们已经得到IMAGE.tar了接下来，把它上传上服务器并运行 2.服务器部分 传输文件（非ssh） scpIMAGE.tarhostname@服务器地址:path scp命令详解 登录服务器 ssh账号@服务器地址 如何登录服务器 docker载入tar文件 dockerimageload<IMAGE.tar dockerrun！（快结束啦！）解压完以后就能看到docker镜像了！然后正常执行dockerrun操作就可以啦！（还是把命令贴出来看一下把） dockerrun--rmcowsay //cowsay只是一个自定义名字 可以参考dockerrun 

148.排序链表在O(nlogn)时间复杂度和常数级空间复杂度下，对链表进行排序。 快慢指针找中点//slow：（5个停在3,10个停在5） classSolution{ public: ListNode*sortList(ListNode*head){ if(head==NULL||head->next==NULL) returnhead; ///*快慢指针查找剧中节点*/ //ListNode*fast=head,*slow=head; //ListNode*tmp=head; //while(fast!=nullptr&&fast->next!=nullptr){ //tmp=slow; //fast=fast->next->next; //slow=slow->next; //} //tmp->next=NULL; //ListNode*left=sortList(head); //ListNode*right=sortList(slow); ListNode*fast=head->next,*slow=head; while(fast&&fast->next){ fast=fast->next->next; slow=slow->next; } ListNode*pre=slow->next; slow->next=NULL; ListNode*left=sortList(head); ListNode*right=sortList(pre); returnmerge(left,right); } 后面那一种查找中点的方式更加简单，巧妙之处在于“fast=head->next;" ListNode*merge(ListNode*left,ListNode*right) {ListNode*result=newListNode(0); ListNode*cur=result; while(left!=NULL&&right!=NULL){ if(left->val<right->val) { cur->next=left; cur=cur->next; left=left->next; } else{ cur->next=right; cur=cur->next; right=right->next; } } if(left!=NULL){ cur->next=left; } if(right!=NULL){ cur->next=right; } //cur->next=(left==NULL?right:left); returnresult->next; } 

Vmware共享目录消失（绝对有用！） 查看是否已经挂载 vmware-hgfsclient 2.如果没有挂载 先umount卸下 sudoumount/mnt/hgfs 然后在重新挂上去 sudovmhgfs-fuse.host://mnt/hgfs 再次查看 vmware-hgfsclient 

Linus下EDB的安装 安装#installdependencies sudoapt-getinstallcmakebuild-essentiallibboost-dev\ libqt5xmlpatterns5-devqtbase5-devqt5-default\ libqt5svg5-devlibgraphviz-devlibcapstone-dev 安装#buildandrunedb sudoaptinstallgit gitclone--recursivehttps://github.com/eteran/edb-debugger.git 如果出错，把https改为git再重新执行 cdedb-debugger mkdirbuild cdbuild cmake.. 如出错sudoapt-getinstall--reinstallpkg-configcmake-data make ./edb--run执行程序 

ubuntu下无法看到共享文件夹 无法看到mnt/hgfs/后的共享文件夹 执行 执行 sudovmhgfs-fuse.host://mnt/hgfs/-oallow_other-ouid=1000 

【软构课堂笔记6：设计模式】 

【软构课堂笔记4：可复用性CRP可维护性正则表达式】 

软构复习【6】 

【软构lab3日志：造轮子的苦逼】 

软构复习【4】 

Linus下CodeBlocks的安装 只需输入3个命令 sudoadd-apt-repositoryppa:damien-moore/codeblocks-stable sudoapt-getupdate sudoapt-getinstallcodeblocks

软构复习【3】 

【软构课堂笔记6：设计模式】 

【软构课堂笔记3：面向对象编程】 

软构复习【2】  

【软构课堂笔记4：可复用性CRP可维护性正则表达式】 

2021-06-23 程序人生-Hello’sP2P 摘要 一个hello程序的生成，要经历预处理，编译，汇编和链接，从而得到可执行目标文件；而hello程序的运行，则需要进程，信号和I/O的共同实现。通过一个简简单单的hello文件，可以大致窥探到计算机运行的整个面貌。 关键词：编译；汇编；链接；虚拟内存；进程；I/O。 目录 摘要第1章概述1.1Hello简介1.2环境与工具1.3中间结果1.4本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析2.4本章小结 第3章编译3.1编译的概念与作用3.2Ubuntu下编译命令3.3Hello的编译结果解析3.4本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令4.3可重定位目标ELF格式4.4Hello.o的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件HELLO的格式5.4HELLO的虚拟地址空间5.5链接的重定位过程分析5.6HELLO的执行流程5.7HELLO的动态链接分析5.8本章小结 第6章HELLO的进程管理6.1进程的概念与作用6.2简述壳SHELL-BASH的作用与处理流程6.3的FORK进程创建过程6.4HELLO的EXECVE过程6.5HELLO的进程执行6.6HELLO的异常与信号6.7本章小结 第7章HELLO的存储管理7.1HELLO的存储器地址空间7.2INTEL逻辑地址到线性地址的变换-段式管理7.3HELLO的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.5三级CACHE支持下的物理内存访问7.6HELLO进程FORK时的内存映射7.7HELLO进程EXECVE时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章HELLO的IO管理8.1LINUX的IO设备管理方法8.2简述UNIXIO接口及其函数8.3PRINTF的实现分析8.4GETCHAR实现分析8.5本章小结 结论附件参考文献第1章概述1.1Hello简介1.2环境与工具1.3中间结果本章小结 第2章预处理2.1预处理的概念与作用2.2在Ubuntu下预处理的命令2.3Hello的预处理结果解析本章小结 第3章编译3.1编译的概念与作用3.2在Ubuntu下编译的命令3.3Hello的编译结果解析3.3.1全局变量sleepsecs3.3.2局部变量i3.3.3if的控制转移3.3.4for循环的实现3.3.5函数调用3.3.6数组3.3.7强制转换3.3.8算数操作 本章小结 第4章汇编4.1汇编的概念与作用4.2在Ubuntu下汇编的命令可重定位目标elf格式4.4hello.o的结果解析4.5本章小结 第5章链接5.1链接的概念与作用5.2在Ubuntu下链接的命令5.3可执行目标文件hello的格式5.4hello的虚拟地址空间5.5链接的重定位过程分析5.6hello的执行流程5.7Hello的动态链接分析本章小结 第6章hello进程管理6.1进程的概念与作用6.2简述壳Shell-bash的作用与处理流程6.3Hello的fork进程创建过程6.4Hello的execve过程6.5Hello的进程执行6.6hello的异常与信号处理6.7本章小结 第7章hello的存储管理7.1hello的存储器地址空间7.2Intel逻辑地址到线性地址的变换-段式管理7.3Hello的线性地址到物理地址的变换-页式管理7.4TLB与四级页表支持下的VA到PA的变换7.6hello进程fork时的内存映射7.7hello进程execve时的内存映射7.8缺页故障与缺页中断处理7.9动态存储分配管理7.10本章小结 第8章hello的IO管理8.1Linux的IO设备管理方法8.2简述UnixIO接口及其函数8.3printf的实现分析8.4getchar的实现分析8.5本章小结 附件参考文献 第1章概述 1.1Hello简介 1.2环境与工具 1.3中间结果 1.4本章小结 第2章预处理 2.1预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3Hello的预处理结果解析 2.4本章小结 第3章编译 3.1编译的概念与作用 3.2Ubuntu下编译命令 3.3Hello的编译结果解析 3.4本章小结 第4章汇编 4.1汇编的概念与作用 4.2在Ubuntu下汇编的命令 4.3可重定位目标ELF格式 4.4Hello.o的结果解析 4.5本章小结 第5章链接 5.1链接的概念与作用 5.2在Ubuntu下链接的命令 5.3可执行目标文件HELLO的格式 5.4HELLO的虚拟地址空间 5.5链接的重定位过程分析 5.6HELLO的执行流程 5.7HELLO的动态链接分析 5.8本章小结 第6章HELLO的进程管理 6.1进程的概念与作用 6.2简述壳SHELL-BASH的作用与处理流程 6.3的FORK进程创建过程 6.4HELLO的EXECVE过程 6.5HELLO的进程执行 6.6HELLO的异常与信号 6.7本章小结 第7章HELLO的存储管理 7.1HELLO的存储器地址空间 7.2INTEL逻辑地址到线性地址的变换-段式管理 7.3HELLO的线性地址到物理地址的变换-页式管理 7.4TLB与四级页表支持下的VA到PA的变换 7.5三级CACHE支持下的物理内存访问 7.6HELLO进程FORK时的内存映射 7.7HELLO进程EXECVE时的内存映射 7.8缺页故障与缺页中断处理 7.9动态存储分配管理 7.10本章小结 第8章HELLO的IO管理 8.1LINUX的IO设备管理方法 8.2简述UNIXIO接口及其函数 8.3PRINTF的实现分析 8.4GETCHAR实现分析 8.5本章小结 结论 附件 参考文献 第1章概述 1.1Hello简介 P2P(fromprogramtoprocess)，将源代码经过预处理转化为预处理输出文件，将预处理输出文件经过编译转化为汇编代码文件，将汇编代码文件经过汇编转化为可重定位目标文件，将可重定位目标文件经过链接转化为可执行目标文件。020(fromzero-0tozero-0)，hello程序从主存到开始，通过虚拟地址寻址并由IO执行，在执行完之后释放内存存储空间，一切就像没有发生过的一样。 1.2环境与工具 电脑型号：荣耀MagicBook2019CPU：AMDRyzen53500UwithRadeonVegaMobileGfx2.10GHz物理机系统：Windows10版本号：19042.1052虚拟机：VMware16.1.2build-17966106虚拟机系统：Ubuntu64位20.04gcc:C语言编译器objdump,edb,gdb 1.3中间结果 hello.c:源文件hello.i:预处理输出文件hello.s:编译代码文件hello.o：可重定位目标文件hello：可执行目标文件 本章小结 本章从整体角度大致地介绍了程序（program）的生成和执行过程，以及下文内容的实现所使用的软硬件环境。 第2章预处理 2.1预处理的概念与作用 预处理是将源程序转化为可执行程序的第一个转化步骤，主要用于C语言编译器对各种预处理命令进行处理，包括对头文件的包含，宏定义的扩展，条件编译的选择等。 2.2在Ubuntu下预处理的命令 将.c文件转化为预处理后的.i可见文本文件hello.c->hello.i:linux>gcc-Ehello.c-ohello.i 2.3Hello的预处理结果解析 预处理后可以发现，原先源代码里的头文件和宏都被程序替换为对应路径里面的文本，将所有调用全部展开，为后面的编译做准备。 本章小结 本章介绍了预处理的指令与过程，从代码展开的层面解释了预处理的原理与意义，为后面介绍编译做准备。 第3章编译 3.1编译的概念与作用 C编译器在进行具体的程序翻译之前，会先对源程序进行词法分析，语义分析和语法分析，然后根据分析的结果进行代码优化和存储分配，最终把C语言源程序翻译成为汇编语言程序。编译器通常采用对源程序进行多次扫描的方式进行处理，每次集中完成一项或几项任务，也可以将一项任务分散到几次扫描进行完成。 3.2在Ubuntu下编译的命令 hello.i->hello.s:linux>gcc-Shello.i-ohello.s 3.3Hello的编译结果解析 3.3.1全局变量sleepsecs sleepsces作为全局变量被放在.data节，并通过globl声明为全局变量。 3.3.2局部变量i 局部变量i为int型数据，在这里大小为4字节。局部变量一般都是存储在寄存器或者栈空间，在这里%rbp栈堆开出4字节空间存储i 3.3.3if的控制转移 If循环使用cmpl来进行数值比较和条件码的设置，若不等于3，通过无条件跳转jmp跳转到L3来实现if内的语句。 3.3.4for循环的实现 For循环也是通过条件码来实现跳转，在这里L3的条件跳转和L4的自然结束后过渡到L3共同构成了一个循环，当i>=10时跳出循环。 3.3.5函数调用 Printf函数，getchar函数，sleep函数，exit函数，通过call来调用这些函数 3.3.6数组 编译后数组通过索引值和基值实现对数组内容的寻址，char*为地址数组类型，每一个大小8字节，则将寄存器%rax中的值增加16恰好到达argv[2]处。 3.3.7强制转换 Sleepsecs被隐式强制转换，实际上被赋值为2（向0舍弃）。 3.3.8算数操作 通过add来实现加法运算 本章小结 本章通过hello的实例将C语言操作和数据类型与汇编语言对应起来，从寄存器和堆的角度来看待程序的运行。 第4章汇编 4.1汇编的概念与作用 汇编的功能是将编译生成的汇编语言代码转换为机器语言代码。因为通常最终的可执行目标文件由多个不同模块对应的机器语言目标代码组合而形成，所以，在生成单个模块的机器语言目标代码时，不能确定每条指令或每个数据最终的地址，也即，单个模块的机器语言目标代码文件需要重新定位，因此，通常把汇编生成的机器语言目标代码文件称为可重定位目标文件。 4.2在Ubuntu下汇编的命令 hello.s->hello.o:linux>gcc-chello.s-ohello.o 可重定位目标elf格式 分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。readelf-ahello.o>hello.elf ELF头：开头Magic:7f454c46020101000000000000000000，描述了生成该文件的系统的字的大小和字节顺序，紧接着便是ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移、节头部表中的条目的大小和数量节头部表：节头部表显示不同节的位置与大小信息，目标文件中每个节都有一个固定大小的条目。重定位节：显示偏移量，信息，类型，符号值，符号名称和加数等信息。符号表：符号表由汇编器构造，表中包含一个数组。 4.4hello.o的结果解析 objdump-d-rhello.o分析hello.o的反汇编，并请与第3章的hello.s进行对照分析。两者的代码实现功能相同，但是相比之下反汇编的代码更加“奇妙”，这种奇妙是机器运行计算和人脑思维运算的不同。由.i文件得到的.s文件像是一种翻译，将人类的高级编程语言翻译成机器语言，但是思维逻辑还是人的思维；而.o文件的反汇编更像是对程序在机器层面运行的记录，它的每一步都通过机器语言从硬件层面记录下来，同时也可以优化人类所翻译的机器语言，提高了逻辑性，降低了人类的阅读性和理解性。说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。 4.5本章小结 通过汇编与反汇编的对比，用ELF表头显式地表现程序结构，从机器层面去了解和解释程序的运行变得更加容易。 第5章链接 5.1链接的概念与作用 链接的功能是将所有关联的可重定位目标文件组合起来，以生成一个可执行文件。可重定位目标文件和可执行目标文件都是机器语言目标文件，所不同的是前者是单个模块生成的，而后者是多个模块组合而成的。 5.2在Ubuntu下链接的命令 ld-ohello.ld-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 5.3可执行目标文件hello的格式 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。 5.4hello的虚拟地址空间 edb显示的与5.3中内容对应。 5.5链接的重定位过程分析 在获得的反汇编文件中，对于一些过程要比汇编生成的内容要详细，如生成了链接过程中才能指定的地址。在重定位中要对绝对地址进行引用，需要进行PC相对寻址；同时也将一些头文件的函数通过引用里libc.so加入到.text中。 5.6hello的执行流程 _init0x1000.plt0x1020_cxa_finalize@plt0x1080puts@plt0x1090printf@plt0x10a0getchar@plt0x10b0exit@plt0x10c0sleep@plt0x10d0_start0x10e0_libc_csu_fini0x10fa_libc_csu_init0x1101deregister_tm_clones0x1110_fini0x12c8 5.7Hello的动态链接分析 PIC函数调用了由共享库定义的函数，编译器无法预测函数的运行时的地址。GNU编译系统把函数地址的解析推迟到它实际被调用的地方。延迟绑定通过动态链接器使用过程链接表(PLT)和全局偏移量表(GOT)两个数据结构实现。GOT存放函数目标地址，PLT通过GOT中存储的地址间接跳转至目标函数。 当调用库内函数时，控制流会跳转到相应函数的PLT表中，PLT会通过GOT把将要调用的函数序号压入栈中，然后调用动态链接器；动态链接器会进行重定位，用栈中的地址重写入GOT，替代GOT原先用来跳转到PLT的地址变为实际的函数地址，再把控制传递给调用函数和PLTPLT，再次通过GOT间接跳转。 本章小结 本章讲述链接的过程，最终生成可执行文件，并且对执行过程进行对比，使我对链接的理解更加深刻。 第6章hello进程管理 6.1进程的概念与作用 进程就是程序的一次运行过程。更确切地说，进程是一个具有一定的独立功能的程序关于某个数据集合的一次运行活动，因而进程具有动态意义。计算机处理的所有任务实际上都是由进程来完成的。 6.2简述壳Shell-bash的作用与处理流程 Shell接收用户命令，调用相关程序：读取命令并处理得到的参数；判断命令的类型，对不同类型命令分情况执行；处理信号，更新进程状态；判断输入发出信号。 6.3Hello的fork进程创建过程 子进程通过fork()函数来创建。子进程相当于当前进程的一个复制本，但是其发展走向与父进程并不一定完全相同；此外，由fork函数创建的子进程其pid一定不为0，故fork函数返回值为0，这就意味着pid为0时为子进程，这为判断进程提供了方法。子进程继续运行函数的剩余部分，子进程也可以有自己的子进程，父进程和子进程的运行顺序按照拓扑排序执行，所有进程一直运行直到进程终止。 6.4Hello的execve过程 excve函数在上下文中加载运行一个新程序，在这里它加载hello可执行文件，之后调用启动代码，并且传递控制。 6.5Hello的进程执行 系统执行进程时，内核可以暂停当前进程，同时启用其他进程，这个过程就是调度，而这些进程以及它们的PC值所构成的序列就是逻辑控制流。当进程被执行时，内核代码不断地根据上下文信息，时间片等进行判断，并根据其结果转移控制权并完成调度。 6.6hello的异常与信号处理 正常情况没有干扰下，内容打印10遍乱按情况下没有影响ctrl+c直接结束程序Ctrl+z程序挂起ps查看程序运行状态jobs查看作业pstree查看进程关系fg程序继续运行kill杀死进程 6.7本章小结 本章介绍fork和execve函数，通过shell介绍命令和进程以及信号处理过程。 第7章hello的存储管理 7.1hello的存储器地址空间 逻辑地址：由程序产生，其内容是与段相关的偏移地址，由段标识符和段内偏移量组成。线性地址：当一个地址空间的地址是连续的非负整数时，该地址空间中的地址被称为线性地址。虚拟地址：CPU通过虚拟地址寻址，然后通过MMU(内存管理单元)将虚拟地址转换为物理地址。物理地址：计算机主存被划分成连续字节大小的内存组成的数组，每个字节都有唯一一个地址，这个地址就是物理地址。 7.2Intel逻辑地址到线性地址的变换-段式管理 全局描述符表GDT：通常来说系统只定义了一个GDT，用来存放系统内每个任务都可能访问的描述符。局部描述符表LDT：存放进程专用的描述符首先，判断段选择描述符中T1字段的数字，可知当前将要转换的是GDT中的段，还是LDT中的段；再根据指定的相应寄存器，得到其地址和大小，得到一个数组。抽取段选择符中的前13位，在这个数组中查找到对应的段描述符，这样就有了Base。把基地址Base+Offset，得到要转换的下一个阶段地址。 7.3Hello的线性地址到物理地址的变换-页式管理 虚拟缓存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须判定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判定这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换掉牺牲页。这些功能是由软硬件联合提供的，包括操作系统软件，MMU(内存管理单元)中的地址翻译硬件和一个存放在物理内存中的骄傲做页表的数据结构，页表会将虚拟页映射到物理页。首先，根据控制寄存器CR3给出的页目录表首地址找出页目录表，由DIR字段提供的10位页目录索引找到对应的页目录项，每个页目录项大小为4B；然后，根据页目录项中20位基地址指出的页表首地址找到对应页表，再根据线性地址中间的页表索引(PAGE字段)找到页表中的页表项；最后，将页表项中的20位及地址和线性地址中的12位页内偏移量组合成32位物理地址。 7.4TLB与四级页表支持下的VA到PA的变换 为了减小缓存次数，往往把页表中最活跃的几个页表项复制到高速缓存中，这种在高速缓存中的页表项组成的页表称为后被转换缓冲器(TLB)。在VA到PA的变换过程中，虚拟地址被分割成4个9位的片。在这里，CR3寄存器包含L1页表的物理地址。VPN1有一个到L1PTE的偏移量，找到这个PTE以后又会包含到L2页表的基础地址；VPN2包含一个到L2PTE的偏移量，找到这个PTE以后又会包含到L3页表的基础地址；VPN3包含一个到L3PTE的偏移量，找到这个PTE以后又会包含到L4页表的基础地址；VPN4包含一个到L4PTE的偏移量，找到这个PTE以后就是相应的PPN。7.5三级Cache支持下的物理内存访问组选择：组索引位标识组，如图7.5.1所示。 行匹配和字选择：行匹配检查多个行的标记位和有效位，以确定所请求的字是否在集合中。传统的内存是一个值的数组以地址作为输人，并返回存储在那个地址的值。另一方面,相联存储器是一个(key,value)对的数组，以key为输人，返回与输人的key相匹配的(key,value)对中的value值，因此我们可以把组相联高速缓存中的每个组都看成一个小的相联存储器，key是标记和有效位，而value就是块的内容。 图7.5.3展示了相联高速缓存中行匹配的基本思想。这里的一个重要思想就是组中的任何一行都可以包含任何映射到这个组的内存块。所以高速缓存必须搜索组中的每一行寻找一个有效的行，其标记与地址中的标记相匹配，如果高速缓存找到了这样一行，那么我们就命中，块偏移从这个块中选择一个字。 7.6hello进程fork时的内存映射 当fork函数被当前进程调用时，内核为新进程创建各种数据结构,并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存,它创建了当前进程的rm_struct、区城结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 7.7hello进程execve时的内存映射 execve函数在当前进程中加载并运行包含在可执行目标文件hello的程序,用hello程序有效地替代了当前程序。加载并运行hello需要以下儿个步骤： 删除已存在的用户区城。删除当前进程虚拟地址的用户部分中的已存在的区域结构。映射私有区城。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的,text和,data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆区域也是请求二进制零的，初始长度为零，图7.7.1概括了私有区域的不同映射。映射共享区域。hello程序与共享对象(或目标)链接，这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。设置程序计数器(PC)。execve做的最后一件事情就是设置当前进程上下文中的粘序计数器，使指向代码区域的入口点。下一次调度这个进程时，它将从这个入口开始执行。Linux将根据需要换入代码和数据页面。 7.8缺页故障与缺页中断处理 假设MMU在试图翻译某个虚报地址A时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤： 虚报地址A是合法的吗？换句话说，A在某个区域结构定义的区域内吗？为了回答这个向题，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的,那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图7.8.1中标识为”1”。因为一个进程可以创建任意数量的新虚拟内存区域，所以顺序搜索区域结构的链表花销可能会很大，因此在实际中，Linux使用某些没有显示出来的字段，Linux在链表中构建了一棵树，并在这棵树上进行查找。试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个页面是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程，这种情况在图7.8.1中标为”2”。此刻，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表，当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU。这次，MMU就能正常地翻译A，而不会再产生缺页中断了。 7.9动态存储分配管理 动态内存分配器维护者一个进程的虚拟内存区域，称为堆。系统之间的细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护者一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。空闲块可以保持空闲，直到它显式地被应用所分配。一个已分配的块保持分配状态，直到它被释放，这种释放要么是应用程序显式执行，要么是内存分配器自身隐式执行。分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。 显式分配器(explicitalloeator)，要求应用显式地释放任何已分配的块。例如，C标准库提供一种叫做malloc程序包的显式分配器，C程序通调洲用mal1oc函数来分配一个块，并通过调用Free函数来释放一个块，C中的new和delete操作符与C中的mal1oc和Free相当。隐式分配器(implicitalocator)，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器(garbagecollector)，而自动释放未使用的块的过程叫做垃圾收集。 7.10本章小结 深入了解了hello程序运行时在内存中的映像，展示虚拟内存和物理内存之间的关系。 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：文件设备管理：unixio接口所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入输出都被当作相对应文件的读和写。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为UnixI/O。 8.2简述UnixIO接口及其函数 1.打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访间一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。2.Linuxshell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0)、标准输出（描述符为1)和标准错误（描述符为2)。头文件<unistd.h>定义了常量STDIN_FILENO、STOOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值。3.改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k,初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为K。4.读写文件。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k~m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF符号”。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。 UnixI/O函数：1.进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件的。intopen(char*filename,intflags,mode_tmode);open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件，mode参数指定了新文件的访问权限位。返回：若成功则为新文件描述符，若出错为-1。2.进程通过调用close函数关闭一个打开的文件。intclose(intfd);返回：若成功则为0,若出错则为-1。3.应用程序是通过分别调用read和write函数来执行输入和输出的。ssize_tread(intfd,void*buf,size_tn);read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。ssize_twrite(intfd,constvoid*buf,size_tn);write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。返回：若成功则为写的字节数，若出错则为-1。 8.3printf的实现分析 https://www.cnblogs.com/pianist/p/3315801.html从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用int0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章了解了系统级I/O下的文件操作和管理方法，以printf和getchar两个函数为例分析了库函数的实现。（第8章1分）结论hello.c通过预处理生成hello.ihello.i通过编译生成hello.shello.s通过汇编生成hello.ohello.o通过链接生成hellohello被IO执行，分配内存空间。开始运行后，系统不断接收和发出信号调节和维持进程状态。运行结束后，系统释放缓存，清除数据，还原状态。 附件 列出所有的中间产物的文件名，并予以说明起作用。Hello.i：预处理生成文件Hello.s：汇编语言文件Hello.o：可重定位文件Hello：可执行生成文件Hello.elf：elf表头文件，是txt的可读取文件Hello.txt：反汇编文件，用来和hello.s对比 参考文献 为完成本次大作业你翻阅的书籍与网站等[1]林来兴.空间控制技术[M].北京：中国宇航出版社，1992：25-42.[2]辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国科学出版社，1999.[3]赵耀东.新时代的工业工程师[M/OL].台北：天下文化出版社，1998[1998-09-26].http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.[4]谌颖.空间交会控制理论与方法研究[D].哈尔滨：哈尔滨工业大学，1992：8-13.[5]KANAMORIH.ShakingWithoutQuaking[J].Science，1998，279（5359）：2063-2064.[6]CHRISTINEM.PlantPhysiology:PlantBiologyintheGenomeEra[J/OL].Science，1998，281：331-332[1998-09-23].http://www.sciencemag.org/cgi/collection/anatmorp. 

计算机系统作业(大黑书csapp第二章部分课后作业）（一） 计算机系统作业(大黑书csapp第二章部分课后作业）（一） 哈尔滨工业大学2019级计算机系统作业（一） 深入理解计算机系统（csapp)第二章2.59,2.63,2.67,2.71,2.75,2.79,2.83,2.87,2.91题目答案（2.61以后的题目符合书本第88页位级整数编码规则的要求），19级的小菜鸡自己写+参考（ctrl+c,ctrl+v）以往大佬的（侵删），难免有错误，还请批评指正QAQ。 2.59 typedefunsignedchar*type_pointer; voidshow_byte(type_pointerstart,size_tlen) { printf("%02X",start[len]); } intmain(void) { intx,y,i; printf("Pleaseinputthedataofxandy:"); scanf_s("%d%d",&x,&y); printf("0x"); for(i=sizeof(int)-1;i>0;i--) { show_byte((type_pointer)&y,i); } show_byte((type_pointer)&x,0); } 2.63 unsignedsrl(unsignedx,intk) { unsignedxsra=(int)x>>k; intx_1=(1<<((sizeof(int)<<3)-k))-1; xsra&=x_1; returnxsra; } intsra(intx,intk) { intxsrl=(unsigned)x>>k; intx_1=1<<((sizeof(int)<<3)-k-1); x_1&=xsrl; x_1=~((x_1<<1)-1); xsrl|=x_1; returnxsrl; } intmain(void) { intx,k; printf("Pleaseinputthenumberofxandk:"); scanf_s("%d%d",&x,&k); printf("%08X,%8X",srl(x,k),sra(x,k)); } 2.67 A.编译器信息警告应是数据超过位宽范围，猜测SUNSPARC这样的机器int型应该是16位. B.分次左移，将intbeyond_msb=1<<32;改为intbeyond_msb=1<<31;beyond_msb=beyond_msb<<1; C. /*Thefollowingcodedoesnotrunproperlyonsomemachines*/ intbad_int_size_is_16(){ /*Setmostsignificantbit(msb)of16-bitmachine*/ intset_msb=1<<15; /*Shiftpastmsbof16-bitword*/ intbeyond_msb=1<<15; beyond_msb=beyond_msb<<1; /*set_msbisnonzerowhenwordsize>=16 beyond_msbiszerowhenwordsize<16*/ returnset_msb&&!beyond_msb; } 2.71 A.在return(word>>(bytenum<<3))&0xFF;中，代码实现的是无符号扩展的32位，与要求不符. B. /*Correctlyattemptatxbyte*/ intxbyte(packed_tword,intbytenum) { intbyte,i; byte=(word>>(bytenum<<3))&0xFF; i=1<<7; i=byte&i; i=i<<1; i=i-1; i=~i; byte=byte|i; returnbyte; } 2.75 这段我写的有些离谱，因为不能用循环，只好把代码手动重复32遍，写完之后发现自己题目可能理解错了（w不确定是多少），所以这一题真的是仅供参考TAT intsigned_high_prod(intx,inty) { longlongunsignedlx,ly,lx0,byte_get,w,start,test; lx=(unsigned)x,ly=(unsigned)y,w=0; start=1,test=0; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; start=start<<1,test=0,lx=lx<<1; byte_get=start&ly; test=test-byte_get|0; w+=lx&test; return(int)(w>>32); } unsignedunsigned_high_prod(unsignedx,unsignedy) { returnsigned_high_prod((int)x,(int)y); } intmain(void) { unsignedx,y; scanf_s("%u%u",&x,&y); printf("%x,%x\n",x,y); printf("%x\n",unsigned_high_prod(x,y)); } 2.79 这题写的可能有问题 floatmul3div4(intx) { intnum1; num1=x+(x<<1); floatnum=num1; *((int*)&num)-=0b1000000000000000000000000; returnnum; } intmain(void) { intx; scanf_s("%d",&x); printf("%f",mul3div4(x)); } 2.83 A.该值num=Y/(2^k-1)就是一个等比数列求无穷大的极限。 B.(a)5/7(b)2/5©19/63 2.87 描述HexMEVD-0800000-0-0.0最小的>2的值3C011025/1024152.0019531252.0019535125FFF2047/102423512512.0最大的非规格数03FF1023/102400.0000609750.000061-infFC00---inf-inf十六进制表示为3BB0的数3BB01.921875140.96063750.960638 2.91 A.0x40490FDB=0b01000000010010010000111111011011,对应浮点数3.141593，二进制表示为0b11.001000110 B.22/7=0b11.001001001001001001… C.小数点后第六位. 

HIT计算机系统（CSAPP）大作业 计算机系统 大作业 题目程序人生-Hello’sP2P 专业计算机 学号xxxx 班级1936603 学生xxx 指导教师刘宏伟 计算机科学与技术学院 2021年6月 摘要 本文借助hello程序的运行过程介绍了计算机系统的底层知识：程序加工、进程执行、存储管理等。主要采用实验验证的方法，通过在Ubuntu操作系统+x64cpu上分解hello程序运行的各个阶段，展示一个“小生命”从新生到结束的过程，最终达到深入理解计算机系统的目的。能够使读者在日常的编程中提高系统能力，从计算机系统去考虑问题，而不仅仅是考虑数据结构和算法。 **关键词：**计算机系统；Linux；程序的运行；进程管理；存储管理； （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分） **** 目录 第1章概述-5- 1.1Hello简介-5- 1.2环境与工具-5- 1.3中间结果-5- 1.4本章小结-6- 第2章预处理-7- 2.1预处理的概念与作用-7- 2.2在Ubuntu下预处理的命令-7- 2.3Hello的预处理结果解析-8- 2.4本章小结-10- 第3章编译-11- 3.1编译的概念与作用-11- 3.2在Ubuntu下编译的命令-11- 3.3Hello的编译结果解析-12- 3.3.1全局变量-12- 3.3.2main函数的参数-12- 3.3.3局部变量-13- 3.3.4字符串常量-13- 3.3.5比较操作-13- 3.3.6分支语句-13- 3.3.7循环语句-14- 3.3.8数组操作-14- 3.3.9函数调用-15- 3.3.10函数返回-16- 3.4本章小结-16- 4.1汇编的概念与作用-17- 4.2在Ubuntu下汇编的命令-17- 4.3可重定位目标elf格式-17- 4.3.1ELF头-17- 4.3.2节-18- 4.3.3节头表-19- 4.4Hello.o的结果解析-21- 4.5本章小结-24- 第5章链接-25- 5.1链接的概念与作用-25- 5.2在Ubuntu下链接的命令-25- 5.3可执行目标文件hello的格式-25- 5.4hello的虚拟地址空间-28- 5.5链接的重定位过程分析-30- 5.6hello的执行流程-32- 5.7Hello的动态链接分析-34- 5.8本章小结-35- 第6章hello进程管理-36- 6.1进程的概念与作用-36- 6.2简述壳Shell-bash的作用与处理流程-36- 6.3Hello的fork进程创建过程-37- 6.4Hello的execve过程-38- 6.5Hello的进程执行-39- 6.6hello的异常与信号处理-40- 6.7本章小结-44- 第7章hello的存储管理-45- 7.1hello的存储器地址空间-45- 7.1.1逻辑地址-45- 7.1.2线性地址-45- 7.1.3虚拟地址-45- 7.1.4物理地址-45- 7.1.5hello的地址空间-45- 7.2Intel逻辑地址到线性地址的变换-段式管理-46- 7.3Hello的线性地址到物理地址的变换-页式管理-46- 7.4TLB与四级页表支持下的VA到PA的变换-47- 7.5三级Cache支持下的物理内存访问-49- 7.6hello进程fork时的内存映射-50- 7.7hello进程execve时的内存映射-51- 7.8缺页故障与缺页中断处理-52- 7.9动态存储分配管理-52- 7.10本章小结-54- 第8章hello的IO管理-55- 8.1Linux的IO设备管理方法-55- 8.2简述UnixIO接口及其函数-56- 8.2.1打开和关闭文件-56- 8.2.2读和写文件-56- 8.3printf的实现分析-57- 8.4getchar的实现分析-59- 8.5本章小结-59- 结论-60- 附件-64- 参考文献-65- 第1章概述 1.1Hello简介 本论文会从一个hello程序的一生作为示例，分析一个C语言程序在linux+ X64环境下所要经历的全部内容。 首先从编写高级语言源程序开始，我们需要建立一个hello.c文件，并按照特定的语法写入程序，但是此时的程序还不能执行，我们需要经过预处理（展开头文件、宏定义等）、编译（翻译为汇编语言程序）、汇编（翻译为可重定位的目标程序）、链接（生成可执行的目标程序），最终生成一个可以执行的程序hello。 接着，这个程序要想运行，需要在shell中输入命令./hello1190401018黄子扬，shell在磁盘上找到相应的程序，现fork一个子进程，接着用execve将hello的上下文加载入这个子进程，并开始执行。程序执行结束后，它并不会立刻完全消失，需要等待父进程将其回收，至此，它才能完全从世界上消失。 在控制流执行的过程中，离不开硬件的帮忙，而现代的处理器的流水线设计，大大提高了吞吐率，使得不同程序的取值、译码、执行、访存、写回、更新PC六大阶段可以在一定条件下并行，极大的提高了运行速率。 程序当然是需要存储空间的了，当前的系统具有四级页表、三级cache、还有容量超大的主存和磁盘，如此复杂却又精细的一套内存管理系统，让hello能够尽情的运行在计算机系统上。cpu从虚拟地址开始，首先查找TLB，如果直接找到则能直接翻译为物理地址，否则则按照级别从多级页表中查找，最终翻译为物理地址，接着又到L1cache中去寻找我们要的字节数据，如果没找到，则按照存储体系从上到下继续寻找。 1.2环境与工具 列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。 软件环境：Windows1064位；Vmware15.6；Ubuntu20.04LTS64位 硬件环境：X64CPU；2GHz；2GRAM；256GHDDisk 开发与调试工具：gcc、gdb、vscode、readelf、edb 1.3中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 附件1hello.c 作用：高级语言源程序 附件2hello.i 作用：预处理生成的.i文件 附件3hello.s 作用：编译生成的.s文件（汇编语言文件） 附件4hello.o 作用：汇编生成的.o文件（可重定位的目标文件） 附件5hello.elf 作用：hello.o的elf格式，用于展示可重定位的elf文件格式 附件6hello.asm 作用：hello.o的反汇编格式，用汇编语言的格式来观察可重定位的目标文件 附件7hello 作用：链接生成的可执行的目标文件 附件8hello_exe.elf 作用：hello的elf格式，用于展示可执行的elf文件格式 附件9hello_exe.asm 作用：hello的反汇编格式，用汇编语言的格式来观察可执行的目标文件 1.4本章小结 本章从总体上介绍了hello程序的一生，主要从p2p的过程，即从高级语言源程序到正在执行的进程的过程，和020的过程，即从程序还没开始执行到最终进程被回收的过程，这两个过程来展开的。 本章的精华涵盖了一个程序执行的几乎所有方面：预处理、编译、汇编、链接、fork子进程、execve切换上下文、进程信号机制、硬件执行流程（F、D、E、M、W、U）、从cache到磁盘的存储体系、进程回收机制等。 （第1章0.5分） 第2章预处理 2.1预处理的概念与作用 概念：预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。典型地，由预处理器(preprocessor)对程序源代码文本进行处理，得到的结果再由编译器核心进一步编译。通常由以下几个操作组成： 头文件展开：将#include包含的文件插入到该指令位置 宏展开：展开所有的宏定义，并删除#define 条件编译：处理所有的条件预编译指令：#if、#ifdef、#else删除注释 添加行号和文件名标识：编译调试时显示行号信息 保留#pragma命令 作用： 宏定义可以简化我们的编程，赋予一个常量有意义的特定的名字，在编程中可以方便程序员的操作，在预处理后会统一进行替换； 头文件的包含可以帮助程序员调用其他模块定义的函数、功能，方便将一个大型程序进行系统化、模块化、组件化； 注释只是在源文件中帮助程序员理解而写的文字，完全没必要在编译的时候考虑，所以一律删掉； 条件编译可以帮助程序员有选择地进行编译，针对不同情况进行处理； 添加行号信息则是方便程序员进行调试操作，能够在debug的时候快速定位错误位置。 2.2在Ubuntu下预处理的命令 gcc-m64-no-pie-fno-PIC-Ehello.c-ohello.i 图2-2-1预处理命令 图2-2-2预处理后得到的文件hello.i 2.3Hello的预处理结果解析 我们打开预处理得到的hello.i文件可以发现，这其中有着大量的头文件展开后引入的内容，可以验证预处理其中的一个最大的作用就是解析头文件的引用，进而确定到具体的代码的位置。如图2-3-1所示。 图2-3-1hello.i中的头文件引入的内容 可以发现，在hello.i文件中，定义了大量的数据类型的别名。应该都是从系统库中引入的一些东西。如图2-2-3所示。 图2-3-2定义数据别名 我们可以发现，从一个简单到只有不到30行的程序，经过预处理后竟然有长达3000余行的代码。如图2-3-3。 图2-3-3预处理后源程序 2.4本章小结 本章简要介绍了c语言程序预处理的基本知识，从预处理指令到预处理后的文件的改变，我们可以看到程序的生成其实是很困难的，远不是我们表面看上去的那么简单。其中比较重要的是头文件和宏定义的展开。 （第2章0.5分） 第3章编译 3.1编译的概念与作用 概念： 编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序，即编译的目的是将高级语言源程序转化为汇编语言源程序，但本质上这两者都还是机器看不懂的程序，都是为了方便人能看懂，只是级别不太一样。汇编语言程序更加贴近底层，能够直接观察到代码操纵了哪些数据、哪些内存、哪些寄存器、发生了怎样的转换、控制流是如何传递和跳转的等等。 作用：1.扫描（词法分析），2.语法分析，3.语义分析，4.源代码优化（中间语言生成），5.代码生成，目标代码优化。 1.将源代码程序输入扫描器，将源代码的字符序列分割成一系列记号。 2.基于词法分析得到的一系列记号，生成语法树。 3.由语义分析器完成，指示判断是否合法，并不判断对错。又分静态语义：隐含浮点型到整形的转换，会报warning；动态语义：在运行时才能确定。 4.中间代码（语言）使得编译器分为前端和后端，前端产生与机器（或环境）无关的中间代码，编译器的后端将中间代码转换为目标机器代码，目的：一个前端对多个后端，适应不同平台。 5.编译器后端主要包括： 代码生成器：依赖于目标机器，依赖目标机器的不同字长，寄存器，数据类型等；目标代码优化器：选择合适的寻址方式，左移右移代替乘除，删除多余指令。 3.2在Ubuntu下编译的命令 gcc-m64-no-piefno-PIC-Shello.i-ohello.s 图3-2-1编译命令 图3-2-2编译后得到的文件hello.s 3.3Hello的编译结果解析 3.3.1全局变量 我们直到在C语言源程序中定义了intsleepsecs=2.5，这是一个已经初始化了的全局变量，我们在hello.s中观察，可以发现它是在.rodata节中的。 图3-3-1全局变量sleepsecs 3.3.2main函数的参数 由寄存器相关的知识，我们知道存储函数参数的前六个寄存器分别是%rdi，%rsi，%rdx，%rcs，%r8，%r9。根据汇编代码，我们可以发现argc和argv分别存储在%edi，%rsi中，并在一开始首先分别保存到了-20(%rbp)，-32(%rbp)的位置。 图3-3-2寄存器传递函数参数 3.3.3局部变量 我们知道局部变量一般直接存储在栈中。我们知道本题的循环变量i是一个局部变量，观察发现它若能执行到循环分支，则它被初始化为0，且存储在栈中。 图3-3-3局部变量存储在寄存器中 3.3.4字符串常量 字符串常量一般存储在.text节中。我们在汇编代码中可以发现，我们用到的两个字符串常量均在.text节中存储，并且各自有一个标号。 图3-3-4-1字符串常量的存储 我们还可以发现在使用字符串常量的时候，是直接使用标号来引用的。 图3-3-4-2通过标号来引用字符串常量 3.3.5比较操作 变量之间的不等关系是通过!=符号来实现的。而在汇编代码中的体现则是用cmp语句。 图3-3-5cmp语句的使用来比较两个变量的大小关系 3.3.6分支语句 分支语句是基于3.3.5中的比较语句加jxx跳转语句实现的，通过cmp设置的标志，达到一定条件则执行对应的分支。 图3-3-6分支的实现 3.3.7循环语句 循环也是通过比较加跳转语句来实现的。 初始值是0，和9作比较，总循环次数10次 图3-3-7循环的实现 3.3.8数组操作 我们知道数组的操作一般都是通过首地址加上偏移量得到的，我们在汇编代码中可以观察到这种方式用在了取argv中的字符串的地址。 argv数组中的内容存储在了栈中，我们从中取出对应的字符串的地址，并分别放到%rsi和%rdx中，作为printf的第二和第三个参数，最终输出到了屏幕上。 图3-3-8数组操作 3.3.9函数调用 函数调用在汇编中的实现很简单，就是调用call指令。在hello.s中执行多次。而函数参数的传递则类似于3.3.2中的描述。前六个参数分别存储于%rdi,%rsi,%rdx,%rcx,%r8,%r9，而剩余的参数则存放在栈中，位于返回地址的上面。 图3-3-9-1调用puts 图3-3-9-2调用printf 图3-3-9-3调用sleep 3.3.10函数返回 一般的函数返回前会有这样几个操作，恢复被调用者保存的寄存器的值，恢复旧的帧指针%rbp（不一定有这个操作），并跳转到原来的控制流的地址。最终一般都是以ret指令结尾的。 图3-3-10ret指令 3.4本章小结 本章的核心是汇编代码的深入理解。从核心知识上来说有这样几点：数据操作、算数运算、逻辑运算、流程控制、过程调用等等。我们从一个具体的汇编代码文件hello.s来总结整个汇编方面我们需要掌握的知识。 主要涉及到的有：全局变量、本地局部变量、字符串常量、分支语句、循环语句、比较操作、数组、函数调用、函数参数传递、函数返回。 （第3章2分）第4章汇编 4.1汇编的概念与作用 概念：汇编器将hello.s翻译成机器语言指令，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，是机器可以读懂的语言。在我们程序员的的角度来看，目标文件中就完全是乱码。 作用：将汇编语言翻译成可重定位的二进制目标文件。 4.2在Ubuntu下汇编的命令 图4-2-1汇编指令 图4-2-2汇编生成的hello.o文件 4.3可重定位目标elf格式 4.3.1ELF头 图4-3-1ELF头 上图是hello.o的ELF可重定位目标文件的格式。 ELF头以一个16字节的序列开始，这个序列描述生成了该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表（sectionheadertable）的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定的大小的条目。 具体代码格式如下： #defineEI_NIDENT16 typedefstruct{ unsignedchare_ident[EI_NIDENT];//包含用以表示ELF文件的字符，以及其他一些与机器无关的信息。开头的4个字节值固定不变，为0x7f和ELF三个字符。 Elf32_Halfe_type;//标识的是该文件的类型 Elf32_Halfe_machine;//表明运行该程序需要的体系结构 Elf32_Worde_version;//表示文件的版本 Elf32_Addre_entry;//程序的入口地址 Elf32_Offe_phoff;//表示Programheadertable在文件中的偏移量 Elf32_Offe_shoff;//表示Sectionheadertable在文件中的偏移量 Elf32_Worde_flags;//对IA32而言，此项为0 Elf32_Halfe_ehsize;//表示ELFheader大小 Elf32_Halfe_phentsize;//表示Programheadertable中每一个条目的大小 Elf32_Halfe_phnum;//表示Programheadertable中有多少个条目 Elf32_Halfe_shentsize;//表示Sectionheadertable中的每一个条目的大小 Elf32_Halfe_shnum;//表示Sectionheadertable中有多少个条目 Elf32_Halfe_shstrndx;//包含节名称的字符串是第几个节 }Elf32_Ehdr; 4.3.2节 在ELF头和节头表之间，存储的是各个节的内容。我们可以使用readelf-pnum<file>的命令来查看节的内容： 图4-3-2某几个节的内容 4.3.3节头表 节头表通常包含以下几个节： .text.rodata.data.bss.symtab.rel.text.rel.data.debug.line.strtab 图4-3-3-1典型的节头表格式 .text：已编译程序的机器代码 .rodata：只读数据，比如printf语句中的格式串和开关语句中的跳转表 .data：已初始化的全局和静态C变量。局部局部C变量在运行的时候保存在栈中，既不出现在.data节中，也不出现在.bss节中。 .bss：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态C变量。在目标文件中这个节不占用实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。 .symtab：一个符号表，它存放在程序中定义和引用的的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。 .rel.text：；一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件并不需要重定位信息，因此通常忽略，除非用户显示地指示链接器包含这些信息。 .rel.data：被模块引用或者定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都要被修改。 .debug：一个调试符号表，其条目时程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有以-g选项调用编译器驱动程序时，才会得到这张表。 .line：原始C程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译器驱动程序时，才会得到这张表。 .strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。 图4-3-3-2hello.o的节头表 4.4Hello.o的结果解析 我们将反汇编的结果输入到文件hello.asm中。 对比分析： 1.hello.s中是没有位置信息的，但是在hello.asm是有的，代码间是有顺序关系的。 图4-4-1hello.asm中代码是有位置信息的 图4-4-2hello.s中的代码是没有地址的 2.hello.asm中使用地址进行跳转，而hello.s中使用标号进行跳转 图4-4-3使用地址跳转 图4-4-4使用标号进行跳转 3.hello.asm中使用地址进行函数调用，而hello.s中使用函数名进行跳转 图4-4-5hello.asm中使用地址进行函数调用 图4-4-6hello.s中使用函数名进行函数调用 4.hello.asm中有重定位条目，而hello.s中没有 如图4-4-7中sleepsecs中的重定位格式是R_X86_64_PC32说明是PC相对的32位的地址，当前PC是main+64，减0x04后是main+60，正好是其应该填充的位置，在重定位后就会填充到这个位置。 重定位条目 图4-4-7重定位条目 图4-4-8hello.s中没有重定位条目 机器语言：就是机器可以直接识别执行的二进制代码，是我们人无法理解的语言，一般是由操作码和操作数构成的。比如call在机器语言中对应的编码就是e8，而操作数则是由是对应的编码的小端格式，如补码、IEEE754表示的浮点格式等等。 汇编语言：是人类为了方便编程，发明出来的和机器语言对应的编程语言，引入了助记符，帮助人们快速的对应复杂的二进制编码。 关系：汇编语言和机器语言基本上是一一对应的，每一条汇编语言实际上是一条机器语言的助记符形式。 4.5本章小结 本章我们把汇编语言源程序汇编成了可重定位的目标文件。分析了可重定位的目标文件的elf格式，elf头、节头表、符号表等等内容，理解了汇编后的二进制可重定位代码。知道了重定位条目的信息，当重定位形成可执行文件之后，就会在对应的位置填入相应的数据。 objdump工具可以帮助我们将可重定位的目标文件反汇编生成反汇编代码，进一步理解hello.o的内容。 （第4章1分） 第5章链接 5.1链接的概念与作用 概念： 链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存中并执行。链接可以执行于编译时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。在早期的计算机系统中，链接甚至是手动执行的。在现代系统中，链接是由叫做链接器的程序自动执行的。 作用： 链接器在软件开发中扮演着一个关键的角色，因为他们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需要简单地重新编译它，并重新链接应用，而不是重新编译其他文件。 5.2在Ubuntu下链接的命令 链接命令： ld-ohello-dynamic-linker/lib64/ld-linux-x86-64.so.2/usr/lib/x86_64-linux-gnu/crt1.o/usr/lib/x86_64-linux-gnu/crti.ohello.o/usr/lib/x86_64-linux-gnu/libc.so/usr/lib/x86_64-linux-gnu/crtn.o 图5-2-1链接指令 图5-2-2链接后生成的可执行目标文件 5.3可执行目标文件hello的格式 hello的elf格式和可重定位的目标文件的elf格式相类似。 图5-3-1可执行文件的elf格式 其中可以很明显的发现在Type一栏变成了EXEC，即可执行的。 地址 大小 图5-3-2节头表 5.4hello的虚拟地址空间 首先用edb加载hello程序。 图5-4-1使用edb加载hello 查看符号 图5-4-2符号 可以发现，和图5-3-2中的一致，interp都在0x4002e0。其他的节都在这附近，可以直接在symbols中或者datadump中观察到。 或者可以直接输入对应节的起始地址，直接再Bootmarks中查看。 图5-4-3-1直接用bootmarks查看地址内容 图5-4-3-2不存在地址的节 可以发现，最后着5个节都没有地址，因为他们的内容已经在连接后直接加入到了二进制代码之中，不需要再次存储了，可执行程序已经可以正常执行了。 5.5链接的重定位过程分析 链接的过程： 1.符号解析 目标文件(.o)定义和引用了符号； 每个符号对应着一个函数、一个全局变量或一个静态变量等； 其中函数、已初始化的全局变量或者静态变量是强符号，未初始化的全局变量或者静态变量是弱符号； 其中有三条链接时的规则：1.不允许由多个同名的强符号；2.如果有一个强符号和多个弱符号同名，那么选择强符号；3.如果由多个弱符号同名，那么从这些弱符号中任意选择一个； 符号解析的作用就是给每个符号引用分配一个精确的符号定义； 2重定位 编译器和汇编器生成的代码段和数据段的开始地址都是0； 链接器给每个符号定义分配一个内存地址，然后修改所有对这些符号的引用使得这些引用指向的是前面分配的内存地址； 链接器使用由汇编器生成的详细的指令(重定位条目)来执行这些重定位操作； hello没有了hello.o重定位条目，因为所有的地方都已经确定了位置，而hello.o因为还没有链接，所以还保留有许多汇编器生成的重定位条目供之后的链接使用。链接的本质是合并不同文件的相同节，如数据节合并在一起，而代码节合并在一起。在这个过程中因为文件要使用其他文件中符号的定义，所以就需要用到在汇编过程中生成的.rel.data和.rel.text节中的重定位信息。 具体看到hello和hello.o的差别，我们通过hello反汇编生成的hello_exe.asm和hello.asm作比较来查看。 首先最明显的差别就是地址的长度不同，未链接的文件中只是简单的使用相对偏移量，而链接后的文件中则是使用虚拟地址空间中的地址。 图5-5-1hello.asm中使用相对偏移量来作为地址 图5-5-2hello_exe.asm中使用虚拟地址 其次，在主函数中调用的函数都不是定义子该文件中的，而是定义在库文件中的，所以未链接时在文件中找不到这些函数的定义，而链接后则可以找到。 图5-5-3在链接后可以在反汇编代码中找到调用函数的定义 最后我们用一个可重定位条目翻译的例子来看重定位的过程： 图5-5-4一个重定位条目的例子 我们在已链接的文件中找到对应的地方。 可以发现其绝对地址时404044，但是是使用的PC相对引用，当程序执行到401163时，PC的值时401169，在加上相对的偏移值0x2edb，即为绝对地址404044。 5.6hello的执行流程 通过命令行输入参数执行程序 图5-6-1用edb执行hello程序 不断地stepinto，可以看到执行过的程序名，如： 图5-6-2hello!_start 执行过程： ld-2.27.so!_dl_start0x7fce8cc38ea0 ld-2.27.so!_dl_init0x7fce8cc47630 hello!_start0x400500 libc-2.27.so!libc_start_main0x7fce8c867ab0 -libc-2.27.so!__cxa_atexit0x7fce8c889430 -libc-2.27.so!__libc_csu_init0x4005c0 hello!_init0x400488 libc-2.27.so!_setjmp0x7fce8c884c10 -libc-2.27.so!_sigsetjmp0x7fce8c884b70 –libc-2.27.so!__sigjmp_save0x7fce8c884bd0 hello!main0x400532 hello!puts@plt0x4004b0 hello!exit@plt0x4004e0 *hello!printf@plt– *hello!sleep@plt– *hello!getchar@plt– ld-2.27.so!_dl_runtime_resolve_xsave0x7fce8cc4e680 -ld-2.27.so!_dl_fixup0x7fce8cc46df0 –ld-2.27.so!_dl_lookup_symbol_x0x7fce8cc420b0 libc-2.27.so!exit0x7fce8c889128 使用edb执行hello，说明从加载hello到_start，到callmain,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。 图5-6-3edb中的执行结果 5.7Hello的动态链接分析 动态链接主要是书上7.10到7.12的内容。 书上的解释是这样的：假设程序调用一个有共享库定义的函数。编译器无法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法时为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。GNU通过一种叫做延迟绑定的技术来将地址的绑定推迟到第一次调用该过程。 动态链接器使用过程链接表PLT和全局偏移量表GOT实现函数的动态链接。其中GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。 通过反汇编我们可以知道GOT和PLT的位置 图5-7-1GOT和PLT的位置 GOT是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]时动态链接器在ld-linux.so模块种的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT项目。 图5-7-2链接前的GOT 图5-7-3动态链接后的GOT 5.8本章小结 链接是现代编程思想的精华部分之一，链接器的出现，使得模块化的编程成为常态，分块编程，各自编译，最后链接是一个很自然的想法。同时，我们程序员也可以更好的使用库函数了。这得益于动态链接的出现，我们不用多次在文件中保存相同的代码，只需要用一个动态链接库，等到函数需要被调用时，再去取对应的代码就可以了。 而传统的静态链接有两个过程，首先是符号解析，需要重点知道强弱符号的规则，第二是重定位，需要知道解析引用的原则。 （第5章1分） 第6章hello进程管理 6.1进程的概念与作用 狭义概念：进程是正在运行的程序的实例 广义概念：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 这其中有两点最为重要的需要我们深入把握和理解： 第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域、数据区域和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。 作用：当在现代系统上运行一个程序的时候，我们会得到一个假象，就好像我们的程序时系统种当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中地指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象是通过进程的概念提供给我们的。 进程的并发性让我们能够同时运行多个程序在电脑上，而且看起来是在独占CPU的；进程异步性让我们同时运行多个程序时是互不影响的；进程的信号机制能够让不同的进程之间产生联系，让进程之间实现通信……进程是计算机科学中最伟大的概念之一，有了进程，才有我们今天的高性能PC机。 6.2简述壳Shell-bash的作用与处理流程 概念：在计算机科学中，Shell俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（commandinterpreter，命令解析器）。它类似于DOS下的COMMAND.COM和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。 CSAPP上的解释就是：shell是一个交互型的应用级程序，它代表客户运行其他程序。 功能:Shell连接了用户和Linux内核，让用户能够更加高效、安全、低成本地使用Linux内核,能够接收用户输入的命令，并对命令进行处理，处理完毕后再将结果反馈给用户，比如输出到显示器、写入到文件等。 在Shell中输入的命令，有一部分是Shell本身自带的，这叫做内置命令；有一部分是其它的应用程序（一个程序就是一个命令），这叫做外部命令。 Shell本身支持的命令并不多，功能也有限，但是Shell可以调用其他的程序，每个程序就是一个命令，这使得Shell命令的数量可以无限扩展，其结果就是Shell的功能非常强大，完全能够胜任Linux的日常管理工作，如文本或字符串检索、文件的查找或创建、大规模软件的自动部署、更改系统设置、监控服务器性能、发送报警邮件、抓取网页内容、压缩文件等。 处理流程： 1．Shell首先从命令行中找出特殊字符（元字符），在将元字符翻译成间隔符号。元字符将命令行划分成小块tokens。Shell中的元字符如下所示： SPACE,TAB,NEWLINE,&,;,(,),<,>,| 2．程序块tokens被处理，检查看他们是否是shell中所引用到的关键字。 3．当程序块tokens被确定以后，shell根据aliases文件中的列表来检查命令的第一个单词。如果这个单词出现在aliases表中，执行替换操作并且处理过程回到第一步重新分割程序块tokens。 4．Shell对~符号进行替换。 5．Shell对所有前面带有$符号的变量进行替换。 6．Shell将命令行中的内嵌命令表达式替换成命令；他们一般都采用$(command)标记法。 7．Shell计算采用$(expression)标记的算术表达式。 8．Shell将命令字符串重新划分为新的块tokens。这次划分的依据是栏位分割符号，称为IFS。缺省的IFS变量包含有：SPACE,TAB和换行符号。 9．Shell执行通配符*?[]的替换。 10．shell把所有从处理的結果中用到的注释删除，並且按照下面的顺序实行命令的检查： A.内建的命令 B.shell函数（由用户自己定义的） C.可执行的脚本文件（需要寻找文件和PATH路径） 11．在执行前的最后一步是初始化所有的输入输出重定向。 12．最后，执行命令。 6.3Hello的fork进程创建过程 我们在终端输入./hello1190401018黄子扬，回车后即开始了这个过程 图6-3-1进程执行的命令 此时，bash首先搜索这是否是一个内置命令，发现不是后，进程开始在磁盘上搜索，找到hello程序后，将其调入内存。 接着bash实行fork()函数，创建一个子进程，此时，该子进程拥有和父进程完全相同的虚拟地址空间副本，即是相对于父进程是独立的。如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。同时父进程和子进程是共享文件的。父进程和子进程的区别在于他们的进程号不同，即PID不同。 父进程和子进程在各自的虚拟地址空间内独立并发的向前推进。 简要介绍fork函数： pid_tfork(void); fork函数调用一次，却会返回两次：一次是在父进程中，一次是在新创建的子进程中。在父进程中，fork返回子进程的PID。在子进程中，fork返回0。因为子进程的PID总是为非0，返回值就提供了一个明确的方法来分辨程序是在父进程还是在子进程中执行。 6.4Hello的execve过程 但是此时fork出来的子进程并没有达到要执行hello程序的目的，我们还要求换上下文，去执行hello程序。 简要介绍execve函数： intexecve(constchar*filename,constchar*argv[],constchar*envp[]); 如果成功，则不返回，如果失败，则返-1。 execve函数加载并运行可执行目标文件filename，即hello程序，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序。 其中的参数列表：argv变量指向指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv[0]是可执行目标文件的名字。环境变量列表类似于参数列表，envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如“name=value”的名字-值对。 bash得到的子程序会去执行execve函数，去加载hello程序，它会首先调用启动代码，启动代码设置栈，并将控制传递给新程序的主函数，该主函数具有如下形式的原型： intmain(intargc,char**argv,char**envp); 当main开始执行时，用户栈的组织结构从栈底往栈顶依次是这样的：首先是参数和环境字符串，栈往上紧随其后的是以null结尾的指针数组，其中每个指针都指向栈中的一个环境变量字符串，全局变量environ指向这些指针中的第一个envp[0]。紧随环境变量数组之后的是以null结尾的argv[]数组，其中每个元素都指向栈中的一个参数字符串。在栈的顶部是系统启动函数libc_start_main的栈帧，接下来就是main函数执行后的即未来的栈帧了。 6.5Hello的进程执行 上下文信息：上下文就是内核重新启动一个被抢占的进程所需要的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。 进程时间片的概念：时间片（timeslice）又称为“量子（quantum）”或“处理器片（processorslice）”是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。现代操作系统（如：Windows、Linux、MacOSX等）允许同时运行多个进程 例如，你可以在打开音乐播放器听音乐的同时用浏览器浏览网页并下载文件。事实上，虽然一台计算机通常可能有多个CPU，但是同一个CPU永远不可能真正地同时运行多个任务。在只考虑一个CPU的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在Linux上为5ms－800ms），用户不会感觉到。 进程调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度，是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进城后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。 图6-5-1进程调度图示 hello程序一开始是运行在usercode中的，所以是不能执行kernel里的代码的，只能通过异常的方式，使其改变为内核模式，执行异常处理程序中的系统调用代码，即sleep函数。等待执行完后，又再依次切换到用户模式执行hello程序。 进程之间的上下文切换是在kernel里完成的，完成后，又退出内核模式，进入到用户模式，去执行切换后的进程，这就是调度的原理。 6.6hello的异常与信号处理 hello出现的异常：中断，陷阱（即系统调用） hello产生的信号：SIGINT、SIGTSTP、SIGCONT、SIGCHLD 我们首先先执行hello程序，并在执行了一会后输入Ctrl+C，直接终止它。进程会收到一个SIGINT信号。 图6-6-1进程收到SIGINT信号后终止 接着我们再次运行，用Ctrl+Z暂停进程。并且用ps命令查看进程，可以发现hello进程仍然存在。 图6-6-2进程收到SIGTSTP信号后停止 还可以使用jobs进行观察。 图6-6-3用jobs观察作业 用pstree观察进程树，我们可以在终端部分找到bash和hello进程。其中hello和pstree都是bash的子进程 可以看到hello进程是bash的子进程 图6-6-4进程树 我们使用kill指令为其传入一个SIGCONT信号，让它继续执行下去。 图6-6-5传入SGICONT信号让进程继续执行 我们使用kill指令为其传入一个SIGKILL信号杀死hello程序。 图6-6-6传入SIGKILL信号将进程杀死 6.7本章小结 进程是现代计算机科学最伟大的概念之一，它让计算机有了并发执行多个程序的能力，大大提高了计算机的性能。我们通过这章的学习，了解到了进程的基本概念、运行原理、进程的用户模式和内核模式、上下文切换、两个重要函数（fork和execve）、四大异常（终端、陷阱、故障、终止）、进程的并发执行等等。 通过这章的学习也让我们对操作系统有了基本的认识，只有有了操作系统，我们才能够控制冷冰冰的硬件来为我们工作。 （第6章1分） 第7章hello的存储管理 7.1hello的存储器地址空间 7.1.1逻辑地址 CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址（偏移地址），不和绝对物理地址相干。 7.1.2线性地址 CPU在保护模式下，“段基址+段内偏移地址”叫做线性地址，注意，保护模式下段基址寄存器中存储的不是真正的段基值（和实模式的含义不一样），而是被称为“段选择子”的东西，通过段选择子在GDT（全局描述表）中找到真正的段基值。另外，如果CPU在保护模式下没有开启分页功能，则线性地址就被当做最终的物理地址来用，若开启了分页功能，则线性地址就叫虚拟地址（在没开启分页功能的情况下线性地址和虚拟地址就是一回事）。但是，如果开启分页功能，虚拟地址（或线性地址）还要通过页部件电路转换成最终的物理地址。 7.1.3虚拟地址 虚拟地址并不真实存在于计算机中。每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间。理论上，虚拟空间受物理内存大小的限制，如给有4GB内存，那么虚拟地址空间的地址范围就应该是0x00000000~0xFFFFFFFF。每个进程都有自己独立的虚拟地址空间。这样每个进程都能访问自己的地址空间，这样做到了有效的隔离。 7.1.4物理地址 物理地址就是内存单元的绝对地址，比如你有一个4G的内存条插在电脑上，物理地址0x0000就表示内存条的第一个存储单元，0x0010就表示内存条的第17个存储单元，不管CPU内部怎么处理地址，最终访问的都是物理地址。在CPU实模式下“段基址+段内偏移地址”就是物理地址，CPU可以使用此地址直接访问内存。 7.1.5hello的地址空间 hello程序主要使用的就是从虚拟地址到物理地址变换的这一套机制，来实现其虚拟地址空间的独立化，但是同时又能精确的映射到对应的物理空间，使其和其他的程序的地址空间隔离。 7.2Intel逻辑地址到线性地址的变换-段式管理 在段式存储管理中，将程序的地址空间划分为若干个段(segment)，这样每个进程有一个二维的地址空间。在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在段式存储管理系统中，则为每个段分配一个连续的分区，而进程中的各个段可以不连续地存放在内存的不同分区中。 程序加载时，操作系统为所有段分配其所需内存，这些段不必连续，物理内存的管理采用动态分区的管理方法。在为某个段分配物理内存时，可以采用首先适配法、下次适配法、最佳适配法等方法。在回收某个段所占用的空间时，要注意将收回的空间与其相邻的空间合并。段式存储管理也需要硬件支持，实现逻辑地址到物理地址的映射。 程序通过分段划分为多个模块，如代码段、数据段、共享段：可以分别编写和编译；可以针对不同类型的段采取不同的保护；可以按段为单位来进行共享，包括通过动态链接进行代码共享。这样做的优点是：可以分别编写和编译源程序的一个文件，并且可以针对不同类型的段采取不同的保护，也可以按段为单位来进行共享。 总的来说，段式存储管理的优点是：没有内碎片，外碎片可以通过内存紧缩来消除；便于实现内存共享。缺点与页式存储管理的缺点相同，进程必须全部装入内存。 图7-2-1段式管理 7.3Hello的线性地址到物理地址的变换-页式管理 将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(pageframe)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。 在页式系统中进程建立时，操作系统为进程中所有的页分配页框。当进程撤销时收回所有分配给它的页框。在程序的运行期间，如果允许进程动态地申请空间，操作系统还要为进程申请的空间分配物理页框。操作系统为了完成这些功能，必须记录系统内存中实际的页框使用情况。操作系统还要在进程切换时，正确地切换两个不同的进程地址空间到物理内存空间的映射。这就要求操作系统要记录每个进程页表的相关信息。 图7-3-1页式管理 7.4TLB与四级页表支持下的VA到PA的变换 首先在TLB中查找PTE，若能直接找到则直接得到对应的PPN，具体的操作是将VPN看作TLBI和TLBT，前者是组号，后者是标记，根据TLBI去对应的组找，如果TLBT能够对应的话，则能够直接得到PTE，进而得到PPN。 图7-4-1从TLB寻找PTE 其中若是在TLB中找不到对应的条目，则应去多级页表中查找，VPN被分为了四块。有一个叫做CR3的寄存器包含L1页表的物理地址，VPN1提供到了一个L1PET的偏移量，这个PTE包含L2页表的基地址，VPN2提供到一个L2PTE的偏移量。依次类推，最终找到页表中的PTE，得到PPN。 图7-4-2四级页表的查询 而VPO和PPO相等，最终的PA等于PPN+PPO。 7.5三级Cache支持下的物理内存访问 PA又被分为了CT、CI、CO分别是标志位、组号和偏移量。首先我们根据组号在L1cache中找到对应的组，然后挨个比较标志位，如果标志位对应且有效位为1，则说明发生了hit，然后根据CO偏移量得到我们想要取的数据就可以了。如果发生了miss，则依次到L2cache、L3cache、主存中去找。 图7-5-1三级cache的示意图 具体的翻译过程： CT即相当于t，CI即相当于s，CO即相当于b。根据cache的工作机制，即先到对应的组去找，然后一一匹配t，检查v，最终若找到则根据b取数据，若没有找到则到更低级的存储中去取数据。 图7-5-2cache的具体翻译过程 7.6hello进程fork时的内存映射 内核为hello程序维护一个单独的任务结构（源代码中的task_struct）。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（例如，PID、指向用用户栈的指针、可执行目标文件的名字、PC）。 图7-6-1hello如何组织虚拟内存 当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 当fork从新进程返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的概念。 7.7hello进程execve时的内存映射 加载hello并执行需要以下几个步骤： 1.删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构（即mmap指向的vm_area_structs）。 2.映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域时请求二进制0的，映射到匿名文件，其大小包括在hello中。栈和堆区域也是请求二进制0的，初始长度为0. 3.映射共享区域。如果hello程序域共享对象链接，比如C标准库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 4.设置程序计数器（PC）。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。 图7-7-1加载器映射用户地址空间的区域 7.8缺页故障与缺页中断处理 若MMU在翻译一个虚拟地址A时，触发了一个却页。这个却页将导致控制转移到内核的却页处理程序。却页处理程序会执行以下的步骤： 1.搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止进程。 2.检查这个却页是否为一条试图对这个代码段里的只读页面进行写操作的存储指令造成的，或者是否为一个运行在用户模式中的进程试图从内核虚拟内存中读取数据字造成的。如果试图进行的访问时不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。 3.若上面两条都不是触发缺页的理由，则此时内核知道了这个缺页是由于对合法的的虚拟地址进行合法的操作造成的。内核会选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU，此时，MMU就能正常的翻译A了。 图7-8-1缺页处理 7.9动态存储分配管理 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量brk，指向堆的顶部。 分配器有两种风格，但是这两种风格都要求应用显示的分配块。 其中显示分配器要求显示释放任何已分配的块，如malloc、new等。 隐式分配器要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。所以也叫垃圾收集器。 显示分配器有以下几点要求：能够处理任意请求序列；立即相应请求；只是用堆；对齐开；不修改已分配的块。 在性能上有两点追求： 1.最大化吞吐率； 2.最大化内存利用率； 但是这两点通常是对立的。 具体的技术有以下几种： 隐式空闲列表 块大小（最低位保存a/f）有效载荷（只包括已分配的块）填充（可选，为了保持双字对齐）块大小（最低位保存a/f） 显示空闲列表 图7-9-1显示空闲列表图示 7.10本章小结 本章是理解计算机系统存储的重中之重，从内存的分页式管理，到三级cache的高层内存管理，再到一个程序内部的堆的管理。其中的思想十分复杂，却又十分精妙，不得不让人感叹前人的智慧。 正是有了这么多从上到下分层的内存管理机制，计算机系统才能有条不紊、并且快速的运行程序。CPU首先发出指令要取某个数据，然后MMU首先去查TLB，如果没有得到就通过4级页表，查找物理地址，得到物理地址后，又通过三级cache，不断的从上到下去寻找我们要的数据，最不济得到磁盘上去读数据，那会造成巨大的时间开销。而如果我们在程序执行的时候需要动态的申请堆空间的话，就需要用到动态分配器了，一般在C语言中使用的是malloc和free的组合。 （第7章2分） 第8章hello的IO管理 8.1Linux的IO设备管理方法 设备的模型化：所有的IO设备（例如网络、磁盘、终端）都被模型化为文件。每个linux文件都有一个类型来表明他在系统中的角色： 普通文件：包含任意数据。 目录：包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。每个目录至少含有两个条目：“.”是到该目录自身的链接，以及“…”是到目录层次结构中父目录的链接。 套接字：用来与另一个进程进行跨网络通信的文件。 图8-1-1linux文件组织结构模型 设备管理：IO是在主存和外部设备之间复制数据的过程。输入操作是从IO设备复制数据到主存，而输出操作时从主存复制数据到IO设备。所有的IO色号被被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许linux内核引出一个简单、低级的应用接口，称为UnixI/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行： 1.打开文件。内核返回一个小的非负整数，叫做描述符，用于标识文件。 2.stdin的描述符为0，stdout的描述符为1，stderr的描述符为2。 3.改变当前文件的位置：用seek操作。 4.读写文件：读时从文件到内存，写时从内存到文件。 5.关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为相应，内核释放文件打开时创建的数据结构，并将它使用的文件描述符恢复到可以使用的描述符池中去。 8.2简述UnixIO接口及其函数 8.2.1打开和关闭文件 intopen(char*filename,intflags,mode_tmode); 若打开文件成功则返回文件描述符，否则返回-1。 flags有多种O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（可读可写）、O_CREAT（如果文件不存在，就创建它的一个截断的空文件）、O_TRUNC（如果文件已经存在，就截断它）、O_APPEND（在每次写操作前，设置文件位置到文件的结尾处）。 mode参数指定访问权限位。 图8-2-1访问权限位 intclose(intfd); 会关闭一个打开的文件，如果关闭一个已关闭的文件描述符会出错。 8.2.2读和写文件 ssize_tread(intfd,void*buf,size_tn); 若成功则返回读的字节数，若EOF则为0，若出错则为-1。 ssize_twrite(intfd,constvoid*buf,size_tn); 若成功则返回为写的字符数，若出错则返回-1。 read函数从描述符为fd的当前位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。 write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。可以通过调用lseek函数，显示地修改当前文件的位置。 8.3printf的实现分析 printf的函数体如下： intprintf(constchar*fmt,…){inti;charbuf[256]; va_listarg=(va_list)((char*)(&fmt)+4);i=vsprintf(buf,fmt,arg);write(buf,i); returni;} va_listarg=(va_list)((char*)(&fmt)+4);是在找第一个参数，其中va_list是一个字符指针。 下面，则执行vsprintf，以下是vsprintf的函数体： intvsprintf(char*buf,constchar*fmt,va_listargs) { char*p; chartmp[256]; va_listp_next_arg=args; for(p=buf;*fmt;fmt++){ if(*fmt!=‘%’){ *p++=*fmt; continue; } fmt++; switch(*fmt){ case‘x’: itoa(tmp,*((int*)p_next_arg)); strcpy(p,tmp); p_next_arg+=4; p+=strlen(tmp); break; case‘s’: break; default: break; } } return(p-buf); } 这个函数返回的是要打印的字符串的长度。 接下来要调用write函数，我们反汇编追踪一下： write:moveax,_NR_writemovebx,[esp+4]movecx,[esp+8]intINT_VECTOR_SYS_CALL 我们可以找到INT_VECTOR_SYS_CALL的实现： init_idt_desc(INT_VECTOR_SYS_CALL,DA_386IGate,sys_call,PRIVILEGE_USER); 可以发现它是要调用sys_call这个函数： sys_call:callsavepushdword[p_proc_ready]stipushecxpushebxcall[sys_call_table+eax*4]addesp,4*3mov[esi+EAXREG-P_STACKBASE],eaxcliret 接着执行字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。 最后显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。 8.4getchar的实现分析 getchar()是stdio.h中的库函数，它的作用是从stdin流中读入一个字符，也就是说，如果stdin有数据的话不用输入它就可以直接读取了，第一次调用getchar()时，确实需要人工的输入，但是如果你输了多个字符，以后的getchar()再执行时就会直接从缓冲区中读取了。 下面是它的函数实现： intgetchar(void) { staticcharbuf[BUFSIZ]; staticchar*bb=buf; staticintn=0; if(n==0) { n=read(0,buf,BUFSIZ); bb=buf; } return(–n>=0)?(unsignedchar)*bb++:EOF; } 异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。 getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。 8.5本章小结 本章简要总结了unixI/O的有关知识，通过对外部设备的模型化实现简单、贯通的读写操作，将所有的IO设备看作文件，通过简单的几个系统函数的组合就完成了各种的读写操作。同时还提供了一种树结构的文件管理模式，并且把目录也抽象为了一种文件。 需要我们重点在编程中掌握read、write、lseek、open、close等基本函数，深入理解内部机制，做到安全的对文件进行读写。 （第8章1分） 结论 hello程序的从诞生到结束要经历很多个过程。它的一生是无数人类计算机科学家智慧的结晶，也是现代信息文明高度发达的果实。 其中第一个，也是完全面向我们程序员的过程，就是用我们的双手一个字母一个字母的将程序敲入电脑中的编辑器里。或许是因为所处的时代高度发达，我们这一代的程序员不用再去考虑许许多多额外的复杂的东西，各种花里胡哨的编辑器层出不穷，更有集成开发环境（IDE）降维打击。我最常用的编辑器有notepad++、sublimeText、vscode，其中vscode背靠微软，功能最为强大，插件生态最为完善，全世界的程序员都在使用这样一款工具。当我们按下键盘，将这样几行字母敲进机器中，一个高级语言（C）源程序就这样诞生了，如图1-1。 图9-1-1hello.c源程序 接着，我们将这个文件保存在了磁盘上，我们终于有了hello.c这个文件。 图9-1-2hello.c源文件 此时虽然我们已经有了源文件，但是它是它，电脑是电脑，谁也不认识谁，要想让它在电脑上执行，我们必须把这个文件中的语句翻译成机器能够认识的语句，这个时候我们的编译工具gcc就登场了。从高级语言到源程序到可执行文件中间需要经历五个步骤： 预处理： 图9-1-3预处理指令 图9-1-4预处理生成的.i文件 编译： 图9-1-5编译指令 图9-1-6编译生成的.s文件 汇编： 图9-1-7汇编指令 图9-1-8汇编生成的.o文件 链接： 图9-1-9-1链接指令1 图9-1-9-2链接指令2 图9-1-10链接生成的可执行文件hello 在经历了如此繁杂的过程后，我们终于得到了我们想要的可执行文件hello，打开终端（terminal），输入执行的命令和命令行参数，我们终于得到了我们预期的实验结果： 图9-1-11hello程序的执行效果 这样看起来简单但是十分伟大的现象终于出现在了我们的眼前。从程序执行开始到完全消失又是一个十分繁杂的过程： 首先，我们打开了终端，运行着一个名为bashshell的程序，接着，我们欲运行一个我们自己写的程序hello，操作系统为我们fork了一个子进程，此时这个子进程（childprocess）拥有着自己独立的进程号（pid），它拥有着于父进程（parentprocess）完全一样但是又独立的虚拟地址空间，并且继承了父进程打开的所有文件的描述符，这就意味着可以往父进程打开的文件中读写数据。 然后，操作系统使用execve，在当前子进程的上下文中加载并运行hello程序。 一个程序的执行不可只能只依赖软件，本质上所有软件的运行都是依赖硬件的。流水线的设计，使得指令的执行速度大大提高，取值、译码、执行、访存、写回、更新PC，不同指令的6大阶段可以重叠执行（无冒险情况下），大大提高了程序的运行速度。 为了更高效的利用存储单元，我们根据存储单元的存取速度和单位造价对存储单元进行了分级，从最顶层的cpu、cache逐渐往下，分别是：主存（DRAM）、本地二级存储（本地磁盘）、远程二级存储（分布式文件系统、网络服务器）等。其中，每一级存储作为下一级存储的缓存，cpu会优先从更高级的存储中去找数据和指令，当找不到时，才会从更低级的存储中去不断地加载到更加高级地存储。 一个程序地上下文（context）是如此地难以管理，操作系统是通过虚拟内存地概念来解决了这个问题，是的每一个独立的程序看上去好像都是独立的占有cpu一样。操作系统通过mmu计算虚拟地址（virtualaddress）和物理地址（physicaladdress）的关系，得到物理地址后，进而又按照从cache到主存再到磁盘的顺序查找想要的数据。这其中，为了加速地址计算和查找的过程，又引入了TLB和页表的概念，读一次磁盘的代价是十分巨大的，因此每次读都需要读很大一块，我们称之为页，数据是按页从磁盘读取读取到主存上的，通常的页的大小是4K。 那么屏幕作为一个外部文件是如何与hello程序产生联系的呢。Linux操作系统会把所有的外部IO设备模型化为一个文件，这样，我们对一个设备的IO操作就模型化为了对一个文件进行的IO操作，我们可以从文件中读，也可以向文件中写。而这个hello程序正是向标准输出流 屏幕上，写出了一系列字符串，在程序的结尾又使用getchar函数从标准输入流 键盘读入了一个字符。 进程的执行还受信号的影响，如我们人为的在终端输入CTRL+C，就可以向所有前台进程发送一个SIGINT信号，终止进程的执行。 图9-1-12子进程收到SIGINT信号后终止 但是进程终止后，并不会立即从这个世界上小时，它仍然会以僵死进程的形式存在在系统中，占用着资源。当父进程将其回收后，它才会从系统中彻底消失。 （结论0分，缺失-1分，根据内容酌情加分） 附件 列出所有的中间产物的文件名，并予以说明起作用。 附件1hello.c 作用：高级语言源程序 附件2hello.i 作用：预处理生成的.i文件 附件3hello.s 作用：编译生成的.s文件（汇编语言文件） 附件4hello.o 作用：汇编生成的.o文件（可重定位的目标文件） 附件5hello.elf 作用：hello.o的elf格式，用于展示可重定位的elf文件格式 附件6hello.asm 作用：hello.o的反汇编格式，用汇编语言的格式来观察可重定位的目标文件 附件7hello 作用：链接生成的可执行的目标文件 附件8hello_exe.elf 作用：hello的elf格式，用于展示可执行的elf文件格式 附件9hello_exe.asm 作用：hello的反汇编格式，用汇编语言的格式来观察可执行的目标文件 （附件0分，缺失-1分） 参考文献 为完成本次大作业你翻阅的书籍与网站等 [1]CSAPP3ed [2]https://blog.csdn.net/xiaosaizi/article/details/105669070 [3]https://blog.csdn.net/huoyahuoya/article/details/53083424 [4]https://www.cnblogs.com/mlgjb/p/8241718.html [5]https://blog.csdn.net/mzjmzjmzjmzj/article/details/84713351?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162393596716780265440699%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162393596716780265440699&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-84713351.first_rank_v2_pc_rank_v29&utm_term=%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80&spm=1018.2226.3001.4187 [6]https://blog.csdn.net/fuzhongmin05/article/details/58061584 [7]https://www.cnblogs.com/pianist/p/3315801.html （参考文献0分，缺失-1分） 

第21次CCF计算机软件能力认证CSP-202009-2-风险人群筛查（详细注释版） #include<iostream> usingnamespacestd; typedefstructcoordinate//定义坐标类型，处理更加方便 { intx,y; }coordinate; intmain(void) { intn,k,t,xl,yd,xr,yu;//按题目中要求命名一致，思路更清晰 cin>>n>>k>>t>>xl>>yd>>xr>>yu;//第一行输入 coordinatepos[n][t];//坐标，用矩阵n*t矩阵存储总的位置信息 for(inti=0;i<n;i++) { for(intj=0;j<t;j++) { cin>>pos[i][j].x>>pos[i][j].y; } } intpass=0;//经过人数 intstay=0;//逗留人数 for(inti=0;i<n;i++) { inttemp=0;//temp用于记录连续多少个节点经过危险区域 boolflag=false;//标志变量标志是否经过危险区域 for(intj=0;j<t;j++) { if(pos[i][j].x>=xl&&pos[i][j].x<=xr&&pos[i][j].y>=yd&&pos[i][j].y<=yu) { flag=true; temp++; if(temp>=k)//当连续的经过点数量达到k时直接跳出循环 break; } else { temp=0; } } if(!flag); elseif(flag&&temp<k)pass++;//只经过不逗留 else//逗留一定经过 { pass++; stay++; } } cout<<pass<<'\n'<<stay; return0; } 

第20次CCF计算机软件能力认证CSP-202006-1-线性分类器 #include<iostream> usingnamespacestd; typedefstructnode { intx,y; chartype; }coordinate; intmain(void) { intn,m; cin>>n>>m; coordinatepoint[n]; for(inti=0;i<n;i++) { cin>>point[i].x>>point[i].y>>point[i].type; } inttheta0[m],theta1[m],theta2[m]; for(inti=0;i<m;i++) { cin>>theta0[i]>>theta1[i]>>theta2[i]; } for(inti=0;i<m;i++) { boolflag=(theta0[i]+(theta1[i]*point[0].x)+(theta2[i]*point[0].y))>0; booltemp=true; for(intj=1;j<n;j++) { if(point[j].type==point[0].type) { if(((theta0[i]+(theta1[i]*point[j].x)+(theta2[i]*point[j].y))>0)==flag) continue; else{ temp=false; break; } } else { if(((theta0[i]+(theta1[i]*point[j].x)+(theta2[i]*point[j].y))>0)!=flag) continue; else { temp=false; break; } } } if(temp)cout<<"Yes"<<endl; elsecout<<"No"<<endl; } return0; } 

CCF计算机软件能力认证考试CSP-202006-2稀疏向量 #include<iostream> usingnamespacestd; #include<map> typedefstructnode { intindex; intvalue; }node; intmain(void) { intn,a,b; longlongintsum=0;//大数用longlongint，要不然会溢出 cin>>n>>a>>b; map<int,int>v1; for(inti=0;i<a;i++) { nodetemp; cin>>temp.index>>temp.value; v1[temp.index]=temp.value; } for(inti=0;i<b;i++) { nodetemp; cin>>temp.index>>temp.value; if(v1[temp.index]!=0) sum+=v1[temp.index]*temp.value; } cout<<sum; return0; } //必须用map动态创建键值对，要不然空间太大，内存不够 //也不能两个向量暴力匹配，时间复杂度太高，时间过不去 

CCF计算机软件能力认证考试CSP-201912-2回收站选址 #include<iostream> usingnamespacestd; #include<map> typedefstructnode { longlongx,y; boolisrecy; intscore; }coordinate; boolisrecy(coordinatep,coordinatepos[],intn) { boolflag1=false,flag2=false,flag3=false,flag4=false; for(inti=0;i<n;i++) { if(pos[i].x-1==p.x&&pos[i].y==p.y)flag1=true; elseif(pos[i].x+1==p.x&&pos[i].y==p.y)flag2=true; elseif(pos[i].x==p.x&&pos[i].y+1==p.y)flag3=true; elseif(pos[i].x==p.x&&pos[i].y-1==p.y)flag4=true; } if(flag1&&flag2&&flag3&&flag4)returntrue; elsereturnfalse; } intscore(coordinatep,coordinatepos[],intn) { intscore=0; for(inti=0;i<n;i++) { if(p.x-1==pos[i].x&&p.y-1==pos[i].y)score++; elseif(p.x-1==pos[i].x&&p.y+1==pos[i].y)score++; elseif(p.x+1==pos[i].x&&p.y+1==pos[i].y)score++; elseif(p.x+1==pos[i].x&&p.y-1==pos[i].y)score++; } returnscore; } intmain(void) { intn; cin>>n; coordinatepos[n]; for(inti=0;i<n;i++) { cin>>pos[i].x>>pos[i].y; } for(inti=0;i<n;i++) { pos[i].isrecy=isrecy(pos[i],pos,n); } for(inti=0;i<n;i++) { pos[i].score=0; } for(inti=0;i<n;i++) { if(isrecy(pos[i],pos,n)){ pos[i].score=score(pos[i],pos,n); } } intscore[5]={0}; for(inti=0;i<n;i++) { if(isrecy(pos[i],pos,n)){ score[pos[i].score]++; } } for(inti=0;i<5;i++) { cout<<score[i]<<endl; } return0; } 

第21次CCF计算机软件能力认证CSP-202009-1-称检测点查询 题目背景 2020年6月8日，国务院联防联控机制发布《关于加快推进新冠病毒核酸检测的实施意见》，提出对“密切接触者”等八类重点人群“应检尽检”，其他人群“愿检尽检”。 问题描述 某市设有n个核酸检测点，编号从1到n，其中i号检测点的位置可以表示为一个平面整数坐标(xi,yi)。 为方便预约核酸检测，请根据市民所在位置（x，y），查询距其最近的三个检测点。多个检测点距离相同时，编号较小的视为更近。 输入格式 输入共n+1行。 第一行包含用空格分隔的三个整数n、x和y，表示检测点总数和市民所在位置。 第二行到第n+1行依次输入n个检测点的坐标。第i+1行（1<=i<=n）包含用空格分隔的两个整数xi和yi，表示i号检测点所在位置。 输出格式 输出共三行，按距离从近到远，依次输出距离该市民最近的三个检测点编号。 样例输入1 322222324 样例输出1 123 样例输入2 501-10001002-12 样例输出2 241 代码如下： #include<iostream> usingnamespacestd; #definemax200 typedefstructdist { intx; inty; }dist; intmain(){ dista[max]; intn,x,y; cin>>n>>x>>y; intresult[n]; boolflag[n]; for(inti=0;i<n;i++) { flag[i]=false; cin>>a[i].x>>a[i].y; result[i]=(a[i].x-x)*(a[i].x-x)+(a[i].y-y)*(a[i].y-y); } intnum[3]; intk; for(inti=n-1;i>=n-3;i--) { k=n-1; for(intj=n-2;j>=0;j--) { if(result[j]<=result[k]&&!flag[j]) { k=j; } } num[n-1-i]=result[k]; flag[k]=true; } for(inti=0;i<3;i++) { for(intj=0;j<n;j++) { if(result[j]==num[i]&&flag[j]) { cout<<j+1<<'\n'; flag[j]=false; } } } return0; } 

