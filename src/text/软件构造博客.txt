第0篇文章[0]
Java中的List类的contains和indexOf方法的区别 问题： 在对List类的使用中，有一次使用到了contains和indexOf方法，而出现预期以外的错误，考虑到List中的元素都为引用类型，因此想知道List的contains和indexOf方法的结果是否与引用对象相关。 代码实例如下： importjava.util.ArrayList; importjava.util.List; publicclassTemp { publicstaticvoidmain(String[]args)throwsException { List<String>list=newArrayList<String>(); for(inti=0;i<10;i++){ list.add(String.valueOf(i)); } //使用contains System.out.println(list.contains("5")); //使用indexOf System.out.println(list.indexOf("5")); System.out.println(list.indexOf(newString("5"))); List<People>peoples=newArrayList<People>(); Peoplea=newPeople("a"); Peopleb=newPeople("b"); Peoplenewa=newPeople("a"); peoples.add(a); peoples.add(b); //使用contains System.out.println(peoples.contains(newa)); //使用indexOf System.out.println(peoples.indexOf(newa)); } } classPeople{ privateStringname; /** *@paramname */ publicPeople(Stringname){ this.name=name; } @Override publicinthashCode(){ finalintprime=31; intresult=1; result=prime*result+((name==null)?0:name.hashCode()); returnresult; } @Override publicbooleanequals(Objectobj){ if(this==obj) returntrue; if(obj==null) returnfalse; if(getClass()!=obj.getClass()) returnfalse; Peopleother=(People)obj; if(name==null){ if(other.name!=null) returnfalse; }elseif(!name.equals(other.name)) returnfalse; returntrue; } /** *@returnthename */ publicStringgetName(){ returnname; } } 运行结果如下： 由此可见，如果List的泛型重写了equals方法，则contains和indexOf方法都可以正常工作，而不需要要求参数为List中的同一个引用对象，只需要值相同即可。 而将equals去掉之后，其他代码不变，发现结果如下： 发现contains和indexOf方法都判定newa这个对象不在peoples这个List中。 如果再将此行改为： //使用contains System.out.println(peoples.contains(a)); //使用indexOf System.out.println(peoples.indexOf(a)); 运行结果如下： 结果再一次正确。 总结： contains和indexOf方法是一致的。如果希望值相同就可以在List中找到，则需要重写List<L>的L中的equals方法。如果希望引用相同，则不可以重写L中的equals方法。 
第1篇文章[0]
Java软件构造SoftwareConstruction(四） 第三次实验相关 关于Java自带类Date与Calendar的使用关于正则表达式 关于Java自带类Date与Calendar的使用 Dated=newDate();//创建一个代表系统当前日期 d=Date(2021-1900,7-1,1);//创建一个代表2021.7.1日期的Date，注意参数的设置 //获取年月日方法如下 intyear=d.getYear()+1900; intmonth=d.getMonth()+1; intdate=d.getDate(); 然后就发现这小破玩意基本被更厉害的Calendar替代了QAQ这里再介绍关于Calendar的使用Calendar是一个抽象类，且加上了protected修饰，所以要用其getInstance方法来构造 Calendars=Calendar.getInstance();//默认当前日期 s.set(2021,7-1,1);//调用set来设置，如此设置为2021.7.1 //获取日期要用Calendar自带的常数来进行获取 //获得年月日 intyear=s.get(Calendar.YEAR); intmonth=s.get(Calendar.MONTH)+1; intdate=s.get(Calendar.DATE); 关于正则表达式 首先要注意的是，在java中\表示插入一个正则表达式的反斜线，其后的字符具有特殊的意义一些常用的匹配为 字符说明+一次或多次匹配前面的字符或子表达式。?零次或一次匹配前面的字符或子表达式。*零次或多次匹配前面的字符或子表达式。{n}n是非负整数。正好匹配n次。x或符号y匹配x或y。[xyz]字符集。匹配包含的任一字符。[a-z]字符范围。匹配指定范围内的任何字符。\d数字字符匹配。等效于[0-9]。 对于模式匹配的基本操作为 Stringcontent="asdjdsfjsdlf13213asakd.,[l[12"; Patternpattern=Pattern.compile("[a-z]{3}"); Matchermatcher=pattern.matcher(content); if(matcher.find()){ System.out.println("YES"); } 
第2篇文章[0]
Java软件构造SoftwareConstruction（五） 第三次实验相关 关于Scanner与java.util.NoSuchElementException关于正则表达式（续）关于捕获组 关于gitcheckout 关于Scanner与java.util.NoSuchElementException 一次关闭（System.in)后则永久关闭，再次打开会出现java.util.NoSuchElementException错误。 关于正则表达式（续） 注意大括号属于特殊字符需要加\{来匹配 关于捕获组 捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。特殊的组group(0)代表整个表达式。下列代码为捕获一个,152-1234-1234}中152-1234-1234电话号的实例 Stringphone=newString(); pattern=Pattern.compile(",(\\d{3}-\\d{4}-\\d{4})\\}"); matcher=pattern.matcher(content); if(matcher.find()==true){ phone=matcher.group(1); } elsereturnfalse; 关于gitcheckout git创建新分支的操作为 gitbranchbranchName 切换到新分支的操作为 gitcheckoutbranchName 将这两个操作合并在一起为 gitcheckout-bbranchName 在切换分支是是对当前HEAD指针指向的变化下图为本次实验分支指向的变化 
第3篇文章[0]
Java软件构造（七） 杂项总结 抽象类适配器内聚和耦合表示泄露default方法LSP和JAVAset与mutable黑盒与白盒最后的最后 抽象类 在多种设计模式中，均有采用继承抽象类来复用代码，同时进行委派实现个性化的操作 适配器 设计模式中最不擅长的一种模式，这是一种结构型模式，是直接进行委派不适配是，增加接口在适配器子类中进行转换适配和隐藏之前委派的一种模式。 内聚和耦合 高内聚低耦合是软件工程的重要概念，描述的功能应该是单一、简单、易理解且模块化的。 表示泄露 不仅影响不变性，也影响表示独立性，检查时从public-private、外部参数赋值给可变属性，返回值为可变属性等几个方面来进行检查。 default方法 通过其在接口中统一实现某些功能。无需在各个类中重复实现它，增量式增加而不破坏原来的类。 LSP和JAVA 子类型方法参数的逆变，在实际运行中算为overloadQAQ。同时Arrays也是协变的。Generics不是协变的。 set与mutable mutable对象在set集合类中发生改变后，集合类行为不确定。 黑盒与白盒 白盒着眼于代码，黑盒着眼于模块，如白盒测试和黑盒测试，一个需要检查代码，一个只关注最后行为，白盒复用源代码可见，黑盒复用源代码不可见，白盒框架代码层面的继承，黑盒框架是实现特定接口/delegation进行框架扩展。 最后的最后 明天就是期末考试了，越复习越觉得之前写的代码还有很多很多可以修改的地方，想着时间再多一点，再尽善尽美一些。日升不滞哇，总会有遗憾，但遗憾是完善的过程，所以不能停止思考，更不能停止书写代码，不断前行，朝着理想的彼岸，绝对的理念进发。 
第4篇文章[0]
Java软件构造Softwareconstruction(三) 第三次实验部分及相关课程学习 相关课程可复用性四个层次上的可复用性LSP原则LiskovSubstitutionPrinciple委派delegation 可维护性5个设计原则SOLIDSRPOCPISPDIP 面向可维护性和可复用性的设计模式创建型模式StructuralpatternsBehavioralpatterns 第三次实验关于github 相关课程 可复用性 四个层次上的可复用性 代码层次，模块层次：类/接口，库层次：API/包，系统层次：框架 LSP原则LiskovSubstitutionPrinciple 子类型多态：客户端可用统一的方式处理不同类型的对象Sameorstrongerinvariants更强的不变量Sameorweakerpreconditions更弱的前置条件Sameorstrongerpostconditions更强的后置条件所以子类型方法参数为逆变，子类型返回值为协变，异常类型为协变协变即为越来越具体，逆变即为越来越抽象 委派delegation 委派：一个对象请求另一个对象的功能委派模式：通过运行时动态绑定，实现对其他类中代码的动态复用当子类只需要复用父类的一部分方法时，就可以不需要使用继承，而用委派机制来实现，同时一个类不需要继承另一个类的全部方法，就通过委派机制调用部分方法。委派的三种类型是，Use，Association，Composition/aggregation 可维护性 5个设计原则SOLID SRP:单一责任原则OCP:开放-封闭原则LSP:Liskov替换原则DIP：依赖转置原则ISP：接口聚合原则 SRP 不应该有多于1个原因让你的ADT发生变化，否则就拆分开 OCP 模块的行为可扩展，模块的代码不应该修改，解决方案：抽象技术 ISP 不能强迫客户端依赖于他们不需要接口，只提供必要接口 DIP 抽象的模块不应依赖于具体的模块 面向可维护性和可复用性的设计模式 创建型模式 工厂方法模式：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 Structuralpatterns 适配器模式：通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。装饰器模式：当特性需要组合时，对每一个特性构造子类，通过委派机制增加到对象上，就像穿一层又一层的衣服 Behavioralpatterns 策略模式：有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里模板模式：做事情的步骤一样，但具体方法不同，共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。迭代器模式：客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型visitor模式：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT。 第三次实验 关于github github在一开始的时候抽风了QAQ，所以一直没有创建仓库，等github好了的时候再创建仓库pull的时候发现查询后发现出现这个问题是因为本地仓库和远程仓库变成独立两个仓库了（一开始没有clone仓库）pull命令后紧接着使用–allow-unrelated-history选项来解决问题。 
第5篇文章[0]
软件构造JavaSoftware(二） 第二次实验与相关课程总结 课程总结抽象数据类型可变数据类型不可变数据类型operationsofanabstracttype表示独立性测试抽象数据类型不变量AbstractionFunction 面向对象接口Interface重载与重写抽象类泛型 第二次实验总结关于测试优先关于Safetyfromrepexposure和Representationinvariant关于文件读入总结 课程总结 抽象数据类型 抽象数据类型与表示独立性：如何设计良好的抽象数据结构，通过封装来避免客户端获取数据的内部表示（即“表示泄露”），避免潜在的bug 在client和implementer之间建立“防火墙” 可变数据类型 可变类型的对象：提供了可改变其内部数据的值的操作，例如List 不可变数据类型 不变数据类型：其操作不改变内部值，而是构造新的对象，例如int,String operationsofanabstracttype 构造器：可能实现为构造函数或静态函数变值器：改变对象属性的方法，通常返回为void观察器：观察对象属性，如Thesize()methodofList生产器：从旧的对象中创建一个新的对象，如concat()methodofString 表示独立性 client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。 测试抽象数据类型 测试creators,producers,andmutators：调用observers来观察这些operations的结果是否满足spec；测试observers：调用creators,producers,andmutators等方法产生或改变对象，来看结果是否正确。 不变量 immutability是典型的不变量。immutable的抽象数据类型不能有变值器。对于一些属性不变量，采用privatefinal进行修饰，同时采用防御式编程来保证其不变性。 AbstractionFunction 由表示空间映射到抽象空间称为AF。ADT开发者关注表示空间R，client关注抽象空间A，它是满射但未必单射，也未必双射。 面向对象 接口Interface Interface和Class:定义和实现ADT接口之间可以继承与扩展一个类可以实现多个接口一个接口可以有多种实现类接口中只确定ADT规约而不具体实现方法，实际当中更倾向于使用接口来定义变量。使用接口来完成信息隐藏，客户端仅使用接口中定义方法，客户端无法直接访问属性。 重载与重写 关于重写/覆盖：若超类中加了final修饰则无法重载，重写的函数的具体使用是在运行时决定，重写的函数参数与原函数相同。关于重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型，方便client调用，client可用不同的参数列表，调用同样的函数，重载函数是在编译时进行的静态类型检查。 抽象类 介于接口与类之间，如果某些操作是所有子类型都共有，但彼此有差别，可以在父类型中设计抽象方法，在各子类型中重写 泛型 泛型是一种类型变量，泛型类，泛型接口，泛型方法，其定义中包含了类型变量 第二次实验总结 关于测试优先 设计测试样例时避免重复造轮子，看似写了很多行测试样例，但却没有实际发现错误，同时对于equals和==这部分测试要多留心。 关于Safetyfromrepexposure和Representationinvariant 对于表示的独立性采用checkRep来进行检查，checkRep使用assert语句如assertvertices2.equals(vertices);对于表示泄露的预防，所有属性都采用privatefinal修饰，并且都采用Collections.unmodifiableSet或者new一个新值来进行防御式拷贝。 关于文件读入 在第一次实验中采用了一种文件读入方法，这里采用另一种文件读入打开文件输入流，用scanner按行读入，然后采用分隔符或正则语言进行匹配 InputStreamis=newFileInputStream(corpus); Scannerscan=newScanner(is); while(scan.hasNext()){ List<String>inputString=Arrays.asList(scan.nextLine().split("")); Iterator<String>it=inputString.iterator(); StringlastString=newString(); StringnowString=newString(); while(it.hasNext()){ lastString=nowString; nowString=it.next(); nowString=nowString.toLowerCase(); graph.add(nowString); intnowWeight; if(lastString.isEmpty()==false){ nowWeight=graph.set(lastString,nowString,0); graph.set(lastString,nowString,nowWeight+1); Map<String,Integer>targets=graph.targets(lastString); } } } 总结 没学习那些概念之前，做实验稍显吃力，学习了之后发现不过按图索骥，实现起来又较为简单 
第6篇文章[0]
Java软件构造SoftwareConstruction（一） Java软件构造SoftwareConstruction（一） 文章目录 Java软件构造SoftwareConstruction（一） 前言第一节课内容自我总结第一次实验git操作java读入命令行读入文件读入 一些总结 前言 已经做好学习信息安全专业的准备，那么在学习这门课程时，也就有了自己在心中定下的要求。课上也提到本课内容及其丰富，虽然压缩了一些学时，但内容没有减少太多。也许未来会有些痛苦吧：），但现在站在山脚下的我，窥不见山的全貌，也难体会爬山的苦累。那么就只是爬山就好了，功不唐捐罢，积跬步至千里罢，进一步有进一步的欢喜罢，不管山有多高，只是不停爬山罢。也许有一天能一览众山小，能守得云开见月明，而我记录下这些足迹，告诉自己这些太远的路，是因为什么而出发。 第一节课内容自我总结 第一次实验 git操作 使用gitremote的操作来链接远程仓库采用的较多的操作分别为` gitremote//列出当前远程分支 gitremote-v//列出当前远程分支带url的信息 gitremoteaddorigin@git.com:~~~~~//以ssh的方式，本地远程分支命名为origin来连接仓库 gitremotermorigin//删除本地指定为origin的远程地址 gitadd.//将文件添加至暂存区 gitcommit-m""//将暂存区内容上传至本地仓库,-m后接备注信息 gitpushoriginmaster//上传至远程仓库，后两项为远程仓库名和分支名 java读入 命令行读入 一开始采用如下方法判断 publicstaticintcommand_line_input(intcitations[]){ intpaper_num=0;//初始化数组长度 Scannerscan=newScanner(System.in);//创造输入流对象 while(scan.hasNextInt()){ citations[paper_num++]=scan.nextInt();//读入论文 if(citations[paper_num-1]<0){//当论文引用量小于0时为非法输入 illegal_input(); scan.close(); return-1; } }`在这里插入代码片` if(scan.hasNext()){//若读入了非整型数字，同样为非法操作 illegal_input(); scan.close(); return-1; } scan.close(); returnpaper_num; } 后发现，while(scan.hasNextInt())无法处理读入回车停止的问题，于是采用先读入一行字符串后转换为int的形式进行 publicstaticintcommand_line_input(intcitations[]){ Scannerscan=newScanner(System.in);//创造输入流对象 Stringcitations_string[]=null;//初始化读入字符串 citations_string=scan.nextLine().split("");//读入带空格字符串 scan.close(); intpaper_num=citations_string.length;//初始化数组长度 citations=newint[paper_num]; for(inti=0;i<paper_num;i++){ try{ citations[i]=Integer.valueOf(citations_string[i]); } catch(Exceptione){//遇到不是数字的情况输出非法信息 illegal_input(); return-1; } if(citations[i]<0){ illegal_input();//引用量小于0也输出非法信息 return-1; } } returnpaper_num; } 文件读入 首先是关于File类的一些基础性问题，在引用绝对路径时，注意不同操作系统文件路径分隔符不同的问题，采用File.separator来解决此类问题，即 Filefile=newFile("d:"+File.seprator+"xx.txt"); 也可以用相对路径的方法新建File对象，根目录为project的根文件夹 Filefile=newFile(""src"+File.separator+"test"+File.separator+"input.txt"); 对于文件读入问题，可新建一个字节输入流，然后再读入即可 InputStreamis=newFileInputStream("src"+File.separator+"test"+File.separator+"input.txt"); Scannerfile_scan=newScanner(is); 一些总结 java的数组为引用传递 
第7篇文章[0]
Java软件构造Softwareconstruction（六） 复习与思考 软件构造的多维度视图和质量目标多维度视图具体某些重要视图 质量目标外部质量因素内部质量因素五大质量目标 软件构造的多维度视图和质量目标 该部分是该怎样以全面的眼光/模型/视图来看待软件系统的，搞清楚构造对象是什么，如何刻画，并学会构造过程中应考虑的质量指标，理解清楚如何构造对象才算好。 多维度视图 按阶段划分：构造时/运行时视图按动态性划分:时刻/阶段视图按构造对象层次划分：代码/构件视图关于多维度视图的整体表现如下图所示对于这副图的理解，个人认为首先掌握好代码与构件视图的区别，构件永远是高于代码层面的变化，如包，文件，配置，版本，日志，进程等等。然后掌握运行与构造时视图的区别，构造时都是关于文件本身不涉及执行时的变化，运行时则是关于栈，变量，内存信息等的一些执行时变化，至于时刻和阶段视图的区分则是一个时间点和一个时间段的区别，如一个时间点的sourcecode是具体怎样的和一个时间段的codechurn代码变化是怎么样的。 具体某些重要视图 (1)Build-time,moment,andcode-levelview：词汇层面:sourcecode语法层面:AST(半结构化的语言彻底结构化成一棵树)语义层面：ClassDiagram(图形化形式化的实现具体目标的结构)(2)Build-time,period,andcode-levelviewCodechurn代码变化(3)Build-time,moment,andcomponent-levelview文件，包，库等等，注意静态链接在构造时，动态链接在运行时(4)Build-time,period,andcomponent-levelviewSCI配置项和版本（基线和版本）(5)Run-time,moment,andcode-levelviewCodeSnapshot:描述程序运行时内存里变量层面的状态(6)Run-time,periodandcode-levelviewExecutiontracing执行跟踪 质量目标 分为外部质量因素与内部质量因素，外部质量因素影响用户，内部质量因素影响软件和它本身开发者，外部质量取决于内部质量。 外部质量因素 正确性：最重要的质量指标健壮性：针对异常情况的处理，这里对异常情况的定义为未被specification覆盖的情况即为“异常情况”！可扩展性：对软件的规约进行修改，是否足够容易可复用性：一次开发，多次使用，不要重复造轮子！！兼容性：不同的软件系统之间相互可容易的集成性能：性能毫无意义，除非有足够的正确性，过早的优化是万恶之源！！改变算法思想！可移植性：软件可方便的在不同的技术环境之间移植易用性：字面意思Functionality：每增加一小点功能，都确保其他质量属性不受到损失Timeliness：在用户想要其前则发布… 内部质量因素 ReadabilityUnderstandabilityClearnessSize 五大质量目标 
第8篇文章[0]
软件构造课程总结（4） 软件构造课程总结（4） 这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。 1.对象、类、属性和方法Instance多个栈、static一个栈2.接口和枚举接口确定ADT规约，类用来实现ADT倾向于使用接口来定义变量。接口中一般没有constructor3.通过接口来写代码先写一个接口publicinterfaceMyString，再写一个实现pulicclassSimplyMyStringimplementsMyString，其中使用@override重写方法，而在接口中只出现方法。客户端需要知道某个具体实现类的名字来建立接口。静态工厂方法：直接在接口中实现建立。4.default方法接口的通用方法 5.继承和重写：6.继承严格继承：不能重写如果不想子类重写，则加上final关键字7.重写使用super来调用父类型的方法抽象方法，不同的子类型各自重写静态类型检查8.多态9.泛型 
第9篇文章[0]
软件构造课程总结（2） 软件构造课程总结（2） 这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。 第四章、数据类型与类型检验 1.程序中的数据类型 数据类型范围基本数据类型和对象数据类型。 基本数据类型：int,long,byte,short,char,float,double,boolean只有值，没有ID均为不可变类型在栈中分配内存 对象数据类型：又值也有ID在堆中分配内存 对象数据类型的结构：有继承关系有操作符有重载 2.可变和不可变类型一句话来说，可变数据类型在内存中的值是可以变化的，而不可变数据类型在内存中的值是不能变化的，如果要改变变量，则需要重新分配一块内存，在这个内存中赋值，并且将指针到这块新的内存。在创造变量的时候加上final关键字可以使得变量变为不可变类型。比如String是一种不可变类型，则以下代码会在内存中发生这样的变化：Strings=“a”;s=s.concat(“b”);先创造一个字符串"a"，将s指向这块内存。然后创造一个字符串"ab"，将s的指针改为这块内存。 不可变类型与可变类型在遇到多个引用的时候会存在差异。 不可变类型需要垃圾回收，但比较安全。可变类型不需要垃圾回收，速度比较快，但是不那么安全。可变类型需要防御式拷贝进行保护。 第五章、数据类型与类型检验 1.spec一句话来说，spec描述了函数的作用，以及前置条件（对输入的限制）和后置条件（对输出的要求）。 2.spec的强度一句话来说，前置条件越弱，后置条件越强，spec就越强。 
第10篇文章[0]
软件构造课程总结（3） 软件构造课程总结（3） 这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。 第六章、ADT 1.表示独立性：通过封装来阻止用户访问程序内部2.抽象函数AF3.表示不变量RI4.数据抽象：强调作用于数据上的操作，在java中使用类的方法5.可变数据类型和不可变数据类型：改变时，前者改变内存中数值，后者构造一个新对象6.四种方法：creators、producers、observes、mutators7.creators：构造函数或者静态函数，或者工厂方法8.mutators：通常返回void9.int是immutable没有构造器mutators，而String是immutable所以也没有构造器mutators10.list是mutable，存在构造器mutators，比如add()11.抽象类型设计Ⅰ.简洁一致的操作Ⅱ.面向用户需求，满足所有需要且尽量简洁Ⅲ.要么抽象要么具体。12.表示独立性内部实现对与用户无关例子：MyString要点：不能让用户访问到类体（使用private表示、observers使用保护式拷贝）13.测试ADT同样是测试四个部分：creators、producers、observes、mutators主要测试返回值和操作结果14.不变量程序中始终保持不变的属性，比如一个家庭类当中，人数总是大于0的。15.RI（RepInvariant）开发者关注R，client关注I三种关系：满射、非单射、非双射AF：抽象函数，R到A的映射R中存在非法值，这时在A中无映射RI中元素合法的子集16.AF一个R到A的映射总结一下RI和AF：RI是输入的约束条件，AF是输入到输出的函数 
第11篇文章[0]
软件构造课程总结（1） 软件构造课程总结（1） 这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。 第一章、软件构造的多篇维度视图和质量目标 1.软件构造的多重视图：这一小节主要讲述了软件构造的三视图维度，分别从时间点还是时间段（MomentorPeriod）、构建还是运行（Build-timeorRun-time）以及代码的逻辑结构和物理结构（Code-levelorComponent-level）讲述了软件构造。 下面是一些比较重要的知识点：1.Code-level：代码的逻辑结构2.Component-level：代码的物理结构3.Momentview：特定时刻的软件形态4.Periodview：软件形态随时间的变化5.三种形式：词汇层面，语法层面，语义层面6.AST：语法分析树，在编译原理中十分重要7.语义：源代码的目标8.源代码：现实世界的代码9.CodeChurn：结构随着版本的变化的改变10.Library：库文件，存在静态链接和动态链接两种形式11.UML：类图12.Codesnapshot：描述程序运行时内存中变量层面的状态。13.Memorydump：记录运行时的内存信息14.Log：日志 2.软件构造的质量这一小节讲述了软件构造时衡量软件质量的几个标准：1.正确性：按照软件的规约spec正确的执行。正确性也是最重要的质量标准。几个保证正确性的方法：①测试，将详细在第二节中讲解②防御式编程：相关的知识有防御式拷贝，权限的使用（private关键字）③checkRep()函数的编写：在程序中我们可以编写一个检查程序，这个方法将时时刻刻检查我们类型中的不变量是否正确。 2.健壮性健壮性是指程序在遇到不符合spec的规定时仍然能够正确的处理，比如返回异常报错 3.可扩展性我们有时候需要对软件的规约进行修改、拓展，是否足够容易？这里就需要我们增强程序的可扩展性。一个可扩展性好的程序可以针对用户的需求扩大进行快速的迭代。 4.可复用性一次开发，多次使用。 5.兼容性 6.同构性 7.性能 8.可移植性 9.易用性 10.及时性 等等。。 我们在编写程序的时候需要对以上这些标准进行衡量，从而构建出一个最能满足客户需求的程序。比如，通常正确性是程序的第一位，而在性能和可扩展性、可复用性的衡量上，则需要根据客户的需求进行设计。______ 第二章、软件测试和测试优先的编程 这一章主要讲述了如何进行程序测试和测试优先编程的思想。我们测试程序，应该抱着找出错误的决心，这是我们测试的第一要义。测试程序主要有两个要点：①等价类基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。我们需要针对每个输入数据需要满足的约束条件，划分等价类。而每个等价类代表着对输入约束加以满足或违反的有效或无效数据的集合。而由于等价类的特性，我们只需要从等价类中选择一个来测试即可。例子：n是正奇数：正数：>0、<0奇数：奇数、偶数奇数隐含着整数：整数、非整数或者：输入的学号no需满足的条件：长度为10位：10、>10、<10以118开头：以此开头、以其他开头之后两位数应为03/36/37：03、36、37、其他②边界测试在工程师进行测试时，发现错误往往出现在边界情况上，比如在上面的例子中，n=0就是一个边界情况。边界值分析方法是对等价类划分方法的补充。通过边界测试，可以让我们更好的测试出错误。 ______ 第三章、软件构造过程和配置管理 这一章主要介绍了两个重要知识点：敏捷开发和git的结构和使用①敏捷开发敏捷开发主要通过快速迭代和小规模的持续改进，以快速适应变化。在2001年AgileManifesto发表敏捷宣言。Agile=增量+迭代每次迭代处理一个小规模增量 ②git1.git的层次结构：工作目录workspace、暂存区staging、仓库localrepository和远程仓库remoterepository（通常是github）。所有的操作就在这四个层次上进行。2.git中文件的结构：我们使用一个树结构来描述git的文件结构：每个commit指向一个父亲；多个commit指向同一个父亲：分支；一个commit指向两个父亲：合并 以上是我总结的一到三章的重点知识。 
第12篇文章[0]
软件构造课程总结（5） 软件构造课程总结（5） 这里是HIT2021软件构造课程的总结博客，主要书写了本学期软件构造的所有课程内容和实验内容。 第八章、ADT和OOP中的等价性 1.根据AF来判断2.equals()重写Object的方法3.Hash的特别方法4.可变类型的等价性观察等价性（可能有bug）行为等价性（看内存位置，直接用Object的==） 第十一章、面向可复用性和可维护性的设计方式 关键词：工厂方法、adapter、decorator、strategy、templatemethod、iterator、visitor设计模式：强调类、对象之间的交互关系，有创建型模式、结构性模式、行为类模式①创建型模式；工厂方法模式：一句话：通过接口实现creatorAdapter模式：略Decorator模式：对每一个特性构造子类，使用委派机制增加到对象上 2020期末考试考点总结： ①checkRep，用assert对precondition进行合法性检查方法一：正则表达式方法二：String转为整数，小数②表示泄露③snapshot书写④健壮性处理：异常和防御式编程⑤测试：等价类划分和边界值测试⑥线程安全threadsafe⑦AF和RI，spec中precondition强度的比较⑧设计模式之模板模式（可扩展性）⑨委派⑩LSP结构外部质量属性、git、安全性 
第13篇文章[0]
软件构造笔记（八）---PPT第四讲 数据类型与类型检查 数据类型静态/动态类型检查静态类型检查原理种类 动态类型检查种类 两者关系 可变/不变的数据类型不变的数据类型finalString特点 可变的数据类型StringBuilder特点解决可变类型不安全的方法 Snapshot理解数据类型 数据类型 基本数据类型/对象数据类型 静态/动态类型检查 静态类型检查 原理 可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性。 Java是静态类型语言，所有变量的类型在编译时(在程序运行之前)都是已知的，因此编译器也可以推导出所有表达式的类型。如果a和b被声明为int型，那么编译器得出a+b也是int型。 比如，如果输入"a"*“b”，尝试将两个字符串相乘，然后静态类型检查将在编程时捕获此错误，而不是在执行期间等待到达该行。 种类 1.Syntaxerrors语法错误2.Wrongnames类名/函数名错误：比如Math.sine(2)，正确的名字是sin3.Wrongnumberofarguments参数数目错误，比如Math.sin(30,20).4.Wrongargumenttypes参数类型错误,likeMath.sin(“30”).5.Wrongreturntypes返回值类型错误,likereturn“30”，但是这个函数应该返回int 动态类型检查 种类 1.Illegalargumentvalues非法的参数值：例如，整数表达式x/y只有在y实际上为零时才错误;否则它的工作原理。在这个表达式中，除以0不是静态误差，而是动态误差。2.Unrepresentablereturnvalues非法的返回值：当特定的返回值不能在类型中表示时。3.Out-of-rangeindexes越界：在字符串上使用负数或太大的索引。4.Callingamethodonanullobjectreference.空指针 两者关系 静态检查倾向于与变量的特定值无关的类型和错误有关。静态类型保证一个变量会有这个集合中的一些值，但是我们直到运行时才知道它的确切值。因此，如果错误只会由某些值引起，如除0或索引超出范围，那么编译器不会引发关于它的静态错误。 相比之下，动态检查往往是关于特定值引起的错误。 静态检查：关于“类型”的检查，不考虑值动态检查：关于“值”的检查 可变/不变的数据类型 改变一个变量：将该变量指向另一个值的存储空间改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。 不变的数据类型 不变对象：一旦被创建，始终指向同一个值/引用如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变 final finalinta=5;1.final类无法派生子类2.final变量无法改变值/引用3.final方法无法被子类重写 String 特点 缺点：使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)优点：安全 可变的数据类型 可变对象：拥有方法可以修改自己的值/引用 StringBuilder 特点 优点：可变类型最少化拷贝以提高效率缺点：不安全比如 publicstaticintsum(List<Integer>list){ intsum=0; for(intx:list){ sum+=x; } returnsum; } publicstaticintsumAbsolute(List<Integer>list){ for(inti=0;i<list.size();i++){ list.set(i,Math.abs(list.get(i))); } returnsum(list); } publicstaticvoidmain(String[]args){ List<Integer>myData=Arrays.asList(-5,-3,-2); System.out.println(sumAbsolute(myData)); System.out.println(sum(myData)); } 最后输出结果为1010因为可变类型导致list的值发生变化 解决可变类型不安全的方法 进行防御式拷贝 Snapshot理解数据类型 基本类型对象类型对象值是一个按其类型标记的圆。可变对象不可变对象：用双线椭圆Strings=“a”;s=s+“b”;不可变的引用：用双线箭头 
第14篇文章[0]
软件构造笔记（二） 面向复用的软件构造技术 一.复用基本概念（一）复用编程：（二）四类复用级别： 二.LSP--LiskovSubstitutionPrinciple（一）内容：（二）协变：（三）逆变： 三.Delegation 一.复用基本概念 （一）复用编程： 1.programmingforreuse面向复用编程：开发出可复用的软件2.programmingwithreuse基于复用编程：利用已有的可复用软件搭建应用系统 （二）四类复用级别： 1.源代码级别的复用2.模块级别的复用：类、抽象类、接口3.库级别的复用：API、包4.系统级别的复用：框架 二.LSP–LiskovSubstitutionPrinciple （一）内容： 1.前置条件不能强化2.后置条件不能弱化3.不变量要保持4.子类型方法参数：逆变5.子类型方法返回值：协变 （二）协变： 1.返回值类型：不变或变得更具体2.异常类型：不变或变得更具体3.举例：（1）返回值类型 classT{//父类 Objecta(){ } } classSextendsT{//子类 @Override Stringa(){ } } （2）异常值类型 classT{//父类 voidbthrowsThrowable{ } } classSextendsT{//子类 @Override voidbthrowsIOException{ } } （三）逆变： 1.参数类型：要相反的变化，要不变或越来越抽象2.举例：(会报错，目前Java把这种形式看作overload） classT{//父类 voidc(Strings){ } } classSextendsT{//子类 @Override voidc(Objects){ } } 三.Delegation 1.委派：一个对象请求另一个对象的功能2.定义类时不用extends比如：privateGraphgraph=Graph.empty()3.使用条件：子类只需要复用父类中的一小部分方法4.建立delegation步骤：（1）永久保存delegation关系：List<Student>ls;（2）建立delegation关系：this.ls.add(s);（3）逐个delegate：通过for循环实现5.举例来讲： classProfessor{ List<Student>ls; voidenroll(Students){ this.ls.add(s); } voidevalute(){ doublescore=0; for(Students:ls) score+=s.evaluate(this); } } 
第15篇文章[0]
软件构造笔记（七）---PPT第三讲 软件配置管理SCM与版本控制系统VCS 软件配置管理SCM基本概念 版本控制系统VCS分类本地版本控制系统集中式版本控制系统分布式版本控制系统 Git工具操作可视化ObjectGraph 存储文件基本操作gitcommitgitpushgit分支/合并 软件配置管理SCM 基本概念 1.SCM：追踪和控制软件的变化2.SCI软件配置项：软件中发生变化的基本单元，如文件3.baseline基线：软件持续变化过程中的稳定时刻，如对外发布的版本4.CMDB：配置管理数据库 版本控制系统VCS 分类 本地版本控制系统 仓库存储于开发者本地机器，无法共享和协作 集中式版本控制系统 仓库存储于独立的服务器，支持多开发者之间的协作 分布式版本控制系统 仓库存储于独立的服务器+每个开发者的本地机器 Git工具 操作可视化 workspace：工作区staging：暂存区 ObjectGraph 特点：（1）A->B表示在版本B的基础上作出变化，形成了版本A（2）每个commit指向一个父亲（3）多个commit指向同一个父亲：分支（4）一个commit指向两个父亲：合并 存储文件 Git存储发生变化的文件（而非代码行），不变化的文件不重复存储 基本操作 gitcommit gitpush git分支/合并 开始gitcheckout–biss53：创建名为iss53的新分支，即创建一个指针指向当前位置gitcommit：由于此时在iss53分支上，所以只对该分支进行操作，提交文件后，将iss53指针向后移动一步，master指针不变下面的操作同理，切换到master分支，创建新分支：hotfix，在该分支进行提交切换到master分支，将其与hotfix分支进行合并，合并结果就是两个指针指向同一处-d代表删除hotfix分支若要合并master与iss53分支最终结果： 
第16篇文章[0]
软件构造笔记（六）---PPT第一讲 多维度视图和质量目标 多维度试图Build-time1.build-time\moment\code-levelview2.build-time\period\code-levelview3.build-time\moment\component-levelview4.build-time\period\component-levelview Run-time1.run-time\moment\code-levelview2.run-time\period\code-levelview3.run-time\moment\component-levelview4.run-time\period\component-levelview 视图维度的转换 质量目标外部质量因素内部质量因素两者关系 多维度试图 按阶段划分：构造时/运行时按动态性划分：时刻/阶段按构造对象的层次划分：代码/构件 Build-time 1.build-time\moment\code-levelview 1.词汇层面：Lexical-orientedsourcecode2.语法层面：AST3.语义层面：ClassDiagram 2.build-time\period\code-levelview Codechurn：代码变化 3.build-time\moment\component-levelview Package\File\StaticLinking\Library 4.build-time\period\component-levelview ConfigurationItem(配置项)\Version(版本) Run-time 1.run-time\moment\code-levelview Snapshotdiagram代码快照图\MemoryDump内存信息转储 2.run-time\period\code-levelview Executionstacktrace执行跟踪：用日志方式记录程序执行的调用次序 3.run-time\moment\component-levelview Dynamiclinking等 4.run-time\period\component-levelview Eventlog：事件日志 视图维度的转换 质量目标 外部质量因素 影响用户1.正确性：发现不正确、消除不正确2.健壮性：针对异常情况的处理3.可扩展性：对spec的修改是否足够容易4.可复用性：一次开发，多次使用5.兼容性：不同软件系统之间相互可容易的集成6.性能：与其他质量属性折中7.可移植性：软件在不同的技术环境之间移植8.易用性：容易学、安装、操作9.功能性10.及时性 内部质量因素 影响软件本身和它的开发者1.可读性2.易理解性3.清晰性4.大小 两者关系 外部质量取决于内部质量 
第17篇文章[0]
软件构造笔记（十）---PPT第六讲 抽象数据类型ADT ADT操作的四种类型Creator构造器Producer生产器Observer观察器Mutator变值器测试四种类型 ADT特性表示独立性RepresentationIndependence不变量InvariantsAF和RI两个空间抽象函数AF表示不变量RI 总结 抽象类型：强调“作用于数据上的操作”，程序员和client无需关心数据如何具体存储的，只需设计/使用操作即可。 可变类型的对象：提供了可改变其内部数据的值的操作不变数据类型：其操作不改变内部值，而是构造新的对象 ADT操作的四种类型 Creator构造器 1.构造器创建该类型的新对象。2.构造器可以接受一个对象作为参数，但不能接受正在构造的类型的对象。3.可能实现为构造函数或静态函数 Producer生产器 生产器从该类型的旧对象创建新对象例如，String的concat()方法是一个生成器:它接受两个字符串并生成一个表示它们的连接的新字符串。 Observer观察器 观察器接受抽象类型的对象并返回不同类型的对象。例如，List的size()方法返回一个int。 Mutator变值器 1.变值器是改变对象属性的方法例如，List的add()方法通过在列表的末尾添加一个元素来改变列表。2.变值器通常返回void，如果返回值为void，则必然意味着它改变了对象的某些内部状态；变值器也可能返回非空类型 测试四种类型 1.测试creators,producers,andmutators：调用observers来观察这些operations的结果是否满足spec；2.测试observers：调用creators,producers,andmutators等方法产生或改变对象，来看结果是否正确。 ADT特性 表示独立性RepresentationIndependence client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。例如，List提供的操作与列表是作为链表还是以数组表示无关。违反表示独立性的例子：函数直接调用内部rep的方法进行实现，也就是只有知道内部实现才能进行如下调用，所以破坏了独立性下图中能看出右边修改后的例子调用getMembers()函数，调用的方法是返回值List的get方法，而不是内部实现的set的方法。换句话说，外部实现只需要关注外部已知的内容，而不需要关注内部的实现，保持了很好的独立性 不变量Invariants 由ADT来负责其不变量，与client端的任何行为无关为什么需要表示不变量？举例来说这是一个不可变的ADT，但由于字段都定义为public，既可以被外部访问，所以客户端可以直接对字段进行操作，对安全性有威胁。这被称为表示泄露representationexposure：这意味着类之外的代码可以直接修改字段。不仅影响不变性，也影响了表示独立性：无法在不影响客户端的情况下改变其内部表示首先进行第一步修改，将字段修饰为privatefinalprivate和public关键字指示哪些字段和方法只能在类内部访问，哪些字段和方法可以从类外部访问。final关键字还有助于保证该不可变类型的字段在对象构造后不会被重新赋值。但是还是存在一些问题，retweetLater应该返回另一条信息，但却是一个小时之后才返回，所以Tweet的不变性被破坏了，原因是该方法泄露了对可变对象的引用。解决方法：进行防御式拷贝 另外一个例子这个代码会导致date都为23因为Date()是可变类型，在每次调用时，Tweet都指向相同的Date()对象解决方法：防御式拷贝注意：通常，应该仔细检查所有ADT操作的参数类型和返回类型。如果任何类型是可变的，请确保不会返回对其表示的直接引用。因为这样做会造成表示泄露。 AF和RI 表示不变量RepInvariant和抽象函数AbstractionFunction 两个空间 表示值(代表值)的空间由实际实现实体的值组成。抽象值构成的空间：client看到和使用的值。ADT开发者关注表示空间R，client关注抽象空间A 抽象函数AF 抽象函数：R和A之间映射关系的函数，即如何去解释R中的每一个值为A中的每一个值。关系：AF:R->A R中的部分值并非合法的，在A中无映射值1.每个抽象值都被一些代表值映射到（满射）2.一些抽象值被多个代表值映射到（未必单射）3.并不是所有的rep值都被映射（未必双射） 表示不变量RI RI:R->boolean表示不变性RI：某个具体的“表示”是否是“合法的”也可将RI看作：所有表示值的一个子集，包含了所有合法的表示值也可将RI看作：一个条件，描述了什么是“合法”的表示值 下图是AF和RI的书写选择某种特定的表示方式R，进而指定某个子集是“合法”的(RI)，并为该子集中的每个值做出“解释”(AF) 即如何映射到抽象空间中的值。 总结 设计ADT：(1)选择R和A；(2)RI 合法的表示值；(3)如何解释合法的表示值 映射AF做出具体的解释：每个repvalue如何映射到abstractvalue 
第18篇文章[0]
软件构造笔记（三） 判断ADT中的等价性 一.引用等价性==二.对象等价性equals 前言：在很多场景下，需要判定两个对象是否“相等”，本文主要讨论==和equals的区别。 一.引用等价性== 对基本数据类型，使用==判定相等 二.对象等价性equals 1.对对象类型，使用equals判定相等2.equals的实现： publicclassObject{   publicbooleanequals(Objectthat){ returnthis==that;//在对象等价性的判断是用引用等价性实现的 } } 一般来说，这个equals的实现通常不是程序员所期待的，所以一般需要重写 3.错误示例： publicclassDuration{   publicbooleanequals(Durationthat){ returnthis.getLength()==that.getLength() } } Durationd1=newDuration(1,2); Durationd2=newDuration(1,2); Objecto2=d2; d1.equals(d2);//结果为true d1.equals(o2);//结果为false d2是Duration类型，所以传入参数时实现的是Duration中的equals，即判断长度相等，所以结果为true；而o2是Object类型，所以传入参数时实现的是Object中的equals，即通过引用等价性进行判断，由于d1和o2是两个不同的对象，所以结果为false. ！！原因是上面equals的实现并不是重写，而是重载，因为改变了参数的类型。 4.重写equals的方法 @Override publicboolwanequals(Objectthat){ returnthatinstanceofDuration&&this.sameValue((Duration)that); } privatebooleansameValue(Durationthat){ returnthis.getLength==that.getLength(); } 5.对于可变类型的等价性实现行为等价性即可，而且无需重写equals和hashcode两个函数 
第19篇文章[0]
软件构造笔记（九）---PPT第五讲 设计规约 行为等价性规约前置/后置条件设计规约规约的强度 行为等价性 举例来说：站在客户的角度，下面两个函数行为是否等价分情况：1.当val缺失时，findFirst返回arr的长度，findLast返回-12.当val出现两次时，findFirst返回较低的索引，findLast返回较高的索引。3.但是当val恰好出现在数组的一个下标处时，这两个方法的行为是相同的。当它们调用这个方法时，它们将传入一个包含一个元素val的arr。对于这样的客户端，这两个方法是相同的。 所以，其实现在没有办法准确定义这两个函数行为是否等价。但如果我们设计一个spec规约，根据规约判定两个函数是否等价，能看出来，上述两个函数满足改规约，所以函数等价如何判断行为等价性：1.单纯的看实现代码，并不足以判定不同的implmentation是否是“行为等价的”。2.需要根据代码的spec（开发者与client之间形成的contract）判定行为等价性。3.在编写代码之前，需要弄清楚spec如何协商形成、如何撰写。 规约前置/后置条件 1.前置条件：对客户端的约束，在使用方法时必须满足的条件2.后置条件：对开发者的约束，方法结束时必须满足的条件3.契约：如果前置条件满足了，后置条件必须满足。如果前置条件不满足，则方法可做任何事情。4.设计特点：参数由@param子句描述，结果由@return和@throws子句描述。尽可能将前置条件放入@param中，将后置条件放入@return和@throws中。5.方法的说明可以讨论方法的参数和返回值，但绝不应该讨论方法的局部变量或方法类的私有字段。6.可变方法的spec：前两种都是可变方法，会修改传入的参数，但是除非在后置条件里声明过，否则方法内部不应该改变输入参数。应尽量遵循此规则，尽量不设计mutating的spec，否则就容易引发bugs。 设计规约 规约的强度 1.存在规约S1和S2，判断是否可以用S2替代S1若满足条件：S2的前置条件更弱、后置条件更强，则证明S2>=S1，可以用S2代替S1spec变强：更放松的前置条件+更严格的后置条件越强的规约，意味着implementor的自由度和责任越重，而client的责任越轻。2.举例：（1）前置条件变弱，后置条件不变判断后置条件是要在满足第一个函数的前置条件的前提下，能发现后置条件相同（2）前置条件和后置条件都变弱了，无法判断 
第20篇文章[0]
软件构造笔记（十一）---PPT第七讲 面向对象的编程 静态/实例方法接口接口和类静态工厂方法default三个关键字 重写Override重载Overrload泛型 静态/实例方法 静态变量/方法：与类关联的变量，而不是与类的实例关联的变量。若将方法与类关联，则为静态方法 要引用类变量和方法，可以用句点(’.’)将类的名称和类方法或类变量的名称连接起来 实例变量/方法：不是类方法或类变量的方法和变量称为实例方法或实例变量。 要引用实例方法和变量，必须引用来自类实例的方法和变量。 总结：类变量和类方法与一个类关联，并且每个类只出现一次。使用它们不需要创建对象。 实例方法和变量在一个类的每个实例中出现一次。静态方法不与类的任何特定实例相关联，而实例方法(声明时不使用Static关键字)必须在特定对象上调用。举例来说：注意：1.静态方法只能调用静态变量2.实例方法既可以调用静态变量，也可以调用正常变量3.main函数中调用static变量：使用类+方法名称调用两者对比： 接口 接口和类 Interface和Class:定义和实现ADT接口：确定ADT规约；类：实现ADT 1.接口之间可以继承与扩展2.一个类可以实现多个接口（从而具备了多个接口中的方法）3.一个接口可以有多种实现类4.也可以不需要接口直接使用类作为ADT，既有ADT定义也有ADT实现，实际中更倾向于使用接口来定义变量 静态工厂方法 设MyString是接口，FastMyString是实现MyString接口的类实现过程出现了问题：1.打破了抽象边界，接口定义中没有包含constructor，也无法保证所有实现类中都包含了同样名字的constructor。2.故而，客户端需要知道该接口的某个具体实现类的名字修改策略：使用静态工厂方法，可以避免使用具体实现类的名字 default 接口中的每个方法在所有类中都要实现；通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它；以增量式的为接口增加额外的功能而不破坏已实现的类 三个关键字 private：只能在声明类中访问protected：可从声明类的子类(以及包内)访问public：可以任意访问 重写Override 重写是在运行时决定执行哪个方法使用final关键字的方法不能在子类中被重写重写的函数：完全同样的signature实际执行时调用哪个方法，运行时决定如果父类的一个对象被用来调用该方法，则父类中的版本将被执行;如果使用子类的对象来调用该方法，则执行子类中的版本 父类型中的被重写函数体不为空：意味着对其大多数子类型来说，该方法是可以被直接复用的。对某些子类型来说，有特殊性，故重写父类型中的函数，实现自己的特殊要求如果父类型中的某个函数实现体为空，意味着其所有子类型都需要这个功能，但各有差异，没有共性，在每个子类中均需要重写。重写之后，利用super()复用了父类型中函数的功能，并对其进行了扩展子类的构造方法若要继承父类，则应该放在构造函数的第一步 重载Overrload 重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型价值：方便client调用，client可用不同的参数列表，调用同样的函数重载是在编译阶段时决定要具体执行哪个方法，即静态检查时决定特点：1.不同的参数列表2.相同/不同的返回值类型3.相同/不同的public/private/protected4.可以声明异常5.可以在同一个类内重载，也可在子类中重载 举例来说：定义如下的类若判断条件如下，会产生异常，原因是由于重载方法是在编译时检查，ah2此时还是Animal类型，所以应用的eat方法不应该传入参数以下两种声明方式就不会出错第一个调用Animal类中的方法第二个调用Horse类中的方法，传入参数另一个例子如下Animal若是接口，则可以按照3的方式进行调用两者的区别与联系： 泛型 泛型接口的实现方法1.泛型接口、非泛型实现类2.泛型接口、泛型实现类 
第21篇文章[0]
软件构造笔记（十二）---PPT第八讲 ADT和OOP中的等价性 前言引用等价性对象等价性equals()函数hashcode()函数 观察等价性行为等价性总结 前言 等价性的划分：不可变对象的引用等价性==和对象等价性equals()可变对象的观察等价性和行为等价性 引用等价性 ==操作符比较引用。它测试引用相等。两个引用是==如果它们指向内存中的相同存储。在快照图中，如果两个引用的箭头指向同一个对象气泡，则它们为==。==对基本数据类型，使用==判定相等 对象等价性 equals()函数 equals()操作比较对象内容 换句话说，对象相等。对对象类型，使用equals() 正常的equals()方法：在Object中实现的缺省equals()是在判断引用等价性，所以应该重写equals()方法错误重写：这是Overload，不是重写正确重写：一个更好的方法去实现equals() hashcode()函数 等价的对象必须有相同的hashCode根据上面描述的Duration类，在修改equals()函数之后，d1.equals(d2)=true，但是输出hashCode()的值发现两者的哈希值不同修改方法：为对象的每个组件计算一个散列代码，用于确定是否相等(通常通过调用每个组件的hashCode方法)，然后组合这些散列代码，并进行一些算术操作。对于Duration，这很容易，因为类的抽象值已经是一个整数值: 观察等价性 当不能通过不改变对象状态的观察来区分它们时，也就是说，只调用observer、producer和creator方法。这通常被严格地称为观察等价性，因为它测试两个对象在程序的当前状态下是否“看起来”相同。观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致对可变类型来说，往往倾向于实现严格的观察等价性 实现观察等价性的缺陷： 行为等价性 当它们不能通过任何观察来区分时，甚至状态也会改变。这种解释允许调用两个对象上的任何方法，包括mutators。这被称为行为平等，因为它测试两个物体在当前状态和所有未来状态下是否会“表现”相同。行为等价性：调用对象的任何方法都展示出一致的结果 对可变类型，实现行为等价性即可。也就是说，只有指向同样内存空间的objects，才是相等的。所以对可变类型来说，无需重写equals()andhashCode()这两个函数，直接继承Object的两个方法即可。如果一定要判断两个可变对象看起来是否一致，最好定义一个新的方法。 总结 1.对于不可变对象：equals()应该比较抽象值。这就相当于说equals()应该提供行为平等。hashCode()应该将抽象值映射为整数。所以，不可变类型必须重写equals()和hashcode()函数2.对于可变对象：equals()应该比较引用，就像==一样。同样，这就相当于说equals()应该提供行为平等。hashCode()应该将引用映射为一个整数。所以，可变类型不需要重写equals()和hashcode()函数 
第22篇文章[0]
软件构造笔记（十五）--PPT第十一讲 面向可复用性和可维护性的设计模式 Creationalpatterns创建型模式Structuralpatterns结构型模式Adapter适配器模式Decorator装饰器模式 Behavioralpatterns行为类模式Strategy策略模式TemplateMethod模板模式IteratorVisitor 设计模式的对比共性模式1共性模式2 Creationalpatterns创建型模式 工厂方法模式 当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。 定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。比如静态工厂方法： Structuralpatterns结构型模式 Adapter适配器模式 1.内容：将某个类/接口转换为client期望的其他形式，通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。2.举例：设置一个接口Shape，通过具体子类Rectangle实现display方法，但由于这个方法不是我们所期望的，我们需要通过一个适配器来实现内部的方法，并在Rectangle内部进行调用，这样可以通过接口封装内部实现 Decorator装饰器模式 本节内容引用：https://www.cnblogs.com/yxlaisj/p/10446504.html 1.用每个子类实现不同的特性，为对象增加不同侧面的特性，对每一个特性构造子类，通过委派机制增加到对象上。使用subtypinganddelegation2.举例：咖啡接口，获取价格和配料 /** *咖啡 */ interfaceCoffee{ /**获取价格*/ doublegetCost(); /**获取配料*/ StringgetIngredients(); } 原味咖啡类，实现咖啡接口，配料中只有咖啡 /** *原味咖啡 */ classSimpleCoffeeimplementsCoffee{ @Override publicdoublegetCost(){ return1; } @Override publicStringgetIngredients(){ return"Coffee"; } } 咖啡对象的装饰器类，同样实现Coffee接口，定义一个Coffe对象的引用，在构造器中进行初始化。并且将getCost（）和getIntegredients()方法转发给被装饰对象。 /** *咖啡的"装饰器"，可以给咖啡添加各种"配料" */ abstractclassCoffeeDecoratorimplementsCoffee{ protectedfinalCoffeedecoratedCoffee; /** *在构造方法中，初始化咖啡对象的引用 */ publicCoffeeDecorator(Coffeecoffee){ decoratedCoffee=coffee; } /** *装饰器父类中直接转发"请求"至引用对象 */ publicdoublegetCost(){ returndecoratedCoffee.getCost(); } publicStringgetIngredients(){ returndecoratedCoffee.getIngredients(); } } 具体的装饰器类，负责往咖啡中“添加”牛奶，注意看getCost（）方法和getIngredients()方法，可以在转发请求之前或者之后，增加功能。 /** *此装饰类混合"牛奶"到原味咖啡中 */ classWithMilkextendsCoffeeDecorator{ publicWithMilk(Coffeecoffee){ super(coffee); } @Override publicdoublegetCost(){ doubleadditionalCost=0.5; returnsuper.getCost()+additionalCost; } @Override publicStringgetIngredients(){ StringadditionalIngredient="milk"; returnsuper.getIngredients()+","+additionalIngredient; } } 另一个具体装饰器类，用来给咖啡加糖，一样的逻辑。 classWithSugarextendsCoffeeDecorator{ publicWithSugar(Coffeecoffee){ super(coffee); } @Override publicdoublegetCost(){ returnsuper.getCost()+1; } @Override publicStringgetIngredients(){ returnsuper.getIngredients()+",Sugar"; } } 客户端使用装饰器模式 publicclassDecoratorDemo{ staticvoidprint(Coffeec){ System.out.println("花费了:"+c.getCost()); System.out.println("配料:"+c.getIngredients()); System.out.println("============"); } publicstaticvoidmain(String[]args){ //原味咖啡 Coffeec=newSimpleCoffee(); print(c); //增加牛奶的咖啡 c=newWithMilk(c); print(c); //再加一点糖 c=newWithSugar(c); print(c); } } Behavioralpatterns行为类模式 Strategy策略模式 1.内容：有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里，为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。2.实现方式：3.举例：下图两个pay()方法的实现就是模板模式 TemplateMethod模板模式 1.问题：一些客户端共享相同的算法，但在细节上有所不同，例如，一个算法由可定制的部分和不变的部分组成。公共步骤不应在子类中重复，但需要重用。解决方法：共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现使用继承和重写实现模板模式2.举例：具体代码：抽象类的实现： Iterator 客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式 Visitor 1.内容：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。本质上：将数据和作用于数据上的某种/些特定操作分离开来。为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码，可以在不改变ADT本身的情况下通过delegation接入ADT 2.举例： VisitorvsIterator迭代器：以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。Visitor：在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT VisitorvsStrategy二者都是通过delegation建立两个对象的动态联系但是Visitor强调是的外部定义某种对ADT的操作，该操作于ADT自身关系不大（只是访问ADT），故ADT内部只需要开放accept(visitor)即可，client通过它设定visitor操作并在外部调用。而Strategy则强调是对ADT内部某些要实现的功能的相应算法的灵活替换。这些算法是ADT功能的重要组成部分，只不过是delegate到外部strategy类而已。区别：visitor是站在外部client的角度，灵活增加对ADT的各种不同操作（哪怕ADT没实现该操作），strategy则是站在内部ADT的角度，灵活变化对其内部功能的不同配置。 设计模式的对比 共性模式1 对于Adapter适用场合：你已经有了一个类，但其方法与目前client的需求不一致。根据OCP原则，不能改这个类，所以扩展一个adaptor和一个统一接口。对于模板模式：适用场合：有共性的算法流程，但算法各步骤有不同的实现，典型的“将共性提升至超类型，将个性保留在子类型” 共性模式2 对于Strategy：对于Iterator对于工厂方法：对于Visitor： 
第23篇文章[0]
工厂方法--笔记四 工厂方法 使用原因示例衣服工厂抽象类工厂定义了统一行为，具体类来实现具体行为调用代码 使用原因 当client不知道要创建哪个具体类的实例，或不想再client代码中指明要具体创建的实例时，用工厂方法。定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 示例 小A要开两个工厂做衣服，分别做短袖和长袖 衣服工厂抽象类 publicabstractclassClothesFactory(){ publicabstractClothmakeClothes(); } 工厂定义了统一行为，具体类来实现具体行为 短袖实现类 publicclassshortSleeveFactoryextendsClothesFactory{ @Override publicClothmakeClothes(){ returnnewshortSleeve(); } } 长袖实现类 publicclasslongSleeveFactoryextendsClothesFactory{ @Override publicClothmakeClothes{ returnnewlongSleeve(); } } 调用代码 publicclassMain{ publicstaticvoidmain(String[]args){ //短袖 ClothesFactoryshort=newshortSleeveFactory(); short.makeClothes.make(); //长袖 ClothesFactorylong=newlongSleeveFactory(); long.makeClothes.make(); 
第24篇文章[0]
软件构造笔记（十四）---PPT第十讲 面向可维护性的构造技术 OO设计原则：SOLID(SRP)TheSingleResponsibilityPrinciple(OCP)TheOpen-ClosedPrinciple(LSP)TheLiskovSubstitutionPrinciple(ISP)TheInterfaceSegregationPrinciple(DIP)TheDependencyInversionPrinciple OO设计原则：SOLID (SRP)TheSingleResponsibilityPrinciple SRP–单一责任原则1.内容：不应有多于1个的原因使得一个类发生变化，即一个类，一个责任2.举例： (OCP)TheOpen-ClosedPrinciple OCP–开放-封闭原则1.对扩展性的开放：这意味着模块的行为可以被扩展。当应用程序的需求发生变化时，或者满足新应用程序的需求时，我们可以使模块以新的不同的方式运行。2.对修改的封闭：但模块自身的代码是不应被修改的，扩展模块行为的一般途径是修改模块的内部实现，如果一个模块不能被修改，那么它通常被认为是具有固定的行为。3.实现方式：第一种：如果有多种类型的Server，那么针对每一种新出现的Server，不得不修改Server类的内部具体实现。不推荐使用第二种：通过构造一个抽象的Server类：AbstractServer，该抽象类中包含针对所有类型的Server都通用的代码，从而实现了对修改的封闭；当出现新的Server类型时，只需从该抽象类中派生出具体的子类ConcreteServer即可，从而支持了对扩展的开放。4.举例：左边：如果要修改m_type的值，则要修改内部代码实现，破坏对修改的封闭。右边：如果要修改m_type的值，只需要增加额外的类进行实现就可以，其他无关的类都不做改动，满足OCP原则 (LSP)TheLiskovSubstitutionPrinciple LSP–Liskov替换原则子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异 (ISP)TheInterfaceSegregationPrinciple ISP–接口隔离原则1.“胖”接口具有很多缺点：不够聚合胖接口可分解为多个小的接口，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的端口。2.举例：这是一个不好的实现方式，RobotWorker不需要实现eat()方法，但由于接口中包含两个方法，所以都要实现，不满足ISP原则。修改方式如下：将上述两个接口分离，实现类时只实现需要功能的接口即可。 (DIP)TheDependencyInversionPrinciple DIP–依赖转置原则1.抽象的模块不应依赖于具体的模块，具体应依赖于抽象举个例子：下面的实现是通过接口而不是具体类实现的2.实现方法：不推荐的方法：上层client的代码中直接嵌入了对下层具体实现机制的调用满足DIP的方法：上层client的代码面向抽象接口编程，隔离对下层具体实现机制的直接接触再举个例子：delegation要通过接口实现，而不是具体子类 
第25篇文章[0]
软件构造笔记（五） Java面向对象编程 静态变量、静态方法1.静态变量2.静态方法 接口和类1.接口2.使用静态工厂方法可以避免客户知道具体子类名称使用default关键字 静态变量、静态方法 1.静态变量 静态变量是属于类的，而不是属于类创建的对象 publicstaticintnum; publicstaticStrings; 2.静态方法 静态方法只能访问类的静态变量或调用类的静态方法。静态方法通常作为工具方法使用，当其被其它类使用时，不需要创建类的实例 classDifference{ publicstaticvoidmain(String[]args){ display(); Differencet=newDifference(); t.show(); } //静态方法 staticvoiddisplay(){ System.out.println("Amazing!"); } //普通方法 voicshow(){ System.out.println("Awesome!"); } 接口和类 1.接口 1.接口之间可以继承和扩展2.一个类可以实现多个接口3.一个接口可以有多种实现类 2.使用静态工厂方法可以避免客户知道具体子类名称 举例来说 publicclassFastMyStringimplementsMyString{   } 客户端具体实现时 MyStrings=newFastMyString(true);//知道具体实现类的名字 为了避免这种情况发生 publicinterfaceMyString{ //在接口里定义子类返回 publicstaticMyStringvalueOf(booleanb){ returnnewFastMyString(true); } } MyStrings=MyString.valueOf(true); 使用default关键字 在接口统一实现某些功能，无需在各个类中重复使用它 publicinterfaceExample{ defaultintmethod1(inta){ } staticintmethod2(intb){ } publicintmethod3(); } publicclassCimplementsExample{ @Override publicintmethod3(){ } publicstaticvoidmain(String[]args){ Example.method2(2); Cc=newC(); c.method1(1); c.method3(); } } 
第26篇文章[0]
软件构造笔记（一） 笔记一 Java基本知识一.String、StringBuilder、StringBuffer类二.Map类基本用法 多维度视图和质量目标总结一.描述软件系统的三个维度二.AST三.质量属性 Java基本知识 一.String、StringBuilder、StringBuffer类 运行速度：StringBuilder>StringBuffer>String 原因：String是字符串常量，StringBuilder和StringBuffer是字符串变量，String对象一旦创建之后该对象是不可更改的，但后两者是可以更改的 publicclassWelcome{ publicstaticvoidmain(String[]args){ Stringstr="abc"; System.out.println(str); str=str+"de"; System.out.println(str); } } 在本例中，首先在第8行创建一个String对象str赋值为"abc"，在第10行，JVM又创建了一个新的对象名为str，把原来的str值和"de"加起来赋值给新的str，原来的str就会被JVM垃圾回收机制给回收掉了。所以Java中String对象进行的操作实际上是一个不断创建新的对象并将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，若以速度比String快很多 二.Map类基本用法 Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。Map中的集合，元素是成对存在的，每个元素由键与值两部分组成，通过建可以找对所对应的值。Collection中的集合称为单列集合，Map中的集合称为双列集合。 Map集合遍历键值对方式 利用迭代器进行遍历 publicclassWelcome{ publicstaticvoidmain(String[]args){ //创建map对象 Map<String,String>map=newHashMap<>(); //向map对象中添加元素 map.put("age","18"); map.put("name","Mary"); map.put("hobby","piano"); //获取map中键元素 Set<String>keySet=map.keySet(); //利用迭代器遍历元素 Iterator<String>it=keySet.iterator(); while(it.hasNext()){ //得到每一个key Stringkey=it.next(); //得到每一个key对应的value Stringvalue=map.get(key); System.out.println(key+"="+value); } } } 利用foreach进行遍历 publicclassWelcome{ publicstaticvoidmain(String[]args){ //创建map对象 Map<String,String>map=newHashMap<>(); //向map对象中添加元素 map.put("age","18"); map.put("name","Mary"); map.put("hobby","piano"); //获取map中键元素 Set<String>keySet=map.keySet(); //利用foreach进行遍历 for(Stringkey:keySet){ Stringvalue=map.get(key); System.out.println(key+"="+value); } } } 多维度视图和质量目标总结 一.描述软件系统的三个维度 Byphases:build-andrun-timeviewsBydynamics:momentandperiodviewsBylevel:codeandcomponentviews 二.AST 1.Javasource：首先，提供一些源代码进行解析。此源代码可以在项目中以Java文件的式提供，也可以直接以char[]包含Java源代码的形式提供。2.Parse：解析在1处描述的源代码。该步骤所需的全部由类提供org.eclipse.jdt.core.dom.ASTParser。3.该抽象语法树是步骤2的结果。它是一个树模型，完全代表在步骤1中提供的源。如果需要，解析器还会计算并包括称为“绑定”的其他符号解析信息。4.ManipulatingtheAST：如果需要更改第3点的AST，可以通过两种方式完成：(1)通过直接修改AST。(2)通过在单独的协议中记录修改。5.Writingchangesback：如果进行了更改，则需要将其应用于1提供的源代码。6.IDocument：是步骤1的源代码的包装，在第5步需要 三.质量属性 1.Externalqualityfactors(1)Correctness:按照预先定义的“规约”执行，是最重要的质量指标(2)Robustness:针对异常情况的处理，出现规约定义之外的清醒的时候，软件要做出恰当的反应(3)Extendibility:对软件的规约进行修改是否足够容易(4)Reusability:是软件可用于构建许多不同应用程序的能力，一次开发，多次使用(5)Compatibility:不同的软件系统之间相互可容易的集成(6)Efficiency:软件的性能效率(7)Protability:软件可方便的在不同的技术环境之间移植(8)Easeofuse:容易学、安装、操作、监控(9)Functionality:系统提供可能性的范围(10)Timeliness:指软件系统在用户使用时或使用之前是否能及时发布另外，还有很多其他的外部质量属性 2.Internalqualityfactors*(1)Readability(2)Understandability(3)Clearness(4)Size 3.Fivekeyqualityobjectivesofsoftwareconstruction(1)Easytounderstand:elegantandbeautifulcode/understandability(2)Readyforchange:maintainabilityandadaptability(3)Cheapfordevelop:designfor/withreuse:reusability(4)Safefrombugs:robustness–Efficienttorun:performance 参考文献 https://www.cnblogs.com/weibanggang/p/9455926.htmlhttps://blog.csdn.net/qq_29373285/article/details/81487594https://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/index.html#bib-example-project 
第27篇文章[0]
软件构造笔记（十三）---PPT第九讲 面向复用的软件构造技术 LSP原则-Liskov替换原则协变Co-variance通配符逆变Contra-variance 比较Comparator<T>Comparable<T> Delegation委派CRP委派的四种形式 白盒框架黑盒框架 LSP原则-Liskov替换原则 一.基本内容（子类型多态）1.子类型可以增加方法，但不可删2.子类型需要实现抽象类型中的所有未实现方法3.子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance的参数4.子类型中重写的方法必须使用同样类型的参数或者符合contra-variance的参数5.子类型中重写的方法不能抛出额外的异常6.子类方法具有更强的不变量7.子类方法具有更弱的前置条件8.子类方法具有更强的后置条件 二.实例1.具有更强的不变量2.更弱的前置条件和更强的后置条件3.不符合条件的方法，调用GraphicProgram中的scaleW方法可能会导致h不等于w，破坏表示不变性4.不兼容的spec：三.满足条件1.前置条件不能强化2.后置条件不能弱化3.不变量要保持4.子类型方法参数：逆变5.子类型方法的返回值：协变6.异常类型：协变 协变Co-variance 父类型->子类型：越来越具体specific返回值类型：不变或变得更具体异常的类型：不变或变得更具体对于子类，更特定的类可能有更特定的返回类型为子类型的方法声明的每个异常都应该是为超类型的方法声明的某些异常的子类型。数组是协变的给定Java的子类型规则，T类型的数组[]可以包含T类型的元素或T的任何子类型。泛型不是协变的Box<Integer>不是Box<Number>的子类型，即使Integer是Number的子类型。给定两个具体类型A和B(例如，Number和Integer)，无论A和B是否相关，MyClass<A>与MyClass<B>没有关系。MyClass<A>和MyClass<B>的共同父类是Object。 通配符 一.使用通配符(?)指定无限制通配符类型，例如List<?>二.如下情况通常使用通配符：1.编写一个可以使用Object类中提供的功能实现的方法。2.当代码在泛型类中使用不依赖于类型参数的方法时。例如,List.size或List.clear。实际上，Class<?>之所以如此常用，是因为Class中的大多数方法不依赖于T。三.上下界1.低有界通配符<?superA>List<Interger>只匹配Integer类型的列表List<?superInteger>匹配Integer的超类型的任何类型的列表，如Integer、Number和Object。2.上有界通配符<?extendsA>总结来说 逆变Contra-variance 父类型->子类型：越来越具体specific参数类型：要相反的变化，要不变或越来越抽象 比较 Comparator<T> 若ADT需要比较大小，可实现Comparator接口并overridecompare()函数举例来说 //首先实现一个Edge类 publicclassEdge{ doubleweight; publicEdge(doublew){ weight=w; } publicdoublegetWeight(){ returnweight; } publicStringtoString(){ return"权重为"+weight; } } publicstaticvoidmain(String[]args){ List<Edge>list=newLinkedList<>(); list.add(newEdge(5.0)); list.add(newEdge(4.5)); list.add(newEdge(3.9)); list.add(newEdge(8.7)); //使用Comparator接口进行比较 Collections.sort(list,newComparator<Edge>(){ @Override publicintcompare(Edgeo1,Edgeo2){ if(o1.getWeight()>o2.getWeight())return1; elsereturn-1; } }); System.out.println(list); } 输出结果 Comparable<T> 另一种方法：让ADT实现Comparable接口，然后overridecompareTo()方法与Comparator的区别：不需要构建新的Comparator类，比较代码放在ADT内部。举例来说 //实现Comparable接口，重写compareTo方法 publicclassEdgeimplementsComparable<Edge>{ doubleweight; publicEdge(doublew){ weight=w; } publicdoublegetWeight(){ returnweight; } publicStringtoString(){ return"权重为"+weight; } @Override publicintcompareTo(Edgeo){ if(this.getWeight()>o.getWeight())return1; elsereturn-1; } } publicstaticvoidmain(String[]args){ Edge[]edge=newEdge[]{ newEdge(5.0), newEdge(4.5), newEdge(3.9), newEdge(8.7) }; Arrays.sort(edge);//使用Arrays.sort()方法进行排序 System.out.println(Arrays.toString(edge)); } Delegation委派 委派/委托：一个对象请求另一个对象的功能与继承的区别继承:通过新操作或重写操作来扩展基类。委派:捕获一个操作并将其发送给另一个对象。如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现。一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。 尽量用delegation代替inheritance CRP 类应该通过它们的组合(通过包含实现所需功能的其他类的实例)来实现多态行为和代码重用，而不是从基类或父类继承。组合一个对象可以做什么(has_a或use_a)比扩展它是什么(is_a)要好。“委托”发生在object层面，而“继承”发生在class层面举例：使用CRP原则实现使用接口实现公共的方法但不同的实现通过接口的组合定义行为的组合，从组合接口中派生具体类，在类中进行委派，可以通过委派实现对象实例和方法的调用 委派的四种形式 1.Dependency:临时性的delegation使用类的最简单形式是调用它的方法;两个类之间的这种形式的关系称为“use-a”关系，在这种关系中，一个类利用另一个类，而没有实际将它作为属性合并。例如，它可以是一个参数，也可以在方法中本地使用。依赖关系:一个对象的实现需要其他对象(供应商)的临时关系。2.Association:永久性的delegation关联:对象类之间的持久关系，允许一个对象实例导致另一个对象实例代表它执行一个操作。has_a:一个类有另一个类作为属性/实例变量-这种关系是结构性的，因为它指定了一种对象连接到另一种对象，而不代表行为。3.Composition:更强的association，但难以变化组合是一种将简单对象或数据类型组合成更复杂的对象或数据类型的方法。is_part_of:一个类有另一个类作为属性/实例变量。4.Aggregation:更弱的association，可动态变化聚合:对象存在于另一个对象之外，在另一个对象之外创建，因此它被作为参数传递给构造函数。总结 白盒框架 通过subclassing和overriding方法扩展1.允许每个非私有方法的扩展2.需要理解超类的实现3.一次只有一个扩展4.一起编译5.通常是所谓的开发框架 黑盒框架 通过委派和接口组合实现方法1.允许在接口中公开功能的扩展2.只需要了解接口3.多个插件4.经常提供更多的模块化5.独立的部署6.通常是所谓的终端用户框架，平台 总结 
第28篇文章[0]
软件构造笔记（十六）---PPT第十二讲 面向正确性与健壮性的软件构造 两个特性健壮性正确性 错误与异常ErrorExceptioncheckedExceptiontry-catch-finallyuncheckedException自定义异常类 Assertions 两个特性 健壮性 1.健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度。2.面向健壮性的编程（1）处理未期望的行为和错误终止（2）即使终止执行，也要准确/无歧义的向用户展示全面的错误信息（3）错误信息有助于进行debug尽可能保持软件运行而不是总是退出两者的比较 正确性 正确性：程序按照spec加以执行的能力，是最重要的质量指标！永不给用户错误的结果 两者的对比： 错误与异常 Error 1.Error类描述了Java运行时系统内部很少发生的内部系统错误和资源耗尽情况(例如，VirtualMachineError,LinkageError)。不应该抛出这种类型的对象，如果发生这样的内部错误，除了通知用户并试图优雅地终止程序外，你能做的很少。内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结束2.种类（1）Userinputerrors用户输入错误（2）Deviceerrors设备错误（3）Physicallimitations物理限制 Exception 一.Exception类描述了由你的程序引起的错误(例如FileNotFoundException,IOException)。这些错误可以被你的程序捕获和处理(例如，执行一个替代操作或做一个优雅的退出关闭所有的文件，网络和数据库连接)。异常：你自己程序导致的问题，可以捕获、可以处理二.分类：1.运行时异常：由程序员在代码里处理不当造成2.其他异常：由外部原因造成 checkedException 1.处理方法：（1）你必须捕获和处理异常,或者告诉编译器不能处理它宣称你的方法抛出的异常,代码。（2）然后使用你的方法将不得不处理,异常(可以选择声明抛出的异常,如果它不能处理)。（3）编译器将检查我们是否完成了以下两件事中的一件(catch或declare)。2.编译过程：必须捕获并指定错误处理器handler，否则编译无法通过，类似于编程语言中的statictypechecking 从Exception中派生出子类型编译器可帮助检查你的程序是否已抛出或处理了可能的异常3.解决办法：（1）Declaringexceptions(throws)声明“本方法可能会发生XX异常”（2）Throwinganexception(throw)抛出XX异常（3）Catchinganexception(try,catch,finally)捕获并处理XX异常4.通过throws在函数头后和spec中均声明异常的种类父子函数–参见LSP原则（1）如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛（2）子类型方法可以抛出更具体的异常，也可以不抛出任何异常（3）如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。错误示例：5.通过throw（1）找到一个能表达错误的Exception类/或者构造一个新的Exception类（2）构造Exception类的实例，将错误信息写入，抛出它一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码6.通过try/catch异常发生后，如果找不到处理器，就终止执行程序，在控制台打印出stacktrace，所以可以通过try/catch捕获并处理异常举例来看：7.通过finally（1）当异常抛出时，方法中正常执行的代码被终止，如果异常发生前曾申请过某些资源，那么异常发生后这些资源要被恰当的清理，可以使用finally进行处理 （2）可以不使用catch子句而使用finally子句。不管代码是否抛出异常，finally都会被执行 try-catch-finally 分情况讨论：1.该代码不抛出任何异常。程序首先执行try块中的所有代码。然后执行finally子句中的代码。然后，执行finally子句后的第一个语句。换句话说，执行通过点1、2、5和6。2.代码抛出一个异常，该异常在catch子句中被捕获。程序执行try块中的所有代码，直到抛出异常为止。try块中的其余代码将被跳过。然后，程序执行匹配的catch子句中的代码，然后执行finally子句中的代码。如果catch子句没有抛出异常，则程序执行finally子句后的第一行。执行通过点1、3、4、5和6。如果catch子句抛出一个异常，那么该异常将被抛回调用者，执行只通过点1、3和5。3.该代码抛出一个未在任何catch子句中捕获的异常。在这里，程序执行try块中的所有代码，直到抛出异常。跳过try块中的剩余代码。然后，执行finally子句中的代码，并将异常抛回给该方法的调用者。执行只通过点1和点5。 uncheckedException ErrorsandRuntimeExceptions1.处理方法：（1）错误表示发生在应用程序之外的情况，例如系统崩溃。运行时异常通常是由于应用程序逻辑中的错误而发生的。（2）在这些情况下你什么都做不了，只能重写你的程序代码。所以编译器不会检查这些。（3）这些运行时异常将在开发和测试期间发现。然后我们必须重构我们的代码来删除这些错误。2.编译过程：可以不处理，编译没问题，但执行时出现就导致程序失败，代表程序中的潜在bug类似于编程语言中的dynamictypechecking 从RuntimeException派生出子类型3.举例：在编程和编译的时候，IDE与编译器均不会给出任何错误提示两者比较1.使用情况：（1）如果客户端可以通过其他的方法恢复异常，那么采用checkedexception；（2）如果客户端对出现的这种异常无能为力，那么采用uncheckedexception；（3）异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。2.对比表格 自定义异常类 为了定义checkedException，你要创建java.lang.Exception的一个子类(或子类的层次结构):可能抛出或传播此异常的方法必须声明它:举个例子： Assertions 一.定义：在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误。当断言为真时，意味着一切都按预期运行。当断言为假时，意味着它在代码中检测到一个意外错误。 
第29篇文章[0]
软件构造博客2.凸包问题的思考 在进行软件构造Lab1的时候，相信大家都会遇到求解凸包问题，而很多人在第一次接触的时候难免会产生疑惑，笔者就这个问题谈一下自己的思考和解决方法： 首先让我们明确一个问题：什么是凸包问题。 凸包（ConvexHull）是一个计算几何（图形学）中的概念。在一个实数向量空间V中，对于给定集合P，所有包含P的凸集的交集S被称为P的凸包。P的凸包可以用P内所有点(p1， Pn)的凸组合来构造。在二维欧几里得空间中，凸包可想象为一个正多边形，它的边界和内部包含着所有顶点。 按照笔者的理解通俗来说，就是把所有顶点看作一堆木棒，现在你需要去找到一根绳子画一个范围，将所有的木棍包括在里面。很显然，就跟我们平时拿绳子捆木棍一样，绳子最先接触到的肯定是最外面的木棍，而凸包就是这些以这些最外面的木棍作为顶点构成的凸多边形。所以我们接下来的问题就是分析如何去找到这些最外面的“木棍”以及相应的时间复杂度。 求解凸包问题主要有三种方法，本文主要讲解前两种方法： 方法一.暴力破解 没错，说到解决问题第一个思考的肯定是暴力求解。具体思想十分简单：对于一个n个点集合中的两个点p1和p2，当且仅当该集合中的其它点都位于穿过这两点的直线的同一边时，它们的连线就是该集合凸包边界的一部分，简言之，p1和p2就是凸包问题中最小凸多边形的顶点。对每一对点都做一遍检验之后，满足条件的线段就构成了该凸包的边界。 在编写代码过程中，我们只需要建立一个直角坐标系，然后求出p1和p2的直线方程，然后将其他点代入方程计算结果是否全部大于等于0或者小于等于0，如果是则是凸包边界上的点，否则就不是。 而本方法的时间复杂度比较容易分析，为O(n^3)。实现代码如下： publicclassConvexHull{ //返回点集合中凸多边形的点集合 publicstaticPoint[]getConvexPoint(Point[]A){ Point[]result=newPoint[A.length]; intlen=0;//用于计算最终返回结果中是凸包中点的个数 for(inti=0;i<A.length;i++){ for(intj=0;j<A.length;j++){ if(j==i)//除去选中作为确定直线的第一个点 continue; int[]judge=newint[A.length];//存放点到直线距离所使用判断公式的结果 for(intk=0;k<A.length;k++){ inta=A[j].getY()-A[i].getY(); intb=A[i].getX()-A[j].getX(); intc=(A[i].getX())*(A[j].getY())-(A[i].getY())*(A[j].getX()); judge[k]=a*(A[k].getX())+b*(A[k].getY())-c;//根据公式计算具体判断结果 } if(JudgeArray(judge)){//如果点均在直线的一边,则相应的A[i]是凸包中的点 result[len++]=A[i]; break; } } } Point[]result1=newPoint[len]; for(intm=0;m<len;m++) result1[m]=result[m]; returnresult1; } //判断数组中元素是否全部大于等于0或者小于等于0，如果是则返回true，否则返回false publicstaticbooleanJudgeArray(int[]Array){ booleanjudge=false; intlen1=0,len2=0; for(inti=0;i<Array.length;i++){ if(Array[i]>=0) len1++; } for(intj=0;j<Array.length;j++){ if(Array[j]<=0) len2++; } if(len1==Array.length||len2==Array.length) judge=true; returnjudge; } 方法二.Gift-wrapping算法 本算法的基本思想为：遍历全部的点，找到最左侧的点，则这个点一定是凸包上的一个点，以这个点为凸包上的第一个点，初始角度为0°(相对于y轴正向的顺时针偏移)。接下来寻找凸包上的下一个点：遍历全部的点，找到从当前点的当前角度转向该点所需旋转最小角度的点。最后以寻找到的下一个点为当前点，当前角度更新为原角度加上旋转角度的和，然后继续去寻找下一个点，直到找到的下一个点为第一个时结束。 而本算法因为每次的起点都是上次找到的凸包点，因此外层循环的复杂度为O(W)，W为凸包上的点，内层循环每次都会全部遍历点，因此时间复杂度为O(n),因此总的是间复杂度为O(nW),在一般情况下凸包上的点的期望为logn，算法复杂度为O(nlogn),极端情况下，如下所示，所有点都在类似圆弧上的话，外层循环也是n，因此时间复杂度会达到O(n^2)。 算法实现： publicstaticSet<Point>convexHull(Set<Point>points){ if(points.size()<=2){ returnpoints; } HashSet<Point>result=newHashSet<Point>(); Pointtmp=points.iterator().next(); Pointstart=tmp; Pointtarg=tmp; doubleangle=0,a1=0,at=0; for(Pointp:points){ if(p.x()<start.x()||p.x()==start.x()&&p.y()>start.y()) start=p; } result.add(start); Pointptr=start; while(true){ at=TurtleSoup.newCalculateBearingToPoint(angle,ptr.x(),ptr.y(),targ.x(),targ.y()); for(Pointq:points){ if(targ==q) continue; a1=TurtleSoup.newCalculateBearingToPoint(angle,ptr.x(),ptr.y(),q.x(),q.y()); if(a1<at){//选择偏转角度最小的 targ=q; at=a1; }elseif(a1==at){//选择距离更大的 doubledist=TurtleSoup.calculateDistance(ptr.x(),ptr.y(),targ.x(),targ.y()); doubledis1=TurtleSoup.calculateDistance(ptr.x(),ptr.y(),q.x(),q.y()); if(dis1>dist){ targ=q; at=a1; } } } if(targ==start)//终止条件 break; else{ angle=at; result.add(targ); ptr=targ; } } returnresult; } 方法三.Graham-Scan法 本算法的思想是先找到凸包上的一个点，然后从那个点开始按逆时针方向逐个找凸包上的点，实际上就是进行极角排序，然后对其查询使用。时间复杂度为O（nlogn）。 具体实现方法略，读者可自行查阅相关文章。同时我们可以证明凸包问题的解法的时间复杂度不会低于O（nlogn），具体证明也请读者自行进行。 
第30篇文章[0]
软件构造博客3.代码测试思考 相信很多同学都发现，每次的软件构造实验都要求我们进行测试代码的编写，而且课程中也很重视测试对于编程的作用，那么测试为什么这么重要呢，我们又该根据什么原则编写测试代码呢，本文就此问题给出笔者的一些看法。 测试为什么那么重要 在软件开发的过程中，我们提倡测试驱动开发(TDD)的方法，原因正是基于测试的重要性： 1.测试是提高软件质量的重要手段 2.测试可以确认开发的程序是否达到用户需求 3.测试可以具体关注系统的某一特定方面的质量特性 4.先进行测试可以节省大量的调试时间 注：测试并不能保证程序100%没有错误！ 我们该如何进行测试 按照老师PPT上的介绍，良好的测试应该有如下特点： 1.能发现错误 2.不冗余 3.体现最佳特性 4.别太复杂也别太简单 而测试也是分层级的，从低到高依次为： 单元测试:是指对软件中的最小可测试单元进行检查和验证，Java里单元指一个类或一个方法 集成测试：也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行测试 系统测试：是对整个系统的测试，将硬件、软件、操作人员看作一个整体，检验它是否有不符合系统说明书的地方 验收测试：是部署软件之前的最后一个测试操作。在软件产品完成了单元测试、集成测试和系统测试之后，产品发布之前所进行的软件测试活动。 此外还有回归测试，它指的是修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。 测试方法有白盒测试和黑盒测试： 白盒测试：对程序内部代码结构的测试，要考虑内部实现细节 黑盒测试：对程序外部表现出来的行为的测试，黑盒测试完全从函数spec导出测试用例，不考虑函数内部实现 而我们实验中主要采用的方法是根据等价类的划分来编写测试样例： 基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例针对每个输入数据需要满足的约束条件划分等价类每个等价类代表着对输入约束加以满足/违反的有效/无效数据的集合。而相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为测试用例即可 可以按照下面的准则划分： 输入数据限定了数值范围 输入数据指明了特定的值 输入数据确定了一组数 输入数据是Y/N 笛卡尔积做到全覆盖和对于每个维度的取值则至少覆盖一次即可，测试完备，但用例数量多，前者测试代价高但是并非所有组合情况都可能，后者测试用例少，代价低，但测试覆盖度未必高，通常情况下在这两个方案之间选取一个折衷的方案。 以Lab2中ConcreteVerticesGraph的部分测试代码为例，读者自行体会这种以等价类划分为基础的测试样例编写： //Testingstrategy //按照加入的点划分：点已经存在，点不存在 //按照加入的权值划分：权值为0，权值大于0，权值小于0 @Test publicvoidtestAddsource(){ Vertex<String>vertex=newVertex<String>("a"); assertEquals(0,vertex.addSource("b",5)); assertEquals(0,vertex.addSource("c",3)); assertEquals(5,vertex.addSource("b",4)); assertEquals(4,vertex.addSource("b",0)); assertEquals(-1,vertex.addSource("b",-1)); } //Testingstrategy //按照加入的点划分：点已经存在，点不存在 //按照加入的权值划分：权值为0，权值大于0，权值小于0 @Test publicvoidtestAddtarget(){ Vertex<String>vertex=newVertex<String>("a"); assertEquals(0,vertex.addTarget("b",5)); assertEquals(0,vertex.addTarget("c",3)); assertEquals(5,vertex.addTarget("b",4)); assertEquals(4,vertex.addTarget("b",0)); assertEquals(-1,vertex.addTarget("b",-1)); } //Testingstrategy //按照移除的点划分：点已经存在，点不存在 @Test publicvoidtestRemovesource(){ Vertex<String>vertex=newVertex<String>("a"); vertex.addSource("b",5); vertex.addSource("c",3); assertEquals(0,vertex.removeSource("d")); assertEquals(5,vertex.removeSource("b")); } //Testingstrategy //按照移除的点划分：点已经存在，点不存在 @Test publicvoidtestRemovetarget(){ Vertex<String>vertex=newVertex<String>("a"); vertex.addTarget("b",5); vertex.addTarget("c",3); assertEquals(0,vertex.removeTarget("d")); assertEquals(5,vertex.removeTarget("b")); } 
第31篇文章[0]
软件构造博客4.Git多分支操作 在Lab3中，我们遇到了利用Git新建仓库和进行不同仓库的提交的操作，下文就这个问题给出较为详细的操作方法： 首先还是Github仓库和本地仓库的设立，这部分过程在我的博客1当中有介绍，有这部分需求的同学可以移步博客1，下面就让我们来看看怎么进行分支操作： 右击我们的本地仓库，选择GitBashhere，可以看到现在的默认分支为master，这时候我们想要新建一个分支change并且提交文件到Github的change分支上，则相关操作有： gitbranchchange(如果你想新建的分支是别的名字的话，这里就修改成你想要的分支名) 然后我们输入gitbranch，就发现现在有两个分支存在，而当前是位于master分支上，之后我们进行分支切换操作： 通过gitcheckoutchange进行分支切换，为了验证我们再次输入gitbranch，可以看到现在指向的分支为change，证明我们切换分支成功，具体操作截图如下： 之后的相关提交操作在我的博客1中有介绍，这里就不再介绍了，有需要的同学可以查看我的软件构造博客1。 
第32篇文章[0]
软件构造博客1.Git的相关操作和使用 博客主要讲述笔者实验中遇到的一些问题的解决方法： 在开始软件构造实验的时候，相信大家都会对利用Git进行提交文件到Github上的指令有困惑，本文就这个问题给出了较为详细的操作步骤。 Git的相关安装操作实验手册上面已经有了介绍，这里就不再赘述。同时你还需要一个Github账号和仓库（感觉在说废话。。）。 1.打开你的Github仓库，点击code，将上面的URL复制下来（其实直接利用浏览器复制也可以） 2.然后去本地建立仓库与Github上的仓库相关联，找到你想建立本地仓库的位置，右击，如果你之前成功安装了Git的话，会出现GitBashhere，点击它。 3.在命令行中输入gitclonehttps (就是你从Github上复制得来的URL) 然后我们就会发现在你创建的地方出现了一个和你Github仓库名一样的文件夹，那就是你和Github仓库相关联的本地仓库文件夹。接下来我们就要通过本地仓库将文件提交到Github仓库中。 4.将你想要提交的文件全部放入本地文件夹中，然后进入Gitbash，在命令行中输入如下代码： gitadd. （此操作是把文件夹下面的文件进行添加） gitcommit -m ”随便写（提交信息）” （提交信息随便写，但是在软件开发的过程中最好是你实验的进度） gitpush-uoriginmaster（分支名） （本操作是将本地仓库push到github上面的master分支，如果交到其他分支上需要修改分支名字，第一次操作可能需要你输入帐号和密码） 完成这些操作后，我们打开我们的Github仓库以后就能看到我们提交之后的结果了。 除了上面以外，还有一些笔者在实际实验过后得出的一点可能称得上是建议的几点： 1.虽然Github也能手动提交，但是效率比较低，而且如果验收方是利用软件进行文件的检查的话手动提交的文件可能不会被查到，而且利用Git提交还能让开发者在Github上看清每次提交的差别，因此实际应用中笔者还是鼓励大家利用Git将提交到Github上。 2.虽然我们学校的WIFI自称能够直接访问Github，但是根据笔者自身体验下来，这种情况很少，甚至几乎没有==，不知道别的同学是不是跟我一样，所以还是鼓励大家在进行访问和提交操作的时候进行一些合理的“科学上网”，从而提高使用Git和Github的体验。 
第33篇文章[0]
软件构造博客5.正则表达式梳理 在Lab3的实现过程中涉及到正则表达式的解析，本文就这个问题给出相关知识点的梳理。 首先我们先要了解什么是正则表达式。根据定义，正则表达式(regularexpression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 正则表达式是由普通字符（例如字符a到z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 在实际应用过程中我们使用grammar判断字符串是否合法，并解析成程序里使用的数据结构，通常是递归的数据结构。 url::=‘http://’hostname‘/’hostname::=‘mit.edu’|‘stanford.edu’|‘google.com’ 其中，url是根节点（特殊的非终止符），与’google.com’相似的是终止符，hosname是非终止符 操作： 连接：x::=yz（空格）重复（0次或多次）：x::=y*选择：x::=y|z有无：x::=y?重复（1次或多次）：x::=y+区间：x::=[a-c]equalsx::=‘a’|‘b’|‘c’x::=[aeiou]equalsx::=‘a’|‘e’|‘i’|‘o’|‘u’不包含区间：x::=[^a-c]equalsx::=‘d’|‘e’|‘f’|…*?+优先级最高，连接次之，|最低而正则语法的定义为：简化之后可以表达为一个产生式而不包含任何非终止节点 正则表达式的语法规则为： 
第34篇文章[0]
软件构造博客6.final的功能用法总结 关于final，相信使用过Java的人都对它不陌生，而本文则将对它的功能和用法进行总结。 final关键字是一种变量前面的修饰符，代表着程序员的最终决策，final变量只能被赋值一次。 例如以下例子 finaldoublea=3.1; a=3.1412; finaldoubleb; b=3.1; b=3.1412; 以上两种方法都是错误的，因为对于double来说，final变量只能被赋值一次。同时对于基本的数值变量，比如int,float,double,boolean,其final一旦被确定则不可以进行任何修改。（如上面例子） 然而对于那些可变的（mutable）对象（object）变量，比如Data类，stringbuilder等，final只是固定了对其的引用，并不能保证其中的值不被修改。 如下例子： finalStringBuilderstringBuilder1=newStringBuilder(); stringBuilder1.append("Iamsosmart "); System.out.print(stringBuilder1); finalStringBuilderstringBuilder1=newStringBuilder(); StringBuilderstringBuilder2=stringBuilder1; stringBuilder2.append("Iamsosmart "); System.out.print(stringBuilder1); 以上两种方法都是可行的，所以我们到底该怎么理解final呢？ 笔者的理解是： 把final想象成一个固定的引用即可，对于基本变量类型，其被彻底固定，对于对象变量，我们仍可以使用其引用去修改它。 
第35篇文章[0]
软件构造6 在此记录一个之前从未了解到的问题。 首先来看本人定义的一个ADT，命名为Employee，定义的ADT如下： publicclassEmployee{ privatefinalStringname; privatefinalStringjob; privatefinalStringphone; //Abstractionfunction: //name映射为员工名字，job映射为员工职务，phone映射为员工电话号码 //Representationinvariant: //name,job,phone都不为空 //Safetyfromrepexposure: //使用privatefinal修饰实例字段，防御式编程。 /** *初始化 *@paramname员工名字 *@paramjob员工职务 *@paramphone员工电话号码 */ publicEmployee(Stringname,Stringjob,Stringphone){ this.name=name; this.job=job; this.phone=phone; checkrep(); } /** *获得员工名字 *@return员工名字 */ publicStringgetname(){ returnname; } /** *获得员工职务 *@return员工职务 */ publicStringgetjob(){ returnjob; } /** *获得员工电话号码 *@return员工电话号码 */ publicStringgetphone(){ returnphone; } /** *检查 */ privatevoidcheckrep(){ assertname!=null; assertjob!=null; assertphone!=null; } @Override publicStringtoString(){ Strings="Employee:\n"+"姓名："+name+"\n"+"职务："+job+"\n"+"手机号码："+phone+"\n"+"\n"; returns; } @Override publicbooleanequals(Objectobj){ if(obj==null){ returnfalse; } if(objinstanceofEmployee){ if(this==obj){ returntrue; } Employeee=(Employee)obj; if(name.equals(e.name)&&job.equals(e.job)&&phone.equals(e.phone)){ returntrue; } } returnfalse; } @Override publicinthashCode(){ returnname.hashCode()+job.hashCode()+phone.hashCode(); } } 其中，name、job、phone均为privatefinal修饰的，而在重写equals的过程中，我们发现在将obj强制类型转换为Employee后，在判断两个对象的name、job和phone是否相同的过程中可以直接访问e中的name、job和phone，即可以直接使用e.name、e.job、e.phone，而name、job、phone这三个表示都是privatefinal的，按常规认识来说应当无法直接访问到，所以这是一个非常有意思的地方。 在翻阅PPT后，我们又发现了一处出现这种情况的地方，如下图所示。 这里，first和last都是privatefinal的，但在重写的equals中都可以直接通过n.first和n.last访问。 这种情况是之前在编程中未曾发现的，如果可以通过这种方式访问内部的表示的话，也就免去了在equals方法内部调用getname、getjob和getphone方法才能得到相应的表示的麻烦，更加清晰、明了。 
第36篇文章[0]
软件构造5 由于软件构造课程需要用到git来提交实验结果，而本人是第一次使用到git，在使用过程中遇到了许多问题，故在此记录下一些git的使用方法以及一些问题的处理。 一.仓库克隆 1.右键点击要克隆到的本地文件夹，选择gitbashhere。 2.在命令行中输入gitclone+要克隆的仓库的URL地址，回车，即可将远程的github上的仓库中的东西克隆到本地的文件夹中。 二.提交 1.右键点击要提交的文件或项目文件夹，选择gitbashhere。 2.输入gitinit命令，回车，用来在当前项目的目录中生成本地的git管理库，我们可以发现在当前目录下多了一个.git的隐藏文件夹。此步骤即为初始化本地仓库。 3.输入gitadd./gitadd*命令，回车，将项目中所有的文件添加到缓存区中。如果想添加特定文件，把.换成对应的文件名即可。 4.输入gitcommit-m"firstcommit" 命令，回车，即可将缓存区中的文件提交到本地仓库中。其中双引号中的内容为注释，可以根据个人需要进行修改。 5.如果是第一次操作，可能会出现需要输入邮箱以及名字的提示，根据提示输入完毕后，再次输入gitcommit-m"firstcommit"即可。 6.输入gitremoteaddorigin+自己的仓库URL地址，回车。即可将本地仓库连接到远程仓库，即github上的仓库。 7.输入gitpushoriginmaster，回车，将本地仓库中master分支上的内容上传到github仓库中，等待一会后看到文件上传的过程显示完成后即为提交成功。 注：在gitpush的过程中可能会弹出failedtoaccess或timedout等提示，这些提示并不是说明提交的过程出错，而是只是因为网络的问题暂时无法连接到远程仓库，遇到这些问题时可以尝试反复提交直到成功为止，或使用加速器进行提交。没有意外情况的话多尝试几次即可成功。 三.创建新分支 1.右键点击要创建新分支的文件或项目文件夹，选择gitbashhere。 2.输入gitcheckout-b+新的分支名，回车，即可创建新分支。这时可以看到文件夹后面的分支名变为了新建立的分支名。 3.然后即可依照二中的步骤在新的分支上进行添加文件到缓存区并将缓存区的文件提交到本地仓库等操作。 4.如果需要将新的分支提交到github，则需要输入gitpushorigin+新的分支名，回车，即可向上述过程那样将文件或项目提交到远程仓库。 5.如需切换回master分支，可以输入gitcheckoutmaster，回车即可。想切换到其他分支只需要输入gitcheckout+分支名即可。 注：在切换分支后，本地文件夹中文件的内容会根据分支的不同进行改变。其内容会与本地仓库中文件的内容保持同步，故在切换分支进行文件更改时需要注意。且若其中一个分支中的本地文件被修改，在切换到其他分支前需要先将修改后的内容提交，再切换分支，否则修改后的内容无法保存。 
第37篇文章[0]
软件构造3 继承 继承关系可以有效地在先前定义的某个类的基础上实现其定义的所有方法功能，并添加自己的独特方法功能。继承关系不仅能够体现复用的价值，还能够使设计思路变得清晰，逻辑结构更加鲜明。同时能够减少工作量，也更容易应对新的变化。 在继承时应遵循LSP原则，final定义的类无法派生出子类，且子类应比父类具有更强的规约、更强的不变量。子类型可以增加方法，但是不能删除。子类型需要实现抽象类型中的所有未实现方法。子类型中可以重写父类型中的方法，但是需要满足子类型方法的参数满足逆变、子类型方法的返回值满足协变且子类型不能抛出比父类型更多的异常。 逆变的过程是参数不便或变得越来越抽象的过程，如从String变为Object，但是目前java中遇到这种情况只能当做overload看待。 
第38篇文章[0]
软件构造2 1.静态类型语言：在编译阶段进行类型检查并发现错误，避免将错误代入运行阶段，提高了代码的正确/健壮性。 动态类型语言：在运行阶段进行类型检查。 静态检查无法检查出与变量值有关的错误。可以检查出：语法错误，类名/函数名错误，参数数目错误，参数类型错误，返回值类型错误。 动态检查能检查出：非法的参数值，非法的返回值，越界，空指针。 2.final类无法派生子类。final变量无法改变值/引用。final方法无法被子类重写。 3.不变对象：一旦被创建，始终指向同一个值/引用。可变对象：拥有方法可以修改自己的值/引用 4.不可变类型，在修改时会频繁发生拷贝。 5.可变还是不可变：（1）看方法是否改变参数（2）看return是否是mutable类型（3）保证所有属性都是private，尽量加final。有时引用不可变但是指向的值是可变的。 6.List在遍历时被修改，就会发生某些错误或抛出异常。可以用iterator自带的remove方法。如果用List.remove删除元素，那么可能会发生遍历过程中的元素经过修改后的下标与期望的下标不匹配的情况。 
第39篇文章[0]
软件构造4 1.参数类型是否匹配，在静态类型检查阶段完成。返回值类型是否匹配，也在静态类型检查阶段完成。 2.精确的规约有助于划分责任，规约可以扮演防火墙的角色。只讲能做什么，不讲怎么实现。可以通过规约判断方法的等价性。 3.静态类型声明是一种规约，可据此进行静态类型检查staticchecking。 4.spec变强：更放松的前置条件+更严格的后置条件。在比较后置条件时，应该在满足对方的前置条件的情况下进行判断。一旦规约1比规约2强，那么可以用规约1替换规约2。5.抽象数据型由操作定义，与内部实现无关。 6.可变与不可变数据类型。可变数据类型：提供了可改变其内部数据的值的操作。不可变数据类型：其操作不改变内部值，而是构造新的对象。 7. 构造器：可能实现为构造函数或静态函数。构造器被实现为静态函数，通常被称为工厂方法。工厂方法用于创建对象，属于静态方法；实例方法在创建对象后才能调用函数并且工作。 生产器：新产生的数据与旧的数据类型一致。 观察器：数据类型不一致。 变值器：改变函数内部对象属性的方法。变值器通常返回void则必然意味着它改变了对象的某些内部状态。也可能返回非空类型。 8.抽象空间A：抽象值构成的空间，即client看到和使用的值。表示空间R：内部表示的值构成的空间，其中既有非法的表示值，也有合法的表示值。AF：表示空间R与抽象空间A的映射关系。一定是满射，但未必是单射，也未必是双射。即R中的非法值没有映射对象，R中的多个合法值可能映射到A中相同的值。AF应当显示的以注释的形式写在代码中，以便于理解。 9.表示独立性：不暴露内部属性与实现方法。 10.RI：一种要求，说明R中的值哪些是合法的，哪些是非法的。RI也应该显示的以注释的形式写在代码中，用于时刻提醒自己。 11.在所有可能改变rep的方法内都应该调用checkRep来检查。checkRep只是自己用于在编程时防止出错或产生非法的表示值所定义的方法。这是一个良好的编程习惯。 12.设计ADT方法：(1)选择R和A；(2)RI：合法的表示值；(3)AF：如何解释合法的表示值。 
第40篇文章[0]
软件构造1 在经过一段时间的软件构造课程以及java编程的学习过后，本人总结了许多收获与先前未曾了解的知识，在此将分成几个部分进行阐述。 1.接口以及面向对象的编程 对于java语言来说，最突出的优势就在于其面向对象的编程能力。其中接口是很方便的一个工具。当接口被定义好后，后续可以有多种实现。当完成这些不同的实现后，可以根据具体的需求来使用不同的实现。这样可以很好地进行复用。在具体的需求发生变化时，也可以更加灵活地进行调整与改变，而不需要像面向过程的编程那样需要调整许多代码，且每面临一次变化都需要调整一次代码，这样的代价未免过高，也不适合进行维护。所以，接口就显示出了独特的优势。 2.测试驱动的编程 经过这一段时间的编程体会，我深刻地感受到了测试驱动的编程带来的好处。在每次编写代码的实现之前，先写好测试用例是一个非常好的习惯。测试用例不仅可以全面地测试我们的实现代码，更重要的是能够引导我们的编程思路。同时，当完成了测试用例后，在编写实现的过程中可以随时进行测试，这样便于我们随时发现并更改实现中的错误。若总是先将实现写好后再编写测试用例，则若测试用例不通过的话我们也很难找出代码中的错误，这样便会浪费大量的时间。同时，若测试用例的编写全面的话，也会使我们注意到一些我们未曾发觉的潜在的风险，或是在我们的实现中并未考虑到的情况。所以测试驱动的编程会带来许多好处。再编写测试用例时，要做到全面、精简。要划分好等价类，并用笛卡尔乘积全覆盖的方式进行编写，以保证各个情况的分类的组合都能够测试的到。同时也要注意精简，不必重复很多相似或同类的测试用例。 
第41篇文章[0]
Java关于日期 周工作日 时间戳的转换 Lab3开发应用的过程中，与用户交互使用的格式大多是日期和周工作日的形式。比如日期：2021-07-04；周工作日形式：1(Monday)…7(Sunday)。而应用底层ADT的处理过程都是基于绝对时间戳的。在ADT将结果计算出来之后，同样要以日期或周工作日的形式打印信息反馈给用户。因此在这个过程中反复用到了日期与绝对时间戳的互相转化。自己造轮子写转化算法是比较麻烦的，难度不大，但细节很多（腊月、2月、闰年、平年），调试也需要花一番功夫。上网查了查，大概知道了java自带的日期类Date、日历类Calendar，以及日期格式化类SimpleDateFormat。借助这几个类的接口可以直接实现转化。但需要注意的是，这几个类的时间可以精确到毫秒级，也就是说转化后的时间戳1个单位表示1毫秒。而我们的应用中完全不需要如此高的精度，应用一精确到日，应用三精确到小时即可。虽然实验指导书上非常有先见之明的建议将ADT内部有关时间戳的类型全部定义为long，但调试的时候看一堆十几位的整数也是够累眼睛的，不如手动调整一下精度。原来想的是：一天24小时、一小时60分钟、一分钟60秒、一秒1000毫秒，那么只需要将精度为毫秒的时间戳/24/60/60/1000即可，这样得到的结果1个单位就表示1天，同理如果要精确到小时只需/60/60/1000。但测试了一下发现并不对，这么直接除是除不尽的。急中生智我打印了一下时间戳1对应的日期，是1970-01-01…。总之是位于这个日期中午的某个时间段而不是00:00。那么显然事件戳的起始点并不是1。但几乎可以肯定1970应该是万年历的起点（Windows系统时间起点就是1970）。那么顺势打印一下1970-01-0100:00的时间戳，发现为-28800000，看来起点是这个数（至于为甚么要设这么个奇怪的数当起点我也很迷惑）。那么我们只需要在上面的计算公式中引入28800000这个偏移量就行了。日期转时间戳的时候，要先将java自带类的转化结果+28800000，再依次除掉那些常数，最后2021-07-02这个日期顺利的除成了18335（具体多少忘了）左右一个数，大概算一下从1970年到现在差不多就是这么多天，那么我们的转换应该没有大问题了。日期转时间戳（精确到日）代码如下： /** *将日期转化为抽象的时间戳 * *@return转化后的时间戳 */ publiclongDate2Time(Stringdate)throwsParseException{ SimpleDateFormatformat=newSimpleDateFormat("yyyy-MM-dd"); Dated=format.parse(date); return(d.getTime()+28800000L)/1000L/60L/60L/24L; } 相应的反过来时间戳转日期需要-28800000这个偏移量（逆运算嘛），代码如下： /** *将时间戳转化为人可以看懂的格式化日期 * *@return格式化日期字符串 */ publicStringTime2Date(longtime){ time=time*60L*60L*24L*1000L-28800000L; SimpleDateFormatformat=newSimpleDateFormat("yyyy-MM-dd"); returnformat.format(newDate(time)); } 有了这两个函数，在与用户交互时表示问题就非常方便了。 
第42篇文章[0]
Java防止内部成员变量外部泄露的措施 做Lab2时最大的收获是关于防泄漏方面的方法和思想。有必要写一点东西记录一下。 其实在此之前我本以为类内部的成员变量暴露给外界是无所谓的。去年暑假的java语言课我写的所有类成员变量全部是public修饰的，自认为这样在类外部可以直接引用查看更加方便。现在想想还是当时还是所知甚少。 Java语言一个很大的特性就是取消了指针类型，这也导致Java中除基本数据类型(int等类型)之外所有类型作为参数传递时传递的是引用（其实个人理解传递的全都是指针地址）而不是一个类的副本。如果某个可变类作为成员变量被暴露在外部，那么这个成员变量在外部可谓是一丝不挂的，外部可随意操纵、修改它，如果有人怀有恶意那么后果可想而知了。所以一定加以保护。 首先是成员变量的权限修饰词，非特殊情况成员变量一致用private修饰，仅限类内部直接使用，如果外部需要查看，则单独写一个observer方法专门返回这个变量的值。 再者就是用final修饰。这个修饰词对于基本类型（int、boolean等）的后果是一旦赋值后便不能再修改，无论是内部还是外部。对于一些可变类（ListSet），这些类无法在外部被引用，内部可以直接使用或修改。而对于成员方法，用final修饰就代表无法被子类继承（断子绝孙方法）。所以一般情况下可变类成员变量都要用final修饰一下，基础类型变量视情况而定，如果在类中以一种条件常量存在，完全可以用final修饰。final这个修饰词还是非常安全的。 最后是关于成员方法返回值的问题。如果成员方法返回的是基础类型值，那么没有问题，因为这类值传递的不是引用，无伤大雅。但如果返回的是可变类，那么就有问题了。如果一个observer方法把可变类成员变量返回到外部，那么外部实际上还是得到了这个类的引用，即使用了final修饰仍然是非常危险的。所以我们在返回前要做一些安全性处理。一种方法是使用Collections.unmodifiableXXX()方法加固返回变量。使用这个方法处理后可变类若在外部遭到修改，那么系统立马会抛出异常。另一种方法是手动复制，在局部定义一个同类型的类，然后将所有信息复制到这个新类中作为副本返回，这样就直接避免了成员变量地址的暴露。 以上就是在实验过程中用到的所有措施，这种安全性的编程思想在以后非常关键。 
第43篇文章[0]
关于Java软件开发中Decorator设计模式的认识 Lab3最终敲定使用Decorator设计模式进行开发，最终结果证明这个选择是完全正确的。 Decorator设计模式本身强大的可扩展性和可复用性完全符合我的预期，对于上层ADT的开发没有占据多少时间（大量的时间都耗在了用户交互开发上了，打印信息真的是个枯燥而无脑的工作）。而且接口的具体实现类、Decorator类以及各个具体装饰类借助IDEA强大的纠错能力，根本没有调试，后续直接调用跑测试没出现任何底层的问题（问题还是全出现在输入信息提取、信息打印格式上）。 Decorator设计模式的核心是编写装饰类。一个基本的抽象装饰类Decorator是必不可少的，同时这也是Decorator设计模式最巧妙的地方。基本装饰类本身定义为接口的实现类，但又往往用abstract修饰，也就是说基础装饰类是不能直接调用的，他只是各具体装饰类相互结合的一个跳板。基础装饰类内部通过委派一个接口的多态来实现继承各个方法，正是因为这个委派，使得逐层装饰的效果都可以被组合。直接看一下用具体装饰类组装一个具有多种特性的ADT的定义方式： privatefinalNonBlankIntervalSet<Employee>DutyIntervalSet= newNonBlankIntervalSet<Employee>( newNonOverlapIntervalSet<Employee>( newUniqueIntervalSet<Employee>( newCommonIntervalSet<Employee>()))); 这是应用一中定义无空白、无重叠、标签唯一时间轴的方式。代表三种特性的具体装饰类依次嵌套，并作为参数传给上一层类的构造器进行构造。这种定义形式看起来非常复杂，但再看一下具体装饰类的写法就一目了然了： publicclassUniqueIntervalSet<L>extendsIntervalDecorator<L>{ publicUniqueIntervalSet(IntervalSet<L>set){ super(set); } /** *在当前时间轴中插入新的时间段和标签。 *若待插入时间段的标签与某个已有时间段标签相同，则不执行插入。 * *@paramlabel待插入时间段的标签 *@paramstart待插入时间段的开始时间 *@paramend待插入时间段的结束时间 */ @Override publicvoidinsert(Llabel,longstart,longend){ if(super.labels().contains(label)){ System.out.println("Labelalreadyexist!"); return; } super.insert(label,start,end); } } 这里标签唯一特性表现为重写了insert方法，在每次插入时间轴前检查该标签是否已经存在，如果不存在，再调用父类的插入方法，这就是新的特性。注意这里使用的是super，调用的是父类的方法。而每一个具体装饰类的父类都是基础装饰类Decorator。再看一下Decorator类的结构 publicabstractclassIntervalDecorator<L>implementsIntervalSet<L>{ protectedfinalIntervalSet<L>intervalSet; protectedIntervalDecorator(IntervalSet<L>set){ this.intervalSet=set; } @Override publicvoidinsert(Llabel,longstart,longend){ intervalSet.insert(label,start,end); } @Override //其他方法依次委派  //  } 也就是说在定义时将无特性的接口实现类CommonIntervalSet作为参数传入UniqueIntervalSet，UniqueIntervalSet的构造器将则个类传给父类进行构造，此时基础装饰类Decorato委派给了CommonIntervalSet。那么每次执行insert操作时，会进入UniqueIntervalSet的特性插入方法，如果达到了插入条件，他再使用super.insert通过父类操作，而其父类Decorator内部正是CommonIntervalSet，所以最后还是会调用CommonIntervalSet的插入方法。那么试想这样逐层嵌套，执行一个方法会根据这样的委派体系依次经历那些装饰类的特性操作，这样便实现了特性的组合。 需要注意的是，嵌套定义具有组合特性的ADT时，定义出来的ADT只能使用公用方法和最外层具体装饰类的特有方法。具体装饰类中一般通过重写方法来赋予特性。如果在具体装饰类中撰写新方法赋予特性，那么在定义时该类必须位于最外层嵌套，嵌套在内层的类的特有方法是无法直接调用的。 最后通过这样一种强大的设计模式，实验三最后新的变化一节修改特性时只需修改一行定义代码即可。因为对于Decorator设计模式来说修改特性就是重新组合嵌套装饰类，我们只需改变一下组装具体ADT时用到的装饰类即可。 
第44篇文章[0]
相对路径./../区别 相对路径：由于是相对的，所以必须有一个基准作为参照物来说明 /基准所在的最顶级目录即根目录，根目录是相对于其他子目录来说的 ./基准所在的当前目录 …/基准所在的当前目录的上一级目录（当前目录的父级目录） 
第45篇文章[0]
使用Git管理github远程仓库的方式 今天上的第一节软构课就要求我们学习使用Git，未来的三个实验全部通过Git提交。晚上下课后就回去搞了搞，比我想象的复杂，骂了Git一整个晚上。之前偶尔用过Github，都是通过网页上传附件的形式上传到仓库，这次整这个git属实给我整迷糊了。 Git被普遍称为功能强大的版本管理工具，强不强大暂时感受不出来，但是用起来真tm的麻烦。安装好后和远程仓库关联起来就废了半天劲。网上的教程大多是远程公开仓库关联本地仓库，奈何我们的实验仓库都是private的，关联需要密钥认证，根据为数不多的教程一步一步照着弄才勉强关联好。 首先本地创建一个本地仓库，在想要创建的文件夹下打开gitbash输入 gitinit 这样本地会多出一个.git隐藏文件夹，作为仓库管理文件。然后在bash创建输入以下命令配置身份 gitconfig--globaluser.name"username" gitconfig--globaluser.email"email" 之后生成rsa密钥作为和git交互的凭证 ssh-keygen-trsa-C"email" 然后在C盘用户文件夹.ssh文件夹下找到两个rsa文件，分别是秘钥和公钥。我们需要把公钥.pub交给github。具体就是打开github的设置添加一个SSHkey，把公钥内容复制进去。 然后在bush输入以下命令测试连接，连接成功就可以了。 ssh-Tgit@github.com 至此把github和本地认证好后，我推荐用Gitgui来执行以后的push操作，毕竟图形界面适合初学者。在图形界面中根据remote->add->branch…等等选项自己可以摸索出来和远程仓库建立连接，无非就是复制以下ssh设定一下分支名。然后就可以push上传。 当然这只是个开始，push的过程中我还经历了各种各样的错误，大多与git分支管理方式有关，git分支的管理属实有点复杂。如果push上传了一个文件，在本地又删除，之后再次上传会出现错误告诉你本地仓库滞后于远程仓库的更新balabala，死活不让上传。这时候开bash用-force选项强制上传即可。不知道把一个上传搞这么严格有什么用，也许以后能慢慢发现好处吧。 
第46篇文章[0]
Java文本文件读入方式 Lab1中遇到的唯一问题是有关文件读入的。要求读入一个.txt文本文件。百度了一下，具体方式如下： try{ Filefile=newFile("../src/P1/txt/"+fileName); if(file.isFile()&&file.exists()){ InputStreamReaderread=newInputStreamReader(newFileInputStream(file),"UTF-8"); BufferedReaderbufferedReader=newBufferedReader(read); StringLine; String[]splitArray; while((Line=bufferedReader.readLine())!=null)       }catch(Exceptione){ System.out.println("Filereadingerror!"); returnfalse; } returntrue; 这样通过各种文件类、流控制类可以实现打开文本文件。打开文件后可以将文本信息以字符串格式逐行读入到字符串变量中。 实验一整体上来说就是让你熟悉一下java语法和编程环境，学学用IDEA，没有什么太多值得记录的地方。 
第47篇文章[0]
2021-07-07 Chapter1:ViewsandQualityObjectivesofSoftwareConstruction1.1Multi-DimensionalViewsofSoftwareConstruction1.软件构造过程中的多维度视图2.视图之间的联系1.2QualityObjectivesofSoftwareConstruction1.软件系统的质量外部质量因素内部质量因素折中、妥协2.五个关键的质量指标1.1Multi-DimensionalViewsofSoftwareConstruction1.软件构造过程中的多维度视图多维度视图1 Moment PeriodCode-level Component-level Code-level Component-levelBuild-time Sourcecode,AST,Interface-Class-Attribute-Method(ClassDiagram) Package,File,StaticLinking,Library,TestCase, BuildScript(ComponentDiagram) CodeChurn ConfigurationItem,VersionRun-time CodeSnapshot,Memorydump Package,Library,Dynamiclinking,Configuration,Database,Middleware,Network,Hardware(DeploymentDiagram) Executionstacktrace,Concurrentmulti-threads Eventlog,Multi-processes,DistributedprocessesProcedureCallGraph,MessageGraph(SequenceDiagram)Moment维度关注于程序在某一个时刻的表现，而Period维度更关注于程序在一段时间内的表现；Build-time维度关注程序还未被投入运行，编码阶段的表现，而Run-time维度更关注于程序运行时的表现；Code-level维度关注程序的语句层面，Component-level维度更关注于一段代码，当作一个块观察比如一个包、一个库。(1)Build-time,moment,andcode-levelview关注的是源码的组织情况，可在词汇（源码）、语法（抽象语法树）、语义（类图）三个层面分别分析。 (2)Build-time,period,andcode-levelview关注的是代码的变化（Codechurn代码变化） (3)Build-time,moment,andcomponent-levelview关注的是包/库，而且是静态链接库 (4)Build-time,period,andcomponent-levelview关注代码的更迭，与(2)中不同的是，这个维度下更关注文件版本的变化，而不是具体语句的变化（2中关注的是哪一行代码被修改了）----VCS的引出 (5)Run-time,moment,andcode-levelview关注的是程序在某个时间点内存中的情况，如代码快照图(CodeSnapshot)、内存信息转储(Memorydump)。 (6)Run-time,periodandcode-levelview关注的是代码的执行情况，执行跟踪 (7)Run-time,moment,andcomponent-levelview关注的也是包/库，但却是在代码执行过程中的情况，如动态链接库 (8)Run-time,period,andcomponent-levelview关注的是系统的使用情况，使用日志查看 2.视图之间的联系 从无到有，写出了代码，就进入了Build-time维度，开始只是单个的没有任何联系的代码文件，所以是在moment+Code-level维度，此时随着时间的推移，代码删删改改，就属于Period+Code-level了，而代码越写越多成为了一个包，甚至形成了一个库，于是就属于moment+Component-level维度了，但是随着时间的推移，你的库文件由于需求的变化发生了变化，所以就属于Period+Component-level。代码写好了，投入运行，进入Run-time维度，观察的如果是某一句代码的执行后结果，那就是moment+Code-level维度，但如果看的是代码执行的轨迹，那就是Period+Code-level维度，而如果看的是一个库文件的连接情况等，那就是moment+Component-level维度了，如果看的是线程或进程的执行过程，也就是通过日志等手段查看一段时间内系统都做了什么事情，那么就是Period+Component-level了。 1.2QualityObjectivesofSoftwareConstruction1.软件系统的质量外部质量因素External1:Correctness（正确性），正确就是满足spec，这是软件开发最重要的因素，一个可用的软件一定是正确的，所以首要保证软件的正确性，其他的都可以做妥协、让步，但只有这一项不可妥协。 External2:Robustness（鲁棒性），通过抛出异常然后处理异常等方式让出错的程序恢复到正常的执行流程上。 External3:Extendibility（易扩展性），要便于软件功能的增加/扩展（ADT、OOP、留下一个Visitor），降低未来修改软件时的成本。 External4:Reusability（复用性），在异性之间尽可能地寻找共性，以便于未来可以直接使用现在写的这段代码。这样可以降低软件地开发成本。 External5:Compatibility（兼容性），在不同的环境下都是可用的，不同的软件系统之间相互可容易的集成。 External6:Efficiency（效率），不要过早的优化，性能在没有正确性保障的条件下是没有意义的。 External7:Portability（可移植性），软件可方便的在不同的技术环境之间移植。 External8:Easeofuse（易用性），学习成本低，结构简单、清晰，易于使用。 External9:Functionality（功能性），功能过多会导致易用性的降低。主要功能要首要提升质量。 External10:Timeliness（时效性），软件要能够在交付时间之前完成开发交给使用者。 External10++:Otherqualities，Verifiability(可验证性)，Integrity(完整性)，Repairability(可修复性)，Economy(经济性)。 内部质量因素代码行数(LOC)、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小 折中、妥协Integrityvs.easeofuse、Economyvs.functionality、Efficiencyvs.portability、Efficiencyvs.reusability、Economyvs.reusability、Timelinessvs.extendibility 这些质量属性之间往往不能兼得，当某一项满足的足够好的时候有可能其他项的表现极差，因而需要做权衡，使得各部分的表现都较好，在某些特定要求下也可以放弃优化其他项而做到某一项的极致，这需要靠开发者的经验积累来判断。 正确性是绝不能与其他质量因素折中的！！！ 在OOP开发中，通过封装、模块化、组件、抽象、分散、错误处理、信息隐藏、框架、接口等技术来尽可能地满足上述地质量因素，提高软件的开发质量。 2.五个关键的质量指标Elegantandbeautifulcode：代码要容易理解，通过统一变量/方法的命名标准、代码的风格、注释、包组织结构、必要时重构代码等方式让代码尽可能的容易理解。Designfor/withreuse：ADT/OOP、接口、继承(Overload、Override)、多态、泛型、框架等技术可用于提高代码的可复用性。Lowcomplexity：当复杂度较低的时候，代码就容易被扩展新的功能，所以要高内聚低耦合，遵从SOLID原则、OO设计模式、使用VCS控制代码版本Robustnessandcorrectness：使用测试驱动的开发、异常处理、Assertion机制、防御式编程等技术保证程序的健壮性和正确性。Performanceandefficiency：使用设计模式、并行/多线程等技术提升性能。 
第48篇文章[0]
Github将https方式改为ssh方式，进行push与clone 使用Git提交到Github时，若采用默认的https方式进行push与clone，则会比较慢，且对大文件容易出现报错的情况，故我们可以将其改为ssh方式。 步骤 打开Github的仓库，点击code，进入显示ssh的页面到本地项目文件夹子，打开gitbash。查看clone地址：git remote-v移除https的方式git remotermorigin添加新的git方式：ssh方式，ssh方式地址的话，在github上，切换到ssh方式，然后复制地址。gitremoteaddorigin刚刚复制的git地址git remote-v看到地址是以git@github.com:开头，说明ssh方式添加成功重新push（提交一下）git pushoriginmaste 完成以上步骤，便由https方式改为了ssh方式。 
第49篇文章[0]
哈工大软件构造Lab2导读-Stanford6.031ProblemSet2:PoeticWalks 文章目录 前言一、P1-Problem1：编写测试用例1.GraphStaticTest2.GraphInstanceTest 二、实现两个ADT1.AF，RI，SafetyfromRepexposure.etc2.checkRep()3.方法的具体实现4.实现Graph.empty() 三、PoeticWalks1.题目意思梳理（结合MIT页面和spec看）2.编写测试用例3.具体实现Poet1)构造方法GraphPoet2)生成句子方法Poem3)toString方法 4.测试代码覆盖度 四、重构Lab1中的SocialNetwork总结 前言 由于实验的介绍为MIT的全英文页面，要点分散，可能造成理解上的困难。所以在这里梳理总结一下软构lab2的整个流程，可以结合MIT的问题描述来看。希望能帮到后来的学弟学妹，不要拿到程序包直接两眼一抹黑，不知从何下手。 写下这篇文章是在完成实验后进行回忆，如有疏漏请多指正。 先简单总结Lab2完成的工作：从github将代码clone到本地，根据已有spec完成测试用例的编写（P1，Problem1），再分别编写两个ADT：ConcreteVerticesGraph和ConcreteEdgesGraph的具体实现（P1，Problem2/3）。之后，我们利用两个ADT分别实现具体的类GraphPoet，并完成一系列的工作（P1，Problem4）。并重构我们在Lab1中实现过的人际关系图（P2） 本实验的完成基于IDEA，可以方便地可视化代码覆盖度，所以没有涉及安装EclEmma。 一、P1-Problem1：编写测试用例 按照TDD（Test-DrivenDevelopment，测试驱动开发）的策略，在编写具体实现之前，我们需要根据已有的spec设计出对应方法的测试。 1.GraphStaticTest 这一部分是对Graph.empty()的测试，可以先不用管，在完成Problem3.2实现Graph.empty()之前，这一块的代码是跑不起来的XD对GraphStaticTest的补充也需要在Problem3.2中进行。 2.GraphInstanceTest 这一部分是对Graph中的具体方法进行测试，需要好好构思构思，如果刚开始草草写了/没有考虑周全，那么在后面代码覆盖度过低，会反复回头来修改这部分，耽误很多时间！ 具体而言，这一部分要按等价类划分的方法，编写测试用例。严格写下来的话，代码行数不少。举个栗子： TestingstrategytestRemove()测试remove()方法，等价类划分如下：删除点是否在图中：是，否删除点是否有相连边：是，否 排除不可能的情况，共3个等价类，所以需要写三组测试。 另外，提醒考虑ADT对有环图的支持并测试，后续部分会用到。 二、实现两个ADT 1.AF，RI，SafetyfromRepexposure.etc 具体实现两个ADT，首先要求我们撰写相信很多同学这是第一次实际写一个程序的AF、RI，这些概念的具体意义可以参见关于AF,RI,Repexposure其实举个例子，照葫芦画瓢也还算容易。例如，对于ConcreteEdgesGraph，它的这些概念可以解释如下： Abstractionfunction:AF(vertices)=Graph中的点AF(edges)=Graph中的边 Representationinvariant:点的名字不能重复所有点都在vertices中edge的权值为正两点间的单向边最多只能有一条 Safetyfromrepexposure:成员变量vertices与edges均用privatefinal修饰，防止其被外部修改在涉及返回内部变量时，采用防御性拷贝的方式，创造一份新的变量return 2.checkRep() checkRep()部分就是针对RI设计出检查代码。比如，在RI中有一条“edge的权值为正”，则在checkRep()中需要用assert语句检查edge的成员是否大于0，在每次运行方法（如add，set）且修改了成员变量后，需要在return前调用checkRep()进行检查。 3.方法的具体实现 在实现ConcreteVerticesGraph和ConcreteEdgesGraph时，MIT的页面要求先用String型，再用泛型L，其实可以直接用泛型L来写，节省后续改的工作量。若用泛型L来写，则需要将两个ADT的部分内容修改为如下： publicclassConcreteEdgesGraph<L>implementsGraph<L>{ } classEdge<L>{ } 和 publicclassConcreteVerticesGraph<L>implementsGraph<L>{ } classVertex<L>{ } 相关方法的具体实现在这里暂且不表，在完成方法的实现后，可以通过前面写的测试用例来检验方法编写是否正确，并看看代码覆盖度，有哪些代码没有覆盖到。（实验要求代码覆盖度尽可能达到100%） 在这里简单讲一下IDEA的代码覆盖度测试：运行之后： 另外注意，两个ADT中需要分别实现成员Edge与成员Vertex，在ConcreteEdgesGraphTest与ConcreteVerticesGraphTest中，需要完成对Edge与Vertex各自成员方法的测试。 4.实现Graph.empty() 这一部分要求我们对Graph.java中的empty()方法进行实现，具体来说，就是让empty()方法返回两个具体ADT中的一个，如图：完成后，在GraphStaticTest中补充测试代码，具体来说，就是模仿已有代码，验证在Interger，Double等类型下是否正确，如图： 三、PoeticWalks 到此，我们已经完成了MIT页面上的Problem1~3，开始解决Problem4。 1.题目意思梳理（结合MIT页面和spec看） 在这一步中，需要依据语料生成一个单词图，单词图的每个顶点是语料中的一个单词，单词图的边代表前一个单词紧接着后一个单词，边的权重为前一个单词紧接着后一个单词的次数，并且不考虑大小写与标点符号。举个例子： hello,hello,HeLlo,world! 其中，hello→hello出现两次，hello→world出现一次，则这个语料构成的图为：更加具体的示例可以参照MIT实验官网的页面。 在根据语料构造好图后，下面需要完成的任务是：输入一个句子，提取出句子两两相邻的单词对，在图中进行一次检索，若句子的前后两单词w1→w2在单词图中隔着一个顶点b，则将b加入句子中，得到w1→b→w2。具体的构建规则如下： ①w1与w2间只能间隔一个顶点，这也就是说，如果在图中出现了w1→a→b→w2，甚至间隔更多的情况，则不会在w1→w2间加入单词。 ②如果从w1到w2同时有两条路径w1→a→w2与w1→b→w2，则选择权重最高路径上的单词加入w1与w2之间。 ③输出的句子中原单词的大小写保持不变，加入的单词全用小写。 ④可以存在指向自己的边，即该图可以是带环图。 2.编写测试用例 在理清思路后，我们可以着手开始编写测试用例，具体的测试策略为编写Poem与toString方法的测试用例，对于Poem，采用不同的语料，测试能否得到正确的输出；对于toString，则用不同用例测试toString方法的正确性。 举个例子如图：在mugar-omni-theater.txt中保存着语料 ThisisatestoftheMugarOmniTheatersoundsystem. 此条测试的意义是输入句子input，经过图处理后，检验输出是否与我们的预期AccOutput相同。 3.具体实现Poet 在GraphPoet中，我们需要依次实现三个方法： 1)构造方法GraphPoet 在GraphPoet的构造方法中，我们需要读取文本文档，并由其中语料按照前文所阐述的方法生成一个单词图。具体实现方式为：输入文件路径并按行读入，将单词进行切分，进行删除标点符号，大写转小写等预处理，每次取相邻元素在图中添加新边。 2)生成句子方法Poem Poem方法输入一个String参数作为原始句子，输出根据单词图匹配过的，扩充了bridgewords的新句子。具体实现思路为一次读入两个单词，检索前一个单词子节点的子节点，若其中包含后一个单词，则选择途径通路权重最高的一路，将该路上途径节点表示的单词加入原来两单词之间。 3)toString方法 简单重写toString方法，将整个图中所有点的指向转化为一条字符串输出。 4.测试代码覆盖度 代码覆盖度建议尽量达到100% 四、重构Lab1中的SocialNetwork 这一环节要求我们基于在前面步骤中定义的Graph及其两种实现，将泛型L替换为Person，按照Lab1中SocialNetWorek的要求，实现Lab1Problem3中FriendshipGraph的各种功能，并且尽可能复用我们在前文构造的类中已经实现的方法。最后，运行提供的main()和执行Lab1中的Junit测试用例，确保其正常运行。 有Lab1的基础，这部分的重构算是比较快的。利用ConcreteEdgesGraphTest与ConcreteVerticesGraphTest其一便可完成。测试代码与main函数之间copy，略加修改就可。 总结 总得来说，Lab2相较于前几届的版本，难度降低了很多，但仍有不易理解的地方，需要花一些时间才能完成。 
第50篇文章[0]
类方法与实例方法的区别 类方法 用static修饰的方法。 由于类方法是属于整个类的，所以类方法的方法体中不能有与类的对象有关的内容。 即类方法体有如下限制： 类方法中不能引用对象变量；类方法中不能调用类的对象方法；在类方法中不能调使用super，this关键字；类方法不能被覆盖。 实例方法 当一个类创建了一个对象后，这个对象就可以调用该类的方法（对象方法）。 实例方法中可以引用对象变量，也可以引用类变量；实例方法中可以调用类方法；对象方法中可以使用super，this关键字。 区别和注意事项 区别 类方法可以通过类名调用，实例方法不能通过类名调用当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。 类方法在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出时才被取消。 注意 当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址。也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。 在Java语言中，类中的类方法不可以操作实例变量，也不可以调用实例方法，这是因为在类创建对象之前，实例成员变量还没有分配内存，而且实例方法也没有入口地址 
第51篇文章[0]
git配置SSH公钥，并与github在线仓库进行链接 首先参考其他资料完成git的安装 然后步入正题： ssh公钥的生成 1.进入C:\Users\Administrator\.ssh文件夹 2.在.ssh文件夹下打开gitbash，输入ssh-keygen-trsa，输入后一直回车即可生成秘钥：3.回到.ssh文件夹，可以看到生成的公钥与私钥。用记事本打开id_rsa.pub，复制其中内容到github的秘钥设置页面： 最后点击AddSSHKey，便完成了秘钥的设置。 SSH公钥链接在线仓库 通过 gitremoteseturlorigin在线仓库SSH地址 来链接对应仓库 相比https，通过ssh进行链接的好处是速度更快，且没有文件大小的上传限制。参考https://lanlan2017.github.io/blog/9f3d9944/ 
第52篇文章[0]
Java实现无向图深搜确定任意两点间最短距离 软件构造lab1实验中编写的Problem3部分，在此处做个记录 涉及的数据类，方法 Graph类表示无向图。其下有几个重要变量：persons：为ArrayList，用于保存graph中的节点。其定义为：publicList<Person>persons=newArrayList<Person>(); relationships：为嵌套的Vector，保存节点间的关系矩阵。若两节点直接相连，则对应位置为1；若两节点不直接相连，则对应位置为0。其定义为：publicVector<Vector<Integer>>relationships=newVector<Vector<Integer>>(); Person类表示图中的顶点。具有name与index两个私有变量，name为String类型，表示名称，是顶点的标识；index为int型，代表顶点在关系矩阵中对应第index行与第index列。若顶点不在图中，则index为默认值-1。getDistance方法输入参数为两个Person顶点，返回值为两顶点间的最短距离。为了方便说明，规定相连两点间距为1。方法声明为：publicintgetDistance(Personp1,Personp2) 算法基本思想 首先对异常情况进行判断，若输入两顶点相同/有不在图中的顶点，则直接返回-1。实现方法为具体根据person的index与name成员判断。进行BFS深搜。具体的实现如下：首先构造以下三个变量：intdistance=0;//起始点到终点的距离，初始为0 Queue<Person>queue=newLinkedList<Person>();//队列，用于BFS搜索 int[]visit=newint[persons.size()];//visit数组（visit为标志是否访问过的数组,访问过为1，否则为0） boolean[]isQueueEnd=newboolean[persons.size()];//isQueueEnd标志节点i是否是某轮bfs深搜的终点，若是，其为true，,需要使distance++ 在我们的算法中，先将初始顶点p1加入队列，因为其访问过，且为第0轮深搜的终点，故设置visit[]与isQueueEnd[]对应位为1。然后弹出该顶点，依次搜索与该顶点直接相连的顶点入队，将这些顶点的visit[]位均设置为1，且设置当前轮最后一个入队顶点的isQueueEnd[]对应位为1，由此，便完成了一轮BFS搜索。终结情况判断：当队首为终结顶点p2时，正常结束，返回distance。当检测到队空时，说明没有从p1到p2的通路，返回-1 以下图为例来解释我们的算法：假设计算从P1到P6的距离：1.先将P1入队2.弹出P1，加入P2,P3,P4，并标记P4为当前轮终点，distance++。3.之后按顺序依次进行:直到队首为P6，返回此时的distance值。 具体实现 person类 publicclassPerson{ privateStringname; privateintindex=-1; publicPerson(Stringname){ this.name=name; } publicStringgetName(){ returnname; } publicintgetIndex(){ returnindex; } publicvoidsetIndex(intindex){ this.index=index; } } getDistance()方法 /** *Addanewedgefromp1top2. * *@paramp1Thestartingvertexofthenewedge *@paramp2Theendingvertexofthenewedge *@returnTheshortestdistancebetweenp1andp2.Iftherearenoanypathsbetweenthem,return-1. */ publicintgetDistance(Personp1,Personp2){ //异常情况处理 //p1与p2有其一不在关系图中 if(p1.getIndex()==-1){ System.out.print(p1.getName()+"不在关系图中"); return-1; } if(p2.getIndex()==-1){ System.out.print(p2.getName()+"不在关系图中"); return-1; } //p1与p2相等 if(p1.getIndex()==p2.getIndex()){ return0; } Queue<Person>queue=newLinkedList<Person>();//队列，用于BFS搜素 intdistance=0; Persontemp=newPerson(""); PersonqueueEnd=newPerson(""); Vector<Integer>tempCol=newVector<Integer>(); //visit数组（visit为标志是否访问过的数组,访问过为1，否则为0） int[]visit=newint[persons.size()]; //isQueueEnd标志节点i是否是某轮bfs深搜的终点，若是，其为true，,需要使distance++ boolean[]isQueueEnd=newboolean[persons.size()]; //初始化，对p1进行设定 queue.add(p1); visit[p1.getIndex()]=1; isQueueEnd[p1.getIndex()]=true; while(queue.peek()!=p2){ temp=queue.poll();//弹出并保存queue的头元素 //将与queue头元素直接相连，且未访问过的元素入队 tempCol=relationships.get(temp.getIndex());//tempCol保存头元素对应的关系矩阵行 for(inti=0;i<tempCol.size();i++){//头元素对应的关系矩阵行，遍历此行中的所有元素，找到与头元素直接相邻的元素 if(tempCol.get(i)==1){ //查找index为i的person，并将其加入队列,同时把其标记为访问过 for(Persont:persons){ if(t.getIndex()==i&&visit[i]==0){ queue.add(t); visit[i]=1; queueEnd=t;//记录当前队尾 break; } } } } //最后队列空，说明没有p1到p2的直接通路 if(queue.isEmpty()) return-1; //记录当前队尾，并使distance++ if(isQueueEnd[temp.getIndex()]){ isQueueEnd[queueEnd.getIndex()]=true; distance++; } } returndistance; } 
第53篇文章[0]
HIT软件构造Lab3实验心得 首先是有关Git的，删除分支的一些操作，因为IDEA不能删除特定分支（可能是我不会？），先是gitbranch-bmain，这个main指的是你要删除的本地分支的名字，而后是gitpushorigin--deletemain，main指的是你要删除的远程仓库分支的名字。 接下来是整个实验一个很重要的地方，是关于MultiIntervalSet如何复用IntervalSet，这部分是个难点，我的想法是增加一个私有的成员变量xxx，其类型为List<IntervalSet<L>>，然后List中的元素的存放的时间段数量依次递减，insert时就寻找还没有插入该label的IntervalSet即可。 然后是装饰器Decorator，实现checkBlank或checkOverlap是通过两个具体装饰角色来进行的，而装饰器和具体装饰角色的其他方法是直接return的，此时如果已经插入有很多时间段的intervalSet进行装饰后，调用相关方法就会出现固定的返回值，因此我们要checkBlank时，需新建立一个变量，通过IntervalSet<L>intervalset=new具体装饰角色的名字(intervalSet);声明后调用checkBlank即可完成检查，而后续还需要用intervalSet时只能用intervalSet来调用方法，因为intervalset调用方法的返回值是固定的。 
第54篇文章[0]
新添加jar包，IDEA的maven工程pom.xml添加新的依赖时报错（TravisCI在线build） 笔者因为写JUnit测试用例时用到了assertThat(MapObject,hasEntry("key","value")); IDEA报错但根据提示仍不知道原因，后面才知道原来需要一个jar包--hamcrest-all.jar 从https://search.maven.org/search?q=g:org.hamcrest中下载了该包并将其移动到 .m2\repository\org\hamcrest目录下，然后从IDEA的ProjectStructure中添加了该包 一开始没添加依赖到pom.xml，直到要上传到GitHub并且在TravisCI进行在线build的时候，才添加依赖于pom.xml中，但出现了报错（因为之前问题解决了，所以现在hamcrest-all和它的version不报错了，这里拿hamcrest-library做实验），出现红字： 可以先在IDEA右侧的maven处点击reload： 如果字体不红的话问题就解决了， 但如果还不行的话，可能就要把jar包安装到本地仓库 当然前提是你需要安装和配置maven（教程挺多的） 安装配置后然后打开cmd，首先cd到你放置你新安装jar包的目录下， 然后输入：（这里拿hamcrest-all-1.3为例） mvninstall:install-file-DgroupId=org.hamcrest -DartifactId=hamcrest-all -Dversion=1.3 -Dpackaging=jar -Dfile=hamcrest-all-1.3.jar 其中-DgroupId、-DartifactId、-Dversion均可以在依赖中看到， （能查看添加依赖的网站：https://mvnrepository.com） -Dpackaging为包的类型，即jar -Dfile是当时新添加的包的名字。 输完命令后回车，然后若提示BUILDSUCCESS，则jar包安装到本地仓库成功。 成功后回到IDEA下再次reload。 
第55篇文章[0]
EclipseIDE的统计代码覆盖度工具EclEmma 首先，EclEmma是一个开源的软件测试工具，可以统计代码覆盖率覆盖率。 代码覆盖率用来刻画在软件测试里，被测试的程序的代码被测试的比例和程度。 在JUnit测试时，被测试代码被调用的比例是由代码在JUnit里使用的情况决定的。 EclEmma的安装：在Eclipse的Help中选取EclipseMarketplace 然后搜索EclEmma，点击Install即可直接安装EclEmma工具。 安装完毕后，右键选取你需要统计代码覆盖度的代码文件，选取CoverageAs，再选取JunitTest就可以测试出在Junit测试中的统计代码覆盖度。 调用后可以看见如图的标识： 绿色表示代码在JUnit测试中被执行到，黄色表示代码在JUnit测试中被部分执行到，红色表示代码没有在JUnit测试被执行到。 下方也有对于代码覆盖度的总体统计，最具体可以查看某个函数的代码覆盖度的数据。 
第56篇文章[0]
Java环境的配置 课程最开始配置Java环境，但是完全没有学习过Java。之前学习C语言，编译器和环境只需要直接安装一个软件即可，而对于Java的环境配置很复杂，最后从Mooc上的新手课程中才搞清楚各种环境的关系。 对于Java的在官网上，环境相关的有JVM，JDK，JRE，JSE。各个文件分别对应的功能如下：JVM：Java虚拟机，Java编译过后的.class文件需要在JVM上运行，是Java可以跨平台的原因。 JRE:Java运行环境，包含了JVM和Java程序所需的核心类库。如果只是需要运行一个开发好的Java程序，我们只需在计算机中安装JRE即可。 JDK:Java开发工具包，包含了Java的开发工具、编译工具、打包工具。如果需要进行Java编程，就需要下载JDK。 三者的关系：JDK包含了JRE，JRE包含了JVM 下载安装好对应的环境以后，与C语言不同的是，你需要自行下载编译器，Java环境里是不具有编译器，既编辑代码的功能的。推荐安装Eclipse作为编译器。通过Eclipse即可开始Java编程了！ 
第57篇文章[0]
JAVA可复用性 一.可复用性的度量、形态与外部表现1.可复用性简介 虽然说复用有不同层级，但是总的来说可复用性就是我们重复使用我们已经编写好的模块。因此过程分为两部分:在某些模块编写出可复用度高的代码，然后在某些模块尽量调用这些代码。 越抽象的东西，可复用性一般越强。因此总的来说，java中接口的可复用性大于抽象类，抽象类大于一般类。 可复用性高显然会带来很多优点：首先编写软件的过程会很愉快(如果能很简单复用的话)，可以让代码更标准，实现的更可靠等等。 但是有时为了提高可复用性，我们也会付出很高的代价，主要是很多时候想实现好的可复用性是很难的，会有很高的开发代价，维护代价以及复用时要进行适配带来的代价。比如Lab2中，Graph这个ADT想实现很好的可复用性就很简单，但对于棋类游戏，想让这个ADT对很多种特定的棋类都有很好的可复用性，就是非常让人头疼的事情。 2.可复用性的衡量 总的来说分为两点，一是复用的次数是否很频繁以及是否可以广泛的应用在很多情况之中(这两个有很强的正相关性，比如List可以广泛的被应用，所以理所当然的用的次数很频繁)；二是复用的代价如何。可见我们并不能定量的去判断某个软件可复用性效果如何，我们只能定性的做一些观察。 3.复用的层面 两种复用的方式：白盒复用和黑盒复用。黑盒复用就类似于调用API接口，或者方法等等；白盒复用是直接得到想要复用的源代码(或其他内容)等等，然后自己根据需要进行修改。 根据复用内容的结构从小到大，分为如下四种复用。 (1).源代码级别的复用:这个是最底层的复用，就是简单的复制粘贴修改。 (2).模块级复用:以class作为最基本的单元，复用的方式有继承和委托，其中委托的耦合度明显低于继承。 (3).类库级重用:相当于把一系列的class进行了打包，类似于第三方库的调用。 (4).框架级复用:在框架的基础上，填充自己的代码，形成完整系统。(其实就类似于一些实验中，给出了很多代码，要求我们填入一些自己的代码) 二.面向复用的软件构造技术1.LSP与泛型中的运用 在我们3.4的继承，多态，泛型等等的基础上，这里我们主要介绍LSP，即Liskov替换原则。 Liskov替换原则用数学性的语言来说，则如下图所示。 从实际设计的角度来说，这个原则其实就是对子类型的约束：要求子类型对象完全可以当作父类型的对象来使用，其中就包括了规约的前置条件不能强化，后置条件不能弱化，要保持不变量等等。 下面介绍协变与异变的概念。 协变：子类对父类方法的覆写中，异常、返回值的类型是父类方法中返回值的类型的子类型，就称之为协变。 逆变：顾名思义，与协变恰恰相反。 因此为了复合Liskov替换原则，我们要求如果有变化的话，那异常，返回值必须是协变，参数必须是异变(当然，在java语言中参数的异变或协变导致方法不再是覆写，而是重载)。 java中的泛型是类型不变的，如下图所示，是十分经典的例子。如果想进行协变或逆变，则需要使用通配符，例如List<?extendsNumber>是List<Number>的子类型，但是不论如何都要确保一个List中的元素都是一种类型的(尽管多种元素都可以放入)。 Class为类型类，详细的用法可以参考“java中的反射”，可以得到很多信息，来验证我们上面的说法。这里就不详细说明了。 2.委托与组合 委托顾名思义，类似于现实中我们委托别人去做一些事情，抽象到代码中，那就是在某个类的方法中，传入其他类的变量，把实现逻辑写在这个其他类的方法中，并在这个类的方法中调用。 例如我们想通过List的复用性实现stack，如果是继承关系的话，则stack中不可避免的有很多与我们期待的数据结构不匹配的方法。因此我们应该采取委托的方式，将pop等函数里某些操作委托给list即可。 由于继承过于严格，因此如果不是有很强的继承关系，使用委托会更合适。 总的来说，委托有四种形式。 (1).依赖(Dependency):逻辑即为AuseB,在A的方法中通过把B当作参数来或在方法的局部中，调用B的方法，是一种临时性的委托，只有调用这个方法的时候，它们才有临时关系。 (2).关联(Association):逻辑即为AhasB,对象A中的字段中有对象B，之后的操作和前面类似；只是A与B之间就有一个相对长的关系了。 (3).组合(Composition):逻辑即为BispartofB,A中有字段B，且在A被构造时，B就被初始化好了(A中的定义导致的，比如A中有privateTB=newT(…)语句)；因此它们声明周期一致。 (4).聚合(Aggregation):逻辑即为AownsB，与(3)很相似，只是B构造的方式是通过A的构造函数的参数。因此对于B的构造，比第三种要灵活。 3.框架设计 有两种形式：一是白盒框架，二是黑盒框架。 白盒框架：主要采用继承的方式，通过构建子类的方式进行扩展，子类中有main函数。代码是可见的，但是带来的问题就是要对父类的代码有了解，更贴近于开发者使用。 黑盒框架：主要采用用插件实现接口和委托的方式进行扩展，子类中没有main函数。更贴近于用户使用。 但无论是那种框架，控制权都是在框架手上的，这其实是框架和很多类构成的一个体系的区别。 至于如何设计好一个框架，总的来说与多个类之间的设计思想一致，只是需要更多的去了解这个框架的用途，然后更有针对性地去开发。 三.面向复用的设计模式 总的来说，针对开发的阶段不同，设计模式分为以下三种：创建型模式、结构型模式、行为类模式。本章主要是讲解其中与可复用性密切相关的一些模式。 1.结构型模式(1).适配器模式 主要是用于解决类之间的接口不兼容的问题。一般用于新版本的时候重新定义了接口或者新创建了一些类，要和旧版本写适配的时候。方式还是一样有两种，分为继承和委托，不过一般委托更方便些。 (2).装饰者模式 总的来说，就是把一个个特殊功能看成是装饰品，然后调用时通过决定加入哪些装饰品从而得到我们想要的结果，而不是通过继承的方式来得到具体的类。 具体实现方式就以ppt上冰淇淋这个例子来举例了，这也是最简单的一个装饰着模式的例子了。 我们对于一个冰激凌，想在它上面添加一些食料。由于不同种的食料可以组合，采用继承会组合数爆炸。因此我们可以采用如下的策略：首先定义接口，其中有我们想要有不同实现的方法：AddTopping()方法；其次，我们正常的实现没有任何装饰的类，用于委托；之后，我们定义一个装饰器基类，把没装饰的类的一个对象作为自己的一个字段(其实就是委托)，然后并不实现要装饰的方法，准备留到子类；注意这个类和没有装饰的类是类似于“兄弟关系”，都是实现共同的接口。 之后，我们再把对应的三种装饰方式实现为装饰器基类的子类，其中构造函数还是调用父类的构造函数，在待装饰的地方，就是先调用父类的操作，再加上自己独特的操作而成，这就是所谓的“装饰”。 之后客户端的调用就顺理成章了。我们想要哪些装饰，就套入哪个装饰的构造方法即可，就类似于递归调用，因为我们在编写类的时候方法的实现就是递归的。 不过这个模式在情况复杂的时候，写起来难度很大，逻辑上哪些应该先装饰，哪些应该后装饰还有冲突等如何处理也是个问题。 (3).外观模式 这个模式比较简单，其实就是客户端有的时候功能组合比较多，可能用起来比较复杂。因此我们就采用外观模式：用一个相对简化，统一的接口来实现对一系列接口的组合使用。 2.行为类模式(1).策略模式 其实这个模式也比较直观，就是实现的代码中，会根据用户输入的不同，采取不同策略的实现方式，就比如C++中的排序sort()函数，系统其实会根据输入的不同采取不同的算法。 当然，内部的实现可以是最简单的先评判输入，然后再生成对应的参数，调用其他接口(委托)；更好的更隐蔽的方式是使用工厂模式，这个在后面的章节中会介绍。 (2).模板模式 模板模式很适合白盒框架，其实就是在父类中定义一系列抽象方法(即为一个个流程)，以及一个方法来定义这些流程的实现步骤，然后再用子类去实现这一个个流程的具体步骤。可见，这个模式和策略模式有相似的地方，就是具体也是采用不同的方法，只是保证步骤一样。 (3).迭代器模式 不关心容器具体类型，用一种统一的方式进行遍历。 一般来说，实现的方式如下图所示。首先，这个类要实现Iterable接口，从而要实现蓝框中的方法得到迭代器。然后，我们就可以自己去实现对应的迭代器，其中这个迭代器要实现Iterator接口。通过这种方式，客户端在遍历的时候，完全无需看到迭代器是如何工作的。 
第58篇文章[0]
软件构造 ADT 一.ADT的基本概念 数据抽象：由一组操作所刻画的数据类型；强调的是操作而不是具体如何存储的。 可以看出对应的抽象可能有多种实现方式。所以可见ADT是由操作定义的，与内部实现方式无关；一般用户也不关心实现方式，只关心暴露出的操作(通过规约来达成一致)。 二.典型的类型和操作 类型上可分为可变数据类型和不可变数据类型，与3.1节的含义相同。 下面内容为重点 操作上可以分为四类，分别是构造器、生产器、观察器、变值器。 构造器是从无到有的过程，一般用构造方法或者静态工厂方法来实现。 生产器是从旧到新的过程，一般是一些对不可变类型的修改导致新生成一个对象等等的操作。 观察器顾名思义，仅仅是看我们想要得到的内容，而不进行修改。 变值器也是顾名思义，指的那些改变对象属性的方法。一般返回值为void的方法很可能是变值器。有变值器的数据类型就是可变数据类型，否则就是不可变数据类型。 三.ADT的设计法则 法则1：操作要简洁，一致。对于复杂的操作，应该拆分成多个简单操作的叠加，以此提高内聚性。 法则2：操作要全面(即需要的功能要可以实现)，且为用户提供方便的操作。 法则3：要不是针对抽象，要不是针对具体，不要两者混合。因此面向具体应用的类型不应该有通用方法，面向通用的类型也不该有具体方法。 四.表示独立性 表示独立性(RepresentationIndependence)的含义为，客户端使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端，客户端调用的结果应该是相同的；也就是我们前面一直强调的用户调用与内部实现方式无关。 五.ADT的测试 总的来说，对构造器、生产器、变值器的测试要用观察器检查；对观察器的测试要用其他三类方法来产生或构造对象。但这样的风险是，可能会产生互相依赖的现象，导致无法找到真正的错误原因。 解决方案：新创建一些方法来解除这些耦合，或者是把一部分私有方法改为公有方法，测试完后再换回私有。或者如果对于小型程序，只要测试结果都是正确的，也就可以解决问题。 六.不变量 不变量就是ADT在使用的过程中永远为真的性质，与客户端的行为无关。为了确保ADT使用时的正确性以及出错误时定位错误，我们一般会经常判断我们的不变量是否为真。 例如不可变类型是不可变的，自己设计的set中不能有重复值(要求不能有重复值)等等。 一般导致不变量被破坏是因为表示泄露：将我们不应该被修改的内容交给了客户端去修改。总的来说，杜绝方法如下：尽量都使用不可变的数据类型；否则至少让输入的参数为不可变类型，同时做好防御性拷贝，返回新的对象，或者是把返回的字段改为不可变的。 七.表示不变量(RI)与抽象函数(AF) 首先，我们做如下的两个定义。 R：表示空间，ADT中实际存储的内容。(当然和ADT的实现密切相关) A：抽象空间，客户端看到和使用的值。 AF：从R到A之间的一个对应关系(映射)，即AF：R→A。 当然，A中的元素都肯定在R中至少有一个对应；而R中却可能有元素不和A中的任何元素对应(即不遵守规约的内容)，因此可见AF为满射而未必为单射。注：这里的映射其实指的是部分映射，因为映射要求R中每个元素都有A来对应，因此对全体R来看的话，只要每个像都有一个原像，那就是单射了；但即使既是单射又是满射，也可能不是双射。 RI：从R到boolean的一个映射，即RI：R→boolean，其中如果R中的元素在A中有像即表示合法，则该元素在RI的映射值为true。也可以说RI是一个条件，描述了哪些是合法值。 下图为一个简单的例子，实现的内容为字符集合。 不同的内部表示要设计不同的AF和RI，主要流程是先通过某种特定的表示方式R，来指定出RI，从而再做出相应的解释，也就是AF。 我们应该在开发阶段，对所有改变不变量的方法中随时检查(除了观察者之外的方法)。因此我们一般会使用assert语句。 八.AF，RI和表示泄露安全说明的文档化 这些都是写在代码的注释中，而非规约中。要给出理由，证明代码并未对外泄露其内部表示，比如字段全部为private，还有对可变字段的处理等等。 可用表示不变量来代替一些前置条件。 
第59篇文章[0]
详解Java中的checked异常和unchecked异常 详解Java中的checked异常和unchecked异常（一）Java的异常层次结构 要想明白Java中checkedException和uncheckedException的区别，我们首先来看一下Java的异常层次结构。 这是一个简化的Java异常层次结构示意图，需要注意的是所有的类都是从Throwable继承而来，下一层则分为两个结构，Error和Exception。其中Error类层次描述了Java运行时系统的内部错误和资源耗尽错误，这种错误除了简单的报告给用户，并尽力阻止程序安全终止之外，一般也米有别的解决办法了。 (二）unchecked异常和checked异常的区别 有了上面的认识之后，我们再来看什么是checked异常，什么是unchecked的异常。其实，Java语言规范对这两个定义十分简单，将派生于Error或者RuntimeException的异常称为unchecked异常，所有其他的异常成为checked异常。尽管，这个定义十分简单，但是RuntimeException却是一个非常让人容易混淆的观念，似乎我们所有的异常都是在程序运行的过程中。我《EffectiveJava》中关于RuntimeException异常的阐述也不是那么尽如人意， Usecheckedexceptionsforrecoverableconditionsandruntimeexceptionsforprogrammingerrors(Item58in2ndedition)1 不过从这句话中我们可以简单引申一下，也就是说，如果出现了RuntimeException，就一定是程序员自身的问题。比如说，数组下标越界和访问空指针异常等等，只要你稍加留心这些异常都是在编码阶段可以避免的异常。如果你还是觉得这两个概念不好区分，那么“最暴力“的方法就是将常见的RuntimeException背下来，这样就可以省去很多判断的时间。 （三）为什么要对unchecked异常和checked异常进行区分？ 原因其实很简单，编译器将检查你是否为所有的已检查异常提供了异常处理机制，比如说我们使用Class.forName()来查找给定的字符串的class对象的时候，如果没有为这个方法提供异常处理，编译是无法通过的。 （四）我们应该对哪些异常进行声明？ 我们前面说，RuntimeException是在programing过程中可以避免的错误，那是不是我们就不需要抛出这些异常呢？原则上来说，是这样的，但是Java规范中并没有对此进行限制，只是看上去你抛出一个数组越界的异常并没有多少实际意义，相反还会对性能造成一定的损失。那么我们应该如何来设计抛出异常呢？我们要记住以下两种情况是必声明throws异常的： 调用一个checked异常的方法，例如IOException，至于原因我们前面已经讨论过了，如果抛出所有的checked异常时无法通过编译的。程序运行过程中发现错误，利用throw语句抛出一个异常。对于unchecked异常，无非主要是两种情况要么是可以避免的（RuntimeException），要么是不可控制的。这些也是需要声明异常的。 
第60篇文章[0]
软件构造 OOP 一.OOP基础 这里只是对需要注意的地方做一些常识性总结，毕竟这些都是java初学者必须要熟练掌握的内容。 1.OOP的一些基本概念 在java语言中，我们最经常遇到的OOP概念即为类，对象和接口。 现实世界中的对象可映射为编程中的对象，其中状态即映射为字段，行为则映射为方法。 类的概念是在对象的概念产生后产生的。类是对一组对象统一的表达，是一个抽象的概念，现实世界中并不存在类的实体；而对象则是类的实例化。 类中的字段和方法分为属于类的和属于对象的。加static即为属于类，在类的外部用类名.字段/方法名进行操作；而不加static即为属于对象，在类的外部用对象名.字段/方法名进行操作。 注：静态方法中无法直接调用非静态成员和方法，但是可以new一个对象，之后再使用。 接口不能有构造方法，也要写规约，实现接口的类对相应的方法可以不写规约。要注意如果接口的规约表示为不可变类，那相应的实现中也要是不可变的，这点常常被忽视。 以前使用接口并不能完全隐藏实现，但现在接口中可以有静态方法，从而实现完全的隐藏，例如实验二中的graph接口。 2.信息隐藏与封装 实现方式:尽量使用接口声明变量，客户端仅使用接口中定义的方法，让客户端不能直接访问属性。可采用不同的权限修饰词来进行约束，以下为四个修饰词各自的权限。 总的来说，不需要用户使用的方法都应尽量是private的，或者作用域能尽量小就尽量小。况且作用域越小，容错率越高。 3.继承与覆写 子类覆写的方法的可见性要大于等于父类，因为子类的对象应可以转型为父类对象，可见性的降低就会出现错误。同理，子类抛出的异常必须是父类的子集。 覆写的方法是在运行时判断类型来调用的，因此以new构造的类型为准。 在子类中,用super关键字来调用父类的各种方法，用的最多的是构造方法。 4.多态 多态主要分为三种，我们下面分别来介绍。 A.特殊多态:一个方法可以有多个同名的实现(方法重载)。要求参数列表必须有不同的地方，其他的并没有要求，总之就是把重载的方法看作和之前完全不同的方法。 重载是编译时确定，属于静态检查。而覆写是运行时确定。因此对于类A变量名=new类B(参数)而言，编译时类型为A，运行时类型为B。具体例子如下图所示。 另外，还需注意这种变量作为参数时多态的用法，如下图所示。 B.参数化多态:一个类型名字可以代表多个类型(泛型化编程)。 泛型类/接口的格式：关键字类名/接口名<占位符>(){…}占位符其实就相当于额外的参数，代表着对应的类型。实际调用的时候使用类型参数，转化为对应的类名(因此如果希望是整型参数，要用Integer而不是int)，因此运行阶段不存在泛型。泛型接口可以有泛型或非泛型的实现类，取决于自己的需求。 泛型方法的格式：关键字<占位符>返回值方法名(参数列表){…}，注意，参数列表中有泛型变量，并不会导致这是一个泛型方法，因为这其实是属于泛型类的泛型变量。 对于静态方法，如果使用泛型参数，那么必须也定义为泛型方法。 C.子类型/包含多态:一个变量名字可以代表多个类的实例。其实就如同上面的例子用到的一样。子类型的实例也可以说是父类型的一个实例(当然反之不成立)，因此子类型的规约不能弱化超类型的规约。 二.ADT和OOP中的等价性1.三种判断等价性的方法 <1>.利用数学上等价的定义:满足自反性，对称性和传递性。 <2>.利用AF来定义ADT的等价判断，如果两个值的AF映射值相同，则说明他们等价。 <3>.在调用者角度，如果调用两个对象的所有任意操作，效果都完全一样，那么则说明他们等价。 2.“==”与equals 对于“==”,代表着判断两个对象的地址空间是不是在同一个位置，也被称为引用等价性；而equals则代表着判断两个对象的内容，也被称为对象等价性。 object类的equals默认为判断两者的地址空间是不是在同一位置。总的来说，对于基本数据类型，我们应该用“==”，而对于对象数据类型，我们应该用equals判断(当然，要根据需要判断是否应该覆写)，当然，我们要明确知道我们写的方法是覆写还是重载。 除了写equals方法，尽量不要用instanceof和getclass()，因为他们不符合OOP的思想，不是好的书写风格。 3.hashcode与equals hashcode方法就类似于数据结构中的哈希函数一样，功能就是把一个个对象映射到一个地址(也就是桶)。默认的方式是按照地址映射，一般地址不同则值不同。 当我们使用HashSet等类似的数据结构的时候，这时再进行寻找时，就如同正常哈希表一样了，是通过判断哈希值是否相等先进行判断，哈希值相同是equals成立的前提，也是首先判断的方法。此时如果我们只重写equals而不重写hashcode，则hashcode还是默认的按地址算出一个值，一般而言只要地址不同则哈希值就不同了，导致了我们equals方法看似失效。 综上，equals()应满足如下条件：首先满足等价性(数学意义上)，其次保证在不被修改的情况下，每次调用的结果应该相同，同时要处理对象为null的情况还有如果这个类使用了哈希表进行查询(比如放入了HashSet中)，则也要覆写hashcode方法。 4.可变类型的等价性 有两种判断方式:观察等价性与行为等价性；分别代表不改变状态的前提下，通过观察器来判断两者是否相同以及调用任何方法是否有相同的结果，但由于是可变类型，也就相当于判断地址是否相同了。 虽然很多时候我们倾向于判断观察等价性是否相同，但是可能引起bug甚至破坏RI，尤其是使用了Set的时候。比如经典的Set<List<T>>引起的bug。 因此，总结起来来说，对于可变类型，我们不应该覆写equals方法和hashcode方法，如果想“比较”，我们可以使用其他自定义的方法；而对于不可变类型，如果我们想要“比较”，那么我们是一定要覆写这两个方法的。 5.装箱及其等价性 在使用集合类时，我们前面也提到过，会进行隐式的装箱操作。因此，装箱完毕后，如果是两个不同对象，即使是整数的装箱，使用“==”进行判断也会返回false，要进行equals的覆写。 但是下面有一个特例，那就是如果是-128到127之间的整数，进行两次装箱操作，那得到的地址是一样的(得益于java的缓存机制)。当然，上面也是要求只装箱，不能为两次new的操作，不然肯定地址值不同。 
第61篇文章[0]
软件构造 面向可维护的设计模式 1.创建模式 这些类的作用主要就是为了创建对象，对应采取的模式就是不同的创建模式，分为以下几种模式。 A.工厂方法模式 使用ADT的时候，如果我们想创建一个对象，我们就要调用构造函数，而构造函数不会在接口中而是在实现类中，因此抽象程度降低了，而且导致用户可能会依赖于这个实现类的实现方式，而不是接口。为了解决这些，工厂模式应运而生。 我们也可以说其实就是对构造函数的包装(就像之前对其他字段或方法的包装一样)，包装到一个新的类中，从而实现隐藏了这个原始类的类名，新的类一般只有一个方法，那就是用来构造原有类的对象。 另外还有一种实现的结果相同的方法，就是在原始的类中添加静态工厂方法，同时将构造方法设置为私有。 B.抽象工厂模式 相比于普通的工厂方法模式中，一个工厂就用于创造一个类的对象，其实抽象方法模式就是变成了一个工厂可以创建一组类的对象，不过创建的搭配是固定好的。 我们可以举下列在麦当劳点餐的例子来大致说明： 对于普通的，没有使用创造模式的情况，我们就是这样点：一个奥尔良鸡腿堡，一个中可乐。我们提出需求时就直接是知道了具体的类，比如是奥尔良鸡腿堡，而不是通过它的父类“汉堡”。 而工厂方法模式，我们是这样点：有一个个优惠卷，每个卷有对应的产品。我们给服务员这些卷，让他们拿出对应的产品，而我们不再需要知道这些产品的名字。通过优惠卷信息的不同，通过不同的工厂去创造对应的对象。 而抽象工厂模式，我们是这样点：有一个个优惠卷，里面都是一个套餐。我们同样不用知道这些套餐中任何一个产品的名字，但是这些产品是绑定在这一个套餐之内的了，我们不再能一个个产品的去点，但是这样我们创建的时候对固定的模式更方便。 2.结构模式 通过改变类之间的结构，让类呈现新的功能。 A.代理模式 有的时候我们在创建一个类的对象时，就要进行一定的操作，而有的时候这个操作很费时间，而操作不一定必须，则此时我们就可以创建一个对应的包装，来实现将所谓的这个操作和对象的创建分隔开。 下面是一个很好的例子。 首先这张图说明在创建这个图片的时候，就调用了loadfromDisk这个需要花费很多时间的操作。 如果我们想要实现仅仅是创建一个对象而不是立刻执行加载操作，则可以执行如下操作：创建一个虚拟的了类，构造方法中不再有display而是挪到了外面，通过委托的机制进行调用。 代理模式与适配器模式的区别：前者的目的是解决私密问题和耗费过大的问题，而后者的目的主要是消除不匹配，让客户端和内部的类以统一的方式建立联系。 3.行为模式 行为性模式主要用于描述类或对象的交互以及职责分配。 A.观察者模式 总的来说就是一种一对多，类似于广播的模式。 在被观察者中，应该有添加观察者和删除观察者的操作(用于将观察者与被观察者之间建立联系)，还有就是将信息通知给观察者的操作(notify)。对于观察者，也该有更新状态的操作(当然是由被观察者的notify来操作) 例子如下所示，观察者即为被观察者中的一个列表。通过调用观察者的update操作来实现notify操作。(当然这里不能删除被观察者) 粉丝(被观察者)的例子如下，subject属性代表着对应的被观察者所观察的观察者。 当然，java中提供了Observer接口和Observable抽象类，类似于迭代器模式。 B.访问者模式 总的来说，访问者模式就是，被访问者中的某个具体的操作，因为各种原因，去委托给另外的类进行完成。委托给的类就是访问者。 我们还是用例子来说明，不然太抽象。 首先这是第一棵继承树，是被访问的那个类。其中要有accept方法，参数是访问类的对象，通过accept方法来让其访问。 而第二棵继承树就是访问类了。其中要有visit方法，通过多态实现取分访问不同类型的对象从而有多种实现，而实现中即可以正常的写业务逻辑了。这个例子相当于把每种物品的计算价格的操作委托给了另一个类，这也就是访问者模式最主要的目的。 与迭代器模式的区别：迭代器模式主要是进行一个个的访问，而访问者模式主要是被访问者将对应的某种功能的实现交给访问者，客户端可以灵活的改变访问者中的操作算法。 4.设计模式总结 虽然设计模式种类很多，但是抽象出的类与类之间的关联效果，都是如下两张图所示。 首先是单一继承树的情况。 其次是两颗继承树的情况。 至于如何去取分这些样式相同的模式，主要是通过它里面方法的不同，就类似于大家都是人，但是由于自身能做的事情不同，因此有不同的职业一样。 
第62篇文章[0]
JAVA正则表达式 一、单个符号1、英文句点.符号：匹配单个任意字符。 表达式t.o可以匹配：tno，t#o，teo等等。不可以匹配：tnno，to，Tno，t正o等。2、中括号[]：只有方括号里面指定的字符才参与匹配，也只能匹配单个字符。 表达式：t[abcd]n只可以匹配：tan，tbn，tcn，tdn。不可以匹配：thn，tabn，tn等。3、|符号。相当与“或”，可以匹配指定的字符，但是也只能选择其中一项进行匹配。 表达式：t(a|b|c|dd)n只可以匹配：tan，tbn，tcn，tddn。不可以匹配taan，tn，tabcn等。4、表示匹配次数的符号 5、^符号：表示否，如果用在方括号内，^表示不想匹配的字符。 表达式：[^x]第一个字符不能是x6、\S符号：非空字符7、\s符号：空字符，只可以匹配一个空格、制表符、回车符、换页符，不可以匹配自己输入的多个空格。8、\r符号：空格符，与\n、\tab相同 二、快捷符号1、\d表示[0 9]2、\D表示[^0 9]3、\w表示[0 9A Z_a z]4、\W表示[^0 9A Z_a z]5、\s表示[\t\n\r\f]6、\S表示[^\t\n\r\f] 三、Pattern和Matcher实例： publicclassFindDemo{privatestaticTestmonitor=newTest();publicstaticvoidmain(String[]args){ Matcherm=Pattern.compile("//w+") .matcher("Eveningisfullofthelinnet'swings");while(m.find()) System.out.println(m.group());inti=0;while(m.find(i)){ System.out.print(m.group()+""); i++; } monitor.expect(newString[]{"Evening","is","full","of","the","linnet","s","wings","Eveningveningeningningingnggisissfull"+"fullulllllofoffthetheheelinnetlinnet"+"innetnnetnetettsswingswingsingsngsgss" }); }} 用括号可以给pattern进行分组，用group（inti）引用。 
第63篇文章[0]
HashMap的底层实现原理 HashMap是最常用的Map接口的实现类型，通过存储键值对的方式，来表示两个集合的映射关系。 一、构造方法 HashMap有四个构造方法 HashMap() //无参构造方法HashMap(intinitialCapacity) //指定初始容量的构造方法HashMap(intinitialCapacity,floatloadFactor)//指定初始容量和负载因子HashMap(Map<?extendsK,?extendsV>m)//指定集合，转化为HashMap HashMap默认初始容量为16，HashMap的扩容十分耗时，如果能提前知道容量尽量提前设置。扩容时会将容量翻倍。 二、数据结构 HashMap的主要数据结构是哈希表，用“拉链法”实现。 哈希表是一组链表的数组。以内置静态类Entry作为结点，Entry的属性有hash，key，value，next 通过Entry.next将所有Entry连接成链表 哈希表通过类型K的内置函数hashCode()，根据这个函数和容量len，可以直接确定查找值所在位置，而不需要一个个比较。这样就Entry所在的位置，直接找到数据，提升效率。 三、函数实现 1.get(Kkey) 首先要寻找key的Entry，计算key.hashCode()%len，得到index，那么就在Entry[index]所在的链表中找到对应key相等的Entry,然后返回Entry中的value即可，如果没找到则返回null 2.put(Kkey,Vvalue) 计算key.hashCode()%len，得到index，遍历Entry[index]如果找到对应的key，替换上新的value并返回原来的value。否则调用addEntry(hash,key,value,index),即给链表添加新的Entry结点 三、后记 在Jdk1.8中，引用了红黑树，进一步提高了HashMap的效率，HashMap的实现方式做了一些改变，数据结构的存储由数组+链表的方式，变化为数组+链表+红黑树的存储方式，但是基本思想没有改变 
第64篇文章[0]
哈工大 软件构造广度搜索 在Lab1实验三中对人际关系的搜索中需要使用广度搜索。由于Java中没有提供现成的队列，我对当时的Person类额外添加了两个属性，一个是是否已经访问的标志isVisited和用于广度遍历时记录层数的lengthpackageP3;importjava.util.*; publicclassPerson{publicintlength;publicStringname;publicbooleanisVisited;publicListneighborlist;publicPerson(Stringname){this.name=name;length=0;isVisited=false;neighborlist=newArrayList();}} 手写了一个很简单的队列packageP3;importjava.util.*; publicclassMyQueue{publicListQueueList;publicMyQueue(){QueueList=newArrayList();}publicvoidOffer(Personname){QueueList.add(name);}publicPersonPoll(){if(QueueList.isEmpty()){returnnull;}returnQueueList.remove(0);}}这里使用了动态数组，所以入队操作直接使用add，加到数组尾部而pop是将队头元素抛出所以用remove（0）实现。 
第65篇文章[0]
软件构造---关于list 已知LinkedList和ArrayList均实现了List接口二者实现结构不同arraylist是基于数组，linkedlist是基于链表因此对于随机访问get和set，ArrayList优于LinkedList，因为ArrayList可以随机定位，而LinkedList要移动指针一步一步的移动到节点处。同时对于add和remove方法，链表的明显比数组有优势的多。对于get，由于数组可以随机访存，链表是顺序的，所以get方法ArrayList时间开销较小。另外arraylist的初始化时默认10容量，而linkedlist默认初始化为空。综上，如果对list有较多的增删操作那么优先选用linkedlist，如果只是访问较多的话，那么arraylist优势较大。不过我一般都直接用arraylist。。 
第66篇文章[0]
哈工大 软件构造关于迭代器Iterator 哈工大 软件构造关于迭代器Iterator迭代器Iterator提供了遍历集合类的方法，主要用法为：Iterator<Integer>it=mylist.iterator.声明一个迭代器遍历的时候基本格式为while(it.hasNext()){Integeri=it.next();…}需要使用迭代器的时候为：遍历时删除元素由于arraylist每次遍历的时候会去判断该集合是否被修改过，调用的方法是checkForComodification()。如果被修改会抛出ConcurrentModificationException异常。机制主要是通过维护2个变量来实现，modCount记录了修改次数，expectedModCount记录期望修改次数。通过iterator.remove()进行的删除操作，会同时修改modCount、ConcurrentModificationException;而通过list.remove(object/index)，则只会修改modCount。这也是fast-fail机制。而迭代器里面的删除同步了expectedModCount和modCount这两个值，所以不会报错。但是，需要注意的是，在使用迭代器一边遍历一边删除同时进行增加时，还是会报错，抛出ConcurrentModificationException异常，这里我个人的解决方案是在遍历过程中设置一个addflag变量，如果遍历过程中会有新元素加入，那么先记录数值并设置addflag为true，在遍历完成后再根据addflag决定是否向集合类中增加相应元素。 
第67篇文章[0]
有关抽象类的感悟 概念： 在面向对象方法中，抽象类主要用来进行类型隐藏。构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的； 通过从这个抽象体派生，也可扩展此模块的行为功能。为了能够实现面向对象设计的一个最核心的原则OCP(Open-ClosedPrinciple)，抽象类是其中的关键所在。 抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。 抽象类的特点：1，抽象方法一定在抽象类中。2，抽象方法和抽象类都必须被abstract关键字修饰。3，抽象类不可以用new创建对象。因为调用抽象方法没意义。4，抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。 抽象类比一般类多个了抽象函数。就是在类中可以定义抽象方法。抽象类不可以实例化。特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象。 abstract关键字，和哪些关键字不能共存。final：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。private:抽象类中的私有的抽象方法，不被子类所知，就无法被复写。而抽象方法出现的就是需要被复写。static：如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了。可是抽象方法运行没意义。 
第68篇文章[0]
pair的应用 在lab3的相关问题中我发现用pair存信息比较合适。我们学习了一个相关结构配对(Pair)。配对提供了一种方便方式来处理简单的键值关联，当我们想从方法返回两个值时特别有用。 在核心Java库中可以使用配对(Pair)的实现。除此之外，某些第三方库，比如ApacheCommons和Vavr，已经在各自的api中公开了这个功能。 核心java配对实现 Pair类 Pair类在javafx.util包中，类构造函数有两个参数，键及对应值： Pairpair=newPair<>(1,“One”); Integerkey=pair.getKey(); Stringvalue=pair.getValue(); 示例描述使用Pair类实现简单Integer到String的映射。示例中getKey方法返回key对象，getValue方法返回对应值对象。 AbstractMap.SimpleEntry和AbstractMap.SimpleImmutableEntry SimpleEntry定义在抽象类AbstractMap里面，其构造方法与Pair类似： AbstractMap.SimpleEntryentry =newAbstractMap.SimpleEntry<>(1,“one”); Integerkey=entry.getKey(); Stringvalue=entry.getValue(); 其键和值可以通过标准的getter和setter方法获得。 另外AbstractMap类还包含一个嵌套类，表示不可变配对：SimpleImmutableEntry类。 AbstractMap.SimpleImmutableEntryentry =newAbstractMap.SimpleImmutableEntry<>(1,“one”); 
第69篇文章[0]
ADT,AF,RI,REPEXPOSURE ADT介绍抽象数据类型（AbstractDataType，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。 ADT具有三个特性，即表示泄漏、抽象函数AF以及表示不变量RI，在我看来，这三个特性都是为不变性所服务的。其中，表示泄漏保证了ADT的内部表示不会被客户端其它代码所篡改，影响不变性，其次，表示不变量RI，对ADT的内部表示进行限制，获取到希望的表示信息，即程序面对的表示，通过抽象函数AF得到客户端所见到的表示。 AFAF指的是抽象函数，抽象函数为表示值空间到抽象值空间的一个映射R:面向实现的表示值空间A:面向规格说明的抽象值空间R==>A一定是满射,但不一定是单射.抽象函数即一个R到A的映射:AF:R→A RIRI指的是表示不变性。"表示"即ADT中的各个属性;而表示不变性即这些属性必须保持的性质,如年龄不能为负数,概率不能大于1. checkRepRI指的是检查不变性，检查不变性就是确定RI是否还成立.在实现中采用断言技术assert来检查不变性是否保持，可以更早地捕获bug 避免表示泄露的方法表示泄露:指的是外部代码能直接改变(不借用类中的mutator方法)类中的属性. 我们需要注意三个关键词：private、final、immutable，所有的操作均为了赋予field这三个属性。 1.所有观察ADT属性的操作全都用observor来实现，这没什么好说的。 2.由于现在写的ADT都较为简单，private和final这两个前缀能加就加上。 3.immutabl的field由于是被数据类型本身决定，所以需要会使用防御式拷贝来保护。 
第70篇文章[0]
有关delegation的思考 什么是委派模式？委派模式，并不属于23种经典的设计模式。但是在Spring框架源码中，它有多次体现。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。 字面理解委派模式项目组，包括：项目经理A、程序员B和程序员C。目前甲方有个项目，需要完成一个xxx任务。首先甲方会直接找到项目经理A去谈这个项目，而不是直接找B和C。项目经理分析这个项目，发现需要两人合作来完成，所以将A1模块分给B，将A2模块分给C，由B和C来合作完成该项目。 在该需求中，项目经理只起到了一个协调工作的作用，其实实际的工作是由B和C来完成的。由此可总结出委派模式的主要特点如下。 委派模式的主要特点干活是我(B和C)的，功劳是你的(A)。项目经理属于渔翁得利型 委派模式的其他特点①委派机制，类似于中介的功能 ②持有被委托人的引用(项目经理A可以随意使唤B和C) ③不关心过程，只关心结果(代理模式：关心的是过程，不关心结果) 代码实现1.甲方现在有一个项目projectA /** 现在有一个项目projectA*/publicinterfaceIDelegate{//项目ApublicvoidprojectA();}2.项目经理评估后，需要两个程序员B和C来完成 /** 程序员B/publicclassProgrammerBimplementsIDelegate{@OverridepublicvoidprojectA(){System.out.println(“程序员B完成模块A”);}}/*程序员C*/publicclassProgrammerCimplementsIDelegate{@OverridepublicvoidprojectA(){System.out.println(“程序员C完成模块B”);}}3.项目经理具体的分配过程 /** 项目经理A(虽然它也有工作,需要实现projectA,但是它的具体工作就是分配任务)/publicclassManagerAimplementsIDelegate{/* 封装构造方法,来获得具体实现该需求(程序员B和C)的实例*/IDelegateiDelegate;publicManagerA(IDelegateiDelegate){this.iDelegate=iDelegate;}@OverridepublicvoidprojectA(){this.iDelegate.projectA();}}4.测试。即：分工完成后，项目具体的完成情况 /** 需求的完成情况*/publicclasstest{publicstaticvoidmain(String[]args){//1.现在甲方有一个新的需求//2.项目经理分析完后,发现需要程序员B和C来完成IDelegateexuctorB=newProgrammerB();IDelegateexuctorC=newProgrammerC();//3.项目经理获取到B和C的引用，然后让B和C来完成工作newManagerA(exuctorB).projectA();newManagerA(exuctorC).projectA();//4.工作完成//5.代码看着像是项目经理A完成的，但实际是B和C完成的。即：干活是B和C，实际功劳确实A的}} 
第71篇文章[0]
有关lsp的思考 含义：只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，有子类出现的地方，父类未必就能适应。 *子类型可以增加方法，但不可删 子类必须完全实现父类的方法，在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了里氏替换原则。 *子类型中重写的方法必须有相同或子类型的返回值 *子类型中重写的方法必须使用同样类型的参数 *子类型中重写的方法不能抛出额外的异常 同时，这也可以体现在方法的规约上面。 Sameorstrongerinvariants更强的不变量Sameorweakerpreconditions更弱的前置条件 Sameorstrongerpostconditions更强的后置条件 采用里氏替换原则的目的就是增强程序的健壮性，版本升级是也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。 基本介绍：1）如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明的使用其子类的对象。2）在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。3）里氏替换原则原则指出，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。 理解：即是在业务处理过程中，我们在用子类继承父类时，尽量不要重写父类中的方法，如果迫不得己必须重写，可采用聚合，组合和依赖等方法。 总结一下，即是：继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合度，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。那么如何解决：里氏替换原则 
第72篇文章[0]
HIT软件构造期末复习笔记第2,12章 第二讲：软件测试与测试优先的编程 ·黑盒测试：对程序外部表现出来的行为进行测试；用于检查代码的功能，不关注内部的实现细节 检查是否符合规约等价类划分：针对每个输入数据需要满足的约束条件，划分等价类；从等价类中导出测试用例边界值分析：对等价类划分的一个补充（在等价类划分时将边界值作为等价类之一加入考虑）测试用例：输入+执行条件+期望结果 ·测试覆盖度：（1）笛卡尔积：全覆盖（2）每个维度的每个取值至少被一个测试用例覆盖一次即可代码覆盖度：函数覆盖、语句覆盖、分支覆盖、条件覆盖、路径覆盖覆盖度标准（100%语句覆盖，90%路径覆盖） ·以注释的形式撰写测试策略： ·TDD：（1）先写spec（2）再写符合spec的测试用例（3）写代码、执行测试、有问题再改、再执行测试用例，直到通过它·Junitassertxxx： 第十二讲：面向正确性与健壮性的软件构造 ·健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度 倾向于容错·正确性：程序按照spec加以执行的能力（最重要的质量指标） 倾向于直接报错可靠性=健壮性+正确性 ·Error/Runtime异常 Error：内部错误，一旦发生，想办法让程序优雅的结束Exception：异常：自己程序导致的问题，可以捕获，可以处理（1）将错误信息传递给上层调用者，并报告“案发现场”的信息（2）Return外的第二种退出途径（3）若找不到异常处理程序，整个系统完全退出（4）分为运行时异常和其他异常运行时异常：程序员在代码中处理不当造成，可避免其他异常：由外部原因造成，无法完全避免 ·Checked异常，Unchecked异常 Checked异常：必须捕获并指定错误处理器handle，否则编译无法通过 ·Checked异常处理机制（1）使用throws声明异常 方法应throws的异常：该方法调用的其他函数抛出的checkedexception当前方法检测并使用throws抛出的checkedexception若无handler来处理抛出的checkedexception，程序就终止执行 （2）使用throw抛出异常：1.找到一个能表达错误的Exception类/或者构造出一个新的Exception类2.构造Exception类的一个实例，将错误信息写入3.抛出错误（throw） 4.一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码 ·自定义异常类 Finally关键字：无论程序是否碰到异常，finally关键字都将被执行 ·断言在开发阶段的代码中嵌入，检验某些假设是否成立。若成立则表明程序运行正常，否则表明存在错误断言即是对代码中程序员所做的假设的文档化，不会影响程序的性能形式： 所构造的message将在发生错误时显示给用户，便于快速发现错误所在；实际运行阶段，不再使用断言！出现AssertionError即表示内部某些假设被违反了 可使用assert的情况：内部不变量、表示不变量、控制流不变量（switch-case）、方法的前置、后置条件断言只检查程序内部的状态是否符合规约，断言一旦false，程序就停止执行，外部错误（不受自己控制）要使用Exception机制去处理 ·防御式编程的基本思路：（1）最好的防御就是不要引入bug（2）若无法避免，则将bug限制在最小范围内；限定在一个方法内部，不扩散（3）Failfast 
第73篇文章[0]
HIT软件构造期末复习4~8章 第四讲：数据类型与类型检验 ·基本数据类型，对象数据类型 可将基本类型包装成对象类型，通常是在定义集合类型时使用它们，一般情况避免使用 Java：静态类型语言；在编译阶段进行类型检查·静态类型检查可在编译阶段发现错误，避免了将错误带入到运行阶段，提高程序健壮性、正确性关于“类型”的检查！！（1）语法错误（2）类名/函数名错误（3）参数数目错误（4）参数类型错误（5）返回值类型错误·动态类型检查关于“值”的检查！！（1）非法的参数值（2）非法的返回值（3）越界、空指针 ·值的改变，引用的改变，final改变一个变量：将该变量指向另一个值的存储空间改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值不变数据类型：一旦被创建，其值不能改变若是引用类型，也可是不变的：一旦确定其指向的对象，不能再被改变Mutable对象：拥有方法可以修改自己的值/引用Immutable对象：一旦被创建，始终指向同一个值/引用 Final类：（1）无法派生出子类（2）Final变量无法改变值或引用（3）Final方法无法被子类重写（4）修饰基本类型：起常量作用，基本类型的值不能改变（5）修饰引用类型：不能在指向其他对象，但被引用对象的值可以改变 对可变数据类型，采取防御式拷贝 给客户端返回一个全新的对象（副本）对不可变数据类型，无需采用防御式拷贝（应对有多个引用的情况）安全的使用可变数据类型：作为局部变量，只有一个引用，不涉及共享 ·Snapshotdiagram：用于描述程序运行时的内部状态 ·迭代器： 对iter使用remove方法可避免mutable对象对迭代器的破坏 注：此种不变性是在运行阶段获得的，编译阶段无法据此进行静态检查 第五讲：设计规约 ·specification 客户端无需阅读调用函数的代码，只需要理解spec即可规约可以隔离变化，无需通知客户端 前置条件：对客户端的约束，使用方法时必须满足的条件后置条件：对开发者的约束，方法结束时必须满足的条件契约：前置条件满足，后置条件必须满足；前置条件不满足，后置条件不一定满足 ·行为等价性站在客户端的角度看待行为等价性；根据规约判断行为是否等价 静态类型声明是一种规约，可据此进行静态类型检查staticchecking 方法前的注释也是一种规约，但需要人工判定其是否满足 Javadoc： ·比较规约：（1）规约的强度（2）规约的确定性（3）规约的陈述性 ·规约强度：Spec变强：更强的后置条件+更弱的前置条件可用更强的规约替换更弱的规约 操作式规约：（eg.伪代码）声明式规约：（无内部实现的描述，只有初终状态）更有价值内部实现的细节不在规约里呈现，放在代码实现体内部内部的注释内呈现 规约质量：·内聚的（spec描述的规约单一、简单、易理解）·信息丰富的（不能让客户端产生理解的歧义）·既足够强又足够弱 第六讲：抽象数据类型 ADT特性：表示泄漏、抽象函数AF、表示不变量RI ADT由操作定义，与其内部如何实现无关不变数据类型：其操作不改变内部值，而是构造新的对象 ·ADT操作的四种类型：构造器：可能实现为构造函数或静态函数生产器：由旧对象产生新对象观察器变值器测试creator、producer、mutator时用observer来观察这些操作是否的结果是否满足spec测试observer时用creator、producer、mutator等方法产生或改变对象，来看结果是否正确 ·表示独立性客户端使用ADT时无需考虑其内部是如何实现的，ADT内部表示的变化不应影响外部spec和客户端。 ·不变量在任何时候总是true，由ADT负责其不变量，与客户端的任何操作均无关（immutability即是一个典型的不变量） ·表示泄漏不仅影响不变性，也影响表示独立性；无法在不影响客户端的情况下改变其内部表示！ 使用immutable对象，可彻底的避免表示泄漏！ ·表示空间、抽象空间、AF ADT开发者关注R，client关注A满射！！！AF：R-->A ·RI（表示不变性）所有表示值的一个子集，包含了所有合法的表示值 选择某种特定的表示方式R，进而指定某个子集是合法的（RI），并为该子集中的每个值做出解释（AF） ·设计ADT：（1）选择R和A（2）RI：合法的表示值（3）如何解释合法的表示值：映射AF ·随时检查RI是否满足在所有可能会改变rep的方法中都要检查 ·在代码中以注释的形式记录AF、RI要精确记录的RI：rep中的所有fields何为有效要精确记录的AF：如何解释每一个R值表示泄漏的安全声明：给出理由，证明代码并未对外泄漏其内部表示 ADT的规约里只能使用client可见的内容来撰写，包含参数、返回值、异常等若规约里提及值，则只能采用A空间中的值在代码中以注释的形式写出AF和RI而不能在javadoc文档中，防止被外部看到而破坏表示独立性 构造器和生产器在创建对象时要确保不变量为true变值器和观察器在执行时必须保持不变性在每个方法return前，用checkRep()检查不变量是否得以保持 第七讲：面向对象编程 ·interface、class定义、实现ADT接口：确定ADT规约（javainterfacecannothaveconstructors）类：实现ADT 接口中的静态工厂方法使用接口类型声明变量，客户端仅使用接口中定义的方法，客户端无法直接访问属性 ·inheritance&override重写的函数：与父类或接口完全相同的signature；实际执行时调用哪个函数，运行时决定若父类型中的某个函数体的实现为空，说明其所有子类型都需要这个功能，但各有差异，无共性，在每个子类中均需要重写重写过后，使用supper()复用父类型中函数的功能，并对其进行扩展 ·多态&overload （1）特殊多态：功能重载（2）参数化多态：使用泛型（3）子类型多态：不同类型的对象可以统一处理，无需区分，从而隔离了变化；LSP原则BisasubtypeofAmeansthateveryBisA；everyBsatisfiesthespecofA子类型的spec不能弱化父类型的spec 第八讲：ADT和OOP中的等价性 ·等价性基于AF定义ADT的等价操作 AF映射到相同的结果，则等价等价关系：自反、传递、对称 ·equals()和==：引用等价性两个对象指向内存的同一段空间时，这两者引用等价Equals()：对象等价性具有相同的内容自定义ADT时要重写Object类的equals方法在object类中实现的缺省equals是在判断引用等价性！对基本数据类型，使用判断相等对对象类型，使用equals判断相等（eg.String） 重写equals的正确姿势其中instanceof操作符用于判断类的一致性 ·Equals等价关系：自反、对称、传递用是否为等价关系检验equals是否正确 ·hashCode()“相等”的对象，其hashCode的结果一定相同两个equals的对象，一定要有同样的hashCode（除非你能保证你的ADT不会被放置到hash类型的集合类中！） ·可变对象的观察等价性、行为等价性：观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致行为等价性：调用对象的任何方法都展示出一致的结果若某个mutable的对象包含在Set集合类当中，当其发生改变后，集合类的行为不确定对所有可变类型对象，实现行为等价性即可，也就是说只有指向相同内存空间的objects才是相等的；对所有mutable类型的对象，无需重写hashCode和equals方法，直接继承Object类的两个方法即可 ·不可变对象的引用等价性、对象等价性：不可变对象需重写equals方法及hashCode方法 
第74篇文章[0]
HIT软件构造1~3章期末复习笔记 第一讲： 软件构造的多维度视图及质量目标 ·软件构造的多维度视图： 按构造对象划分：代码、构建视图（CodeorComponentlevel） ·软件构造的阶段划分、各阶段的构造活动： 语法树、流程图：B+C+M 版本控制工具：B+C+P UML图：R+C+P ·内部外部质量指标： 外部质量指标： 正确性（最重要）、健壮性、可扩展性、可复用性（兼容性、可移植性、易用性） 内部质量指标： LOC（lineofcode）、可读性、可理解性、规模、耦合度（低）、内聚度（高）、（圈）复杂度 第三讲： 软件构造过程与配置管理 ·SCM（软件配置管理） 追踪、控制软件的变化 SCI：软件配置项：软件发生变化的基本单元（形式：文件） Baseline：基线：软件持续变化过程中的“稳定时刻” CMDB：配置管理数据库：存储软件的各配置项随时间发生变化的信息+基线 Versioning：版本控制 ·VCS（版本控制系统） LocalVCS：本地版本控制系统：仓库存储于开发者本地机器，无法共享和合作 CentralizedVCS：集中式版本控制系统：仓库存储于独立的服务器，支持多开发者间的协作 DistributedVCS：分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器 ·GIt 基本结构： Gitrepository：dictionary本地CMDB Workingdictionary工作目录（本地文件系统） Stagingarea暂存区（隔离工作目录与git仓库） 基本指令： gitadd.（gitadd*）gitcommit-m“version”gitpushoriginmastergitpulloriginmaster（从远程仓库pull）gitclone git（克隆到本地仓库）gitcheckoutchange（切换分支）gitcheckout-bchange（新建并切换到分支change）gitmergechange（将change分支与当前分支合并） 每个commit指向一个父亲； 合并：一个commit指向多个父亲 分支：多个commit指向一个父亲 
第75篇文章[0]
HIT软件构造期末复习笔记第9~11章 第九讲：面向复用的软件构造技术 ·白盒框架：通过代码层面的继承进行框架扩展·黑盒框架：通过实现特定接口、委派进行框架扩展 ·LSP原则（1）子类型可以增加方法，但不可以删除方法（2）子类型需要实现抽象类型中所有未实现的方法（3）子类型中重写的方法必须有相同或子类型的返回值或符合co-variance的参数（4）子类型中的重写的方法必须使用同样类型的参数或符合contra-variance的参数（5）子类型中重写的方法不能抛出额外的异常（更强的不变量，更弱的前置条件，更强的后置条件）子类型方法参数：逆变子类型方法的返回值：协变异常类型：协变 ·协变：父类型-->子类型：越来越具体的spec返回值类型、异常类型：不变或变的更具体·逆变：父类型-->子类型：越来越具体的spec参数类型：要不变或越来越抽象（目前Java遇到此种情况，均当作overload看待） ·数组的子类型化 ·泛型的子类型化ArrayList是List的子类型，而List不是List的子类型泛型不支持协变 类型擦除List不是List的子类型！ ·解决：使用通配符？ ·组合和委派委派：一个对象请求另一个对象的功能（复用的一种常见形式）委派模式：通过运行时动态绑定，实现对其他类中代码的复用委派发生在object层，继承发生在class层分类：（1）Dependency：临时性的delegation（2）Association：永久性的delegation（3）Composition：更强的association（难以变化）（4）Aggregation：更弱的association（可动态变化） ·接口的组合 ·CRP原则 ·白盒框架的原理与实现 ·黑盒框架的原理与实现 第十讲：面向可维护性的构造技术 ·可维护性的常见度量指标：可维护性、可扩展性、灵活性、可适应性、可管理性、支持性圈复杂度、代码行数、可维护性指数、继承的层次数、类之间的耦合度、单元测试的覆盖度 ·聚合度、耦合度：高聚合+低耦合 ·SOLID：SRP：单一责任原则OCP：开放-封闭原则LSP：Liskov替换原则ISP：接口聚合原则DIP：依赖转置原则 SRP：不应有多于一个原因让你的ADT发生变化，否则就拆分开OCP：对扩展性的开放：模块的行为应该是可扩展的对修改的封闭：模块自身的代码不应被修改；扩展模块行为的一般途径是修改模块的内部实现 LSP：子类型必须能替代其基类型；派生类必须能够通过其基类的接口使用，客户端无需理解这二者的差异ISP：不能强迫客户端依赖于它不需要的接口，只提供必需的接口DIP：抽象的模块不应依赖于具体的模块，具体应依赖于抽象（delegation时要通过interface建立联系，而非具体的子类） ·语法驱动的构造从外部读取文本数据，在应用中做进一步的处理用语法判断字符串是否合法，并解析成程序里使用的数据结构 ·正则表达式 第十一讲：面向可复用性和可维护性的设计模式 ·创建型模式： ··工厂方法（“虚拟构造器”）当客户端不知道要创建哪个具体类的实例，或不想在client代码中指明要具体创建的实例时，用工厂方法定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类 ·结构型模式： ··Adapter（适配器模式）将某个类、接口转换为client期望的其他形式；通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体的子类 ··Decorator（装饰器模式）为对象增加不同侧面的属性，对每个特性构造子类，通过委派机制增加到对象上 客户端需要一个具有多种特性的object，通过一层一层的装饰来实现 ·行为型模式 ··Strategy（策略模式）有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而非写死在代码中；为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例 ··Templatemethod（模板模式）做事情的步骤一致，但方法不一样；共性的步骤在抽象类中公共实现，差异化的步骤在各个子类中实现使用继承和重写实现模板模式 ··Iterator（迭代器模式）客户端希望遍历被放入到容器、集合类中的一组ADT对象，无需关心容器的具体类型 为ADT实现iterable接口，实现该接口的集合对象是可遍历迭代的（只含iterator方法）实现自己独特的Iterator迭代器（next、hasNext、remove），允许客户端应用这个迭代器进行显式或隐式的迭代遍历 ··Visitor将数据和作用于数据上的某种、某些种特定操作分离开来为ADT预留一个将来可扩展功能的接入点，外部实现的代码功能能在不改变ADT本身的情况下通过delegation接入ADT 
第76篇文章[0]
Git：删除远程仓库中的文件及文件夹&GIt中错误“SSL_ERROR_SYSCALL,errno10054”的解决 eg.删除GitHub远程仓库中的FriendshipGraphTest.java文件 使用gitpulloriginmaster指令拉取远程仓库 使用gitrm-r--cachedfilename指令删除特定文件与文件夹 使用gitcommit-m“ ”指令提交删除操作至本地仓库 使用gitpush指令上传至远程仓库 最终结果 ·GIt中错误“SSL_ERROR_SYSCALL,errno10054”的解决方案： 此问题为安全设置问题： 使用指令： gitconfighttp.sslVerify"false" 即可解决 ·Git中错误：“TimeOut”解决方法： 因github为境外网站，时常出现崩坏的情况；如遇此情况： 反复多次提交即可解决。 参考文献：https://www.cnblogs.com/emmetyang/p/10620819.html 
第77篇文章[0]
格式化日期的转化 1、格式化字符串日期转化为可计算可比较日期应用场景：如果时间的输入参数是一个字符串，那么比较两个日期就比较困难，计算两个日期之间差了多长时间更困难。经过查阅资料，发现日期可以通过字符串转化成long型的时间，这个时间表示的是从1970-1-1开始的毫秒时间。代码如下： publiclongparseTime(Stringdate) { DateFormatdft=newSimpleDateFormat("yyyy-MM-dd"); longtime=0; try{ Dated=dft.parse(date); time=d.getTime(); }catch(ParseExceptione){ System.out.println("时间错误"); System.exit(0); } returntime; } 这里输入日期的格式需要为“年-月-日”，对于不同的应用场景，只需修改格式串中的字符串。如果格式错误，会给出提示信息，并且退出运行，这个报错机制也可自行修改。 2、long型毫秒时间转化回字符串时间 publicStringtimeToString(longtime) { DateFormatdft=newSimpleDateFormat("yyyy-MM-dd"); Datereparse=newDate(); reparse.setTime(time); returndft.format(reparse); } 虽然long型的时间方便计算，但是字符串的时间方便观察，所以也需要将其转化回来。 3、将字符串日期转化成星期 /** *将字符串类型的时间信息转化成具体的星期几 *@paramtime字符串类型的时间 *@return周一到周五0-4，周六5，周日6 */ publicintparseTime(Stringtime) { DateFormatdft=newSimpleDateFormat("yyyy-MM-dd"); intday=0; try{ Dated=dft.parse(time); Calendarcal=Calendar.getInstance(); cal.setTime(d); day=cal.get(Calendar.DAY_OF_WEEK); }catch(ParseExceptione){ System.out.println("错误时间信息"); System.exit(0); } if(day==1) { return6; } returnday-2; } 这个函数的原型得到的day结果是，星期日：1，星期一到星期六：2-7，这里是为了方便处理我进行了转化。 在学习这一部分内容时，我主要参考了：https://blog.csdn.net/dashenmepi/article/details/108725254 
第78篇文章[0]
在Eclipse中使用Junit测试代码 一、在项目中加入Junit库 右击项目文件，在选项中选择BuildPath这一选项。选择AddLibbraries选项，在其中找到Junit，可以自行选择需要的Junit版本。 当你的项目中除了之前的基础库文件，还出现了Junit库，说明已经添加完成了。二、Junit代码的构建 @Test publicvoidtestSet() { Graph<String>current=emptyInstance(); //测试错误输入负的权值 assertEquals(-1,current.set("A","B",-1)); assertEquals(false,current.vertices().contains("A")); assertEquals(false,current.vertices().contains("B")); assertEquals(false,current.targets("A").containsKey("B")); //测试权值不为0，图中没有这两点也没有这条边的情况，返回值应该是零，并且两个点应该已经被插入到图中，这条边也已经被插入到图中 assertEquals(0,current.set("A","B",1)); assertEquals(true,current.vertices().contains("A")); assertEquals(true,current.vertices().contains("B")); assertEquals(true,current.targets("A").containsKey("B")); //测试权值不为零，图中已经存在这两点的情况，返回值应该是1（同时完成对先前加入的边的权值的查看） assertEquals(1,current.set("A","B",2)); //测试权值为0，图中已经存在这两点的情况，返回值应该是2，并且这条边已经被删除 assertEquals(2,current.set("A","B",0)); assertEquals(false,current.targets("A").containsKey("B")); //测试权值不为零，图中有这两个点，但是没有这样的边的情况，返回值应该是0，并且这条边已经被添加 assertEquals(0,current.set("A","B",2)); assertEquals(true,current.targets("A").containsKey("B")); //测试权值为0，图中没有这两点也没有这条边的情况，返回值应该是0，但是同时没有对这两个点进行插入操作，也没有对这条边进行插入 assertEquals(0,current.set("C","D",0)); assertEquals(false,current.vertices().contains("C")); assertEquals(false,current.vertices().contains("D")); assertEquals(false,current.targets("C").containsKey("D")); } 以我之前对构建的图的类为例说明Junit代码的基本思路。首先对于任何用于测试的函数，都需要加上@Test标签，否则Eclipse不会识别你的测试方法，运行时不会执行。然后重点使用assertEquals函数，这个函数前一个参数是给定的正确结果，后一个参数是你要测试方法的返回结果。只有当两者相同，测试的结果才会是正确的。正确的结果将被标注为绿色，红色代表有运行错误，蓝色代表assertEquals结果出现错误，可以进一步进行检查。比如以下这个例子这一测试出现蓝色，双击这一内容进行检查。发现以下错误信息。双击上面一行进一步对比结果。可以看到详细的比较结果，然后返回查看代码的运行情况，进行debug。 3、使用注意(1)当使用Junit时如果代码中包含有exit函数，测试程序会直接卡死，网上有一些处理方式，详细可以查看https://blog.csdn.net/weixin_43872188/article/details/104781255(2)如果函数没有返回值可以进行比较，可以在类中定义相关的观察者方法，比如重写toString函数，当成检查的方式。(3)测试类也可以进行继承，并且子类如果没有重写父类中的测试函数，子类会自动执行父类的测试。举例：可以看到这一类中只写了三个测试方法。运行后可以看到执行了一些其他函数，而这些函数恰恰就是父类中的测试函数。 
第79篇文章[0]
Java按行读取文件内容：简要方法介绍和实例演示 Java按行读取文件内容：简要方法介绍和实例演示 1、使用到的相关方法和类简介 publicFileInputStream(Filefile)throwsFileNotFoundExceptionCreatesaFileInputStreambyopeningaconnectiontoanactualfile,thefilenamedbytheFileobjectfileinthefilesystem.AnewFileDescriptorobjectiscreatedtorepresentthisfileconnection.Ifthenamedfiledoesnotexist,isadirectoryratherthanaregularfile,orforsomeotherreasoncannotbeopenedforreadingthenaFileNotFoundExceptionisthrown. Parameters:file-thefiletobeopenedforreading.Throws:FileNotFoundException-ifthefiledoesnotexist,isadirectoryratherthanaregularfile,orforsomeotherreasoncannotbeopenedforreading.SecurityException-ifasecuritymanagerexistsanditscheckReadmethoddeniesreadaccesstothefile. 这是查阅的java原始库中的描述，简单介绍就是传入参数file，试图通过关联一个具体的文件建立一个文件输入流，如果文件名字不存在、无法被打开或是无法被阅读，那么就抛出异常。 建立文件输入流后，进一步需要建立BufferedReader对象来对文件输入进行读取。以下给出java原文档给出的实例，其中传入BufferedReader的参数还可以是InputStreamReader等输入流。 BufferedReaderin=newBufferedReader(newFileReader(“foo.in”)); 建立好字符读入后，便可以调用其中的方法进行按行读取内容。这里主要给出一个之后需要用到的方法，也就是按行读取一个字符串。 StringreadLine()Readsalineoftext. 2、实例演示 FilefileInput=newFile(fileName); ArrayList<ArrayList<Integer>>input=newArrayList<ArrayList<Integer>>(); Stringstr=newString(); inti=0; try{ FileInputStreamfile=newFileInputStream(fileInput); BufferedReaderbr=newBufferedReader(newInputStreamReader(file,"UTF-8"));//构造一个BufferedReader类来读取文件 while((str=br.readLine())!=null){ ArrayList<Integer>e=newArrayList<Integer>(); input.add(e); //System.out.println(str); for(Stringa:str.split("\t")){ try{ if(Integer.parseInt(a)<0) { System.out.println("输入中含有负数"); returnnull; } input.get(i).add(Integer.parseInt(a)); }catch(Exceptionw){ System.out.println("非法输入格式或内容"); returnnull; } } i++; } }catch(Exceptione){ System.out.println("读入文件错误"); returnnull; } 这段代码处理的是读取文件中的不含负数和小数的矩阵，按行对矩阵进行处理，最终将矩阵保存在input中，方便后续进一步处理。代码中的fileName便是读入文件的路径。 
第80篇文章[0]
Git中较为常见的命令和错误 一、常用指令1、将自己本地的代码上传到自己的github仓库中 gitinit//初始化仓库 gitadd.//添加文件到本地暂存区或用gitadd(文件name) gitcommit-m“firstcommit”//提交到本地仓库 gitremoteaddorigin远程仓库地址//添加远程仓库 gitpush-uoriginmaster//把本地仓库的master分支推送到远程仓库master分支 这些指令是常常用来将自己本地代码推送到master分支的操作。 2、新建分支 …最初在master上工作… gitcheckout-bchange创建新分支同时也切换到了change分支 比如现在想要将内容推送到change分支 gitadd* gitcommit-m"change"在该分支上提交 gitpushoriginchange gitcheckoutmaster切换回master分支 这是用来新建分支，并将内容推送到新分支上的操作。 3、查看当前提交信息 gitlog gitlog--graph gitlog--graph--all 第一条指令用于查看当前分支提交记录，第二条指令可以给出当前分支更加完整的先后顺序信息，第三条可以给出所有分支的提交信息和结构。 二、问题及解决方案1、在github上的文件夹出现白色箭头，无法进入访问问题原因：文件夹内部有.git的隐藏文件，可以通过查看隐藏文件的选项在文件管理器中查看。github因此将其视为子模块。解决方案：（1）删除文件夹里面的.git文件夹 （2）执行gitrm--cached[文件夹名] （3）执行gitadd[文件夹名] （4）执行gitcommit-m“msg” （5）执行gitpushorigin[branch_name]概括来说就是先删除文件夹里的.git文件，重新将其push到仓库。 2、GitHub提交的时显示Updateswererejectedbecausetheremotecontainsworkthatyoudo问题原因：此问题原因较多，但根本原因是远程仓库中的文件有部分本地库中没有。解决方法：gitpulloriginmaster//把远程仓库master分支拉取到本地仓库master分支但是如果改动很大，比如直接在两个不同的文件夹下进行push操作，即使进行pull也可能出现其他问题。比如，refusingtomergeunrelatedhistories解决方案：gitpulloriginmaster--allow-unrelated-histories 以上是我在学习过程中遇到的问题和使用的情况，学习时主要参考了以下内容：https://blog.csdn.net/u012308586/article/details/104905828https://blog.csdn.net/u012145252/article/details/80628451https://blog.csdn.net/xiebaochun/article/details/114143346 
第81篇文章[0]
Java正则表达式实例讲解 Java正则表达式实例讲解 首先观察本次需要读取的文件的内容 Employee{ ZhangSan{Manger,139-0451-0000} LiSi{Secretary,151-0101-0000} WangWu{AssociateDean,177-2021-0301} ZhaoLiua{Professor,138-1920-3912} ZhaoLiub{Lecturer,138-1921-3912} ZhaoLiuc{Professor,138-1922-3912} ZhaoLiud{Lecturer,198-1920-3912} ZhaoLiue{Professor,178-1920-3912} ZhaoLiuf{Lecturer,138-1929-3912} ZhaoLiug{Professor,138-1920-0000} ZhaoLiuh{AssciateProfessor,138-1929-0000} ZhaoLiui{Professor,138-1920-0200} ZhaoLiuj{AssciateProfessor,138-1920-0044} ZhaoLiuk{Professor,188-1920-0000}}Period{2021-01-10,2021-03-06}Roster{ ZhangSan{2021-01-10,2021-01-11} LiSi{2021-01-12,2021-01-20} WangWu{2021-01-21,2021-01-21} ZhaoLiua{2021-01-22,2021-01-22} ZhaoLiub{2021-01-23,2021-01-29} ZhaoLiuc{2021-01-30,2021-01-31} ZhaoLiud{2021-02-01,2021-02-08} ZhaoLiue{2021-02-09,2021-02-15} ZhaoLiuf{2021-02-16,2021-02-24} ZhaoLiug{2021-02-25,2021-02-28} ZhaoLiuh{2021-03-01,2021-03-01} ZhaoLiui{2021-03-02,2021-03-04} ZhaoLiuj{2021-03-05,2021-03-05} ZhaoLiuk{2021-03-06,2021-03-06}} 本段是一组排班人员的信息，第一部分是员工的信息包括其姓名、职称和电话，第二部分是值班表的开始时间和结束时间，第三部分是员工将要被放在排班表的位置信息。我们的目标是将以上介绍的信息全部读取出来。首先处理第一部分，我们最终要获得的是员工的姓名、职称和手机号，在对其所处部分进行对应后，建立以下正则表达式。 StringemployeeEntrance="\\s*Employee\\{\\s*"; StringemployeePattern="\\s*([^\\{]*)\\{([^,]*),(\\d{3})-(\\d{4})-(\\d{4})\\D*"; 第一行用于匹配Employee的第一行，也就是对应开始读入员工信息。表达式含义:\\s代表任何空白字符，包括空格、制表符、换页符等。后面跟一个*代表此空白符可以重复多次，或者一次也没有。与之类似的有+这个符号，表示这个位置至少有一个这样的字符。\{代表匹配大括号，注意在正则表达式中{带有格式说明的意思，所以为了表示其本身也需要加上\\。 第二行用于匹配后面真正的员工信息。表达式含义：这次与上次的式子不同，加入了（）括住了部分内容，括住的部分就代表将要在后面提取的内容，从前到后序号依次从一开始，在后面将通过这一顺序提取信息。[]括住的内容表示这一位置可能出现的字符，加上^代表除了这一字符的其他字符。后面\\d代表一个数字字符，与[0-9]相同，后面加上{3}代表重复三次，也就是按照文件中3-4-4的顺序进行提取。最后一个\\D*代表非数字字符的重复或空。 这样便构建了读取的正则表达式，但是想要按照表达式提取还没有完。 StringperiodPattern="Period\\{([0-9|-]*),([0-9|-]*)\\}"; StringrosterEntrance="Roster\\{\\s*"; StringrosterPattern="\\s*([^\\{]*)\\{([0-9|-]*),([0-9|-]*)\\}"; 这三句分别对应匹配后面三种句式，其中的内容与前面相似，我就不再详细介绍了。其中[0-9|-]，代表这一处可以是0-9的数字字符或是“-”这一字符，表示或者关系，采用|即可，表示范围可以使用头-尾。 用于匹配正则表达式的字符串规则构建完成，后面就是提取目标信息。 Patternemployee=Pattern.compile(employeeEntrance); Patternemessage=Pattern.compile(employeePattern); Patternperiod=Pattern.compile(periodPattern); Patternroster=Pattern.compile(rosterEntrance); Patternrmessage=Pattern.compile(rosterPattern); 创建Pattern对象对正则表达式进行解析。 Matchermessage=emessage.matcher(str); while(message.find()) { Stringname=message.group(1).substring(2); Stringposition=message.group(2); Stringphone=message.group(3)+message.group(4)+message.group(5); Stuffs=newStuff(name,phone,position); addStuff(s); str=br.readLine(); message=emessage.matcher(str); } 创建Matcher对象对读入字符串进行组捕获，之前在正则表达式中，我构建了五小括号，其中对应的内容分别保存在了group(1)到group(5)。group(0)中保存的式整个捕获的字符串。 这些是提取后的内容，其中还有其他内部处理，这里只是简单验证正确性。 我学习这部分内容主要参考的网址：https://www.runoob.com/java/java-regular-expressions.html里面内容比较全面，大家可以把我的当成一个实例来看。 
第82篇文章[0]
[HIT]哈工大2021软件构造学习心得 复习了一遍软件构造的概念，对这门课的学习方式和学习内容也有了些体会和心得，给大家分享下我的感受。 第一就是这是门编程课，所以一定要动手！！！一定要动手！！！一定要动手！！！个人评判目前学过的四门编程课，动手要求能力：C语言程序设计>软件构造>数据结构>算法设计。编程课不去敲代码是绝对不行的，哪怕你不去上课，习题课的内容、实验课的内容你也要亲自动手去敲。因为很多东西你只学理论是永远学不明白的，就像教你竖式乘法你却不去动手计算。Lab3我想对于绝大多数同学都是个很大的挑战，但也是这个实验中，我对继承、抽象类、具体类、接口等等各种概念才有了自己的认识。多动手，才是学好这门课的最主要途径！ 第二，这门课的先修真的太重要了。没学过Java和Git的我从第一节课就开始懵，直接懵到考试前，所以建议学弟学妹们，在学习数据结构，或者更早的时候，顺道就给Java学了吧。而且学了Java才后知后觉，用Java实现数据结构里的链表、树、图有多么轻松！想想当初C语言折磨得我 悔不当初。所以，有空早学Java，早晚都要学的！ 我觉得以上两点就是能确保你学好这门课的全部要素了，当然我哪点做的都不好 但是期末了，三个Lab都写完了，复习也复习过一遍了，突然发现这门课是一门越学的深入越能感受到其巧妙的课程。我想每个同学Lab1和第一次习题课写的代码现在如果再找出来，都能挑一大堆毛病出来，这不正是这门课的收获。虽然只有短短32学时，我们已经从面向过程的古板简陋的C语言程序员，变成能从很多层面写代码，面向对象编程的Java程序员了，而且越是用的多，越能感受到这种不一样的编程方式的魅力。我现在很有一种冲动，就是和很多人一起完成一个大型程序，用所谓敏捷编程的思想做个什么项目出来，感觉这种交互性、协同性，才能激发我编程的激情。然后再回过头看看我们的作品，分析分析他的健壮性、正确性、复用性、可维护性等等，我想我又会有新的感想。C语言教我从无到有，而软件构造和数据结构则教我们从有到好，从好到更好。 以上就是我对这门课的一些感想，当然还有24小时时间，试还是要考，仍需继续学习才是。 
第83篇文章[0]
[HIT]哈工大2021软件构造知识点理解(1) 委托 总有一些知识点，看起来似懂非懂，因此决定写几篇文章来对这些知识点总结归纳，顺便加强自己的理解，也欢迎各位积极指正其中理解不到位的地方。 在可复用处个人认为最难理解的地方就是委托(Delegation)，因此此处着重讨论一下Java中的四种委托 Dependency、Association、Aggregation和Composition。 由弱到强分别是Dependency->Association，Association中Aggregation->Composition。 假设有两个类A和B，A的Rep中含有B的对象，并且在之后A委托B，调用了B的方法，这样的委托称作Association，否则，若B的对象只作为A的某方法中的局部变量出现，我们管这样的委托叫做Dependency。 比如对于下面这个再简单不过的类B： publicclassB{ privatefinalintnum; publicB(intnum){ this.num=num; } publicintgetNum(){ returnnum; } } Dependency策略： publicclassA{ privatefinalintnum; publicA(){ Bb=newB(10); num=b.getNum(); } } 而关于Association策略，将其拆分成两部分，先来说较好理解的较强的Competition策略： publicclassA{ privatefinalintnum; privatefinalBb=newB(10); publicA(){ num=b.getNum(); } } 较弱的Aggregation策略： publicclassA{ privatefinalintnum; privatefinalBb; publicA(intnum){//此处传参也可以是Bb，看使用场景 Bb=newB(num); this.b=b; this.num=this.b.getNum(); } } 是不是有些懵，不用担心，接下来来总结一下： 1）Dependency策略的委托就像是一个渣男/渣女委托你办事，用完你就把你给甩了，并且在以前或者以后甚至都看不出任何你存在过的痕迹。 2）Competition策略的委托截然不同，就像一个贞洁烈女，只要我委托你办事了，我就赖上你了，而且我的对象从此以后只能是你，不能是别人。 3）Aggregation比较中庸，我委托给你了，我的心中就给你了一个位置，或许在未来我的对象会变，但他也永远是你的那个类型。 用这种方式来理解委托的概念，是不是就好理解多了。以上就是知识点理解第一篇的全部内容了。 
第84篇文章[0]
[HIT]哈工大2021软件构造知识点理解(2) 七大设计模式 不管怎么看，以我现在的水平，我都不可能在一篇文章中说明白一个设计模式，更别说七个。但如果你完全不知道这七大模式都是什么，那么这篇文章或许对引领你建立对这六种模式理解的框架有所帮助。 其实Java开发共有23种模式，关于这23种模式CSDN上优秀的文章比比皆是，但因为考试只针对其中六种，故在此为那些正在学习和明年将学习的学弟们写一篇入门的不能再入门的文章。 1）Adapter模式：Adapter模式也叫做适配器模式，什么是这个所谓的适配器模式呢。我来用最通俗的语言举个例子：假设你有一个3.5毫米插头耳机，并且你使用的是老款的安卓手机，上面带有一个3.5插孔耳机孔，你当然可以自由地使用这个耳机。但有一天你要换手机了，换成最新款的苹果手机，上面并不带有3.5插孔耳机孔，而是一个苹果专用接口，你该怎么做呢？将耳机线拆开将其重新焊接上苹果接口？还是给苹果手机拆开凿一个3.5插孔的耳机孔？现实中没有人这么做。因为这时就轮到我们的适配器登场了。只需要一个转换口，将原来的接口转换为适合耳机的接口即可。这里的这个转换口，就是Adapter。在Java编程实际过程中，Adapter一般是将具体类和接口进行转接，Adapter是OCP(Open-ClosedPrinciple)的体现之一。关于更详细的Adapter模式讲解，可参考以下文章：(4条消息)适配器模式的三种形式_烟雨星空的博客-CSDN博客_适配器模式 2）Decorator模式：装饰者模式，在我看来是这七大模式中最优雅当然也最晦涩难懂的设计模式。举一个经典的例子，也就是奶茶加珍珠的例子。假设一家奶茶店产品有红茶绿茶四季春奶茶，相应的配料有珍珠椰果红豆布丁奥利奥等等，作为软件工程师的你如何为这家店设计一个点餐平台呢？朴素的思想是排列组合，设计一个抽象类Tea，然后为每种具体饮品分别实现，在每个具体类中用boolisPearl，isOrio等等标记加料情况，那如果一个顾客加了三份珍珠怎么办呢？而且在每个具体类中重复的使用相同的bool变量，显然不符合我们避免代码复用的思想。优雅的解决方案是，为PearledTea等具体类设计一个统一的抽象类AddedTea，这个AdderTea继承Tea，且委托具体饮品类如RedTea等中的方法来完成功能，这样就形成了一个层层包装的商品流程。为简化例子，假设功能只有一个getPrice计算价格，一位顾客点了一杯三份珍珠一份奥利奥的红茶，那么包装的效果应如下所示： 关于更详细的Decorator模式讲解可参考：(4条消息)装饰者模式(通俗易懂)_笔记别偷看-CSDN博客_装饰着模式 3）Template模式：也叫模板模式，这个应该是最好理解的一个设计模式，同样开始举例子：假设用户想进行球类运动，球类运动的一般步骤假设是：换运动服 打球 洗澡 回家，可以见得不管打什么球，用户的换运动服和洗澡步骤都是一样的。那么模板模式的思想就是先设计一个抽象类，直接在其中具体实现换衣服方法和洗澡方法，至于具体打球方法留给各子类去完成。这个模式不贴参考文章了，应该明白意思就理解了，毕竟Lab中用的还蛮多的。 4）Strategy模式：策略模式，主要结合@Override使用。这种模式我们C语言最早期就接触过，用Switch语句选择不同的排序方式然后单步调试观察运行效果，可以类比到策略模式中。策略模式就是用户端动态的选择不同的算法来完成同一个任务，过程是首先构造一个接口，然后客户端传入要使用的算法后通过委托来实现所选择的算法。委托策略一般是Aggregation，也就是较折中的策略。策略模式可以参考(4条消息)策略模式及简单Java案例代码实现_Len-CSDN博客_策略模式java 5）Iterator模式：迭代器模式是较常用的轻量化模式，最为常见的便是链表List的遍历。迭代器模式设计要求设计者所完成的ADT无需关心容器具体类型的情况下即可完成迭代过程，其具体的实现方式是在ADT中实现Iterable接口，此接口内部只有一个返回一个迭代器的方法，然后再创建一个内部类实现Iterator接口，重写其hasNext()、next()和remove()方法，同样不贴参考文章了，贴一段代码，来自(4条消息)[HITSC]哈工大2020春软件构造复习笔记(4)_北言栾生的博客-CSDN博客 publicclassPair<E>implementsIterable<E>{ privatefinalEfirst,second; publicPair(Ef,Es){first=f;second=s;} publicIterator<E>iterator(){ returnnewPairIterator(); } privateclassPairIteratorimplementsIterator<E>{ privatebooleanseenFirst=false,seenSecond=false; publicbooleanhasNext(){return!seenSecond;} publicEnext(){ if(!seenFirst){seenFirst=true;returnfirst;} if(!seenSecond){seenSecond=true;returnsecond;} thrownewNoSuchElementException(); } publicvoidremove(){ thrownewUnsupportedOperationException(); } } //使用隐式方法迭代 publicstaticvoidmain(String[]args){ Pair<String>pair=newPair<String>("foo","bar"); for(Strings:pair){ } } } 6）Visitor模式：访问者模式的总体思想是数据Data与操作Operation分离的思想。实现较为复杂却并不困难：假设你家地下车库中放着各种乱七八糟的东西，如旧衣服篮球报纸玩具，而你要做的是是为你的汽车加油，但对其中大部分物品(Element)这个操作是不合法的，所以朴素的思想是在加油方法中加入判断语句，但如果是一个泛化操作，比如如果找到了玩具做什么，找到了报纸做什么，那么大段的switch-case不仅不优雅而且性能级差。因此Visitor模式的思想是通过一个Visitor抽象类，在其具体实现中实现visit方法，另外定义一个Element接口，在其具体实现中根据应用需求能够完成此时对应的操作，这样在访问时就能利用Dependency策略的委托来完成对应操作。深入学习可以参考(4条消息)设计模式(JAVA) Visitor模式_读书好学求知-CSDN博客 7）FactoryMethod模式：工厂方法模式也较好理解，举个例子，假如你要为你们家买一台空调，但还没决定好要买哪个牌子的空调，于是你对卖空调的工厂传入了你的需求。卖空调的工厂有很多子工厂，分别能生产海尔美的格力各种空调，这样一来，不管你买哪个牌子都可以直接与总工厂协商，总工厂再交由子工厂来具体实现为你生产空调这一操作。总工厂相当于一个接口，而子工厂则是这个接口的具体实现类。最为常见的FactoryMethod模式如使用Collection的时候，假设你要定义一个Map接口局部变量，你既可以实现为HashMap，也可以实现为TreeMap。更多请参考(4条消息)设计模式之工厂方法模式_Mr.yang的博客-CSDN博客 以上例子或者思想并不是我独立创造的，而是基本上全部来源于别人优秀的文章，我只是将他们进行总结归纳整合，在此抛砖引玉，希望为大家软件构造学习之路能有所启发有所帮助。 
第85篇文章[0]
[HIT]哈工大2021软件构造知识点理解(3) 异常与断言 首先理解Java中异常的组织结构。Java中的异常Exception是一个类，继承自Throwable，Throwable还派生出Error类。Exception子类一般分为RuntimeException和一般性异常。 RuntimeException=运行时异常=系统异常=uncheckedException，可以编译通过，此类异常一定是程序员的问题，常见如被0除异常，是程序健壮性低的体现，打印异常信息即可。 一般性异常=受控异常=编译时异常=checkedException，此类异常必须显示的捕获/传递否则无法编译通过。 然后理解，捕获和抛出的有关概念： 1）捕获：try-catch-finally语句，try捕获异常，try接口会对可能含有异常的代码进行检查，若出现了异常信息，将异常传递给后面的catch()块进行处理，catch括号内为异常类，try后面可以跟多个catch块，对应不同的异常处理。try-catch类似于循环中的if-break，当异常出现时后续代码不会执行。而finally块是不管异常与否都会执行，也就是若出现异常，停止继续执行try块转而执行finally块，而若未出现异常，执行完try块将执行finally块。由于try-catch的break性质，一般先截获子异常，再截获父异常。由具体到抽象，由小范围到大范围。 2）抛出：注意，有两种语句：throws和throw。throws语句，一般在方法的声明处，跟在函数名后参数前。“出错了就不管了”的赖皮属性声明此方法可能产生的所有异常，不作处理将异常向上传递，异常处理交给调用者。throw用来在方法体内部抛出具体的异常，后面跟异常对象名，将错误信息真正的抛出。异常对象后面一般会跟getMessage()方法和printStackTrace()方法，二者区别在于getMessage会打印异常描述信息如日志信息，而printStackTrace会打印堆栈信息。 有了这些概念，assert就很容易了。 assert语句常见有两种： assertcondition;//condition为真则无事发生，为假则抛出一个AssertionError对象 assertcondition:message;//condition为真无事发生，为假会将message传入AssertionError进行错误信息输出 须注意的是，assert在IDE常规工作模式下并不会生效。 自定义异常也是考点的一部分，一般来说是一个继承自Exception的类，只含有无参数构造方法和有参数构造方法两个方法，如下： publicclassMyExceptionextendsException{ publicMyException(){ super(); } publicMyException(Stringmsg){ super(msg); } } 调用时需使用 thrownewMyException(message); 
第86篇文章[0]
HIT软件构造21年春lab总结 HIT软件构造21年春lab Lab1P2convexHull Lab2迭代器删除toString的益处AF，REP的理解参数输入类型的对比 Lab21.MultiIntervalSet对于IntervalSet的委派关于周期性的疑惑 Lab1 P2convexHull 关于二维凸包的一个问题，一开始的想法是：先选定最右下角的点作为基点，然后如果下一个点在相对于以基点做的y轴的右侧则后续的点都得选取逆时针角度最大的点，直到回到基点。以上想法是由于之前写过一个计算两个向量转向的函数，而如果是逆时针的话就是角度大于180度，所以就相当于寻找旋转角最大的即可，不过实际操作起来发现时间复杂度过大，于是去寻找了相关的算法，发现了向量叉乘结果可以判断逆时针还是顺时针，于是陷入了沉思。向量的叉乘究竟是如何判断逆时针还是顺时针，我查找了许多的参考资料都没有一个完整地解答这一个原理。我们知道，根据右手螺旋守则，逆时针方向的向量叉乘都指向同一侧，而顺时针都指向另一侧，个人猜测这个原理是个发现，由于发现逆时针叉乘结果都是正的，才规定叉乘结果是正就是逆时针，叉乘结果是负就是顺时针。 Lab2 在lab2中有许多新的发现。 迭代器删除 例如如果要删除容器里面的元素，例如：list，map，set。最好是使用迭代器来删除，因为如果用for循环来删除，假设当删去第i个元素时，后续的所有元素就会往前移动，第i+1变为i，i+2变为i+1……。而此时循环中的控制循环次数变量仍是i，且下一个循环就变为i+1，而我们本来的i+1元素已经到了第i个元素，所以会有漏删的可能性。这种时候我们就最好使用迭代器删除。然后迭代器中最难书写的就是Map了，需要在Map.Entry使用迭代器。 toString的益处 toString()函数在debug中的帮助。toString是为了让我们更好地理解一个ADT类，用人能听懂的话。当我们override了toString后，我们在debug时，我们的ADT变量就会用我们定义的toString来表示，如果我们没有toString，则该变量显示的就是内存地址，这不方便我们去理解内部的情况，所以后续在编写ADT时，最好先将toString完成。 AF，REP的理解 AF我的理解是用人的语言去描述ADT类型，让使用者可以听懂这个ADT是用来表示什么的。REP我的理解是它声明了有什么变量，变量之间或者变量本身要满足什么关系。 参数输入类型的对比 在FriendshipGraph中，我将原本的参数输入从Person改为String，然后在方法内部再new出Person。这里是由于习题课的时候老师提过一嘴，采用基础数据类型的好处在于让客户端对我们内部的实现了解更少，这样子更有利于我们保护内部的数据。 Lab2 1.MultiIntervalSet对于IntervalSet的委派 在MultiIntervalSet中要求将IntervalSet作为我们的Rep，称为intervalSet，需要复用IntervalSet中已实现的类和功能。但是IntervalSet接口的实现类CommonIntervalSet是针对标签只有一个时间段的插入。那么问题来了，如果要在MultiIntervalSet中通过intervalSet来插入一个标签多个时间段就必须得重写MultiIntervalSet的标签。然而时间段的管理都在intervalSet这个我们的Rep中的成员变量中。 但是MultiIntervalSet正常来说是无法范文IntervalSet中的Rep，所以我们就需要将IntervalSet中的Rep返回出来，于是我增加了一个getIntervalSet的函数。 现在又有个问题了：当DutyIntervalSet继承了CommonIntervalSet，它就多了一个getIntervalSet函数，很显然在DutyIntervalSet类中，我们是不想把他的Rep返回给客户端，对于这个问题我的想法是将DutyIntervalSet的getIntervalSet重写为空，但是这个方法又不符合LSP原则了。所以重写了MultiIntervalSet中的Rep，一开始的方法是将IntervalSet中的rep定义为Map<L,List<·Interval>>。现在我们将MultiIntervalSet中的Rep定义为List<·IntervalSet>。如果同一个标签有新的Interval就往List中add一个新的Interval。由此能很好地实现委派的任务。 关于周期性的疑惑 关于App1与App2，没有要求周期性。那么岂不本应该意味着App1和App2不论是否满足周期性都是正确的？而且App1本身便是一个标签一个时间段，从定义上一开始就不满足周期性。所以对于App1和App2我不去检验周期性，而对于App3由于要求满足周期性原则，所以如果经检验，不满足周期性我便抛出异常。以上是我对周期性的理解。 
第87篇文章[0]
LSP原则学习笔记 LSP原则要求，子类要能替换父类型，从中总结出几点符合的条件要求： 子类的Spec要强于或等于父类。Spec强=前置条件更弱|（在对比双方中满足更强的前置条件下）后置条件更强。子类型的异常可以更具体，协变子类型的返回类型可以更具体，协变其实这点很好理解，比如父类的返回值原本为Animal，换回子类型之后，返回的是Cat，其中CatextendsAnimal，这在编译上是可以通过的。如果父类型是Cat，子类型返回Animal，那这就在编译上无法通过了子类型的参数类型可以更宽松，逆变同样从编译角度去考虑，假设父类型传入的是一个接口的参数，例如ArrayList<.L>，那么子类型改为List<.L>，原本传入父类型的参数仍然可以传入子类型的对象中，所以是满足的。如果反过来，父类型中是List<.L>，子类型是ArrayList<.L>，那么这在编译上就不能通过了，因为传入父类型的参数可以是LinkList，与ArrayList不同。 
第88篇文章[0]
软件构造期末复习内容9-12讲 程序复用性： 白盒：源代码可见可修改，通过代码层面的继承进行扩展 黑盒：源代码不可见，通过实现特定接口进行扩展 LSP：子类型可以增加方法，但不可删除 子类型必须实现所有抽象类未实现方法 子类型重写方法比如有相同类型返回值和参数列表 不能抛出额外异常 委派：一个对象请求另一个对象，也是复用的一种方式 可维护性： 纠错适应完善预防 耦合指不同方法之间的依赖 不应该有多于1个原因使你的ADT发生变化 设计模式：适配器 将某个类/接口转换成client期望的其他形式 装饰器 用子类实现不同特性 策略模式：用多种方法实现同一个任务，根据需要动态切换算法 模板模式：共性步骤一样，具体实现不同 迭代模式：无论容器为何，枚举方式一致 工厂模式：将实现交给子类，由子类决定实现什么。 运行时异常：由程序员处理不当导致 checked/unchecked如果能够补救，就checked，否则unchecked 
第89篇文章[0]
软件构造期末复习内容4-8讲 数据类型： 类型检查： 静态检查：在编译阶段检查 动态检查：在运行时检查 Immutable:一旦确定其值或指向对象，无法再改变 （Final） 对于不可变类型，修改值实际上是修改了引用对象 拷贝时为确保安全，拷贝的是对象的一个复制 snapshot中，不可变类型用双线椭圆，不可变引用用双线箭头 设计规约spec 行为等价性：从客户端视角看是否等价 符合规约即等价 前置条件：对用户约束，后置条件：对开发者约束，前置条件满足则后置条件必须满足 规约强度：针对开发者的限制。 ADT操作的四种类型： 构造器：构造一个ADT 生产器，用当前内容产生一个新的对象 观察器：观察ADT中数据 变值器：改变对象属性的方法 表示独立性：使用ADT时无需考虑其内部实现 表示泄露：指用户可以使用我们提供方法以外的方法来修改ADT内部数据 RI：表示不变性，或看作某个表示是否合法 AF：某种具体表示对应抽象空间内容的映射 OOP：面向对象编程 接口Interface：定义ADT 一个接口可以有多个实现，一个类可以实现多个接口 接口用于确定规约 继承： 严格继承：子类只能使用父类的方法和自己的方法，不能修改 重写：子类可以重新实现父类的方法 重载：多个方法具有同样的名字，但有不同的参数列表和返回值 静态类型检查时根据参数列表匹配对应的方法 ADT等价：AF映射到同样结果即视为等价 ==对基本类型equals对对象类型 实现ADT时equals要重写 等价对象必须有相同的hashcode Mutable 观察等价：看起来是否一致 行为等价：对于相同行为，结果是否均一致 
第90篇文章[0]
软件构造课程期末复习内容（1，3讲) 软件构造的多维度视图 按阶段划分：构造时/运行时 按动态性划分：时刻/阶段 按层次划分：代码/构件 软件构造的阶段划分： 构造阶段(Build-time):词汇，语义，语法，变化，静态链接 运行时阶段(Runtime): 内外部质量指标 外部： 正确性：按照预先规约的方式运行(最重要指标) 健壮性：针对异常情况的处理 可扩展性：是否可以容易地修改软件 可复用性：一次开发，多次使用 兼容性：不同软件之间相互可容易集成 性能 可移植：软件可方便地在不同环境之间移植 易用:容易操作，对用户友好 其他性质：及时，可验证，完整，可修复，经济等 内部： 代码可读，可理解，清晰，码量大小。 5个重要的质量指标 容易理解，便于开发，做好修改准备，面对bug是安全的，运行效率高。 软件配置管理SCM： 追踪控制软件变化 软件配置项：软件中发生变化的基本单元(如文件). 基线(Baseline)：软件变化过程中的稳定版本 版本：软件在某一特定时刻的标识，便于在多个开发者之间形成协作。 版本控制系统VCS 本地：仓库存储于本地 集中式：仓库有独立服务器 分布式：仓库存储于独立服务器和每个开发者的本地机器 git： 
第91篇文章[0]
软件构造的一些个人体会2 在整个软件构造的课程中和学习Java的过程当中，学到了一些比较重要的知识点。对于一些知识点我理解的不是很透彻，觉得还是要进一步多学习一些。在这里稍微地总结一下之前学到的，理解起来对我来说比较困难的一些知识点吧。 关于Immutable和mutable 这个方面是在学习的时候让我感到比较难理解的。对于immutable：拥有方法可以修改自己的值或者引用，对于mutable：一旦被创建，始终指向同一个值或者引用。比如一个经常被举得例子，就是String和StringBuilder。 Strings="a";//开辟一个存储空间，里面存着字符a，s指向这块空间，记为space1 Stringt=s;//让t指向s所指向的空间即space1 s=s.concat("b");//把字符a和字符b连接，然后把“ab”放在一个新的存储空间，记为space2，最后让s指向这块空间 //我们可以看到，现在s和t所指向的是两块不同的空间，空间中的内容也不一样，因此s和t的效果是不一样的 StringBuildersb=newStringBuilder("a");//开辟一个存储空间，里面存着字符a StringBuildertb=sb;//开辟一个存储空间，里面存着字符a sb.append("b");//取出a，然后与字符b连接，然后把“ab”仍然放在这块空间内，把原来的“a”覆盖了，sb的指向没变 //在这个情况下，由于从始至终只用到了一块存储空间，所以sb和tb的效果实际上是相同的 mutable和immediate各有各的好处吧，不过为了避免一些错误，保证程序的正确性，多考虑使用mutable。 spec结构和强度 这个是课程的一个很重要的部分，实验和上课的时候经常强调。对于spec：前置条件：对客户端的约束，在使用方法时必须满足的条件；@paramannotation：说明每个参数的前置条件；后置条件：对开发者的约束，方法结束时必须满足的条件；@returnannotation：说明后置条件；@throwsannotation：说明出现异常的时候会发生什么。对于spec的强度，一般来说，使得spec变强的要求是更宽松的前置条件，加上更严格的后置条件。同时要注意，spec不可以暴露实现细节，不可以暴露局部变量，也不可以暴露私有的数据域。 关于等价性 不可变类型的等价性判断等价的两个方式：AF映射到同样的结果，则等价。站在外部观察者角度：对两个对象调用任何相同的操作，都会得到相同的结果，则认为这两个对象是等价的。两个等价的对象调用相同的Observer应该返回相同的结果。==：引用等价性equals()：对象等价性可变数据类型的等价性观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致。调用Observer方法表现出相同的结果。约等于对象等价性。行为等价性：约等于引用等价性。调用对象的任何方法都展示出一致的结果。包括mutator、producer、observer。 其他部分 其他的很多知识点也是很重要的，比如继承，委派，逆变，协变，LSP等部分，在这里就不具体的展开了，毕竟我自己觉得我的理解还是有待提升的。 
第92篇文章[0]
软件构造的一些个人体会1 大二下学期的后半学期，学校开了软件构造这一门课。到不久之前结课为止，也是上了大半学期了，所以就在期末之前稍微提一下在这们课上学到的一些东西和自己的一些个人体会吧。 1.Git和GitHub在课程中的使用 在大一的时候就已经听过学长在讲座上介绍过Git以及GitHub，但是当时没有系统的学习过，就一直对这个东西是半懂不懂的状态。在软构这门课上，专门学习了版本控制系统VCS，同时实验课要求使用Git上传代码到GitHub上，所以自己查了一些资料，算是有了一些基本的了解了。在软件构造实验的时候使用到的git命令不多，主要是以下这一些：创建：gitinit暂存：gitadd.链接：gitremoteaddorigin提交：gitcommit-m“commitmessage”推送：gitpush-uoriginmaster在实验三还涉及到一些分支的命令。 2.对于测试的一些想法 软件构造课程上，老师十分强调测试用例的重要性，实验的要求里面也是十分的重视写测试代码。这里跟之前接触到的编程课还是有些不同的。之前的课程，比如大一的程序设计基础，还有上学期的数据结构和这学期的计算机系统，主要是使用的C语言，写代码的时候也没有特意去强调测试用例和debug等方面。不过在这一门课程里，不同的就是真的很重视测试代码。虽然我在写实验的过程中对写测试代码不是很熟练，有时候会有抵触的情绪，但是客观的说，测试用例能帮助我们节约很多的调试时间。以及，通过测试衍生出来的代码覆盖度问题，选取测试用例的问题，我认为都是很有帮助的。 3.spec和代码注释 之前的编程课强调实现的过程，更多的是自己和自己之间的一种行为，因此我在写代码，对于注释总是觉得能省则省，能够满足基本的看得懂就行。而现在在软件构造这门课上，更多的是强调了面向对象的思想，这时候写spec和代码的注释等就很重要了，不过在这方面我觉得我的意识还是不够。课程里面也是有挺多的地方涉及到这一方面的东西。好的spec好像⼀道防火墙⼀样将客户和实现者隔离开，它使得客户不必知道这个单元是如何运行的，也使得实现者不必管这个单元会被怎么使用。 4.课程的一些想法 这一门课最主要的内容就是介绍ADT和OOP的部分，还有一些复用性和可维护性的知识点，最后又讲了一些面向健壮性与正确性的内容。由于课时的压缩，整体的课程压力还是很大的。个人感觉难理解的主要是ADT以及OOP，可能是因为之前没学过Java，在大一的夏季学期学习的C++也忘了挺多内容的。再加上课程的课时紧张，要求我们自学Java，这就导致了在某一些方面学的不精的问题了。课程的内容比较多，全部面面俱到是很难的，我自己能力也不足。在后面的博客我想要讲一些我自己觉得比较重要的部分吧。 
第93篇文章[0]
Java泛型的类型擦除 为什么Java的泛型要使用类型擦除？ 从技术来说，Java完全可以不使用类型擦除而直接实现”真泛型”。然而，Java诞生的时候，是没有包括泛型的，10年之后，Java才想实现类似于C++模板的概念，即泛型。由于Java类库是非常宝贵的资源，因此必须保证向后兼容。如果要实现“真泛型”，不仅需要修改JVM的源代码，让JVM能正确读取和校验泛型信息；而且为了兼容，需要为原本不支持泛型的API都添加相应的泛型API。这样的修改工作量是无法想象的。因此Java设计者采取了“类型擦除”这种机制作为折中的实现方式。 什么是类型擦除？ 在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉，这个过程就称为类型擦除。 我们以一个例子来验证Java的类型擦除机制。对于下面的代码，最后输出的结果为true。 ArrayList<Integer>intergerList=newArrayList<Integer>(); ArrayList<String>stringList=newArrayList<String>(); System.out.println(intergerList.getClass()==stringList.getClass());//true 我们定义的两个列表，一个是String泛型，一个是Integer泛型，但是它们的getClass()方法得到的类信息居然是一样的。这说明泛型类型String和Integer在运行之前就被擦除掉了，在运行时无法知道定义时的具体类型。 在类型擦除后的实际类型是什么呢？根据上面所说的向后兼容，擦除后的实际类型应该能被之前没有泛型时的Java程序接受。因此Java将具体的类型擦除为原始类型。原始类型就是擦除泛型信息，最后在字节码中的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供。类型变量擦除时，使用其限定类型替换（无限定时用Object替换）。 举例来说，如果我们定义下面这样一个带泛型的类： publicclassNode<T>{ privateTdata; privateNode<T>next; publicNode(Tdata,Node<T>next){ this.data=data; this.next=next; } publicTgetData(){ returndata; } //  } 那类型擦除后，它的实际定义应该类似于： publicclassNode{ privateObjectdata; privateNodenext; publicNode(Objectdata,Nodenext){ this.data=data; this.next=next; } publicObjectgetData(){ returndata; } //  } 所有的泛型T都被替换为Object。 类型擦除带来的问题 1.运行时的类型检测问题：由于类型变量会在运行前被擦除掉，那如何检测到向ArrayList<String>中添加非String类型的对象这种类型错误呢？ 解决方法：利用编译器进行静态检查。编译器会先检查代码中的泛型类型，如果存在类型不匹配，会直接报错，只有在类型匹配时才能进行后续的类型擦除。比如： List<Integer>myInts=newArrayList<Integer>(); myInts.add(1); myInts.add(2); List<Number>myNums=myInts;//compilererror myNums.add(3.14); staticlongsum(List<Number>numbers){ longsummation=0; for(Numbernumber:numbers){ summation+=number.longValue(); } returnsummation; } List<Integer>myInts=Arrays.asList(1,2,3,4,5); List<Long>myLongs=Arrays.asList(1L,2L,3L,4L,5L); List<Double>myDoubles=Arrays.asList(1.0,2.0,3.0,4.0,5.0); sum(myInts); sum(myLongs);//compilererror sum(myDoubles); 2.返回泛型类型的函数怎么办？所有的泛型类型都会被替换为原始类型，那返回泛型类型的函数实际上返回的是原始类型的对象，难道还需要手动的类型转化吗？ 解决方法：自动生成类型转换。ArrayList的get方法源代码如下： publicEget(intindex){ RangeCheck(index); return(E)elementData[index]; } 在return之前，会根据泛型的类型进行强转。即使泛型信息会被擦除，但是会将(E)elementData[index]编译为(Date)elementData[index]。因此不需要自己手动进行强转，在类型擦除时会自动地在结果字节码中插入强制类型转换。 3.不能使用泛型数组。如果我们假设在Java中可以创建泛型数组，那么看如下代码： List<String>[]s=newArrayList<String>[1]; List<Integer>i=Arrays.asList(1); Object[]o=s; o[0]=i Java的类型系统规定，子类数组是父类数组的子类，因此Object[]o=s;是正确的。如果我们假设可以创建泛型数组，那上述代码没有任何问题。但是最后一行代码将List<Integer>类型的对象赋给了List<String>类型的数组，这个问题在编译时无法发现，只能在运行时出现问题。然而，类型擦除机制要求编译器能够检测所有类型不匹配的问题。因此Java中禁止创建泛型数组，这样编译器就可以检测所有的类型不匹配问题。 
第94篇文章[0]
2021哈工大软件构造Lab3 2021年春季学期计算学部《软件构造》课程 Lab3实验报告 目录 1实验目标概述···1 2实验环境配置···1 3实验过程···1 3.1待开发的三个应用场景···1 3.2面向可复用性和可维护性的设计：IntervalSet<L>·2 3.2.1IntervalSet<L>的共性操作···2 3.2.2局部共性特征的设计方案···3 3.2.3面向各应用的IntervalSet子类型设计（个性化特征的设计方案）···4 3.3面向可复用性和可维护性的设计：MultiIntervalSet<L>·7 3.3.1MultiIntervalSet<L>的共性操作···7 3.3.2局部共性特征的设计方案···7 3.3.3面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）···9 3.4面向复用的设计：L·11 3.5可复用API设计···13 3.5.1计算相似度···13 3.5.2计算时间冲突比例···14 3.5.3计算空闲时间比例···15 3.6应用设计与开发···15 3.6.1排班管理系统···15 3.6.2操作系统的进程调度管理系统···17 3.6.3课表管理系统···18 3.7基于语法的数据读入···18 3.8应对面临的新变化···20 3.8.1变化1·20 3.8.2变化2·21 3.9Git仓库结构···21 4实验进度记录···22 5实验过程中遇到的困难与解决途径···23 6实验过程中收获的经验、教训、感想···24 6.1实验过程中收获的经验和教训···24 6.2针对以下方面的感受···24 实验目标概述 本次实验覆盖课程第2、3章的内容，目标是编写具有可复用性和可维护性的软件，主要使用以下软件构造技术： 子类型、泛型、多态、重写、重载继承、代理、组合语法驱动的编程、正则表达式API设计、API复用 本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过ADT和泛型等抽象技术，开发一套可复用的ADT及其实现，充分考虑这些应用之间的相似性和差异性，使ADT有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。 实验环境配置 Eclipse和Git在上一次实验中已经配置好了。本次实验无需额外配置环境。 在这里给出你的GitHubLab3仓库的URL地址（Lab3-学号）。 https://github.com/ComputerScienceHIT/HIT-Lab3-1190200817 实验过程 请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。 待开发的三个应用场景 简要介绍三个应用： ①值班表管理，一个单位有n个员工，在某个时间段内安排值班。每天只能安排一个员工且不能出现无人值班的情况；每个员工需要安排在连续的几天内。值班表内需要记录员工的名字、职位、手机号码，以便于外界联系值班员。 ②操作系统进程调度管理，进程被调度在CPU上执行，操作系统决定在各个时段内执行哪个进程。操作系统可挂起某个正在执行的进程，在后续时刻可以恢复执行被挂起的进程。每个时间只能有一个进程在执行，其他进程处于休眠状态；一个进程的执行被分为多个时间段；在特定时刻，CPU可以“闲置”；调度无规律，可看作是随机调度。 ③大学课表管理：课程需要特定的教室和特定的教师。假设各周的课表都是完全一样的，同样的课程安排将以“周”为单位进行周期性的重复，直到学期结束；一门课程每周可以出现1次，也可以安排多次，且由同一位教师承担并在同样的教室进行；允许课表中有空白时间段；同一个时间段内可以安排不同的课程；一位教师也可以承担课表中的多门课程。 相同之处：都包含了具有不同特征的“时间段集合”对象。每个时间段对应一个对象标签。 不同之处：有三个维度上的差异。①是否允许时间轴上有空白。在应用1中，不允许有空白；在应用2和应用3中，允许有空白。②是否允许不同的interval之间有重叠。在应用1和应用2中，不允许有重叠；在应用3中，允许有重叠。③是否包含周期性的时间段。应用3中以“一周”为单位重复某个课程，但应用1和应用2中不存在这种情况。 面向可复用性和可维护性的设计：IntervalSet<L> 该节是本实验的核心部分。 IntervalSet<L>的共性操作 这个ADT描述了一组在时间轴上分布的“时间段”，每个时间段附着一个特定的标签，且标签不重复。因此共性的方法包括： 静态工厂方法empty()：创建一个空对象。voidinsert(longstart,longend,Llabel)：在当前对象中插入新的时间段和标签。Set<L>labels()：获得当前对象中的标签集合。booleanremove(Llabel)：从当前对象中移除某个标签所关联的时间段。longstart(Llabel)：返回某个标签对应的时间段的开始时间。longend(Llabel)：返回某个标签对应的时间段的结束时间。IntervalSet<L>copy()：返回这个对象的副本。 局部共性特征的设计方案 由于IntervalSet是一对一的结构，即一个标签对应一个时间段，因此可以使用Map作为内部的数据结构，定义为： privatefinalMap<L,time>intervalMap=newHashMap<>(); 由于时间段是两个long型的整数构成的，因此可以定义一个辅助类time表示一个时间段。其中start是时间段的开始，end是时间段的结束，同时要求start一定大于0且start一定比end小。这里time实现了Comparable接口是为了满足下面MultiIntervalSet中的一些功能。 对于empty()方法，直接返回一个具体实现类。 对于insert()方法，首先判断非法条件（start<0和start>=end），然后判断Map中是否包含标签，若包含该标签，那只有在重复设置相同时间段时才合法，否则会抛出IntervalConflictException；若不包含该标签，就直接插入时间段。（注意，这里是允许不同标签之间存在Overlap的） 对于labels()方法，直接返回Map中所有的键构成的集合即可。 对于remove()方法，判断Map的键中是否存在该标签，若不存在，直接返回false；若存在，就在Map中删除该标签，并返回true。 对于start()方法，判断Map的键中是否存在该标签，若不存在，直接返回-1，否则可以得到标签对应的时间段time，调用time的getStart()方法就可以得到时间段的开始时间并返回。 对于end()方法，同上，但要调用time的getEnd()方法得到时间段的结束时间并返回。 对于copy()方法，先新建一个空白的IntervalSet副本，然后遍历Map。将遍历得到的所有时间段和标签通过insert()方法插入到新的副本中，最后返回该副本。 此外，还需要重写toString方法提供容易阅读的信息。 面向各应用的IntervalSet子类型设计（个性化特征的设计方案） 一、使用decorator装饰器的方法进行是否允许不同的interval之间有重叠以及周期性的维度的个性特征的设计。向装饰器中传入待装饰的IntervalSet，并在继承该装饰器的具体子类中实现相应的个性化功能。如下图，在装饰器IntervalSetDecorator中有属性intervalSet，是一个待装饰的IntervalSet类，而IntervalSetDecorator中的所有方法都调用intervalSet的相应方法。 ①不允许重叠的IntervalSet实现如下： 首先NoOverlapIntervalSet继承装饰器IntervalSetDecorator，并实现IntervalSet接口。在NoOverlapIntervalSet中添加一个属性intervalMap记录添加的所有时间段。 在重写的insert()方法中，首先判断新添加的时间段是否与已添加的时间段发生重叠，如果有，直接抛出异常；否则就调用未重写的父类的insert()方法进行插入。 ②周期性的IntervalSet实现如下： 首先PeriodicIntervalSet继承装饰器IntervalSetDecorator，并实现IntervalSet接口。在PeriodicIntervalSet中添加一个属性period记录时间周期。 在重写的insert()方法中，将开始时间和结束时间对周期取模后再调用未重写的父类的insert()方法进行插入。 二、使用代理的方式进行是否允许时间轴上有空白这个维度的个性特征的设计。由于不允许空白相当于添加了新的方法，因此将这个特性抽象为一个接口NoBlankIntervalSet： 接口中包含三个方法：blankIntervals()返回所有的空白时间段集合；getStart-Time()返回总的开始时间；getEndTime()返回总的结束时间。 一个具体的不允许时间轴上有空白的IntervalSet只需要实现NoBlank-IntervalSet接口。具体实现类CommonNoBlankIntervalSet的实现如下： 属性startTime是总的开始时间，endTime是总的结束时间。blankIntervals()的实现如图，首先将空白时间段设置为整个时间段，然后遍历所有的时间段，将这些时间段从空白时间段中去除，最后得到的就是所有的空白时间段。 面向可复用性和可维护性的设计：MultiIntervalSet<L> MultiIntervalSet<L>的共性操作静态工厂方法empty()：创建一个空对象。MultiIntervalSet(IntervalSet<L>initial)：利用initial中包含的数据创建非空对象。voidinsert(longstart,longend,Llabel)：在当前对象中插入新的时间段和标签。Set<L>labels()：获得当前对象中的标签集合。booleanremove(Llabel)：从当前对象中移除某个标签所关联的所有时间段。IntervalSet<Integer>intervals(Llabel)：从当前对象中获取与某个标签所关联的所有时间段。 局部共性特征的设计方案 由于要求必须使用IntervalSet<L>作为其rep的一部分，因此选择IntervalSet<L>组成的List作为rep。一个IntervalSet中只存储某个标签对应的一个时间段，如果一个标签对应多个时间段，需要分散在不同的IntervalSet中。 对于empty()方法，直接返回一个具体实现类。 对于initial初始化方法，直接将传入的IntervalSet的副本作为rep的一个元素。 对于insert()方法，首先判断非法情况。之后遍历IntervalSet列表得到标签对应的所有时间段，判断已存在的时间段和要增加的时间段是否存在重叠，如果重叠则抛出异常；若不重叠，就寻找某个不存在该标签的IntervalSet，将这个时间段插入该IntervalSet，如果列表中所有的IntervalSet都包含该标签，就需要新建一个空白的IntervaSet加入列表，再进行插入。 对于labels()方法，可以直接返回第一个IntervalSet中的所有标签组成的集合。（因为插入时都是从头开始遍历的，因此不会存在某个标签出现在后面的IntervalSet而不在第一个IntervalSet中的情况） 对于remove()方法，直接对每个IntervalSet调用remove()方法即可。 对于intervals()方法，遍历IntervalSet列表得到标签对应的所有时间段，将时间段从小到大进行排序（前面time的实现中进行了说明）。然后将每个时间段以它的顺序作为标签插入到一个IntervalSet中并返回。 此外，还需要重写toString方法提供容易阅读的信息。 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案） 与3.2.3同理，使用decorator装饰器的方法进行是否允许不同的interval之间有重叠以及周期性的维度的个性特征的设计。向装饰器中传入待装饰的MultiIntervalSet，并在继承该装饰器的具体子类中实现相应的个性化功能。如下图，在装饰器MultiIntervalSetDecorator中有属性multiIntervalSet，是一个待装饰的MultiIntervalSet类，而MultiIntervalSetDecorator中的所有方法都调用multiIntervalSet的相应方法。 ①不允许重叠的MultiIntervalSet实现如下： 首先NoOverlapMultiIntervalSet继承装饰器MultiIntervalSetDecorator，并实现MultiIntervalSet接口。 在重写的insert()方法中，首先判断新添加的时间段是否与已添加的时间段发生重叠，如果有，直接抛出异常；否则就调用未重写的父类的insert()方法进行插入。 ②周期性的MultiIntervalSet实现如下： 首先PeriodicMultiIntervalSet继承装饰器MultiIntervalSetDecorator，并实现MultiIntervalSet接口。在PeriodicMultiIntervalSet中添加一个属性period记录时间周期。 在重写的insert()方法中，将开始时间和结束时间对周期取模后再调用未重写的父类的insert()方法进行插入。 面向复用的设计：L 设计三个应用的不同标签，分别为“员工”（Employee）、“进程”（Process）、 “课程”（Course）。并且它们都是immutable类。 ①对于Employee，具有的属性为：姓名、职务、手机号码。 除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：只有三个属性均相同时才认为是相同的。 ②对于Course，具有的属性为：课程ID、课程名称、教师名字、地点。 除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：只有四个属性均相同时才认为是相同的。 此外，Course类实现了Comparable接口，这是为了APP中显示课程顺序的合理性。 ③对于Process，具有的属性为：进程ID、进程名称、最短执行时间、最长执行时间。 除了相应的get方法之外，还需要重写equals()、hashCode()和toString()方法。equals()的判断依据是：进程ID相同时认为是相同的。 可复用API设计 计算相似度 对于两个MultiIntervalSet：s1和s2，遍历s1中的标签，查看s2中是否存在相同的标签，如果不存在，则对相似度没有贡献；如果存在，那么这个标签在s1和s2中各有一个时间段的集合，计算这两个时间段集合的重合长度，将所有的重合长度加在一起除以MultiIntervalSet的时间跨度就是两个MultiIntervalSet的相似度。 计算时间冲突比例 对于IntervalSet来说，由于它是一个特殊的MultiIntervalSet，因此可以把它转换成MultiIntervalSet后再调用针对MultiIntervalSet的计算时间冲突比例的函数。 对于MultiIntervalSet，维护一个冲突时间段的集合conflictTime，初始时为空。遍历set中的标签，判断该标签和其他标签的时间段是否存在重合，如果存在，就将冲突的时间段加入conflictTime。向conflictTime加入时间段也需要考虑重合的问题，集合中不能有重合的时间段，因此向conflictTime加入时间段时需要进行适当的合并。最后conflictTime中的时间长度除以总的时间跨度就是时间冲突比例。 计算空闲时间比例 对于IntervalSet来说，由于它是一个特殊的MultiIntervalSet，因此可以把它转换成MultiIntervalSet后再调用针对MultiIntervalSet的计算空闲时间比例的函数。 对于MultiIntervalSet，原理类似于3.2.3中的blankIntervals()方法。维护一个空闲时间段的集合freeTime，初始时为整个时间段。遍历set中的所有时间段，并将其从freeTime中删去。最后freeTime中的时间长度除以总的时间跨度就是空闲比例。 应用设计与开发 利用上述设计和实现的ADT，实现手册里要求的各项功能。 排班管理系统 使用DutyIntervalSet作为数据结构，同时维护一个Employee的集合可以存储未被安排的员工。刚进入时APP，会提示初始化一些信息，包括：排班开始日期、结束日期以及一组员工信息。初始化结束后，打印一个菜单，告诉用户提供的一些功能。 根据用户选择的功能采取相应的操作。其中选项1,2涉及对Employee集合的增删；3对应DutyIntervalSet的insert操作；4对应DutyIntervalSet的remove操作；5对应DutyIntervalSet的blankIntervals操作；7对应DutyIntervalSet的blankIntervals操作以及DutyIntervalSet的labels、start、end操作；8的操作见3.7节。由于这些操作都是简单地使用一些函数，因此不再详细叙述。这里只介绍“6：自动编排”的实现方法：首先调用DutyIntervalSet的blankIntervals操作得到未被安排的时间段，然后遍历Employee集合，找出未被安排的员工，将这些未被安排的时间段和员工一对一匹配起来，并调用insert方法插入到DutyIntervalSet中。 此外，APP还拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。举例来说，针对添加员工的操作，存在各种非法的输入情况，在APP中都得到了相应的解决，并提示给用户。 操作系统的进程调度管理系统 使用ProcessIntervalSet作为数据结构，同时维护一个的Map存储进程和已执行时间的映射关系。进入APP后，会打印一个菜单，告诉用户提供的一些功能。 根据用户选择的功能采取相应的操作。其中选项1,2涉及对Map的增删；5，6对应ProcessIntervalSet的intervals操作。由于这些操作都是简单地使用一些函数，因此不再详细叙述。这里介绍3,4的实现方法，选项3：从时间点0开始进入一个循环，当所有的进程都被执行完成后退出循环。在循环中，首先使用随机数（random.nextBoolean）决定是否调度进程，如果决定不调度进程，则闲置一段随机的时间（random.nextInt）；如果决定调度进程，则随机选择一个未完成的进程（使用随机数选择进程的序号）并执行一段随机的时间（random.nextInt），执行结束后，如果该进程的总执行时间已经落到最短执行时间和最长执行时间的区间内，则该进程被执行完成，然后从这个时间点开始进行下一轮的循环。选项4：和选项3唯一的不同在于进程的选择不是随机的，而是选择距离其最大执行时间差距最小的进程。 同样地，APP拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。 课表管理系统 使用CourseIntervalSet作为数据结构，同时维护一个Course的Map存储未被安排的课程以及对应的剩余学时数。刚进入时APP，会提示初始化一些信息，包括：学期开始日期、总周数、以及一组课程信息。初始化结束后，打印一个菜单，告诉用户提供的一些功能。 根据用户选择的功能采取相应的操作。其中选项1,2涉及对Course映射的增删；3对应CourseIntervalSet的insert操作；4对应CourseIntervalSet的remove操作；5对应对Course映射的遍历以及显示；6,7对应API中操作的使用；8对应CourseIntervalSet的intervals操作。由于这些操作都是简单地使用一些函数，因此不再详细叙述。 同样地，APP拥有很好的健壮性，能面对用户各种非法的、不符合格式的输入。 基于语法的数据读入 首先对文件的格式进行分析，文件总共包括三个部分，分别是Employee、Period和Roster，每个部分有自己独特的格式。在假设没有空格、缩进和空行的情况下，可以分别设计识别每个部分的正则表达式。 Employee部分的正则表达式： Period部分的正则表达式： Roster部分的正则表达式： 对于整个文件，由于三个部分出现的顺序是不定的，即共有六种情况，因此识别整个文件的正则表达式为： 首先利用这个正则表达式判断文件的格式是否正确，如果正确就抽取出每个部分。 利用Employee内部的格式抽取出员工信息： 利用Period的格式抽取出时间段信息： 利用Roster内部的格式抽取出排班信息： 根据抽取出的信息，就可以构造出一个排班表了，在构造的同时判断一些错误，如：员工信息重复、员工未定义、时间重叠等。 在APP中，读入用户指定的文件，并去除所有的空格、缩进、空行，之后调用Parser解析信息，在出现错误时提示给用户相应错误信息。 应对面临的新变化 变化1 修改之前的DutyIntervalSet实现的是IntervalSet接口，但是本次变化要求每个标签可以对应多个时间段，因此要求DutyIntervalSet实现MulitIntervalSet接口，同时还要保持不允许重叠的特征。因此只需要修改DutyIntervalSet继承的装饰器类型以及实现的接口类型即可。具体修改如图： 修改前的代码： 修改后的代码： 由于DutyIntervalSet从实现IntervalSet接口变为实现MulitIntervalSet接口，因此一些方法会发生变化，例如不再支持start()和end()方法，同时新增加了intervals()方法。因此，在DutyRosterApp需要修改相应的实现方法。举例来说，对于APP中的可视化排班信息的功能，需要遍历DutyIntervalSet中的信息，之前的遍历方式直接使用labels()方法： 但是，修改之后需要使用intervals()方法： 在其他地方也涉及这种变化，就不一一列举了。同时，需要修改测试代码保持测试的正确性。 除修改测试代码的变化，一共修改大约50行代码，花费时间较短，说明之前的设计较为合理，应对变化的能力比较强，可维护性很好。测试代码的修改大约也在50行左右。 变化2 由于使用了装饰器，只需要将原来传入装饰器的MultiIntervalSet改为不能重叠的NonOverlapMultiIntervalSet即可。如果不考虑测试代码的话，真正修改的代码只有一行！说明之前的设计较为合理，应对变化的能力比较强，可维护性很好。具体修改如图： 修改前的代码（传入可重叠的MultiIntervalSet）： 修改后的代码（传入不可重叠的NoOverlapMultiIntervalSet）： 为了使得测试仍然保持正确，需要修改原来的测试代码，总共修改的代码量大约为50行，花费时间较短。 Git仓库结构 请在完成全部实验要求之后，利用Gitlog指令或Git图形化客户端或GitHub上项目仓库的Insight页面，给出你的仓库到目前为止的ObjectGraph，尤其是区分清楚change分支和master分支所指向的位置。 使用gitlog指令，得到如下结果： 可以看出，Git仓库到目前为止的ObjectGraph有如下形式： 实验进度记录 请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。 每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。 不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。 日期时间段计划任务实际完成情况2021.6.2812:30-14:30设计IntervalSet接口并完成一个具体的实现类CommonIntervalSet，编写测试完成2021.6.2814:30-17:00设计MultiIntervalSet接口并完成具体的实现类CommonMultiIntervalSet，编写测试完成2021.6.2817:30-18:30设计IntervalSet和Common-MultiIntervalSet的装饰器完成2021.6.2818:30-19:30在有无空白的维度上，设计NoBlankIntervalSet接口并完成具体实现类CommonNoBlankIntervalSet，编写测试完成2021.6.2819:30-21:00在是否允许重叠的维度上，设计实现不允许重叠的装饰类NoOverlapIntervalSet和NoOverlap-MultiIntervalSet，编写测试完成2021.6.2821:30-22:30在周期性的维度上，设计实现周期性的装饰类PeriodicIntervalSet和PeriodicMultiIntervalSet，编写测试完成2021.6.299:00-10:00实现Employee、Process、Course类，编写测试完成2021.6.2910:00-12:30设计实现API，编写测试完成2021.6.2913:30-14:00实现DutyIntervalSet、Process-IntervalSet和CourseIntervalSet，编写测试完成2021.6.2914:00-17:30实现DutyRosterApp测试健壮性时发现很多不足，延期一小时完成2021.6.2919:00-22:00实现CourseScheduleApp测试健壮性时发现很多不足，延期半小时完成2021.6.309:00-12:00实现ProcessScheduleApp完成2021.6.3016:30-17:30学习正则表达式完成2021.6.3018:30-20:30设计实现解析器Parser，编写测试由于对正则表达式不太熟悉，延期半小时完成2021.6.3021:00-22:30向DutyRosterApp中加入解析文件功能完成2021.7.19:00-10:00完善整个项目的注释（spec、AF、RI、safefromexposure、teststrategy）完成2021.7.110:30-11:30修改代码以面对新的变化完成 实验过程中遇到的困难与解决途径 遇到的难点解决途径对装饰器不够熟悉，不知如何编写正确的装饰器以实现功能。在网上查看其它应用使用装饰器的方法并加以总结，逐渐熟悉装饰器的使用。编写APP时遇到很多的健壮性问题。仔细分析每个步骤中用户可能的所有输入，针对任何非法情况都作出提示。虽然很耗费时间，但效果很好。不知如何设计正则表达式来抽取大量的文件信息。在学习正则表达式语法的同时进行一些小的测试，从小的正则表达式开始，逐渐累积成复杂的正则表达式，最终实现对文件的解析。 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 设计ADT时一定要考虑得全面且清楚，在最终决定实现方案后再编写代码，否则在后面的应用实现中发现问题时只能再重新设计。同时，在编写APP时，一定要事先考虑健壮性的问题，不然，在编写完代码之后进行测试时会遇到很多的健壮性问题，这时再去修改就会使得代码很臃肿，可读性变差，出错的可能性更高。 针对以下方面的感受重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用，你是否体会到复用的好处？ 面向ADT的编程需要从实际中进行抽象，并进行合理的设计，有很好的可扩展性和可复用性；而直接面向应用场景编程只针对特定应用，每次更换应用场景时都要重新编程，扩展性很差，只适合简单的应用场景。本实验中设计一个ADT就可以应用到三个不同的场景，大大缩短了开发时间。 重新思考Lab2中的问题：为ADT撰写复杂的specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？ 这些工作使得客户端了解各方法的功能但无法得知内部具体实现，可以防止内部变量被客户端恶意修改，时刻检查表示不变量，保证安全性。虽然这些工作有些麻烦，但却是好的软件必须具备的，因此我愿意在以后编程中坚持这么做。同时，在复杂的软件开发过程中，好的注释可以节省大量阅读代码的时间，使得开发时间大大降低。 之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？ 由于API面向的场景是广泛的，因此开发难度很大，但是一旦开发一个好的API，就可以在大量场合中应用，大大提高代码的复用性。 你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？ 语法驱动编程为实际应用提供了很大的便利，用户无需繁琐地一行一行地输入信息，而只需提供一个文件以及一定的语法规则即可。而对于应用的开发者，只需根据语法规则编写代码，即使改变语法规则也可以很快地修改实现代码，有很好的可维护性。 Lab1和Lab2的大部分工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过五周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？ ADT的难度主要体现在抽象上。一个好的ADT既不能过于具体，也不能过于抽象。需要从大量应用场景中寻找共性，抽象的程度也很难把握。对于这种情况，只能反复的推敲，比较不同设计方案的差异并选择最好的ADT设计方案。 “抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的五个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？ 接口、抽象类、类的抽象程度一定是逐渐降低的，将所有应用的共性抽象为接口，然后在抽象类以及类中添加新的特性。通过接口的组合可以形成新的接口，并可以具备不同接口中的抽象。类的继承也可以增加更具体的新的特性。同时，使用正确的设计模式可以使得代码的可复用性和可维护性最大化。 关于本实验的工作量、难度、deadline。 难度适中，可以接受，但是工作量很大，尤其是APP的编写要花费很长时间。虽然给了三周时间，但是和其他课的实验、大作业、考试有重叠，总体上时间还是很紧。希望各课程的老师可以相互协调一下实验安排。 到目前为止你对《软件构造》课程的评价。 逐渐理解了软件构造过程中独有的思路和方法，也逐渐适应了与之前完全不同的编程过程。通过Lab3大量的代码训练，自己的编程水平也有了极大的提高。 
第95篇文章[0]
Integer的自动装箱与比较问题 问题引入 Java使用==进行引用的比较，使用equals进行对象的比较。在多数情况下，都是使用==比较基本数据类型，而使用equals比较对象类型。但Java又为每个基本数据类型建立了相应的包装类，这使得相等的比较稍微复杂了一些，其中涉及自动装箱与拆箱的问题。同时，Integer的缓存机制使得比较情况更加复杂。因此，在这里分析一下Integer的自动装箱与比较问题。 自动装箱 自动拆箱和自动装箱是java的语法糖之一，执行在编译期，会根据代码的语法决定是否进行拆箱和装箱动作。自动装箱使得定义基本数据类型的包装类时，可以直接使用=赋值，而不使用new，如： Integera=5; 在编译时，会根据这种语法，决定进行装箱操作，实际上执行的语句调用了Interger的静态方法： Integera=Integer.valueOf(128); 在任何时候，如果涉及到从基本数据类型到其包装类的转换，编译器都会决定进行自动装箱。比如： Map<String,Integer>map=newHashMap<>(); map.put("a",1); 由于map中值的类型为Integer，而put将int类型的值放到map中，自动装箱后的语句类似于： Map<String,Integer>map=newHashMap<>(); map.put("a",Integer.valueOf(1)); 自动拆箱 和自动装箱相反，如果将Integer类型的数据赋值给基本数据类型int，就会执行自动拆箱。如： Integera=newInteger(5); intb=a; 在编译时，会根据这种语法，决定进行拆箱操作，实际上执行的语句调用了a的intValue方法： Integera=newInteger(5); intb=a.intValue(); 当Integer类型的对象和基本数据类型进行算术或关系运算时，Integer对象也会自动拆箱，比如： Integera=newInteger(5); intb=6; Integerc=a+b; 当执行Integerc=a+b;时，编译器发现一个Integer类型和一个int类型进行算术运算，决定对Integer类型进行拆箱。a+b运算的结果实际上是int类型的，将结果赋值给c时又会进行装箱操作。 Integer的缓存机制 Integer的缓存机制使得比较问题更加复杂。上面说过，自动装箱时调用了Integer.valueOf()，这个函数的源码为： publicstaticIntegervalueOf(inti){ if(i>=IntegerCache.low&&i<=IntegerCache.high) returnIntegerCache.cache[i+(-IntegerCache.low)]; returnnewInteger(i); } 其中IntegerCache.low=-128，IntegerCache.high=127。这说明valueOf的参数如果介于-128和127之间的话，会返回IntegerCache中的对象，否则会重新new一个对象并返回。 Integer/int的比较 1.两个int类型进行比较，直接使用==就好了。 2.涉及Integer的比较，使用equals总不会出错。如果是两个Integer进行比较，equals当然比较的是各对象的值。如果是一个Integer和一个int比较，只能对Integer对象使用equals方法，这时会涉及自动装箱，比如： Integera=5; intb=5; a.equals(b); 最后一条语句会让b自动装箱，但是equals比较的始终是对象的值，因此不会有问题 3.涉及Integer的比较，如果使用==，情况会变得复杂。 如果是一个Integer和一个int比较，前面说过会进行自动拆箱，Integer对象会变为int类型，相当于两个int的==比较，没有问题。 如果是两个Integer进行比较，这里情况比较复杂。 (1)只要有一个Integer是通过new产生的，一定会得到false。因为new会在堆中分配内存，而==比较的是引用，也就是比较内存地址，只要不是别名引用，一定会得到false Integera=newInteger(5); Integerb=newInteger(5); Integerc=5; a==b//false a==c//false (2)两个Integer都是直接赋值产生的，只有被缓存时才能得到true。根据上面valueOf的源码可知，如果值落在-128~127之间，会返回IntegerCache中的对象，对于下面的代码，a和b都指向IntegerCache中的同一对象，因此==会得到true Integera=5; Integerb=5; a==b//true (3)两个Integer都是直接赋值产生的，但未缓存，会得到false。根据valueOf的源码，如果值不在-128~127之间，会返回new的对象，这时和(1)完全一样。对于下面的代码，a和b都是new出的对象，==会得到false Integera=128; Integerb=128; a==b//false 对于其他基本数据类型及其包装类，也涉及装箱、拆箱以及缓存的机制 包装类型基本数据类型缓存Booleanbooleantrue,falseBytebyte-128~127Shortshort-128~127Characterchar0~127Integerint-128~127Longlong-128~127Floatfloat无缓存Doubledouble无缓存 启示 可以看出比较的情况还是比较多的，但是如果只使用equals，就不会出现任何问题。因此涉及包装类对象之间值的比较，一定要用equals方法。这也是阿里Java开发手册编程规约中指出的：强制所有包装类对象之间值的比较，全部使用equals方法！ 
第96篇文章[0]
哈工大软件构造Lab2 2021年春季学期计算学部《软件构造》课程 Lab2实验报告 目录 1实验目标概述···1 2实验环境配置···1 3实验过程···2 3.1PoeticWalks·2 3.1.1GetthecodeandprepareGitrepository·2 3.1.2Problem1:TestGraph<String>·2 3.1.3Problem2:ImplementGraph<String>·3 3.1.3.1ImplementConcreteEdgesGraph·3 3.1.3.2ImplementConcreteVerticesGraph·5 3.1.4Problem3:ImplementgenericGraph<L>·7 3.1.4.1Maketheimplementationsgeneric·7 3.1.4.2ImplementGraph.empty()·7 3.1.5Problem4:Poeticwalks·8 3.1.5.1TestGraphPoet·8 3.1.5.2ImplementGraphPoet·8 3.1.5.3Graphpoetryslam··9 3.1.6使用Eclemma检查测试的代码覆盖度···9 3.1.7Beforeyou’redone·10 3.2Re-implementtheSocialNetworkinLab1·10 3.2.1FriendshipGraph类···11 3.2.2Person类···11 3.2.3客户端main()·11 3.2.4测试用例···12 3.2.5提交至Git仓库···12 4实验进度记录···13 5实验过程中遇到的困难与解决途径···13 6实验过程中收获的经验、教训、感想···13 6.1实验过程中收获的经验和教训···13 6.2针对以下方面的感受···14 实验目标概述 本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说： 针对给定的应用问题，从问题描述中识别所需的ADT；设计ADT规约（pre-condition、post-condition）并评估规约的质量；根据ADT的规约设计测试用例；ADT的泛型化；根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction）使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure）；测试ADT的实现并评估测试的覆盖度；使用ADT及其实现，为应用问题开发程序；在测试代码中，能够写出testingstrategy并据此设计测试用例。 实验环境配置 Eclipse和Git在上一次实验中已经配置好了。本次实验只需要在eclipse中配置EclEmma用来检查测试的代码覆盖度。在Help->EclipseMarketplace中查找EclEmma，发现最初安装Eclipse就已经默认安装EclEmma了。这样，本实验所需要的所有环境就都配置好了。 在这里给出你的GitHubLab2仓库的URL地址（Lab2-学号）。 https://github.com/ComputerScienceHIT/HIT-Lab2-1190200817 实验过程 请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。 PoeticWalks 任务要求实现两种不同形式的图，给出了一个图接口来规定图所包含的各种方法，两种不同的实现需要继承这个接口，实现给定方法，同时需要满足泛型要求。在完成了两种实现后，任选一种实现形式完成自动扩展诗歌的任务。 GetthecodeandprepareGitrepository 使用gitinit初始化一个本地仓库，通过gitclone将GitHub上的文件下载到这个仓库中。这时就可以利用IDE进行代码编写。每当认为某一处代码修改完成，可以让它成为一个新的版本时，利用gitadd添加相应代码，使用gitcommit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过gitpushoriginmaster将本地仓库push到GitHub上。 Problem1:TestGraph<String> 思路：对Graph<String>接口中的所有方法进行测试，设计相应的测试策略，按等价类划分的方法进行测试。 测试策略：（1）对add方法进行测试，等价类划分：加入的点已经存在于图中；加入的点不在图中。（2）对set方法进行测试，等价类划分：设置的边已经在图中，权值依次为大于零（即需要更新权值）、等于零（即删除该边）、小于零（是非法情况，不做任何操作）；设置的边不在图中，但顶点在图中，权值依次为大于零、等于零、小于零；设置的边的顶点不在图中，权值依次为大于零、等于零、小于零。（3）对remove方法进行测试，等价类划分：要删除的点在图中，但不关联边；要删除的点在图中，且关联边；要删除的点不在图中。（4）对vertices方法进行测试，等价类划分：点集为空；点集非空。（5）对sources方法进行测试，等价类划分：作为参数的顶点存在源点（返回非空）；作为参数的点不存在源点（返回为空）。（6）对targets方法进行测试，等价类划分同（5），即是否存在目标点。在对每一个方法进行测试时，同时需要考虑其他方法的影响，因此在每个测试中都会同时测试一些其他方法。 结果：在实现了两种形式的图之后，运行编写的junit测试用例，通过。 Problem2:ImplementGraph<String> ImplementConcreteEdgesGraph （1）设计Edge类：Edge类应该含有一条有向边的所有信息，即起点标签、终点标签以及权值。 关于Edge类的AF、RI和防止表示泄露的方式： Abstractionfunction：AF(source)=该边的起点、AF(target)=该边的终点、AF(weight)=该边的权值 Representationinvariant：source与target非空且weight为正数 Safetyfromrepexposure：将source,target,weight设置为private,外部无法直接引用 由于Edge需要是不可变类型，将起点标签、终点标签以及权值都设置为privatefinal，并且Edge类中的方法不能修改这些属性。Edge中的方法包括：getSource()：获得起点标签；getTarget()：获得终点标签；getWeight()：获得权值（由于int和顶点类型L都是不可变类型，因此正常返回不会影响其不可变性）；Edge()：构造方法；checkRep()：检查表示不变量；同时重写了hashCode、equals和toString用于Edge类型判断相等。 （2）测试Edge类：对Edge类除checkRep()外的所有方法进行测试，对于getSource()、getTarget()、getWeight()、toString()、hashCode()，都是简单的返回结果，不存在特殊情况，无需划分等价类，对每个方法进行一次测试即可。对于equals()方法，只要划分成两个Edge实例相等和不相等两种情况。 （3）利用Edge实现ConcreteEdgesGraph： 关于ConcreteEdgesGraph类的AF、RI和防止表示泄露的方式： Abstractionfunction：AF(vertices)={vertex|vertexinvertices}、AF(edges)= {edges[i]|0<=i<edges.sizes()} Representationinvariant：edges中每条边满足长度大于零；起点终点都在vertices中；以一个点为起点另一个点为终点最多只有一条边(边不能重复) Safetyfromrepexposure：将vertices和edges设置为private,外部无法直接引用、返回vertices时进行防御式拷贝 各方法的实现思路如下： 方法名实现思路add()判断要加入的顶点是否已经存在于vertices集合，若存在，直接返回false；不存在则向vertices中添加顶点，返回trueset()参数source、target、weight，在edges中寻找是否有以source为起点、target为终点的边。若有，则记录权值并将这条边删去，当weight大于零时重新添加新边；若没有，判断weight的值，若weight大于零，则添加新边，同时可能需要向vertices添加新顶点，否则不做操作。最后，如果之前记录过权值，就将其返回，权值为负时返回-1，其他情况都返回0.remove()首先判断要删除的点是否在点集vertices中，如果不在，不做任何操作并返回false。若存在，在点集中将该点删除，同时遍历所有的边，只要某条边的起点或终点是要删除的点，就将这条边从edges中删除，最后返回true。vertices()返回vertices的一份不可修改的拷贝。sources()遍历所有的边，如果某条边的终点是输入参数，就将其放进结果映射中，最后返回结果映射。targets()遍历所有的边，如果某条边的起点是输入参数，就将其放进结果映射中，最后返回结果映射。toString()依次遍历点集vertices和边集edges，将所有信息组合成字符串，格式为”Vertices:…,Edges:…” （4）实现后，利用继承自GraphInstanceTest的ConcreteEdgesGraph进行测试，测试通过。 ImplementConcreteVerticesGraph （1）设计Vertex类：Vertex类应该含有与一个顶点有关的所有信息，即一个Vertex实例相当于一个邻接表。因此属性包括顶点的标签vertex和表示邻接关系的映射adjacent（其中adjacent的键是终点，值是这条边的权值）。为了避免表示泄露，使用privatefinal修饰这两个属性。 关于Vertex类的AF、RI和防止表示泄露的方式： Abstractionfunction：AF(vertex)=顶点的标签、AF(adjacent)=以该点为起点的所有边的集合 Representationinvariant:vertex非空且每个边的权值大于0 Safetyfromrepexposure：将vertex和adjacent设置为private，外部无法直接引用、返回adjacent时进行防御式拷贝 Vertex中的方法包括：getVertex()：获得顶点标签；getAdjacent()：获得邻接表；set()：改变邻接表中的某个条目，与Graph中的set相对应；remove()：删除邻接表中的某个条目，与Graph中的remove相对应；Vertex()：构造方法；checkRep()：检查表示不变量；同时重写了hashCode、equals和toString用于判断相等。Vertex类型是可变的，因为set()方法和remove()方法都会改变Vertex内部的属性值。 （2）测试Vertex类：对Vertex类除checkRep()外的所有方法进行测试。其中getVertex()只是简单地获得标签，无需划分等价类；getAdjacent()划分为邻接表空/非空两种情况；equals()划分为两个Vertex实例相等/不相等；toString()划分为邻接表空/非空两种情况；测试set()、remove()方法的策略和GraphInstanceTest中对set()、remove()的测试策略一致，详见3.1.2. （3）利用Vertex实现ConcreteVerticesGraph： 关于ConcreteVerticesGraph类的AF、RI和防止表示泄露的方式： Abstractionfunction：AF(vertices)={vertices[i]|0<=i<vertices.sizes()} Representationinvariant：vertices中不能有重复顶点 Safetyfromrepexposure：将vertices设置为private,外部无法直接引用 各方法的实现思路如下： 方法名实现思路add()判断要加入的顶点是否是vertices中某个Vertex实例的标签，若不是，直接返回false；否则以输入参数为标签新建一个Vertex并加入vertices，返回trueset()参数source、target、weight，在vertices中寻找是否有以source为标签的Vertex实例。若有，继续在其邻接表中寻找是否存在一个键是target，存在则记录权值，当weight>0时更新，weight=0时删除，weight<0时不操作；否则在weight大于零时添加新边。若没有，只有在weight>0时新建一个以source为标签的Vertex并加入vertices中，同时添加一条新边。只有在之前记录权值的情况下返回权值，权值为负时直接返回-1，其他情况均返回零。remove()首先判断要删除的点是否是vertices中某个Vertex实例的标签，如果不是，不做任何操作并返回false。若是，在vertices中将该点删除。同时遍历vertices中所有的Vertex实例，删除其邻接表中关于要删除边的信息，最后返回true。vertices()遍历vertices，将每个点的标签加入返回集合即可。sources()遍历所有顶点，如果其邻接表中有终点的信息，就将其放进结果映射中，最后返回结果映射。targets()如果源点存在，返回源点的邻接表的一份不可修改拷贝；否则返回一个空映射。toString()依次遍历点集vertices和边集edges，将所有信息组合成字符串，格式为”Vertices:…,Edges:…” （4）实现后，利用继承自GraphInstanceTest的ConcreteVerticesGraph进行测试，测试通过。 Problem3:ImplementgenericGraph<L> Maketheimplementationsgeneric 由于在针对String类型实现Graph时没有用到String类的特殊性质，所有相等的比较都是用equals实现，所有转化为字符串都是用toString实现，也没有用到String可比较的性质。因此，可以直接将刚才针对String类实现的ConcreteEdgesGraph和ConcreteVerticesGraph中的所有String更换为L即可。同时，Edge类和Vertex类也需要使用泛型，将其中所有的String改为L。在GraphStaticTest测试程序中，用和3.1.2中相同的测试策略，测试了泛型为Integer的情况，测试通过。 ImplementGraph.empty() 在Graph.empty()中，只需返回一个具体的Graph实例即可，可以在ConcreteEdgesGraph和ConcreteVerticesGraph任选其一。我选择了ConcreteVerticesGraph。 综上，关于Graph的实现全部完成，所有测试都顺利通过。 Problem4:Poeticwalks 任务要求利用之前实现的图，将语料库文件转化为一种图结构，并且根据输入的字符串在图中搜索可以插入的单词，完成诗句的扩展。 TestGraphPoet 对GraphPoet中的所有方法进行测试。GraphPoet中只有两个方法，构造方法GraphPoet()和产生诗的poem()。使用按等价类划分的方法对每个方法进行测试。 测试策略：（1）对构造方法，功能是读入语料库文件并产生相应的图。按照文件的形式划分等价类：文件为空；文件只有一行，且分隔符都是单个空格；文件有一行，但分隔符可能是连续空格；文件有多行但不存在空行；文件存在空行。针对以上情况设计语料库文件形式，测试是否能够正确生成相应的图结构。（2）对于poem()方法。按照输入字符串的形式和扩展形式划分等价类：输入字符串是空串；输入字符串存在连续空格；扩展后未插入单词；插入单词的过程中不存在比较行为；插入单词的过程中存在比较行为，测试是否能够正确扩展诗句。 ImplementGraphPoet 构造函数的实现：每次从文件中读入一行，用.split(“\\s+”)将读入的文本分割成单词，同时将所有单词转化为小写。对于分割后String数组中的每一个字符串，从它到它之后的字符串的边的权重加一，可以通过使用两个set()完成。 同时需要注意保留行尾的字符串，它到下一行第一个单词的边的权重需要加一。此外还要特别考虑空行的情况。 poem()函数的实现：先将输入字符串用.split(“\\s+”)分隔成单词，从前向后依次遍历两个单词，对前面的单词调用targets()得到它所有指向的顶点，对后面的单词调用sources()得到所有指向它的顶点。得到的两个结果的交集就是这两个单词的所有中间顶点，找到使得两条边权值和最大的顶点就是需要插入的顶点。维护一个List按顺序保存结果字符串中的每一个单词，每得到一个要插入的顶点，就将其对应的单词加到List中，每次循环最后将后面的单词也加入List中。循环结束时，List保存的就是结果字符串中的每个单词，将它们连接起来，中间由单个空格分隔就得到扩展后的字符串。 使用前面设计的测试用例测试，通过。 Graphpoetryslam 语料库内容如下： 扩展代码： 扩展结果： 使用Eclemma检查测试的代码覆盖度 除GraphPoet和FriendshipGraph中的main函数没有覆盖，其他基本都覆盖到了。 Beforeyou’redone 通过Git提交当前版本到GitHub上你的Lab2仓库：先使用gitstatus确定未被添加的代码；再使用gitadd添加相应代码；使用gitcommit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过gitpushoriginmaster将本地仓库push到GitHub上。 在这里给出你的项目的目录结构树状示意图。（Eclipse中显示的项目目录结构） Re-implementtheSocialNetworkinLab1 利用之前实现好的Graph<L>，重新实现Lab1中的SocialNetWork，并且要尽可能复用已经实现的add()和set()方法，并能和之前一样通过测试。这让我们体会到实现好一个类型对之后的工作有很大的简化。 FriendshipGraph类 使用ConcreteVerticesGraph<Person>作为FriendshipGraph中的图结构，并且用privatefinal修饰，避免表示泄露。 addVertex()方法直接使用Graph中的add()方法实现： addEdge()方法直接使用Graph中的set()方法实现，由于此题不带权，因此权值均设置为1： getDistance()没有太大变化，和之前一样利用广度优先搜索实现。 Person类 由于使用ConcreteVerticesGraph<Person>实现，要求Person是不可变类型，定义Person的属性只有一个，即名字字符串，同时用privatefinal修饰。 关于Vertex类的AF、RI和防止表示泄露的方式： Abstractionfunction：AF(name)=这个人的名字 Representationinvariant：名字不能为null Safetyfromrepexposure：将name设置为private,外部无法引用 Person类的方法包括：checkRep()检查表示不变量；getName()获得名字；Person()构造方法；重写的hashCode()、equals()、toString()使得便于判断重复；同时实现了compareTo()方法使得Person类是可比较的。可以发现，所有方法都无法更改Person内部的属性，因此Person类是不可变的。 客户端main() 客户端代码已经在Lab1中给出： 测试用例 对FriendshipGraph中的所有方法进行测试。使用按等价类划分的方法对每个方法进行测试。 测试策略：（1）对于addVertex()方法，测试添加重复的人和不重复的人的情况；（2）对于addEdge()方法，测试三种情况：添加朋友关系的人不在图中；添加自己到自己的朋友关系；正常添加朋友；（3）对于getDistance()测试三种情况：没有朋友关系的两个人之间的距离；有朋友关系的两个人之间的距离；自己到自己的距离。 使用按照测试策略设计的测试用例测试，通过。 提交至Git仓库 通过Git提交当前版本到GitHub上你的Lab2仓库：先使用gitstatus确定未被添加的代码；再使用gitadd添加相应代码；使用gitcommit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过gitpushoriginmaster将本地仓库push到GitHub上。 项目的目录结构树状示意图见3.1.7 实验进度记录 请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。 日期时间段计划任务实际完成情况2021.5.2118:30-20:30设计GraphInstanceTest中的测试用例完成2021.5.2219:30-22:00实现ConcreteEdgesGraph<String>并进行测试完成2021.5.2318:30-21:00实现ConcreteVerticesGraph<String>并进行测试完成2021.5.2321:00-21:30将特定类型转换为泛型发现前面实现中的问题并进行了修改，延期一小时完成2021.5.2420:00-22:30设计GraphPoet测试用例并实现GraphPoet，进行测试完成2021.5.2510:00-11:30利用ConcreteVerticesGraph重新实现之前的FriendshipGraph并进行测试完成 实验过程中遇到的困难与解决途径 遇到的难点解决途径撰写AF,RI,Safetyfromrepexposure时不知道从何写起 查看PPT中的示例以及在网上查找相关的示例理解撰写思路和方法，并逐渐掌握了撰写方法。测试用例覆盖的情况不全面 仔细地设计测试用例，尽可能覆盖等价类中所有的情况。 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 在实现使用泛型的类时，一定要事先完整地想好各个功能如何实现，特别是每个方法都要满足所有可能的类型，要特别小心不要利用某些类特有的性质。比如，在实现泛型为String的特殊情况时，使用了compareTo方法，这个方法不是所有类都有的，扩展到泛型时会产生错误，需要重新设计方法的实现。 针对以下方面的感受面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？ 面向ADT的编程需要从实际中进行抽象，并进行合理的设计，有很好的可扩展性和可复用性；而直接面向应用场景编程只针对特定应用，每次更换应用场景时都要重新编程，扩展性很差，只适合简单的应用场景。 使用泛型和不使用泛型的编程，对你来说有何差异？ 使用泛型能够扩展应用范围，可以适用于不同的类，能够很好地应对变化，并且能提高可复用性。但使用泛型也使得功能的实现更加困难，必须考虑可能的所有类型，不能依赖任何特定类型，需要更全面细致的考虑。 在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？ 这使得测试时不需考虑方法的实际实现，不会让测试过度依赖具体的实现方法，这也体现了测试优先编程的优势，可以更加容易地发现错误，保证测试的有效性。我也在逐渐适应这种测试优先的编程方法，也体会到这种方法确实很有效。 P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？ 可以提高代码的可复用性，减少大量重复的工作。 P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？ 正在逐渐适应从具体应用场景到ADT的“抽象映射”，并逐渐掌握抽象的方法。在P3自主设计时，仍然需要参考P1给出的逻辑关系，仿照P1进行设计，我也在自主设计的过程中逐渐掌握设计思路和方法，并尽可能地进行独立设计。 为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？ 这些工作使得客户端了解各方法的功能但无法得知内部具体实现，同时可以防止内部变量被客户端恶意修改。时刻检查表示不变量，可以更好地保证代码的正确和安全。虽然这些工作有些麻烦，但却是好的软件必须具备的，因此我愿意在以后编程中坚持这么做。 关于本实验的工作量、难度、deadline。 工作量不大，难度不太大，但是撰写specification,invariants,RI,AF以及testingstrategy会使用较长时间。deadline很合适，给了三周时间，完全可以完成。 《软件构造》课程进展到目前，你对该课程有何体会和建议？ 逐渐理解了软件构造过程中独有的思路和方法，也逐渐适应了与之前完全不同的编程过程。建议实验内容还是翻译成中文，有些英文读起来会有歧义。 
第97篇文章[0]
Java继承问题以及子类转换为父类时调用方法及属性的情况 1.方法的继承 子类可以继承父类的非private方法。 classparent{ publicvoidpnp(){ System.out.println("Parent"); } } classchildextendsparent{ } childc=newchild(); c.pnp(); 输出结果为Parent. 子类可以重写父类的非private方法。 classparent{ publicvoidpnp(){ System.out.println("Parent"); } } classchildextendsparent{ @Override publicvoidpnp(){ System.out.println("Child"); } } 这时，输出结果为Child 对于父类的private方法，子类是不可见的，尝试调用父类的private方法会导致静态检查直接报错。 当然，子类中也可以添加自己独特的新方法。如果子类中写了一个和父类某个private方法一样的方法，这不能算重写，应该也算添加新方法。 2.属性的继承 属性的继承和方法的继承类似，子类可以继承父类的非private属性。父子类定义如下： classparent{ intnp=0; } classchildextendsparent{ } 子类child可以访问np属性，在main中进行测试，输出结果为0. childch=newchild(); System.out.println(ch.np); 当然，类似于方法的重写，子类也可以覆盖掉父类的属性。 classparent{ intnp=0; } classchildextendsparent{ intnp=1; } 测试代码和上面一样，输出结果为1. 当子类试图访问父类的private属性时，静态检查会直接报错。 子类中也可以添加自己独特的新属性。 3.方法与属性混合的情况 如果方法是从父类继承的，那么方法中使用到的属性都是父类的属性。 classparent{ intnp=0; publicvoidpnp(){ System.out.println(np); } } classchildextendsparent{ intnp=1; } childch=newchild(); ch.pnp(); 在main中测试，输出结果是0.即使子类中已经覆盖了属性np，但是方法的行为仍然和父类一致，这时就不能简单地看代码的逻辑了。如果子类想按照代码的逻辑实现功能的话就只能重写，而重写的代码和之前一模一样。 classparent{ intnp=0; publicvoidpnp(){ System.out.println(np); } } classchildextendsparent{ intnp=1; @Override publicvoidpnp(){ System.out.println(np); } } 这时测试输出结果为1. 然而对于方法内部再次调用方法的情况，却正好相反。如果从父类继承来的方法A调用了方法B，并且子类重写了方法B，当子类调用方法A时，方法A内部会调用被重写的方法B. classparent{ publicvoidA(){ B(); } publicvoidB(){ System.out.println("Origin"); } } classchildextendsparent{ publicvoidB(){ System.out.println("Override"); } } 子类调用A()时会输出Override。 4.子类转换为父类时，调用方法及属性的情况 显然的是，当子类转换为父类后，只能调用父类中存在的方法、访问父类中存在的属性。 当访问属性时，属性的值是父类中的值。 classparent{ intnp=0; } classchildextendsparent{ intnp=1; } parentc=newchild(); System.out.println(c.np); 输出结果为0. 而调用的方法应该是子类中的方法。 如果方法被重写，调用的方法就是子类中被重写的方法。 classparent{ publicvoidA(){ System.out.println("Origin"); } } classchildextendsparent{ @Override publicvoidA(){ System.out.println("Override"); } } parentc=newchild(); c.A(); 输出结果为Override。 如果方法没有被重写，调用的方法就是父类中的方法。 classparent{ publicvoidA(){ System.out.println("Origin"); } } classchildextendsparent{ } parentc=newchild(); c.A(); 输出结果为Origin。 如果调用的方法中访问了某个属性或者又调用了其他方法时，会遵循3中给出的分析。 简单总结一下 对于属性的访问，在运行前就会确定，因此只看当前的类型，当前的类型是什么就访问这个类型中定义的属性；而对方法的调用在运行时才会确定，要看原本的类型（即new的时候的类型），按照这个类型调用相应方法。而方法内部如果访问了属性，这个属性是定义该方法的那个类型中的属性；方法内部如果调用了其他方法，被调用的方法仍然是这个类型中的方法，当然，也存在嵌套的情况。 
第98篇文章[0]
哈工大软件构造Lab1 Lab1实验报告 1实验目标概述 1 2实验环境配置 1 3实验过程 2 3.1MagicSquares.2 3.1.1isLegalMagicSquare().2 3.1.2generateMagicSquare().3 3.2TurtleGraphics.5 3.2.1Problem1:Cloneandimport5 3.2.2Problem3:TurtlegraphicsanddrawSquare.5 3.2.3Problem5:Drawingpolygons.6 3.2.4Problem6:CalculatingBearings.7 3.2.5Problem7:ConvexHulls.8 3.2.6Problem8:Personalart9 3.2.7Submitting.10 3.3SocialNetwork.10 3.3.1设计/实现FriendshipGraph类 10 3.3.2设计/实现Person类 12 3.3.3设计/实现客户端代码main().13 3.3.4设计/实现测试用例 13 4实验进度记录 15 5实验过程中遇到的困难与解决途径 16 6实验过程中收获的经验、教训、感想 16 6.1实验过程中收获的经验和教训 16 6.2针对以下方面的感受 16 实验目标概述 本次实验通过求解三个问题，训练基本Java编程技能，能够利用JavaOO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。 ⚫基本的JavaOO编程 ⚫基于EclipseIDE进行Java编程 ⚫基于JUnit的测试 ⚫基于Git的代码配置管理。 实验环境配置 在官网下载安装JDK，根据网上的步骤配置环境变量。 在官网下载安装Eclipse，设置JRE以及其他preferences。新建一个Workspace，建立项目、包以及java源代码，Eclipse配置成功的结果如图。 在官网下载Git并安装，设置用户名、邮箱等信息，Git配置成功的结果如图。 GitHubLab1仓库的URL地址：https://github.com/ComputerScienceHIT/HIT-Lab1-1190200817。 实验过程 请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。 为了条理清晰，可根据需要在各节增加三级标题。 MagicSquares 主要任务：从txt文件中解析数据，并判断数据是否构成一个幻方，通过5个文件进行测试。同时阅读和改进产生幻方的代码，并进行测试。 isLegalMagicSquare() 首先，需要从txt文件中读出数据，读txt文件可以使用固定的格式，即使用BufferedReader并用try-resource语句处理异常。 利用BufferedReader，每次可以从文件中读入一行字符串。由于txt文件以’\t’分隔数据的，用String类的split方法可以将读入的字符串以’\t’分隔，得到字符串数组，每个字符串数组都代表一个数。使用Integer.valueOf将分隔后的每个字符串解析为数字，同时需要捕获异常识别非法数据。 所有数据都存在二维ArrayList中，获得每一行数据的个数以及总行数，判断是否为n*n的矩阵。分别计算每行、每列以及两个对角线上的数字之和，比较是否相等，并返回结果。如果出现各种特殊情况，输出错误提示信息并返回。 generateMagicSquare() 阅读generateMagicSquare()的代码，可以看出它是将1到n2 填充到一个n*n 的幻方中，这种方法是常用的填充幻方的方法。程序的流程图如下： 但是，这种方法只能填充n 为奇数时的幻方。当n 为偶数时，函数产生异常java.lang.ArrayIndexOutOfBoundsException即填充过程中在row++时发生数组越界访问。并且当n 是负数时，不能有效处理非法输入，产生异常java.lang.NegativeArraySizeException即初始化了行列数为负数的数组。这导致了很差的健壮性。修改这个函数，当输入不合法时提示错误并退出。 同时，当输入合法时，增加将结果写入文件的功能。和之前类似，使用BufferedWriter将数据写入文件。 利用前面的isLegalMagicSquare()函数，可以判断生成的文本文件确实符合MagicSquare。 TurtleGraphics 主要任务：根据函数的注释补全代码，实现一系列绘图可能用到的功能。包括画出正方形、计算正多边形的内角、计算对应内角的正多边形边数、计算绘图时的角度转移、计算凸包、以及绘制自己独特的图形。 Problem1:Cloneandimport 使用gitinit初始化一个本地仓库，通过gitclone将GitHub上的文件下载到这个仓库中。这时就可以利用IDE进行代码编写。每当认为某一个代码改进完成，可以让它成为一个新的版本时，利用gitadd添加相应代码，使用gitcommit将本地文件加入到本地仓库。当所有的代码都修改完毕，通过gitpushoriginmaster将本地仓库push到GitHub上。 Problem3:TurtlegraphicsanddrawSquare 绘制图形时要用到两个函数：forward和turn，分别实现前进和转向。绘制正方形时，只需要每次前进给定长度，然后转向90°，循环四次即可。 代码： 结果： Problem5:Drawingpolygons 对于给定边数的正多边形，需要计算内角的度数来确定每次转向的度数。实现calculateRegularPolygonAngle()函数确定给定边数的正多边形的内角度数。直接通过公式可求出。 和上面一样，每次前进给定长度，转向的角度为外角的度数，循环次数为边数。 代码： 结果（以正六边形为例）： 最后还要实现给定内角度数，确定正多边形边数的函数。直接通过公式可求出。注意最后要将结果四舍五入才能返回整数。 Problem6:CalculatingBearings 实现函数calculateBearingToPoint()以满足已知起点、终点和当前朝向时，应该转向的角度。计算起点和终点所连直线的斜率，利用atan函数得到最终的朝向的角度，它和当前朝向的差值就是需要转过的角度。 通过调用calculateBearingToPoint()函数就可以计算经过一系列点时每次要转向的角度，进而实现calculateBearings()。已知初始朝向，按顺序在列表中取出两个点，调用calculateBearingToPoint()就可以得到这两个点之间需要转过的角。修改当前朝向为转向之后的角度，就可以进行下一次计算。需要注意，更新当前朝向后，如果角度超过360°，需要减去360°。 Problem7:ConvexHulls 使用安德鲁算法求解凸包。首先判断特殊情况，如果顶点数小于等于2时，这些点都会是凸包中的，直接返回原点集。找到所有点中横坐标最大的点，有多个则选择纵坐标最小的点，把它作为基准点，这个点一定在凸包中。其他的点和这个点的连线与y轴正半轴存在夹角，按照夹角从小到大对其他顶点排序。维护一个栈，首先将基准点入栈。按顺序从排好序的顶点中取出一个，如果栈中的点数大于2，就取出栈顶的两个点。通过计算向量的内积判断栈顶的点是否应该在凸包中，如果不在，将栈顶的点弹出，继续判断；如果在，将取出的顶点入栈。如果栈中的点数小于2，直接将取出的顶点入栈。最后，栈中的点就是凸包中的点。代码如下： 对于以上实现的代码，都通过了测试程序的测试。 Problem8:Personalart 利用while循环绘制一个雪花图形，通过递推确定每次要转向的角度。 代码： 结果： Submitting 当所有代码都修改完成并确认无误后，利用gitadd添加修改过的代码文件，使用gitcommit将本地文件加入到本地仓库，同时可以标注版本信息。通过gitpushoriginmaster将本地仓库push到GitHub上，在GitHub上可以看到push之后的文件。 SocialNetwork 主要任务：设计Person类和FriendshipGraph类来模拟一个社交网络，并实现社交网络中需要的一些简单功能，包括添加人、添加社交关系以及计算两个人之间的距离。同时，编写测试程序来检查实现的正确性。 设计/实现FriendshipGraph类 社交网络是一个图模型，FriendshipGraph类中要存储一个图，并且要支持各种功能。我在FriendshipGraph类中只存储图的顶点，而顶点之间的关系和某一个人有关，因此存储在Person类中。FriendshipGraph类的属性只有privateHashSet<Person>vertex用来存储图的顶点，方法包括构造方法、private变量的getter和setter以及一些简单的功能addVertex(),addEdge(),getDistance()。另外，由于名字是Person的属性，因此判断名字是否重复交给Person类实现。 addVertex()向vertex集合中添加顶点，addEdge()在Person类的朋友集合中添加新的朋友，getDistance()利用广度优先搜索计算两个Person之间的最近距离。同时，在函数中判断一些非法情况。具体代码如下： 属性 构造函数 getter和setter addVertex() addEdge() getDistance() 设计/实现Person类 Person类是对人的抽象，属性包括自己的名字和朋友集合。方法包括：内部private属性的getter和setter，构造函数，以及添加朋友的addFriend()。同时，为了判断重名，在Person类中重写hashCode()、equals()和toString()方法，使得每个Person实例有不同的名字，如果有两个同名Person添加到社交网络的集合中，集合只会保留一个。具体代码如下： 属性 addFrined() 构造函数 Getter和setter 重写的hashCode,equals,toString 设计/实现客户端代码main() 按照给定的客户端代码实现。 设计/实现测试用例 对于addVertex()的测试：当调用addVertex()后，测试FriendshipGraph类中顶点集合vertex的大小。如果添加的人不重复，大小会加一，否则不变。 当addVertex()添加人的名字重复时，程序会输出提示信息并退出。因此测试程序退出时的输出内容是否正确（在网上查阅资料得知，需要添加额外的代码以测试调用System.exit()的情况）。 对于addEdge()的测试：当调用addEdge()后，测试添加朋友的Person类中朋友集合friend的大小。addEdge()两个参数对应的Person类中的friend集合大小都会加一。 对于getDistance()的测试：建立一个社交网络，测试函数返回的结果和实际结果是否相同，需要覆盖距离是-1、0以及大于0的情况。 测试结果： 实验进度记录 日期时间段任务实际完成情况2021-05-0620:30-21:30编写SocialNetwork问题中的FriendshipGraph类和Person类并在main函数中进行测试按计划完成2021-05-0718:30-19:30编写isLegalMagicSquare()函数，并用1.txt~5.txt文件中的数据进行测试延期10分钟完成2021-05-0720:30-21:30分析generateMagicSquare()函数的功能并进行修改，用其产生的MagicSquare测试isLegalMagicSquare()函数按计划完成2021-05-0814:00-17:00完成TurtleGraphics问题中的所有任务按计划完成2021-05-0918:30-19:00设计并编写addVertex(),addEdge()和getDistance()的单元测试按计划完成2021-05-1113:45-15:00使用Git管理仓库并push到GitHub延期20分钟完成 实验过程中遇到的困难与解决途径 遇到的困难解决途径用Git管理时无法合并到master分支 查阅资料，发现命令行参数存在问题，修改后成功。 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 本次实验初次接触软件构造，在实验中，我明白了软件构造的基本流程，并且更加熟练地掌握Java语言。同时，对Git的学习和使用也让我懂得了软件管理的重要性。获得了一些使用Git和本地IDE进行软件构造的经验。同时，也获得了一些教训，一定要在编写代码之前考虑好类的构造，属性、方法的定义以及使用的数据结构，否则一旦出错可能需要重头再来；同时，在设计之前也要平衡不同的质量目标，不至于在代码编写结束后再耗费很大功夫重新修改。 针对以下方面的感受Java编程语言是否对你的口味？ 是，面向对象的语言会更容易编写，同时Java也包含了更多常用的数据结构和函数，可以节省编写代码的工作量。 关于EclipseIDE； Eclipse集成开发环境功能很强大，使得编写程序更加容易。 关于Git和GitHub； 虽然Git的指令有些难搞懂，但是用它管理项目是很方便的。GitHub上的资源很多，功能也很强，但就是访问速度太慢了。 关于CMU和MIT的作业； 难度适合，也让我们可以与国外名校接轨。 关于本实验的工作量、难度、deadline； 难度不大，但是工作有些繁琐，但deadline设置比较合理，可以按时完成。 关于初接触“软件构造”课程； 初次做软件构造的实验，我认为可以通过这个课程提升自己的编程能力并且培养一种全局观念，同时可以获得更多不同的能力。 
第99篇文章[0]
接口中的default方法 复习的时候看到了interface还可以用default声明方法，学习了一下。Java8接口中也允许使用default关键字来定义并实现实例方法，这个应用有点类似于抽象类的功能。 通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它。上一个小例子： packageexample; interfaceIntefercaeExample{ defaultvoidshowDefault(){ System.out.println("hello"); } staticvoidshowStatic(){ System.out.println("haha"); } //没有实现的抽象方法 voidsayHi(); } classSometryimplementsIntefercaeExample{ @Override publicvoidsayHi(){ System.out.println("Hi"); } publicstaticvoidmain(String[]args){ IntefercaeExample.showStatic(); SometrylearnDefault=newSometry(); //被Default所修饰的具体方法可以通过引用变量来调用 learnDefault.showDefault(); learnDefault.sayHi(); } } 输出结果： 
第100篇文章[0]
正则表达式笔记 基本语法跟形式语言课程中学的差不多，但java正则表达式的符号数量远远多于+，*，和连接。符号表网上可查，比较常用的有 （图片资源来源网络） 但实验中出现了一种特殊符号，好像是中文空格，它无法用\s识别，只能复制粘贴到正则表达式中，所以一定要注意文件格式和其中的缩进形式。 根据JavaLanguageSpecification的要求，Java源代码的字符串中的反斜线被解释为Unicode转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被Java字节码编译器解释。不加\\有时编译器会报错，有时不会报错，这种情况下一定要注意，否则又浪费半天。 
第101篇文章[0]
lab3中去除读进来的文件缩进的方法 首先，因为我先把整个文件用BufferReader给读成了一个String类型的量，因为String类型是immutable的，所以要新建一个String类型的临时变量来记录改变以后的内容；然后再用最笨的方法:String.replaceAll(""，""); 方法比较笨，但还是先记录在学习；代码就一句： Stringnewfile=fileentry.replace("\n","").replace("\r","").replace(" ","").replace("",""); （真不是在这水文章，这个当时的确调了一会，才把所有缩进都去掉） 
第102篇文章[0]
JUnit5中测试异常抛出的方法 根据JUnit文档（http://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions）: importstaticorg.junit.jupiter.api.Assertions.assertThrows;   @Test voidexceptionTesting(){ ExecutableclosureContainingCodeToTest=()->thrownewIllegalArgumentException("amessage"); assertThrows(IllegalArgumentException.class,closureContainingCodeToTest,"amessage"); } 说实话我没太明白什么个原理，先码后了解 
第103篇文章[0]
java自定义异常类 java可以通过继承Exception的手段来进行自定义的异常类 publicclassIntervalConflictExceptionextendsException{//自定义的异常类 /** *Makeanewintervalconflictexceptionwiththegivendetailmessage *@parammessagethedetailmessage */ publicIntervalConflictException(Stringmessage){ super(message); } } 但只是这么写Eclipse会有warning存在，warning内容如下： 出现这个warning的原因是：只要任何类别实现了Serializable这个接口的话，如果没有加入serialVersionUID，Eclipse都会给你warning提示，这个serialVersionUID为了让该类别Serializable向后兼容。即版本升级时反序列化仍保持对象的唯一性； 
第104篇文章[0]
哈工大软件构造Lab1的设计实现 2021年春季学期 计算学部《软件构造》课程 Lab1实验报告 目录 1.实验目标概述3 2.实验环境配置3 3.实验过程6 3.1MagicSquares6 3.1.1isLegalMagicSquare()6 3.1.2generateMagicSquare()8 3.2TurtleGraphics10 3.2.1Problem1:Cloneandimport10 3.2.2Problem3:TurtlegraphicsanddrawSquare10 3.2.3Problem5:Drawingpolygons11 3.2.4Problem6:CalculatingBearings11 3.2.5Problem7:ConvexHulls12 3.2.6Problem8:Personalart12 3.2.7Submitting14 3.3SocialNetwork14 3.3.1设计/实现FriendshipGraph类14 3.3.2设计/实现Person类15 3.3.3设计/实现客户端代码main()16 3.3.4设计/实现测试用例17 4.实验进度记录18 5.实验过程中遇到的困难与解决途径19 6.实验过程中收获的经验、教训、感想19 6.1实验过程中收获的经验和教训19 6.2针对以下方面的感受19 实验目标概述 本次实验通过求解三个问题，训练基本Java编程技能，能够利用JavaOO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。 ⚫基本的JavaOO编程 ⚫基于EclipseIDE进行Java编程 ⚫基于JUnit的测试 ⚫基于Git的代码配置管理 实验环境配置 在这里给出你的GitHubLab1仓库的URL地址。 https://github.com/ComputerScienceHIT/HIT-Lab1-1190200828 实验过程 MagicSquares 该任务的目标：设计isLegalMagicSquare()函数，判定给定的几个矩阵是否为magicsquare；将给定的生成奇数阶的magicsquare的generateMagicSquare()函数作为静态函数加入我的程序代码中，将生成的矩阵存入6.txt并调用isLegalMagicSquare()判断所生成的矩阵是否正确。该阶段涉及到文件读写操作、对某些特定函数的调用（例如split等）、对部分异常的处理（例如矩阵中有负数、浮点数，或是行列数不相等）等。 isLegalMagicSquare() 1.根据实验要求，我不能上来直接就去用magic矩阵的定义去判断其正确性，即每行每列每个对角线的元素和都相等；而是应该先判断给定的矩阵是否合理，即判断行列数是否相等、矩阵中是否有浮点数、负数等。由此，我的想法是设置一个整型变量n=0，对于txt文件先按行读入，每读入一行n++，直到读完文件，此时n的值即为矩阵行数。然后，依旧是按行读入文件，每读入一行，将其存入Stringline中，并调用split(“\t”)将其分割并存入String[]line_cut，比较行数n与line_cut.length，不相等则输出错误提示并返回false，后经过测试，当文件未用”\t”进行分割时，也会导n!=line_cut.length，因此在这里一并输出错误提示；然后判断line_cut中的每一个元素是否都是正整数，按位寻访line_cut，若出现某一位不在数字字符’0’-‘9’中，则输出错误提示并返回false。综上所述，即有如下代码： 以上错误判断完毕后，将读入的文档存入矩阵magic中，并按照magic矩阵定义进行测试，若不符合magic矩阵定义，则返回false。注意，在此过程中，并未输出错误提示，表示矩阵本身不存在行列数不相等等错误。于是有以下代码： 至此，isLegalMagicSquare()函数设计完毕； 结果展示： generateMagicSquare() 程序代码已经在ppt中给出，程序流程图如下：除该程序代码外，需对该函数的输入进行测试，以防输入为偶数或负数。该测试在我的main函数中完成，输入阶数为负数或偶数或输入阶数小于2时输出错误提示并予以重新输入，但是，如果输入根本并非整数，而是浮点数或字符时，则输出错误提示且不允许重新输入，于是有如下代码：除此之外，还需要在函数中加入文件写入操作，将产生的magic矩阵存入6.txt以便于main函数中测试其生成的magic矩阵的正确性，添加的代码如下：结果展示： TurtleGraphics 该任务的目标：clone已有的程序后，利用turtle按照要求画图，主要需要修改及再编程的是TurtleSoup类，其中的一些函数编程时需要结合我们已有的数学几何知识、TurtleSoup类中的提示信息以及测试用的TurtleSoupTest类中的提示信息，最后可以发挥想象力进行自己的创作。 Problem1:Cloneandimport 从github获取代码 由于clone出现问题，找不到实验报告上给的那个链接，所以我进入该链接后，将代码逐个复制到我的程序类中。 初始化本地仓库gitinit Problem3:TurtlegraphicsanddrawSquare 该函数需要实现：已知边长，画出边长为指定数值的正方形。参数是海龟对象turtle和边长sideLength。循环执行，每次画笔直行sideLength距离，然后画笔方向旋转90度，循环执行4次后即可得到所需要的正方形，函数代码如下：结果展示（sideLength=40）： Problem5:Drawingpolygons 首先，要求计算已知正多边形边数的内角度，该计算由已知公式可以推导，因此相关函数代码如下：根据正方形的画法，只需要将画笔的转向角度设置为180–内角度数，循环多边形边数次数即可。考虑到画笔转向既能是顺时针又能是逆时针，故在此声明：sides可为负数，且当sides为负整数时，代表着画笔将逆时针旋转，且旋转度数为180–内角度数，并且取sides的绝对值为正多边形边数。函数代码如下： Problem6:CalculatingBearings 首先，已知起点和当前朝向角度，要求起点到终点需要转动的角度。根据几何运算，得函数代码如下：上述问题的扩展：此时有若干个点，要求从第一个点开始到第二个点，再从第二个点到第三个点……以此类推每次转向的角度。以起点为第一个点，循环n-1次，每次将第i+1号点设置为“终点”，通过上一个函数计算旋转角度并存储到List中，将下一次的“起点”用当前“终点”更新，继续循环。程序代码如下： Problem7:ConvexHulls 由凸包算法（CSDN（ConvexHull凸包算法之Gift-Wrapping_InnovativeWorkstation-CSDN博客）上查阅），可得该函数代码为： Problem8:Personalart 函数代码： 结果展示： Submitting 由于第一次提交时已经进行过初始化以及与我的云仓库的关联，本次提交中只需要添加文件、注释以及提交三个步骤。 SocialNetwork 该任务的目标：设计一张社交网络无向图，连接互为朋友的人与人，并且能计算任意两人之间需要的最少的关联路径。于是，该问题为最短路径问题，而构建的图为无向无权图，所以利用DFS深度优先遍历即可得到两点间的最短路径。 设计/实现FriendshipGraph类 存储图中的人姓名的集合： addVertex()函数：首先判断Personp是否在图中，若已经存在于图中，则输出错误信息，程序结束；否则将p添加至person中。 addEdge()函数：在a、b的朋友列表里分别加入彼此。 getDistance()函数：DFS深度优先算法求最短路径 设计/实现Person类 Person类包括： Person()：包括这个人的名字p_name，这个人的朋友列表friends； IsFriendOf(Personp)：在p_name的朋友列表里加入p； 设计/实现客户端代码main() 由ppt给出： 设计/实现测试用例 思想：将a通过addVertex()函数加入testGraph1中，b不加入，因此，测试用例为a在testGraph1.person中，b不在； 思想：将a、b通过addVertex()函数加入testGraph1中，调用addEdge()函数，在a、b加一条线，即关联在一起，那么，a、b的朋友列表将包含彼此，因此测试用例中，a在b.friends中，b也在a.friends中； 思想：getDistance测试中应包括自己与自己、相互认识的两人、相互不认识但是有中间人关联的两人以及互不相干的两人； 测试结果：至此，实验设计结束。 
第105篇文章[0]
面向软件构造期末考试程序设计题的复习 面向软件构造期末考试程序设计题的复习 目录 目录1 1设计spec1 1.1spec的重要性1 1.2spec的结构1 1.3spec中不能包含的部分1 2ADT的设计1 2.1RI1 2.2表示泄露2 2.2AF2 3面向可维护性的设计模式2 3.1Visitor2 3.2Strategy策略模式2 3.3Iterator迭代器模式2 3.4Decorator装饰器模式3 3.5FactoryMethod工厂模式3 3.6Adapter适配器模式3 1设计spec 1.1spec的重要性 spec是程序员自己对所写的方法的规约，它规定了方法应该做什么，不应该做什么。spec时是测试优先编程的基础，因为程序员所编写的代码必定是符合spec的，否则就是不合格的，所以符合spec的代码也必然能通过根据spec所设计出的测试。同时，有了spec，客户端在使用所写的代码时就有所依据，客户端可以轻松的知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，而不必知道内部逻辑是怎么样的，大大节省了客户端使用自己的API时所需要的时间，并且降低了客户端对自己所编写的代码的误解。 1.2spec的结构 方法的功能；前置条件，即方法参数的限制条件，使用@param说明每个参数的前置条件；后置条件，即当前置条件满足时，方法结束时必须满足的条件，使用@return说明正确的返回值，即后置条件；使用@throws说明出现什么样的错误情况会导致什么样的异常。 1.3spec中不能包含的部分 spec不能暴露实现细节，不应该暴露局部变量，也不应该暴露私有的数据域，这些东西一旦暴露，就有可能给被非法的程序员利用，发现漏洞并实施攻击。 【注】方法不应该改变输入参数的取值，如果改了，则必须在spec中做出说明。所以推荐使用immutable的对象，以及使用immutable类作为返回值类型。 2ADT的设计 ADT的设计包括spec的设计、rep的设计以及implementation的设计，spec的设计上面已经提到，下面将介绍一些ADT相关的问题。 2.1RI RepInvariant，即不变量集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。我们通常通过写checkRep()来随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。 checkRep检查包括参数大小、参数是否为空、参数长度、参数中是否有 2.2表示泄露 即client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。一般来说，方法中的变量如果是public的，那么很有可能会出现表示泄露。若某些getter函数并未采用防御式拷贝，则变量有可能被外部指针所引用，导致表示泄露。 2.2AF AbstractionFunction，即从R空间到A空间存在一个映射，这个映射是一个满射，是将R中的每一个值解释为A中的一个值的映射。这个映射的解释函数就是AF。 3面向可维护性的设计模式 3.1Visitor 对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。 首先，设计相应扩展的Visitor接口，其中包括visit方法，该方法的参数为要扩展的方法类型，并且可复用。然后，设计一个CacuVisitor，实现Visitor接口中的方法，满足要扩展的功能条件。接着，在被扩展的方法中增加accept方法，即accept(Visitorvisitor){visitor.visit(this);}，即将自己传给visit。最后，在客户端调用accept(newCacuVisitor())即可。 3.2Strategy策略模式 有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。 首先，设计对应的扩展Strategy接口，接口中有相应的被扩展的方法select，该方法的参数与扩展前相同。然后，创建两个或多个不同的CacuStrategy方法，内部使用不同的策略来实现Strategy接口中的方法，分别满足原策略条件和要扩展的策略的功能条件。接着，在被扩展的方法参数中增加一个Strategy接口类型的参数，并将调用原策略方法的代码改为strategy.select(原参数)。最后，在客户端调用扩展方法时(原参数，newCacuStrategy)即可。 3.3Iterator迭代器模式 客户端希望遍历被放入容器/集合类的一组ADT对象。实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。 首先实现Iterator<遍历对象>的接口，然后实现iterator()方法，即publicIterator<遍历对象>iterator(){returnnewCacuIterator();} 接着创建内部类来实现该接口： privateclassCacuIteratorimplementsIterator<Car>，在该类中要实现next()，hasNext()，remove()三个方法。 3.4Decorator装饰器模式 每个子类实现不同的特性，因为这些特性都是多个维度上的个性化的特征，没办法做到在一个顶层的接口中完成所有特征的抽象，而且需要做到在各个维度上的特性的任意组合，此时光靠继承是没办法实现特性的组合的，如果要强行使用继承实现，那么面对的一个不可避免地问题是组合爆炸，因为每次继承只能扩展一个特性，多个特性就要多次继承实现，并且也不便于维护与扩展，而且会有大量的重复代码。 首先创建一个类来实现接口的方法，然后再创建一个类，来继承刚刚创建的那个类，并在此类中添加修饰。可以在继承后的类中添加rep，即参数。 3.5FactoryMethod工厂模式 解决的问题：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。 定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。也可以通过直接定义静态工厂方法来创建子类实例。 3.6Adapter适配器模式 将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。 后续将继续添加。 
第106篇文章[0]
Lab2中遇到的困难及相关知识 Lab2中遇到的困难及相关知识 目录 1对一些对象类型的不熟悉1 1.1Queue1 1.2Set1 1.3List2 1.4Map2 2循环遍历2 2.1普通for循环3 2.2加强for循环3 2.3迭代器Iterator3 总结3 1对一些对象类型的不熟悉 1.1Queue 队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，有先进先出的特点。 其常用方法如下： add()：将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回true，如果当前没有可用的空间，则抛出IllegalStateException。element()：获取，但是不移除此队列的头。offer()：将指定的元素插入此队列（如果立即可行且不会违反容量制），当使用有容量限制的队列时，此方法通常要优于add(E)，后者可能无法插入元素，而只是抛出一个异常。peek()：获取但不移除此队列的头；如果此队列为空，则返回null。poll()：获取并移除此队列的头，如果此队列为空，则返回nullremove()：获取并移除此队列的头。 1.2Set Set继承于Collection接口，是一个不允许出现重复元素，并且无序的集合。 其常用方法如下： add()：向集合中添加元素clear()：去掉集合中所有的元素contains()：判断集合中是否包含某一个元素isEmpty()：判断集合是否为空remove()：从集合中去掉特定的对象size()：返回集合的大小 1.3List List是一个接口，它继承于Collection的接口。它代表着有序的队列。当我们讨论List的时候，一般都和Set作比较。 List中元素可以重复，并且是有序的（这里的有序指的是按照放入的顺序进行存储。如按照顺序把1，2，3存入List，那么，从List中遍历出来的顺序也是1，2，3）。而Set中的元素不可以重复，并且是无序的（从set中遍历出来的数据和放入顺序没有关系）。 List的常用方法： add()：向List的指定位置插入元素get()：返回list中指定位置的元素set()：修改List中的某一指定位置的元素isEmpty()：判断List是否为空remove()：从List中去掉特定的对象size()：返回List的大小 1.4Map Map是将键映射到值的对象的数据结构，一个映射不能包含重复的键，且每个键最多只能映射到一个值。 Map的常用方法： put()：添加映射对get()：根据键来获取其映射的值containsKey()：判断Map中是否有指定键值containsValue()：判断Map中是否有指定的值remove()：从Map中去掉特定的对象keySet()：获得键的集合values()：获得值的集合isEmpty()：判断Map是否为空entrySet()：返回Map中的元素对 2循环遍历 循环遍历中的加强for循环以及迭代器遍历是我之前没有用的循环遍历方式。 2.1普通for循环 类似于for(inti=0;i<n;i++)的循环遍历； 2.2加强for循环 类似于for(Stringstr:list)的循环遍历； 值得注意的是，在加强for循环的过程中，只能观察被遍历的元素的值，并不能对其进行删除等操作，否则会发生意料之外的事情。 2.3迭代器Iterator 例如如下程序： Iterator<String>it=list.iterator(); while(it.hasNext()){ Stringx=it.next(); if(x.equals(“del”)){ it.remove(); } } 总结 本章回顾了我在做Lab2时遇到的两个主要的困难以及与它们相关的知识。 
第107篇文章[0]
Java面向对象的一些相关概念及设计实例 Java面向对象的一些相关概念及设计实例 1面向对象的相关概念 1.1面向对象 面向对象(ObjectOriented)是软件开发方法，一种编程范式。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。 1.2面向对象的相关概念 对象： 对象是指具体的某一个事物，即在现实生活中能够看得见摸得着的事物。在面向对象程序设计中，对象所指的是计算机系统中的某一个成分。在面向对象程序设计中，对象包含两个含义，其中一个是数据，另外一个是动作。对象则是数据和动作的结合体。对象不仅能够进行操作，同时还能够及时记录下操作结果。类的实例化可生成对象，一个对象的生命周期包括三个阶段：生成、使用、消除。 方法： 方法是指对象能够进行的操作，即函数。方法是类中的定义函数，其具体的作用就是对对象进行描述操作。 类： 类是具有相同特性（数据元素）和行为（功能）的对象的抽象。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象，类实际上就是一种数据类型。在我的理解中，类就像是一个带有内置函数的C语言中的结构体。 接口： 在Java语言中,仅支持单一继承,即一个子类只能有一个直接的父类，然而在日常生活中，多继承的问题在所难免如电子书既是一种图书，同时又是一种多媒体，这种继承关系要求子类继承多个父类。这样就可能导致子类具有多种多样的方法和实现形式。所以Java不允许多继承，为了解决多继承的问题，Java引入了接口的概念。定义一个接口不能使用class关键字，而是使用interface关健字。 1.3面向对象的核心特性 继承性： 继承简单地说就是一种层次模型，这种层次模型能够被重用。层次结构的上层具有通用性，但是下层结构则具有特殊性。在继承的过程中类则可以从最顶层的部分继承一些方法和变量。类除了可以继承以外同时还能够进行修改或者添加。通过这样的方式能够有效提高工作效率。 封装性： 封装是将数据和代码捆绑到一起，对象的某些数据和代码可以是私有的(private)，不能被外界访问，以此实现对数据和代码不同级别的访问权限。防止了程序相互依赖性而带来的变动影响，面向对象的封装比传统语言的封装更为清晰、更为有力。有效实现了两个目标：对数据和行为的包装和信息隐藏。 多态性： 多态是指不同事物具有不同表现形式的能力。多态机制使具有不同内部结构的对象可以共享相同的外部接口，通过这种方式减少代码的复杂度。一个接口，多种方式。 2面向对象的设计实例 设计实例即Lab2中Graph接口以及其具体实现的子类。 2.1Graph接口 /** *Amutableweighteddirectedgraphwithlabeledvertices. *Verticeshavedistinctlabelsofanimmutabletype{@codeL}whencompared *usingthe{@linkObject#equals(Object)equals}method. *Edgesaredirectedandhaveapositiveweightoftype{@codeint}. * *<p>PS2instructions:thisisarequiredADTinterface. *YouMUSTNOTchangethespecificationsoraddadditionalmethods. * *@param<L>typeofvertexlabelsinthisgraph,mustbeimmutable */ publicinterfaceGraph<L>{ /** *Createanemptygraph. * *@param<L>typeofvertexlabelsinthegraph,mustbeimmutable *@returnanewemptyweighteddirectedgraph */ publicstatic<L>Graph<L>empty(){ returnnewConcreteEdgesGraph<L>(); } /** *Addavertextothisgraph. * *@paramvertexlabelforthenewvertex *@returntrueifthisgraphdidnotalreadyincludeavertexwiththe *givenlabel;otherwisefalse(andthisgraphisnotmodified) */ publicbooleanadd(Lvertex); /** *Add,change,orremoveaweighteddirectededgeinthisgraph. *Ifweightisnonzero,addanedgeorupdatetheweightofthatedge; *verticeswiththegivenlabelsareaddedtothegraphiftheydonot *alreadyexist. *Ifweightiszero,removetheedgeifitexists(thegraphisnot *otherwisemodified). * *@paramsourcelabelofthesourcevertex *@paramtargetlabelofthetargetvertex *@paramweightnonnegativeweightoftheedge *@returnthepreviousweightoftheedge,orzeroiftherewasnosuch *edge */ publicintset(Lsource,Ltarget,intweight); /** *Removeavertexfromthisgraph;anyedgestoorfromthevertexare *alsoremoved. * *@paramvertexlabelofthevertextoremove *@returntrueifthisgraphincludedavertexwiththegivenlabel; *otherwisefalse(andthisgraphisnotmodified) */ publicbooleanremove(Lvertex); /** *Getalltheverticesinthisgraph. * *@returnthesetoflabelsofverticesinthisgraph */ publicSet<L>vertices(); /** *Getthesourceverticeswithdirectededgestoatargetvertexandthe *weightsofthoseedges. * *@paramtargetalabel *@returnamapwherethekeysetisthesetoflabelsofverticessuch *thatthisgraphincludesanedgefromthatvertextotarget,and *thevalueforeachkeyisthe(nonzero)weightoftheedgefrom *thekeytotarget */ publicMap<L,Integer>sources(Ltarget); /** *Getthetargetverticeswithdirectededgesfromasourcevertexandthe *weightsofthoseedges. * *@paramsourcealabel *@returnamapwherethekeysetisthesetoflabelsofverticessuch *thatthisgraphincludesanedgefromsourcetothatvertex,and *thevalueforeachkeyisthe(nonzero)weightoftheedgefrom *sourcetothekey */ publicMap<L,Integer>targets(Lsource); } 2.2具体实现 AF、RI、SafetyfromrepexposureCheckRep：ConcreteEdgesGraph中需要实现的方法(将方法全部实现即可)：ConcreteEdgesGraph：构造方法，不需要初始化变量；checkRep：检查表示不变性；add：添加一个顶点到顶点集vertices，不能重复加入；set：输入起点source、终点target和边权值weight，若起点或终点不在vertices内，则调用add将其加入。若weight<0，则返回-1；当weight=0时，若边存在，则删去该边；当weight>0时，若该边不存在，则将该边直接加入edges，否则应删去原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点，返回所有指向该点的起点及边的权值；targets：输入起点，返回该点指向的所有终点及边的权值；toString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点，返回所有指向该点的起点及边的权值；targets：输入起点，返回该点指向的所有终点及边的权值；toString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。 
第108篇文章[0]
哈工大软件构造Lab2设计实现 2021年春季学期 计算学部《软件构造》课程 **Lab2 目录 1实验目标概述3 2实验环境配置3 3实验过程5 3.1PoeticWalks5 3.1.1GetthecodeandprepareGitrepository5 3.1.2Problem1:TestGraph<String>5 3.1.3Problem2:ImplementGraph<String>6 3.1.4Problem3:ImplementgenericGraph<L>12 3.1.5Problem4:Poeticwalks14 3.1.6使用Eclemma检查测试的代码覆盖度16 3.1.7Beforeyou’redone16 3.2Re-implementtheSocialNetworkinLab118 3.2.1FriendshipGraph类18 3.2.2Person类18 3.2.3客户端main()19 3.2.4测试用例19 3.2.5提交至Git仓库20 4实验进度记录21 5实验过程中遇到的困难与解决途径22 6实验过程中收获的经验、教训、感想22 6.1实验过程中收获的经验和教训22 6.2针对以下方面的感受22 实验目标概述 本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说： ⚫针对给定的应用问题，从问题描述中识别所需的ADT； ⚫设计ADT规约（pre-condition、post-condition）并评估规约的质量； ⚫根据ADT的规约设计测试用例； ⚫ADT的泛型化； ⚫根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction） ⚫使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure）； ⚫测试ADT的实现并评估测试的覆盖度； ⚫使用ADT及其实现，为应用问题开发程序； ⚫在测试代码中，能够写出testingstrategy并据此设计测试用例。 实验环境配置 IDEA自带代码覆盖率工具，只需右键单击测试文件，选择RunwithCoverage即可： 在这里给出你的GitHubLab2仓库的URL地址（Lab2-学号）： https://github.com/ComputerScienceHIT/HIT-Lab2-1190200828 实验过程 PoeticWalks 此实验的目的是练习设计、测试和执行ADT。该阶段给出了一个图的接口，要求建立一个边图类一个点图类来分别继承自该图接口，在里面实现一系列方法并实现抽象数据型以完成poet。 GetthecodeandprepareGitrepository 从GitHub获取该任务的代码： gitclonehttps://github.com/rainywang/Spring2021_HITCS_SC_Lab2/ 在本地创建git仓库： 在自己创建的本地仓库中，打开gitbash输入gitinit然后与git远端仓库进行关联即可。 Problem1:TestGraph<String> 思路： 这是针对Graph<String>设计相应的测试策略，即对Graph<String>的每个方法进行测试。 过程： 下面的截图为接口Graph中的部分被方法测试策略，其中vertices()方法在add、set等方法的测试中已经测试过，因此不再单独测试： 其他测试策略不再一一展示。 Problem2:ImplementGraph<String> ImplementConcreteEdgesGraph Edge类的实现初始化构造方法：定义边起点source和边终点target，以及边权值weight。AF、RI、Safety：Edge中需要实现的方法：Edge：初始化构造方法，即初始化边的两个顶点和边权值；checkRep：检查表示不变性；getSource：返回边起点；getTarget：返回边终点；getWeight：返回边权值；toString：字符串形式描述一条边，形式为”Weightoftheedgefromsourcetotargetisweight.\n”Edge类中各方法的测试策略： 其他测试策略不再一一展示。 测试结果：ConcreteEdgesGraph类的实现初始化构造方法：定义顶点集vertices和边表edges。AF、RI、Safety：ConcreteEdgesGraph中需要实现的方法(结合已设计的Graph测试用例)：ConcreteEdgesGraph：构造方法，不需要初始化变量；checkRep：检查表示不变性；add：添加一个顶点到顶点集vertices，不能重复加入；set：输入起点source、终点target和边权值weight，若起点或终点不在vertices内，则调用add将其加入。若weight<0，则返回-1；当weight=0时，若边存在，则删去该边；当weight>0时，若该边不存在，则将该边直接加入edges，否则应删去原边后再将新的边和权值加入edges。改变了原边权值时，返回原边权值，边不存在则返回0；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点，返回所有指向该点的起点及边的权值；targets：输入起点，返回该点指向的所有终点及边的权值；toString：字符串形式输出图，每一条边的输出格式都与Edge类中toString方法中的返回形式相同。测试结果(包含Graph测试用例测试结果和toString的测试结果)： ImplementConcreteVerticesGraph Vertex类的实现初始化构造方法：定义图中点的名字vertex，Mapsources用于存储指向点vertex的所有起点以及它们之间的边的权值，Maptargets用于存储点vertex指向的所有终点以及它们之间边的权值。AF、RI、Safety：Vertex类中需要实现的方法：Vertex：初始化构造方法；checkRep：检查表示不变性；getVertex：返回点的名字；addSource：向sources中添加指向该点的起点及它们间边的权值。若weight<0，则返回-1；当weight=0时，若该起点存在，则在sources中删去该起点；当weight>0时，直接sources.put进行添加或者替换。改变了原边权值时，返回原边权值，边不存在则返回0；addTarget：向targets中添加该点指向的终点及它们间边的权值。操作与addSource相类似；getSources：返回sources；getTargets：返回targets；removeSource：从sources中删去一个指向该点的起点；removeTarget：从targets中删去一个该点指向的终点；toString：返回该点以及sources、targets。测试结果：ConcreteVerticesGraph类的实现初始化构造方法：定义顶点列表。AF、RI、Safety：ConcreteVerticesGraph类中需要实现的方法：ConcreteVerticesGraph：构造方法，不需要初始化变量；checkRep：检查表示不变性；add：初始化一个新的顶点并将其添加到到顶点列表vertices，若该点已经存在于图中，不能重复加入；set：输入起点source、终点target和边权值weight，若起点或终点不在vertices()内，则调用add方法将其加入。关于weight不同取值的操作于Vertice类的addSource、addTarget方法中完成；remote：去除某一点以及与它有关的所有边；vertices：返回顶点集vertices；sources：输入终点，返回所有指向该点的起点及边的权值；targets：输入起点，返回该点指向的所有终点及边的权值；toString：字符串形式输出图，每一个顶点的sources和targets的格式都与Vertex类中toString方法中的返回形式相同。测试结果： Problem3:ImplementgenericGraph<L> Maketheimplementationsgeneric 将之前实现的类和方法均使用泛型实现即可，即将各类中一开始用String型定义的变量，如起点source、终点target等相关的String类型变量均换为L。 接下来，按照IDEA的报错，将代码的其他位置的String替换为泛型L即可。 ImplementGraph.empty() 返回一个Graph的具体实现即可。 补充其他类型的标签： 测试结果： Problem4:Poeticwalks TestGraphPoet GraphPoet类中GraphPoet与poem方法的测试策略及测试用例： 【注】因为GraphPoet方法没有任何输出，图变量graph为private，所以无法直接测试该方法，所以直接测试两个方法； 1_empty.txt：空白文件，图为空，b必定不存在，所以返回值与input一致； 2_easy.txt：简单测试用文件，要插入的b均唯一 3_difficult.txt：比较复杂的测试用文件，要插入的b不唯一 GraphPoet类中toString方法的测试策略： 【注】考虑到该方法的测试，将Graph的具体实现更改为边图类，因为边图类的toString输出比点图类输出简单，更易书写测试用例。 ImplementGraphPoet 初始化构造方法：定义字符串构成的图graph。AF、RI、Safety：需要实现的方法：GraphPoet：先将文件corpus中的所有点读入，考虑到其中存在相同的点，集合Set并不适用，因此将所有点都读入列表。循环遍历列表，每次读入一前一后两个点作为起点和终点，建成一条边，其权值为该边在corpus中出现的次数；poem：生成poem，设计如下：toString：调用Graph接口中的toString方法，将整个图中所有点的指向转化为一条字符串输出。因为Graph接口的具体实现在设计测试文件时改为了边图类，所以输出格式即为边图类的toString方法的输出。 Graphpoetryslam 在main函数中加入一个输出调用toString方法，运行结果如下： 使用Eclemma检查测试的代码覆盖度 Beforeyou’redone 如何通过Git提交当前版本到GitHub上你的Lab2仓库。 gitinit gitadd. gitcommit-m“Firstcommit:PoeticWalkshasbeendone” gitremoteaddoriginhttps://github.com/ComputerScienceHIT/HIT-Lab2-1190200828 gitpushoriginmaster-u-m 在这里给出你的项目的目录结构树状示意图： Re-implementtheSocialNetworkinLab1 用在PoeticWalks已经实现的Graph<L>来实现Lab1中的FriendshipGraph类的各个方法，使之能通过测试文件，并且运行main函数的结果与Lab1一致。 FriendshipGraph类 初始化构造方法：生成空图graph。AF、RI、Safety：FriendshipGraph类中要实现的方法：main：与Lab1一致；addVertex：向图中添加点，调用Graph类中的add即可；addEdge：向图中添加边，因为是无向图，调用两次Graph类中的set即可；getDistance：得到两点间的距离，利用DFS算法，通过调用Graph类中的sources等方法即可；getGraph：因为构造方法graph设置为为private，为方便测试，故设置该方法以返回graph。 Person类 初始化构造方法：定义人的名字nameAF、RI、Safety：Person类中要实现的方法：Person：初始化构造方法，即初始化name； 客户端main() 将Lab1中的main直接复制过来即可，运行结果如下： 该结果与Lab1中main的运行结果一致。 测试用例 测试用例与Lab1一致，新增方法getGraph在其他测试中已测试完毕，不再进行单独测试； 测试结果(main无法参与测试，所以代码覆盖度较低)： 提交至Git仓库 提交过程同PoeticWalks； 在这里给出你的项目的目录结构树状示意图。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EHvUECld-1625645261706)(media/21c74acf10e1062c719496a9d029fc77.png)] 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 经过学习，对于Java的一些概念更加了解；对于Java中自带的一些方法还是很不熟悉，很多方法都要靠百度现场搜，以后会多加积累，多加练习；总是因为一些小错误而debug很长时间，以后要避免循环溢出等小错误；因为IDEA太聪明了，导致手写代码基本不可能，以后要多加记忆代码，加强手写代码能力。 针对以下方面的感受 面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？ADT的实现过程比较困难，但是一旦实现了ADT，后续工作就会变得十分简单；使用泛型和不使用泛型的编程，对你来说有何差异？本次实验来讲并没有什么差异，因为开始时未用泛型时，也没有用到与特定数据类型相关的方法；在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？优势：有目的的编程，有助于保证代码的正确性；暂时不适应；P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？提高代码效率，降低实现难度；P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？首先，P3不存在；其次，肯定不适应，因为P1都只是勉强能写；为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？意义：防止内部变量被外部修改，提高代码安全性；我会尽量坚持，虽然繁琐，但可以提高代码安全性；关于本实验的工作量、难度、deadline。工作量比较大，主要体现在写代码、代码注释、测试策略以及实验报告的撰写；难度对我来说比较高，因为对Java还是不算熟悉，很多方法需要现查；ddl比较合理，毕竟三周时间，但很容易造成所有工作堆在最后完成，建议学习计算机系统实验，将整个实验分为几个具有联系的小型实验发布，每周一交；《软件构造》课程进展到目前，你对该课程有何体会和建议？Java是一个很聪明的语言，而IDEA也是一个很聪明的编程工具；实验中给出代码注释基本上都是英文，本次实验中，我的函数注释基本上也是用的英文，但是测试策略、代码注释还是中文，以后会慢慢改进。设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？首先，P3不存在；其次，肯定不适应，因为P1都只是勉强能写；为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？意义：防止内部变量被外部修改，提高代码安全性；我会尽量坚持，虽然繁琐，但可以提高代码安全性；关于本实验的工作量、难度、deadline。工作量比较大，主要体现在写代码、代码注释、测试策略以及实验报告的撰写；难度对我来说比较高，因为对Java还是不算熟悉，很多方法需要现查；ddl比较合理，毕竟三周时间，但很容易造成所有工作堆在最后完成，建议学习计算机系统实验，将整个实验分为几个具有联系的小型实验发布，每周一交；《软件构造》课程进展到目前，你对该课程有何体会和建议？Java是一个很聪明的语言，而IDEA也是一个很聪明的编程工具；实验中给出代码注释基本上都是英文，本次实验中，我的函数注释基本上也是用的英文，但是测试策略、代码注释还是中文，以后会慢慢改进。 
第109篇文章[0]
学完哈工大软件构造的一点小心得 其实这个课应该叫Java编程深入学习（笑 写一点学习时感觉比较容易混淆的点，可能有错漏，大神轻喷 final的修饰作用 用来修饰一个引用 如果引用为基本数据类型，则该引用为常量，该值无法修改；如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。如果引用时类的成员变量，则必须当场赋值，否则编译会报错。（或者在实例化类时，在构造函数将final修饰的成员变量全部赋值） 总之就是固定了引用，使一个引用不能被改变，由于基本数据类型引用和数据是一一对应的，因此固定引用就是固定了数值。 用来修饰一个方法 当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。主要用于严格继承，子类无需重写父类中的方法 用来修饰类 当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。 静态方法，静态变量（或者叫类方法，类变量），实例方法，实例变量 概念：实例化，就是你新建一个对象的那个动作就叫实例化，实例方法和变量就是基于已经生成的对象的东西，而类方法和类变量不用实例化变量就可以使用（经典例子：Math.sin()），因为是每个类共有的东西，因此冠以类方法类变量的名称 实例变量（instancevariable） 实例变量：或叫实例域、实例字段（instancefield），或叫成员变量（membervariable）。实例的变量，每个实例的变量可能不同。 实例方法（instancemethod） 实例方法：或叫成员方法（membermethod）。供实例用的方法，必须要先有实例，才能通过此实例调用实例方法。 类变量（classvariable） 类变量：或叫静态域、静态字段（staticfield），或叫静态变量（staticvariable）。出现在这样的情况下：一个类的所有实例需要一个公有的属性，比如，一，统计实例个数；二，常量。类变量与类直接关联在一起。内存当中只有一个地方存放这个变量。任何实例都可以修改它的值（前提是它没有被final修饰符修饰，不然就是常量），但是，访问类变量并不需要实例，用类就可以操作了。 类方法（classmethod） 类方法（classmethod）：跟类变量的基本特点一样。供类用的方法，可以没有实例，直接通过类来调用类方法。 从形式上看，类变量和类方法，比一般的变量和方法多了一个static修饰符。因为这个原因，类变量和类方法也被叫做静态变量和静态方法。 使用方式 实例方法可以直接访问实例变量，调用实例方法； 实例方法可以直接访问类变量，调用类方法。但不推荐这么做，原因是不清晰，容易把类变量误认为是实例变量，把类方法误认为是实例方法（借助IDE，它会给出警告信息）； 类方法可以直接调用类变量和类方法； 类方法不能直接调用实例变量和实例方法； 类方法里面不能使用“this”关键字，因为没有实例存在，“this”不知道引用哪个实例。 public,protected,friendly,private 直接上图 作用域当前类同一package子孙类其他packagepublicYYYYprotectedYYYNfriendly(default)YYNNprivateYNNN override&overload override（重写）发生在子类和父类中。 重写是子类对父类的允许访问的方法的实现过程进行重新编写,返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。 重写规则 参数列表与被重写方法的参数列表必须完全相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5及更早版本返回类型要一样，java7及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个类，则不能重写该类的方法 overload（重载）可以发生在一个类中，或者父类和子类中 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准 重写与重载之间的区别 区别点重载方法重写方法参数列表必须修改一定不能修改返回类型可以修改一定不能修改异常可以修改可以减少或删除，一定不能抛出新的或者更广的异常访问可以修改一定不能做更严格的限制（可以降低限制） 多态的三个方面 Adhocpolymorphism(特殊多态)：体现在overload上 Parametricpolymorphism(参数化多态)：体现在泛型上 subtypepolymorphism（子类型多态）：体现在继承上 枚举 本质就是类，但是这些类已经实例化并存储在枚举列表中。枚举也可以有自己的构造方法，成员变量和成员方法。具体看https://blog.csdn.net/qq_35385687/article/details/90147104 接口（静态方法和default方法） default方法：写在接口中，相当于正常的方法，可以写方法体，也可以正常使用。 作用：由于修改接口需要修改接口所有相关的实现类，非常不利于开发维护，因此使用default给接口添加新的方法和实现，实现类会继承default方法，省去了重复开发的弊端。 静态方法：类似类的静态方法，不用实例化对象就能直接调用。 泛型通配符的一些小知识点 具体看https://www.cnblogs.com/minikobe/p/11547220.html 设计模式（工厂，适配器，装饰器，策略模式，模板模式，迭代器模式，访问者模式） 工厂模式：将创建类的细节和逻辑与客户端隔离开。使用一个接口创建不同的子类。 适配器模式：将一个接口转换为客户需要的另一个接口。 假如客户现在使用的接口是A，而需要B的功能，但是B和A之间不兼容。这时候就可以创造适配器类，通过委托调用B的功能。然后修改A，若需要调用B的功能，则在A中委托生成适配器，间接调用B。 缺点：使用过多类之间的关系会非常混乱，而且一个类只能使用一个适配器 装饰器模式：动态地给一个对象添加一些额外的职责。 假如客户现在使用的接口是A，需要一些功能可以灵活添加，则使用装饰器。首先构造一个抽象装饰类B实现接口A。但是抽象装饰类B并不具体实现装饰，而是委托调用装饰子类实现功能。接着我们写各种装饰子类，都继承自B，每个装饰类内部有具体的装饰功能。同时每个装饰子类中有一个构造函数，参数是最顶层的A。这意味这若要生成拥有多个特征的子类，只需在构造时每层嵌套一个装饰子类即可。 策略模式：没啥好说的，就是全部是委托关系。类要使用的时候可以随意选择不同的策略类进行计算 模板模式：类似给定程序框架，然后框架中的模块可以自定义。具体来说，给一个模板类，里面有一个表示方法逻辑关系的方法，在其中的不同方法的逻辑运行关系和流程是确定的，但是部分具体实现由于情况的不同而不同，这时我们可以通过子类继承该模板类，然后修改实现方法。 注意，表示逻辑和流程的方法应该用final修饰，防止被子类更改。 迭代器模式：以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。 访问者模式：当需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。 具体操作，在被访问的类里面加一个对外提供接待访问者的接口，在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。 在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT LSP原则： 只要父类能出现的地方，子类就可以出现，并且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但反之，未要求。 通俗点：子类可以扩展父类的功能，但不能改变父类原有的功能 具体来说： 子类可以实现父的抽象方法，但不能覆盖父类的非抽象方法覆盖或实现父类的方法时输入参数可以被放大，覆写或实现父类的方法时输出结果可以被缩小子类抛出的异常需要比父类具体 实践中： 在类中调用其它类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已违背了LSP如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。如果你的程序中出现了if/else之类对子类类型进行判断的条件，则说明类的设计已违背了LSP。 CRP原则： 软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。（能不用继承就不要用继承） 委托（dependance,Composition,Aggregation） dependance：临时使用，在方法中new一个，使用完成后就抛弃 composition：深入绑定，委派类作为该类的成员。 aggregation：浅绑定，委派类作为该类某个方法的参数进行使用 SOLID编程原则 (SRP)TheSingleResponsibilityPrinciple单一责任原则 当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。 (OCP)TheOpen-ClosedPrinciple开放-封闭原则 软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。 (1)通过增加代码来扩展功能，而不是修改已经存在的代码。 (2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。 (3)OCP支持替换的服务，而不用修改客户模块。 (LSP)TheLiskovSubstitutionPrincipleLiskov替换原则 客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。 (DIP)TheDependencyInversionPrinciple依赖转置原则 (1).高层模块不要依赖低层模块； (2).高层和低层模块都要依赖于抽象； (3).抽象不要依赖于具体实现； (4).具体实现要依赖于抽象； (5).抽象和接口使模块之间的依赖分离 (ISP)TheInterfaceSegregationPrinciple接口聚合原则 不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。 客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。 
第110篇文章[0]
软件构造Lab3中关于时间相关类的设计 在lab3中，不同的应用需要的时间格式不同，但IntervalSet接口统一采用了long类型作为时间点参数。为了能够使用IntervalSet接口，初步考虑使用一个时间类进行统一的转换。本来采用了Java自带的Date数据类型作为转换头，但由于Date中大部分的方法已经被舍弃了，无法作为解码器使用；除此之外，由于从给定日期到1900年1月1日的毫秒数过大，在课表APP中担心爆long，因此需要重新设计APP。最终人为定义了一个编解码器类，每个APP需要时调用作为编解码器将时间与long进行转换。排班与课表APP采用从1900年1月1日到给定时间的天数作为编码结果，保证了编码的连续性；其中课表可以将天数乘10转换为课时数，并且也保证了连续。 classDutyCodec { publicDutyCodec(){} /** *Encodeadatetoalonginteger *@paramyeartheyearofthedate *@parammonththemonthofthedate *@paramdaythedayofthedate *@returnalongintegerindicatesthecodeofthedate */ publiclongencode(intyear,intmonth,intday)throwsDateError { longcode=day-1; if(year<1900||month<=0||day<=0||month>12||day>31) thrownewDateError("Invaliddate"); if(day==31) if(month==2||month==4||month==6||month==9||month==11) thrownewDateError("Invaliddate"); if(month==2&&day==29) if(!(year%4==0&&year%100!=0)) thrownewDateError("Invaliddate"); for(inti=1900;i<year;i++) { if((i%4==0&&i%100!=0)||i%400==0) code+=366; else code+=365; } for(inti=1;i<month;i++) { if(!(i==2||i==4||i==6||i==9||i==11)) code+=31; elseif(i!=2) code+=30; else code+=((i%4==0&&i%100!=0)||i%400==0)?29:28; } returncode; } /** *Gettheyearfromthecode *@paramcodethecodewanttodecode *@returnaintegerindicatestheyear */ publicintgetYear(longcode) { intyear=0; for(year=1900;code>=0;year++) { if((year%4==0&&year%100!=0)||year%400==0) code-=366; else code-=365; } returnyear-1; } /** *Getthemonthfromthecode *@paramcodethecodewanttodecode *@returnaintegerindicatesthemonth */ publicintgetMonth(longcode) { intyear=0; intmonth=0; for(year=1900;code>=0;year++) { if((year%4==0&&year%100!=0)||year%400==0) code-=366; else code-=365; } year--; code+=((year%4==0&&year%100!=0)||year%400==0)?366:365; for(month=1;code>=0;month++) { if(!(month==2||month==4||month==6||month==9||month==11)) code-=31; elseif(month!=2) code-=30; else code-=((year%4==0&&year%100!=0)||year%400==0)?29:28; } returnmonth-1; } /** *Getthedayfromthecode *@paramcodethecodewanttodecode *@returnaintegerindicatestheday */ publicintgetDay(longcode) { intyear=0; intmonth=0; for(year=1900;code>=0;year++) { if((year%4==0&&year%100!=0)||year%400==0) code-=366; else code-=365; } year--; code+=((year%4==0&&year%100!=0)||year%400==0)?366:365; for(month=1;code>=0;month++) { if(!(month==2||month==4||month==6||month==9||month==11)) code-=31; elseif(month!=2) code-=30; else code-=((year%4==0&&year%100!=0)||year%400==0)?29:28; } month--; if(!(month==2||month==4||month==6||month==9||month==11)) code+=31; elseif(month!=2) code+=30; else code+=((year%4==0&&year%100!=0)||year%400==0)?29:28; return(int)code+1; } } 
第111篇文章[0]
对于装饰器模式的理解 之前一直有个疑问，如果采用装饰器模式设计继承树，那客户端在调用的时候如何使用装饰器中的功能？原先理解的是客户端仍然只能查看接口，但接口带来的问题就是：子类添加的个性的方法无法体现在顶层的接口中，从而导致客户端无法使用子类的所有功能。例如: publicinterfaceA{ publicstaticAempty(){ returnnewA1(); } publicvoida(); } publicA1implementsA{ publicA1(){} @Override publicvoida(){} } publicabstractDecoratorimplementsA{ protectedAdecoratedA; publicDecorator(Aa){ decoratedA=a; } @Override publicvoida(){ decoratedA.a(); } } publicDecorator1extendsDecorator{ publicDecorator1(Aa){ super(a); } publicvoidb(){}; } Aa=newA1(); Adecorator=newDecorator1(a); 此时decorator无法调用b方法查看网上别人的代码后发现，装饰器模式的装饰应该只真对于自身，而不能被外界使用，即b方法应该被private修饰。 
第112篇文章[0]
JUnit测试是否正常抛出错误 在使用JUnit测试代码时，课程上将的只有assertEquals函数。然而，assertEquals函数的实现是调用了对象提供的equals方法来判断被测是否与参照相同，如果程序抛出错误，assertEquals函数就无法捕获例如 NewList<Integer>list=newArrayList<>(); assertEquals(1,list.get(0)); 会抛出错误，假设此时我们需要测试是否正常抛出了越界错误，就不能使用assertEquals函数进行测试因此，JUnit提供了一个fail函数来判断是否抛出了异常，其随trycatch块一起共同使用 try { //被测代码 fail("缺了异常")； } catch(Exceptione) { System.out.println("e.getMessage()"); } 此时若被测代码没有抛出异常，则会执行fail函数 
第113篇文章[0]
已学的UML类图的基本元素 单个类 Class +Stringpublic -Stringprivate #Stringprotected ~Stringdefault +Abstract():String +Static():String 如图中类图所示+表示public修饰符-表示private修饰符#表示protected修饰符~表示默认包权限，即本包可见，外部包不可见斜体字表示抽象方法下划线表示静态方法 类间关系 继承 A B 图中所示有误，应用空心三角与实线表示继承关系 实现 A B 图中所示有误，应用空心三角与虚线表示继承关系 聚合（hasa关系） A B 用空心菱形与实线箭头表示，如图表示B含有一个A 
第114篇文章[0]
Lab2中关于equals方法的一个问题（尚未解决） lab2实验中要求不能有警告且不能用@SuppressWarnings取消警告。然而，在为包含泛型的可变类型写equals方法时，遇到了如下问题 ClassGraph<L> { @Override publicbooleanequals(Objectobj) { if(obj==null) returnfalse; if(!(objinstanceofGraph)) returnfalse; Graph<L>g=(Graph<L>)obj; } } 在类型转换时，编译器报警告：Typesafety:UncheckedcastfromObjecttoGraph。网上给出的方法均是使用@SuppressWarnings(“unchecked”)或者设置IDE来忽视该警告。是否有其他解决办法？ 
第115篇文章[0]
2021-07-07 关于多态的一些内容 重载的多态 与overload相关，主要是多个不同实现的方法具有相同的名字，但每个方法之间的参数必须有所区分。重载多态对于客户端而言是方便的，不需要记住大量方法的名字，根据输入的参数不同，会在静态类型检查时自动匹配相应的方法。例如： privatevoidPeople(Stringname) { } privatevoidPeople(Stringname,Stringtel) { } privatevoidPeople(Stringname,Stringtel,intage) { } 三者虽然方法名相同，但参数类型不同，因此符合重载多态注意： privatevoidPeople(Stringname,Stringtel,intage) { } PrivatebooleanPeople(Stringname,Stringtel,intage) { } 这两个方法虽然返回值类型不一致，但参数类型是相同的，不构成重载 参数的多态 参数多态即我们通常所说的泛型，当具体使用的数据类型还不确定时可以使用，能够提高代码的适用范围。例如： publicstatic<L>IntevalSet<L>empty() { } L便是我们所用的一个替代具体数据类型的一个标识符当我们需要赋予其具体类型时，例如String IntevalSet<String>a=IntevalSet.empty(); 只需将先前的L换成我们所要使用是数据类型即可 子类型多态 子类型多态的前提条件有以下几点： 要存在继承关系。重写子类（override)父类要引用子类对象。 publicclassfriend{ inta=10; publicvoidmakefriend() { System.out.println("makefriend"); } } publicclassBestfriendextendsfriend{ inta=9; publicvoidmakefriend() { System.out.println("makebestfriend"); } } Bestfriend继承了父类friend，而且重写了方法makefriend,二者都定义了一个成员变量a.测试： publicstaticvoidmain(String[]args){ friendf=newBestfriend();//多态使用 f.makefriend(); System.out.println(f.a); } 输出结果为; makebestfriend 10 我们发现1.调用成员方法时，使用的是子类型中重写后的成员方法。2.父类和子类中出现同名的成员变量时，多态调用该变量时，会使用父类中成员变量 
第116篇文章[0]
2021-07-06 #关于final关键字的一些内容 修饰变量：final关系字修饰后的变量，其内存地址是不会发生变化的。例如：修饰基本数据类型 publicfinalStringa="kk"; a=newString("tt");//静态类型检查会报错 由于string是immutable类型的变量，当改变a的值时，会将其指向一个新的内存空间，与final变量修饰相矛盾，报错。修饰引用数据类型，即对象 finalPersonb=newPerson("b","00000"); finalPersonc=newPerson("a","11111"); System.out.println(b.getname()); b.setname("c"); System.out.println(b.getname()); 此时的输出结果为：可以看到b的保留的某些值是可以正常更改的。但想进行下列操作时 c=b; 系统会报错，因为对象b和对象c使用了final关键字来进行修饰，其指向的内存地址是不可以修改的。但对象内部值与对象的内存空间是不一样的，所以对象内部的值可以修改。修饰方法时final关键字修饰的方法是不能够重写的，并且某一个类中所有private方法都默认添加了final关键字修饰类时final关键字修饰的类是无法被继承的 
第117篇文章[0]
如何将Java中的Date类变成immutable类型 想法一 直接使用final对Date的对象进行修饰。 但是Date是对象数据类型（Objecttypes），当我们对这样的数据类型用final修饰时，它引用的对象是不能改变的，但是它指向的对象的值是可以改变的。 finalDatedate=newDate(); date.setYear(2021);//allowed! 上面代码是合法的，我们尽管使用了final来修饰Date类型的date对象，我们依然可以调用setYear方法来修改date里有关年份的属性。 想法二 写一个自己的MyDate类，在这个类中，实现Date类的基本功能，但是一切可能改变对象值的方法都不应该再出现（例如上面提到的setYear方法）。其实本质上就是在新的类里创建了一个Date类型的private对象，然后将需要实现的方法委托（Delegation）给Date类。 importjava.util.Date; publicclassMyDate{ privateDatedate; publicMyDate(){ date=newDate(); } publicMyDate(longtime){ date=newDate(time); } publicbooleanafter(MyDatewhen){ returndate.after(when.date); } publicbooleanbefore(Mydatewhen){ returndate.before(when.date); } //  } 
第118篇文章[0]
Java防御式拷贝方法小结 为什么要用防御式拷贝 在ADT中，常常会有一些Observer方法，用户可以通过这样的方法查看ADT的一些相关属性。用户在获得相关属性后，可能会对这些属性做一些修改，如果我们直接把ADT中的rep返回给用户，那么用户的修改就有可能对ADT产生巨大影响，从而导致程序出现一些意想不到的错误。而使用防御性拷贝就是为了避免类似情况的出现。 其实，如果从更广义的角度看，不仅仅是出现返回值时有可能出现表示泄露，其实在构造函数里如果对用户输入的对象不进行有效的拷贝，用户之后的修改其实也可能对你设计的ADT产生影响，这时其实也需要进行防御性拷贝。 举例 以下面这个例子为例。 classPoem{ publicStringtitle; publicStringauthor; privateList<String>lines=newArrayList<>(); privateDatedate; //AF:代表一首诗，包含四个属性： //title为诗的题目， //author为诗的作者， //lines为诗的文本行， //date为诗的发表日期 publicPoem(Stringt,Stringa,List<String>l,Dated){ title=t; author=a; lines=l; date=d; } publicvoidaddOneLine(StringnewLine){ lines.add(newLine); } //.. publicList<String>getAllLines(){ returnlines; } } 在这个ADT中实际上是存在着一些表示泄露的风险的。 在构造函数里，直接使用了lines=l;这样的语句，本意试想把输入的List<String>l拷贝给rep里的lines属性。但是由于List是对象数据类型，所以实际上此时l与line指向的是同一个对象，一旦客户端改变l中的值，line也会跟着改变，这样是很危险的。在构造函数里，还出现了date=d;语句。Date是对象数据类型，一旦客户端改变d中的值，date中的值也会跟着改变，这样是很危险的。在getAllLines()方法中，直接把rep中的lines放回给了用户，这样用户可以随意修改返回的List，有可能会改变ADT中的rep，这也违反了表示独立性。 解决：防御式拷贝 关于防御式拷贝，主要的思路就是创建一个跟原来的对象一模一样的对象，并且这个新的对象不会受到原来对象的影响，也就是说它们是完全独立的。这里主要以List和Date这两个典型的mutable类型进行举例。 List 对于List，我们实际想要复制的是整个List里的所有对象，而不是指向这个List的指针。 我们可以遍历原始List，再将List里的所有元素拷贝到新的List中，代码如下。 classTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<>(Arrays.asList("a","b","c")); List<String>copyList=newArrayList<>(); for(inti=0;i<list.size();i++){ copyList.add(list.get(i)); } list.remove(0); System.out.println("list:"+list.toString()); System.out.println("copylist:"+copyList.toString()); } } 最后的运行结果为 list:[b,c]copylist:[a,b,c] 可以看出这里成功实现了元素的拷贝，对原来List的改变不会影响新的List。 但是这样的拷贝略显麻烦，下面的方法要简单一些。 classTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<>(Arrays.asList("a","b","c")); List<String>copyList=newArrayList<>(); copyList.addAll(list); list.remove(0); System.out.println("list:"+list.toString()); System.out.println("copylist:"+copyList.toString()); } } 通过List对象的addAll()方法，实现List中元素的拷贝（俗称“深拷贝”）。 Java中的一些其他的集合类（比如Set，Map等）也可以通过类似的方法实现防御式拷贝，进而避免外来的改变对ADT造成影响。 而在Observer方法中，实际上也需要进行防御式拷贝，这里可以使用上面的方法将rep的拷贝返回给用户，也可以使用Collections.unmodifiableLis()对List对象进行修饰，修饰过的对象是不可变的。 Date Date与List相比就要简单一些了，我们只需要创建一个新的Date对象，保证这个对象的值和原来的对象一样即可。 下面是具体的代码实现。 classTest{ publicstaticvoidmain(String[]args){ Datedate=newDate(); DatecopyDate=newDate(date.getTime()); date.setTime(2000000000); System.out.println("date:"+date.toString()); System.out.println("copydate:"+copyDate.toString()); } } 最后的运行结果为 date:SatJan2411:33:20CST1970copydate:TueJul0616:57:15CST2021 我们成功创建了两个完全独立的Date对象，这正是我们想要的。 对于一些其他的对象，或是通过构造函数，或是通过一些set方法，我们都可以创建一个与原先对象一模一样的对象。 结语 以List和Date为例，本文主要介绍了Java中进行防御式拷贝的一些方法，并且说明了防御式拷贝的必要性。 但是如果返回值本身的就是immutable类型的对象，实际上就不需要防御式拷贝了，因为这样的对象是不允许被改变的。所以，在日后的编程中，如果可以使用immutable类型的对象，就尽量使用，这样可以避免许多与表示泄露有关的麻烦。 
第119篇文章[0]
关于boost多线程的小总结 join 一般来说，多线程的各个线程之间往往是相互联系的，一个线程停止，其他进程也没有继续进行下去的必要了。所以，一般只要在一个线程后面加.join()。但这并不是针对所有情况。比方说，如果两个线程之间没有联系，一个线程结束时，另一个线程不一定要同时结束，这样一来就要在两个线程后面都加上.join()。 加锁 一般只在需要处理共享变量的时候加锁。加锁虽然能让线程之间互不影响，但如果加锁覆盖的范围太广，就会减慢整个多线程的速度。有时候，需要进行一些很耗时的操作（比如抓图），但操作的是共享变量，这时候怎么办呢？一个很好的解决方案是先用一个临时变量代替这个共享变量进行抓图，然后再把这个临时变量赋值给共享变量。此时，抓图操作是在加锁之前，赋值操作在加锁之后，而赋值是很快的操作。这样一来，既在使用共享变量时加了锁，又大大加快了程序的运行速度。 结束 一般通过key=cv::waitKey(1)语句等待按“q”进行结束，但这往往只能正常终止当前线程，别的线程是被打断的而不是正常结束。可以在进程中的while循环的条件里写一个开关变量，一旦按下“q”键就修改这个变量的值，让所有进程正常结束。 
第120篇文章[0]
关于Java迭代器（Iterator）的思考 JavaIterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代ArrayList和HashSet等集合。 在我们使用 for( : ) 去遍历集合中的所有元素时，其实就隐式地使用了迭代器（Iterator）。 遍历集合的两种方法 通常来说，遍历集合中的元素主要有以下两种方法。 //method1 List<String>list= ; for(Stringstr:list){ System.out.println(str); } //method2 List<String>list= ; Iterator<String>iter=list.iterator(); while(iter.hasNext()){ Stringstr=iter.next(); System.out.println(str); } 对于第二种方法来说，其实是显式地定义了一个Iterator类型的对象，它有iterator()方法，调用该方法可以获取一个迭代器。 迭代器有三个基本操作，分别是next、hasNext和remove。 调用it.next()会返回迭代器的下一个元素，并且更新迭代器的状态。 调用it.hasNext()用于检测集合中是否还有元素。 调用it.remove()将迭代器返回的元素删除。 Iterator是Java中的一个接口，位于java.util包中，使用前需要引入它，语法格式如下： importjava.util.Iterator;//引入Iterator类 两种方法的比较 下面，我们来比较一下这两种方法有何不同。 我们先分别运行一下下面的两段代码。 publicclassTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<String>(Arrays.asList("Apple","Orange","Peach")); for(Stringstr:list){ System.out.println(str); } } } publicclassTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<String>(Arrays.asList("Apple","Orange","Peach")); Iterator<String>iter=list.iterator(); while(iter.hasNext()){ Stringstr=iter.next(); System.out.println(str); } } } 我们发现它们的运行结果是一样的。这样看它们好像没有什么差别，而且第一种写法要简单一些，代码量更少。 删除元素 下面我们比较一下当从集合中删除元素时，这两种写法的区别。 publicclassTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<String>(Arrays.asList("Apple","Orange","Peach")); for(Stringstr:list){ list.remove(str); } System.out.println(list); } } 当我们运行上面这段代码时，出现了报错。可以通过根据异常定位到报错的地方：当我们使用Java中的foreach循环时，其实编译器会根据list对象创建一个Iterator的迭代器。我们对list进行的增删操作的具体实现都必须经过Iterator。在Iterator创建的时候modCount被赋值给了expectedModCount，但是调用list的add和remove方法的时候不会同时自动增减expectedModCount，这样就导致两个count不相等，从而抛出异常。 我们再试试下面这种写法。 publicclassTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<String>(Arrays.asList("Apple","Orange","Peach")); Iterator<String>iter=list.iterator(); while(iter.hasNext()){ Stringstr=iter.next(); list.remove(str); } System.out.println(list); } } 运行之后，出现了和上面一样的报错信息。与上一种写法相比，这里的Iterator被显式地定义出来了，但是同样出现了调用list的remove方法的时候不会同时自动增减expectedModCount的问题，这样就导致两个count不相等，从而抛出异常。 那应该怎样在遍历List的同时删除元素呢，我们看一下下面这种写法。 publicclassTest{ publicstaticvoidmain(String[]args){ List<String>list=newArrayList<String>(Arrays.asList("Apple","Orange","Peach")); Iterator<String>iter=list.iterator(); while(iter.hasNext()){ Stringstr=iter.next(); if(str.endsWith("e")){ iter.remove(); } } System.out.println(list); } } 最后的运行结果如下：我们可以看到，这里成功的删除了以e结尾的两个字符串。为什么使用iter.remove()就可以成功删除List中的元素呢？这是因为在Iterator中的remove方法在删除元素后会自动调整迭代器指向的元素，也会自动增减expectedModCount的值，所以不会出现之前的报错。 使用自己的迭代器 上面我们都是使用的Java标准库里的Iterator接口，那能否定义自己的MyIterator类（接口）呢？ 答案是肯定的。并且在很多时候，为自己设计的抽象数据类型（ADT）增加一个迭代器是一个很不错的设计模式（IteratorPattern），用户可以用之前已经非常熟悉的迭代器方法来遍历你设计的ADT中的元素。 在Java的标准库中定义了一个Iterable接口，而实现该接口的集合对象是可遍历迭代的。这里的Ierator是迭代器的接口，也在Java标准库中有定义。基本结构如下。而所谓的Iteratorpattern就是指让自己的集合类实现Iterable接口，并实现自己独特的Iterator迭代器(重写hasNext,next,remove方法)，允许客户端利用这个迭代器进行显式或隐式的迭代遍历。 下面是一个实现样例。 //实现Iterable<E>接口 publicclassPair<E>implementsIterable<E>{ privatefinalEfirst,second; publicPair(Ef,Es){first=f;second=s;} //重写iterator方法 //返回自己的迭代器 publicIterator<E>iterator(){ returnnewPairIterator(); } //构建自己的Iterator privateclassPairIteratorimplementsIterator<E>{ privatebooleanseenFirst=false,seenSecond=false; //OverridehasNext方法 publicbooleanhasNext(){return!seenSecond;} //Overridenext方法 publicEnext(){ if(!seenFirst){seenFirst=true;returnfirst;} if(!seenSecond){seenSecond=true;returnsecond;} thrownewNoSuchElementException(); } //Overrideremove方法 //这里不允许删除元素 publicvoidremove(){ thrownewUnsupportedOperationException(); } } } 
第121篇文章[0]
2021春软件构造雨课堂选择题(3）（4) 1.Externalqualityfactors：（1）正确性（2）健壮性（3）可扩展性（4）可复用性（5）兼容性（6）效率（7）可移植性（8）易用性（9）功能性 2.敏捷开发特征：增量式过程迭代过程 3.配置管理SCM①软件配置管理：用于追踪和控制软件的变化②SCI基本配置项：产生变化的基本单元③版本：为软件的任一特定时刻moment的形态指派一个唯一的编号，作为“身份标识”。④Git----集中式版本控制系统 4.Git①.git-----本地的CMDB②工作目录-------本地文件系统③暂存区-----隔离工作目录和Git仓库 ④3种状态：已修改、已暂存、已提交 ⑤Git存储发生变化的文件（而非代码行），不变化的文件不重复存储。 ⑥将Github上的某个Git仓库设置为本地仓库的指令是：gitpullaaa⑦将暂存区文件写入Git仓库的指令是：gitcommit-m“xxxx” 5.Git仓库的objectgraph 
第122篇文章[0]
2021春软件构造雨课堂选择题(5) 1.codereview代码评审 2.staticcodeanalysis 3.dynamiccodeanalysis动态分析：执行程序并观察现象，收集数据、分析不足 4.profiling：对代码的运行时状态和性能进行度量，发现代码中存在的问题 5.refactoring重构在不改变功能的前提下，优化代码 
第123篇文章[0]
Git学习笔记 个人的学习笔记，用作以后复习。以下内容来源于尚硅谷：link 1.Git的常用命令 1.1设置用户签名 安装完成后只需要设置一次用户签名否则提交代码会报错 gitconfig--globaluser.nameyourname gitconfig--globaluser.emailyouremailadd cat~/.gitconfig//查看设置好的用户 {查看用户：c盘用户} {这个签名和其他的账号，如Github账号没有任何关系} 小技巧：输入命令的前几个字母，点击tab键自动补全命令 1.2基本操作 先打开项目文件所在位置再打开bash .git文件默认隐藏，不要修改它里面放的东西 gitinit//初始化本地库 ll//查看文件 ll-a//查看隐藏文件 cd///回到根目录 cd..//回到上一层目录 gitstatus//查看本地库状态 //Onbranchmaster在master分支 gitaddfilename#添加到暂存区，也就是追踪文件的过程 gitadd--all waring：LFwillbereplacedbyCRLFinhello.txt 这里是window里面的换行符LF被改成Linux下的换行符CRLF，不必在意这个警告 //暂存区的文件可以删除 gitrm--cachedfilename//只是从暂存区里删掉了，工作区里没有删除 gitcommit-m"日志信息"filename//提交到本地库 gitreflog//查看版本信息 //965c6a1(HEAD->master)……//965c6a1版本号 gitlog//查看详细版本信息 catfilename//显示filename里面的内容 ·只要有文件修改就可以查看状态 ·修改文件后再用gitstatus查看，发现modified信息 ·Git里按行来修改文件 gitreset--hard版本号//版本穿梭：认为新的版本不行，回到旧的版本 //版本号用relog查看就可以 git切换版本用的是指针，不是记录很多个不同版本的文件（副本） HEAD指向的分支就是当前分支 2.Git的分支操作 2.1什么是分支 一个项目，多个任务，我们对每个任务创建分支。在不同的分支上完成开发，这样就不会影响主分支。 Master主分支 Hot-fix热修复分支 分支是可以改名的 2.2分支的操作 gitbranchname//创建分支 gitbranch-v//查看分支 gitbranch-mold_namenew_name gitcheckoutname//切换分支 gitmergename//把指定的分支合并到当前分支上 //注意：合并前得先切换到目标分支，再合并 2.3合并时冲突的处理办法 两个分支在同一文件同一位置有两套完全不同的修改人为决定谁去谁留 CONFLICT(content)：Mergeconflictinfilename.type 直接vim打开冲突的文件，人为修改<<<===>>>之间的内容，再次添加到缓存区，提交即可但提交时不要加上filename.type gitcommit-m"info" 即可 3.GitHub操作 3.1创建远程创库 gitremote-v//查看别名 gitremoteaddAB//创建别名将B重新起个名字，A gitremoteaddgit-demohttp://……//将网站叫做git-demo 3.2本地分支和远程仓库 gitpush别名分支//推送本地分支到远程仓库 //不用别名，直接用网页链接也可以 gitpull别名分支//拉取远程仓库到本地库 gitclonehttp://……//克隆远程代码到本地 /* 克隆代码不需要登陆 ①拉取代码 ②自动初始化本地仓库 ③别名也创建好了 */ 3.3GitHub团队内协作 前提条件：加入团队 在仓库创建者的账号里：setting-->manageaccess-->inviteacollaborator-->输入账号 得到了一个邀请的网页地址被邀请者需要进入这个网站，接受这个邀请 
第124篇文章[0]
Java设计模式：装饰器模式（简易版） 软构lab3 这是个简单的例子 我们假设要点一份菜。菜单里：①蔬菜②肉类 现在我们为这个份菜增加装饰：①加辣椒②加量 1.抽象构件角色：Dish这是一个接口 packagefunc; publicinterfaceDish{ voidorderdish(Stringmsg);//点一份菜 } 2.具体实现：Meat和VegetableMeat和Vegetable是对Dish的具体实现，用implements packagefunc; publicclassMeatimplementsDish{ @Override publicvoidorderdish(Stringmsg){ //TODOAuto-generatedmethodstub System.out.println("你点了一份荤菜："+msg); } } packagefunc; publicclassVegetableimplementsDish{ @Override publicvoidorderdish(Stringmsg){ //TODOAuto-generatedmethodstub System.out.println("你点了一份素菜："+msg); } } 3.抽象装饰器DecoratorDish①这是一个抽象类，实现Dish，因此用implements②注意其成员属性：引用了Dish对象 packagedecorator; importfunc.Dish; publicabstractclassDecoratorDishimplementsDish{ //要装饰的对象是 privateDishmyDish; //构造器 publicDecoratorDish(DishmyDish){ this.myDish=myDish; } //原先在Dish接口中的方法 publicvoidorderdish(Stringmsg){ myDish.orderdish(msg); } } 4.具体装饰AddPepper和Large①在这里实现要增加的新方法②注意构造器的写法，用了super packagedecorator; importfunc.Dish; publicclassLargeextendsDecoratorDish{ //构造器 publicLarge(Dishlarge_dish){ super(large_dish); } //点一份加大的菜 @Override publicvoidorderdish(Stringmsg){ super.orderdish(msg);//原功能 LargeDish();//新功能 } //要增加的新的功能 publicvoidLargeDish(){ System.out.println("备注：大份的"); } } packagedecorator; importfunc.Dish; publicclassAddPepperextendsDecoratorDish{ //构造器 publicAddPepper(Dishpepper_dish){ super(pepper_dish); } //点一份加辣的菜 @Override publicvoidorderdish(Stringmsg){ super.orderdish(msg);//原功能 PepperDish();//新功能 } //要增加的新的功能 publicvoidPepperDish(){ System.out.println("备注：加辣的"); } } 5.测试 packagetest; importdecorator.AddPepper; importdecorator.Large; importfunc.Vegetable; importfunc.Dish; importfunc.Meat; publicclasstestde{ publicstaticvoidmain(String[]argv){ Dishsalad=newVegetable(); Dishchicken=newMeat(); System.out.println("-------原始的---------"); salad.orderdish("沙拉"); chicken.orderdish("烤鸡"); //这里就是使用了装饰的 //我们可以给Dish的具体实现类增加任意多的装饰 Dishlarge_salad=newLarge(newVegetable()); Dishpepper_chicken=newAddPepper(chicken); Dishdouble_deco=newAddPepper(newLarge(newVegetable())); System.out.println("\n-------加装饰的---------"); large_salad.orderdish("沙拉"); pepper_chicken.orderdish("烤鸡"); double_deco.orderdish("土豆泥"); } } 
第125篇文章[0]
Java的ArrayList小问题 1.发现在new时，不是会自动初始化为null①在遍历时最好使用for-each方法，否则会出现越界异常②或者用size()来遍历也行 importjava.util.ArrayList; publicclassTry{ publicstaticvoidmain(String[]args){ //TODOAuto-generatedmethodstub ArrayList<String>mylist=newArrayList<>(); mylist.add(0,"A"); mylist.add(1,"A"); //注释掉，发现编译报错 //mylist.add(2,"NULL"); mylist.add(3,"B"); for(Stringi:mylist){ System.out.println(i); } } } 2.发现remove后，元素下标会自动排好 importjava.util.ArrayList; publicclassTry{ publicstaticvoidmain(String[]args){ //TODOAuto-generatedmethodstub ArrayList<Integer>mylist=newArrayList<>(); for(inti=0;i<=4;i++){ mylist.add(i); } for(intj:mylist){ System.out.println(j); } mylist.remove(1); System.out.println(mylist.indexOf(0)); System.out.println(mylist.indexOf(2)); System.out.println(mylist.indexOf(3)); System.out.println(mylist.indexOf(4)); } } 
第126篇文章[0]
2021春软件构造雨课堂选择题(2) 1.Memorydump属于软件三维视图中的：Run-time、Code-level、Moment 2.Executionstacktrace和codesnapshot在软件三维度视图中的共性是：都是Run-time，code-level 3.CodeChurn和AST分别是Build-time和period的视图 4.Staticlinking（静态链接）和Dynamiclinking（动态链接）的区别在于：①前者发生在构造阶段，后者发生在运行阶段。 
第127篇文章[0]
Java时间年月日及其持续天数用Date！！！ 软构lab3 知道开始和结束日期的年月日，求持续天数 getTimeInMillis()将其转化成long,表示从格林威治标准时间1970年1月1日的00:00:00.000到Calendar对象表示的时间之间的毫秒数 importjava.util.Calendar; publicclassTry{ publicstaticvoidmain(String[]args){ Calendarstartdate=Calendar.getInstance(); Calendarenddate=Calendar.getInstance(); //设置时间 startdate.set(2021,6,30); enddate.set(2021,7,2); //getTimeInMills()函数 longdura=enddate.getTimeInMillis()-startdate.getTimeInMillis(); //输出检查 System.out.println(startdate.get(Calendar.YEAR)+"-"+startdate.get(Calendar.MONTH)+"-"+startdate.get(Calendar.DATE)); System.out.println(enddate.get(Calendar.YEAR)+"-"+enddate.get(Calendar.MONTH)+"-"+enddate.get(Calendar.DATE)); //得到毫秒数 System.out.println(dura); //得到天数 System.out.println(dura/1000/60/60/24); } } 以上方法十分离谱，快跑！！！ 2021-6-1到2021-6-5得到的时间是4但是！2021-6-30到2021-7-1得到的时间却是1 如果涉及到月转换，就别用这个方法 看了一番突然发现了问题所在：java里的Calendar不检查月份天数，它默认每个月都是31天。 publicstaticStringnyr(Calendara){ Stringmystr=a.get(Calendar.YEAR)+"-"+a.get(Calendar.MONTH)+"-"+a.get(Calendar.DATE); returnmystr; } publicstaticvoidmain(String[]args){ Calendara=Calendar.getInstance(); a.set(2021,2,28); System.out.println(nyr(a)); a.add(Calendar.DATE,1); System.out.println(nyr(a)); a.add(Calendar.DATE,1); System.out.println(nyr(a)); a.add(Calendar.DATE,1); System.out.println(nyr(a)); a.add(Calendar.DATE,1); System.out.println(nyr(a)); } 输出如下：？？？谁家2月有30号啊！！！！ 再见Calendar，我用Date去了 新方法如下： packagetest; //注意：引进的包是sql里的 importjava.sql.Date; importjava.util.Calendar; publicclassTry{ //给日期加n天 publicstaticDateadd_days(Datea,longday){ Calendartemp=Calendar.getInstance(); temp.setTime(a); temp.set(Calendar.DATE,temp.get(Calendar.DATE)+(int)day); Datemydate=newDate(temp.get(Calendar.YEAR)-1900,temp.get(Calendar.MONTH),temp.get(Calendar.DATE)); returnmydate; } //计算两个日期之间的持续天数 publicstaticlonggetDuration(Dateearly,Datelate){ //不必考虑日期的先后顺序，加个绝对值 longmyDura=Math.abs(early.getTime()-late.getTime())/(1000*60*60*24); returnmyDura; } publicstaticvoidmain(String[]args){ //奇妙的赋值方式 //年份-1900，月份-1，日正常 Datea=newDate(2021-1900,2-1,28); System.out.println(a.toString()); System.out.println("---------测试：加方法是否跨月份----------"); //注意：Date是mutable的 a=add_days(a,1); System.out.println(a.toString()); a=add_days(a,1); System.out.println(a.toString()); a=add_days(a,1); System.out.println(a.toString()); System.out.println("---------测试：两个日期之间的持续天数----------"); Dateb=newDate(2021-1900,6-1,1); Datec=newDate(2021-1900,6-1,5); Dated=newDate(2021-1900,7-1,1); System.out.println("2021-6-1到2021-6-5间隔"+getDuration(b,c)+"天"); System.out.println("2021-6-1到2021-7-1间隔"+getDuration(d,b)+"天"); } nice 
第128篇文章[0]
2021春软件构造雨课堂选择题(1) Integera=newInteger(3); Integerb=3; intc=3; System.out.println("a==b"+(a==b)); System.out.println("b==c"+(b==c)); System.out.println("a==c"+(a==c)); 2. Stringa="c"; Stringb="c"; System.out.println("aandb:"+(a==b)); String是不可变的数据类型，改变引用、不改变内容。 System.out.println("2.00-1.10="+(2.00-1.10)); 浮点数在计算机里无法精确存储4. List<Integer>list=newArrayList<>(); for(inti=-3;i<3;i++){ list.add(i); } System.out.println("finishadd"+list); for(inti=0;i<3;i++){ list.remove(i); } System.out.println("finishremove"+list); remove（intindex）删除的是index处的数字删除后，数组的大小及其元素下标都会动态更改5. Strings="Hello"; s+="World"; s.trim(); System.out.println(s); trim()//去除字符串的头尾空格 
第129篇文章[0]
软件构造作业-使用eclipse内置的git工具 前言 在哈工大软件构造的几个实验（作业）中，均要求使用git管理项目配置。同时，建议使用eclipseIDE进行项目开发。如果使用eclipse自带的git插件，就不需要额外安装和使用git，在eclipse中一并管理，比较方便。本文将实例演示使用内置git工具管理项目的常用方法。 步骤1新建远程仓库 在GitHub上创建远程仓库。软件构造课程的3个作业，只要点击链接，就可以自动生成仓库。在此我额外新建一个仓库作为演示。 1.1点击startaproject 1.2填写仓库信息 有仓库名和一些可选项。我选择添加README文件，因为如果仓库是空的，它不会生成默认分支，之后会有点麻烦。 1.3点击"Createrepository"确认 新建仓库完成后，应该看到这样的界面。 1.4*修改默认分支名为master 点击分支按钮，再点Viewallbranches，再点击右侧的铅笔图标，则如下图所示。 步骤2在eclipse中引入项目 2.1从Git中引入 打开eclipse，点击File->Import，选择ProjectsfromGit(withsmartimport)，点击Next。 2.2选择CloneURI 然后点击Next。 2.3填写相关信息 先复制远程仓库的地址。 再填写URI和自己的Github账号信息。Host和RepositoryPath会在填写URI后自动填写。勾选StoreinSecureStore，就可以记住密码，以后不用每次输入。 2.4剩下的操作 不断点击Next，再点Finish。完成的结果如下图。可以看到项目被引入工作空间了。 2.5*设置Java项目 右键项目，选择Properties. 选择ProjectNatures，AddJava，再点击OK和ApplyandClose。 再在buildpath中添加jdk和JUnit，具体操作略。 步骤3修改项目并提交到远程分支 3.1做出本地修改 新建文件new，写入123. 3.2提交到本地仓库 右键项目，选择Team->Commit  以下显示的是GitStaging。点击重叠的绿色加号，将修改放入stage。右侧是CommitMessage。必须填入，否则不能提交。 再点击右下角的Commit，即可提交。 3.3Push到远程仓库 右键项目，选择Team->PushtoUpstream Push成功后，会跳出如下窗口。 也可以在commit步骤直接点击CommitandPush，一步到位。 步骤4创建和切换分支 4.1在远程仓库创建新分支change 4.2在本地仓库添加Upstream的分支 右键->Team->Remote->ConfigureFetchfromUpstream  在Refmappings中点击Add ，Source选择change，输入后会稍微加载一段时间。 然后点击Next到Finish。 4.3新建并切换到本地分支change 右键->SwitchTo->NewBranch  填写name为change，完成。 4.4修改本地文件 4.5push到远程change分支 先commit，然后设置PushBranch"change"  填入Branch名为change。 再push就可以了。 4.6再切换回来 步骤5其它 本文中没有提到的有fetch，pull，解决冲突等问题。这些在本学期的软件构造中用不到，但在实际的多人协作中很常用。以后有时间可能会讨论。 
第130篇文章[0]
SC（二） Iterator迭代器学习体会 做Lab2的时候用到了，简单了解了一下Iterator的使用。 Iterator可以遍历并选择列中的对象，在Java中只能单向移动 （1）iterator()：返回一个Iterator。例： Iterator<Edge<L>>it=edges.iterator(); （2）next()：获得序列中的下一个元素。例： Edge<L>a=it.next(); 第一次调用Iterator的next()方法时，它返回序列的第一个元素。 （3）hasNext()：检查序列中是否还有元素。例： while(it.hasNext()){ Edge<L>a=it.next(); } (4)remove()：将迭代器新返回的元素删除 it.remove(); Iterator<Edge<L>>it=edges.iterator(); while(it.hasNext()){ Edge<L>a=it.next(); if(){ flag=a.getWeight(); it.remove(); break; } } 
第131篇文章[0]
SC（四） 两类ADT复用手段 继承 用于Class之间 父类和子类之间的关系，通过extends产生继承关系 子类可以直接访问父类中的非私有的属性和行为，无法继承父类中私有的内容 一个类只能有一个直接父类，但多个类可以继承一个父类；可以多层继承，例如A->B,B->C 遵循LSP原则 委派 用于Object之间，运行时建立动态链接 建立委派（rep存储/不存储）->动态传入（client负责）->实际调用 
第132篇文章[0]
SC（三） 重写（Override）和重载（Overload） 重写（Override） 重写是子类对父类允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。 重写方法的spec保持不变/增强 重写方法是子类对父类方法的修改/扩展，个性化过程 finalmethod不可被重写 在运行时决定调用哪个方法 重载（Overload） 重载：在同一个类里面，相同的方法名，不同的参数列表。常见构造器的重载 重载和重写是完全不同的，二者没有任何关系。 参考资料：https://www.runoob.com/java/java-override-overload.html 
第133篇文章[0]
SC（一） 关于对“过早的优化是万恶之源”的理解 “过早的优化是万恶之源”这句话出自DonaldKnuth的《计算机编程艺术》 其实在接触软件构造课程之前，我并没有真正的去体会这句话。此前的编程目的都是为了学习一门编程语言，或者是学一些数据结构和算法。从这些角度出发，代码层的程序优化似乎是一件非常重要的事。有一段时间非常执着于对复杂度甚至代码简洁程度的优化，可以优化的复杂度都进行优化，对复杂度的优化超出我的能力范围后就开始简化代码。因为那时候需要写的代码量很小并且是面向过程的编程，所以并没有带来非常大的困扰。 当我被软件构造实验按在地上反复摩擦的时候，我终于开始正视这句话。在多次因为尝试对某一段代码进行优化结果导致连锁反应整个程序崩溃的时候，我也放弃了这种执着于从一开始就优化程序的想法。一个程序应该是先实现它需要实现的基本功能，再考虑优化问题。一个正确的程序，远比一个快速的程序重要的多。在遵循设计原则的基础上，完成一个正确的程序是首要任务。 优化应该是基于需求的，在没有明确真正需求的情况下过早的优化只能造成精力和时间的浪费。 对程序性能进行优化时，应该依赖性能分析数据，而不是靠直觉推断是否需要优化，理论数据和实际数据都有可能相去甚远，更不用说靠直觉产生的“假想数据”。 在了解需求和性能分析数据的情况下，应该选择相对更优的优化指标。你无法优化一切，在各种指标中选择更符合优化目标的进行优化。 
第134篇文章[0]
2021-07-07 解决Thepackagejava包isnotaccessible问题包无法引进的问题，如下图：首先第一步查看自己是否在创建工程的时候不小心创建了module-info.java文件，如果是的话，这个时候有两种解决方案第一种eclipse自动给你生成的解决方案，你双击它后，可以在module infor.java文件生成如下代码：此时就会发现错误都解决了。 第二种比较粗暴：直接删除这个module-info.java 如果不是因为module-info.java文件的原因，那么网上有很多博客可以解决这个问题。 
第135篇文章[0]
关于Java中的异常处理控制流 在软件构造实验中，我们使用java语言标准库的各种方法，时不时遇见Eclipse提示需要处理某某Exception。Eclipse一般会提示两种修改当前代码的方法以消除编译错误。一个是用trycatch语句块包围可能抛出异常的代码，另一个是为当前正在编写的方法添加throws声明。两种方法是有区别，但是以前对此不清不楚。在做实验三的时候，因为代码需要，学习了一下，现在在这里记录一下。 1.对可能抛出异常的代码使用try-catch-finally语句包围。 那些可能抛出异常的代码应该写在try中。 catch可以有多个列在try后面，分别处理相应的异常。几个catch语句块是有顺序的，发生异常时从前往后寻找匹配异常的语句块。只会匹配并执行一个catch语句块，然后控制流离开catch们，继续往下执行（finally或方法中剩余内容），try中的剩余内容不会再执行了。 若有两种异常需要处理，其中一个异常类型是另一个异常类型的子类型，那么子类型异常的特殊的处理得放在前面，对于其他父类型异常比较一般的处理就放在后面。如果catch(父类型异常){}在catch(子类型异常){}之前，子类型异常的处理就总是会被截胡永远没机会执行了，会有编译错误提示这一点。 finally语句块是总是要执行的内容，即有没有发生异常都要执行finally。finally理论上是保证只要执行了try，不管有没有执行catch，不管catch执行什么，finally语句块都执行。例如，catch中最后直接return，在真正离开本方法之前，还是会执行finally语句块，不过已经确定的返回值不会受到finally中相应赋值语句的影响。实际上有些情况会导致finally没机会执行，比如jvm进程已经在catch执行后结束了。 2.为当前方法添加throws声明。 那些可能抛出异常的代码直接写在当前方法中即可。 这会导致相应的异常转发到当前方法的调用者调用当前方法处抛出，由调用者决定如何处理。发生异常时，直接离开当前方法不再执行，控制流回到调用者调用这个方法的地方，并继续执行调用者方法中关于这个异常的处理逻辑。如果在调用链中每级方法都声明throws把异常处理推给上级，连main方法也如是，那么调用main方法的jvm内部逻辑会处理相关异常。 实际上，关于异常处理还有很多细节。不过在实验三中知道这些就差不多了吧。。。 
第136篇文章[0]
关于Java中方法的重写（Override） 在java中，子类的非静态成员方法可以重写（Override）父类中的对应的方法。在使用父类引用调用相应的方法时，会根据运行时引用所指向的对象的实际类型动态调用子类或父类对应的方法，这就是多态了。软件构造课的考试题中有这样的题： 考察什么是正确的重写。 在java中，我们使用@Override注解让编译器为我们检查是否正确重写，编写子类时也是用IDE直接生成代码，因此有些细节就没有注意到，这里记录一下。 0.根据LSP规则，子类类型也是父类类型，需要父类类型的地方子类类型可以顶上去。因此，通过父类引用动态调用方法，调用的子类方法必须是兼容的。 1.private方法不能参与重写。private完全是仅本类可见的，自然不能被其他类（包括子类、父类）感知，动态调用之类的显然也不行了。 2.子类方法或不throws任何异常，或throws父类方法所声明的那些异常。子类方法throws的异常类型可以是父类方法throws的异常类型的子类型，这很好理解，父类方法要求throwsException，子类方法throwsIOException，IOException也是EXception，因此子类方法满足了要求。 3.子类方法返回值类型必须也是父类方法返回值类型。也就是说，子类方法或返回一样的类型，或返回父类方法返回类型的子类型。这也很好理解，父类方法returnNumber，子类方法returnDouble，Double也是Number，因此子类方法满足了要求。 4.理论上，根据LSP，还可以允许子类方法的参数类型是父类方法参数类型的父类型。即子类方法(List<?>scores)而父类方法(ArrayList<?>scores)，因为ArrayList<?>也是List<?>，参数传递起来是兼容的。实际上，在java中不允许这种重写。这某种意义上说与java的另一个特性是有关的，即重载：java允许一系列同名但参数类型不完全相同的方法写在一个类，并在编译阶段根据实参类型确定某段代码中调用的一系列重载方法究竟是哪一个。如果允许前面说的这种重写，就会出现子类中可以有多个方法重写父类方法，这不是乱套了？因此java不允许这种重写。其实这一问题可以有多种方法解决，比如增加某种关键字，在子类中明确指定哪个方法重写父类的哪个方法，但是这样非常不简洁。实际上，java采用重写加重载可以达到类似的效果，即用子类方法(ArrayList<?>scores)重写父类方法(ArrayList<?>scores)，然后子类方法(ArrayList<?>scores)直接调用另一个重载子类方法(List<?>scores)，实际效果相当于子类方法(List<?>scores)重写父类方法(ArrayList<?>scores)。 
第137篇文章[0]
关于Java中equals方法 今天被这熟悉而又陌生的equals方法搞麻了。对于不可变类型，似乎还好，反正是不可变的，判断一下内容即可。主要是父类类型和子类类型之间做equals时，需要处理非常多的细节。但是把这种比较内容（也即是观察等价性）的想法用到可变类型上，可就掉坑里了。 一般借java讲等价性，都会提到，java的容器类型都实现了观察等价性。由于容器都是mutable的，嵌套的HashSet<ArrayList<String>>会出bug： publicstaticvoidmain(String[]args){ HashSet<ArrayList<String>>set=newHashSet<>(); ArrayList<String>list=newArrayList<>(); list.add("A"); set.add(list); set.contains(list);//returntrue list.add("B"); set.contains(list);//returnfalse } list并没有移除可是contains检测不到了。这是因为list被改变了，按其观察等价性的实现，hashcode也变了，contains计算哈希桶编号得到的不再是原来的那个保存着list的桶了，自然认为找不到list。麻了。 在PPT上，关于这里，说java的观察等价性实现是不好的，应该使用行为等价性实现，即使用Object中引用等价性的实现。可是使用引用等价性完全不能反应这个ADT的任何特点，实际上没有任何意义。这样的equals实现无非是“不出bug”，并不能使它有意义地出现在HashSet中。在HashSet里出现两个地址不同但元素完全相同的东西看上去是荒谬的。目前java中的这些容器类型不能很好地容纳可变类型，主要还是在于不能随着元素变化自动调整容器自身，和equals怎样实现是没有关系的。无论是没有意义的引用等价性还是倒霉的观察等价性，都不能让容器正确地、反应ADT特性地容纳相关类型。搞坏了equals，再去弄一个same，similar之类的去判断ADT等价性属实麻了。 最简单的规则还是禁止在容器中使用可变类型。实在需要在容器中使用可变类型，还是封装remove-add好一点。让equals做回自己吧。 
第138篇文章[0]
【软件构造】Maven的使用 Maven是一个比较好用的配置管理工具。当你的程序需要多个配置项时，可以去他的官方网站，找到对应的版本，把对应的脚本粘贴到你的配置文件当中。它会自动下载。它还可以管理你程序的生命周期，无论你是要编译、生成文档、发布、测试、运行，你只需要配置好对应的脚本，运行脚本即可自动完成。 1.首先，在工程的根目录下创建一个pom.xml 2.配置依赖项，这一部分代码可以从https://mvnrepository.com/上查找。比如我们要引入log4j2、junit4的依赖 3.配置源文件夹、测试文件夹，这一部分放进<build>标签中 4.配置编译插件，放在<build><plugins>里，注意，maven默认的jdk版本是1.7，很多情况下需要改成1.8及以上版本 5.配置其他部分的插件，要放进对应的标签中，比如这里的spotBugs插件 6.要进行某些生命周期的操作，我们可以通过maven的命令行参数执行，也可用ide 7.执行complile，可以看到对应的结果 
第139篇文章[0]
【软件构造】使用JUnit进行单元测试 简介 JUnit是一个Java编程语言的单元测试框架。JUnit在测试驱动的开发方面有很重要的发展，是起源于JUnit的一个统称为xUnit的单元测试框架之一。 好处 1.可以书写一系列的测试方法，对项目所有的接口或者方法进行单元测试。 2.启动后，自动化测试，并判断执行结果,不需要人为的干预。 3.只需要查看最后结果，就知道整个项目的方法接口是否通畅。 4.每个单元测试用例相对独立，由Junit启动，自动调用。不需要添加额外的调用语句。 5.添加，删除，屏蔽测试方法，不影响其他的测试方法。开源框架都对JUnit有相应的支持。 环境配置 从官网http://www.junit.org 下载JUnit最新版本的压缩文件。 JUnit断言 Junit所有的断言都包含在Assert类中。 这个类提供了很多有用的断言方法来编写测试用例。只有失败的断言才会被记录。Assert类中的一些有用的方法列式如下： voidassertEquals(booleanexpected,booleanactual):检查两个变量或者等式是否平衡voidassertTrue(booleanexpected,booleanactual):检查条件为真voidassertFalse(booleancondition):检查条件为假voidassertNotNull(Objectobject):检查对象不为空voidassertNull(Objectobject):检查对象为空voidassertSame(booleancondition):assertSame()方法检查两个相关对象是否指向同一个对象voidassertNotSame(booleancondition):assertNotSame()方法检查两个相关对象是否不指向同一个对象voidassertArrayEquals(expectedArray,resultArray):assertArrayEquals()方法检查两个数组是否相等 JUnit注解 @Test:这个注释说明依附在JUnit的publicvoid方法可以作为一个测试案例。@Before:有些测试在运行前需要创造几个相似的对象。在publicvoid方法加该注释是因为该方法需要在test方法前运行。@After:如果你将外部资源在Before方法中分配，那么你需要在测试运行后释放他们。在publicvoid方法加该注释是因为该方法需要在test方法后运行。@BeforeClass:在publicvoid方法加该注释是因为该方法需要在类中所有方法前运行。@AfterClass:它将会使方法在所有测试结束后执行。这个可以用来进行清理活动。@Ignore:这个注释是用来忽略有关不需要执行的测试的。 JUnit加注解执行过程 beforeClass():方法首先执行，并且只执行一次。afterClass():方法最后执行，并且只执行一次。before():方法针对每一个测试用例执行，但是是在执行测试用例之前。after():方法针对每一个测试用例执行，但是是在执行测试用例之后。在before()方法和after()方法之间，执行每一个测试用例。 JUnit执行测试 测试用例是使用JUnitCore类来执行的。JUnitCore是运行测试的外观类。要从命令行运行测试，可以运行javaorg.junit.runner.JUnitCore。对于只有一次的测试运行，可以使用静态方法runClasses(Class[])。 JUnit参数化测试 Junit4引入了一个新的功能参数化测试。参数化测试允许开发人员使用不同的值反复运行同一个测试。你将遵循5个步骤来创建参数化测试。 用@RunWith(Parameterized.class)来注释test类。创建一个由@Parameters注释的公共的静态方法，它返回一个对象的集合(数组)来作为测试数据集合。创建一个公共的构造函数，它接受和一行测试数据相等同的东西。为每一列测试数据创建一个实例变量。用实例变量作为测试数据的来源来创建你的测试用例。 一旦每一行数据出现测试用例将被调用。 
第140篇文章[0]
【软件构造】Git的使用 1.什么是Git? 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 2.目录结构 假如现在有一个工程被git管理，它分为三个部分：本地工作区，本地版本库（CMDB）的远程版本库。其中本地版本库有一个暂存区。 本地工作区就是你的工程所对应的本地文件夹 本地版本库是工作区（本地文件夹）下的.git隐藏文件夹。 远程版本库是你的工程在网络上的备份。 3.文件 文件时Git的基本配置项SCI（软件中发生变化的基本单元） 当一个文件被创建或者修改时，它与本地版本库中的相应文件不一样了，此时它处于“已修改”状态。 已修改的文件，可以通过gitadd命令，添加到暂存区，此时它处于“已暂存”状态。 已暂存的文件，可以通过gitcommit，把暂存区的文件汇总成一个commit，然后提交到本地版本库，此时它处于“已提交“”状态。 也可以通过gitcommit-a命令将已修改的文件提交commit。 4.操作 gitstatus可以查看当前工作目录的状态。 显示出来的文件总共有三种状态分别是 1.已添加至暂存区，未提交的（add后未commit的文件） 2.已修改，未暂存的 3.为追踪到的文件 gitdiff比较暂存区和工作区的文件的差异 gitdiffHEAD可以查看某个commit中的文件和当前工作区中的文件的差别 想要把本地的提交记录提交到远程，可以执行gitpush命令。 如果要把远程的提交记录拉回到本地，可以执行gitfetch命令。 如果要把远程的工程下载到本地，可以执行gitclone命令 如果要把远程工程拉到本地，并且立即和自己的本地版本合并，可以用gitpull命令。 要撤销本地工作区到暂存区的更改，可以用gitreset<file> 要撤销commit，可以用gitreset<commit> 5.分支 使用分支，相当于从现有的版本线上又分出来一条，可以加一些和以前不一样的版本分别管理，还可以合并，非常方便。 一次只能在一个分支上工作，要跳转分支，需要gitcheckout<branch> 要创建新分支，可以用gitcheckout-b<branch> 如果两个分支有共同的祖先，在某个时刻可以把这个有共同祖先的分支和自己合并，命令是gitmerge<branch> 6.总结（github官方的cheatsheet） 安装Git GitHub提供了包含图形界面的桌面客户端，通过客户端可以完成大部分常用的仓库操作，同时可以自动更新Git的命令行版本，以适应新的场景。 GitHubDesktop https://desktop.github.com/ GitHub的Linux和POSIX版本可以在官方的GitSCM网站上获取。 Git全平台版 http://git-scm.com 配置工具 对所有本地仓库的用户信息进行配置 $gitconfig--globaluser.name"[name]" 对你的commit操作设置关联的用户名 $gitconfig--globaluser.email"[emailaddress]" 对你的commit操作设置关联的邮箱地址 创建仓库 创建一个新的仓库或者从一个现有的链接获取仓库 $gitinit[project-name] 创建一个本地的仓库，并设置名字 $gitclone[url] 下载一个项目以及它所有的版本历史 更改 检查已有的编辑并执行commit操作 $gitstatus 列出所有新建或者更改的文件，这些文件需要被commit $gitdiff 展示那些没有暂存文件的差异 $gitadd[file] 将文件进行快照处理用于版本控制 $gitdiff--staged 展示暂存文件与最新版本之间的不同 $gitreset[file] 将文件移除暂存区，但是保留其内容 $gitcommit-m"[descriptivemessage]" 将文件快照永久地记录在版本历史中 批量更改 命名一系列commit以及合并已完成的工作 $gitbranch 列出当前仓库中所有的本地分支 $gitbranch[branch-name] 建立一个新分支 $gitcheckout[branch-name] 切换到一个特定的分支上并更新工作目录 $gitmerge[branch-name] 合并特定分支的历史到当前分支 $gitbranch-d[branch-name] 删除特定的分支 重构文件 重定位并移除版本文件 $gitrm[file] 从工作目录中删除文件并暂存此删除 $gitrm--cached[file] 从版本控制中移除文件，并在本地保存文件 $gitmv[file-original][file-renamed] 改变文件名并准备commit 保存临时更改 暂存一些未完成的更改 $gitstash 临时存储所有修改的已跟踪文件 $gitstashpop 重新存储所有最近被stash的文件 $gitstashlist 列出所有被stash的更改 $gitstashdrop 放弃所有最近stash的更改 查阅历史 浏览并检查项目文件的发展 $gitlog 列出当前分支的版本历史 $gitlog--follow[file] 列出文件的版本历史，包括重命名 $gitdiff[first-branch] [second-branch] 展示两个不同分支之间的差异 $gitshow[commit] 输出元数据以及特定commit的内容变化 撤销commit 擦除错误并更改历史 $gitreset[commit] 撤销所有[commit]后的的commit，在本地保存更改 $gitreset--hard[commit] 放弃所有更改并回到某个特定的commit 同步更改 注册一个远程的链接，交换仓库的版本历史 $gitfetch[remote] 下载远程仓库的所有历史 $gitmerge[remote]/[branch] 合并远程分支到当前本地分支 $gitpush[remote][branch] 上传所有本地分支commit到GitHub上 $gitpull 下载书签历史并合并更改 
第141篇文章[0]
01软件构造的多维度视图和质量目标（软件构造） 软件构造的多维视图 三个维度 （1）编程时&运行时（2）时间&时刻（3）微观和宏观从这三个维度来看待软件构造，那么在这写维度的组合下，我们更关注一些什么呢？下图或许能解答你的疑惑！如图中所展示的九个内容，在下面将一一做出说明。 编程时的视图下 对于微观上的视图（Code-levelview），我们更加关注的是源代码：sourcecode。在这个视图下，主要分析代码的逻辑组织，即源代码是怎样在基本的编程块，例如函数、类、方法、接口等，在这些的基础上的逻辑组织。对于宏观的视图（Component-levelview），我们更加关注的则是整个工程的结构：architecture。此时，像文件、路径、包、库以及他们之间的相关性，则更加值得我们注意，换句话来说，在这个视图下，主要跟分析代码的物理组织。而在特定的时刻下，源代码和整体工程的特定形态也是我们分析代码的编程情况中必不可少的部分。最后，在一段时间内，也可以说是一定周期内（软件的开发呈现一定的周期性，这个问题之后或许会再来探讨），我们更关注的是发展和变化，在这段时间内修改的内容，添加的方法等等，而这些变化，人为的记录未免强人所难，这时，一个好的软件管理工具的使用能大大提高软件开发的效率，暂且按下不提。 （1）Build-time，moment，code-levelview 源代码在代码各部分的基础上是怎样逻辑组织的，例如函数、类、方法、接口等，以及它们之间的关系。而这些又可以从三个层面来看待：词汇层面、语法层面（例如：AbstractSyntaxTree（AST））、以及语义层面（例如：ClassDiagram） 词汇层面 即程序代码中使用的语句、字符串、以及变量以“近乎自然语言的风格+遵循特定的变成语法”的组织形式形成一种半结构化的源代码语言，这既方便了程序员的阅读，同时方便编译器的编译。如图，相信即使不懂Java语言，也能轻松看懂图中的代码做了一些什么事，而这样的组织结构，让不同的程序员在阅读他人的代码时节约时间。 语法层面 对于语法的层面，更加注重的是软件执行的过程，或者说是软件执行的算法流程。以图中左侧代码为例，构造出了AST（语法分析树），对应的就是程序执行的流程同样对于数据或者文件的操作也同样可以构造除AST来描述整个操作的流程。而AST的目的就是将程序彻底结构化，把源代码变成一棵树，对树做各种操作就是对源代码的修改。这应该怎么理解呢？以上图文件读取为例，在开发过程中，对读入文件的方式做出修改的话，只需要修改图中的①部分。这样结构分明的一棵树，便于修改的一种组织方式，对于我来说是没办法拒绝的。 语义层面 语义的含义是指源代码具体现实什么目标，例如：用UML来描述接口、类、属性、方法及它们之间的关系。而这些通常用图形化或者形式化的方法来表达“需求”和“设计”思想。如下图：该图相信可以清晰的表示人和学生、教授之间的关系，以及人与地址之间的关系。 （2）Build-time,period,andcode-levelview 主要关注的是编码时，代码的改变情况，即Codechurn代码变化，包括添加的行、文件的改进或删除、从一个版本到另一的版本的变化。而实现这些的管理，仅仅依靠自己是非常困难的，因此我们一般会使用一些版本控制工具。例如图中红色区域，就是该次修改的项目。更加清晰直观的表现出了变化的发生位置，设想这样一个场景，昨天保存的代码已经通过测试没有问题，而今天出现了bug，通过这样的版本控制工具就能尽快的定位到代码可能出错的位置。 (3)Build-time,moment,andcomponent-levelview 在这三个视图下，我们所关注的是代码的组织情况，简单来说就是在开发程序的时候会有很多的类、很多的文件，当然我们可以任意的放在工程里，但这样就会出现一个问题，如果想要对程序进行更改，那什么应该更改，什么不该更改这个问题就会需要耗费大量的时间去思考以及记录。一种好的组织方式就是利用模块化的方式来组织文件。比如功能类似的、完成某个功能的文件放在一个包里，这样上面的问题就迎刃而解了。如图中的ADT等。 Library 对于组织程序文件的时候，一种最简单的方法就是利用库函数（library）的形式来进行组织。在编程时，很多情况下，大部分的功能其实并不需要我们自己编写，大部分情况下我们可以调用第三方的库文件中的方法直接使用，就像使用编程指令一样使用库中的功能，例如： System.out.println("HelloWorld"); 除了编辑阶段，在构建阶段也可以使用库文件，例如我们可以用maven提供的资源；在测试阶段很多的第三方库也为我们提供了便利。 Linkingwithalibrary 但库文件毕竟是第三方提供的，那么我们如何去使用这些库文件呢？回想一下刚开始使用java的时候，我们需要配置java环境以及资源目录，而这些工作就是为了在之后的代码编写过程中告诉程序库文件的位置。但仅仅找到是不够的，我们要做的第二步就是告诉程序怎么把库文件链接到程序中，链接的方式有两种，一种是静态链接，一种是动态链接。关于链接的内容可以参考学习《深入理解计算机系统》，在这里只作简单介绍。静态链接是将库被拷贝进入代码形成整体，执行的时候无需提供库文件，这种链接发生在构造阶段，当然这样做的坏处就是当库文件更新升级的升级后，程序中的库文件相关资源是不会发生改变的；而动态链接则是在程序运行时，通过地址动态的使用库文件中的资源，因此，在将程序打包发送时，不要忘记将用到的库文件一并打包发送给客户！如图是一个模块化的UML图，与代码级别不同的是，这个图不在将视线聚集在方法和类等之间的关系，而是例如图中shoppingcart和orders之间。 (4)Build-time,period,andcomponent-levelview 在这些维度下，其实我们所关注的也是代码的改变情况，简单来说，也就是希望我们能够知道在这个阶段中，我们对这个代码做了什么改变。没错！还是版本控制工具！softwareconfigurationitem！比如说window在不同的阶段会有不同的版本，我们就希望能把它记录下来。例如图中，我们希望记录每个文件的不同的开发版本，而最后我们所发布的finalversion实际上就是file1的1.3，file2的1.2，以及file3的1.4的版本。而版本控制工具除了记录的功能外，它还提供了另一个非常重要的功能，支持协同开发。通常一个大的工程，不可能由一个人甚至是几个人来完成，他有可能是由一个大的几十甚至几百人的团队来负责开发的，那么这个时候就需要协同工作，在工程的不同分支上开发完成部分功能以及对这些功能的集成。如上图，可能每个分支就是不同的模块的功能的开发，这样能够在一定程度上不影响别人的工作状况下独立的完成自己的工作。 运行时的视图下 运行时，程序被载入目标机器，开始执行在code-levelview的维度，我们关心的是逻辑实体，例如：对象、函数等，在内存中如何呈现？其实很简单，我们使用的java是一种面向对象的编程语言，在程序进行运行的时候，我们所关注的就是程序在某一个时间点到底有多少个对象，以及对象里面的值是什么样的。而在模块化的角度，我们更关注的是多个模块在运行时的配置是什么样的，即在软件层面，物理实体（OS、network、hardware等等）在物理硬件环境中如何呈现？目前很多的程序都是采用分布式的情况来进行配置的，什么的是分布式呢，简单来说，就是一个程序并不是就安装在一个机器上，而可能是被分割成了几部分，安装在了不同的机器上来进行运行的。在时刻视角下，我们可能更关注的是程序在内存中的情况，程序占用内存的空间有多大，程序在某个时间点生成了多少个对象。在时间或者周期的角度，我们关注的是这个程序在执行时到底需要多大的内存等问题。 (5)Run-time,moment,andcode-levelview 在当前视图下，我们关注的就是程序在某一个时间点到底有多少个对象，以及对象里面的值是什么样的。这时候我们引入一个snapshotdiagram（代码快照图）来描述当前我们所关注的信息。如上两图，我们所关注的信息就一目了然了。而该图的含义与结构我们暂且按下不提。同样另外一个我们所使用的方法是memorydump（内存信息转储），这种工具科技方便的查看内存的使用情况。最常见的memorydump工具相信我们都并不陌生任务管理器！它就能告诉我们在运行过程中，程序的一些内存占用信息。 (6)Run-time,periodandcode-levelview 这个角度我们所看重的是代码的执行情况，这也可以通过一个UML图来表示，这时的UML图我们称之为运行视图，或者也可以称之为时序图，这个时序图就描述了在和层序运行的时候，多个类、多个方法之间是怎么进行调用的。当然我们还可以利用一些工具，例如一些列的tracing也就是追踪的工具，来了解到程序在执行的时候的一些信息，即用日志记录程序执行的调用次数。如下图： (7)Run-time,moment,andcomponent-levelview 在这个维度下，我们从模块的角度来看待代码的组织情况，即程序在不同的机器或者单元上的配置情况，如下图： (8)Run-time,period,andcomponent-levelview 在这最后一个维度下，我们关注的是整个系统的调用情况或系统的使用情况，我们可以通过日志文件从系统的层面上看待程序的使用情况，例如程序被调用、被挂起、程序结束等信息。如下图： 总结 将以上八个维度下的关注重点放在同一张表格中，我们就得到了本文讨论的内容：软件构造的多维度视图。表格中被红色框矿主的部分就是软件构造这门课会涉及的部分，而其他的知识点也推荐大家去了解知识点对应的内容。从不同的维度下看待软件构造，梳理了一遍之后，相信我们对如何构造使用工具来对软件进行监视和了解有了进一步的认识，当然还有如何构造一个好的软件也有了初步的判断，但更多的内容还需要之后慢慢探索。 引用 以上博文中的资料均引用自2021年春季学期软件构造课程（任课教师：王忠杰感谢老师的倾囊相授！）中的内容，加上个人对其的稍许理解。 欢迎各位相约探讨！ 
第142篇文章[0]
[软件构造]2020春HIT软构心得(IDEA+MAVEN+TravisCI) HIT的软构课程推荐使用Eclipse编写代码，并且三次实验都默认你使用Eclipse，而像我这样喜欢好看的IDE的人当然会选择用IDEA来编写代码。因此本文会讲述如何在IDEA环境下来完成软构实验的一些内容，并且简单讲述Maven的一些小技巧，以及如何用TravisCI进行在线build。 （使用的IDEA版本为2020.3.3，社区版） 目录 IDEA使用tips IDEA下用Maven构建项目 如何用TravisCI进行在线build 总结 IDEA使用tips 1.利用集成的Git进行相关操作 事实上，IDEA的功能是强大的，它集成了Git，并且让Git的许多操作变得十分简便易懂。 （关于Git的安装及使用本文不再赘述，B站教程很多，个人推荐尚硅谷） 对于一个新建工程，首先在最上面的一堆菜单选项中找到"VCS"，然后点击"CreateGitRepository"就可以创建本地仓库。 在创建了Git的本地仓库后，就可以点击IDEA上方的Git栏，看到下图所示界面。 点击Commit，可以将修改好的代码上传到本地仓库；点击Push，可以将本地仓库的代码上传到GitHub。这两个功能是实验中最常用到的功能。 需要注意的是，在第一次push前，需要先设置remotes（即下方的ManageRemotes）。点进去之后，可以创建新的remote。这里remote的名字只是你给URL地址起的一个别名，可以随便起。 在push过程中，我们可以选择将本地仓库的内容推送到一个远程仓库。在软构实验中，就是推送到专门的实验仓库中。 注意，push过程中，你有两个地方可以更改。第一个是你的remote，代表远程仓库的地址，第二个紧跟在remote后面，代表远程仓库的分支名字。通常我们都会推送到master分支上，所以将名字改为master即可。 此外，如果你在自己的实验仓库页面修改了分支名字，比如将初始生成的main分支改为master，那么第一次push很可能失败，因为有可能出现分支合并错误。你可以将分支改回main，再推送一个master；或者在写代码前先将远程仓库pull下来，这样就不会产生分支合并错误。 在今年的实验3中，还需要新建分支。此处直接点击"NewBranch"（需要至少commit一次该按钮才会亮起），输入新分支的名字点击创建即可。默认会勾选"Checkoutbranch"，代表新建分支后，自动将头指针移动到该分支。 2.设置test目录 根据目录要求，你需要在lab工程下创建src和test这两个目录。通常src会在新建工程时自动创建好，而test目录需要我们自己创建，创建好后如下图所示： 但是我们会发现，在test目录下，无法直接像在src目录下那样直接创建一个java文件。此时需要我们更改一些设置：右键工程根文件夹，然后选择“OpenModuleSettings”。 进入下图所示界面后，右键test目录，将其设置为“Tests”即可，之后你会发现test目录变为了绿色，那就代表设置成功。 设置成功后，你就可以正常地在test目录下添加java文件，来对你的代码进行测试。 （有关Junit的使用方法，网上也有很多教程，此处不再赘述） 3.测试代码覆盖率 在第二个实验中，会让你用Eclipse中的EclEmma来统计Junit测试用例的代码覆盖度。但在IDEA中你是找不到这个插件的（因为这个插件是为Eclipse设计的），取而代之，你可以找到JaCoCo。但没关系，你可以放心使用，因为EclEmma在2.0版本之后是基于JaCoCo设计的。 在编写完Junit测试代码并点击小绿色箭头测试前，你可以看到这个界面： 为了使用JaCoCo，首先点击最下面的"ModifyRunConfiguration"，进入如下界面： 默认设置都不用动，但你需要选择"CodeCoverage"栏右边的那个"Modify"选项，点开如下： 为了选择JaCoCo，你需要勾选"Specifyalternativecoveragerunner"。勾选之后，下方会多出一个选项： 默认选项应该是IntelliJIDEA，你只需要选为JaCoCo即可。 更改完设置以后，再次点击绿色箭头，选择第三个选项"Run‘xxx’withCoverage"，之后就会在右边显示相关的覆盖率数据。通常来讲不用过分追求百分百覆盖率，这不现实，也没必要。但是如果覆盖率很低，那就说明你需要重新设计测试代码，尽可能地去让每个函数的每个分支都能被测试到。 IDEA下用Maven构建项目 在课程中，会讲到软件构造的整个流程，其中一步就是Build，也就是构建。而Maven就是一个很棒的构建工具，此外它也是一个依赖管理工具和项目管理工具，能通过配置文件中的依赖关系从中央仓库中下载项目所需的外部库。 由于笔者能力有限，对于Maven的许多功能研究的并不透彻，只能做到抛砖引玉，同时让读者避开一些坑。下面开始讲如何用Maven构建一个项目。 1.添加Maven框架支持 依旧是右键工程根目录，点击"AddFrameworkSupport"。 之后在界面中勾选Maven，点击OK，就将Maven添加到你的工程中了。 （如果添加之后出现Errorreading，点击右边Maven框中的转圈的箭头按钮即可） 添加完之后，我们欣（wu）喜（yu）地发现项目的目录结构变了，同时多出了一个pom.xml配置文件，如下图。 但是！实验手册对目录结构有明确要求，我们不想改变目录结构！ 那有人就说了，我不用Maven不就行了！逃避虽然可耻，但有用！ Maven还是要用的，毕竟之后我们还要验证我们的程序是否能脱离本机环境跑起来，而这也是实验手册的要求。毕竟，仅仅能让代码在你的机器上跑起来是不够的！ 2.更改Maven目录结构 让我们先看看目录结构都改变什么了。首先是src目录，原先它是我们代码的根目录，现在代码的根目录变成了src\main\java，而test目录也变成了src\test\java（虽然之前的test目录也能用）。 这其实是Maven约定的目录结构（具体的目录结构可以去网上搜，很多详解）。而我们为了更改目录结构，就不得不打开pom.xml这个配置文件了！ 初始时，配置文件里会有如下信息（看不懂就对了，我也看不懂，就能看懂个UTF-8） <?xmlversion="1.0"encoding="UTF-8"?> <projectxmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"> <modelVersion>4.0.0</modelVersion> <groupId>groupId</groupId> <artifactId>test</artifactId> <version>1.0-SNAPSHOT</version> <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> </properties> </project> 现在我们在其中加上一些信息。 <?xmlversion="1.0"encoding="UTF-8"?> <projectxmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"> <modelVersion>4.0.0</modelVersion> <groupId>groupId</groupId> <artifactId>test</artifactId> <version>1.0-SNAPSHOT</version> <build> <sourceDirectory>src</sourceDirectory> <testSourceDirectory>test</testSourceDirectory> </build> <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> </properties> </project> 没错，就是多了一段build信息！更新配置文件信息后，你会看到这样一个小框： 直接点击按钮，它会帮你根据更新后的配置信息更改项目结构。让我们看看更新后的目录结构： src目录又回来了！test目录也回来了！问题成功解决！接下来你就可以把那些与实验无关的文件夹删掉了： 有的人会说，我直接像之前那样更改ModuleSettings不行吗？答案是否定的，不然我也不会去一个我看不懂的配置文件中去修改信息了2333 现在这个目录结构就符合实验手册的要求了。但是还没完！我们还需要往配置文件里加点信息。 3.添加Junit4依赖 我们在build项和version项中间加一些依赖关系信息： <dependencies> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> </dependency> </dependencies> 如果不加这个信息，你之后在用Junit4写测试用例时，是无法用maven构建成功的！ 如果以后你需要添加别的依赖关系，只需要按照dependency书写的格式，在dependencies中新加一个条目即可。 简单来说，dependency中的这三条信息可以唯一确定一个依赖条目，就像是函数中的一对一映射一样。至于这三条信息具体写什么，可以直接去Maven中央仓库网页（MavenRepository:Search/Browse/Explore(mvnrepository.com)）去查找，人家都会给你写好的。 4.用Maven进行测试 在右侧的Maven菜单中，双击Lifecycle中的test选项，Maven就会自动帮你执行test以前包括test的所有步骤。这里我们是想用Maven帮我们跑测试用例。 之后，我们就会看到一些输出信息，其中就可以看到关于测试用例的信息。 （中间如果出了什么错误信息可以百度，因为我也不知道会遇到什么千奇百怪的错误，我自己也遇到过各种错误，就挺离谱的） 请注意，想要让Maven识别你的测试文件，你需要以一定的格式来命名测试文件，比如xxxTest或者TestXXX。在测试过程中，我发现如果将文件名改成别的（比如单走一个t），Maven就不会输出测试信息。 5.控制台输出乱码 在刚才测试的过程中，如果你输出了一些中文信息，可能会出现乱码的情况！如果出现乱码，请试一试如下的解决方案（不保证百分百好用，不好用还可以继续百度） 如下图，修改pom.xml中的properties信息，新加两行。 <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <argLine>-Dfile.encoding=UTF-8</argLine> </properties> 至此关于Maven的一些使用方法就讲完了，由于笔者能力有限，如有错误，恳请斧正！ 如何用TravisCI进行在线build 其实本来可以不用Maven来如此费力的构建项目的（过程中还会出现许多莫名其妙的错误毁心态）。 不过一方面，如果想从走软构方向，这些东西是一定要会的，另一方面就是，Maven是我们接下来用TravisCI进行在线build的基础。 有关TravisCI如何注册、使用的方法，可以自行百度，教程多得很。接下来我们只是讲解如何用它在线build一个Java项目。 其实很简单，首先你需要在根目录下新建一个yml类型的文件 .travis.yml （注意，travis前面还有一个点） 然后复制如下代码： language:java jdk:openjdk8 branches:master install:mvninstall-DskipTests=true-Dmaven.javadoc.skip=true script:mvntest （如果你是手写，请务必记住，每一个条目的冒号后面都有一个空格！这是语法要求！不添加空格会识别不了相关信息） 其中，language条目说明了你的代码使用的是什么语言；jdk条目说明了你的jdk版本（比如jdk8）；branches条目说明了从GitHub仓库上的哪个分支去找代码；script条目相当于一个脚本，说明了要执行的命令，比如"mvntest"（就是上一节中的用Maven跑测试代码的命令） （至于install那个命令我也不知道什么意思，实在是能力有限） 之后你只需要把这个文件和仓库里的其他文件一起push到仓库中就可以了！TravisCI会很聪明地找到这个文件，然后开始根据这个文件帮你在线Build。如果你的项目在本机上可以用Maven成功构建，那么大概率在线build也不会出问题。 在等待10多秒之后，TravisCI就会提示你build成功，同时输出一些日志信息，在这里你同样可以看到测试信息（下图只截取成功时的部分画面，测试代码背景是本课程的lab2） 至此，你已经成功地让自己的项目脱离本机环境运行起来了，可喜可贺！ 总结 以上就是我在用IDEA进行软构实验中的一些小心得（和踩坑体验），希望能让学弟学妹少踩一些坑！当然，这篇文章并不是一篇保姆级教学，因此一些基础知识仍然需要在网上搜索资料，自行学习（这也是对能力的一种锻炼）。希望对你们有帮助！ 
第143篇文章[0]
软件构造(一)srcrefspecmasterdoesnotmatchany的解决方案 在使用Git向Github上面push代码的时候,出现了 error:srcrefspecmasterdoesnotmatchany. 的问题,查阅了很多博客的解决方法针对于我的这次提交都无法解决该问题.最后发现是在push的时候没有切换分支导致的.只需要加入一句 gitcheckout分支名字 成功把分支切换成master分支,就可以解决这个error成功push项目代码啦!!! 
第144篇文章[0]
软件构造(四)Override与Overload Override重写重写是子类对父类的允许访问的方法的实现过程进行重新编写,返回值和形参都不能改变。 重写不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常,也不能出现新的函数. 在面向对象原则里，重写意味着可以重写任何现有方法。参数列表与被重写方法的参数列表必须完全相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5及更早版本返回类型要一样，java7及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 方法的重写规则 1.父类的成员方法只能被它的子类重写。 2.声明为final的方法不能被重写。 3.声明为static的方法不能被重写，但是能够被再次声明。 4.若子类和父类在同一个包中，那么子类可以重写除了声明为private和final的所有方法。 5.若子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 6.重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 7.构造方法不能被重写。 8.如果不能继承一个类，则不能重写该类的方法。 当需要在子类中调用父类的被重写方法时，要使用super关键字。 classBird{ publicvoidmove(){ System.out.println("鸟儿可以叫"); } } classCooingextendsBird{ publicvoidmove(){ super.move();//应用super类的方法 System.out.println("鸽子可以咕咕咕"); } } publicclassTestCooing{ publicstaticvoidmain(Stringargs[]){ Birdb=newCooing();//Cooing对象 b.move();//执行Cooing类的方法 } } 执行结果应为 鸟儿可以叫 鸽子可以咕咕咕 Overload重载重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法都必须有一个不一样的参数类型列表。 最常用的地方就是构造函数的重载。 重载的规则 1.被重载的方法必须改变参数列表(参数个数或类型不一样)；2.被重载的方法可以改变返回类型；3.被重载的方法可以改变访问修饰符；4.被重载的方法可以声明新的或更广的检查异常；5.方法能够在同一个类中或者在一个子类中被重载。6.无法以返回值类型作为重载函数的区分标准。 publicvoidCat(intage,Stringname){ System.out.println("name:"+name+"\n"+"age:"+age); } publicvoidCat(Stringname,intage){ System.out.println("name:"+name+"\n"+"age:"+age); } 重写与重载的区别 重写重载参数不变变返回类型不变可变异常可减少删除,但不可抛出新的或更广的可变访问可以降低限制可变 总的来说,Overload除了参数必须要改,其他都是可以改的,相当于一个同名函数,为了做区分当然要在参数上有区别啦,不然他怎么知道该调用哪一个qwqq;而Override则可改范围很小,参数,返回类型皆不可变,是在原函数的框架内进行重写,受到的限制明显大于Overload. 
第145篇文章[0]
软件构造(三)正则表达式 正则表达式语法 字符说明\将下一字符标记为特殊字符、文本、反向引用或八进制转义符。eg，n匹配字符n。\n匹配换行符。*零次或多次匹配前面的字符或子表达式(co*匹配c和coo)+一次或多次匹配前面的字符或子表达式(co+不匹配c)?零次或一次匹配前面的字符或子表达式\r匹配一个回车\s匹配任何空白字符,包括空格,制表,换页符\n匹配换行符\d数字字符匹配,等效于[0-9]\D非数字字符匹配,等效于[^0-9]\w匹配任意字类字符,等效于[A-Za-z0-9]\W匹配任意非字类字符,等效于[^A-Za-z0-9]^匹配输入字符串开始的位置。如果设置了RegExp对象的Multiline属性，^还会与"\n"或"\r"之后的位置匹配。$匹配输入字符串结尾的位置。如果设置了RegExp对象的Multiline属性，$还会与"\n"或"\r"之前的位置匹配。[xyz]匹配包含的任一字符集[a-z]匹配指定范围内的任何字符[匹配a到z的范围内的任何小写字母] 查找子串中是否包含了Cooing子串: Stringpattern=".*Cooing.*"; Stringcontent="qwqqqqCooingqwqqqqq"; booleanisMatch=Pattern.matches(pattern,content); System.out.println("字符串中是否包含了'Cooing'子串?"+isMatch); 在Java中，\\表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。Java中正则表达式中需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在Java的正则表达式中，两个\\代表其他语言中的一个\，这也就是为什么表示一位数字的正则表达式是\\d，而表示一个普通的反斜杠是\\。 
第146篇文章[0]
软件构造(二)spec规约 spec规约是使用者（client）和实现者（implementor）之间的妥协与契约，即是一种在使用时必须要遵循的要求的说明，也是一种在在实现时需要遵循的原则.一般书写在每一个类和每一方法前面.由@param、@throws、@return组成. /** *Insertaintervalwithitsstart,end,andlabel *Labeledintervalsconflictif:theyhavethesamelabelwithdifferent *intervals,ortheyhavedifferentlabelswithoverlappingintervals. * *Forexample,ifthissetis{"A"=[0,10),"B"=[20,30)}, *insert("A"=[0,10))hasnoeffect *insert("A"=[10,20))throwsIntervalConflictException *insert("B"=[10,20))throwsIntervalConflictException *insert("C"=[20,30))throwsIntervalConflictException *insert("D"=[30,40))adds"D"=[30,40) * *@paramstartthestartoftheinterval(thelowendoftheinterval) *@paramendtheendoftheinterval(thehighendoftheinterval) *@paramlabelthelabeltoadd *@throwsIntervalConflictException-ifthelabelisalreadyexisted, *andthestartandendarenotthesamewiththenewones; *orthere'saexistedintervalwhoserangeconflictwiththenewone. */ 约定俗成的规矩是使用者需要在满足前置条件的情况下，才能得到正确的结果. 行为等价性:对于用户来讲,提供的同一个spec，若都被满足了，那么就算做等价.所以重点就是要站在用户端看待问题，只要同一个spec被满足，则说明实现了相同的功能，即同一个spec所有实现是等价的.不能单看代码结果不一样,就说两个实现不等价. spec的强弱判断和比较方法:前置条件越弱,后置条件越强,spec越强.(前者用户所需遵守规则少,后者用户得到的信息更详细)因为前置条件必须被满足，所以后置条件的比较是在前置假设成立的条件下进行的，在很多情况下，前置条件的限制使得后置条件从不同变为相同. 
第147篇文章[0]
软件构造(五)异常 Checked异常、Unchecked异常：编译器可帮助检查你的程序是否已抛出或处理了可能的异常（checked异常）必须捕获并指定错误处理器handler，否则编译无法通过；类似于编程语言中的statictypechecking. ErrorsandRuntimeExceptions（unchecked异常）不需要在编译的时候用try…catch等机制处理. Checked异常的处理机制：声明、抛出、捕获、处理、清理现场、释放资源等：Declaringexceptions(throws)声明“本方法可能会发生XX异常”Throwinganexception(throw)抛出XX异常Catchinganexception(try,catch,finally)捕获并处理XX异常，不管程序是否碰到异常，finally都会被执行Unchecked异常也可以使用throws声明或try/catch进行捕获，但大多数时候是不需要的，也不应该这么做 掩耳盗铃，对发现的编程错误充耳不闻当要决定是采用checkedexception还是uncheckedexception的时候，问一个问题：“如果这种异常一旦抛出，client会做怎样的补救？”如果客户端可以通过其他的方法恢复异常，那么采用checkedexception；如果客户端对出现的这种异常无能为力，那么采用uncheckedexception；异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。错误可预料，但无法预防，但可以有手段从中恢复，此时使用checkedexception。如果做不到这一点，则使用uncheckedexception.自定义异常类如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛。子类型方法可以抛出更具体的异常，也可以不抛出任何异常。如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。 
第148篇文章[0]
软件构造-学习笔记6：对于final关键字的理解 在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。 修饰类：当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。修饰方法：使用final修饰方法时，说明这个方法不允许被重写、修改，相当于“锁定”。修饰变量：final成员变量表示常量，只能被赋值一次，赋值后值不再改变。当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。就如同Snapshot里的双箭头含义一样：不可以指向其他地方。在本质上是一个意思，因为对于引用类型说，引用的值是一个地址，final要求该值，即地址的值不发生变化。final修饰一个成员变量（属性），必须要显式的初始化。 
第149篇文章[0]
软件构造-学习笔记4：Javafor遍历是如何判断数据是不是list的最后一位 Javafor遍历是如何判断数据是不是list的最后一位 if(employees.size()-1==employees.indexOf(e)){ 如果该表达式成立，则说明数据为list的最后一位 
第150篇文章[0]
软件构造-学习笔记10：Try-Catch中finally的用法 Try-Catch中finally的用法 Java中的Finally关键一般与try一起使用，在程序进入try块之后，无论程序是因为异常而中止或其它方式返回终止的，finally块的内容一定会被执行。 考题类型：判断try-catch块中多catch异常下的代码执行顺序：finally块中内容一定会执行。 
第151篇文章[0]
软件构造-学习笔记8：一种自定义sort排序依据的方法 intervals.sort((x,y)->(int)(x.getStart()-y.getStart())); 
第152篇文章[0]
软件构造-学习笔记5：一种处理整数时间点和字符型时间的方法 publiclongdaysBetween(StringstartTime,StringendTime)throwsParseException{ SimpleDateFormatDateFormat=newSimpleDateFormat("yyyy-MM-dd"); Datedate1=DateFormat.parse(startTime); Datedate2=DateFormat.parse(endTime); Calendarcal=Calendar.getInstance(); cal.setTime(date1); longtime1=cal.getTimeInMillis(); cal.setTime(date2); longtime2=cal.getTimeInMillis(); longbetween_days=(time2-time1)/(1000*3600*24); returnInteger.parseInt(String.valueOf(between_days)); } publicDatedateiswhat(longpoint)throwsParseException{ SimpleDateFormatDateFormat=newSimpleDateFormat("yyyy-MM-dd"); Datedate1=DateFormat.parse(startTime); CalendarrightNow=Calendar.getInstance(); rightNow.setTime(date1); rightNow.add(Calendar.DAY_OF_YEAR,(int)point); DateDT=rightNow.getTime(); returnDT; } Date和Calendar类的灵活使用注意DateFormat的使用，有助于这种转换。 
第153篇文章[0]
软件构造-学习笔记7：重载（overloading）和重写（overriding）的区别 重载（overloading）和重写（overriding）的区别 文章目录 重载（overloading）和重写（overriding）的区别重载（overloading）重写（overriding） 重载（overloading） 重载(overloading)是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。 事实上，重载也可以针对同一函数针对不同传入类型进行设计，如在实验三中可以针对为IntervalSet和MultiIntervalSet进行重载，以展示出不同的行为。在一个类中，同名的方法有不同的参数列表，这是重载表现出的效果重载的参数列表一定要是不同的。这里的参数列表可以看做不同的对象。发生重载一定是在一个类中，重载是针对不同的对象有不同的操作。重载是实现多态的一种方式（编译阶段）重载对返回类型没有要求，但不能有两个同名同参数列表、返回类型不同的函数。 重写（overriding） 重写是子类对父类的允许访问的方法的实现过程进行重新编写,返回值和形参都不能改变。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如：父类的一个方法申明了一个检查异常IOException，但是在重写这个方法的时候不能抛出Exception异常，因为Exception是IOException的父类，只能抛出IOException的子类异常。在面向对象原则里，重写意味着可以重写任何现有方法。 重写是发生在两个类之间，即子类对父类中的方法进行重新定义。但子类不可以改变父类方法的方法名，参数列表，返回类型（除非子类的返回值是它父类的返回值的子类）。重写也是实现多态的一种方式（运行阶段）重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常在重写方法中，对访问修饰符的限制，子类一定要大于父类（public>protected>default>private) 
第154篇文章[0]
软件构造-学习笔记9：可维护性的常见度量指标 可维护性的常见度量指标 指标： 圈复杂度代码行数可维护性指数继承的层次数类之间的耦合度单元测试的覆盖度 实际方法： 继承的层次数类之间的耦合度单元测试的覆盖度聚合度与耦合度 模块化编程：高内聚&低耦合 DirectMapping直接映射FewInterfaces尽可能少的接口SmallInterfaces尽可能小的接口ExplicitInterfaces显式接口InformationHiding信息隐藏 
第155篇文章[0]
软件构造-学习笔记2：解决在已经push至Github后，.gitignore文件无法生效的问题 原因是：.gitignore只能忽略那些没有被纳入版本管理的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除，然后再提交：方法：打开GitBash，进入你想删除本地缓存仓库的目录，之后执行： gitrm-r--cached. gitadd. gitcommit-m'update.gitignore' 之后正常push，.gitignore文件即可正常生效。 
第156篇文章[0]
软件构造-学习笔记3：解决SelectedClassfilename‘HelloWorld.Java‘mappedtonotjavafiletype“”的问题 原因：不小心创建了同名的文本文件，idea将其认定为模板存储在了FileTypes中，这时只需要打开：settings-Editor-FileTypes，在左侧边栏找到你报错的相关文件类型，将右下方的固定模板删去即可。 
第157篇文章[0]
软件构造-学习笔记1：解决使用IDEA通过HTTPS链接无法提交代码至github的问题 解决使用IDEA通过HTTPS链接无法提交代码至github的问题 一、初次尝试解决： 首先是遇到了如图所示的报错：起初猜测是网络环境问题，之后尝试SCIENCE上网之后遇到新的报错：OpenSSLSSL_read:Connectionwasreset,errno10054查阅前人经验得知：首先，造成这个错误很有可能是网络不稳定，连接超时导致的。当时给出的解决方式是在GitBash中使用如下命令： gitconfig--globalhttp.sslVerify"false" 据查看文档得知，该命令作用为解除git对SSL证书错误的的限制，这个错误并不重要是系统证书的问题，系统判断到这个行为会造成不良影响，所以进行了阻止，只要设置跳过SSL证书验证就可以了。 初次使用确实有效，但似乎每次重启电脑后在push之前都需要输入该命令，十分麻烦。 二、使用SSH 参见文章GitHub如何配置SSHKey感谢博主@前端向朔的分享，配置成功后push过程顺利。 
第158篇文章[0]
软件构造实验总结 Lab1 现在做完三个实验再回头看Lab1，发现真是基本没干什么，只是简单地熟悉了一下Java编程。 P1：MagicSquares 我遇到的问题主要是要实现从文本中读入数据并进行合法性判断的功能。通过上网查阅资料，最终学会了读操作，需要用到FileReader和BufferedReader。这是第一次的上网自学，当时还觉得挺了不起的，后来发现在编程过程中上网自学一些Java中的有关知识简直就是家常便饭。 后续的数据操作此处不再描述，我当时的代码风格还是C的风格，比如使用大量一维数组、二维数组进行遍历查找，但在后面的实验中有逐渐改进，慢慢地习惯了使用List、使用迭代器等等。 P2：TurtleGraphics 这个任务是我第一次接触到的填空式的程序设计，形式很新颖，趣味性较强。 任务要求主要就是参照给出的spec完成几个方法的实现，使得已有测试用例能通过（这也是在此门课程中首次接触到Junit测试）。每个待实现的方法其实都是一些简单的算法。值得一提的是一个求解凸包的问题，我的大致思路是先找到所有点当中的最左下角的点，然后遍历其他的点，找到能使得turtle旋转角度最小的点，移动到该点上，再用相同方法继续查找下一个点，以此类推，直到回到一开始选定的最左下角的点，说明已经找到了所有点当中在最外圈的点，也就得到了凸包。 当我把一个到处是空白的框架逐渐丰满起来，测试用例也一个个通过的时候，还是很欣慰很有成就感的。 P3：SocialNetwork 这个任务要求设计实现一个FriendshipGraph类来表示现实生活中的社交关系图，还要设计一个Person类来表示人，最后还要自己编写测试用例来对FriendshipGraph中的方法进行测试。当时觉得做了好多的工作，现在回头看只想一笑而过。 在这个任务的完成过程中，我对ADT以及TDD有了一个最最基本的了解（虽然这时候还不知道这些名词），初次感受了一个比较完整的简易的程序设计流程。至于完整的设计流程，在Lab2和Lab3中逐渐揭开了神秘的面纱。 Lab2 从Lab2开始，总算是接触到这门课程的核心了 ADT和OOP，实验难度也有了明显提升。 P1：PoeticWalks 其实P1可以被分成两个部分，第一个部分是设计一套ADT，第二个部分是利用这个设计好的ADT来完成一个应用，也就是poeticwalks。 这个任务和Lab1的P2一样，也是填空，不过这次填的东西就多了。查看已经给出的Graph类，里面声明了一些方法，通过对每个方法的spec进行阅读，确定首先要做的就是划分等价类、写测试策略并设计测试用例。这其实就是TDD的一个体现，以前的编程中我都是直接完成实现，在这里按照要求应该先完成测试用例，这样能使方法在实现之后能立即得到测试，确保其正确性及健壮性，而且在设计测试用例的过程中，我们也能提前考虑各种特殊情况，在完成实现的时候加以注意。 完成了测试用例，接下来就该实现Graph了。任务中要求了两种实现方式ConcreteEdgesGraph和ConcreteVerticesGraph，这就是对OOP中继承关系的体现了。两个类都是对抽象接口Graph的实现，只是两者的内部逻辑不一样，但对外表现出来的都是一样的，都能提供Graph中的方法。两者的测试用例也是一样的，都继承自Graph的测试用例，因为实现了相同的方法。 在实现过程中，还涉及到了mutability/immutability说明、AF、RI、safetyfromrepexposure以及每个方法的spec，这些内容部分已经给出，但绝大部分仍需要自行添加完善。这些说明能使代码具有更加清晰的逻辑，既能帮助别人读懂自己的代码，又能方便日后查看代码时快速明白当初的想法，还能提醒自己时刻注意所写程序的正确性、安全性，保证不会在以后被客户端恶意操作，同时也可以清楚展示给客户端各个方法能实现什么功能，以及该怎么输入。 接下来就进入了P1的第二个部分，应用ADT实现一个poeticwalks的功能。还是一样的，先阅读spec了解清楚各个方法要实现的功能，设计相关的测试用例，然后再实现各方法，完善mutability/immutability说明、AF、RI、safetyfromrepexposure以及每个方法的spec。在实现各个方法的时候，由于已经设计好了ADT，所以能直接调用其中的方法，省去了很多工作。 P2：ReimplementSocialNetwork 这个任务其实和P1的第二部分是一样的，就是用已设计的ADT来完成一个应用的实现，而这个实现正是在Lab1中完成过的社交关系图。有了Graph这个强有力的ADT，很快就能实现FriendshipGraph这个类。同样，mutability说明、AF、RI、safetyfromrepexposure以及每个方法的spec也是不可省略的。虽然这里只需要把Lab1的测试用例直接拿来用就行，但为了按照更标准的模板来，我还是划分等价类、写测试策略并设计测试用例，使得测试更加充分。 到此，我在Lab2中初次体验了面向ADT的编程。不同于以往的直接面向应用场景的编程，面向ADT的编程是一种具有更长远眼光的做法，能在以后更加方便的实现更多具有相似性的应用；面向应用场景的编程虽然在短期看来很方便，但是可扩展性差，在遇到相似情景的时候，只能做大量重复工作，将相似的功能进行反复开发，效率较低。 Lab3 到了Lab3，就是整个三次实验的最高潮了，除了一份实验手册上的思路介绍，所有的东西都要自己设计与实现，是真正的从零开始。 在Lab3里，要求实现三个应用 排班管理系统、操作系统进程调度管理系统和课表管理系统。对这三个应用进行分析，能发现它们均涉及到具有不同特征的“时间段集合”这种对象，为了提高软件的可复用性和可维护性，可以设计构造一套ADT。 一开始我还比较迷茫，就参照着Lab2中设计Graph的那一套流程来进行。首先是设计IntervalSet，在实验手册的提示下，我确定了IntervalSet这个抽象接口中的方法，并完成了每个方法的spec。然后划分等价类、写测试策略并设计测试用例。接下来对IntervalSet这个接口进行实现，不同于Lab2的是，这里只用完成一个实现，即CommonIntervalSet。mutability说明、AF、RI和safetyfromrepexposure也是需要完成的。这样做下来，我也渐渐明白了设计流程。 在IntervalSet的spec里面，提到里面的时间段的“标签”是不能重复的，这在排班管理系统里适用，但在操作系统进程调度管理系统和课表管理系统里就不适用了。于是，我们还要设计实现另一种“时间段集合”MultiIntervalSet，它允许不同时间段的标签“重复”。在实验里，我选择将其直接实现为具体的类，而没有设计相关的接口。和IntervalSet一样，MultiIntervalSet各个方法的设计与spec撰写、测试策略、测试用例、方法的具体实现、mutability说明、AF、RI和safetyfromrepexposure都得按顺序逐一实现。 接下来就要对局部共性进行设计与实现了，这里将用到设计模式的相关知识，我最终选择的是装饰器模式。对于三个维度的特性 是否允许空白、是否允许重叠及是否需要周期性重复，将它们分别看做一层层装饰，逐一地加到原本的对象上。由于排班管理系统会基于IntervalSet来实现，而它要求不允许空白和不允许重叠的特性，我就为之设计了两个用来装饰的类NoBlankIntervalSet和NonOverlapIntervalSet，它们都继承同一个类IntervalSetDecorator，而这个类是对接口IntervalSet的一个实现。然后再将NoBlankIntervalSet和NonOverlapIntervalSet逐层装饰到IntervalSet上，就得到了用于排班管理系统的DutyIntervalSet。 需要注意的是，NoBlankIntervalSet中添加了原IntervalSet中没有的方法checkNoBlank，为了能调用这个方法，在装饰的时候需要把它放在最外面的一层，并将对象声明为NoBlankIntervalSet而非IntervalSet。这样看来似乎有些打破装饰器模式，但我在查阅资料时发现这被称为半透明的装饰器模式，介于装饰器模式和适配器模式之间，允许对接口进行改变以增强功能。 类似的思路，继续为基于MultiIntervalSet的操作系统进程调度管理系统和课表管理系统设计MultiIntervalSetDecorator类，注意它并不是实现MultiIntervalSet，因为MultiIntervalSet已经是具体的类，而非抽象接口。这样似乎又违背了装饰器模式，但是其思路是完全一致的。再设计并实现NonOverlapMultiIntervalSet、OverlapMultiIntervalSet和PeriodicMultiIntervalSet，并通过包装得到用于操作系统进程调度管理系统的ProcessIntervalSet和用于课表管理系统的CourseIntervalSet。同NoBlankIntervalSet一样，PeriodicMultiIntervalSet也属于半透明的装饰器模式。 设计完三个面向应用的ADT，再追加三个immutable的类Employee、Process和Course，以及自主设计的API，我们的基础框架就整个完成了。运用这一套自主设计的ADT，我们已经能解决不少现实中的问题了。 接下来的工作就是用已经开发好的ADT来完成一开始提到的三个应用 DutyRosterApp、ProcessScheduleApp和CourseScheduleApp。在已有的ADT的帮助下，每个应用中要求的功能都比较容易想到解决方案。几个小的问题，例如对日期的计算、随机执行时间的“随机”的实现等，在自学LocalDate和Random后都能很快解决。比较大的问题就是对于各种情况的分类讨论不够全面，总是会出现一些漏洞，导致手动测试的时候bug的花样繁多。我也在这段修改代码的长时间斗争中感受到了数学基础和算法设计的重要性，以后还得多多加强这方面的训练。 实现完三个应用之后，还需要给排班表新增一个从文件读入初始化数据的功能，这不仅需要会读文件的操作，还要学会正则表达式的写法。于是我又继续上网找代码示例自学（不得不说自学能力真的太重要了！），参照着代码示例写出员工信息、排班信息和排班时间的正则表达式后，运用Pattern和Matcher，以正则表达式为模板，在文件输入里面进行匹配，获取需要的信息。一旦获取到信息，后续的初始化就很容易了。 好不容易完成所有的功能，又要面临新的变换 排班管理系统要允许一个员工多时间的排班，课程管理系统不允许任何课程的重叠。但是还好我们是面向ADT的编程，在面对这些变化时是比较容易的，不用大量重复的工作，只需少量的修改。 排班管理系统的变化，只需要新增一个NoBlankMultiIntervalSet类来继承MultiIntervalSetDecorator，再修改DutyIntervalSet，将其变成用NoBlankMultiIntervalSet和NonOverlapMultiIntervalSet装饰的MultiIntervalSet，最后修改DutyRosterApp中利用IntervalSet特性实现的少量代码即可。 课表管理系统的变化更加简单，甚至不用新增类，只需修改CourseIntervalSet即可，将其装饰由OverlapMultiIntervalSet改变为NonOverlapMultiIntervalSet就完成了，几乎不用花时间。 到此，软件构造的三个实验就都圆满结束了。我从一个毫无设计思维、只会一来就实现各种方法的小白，成长为了一个初步具有设计意识与习惯的软件构造初学者。期间，我体会了ADT与OOP的魅力，感受了面向ADT编程带来的良好的可维护性和可复用性，当然也经历了各种困难与崩溃。但是最终回顾整个过程时，收获颇丰，成就感十足，内心还是十分喜悦与欣慰的。 关于Git 在三次实验中，提交成果均用到了git，下面记录一下用到的几个指令： gitinit 创建一个本地git仓库 gitclonexxxx克隆一个仓库中的代码 gitremoteaddoriginxxxx将本地仓库与远程仓库关联 gitremote-v查看远程仓库相关信息 gitadd(filename)将工作区内容交到暂存区 gitcommit-m"xxxx"将暂存区内容提交到本地仓库 gitstatus查看仓库状态 gitpush-uoriginmaster将本地仓库内容提交到远程仓库上 gitcheckout-bchange创建新的分支change gitcheckoutmaster切换回master分支 关于在线build 我使用的是GitHub上的在线build，在Actions目录下选择JavawithMaven: 选择后会自动生成maven.yml文件，将其中版本修改为指定版本（我用的jdk8)再提交即可： build的结果如下： 注意在build之前要先提交一个pom.xml文件，否则可能会失败，文件内容如下（其中artifactId需根据每个仓库的仓库名进行修改）： 
第159篇文章[0]
软件构造主要知识点总结 软件构造基础 软件构造的多维度视图 三个维度（buildtime--runtime;moment--period;codelevel--componentlevel）和八个视图 软件构造各阶段活动 质量因素 外部质量因素影响用户，内部质量因素影响软件本身和它的开发者，外部质量取决于内部质量。 外部质量因素：正确性、健壮性、可扩展性、可复用性、兼容性、时空性能、可移植性、易用性、功能性、及时性、可验证性、完整性、可修复性、经济性等 内部质量因素：可读性、可理解性、简洁性、大小等 各质量因素往往不能同时满足，需要折中，但正确性永远不能与其他质量因素折中。 SCM与VCS 软件配置管理(SCM)追踪和控制软件的变化，软件中发生变化的基本单元，如文件，被称为软件配置项(SCI)。当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。 版本控制系统(VCS)有三种：本地版本控制系统（存储在本地）、集中式版本控制系统（存储在服务器）、分布式版本控制系统（同时存储在本地和服务器）。 Git 四个区域及基本指令： 分支的创建与合并： ADT与OOP 数据类型 基本数据类型：如int、long、boolean、double、char等 对象数据类型：如String、BigInteger等 基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。 类型检查 静态类型检查：在编译阶段进行类型检查，避免将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误等。 动态类型检查：在运行阶段才会进行类型检查，例如非法的参数值、非法的返回值、越界、空指针等。 静态类型检查是关于数据类型的检查，而动态类型检查是关于值的检查。 Mutability/Immutability 不变对象：一旦被创建，始终指向同一个值/引用，会产生大量拷贝（需要垃圾回收） 可变对象：拥有方法可以修改自己的值/引用，效率更高但不够安全（但可通过防御式拷贝解决） 关于final final类无法派生子类 final变量无法改变值/引用 final方无法被子类override Snapshotdiagram 基本类型: 对象类型: mutable对象，单线椭圆:immutable对象，双线椭圆:可变的引用，单线箭头；不可变的引用，双线箭头： specification 规约(spec)是程序与客户端达成的一致，给程序员和用户双方都确定了责任，调用时双方都要遵守。规约能隔离“变化”，无需通知客户端；提高代码效率；解耦，客户端不需了解具体实现等。 前置条件(precondition)：对客户端的约束，在使用方法时必须满足的条件,使用@paramannotation说明。后置条件(postcondition)：对开发者的约束，方法结束时必须满足的条件，使用@returnannotation说明返回值的要求，使用@throwsannotation说明出现异常时的处理。 更强的spec意味着更放松的前置条件和更严格的后置条件。可以用更强的spec去替换弱的spec。越强的spec，意味着implementor的自由度越小、责任越重，而client的责任越轻。 ADT的四种操作类型 Creators构造器：用于创建一个新的对象。 Producers生产器：用于使用一个已存在的对象产生一个新的对象。 Observers观察器：不对数据做任何改动，查看一个已存在的对象的各个值。 Mutators变值器：用于改变对象的属性。 测试creators,producers,andmutators：调用observers来观察这些operations的结果是否满足spec。 测试observers：调用creators,producers,andmutators等方法产生或改变对象，来看结果是否正确。 风险：如果被依赖的其他方法有错误，可能导致被测试方法的测试结果失效。 ADT各特性 表示独立性(RepresentationIndependence)：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。 不变量(Invariants)：与程序运行无关，在任何时候都应该满足的一些条件，例如immutability。 表示空间R 和抽象空间 A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。 表示不变性(RI)：某个具体的“表示”是否是“合法的”;也可看作所有表示值的一个子集，包含了所有合法的表示值;也可看作一个条件，描述了什么是“合法”的表示值。 抽象函数(AF)：表示空间R和抽象空间A之间映射关系的函数，即如何去解释R中的每一个值为A中的每一个值。 表示泄漏的安全声明(safetyfromrepexposure)：给出代码并未对外泄露其内部表示的理由。 接口、抽象类、具体类 接口与类用于定义和实现ADT，接口确定ADT的规约，类对ADT进行具体实现。接口之间可以继承和扩展；一个类可以实现多个接口，从而具备多个接口中的方法；一个接口可以有多种实现类；接口中不应提供构造函数（不可被实例化），但允许静态方法和default方法实现；类中必须实现所继承接口的所有方法，允许添加新的方法。抽象类介于接口和具体类之间，比接口具体，比具体类抽象。 继承与Override 子类可以继承父类的成员变量和方法。 严格继承：子类只能添加新方法，无法重写父类中的方法，如父类中的方法使用了final关键字限定。 重写(override)：子类的方法覆盖了父类的方法。重写的方法应该与父类方法有相同的方法名和参数，只有这样编译器才会判定为重写的方法。使用@Overrideannotation强制检查是否重写了父类中的方法。 多态与Overload 三种多态：特殊多态、参数化多态、子类型多态 特殊多态与重载 重载(overload)即多个方法具有同样的名字，但有不同的参数列表或返回值类型。参数列表必须不同，返回值类型、可见性、异常可相同也可不同。重载不仅发生在类内，也可发生在父类与子类之间。 注意：override是在运行阶段决定的，而overload是在编译阶段决定的。 参数化多态与泛型编程 使用泛型参数代替具体的类型。运行时泛型消失，用具体类型代替。通配符"?"只在使用泛型的时候出现，不能在定义中出现。 子类型多态 “B是A的子类型”意味着每一个B都是A，从规约的角度说是“每个B都满足A的规约”。使用instanceof可以检查一个对象在运行时的实际类型。 等价性 引用等价性：使用==进行判断，是否等价取决于指向的地址是否相同。基本数据类型必须使用这种办法判断等价性。 对象等价性：使用equals()进行判断。对于对象类型，使用这种办法来判断等价性，如果只用==则是在判断两个对象的ID(内存里的同一空间)是否相等。 equals()与hashCode() 不可变对象的equals()与hashCode()方法继承Object中的方法。在Object中，equals()的实现为==，而hashCode()的实现为返回内存地址。这往往不是程序员想要的，所以这两个方法需要重写。注意重写的时候不要写成重载，参数类型仍然应该是Object。 可变对象的等价性 观察等价性：指在不改变状态的情况下，两个mutable对象是否看起来一致。 行为等价性：指调用对象的任何方法都展示出一致的结果。 对可变类型来说，人们往往倾向于实现严格的观察等价性，但在有些时候，观察等价性可能导致bug，甚至可能破坏RI。例如：如果某个mutable的对象包含在Set集合类中，当其发生改变后，集合类的行为不确定。 可变类型等价设计实现行为等价性即可，无需重写equals()和hashCode()（与不可变类型要求相反），如果要判断两个可变对象是否看起来一致，最好定义一个新方法。 面向可复用性和可维护性的软件构造 复用 面向复用编程(programmingforreuse)：开发可以复用的软件 基于复用编程(programmingwithreuse)：复用已有的软件开发 源代码层面：方法和语句 模块层面：类和接口 库层面：API 架构层面：框架 LSP 子类型多态：客户端可用统一的方式处理不同类型的对象。 Liskov替换原则内容： 协变： 逆变： 泛型类型是不支持协变的，如ArrayList<String>是List<String>的子类型，但List<String>不是List<Object>的子类型。这是因为发生了类型擦除，运行时就不存在泛型了，所有的泛型都被替换为具体的类型。 但是在实际使用的过程中是存在能够处理不同的类型的泛型的需求的，如定义一个方法参数是List<E>类型的，但是要适应不同的类型的E，于是可使用通配符"?"来解决这个需求。 委派 委派/委托(delegation)：一个对象请求另一个对象的功能。 如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，也就是说一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。 委托发生在object层面，而继承发生在class层面。 CRP 利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。组合就是多个不同方面的delegation的结合。 SOLID设计原则 单一责任原则(SRP)：不应该有多于1个原因让你的ADT发生变化，否则就应拆分开。开放-封闭原则(OCP)：对扩展性的开放，对修改的封闭。Liskov替换原则(LSP)：子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异。接口分割原则(ISP)：不能强迫客户端依赖于它们不需要的接口 只提供必需的接口。客户端不应依赖于它们不需要的方法，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的端口。依赖转置原则(DIP)：具体模块应依赖于抽象模块，但抽象模块不应依赖于具体模块。换句话说：委托的时候要通过接口建立联系，而非具体子类。 设计模式 创建型模式（工厂方法模式）、结构型模式（适配器模式、装饰器模式）、行为类模式（策略模式、模板模式、迭代器模式、参观者模式） 共性样式1：只使用继承 例子： 共性样式2：继承+委派 例子： 面向健壮性与正确性的软件构造 健壮性与正确性 健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常。 正确性：程序按照spec加以执行的能力，是最重要的质量指标。 Error/Runtime异常、其他异常 Error：与代码无关，程序员通常无能为力，一旦发生，想办法让程序优雅的结束。也可以通过对外部环境的配置解决问题，如用户输入错误、设备错误、物理限制等。 Exception：一定是程序导致的问题，可以捕获、可以处理。 由于程序员对Error通常无法预料无法解决，因此重点关注可被解决的Exception Checked异常、Unchecked异常 黑盒测试 黑盒测试用于检查程序是否符合规约，不关心内部实现细节。理想情况是用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误。 等价类划分针对每个输入数据需要满足的约束条件划分等价类，从等价类中导出测试用例。 边界值分析方法大量的错误发生在输入域的“边界”而非中央，边界值分析方法是对等价类划分方法的补充。故可在等价类划分时，将边界作为等价类之一加入考虑。 等价类覆盖的方式 笛卡尔积：全覆盖，多个划分维度上的多个取值，要组合起来，每个组合都要有一个用例。测试完备，但用例数量多，测试代价高。 覆盖每个取值：每个维度的每个取值至少被1个测试用例覆盖一次即可，测试用例少，代价低，但测试覆盖度未必高。 白盒测试 白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例。通常由开发人员完成，一般较早执行。 独立/基本路径测试：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试用例使每一条基本路径被至少覆盖1次。 
第160篇文章[0]
Arrays.asList后对结果进行remove操作导致UnsupportedOperationException的解决方法 问题描述： 最近在完成实验的过程中，我想要将一个字符串数组转换为一个List，从而方便后续对其中元素进行检查，删除掉一部分非法元素。简单上网搜索资料以后，我发现了可以使用Arrays.asList的操作，将一个字符串数组转化为List，示例代码如下： String[]s={"aa","bb","cc"}; List<String>strlist=Arrays.asList(s); 但是当我使用这个方法完成代码，进行JUnit测试的时候却不能通过，查看FailureTrace时在这段代码处发现了UnsupportedOperationException的报错： 原因分析: 我们首先查看一下Arrays.asList的源码（按住"Ctrl"键，将鼠标指到"asList"上，即可选择查看其源码）： /** *Returnsafixed-sizelistbackedbythespecifiedarray.(Changesto *thereturnedlist"writethrough"tothearray.)Thismethodacts *asbridgebetweenarray-basedandcollection-basedAPIs,in *combinationwith{@linkCollection#toArray}.Thereturnedlistis *serializableandimplements{@linkRandomAccess}. * *<p>Thismethodalsoprovidesaconvenientwaytocreateafixed-size *listinitializedtocontainseveralelements: *<pre> *List&lt;String&gt;stooges=Arrays.asList("Larry","Moe","Curly"); *</pre> * *@param<T>theclassoftheobjectsinthearray *@paramathearraybywhichthelistwillbebacked *@returnalistviewofthespecifiedarray */ @SafeVarargs @SuppressWarnings("varargs") publicstatic<T>List<T>asList(T a){ returnnewArrayList<>(a); } 可以看到该方法返回的是一个ArrayList，继续查看这个ArrayList的源码，发现它并不是java.util.ArrayList的ArrayList，而是java.util.Arrays内部自己所包含的ArrayList。而这个内部类，继承了AbstractList类，没有重写remove方法： /** *@serialinclude */ privatestaticclassArrayList<E>extendsAbstractList<E> implementsRandomAccess,java.io.Serializable { privatestaticfinallongserialVersionUID=-2764017481108945198L; privatefinalE[]a; ArrayList(E[]array){ a=Objects.requireNonNull(array); } @Override publicintsize(){ returna.length; } @Override publicObject[]toArray(){ returna.clone(); } @Override @SuppressWarnings("unchecked") public<T>T[]toArray(T[]a){ intsize=size(); if(a.length<size) returnArrays.copyOf(this.a,size, (Class<?extendsT[]>)a.getClass()); System.arraycopy(this.a,0,a,0,size); if(a.length>size) a[size]=null; returna; } @Override publicEget(intindex){ returna[index]; } @Override publicEset(intindex,Eelement){ EoldValue=a[index]; a[index]=element; returnoldValue; } @Override publicintindexOf(Objecto){ E[]a=this.a; if(o==null){ for(inti=0;i<a.length;i++) if(a[i]==null) returni; }else{ for(inti=0;i<a.length;i++) if(o.equals(a[i])) returni; } return-1; } @Override publicbooleancontains(Objecto){ returnindexOf(o)!=-1; } @Override publicSpliterator<E>spliterator(){ returnSpliterators.spliterator(a,Spliterator.ORDERED); } @Override publicvoidforEach(Consumer<?superE>action){ Objects.requireNonNull(action); for(Ee:a){ action.accept(e); } } @Override publicvoidreplaceAll(UnaryOperator<E>operator){ Objects.requireNonNull(operator); E[]a=this.a; for(inti=0;i<a.length;i++){ a[i]=operator.apply(a[i]); } } @Override publicvoidsort(Comparator<?superE>c){ Arrays.sort(a,c); } } 再继续查看一下AbstractList类的源码，我们会发现它的remove方法被直接定义为了“thrownewUnsupportedOperationException();”： /** *{@inheritDoc} * *<p>Thisimplementationalwaysthrowsan *{@codeUnsupportedOperationException}. * *@throwsUnsupportedOperationException{@inheritDoc} *@throwsIndexOutOfBoundsException{@inheritDoc} */ publicEremove(intindex){ thrownewUnsupportedOperationException(); } 到这里就完美破案了，进行Arrays.asList的操作得到的是一个java.util.Arrays内部自己所包含的ArrayList，而它的remove方法继承的是AbstractList类中的remove方法，当我们试图对Arrays.asList的结果进行remove操作时，就会抛出UnsupportedOperationException。 解决方案： 新建一个java.util.ArrayList的ArrayList： List<String>inputword=Arrays.asList(input.split("")); List<String>inputwords=newArrayList<>(); inputwords.addAll(inputword); 
第161篇文章[0]
Java中的ArrayList和LinkedList 在Java中，我们经常使用到List这个类。这个类有多种实现，本文将着重分析其中最为常见的两个实现方式ArrayList和LinkedList。 其实从名字就不难猜到，ArrayList是基于数组的实现方式，LinkedList是基于链表的实现方式，但我们最好还是通过查看源代码进行更具体的分析。 首先查看两者的rep和creator部分： ArrayLIst: privatestaticfinallongserialVersionUID=8683452581122892189L; /** *Defaultinitialcapacity. */ privatestaticfinalintDEFAULT_CAPACITY=10; /** *Sharedemptyarrayinstanceusedforemptyinstances. */ privatestaticfinalObject[]EMPTY_ELEMENTDATA={}; /** *Sharedemptyarrayinstanceusedfordefaultsizedemptyinstances.We *distinguishthisfromEMPTY_ELEMENTDATAtoknowhowmuchtoinflatewhen *firstelementisadded. */ privatestaticfinalObject[]DEFAULTCAPACITY_EMPTY_ELEMENTDATA={}; /** *ThearraybufferintowhichtheelementsoftheArrayListarestored. *ThecapacityoftheArrayLististhelengthofthisarraybuffer.Any *emptyArrayListwithelementData==DEFAULTCAPACITY_EMPTY_ELEMENTDATA *willbeexpandedtoDEFAULT_CAPACITYwhenthefirstelementisadded. */ transientObject[]elementData;//non-privatetosimplifynestedclassaccess /** *ThesizeoftheArrayList(thenumberofelementsitcontains). * *@serial */ privateintsize; /** *Constructsanemptylistwiththespecifiedinitialcapacity. * *@paraminitialCapacitytheinitialcapacityofthelist *@throwsIllegalArgumentExceptionifthespecifiedinitialcapacity *isnegative */ publicArrayList(intinitialCapacity){ if(initialCapacity>0){ this.elementData=newObject[initialCapacity]; }elseif(initialCapacity==0){ this.elementData=EMPTY_ELEMENTDATA; }else{ thrownewIllegalArgumentException("IllegalCapacity:"+ initialCapacity); } } /** *Constructsanemptylistwithaninitialcapacityoften. */ publicArrayList(){ this.elementData=DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** *Constructsalistcontainingtheelementsofthespecified *collection,intheordertheyarereturnedbythecollection's *iterator. * *@paramcthecollectionwhoseelementsaretobeplacedintothislist *@throwsNullPointerExceptionifthespecifiedcollectionisnull */ publicArrayList(Collection<?extendsE>c){ Object[]a=c.toArray(); if((size=a.length)!=0){ if(c.getClass()==ArrayList.class){ elementData=a; }else{ elementData=Arrays.copyOf(a,size,Object[].class); } }else{ //replacewithemptyarray. elementData=EMPTY_ELEMENTDATA; } } 从上面的代码中，我们能看到ArrayList确实采用了基于数组的实现方式，rep中有用于记录List长度的size，还有三种形式的数组： 1）EMPTY_ELEMENTDATA是用于构造空数组的； 2）DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是用于构造空数组的，但它与EMPTY_ELEMENTDATA是有区别的，当之后出现第一个元素加入该数组时，它会扩展为大小为DEFAULT_CAPACITY（默认设置为10）的一个数组，即它在首次增加元素时对数组增加的长度有要求； 3）elementData是真正用来存储List中所有元素的数组，若它等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则会在出现第一个元素加入该数组时，扩展为大小为DEFAULT_CAPACITY（默认设置为10）的一个数组。 接下来再看看ArrayList的creator，发现同样有三种方式： 1）传入一个int型参数initialCapacity，这个参数指定List的初始长度。若参数大于0，则直接将elementData设置为大小为initialCapacity的数组；若参数等于0，则将elementData设置为EMPTY_ELEMENTDATA这个空数组；其余情况下，将会抛出异常； 2）不传入参数，则直接将elementData设置为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，可在之后加入第一个元素时再进行扩展； 3）传入一个Collection，将按照Collection的iterator给定的顺序将元素放入数组，再将数组赋值给elementData（要进行类的检查，若Collection不是ArrayList，会先进行转换），若Collection为空，将elementData设置为EMPTY_ELEMENTDATA这个空数组。 LinkedList: transientintsize=0; /** *Pointertofirstnode. *Invariant:(first==null&&last==null)|| *(first.prev==null&&first.item!=null) */ transientNode<E>first; /** *Pointertolastnode. *Invariant:(first==null&&last==null)|| *(last.next==null&&last.item!=null) */ transientNode<E>last; /** *Constructsanemptylist. */ publicLinkedList(){ } /** *Constructsalistcontainingtheelementsofthespecified *collection,intheordertheyarereturnedbythecollection's *iterator. * *@paramcthecollectionwhoseelementsaretobeplacedintothislist *@throwsNullPointerExceptionifthespecifiedcollectionisnull */ publicLinkedList(Collection<?extendsE>c){ this(); addAll(c); } privatestaticclassNode<E>{ Eitem; Node<E>next; Node<E>prev; Node(Node<E>prev,Eelement,Node<E>next){ this.item=element; this.next=next; this.prev=prev; } } 从上面的代码中，我们能看到LinkedList也确实采用了基于链表的实现方式（而且是双向链表） rep中有记录List长度的size，还有List中第一个和最后一个结点first和last。值得一提的是，Java中没有指针，但这里的实现原理类似于指针，不过是借助结点Node实现的，所以我们还是将LinkedList看做链表。 LinkedList的creator也比ArrayList简单，有两种：一种不传入参数的，创建空链表；一种传入一个Collection，将按照Collection的iterator给定的顺序将元素创建链表。 然后看一下最基本的增加单个元素的操作： ArrayList: /** *Appendsthespecifiedelementtotheendofthislist. * *@parameelementtobeappendedtothislist *@return<tt>true</tt>(asspecifiedby{@linkCollection#add}) */ publicbooleanadd(Ee){ ensureCapacityInternal(size+1);//IncrementsmodCount!! elementData[size++]=e; returntrue; } /** *Insertsthespecifiedelementatthespecifiedpositioninthis *list.Shiftstheelementcurrentlyatthatposition(ifany)and *anysubsequentelementstotheright(addsonetotheirindices). * *@paramindexindexatwhichthespecifiedelementistobeinserted *@paramelementelementtobeinserted *@throwsIndexOutOfBoundsException{@inheritDoc} */ publicvoidadd(intindex,Eelement){ rangeCheckForAdd(index); ensureCapacityInternal(size+1);//IncrementsmodCount!! System.arraycopy(elementData,index,elementData,index+1, size-index); elementData[index]=element; size++; } 发现有两种增加元素的方式： 1）不指定位置，会在请求增加一个长度之后，直接加在List最后； 2）指定位置，先检查位置参数index的合法性，若合法再请求增加一个长度，将插入位置后面的元素依次向后挪动一个位置，最后将要增加的元素插入指定位置。 LinkedList: /** *Appendsthespecifiedelementtotheendofthislist. * *<p>Thismethodisequivalentto{@link#addLast}. * *@parameelementtobeappendedtothislist *@return{@codetrue}(asspecifiedby{@linkCollection#add}) */ publicbooleanadd(Ee){ linkLast(e); returntrue; } /** *Linkseaslastelement. */ voidlinkLast(Ee){ finalNode<E>l=last; finalNode<E>newNode=newNode<>(l,e,null); last=newNode; if(l==null) first=newNode; else l.next=newNode; size++; modCount++; } 可以看见LinkedList直接将元素放入新的结点，并加在List的末尾。 再看一下删减单个元素的操作： ArrayList: /** *Removestheelementatthespecifiedpositioninthislist. *Shiftsanysubsequentelementstotheleft(subtractsonefromtheir *indices). * *@paramindextheindexoftheelementtoberemoved *@returntheelementthatwasremovedfromthelist *@throwsIndexOutOfBoundsException{@inheritDoc} */ publicEremove(intindex){ rangeCheck(index); modCount++; EoldValue=elementData(index); intnumMoved=size-index-1; if(numMoved>0) System.arraycopy(elementData,index+1,elementData,index, numMoved); elementData[--size]=null;//cleartoletGCdoitswork returnoldValue; } /** *Removesthefirstoccurrenceofthespecifiedelementfromthislist, *ifitispresent.Ifthelistdoesnotcontaintheelement,itis *unchanged.Moreformally,removestheelementwiththelowestindex *<tt>i</tt>suchthat *<tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt> *(ifsuchanelementexists).Returns<tt>true</tt>ifthislist *containedthespecifiedelement(orequivalently,ifthislist *changedasaresultofthecall). * *@paramoelementtoberemovedfromthislist,ifpresent *@return<tt>true</tt>ifthislistcontainedthespecifiedelement */ publicbooleanremove(Objecto){ if(o==null){ for(intindex=0;index<size;index++) if(elementData[index]==null){ fastRemove(index); returntrue; } }else{ for(intindex=0;index<size;index++) if(o.equals(elementData[index])){ fastRemove(index); returntrue; } } returnfalse; } /* *Privateremovemethodthatskipsboundscheckinganddoesnot *returnthevalueremoved. */ privatevoidfastRemove(intindex){ modCount++; intnumMoved=size-index-1; if(numMoved>0) System.arraycopy(elementData,index+1,elementData,index, numMoved); elementData[--size]=null;//cleartoletGCdoitswork } 与增加方法对应，同样是两种删减方法：一种按参数index查找（需要检查参数合法性），一种按元素查找，若能找到，则需要将删除位置后面的元素依次向前挪动一个位置，把原本的最后一个元素置为null，再将List的长度减1。 LinkedList: /** *Removesthefirstoccurrenceofthespecifiedelementfromthislist, *ifitispresent.Ifthislistdoesnotcontaintheelement,itis *unchanged.Moreformally,removestheelementwiththelowestindex *{@codei}suchthat *<tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt> *(ifsuchanelementexists).Returns{@codetrue}ifthislist *containedthespecifiedelement(orequivalently,ifthislist *changedasaresultofthecall). * *@paramoelementtoberemovedfromthislist,ifpresent *@return{@codetrue}ifthislistcontainedthespecifiedelement */ publicbooleanremove(Objecto){ if(o==null){ for(Node<E>x=first;x!=null;x=x.next){ if(x.item==null){ unlink(x); returntrue; } } }else{ for(Node<E>x=first;x!=null;x=x.next){ if(o.equals(x.item)){ unlink(x); returntrue; } } } returnfalse; } /** *Unlinksnon-nullnodex. */ Eunlink(Node<E>x){ //assertx!=null; finalEelement=x.item; finalNode<E>next=x.next; finalNode<E>prev=x.prev; if(prev==null){ first=next; }else{ prev.next=next; x.prev=null; } if(next==null){ last=prev; }else{ next.prev=prev; x.next=null; } x.item=null; size--; modCount++; returnelement; } 按元素查找，若能找到，则需要将删除位置前面和后面的结点（如果都有的话）链接起来，否则只需要修改单个结点的“指针”即可。 到此我们可以得出结论，ArrayList是基于数组的实现方式，LinkedList是基于链表的实现方式。结合源代码分析，我们还能发现在增删元素时，LinkedList性能会更好，因为不会涉及到移动元素，而ArrayList需要大量移动元素的操作。这启示我们在需要频繁修改List中元素的情境下，可以优先考虑LinkedList。 
第162篇文章[0]
设计模式之装饰器模式（Decorator） 在设计继承树的时候，我们会选择将最基础最普遍的方法（共性方法）放入最顶层的接口中去实现，而将各个特殊的方法（个性方法）在底层的具体子类中去实现。 对于一些局部共性（即一些类有，一些类没有的方法），我们可以选择使用装饰器模式。本文接下来将会对装饰器模式进行简单介绍。 装饰器模式 装饰器模式是设计模式中常见的一种，它以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。示意图如下： 在装饰器模式中的角色有： 抽象构件角色(Component)：给出一个抽象接口，以规范将要实现功能扩展的对象。 具体构件角色(ConcreteComponent)：定义一个将要实现功能扩展的类。 装饰角色(Decorator)：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰角色(ConcreteDecorator)：负责给构件对象实现扩展的功能。 publicinterfaceComponent{ publicvoidsampleOperation(); } publicclassConcreteComponentimplementsComponent{ @Override publicvoidsampleOperation(){   } } publicclassDecoratorimplementsComponent{ privateComponentcomponent; publicDecorator(Componentcomponent){ //delegation this.component=component; } @Override publicvoidsampleOperation(){ component.sampleOperation(); } } publicclassConcreteDecoratorAextendsDecorator{ publicConcreteDecoratorA(Componentcomponent){ super(component); } @Override publicvoidsampleOperation(){ super.sampleOperation(); //实现功能扩展  } } publicclassConcreteDecoratorBextendsDecorator{ publicConcreteDecoratorB(Componentcomponent){ super(component); } @Override publicvoidsampleOperation(){ super.sampleOperation(); //实现功能扩展  } } 变化 如果只有一个具体构件角色，那么可以考虑去掉抽象构件角色，把装饰角色作为一个具体构件角色的子类。示意图如下： 如果只有一个具体装饰角色，那么还可以把装饰角色和具体装饰角色合并成一个类。示意图如下： 透明性要求 装饰器模式对客户端的透明性，要求程序不要声明一个ConcreteComponent类型或者ConcreteDecorator类型的变量，而应当声明一个Component类型的变量。示例代码如下： Componentcomponet=newConcreteComponent(); ComponentconcretedecoratorA=newConcreteDecoratorA(component); 如下示例代码是错误的： ConcreteComponentcomponet=newConcreteComponent(); ConcreteDecoratorAconcretedecoratorA=newConcreteDecoratorA(component); 半透明的装饰器模式 如果能满足透明性的要求，则是纯粹的装饰器模式，它要求在不改变接口的前提下扩展功能。但是在实际的功能扩展中，往往需要创建新的方法，这就导致了“半透明”的装饰器模式的出现。即允许装饰器模式改变接口以实现功能扩展。这意味着客户端可以声明ConcreteDecorator类型的变量，从而调用在ConcreteDecorator类中才有的方法，示例代码如下： Componentcomponet=newConcreteComponent(); ConcreteDecoratorAconcretedecoratorA=newConcreteDecoratorA(component); concretedecoratorA.methodA(); 半透明的装饰器模式是介于装饰器模式和适配器模式之间的。装饰器模式不改变类的接口，通过改写方法来扩展类的功能。适配器模式并不扩展类的功能，但是会改变类的接口，以便和目标接口相符合。半透明的装饰器模式应用更广，也称做半装饰器、半适配器模式。 对比继承关系 再把装饰器模式和继承关系对比分析一下，两者都是要扩展类的功能，但是装饰器模式比继承关系更具灵活性。装饰器模式允许动态地决定增加或是删除扩展的功能，按照需求自由地进行扩展性能的组合；而继承关系是静态的，事先就要全部写好，在扩展性能较多的时候，会遇到“组合爆炸”的尴尬处境。但是在扩展性能较多的情况下，装饰器模式也有一定弊端，就是复杂程度较高，显得较为臃肿冗余。 
第163篇文章[0]
正则表达式学习笔记（统一用法） 
第164篇文章[0]
HIT软件构造LAB3随机进程调度的实现 首先列出需求：针对操作系统的进程调度管理系统，所需完成的功能为：Step1增加一组进程，输入每个进程的ID、名称、最短执行时间、最长执行时间；进程一旦设定无法再修改其信息。Step2当前时刻（设定为0）启动模拟调度，随机选择某个尚未执行结束的进程在CPU上执行（执行过程中其他进程不能被执行），并在该进程最大时间之前的任意时刻停止执行，如果本次及其之前的累积执行时间已落到[最短执行时间，最长执行时间]的区间内，则该进程被设定为“执行结束”。重复上述过程，直到所有进程都达到“执行结束”状态。在每次选择时，也可“不执行任何进程”，并在后续随机选定的时间点再次进行进程选择。 privateLinkedList<Process>processes=newLinkedList<Process>(); privateLinkedList<Process>finprocesses=newLinkedList<Process>(); processes存储未执行完成的进程finprocess存储执行完成的进程设置longstart=0为当前时刻因为我们的需求是一次性完成所有进程的调度，故设置循环条件 while(processes.isEmpty()) 然后进行第一步，随机挑选进程执行我们要用到Random函数设置max为链表processes当前的长度 max=processes.size(); Randomra=newRandom(); r=ra.nextInt(max); 得到一个在[0,max)之间的整形数索引，此随机数就是我们此次要操作的进程的组索引 但我们选择了某一个进程，也可能不进行任何操作，故设定一个跳过此次操作的概率（我设的五分之一） Randomrc=newRandom(); if(rc.nextInt(5)!=0){//后接执行操作 然后开始我们的调度，我的每个Process类中都存有该进程已执行的时长sum，故我们需要生成一个在区间(0,maxtime-sum]的随机数作为此次执行的时间（注意左开右闭，因为至少要执行一个时间单位）。并更新sum，将该执行插入进程执行表中（MultiIntervalSet）中，注意，start为当前时刻，start+temp为此执行操作结束时间，之后更新start为start+temp Randomrb=newRandom(); temp=rb.nextInt((int)(processes.get(r).getmax()-processes.get(r).getsum()))+1; temp1=processes.get(r).getmax(); temp1+=temp; processes.get(r).changesum(temp1); schedule.insert(start,start+temp,processes.get(r)); start+=start+temp; 判断sum的大小，若sum处于[最短执行时间，最长执行时间]的区间内，将该进程加入finprocesses中，并将其移出processes if(temp1>=processes.get(r).getmin()&&temp1<=processes.get(r).getmax()){ finprocesses.add(processes.get(r)); processes.remove(processes.get(r)); } 至此我们就完成了随机调度的操作 
第165篇文章[0]
HIT软构lab2中GraphPoet的一种实现 首先是第一个方法GraphPoet的实现 publicGraphPoet(Filecorpus)throwsIOException{ BufferedReaderbr=newBufferedReader(newFileReader(corpus)); Stringline; Stringfront,next; inttemp; Stringfulltxt=""; while((line=br.readLine())!=null){ fulltxt=fulltxt+line+"";//得到全文 } br.close(); fulltxt=fulltxt.toLowerCase();//大写转小写 String[]wordset=fulltxt.split("");//将句子以各种分句符号或空格划分，得到单词集合 for(inti=0;i<wordset.length-1;i++){ front=wordset[i]; next=wordset[i+1]; if(!graph.vertices().contains(front)||!graph.targets(front).containsKey(next)){//若front不在点集中或不含到next的边则添加一条边 graph.set(front,next,1); continue; } if(graph.targets(front).containsKey(next)){//若已有该边则weight++ temp=graph.targets(front).get(next)+1; graph.set(front,next,temp); continue; } } checkRep(); //thrownewRuntimeException("notimplemented"); } 首先将输入的文本提取到字符串text中，再用spilt方法进行处理，spilt仅根据空格切分即可，标点符号不能切割。因为单词后面接上标点符号有助于对上下文的判断，比如Hi,nicetomeetyou.如果将标点符号切割掉，就会将Hi这个单词与nice形成前后文，这不是我们所需要的。同时，我们生成诗句时也需要保留原标点符号。 然后是poet实现 publicStringpoem(Stringinput){ String[]wordset=input.split("");//把input分词 Stringstr=wordset[0]; Set<String>frontset=newHashSet<>(); Set<String>nextset=newHashSet<>(); inttemp=0; Stringtempstr; for(inti=1;i<wordset.length;i++){ tempstr=""; temp=0; frontset=graph.targets(wordset[i-1].toLowerCase()).keySet();//将wordset中的第i-1位的顶点的targets中所有顶点的label赋值给frontset nextset=graph.sources(wordset[i].toLowerCase()).keySet();//将wordset中的第i位的顶点的sources中所有顶点的label赋值给frontset for(Stringfront:frontset){//遍历寻找两个词之间是否存在“桥梁” for(Stringnext:nextset){ if(front==next){ temp++; tempstr=front; } } } if(temp==1){//若两词之间有且只有一条长度为1的桥 str=str+""+tempstr+""+wordset[i]; continue; } str=str+""+wordset[i]; } checkRep(); returnstr; //thrownewRuntimeException("notimplemented"); } 我的思路是将input中的词先spilt分词，然后将前后两个词放入循环，若查找到存在桥，就将桥加入输出字符串中 
第166篇文章[0]
HIT软件构造lab3中DutyRosterApp中函数isfull()的实现 HIT软件构造lab3中DutyRosterApp中函数isfull()的实现 首先该函数的需求是用户可随时检查当前排班是否已满（即所有时间段都已被安排了特定员工值班）、若未满，则展示给用户哪些时间段未安排、未安排的时间段占总时间段的比例。 用户输入的时间一般为xx年xx月xx日，我们需要通过函数LocalDate.of(intyear,intmonth,intday)来将输入的年月日转化为大小为输入日期到1970年1月1日之间的天数的整形数，通过此函数得到排班开始日期startdate，排班结束日期enddate首先创建一个大小为排班日期的boolean数组timelist period=enddate-startdate; boolean[]timelist=newboolean[(int)period]; 然后通过遍历所有有有排班的员工，将有排班的时间段赋值为true其中worker类为员工，包含员工信息 for(workerp:schedule.labels()){ start=p.getstart(); end=p.getend(); for(longi=start-startdate;i<end-startdate;i++){ timelist[(int)i]=true; } } 处理完此数组后再次进行循环来输出空闲时间段设置count计数器来记录空闲时间的数量，flag为判断位 for(intj=0;j<(int)period;j++){ if(timelist[j]==false){ count++; if(flag==0){ sparestart=j+startdate; flag=1; } } else{ if(flag==1){ spareend=j+startdate-1; System.out.println(LocalDate.ofEpochDay(sparestart)+"->"+LocalDate.ofEpochDay(spareend)); flag=0; } } } 循环中，若当前块为空且flag为0，将此块设置为空闲时间段的起点（加上startdate）继续遍历，碰到第一个非空闲块时将flag设回0，并将空闲时间段结尾段设为j-1+enddate并输出LocalDate.ofEpochDay(sparestart)+“->”+LocalDate.ofEpochDay(spareend)LocalDate.ofEpochDay()为将天数转回日期最后输出空白占比count/period（若count为0则不输出） 
第167篇文章[0]
HIT软件构造MultiIntervalSet中数据结构的设计 我在MultiIntervalSet中设计了两个子类一个为Nper(命名没有实际意义），用来存储label以及一个time类的链表，用以存储对一个目标的多次排班或调度 classNper<L>{ privateLlabel; privateLinkedList<time>timelist=newLinkedList<time>(); publicNper(LNlabel,longNstart,longNend){ this.label=Nlabel; timeNtime=newtime(Nstart,Nend); timelist.add(Ntime); } } 第二个子类为time，用以储存单次调度的起始时间与终止时间 classtime{ privatelongstart; privatelongend; publictime(longNstart,longNend){ this.start=Nstart; this.end=Nend; } } 说回MultiIntervalSet protectedLinkedList<Nper<L>>multilabels=newLinkedList<Nper<L>>(); 主要的数据结构为<Nper>的链表multilabels，每一个Nper中都会存储一个Llabel以及对其的调度表timelist。此种设计的好处就是，当需要取出对某个进程的调度信息（或某门课程的排课信息）时，只需要找到一次相应的Nper就可以调出他的所有时间调度。而对timelist插入时间时会进行排序（time的insert函数），timelist中根据index的大小顺序存储调度发生的时间。当所需调用时会更加的方便且清晰 
第168篇文章[0]
软件构造 关于git指令复习的进一步理解 笔者在前几天简单描述了我在lab2用git提交时出现的一个问题。今天我在复习软件构造课程时，读到了git作为SCM工具的简单应用，看见了这样的一张图： 我们提交实验时最常用的方法就是首先 gitadd<文件> 然后gitcommit-m“提交信息” 最后gitpushURL分支 实际上，这在上面的图中就是前三个步骤。而我在lab2中遇到的问题就是重复了第三步，在不同的localrepository（本地仓库上）进行gitpush，从而无法成功提交。当时我的解决方法就是找到了第一次进行提交的本地仓库，随后提交成功。另外一种解决办法就是gitpull，上图中的黄颜色的指令就是将远程仓库上的所有文件全部清空并下载到本地工作区。清空了全部内容，下一次的提交也就一定会成功了。 
第169篇文章[0]
软件构造 关于一个github提交错误原因的解决办法 笔者在完成lab2时还是周六的晚上，但当第二天修改好实验报告准备提交时，已经是晚上十点了，距离截止时间还有不到两个小时的时候，发现github提交时出现了错误！ 当我按照git提交流程一步一步的做到了 gitcommit-m"提交信息" 时，没有出现任何问题，但是当我最后即将 gitpushxxxxmaster 时，发现出现了网络问题，无法连接至github，这是一个很常见的问题，只需要重新提交几次就可以提交成功了，但是，我十分手欠地新建了一个文件夹，将原文件夹的数据拷贝过去。并在新文件夹中重新建立git仓库，重新提交。 于是当到了最后一步 gitpushxxxxmaster 时，出现了新的问题：git显示无法提交，这显然不是网络的问题，原因是我在原文件夹提交了commit信息，会导致无法再次提交文件，只有在原文件夹将文件成功push上传，才能提交其他文件。 于是，正在我焦头烂额的时候，我的室友给了我指导，他让我找回到原来的文件夹，在原文件夹里重新提交了好几次，最终上传成功。 当然，对这个问题，还有其他的解决方法：需要用到pull命令： gitpull--rebasexxxxmaster （xxxx为你的仓库名） 该命令会把个人仓库里的所有文件下载到你的新本地仓库中。 
第170篇文章[0]
软件构造 关于java的正则表达式 笔者在完成lab3时，正则表达式实在是造成了很大的困扰，下面就来简单介绍一下java中的正则表达式。 一个字符串其实就是一个简单的正则表达式，例如 HelloWorld 正则表达式匹配"HelloWorld"字符串。而“.”（点号）也是一个正则表达式，它匹配任何一个字符如："0"或"a"。 java.util.regex包主要包括以下三个类： Pattern类： pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher类： Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。 PatternSyntaxException： PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 在Java中，“\\”表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。在Java中，正则表达式中需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在Java的正则表达式中，两个 \\ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\。其实，类比一下C语言可以很好理解这一部分。 对于正则表达式的语法，网上有很多的参考资料，本文只是对正则表达式的匹配方式进行简单介绍，这里就不多赘述。 下面介绍Matcher类的方法，参考https://www.runoob.com/java/java-regular-expressions.html 索引方法 索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配： 序号方法及说明1publicintstart()返回以前匹配的初始索引。2publicintstart(intgroup) 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引3publicintend()返回最后匹配字符之后的偏移量。4publicintend(intgroup)返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。 查找方法 查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式： 序号方法及说明1publicbooleanlookingAt() 尝试将从区域开头开始的输入序列与该模式匹配。2publicbooleanfind()尝试查找与该模式匹配的输入序列的下一个子序列。3publicbooleanfind(intstart）重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。4publicbooleanmatches()尝试将整个区域与模式匹配。 替换方法 替换方法是替换输入字符串里文本的方法： 序号方法及说明1publicMatcherappendReplacement(StringBuffersb,Stringreplacement)实现非终端添加和替换步骤。2publicStringBufferappendTail(StringBuffersb)实现终端添加和替换步骤。3publicStringreplaceAll(Stringreplacement) 替换模式与给定替换字符串相匹配的输入序列的每个子序列。4publicStringreplaceFirst(Stringreplacement) 替换模式与给定替换字符串匹配的输入序列的第一个子序列。5publicstaticStringquoteReplacement(Strings)返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement方法一个字面字符串一样工作。 
第171篇文章[0]
软件构造 关于lab3对于时间的处理 本人最近完成了lab3的实验。在完成dutyroster类（排班表）时，需要对时间进行恰当的处理。因为面向现实生活时，必须要考虑不同年份、不同月份对计算时间差天数的处理。我在完成这次实验时也是产生了很大的困扰，最终在室友的帮助下，我利用java的localDate类实现了很好的处理。 下面介绍一下localDate类，我们直接用一组代码来理解： LocalDatelocalDate=LocalDate.now()； System.out.println("localDate="+localDate);//localDate=2021-07-05，直接获取当天的信息 System.out.println("localDate="+localDate.getDayOfWeek().getValue());//获取星期几 System.out.println("localDate="+localDate.get(ChronoField.ALIGNED_WEEK_OF_MONTH));//获取当前月的第几周 System.out.println(localDate.getDayOfYear());//获取本年中截止到今天已经过去的天数 System.out.println(localDate.with(TemporalAdjusters.firstDayOfMonth()));//得到所在月的第一天 System.out.println(localDate.withDayOfMonth(3));//得到所在月的第三天 System.out.println(localDate.with(TemporalAdjusters.lastDayOfMonth()));//得到所在月的最后一天 System.out.println(localDate.plusDays(10));//得到10天后的日期 通过上面的代码，可以对localDate有简单的理解。 在lab3中，我通过(endDate.toEpochDay()-startDate.toEpochDay())的表达式，来间接获得了起止天数差。 
第172篇文章[0]
软件构造 在Eclipse中进行JUnit测试 本人完成了学期的所有实验后，想起来在完成lab1时，对如何进行Junit测试没搞清楚，所以在这里详细记录一下JUnit测试的具体步骤。 首先右键工作项目，并选中最下面的properties； 然后在JavaBuildPath中选中ClassPath，并点击右侧的addliabrary 选择自己想要的JUnit版本，点击Finish 对想要测试的类新建测试用例，右键该类选择new后选择JUnitTestCase 在接下来的页面上要勾选setup点击next，并给自己想要进行测试的方法打勾。 点击Finish，即可看到生成的测试用例，之后就可以自己进行编写改动。 
第173篇文章[0]
HIT软件构造Lab1记录 目录 2实验环境配置 3实验过程 3.1MagicSquares 3.1.1isLegalMagicSquare() 3.1.2generateMagicSquare() 3.2TurtleGraphics 3.2.1Problem1:Cloneandimport 3.2.2Problem3:TurtlegraphicsanddrawSquare 3.2.3Problem5:Drawingpolygons 3.2.4Problem6:CalculatingBearings 3.2.5Problem7:ConvexHulls 3.2.6Problem8:Personalart 3.2.7Submitting 3.3SocialNetwork 3.3.1设计/实现FriendshipGraph类 3.3.2设计/实现Person类 3.3.3设计/实现客户端代码main() 3.3.4设计/实现测试用例 4实验进度记录 5实验过程中遇到的困难与解决途径 6实验过程中收获的经验、教训、感想 6.1实验过程中收获的经验和教训 6.2针对以下方面的感受 实验目标概述 本次实验通过求解三个问题，训练基本Java编程技能，能够利用JavaOO开 发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够 为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。 另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。 ⚫基本的JavaOO编程 ⚫基于EclipseIDE进行Java编程 ⚫基于JUnit的测试 ⚫基于Git的代码配置管理 实验环境配置 本实验使用了IDEA而不是pdf中给出的eclipse作为ide，不过还是通过pdf中给出的链接安装了eclipse，不过没有使用，在git官网下载了git，并在IDEA中下载了git和Junit插件，安装过程中并未出现困难 GitHubLab1仓库的URL地址： https://github.com/ComputerScienceHIT/HIT-Lab1-1190201517 实验过程 请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。 为了条理清晰，可根据需要在各节增加三级标题。 MagicSquares 幻方：对一个行列数相等的矩阵，若其每一行之和、每一列之和以及对角线之和都相等，则其为一个幻方（MagicSquare） 要求一： 设计一个程序来判断五个文件中的矩阵是否为MagicSquare，其中文件保存的矩阵需以\t分割每个数字。若是返回true，若不是或文件有错误则输出false并输出错误原因。 要求二： 设计一个函数来生成一个给定大小的MagicSquare，并存入到文件6.txt中，并用要求一中的和函数判断其是否为符合定义的MagicSquare。 isLegalMagicSquare() 对于读入的文件，构建二维数组存储其中的数字，读入过程中即可检查其行列是否相等、是否均为正整数，是否由\t分割等，若不符合定义则弹出报错终止程序。因为使用Integer.valueOf存入数组，在读取到空格时会报错，以此检验数字是否由\t分割 读入完毕后，对于得到的二维数组，计算其各行、列以及两对角线之和并依次比较，一旦发现不相等就跳出循环并返回false，若最终没有发现不相等，则返回true。 generateMagicSquare() 生成magicsquare的函数已经在手册中给出，因此我们只需检查输入的n是否合法（正奇数），不合法是终止函数返回false，合法时生成、写入文件并返回true。之后在用要求一的函数检验生成的文件即可。 TurtleGraphics 根据要求，我们要按照注释补全给定程序中缺失的特定功能的函数，来实现一个绘图工具，其能够实现绘制正多边形、计算正多边形内角、计算偏角等功能。 Problem1:Cloneandimport 从给定链接下载P2的文件包并导入项目中。 Problem3:TurtlegraphicsanddrawSquare、 通过已经给出的转向和前进指令来绘制正方形 Problem5:Drawingpolygons 绘制指定边数和边长的正多边形 Problem6:CalculatingBearings 通过给定朝向和点集，计算改变朝向的偏角值集 Problem7:ConvexHulls 利用BFS算法计算给定点集的凸包 Problem8:Personalart Submitting 通过IDEA的git插件，输入url提交至自己的github仓库中 SocialNetwork 通过Person和FriendshipGraph两个类，用FriendshipGraph模拟Person对象间的社交关系，实现对社交网络的模拟，并实现计算两个Person之间的最短社交距离的功能。 设计/实现FriendshipGraph类 存储网络中的person以及person的全部name 加入新用户时，检测是否有重名，若重名终止程序 通过person类中的操作实现addEdge 使用有向图的BFS算法计算两点的最短距离。 主函数部分实现了手册中给出的代码 运行结果： 设计/实现Person类 Person类代码如下 Person类包含了用户姓名以及人际关系，通过List保存每个对象的朋友以表现朋友关系，因此通过向List中添加元素实现addFriend的功能。 设计/实现客户端代码main() 设计/实现测试用例 通过三个测试用例，检验程序的添加用户、添加用户关系、计算最短距离三个功能 实验进度记录 请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。 每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。 不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。 日期时间段任务实际完成情况2021-05-1113:45-15:30大致学习实验内容，编写问题1的isLegalMagicSquare函数按计划完成2021-05-20全天完成P1及P2全部内容超过凌晨几小时2021-05-23全天完成剩余内容并整理学习到内容完成 实验过程中遇到的困难与解决途径 遇到的困难解决途径对java掌握不熟练，很多方法、函数需要查阅资料，浪费了很多时间努力学习java，掌握基本代码方式对github不太了解，不清楚仓库、clone等功能是如何运作的查阅各种资料，实践理解功能 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 大概了解了java的代码、项目管理、git的版本控制、以及github的共享体系 针对以下方面的感受Java编程语言是否对你的口味？ 还可以，有时不够直观，但整体上功能更多，比c更灵活 关于EclipseIDE； 没有使用，习惯使用IDEA，今后会补充这方面的不足 关于Git和GitHub； 用得不太好，但也还行 关于CMU和MIT的作业； 很有创意，给我提供了很多思路 关于本实验的工作量、难度、deadline； 难度很适合作为第一次实验 关于初接触“软件构造”课程； 有很多不习惯的地方，但是一一克服后感觉收获颇丰 
第174篇文章[0]
软件构造学习笔记 数据类型与类型检验 数据类型 基本数据类型:只有值，没有ID(与其他值无法区分) 在栈中分配内存 代价低 不可变 int,long,boolean,double,char 对象数据类型:既有ID，也有值 在堆中分配内存 代价昂贵 可变\不可变 String,BigInteger 对象类型形成层次结构：继承关系（extends） 重载 同样的操作名可用于不同的数据类型 类型转换 inta=2;//a=2 doublea=2;//a=2.0(Implicit) inta=(int)18.7;//a=18double a=(double)2/3;//a=0.6666… Mutability与Immutability 改变一个变量：将该变量指向另一个值的存储空间 改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。 Immutability不变性 不变性：重要设计原则 不变数据类型：一旦被创建，其值不能改变 如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变 final：final类无法派生子类 final变量无法改变值/引用 final方法无法被子类重写 不变对象：一旦被创建，始终指向同一个值/引用 可变对象：拥有方法可以修改自己的值/引用 String是不可变的 StringBuilder是可变的 使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，不可变类型更“安全”，在其他质量指标上表现更好 可变类型最少化拷贝以提高效率，使用可变数据类型，可获得更好的性能 Snapshot 用于描述程序运行时的内部状态，便于程序员之间的交流，刻画各类变量随时间变化，解释设计思路 基本类型的值 对象类型的值 不可变对象：用双线椭圆 不可变的引用：用双线箭头 引用是不可变的，但指向的值却可以是可变的，可变的引用，也可指向不可变的值 
第175篇文章[0]
软件构造学习笔记 软件构造的多维度视图 Build-time:软件的构造阶段。 Code-level:代码的逻辑组织。源代码如何被方法、函数、类和接口等底层模块组织起来，以及其中代码之间的依赖关系。 Component-level：代码的物理组织。代码块之间的关系，如文件、包等。 Momentview:特定时刻的软件形态。 Periodview:软件形态随时间的变化。 (1)Build-time,moment,andcode-levelview 词汇层面：Lexical-orientedsourcecode 半结构化：近乎自然语言的风格+遵循特定的编程语法 语法层面：Syntax-orientedprogramstructure:e.g.,AbstractSyntaxTree(AST) AST：彻底结构化，将源代码变为一棵树，对树做各种操作=对源代码的修改 语义层面：Semantics-orientedprogramstructure:e.g.,ClassDiagram 语义：源代码具体想实现什么目标？源代码 >现实世界 用于表达“需求”和“设计”思想，再转化成code 通常是图形化或形式化的 (2)Build-time,period,andcode-levelview Codechurn代码变化:Linesadded,modifiedordeletedtoafilefromoneversiontoanother (3)Build-time,moment,andcomponent-levelview 关注库（这里指静态链接库）和包，库有这几种来源：操作系统提供的库、编程语言提供的库、第三方公司提供的库以及自己积累的库。 开发者像使用编程语言指令一样使用库中的功能 操作系统提供的库 编程语言提供的库第三方公司提供的库 你自己积累的库 (4)Build-time,period,andcomponent-levelview 各项软件实体随时间如何变化 VersionControlSystem(VCS) (5)Run-time,moment,andcode-levelview 代码快照图：描述程序运行时内存里变量层面的状态 (6)Run-time,periodandcode-levelview 用日志方式记录程序执行的调用次序 (7)Run-time,moment,andcomponent-levelview DeploymentdiagraminUML (8)Run-time,period,andcomponent-levelview 事件日志：系统层面 
第176篇文章[0]
软件构造学习笔记 软件构造过程 传统软件进程模型 基础类型：线性过程、迭代过程 瀑布过程：线性推进阶段划分清楚整体推进无迭代管理简单无法适应需求增加/变化 增量过程：线性推进增量式（多个瀑布的串行）无迭代比较容易适应需求的增加 V字模型： 原型过程：迭代过程 螺旋模型：非常复杂的过程 。 多轮迭代基本遵循瀑布模式每轮迭代有明确的目标遵循“原型”过程，进行严格的风险分析方可进入下一轮迭代 敏捷开发 通过快速迭代和小规模的持续改进，以快速适应变化。 Agile=增量+迭代，每次迭代处理一个小规模增量 极限的用户参与 极限的小步骤迭代 极限的确认/验证 软件配置管理(SCM)和版本控制系统(VCS) 软件配置管理：追踪和控制软件的变化 软件配置项（SCI）：软件中发生变化的基本单元（例如：文件） 基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本） CMDB：配置管理数据库存储软件的各配置项随时间发生变化的信息+基线 Versioning版本控制 版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识” 古老的版本控制方法：通过复制文件并修改文件名 仓库：即于SCM中的CMDB 工作拷贝：在开发者本地机器上的一份项目拷贝 文件：一个独立的配置项 版本：在某个特定时间点的所有文件的共同状态 变化：即codechurn，两个版本之间的差异 HEAD：程序员正在其上工作的版本 版本控制系统（VCS） 本地版本控制系统：仓库存储于开发者本地机器，无法共享和协作 集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作 分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器 GitasanexampleofSCMtool 本地的CMDB 工作目录：本地文件系统 暂存区：隔离工作目录和Git仓库 
第177篇文章[0]
软件构造Lab3记录 实验3，学期末时间太紧了，不然过程应该是挺快乐的 2实验环境配置 3实验过程 3.1待开发的三个应用场景 3.2面向可复用性和可维护性的设计：IntervalSet<L> 3.2.1IntervalSet<L>的共性操作 3.2.2局部共性特征的设计方案 3.2.3面向各应用的IntervalSet子类型设计（个性化特征的设计方案） 3.3面向可复用性和可维护性的设计：MultiIntervalSet<L> 3.3.1MultiIntervalSet<L>的共性操作 3.3.2局部共性特征的设计方案 3.3.3面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案） 3.4面向复用的设计：L 3.5可复用API设计 3.5.1计算相似度 3.5.2计算时间冲突比例 3.5.3计算空闲时间比例 3.6应用设计与开发 3.6.1排班管理系统 3.6.2操作系统的进程调度管理系统 3.6.3课表管理系统 3.7基于语法的数据读入 3.8应对面临的新变化 3.8.1变化1 3.8.2变化2 3.9Git仓库结构 4实验进度记录 5实验过程中遇到的困难与解决途径 6实验过程中收获的经验、教训、感想 6.1实验过程中收获的经验和教训 6.2针对以下方面的感受 实验目标概述 本次实验覆盖课程第2、3章的内容，目标是编写具有可复用性和可维护性 的软件，主要使用以下软件构造技术： ⚫子类型、泛型、多态、重写、重载 ⚫继承、代理、组合 ⚫语法驱动的编程、正则表达式 ⚫API设计、API复用 本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过ADT和泛型等抽象技术，开发一套可复用的ADT及其实现，充分考虑这些应用之间的相似性和差异性，使ADT有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。 实验环境配置 在这里给出你的GitHubLab3仓库的URL地址（HIT-Lab3-学号）。 实验过程 请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。 待开发的三个应用场景 （1）值班表管理（DutyRoster）：一个单位有n个员工，在某个时间段内（例如寒假1月10日到3月6日期间），每天只能安排唯一一个员工在单位值班，且不能出现某天无人值班的情况；每个员工若被安排值班m天（m>1），那么需要安排在连续的m天内。值班表内需要记录员工的名字、职位、手机号码，以便于外界联系值班员。 （2）操作系统进程调度管理（ProcessSchedule）：考虑计算机上有一个单核CPU，多个进程被操作系统创建出来，它们被调度在CPU上执行，由操作系统决定在各个时段内执行哪个线程。操作系统可挂起某个正在执行的进程，在后续时刻可以恢复执行被挂起的进程。可知：每个时间只能有一个进程在执行，其他进程处于休眠状态；一个进程的执行被分为多个时间段；在特定时刻，CPU可以“闲置”，意即操作系统没有调度执行任何进程；操作系统对进程的调度无规律，可看作是随机调度。 （2）大学课表管理（CourseSchedule）：针对某个班级，假设其各周的课表都是完全一样的（意即同样的课程安排将以“周”为单位进行周期性的重复，直到学期结束）；一门课程每周可以出现1次，也可以安排多次（例如每周一和周三的“软件构造”）且由同一位教师承担并在同样的教室进行；允许课表中有空白时间段（未安排任何课程）；考虑到不同学生的选课情况不同，同一个时间段内可以安排不同的课程（例如周一上午3-4节的“计算方法”和“软件构造”）；一位教师也可以承担课表中的多门课程。 面向可复用性和可维护性的设计：IntervalSet<L> 该节是本实验的核心部分。 IntervalSet<L>的共性操作 insert分配一个时间段给一个新的标签labels获取已分配的标签集remove移除某标签的已分配时间段start获取某标签的时间段开始时间end获取某标签的时间段结束时间 局部共性特征的设计方案 IntervalSet<L>类的设计： 创建一个Interval<L>类，每个Interval对象保存一个标签和其分配的唯一时间段 通过继承decorator的子类实现各种个性化特征设计 无重叠IntervalSet<L>： 遍历每个时间段检查是否有重叠部分 2.非空IntervalSet<L>： 当输入完成后使用函数checkNoBlank检查，该函数返回总时间轴上未分配的时间，当已经非空时返回空集 3.周期性IntervalSet<L>： 周期性并无太多特殊性，其求模、取偏移等过程在具体的应用场景中实现，不新建额外的类 面向可复用性和可维护性的设计：MultiIntervalSet<L> MultiIntervalSet<L>的共性操作 insert分配一个时间段给一个已保存的标签addlabel添加一个新的标签labels获取已分配的标签集remove移除某标签的所有已分配时间段starts获取某标签的所有时间段开始时间ends获取某标签的所有时间段结束时间delete删除一个未分配时间的标签 局部共性特征的设计方案 创建Intervals<L>，以复用IntervalSet<L>的代码，每个Intervals<L>对象保存了一个标签和其分配的所有时间段，用IntervalSet<Integer>表示 add为该标签分配一个时间段delete删除该标签的所有时间段getNum返回该标签分配的时间段个数getLabel返回标签名getStarts获取某标签的所有时间段开始时间getEnds获取某标签的所有时间段结束时间toString复用IntervalSet<L>中的toStirng方法 对于MultiIntervalSet<L>中各方法的实现： insert：复用insert代码，向label对应的Intervals<L>分配一个时间段，并使num+1 labels：遍历List<Intervals<L>>，返回所有label构成的集 remove：遍历List<Intervals<L>>，移除对应的label中的所有时间段 starts：遍历List<Intervals<L>>，找到对应label的Intervals<L>，遍历其intervalSet，返回每个时间段的intervalSet.start ends：遍历List<Intervals<L>>，找到对应label的Intervals<L>，遍历其intervalSet，返回每个时间段的intervalSet.end delete：检查对应label的Intervals<L>的num是否为0，是则从intervalsets中移除该对象 MultiIntervalSet<L>结构如下： 面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）无重叠： 与IntervalSet<L>类似，相对复杂一些 非空 与IntervalSet<L>同理，调整遍历策略即可 面向复用的设计：L 对于三个实际应用，三个label分别是： Emploee： Process Course 对于每个label，重写其equals方法，只要某一唯一特征相同就返回true，如课程ID、进程ID、员工姓名（员工姓名唯一是实验手册要求，实际应用中不可能这样设计） 可复用API设计 三个API原理基本相同，策略是首先建立一个包含所有时间的List（即从开始到结束），多重遍历IntervalSet中的时间段并检查其特定条件，将符合条件的时间点从List中移除，根据List的剩余长度返回特征值，该方法时间复杂度较高，但考虑到三个应用没有太大的数据量，其实可以接受 计算相似度 计算时间冲突比例 计算空闲时间比例 应用设计与开发 利用上述设计和实现的ADT，实现手册里要求的各项功能。 应用系统已配备操作界面和文字描述，功能基本复用了上述类中的方法 排班管理系统 基本使用上述ADT实现，用户首先输入起止时间以确定范围，然后将Employee类看作IntervalSet中的label，进行相应操作，由于CommonIntervalSet类只保存已分配时间段的label，所以单独创建一个List用来存储总的职员表，在删除员工时应遍历检查其是否在IntervalSet.label中，不在即没有排班时才可以删除员工信息，时间表示上，程序的前端输入输出均使用直观的LocalDate类表示，即yyyy-mm-dd，在后端信息处理时则使用日期转换的大纪元日表示（距离某特定日期的天数，long类型），便于信息处理 添加排班记录，下图也体现了本系统的日期转换、输入模式等 添加员工信息的方法不对IntervalSet进行操作 删除员工时应检查其是否存在排班 对值班记录是否排满的检查直接复用了上述非空IntervalSet的检查方法 对于实验手册要求的随机排班功能，经实践发现如果完全随机排班，大概率出现排班时间不均的情况，甚至有时会一个人值所有班，这是不合理的，所以本系统采用了根据需值班天数和总员工数取每人需要值班的平均天数，但随机选择值班顺序的方法，这样可以尽可能公平地值班，该方法代码较长，可以在系统中进行测试，报告中不截图了 不过有一点需要注意，根据这种取平均值的方法，由于舍入问题，需要检查在只剩一人没有排班时，应将剩余天数都排给他，这会让他比别人多值最多人数-1天的班，通常这是可以接受的 主界面代码及操作截图： 操作系统的进程调度管理系统 进程管理系统使用MultiIntervalSet类和其无重叠子类实现，MultiIntervalSet类中可以存储未分配时间段的标签，所以不需要单独存储进程目录了，需要注意本程序禁止进程ID为0，现实中0号进程是系统进程，而在本系统中做此限制的原因会在后面提到 本系统需要实现的功能比较少，主要使用了三个方法： 随机进程调度randomSchedule() 在此采用的方法是通过进程ID随机选择目标，若目标已经完成则重新随机，手册中要求了系统空置的情况，为了模拟这种情况，我们额外添加了一个进程ID为0的进程，名为idle，这也是我们限制用户添加的进程ID的原因，这样在随机数取到0时就代表系统空置了，为了避免随机数取到特别大的数，我们限制空置时间为1到10的随机数，对于运行时间，我们取选择的目标程序的最长运行时间减去进程已运行时间（保存在Process类中）以内的随机一个正整数，通过MultiIntervalSet表示各个进程在时间轴上的运行记录，若运行后该进程运行时间达到最短运行时间，则标记其已经完成，之后不再选择，并且使计数器+1，当计数器等于进程数时停止系统 最短优先进程调度shortestSchedule() 该系统通过遍历选出longest–runningtime最小的进程作为目标即可，运行时间选择策略与上一个方法相同，区别是这种调度模式不再有系统空置的情况了 可视化处理visualization() 本方法在系统调度完成之后通过保存的MultiIntervalSet复现系统调度过程到用户指定的时刻，并标注各进程的状态，包括：pause暂停，stop终止（完成），running运行中，只有在用户指定时刻正在运行的进程是running状态 课表管理系统 写到这里时我发现前面的代码可以进行大量复用了，所以第三个App虽然内容不少但反而没有用大量时间 对于该系统的时间表示，由于周期性的特点我们在MultiIntervalSet中只保存0到34这段时间，从周一第一节开始，每个点代表一节课（2学时） 在排课分配时，每排一节课将该课程的已分配学时+2（保存在Course类中），当已分配满周学时时不可再为该课程排课 对于查询课表功能的实现，由于时间轴上保存的是抽象化的0到34表示上课时间，而用户输入的是yyyy-mm-dd格式的日期查询当天课程，所以需要进行转换，这里使用了Localdate中的getDayOfWeek()方法，该方法可以计算某日期当天是星期几，再根据星期几决定偏移量，比如星期一从0开始，星期二从5开始…从偏移量开始往后的五节课程，就是当天的课表，遍历MultiIntervalSet，将符合时间的课程输出即可 对于计算每周空闲时间和重复时间比例的功能，简单复用APIs.java中的方法即可实现 应对面临的新变化 变化1 值班表的改变相对比较复杂，因为我早期的设计思路有一些问题，IntervalSet和MultiIntervalSet的方法不方便相互改变，需要改动一些客户端的方法才能实现值班表从单一表到多重表的改动，代价偏大 变化2 课表系统因为不涉及多重表和单一表的转换，所以改动比较简单，只需再decorator中新增一种无重叠MultiIntervalSet并应用到客户端中即可，代价比较小 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训针对以下方面的感受重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用，你是否体会到复用的好处？ 面向ADT的编程可以使代码具有更好的可复用型，让ADT可以面向多种相似的应用场所，大量提高编程效率 重新思考Lab2中的问题：为ADT撰写复杂的specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？ 让ADT更加准确，愿意 之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？ 难处体会到了，乐趣很难说 你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？ 第一次接触，有点复杂 Lab1和Lab2的工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过三周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？ 难度主要体现在自己的设计要足够严谨，如果有功能的遗漏，后续的补救工作是灾难性的，反复思考，确认自己的设计可以应对相应场合 “抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的三个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、委派、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？ 模块化的设计思路能够大大减轻工作量，但需要时间来熟悉这种模式 关于本实验的工作量、难度、deadline。‘ 好 下周就要进行考试了，你对《软件构造》课程总体评价如何？ 面向更多实际应用，比较有意义 
第178篇文章[0]
HIT软件构造Lab2记录 本次实验初看让人有点摸不着头脑，先根据模板写测试再编程的顺序在之前完全没见过，但熟悉之后发现效率很高，思路也更清晰，nice 目录 2实验环境配置 3实验过程 3.1PoeticWalks 3.1.1GetthecodeandprepareGitrepository 3.1.2Problem1:TestGraph<String> 3.1.3Problem2:ImplementGraph<String> 3.1.3.1ImplementConcreteEdgesGraph 3.1.3.2ImplementConcreteVerticesGraph 3.1.4Problem3:ImplementgenericGraph<L> 3.1.4.1Maketheimplementationsgeneric 3.1.4.2ImplementGraph.empty() 3.1.5Problem4:Poeticwalks 3.1.5.1TestGraphPoet 3.1.5.2ImplementGraphPoet 3.1.5.3Graphpoetryslam 3.1.6使用Eclemma检查测试的代码覆盖度 3.1.7Beforeyou’redone 3.2Re-implementtheSocialNetworkinLab1 3.2.1FriendshipGraph类 3.2.2Person类 3.2.3客户端main() 3.2.4测试用例 3.2.5提交至Git仓库 4实验进度记录 5实验过程中遇到的困难与解决途径 6实验过程中收获的经验、教训、感想 6.1实验过程中收获的经验和教训 6.2针对以下方面的感受 1.实验目标概述 本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说： l针对给定的应用问题，从问题描述中识别所需的ADT； l设计ADT规约（pre-condition、post-condition）并评估规约的质量； l根据ADT的规约设计测试用例； lADT的泛型化； l根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction） l使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure）； l测试ADT的实现并评估测试的覆盖度； l使用ADT及其实现，为应用问题开发程序； l在测试代码中，能够写出testingstrategy并据此设计测试用例。 2.实验环境配置 IDEA中自带覆盖率测试插件，故无需添加 在这里给出你的GitHubLab2仓库的URL地址（Lab2-学号）。https://github.com/ComputerScienceHIT/HIT-Lab2-1190201517 3.实验过程 3.1PoeticWalks 题目给出了一个graph接口，要求我们完成两个描述图的类，其中一个以边为主体，一个以点为主体，并按要求实现接口中的各种方法，最后使用完成的图抽象数据类型完成诗歌生成的功能 ​​​​​​​3.1.1 GetthecodeandprepareGitrepository 通过控制台命令建立本地git仓库，并用clone指令通过给出的url地址下载指定代码包到git仓库中 ​​​​​​​3.1.2 Problem1:TestGraph<String> 思路：首先根据接口的功能描述完成测试程序，测试程序应分别测试接口中给出的各个方法 add：对于点已存在和未存在的情况分别测试，检查输入的点是否在图中。 set：考虑多种情况：边不存在时添加，边已存在时覆盖并返回原权重，权重为0时删除边，权重为负时报错。 remove：点不存在时返回false，点存在时移除该点并返回true，移除后应检查与该点有关的边是否也被移除 vertices：检查点的添加和移除后是否均能正确返回点集 sources和targets：检查添加、移除边后能否正确返回源点集和终点集 ​​​​​​​3.1.3 Problem2:ImplementGraph<L> ​​​​​​​3.1.3.1 ImplementConcreteEdgesGraph 建立ConcreteEdgesGraph类和Egde类，Egde类表示边的状态，ConcreteEdgesGraph类实现接口功能，其中各方法功能如下表： Edge： 方法功能checkRep检查不变性getSource返回起始点getTarget返回终止点getWeight返回权重toString按“起始点-权重>终止点”的格式返回表示该边的字符串 ConcreteEdgesGraph： 方法功能checkRep检查不变性add向图中添加一个点，点的名称不可重复set向图中添加一条边，若边存在则覆盖旧边并返回旧边权重，边不存在则新建并返回0，当输入权重为0时移除该边，权重为负时报错remove移除一个点和该点连接的边，成功移除返回true，边不存在返回falsevertices返回图的所有点构成的集合sources返回图中所有作为起始点的点和其边构成的集合targets返回图中所有作为终止点的点和其边构成的集合toString将图中所有边转化为字符串返回，顺序按照边添加的顺序 ​​​​​​​3.1.3.2 ImplementConcreteVerticesGraph 建立ConcreteVerticesGraph类和Vertex类，Vertex类表示点及其连接状态，ConcreteVerticesGraph类实现接口功能，其中各方法功能如下表： Vertex： 方法功能checkRep检查不变性getVertex返回该点名称getSources返回指向该点的点集getTargets返回该点指向的点集addSources\removeSources添加、删除指向该点的边addTargets\removeTargets添加、删除该点指向的边toString按“起始点-权重>终止点”的格式返回表示该边的字符串 ConcreteVerticGraph： 方法功能checkRep检查不变性add向图中添加一个点，点的名称不可重复set向图中添加一条边，若边存在则覆盖旧边并返回旧边权重，边不存在则新建并返回0，当输入权重为0时移除该边，权重为负时报错remove移除一个点和该点连接的边，成功移除返回true，边不存在返回falsevertices返回图的所有点构成的集合sources返回图中所有作为起始点的点和其边构成的集合targets返回图中所有作为终止点的点和其边构成的集合toString将图中所有边转化为字符串返回，顺序按照点添加的顺序，每个点按边添加顺序输出以该点为起始点的边 ​​​​​​​3.1.4 Problem4:Poeticwalks 本题要求使用上述图结构，用给定的文件为文本集，连接集合中相邻的词，构建这样的图后，对任意词组成的的字符串，若串中任意两词间在图中存在一个“桥”，就将该桥插入字符串中。 ​​​​​​​3.1.4.1 TestGraphPoet 根据题目要求，需要对图的构建、字符串的插入进行测试，分情况需测试空文件、标准文件和多行文件的读入、多种权值比较的情况 ​​​​​​​3.1.4.2 ImplementGraphPoet 思路：读入文件时，按空格将文件内容按单词拆分为字符串数组，并按上述结构存入图中作为点集，并以此将相邻的单词连接，每一次相邻使权重加一。 对字符串进行插入时，检查以当前词指向的点中是否有指向下一个词的点，在所有符合条件的点中将权重和最高的点插入两词之间，按此规则遍历字符串并输出结果 ​​​​​​​3.1.4.5 使用Eclemma检查测试的代码覆盖度 ​​​​​​​3.2 Re-implementtheSocialNetworkinLab1 和Lab1中的FriendshipGraph类问题类似，只需将其中方法使用本次饰演的Graph结构实现即可 ​​​​​​ 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 本次实验遇到了时间规划不合理导致任务积压的问题，下次应为实验分配更合理的时间准备 ​​​​​​​针对以下方面的感受 1.面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？ 面向ADT编程时任务更加模块化，更好理清思路，对项目管理也有很大帮助 2.使用泛型和不使用泛型的编程，对你来说有何差异？ 使用泛型编程可以增加程序的泛用性，但因为此前用的不多，有些不熟悉，需要时间理解 3.在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？ 使测试不受程序影响，更具客观准确性，目前还不太适应 4.P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？ 提高了工作效率，使代码具备复用性 5.为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？ 保证了代码的安全性 6.关于本实验的工作量、、deadline。 适中，很合适 7.《软件构造》课程进展难度到目前，你对该课程有何体会和建议？ 这门课程更多偏向于实际应用中的项目管理、软件开发等方面，更贴近实际而不是理论 
第179篇文章[0]
关于软件构造的多维度视图的总结 这部分是在软件构造课上学习的，属于记忆性内容，在此作出一个总结 按状态划分：构造时视图（build-time）运行时视图（run-time） 按动态性划分：时刻视图（moment） 阶段视图（period） 按构造对象的层次划分：代码视图（code） 构件视图（component） 下面为一些举例： Sourcecode(源代码):bulild-timemomentcode AST(抽象语法树):build-timemomentcode Interiace-Class-Attribute-Method(内部类属性方法):build-timemomentcode CodeSnapshot(代码快照):run-timemomentcode Memorydump(内存转储):run-timemomentcode Package(包):build-timemomentcomponent File(文件):build-timemomentcomponent StaticLinking(静态链接):build-timemomentcomponent TestCase(测试用例):build-timemomentcomponent BuildScript(构建脚本):build-timemomentcomponent Package(封装):run-timemomentcomponent Library(程序库):run-timemomentcomponent Dynamiclinking(动态链接):run-timemomentcomponent Configuration(配置):run-timemomentcomponent Database(数据库):run-timemomentcomponent Middleware(中间软件):run-timemomentcomponent Network(网络):run-timemomentcomponent Hardware(计算机硬件):run-timemomentcomponent CodeChurn(代码变化):build-timeperiodcode ExecutionStackTrace(执行堆栈跟踪):run-timeperiodcode Concurrentmulti-threads(并发多线程):run-timeperiodcode ConfigurationItem(配置项):build-timeperiodcomponent Version(版本):build-timeperiodcomponent Eventlog(事件日志):run-timeperiodcomponent Multi-processes(多进程):run-timeperiodcomponent Distributedprocesses(分布式进程):run-timeperiodcomponent ProcedureCallGraph(过程调用图):run-timeperiodcode&component MessageGraph(消息图):run-timeperiodcode&component 
第180篇文章[0]
正则表达式条件匹配的基本语法 条件匹配在正则表达式中十分重要，下面简单根据我的了解介绍一些： ?(A)B 表示只有当A存在时才会匹配B 下面的代码验证： Stringpattern="/?(A)B"; Stringstr="B"; Patternp=Pattern.compile(pattern); Matcherm=p.matcher(str); booleanresult=m.matches(); if(result){ System.out.println("匹配"); } else{ System.out.println("不匹配"); } 上述为A不存在B存在的情况，结果为不匹配 Stringpattern="/?(A)B"; Stringstr="AB"; Patternp=Pattern.compile(pattern); Matcherm=p.matcher(str); booleanresult=m.matches(); if(result){ System.out.println("匹配"); } else{ System.out.println("不匹配"); } 上述为AB都存在的情况结果为匹配 ?(A)B|C 若A存在，匹配B，否则，匹配C 下面的代码验证： Stringpattern="/?(A)B|C"; Stringstr="AB"; Patternp=Pattern.compile(pattern); Matcherm=p.matcher(str); booleanresult=m.matches(); if(result){ System.out.println("匹配"); } else{ System.out.println("不匹配"); } 上述为A存在的情况，结果为匹配 Stringpattern="/?(A)B|C"; Stringstr="C"; Patternp=Pattern.compile(pattern); Matcherm=p.matcher(str); booleanresult=m.matches(); if(result){ System.out.println("匹配"); } else{ System.out.println("不匹配"); } 上述为A不存在的情况，结果为匹配 
第181篇文章[0]
assertEquals判断两个double是否相等的方法 在我们写测试用例时，难免要对各种数据类型是否相等进行判断。前几天在对两个double类型利 用aseertEquals进行判断时，遇到了下面的问题：精简化问题如下： 在这个例子中double类型h与y的值都为0.1，但assertEquals测试没通过，同时有一条warning ThemethodassertEquals(double,double)fromthetypeAssertisdeprecated 这条warning的意思是类型Assert中的方法assertEquals（double，double）已弃用。 其实我们都直到浮点型的存储形式，因为浮点数的范围和精度有限，所有直接判断两个double类 型是否相等是不合理的，以此我们利用下面的方法解决这个问题： java中提供了解决double判断的方法其中assertEquals的第一个参数为预期值，第二个参数为实 际值，第三个参数为偏差。当预期值与实际值之间的差值在偏差的范围内则判为相等，否则会抛出 错误。 
第182篇文章[0]
有关java等价性问题==误用 在一次实验的test阶段，测试文件总是不通过，最后发现我是犯了等价性方面的错误： 在判断两个字符串是否相等时错误的使用==，将其改为equals()方法解决了问题。 后来在经课上听讲与课后调查了解到： ==是在判断两个对象是否指向内存里的同一段空间。 equals是将此字符串与指定的对象进行比较。当且仅当参数不为NULL并且是表示与此 对象相同的字符序列的字符串对象时，结果才为true。 就这个问题简化验证：将字符串s1与s2，利用==与equals()分别判断 Strings1="Hui"; Strings2=newString(s1); if(s1==s2){ System.out.println("==:T"); } else{ System.out.println("==:F"); } if(s1.equals(s2)){ System.out.println("equals:T"); } else{ System.out.println("equals:F"); } 结果如下：可以看出==判断为false，利用equals()判断为true。 这里让我想起了一道以前的课堂的一道题可以加深对==的理解： 答案为Flase;True a为创建的Integer对象，b是自动装箱产生的Integer对象，其地址不同，故第一个为false。 c为int类型，int与Integer比较时，Integer会进行拆箱，相当于两个int进行比较，故第二个为true。 通过以上测试可以看出：在判断相等的大部分情况下，我们在代码中的本意是equals()， 而不是==，这点不难理解，故在编写代码时一定要注意。 
第183篇文章[0]
java中List的遍历方法 在做实验写代码时，List集合的遍历是经常要用到的 经过课上的讲解与课后的相关学习，总结如下： 首先在遍历之前创造一个List如下： List<String>list=newArrayList<>(); list.add("H"); list.add("u"); list.add("i"); list.add("Y"); list.add("i"); 第一种方法：for循环遍历 理解起来最为简单，利用for循环，设置循环内的局部变量通过get方法对List遍历。 for(inti=0;i<list.size();i++) { System.out.println(list.get(i)); } 第二种方法：增强型for循环遍历 for(数据类型变量名：容器对象){ } for(Strings:list){ System.out.println(s); } 第三种方法：迭代器： 通过集合对象获得迭代器对象 利用while循环遍历 利用hasNext()方法判断是否终止 利用next()获取元素 Iterator<String>iter=list.iterator(); while(iter.hasNext()){ Strings=iter.next(); System.out.println(s); } 三种方法的结果都如下： 可见三种方法都正确实现了List的遍历。 
第184篇文章[0]
Java中关于Queue的一部分操作 队列是一个先进先出的数据结构，具有一些相似度较高的操作。在软件构造课程过程中，一些实际的操作在编写时，却触发了一些异常。下面记录一下自己遇到的问题。 1.关于add()与offer()的差别 add()与offer()都是向队列中添加一个元素。差别在于队列满时的添加操作。 查看add()的API如下： 查看offer()的API如下： 如图，差别在于，add()是抛出异常让你处理，而offer是返回false。 2.关于poll()与remove()的差别 poll()和remove()都是从队首获取元素，并将该元素从队列中移除。差别在于队列为空时的操作。 查看poll()的API如下： 查看remove()的API如下： 如图，差别在于，poll()会返回null，而remove()会抛出异常。 
第185篇文章[0]
java.lang.IllegalStateException:Nomatchfound的错误解决方法 在java中编写正则表达式时，程序报错：java.lang.IllegalStateException:Nomatchfound 找到错误是因为在执行分组捕获的时候，没有先进行匹配操作，及find()。 下面是从程序中截出来的一段代码，目的是检测一段表达式： Patternpattern=Pattern.compile("Employee\\{\\s*(([a-z|A-Z]+\\{[^{}]*}\\s*)*)}"); Matcherm=pattern.matcher(fileContent); m.find(); Stringemployees=m.group(1); Employee{ ZhangSan{Manger,139-0451-0000} LiSi{Secretary,151-0101-0000} WangWu{AssociateDean,177-2021-0301} ZhaoLiua{Professor,138-1920-3912} ZhaoLiub{Lecturer,138-1921-3912} ZhaoLiuc{Professor,138-1922-3912} } 但是发现在处理另外一段表达式的时候还是会有java.lang.IllegalStateException:Nomatchfound的提示，其中发现问题出现在一句话： ZhaoLiu1{Professor,138-1920-3912} 要求的正则表达式中是不含数字的，但是当检测带有数字的表达式时还是会报错，后来发现正确的形式应该为： while(m.find()){ Stringemployees=m.group(1); } 这样问题就解决了。 
第186篇文章[0]
Java多维度视图的总结 软件构造中第一章的最主要的内容应该就是软件的多维视图。可以以三个相互正交的维度划分： 按状态划分：构造时视图（build-time）运行时视图（run-time）按动态性划分：时刻视图（moment）阶段视图（period）按构造对象的层次划分：代码视图（code）组件视图（component） 软件的多维视图从构造-运行、代码层-组件层、时刻-阶段这三对对应的属性来刻画了各种可能出现的状态和过程。而软件构造的过程正伴随着这些视图的转换。 
第187篇文章[0]
Java抽象与接口 抽象函数/抽象类 抽象函数：表达概念而无法实现具体代码的函数。 抽象类：表达概念而无法构造出实体的类。 抽象函数只有函数头而没有实现，它的实现由子类提供有抽象函数的类一定是抽象类，允许声明没有抽象方法的抽象类。非抽象类不能包含抽象函数，如果一个抽象父类的子类不能实现所有的抽象方法，它必须声明为抽象的。抽象类不能用new制造对象，但是可以定义变量；可以定义它的构造方法，可在子类的构造方法中调用。任何继承了抽象类的非抽象类的对象可以付给这个变量 接口的定义 1.接口是纯抽象类。 所有成员函数都是抽象函数所有成员变量都是publicstaticfinal 2.接口规定了里面有什么，但不管里面有什么。 3.接口不能被实例化，只能被类实现，或者被其他接口扩展。 4.关键字 interface表明其后紧跟的是接口名extends表明继承自哪些父接口 5.访问权限控制符 public表明任意类和接口均可使用这个接口；缺省修饰符表明只有与该接口定义在同一个包中的类和接口才可以使用这个接口。 接口的实现 类用extends，接口用implements类可以实现多个接口接口可以继承接口，但不能继承类接口不能实现接口 面向接口的编程方式 设计程序时需要先定义接口，再利用接口去实现类任何需要在函数间传入传出的一定是接口 
第188篇文章[0]
JavaADT设计总结 ADT ADT是抽象数据类型（AbstractDataType）的缩写。ADT是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。 下面介绍有关表示的几个概念: 抽象函数(Abstract Function, AF)表示不变量(RepresentationInvariant, RI)表示独立性（RepresentationIndependence) （1）抽象函数(Abstract Function, AF) 表示域（称为R）包含的是值具体的实现实体。抽象域（称为A）包含类型设计时支持使用的值。抽象函数是表示值到其对应的抽象值的映射 AF:R->A。 （2）表示不变量(RepresentationInvariant, RI) 要求注明抽象值的合法区域，并说明合法或者不合法的原因。其中最基本的表示不变量的就是可变与不可变性（mutable/immutable）。 记录不变量是为了保持程序的“正确性”，防止发生错误。 （3）表示独立性（RepresentationIndependence) 说一个ADT有良好的表示独立性，就是说client使用ADT是无需考虑其内部如何实现的，ADT内部表示的变化不应影响外部spec和客户端。所有的操作的使用方法和效果都要在spec中说清楚，规定好输入的约束条件和输出的正确性和安全性。 
第189篇文章[0]
2021-07-07 软件构造之关于委派delegation的一些感悟 1.delegate的含义：委派模式（Delegate）是面向对象设计模式中常用的一种模式。这种模式的原理为类B和类A是两个互相没有任何关系的类，B具有和A一模一样的方法和属性；并且调用B中的方法，属性就是调用A中同名的方法和属性。B好像就是一个受A授权委托的中介。第三方的代码不需要知道A的存在，也不需要和A发生直接的联系，通过B就可以直接使用A的功能，这样既能够使用到A的各种公能，又能够很好的将A保护起来了。2.delegate的类型：2.1AuseB：B类对象在A类中出现，但是是以局部变量或是方法参数的形式出现的。A类中并没有B类的对象作为域。一般称这种delegation为临时性的delegation。2.2AhasB：B类对象在A类中出现，B类的对象是A类的域之一。B类对象通过A类对象的constructor方法或其它方法从外部输入A类对象。AhasB有两种情况：Association为A类对象和B类对象之间并没有从属关系；Aggregation为A类对象由B类聚合而成，但是B类可以脱离A类单独存在。一般称这种delegation为永久性的delegation。2.3AispartofB：B类对象在A类中出现，B类的对象是A类的域之一。B类对象在A类对象内创建。B类对象不能脱离A类对象独立存在。一般称这种delegation为永久性的delegation。3.delegate的使用场景：在某些情况下，我们不希望或是不能直接访问对象A，而是通过访问一个中介对象B，由B去访问A达成目的，这种方式我们就称为代理。这里对象A所属类我们称为委托类，也称为被代理类，对象B所属类称为代理类。4.静态delegate：代理者的代码由程序员自己或通过一些自动化工具生成固定的代码再对其进行编译，代码运行前代理类的class编译文件就已经存在。5.动态gelegate：通过反射机制动态的生成代理者的对象，代理谁只有在执行时才知道。java提供了一个便捷的动态代理接口InvocationHandler,实现该接口需要重写invoke()方法。实现动态代理包括三步：1新建委托类；2实现InvocationHandler接口，这是负责连接代理类和委托类的中间类必须实现的接口；3通过Proxy类创建代理类对象。以上关于delegate的一些感悟是基于课程学习和csdn的一些文章得来，用于课程总结感悟，侵删。 
第190篇文章[0]
2021-07-07 软件构造之知识点总结1、31.软件构造的多维度视图1.1Byphases:build-andrun-timeviews按阶段划分：构造时/运行时视图1.2Bydynamics:momentandperiodviews按动态划分：时刻/阶段视图1.3Bylevels:codeandcomponentviews按构造对象的层次划分：代码/构件视图2.软件构造的阶段划分、各阶段的构造活动阶段1：build-time，构造活动为design、refactoring、build、versioncontrol、evolution阶段2：dumping、debugtesting、buildinstalldeploy、profiling、tracing、logging3.内部/外部的质量标准外部质量因素影响用户，内部质量因素影响软件本身和它的开发者，外部质量取决于内部质量。包括：正确性，健壮性，可扩展性，可复用性，保持设计的同构性，有效性，可移植性，易用性，功能性，及时性等等4.软件配置管理SCM与版本控制系统VCS软件配置管理：追踪和控制软件的条件版本控制系统：本地版本控制系统：仓库存储于开发者本地机器无法共享和协作；集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作分布式版本控制系统：仓库存储与独立的服务器+每个开发者的本地机器5.Git的结构git仓库分为三部分：本地的CMDB、工作目录：本地文件系统以上为1、3的知识点文字总结，为本人针对软件构造学习所做，侵删 
第191篇文章[0]
2021-07-06 软件构造之关于OOP的一些感悟 Object-OrientedProgramming面向对象的编程1.类：类的定义包括“成员变量”的定义和“方法”的定义:成员变量用于描述该类型对象共同的数据结构，方法用于描述对象的行为，封装对象的功能。类定义完成后，对象的创建可通过new关键字创建，创建对象的过程通常被称为实例化。2.对象：为了能够对实例化对象进行访问控制，需要用一个特殊的变量 引用。引用类型变量可以存放该类对象的地址信息，通常称为“指向该类的对象”。当一个引用类型变量指向该类的对象时，就可以通过这个变量对对象实施访问。除8种基本类型之外，用类、接口、数组等声明的变量都称为引用类型变量，简称“引用”。通过引用就可以访问对象的成员变量和调用方法。3.继承：子类继承自父类。一般通用的属性和方法都放在父类，子类继承后也有这些属性和方法，并可以添加自己的属性和方法。一个类只能继承一个父类。继承不仅让代码变得简洁，还增加了代码的可重用性，拓展，修改。子类的构造方法必须通过super关键字调用父类的构造方法。如果子类的构造方法没有调用父类的构造方法，编译器会自动加入对父类无参构造的调用。override：当子类对象的重写方法被调用时（无论是通过子类的引用还是父类的引用调用），运行的都是子类重写后的方法。这里注意一下override和overload的一些区别：overload是指在一个类中定义多个方法名相同参数列表不同的方法，在编译时根据参数个数和类型来决定绑定哪个方法；override是指在子类中定义和父类完全相同的方法，在运行时根据对象的类型不同（不是引用类型）来调用不同的版本。4.封装：修饰符本类同一个包中的类子类其他类public可以访问可以访问可以访问可以访问protected可以访问可以访问可以访问不能访问默认可以访问可以访问不能访问不能访问private可以访问不能访问不能访问不能访问真的，这个图就很重要，默认这个其实也是default（我这么看的）5.多态：多态是在继承的基础上实现的。多态的三要素：继承、重写和父类引用指向子类对象。父类引用指向不同子类对象时，调用相同的方法，呈现出不同的行为就是类多态特性。多态可以分为编译时多态和运行时多态。一个类型的引用在指向不同的对象时会有不同的实现；当然同样一个对象，造型成不同的类型时，也会有不同的功能。另外关注一下instanceof关键字，为了避免ClassCastException，可以通过instanceof关键字判读某个引用指向的对象是否可以强制为某类型。以上是本人学习了OOP之后结合课件和CSDN上的一些文章总结的结果，侵删，仅供参考和作为课程感悟用途。 
第192篇文章[0]
2021-07-06 软件构造之ADT的一些感悟 前言：抽象数据类型和表示独立性是我们能够将如何在程序中使用数据与数据结构本身的特定形式分离开。设计良好的抽象数据结构，通过封装来避免客户端获取数据内部表示，避免潜在的bug，起到在client和implementer之间建立防火墙的作用。抽象类型：强调“作用于数据上的操作”，程序员和用户无需关心数据如何具体存储的，秩序设计或使用操作即可。可以说，ADT是由操作定义的，于其内部如何实现无关。可变与不可变数据类型：可变数据类型的对象提供了可改变其内部数据的值的操作，而不可变数据类型的操作不改变内部值，而实构造新的对象。举例而言，StringBuilder是String的可变版本，但这两个的Java类型肯定不相同，不能相互转换。抽象类型的操作：一个抽象类型包括构造器、生产器、观察器和变值器（改变对象属性的方法）。其中：构造器的可能实现为构造函数或静态函数，后者被称为一个工厂方法。变值器通常返回void，意味着改变了对象内部的某些状态（当然变值器也可以返回非空类型）。设计一个抽象类： 设计简洁、一致的操作；2.要足以支持客户对数据多做的所有操作需要，且用操作满足用户需要的难度要低；3.要么抽象要么具体，不要混合。表示独立性：表示独立性指用户在使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。除非ADT的操作指明了具体的pre和post-condition，否则不能改变ADT的内部表示，可以看作spec规定了client和implementer之间的契约。代表独立性的魅力在于，某函数的现有客户端只依赖于它的公共方法的规约，而不是它的私有字段，我们可以在不检查和更改所有的客户端代码的情况下进行此更改。测试一个ADT：调用观察器观察剩下三个操作的结果是否满足spec，反过来，调用这三个操作等方法产生或改变对象，看结果是否正确来测试观察器。变量：由ADT负责不变量，与客户端的任何行为无关。因为我们总要假设有客户端由恶意地破坏ADT的不变量，所以需要不变量保持程序的正确性并且易发现错误。一旦发生表示泄露，不仅影响不变性，也影响表示独立性，即无法在不影响客户端地情况下改变其内部表示。防御式拷贝：对可变对象进行复制，避免将引用泄露给rep，确保类不变量在任何输入中存储，以最小化可变性。通常，我们检查所有ADT的陈宗座参数和返回类型，如果任何类型是可变的，则确保我们的实现不会返回对其表示的直接引用。最好的办法就是使用不可变的类型，彻底表示表示泄露。AF与RI：AT（抽象函数），表示R和A之间映射关系的函数，即如何去结视R中的每一个值为A中的每一个值。RI（表示不变性），表示某个具体的“表示”是否是“合法的”。 
第193篇文章[0]
2021-07-05 软件构造之关于git的使用 前言：本人软件构造课需要在github中获取提供的一些程序框架，并且需要持续的上传代码和报告更新github的个人仓库，所以需要用到一些git的基本操作以及技巧，所以利用这个机会在这里分享一下git学习和使用的收获与心得体会。创建版本库：默认已经安装好git了，首先，选择一个合适的地方，创建一个空目录，示例代码如下：$mkdirruanjiangouzao$cdruanjiangouzao$pwd其中ruanjiangouzao为你起的仓库的名字（当然具体要按照实验要求HIT-Lab？-学号），pwd的目的是显示当前目录。然后通过gitinit命令把这个目录变成Git可以管理的仓库：$gitinit添加远程仓库：建立好本地仓库后就需要与实验给出的远程仓库建立联系，由于软件构造的实验都实现给学生梦创建好了仓库，所以我们不需要在Github中创建新的仓库了，需要登上自己Lab的仓库改一下仓库名字变成规定的形式，然后保存下来仓库的地址并把main分支修改成master分支就好了。接下啦在本地仓库文件夹下运行$gitremoteaddorigingit@github.com:刚才保存的实验地址.git（没有http这些前缀的）接下来就是往github仓库中上传相关的代码和文件啦。这里建议先克隆下来实验的仓库到本地仓库在进行后续上传。从远程库克隆：加粗样式在本地仓库文件夹里执行如下命令克隆下来远程库：$gitclonegit@github.com:刚才保存的实验地址.git（没有http这些前缀的）向远程仓库中push：$gitadd.$gitcommit-m“随便起个名字”$gitpushoriginmaster第一行add是添加要上传的文件，.是添加该文件夹中所有的文件；第二行是为了给这个版本的提交起一个名字；第三行是把选中的内容推送到master分支上去。当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：Theauthenticityofhost‘github.com(xx.xx.xx.xx)’can’tbeestablished.RSAkeyfingerprintisxx.xx.xx.xx.xx.Areyousureyouwanttocontinueconnecting(yes/no)?这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：Warning:Permanentlyadded‘github.com’(RSA)tothelistofknownhosts.这个警告只会出现一次，后面的操作就不会有任何警告了。添加新的分支change：Lab3中要求修改原来的设计以应对一些变化，在确保之前的开发已经commit到Git仓库，然后创建新分支“change”，在该分支上完成一些功能的变化。$gitcheckout-bchange$gitadd*$gitcommit-m“change”$gitcheckoutmaster第一行创建change新分支；第三行在该分支上提交软件构造的Lab新代码；第四行切换回master分支。Tips： 正常方法连接github极不稳定，请切记不要赶在ddl前几分钟拼命提交。即使显示如"everythingisupdate"这种反馈也不要轻信，尽量自己打开仓库看一眼。仓库名字一定要按照要求起，一定记得把main改成master，不然真的会不被读取到。ddl一定要遵守。参考资料：廖雪峰git教程lab-3reusabilityandmaintainabilityorientedprogrammingv3 
第194篇文章[0]
Java正则表达式的元字符 Lab3需要对字符串进行匹配，这里整理了一下元字符： 1.限定符 2.选择匹配符 3.分组组合和反向引用符 4.特殊字符 5.字符匹配符 6.定位符 \\转义号[]可接受的字符列表[^]不可接受的字符列表-连字符.匹配除\n以外任意字符\\d匹配单个数字字符\\D匹配单个非数字字符\\w匹配单个数字、大小写字母字符\W匹配单个非数字、大小写字母字符|匹配“|”之前或之后的表达式*指定的字符重复0/n次+指定的字符重复1/n次？指定的字符重复0/1次｛n｝只能输入n个字符｛n,｝指定至少n个匹配｛n,m｝指定至少n个但不多于m个匹配^指定开始字符$指定结束字符\\b匹配目标字符串的边界\bB匹配目标字符串的非边界\f匹配换页符\n匹配换行符\r匹配回车 
第195篇文章[0]
Java8中的stream(一点点) Stream是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。不会去存储对象 创建Steam： 由数组创建流，通过Arrays中的静态方法stream()创建数据源 static<T>Stream<T>stream(T[]array):返回一个流。 publicvoidstream(){ List<StreamObject>list=newArrayList(); Stream<StreamObject>stream=list.stream(); Stream<StreamObject>stream1=list.parallelStream(); } 由数组创建流，通过Arrays中的静态方法stream()创建数据源 static<T>Stream<T>stream(T[]array):返回一个流。 publicvoidstream2(){ Integer[]integer=newInteger[20]; Stream<Integer>stream=Arrays.stream(integer); } Stream中间操作： 筛选与切片： 1.filter(Predicatep)接收Lambda表达式，从流中排除某些元素 2.distinct()筛选，通过流所生成元素的hashCode()和equals()去除重复元素 3.limit(longmaxSize)截断流，使其元素不超过给定数量 4.skip(longn)跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补 映射： 1.map(Functionf)接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素 2.mapToDouble(ToDoubleFunctionf)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream 3.mapToInt(ToIntFunctionf)接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream 排序： 1.sorted()产生一个新流，其中按自然顺序排序 2.sorted(Comparatorcomp)产生一个新流，其中按比较器顺序排序 应用： ​ publicstaticvoidtest(){ List<StreamObject>list=Arrays.asList( newStreamObject(1,"学","习","烂"), newStreamObject(2,"学","习","烂"), newStreamObject(2,"学","习","烂"), newStreamObject(3,"学","习","烂") ); Stream<StreamObject>stream= list.stream() .filter(StreamObject::method) .distinct() .limit(2) .skip(1); stream.forEach(System.out::println); System.out.println(list); } ​ 这里控制台会输出ID等于3的那条数据,在我们输出list的时候，我们发现list的数据并没有收到改变。 
第196篇文章[0]
Java设计模式-装饰器模式 对于开发中不同级别的管理员，如何在管理员这个实体的基础上动态的去设置他们的权限范围呢？我们把权限当作一种挂饰，这种挂饰放在不同的管理员身上就代表他们是什么管理员，那么这种挂饰如何放到管理员身上呢？这就需要装饰器模式了。看一下概念： 装饰器模式（DecoratorPattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 首先定义一个管理员接口，实现这个接口证明你就是一个管理员： interfaceComponent{ voididentity(); } 基础管理员： classAdministratorimplementsComponent{ @Override publicvoididentity(){ System.out.println("无权限管理员"); } } 需要写一个装饰器负责把权限装饰到这个现有的管理员身上。首先肯定要有这个管理员的实例(对象)，所以这个装饰器的构造器中我们要传入一个管理员，其次如果想不破坏管理员的原有结构功能，那么我们肯定要实现管理员这个接口，放入传入具体管理员实例的方法，这样才能保证结构和功能： classDecoratorimplementsComponent{ protectedComponentcomponent; publicDecorator(Componentcomponent){ this.component=component; } @Override publicvoididentity(){ component.identity(); } } 通过装饰器，把权限这个挂饰挂在管理员身上，以此来形成负责不同模块的管理员工。这里我们来实现两个挂饰：写挂饰中挂饰通过装饰器去挂，那么我们肯定要继承这个装饰器，在重写它的方法中动态的增加权限。 classDeAextendsDecorator{ publicDeA(Componentcomponent){ super(component); } @Override publicvoididentity(){ this.component.identity(); personnelFile(); } publicvoidpersonnelFile(){ System.out.println("负责A"); } } classDeBextendsDecorator{ publicDeB(Componentcomponent){ super(component); } publicvoidadministration(){ System.out.println("负责B"); } @Override publicvoididentity(){ this.component.identity(); administration(); } } 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 
第197篇文章[0]
Lab1中turtle凸包算法的实现 lab1中P2要求实现：给定一组点，计算凸包，即包含一组输入点中的所有点的最小凸集。使用Jarvis步进法，思路：纵坐标最小的那个点一定是凸包上的点，比如下面中的P0。从P0开始，按逆时针的方向，逐个找凸包上的点，每前进一步找到一个点，所以叫作步进法。利用夹角。假设现在已经找到P0,P1,P2了，要找下一个点：剩下的点分别和P2组成向量，设这个向量与向量P1P2的夹角为β。当β最小时就是所要求的下一个点了，此处为P3。 publicstaticSet<Point>convexHull(Set<Point>points){ if(points.size()<=2){ returnpoints; } Set<Point>convexHullPoints=newHashSet<Point>(); Pointa=newPoint(Double.MAX_VALUE,Double.MAX_VALUE); for(Pointi:points){ if(i.y()<a.y()) a=i; } PointcurPoint=a,minPoint=null,lastPoint=a; doublex1=0.0,y1=-1.0; do{ convexHullPoints.add(curPoint); doubleminTheta=Double.MAX_VALUE,x2=0.0,y2=0.0; for(Pointi:points){ if((!convexHullPoints.contains(i)||i==a)&&(i!=lastPoint)){ doublex3=i.x()-curPoint.x(),y3=i.y()-curPoint.y(); doubleTheta=Math .acos((x1*x3+y1*y3)/Math.sqrt(x1*x1+y1*y1)/Math.sqrt(x3*x3+y3*y3)); if(Theta<minTheta||(Theta==minTheta&&x3*x3+y3*y3>Math.pow(i.x()-minPoint.x(),2) +Math.pow(i.y()-minPoint.y(),2))){ minPoint=i; minTheta=Theta; x2=x3; y2=y3; } } } x1=x2; y1=y2; lastPoint=curPoint; curPoint=minPoint; }while(curPoint!=a); returnconvexHullPoints; } 
第198篇文章[0]
关于AF、RI 思考一下两个值域之间的关系︰ 表示域(spaceofrepresentationvalues)里面包含的是值具体的实现实体。在简单的情况下，一个抽象类型只需要实现为单个的对象，但是更常见的情况是使用一个很多对象的网络。 抽象域里面包含的则是类型设计时支持使用的值。这些值是由表示域"抽象/想象"出来的，也是使用者关注的。例如，一个无限整数对象的抽象域是整个整数域，但是它的实现域可能是一个由原始整数类型〈有限)组成的数组实现的，而使用者只关注抽象域。 但是，实现者是非常"在意"表示域(和抽象域）)的，因为实现者的责任就是实现表示域到抽象域的转换（映射)。 选择用字符串来表示一个字符集合︰ publicclasscharset{ privatestrings;  } 如上图所示，表示域R包含的是我们的实现实体（字符串)，而抽象域里面是抽象类型表示的字符集合，我们用箭头表示这两个域之间的映射关系。这里要注意几点︰ ·每一个抽象值都是由表示值映射而来。我们之前说过实现抽象类型的意义在于支持对于抽象值的操作，即我们需要能够创建和管理所有的抽象值，因此它们也必须是可表示的。 ·一些抽象值是被多个表示值映射而来的。这是因为表示方法并不是固定的，我们可以灵活的表示一个抽象值。 ·不是所有的表示值都能映射到抽象域中。在上面这个例子中，"abbc"就没有被映射。因为我们已经确定了表示值的字符串中不能含有重复的字符 ―这样我们的remove方法就能在遇到第一个对应字符的时候停止，因为我们知道没有重复的字符。 由于我们不可能对每一个映射一一解释，为了描述这种对应关系和这两个域，我们再定义两个概念∶抽象函数abstractionfunction是表示值到其对应的抽象值的映射∶ AF:R→A 快照图中的箭头表示的就是抽象函数，可以看出，这种映射是满射，但不一定是单射(不一定是双射)。表示不变量repinvariant是表示值到布尔值的映射︰ Rl:R-boolean 对于表示值r，当且仅当r被AF映射到了A，Rl(r)为真。换句话说，RI告诉了我们哪些表示值是"良好组织"的(能够去表示A中的抽象值)，在下图中，绿色表示的就是Rl(r)为真的部分，AF只在这个子集上有定义。 对同一个定义域，有不同的表示不变量 publicclassCharset{ privatestrings;llRepinvariant: lls.length()iseven lls[0]<=s[1]<= <=s[s.length()-1]llAbstractionfunction: llAF(s)=unionof{c\s[2i]<=c<=s[2i+1]}l/ forall0<=i<s.length()/2   } 总之，一个ADT的实现不仅是选择表示域(规格说明)和抽象域〈具体实现)，同时也要决定哪一些表示值是合法的(表示不变量)，合法表示会被怎么解释/映射(抽象函数)。 
第199篇文章[0]
对象和对象的引用 复习的时候突然被对象和对象的引用搞懵了。搜了一圈，终于搞明白了。 先建立一个类 publicclassTest{ //默认构造方法 publicTest{ } } 然后用这个类new一个对象 Testt=newTest(); 右边的“newTest”，是创建一个Test对象。 而左边的“Testt”创建了一个Test类引用变量，是用来指向Test对象的对象引用。 也可以写成： Testt;//创建对象引用 t=/*将对象引用指向对象*/newTest();//创建对象 //一个对象引用可以指向一个对象 Testt；//一个对象引用 Test=newTest();//一个对象引用指向一个对象 也可以多个对象引用指向一个对象 Testt1，t2，t3;//创建多个对象引用 t1=newTest(); t2=t1; t3=t2;//创建对象，并被多个对象引用指向 参考原文：https://blog.csdn.net/qq_26805137/article/details/52945688 牛(｡◕ˇ∀ˇ◕) 
第200篇文章[0]
【新人】编写JUnit测试类有自定义类cannotberesolvedtoatype 今天在编写某实验的测试代码时，尝试实例化对象时出现了Edgecannotberesolvedtoatype的 错误。但这个类是有的，也已经import过了，就很令人费解。 后来请教了同学，了解到是项目的结构出了问题。之前的结构是这样的： 可以看到测试文件都是放在P1文件夹下，它们的package写的都是P1.graph/P1.poet，而src里的源文件都没有放在P1里，其package为graph/poet。 同学说，将测试文件与源文件的包名保持一致，这样测试代码就相当于可以直接看到源文件里的东西了。 于是我将结构进行修改： 果然通过了，同时还省去了一部分import。 非常的好用。 后续再学习学习原理。 
第201篇文章[0]
在Eclipse中使用git传本地仓库到远程仓库 在后两次课程实验中，我都是使用Eclipse中的git操作上传代码到GitHub，现在课程结束了，我简单记录一下。 1、首先打开一个项目，右击，点击Team >ShareProject 2、选择Git 3、在该界面创建本地仓库 4、再次右键项目，Team >Commit 5、在1处填写提交信息，2处选择提交文件，完成后点击Commitandpush 6、在这里填写远程仓库的URL等信息。传Github在Authentication处填写用户名和密码 7、填写完成后继续，点击Finish即可。 之后每当有改动或增加内容，右键项目Team >Commit，重复一波即可，非常的方便，非常的银杏。 更多操作可以移步这里：https://www.jianshu.com/p/acb00e4c7301 
第202篇文章[0]
2021-06-29 软件构造线程安全 线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。 多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。或者说：一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题。 线程安全问题大多是由全局变量及静态变量引起的，局部变量逃逸也可能导致线程安全问题。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。类要成为线程安全的，首先必须在单线程环境中有正确的行为。如果一个类实现正确(这是说它符合规格说明的另一种方式)，那么没有一种对这个类的对象的操作序列(读或者写公共字段以及调用公共方法)可以让对象处于无效状态，观察到对象处于无效状态、或者违反类的任何不可变量、前置条件或者后置条件的情况。此外，一个类要成为线程安全的，在被多个线程访问时，不管运行时环境执行这些线程有什么样的时序安排或者交错，它必须仍然有如上所述的正确行为，并且在调用的代码中没有任何额外的同步。其效果就是，在所有线程看来，对于线程安全对象的操作是以固定的、全局一致的顺序发生的。 正确性与线程安全性之间的关系非常类似于在描述ACID(原子性、一致性、独立性和持久性)事务时使用的一致性与独立性之间的关系：从特定线程的角度看，由不同线程所执行的对象操作是先后(虽然顺序不定)而不是并行执行的。线程安全的四中策略总结：1.Confinement:限制可变变量共享，线程之间不共享mutable数据类型，将可变数据限制在单一进程内部，避免竞争，不让其他进程直接读写该数据。局部变量总是线程安全的，但如果局部变量是一个对象引用，若该对指向象是可变对象，则必须确定该对象也是线程confine的，不能有其他线程也该对象的引用。2.Immutablity不可变数据类型：使用不可变数据类型和不可变引用，避免多线程之间的竞争，不可变数据类型通常是线程安全的，如果ADT使用了可变类型，需要通过加锁机制来保证线程安全。更强的不变性定义如下:1.没有改变数据的操作。（不要提供setter方法等）2.所有字段均为private和final。3.没有表示泄露。4.表示中的任何可变对象都不能发生变化。5.不允许子类重写方法（直接声明为final类，或者使构造方法私有，使用工厂方法构造实例）但是注意：如果是引用，任然必须保证指向的对象是不可变的。3.UsingThreadsafeDataTypes：使用线程安全的数据类型，如果必须要使用mutable的数据类型在多线程之间共享收据，要使用线性安全的数据类型，所有的集合类都不是线程安全的，Java提供了装饰器模式。4.同步和锁：防止线程在同一时间访问同一数据，程序员之间负责多线程之间对mutale数据的共享操作，通过同步策略，避免多线程同时访问数据使用锁机制。获得对数据的独家mutate权力。其他线程被阻塞，不能访问。MonitorPattern：用ADT之间左lock，对所有方法都加锁，把synchronized放到方法声明里和把方法体外套一个symchronized一样，Lockingprinciple：任何共享的mutable变量必须被lock所保护，多个变量组合必须被同一个锁保护，同步机制给性能带来很大的影响。死锁：多个线程相互竞争lock，相互等待对方释放lock解决方案1：lockordering。解决方案2：使用上级对象上锁。线程安全的意义：线程安全，是指变量或方法(这些变量或方法是多线程共享的)可以在多线程的环境下被安全有效的访问。这说明了两方面的问题:(1)可以从多个线程中调用，无需调用方有任何操作;(2)可以同时被多个线程调用，无需线程之不必要的交互。 
第203篇文章[0]
2021-06-30 软件构造Delegation 引出：子类可以继承父类的字段、属性和方法，使用“继承”可以较大程度地复用代码。在使用继承时，务必要确定代码中定义的“父类”和“子类”确实存在客观的“父子关系”，而不要去做“为了代码复用而使用继承”的事情，这是舍本逐末的做法，也是滥用继承的体现。滥用继承会破坏类之间客观存在的关系，也会模糊代码所体现的语义。 委派和继承都是为了提高代码的复用性，只是方式不同。委派：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象。继承：利用extends来扩展一个基类。 （1）Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。示例代码： interfaceFlyable{ publicvoidfly(); } interfaceQuackable{ publicvoidquack(); } classFlyWithWingsimplementsFlyable{ @Override publicvoidfly(){ System.out.println("flywithwings"); } } classQuackimplementsQuackable{ @Override publicvoidquack(){ System.out.println("quacklikeduck"); } } interfaceDucklikeextendsFlyable,Quackable{ } publicclassDuckimplementsDucklike{ //delegation FlyableflyBehavior; QuackablequackBehavior; //设置delegation对象实例 publicvoidsetFlyBehavior(FlyableflyBehavior){ this.flyBehavior=flyBehavior; } publicvoidsetQuackBehavior(QuackablequackBehavior){ this.quackBehavior=quackBehavior; } //通过delegation实现具体行为 @Override publicvoidfly(){ this.flyBehavior.fly(); } @Override publicvoidquack(){ this.quackBehavior.quack(); } } publicclassClient{ publicstaticvoidmain(String[]args){ Flyablef=newFlyWithWings(); Quackableq=newQuack(); Duckd=newDuck(); d.setFlyBehavior(f); d.setQuackBehavior(q); d.fly(); d.quack(); } } （2）Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。示例代码： publicinterfaceStudy{ intstudy(Stringcontent); } classStudyInClassimplementsStudy{ @Override publicintstudy(Stringcontent){ return1; } } classStudyByMoocimplementsStudy{ @Override publicintstudy(Stringcontent){ return2; } } classStudent{ privateStringname; privateMap<String,Integer>scores=newHashMap<String,Integer>(); publicMap<String,Integer>getScores(){ returnscores; } //AF:name为学生名字，scores中的key为学科名字，value为学生成绩 //RI:学生成绩范围为[0,100] publicStudent(Stringname){ this.name=name; } publicintgetFinalScore(){ inttotal=0; for(Stringcontent:scores.keySet()){ total+=scores.get(content); } returntotal; } //建立临时性的delegation关系 publicintstudy(Stringcontent,Studymethod){ System.out.print(content+":\t"); returnmethod.study(content); } publicvoidgetScore(Stringcontent,Studymethod){ intscore=method.study(content); scores.put(content,score); } publicstaticvoidmain(String[]args){ StudyinClass=newStudyInClass(); StudybyMooc=newStudyByMooc(); StudentWu=newStudent("wyf"); Wu.study("软件构造",inClass); Wu.getScore("软件构造",inClass); System.out.println(Wu.getScores().get("软件构造")); Wu.study("计算机系统",byMooc); Wu.getScore("计算机系统",byMooc); System.out.println(Wu.getScores().get("计算机系统")); System.out.println("总成绩："+Wu.getFinalScore()); } （3）Composition:更强的association，但难以变化。也就是以下代码Association中的法二。（4）Aggregation:更弱的association，可动态变化。也就是以下代码Association中的法一。 //法一：在构造方法中传入参数绑定 Flyablef=newFlyWithWings(); Duckd=newDuck(f); d.fly(); classDuck{ Flyablef;//这个必须由构造方法传入参数绑定 publicDuck(Flyablef){this.f=f;} publicvoidfly(){f.fly();} } //法二：在rep或构造方法中直接写死 Duckd=newDuck(); d.fly(); classDuck{ //这两种实现方式的效果是相同的 Flyablef=newFlyWithWings();//写死在rep中 publicDuck(){f=newFlyWithWings();}//写死在构造方法中 publicvoidfly(){f.fly();} } 参考文献：https://blog.csdn.net/weixin_44940258 
第204篇文章[0]
IdeaTest文件无法正常与运行文件链接newInstanceWithCaller 在编写完@Test代码测试程序时无法正常运行，出现如下问题 这里可能是因为两个程序没有指定在一个package内，或者命名相同但测试文件夹指定不同 可以在检查开头的packageinterval 或者右键单击test文件夹，选择markdirectoryas选项 
第205篇文章[0]
ADT设计时不可变性的保持 分两种情况，属性为不可变和可变 1.例如一个ADT Graph， 不能直接使用Graph.lenth（lenth为Graph中的一个属性），应该使用Graph.getLength() publicintgetLength(){ returnthis.length } intlength 为不可变（基本数据类型都为不可变）， 可以直接return 2. 如果ADT的field中有如下定义 publicclassGraph{ Datedate; intlength; } Date是一个可变类型，那么我们使用修改函数进行修改时，需要返回一个新的修改的对象，而非对其直接进行修改 无论可变不可变，return的一定是immutable的 
第206篇文章[0]
set的基本用法 set是一棵红黑树，在一些操作上十分高效，还具有许多priority_queue没有的功能 下面是基本用法 //set #include<set> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; set<int>s; intmain() { intn; cin>>n; for(inti=1;i<=n;i++) { intt; cin>>t; s.insert(t); } //遍历： set<int>::iteratorit;//正向迭代器 for(it=s.begin();it!=s.end();it++)//正向遍历（即由小到大输出） cout<<*it<<""; cout<<endl; set<int>::reverse_iteratorrit;//反向迭代器 for(rit=s.rbegin();rit!=s.rend();rit++)//反向遍历（即由大到小输出） cout<<*rit<<""; //元素的删除：可以删除迭代器上的元素，等于某键值的元素，区间上的元素和清空集合 it=s.begin(); for(inti=1;i<=2;i++) s.erase(it++); for(it=s.begin();it!=s.end();it++) cout<<*it<<""; cout<<endl; s.clear(); for(it=s.begin();it!=s.end();it++) cout<<*it<<""; cout<<endl; //元素的检索：用s.find()，如果找到，则返回迭代器位置，否则返回s.end(); s.insert(5); cout<<*s.find(5)<<endl; if(s.find(20)==s.end())cout<<"NO"; return0; } 很多用到set时需要进行重载运算符，用法如下 //set #include<set> #include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> usingnamespacestd; structmycmp//当set中的元素不是结构体时 { booloperator()(constint&a,constint&b) { returna%10<b%10; } }; set<int,mycmp>s1; structpoint { intx,y; booloperator<(constpoint&a)const//当set中的元素是结构体时,直接写在结构体中 { returnx<a.x;//按照x从小到大排序 } }; set<point>s2; intmain() { intn;cin>>n; for(inti=1;i<=n;i++) { intt;cin>>t;s1.insert(t); } set<int,mycmp>::iteratorit1; for(it1=s1.begin();it1!=s1.end();it1++) cout<<*it1<<""; cout<<endl; for(inti=1;i<=n;i++) { pointt; cin>>t.x>>t.y; s2.insert(t); } set<point>::iteratorit2; for(it2=s2.begin();it2!=s2.end();it2++) cout<<(*it2).x<<""; return0; } 
第207篇文章[0]
几种重要的设计模式的便于记忆归纳 1. 适配器：把所有拉进来，根据情况执行 2. 装饰器：把要装饰的拉进来，再添点操作 3. 模版：抽象类，空三个，写一个用这三个，这三个在子类中实现 4. 策略：一个类引用另一种策略类，执行策略类中的操作，策略类可以换 5. 访问者：访问者类引用多个被访问者类，判断后输出判断结果 
第208篇文章[0]
git逻辑梳理 1.大致分为但各区域 workspace stage(标记文件) localrepository remoterepository -gitadd-> -gitcommit-> -gitpush-> 2.发生冲突时（对一个文件进行了不同修改） 两个个branch不能再进行合并 3.fetch 直接从远端拷贝下来，相同文件覆盖 4.对于没有冲突的不同文件，可以进行merge 5.gitpull=fetch+merge 
第209篇文章[0]
静态工厂方法的实例理解 先上例子 主要思路为在接口中定义一个静态的函数，可以直接初始化一个任意的实现类 这样在多个实现类的情况下，在具体调用过程中可以不管具体实现操作，直接初始化接口的特定实现类 在每个实现类中特性化地实现构造函数即可 
第210篇文章[0]
关于git的一些知识 1.git的一些命令添加文件：gitaddxx.xx提交文件：gitcommit-m“message”push到远程仓库：gitpushoriginmaster从远程仓库pull：gitpulloriginmaster新建分支：gitcheckout-bbranch_name切换分支：gitcheckoutbranch_nameorgitcheckoutmaster选择一个分支与当前分支合并：gitmergebranch_name2（之前已有指令gitcheckoutbranch_name1）2.使用git提交作业的时候，记得检查名字。若名字不对，进入settings里边修改。以实验2为例：3.初次接触git的时候，我们会比较迷茫。我们应该先学会如何配置git，通过网上的相关教程。有些教程存在错误，我们在多次检查之后，如果依然行不通，我们应该换一个教程。第一次配置的时候，我在同学的帮助下才完成。然后我们应该了解git的相关指令。记住指令，我们才能将写好的代码上传。4.分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（gitclone），在本地机器上拷贝一个完整的Git仓库。Git的功能特性：从一般开发者的角度来看，git有以下功能：1、从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。2、在自己的机器上根据不同的开发目的，创建分支，修改代码。3、在单机上自己创建的分支上提交代码。4、在单机上合并分支。5、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。6、生成补丁（patch），把补丁发送给主开发者。7、看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。8、一般开发者之间解决冲突的方法，开发者之间可以使用pull命令解决冲突，解决完冲突之后再向主开发者提交补丁。从主开发者的角度（假设主开发者不用开发代码）看，git有以下功能：1、查看邮件或者通过其它方式查看一般开发者的提交状态。2、打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。3、向公共服务器提交结果，然后通知所有开发人员。优点：适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。缺点：学习周期相对而言比较长。不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。 
第211篇文章[0]
java中ArrayList相关应用 初始化：1.动态初始化（指定长度）：数据类型[]数组名称=new数据类型（数据长度）2.静态初始化（指定内容）：数据类型[]数组名称=new数据类型[]{元素1，元素2…} 添加：ArrayListarrayList=newArrayList();arrayList.add(“0”);arrayList.add(“1”); 获取集合元素：ArrayListarrayList=newArrayList();arrayList.add(“0”);arrayList.add(“1”);arrayList.add(“2”);Stringa=arrayList.get(1);Stringb=arrayList.get(2);System.out.println(a);System.out.println(b); 删除集合中的元素：ArrayListarrayList=newArrayList();arrayList.add(“0”);arrayList.add(“1”);arrayList.add(“2”);//先创建Stringa=arrayList.remove(3);System.out.println(“删除的是：”+a); 获取集合长度ArrayListarrayList=newArrayList();arrayList.add(“0”);arrayList.add(“1”);arrayList.add(“2”);//创建ArrayList集合intsize=arrayList.size();System.out.println(“ArrayList集合长度：”+size); 
第212篇文章[0]
java练手：万年历 clock：packagewannianli; publicclassClock{privateDisplayhour=newDisplay(24);privateDisplayminiute=newDisplay(60);privateDisplaysecond=newDisplay(60);privateDisplayyear=newDisplay(9999);privateDisplaymonth=newDisplay(12);privateDisplayday;publicvoidstart(){inti,j;for(;;){i=year.getValue();j=month.getValue();if(i%4000||i%40&&i%100!=0){if(j2){day=newDisplay(29);}elseif(j1||j3||j5||j7||j8||j10||j12){day=newDisplay(31);}else{day=newDisplay(30);}}else{if(j2){day=newDisplay(28);}elseif(j1||j3||j5||j7||j8||j10||j12){day=newDisplay(31);}else{day=newDisplay(30);}}second.increase();if(second.getValue()==0){miniute.increase();if(miniute.getValue()==0){hour.increase();if(hour.getValue()==0){day.increase();if(day.getValue()==0){month.increase();if(month.getValue()==0){year.increase();}}}}}System.out.printf("%04d:%02d:%02d:%02d:%02d:%02d\n",year.getValue(),month.getValue(),day.getValue(),hour.getValue(),miniute.getValue(),second.getValue());}}publicstaticvoidmain(String[]args){Clockc=newClock();c.start(); } } displaypackagewannianli; publicclassDisplay{ privateintvalue=0; privateintlimit=0; publicDisplay(intlimit) { this.limit=limit; } publicvoidincrease() { value++; if(value==limit) { value=0; } } publicintgetValue() { returnvalue; } } 
第213篇文章[0]
面向对象编程 面向对象(ObjectOriented)是一种编程范式。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。面向对象与面向过程相对，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。面向对象的性质（1）对象唯一性每个对象都有自身唯一的标识，通过这种标识，可找到相应的对象。在对象的整个生命期中，它的标识都不改变，不同的对象不能有相同的标识。（2）抽象性抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。（3）继承性继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。继承性是面向对象程序设计语言不同于其它语言的最重要的特点，是其他语言所没有的。在类层次中，子类只继承一个父类的数据结构和方法，则称为单重继承。在类层次中，子类继承了多个父类的数据结构和方法，则称为多重继承。多重继承，JAVA、VB、NET、Objective-C均仅支持单继承，注意在C++多重继承时，需小心二义性。在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重用性。采用继承性，提供了类的规范的等级结构。通过类的继承关系，使公共的特性能够共享，提高了软件的重用性。（4）多态性多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。多态性允许每个对象以适合自身的方式去响应共同的消息。多态性增强了软件的灵活性和重用性。 
第214篇文章[0]
java练手：城市之间距离 packagejava4; importjava.util.ArrayList;importjava.util.Scanner; publicclassa{ publicstaticvoidmain(String[]args){ ArrayList<String>hs=newArrayList<String>(); Scannerin=newScanner(System.in); Stringstr; intn=0; System.out.println("请输入城市"); for(;;) { str=in.next(); Strings="###"; if(str.equals(s)) { System.out.println("城市输入结束"); break; }//若输入“###”表示城市输入结束 hs.add(str); n++; }//循环读入城市并存入容器hs中 int[][]a=newint[n][n]; Scannerin2=newScanner(System.in); System.out.println("请输入距离"); for(inti=0;i<n;i++) { for(intj=0;j<n;j++) { a[i][j]=in2.nextInt(); } }//将距离矩阵读入，存入二维数组a中 System.out.println("结束输入距离"); Stringstr1,str2; Scannerin3=newScanner(System.in); System.out.println("请输入两个城市"); str1=in3.next();//读入第一个要比较的城市 str2=in3.next();//读入第二个要比较的城市 intq=0,w=0; for(intm=0;m<n;m++) { if(hs.get(m).equals(str1)) { q=m;//记录下第一个城市在容器中位置，即矩阵横坐标 break; } }//寻找第一个输入的城市在容器中的第几位 for(intm=0;m<n;m++) { if(hs.get(m).equals(str2)) { w=m;//记录下第二个城市在容器中位置，即矩阵纵坐标 break; } }//寻找第二个输入的城市在容器中的第几位 System.out.println("输出距离："+a[q][w]);//矩阵第i行第j列表示第i个城市与第j个城市之间的距离 } } 
第215篇文章[0]
java中map相关知识和操作 Map概述：Map用于保存具有映射关系的数据，Map集合里保存着两组值，一组用于保存Map的ley，另一组保存着Map的value。Map集合的功能概述a:添加功能put(Kkey,Vvalue).b:删除功能voidclear();valueremove(key);c:判断功能booleancontainsKey(key);booleancontainsValue(value);booleanisEmpty()；d:获取功能valueget(key);intsize();//存在即返回键值，否则返回NULL，可以通过返回值来确定是否包含指定键，获取键值对的个数。e:长度功能intsize()：返回集合中的键值对的对数f:取出所有元素先获取map集合中的键存放进set集合中。通过Set集合的迭代器取出Set集合中键，通过map的get(key)方法获取键对应的值。g:Map下常用的子类：Hashtable：内部结构是哈希表。是同步的。不允许键和值为null。其内部子类Properties：用来存储键值对型的配置信息。HashMap：内部结构是哈希表，是不同步的。TreeMap：内部结构是二叉树。是不同步的，可以对Map中的键进行排序。 
第216篇文章[0]
软件构造lab2 实验目标概述 根据实验手册简要撰写。 针对给定的应用问题，从问题描述中识别所需的ADT； 设计ADT规约（pre-condition、post-condition）并评估规约的质量； 根据ADT的规约设计测试用例； ADT的泛型化； 根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction） 使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure） 测试ADT的实现并评估测试的覆盖度； 使用ADT及其实现，为应用问题开发程序； 在测试代码中，能够写出testingstrategy并据此设计测试用例。 实验环境配置 简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。 特别是要记录配置过程中遇到的问题和困难，以及如何解决的。 安装配置EclEmma 在这里给出你的GitHubLab2仓库的URL地址（Lab2-学号）。 实验过程 请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。 PoeticWalks 在这里简要概述你对该任务的理解。 实现并测试具有标记顶点的Graph。然后实现一个使用单词的图生成诗歌的类 GetthecodeandprepareGitrepository 如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。 从实验指南中发布的链接上直接下载获取 Problem1:TestGraph<String> 以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。 testadd():测试能不能加入新顶点testSet():测试能不能加入一条新边testRemove():在图中加入一条边，然后删除某顶点，测试这条边是否还存在testVertices():向图中加入顶点测试集合是否正确testsSources():向图中加入顶点和边测试是否返回源头点和权重testTargets():向图中加入顶点和边测试测试某顶点相连是否正确 Problem2:ImplementGraph<String> 以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。 ImplementConcreteEdgesGraph Edge：用source表示源点，target表示目标点，weight表示权重，编写get以上三种数据，然后检查是否存在非法数据 ImplementConcreteVerticesGraph Vertex：用vertexname表示顶点，map存储与改点有关的数据，check检查是否存在空顶点。 Problem3:ImplementgenericGraph<L> Maketheimplementationsgeneric 搜索所有的string并将其转换为L ImplementGraph.empty() 利用conctreteedgesgraph（）实现Graph.empty() Problem4:Poeticwalks TestGraphPoet 借助测试用例实现功能 ImplementGraphPoet 从文本中获得单词图，返回处理好的字符串 Graphpoetryslam 使用Eclemma检查测试的代码覆盖度Beforeyou’redone 请按照C:\Users\a\Downloads\before_youre_donehttp://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done的说明，检查你的程序。 如何通过Git提交当前版本到GitHub上你的Lab2仓库。 在这里给出你的项目的目录结构树状示意图。 Re-implementtheSocialNetworkinLab1 在这里简要概述你对该任务的理解。 在定义了Graph的情况下，实现friendshipgraph类 FriendshipGraph类 给出你的设计和实现思路/过程/结果。 用Graph表示人物关系 Addvertex（）添加顶点 Getdistance（）寻找最短路径并返回路径长度 Person类 给出你的设计和实现思路/过程/结果。 Name表示顶点名字。 Distance表示最短距离。 Map存储所有相连顶点及其权重 List存储所有相连顶点 Check检查是否有重复级和空元素 客户端main() 给出你的设计和实现思路/过程/结果。 由lab1实验指南可得 测试用例 给出你的设计和实现思路/过程/结果。 提交至Git仓库 如何通过Git提交当前版本到GitHub上你的Lab3仓库。 Gitadd Gitcommit-m“xxxx” Gitpushoriginmaster 在这里给出你的项目的目录结构树状示意图。 实验进度记录 请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。 每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。 不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。 日期时间段计划任务实际完成情况2021/6/519:00-22:003.1完成2021/6/719:00-22:003.2粗糙完成2021/6/1312:00-16:00修改bug，完成报告完成 实验过程中遇到的困难与解决途径 遇到的难点解决途径函数较为复杂，编写过程中多次出现问题继续练习，熟练编写技巧分析图中关系时顺序混乱从头理头绪 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 丰富了对于不同类的理解和应用，进一步提高了编程和算法能力 针对以下方面的感受面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？ ADT能够复用数据结构和一系列方法，让代码更加清晰 使用泛型和不使用泛型的编程，对你来说有何差异？ 泛型更方便但限制条件多 在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？ 在一边实现具体类时可以一边测试，利于修改 P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？ 能够提高效率 P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？ 还没理解透彻，仍感到一些困难 为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？ 使开发者能够注意步骤，避免编程混乱 关于本实验的工作量、难度、deadline。 工作量比较大，需要比较长的时间 《软件构造》课程进展到目前，你对该课程有何体会和建议？ 学会了如何提高效率，实现更好的编译 实验目标概述 根据实验手册简要撰写。 针对给定的应用问题，从问题描述中识别所需的ADT； 设计ADT规约（pre-condition、post-condition）并评估规约的质量； 根据ADT的规约设计测试用例； ADT的泛型化； 根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction） 使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure） 测试ADT的实现并评估测试的覆盖度； 使用ADT及其实现，为应用问题开发程序； 在测试代码中，能够写出testingstrategy并据此设计测试用例。 实验环境配置 简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。 特别是要记录配置过程中遇到的问题和困难，以及如何解决的。 安装配置EclEmma 在这里给出你的GitHubLab2仓库的URL地址（Lab2-学号）。 实验过程 请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。 PoeticWalks 在这里简要概述你对该任务的理解。 实现并测试具有标记顶点的Graph。然后实现一个使用单词的图生成诗歌的类 GetthecodeandprepareGitrepository 如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。 从实验指南中发布的链接上直接下载获取 Problem1:TestGraph<String> 以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。 testadd():测试能不能加入新顶点testSet():测试能不能加入一条新边testRemove():在图中加入一条边，然后删除某顶点，测试这条边是否还存在testVertices():向图中加入顶点测试集合是否正确testsSources():向图中加入顶点和边测试是否返回源头点和权重testTargets():向图中加入顶点和边测试测试某顶点相连是否正确 Problem2:ImplementGraph<String> 以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。 ImplementConcreteEdgesGraph Edge：用source表示源点，target表示目标点，weight表示权重，编写get以上三种数据，然后检查是否存在非法数据 ImplementConcreteVerticesGraph Vertex：用vertexname表示顶点，map存储与改点有关的数据，check检查是否存在空顶点。 Problem3:ImplementgenericGraph<L> Maketheimplementationsgeneric 搜索所有的string并将其转换为L ImplementGraph.empty() 利用conctreteedgesgraph（）实现Graph.empty() Problem4:Poeticwalks TestGraphPoet 借助测试用例实现功能 ImplementGraphPoet 从文本中获得单词图，返回处理好的字符串 Graphpoetryslam 使用Eclemma检查测试的代码覆盖度Beforeyou’redone 请按照C:\Users\a\Downloads\before_youre_donehttp://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done的说明，检查你的程序。 如何通过Git提交当前版本到GitHub上你的Lab2仓库。 在这里给出你的项目的目录结构树状示意图。 Re-implementtheSocialNetworkinLab1 在这里简要概述你对该任务的理解。 在定义了Graph的情况下，实现friendshipgraph类 FriendshipGraph类 给出你的设计和实现思路/过程/结果。 用Graph表示人物关系 Addvertex（）添加顶点 Getdistance（）寻找最短路径并返回路径长度 Person类 给出你的设计和实现思路/过程/结果。 Name表示顶点名字。 Distance表示最短距离。 Map存储所有相连顶点及其权重 List存储所有相连顶点 Check检查是否有重复级和空元素 客户端main() 给出你的设计和实现思路/过程/结果。 由lab1实验指南可得 测试用例 给出你的设计和实现思路/过程/结果。 提交至Git仓库 如何通过Git提交当前版本到GitHub上你的Lab3仓库。 Gitadd Gitcommit-m“xxxx” Gitpushoriginmaster 在这里给出你的项目的目录结构树状示意图。 实验进度记录 请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。 每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。 不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。 日期时间段计划任务实际完成情况2021/6/519:00-22:003.1完成2021/6/719:00-22:003.2粗糙完成2021/6/1312:00-16:00修改bug，完成报告完成 实验过程中遇到的困难与解决途径 遇到的难点解决途径函数较为复杂，编写过程中多次出现问题继续练习，熟练编写技巧分析图中关系时顺序混乱从头理头绪 实验过程中收获的经验、教训、感想 实验过程中收获的经验和教训 丰富了对于不同类的理解和应用，进一步提高了编程和算法能力 针对以下方面的感受面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？ ADT能够复用数据结构和一系列方法，让代码更加清晰 使用泛型和不使用泛型的编程，对你来说有何差异？ 泛型更方便但限制条件多 在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？ 在一边实现具体类时可以一边测试，利于修改 P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？ 能够提高效率 P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？ 还没理解透彻，仍感到一些困难 为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？ 使开发者能够注意步骤，避免编程混乱 关于本实验的工作量、难度、deadline。 工作量比较大，需要比较长的时间 《软件构造》课程进展到目前，你对该课程有何体会和建议？ 学会了如何提高效率，实现更好的编译 
第217篇文章[0]
ArrayListLinkList效率对比 由于老师上课的时候讲到了ArrayListLinkList效率不同，于是课下查找资料，并写了一个二者效率对比的小代码。 首先通过查找资料我了解到：1.LinkedList和ArrayList的差别主要来自于Array和LinkedList数据结构的不同。ArrayList是基于数组实现的，LinkedList是基于双链表实现的。另外LinkedList类不仅是List接口的实现类，可以根据索引来随机访问集合中的元素，除此之外，LinkedList还实现了Deque接口，它代表一个双向队列，因此LinkedList可以作为双向队列，栈和List集合使用。 2.因为Array是基于索引的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。 3.相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引。 4.LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。 首先我们测试ArrayListLinkList增加新的内容时效率上的区别。代码如下： 测试结果为： 可以看出array比link快。可能是因为在不修改指针的时候，在往数据末尾新增的时候速度还是比LinkList速度快。 然后测试插入操作： 结果为： 可以看出link确实比array快很多，因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。 
第218篇文章[0]
软件构造lab2回顾 前言 临近期末考试，开始对知识点进行整理，对课程布置的实验进行回顾。经过反复对比，感觉还是动手实验对知识获取的帮助最大，逐步解决问题的过程让自己对课上知识的理解更深入了一些。Lab2这一部分的的主要内容是ADT和OOP，实验目的也是抽象数据型的实现，以及面向对象编程。以下是对Lab2这一实验过程中遇到的一些事物做的简单回顾，课程中涉及到的其他重要知识点将在以后慢慢总结。 内容 一.实验目标概述 本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说： 针对给定的应用问题，从问题描述中识别所需的ADT； 设计ADT规约（pre-condition、post-condition）并评估规约的质量； 根据ADT的规约设计测试用例； ADT的泛型化； 根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction） 使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure）； 测试ADT的实现并评估测试的覆盖度； 使用ADT及其实现，为应用问题开发程序； 在测试代码中，能够写出testingstrategy并据此设计测试用例。 二.涉及到的一些知识 （一）代码覆盖度测试 实验中主要采用Eclemma对测试用例的覆盖度进行测试，在eclipse上的使用方式如下： 1.准备好要测试的代码和测试用例； 2.右键项目->选择CoverageAs->JavaApplication，便可以完成覆盖度测试。显示结果将给出各测试用例的覆盖度，如图所示： 打开被测试的类，其中代码背景颜色被涂成红色的部分即为未覆盖的部分，注意对项目进行覆盖度测试时，只有当被测试的代码覆盖完整时，才会显示绿色，因此未被测试的类中的代码也会一并标记为红色。 （二）对象的存储--对象容器 用来盛装对象的工具，其特点不只在于能够对某一类对象进行存储，而且Java对每一种容器本身也提供了不少相应的方法，使得对象容器使用起来将要简单很多。 1.对象列表 示例如下： ArrayList<String>l=newArrayList<String>() 对象列表ArrayList是一个有顺序的列表，其下标索引从0开始。对象在该列表中的存储是有序的，因此与集合Set不同，我们可以通过下标对ArrayList中的元素进行访问。它的优点在于随机访问元素快，但是在中间插入和移除比较慢。 实验中用到的除了基本的size等方法，以下几种方法让我印象较为深刻： add(intindex,Objectelement)：在列表的指定位置插入指定元素。 set(inti,Objectelement)：将索引i位置元素替换为元素element并返回被替换的元素。 个人认为，对象列表和C语言中的数组类似，既可以直接操作、寻找对象，也可以通过下标进行操作，但其元素的个数不固定，长度可变，操作时更加灵活。 2.集合容器 示例如下： Set<String>set=newHashSet<String>(); Set和数学中集合的概念类似，元素具有唯一性和无序性。所以Set最常用的就是测试归属性，很容易的询问出某个对象是否存在Set中。而若是要获得确定元素顺序的集合，可以用treeset来进行存储。 Set具有和Collection完全一样的接口，继承相应的方法但没有额外的功能，只是表现的行为不同。 3.哈希表 示例如下： Map<String,Integer>m=newHashMap<String,Integer>(); Map接口就像图表，关键字与关键字的值具有对应关系。类似于日常使用的字典，它根据键的hashCode值存储数据，也就是键-值对的方式存储，因此大多数情况下可以通过键名直接定位到它的值。Map具有很快的访问速度，但其遍历顺序却是不确定的。注意HashMap最多只允许一条记录的键为null，允许多条记录的值为null。 HashMap很特别的特点就是，我们可以根据关键字和关键字的值分别对表中的对象进行寻找、修改等操作。 （三）遍历访问容器中的对象--迭代器 JavaIterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代ArrayList和HashSet等集合。它是Java迭代器最简单的实现，ListIterator是CollectionAPI中的接口，它扩展了Iterator接口。 迭代器的使用使不可变数据型对象容器的遍历等操作变得更加方便，比如删除操作。 迭代器的两个基本操作是next、hasNext和remove：方法it.next()会返回迭代器的下一个元素，并且更新迭代器的状态；方法hasNext()会返回布尔值，用于检测集合中是否还有元素；而方法remove()的用途则是将迭代器返回的元素删除。 以下是写实验时设计的一个使用迭代器实现的方法： @Overridepublicbooleanremove(Lvertex){ Iterator<Vertex<L>>V=vertices.iterator(); while(V.hasNext()){ Vertex<L>v=V.next(); if(v.Getname().equals(vertex)){//removethevertexitself V.remove(); checkRep(); returntrue; } else{ if(v.Getsources().containsKey(vertex)){//removethevertexfromrelatedmaps(assource) v.removesource(vertex); } if(v.Gettargets().containsKey(vertex)){//removethevertexfromrelatedmaps(astarget) v.removetarget(vertex); } } } checkRep(); returnfalse; } 总结 实验2中还有很多较为核心的内容没有列出，文章只给出了一些Java语法及测试的使用方法，一些其他重要的内容将在以后总结。 
第219篇文章[0]
软件构造笔记（四）：Spec、AF和RI 前言 本文将介绍一些关于ADT设计中Spec、AF和RI的细节。由于内容较为细碎，为了加强理解，特将该部分知识点列出来，进行简单归纳总结。 一.Spec 刚开始接触软件构造时，关于规约Spec的概念便已经有所接触，但真正开始逐步认识还是在实验中设计规约的时候。 （一）含义 Spec是程序员在设计ADT时对自己所写方法的规约，它规定了方法应该做什么，不应该做什么。而在接下来的设计中，测试用例的编写就需要依靠Spec的描述，因为程序员所编写的代码必定是符合spec的，否则就是不合格的。同时，有了Spec的存在，客户端在使用代码时就会有所依据，好的Spec可以大大节省客户端使用自己的API时所需要的时间，并且大大降低了客户端对自己所编写的代码的误解。 （二）内容及评判标准 Spec的主要内容分为以下三部分： 1.前置条件precondition：这是对客户端的约束，是用户在使用方法时必须满足的条件。在Java中一般使用声明@param说明每个参数的前置条件。 2.后置条件postcondition：这是对开发者的约束，也是方法结束时设计者必须满足的内容。在Java中一般使用如下两种声明，其内容及用途如下： @return：对后置条件的说明，一般为返回值； @throws：说明出现异常的时候会发生什么，一般为异常处理方式。 （三）Spec强弱 若想要Spec变强，可以采用如下方式： 1.更宽松的前置条件 2.更严格的后置条件 如果是用椭圆在图中对不同的Spec强弱进行表示，则越小（包含的结果的点越少）的椭圆，其Spec越强，此处我们可以理解为：椭圆的大小代表了开发者的自由度。 （四）注意事项 程序员应该通过Spec让客户端轻松地知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，但不应该让用户知道方法的内部逻辑是怎么样的，以避免恶意用户对代码结构的破坏。 二.AF和RI 由于AF和RI之间存在映射关系，因此可以将两者放在一起进行讨论。 （一）含义 RI：RepInvariant。其中Invariant是不变量的意思，是ADT的功能中任何时候都应该满足的一些条件。 AF：AbstractionFunction。代表抽象函数。 （二）具体表示 AF和RI中的A和R分别代表两个空间：R是内部表示的空间，是开发者关注的内容；而A是ADT能表示的存在于实际的对象，一般是由客户所关注的。 而AF就是从R空间到A空间的一个映射，作为解释函数，对A空间的每一个对象，在R空间中都至少由一种属性或类型与之对应，因此该映射是一个满射。 而RI是一个集合，是R空间中所有值的子集，包含了所有合法的表示值。checkRep()方法就是用来随时检查RI是否被满足的。 此处附上自己在lab2中写过的AF、RI，以及Safetyfromrepexposure的描述： //Abstractionfunction: //AF(vertices)=点集 //Representationinvariant: //无重复点 //Safetyfromrepexposure: //privatefinalList<Vertex<L>>vertices （三）注意事项 RI、AF存在如下关系： 相同的R可能存在不同的RI； 即使是同样的R、RI，也可以根据解释不同，而获得不同的AF； 两个ADT有相同的rep和相同的AF，但其R也不 定相同。 不应该给client看的内容有AF、RI、Repexposuresafetyargument、testingstrategy、Rep、Implementation和Testcases等等，留给client的只有Spec。 总结 本文主要解释了一些ADT设计中关于Spec、AF和RI的含义、内容、注意事项等内容。其细节部分相对琐碎，但是在实际应用中非常重要，因此应该牢记，并在日后有需求的时候活学活用。 
第220篇文章[0]
软件构造lab3心得 前言 经过前后两周时间的调试和反复修改，终于完成了lab3实验指导手册中的内容(当然不一定很完善)。简单写一下心得，梳理一下自己实验中的收获，以及实验过程给我带来的新体会。外加临近期末考试，需要对知识点进行整理，对课程布置的实验进行回顾，因此决定写一篇博客，记录一下lab3给我带来的收获。 内容 一.实验目标概述 该实验的目标是编写具有可复用性和可维护性的软件，主要使用以下软件构造技术： 子类型、泛型、多态、重写、重载； 继承、代理、组合； 语法驱动的编程、正则表达式； API设计、API复用； 本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过ADT和泛型等抽象技术，开发一套可复用的ADT及其实现，充分考虑这些应用之间的相似性和差异性，使ADT有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。 二.实验中遇到的一些知识 （一）委派(delegation) 该实验设计过程中主要涉及到了委派的思想，用于提高代码的可复用性。 委托的含义：当我们设计ADT时，若遇到一个对象需要另一个对象的功能时，便可以让新对象捕获该对象，并可以在另一对象中对其进行功能调用，这个过程便是委托。 在使用委派时，过程涉及到的类A和类B是两个没有任何关系的类，而B具有和A一模一样的方法和属性；当我们调用B中的方法时，调用B中的属性就等价于调用A中同名的方法和属性。此时B如同得到A授权委派的中介。调用B类的代码不需要知道A的存在，也不会和A发生直接的联系，而通过B就可以直接使用A的功能，这样的模式，既能够使代码使用到A的各种属性及功能，又能够很好地将A保护起来。 委派与继承的操作过程相似，都是对某一个类进行复用，但两者实际上存在较大差异：继承是在一个现有类的基础上去构建一个新的类，而这个构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承（非父类私有）的属性和方法。如果想声明一个类继承另一个类，需要使用extends关键字。而委派的双方往往是关联不大的两个类，一般当想要调用一个类中的少部分属性或方法时，便可以采用委派的方法。而当多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要对那个类进行继承即可。 比如说，水果的榨汁过程需要工厂的操作，是因为水果自己不具有榨汁的功能，因此我们可以把水果交给工厂类中的方法进行处理，这便是委托的过程。 而水果成熟后，会从生长的植株上下落，这种下落的行为在水果中很常见，苹果、梨也有下落的行为，因此便可以在水果类中写下这种行为，然后在苹果类中通过extends获得这个方法的复用，这便是继承的过程。 （二）Decorator装饰器模式 Lab3中，自己对三个应用类的设计其实是采用了第五种方案，不过在实验设计完成以后又通过查阅资料对另外五种设计方案进行了简单的了解，感觉第六种方案更加简便，因此在这里介绍一下Decorator设计模式。 为了让每一个子类实现不同的特性，采用Decorator设计模式，为对象增加不同侧面的不同特性。该设计模式的原理如下： 首先从接口派生出子类，并在子类中定义一个父类接口，将其作为delegation的对象。这个过程类似于子类型自己到自己(该接口的其他子类)的委派。这两个类都是同一个接口的子类。 使用装饰类，通过一层一层反复装饰，最终得到的对象可以拥有任意不同特性的组合，我觉得这就是Decorator模式最精妙的地方，只要ADT设计得当，复用后使用起来将会非常简便。而装饰的顺序并不会影响到对象的最终结果拥有哪些特性，唯一的影响在于最终得到的是哪个类型的对象，即最后一次装饰的特性决定了最终得到哪个具体类型的对象。 三.自己在实现过程中遇到的困难及解决过程 实验刚开始进行的时候，我曾经犯过一个很低级的错误，就是将interface写在了class类中，后来通过对lab1、lab2中涉及到复用的代码进行查看才发现自己的错误所在。个人认为，interface和class在层次上可以是并列关系，接口类似于类，但其成员都没有执行方式，它只是方法、属性等内容的组合。 总结 实验3中还有很多较为核心的内容没有列出，文章只给出了一些Java语法及ADT复用的原理及使用方法，一些其他重要的内容将在以后总结。 
第221篇文章[0]
软件构造笔记（三）：关于等价性的个人理解 前言 前两篇博客中介绍了自己软件构造的第二次、第三次实验内容及心得体会，本文将介绍一些软件构造学习过程中遇到的一部分知识点难点，剩余的内容将在随后补充。 一.引用等价性和对象等价性 （一）引用等价性==： 该比较符号比较的内容是索引，它测试的是指向相等，如果两个索引指向同一块存储区域，那它们就是相等的。对于基本数据类型，我们只能使用这种方式进行比较，若相同，结果为true；否则为false。 （二）对象等价性：equals()： 这是一种方法，比较的是对象的内容，用来测试对象的值是否相等，复合数据类型和对象都通过这种方式进行比较。 总结：当对两个同类型对象进行比较时，这两种比较方式的结果不一定相同，当我们比较引用等价性时，除非是同一个new出来的对象，否则结果为false。而当我们比较对象等价性时，则会根据对象内容及重写情况比较，若无重写则结果会等同于双等号比较。 二.hashCode()方法 （一）对于不可变类型： equals()应该比较抽象值是否相等。这和equals()比较行为等价性是一样的。 hashcode()应该将抽象值映射为整数。 不可变类型需同时重写equals()和hashcode()。 （二）对于可变类型： equals()应该比较索引，就像==一样。同样的，这也是比较行为相等性。 hashcode()应该将索引映射为整数。 所以可变类型不用重写这两个方法，直接继承Object中的即可。 三.观察等价性与行为等价性： （一）观察等价性： 两个索引在不改变各自对象状态的前提下不能被区分。即通过只调用observer，producer和creator中的方法，它测试的是这两个索引在当前程序状态下“看起来”相等。 （二）行为等价性： 两个索引在任何代码的情况下都不能被区分，即使有一个对象调用了改造者，它测试的是两个对象是否会在未来的所有状态下“行为”相等。 讨论 从前在实验里会常常用到equals()，但是没有注重过equals()的具体应用场景和重写。而在不够理解等价性的定义时候，我使用的方法多为，直接加条件判断，把需要判断相等即等于对象相等的变量直接放入条件判断语句，这正是比较观察等价性的一种体现，而以后对于可变数据型，定义新的方法就等同于使用条件语句判断，对于不可变数据类型，重写也就是注重对象中的“一部分”是等价的，就可满足条件。 此外，观察等价性与行为等价性的区分是可变数据类型特有的对象等价性区分特征，这里也需要注意一下。 
第222篇文章[0]
HIT软件构造五 HIT软件构造笔记五Object-OrientedProgramming1、Interface接口接口可以实现静态方法，使用static关键字。 通过static关键字可以实现静态工厂方法，从而将接口的实现类封装，实现对外信息隐藏。 接口中也允许使用default关键字来定义并实现实例方法，这个应用有点类似于抽象类的功能。 通过default方法，在接口中统一实现某些功能，无需在各个类中重复实现它。2、继承和重写子类覆写的方法的可见性要大于等于父类，因为子类的对象应可以转型为父类对象，可见性的降低就会出现错误。同理，子类抛出的异常必须是父类的子集。 覆写的方法是在运行时判断类型来调用的，因此以new构造的类型为准。 在子类中,用super关键字来调用父类的各种方法，用的最多的是构造方法。3.、多态三种多态：特殊多态、参数化多态、子类型多态特殊多态:一个方法可以有多个同名的实现(方法重载)。要求参数列表必须有不同的地方，其他的并没有要求，总之就是把重载的方法看作和之前完全不同的方法。参数化多态:一个类型名字可以代表多个类型(泛型化编程)。子类型/包含多态:一个变量名字可以代表多个类的实例。 4.ADT与OOP中的等价性判断等价性的方法①利用数学上等价的定义:满足自反性，对称性和传递性。②利用AF来定义ADT的等价判断，如果两个值的AF映射值相同，则说明他们等价。③在调用者角度，如果调用两个对象的所有任意操作，效果都完全一样，那么则说明他们等价。 “”与equals对于“”,代表着判断两个对象的地址空间是不是在同一个位置，也被称为引用等价性；而equals则代表着判断两个对象的内容，也被称为对象等价性。 object类的equals默认为判断两者的地址空间是不是在同一位置。总的来说，对于基本数据类型，我们应该用“==”，而对于对象数据类型，我们应该用equals判断(当然，要根据需要判断是否应该覆写)，当然，我们要明确知道我们写的方法是覆写还是重载。 除了写equals方法，尽量不要用instanceof和getclass()，因为他们不符合OOP的思想，不是好的书写风格。 hashcode与equalshashcode方法就类似于数据结构中的哈希函数一样，功能就是把一个个对象映射到一个地址(也就是桶)。默认的方式是按照地址映射，一般地址不同则值不同。 当我们使用HashSet等类似的数据结构的时候，这时再进行寻找时，就如同正常哈希表一样了，是通过判断哈希值是否相等先进行判断，哈希值相同是equals成立的前提，也是首先判断的方法。此时如果我们只重写equals而不重写hashcode，则hashcode还是默认的按地址算出一个值，一般而言只要地址不同则哈希值就不同了，导致了我们equals方法看似失效。 综上，equals()应满足如下条件：首先满足等价性(数学意义上)，其次保证在不被修改的情况下，每次调用的结果应该相同，同时要处理对象为null的情况还有如果这个类使用了哈希表进行查询(比如放入了HashSet中)，则也要覆写hashcode方法。 可变类型的等价性：观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致。调用Observer方法表现出相同的结果。约等于对象等价性。行为等价性：调用对象的任何方法都展示出一致的结果。包括mutator、producer、observer。约等于引用等价性。 equals()和hashCode()所以，对可变类型，实现行为等价性即可，也就是说，只有指向同样内存空间的对象才是相等的。所以对可变类型来说，无需重写这两个函数，直接继承Object的equals()和hashCode()即可。 5.装箱及其等价性 在使用集合类时，我们前面也提到过，会进行隐式的装箱操作。因此，装箱完毕后，如果是两个不同对象，即使是整数的装箱，使用“==”进行判断也会返回false，要进行equals的覆写。 但是下面有一个特例，那就是如果是-128到127之间的整数，进行两次装箱操作，那得到的地址是一样的(得益于java的缓存机制)。当然，上面也是要求只装箱，不能为两次new的操作，不然肯定地址值不同。 
第223篇文章[0]
HIT软件构造笔记三 HIT软件构造笔记三1.1DataTypeandTypeChecking 编程语言的数据类型基本数据类型(int、boolean、char、byte、double、long)，Immutable，在栈中分配内存，代价也比较低对象数据类型(String、Integer等)。Immutable/Mutable，分配的内存都在堆中，代价相对昂贵 基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。2.类型检查静态类型语言(Java)可执行静态类型检查，在编译阶段进行类型检查，这意味着避免了将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误都可以在静态类型检查时发现；动态类型语言(python)只有动态类型检查，在运行阶段才会进行类型检查，例如非法的参数值(最典型的NULL引用)、非法的返回值、越界等等。3.Mutability和ImmutabilityImmutability：不变性，一个重要的设计原则，设计ADT时尽量保证这个原则。 Immutabletypes：不可变的数据类型，当实例对象被创建以后，该对象的值就不可变化了，也就是该ADT中不能有mutator方法。 可变对象的优点：虽然mutable类型由于指向的是同一个存储区域，所以更改对象的内容后会在意想不到的位置产生意想不到的变化，所以更推荐使用Imutable的数据类型，但是使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，比如依次将‘a’~‘z’连接到一个空字符串上，就会产生25个临时拷贝，而使用可变类型则最少化拷贝以提高效率。 使用可变数据类型，可获得更好的性能。但是在质量指标中，性能的优先级较低，所以即使mutable类型有这个优点也更倾向于选择imutable的类型。 4.Snapshotdiagram基本类型的值对象类型的值：mutable对象，单线圈；immutable对象，双线圈；可变的引用，单线箭头；不可变的引用，双线箭头 5.集合类型List Set Map 1.2DesigningSpecification1、Spec的用处；没规约，没法写程序；即使写出来，也不知道对错；规约是程序与客户端之间达成的一致；Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守；很多bug来自于双方之间的误解，不写下来，那么不同开发者的理解就可能不同；没有规约，难以定位错误；精确的规约，有助于区分责任；客户端无需阅读调用函数的代码，只需理解spec即可2、Spec的结构：precondition前置条件：对客户端的约束，在使用方法时必须满足的条件使用@paramannotation说明每个参数的前置条件postcondition后置条件：对开发者的约束，方法结束时必须满足的条件使用@returnannotation说明后置条件使用@throwsannotation说明出现异常的时候会发生什么在方法声明中使用static等关键字声明，可据此进行静态类型检查当客户端满足前置条件的时候，结果必须满足后置条件；当前置条件不满足的时候，方法内部可以做任何事情，但作为开发者，应该尽量让程序做到failfast。 3、Spec的评判标准：spec变强的要求是更宽松的前置条件+更严格的后置条件，在这种情况下，就可以用变强了的spec去替换原来的spec。越强的规约，意味着implementor的自由度和责任越重，而client的责任越轻。 用椭圆表示spec的强度，大椭圆表示更弱的spec，小椭圆表示更强的spec，椭圆的大小表示的是开发者的自由度，小椭圆有更强的后置和更弱的前置，因此所包含的结果的点就少，所以就小。 
第224篇文章[0]
HIT软件构造笔记四 HIT软件构造笔记四AbstractDataType(ADT)1.ADT的操作：Creatorscreatenewobjectsofthetype.构造器Producerscreatenewobjectsfromoldobjectsofthetype.生产器Observerstakeobjectsoftheabstracttypeandreturnobjectsofadifferenttype.观察器Mutatorschangeobjects.变值器，改变对象属性的方法 2.ADT的设计法则法则1：操作要简洁，一致。对于复杂的操作，应该拆分成多个简单操作的叠加，以此提高内聚性。 法则2：操作要全面(即需要的功能要可以实现)，且为用户提供方便的操作。 法则3：要不是针对抽象，要不是针对具体，不要两者混合。因此面向具体应用的类型不应该有通用方法，面向通用的类型也不该有具体方法。3.ADT的测试总的来说，对构造器、生产器、变值器的测试要用观察器检查；对观察器的测试要用其他三类方法来产生或构造对象。但这样的风险是，可能会产生互相依赖的现象，导致无法找到真正的错误原因。 解决方案：新创建一些方法来解除这些耦合，或者是把一部分私有方法改为公有方法，测试完后再换回私有。或者如果对于小型程序，只要测试结果都是正确的，也就可以解决问题。 4.不变量与抽象函数RepInvariant(RI)andAbstractionFunction(AF)Invariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件 两个空间R和A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。 AbstractionFunction：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。 RepInvariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。5.AF，RI和表示泄露安全说明的文档化这些都是写在代码的注释中，而非规约中。要给出理由，证明代码并未对外泄露其内部表示，比如字段全部为private，还有对可变字段的处理等等。 可用表示不变量来代替一些前置条件。 
第225篇文章[0]
HIT软件构造笔记六 HIT软件构造笔记六一.可复用性的度量、形态与外部表现1.可复用性的评估评估的方面：复用的频繁性、复用的代价(适配)一个有高可复用性的代码应该有如下特点：小、简单；与标准兼容；灵活可变；可扩展；泛型、参数化；模块化；变化的局部性；稳定；丰富的文档和帮助。2、复用的层面两种复用的方式：白盒复用和黑盒复用。黑盒复用就类似于调用API接口，或者方法等等；白盒复用是直接得到想要复用的源代码(或其他内容)等等，然后自己根据需要进行修改。 根据复用内容的结构从小到大，分为如下四种复用。 (1).源代码级别的复用:这个是最底层的复用，就是简单的复制粘贴修改。 (2).模块级复用:以class作为最基本的单元，复用的方式有继承和委托，其中委托的耦合度明显低于继承。 (3).类库级重用:相当于把一系列的class进行了打包，类似于第三方库的调用。 (4).框架级复用:在框架的基础上，填充自己的代码，形成完整系统。(其实就类似于一些实验中，给出了很多代码，要求我们填入一些自己的代码) 二．面向复用的软件构造技术1、LSP与泛型中的运用Liskov替换原则，从实际设计的角度来说，这个原则其实就是对子类型的约束：要求子类型对象完全可以当作父类型的对象来使用，其中就包括了规约的前置条件不能强化，后置条件不能弱化，要保持不变量等等。 下面介绍协变与异变的概念。 协变：子类对父类方法的覆写中，异常、返回值的类型是父类方法中返回值的类型的子类型，就称之为协变。 逆变：顾名思义，与协变恰恰相反。 因此为了复合Liskov替换原则，我们要求如果有变化的话，那异常，返回值必须是协变，参数必须是异变(当然，在java语言中参数的异变或协变导致方法不再是覆写，而是重载)。 java中的泛型是类型不变的，如下图所示，是十分经典的例子。如果想进行协变或逆变，则需要使用通配符，例如List<?extendsNumber>是List<Number>的子类型，但是不论如何都要确保一个List中的元素都是一种类型的(尽管多种元素都可以放入)。 2、委托与组合委派/委托：一个对象请求另一个对象的功能。 四种委派方式：①Dependency：依赖关系，临时性的delegation②Association：关联关系，永久性的delegation。③Composition:更强的association，但难以变化。④Aggregation:更弱的association，可动态变化。 组合：利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。 3、框架framework黑盒框架：通过实现特定接口进行框架扩展，采用的是delegation机制达到这种目的，通常采用的设计模式是策略模式(Strategy)和观察者模式(Observer)白盒框架：通过继承和重写实现功能的扩展，通常的设计模式是模板模式(TemplateMethod)。 
第226篇文章[0]
HIT软件构造lab1心得 1实验目标概述本次实验通过求解三个问题，训练基本Java编程技能，能够利用JavaOO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。基本的JavaOO编程基于EclipseIDE进行Java编程基于JUnit的测试基于Git的代码配置管理2实验环境配置安装Eclipse、JDK和Git 1、在配置Eclipse时，通过Window–Preferences–Java–InstalledJREs–添加已安装好的jdk的路径，配置jdk 2、学习了一些Git指令，如3.2Problrm2中初始化一个本地仓库，并将Lab1push到本地仓库中。3、学习了Junit测试project，在要使用Junit的project名上，右键–properties–javabuildpath–libraries–AddExternalJARs–点击Junit包。在3.2和3.3中书写并使用Junit进行测试。 3实验过程请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。为了条理清晰，可根据需要在各节增加三级标题。3.1MagicSquares该任务有两个要求：1、实现从txt文本中读取数据并保存，判断其是否为魔方阵2、创建一个阶数为n，且n为奇数的魔方阵，并根据1的代码判断这个魔方阵是否满足定义。在给出的代码中添加注释，并将创建出的魔方阵保存到6.txt文本中，当程序异常时,“优雅的”退出 函数输出false结束，并非非法退出。3.1.1isLegalMagicSquare()1、该函数：booleanisLegalMagicSquare(StringfileName)接受一个文件名，并且返回一个布尔结果（True/False),通过文件名+文件相对路径，函数读取文本中的数据，保存在一个二维数组中，进行判断该文本中的数据是否为魔方阵。2、在函数：voidmain(String[]args)throwsIOException中定义fileName并传输给isLegalMagicSquare，通过“src/P1/”+fileName找到文本文件。3、首先将数据按行存储在一个可动态修改的数组中，并且通过“\t”分隔符将数据存入一个二维数组中。4、对存入的数据进行判断：（1）判断文本中的数据是否合理：①判断文本中数据是否重复；②判断文本中数据是否均大于0；③判断数据中是否含有小数；④判断是否有文按“\t”分割存储的数据；（2）判断数据是否满足每行、列和两条对角线之和均相等。3.1.2generateMagicSquare()函数注释： 第0行中间，放置1。向当前位置的右上方放置下一个数；若下一个位置超出数组下标范围，则将魔方阵沿行、列方向看成环形，下标再从0开始计数若当前放置数是n的倍数，表示一条对角线已满，则下一个位置是本列的下一行采用二维数组存放幻方阵，元素下标i，j沿行、列方向看成环形变化规律如下：i=（i-1+n）%n；//向上一行j=（j+1）%n；//向右一列1、在调用函数generateMagicSquare()前，先对输入的n值进行判断，将大于0且是奇数的n传输到函数中。2、首先构造出n*n的魔方阵3、将魔方阵写入6.txt中4、输出生成的魔方阵5、调用函数IsLegalMagicSquare()判断6.txt中的数据是否是魔方阵6、结果 关于异常产生的分析: 数组越界,原因是在生成函数中,i<=square,计算机面对非整数时常用的方法是向下取整,输入奇数时col=n/2的值会向下取整,而square=n*n,所以此时i即使=square,数组也不会越界,而如果输入为偶数时,当i=square时就会发生越界,原因是在下标为n的数组中放入了大于n个的数据 此时数组下标为负值,输入的n为负值循环时数组下标为负，所以产生异常。3.2TurtleGraphics获取turtle包，熟悉TurtleGragpics的各种函数接口，调用已有的函数，实现java语言的绘图功能，并用java给出的.Math库里的函数实现一些简单的计算功能。3.2.1Problem1:Cloneandimport3.2.1.1从GitHub获取该任务的代码 https://github.com/rainywang/Spring2021_HITCS_SC_Lab1/tree/master/P2获取代码。将turtle包和rules包存入本地文件夹中，在Eclipse中，File–import–General–Filesystem–Browse…–找到本地文件夹并将turtle包和rules包复制到eclipse-workspace/TurtleGragphics.java/src/中，完成将实验需要的库导入。3.2.1.2在本地创建Git仓库：右键ProjectTurtleGragphics.java–Team–ShareProject…–Git–next–Finish3.2.1.3使用git管理本地开发。右键ProjectTurtleGragphics.java–Team->commit->StagedChanges->CommitMessage->Commit(推到本地仓库)3.2.2Problem3:TurtlegraphicsanddrawSquare3.2.2.1提供两个函数forward(units)：在当前方向上按单位像素移动turtlre，其中单位是一个整数。按照最初的标志惯例，turtle从朝上开始。turn(degrees):更改当前朝向，向右顺时针旋转，其中度数是double型。3.2.2.2调用forward()、turn()函数，画正方形，需要顺时针旋转90°前进sideLength,循环4次 下图为边长sideLength为100的正方形 3.2.3Problem5:Drawingpolygons3.2.3.1已知正多边形边数sides，求内角的度数由数学公式推导得内角度数=(double)((sides-2)*180.0/sides) 运行TurtleSoupTest中的Junit测试calculateRegularPolygonAngle()：右键TurtleSoupTest.java–Runas–1JUnitTest 3.2.3.2drawRegularPolygon(Turtle,int,int)，已知正多边形的内角、边数、边长，画出这个正多边形（转动的角度=180°-内角） Main函数，在main中输入得到正多边形的边数和边长 3.2.3.3示例边长为50的正六边形 边长为60的正八边形 3.2.4Problem6:CalculatingBearings3.2.4.1calculateBearingToPoint(double,int,int,int,int)计算turtle从当前位置和朝向到终点顺时针需要转过的角首先计算过两点的线段与x轴正方向形成的夹角，这里使用了Main.atan(x,y)函数，在与currentBearing相减，此时要注意：1、判断起点和终点是否重合2、夹角和turtle转过的角度范围都是[0.0,360.0）3、turtle朝向是上，而x轴正方向是向右，turtle是顺时针旋转（角度由小到大），坐标轴是逆时针旋转（角度由小到大）。所以currentBearing要减去90再取相反数。即currentBearing=90-currentBearing。 Junit测试 3.2.4.2publicstaticListcalculateBearings(ListxCoords,ListyCoords)该函数使用List存放每次调用calculateBearingToPoint返回的值，依次对相邻节点调用calculateBearingToPoint，在下一次循环，这一次的终点会被覆盖为下一次的起点，假设初始的起点为（0，0），总共由n个点，则有n-1次调用，在for循环中i=1，所以共循环n-2次。 Junit测试 3.2.5Problem7:ConvexHulls算法：边界漫游法时间复杂度：T（n）=O（n^2）1、首先遍历所有的点，找到最左下角的点2、以找到的点为基点，y轴正向为目前偏移角，开始依次找顺势针转角最小的点，记录这个点并将它加入到凸包集合中，以这次的偏向角累加上之前的角度度作为下一次的目前偏向角。3、循环直到再次遇到最左下角为止退出 Junit测试 3.2.6Problem8:Personalart 3.2.7Submitting如何通过Git提交当前版本到GitHub上你的Lab1仓库。 3.3SocialNetwork熟悉和掌握java中的数据结构类型，本项目要求我们掌握图的遍历，求两点之间的最短路径。利用图来实现人与人之间的关系，并能任意计算出人与人之间的情况（有无联系），基于FriendshipGraph类和Person类3.3.1设计/实现FriendshipGraph类FriendshipGraph类中包含图中所有点，每个点代表了一个Person，包含Person之间的边，并且可以计算两点之间的距离1、addVertex（）对Person名字进行判重：用哈希集合记录下所有Person的名字，当有新的Person加入时则判断是否已经在集合中。 2、addEdge（）将两个Person之间进行联系，在图中，两个点之间的有向边表示两个Person之间有联系，而联系是双向的，所以在计算边数时需要加两个方向的边。 3、getDistance（），计算任意两个Person之间的距离，若没有任何联系则输出-1。使用BFS算法。 3.3.2设计/实现Person类给出将每个人对应到一个Person上，并保存名字，调用每个Person姓名和朋友列表3.3.3设计/实现客户端代码main()由Lab1手册得： 结果为： 3.3.4设计/实现测试用例3.3.4.1addVertexTest()函数调用addVertex（）函数，添加一个人，并判断Person中最后一个是不是这个人 3.3.4.23.3.4.2addEdgeTest()调用addEdge（）函数，给两个人添加联系，并判断xw中的朋友最后一个人是不是wy 3.3.4.3getDistanceTest()调用getDistance（）函数，增加了a,b,c三人，并添加关系，判断与我们添加的关系是否一致 Junit测试： 4实验进度记录请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。日期时间段任务实际完成情况2021-05-1113:30-15:30编写3.1.1isLegalMagicSquare()按计划完成2021-05-1216：00-20：00编写generateMagicSquare()，完成3.1延期1小时完成2021-05-1613：00-20：003.2Problem1-Problem6按计划完成2021-05-1813:30-17:303.2Problem7按计划完成2021-05-1916：00-20：003.2完成按计划完成2021-05-2016：00-22：003.33.3.1FriendshipGraph类按计划完成2021-05-2118：00-23：003.3.2设计/实现Person类按计划完成2021-05-228：00-15：303.3完成延期1小时完成2021-05-238：00-14：00完成Lab1实验报告按计划完成5实验过程中遇到的困难与解决途径遇到的困难解决途径 Junit测试在3.2中test开始处是规定好的文件格式，添加Junit4后即可测试，在3.3中自己写测试的时候没有注意格式导致不成功，在与3.2中对比后，成功写出了可以进行junit测试的test.java文件凸包问题难以解决通过查询资料得到许多解决凸包问题的算法 6实验过程中收获的经验、教训、感想6.1实验过程中收获的经验和教训6.2针对以下方面的感受(1)Java编程语言是否对你的口味？第一次接触java，对其中的许多函数还不了解，只能从头开始学习。使用c语言完成的一些非常复杂的数据结构在java库中已经存在，对使用非常方便，这次实验让我受益匪浅。(2)关于EclipseIDE；初次使用Eclipse，许多操作并不了解，而网络上对它的细致的、系统的描述也比较少，只能通过一点点查询来了解java文件运行出错时可能的原因。让我比较印象深刻的是，eclipse对可能为空的字符串非常严格，只有在判断其不为空时，才能继续运行。(3)关于Git和GitHub；Git之前从未接触过,它可以在本地构建仓库更新版本，对Github也是知之甚少,这次实验我也只是学会创建了一个账号。(4)关于CMU和MIT的作业；全英文让我理解起来比较困难，只能反复的读题去理解题意(5)关于本实验的工作量、难度、deadline；对于初次接触java语言的我来说，有些吃力，deadline比较合理，因为平时周末基本没有课，没有实验的话可能也不会起早。(6)关于初接触“软件构造”课程；之前没有系统的了解过这门课程，但经过这几周的学习，让我对它愈发感兴趣起来。 
第227篇文章[0]
HIT软件构造笔记二 HIT软件构造笔记二1.1.1SoftwareLifecycleandConfigurationManagement1、SoftwareDevelopmentLifecycle软件开发生命周期(SDLC)：从无到有，从有到好静态测试：肉眼检查。动态测试：用测试用例进行实际测试。2、传统软件过程模型：基本类型有线性过程(Linear)和迭代过程(Iterative) 目前存在的模型有瀑布过程(waterfall)，增量过程(incremental)，V字模型(V-model)，原型过程(prototyping)，螺旋模型(spiral)。3、敏捷开发：Agile=增量+迭代通过快速迭代和小规模的持续改进，以快速适应变化，每次迭代处理一个小规模增量4、极限编程：XP 1.1.2软件配置管理(SCM)和版本控制系统(VCS)软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被称为软件配置项(SCI)。 当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。 为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。 VCS分为三种：1、本地版本控制系统（无法协作）存储在本地2、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）3、存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。1.1.3Git创建：gitinit 暂存：gitadd 提交：gitcommit-m“commitmessage” 链接：gitremoteaddorigin 推送：gitpush-uoriginmaster 创建分支：gitcheckout-b 切换分支：gitcheckout 合并分支：gitmerge 删除分支：gitbranch-d git中的四个区域：workspace、stagingarea、Localrepository、Remoterepository git的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。 git单个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。 传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。 关于分支的合并：对于合并操作来说，如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的指针移到做过更改分支的指针的位置。而如果两个分支都做了更改，那么就找到更改的共同的祖先节点，以祖先节点为开始，将两个分支所有做出的更改都放在一起，在工作分支上形成一个新的节点删除分支时，只是删除了分支指针，并没有删除在该分支上的commit。 2.1Generalprocessofsoftwareconstruction 通常软件构造过程(1)Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。 (2)Codereview、Staticcodeanalysis：可以使用工具来发现bug，如CheckStyle,SpotBugs。 (3)Testing：测试，单元测试、集成测试、系统测试… (4)Debugging：调试 (5)Dynamiccodeanalysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分 (6)Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化 (7)Build：chapter22.狭义的软件构造过程(Build)这是一个借助于工具，将软件构造过程中大的各阶段的活动自动化的过程，尽可能地脱离人工，以提高构造效率。 常用的工具：Jenkins、Make、Ant、Maven、Gradle、EclipseIDE 利用工具完成项目的自动化构建、测试、打包release等功能，完成buildtime–>runtime。 
第228篇文章[0]
HIT软件构造lab2实验心得 HIT软件构造lab2实验心得 1实验目标概述本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说：针对给定的应用问题，从问题描述中识别所需的ADT；设计ADT规约（pre-condition、post-condition）并评估规约的质量；根据ADT的规约设计测试用例；ADT的泛型化；根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（repinvariant）、抽象过程（abstractionfunction）使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（repexposure）；测试ADT的实现并评估测试的覆盖度；使用ADT及其实现，为应用问题开发程序；测试代码中，能够写出testingstrategy并据此设计测试用例。2实验环境配置根据实验手册中的网址，在eclipse中：help–EclipseMarketplace–search–EclEmmaJavaCodeCoverage–install安装成功 URL地址：https://github.com/ComputerScienceHIT/HIT-Lab2-11902020133实验过程请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。3.1PoeticWalksMIT指导页面链接：http://web.mit.edu/6.031/www/sp17/psets/ps2/该问题已经提供了ADT大体框架，graph的接口，要求我们建立一个边图类ConcreteEdgesGraph、一个点图类ConcreteVerticesGraph实现graph接口，实现抽象数据型，完成poet的工作。Graph接口要求实现add（添加新节点），set（添加新边），remove（移除节点），vertices（获得所有的节点集合），sources（target）获得以target为目标节点的边的起始节点，targes(source)获得以source为起始节点的边的目标节点。Poet：假设存在一条由a到b的有向边，构造有向图，再给定一句子，如果句子中两个相邻单词在有向图中有一个中间单词，则将该单词插入到a与b中间，若存在多个中间单词，则插入权重最大的那个3.1.1GetthecodeandprepareGitrepository如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。网址：https://github.com/rainywang/Spring2020_HITCS_SC_Lab2/tree/master/P1 gitbash直接执行gitclonehttps://github.com/rainywang/Spring2020_HITCS_SC_Lab2.git下载工程文件 gitclonehttps://github.com/ComputerScienceHIT/Lab2-1190202013.git本地仓库建好 3.1.2Problem1:TestGraph以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。针对Graph设计测试策略，编写测试用例主要利用等价类划分的思想进行测试。过程：用String类为Graph编写测试用例。共需编写六个函数的测试用例：add,set,remove,vertices,sources,targets。add,set,remove属于mutator；vertices,sources,targets属于observer。如下所示，为所有方法的测试策略 将Graph中的empty()方法修改为： 并对GraphStaticTest进行JUnit测试，如下：用String类为Graph编写测试用例。共需编写六个函数的测试用例：add,set,remove,vertices,sources,targets。add,set,remove属于mutator；vertices,sources,targets属于observer在coverage中查看覆盖率如下 3.1.3Problem2:ImplementGraph分别实现两个实现类ConcreteEgesGraph和ConcreteVerticesGraph，需标注创建的每一个类的AF和RI，如何防止表示泄露。使用函数checkRep来检验是否符合RI，重写toString函数以便输出该类信息。3.1.3.1ImplementConcreteEdgesGraph3.1.3.1.1实现Edge:1、EDGE中的字段包括边的起始节点、目标节点和边权值，定义为私有类型变量，信息对外界隐藏，使用final是其值不可变，防止外部对内部引用使其泄露。 2、实现Edge需要实现的方法：Fileds作用privatefinalLsource起始节点privatefinalLtarget目标节点privatefinalintweight边权值 Method作用Edge初始化构造方法，初始化边的起始节点和目标节点和边权值checkRep()检查表示不变性，两点不为null且权值非负getsource()返回有向边起始节点gettarget()返回有向边目标节点getweight()返回边权值@OverridetoString()使用@Override注释toString以确保正确覆盖Object方法的toString方法3、AF、RI和Safetyfromrepexposure 4、Edge测试策略： 3.1.3.1.2实现ConcreteEdgesGraph类：1、ConcreteEdgesGraph字段中包括顶点set表和边list表，定义私有类型的表如下图所示： 2、实现ConcreteEdgesGraph需要实现的方法： Method作用privatevoidcheckRep()检查表示不变性，edges长度是大于0的实数，有起始的节点publicbooleanadd(Lvertex)调用vertices.add，其返回结果为boolean且满足spec定义。publicintset(Lsource,Ltarget,intweight)前置条件要求weight>=0，如果weight<0，输出提示信息。在weight>=0的条件下，对图的边表进行遍历，若存在顶点为source，终点为target的边，保存这条边原本的权值，否则设为0。如果weight>0，则将这条边及顶点加入或者修改原有边的权值；如果weight=0，删除这条边。返回原本的权值。publicbooleanremove(Lvertex)从vertices中删去，传入的参数vertex点，遍历edges，寻找是否有边的起点或者是终点是该vertex，删去。注意在使用迭代器遍历时要使用iterator.remove方法保证安全。publicSetvertices()返回vertices集合publicMap<L,Integer>sources(Ltarget)根据传入的target参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。publicMap<L,Integer>targets(Lsource)根据传入的source参数寻找以source为起点的边。实现同上publicStringtoString()将整个图中所有点的指向转化为一条字符串输出 3、AF,RI和Safetyfromrepexposure 4、测试策略：继承Graph的测试策略，并增加toString的测试 测试结果如下： 检查覆盖率： 3.1.3.2ImplementConcreteVerticesGraph3.1.3.2.1实现Vertex：1、字段中应当包括点的名字，点的源点表Map，点的终点表Map，定义私有类型的表Filed作用privateLname节点名字privateMap<L,Integer>sources所有以name为目标节点的边，<起始节点name,边的权重>privateMap<L,Integer>targets所有以name为起始节点的边，<目标节点name,边的权重>2、在Vertex需要实现的方法: Interface作用privatevoidcheckRep()检查表示不变性，每个边的权值应该大于0publicLgetname)返回该节点的namepublicMap<L,Integer>getsources()根据传入的targets参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。publicMap<L,Integer>gettargets()根据传入的sources参数寻找以targe为终点的边。返回一个键值对为（点，权重）的map。publicintaddsource(Lnewsource,intweight)加入一条以source为起点，当前顶点为终点的边，即将source,weight加入sourcespublicintaddtarget(Lnewtarget,intweight)加入一条以当前点为起点，当前target为终点的边，即将target,weight加入targetspublicintremovesource(Lnewsource)在源点表中删除某起始点，并返回旧的边长publicintremovetarget(Lnewtarget)在终点表中删除某终点，并返回旧的边长publicStringtoString()得到一个点的字符串表示3、AF,RI和Safetyfromrepexposure： 4、测试策略： 3.1.3.2.2实现ConcreteVerticeGraph:1、ConcreteVerticesGraph的字段为Vertex构成的List，定义私有类型的表： 2、在ConcreteVerticesGraph需要实现的方法：Method实现思路privatevoidcheckRep()检查表示不变性，vertices中没有重复点publicbooleanadd(Lvertex)检查输入满足vertex!=null，添加一个顶点进入点表中publicintset(Lsource,Ltarget,intweight)输入source，target，weight，分别为边的起点、终点和权值。若权值为负，返回-1。若权值为正且新边已经存在，则除去原边并添加新边。若权值为正且新边不存在，则直接添加新边。若权值为0且新边已经存在，则出去原边。只要改变了原边权值，都返回原边权值，没有权值则返回0publicbooleanremove(Lvertex)除去某个点及与它相邻的所有边。只需要遍历vertices，寻找是否有与待删除点相同的名字的点直接删去即可，如果名字不相同，则在该点的源点表和终点表中寻找删去即可，使用迭代器实现。publicSetvertices返回所有的点集publicMap<L,Integer>sources(Ltarget)输入一个终点，返回与它相连的所有边和起点构成的MappublicMap<L,Integer>targets(Lsource)输入一个起点，返回与它相连的所有边和终点构成为的MappublicStringtoString()将整个图中所有点的指向转化为一条字符串输出3、AF,RI和Safetyfromrepexposure如下图： 4、测试策略：继承Graph的测试策略并增加toString的测试 测试结果： 检查覆盖率： 3.1.4Problem3:ImplementgenericGraph：3.1.4.1Maketheimplementationsgeneric将所有String改为L，并且Edge需改为Edge，Vertex需改为Vertex。3.1.4.2ImplementGraph.empty()选择ConcreteEdgesGraph作为Graph.empty()的实现类，返回newConcreteEdgesGraph 测试策略： 测试结果： 覆盖率： 3.1.5Problem4:Poeticwalks任务要求我们实现一个类，利用之前实现的图结构，能够将语料库转化为该种图结构，并且在图中搜索，完成对输入的诗句的句子进行扩充。3.1.5.1TestGraphPoet测试策略：GraphPoet()考虑到了输入文件是否存在、文件中含有多个连续空格、大小写、换行符、空行、标点符号、重复的词以及连续的词或词组等特殊情况，依此设计测试用例；poem()图中没有的词、相邻的两个词、两个词之间的路径经过多个词的情况不作改变；存在两个词在图中有一条只经过一个桥接词的路径；存在两个词在图中有多条只经过一个桥接词的路径。 具体实现读入一系列满足要求的文件： 测试结果为： 测试覆盖率为： 3.1.5.2ImplementGraphPoet1、构造器GraphPoet(Filecorpus)一行一行读入文件，以空格为界将词分开存入列表，以每两个连续的词作为顶点，这两个顶点之间有边，记录两个词连续出现的次数作为边权。观察器poem(Stringinput)输入需要进行扩充的字符串，声明声明一个StringBuilder保存，每次读取一个词，当前词作为source，下一个词作为target，然后在garph中寻找source的终点表中是否有与target的源点表中相同的元素，并且找到权值最大的和的点加入source和target之间，返回扩充后的字符串。Checkrep检查是否符合RI：图中每个词都不是空，不含有空格和换行符，都是小写，每个词都有边与之相连。toString调用ConcreteEdgesGraph中的toString方法，将整个图中所有点的指向转化为一条字符串输出2、AF,RI和Safetyfromrepexposure如下图： 3.1.5.3Graphpoetryslam运行main函数如下输出： 3.1.6Beforeyou’redone如何通过Git提交当前版本到GitHub上你的Lab2仓库。 在这里给出你的项目的目录结构树状示意图。 3.2Re-implementtheSocialNetworkinLab1这次实验要求我们基于PoeticWalks中定义的Graph及其两种实现（本人使用的是ConcreteVerticesGraph），实现Lab1中SocialNetWorek中的各种功能，并且尽可能复用ConcreteVerticesGraph中已经实现的方法，然后运行提供的main()和执行Lab1中的Junit测试用例，使之正常运行。3.2.1FriendshipGraph类(1).FriendshipGraph的字段为Person构成的ConcreteEdgesGraph，定义私有类型的表如下图所示： (2).在FriendshipGraph需要实现的方法如下图所示：FriendshipGraph构造方法addVertex在图中增加新Person，只需要调用ConcreteEdgesGraph中的add即可： addEdge为某个人增加朋友,a为这个人，b为增加的朋友,直接调用ConcreteEdgesGraph中的set即可： getallprople直接返回即可： getDistance遍历顶点以及其sources，根据广度优先算法，构建队列。将起点先加入队列，然后每次从队头弹出一个点，将其sources中还未在队列中的顶点压入队尾，直到遍历到终点。在这个过程中记录起点距每个点的距离即可。若直到队空也没有遍历到终点，则返回-1。00main复制Lab1的即可(3).AF,RI和Safetyfromrepexposure如下图： 3.2.2Person类(1).FriendshipGraph的字段为Person构成的ConcreteEdgesGraph，定义私有类型的表如下图所示： (2).在FriendshipGraph需要实现的方法如下图所示：Person没有重复名字则加入，构造方法getmyname返回本人名字，直接返回即可(3).AF,RI和Safetyfromrepexposure如下图： 3.2.3客户端main()复制Lab13.3中的main运行后如下： 3.2.4测试用例测试策略：与Lab1的测试策略相同： 测试结果： 检查覆盖率：(需要提前注释main()函数)： 3.2.4提交至Git仓库如何通过Git提交当前版本到GitHub上你的Lab2仓库。与提交P1相似 在这里给出你的项目的目录结构树状示意图。 4实验进度记录请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。日期时间段计划任务实际完成情况5.2513:00-22:30完成P1边图类完成5.2615：30-23：30完成P1点图类完成5.2815：30-20：00GraphPoet和poem未按计划完成5.2913：00-16：30Poem完成6.315：30-20：00修改完善测试用例完成6.414：30-19：30FriendshipGraph完成6.1015：30-16：00完善测试用例完成6.1113：00-16：00完善报告完成5实验过程中遇到的困难与解决途径遇到的难点解决途径换成泛型后很多警告 按照提示增加<> Git二次提交不太会使用git二次提交文件，所以重新增加master重新push6实验过程中收获的经验、教训、感想6.1实验过程中收获的经验和教训在自行设计多种类来实现功能的情况下，自己设计的很多类之间有很多重复和矛盾的部分，很多关系弄不清楚6.2针对以下方面的感受(1)面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？答：面向ADT需要考虑底层实现，而面向应用场景无需了解ADT如何实现各种功能，直接调用即可。 (2)使用泛型和不使用泛型的编程，对你来说有何差异？答：使用泛型应用范围更广，但设计的时候需要考虑不能应用某一类型内部的方法；不使用泛型应用范围窄，但设计时可以应用某一特定类型包装好的方法。 (3)在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？答：能够保证代码的正确性，及时修改。不适应。 (4)P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？答：可以提高代码的利用率，减少重复。 (5)P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？答：适应方式就是在应用场景时只考虑应用场景，“忘记”ADT内部的具体实现方式。自主实现感觉需要自己考虑的东西变多了。 (6)为ADT撰写specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？答：保证程序的安全性和健壮性。可能很难坚持。 (7)关于本实验的工作量、难度、deadline。答：感觉工作量还挺多的。(8)《软件构造》课程进展到目前，你对该课程有何体会和建议？答：实验和课堂上的理论结合非常紧密。 
第229篇文章[0]
HIT软件构造lab3心得 1实验目标概述本次实验覆盖课程第2、3章的内容，目标是编写具有可复用性和可维护性的软件，主要使用以下软件构造技术：子类型、泛型、多态、重写、重载继承、代理、组合语法驱动的编程、正则表达式API设计、API复用本次实验给定了三个具体应用（值班表管理、操作系统进程调度管理、大学课表管理），学生不是直接针对每个应用分别编程实现，而是通过ADT和泛型等抽象技术，开发一套可复用的ADT及其实现，充分考虑这些应用之间的相似性和差异性，使ADT有更大程度的复用（可复用性）和更容易面向各种变化（可维护性）。2实验环境配置Eclipse与git 在这里给出你的GitHubLab3仓库的URL地址（HIT-Lab3-学号）。https://github.com/ComputerScienceHIT/HIT-Lab3-11902020133实验过程请仔细对照实验手册，针对每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。3.1待开发的三个应用场景3.1.1值班表管理要求：1、每天只有一个员工值班；2、不能出现某天无人值班的情况；3、任意两个员工值班时间不能重叠；4、记录员工值班日期、名字、职位、手机号码； 3.1.2操作系统进程调度管理要求：1、同一个进程可以在多个不同时间段内多次执行；2、多个进程执行时的时间段不可重叠；3、在特定时刻，时间轴上没有进程在执行，即“闲置”；4、操作系统对进程调度是随机的；3.1.3大学课表管理要求：1、课表中有多个课程排课；2、同一时间段可以有不同的课程（学生选课不同）3、同一课程每周可以出现一次，也可以安排多次；4、课表中允许有空白时间段（未安排任何课程）；5、同一课程由同一位老师在同一教室进行；6、一位老师可以承担课表中的多门课程；7、课表具有周期性（T=7days）； 三个应用的共性与差异：三个APP均与时间段有关，值班表要求一人只能对应一个时间段，进程与课表管理要求一个对象课可以对应多个时间段。在值班表和进程中，要求各个时间段不能重叠，而课表允许有重叠。在值班表中要求不能有空白的时间段，课表必须具有周期行等等。 3.2面向可复用性和可维护性的设计：IntervalSet该节是本实验的核心部分。3.2.1IntervalSet的共性操作1、IntervalSetempty()：创建一个空对象，返回创建的空对象；2、voidinsert(longstart,longend,Llabel)：插入新时间段，start,end分别表示开始时间和结束时间，label是时间段标签，当存在此标签或者时间段被占用时输出异常；3、Setlabels()：获得当前对象中标签集合4、booleanremove(Llabel)：从当前对象中移除某个标签label所关联的标签，若集合中没有找到指定标签则返回false，否则返回true，即成功移除；5、longstart(Llabel):返回标签label对应时间段的开始时间6、longend(Llabel)：返回标签label对应时间段的结束时间7、booleancheckLegal();检查当前程序的合法性8、voidclear():清空当前时间段集合中的所有时间段9、读取时间段集合链表LinkedList<Interval>readIntervalSet(); 3.2.2局部共性特征的设计方案采用报告3.4.2中的方案6使用decorator模式进行局部共性特征设计方案。定义一个装饰器抽象类Decorator继承自IntervalSet接口 下面设立多个子类分别继承自Decorator抽象类。三个局部共性特征为1、是否允许时间重叠2、是否允许时间段中有空隙3、是否允许时间循环呈周期变化可以看出这三个特征的区别在于插入方法和检查程序合法性两个方法上，因此在子类中分别对这两个函数进行重写即可 3.2.3面向各应用的IntervalSet子类型设计（个性化特征的设计方案）由于在值班表管理中要求n名员工的值班时间段必须相连，无空白时间段，所以DutyIntervalSet与之前设计的不允许时间冲突和不允许各个时间段中有空白时间段，和之前实现的子类功能高度重合，因此直接继承即可。noGapIntervalSet中增加了判断某个时间段中是否有循环或者空白时间段的方法booleancheckLegal()。该方法中将时间段集合链表LinkedList<Interval>中的时间段依次遍历，如果出现了当前遍历时间段开始时间大于上一个时间段的结束时间的情况，说明有空白，返回false，否则返回true。noOverlappingIntervalSet通过对insert函数进行重写，保证原集合内时间段之间不发生重叠。在每次加入新时间段时，判断新加入时间段与集合中原有所有时间段的位置关系。如果出现重合，则输出异常，否则可以加入原集合。 3.3面向可复用性和可维护性的设计：MultiIntervalSet3.3.1MultiIntervalSet的共性操作1、IntervalSetempty()：创建一个空对象，empty()或不带任何参数的构造函数，返回创建的空对象2、MultiIntervalSet(IntervalSetinitial)：创建一个非空对象，利用initial中包含的数据创建非空对象，返回创建的非空对象3、voidinsert(longstart,longend,Llabel):在当前对象中插入新的时间段和标签;4、Setlabels():获得当前对象中的标签集合：5、booleanremove(Llabel):从当前对象中移除某个标签所关联的所有时间段6、IntervalSetintervals(Llabel):从当前对象中获取与某个标签所关联的所有时间段：，返回结果表达为IntervalSet的形式，其中的时间段按开始时间从小到大的次序排列。7、getMap():返回当前的时间段集合8、booleancheckLegal():检查合法性9、清空当前的时间段集合3.3.2局部共性特征的设计方案针对multiIntervalSet同样面临着是否允许空隙，是否允许时间冲突，是否允许周期循环的三个问题，同样采用方案6的装饰器设计模式，重写multiIntervalSet的insert方法和checkLegal方法，设计出不同功能的子类。3.3.3面向各应用的MultiIntervalSet子类型设计（个性化特征的设计方案）面对进程调度的应用设计一个ProcessIntervalSet，这个个性化特征为可以有空隙，但是时间不允许重叠，因此这个类继承自上面实现的无周期，不重叠，可以有间隙的装饰子类，因为需要设计成可视化，所以在这个子类中增加两个show方法，可以查看当前所有的进程调度，也可以查看单独的进程被调度的情况。面对课程表安排的应用设计一个CourseIntervalSet类，由于插入课程时希望通过星期几和开始上课的时间进行插入，因此在这个子类中需要增加能够将周数和开始上课的时间对应成时间段的开始时间和结束时间的方法，同时，这个课程表也需要可视化读入，所以增加一个获得具体星期的课表的方法。3.4面向复用的设计：L所有的ADT都采用泛型L，L必须是immutable类型的变量。如针对每个应用设计的类Employee、Process、Course等3.5可复用API设计将方法写在单独的APIs.java中，采用委派方式3.5.1计算相似度针对multiIntervalSet的计算相似度的方法，可以计算两个时间段集合的相似度。两个时间段集合的相似度是通过相似时间/总时间计算的，而相似时间则要求时间段和标签完全一样的时候才叫有效的相似时间。维护两个IntervalSet，标签使用Integer类型，然后将multi的时间段集合转换成普通的时间段集合，这样将每个时间段按照开始时间的先后顺序插入其中。这样还可以顺便计算出来两个时间段集合的最长持续时间是多少。然后通过for循环，遍历两个时间段集合的每个时间段，统计有效时间，由此计算出相似度结果。首先分析相似度的计算：我们以实验指导的例子为例：首先我们可以得出对于第一个MultiIntervalSet中标签A，其对应的区域有两个地方[0,5)和[20，25)，而在第二个MultiIntervalSet中标签A，其对应的区域有一个为[20,35)，而由于不同标签的相似度，只存在于相同的标签对应的时间段，因此我们可以计算出相似度。Similarratio=15/35=0.42857。在介绍方法前，首先简述求相似度的辅助函数：1.publicstaticlonggetStartTimerShaft(MultiIntervalSets)获得MultiIntervalSet的最早的时间2.publicstaticlonggetEndTimeShaft(MultiIntervalSets)获得MultiIntervalSet的最晚的时间3.publicstaticdoubleintervalLength(Sets1)计算s1中的所有时间段的时间的长度4.publicstaticSetsimilarIntervals(IntervalSets1,IntervalSets2)求s1与s2的重合时间段，其中参数为由MultiIntervalSet的label对应的多个Interval构成的Interval，Integer为从小到大的顺序。3.5.2计算时间冲突比例时间冲突比例应为计算一个MultiIntervalSet类型中所有labels对应的时间段存在重叠的部分。首先将所有的label映射到Boolean类型，即可认为当前是否已经遍历过该标签。初始化时候，将label对应的Boolean都设置为false。在循环MultiIntervalSet中所有标签时，依次将每一个设置为true，表示遍历完成。通过双层循环实现对label的遍历，在遍历一个标签时，若发现另一个标签与其相同或已访问过，则跳过，否则通过调用simlarIntervals函数和intervals函数，检查label标签对应的时间段与待检查标签中是否有相同的部分，若有，则累加，即为冲突时间。总时间通过对每一个label对应时间段求和即可得。冲突事件/总时间即为时间冲突比例。3.5.3计算空闲时间比例首先通过3.5.1中叙述的getStartTimerShaft(MultiIntervalSET)函数，获得MultiIntervalSet的最早的时间点，再通过getEndTimerShaft(MultiIntervalSET)函数，即可获得MultiIntervalSet的最晚的时间点。此时即可计算总的时间。首先将开头时间和结束时间放入Set中，即可得到此时对应的Interval的集合，开始时候，只有一个Interval，代表从头到结尾。通过对MultiIntervalSet中的labels遍历，依次得到每个label对应的时间段。当得到每个时间段后，将Set中的包含当前label对应的时间段的时间段拆分成，不包括不包括label的时间段的部分，并将原Interval删除，将新拆分的Intervals放入Set中，最后调用intervalLength函数，即可计算Set中的时间间隔的总长度。通过空闲时间/总时间即可计算出空闲时间比例。3.6应用设计与开发利用上述设计和实现的ADT，实现手册里要求的各项功能。3.6.1排班管理系统针对排班管理系统，所需完成的功能为：Step1设定排班开始日期、结束日期，具体到年月日即可。Step2增加一组员工，包括他们各自的姓名、职务、手机号码，并可随时删除某些员工。如果某个员工已经被编排进排班表，那么他不能被删除，必须将其排班信息删掉之后才能删除该员工。员工信息一旦设定则无法修改。Step3可手工选择某个员工、某个时间段（以“日”为单位，最小1天，可以是多天），向排班表增加一条排班记录，该步骤可重复执行多次。在该过程中，用户可随时检查当前排班是否已满（即所有时间段都已被安排了特定员工值班）、若未满，则展示给用户哪些时间段未安排、未安排的时间段占总时间段的比例。Step4除了上一步骤中手工安排，也可采用自动编排的方法，随机生成排班表。Step5可视化展示任意时刻的排班表。可视化要直观明了，可自行设计。其中step4的自动编排方法秉持着平均的原则，计算出一共要安排多少天，然后用天数除以员工数量，再最后处理剩余的没有安排上的部分，从而完成自动的安排。如果在自动安排之前已经手动插入了一些安排，那么就清空列表后再进行自动编排3.6.2操作系统的进程调度管理系统针对操作系统的进程调度管理系统，所需完成的功能为：Step1增加一组进程，输入每个进程的ID、名称、最短执行时间、最长执行时间；进程一旦设定无法再修改其信息。Step2当前时刻（设定为0）启动模拟调度，随机选择某个尚未执行结束的进程在CPU上执行（执行过程中其他进程不能被执行），并在该进程最大时间之前的任意时刻停止执行，如果本次及其之前的累积执行时间已落到[最短执行时间，最长执行时间]的区间内，则该进程被设定为“执行结束”。重复上述过程，直到所有进程都达到“执行结束”状态。在每次选择时，也可“不执行任何进程”，并在后续随机选定的时间点再次进行进程选择。Step3上一步骤是“随机选择进程”的模拟策略，还可以实现“最短进程优先”的模拟策略：每次选择进程的时候，优先选择距离其最大执行时间差距最小的进程。Step4可视化展示当前时刻之前的进程调度结果，以及当前时刻正在执行的进程。可视化的形式要直观明了，可自行设计。添加一组进程后，可以启动系统模拟进程调度。进程调度有两种调度策略，一个是随机调度，一个是最短进程优先策略。在这里都采取随机数的方式进行随机调度，同时加入无进程的情况。在随机进程选择中采用平均随机，即每次从未完成的进程中选择一个，并执行随机数的时间，然后进行下一次随机选择进程，直到所有进程都达到执行时间为止。而最短进程优先策略则增加随机数的产生范围，多余的随机数都指向最短时间的进程，这样最短时间的进程就会被更容易调度。欢迎界面 输入1 功能为添加进程。 输入2 输入5 3.6.3课表管理系统针对课表管理系统，所需完成的功能为：Step1设定学期开始日期（年月日）和总周数（例如18）；Step2增加一组课程，每门课程的信息包括：课程ID、课程名称、教师名字、地点、周学时数（偶数）；Step3手工选择某个课程、上课时间（只能是8-10时、10-12时、13-15时、15-17时、19-21时），为其安排一次课，每次课的时间长度为2小时；可重复安排，直到达到周学时数目时该课程不能再安排；Step4上步骤过程中，随时可查看哪些课程没安排、当前每周的空闲时间比例、重复时间比例；Step5因为课程是周期性的，用户可查看本学期内任意一天的课表结果。每次课的时间长度为2小时，且只有固定的几个时间段可以上课，因此可以根据星期几和上课的开始时间确定唯一的上课时间，在此通过一个转换即可做到。将weekday*24再加上开始上课的时间，就能确定唯一的上课时间。简要分析，我们需要一个一个标签对应多个时间段的数据类型，因此选择MultiIntervalSet类型。CourseScheduleApp运行如下：课表目录 更新课表信息 添加课程 设置课程上课时间 查看未安排的课程 查看设置完成的课程 3.7基于语法的数据读入修改“排班管理”应用以扩展该功能。该模块主要采用正则表达式处理从文件中读入的字符串。根据提供的文件的格式确定正则表达式，然后通过正则表达式的语法获取每一行的信息。用每一个正则表达式去匹配每一行，如果匹配上了就获取相应的信息进行处理即可。 在匹配确认格式匹配后，将所读入的内容转化为值班表。具体运行结果如下：当读入test1.txt时，具体运行结果如下所示： 3.8应对面临的新变化3.8.1变化1代价并不大。只需将值班表中使用的没有空时间段改为允许有空隙，并修改查看排版信息的遍历时所用到的intervalset中的函数（start,end），变为multi-intervalset中的函数（intervals）即可。同时，由于一个员工可以占据多段时间，随机排班的功能也需要进行修改。新的排版方式是对每一天进行遍历，每一天都随机选择一个员工。3.8.2变化2代价很小。只需要再套一层NoOverlapIntervalSet的装饰器就足以应对变化。3.9Git仓库结构请在完成全部实验要求之后，利用Gitlog指令或Git图形化客户端或GitHub上项目仓库的Insight页面，给出你的仓库到目前为止的ObjectGraph，尤其是区分清楚change分支和master分支所指向的位置。 4实验进度记录请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。每次结束编程时，请向该表格中增加一行。不要事后胡乱填写。不要嫌烦，该表格可帮助你汇总你在每个任务上付出的时间和精力，发现自己不擅长的任务，后续有意识的弥补。日期时间段计划任务实际完成情况2021.06.2710:00-20:00完成IntervalSet接口和CommonIntervalSet实例按时完成2021.06.2813:00-15:00重构CommonIntervalSet代码按时完成2021.06.2816：00-19：00完成MultiIntervalSet接口和Common实例未完成2021.06.2821：00-23：00完成MultiIntervalSet接口和Common实例按时完成2021.06.299：00-13：00完成dutyIntervalSet设计和值班表app未完成2021.06.2915：00-19：00完成dutyIntervalSet设计和值班表app按时完成2021.06.307：00-13：00完成装饰类的书写按时完成2021.06.3015：00-23：00完成具体类的书写并实现进程调度按时完成2021.07.017：00-15：00完成课程表安排和APIs类按时完成2021.07.027：00-16：00完成应对变化及代价按时完成2021.07.037：00-18;00完成报告按时完成5实验过程中遇到的困难与解决途径遇到的难点解决途径 产生随机数不会网络搜索 如何对日期进行处理网络搜索，了解了Date等方法可以进行日期运算6实验过程中收获的经验、教训、感想6.1实验过程中收获的经验和教训对代码复用的体会更加深刻了6.2针对以下方面的感受(1)重新思考Lab2中的问题：面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？本实验设计的ADT在五个不同的应用场景下使用，你是否体会到复用的好处？ 复用在一定程度上增加了代码的难度，但另一方面复用大量的减少了代码量。复用更考察了抽象能力，将不同的场景的共同点抽象成抽象ADT。 (2)重新思考Lab2中的问题：为ADT撰写复杂的specification,invariants,RI,AF，时刻注意ADT是否有repexposure，这些工作的意义是什么？你是否愿意在以后的编程中坚持这么做？保证了正确性与安全性，并将一直坚持。 (3)之前你将别人提供的API用于自己的程序开发中，本次实验你尝试着开发给别人使用的API，是否能够体会到其中的难处和乐趣？开发API难处体会比较深刻，乐趣没有难处深刻。 (4)你之前在使用其他软件时，应该体会过输入各种命令向系统发出指令。本次实验你开发了一个解析器，使用语法和正则表达式去解析输入文件并据此构造对象。你对语法驱动编程有何感受？匹配过程更加实用。 (5)Lab1和Lab2的工作都不是从0开始，而是基于他人给出的设计方案和初始代码。本次实验是你完全从0开始进行ADT的设计并用OOP实现，经过三周之后，你感觉“设计ADT”的难度主要体现在哪些地方？你是如何克服的？抽象出相同的地方，勤于思考。 (6)“抽象”是计算机科学的核心概念之一，也是ADT和OOP的精髓所在。本实验的三个应用既不能完全抽象为同一个ADT，也不是完全个性化，如何利用“接口、抽象类、类”三层体系以及接口的组合、类的继承、委派、设计模式等技术完成最大程度的抽象和复用，你有什么经验教训？先写接口考虑好应用场景，并写测试，进而不断完善代码。 (7)关于本实验的工作量、难度、deadline。工作量过大、难度过大、deadline过紧。 (8)下周就要进行考试了，你对《软件构造》课程总体评价如何？对我编程起到了很大的作用，让我了解到如何编出更好的代码。 
第230篇文章[0]
HIT软件构造笔记一 软件构造复习笔记一1.1软件构造过程中的多维度视图1、多维度视图 (1)Build-time,moment,andcode-levelview关注的是源码的组织情况，可在词汇（源码）、语法（抽象语法树）、语义（类图）三个层面分别分析。 (2)Build-time,period,andcode-levelview关注的是代码的变化（Codechurn代码变化） (3)Build-time,moment,andcomponent-levelview关注的是包/库，而且是静态链接库 (4)Build-time,period,andcomponent-levelview关注代码的更迭，与(2)中不同的是，这个维度下更关注文件版本的变化，而不是具体语句的变化（2中关注的是哪一行代码被修改了） (5)Run-time,moment,andcode-levelview关注的是程序在某个时间点内存中的情况，如代码快照图(CodeSnapshot)、内存信息转储(Memorydump)。 (6)Run-time,periodandcode-levelview关注的是代码的执行情况，执行跟踪 (7)Run-time,moment,andcomponent-levelview关注的也是包/库，但却是在代码执行过程中的情况，如动态链接库 (8)Run-time,period,andcomponent-levelview关注的是系统的使用情况，使用日志查看2、视图之间的联系代码是一个从无到有的过程，也就空集->Code，而有了代码之后程序必定会随着代码行的增加而逐步完善，最后被封装，也就是Code->Component这个过程。当程序构建成功后需要运行，也就是Build-time->Run-time，最后我们还可能需要多次修改调整程序，或者记录程序版本变化，也就需要Moment->Period维度的转变。 1.2QualityObjectivesofSoftwareConstruction 软件系统的质量外部质量因素（1）正确性正确性是软件产品能够正确的执行任务的能力，是首要的质量目标。保证正确性的途径是有条件的。一个软件系统设计多个层面，所以不可能仅仅靠每个构件和属性的正确性来保证整体的正确性，各层之间是相互依赖的。 （2）健壮性健壮性是软件系统对异常情况做出适当反应的能力。健壮性补充了正确性。正确性解决了系统在其规范所涵盖的情况下的行为；健壮性描述了在该规范之外发生的事情。健壮性是确保如果出现此类情况，系统不会导致灾难性事件；它应生成适当的错误消息，干净地终止执行，或进入所谓的“优雅降级”模式。健壮性同异常情况相关，异常或非异常取决于程序的规格说明，异常情况是程序的规格说明中没有涉及的部分。判断是否异常是异常的标准，不取决于客观的正确标准，而取决于程序的规格说明。 （3）可扩展性可扩展性是指软件易于调整以适应变化的能力。可扩展性同规模密切相关，越大越难以扩展。软件是易变的，需要可扩展性。传统方法最初冻结需求，假设没有变化，因此难以适应变化两个提高可扩展性的原则：简单的体系结构总是比复杂的体系更容易适应变化。模块自治性越强，变化时对其余模块影响越小。 （4）重用性软件经常遇到相似的模式，利用共性，避免重复实现。 （5）兼容性兼容性是指软件元素易于与其他的组合。因为我们的软件并非运行在真空中，但难点在于不同的软件有不同的设定。所以，解决兼容性的关键是标准性，例如规定文件格式、数据结构、用户接口等。更通用的方法是通过协议来实现更通用的兼容性。 （6）效率效率是软件系统对硬件资源尽可能少的需求的能力，但前提是软件的正确性，并且需要与其他目标进行权衡。 （7）可移植性可移植性是指便于将软件产品转移到各种硬件和软件环境。 （8）易用性用户可以轻松掌握软件的使用，也包括安装、运行和监控的容易度。既方便初学者入门，也不影响熟练的用户直接使用。一个关键是结构要简洁，理解用户，换位思考，站在用户的角度设计软件。 （9）功能性增加功能的同时也要防止陷入“蠕变特性”，即程序设计中一种不适宜的趋势，即软件开发者增加越来越多的功能，企图跟上竞争，其结果是程序极为复杂、不灵活、占用过多的磁盘空间。过多的新功能容易带来一致性的缺失，影响易用性。在质量提升技术的帮助下，可以在整个项目中保持质量水平不变，而不仅仅是功能性。 （10）及时性及时性是指软件系统能够在用户需要时或者需要需要之前发布 内部质量因素圈复杂度：用来衡量一个模块判定结构的复杂程度。耦合度：设计中追求高内聚和低耦合。可读性、易理解性、清晰度、复杂度、体积内部质量因素通常用作外部质量因素的部分度量。 正确性是绝不能与其他质量因素折中的！！！ 
第231篇文章[0]
Java编程语言中类的继承 在软件构造实验3中，我们多次用到了继承的思想 继承是面向对象的开发过程中的一个非常重要的概念，通过继承，我们可以使用之前定义的成员方法和成员变量，经过简单的程序编码就可以在已有类的基础上增加新的功能。 Java程序设计语言通过继承机制，在现有类的基础上定义一个新的类，并在原有类的基础上添加新的方法或修改原有方法，从而提高编程效率、减少错误概率。 继承是通过关键字extends来声明的，其格式为： [修饰符]class类名extends父类名 如 publicclassbirdextendsanimal{ } bird类继承了animal类，即animal类是bird类的直接父类（或直接超类），bird是animal类的直接子类。 我们简单的编写animal类，使它作为bird类的父类 publicclassanimal{ publicbooleanlive; publicStringname; publicfinalbooleancanFly; publicanimal(booleancanFly) { this.canFly=canFly; } publicvoidgetName() { System.out.println(name); } } 我们用eclipse创建子类时，在指定包、类名的同时，还可以指定继承的超类（父类）和实现的接口。 我们可以在Superclass中输入或选择我们要继承的父类。 eclipse自动为我们生成了代码。 packageP1; publicclassbirdextendsanimal{ } 此时，eclipse向我们报错，因为我们在父类中写了一个构造方法，eclipse提醒我们为子类添加构造方法。 我们选择让eclipse自动添加构造方法，得到了如下代码。 packageP1; publicclassbirdextendsanimal{ publicbird(booleancanFly){ super(canFly); //TODOAuto-generatedconstructorstub } } 我们编写一个program来验证一下，子类bird是否继承了animal的成员方法与成员变量 packageP1; publicclassprogram{ publicstaticvoidmain(String[]args){ //TODOAuto-generatedmethodstub birdeagle=newbird(true); eagle.name="Eagle"; eagle.live=true; eagle.getName(); } } 运行结果如下 
第232篇文章[0]
自增与自减运算符 在软件构造实验3中，从文本中读取有效信息时，出现了读取到的信息错误的问题 读取信息时，前两个字符总是相等，后面读取到的字符串也依次发生了错误 摘取部分错误代码如下 publicstaticvoidmain(String[]args) { inti=0; Strings="Java"; Stringst=""; st=st+s.charAt(i); System.out.println(st); st=st+s.charAt(i++); System.out.println(st); st=st+s.charAt(i++); System.out.println(st); st=st+s.charAt(i++); System.out.println(st); } 错误结果。 首先观察到的错误就是前两个字符相等，这与我们希望的结果明显不同 第一个字符输出与第二个字符相等，很明显这里实际执行的操作应该是 st=st+s.charAt(0); st=st+s.charAt(0); 这时候才反应过来i++与++i的区别 i++：使用i的值之后，将i的值加1 ++i：将i的值加1之后，使用i的值 i--：使用i的值之后，将i的值减1 --i：将i的值减1之后，使用i的值 publicstaticvoidmain(String[]args) { inti=0; Strings="Java"; Stringst=""; st=st+s.charAt(i); System.out.println(st); st=st+s.charAt(++i); System.out.println(st); st=st+s.charAt(++i); System.out.println(st); st=st+s.charAt(++i); System.out.println(st); } 修改后的结果 自增与自减运算符在刚开始接触高级语言的时候就已经学习过了，但是在平时使用的过程中可能很少需要区分i++与++i的区别，因此可能稍加不注意就出现了bug。有时可能不容易检查 在写代码的时候注意甄别两者的区别，可以避免在后续过程中调试的麻烦 
第233篇文章[0]
用Java集合类实现图的广度优先算法 用Java集合类实现图的广度优先算法 第一次Java实验，就碰到了要求实现无向图两点间距离计算的题目。被迫拾起了数据结构的知识。 刚刚着手学习Java编程语言，加上之前数据结构的知识也都还给老师，就算还记得，也不知道怎样用Java实现图的结构与算法啊QAQ 没办法，最后硬着头皮，用Java集合类勉强写出来了。 过程可能要麻烦很多，我相信肯定也被很多人写过，不过我实在太懒了，也没有搜过相关文章。如果实现过程中有问题，还请大佬指出。 先给出题目条件吧。这里要存储的点是一个自定义的Person类，当然，你也可以使用任何的其他对象。 Map<Person,Set<Person>>graph=newHashMap<Person,Set<Person>>(); 我用一个HashMap对象graph来存储我的图。这里，Person是图中的每一个顶点，Set<Person>中存放的是每一个和Person相邻接的顶点。 添加顶点与添加边的方法比较简单，不具体写出来了，简述一下吧。 booleanaddVertex(Personname) voidaddEdge(Personname1,Personname2) 函数addVertex(Personname)将Person类name加入graph中，并为name新建一个集合，加入name在graph中映射到的值里。 函数addEdge(Personname1,Personname2)则分别将name1加入name2映射到的集合graph.get(name2)中，将name2加入到name1映射到的集合graph.get(name1)中。 接下来，就是用集合实现广度优先算法来获取距离了。话不多说，先给出代码。 intgetDistance(Personname1,Personname2) { intdistance=0; if(graph.containsKey(name1)&&graph.containsKey(name2))//有这两个人 { Map<Person,Integer>search=newHashMap<Person,Integer>();//search标记邻接点是否被访问过 Set<Person>set=newHashSet<Person>();//已经遍历到的全部点的集合set set.add(name1); search.put(name1,0); while(search.containsValue(0))//存在没有遍历的点 { if(set.contains(name2))//已经搜索到了name2 { returndistance; } Set<Person>friend=newHashSet<Person>();//新一轮遍历到的全部点的集合 Iterator<Person>it=set.iterator();//遍历全部点的集合 while(it.hasNext()) { Personx=it.next();//从set中依次取出 if(search.get(x)==0) { friend.addAll(graph.get(x));//将x的邻接的点全部添加到集合friend中 search.put(x,1);//标记x的邻接点已访问 } } set.addAll(friend);//将新集合并入原集合set it=set.iterator(); while(it.hasNext())//遍历集合set { Personx=it.next(); if(search.containsKey(x)==false)//存在search中未加入的新点 { search.put(x,0); } } distance=distance+1;//完成一次搜索，距离加1 } return-1; } else { System.out.println("error!根本没这人"); System.exit(0); } returndistance; } 首先，我们要保证这两个点在图中确实存在，然后我们再进行下一步。 用distance标记两人之间的距离，这里用了另一个HashMap对象search标记一个顶点是否被访问过邻接点。 Map<Person,Integer>search=newHashMap<Person,Integer>(); 用HashSet存储name1可达的顶点（我们从name1出发，搜索name2）。 Set<Person>set=newHashSet<Person>(); 如果一个顶点Person的邻接点被存入了set中，我们就把Person映射到的值标记为1，反之，如果点Person的邻接点还没有被存入set，我们将Person映射到的值标记为0。 下面我们正式开始。 首先我们将name1加入set，并将映射（set，0）写入哈希表search，因为此时我们仅仅是将name1写入了set，并没有将set的邻接点写入set。 接下来就要进入循环了，循环条件为search.containsValue(0)，也就是说在set中，存在着一些点，它们的邻接点还没有被添加进set中，此时我们可以继续添加这些点。 循环开始，我们先判断了name2是否存在于set中（不排除name2等于name1的可能），如果name2已存在于set中，返回distance（name2等于name1时，distance为0）。 接下来，我再次new了一个HashSet的集合。 Set<Person>friend=newHashSet<Person>(); friend存储的是这一轮循环过程中，将要被添加到set中的点，因为set需要遍历，担心直接添加进set中会引起混乱（这个我并没有进行实验，感兴趣的可以尝试一下），但是用个friend缓冲一下，就不会遇到这种问题了。 接下来，开始遍历set，依次从set中取出元素，如果这个元素被search标记为0，即它的邻接点并未被添加（我们暂时不考虑邻接点有哪些，有可能其实它的邻接点已经全部被添加进set中了，但是我们是不知道的，我们必须通过再添加一次，来保证不产生遗漏，Set类就像数学中的集合一样，会帮我们去掉重复的元素），我们将它映射到的集合添加到friend中（即将所有邻接点加入friend中）并将这个元素重新标记为1。 全部遍历完成后，我们再将集合friend并入到集合set中。 紧接着，我们再一次遍历set集合，如果set中存在元素，在search中不存在（即前一轮遍历得到的friend中存在着新的，原set中不存在的元素，被加入到了set中），则将此元素添加到search中，并使其映射到0。 遍历完成后，distance加1，即在原先已遍历到的顶点的前提上再次前进了一节。 接下来，继续进行最外层的循环。如果set中存在被标记为0的元素，则继续进行前面的步骤。 如果不存在被标记为0的元素，则说明上一轮的搜索并没有增加新的元素，我们已经完全搜索了name1可达的节点，这应该是图的一个连通子图。如果name2存在于这个子图中，由于新一轮搜索并没有增加新的标记为0的节点，也就是说在之前一轮的循环结束，set中就已经包含了这个连通子图，而在上一轮的循环中，显然如果存在name2，那么在if条件的判断时就应该已经返回了结果。因此，name2是不存在这个连通子图中的，也就是说name1无法到达name2，于是，我们返回一个-1。 有点啰嗦，写的有点多，希望大佬们不要见怪。 
第234篇文章[0]
哈工大软件构造Lab3（继承不同父类时返回值类型不同带来的比较问题，提高代码的可复用性） 在实验三中，我们写了两个接口 IntervalSet<L> MultiIntervalSet<L> 我们定义了时间段类Interval privatefinallongstart; privatefinallongend; 在Interval中保存的是一个时间段的开始时间与结束时间 对于两个接口，写了相应的实现 CommonIntervalSet<L> privatefinalMap<L,Interval>intervals=newHashMap<>(); CommonIntervalSet所实现的主要功能是管理标签L到时间段Interval的映射关系。每个标签L只能对应一个时间段。 如：在安排值班时间时，每个人只安排一个时间段。 在CommonIntervalSet<L>中，我们给出了一种方法，得到标签Llabel对应的时间段 publicIntervalgetInterval(Llabel) CommonMultiIntervalSet<L> privatefinalMap<L,IntervalSet<Integer>>intervals=newHashMap<>(); CommonMultiIntervalSet实现的功能是管理标签L到时间段集合IntervalSet<Integer>的映射关系。IntervalSet<Integer>即第一个接口，这里我们是用Integer类型代替抽象数据类型。每个标签L映射到一个时间段集合，即每个标签可以对应多个时间段。 如：进程执行时，执行时间并不是连续的，因此一个进程可能对应多个时间段。 在MultiCommonIntervalSet<L>中，我们给出了一种方法，得到标签Llabel对应的时间段的集合IntervalSet<Integer> publicIntervalSet<Integer>getInterval(Llabel) 介绍完前提，我们开始介绍本次实验中遇到的问题。 我们需要设计一个值班表排表的APP，DutyRosterSet 我们需要实现两种APP 第一种：同一个员工可以在两个不连续的时间段值班 第二种：同一个员工的值班时间必须是连续的 publicclassDutyRosterSetextendsCommonMultiIntervalSet<Employee>implementsIDutyRosterSet publicclassDutyRosterSetextendsCommonIntervalSet<Employee>implementsIDutyRosterSet 很明显，对于第一种APP，我们应该继承CommonIntervalSet<L>类；对于第二种，我们应该继承CommonMultiIntervalSet<L>类 在DutyRosterSet中，我们需要实现以下功能 给定标签Llabel，以及时间段Intervaltime 我们要判断label是否指向时间段label 我们已经从CommonIntervalSet<L>和CommonMultiIntervalSet<L>中分别继承了 publicIntervalgetInterval(Llabel) 以及 publicIntervalSet<Integer>getInterval(Llabel) 此时，就给我们代码的实现带来了一定的问题。 当我们调用getInterval（label）的时候，由于继承的类不同，所返回的返回值的类型也不同，由于我们无法直接判断返回值是一个时间段的类型Interval，还是时间段集合IntervalSet<Integer>。这给我们判断标签label是否指向时间段time造成了很大困难。 因此，当已经实现第一种APP后，如果想实现第二种APP，此时我们不仅需要将继承的类由CommonIntervalSet<L>更改为CommonMultiIntervalSet<L>，还需要修改代码，这与我们要求尽可能高的复用性的要求相矛盾。 接下来，我们介绍一下针对这种问题的解决方案 2种方法，其实大同小异，都简单的写了一下 为了提高代码的可复用性，使我们可以更方便的根据不同要求，修改更少的代码。 我们考虑将判断的过程放入父类 第一种：保留差异性，在不同的父类中实现的方法，需要传入不同的参数 在CommonIntervalSet<L>中添加以下方法 publicbooleanbelong(Intervala,Intervalb) 在CommonMultiIntervalSet<L>中添加以下方法 publicbooleanbelong(Intervalt,IntervalSet<Integer>set) 此时，我们再判断标签label是否指向时间段time的时候，只需要调用 belong（time，getInterval（label）） 由于在CommonIntervalSet<L>中，getInterval（label）返回的是Interval类型，而belong（，）要传入的参数正是Interval型 而在CommonMultiIntervalSet<L>中，getInterval（label）返回的是IntervalSet<Integer>类型，而belong（，）要传入的参数则是IntervalSet<Integer>型，此时分别对应相等 此种方法既解决了继承不同父类时返回值不同的问题，同时也保留了部分差异性，当我们所需实现的APP对某些差异性有针对性的要求时，可以使用此方法 第二种：直接使用同样的接口 在CommonIntervalSet<L>和CommonMultiIntervalSet<L>中添加同样的方法 publicbooleanbelong(Intervalt,Llabel) 此时，我们要判断label是否指向时间段time，只需要调用 belong（time，label） 这种方法就消除了差异性的问题，使代码有了更高的可复用性 同时，因为消除了差异性，只保留了共性的部分，使其他程序员在使用我们设计的接口时，更简单易懂 个人还是比较倾向于第二种方法的，毕竟我们写接口就是为了抽象出共性的东西，让我们可以更方便的反复利用 总结： 为了提高可复用性，应尽量减少继承不同父类时出现的返回值类型不同的问题，减少其个性的方法，增加其共性的方法，针对不同要求有不同实现，然后通过相同的接口，可以让我们的代码具有更好的可复用性 
第235篇文章[0]
正则表达式中的元字符 在软件构造实验三中，我们为排班表应用添加了一个从文本中读取排班信息的功能 文本中给出的信息在格式上可能是错误的，如果我们直接拿来使用的话，当我们在后续的对文本信息进行解析的过程中，可能会出现很多不必要的麻烦 通过使用正则表达式，在对文本内容解析之前，先筛除掉格式错误的文本文件，可以很大程度上减少我们后续过程中的工作量 我总结了一下常用的正则表达式的元字符，并简单介绍了一下它们的含义 正则表达式中的元字符 元字符正则表达式中的写法含义."."代表任意一个字符\d"\\d"代表0~9的任意一个数字\D"\\D"代表任意一个非数字字符\s"\\s"代表空白字符。如‘\t’、‘\n’\\S"\\S"代表非空白字符\w"\\w"代表可用作标识符的字符（不包括‘$’）\W"\\W"代表不可用于标识符的字符\p{Lower}\\p{Lower}代表小写字母{a~z}\p{Upper}\\p{Upper}代表大写字母{A~Z}\p{ASCII}\\p{ASCII}ASCII字符\p{Alpha}\\p{Alpha}字母字符\p{Digit}\\p{Digit}十进制数字\p{Alnum}\\p{Alnum}数字或字母字符\p{Punct}\\p{Punct}标点符号\p{Graph}\\p{Graph}可见字符\p{Print}\\p{Print}可打印字符\p{Blank}\\p{Blank}空格或制表符\p{Cntrl}\\p{Cntrl}控制字符 资料来源：《Java从入门到精通》，清华大学出版社，2019年10月第1版 
第236篇文章[0]
初学Iterator迭代器设计模式 初学迭代器设计模式，一直不怎么理解，希望通过写篇博客加强理解。 我的理解是，迭代器设计模式可以解决这个问题。如果我有一个自已定义的类，这个类有当作容器的功能，比如里面有一个属性是Set，然后我想要遍历被放入这个容器类的一组ADT对象，而无需关注容器的具体类型，这时就可以使用迭代器设计模式了。 我们需要关注两个接口，Iterable和Iterator。这两个接口的大致结构如下： publicinterfaceIterable<T>{   Iterator<T>iterator(); } publicinterfaceIterator<E>{ booleanhasNext(); Enext(); voidremove(); } 让自己的集合类实现Iterable接口，并实现自己独特的Iterator迭代器（hasNext,next,remove），允许客户端利用这个迭代器进行显示或隐式的迭代遍历： for(Ee:collection){ } Iterator<E>iter=collection.iterator(); while(iter.hasNext()){ } 下面看一个具体的例子。比如我们要造一个停车场ParkingField，这是一个接口，它的实现类是ConcreteParkingField。然后车位的类叫Lot，停进去的东西有汽车，摩托车等，所以有一个接口Parkable。下面看看怎么实现迭代器。我们首先需要给停车场这个容器提供遍历的功能，所以用ParkingField继承接口Iterable，再用ConcreteParkingField实现ParkingField。r然后需要提供一个迭代器，用ParkingIterator来实现接口Iterator。代码框架大致如下（里面的方法和属性不是重点，所以我把大部分的属性用…代替，重点是和迭代器相关的东西）： ParkingField继承接口Iterable publicinterfaceParkingFieldextendsIterable<String>{ publicstaticParkingFieldcreate(int[]nos,int[]widths)throwsException{ returnnewConcreteParkingField(nos,widths); } publicstaticParkingFieldcreate(Map<Integer,Integer>lots)throwsException{ returnnewConcreteParkingField(lots); } publicvoidparking(Stringtype,Stringplate,intwidth,intnum,String[]extraRegistrationInfo)throwsException; publicvoidparking(Stringtype,Stringplate,intwidth,String[]extraRegistrationInfo); publicdoubledepart(Stringplate)throwsException; publicMap<Integer,String>status(); publicintgetNumberOfLots(); publicbooleanisLotInParkingField(intnum,intwidth); publicbooleanisEmpty(); intgetLotWidth(intnum)throwsException; } ConcreteParkingField实现接口ParkingField publicclassConcreteParkingFieldimplementsParkingField{ privatefinal  privatefinalMap<Lot,Parkable>status=newHashMap<>(); privatefinal  publicConcreteParkingField(Map<Integer,Integer>lotsInfo)throwsException{ } publicConcreteParkingField(int[]nos,int[]widths){ } @Override publicvoidparking(Stringtype,Stringplate,intwidth,intnum,String[]extraRegistrationInfo)throwsException{ } @Override publicvoidparking(Stringtype,Stringplate,intwidth,String[]extraRegistrationInfo){ } @Override publicdoubledepart(Stringplate)throwsException{ } @Override publicMap<Integer,String>status(){ } @Override publicintgetNumberOfLots(){ } @Override publicbooleanisLotInParkingField(intnum,intwidth){ } @Override publicbooleanisEmpty(){ } @Override publicintgetLotWidth(intnum)throwsException{ } @Override publicStringtoString(){ } //重点是这个。。。返回一个迭代器 @Override publicIterator<String>iterator(){ returnnewParkingIterator(this.status); } ParkingIterator来实现接口Iterator注意，正常情况下Iterator的泛型应该是Parkable，为了不给ParkingField和client泄露Parkable，改成了String。 publicclassParkingIteratorimplementsIterator<String>{ privatefinal  privatefinal  privateintcount=0; publicParkingIterator( ){   } @Override publicbooleanhasNext(){ returncount< size(); } @Override publicStringnext(){   count++;   } @Override publicvoidremove(){   } } 总的来说，迭代器模式让数据处理逻辑和内部数据管理分离，用一种更安全的方式进行遍历。此外，还可以还可以控制内部数据的顺序，这上面的例子中，于ParkingIterator的构造方法中加入一个排序即可。以上，如有错误，恳请斧正。 
第237篇文章[0]
Java中的列举Enumerations 复习的时候发现Java中的Enumerations这个类型以前好像没有见过，感觉有时候还是挺有用的，所以就来记录一下。 根据我的理解，Enumerations就是一个类class，但是里面可以自定义一些常用的对象。比如说我有一个课程（Course）类，然后我经常使用的对象有math，Chinese，English这三门课程，所以就可以把这三种对象定义在Enumerations里面。 publicenumCourse{ math("math",6,"m"),Chinese("Chinese",4,"c"),English("English",4,"e"); privatefinalStringcourseName; privatefinalintstudyHours; privatefinalStringteacherName; Course(StringcourseName,intstudyHours,StringteacherName){ this.courseName=courseName; this.studyHours=studyHours; this.teacherName=teacherName; } publicStringgetCourseName(){ returnthis.courseName; } publicStringgetTeacherName(){ returnthis.teacherName; } publicintgetStudyHours(){ returnthis.studyHours; } } 像这样，我定义了一个Enumerations，里面有三个常用的对象，math，Chinese，English。如果想要调用其中一个也很容易，如下： Coursem=Course.math; System.out.println(m.getTeacherName()); 这样，m就是math这个对象了。 另外，还可以遍历这些对象，像这样： for(Coursep:Course.values()){ System.out.println(p.getCourseName()); } 后来又发现一点，不要轻易修改里面属性的值。比如现在我把Course修改如下，让它变成一个mutable的ADT，就是把studyHours前面的final修饰符去掉，然后增加了一个修改studyHours的方法setStudyHours。 publicenumCourse{ math("math",6,"m"),Chinese("Chinese",4,"c"),English("English",4,"e"); privatefinalStringcourseName; privateintstudyHours; privatefinalStringteacherName; Course(StringcourseName,intstudyHours,StringteacherName){ this.courseName=courseName; this.studyHours=studyHours; this.teacherName=teacherName; } publicStringgetCourseName(){ returnthis.courseName; } publicStringgetTeacherName(){ returnthis.teacherName; } publicintgetStudyHours(){ returnthis.studyHours; } publicvoidsetStudyHours(inthours){ this.studyHours=hours; } } 然后我尝试修改属性的值： publicstaticvoidmain(String[]args){ Coursem=Course.math; m.setStudyHours(4); System.out.println(m.getStudyHours()); System.out.println(Course.math.getStudyHours()); } 结果输出都是4。这就说明第一句的m=Course.math应该是让m指向math的空间，然后修改m的studyHours后，这个空间里的studyHours就会发生变化，所以Enumerations里面的math对象也就变化了。因此我觉得对于Enumerations，还是使用immutable的数据类型为好。 
第238篇文章[0]
学习了Java中ADT的等价性的一些收获 这里写自定义目录标题 等价关系对象的等价性equals函数hashCode函数可变类型的等价性对equals和hashCode的总结 最近在软件构造课里学习了Java中ADT的等价性，希望能够通过写博客这种方式来总结一下，加强理解。 等价关系 之前在集合论与图论中学过关系，等价关系需要满足三个性质，自反性、对称性、传递性。对于一个集合T，这个集合的某一个关系可以定义为其笛卡尔积的子集，即关系R ⊆ \subseteq ⊆T × \times ×T。下面看看等价关系的三个性质。自反性 ∀ \forall ∀t ∈ \in ∈T,tRt.对称性 ∀ \forall ∀u,v ∈ \in ∈T,ifuRv,thenvRu.传递性 ∀ \forall ∀u,v,w ∈ \in ∈T,ifuRv,andvRw,thenuRw. 对象的等价性 注：这里的对象指的都是不可变(immutable)的，如果是可变的，直接用Object类里的函数即可。 老师上课举的例子我觉得对我的启示比较大，两个对象是否等价，需要比较的不应该是它们内部的属性，而是属性经过AF(abstractionfunction)映射后是结果，即AF(rep1)是否等于AF(rep2)。其中rep1和req2分别是待比较的两个对象的属性列表。 例子如下： publicclassDuration{ privatefinalmins; privatefinalsecs; //repinvariant: //mins>=0,secs>=0 //abstractionfunction: //representsaspanoftimeofminsminutesandsecsseconds /**Makeadurationlastingformminutesandsseconds.*/ publicDuration(intm,ints){ mins=m; secs=s; } /**@returnlengthofthisdurationinseconds*/ publiclonggetLength(){ returnmins*60+secs; } } 这是一个表示时间的类，如果要比较两个Duration对象的等价性，判断两个属性是否相等显然是不合理的，比如 Durationd1=newDuration(1,2); Durationd2=newDuration(0,62); 这两个对象虽然内部的属性不同，但表示的意义都是62秒，所以应该等价。这里就可以用函数getLength()来判断了，如果返回值相等，则等价。 在这里需要约束class里面的方法。对于两个等价的对象，执行同一观察器（observer）函数，返回的结果也要一样。例如有一个class的结构如下： classLetterSet{ privateStrings; //Abstractionfunction: //AF(s)=thesubsetoftheletters{a z}thatarefoundins //(ignoringalphabeticcaseandnon-letters) /**@returntrueifandonlyifallthelettersinthissetarelowercase*/ publicbooleanisAllLowercase(){ } } 这个isAllLowercase函数就是错误的。比如"abc"和"ABC"，有AF，都映射到集合{a,b,c}，但这个函数的返回值不同。 equals函数 首先看一下Object类中的equals函数。 publicclassObject(){   publicbooleanequals(Objectthat){ returnthis==that; } } 对于这个缺省的equals函数，我的理解是判断两个对象是否指向同一个内存空间（不太确定），所以一般来说，对于自己编写的类，需要以上文的原则重写这个函数。重写函数的代码基本如下： @Override publicbooleanequals(Objecto){ if(!(oinstanceofDuration))returnfalse; Durationthat=(Duration)o; returnthis.getLength()==that.getLength(); } 注意，这里的参数必须是Object型。这是因为这是对父类函数的重写（override），参数列表必须相同，如果参数类型不同，那是重载（overload）。比如说我们把equals函数写成下面的格式：publicbooleanequals(Duration)，则如果调用函数传入的参数类型是Duration，当然默认调用是我们写的这个函数，但如果参数是其他的类型，因为类型不匹配，所以会调用父类的equals函数，发生错误。 hashCode函数 这个函数的功能是将对象映射到一个常数。看一下Object类中的hashCode函数。 publicclassObject{   publicbooleanequals(Objectthat){returnthis==that;} publicinthashCode(){return/*thememoryaddressofthis*/;} } 这个函数的默认实现是返回它的内存地址。重写这个函数的规则和equals相似，都是由AF决定的。如果两个对象等价，则它们的hashCode返回值一定相等。对于上面的例子Duration这个类，重写的一种方法为： @Override publicinthashCode(){ return(int)getLength(); } 可变类型的等价性 这里引出了两个概念，观察等价性和行为等价性。观察等价性在不改变状态的情况下，两个mutable对象是否看起来一致。行为等价性调用对象的任何方法都展示出一致的结果。 对于不可变类型来说，这两种等价性是等价的，不可变类型没有变化器（mutator）方法。对于可变类型，往往使用观察等价性来判断，但有时用观察等价性会出现bug。当我们编写一个可变类型时，实现行为等价性即可，equals函数和hashCode函数，不需要重写，直接继承Object的两个方法就行了。当然如果一定要判断两个可变类型“看起来”是否一致，可以定义一个新的方法来判断。 对equals和hashCode的总结 对于不可变类型必须重写这两个方法，保证行为等价性，行为等价性等价于观察等价性。对于可变类型不需要重写，保证行为等价性。 最后，本人新手，恳请斧正。 
第239篇文章[0]
Java中final修饰符与类型检查 文章目录 前言一、类型检查1.静态类型检查2.动态类型检查 二、可变数据类型和不可变数据类型1.可变数据类型2.不可变数据类型 final修饰符修饰可变类型修饰不可变类型 前言 最近在复习，感觉类型检查那部分细节比较多，final修饰符也会涉及到类型检查，所以就把这两个知识点综合起来总结一下。 一、类型检查 1.静态类型检查 Java是一种静态类型的语言。 ----所有变量的类型在编译的时候就已经知道了，然后编译器也会导出所有表达式的类型。 ----如果a和b为int类型，那么编译器会推断a+b也是int类型。 ----eclipse环境会在你写代码的时候就做这些事情，所以你在写代码的时候就会发现eclipse可能报出一些错误。 ----静态类型检查在编译阶段进行。 在编译阶段发现错误，避免了将错误带到运行阶段，可提高程序正确性。 一般是类型相关的错误。如语法错误，类名、函数名错误，参数数目、类型错误，返回值类型错误。 intn=1; if(n)n++; 在eclipse中输入这段代码时，在第二个n处会有红色波浪线，因为和C不一样，Java的判断语句内必须的boolean类型的。所以编译器在编译阶段就会报错。 2.动态类型检查 在像python这样的动态类型语言中，这种检查推迟到运行时候。 ----在运行阶段进行类型检查。 一般的错误有非法的参数值，非法的返回值，越界，空指针。 inta=1,b=0; System.out.println(a/b); 在eclipse中输入这段代码，没有运行时，不会报错。但运行后会抛出异常：Exceptioninthread“main”java.lang.ArithmeticException:/byzero。这是在运行阶段进行检查的动态类型检查。 二、可变数据类型和不可变数据类型 1.可变数据类型 可变数据类型是当改变一个变量的值时，将该变量当前指向的值的存储空间中写入一个新的值。比如StringBuilder是一种可变的数据类型。 StringBuildersb=newStringBuilder("a"); sb.append("b"); 其内部的过程可以由这个图来表示： 2.不可变数据类型 不可变数据类型是改变一个变量，将该变量指向令一个值的存储空间。比如String是一种不可变的数据类型。 Strings="a"; s=s.concat("b"); 其内部的过程可以由这个图来表示： final修饰符 用final修饰class可以阻止被继承；修饰method可以阻止被子类重写；修饰field可以阻止被重新赋值；修饰局部变量也可以阻止被重新赋值。 下面主要讨论final分别修饰可变和不可变数据类型与静态类型检查的情况。 修饰可变类型 以StringBuilder为例。 finalStringBuildersb=newStringBuilder("a"); sb.append("b"); 这段代码没有任何问题，代码快照图和上文可变数据类型的图相同。依然是同一个空间，只是空间里的值不同了。 finalStringBuildersb=newStringBuilder("a"); sb=newStringBuilder("ab"); 这段代码在第二个sb处就会有红色波浪线，因为有final修饰，无法改变变量指向的对象。对于可变数据类型，final使得变量无法改变其引用。 修饰不可变类型 以String为例。 finalStrings="a"; s=s.concat("b"); 和上文的图相同，String是不可变的数据类型，无法修改值，只能重新创建一个空间。这段代码就想要重新创造一个空间，这个空间里面的内容是“ab”，然后让s指向这个空间。显然会报错，因为有final修饰，s无法改变其指向。所以说，对于不可变数据类型，一旦被创建，其值不能改变。 
第240篇文章[0]
Java中类的继承时调用方法的小细节 我在复习备考时发现自己对部分细节还是不熟悉，所以写篇博客记录一下，希望能够帮到大家。 首先我写了三个类，animal，dog，husky。代码如下，非常简单。 publicclassanimal{ publicvoideat(){ System.out.println("eat100"); } publicvoidrun(intp){ System.out.println("run100"); } } publicclassdogextendsanimal{ publicvoideat(){ System.out.println("eat200"); } publicvoidrun(Stringp){ System.out.println("run200"); } } publicclasshuskyextendsdog{ publicvoidrun(intp){ System.out.println("run300"); } } 我们创建对象时，有三组，共六种方式： animala=newanimal(); animalb=newdog(); animalc=newhusky(); dogd=newdog(); doge=newhusky(); huskyf=newhusky(); 第一个 animala=newanimal(); a.eat(); a.run(0); 这里显然只能这样调用，输出结果是eat100和run100没有疑问。 第二个可以看到，虽然dog类中run方法的参数类型是String，但这里只支持int的参数，也就是父类animal的run方法。这是因为这种定义方法，编译器将b静态解析成animal类，所以只能调用animal中的方法。运行一下试试 animalb=newdog(); b.eat(); b.run(0); 输出结果为：eat200（换行）run100。可以看到，eat方法虽然静态解析成animal中的方法，但运行时还是dog的eat方法。run方法，因为参数是int型，所以运行时只能调用animal的run方法。 第三个 animalc=newhusky(); c.eat(); c.run(0); 正如刚才所说，静态检查下是animal的方法。输出结果为eat200（换行）run300。husky中只重写了run方法，所以调用eat时默认运行的是父类dog的eat方法，而调用run方法就是husky的run方法。 第四个dogd=newdog();比较容易，就不再阐述了。 第五个这里的静态解析，将e解析成dog类，可以调用dog类中的方法和其父类animal类中的方法。 doge=newhusky(); e.eat(); e.run(0); e.run("0"); 输出结果为eat200（换行）run300（换行）run200。因为husky中没有些eat，所以这里调用的是父类dog中的eat。然后husky中有run(intp)，所以参数为int时调用husky中的run。参数为String时向父类搜索，调用dog中的run。 第六个huskyf=newhusky();这种情况类似于上一种。 huskyf=newhusky(); f.eat(); f.run(0); f.run("0"); 结果也和上面一种一样，这里就不解释了。 以上内容全部是个人通过代码实验出来的，如果有误，恳请斧正。 
第241篇文章[0]
软件构造（二）checkRep遍历迭代器时死循环可能是因为assert没有设置开启 privatevoidcheckRep(){ Iterator<String>It1=set.iterator(); while(It1.hasNext()){ assertIt1.next()!=null; } } 第一次写checkRep的时候写成类似上面的格式，结果发现运行的时候如果It1.next的key为null，结果就会死循环，不能从while中退出。 后来发现是一个很愚蠢的错误。在eclipse中assert功能是默认关闭的，需要自己在设置中打开。 在新版本的eclipse中从菜单栏打开Run-RunConfigurations… 然后再在右边找到Arguments，在下面VMarguments里输入-ea，点击Run，就能解决问题。 
第242篇文章[0]
软件构造（三）JAVA中ArrayList对自定义类的自然排序 在做软件构造lab3实验的时候，为了想让时间段，按照起始时间的大小从低到高排序，尝试了比较器。 publicclasstimeBlockimplementsComparator{ privatelongbegin; privatelongend; publictimeBlock(longbegin,longend){ this.begin=begin; this.end=end; } publiclonggetBegin(){ returnthis.begin; } publiclonggetEnd(){ returnthis.end; } @Override publicStringtoString(){ return"("+this.begin+"->"+this.end+")"; } @Override publicintcompare(Objecto1,Objecto2){ if(((timeBlock)o1).getBegin()>((timeBlock)o2).getBegin()) return1; elseif(((timeBlock)o1).getBegin()<((timeBlock)o2).getBegin()) return-1; else return0; } } publicclassMain2{ Set<String>set=newHashSet<>(); publicstaticvoidmain(String[]args){ List<timeBlock>set=newArrayList<>(); timeBlocka=newtimeBlock(4,10); timeBlockb=newtimeBlock(2,15); timeBlockc=newtimeBlock(15,19); set.add(a); set.add(b); set.add(c); set.sort(Comparator.naturalOrder()); System.out.println(set); } } 但是发现sort处出现了这样的错误信息。 后阅读Comparator.naturalOrder()的spec，发现要求自定义类必须实现Comparable的接口才能使用Comparator.naturalOrder()来进行自然排序，同理Comparator.reverseOrder()也是一样。 于是对代码修改以实现Comparable publicclasstimeBlock2implementsComparable<Object>{ privatelongbegin; privatelongend; //20210622151943 /** *forbuildatimeBlock *@parambeginpositive *@paramendshouldbelargerthanbegin */ publictimeBlock2(longbegin,longend){ this.begin=begin; this.end=end; } publiclonggetBegin(){ returnthis.begin; } publiclonggetEnd(){ returnthis.end; } @Override publicStringtoString(){ return"("+this.begin+"->"+this.end+")"; } @Override publicintcompareTo(Objecto){ if(this.begin<((timeBlock2)o).getBegin()) return-1; elseif(this.begin>((timeBlock2)o).getBegin()) return1; elseif(this.end<((timeBlock2)o).getEnd()) return-1; else return0; } } publicclassMain2{ Set<String>set=newHashSet<>(); publicstaticvoidmain(String[]args){ List<timeBlock2>set=newArrayList<>(); timeBlock2a=newtimeBlock2(4,10); timeBlock2b=newtimeBlock2(2,15); timeBlock2c=newtimeBlock2(15,19); set.add(a); set.add(b); set.add(c); set.sort(Comparator.naturalOrder()); System.out.println(set); } } 同理在sort中传入参数Comparator.reverseOrder()也可以实现逆向排序。 实际上ArrayList.sort传入的那个参数是一个比较器，并利用compare函数进行sort。所以我们也可以通过自己写compare函数来实现想要的比较方法，例如想进行逆向排序,就直接向sort传一个参数，要求他实现Comparator接口，并Ovrridecompare方法使得反向排序即可 publicclasstimeBlockimplementsComparator{ privatelongbegin; privatelongend; publictimeBlock(longbegin,longend){ this.begin=begin; this.end=end; } publiclonggetBegin(){ returnthis.begin; } publiclonggetEnd(){ returnthis.end; } @Override publicStringtoString(){ return"("+this.begin+"->"+this.end+")"; } @Override publicintcompare(Objecto1,Objecto2){ if(((timeBlock)o1).getBegin()>((timeBlock)o2).getBegin()) return-1; elseif(((timeBlock)o1).getBegin()<((timeBlock)o2).getBegin()) return1; else return0; } } publicclassMain2{ Set<String>set=newHashSet<>(); publicstaticvoidmain(String[]args){ List<timeBlock>set=newArrayList<>(); timeBlocka=newtimeBlock(4,10); timeBlockb=newtimeBlock(2,15); timeBlockc=newtimeBlock(15,19); set.add(a); set.add(b); set.add(c); set.sort(newtimeBlock(0,1)); System.out.println(set); } } 
第243篇文章[0]
软件构造（五）java中privatepublicprotectedstaticfinal关键字的作用 private private关键字，只有在本类之中可以被直接修改。 protected 如果一个类中变量或方法有修饰字protected，同一类、同一包可以使用。不同包的类要使用，必须是该类的子类才能存取变量或调用。 public 任何类和对象都可以引用。 注：如果前面不加public，private和final，那么只能被同包内的类和对象引用。 static static修饰的类成员变量和类成员方法，只能被类调用，将作为类变量，可以不依靠创建对象来调用。比如静态工厂方法可以用来生成对象。但是该类的某一特定对象，也可以通过this.访问类的静态变量和静态方法。 static无法方法内的局部变量。 final final修饰的变量：不能修改引用。 例如：对于immutable的类型，如int，String。不允许修改变量的值。 对于mutable的类型，如ArrayList，可以继续向其中添加或者修改元素，但是不能将新的ArrayList赋值给变量，否则会在编译阶段报错。 当用final作用于类的成员变量时，成员变量必须在定义时或者构造器中进行初始化赋值。 final修饰的方法：不能被Override final修饰的类：不能被继承。final类中的成员方法将被视作final类型。 参考和引用： https://blog.csdn.net/findaway123/article/details/7604676 https://blog.csdn.net/u012723673/article/details/80580011 
第244篇文章[0]
软件构造（四）Eclipse报错：AJNIerrorhasoccurred,pleasecheckyourinstallationandtryagain. 如果出现这个问题，并且正常java安装没问题可能主要的问题是Eclipse中设置的Compiler版本和JRE不一致。如果不一致哪怕重新装多少遍jdk估计也没辙。 JRE的版本，在工程目录中就可以直接看到，而Compiler的版本，可以右键选中工程project图标，然后选择properties JavaCompiler在右边可以看到编译器版本是9，并且可以在下拉栏中修改。 而我的Library版本是jdk1.8，所以需要将编译器版本也修改到1.8. 在properties JavaBuildPath中也可以对libraryremove和add的方式进行更换 
第245篇文章[0]
软件构造（一）java根据类属性生成hash值的方法 在写实验利用HashSet.contains进行判断当前对象在集合中是否存在的时候，需要判断该对象的hash值是否存在。这个时候需要override对象的hashCode方法。 假设对象所在的类大致如下： publicclassCourse{ privatelongID; privateStringname; privateStringteacherName; privateStringlocation; privatelongClass_hours; } 我们需要根据这些属性的值生成hash值。只有当这些属性的值相等的时候散列值相等，可以采用object.hash方法。 如下 publicclassCourse{ privatelongID; privateStringname; privateStringteacherName; privateStringlocation; privatelongClass_hours; @Override publicinthashCode(){ returnObjects.hash(ID,name,teacherName,locationClass_hours); } } 
第246篇文章[0]
ADTandOOP复习总结(一) ADTandOOP复习总结（一） 软件构造的理论基础 ADT(抽象数据类型) 软件构造的技术基础 OOP(面向对象编程) 章节目标 1.Gettoknowbasicknowledgeaboutdatatype,andstaticand dynamictypecheckinginprogramminglanguage,especiallyinJava.  静态/动态类型检查 2.Understandmutabilityandmutableobjects 可变/不变的数据类型 3.Identifyaliasingandunderstandthedangersofmutability  可变数据类型的危险性 4.Useimmutabilitytoimprovecorrectness,clarityandchangeability  不变数据类型的优越性 5.Usesnapshotdiagramtodemonstratethestateofspecifictime duringaprogram’sexecution. 用Snapshot图理解数据类型 6.UseArrays,CollectionsandEnumtodealwithcomplexdatatypes  用集合类表达复杂数据类型 7.KnowtheharmofNullreferencesandavoidit  了解空引用的危害，并避免使用它 1.Typesinjava 基本数据类型 –int(forintegerslike5and-200,butlimitedtotherange±2^31,or roughly±2billion) –long(forlargerintegersupto±2^63) –boolean(fortrueorfalse) –double(forfloating-pointnumbers,whichrepresentasubsetofthereal numbers) –char(forsinglecharacterslike'A'and'$') 对象引用数据类型 –Stringrepresentsasequenceofcharacters. –BigIntegerrepresentsanintegerofarbitrarysize. 根据Java约定，基础数据类型为小写，而对象类型以大写字母开头。 基础数据类型对象引用类型int,long,byte,short,char,float,double,booleanClasses,interfaces,arrays,enums,annotations只有值，没有ID(与其他值无法区分)既有ID，也有值Immutable不可变的Somemutable,somenot可变/不可变Onstack,existonlywheninuse在栈中分配内存Onheap,garbagecollected在堆中分配内存无法实现表达的统一UnityofexpressionwithgenericsDirtcheap代价低Morecostly代价昂贵 将基本数据类型封装为对象类型 Boolean,Integer,Short,Long,Character,Float,Double 通常是在定义容器类型的时候使用它们（容器类型操作的元素要求是 对象类型，所以需要对基本数据类型进行包装，转换为对象类型），一般情况下，尽量避免使用（会降低性能） 操作符 -Assignment:= –Addition:+ –Subtraction:- –Multiplication:* –Division:/ java不支持操作符重载，虽然java里的String可以使用"+"进行连接，貌似进行了运算符重载，但其实不是，这是JVM进行的处理，JVM编译的时候会构建一个StringBuilder，然后调用了append方法将字符串连接起来，这和C++的运算符重载有本质的不同 2.静态与动态数据类型检查 java是静态类型语言，类型检查在运行前就进行了，在像Python这样的动态类型语言中，这种检查会被推迟到运行时（当程序运行时） 检查类型 静态检查动态检查不检查在程序运行之前就会自动发现这个错误执行代码时会自动发现错误该语言根本不能帮助您查找错误。你必须自己注意，否则就会得到错误的答案可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性静态检查往往是关于类型的，这些错误与变量所具有的特定值无关。关于“值”的检查检查类容：Syntaxerrors，Wrongnames，Wrongnumberofarguments，Wrongargumenttypes，Wrongreturntypes，Illegalargumentvalues，Unrepresentablereturnvalues，Out-of-rangeindexes，Callingamethodonanullobjectreference 3.可变性和不可变性 改变一个变量：将该变量指向另一个值的存储空间。 改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。 重要设计原则：不变性，变化是“罪恶”，但程序不能没有变化，尽可能避免变化，以避免副作用 不变数据类型：一旦被创建，其值不能改变 如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变指向其他对象 4.快照图 用于描述程序运行时的内部状态便于程序员之间的交流便于刻画各类变量随时间变化便于解释设计思路 具体看课件上的图，怎么画解释的很清楚，这里不多赘述。 5.复杂数据类型 int[]a=newint[100]; –indexing:a[2] –assignment:a[2]=0 –length:a.length List<Integer>list=newArrayList<Integer>(); –indexing:list.get(2) –assignment:list.set(2,0) –length:list.size() Note1:Listisaninterface.列表是一个接口 Note2:membersinaListmustbeanobject.列表的成员必须是对象数据类型 集合是包含零或多个唯一对象的无序集合。 –s1.contains(e)testifthesetcontainsanelement –s1.containsAll(s2)testwhethers1⊇s2 –s1.removeAll(s2)removes2froms1 Setisanabstractinterface集合是一个抽象接口 AMapissimilartoadictionary(key-value) –map.put(key,val)addthemappingkey→val –map.get(key)getthevalueforakey –map.containsKey(key)testwhetherthemaphasakey –map.remove(key)deleteamapping Mapisanabstractinterface ImplementationsofList,Set,andMap:列表、集合和图的实现 –List:ArrayListandLinkedList –Set:HashSet –Map:HashMap List<String>firstNames=newArrayList<String>(); List<String>lastNames=newLinkedList<String>(); List<String>firstNames=newArrayList<>(); List<String>lastNames=newLinkedList<>(); Set<Integer>numbers=newHashSet<>(); Map<String,Turtle>turtles=newHashMap<>(); 迭代器 迭代器是一个对象，它遍历一组元素并逐个返回元素，for(…:…)形式的遍历，调用的是被遍历对象所实现的迭代器 迭代器（iterator）的两个方法： –next()returnsthenextelementinthecollection thisisamutatormethod! –hasNext()testswhethertheiteratorhasreachedtheendofthecollection 用法如下： List<String>lst=newArrayList<String>(); Iteratoriter=lst.iterator(); while(iter.hasNext()){ Stringstr=iter.next(); System.out.println(str); } 空引用的危害 在Java中，对对象和数组的引用也可以接受特殊值Null，这意味着该引用不指向对象。空值是Java类型系统中一个不幸的漏洞。基本数据类型不能为空，编译器将拒绝这样的带有静态错误的尝试：intsize=null;//illegal无法调用任何方法或使用具有这些引用之一的任何字段（抛出Null指针异常）null与空字符串“”或空数组不相同在参数和返回值中隐式地不允许使用空值。如果一个方法允许一个参数的空值，它应该显式地声明它，或者如果它可能因此返回一个空值，它应该显式地声明它。但这些通常都不是什么好主意。避免设置为空。 
第247篇文章[0]
java接口(Interface)学习笔记 java接口(Interface)学习笔记 接口(Interface)，在java编程语言中是一个抽象类型，是抽象方法的集合，通常用interface来声明，一个类可以通过继承接口的方式，从而来继承接口的抽象方法。一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为 需要注意的是，接口并不是类，编写接口的方式和类很相似，但是他们属于不同的概念，类描述对象的属性和方法，接口则包含要实现的方法。 如下面这是一个典型的类 publicclassDog{ //类的属性,接口的属性只能是finalstatic的属性，不能是变量 Stringname; intsize; Stringcolour; intage; //类的构造函数，接口没有构造函数 publicDog(Stringname){ this.name=name; } /*类的方法方法有方法体，而接口的方法是抽象的，不能有方法体，必须由要实现它的类来定义这些方法*/ voidsetSize(intsize){ this.size; } voidsetColour(Stringcolour){ this.colour=colour; } voidsetAge(intage){ this.age=age; } } 接口与类相似点： 一个接口可以有多个方法。接口文件保存在.java结尾的文件中，文件名使用接口名。接口的字节码文件保存在.class结尾的文件中。接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别： 接口不能用于实例化对象。接口没有构造方法。接口中所有的方法必须是抽象方法。接口不能包含成员变量，除了static和final变量。接口不是被类继承了，而是要被类实现。接口支持多继承。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是publicstaticfinal类型的。接口中不能含有静态代码块以及静态方法(用static修饰的方法)，而抽象类是可以有静态代码块和静态方法。一个类只能继承一个抽象类，而一个类却可以实现多个接口。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。总而言之，实现接口的类除非是抽象类，否则该类要定义接口中的所有方法。 接口的声明语法格式如下 [可见度]interface接口名称[extends其他的接口名]{ //声明变量 //抽象方法 } 下面是个接口声明的简单例子 publicinterfaceNameOfInterface { //任何类型final,static字段 //抽象方法 } 接口有以下特性： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。接口中的方法都是公有的。接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。 实例 interfaceAnimal{ publicvoideat(); publicvoidtravel(); } 接口的实现 当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 实现一个接口的语法，可以使用这个公式：  implements接口名称[,其他接口名称,其他接口名称 , ]  实例(抽象类实现接口) 抽象类和接口都是java中用来实现多态的方法，在java一般的用法中，如果要用普通类来实现接口，则必须实现该接口中的所有方法，这样就会导致需要实现多余的方法； 采用抽象类来实现方法，可以实现该接口中的部分方法，而且当其他类继承该抽象类时，只需要实现抽象类中未实现的方法即可。 例: 抽象类B只实现了接口A中的方法a、b， 当类C继承类B时，只需要实现B中为实现的接口c即可。 一般情况下，类C中的方法a、b都是调用父类B的方法a、b。 接口代码 publicinterfaceAction{ publicvoidjump(); publicvoideat(); publicvoidrun(); } 抽象父类 publicabstractclassAnimalimplementsAction{ publicStringname; publicintage; publicAnimal(){ } publicAnimal(Stringname,intage){ this.name=name; this.age=age; } publicabstractvoidfly(); @Override publicvoidjump(){ System.out.println(name+"在跳高"); } //没有实现publicvoidrun()和publicvoideat(); } 子类： publicclassCatextendsAnimal/*implementsJumpping*/{ publicCat(){ } publicCat(Stringname,intage){ super(name,age); } //只需实现了抽象类的抽象方法publicabstractvoidfly(); publicvoidfly(){ System.out.println("猫在飞"); } publicstaticvoidmain(Stringargs[]){ Catcat=newCat("wyq",12); cat.fly; cat.jump();//canrun,ok! cat.fly();//canrun,ok! cat.run();//会报错，抽象父类中并没有实现这个方法 } } 实例(普通类类实现一个接口) 需要实现接口中的所有方法 publicclassDogimplementsAnimal{ //类的属性,接口的属性只能是finalstatic的属性，不能是变量 Stringname; intsize; Stringcolour; intage; //类的构造函数，接口没有构造函数 publicDog(Stringname){ this.name=name; } /*类的方法方法有方法体，而接口的方法是抽象的，不能有方法体，必须由要实现它的类来定义这些方法*/ voidsetSize(intsize){ this.size; } voidsetColour(Stringcolour){ this.colour=colour; } voidsetAge(intage){ this.age=age; } /*需要实现的接口的方法*/ @Override publicvoideat(){ System.out.println("Dogeats"); } @Override publicvoidtravel(){ System.out.println("Dogtravels"); } publicstaticvoidmain(Stringargs[]){ Dogdog=newDog("wyq"); dog.eat(); dog.travel(); } } 实例(普通类实现多个接口) 如现在有两个接口如下 publicinterfaceInterface1{ publicvoidmethod1(); } publicinterfaceInterface2{ publicvoidmethod2(); } 那么一个类可以一并实现上面两个接口 publicclassAimplementsInterface1,Interface2{ publicA(){ } @Override publicvoidmethod1(){ System.out.println("method1"); } @Override publicvoidmethod2(){ System.out.println("method2"); } } 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。一个类只能继承一个类，但是能实现多个接口。一个接口能继承另一个接口，这和类之间的继承比较相似。 接口的继承(extends关键字) java类的多继承是不合法，但接口是支持多继承的。 语法如下  extends接口名称,其他接口名称,其他接口名称 ,  如现在有两个接口如下 publicinterfaceInterface1{ publicvoidmethod1(); } publicinterfaceInterface2{ publicvoidmethod2(); } 那么第三个接口可以同时继承上面两个接口 publicinterfaceInterface3extendsInterface1,Interface2{ publicvoidmethod3(); } 实现类，A类实现了Interface3，需要将Interface3的方法和它继承的Interface1和Interface2的方法一并实现。 publicclassAimplementsInterface3{ @Override publicvoidmethod1(){ System.out.println("method1"); } @Override publicvoidmethod2(){ System.out.println("method2"); } @Override publicvoidmethod3(){ System.out.println("method3"); } publicstaticvoidmain(String[]args){ method1(); method2(); method3(); } } 
第248篇文章[0]
java泛型理解 java泛型理解 泛型在java中经常使用，有很重要的作用，在做软件构造的实验，我对泛型的理解不是很深，但随着了解和运用越来越多，理解也就加深了，这里记录一下学习的理解 什么是泛型？ 泛型，即“参数化类型”，是对java语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样，泛型的本质是为了参数化类型，在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型，在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 对于常见的泛型模式，推荐的泛型类型变量有： E：元素（element），多用于java集合框架K：关键字（Key）N：数字（Number）T：类型（Type）V：值（value）T和T的区别：T是tpye的首字母缩写；T表示“返回值”是一个泛型，传入什么类型，就返回什么类型，而单独的“T"表示限制传入的参数类型 举个例子说明泛型的作用 ListarrayList=newArrayList(); arrayList.add("aaaa"); arrayList.add(100); for(inti=0;i<arrayList.size();i++){ Stringitem=(String)arrayList.get(i); Log.d("泛型测试","item="+item); } 运行程序，崩溃 java.lang.ClassCastException:java.lang.Integercannotbecasttojava.lang.String 原因是ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。 我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。 List<String>arrayList=newArrayList<String>();   //arrayList.add(100);在编译阶段，编译器就会报错 泛型的特性 泛型只在编译阶段有效。看下面的代码： List<String>stringArrayList=newArrayList<String>(); List<Integer>integerArrayList=newArrayList<Integer>(); ClassclassStringArrayList=stringArrayList.getClass(); ClassclassIntegerArrayList=integerArrayList.getClass(); if(classStringArrayList.equals(classIntegerArrayList)){ Log.d("泛型测试","类型相同"); } 输出结果：D/泛型测试:类型相同。 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 泛型如何使用 泛型有三种使用方式，分别为：泛型类，泛型接口，泛型方法 1.泛型类 泛型类型用于类的定义中，最典型的是各种容器类，如：List，Set，Map 泛型的基本写法： class类名称<泛型标识：可以随便写任意标识号，标识指定的泛型的类型>{ private泛型标识/*（成员变量类型）*/var;   } } 举个例子： /*T的类型由外部指定*/ publicclassExample<T>{ privatekey; publicExample(Tkey){ this.key=key } publicTgetkey(){ returnkey } } 那如何使用呢 //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型 //传入的实参类型需与泛型的类型参数类型相同，即为Integer. Example<Integer>genericInteger=newExample<Integer>(123456); //传入的实参类型需与泛型的类型参数类型相同，即为String. Example<String>genericString=newExample<String>("key_vlaue"); Log.d("泛型测试","keyis"+genericInteger.getKey()); Log.d("泛型测试","keyis"+genericString.getKey()); 结果： 泛型测试:keyis123456 泛型测试:keyiskey_vlaue 2.泛型接口 泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： //定义一个接口 publicinterfaceGen<T>{ publicTnext() } 当实现泛型接口的类，未传入泛型实参时： /** *未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 *即：classFruitGenerator<T>implementsGen<T>{ *如果不声明泛型，如：classFruitGeneratorimplementsGenerator<T>，编译器会报错："Unknownclass" */ classFruitGenerator<T>implementsGen<T>{ @Override publicTnext(){ returnnull; } } 当实现泛型接口的类，传入泛型实参时： /** *传入泛型实参时： *定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator<T> *但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 *在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 *即：Generator<T>，publicTnext();中的的T都要替换成传入的String类型。 */ publicclassFruitGeneratorimplementsGenerator<String>{ privateString[]fruits=newString[]{"Apple","Banana","Pear"}; @Override publicStringnext(){ Randomrand=newRandom(); returnfruits[rand.nextInt(3)]; } } 3.泛型方法 泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型。 假设需要实现这样一个方法：该方法负责将一个Object数组的所有元素添加到一个Collection集合中。考虑采用如下代码来实现该方法： staticvoidfromArrayToCollection(Object[]a,Collection<Object>c){ for(Objecto:a){ c.add(o); } } 上面定义的方法没有任何问题，关键在于方法中的c参数，它的数据类型是Collection。正如前面介绍的，Collection不是Collection的子类型 所以这个方法的功能很有限，它只能将Object[]数组的元素复制到元素为Object（Object的子类不行）的Collection集合中，即下面代码会引起问题。 String[]strArr={"a","b"}; List<String>strList=newArrayList<>(); //Collection<String>会报错，Collection<String>不能当做/Collection<Object>使用 可见上面方法的参数类型不可以使用Collection，使用通配符Collection<?>也不行，因为Java不允许把对象放进一个未知类型的集合里。为解决这个问题，可以使用泛型方法，在声明方法时定义一个或多个类型形参。泛型用法格式如下： 修饰符<T，S>返回值类型方法名(形参列表){ //方法体 } 该泛型方法的方法签名比普通方法的方法签名多了类型形参声明，类型形参声明以尖括号括起来，多个类型形参直接以逗号（，）隔开，所有的类型形参声明放在方法修饰符和返回值类型之间。采用支持泛型的方法，就可以将上面的fromArrayToCollection方法改写为如下形式 static<T>voidfromArrayToCollection(T[]a,Collection<T>c){ for(Objecto:a){ c.add(o); } } 可以看到Object被替换成了T，而且在修饰符和返回值中间加了 下面代码示范了完整用法 static<T>voidfromArrayToCollection(T[]a,Collection<T>c){ for(Objecto:a){ c.add(o); } } publicstaticvoidmain(Sting[]args){ Object[]oa=newObject[100]; Collection<Object>co=newArrayList<>(); fromArrayToCollection(oa,co) String[]sa=newString[100]; Collection<String>cs=newArrayList<>(); fromArrayToCollection(sa,cs) Integer[]ia=newInteger[100]; Collection<Integer>co=newArrayList<>(); fromArrayToCollection(ia,ci) } 上面程序调用了一个泛型方法，该泛型方法中定义了一个T类型形参，这个T类型形参就可以在该方法内当成普通类型使用。与接口、类声明中定义的类型参数不同的是，方法声明中定义的形参只能在该方法内使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。 与类，接口中泛型参数不同的是，方法中的泛型参数无须显式传入实际类型参数，如上面程序所示，当程序调用fromArrayToCollection()方法时，无须在调用该方法前传入String、Object等类型，但系统依然可以知道类型参数的数据类型，因为编译器根据实参推断类型实参的值，它通常推断出最直接的类型参数。 
第249篇文章[0]
用git把本地文件推送到远程仓库 要把实验的项目交到GitHub上，因为用git提交的问题之前一直有点迷糊，今天再整理一下一.先提交到本地仓库1.之前的gitbash已经安装好了，检查一下名字和地址，可以看到已经完成了绑定 2.创建一个空目录并将它设置为当前目录用pwd查看当前目录，看到当前目录已经设置成labs了 本地已经创建了一个labs空目录（这里注意windows目录里不能有中文） 3.把目录初始化为仓库 4.把eclipse的项目文件一到这个目录下 这里这个报错是说，要把我文件里的所有LF换行符换成CRLF换行符，这个主要是因为不同操作系统的换行符不一样，如果是跨平台开发的话要执行gitconfigcore.sutocrlffalse,因为我们就交到GitHub上，所以就简单忽略这个警告就行了。5.把文件提交到仓库 二.再提交到远程仓库1.添加远程库，就是在GitHub上建立一个仓库，我这里就是统一要求的仓库 这里wyq-cloud的地方应该是你的GitHub的用户名，labs的地方应该是你的仓库名你也可以用另一种办法：使用SSHkey命令应该是：$gitremoteaddoriginSSHkey这个SSHkey从GitHub上得到：进入你的仓库主页，在下载代码的地方 有一个SSH把它复制下来，粘贴到SSHkey的地方就行了（如果你这个命令用错了，添加了一个不存在的远程仓库，后面推送本地库内容会报错： 你可以删掉刚才那个库： 然后重新添加远程库）2.把本地库的内容推送到远程库 远程库里就有这些文件里，在master分支里 参考：https://blog.csdn.net/weixin_42152081/article/details/80558282?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162526935516780261942725%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&request_id=162526935516780261942725&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2alltop_positive~default-1-80558282.first_rank_v2_pc_rank_v29&utm_term=git&spm=1018.2226.3001.4187 
第250篇文章[0]
软件构造复习笔记（一） 软件构造复习：软件构造的多维度视图和质量目标1.按阶段划分：构造时/运行时视图（phases：build-/run-timeviews）按动态性划分：时刻/阶段视图（moment/periodviews）按构造对象的层次划分：代码/构件视图（levels:code/componentviews）2.软件构造：在不同视图间转换3.五个关键的质量目标：(1)容易理解：understandability可理解性.(2)准备好改变：maintainabilityandadaptability可维护性和适应性(3)发展的成本低：designwith/forreusereusability可复用性(4)健壮性(5)表现？Performance一．多维度软件视图1.Software=Program+Data+Documents软件=程序+数据+文档2.Software=Modules(Components)+Data/ControlFlows软件=模块（构件）+数据流/控制流3. 时刻时间段 代码构件代码构件构造时源代码静态链接codechurn配置项抽象语法树包、库、版本接口-类-属性文件、测试用例–方法、构造脚本（类图）（构件图） 代码构件代码构件运行时代码快照动态链接并行多线程事件日志内存转储包、库、执行时栈轨迹多进程、配置、中间件、分布式进程网络、数据库1）构造时视图1.代码层面：代码的逻辑组织：接口、类、方法、函数构件层面：代码的物理组织：库、包、目录、文件时刻：特定时刻软件形态时间段：软件形态随时间变化2.Build-time/moment/code:三种相互关联的形式：词汇层面:半结构化的语法层面:（AST）彻底结构化，将源代码变为一棵树语义层面:表达需求和设计思想Build-time/period/code:Codechurn代码变化Build-time/moment/component:源代码-文件-（目录）-包-构件-子系统-库3.库：操作系统提供的/编程语言提供的/第三方提供的/自己积累的4.静态链接：在静态链接里、库是单个对象文件的集合。Build进程时，如果一个函数被需要，链接工具会把它从库里抽取出来，复制到可执行文件中，执行的时候就是代码的一部分了，不再需要库文件。静态链接发生在构造阶段（buildtime）可执行文件被加载到机器上时静态链接就结束了，；最终的可执行文件被创建之后，就不能再从库中分离程序。（UML是统一软件建模语言；VCS版本控制系统；SCI软件配置项）2）运行时视图1.运行时：程序被载入目标文件，开始执行代码层面：逻辑实体在内存中如何呈现构件层面：物理实体在物理硬件环境中如何呈现2.一个库不能直接在机器上加载执行，必须先连接到可执行文件3.NativeMachineCode(原生机器码）：CPU可以直接理解，最快的执行代码的方法4.FullProgramInterpretation（程序完全解释执行）5.InterpretedByteCodes（解释型字节码）：（JVM：java虚拟机）6.动态链接：库文件在build阶段不被加入可执行文件，只做出标记；运行时，根据标记装载库值内存；发布软件时，需要把所有动态库也复制给用户优点：更新库的版本不需要重新创建可执行文件；许多操作系统值上传一份副本到内存，然后分享7.分布式程序的运行态：需要多个运行程序，分别不属于多个计算机物理环境8.Run-time/moment/code:代码快照：程序运行时内存里变量层面的状态内存信息转储：进程因为某些原因终止时，在内存里存一个它的内容的副本Run-time/period/code:执行跟踪：用日志方式记录程序执行的调用次序Run-time/Period/component:日志（系统层面） 
第251篇文章[0]
2021-06-23 软件构造课后感想 软件构造课程已经接近尾声，实验也均验收，所以这里大致写一下对于课程和实验的一些感想。这门课程在期中开课，学时相比前几年缩减了一半以上，但是学习的内容似乎没有减少，区别是实验少做了一个，并且前三个实验的内容有所减少，总体来说压力是很大的，因为同期还有CSAPP这门大课。对于课程内容，因为学时压缩，感觉内容有些过多了，主要运用了java学习软件构造，包括测试，数据类型，规约，面对复用性，可维护性，健壮性，正确性进行软件构造等内容，使我们对软件构造有了一个大体的认知，并且也基于老师给的模板进行了部分实践，可以说收获是比较多的，对于编程也有了进一步的了解，相比之前学习的数据结构，高级程序语言设计等课上单纯的算法题目或者是对于数据结构，数据类型的学习，软件构造课上所学到的内容更加综合化，具体，面向实践，使我们对程序的理解更加深入，但是没有教材，并且ppt也基本是英文的，这一点有些遗憾，对于课程的学习造成了不小的困难，因为专业术语较多，即使借助翻译软件进行学习，结果也不尽人意，希望以后可以推出中文的教材或者是翻译后的ppt，这样自学时会方便许多。再谈谈实验，因为之前几乎没有关于java的学习，学校也没有安排相关的课程，而实验使用的是java语言，并且运用较为深入，不是之前对于c语言的那种简单使用，所以在实验过程中遇到了很多的障碍，java的使用不熟练对实验影响很大，个人认为软件构造课程初期应该至少花几节课的时间讲解一下java的基础使用，做实验的时候，不少地方都是大概理解应该如何实现，理解思想也有了思路，但是用java却不知道该怎么做，所以实验完成的过程效率很低，花费了过多的且没有必要的时间。但是实验本身是十分契合教学的，实验中对课程所讲授的内容基本都有涵盖，让我们对于课程内容真正地有了一些理解，如果能够在不查阅资料的情况下很好地完成实验，那么对于这门课程的学习基本就没有问题了，所以我认为实验设计的是很好的。既能复习巩固上课所学习的知识点，也能在实验的过程中自学不少知识。 
第252篇文章[0]
一篇通俗易懂的ADT介绍 最近笔者通过哈工大的软件构造课程,学习了抽象数据类型.我们,将通过打比方的形式,通俗易懂的给大家讲明白ADT是谁,为什么要有这个东西,以及,怎么构建它 ADT:抽象数据类型 定义:抽象数据类型（AbstractDataType，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。按照MIT的说法,ADT可以用下面的这幅图来进行描述: 直观的看,ADT就是一道墙,将内在的表示与外部的使用进行隔离这种隔离,通过接口进行的间接访问,降低了代码块与块之间的耦合性. 下面的两个比喻,形象生动的说明了ADT是干什么的,为什么这么重要: 就像盖房子,我们写的软件代码,java里面一个个的Class,就像很多的***普通的砖头***,我们并不需要他们每一个都那么的独领风骚,我们需要每一块砖头都长得差不多,标准一致,这样可以进行将砖头进行千百次的堆砌.同时,我们需要一块砖头如果觉得它存在质量问题,我们可以马上用另一块相似的砖头进行代替.就像军舰里面的***水密隔舱***,通过一层一层的将船与外面的大海进行隔离,那么如果一侧因为中弹而进水,将防水门一关,进水将不会影响到军舰的其余部分. 为了能够造出更规则统一的砖头(水隔舱),无数计算机领域的巨佬,研究出ADT这样的指导思想,帮助外面更好的,造出统一而又安全的砖头. 可变与不可变数据类型 还是使用砖头来作比方:如果我们想要自己用砖头搭建起来的房子是可以平稳存在的,那么,我们就首先得要求这个砖头,它是稳定的.不可变数据类型就像是一块死砖头,它不会因为外界的操作而改变自己的属性,可以说这个砖头,它是死的.我们就可以依靠这个砖头来作房子的地基.从而使房子四平八稳.比如说,上图的字符串String,就是不可变的,它如果对其进行操作,会直接返回新的一个对象那么,如果我们的代码里面用了可变的数据类型,它会带来什么后果呢? 直接给外界你内部的属性的指针,让外界直接对内部属性进行修改.导致一些很阴间的bug.比如:神不知鬼不觉的,数据结构内部属性的值一下子就变了… /** *@returnthefirstdayofspringthisyear */ publicstaticDatestartOfSpring(){ returnaskGroundhog(); } ******************************************** //somewhereelseinthecode  publicstaticvoidpartyPlanning(){ DatepartyDate=startOfSpring(); //  } /** *@returnthefirstdayofspringthisyear */ publicstaticDatestartOfSpring(){ if(groundhogAnswer==null){ groundhogAnswer=askGroundhog(); } returngroundhogAnswer; } privatestaticDategroundhogAnswer=null; ********************************************** //somewhereelseinthecode  publicstaticvoidpartyPlanning(){ //let'shaveapartyonemonthafterspringstarts! DatepartyDate=startOfSpring(); partyDate.setMonth(partyDate.getMonth()+1); // uh-oh.whatjusthappened? } 所以,正如大厦的地基必须要用混凝土和坚实的砖石来打,程序内部所依靠的数据类型,最好是采用不可变的数据类型 Spec规约 假如我们是来给别人家房子的施工队,在出发之前,一般都是要和雇主甲方爸爸签一个文书的,这个就是规约Spec 这个spec,它通过规定双方的责任,也就是产品问题,找谁说理去.细分为两大类:前置条件:如果产品坏了,这个责任在用户.后置条件:如果产品坏了,这个责任在施工队. 在我们写Java程序时,其实,也有这样的一个spec要去完成它长这样: /** *Findavalueinanarray. *@paramarrarraytosearch,requiresthatvaloccursexactlyonce *inarr *@paramvalvaluetosearchfor *@returnindexisuchthatarr[i]=val */ staticintfind(int[]arr,intval) 不难发现里面的前置与后置可以大致分下: 前置条件 @paramarrarraytosearch,requiresthatvaloccursexactlyonceinarr @paramvalvaluetosearchfor find(int[]arr,intval) 后置 Findavalueinanarray. @returnindexisuchthatarr[i]=val 它就像一个防火墙,隔绝开了用户与程序内部的表示. 换一种视角数据->操作 如果我们对之前学的数据结构与算法换一种视角来看,我们的数据结构其实可以被一组操作进行刻画. 比如说,以我手里的茶杯为例它作为一名普普通通的茶杯,它可以用以下操作来刻画 classTeaCup{ /** *喝茶 */ publicDrink(){}; /** *倒茶 */ publicFill(WaterTea){}; } 我们作为21世纪的消费者,是不需要了解这个茶杯它是用硅酸盐组成的.然后里面添加了什么样子的化学物质来进行塑性等待的细节.我们使用的,只是它给我们的两个方法:喝茶,倒茶. ADT也一样,我们给外界的是一组操作,而非内部的表示. 四大er,四种方法 具体来说,这些操作可以细分为四大方法:以杯具的一生为例: 构造器:凭空直接给你造出一个茶杯生产器:放入一个白色的茶杯,与一些颜料,给你返回一个黑色的茶杯观察器:看下茶杯是否为空的,里面的茶叶是什么品种的.变值器:放入一个空茶杯,返回一个打满了茶水的茶杯. 来一点数学:抽象函数AbstractFunction 我们上面说了这么多,其实可以用一个简单的数学映射加以描述 AF(内在表示)==>抽象值 程序员需要利用号内在的表示值,同时编写程序,来进行映射,向外界提供观测,修改抽象值的接口. 这便是抽象.通过抽象,隐藏底层复杂的实现细节,将间接,可靠一致的抽象操作提供给外界,从而达到降低系统整体的耦合度的效果. 底层的实现细节就是R空间.而用户关注的空间,或者说,我们给用户呈现的空间,就是A空间,即抽象空间. 下面就是一个例子,通过抽象函数,我们将字符串映射到了集合空间A里面. 左边的R,是Representation,即数据表示.这个,便如我们施工队的比方,是我们房子下面的地基.这个地基,必须要稳,否则房子本身就是不稳定的,有害于人民群众的财产安全. 所以,我们作为ADT的编写者,有责任去做点事情,来确保这个房子是稳定的.体现为: RI表示不变量 还是以集合为例,我们用按顺序排列的字母来队这个集合进行表示,所有串里面的字符排列,必须是升序的.这个升序,就是RI,它对表示空间进行了划分,将我们用到的合法的值,映射为true,其余为false用函数的角度来说 RI(表示)==>{true,false} 我们还可以在代码里面对这个进行检查,因为只要我们的表示什么时候被RI给映射到了false,那么就意味着,我们的代码出bug了… 上述内容便是ADT的一些介绍,谢谢大家. 
第253篇文章[0]
五种基于委托(delegation)设计模式的场景+代码分析 笔者在复习哈工大软件构造的设计模式时,对最基本的五种设计模式,展开了探讨 当然,借着编程操作的机会,也练习了一下正则匹配,防御式编程参数检查等一些软构课上教的(要考的)内容下面是五种基本的设计模式试用场景 目录 工厂方法装饰器模式适配器模式迭代器模式访问者模式小结 工厂方法 基本介绍通过工厂类,将客户端与client进行隔离开场景:假如我们要为一个游戏写NPC,考虑到NPC以后的种类会很多,所以,应该建议采用工厂方法而不是new,对NPC进行创建 //main publicclassCM{ publicstaticvoidmain(String[]args){ PersonP=PersonFactory.createPeron("M");//由静态工厂方法调用 System.out.print(P.getName()); } } //NPC publicclassPerson{ privatefinalStringname; publicPerson(StringN){ this.name=N; } publicStringgetName(){ returnname; } } //NPC的工厂方法: packageFactory; publicclassPersonFactory{ //普通工厂 publicPersonCreatPerson(Stringn){ returnnewPerson(n); } //静态工厂方法 publicstaticPersoncreatePeron(Stringn) { returnnewPerson(n); } } 装饰器模式 场景:假如我们的游戏需要对NPC进行包装 穿上了防弹衣可以防弹穿上雨衣可以防雨穿上了翅膀可以飞 客户需要构造穿着雨衣的鸟人和穿着防弹衣的鸟人 那么可以这样构造 //human的接口 publicinterfaceHuman{ /** *进行互动的行为 */ publicvoidaction(); } //human的实现基类 publicclassConcreteHumanimplementsHuman{ @Override publicvoidaction(){ System.out.println("我是Human"); } } /** *装饰类基类 */ publicclassBasicDecoratorimplementsHuman{ privatefinalHumanh0; publicBasicDecorator(Humanh1){ if(h1==null){//进行参数的检查 thrownewNullPointerException();//runTimeException } h0=h1; } @Override publicvoidaction(){ h0.action(); } } //三种装饰器 publicclassRaincoatHumanextendsBasicDecorator{ publicRaincoatHuman(Humanh1){ super(h1); } @Override publicvoidaction(){ System.out.println("这人穿了雨衣"); super.action(); } } publicclassFlyableHumanextendsBasicDecorator{ publicFlyableHuman(Humanh1){ super(h1); } @Override publicvoidaction(){ System.out.println("这人长了翅膀可以飞"); super.action(); } } publicclassBullyProfHumanextendsBasicDecorator{ publicBullyProfHuman(Humanh1){ super(h1); } @Override publicvoidaction(){ System.out.println("这人刀枪不入"); super.action(); } } //main函数 publicstaticvoidmain(String[]args){ //穿着雨衣的鸟人 HumanH0=newRaincoatHuman(newFlyableHuman(newConcreteHuman())); H0.action(); //穿着防弹衣的鸟人 HumanH1=newBullyProfHuman(newFlyableHuman(newConcreteHuman())); H1.action(); } 输出: 具体的UML类图 适配器模式 场景:假如我们由一个算法的黑盒子,只能够接受浮点数据为输入,以整形数为输出.而我们现在向用户提供的接口是字符串为输入,字符串为输出.这个时候,需要我们利用适配器,对类进行适配. 注意:我们需要对前置条件的参数进行检查,同时,也需要检查后置条件是否满足.采取的思路:前面的前置,利用正则进行检查,抛出UncheckedException.后面的用assert来进行判定,判定后置条件是否满足.思考:一个合法的浮点数,长什么样子? 不是0003.14这样子的,这样子太丑了可以没有小数点,但是如果有小数点,我们需要对后面的数位进行判定 我们写正则的时候,需要体现对思考的check //假如我们由一个黑盒: /** *年份久远的黑盒,可以work */ publicclassOldBlackBox{ publicintgetAnswer(doubled0){ System.out.println("计算中 "); return888; } } //我们向用户承诺了一个API接口 publicinterfaceAPIUserInterface{ /** *我们的API向用户提供的方法 * *@param以小数形式的字符串,必须为合法的小数,如为非0098.xxx格式(大于一的,前方不能含有0) *@return字符串形式的整形数888 */ publicStringAPIWork(Stringinput); } //现在我们对这个进行适配 publicclassAdapterimplementsAPIUserInterface{ @Override publicStringAPIWork(Stringinput){ //进行检查前置条件是否合法 if(!input.matches("([1-9][\\d]*|[0-9])(\\.[\\d]+)?"))//运用正则 { thrownewIllegalArgumentException("输入数据:"+input+"不是合法的浮点数"); } System.out.println("你输入了:"+input); //Delegate黑盒进行计算 OldBlackBoxOBB=newOldBlackBox(); Doubled0=Double.valueOf(input); Integeri=OBB.getAnswer(d0); StringRET=i.toString(); //检查后置条件是否合法 assertRET.equals("888"); returnRET; } } //用户代码: publicstaticvoidmain(String[]args){ APIUserInterfaceAPIU=newAdapter(); System.out.println(APIU.APIWork("996")); System.out.println("--------------"); System.out.println(APIU.APIWork("18.47")); System.out.println("--------------"); System.out.println(APIU.APIWork("18..47")); } 输出: 迭代器模式 场景:假如我们向用户提供一个List的抽象,用户可以从头进行顺序遍历到尾部. List需要满足其类型是Number的子类 //直接写了一个数组 publicclassUniqueList<LextendsNumber>implementsIterable{ privatefinalList<L>L0; publicUniqueList(){ L0=newArrayList<>(); } publicvoidadd(Lll){ L0.add(ll); } //按照王老师的做法,这里可以直接在类里面写迭代器,这样,就可以直接访问类里面的信息 privateclassUniqueIterator<L>implementsIterator<Object>{ privatefinalList<L>myL=newArrayList(L0); privateintcurrent=0; @Override publicbooleanhasNext(){ returncurrent<myL.size(); } @Override publicObjectnext(){ if(!hasNext()){ thrownewArrayIndexOutOfBoundsException("你访问第"+(1+current)+"个(1~n)元素,导致数组越界"); } Llo=myL.get(current); current++; returnlo; } @Override publicvoidremove(){ thrownewUnsupportedOperationException("删除元素并没有得到支持"); } } @Override publicIterator<L>iterator(){ returnnewUniqueIterator(); } } //客户端 publicstaticvoidmain(String[]args){ UniqueList<Integer>UL=newUniqueList<Integer>(); UL.add(5); UL.add(4); UL.add(3); UL.add(2); UL.add(1); Iterator<Integer>uli=UL.iterator(); while(uli.hasNext()){ System.out.println(uli.next()); } uli.next();//试图访问越界 结果: 访问者模式 场景:假如我们已经写好了一个数组的类.考虑到未来的扩展,我们留存了一个accept的方法来允许visitor对其进行访问 现在目标逐渐明确, 1.用一个visitor来进行访问数组,求平均值 2.用一个visitor来访问数组,求总和 3,用一个visitor来访问数组,求向量的模长 默认数组是int类型的 //我们的数组接口 publicinterfaceListInterface0extendsIterable{ /** *获取idx位置的元素 * *@paramidx合法的位置 *@returnidx位置的元素 */ publicintgetElement(intidx); /** *添加元素 * *@paramval添加的元素 */ publicvoidaddElement(intval); /** *接受访问者v0的扩展 * *@paramv0访问者 */ publicvoidaccept(Visitorv0); } //我们的访问者接口 publicinterfaceVisitor{ /** *对列表进行访问 * *@paramL0 */ publicvoidvisit(ListInterface0L0); } 数组接口的实现代码 publicclassList2implementsListInterface0{ privatefinalList<Integer>L0=newArrayList<>(); @Override publicintgetElement(intidx){ returnL0.get(idx); } @Override publicvoidaddElement(intval){ L0.add(val); } //按照王老师的做法,这里可以直接在类里面写迭代器,这样,就可以直接访问类里面的信息 privateclassUniqueIterator<L>implementsIterator<Object>{ privatefinalList<L>myL=newArrayList(L0); privateintcurrent=0; @Override publicbooleanhasNext(){ returncurrent<myL.size(); } @Override publicObjectnext(){ if(!hasNext()){ thrownewArrayIndexOutOfBoundsException("你访问第"+(1+current)+"个(1~n)元素,导致数组越界"); } Llo=myL.get(current); current++; returnlo; } @Override publicvoidremove(){ thrownewUnsupportedOperationException("删除元素并没有得到支持"); } } @Override publicIterator<Integer>iterator(){ returnnewUniqueIterator(); } @Override publicvoidaccept(Visitorv0){ v0.visit(this); } } 三种访问者的实现代码: //平均值访问者 publicclassMeanVisitorimplementsVisitor{ @Override publicvoidvisit(ListInterface0L0){ intsum=0; inti=0; Iterator<Integer>ii=L0.iterator(); while(ii.hasNext()){ sum+=ii.next(); i++; } System.out.println("平均值为:"+(double)((double)sum/i)); } } //总和访问者 publicclassSumVisitorimplementsVisitor{ @Override publicvoidvisit(ListInterface0L0){ intsum=0; inti=0; Iterator<Integer>ii=L0.iterator(); while(ii.hasNext()){ sum+=ii.next(); i++; } System.out.println("总和为:"+(sum)); } } //向量长度访问者 publicclassVecLengthimplementsVisitor{ @Override publicvoidvisit(ListInterface0L0){ intsum=0; Iterator<Integer>ii=L0.iterator(); while(ii.hasNext()){ intt=ii.next(); sum+=(t*t); } System.out.println("向量长度为:"+(sum)); } } 主函数 publicstaticvoidmain(String[]args){ ListInterface0L2=newList2(); L2.addElement(5); L2.addElement(4); L2.addElement(3); L2.addElement(2); L2.addElement(2); L2.accept(newMeanVisitor()); L2.accept(newSumVisitor()); L2.accept(newVecLength()); } 输出: UML图: 可以发现,访问者与被访问者互相依赖 小结 根据王忠杰老师所言:这五种设计模式,均是对委托(两颗继承树)的变形与拓展.在动手操作之后,发现老师说的,还真是蛮有道理的,脑海里对基本的设计模式的UML图有一个基本的映像,动手操作起来,还真是不难的. 以上便是这篇博客的全部内容.谢谢. 
第254篇文章[0]
哈工大2021软件构造实验3心得(1)-进行GUI设计 哈工大2021软件构造实验3心得(1)-进行GUI设计 最近,笔者完成下窝工的软构实验三.在完成过程中,有很多坑想要记录一下.顺便方便一下后来的窝工学子. 此Blog主要讨论如何在Eclipse里面写出一个GUI WindowBulider介绍 来自应用商店的介绍:WindowBuilderiscomposedofSWTDesignerandSwingDesignerandmakesitveryeasytocreateJavaGUIapplicationswithoutspendingalotoftimewritingcode.UsetheWYSIWYGvisualdesignerandlayouttoolstocreatesimpleformstocomplexwindows;theJavacodewillbegeneratedforyou.Easilyaddcontrolsusingdrag-and-drop,addeventhandlerstoyourcontrols,changevariouspropertiesofcontrolsusingapropertyeditor,internationalizeyourapp,andmuchmore. 下面我们来介绍一下怎么来进行安装: WindowBuilder的安装 我们直接用最简单的方法,在Eclipse的商店里面装,但是,这个网站由于某种原因,它比较慢,所以,我们选择了换镜像 Eclipse镜像配置 毕竟工欲善其事，必先利其器,秉承着这样一个原则,我们首先对Eclipse的镜像进行配置.(1)打开Window里面的preference界面 (2)直接搜sites关键词进入AvailableSoftwareSites然后把里面的把这里链接里面的http://download.eclipse.org/替换为http://mirrors.ustc.edu.cn/eclipse即把它自己的源,更新为清华镜像比如说以AmaterasUML为例: 如果想进一步的探讨换镜像,可以参考大佬的博客,呐,链接在这.https://blog.csdn.net/weixin_44543145/article/details/95637057 Eclipse安装WindowBuilder 直接进入Help里面的Marketplace 然后进去直接搜索WindowBuilder点击Install,直接安装就可以了.可以发现,切了镜像以后灰常快. 在Eclipse里面设计一个简易的可以传参的GUI 首先,在新建项目里面直接new一个other的新类然后,点击Jframe进行建立给它写个名字点击Finish直接开工.创建完成以后,可以发现 屏幕里面,有菜单,可以进行自由切换,是源代码模式,还是Design模式 进入Design模式,发现,可以进行图形化编程,即,我们在Design里面进行的操作,将会被以代码的形式转到Sourse里面下面,我们将进行设计一个最简单的可以传参的GUI把JTextField,拖到窗口里面.发现窗口里面多了项textField然后,在里面进行更改其text内容与属性右边的窗口也变了 回到Sourse视窗,进行代码的重构发现,在这里面,存在一个一一对应的"你好世界"串,于是,我们将其进行替换为要对方法进行传入的参数即可 更改如下 //更改后 /** *Createtheframe. */ publicJFab(StringargS){ setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(100,100,450,300); contentPane=newJPanel(); contentPane.setBorder(newEmptyBorder(5,5,5,5)); contentPane.setLayout(newBorderLayout(0,0)); setContentPane(contentPane); textField=newJTextField(); textField.setText(argS); contentPane.add(textField,BorderLayout.CENTER); textField.setColumns(10); } } 然后,在main函数里面进行传入特定参数即可实现调用 可以在Design里面对窗口进行个性化比如换字体 以上就是利用Eclipse从无到有,设计一个可传参的GUI的过程,谢谢大家. 
第255篇文章[0]
哈工大2021软件构造实验3心得(2)在Junit里面对命令行程序的单元测试 笔者最近完成了窝工软件构造里面的Lab3写了一个针对命令行交互的小程序. 不过,在进行测试时遇到了一丢丢小麻烦即,怎么来对一个对命令行交互的程序进行测试 前言 在<<阿里巴巴Java开发规范>>里面有这样的一句话 【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执 行过程必须完全自动化才有意义。 输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。 【强制】单元测试是可以重复执行的，不能受到外界环境的影响。 说明:单元测试通常会被放到持续集成中，每次有代码checkin时单元测试都会被执行。 如果单测对外部环境(网络、服务、中间件等)有依赖，容易导致持续集成机制的不可用。 正例:为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring这样的DI框架注入一个本地(内存)实现或者Mock实现。 我们作为一名系统学习了软件构造的学生,如果仅仅是向大一那样,通过纯手敲的方法,来对一个小软件进行测试,那就有点low了. 于是,我们采用Junit的方法,利用它,进行软件的单元测试 核心 关键:对Java的输入输出进行重定向 首先,我们需要记录下默认的Java输入输出流: //记录标准流 finalInputStreamoInputStream=System.in; finalPrintStreamoOutputStream=System.out; 然后,我们需要手动设置输出流,即,将程序的输出,从屏幕转到我们想要的地方 //设置输出流 finalByteArrayOutputStreamBoutputStream=newByteArrayOutputStream(); System.setOut(newPrintStream(BoutputStream)); FileInputStreamFinputStream=null; 同时,我们还需要手动设置输入流,将键盘输入转成从文件里面进行输入 try{ FinputStream=newFileInputStream("test/CMD/P0.txt"); System.setIn(FinputStream); }catch(FileNotFoundExceptione){ e.printStackTrace(); } 然后,就可以开始进行跑我们的程序了 //这是我的命令行应用程序 ProcessScheduleAppCmdPSAC=newProcessScheduleAppCmd(); PSAC.run(); 跑完以后,我们直接取出标准输出,转String进行检查 StringcmdOutsString=BoutputStream.toString(); assertEquals(true,cmdOutsString.contains("进行随机模拟")); // 这里面省略无数assertequal语句 assertEquals(true,cmdOutsString.contains("是否已经结束：true")); 最后,复位标准输入输出 System.setIn(oInputStream); System.setOut(oOutputStream); 尾声 以上就是利用Junit对在命令行程序进行check的步骤,谢谢大家 
第256篇文章[0]
哈工大软件构造-设计模式学习心得 设计模式 设计模式，即DesignPatterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性 一:总纲 按照王老师的体系,23种设计模式,看上去很多,但万变不离其宗.一切设计模式,均是离不开这两张图.具体来说,就如下两种: 1.只有继承关系的: DIP:依赖倒转原则,细节应当依赖于抽象，抽象不应当依赖于细节。OCP:开闭原则,软件实体应当对扩展开放，对修改关闭. 特点: 只有一颗继承树 在设计模式里面的体现: 模板方法:比如,我写了一个白盒框架,现在要往里面加东西,我希望用户来进行手动添加,那么,我给用户一个接口,下面的子类型实现是可以进行任意安排的. 2.继承+委托(delegation) 特点:两颗继承树 通过另一组继承树,对内在的实现进行了隐藏,具体的体现比如说:Factory方法,Adapter方法,装饰器模式,等等. 对于装饰器来说,可以认为这两颗树均是自己,通过自己对自己进行委托,进行功能的附加. 下面,我们来具体的对王老师上课所授的7种设计模式展开具体分析: 二:具体的7种设计模式 2.1工厂方法: 用户是通过工厂类来得到新的对象,而不是通过new运算符来得到新的对象 常规情况 ProductA=newProductA(); 工厂方法 ProductB=ProductFactory.ProduceA(); 正如船舶里面的水隔舱,工厂类对对象的创建与用户进行了隔离.对于用户而言,它是不知道它的要的产品具体叫什么,这个提供产品的事情,已经被工厂所取代.如果我们需要对功能进行修改的话,只需要动工厂的new的对象,客户端的程序实质上,是稳定的. 2.2适配器模式 考虑下列情形: 假如我们在进行一个机器学习的项目,我们的核心算法,它需要提供一个numpy形式的矩阵,而我们的数据采集器,返回的矩阵,是一个excel文件.这个时候,我们就需要一个适配器,帮我们干活了 它通过委托与接口,在二者之间建立了如下的桥梁; 2.3装饰器模式 人靠衣装,在街上走,你会看到有穿T恤的,穿长袖夹克的,有穿背心的各种各样的人.那么,如果要建立这样的关系的话,我们是可以通过继承来组合,也可以通过建立装饰器来进行委托.如果是组合的话,问题会越来越麻烦.设想,假如一开始所有人都穿T恤,那么到后来,秋天了,大家穿长袖的,有可能是里面套了一个背心,也有可能是里面传了一件毛衣,那么我们都用继承来进行处理的话,这个组合树,将会越来越大.问题很大!这就是组合爆炸所以,正确的做法是,让类学会穿衣服.不同的衣服,展现出不同的特性.有不同的功能 为每一个特性构造子类,并通过委派机制,添加到对象上.基类实现最原始的功能,然后每一个装饰类实现一部分,逐层的去委派实现. 2.4策略模式 考虑如下的场景:假如我们在写一个文本翻译的APP,用户输入文本,我们对其进行翻译.我们一开始是采用SVD分解对文本进行词嵌入.后来,竞争对手纷纷采用了BERT来进行词嵌入,效果比我们好很多.那么,我们也想要用BERT来进行,不过由于考虑到以后的扩展,我们决定将词嵌入,放到一个方法类里面去进行.即这里的策略类.策略模式:存在多种算法来处理同一个任务,但client需要根据需要动态切换算法.我们可以为不同的实现算法构造抽象接口.利用委托,在运行时,动态传入Client倾向的算法类的实例.其UML图如下; 2.5模板模式 还是我们的文本翻译APP.众所周知,NLP文本翻译任务,包含以下几个基本步骤:文本预处理->文本词嵌入->Seq2Seq的生成 我们可以把这几个步骤抽出来作为模板,子类在继承时,进行实现.让子类分别实现我们的模板里面的方法,预处理,词嵌入,文本生成.他们,作事情的步骤时一样的,但具体的方法不同.让共性的步骤在公共实现.差异化的在子类实现. 2.6迭代器模式 用途:我们给外界用户的往往是一个黑箱,如果用户有想要逛逛的需求的话,我们便要在既维护内在表示的基础上,又满足外界用户的需求.在Java里面已经提供了下面的接口:Iterable接口:实现这个的集合对象是可遍历的Iterator接口:迭代器,实现这个的是可以进行显示/隐式的进行迭代的. 2.7Visitor模式 简单点说:就是预留扩展点,以便日后的扩展为我们的对象的特定Visit,运行时进行动态的绑定.操作可以灵活更改的.方便以后操作. 以上就是对于设计模式的一些总结与思考,谢谢. 
第257篇文章[0]
Java源码探究学习(一)论List(更新中) Java源码探究学习(一)论List(更新中) 前言:由于笔者于哈工大学习软件构造时,王老师上课抛出了一个小任务,即,从Java的源码里面来学习它的ADT的思想.所以,笔者希望通过写一点点博客,进行探究 一.LinkedList的探究 首先,我们进入linkedlist的源码,进行粗略的看看,首先,看看这个实现的spec,通过加批注的方式进行学习. 首先介绍,这个链表,实现了List与Deque,允许所有的元素. /** *Doubly-linkedlistimplementationofthe{@codeList}and{@codeDeque} *interfaces.Implementsalloptionallistoperations,andpermitsall *elements(including{@codenull}). * *<p>Alloftheoperationsperformascouldbeexpectedforadoubly-linked *list.Operationsthatindexintothelistwilltraversethelistfrom *thebeginningortheend,whicheverisclosertothespecifiedindex. **/ Percondition: 通过加粗的话,设定前置条件,这个实现不是synchronized.的 /* *<p><strong>Notethatthisimplementationisnotsynchronized.</strong> *Ifmultiplethreadsaccessalinkedlistconcurrently,andatleast *oneofthethreadsmodifiestheliststructurally,it<i>must</i>be *synchronizedexternally.(Astructuralmodificationisanyoperation *thataddsordeletesoneormoreelements;merelysettingthevalueof *anelementisnotastructuralmodification.)Thisistypically *accomplishedbysynchronizingonsomeobjectthatnaturally *encapsulatesthelist. * *Ifnosuchobjectexists,thelistshouldbe"wrapped"usingthe *{@linkCollections#synchronizedListCollections.synchronizedList} *method.Thisisbestdoneatcreationtime,topreventaccidental *unsynchronizedaccesstothelist:<pre> *Listlist=Collections.synchronizedList(newLinkedList( ));</pre> **/ Postcondition: 对后置条件进行说明: 说明本类里面方法的返回值,同时提到了failfast,即针对每种不满足情况,抛出的异常 /*<p>Theiteratorsreturnedbythisclass's{@codeiterator}and *{@codelistIterator}methodsare<i>fail-fast</i>:ifthelistis *structurallymodifiedatanytimeaftertheiteratoriscreated,in *anywayexceptthroughtheIterator'sown{@coderemove}or *{@codeadd}methods,theiteratorwillthrowa{@link *ConcurrentModificationException}.Thus,inthefaceofconcurrent *modification,theiteratorfailsquicklyandcleanly,ratherthan *riskingarbitrary,non-deterministicbehavioratanundetermined *timeinthefuture. * *<p>Notethatthefail-fastbehaviorofaniteratorcannotbeguaranteed *asitis,generallyspeaking,impossibletomakeanyhardguaranteesinthe *presenceofunsynchronizedconcurrentmodification.Fail-fastiterators *throw{@codeConcurrentModificationException}onabest-effortbasis. *Therefore,itwouldbewrongtowriteaprogramthatdependedonthis *exceptionforitscorrectness:<i>thefail-fastbehaviorofiterators *shouldbeusedonlytodetectbugs.</i> * *<p>Thisclassisamemberofthe *<ahref="{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"> *JavaCollectionsFramework</a>. **/ 下面是对作者进行了介绍,膜拜一下大佬  /* *@authorJoshBloch *@seeList *@seeArrayList *@since1.2 *@param<E>thetypeofelementsheldinthiscollection */ 再往下面看,发现当年作者写的checkRep即,从这里我们可以看到作者的表示不变量即要么,size是0,链表里面没有元素;firstlastnull要么,first的前面与last的后面,都是null 更新中… 
第258篇文章[0]
软件构造复习笔记(3) 注：文章中带有*的标题表示往年考试中出现过相应考点 文章目录 第七章面向对象的编程(OOP)1基本概念：对象、类、属性、方法*2接口和枚举*4封装和信息隐藏*5继承和重写*Overriding*抽象类 6多态、子类型、重载*9动态分派10一些Java中的重要对象方法*11设计好的类*12OOP历史 第八章ADT和OOP中的“等价性”1等价关系*2不可变类型的等价性3==和equal()*4实现equal()5对象契约*6可变类型的等价性7自动封装和等价性 第九章面向复用的软件构造技术1什么是软件复用2如何度量可复用性3可重用部件的等级和形态5设计可复用类*Liskov替代原则(LSP)*委派和组成* 6设计系统级可复用API库和框架 第七章面向对象的编程(OOP) 1基本概念：对象、类、属性、方法* 对象：是状态和行为的组合状态-对象中所包含的数据-类中的实例变量行为-对象所支持的行为-类中的实例方法 类：每个对象都属于某个类，方法定义了类型和实现类成员变量：一个和类相关而非类的实例相关的变量-静态成员变量类方法：之和类相关的方法-静态方法 注：本节为基础知识，需要掌握 2接口和枚举* 接口(Interface)：一个方法声明的列表，不包含方法体，可以由类实现接口间可以继承和扩展一个类可以实现多个接口(从而具备了多个接口中的方法)一个接口可以有多种实现类 接口-确定ADT规范，类-实现ADT可以不需要接口直接使用类作为ADT，既有ADT定义也有ADT实现但实际中更倾向于使用接口来定义变量 打破了抽象边界，接口定义中没有包含constructor，也无法保证所有实现类中都包含了同样名字的constructor。 故而，客户端需要知道该接口的某个具体实现类的名字。可以提供静态工厂方法而非构造函数来向客户端提供具体实现类。 接口中每个方法都需要在所有实现它的类中实现可以通过default关键字修饰方法，在接口中统一实现某些功能，无需在各个类中重复实现它以增量式的为接口增加额外的功能而不破坏已实现的类 枚举：注：本节了解一下接口就行了 4封装和信息隐藏* 信息隐藏：区分模块设计好坏的唯一最重要的因素是它对其他模块隐藏内部数据和其他实现细节的程度，设计良好的代码应该能隐藏全部实现细节 通过接口进行信息隐藏：1.使用接口类型声明变量2.客户端仅使用接口中定义的方法3.客户端代码无法直接访问属性 权限修饰符：private：只能在类内部进行使用protected：可以在其子类及同个包中的其他类中使用public：在所有类中都可以使用 信息隐藏策略：1.认真设计API2.只提供客户端需要的功能，其他所有成员都应该是private的3.你可以在不破坏客户端的情况下将任何一个private成员修饰为public 注：本节需要了解权限修饰符的功能 5继承和重写* Overriding* 可重写的方法：未加final修饰的方法都可以在子类中重写，即在子类中将该方法重写实现，重写的方法有着和原方法完全相同的声明，实际执行时调用哪个方法，在运行时决定 严格继承：子类只能添加新的方法，无法重写超类中的方法如果一个方法不能被重写，那它一定以final修饰 通产override的方法都需要在方法声明前添加@override final作用：1.变量-使变量在初始化后不能再改变取值2.方法-避免子类中重写该方法3.类-避免该类被继承 重写时，可以使用super()复用父类中函数的功能，并在后续代码中进行拓展重写时，不要改变原方法的本意 抽象类 抽象方法：存在有声明，但没有实现的方法，这个方法由abstract关键字修饰抽象类：存在至少一个抽象方法的类，该类必须由abstract关键字修饰，抽象类不能被实例化 接口可以被认为是只有抽象方法的抽象类 如果某些操作是所有子类型都共有，但彼此有差别，可以在父类型中设计抽象方法，在各子类型中重写。所有子类型完全相同的操作，放在父类型中实现，子类型中无需重写。有些子类型有而其他子类型无的操作，不要在父类型中定义和实现，而应在特定子类型中实现。 注：继承、重写是重要概念，必须掌握 6多态、子类型、重载* 三种多态类型：特殊多态-函数重载参数化多态-泛型子类型多态、包含多态-多个子类继承某父类 重载(Overload)：多个方法具有同样的名字，但有不同的参数列表或返回值类型价值：方便客户端使用，客户端可用不同的参数列表，调用同样的函数重载时一种静态多态：进行静态类型检查，根据参数列表进行最佳匹配，在编译阶段时决定要具体执行哪个方法 重载规则：1.必须有不同的参数列表2.可以有相同/不同的返回值类型3.可以有相同/不同的权限修饰符4.可以有新的或更广泛的检查异常5.可以在同一个类内重载，也可以在子类中重载 重写(Override)则是在运行时进行动态检查，根据内存中对象的具体类型来调用对应方法泛型：以泛型方式定义函数和类型，以便基于运行时传递的参数工作，即允许静态类型化而不完全指定类型。 泛型编程：是一种编程风格，其中数据类型和函数用稍后指定的类型编写，然后在需要时对作为参数提供的特定类型进行实例化。 类型变量：未指定的变量类型泛型类：类定义中包含了类型变量泛型接口：接口定义中包含了类型变量泛型方法：方法定义中包含了类型变量 泛型的其他性质：子类型：若B是A的子类型，意味着每一个B类型的变量都可以被当作A类型B是A的子类型当且仅当B的Spec至少和A一样强，子类型的规约不能弱化父类型的规约 子类型多态：不同类型的对象可以统一的处理而无需区分 注：重载、重写应该掌握，泛型应该了解一下，子类型多态需要注意对子类型spec的要求 9动态分派 动态分派：确定要在运行时调用的方法，即在运行时解析对已覆盖或多态方法的调用静态分派：重载的方法使用静态绑定绑定，而重载的方法在运行时使用动态绑定绑定。 10一些Java中的重要对象方法* equals方法：当两个对象等价时返回true，应满足对称、自反、传递的性质hashCode方法：返回在哈希映射中使用的哈希代码toString方法：返回一个可打印的字符串表示注：应重点关注equal方法 11设计好的类* 不可变类的优点：简单、固有线程安全、可以自由共享、不需要防御拷贝、优秀的构建块 如何写不可变类：1.不提供任何mutator2.确保方法都不会被重写3.使所有变量均被final修饰4.使所有变量均被private修饰5.确保任何可变类型的组成部分的安全性(避免表示泄露)6.实现toString()、hashCode()、equals()等方法 注：需要学会怎么设计不可变的类 12OOP历史 第八章ADT和OOP中的“等价性” 1等价关系* ADT是对数据的抽象，体现为一组对数据的操作抽象函数AF：内部表示->抽象表示基于抽象函数AF定义ADT的等价操作 等价关系：自反、对称、传递注：需要理解什么是等价关系 2不可变类型的等价性 如果AF映射到相同的结果，则等价站在外部观察者的角度，对两个对象调用任何相同的操作，都会得到相同的结果，则认为两个对象是等价的，反之亦然 3==和equal()* ==运算符比较的是对象的引用，两个对象指向同一个内存空间时，则说明这两个对象具有引用等价性equal()方法比较的是对象的内容，即对象等价性 在自定义ADT时，需要重写Object的equals() ==通常用于对基本数据类型判断是否相等，equal()用于判断对象类型是否等价 注：需要了解如何区分两者区别 4实现equal() 在Object中缺省equals()是在判断引用等价性，所以一般需要重写 equal方法如果接受的参数不是Object类型则实现不是override而是overload instanceof运算符可以判断某一变量所指向内存是否属于某各类型(动态检查) 5对象契约* equal方法满足的契约：1.等价关系：自反、对称、传递2.除非对象被修改了，否则调用多次equals应有同样的结果3.对于非null引用x，x.equals(null)应返回false4.等价的对象，其hashCode()的结果必须相同 哈希表：等价的对象必须有相同的hashCode，但不等价的对象也可以有相同的hashCode，不够性能会变差 重载hashCode()：注：主要关注equals()方法 6可变类型的等价性 观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致行为等价性：调用对象的任何方法都展示出一致的结果，可以认为就是引用等价性 对可变类型来说，往往倾向于实现严格的观察等价性，但有时候观察等价性可能导致bug，甚至可能破坏RI 在hashSet等类型中，其内部的可变数据类型发生改变时，hashCode会改变，导致hashSet的contains方法会判断集合中改变过的内容不属于集合 7自动封装和等价性 第九章面向复用的软件构造技术 1什么是软件复用 软件复用是使用现有软件组件实现或更新软件系统的过程 软件复用的两个视角：1.面向复用编程(Creation)：开发出可复用的软件2.基于复用编程(Use)：利用已有的可复用软件搭建应用系统 复用好处：1.降低成本和开发时间2.经过充分测试，可靠、稳定3.标准化，在不同应用中保持一致 2如何度量可复用性 从以下几个角度度量：1.复用的机会有多频繁？复用的场合有多少？2.复用的代价有多大？ 3可重用部件的等级和形态 最主要的复用是在代码层面，但软件构造过程中的任何实体都可能被复用-需求、设计/规约、数据、测试用例、文档 白盒复用：源代码可见，可修改和拓展-复制已有代码到正在开发的系统，进行修改优点：可定制化程度高缺点：对其修改增加了软件的复杂度，且需要对其内部充分的了解 黑盒复用：源代码不可见，不能修改-只能通过API接口来使用，无法修改代码优点：简单、清晰缺点：适应性差些 复用一个类的方法：1.继承：子类可以对父类中的属性、方法等进行复用2.委派：在一个类中使用其他类的方法来实现自己的功能 框架：一组具体类、抽象类、及其之间的连接关系开发者根据framework的规约，填充自己的代码进去，形成完整系统 白盒框架：通过代码层面的继承进行框架拓展黑盒框架：通过实现特定接口/delegation进行框架拓展 5设计可复用类* Liskov替代原则(LSP)* 子类型多态：客户端可用统一的方式处理不同类型的对象在Java中的编译器强制执行的规则：1.子类型可以增加方法，但不可以删2.子类型中需要实现抽象类型中的所有未实现方法3.子类型中重写的方法必须返回相同的类型或其子类型(满足协变)4.子类型中重写的方法必须接收相同的参数类型(满足逆变)5.子类型中重写的方法不能抛出额外的异常 LSP原则：子类方法必须相比于父类方法有着相同或更强的不变量，相同或更弱的前置条件，相同或更强的后置条件，才能使子类无条件地可以替代父类。LSP是子类型关系的一个特殊定义，称为（强）行为子类型 LSP依赖于以下限制：1.前置条件不能强化2.后置条件不能弱化3.不变量要保持4.子类型方法参数：逆变5.子类型方法返回值：协变6.异常类型：协变 协变：随着父类型到子类型越来越具体，对于返回值类型而言，不变或变得更具体，异常的类型也是如此逆变：随着父类型到子类型越来越具体，参数类型会相反地变化，要不变或者越来越抽象(目前Java中这种情况会被视作overload) 数组是协变的：根据Java的子类型规则，一个类型T的数组可以容纳类型T和其子类型的变量 泛型不是协变的，ArrayList是List的子类型，但List不是类型List的泛型 泛型中的通配符： 委派和组成* 以排序为例，如果你的ADT需要比较大小，或者要放入Collections或Array进行排序，可实现Comparator接口构建比较器并overridecompare方法或者实现Comparable接口拓展ADT并overridecompareTo方法(不需要构建新的Comparator类，比较代码防止ADT内部) 上述例子中，Comparator属于delegation，而Comparable不属于delegation 委派：一个对象请求另一个对象的功能，委派是代码复用的一种常见形式 显式委派：将发送对象传递给接收对象隐式委派：通过成员查找规则 委派模式：通过运动时动态绑定，实现对其他类中代码的动态复用 委派和继承：继承通过拓展基类来添加新操作或重写某操作委派通过捕捉某个行为，并将其发送给另一个对象很多设计模式都使用两者组合 如果子类只需要复用父类中的一小部分方法，则可以不需要使用继承，而是通过委派机制来实现一个类不需要继承另一个类的全部方法时，可以通过委派机制调用部分方法，从而避免大量无用方法 委托发生在object层面，而继承发生在class层面 组合复用原则(CRP)：类应该通过其组合（通过包含实现所需功能的其他类的实例）来实现代码重用，而不是从基类或父类继承来实现多态行为和代码重用。 CRP原则的思路：1.使用接口定义系统必须对外展示的不同侧面的行为2.接口之间通过extends实现行为的扩展（接口组合）3.类implements组合接口，从而规避了复杂的继承关系 delegation的类型：1.Dependency:临时性的delegation(作为方法的参数使用)Dependency：对象需要其他对象（供应者）才能实现的临时关系2.Assosiation:永久性的delegation(作为对象的属性使用)Assosiation：对象类之间的持久关系，允许一个对象实例代表另一个对象实例执行操作。3.Composition:更强的assosiation，但难以变化(属性通过内部各方法进行初始化、修改等)Composition：是一种将简单的对象或数据类型组合成更复杂的数据类型的方法4.Aggregation:更弱的assosiation，可动态变化(属性通过外部方法进行修改)Aggregation：对象存在于另一个外部，在外部创建，因此它作为参数传递给解释器。这四种类型都支持一对多的delegation注：本节为重点，需要理解LSP、CRP、继承、委派等概念的含义，并会分析及写相应代码 6设计系统级可复用API库和框架 库：提供可复用功能的类和方法的集合 
第259篇文章[0]
软件构造复习笔记(1) 注：文章中带有*的标题表示往年考试中出现过相应考点 文章目录 第一章软件构造的多维度视图和质量目标1多维度软件视图*Build-timeview-构造阶段-编写代码过程Runtimeview-运行阶段-程序运行过程 2软件构造：视图间的转换3软件系统的质量属性*外部质量因素*内部质量因素折中 4软件构造五大关键质量目标 第二章软件测试与测试优先的编程1软件测试*2测试用例3测试优先的编程*4单元测试5使用JUnit的自动单元测试6黑盒测试*等价类划分边界值分析两个极端的划分覆盖策略 7白盒测试8测试的覆盖度*9自动测试和回归测试10测试策略* 第三章软件构造过程与配置管理1软件开发生命周期(SDLC)2传统软件流程模型![在这里插入图片描述](https://img-blog.csdnimg.cn/20210705212556877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3dzAxMDAwMTM0,size_16,color_FFFFFF,t_70)3敏捷开发4软件配置管理(SCM)和版本控制系统(VCS)*5SCM工具例子：Git*6软件构造的总体流程 第一章软件构造的多维度视图和质量目标 1多维度软件视图* Build-timeview-构造阶段-编写代码过程 Code-levelview-代码的逻辑组织-函数、类、方法、接口等Component-levelview-代码的物理组织-文件、路径、包、库等 Momentview-特定时刻的软件形态-特定时间Periodview-软件形态随时间的变化-一段时间 Runtimeview-运行阶段-程序运行过程 Code-levelview-逻辑实体在内存中如何呈现-内存状态Component-levelview-物理实体在物理硬件环境中如何呈现-物理环境 Momentview-逻辑/物理实体在内存/硬件环境中特定的形态如何-特定时间Periodview-逻辑/物理实体在内存/硬件环境中的形态随时间如何变化-一段时间 上述三类view共构成八种具体情况 代码快照图(Snapshotdiagram)：描述程序运行时内存里变量层面的状态 注：本节需要记住各操作对应八种维度中的哪个 2软件构造：视图间的转换 3软件系统的质量属性* 外部质量因素* 外部质量因素：例如使用的速度或难易程度等质量，其在软件产品中的存在或缺失可以被其用户检测到外部质量因素影响用户 外部质量因素包括：1.正确性：程序能按照预先定义的规约执行，正确性是最重要的质量指标。每一层保证自己的正确性，同时假设其下层是正确的。 2.健壮性：针对异常情况的处理，出现异常时不要崩溃 3.可拓展性：为了应对未来可能的变化 4.可复用性：一次开发，多次使用 5.兼容性：不同的软件系统之间相互可容易的集成 6.高效性：性能毫无意义，除非有足够的正确性，过早优化时万恶之源 7.可移植性：软件可方便的在不同的技术环境之间移植 8.易用性：容易学、安装、操作、监控 9.功能性：提供未来可能需要的功能，每增加一小点功能，都确保其他质量属性不受到损失 10.及时性：用户需要前，软件系统能及时发布 11.其他：可验证性、完整性、可修复性、经济性 注：本节只需要记住几个外部特性即可 内部质量因素 内部质量因素：适用于软件产品的其他质量，如模块化或可读性，是内部因素内部质量因素影响软件本身和它的开发者 复杂性是几乎任何外部质量因素的敌人！内部质量因素通常用作外部质量因素的部分测量。只有外部质量重要，但外部质量取决于内部质量。 折中 正确的软件开发过程中，开发者应该将不同质量因素之间如何做出折中的设计决策和标准明确的写下来 虽然需要折中，但“正确性”绝不能与其他质量因素折中。 最重要的几个质量因素：正确性、健壮性-可靠可拓展性、可复用性-模块化 4软件构造五大关键质量目标 可理解性：可复用性：可维护性和可适应性：健壮性：性能表现： 第二章软件测试与测试优先的编程 1软件测试* 软件测试：提高软件质量的重要手段，用来寻找程序bug、检查程序是否满足使用要求，确认程序是否到达可用级别(用户需求)。关注系统的某一侧面的质量特性。 测试跟其他活动的目标相反：破坏、证错 即使是最好的测试程序也无法达到100%无错误，再好的测试也无法证明系统里不存在错误。 好的测试：能发现错误、不冗余、最佳特性、别太复杂也别太简单 测试层次：静态测试：不需要运行程序，例如检查代码动态测试：描述代码的动态行为，需要运行在给定的集合或测试集合上 测试与调试：测试-发现是否存在错误，调试-识别错误根源，消除错误 白盒测试：对程序内部代码结构的测试黑盒测试：对程序外部表现出来的行为的测试 注：本节只考过选择题，而且比较简单，简单看一遍就行了 2测试用例 测试用例：输入+执行条件+期望结果 好的测试用例的特性：最可能发现错误、不重复、不冗余、最有效、即不简单也不复杂 3测试优先的编程* 在写代码前写测试用例 过程：1.先写spec2.再写符合spec的测试用例3.写代码、执行测试、有问题再改、再执行测试用例、直到通过它 Spec：描述函数的输入和输出行为它给出了参数的类型和对它们的任何附加约束条件。它也给出了返回值类型以及返回值如何与输入相关联在代码中，规范由方法声明和上面描述它所做什么的注释组成。 注：本节内容需要理解Spec是什么 4单元测试 单元测试：针对软件的最小单元模型开展测试，隔离各个模块，容易定位错误和调试 对每个函数的spec编写测试用例，每个测试都应该包括一组预期结果 5使用JUnit的自动单元测试 需要记住的方法：assertEquals、assertTrue、assertFalse 6黑盒测试* 黑盒测试：用于检查代码的功能，不关心内部实现细节 黑盒测试寻找以下类型的错误：1.不正确或缺失的函数2.接口错误3.数据结构或外部数据库使用错误4.行为错误5.初始化和终止错误 黑盒测试的测试用例：为了检查程序是否符合规约，用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误 等价类划分 基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。针对每个输入数据需要满足的约束条件，划分等价类每个等价类代表着对输入约束加以满足/违反的有效/无效数据的集合 基于的假设：相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为测试用例即可 边界值分析 大量的错误发生在输入域的“边界”而非中央 边界值分析方法是对等价类划分方法的补充，在等价类划分时，将边界作为等价类之一加入考虑 两个极端的划分覆盖策略 笛卡尔积：全覆盖多个划分维度上的多个取值，要组合起来，每个组合都要有一个用例并非所有组合情况都可能 测试完备，但用例数量多，测试代价高 覆盖每个取值：最少一次即可每个维度的每个取值至少被1个测试用例覆盖一次即可 测试用例少，代价低，但测试覆盖度未必高 注：本节容易考根据spec写测试用例 7白盒测试 黑盒测试完全从函数spec导出测试用例，不考虑函数内部实现 白盒测试要考虑内部实现细节，根据程序执行路径设计测试用例 白盒测试一般较早执行 独立/基本路径测试：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试用例使每一条基本路径被至少覆盖1次。 8测试的覆盖度* 代码覆盖度：已有的测试用例有多大程度覆盖了被测程序 代码覆盖度越低，测试越不充分，但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高 常用工具：EclEmma 注：本节只在选择题的某个选项中考过EclEmma 9自动测试和回归测试 自动测试：自动调用被测函数、自动判定测试结果、自动计算覆盖度只是“测试用例的自动执行”，并非“自动生成测试用例” 回归测试：一旦程序被修改，重新执行之前的所有测试 一旦发现bug，要马上写一个可重现该bug的测试用例，并将其加入测试库 常用工具：ContinuousIntegration、TravisCI 10测试策略* 测试策略(根据什么来选择测试用例)非常重要，需要在程序中显式记录下来 目的：在代码评审过程中，其他人可以理解你的测试，并判断你的测试是否足够充分 注：本节需要学会怎么写测试策略 第三章软件构造过程与配置管理 1软件开发生命周期(SDLC) 2传统软件流程模型 3敏捷开发 敏捷开发：通过快速迭代和小规模的持续改进，以快速适应变化。 Agile=增量+迭代每次迭代处理一个小规模增量 4软件配置管理(SCM)和版本控制系统(VCS)* 软件配置管理：追踪和控制软件的变化 软件配置项(SCI)：软件中发生变化的基本单元（例如：文件） 基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本） 配置管理数据库(CMDB)：存储软件的各配置项随时间发生变化的信息+基线 版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识” 仓库：即于SCM中的CMDB 工作拷贝：在开发者本地机器上的一份项目拷贝 文件：一个独立的配置项 版本：在某个特定时间点的所有文件的共同状态 变化：即codechurn，两个版本之间的差异 HEAD：程序员正在其上工作的版本 本地版本控制系统：仓库存储于开发者本地机器无法共享和协作 集中式版本控制系统：仓库存储于独立的服务器，支持多开发者之间的协作 分布式版本控制系统：仓库存储于独立的服务器+每个开发者的本地机器 注：本节只在选择题中考过SCI、SCM的概念 5SCM工具例子：Git* Git视图：Git仓库包括以下三个部分：.git文件：本地的CMDB工作目录：本地文件系统暂存区：隔离工作目录和Git仓库 每个文件都处于下列三种状态之一：Modified：已修改Staged：已暂存Committed：已提交Git的对象图： Git存储发生变化的文件本身，而不是变化的代码行文件未发生变化，则后续多个版本始终指向同一个文件文件发生变化了，存储两份不同的文件，两个版本指向不同的文件gitpush、gitpull：向/从远程服务器发送/接受对象图 分支、合并：gitcheckout-bA新建分支Agitcheckout-dA删除分支AgitcheckoutA切换到分支AgitmergeA将当前分支与A合并注：本节考过git所对应的SCM各部分、git的指令等 6软件构造的总体流程 
第260篇文章[0]
软件构造复习笔记(4) 注：文章中带有*的标题表示往年考试中出现过相应考点 文章目录 第十章面向可维护性的构造技术1软件可维护性和演化2可维护性的指标3模块化设计和模块化原则4OO设计原则：SOLID*单一责任原则(SRP)开放-封闭原则(OCP)Liskov替换原则(LSP)接口隔离原则(ISP)依赖转置原则(DIP) 5语法驱动的构造*语法的构成要素语法中的运算*语法中的递归分析树正则语法和正则表达式* 第十一章面向可复用性和可维护性的设计模式1创建模式*2结构模式*适配器模式(AdapterPattern)装饰器模式(Decorator) 3行为模式*策略模式(Strategy)模板模式(TemplateMethod)迭代器模式(Iterator)访问器模式(Visitor) 4设计模式的共性与差异* 第十二章面向正确性与健壮性的软件构造1什么是健壮性和正确性？2如何量度健壮性和正确性3Java中的Error和Exception*4异常处理*5断言6防御式编程7SpotBugs工具 第十章面向可维护性的构造技术 1软件可维护性和演化 软件维护：修复错误、改善性能 主要步骤：1.测试所做的修改2.回归测试3.记录变化 除了修复问题，修改中不能引入新的故障最大的问题：修改后没有足够的文档记录和测试 软件可维护性的类型：软件演化：对软件进行持续的更新，软件的大部分成本来自于维护阶段 软件维护不仅仅是运维工程师的工作，而是从设计和开发阶段就开始了在设计与开发阶段就要考虑将来的可维护性 面向可维护性的构造技术：1.模块化设计2.OO设计原则3.OO设计模式4.基于状态的构造技术5.表驱动的构造技术6.基于语法的构造技术 2可维护性的指标 可维护性：软件系统或组件易于修改以纠正故障、提高性能或其他属性，或适应已改变的环境”。 可拓展性：软件设计/实施考虑到未来的增长，可拓展性被视为扩展系统能力和实施扩展所需努力水平的系统衡量。 灵活性：软件根据用户需求、外部技术和社会环境等而轻松改变的能力。 可适应性：交互系统（自适应系统）的能力，可以根据获取的用户及其环境信息来适应个别用户的行为。 可管理性：监控和维护软件系统的效率和容易，以保持系统运行、安全和平稳运行。 支持性：基于包括质量文档、诊断信息和知识渊博的技术人员的资源，在部署后软件如何有效地运行。 HalsteadVolume:基于源代码中（不同的）运算符和操作数数量的复合度量。 3模块化设计和模块化原则 目的：将系统划分为模块，并用一种模块内高内聚，模块间低耦合的方式分配各模块的职责 模块化降低了程序员在任何时候都必须处理的总复杂性，做到分离关注点和信息隐藏 评估模块性的五个标准：1.可分解性(Decomposability)：较大的组件是否已分解为较小的组件2.可组合性(Composability)：较大的组件是否可以由较小的组件构成3.可理解性(Understandability)：组件是否可以单独理解4.可持续性(Continuity)：对规约的小改变是否只影响本地优先数量的组件5.出现异常之后的保护(Protection)：运行时异常的影响是否局限于少量的相关组件 五个模块化设计的规则：1.直接映射(DirectMapping)2.尽可能少的接口(FewInterfaces)3.尽可能小的接口(SmallInterfaces)4.显式接口(ExplicitInterfaces)5.信息隐藏(InformationHiding) 耦合性：耦合是衡量模块之间依赖关系的度量方法模块间耦合性程度由模块之间的接口数量和每个接口的复杂性决定(复杂性由通信的类型决定) 内聚性：是衡量模块功能或责任的紧密相关的标准，如果一个模块的所有元素都在朝着相同的目标工作，那么该模块就具有很高的内聚性 好的设计需要高内聚，低耦合，但有时需要折中，耦合程度高时，内聚内聚程度倾向于变低，反之亦然 4OO设计原则：SOLID* SOLID：五大类的设计原则TheSingleResponsibilityPrinciple单一责任原则(SRP)TheOpen-ClosedPrinciple开放-封闭原则(OCP)TheLiskovSubstitutionPrincipleLiskov替换原则(LSP)TheDependencyInversionPrinciple依赖转置原则(DIP)TheInterfaceSegregationPrinciple接口聚合原则(ISP) 单一责任原则(SRP) SRP:不应该有多于1个原因让你的ADT发生变化，否则就拆分开；一个类，一个责任责任：变化的原因 如果一个类包含了多个责任，那么将引起不良后果：1.引入额外的包，占据资源2.导致频繁的重新配置、部署等 开放-封闭原则(OCP) 开放：对拓展性的开发，模块的行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化 封闭：对修改的封闭，模块自身的代码是不应被修改的；扩展模块行为的一般途径是修改模块的内部实现；如果一个模块不能被修改，那么它通常被认为是具有固定的行为 关键的解决方案：抽象技术 “软件实体（类、模块、功能等）。应该开放扩展，但关闭修改”，即使用继承和组合/委托更改类的行为 Liskov替换原则(LSP) LSP：子类型必须能够替换其基类型派生类必须能够通过其基类的接口使用，客户端无需了解两者之间的差异 接口隔离原则(ISP) ISP：不能强迫客户端依赖于他们不需要的接口，只提供必需的接口 不要用许多方法污染接口，避免臃肿的接口，客户端不应该被强迫依赖他们不需要的方法接口属于客户端，而不是体系结构 接口臃肿的类是接口不够聚合的类，胖接口可以分解为多个小接口；不同的接口向不同的客户端提供服务；客户端只访问自己所需要的接口 图示： 依赖转置原则(DIP) DIP：抽象的模块不应该依赖于具体的模块，具体的模块应该依赖于抽象的大部分的接口和抽象都应该被使用 delegation时，要通过接口建立联系，而非具体子类注：本节SOLID五个原则都应该了解 5语法驱动的构造* 语法的构成要素 有一类应用，从外部读取文本数据，在应用中做进一步处理。特定的，字节或字符序列应该有如下特性：1.输入文件有特定格式，程序需读取文件并从中抽取正确的内容2.从网络上传输过来的信息，遵循特定的协议3.用户在命令行输入的指令，遵循特定的格式4.内存中存储的字符串，也有格式需要 通常使用语法分析来判断字符串是否合法，并解析成程序里使用的数据结构，且这个数据通常是一个递归的数据结构 一个语法定义了一个字符串集合语法中的文字字符串被称作终止节点，他们是语法解析树的叶节点，无法再向下扩展，通常被表示为字符串 一个语法由一个产生式节点的集合描述，其中每一个产生式都定义了一个非终止节点，并遵循特定规则，利用操作符、终止节点和其他非终止节点，构造新的字符串，非终止节点是树中表示字符串的内部节点 一个语法中的产生式有如下形式：nonterminal::=expressionofterminals,nonterminals,andoperators 根节点：是一个语法中的非终止节点，语法识别出的字符串集合中都是与根节点匹配的字符串 语法中的运算* 三种基本语法运算：连接(Concatenation)-x::=yz-x匹配y后接z的字符串重复(Repetition)-x::=y*-x匹配零个或多个y选择(Union)-x::=y|z-x要么匹配y要么匹配z 运算优先级：1.通常情况下，前缀运算符*,?,+有最高的运算优先度2.连接其次3.选择优先度最低但圆括号可以被用作修改优先级，括号内的优先运算 其他语法运算符：可选(Optional)-x::=y+-x要么是y要么为空一次或多次出现-x::=y+-x是一个或多个y的连接一个字符类-x::=[…]-表示包含方括号中列出的任何字符的长度为1的字符串,例如x::=[a-c]等价于x::=‘a’|‘b’|‘c’一个倒置的字符类-x::=[^…]-表示包含括号中未列出的任何字符的长度为1的字符串，例如x::=[^a-c]等价于x::=‘d’|‘e’|‘f’|… 语法中的递归 分析树 分析树：根据语法匹配将一个字符串生成一个能显示字符串中的各部分如何和语法中各部分联系起来的树树的叶节点标记着终止符号，代表已经被分析完的字符串部分，如果从左到右将叶节点连接，将获得原字符串 正则语法和正则表达式* 正则语法：简化之后可以表达为一个产生式而不包含任何非终止节点 正则表达式：终端和运算符的约简表达式可以写成一种更紧凑的形式，称为正则表达式。正则表达式会去掉了终端周围的引号以及终端和运算符之间的空格，因此它只由终端字符、用于分组的括号和运算符字符组成。 一些正则表达式的运算：.-任意字符\d-任意数字\s-任意空白符\w任意有意义的字符，相当于[a-zA-Z_0-9].()*+…-表示反斜杠后的字符 注：本节只需要学会正则表达式即可 第十一章面向可复用性和可维护性的设计模式 1创建模式* 工厂方法，也被称作虚拟构造器，当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。可以定义一个用于创建对象的接口，让其子类来决定实例化哪个类，从而使一个类的实例化延迟到其子类 带有工厂方法的类也可以实现其他功能有新的具体产品类加入时，可以在工厂类里修改过增加新的工厂函数(OCP)，不会影响客户端代码客户端使用工厂方法来创建实例，得到的实例的类型是抽象接口而非具体类根据类型决定创建哪个具体产品 优点：消除了将特定于应用程序的类绑定到代码的需要。代码仅处理产品接口，因此它可以处理任何用户定义的具体产品 潜在缺点：客户可能必须创建构造类的子类，以便他们可以创建特定的产品。 注：本节了解一下就行 2结构模式* 适配器模式(AdapterPattern) 将某个类/接口转换为客户端期望的其他形式，适配器使由于不相容的接口导致本不能一起使用的类可以一起使用。一般通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。 装饰器模式(Decorator) 装饰器用于为对象添加不同侧面的特性，对于每一个特性构造子类，通过委派机制增加到对象上装饰器使用了子类型和委派 Collections.unmodifiedSet等通过装饰器实现，修改原数据依然会导致所得到的添加特性后的对象改变客户端需要一个具有多种特性的object，可以通过一层一层的装饰来实现注：本节需要简单理解一下 3行为模式* 策略模式(Strategy) 问题：有多种不同的算法来实现同一个任务，但需要客户端根据需要动态切换算法，而不是写死在代码中 实现方法：为不同的实现算法构造抽象接口，利用delegation，运行时动态传入客户端倾向的算法实例 优点：易于扩展到新的算法实现将算法与客户端上下文进行分离 模板模式(TemplateMethod) 问题：做事情的步骤一样，但具体方法不同 实现方法：共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现 模板模式使用继承和重写方法组合的策略来实现 迭代器模式(Iterator) 问题：客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型 解决方案：一种专为迭代的策略模式 作用：1.隐藏底层容器的内部实现2.支持具有统一接口的多个遍历策略3.易于更改容器类型4.促进项目各部分之间的沟通 Iterable接口：实现该接口的集合对象是可迭代遍历的Iterator接口：迭代器 迭代器模式：让自己的集合实现Iterable接口，并实现自己的独特Iterator迭代器，允许客户端利用这个迭代器进行显示或隐式的迭代遍历： 访问器模式(Visitor) Visitorpattern：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类本质上：将数据和作用于数据上的某种/些特定操作分离开 效果：为ADT预留一个将来可拓展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT 只要更换visitor的具体实现，即可切换算法 注：本节内容都比较重要，需要会根据各种设计模式写代码 4设计模式的共性与差异* 共性样式1：只使用继承，不使用委派核心思路OCP/DIP，依赖反转，客户端只依赖“抽象”，不能依赖于”具体“发生变化时最好是扩展，而非修改 代表：Adaptor、Template共性样式2：注：本节需要理解 第十二章面向正确性与健壮性的软件构造 1什么是健壮性和正确性？ 健壮性(Robustness)：系统在不正常输入或不正常外部环境下仍能够表现正常的程度 面向健壮性的编程：1.处理未期望的行为和错误终止2.即使终止执行，也要准确/无歧义的向用户展示全面的错误信息3.错误信息有助于debug 健壮性原则：1.总是假定用户恶意，假定自己的代码可能失败2.把用户想象成白痴，可能输入任何东西3.对别人宽容点，对自己狠一点对自己的代码要保守，对用户的行为要开放 健壮性编程的原则：1.封闭实现细节，限定用户的恶意行为2.考虑极端情况，没有不可能 正确性(Correctness)：程序按照spec加以执行的能力，是最重要的质量指标 正确性-永不给用户错误的结构健壮性-尽可能保持软件运行而不是总是退出正确性倾向于直接报错(error)，健壮性则倾向于容错(fault-tolerance) 健壮性：让用户变得更容易：出错也可以容忍，程序内部已有容错机制正确性：让开发者变得更容易：用户输入错误（不满足precondition的调用），直接结束。 对外的接口，倾向于健壮；对内的实现，倾向于正确 安全关键型应用程序相比于健壮性倾向于支持正确性消费者的应用程序相比于正确性倾向于支持健壮性 可靠性(Reliability)：系统在规定条件下执行其所需功能的能力-故障之间的平均时间长度。Reliability=Robustness+Correctness 提高健壮性和正确性的步骤：0.使用断言、防御性编程、代码审查、正式验证等来编写具有健壮性和正确性的代码1.观察故障症状（内存转储、堆栈跟踪、执行日志、测试）2.识别潜在的故障（错误定位、调试）3.修复错误（代码修订） 2如何量度健壮性和正确性 外部观察角度：Meantimebetweenfailures平均失效间隔时间(MTBF)：系统运行过程中系统固有故障之间的预期运行时间。MTBF描述了可修复系统的两次故障之间的预期时间，而meantimetofailure平均故障时间(MTTF)表示不可修复系统的预期故障时间。内部观察角度：残余缺陷率：每千行代码中遗留的bug数量 3Java中的Error和Exception* 内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结果异常：程序的问题，可以捕获、可以处理 Error种类：用户输入错误、设备错误、物理限制大多数情况下，Error不需要被实例化注：本节了解一下就行 4异常处理* 使用try-catch结构异常：程序执行中的非正常时间，程序无法再按预想的流程执行 Exception会将错误信息传递给上层调用者，并报告”案发现场“的信息Exception可以是return之外的第二种退出途径-当找不到异常处理程序时，整个系统会完全退出 异常可以被分为RuntimeException和其他类型运行时异常：由程序员在代码中处理不当造成，是程序源代码中引入的故障造成的，如果在代码中提前进行验证，则这些故障就可以避免 其他异常：由外部原因造成，是程序员无法完全控制的外在问题所导致的，即使在代码中提前加以验证(文件是否存在等)，也无法完全避免失效发生 当异常产生时，要么异常处理程序处理了异常，要么会告诉编译器无法处理该异常，并在命令行中输出错误信息。编译器可以帮助检查程序是否已经抛出或处理了可能的异常。 Error和RuntimeException并不被编译器进行检查， RuntimeException不需要在编译时用trycatch等机制处理，但执行时可能会导致程序失败，代表程序中的潜在bug-类似动态检查 而其他Exception则必须捕获并指定错误处理程序，否则编译无法通过-类似静态类型检查 Java中异常处理的关键字：try、catch、finally、throws、throwthrows：表明方法会抛出XX异常throw：抛出XX异常try、catch、finally：捕获并处理XX异常 Unchecked异常也可以使用throws声明或try/catch进行捕获，但大多数时候是不需要的，也不应该这么做-掩耳盗铃，对发现的编程错误充耳不闻 如果客户端可以通过其他的方法恢复异常，那么采用checkedexception；如果客户端对出现的这种异常无能为力，那么采用uncheckedexception；异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息 “异常”也是方法和client端之间spec的一部分，在post-condition中刻画 对于checkedexception，需要在方法声明后加throwsXX异常程序员必须在方法的spec中明确写清本方法会抛出的所有checkedexception，以便于调用该方法的client加以处理而uncheckedexception则不需要 若一个程序内部某方法可能抛出某checkedexception，则要么它内部有该异常的处理程序，要么它也声明会抛出异常，将异常移交给调用它的方法处理。若没有处理程序来处理checkedexception，程序将终止运行 程序员不应抛出Error，Error通常只指虚拟机或动态库的错误 子类型多态相关：1.如果子类型中override了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更宽泛2.子类型方法可以抛出更具体的异常，也可以不抛出任何异常3.如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。 抛出异常方法：流程：1.找到到一个能表达错误的Exception类/或者构造一个新的Exception类2.构造Exception类的实例，将错误信息写入3.抛出它 一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码 构造异常类：对于checkedexception，只需要继承Exception类对于uncheckedexception，只需要继承RuntimeException类 异常处理程序：若某段代码中可能抛出异常，可以将这段代码包含在try代码块内，并使用catch捕获其抛出的各种异常。若在各catch代码段后有finally代码段，程序会在执行完catch代码段后执行finally代码段，另外，没有抛出异常时finally代码段也会被执行。 finally代码段通常用于清理异常发生前曾申请过的资源 重新抛出异常：catch代码段中也可以抛出异常目的：更改exception的类型，更方便客户端获取错误信息并处理调用栈追踪： 注：本节需要学会ava中的两类异常，并掌握他们区别，并掌握异常抛出、处理等相关代码的编写，还需要了解异常处理观察者控制的转移路径，以及异常导致程序退出时显示的的方法调用栈含义 5断言 断言：当不满足前提条件时，此代码通过抛出断言错误异常来终止程序。调用者的错误的影响无法传播。检查前置条件是防御式编程的一种典型形式 为什么要断言：在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误。 断言即是对代码中程序员所做假设的文档化，也不会影响运行时性能(在实际使用时，assertion都会被disabled)断言为了程序正确性，使用断言处理“绝不应该发生”的情况，如果来自于自己所写的其他代码，可以使用断言来帮助发现错误异常为了程序健壮性，使用异常来处理你“预料到可以发生”的不正常情况，如果参数来自于外部（不受自己控制），使用异常处理 6防御式编程 防御性编程是一种防御性设计的形式，旨在确保一块软件在不可预见的情况下的持续功能。 7SpotBugs工具 SpotBugs是一个使用静态分析来查找Java代码中的bug的程序 
第261篇文章[0]
软件构造复习笔记(2) 注：文章中带有*的标题表示往年考试中出现过相应考点 文章目录 第四章数据类型与类型检验1编程语言中的数据类型*2静态、动态类型检查*3可变性、不可变性*4Snapshotdiagram*5复杂数据类型-Arrays和Collections*6有用的不可变数据类型* 第五章设计规约1编程语言中的函数、方法*2规约：面向交流编程*假设规约行为等价性规约结构-前置条件和后置条件* 3设计规约*规约性质*规约图设计好的规约* 第六章抽象数据类型(ADT)1抽象与用户定义的类型2对类型和操作进行分类*3抽象数据类型例子4设计一个抽象类型*5表示独立性6对ADT的测试7不变量*8表示不变性和抽象函数*9有益的可变性10记录AF、RI、以及防止表示泄露的方法*11ADT不变量替代前置条件 第四章数据类型与类型检验 1编程语言中的数据类型* 基本数据类型：int、boolean等 对象数据类型：String、Integer等 注：本节简单看看就行了，考也是大题里穿插考 2静态、动态类型检查* 静态类型语言：在编译阶段进行类型检查动态类型语言：在运行阶段进行类型检查静态类型检查>>动态>>无检查 静态类型检查：可在编译阶段发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性 静态检查：关于“类型”的检查，不考虑值动态检查：关于“值”的检查 注：本节看一遍就行了，需要知道怎么找错，就考过选择， 3可变性、不可变性* 改变一个变量：将该变量指向另一个值的存储空间改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的值。 尽可能避免变化，以避免副作用 不变性：重要设计原则不变数据类型：一旦被创建，其值不能改变，使用final关键字修饰，如果是引用类型，也可以是不变的，即一旦确定其指向的对象，指向不能再被改变 如果编译器无法确定final变量不会改变，就提示错误，这也是静态类型检查的一部分。尽量使用final变量作为方法的输入参数、作为局部变量。 注意：1.final类无法派生子类2.final变量无法改变值/引用3.final方法无法被子类重写 不变对象：一旦被创建，始终指向同一个值/引用(这个对象内部的各个属性都不能修改)可变对象：拥有方法可以修改自己的值/引用 Immutable数据类型例子：StringString类型不可变，所以一个String对象在其生命周期中只能有一个值为了向一个String对象末尾添加元素，将重新创建一个新的String对象Mutable数据类型例子：StringBuilderStringBuilder有插入、删除、替代字符等方法修改对象内部的值因此它是可变数据类型String和StringBuilder区别：当只有一个引用指向该值时，没有区别有多个引用的时候，差异就出现了可变数据类型的优点：1.使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)2.可变类型最少化拷贝以提高效率3.使用可变数据类型，可获得更好的性能4.可变数据类型也适合于在多个模块之间共享数据 可变数据类型的风险：传递可变值时，函数可能超过spec的范畴，因为它可能会改变输入参数的值返回可变值时，后续对返回值的操作可能会影响全局变量的值 解决方案：1.通过防御式拷贝，给客户端返回一个副本2.安全地使用可变类型：局部变量，不会涉及共享；同一时间只有一个引用 注：本节需要掌握怎么区分可变和不可变数据类型，还得会画相应的snapshotdiagram 4Snapshotdiagram* 作用：用于描述程序运行时的内部状态 画法：注：本节经常在大题中考如何画snapshotdiagram，需要会画 5复杂数据类型-Arrays和Collections* 数组：数组定长，一旦被创建，其长度不可改变 列表：List是类型T的可变长序列 数组和List的迭代：集合：零个或多个唯一对象的无序集合映射：类似与字典，使用键值对存储，一个键只能对应一个值List、Set、Map都是接口，使用时需要用其具体实现类ArrayList、HashSet、HashMap等 迭代器：可变数据类型使用迭代器时，不可添加元素，若想删除元素，必须调用对应迭代器的remove方法。 注：本节是大题的基本知识，应该掌握 6有用的不可变数据类型* 基本类型及其封装对象类型都是不可变的 Collections类中有将可变Collections转化为不可变类型的方法：Collections.unmodifiableListCollections.unmodifiableSetCollections.unmodifiableMap其参数为要转化的Collection，这种包装器得到的结果是不可变的，只能看但是这种“不可变”是在运行阶段获得的，编译阶段无法据此进行静态检查 注：本节考过选择题，看看就行了 第五章设计规约 1编程语言中的函数、方法* 方法：参数类型是否匹配，在静态类型检查阶段完成返回值类型是否匹配，也在静态类型检查阶段完成 方法是程序的"积木"，可以被独立开发、测试、复用使用方法的客户端，无需了解方法内部具体如何工作-“抽象” 完整方法示例： 注：大题一定会考写方法，学过编程语言的应该都会，看看就行了 2规约：面向交流编程* 例子，JAVAAPI文档： 假设 把对某个变量所做出的假设写下来，例如，假定某一变量必须指向Integerfinal关键字也算假设，它定义了不可改变的设计决策 为什么要写出假设？一，自己记不住二，别人看不懂 代码中蕴含的“设计决策”-给编译器读注释形式的“设计决策”-给自己和别人读 规约 没规约，没法写程序，即使写出来，也不知道对错规约也是程序与客户端之间达成的一致Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守 很多bug来自于双方间的误解不写下来，那么不同开发者的理解可能就不同没有规约，难以定位错误 规约优点：1.精确的规约，有助于区分责任2.客户端无需阅读调用函数的代码，只需理解spec即可 例子：规约可以隔离“变化”，无需通知客户端规约也可以提高代码效率规约也扮演了用户和实现者之间的防火墙，用户不需要了解具体实现 规约只讲“能做什么”，不讲“怎么实现” 行为等价性 行为等价性：两个事物是否可以相互替换要站在客户端的视角看待行为等价性 根据规约判断是否行为等价，如果两个函数符合这个规约，那他们对于这个规约而言就等价 规约结构-前置条件和后置条件* 前置条件：对客户端的约束，在使用方法时必须满足的条件后置条件：对开发者的约束，方法结束时必须满足的条件契约：如果前置条件满足了，后置条件必须满足，若前置条件不满足，则方法可以做任何事情 静态类型声明是一种规约，可据此进行静态类型检查。方法前的注释也是一种规约，但需人工判定其是否满足 除非在后置条件里声明过，否则方法内部不应该改变输入参数应尽量遵循此规则，尽量不设计mutating的spec，否则容易引发bug原因：程序中可以有多个变量指向用一个可变对象(别名)，无法强迫类的实现体和客户端不保存可变变量的别名 注：本节只需要看一遍就行，可能考选择 3设计规约* 规约性质* 规约的三条性质：确定性、陈述性、强度 强度： 当规约S2相比S1的前置条件更弱，后置条件更强时，则称规约S2的强度强于S1，就可以用S2替代S1Spec变强：更放松的前置条件+更严格的后置条件 例子：确定性：明确的规约：给定一个满足前置条件的输入，其输出是唯一的、明确的欠定的规约：同一个输入可以有多个输出非确定的规约：同一个输入，多次执行时得到的输出可能不同欠定通常可认为等价于非确定，但欠定的规约通常有确定的实现 陈述性：操作式规约：给出方法进行的一系列步骤，例如伪代码声明式规约：没有内部实现的描述，只有“初-终”状态声明式规约更有价值，通常不使用操作式规约，内部实现的细节通常放在实现体内部注释中 规约图 设计好的规约* 好的规约应该易于阅读，应该有以下几个性质：1.内聚的：Spec描述的功能应单一、简单、易理解2.信息丰富的：不能让客户端产生理解的歧义3.足够健壮的：开发者应尽可能考虑各种特殊情况，在后置条件中给出处理措施4.足够虚弱的：太强的spec在很多特殊情况下难以达到，给开发者增加了实现的难度5.使用抽象类型：在规约里使用抽象类型，可以给方法的实现体与客户端更大的自由度6.前置后置条件选取：*注：本节主要需要重点掌握怎么写spec以及spec的前置、后置条件强度的比较等* 第六章抽象数据类型(ADT) 1抽象与用户定义的类型 除了编程语言所提供的基本数据类型和对象数据类型，程序员可定义自己的数据类型 数据抽象：由一组操作所刻画的数据结构，而非传统意义上关注数据的具体表示 抽象类型：强调“作用于数据上的操作”，程序员和客户端无需关心数据如何具体存储，只需设计/使用操作即可。 一个抽象数据类型由它的操作所定义，与其内部实现无关 2对类型和操作进行分类* 对类型的分类：可变类型的对象：提供了可改变其内部数据的值的操作不可变数据类型：其操作不改变内部值，而是构造新的对象 对操作的分类：构造器(Creator)：创造ADT的新对象生产器(Producer)：提供ADT以前的对象创造新的对象观察器(Observer)：获取抽象类型的对象，并返回不同类型的对象变值器(Mutator)：改变对象属性的方法 构造器可能实现为构造函数或静态函数，实施为静态函数的通常被称作工厂方法变值器通常返回void，如果返回值为void，则必然意味着它改变了对象的某些内部状态变值器也可能返回非空类型，例如返回boolean，判断操作是否成功 注：本节需要掌握如何判断某一方法有可能属于哪种，建议关注一下静态工厂方法 3抽象数据类型例子 4设计一个抽象类型* 设计好的ADT，靠“经验法则”，提供一组操作，设计其行为规约spec 以下是几个设计规则：1.设计简洁、一致的操作2.要足以支持客户端对数据所做的所有操作需要，且用操作满足客户端需要的难度要低3.要么抽象、要么具体，不要混合-要么针对抽象设计，要么针对具体应用的设计 注：本节内容理解就行，考试必考ADT设计 5表示独立性 表示独立性(RI)：客户端使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端 除非ADT的操作指明了具体的前置和后置条件，否则不能改变ADT的内部表示-spec规定了客户端和实现者之间的契约 6对ADT的测试 测试creators,producers,andmutators：调用observers来观察这些operations的结果是否满足spec；测试observers：调用creators,producers,andmutators等方法产生或改变对象，来看结果是否正确。风险：如果被依赖的其他方法有错误，可能导致被测试方法的测试结果失效。 7不变量* 不变量(invariants)：在任何时候都是true由ADT来负责其不变量，与client端的任何行为无关 为什么需要不变量：保持程序的“正确性”，容易发现错误 总是要假设客户端有“恶意”破坏ADT的不变量除非迫不得已，否则不要把希望寄托于客户端上，ADT有责任保证自己的invariants，并避免“表示泄露”。 最好的办法就是使用immutable的类型，彻底避免表示泄露 保持不变性和避免表示泄漏，是ADT最重要的一个Invariant！ 注：本节简单理解一下就行了 8表示不变性和抽象函数* 抽象值构成的空间：用户端看到和使用的值 ADT开发者关注表示空间R，client关注抽象空间A 抽象函数：R和A之间映射关系的函数，即如何去解释R中每一个值为A中的每一个值抽象函数性质：1.满射：每一个抽象值都必须被某个表示值所映射2.未必单射：某个抽象值可能由超过一个表示值映射3.未必双射：不是所有表示值都需要有映射，R中部分值并非合法的，在A中无映射值 RI:R→boolean表示不变性(RI通常指的是这个)：某个具体的“表示”是否是“合法的”也可以将RI看作：所有表示值的一个子集，包含了所有合法的表示值也可将RI看作：一个条件，描述了什么是“合法”的表示值 RI和AF都是作为注释写在代码中的，通常写在rep下方 不同的内部表示，需要设计不同的AF和RI，即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。 编写过程：选择某种特定的表示方式R，进而指定某个子集是“合法”的(RI)，并为该子集中的每个值做出“解释”(AF) 即如何映射到抽象空间中的值。 在实现中通常有一个checkRep方法，在所有可能改变rep的方法内检查RI是否被满足 注：本节比较重要，需要理解 9有益的可变性 对immutable的ADT来说，它在A空间的abstractvalue应是不变的，但其内部表示的R空间中的取值则可以是变化的。 这种mutation只是改变了R值，并未改变A值，对client来说，是immutable的“AF并非单射”，从一个R值变成了另一个R值 但这并不代表在immutable的类中就可以随意出现mutator！ 10记录AF、RI、以及防止表示泄露的方法* 在代码中用注释形式记录AF和RI以及防止表示泄露的方法，其内容是客户端不可见的 要精确的记录RI：rep中的所有fields何为有效要精确记录AF：如何解释每一个R值 表示泄漏的安全声明：给出理由，证明代码并未对外泄露其内部表示 自证清白 具体措施：ADT的规约里只能使用client可见的内容来撰写，包括参数、返回值、异常等。如果规约里需要提及“值”，只能使用A空间中的“值“。ADT的规约里也不应谈及任何内部表示的细节，以及R空间中的任何值ADT的内部表示(私有属性)对外部都应严格不可见 表示泄漏的风险：一旦泄露，ADT内部表示可能会在程序的任何位置发生改变（而不是限制在ADT内部），从而无法确保ADT的不变量是否能够始终保持为true。 导致表示泄露的代码：1.直接将内部rep的别名作为返回值输出2.直接用rep作为外部可变对象的别名3.内部rep未用private修饰 如何构建不变性：1.在对象的初始状态不变量为true，在对象发生变化时，不变量也要为true2.构造器和生产器在创建对象时要确保不变量为true3.变值器和观察器在执行时必须保持不变性4.在每个方法return之前，用checkRep()检查不变量是否得以保持。 注：本节内容需要会读AF/RI，并会判断什么情况下RI可能不满足，以及知道哪些行为会导致表示泄露 11ADT不变量替代前置条件 用ADT不变量取代复杂的Precondition，相当于将复杂的precondition封装到了ADT内部。 
第262篇文章[0]
从C语言到Java学习过程（1） 从C语言到Java学习过程（1） 文章目录 从C语言到Java学习过程（1）前言一.Helloworld1.代码2.编译、运行3.个人总结 二.基本知识1.基本数据类型(1)基本介绍(2)类型转换(3)常量声明 2.选择语句3.循环语句 小结 前言 本人由于课程需要使用java语言，而之前对于该语言并不是很熟悉，但在大一的课程上简单的学习过一些C语言的知识，对编程语言方面并不算毫无基础。这篇及以后可能写的几篇博客算是记载一下我个人的Java学习过程吧，也希望能给以后的读者(如果有的话)一些帮助吧。 一.Helloworld 所有语言的学习一般都是从写Helloworld程序开始的吧，所以我打算先写个Java版的Helloworld程序并拿来和C语言的比较一下。 1.代码 下面是C语言的Helloworld，文件名记为Helloworld.c，代码如下： #include<stdio.h> intmain(intargc,char**argv) { printf("Helloworld\n"); return0; } 下面是Java语言的Helloworld，文件名记为Helloworld.java，代码如下： publicclassHelloworld{ publicstaticvoidmain(String[]args){ System.out.println("Helloworld"); } } 2.编译、运行 C语言和Java语言均属于静态编译语言，所以想要运行两者都需要进行编译。 对于C程序，使用gcc编译，可以在命令行中输入如下指令： gccHelloworld.c-oHelloworld.exe 可以得到程序的exe文件，在命令行中输入 ./Helloworld.exe 即可运行，效果为在命令行中输出Helloworld字样 对于JAVA语言，可以使用javac进行编译，在命令行中输入 javacHelloworld.java 可以得到Helloworld.class文件，在命令行中输入 javaHelloworld 即可运行，效果与C语言程序相同。 注：javac命令需要安装jdk才能使用，而gcc编译器一般linux自带，在windows下可以通过安装mingw获取gcc编译器。具体安装过程网上有的是，这里不再赘述。 两者都需要将其对应可执行程序所在目录设置为环境变量时，才能直接在命令行中使用。 3.个人总结 Java和C语言最大的差别就是java是一个彻底的面向对象的语言，也就是说，程序的一切行为都是以类为基础的，不可以有单独存在的方法(函数)与属性(变量)，所以main函数的外面需要套在一个class的代码块中。 而且一般来说，Java文件的名字应该与其主类名称相同(这里为Helloworld)。除此之外，每个java类中都可以有一个main方法，且当将这个类被编译为.class文件时，并直接通过java命令运行时，运行的就是这个类中的main方法。 另外，关于库调用方面，C语言是通过引入头文件的形式得以调用函数库中的已有函数，而java则是通过引入其他包来调用其他文件中的类及其各种方法(System类属于Java默认调用的包，不需要特意进行引入)。 二.基本知识 Java中的许多初学者基础知识和C语言及其相似，以下是个人学习过程中的一些总结。 1.基本数据类型 (1)基本介绍 Java和C都有char、short、int、long、float、double这几个数据类型，不同的是，Java中还有boolean类型用以表示布尔值，以及byte类型用于单独表示一个字节，而C语言中有指针类型和longlong与longdouble(后两种并不常见)。 数据类型java中所占字节数C语言中所占字节数byte1\char21short22int44long84/8longlong\8float44double88longdouble\8/12/16bollean不明\void*\4/8 java中的char类型存储字符的unicode编码，而C语言中的char存储的是ASCII码，另外，java通过使用byte表示占用一个字节的值，而C语言往往使用signedchar来表示一个字节的值。 关于short、int、long、float、double等数据类型的使用场合，Java和C一般相同，java的long类型相比于C语言的更加确定，相当于longlong类型。 C语言中通常使用int类型表示布尔值，为0表示false，为其他任意非0值时表示true。而Java中则用boolean类型来表示布尔值，且只有true和false两种取值。 至于C语言中的指针，个人认为Java中与其对应的为各种引用数据类型，不同的是，指针可以直接进行各种操作，而Java中对引用数据类型的操作则受到各种限制。 指针可以使程序的编写过程更加灵活，但也可能因为程序员水平不高导致潜在风险，但无论如何指针都是C语言的精髓。至于引用数据类型的细节后面再说吧。 (2)类型转换 Java的类型转换与C语言差不多，分为自动(隐式)类型转换和强制类型转换。隐式类型转换发生在小数据类型与大数据类型进行运算以及整数数据类型与浮点数据类型运算的时候，这里不再赘述。需要注意，整数的默认类型为int，浮点数的默认类型为double，若要声明float类型的浮点数，需要在后面加f或者F。 强制类型转换方面，两者也差不多，通常发生在将大的数据类型转换为小的数据类型以及浮点数转换为整数的时候。需要注意的是，通常强制类型转换会导致数据精度损失以及数据溢出，且浮点数转换为整数并不是四舍五入，而是抛弃小数位。 boolean类型不可进行类型转换。 注：上面的强制类型转换仅局限于对基本数据类型进行操作，暂时不包括引用数据类型。 (3)常量声明 在C语言中，常量包括宏常量和const常量两种，前者通过在预编译阶段直接替换实现，后者通过存储在只读数据段中实现，具体实例如下： #defineX100//定义一个表示100的宏常量 constinty=100;//定义一个表示100的const常量 而Java中通过使用final关键字，其实现细节暂时不清楚，个人认为和C语言的const常量类似。实例如下： finalintz=100;//定义一个表示100的常量 2.选择语句 选择语句没什么说的，C语言和Java都是下列格式 if(条件1为真){   } elseif(条件2为真){ }   elseif(条件n为真){   } else{   } 这里不做过多解释。 3.循环语句 C语言中的三种循环方法java均可以使用，具体如下： for(循环初始化;循环条件1;循环迭代表达式){   } while(循环条件2){   } do{   }while(循环条件3) 上述三种循环方法这里不做过多解释。 另外Java中还提供了加强型for循环(foreach循环)，实例如下： int[]intArray={ }; for(inti:intArray){   } 注：其中数组可以替换为任何实现了iterable接口的类(具体后面再说吧)。 小结 今天写了不少，感觉没太大错误，之后有时间再写，但毕竟本人还是个新手，难免出错，要是有什么错误，希望读者能在评论区不吝赐教。 
第263篇文章[0]
软件构造学习笔记2（Delegation委派） 目录 软件构造学习笔记 前言 一、什么是Delegation（委派） 二、不同类型的委派 1.Dependency:临时性的delegation 2.Association:永久性的delegation 3.Composition:更强的association，但难以变化 4.Aggregation:更弱的association，可动态变化 三、总结 1.委派过程 2.委派与继承 前言 学习委派机制（Delegation）时遇到一些困惑，因此查阅相关资料，结合课件和课堂笔记整理一下知识点。以下内容是个人理解，如果有不正确的地方欢迎大家指出。 一、什么是Delegation（委派） 委派：一个对象请求另一个对象的功能，于是捕获操作并发送给另一对象，进行功能调用。是复用的一种常见形式。 与继承（Inheritance）的区别：“委托”发生在object层面，运行时建立联系，而“继承”发生在class层面 二、不同类型的委派 Use(AuseB) Association(AhasB) Composition/aggregation(AownsB) 1.Dependency:临时性的delegation 两个类之间的这种暂时性的关系叫做“use-a"关系。 以下面的代码为例，Duckd想要请求FlyWithWingsf的功能，实现fly方法，在临时性的委派关系中，不需要将委托对象f存储为Duck类中的字段，只需在d.fly(f)中动态传入f，并在fly方法中通过f.fly()完成实际调用。 publicclassFlyWithWingsimplementsFlyable{ @Override publicvoidfly(){ System.out.println("Wings"); } } classDuck{ //不需要将委托的类存储为Duck类中的字段 voidfly(Flyablef){ f.fly(); } } Flyablef=newFlyWithWings(); Duckd=newDuck(); d.fly(f);//将f动态传入d中 2.Association:永久性的delegation 这是类之间的永久关系，属于has-a的关系。这种关系允许一个对象实例a让另一个对象实例b为它自己做事。 这种关系是结构化的，它指定了一种对象与另一种对象相关联，不指定行为。可以将下面的Composition/Aggregation看作是Association的两种具体形态。 classDuck{ FlyWithWingsf; //  } 3.Composition:更强的association，但难以变化 这种关系是”a-part-of“关系，一个类将另一个类作为属性或实例变量 classFlyWithWingsimplementsFlyable{ @Override publicvoidfly(){ System.out.println("flywithwings"); } } classDuck{ Flyablef=newFlyWithWings();//一个类把另一个类作为自己的属性或实例变量 voidfly(){ f.fly(); } } Duckd=newDuck(); d.fly(); 这种关系中，若对象d销毁了，则委派对象f也没有了存在的意义 4.Aggregation:更弱的association，可动态变化 这种关系是“has-a”的关系 以下面的代码为例，将另一个外部对象f，以参数形式传递给Duck类中的构造方法或其他特定方法（如本例中的setBehavior方法） publicclassCannotFlyimplementsFlyable{ @Override publicvoidfly(){ System.out.println("Cannotfly"); } } classDuck{ Flyablef; Duck(Flyablef){ this.f=f; } voidsetFlyBehavior(Flyablef){ this.f=f; } voidfly(){ f.fly(); } } 这种类型与Composition的不同在于： 1.委托的对象可以动态变化，例如运行下面这段代码 Flyablef=newFlyWithWings(); Duckd=newDuck(f);//将另一个外部对象f，以参数形式传递给Duck类的构造方法 d.fly(); Flyablef2=newCannotFly(); d.setFlyBehavior(f2);//委托的对象可以动态改变 d.fly(); 输出结果为 2.对象d销毁后，对象f和f2依然可以独立存在 三、总结 1.委派过程 通过以上分析，委派过程可以大致总结为以下三步： 1.建立委派 classDuck{ //Flyablef;//可以将委托对象f存储在rep中，也可以不存储 voidfly(){//运行时建立关系 f.fly(); } } 2.动态传入 Duckd=newDuck(f);//将另一个外部对象f，以参数形式传递给Duck类的构造方法 d.setFlyBehavior(f);//或传入其他特定方法 3.实际调用 d.fly(); 2.委派与继承 “委托”发生在object层面，而“继承”发生在class层面。如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，从而避免大量无用的方法。 例如在上述开发场景中，fly的具体实现可以有很多种（如FlyWithWings,CanNotFly)，且Duck中的fly方式也有可能发生变化，因此设计时如果设计成DuckextendsFlyableAnimal将会造成很多不便，而使用委派机制更加合适，更加灵活。 
第264篇文章[0]
软件构造学习4（以ArrayList和LinkedList为例理解表示独立性repindependence) 目录 一、什么是表示独立性（RepresentationIndependence） 二、以List为例 1.ArrayList 2.LinkedList 3.总结 三、表示独立性的重要性 一、什么是表示独立性（RepresentationIndependence） 表示独立性：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端（除非ADT的操作指明了具体的pre-和post-condition，否则不能改变ADT的内部表示） 二、以List为例 List接口继承collection接口，添加了插入、删除、查找等方法。其实现有两种，但List提供的操作表现的内容与其用LinkedList还是Array无关 Eget(intindex); Eset(intindex,Eelement); voidadd(intindex,Eelement); Eremove(intindex); intindexOf(Objecto); intlastIndexOf(Objecto); ListIterator<E>listIterator(); ListIterator<E>listIterator(intindex); List<E>subList(intfromIndex,inttoIndex); 1.ArrayList 内部表示如下，可以看到使用了数组实现 privatetransientObject[]elementData;//支撑数组 privateintsize; 当增加元素到列表结尾时，实现如下 publicbooleanadd(Ee){ ensureCapacityInternal(size+1);//确保内部数组有足够的空间 elementData[size++]=e;//将元素加入到数组的末尾 returntrue; } 可以看到如果ArrayList容量满足需求时，add()其实就是直接对数组进行赋值，因此性能很高。 2.LinkedList 内部表示如下，使用了双向链表数据结构 privatetransientEntry<E>header=newEntry<E>(null,null,null); privatetransientintsize=0; 当增加元素到列表结尾时，实现如下 voidlinkLast(Ee){ finalNode<E>l=last; //构建一个新节点newNode finalNode<E>newNode=newNode<>(l,e,null); //将newNode作为尾节点 last=newNode; if(l==null) first=newNode; else l.next=newNode; size++; modCount++; } LinkedList由于使用了链表结构，每次元素的增加都需要新建一个node对象，并进行插入操作，很多情况下会对性能会有所影响。 3.总结 可以看到，不同的内部表示会影响方法的性能，但是client使用List时无需考虑其内部如何实现，使用时都是通过list.add(),list.remove()等进行操作，与其用LinkedList还是Array无关。 三、表示独立性的重要性 下面的代码是一个破坏了表示独立性的例子 /** *Representsafamilythatlivesinahouseholdtogether. *Afamilyalwayshasatleastonepersoninit. *Familiesaremutable. */ classFamily{ publicList<Person>people; publicList<Person>getMembers(){ returnpeople; } } 在Family类中使用的内部表示是List<Person>，当客户端使用下面的方式访问家庭成员时，就破坏了表示独立性 voidclient1(Familyf){ Personbaby=f.people.get(f.people.size()-1);   } } 当Family中修改代码，将内部表示改变为Set<Person>后， classFamily{ Set<Person>p; List<Person>getMembers(){ returnnewArrayList<>(p); } } 客户端的代码就不能适应变化。但是根据表示独立性，ADT内部表示的变化不应影响外部spec和客户端，因此正确的实现应该如下 voidclient2(Familyf){ Personanybody=f.getMember().get(0);   } } 
第265篇文章[0]
java设计模式--对象适配器模式 目录 一、适配器模式（AdapterPattern)的思想 二、适配器模式中的三个角色 三、对象适配器模式 总结 适配器模式的优点 一、适配器模式（AdapterPattern)的思想 思想：把一个类/接口转换为客户端期望的形式。 这样做的好处： 1.使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 2.通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。 二、适配器模式中的三个角色 目标(Target):客户端期待得到的接口。源(Adaptee):需要被适配的接口。适配器(Adapter)：连接目标和源，把源接口转换成期待的目标接口。 适配器模式包括3种形式：类适配器模式、对象适配器模式、接口适配器模式。本文主要介绍对象适配器。 三、对象适配器模式 在对象适配器模式中，目标ITarget是一个与客户端需求匹配的接口，适配器Adapter和源Adaptee之间是委派关系（delegation）。 以下面的代码为例： 客户端想调用LegacyRectangle中的方法，画出一个长方形。这个例子中LegacyRectangle类就是源。但是客户端想要传入的是左上角的顶点和右下角的顶点，而源Adaptee中的方法需要的参数是左上角的顶点，以及宽和高，出现了不适配。 classClient{ publicdisplay(){ newLegacyRectangle().display(x1,y1,x2,y2);//客户端想要传入左上角的顶点和右下角的顶点 } } classLegacyRectangle{ voiddisplay(intx1,inty1,intw,inth){  //源Adaptee中的方法需要的参数是左上角的顶点，以及宽和高 } } 此时通过对象适配器模式，先增加一个接口shape，这个接口与客户端的要求适配。（客户端对抽象接口编程，与LegacyRectangle隔离） interfaceShape { voiddisplay(intx1,inty1,intx2,inty2); } 再用一个Rectangle类实现shape接口，此时Rectangle充当的是Adapter的角色，通过与LegacyRectangle类建立委派关系完成display方法的实现。 classRectangleimplementsShape{ voiddisplay(intx1,inty1,intx2,inty2){ newLegacyRectangle().display(x1,y1,x2-x1,y2-y1);//通过委派完成display } } 此时客户端的代码实现如下： classClient{ Shapeshape=newRectangle();//客户端对抽象接口编程，与LegacyRectangle隔离 publicdisplay(){ shape.display(x1,y1,x2,y2); } } 可以看到，通过适配器Rectangle,解决了LegacyRectangle与客户端期望形式不匹配的问题，实现了代码的复用。 总结 适配器模式的优点 代码复用：使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。可以复用已经实现的类的功能。 封装：通过增加一个接口，将已存在的子类封装起来，客户端面向接口编程，从而隐藏了具体子类。 
第266篇文章[0]
软件构造（规约的强弱） 目录 一、什么是规约（spec) 二、规约的强弱 1.以下面的代码为例 2.Note 一、什么是规约（spec) 规约是写在方法前面的注释，用来解释方法的功能、参数、返回值等 为什么要为每个方法写规约？ 1.精确的规约，有助于区分责任 2.客户端无需阅读调用函数的代码，只需理解spec即可 3.规约可以隔离“变化”，无需通知客户端 规约的结构： 1.对方法的解释 2.前置条件：对客户端的约束，在使用方法时必须满足的条件 3.后置条件：对开发者的约束，方法结束时必须满足的条件 二、规约的强弱 定义：规格说明S2强于（等于）规格说明S1，如果： S2的前置条件弱于或等价于S1的S2的后置条件强于或等于S1的后置条件。 即：spec变强意味着更放松的前置条件+更严格的后置条件 1.以下面的代码为例 版本1中，对find方法的规约中，前置条件中规定val在数组a中出现有且仅有一次 再看版本2 此时前置条件规定val应该出现至少一次，因此前置条件变弱了，所以spec更强了 再看版本3 和版本2比，在满足前置条件的情况下，后置条件变强了，所以spec更强了 2.Note 需要注意的是，两个specS1和S2比较时，一定要在满足前置条件的情况下比较后置条件的强弱 看下面这个例子 单看后置条件，S2的后置条件比S1更强，但是在满足S1的前置条件，即满足val在数组a中至少出现一次的条件时，其实S2的后置条件与S1相比并没有变化。前置条件更弱，后置条件不变，因此S2比S1更弱了。 
第267篇文章[0]
Java中的等价性 目录 一、相等（Equality） 二、==与equals() 1.== 2.equals 3.总结 三、不可变类型的等价性 总结 一、相等（Equality） 我们可以从三个角度来看待ADT中的相等： 1.从ADT中的抽象函数AF（abstractfunction）：如果AF(a)=AF(b)，我们就说a和b相等。 2.从关系的角度 等价关系是指对于关系E⊆TxT，它满足： 自反性:E(t,t)∀t∈T对称性:E(t,u)⇒E(u,t)传递性:E(t,u)∧E(u,v)⇒E(t,v) 3.从外部观察者角度：对两个对象调用任何相同的操作，都会得到相同的结果，则认为这两个对象是等价的。 二、==与equals() Java有两种判断相等的操作：==和equals 1.== ==比较的是引用，也就是说，测试的是引用等价性。如果两个索引指向同一块存储区域，那它们就是==的。 2.equals equals()操作比较对象内容，也就是测试的是对象等价性。 在自定义ADT时，需要重写Object的equals() 3.总结 使用： 对基本数据类型，使用==判定相等 对对象类型，使用equals()。如果用==，是在判断两个对象身份标识ID是否相等（即是否指向内存里的同一段空间） 三、不可变类型的等价性 在Object中实现的缺省equals()是在判断引用等价性，实现如下 publicclassObject{   publicbooleanequals(Objectthat){ returnthis==that; } } 重写与重载 在方法签名中犯一个错误很容易，并且当您打算覆盖它时重载一个方法。只要你的意图是在你的超类中重写一个方法，就应该使用Java的批注@Override。通过这个注解，Java编译器将检查超类中是否存在具有相同签名的方法，如果签名中出现错误，则会给出编译器错误。 总结 相等应该满足等价关系（自反、对称、传递）。相等和哈希必须互相一致，以便让使用哈希表的数据结构（例如 HashSet 和 HashMap）正常工作。抽象函数是不可变类型相等的比较基础。索引是可变类型相等的比较基础。这也是确保相等一致性和保护哈希表不变量的唯一方法。 
第268篇文章[0]
软件构造 关于RI与AF 1.基本概念 以PPT为依据整理一下主要概念：表示独立性（Representationindependent）：client使用ADT时无需考虑其内部如何实现，ADT内部的变化不应影响外部spec和客户端。不变量（Invariant）：程序的一个属性，对于程序的每一个可能的运行时状态，它总是为真。例如：immutability就是一个典型的“不变量”。表示域（R）：包含的是值具体的实现实体的空间。一般情况下ADT的表示比较简单，有些时候需要复杂表示。抽象域（A）：包含的是类型设计时支持使用的值的空间。这些值是由表示域“抽象/想象”出来的，也是使用者关注的。抽象函数（Abstractionfunction）：R和A之间映射关系的函数。AF：R→A表示不变量（Repinvariant）：将表示空间的值映射到布尔值。RI:R→booleanSafetyfromRepExposure：防止表示泄露的方法 2.实际运用 在代码编写中，我们一般会在一个Class开头写下注释，内容包含：AF，RI和SafetyfromRepExposure。以下面的代码为例：可以看到，在开头的注释里就包含了这三部分。其中，AF就是说明将一个抽象的东西，表示成程序可以表示的东西。在这里，我们将一张图G表示为G中所有的点v的集合。RI就是对所有表示值的一个子集，包含了所有合法的表示值。也可以看做：一个条件，描述了什么是“合法”的表示值。在这里，我们对所有点v做出了要求。SafetyfromRepExposure就是对安全性的策略。在这里，我们保证所有field都是private，每个method返回的都是变量的赋值，点的元素都是immutable的。 3.保护不变量 如何保护表示不变量呢，一般情况下有如下几种做法： 通过私有变量来保护通过防御式拷贝防止泄露写规格说明（通常无用）使用Collections.unmodifiableList()这类方法来返回不变量 
第269篇文章[0]
软件构造 关于等价性 关于等价性 在学到ADT的等价性的时候，有三条基本原则，即：自反、传递、对称。其中，自反和对称往往是满足的，但传递常常出现一些问题。比如，在课堂上就出现了这样一个例子： 显然，这个equals()不满足于传递性，问题就出现所谓的误差值CLOCK_SKEW上。由于误差值在传递的过程中会不断累加，从而导致了最终超过可容忍的误差值的情况。 但这种设置误差值的方法是经常使用的，比如在ACM的很多计算几何题目中，就大量采用了误差值的方法。以二维为例：设一个误差值eps（通常很小），对两点A(x1,y1)和B(x2,y2)，当这两点间距离 d i s ( A , B ) = ( x 1 − x 2 ) 2 + ( y 1 − y 2 ) 2 ≤ e p s dis(A,B)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}\leqeps dis(A,B)=(x1​−x2​)2+(y1​−y2​)2 ​≤eps时，将A与B视为同一点。 这个方法是非常实用的，因为它很好地解决了计算机浮点运算中精度误差的问题。但这样的代价就是破坏了等价关系的传递性。 从某种意义上来说，我们经常不得不对程序的实用性与准确性进行取舍，这一点在等价性关系上展现得很好。 解决方案 那么，有没有既满足实用性，又满足等价性的解决方案呢？我有一个初步的想法。以一维线段为例：设左端点为0，右端点为10。将其等距地划分为n段，则每个区间形成了一个等价类。 equals(A,B)：当A和B在同一个区间内时，认为A和B是等价的。否则A和B不等价。 显然，这个equals()是满足等价性的三个原则的：A与B等价，B与C等价，则说明ABC在同一组内，那么A与C等价。这个equals()是运用了分块算法的想法：块内统一管理。但面对块间的情况时，equals()就不能发挥作用了：只要A与B在不同的块内，哪怕 d i s ( A , B ) ≤ e s p dis(A,B)\leqesp dis(A,B)≤esp，A与B也不等价。这就是对实用性的牺牲。同时，我们发现n要尽量的大。上图中分别为n=2和n=5的情况，显然n=5的情况中equals()更为精准，不容易出现跨块的情况。 改进方案 正如数学上的插值法所说明的：当等距的方法到达瓶颈后，不妨试一下不等距的情况。由于我们开发的是软件，面对的是实际情况的数据，而实际情况的数据又一般具有一些规律，如：符合正态分布。因此我们可以根据数据的分布情况来改变分块的策略。不妨假设输入数据满足正态分布：对上图进行改造：可以看到2、3两条线段中都是n=5，但是由于数据常常出现在中间部分，两头的数据会较少，因此线段3改变了策略，将端点设置在了{1,2,8,9}。 
第270篇文章[0]
软件构造 关于面向对象设计原则 1.五大原则 我们在学习面向可维护性的构造技术时，学习了面向对象设计的五大原则，掌握这些原则能帮助我们更好的理解面向对象的概念，也能更好的理解设计模式。 2.SRP单一责任原则 不应该有多于1个原因让你的ADT发生变化，否则就拆分开。 单一职责原则的优点： 类的复杂性降低，实现什么职责都有明确的定义；逻辑变得简单，类的可读性提高了，而且，因为逻辑简单，代码的可维护性也提高了；变更的风险降低，因为只会在单一的类中的修改。 3.OCP开放-封闭原则 分为两部分。 对扩展性的开放：模块的行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化。对修改的封闭：模块自身的代码是不应被修改的，扩展模块行为的一般途径是修改模块的内部实现，如果一个模块不能被修改，那么它通常被认为是具有固定的行为。 4.LSPLiskov替换原则 子类型必须能够替换其基类型，派生类必须能够通过其基类的接口使用，客户端无需了解二者之间的差异。简单概括：只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何异常。但是反过来就不行了，因为子类可以扩展父类没有的功能，同时子类还不能改变父类原有的功能。具体来说： 子类型可以增加方法，但不可删除。子类型需要实现抽象类型中的所有未实现方法。子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance的参数。子类型中重写的方法必须使用同样类型的参数或者符合contra-variance的参数。子类型中重写的方法不能抛出额外的异常。 5.ISP接口隔离原则 不能强迫客户端依赖于它们不需要的接口：只提供必需的接口。意思就是客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，这就需要对接口进行细化，保证接口的纯洁性。换成另一种说法就是，类间的依赖关系应该建立在最小的接口上，也就是建立单一的接口。 6.DIP依赖转置原则 抽象的模块不应依赖于具体的模块，具体应依赖于抽象。在Java语言中，抽象就是指接口或抽象类，两者都不能被实例化；而细节就是实现接口或继承抽象类产生的类，也就是可以被实例化的实现类。依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的，这就是俗称的面向接口编程。 
第271篇文章[0]
软件构造 关于设计模式 1.设计模式 在软件构造的学习中，我们学习了几种设计模式，这里做出一个汇总和分类。 创建型模式结构型模式行为类模式 2.创建型模式 (1).工厂方法模式 当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 3.结构型模式 (1).适配器模式 将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。 (2).装饰器模式 装饰者模式用每个子类实现不同的特性，在我们需要大量有重复属性但是同时又有特定属性的时候，使用单纯地继承委托等方法可能会造成组合爆炸、大量代码重复等等问题。而装饰器模式能很好地解决这个问题。其问题是为对象增加不同侧面的特性，解决方式是对每一个特性构造子类，通过委派机制增加到对象上，其工作原理是以递归的方式实现，接口：定义装饰物执行的公共操作，起始对象，在其基础上增加功能(装饰)，将通用的方法放到此对象中。Decorator抽象类是所有装饰类的基类，里面包含的成员变量component指向了被装饰的对象。 3.行为类模式 (1).策略模式 有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。 (2).模板模式 有些问题做事情的步骤一样，但具体方法不同。共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。 (3).迭代器模式 客户端希望遍历被放入容器/集合类的一组ADT对象，无需关心容器的具体类型。也就是说，不管对象被放进哪里，都应该提供同样的遍历方式。Iteratorpattern：让自己的集合类实现Iterable接口，并实现自己的独特Iterator迭代器(hasNext,next,remove)，允许客户端利用这个迭代器进行显式或隐式的迭代遍历。 (4).访问者模式 对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。本质上：将数据和作用于数据上的某种/些特定操作分离开来。为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT。 
第272篇文章[0]
软件构造 关于mutable与immutable 1.immutable与mutable类的定义 mutable类：定义比较简单，创建之后，该对象拥有可以更改其值/引用的方法 immutable类：immutable类是指这个类的实例一旦创建完成后，就不能改变其成员变量值，也就是不能改变对象的状态。首先，类需要声明为final，保证其不可以被继承,所有成员变量定义为privatefinal,不提供改变成员变量的Mutators方法，通过构造器初始化成员变量，如果构造器传入了引用数据类型需要进行防御式拷贝。 2.Java中常见的mutable和immutable类 常见的immutable类 String：一个String总是表示一个相同的字符串。由于String是immutable的，一旦创建，一个String类总是含有相同的值。想要改变值，java会创建一个新的String类。 基本类型及其封装对象类型：基本类型：byte、short、int、long、float、double、char、boolean与封装类：Byte,Short,Integer,Long,Float,Double,Character,Boolean, Scanner常见的扫描器 将Iterator迭代器转换为Scala迭代器 经过Collections.unmodifiableList/Map/Set()方法处理后的集合 常见的mutable类 StringBuilder：StringBuilder是mutable类型的一个例子。它有删除部分字符串，插入或替换字符等方法。这个类有改变对象值的方法，而不仅仅是返回新值。 StringBuffer 常见的Map如HashMap Java中的常见的大多数迭代器Iterator 3.mutable与immutable的优劣 使用immutable，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)。mutable最少化拷贝以提高效率。因此，使用可变数据类型，可获得更好的性能。也适合于在多个模块之间共享数据。 4.mutable与immutable的差异例子 5.使用final 可以这么理解：在java中引用变量的组成分为两部分：引用哪个对象，那个对象的值。immutable就是那个对象的值不会改变，但引用哪个对象会改变。mutable就是两者都能改变。而如果在一个引用变量前使用final修饰，则会导致引用哪个对象不会发生改变。在snapdiagram中，表现为指针变成双线。 
第273篇文章[0]
GraphPoet翻译 ClassGraphPoet java.lang.Object poet.GraphPoet publicclass GraphPoetextendsObject 一个基于图的诗歌派生器。 GraphPoet由文本语料库初始化，它用这个语料库来派生一个单词亲和图wordaffinitygraph。单词words用图中的顶点vertices表示。单词是不包括空格和换行符的不区分大小写的非空字符串，它们在语料库中由空格、换行符或EOF分隔。图中的各边表示邻接的数量：从w1到w2的边的权重定义为语料库中“w2”紧跟在“w1”后面的次数。 举个栗子，给定这个语料库: Hello,HELLO,hello,goodye! 生成的图应该包含两条边： (“hello,”)->(“hello,”)权重为2(“hello,”)->(“goodbye!”)权重为1 两个点表示为不区分大小写的“hello,”和“goodbye!” 给定输入字符串，GraphPoet通过尝试在输入中的每对相邻单词之间插入一个桥接词bridgeword来生成一首诗。单词由语料库中的单词定义和分隔。输入词“w1”和“w2”之间的桥接词“b”使得w1->b->w2成为一条包含两条边的路径，满足在这个诗人(GraphPoet)的单词亲和图中的所有从w1到w2的包括两条边路径中，具有最大权重。如果没有这样的路径，则不会插入桥接词。在输出的诗句中，输入词保留了原来的大小写，而桥词则是小写。诗中每个字之间的空白是一个空格，开头和结尾没有空格。 再举个栗子，给定这个语料库： ThisisatestoftheMugarOmniTheatersoundsystem. 对于这个输入： Testthesystem. 输出的诗句将会是： Testofthesystem. 说明：这是一个有要求的ADT类，并且你不能弱化要求的规约specifications。但是，你可以强化规约，也可以添加额外方法。你必须在你的属性rep中使用Graph类，但是除此之外这个类的实现取决于你。 ConstructorSummary GraphPoet (File corpus)使用从corpus生成的图创建一个新的诗人。 MethodSummary String poem (String input)生成一首诗。 从java.lang.Object类继承的方法 equals, getClass, hashCode, notifyAll, toString, wait, wait, wait ConstructorDetail GRAPHPOET publicGraphPoet(Filecorpus)throwsIOException 使用从corpus生成的图创建一个新的诗人。 parameters corpus-生成诗人的单词亲和图的文本文件 Throws IOException-如果无法找到或无法读corpus文件 MethodDetail POEM publicStringpoem(Stringinput)派生一首诗。 Parameters input-派生一首诗的源字符串 Returns poem-(如上文所说) 声明：翻译自MIT6.031的 GraphPoet(ProblemSet2:PoeticWalks)仅供个人学习个人水平有限，如有疏漏和错误恳请批评指正 
第274篇文章[0]
Java为什么不采用360垃圾清理来进行垃圾回收呢？ Java垃圾回收机制 什么是垃圾回收（GC） 垃圾回收，顾名思义，便是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。在Java虚拟机的语境下，垃圾指的是死亡的对象所占据的堆空间。 Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。它从一系列GCRoots出发，边标记边探索所有被引用的对象。 判断对象死亡的方法 引用计数法: 它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。 引用计数法的具体实现是这样子的： 如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器+1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器-1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。 引用计数法的弊端： 除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。 可达性分析算法: 可达性分析算法的实质在于将一系列**GCRoots**作为初始的**存活对象合集（liveset）**，然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。 什么是GCRoots呢？ 我们可以暂时理解为由堆外指向堆内的引用， 一般而言，GCRoots包括（但不限于）如下几种： -Java方法栈桢中的局部变量； -已加载类的静态变量； - JNIhandles； -已启动且未停止的Java线程。 -可达性分析优点：解决循环引用问题 可达性分析可以解决引用计数法所不能解决的循环引用问题。 举例来说，即便对象a和b相互引用，只要从GCRoots出发无法到达a或者b，那么可达性分析便不会将它们加入存活对象合集之中。 -可达性分析算法的问题 虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。 比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为null）或者漏报（将引用设置为未被访问过的对象）。 误报并没有什么伤害，Java虚拟机至多损失了部分垃圾回收的机会。 漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致Java虚拟机崩溃。 垃圾收集算法 清除（sweep）: 把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（freelist）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。 清除这种回收方式的优点是原理极其简单。 但是清除有两个缺点： 一是会造成内存碎片。由于Java虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。 二是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointerbumping）来做分配。而对于空闲列表，Java虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。 压缩（compact）: 把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。 这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。 复制（copy）： 把内存区域分为两等分，分别用两个指针from和to来维护，并且只是用from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域中，并且交换from指针和to指针的内容。 复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。 垃圾收集器 Serial收集器 Serial收集器是最基本的、历史最悠久的收集器，曾经是JDK1.3.1之前虚拟机的新生代收集的唯一选择。Serial这个名字揭示了这是一个单线程的垃圾收集器，特点如下： 仅仅使用一个线程完成垃圾收集工作；在垃圾收集时必须暂停其他所有的工作线程，知道垃圾收集结束；StoptheWorld是在用户不可见情况下执行的，会造成某些应用响应变慢；使用复制算法； ParNew收集器 ParNew收集器其实是Serial收集器的多线程版本，与Serial不同的地方就是在垃圾收集过程中使用多个线程，剩下的所有行为包括控制参数、收集算法、StoptheWorld、对象分配规则和回收策略等都一样。ParNew收集器也使用复制算法。 ParallelScavenge收集器 ParallelScavenge收集器和ParNew类似，是一个新生代收集器，使用复制算法，又是并行的多线程收集器。不过和ParNew不同的是，ParallelScavenge收集器的关注点不同。 CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而ParallelScavenge收集器的目的则是达到一个可控制的吞吐量。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+运行垃圾收集时间）。如果虚拟机一共运行100分钟，垃圾收集运行了1分钟，那么吞吐量就是99%。 停顿时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 ParallelScavenge收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。 MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能在给定时间内完成垃圾收集。不过垃圾收集时间的缩短是以牺牲吞吐量和新生代空间为代价的，短的垃圾收集时间会导致更加频繁的垃圾收集行为，从而导致吞吐量的降低。 SerialOld收集器 SerialOld是Serial的老年版本，在Serial的工作流程图中可以看到，SerialOld收集器也是一个单线程收集器，使用“标记-整理”算法。这个收集器主要给Client模式下的虚拟机使用。如果在Serve模式下，它有两个用途：一个是在JDK1.5之前的版本中与ParallelScavenge收集器搭配使用；另一个就是作为CMS收集器的后备预案，在并发收集发生ConcurrentModeFailure时使用。这个收集器的工作流程在Serial的后半部分有所体现。 ParallelOld收集器 ParallelOld收集器是ParallelScavenge收集器的老年版本，它也使用多线程和“标记-整理”算法。这个收集器是在JDK1.6开始提供。 CMS收集器 CMS（ConcurrentMarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。在重视响应速度和用户体验的应用中，CMS应用很多。 CMS收集器使用“标记-清除”算法，运作过程比较复杂，分为4个步骤： 初始标记（CMSinitialmark）并发标记（CMSConcurrentmark）重新标记（CMSremark）并发清除（CMSConcurrentSweep） G1收集器 G1（Garbagefirst）收集器是最先进的收集器之一，是面向服务端的垃圾收集器。与其他收集器相比，G1收集器有如下优点： 并行与并发：有些收集器需要停顿的过程G1仍然可以通过并发的方式让用户程序继续执行；分代收集：可以不使用其他收集器配合管理整个Java堆；空间整合：使用标记-整理算法，不产生内存碎片；可预测的停顿：G1除了降低停顿外，还能建立可预测的停顿时间模型； G1中也有分代的概念，不过使用G1收集器时，Java堆的内存布局与其他收集器有很大的差别，它将整个Java堆划分为多个大小相等的独立区域（Region），G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要的时间的经验值），在后台维护一个优先列表，每次优先收集价值最大的那个Region。这样就保证了在有限的时间内尽可能提高效率。 G1收集器的大致步骤如下： 初始标记（Initialmark）并发标记（Concurrentmark）最终标记（Finalmark）筛选回收（LiveDataCountingandEvacuation） 回到标题 360垃圾清理的目标和JavaGC的目标是不同的。 360清理的目标集中在文件系统里无用的垃圾，而GC的目标集中在内存里不需要再用到的数据。 :) 
第275篇文章[0]
Java集合类总结 在编写java程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！ java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等。 Collection接口 Collection接口是最基本的集合接口，它不提供直接的实现，JavaSDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。 在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。 List接口 List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 2.1 ArrayList ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。size、isEmpty、get、set、iterator和listIterator操作都以固定时间运行。add操作以分摊的固定时间运行，也就是说，添加n个元素需要O(n)时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。ArrayList擅长于随机访问。同时ArrayList是非同步的。 2.2LinkedList同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：Listlist=Collections.synchronizedList(newLinkedList( )); 2.3Vector 与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。 2.4StackStack 继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。。 Set接口 Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。 3.1EnumSet是枚举的专用Set。所有的元素都是枚举类型。 3.2HashSetHashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。 Map接口 Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。 4.1HashMap以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[]table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 4.2TreeMap键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口 4.3HashTable也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低 Queue接口 队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。 
第276篇文章[0]
软件构造内容简单梳理 1.多维度视图与质量目标 1.多维度视图与质量目标 1.1三维度八视图 MomentPeriodCode-levelComponent-levelCode-levelComponent-levelBuild-timeSourcecode,AST,Interface-Class-Attribute-Method(ClassDiagram)Package,File,StaticLinking,Library,TestCase,BuildScript(ComponentDiagram)CodeChurnConfigurationItem,VersionRun-timeCodeSnapshot,MemorydumpPackage,Library,Dynamiclinking,Configuration,Database,Middleware,Network,Hardware(DeploymentDiagram)Executionstacktrace,Concurrentmulti-threadsProcedureCallGraph,MessageGraph(SequenceDiagram)Eventlog,Multi-processes,DistributedprocessesProcedureCallGraph,MessageGraph(SequenceDiagram) 1.2质量目标 1.2.1五个关键的质量目标 1.Elegantandbeautifulcode：代容易理解。2.Designfor/withreuse：提高代码的可复用性。3.Lowcomplexity：高内聚低耦合。4.Robustnessandcorrectness：健壮性和正确性。5.Performanceandefficiency：提升性能。 1.2.2内部&外部质量因素 内部： 代码行数(LOC)、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小。 外部： Correctness（正确性），Robustness（鲁棒性），Extendibility（易扩展性），Reusability（复用性），Compatibility（兼容性），Efficiency（效率），Portability（可移植性），Easeofuse（易用性），Functionality（功能性），Timeliness（时效性），Verifiability(可验证性)，Integrity(完整性)，Repairability(可修复性)，Economy(经济性)等。 2.软件构造的过程与工具 2.软件构造的过程与工具 2.1SCM,VCS,Git 2.1.1SCM(软件配置管理) 软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被成为软件配置项(SCI)。 当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。 为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。 2.1.2VCM（版本控制系统） VCS分为三种：本地版本控制系统（无法协作）存储在本地、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。 2.1.3Git 指令： 创建：gitinit 暂存：gitadd<filename> 提交：gitcommit-m“commitmessage” 链接：gitremoteaddorigin<URL> 推送：gitpush-uoriginmaster 创建分支：gitcheckout-b<branchname> 切换分支：gitcheckout<branchname> 合并分支：gitmerge<branchname> 删除分支：gitbranch-d<branchname> 注意，git的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。 2.2软件构造过程 1.Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。 2.Codereview、Staticcodeanalysis：可以使用工具来发现bug，如CheckStyle,SpotBugs。 3.Testing：测试，单元测试、集成测试、系统测试… 4.Debugging：调试 5.Dynamiccodeanalysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分 6.Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化 7.Build：第2部分 3.ADT&OOP 3.ADT&OOP 3.1Spec 3.1.1Spec的结构 precondition前置条件：对客户端的约束，在使用方法时必须满足的条件使用@paramannotation说明每个参数的前置条件postcondition后置条件：对开发者的约束，方法结束时必须满足的条件使用@returnannotation说明后置条件 抛出异常：使用@throwsannotation说明出现异常的时候会发生什么在方法声明中使用static等关键字声明，可据此进行静态类型检查 3.1.2Spec的强弱 更强的Spec：前置条件变弱，后置条件变强，强的Spec可以替换弱的。 3.2ADT 3.2.1 ADT的操作Creators构造器：用于使用new关键字创建一个新的对象。还有一种方法是静态方法，如Arrays.asList()、String.valueOf(ObjectObj)等。 Producers生产器：用于使用一个存在的对象产生一个新的对象，例如String.concat()就是使用已存在的字符串构造出一个新的对象，而且不会改动原先存在的对象。 Observers观察器：不对数据做任何改动，只是查看一个已经存在的对象的各个值，如List.size()、所有的getter方法等。 Mutators变值器：用于改变对象属性的方法，如List.add()。mutator通常返回void，因为它不需要对外界做出反应，只是对ADT的数据域做了更改；mutator也可能返回非空，比如返回boolean表示修改成败等。 3.2.2.设计ADT设计一个好的ADT需要靠开发者的经验来设计它的操作的spec，设计一个ADT要遵循下面三个原则：（1）设计简洁一致的操作（2）要足以支持client所需要的对数据的所有操作，且用操作的难度要低（3）要么抽象要么具体，不要混合 要么针对抽象设计，要么针对具体应用的设计。 实现一个ADT的三个部分：specification、representation、implementation RepresentationIndependence表示独立性client不应该知道内部的数据域是怎么实现的，最好client只能通过ADT提供的getter方法获得ADT存储的数据。 client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。其目的一个是为了便于未来的升级和维护，当内部发生变化的时候不会影响到client。 3.2.3测试ADT因为测试相当于client使用ADT，所以它也不能直接访问ADT内部的数据域，所以只能调用其他方法去测试被测试的方法。 针对creator：构造对象之后，用observer去观察是否正确 针对observer：用其他三类方法构造对象，然后调用被测observer，判断观察结果是否正确 针对producer：produce新对象之后，用observer判断结果是否正确 RepInvariant(RI)andAbstractionFunction(AF)Invariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件 两个空间R和A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。 AbstractionFunction：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。 RepInvariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。 相同的R空间有肯能会有不同的RI。 即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。 checkRep()：用于随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。 表示泄露：client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。 3.3OOP 3.3.1继承与重写 子类可以继承父类的数据域和方法。 严格继承：子类只能添加新方法，无法重写超类中的方法。原因：父类中的方法使用了final关键字限定。 重写：子类的方法覆盖了父类的方法。重写的方法应该与父类方法有相同的签名，只有这样编译器才会判定为重写的方法。使用@Overrideannotation强制检查是否重写了超类中的方法。 3.3.2多态 三种多态：特殊多态、参数化多态、子类型多态 特殊多态：功能重载 重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型。参数列表必须不同，返回值类型、可见性、异常均为可以相同也可不同。重载不仅可以发生在类内，也可发生在父类与子类之间。 父类与子类之间发生重载的例子如下。这两个情况都不能编译成功，以为无论是a还是h，他们的运行时类型都是Animal，而不是通过new创建的具体类型。 参数化多态：泛型 使用泛型参数代替具体的类型。作为一个泛型接口，当实现的时候可以实现一个具有具体类型的子类型，也可以实现一个具有泛型接口的实现类。 子类型多态 终极目的：不同类型的对象可以统一处理而无需区分。 遵循的设计原则：LSP 4.复用 4.复用 4.1四个复用层面 1.源代码层面的复用可以在网络上寻找自己需要的代码，但要注意开发商用的软件不能直接复制开源的代码，避免引起法律纠纷。 2.模块层面的复用通过继承(Inheritance)的方式复用父类的代码，同时也可override父类中已存在的方法。另一个复用的方法是委托(delegation)，详见下一小节(4.2)。3.库层面的复用通过导入库来调用库中的API完成复用。除了导入本地库，也可以通过导入部署在网络上的库来完成复用，如WebServices/RestfulAPIs 4.架构层面的复用框架：一组具体类、抽象类、及其之间的连接关系。开发者可以根据spec填充自己的代码从而形成完整的系统。开发者根据Framework预留的接口所写的程序，而Framework作为主程序加以执行，执行过程中调用开发者所写的程序。关于框架详见下一小节4.2.3。 黑盒框架：通过实现特定接口/delegation进行框架扩展白盒框架：通过代码层面的继承进行框架扩展 4.2LSP 4.2.1LSPLiskovSubstitutionPrinciple中子类重写父类的方法应该满足的条件： 编译器在静态类型检查时强制满足的条件 子类型可以增加方法，但不可删除子类型需要实现抽象类型中的所有未实现方法子类型中重写的方法返回值必须与父类相同或符合co-variance(协变)子类型中重写的方法必须使用同样类型的参数或者符合contra-variance(逆变)的参数子类型中重写的方法不能抛出额外的异常还应该满足的条件 更强的不变量(RI)更弱的前置条件更强的后置条件协变关于返回值的类型，应该保持不变或者变得更具体，也就是与派生的方向一致。 所抛出的异常的类型也是如此。 4.2.2.4种委派方式 1.Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。 2.Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。 3.Composition:更强的association，但难以变化。 4.Aggregation:更弱的association，可动态变化。 4.3.6种经典复用模式 1.Adapter适配器模式目的是将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。 因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。 2.Decorator装饰器模式 装饰器模式的原理是从接口派生出子类，然后在子类中定义一个父类接口然后将其作为delegation的对象，也就是说：自己到自己的委派。这里第一个自己指的是子类型本身，第二个自己是指该接口的其他子类，由于他们两个是同一个接口的子类，所以可以称为自己到自己的委派。 3.Facade外观模式 客户端在调用的API时候会以固定的方式调用一系列的方法，而为了简化客户端的使用，便于客户端的学习使用、解耦，所以需要提供一个统一的接口来取代一系列小接口调用，对复杂系统做了一个封装。 4.Strategy策略模式 有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。 5. TemplateMethod模板模式 做事情的步骤一样，但具体方法不同，因此共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。 在模板中，实现了一个固定执行一系列操作的方法，这个方法使用final关键字做了限定，不能再被子类重写，因此，子类只能通过重写该方法调用的那些尚未实现的方法。 6.Iterator迭代器模式 客户端希望遍历被放入容器/集合类的一组ADT对象，而无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式 实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。 5.可维护性 5.可维护性 5.1SOLID设计原则 1.(SRP)TheSingleResponsibilityPrinciple---------单一责任原则 尽可能地将功能分割，以达到不应该有多于一个原因让你的ADT发生变化的目的，否则就要拆分开。如果多个责任（功能）放在一个类中就有可能在未来某一个功能发生变化的时候影响到整个类，从而影响到整个程序的很大一部分实现（需要全部重新编译打包部署）。2.(OCP)TheOpen-ClosedPrinciple-------------------开放-封闭原则 在未来对功能进行修改或者扩展的时候，要遵循尽量不去改动已有的代码而是扩展出新的类然后调用新的类的原则。 典型的违反OCP的例子是大量的使用if-else/switch-case语句，这给维护造成了极大的麻烦。所以应对的方法是让客户端传入接口的不同子类型，而在ADT中只需要统一的调用接口中共有的方法即可。 3.(LSP)TheLiskovSubstitutionPrincipleLiskov----替换原则 子类型必须能够替换其基类型。4.(DIP)TheDependencyInversionPrinciple--------依赖转置原则 具体的模块应该依赖于抽象的模块，但抽象的模块不应依赖于具体的模块。5.(ISP)TheInterfaceSegregationPrinciple----------接口隔离原则 大接口分解为多个小的接口。 5.2可维护性的设计模式 1.FactoryMethod工厂方法当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。 定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 当然也可以通过直接定义静态工厂方法来创建子类实例。 2.AbstractFactory抽象工厂当client需要的是多个具有固定搭配的类的组合，如A和B两个系列的类，A1搭配B1，A2搭配B2，于是，就要用抽象工厂对其做一次封装。 定义一个用于创建对象的接口，让其子类来决定实例化哪一组类，从而使类与类之间的搭配对于client来说固定了。 本质上，AbstractFactory是把多类产品的factorymethod组合在一起 3.Proxy代理模式某个对象比较“敏感”/“私密”/“贵重”，不希望被client直接访问到，故设置proxy，在二者之间建立防火墙。 创建一个代理类，它接受client的功能请求，然后把功能请求转发(delegate)给实现类，类似于Adapter模式。 4.Observer观察者模式 5.Visitor对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。 为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT 本质上是将数据和作用于数据上的某种/些特定操作分离开来。 6.共性和差异Proxyvs.AdaptorAdapter：目的是消除不兼容，目的是B以客户端期望的统一的方式与A建立起联系。 Proxy：目的是隔离对复杂对象的访问，降低难度/代价，定位在“访问/使用行为” Visitorvs.IteratorIterator：目的是以遍历的方式访问集合数据而无需暴露其内部表示，将“遍历”这项功能delegate到外部的iterator对象。 Visitor：在特定ADT上执行某种特定操作，但该操作不在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活扩展/改变visitor的操作算法，而不影响ADT Strategyvs.visitor同：二者都是通过delegation建立两个对象的动态联系 Visitor：强调是的外部定义某种对ADT的操作，该操作于ADT自身关系不大（只是访问ADT），故ADT内部只需要开放accept(visitor)即可，client通过它设定visitor操作并在外部调用。 visitor是站在外部client的角度，灵活增加对ADT的各种不同操作（哪怕ADT没实现该操作）。 Strategy：强调是对ADT内部某些要实现的功能的相应算法的灵活替换。这些算法是ADT功能的重要组成部分，只不过是delegate到外部strategy类而已。 strategy是站在内部ADT的角度，灵活变化对其内部功能的不同配置。 6.正确性&健壮性 6.正确性&健壮性 6.1并发 并发编程有两种模式： 共享内存：在内存中读写共享数据，某一时刻执行在不同处理器上的同一程序共享内存里的数据；消息传递：通过channel交换消息，A把消息发给B，B把执行结果发给A 6.2线程安全 1. Confinement限制数据共享，将可变数据限制在单一线程内部，不允许任何线程直接读写该数据。 核心思想：线程之间不共享mutable数据类型。 避免使用全局数据，而是使用局部数据。如果使用全局的mutable的数据，就有可能造成竞争条件。 2.Immutability共享不可变数据，使用不可变数据类型和不可变引用，避免多线程之间的racecondition，因为不可变数据通常是线程安全的。 大家都只是读取它的值，而不能对它做出更改，所以它是线程安全的。 不可变类型要满足的条件： 没有mutator方法所有的数据域都是private和final的没有表示泄露rep中的mutable的数据没有任何改变3.UsingThreadsafeDataTypes共享线程安全的可变数据，如果必须要用mutable的数据类型在多线程之间共享数据，要使用线程安全的数据类型。 在JDK中的类，文档中明确指明了是否threadsafe。 一般来说，JDK同时提供两个相同功能的类，一个是threadsafe，另一个不是(threadsafe的类一般性能上受影响)。例如： StringBuffervs.StringBuilder StringBuffer是线程安全的，可被安全的用于多线程。 StringBuilder是线程不安全的，但它的运行速度要比StringBuffer更快。 4:LocksandSynchronization 同步机制：通过锁的机制共享线程不安全的可变数据，变并行为串行。 6.3锁、同步 6.3.1锁 Lock是Java语言提供的内嵌机制。在Java中，任何对象都可以作为锁。可以创建一个没有意义的对象Objectlock=newObject();作为锁来使用，而拥有lock的线程可独占式的执行该部分代码。 6.3.2同步 程序员来负责多线程之间对mutable数据的共享操作，通过“同步”策略，避免多线程同时访问数据。 使用锁机制，获得对数据的独家mutation权，其他线程被阻塞，不得访问。 当A线程申请了A锁时，它获得了对数据的独家修改访问权限，B线程再想访问时，就必须申请A锁的使用权限，这就要等A线程执行结束释放锁时候再获得。 
第277篇文章[0]
软件构造-关于图 一些概念： 1.连通图与连通分量 连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。 连通分量：非连通图中的各个连通子图称为该图的连通分量。 2.邻接矩阵 邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。 3.邻接表 邻接表是图的一种链式存储表示方法。它是改进后的"邻接矩阵"，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。 1.顶点类： 在非常抽象的图的问题中，知识简单的把顶点编号，从0->n-1,不需要任何变量类型来存储顶点，因为他们的用处来自于他们之间的相互关系，但大多数情况下，顶点表示某个真实世界的对象。顶点对象能放在数组中，然后用下标指示。 packagecom.cn.graph;/** *图的顶点类 *@authorAdministrator * */publicclassVertex{publiccharlable;publicbooleanwasvisited;publicVertex(charlab){ lable=lab; wasvisited=false;}} 2.深度优先搜索 找到一个起始点---本例为顶点A,需要做三件事情，首先访问该节点，然后把该点放入栈中，以便记住它，最后标记该点，这样就不会再访问它了。 packagecom.cn.graph;/** *深度优先实现的图 *@authorAdministrator * */publicclassGraph{privatefinalintMAX_VERTS=20;privateVertex[]vertexList;privateintadjMat[][];publicintnVerts;privateStackXtheStack;publicGraph(){ vertexList=newVertex[MAX_VERTS]; adjMat=newint[MAX_VERTS][MAX_VERTS]; nVerts=0; for(inti=0;i<MAX_VERTS;i++){ for(intj=0;j<MAX_VERTS;j++){ adjMat[i][j]=0; } } theStack=newStackX();}publicvoidaddVertex(charlab){ vertexList[nVerts++]=newVertex(lab);}publicvoidaddEdage(intstart,intend){ adjMat[start][end]=1; adjMat[end][start]=1;}publicvoiddisplayVertex(intv){ System.out.print(vertexList[v].lable+"");}publicvoiddfs(){ vertexList[0].wasvisited=true; displayVertex(0); theStack.push(0); while(!theStack.isEmpty()){ intv=getAdjUnvisitedVertex(theStack.peek()); if(v==-1) theStack.pop(); else{ vertexList[v].wasvisited=true; displayVertex(v); theStack.push(v); } } for(inti=0;i<nVerts;i++) vertexList[i].wasvisited=false;}publicintgetAdjUnvisitedVertex(intv){ for(inti=0;i<nVerts;i++) if(adjMat[v][i]==1&&vertexList[i].wasvisited==false) returni; return-1;}} 3.广度优先 首先访问起始顶点的所有邻接点，然后再访问较远的区域，用队列来实现它。（A是起始点，所以访问它，并标记为当前顶点，然后应用规则）。 packagecom.cn.graph;/** *图的广度优先搜索---队列类 *@authorAdministrator * */publicclassQueue{privatefinalintSIZE=20;privateintqueueArray[];privateintfront;privateintrear;publicQueue(){ queueArray=newint[SIZE]; front=0; rear=-1;}publicvoidinsert(intj){ if(rear==SIZE-1) rear =-1; queueArray[++rear]=j;}publicintremove(){ inttemp=queueArray[front++]; if(front==SIZE) front=0; returntemp;}publicbooleanisEmpty(){ return(rear+1==front||front+SIZE-1==rear);}} 
第278篇文章[0]
浅谈Java的继承 在生活中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物，同理，波斯猫和巴厘猫继承自猫，这些动物之间会形成一个继承体系。在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。 继承的用法：在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。通过extends关键字让类与类之间产生继承关系。多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。多个类可以称为子类，单独这个类称为父类或者超类。 classPerson{ Stringname; intage; } classStudentextendsPerson{//此处运用了继承的思想，将class继承 voidstudy(){ System.out.println("studentstudy "+age); } } classExtendDemo{ publicstaticvoidmain(String[]args){ Students=newStudent(); s.name="zhangsan"; s.age=20; s.study(); } } 注意事项：1.子类可以直接访问父类中的非私有的属性和行为。2.子类无法继承父类中私有的内容。3.父类怎么来的？共性不断向上抽取而来的。4.Java只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类。 继承的优点：1.继承的出现提高了代码的复用性。2.继承的出现让类与类之间产生了关系，提供了多态的前提。 继承的特点：1.在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类，2.多个类可以继承一个父类。3.在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。例如下面这种情况是允许的。4.在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。 
第279篇文章[0]
类与对象的基本概念 类与对象时整个面向对象中最基础的组成单元。 类：是抽象的概念集合，表示的是一个共性的产物，类之中定义的是属性和行为（方法）； 类是定义对象形式的模板，指定了数据以及操作数据的代码。Java中使用类的规范来构造对象，而对象是类的实例。类是逻辑抽象的，只有类的实例 对象才是内存中的物理表示。类一般都包含方法和变量，通过class创建类。 //类由class创建 publicclassPerson{ publicPerson(){ System.out.println("热烈庆祝中国共产党成立一百周年"); } } 对象：对象是一种个性的表示，表示一个独立的个体，每个对象拥有自己独立的属性，依靠属性来区分不同对象。对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步： 1.声明：声明一个对象，包括对象名称和对象类型。 2.实例化：使用关键字new来创建一个对象。 3.初始化：使用new创建对象时，会调用构造方法初始化对象。 publicclassPuppy{ publicStringname_; publicSupper(Stringname) { name_=name; } publicstaticvoidmain(String[]args) { SuppermySupper=newSupper("tommy");//这条语句将创建一个Puppy对象 } } 可以一句话来总结出类和对象的区别：类是对象的模板，对象是类的实例。类只有通过对象才可以使用，而在开发之中应该先产生类，之后再产生对象。类不能直接使用，对象是可以直接使用的。 
第280篇文章[0]
面向对象编程的特点 对于初学Java的新手来说，Java的面向对象问题比较难理解，今天我就对此问题谈一谈自己所学到的知识。 Java面向对象编程作为一种编程思想，有三大特性，封装，继承，多态。次三类特性可以说是决定面向对象编程的根本，只有对此概念有一定的理解，才能学好Java语言。 1.封装 把客观事物封装成抽象的类，并且把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。也就是说，抽象数据类型对数据信息以及对数据的操作进行打包，将其变成一个不可分割的实体在这个实体内部，我们对数据进行隐藏和保密，只留下一些接口供外部调用。 简而言之，一个类就是一个封装了数据以及操作代码的实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。 封装类似于黑箱操作。一个具体复杂的对象有很多的属性和方法，有些需要公开，有些不需要公开，就好比一个具体的人的信息，有些是public，有些是private，而有些是protecred，别人问到的时候对于怎么样的信息都有不同的态度。根据与这个人的关系来回答问题，封装的结果是输出结果，不问过程。 比如我们将一个房子看做是一个对象，里面的漂亮的装饰，也有实用的家具，这都是该房子的私有属性，但是家是属于私人的，不可以被他人随意观看或出入，封装就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设，同时不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。 2.继承 继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。在本职上是特殊和一般的关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。 Java的继承属性避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围 在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。 继承的原则：1.能够继承父类的public和protected成员变量，不能够继承父类的private11成员变量。2.对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承。3.对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。 3.多态 相比于封装和继承，Java多态是三大特性中比较难的一个，封装和继承最后归结于多态，多态指的是类和类的关系，两个类由继承关系，存在有方法的重写，故而可以在调用时有父类引用指向子类对象。自己对于多态的理解还不够深刻，故而分享的不是很多，敬请见谅。 
第281篇文章[0]
Java注释的简单理解 每种编程语言的语法规范中都包含了注释的规则，从早期的C到近些年的Python大体上各种语言的注释要求都类似。良好的注释习惯会让别人很轻松地阅读你的代码，同时，也让自己的编程过程中的想法有了准确的记录，下面就我最近学习的Java语言，与大家分享一下我的理解。 在Java中有3种类型的注释，分别是单行注释、多行注释和文档注释。 1.单行注释 单行注释的作用是注释一行代码。它是使用双斜线（//）标注的，注释的内容放在“//”的后面。 //注释内容 2.多行注释 如果我们想同时注释连续的多行代码，可以使用多个单行注释。但是这种方式太过繁琐，我们可以直接使用多行注释的方式。 多行注释的作用是注释连续的多行内容。它把注释的内容放在“/*”开始，“*/”结束的区域内。这其中的一切内容均属于注释部分，不用做代码处理。 /*多 行 注 释 */ 3.文档注释 单行注释和多行注释是大多数程序语言共有的，Java语言在二者之上还有自己独有的文档注释。 文档注释的好处是将分离的代码和注释连接起来，保证代码与注释内容可以同时更新。除此之外，文档注释还可以生成API文档。 文档注释以“/**”开始，“*/”结束，中间的内容全部都是文档注释。 /** 文档注释 */ 不过，要想保证代码与注释同时更新，仅使用“/**”、“*/”这两个符号是不够的，还要使用到文档注释的标签，也可以称为“标记”。文档注释的标记是什么、完整的文档注释应该怎么编写、如何将文档注释生成API见“2.文档注释生成API文档”。下面是3种注释的示例。 packagestudy._cqf; /** *主题：Java中的注释 * *@authorCongqiufeng * */ publicclassstudy{ /** *【文档注释】 *@param字符串数组 *@returnvoid类型 */ publicstaticvoidmain(String[]args){ /* *【多行注释】 *System类字段out */ System.out.println("HelloWorld!");//【单行注释】输出内容为HelloWorld! } } 
第282篇文章[0]
对于重载，重写的理解 重载概念： 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。 调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法,这就是多态性。重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。 重载的规则： 1）、必须具有不同的参数列表； 2）、可以有不同的返回类型，只要参数列表不同就可以了； 3）、可以有不同的访问修饰符； 4）、可以抛出不同的异常； 重载和重写（覆盖）的特点： Override特点 1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果； 2、覆盖的方法的返回值必须和被覆盖的方法的返回一致； 3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 2.Overload特点 1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）； 2、不能通过访问权限、返回类型、抛出的异常进行重载； 3、方法的异常类型和数目不会对重载造成影响； 4、对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。 
第283篇文章[0]
软件构造复习笔记 软件构造课程复习笔记1 1.软件构造中的多维度视图2.视图间的转换3.软件系统的质量 由于在之前的夏季小学期选择的课程并非java，因此在java方面投放了部分精力自学。博客整理的开始时间较晚，请见谅。现在开始对软件构造课程进行复习和整理。（主要基于对课件的阅读以及课堂知识的整理） 1.软件构造中的多维度视图 Moment维度是指程序在某一个时刻的表现，而Period维度指程序在一段时间内的表现；Build-time维度是指程序在编码阶段的表现，而Run-time维度关注程序在运行时的表现；Code-level维度在程序代码的语句层面，Component-level维度指程序一段代码：一个包，一个库 Build-timeviews：code-levelview关注源代码的逻辑组织情况，结构，方法等component-levelview关注源代码的物理组织，如库，包，文件等等是如何链接组织起来的(1)Build-time,moment,andcode-levelview关注的是源码的组织情况，可在词汇层面（源码）、语法层面（抽象语法树）、语义层面（类图）三个层面分别分析。AST：抽象语法树（abstractsyntaxcode，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，这所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节，比如说，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。抽象语法树并不依赖于源语言的语法，也就是说语法分析阶段所采用的上下文无文文法，因为在写文法时，经常会对文法进行等价的转换（消除左递归，回溯，二义性等），这样会给文法分析引入一些多余的成分，对后续阶段造成不利影响，甚至会使合个阶段变得混乱。因些，很多编译器经常要独立地构造语法分析树，为前端，后端建立一个清晰的接口。（初始理解就是关于将源代码结构表示为树）AST：彻底结构化，将源代码变为一棵树，对树做各种操作==对源代码的修改(2)Build-time,period,andcode-levelview关注的是代码的变化（Codechurn代码变化）(3)Build-time,moment,andcomponent-levelview关注的是包/库：静态链接库（课件里有一些关于库的知识）(4)Build-time,period,andcomponent-levelview关注代码版本的更迭，而不是具体语句的变化，这里与2不同Run-timeviews区分了动态链接和静态链接(5)Run-time,moment,andcode-levelview关注的是程序在某个时间点内存中的情况，如代码快照图(CodeSnapshot)、内存转储(Memorydump)。(6)Run-time,periodandcode-levelview关注的是代码的执行情况，执行跟踪(7)Run-time,moment,andcomponent-levelview关注的也是包/库，但却是在代码执行过程中的情况，如动态链接库(8)Run-time,period,andcomponent-levelview关注的是系统的使用情况，使用日志查看 2.视图间的转换 Build-time维度：写出代码的维度。moment+Code-level维度，写出了一些零散代码此时随着时间的推移，代码删删改改，就属于Period+Code-level了，而代码越写越多成为了一个包，甚至形成了一个库，于是就属于moment+Component-level维度了（包含了代码间的物理联系），Period+Component-level：库文件由于需求的变化发生了变化，代码写好了，投入运行，进入Run-time维度，观察的如果是某一句代码的执行后结果，那就是moment+Code-level维度，但如果看的是代码执行的轨迹，那就是Period+Code-level维度，而如果看的是一个库文件的连接情况等，那就是moment+Component-level维度，如果看的是线程或进程的执行过程，也就是通过日志等手段查看一段时间内系统都做了什么事情，那么就是Period+Component-level。 3.软件系统的质量 外部质量因素（影响用户）External1:Correctness（正确性），正确就是按照预先定义的“规约”执行，这是软件开发最重要质量指标，一个可用的软件一定是正确的，所以首要保证软件的正确性，其他的都可以做妥协、让步，但只有这一项不可妥协。通过测试和调试可以发现和消除不正确。防御式编程可以在写程序时就保证正确性。形式化方法：通过形式化验证发现问题。External2:Robustness（健壮性），是针对异常情况的处理，对正确性的补充。出现规约定义之外的情形的时候，软件要做出恰当的反应，不要崩溃。External3:Extendibility（可扩展性），要便于软件功能的增加/扩展（ADT、OOP、留下一个Visitor），应对变化，降低未来修改软件时的成本，External4:Reusability（可复用性），在异性之间尽可能地寻找共性，以便于未来可以直接使用现在写的这段代码。这样可以降低软件地开发成本。进行一次开发，多次使用。发现共性。External5:Compatibility（兼容性），在不同的环境下都是可用的，不同的软件系统之间相互可容易的集成。（保持设计的同构性）External6:Efficiency（效率），不要过早的优化，性能在没有正确性保障的条件下是没有意义的。External7:Portability（可移植性），软件可方便的在不同的技术环境之间移植。External8:Easeofuse（易用性），学习成本低，结构简单、清晰，易于使用。（对用户而言）External9:Functionality（功能性），功能过多会导致易用性的降低。主要功能要首要提升质量。External10:Timeliness（时效性），软件要能够在交付时间之前完成开发交给使用者。External10++:Otherqualities，Verifiability(可验证性)，Integrity(完整性)，Repairability(可修复性)，Economy(经济性)。 内部质量因素（影响软件本身以及开发者）代码行数、圈复杂度、结构：高内聚低耦合、可读性、可理解性、整洁度、大小 折中、妥协 完整性与易用性;经济性与功能性；效率与可移植性；效率与可复用性；经济与可复用性；经济性与可扩展性这些质量属性之间往往不能兼得，当某一项满足的足够好的时候有可能其他项的表现极差，因而需要做权衡，使得各部分的表现都较好，在某些特定要求下也可以放弃优化其他项而做到某一项的极致，这需要靠开发者的经验积累来判断。 正确性决不能折中。 在OOP开发中，通过封装、模块化、组件、抽象、分散、错误处理、信息隐藏、框架、接口等技术来尽可能地满足上述地质量因素，提高软件的开发质量。 2.五个关键的质量指标Elegantandbeautifulcode：代码要容易理解，通过统一变量/方法的命名标准、代码的风格、注释、包组织结构、必要时重构代码等方式让代码尽可能的容易理解。Designfor/withreuse：ADT/OOP、接口、继承(Overload、Override)、多态、泛型、框架等技术可用于提高代码的可复用性。Lowcomplexity：当复杂度较低的时候，代码就容易被扩展新的功能，所以要高内聚低耦合，遵从SOLID原则、OO设计模式、使用VCS控制代码版本Robustnessandcorrectness：使用测试驱动的开发、异常处理、Assertion机制、防御式编程等技术保证程序的健壮性和正确性。Performanceandefficiency：使用设计模式、并行/多线程等技术提升性能。 
第284篇文章[0]
软件构造复习笔记4 数据类型与类型检验 编程语言的数据类型​在Java中，数据类型分为基本数据类型(int、boolean、char等)和对象数据类型(String、Integer等)。所有的基本数据类型都是Immutable的，而且在栈中分配内存，代价也比较低。而对象数据类型有的是Immutable的，有的是Mutable的，分配的内存都在堆中，代价相对昂贵。因此在能使用基本类型的情况下尽量使用基本数据类型，降低代价。 对象数据类型是OOP的核心，由于对象数据类型存在继承(extends)机制，因此在OOP中可以更好的复用代码。 基本类型被包装为对象类型，通常只有在定义集合的时候使用，其他情况下尽量避免使用。基本类型和对象类型之间一般可以自动转换。2.类型检查静态类型语言可执行静态类型检查，在编译阶段进行类型检查，这意味着避免了将错误带入到运行阶段，可以提高程序的正确性/健壮性，例如语法错误、类名/函数名错误，参数类型或数目错误、返回值类型错误都可以在静态类型检查时发现；动态类型语言(python)只有动态类型检查，在运行阶段才会进行类型检查，例如非法的参数值(最典型的NULL引用)、非法的返回值、越界等等。（简言之编程时就会报错） 静态类型检查是关于数据类型的检查，它不会关心具体的值，而动态类型检查是关于值的检查。 例如intn=1.1在静态类型检查的时候就会报错，但doublea=0;doubleb=2/a;只有在运行之后，执行动态类型检查的时候才会报告除零错。3.关于不可变性改变变量：使变量指向存储着另一个值的空间 改变变量的值：变量指向的空间不变，变化的是存储的内容。 Immutability：不变性，一个重要的设计原则，设计ADT时尽量保证这个原则。 Immutabletypes：不可变的数据类型，当实例对象被创建以后，该对象的值就不可变化了，也就是该ADT中不能有mutator方法。 在编写程序的时候使用final关键字可以保证该变量不可再被改变，但不能保证该变量的值不变。所以，尽量使用final变量作为方法的输入参数、作为局部变量。 final类无法派生子类 final变量无法改变值/引用 final方无法被子类override(重写) 比较immutable和mutable不变对象：一旦被创建，始终指向同一个值/引用可变对象：拥有方法可以修改自己的值/引用可变对象的优点：虽然mutable类型由于指向的是同一个存储区域，所以更改对象的内容后会在意想不到的位置产生意想不到的变化，所以更推荐使用Imutable的数据类型，但是使用不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收)，比如依次将‘a’~‘z’连接到一个空字符串上，就会产生25个临时拷贝，而使用可变类型则最少化拷贝以提高效率。 使用可变数据类型，可获得更好的性能。但是在质量指标中，性能的优先级较低，所以即使mutable类型有这个优点也更倾向于选择imutable的类型。 也适合于在多个模块之间共享数据。在这里强烈不推荐使用Globalvariables。 设计规范 为什么要写注释？因为单靠代码自己无法把开发者的设计决策全部清晰直观地表现出来，如final关键字本身就是一种设计决策，开发者很容易理解，但这个的只要目的不是为了给人读，是为了给编译器读，如果未来程序员对这个部分做了什么改动，编译器可以很快的在静态代码分析中就能发现错误，避免错误带入后面的开发中，而只有注释，才能够让其他人清晰的看到这部分干了什么，甚至是怎么实现的等等信息。为什么要写spec？spec是程序员自己对所写的方法的规约，它规定了方法应该做什么，不应该做什么，有了spec就可以编写测试用例了，因为程序员所编写的代码必定是符合spec的，否则就是不合格的，符合spec的代码也必然能通过根据spec所设计出的测试。同时，有了spec，客户端在使用所写的代码时就有所依据，客户端可以轻松的知道他需要为这个方法提供什么样的参数，以及会得到什么样的结果，而不必知道内部逻辑是怎么样的，大大节省了客户端使用自己的API时所需要的时间，并且大大降低了客户端对自己所编写的代码的误解。而且，拥有精确的spec，有助于区分责任，很容易地就可以找到是哪一部分的代码出了问题。最后，由于客户端并不需要了解内部的实现也就意味着你可以在满足spec的大前期下对实现方法进行任意的改动而不需要告知客户端，因为无论你怎么改，只要满足spec，在客户端看来，你的行为(作用)都是相同的。spec的结构precondition前置条件：对客户端的约束，在使用方法时必须满足的条件使用@paramannotation说明每个参数的前置条件postcondition后置条件：对开发者的约束，方法结束时必须满足的条件使用@returnannotation说明后置条件使用@throwsannotation说明出现异常的时候会发生什么在方法声明中使用static等关键字声明，可据此进行静态类型检查当客户端满足前置条件的时候，结果必须满足后置条件；当前置条件不满足的时候，方法内部可以做任何事情，但作为开发者，应该尽量让程序做到failfast。 spec不能有什么？ spec不能暴露实现细节，不应该暴露局部变量，也不应该暴露私有的数据域，这些东西一旦暴露，就有可能给被非法的程序员利用，发现漏洞并实施攻击。 注意：方法不应该改变输入参数的取值，如果改了，则必须在spec中做出说明。所以不推荐使用mutable的对象。另外，我们无法强迫类的实现体和客户端不保存可变变量的“别名”，因此，如果直接返回本来的mutable对象，客户端可能修改它的值造成内部实现的错误，同样，如果返回了的是原来mutable对象的拷贝，虽然内部不用再担心客户端的更改影响到自己，但客户端无法知道内部是否保留了被返回的拷贝的别名，因此双方无法完全的信任彼此，故而不推荐使用mutable类作为返回值类型。 spec的评判标准评判哪个规约更好的三个方面：规约的确定性、规约的陈述性、规约的强度 重点是规约的强度的判断，spec变强的要求是更宽松的前置条件+更严格的后置条件，在这种情况下，就可以用变强了的spec去替换原来的spec。越强的规约，意味着实现者的自由度和责任越重，而客户的责任越轻。 强的spec可以替换弱的spec，这一点会在第4章的LSP中得到应用 用椭圆表示spec的强度 如下图，大椭圆表示更弱的spec，小椭圆表示更强的spec，椭圆的大小表示的是开发者的自由度，小椭圆有更强的后置和更弱的前置，因此所包含的结果的点就少，所以就小。 ADT ADT的操作Creators构造器：用于使用new关键字创建一个新的对象。还有一种方法是静态方法，如Arrays.asList()、String.valueOf(ObjectObj)等。 Producers生产器：用于使用一个存在的对象产生一个新的对象，例如String.concat()就是使用已存在的字符串构造出一个新的对象，而且不会改动原先存在的对象。 Observers观察器：不对数据做任何改动，只是查看一个已经存在的对象的各个值，如List.size()、所有的getter方法等。 Mutators变值器：用于改变对象属性的方法，如List.add()。mutator通常返回void，因为它不需要对外界做出反应，只是对ADT的数据域做了更改；mutator也可能返回非空，比如返回boolean表示修改成败等。 设计ADT设计一个好的ADT需要靠开发者的经验来设计它的操作的spec，设计一个ADT要遵循下面三个原则：（1）设计简洁一致的操作（2）要足以支持client所需要的对数据的所有操作，且用操作的难度要低（3）要么抽象要么具体，不要混合 要么针对抽象设计，要么针对具体应用的设计。 实现一个ADT的三个部分：specification、representation、implementation RepresentationIndependence表示独立性client不应该知道内部的数据域是怎么实现的，最好client只能通过ADT提供的getter方法获得ADT存储的数据。 client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。其目的一个是为了便于未来的升级和维护，当内部发生变化的时候不会影响到client。 测试ADT因为测试相当于client使用ADT，所以它也不能直接访问ADT内部的数据域，所以只能调用其他方法去测试被测试的方法。 针对creator：构造对象之后，用observer去观察是否正确 针对observer：用其他三类方法构造对象，然后调用被测observer，判断观察结果是否正确 针对producer：produce新对象之后，用observer判断结果是否正确 RepInvariant(RI)andAbstractionFunction(AF)Invariants：不变量，与程序运行无关，在任何时候都应该满足的一些条件 两个空间R和A：R空间是ADT的内部表示的空间，A空间是ADT能够表示的存在于实际当中的对象。ADT的开发者关注的是R空间，client关注的是A空间。 AbstractionFunction：从R空间到A空间存在一个映射，这个映射是一个满射，这个映射将R中的每一个值解释为A中的一个值。这个解释函数就是AF。 RepInvariant：这是一个集合，是R空间所有值的子集，它包含了所有合法的表示值，而只有满足RI的值，才是合法值，才会在A空间内有值与其对应。 相同的R空间有肯能会有不同的RI。 即使是同样的R、同样的RI，也可能有不同的AF，即“解释不同”。 checkRep()：用于随时检查RI是否满足。使用assert检查RI，在所有的方法最好都加入调用这个检查方法。checkRep()在检查时有可能耗费大量的时间影响性能，所以只需要在开发阶段保留这部分。 表示泄露：client可以拿到数据域的本身或别名。一旦表示泄露，client就有可能无意间改动数据，而如果在设计中，要求一个ADT是Immutable的，而如果它出现了表示泄露，就有可能违反Immutable的原则。 DocumentingtheAF,RI,andSafetyfromRepExposure在代码中用注释的形式记录AF（如何解释每个R值）和RI（rep中哪些数据是有效的）。 
第285篇文章[0]
软件构造复习笔记8 可维护性 可维护性的指标软件维护的类型：纠错性维护(25%)、适应性维护(21%)、完善性维护(50%)、预防性维护(4%) 可维护性(Maintainability)、可扩展性(Extensibility)、灵活性(Flexibility)、可适应性(Adaptability)、可管理性(Manageability)、支持性(Supportability)这些指的都是可维护性。 评判可维护性的一些方面： 设计结构足够简单；模块之间松散耦合；模块内部高度聚合；不要使用了非常深的继承树，尽量使用delegation替代继承；代码的圈复杂度不能太高；不存在重复代码2.模块化设计原则目的：高内聚低耦合；分离关注点(通过delegation等机制分离功能)；信息隐藏(避免表示泄露、静态工厂方法等等) 评估模块化的五个标准： 可分解性(Decomposability)：让复杂的功能分解成一个个ADT完成可组合性(Composability)：让一个个ADT组合完成复杂的功能可理解性(Understandability)：OOP是面向世界上存在的事物编程，所以容易被理解可持续性(Continuity)：发生变化时使得受影响范围最小出现异常之后的保护(Protection)：出现异常后使得受影响范围最小模块化设计的五个原则： DirectMapping(直接映射)FewInterfaces(尽可能少的接口)SmallInterfaces(尽可能小的接口)ExplicitInterfaces(显式接口)InformationHiding(信息隐藏)高内聚低耦合 高内聚：模块内部的功能之间的联系要紧密，无关的功能之间要分离成不同的模块 低耦合：模块之间的关系要越松散越好 SOLID设计原则SOLID原则： (SRP)TheSingleResponsibilityPrinciple---------单一责任原则(OCP)TheOpen-ClosedPrinciple-------------------开放-封闭原则(LSP)TheLiskovSubstitutionPrincipleLiskov----替换原则(DIP)TheDependencyInversionPrinciple--------依赖转置原则(ISP)TheInterfaceSegregationPrinciple----------接口隔离原则单一责任原则(SRP)一个类，一个责任 尽可能地将功能分割，以达到不应该有多于一个原因让你的ADT发生变化的目的，否则就要拆分开。如果多个责任（功能）放在一个类中就有可能在未来某一个功能发生变化的时候影响到整个类，从而影响到整个程序的很大一部分实现（需要全部重新编译打包部署）。 开放-封闭原则(OCP)对扩展性的开放，对修改的封闭 在未来对功能进行修改或者扩展的时候，要遵循尽量不去改动已有的代码而是扩展出新的类然后调用新的类的原则。 典型的违反OCP的例子是大量的使用if-else/switch-case语句，这给维护造成了极大的麻烦。所以应对的方法是让客户端传入接口的不同子类型，而在ADT中只需要统一的调用接口中共有的方法即可。 替换原则(LSP)子类型必须能够替换其基类型 代价是失去了子类型扩展出的功能。 依赖转置原则(DIP)具体的模块应该依赖于抽象的模块，但抽象的模块不应依赖于具体的模块 使用接口隔离应用层和实现层，client面向接口编程。 接口隔离原则(ISP)大接口分解为多个小的接口 客户端不应依赖于它们不需要的方法，不同的接口向不同的客户端提供服务，客户端只访问自己所需要的接口面向可维护性的编程 FactoryMethod工厂方法解决的问题：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。 定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。 当然也可以通过直接定义静态工厂方法来创建子类实例。 AbstractFactory抽象工厂解决的问题：当client需要的是多个具有固定搭配的类的组合，如A和B两个系列的类，A1搭配B1，A2搭配B2，于是，就要用抽象工厂对其做一次封装。 定义一个用于创建对象的接口，让其子类来决定实例化哪一组类，从而使类与类之间的搭配对于client来说固定了。 本质上，AbstractFactory是把多类产品的factorymethod组合在一起 Proxy代理模式解决的问题：某个对象比较“敏感”/“私密”/“贵重”，不希望被client直接访问到，故设置proxy，在二者之间建立防火墙。 创建一个代理类，它接受client的功能请求，然后把功能请求转发(delegate)给实现类，类似于Adapter模式。4.Observer观察者模式解决的问题：“粉丝”对“偶像”感兴趣，希望随时得知偶像的一举一动。 粉丝到偶像那里注册，偶像一旦有新闻发生，就推送给已注册的粉丝（回调callback粉丝的特定功能）。这是一个双向delegate的关系，5.Visitor解决的问题：对特定类型的object的特定操作(visit)，在运行时将二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类。 为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT 
第286篇文章[0]
软件构造复习笔记3 1.软件开发生命周期 1.从无到有；从有到好2.传统软件过程模型：基本类型有线性过程(Linear)和迭代过程(Iterative)，目前存在的模型有瀑布过程(waterfall)，增量过程(incremental)，V字模型(V-model)，原型过程(prototyping)，螺旋模型(spiral)。 3.敏捷开发：Agile=增量+迭代 将任务划分成一个个小规模的任务，因此较小的团队也能够适应大规模软件的开发。在每个小步骤的迭代中，用户可以参与开发，软件可以随时修正，质量因此得到了保证。因此，敏捷开发是一次次小迭代，将任务细分成一个个小任务，在每个小任务上完成迭代。 4.极限编程：关注于测试驱动的开发(TDD)，自动化构建、持续集成、持续交付。（迭代：开发出来之后由用户试用/评审，发现问题反馈给开发者，开发者修改原有的实现，继续交给用户评审。循环往复这个过程，直到用户满意为止。时间代价高，但开发质量也高。） 2.软件配置管理(SCM)和版本控制系统(VCS) 软件配置管理是为了追踪和控制软件的变化，而软件中发生变化的基本单元，如文件，就被成为软件配置项(SCI)。 当软件在开发过程中达到了一个稳定的状态，如可以对外发布的状态，此时的文件组成了基线(Baseline)。 为了存储各配置项随时间变化的信息和基线信息，就有一个数据库来管理这些内容，即配置管理数据库(CMDB)。 VCS：本地版本控制系统（无法协作）存储在本地、集中式版本控制系统（支持协作但没办法抵抗服务器崩溃导致无法开发的风险）存储在服务器上、分布式版本控制系统（解决了前两者的问题，代价是存储空间）同时存储在本地和服务器。 （基线：软件持续变化过程中的“稳定时刻”）版本：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识” 3.git 创建：gitinit 暂存：gitadd 提交：gitcommit-m“commitmessage” 链接：gitremoteaddorigin 推送：gitpush-uoriginmaster 创建分支：gitcheckout-b 切换分支：gitcheckout 合并分支：gitmerge 删除分支：gitbranch-d git中的四个区域：workspace、stagingarea、Localrepository、Remoterepository git的存储结构是一张有向无环图，每次commit在图上会增加一个新的节点，并将HEAD指向这个节点。通常一个子节点有一个父节点，当一个父节点有多个子节点时表明创建了分支，一个子节点有多个父节点时表明进行分支合并。 git单个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。 传统VCS存储的是文件每个版本之间的变化，这种办法的优点是存储空间较小，但由于存储的只是变化，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。git存储的则是文件，所以取出特定版本的文件比较方便，但是代价的是空间复杂度较高。 关于分支的合并：对于合并操作来说，如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的指针移到做过更改分支的指针的位置。 通常软件构造过程(1)Programming：有编程语言，也有建模语言，如UML，还有配置语言，如XML、JSON。 (2)Codereview、Staticcodeanalysis：可以使用工具来发现bug，如CheckStyle,SpotBugs。 (3)Testing：测试，单元测试、集成测试、系统测试… (4)Debugging：调试 (5)Dynamiccodeanalysis/profiling：在程序运行的过程中查看并发现问题，本课程不涉及这部分 (6)Refactoring：重构不改变功能，只是处于更容易维护的目的对代码优化 (7)Build：第2部分 狭义的软件构造过程(Build)这是一个借助于工具，将软件构造过程中大的各阶段的活动自动化的过程，尽可能地脱离人工，以提高构造效率。 常用的工具：Jenkins、Make、Ant、Maven、Gradle 利用工具完成项目的自动化构建、测试、打包release等功能，完成buildtime–>runtime。 
第287篇文章[0]
软件测试复习笔记 软件测试与测试优先的编程 对软件测试进行复习。即使是最好的测试也无法达到百分之百的无错。好的测试：能发现错误。不冗余；最佳特性；别太复杂也别太简单。Testinglevels：单元测试（函数级别）；集成测试（包，类，等等）；系统测试（最终测试）。静态测试；静态测试通常是隐含的，作为校对，加上当编程工具/文本编辑器检查源代码结构或编译器(预编译程序)检查语法和数据流作为静态程序分析。（没有实际运行）动态测试：动态测试描述了对代码的动态行为的测试，它实际上是用给定的一组测试用例来执行编程代码。-动态测试可以在程序100%完成之前开始，以便测试特定部分的代码，并应用于离散的函数或模块。-这方面的典型技术是使用存根/驱动程序或从调试器环境执行。先测试，在调试。白盒测试：对程序内代码结构的测试黑盒测试黑盒测试##对程序外部行为进行的测试。想要进行好的测试，就要抱着想要另其出错的态度。 测试用例 测试用例：输入+执行条件+期望结果测试用例是为特定目标而开发的，例如执行特定的程序路径或验证对特定需求的遵从性。测试用例可能只是您对程序提出的一个问题。运行测试的目的是获取信息，例如，程序是否通过测试。测试用例是质量保证的基石，而测试用例是为了验证产品的质量和行为而开发的。 测试优先的编程 先写spec（规约）再写符合spec的测试用例测试，修改，通过。先写测试更为方便。 单元测试 针对软件的最小单元模型进行测试 Junit测试 junit是一个单元测试框架。junit单元检测仪@test为注释利用断言等方法进行检测，1.assertEquals测试两个对象是否相等，该断言不能用于数组的比较，数组的比较用assertArrayEquals2.assertArrayEquals测试两个数组是否相等3.assertTrue，assertFalseassertTrue和assertFalse用于测试boolean变量的值为true还是false4.assertNull，assertNotNullassertNull和assertNotNull用于测试变量的值是否为null5.assertSame，assertNotSameassertSame和assertNotSame用于测试两个对象的引用是否相同6.assertThatassertSame和assertNotSame用于测试两个对象的引用是否相同 黑盒测试 检查程序是否符合规约 通过分区选择测试用例 基于等价类划分的测试：将被测函数的输入域划分为等价类，从等价类中导出测试用例。针对每个输入数据需要满足的约束条件，划分等价类 代码覆盖度 代码覆盖度：已有的测试用例有多大程度覆盖了被测程序码覆盖度越低，测试越不充分但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高 
第288篇文章[0]
软件构造复习笔记7 复用 面向复用编程面向复用编程(programmingforreuse)：开发可以复用的软件 基于复用编程(programmingwithreuse)：复用已有的软件开发 为了降低成本和开发时间，提出了面向复用的编程，所有面向复用的代码都应该经过充分的测试，以保证它的可靠性和稳定性（不能在未来使用的时候发现一堆bug，那就白干了），而因为它是面向复用的，所以在不同的应用里可以保持一致的表现，也就是说对此功能做了标准化。 可复用性的评估 评估的方面：复用的频繁性、复用的代价(适配) 一个有高可复用性的代码应该有如下特点：小、简单；与标准兼容；灵活可变；可扩展；泛型、参数化；模块化；变化的局部性；稳定；丰富的文档和帮助。 复用的层面最主要的复用是在代码层面，这也是我们所关注的，但软件构造过程中的任何实体都可能被复用（需求、spec、数据、测试用例、文档等等） 源代码层面：方法、语句… 模块层面：ADT(类和接口) 库层面：API，如.jar文件 架构层面：框架 复用分为白盒复用和黑盒复用，白盒复用意味着源码是可见的，对我们来说意义不是很大，更多的是源码不可见的黑盒复用，只有这样才能隔离客户端和ADT的内部实现。 源代码层面的复用可以在网络上寻找自己需要的代码，但要注意开发商用的软件不能直接复制开源的代码，避免引起法律纠纷。 模块层面的复用通过继承(Inheritance)的方式复用父类的代码，同时也可override父类中已存在的方法。另一个复用的方法是委托(delegation)，详见下一小节(4.2)。库层面的复用通过导入库来调用库中的API完成复用。 除了导入本地库，也可以通过导入部署在网络上的库来完成复用，如WebServices/RestfulAPIs 架构层面的复用框架：一组具体类、抽象类、及其之间的连接关系。开发者可以根据spec填充自己的代码从而形成完整的系统。开发者根据Framework预留的接口所写的程序，而Framework作为主程序加以执行，执行过程中调用开发者所写的程序。关于框架详见下一小节4.2.3。 黑盒框架：通过实现特定接口/delegation进行框架扩展白盒框架：通过代码层面的继承进行框架扩展Liskov替换原则(LSP)子类型多态子类型多态：客户端可用统一的方式处理不同类型的对象。例子类对象取代父类对象而不会产生任何问题。 LSPLiskovSubstitutionPrinciple中子类重写父类的方法应该满足的条件： 编译器在静态类型检查时强制满足的条件 子类型可以增加方法，但不可删除子类型需要实现抽象类型中的所有未实现方法子类型中重写的方法返回值必须与父类相同或符合co-variance(协变)子类型中重写的方法必须使用同样类型的参数或者符合contra-variance(逆变)的参数子类型中重写的方法不能抛出额外的异常还应该满足的条件 更强的不变量(RI)更弱的前置条件更强的后置条件协变关于返回值的类型，应该保持不变或者变得更具体，也就是与派生的方向一致。 所抛出的异常的类型也是如此。 classT{Objecta(){…}voidb()throwsThrowable{…}}classSextendsT{@Override//返回值从Object协变成了String，这是符合重写的语法的Stringa(){…}@Override//抛出的异常从Throwable协变成了IOException，这也是符合重写的语法的voidb()throwsIOException{…}} 逆变关于参数的类型，应该保持不变或者变得更抽象，也就是与派生的方向相反。 classT{voidc(Strings){…}}classSextendsT{@Override//虽然按照LSP这是合法的，但是在java语法中，不当作override，而是overloadvoidc(Objects){…}} 类型擦除(泛型中的LSP)泛型类型是不支持协变的，如ArrayList是List的子类型，但List不是List的子类型。这是因为发生了类型擦除，运行时就不存在泛型了，所有的泛型都被替换为具体的类型。 但是在实际使用的过程中是存在能够处理不同的类型的泛型的需求的，如定义一个方法参数是List类型的，但是要适应不同的类型的E，于是可使用通配符?来解决这个需求。组合与委托委派/委托：一个对象请求另一个对象的功能。 一个使用Comparator接口实现delegation的例子： publicclassEdge{Vertexs,t;doubleweight;…}publicclassEdgeComparatorimplementsComparator{@Overridepublicintcompare(Edgeo1,Edgeo2){if(…>…)return1;elseif(…<…)return-1;elsereturn0;}}publicvoidsort(Listedges){Comparatorcomp=newEdgeComparator();Collections.sort(edges,comp);//把比较的功能分离出来单独委派给了一个类} 实现比较功能还有另一种方式，让ADT实现Comparable接口然后override该接口的comparaTo()方法，但是这种方法就不再是delegation了。 选择继承还是委派？ 如果子类只需要复用父类中的一小部分方法，可以不需要使用继承，而是通过委派机制来实现，也就是说一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法。 委托发生在object层面(朋友关系)，而继承发生在class层面(父子关系) 四种委派方式Dependency：依赖关系，临时性的delegation。把被delegation的对象以参数方式传入。只有在需要的时候才建立与被委派类的联系，而当方法结束的时候这种关系也就随之断开了。 //如果要让鸭子用其他方式叫(或飞)只需更换new的q(f)的类型即可Flyablef=newFlyWithWings();//使用翅膀飞行的飞行方式Quackableq=newQuack();//鸭叫声的叫声Duckd=newDuck();//一只鸭子d.fly(f);//让鸭子飞d.quack(q);//让鸭子叫 classDuck{//nofieldtokeepFlyableobjectpublicvoidfly(Flyablef){f.fly();}//让这个鸭子以f的方式飞publicvoidquack(Quackableq){q.quack()};//让鸭子以q的方式叫} Association：关联关系，永久性的delegation。被delegation的对象保存在rep中，该对象的类型被永久的与此ADT绑定在了一起。 //法一：在构造方法中传入参数绑定Flyablef=newFlyWithWings();Duckd=newDuck(f);d.fly();classDuck{Flyablef;//这个必须由构造方法传入参数绑定publicDuck(Flyablef){this.f=f;}publicvoidfly(){f.fly();}}//法二：在rep或构造方法中直接写死Duckd=newDuck();d.fly();classDuck{//这两种实现方式的效果是相同的Flyablef=newFlyWithWings();//写死在rep中publicDuck(){f=newFlyWithWings();}//写死在构造方法中publicvoidfly(){f.fly();}}Composition:更强的association，但难以变化。也就是Association中的法二。 Aggregation:更弱的association，可动态变化。也就是Association中的法一。 上面所说的都是一对一的delegation，也存在一对多的delegation，只需要在rep中保存所有被委派的对象即可。 组合CompositeReusePrinciple(CRP)利用delegation的机制，将功能的具体实现与调用分离，在实现中又通过接口的继承树实现功能的不同实现方法，而在调用类中只需要创建具体的子类型然后调用即可。组合就是多个不同方面的delegation的结合。 接口的具体子类型又可以通过静态工厂方法隐藏。 抽象层是不会轻易发生变化的，会发生变化的只有底层的具体的子类型，而具体功能的变化（实现不同的功能）也是在最底层，所以抽象层是稳定的。而在具体层，两个子类之间的委派关系就有可能是稳定的也有可能是动态的，这取决于需求和设计者的设计决策。 上图中所存在的子类与父类的替换只有在满足LSP的前提下才能存在，不满足LSP就没有这种delegation机制了。六种设计模式：Adapter、Decorator、Facade、Strategy、Templatemethod、Iterator Adapter适配器模式目的是将某个类/接口转换为client期望的其他形式。通过增加一个接口，将已存在的子类封装起来，client面向接口编程，从而隐藏了具体子类。 因为Adaptee是不匹配客户端所需求的，可能是参数上的，所以此时就需要一个中间件来做客户端和Adaptee之间的适配工作，这就是Adapter，它接受客户端的功能请求但是不会做具体的功能实现，而是把客户端所提供的参数转换成Adaptee所接受的形式，然后将任务委派给Adaptee完成。 Decorator装饰器模式你即将开始无限套娃之旅 每个子类实现不同的特性，因为这些特性都是多个维度上的个性化的特征，没办法做到在一个顶层的接口中完成所有特征的抽象，而且需要做到在各个维度上的特性的任意组合，此时光靠继承是没办法实现特性的组合的，如果要强行使用继承实现，那么面对的一个不可避免地问题是组合爆炸，因为每次继承只能扩展一个特性，多个特性就要多次继承实现，并且也不便于维护与扩展，而且会有大量的重复代码。 因此，提出了Decorator设计模式，为对象增加不同侧面的不同特性。 装饰器模式的原理是从接口派生出子类，然后在子类中定义一个父类接口然后将其作为delegation的对象，也就是说：自己到自己的委派。这里第一个自己指的是子类型本身，第二个自己是指该接口的其他子类，由于他们两个是同一个接口的子类，所以可以称为自己到自己的委派。 下图中，Component是一个接口，接口中是公共的特性，ConcreteComponent是这个接口的基本实现，没有任何个性。Decorator是接口的一个抽象实现，它解决了委派关系的建立问题，从它派生出的诸多子类可以实现各个单独的特性而不必考虑所需要的其他特性如何在本类中实现，这些问题都通过delegation机制交给了其他子类完成。 如果你没看懂，不要担心，看看下面的例子吧 一个使用装饰器模式设计的例子 //Stack接口，定义了所有的Stack共性的基础的功能interfaceStack{voidpush(Iteme);Itempop();}//最基础的类，啥个性也没有的Stack，只有共性的实现publicclassArrayStackimplementsStack{…//reppublicArrayStack(){…}publicvoidpush(Iteme){…}publicItempop(){…}}//装饰器类，可以是一个抽象类，用于扩展出有各个特性方面的各个子类publicabstractclassStackDecoratorimplementsStack{protectedfinalStackstack;//用来保存delegation关系的reppublicStackDecorator(Stackstack){this.stack=stack;//建立稳定的delegation关系}publicvoidpush(Iteme){stack.push(e);//通过delegation完成任务}publicItempop(){returnstack.pop();//通过delegation完成任务}}//一个有撤销特性功能的子类publicclassUndoStackextendsStackDecoratorimplementsStack{privatefinalUndoLoglog=newUndoLog();publicUndoStack(Stackstack){super(stack);//调用父类的构造方法建立delegation关系}publicvoidpush(Iteme){log.append(UndoLog.PUSH,e);//实现个性化的功能super.push(e);//共性的功能通过调用父类的实现来完成}publicvoidundo(){//implementdecoratorbehaviorsonstack}…} 使用装饰类，通过一层一层的装饰，让得到的对象最终能够拥有任意不同特性的组合，这才是decorator模式最精妙的地方。而且装饰的顺序是不会影响到对象的最终结果拥有哪些特性的，影响到的唯一地方在于最终得到的是哪个类型的对象，也就是最后一次装饰的特性决定了最终得到哪个具体类型的对象。 简直神来之笔 //先创建出一个基础类对象Stacks=newArrayStack();//利用UndoStack中继承到的自己到自己的委派建立起从UndoStack到ArrayStack的delegation关系//这样，UndoStack也就能够实现最基础的功能，并且自身也实现了个性化的功能Stackus=newUndoStack(s);//通过一层层的装饰实现各个维度的不同功能Stackss=newSecureStack(newSynchronizedStack(us)); JDK中装饰器模式的应用：staticListunmodifiableList(Listlist)、staticSetsynchronizedSet(Setset); Facade外观模式客户端在调用的API时候会以固定的方式调用一系列的方法，而为了简化客户端的使用，便于客户端的学习使用、解耦，所以需要提供一个统一的接口来取代一系列小接口调用，对复杂系统做了一个封装。 经过封装得到的一个方法通常是静态方法，因为客户端可以直接调用这个方法而没必要new一个对象。 Strategy策略模式有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里。因此可以为不同的实现算法构造抽象接口，利用delegation，运行时动态传入client倾向的算法类实例。 ConcreatestrategyA和ConcreateStrategyB是Strategy接口的两种不同的实现，客户端在运行时可选择任意一种来完成功能。在方法中只需要留出一个Strategy接口类型的参数，客户端选择具体类型后传入即可。 TemplateMethod模板模式做事情的步骤一样，但具体方法不同，因此共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现。使用继承和重写实现模板模式。 在模板中，实现了一个固定执行一系列操作的方法，这个方法使用final关键字做了限定，不能再被子类重写，因此，子类只能通过重写该方法调用的那些尚未实现的方法。 在上一节中提到的白盒框架就是用这种技术实现的 Iterator迭代器模式客户端希望遍历被放入容器/集合类的一组ADT对象，而无需关心容器的具体类型，也就是说，不管对象被放进哪里，都应该提供同样的遍历方式 实现方式是在ADT类中实现Iterable接口，该接口内部只有一个返回一个迭代器的方法，然后创建一个迭代器类实现Iterator接口，实现hasnext()、next()、remove()这三个方法。 一个迭代器的实例： publicclassPairimplementsIterable{privatefinalEfirst,second;publicPair(Ef,Es){first=f;second=s;}publicIteratoriterator(){returnnewPairIterator();}privateclassPairIteratorimplementsIterator{privatebooleanseenFirst=false,seenSecond=false;publicbooleanhasNext(){return!seenSecond;}publicEnext(){if(!seenFirst){seenFirst=true;returnfirst;}if(!seenSecond){seenSecond=true;returnsecond;}thrownewNoSuchElementException();}publicvoidremove(){thrownewUnsupportedOperationException();}}//使用隐式方法迭代publicstaticvoidmain(String[]args){Pairpair=newPair(“foo”,“bar”);for(Strings:pair){…}}} 
第289篇文章[0]
软件构造复习笔记5 OOP set.contains(list);//false!//甚至还有如下神奇的事情for(Listl:set)set.contains(l);//false小心：如果某个mutable的对象包含在Set集合类中，当其发生改变后，集合类的行为不确定。 在JDK中，不同的mutable类使用不同的等价性标准： Date.equals()、List.equals()实现的是观察等价性。 StringBuilder.equals()实现的是行为等价性，它的equals()方法实际上是直接继承自Object类。 equals()和hashCode()所以，对可变类型，实现行为等价性即可，也就是说，只有指向同样内存空间的对象才是相等的。所以对可变类型来说，无需重写这两个函数，直接继承Object的equals()和hashCode()即可。 自动封装手动封装的结果： Integerx=newInteger(3);Integery=newInteger(3);x.equals(y);//truex==y;//false(int)x==(int)y;//true 自动封装的结果： Map<String,Integer>a=newHashMap<>(),b=newHashMap<>();a.put(“c”,130);//被自动转换成了Integerb.put(“c”,130);a.get(“c”)==b.get(“c”);//false，get获得的是Integer，并不会自动转换成原始的inta.get(“c”).equals(b.get(“c”));//true 特殊情况： Map<String,Integer>a=newHashMap<>(),b=newHashMap<>();a.put(“c”,1);b.put(“c”,1);a.get(“a”)==b.get(“a”);//true 原因：JVM为-128~127分配的空间位于常量池中，所以即使被自动封装成了对象类型也可以用==判断相等。 Integerx=2;Integery=2;x==y;//true/*仅限于上面的方式创建的对象，通过new创建的对象不行*/Integerx=newInteger(2);Integery=newInteger(2); 
第290篇文章[0]
Java中的List类的contains和indexOf方法的区别 问题： 在对List类的使用中，有一次使用到了contains和indexOf方法，而出现预期以外的错误，考虑到List中的元素都为引用类型，因此想知道List的contains和indexOf方法的结果是否与引用对象相关。 代码实例如下： importjava.util.ArrayList; importjava.util.List; publicclassTemp { publicstaticvoidmain(String[]args)throwsException { List<String>list=newArrayList<String>(); for(inti=0;i<10;i++){ list.add(String.valueOf(i)); } //使用contains System.out.println(list.contains("5")); //使用indexOf System.out.println(list.indexOf("5")); System.out.println(list.indexOf(newString("5"))); List<People>peoples=newArrayList<People>(); Peoplea=newPeople("a"); Peopleb=newPeople("b"); Peoplenewa=newPeople("a"); peoples.add(a); peoples.add(b); //使用contains System.out.println(peoples.contains(newa)); //使用indexOf System.out.println(peoples.indexOf(newa)); } } classPeople{ privateStringname; /** *@paramname */ publicPeople(Stringname){ this.name=name; } @Override publicinthashCode(){ finalintprime=31; intresult=1; result=prime*result+((name==null)?0:name.hashCode()); returnresult; } @Override publicbooleanequals(Objectobj){ if(this==obj) returntrue; if(obj==null) returnfalse; if(getClass()!=obj.getClass()) returnfalse; Peopleother=(People)obj; if(name==null){ if(other.name!=null) returnfalse; }elseif(!name.equals(other.name)) returnfalse; returntrue; } /** *@returnthename */ publicStringgetName(){ returnname; } } 运行结果如下： 由此可见，如果List的泛型重写了equals方法，则contains和indexOf方法都可以正常工作，而不需要要求参数为List中的同一个引用对象，只需要值相同即可。 而将equals去掉之后，其他代码不变，发现结果如下： 发现contains和indexOf方法都判定newa这个对象不在peoples这个List中。 如果再将此行改为： //使用contains System.out.println(peoples.contains(a)); //使用indexOf System.out.println(peoples.indexOf(a)); 运行结果如下： 结果再一次正确。 总结： contains和indexOf方法是一致的。如果希望值相同就可以在List中找到，则需要重写List<L>的L中的equals方法。如果希望引用相同，则不可以重写L中的equals方法。 
第291篇文章[0]
eclipse使用过程中遇到的问题合集（持续更新中 ） 目录 问题1 JUnit项目无法正确运行 问题2 JUnit配置问题 问题3 在外部修改了文件后无法在eclipse中读取和运行 问题1 JUnit项目无法正确运行 解决方法 方法一：将测试代码文件暂时放入src文件夹中才能执行，在test文件夹中不能执行。 方法二：外部创建的文件夹是普通文件夹，而不是source folder，因此需要在eclipse中创建source file，在这个文件夹中再建立package，再建立.java即可运行。 问题2 JUnit配置问题 解决方法 应该在classPath导入库 注意是在Classpath中加入JUnit库，而不是在Modulepath中加入。 问题3 在外部修改了文件后无法在eclipse中读取和运行 解决方法 在eclipse中删除该文件（注意不要删除磁盘文件），然后点击 Openprojectsfromfilesystem,再点击Directory，选中自己要导入的java文件夹即可。 
第292篇文章[0]
Git将文件提交到远程仓库 本文主要是对git的提交做了一个整理，对于git的起步的安装以及初始化等不再赘述，默认git已经安装完成可以使用。 注意，文中尖括号表示可变的部分，url表示链接地址 一、获取git仓库 1.Git前如果不是在目标文件夹中使用git，那么可以通过cd指令如： $cd/home/user/my_project(linux) $cd/User/user/my_project(macOS) $cd/c/user/my_prject(Windows) 或者是在目标文件夹右键空白位置打开菜单栏里打开gitbash直接就在当前目标文件夹下。 2. $gitinit 该命令在目标文件夹下创建一个名为.git的子目录，这个子目录含有你初始化的git仓库中的必须文件，这些文件是git仓库的骨干。 3.$gitclone<url> 获得一份已经存在的git仓库的拷贝，将git仓库上的文件拷贝到你的本地并且在目录下初始化一个.git文件夹。 4.$gitadd. (别忘了add后有个空格且有个.) $gitcommit-m“<name>” 将目标文件夹中的文件进行版本控制，并初步提交到本地git仓库。 二、git远程仓库的使用 1.$gitremote-v 查看远程仓库,会显示需要读写远程操作使用的git保存的简写以及其对应的URL （Ps:gitclone命令货去的git仓库会添加有远程仓库） 2.$gitremoteadd<name><url> 添加一个新的远程git仓库 3.$gitbranch<name> 在本地建立一个新的分支（比如master分支） $gitcheckout<name> 切换到<name>的分支上 （这部分不是很重要，创建新分支时使用） 4.$gitpush<remote><branch>（这个指令也可以将新建的分支push到远程仓库上） 如$gitpushorigin<name>将本地的<name>分支推送到远程仓库上 $gitpushorigin<branch>:<branch> 前一个为本地仓库分支名，后一个为远程仓库的分支名，将本地分支指定推送到远程仓库的某个分支上。 5.Ps：远程仓库的重命名和移除 重命名：$gitremoterename<prename><newname> 移除$gitremoteremove<name> 6.注意分支切换之后会改变HEAD的指向，会指向当前所在的分支，如果进行本地仓库的commit，会导致head指向的分支和head操作自动向前移动，其他分支并没有，会留在切换之前commit的历史，那么这样就可以对项目做出分叉。 7.更多参考资料https://git-scm.com/book/zh/v2 
第293篇文章[0]
spec学习笔记 设计规约 目标：方法的规约 前置/后置条件 欠定规约，非确定规约 陈述式、操作式规约 规约强度及其比较 如何写出好的规约 “方法”是程序的“积木”，可以被独立开发、测试和复用，需要抽象 代码中蕴含的“设计决策”：给编译器度 注释中蕴含的“设计决策”：给自己和别人读 规约给“供需双方”都确定了责任，在调用时候双方都要遵守。 前置条件和后置条件 前置条件：对客户端的约束，在使用方法时必须满足的条件 后置条件：对开发者的约束，方法结束时必须满足的条件 契约：前置条件满足，后置条件必须满足 可以加入@requires和@effects 规约的评价 规约的确定性；规约的陈述性；规约的强度 前置条件和后置条件的切分考虑 强的规约，放松的前置条件和更严格的后置。 欠定规约：同一个输入有多个输出 非确定规约：同一个输入，多次执行时的输出可能不同 操作式规约：伪代码 声明式规约：没有内部实现描述，只有“初-终” 例子 /** * * */ 
第294篇文章[0]
数据类型学习笔记 数据类型：一组值，并且包括可以对齐所做的操作 变量：用特定数据类型定义可以存储满足类型约束的值 基本数据类型：int;long;Boolean;double;char; 对象数据类型：String;BigInteger; 基础类型一般是只有值，没有ID（与其他值无法区分）是不可边的，在栈中分配内存，代价一般较低 对象引用类型：（如classes,interfaces,arrays等）既有自己的ID也有值，分为可变和不可变的，在堆中分配内存，代价一般很昂贵。 对象引用类型能形成层次结构： 比如：继承关系（extends） 可以将基础类型包装为对象引用类型（一般是定义一个集合） 操作符：+-*/等运算；重载：操作符可用于不同数据类型 静态/动态类型检查 静态类型，在编译阶段进行类型检查 语法错误；类名/函数名错误；参数数目错误；参数类型错误；返回值类型错误 动态类型：在运行阶段进行类型检查。 非法的参数值；非法的返回值；越界；空指针 可变/不可变数据类型 改变变量：将该变量指向另一个值的存储空间 改变变量值：将该变量当前指向值的存储空间清除后写入一个新的值 所以在改变变量值的过程中的变化可能产生副作用。 不变性： 不变数据类型：一旦被创建，其值不能改变，包括引用类型，确定其指向的对象就不能再改变。（java中采用final变量作为方法的输入参数和局部变量） 不变对象：一旦被创建，始终指向同一个值（引用） 可变对象：在一些方法下可以修改自己的值/引用 要注意程序中哪些参数在程序始终不发生改变。也尽量避免改变 不可变：需要频繁的修改和产生大量临时的拷贝（需要进行垃圾回收） 可变：减少拷贝提高效率 不可变类型更加安全。 在引用参数时需要注意数据发生的变化，以防发生冒险 
第295篇文章[0]
Junit断言（assert） voidassertArrayEquals(expectedArray,actualArray) 检查两个数组是否相等voidassertEquals(Objectexpected,Objectactual) 检查两个变量（可以为布尔值，可以为文本，也可以为数据）或等式是否平衡voidassertTrue(Booleancondition)检查为真voidassertFalse(Booleancondition)检查为假voidassertNotNull(Objectobject)检查对象不为空voidassertNull(Objectobject)检查对象为空voidassertSame(Objectobject,Objectobject)检查两个对象是否为相同的引用voidassertNotSame(Objectobject,Objectobject)检查两个对象是否为不同的引用voidassertThat(Objectobject,condition) 9.主要都是前一个待测数据是否符合后面的条件，条件有 /*一般匹配符*/ allOf()接下来的所有条件必须都成立 anyOf()接下来的所有条件至少一个成立 anything()不管如何，永远成立 is()与is括号中给出的object相等则通过 not()与not括号中给出的object不等则通过 /*数据匹配符*/ CloseTo()前面的数据在括号中给出的范围之内，括号给出（n,a）表示n±a的范围内 GreaterThan()前面的数据大于括号内的数据 LessThan()前面的数据小于括号内的数据 EqualTo()前面的数据等于括号内的数据，相当于equals方法 /*字符串匹配符*/ containsString()前面的数据中包含指定字符串 startsWith()前面的数据是指定字符串开头 endsWith()前面的数据是指定字符串结尾 /*集合匹配符*/ hasItem()集合中含有指定元素 hasEntry()含有指定的键对 hasKey()含指定键 hasValue()含指定值 
第296篇文章[0]
test测试学习笔记 Softwaretesting （1）提高软件质量的重要手段 （2）确认是否达到用户需求 （3）关注系统的某一侧面的质量特性 当然也要注意，无论什么样的测试，质量有多高的测试，也无法达到100%的没有错误 （4）残留缺陷率（每一千行代码交付后留存的bug） 典型工业软件1-10defects/kloc 高质量的验证0.1-1defects/kloc（java库） 非常高的安全关键认证0.01-0.1defects/kloc(重要的航天控件等) （5）什么是高质量的测试 *能发现错误 *不冗余 *最佳的品类 *别太复杂也别太简单 （6）测试的等级 单元测试->集成测试->系统测试->验收测试 单元测试：验证特定代码部分功能的测试，功能级别 集成测试：多个程序员或者编程团队创建的两个/多个类、包等的组合执行 系统测试：测试一个完整集成的系统，是否满足要求，在最终配置中执行 回归测试：回到上一层级的测试。一旦程序被修改，重新执行之前的所有测试 （7）其他测试种类 略 （8）静态测试和动态测试 静态测试是隐式的，用编程工具和文本检查源代码结构和编译器 检查语法和数据流（用眼睛看） 动态测试可在程序未完成时候进行，测试特定的代码部分。 （9）测试和调试（debug） 测试：发现是否存在错误 调试，识别错误根源，根除错误。 （10）白盒测试和黑盒测试 白盒测试：对程序内部代码结构的测试，程序内部代码可见 黑盒测试：对程序外部表现出来的行为的测试，并不需要看到程序内部代码 testcase（测试用例） 1）测试用例={测试输入+执行条件+期望的结果} 2）写测试->组织测试用例->执行测试用例->获取状态和报告 3. 测试优先编程 1）先写spec->写符合spec的测试用例->写代码、执行测试、有问题再改、再执行。 2）先写测试会节省大量调试时间 3）test-drivendevelopment 在测试中完善。 4．Junit 1）assertEquals()期望值和运行值的比较 2）assertTrue() 3）assertFalse() 4）另外 注意@Test的标识，表示这是一个测试 5.黑盒测试 黑盒测试：检查代码的功能但不关心其内部结构 从规约（程序的规范和需求）出发 测试用例完全由spec导出 6.等价类划分和边界值分析方法 按输入域进行划分 对称，传递，自反 从数值范围，长度，要求等进行划分 主要是考虑边界问题，输入数据的特殊情况，进行边界值的分析方法 程序在边界可能发生一些“突变” 7.白盒测试 需要考虑内部的细节，俺炸程序执行的路径设计测试用例 对所有执行的路径进行等价类划分，找出代表性的最简单路径、每条基本路径至少覆盖一次 8.覆盖度 测试用例多大程度覆盖了被测程序，覆盖度越低，测试越不充分 路径＞分支＞语句（难度和效果） 测试策略：testingstrategy 
第297篇文章[0]
spec简单例子 总是让我们写spec但是究竟该怎么写，那么我们通过例子来看。 比如我们碰到以下代码让我们对他写spec 例子 publicList<String>getSomeLines(intstart,intend){ List<String>some=newArrayList<>(); for(inti=start;i<end;i++){ some.add(lines.get(i)); returnsome; } } 方法getSomeLines（）返回诗的第start行到第end行的文本，我们需要针对该方法设计spec，充分考虑健壮性。 /** *@Paramstartstart需要大于等于0并且小于总行数 *@Paramendend需要大于start并且小于等于总行数 *@return返回从start行到end行之间的行列表 *@throwsNolines没有行抛出异常 *@throwsBoundExceptionstart和end不符合规范 */ 我们就可以根据代码写出如此的比较简单的spec。 
第298篇文章[0]
JAVA异常处理 在上一个博客里面我们有涉及到类似下面的句式，那么它究竟是干什么的以及怎么用。 try{   }catch(Exceptione) {   } 下面我们来探讨一下： 作为看这篇博客的你来讲，代码肯定是很熟悉的东西了，并且人为操作的东西总是有漏洞，体现在代码上面就是异常，错误等。 为此Java提供了异常处理机制来帮助我们检查可能出现的错误。 假设我们运行以下代码： publicclasstest{ publicstaticvoidmain(String[]args){ intresult; result=1/0; System.out.println(result); } } 那么程序就会出现下面的异常，不能正常运行 其中他说的是ArithmeticException：/byzero直接描述给我们是因为在算术表达式中1/0 0作为除数出现，这不符合我们正常的算术表达式，不能继续执行，异常提前退出。 为了保证能够让程序有效的进行，我们需要对发生的异常进行相应的处理。因为当异常产生之后，如果不做任何处理的情况下，程序就会把被终止。 publicclasstest{ publicstaticvoidmain(String[]args){ Stringstr=newString("csdnyyds"); System.out.println(str); intcode_age=Integer.parseInt(str); System.out.println(code_age); } } 再假设我们运行上面的例子，我们已知Integer.parseInt是将非字符型转换为int型，匹配我们定义的code_age。但是运行之后程序会出现以下异常： 和上一次不同，这次报出的是NumberFormatException也就是字符转数字异常。执行转换代码的时候异常终止。 既然我们已经知道了报出异常，那么如何捕捉异常呢？ 这就涉及到我们本次主要介绍的东西 try{   }catch(Exception1e){ 对Exception1的处理 } catch(Exception2e){ 对Exception2的处理 }   finally{ 程序块 } 那么我们把刚才的代码套入trycatch里面 publicclasstest{ publicstaticvoidmain(String[]args){ try{ Stringstr=newString("csdnyyds"); System.out.println(str); intcode_age=Integer.parseInt(str); System.out.println(code_age); }catch(Exceptione){ e.printStackTrace(); } System.out.println("程序执行完毕"); } } 运行结果如下： 虽然还是会报错但是我们的程序不会停止运行。 当在try里面遇到会报错的代码的时候，编译器就会自动去catch里面运行，运行完catch里面之后继续运行接下来的代码也就是System.out.println("程序执行完毕");这不会导致程序因为异常而终止。 另外finally语块是完整的try-catch不可缺少的，无论是否执行try-catch是否顺利执行，都会执行fanally。 抛出异常： 有throws和throw两种方法 //已知代码会发生负数数组异常的前提下我们可以： publicclasstest{ staticvoidpop()throwsNegativeArraySizeException{ int[]array=newint[-10]; } publicstaticvoidmain(String[]args){ try{ pop(); }catch(NegativeArraySizeExceptione){ System.out.println("pop()方法抛出异常"); } } } 运行结果如下： 我们定义了一个负数数组，但是我们可以通过throws关键字抛出异常，不让我们看到异常语句。 另外throw一般用于方法体中，程序在执行到throw语句的时候立刻终止，后面语句不再执行。感兴趣的童鞋可以搜索查看哦 
第299篇文章[0]
Java的继承 类的继承 类的继承，在我理解中有点类似父进程和子进程。 首先继承的基本思想就是基于某个父类进行扩展，得到一个新的子类，子类可以继承父类原有的属性和方法，相应地，也可以增加原来父类所不具有的属性和方法，或者直接重写父类中的方法。 举个例子，例如正方形，是特殊的四边形，因为正方形是四个边都相等的四边形，可以说正方形继承了四边形类。这时，正方形继承了平行四边形所有具有的属性和方法，以及可以基于四边形类所增加的新的平行四边形类的属性和方法。 举例： publicclassTest{ publicTest(){//构造方法 //something.. } protectedvoiddoSomething(){//成员方法 //something.. } protectedTestdolt(){//方法返回值类型为Test类型 returnnewTest(); } } classTest2extendsTest{//继承父类 publicTest2(){//构造方法 super();//调用父类构造方法 super.doSomething();//调用父类成员方法 } publicvoiddoSomethingnew(){//新增方法 //something.. } publicvoiddoSomething(){//重写父类方法 //somenewsentence.. } protectedTest2dolt(){//重写父类方法，方法返回类型为Test2类型 returnnewTest2(); } } 该例子中定义了两个类，其中Test2类继承Test类，可以说Test类为Test2类的父类，Test2为Test的子类。在子类中可以连同初始化父类构造方法来完成子类初始化操作，既可以在子类的构造方法中用super()语句调用父类的构造方法，也可以在子类中使用super关键字调用父类的成员方法等。但是对于父类中的private方法，子类没有权限调用它，只可以调用父类中修饰符为public或者protected的成员方法。例如子类构造方法中可以使用super关键字调用父类的doSomething()方法，因为doSomething方法修饰符为protected。同时在子类中也可以定义一些新的方法，如子类的doSomethingnew（）方法。 继承并不只是扩展父类的功能，还可以重写父类的成员方法。重写还可以成为覆盖，就是在子类中讲父类的成员方法的名称保留，重写成员方法的实现内容，更改成员方法的存储权限，或是修改成员方法的返回类型。 在继承中还有一种特殊的重写方式，子类与父类的成员方法返回值，方法名称，参数类型及个数完全相同，唯一不同你的就是方法实现内容，这种特殊重写方式被称为重构。 publicclassParent{ Parent(){ System.out.println("调用父类的Parent()构造方法"); } } classSubParentextendsParent{ SubParent(){ System.out.println("调用子类的SubParent()构造方法"); } } publicclassSubroutineextendsSubParent{ publicSubroutine(){ System.out.println("调用子类的Subroutine()构造方法"); //TODO自动生成的构造函数存根 } publicstaticvoidmain(String[]args){ Subroutines=newSubroutine(); } } 创建Subroutine类和两个父类，分别为Parent和SubParent。这三个类的继承关系是Subroutine类继承Subparent类，而Subparent类继承Parent类。分别在这三个类的构造方法中输出构造方法名称来验证继承关系。 Eclipse输出如下 调用父类的Parent()构造方法 调用子类的SubParent()构造方法 调用子类的Subroutine()构造方法 运行结果可以看出，在子类Subroutine的主方法中只调用子类的构造方法实例化子类对象，并且在子类构造方法中没有调用父类构造方法的任何语句，但是在实例化子类对象时它相应调用了父类的构造方法。在这个结果中可以看到调用构造方法的顺序，首先是顶级父类，然后是上一级父类，最后才是子类。也就是说，实例化子类对象时首先要实例化父类对象，然后在实例化子类对象，所以在子类构造方法访问父类的构造方法去，父类已经完成实例化操作。 
第300篇文章[0]
Java类与类的构造方法以及this关键字 类 构造一个类我们需要设定 权限修饰符返回值类型方法名(参数类型参数名) {  //方法体 return返回值; } 一个成员方法可以有参数，这个参数可以是对象，也可以是基本数据类型的变量，同时成员方法有返回值和不返回任何值的选择，如果需要返回值，就需要在方法体中使用return关键字，return之后这个方法执行就会被终止。 但是注意返回值一定要与成员方法的返回值类型一样。 权限修饰符： 访问包位置privateprotectedpublic本类可见可见可见同包其他类或子类不可见可见可见其他包的类或子类不可见不可见可见 默认访问权限： 当我们创建如下没有权限修饰符的类时： classAnything{ publicvoiddoEverything(){ ..//方法体 } } 默认修饰符，就是只有一个包内的其他类和子类可以对该类进行访问，而AnyClass类中的doEverything方法被修饰为public权限，但它会跟从Anything的权限。Java语言规定，类的权限设定会约束类成员的权限设定，所以即使把public换成任何诸如private或者没有，效果都是一样的。 this关键字 最开始学的时候对这个this关键字很不熟悉，不知道到底在指代什么。 那么我在此举几个例子 privatevoidsetName(Stringname){ this.name=name; } 一般而言，类似这种定义我们会发现两个name一个是全局变量，一个是形参，那么当我们想要修改全局变量的时候我们不清楚究竟有没有改变全局变量，因为往往我们都希望通过参数来改变全局变量。 再看另一种用法 publicBookgetBook(){ returnthis;//返回Book类引用 } 此时的应用就是方法的返回值。 类的构造方法： 构造方法的特点：构造方法没有返回值，构造方法的名称要与本类的名称相同。 publicbook(){  //构造方法体 } book是方法的名称 例子： publicclassAnything{ publicAnything{ this("this调用有参构造方法");//定义无参构造方法 System.out.println("无参构造方法");//使用this调用有参构造方法 } publicAnything(Stringname){ System.out.println("有参构造方法");//定义有参构造方法 } } 看倒定义了两个构造方法，在无参构造方法中可以使用this关键字调用有参的构造方法。但使用这种方式需要注意的是只可以在无参构造方法中的第一句使用this调用有参构造方法。 
第301篇文章[0]
JAVAI/O流File操作 众所周知java语言提供给程序员非常多的包供编程时使用，方便又快捷。 I/O流也如此，在Java中这些类被放在java.io包里面，所以我们想要开始使用I/O就先把java.io填进去。 一.I/O （1）输入流 首先介绍输入流，介绍输入流就要先了解InputStream类，它是字节输入流的抽象类，是所有字节输入流的父类。比如它包括AudioInputStream，ByteArrayInputStream，StringBufferInputStream等等，其中这类方法遇到错误的时候都会引发IOException异常。 该类中，有以下一些方法： read()：从输入流中读取数据的下一个字节，并且返回0-255范围内的int字节值。如果到达了流末尾而没有可用的字节，则返回-1。 read(byte[]b):从输入流中读入一定长度的字节，并以整数的形式返回字节数。 mark(intreadlimit):在输入流的当前位置放置一个标记，readlimit参数告知此输入流在标记位置失效之前允许读取的字节数。 reset()：将输入指针返回到当前所做的标记处。 close()：关闭此输入流并且释放与该流关联的所有系统资源。 由于Java中的字符是Unicode编码，双字节，InputStream是用来处理字节的，并不适合处理字符串。所以Java为了字符输入提供了单独的类也就是Reader。相应的Reader类是字符输入流的抽象类，所有字符输入流的实现都是它的子类。Reader类与InputStream类中的方法类似，在此不进行赘述，感兴趣的可以去JDK文档自行查询。 （2）输出流 想对比与InputStream，输出流当然是OutputStream。 OutputStream类是字节输出流的抽象类，同样OutputStream类中也包含了很多方法，其中所有方法的返回值均为void，均返回void。在遇到错误的时候也会引发IOException异常。 下面简要介绍几个子类： write(intb)（//对应于read，方便好记）：将指定的字节写入这个输出流。 write(byte[]b):将b个字节从指定的byte数组写入此输出流。 write(byte[]b,intoff,intlen)方法：将指定byte数组中从偏移量off开始的len个字节写入此输出流。 flush()：彻底完成输出并且清空缓存区。 close()：关闭输出流。 二.File操作 （1）文件的创建与删除 Java中提供了File类创建文件对象，通常情况下使用以下三种。 File(Stringname) 其中name指的是文件的路径名字，例如，我们想要创建一个新的File对象，我们可以 Filefilename=newFile("c:/java1.txt"); File(Stringparent,Stringchild) 该方法根据父路径来创建一个新的File对象 Filefile=newFile("C:","java1.txt"); File(Filef,Stringchild) 与上面类似，只不过前面的paret变成了File类型，所以我们需要换一种构造方式。 Fileparent=newFile("c:"); Filefile=newFile(parent,"java1.txt"); 当然每次进行newFile不妨考虑到会不会有该文件或者是直接创建问题。那么我们可以看下面代码如何解决。 publicclassTest{ publicstaticvoidmain(String[]rags){ Filefile=newFile("java1.txt"); if(file.exists()){ file.delete(); System.out.println("文件删除"); } else{ try{ file.createNewfile(); System.out.println("文件创建好了"); }catch(Exceptione){ e.printStackTrace(); } } } } 可以看到这里面有关于文件异常的操作，trycatch，另外我们还调用了delete和exists，分别是当我们创建了文件java1.txt时候，判断如果该文件存在，那我们进行delete操作，并且输出提示，else否则如果文件不存在那么我们进行文件创建，createNewfile，并且输出提示。 下面在最后简单进行一下File包含常用的方法的小汇总： 方法返回值说明getName()String获取文件的名称canRead()boolean判断文件是否可读canWrite()boolean判断文件是否可以被写入exits()boolean判断文件是否存在length()long以字节位单位获取文件长度getAbsolutePath()String获取文件的绝对路径getParent()String获取文件的父亲路径isFile()boolean判断文件是否存在isDirectory()boolean判断文件是否为一个目录isHidden()boolean判断文件是否为隐藏文件lastModified()long获取文件最后修改时间 好了，本次介绍就到此结束了，下次再见，拜拜！ 
第302篇文章[0]
如何对HashMap进行排序 问题描述 这个问题从字面上看会有点奇怪，毕竟HashMap是按哈希值存储元素的，每个元素的位置是固定的，所以无法像list一样可以通过索引值list.get(i)去获取元素，由于位置由哈希值确定，也谈不上排序。但是，问题就在于确实会遇到一些情形，比如我定义了一个map对象 Map<Student,Integer>map=newHashMap<>(); map是由学生类作为key，整型类作为value的，我的toString函数里面，希望它能够按照Integer（实际意义为分数）的大小进行排序，并返回一个按顺序排列的字符串。 比如下面这个map Map<Student,Integer>map=newHashMap<>(); Studenta=newStudent("a"); Studentb=newStudent("b"); Studentc=newStudent("c"); map.put(a,78); map.put(c,60); map.put(b,99); 打印map.toString()的结果 {[Studentname:a]=78,[Studentname:b]=99,[Studentname:c]=60} 既不是按照插入顺序，也不是按照我们预期的value大小顺序排列。所以说直接returnmap.toString()肯定是不行的，那我怎么能够构造一个字符串表示map，而且是按value大小排列的呢？ 解决方案 方法①首先网上有一些大佬的博客都介绍了用Java8的Streams进行排序，比如： map.entrySet().stream().sorted((e1,e2)->e1.getValue().compareTo(e2.getValue())).forEach(System.out::println); 输完这行代码，然后直接运行，就会神奇地发现控制台打印出了按value顺序排列的map然而，这种方法虽然很舒服，但是不能解决我的这个所面临的问题，它不能变成一个可返回的字符串，而是直接打印了出来。 方法②仍然使用Java8的Streams进行排序，同时借助了LinkedHashMap Map<Student,Integer>sortedMap=map.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors .toMap(Map.Entry::getKey, Map.Entry::getValue, (e1,e2)->e1, LinkedHashMap::new)); 这时候，我们打印一下sortedMap Strings=sortedMap.toString(); System.out.println(s); 输出结果：这方法也很舒适，直接调用内置方法，就可以排序了，而且只需改一下参数就能按key排序或者是降序排序，十分快捷。 但是，有时候人就比较作，或者面临的情况很specific，比如说，我不希望这个返回的字符串是xx(Student)=xx(成绩)这种形式输出，但是我们知道，map这种类型的toString就是{key1=value1,key2=value2…}，如果跑到人家库里面的去改写方法，这不太好…或者自己重新写一个类继承map后又重写toString，会比较麻烦。 所以就有了下面这种比较原始的方法，看上去会比之前两个多花点时间，但是结果上灵活性会更强。 方法③这个方法，说起来很直观，一看就懂，一般也能想到，我称之为“土办法”，也就是定义两个列表，keylist和valuelist，然后按value值对valuelist排序，交换valuelist中元素的同时交换keylist中的元素。也就是同时排序的思想。 Strings="{"; List<Student>keylist=newArrayList<>(); List<Integer>valuelist=newArrayList<>(); for(Map.Entry<Student,Integer>entry:map.entrySet()){ keylist.add(entry.getKey()); valuelist.add(entry.getValue()); }//初始化keylist和valuelist for(inti=0;i<valuelist.size();i++){ intminpos=i; Integermin=valuelist.get(i); for(intj=i+1;j<valuelist.size();j++){ if(valuelist.get(j).compareTo(min)<0){ minpos=j; min=valuelist.get(j); } }//选择排序（按值排序） if(minpos!=i){ Integertemp=valuelist.get(i); valuelist.set(i,min); valuelist.set(minpos,temp);//valuelist排序 Studenttempl=keylist.get(i); keylist.set(i,keylist.get(minpos)); keylist.set(minpos,templ);//同时排序keylist } } //个性化操作 for(inti=0;i<keylist.size();i++){ s+=keylist.get(i)+"\t对应成绩="; s+=valuelist.get(i); if(i<keylist.size()-1)s+=",\n"; } s+="}"; 同时排序使得将原有map分解为：两个索引值对应的list，那么我们就可以按大小顺序对list中的值操作，灵活性会比较高。打印一下s，输出结果： 参考链接 如何对HashMap进行排序 
第303篇文章[0]
如何用Junit测试 文章目录 导入JUnit的包新建一个Junit测试类测试用例运行测试类 导入JUnit的包 右键点击java项目→BuildPath→ConfigureBuildPathAddLibrary→JUnit选择Junit的版本→Finish→Applyandclose 新建一个Junit测试类 在java包上点击右键→New→Other（讲道理熟悉了以后，直接new一个普通的class，再自己导入junit包和这个操作也是一样的）选择JunitTestCase给测试类取名，选择classundertest点击Finish 测试用例 //insert(): //测试策略 //插入标签在时间集合中(非法插入); //插入标签不在集合中:插入时间不合法(end<start);插入时间合法（合法插入） @Test publicvoidtestInsert(){ IntervalSet<Employee>iset=emptyInstance(20210101,20210305); longstart=20210101; longend=20210203; Employeelabel1=newEmployee("a","manager",18846451368L); Employeelabel2=newEmployee("b","worker",16548751663L); assertTrue(iset.insert(start,end,label1));//合法插入 assertTrue(iset.labels().contains(label1)); System.out.println("预期插入出错测试方法：testInsert()"); assertFalse(iset.insert(start+1,end+1,label1));//标签重复 assertFalse(iset.insert(end,start,label2));//插入时间不合法，起始时间>终止时间 } 先写测试策略（划分等价类，或者用边界值分析的思想）测试方法前用@Test标注使用assertTrue(),assertFalse(),assertEquals(预期值，测试值)等方法对结果进行测试需要测试抛出异常的方法，@Test(expected=xxx异常.class) @Test(expected=IntervalBlankException.class) publicvoidtestBlank()throwsIntervalBlankException{ longpstart=20210110L; longpend=20210306L; DutyIntervalSetdiset=newDutyIntervalSet(newCommonIntervalSet1<Employee>(pstart,pend)); Employeea=newEmployee("ZhangSan","Manager",13904510000L); diset.insert(20210112L,20210131L,a); diset.checkifBlank();//预期结果：调用checkifBlank方法抛出IntervalBlankException的异常 } 运行测试类 右键点击测试类→RunAs→JUnitTest绿色表示测试通过，如果是红色或者蓝色则测试失败，需要根据报错提示对源代码修改。 
第304篇文章[0]
Java_如何编写自己的泛型类 泛型 泛型，即参数化类型，类似于方法中将变量参数化，泛型是将原来定义的具体的类型参数化。 使用泛型的需求 Java中为什么要使用泛型，是因为泛型使用起来非常之方便，泛型类/方法针对于面向复用的开发。当我们想让一个类/方法同时适配于多种数据类型，这将大大省去我们编写重复代码的时间。 举一个常见的例子说明： List<Integer>ilist=newArrayList<Integer>(); List<String>slist=newArrayList<String>(); 其中List接口以及类ArrayList均使用了泛型，从而可以构造出接收以类型Integer,String为参数的list；所以下面的add操作中可以用不同类型的变量作为参数（用泛型可以省去重载方法的开销）： ilist.add(1); ilist.add(2); System.out.println(ilist); slist.add("a"); slist.add("b"); System.out.println(slist); 分别输出为[1,2] [a,b] 泛型应用场景 可以看到，除了部分底层的实现类，上层的类/抽象类/接口基本都是用泛型实现的，用泛型实现能够很好地进行复用，比如这里的L可以是Employee，Course，Process，从而派生出三个具体子类DutyIntervalSet，CourseIntervalSet，ProcessIntervalSet。 下面我们将以上图为例介绍如何编写一个自己的泛型类。 如何编写自己的泛型类 我们以MultiIntervalSet为例进行分析：编写面向泛型的类时需要注意以下几点：①泛型类的声明：需要在类名后加上<L> publicclassMultiIntervalSet<L>implementsIMultiIntervalSet<L> ②需要用到泛型的地方，全部用L代替 protectedfinalSet<L>elabel=newHashSet<>(); protectedfinalMap<L,List<Interval>>emap=newHashMap<>(); ③只能对定义为泛型的变量做一些通用的操作：对于一个Llabel的泛型变量label，可以对它进行list.add(label)，set.contains(label)等操作，由于它在具体传入的时候已经变成了一个具体的类。但是想要显式地调用它自己的方法只能调用如下几种（此时感觉label就是一个原始的Object类）：要小心，不要代入某个具体的类型，调用它特有的方法；所以这也是泛型的一个局限性，对于通用的操作可以复用，但如果要用到某个具体类的方法，则不能将该类型作为参数传递。 ④泛型类中可以有非泛型方法，也可以有非泛型的成员变量。这点很好理解，泛型类中不一定每个方法都需要用到泛型，用到泛型时才是泛型方法；同时泛型类中当然也可以有具体类型的成员变量。 protectedfinalSet<L>elabel=newHashSet<>(); protectedfinalMap<L,List<Interval>>emap=newHashMap<>(); protectedIntervalduration; 最后给出一个泛型方法的例子 publicbooleanremove(Llabel){ if(!elabel.contains(label))returnfalse; else{ emap.remove(label); elabel.remove(label); checkRep(); returntrue; } } 总结 总之，写泛型类的时候要保持平常心，将L当作一个普通的类型去编写代码，开始时不要因为觉得L的写法陌生，而不敢对它进行操作，或者不愿意自定义泛型类/方法。 补充介绍：类型通配符 类型通配符一般是使用?代替具体的类型参数。例如List<?>在逻辑上是List<String>,List<Integer>等所有List<具体类型实参>的父类。①在某些情况下，我们必须使用到类型通配符，否则静态编译时会报错：比如：重写equals函数时用到instanceof运算符 @Overridepublicbooleanequals(Objectobj){ if(objinstanceofEdge<L>){ Edge<L>e=(Edge<L>)obj; // 后续逻辑省略 编译报错：CannotperforminstanceofcheckagainstparameterizedtypeEdge.UsetheformEdge<?>insteadsincefurthergenerictypeinformationwillbeerasedatruntime 修改为下图所示，编译通过。 if(objinstanceofEdge<?>){ Edge<?>e=(Edge<?>)obj; ②类型通配符还可以用于特定的情形比如限定类型的上/下限： List<?extendsNumber>限定接收类型的上限为Number，接受Number及其下层子类类型 List<?superNumber>限定接收类型的下限为Number，接受Number及其三层父类类型，如Object类型的实例。 
第305篇文章[0]
多维软件视角 三维度八视图 多维软件视角 三个维度：阶段：Build（构造阶段），Run（运行阶段）层次：代码层面，构件层面时间：时刻，一段时间 视角一：Build-time,moment,andcode-levelview 词汇层面：源代码语法层面：抽象语法树（AST，AbstractSyntaxTree）语义层面：类图 视角二：Build-time,period,andcode-levelview Codechurn：代码变化（一段时间） 视角三：Build-time,moment,andcomponent-levelview 源代码被物理地组织成文件（File），这些文件又被目录组织起来；文件被封装到包（Package）中，逻辑上构成组件和子系统可重用模块以库（Library）的形式出现 静态链接发生在构造阶段，静态链接时，库被拷贝进入代码形成整体，执行的时候无需提供库文件 视角四：Build-time,period,andcomponent-levelview SoftwareConfigurationItem(SCI，配置项)Version(版本) 视角五：Run-time,moment,andcode-levelview Snapshotdiagram:代码快照图（描述程序运行时内存里变量层面的状态）Memorydump(内存信息转储) 视角六：Run-time,periodandcode-levelview Executiontracing执行跟踪用日志方式记录程序执行的调用次序（代码层面） 视角七：Run-time,moment,andcomponent-levelview Deploymentdiagram（部署图） 视角八：Run-time,period,andcomponent-levelview EventLog：事件日志，构件/系统层面 
第306篇文章[0]
Java中的重载（Overload）机制详解及与重写（Override）的区别 文章目录 重载重载的定义重载的好处重载是一种静态多态重载的规则重载举例 重载与重写的区别 重载 重载的定义 重载：多个方法具有相同的名字，但有不同的参数列表 重载的好处 方便client（客户端）调用，client可用不同的参数列表，调用同样的函数 比如想要定义加法的方法，让它可以计算不同类型的数之和，有不同类型的返回值，可以如下定义： publicintadd(intx,inty){ returnx+y; } publicdoubleadd(doublex,doubley){ returnx+y; } 如果没有重载机制，那么想要定义两个具有相同/相似功能的方法，必须用不同函数名加以区分，如add1,add2，去定义和记住这些方法名字，对开发者和使用者都是一种负担。 重载是一种静态多态 重载是一种静态多态，根据参数列表进行最佳匹配，做静态类型检查，在编译阶段时决定要具体执行哪个方法。 与之相反，重写方法则是在运行时进行动态检查。 关于这一点，首先需要明白两个概念： 绑定：将调用的名字与实际的方法名字联系起来（可能很多个）分派：具体执行哪个方法（earlybinding→staticdispatch） 提前/静态绑定（Early/Staticbinding）每当一个方法的绑定发生时，所绑定的类型由编译器在编译时确定，然后绑定发生。 推迟/动态绑定（Late/Dynamicbinding）在重写父类和子类具有相同的方法时，对象的类型决定了要执行的方法。对象的类型在运行时确定。 类型分派原理发生阶段应用场景静态分派根据变量的静态类型编译期（不由Java虚拟机执行）Overload动态分派根据变量的动态类型运行期（由Java虚拟机执行）Override Overload方法：提前绑定和静态分派。 编译阶段即可确定要执行哪个具体操作。这个主要是针对多态性而言的。笔者理解为，如果发生了继承的情况，子类重载了父类的方法，由于参数列表不同，编译阶段可以很快检查并绑定到对应的方法，所以采取了这种earlybinding+staticdispatch的机制。 Override方法:推迟绑定和动态分派。 如果子类重写了父类的方法，编译阶段不知道对象类型，需要进行推迟绑定，在运行阶段决定具体执行哪个方法。 如果这一点不理解可以暂时跳过，但需要了解在哪个阶段进行检查与确定执行方法。即重载方法在编译时做静态类型检查，决定执行哪一个方法；而重写方法在运行时进行动态检查，并决定执行哪个方法。 重载的规则 必须有不同的参数列表可以有相同/不同的返回值类型可以有相同/不同的访问权限(public/private/protected)可以声明新的异常可以在同一个类内重载，也可在子类中重载 注意到，重载规则中最重要的也是最本质的是第一条规则：重载方法的参数列表必须改变，指的是参数个数/参数类型发生改变比如 //方法1（原方法） publicvoidchangeSize(intsize,Stringname,floatpattern){} //方法2 publicvoidchangeSize(intsize,Stringname){} //方法3 publicvoidchangeSize(intlength,Stringpattern,floatsize){} //方法4 publicbooleanchangeSize(intsize,Stringname,floatpattern){} 方法2即为方法1的重载方法，方法3、4均不是方法1的重载方法，参数列表（指参数类型和参数个数）与方法1相同方法3仅仅改变了参数变量名称，没有改变参数类型和个数方法4只是改变了方法返回类型，也没有改变参数列表 重载举例 下面我们来看一组子类重载父类方法的例子，加深我们的理解。注意，可以子类中重载，也可在同一个类内重载（像前述add方法可以放在同一个类中）；并不是像重写一样必须发生在父类和子类之间。首先定义两个类Animal和Horse，Horse类中重载了Animal中的eat方法，需要传入一个字符串变量 publicclassAnimal{ publicvoideat(){ System.out.println("undefined"); } } classHorseextendsAnimal{ publicvoideat(Stringfood){ System.out.println(food); } } 我们进行如下测试 //测试1 Animala=newAnimal(); a.eat(); 输出结果：undefined，调用Animal中的无参eat方法 //测试2 Horseh=newHorse(); h.eat(); 输出结果：undefined，调用Horse类中继承的无参eat方法 //测试3 Animalah=newHorse(); ah.eat(); 输出结果：undefined，由于没有参数，调用了Animal类中的无参eat方法 //测试4 Horsehe=newHorse(); he.eat("Apples"); 输出结果：Apples，调用Horse类中有参方法 //测试5 Animala2=newAnimal(); a2.eat("treats"); 编译报错：Themethodeat()inthetypeAnimalisnotapplicableforthearguments(String)，Animal类中没有带参数的eat方法，这里也再次说明了重载是一种静态多态，在编译时期进行静态检查。 //测试6 Animalah2=newHorse(); ah2.eat("Carrots"); 编译报错：Themethodeat()inthetypeAnimalisnotapplicableforthearguments(String)，Animal类中没有带参数的eat方法，尽管ah2具有多态性，但重载方法基于earlybinding和静态分派，编译时会做静态检查，到Animal的方法里去找带参数的eat，如果找到然后进行绑定，但是显然此处静态检查是出错的（找不到带参数的eat），所以编译报错。 重载与重写的区别 重载（Overload）重写（Override）参数列表必须改变必须不变返回值类型可以改变必须不变异常可以改变要么不抛出异常，要么抛出与父类方法相同的异常或该异常的子类访问权限可以改变子类的方法的访问权限不能小于父类调用引用类型确定选择哪个重载版本（基于声明的参数类型），在编译时发生对象类型（堆上实际实例的类型）决定了选择哪个方法，发生在运行时 
第307篇文章[0]
(软件构造博客）List的浅拷贝和深拷贝 List的拷贝 在写实验的时候发现List的常见的复制方式复制完后的结果居然不是和原List无关的，查阅资料之后记录这一情况。首先展示一下我发现问题的一个简化示例： publicclassPerson{ privateStringname; privateintage; publicPerson(Stringname,intage) { this.name=name; this.age=age; } publicvoidsetAge(intage) { this.age=age; } @Override publicStringtoString() { returnthis.name+this.age; } publicstaticvoidmain(String[]argv) { List<Person>a=newArrayList<>(); Personp1=newPerson("john",20); Personp2=newPerson("jack",30); a.add(p1); a.add(p2); List<Person>b=newArrayList<>(); for(inti=0;i<a.size();i++) { b.add(a.get(i)); } System.out.println("刚复制完时："); System.out.println("a:"+a.toString()); System.out.println("b:"+b.toString()); b.get(1).setAge(40); System.out.println("修改b之后："); System.out.println("a:"+a.toString()); System.out.println("b:"+b.toString()); } } 输出结果如下： 刚复制完时： a:[john20,jack30] b:[john20,jack30] 修改b之后： a:[john20,jack40] b:[john20,jack40] 可以发现，a居然跟随着b的变化一起变化了，这显然和我们的设计要求不一致，接下来就来看看List的复制的几种情况。 1.浅拷贝 我们上面展示的这种方法就是浅拷贝的一种，可以说是我日常复制List的时候最常用的。顾名思义，浅拷贝将原List和拷贝List中的元素指向同一个地址，要是刚好这个元素的类型是mutable的，那么就会出现上述情况，修改b结果把a也给修改了。以下是浅拷贝的几种不同的方式 1.1遍历循环复制 也就是上述代码展示的了，不再赘述。 1.2使用List实现类的构造方法 如下代码展示，其实和遍历复制本质相同，只是使用了构造方法。 List<Person>b=newArrayList<>(a); 我们可以分析一下ArrayList的源码，就可以发现事实上它是利用了一个叫做copyOf的函数实现的构造函数的主要功能，构造函数源码如下： publicArrayList(Collection<?extendsE>c){ elementData=c.toArray(); if((size=elementData.length)!=0){ //c.toArraymight(incorrectly)notreturnObject[](see6260652) if(elementData.getClass()!=Object[].class) elementData=Arrays.copyOf(elementData,size,Object[].class); }else{ //replacewithemptyarray. this.elementData=EMPTY_ELEMENTDATA; } } 我们可以继续分析copyOf函数的源码，发现调用了一个System.arraycopy的函数，copyOf源码如下： publicstatic<T,U>T[]copyOf(U[]original,intnewLength,Class<?extendsT[]>newType){ @SuppressWarnings("unchecked") T[]copy=((Object)newType==(Object)Object[].class) ?(T[])newObject[newLength] :(T[])Array.newInstance(newType.getComponentType(),newLength); System.arraycopy(original,0,copy,0, Math.min(original.length,newLength)); returncopy; } 继续看System.arraycopy的源码，这是一个naive函数，那就不继续分析了，关键在于这个函数实现的功能就是实现数组之间的复制，而且由调用这一方法的构造函数也是浅拷贝的一种。 1.3list.addAll() 使用方法： List<Person>a=newArrayList<>(); Personp1=newPerson("john",20); Personp2=newPerson("jack",30); a.add(p1); a.add(p2); List<Person>b=newArrayList<>(); b.addAll(a); 源码如下： publicbooleanaddAll(Collection<?extendsE>c){ Object[]a=c.toArray(); intnumNew=a.length; ensureCapacityInternal(size+numNew);//IncrementsmodCount System.arraycopy(a,0,elementData,size,numNew); size+=numNew; returnnumNew!=0; } 通过简单查看其源码发现和构造函数的复制函数方法没什么两样，不再赘述。 1.4System.arraycopy() 不再赘述，和上面一样，调用方法参见addAll源码即可。 1.5使用Stream的方式copy 使用方法： List<Person>b=a.stream().collect(Collectors.toList()); 2.List深拷贝 和浅拷贝不同，那么显然深拷贝就是a与b的元素指向不同的地址，因此a与b内容相同，但是修改的时候互不影响，这才是我们在大多数情况下比较符合我们要求的拷贝方法。以下两种方法参考博客：https://blog.csdn.net/qq_35507234/article/details/85070429 2.1使用序列化方法 publicstatic<T>List<T>deepCopy(List<T>src)throwsIOException,ClassNotFoundException{ ByteArrayOutputStreambyteOut=newByteArrayOutputStream(); ObjectOutputStreamout=newObjectOutputStream(byteOut); out.writeObject(src); ByteArrayInputStreambyteIn=newByteArrayInputStream(byteOut.toByteArray()); ObjectInputStreamin=newObjectInputStream(byteIn); @SuppressWarnings("unchecked") List<T>dest=(List<T>)in.readObject(); returndest; } List<Person>destList=deepCopy(srcList);//调用该方法 2.2clone方法 publicclassAimplementsCloneable{ publicStringname[]; publicA(){ name=newString[2]; } publicObjectclone(){ Ao=null; try{ o=(A)super.clone(); }catch(CloneNotSupportedExceptione){ e.printStackTrace(); } returno; } } for(inti=0;i<n;i+=){ copy.add((A)src.get(i).clone()); } 3.使用场景 很显然，在没有特殊情况的时候使用浅拷贝绰绰有余，例如List中的元素如果是String，那么使用浅拷贝并不会存在a与b同时修改的情况，这是因为String是Immutable的，例如我们对b这个List中的某一个String进行修改，那么这个String会指向一段新的地址，而a的相同位置的元素指向原来的地址不变，因此不存在同步变化的情况，使用浅拷贝即可。但是如果我们真的需要使用一个元素是mutable类型的List的话，而且这个List还有可能在多处被复制使用的话就需要考虑深拷贝了。例如文章最开始那个例子，如果List的元素是自定义的Person类，而且这是一个mutable的ADT，那么使用浅拷贝可能存在风险。 
第308篇文章[0]
Amazon数据集网址 在构建知识图谱的时候大多需要使用Amazon的数据集，在此记录Amazon数据集网址。2014版：http://snap.stanford.edu/data/amazon/productGraph/2018版：http://deepyeti.ucsd.edu/jianmo/amazon/index.html两个版本略有不同，可以按需使用 
第309篇文章[0]
（软件构造博客）immutable和mutable immutable和mutable 复习到了这一部分，记录一下immutable和mutable的性质与区别。 1.优缺点比较 首先先把二者的优缺点列出来： 优缺点immutablemutable缺点由于内部数据不可变，所以对其频发修改会产生大量的临时拷贝，浪费空间可变类型由于其内部数据可变，所以其风险更大优点内部数据的不可变导致其更加安全，可以用作多线程的共享对象而不必考虑同步问题可变类型会减少数据的拷贝次数，从而其效率要高于immutable 2.各自的定义 immutable：一个immutable的对象其值在指定了之后就不可再改变，如果试图修改其内部的值会新建一个新的地址保存新的值。mutable：一个mutable的对象其值在指定了之后还是可以修改的。 3.举例 在编程语言中这个概念是通用的，以下使用java来举例。首先，java中很典型的一个immutable的对象就是String。当对String完成初始化之后，String指向的这一段地址的内容就固定了，如果为这个String赋另外一个值，将会给这个String赋一段新的地址，这个新地址中存着新值，如果旧的地址将没有其他对象指向它，将等待回收。以下使用一个SnapShot图来表示这个过程。而mutable的一个例子就是List，java中的List、set、Map等对象都是可变的，这一点从它们都存在类似于add的方法就可以看出。mutable在改变值的时候不改变地址，而是直接修改原本地址中的值。 4.优缺点分析 每一种对象的存在和使用都是存在其合理性的。以下为两种对象使用过程中的优缺点分析。 4.1immutable 对于immutable来说，优点十分明显，就是它指向的地址的内容是不可变的，也就不存在两个对象都指向一个地址的时候其中一个对象无法知道另外一个对象是否对这个地址的内容进行修改。也就是说，immutable在很大程度上保证了多线程的时候的正确性。但是缺点同样十分明显，就是每一次修改都要进行一次复制，可能会产生很大的时间开销，同时会产生大量的需要回收的垃圾。例如对于如下代码片段： publicvoidtest(intn) { Strings=""; for(inti=0;i<n;i++) { s.concat(String.valueOf(i)); } } 对于第一个i来说进行了n次插入意味着复制了n次，也就是这个过程中时间复杂度是O(n^2)的，而这只是一个最简单的一层循环。 4.2mutable mutable由于其指向地址内容可变，因此每次修改的时候不需要复制，因此其开销比immutable小很多。但是其缺点就在于如果多个变量指向同一段地址的时候，其中一个对象对于地址内容的修改会影响到其他所有的变量的值，这种影响很有可能导致程序出错，例如如下代码片段： publicclassZoo{ privateList<String>animals; publicZoo(List<String>animals){ this.animals=animals; } publicList<String>getAnimals(){ returnthis.animals; } publicstaticvoidmain(String[]argv) { List<String>a=newArrayList<>(); a.addAll(Arrays.asList("lion","tiger","bear")); Zoozoo=newZoo(a); a.add("zebra"); System.out.println(a); System.out.println(zoo.getAnimals()); List<String>b=zoo.getAnimals(); b.add("flamingo"); System.out.println(a); } } 其中List是一个Mutable的对象，因此a，zoo.animals,b都指向了同一段内存空间，任何一个内容的修改都会造成三个值一起发生变化，因此main函数的输出如下：很显然这种输出在很大可能性下不是我们想要的，因此使用mutable是存在风险的。 5.使用场景 尽可能使用不可变的对象和不可变的引用。如果可以肯定某一段地址空间只会由一个对象指向，可以考虑使用mutable对象，但是使用的时候一定要注意不要产生多个对象修改一段空间内值的情况。 
第310篇文章[0]
（软件构造博客）java中的final java中的final java中的final关键字可以用来声明变量、方法、类。主要起到的作用就是达到引用不可变的效果。具体分别介绍如下： 1.1final变量 被final修饰的变量在赋值之后引用关系就确定了，也就是不能对于基本数据类型来说不可以另赋新值，对于对象数据类型来说不能为这个变量指派一个新的对象。也就是类似于以下语句都是会在静态检查的时候报错的： finalinta=1; a=2; finalStrings="GOOGLE"; s="BAIDU"; 那么仔细考虑来看，如果我们指定的一个变量是immutable的，那么就意味着如果用final修饰，在初始化之后这个变量就不可以修改了，如果是mutable的话，内部的值还可以修改但是不可以改变引用关系。那么是不是意味着如果在我们定义的ADT内部如果我们用final修饰了一个immutable的变量的时候就不用担心表示泄露了呢？事实上不是这样的，如果在这种情况下存在表示泄露可能会存在使用者分析运行时内存的具体情况判断ADT内部一些实现功能的危险，也就是说即使使用了final，还是需要注意表示泄露的问题。 1.2final方法 下面这段话摘自《Java编程思想》第四版第143页： “使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的 含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用 。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java 版本中，不需要使用final方法进行这些优化了。“ 也就是说，如果一个方法使用了final修饰，那么这个方法将不再能被子类重写。需要注意的是由于重写首先建立在继承的关系上，如果父类中一个final方法是private的，子类自然无法访问，那么子类中定义相同的方法名和参数是不会报错的，但是这时候不再是重写关系。例如如下代码是不会报错的 publicclassPerson{ privatefinalvoiddecision(){ System.out.println("父类"); } } publicclassconcretePersonextendsPerson{ publicvoiddecision(){ System.out.println("子类"); } publicstaticvoidmain(String[]args){ Personp=newconcretePerson(); //p.decision(); } } 但是可以发现的是如果我们去掉注释的话IDE会直接在注释那一行下报错，显示没有这个方法。这是由于静态检查阶段p的类型还是Person，而Person的decison方法是private的，不可访问，因此静态检查报错。 1.3final类 与上面两类类似，如果使用final修饰类的话，那么这个类是不可以被继承的。 2.final一些实例 2.1final变量与普通变量 很重要的一点就是final变量的指向已经不可变了，因此可以看下面这个例子 publicstaticvoidmain(String[]args){ Stringa="helloworld"; Stringb="helloworld"; Stringc="hello"+"world"; finalStringd="hello"; Stringe="hello"; Stringf=d+"world"; Stringg=e+"world"; System.out.println(a==b); System.out.println(a==c); System.out.println(d==e); System.out.println(a==f); System.out.println(a==g); } 输出如下： true true true true false 这个结果让我困惑了一段时间，查阅了资料之后有了一定的了解。接下来对于每一个结果进行分析。首先需要明确的就是对于这种直接通过双引号""声明字符串的方式,虚拟机首先会到字符串常量池中查找该字符串是否已经存在，如果存在会直接返回该引用,如果不存在则会在堆内存中创建该字符串对象,然后到字符串常量池中注册该字符串。 也就是说a和b和c事实上是指向同一段地址的，因此a==b和a==c成立。 接下来分析一下a==g为什么是false的。这是因为g是在运行的时候才分配的一段地址，因此和a的地址是不一致的，因此返回false。那么为什么a==f就是对的呢？这是因为d是由final修饰的，在静态编译的时候就当做常量使用，因此f的地址是在常量池中分配的，和a是指向一段地址的，因此a==f成立。 
第311篇文章[0]
（软件构造博客）==和equals的区别 ==和equals的区别 之前在做软件构造实验的时候遇到了应该使用==还是equals判断相等的情况，结合上课讲的内容和查阅的资料在此记录二者的相同点和区别，如有不正确的地方请批评指正。 1.相同点 很显然二者的相同点就是都是用来判断两个元素是否相同的，只是使用的方式以及判断的方法不同。 2.不同点 首先，最大的区别就是==是一个运算符而equals是一个函数，这是二者本质上的不同，当然，在使用的时候这不是我们需要考虑的重点。在使用的时候我们需要考虑的是：1.对于一些基本数据类型例如byte，int等只能使用==，表示对于数值或者是基本数据类型值的比较，由于这些都是基本数据类型，因此不存在使用equals函数来比较的必要2.对于一些复合数据类型，如果我们使用==来表示比较比较两个元素的话我们比较的是他们的存放地址的相同与否，也就是如果们new了两个复合数据类型，尽管它们内部的值可能是相同的，但是比较结果是不相同的，很显然在大多数时候这都是不符合我们的使用要求的。3.对于复合数据类型，使用的equals都是继承自java的Object类，在不进行override的情况下比较的还是存放地址，因为Object中默认是使用==实现这个函数的，可以通过override来重写，定义我们需要的比较方式，例如Interger，Date，String等复合数据类型内部都进行了重写，不再是比较存放的地址位置。 具体例子 代码： //基本数据类型的比较 inttest1=10; inttest2=10; System.out.println(test1==test2);//true //引用数据类型的比较 Strings1="test"; Strings2="test"; System.out.println(s1==s2);//true System.out.println(s1.equals(s2));//true //String类中==与equals的比较 Strings3=newString("test"); Strings4=newString("test"); System.out.println(s3==s4);//false System.out.println(s3.equals(s4));//true //非String类中==与equals类型的比较 4.关于重写equals 一般来说，如果我们定义的一个ADT我们希望它是immutable类型的时候我们需要重写equals，这是因为很可能存在使用这个ADT，new出的两个实体由于存放的位置不同而无法使用==比较是否相等，这时候就需要重写equals，而mutable类型的ADT一般不需要重写equals方法。 
第312篇文章[0]
（软件构造博客）软件构造的三维度八视图 软件构造的三维度八视图 ​软件构造的三维度八视图是在软件的构造和后期维护过程中的一个概念，其实就是软件构造应该如何构造的问题，事实上，“软件构造”就可以看做是三维度八视图之间的相互切换的过程。在此对于这三维度和八视图进行简要的归纳总结。 ​三维度八视图的英文版图如下： 中文翻译版如下： 以下是我对三维度八视图的理解，如有不正确请批评指正： 1.三维度 首先时刻和阶段这一维度较好理解，就是指是在某一个时刻或者是一段时间内进行观察得到的结果。 而代码和构件这一维度来看，很显然，代码层面就是指直接与源代码相关的部分而构件层面更多的指这个项目使用的一些外部的配置、库等信息。 编译与运行时这一维度也较好理解，不过多赘述 2.八视图 个人感觉这八个视图事实上和计算机系统中很多知识是重叠的，由于这学期刚好两门课都学，因此尝试从不同角度对八视图进行解释。 2.1编译时 时刻 代码 很显然，这一部分如果需要对应于计算机系统中的编译过程，在c语言中由gcc完成，在java中由JDK完成这一过程，与这一过程密切相关的就是源代码，也就是日常最常接触到的，其次就是语法分析数，这是由编译器产生的一棵树，主要是对程序进行词义分析、语法分析等工作，语法分析树这一部分知识可以见形式语言与自动机或编译原理课程。一棵c语言语法分析树示例如下： 2.2编译时 时刻 构件 显然，这一部分对应于静态链接的过程，在c语言链接过程中使用链接器（ld）将文件转化为可执行目标文件，在java中这一流程类似，也是将外部的包等代码中使用的外部的包信息与代码文件进行链接。 2.3编译时 阶段 代码 这一阶段事实上对应于源代码的一个变化的过程，主要体现的是对于源代码不断地修改，很好理解。 2.4编译时 阶段 构件 首先，对应于配置项的变化，配置项的解释就是：软件生存周期各个阶段活动的产物经审批后即可称之为软件配置项。也就是在源代码变化之后生成了多个部件，我们可能有了这个软件的不同零件，将其组合起来之后就是整个软件；其次就是版本控制，这一点很好理解，处于维护、功能升级等不同原因，软件总会不断推出新版本，这些版本表现的就是软件的一个演变过程。 github为我们每一个项目维护的一个提交历史记录就可以看成是这一阶段的一个简单示例 2.5运行时 时刻 代码 这一阶段对应于在运行中代码的变化，主要表示的就是例如在运行时某一时刻某个变量的值是什么样的，事实上我们对于程序打断点调试的时候看的就是这一个视图的内容。 2.6运行时 时刻 构建 很显然，这一阶段对应于动态链接，可以简单理解成在加载的时候再对使用的一些外部构件进行的链接；除了动态链接之外，这一视图对应的很重要的一部分是类似于在运行时使用数据库这种情况，数据库并没有嵌入软件，而是在软件运行时某个时刻请求数据库的信息。 2.7运行时 阶段 代码 这一部分可以看成是在程序运行过程中栈的信息的一个展示，最明显的一个展示就是java程序报错的时候出现的报错信息，这就是在java运行过程中与某个报错相关的栈的信息的展示，一个简单的例子如下图所示： 2.8运行时 阶段 构件 这一阶段主要对应于事件日志这一类信息，其事实上就是构件层面上的代码运行过程中的栈信息，但是它并没有2.7中栈信息内容那么繁多，其主要记录代码运行过程中的重要的事件的发生信息。 以上就是我对于三维度八视图的一些理解，如有错误或不足希望批评指正。 
第313篇文章[0]
（软件构造博客）Eclipse使用基本教程一（安装、JDK配置） 1.Eclipse安装 下载官方链接：https://www.eclipse.org/downloads/ 点击红框中的DownloadPackages，进入如下页面：根据使用的系统选择第一项中的Eclipse版本即可，后续只需要按照提示内容安装即可，不再赘述。 2.JDK安装 2.1下载 由于我们需要进行java开发，因此需要下载并配置JDK，具体方法如下：官方下载链接：https://www.oracle.com/java/technologies/javase-downloads.html如果使用官方链接直接点击Download,选择合适的版本即可。如果觉得官方链接太慢可以使用如下链接：华为云镜像：https://repo.huaweicloud.com/java/jdk/，进入之后选择合适的版本和系统即可。 2.2安装点击下载好的exe文件，出现如下安装指引点击下一步后出现如下页面，可以点击修改，更改安装地址，例如本人改为E:\JDK\JDK8，之后点击下一步等待安装即可。由于本人安装的是JDK8，因此还需要安装JRE（如果是JDK10后的版本无此过程），安装完成后，会弹出JRE安装界面，如下： 等待JRE安装完成即可。 2.3环境变量配置在Win10系统中演示，其他系统同理。打开系统属性界面（如果找不到直接在设置界面的搜索框中搜索变量，选择编辑系统变量选项即可）点击环境变量，进入如下界面，点击新建或编辑即可操作 由于本人电脑上已经配置了JDK11，因此JAVA_HOME等已经创建，第一次配置时新建即可。1.新建JAVA_HOME，将其设置为JDK安装目录。2.新建Path（如果已有的话再末尾添加即可），添加一项，为%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;3.新建CLASSPATH，设置为.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar（注意开头有一个点） 如果进行到这一步，那么JDK已经安装完成，可以进行验证。首先win+R打开如下面板： 进入cmd，输入javac，出现如下内容：如果需要查看JDK版本，使用java-version命令，出现如下信息：这就意味着JDK安装完成。 这是Eclipse配置java项目的第一步，下一个教程将展示如何开始第一个java程序，并使用Junit进行测试。 
第314篇文章[0]
Java里long类型除法转double 问题描述： java里面两个long类型的数相除，想要得到double类型的结果。 publicstaticvoidmain(String[]args)throwsException{ longa=2; longb=3; doublec=a/b; System.out.println(c); } 结果得到了0.0 解决方案： 数据类型强制转化。 publicstaticvoidmain(String[]args)throwsException{ longa=2; longb=3; //或者doublead=(double)a; //doublec=ad/b; doublec=(double)a/b; System.out.println(c); } 得到结果0.666666666 
第315篇文章[0]
java的String：==和equals（）区别 项目场景： 做MIT软件构造实验：ProblemSet2:PoeticWalks，实现Graph的implement CMU实验网站 问题描述： 问题是这样的，我定义了如下的一个类Edge, classEdge<L>{ //TODOfields privatefinalLsou; privatefinalLtar; privatefinalIntegerwei; //Abstractionfunction: //souisthesource,taristhetarget,weiistheweightonthedirectededgefromsourcetotarget //Representationinvariant: //true //Safetyfromrepexposure: //thefieldsareallprivatefinal //TODOconstructor publicEdge(Lsource,Ltarget,Integerweight){ sou=source; tar=target; wei=weight; checkRep(); } //TODOcheckRep publicvoidcheckRep(){ assertwei>0; assertsou!=null; asserttar!=null; } //TODOmethods //防御式拷贝 publicLgetSource(){ checkRep(); returnsou; } publicLgetTarget(){ checkRep(); returntar; } publicIntegergetWeight(){ checkRep(); returnwei; } //TODOtoString() publicStringtoString(){ checkRep(); returnthis.sou+"->"+this.tar+"weight:"+this.wei+"\n"; } } 现在我定义了一个List，里面的元素都是Edge，但是我想要比较两个Edge的source是否是一样的，发现如果直接用==，得到的结果永远是false，只有用equals方法才可以正确比较。 //firstversionalwaysfalse if(edges.get(i).getSource()==source) //secondversionwrightanswer if(edges.get(i).getSource().equals(source)) 而且最玄学的是，我在test里面跑的时候没有问题，但是将Graph作接口引入到了poem代码里面的时候这个问题才发现。 现在想想，这是因为我Junit测试的时候，输入的L都是常字符串，就是"a","b"这种直接赋值的，这种好像是==里面可以正常判断的。部分测试代码如下。 @Test publicvoidtestSourcesAndTarget(){ Graph<String>g=emptyInstance(); Stringa="a"; Stringb="b"; Stringc="c"; g.add(a); g.add(b); g.add(c); g.set(a,b,1); g.set(a,c,1); g.set(c,b,1); Map<String,Integer>res=g.targets(a); assertEquals(true,1==res.get(b)); assertEquals(true,1==res.get(c)); Map<String,Integer>res1=g.sources(b); assertEquals(true,1==res1.get(a)); assertEquals(true,1==res1.get(c)); } 原因分析： 后来我在想，为什么会发生这种事情呢？经过调查，我发现，由于我在poem里面应用的是String代替L。String可以用==和equals（）方法比较，==是比较两个字符串的首地址，equals（）方法是比较两个字符串的内容。所以对于两个不同的Edge里面的String类型的source，当然用==方法比较不出来的了。所以，以后比较String相等，保险起见，还是都用equals（）吧 简单的测试用例（来源） Strings1,s2,s3="abc",s4="abc"; s1=newString("abc"); s2=newString("abc"); System.out.println("s1==s2:"+(s1==s2));//false System.out.println("s1==s3:"+(s1==s3));//false System.out.println("s3==s4:"+(s3==s4));//true System.out.println("s1.equals(s2):"+(s1.equals(s2)));//true System.out.println("s1.equals(s3):"+(s1.equals(s3)));//true System.out.println("s3.equals(s4):"+(s3.equals(s4)));//true 拓展 注意：对于s3和s4来说，有一点不一样要引起注意，由于s3和s4是两个字符，串常量所生成的变量，其中所存放的内存地址是相等的，所以s3==s4是true（即使没有s3=s4这样一个赋值语句） 另外对于int等基本类型比较，只能用==，没有equals（）方法 对于基本类型的包装类型，比如Boolean、Character、Byte、Shot、Integer、Long、Float、Double等的引用变量，==是比较地址的，而equals是比较内容的（equals（）被重写了）。 对于object函数，equals（）也是比较首地址，可以在object函数里面重写equals方法，来达到比较的目的 
第316篇文章[0]
Junit单元测试程序运行bug：ClassNotFoundException 问题描述： 利用Junit进行单元测试的时候，之前都可以，但是有一天突然不行了，出现了ClassNotFoundException的异常提示，并且对于所有的Junit测试都是一样的。 原因分析： 原因分析有很多，java这方面的bug解决方案也有很多，很多人说是因为版本不匹配，jre，jdk版本之类的，我也不太懂，但是亲测两种方法是有效的。重新下载jdk，jre什么的解决方案，不在我的考虑之内，因为这样太麻烦了。 解决方案： PS：之前试了更改.classpath文件，里面加了output信息；也尝试了这个blog的方法，但是都没有用 1、后来我自己尝试的一种方法： 类似重新加载Junit5包。 我之前导入的Junit5包，后来尝试导入了Junit4包，然后用他进行单元测试用例，但是这个时候eclipse出现了错误 提示只能用版本5进行测试，然后我又重新换回来Junit5，这次居然成功了！！！ 2、clean。后来有出现了一次这样的情况，这次在eclipse里，project->clean，重新再进行Junit测试 
第317篇文章[0]
【总结】Obj&Spec SPEC Object 属性/数据 可变的不可变的方法 Spec实现 Spec: 定义：双方的“合同”/”防火墙“（外部不可见）基本结构： 前置条件（对参数的约束，对客户端的约束）后置条件（对返回值的约束，对开发者的约束）原则：​前置满足---->后置必须满足前置满足 >？(failfine)​Spec是给客户端看的，不要把程序内部暴露出来强度： stronger（对客户端更加友好/易使用，对开发者要求更高/难设计/实现方式更少）： 前置条件更弱,后置条件更强（在前置条件一样的情况下） 【注：看PPT的几个例子】 下面情况不可比较强度： ​前置变弱且前置相同时，后置变弱 ​当不可比较的时候，两个spec无法替代另一个 ​当可以比较的时候，可以用stronger的条件代替weaker的条件 Spec的强度： A>b: 可以用A取代b preA<=preb更弱的前置条件postA>=postb(以b的pre为准）更强的后置条件 更强的spec实现自由度小，难于开发易于使用ven图：更大的圈代表更大的实现自由度，spec强度更低 可以让后置条件减弱：Throwerror 参数检查的代价： 代价高：不实现，写在pre-condition中 代价低：检查，直接在post中抛出异常 
第318篇文章[0]
2021-06-06ADT总结 ADT总结 1.ADT的内容 属性（名词）rep内部数据结构不可见方法（动词）Spec规约impl实现方法，功能Spec可见impl不可见 对外部只有接口，封装后用户不关心内部 1.1ADT的内部方法可以大致分为以下四类 creator构造器 ​初始化，新建一个ADT对象 a.new() b.静态工厂：graph.empty() producer生产器 ​比如String.concat()能够返回一个新的对象,不改变内部数据 observer观察器 Eg:.size()看内部东西，不改变内部数据 mutator变值器Eg.Add()修改内部数据​大部分返回void/bool​只有mutable类型才有！ 1.2表示独立性 内部变化后，外部不因此受影响 ​为什么内部会变化(impl)？（优化性能，多种实现）​内部变化一定要遵循spec!(测试用例就是根据spec写的） 对于客户端，只能见到spec，无法看见rep和impl 比如：List可以有两种实现方式： Lista=NewarrayList Listb=NewlinkeList 但是从外部看来，调用方法并没有差异（比如.Add()、.remove()方法是一样的） 内部rep应该是private而不是public用户端使用的API不应该因为内部rep实现的改变而瘫痪 1.3表示泄漏/repexposure： ​个人理解：client获取到了你内部变量/获取到了你的内部实现方法（本来不应该看到的，给人看到了！） 如何避免表示泄漏： 全部属性private对于mutable类型 Collection.unmodifiable.wraped)（解决拷贝空间问题）防御式拷贝（返回一个拷贝后的新的对象） 尽可能用immutable数据类型 1.4如何测试一个ADT的方法（测试用例） adt的四种方法、 c/p/m用observer查看属性O先用c/p造出，再调用o代码覆盖率无须100% 2.ADT的不变性 “始终保持为真的一组条件” 2.1抽象空间A,实际空间R 抽象空间A：用户看到的值;(Abstract)实际空间R：内部维系的值(Realization) A中的值，一定能够在R中至少找到一个值与之对应(满射） ​（但是不是单射不一定） 2.2AFRI概念 AF（abstractfunction）抽象函数（就是A--R之间的函数） 抽象函数是表示从表示空间到抽象空间映射的函数比如：我存了一个graph图来表示人际关系​AF(graph)=现实中的人际关系图RI（repinvariant）表示不变量 表示不变量将表示变量值映射成一个布尔值。简单来说，就是一个条件，判断内部元素是否合法。比如：我要求图graph不为空，那么RI中就是“图不为空”这个条件。Checkrep():满足条件，合法；不满足，非法！使得属性都满足RI为true每个方法返回之前调用 用Assert+表达式 False:throwAssertErro(直接退出！违反了RI，程序没有必要继续错误地执行） 调用时机： C/P/M最后一行返回之前。 O按道理来说不会改变RI，但是防止粗心，也需要在最后写一个。 每次都调用，增加复杂度？ 开关！ -ea开发的时候，打开assert -da交付的时候，关闭assert 参考：AFRI的概念 unmodifiableList返回一个只能看不能改的方法 3.ADT的设计流程 设计一组方法（C/T/M/O）以及specTDD测试用例（根据spec）选择Rep（内部数据结构）/并impl设计RI（比如边的权值不为负，点不能为空）设计AF（R >A)（比如边对应人际关系）RI/AF的注释是为了提醒自己怎么避免表示泄漏（mutable与immutable都要考虑） 4.ADT如何保持表示不变性 对于immutable，只要保证没有/M对于RI：checkRep()无表示泄漏！（见1.3） 
第319篇文章[0]
【lab2】关于Equals和HashCode重写 为什么要重写Equals和HashCode？ 每当我们定义一个immutable类的时候，就应该考虑重写其Equals和HashCode ​一个immutable类，创造两个对象A,B;A和B有着一模一样的内容，但是由于内存地址的不同，我们用"==“或者是缺省的equals(内部实现还是”==")，是不能够得出他们相等的。 ​如果要想他们在外界看来是一样的，那就要重写类中的equals函数，而HashCode也应该随之重写。 ​因为：如果两个对象相同，就是适用于equals(java.lang.Object)方法，那么这两个对象的hashCode一定要相同ref 对于mutable的类，我们不必管Equals和HashCode，直接使用默认的即可 如何重写Equals和HashCode？ ​例子： @Override publicbooleanequals(Objectobj){ if(this==obj)returntrue; if(obj==null||this.getClass()!=obj.getClass())returnfalse; Personperson=(Person)obj; returnname.equals(person.name); } @Override publicinthashCode(){ returnObjects.hash(name,age); } [reference:] 重写hashcode方法|Tanthen HashMap什么时候重写hashcode和equals方法，为什么需要重写_Keith003的博客-CSDN博客 为什么使用HashMap需要重写hashcode和equals方法？_hxt的博客-CSDN博客_为什么要重写hashcode和equals方法 Java中hashCode的作用 
第320篇文章[0]
【lab2】defensivecopy HowtoDefensiveCopy 条件 方法返回一个mutable的数据类型 语法 withoutdefensivecopy: publicNamegetName(){ returnname; } 这种observer则会造成类中参数被改变的风险。 withdefensivecopy: publicNamegetName(){ returnnewName(name.toString()); } 对于抽象类型 lab2中给出的L是一个不知道类型的抽象数据类型，但是spec中有明确讲到必须是immutable的 *@param<L>typeofvertexlabelsinthisgraph,mustbeimmutable 所以我们在接口设计的时候不需要刻意实现防御式拷贝。 参考 
第321篇文章[0]
【lab2】scanner读文件 publicGraphPoet(Filecorpus)throwsIOException{ try{ Filefile=newFile("assets/test.txt"); Scannerscanner=newScanner(corpus); scanner.useDelimiter("\\s+"); StringpreWord=null; StringthisWord; inti=0; while(scanner.hasNext()){ thisWord=scanner.next(); graph.add(thisWord.toLowerCase()); if(i>0){ //不存在边，加入 intlastEdgeWeight=this.graph.set(preWord.toLowerCase(),thisWord.toLowerCase(),1); //如果边已经存在了，weight++ if(lastEdgeWeight!=0) this.graph.set(preWord.toLowerCase(),thisWord.toLowerCase(),lastEdgeWeight+1); } i=1; preWord=thisWord; System.out.println(); } scanner.close(); }catch(Exceptione){ thrownewIOException("FileNotReadableorNotFound"); } publicGraphPoet(Filecorpus)throwsIOException{ //读文件 try{ BufferedReaderreader=newBufferedReader(newFileReader(corpus)); BufferedReaderbReader=newBufferedReader(reader); Stringline; List<String>words=newArrayList<>(); while((line=bReader.readLine())!=null){ //单词小写加入图 words.clear(); words.addAll(Arrays.asList(line.split("\\s+"))); intnum=words.size(); for(inti=0;i<num;i++){ graph.add(words.get(i).toLowerCase()); if(i>0){ //不存在边，加入 intlastEdgeWeight=this.graph.set(words.get(i-1).toLowerCase(),words.get(i).toLowerCase(),1); //如果边已经存在了，weight++ if(lastEdgeWeight!=0) this.graph.set(words.get(i-1).toLowerCase(),words.get(i).toLowerCase(),lastEdgeWeight+1); } } } bReader.close(); checkRep(); }catch(Exceptione){ thrownewIOException("FileNotReadableorNotFound"); } //thrownewRuntimeException("notimplemented"); } ``` 
第322篇文章[0]
【总结】ADT ADT总结 1.ADT的内容 属性（名词）rep内部数据结构不可见方法（动词）Spec规约impl实现方法，功能Spec可见impl不可见 对外部只有接口，封装后用户不关心内部 1.1ADT的内部方法可以大致分为以下四类 creator构造器 ​初始化，新建一个ADT对象 a.new() b.静态工厂：graph.empty() producer生产器 ​比如String.concat()能够返回一个新的对象,不改变内部数据 observer观察器 Eg:.size()看内部东西，不改变内部数据 mutator变值器 Eg.Add()修改内部数据 ​大部分返回void/bool ​只有mutable类型才有！ 1.2表示独立性 内部变化后，外部不因此受影响 ​为什么内部会变化(impl)？（优化性能，多种实现）​内部变化一定要遵循spec!(测试用例就是根据spec写的） 对于客户端，只能见到spec，无法看见rep和impl 比如：List可以有两种实现方式： Lista=NewarrayList Listb=NewlinkeList 但是从外部看来，调用方法并没有差异（比如.Add()、.remove()方法是一样的） 内部rep应该是private而不是public用户端使用的API不应该因为内部rep实现的改变而瘫痪 1.3表示泄漏/repexposure： ​个人理解：client获取到了你内部变量/获取到了你的内部实现方法（本来不应该看到的，给人看到了！） 如何避免表示泄漏： 全部属性private对于mutable类型 Collection.unmodifiable.wraped)（解决拷贝空间问题）防御式拷贝（返回一个拷贝后的新的对象） 尽可能用immutable数据类型 1.4如何测试一个ADT的方法（测试用例） adt的四种方法、 c/p/m用observer查看属性O先用c/p造出，再调用o代码覆盖率无须100% 2.ADT的不变性 “始终保持为真的一组条件” 2.1抽象空间A,实际空间R 抽象空间A：用户看到的值;(Abstract)实际空间R：内部维系的值(Realization) A中的值，一定能够在R中至少找到一个值与之对应(满射） ​（但是不是单射不一定） 2.2AFRI概念 AF（abstractfunction）抽象函数（就是A--R之间的函数） 抽象函数是表示从表示空间到抽象空间映射的函数比如：我存了一个graph图来表示人际关系​AF(graph)=现实中的人际关系图RI（repinvariant）表示不变量 表示不变量将表示变量值映射成一个布尔值。简单来说，就是一个条件，判断内部元素是否合法。比如：我要求图graph不为空，那么RI中就是“图不为空”这个条件。Checkrep():满足条件，合法；不满足，非法！使得属性都满足RI为true每个方法返回之前调用 用Assert+表达式 False:throwAssertErro(直接退出！违反了RI，程序没有必要继续错误地执行） 调用时机： C/P/M最后一行返回之前。 O按道理来说不会改变RI，但是防止粗心，也需要在最后写一个。 每次都调用，增加复杂度？ 开关！ -ea开发的时候，打开assert -da交付的时候，关闭assert [参考：AFRI的概念](表示不变量（RepresentationInvariant）与抽象函数（AbstractFunction）-siren27-博客园(cnblogs.com)) unmodifiableList返回一个只能看不能改的方法 3.ADT的设计流程 设计一组方法（C/T/M/O）以及specTDD测试用例（根据spec）选择Rep（内部数据结构）/并impl设计RI（比如边的权值不为负，点不能为空）设计AF（R >A)（比如边对应人际关系）RI/AF的注释 怎么避免表示泄漏？（mutable与immutable都要考虑） 4.ADT如何保持表示不变性 对于immutable，只要保证没有/M对于RI：checkRep()无表示泄漏！（见1.3） 
第323篇文章[0]
【lab2】Safetyfromrepexposure 简单来说，一个主类有属性和方法两种成分，这里的主类是指用户直接使用的类，需要做到以下两点 1、将类中所有的属性（变量）定义为private类型， ​目的是不让用户得到你的内部属性 2、方法或者返回immutabledata，或者返回本应该返回的mutabledata的副本，或者返回一个不可修改的mutabledata ​1、尽量使用immutable数据类型，比如能使用String就不使用StringBuilder，能使用Instance就不使用Data ​2、为了创造mutabledata的副本，可以进行defensivecopy。可以在主类方法中构造然后返回，但是推荐方法是使用mutable数据类型的clone，假如该mutable数据类型是自己写的类，那么推荐在类中写一个clone的方法 ​3、使用Collections.unmodifiableSet等方法 这里需要注意的是第二个方面，如果想要返回一个Collection类的数据，有人说我创建了一个Collection类，向里面添加数据后，不管数据怎样，都算defensivecopy了，但是如果数据是mutable类型，那么就不算defensivecopy，因为Collection类储存的是地址，尽管new了一个hashSet或者hashMap，但是没有真正的对mutable数据进行defensivecopy。  版权声明：本文为CSDN博主「djd566」的原创文章，遵循CC4.0BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/djd566/article/details/79749757 
第324篇文章[0]
【lab2】如何在@test测试函数中抓获异常 @Test(expected=IllegalArgumentException.class) publicvoidtestEmptyVertexToString()throwsIllegalArgumentException{ newVertex<>(null);//传入null参数报错，抛出IllegalArgumentException异常 } 
第325篇文章[0]
SoftwareConstructionlab2：总结 SoftwareConstructionlab2 junit测试代码覆盖率： ​代码覆盖率可以使用IDEA自带的工具 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wTShgQvr-1622905245128)(E:\Typora_info\pong\image-20210605214220642.png)] 整体设计流程： 写Spec 根据Spec完成测试用例 实现Graph 防止内存泄漏的方法 1.内部变量尽量使用immutable的，并设置为私有属性 2.对于返回值，如果是mutable数据类型，一定要使用防御式拷贝 3.必要时加上final关键字 checkRep()的意义 ​我们定义的每一个对象，都要遵循规约，而checkRep()就是我们检查对象内部属性是否合法的方法。 ​调用时机：应该在所有方法的最后一行/返回前调用checkRep(),不必担心影响程序速度，可以关掉。 读取TXT文件 参考 使用BuffererReader.继承Reader类 publicvoidfileRead()throwsException{ Filefile=newFile("D:\\test.txt");//定义一个file对象，用来初始化FileReader FileReaderreader=newFileReader(file);//定义一个fileReader对象，用来初始化BufferedReader BufferedReaderbReader=newBufferedReader(reader);//new一个BufferedReader对象，将文件内容读取到缓存 StringBuildersb=newStringBuilder();//定义一个字符串缓存，将字符串存放缓存中 Strings=""; while((s=bReader.readLine())!=null){//逐行读取文件内容，不读取换行符和末尾的空格 sb.append(s+"\n");//将读取的字符串添加换行符后累加存放在缓存中 System.out.println(s); } bReader.close(); Stringstr=sb.toString(); System.out.println(str); } ​way2:使用FileInputStream类 privatestaticStringgetTemplateContent()throwsException{ Filefile=newFile("D:\\test.txt"); if(!file.exists()){ returnnull; } FileInputStreaminputStream=newFileInputStream(file); intlength=inputStream.available(); bytebytes[]=newbyte[length]; inputStream.read(bytes); inputStream.close(); Stringstr=newString(bytes,StandardCharsets.UTF_8); returnstr; } java异常捕获 ​java异常捕获 try{ d=Double.parseDouble(bidPrice); }catch(Exceptione){ e.printStackTrace(); //方法也抛出了异常，交由调用者处理 thrownewAuctionException("这是由throw关键字抛出的异常"); } try{ at.bid("abc"); }catch(AuctionExceptionae){ System.err.println(ae.getMessage()); } ​ 
第326篇文章[0]
【lab2】关于构造器非法参数的问题 结论：如果判断条件非法，直接抛出异常 thrownewIllegalArgumentException("Wrong!"); 参考网址 下面直接截取详细内容：Iftheprogrameverexecutesastatementlike: thrownew???Exception("…message…"); Javastopstheprogramandsignalstheerrorthroughtheconstructedinstanceofthe???Exception(wherethe???arereplacedbythenameofwhicheverparticularexceptionisdesired).Forourpurposes,thiswillsimplyterminatetheprogramandprintthegivenerrormessage. 
第327篇文章[0]
【lab2】如何创建可变类&不可变类 如何创建可变类&不可变类 可变类和不可变类(MutableandImmutableObjects) 可变类和不可变类的区别：是否有mutator方法（是否可以更改属性） 可变类和不可变类(MutableandImmutableObjects)的初步定义： 可变类：当你获得这个类的一个实例引用时，你可以改变这个实例的内容。 不可变类：当你获得这个类的一个实例引用时，你不可以改变这个实例的内容。不可变类的实例一但创建，其内在成员变量的值就不能被修改。 举个例子：String和StringBuilder，String是immutable的，每次对于String对象的修改都将产生一个新的String对象，而原来的对象保持不变，而StringBuilder是mutable，因为每次对于它的对象的修改都作用于该对象本身，并没有产生新的对象。 如何创建一个自己的不可变类： a.所有属性都是privatefinalb.不提供对成员的改变方法，例如：也就是王老师上课说的 “immutable类不能有mutator的方法” c.确保所有的方法不会被重载。手段有两种：使用finalClass(强不可变类)，或者将所有类方法加上final(弱不可变类)。d.确保类不能被继承：​将类声明为final,或者使用静态工厂并声明构造器为private。 静态工厂能保证对象创造时的唯一性；并且由于命名不是固定的，更能清楚地表达意思。 (如果类可以被继承会破坏类的不可变性机制，只要继承类覆盖父类的方法并且继承类可以改变成员变量值，那么一旦子类以父类的形式出现时，不能保证当前类是否可变。) 如果某一个类成员不是原始变量(primitive)或者不可变类，必须通过在成员初始化(in)或者get方法(out)时通过深度clone方法，来确保类的不可变。 reference:可变类与不可变类的区别 reference:JAVA-可变对象与不可变对象 优质reference：[Java]如何实现一个不可变类（Immutableclass） 
第328篇文章[0]
正则表达式在Java语言程序编程时如何从文件中读取数据并运用 正则表达式在Java语言程序编程时如何从文件中读取数据并运用 1.读取文件 读取文件的方式有很多，这里我简单地使用字符串标明路径，通过路径创建文件型变量（File）。 Stringfilepath="src/txt/test.txt"; Filefile=newFile(filepath); Scannerfileread=newScanner(file); 这时我们能够从文件以字符串的形式读取内容，通过相关的正则表达式来判断内容是否正确。 2.转换文件信息 我们无法直接从文件里获取数据给程序中的变量，因此我们要暂时存储数据 Stringtext=""; while(fileread.hasNext()){ text+=fileread.nextLine(); text+="\n"; } fileread.close(); 这里为了保证文件读取后转换为String类型时其内容的结构不变（如果你使用过正则语言表达式，你会发现空格是很恶心的东西），所以我们使用Scanner.nextLine()来成行地读取数据。 3.再次提取信息 Strings;   Patternpattern=Pattern.compile(Stringparser); Matcherm=pattern.matcher(s); while(m.find()){ System.out.println(m.group()); } 这是一段很经典的正则语言匹配代码，parser为字符串类型变量，它表示的是正则语言表达式；而m可以看作是正则表达式在s中索引内容parser的一个方法概括,m.find()代表正则表达式找到了一个匹配的对象，此时如果再m.find()的话正则表达式会去寻找下一个匹配的对象（这一点和next()很像）。在这里要注意的是m.group()返回的是m.find()找到的对象，这就意味着，如果开始时没有m.find()，m.group()是不起作用的；同时，如果只进行一次m.find()，无论输出多少次m.group()都只是最靠近的一次m.find()找到的内容。 4.提取变量内容 在这里，比如说我想提取一段时间，文本内容是   {2021-01-01,2021-02-03}   这里我们进行一下简单约束，我们可以设计一个正则语言把时间提取出来 parser="//{20[0-9][0-9]-[0-9][0-9]-[0-9][0-9],20[0-9][0-9]-[0-9][0-9]-[0-9][0-9]//}"; 通过我上述的代码完全可以获得 Stringmessage=m.group(); 我们再精确提取时间 intyear1,year2,month1,month2,day1,day2; PatternYear=pattern.compile("20[0-9][0-9]"); PatternMonth=pattern.compile("[0-9][0-9]"); PatternDay=pattern.compile("[0-9][0-9]"); Matcheryear=Year.matcher(message); Matchermonth=Month.matcher(message); Matcherday=Day.matcher(message); year.find();//**2021**-01-01,2021-02-03 year1=Integer.parseInt(year.group()); year.find();//2021-01-01,**2021**-02-03 year2=Integer.parseInt(year.group()); month.find();//**20**21-01-01,2021-02-03 month.find();//20**21**-01-01,2021-02-03 month.find();//2021-**01**-01,2021-02-03 month1=Integer.parseInt(month.group()); month.find();//2021-01-**01**,2021-02-03 month.find();//2021-01-01,**20**21-02-03 month.find();//2021-01-01,20**21**-02-03 month.find();//2021-01-01,2021-**02**-03 month2=Integer.parseInt(month.group()); day.find();//**20**21-01-01,2021-02-03 day.find();//20**21**-01-01,2021-02-03 day.find();//2021-**01**-01,2021-02-03 day.find();//2021-01-**01**,2021-02-03 day1=Integer.parseInt(day.group()); day.find();//2021-01-01,**20**21-02-03 day.find();//2021-01-01,20**21**-02-03 day.find();//2021-01-01,2021-**02**-03 day.find();//2021-01-01,2021-02-**03** day2=Integer.parseInt(day.group()); 此时变量数据便提取了出来。 
第329篇文章[0]
停车场管理系统-----软件构造习题课代码分析 题目描述： 软件框架： ADT设计： 静态工厂方法 /** *创建一个新的停车场 * *@paramnos各停车位的编号，均为自然数，且无重复 *@paramwidths各停车位的宽度，包含的元素数量=nos中元素数量且>=5 *@return一个停车场对象，包含了widths.length个车位，各车位的宽度与nos中相应数字一致，且各车位上均未有停车 *@throws如果违反nos和widths不合法 */ publicstaticParkingFieldcreate(int[]nos,int[]widths)throwsException{ returnnewConcreteParkingField(nos,widths); } 创建一个新的停车场。 停车： /** *在某个停车位上停车 *车牌号为plate的车辆，之前没停在车场，执行后停在了车位号为num的车位上，该车位宽度大于车宽度 *其他车位的状态不变 * *@paramplate要停进来的车辆车牌号，notnull *@paramwidth车的宽度，自然数 *@paramnum指定的停车位编号，自然数 *@throws如果plate车已经停在该停车场，或者num车位已被其他车占用，或者num车位宽度不超过width，或者num并不是合法车位 */ publicvoidparking(Stringtype,Stringplate,intwidth,intnum,String[]extraRegistrationInfo)throwsException; 驶离停车场： /** *将汽车驶离停车场，plate车原来占用的车位空出来了，计算出本次停车的费用（半小时10元，不足半小时按半小时计算） * *@paramplate待驶离的车辆，notnull *@return本次停车的费用（精确计算得到） *@throwsplate车并没有停在本车场 */ publicdoubledepart(Stringplate)throwsException; 停车场状态: /** *返回当前停车场每个车位的状态（空，或被某车占用） * *@returnKey为停车位的编号，Value为该车位上的车辆车牌号。如果停车位上无车辆，则对应的Value为“” */ publicMap<Integer,String>status(); 以上是核心方法，其他辅助性的方法不再说明。方法的实现都十分简单，并不是软件构造课的主要内容，故对其逻辑不一一说明。 面向复用的设计： 相机场等，本质上和停车场的功能完全一样，所以我们设计的ADT如果有很好的复用性的话，只需经过少量的扩展，就可以实现一个更加复杂的场景下的类。 我们首先将Car扩展成Parkable，即停放的东西不止可以是车，还可以是飞机、摩托车等。针对Parkable，设计一组方法来描述其行为。 publicinterfaceParkable{ publicintgetWidth(); publicStringgetPlate(); publicdoublegetPricingUnit(); publicdoublegetPrice(); publicStategetState(); publicvoidsetState(Statestate); publicstaticParkablecreate(Stringtype,Stringplate,intwidth,String[]extraRegistrationInfo)throwsException{ returnnewParkableFactory().create(type,plate,width,extraRegistrationInfo); } } 为了避免在客户端代码使用new操作，我们使用静态工厂方法来代替new操作。 publicstaticParkablecreate(Stringtype,Stringplate,intwidth,String[]extraRegistrationInfo)throwsException{ returnnewParkableFactory().create(type,plate,width,extraRegistrationInfo); } 接着，针对各种交通工具进行方法的实现。 如，Car类： publicclassCarextendsConcreteParkable{ privatefinalDriverRegistrationdr=newDriverRegistration(); publicCar(Stringplate,intwidth){ super(plate,width); pricingUnit=30; price=10; } publicvoidregisterDriver(Stringname){ dr.registerDriver(name); } publicStringgetDriverInfo(){ returndr.getDriverInfo(); } @Override publicStringtoString(){ return"Car"+super.toString(); } } 工厂方法： 针对不同的类，提供工厂方法来创建实例对象，将对象类型作为一个参数，定义到工厂方法中去，Stringtype，这样，在每次创建时根据不同的类型来创建不同类型的实例。 publicParkablecreate(Stringtype,Stringplate,intwidth,String[]extraRegistrationInfo)throwsException{ if(type.equals("car")){ Carc=newCar(plate,width); c.registerDriver(extraRegistrationInfo[0]); returnc; }elseif(type.equals("motor")){ Motorm=newMotor(plate,width); m.registerDriver(extraRegistrationInfo[0]); returnm; }elseif(type.equals("plane")){ Planep=newPlane(plate,width); Calendarc=Calendar.getInstance(); //根据extraRegistrationInfo[1]字符串设置c的值 p.registerAirport(extraRegistrationInfo[0],c); returnp; } else thrownewException("Illegaltype"); } State设计模式： 创建State接口，实现两个状态，一种是停着（parking)，一种是在路上（depart）让Parkable拥有一个属性State，能够管理自己的状态。 Decorator设计模式： 建立一个用于装饰的基础类ComplexParkingField，实现ParkingField接口，其中的所有方法都delegate到未装饰之前的对象。然后，建立一个具体装饰类ParkingFieldWithCompany，也实现ParkingField接口，继承自ComplexParkingField类，增加了rep（公司信息），对需要变化的方法进行扩展（使用super.xxx()调用基础功能）。修改构造函数，增加company参数。 privateStringcompany; privatevoidcheckRep(){ assertcompany!=null&&company.length()>0; } publicParkingFieldWithCompany(ParkingFieldpf,Stringcompany){ super(pf); this.company=company; checkRep(); } @Override publicvoidparking(Stringtype,Stringplate,intwidth,intnum,String[]extraRegistrationInfo) throwsException{ super.parking(type,plate,width,num,extraRegistrationInfo); System.out.println("-------"+plate+","+this.company+"welcometoparking"); } visitor设计模式： 扩展其他功能：考虑将来对ParkingField的功能扩展。例如要扩展的一个功能是统计停车场当前时刻占用比例(=已停车的车位数量总车位数)。建立visitor接口ParkingVisitor，只有一个方法doublevisit(parkingFieldpf)。建立其子类PercentageVisitor，实现该visit方法，调用pf的方法获得pf的内部表示，进行计算。在ParkingField接口中增加accept(ParkingVisitorpv)方法，其实现很简单：pv.visit(this)。 publicinterfaceParkingVisitor{ publicdoublevisit(ParkingFieldpf); } 如果还有其他功能，可以继续定义visitor进行扩展。 
第330篇文章[0]
HIT软件构造---Git工具使用遇见的问题 HIT软件构造--------Git工具使用小记 目录 ==HIT软件构造==--------Git工具使用小记==校园网==登录不上github==git==常见指令（只列平常用的多的，其他建帮助手册）记录一些在使用git时遇见的==奇怪问题== 校园网登录不上github 只能说太离谱了，不翻墙登不上github，被针对了？ git常见指令（只列平常用的多的，其他建帮助手册） 1.gitinit:初始化一个本地git仓库2.gitclone[url]:将[url]处的远程仓库拷贝到本地3.gitadd*:将当前文件下的所有文件（*代表所有文件）提交到暂存区4.gitcommit-m"":提交暂存区的文件到本地仓库""内记录一些本次提交的信息5.gitpushoriginmaster:master:这个指令更一般化的形式是gitpush远程主机名远程分支名本地分支名，可以将本地仓库的文件提交到远程仓库（github、gitee等）6.gitfetch:将远程仓库的某分支拉取到本地仓库7.gitmerge：合并分支8.gitpull：相当于gitfetch+gitmerge：将远程仓库直接拉取并和本地仓库合并 记录一些在使用git时遇见的奇怪问题 1.fetch、pull、push、clone时遇到Failedtoconnecttogithub.comport443:Timedout的错误而且还时有时没有的，把人整蒙了。 在翻墙时会自动打开使用代理服务器这一项，导致连接不到github的端口，所以我们把这一项取消，并选中上面的自动检测。 如图所示，这样就不会出现timeout的错误了。 2.main和master的问题以往github默认分支名字时master，但是到2020年之后github官方将默认名字改为了main。但是老师明确说明要将代码提交到master分支，所以我们要建立一个master分支，再将其提交上去。 
第331篇文章[0]
Java正则表达式的使用 写在前面 学过形式语言与自动机的小伙伴对regex应该都不陌生了，我们简单的回顾几个离散中的概念， ( a ) ∗ (a)^{*} (a)∗代表的是克林闭包，代表a可以重复 ( 0 , ∞ ) (0,\infty) (0,∞)次，而 ( a ) + (a)^{+} (a)+代表正闭包，说明a最少出现一次。 Java中regex的应用 如果想匹配一段特定的串，直接输入即可数字：\d或者[0-9]字母：\w或者[a-zA-Z]空白：\s重复0次以上：*重复1次以上：+0次或1次：？其他都用处不大，可以大概找手册看一遍，知道有那些东西，用的时候再去查就可以。Attention：在java正则表达式中\代表反斜杠，所以转义字符前的那个斜杠要输入\才行，也就是说如果我们要去比配数字，我们要使用\\d+，而不是\d+ 实际用法 字符串本身就有一个matches方法 我们随意选举一个字符串对象实验，可以发现matches方法返回的是一个Boolean值，如果能够匹配给出的regex就返回true，这就是最简单也是最实用的方法了。 更加复杂的用法 前面的matches方法已经非常使用了，但是有时候我们需要从大型的文本中去匹配一些对象，此时matches方法就不好使了，所以我们需要结合java提供的Pattern和Matcher类来对文本进行读取。 我们首先使用文本读取的方法将字符串读入到一个字符串对象中。现生成一个Pattern对象，注意，这个对象只能由工厂方法创建即: Patternregex=Pattern.compile() 然后再括号内输入你想要的正则表达式即可。接下来创建一个matcher对象，matcher对象的创建是根据之前我们已经创建的Pattern对象直接创建的：其参数是我们想要匹配的文本，即我们之前从文本文件中读取的字符串，我们将其输入在括号中即可。 接下来主要有三个方法： matches：只有整个字符串都符合regex，才返回truelookingAt：从串的最前面开始匹配，有能够匹配的上的，就返回truefind：只要整个串中有匹配的地方，就返回true当我们用以上三个方法找到对应的匹配时，用**m.group()**方法就可以得到匹配的字符串啦。这就是regex最简单的应用了。 
第332篇文章[0]
EclEmma的安装与使用----HIT软件构造 EclEmma EclEmma是一个软件测试工具，可以查看代码的调用情况，也可以检查测试用例代码执行的覆盖率。直接打开Eclipse，在商店里面搜索安装。安装好后左上角有一个coverage按钮。运行即可：这是其中一段代码的示例，绿色说明覆盖的比较好，黄色差一等，红色最差。可以在弹出来的coverage栏查看覆盖率。 
第333篇文章[0]
HIT软件构造----保姆级Gradle安装教程（10分钟入门） Gradle安装教程 官网：https://gradle.org/ 首先安装Gradle，我们打开官网，点击installgradle在prerequisites中发现，需要jdk在1.8以上（现在也没人用老版本了把哈哈）下面一堆英文，不想看的同学光看楼主所说的就可以了：翻到下面，点击这个蓝色Download随便选一个版本，然后点击binary-only，将这个zip文件随便下载到任何一个地方：然后将它解压： 完全不用像官网说的放在c盘，随便放哪都行，但是要记住它。接着我们添加环境变量：这个过程有过开发经验的同学应该都很熟悉把，具体的就是右键此电脑–》属性–》高级系统设置–》环境变量–》在系统变量中找到Path：点击编辑，新建，浏览，找到刚才解压的地方：选择Gradle目录下的gradle-7.0.2目录下的bin，添加即可。 接下来打开cmd，输入gradle-v进行验证，出现以上信息说明你的安装大功告成啦！ 如上图，可以直接在eclipse和idea中安装插件，楼主使用的是eclipse，所以我们点击eclipse。进入到下面这个网址：https://www.vogella.com/tutorials/EclipseGradle/article.html根据介绍我们可以知道，最简单的方法就是进入eclipse，然后在商店里下载即可。工具栏中点Help，然后选最下面的EclipseMarketplace。搜索BuildshipGradle，安装即可。如果是新建一个Gradle工程的话，直接在新建工程的地方创建即可：File–>new–>other 然后选择Gradle即可：由于楼主的工程是已经创建好了，所以需要用另一种方式来添加Gradle配置： 在工程名处右键单击，选择Configure，然后选择AddGradleNature： 
第334篇文章[0]
java中的泛型中的静态方法 泛型方法 泛型方法就是要在权限符和返回值之间声明泛型，通常用L、V、E、T、K等字母，然后就可以在这个方法的内部将其看作一种方法类型了 在实验中遇到的问题 publicstatic<L>IntervalSet<L>empty()throwsException{ thrownewRuntimeException(); } 本以是想用静态工厂方法定义一个初始化的方法，但是发信并不能使用类定义的泛型。 静态方法不能直接使用类定义的泛型，也就是说如果要在静态方法中使用泛型的话，就必须将其声明为泛型方法。 查阅的材料 https://www.cnblogs.com/coprince/p/8603492.html链接 
第335篇文章[0]
HIT软件构造----Reading6:Specifications（fromMITSoftwareConstruction） Specifications 原文链接http://web.mit.edu/6.031/www/sp20/classes/06-specifications/ Introduction Thespecificationactsasacontract:theimplementerisresponsibleformeetingthecontract,andaclientthatusesthemethodcanrelyonthecontract.同老师上课讲法，spec就是客户端和开发者之间的合同，开发者必须按照合同实现方法，用户必须按照合同去使用方法。 本文将讨论preconditions、postconditions、exceptions三个重要概念 Javaneededforthisreading 需要我们了解exception的概念try、catch的用法很简单的基本概念，用过java的同学应该都知道。 Behavioralequivalence 所谓的行为等价性：whetherwecouldsubstituteoneimplementationfortheother。即我们是否可以用一段代码去代替另一段代码。如下面两个小例子：1. staticintfind(int[]arr,intval){ for(inti=0;i<arr.length;i++){ if(arr[i]==val)returni; } return-1; } staticintfind(int[]arr,intval){ for(inti=0,j=arr.length-1;i<=j;i++,j--){ if(arr[i]==val)returni; if(arr[j]==val)returnj; } return-1; } 两个方法都是在一个数组中寻找是否存在某个数，如果存在则返回下标，如果不存在则返回-1。我们的问题是：是否能够用方法2来代替方法1呢？即这两个方法是否具有行为等价性呢？答案是不能的，如果有待查找的数字多次出现在了这个数组中，第一个方法会返回第一次出现时的下标，第二个方法会返回最小或者最大的下标，取决于谁更加靠近端点。而如果我们加上一个限定条件：只有一个待寻找的数存在在数组当中的话，那么两个方法的返回值就是唯一的，在这个条件的约束下，两个方法具有行为等价性。行为等价性的定义是从客户端的角度来说的，如果一个方法能够替换另一个，则两方法具有行为等价性。 staticintfind(int[]arr,intval) requires: valoccursexactlyonceinarr effects: returnsindexisuchthatarr[i]=val 博客中给出的习题，复习时均应阅读：spec和test（test-first-programming）一定要先写好 两句很有启发的话：strongpreconditionhidestheirpotentialdifferencesinbehavior.前置条件太强的话，会盖住潜在的行为不同性，两个看起来不同的方法在很强的前置条件下会具有行为等价性。==aweakpostconditionpermitstheirdifferencesinbehavior==前置条件太弱，就会允许一些行为上的差异，但是两方法仍具有行为等价性。 Whyspecifications? spec可以帮助我们使程序更好理解，我们要了解一个方法能干什么，只读spec即可，不必费心神去读源代码。也可以帮助我们更快的确定bug的位置。spec不仅像用户和实现者之间的合同，也像用户和实现者之间的防火墙。implementer可以用任何的数据结构和算法来实现spec要求的功能，而不必将细节暴露给客户端。这样的防火墙带来的好处就是将客户端和实现者解耦（decoupling）。 Specificationstructure spec的构成：1.方法名，参数类型，返回值类型，抛出异常的类型2.requires（pre）3.effects（post）满足precodition是客户端的义务。而满足postcondition是实现者的义务。参数类型和requires都是precondition。返回值类型和抛出异常的类型和effects都是postcondition。 前置条件满足，后置条件必须满足前置条件不满足，后置条件随意，实现者可以做任何事（即使是不道德的事情） Whenourpreconditionisviolated,theclienthasabug.Wecanmakethatbugeasiertofindandfixbyfailingfast,eventhoughwearenotobligatedtodoso.自律的要求（即使没有任何人要求我们这么做）：抛出异常，failfast（让程序尽快死掉），检查bug。 SpecificationsinJava @param@return@throw用这样的语法可以自动生成帮助手册。例： spec的注释第一行两个星号不用加参数类型或着返回值类型没有@requires和@effects这样的关键字 **什么是spce不应该说的：** 局部变量，私有属性，算法实现的任何细节，实现者应该保证细节对读代码的人不可见。 Donotallownullreferences 原始类型不能被赋值为null：（8种primitives）byte、short、int、long、float、double、boolean、char。你无法访问null对象的任何属性和方法。例如Stringname=null;name.length()----------------->throwsNullPointExceptionnull通常是危险的，所以spec除非显示说明可以接受null，否则null是不能做为参数和返回值的。所以默认任何spec都有一个precondition：参数不能是null，也都有一个postcondition：返回值不能是null！！！Avoidnull!!!建议显示的使用@NonNull关键字来说明禁止出现null，这样编译器就会自动检查。 void也是一个值，如果返回类型是void，只能用return;null.length()会导致NullPointerException 关键：只要没提参数或者返回值可以是null，就默认不能是null。 Includeemptiness null和emptiness的差别：null和空串的差别，类似于形式语言与自动机那门课中， ϕ 和 ϵ \phi和\epsilon ϕ和ϵ的区别。List.of()返回一个空列表。 只要没说可以用null，就绝对不能用null。前件不成立，后件无条件成立。 Testingandspecifications Testingunits 集成测试：一个测试用例结合各个模块的功能。不应该使测试用例违反前置条件，否则测试没有意义。如果编译器能检查出某种错误，那么它不应该被写入spec，那是多余的。 Specificationsformutatingmethods 后置条件存在的side-effects，可能会修改某个内部的值。 pre必须限制list1不等于list2，否则有可能算法无法停止。 就像null如果不特殊说明就被禁止出现在参数和返回值中一样，mutation不特殊说明也被禁止出现在参数和返回值中。 Exceptions 例： IndexOutOfBoundsException NullPointException ArithmeticException NumberFormatException 出现不应该出现的情况时，以往的程序员往往返回一个特殊值，如-1，null，9/9/99等，然而这样时有问题的，我们不仅容易忘了这么做，而且还会导致我们无法发现程序中存在的bug。Java的异常处理机制，提供以下两种做法: 用throw抛出异常用trycatch处理异常例题：try必须跟catch或者finally，否则静态检车都过不去。try和catch会把变量的作用域分开，在try中声明的变量到这个大括号外面就直接被释放了，不再存在，不能对它赋值或者引用。空的catch体是一个很坏的编程习惯，尽量不要这么去做。它捕获了异常，但又什么都不做，让程序继续执行下去。chainedexception，将原来捕获的异常作为新的异常的构造器的参数传入，构造一个新的异常，然后继续抛出。 Checkedanduncheckedexceptions 从上一个部分可以看出异常机制的两个重要理由：特殊的返回值和bug检测。有这样一通用的规则：用checkedexceptions来标识特殊值，用uncheckedexceptions来标识bug。 checkedexceptions:需要在函数声明中写throwXXXXException，这样编译器就会进行静态检查。Exception之下有一支全是checkedexceptionRuntimeException下面全是uncheckedexception当用catch，你最好用最细分的exception类型，而不是简单的用Exception或者RuntimeException，可能会影响静态检查或者隐藏bug。 unchecked的exception最好不要抛出来，而是直接打印信息，方便我们找到bug所在。checked的exception要抛给上一层，告诉我们需要处理特殊值了（情况不符合）。抛出的异常就类似于我们以往的编程工作中所写的函数所返回的特殊值（例如遇到找不到的情况就返回-1，并在main函数中检测这个特殊值）。可以把抛特殊值等价于抛异常。 Error是UncheckedException，但是error不是exception的子类，所以无法被try，catch捕获。而且直接自动打印栈信息。checkedexception：@throws和throws都要写uncheckedexception：只用写@throws Summary SafefrombugsEasytounderstandReadyforchange 
第336篇文章[0]
面向可复用性的软件构造 一.复用的等级和形态 源代码级别的复用：复制粘贴模块级别的复用：类与接口库级别的复用：API和包 二.复用的类型 白盒复用：复制并修改一段代码。可以对代码的功能进行定制，但是愮指导代码内部的实现逻辑，增加了软件的复杂度。黑盒复用：不能直接看到源代码，只是利用别人提供的API，更加简单，但是适用性差。 三.源代码级别的复用 粘贴代码 四.模块级别的复用：类与接口 继承： 设计继承树可能会重写一堆方法（@Override）extend是类级别的复用 代理： 显式代理：传递对象给需要使用这些功能的对象隐式代理：将某个对象定义为这个对象的成员，去调用其方法是对象级别的复用 五.库级别的复用：API和包 库：开发者构造软件，去调用库中的功能框架：可以复用的骨架代码，可以定制功能到某个应用。框架作为主程序去执行，执行过程中调用开发者自己写的程序 六.框架级别的复用 框架：一组抽象类和具体类，以及他们之间的关系。开发者根据框架的规约，填充一些自己的代码进去，形成完整的代码 白盒框架：通过继承进行框架的扩展黑盒框架：通过实现特定的接口、或者通过dialing来进行扩展 七.行为子类型和LSP原则 子类型多态：客户端可以用统一的方式来处理不同类型的对象。使用父类的地方，都可以无条件用子类来代替。静态类型检查（即编译器对子类型的要求）： 子类型可以添加方法，但是不可以删除子类型需要实现抽象类型中的所有未实现的方法子类型中重写的方法必须有相同或子类型的返回值候符合协变的返回值子类中重写的方法必须使用同样类型的参数或者符合逆变的参数子类型中重写的方法不能抛出额外的异常总结：更强的不变量、更弱的前置条件、更强的后置条件协变：返回值的类型和异常的类型要更加具体。 Object-->String Throwable-->IOException 逆变：参数类型要更加抽象。 String-->Object 理论上是这样的，但是目前java还不支持这样，还是会将其当作overload而不是override看待。但是泛型中的参数不能这样理解，协变后的泛型不是原类型的子类型：List<Integer>不是List<Number>的子类型。也就是说Myclass<A>和Myclass<B>没有任何关系，无论A和B是否有关系。 泛型中的通配符 List<?>是一个不知道什么类型的列表使用通配符的典型场景： 你实现的方法可以通过使用Object类的方法来实现当你的方法在泛型类中不依赖参数的类型时，如List.size,List.clear等List<Object>很可能使错误的用法，而正确的用法使List<>?>通配符下界：<?superA>，A的父类和自己都可以传入通配符下界：<?extendsA>，A的子类和自己都可以传入List<Number>是List<？>的子类型List<Number>是List<？extendsObject>的子类型List<Object>是List<？superString>的子类型 八.委派（delegation） InterfaceComparator<T>intcompare(To1,To2)如果ADT需要实现比较大小的操作，或着要放入Collections或Arrays中进行排序，实现Comparator接口并重写compare方法InterfaceComparable<T>让ADT实现Comparable接口，然后overridecompareTo方法 区别：不用构建新的Comparator类，比较代码放在ADT内部委派（delegation）：一个对象请求另一个对象的功能，通过运行时动态绑定，实现对其他类中代码的复用显示委派：将对象作为参数传入隐式委派：放入实现类的内部client calls >Receiver delegatesto >delegate问题：如果子类中只需要复用父类中的一小部分代码，那么就不需要继承，继承是没有意义的，而是需要动态请求一个对象，通过委派来实现代码的复用，避免大量无用的复用Compositeoverinheritanceprinciple（CRP）：组合比继承更好，has_a、use_a比is_a更好。代理的类型：use：临时性的delegation，通过参数传入，方法运行完，两者就彻底脱离关系了association：永久性的delegation，在rep中定义一个属性存储要请求的对象，通过构造方法传参构造，但是传入后就不能修改了，就固定住了composition：更强的association，直接在写ADT的时候就将类型固定好了，不能通过传参设定，难以变化，可以理解为is_part_ofAggregation：更弱的association：不仅可以通过构造方法传参构造，还可以在后续的客户端代码处，通过特殊的设定方法，随时改变属性。 
