Software Construction
1 Views and Quality Objectives of
Software Construction
软件构造的多维度视图和质量目标
Wang Zhongjie
rainy@hit.edu.cn
April 28, 2021
1 Views and Quality Objectives of Software Construction
Objective of this lecture
 To understand the constituents of a software system in three 
orthogonal dimensions 
从三个维度看软件系统的构成
 To know what models are used to describe the morphology and 
states of a software system 
用什么样的模型/视图描述软件系统
 To treat software construction as the transformations between 
different views 
将“软件构造”看作“不同视图之间的转换”
先要搞清楚：软件构造的对象是什么、如何刻画
然后再关注：如何构造
1 Views and Quality Objectives of Software Construction
Objective of this lecture
 To know quality factors to be cared in software construction 
软件构造过程中应考虑的重要质量指标
 To understand the consequences if quality objectives cannot be 
achieved 
如果达不到期望的质量目标，会有什么后果
 To know what construction techniques are to be studied for each 
quality factor in this course 
有哪些面向质量指标的软件构造技术
除了要搞清楚“要构造的结果是什么”
还要理解清楚“构造的结果如何才算好”
1 Views and Quality Objectives of Software Construction
Outline
 Multi-dimensional software views – By phases: build- and run-time views 按阶段划分：构造时/运行时视图 – By dynamics: moment and period views 按动态性划分：时刻/阶段视图 – By levels: code and component views 
按构造对象的层次划分：代码/构件视图 – Elements, relations, and models of each view
 Software construction: transformation between views –   Code – Code  Component – Build-time  Run-time – Moment  Period
1 Views and Quality Objectives of Software Construction
Outline
 Quality properties of software systems – External vs. internal quality factors – Important external quality factors – Tradeoff between quality factors
 Five key quality objectives of software construction
– Easy to understand: elegant and beautiful code / understandability
– Ready for change: maintainability and adaptability
– Cheap for develop: design for/with reuse: reusability
– Safe from bugs: robustness – Efficient to run: performance
 Summary
1 Views and Quality Objectives of Software Construction
Reading
 MIT 6.031：Getting started, readings 02
 CMU 17-214：Aug 29
 代码大全：第1-4章  Object-Oriented Software Construction：第1章  代码大全：第20章  软件工程--实践者的研究方法：第14章
Software Construction
1 Multi-dimensional software views
1 Views and Quality Objectives of Software Construction
What is a Software?
 The term “software” was firstly proposed by Alan Turing. – System software vs. Application software – Desktop/web/mobile/embedded software – Business/personal-oriented software – Open source vs. proprietary software
Alan Turing (1912-1954)
1 Views and Quality Objectives of Software Construction
Constituents of a software system
 Software = Program (codes)?
 Software = Algorithms + Data Structure?
 Software = Program + Data + Documents
 Software = Modules (Components) + Data/Control Flows
Donald E. Knuth (1938- )
Turing Award 1974
Edager Dijkstra (1930-2002)
Turing Award 1972
Niklaus Wirth (1934-)
Turing Award 1984
1 Views and Quality Objectives of Software Construction
Constituents of a software system: one more step
Software Users
Social Environment
Technological
Environment
Hardware
Network
Program
Data
Documents
Business Objectives
1 Views and Quality Objectives of Software Construction
Constituents of a software system: two more steps
1 Views and Quality Objectives of Software Construction
Multi-dimensional software views
Moment Period
Code-level Component-level Code-level Component-level
Build￾time
Source code,
AST,
Interface-Class￾Attribute￾Method
(Class Diagram)
Package, File, Static
Linking, Library, 
Test Case,
Build Script
(Component 
Diagram)
Code Churn Configuration 
Item, Version
Run￾time
Code Snapshot, 
Memory dump
Package, Library, 
Dynamic linking, 
Configuration, 
Database, 
Middleware, 
Network, 
Hardware 
(Deployment 
Diagram)
Execution 
stack trace,
Concurrent
multi-threads
Event log,
Multi-processes,
Distributed 
processes
Procedure Call Graph, Message 
Graph (Sequence Diagram)
Software Construction
(1) Build-time Views
1 Views and Quality Objectives of Software Construction
Build-time views of a software system
 Build-time (构造阶段): idea  requirement  design  code 
installable / executable package – Code-level view: source code ---- how source code are logically organized 
by basic program blocks such as functions, classes, methods, interfaces, 
etc, and the dependencies among them 代码的逻辑组织 – Component-level view: architecture ---- how source code are physically
organized by files, directories, packages, libraries, and the dependencies 
among them 代码的物理组织 ---------------------------------------------------------------- – Moment view: what do source code and component look like in a specific 
time 特定时刻的软件形态 – Period view: how do they evolve/change along with time 软件形态随时间
的变化
1 Views and Quality Objectives of Software Construction
(1) Build-time, moment, and code-level view
 How source code are logically organized by basic program blocks 
such as functions, classes, methods, interfaces, etc, and the 
dependencies among them.
 Three inter-related forms: – 词汇层面：Lexical-oriented source code – 语法层面：Syntax-oriented program structure: e.g., Abstract Syntax Tree 
(AST) – 语义层面：Semantics-oriented program structure: e.g., Class Diagram 
1 Views and Quality Objectives of Software Construction
Lexical-based semi-structured source code
 Source code: the most important assets in software development
半结构化：近乎自然语言的
风格+遵循特定的编程语法
前者：方便程序员
后者：方便编译器
1 Views and Quality Objectives of Software Construction
Syntax-oriented program structure
 Abstract Syntax Tree (AST)
 To represent semi-structured 
source code as a structured 
tree.
while (a  b) {
if (a > b) 
a = a – b;
else
b = b – a;
}
return a;
https://en.wikipedia.org/wiki/Abstract_syntax_tree
http://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/index.html
1 Views and Quality Objectives of Software Construction
Processing Java Source Files by AST
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jface.text.Document;
import org.eclipse.text.edits.TextEdit;
public class AST {
void processJavaFileByAST(){
Document doc = new Document(javaFilePath);
ASTParser parser = ASTParser.newParser(AST.JLS3);
parser.setResolveBindings(true);
parser.setSource(doc.get().toCharArray());
CompilationUnit cu = (CompilationUnit) parser.createAST(null);
cu.recordModifications();
AST ast = cu.getAST();
ImportDeclaration id = ast.newImportDeclaration();
id.setName(ast.newName(new String[] {"java", "util", "Set"}));
cu.imports().add(id); // add import declaration at end
TextEdit edits = cu.rewrite(doc, null);
}}
AST：彻底结构化，将
源代码变为一棵树，
对树做各种操作==对
源代码的修改
http://www.vogella.com/tutorials/EclipseJDT/article.html
1 Views and Quality Objectives of Software Construction
Semantics-oriented program structure
 E.g., using Class Diagram (UML) to 
describe interfaces, classes, attributes,
methods, and relationships among them.
 Graphics-based or formally defined. 通常是图形化或形式化的
 Modeled in design phase, and transformed into source code. 
 It is the result of Object-Oriented Analysis and Design in terms of 
user requirements.
用于表达“需求”
和“设计”思想，
再转化成code
语义：源代码具体
想实现什么目标？
源代码---现实世界
1 Views and Quality Objectives of Software Construction
Semantics-oriented program structure
1 Views and Quality Objectives of Software Construction
(2) Build-time, period, and code-level view
 Views describing “changes” along with time.
 Code churn 代码变化: Lines added, modified or deleted to a file 
from one version to another.
1 Views and Quality Objectives of Software Construction
Code churn Code churn is defined as lines added, modified or
deleted to a file from one version to another.
1 Views and Quality Objectives of Software Construction
(3) Build-time, moment, and component-level view
 Source code are physically organized into files which further are 
organized by directories;  Files are encapsulated into packages and, logically, components 
and sub-systems.
 Reusable modules are in the form of libraries.
1 Views and Quality Objectives of Software Construction
Library
 Libraries are stored in disk files of their own, collect a set of code 
functions that can be reused across a variety of programs. – Developers aren’t always building a single executable program file, but join 
custom-developed software and prebuilt libraries into a single program.
 In build-time, a library function can be viewed as an extension to the 
standard language and is used in the same way as functions written 
by the developers. 开发者像使用编程语言指令一样使用库中的功能
System.out.println("Hello World");
 Sources of libraries: – From OS pre-installed set of libraries for operations such as file and 
network I/O, GUI, mathematics, database assess; 操作系统提供的库 – From language SDK; 编程语言提供的库 – From third-party sources; 第三方公司提供的库 – Developers can also publish their own libraries. 你自己积累的库
1 Views and Quality Objectives of Software Construction
Maven Repository
<dependency>
<groupId>junit</groupId>
<artifactId>junit</artifactId>
<version>4.12</version>
<scope>test</scope>
</dependency>
1 Views and Quality Objectives of Software Construction
Linking with a library
 When a program is edited, built and installed, a list of libraries to 
search must be provided. 编程时和build时，需告诉IDE和JVM在哪
里寻找某些库
 If a function is referenced in the source code but the developer 
didn’t explicitly write it, the list of libraries is searched to locate 
the required function. 
javac -classpath ./lib/*.jar
 When the function is found, the appropriate object file is copied 
into the executable program.  Two different approaches of integrating a library into an 
executable program: – Static linking (静态链接) – Dynamic linking (动态链接)
1 Views and Quality Objectives of Software Construction
Static linking
 In static linking, a library is a collection of individual object files.
 During the build process, when the linker tool determines that a 
function is required, it extracts the appropriate object file from the 
library and copies it into the executable program
– 库被拷贝进入代码形成整体，执行的时候无需提供库文件 – The library’s object file appears identical to any of the object files the 
developer created on his or her own.
 Static linking happens in build time – End up with a single executable program 
to be loaded onto the target machine. – After the final executable program has 
been created, it’s impossible to separate 
the program from its libraries.
静态链接发生在构造阶段
1 Views and Quality Objectives of Software Construction
Component diagram in UML
1 Views and Quality Objectives of Software Construction
(4) Build-time, period, and component-level view
 How do all files/packages/components/libraries change in a 
software system along with time? 各项软件实体随时间如何变化？
 Software Configuration Item (SCI，配置项)  Version (版本)
1.0
1.1
1.2
1.3
File 1 File 2 File 3 Version 
Labels
Final
Version
Beta 1
1.0
1.1
1.2
1.3
1.0
1.1
1.2
1.0
1.1
1.2
1.3
1.4
1 Views and Quality Objectives of Software Construction
Version Control System (VCS)
1 Views and Quality Objectives of Software Construction
Evolution Graph (of a SCI or a Software)
Evaluation graph describes the 
development process and phases of 
a software.
1 Views and Quality Objectives of Software Construction
Versioning
 Software versioning is the process of assigning either unique 
version names or unique version numbers to unique states of 
computer software. – Within a given version number category (major, minor), these 
numbers are generally assigned in increasing order and correspond 
to new developments in the software. – At a fine-grained level, revision control is often used for keeping 
track of incrementally different versions of electronic information, 
whether or not this information is computer software.
Software Construction
(2) Runtime Views
1 Views and Quality Objectives of Software Construction
Runtime views of a software system
 Runtime: what does a program look like when it runs inside the 
target machine, and what are all the disk files that the target machine 
needs to load into memory? 运行时：程序被载入目标机器，开始执行 – Code-level view: source code ---- what do the in-memory states of an 
executable program look like and how do program units (objects, 
functions, etc) interact with each other? 代码层面：逻辑实体在内存中如何
呈现？ – Component-level view: architecture ---- how are software packages 
deployed into physical environment (OS, network, hardware, etc) and 
how do they interact? 构件层面：物理实体在物理硬件环境中如何呈现？ ---------------------------------------------------------------- – Moment view: how do programs behave in a specific time 逻辑/物理实体
在内存/硬件环境中特定时刻的形态如何？ – Period view: how do they behave along with time 逻辑/物理实体在内存/
硬件环境中的形态随时间如何变化？
1 Views and Quality Objectives of Software Construction
High-level concepts of run-time software
 Executable programs: The sequence of machine-readable 
instructions that the CPU executes, along with associated data 
values. – This is the fully compiled program that’s ready to be loaded into the 
computer’s memory and executed.
 Libraries: Collections of commonly used object code that can be 
reused by different programs. – Most operating systems include a standard set of libraries that developers 
can reuse, instead of requiring each program to provide their own. – A library can’t be directly loaded and executed on the target machine; it 
must first be linked with an executable program.
1 Views and Quality Objectives of Software Construction
High-level concepts of run-time software
 Configuration and data files: These are not executable files; they 
provide useful data and configuration information that the program 
can load from disk.
 Distributed programs: This type of software consists of multiple 
executable programs that communicate with each other across a 
network or simply as multiple processes running on the same 
machine. – This contrasts with more traditional software that has a single monolithic 
program image.
1 Views and Quality Objectives of Software Construction
Executable Programs: Native Machine Code
 A program is loaded into memory first, and several mechanisms 
exist for executing the software, depending on how much 
compilation took place before the program was loaded and how 
much OS supports the program requires.
 Native Machine Code (原生机器码): – Fully converted executable program into the CPU’s native machine code. – The CPU simply “jumps” to the program’s starting location, and all the 
execution is performed purely using the 
CPU’s hardware. – While it’s executing, the program optionally 
makes calls into the operating system to 
access files and other system resources. – This is the fastest way to execute code, 
because the program full accesses to the 
CPU’s features.
1 Views and Quality Objectives of Software Construction
Executable Programs: Full Interpretation
 Full Program Interpretation (程序完全解释执行): – The runtime system loads the entire source code into memory and 
interprets it (such as BASIC, UNIX shell, etc)
1 Views and Quality Objectives of Software Construction
Executable Programs: Interpreted Byte Codes
 Interpreted Byte Codes (解释型字节码): – Byte codes are similar to native machine code, except that the CPU doesn’t 
directly understand them. – It first translates them into native machine code or interprets them as the 
program executes. – A byte code environment therefore 
requires that an additional interpreter
or compiler be loaded alongside the 
program.
 Java Virtual Machine (JVM)
1 Views and Quality Objectives of Software Construction
Executable Programs: Interpreted Byte Codes
 Perl or Python: they are interpreted rather than compiled, but use 
byte codes at runtime.
 The simple act of executing the Perl or Python script automatically 
triggers the generation of byte codes.
1 Views and Quality Objectives of Software Construction
Dynamic linking
 Dynamic linking method doesn’t copy the object file into the 
executable image; instead, it notes which libraries are required to 
successfully execute the program. 库文件不会在build阶段被加入可
执行软件，仅仅做出标记
 When the program starts running, the libraries are loaded into 
memory as separate entities and then are connected with the main 
program. 程序运行时，根据标记装载库至内存
 A dynamic library is a disk file that is constructed by joining object 
files. The library is then collected into the release package and 
installed on the target machine. Only then can it be loaded into the 
machine’s memory. 发布软件时，记得将程序所依赖的所有动态库都
复制给用户
你的实验，提交到GitHub的时候，切记把各种lib都一并提交上来
1 Views and Quality Objectives of Software Construction
Dynamic linking
 Advantages: – It’s possible to upgrade to a newer version of a library (adding features or 
fixing bugs), without needing to re-create the executable program. – Many operating systems can optimize their memory usage by loading 
only a single copy of the library into memory, yet sharing it with other 
programs that require that same library.
1 Views and Quality Objectives of Software Construction
Configuration and Data Files
 Any program of significant size uses external data sources, such as 
a file on a disk.
 Your program makes calls into the operating system to request that 
data be read into memory. – A bitmap graphic image displayed onscreen
– A sound stored as a digitized wave form
– A configuration file that customizes 
the behavior of a program
– A set of documents 
containing online help
text – A database containing 
names and addresses
1 Views and Quality Objectives of Software Construction
Distributed Programs
 For example, a software system might use the client/server model, 
with a single server program running on one computer and a large 
number of client programs running on many other computers. 
 In this scenario, the build system could create two release packages, 
given that different people will be installing the server program 
versus the client program. 
 Alternatively, the same release package could be used to install the 
two separate programs.
 分布式程序的运行态：需要多个运行程序，分别部署于多个计算机物
理环境。
1 Views and Quality Objectives of Software Construction
(5) Run-time, moment, and code-level view
 Snapshot diagram: focusing on 
variable-level execution states in 
the memory of a target computer.
 Fine-grained states of a program. 
 代码快照图：描述程序运行时内存
里变量层面的状态
1 Views and Quality Objectives of Software Construction
Memory dump (内存信息转储)  Memory dump: a file on hard disk containing a copy of the contents 
of a process's memory, produced when a process is aborted by certain 
kinds of internal error or signal. – Debuggers can load the dump file and
display the information it contains 
about the state of the running program. – Information includes the contents of 
registers, the call stack and all other 
program data (counters, variables, 
switches, flags, etc). – It is taken in order to analyze the status
of the program, and the programmer 
looks into the memory buffers to see 
which data items were being worked
on at the time of failure.
1 Views and Quality Objectives of Software Construction
Memory dump
1 Views and Quality Objectives of Software Construction
(6) Run-time, period and code-level view
 Sequence diagram in UML: interactions among program units 
(objects)
1 Views and Quality Objectives of Software Construction
Execution tracing 执行跟踪
 Tracing involves a specialized use of logging to record information 
about a program‘s execution. 用日志方式记录程序执行的调用次序
 This is typically used by programmers for debugging purposes, and 
depending on the type and detail of information contained in a trace log, 
by experienced administrators or technical-support personnel and by 
software monitoring tools to diagnose common problems with software.
1 Views and Quality Objectives of Software Construction
(7) Run-time, moment, and component-level view
 Deployment diagram in UML
1 Views and Quality Objectives of Software Construction
(8) Run-time, period, and component-level view
 Event logging provides system administrators with information 
useful for diagnostics and auditing. 事件日志：系统层面 – The different classes of events that will be logged, as well as what details 
will appear in the event messages, are considered in development cycle. 
 Each class of event to be assigned a unique “code” to format and 
output a human-readable message. – This facilitates localization and allows system administrators to more 
easily obtain information on problems that occur.
1 Views and Quality Objectives of Software Construction
Execution tracing and event logging
Event logging (构件/系统层面) Execution tracing (代码层面)
Consumed primarily by system 
administrators Consumed primarily by developers
Logs "high level" information (e.g. failed 
installation of a program)
Logs "low level" information (e.g. a 
thrown exception)
Must not be too "noisy" (contain many 
duplicate events or information not helpful 
to its intended audience)
Can be noisy
A standards-based output format is often 
desirable, sometimes even required Few limitations on output format
Event log messages are often localized Localization is rarely a concern
Addition of new types of events, as well as 
new event messages, need not be agile
Addition of new tracing messages must be 
agile
1 Views and Quality Objectives of Software Construction
What we are focused on in this semester
Moment Period
Code-level Component-level Code-level Component-level
Build￾time
Source code,
AST,
Interface-Class￾Attribute￾Method
(Class Diagram)
Package, File, Static 
Linking, Library, 
Test Case,
Build Script
(Component 
Diagram)
Code Churn Configuration 
Item, Version
Run￾time
Code Snapshot, 
Memory dump
Package, Library, 
Dynamic linking, 
Configuration, 
Database, 
Middleware, 
Network, 
Hardware 
(Deployment 
Diagram)
Execution 
stack trace,
Concurrent 
multi-threads
Event log,
Multi-processes,
Distributed 
processes
Procedure Call Graph, Message 
Graph (Sequence Diagram)
Software Construction
2 Software construction: 
Transformation between views
1 Views and Quality Objectives of Software Construction
Software construction: transformation btw views
Build-time
Run-time
Moment Period
Moment
Period
Code
Component
Code
Churn
CI and 
Version
Code 
Snapshot
Physical 
Architecture
Call 
Graph
Thread and 
Process
design
programming
design build 
build
install
deploy
refactoring
Version Control
evolution
deploy
review, static analysis
debug
testing
profiling, tracing
logging
execute
dumping
1 Views and Quality Objectives of Software Construction
Types of Transformations in Software Construction
   Code – Programming / Coding (ADT/OOP) – Review, static analysis/checking
 Code  Component – Design (ADT/OOP; Reusability; Maintainability) – Build: compile, static link, package, install, etc 
 Build-time  Run-time – Install / deploy
– Debug, unit/integration testing (Robustness and Correctness)
 Moment  Period
– Version control – Loading, dynamic linking, execution (dumping, profiling, logging) – Concurrent threads
Software Construction
3 Quality properties of software 
systems
1 Views and Quality Objectives of Software Construction
External and internal quality factors
 External quality factors: qualities such as speed or ease of use, 
whose presence or absence in a software product may be detected 
by its users.
 Other qualities applicable to a software product, such as being 
modular, or readable, are internal factors, perceptible only to 
developers who have access to the actual software text.
 In the end, only external factors matter.
 But the key to achieving these external factors is in the internal 
ones: for the users to enjoy the visible qualities, the designers and 
implementers must have applied internal techniques that will ensure 
the hidden qualities.
External quality factors affect users
外部质量因素 影响 用户
Internal quality factors affect the software itself and its developers
内部质量因素 影响 软件本身和它的开发者
External quality results from internal quality
外部质量取决于内部质量
Software Construction
(1) External quality factors
1 Views and Quality Objectives of Software Construction
External 1: Correctness
 Correctness is the ability of software products to perform their exact 
tasks, as defined by their specification. 按照预先定义的“规约”执行
 Correctness is the prime quality 正确性：最重要的质量指标
Assume a software system is developed in layers.
Each layer guarantees its correctness under the 
assumption that its lower layer is also correct.
每一层保证自己的正确性，同时假设其下层是正确的
1 Views and Quality Objectives of Software Construction
External 1: Correctness
 Approaches of ensuring correctness: Testing and debugging
测试和调试：发现不正确、消除不正确 Robustness (Chapter 6)
 Defensive programming such as typing and assertions 
防御式编程：在写程序的时候就确保正确性 meant to help build 
software that is correct from the start — rather than debugging it into 
correctness. Robustness (Chapter 6)
 Formal approach: “check”, “guarantee” and “ensure” 
形式化方法：通过形式化验证发现问题 – Mathematical techniques for formal program specification and verification
 Formal Language, Graduate courses
1 Views and Quality Objectives of Software Construction
External 2: Robustness
 Robustness is the ability of software systems to react appropriately 
to abnormal conditions 健壮性：针对异常情况的处理 – Robustness complements correctness. 健壮性是对正确性的补充 – Correctness addresses the behavior of a system in cases covered by its 
specification; 正确性：软件的行为要严格的符合规约中定义的行为 – Robustness characterizes what happens outside of that specification. 健壮
性：出现规约定义之外的情形的时候，软件要做出恰当的反应
 Robustness is to make sure that if such cases do arise, the system 
does not cause catastrophic events; it should produce appropriate 
error messages, terminate its execution cleanly, or enter a so-called 
“graceful degradation” mode.
 健壮性：出现异常时不要“崩溃”
1 Views and Quality Objectives of Software Construction
External 2: Robustness
 Robustness is concerned with “abnormal case”, which implies that 
the notions of normal and abnormal case are always relative to a 
certain specification “normal”和“abnormal”是主观而非客观 – An abnormal case is simply a case that is not covered by the specification 
未被specification覆盖的情况即为“异常情况” – If you widen the specification, cases that used to be abnormal become 
normal — even if they correspond to events such as erroneous user input 
that you would prefer not to happen 所谓的“异常”，取决于spec的范畴
• “Normal” in this sense does not mean “desirable”, but simply “planned for in the 
design of the software”. 
• Although it may seem paradoxical at first that erroneous input should be called a 
normal case, any other approach would have to rely on subjective criteria, and so 
would be useless. 
Exception handling (Chapter 6)
1 Views and Quality Objectives of Software Construction
External 3: Extendibility
 Extendibility (可扩展性) is the ease of adapting software products to 
changes of specification. 对软件的规约进行修改，是否足够容易？
 The problem of extendibility is one of scale 规模越大，扩展起来越
不容易 – For small programs change is usually not a difficult issue; but as software 
grows bigger, it becomes harder and harder to adapt. – A large software system often looks to its maintainers as a giant house of 
cards in which pulling out any one element might cause the whole edifice 
to collapse.
 We need extendibility because at the basis of all software lies some 
human phenomenon and hence fickleness 为什么要扩展：应对变化 – Traditional approaches did not take enough account of change, relying 
instead on an ideal view of the software lifecycle where an initial analysis 
stage freezes the requirements, the rest of the process being devoted to 
designing and building a solution.
1 Views and Quality Objectives of Software Construction
External 3: Extendibility
 Two principles are essential for 
improving extendibility: – Design simplicity: a simple architecture will 
always be easier to adapt to changes than a 
complex one. 简约主义设计 – Decentralization: the more autonomous the 
modules, the higher the likelihood that a 
simple change will affect just one module, 
or a small number of modules, rather than 
triggering off a chain reaction of changes 
over the whole system. 分离主义设计
 Chapter 3 (ADT and OOP)
 Chapter 4/5 (Modularity and adaptability)
1 Views and Quality Objectives of Software Construction
External 4: Reusability
 Reusability (可复用性) is the ability of 
software elements to serve for the construction 
of many different applications. 一次开发，多
次使用
 The need for reusability comes from the 
observation that software systems often follow 
similar patterns; it should be possible to 
exploit this commonality and avoid 
reinventing solutions to problems that have 
been encountered before. 发现共性 – A reusable software element will be applicable to
many different developments. – Don’t Repeat Yourself (DRY) – Don’t Re-invent the Wheel
 Chapter 4 (Design for/with reuse)
1 Views and Quality Objectives of Software Construction
External 5: Compatibility
 Compatibility (兼容性) is the ease of combining software elements 
with others. 不同的软件系统之间相互可容易的集成
 Compatibility is important because we do not develop software 
elements in a vacuum (真空): they need to interact with each other.
 But they too often have trouble interacting because they make 
conflicting assumptions about the rest of the world. – An example is the wide variety of incompatible file formats supported by 
many operating systems. A program can directly use another’s result as 
input only if the file formats are compatible. (文件格式的兼容性)
1 Views and Quality Objectives of Software Construction
External 5: Compatibility
 The key to compatibility lies in homogeneity of 
design (保持设计的同构性), and in agreeing on 
standardized conventions for inter-program communication. 
The key to compatibility is standardization, 
especially standard protocols. 标准化
 Approaches include: – Standardized file formats, as in the Unix system, where every text file is 
simply a sequence of characters. – Standardized data structures, as in Lisp systems, where all data, and 
programs as well, are represented by binary trees (called lists in Lisp). – Standardized user interfaces, as on various versions of Windows, OS/2 
and MacOS, where all tools rely on a single paradigm for communication 
with the user, based on standard components such as windows, icons, etc.
 More general solutions are obtained by defining standardized access 
protocols to all important entities manipulated by the software.
1 Views and Quality Objectives of Software Construction
External 6: Efficiency
 Efficiency is the ability of a software system to place as few demands 
as possible on hardware resources, such as processor time, space 
occupied in internal and external memories, bandwidth used in 
communication devices.
 Efficiency does not matter much if the software is not correct (“do 
not worry how fast it is unless it is also right ”). 性能毫无意义，除非有
足够的正确性 – The concern for efficiency must be balanced with other goals such as 
extendibility and reusability; 对性能的关注 要与 其他质量属性进行折中 – Extreme optimizations make the software so specialized as to be unfit for 
change and reuse. 过度的优化导致软件不再适应变化和复用
 Algorithms, I/O, memory management, etc.
Abstract concepts for correctness of 
computation vs. Concrete implementation 
for performance through optimization
1 Views and Quality Objectives of Software Construction
External 6: Efficiency 过早优化是万恶之源
1 Views and Quality Objectives of Software Construction
External 7: Portability (可移植性)  Portability is the ease of transferring software products to various 
hardware and software environments. 软件可方便的在不同的技术环
境之间移植
 Portability addresses variations not just of the physical hardware but 
more generally of the hardware-software machine, the one that we 
really program, which includes the operating system, the window 
system if applicable, and other fundamental tools. 硬件、操作系统
1 Views and Quality Objectives of Software Construction
External 8: Ease of use
 Ease of use (易用性) is the ease with which people of various 
backgrounds and qualifications can learn to use software products 
and apply them to solve problems. (容易学、安装、操作、监控) – It also covers the ease of installation, operation and monitoring.
 How to provide detailed guidance and explanations to novice users, 
without bothering expert users who just want to get right down to 
business. (给用户提供详细的指南)  Structural simplicity
– A well-designed system, built according to a clear, well thought-out 
structure, will tend to be easier to learn and use than a messy one.
 Know the user – The argument is that a good designer must make an effort to understand 
the system’s intended user community.
1 Views and Quality Objectives of Software Construction
External 9: Functionality
 Functionality is the extent of possibilities provided by a system.
 Featurism (often “creeping featurism”) 程序设计中一种不适宜的趋
势，即软件开发者增加越来越多的功能，企图跟上竞争，其结果是程
序极为复杂、不灵活、占用过多的磁盘空间 – The easier problem is the loss of consistency that may result from the 
addition of new features, affecting its ease of use. Users are indeed known 
to complain that all the “bells and whistles” of a product’s new version 
make it horrendously complex. – The more difficult problem is to avoid being so focused on features as to 
forget the other qualities (Ignorance of overall quality).
Osmond’s curves
1 Views and Quality Objectives of Software Construction
External 9: Functionality
 What Osmond suggests (the color curve) is, aided by the quality￾enhancing techniques of OO development, to maintain the quality 
level constant throughout the project for all aspects but functionality. 
 You just do not compromise on reliability, extendibility and the like: 
you refuse to proceed with new features until you are happy with 
the features you have.
 Chapter 2 (Agile, SCM)
Start with a small set of key features 
with all quality factors considered.
Add more features gradually during 
development process and guarantee the 
same quality as key features.
每增加一小点功能，都确保其他质量属性
不受到损失
1 Views and Quality Objectives of Software Construction
External 10: Timeliness
 Timeliness (及时性) is the ability of a software system to be released 
when or before its users want it.
 A great software product that appears too late might miss its target 
altogether.
1 Views and Quality Objectives of Software Construction
External 10++: Other qualities
 Verifiability (可验证性) is the ease of 
preparing acceptance procedures, 
especially test data, and procedures 
for detecting failures and tracing 
them to errors during the validation 
and operation phases.
 Integrity (完整性) is the ability of software systems to protect their 
various components (programs, data) against unauthorized access 
and modification.
 Repairability (可修复性) is the ability to facilitate the repair of 
defects.
 Economy (经济性), the companion of timeliness, is the ability of a 
system to be completed on or below its assigned budget.
Software Construction
(2) Internal quality factors
1 Views and Quality Objectives of Software Construction
Internal quality factors
 Source code related factors such as Lines of 
Code (LOC), Cyclomatic Complexity, etc 
 Architecture-related factors such as 
coupling, cohesion, etc
 Readability
 Understandability
 Clearness
 Size
Complexity is the enemy of almost 
any external quality factors!
Internal quality factors are usually used as 
partial measurement of external quality factors.
Software Construction
(3) Tradeoff between quality 
properties
1 Views and Quality Objectives of Software Construction
Tradeoff between quality properties 折中
 How can one get integrity without introducing protections of various 
kinds, which will inevitably hamper ease of use? 
 Economy often seems to fight with functionality.  Optimal efficiency would require perfect 
adaptation to a particular hardware and 
software environment, which is the opposite 
of portability, and perfect adaptation to a 
specification, where reusability pushes 
towards solving problems more general 
than the one initially given. 
 Timeliness pressures might tempt us to use “Rapid Application 
Development” techniques whose results may not enjoy much 
extendibility.
Integrity vs. ease of use
Economy vs. functionality
Efficiency vs. portability
Efficiency vs. reusability
Economy vs. reusability
Timeliness vs. extendibility
1 Views and Quality Objectives of Software Construction
Tradeoff between quality properties
 Developers need to make tradeoffs. – Too often, developers make these tradeoffs implicitly, without taking the 
time to examine the issues involved and the various choices available; 
efficiency tends to be the dominating factor in such silent decisions. – A true software engineering approach implies an effort to state the criteria 
clearly and make the choices consciously. – 正确的软件开发过程中，开发者应该将不同质量因素之间如何做出折中的设
计决策和标准明确的写下来
 Necessary as tradeoffs between quality factors may be, one factor 
stands out from the rest: correctness. – There is never any justification for compromising correctness for the sake 
of other concerns such as efficiency. – If the software does not perform its function, the rest is useless. – 虽然需要折中，但“正确性”绝不能与其他质量因素折中。
1 Views and Quality Objectives of Software Construction
Key concerns of software construction
 All the qualities discussed above are important. 
 最重要的几个质量因素
But in the current state of the software industry, four stand out: – Correctness and robustness: reliability
• Systematic approaches to software construction
• Formal specification
• Automatic checking during development process
• Better language mechanism
• Consistency checking tools – Extendibility and reusability: modularity
1 Views and Quality Objectives of Software Construction
How OOP improves quality
 Correctness: encapsulation, decentralization
 Robustness: encapsulation, error handling
 Extendibility: encapsulation, information hiding
 Reusability: modularity, component, models, patterns
 Compatibility: standardized module and interface
 Portability: information hiding, abstraction
 Ease of use: GUI components, framework
 Efficiency: reusable components
 Timeliness: modeling, reuse
 Economy: reuse
 Functionality: extendibility
Software Construction
4 Five key quality objectives of 
software construction
1 Views and Quality Objectives of Software Construction
Quality considerations of this course
 Elegant and beautiful code  easy 
to understand, understandability 
 Design for/with reuse  cheap 
for develop
 Low complexity  ready for 
changes, easy to extend 
 Robustness and correctness 
safe from bug, not error-prone
 Performance and efficiency 
efficient to run
Reusability
Maintainability
Robustness/Correctness
Chapter 2 ADT and OOP
1 Views and Quality Objectives of Software Construction
Understandability
Moment Period
Code-level Component-level Code-level Component-level
Build￾time
代码的可理解性
（变量/子程序/
语句的命名与构
造标准、代码布
局与风格、注释、
复杂度）
Code Review;
Walkthrough;
Static Code 
Analysis;
ADT/函数规约
构件/项目的可理解
性（包的组织、文
件的组织、命名空
间）
Refactoring Version control
Run￾time
Log
Trace
1 Views and Quality Objectives of Software Construction
Reusability
Moment Period
Code-level Component-level Code-level Component-level
Build￾time
ADT/OOP;
接口与实现分离;
继承/重载/重写;
组合/代理;
多态;
子类型与泛型;
OO设计模式
API design;
Library;
Framework
(for/with reuse);
Static linking
Run￾time Dynamic linking
1 Views and Quality Objectives of Software Construction
Maintainability and Adaptability
Moment Period
Code-level Component-level Code-level Component-level
Build￾time
模块化设计;
聚合度/耦合度;
SOLID;
OO设计模式;
State-based 
programming;
Grammar-based 
programming
SOLID;
GRASP
SCM
Version Control
Run￾time
1 Views and Quality Objectives of Software Construction
Robustness
Moment Period
Code-level Component-level Code-level Component-level
Build￾time
Error handling;
Exception 
handling;
Assertion;
Defensive 
programming;
Test-first
programming
Continuous Integration; 
Regression Testing
Run￾time
Unit/Integration Testing;
Debug;
Memory Dumping
Logging
Tracing
1 Views and Quality Objectives of Software Construction
Performance
Moment Period
Code-level Component-level Code-level Component-level
Build￾time
代码调优;
Design pattern
Run￾time
空间复杂性（内
存管理性能）;
时间复杂性（I/O
性能）;
Memory dump;
Garbage
Collection (GC)
分布式系统
Performance 
profiling, 
analysis and 
tuning
并行/多线程
Software Construction
Summary
1 Views and Quality Objectives of Software Construction
Summary of this lecture
 Three dimensions of describing a software system: – By phases: build- and run-time views – By dynamics: moment and period views – By levels: code and component views
 Elements, relations, and models of each view
 Software construction: transformation between views –   Code – Code  Component – Build-time  Run-time – Moment  Period
1 Views and Quality Objectives of Software Construction
Summary
 Quality properties of software systems – External vs. internal quality factors – Important external quality factors – Tradeoff between quality factors
 Five key quality objectives of software construction
– Easy to understand: elegant and beautiful code / understandability
– Ready for change: maintainability and adaptability
– Cheap for develop: design for/with reuse: reusability
– Safe from bugs: robustness – Efficient to run: performance
 Construction techniques to be studied in this course (classified by 
the orientation of five key quality objectives)
Software Construction
The end
April 28, 2021
Software Construction
2 Testing and Test-First Programming
软件测试与测试优先的编程
Wang Zhongjie
rainy@hit.edu.cn
May 10, 2021
2 Testing and Test-First Programming
Objective of this lecture
 Understand the value of testing, and know the process of test-first 
programming 认可“测试”的价值，搞清楚“测试优先”的哲理
 Be able to design a test suite for a method by partitioning its input 
and output space, finding its boundaries, and choosing good test 
cases 学会用等价划分和边界值分析方法为模块设计测试用例
 Be able to judge a test suite by measuring its code coverage 可用工具
度量一组测试用例对代码的“覆盖度”
 Understand and know when to use blackbox vs. whitebox testing, 
unit tests vs. integration tests, and automated regression testing 各种
各样的测试，都有些初步了解
2 Testing and Test-First Programming
Outline
 Software Testing
 Test Case 测试用例
 Test-First Programming / Test￾Driven Development (TDD) 测试优
先的编程/测试驱动开发
 Unit Testing 单元测试
 Automated Unit Testing with JUnit 
使用JUnit进行自动化单元测试
 Black-box Testing 黑盒测试 – Choosing Test Cases by Partitioning 
等价类划分 – Include Boundaries in the Partition 
边界值分析
 White-box Testing * 白盒测试
 Coverage of Testing 覆盖度
 Integration Testing * 集成测试
 Automated Testing and 
Regression Testing * 回归测试
 Documenting Your Testing 
Strategy 在程序中文档化测试
策略
确保程序正确性/健壮性的最普
遍的手段：测试
1 设计测试用例
2 用JUnit写测试程序
3 自动化测试过程
2 Testing and Test-First Programming
Reading
 MIT 6.031：03
 CMU 17-214：Sep 05
 代码大全：第22章  软件工程--实践者的研究方法：第17-18章
Software Construction
1 Software Testing
2 Testing and Test-First Programming
What is testing?
 Software testing is an investigation conducted to provide 
stakeholders with information about the quality of the product or 
service under test. 提高软件质量的重要手段 – It is the process of executing a program or application with the intent of 
finding bugs (errors or other defects), and verifying that the software 
product is fit for use. 确认是否达到可用级别(用户需求) – It involves the execution of a software component to evaluate one or more 
properties of interest. 关注系统的某一侧面的质量特性
2 Testing and Test-First Programming
What is testing?
 Even with the best validation, it’s very hard to achieve perfect 
quality in software. 即使是最好的测试，也无法达到100%的无错误
 Some typical residual defect rates 残留缺陷率 (bugs left over after 
the software has shipped) per kloc (1000 Lines of Code): – 1-10 defects/kloc: Typical industry software. – 0.1-1 defects/kloc: High-quality validation. The Java libraries might 
achieve this level of correctness. – 0.01-0.1 defects/kloc: The very best, safety-critical validation. NASA and 
companies like Praxis can achieve this level.
 This can be discouraging for large systems. For example, if you 
have shipped a million lines of typical industry source code (1 
defect/kloc), it means you missed 1000 bugs! 触目惊心
2 Testing and Test-First Programming
Test Characteristics
 Testing’s goal runs counter to the goals of other development 
activities. The goal is to find errors. 测试跟其他活动的目标相反：破
坏、证错、“负能量”
 Testing can never completely prove the absence of errors. 再好的测
试也无法证明系统里不存在错误
 What is a good test? – A good test has a high probability of finding an error 能发现错误 – A good test is not redundant 不冗余 – A good test should be “best of breed” 最佳特性 – A good test should be neither too simple nor too complex 别太复杂也别太
简单
2 Testing and Test-First Programming
Testing levels
 Unit testing 单元测试: refers to tests that verify the 
functionality of a specific section of code, usually at 
the function level.
 Integration testing 集成测试: the combined execution of two or more 
classes, packages, components, subsystems that have been created by 
multiple programmers or programming teams. 
 System testing 系统测试: to test a completely integrated system to 
verify that the system meets its requirements, which executes the 
software in its final configuration.
Unit 
testing
Integration 
testing
System 
testing
function/class classes/packages
/components/subsystems system
Regression 
testing 回归测试
验收测试
2 Testing and Test-First Programming
Other testing types
 Installation testing
 Compatibility testing
 Smoke and sanity testing
 Regression testing
 Acceptance testing
 Alpha testing / Beta testing
 Performance/load/scalability testing
 Usability testing
 Accessibility testing
 Security testing
 and so on…
2 Testing and Test-First Programming
Static vs. Dynamic testing
 Static testing is performed without actually executing programs. – Static testing is often implicit, as proofreading, plus when programming 
tools/text editors check source code structure or compilers (pre-compilers) 
check syntax and data flow as static program analysis. – Reviews, walkthroughs, or inspections are referred to as static testing.
静态测试 vs 动态测试：靠眼睛看 vs 撸起袖子使劲干
 Dynamic testing describes the testing of the dynamic behavior of 
code, which actually executes programmed code with a given set 
of test cases. – Dynamic testing may begin before the program is 100% complete in order 
to test particular sections of code and are applied to discrete functions or 
modules. – Typical techniques for this are either using stubs/drivers or execution 
from a debugger environment.
2 Testing and Test-First Programming
Testing vs. Debugging
 Testing is a means of detecting errors. 测试：发现是否存在错误
 Debugging is a means of diagnosing and correcting the root causes 
of errors that have already been detected. 调试：识别错误根源，消
除错误
 This section deals exclusively 
with testing. 
 Debugging is discussed in 
detail in Chapter 6.4.
2 Testing and Test-First Programming
White-box vs. black-box testing
 White-box testing tests internal structures 
or workings of a program by seeing the 
source code. 白盒测试：对程序内部代码
结构的测试
 Black-box testing treats the software as a “black box”, examining 
functionality without any knowledge of internal implementation, 
without seeing the source code. 黑盒测试：对程序外部表现出来的行
为的测试
软件 Input Output
White-box testing Black-box testing 
2 Testing and Test-First Programming
Why Software Testing is Hard
 Exhaustive testing is infeasible: The space of possible test cases is 
generally too big to cover exhaustively. 穷举+暴力=不可能 – Imagine exhaustively testing a 32-bit floating-point multiply operation, 
a*b. There are 2^64 test cases!
 Haphazard testing (“just try it and see if it works”) is less likely to 
find bugs, unless the program is so buggy that an arbitrarily-chosen 
input is more likely to fail than to succeed. 靠偶然测试没意义 – It also doesn’t increase our confidence in program correctness.
 Random or statistical testing doesn’t work well for software. Other 
engineering disciplines can test small random samples (e.g. 1% of 
hard drives manufactured) and infer the defect rate for the whole 
production lot. 基于样本的统计数据对软件测试意义不大—软件与产
品的巨大差异 – This is only true for physical artifacts, but it’s not true for software.
2 Testing and Test-First Programming
Why Software Testing is Hard
 Software behavior varies discontinuously and discretely across the 
space of possible inputs. 软件行为在离散输入空间中差异巨大 – The system may seem to work fine across a broad range of inputs, and 
then abruptly fail at a single boundary point. 大多数正确，少数点出错 – The famous Pentium FDIV bug affected approximately 1 in 9 billion 
divisions, discovered in 1994. – Stack overflows, out of memory errors, and many bugs tend to happen 
abruptly, and always in the same way, not with probabilistic variation.
bug出现往往不符合特定概率分布
 That’s different from physical systems 无统计分布规律可循 – There is often visible evidence that the system is approaching a failure 
point (cracks in a bridge) or failures are distributed probabilistically near 
the failure point (so that statistical testing will observe some failures even 
before the point is reached).
Software test cases must be chosen carefully and systematically
2 Testing and Test-First Programming
Pentium FDIV bug
 https://en.wikipedia.org/wiki/Pentium_FDIV_bug
 The Pentium FDIV bug was a computer bug that 
affected the floating point unit (FPU) of the early 
Intel Pentium processors. 
 Because of the bug, the processor might return incorrect binary 
floating point results when dividing a number. – 奔腾浮点除错误是Intel旧版本Pentium浮点运算器FPU的一个错误，起源于
浮点除指令。
 In December 1994, Intel recalled the defective processors. 
 In January 1995, Intel announced "a pre-tax charge of $475 million 
against earnings, ostensibly the total cost associated with 
replacement of the flawed processors.“
 最初找出bug的原始记录：http://www.trnicely.net/#PENT
2 Testing and Test-First Programming
Ariane 5 launch vehicle
 In the 1990s, the Ariane 5 launch vehicle, designed 
and built for the European Space Agency, 
self-destructed 37 seconds after its first launch.
 The reason was a control software bug that went 
undetected. – The Ariane 5’s guidance software was reused from the 
Ariane 4, which was a slower rocket. – When the velocity calculation converted from a 64-bit floating point 
number (a double in Java terminology, though this software wasn’t 
written in Java) to a 16-bit signed integer (a short), it overflowed the small 
integer and caused an exception to be thrown. – The exception handler had been disabled for efficiency reasons, so the 
guidance software crashed. – Without guidance, the rocket crashed too. The cost of the failure was $1 
billion.
2 Testing and Test-First Programming
Putting on Your Testing Hat
 Testing requires having the right attitude. When you’re 
coding, your goal is to make the program work, but as a 
tester, you want to make it fail. 要转变心态，用“让其出
错”和“尽快出错”作为写高质量代码的日常法宝 – That’s a subtle but important difference. It is all too tempting 
to treat code you’ve just written as a precious thing, a fragile 
eggshell, and test it very lightly just to see it work.
抛弃这样的想法：我的代码是宝贝，可不能总让它出错！
 Instead, you have to be brutal. A good tester wields a 
sledgehammer and beats the program everywhere it 
might be vulnerable, so that those vulnerabilities can be 
eliminated. 学会对自己的代码更暴力些！
Not only “make it fail”, but also “fail fast”.
Software Construction
2 Test Case
2 Testing and Test-First Programming
What is test case?
 A test case, is a set of test inputs, execution conditions, and 
expected results. i.e., test case = {test inputs + execution 
conditions+ expected results} 测试用例：输入+执行条件+期望结果 – A test case is developed for a particular objective, such as to exercise a 
particular program path or to verify compliance with a specific 
requirement. – A test case could simply be a question that you ask of the program. The 
point of running the test is to gain information, for example whether the 
program will pass or fail the test. – Test case is the cornerstone of Quality Assurance whereas they are 
developed to verify quality and behavior of a product.
 E.g., test cases: {2,4}, {0,0}, {-2,4} for program y=x^2
2 Testing and Test-First Programming
Test cases are valuable assets 资产 in your project
2 Testing and Test-First Programming
Characteristics of good test case
 Most likely to catch the wrong 最可能发现错误
 Not repetitive and not redundant 不重复、不冗余
 The most effective in a group of similar test cases 最有效
 Neither too simple nor too complicated 既不简单也不复杂
 若干相关学术研究： – 根据spec和代码，自动生成测试用例 – 测试用例的最小化 – 回归测试的最小用例集
Software Construction
3 Test-First Programming
2 Testing and Test-First Programming
Test-First Programming 测试优先的编程
 Test-first programming: Write the tests before you write the code.
 Motivation
– Test early and often.  Make it fail, fail it fast! – Don’t leave testing until the end, when you have a big pile of unvalidated
code. Leaving testing until the end only makes debugging longer and 
more painful, because bugs may be anywhere in your code. – It’s far more pleasant to test your code as you develop it. “测试代码”比
写代码更有成就感！
 Process: – Write a specification for the function. 先写spec – Write tests that exercise the specification. 再写符合spec的测试用例 – Write the actual code. Once your code passes the tests you wrote, you’re 
done. 写代码、执行测试、有问题再改、再执行测试用例，直到通过它
2 Testing and Test-First Programming
Test-First Programming
 Spec describes the input and output behavior of the function. – It gives the types of the parameters and any additional constraints on 
them (e.g. sqrt()’s parameter must be nonnegative). – It also gives the type of the return value and how the return value relates 
to the inputs. – In code, the specification consists of the method signature and the 
comment above it that describes what it does. 
写测试用例，就是理解、修正、完善你的spec设计的过程
 Writing tests first is a good way to understand the specification. – The specification can be buggy, too — incorrect, incomplete, ambiguous, 
missing corner cases. – Trying to write tests can uncover these problems early, before you’ve 
wasted time writing an implementation of a buggy spec.
2 Testing and Test-First Programming
What is specification?
Specification of a function is the description of the 
function’s behavior:
• the types of parameters
• type of return value
• constraints and relationships between them.
Details of specification will be learned 
in Chapter 2
2 Testing and Test-First Programming
Test First or Test Last?
 Debugging and associated rework takes about >50 percent of the 
time spent in a typical software development cycle.
 The defect-cost increase graph suggests that writing test cases first 
will minimize the amount of time between when a defect is 
inserted into the code and when the defect is detected and 
removed. 先写测试会节省大量的调试时间
2 Testing and Test-First Programming
Test-driven development (TDD)
 Test-driven development (TDD) is a development process that 
relies on the repetition of a very short development cycle: 
requirements are turned into very specific test cases, then the 
software is improved to pass the new tests, only. 
 It is opposed to software development that allows software to be 
added that is not proven to meet requirements.
Software Construction
4 Unit Testing
2 Testing and Test-First Programming
Unit Testing 单元测试
 Unit testing focuses verification effort on the smallest unit of 
software design—the software component or module. 针对软件的
最小单元模型开展测试，隔离各个模块，容易定位错误和调试 – Testing modules in isolation leads to much easier debugging. – When a unit test for a module fails, you can be more confident that the 
bug is found in that module, rather than anywhere in the program.
2 Testing and Test-First Programming
Unit-test procedures
 Unit testing is normally considered as an adjunct to the coding step. – Test-first programming!
 A review of design information provides guidance for establishing 
test cases that are likely to uncover errors. Each test case should be 
coupled with a set of expected results.
2 Testing and Test-First Programming
Unit-test procedures
 Because a component is not a stand-alone program, driver and/or 
stub software must often be developed for each unit test. 
 Driver : A “main program” that accepts test case data, passes such 
data to the component (to be tested), and prints relevant results.
 Stubs: serve to replace modules that are subordinate (invoked by) 
the component to be tested. – A stub uses the subordinate module’s 
interface, may do minimal data manipulation, prints 
verification of entry, and returns control
to the module undergoing testing.
Software Construction
5 Automated Unit Testing with JUnit
2 Testing and Test-First Programming
A Popular unit test framework: JUnit
 JUnit is a widely-adopted unit testing framework for Java. – JUnit has been important in the development of test-driven development, 
and is one of a family of unit testing frameworks which is collectively 
known as xUnit.  JUnit is linked as a JAR at compile-time; the framework resides 
under package junit.framework for JUnit 3.8 and earlier, and 
under package org.junit for JUnit 4 and later. – A research survey performed in 2013 across 10,000 Java projects hosted on 
GitHub found that JUnit, (in a tie with slf4j-api), was the most commonly 
included external library. Each library was used by 30.7% of projects. 
http://www.junit.org
http://junit.sourceforge.net/javadoc/
2 Testing and Test-First Programming
Junit test case
 A JUnit unit test is written as a method preceded by the annotation 
@Test.  A unit test method typically contains one or more calls to the 
module being tested, and then checks the results using assertion 
methods like assertEquals, assertTrue, and assertFalse.  For example, the tests we chose for 
Math.max() might look like 
this when implemented for JUnit:
expected actual
To show that this is a test
2 Testing and Test-First Programming
JUnit
 To create a new JUnit test case or test suite in an existing project
2 Testing and Test-First Programming
JUnit
 JUnit3：  JUnit4：
setUp() or @Before： Prepare for the test, complete the initialization;
tearDown() or @After： Clean up the test environment
2 Testing and Test-First Programming
JUnit 4 example
public class Calculator {
public int evaluate(String expression) {
int sum = 0;
for (String summand: expression.split("\\+"))
sum += Integer.valueOf(summand);
return sum;
} }
------
import static org.junit.Assert.assertEquals;
import org.junit.Test;
public class CalculatorTest {
@Test
public void evaluatesExpression() {
Calculator calculator = new Calculator();
int sum = calculator.evaluate("1+2+3");
assertEquals(6, sum);
} }
2 Testing and Test-First Programming
A more complex JUnit test
@Test
public void lookupEmailAddresses() {
assertThat(new CartoonCharacterEmailLookupService().
getResults("looney"), allOf(
not(empty()),
containsInAnyOrder(
allOf(instanceOf(Map.class), hasEntry("id", "56"), 
hasEntry("email", "roadrunner@fast.org")),
allOf(instanceOf(Map.class), hasEntry("id", "76"), 
hasEntry("email", "wiley@acme.com"))
)
));
}
2 Testing and Test-First Programming
assertXXX in JUnit
assertArrayEquals("failure - byte arrays not same", expected, actual);
assertEquals("failure - strings are not equal", "text", "text");
assertFalse("failure - should be false", false);
assertNotNull("should not be null", new Object());
assertNotSame("should not be same Object", new Object(), new Object());
assertNull("should be null", null);
assertSame("should be same", aNumber, aNumber);
assertTrue("failure - should be true", true);
assertThat("albumen", both(containsString("a")).and(containsString("b")));
assertThat(Arrays.asList("one", "two", "three"), hasItems("one", "three"));
assertThat("good", allOf(equalTo("good"), startsWith("good")));
查看实际值是否满足指定的条件，条件使用Hamcrest Matchers匹配符进行匹配
Complete list can be found in
https://github.com/junit-team/junit4/wiki/Assertions
2 Testing and Test-First Programming
JUnit Test organization
 Have a test class FooTest for each public 
class Foo
 Have a source directory and a test
directory
– Store FooTest and Foo in the same package – Tests can access members with default (package) 
visibility
Software Construction
6 Black-box Testing
2 Testing and Test-First Programming
Black-box testing
 Black-box testing is a method of software testing that examines the 
functionality of an application without peering into its internal 
structures or workings. 黑盒测试：用于检查代码的功能，不关心内
部实现细节
 Black-box testing attempts to find errors in the following types: – Incorrect or missing functions – Interface errors – Errors in data structures or external database access – Behavior or performance errors – Initialization and termination errors 软件 Input Output
需求说明
(SRS)
被测程序 测试结果
产生
测试用例
输出
2 Testing and Test-First Programming
Test cases for black-box testing
 Test cases for black-box testing are built around specifications and 
requirements, i.e., what the application is supposed to do. 检查程序
是否符合规约 – Test cases are generally derived from external descriptions of the software, 
including specifications, requirements and design parameters. – Pick a set of test cases that is small enough to run quickly, yet large 
enough to validate the program. 用尽可能少的测试用例，尽快运行，并尽
可能大的发现程序的错误
Spec. Program
Test Case
Spec. Program
Test Cases
Software Construction
6.1 Choosing Test Cases by 
Partitioning
2 Testing and Test-First Programming
Equivalence Partitioning 等价类划分
 Equivalence partitioning is a testing method that divides the input 
domain of a program into classes of data from which test cases can be 
derived. 基于等价类划分的测试：将被测函数的输入域划分为等价类，
从等价类中导出测试用例。
 Test-case design for equivalence partitioning is based on an 
evaluation of equivalence classes for an input condition. 针对每个输
入数据需要满足的约束条件，划分等价类 – If a set of objects can be linked by relationships that are symmetric, 
transitive, and reflexive, an equivalence class is present. 对称、传递、自反
 An equivalence class represents a set of valid or invalid states for 
input conditions. 每个等价类代表着对输入约束加以满足/违反的有效
/无效数据的集合 – Typically, an input condition is either a specific numeric value, a range of 
values, a set of related values, or a Boolean condition. 
2 Testing and Test-First Programming
Equivalence Partitioning
 The idea behind equivalence classes is to partition the input space 
into sets of similar inputs on which the program has similar 
behavior, then use one representative of each set. 基于的假设：相似
的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为
测试用例即可 – This approach makes the best use of limited testing resources by choosing 
dissimilar test cases, and forcing the testing to explore parts of the input 
space that random testing might not reach. 从而可以降低测试用例数量
等价类 规格说明
测试用例
2 Testing and Test-First Programming
Guidelines for Equivalence Partitioning
 Equivalence classes may be defined according to the guidelines: – If an input condition specifies a range, one valid and two invalid 
equivalence classes are defined. 输入数据限定了数值范围，则… – If an input condition requires a specific value, one valid and one invalid 
equivalence classes are defined. 输入数据指明了特定的值，则… – If an input condition specifies a member of a set, one valid and one invalid 
equivalence class are defined. 输入数据确定了一组数值，则… – If an input condition is Boolean, one valid and one invalid class are 
defined. 输入数据是Y/N，则… n是正奇数：
正数：>0、<0
奇数：奇数、偶数
奇数隐含着整数：整数、非整数
输入的学号no需满足的条件：
• 长度为10位：10、>10、<10
• 以118开头：以此开头、以其他开头
• 之后两位数应为03/36/37：03、36、37、其他
2 Testing and Test-First Programming
Example: BigInteger.multiply()
 BigInteger is a class built into the Java library that can represent 
integers of any size, unlike the primitive types int and long that 
have only limited ranges. 
 BigInteger has a method multiply that multiplies two 
BigInteger values together:
/** 
* @param val another BigInteger 
* @return a BigInteger whose value is (this * val). 
*/ 
public BigInteger multiply(BigInteger val)
E.g.,
BigInteger a = ...; 
BigInteger b = ...; 
BigInteger ab = a.multiply(b);
2 Testing and Test-First Programming
Example: BigInteger.multiply()
 We should think of multiply as a function taking two inputs:
BigInteger × BigInteger → BigInteger
 So we have a two-dimensional input space 二维输入空间, 
consisting of all the pairs of integers (a,b).  We might start with these partitions 从正负的角度对二维空间进行
等价类划分 – a and b are both positive – a and b are both negative – a is positive, b is negative – a is negative, b is positive
2 Testing and Test-First Programming
Example: BigInteger.multiply()
 There are also some special cases for multiplication that we should 
check: 0, 1, and -1. 需要考虑输入数据的特殊情况 – a or b is 0, 1, or -1
 Finally, as a suspicious tester trying to find bugs, we might suspect 
that the implementor of BigInteger might try to make it faster by 
using int or long internally when possible, and only fall back to 
an expensive general representation (like a list of digits) when the 
value is too big. 考虑输入的上限：很大的数是否仍正确？
 So we should definitely also try integers that are very big, bigger 
than the biggest long. – a or b is small – the absolute value of a or b is bigger than Long.MAX_VALUE (the biggest 
possible primitive integer in Java, which is roughly 2^63)
Boundary Value Analysis (BVA) 
2 Testing and Test-First Programming
Example: BigInteger.multiply()
 Let’s bring all these observations together into a straightforward 
partition of the whole (a,b) space. 
 We’ll choose a and b independently from: – 0 – 1 – -1 – small positive integer – small negative integer – huge positive integer – huge negative integer
 So this will produce 7*7=49 partitions
that completely cover the space of pairs 
of integers.
2 Testing and Test-First Programming
Example: BigInteger.multiply()
 To produce the test suite, we would pick an arbitrary pair (a,b) 
from each square of the grid, for example: – (a,b) = (-3, 25) to cover (small negative, small positive) – (a,b) = (0, 30) to cover (0, small positive) – (a,b) = (2^100, 1) to cover (large positive, 1) – etc.
 The points are test cases that we 
might choose to completely cover 
the partition.
2 Testing and Test-First Programming
Example: max()
 Another example from the Java library: the integer max() function, 
found in the Math class.
/** 
* @param a an argument 
* @param b another argument 
* @return the larger of a and b. 
*/ 
public static int max(int a, int b) – max : int × int → int – From the specification, it makes sense to partition this function as:
• a < b
• a = b
• a > b – Our test suite might then be:
• (a, b) = (1, 2) to cover a < b
• (a, b) = (9, 9) to cover a = b
• (a, b) = (-5, -6) to cover a > b
2 Testing and Test-First Programming
Exercises
/**
* Reverses the end of a string.
*
* 012345 012345
* For example: reverseEnd("Hello, world", 5) returns "Hellodlrow ,"
* <-----> <----->
*
* With start == 0, reverses the entire text.
* With start == text.length(), reverses nothing.
*
* @param text non-null String that will have its end reversed
* @param start the index at which the remainder of the input is reversed,
* requires 0 <= start <= text.length()
* @return input text with the substring from start to the end of the string 
* reversed
*/
public static String reverseEnd(String text, int start)
• start = 0, start = 5, start = 100
• start < 0, start = 0, start > 0
• start = 0, 0 < start < text.length(), start = text.length()
• start < text.length(), start = text.length(), start > text.length()
2 Testing and Test-First Programming
Exercises
/**
* Reverses the end of a string.
*
* 012345 012345
* For example: reverseEnd("Hello, world", 5) returns "Hellodlrow ,"
* <-----> <----->
*
* With start == 0, reverses the entire text.
* With start == text.length(), reverses nothing.
*
* @param text non-null String that will have its end reversed
* @param start the index at which the remainder of the input is reversed,
* requires 0 <= start <= text.length()
* @return input text with the substring from start to the end of the string 
* reversed
*/
public static String reverseEnd(String text, int start)
Which of the following are reasonable partitions for the text parameter?
• text contains some letters; text contains no letters, but some numbers; 
text contains neither letters nor numbers
• text.length() = 0; text.length() > 0
• text.length() = 0; text.length()-start is odd; text.length()-start is even
• text is every possible string from length 0 to 100
Software Construction
6.2 Include Boundaries in the 
Partition
2 Testing and Test-First Programming
Boundary Value Analysis
 A greater number of errors occurs at the boundaries of the input 
domain rather than in the “center”: 大量的错误发生在输入域的“边
界”而非中央 – 0 is a boundary between positive numbers and negative numbers – Maximum and minimum values of numeric types, like int and double – Emptiness (the empty string, empty list, empty array) for collection types – The first and last element of a collection
 Boundary Value Analysis (BVA) has been developed as a testing 
technique, leading to a selection of test cases on bounding values. – A test-case design technique that complements equivalence partitioning. – Rather than selecting any element of an equivalence class, BVA leads to 
the selection of test cases at the “edges” of the class.
 边界值分析方法是对等价类划分方法的补充
2 Testing and Test-First Programming
Why do bugs often happen at boundaries? 
 Reasons – Programmers often make off-by-one mistakes (like writing <= instead of 
<, or initializing a counter to 0 instead of 1). 程序员经常犯一些大小差1的
错误 – Some boundaries may need to be handled as special cases in the code. 某
些边界值是“特殊情况”，需要特殊处理 – Boundaries may be places of discontinuity in the code’s behavior. When 
an int variable grows beyond its maximum positive value, for example, it 
abruptly becomes a negative number. 程序的行为在边界的地方可能发生
“突变”
 It’s important to include boundaries as subdomains in your 
partition, so that you’re choosing an input from the boundary. 在等
价类划分时，将边界作为等价类之一加入考虑
2 Testing and Test-First Programming
Guidelines for Boundary Value Analysis
a b cd x1 x2 5个测试用例:
最小值；略高于最小值；
正常值；
略低于最大值；最大值；
n个变量，有4n+1个测试用例
在5个测试用例的基础上增如:
略高于最大值；
略低于最小值；
a b cd x1 x2 a b cd x1
2 Testing and Test-First Programming
Combine Partitioning and BVA
2 Testing and Test-First Programming
Example of BVA
2 Testing and Test-First Programming
Example: max()
 Let’s redo max : int × int → int.
 Partition into: – Relationship between a and b • a < b
• a = b
• a > b – Value of a • a = 0
• a < 0
• a > 0
• a = minimum integer
• a = maximum integer
– Value of b • b = 0
• b < 0
• b > 0
• b = minimum integer
• b = maximum integer
2 Testing and Test-First Programming
Example: max()
 Now let’s pick test values that cover all these classes: – (1, 2) covers a < b, a > 0, b > 0 – (-1, -3) covers a > b, a < 0, b < 0 – (0, 0) covers a = b, a = 0, b = 0 – (Integer.MIN_VALUE, Integer.MAX_VALUE) covers a < b, a = minint, 
b = maxint – (Integer.MAX_VALUE, Integer.MIN_VALUE) covers a > b, a = maxint, 
b = minint
2 Testing and Test-First Programming
Two Extremes for Covering the Partition
 Full Cartesian product 笛卡尔积：全覆盖 – Every legal combination of the partition dimensions is covered by one test 
case. 多个划分维度上的多个取值，要组合起来，每个组合都要有一个用例 – For the max example that included boundaries, which has three 
dimensions with 3 parts, 5 parts, and 5 parts respectively, it would mean 
up to 3 × 5 × 5 = 75 test cases. – In practice not all of these combinations are possible. For example, there’s 
no way to cover the combination a<b, a=0, b=0, because a can’t be 
simultaneously less than zero and equal to zero. 并非所有组合情况都可能
 Cover each part 覆盖每个取值：最少1次即可 – Every part of each dimension is covered by at least one test case, but not 
necessarily every combination. 每个维度的每个取值至少被1个测试用例覆
盖一次即可 – The test suite for max might be as small as 5 test cases if carefully chosen. 
2 Testing and Test-First Programming
Two Extremes for Covering the Partition
 Full Cartesian product 笛卡尔积：全覆盖
 Cover each part 覆盖每个取值：最少1次即可
 前者：测试完备，但用例数量多，测试代价高
 后者：测试用例少，代价低，但测试覆盖度未必高。
 Often we strike some compromise between these two extremes, 
based on human judgement and caution, and influenced by 
whitebox testing and code coverage tools.
n是正奇数：
正数：>0、=0、<0
奇数：奇数、偶数
奇数隐含着整数：整数、非整数
输入的学号no需满足的条件：
• 长度为10位：10、>10、<10
• 以119开头：以此开头、以其他开头
• 之后两位数应为03/36/37：03、36、37、其他
Software Construction
7 White-box Testing
2 Testing and Test-First Programming
Black-box vs. White-box testing
 Blackbox testing means choosing test cases only from the 
specification, not the implementation of the function. 黑盒测试完
全从函数spec导出测试用例，不考虑函数内部实现 – We partitioned and looked for boundaries in multiply and max without 
looking at the actual code for these functions.
 Whitebox testing (also called glass box testing) means choosing 
test cases with knowledge of how the function is actually 
implemented. 白盒测试要考虑内部实现细节 – For example, if the implementation selects different algorithms depending 
on the input, then you should partition according to those domains. – If the implementation keeps an internal cache that remembers the answers 
to previous inputs, then you should test repeated inputs.
2 Testing and Test-First Programming
White-box testing 
 An internal perspective of the system, as well as 
programming skills, are used to design test cases. 
 The tester chooses inputs to exercise paths through the code and 
determine the appropriate outputs. 根据程序执行路径设计测试用例
 White-box testing can be applied at the unit, integration and 
system levels of the software testing process. In general, it is 
performed early in the testing process. 白盒测试一般较早执行
Spec. Program
Test Case
Spec. Program
Test Cases
2 Testing and Test-First Programming
White-box testing 
测试用例
分析
源程序
被测程序
覆盖情况分析
执行路径
2 Testing and Test-First Programming
Exercise
/**
* Sort a list of integers in nondecreasing order. 
* Modifies the list so that 
* values.get(i) <= values.get(i+1) for all 0<=i<values.length()-1
*/
public static void sort(List<Integer> values) {
// choose a good algorithm for the size of the list
if (values.length() < 10) {
radixSort(values);
} else if (values.length() < 1000*1000*1000) {
quickSort(values);
} else {
mergeSort(values);
} }
Which of the following test cases are likely to be boundary values produced by white 
box testing?
values = [] (the empty list)
values = [1, 2, 3]
values = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
values = [0, 0, 1, 0, 0, 0, 0]
2 Testing and Test-First Programming
White-box testing 
 Using white-box testing methods, you can derive test cases that – Guarantee that all independent paths within a module have been 
exercised at least once – Exercise all logical decisions on their true and false sides, – Execute all loops at their boundaries and within their operational bounds, – Exercise internal data structures to ensure their validity.
 A typical white-box testing method is called “independent/basis 
path testing” 独立/基本路径测试：对程序所有执行路径进行等价类划
分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试
用例使每一条基本路径被至少覆盖1次。
Software Construction
8 Coverage of Testing
2 Testing and Test-First Programming
Code coverage 代码覆盖度
 Testing should consider the code coverage of the test case for the 
internal logic of the program. 
 Code coverage is a measure used to describe the degree to which 
the source code of a program is executed when a particular test 
suite runs. 代码覆盖度：已有的测试用例有多大程度覆盖了被测程序 – A program with high code coverage, measured as a percentage (通常用百
分比衡量覆盖度), has had more of its source code executed during testing 
which suggests it has a lower chance of containing undetected software 
bugs compared to a program with low code coverage. – Many different metrics can be used to calculate code coverage; some of the 
most basic are the percentage of program subroutines and the percentage 
of program statements called during execution of the test suite.
代码覆盖度越低，测试越不充分
但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高
2 Testing and Test-First Programming
Code coverage 代码覆盖度
 One way to judge a test suite is to ask how thoroughly it exercises 
the program. This notion is called coverage.  There are many common kinds of coverage: – Function coverage: has each function in program been called? 函数覆盖 – Statement coverage: is every statement run by some test case? 语句覆盖 – Branch coverage: for every if or while or switch-case or for statement 
in the program, are both the true and the false direction taken by some test 
case? 分支覆盖 – Condition coverage: for every condition in if/while/for/switch-case
statement, are both the true/false direction taken by some test case? 条件
覆盖 – Path coverage: is every possible combination of branches — every path 
through the program — taken by some test case? 路径覆盖 – 感兴趣请自行阅读参考书，学习各类白盒测试方法
2 Testing and Test-First Programming
Code Coverage
 Branch coverage is stronger (requires more tests to achieve) than 
statement coverage, and path coverage is stronger than branch
coverage. 测试效果：路径覆盖>分支覆盖>语句覆盖
 In industry, 100% statement coverage is a common goal, but even 
that is rarely achieved due to unreachable defensive code (like 
“should never get here” assertions). 
 100% branch coverage is highly desirable, and safety critical 
industry code has even more arduous criteria. 
 Unfortunately 100% path coverage is infeasible, requiring 
exponential-size test suites to achieve. 测试难度：路径覆盖>分支覆
盖>语句覆盖
 在不同的软件类型中、不同的公司中，对达到何种标准的覆盖度都有
不同的要求
2 Testing and Test-First Programming
Code coverage 代码覆盖度
 The most thorough white-box method is to cover every path in the 
program 路径覆盖, but because the program generally contains a 
loop, so the number of paths is great. 但路径数量巨大，难以全覆盖 – It is almost impossible to execute every path, and we can only try to 
ensure that the coverage is as high as possible.
 An example: – A program contains a loop that needs to be executed 20 times. It includes 
5
20 different execution paths. Supposing that it takes 1 ms to test each path, 
it will take 3170 years to finish testing all the paths.
2 Testing and Test-First Programming
Code Coverage
 A standard approach to testing is to add tests until the test suite 
achieves adequate coverage: i.e., so that every reachable statement in 
the program is executed by at least one test case. 
 In practice, coverage is usually measured by a code coverage tool, 
which counts the number of times each statement is run by your test 
suite. 
 With such a tool, white box testing is easy; you just measure the 
coverage of your black box tests, and add more test cases until all 
important statements are logged as executed.
 实际当中，根据预先设定的覆盖度标准，逐步增加测试用例的数量，
直到覆盖度达到标准（例如语句覆盖100%、路径覆盖90%）。
2 Testing and Test-First Programming
EclEmma
 A good code coverage tool for Eclipse is EclEmma – http://www.eclemma.org
– http://www.ibm.com/developerworks/cn/java/j-lo-eclemma
 Lines that have been 
executed by the test suite are 
colored green, and lines not 
yet covered are red.  The next step is to come up 
with a test case that causes 
the red lines to execute, and 
add it to your test suite so 
that the red lines become 
green.
2 Testing and Test-First Programming
EclEmma’s code coverage analysis
Software Construction
9 Automated Testing and 
Regression Testing
2 Testing and Test-First Programming
Automated testing
 Nothing makes tests easier to run, and more likely to be run, than 
complete automation. 手工测试的代价太高，最好达到完全的自动化
 Automated testing means running the tests and checking their 
results automatically. 自动调用被测函数、自动判定测试结果、自动
计算覆盖度 – A test driver should not be an interactive program that prompts you for 
inputs and prints out results for you to manually check. – Instead, a test driver should invoke the module itself on fixed test cases 
and automatically check that the results are correct. – The result of the test driver should be either “all tests OK” or “these tests 
failed: …” 
 A good testing framework, like JUnit, helps you build automated test 
suites.
2 Testing and Test-First Programming
Automated testing vs. Automatic test generation 
 Note that automated testing frameworks like JUnit make it easy to 
run the tests, but you still have to come up with good test cases 
yourself. 只是“测试用例的自动执行”，并非“自动生成测试用例”
 Automatic test generation is a hard problem, still a subject of active 
computer science research.
2 Testing and Test-First Programming
Regression testing 回归测试
 Once you have test automation, it’s very important to rerun your 
tests when you modify your code. 回归测试：一旦程序被修改，重
新执行之前的所有测试 – Software engineers know from painful experience that any change to a 
large or complex program is dangerous. – Whether you’re fixing another bug, adding a new feature, or optimizing 
the code to make it faster, an automated test suite that preserves a baseline 
of correct behavior – even if it’s only a few tests – will save your bacon. – Running the tests frequently while you’re changing the code prevents 
your program from regressing — introducing other bugs when you fix new 
bugs or add new features. 
 Running all your tests after every change is called regression testing.
2 Testing and Test-First Programming
Regression testing
 Whenever you find and fix a bug, take the input that elicited the 
bug and add it to your automated test suite as a test case. 
 This kind of test case is called a regression test. This helps to 
populate your test suite with good test cases. 
 Remember that a test is good if it elicits a bug — and every 
regression test did in one version of your code! 
 Saving regression tests also protects against reversions that 
reintroduce the bug. 
2 Testing and Test-First Programming
Automated regression testing
 This idea also leads to test-first debugging. – When a bug arises, immediately write a test case for it that elicits it, and 
immediately add it to your test suite. – Once you find and fix the bug, all your test cases will be passing, and 
you’ll be done with debugging and have a regression test for that bug. 
一旦发现bug，要马上写一个可重现该bug的测试用例，并将其加入测试库
 In practice, automated testing and regression testing, are almost 
always used in combination. – Regression testing is only practical if the tests can be run often, 
automatically. – Conversely, if you already have automated testing in place for your 
project, then you might as well use it to prevent regressions. 
 Automated regression testing is a best-practice of modern software 
engineering. 自动化回归测试
2 Testing and Test-First Programming
Continuous Integration
2 Testing and Test-First Programming
Travis-CI
 https://travis-ci.org
2 Testing and Test-First Programming
Exercise
 Which of the following best defines regression testing? – You should run a suite of tests whenever you change the code. – Every component in your code should have an associated set of tests that 
exercises all the corner cases in its specification. – Tests should be written before you write the code as a way of checking 
your understanding of the specification. – When a new test exposes a bug, you should run it on all previous versions 
of the code until you find the version where the bug was introduced.
 Which of the following are good times to rerun all your JUnit tests? – Before doing git add/commit/push
– After rewriting a function to make it faster – When using a code coverage tool – After you think you fixed a bug
Software Construction
10 Documenting Your Testing 
Strategy
2 Testing and Test-First Programming
Documenting Testing Strategy
 Unit testing strategy is a complementary document of ADT’s 
design. 测试策略（根据什么来选择测试用例）非常重要，需要在程
序中显式记录下来 – Aligning with the idea of test-first programming, it is recommended to 
write down the testing strategy (such as partitioning and boundary) 
according to which you design your test cases.
 The objective is to make code review to check if your testing is 
sufficient, and to make other developers understand your test. 
目的：在代码评审过程中，其他人可以理解你的测试，并评判你的测
试是否足够充分
2 Testing and Test-First Programming
An example Document the strategy at the top of 
the test class:
Each test method should have a 
comment above it saying how its test 
case was chosen, i.e. which parts of the 
partitions it covers:
Software Construction
Summary
2 Testing and Test-First Programming
Summary of this lecture
 Test-first programming. Write tests before you write code.
 Partitioning and boundaries for choosing test cases systematically.
 White box testing and statement coverage for filling out a test suite.
 Unit-testing each module, in isolation as much as possible.
 Automated regression testing to keep bugs from coming back.
 Safe from bugs. Testing is about finding bugs in your code, and test￾first programming is about finding them as early as possible, 
immediately after you introduced them.
Software Construction
The end
May 10, 2021
Software Construction
3 Software Construction Process and 
Configuration Management
软件构造过程与配置管理
Wang Zhongjie
rainy@hit.edu.cn
May 10, 2021
3 Software Construction Process and Configuration Management
Objectives of this lecture
 To know the general process of software development 软件开发的
基本过程
 To understand the philosophy of traditional software process 
models including linear and iterative models (waterfall, 
incremental, prototyping, spiral, and V-model) 传统的软件开发过程
模型
 To know and make practice of Agile development 敏捷开发
 To understand Software Configuration Management (SCM) 软件配
置管理
 To learn how to use Git for daily SCM tasks (basic commands for 
personal dev., advanced commands for collaborative dev) Git作为
配置管理工具
3 Software Construction Process and Configuration Management
Objective of this lecture
 Get to know the general process of software construction (Design 
 Programming  Debug  Testing  Build  Release) 广义的
软件构造过程
 Use Eclipse IDE as Java construction environment and tools 
Eclipse作为Java构造工具
 Get to know typical tools for review and static analysis, debug 
(dumping, logging) and testing, and dynamic analysis / profiling 
软件构造各阶段的常见工具
 Learn the narrow-sense process of software construction (Build: 
Validate  Compile  Link  Test  Package  Install 
Deploy) 狭义的软件构造：build
 Use one of build tools (make, Ant, Maven, Gradle, Eclipse IDE) to 
build your own Java projects 常见的build工具
3 Software Construction Process and Configuration Management
Outline
 Software Development Lifecycle (SDLC)
 Traditional software process models (waterfall, incremental, V￾model, prototyping, spiral)
 Agile development and eXtreme Programming (XP)
 Software Configuration Management (SCM)
 Git as a SCM tool
 Summary
第1次课：软件构造的结果形态、如何是“好”
本次课关心：软件开发(01…n)遵循什么过程
3 Software Construction Process and Configuration Management
Outline
 General process of software construction: Design  Programming 
/refactoring  Debugging  Testing  Build  Release – Programming / refactoring
– Review and static code analysis – Debugging (dumping and logging) and Testing
– Dynamic code analysis /profiling
 Narrow-sense process of software construction (Build): Validate 
Compile  Link  Test  Package  Install  Deploy
– Build system: components and process – Build variants and build language – Build tools: Make, Ant, Maven, Gradle, Eclipse/IDEA/NetBeans
 Summary
以及：每个阶段内部的“子过程”
3 Software Construction Process and Configuration Management
Reading
 MIT 6.031：05、28
 CMU 17-214：Nov 19、Nov 21
 软件工程--实践者的研究方法：第2-3、22章  代码大全：第21、27-30章  深入理解软件构造系统：第1-5章、第7章、第10章  持续集成实践：第1-5章
Software Construction
1 Software Development Lifecycle 
(SDLC)
3 Software Construction Process and Configuration Management
Lifecycle of a software 
 Software Development Life Cycle (SDLC): From 0 to 1 从无到有
3 Software Construction Process and Configuration Management
Lifecycle of a software 
 Multiple versions in the life of a software: From 1 to n 从有到好
Initial
Version
Updated
Version 1 Discarded Updated
Version 2 …
3 Software Construction Process and Configuration Management
Life patterns of software
Vitality
0 Time
Software Construction
2 Traditional Software Process 
Models
3 Software Construction Process and Configuration Management
Traditional software process models
 Two basic types: – Linear 线性过程 – Iterative 迭代过程
 Existing models: – Waterfall (Linear, non-iterative) 瀑布过程 – Incremental (non-iterative) 增量过程 – V-Model (for verification and validation) V字模型 – Prototyping (iterative) 原型过程 – Spiral (iterative) 螺旋模型
 Key quality considerations 选择合适的过程模型的依据: – User involvement (adapt to changes) 用户参与程度有多大？--适应变化的能力 – Development efficiency, management complexity 开发效率/管理复杂度 – Quality of software 开发出的软件的质量
3 Software Construction Process and Configuration Management
Waterfall (sequential, non-iterative)
 Progress is seen as flowing steadily downwards (like a waterfall) 
through the phases of conception, initiation, analysis, design, 
construction, testing, implementation and maintenance.
 Easy to use, but after-the-fact changes are prohibitively costly.
 Defined by Winston W. Royce in 1970. 瀑布过程：
• 线性推进
• 阶段划分清楚
• 整体推进
• 无迭代
• 管理简单
• 无法适应需求
增加/变化
3 Software Construction Process and Configuration Management
Incremental (non-iterative)
增量过程：
• 线性推进
• 增量式（多个瀑布的串行）
• 无迭代
• 比较容易适应需求的增加
3 Software Construction Process and Configuration Management
V-Model (for verification and validation)
 V-model represents a development process that may be considered 
an extension of the waterfall model. – Instead of moving down in a linear way, the process steps are bent 
upwards after the coding phase, to form the typical V shape. – Demonstrates the relationships between each phase of the development 
life cycle and its associated phase of testing. – The horizontal and 
vertical axes represents 
time or project 
completeness 
(left-to-right) and 
level of abstraction 
(coarsest-grain abstraction 
uppermost), respectively.
3 Software Construction Process and Configuration Management
Prototyping (iterative)
 Benefits: – The software designer and implementer 
can get valuable feedback from the users 
early in the project. – The client can compare if the software 
made matches the software specification, 
according to which the software 
program is built. – It also allows the software engineer some 
insight into the accuracy of initial project 
estimates and whether the deadlines and 
milestones can be successfully met.
在原型上持续不断的迭代
发现用户变化的需求
迭代：开发出来之后由用户试用/评审，发现问题反馈给
开发者，开发者修改原有的实现，继续交给用户评审。
循环往复这个过程，直到用户满意为止。
时间代价高，但开发质量也高。
3 Software Construction Process and Configuration Management
Spiral (iterative)
非常复杂的过程：
• 多轮迭代基本遵循瀑
布模式
• 每轮迭代有明确的目
标，遵循“原型”过
程，进行严格的风险
分析，方可进入下一
轮迭代
Software Construction
3 Agile Development
3 Software Construction Process and Configuration Management
Agile development
 It advocates adaptive planning, evolutionary development, early 
delivery, and continuous improvement, and it encourages rapid 
and flexible response to change. 敏捷开发：通过快速迭代和小规模
的持续改进，以快速适应变化。
 Agile Manifesto 敏捷宣言 was firstly coined in 2001 by 17 famous 
“programmers”.
3 Software Construction Process and Configuration Management
Agile development: rapid delivery
Agile = 增量 + 迭代
每次迭代处理一个小规模增量
3 Software Construction Process and Configuration Management
Agile development
 Extreme user involvement
 Extreme small iteration
 Extreme V&V
 极限的用户参与
 极限的小步骤迭代
 极限的确认/验证
3 Software Construction Process and Configuration Management
Waterfall vs. Agile
3 Software Construction Process and Configuration Management
eXtreme Programming (XP，极限编程)
Continuous delivery
unit t est 
continuous integration 
acceptance testing
pair 
programming
Release
user st ories 
values 
 acceptance test criteria 
iteration plan
simple design 
CRC cards
spike solutions 
protot ypes
refactoring
software increment
project velocity computed
Incremental user stories
Test-Driven Dev.
(TDD)
Pair programming
Continuous integration
Refactoring
Build automation
Prototyping
Iteration
3 Software Construction Process and Configuration Management
Pair Programming
3 Software Construction Process and Configuration Management
Task board and progress monitoring
3 Software Construction Process and Configuration Management
《硅谷》中的敏捷开发和task board
Software Construction
4 Software Configuration 
Management (SCM)
and Version Control System (VCS)
3 Software Construction Process and Configuration Management
Software Configuration Mgmt. (SCM)
 SCM is the task of tracking and controlling changes in the 
software. 软件配置管理：追踪和控制软件的变化
 SCM practices include revision control and the establishment of 
baselines. 
3 Software Construction Process and Configuration Management
Life Cycle of a Configuration Item (CI)
 Any constituents of a software (source code, data, documents, 
hardware, various environments) may be updated along with the 
time in the life cycle of the software.
 Software Configuration Item (SCI): the fundamental structural 
unit of SCM. 软件配置项：软件中发生变化的基本单元（例如：文件）
1.0
1.1
1.2
1.3
File 1 File 2 File 3 Version 
Labels
Final
Version
Beta 1
1.0
1.1
1.2
1.3
1.0
1.1
1.2
1.0
1.1
1.2
1.3
1.4
3 Software Construction Process and Configuration Management
Configuration Items (SCI) and Baselines
 A baseline is an agreed description of the attributes of a product, 
at a point in time, which serves as a basis for defining change.
基线：软件持续变化过程中的“稳定时刻”（例如：对外发布的版本）
3 Software Construction Process and Configuration Management
CMDB and Check-in/Check-out for Auditing
CMDB：配置管理数据库
存储软件的各配置项随时间发生变化的信息
+基线
3 Software Construction Process and Configuration Management
Versioning 版本控制
 Versioning is the process of assigning either unique version 
names or unique version numbers to unique states of 
software. 版本：为软件的任一特定时刻（Moment）的形态指
派一个唯一的编号，作为“身份标识” – Within a given version number category (major, minor), these 
numbers are generally assigned in increasing order and correspond 
to new developments in the software. – At a fine-grained level, revision control is often used for keeping 
track of incrementally different versions of electronic information, 
whether or not this information is computer software.
3 Software Construction Process and Configuration Management
Version control systems you’ve already used
 古老的版本控制方法：通过复制文件并修改文件名
3 Software Construction Process and Configuration Management
Why version control is required – for individuals
 Reverting to a past version 回滚到上一个版本
 Comparing two different versions 比较两个版本的差异
 Pushing full version history to another location 
备份软件版本历史
 Pulling history back from that 
location 获取备份
 Merging versions that are offshoots of the same earlier version 合并
3 Software Construction Process and Configuration Management
Why version control is required – for teamwork
 Communications and share/merge works among multiple 
developers 在多个开发者之间共享和协作
 Logging individualized works of different developers for auditing 
记录每个开发者的动作，便于“审计”
3 Software Construction Process and Configuration Management
History of an SCI
多个版本之间，形成线性
或分支结构
3 Software Construction Process and Configuration Management
Version control terminology
 Repository: a local or remote store of the versions in a project 
仓库：即于SCM中的CMDB
 Working copy: a local, editable copy of a project that we can work on 
工作拷贝：在开发者本地机器上的一份项目拷贝
 File: a single file in the project 文件：一个独立的配置项
 Version or revision: a record of the contents of the project at a point 
in time 版本：在某个特定时间点的所有文件的共同状态
 Change or diff: the difference between two versions 变化：即code 
churn，两个版本之间的差异
 Head: the current version HEAD：程序员正在其上工作的版本
3 Software Construction Process and Configuration Management
Version Control System (VCS) 
 Local VCS 
 Centralized VCS
 Distributed VCS
 本地版本控制系统：
仓库存储于开发者本地机器
无法共享和协作
3 Software Construction Process and Configuration Management
Version Control System (VCS) 
 Local VCS
 Centralized VCS
 Distributed VCS
集中式版本控制系统：仓库存储于独立的服务器，
支持多开发者之间的协作
3 Software Construction Process and Configuration Management
Version Control System (VCS) 
 Local VCS
 Centralized VCS
 Distributed VCS
分布式版本控制系
统：仓库存储于独
立的服务器+每个开
发者的本地机器
Software Construction
5 Git as an example of SCM tool
3 Software Construction Process and Configuration Management
What is Git?
 Initial release: 2005
 Initial Author: Linus Torvalds
 For development of the Linux kernel.
Linus Torvalds (1969-)
3 Software Construction Process and Configuration Management
Managing changes in software evolution process
3 Software Construction Process and Configuration Management
Git repository
 A Git repository has three parts: – .git directory (a repository storing all version control data) 本地的CMDB
– Working directory (local file system) 工作目录：本地文件系统 – Staging area (in memory) 暂存区：隔离工作目录和Git仓库
 Each file belongs to one of the following three states: – Modified (the file in working directory
is different from the one in git repository,
but is not in staging area) 已修改 – Staged (the file is modified and has been
added into the staging area) 已暂存 – Committed (the file keeps same in working
directory and git directory) 已提交
3 Software Construction Process and Configuration Management
Object graph in Git
 All of the operations we do with Git — clone, add, commit, push, 
log, merge, … — are operations on a graph data structure that 
stores all of the versions of files in the project, and all the log 
entries describing those changes. 
 The Git object graph is stored in the .git directory of the repository. 
 Copying a git project from another machine/server means copying 
the whole object graph. – git clone URL local_repository
3 Software Construction Process and Configuration Management
What an Object Graph looks like?
 Object graph, being the history of a Git project, 
is a directed acyclic graph (DAG). 
 Object Graph：版本之间的演化关系图，一条边
A->B表征了“在版本B的基础上作出变化，形成
了版本A”
3 Software Construction Process and Configuration Management
Commits: nodes in Object Graph
 Each node in the history graph is a commit a.k.a. 
version a.k.a. revision of the project: a complete 
snapshot of all the files at that point in time. – Except for the initial commit, each commit has a 
pointer to a parent commit. 每个commit指向一个父亲 – Some commits have the same parent: they are versions 
that diverged from a common previous version. 多个
commit指向同一个父亲：分支 – Some commits have two parents: they are versions 
that tie divergent histories back together. 一个commit
指向两个父亲：合并
 A branch is just a name that points to a commit.
 HEAD points to the current commit. – We need to remember which branch we’re working on. So HEAD
points to the current branch, which points to the current commit.
3 Software Construction Process and Configuration Management
Commits: nodes in Object Graph
 Git represents a commit with a tree node. – For a project of any reasonable size, most of the files won’t change in any 
given revision. Storing redundant copies of the files would be wasteful, so 
Git doesn’t do that. – Instead, Git object graph stores each version of an individual file once, and 
allows multiple commits to share that one copy. – Each commit also has log data — who, when, short log message, etc.
指向具体文件
存储的指针 与之前commit
中未发生变化
的文件，无需
重复存储
3 Software Construction Process and Configuration Management
Managing changes in Git
 Traditional VCS:
传统VCS存储
版本之间的变
化（行）
 In Git:
Git存储发生变
化的文件（而
非代码行），
不变化的文件
不重复存储
3 Software Construction Process and Configuration Management
Commits: nodes in Object Graph
文件未发生变化，则后
续多个版本始终指向同
一个文件
文件发生变化了，存储
两份不同的文件，两个
版本指向不同的文件
3 Software Construction Process and Configuration Management
Add to the object graph with git commit
3 Software Construction Process and Configuration Management
Send & receive object graphs with git push & git pull
本地仓库 远程仓库
3 Software Construction Process and Configuration Management
Git supports Branch and Merge 分支/合并
 A branch is the duplication of an object under revision 
control so that modifications can happen in parallel along 
both branches.
 Merging two branches together.
3 Software Construction Process and Configuration Management
Branching
3 Software Construction Process and Configuration Management
Creating and merging branches in Git
git checkout –b iss53 git commit
git checkout master
git checkout –b hotfix
git commit
git checkout master
git merge hotfix
3 Software Construction Process and Configuration Management
Creating and merging branches in Git
git branch –d hotfix
git checkout iss53
git commit
git checkout master
git merge iss53
3 Software Construction Process and Configuration Management
Git supports collaboration
 Local repository and Remote Repository 
3 Software Construction Process and Configuration Management
Git supports collaboration
3 Software Construction Process and Configuration Management
Git supports collaboration
3 Software Construction Process and Configuration Management
Git supports collaboration
3 Software Construction Process and Configuration Management
GitHub is how people build software
 GitHub: a web-based Git server and Internet hosting service. – It offers all of the distributed version control and SCM functionality of Git 
as well as adding its own features. – It provides access control and several collaboration features such as bug 
tracking, feature requests, task management, and wikis for every project. – Private and free repositories (for open-source projects)
 In 2019, it has more than 31 million users above 100 million 
repositories.
3 Software Construction Process and Configuration Management
GitHub working process
 Basic process: commit, branch and merge
 Collaboration process: fork and pull request
3 Software Construction Process and Configuration Management
GitHub working process
3 Software Construction Process and Configuration Management
Issue Tracking and Pull Request
Software Construction
6 General process of software 
construction
3 Software Construction Process and Configuration Management
General process of software construction
Programming 
(coding) 编码
Debugging
调试
Refactoring
重构
Testing
测试
Dynamic code 
analysis /profiling 
性能分析
Code review
Static code analysis
代码评审
Build
构建
Validate
Compile
Link
Test 
Package
Install
Deploy
Clean …
Software Construction
(1) Programming
3 Software Construction Process and Configuration Management
Construction languages
 Purpose of the languages 从用途上划分 – Programming languages (e.g., C, C++, Java, Python) 编程语言 – Modeling languages (e.g., UML) 建模语言 – Configuration languages (e.g., XML) 配置语言 – Build languages (e.g., XML) 构建语言
 Forms of the languages 从形态上划分 – Linguistic-based 基于语言学的构造语言 – Mathematics-based (formal) 基于数学的形式化构造语言 – Graphics-based (visual) 基于图形的可视化构造语言
3 Software Construction Process and Configuration Management
(1) Programming Languages 编程语言
3 Software Construction Process and Configuration Management
Programming tools
 Integrated development environment (IDE): comprehensive facilities 
to programmers for software development. 集成开发环境
 An IDE normally consists of: – Source code editor with intelligent code completion, code refactoring tool
源代码编辑器、智能代码补全工具、代码重构工具 – File management tool 文件管理 – Library management tool 库管理 – Class browser, object browser, class hierarchy diagram 软件逻辑实体可视化 – Graphical User Interface (GUI) builder 图形化用户界面构造器 – Compiler, interpreter 编译器、解释器 – Build automation tools 自动化build工具 – Version control system 版本控制系统 – Extensible by more external third-party tools 外部的第三方工具
3 Software Construction Process and Configuration Management
Eclipse as an IDE example
 Eclipse IDE: an open source IDE for Java, but not limited to, 
C/C++, PHP, Python, etc, started as a proprietary IBM product 
(Visual age for Smalltalk/Java) – It contains a base workspace with tools for coding, building, running and 
debugging applications, and an extensible plug-in system for customizing 
the environment. – Plug-ins are structured bundles of code and/or data that contribute 
functionality to the system. 
Functionality can be contributed 
in the form of code libraries, 
platform extensions, or even 
documentation. – Plug-ins can define extension 
points, well-defined places 
where other plug-ins can add 
functionality.
3 Software Construction Process and Configuration Management
Eclipse IDE Components
Menu bars
Full drop down menus plus quick 
access to common functions
Editor Pane
This is where we edit 
our source code
Perspective Switcher
We can switch between 
various perspectives 
here
Outline Pane
This contains a hierarchical 
view of a source file
Package Explorer Pane
This is where our 
projects/files are listed
Miscellaneous Pane
Various components can appear in this 
pane – typically this contains a console 
and a list of compiler problems
Task List Pane
This contains a list of 
“tasks” to complete
3 Software Construction Process and Configuration Management
(2) Modeling languages 建模语言
http://modeling-languages.com
 A modeling language is any artificial language that can be used to 
express information or knowledge or systems in a structure that is 
defined by a consistent set of rules, with the objective of visualizing, 
reasoning, verifying and communicating the design of a system.
3 Software Construction Process and Configuration Management
UML as a modeling language and tool example
 UML: Unified Modeling Language
to learn UML in “Software Process and Tools” in the 3rd year
3 Software Construction Process and Configuration Management
UML as a modeling language and tool example
 UML Class Diagram
3 Software Construction Process and Configuration Management
UML as a modeling language and tool example
 UML Sequence Diagram
3 Software Construction Process and Configuration Management
(3) Configuration languages 配置语言
 Configuration files configure the parameters and initial settings 
for programs. – Applications should provide tools to create, modify, and verify 
the syntax of their configuration files; – Some computer programs only read their configuration files at startup. 
Others periodically check the configuration files for changes.
 Purpose example: – Deployment environment settings – Variants of application features – Variants of connections between components
 Configuration language examples: – Key-Value texts (.ini, .properties, .rc, etc) – XML, YAML, JSON
To separate 
stable and 
unstable parts
To change 
behaviors of 
software at 
run-time
3 Software Construction Process and Configuration Management
Configuration languages
Software Construction
(2) Review and static code analysis
3 Software Construction Process and Configuration Management
Review and static analysis/checking 代码评审
 Code review is systematic examination (peer 
review) of source code. – Intended to find mistakes overlooked in the initial 
development phase, improving the overall quality. – Reviews are done in various forms such as pair 
programming, informal walkthroughs, and formal 
inspections. – 结对编程 – 走查 – 正式评审会议 – 自动化评审
3 Software Construction Process and Configuration Management
Formal code review 正式的代码评审会议
 Formal code review, such as a Fagan inspection, involves a careful 
and detailed process with multiple participants and multiple 
phases. – Formal code reviews are the traditional method of review, in 
which software developers attend a 
series of meetings and review code 
line by line, usually using printed 
copies of the material. – Formal inspections are extremely 
thorough and have been proven 
effective at finding defects in the 
code under review.
3 Software Construction Process and Configuration Management
Formal code review 正式的代码评审会议
3 Software Construction Process and Configuration Management
Lightweight code review 轻量级的代码评审
 Lightweight code review typically requires less overhead than 
formal code inspections, though it can be equally effective when 
done properly. 
 Lightweight reviews are often conducted as part of the 
normal development process: – Over-the-shoulder – one developer looks over the author's 
shoulder as the latter walks through the code. – Email pass-around – source code management system emails code to 
reviewers automatically after checkin is made. – Pair programming – two authors develop code together at the same 
workstation, as it is common in Extreme Programming. – Tool-assisted code review – authors and reviewers use 
software tools, informal ones such as pastebins and
IRC, or specialized tools designed for peer code 
review.
3 Software Construction Process and Configuration Management
Static code analysis 利用工具进行的静态代码分析
 Static code analysis is the analysis of computer software that is 
performed without actually executing programs (analysis 
performed on executing programs is known as dynamic analysis).
 The process provides an understanding of the code structure, and 
can help to ensure that the code adheres to industry standards. 
 Automated tools can assist programmers and developers in 
carrying out static analysis. – e.g., CheckStyle, SpotBugs, PMD for Java
3 Software Construction Process and Configuration Management
Purpose of Code Review
 Code review really has two purposes: – Improving the code. Finding bugs, anticipating possible bugs, checking 
the clarity of the code, and checking for consistency with the project’s style 
standards. – Improving the programmer. Code review is an important way that 
programmers learn and teach each other, about new language features, 
changes in the design of the project or its coding standards, and new 
techniques. In open source projects, particularly, much conversation 
happens in the context of code reviews.
 Code review is widely practiced in open source projects like 
Apache and Mozilla. 
 Code review is also widely practiced in industry. – At Google, you can’t push any code into the main repository until another 
engineer has signed off on it in a code review.
3 Software Construction Process and Configuration Management
Some concrete examples of Code Review
Bugs or potential bugs.
Repetitive code (remember DRY, Don’t Repeat Yourself).
Disagreement between code and specification.
Off-by-one errors.
Global variables, and other too-large variable scopes.
Optimistic, undefensive programming.
Magic numbers. …
Unclear, messy code.
Bad variable or method names.
Inconsistent indentation.
Convoluted control flow (if and while statements) that 
could be simplified.
Packing too much into one line of code, or too much into 
one method.
Failing to comment obscure code.
Having too many trivial comments that are simply 
redundant with the code.
Variables used for more than one purpose. …
3 Software Construction Process and Configuration Management
Some concrete examples of Code Review
Misunderstandings of Java.
Misuse of == or .equals()
Inadvertent use of integer division instead of floating￾point division.
Use of a fixed-size array where a variable-length List 
would be more appropriate. …
Misusing (or failing to use) essential design concepts.
Incomplete or incorrect specification for a method or class.
Representation exposure for a data abstraction.
Immutable datatypes that expose themselves to change.
Invariants that aren’t really invariant, or aren’t even stated.
Failure to implement the Object contract correctly (equals and 
hashCode). …
Code review is 
usually based 
on 
“programming 
experience”. 
Software Construction
(3) Dynamic code analysis / profiling
3 Software Construction Process and Configuration Management
Dynamic code analysis / profiling
 Dynamic program analysis is the analysis of software that is 
performed by executing programs. 动态分析：要执行程序并观察现
象、收集数据、分析不足
 The target program must be executed with sufficient test inputs to 
produce interesting behavior. 
 Use of software testing measures such as code coverage helps 
ensure that an adequate slice of the program's set of possible 
behaviors has been observed. 
 Profiling (“program profiling”, “software profiling”) is a form of 
dynamic program analysis that measures the space (memory) or 
time complexity of a program, the usage of particular instructions, 
or the frequency and duration of function calls. 
对代码的运行时状态和性能进行度量，发现代码中的潜在问题
3 Software Construction Process and Configuration Management
Dynamic code analysis / profiling
Software Construction
(4) Debugging and Testing
3 Software Construction Process and Configuration Management
What is testing? 测试：发现程序是否有错误
 Software testing is an investigation conducted to provide 
stakeholders with information about the quality of the product or 
service under test. 
 Test techniques include the process of executing a program or 
application with the intent of finding software bugs (errors or other 
defects), and verifying that 
the software product is fit 
for use.
 Software testing involves the
execution of a software 
component or system 
component to evaluate one 
or more properties of interest. 
3 Software Construction Process and Configuration Management
What is Debugging? 调试：定位错误、发现错误根源
 Debugging is the process of identifying the root cause of an error 
and correcting it. 
 It contrasts with testing, which is the process of detecting the error 
initially, debugging occurs as a consequence of successful testing. – On some projects, debugging occupies as much as 50 percent of the total 
development time. – For many programmers, debugging is the hardest part of programming.
 Like testing, debugging isn’t a way to improve the quality of your 
software, but it’s a way to diagnose defects. – Software quality must be built in from the start. The best way to build a 
quality product is to develop requirements carefully, design well, and use 
high-quality coding practices. – Debugging is a last resort.
3 Software Construction Process and Configuration Management
Debug perspective in Eclipse
List of breakpoints
These buttons allow you 
to step through the code
Note new Debug 
perspective – click Java to 
return to normal
Variables in scope are listed here along 
with their current values (by right 
clicking you can change values of 
variables as you program is running)
Current high level location 
(class and method)
This pane shows the current 
line of code we broke on
Output console, just like 
in normal run mode
Software Construction
(5) Refactoring
3 Software Construction Process and Configuration Management
Refactoring 重构：在不改变功能的前提下优化代码
 Refactoring is the process of changing a software system in such a 
way that it does not alter the external behavior of the code yet 
improves its internal structure. – Incurs a short-term time/work cost to reap long-term benefits, and a long￾term investment in the overall quality of your system.
 Refactoring is: – restructuring (rearranging) code... – ...in a series of small, semantics-preserving 
transformations... – ...in order to make the code easier to maintain and modify
 Refactoring is not just any old restructuring
– You need to keep the code working
– You need small steps that preserve semantics – You need to have unit tests to prove the code works
3 Software Construction Process and Configuration Management
Refactoring
3 Software Construction Process and Configuration Management
Eclipse IDE support for refactoring
 Eclipse (and some other IDEs) provide 
significant support for refactoring
3 Software Construction Process and Configuration Management
Eclipse IDE support for refactoring
http://help.eclipse.org/
luna/index.jsp?topic=%2F
org.eclipse.jdt.doc.user
%2Freference%2Fref-menu￾refactor.htm
3 Software Construction Process and Configuration Management
External tools for refactoring
Software Construction
7* Narrow-sense process of software 
construction (Build)
粗略理解build：build-time  run-time
借助于工具，将软件构造各阶段的活动“自动化”
(编译、打包、静态分析、测试、生成文档、部署、…)
尽可能脱离“手工作业”，提高构造效率
3 Software Construction Process and Configuration Management
Typical BUILD scenarios 使用build的典型场景
 The compilation of software written in traditional compiled 
languages, such as C, C++, Java and C#. 
 The packaging and testing of software written in interpreted 
languages such as Perl and Python.
 The compilation and packaging of web-based applications. – These include static HTML pages, source code written in Java or C#, 
hybrid files written using JSP (JavaServer Pages), ASP (Active Server 
Pages), or PHP (Hypertext Preprocessor) syntax, along with numerous 
types of configuration file.
3 Software Construction Process and Configuration Management
Typical BUILD scenarios 使用build的典型场景
 The execution of unit tests to validate small portions of the 
software in isolation from the rest of the code.
 The execution of static analysis tools to identify bugs in a 
program’s source code. The output from this build system is a bug 
report document rather than an executable program.
 The generation of PDF or HTML documentation. This type of 
build system consumes input files in a range of different formats 
but generates human-readable documentation as the output.
3 Software Construction Process and Configuration Management
Compiled Languages
 Compiled languages such as C, C++, Java, and C#. In this model, 
source files are compiled into object files, which are then linked 
into code libraries or executable programs. 
 The resulting files are collected into a release package that can be 
installed on a target machine.
3 Software Construction Process and Configuration Management
Interpreted Languages
 Interpreted source code isn’t compiled into object code, so there’s no 
need for an object tree. The source files themselves are collected into 
a release package, ready to be installed on the target machine. 
 Compilation tools focus on transforming source files and storing 
them in the release package. 
 Compilation into machine code is not performed at build time, even 
though it may happen at runtime.
3 Software Construction Process and Configuration Management
Web-Based Applications
 The build system for a web-based application is a mix of compiled 
code, interpreted code, and configuration or data files. 
 Some files (such as HTML files) are copied directly from the source 
tree to the release package, whereas others (such as Java source files) 
are first compiled into object code. 
3 Software Construction Process and Configuration Management
Unit Testing, Static Analysis, etc
3 Software Construction Process and Configuration Management
Components of a Build System
 Version-Control Tools
 Source Tree: a program’s source code is stored as a number of disk 
files. This arrangement of the files into different is known as the 
source tree. The structure of the source tree often reflects the 
architecture of the software. 
 Object Trees: a separate tree hierarchy that stores any object files or 
executable programs constructed by the build process.
 Compilation Tools: a program that translate the human-readable 
source files into the machine-readable executable program files. – Compiler: source files  object files – Linker: multiple related object files  executable program image – UML-based code generator: models  source code files – Documentation generator: scripts  documents
3 Software Construction Process and Configuration Management
Native compilation vs. cross-compilation
3 Software Construction Process and Configuration Management
Components of a Build System
 Release Packaging and Target Machines: produces something that 
you can actually install on a user’s machine. – To extract the relevant files from the source and object trees and store 
them in a release package. – The release package should be a single disk file and should be compressed 
to reduce the amount of time it takes to download. – Any nonessential debug information should be removed so that it doesn’t 
clutter the software’s installation.
 Types of packaging: – Archive files: zip and unzip
– Package-management tools: UNIX-style such as .rpm and .deb – Custom-built GUI installation tools: Windows-style
3 Software Construction Process and Configuration Management
Build process
 Build process: the build tool invokes each of the compilation tools to 
get the job done, which is an end-to-end sequence of events.
3 Software Construction Process and Configuration Management
Build language (build description)
 A build tool needs the build 
description to be written in a text￾based format. – It follows syntax rules of a specific 
build language.
 For example, when using Make, the 
interfile dependency information is 
specified in the form of rules, which 
are stored in a file named Makefile.  You can write the description 
manually or generate it by IDE.
Makefile for a java program
JFLAGS = -g
JC = javac
.SUFFIXES: .java .class
.java.class:
$(JC) $(JFLAGS) $*.java
CLASSES = \
Foo.java \
Blah.java \
Library.java \
Main.java 
default: classes
classes: $(CLASSES:.java=.class)
clean:
$(RM) *.class
3 Software Construction Process and Configuration Management
How a build system is used
 Developer (or private) build: The developer has checked out the 
source code from VCS and is building the software in a private 
workspace. 
 Release build: to provide a complete software package for the test 
group to validate. When the testers are convinced that the software is 
of high enough quality, that same package is made available to 
customers. 
 Sanity build: The build process determines whether the current 
source code is free of errors and passes a basic set of sanity tests. This 
type of build can occur many times per day and tends to be fully 
automated. – Daily build / nightly build 每日构建 – Continuous Integration (CI) 持续集成
3 Software Construction Process and Configuration Management
Continuous Integration (CI) 持续集成
https://en.wikipedia.org/wiki/Continuous_integration
3 Software Construction Process and Configuration Management
Jenkins
 https://jenkins.io
3 Software Construction Process and Configuration Management
Build tools
 For Java: – Make – Ant – Maven
– Gradle – Eclipse IDE
 Build工具 + 相应的build script (类似于编程语言，告诉工具具体如
何一步一步的build)
 建议最好学会Ant、Maven、Gradle中的一种，提高你的编程效率
Software Construction
Summary
3 Software Construction Process and Configuration Management
Summary
 General Software Development Lifecycle (SDLC)
 Traditional software process models – Waterfall, incremental, prototype, iterative
 Agile development
 Collaborative software development
 Software Configuration Management (SCM)
 Git as a SCM tool
3 Software Construction Process and Configuration Management
Summary of this lecture
 General process of software construction: Design  Programming 
/refactoring  Debugging  Testing  Build  Release – Programming / refactoring
– Review and static code analysis – Debugging (dumping and logging) and Testing
– Dynamic code analysis /profiling
 Narrow-sense process of software construction (Build): Validate 
Compile  Link  Test  Package  Install  Deploy
– Build system: components and process – Build variants and build language – Build tools: Make, Ant, Maven, Gradle, Eclipse
Software Construction
The end
May 10, 2021
Software Construction
4 Data Type and Type Checking
数据类型与类型检验
Wang Zhongjie
rainy@hit.edu.cn
May 17, 2021
4 Data Type and Type Checking
Objective of this lecture
1. Get to know basic knowledge about data type, and static and 
dynamic type checking in programming language, especially Java. ——静态/动态类型检查
2. Understand mutability and mutable objects ——可变/不变的数据类型
3. Identify aliasing and understand the dangers of mutability ——可变数据类型的危险性
4. Use immutability to improve correctness, clarity and changeability ——不变数据类型的优越性
5. Use snapshot diagram to demonstrate the state of specific time 
during a program’s execution. ——用Snapshot图理解数据类型
6. Use Arrays, Collections and Enum to deal with complex data types ——用集合类表达复杂数据类型
7. Know the harm of Null references and avoid it
4 Data Type and Type Checking
Outline
1. Data type in programming languages
2. Static vs. dynamic data type checking
3. Mutability & Immutability
4. Snapshot diagram
5. Complex data types: Arrays and Collections
6. Useful immutable types
7. Summary
前两章回答了：什么是“高质量的软件”、
如何从不同维度刻画软件、软件构造的基本
过程和步骤
本章：软件构造的理论基础——ADT
软件构造的技术基础——OOP
4 Data Type and Type Checking
Reading
 MIT 6.031：01、08
 CMU 17-214：Oct. 01
 Java编程思想：第1-6章、第11章 for all lectures in Chapter 3
Software Construction
1 Data type in programming 
languages
4 Data Type and Type Checking
Types and Variables
 A type is a set of values, along with operations that can be performed 
on those values. 数据类型
 Examples: – boolean: Truth value (true or false). – int: Integer (0, 1, -47). – double: Real number (3.14, 1.0, -2.1). – String: Text (“hello”, “example”).
 Variables: Named location that stores a value of one particular type – Form: TYPE NAME; – Example: String foo;
变量：用特定数据类型定义，可存储满足类型约束的值
4 Data Type and Type Checking
Types in Java
 Java has several primitive types 基本数据类型, such as: – int (for integers like 5 and -200, but limited to the range ± 2^31, or 
roughly ± 2 billion) – long (for larger integers up to ± 2^63) – boolean (for true or false) – double (for floating-point numbers, which represent a subset of the real 
numbers) – char (for single characters like 'A' and '$' )  Java also has object types 对象数据类型, for example: – String represents a sequence of characters. – BigInteger represents an integer of arbitrary size.
 By Java convention, primitive types are lowercase, while object 
types start with a capital letter.
4 Data Type and Type Checking
Types in Java
Primitives Object Reference Types
int, long, byte, short, char,
float, double, boolean
Classes, interfaces, arrays, enums,
annotations
No identity except their value
只有值，没有ID (与其他值无法区分)
Have identity distinct from value
既有ID，也有值
Immutable 不可变的 Some mutable, some not 可变/不可变
On stack, exist only when in use
在栈中分配内存
On heap, garbage collected
在堆中分配内存
Can’t achieve unity of expression Unity of expression with generics
Dirt cheap 代价低 More costly代价昂贵
4 Data Type and Type Checking
Hierarchy of object types 对象类型形成层次结构
 The root is Object (all non-primitives are objects) – All classes except Object have one parent class, specified with an extends
clause
class Guitar extends Instrument { ... }
 If extends clause omitted, defaults to Object
 A class is an instance of all its superclasses 继承关系 – Inherits visible fields and methods from its superclasses – Can override methods to change their behavior
4 Data Type and Type Checking
Boxed primitives
 Immutable containers for primitive types 
将基本类型包装为对象类型 – Boolean, Integer, Short, Long, Character, Float, Double
 Canonical use case is collections 
通常是在定义集合类型的时候使用它们
 Don‘t use boxed primitives unless you have to! 
一般情况下，尽量避免使用
 Language does autoboxing and auto-unboxing 一般可以自动转换
4 Data Type and Type Checking
Operators
 Operators: symbols that perform simple computations 操作符 – Assignment: = – Addition: + – Subtraction: - – Multiplication: * – Division: /  Order of Operations: follows standard math rules – 1. Parentheses – 2. Multiplication and division – 3. Addition and subtraction
 String concatenation (+) – String text = "hello" + " world"; – text = text + " number " + 5; // text = "hello world number 5"
4 Data Type and Type Checking
Operations
 Operations 操作 are functions that take inputs and produce 
outputs (and sometimes change the values themselves). – As an infix, prefix, or postfix operator. For example, a + b invokes the 
operation + : int × int → int . – As a method of an object. For example, bigint1.add(bigint2) calls the 
operation add: BigInteger × BigInteger → BigInteger . – As a function. For example, Math.sin(theta) calls the operation sin: 
double → double. Here, Math is not an object. It’s the class that contains 
the sin function.
4 Data Type and Type Checking
Overloading operators/operations 重载
 Some operations are overloaded in the sense that the same 
operation name is used for different types 同样的操作名可用于不同
的数据类型
 The arithmetic operators +, -, *, / are heavily overloaded for 
the numeric primitive types in Java. 
 Methods can also be overloaded. Most programming languages 
have some degree of overloading.
 (to be discussed in Section 4 OOP)
Software Construction
2 Static vs. dynamic
data type checking
4 Data Type and Type Checking
Conversion by casting 类型转换
int a = 2; // a = 2 
double a = 2; // a = 2.0 (Implicit) 
int a = (int) 18.7; // a = 18 
double a = (double)2/3; // a = 0.6666…
int a = 18.7; // ERROR 
String a = 1; // ERROR
double a = 2/3; // a = 0.0 
4 Data Type and Type Checking
Static Typing vs. Dynamic Typing
 Java is a statically-typed language. 静态类型语言 – The types of all variables are known at compile time (before the program 
runs), and the compiler can therefore deduce the types of all expressions 
as well. – If a and b are declared as int, then the compiler concludes that a+b is 
also an int . – The Eclipse environment does this while you’re writing the code, in fact, 
so you find out about many errors while you’re still typing. – 在编译阶段进行类型检查
 In dynamically-typed languages like Python, this kind of checking 
is deferred until runtime (while the program is running). 动态类型
语言– 在运行阶段进行类型检查
4 Data Type and Type Checking
Static Checking and Dynamic Checking
 Three kinds of automatic checking that a language can provide: – Static checking: the bug is found automatically before the program even 
runs. 静态类型检查 – Dynamic checking: the bug is found automatically when the code is 
executed. 动态类型检查 – No checking: the language doesn’t help you find the error at all. You have 
to watch for it yourself, or end up with wrong answers. 无检查
 Needless to say, catching a bug statically is better than catching it 
dynamically, and catching it dynamically is better than not 
catching it at all. 静态类型检查 >> 动态 >> 无检查
4 Data Type and Type Checking
Mismatched Types
 Java verifies that types always match: 
 String five = 5; // ERROR! 
test.java.2: incompatible types 
found: int
required: java.lang.String
String five = 5; 
4 Data Type and Type Checking
Static checking
 Static checking means checking for bugs at compile time.  Bugs are the bane毒药 of programming. 
 Static typing prevents a large class of bugs from infecting your 
program: to be precise, bugs caused by applying an operation to 
the wrong types of arguments. 
 If you write a broken line of code like:
"5" * "6"
that tries to multiply two strings, then static typing will catch this 
error while you’re still programming, rather than waiting until the 
line is reached during execution.
静态类型检查：可在编译阶段发现错误，避
免了将错误带入到运行阶段，可提高程序正
确性/健壮性
4 Data Type and Type Checking
Static checking
 Syntax errors 语法错误, like extra punctuation or spurious words. 
Even dynamically-typed languages like Python do this kind of static 
checking. 
 Wrong names 类名/函数名错误, like Math.sine(2) . (The right 
name is sin)  Wrong number of arguments 参数数目错误, like Math.sin(30, 
20) .  Wrong argument types 参数类型错误, like Math.sin("30") .  Wrong return types 返回值类型错误, like return "30"; from a 
function that’s declared to return an int .
4 Data Type and Type Checking
Dynamic checking
 Illegal argument values 非法的参数值. For example, the integer 
expression x/y is only erroneous when y is actually zero; 
otherwise it works. So in this expression, divide-by-zero is not a 
static error, but a dynamic error.
 Unrepresentable return values 非法的返回值, i.e., when the specific 
return value can’t be represented in the type.
 Out-of-range indexes 越界, e.g., using a negative or too-large index 
on a string.
 Calling a method on a null object reference. 空指针
4 Data Type and Type Checking
Static vs. Dynamic Checking
 Static checking tends to be about types, errors that are independent 
of the specific value that a variable has. – Static typing guarantees that a variable will have some value from that set, 
but we don’t know until runtime exactly which value it has. – So if the error would be caused only by certain values, like divide-by-zero 
or index-out-of-range then the compiler won’t raise a static error about it.
 Dynamic checking, by contrast, tends to be about errors caused by 
specific values.
静态检查：关于“类型”的检查，不考虑值
动态检查：关于“值”的检查
4 Data Type and Type Checking
Classroom Exercises
int n = 5;
if (n) {
n = n + 1;
}
int big = 200000; 
big = big * big; 
double probability = 1/5;
int sum = 0;
int n = 0;
int average = sum/n;
double sum = 7;
double n = 0;
double average = sum/n;
Static error
Dynamic error
No error, but 
wrong answer
Type mismatch: 
cannot convert 
from int to 
boolean
0.0
Exception in 
thread "main" 
java.lang.Arith
meticException: 
/ by zero
Infinity
1345294336
Software Construction
3 Mutability and Immutability
4 Data Type and Type Checking
Assignment 赋值
 Use “=” to give variables a value
 Example: – String foo; – foo = “IAP 6.092”;
 Assignment can be combined with a variable declaration
 Example: – double badPi = 3.14; – boolean isJanuary = true;
4 Data Type and Type Checking
Changing a variable or its value
 What’s the distinction between changing a variable and changing a 
value? 改变一个变量、改变一个变量的值，二者有何区别？ – When you assign to a variable, you’re changing where the variable’s 
arrow points. You can point it to a different value. 改变一个变量：将该变
量指向另一个值的存储空间 – When you assign to the contents of a mutable value – such as an array or 
list – you’re changing references inside that value. 改变一个变量的值：将
该变量当前指向的值的存储空间中写入一个新的值。
 Change is a necessary evil. 变化是“罪恶”，但程序不能没有变化
 Good programmers avoid things that change, because they may 
change unexpectedly. 尽可能避免变化，以避免副作用
4 Data Type and Type Checking
Immutability 不变性
 Immutability is a major design principle. 不变性：重要设计原则
 Immutable types are types whose values can never change once 
they have been created. 不变数据类型：一旦被创建，其值不能改变
 Java also gives us immutable references: variables that are 
assigned once and never reassigned. 如果是引用类型，也可以是不
变的：一旦确定其指向的对象，不能再被改变 – To make a reference immutable, declare it with the keyword final
final int n = 5;
final Person a = new Person(“Ross”);
 If the Java compiler isn’t convinced that your final variable will 
only be assigned once at runtime, then it will produce a compiler 
error. So final gives you static checking for immutable references.
如果编译器无法确定final变量不会改变，就提示错误，这也是静态
类型检查的一部分。
4 Data Type and Type Checking
Immutability
 It’s good practice to use final for declaring the parameters of a 
method and as many local variables as possible. 所以，尽量使用
final变量作为方法的输入参数、作为局部变量。
 Like the type of the variable, these declarations are important 
documentation, useful to the reader of the code and statically 
checked by the compiler. final表明了程序员的一种“设计决策”
 Note: – A final class declaration means it cannot be inherited. final类无法派生
子类 – A final variable means it always contains the same value/reference but 
cannot be changed final变量无法改变值/引用 – A final method means it cannot be overridden by subclasses final方法
无法被子类重写
4 Data Type and Type Checking
Mutability and Immutability
 Objects are immutable: once created, they always represent the 
same value. 
 Objects are mutable: they have methods that change the value of the 
object. 
不变对象：一旦被创建，始终指向同一个值/引用
可变对象：拥有方法可以修改自己的值/引用
4 Data Type and Type Checking
String as an immutable type
 String is an example of an immutable type. 
 A String object always represents the same string. 
 Since String is immutable, once created, a String object always 
has the same value. 
 To add something to the end of a String, you have to create a new 
String object:
Note: this is a snapshot diagram
4 Data Type and Type Checking
StringBuilder as a mutable type
 StringBuilder is an example of a mutable type. 
 It has methods to delete parts of the string, insert or replace 
characters, etc.
 This class has methods that change the value of the object, rather 
than just returning new values:
4 Data Type and Type Checking
Mutability and Immutability
 So what? In both cases, you end up with s and sb referring to the 
string of characters “ab”. 有区别吗？最终的值都是一样的 – The difference between mutability and immutability doesn’t matter much 
when there’s only one reference to the object. 当只有一个引用指向该值，
没有区别
 But there are big differences in how they behave when there are 
other references to the object. 有多个引用的时候，差异就出现了 – When another variable t points to the same String object as s, and 
another variable tb points to the same StringBuilder as sb , then the 
differences between the immutable and mutable objects become more 
evident.
4 Data Type and Type Checking
Advantage of mutable types
 Using immutable strings, this makes a lot of temporary copies 使用
不可变类型，对其频繁修改会产生大量的临时拷贝(需要垃圾回收) – The first number ( "0" ) is actually copied n times in the course of building 
up the final string, the second number is copied n-1 times, and so on. – It actually costs O(n2
) time just to do all that copying, even though we only 
concatenated n elements.
 StringBuilder is designed to minimize this copying. 可变类型最
少化拷贝以提高效率 – It uses a simple but clever internal data structure to avoid doing any 
copying at all until the very end, when you ask for the final String with 
a toString() call.
4 Data Type and Type Checking
Advantage of mutable types
 Getting good performance is one reason why we use mutable 
objects. 使用可变数据类型，可获得更好的性能
 Another is convenient sharing: two parts of your program can 
communicate more conveniently by sharing a common mutable data 
structure. 也适合于在多个模块之间共享数据
 “Global variables”
 But you must have known the disadvantages of global variables…
4 Data Type and Type Checking
Exercise
String s = " Hello ";
s += " World ";
s.trim( );
System.out.println(s);
What will be the output of the following code snippet?
See the specification of String.trim():
Returns:
A copy of this string with leading and trailing 
white space removed, or this string if it has no 
leading or trailing white space.
3 String objects are created, and 2 of them 
become unreachable as there are no references 
to them, and gets garbage collected.
StringBuilder sb = new StringBuilder(" Hello ");
sb.append(" World ");
System.out.println(sb.toString().trim( ));
4 Data Type and Type Checking
Risks of mutation
 Since mutable types seem much more powerful than immutable 
types, why on earth would you choose the immutable one? 既然如
此，为何还要用不可变类型？ – StringBuilder should be able to do everything that String can do, plus 
set() and append() and everything else.
 The answer is that immutable types are safer from bugs, easier to 
understand, and more ready for change. 不可变类型更“安全”，
在其他质量指标上表现更好 – Mutability makes it harder to understand what your program is doing, 
and much harder to enforce contracts. 
 Tradeoff between performance and safety? 折中，看你看重哪个质
量指标
4 Data Type and Type Checking
Risky example #1: passing mutable values
Mutating the list directly for 
better performance
一个计算数组中元
素之和的函数
But, what will happen here?
4 Data Type and Type Checking
Risk
 Safe from bugs? – In this example, it’s easy to blame the implementer of sumAbsolute() for 
going beyond what its spec allowed. 该函数超出了spec范畴，因为它改变
了输入参数的值！ – But really, passing mutable objects around is a latent bug. It’s just waiting 
for some programmer to inadvertently mutate that list, often with very 
good intentions like reuse or performance, but resulting in a bug that may 
be very hard to track down. 这种错误非常难于跟踪和发现
 Easy to understand? – When reading main() , what would you assume about sum() and 
sumAbsolute() ? – Is it clearly visible to the reader that myData gets changed by one of them? – 对其他程序员来说，也难以理解
4 Data Type and Type Checking
Risky example #2: returning mutable values
 Date as a built-in Java class, is a mutable type.
通过全局变量作为
cache
What will happen here?
4 Data Type and Type Checking
Risk
 In both of these examples — the 
List<Integer> and the Date — the 
problems would have been 
completely avoided if the list and 
the date had been immutable types. 
 The bugs would have been 
impossible by design.
 You should never use Date ! – Use one of the classes from package 
java.time : LocalDateTime , Instant , 
etc. – All guarantee in their specifications that 
they are immutable .
4 Data Type and Type Checking
How to modify the code?
 In Example 1: – To return a new copy of the object (defensive copying), i.e., 
return new Date(groundhogAnswer.getTime());
通过防御式拷贝，给客户端返回一个全新的Date对象 – However, use extra space for every client — even if 99% of the clients never 
mutate the date it returns. We may end up with lots of copies of the first 
day of spring throughout memory. 大部分时候该拷贝不会被客户端修改，
可能造成大量的内存浪费
 If we used an immutable type instead, then different parts of the 
program could safely share the same values in memory, so less 
copying and less memory space is required. 如果使用不可变类型，
则节省了频繁复制的代价
 Immutability can be more efficient than mutability, because 
immutable types never need to be defensively copied.
4 Data Type and Type Checking
Aliasing is what makes mutable types risky
 Using mutable objects is just fine if you are using them entirely 
locally within a method, and with only one reference to the object. 安
全的使用可变类型：局部变量，不会涉及共享；只有一个引用
 What led to the problem in the two examples we just looked at was 
having multiple references, also called aliases, for the same mutable 
object. 如果有多个引用（别名），使用可变类型就非常不安全 – In the List example, the same list is pointed to by both list (in sum and 
sumAbsolute) and myData (in main). One programmer ( sumAbsolute ’s) 
thinks it’s ok to modify the list; another programmer ( main ’s) wants the 
list to stay the same. Because of the aliases, main ’s programmer loses. – In the Date example, there are two variable names that point to the Date
object, groundhogAnswer and partyDate . These aliases are in completely 
different parts of the code, under the control of different programmers 
who may have no idea what the other is doing.
4 Data Type and Type Checking
More Examples of Defensive Copying
4 Data Type and Type Checking
More Examples of Defensive Copying
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
p.end().setYear(78); // Modifies internals of p!
Software Construction
4 Snapshot diagram 
as a code-level, run-time, and 
moment view
4 Data Type and Type Checking
Software construction: transformation btw views
Build-time
Run-time
Moment Period
Moment
Period
Code
Component
Code
Churn
CI and 
Version
Code 
Snapshot
Physical 
Architecture
Call 
Graph
Thread and 
Process
programming
design, build
build
install
deploy
refactoring
Version Control
evolution
deploy
review, static analysis
debug
testing
profiling, dumping
logging
execute
4 Data Type and Type Checking
Snapshot diagrams
 It will be useful for us to draw pictures of what’s happening at 
runtime, in order to understand subtle questions.
 Snapshot diagrams represent the internal state of a program at 
runtime – its stack (methods in progress and their local variables) and 
its heap (objects that currently exist). 用于描述程序运行时的内部状态
 Why we use snapshot diagrams? – To talk to each other through pictures. 便于程序员之间的交流 – To illustrate concepts like primitive types vs. object types, immutable 
values vs. immutable references, pointer aliasing, stack vs. heap, 
abstractions vs. concrete representations. 便于刻画各类变量随时间变化 – To help explain your design for your team project (with each other and 
with your TA). 便于解释设计思路 – To pave the way for richer design notations in subsequent courses. 
4 Data Type and Type Checking
Primitive and Object values in Snapshot Diagram
 Primitive values 基本类型的值 – Primitive values are represented by bare constants. The incoming arrow is 
a reference to the value from a variable or an object field.
 Object values 对象类型的值 – An object value is a circle labeled by its type. – When we want to show more detail, we write field names inside it, with 
arrows pointing out to their values. For still more detail, the fields can 
include their declared types. 
4 Data Type and Type Checking
Reassignment and immutable values
 For example, if we have a String variable s , we can reassign it 
from a value of "a" to "ab"
String s = "a";
s = s + "b";
 String is an example of an immutable type, a type whose values 
can never change once they have been created. 
 Immutable objects (intended by their designer to always represent 
the same value) are denoted in a snapshot diagram by a double 
border, like the String objects in our diagram. 不可变对象：用双线
椭圆
4 Data Type and Type Checking
Mutable values
 By contrast, StringBuilder (a built-in Java class) is a mutable 
object that represents a string of characters, and it has methods that 
change the value of the object:
StringBuilder sb = new StringBuilder("a");
sb.append("b");
 These two snapshot diagrams look very different, which is good: 
the difference between mutability and immutability will play an 
important role in making code safe from bugs .
4 Data Type and Type Checking
Unreassignable/Immutable references
 Java also gives us immutable references 不可变的引用: variables 
that are assigned once and never reassigned. To make a reference 
immutable, declare it with the keyword final:
final int n = 5;
 If the Java compiler isn’t convinced that your final variable will 
only be assigned once at runtime, then it will produce a compiler 
error. So final gives a static checking for immutable references.
 In a snapshot diagram, an unreassignable reference (final) is 
denoted by a double arrow. 
4 Data Type and Type Checking
Unreassignable/Immutable references
 An object whose id never changes (it can’t be reassigned to a 
different number), but whose age can change. 不可变的引用：用双
线箭头
 An immutable/unreassignable reference to a mutable value (for 
example: final StringBuilder sb) whose value can change even 
though we’re pointing to the same object. 引用是不可变的，但指向
的值却可以是可变的
 A mutable/reassignable reference to an immutable value (like 
String s), where the value of the variable can change because it 
can be re-pointed to a different object. 可变的引用，也可指向不可
变的值
4 Data Type and Type Checking
Exercises
 We can have an immutable reference to a mutable value (for 
example: final StringBuilder sb) whose value can change even 
though we’re pointing to the same object.
final StringBuilder sb = new StringBuilder("abc");
sb.append("d");
sb = new StringBuilder("e");
System.out.println(sb);
What will happen?
Can you draw the snapshot diagram?
编译阶段出错：The final 
variable sb cannot be assigned
输出：abcd
sb
StringBuilder
“abc” “abcd”
StringBuilder
“abcd” “e”
4 Data Type and Type Checking
Exercises
 We can also have a mutable reference to an immutable value (like 
String s), where the value of the variable can change because it 
can be re-pointed to a different object.
String s1 = new String("abc");
List<String> list = new ArrayList<String>();
list.add(s1);
s1 = s1.concat("d");
System.out.println(list.get(0));
String s2 = s1.concat("e");
list.set(0, s2);
System.out.println(list.get(0));
What will happen?
Can you draw the snapshot diagram?
输出：abc
输出：abcde
4 Data Type and Type Checking String s1 = new String("abc");
List<String> list = new ArrayList<String>();
list.add(s1);
s1 = s1.concat("d");
System.out.println(list.get(0));
String s2 = s1.concat("e");
list.set(0, s2);
System.out.println(list.get(0));
输出：abc
输出：abcde
String
“abc” 
“abcd”
s1
String
“abc”
list
ArrayList<String>
0
String
“abc” 
“abcd”
String
“abcd”
String
“abc” 
“abcd”
String
“abcde”
s2 Unreachable objects
等待垃圾回收(GC)
Software Construction
5 Complex data types: Arrays and 
Collections
4 Data Type and Type Checking
Array
 Arrays are fixed-length sequences of another type T. For example, 
here’s how to declare an array variable and construct an array value 
to assign to it:
int[] a = new int[100];
 The int[] array type includes all possible array 
values, but a particular array value, once created, 
can never change its length. 
 Operations on array types include: – indexing: a[2] – assignment: a[2]=0 – length: a.length
int[] a = new int[100];
int i = 0; 
int n = 3; 
while (n != 1) { 
a[i] = n; 
i++; 
if (n % 2 == 0) { 
n = n / 2; 
} 
else { 
n = 3 * n + 1; 
} 
} 
a[i] = n; 
i++;
Why 100?
4 Data Type and Type Checking
List
 Lists are variable-length sequences of another type T . List<Integer> list = new ArrayList<Integer>();
 Some of its operations: – indexing: list.get(2) – assignment: list.set(2, 0) – length: list.size()
 Note 1: List is an interface.
 Note 2: members in a List
must be an object.
String[] names;
int[] numbers;
char[][] grid;
Please use List rather than arrays
4 Data Type and Type Checking
Iterating
 Iterating an array
int max = 0;
for (int i=0; i<array.length; i++) {
max = Math.max(array[i], max);
}  Iterating a List
int max = 0;
for (int x : list) {
max = Math.max(x, max);
}
4 Data Type and Type Checking
Set
 A Set is an unordered collection of zero or more unique objects. 
 An object cannot appear in a set multiple times. Either it’s in or it’s 
out. – s1.contains(e) test if the set contains an element – s1.containsAll(s2)test whether s1 s2 – s1.removeAll(s2) remove s2 from s1
 Set is an abstract interface
4 Data Type and Type Checking
Map
 A Map is similar to a dictionary (key-value) – map.put(key, val) add the mapping key → val – map.get(key) get the value for a key – map.containsKey(key) test whether the map has a key – map.remove(key) delete a mapping
 Map is an abstract interface
4 Data Type and Type Checking
Declaring List, Set, and Map variables
 With Java collections we can restrict the type of objects contained 
in the collection. 
 When we add an item, the compiler can perform static checking to 
ensure we only add items of the appropriate type. 
 Then, when we pull out an item, we are guaranteed that its type 
will be what we expect.
4 Data Type and Type Checking
Declaring List, Set, and Map variables
 Declaration:
List<String> cities; // a List of Strings
Set<Integer> numbers; // a Set of Integers
Map<String, Turtle> turtles; // a Map with String keys and Turtle values
 We cannot create a collection of primitive types. – For example, Set<int> does not work. – However, int have an Integer wrapper we can use (e.g. Set<Integer> 
numbers). – When using:
sequence.add(5); // add 5 to the sequence
int second = sequence.get(1); // get the second element
4 Data Type and Type Checking
Creating List, Set, and Map variables 
 Java helps distinguish between – the specification of a type – what does it do? Abstract Interface – The implementation – what is the code? Concrete Class
 List , Set , and Map are all interfaces: – They define how these respective types work, but they don’t provide 
implementation code. – Advantage: users have the right to choose different implementations in 
different situations.
 Implementations of List , Set , 
and Map : – List: ArrayList and LinkedList – Set: HashSet – Map: HashMap
List<String> firstNames = new ArrayList<String>();
List<String> lastNames = new LinkedList<String>();
List<String> firstNames = new ArrayList<>();
List<String> lastNames = new LinkedList<>();
Set<Integer> numbers = new HashSet<>();
Map<String,Turtle> turtles = new HashMap<>();
4 Data Type and Type Checking
Using List, Set, and Map variables 
Map<String, Double> treasures = new HashMap<>();
String x = "palm";
treasures.put("beach", 25.);
treasures.put("palm", 50.);
treasures.put("cove", 75.);
treasures.put("x", 100.);
treasures.put("palm", treasures.get("palm") + treasures.size());
treasures.remove("beach");
double found = 0;
for (double treasure : treasures.values()) {
found += treasure;
}
treasures.get(x)
treasures.get("x")
found
4 Data Type and Type Checking
Using List, Set, and Map variables 
treasures.get(x)
treasures.get("x")
found
4 Data Type and Type Checking
Iteration
List<String> cities = new ArrayList<>();
Set<Integer> numbers = new HashSet<>();
Map<String,Turtle> turtles = new HashMap<>();
for (String city : cities) {
System.out.println(city);
}
for (int num : numbers) {
System.out.println(num);
}
for (int ii = 0; ii < cities.size(); ii++) {
System.out.println(cities.get(ii));
}
for (String key : turtles.keySet()) {
System.out.println(key + ": " + turtles.get(key));
}
4 Data Type and Type Checking
Iterator as a mutable type 迭代器
 Iterator is an object that steps through a collection of elements 
and returns the elements one by one. 
 Iterators are used under the covers in Java when you’re using a 
for (... : ...) loop to step through a List or array. 
 An iterator has two methods: – next() returns the next element in the collection --- this is a mutator
method! – hasNext() tests whether the iterator has reached the end of the collection.
4 Data Type and Type Checking
An example iterator for ArrayList<String>
Class 
definition
Instance 
variables
Invariants
Specification
Constructor
Instance 
method
改变了index的取值
故该类是mutable的
4 Data Type and Type Checking
Snapshot diagram of MyIterator
为何是双线？
list被final修饰
4 Data Type and Type Checking
Mutation undermines (暗中破坏) an iterator
 Suppose we have a list of subjects represented as strings. We want 
a method dropCourse6 that will delete the Course 6 subjects from 
the list, leaving the other subjects behind.
 First write the specification (to be introduced in next lecture)
 Next, write the test cases
4 Data Type and Type Checking
Mutation undermines an iterator
 The implementation:
 Run it
Why?
Draw the snapshot
and analysis…
4 Data Type and Type Checking
Mutation undermines an iterator
MyIterator
list
index
ArrayList<String>
0 1 2
subjects
“6.045” “6.005” “6.813”
iter
0
MyIterator
list
index
ArrayList<String>
0 1 2
subjects
“6.045” “6.005” “6.813”
iter
1
4 Data Type and Type Checking
Mutation undermines an iterator
MyIterator
list
index
ArrayList<String>
0 1 2
subjects
“6.045” “6.005” “6.813”
iter
1
MyIterator
list
index
ArrayList<String>
0 1 2
subjects
“6.045” “6.005” “6.813”
iter
1
4 Data Type and Type Checking
Mutation undermines an iterator
 How about this code?
 Try this:
The iterator adjusts its index appropriately.
Software Construction
6 Useful immutable types
4 Data Type and Type Checking
Useful immutable types
 The primitive types and primitive wrappers are all immutable. 基
本类型及其封装对象类型都是不可变的 – If you need to compute with large numbers, BigInteger and BigDecimal
are immutable.
 Don’t use mutable Date, use the appropriate immutable type from 
java.time based on the granularity of timekeeping you need.
 The usual implementations of Java’s collections types — List, Set, 
Map — are all mutable: ArrayList, HashMap, etc. 
 The Collections utility class has methods for obtaining 
unmodifiable views of these mutable collections: – Collections.unmodifiableList – Collections.unmodifiableSet – Collections.unmodifiableMap
a wrapper around the underlying 
list/set/map
4 Data Type and Type Checking
Immutable Wrappers around Mutable Data Types
 The Java collections classes offer an interesting compromise: 
immutable wrappers. 这种包装器得到的结果是不可变的：只能看 – Collections.unmodifiableList() takes a (mutable) List and wraps it 
with an object that looks like a List , but whose mutators are disabled –
set() , add() , remove() , etc. throw exceptions. So you can construct a 
list using mutators, then seal it up in an unmodifiable wrapper (and throw 
away your reference to the original mutable list, and get an immutable list.
 The downside is that you get immutability at runtime, but not at 
compile time. 但是这种“不可变”是在运行阶段获得的，编译阶段
无法据此进行静态检查 – Java won’t warn you at compile time if you try to sort() this 
unmodifiable list. – You’ll just get an exception at runtime. – But that’s still better than nothing, so using unmodifiable lists, maps, and 
sets can be a very good way to reduce the risk of bugs.
4 Data Type and Type Checking
Unmodifiable Wrappers
List<String> list = new ArrayList<>();
list.add("ab");
List<String> listCopy = Collections.unmodifiableList(list);
listCopy.add("c");
list.add("c");
System.out.println(listCopy.size());
What will happen?
Exception in thread "main" java.lang.UnsupportedOperationException
at java.util.Collections$UnmodifiableCollection.add(Collections.java:1055)
at Immutable.main(Immutable.java:33) 2
4 Data Type and Type Checking
What will happen?
public class Zoo {
private List<String> animals;
public Zoo(List<String> animals) {
this.animals = animals;
}
public List<String> getAnimals() {
return this.animals;
} }
What is the output from this code?
List<String> a = new ArrayList<>();
a.addAll(Arrays.asList("lion", "tiger", "bear"));
Zoo zoo = new Zoo(a);
a.add("zebra");
System.out.println(a);
System.out.println(zoo.getAnimals());
List<String> b = zoo.getAnimals();
b.add("flamingo");
System.out.println(a);
4 Data Type and Type Checking
Unmodifiable Wrappers
 The unmodifiable wrappers take away the ability to modify the 
collection by intercepting all the operations that would modify the 
collection and throwing an UnsupportedOperationException.  Unmodifiable wrappers have two main uses, as follows: – To make a collection immutable once it has been built. In this case, it's 
good practice not to maintain a reference to the backing collection. This 
absolutely guarantees immutability. – To allow certain clients read-only access to your data structures. You keep 
a reference to the backing collection but hand out a reference to the 
wrapper. In this way, clients can look but not modify, while you maintain 
full access.
4 Data Type and Type Checking
Unmodifiable Wrappers
 public static <T> Collection<T> 
unmodifiableCollection(Collection<? extends T> c);
 public static <T> Set<T> unmodifiableSet(Set<? extends T> s);
 public static <T> List<T> unmodifiableList(List<? extends T> 
list);
 public static <K,V> Map<K, V> unmodifiableMap(Map<? extends K, 
? extends V> m);
 public static <T> SortedSet<T> 
unmodifiableSortedSet(SortedSet<? extends T> s);
 public static <K,V> SortedMap<K, V> 
unmodifiableSortedMap(SortedMap<K, ? extends V> m);
4 Data Type and Type Checking
Static methods for unmodifiable collections
 To create immutable collections from some known values, use 
List.of, Set.of, and Map.of. List<String> a = List.of("lion", "tiger", "bear");
 Alternatively, use List.copyOf (Java 10) to create unmodifiable 
shallow copies of mutable collections.
Software Construction
Summary
4 Data Type and Type Checking
Summary of this lecture
 Static type checking: – Safe from bugs. Static checking helps with safety by catching type errors 
and other bugs before runtime. – Easy to understand. It helps with understanding, because types are 
explicitly stated in the code. – Ready for change. Static checking makes it easier to change your code by 
identifying other places that need to change in tandem. For example, 
when you change the name or type of a variable, the compiler 
immediately displays errors at all the places where that variable is used, 
reminding you to update them as well.
4 Data Type and Type Checking
Summary
 Mutability is useful for performance and convenience, but it also 
creates risks of bugs by requiring the code that uses the objects to be 
well-behaved on a global level, greatly complicating the reasoning 
and testing we have to do to be confident in its correctness.  Make sure you understand the difference between an immutable
object (like a String ) and an immutable reference (like a final
variable). 
 Snapshot diagrams can help with this understanding. – Objects are values, represented by circles in a snapshot diagram, and an 
immutable one has a double border indicating that it never changes its 
value. – A reference is a pointer to an object, represented by an arrow in the 
snapshot diagram, and an immutable reference is an arrow with a double 
line, indicating that the arrow can’t be moved to point to a different object.
4 Data Type and Type Checking
Summary
 The key design principle is immutability: using immutable objects 
and immutable references as much as possible. – Safe from bugs. Immutable objects aren’t susceptible to bugs caused by 
aliasing. Immutable references always point to the same object. – Easy to understand. Because an immutable object or reference always 
means the same thing, it’s simpler for a reader of the code to reason about 
— they don’t have to trace through all the code to find all the places where 
the object or reference might be changed, because it can’t be changed. – Ready for change. If an object or reference can’t be changed at runtime, 
then code that depends on that object or reference won’t have to be 
revised when the program changes.
Software Construction
The end
May 17, 2021Software Construction
5 Designing Specification
设计规约
Wang Zhongjie
rainy@hit.edu.cn
May 17, 2021
5 Designing Specification
Objective of this lecture
 Understand preconditions and postconditions in method 
specifications, and be able to write correct specifications (方法的规
约)  What preconditions and postconditions are, and what they mean 
for the implementor and the client of a method (前置/后置条件)  Understand underdetermined specs, and be able to identify and 
assess nondeterminism (欠定规约、非确定规约)  Understand declarative vs. operational specs, and be able to write 
declarative specs (陈述式、操作式规约)  Understand strength of preconditions, postconditions, and specs; 
and be able to compare spec strength (规约的强度及其比较)  Be able to write coherent, useful specifications of appropriate 
strength (如何写出好的规约)
5 Designing Specification
Outline
1. Function / method in programming language
2. Specification: Programming for communication
Why specification is needed
Behavioral equivalence
Specification structure: pre-condition and post-condition
Testing and verifying specifications
3. Designing specifications
Classifying specifications
Diagramming specifications
Quality of a specification
4. Summary
上一节关注了编程语言中的“数据类型”、
“变量”、“值”，尤其是mutable和
immutable的类型/值/引用
本节转向“方法/函数/操作”如何定义——
编程中的“动词”、规约
5 Designing Specification
Reading
 MIT 6.031：06、07
 CMU 17-214：Sep 05
Software Construction
1 Functions & methods in 
programming languages
5 Designing Specification
Method
public static void threeLines() {
STATEMENTS;
}
public static void main(String[] arguments){ 
System.out.println("Line 1"); 
threeLines(); 
System.out.println("Line 2"); 
} 
5 Designing Specification
Parameters
[…] NAME (TYPE NAME, TYPE NAME) { 
STATEMENTS 
} 
To call: 
NAME(arg1, arg2); 
 Attention: parameter type mismatch when calling a method – static 
checking 参数类型是否匹配，在静态类型检查阶段完成
5 Designing Specification
Return Values
public static TYPE NAME() { 
STATEMENTS; 
return EXPRESSION; 
}
void means “no type”
返回值类型是否匹配，也在静态类型检查阶段完成
5 Designing Specification
Variable Scope 变量的作用域
class SquareChange { 
public static void printSquare(int x){ 
System.out.println("printSquare x = " + x); 
x = x * x; 
System.out.println("printSquare x = " + x); 
} 
public static void main(String[] arguments){ 
int x = 5; 
System.out.println("main x = " + x); 
printSquare(x); 
System.out.println("main x = " + x); 
} 
} 55
25
5
Immutable
5 Designing Specification
Methods: Building Blocks
 Big programs are built out of small methods
 Methods can be individually developed, tested and reused 
 User of method does not need to know how it works --- this is 
called “abstraction” 
“方法”是程序的“积木”，可以被独立开发、测试、复用
使用“方法”的客户端，无需了解方法内部具体如何工作—“抽象”
5 Designing Specification
A complete method
public class Hailstone {
/**
* Compute a hailstone sequence.
* @param n Starting number for sequence. Assumes n > 0.
* @return hailstone sequence starting with n and ending with 1.
*/
public static List<Integer> hailstoneSequence(int n) {
List<Integer> list = new ArrayList<Integer>();
while (n != 1) {
list.add(n);
if (n % 2 == 0) {
n = n / 2;
} else {
n = 3 * n + 1;
} }
list.add(n);
return list;
} }
方法的规约spec
方法的实现体implementation
Software Construction
2 Specification: Programming for 
communication
Software Construction
(1) Documenting in programming
5 Designing Specification
Java API documentation: an example
5 Designing Specification
Java API documentation: an example
5 Designing Specification
Java API documentation: an example
 Class hierarchy and a list of implemented interfaces.
 Direct subclasses, and for an interface, implementing classes.
 A description of the class
 Constructor summary
 Method summary lists all the methods we can call
 Detailed descriptions of each method and constructor – The method signature: we see the return type, the method name, and the 
parameters. We also see exceptions. For now, those usually mean errors the 
method can run into. – The full description. – Parameters: descriptions of the method arguments. – And a description of what the method returns.
5 Designing Specification
Documenting Assumptions 
 Writing the type of a variable down documents an assumption 
about it: e.g., this variable will always refer to an integer. 变量的数
据类型定义 – Java actually checks this assumption at compile time, and guarantees that 
there’s no place in your program where you violated this assumption.
 Declaring a variable final is also a form of documentation, a claim 
that the variable will never change after its initial assignment. 
final关键字定义了设计决策：“不可改变” – Java checks that too, statically.
 How about the assumptions of functions / methods?
 代码本身就蕴含着你的设计决策，但是远远不够
5 Designing Specification
Programming for communication
 Why do we need to write down our assumptions? – Because programming is full of them, and if we don’t write them down, 
we won’t remember them, and other people who need to read or change 
our programs later won’t know them. They’ll have to guess. – 为什么要写出“假设”？第一：自己记不住；第二：别人不懂。
 Programs have to be written with two goals in mind: – Communicating with the computer. First persuading the compiler that 
your program is sensible – syntactically correct and type-correct. Then 
getting the logic right so that it gives the right results at runtime. 代码中蕴
含的“设计决策”：给编译器读 – Communicating with other people. Making the program easy to 
understand, so that when somebody has to fix it, improve it, or adapt it in 
the future, they can do so. 注释形式的“设计决策”：给自己和别人读
Software Construction
(2) Specification and Contract 
(of a method)
5 Designing Specification
Specifications (or called Contract)
 Specifications are the linchpin 关键 of teamwork. It’s impossible to 
delegate responsibility for implementing a method without a 
specification. 没规约，没法写程序；即使写出来，也不知道对错
 The specification acts as a contract 契约: the implementer is 
responsible for meeting the contract, and a client that uses the 
method can rely on the contract. 程序与客户端之间达成的一致 – States method’s and caller’s responsibilities – Defines what it means for implementation to be correct
 Specifications place demands on both parties: when the 
specification has a precondition, the client has responsibilities too. 
Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守 – If you pay me this amount on this schedule…
– I will build a with the following detailed specification
– Some contracts have remedies for nonperformance
5 Designing Specification
Why specifications?
 Reality: – Many of the nastiest bugs in programs arise because of misunderstandings 
about behavior at the interface between two pieces of code. 很多bug来自于
双方之间的误解 – Although every programmer has specifications in mind, not all 
programmers write them down. As a result, different programmers on a 
team have different specifications in mind. 不写下来，那么不同开发者的理
解就可能不同 – When the program fails, it’s hard to determine where the error is. 没有规
约，难以定位错误
 Advantages: – Precise specifications in the code let you apportion blame to code 
fragments, and can spare you the agony of puzzling over where a fix 
should go. 精确的规约，有助于区分责任 – Specifications are good for the client of a method because they spare the 
task of reading code. 客户端无需阅读调用函数的代码，只需理解spec即可
5 Designing Specification
An example of specification
 A method add() of a Java class BigInteger
5 Designing Specification
Specification (contract)
 Specifications are good for the implementer of a method because 
they give the implementor freedom to change the implementation 
without telling clients. 规约可以隔离“变化”，无需通知客户端
 Specifications can make code faster, too. 规约也可以提高代码效率
 The contract acts as a firewall between client and 
implementor. 规约：扮演“防火墙”角色 – It shields the client from the details of the workings 
of the unit. – It shields the implementor from the details of the
usage of the unit. – This firewall results in decoupling, allowing the code 
of the unit and the code of a client to be changed 
independently, so long as the changes respect the 
specification. – 解耦，不需了解具体实现
5 Designing Specification
Specification (contract)
 Agreement between an object and its user – Method signature (type specifications) 输入/输出的数据类型 – Functionality and correctness expectations 功能和正确性 – Performance expectations 性能
 What the method does, not how it does it 只讲“能做什么”，不讲
“怎么实现” – Interface (API), not implementation
Software Construction
(3) Behavioral equivalence
5 Designing Specification
Behavioral equivalence (行为等价性)  To determine behavioral equivalence , the question is whether we 
could substitute one implementation for the other (是否可相互替换).  The notion of equivalence is in the eye of the 
client (站在客户端视角看行为等价性). 
这两个函数是否等价？
行为不同，但对用户来说
“是否等价”？
When val is missing, 
findFirst returns the 
length of arr and 
findLast returns -1;
When val appears 
twice, findFirst
returns the lower index 
and findLast returns 
the higher.
5 Designing Specification
Behavioral equivalence (行为等价性)  To determine behavioral equivalence , the question is whether we 
could substitute one implementation for the other (是否可相互替换).  The notion of equivalence is in the eye of the 
client (站在客户端视角看行为等价性). 
这两个函数是否等价？
行为不同，但对用户来说
“是否等价”？
But when val occurs at exactly 
one index of the array, the two 
methods behave the same. 
Whenever they call the 
method, they will be passing in 
an arr with exactly one 
element val. For such clients, these two 
methods are the same.
5 Designing Specification
Behavioral equivalence
 In order to make it possible to substitute one implementation for 
another, and to know when this is acceptable, we need a 
specification that states exactly what the client depends on 根据规约
判断是否行为等价
这两个函数符合这个规约，故它们等价。
5 Designing Specification
Classroom Exercises
Suppose clients only care about 
calling the find method when they 
know val occurs exactly once in a. In this case, are findFirst and 
findLast behaviorally equivalent?
Suppose clients only care that the find method should return:
• any index i such that a[i] == val, if val is in a • any integer j such that j is not a valid array index, otherwise
In this case, are findFirst and findLast behaviorally equivalent?
5 Designing Specification
Short summary
单纯的看实现代码，并
不足以判定不同的
implmentation是否是
“行为等价的”
需要根据代码的spec
（开发者与client之间
形成的contract）判定
行为等价性
在编写代码之前，需要
弄清楚spec如何协商形
成、如何撰写
Software Construction
(4) Specification structure: 
pre-condition and post-condition
5 Designing Specification
Specification Structure
 A specification of a method consists of several clauses: – Precondition , indicated by the keyword requires – Postcondition , indicated by the keyword effects – Exceptional behavior: what it does if precondition violated
 The precondition is an obligation on the client (i.e., the caller of the 
method). It’s a condition over the state in which the method is 
invoked. 前置条件：对客户端的约束，在使用方法时必须满足的条件
 The postcondition is an obligation on the implementer of the 
method. 后置条件：对开发者的约束，方法结束时必须满足的条件
 If the precondition holds for the invoking state, the method is 
obliged to obey the postcondition, by returning appropriate values, 
throwing specified exceptions, modifying or not modifying objects, 
and so on. 契约：如果前置条件满足了，后置条件必须满足
5 Designing Specification
Specification Structure
 The overall structure is a logical 
implication: if the precondition holds when 
the method is called, then the postcondition
must hold when the method completes. 前置
条件满足，则后置条件必须满足。
 If the precondition does not hold when the 
method is called, the implementation 
is not bound by the postcondition. – It is free to do anything, including not 
terminating, throwing an exception, returning 
arbitrary results, making arbitrary 
modifications, etc. – 前置条件不满足，则方法可做任何事情。 – “你违约在先，我自然不遵守承诺”
5 Designing Specification
Classroom Exercises
As the implementer of find, which are legal?
• if arr is empty, return 0 • if arr is empty, throw an exception
• if val occurs twice in arr, throw an exception
• if val occurs twice in arr, set all the values in arr to 0, then throw an 
exception
• if arr is not empty but val doesn’t occur, pick an index at random, 
set it to val, and return that index
• if arr[0] is val, continue checking the rest of the array and return the 
highest index where you find val (or 0 if you don’t find it again)
The client has violated 
the precondition. As 
implementers, we are 
free to do anything.
If arr[0] is the only occurrence of val?
If we do find another val in the array?
5 Designing Specification
Classroom Exercises
• if arr is empty, return 0 • if arr is empty, throw an exception
• if val occurs twice in arr, throw an exception
• if val occurs twice in arr, set all the values in arr to 0, then throw an 
exception
As the implementer of find, why would you choose to throw an 
exception if precondition is violated?
When our precondition is violated, the client has a bug. 
We can make that bug easier to find and fix by failing fast, even though 
we are not obligated to do so.
5 Designing Specification
Specifications in Java
 Java’s static type declarations are effectively part of the precondition 
and postcondition of a method, a part that is automatically checked 
and enforced by the compiler. 静态类型声明是一种规约，可据此进行
静态类型检查static checking。  The rest of the contract must be described in a comment preceding 
the method, and generally depends on human beings to check it and 
guarantee it. 方法前的注释也是一种规约，但需人工判定其是否满足
 Parameters are described by @param clauses and results are 
described by @return and @throws clauses. 
 Put the preconditions into @param where possible, and 
postconditions into @return and @throws.
5 Designing Specification
Specifications in Java
5 Designing Specification
Recall the code in Lab1
5 Designing Specification
Classroom Exercises
5 Designing Specification
Classroom Exercises
This exercise shows that in a spec, parts of the precondition and 
postcondition may be found in places other than the @param and 
@return clauses, so it’s important to read carefully.
5 Designing Specification
What a specification may talk about
 A specification of a method can talk about the parameters and return
value of the method, but it should never talk about local variables of 
the method or private fields of the method’s class. – You should consider the implementation invisible to the reader of the spec. – In Java, the source code of the method is often unavailable to the reader of 
your spec, because the Javadoc tool extracts the spec comments from your 
code and renders them as HTML.
5 Designing Specification
Specifications for mutating methods
 Example 1: a mutating method
 Example 2: a mutating method
 Example 3: a method that does not mutate its argument
5 Designing Specification
Specifications for mutating methods
 If the effects do not explicitly say that an input can be mutated, 
then we assume mutation of the input is implicitly disallowed. 除
非在后置条件里声明过，否则方法内部不应该改变输入参数
 Virtually all programmers would assume the same thing. Surprise 
mutations lead to terrible bugs. 应尽量遵循此规则，尽量不设计
mutating的spec，否则就容易引发bugs。  Convention 程序员之间应达成的默契：除非spec必须如此，否则不
应修改输入参数 – Mutation is disallowed unless stated otherwise . – No mutation of the inputs
 Mutable objects can make simple specification/contracts very 
complex 尽量避免使用mutable的对象
 Mutable objects reduce changeability
5 Designing Specification
Mutable objects make simple contracts complex
 Multiple references to the same mutable object (aliases for the object) 
may mean that multiple places in your program — possibly widely 
separated — are relying on that object to remain consistent. 程序中可
能有很多变量指向同一个可变对象（别名）
 To put it in terms of specifications, contracts can’t be enforced in just 
one place anymore, e.g. between the client of a class and the 
implementer of a class. 无法强迫类的实现体和客户端不保存可变变量
的“别名”
 Contracts involving mutable objects now depend on the good 
behavior of everyone who has a reference to the mutable object. 
不能靠程序员的“道德”，要靠严格的“契约”
5 Designing Specification
Mutable objects make simple contracts complex
 As a symptom of this non-local contract phenomenon, consider the 
Java collections classes, which are normally documented with very 
clear contracts on the client and implementer of a class. – Try to find where it documents the crucial requirement on the client that 
you can’t modify a collection while you’re iterating over it. 
5 Designing Specification
Mutable objects make simple contracts complex
 The need to reason about global properties like this make it much 
harder to understand, and be confident in the correctness of, 
programs with mutable data structures. 
避免使用可变的全局变量！
 We still have to do it — for performance and convenience — but we 
pay a big cost in bug safety for doing so.
但是为了性能原因，有时候却不得不用。
这对程序的安全性造成了巨大破坏。
5 Designing Specification
Mutable objects reduce changeability
 Mutable objects make the contracts between clients and 
implementers more complicated, and reduce the freedom of the 
client and implementer to change. – In other words, using objects that are allowed to change makes 
the code harder to change. 可变数据类型导致程序修改变得异常困难
 An example: a method to looks up a username in database and 
returns the user’s 9-digit identifier
 A client using this method to print out a user’s identifier:
5 Designing Specification
Mutable objects reduce changeability
 Now both the client and the implementor separately decide to 
make a change. – The client is worried about the user’s privacy, and decides to obscure the 
first 5 digits of the id: – The implementer is worried about the speed and 
load on the database, so the implementer 
introduces a cache that remembers usernames 
that have been 
looked up:
 What will happen?
5 Designing Specification
Mutable objects reduce changeability
5 Designing Specification
Mutable objects reduce changeability
 Sharing a mutable object complicates a contract.  Who’s to blame here? 谁为此事负责？ – Was the client obliged not to modify the object it got back? – Was the implementer obliged not to hold on to the object that it returned?
 A possible way of clarifying the spec:
 How about this spec? – It’s a lifetime contract! 完全建立在客户端开发者的“良心”之上，不可靠！
5 Designing Specification
Mutable objects reduce changeability
 How about this one?
 This spec at least says that the array has to be fresh. 
 But does it keep the implementer from holding an alias to that new 
array? 
 Does it keep the implementer from changing that array or reusing it 
in the future for something else?
 这回责任又到了开发者这一边的“良心”…都靠不住！
5 Designing Specification
Mutable objects reduce changeability
 How about this one?
 The immutable String return value provides a guarantee that the 
client and the implementer will never step on each other the way 
they could with char arrays. 
 It doesn’t depend on a programmer reading the spec comment 
carefully. 
 String is immutable . Not only that, but this approach (unlike the 
previous one) gives the implementer the freedom to introduce a 
cache — a performance improvement. 关键就在于“不可变”，在规
约里限定住
Software Construction
(5)* Testing and verifying 
specifications
5 Designing Specification
Formal contract specification
http://www.eecs.ucf.edu/~leavens/JML/index.shtml
 Java Modelling Language (JML)
 This is a theoretical approach with advantages – Runtime checks generated automatically
– Basis for formal verification
– Automatic analysis tools
 Disadvantages – Requires a lot of work
– Impractical in the large – Some aspects of behavior not amenable to formal specification
5 Designing Specification
Textual specification - Javadoc
 Practical approach
 Documenting every parameter, return value, every exception 
(checked and unchecked),what the method does, including Purpose, 
side effects, any thread safety issues, any performance issues
 Do not document implementation details
5 Designing Specification
Semantic correctness adherence to contracts
 Compiler ensures types are correct (static type checking) – Prevents many runtime errors, such as “Method Not Found” and 
“Cannot add boolean to int”
 Static analysis tools (e.g., FindBugs) recognize many common 
problems (bug patterns) – For example: Overriding equals without overriding hashCode
 But how do you ensure semantic correctness?
5 Designing Specification
Formal verification
 Use mathematical methods to prove correctness with respect to the 
formal specification
 Formally prove that all possible executions of an implementation 
fulfill the specification
 Manual effort; partial automation; not automatically decidable
"Testing shows the presence, not the absence of bugs.”
——Edsger W. Dijkstra, 1969
5 Designing Specification
Testing
 Executing the program with selected inputs in a controlled 
environment
 Goals – Reveal bugs, so they can be fixed (main goal) – Assess quality
– Clarify the specification, documentation
“Beware of bugs in the above code; 
I have only proved it correct, not tried it.”
——Donald Knuth, 1977
Chapter 6 Robustness
5 Designing Specification
Black-box testing
 Black-box testing: to check if the tested program follow the specified 
specification in an implementation-independent way.
 Your test cases should not count on any concrete implemented 
behavior. Test cases must obey the contract, just like every other client.
 An example specification:
 The test case:
This test case has assumed a specific implementation that 
find always returns the lowest index.
Software Construction
3 Designing specifications
Software Construction
(1) Classifying specifications
5 Designing Specification
Comparing specifications
 How deterministic it is. Does the spec define only a single possible 
output for a given input, or allow the implementor to choose from a 
set of legal outputs? 规约的确定性
 How declarative it is. Does the spec just characterize what the output 
should be, or does it explicitly say how to compute the output? 规约
的陈述性
 How strong it is. Does the spec have a small set of legal 
implementations, or a large set? 规约的强度
 “What makes some specifications better than others?”
 用于判断“哪个规约更好”
5 Designing Specification
Stronger vs. weaker specs
 How to compare the behaviors of two specifications to decide 
whether it’s safe to replace the old spec with the new spec? 如何比
较两个规约，以判断是否可以用一个规约替换另一个？
 规约的强度S2>=S1 A specification S2
is stronger than or equal to a 
specification S1
if – S2
’s precondition is weaker than or equal to S1
’s 前置条件更弱 – S2
’s postcondition is stronger than or equal to S1
’s, for the states that 
satisfy S1
’s precondition. 后置条件更强
Then an implementation that satisfies S2
can be used to satisfy S1
as 
well, and it’s safe to replace S1 with S2
in program. 就可以用S2
替代S1  Rules: – Weaken the precondition: placing fewer demands on a client will never upset 
them. – Strengthen the post-condition, which means making more promises.
spec变强：更放松的前置条件+更严格的后置条件
5 Designing Specification
Stronger vs. weaker specs
 Original spec:
 A stronger spec:
 A much stronger spec:
5 Designing Specification
Stronger vs. weaker specs
 How about these two?
前置条件更弱了
在满足findExactlyOne的
前置条件的情况下，
该后置条件无变化
5 Designing Specification
Stronger vs. weaker specs
 How about these two?
前置条件更弱了
在满足findOneOrMore, AnyIndex
的前置条件的情况下，该后
置条件无变化
5 Designing Specification
Stronger vs. weaker specs
 How about these two?
前置条件更弱了
在满足findOneOrMore, FirstIndex
的前置条件的情况下，该后置
条件弱化了：没有返回lowest 
index
5 Designing Specification
Stronger vs. weaker specs
 If S3
is neither stronger nor weaker than S1
, there specs. might 
overlap (such that there exist implementations that satisfy only S1
, 
only S3
, and both S1
and S3
) or might be disjoint. 
 In both cases, S1
and S3
are incomparable.
5 Designing Specification
Exercise
 When a specification is strengthened: – Fewer implementations satisfy it – More implementations satisfy it – Fewer clients can use it – More clients can use it – None of the above
A stronger spec might have a weaker precondition and/or 
stronger postcondition.
In both cases, the implementor must be more careful; but clients 
with more varied inputs or more specific needs might now be able 
to make use of the stronger spec.
越强的规约，意味着implementor的自由度和责任越重，而client的
责任越轻。
5 Designing Specification
Deterministic vs. underdetermined specs
 Deterministic: when presented with a state satisfying the 
precondition, the outcome is completely determined. – Only one return value and one final state is possible. – There are no valid inputs for which there is more than one valid output.
确定的规约：给定一个满足precondition的输入，其输出是唯一的、明确的
5 Designing Specification
Deterministic vs. underdetermined specs
 Under-deterministic: specification allows multiple valid outputs for 
the same input. 欠定的规约：同一个输入可以有多个输出
 Nondeterministic: sometimes behaves one way and sometimes 
another, even if called in the same program with the same inputs 
(e.g., depending on random or timing) 非确定的规约：同一个输入，
多次执行时得到的输出可能不同 – To avoid the confusion, we’ll refer to specifications that are not 
deterministic as underdetermined. 为避免混乱，not d.. == under d..
 Underdeterminism in specifications offers a choice that is made by 
the implementor at implementation time. – An underdetermined spec is typically implemented by a fully￾deterministic implementation. 欠定的规约通常有确定的实现
5 Designing Specification
Deterministic vs. underdetermined specs
Under-deterministic!
Every legal 
input has 
exactly one 
legal output?
Deterministic!
5 Designing Specification
Declarative vs. operational specs
 Operational specifications give a series of steps that the method 
performs; pseudocode descriptions are operational. 操作式规约，例
如：伪代码
 Declarative specifications don’t give details of intermediate steps. 
Instead, they just give properties of the final outcome, and how it’s 
related to the initial state. 声明式规约：没有内部实现的描述，只有
“初-终”状态
 Declarative specifications are preferable. 声明式规约更有价值 – They’re usually shorter, easier to understand, and most importantly, don’t 
inadvertently expose implementation details that a client may rely on.
 Why operational spec. exists? – Programmers use the spec to explain the implementation for a maintainer. – Don’t do that. When it’s necessary, use comments within the body of the 
method, not in the spec comment. 内部实现的细节不在规约里呈现，放在
代码实现体内部注释里呈现。
5 Designing Specification
Declarative spec.
 Standard: the clearest, for clients and maintainers of the code.
5 Designing Specification
Declarative vs. operational specs
Which of the following are 
declarative?
• effects: returns the result of adding all elements to a new 
StringJoiner(delimiter)
• effects: returns the result of looping through elements and 
alternately appending an element and the delimiter
• effects: returns concatenation of elements in order, with delimiter 
inserted between each pair of adjacent elements
Software Construction
(2) Diagramming specifications
5 Designing Specification
Diagramming specifications
 Each point in this space represents a method implementation.  A specification defines a region in the space of all possible 
implementations. 
 A given implementation either behaves according to the spec, 
satisfying the precondition-implies-postcondition contract (it is 
inside the region), or it does not (outside the region). 某个具体实现，
若满足规约，则落在其范围内；否则，在其之外。
5 Designing Specification
Diagramming specifications
 Implementors have the freedom to move around inside the spec, 
changing their code without fear of upsetting a client. 程序员可以在
规约的范围内自由选择实现方式 – This is crucial in order for the implementor to be able to improve the 
performance of their algorithm, the clarity of their code, or to change their 
approach when they discover a bug, etc.
 Clients don’t know which implementation they will get. 客户端无需
了解具体使用了哪个实现 – They must respect the spec, but also have the freedom to change how 
they’re using the implementation without fear that it will suddenly break.
5 Designing Specification
Diagramming specifications
 When S2
is stronger than S1
, it defines a smaller region in this 
diagram. 更强的规约，表达为更小的区域
 A weaker specification defines a larger 
region.
Strengthening the postcondition
means for implementors: it 
means they have less freedom, 
the requirements on their 
output are stronger 更强的后置
条件意味着实现的自由度更低了- 在图中的面积更小
Weakening the precondition 
means: implementations will 
have to handle new inputs that 
were previously excluded by 
the spec. 更弱的前置条件意味着
实现时要处理更多的可能输入，
实现的自由度低了面积更小
5 Designing Specification
Diagramming specifications ExactlyOne 
< OneOrMore, AnyIndex 
< OneOrMore, FirstIndex
ExactlyOne 
< OneOrMore, AnyIndex 
< CanBeMissing
OneOrMore, FirstIndex
CanBeMissing
无法比较
Where should ExactlyOne be?
Software Construction
(3) Designing good specifications
5 Designing Specification
Quality of a specification
 What makes a good method? Designing a method means primarily 
writing a specification. 
 About the form of the specification: it should obviously be succinct, 
clear, and well-structured, so that it’s EASY TO READ.  The content of the specification, however, is harder to prescribe. 
There are no infallible rules, but there are some useful guidelines.
 一个好的“方法”设计，并不是你的代码写的多么好，而是你对该方
法的spec设计得如何。 – 一方面：client用着舒服 – 另一方面：开发者编着舒服
5 Designing Specification
(1) The specification should be coherent (内聚的)  The spec shouldn’t have lots of different cases. Long argument lists, 
deeply nested if-statements, and boolean flags are all signs of 
trouble. Spec描述的功能应单一、简单、易理解
Separating those two 
responsibilities into two 
different methods will 
make them simpler (easy 
to understand) and more 
useful in other contexts 
(ready for change).
 In addition to terrible use of global variables and printing instead of 
returning, the specification is not coherent — it does two different 
things, counting words and finding the longest word. 该规约做了两
件事，所以要分离开形成两个方法。
5 Designing Specification
(2) The results of a call should be informative
信息丰富的
 If null is returned, you can’t tell whether the key was not bound 
previously, or whether it was in fact bound to null.  This is not a very good design, because the return value is useless 
unless you know for sure that you didn’t insert null.
不能让客户端产生理解的歧义
5 Designing Specification
(3) The specification should be strong enough
 The spec should give clients a strong enough guarantee in the general 
case — it needs to satisfy their basic requirements. – We must use extra care when specifying the special cases, to make sure they 
don’t undermine what would otherwise be a useful method. – For example, there’s no point throwing an exception for a bad argument but 
allowing arbitrary mutations, because a client won’t be able to determine 
what mutations have actually been made. 
没有充分阐明遇到null
之后参数是否变化 – If a NullPointerException is thrown, the client is left to figure out on their 
own which elements of list2 actually made it to list1 .  太弱的spec，client不放心、不敢用 (因为没有给出足够的承诺)。
开发者应尽可能考虑各种特殊情况，在post-condition给出处理措施。
5 Designing Specification
(4) The specification should also be weak enough
 This is a bad specification. – It lacks important details: is the file opened for reading or writing? 
Does it already exist or is it created? – It’s too strong, since there’s no way it can guarantee to open a file.
The process in which it runs may lack permission to open a file, or there 
might be some problem with the file system beyond the control of the 
program. 
 Instead, the specification should say something much weaker: it 
attempts to open a file, and if it succeeds, the file has certain 
properties.
 太强的spec，在很多特殊情况下难以达到，给开发者增加了实现的难
度（client当然非常高兴）。
5 Designing Specification
(5) The specification should use abstract types
 Writing our specification with abstract types gives more freedom 
to both the client and the implementor. 在规约里使用抽象类型，可
以给方法的实现体与客户端更大的自由度
 In Java, this often means using an interface type, like Map or 
Reader, instead of specific implementation types like HashMap or 
FileReader. – Abstract notions like a List or Set – Particular implementations like ArrayList or HashSet.  This forces the client to pass in an ArrayList, and forces the 
implementor to return an ArrayList, even if there might be 
alternative List implementations that they would rather use.
5 Designing Specification
(6) Precondition or postcondition?
 Whether to use a precondition, and if so, whether the method code 
should attempt to make sure the precondition has been met before 
proceeding? 是否应该使用前置条件？在方法正式执行之前，是否要检
查前置条件已被满足？
 For programmer: – The most common use of preconditions is to demand a property precisely 
because it would be hard or expensive for the method to check it. 
If to check a condition would 
make a method unacceptably 
slow, a precondition is often 
necessary.
不写Precondition，就要在代
码内部check；若代价太大，
在规约里加入precondition，
把责任交给client
5 Designing Specification
Precondition or postcondition?
 For user: A non-trivial precondition inconveniences clients, because 
they have to ensure that they don’t call the method in a bad state 
(that violates the precondition); if they do, there is no predictable 
way to recover from the error. 
 So users of methods don’t like preconditions. 客户端不喜欢太强的
precondition，不满足precondition的输入会导致失败。 – Thus, Java API classes tend to specify (as a postcondition) that they throw 
unchecked exceptions when arguments are inappropriate. 惯用做法是：
不限定太强的precondition，而是在postcondition中抛出异常：输入不合法 – This makes it easier to find the bug or incorrect assumption in the caller 
code that led to passing bad arguments. – In general, it’s better to fail fast , as close as possible to the site of the bug, 
rather than let bad values propagate through a program far from their 
original cause. 尽可能在错误的根源处fail，避免其大规模扩散
5 Designing Specification
Precondition or postcondition?
 The key factors are the cost of the check (in writing and executing 
code), and the scope of the method. 衡量标准：检查参数合法性的代
价多大？
 If it’s only called locally in a class, the precondition can be 
discharged by carefully checking all the sites that call the method. 
 If the method is public, and used by other developers, it would be 
less wise to use a precondition. Instead, like the Java API classes, you 
should throw an exception.
 归纳：是否使用前置条件取决于(1) check的代价；(2) 方法的使用范围 – 如果只在类的内部使用该方法(private)，那么可以不使用前置条件，在使用
该方法的各个位置进行check——责任交给内部client； – 如果在其他地方使用该方法(public)，那么必须要使用前置条件，若client端
不满足则方法抛出异常。
Software Construction
Summary
5 Designing Specification
Summary
 A specification acts as a crucial firewall between the implementor of 
a procedure and its client. 
 It makes separate development possible: the client is free to write 
code that uses the procedure without seeing its source code, and the 
implementor is free to write the code that implements the procedure 
without knowing how it will be used.
5 Designing Specification
Summary
 Safe from bugs – A good specification clearly documents the mutual assumptions that a 
client and implementor are relying on. Bugs often come from 
disagreements at the interfaces, and the presence of a specification reduces 
that. – Using machine-checked language features in your spec, like static typing 
and exceptions rather than just a human-readable comment, can reduce 
bugs still more.
 Easy to understand
– A short, simple spec is easier to understand than the implementation itself, 
and saves other people from having to read the code.
 Ready for change – Specs establish contracts between different parts of your code, allowing 
those parts to change independently as long as they continue to satisfy the 
requirements of the contract.
5 Designing Specification
Summary
 Declarative specifications are the most useful in practice. 
 Preconditions (which weaken the specification) make life harder for 
the client, but applied judiciously they are a vital tool in the software 
designer’s repertoire, allowing the implementor to make necessary 
assumptions.
5 Designing Specification
Summary
 Safe from bugs. – Without specifications, even the tiniest change to any part of our program 
could be the tipped domino that knocks the whole thing over. – Well-structured, coherent specifications minimize misunderstandings and 
maximize our ability to write correct code with the help of static checking, 
careful reasoning, testing, and code review.
 Easy to understand
– A well-written declarative specification means the client doesn’t have to 
read or understand the code.
 Ready for change – An appropriately weak specification gives freedom to the implementor, 
and an appropriately strong specification gives freedom to the client. – We can even change the specs themselves, without having to revisit every 
place they’re used, as long as we’re only strengthening them: weakening 
preconditions and strengthening postconditions.
Software Construction
The end
May 17, 2021Software Construction
6 Abstract Data Type (ADT)
抽象数据类型 (ADT)
Wang Zhongjie
rainy@hit.edu.cn
May 24, 2021
6 Abstract Data Type (ADT)
Objective of this lecture
 Abstract data types and representation independence : enable us to 
separate how we use a data structure in a program from the 
particular form of the data structure itself. – Abstract data types address a particularly dangerous problem: clients 
making assumptions about the type’s internal representation. – We’ll see why this is dangerous and how it can be avoided. – We’ll also discuss the classification of operations, and some principles of 
good design for abstract data types.
 抽象数据类型与表示独立性：如何设计良好的抽象数据结构，通过封
装来避免客户端获取数据的内部表示（即“表示泄露”），避免潜在
的bug——在client和implementer之间建立“防火墙”
6 Abstract Data Type (ADT)
Objective of this lecture
 Invariants, representation exposure, abstraction functions (AF), 
and representation invariants (RI) – A more formal mathematical idea of what it means for a class to 
implement an ADT, via the notions of abstraction functions and rep 
invariants . – These mathematical notions are eminently practical in software design. – The abstraction function will give us a way to cleanly define the equality 
operation on an abstract data type. – The rep invariant will make it easier to catch bugs caused by a corrupted 
data structure.
 ADT的特性：表示泄漏、抽象函数AF、表示不变量RI
 基于数学的形式对ADT的这些核心特征进行描述并应用于设计中。
6 Abstract Data Type (ADT)
Outline
1. Abstraction and User-Defined Types
2. Classification of operations in ADT
3. Abstract Data Type Examples
4. Design principles of ADT
5. Representation Independence (RI)
6. Realizing ADT Concepts in Java
7. Testing an ADT
8. Invariants
9. Rep Invariant and 
Abstraction Function
10. Beneficent mutation
11. Documenting the AF, 
RI, and Safety from 
Rep Exposure
12. ADT invariants replace 
preconditions
3-1节研究了“数据类型”及其特性
3-2节研究了方法和操作的“规约”及其特性
本节：将数据和操作复合起来，构成ADT，学习
ADT的核心特征，以及如何设计“好的”ADT
6 Abstract Data Type (ADT)
Reading
 MIT 6.031：10、11
Software Construction
1 Abstraction and User-Defined 
Types
6 Abstract Data Type (ADT)
User-Defined Types
 A programming language came with built-in types (such as 
integers, booleans, strings, etc.) and built-in procedures, e.g., for 
input and output. 
 Users could define their own data types and procedures – User￾Defined Types.  除了编程语言所提供的基本数据类型和对象数据类型，程序员可定义
自己的数据类型
6 Abstract Data Type (ADT)
Data Abstraction
 Data abstraction: a type is characterized by the operations you can 
perform on it. 数据抽象：由一组操作所刻画的数据类型（而非…） – A number is something you can add and multiply; – A string is something you can concatenate and take substrings of; 
 Traditionally, programmers define their own types in early 
programming languages, such as: create a record type date, with 
integer fields for day, month, and year. 传统的类型定义：关注数据
的具体表示
 Abstract types focus on operations --- user of the type need not to 
worry about how its values were actually stored, a programmer can 
ignore how the compiler actually stores integers. All that matters is 
the operations. 抽象类型：强调“作用于数据上的操作”，程序员和
client无需关心数据如何具体存储的，只需设计/使用操作即可。
6 Abstract Data Type (ADT)
An example
 An abstract data type Bool has the following operations: – true: Bool – false: Bool – and: Bool × Bool → Bool – or: Bool × Bool → Bool – not: Bool → Bool
 There are many possible ways that Bool might be implemented, 
and still be able to satisfy the specs of the operations, for example: – As a single bit, where 1 means true and 0 means false. – As an int value where 5 means true and 8 means false. – As a reference to a String object where "false" means true and "true" 
means false. – As an int value > 1 where prime numbers mean true and composite 
numbers mean false.
The operations themselves (and 
their specs) completely define the 
data type, abstracting away from 
the details of data structure, 
memory storage, or 
implementation.
6 Abstract Data Type (ADT)
An abstract type is defined by its operations
 Remember----an abstract data type is defined by its operations. – The set of operations for a type T, along with their specifications, fully 
characterize what we mean by T. 
 When we talk about the List type, what we mean is not a linked
list or an array or any other specific data structure for 
representing a list. 
 Instead we mean a set of opaque 
values – the possible objects that 
can have List type – that satisfy 
the specifications of all the 
operations of List: get(), 
size(), etc.
ADT是由操作定义的，与其内部
如何实现无关！
6 Abstract Data Type (ADT)
SE scholars who made contributions to ADT
 Ole-Johan Dahl and Kristen Nygaard Dahl (the inventors of the 
Simula language)
 Antony Hoare (who developed many of the techniques we now use 
to reason about abstract types)
Antony Hoare (1934-)
1980 Turing Award
Kristen Nygaard (1926-2002)
2001 Turing Award
Ole-Johan Dahl (1931-2002)
2001 Turing Award
6 Abstract Data Type (ADT)
SE scholars who made contributions to ADT
 David Parnas (who coined the term information hiding and first 
articulated the idea of organizing program modules around the 
secrets they encapsulated)  Barbara Liskov and John Guttag (the specification of abstract types, 
and in programming language support for them)
Barbara Liskov (1939- )
2008 Turing Award
David L. Parnas (1941- ) John Guttag (1949- )
Software Construction
2 Classifying Types and Operations
6 Abstract Data Type (ADT)
Mutable and immutable types
 Types, whether built-in or user-defined, can be classified as 
mutable or immutable 可变和不可变数据类型 – The objects of a mutable type can be changed: that is, they provide 
operations which when executed cause the results of other operations on 
the same object to give different results. 可变类型的对象：提供了可改变其
内部数据的值的操作 – Date is mutable, because you can call setMonth() and observe the change 
with the getMonth() operation. – But String is immutable, because its operations create new String
objects rather than changing existing ones. 不变数据类型： 其操作不改变
内部值，而是构造新的对象 – Sometimes a type will be provided in two forms, a mutable and an 
immutable form. StringBuilder, for example, is a mutable version of 
String (but the e two are certainly not the same Java type, and are not 
interchangeable).
6 Abstract Data Type (ADT)
Classifying the operations of an abstract type
 Creators create new objects of the type. 构造器 – A creator may take an object as an argument, but not an object of the type 
being constructed.
 Producers create new objects from old objects of the type. 生产器 – The concat() method of String , for example, is a producer: it takes two 
strings and produces a new one representing their concatenation.
 Observers take objects of the abstract type and return objects of a 
different type. 观察器 – The size() method of List , for example, returns an int .  Mutators change objects. 变值器，改变对象属性的方法 – The add() method of List , for example, mutates a list by adding an 
element to the end.
6 Abstract Data Type (ADT)
Classifying the operations of an abstract type
 creator : t* → T
 producer : T+, t* → T
 observer : T+, t* → t
 mutator : T+, t* → void | t | T
 Each T is the abstract type itself; 
 Each t is some other type. 
 The + marker indicates that the type may occur one or more times 
in that part of the signature.
 The * marker indicates that it occurs zero or more times. 
 The | indicates or.
6 Abstract Data Type (ADT)
Signature of an operation
 String.concat() as a producer – concat: String × String → String
 List.size() as an observer – size: List → int
 String.regionMatches as a observer – regionMatches: 
String × boolean × int × String × int × int → boolean
请阅读该函
数的spec，
学习复杂
spec的写法
6 Abstract Data Type (ADT)
Signature of a creator
 A creator is either implemented as a constructor , like new 
ArrayList(), or simply a static method instead, like 
Arrays.asList(), List.of(). 构造器：可能实现为构造函数或静
态函数
 A creator implemented as a static method is often called a factory 
method 工厂方法
 The various String.valueOf(Object Obj) methods in Java are 
other examples of creators implemented as factory methods. 与
Object.toString()正好是相对的
6 Abstract Data Type (ADT)
Signature of a mutator
 Mutators are often signaled by a void return type. 变值器通常返回
void
– A method that returns void must be called for some kind of side-effect, 
since otherwise it doesn’t return anything. 如果返回值为void，则必然意
味着它改变了对象的某些内部状态
 But not all mutators return void. 变值器也可能返回非空类型 – For example, Set.add() returns a boolean that indicates whether the set 
was actually changed. – In Java’s graphical user interface toolkit, Component.add() returns the 
object itself, so that multiple add() calls can be chained together.
Software Construction
3 Abstract Data Type Examples
6 Abstract Data Type (ADT)
int and String
 int is immutable, so it has no mutators. – creators: the numeric literals 0 , 1 , 2 , … – producers: arithmetic operators + , - , * , / – observers: comparison operators == , != , < , > – mutators: none (it’s immutable)
 String is Java’s string type. String is immutable. – creators: String constructors – producers: concat , substring , toUpperCase – observers: length , charAt – mutators: none
6 Abstract Data Type (ADT)
List
 List is Java’s list type and is 
mutable. 
 List is also an interface, which 
means that other classes provide 
the actual implementation of the 
data type, such as ArrayList and 
LinkedList . – creators: ArrayList and 
LinkedList constructors, 
Collections.singletonList – producers: 
Collections.unmodifiableList – observers: size , get – mutators: add , remove , addAll , 
Collections.sort
https://docs.oracle.com/javase/8/docs/api/java/util/List.html
看看每一个method的类型是什么
6 Abstract Data Type (ADT)
Examples
 Integer.valueOf() 
 BigInteger.mod()
 List.addAll()
 String.toUpperCase()
 Set.contains()
 Map.keySet()
 Collections.unmodifiableList()
 BufferedReader.readLine()
Creator
Producer
Mutator
Producer
Observer
Observer
Producer
Mutator
Software Construction
4 Designing an Abstract Type
6 Abstract Data Type (ADT)
Designing an Abstract Type
 Designing an abstract type involves choosing good operations and 
determining how they should behave. 设计好的ADT，靠“经验法
则”，提供一组操作，设计其行为规约 spec
 Rules of thumb 1 设计简洁、一致的操作 – It’s better to have a few, simple operations that can be combined in 
powerful ways, rather than lots of complex operations. – Each operation should have a well-defined purpose, and should have a 
coherent behavior rather than a panoply of special cases. – We probably shouldn’t add a sum operation to List , for example. It might 
help clients who work with lists of integers, but what about lists of 
strings? Or nested lists? All these special cases would make sum a hard 
operation to understand and use.
6 Abstract Data Type (ADT)
Designing an Abstract Type
 Rules of thumb 2 要足以支持client对数据所做的所有操作需要，且
用操作满足client需要的难度要低
 The set of operations should be adequate in the sense that there 
must be enough to do the kinds of computations clients are likely 
to want to do. – A good test is to check that every property of an object of the type can be 
extracted. – For example, if there were no get operation, we would not be able to find 
out what the elements of a list are. 没有get()操作就无法获取list的内部
数据 – Basic information should not be inordinately difficult to obtain. – For example, the size method is not strictly necessary for List, because we 
could apply get on increasing indices until we get a failure, but this is 
inefficient and inconvenient. 用遍历方式获取list的size –太复杂 vs 提供
size()操作，方便client使用
6 Abstract Data Type (ADT)
Designing an Abstract Type
 Rules of thumb 3 要么抽象、要么具体，不要混合 --- 要么针对抽象
设计，要么针对具体应用的设计
 The type may be generic: a list or a set, or a graph, for example. 
 Or it may be domain-specific: a street map, an employee database, 
a phone book, etc. 
 But it should not mix generic and domain-specific features. – A Deck type intended to represent a sequence of playing cards shouldn’t 
have a generic add method that accepts arbitrary objects like integers or 
strings. – Conversely, it wouldn’t make sense to put a domain-specific method like 
dealCards into the generic type List .
Software Construction
5 Representation Independence
表示独立性
6 Abstract Data Type (ADT)
Representation Independence
 Critically, a good abstract data type should be representation 
independent. 表示独立性：client使用ADT时无需考虑其内部如何实
现，ADT内部表示的变化不应影响外部spec和客户端。 – The use of an abstract type is independent of its representation (the actual 
data structure or data fields used to implement it), so that changes in 
representation have no effect on code outside the abstract type itself. – For example, the operations offered by List are independent of whether 
the list is represented as a linked list or as an array.  You won’t be able to change the representation of an ADT at all 
unless its operations are fully specified with preconditions and 
postconditions, so that clients know what to depend on, and you 
know what you can safely change. 除非ADT的操作指明了具体的pre-
和post-condition，否则不能改变ADT的内部表示——spec规定了
client和implementer之间的契约。
6 Abstract Data Type (ADT)
Example: Different Representations for Strings
6 Abstract Data Type (ADT)
Let’s write its test case (Test-First Programming)
MyString s = MyString.valueOf(true);
assertEquals(“true”, s);
assertEquals(“true”, s.toString());
assertEquals(4, s.length());
assertEquals('t', s.charAt(0));
assertEquals('r', s.charAt(1));
assertEquals('u', s.charAt(2));
assertEquals('e', s.charAt(3));
MyString t = s.substring(0,2);
assertEquals('t', t.charAt(0));
...
6 Abstract Data Type (ADT)
A simple representation for MyString
 Look at a simple representation for MyString : just an array of 
characters, exactly the length of the string, with no extra room at 
the end. 
 Here’s how that internal representation would be declared, as an 
instance variable within the class:
private char[] a;
 With that choice of representation, the operations would be 
implemented in a straightforward way:
6 Abstract Data Type (ADT)
The corresponding implementation for MyString
6 Abstract Data Type (ADT)
An example of the client
MyString s = MyString.valueOf(true);
MyString t = s.substring(1,3);
6 Abstract Data Type (ADT)
Another representation for better performance
 Because this data type is immutable, the substring operation 
doesn’t really have to copy characters out into a fresh array. 
 It could just point to the original MyString object’s character array 
and keep track of the start and end that the new substring object 
represents. 
 To implement this optimization, we could change the internal 
representation of this class to:
private char[] a;
private int start;
private int end;
6 Abstract Data Type (ADT)
Now the implementation is …
Because MyString ’s existing 
clients depend only on the 
specs of its public methods, 
not on its private fields, we 
can make this change without 
having to inspect and change 
all that client code. 
That’s the power of 
representation independence.
6 Abstract Data Type (ADT)
An example of the client
MyString s = MyString.valueOf(true);
MyString t = s.substring(1,3);
6 Abstract Data Type (ADT)
An example of violating RI
/**
* Represents a family that lives in a household together.
* A family always has at least one person in it.
* Families are mutable.
*/
class Family {
public List<Person> people;
public List<Person> getMembers() {
return people;
} }
void client1(Family f) {
Person baby = f.people.get(f.people.size()-1); ... 
} 
class Family {
Set<Person> p;
List<Person> getMembers() {
return new ArrayList<>(p);
} }
6 Abstract Data Type (ADT)
An example of keeping RI
6 Abstract Data Type (ADT)
An example of keeping RI
Specification Representation Implementation
6 Abstract Data Type (ADT)
An example of keeping RI
Specification
Specification
Representation
Specification
Implementation
Software Construction
6 Testing an Abstract Data Type
6 Abstract Data Type (ADT)
How to test an ADT
 We build a test suite for an ADT by creating tests for each of its 
operations. 
 These tests inevitably interact with each other. 
 The only way to test creators, producers, and mutators is by calling 
observers on the objects that result, and likewise, the only way to test 
observers is by creating objects for them to observe.
 测试creators, producers, and mutators：调用observers来观察这些
operations的结果是否满足spec；  测试observers：调用creators, producers, and mutators等方法产生或
改变对象，来看结果是否正确。
 风险：如果被依赖的其他方法有错误，可能导致被测试方法的测试结
果失效。
6 Abstract Data Type (ADT)
Partition the input spaces of ADT operations
针对creator：构造对象之后，用observer去观察是否正确
针对observer：用其他三类方法构造对象，然
后调用被测observer，判断观察结果是否正确
针对producer：produce新对象之后，用
observer判断结果是否正确
Recall what we’ve learned in Section 7-5: partitioning-based testing
6 Abstract Data Type (ADT)
Test suite that covers all partitions
• Which test cases cover the part “charAt() with string 
len=1”?
• Which test cases cover the part “substring() of string 
produced by substring()”?
• Which test cases cover the part “valueOf(true)”?
Software Construction
7 Invariants
6 Abstract Data Type (ADT)
Invariants of an ADT
 The most important property of a good abstract data type is that 
it preserves its own invariants. 保持不变量
 An invariant is a property of a program that is always true, for every 
possible runtime state of the program. 不变量：在任何时候总是true – Immutability is one crucial invariant: once created, an immutable object 
should always represent the same value, for its entire lifetime. 例如：
immutability就是一个典型的“不变量”
 Saying that the ADT preserves its own invariants means that the 
ADT is responsible for ensuring that its own invariants hold. 由ADT
来负责其不变量，与client端的任何行为无关 – It doesn’t depend on good behavior from its clients. – Correctness doesn’t depend on other modules.
6 Abstract Data Type (ADT)
Why are invariants required?
 When an ADT preserves its own invariants, reasoning about the 
code becomes much easier. 为什么需要不变量：保持程序的“正确
性”，容易发现错误 – If you can count on the fact that Strings never change, you can rule out 
that possibility when you’re debugging code that uses Strings – or when 
you’re trying to establish an invariant for another ADT that uses Strings. – Contrast that with a string type that guarantees that it will be immutable 
only if its clients promise not to change it. Then you’d have to check all the 
places in the code where the string might be used. 如果没有这个不变性，
那么在所有使用String的地方，都要检查其是否改变了
 … Assume clients will try to destroy invariants (malicious hackers 
or honest mistakes) 总是要假设client有“恶意”破坏ADT的不变量-
--defensive programming
6 Abstract Data Type (ADT)
Immutability as a type of Invariants
 How do we guarantee that these Tweet objects are immutable – that, 
once a tweet is created, its author, message, and date can never be 
changed?
6 Abstract Data Type (ADT)
It’s mutable…
 The first threat to immutability comes from the fact that clients can 
directly access its fields.
 What’s the effect of this code?
 This is a trivial example of representation exposure 表示泄露, 
meaning that code outside the class can modify the representation 
directly. 不仅影响不变性，也影响了表示独立性：无法在不影响客户
端的情况下改变其内部表示 – Rep exposure like this threatens not only invariants, but also 
representation independence. – We can’t change the implementation of Tweet without affecting all the 
clients who are directly accessing those fields.
6 Abstract Data Type (ADT)
To make it immutable…
 The private and public
keywords indicate which fields 
and methods are accessible 
only within the class and which 
can be accessed from outside 
the class. 
 The final keyword also helps 
by guaranteeing that the fields 
of this immutable type won’t 
be reassigned after the object is 
constructed.
6 Abstract Data Type (ADT)
How about this …
 What’s the effect of this code?
 retweetLater() takes a tweet and should return another tweet 
with the same message (called a retweet) but sent an hour later. 
 The retweetLater() method might be part of a system that 
automatically echoes funny things that Twitter celebrities say.
6 Abstract Data Type (ADT)
What’s the problem?
 What’s the problem here? – The getTimestamp call returns a reference to 
the same Date object referenced by tweet t . t.timestamp and d are aliases to the same 
mutable object. – So when that date object is mutated by d.setHours() , this affects the 
date in t as well, as shown in the snapshot diagram.
 Tweet ’s immutability invariant has been broken. – The problem is that Tweet leaked out a reference to a mutable object that 
its immutability depended on. – We exposed the rep, in such a way that Tweet can no longer guarantee 
that its objects are immutable. – Perfectly reasonable client code created a subtle bug.
But, we have 
declared timestamp
as final! 
6 Abstract Data Type (ADT)
How to solve it? --- Defensive copying
 We can patch this kind of rep exposure by using defensive 
copying: making a copy of a mutable object to avoid leaking out 
references to the rep. 
 Defensive copying is an approach of defensive programming
– Assume clients will try to destroy invariants --- May actually be true 
(malicious hackers), but more likely, honest mistakes – Ensure class invariants survive any inputs, to minimize mutability
6 Abstract Data Type (ADT)
Copy and Clone()
 Mutable types often have a copy constructor that allows you to 
make a new instance that duplicates the value of an existing 
instance. – In this case, Date ’s copy constructor uses the timestamp value, measured 
in milliseconds since January 1, 1970. – As another example, StringBuilder ’s copy constructor takes a String.  Another way to copy a mutable object is clone(), which is 
supported by some types but not all. – To be further discussed in Chapter 8 Performance
6 Abstract Data Type (ADT)
Still rep exposure…
 What’s the side-effect of this code?
 The constructor of Tweet saves the reference
that was passed in, so all 24 Tweet objects 
end up with the same time.
6 Abstract Data Type (ADT)
How to solve it? --- Again, defensive copying
 In general, you should carefully inspect the argument types and 
return types of all your ADT operations. 
 If any of the types are mutable, make sure your implementation 
doesn’t return direct references to its representation. 
 Doing that creates rep exposure.
6 Abstract Data Type (ADT)
Leave the responsibility to your clients?
 You may object that this seems wasteful. Why make all these copies 
of dates? Why can’t we just solve this problem by a carefully written 
specification, like this?
– This approach is sometimes taken when there isn’t any other reasonable 
alternative – for example, when the mutable object is too large to copy 
efficiently. 当复制代价很高时，不得不这么做 – But the cost in your ability to reason about the program, and your ability 
to avoid bugs, is enormous. 但是由此引发的潜在bug也将很多
6 Abstract Data Type (ADT)
Using immutable instead of mutable types
 In the absence of compelling arguments to the contrary, it’s almost 
always worth it for an abstract data type to guarantee its own 
invariants, and preventing rep exposure is essential to that. 
除非迫不得已，否则不要把希望寄托于客户端上，ADT有责任保证自
己的invariants，并避免“表示泄露”。
 An even better solution is to prefer immutable types. If we had 
used an immutable date object, like java.time.ZonedDateTime, 
instead of the mutable java.util.Date, then we would have 
ended this section after talking about public and private. No 
further rep exposure would have been possible. 最好的办法就是使
用immutable的类型，彻底避免表示泄露
6 Abstract Data Type (ADT)
An example
Hypotenuse
Leg A Leg B
Representation
Constructor
Observer
Producer
6 Abstract Data Type (ADT)
Summary
 Don’t incorporate mutable parameters into object; make defensive 
copies
 Return defensive copies of mutable fields…
– Return new instance instead of modifying
 Or return unmodifiable view of mutable fields
 Real lesson – use immutable components, to eliminate the need for 
defensive copying
保持不变性和避免表示泄漏，是ADT最
重要的一个Invariant！
Software Construction
8 Rep Invariant
and Abstraction Function
Theory of ADT
6 Abstract Data Type (ADT)
Two spaces of values
 R: the space of representation values 
(rep values) consists of the values of the 
actual implementation entities. – An ADT will be implemented as a single object, but more commonly a 
small network of objects is needed, so the value is often something rather 
complicated. 一般情况下ADT的表示比较简单，有些时候需要复杂表示
 A: the space of abstract values consists of the values that the type is 
designed to support. 抽象值构成的空间：client看到和使用的值 – They’re platonic entities that don’t exist as described, but they are the way 
we want to view the elements of the abstract type, as clients of the type. – For example, an abstract type for unbounded integers might have the 
mathematical integers as its abstract value space; the fact that it might be 
implemented as an array of primitive (bounded) integers, say, is not 
relevant to the user of the type.
表示空间 抽象空间
6 Abstract Data Type (ADT)
Example of two spaces
 The implementor of the abstract type must be interested in the 
representation values, since it is the implementor’s job to achieve the 
illusion of the abstract value space using the rep value space. ADT开
发者关注表示空间R，client关注抽象空间A  Suppose, for example, that we choose to use a string to represent a 
set of characters:
 Then the rep space R contains Strings, and the abstract space A is 
mathematical sets of characters.
6 Abstract Data Type (ADT)
Mapping between R and A
 Every abstract value is mapped to by 
some rep value (surjective, 满射). – The purpose of implementing the abstract type is 
to support operations on abstract values. Presumably, we will need to be 
able to create and manipulate all possible abstract values, and they must 
therefore be representable.
 Some abstract values are mapped to by more than one rep 
value (not injective, 未必单射). – This happens because the representation isn’t a tight encoding. There’s 
more than one way to represent an unordered set of characters as a string.
 Not all rep values are mapped (not bijective, 未必双射). – In this case, the string “abbc” is not mapped. In this case, we have decided 
that the string should not contain duplicates. This will allow us to 
terminate the remove method when we hit the first instance of a particular 
character, since we know there can be at most one.
6 Abstract Data Type (ADT)
Abstraction Function
 An abstraction function that maps rep values to the abstract values 
they represent: 抽象函数：R和A之间映射关系的函数，即如何去解
释R中的每一个值为A中的每一个值。
AF : R → A
 The arcs in the diagram show the abstraction function. – In the terminology of functions, the properties can be expressed by saying 
that the function is surjective (also called onto), not necessarily injective ( 
one-to-one ) and therefore not necessarily bijective, and often partial. 
AF： 满射、非单射、
未必双射
 R中的部分值并非合法的，
在A中无映射值
6 Abstract Data Type (ADT)
Rep Invariant: another important ADT invariants
 A rep invariant that maps rep values to booleans:
RI : R → boolean
 For a rep value r , RI(r) is true if and only if r is mapped by AF . 
 In other words, RI tells us whether a given rep value is well￾formed. 
 Alternatively, you can think of RI as a set: it’s the subset of rep 
values on which AF is defined.
 表示不变性RI：某个具体的“表示”是否是“合法的”
 也可将RI看作：所有表示值的一个子集，包含了所有合法的表示值
 也可将RI看作：一个条件，描述了什么是“合法”的表示值
6 Abstract Data Type (ADT)
Documenting RI and AF
 Both the rep invariant and the abstraction function should be 
documented in the code, right next to the declaration of the rep 
itself:
只要不包含重复字符
的字符串，都是“合
法的”表示值
从s中取出所有的字
符，构成集合，即为
client所需的抽象值
该ADT的AF是否满足
满射？
单射？
双射？
6 Abstract Data Type (ADT)
What determine AF and RI?
 The abstract value space alone doesn’t determine AF or RI: – There can be several representations for the same abstract type. – A set of characters could equally be represented as a string, as above, or as 
a bit vector, with one bit for each possible character. – Clearly we need two different abstraction functions to map these two 
different rep value spaces. – 不同的内部表示，需要设计不同的AF和RI
 Defining a type for the rep, and thus choosing the values for the 
space of rep values, does not determine which of the rep values will 
be deemed to be legal, and of those that are legal, how they will be 
interpreted. 选择某种特定的表示方式R，进而指定某个子集是“合
法”的(RI)，并为该子集中的每个值做出“解释”(AF)——即如何映射
到抽象空间中的值。
6 Abstract Data Type (ADT)
What determine AF and RI?
 For example, if we allow duplicates in strings, but at the same time 
require that the characters be sorted, appearing in nondecreasing 
order, then there would be the same rep value space but different rep 
invariant.
Same rep value space
Different rep invariant
6 Abstract Data Type (ADT)
What determine AF and RI?
 Even with the same type for the rep value space and the same rep 
invariant RI, we might still interpret the rep differently, with 
different abstraction functions AF. 即使是同样的R、同样的RI，也
可能有不同的AF，即“解释不同”。 – Perhaps we’ll interpret consecutive pairs of characters as subranges, so 
that the string rep "acgg" is interpreted as two range pairs, [a-c] and 
[g-g] , and therefore represents the set 
{a,b,c,g}. 
6 Abstract Data Type (ADT)
Problems
 Which of the following values of s
satisfy this rep invariant? – "abc" – "abcd" – "eeee" – "ad" – "adad" – ""
 “Which of the following 
does AF("acfg") map to? – {a,b,c,d,e,f,g} – {a,b,c,f,g} – {a,c,f,g} – some other abstract value – no abstract value, because 
"acfg" does not satisfy the 
 Which of these values does the abstraction rep invariant
function map to the same abstract value as 
it maps "tv"? – "ttv" – "ttuuvv" – "ttuv" – "tuv"
6 Abstract Data Type (ADT)
How RI and AF influence ADT design
 The essential point is that designing an abstract type means not only 
choosing the two spaces – the abstract value space for the 
specification and the rep value space for the implementation – but 
also deciding what rep values to use and how to interpret them.
设计ADT：(1) 选择R和A；(2) RI --- 合法的表示值；
(3) 如何解释合法的表示值 ---映射AF
做出具体的解释：每个rep value如何映射到abstract value
 It’s critically important to write down these assumptions in your 
code, so that future programmers (and your future self) are aware of 
what the representation actually means. – Why? What happens if different implementers disagree about the 
meaning of the rep?
而且要把这种选择和解释明确写到代码当中
6 Abstract Data Type (ADT)
Question 1
 Which of the following should be known (visible and documented) 
to the client of an abstract data type? – Abstract value space – Abstraction function
– Creators – Observers – Rep
– Rep invariant
 Which of above should be known to the developer of an abstract 
data type?
6 Abstract Data Type (ADT)
Question 2
 Suppose C is an abstract data type whose representation has two 
String fields:
class C {
private String s;
private String t;
...
}  Assuming you don’t know anything about C’s abstraction, which 
of the following might be statements in a rep invariant for C? – s contains only letters – s.length() == t.length() – s represents a set of characters – C’s observers – s is the reverse of t – s+t
6 Abstract Data Type (ADT)
Problem 3
class C {
private String s;
...
}
public void add(char c) {
s = s + c;
}
public void remove(char c) {
int position = s.indexOf(c);
if (position >= 0) {
s = s.substring(0, position) + 
s.substring(position+1, s.length());
} }
这两个方法分别支持哪个（些）
AF/RI？
意即：执行该方法之后，RI是否
仍然可以保持？
xyyxyyx
Spec: 将c从字符
Spec: 将c加入 集合中删除
字符集合
6 Abstract Data Type (ADT)
Problem 3
class C {
private String s;
...
}
这个方法分别支持哪个（些）
AF/RI？
public boolean contains(char c) {
for (int i = 0; i < s.length(); i += 2) {
char low = s.charAt(i);
char high = s.charAt(i+1);
if (low <= c && c <= high) {return true;}
}
return false;
}
6 Abstract Data Type (ADT)
Example: ADT for Rational Numbers
6 Abstract Data Type (ADT)
RI and AF of this example
 The RI requires that numerator/denominator pairs be in reduced 
form (i.e., lowest terms), so pairs like (2,4) and (18,12) above should 
be drawn as outside the RI.
6 Abstract Data Type (ADT)
RI and AF of this example
6 Abstract Data Type (ADT)
Checking the Rep Invariant 随时检查RI是否满足
 The rep invariant isn’t just a neat mathematical idea. If your 
implementation asserts the rep invariant at run time, then you can 
catch bugs early.
 You should certainly call checkRep() to assert the rep invariant at 
the end of every operation that creates or mutates the rep (creators, 
producers, and mutators). 在所有可能改变rep的方法内都要检查
 Observer methods don’t normally need to call checkRep(), but it’s 
good defensive practice to do so anyway. Observer方法可以不用，但
建议也要检查，以防止你的“万一” – Calling checkRep() in every method, including observers, means you’ll 
be more likely to catch rep invariant violations caused by rep exposure.
Software Construction
9 Beneficent mutation
6 Abstract Data Type (ADT)
Beneficent mutation
 Recall that a type is immutable if and only if a value of the type 
never changes after being created. 
 With our new understanding of the abstract space A and rep space R, 
we can refine this definition: the abstract value should never change. 
 But the implementation is free to mutate a rep value as long as it 
continues to map to the same abstract value, so that the change is 
invisible to the client. 
 This kind of change is called beneficent mutation (有益的可变性).  对immutable的ADT来说，它在A空间的abstract value应是不变的。
 但其内部表示的R空间中的取值则可以是变化的。
6 Abstract Data Type (ADT)
An example of beneficent mutation
 RatNum: this rep has a weaker 
rep invariant that doesn’t require 
the numerator and denominator 
to be stored in lowest terms
6 Abstract Data Type (ADT)
An example of beneficent mutation
 This weaker rep invariant allows a sequence of RatNum arithmetic 
operations to simply omit reducing the result to lowest terms. But 
when it’s time to display a result to a human, we first simplify it:
6 Abstract Data Type (ADT)
An example of beneficent mutation
 Notice that this toString implementation reassigns the private 
fields numerator and denominator, mutating the representation –
even though it is an observer method on an immutable type! 
 But, crucially, the mutation doesn’t change the abstract value. – Dividing both numerator and denominator by the same common factor, or 
multiplying both by -1, has no effect on the result of the abstraction 
function, AF(numerator, denominator) = numerator/denominator. 
 Another way of thinking about it: AF is a many-to-one function, 
and the rep value has changed to another that still maps to the 
same abstract value. So the mutation is harmless, or beneficent.
 这种mutation只是改变了R值，并未改变A值，对client来说是
immutable的 “AF并非单射”，从一个R值变成了另一个R值  但这并不代表在immutable的类中就可以随意出现mutator！
6 Abstract Data Type (ADT)
Why is beneficent mutation required?
 This kind of implementer freedom often permits performance 
improvements like: – Caching：例如通过cache暂存某些频繁计算的结果 – Data structure rebalancing：例如对tree数据结构进行插入或删除节点之后 – Lazy computation：上例中在toString()的时候才进行约分计算
 通过牺牲immutability的部分原则来换取“效率”和“性能”
AF： 满射、非单射、
未必双射
 A值在R中有多个对应的R值 
可以内部改变R值，不改变A值
Software Construction
10 Documenting the AF, RI, and 
Safety from Rep Exposure
6 Abstract Data Type (ADT)
Documenting AF and RI
 It’s good practice to document the abstraction function and rep 
invariant in the class, using comments right where the private fields 
of the rep are declared. 在代码中用注释形式记录AF和RI
 It is not enough for the RI to be a generic statement like “all fields are 
valid.” 要精确的记录RI：rep中的所有fields何为有效 – The job of the rep invariant is to explain precisely what makes the field 
values valid or not.
 It is not enough for the AF to offer a generic explanation like 
“represents a set of characters.” 要精确记录AF：如何解释每一个R值 – The job of the abstraction function is to define precisely how the concrete 
field values are interpreted. – As a function, if we take the documented AF and substitute in actual (legal) 
field values, we should obtain out a complete description of the single 
abstract value they represent.
6 Abstract Data Type (ADT)
Documenting rep exposure safety argument
 Another piece of documentation is a rep exposure safety argument 
表示泄漏的安全声明
 This is a comment that examines each part of the rep, looks at the 
code that handles that part of the rep (particularly with respect to 
parameters and return values from clients, because that is where rep 
exposure occurs), and presents a reason why the code doesn’t expose 
the rep. 给出理由，证明代码并未对外泄露其内部表示——自证清白
6 Abstract Data Type (ADT)
Example 1
RI：针对Rep的每一个field
以及多个fields之间的关系，
进行条件限定，要精确
AF：给出client看到的A值是什么，
是对每一个Rep值的“数学运算”
6 Abstract Data Type (ADT)
Example 2
6 Abstract Data Type (ADT)
Example 3
getFollowers() makes a 
defensive copy of the Set it 
returns, and all other 
parameters and return values 
are immutable String or void.
The Set objects 
in the rep are 
made immutable 
by unmodifiable 
wrappers
6 Abstract Data Type (ADT)
Summary: What an ADT spec may talk about
 The specification of an abstract type T – which consists of the specs of 
its operations – should only talk about things that are visible to the 
client. ADT的规约里只能使用client可见的内容来撰写，包括参数、返
回值、异常等。 – This includes parameters, return values, and exceptions thrown by its 
operations. 
 Whenever the spec needs to refer 
to a value of type T, it should 
describe the value as an abstract 
value, i.e. mathematical values in 
the abstract space A. 如果规约里
需要提及“值”，只能使用A空间
中的“值”。
6 Abstract Data Type (ADT)
Summary: What an ADT spec may talk about
 The spec should not talk about details of the representation, or 
elements of the rep space R. ADT的规约里也不应谈及任何内部表示
的细节，以及R空间中的任何值
 It should consider the rep itself (the private fields) invisible to the 
client, just as method bodies and their local variables are considered 
invisible. ADT的内部表示(私有属性)对外部都应严格不可见
 That’s why we write the rep invariant and abstraction function as 
ordinary comments within the body of the class, rather than Javadoc 
comments above the class. 故在代码中以注释的形式写出AF和RI而不
能在Javadoc文档中，防止被外部看到而破坏表示独立性/信息隐藏 – Writing them as Javadoc comments would commit to them as public parts 
of the type’s specification, which would intefere with rep independence 
and information hiding.
6 Abstract Data Type (ADT)
How to establish invariants
 An invariant is a property that is true for the entire program – which 
in the case of an invariant about an object, reduces to the entire 
lifetime of the object.
 To make an invariant hold, we need to: – Make the invariant true in the initial state of the object; – Ensure that all changes to the object keep the invariant true. – 在对象的初始状态不变量为true，在对象发生变化时，不变量也要为true
 Translating this in terms of the types of ADT operations: – Creators and producers must establish the invariant for new object 
instances; 构造器和生产器在创建对象时要确保不变量为true – Mutators and observers must preserve the invariant. 变值器和观察器在执
行时必须保持不变性。 – Using checkRep() to check invariants before each method returns. 在每个
方法return之前，用checkRep()检查不变量是否得以保持。
6 Abstract Data Type (ADT)
How to establish invariants
 The risk of rep exposure makes the situation more complicated. 
 If the rep is exposed, then the object might be changed anywhere in 
the program, not just in the ADT’s operations, and we can’t 
guarantee that the invariant still holds after those arbitrary changes. 
 表示泄漏的风险：一旦泄露，ADT内部表示可能会在程序的任何位置
发生改变（而不是限制在ADT内部），从而无法确保ADT的不变量是
否能够始终保持为true。  So the full rule for proving invariants——If an invariant of an 
abstract data type is – established by creators and producers; – preserved by mutators, and observers; – no representation exposure occurs,
then the invariant is true of all instances of the abstract data type.
用这三个标准来检查你的ADT是
否保持不变量？
6 Abstract Data Type (ADT)
Does this ADT 
keep its invariant?
Here causes a rep exposure, so the 
client may inadvertently change 
values in the returned array and 
destroy the invariant as a result, even 
while obeying all the specs as written.
This method creates a new triangle, 
but changes only the legs and doesn’t 
recalculate a new hypotenuse for it. 
This doesn’t preserve the Pythagorean 
invariant for the new triangle.
Software Construction
11 ADT invariants replace 
preconditions
6 Abstract Data Type (ADT)
ADT invariants replace preconditions
 An enormous advantage of a well-designed abstract data type is that 
it encapsulates and enforces properties that we would otherwise 
have to stipulate in a precondition. 用ADT不变量取代复杂的
Precondition，相当于将复杂的precondition封装到了ADT内部。
6 Abstract Data Type (ADT)
ADT invariants replace preconditions
 It’s safer from bugs, because the required condition (sorted with no 
repeats) can be enforced in exactly one place, the SortedSet type, 
and because Java static checking comes into play, preventing 
values that don’t satisfy this condition from being used at all, with 
an error at compile-time.
 It’s easier to understand, because it’s much simpler, and the name 
SortedSet conveys what the programmer needs to know.
 It’s more ready for change, because the representation of 
SortedSet can now be changed without changing exclusiveOr or 
any of its clients.
6 Abstract Data Type (ADT)
An Example
public static List<Tweet> 
writtenBy(TweetList tweets, UserName username)
{ ... }
TweetList would be able to represent the requirement that the tweets have 
distinct timestamps
UserName would be able to represent the constraint on valid usernames.
Software Construction
Summary
6 Abstract Data Type (ADT)
Summary
 Abstract data types are characterized by their operations.
 Operations can be classified into creators, producers, observers, 
and mutators.
 An ADT’s specification is its set of operations and their specs.
 A good ADT is simple, coherent, adequate, and representation￾independent.
 An ADT is tested by generating tests for each of its operations, but 
using the creators, producers, mutators, and observers together in 
the same tests.
6 Abstract Data Type (ADT)
Summary
 Safe from bugs. A good ADT offers a well-defined contract for a 
data type, so that clients know what to expect from the data type, 
and implementors have well-defined freedom to vary.
 Easy to understand. A good ADT hides its implementation behind a 
set of simple operations, so that programmers using the ADT only 
need to understand the operations, not the details of the 
implementation.
 Ready for change. Representation independence allows the 
implementation of an abstract data type to change without requiring 
changes from its clients.
6 Abstract Data Type (ADT)
Summary
 An invariant is a property that is always true of an ADT object 
instance, for the lifetime of the object.
 A good ADT preserves its own invariants. Invariants must be 
established by creators and producers, and preserved by observers 
and mutators.
 The rep invariant specifies legal values of the representation, and 
should be checked at runtime with checkRep() .  The abstraction function maps a concrete representation to the 
abstract value it represents.
 Representation exposure threatens both representation 
independence and invariant preservation.
6 Abstract Data Type (ADT)
Summary
 Safe from bugs. A good ADT preserves its own invariants, so that 
those invariants are less vulnerable to bugs in the ADT’s clients, and 
violations of the invariants can be more easily isolated within the 
implementation of the ADT itself. Stating the rep invariant explicitly, 
and checking it at runtime with checkRep(), catches 
misunderstandings and bugs earlier, rather than continuing on with 
a corrupt data structure.
 Easy to understand. Rep invariants and abstraction functions 
explicate the meaning of a data type’s representation, and how it 
relates to its abstraction.
 Ready for change. Abstract data types separate the abstraction from 
the concrete representation, which makes it possible to change the 
representation without having to change client code.
Software Construction
The end
May 24, 2021Software Construction
7 Object-Oriented Programming (OOP)
面向对象的编程
Wang Zhongjie
rainy@hit.edu.cn
May 25, 2021
7 Object-Oriented Programming (OOP)
Objective of this lecture
 Separating the interface of an abstract data type from its 
implementation, and using Java interface types to enforce that 
separation. 
 Define ADTs with interfaces, and write classes that implement 
interfaces.
 用OOP/接口/类实现ADT
3-3节学习了ADT理论
本节学习ADT的具体实现技术：OOP
7 Object-Oriented Programming (OOP)
Outline
 Basic concepts: object, class, attribute, method, interface, and 
enumerations OOP的基本概念
 Distinct features of OOP
Encapsulation and information hiding 封装与信息隐藏
Inheritance and overriding 继承与重写
Polymorphism, subtyping and overloading 多态、子类型、重载
*Static and Dynamic dispatch 静态与动态分派
 Some important Object methods in Java
 Designing good classes
 History of OOP
 Summary
7 Object-Oriented Programming (OOP)
Reading
 MIT 6.031：12
 CMU 17-214：Sep 3、Sep 10、Sep 19、Sep 24
 Java编程思想：第7-9章  代码大全：第6章  Effective Java：第3-4、7-9章
Software Construction
1 Basic concepts: object, class, 
attribute, and method
7 Object-Oriented Programming (OOP)
Object
 Real-world objects share two characteristics: they all have 
states and behaviors.  Identifying the state and behavior for real-world objects is a great 
way to begin thinking in terms of OOP. – Dogs have state (name, color, breed, hungry) and behavior (barking, 
fetching, wagging tail). – Bicycles have state (current gear, current pedal cadence, current speed) 
and behavior (changing gear, changing pedal cadence, applying brakes). 
 For each object that you see, ask yourself two questions, and these 
real-world observations all translate into the world of OOP: – What possible states can this object be in? 状态有哪些？ – What possible behavior can this object perform? 行为有哪些？
7 Object-Oriented Programming (OOP)
Object
 An object is a bundle of state and behavior
 State – the data contained in the object. – In Java, these are the fields of the object
 Behavior – the actions supported by the object – In Java, these are called methods – Method is just OO-speak for function
– invoke a method = call a function
7 Object-Oriented Programming (OOP)
Classes
 Every object has a class – A class defines methods and fields – Methods and fields collectively known as members
 Class defines both type and implementation
– type ≈ where the object can be used
– implementation ≈ how the object does things
 Loosely speaking, the methods of a class are its Application 
Programming Interface (API) – Defines how users interact with instances
7 Object-Oriented Programming (OOP)
Class example – complex numbers
7 Object-Oriented Programming (OOP)
Class usage example
7 Object-Oriented Programming (OOP)
Static vs. instance variables/methods of a class
 Class variable 类成员变量: a variable associated with the class 
rather than with an instance of the class. You can also associate 
methods with a class--class methods类方法. – To refer to class variables and methods, you join the class's name and the 
name of the class method or class variable together with a period ('.').
 Methods and variables that are not class methods or class variables 
are known as instance methods 实例方法 and instance variables 实
例成员变量. – To refer to instance methods and variables, you must reference the 
methods and variables from an instance of the class
 Summary: – Class variables and class methods are associated with a class and occur 
once per class. Using them doesn't require object creation. – Instance methods and variables occur once per instance of a class.
7 Object-Oriented Programming (OOP)
Static vs. instance variables/methods of a class
class DateApp {
public static void main(String args[]) {
Date today = new Date();
System.out.println(today);
} }
class Another {
public static void main(String[] args) {
int result;
result = Math.min(10, 20); 
System.out.println(result);
System.out.println(Math.max(100, 200));
} }
7 Object-Oriented Programming (OOP)
Static vs. instance variables/methods of a class
 Static methods are not associated with any particular instance of 
a class, while instance methods (declared without the static 
keyword) must be called on a particular object.
class Difference {
public static void main(String[] args) {
display(); //calling without object
Difference t = new Difference();
t.show(); //calling using object
}
static void display() {
System.out.println("Programming is amazing.");
}
void show(){
System.out.println("Java is awesome.");
} }
7 Object-Oriented Programming (OOP)
public class MyStatic {
private String name;
private static String staticStr = "STATIC-STRING";
public MyStatic (String n){
this.name = n;
}
public static void testStaticMethod(){
//you can call static variables here, can not call instance variables
System.out.println(MyStatic.staticStr); 
}
public void testObjectMethod(){
//you can also call static and instance variables here
System.out.println(MyStatic.staticStr); 
System.out.println("Name: "+this.name);
}
public static void main(String a[]){
//By using class name, you can call static method
MyStatic.testStaticMethod();
MyStatic msm = new MyStatic ("Java2novice");
msm.testObjectMethod();
} }
7 Object-Oriented Programming (OOP)
Static and Instance methods
Instance Methods Class Methods
Software Construction
2 Interface and Enumerations
7 Object-Oriented Programming (OOP)
Interface
 Java’s interface is a useful language mechanism for designing and 
expressing an ADT, with its implementation as a class 
implementing that interface. – An interface in Java is a list of method signatures, but no method bodies. – A class implements an interface if it declares the interface in its 
implements clause, and provides method bodies for all of the interface’s 
methods. – An interface can extend one or more others – A class can implement multiple interfaces – Interface和Class: 定义和实现ADT
– 接口之间可以继承与扩展 – 一个类可以实现多个接口（从而具备了多个接口中的方法） – 一个接口可以有多种实现类
7 Object-Oriented Programming (OOP)
An interface to go with the example class
7 Object-Oriented Programming (OOP)
Modifying class to use interface
7 Object-Oriented Programming (OOP)
Modifying client to use interface
7 Object-Oriented Programming (OOP)
Interface permits multiple implementations
7 Object-Oriented Programming (OOP)
Interface decouples client from implementation
7 Object-Oriented Programming (OOP)
Java interfaces and classes
 Interfaces vs. classes接口：确定ADT规约；类：实现ADT
– Interface: specifies expectations – Class: delivers on expectations (the implementation)
 Classes do define types 也可以不需要接口直接使用类作为ADT，既
有ADT定义也有ADT实现 – Public class methods usable like interface methods – Public fields directly accessible from other classes
 But prefer the use of interfaces 实际中更倾向于使用接口来定义变量 – Use interface types for variables and parameters unless you know one 
implementation will suffice. – Supports change of implementation; – Prevents dependence on implementation details
7 Object-Oriented Programming (OOP)
An Example
/** Represents an immutable set of elements of type E. */
public interface Set<E> {
/** make an empty set */
public Set();
/** @return true if this set contains e as a member */
public boolean contains(E e);
/** @return a set which is the union of this and that */
public ArraySet<E> union(Set<E> that); 
}
/** Implementation of Set<E>. */
public class ArraySet<E> implements Set<E> {
/** make an empty set */
public ArraySet() { ... }
/** @return a set which is the union of this and that */
public ArraySet<E> union(Set<E> that) { ... }
/** add e to this set */
public void add(E e) { ... }
}
Java interfaces can’t have constructors.
It isn’t representation-independent.
It’s missing the contains() method.
Java allowes classes to have more 
methods than the interface
This violates the spec for Set, its immutability, so 
ArraySet is not a legal implementation of Set. 
7 Object-Oriented Programming (OOP)
Using Interface+Class for ADT: MyString
7 Object-Oriented Programming (OOP)
Implementation 1 of MyString
7 Object-Oriented Programming (OOP)
Implementation 2 of MyString
7 Object-Oriented Programming (OOP)
Why multiple implementations?
 Different performance – Choose implementation that works best for your use
 Different behavior – Choose implementation that does what you want – Behavior must comply with interface spec (“contract”)
 Often performance and behavior both vary
– Provides a functionality – performance tradeoff – Example: HashSet, TreeSet
7 Object-Oriented Programming (OOP)
To use MyString and its implementations
 Problem: breaks the abstraction barrier – Clients must know the name of the concrete representation class. – Because interfaces in Java cannot contain constructors, they must directly 
call one of the concrete class’ constructors. – The spec of that constructor won’t appear anywhere in the interface, so 
there’s no static guarantee that different implementations will even 
provide the same constructors. – 打破了抽象边界，接口定义中没有包含constructor，也无法保证所有实现类
中都包含了同样名字的constructor。 – 故而，客户端需要知道该接口的某个具体实现类的名字
7 Object-Oriented Programming (OOP)
Using static factory instead of constructor
From Java 8 interfaces are allowed to contain static methods.
7 Object-Oriented Programming (OOP)
Using default methods in an interface
 In a typical design based on abstractions, where an interface has one 
or multiple implementations, if one or more methods are added to 
the interface, all the implementations will be forced to implement 
them too. Otherwise, the design will just break down. 接口中的每个
方法在所有类中都要实现
 default interface methods are an efficient way to deal with this 
issue. They allow us to add new methods to an interface that are 
automatically available in the implementations. Thus, there‘s no 
need to modify the implementing classes. 通过default方法，在接口
中统一实现某些功能，无需在各个类中重复实现它。
 The most typical use of default methods in interfaces is to 
incrementally provide additional functionality to a given type 
without breaking down the implementing classes. 以增量式的为接口
增加额外的功能而不破坏已实现的类
7 Object-Oriented Programming (OOP)
Using default methods in an interface
public interface Example {
default int method1(int a) {…}
static int method2(int b) {…}
public int method3();
}
public class C implements Example {
@Override
public int method3() {…}
public static void main(String[] args) {
Example.method2(2);
C c = new C();
c.method1(1);
c.method3();
} }
7 Object-Oriented Programming (OOP)
Summary of Interface
 Safe from bugs – An ADT is defined by its operations, and interfaces do just that. – When clients use an interface type, static checking ensures that they only 
use methods defined by the interface. – If the implementation class exposes other methods — or worse, has visible 
representation — the client can’t accidentally see or depend on them. – When we have multiple implementations of a data type, interfaces 
provide static checking of the method signatures.
7 Object-Oriented Programming (OOP)
Summary of Interface
 Easy to understand. – Clients and maintainers know exactly where to look for the specification 
of the ADT. – Since the interface doesn’t contain instance fields or implementations of 
instance methods, it’s easier to keep details of the implementation out of 
the specifications.
 Ready for change. – We can easily add new implementations of a type by adding classes that 
implement interface. – If we avoid constructors in favor of static factory methods, clients will 
only see the interface. – That means we can switch which implementation class clients are using 
without changing their code at all.
7 Object-Oriented Programming (OOP)
Enumerations
 Sometimes a type has a small, finite set of immutable values, such as: – Months of the year: January, February, …, November, December – Days of the week: Monday, Tuesday, …, Saturday, Sunday – Compass points: north, south, east, west
 When the set of values is small and finite, it makes sense to define all 
the values as named constants, called an enumeration. Java has the 
enum construct.
public enum Month { 
JANUARY, FEBRUARY, MARCH, ..., 
OCTOBER, NOVEMBER, DECEMBER;
}
public enum PenColor { 
BLACK, GRAY, RED, ..., BLUE;
}
PenColor drawingColor = PenColor.RED;
Month month = Month.MARCH;
if(month.equals(Month.MARCH)) {...}
for(Month m : Month.values()) 
m.name();
m.ordinal();
m.comparedTo();
m.toString();
...
7 Object-Oriented Programming (OOP)
Add data and behaviors to enumerations
public enum Planet {
MERCURY(3.302e+23, 2.439e6), VENUS (4.869e+24, 6.052e6),
EARTH(5.975e+24, 6.378e6), MARS(6.419e+23, 3.393e6);
private final double mass; // In kg.
private final double radius; // In m.
private static final double G = 6.67300E-11;
Planet(double mass, double radius) {
this.mass = mass;
this.radius = radius;
}
public double mass() { return mass; }
public double radius() { return radius; }
public double surfaceGravity() {
return G * mass / (radius * radius);
} } for (Planet p : Planet.values()) 
System.out.println(p.surfaceGravity());
Software Construction
4 Encapsulation and information 
hiding
7 Object-Oriented Programming (OOP)
Information hiding
 Single most important factor that distinguishes a well-designed 
module from a bad one is the degree to which it hides internal data 
and other implementation details from other modules
 Well-designed code hides all implementation details – Cleanly separates API from implementation
– Modules communicate only through APIs – The are oblivious to each others’ inner workings
 Known as information hiding or encapsulation, a fundamental 
tenet of software design.
7 Object-Oriented Programming (OOP)
Benefits of information hiding
 Decouples the classes that comprise a system
– Allows them to be developed, tested, optimized, used, understood, and 
modified in isolation
 Speeds up system development – Classes can be developed in parallel
 Eases burden of maintenance – Classes can be understood more quickly and debugged with little fear of 
harming other modules
 Enables effective performance tuning
– “Hot” classes can be optimized in isolation
 Increases software reuse – Loosely-coupled classes often prove useful in other contexts
7 Object-Oriented Programming (OOP)
Information hiding with interfaces
 Declare variables using interface type 使用接口类型声明变量
 Client can use only interface methods 客户端仅使用接口中定义的
方法
 Fields not accessible from client code 客户端代码无法直接访问属性
 But this only takes us so far – Client can access non-interface members directly
– In essence, it’s voluntary information hiding
7 Object-Oriented Programming (OOP)
Visibility modifiers for members
 private – Accessible only from declaring class
 protected – Accessible from subclasses of declaring class (and 
within package)
 public – Accessible from anywhere
7 Object-Oriented Programming (OOP)
Best practices for information hiding
 Carefully design your API
 Provide only functionality required by clients, and all other 
members should be private
 You can always make a private member public later without 
breaking clients – But not vice-versa!
7 Object-Oriented Programming (OOP)
Classroom Exercises
class Wallet {
private int amount;
public void loanTo(Wallet that) {
/*A*/ that.amount += this.amount;
/*B*/ amount = 0;
}
public static void main(String[] args) {
/*C*/ Wallet w = new Wallet();
/*D*/ w.amount = 100;
/*E*/ w.loanTo(w);
}
} 
class Person {
private Wallet w;
public int getNetWorth() {
/*F*/ return w.amount;
}
public boolean isBroke() {
/*G*/ return Wallet.amount == 0;
} }
Are there any errors for 
each line of A-G? 
Software Construction
5 Inheritance and Overriding
7 Object-Oriented Programming (OOP)
Variation in the real world
 Two types of “Bank Account”
7 Object-Oriented Programming (OOP)
Interface inheritance for an account type hierarchy
Software Construction
(1) Overriding
7 Object-Oriented Programming (OOP)
Rewriteable Methods and Strict Inheritance
 Rewriteable Method: A method which allow a re-implementation. – In Java methods are rewriteable by default, i.e. there is no special 
keyword. 
 Strict inheritance (严格继承：子类只能添加新方法，无法重写超类中
的方法) – The subclass can only add new methods to the superclass, it cannot 
overwrite them
– If a method cannot be overwritten in a Java program, it must be prefixed 
with the keyword final.
7 Object-Oriented Programming (OOP)
 Superclass
 Subclass
Strict Inheritance
drive()
brake()
accelerate()
Car
playMusic()
ejectCD()
resumeMusic()
pauseMusic()
LuxuryCar
public class LuxuryCar extends Car {
public void playMusic() {…}
public void ejectCD() {…}
public void resumeMusic() {…}
public void pauseMusic() {…}
}
public class Car {
public final void drive() {…}
public final void brake() {…}
public final void accelerate() {…}
}
7 Object-Oriented Programming (OOP)
Strict Inheritance and Rewriteable Methods 
class Device {
int serialnr;
public final void help() {….}
public void setSerialNr(int n) {
serialnr = n;
} }
class Valve extends Device {
Position s;
public void setSerialNr(int n) {
...
} }
help() not 
overwritable
setSerialNr()
overwritable
7 Object-Oriented Programming (OOP)
final
 A final field: prevents reassignment to the field after initialization
 A final method: prevents overriding the method
 A final class: prevents extending the class – e.g., public final class CheckingAccountImpl { ... }
7 Object-Oriented Programming (OOP)
Overriding (覆盖/重写)  Method overriding is a language feature that allows a subclass or 
child class to provide a specific implementation of a method that is 
already provided by one of its superclasses or parent classes. – The same name, same parameters or signature, and same return type. 重写
的函数：完全同样的signature – The version of a method that is executed will be 
determined by the object that is used to invoke it. 
实际执行时调用哪个方法，运行时决定。 – If an object of a parent class is used to invoke the 
method, then the version in the parent class will be 
executed; – If an object of the subclass is used to 
invoke the method, then the version in the child 
class will be executed. 
7 Object-Oriented Programming (OOP)
Example: Overwriting a Method
class Device {
int serialnr;
public final void help() {….}
public void setSerialNr(int n) {
serialnr = n;
} }
class Valve extends Device {
Position s;
public void on() {
… 
}
public void setSerialNr(int n) {
serialnr = n + s.serialnr;
} }
父类型中的被重写函数体不为空：意
味着对其大多数子类型来说，该方法
是可以被直接复用的。
对某些子类型来说，有特殊性，故重
写父类型中的函数，实现自己的特殊
要求
7 Object-Oriented Programming (OOP)
Rewriteable Methods are set to empty
class Device {
int serialnr;
public void setSerialNr(int n) {}
}
class Valve extends Device {
Position s;
public void on() {
…..
}
public void setSerialNr(int n) {
seriennr = n + s.serialnr;
}
} // class Valve
I expect that the method 
setSerialNr() will be 
overwritten. I only write 
an empty body
Overwriting of the 
method setSerialNr() 
of Class Device
如果父类型中的某个函数实现体为空，
意味着其所有子类型都需要这个功能，
但各有差异，没有共性，在每个子类中
均需要重写。
7 Object-Oriented Programming (OOP)
Overriding (覆盖/重写)  When a subclass contains a method that overrides a method of the 
superclass, it can also invoke the superclass method by using the 
keyword super. class Thought {
public void message() {
System.out.println(“Thought.");
} }
public class Advice extends Thought {
@Override // @Override annotation in Java 5 is optional but helpful.
public void message() {
System.out.println(“Advice.");
super.message(); // Invoke parent's version of method.
} }
Thought parking = new Thought();
parking.message(); // Prints "Thought."
Thought dates = new Advice(); 
dates.message(); // Prints “Advice. \n Thought."
重写之后，利用super()复用了父类
型中函数的功能，并对其进行了扩展
7 Object-Oriented Programming (OOP)
Extended reuse with super
重写之后，利用super()复用了父类
型中函数的功能，并对其进行了扩展
7 Object-Oriented Programming (OOP)
Constructors with this and super
Constructor call must be the 
first statement in a constructor
7 Object-Oriented Programming (OOP)
Bad Use of Overwriting Methods
 One can overwrite the operations of a superclass with completely 
new meanings. 重写的时候，不要改变原方法的本意
 Example:
Public class SuperClass {
public int add (int a, int b) { return a+b; }
public int subtract (int a, int b) { return a-b; }
}
Public class SubClass extends SuperClass {
public int add (int a, int b) { return a-b; }
public int subtract (int a, int b) { return a+b; }
}  We have redefined addition as subtraction and subtraction as 
addition!! 
Software Construction
(2) Abstract Class
7 Object-Oriented Programming (OOP)
Abstract Methods and Abstract Classes
 Abstract method: – A method with a signature but without an implementation (also called 
abstract operation) – Defined by the keyword abstract
 Abstract class: – A class which contains at least one abstract method is called abstract class
 Interface: An abstract class which has only abstract methods – An interface is primarily used for the specification of a system or 
subsystem. The implementation is provided by a subclass or by other 
mechanisms. 
 Concrete class  Abstract Class  Interface
7 Object-Oriented Programming (OOP)
An example of abstract class
abstract class GraphicObject {
int x, y;
...
void moveTo(int newX, int newY) {
...
}
abstract void draw();
abstract void resize();
}
class Circle extends GraphicObject {
void draw() {
...
}
void resize() {
...
} }
class Rectangle extends GraphicObject {
void draw() {
...
}
void resize() {
...
} }
如果某些操作是所有子类型都共有，
但彼此有差别，可以在父类型中设计
抽象方法，在各子类型中重写
所有子类型完全相同的操作，
放在父类型中实现，子类型中
无需重写。
有些子类型有而其他子类型无
的操作，不要在父类型中定义
和实现，而应在特定子类型中
实现。
7 Object-Oriented Programming (OOP)
Implementation inheritance for code reuse
An abstract class is missing 
the implementation of one or 
more methods
Protected elements are 
visible in subclasses
An abstract method is left to 
be implemented in a subclass
No need to define 
getBalance(), and the code 
is inherited from 
AbstractAccount
Software Construction
6 Polymorphism, subtyping and 
overloading
多态、子类型、重载
Software Construction
(1) Three Types of Polymorphism
7 Object-Oriented Programming (OOP)
Three Types of Polymorphism (多态)  Ad hoc polymorphism (特殊多态): when a function denotes different 
and potentially heterogeneous implementations depending on a 
limited range of individually specified types and combinations. Ad 
hoc polymorphism is supported in many languages using function 
overloading (功能重载).  Parametric polymorphism (参数化多态): when code is written 
without mention of any specific type and thus can be used 
transparently with any number of new types. In the object-oriented 
programming community, this is often known as generics or generic 
programming.  Subtyping (also called subtype polymorphism or inclusion 
polymorphism 子类型多态、包含多态): when a name denotes 
instances of many different classes related by some common 
superclass. 
Software Construction
(2) Ad hoc polymorphism and 
Overloading
7 Object-Oriented Programming (OOP)
Ad hoc polymorphism
 Ad-hoc polymorphism is obtained when a function works on several 
different types (which may not exhibit a common structure) and may 
behave in unrelated ways for each type. 
public class OverloadExample {
public static void main(String args[]) {
System.out.println(add("C","D"));
System.out.println(add("C","D","E"));
System.out.println(add(2,3));
}
public static String add(String c, String d) {
return c.concat(d);
}
public static String add(String c, String d, String e){
return c.concat(d).concat(e);
}
public static int add(int a, int b) {
return a+b;
} }
7 Object-Oriented Programming (OOP)
Overloading
 Overloaded methods let you reuse the same method name in a 
class, but with different arguments (and optionally, a different 
return type). 
 Overloading a method often means you're being a little nicer to 
those who call your methods, because your code takes on the 
burden of coping with different argument types rather than forcing 
the caller to do conversions prior to invoking your method.
 重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型
 价值：方便client调用，client可用不同的参数列表，调用同样的函数
7 Object-Oriented Programming (OOP)
Overloading (重载)  doTask() and doTask(Object O) are overloaded methods. – To call the latter, an object must be passed as a parameter, whereas the 
former does not require a parameter, and is called with an empty 
parameter field. – A common error would be to assign a default value to the object in the 
second method, which would result in an ambiguous call error, as the 
compiler wouldn't know which of the two methods to use. 
 A method print(Object O):one might like the method to be 
different when printing, for example, text or pictures. – Two different methods may be overloaded as print(text_object T); 
print(image_object P). – If we write the overloaded print methods for all objects our program will 
"print", we never have to worry about the type of the object, and the 
correct function call again, the call is always: print(something).
7 Object-Oriented Programming (OOP)
Overloading (重载)  Function overloading is the ability to create multiple methods of the 
same name with different implementations. – Calls to an overloaded function will run a specific implementation of that 
function appropriate to the context of the call, allowing one function call 
to perform different tasks depending on context.
 Overloading is a static polymorphism 静态多态 – A function call is resolved using the ‘best match technique’, i.e. the 
function is resolved depending upon the argument list. 根据参数列表进行
最佳匹配 – Static type checking in function calls 静态类型检查 – The determination of which of these methods are used is resolved at 
compile time. 在编译阶段时决定要具体执行哪个方法 (static type checking) – 与之相反，overridden methods则是在run-time进行dynamic checking！
7 Object-Oriented Programming (OOP)
Overloading rules 
 Rules in function overloading: the overloaded function must differ 
either by the arity or data types – MUST change the argument list. 不同的参数列表 – CAN change the return type. 相同/不同的返回值类型 – CAN change the access modifier. 相同/不同的public/private/protected
– CAN declare new or broader checked exceptions. 异常 – A method can be overloaded in the same class or in a subclass. 可以在同
一个类内重载，也可在子类中重载
7 Object-Oriented Programming (OOP)
Legal Overloads
public void changeSize(int size, 
String name, float pattern) { }
 The following methods are legal overloads of the changeSize() 
method: – public void changeSize(int size, String name) { } – public int changeSize(int size, float pattern) { } – public void changeSize(float pattern, String name){ } – public void changeSize(int length, String pattern, float 
size){ } – public boolean changeSize(int size, String name, float 
pattern) { }
The same signature!
No changes on parameters
7 Object-Oriented Programming (OOP)
Invoking overloaded methods
public class Adder {
public int addThem(int x, int y) {
return x + y;
}
public double addThem(double x, double y) {
return x + y;
} }
public class TestAdder {
public static void main (String [] args) {
Adder a = new Adder();
int b = 27;
int c = 3;
// Which addThem is invoked? 
int result = a.addThem(b,c); 
double doubleResult = a.addThem(22.5,9.3); 
System.out.println (result);
System.out.println (doubleResult);
} }
7 Object-Oriented Programming (OOP)
Invoking overloaded methods
class Animal { 
public void eat() {}
}
class Horse extends Animal {
public void eat(String food) {}
}
public class UseAnimals {
public void doStuff(Animal a) {
System.out.println("Animal");
}
public void doStuff(Horse h) {
System.out.println("Horse");
} }
public class TestUseAnimals {
public static void main (String [] args) {
UseAnimals ua = new UseAnimals();
Animal animalobj = new Animal();
Horse horseobj = new Horse();
Animal animalRefToHorse = new Horse();
ua.doStuff(animalobj);
ua.doStuff(horseobj);
ua.doStuff(animalRefToHorse);
} }
Which overridden version of the method to call is decided at runtime based 
on object type, but which overloaded version of the method to call is based 
on the reference type of the argument passed at compile time. 
“Animal”
Overload也可以发生在父类和子类之间
7 Object-Oriented Programming (OOP)
Invoking overloaded methods
class Animal { 
public void eat() {}
}
class Horse extends Animal {
public void eat(String food) {}
}
7 Object-Oriented Programming (OOP)
Check your understanding
 What will happen?
Compile: Cannot Instantiate the 
type Animal
“Woof!”
“Moo!”
Compile: The method moo() is 
undefined for the type 
Animal
7 Object-Oriented Programming (OOP)
Overriding vs. Overloading
public class Test { 
 public static void main(String[] args) { 
 A a = new A(); 
 a.p(10); 
 } 
} 
class B { 
 public void p(int i) { 
 } 
} 
class A extends B { 
 // This method overrides the method in B 
 public void p(int i) { 
 System.out.println(i); 
 } 
}
public class Test { 
 public static void main(String[] args) { 
 A a = new A(); 
 a.p(10); 
 } 
} 
class B { 
 public void p(int i) { 
 } 
} 
class A extends B { 
 // This method overloads the method in B 
 public void p(double i) { 
 System.out.println(i); 
 } 
}
The method p(int i) in class A 
overrides the same method defines 
in class B.
The method p(int i) in class A 
overloads the same method defines 
in class B.
7 Object-Oriented Programming (OOP)
Overriding vs. Overloading
 Do not confuse overriding a method in a derived class with 
overloading a method name – When a method is overridden, the new method definition given in the 
derived class has the exact same number and types of parameters as in the 
base class – When a method in a derived class has a different signature from the 
method in the base class, that is overloading
– Note that when the derived class overloads the original method, it still 
inherits the original method from the base class as well
7 Object-Oriented Programming (OOP)
Overriding vs. Overloading
Overloading Overriding
Argument list Must change Must not change
Return type Can Change Must not change
Exceptions Can Change
Can reduce or eliminate 
Must not throw new or 
broader checked exception
Access Can Change
Must not make more 
restrictive (can be less 
restrictive)
Invocation
Reference type determines which overloaded 
version (based on declared argument types) is 
selected. Happens at compile time. The actual 
method that's invoked is still a virtual method 
invocation that happens at runtime, but the 
compiler will always know the signature of 
the method that is to be invoked. So at 
runtime, the argument match will have 
already been nailed down, just not the actual 
class in which the method lives
Object type (in other words, 
the type of the actual 
instance on the heap) 
determines which method 
is selected.
Happens at runtime.
Software Construction
(3) Parametric polymorphism and 
Generic programming
7 Object-Oriented Programming (OOP)
Parametric polymorphism
 Parametric polymorphism is obtained when a function works 
uniformly on a range of types; these types normally exhibit some 
common structure. – It the ability to define functions and types in a generic way so that it works 
based on the parameter passed at runtime, i.e., allowing static type￾checking without fully specifying the type. – This is what is called “Generics (泛型)” in Java.
 Generic programming is a style of programming in which data types 
and functions are written in terms of types to-be-specified-later that 
are then instantiated when needed for specific types provided as 
parameters. 
Generic programming centers around the idea of abstracting from 
concrete, efficient algorithms to obtain generic algorithms that can be 
combined with different data representations to produce a wide variety of 
useful software.
7 Object-Oriented Programming (OOP)
Template in C++
template<typename T>
class List {
/* class contents */
};
List<Animal> list_of_animals;
List<Car> list_of_cars;
template<typename T>
void Swap(T & a, T & b) {
T temp = b;
b = a;
a = temp;
}
string hello = “world!”
string world = “Hello,”;
Swap( world, hello );
cout << hello << world << endl;
C++ Standard Library includes 
the Standard Template Library 
(STL) that provides a framework 
of templates for common data 
structures and algorithms. 
7 Object-Oriented Programming (OOP)
Generics in Java
 A type variable is an unqualified identifier 类型变量. – They are introduced by generic class declarations, generic interface 
declarations, generic method declarations, and by generic constructor 
declarations.
 A class is generic if it declares one or more type variables. 泛型类：
其定义中包含了类型变量 – These type variables are known as the type parameters of the class. – It defines one or more type variables that act as parameters. – A generic class declaration defines a set of parameterized types, one for 
each possible invocation of the type parameter section. – All of these parameterized types share the same class at runtime.
7 Object-Oriented Programming (OOP)
Generics in Java
 An interface is generic if it declares type variables 泛型接口 – These type variables are known as the type parameters of the interface. – It defines one or more type variables that act as parameters. – A generic interface declaration defines a set of types, one for each possible 
invocation of the type parameter section. – All parameterized types share the same interface at runtime.
 A method is generic if it declares type variables.泛型方法 – These type variables are known as the formal type parameters of the 
method. – The form of the formal type parameter list is identical to a type parameter 
list of a class or interface.
7 Object-Oriented Programming (OOP)
Type variables
 Using <>, the diamond operator, to help declare type variables.
 For example: – List<Integer> ints = new ArrayList<Integer>(); – public interface List<E> – public class Entry<KeyType, ValueType>
7 Object-Oriented Programming (OOP)
public class PapersJar<T> {
private List<T> itemList = new ArrayList<>();
public void add(T item) {
itemList.add(item);
}
public T get(int index) {
return (T) itemList.get(index);
}
public static void main(String args[]) {
PapersJar<String> papersStr = new PapersJar<>();
papersStr.add("Lion");
String str = (String) papersStr.get(0);
System.out.println(str);
PapersJar papersInt = new PapersJar();
papersInt.add(new Integer(100));
Integer integerObj = (Integer) papersInt.get(0);
System.out.println(integerObj);
} }
7 Object-Oriented Programming (OOP)
Example
public class Pair<E> {
private final E first, second;
public Pair(E first, E second) {
this.first = first;
this.second = second;
}
public E first() { return first; }
public E second() { return second; }
}
Client:
Pair<String> p = new Pair<>("Hello", "world");
String result = p.first();
7 Object-Oriented Programming (OOP)
Another example: Java Set
 Set is the ADT of finite sets of elements of some other type E .  Set is an example of a generic type : a type whose specification is 
in terms of a placeholder type to be filled in later. 
 Instead of writing separate specifications and implementations for 
Set<String> , Set<Integer> , and so on, we design and 
implement one Set<E> . 
7 Object-Oriented Programming (OOP)
Another example: Java Set
 Creator
 Observer
 Mutator
7 Object-Oriented Programming (OOP)
Generic Interfaces
 Suppose we want to implement the generic Set<E> interface. – Way 1: Generic interface, non-generic implementation: to implement 
Set<E> for a particular type E . 泛型接口，非泛型的实现类
7 Object-Oriented Programming (OOP)
Generic Interfaces
 Way 2: Generic interface, generic implementation. 泛型接口，泛型
的实现类 – We can also implement the generic Set<E> interface without picking a 
type for E . – In that case, we write our code blind to the actual type that clients will 
choose for E . – Java’s HashSet does that for Set.
7 Object-Oriented Programming (OOP)
Some Java Generics details
 Can have multiple type parameters – e.g., Map<E, F>, Map<String, Integer>
 Wildcards 通配符，只在使用泛型的时候出现，不能在定义中出现 – List<?> list = new ArrayList<String>(); – List<? extends Animal> – List<? super Animal>
 Generic type info is erased (i.e. compile-time only) – Cannot use instanceof() to check generic type 运行时泛型消失了！
 Cannot create Generic arrays – Pair<String>[] foo = new Pair<String>[42]; // won't compile
Software Construction
(4) Subtyping Polymorphism
7 Object-Oriented Programming (OOP)
Subtypes
 A type is a set of values. – The Java List type is defined by an interface. – If we think about all possible List values, none of them are List objects: 
we cannot create instances of an interface. – Instead, those values are all ArrayList objects, or LinkedList objects, or 
objects of another class that implements List .  A subtype is simply a subset of the supertype – ArrayList and LinkedList are subtypes of List.
7 Object-Oriented Programming (OOP)
Inheritance and Subtype: a glimpse at the hierarchy 
 Java Collections API
 Benefits of inheritance/subtype: Reuse of code, Modeling flexibility 
 In Java: Each class can directly extend only one parent class; A class 
can implement multiple interfaces.
7 Object-Oriented Programming (OOP)
Subtypes
 “B is a subtype of A” means “every B is an A.” 
 In terms of specifications: “every B satisfies the specification for A.” – B is only a subtype of A if B’s specification is at least as strong as A’s 
specification. – When we declare a class that implements an interface, the Java compiler 
enforces part of this requirement automatically: it ensures that every 
method in A appears in B, with a compatible type signature. – Class B cannot implement interface A without implementing all of the 
methods declared in A.
7 Object-Oriented Programming (OOP)
Static checking on subtypes
 But the compiler cannot check that we haven’t weakened the 
specification in other ways: – Strengthening the precondition on some inputs to a method
– Weakening a postcondition
– Weakening a guarantee that the interface abstract type advertises to 
clients. 
 If you declare a subtype in Java (e.g., implementing an interface), 
then you must ensure that the subtype’s spec is at least as strong as 
the supertype’s.
 子类型的规约不能弱化超类型的规约。
7 Object-Oriented Programming (OOP)
Subtype polymorphism
 Subtype polymorphism: Different kinds of objects can be treated 
uniformly by client code 
子类型多态：不同类型的对象可以统一的处理而无需区分
 Each object behaves according to its type (e.g., if you add new kind 
of account, client code does not change) 从而隔离了“变化”
 Liskov Substitution Principle (LSP): – If S is a subtype of T, then objects of type T may be replaced with objects 
of type S (i.e. an object of type T may be substituted with any object of a 
subtype S) without altering any of the desirable properties of T.
 Section 5-2 Reusability
7 Object-Oriented Programming (OOP)
An example
The stronger requirement 
width = height violates 
the contract of the interface 
 Stronger precondition
This postcondition requires 
different behavior, 
incompatible with the 
original spec.
7 Object-Oriented Programming (OOP)
An example
A weaker postcondition
Overload ! 
7 Object-Oriented Programming (OOP)
instanceof
 Operator that tests whether an object is of a given class
 Advice: avoid instanceof() if possible, and never(?) use 
instanceof() in a superclass to check type against subclass.
7 Object-Oriented Programming (OOP)
Type casting
 Sometimes you want a different type than you have
double pi = 3.14;
int indianaPi = (int) pi;
 Useful if you know you have a more specific subtype:
Account acct = …;
CheckingAccount checkingAcct = (CheckingAccount) acct;
long fee = checkingAcct.getFee();
 But it will get a ClassCastException if types are incompatible
 Advice: – Avoid downcasting types WHY? – Never(?) downcast within superclass to a subclass WHY?
Software Construction
9 *Dynamic dispatch
7 Object-Oriented Programming (OOP)
Dynamic dispatch
 Dynamic dispatch is the process of selecting which 
implementation of a polymorphic operation to call at run time. – Object-oriented systems model a problem as a set of interacting objects 
that enact operations referred to by name. – Polymorphism is the phenomenon wherein somewhat interchangeable 
objects each expose an operation of the same name but possibly differing 
in behavior. 
Determining which method to call at 
runtime, i.e., a call to an overridden or 
polymorphic method is resolved at 
runtime
7 Object-Oriented Programming (OOP)
Dynamic dispatch
 As an example, a File object and a Database object both have 
a StoreRecord method that can be used to write a personnel record 
to storage. Their implementations differ.
 A program holds a reference to an object which may be either 
a File object or a Database object. Which it is may have been 
determined by a run-time setting, and at this stage, the program 
may not know or care which. 
 When the program calls StoreRecord on the object, something 
needs to decide which behavior gets enacted. 
 The program sends a StoreRecord message to an object of 
unknown type, leaving it to the run-time support system to 
dispatch the message to the right object. The object enacts 
whichever behavior it implements.
7 Object-Oriented Programming (OOP)
Dynamic dispatch
dividend.divide(divisor) # dividend / divisor
 This is thought of as sending a message named divide with 
parameter divisor to dividend.  An implementation will be chosen based only on dividend's type 
(perhaps rational, floating point, matrix), disregarding the type or 
value of divisor.
7 Object-Oriented Programming (OOP)
Dynamic dispatch
 Dynamic dispatch contrasts with static dispatch, in which the 
implementation of a polymorphic operation is selected at compile￾time. 
 The purpose of dynamic dispatch is to support cases where the 
appropriate implementation of a polymorphic operation cannot be 
determined at compile time because it depends on the runtime 
type of one or more actual parameters to the operation.
 静态分派：编译阶段即可确定要执行哪个具体操作。
Overloaded methods are bonded using static binding 
while overridden methods are bonded using dynamic 
binding at runtime.
7 Object-Oriented Programming (OOP)
Dynamic dispatch
 Dynamic dispatch is different from late binding (also known as 
dynamic binding 推迟绑定). – When selecting an operation, binding associates a name to an operation. – Dispatching chooses an implementation for the operation after you have 
decided which operation a name refers to. – 绑定：将调用的名字与实际的方法名字联系起来（可能很多个）；分派：具
体执行哪个方法（early binding  static dispatch） – With dynamic dispatch, the name may be bound to a polymorphic 
operation at compile time, but the implementation not be chosen until run 
time. 动态分派：编译阶段可能绑定到多态操作，运行阶段决定具体执行哪
个（override和overload均是如此）； – While dynamic dispatch does not imply late binding, late binding does 
imply dynamic dispatching since the binding is what determines the set of 
available dispatches. 推迟绑定：编译阶段不知道类型，一定是动态分派（
override是推迟绑定，overload是early binding）
7 Object-Oriented Programming (OOP)
Early/static binding
 Whenever a binding of static, private and final methods happen, 
type of the class is determined by the compiler at compile time and 
the binding happens then and there.
class Human{
public static void walk() {
System.out.println("Human walks");
} }
class Boy extends Human{
public static void walk(){
System.out.println("Boy walks");
}
public static void main( String args[]) {
Human obj = new Boy();
Human obj2 = new Human();
obj.walk();
obj2.walk();
} }
7 Object-Oriented Programming (OOP)
Late/dynamic binding
 In overriding both parent and child classes have same method and 
in this case the type of the object determines which method is to be 
executed. The type of object is determined at the run.
class Human{
public void walk() {
System.out.println("Human walks");
} }
class Boy extends Human{
public void walk(){
System.out.println("Boy walks");
}
public static void main( String args[]) {
Human obj = new Boy();
Human obj2 = new Human();
obj.walk();
obj2.walk();
} }
7 Object-Oriented Programming (OOP)
Dynamic method dispatch
1. (Compile time) Determine which class to look in
2. (Compile time) Determine method signature to be executed
– Find all accessible, applicable methods – Select most specific matching method
3. (Run time) Determine dynamic class of the receiver
4. (Run time) From dynamic class, locate method to invoke – Look for method with the same signature found in step 2 – Otherwise search in superclass and etc.
7 Object-Oriented Programming (OOP)
Example
class Game {
public void type(){ 
System.out.println("Indoor & outdoor"); }
}
class Cricket extends Game {
public void type() { 
System.out.println("outdoor game"); }
public static void main(String[] args) {
Game gm = new Game();
Cricket ck = new Cricket();
gm.type();
ck.type();
gm=ck; //gm refers to Cricket object
gm.type(); //calls Cricket's version of type
}}
Upcasting: a 
Parent class 
variable refers to 
Child class object
Override方法
Late biding
Dynamic dispatch
Late binding
Dynamic dispatch
Early binding
Static dispatch
Late binding
Dynamic dispatch
Software Construction
10 Some important Object methods
in Java
7 Object-Oriented Programming (OOP)
Overriding Object methods
 equals() – true if the two objects are “equal”
 hashCode() – a hash code for use in hash maps
 toString() – a printable string representation
 toString() – ugly and uninformative – You know what your object is so you can do better – Always override unless you know in won’t be called
 equals & hashCode – identity semantics – You must override if you want value semantics – Otherwise don’t
7 Object-Oriented Programming (OOP)
Overriding toString()
7 Object-Oriented Programming (OOP)
equals Override Example
7 Object-Oriented Programming (OOP)
hashCode override example
7 Object-Oriented Programming (OOP)
Alternative hashCode override
 Less efficient, but otherwise equally good!
7 Object-Oriented Programming (OOP)
What does this print?
 Name overrides hashCode but not equals! The two Name instances 
are thus unequal.
7 Object-Oriented Programming (OOP)
How do you fix it?
 Replace the overloaded equals method with an overriding equals 
method.
Software Construction
11 Designing good classes
7 Object-Oriented Programming (OOP)
Advantages of immutable classes
 Simplicity
 Inherently Thread-Safe
 Can be shared freely
 No need for defensive copies
 Excellent building blocks
7 Object-Oriented Programming (OOP)
How to write an immutable class
 Don’t provide any mutators
 Ensure that no methods may be overridden
 Make all fields final
 Make all fields private
 Ensure security of any mutable components (avoid rep exposure)
 Implement toString(), hashCode(), clone(), equals(), etc.
7 Object-Oriented Programming (OOP)
Immutable class example
7 Object-Oriented Programming (OOP)
Immutable class example
7 Object-Oriented Programming (OOP)
When to make classes immutable
 Always, unless there's a good reason not to
 Always make small “value classes” immutable! – Examples: Color, PhoneNumber, Unit – Date and Point were mistakes! – Experts often use long instead of Date
7 Object-Oriented Programming (OOP)
When to make classes mutable
 Class represents entity whose state changes – Real-world - BankAccount, TrafficLight – Abstract - Iterator, Matcher, Collection – Process classes - Thread, Timer
 If class must be mutable, minimize mutability
– Constructors should fully initialize instance – Avoid reinitialize methods
Software Construction
12 History of OOP
7 Object-Oriented Programming (OOP)
Simulation and the origins of OO programming
 1960s: Simula 67 was the first object-oriented language developed by 
Kristin Nygaard and Ole-Johan Dahl at the Norwegian Computing 
Center, to support discrete-event simulation. (Class, object, inheritance, 
etc)
 The term "object oriented programming (OOP) " was first used by 
Xerox PARC in their Smalltalk language. 
 1980s: OOP had become prominent, and the primary factor in this is 
C++.
 Niklaus Wirth for modular programming and data abstraction, with 
Oberon and Modula-2;
 Eiffel and Java
7 Object-Oriented Programming (OOP)
History of OOP languanges
Software Construction
Summary
7 Object-Oriented Programming (OOP)
Summary
 Criteria of Object-Orientation
 Basic concepts: object, class, attribute, method, and interface
 Distinct features of OOP
Encapsulation and information hiding
Inheritance and overriding
Polymorphism, subtyping and overloading
Static and Dynamic dispatch
 Some important Object methods in Java
 To write an immutable class
 History of OOP
 Summary
Software Construction
The end
May 25, 2021Software Construction
8 Equality in ADT and OOP
ADT和OOP中的“等价性”
Wang Zhongjie
rainy@hit.edu.cn
May 31, 2021
8 Equality in ADT and OOP
Objective of this lecture
 Understand the properties of an equivalence relation. 等价关系
 Understand equality for immutable types defined in terms of the 
abstraction function and observations. 站在观察者角度，利用AF，定
义不可变对象之间的等价关系
 Differentiate between reference equality and object equality. 引用等
价性和对象等价性
 Differentiate between strict observational and behavioral equality for 
mutable types. 可变数据类型的观察等价性和行为等价性
 Understand the Object contract and be able to implement equality 
correctly for mutable and immutable types. 理解Object的契约，正确
实现等价关系判定
8 Equality in ADT and OOP
Outline
 Equivalence Relation
 Equality of Immutable Types
 == vs. equals()
 Equality of immutable types
 The Object contract
 Equality of Mutable Types
 Autoboxing and Equality 在很多场景下，需要判定两个对象是否
“相等”，例如：判断某个
Collection中是否包含特定元素。
==和equals()有和区别？如何为自定
义ADT正确实现equals()？
8 Equality in ADT and OOP
Reading
 MIT 6.031：15
Software Construction
1 Equivalence Relation
8 Equality in ADT and OOP
Equality operation on an ADT
 ADT is data abstraction by creating types that are characterized by 
their operations, not by their representation. ADT是对数据的抽象，
体现为一组对数据的操作
 For an abstract data type, the abstraction function (AF) explains 
how to interpret a concrete representation value as a value of the 
abstract type, and we saw how the choice of abstraction function 
determines how to write the code implementing each of the ADT’s 
operations. 抽象函数AF：内部表示抽象表示
 The abstraction function (AF) gives a way to cleanly define the 
equality operation on an ADT. 基于抽象函数AF定义ADT的等价操作
8 Equality in ADT and OOP
Equality of values in a data type?
 In the physical world, every object is distinct – at some level, even 
two snowflakes are different, even if the distinction is just the 
position they occupy in space. 现实中的每个对象实体都是独特的
 So two physical objects are never truly “equal” to each other; they 
only have degrees of similarity. 所以无法完全相等，但有“相似性”
 In the world of human language, however, and in the world of 
mathematical concepts, you can have multiple names for the same 
thing. 在数学中，“绝对相等”是存在的 – So it’s natural to ask when two expressions represent the same thing: 1+2, √9, and 3 are alternative expressions for the same ideal mathematical 
value.
8 Equality in ADT and OOP
Equivalence Relation
 An equivalence is a relation E T x T that is: – reflexive: E(t,t) t∈T – symmetric: E(t,u) E(u,t) – transitive: E(t,u) ∧ E(u,v) E(t,v) – To use E as a definition for equality, we would say that a equals b if and 
only if E(a,b). 等价关系：自反、对称、传递
 For a boolean-valued binary operation like == or equals(), the 
equivalence E is the set of pairs (x,y) for which the operation 
returns true.  So for ==, these properties can also be written as: – Reflexive: t==t, t∈T – Symmetric: t==u u==t – Transitive: t==u ∧ u==v t==v
Software Construction
2 Equality of Immutable Types
8 Equality in ADT and OOP
Using AF to define the quality
 Using an abstraction function (AF). – Recall that an abstraction function f: R → A maps concrete instances of a 
data type to their corresponding abstract values. – To use f as a definition for equality, we say that a equals b if and only if 
f(a)=f(b). AF映射到同样的结果，则等价
 An equivalence relation induces an abstraction function (the 
relation partitions T, so f maps each element to its partition class). 
 The relation induced by an abstraction function is an equivalence 
relation.
8 Equality in ADT and OOP
Using observation to define the equality
 Another way we can talk about the equality between abstract values 
is in terms of what an outsider (a client) can observe about them
 Using observation. We can say that two objects are equal when they 
cannot be distinguished by observation – every operation we can 
apply produces the same result for both objects. – Consider the set expressions {1,2} and {2,1}. Using the observer 
operations available for sets, cardinality |…| and membership ∈, these 
expressions are indistinguishable:
• |{1,2}| = 2 and |{2,1}| = 2
• 1 ∈ {1,2} is true, and 1 ∈ {2,1} is true
• 2 ∈ {1,2} is true, and 2 ∈ {2,1} is true
• 3 ∈ {1,2} is false, and 3 ∈ {2,1} is false
 In terms of ADT, “observation” means calling operations on the 
objects. So two objects are equal if and only if they cannot be 
distinguished by calling any operations of the abstract data type.
站在外部观察者角度：对两个
对象调用任何相同的操作，都
会得到相同的结果，则认为这
两个对象是等价的。
反之亦然！
8 Equality in ADT and OOP
Example 1: Duration
 Here’s a simple example of an immutable ADT.
 Now which of the following values should be considered equal?
Think in terms of both the abstraction￾function definition of equality, and the 
observational equality definition.
8 Equality in ADT and OOP
Example 2: LetterSet
Since there’re no any 
operations except the 
constructor, we cannot 
use the observational 
equality.
Using the abstraction-function definition of equality for LetterSet: • new LetterSet("abc")
• new LetterSet("aBc")
• new LetterSet("")
• new LetterSet("bbbbbbbc)"
• new LetterSet("1a2b3c")
8 Equality in ADT and OOP
Example 2: LetterSet
new LetterSet(“a”) == new LetterSet(“b”)
new LetterSet(“a”) <> new LetterSet(“aa”)
8 Equality in ADT and OOP
Example 3: Myline
Using the observational definition of equality:
• new MyLine(new int[] { 0,0, 1,1 })
• new MyLine(new int[] { 0,0, -1,-1 })
• new MyLine(new int[] { 5,10, 6,11 })
• new MyLine(new int[] { 0,0, 1,5 })
• new MyLine(new int[] { 0,0, 1,1, 2,2 })
Software Construction
3 == vs. equals()
8 Equality in ADT and OOP
== vs. equals()
 Java has two different operations for testing 
equality, with different semantics. – The == operator compares references. 
It tests referential equality. Two references are 
== if they point to the same storage in memory. 
In terms of the snapshot diagrams, two references 
are == if their arrows point to the same object 
bubble. 引用等价性 – The equals() operation compares object contents – in other words, 
object equality. 对象等价性
 The equals operation has to be defined appropriately for every 
abstract data type. 在自定义ADT时，需要重写Object的equals() – When we define a new data type, it’s our responsibility to decide what 
object equality means for values of the data type, and implement the 
equals() operation appropriately.
8 Equality in ADT and OOP
The == operator vs. equals method
 For primitives you must use == 对基本数据类型，使用==判定相等
 For object reference types 对对象类型，使用equals() – The == operator provides identity semantics 如果用==，是在判断两个对象
身份标识 ID是否相等（指向内存里的同一段空间） – Exactly as implemented by Object.equals – Even if Object.equals has been overridden, this is seldom what you 
want! – You should (almost) always use .equals
 Using == on an object reference is a bad smell in code
if (input == "yes") // A bug!!!
8 Equality in ADT and OOP
Tips for overriding a method
 If you want to override a method: – Make sure signatures match
– Use @Override so compiler has your back
– Do copy-and-paste declarations (or let IDE do it for you)
Software Construction
4 Implementing equals()
8 Equality in ADT and OOP
Equality of Immutable Types
 The equals() method is defined by Object , and its default 
implementation looks like this:
 The default meaning of equals() is the same as referential 
equality. 在Object中实现的缺省equals()是在判断引用等价性
 For immutable data types, this is almost always wrong. 这通常不是
程序员所期望的
 We have to override the equals() method, replacing it with our 
own implementation. 因此，需要重写
8 Equality in ADT and OOP
equals() for this example
 equals() for the class Duration:  How about this code?
 Why?
Even though d2 and o2 end up referring 
to the very same object in memory, you 
still get different results for them from 
??? equals() .
这不是override，
而是overload！
8 Equality in ADT and OOP
What’s going on?
 The class Duration has overloaded the equals() method, because 
the method signature was not identical to Object ’s. 
 We actually have two equals() methods in Duration : – An implicit equals(Object) inherited from Object – The new equals(Duration) .
 Java compiler selects between overloaded operations using the 
compile-time type of the parameters. Static Type Checking
8 Equality in ADT and OOP
What’s going on?
 If we pass an Object reference, as in d1.equals(o2) , we end up 
calling the equals(Object) implementation. 
 If we pass a Duration reference, as in d1.equals(d2) , we end up 
calling the equals(Duration) version. 
 This happens even though o2 and d2 both point to the same object 
at runtime! Equality has become inconsistent.
8 Equality in ADT and OOP
Overload vs. override
 It’s easy to make a mistake in the method signature, and overload a 
method when you meant to override it. 
 Java’s annotation @Override should be used whenever your 
intention is to override a method in your superclass. 
 With this annotation, the Java compiler will check that a method 
with the same signature actually exists in the superclass, and give 
you a compiler error if you’ve made a mistake in the signature.
8 Equality in ADT and OOP
A better way to implement equals()
 The first method overrides and replaces the equals(Object)
method inherited from Object.  It tests the type of the that object passed to it to make sure it’s a 
Duration, and then calls a private helper method sameValue() to 
test equality. 
8 Equality in ADT and OOP
What does this print?
public class Name {
private final String first, last;
public Name(String first, String last) {
if (first == null || last == null)
throw new NullPointerException();
this.first = first; 
this.last = last;
}
public boolean equals(Name o) {
return first.equals(o.first) && last.equals(o.last);
}
public int hashCode() {
return 31 * first.hashCode() + last.hashCode();
}
public static void main(String[] args) {
Set<Name> s = new HashSet<>();
s.add(new Name("Mickey", "Mouse"));
System.out.println(s.contains(new Name("Mickey", "Mouse")));
} }
8 Equality in ADT and OOP
How about this?
public class Name {
private final String first, last;
public Name(String first, String last) {
if (first == null || last == null)
throw new NullPointerException();
this.first = first; 
this.last = last;
}
@Override public boolean equals(Object o) {
if (!(o instanceof Name))
return false;
Name n = (Name) o;
return n.first.equals(first) && n.last.equals(last);
} 
public int hashCode() {
return 31 * first.hashCode() + last.hashCode();
}
public static void main(String[] args) {
Set<Name> s = new HashSet<>();
s.add(new Name("Mickey", "Mouse"));
System.out.println(s.contains(new Name("Mickey", "Mouse")));
} }
8 Equality in ADT and OOP
equals Override Example
public final class PhoneNumber {
private final short areaCode;
private final short prefix;
private final short lineNumber;
@Override 
public boolean equals(Object o) {
if (!(o instanceof PhoneNumber)) // Does null check
return false;
PhoneNumber pn = (PhoneNumber) o;
return pn.lineNumber == lineNumber
&& pn.prefix == prefix
&& pn.areaCode == areaCode;
}
...
}
进行类型比较
和null值判定
严格来说，在没有
AF的情况下直接在
equals()中判断每
个域的等价性，是
不正确的
8 Equality in ADT and OOP
instanceof
 The instanceof operator tests whether an object is an instance of a 
particular type. 
 Using instanceof is dynamic type checking, not the static type 
checking. 
 In general, using instanceof in object-oriented programming is a 
bad smell. It should be disallowed anywhere except for 
implementing equals . 
 This prohibition also includes other ways of inspecting objects’ 
runtime types. – For example, getClass() is also disallowed.
8 Equality in ADT and OOP
instanceof
public void doSomething(Account acct) {
long adj = 0;
if (acct instanceof CheckingAccount) {
checkingAcct = (CheckingAccount) acct;
adj = checkingAcct.getFee();
} else if (acct instanceof SavingsAccount) {
savingsAcct = (SavingsAccount) acct;
adj = savingsAcct.getInterest();
} }
Do not do this.
This code is bad.
Never(?) use instanceof in a superclass to check type 
against subclass
8 Equality in ADT and OOP
Use polymorphism to avoid instanceof
public interface Account {
public long getMonthlyAdjustment();
}
public class CheckingAccount implements Account {
public long getMonthlyAdjustment() {
return getFee();
} }
public class SavingsAccount implements Account {
public long getMonthlyAdjustment() {
return getInterest();
}
public void doSomething(Account acct) {
long adj = acct.getMontlyAdjustment();
}
Software Construction
5 The Object contract
8 Equality in ADT and OOP
The contract of equals() in Object
 When you override the equals() method, you must adhere to its 
general contract: – equals must define an equivalence relation – that is, a relation that is 
reflexive, symmetric, and transitive; 等价关系：自反、传递、对称 – equals must be consistent: repeated calls to the method must yield the 
same result provided no information used in equals comparisons on the 
object is modified; 除非对象被修改了，否则调用多次equals应同样的结果 – for a non-null reference x , x.equals(null) should return false; – hashCode() must produce the same result for two objects that are deemed 
equal by the equals method. “相等”的对象，其hashCode()的结果必须
一致
8 Equality in ADT and OOP
The equals contract
 The equals method implements an equivalence relation: – Reflexive: For any non-null reference value x, x.equals(x) must return 
true. – Symmetric: For any non-null reference values x and y, x.equals(y) must 
return true if and only if y.equals(x) returns true. – Transitive: For any non-null reference values x, y, z, if x.equals(y) 
returns true and y.equals(z) returns true, then x.equals(z) mus return 
true. – Consistent: For any non-null reference values x and y, multiple 
invocations of x.equals(y) consistently return true or consistently return 
false, provided no information used in equals comparisons on the objects 
is modified. – For any non-null reference value x, x.equals(null) must return false.
 equals is a global equivalence relation over all objects.
8 Equality in ADT and OOP
The equals contract in English
 Reflexive – every object is equal to itself
 Symmetric – if a.equals(b) then b.equals(a)  Transitive – if a.equals(b) and b.equals(c), then a.equals(c)  Consistent– equal objects stay equal unless mutated
 “Non-null” – a.equals(null) returns false
 Taken together these ensure that equals is a global equivalence 
relation over all objects
 用“是否为等价关系”检验你的equals()是否正确
8 Equality in ADT and OOP
Breaking the Equivalence Relation
 We have to make sure that the definition of equality implemented 
by equals() is actually an equivalence relation as defined earlier: 
reflexive, symmetric, and transitive. – If it isn’t, then operations that depend on equality (like sets, searching) 
will behave erratically and unpredictably. – You don’t want to program with a data type in which sometimes a equals 
b , but b doesn’t equal a . – Subtle and painful bugs will result.
Which property of the equivalence relation is violated?
8 Equality in ADT and OOP
Breaking the Equivalence Relation
Duration d_0_60 = new Duration(0, 60);
Duration d_1_00 = new Duration(1, 0);
Duration d_0_57 = new Duration(0, 57);
Duration d_1_03 = new Duration(1, 3);
d_0_60.equals(d_1_00)
d_1_00.equals(d_0_60)
d_1_00.equals(d_1_00)
d_0_57.equals(d_1_00)
d_0_57.equals(d_1_03)
d_0_60.equals(d_1_03)
8 Equality in ADT and OOP
Breaking Hash Tables
 A hash table is a representation for a mapping: an abstract data 
type that maps keys to values. – Hash tables offer constant time lookup, so they tend to perform better 
than trees or lists. Keys don’t have to be ordered, or have any particular 
property, except for offering equals and hashCode .  How a hash table works: – It contains an array that is initialized to a size corresponding to the 
number of elements that we expect to be inserted. – When a key and a value are presented for insertion, we compute the 
hashcode of the key, and convert it into an index in the array’s range (e.g., 
by a modulo division). The value is then inserted at that index.
 The rep invariant of a hash table includes the fundamental 
constraint that keys are in the slots determined by their hash codes.
8 Equality in ADT and OOP
Breaking Hash Tables
 Hashcodes are designed so that the keys will be spread evenly over 
the indices. 
 But occasionally a conflict occurs, and two keys are placed at the 
same index. 
 So rather than holding a single value at an index, a hash table 
actually holds a list of key/value pairs, usually called a hash bucket .  A key/value pair is implemented in Java simply as an object with 
two fields. 
 On insertion, you add a pair to the list in the array slot determined 
by the hash code. 
 For lookup, you hash the key, find the right slot, and then examine 
each of the pairs until one is found whose key equals the query key.
8 Equality in ADT and OOP
Hash Tables
8 Equality in ADT and OOP
The hashCode contract
 Whenever it is invoked on the same object more than once during an 
execution of an application, the hashCode method must consistently 
return the same integer, provided no information used in equals 
comparisons on the object is modified. – This integer need not remain consistent from one execution of an 
application to another execution of the same application.
 If two objects are equal according to the equals(Object) method, 
then calling the hashCode method on each of the two objects must 
produce the same integer result. 等价的对象必须有相同的hashCode – It is not required that if two objects are unequal according to the 
equals(Object) method, then calling the hashCode method on each of 
the two objects must produce distinct integer results. – However, the programmer should be aware that producing distinct 
integer results for unequal objects may improve the performance of hash 
tables. 不相等的对象，也可以映射为同样的hashCode，但性能会变差
8 Equality in ADT and OOP
The hashCode contract in English
 Equal objects must have equal hash codes – If you override equals you must override hashCode
 Unequal objects should have different hash codes – Take all value fields into account when constructing it
 Hash code must not change unless object mutated
8 Equality in ADT and OOP
Breaking Hash Tables
 Why the Object contract requires equal objects to have the same 
hashcode? – If two equal objects had distinct hashcodes, they might be placed in 
different slots. – So if you attempt to lookup a value using a key equal to the one with 
which it was inserted, the lookup may fail.
 Object ’s default hashCode() implementation is consistent with 
its default equals() :
8 Equality in ADT and OOP
In our example…
 For Duration , since we haven’t overridden the default 
hashCode() yet, we’re currently breaking the Object contract:
 d1 and d2 are equal, but they have different hash codes. 
 How to fix it?
8 Equality in ADT and OOP
Overriding hashCode()
 A simple and drastic way to ensure that the contract is met is for 
hashCode to always return some constant value, so every object’s 
hash code is the same. – This satisfies the Object contract, but it would have a disastrous 
performance effect, since every key will be stored in the same slot, and 
every lookup will degenerate to a linear search along a long list.
 The standard is to compute a hash code for each component of the 
object that is used in the determination of equality (usually by 
calling the hashCode method of each component), and then 
combining these, throwing in a few arithmetic operations. 
 For Duration , this is easy, because the abstract value of the class is 
already an integer value:
8 Equality in ADT and OOP
Overriding hashCode()
 Recent versions of Java now have a utility method 
Objects.hash() that makes it easier to implement a hash code 
involving multiple fields.
 Note that if you don’t override hashCode() at all, you’ll get the one 
from Object, which is based on the address of the object. 
 If you have overridden equals , this will mean that you will have 
almost certainly violated the contract – 两个equal的objects，一定要
有同样的hashcode.  A general rule:
Always override hashCode() when you override equals()
除非你能保证你的ADT不会被放入到Hash类型的集合类中 
8 Equality in ADT and OOP
hashCode override example
public final class PhoneNumber {
private final short areaCode;
private final short prefix;
private final short lineNumber;
@Override 
public int hashCode() {
int result = 17; // Nonzero is good
result = 31 * result + areaCode; // Constant must be odd
result = 31 * result + prefix; // " " " "
result = 31 * result + lineNumber; // " " " "
return result;
}
...
}
8 Equality in ADT and OOP
Alternative hashCode override
 Less efficient, but otherwise equally good!
public final class PhoneNumber {
private final short areaCode;
private final short prefix;
private final short lineNumber;
@Override 
public int hashCode() {
short[] hashArray = {areaCode, prefix, lineNumber};
return Arrays.hashCode(hashArray);
}
...
}
8 Equality in ADT and OOP
An example
class Person {
private String firstName;
private String lastName;
...
public boolean equals(Object obj) {
if (!(obj instanceof Person)) return false;
Person that = (Person) obj;
return this.lastName.toUpperCase().
equals(that.lastName.toUpperCase());
}
public int hashCode() {
// TODO
} } return 42;
return firstName.toUpperCase();
return lastName.toUpperCase().hashCode();
? return firstName.hashCode() + lastName.hashCode();
Software Construction
6 Equality of Mutable Types
8 Equality in ADT and OOP
Equality of Mutable Types
 Equality: two objects are equal when they cannot be distinguished 
by observation. 
 With mutable objects, there are two ways to interpret this: – When they cannot be distinguished by observation that doesn’t change the 
state of the objects, i.e., by calling only observer, producer, and creator 
methods. This is often strictly called observational equality, since it tests 
whether the two objects “look” the same, in the current state of program. 
观察等价性：在不改变状态的情况下，两个mutable对象是否看起来一致 – When they cannot be distinguished by any observation, even state 
changes. This interpretation allows calling any methods on the two 
objects, including mutators. This is called behavioral equality , since it 
tests whether the two objects will “behave” the same, in this and all future 
states. 行为等价性：调用对象的任何方法都展示出一致的结果
 Note: for immutable objects, observational and behavioral equality 
are identical, because there aren’t any mutator methods.
8 Equality in ADT and OOP
Equality in Java for mutable type
 For mutable objects, it’s tempting to implement strict observational 
equality. 对可变类型来说，往往倾向于实现严格的观察等价性 – Java uses observational equality for most of its mutable data types (such as 
Collections), but other mutable classes (like StringBuilder ) use 
behavioral equality. – If two distinct List objects contain the same sequence of elements, then 
equals() reports that they are equal.
 But using observational equality leads to subtle bugs, and in fact 
allows us to easily break the rep invariants of other collection data 
structures. 但在有些时候，观察等价性可能导致bug，甚至可能破坏RI
8 Equality in ADT and OOP
An example
 Suppose we make a List , and then drop it into a Set :  We can check that the set contains the list we put in it, and it does:
 But now we mutate the list:
 And it no longer appears in the set!
 It’s worse than that, in fact: when we iterate over the members of 
the set, we still find the list in there, but contains() says it’s not 
there.
8 Equality in ADT and OOP
What’s going on?
 List<String> is a mutable object. In the standard Java 
implementation of collection classes like List, mutations affect the 
result of equals() and hashCode() .  When the list is first put into the HashSet, it is stored in the hash 
bucket 哈希桶/散列桶 corresponding to its hashCode() result at 
that time. 
 When the list is subsequently mutated, its hashCode() changes, 
but HashSet doesn’t realize it should be moved to a different 
bucket. So it can never be found again.
 When equals() and hashCode() can be affected by mutation, we 
can break the rep invariant of a hash table that uses that object as a 
key.
你在派出所申领了身份证，留了当时的照片；
几个月以后，你“整容”了(mutated)，你坐飞机案件的时候就无法匹
配到你的身份证照片了…
8 Equality in ADT and OOP
What’s going on?
 Great care must be exercised if mutable objects are used as set 
elements. 
 The behavior of a set is not specified if the value of an object is 
changed in a manner that affects equals comparisons while the 
object is an element in the set. 如果某个mutable的对象包含在Set集
合类中，当其发生改变后，集合类的行为不确定  务必小心
 The Java library is unfortunately inconsistent about its 
interpretation of equals() for mutable classes. 
 Collections use observational equality, but other mutable classes
(like StringBuilder) use behavioral equality. 在JDK中，不同的
mutable类使用不同的等价性标准… 
8 Equality in ADT and OOP
Two examples
 Date类的equals()的spec："Two Date objects are equal if and only 
if the getTime method returns the same long value for both. “
观察等价性
 List类的equals()的spec："Returns true if and only if the 
specified object is also a list, both lists have the same size, and all 
corresponding pairs of elements in the two lists are equal. “ – Two lists are defined to be equal if they contain the same elements in the 
same order.
观察等价性
 StringBuilder类的equals继承自Object类 
行为等价性
8 Equality in ADT and OOP
Lessons learned from this example
 equals() should implement behavioral equality. 对可变类型，实
现行为等价性即可
 In general, that means that two references should be equals() if 
and only if they are aliases for the same object. 也就是说，只有指
向同样内存空间的objects，才是相等的。
 So mutable objects should just inherit equals() and hashCode() 
from Object. 所以对可变类型来说，无需重写这两个函数，直接继承
Object的两个方法即可。
 For clients that need a notion of observational equality (whether 
two mutable objects “look” the same in the current state), it’s better 
to define a new method, e.g., similar(). 如果一定要判断两个可变
对象看起来是否一致，最好定义一个新的方法。
8 Equality in ADT and OOP
The Final Rule for equals() and hashCode()
 For immutable types : – equals() should compare abstract values. This is the same as saying 
equals() should provide behavioral equality. – hashCode() should map the abstract value to an integer. – So immutable types must override both equals() and hashCode() .  For mutable types : – equals() should compare references, just like == . Again, this is the same 
as saying equals() should provide behavioral equality. – hashCode() should map the reference into an integer. – So mutable types should not override equals() and hashCode() at all, 
and should simply use the default implementations provided by Object . Java doesn’t follow this rule for its collections, unfortunately, leading to 
the pitfalls that we saw above.
8 Equality in ADT and OOP
Exercise
 Bag<E> is a mutable ADT representing what is often called a 
multiset, an unordered collection of objects where an object can 
occur more than once. It has the following operations:
/** make an empty bag */
public Bag<E>()
/** modify this bag by adding an occurrence of e, and return 
this bag */
public Bag<E> add(E e)
/** modify this bag by removing an occurrence of e (if any), 
and return this bag */
public Bag<E> remove(E e)
/** return number of times e occurs in this bag */
public int count(E e)
8 Equality in ADT and OOP
Exercise
Bag<String> b1 = new Bag<>().add("a").add("b");
Bag<String> b2 = new Bag<>().add("a").add("b");
Bag<String> b3 = b1.remove("b");
Bag<String> b4 = new Bag<>().add("b").add("a");
b1.count("a") == 1
b1.count("b") == 1
b2.count("a") == 1
b2.count("b") == 1
b3.count("a") == 1
b3.count("b") == 1
b4.count("a") == 1
b4.count("b") == 1
If Bag is implemented 
with behavioral
equality
b1.equals(b2)
b1.equals(b3)
b1.equals(b4)
b2.equals(b3)
b2.equals(b4)
b3.equals(b1)
If Bag implemented 
observational equality
despite the dangers
b1.equals(b2)
b1.equals(b3)
b1.equals(b4)
b2.equals(b3)
b2.equals(b4)
b3.equals(b1)
8 Equality in ADT and OOP
clone() in Object
 clone() creates and returns a copy of this object. 
 The precise meaning of "copy" may depend on the class of the 
object. 
 The general intent is that, for any object x:
x.clone() != x
x.clone().getClass() == x.getClass() 
x.clone().equals(x)
从这些contracts中无法确保是deep copy！
Software Construction
7 Autoboxing and Equality
8 Equality in ADT and OOP
Autoboxing and Equality
 Primitive types and their object type equivalents, e.g., int and 
Integer .  If you create two Integer objects with the same value, they’ll be 
equals() to each other.
 But what if x==y? ----- False (because of referential equality)
 But what if (int) x == (int) y? ----True
 What’s the result of this code?
8 Equality in ADT and OOP
Autoboxing and Equality
放入Map的时候，
自动将int 130转为
了Integer
取出来的时候，得
到的是Integer类 型 对Integer类型的==， 是reference equality判 断 a.get("c").equals(b.get("c"));
Integer对象的
equals()是object 
equality
8 Equality in ADT and OOP
Autoboxing and Equality
 What about this code?
Map<String, Integer> a = new HashMap<>();
Map<String, Integer> b = new HashMap<>();
a.put("c", 1);
b.put("c", 1);
System.out.println (a.get("a")== b.get("a"));
Numbers between 
-128 and 127 are 
true.
Integer x = 2;
Integer y = 2;
System.out.println(x==y);
Integer x = new Integer(2);
Integer y = new Integer(2);
System.out.println(x==y);
Software Construction
Summary
8 Equality in ADT and OOP
Summary
 Equality is one part of implementing an abstract data type (ADT). – Equality should be an equivalence relation (reflexive, symmetric, 
transitive). – Equality and hash code must be consistent with each other, so that data 
structures that use hash tables (like HashSet and HashMap ) work 
properly. – The abstraction function is the basis for equality in immutable data types. – Reference equality is the basis for equality in mutable data types; this is 
the only way to ensure consistency over time and avoid breaking rep 
invariants of hash tables.
8 Equality in ADT and OOP
Summary
 Safe from bugs – Correct implementation of equality and hash codes is necessary for use 
with collection data types like sets and maps. It’s also highly desirable for 
writing tests. Since every object in Java inherits the Object 
implementations, immutable types must override them.
 Easy to understand
– Clients and other programmers who read our specs will expect our types 
to implement an appropriate equality operation, and will be surprised and 
confused if we do not.
 Ready for change – Correctly-implemented equality for immutable types separates equality of 
reference from equality of abstract value, hiding from clients our decisions 
about whether values are shared. Choosing behavioral rather than 
observational equality for mutable types helps avoid unexpected aliasing 
bugs.
Software Construction
The end
May 31, 2021Software Construction
9 Construction for Reuse
面向复用的软件构造技术
Wang Zhongjie
rainy@hit.edu.cn
June 7, 2021
9 Construction for Reuse
Objective of this lecture
 Advantages and disadvantages of software reuse
 Construction for/with reuse
 Characteristics of generic reusable components
 Methods of developing portable application systems
前几次课介绍了软件构造的核心理论（ADT）与技术（OOP），其核
心是保证代码质量、提高代码安全性。
本次课面向一个重要的外部质量指标：可复用性——如何构造出可在
不同应用中重复使用的软件模块/API？
首先探讨可复用的软件应该“长什么样”，然后学习“如何构造”
9 Construction for Reuse
Outline
 What is software reuse? 
 How to measure “reusability”?
 Levels and morphology of reusable components – Source code level reuse 源代码级别的复用 – Module-level reuse: class/interface 模块级别的复用：类/抽象类/接口 – Library-level: API/package 库级别的复用：API/包 – System-level reuse: framework 系统级别的复用：框架
9 Construction for Reuse
Outline
 Designing reusable classes 设计可复用的类 – Inheritance and overriding 继承与重写 – Overloading 重载 – Parametric polymorphism and generic programming 参数多态与泛型编程 – Behavioral subtyping and Liskov Substitution Principle (LSP) 行为子类型
与Liskov替换原则 – Composition and delegation 组合与委托
 Designing system-level reusable libraries and frameworks 设计可
复用库与框架 – API and Library – Framework – Java Collections Framework 
(an example)
从类、API、框架三个层面学习如何设计可
复用软件实体的具体技术
9 Construction for Reuse
Reading
 CMU 17-214：Oct 10、Oct 15、Oct 17、Oct 22
 Java编程思想：第14、15章  Effective Java：第5章
Software Construction
1 What is Software Reuse?
9 Construction for Reuse
Hardware is reused inherently
9 Construction for Reuse
Software reuse
 Software reuse is the process of implementing or updating software 
systems using existing software components.
 Two perspectives of software reuse – Creation: creating reusable resources in a systematic way (programming 
for reuse 面向复用编程：开发出可复用的软件) – Use: reusing resources as building blocks for creating new systems 
(programming with reuse 基于复用编程：利用已有的可复用软件搭建应用
系统)  Why reuse? – “The drive to create reusable rather than transitory artifacts has aesthetic 
and intellectual as well as economic motivations and is part of man’s 
desire for immortality. – It distinguishes man from other creatures and civilized from primitive 
societies” (Wegner, 1989). 
9 Construction for Reuse
Programming for/with reuse
应用场景1
应用场景2
应用场景3
应用场景n 分析相似性+差异性 …
接口
抽象类
一般类
for
reuse
选取、适配、修改、扩展
with
reuse
100%
50%
0%
复用度
很大的适应性
降低成本和开发时间
充分的测试高可靠
标准化、一致化
针对性不强性能差
往往无法拿来就用
需要适配
可靠性建立在外部基础上
9 Construction for Reuse
Recall Lab2
 在Lab2中：你开发了一个基于泛型的抽象接口Graph<L>，定义了支
持图结构的ADT
 针对该ADT，用两种不同的Rep，开发了两个不同的实现
ConcreteVertexGraph<L>和ConcreteEdgeGraph<L>
Programming for reuse 
面向复用编程：开发出可复用的软件
 进而，你利用该ADT及其两个实现，完成了两个应用的开发： – Poetic Walks – Friendship Social Network
Programming with reuse 
基于复用编程：利用已有的可复用软
件搭建应用系统
9 Construction for Reuse
Why reuse?
 Reuse is cost-effective and with timeliness 降低成本和开发时间 – Increases software productivity by shortening software production cycle 
time (software developed faster and with fewer people) – Does not waste resources to needlessly 
"reinvent-the-wheel" – Reduces cost in maintenance (better quality, more 
reliable and efficient software can be produced)
 Reuse produces reliable software 经过充分
测试，可靠、稳定 – Reusing functionality that has been around for 
a while and is debugged is a foundation for building on stable subsystems
 Reuse yields standardization 标准化，在不同应用中保持一致 – Reuse of GUI libraries produces common look-and-feel in applications. – Consistency with regular, coherent design.
9 Construction for Reuse
Reuse costs
 Reusable components should be designed and built in a clearly
defined, open way, with concise interface specifications, understandable
documentation, and an eye towards future use. 做到这些，需要代价
 Reuse is costly: it involves spans organizational, technical, and 
process changes, as well as the cost of tools to support those changes, 
and the cost of training people on the new tools and changes. 不仅
program for reuse代价高，program with reuse代价也高
9 Construction for Reuse
Development for reuse: 开发可复用的软件
 The development cost of reusable components is higher than the 
cost of specific equivalents. This extra reusability enhancement 
cost should be an organization rather than a project cost. 开发成本
高于一般软件的成本：要有足够高的适应性
 Generic components may be less space-efficient and may have 
longer execution times than their specific equivalents. 性能差些：
针对更普适场景，缺少足够的针对性
Name
generalization
Operation
generalization
Exception
generalization
Component
certification
Reusable
component
Initial
component
9 Construction for Reuse
Development with reuse: 使用已有软件进行开发
 Component management tools, such as repositories, for 
architectures, designs, documentation, and code must be 
developed and maintained. 可复用软件库，对其进行有效的管理
 A key issue: adaptation 往往无法拿来就用，需要适配 – Extra functionality may have to be added to a component. When this has 
been added, the new component may be made available for reuse. – Unneeded functionality may be removed from a component to improve its
performance or reduce its space requirements – The implementation of some component operations may have to be 
modified. 
Design
system
achitecture
Specify
components
Search for
reusable
components
Incorporate
discovered
components
9 Construction for Reuse
Reusable Libraries and APIs in JDK
9 Construction for Reuse
Rich third-party libraries and APIs in Java
9 Construction for Reuse
Rich RubyGems 
Software Construction
2 How to measure “reusability”?
9 Construction for Reuse
Measure resuability
 How frequently can a software asset be reused in different 
application scenarios? 复用的机会有多频繁？复用的场合有多少？ – The more chance an asset is used, the higher reusability it has. – Write once, reuse multiple times.
 How much are paid for reusing this asset? 复用的代价有多大？ – Cost to buy the asset and other mandatory libraries 搜索、获取 – Cost for adapting and extending it 适配、扩展 – Cost for instantiating it 实例化 – Cost for changing other parts of the system that interact with it 与软件其他
部分的互连的难度
9 Construction for Reuse
Reusability
 Reusability implies some explicit management of build, 
packaging, distribution, installation, configuration, deployment, 
maintenance and upgrade issues.
 A software asset with high reusability should: – Brief (small size) and Simple (low complexity) 小、简单 – Portable and Standard Compliance 与标准兼容 – Adaptable and Flexible 灵活可变 – Extensibility 可扩展 – Generic and Parameterization 泛型、参数化 – Modularity 模块化 – Localization of volatile (changeable) design assumptions 变化的局部性 – Stability under changing requirements 稳定 – Rich documentation 丰富的文档和帮助
Software Construction
3 Levels and morphology of reusable 
components
9 Construction for Reuse
Levels of Reuse
 A reusable component may be code 最主要的复用是在代码层面 – Most prevalent: what most programmers relate with reuse
 But benefits result from a broader and higher-level view of what 
can be reused. 但软件构造过程中的任何实体都可能被复用 – Requirements 需求 – Design and specifications 设计/规约spec – Data 数据 – Test cases 测试用例 – Documentation 文档
9 Construction for Reuse
What we concern in this lecture
 Source code level: methods, statements, etc
 Module level: class and interface
 Library level: API – Java Library, .jar
 Architecture level: framework 框架
9 Construction for Reuse
Types of Code Reuse
 White box reuse 白盒复用：源代码可见，可修改和扩展 – Reuse of code when code itself is available. Usually requires some kind of 
modification or adaptation 复制已有代码到正在开发的系统，进行修改 – Pro: You can customize the module to fit the specific situation, this allows 
reuse in more situations 可定制化程度高 – Con: You now own the customized result, so it adds to your code 
complexity. You requires intrinsic knowledge on component internals. 对
其修改增加了软件的复杂度，且需要对其内部充分的了解
 Black box reuse 黑盒复用：源代码不可见，不能修改 – Reuse in the form of combining existing code by providing some “glue”, 
but without having to change the code itself - usually because you do not 
have access to the code 只能通过API接口来使用，无法修改代码 – Pro: Simplicity and Cleanliness 简单，清晰 – Con: Many times it is just not possible 适应性差些
9 Construction for Reuse
Formats for reusable component distribution
 Forms: – Source code – Package such as .jar, .gem, .dll, 
 Sources of reusable software components: – Internal (corporate) code libraries 组织的内部代码库（Guava） – Third party libraries 第三方提供的库（Apache） – Built-in language libraries 语言自身提供的库（JDK） – Code samples from tutorials, examples, books, etc. 代码示例 – Local code guru or knowledgeable colleague 来自同事 – Existing system code 已有系统内的代码 – Open source products (be sure to follow any licensing agreements)
开源软件的代码
以及最重要的：自己
日积月累出来的可复
用代码库
Software Construction
(1) Source code reuse
9 Construction for Reuse
Reusing Code – Lowest Level
 Copy/paste parts/all into your program
 Maintenance problem
– Need to correct code in multiple places – Too much code to work with (lots of versions)
 High risk of error during process
 May require knowledge about how the used software works
 Requires access to source code
 相关研究1：如何从互联网上快速找到需要的代码片段？
 反向研究：如何从源代码中检测出克隆代码 (clone code)？
9 Construction for Reuse
GitHub code search: github.com/search
9 Construction for Reuse
Searchcode: searchcode.com
Software Construction
(2) Module-level reuse: 
class/interface
Inheritance
Use
Composition/aggregation
Delegation/association
9 Construction for Reuse
Reusing classes
 A class is an atomic unit of code reuse – Source code not necessary, class file or jar/zip – Just need to include in the classpath – Can use javap tool to get a class’s public method headers
 Documentation very important (Java API)
 Encapsulation helps reuse
 Less code to manage
 Versioning, backwards-compatibility still problem
 Need to package related classes together -- Static Linking
9 Construction for Reuse
Approaches of reusing a class: inheritance 继承
 Java provides a way of code reuse named Inheritance – Classes extend the properties/behavior of existing classes – In addition, they might override existing behavior 
 No need to put dummy methods that just forward or delegate work
 Captures the real world better
 Usually need to design inheritance hierarchy before 
implementation
 Cannot cancel out properties or methods, so must be careful not to 
overdo it
9 Construction for Reuse
Approaches of reusing a class: delegation 委托
 Delegation is simply when one object relies on another object for 
some subset of its functionality (one entity passing something to 
another entity) – e.g. the Sorter is delegating functionality to some Comparator
 Judicious delegation enables code reuse – Sorter can be reused with arbitrary sort orders – Comparators can be reused with arbitrary client code that needs to 
compare integers
 Explicit delegation: passing the sending object to the receiving object
 Implicit delegation: by the member lookup rules of the language
 Delegation can be described as a low level mechanism for sharing 
code and data between entities. 
Software Construction
(3) Library-level reuse: API/Package
9 Construction for Reuse
Libraries
 Library: A set of classes and methods (APIs) that provide reusable 
functionality
9 Construction for Reuse
Framework
 Framework: Reusable skeleton code that can be customized into an 
application
 Framework calls back into client code – The Hollywood principle: “Don’t call us. We’ll call you.”
9 Construction for Reuse
General distinction: Library vs. framework
开发者构造可运行
软件实体，其中涉
及到对可复用库的
调用
Framework作为主
程序加以执行，执
行过程中调用开发
者所写的程序
9 Construction for Reuse
Characteristics of a good API
 Easy to learn
 Easy to use, even without documentation
 Hard to misuse
 Easy to read and maintain code that uses it
 Sufficiently powerful to satisfy requirements
 Easy to evolve
 Appropriate to audience
9 Construction for Reuse
Guava: Google core libraries for Java
9 Construction for Reuse
Apache Commons
 Apache Commons is an Apache project focused on all aspects of 
reusable Java components. – https://commons.apache.org
– https://github.com/apache/commons-*
9 Construction for Reuse
API on Web/Internet: Web Services/Restful APIs 
Software Construction
(4) System-level reuse: Framework
9 Construction for Reuse
Application Frameworks
 Frameworks are sub-system design containing a collection of 
abstract and concrete classes along with interfaces between each 
class 框架：一组具体类、抽象类、及其之间的连接关系 – 只有“骨架”，没有“血肉”
 A framework is an abstraction in which software providing generic 
functionality can be selectively changed by additional user-written 
code, thus providing application-specific software. 开发者根据
framework的规约，填充自己的代码进去，形成完整系统
Framework
Application Components
9 Construction for Reuse
Application Frameworks
 Reusability leverages of the application domain knowledge and 
prior effort of experienced developers 领域知识的复用 – Data processing, GUI, etc – 将framework看作是更大规模的API复用，除了提供可复用的API，还将这
些模块之间的关系都确定下来，形成了整体应用的领域复用
Framework
Application Components
Framework作为主
程序加以执行，执
行过程中调用开发
者所写的程序
开发者根据
Framework预留的
接口所写的程序
骨骼清奇，天赋异禀
9 Construction for Reuse
Framework Design
 Frameworks differ from applications – The level of abstraction is different as frameworks provide a solution for a 
family of related problems, rather than a single one. – To accommodate the family of problems, the framework is incomplete, 
incorporating hot spots and hooks to allow customization
 Frameworks can be classified by the techniques used to extend 
them. – Whitebox frameworks 黑盒框架 – Blackbox frameworks 白盒框架
9 Construction for Reuse
White-box and Black-Box Frameworks
 Whitebox frameworks 白盒框架，通过代码层面的继承进行框架扩展 – Extensibility achieved through inheritance and dynamic binding. – Existing functionality is extended by subclassing framework base classes 
and overriding predefined hook methods – Often design patterns such as the template method pattern are used to 
override the hook methods. 
 Blackbox frameworks 黑盒框架，通过实现特定接口/delegation进行
框架扩展 – Extensibility achieved by defining interfaces for components that can be 
plugged into the framework. – Existing functionality is reused by defining components that conform to a
particular interface – These components are integrated with the framework via delegation.
Software Construction
5 Designing reusable classes
9 Construction for Reuse
Designing reusable classes in OOP
 Encapsulation and information hiding
 Inheritance and overriding
 Polymorphism, subtyping and overloading
 Generic programming
 Behavioral subtyping and Liskov Substitution Principle (LSP)
 Delegation and Composition
Already introduced in 
section 3.4 OOP
Software Construction
(1) Behavioral subtyping and Liskov 
Substitution Principle (LSP)
9 Construction for Reuse
Behavioral subtyping
 Subtype polymorphism: Different kinds of objects can be treated 
uniformly by client code. 子类型多态：客户端可用统一的方式处理
不同类型的对象 – If the type Cat is a subtype of Animal, then an expression of type Cat can 
be used wherever an expression of type Animal is used. 
 Let q(x) be a property provable about objects x of type T, then 
q(y) should be provable for objects y of type S where S is a 
subtype of T. ——Barbara Liskov
Animal a = new Animal();
Animal c1 = new Cat();
Cat c2 = new Cat();
在可以使用a的场景，都可以用c1和c2代
替而不会有任何问题
a = c1;
a = c2;
9 Construction for Reuse
Barbara Liskov
Barbara Liskov (1939- )
MIT
http://www.pmg.csail.mit.edu/~liskov
美国第一位计算机科学方向的女博士
2008年图灵奖获得者
提出了第一个支持数据抽象的面向对象编程语
言CLU，对现代主流语言如C++/Java/Python 
/Ruby/C#都有深远的影响。她所提炼出来的
数据抽象思想，成为软件工程的重要精髓之一。
她提出的“Liskov替换原则”，是面向对象最
重要的几大原则之一。
9 Construction for Reuse
抽象数据类型ADT和OO设计的LSP原则
 由于女教授当时是个新鲜事物，于是在欢迎新员工的仪式上闹出一个
笑话：主持人错把她的丈夫当成了欢迎的对象。  在科研方面，为DARPA和NSF开发了一种新的程序设计语言CLU，
1974年完成，首次提出了抽象数据类型ADT的概念，使程序设计方法
学实现了一次革命性的飞跃，也为后来OO编程语言的发展奠定了基
础。
 普遍认为，CLU是计算机早期历史上最完善的程序设计语言，1975年
之后出现的Ada、C++、Java、C#等，都受到了CLU的影响。
 1980年代，提出了Liskov Substitution Principle (LSP)，这是OO的
重要原则之一，继承和复用就是建立在LSP之上。
9 Construction for Reuse
Behavioral subtyping
 Compiler-enforced rules in Java (static type checking) – Subtypes can add, but not remove methods 子类型可以增加方法，但不可删 – Concrete class must implement all undefined methods 子类型需要实现抽象
类型中的所有未实现方法 – Overriding method must return same type or subtype 子类型中重写的方法
必须有相同或子类型的返回值或者符合co-variance的参数 – Overriding method must accept the same parameter types 子类型中重写的
方法必须使用同样类型的参数或者符合contra-variance的参数 – Overriding method may not throw additional exceptions 子类型中重写的方
法不能抛出额外的异常
 Also applies to specified behavior (methods): – Same or stronger invariants 更强的不变量 – Same or weaker preconditions 更弱的前置条件 – Same or stronger postconditions 更强的后置条件
Liskov
Substitution 
Principle 
(LSP)
9 Construction for Reuse
Example 1 for Behavioral subtyping (LSP)
 Subclass fulfills the same invariants (and additional ones)
 Overridden method has the same pre- and post-conditions
abstract class Vehicle {
int speed, limit;
//@ invariant speed < limit;
//@ requires speed != 0;
//@ ensures speed < \old(speed)
void brake();
}
class Car extends Vehicle {
int fuel;
boolean engineOn;
//@ invariant speed < limit;
//@ invariant fuel >= 0;
//@ requires fuel > 0 && !engineOn;
//@ ensures engineOn;
void start() { … }
void accelerate() { … }
//@ requires speed != 0;
//@ ensures speed < \old(speed)
void brake() { … }
}
9 Construction for Reuse
Example 2 for Behavioral subtyping (LSP)
 Subclass fulfills the same invariants (and additional ones)
 Overridden method start has weaker precondition
 Overridden method brake has stronger postcondition
class Hybrid extends Car {
int charge;
//@ invariant charge >= 0;
//@ requires (charge > 0 
|| fuel > 0) && !engineOn;
//@ ensures engineOn;
void start() { … }
void accelerate() { … }
//@ requires speed != 0;
//@ ensures speed < \old(speed)
//@ ensures charge > \old(charge)
void brake() { … }
}
class Car extends Vehicle {
int fuel;
boolean engineOn;
//@ invariant speed < limit;
//@ invariant fuel >= 0;
//@ requires fuel > 0 && !engineOn;
//@ ensures engineOn;
void start() { … }
void accelerate() { … }
//@ requires speed != 0;
//@ ensures speed < \old(speed)
void brake() { … }
}
9 Construction for Reuse
Behavioral subtyping (LSP)
 How about these two classes? Is LSP satisfied?
class Rectangle {
int h, w;
Rectangle(int h, int w) {
this.h=h; this.w=w;
}
//methods
}
class Square extends Rectangle {
Square(int w) {
super(w, w);
} }
class Rectangle {
//@ invariant h>0 && w>0;
int h, w;
Rectangle(int h, int w) {
this.h=h; this.w=w;
}
//methods
}
class Square extends Rectangle {
//@ invariant h>0 && w>0;
//@ invariant h==w;
Square(int w) {
super(w, w);
} }
Is this Square a behavioral subtype of Rectangle?
9 Construction for Reuse
Behavioral subtyping (LSP)
 How about these two classes? Is LSP satisfied?
class Rectangle {
//@ invariant h>0 && w>0;
int h, w;
Rectangle(int h, int w) {
this.h=h; this.w=w;
}
//@ requires factor > 0;
void scale(int factor) {
w=w*factor;
h=h*factor;
} }
class Square extends Rectangle {
//@ invariant h>0 && w>0;
//@ invariant h==w;
Square(int w) {
super(w, w);
} }
Is this Square a behavioral subtype of Rectangle?
9 Construction for Reuse
Behavioral subtyping (LSP)
Invalidates stronger invariant (w==h) 
in subclass
class Rectangle {
//@ invariant h>0 && w>0;
int h, w;
Rectangle(int h, int w) {
this.h=h; this.w=w;
}
//@ requires factor > 0;
void scale(int factor) {
w=w*factor;
h=h*factor;
}
//@ requires neww > 0;
void setWidth(int neww) {
w=neww;
} }
class Square extends Rectangle {
//@ invariant h>0 && w>0;
//@ invariant h==w;
Square(int w) {
super(w, w);
} }
Is this Square a behavioral subtype of Rectangle?
class GraphicProgram {
void scaleW(Rectangle r, int factor) {
r.setWidth(r.getWidth() * factor);
} }
9 Construction for Reuse
Behavioral subtyping (LSP)
class Rectangle {
//@ invariant h>0 && w>0;
int h, w;
Rectangle(int h, int w) {
this.h=h; this.w=w;
}
//@ requires factor > 0;
void scale(int factor) {
w=w*factor;
h=h*factor;
}
//@ requires neww > 0;
//@ ensures w=neww 
&& h not changed
void setWidth(int neww) {
w=neww;
} }
class Square extends Rectangle {
//@ invariant h>0 && w>0;
//@ invariant h==w;
Square(int w) {
super(w, w);
}
//@ requires neww > 0;
//@ ensures w=neww && h=neww
@Override
void setWidth(int neww) {
w=neww;
h=neww;
} }
9 Construction for Reuse
Liskov Substitution Principle (LSP)
 LSP is a particular definition of a subtyping relation, called 
(strong) behavioral subtyping 强行为子类型化
 In programming languages, LSP is relied on the following 
restrictions: – Preconditions cannot be strengthened in a subtype. 前置条件不能强化 – Postconditions cannot be weakened in a subtype. 后置条件不能弱化 – Invariants of the supertype must be preserved in a subtype. 不变量要保持 – Contravariance of method arguments in a subtype 子类型方法参数：逆变 – Covariance of return types in a subtype. 子类型方法的返回值：协变 – No new exceptions should be thrown by methods of the subtype, except 
where those exceptions are themselves subtypes of exceptions thrown by 
the methods of the supertype. 异常类型：协变 (This is to be discussed in 
Section 7-2)
9 Construction for Reuse
Covariance (协变)  See this example:
 More specific classes may 
have more specific return 
types 
 This is called covariance of 
return types in the subtype.
class T {
Object a() { … }
}
class S extends T {
@Override 
String a() { … } 
} 
class T {
void b( ) throws Throwable {…}
}
class S extends T {
@Override 
void b( ) throws IOException {…}
}
class U extends S {
@Override 
void b( ) {…}
} 
 Every exception declared for the 
subtype’s method should be a 
subtype of some exception declared 
for the supertype’s method. 
父类型子类型：越来越具体specific
返回值类型：不变或变得更具体
异常的类型：也是如此。
9 Construction for Reuse
Contravariance (反协变、逆变)  What do you think of this code?
 Logically, it is called contravariance of method arguments in the 
subtype.
 This is actually not allowed in Java, as it would complicate the 
overloading rules. 目前Java中遇到这种情况，当作overload看待 
class T {
void c( String s ) { … }
}
class S extends T {
@Override 
void c( Object s ) { … } 
} 
父类型子类型：越来越具体specific
参数类型：要相反的变化，要不变或越来
越抽象
The method c(Object) of type S must override or 
implement a supertype method
9 Construction for Reuse
Summary on subtyping and LSP
在Java中都当成overload
9 Construction for Reuse
Co-variance and Contra-variance
 Arrays are covariant 协变的: given the subtyping rules of Java, an 
array of type T[] may contain elements of type T or any subtype of 
T. Number[] numbers = new Number[2];
numbers[0] = new Integer(10);
numbers[1] = new Double(3.14);
Integer[] myInts = {1,2,3,4};
Number[] myNumber = myInts;
myNumber[0] = 3.14; //run-time error!
 At run-time Java knows that this array was actually instantiated as 
an array of integers which simply happens to be accessed through 
a reference of type Number[]. – 区分：Type of an object vs. Type of a reference 
9 Construction for Reuse
Consider LSP for generics 泛型中的LSP
 So, how about in generics?
 Generics are type invariant – ArrayList<String> is a subtype of List<String> – List<String> is not a subtype of List<Object>  The type information for type parameters is discarded by the 
compiler after the compilation of code is done; therefore this type 
information is not available at run time. 
 This process is called type erasure 类型擦除
 Generics are not covariant.
Object obj = new Object();
Integer integer = new Integer(10);
obj = integer;
void someMethod(Number n) 
{ ... }
someMethod(new Integer(10)); 
someMethod(new Double(10.1));
9 Construction for Reuse
What is type erasure?
 Type erasure: Replace all type parameters in generic types with their 
bounds or Object if the type parameters are unbounded. The 
produced bytecode, therefore, contains only ordinary classes, 
interfaces, and methods.
public class Node<T> {
private T data;
private Node<T> next;
public Node(T data, Node<T> next) {
this.data = data;
this.next = next;
}
public T getData() { return data; }
// ...
}
public class Node {
private Object data;
private Node next;
public Node(Object data, 
Node next) {
this.data = data;
this.next = next;
}
public Object getData() { 
return data; }
// ...
}
9 Construction for Reuse
An example
List<Integer> myInts = new ArrayList<Integer>();
myInts.add(1);
myInts.add(2);
List<Number> myNums = myInts; 
myNums.add(3.14);
//compiler error
static long sum(List<Number> numbers) {
long summation = 0;
for(Number number : numbers) {
summation += number.longValue();
}
return summation;
}
List<Integer> myInts = asList(1,2,3,4,5);
List<Long> myLongs = asList(1L, 2L, 3L, 4L, 5L);
List<Double> myDoubles = asList(1.0, 2.0, 3.0, 4.0, 5.0);
sum(myInts); 
sum(myLongs);
sum(myDoubles);
//compiler error
We cannot consider a list of 
integers to be subtype of a list of 
numbers.
That would be considered unsafe 
for the type system and compiler 
rejects it immediately.
9 Construction for Reuse
Consider LSP for generics 泛型中的LSP
 Box<Integer> is not a subtype of 
Box<Number> even though Integer is a 
subtype of Number.  Given two concrete types A and B (for 
example, Number and Integer), 
MyClass<A> has no relationship to 
MyClass<B>, regardless of whether or not A and B are related. The 
common parent of MyClass<A> and MyClass<B> is Object.  For information on how to create a subtype-like relationship 
between two generic classes when the type parameters are related, 
see Wildcards. – https://docs.oracle.com/javase/tutorial/java/generics/wildcards.html
9 Construction for Reuse
Wildcards in Generics
 The unbounded wildcard type is specified using the wildcard 
character (?), for example, List<?>. – This is called a list of unknown type. 
 There are two scenarios where an unbounded wildcard is a useful 
approach: – If you are writing a method that can be implemented using functionality 
provided in the Object class. – When the code is using methods in the generic class that don't depend on 
the type parameter. For example, List.size or List.clear. – In fact, Class<?> is so often used because most of the methods in 
Class<T> do not depend on T.
9 Construction for Reuse
Wildcards in Generics
public static void printList(List<Object> list) {
for (Object elem : list)
System.out.println(elem + " ");
System.out.println();
}
The goal of printList is to print a list of any type, but it fails to achieve that goal 
— it prints only a list of Object instances; it cannot print List<Integer>, 
List<String>, List<Double>, and so on, because they are not subtypes of 
List<Object>. To write a generic printList method, use List<?>
public static void printList(List<?> list) {
for (Object elem: list)
System.out.print(elem + " ");
System.out.println();
}
List<Integer> li = Arrays.asList(1, 2, 3);
List<String> ls = Arrays.asList("one", "two", "three");
printList(li);
printList(ls);
9 Construction for Reuse
Wildcards in Generics
 Lower Bounded Wildcards: <? super A> – List<Integer> List<? super Integer> – The former matches a list of type Integer only, whereas the latter 
matches a list of any type that is a supertype of Integer such as Integer, 
Number, and Object.  Upper Bounded Wildcards: <? extends A> – List<? extends Number>
public static double sumOfList(List<? extends Number> list) {
double s = 0.0;
for (Number n : list)
s += n.doubleValue();
return s;
}
List<Integer> li = Arrays.asList(1, 2, 3);
List<Double> ld = Arrays.asList(1.2, 2.3, 3.5);
9 Construction for Reuse
Consider LSP for generics with wildcards
 List<Number> is a subtype of List<?>
 List<Number> is a subtype of List<? extends Object>
 List<Object> is a subtype of List<? super String>
List<? extends Integer> intList = new ArrayList<>();
List<? extends Number> numList = intList;
9 Construction for Reuse
Consider LSP for generics with wildcards
In the class java.util.Collections:
public static <T> void copy(
List<? super T> dest, 
List<? extends T> src)
List<Number> source = new LinkedList<>();
source.add(Float.valueOf(3));
source.add(Integer.valueOf(2));
source.add(Double.valueOf(1.1));
List<Object> dest = new LinkedList<>();
Collections.copy(dest,source);
Software Construction
(2) Delegation and Composition
9 Construction for Reuse
A Sorting example
 Version A:
 Version B:
9 Construction for Reuse
Interface Comparator<T>
 int compare(T o1, T o2): Compares its two arguments for order. – A comparison function, which imposes a total ordering on some collection 
of objects. – Comparators can be passed to a sort method (such as Collections.sort
or Arrays.sort) to allow precise control over the sort order. Comparators 
can also be used to control the order of certain data structures (such as 
sorted sets or sorted maps), or to provide an ordering for collections of 
objects that don't have a natural ordering.
 如果你的ADT需要比较大小，或者要放入Collections或Arrays进行
排序，可实现Comparator接口并override compare()函数。
9 Construction for Reuse
Interface Comparator<T>
public class Edge {
Vertex s, t;
double weight;
...
}
public class EdgeComparator 
implements Comparator<Edge>{
@Override
public int compare(Edge o1, Edge o2) {
if(o1.getWeight() > o2.getWeight())
return 1;
else if (.. == ..) return 0;
else return -1;
} }
public void sort(List<Edge> edges) {
Comparator comparator = new EdgeComparator();
Collections.sort(edges, comparator);
}
9 Construction for Reuse
Interface Comparable<T>
 This interface imposes a total ordering on the objects of each class 
that implements it. 
 This ordering is referred to as the class's natural ordering, and the 
class's compareTo method is referred to as its natural comparison 
method.
 另一种方法：让你的ADT实现Comparable接口，然后override 
compareTo() 方法
 与使用Comparator的区别：不需要构建新的Comparator类，比较代
码放在ADT内部。
 This is not delegation any longer.
9 Construction for Reuse
Interface Comparable<T>
public class Edge implements Comparable<Edge> {
Vertex s, t;
double weight;
...
public int compareTo(Edge o) {
if(this.getWeight() > o.getWeight())
return 1;
else if (.. == ..) return 0;
else return -1;
} }
9 Construction for Reuse
Delegation
 Delegation is simply when one object relies on another object for 
some subset of its functionality (one entity passing something to 
another entity) 委派/委托：一个对象请求另一个对象的功能 – e.g. the Sorter is delegating functionality to some Comparator
 Judicious delegation enables code reuse 委派是复用的一种常见形式 – Sorter can be reused with arbitrary sort orders – Comparators can be reused with arbitrary client code that needs to 
compare integers
 Delegation can be described as a low level mechanism for sharing 
code and data between entities. – Explicit delegation: passing the sending object to the receiving object – Implicit delegation: by the member lookup rules of the language
9 Construction for Reuse
A simple Delegation example
class A {
void foo() {
this.bar();
}
void bar() {
print("a.bar");
} }
class B {
private A a; // delegation link
public B(A a) {
this.a = a;
}
void foo() {
a.foo(); // call foo() on the a-instance
}
void bar() {
print("b.bar");
} }
A a = new A();
B b = new B(a); // establish delegation between two objects
9 Construction for Reuse
Delegation
 The delegation pattern is a software design pattern for 
implementing delegation, though this term is also used loosely for 
consultation or forwarding. 委派模式：通过运行时动态绑定，实现对
其他类中代码的动态复用
 Delegation is dependent upon dynamic binding, as it requires that 
a given method call can invoke different segments of code at 
runtime. 
 Process – The Receiver object delegates operations to the Delegate object – The Receiver object makes sure, that the Client does not misuse the 
Delegate object.
delegates to Client Receiver Delegate calls
9 Construction for Reuse
Using delegation to extend functionality
 Consider java.util.List
我需要一个能log的List
 Suppose we want a list that logs its operations to the console… – The LoggingList is composed of a List, and delegates (the non-logging) 
functionality to that List.
这里实现动态绑定
这里进行功能委派
9 Construction for Reuse
 Inheritance: Extending a Base class by a new operation or 
overwriting an operation. 
 Delegation: Catching an operation and sending it to another object.
 Many design patterns use a combination of inheritance and 
delegation.
+Add()
+Remove()
List
Stack
+Push()
+Pop()
+Top()
+Push()
+Pop()
+Top()
Stack
Add()
Remove()
List
Delegation vs. Inheritance
9 Construction for Reuse
Delegation vs. Inheritance
 Lab2的P2中，要复用P1中开发出的Graph<L>完成社交网络相关功能
public class FriendshipGraph {
private Graph<Person> graph = Graph.empty();
public void addVertex(Person p) {
graph.add(p);
}
...
public void getDistance(Person a, Person b) {
//Graph<L>不具备该功能，需要自己实现
} }
9 Construction for Reuse
Delegation vs. Inheritance
 Lab2的P2中，要复用P1中开发出的Graph<L>完成社交网络相关功能
public class FriendshipGraph<Person> 
extends ConcreteEdgeGraph<Person> {
@Override
public void addVertex(Person p) {
...
super.add(p);
}
...
public void getDistance(Person a, Person b) {
//Graph<L>不具备该功能，需要自己实现
} }
9 Construction for Reuse
Replace Inheritance with Delegation
 Problem: You have a subclass that uses only a portion of the 
methods of its superclass (or it‘s not possible to inherit superclass 
data). 如果子类只需要复用父类中的一小部分方法
 Solution: Create a field and put a superclass object in it, delegate 
methods to the superclass object, and get rid of inheritance. 可以不需
要使用继承，而是通过委派机制来实现
 In essence, this refactoring splits both classes and makes the 
superclass the helper of the subclass, not its parent. – Instead of inheriting all superclass methods, the subclass will have only 
the necessary methods for delegating to the methods of the superclass 
object. 一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法 – A class does not contain any unneeded methods inherited from the 
superclass. 从而避免大量无用的方法
9 Construction for Reuse
Replace Inheritance with Delegation
class RealPrinter {
void print() {
System.out.println("Printing Data");
}
} 
class Printer extends RealPrinter { 
void print(){
super.print();
} }
Printer printer = new Printer();
printer.print();
class RealPrinter {
void print() {
System.out.println("The Delegate");
} }
class Printer {
RealPrinter p = new RealPrinter();
void print() {
p.print();
} }
Printer printer = new Printer();
printer.print();
Inheritance
Delegation
9 Construction for Reuse
Composite over inheritance principle
 Or called Composite Reuse Principle (CRP) – Classes should achieve polymorphic behavior and code reuse by 
their composition (by containing instances of other classes that implement 
desired functionality) rather than inheritance from a base or parent class. – It is better to compose what an object can do (has_a or use_a) than 
extend what it is (is_a).
 Delegation can be seen as a reuse mechanism at the object level, 
while inheritance is a reuse mechanism at the class level.“委托”
发生在object层面，而“继承”发生在class层面
9 Construction for Reuse
CRP example
 An Employee class has a method for computing the employee's 
annual bonus:
class Employee {
Money computeBonus() {... // default computation}
...
}  Different subclasses of Employee: Manager, Programmer, Secretary, 
etc. may want to override this method to reflect the fact that some 
types of employees get more generous bonuses than others:
class Manager extends Employee {
@Override
Money computeBonus() {... // special computation}
...
}
9 Construction for Reuse
CRP example
 There are several problems with this solution. – All Manager objects get the same bonus. What if we wanted to vary the 
bonus computation among managers? ——To introduce a special subclass 
of Manager?
class SeniorManager extends Manager {
@Override
Money computeBonus() {... // more special computation}
...
} – What if we wanted to change the bonus computation for a particular 
employee? For example, what if we wanted to promote Smith from 
Manager to SeniorManager? – What if we decided to give all managers the same bonus that 
programmers get? Should we copy and paste the computation algorithm 
from Programmer to Manager?
9 Construction for Reuse
 The problem is: the bonus calculator for each employer may be 
different and be changed frequently. – The relation between Employee and bonus calculator should be in the 
object level instead of class level. 核心问题：每个Employee对象的奖金计
算方法都不同，在object层面而非class层面。
 A CRP solution:
CRP Example
class Manager {
ManagerBonusCalculator mbc = new ManagerBonusCalculator();
Money computeBonus() {
return mbc.computeBonus();
} }
class ManagerBonusCalculator {
Money computeBonus {... // special computation}
}
And so does for class 
Programmer and others
9 Construction for Reuse
CRP example: more general design
class Employee {
BonusCalculator bc;
...
}
interface BonusCalculator {
Money computeBonus();
}
class Manager extends Employee {
Money computeBonus() {
bc = new ManagerBonusCalculator();
return bc.computeBonus();
} }
class ManagerBonusCalculator implements BonusCalculator {
Money computeBonus {... // special computation}
}
Delegation：委托 Inheritance：继承
Implement：接口实现
Delegation：object层面的委托
9 Construction for Reuse
CRP example: more general design
Client
Sub Type 
1.1
Sub Type 
1.n
Sub Type 
2.n
Sub Type 
2.1
Interface 1
(or Abstract 
Class 1)
Interface 2
(or Abstract 
Class 2)
delegation
delegation
9 Construction for Reuse
Composite over inheritance principle 更普适的
 一个假象的场景： – 你要开发一套动物ADT，各种不同种类的动物，每类动物有自己的独特
“行为”，某些行为可能在不同类型的动物之间复用。 – 考虑到生物学和AI的进展，动物的“行为”可能发生会发生变化；
 例如： – 行为：飞、叫、… – 动物：既会飞又会叫的鸭子、天鹅；不会飞但会叫的猫、狗；… – 有10余种“飞”的方式、有10余种“叫”的方式；而且持续增加
class duck {
void fly() {…//飞法1}
void quack() {…//叫法1}
}
class swan {
void fly() {…//飞法2}
void quack() {…//叫法2}
}
直接面向具体类型动物的编程：类
缺陷：存在大量的重复；不易变化
9 Construction for Reuse
Composite over inheritance principle 更普适的
class flyableAnimal {
//实现通用的飞法
void fly() {…//飞法1}
abstract void quack();
}
class duckLikeAnimal extends flyableAnimal {
@Override //如果某类动物飞法不同，则override重写新“飞法”
void fly() {…//飞法2}
@Override //针对该动物的叫法，写具体实现；不会叫则保持实现体为空即可
void quack() {…//叫法1}
}
通过inheritance实现对某些通用行为的复用
缺点：需要针对“飞法”设计复杂的继承关系树；不能
同时支持针对“叫法”的继承；动物行为发生变化时，
继承树要随之变化。
9 Construction for Reuse
Composite over inheritance principle 更普适的
 An implementation of composition over inheritance typically 
begins with the creation of various interfaces representing the 
behaviors that the system must exhibit. 
 Classes implementing the identified interfaces are built and added 
to business domain classes 
as needed. 
 Thus, system behaviors are 
realized without inheritance.
 使用接口定义系统必须对外
展示的不同侧面的行为
 接口之间通过extends实现
行为的扩展（接口组合）
 类implements 组合接口
 从而规避了复杂的继承关系
9 Construction for Reuse
Composite over inheritance principle
interface Flyable {
public void fly();
}
interface Quackable {
public void quack();
}
class FlyWithWings implements Flyable { 
@Override
public void fly() {
System.out.println("fly with wings");
} }
class Quack implements Quackable {
@Override
public void quack() {
System.out.println("quack like duck");
} }
两个接口，定义
抽象行为
接口的具体实现，
可以有多种方式，
在具体类中实现具
体行为
9 Construction for Reuse
Composite over inheritance principle
interface Ducklike extends Flyable, Quackable {}
public class Duck implements Ducklike {
Flyable flyBehavior;
Quackable quackBehavior;
void setFlyBehavior(Flyable f) {
this.flyBehavior = f; }
void setQuackBehavior(Quackable q) {
this.quackBehavior = q; }
@Override
public void fly() {
this.flyBehavior.fly();
}
@Override
public void quack() {
this.quackBehavior.quack();
} }
Client code:
Flyable f = new FlyWithWings();
Quackable q = new Quack();
Duck d = new Duck();
d.setFlyBehavior(f);
d.setQuackBehavior(q);
d.fly();
d.quack();
从组合接口中派
生具体类 Delegation
设置
Delegation
对象实例
通过
Delegation实
现具体行为
对接口编程
接口的组合，定
义了行为的组合
9 Construction for Reuse
Types of delegation
 Use (A use B)
 Association (A has B)
 Composition/aggregation (A owns B) – 可以认为Composition/Aggregation是Association的两种具体形态
 This classification is in terms of the “coupling degree” between the 
delegate and delegator.
delegates to
Use
Composition
Aggregation
Association 
Client Receiver Delegate calls
9 Construction for Reuse
 The simplest form of using classes is calling its methods;  This form of relationship between two classes is called “uses-a” 
relationship, in which one class makes use of another without 
actually incorporating it as a property. -it may, for example, be a 
parameter or used locally in a method.
 Dependency: a temporary relationship that an object requires other 
objects (suppliers) for their implementation. 
(1) Dependency: 临时性的delegation
class Duck {
//no field to keep Flyable object
void fly(Flyable f) {
f.fly();
} }
Flyable f = new FlyWithWings();
Quackable q = new Quack();
Duck d = new Duck();
d.fly(f);
d.quack(q);
9 Construction for Reuse
(2) Association: 永久性的delegation
 Association: a persistent relationship between classes of objects that 
allows one object instance to cause another to perform an action on 
its behalf. – has_a: one class has another as a property/instance variable – This relationship is structural, because it specifies that objects of one kind 
are connected to objects of another and does not represent behavior.
class Duck {
Flyable f = new CannotFly();
void Duck(Flyable f) { 
this.f = f; 
}
void Duck() {
f = new FlyWithWings();
}
void fly() { f.fly(); } }
Flyable f = new FlyWithWings();
Duck d = new Duck(f);
Duck d2 = new Duck();
d.fly();
9 Construction for Reuse
(3) Composition: 更强的association，但难以变化
 Composition is a way to combine simple objects or data types into 
more complex ones. – is_part_of: one class has another as a property/instance variable – Implemented such that an object contains another object.
class Duck {
Flyable f = new FlyWithWings();
void fly() {
f.fly();
} }
Duck d = new Duck();
d.fly();
9 Construction for Reuse
(4) Aggregation: 更弱的association，可动态变化
 Aggregation: the object exists outside the other, is created outside, so 
it is passed as an argument to the construtor. – has_a
class Duck {
Flyable f;
void Duck(Flyable f) { 
this.f = f; 
}
void setFlyBehavior(f) {
this.f = f;
}
void fly() { f.fly();} }
Flyable f = new FlyWithWings();
Duck d = new Duck(f);
d.fly();
d.setFlyBehavior(new CannotFly());
d.fly();
9 Construction for Reuse
Composition vs. Aggregation
 In composition, when the owning object is destroyed, so are the 
contained objects. – A university owns various departments, and each department has a 
number of professors. If the university closes, the departments will no 
longer exist, but the professors in those departments will continue to exist. 
 In aggregation, this is not necessarily true. – A University can be seen as a composition of departments, whereas 
departments have an aggregation of professors. A Professor could 
work in more than one department, but a department could not be part 
of more than one university.
9 Construction for Reuse
Composition vs. Aggregation
public class WebServer {
private HttpListener listener;
private RequestProcessor processor;
public WebServer(HttpListener listener, RequestProcessor processor) {
this.listener = listener;
this.processor = processor;
} }
public class WebServer {
private HttpListener listener;
private RequestProcessor processor;
public WebServer() {
this.listener = new HttpListener(80);
this.processor = new RequestProcessor(“/www/root”);
} }
Which is Composition?
Which is Aggregation?
9 Construction for Reuse
Types of delegation
 Use (A use one or multiple B)
 Association (A has one or multiple B)
 Composition/aggregation (A owns one or multiple B)
 都支持1对多的delegation——
class Professor {
List<Student> ls; //永久保存delegation关系
void enroll(Student s) { 
this.ls.add(s); //建立delegation关系
}
void evaluate() { 
double score = 0;
for(Student s : ls) 
score += s.evaluate(this); //逐个delegate
} }
Software Construction
6 Designing system-level reusable 
API libraries and Frameworks
9 Construction for Reuse
Libraries
 Library: A set of classes and methods (APIs) that provide reusable 
functionality
9 Construction for Reuse
Why is API design important?
 If you program, you are an API designer, and APIs can be among 
your greatest assets API是程序员最重要的资产和“荣耀”，吸引外
部用户，提高声誉 – Good code is modular – each module has an API – Users invest heavily: acquiring, writing, learning
– Thinking in terms of APIs improves code quality
– Successful public APIs capture users
 Can also be among your greatest liabilities – Bad API can cause unending stream of support calls – Can inhibit ability to move forward
 Public APIs are forever – one chance to get it 
right – Once module has users, can’t change API at will
建议：始终以开发API的
标准面对任何开发任务
面向“复用”编程
而不是面向“应用”编程
难度：要有足够良好的设
计，一旦发布就无法再自
由改变
9 Construction for Reuse
Whitebox and Blackbox frameworks
 Whitebox frameworks – Extension via subclassing and overriding methods – Common design pattern(s): Template Method
– Subclass has main method but gives control to framework
 Blackbox frameworks – Extension via implementing a plugin interface – Common design pattern(s): Strategy, Observer – Plugin-loading mechanism loads plugins and gives control to the 
framework
9 Construction for Reuse
A calculator example (without a framework)
9 Construction for Reuse
A simple whitebox framework
子类中由开发
者通过
override完成
定制的功能
9 Construction for Reuse
Using the whitebox framework
Overriding
Extension via subclassing and overriding methods
Subclass has main method but gives control to framework
Overriding
9 Construction for Reuse
An example blackbox framework
public class Application extends JFrame {
private JTextField textField;
private Plugin plugin;
public Application() { }
protected void init(Plugin p) {
p.setApplication(this);
this.plugin = p;
JPanel contentPane = new JPanel(new BorderLayout());
contentPane.setBorder(new BevelBorder(BevelBorder.LOWERED));
JButton button = new JButton();
button.setText(plugin != null ? plugin.getButtonText() : "ok");
contentPane.add(button, BorderLayout.EAST);
textField = new JTextField("");
if (plugin != null) 
textField.setText(plugin.getInititalText());
textField.setPreferredSize(new Dimension(200, 20));
contentPane.add(textField, BorderLayout.WEST);
if (plugin != null) 
button.addActionListener((e) -> { plugin.buttonClicked(); } );
this.setContentPane(contentPane);
...
}
public String getInput() { return textField.getText(); }
}
public interface Plugin {
String getApplicationTitle();
String getButtonText();
String getInititalText();
void buttonClicked() ;
void setApplication(Application app);
}
9 Construction for Reuse
Using the blackbox framework
Extension via implementing a plugin interface
Plugin-loading mechanism loads plugins and gives 
control to the framework
9 Construction for Reuse
Another example of white-box framework
public abstract class PrintOnScreen {
public void print() {
JFrame frame = new JFrame();
JOptionPane.showMessageDialog(frame, textToShow());
frame.dispose();
}
protected abstract String textToShow();
} 
public class MyApplication extends PrintOnScreen {
@Override
protected String textToShow() {
return "printing this text on "
+ "screen using PrintOnScreen "
+ "white Box Framework";
} }
Extension 
point
Main body of 
framework
REUSE
Overriding
MyApplication m = new MyApplication();
m.print();
9 Construction for Reuse
Another example of black-box framework
public final class PrintOnScreen {
TextToShow textToShow; 
public PrintOnScreen(TextToShow tx) {
this.textToShow = tx;
}
public void print() {
JFrame frame = new JFrame();
JOptionPane.showMessageDialog(frame, 
textToShow.text());
frame.dispose();
} }
public interface TextToShow {
String text();
}
public class MyTextToShow 
implements TextToShow {
@Override
public String text() {
return "Printing";
} }
PrintOnScreen m =
new PrintOnScreen(new MyTextToShow());
m.print();
Extension 
point by 
composition
Plugin
9 Construction for Reuse
Another example of black-box framework
public final class PrintOnScreen {
TextToShow textToShow; 
public PrintOnScreen(TextToShow tx) {
this.textToShow = tx;
}
public void print() {
JFrame frame = new JFrame();
JOptionPane.showMessageDialog(frame, 
textToShow.text());
frame.dispose();
} }
public interface TextToShow {
String text();
}
public class MyTextToShow 
implements TextToShow {
@Override
public String text() {
return "Printing";
} }
PrintOnScreen m =
new PrintOnScreen(new MyTextToShow());
m.print();
如果有多个plugin怎么办？
如果通过配置文件选择加载
某个plugin，怎么做？
9 Construction for Reuse
Whitebox vs. Blackbox Frameworks
 Whitebox frameworks use subclassing/subtyping ---继承 – Allows extension of every non-private method
– Need to understand implementation of superclass – Only one extension at a time – Compiled together – Often so-called developer frameworks
 Blackbox frameworks use composition -- 委派/组合 – Allows extension of functionality exposed in interface – Only need to understand the interface – Multiple plugins – Often provides more modularity
– Separate deployment possible (.jar, .dll, …) – Often so-called end-user frameworks, platforms
9 Construction for Reuse
Whitebox vs. Blackbox Frameworks
终端用户 Framework Plugin 
Interface
User-defined 
Class
终端用户
Framework
User-defined 
Class
Blackbox Framework
Whitebox Framework
Reusable 
Code
Reusable 
Code
Delegation￾based
Inheritance￾based
Software Construction
Summary
9 Construction for Reuse
Summary
 What is software reuse? 
 How to measure “reusability”?
 Levels and morphology of reusable components – Source code level reuse – Module-level reuse: class/interface – Library-level: API/package – System-level reuse: framework
9 Construction for Reuse
Summary
 Designing reusable classes – Inheritance and overriding
– Overloading
– Parametric polymorphism and generic programming
– Behavioral subtyping and Liskov Substitution Principle (LSP) – Composition and delegation 
 Designing system-level reusable libraries and frameworks – API and Library
– Framework 
Software Construction
The end
June 7, 2021Software Construction
10 Construction for Change
面向可维护性的构造技术
Wang Zhongjie
rainy@hit.edu.cn
June 9, 2021
10 Construction for Change
Outline
 Software Maintenance and Evolution
 Metrics of Maintainability
 Modular Design and Modularity Principles
 OO Design Principles: SOLID
 Grammar-based construction
– Grammar and Parser – Regular Expression (regexp)
本次课面向另一个质量指标：可维护性——软件
发生变化时，是否可以以很小的代价适应变化？
（1）什么是软件维护；
（2）可维护性如何度量；
（3）实现高可维护性的设计原则
（4）基于语法的构造技术
10 Construction for Change
Reading
 软件工程--实践者的研究方法：第23章  Object-Oriented Software Construction：第3章  MIT 6.031：17、18
 Java编程思想：第13.6节
Software Construction
1 Software Maintenance and 
Evolution
10 Construction for Change
What is Software Maintenance?  Software maintenance in software engineering is the modification of 
a software product after delivery to correct faults, to improve 
performance or other attributes. 软件维护：修复错误、改善性能
 In "ISO/IEC 14764:2006 Software 
Engineering — Software Life Cycle 
Processes — Maintenance"
10 Construction for Change
Operation & Maintenance Engineer 运维工程师
 Maintenance is one of the most difficult aspects of software 
production because maintenance incorporates aspects of all other 
phases 运维是软件开发中最困难的工作之一
 A fault is reported from users and is to be handed by a 
maintenance engineer. 处理来自用户报告的故障/问题
 A maintenance engineer must have superb debugging skills – The fault could lie anywhere 
within the product, and the 
original cause of the fault might 
lie in the by now non-existent 
specifications or design documents 
(bug/issue localization). – Superb diagnostic skills, testing 
skills and documentation skills 
are required (testing, fix, and 
documenting changes).
10 Construction for Change
Operation & Maintenance Engineer 运维工程师
10 Construction for Change
Operation & Maintenance Engineer 运维工程师
 阿里运维工程师职责： – 负责系统稳定性工作； – 生产系统部署、上线； – 维护生产系统网络安全、
稳定、可靠； – 维护生产系统数据备份；
 岗位要求： – 深入理解运维体系结构，精于容量规划、架构设计、性能优化； – 熟悉服务管理、单元部署、自动扩容等运维系统建设，
对成本控制和效能提升有深刻的理解和实践 – 熟悉故障、监控、限流、降级、预案、扩容工作原理； – 熟悉java虚拟机，对java应用的部署及系统优化有一定的经验； – 熟悉自动化发布工具、熟悉docker技术优先； – …
大多数运维
任务并非需
要涉及代码
修改。
但是有时候
不得不回到
代码层面…
10 Construction for Change
After fixing the code
 More Steps: – Test that the modification works correctly: use specially constructed test 
cases 测试所做的修改 – Check for regression faults: use stored test data, and add specially test cases 
to stored test data for future regression testing 回归测试 – Document all changes 记录变化
 How to minimize regression faults 除了修复问题，修改中不能引入新
的故障 – Consult the detailed documentation and make use of constructed test cases.
 What usually happens: no enough documentation / test cases 最大的
问题：修改后没有足够的文档记录和测试 – The operation engineer has to deduce from the source code itself all the 
information needed to avoid introducing a regression fault. 
10 Construction for Change
Types of software maintenance
 Corrective maintenance 25% 纠错性 – Reactive modification of a software product 
performed after delivery to correct discovered 
problems;
 Adaptive maintenance 21% 适应性 – Modification of a software product performed after 
delivery to keep a software product usable in a 
changed or changing environment;
 Perfective maintenance 50% 完善性 – Enhancement of a software product after delivery to 
improve performance or maintainability;
 Preventive maintenance 4% 预防性 – Modification of a software product after delivery to 
detect and correct latent faults in the software product 
before they become effective faults.
10 Construction for Change
Software Evolution
 Software evolution is a term used in software maintenance, 
referring to the process of developing software initially, then 
repeatedly updating it for various reasons. 软件演化：对软件进行持
续的更新
 Over 90% of the costs of a typical system arise in the maintenance 
phase, and that any successful piece of software will inevitably be 
maintained. 软件的大部分成本来自于维护阶段
10 Construction for Change
Software Evolution
 Multiple versions in the life of a software: From 1 to n
Initial
Version
Updated
Version 1
Discarded
Version
Updated
Version 2 …
10 Construction for Change
Lehman’s Laws on Software Evolution
 Feedback System
 Continuing Change
 Continuing Growth
 Declining Quality
 Increasing Complexity
 Self Regulation
– Conservation of Organizational Stability
– Conservation of Familiarity 
“变化”在软件生命周期中是不可避免的！
如何在最初的设计中充分考虑到未来的变化，
避免因为频繁变化导致软件复杂度的增加和质
量的下降？
10 Construction for Change
Maintenance is not just the task of op engineers…
 Maintenance is not just the task of maintenance and operation 
engineers, but also a potential task of software designers and 
developers. 软件维护不仅仅是运维工程师的工作，而是从设计和开
发阶段就开始了
 For them, it is mandatory to consider future potential 
changes/extensions of the software during the design and 
construction phases; 在设计与开发阶段就要考虑将来的可维护性
 So that flexible and extensible design/constructions are 
comprehensively considered, in other words, “easy to change / 
extension”. 设计方案的“easy to change”  This is what’s called “maintainability”, “extensibility” and 
“flexibility” of software construction.
10 Construction for Change
Examples of maintainability-oriented construction
 Modular design and implementation 模块化 – Low coupling and high cohesion
 OO design principles OO设计原则 – SOLID、GRASP
 OO design patterns OO设计模式 – Factory method pattern, Builder pattern – Bridge pattern, Proxy pattern
– Memento pattern, State pattern
 State-based construction (Automata-based programming) 基于状态
的构造技术
 Table-driven construction 表驱动的构造技术
 Grammar-based construction 基于语法的构造技术
Software Construction
2 Metrics of Maintainability
10 Construction for Change
Many names of maintainability
 Maintainability 可维护性—"The ease with which a software system 
or component can be modified to correct faults, improve
performance, or other attributes, or adapt to a changed 
environment".
 Extensibility 可扩展性— Software design/implementation takes 
future growth into consideration and is seen as a systemic measure 
of the ability to extend a system and the level of effort required to 
implement the extension.
 Flexibility 灵活性—The ability of software to change easily in 
response to user requirements, external technical and social 
environments, etc.
 Adaptability 可适应性— The ability of an interactive system 
(adaptive system) that can adapt its behavior to individual users 
based on information acquired about its user(s) and its environment.
Ready for Change
Ready for Extension
10 Construction for Change
Many names of maintainability
 Manageability 可管理性 —How efficiently and easily a software 
system can be monitored and maintained to keep the system 
performing, secure, and running smoothly.
 Supportability 支持性—How effectively a software can be kept
running after deployment, based on resources that include quality 
documentation, diagnostic information, and knowledgeable and 
available technical staff.
10 Construction for Change
Questions about maintainability
 Code review的时候经常问的关于可维护性的问题： – Structural and design simplicity: how easy is it to change things? 设计结构
是否足够简单？ – Are things tightly or loosely coupled (i.e., separation of concerns)?模块之
间是否松散耦合？ – Are all elements in a package/module cohesive and their responsibilities 
clear and closely related? 模块内部是否高度聚合？ – Does it have overly deep inheritance hierarchies or does it favor 
composition over inheritance? 是否使用了非常深的继承树，是否使用了
delegation替代继承？ – How many independent paths of execution are there in the method 
definitions (i.e., cycolmatic complexity)? 代码的圈复杂度是否太高？ – How much code duplication exists? 是否存在重复代码？ – …
10 Construction for Change
Some common-used maintainability metrics
 Cyclomatic Complexity 圈复杂度 - Measures the 
structural complexity of the code. – It is created by calculating the number of different code 
paths in the flow of the program. – A program that has complex control flow will require 
more tests to achieve good code coverage and will be 
less maintainable. – CC = E-N+2, CC=P+1, CC=number of areas
 Lines of Code 代码行数 - Indicates the approximate 
number of lines in the code. – A very high count might indicate that a type or method 
is trying to do too much work and should be split up. – It might also indicate that the type or method might be 
hard to maintain.
10 Construction for Change
Some common-used maintainability metrics
 Halstead Volume: a composite 
metric based on the number of 
(distinct) operators and 
operands in source code.
10 Construction for Change
Some common-used maintainability metrics
 Maintainability Index (MI) 可维护性指数- Calculates an index value 
between 0 and 100 that represents the relative ease of maintaining 
the code. 
 A high value means better maintainability. It is calculated based 
on: – Halstead Volume (HV) – Cyclomatic Complexity (CC) – The average number of lines of code per module (LOC) – The percentage of comment lines per module (COM).
10 Construction for Change
Some common-used maintainability metrics
 Depth of Inheritance 继承的层次数 - Indicates the number of class 
definitions that extend to the root of the class hierarchy. The deeper 
the hierarchy the more difficult it might be to understand where 
particular methods and fields are defined or/and redefined. 
 Class Coupling 类之间的耦合度 - Measures the coupling to unique 
classes through parameters, local variables, return types, method 
calls, generic or template instantiations, base classes, interface 
implementations, fields defined on external types, and attribute 
decoration. – Good software design dictates that types and methods should have high 
cohesion and low coupling. – High coupling indicates a design that is difficult to reuse and maintain 
because of its many interdependencies on other types.
 Unit test coverage单元测试的覆盖度 - indicates what part of the code 
base is covered by automated unit tests. (to be studied in Chapter 7)
10 Construction for Change
Many other maintainability metrics
 请自行查阅资料加以理解
Software Construction
3 Modular Design and Modularity 
Principles
10 Construction for Change
Modular programming 模块化编程
 Modular programming is a design technique that emphasizes 
separating the functionality of a program into independent, 
interchangeable modules, such that each contains everything 
necessary to execute only one aspect of the desired functionality. 
 High-level decomposition of the code of an entire program into 
pieces in both Structured Programming and OOP.
Edager Dijkstra (1930-2002)
Turing Award 1972
Niklaus Wirth (1934-)
Turing Award 1984
David L. Parnas (1941- )
10 Construction for Change
Modular programming
 The goal of design is to partition the system into modules and 
assign responsibility among the components in a way that: – High cohesion within modules 高内聚 – Loose coupling between modules 低耦合
 Modularity reduces the total complexity a programmer has to deal 
with at any one time assuming: – Functions are assigned to modules in away that groups similar functions 
together (Separation of concerns) 分离关注点 – There are small, simple, well-defined interfaces between modules 
(Information hiding) 信息隐藏
 The principles of cohesion and coupling are probably the most 
important design principles for evaluating the maintainability of a 
design.
Software Construction
(1) Five Criteria for Evaluating 
Modularity
10 Construction for Change
Five Criteria for Evaluating Modularity
 Decomposability (可分解性) – Are larger components decomposed into smaller components?
 Composability (可组合性) – Are larger components composed from smaller components?
 Understandability (可理解性) – Are components separately understandable?
 Continuity (可持续性) ——发生变化时受影响范围最小 – Do small changes to the specification affect a localized and limited number 
of components?
 Protection (出现异常之后的保护) ——出现异常后受影响范围最小 – Are the effects of run-time abnormalities confined to a small number of 
related components?
Software Construction
(2) Five Rules of Modularity Design
10 Construction for Change
Five Rules of Modularity Design
 Direct Mapping (直接映射)  Few Interfaces (尽可能少的接口)  Small Interfaces (尽可能小的接口)  Explicit Interfaces (显式接口)  Information Hiding (信息隐藏)
Software Construction
(3) Coupling and Cohesion
10 Construction for Change
Coupling
 Coupling is the measure of dependency between modules. A 
dependency exists between two modules if a change in one could 
require a change in the other.
 The degree of coupling between modules is determined by: – The number of interfaces between modules (quantity), and
– Complexity of each interface (determined by the type of communication) 
(quality)
10 Construction for Change
Coupling between HTML, CSS and JavaScript
 A well-designed web app modularizes around: – HTML files which specify data and semantics – CSS rules which specify the look and formatting of HTML data – JavaScript which defines behavior/interactivity of page
10 Construction for Change
 HTML:
 CSS:
 Output:
<!doctype html>
<html>
<head>
<script type="text/javascript" src="base.js"></script>
<link rel="stylesheet" href="default.css">
</head>
<body>
<button onclick="highlight2()">Highlight</button>
<button onclick="normal2()">Normal</button>
<h1 id="title" class="NormalClass">CSS <--> JavaScript Coupling</h1>
</body>
</html>
.NormalClass {
color:inherit;
font-style:normal;
}
Coupling between HTML, CSS and JavaScript
10 Construction for Change
Coupling between HTML, CSS and JavaScript
 JavaScript code modifies the style attribute of HTML element.
function highlight() {
document.getElementById("title").style.color="red";
document.getElementById("title").style.fontStyle="italic";
}
function normal() {
document.getElementById("title").style.color="inherit";
document.getElementById("title").style.fontStyle="normal";
}  Or, JavaScript code modifies the class attribute of HTML element.
function highlight() {
document.getElementById("title").className = "HighlightClass";
}
function normal() {
document.getElementById("title").className = "NormalClass";
}
10 Construction for Change
Cohesion
 Cohesion is a measure of how strongly related the functions or 
responsibilities of a module are.
 A module has high cohesion if all of its elements are working 
towards the same goal. 
10 Construction for Change
Cohesion and Coupling
 The best designs have high cohesion (also called strong cohesion) 
within a module and low coupling (also called weak coupling) 
between modules.
10 Construction for Change
Coupling and Cohesion are with trade-off
 When Coupling is high, cohesion tends to be low and vise versa.
Software Construction
4 OO Design Principles: SOLID
10 Construction for Change
SOLID: 5 classes design principles
 (SRP) The Single Responsibility Principle 单一责任原则
 (OCP) The Open-Closed Principle 开放-封闭原则
 (LSP) The Liskov Substitution Principle Liskov替换原则
 (DIP) The Dependency Inversion Principle 依赖转置原则
 (ISP) The Interface Segregation Principle 接口聚合原则
Software Construction
(1) Single Responsibility Principle 
(SRP)
单一责任原则
10 Construction for Change
Single Responsibility Principle
 “There should never be more than one reason for a class to 
change”, i.e., a class should concentrate on doing one thing and 
one thing only. 不应该有多于1个原因让你的ADT发生变化，否则就
拆分开
Just because you can, doesn’t mean you should
10 Construction for Change
(SRP) The Single Responsibility Principle
 Responsibility: “a reason for change.” (责任：变化的原因)  SRP: – There should never be more than one reason for a class to change. (不应有
多于1个的原因使得一个类发生变化) – One class, one responsibility. (一个类，一个责任)  如果一个类包含了多个责任，那么将引起不良后果： – 引入额外的包，占据资源 – 导致频繁的重新配置、部署等
 The SRP is one of the simplest of the principle, and one of the 
hardest to get right. (最简单的原则，却是最难做好的原则)
10 Construction for Change
SRP的一个反例
+ draw( )
Rectangle类既包含GUI的绘图功能
draw()-在GUI上显示矩形，
又包括几何计算功能area()-计算面积。
该设计违反了SRP。
通过分解，将两个无关
的责任分离开来，
分别放置在两个类中：
• Geometric Rectangle
类负责计算面积，
• Rectangle类负责在
GUI上绘图。
10 Construction for Change
Single Responsibility Principle
 Two resposibilities – Connection Management – Data Communication
interface Modem {
public void dial(String pno);
public void hangup();
public void send(char c);
public char recv();
}
interface DataChannel {
public void send(char c);
public char recv();
}
interface Connection {
public void dial(String phn);
public char hangup();
}
Software Construction
(2) Open/Closed Principle (OCP)
（面向变化的）开放/封闭原则
10 Construction for Change
(OCP) The Open-Closed Principle
 Classes should be open for extension (对扩展性的开放) – This means that the behavior of the module can be extended. That we can 
make the module behave in new and different ways as the requirements of 
the application change, or to meet the needs of new applications. (模块的
行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化)  But closed for modification. (对修改的封闭) – The source code of such a module is inviolate. No one is allowed to make 
source code changes to it. (但模块自身的代码是不应被修改的) – The normal way to extend the behavior of a module is to make changes to 
that module. (扩展模块行为的一般途径是修改模块的内部实现) – A module that cannot be changed is normally thought to have a fixed 
behavior. (如果一个模块不能被修改，那么它通常被认为是具有固定的行为)
10 Construction for Change
Open Closed Principle
 Key: abstraction (关键的解决方案：抽象技术)  "Software entities (classes, modules, functions, etc.) should be 
open for extension, but closed for modification“, i.e., change a 
class' behavior using inheritance and composition/delegation
10 Construction for Change
OCP的一个反例
如果有多种类型的Server，那么针对每一种新出现的
Server，不得不修改Server类的内部具体实现。
通过构造一个抽象的Server类：
AbstractServer，该抽象类中包含针
对所有类型的Server都通用的代码，从
而实现了对修改的封闭；
当出现新的Server类型时，只需从该抽
象类中派生出具体的子类
ConcreteServer即可，从而支持了对
扩展的开放。
10 Construction for Change
Open Closed Principle
// Open-Close Principle - Bad example
class GraphicEditor {
public void drawShape(Shape s) {
if (s.m_type==1)
drawRectangle(s);
else if (s.m_type==2)
drawCircle(s);
}
public void drawCircle(Circle r) 
{....}
public void drawRectangle(Rectangle r) 
{....}
}
class Shape {
int m_type;
}
class Rectangle extends Shape {
Rectangle() {
super.m_type=1;
} }
class Circle extends Shape {
Circle() {
super.m_type=2;
}
一大堆复杂的 } 
if-else 
/switch-case
结构，维护起来
非常麻烦
10 Construction for Change
Open Closed Principle - Improved
// Open-Close Principle - Good example
class GraphicEditor {
public void drawShape(Shape s) {
s.draw();
} }
class Shape {
abstract void draw();
}
class Rectangle extends Shape {
public void draw() {
// draw the rectangle
}
} 
Software Construction
(3) Liskov Substitution Principle 
(LSP)
Liskov替换原则
10 Construction for Change
(LSP) The Liskov Substitution Principle
 "Functions that use pointers or references to base classes must be 
able to use objects of derived classes without knowing it“, i.e., 
subclasses should behave nicely when used in place of their base 
class
 LSP: Subtypes must be substitutable for their base types. (子类型必
须能够替换其基类型) 
 Derived Classes must be usable through the base class interface 
without the need for the client to know the difference. (派生类必须
能够通过其基类的接口使用，客户端无需了解二者之间的差异)  Already discussed in Section 5-2 Reusability
Software Construction
(4) Interface Segregation Principle 
(ISP)
接口隔离原则
10 Construction for Change
Interface Segregation Principle
 “Clients should not be forced to depend upon interfaces that they 
do not use“, i.e., keep interfaces small. 不能强迫客户端依赖于它们
不需要的接口：只提供必需的接口
 Don’t force classes so implement methods they can’t (Swing/Java)
 Don’t pollute interfaces with a lot of methods
 Avoid ’fat’ interfaces
10 Construction for Change
(ISP) The Interface Segregation
 Clients should not be forced to depend upon methods that they do 
not use. (客户端不应依赖于它们不需要的方法)  Interfaces belong to clients, not to hierarchies. 
 This principle deals with the disadvantages of “fat” interfaces. 
(“胖”接口具有很多缺点)  Classes that have “fat” interfaces are classes whose interfaces are 
not cohesive. (不够聚合) – The interfaces of the class can be broken up into groups of member 
functions. (胖接口可分解为多个小的接口) – Each group serves a different set of clients (不同的接口向不同的客户端提
供服务). – Thus some clients use one group of member functions, and other clients 
use the other groups. (客户端只访问自己所需要的端口)
10 Construction for Change
(ISP) The Interface Segregation Principle
10 Construction for Change
Interface Segregation Principle
//bad example (polluted interface)
interface Worker {
void work();
void eat();
}
ManWorker implements Worker {
void work() {…};
void eat() {…};
}
RobotWorker implements Worker {
void work() {…};
void eat() {//Not Appliciable 
for a RobotWorker};
}
interface Workable {
public void work();
}
interface Feedable{
public void eat();
} 
Solution: split into two 
interfaces
10 Construction for Change
Interface Segregation Principle
interface Workable {
public void work();
}
interface Feedable{
public void eat();
} 
ManWorker implements Workable, Feedable {
void work() {…};
void eat() {…};
}
RobotWorker implements Workable {
void work() {…};
}
Software Construction
(5) Dependency Inversion Principle 
(DIP)
依赖转置原则
10 Construction for Change
(DIP) The Dependency Inversion Principle
 High level modules should not depend upon low level modules. 
Both should depend upon abstractions. – Abstractions should not depend upon details (抽象的模块不应依赖于具体
的模块) – Details should depend upon abstractions (具体应依赖于抽象)  Lots of interfaces and abstractions should be used!
10 Construction for Change
Example: the “Copy” program
void Copy(OutputStream dev) {
int c;
while ((c = ReadKeyboard()) != EOF)
if (dev == printer)
writeToPrinter(c);
else
writeToDisk(c); }
interface Reader {
public int read();
}
interface Writer {
public int write(c);
}
class Copy {
void Copy(Reader r, Writer w) {
int c;
while (c=r.read() != EOF)
w.write(c);
} }
10 Construction for Change
DIP: another example
上层client的代码
中直接嵌入了对下
层具体实现机制的
调用
上层client的代码面
向抽象接口编程，
隔离对下层具体实
现机制的直接接触
10 Construction for Change
Dependency Inversion Principle
//DIP - bad example
public class EmployeeService {
private EmployeeFinder emFinder; //concrete class, not abstract. 
//Can access a SQL DB for instance
public Employee findEmployee(…) {
emFinder.findEmployee(…)
} }
//DIP - fixed
public class EmployeeService {
private IEmployeeFinder emFinder 
//depends on an abstraction, no an implementation
public Employee findEmployee(…) {
emFinder.findEmployee(…)
} } Now its possible to change the finder to be a XmEmployeeFinder, 
DBEmployeeFinder, FlatFileEmployeeFinder, 
MockEmployeeFinder….
换句话说：
delegation的时候，
要通过interface建立
联系，而非具体子类
Software Construction
5 Grammar-based construction 
语法驱动的构造
10 Construction for Change
String/Stream based I/O
 Some program modules take input or produce output in the form 
of a sequence of bytes or a sequence of characters, which is called 
a string when it’s simply stored in memory, or a stream when it 
flows into or out of a module. 有一类应用，从外部读取文本数据，
在应用中做进一步处理。
 Concretely, a sequence of bytes or characters might be: – A file on disk, in which case the specification is called the file format 输入文
件有特定格式，程序需读取文件并从中抽取正确的内容 – Messages sent over a network, in which case the specification is a wire 
protocol 从网络上传输过来的消息，遵循特定的协议 – A command typed by the user on the console, in which case the 
specification is a command line interface 用户在命令行输入的指令，遵循特
定的格式 – A string stored in memory 内存中存储的字符串，也有格式需要
10 Construction for Change
String/Stream based I/O
C:\>curl --HEAD http://cms.hit.edu.cn
HTTP/1.1 200 OK
Date: Fri, 20 Apr 2019 14:00:00 GMT
Server: Apache/2.4.33 (Unix) mod_jk/1.2.43
Accept-Ranges: bytes
Vary: Accept-Encoding
Connection: close
Content-Type: text/html
10 Construction for Change
The notion of a grammar
 For these kinds of sequences, the notion of a grammar is a good 
choice for design: – It can not only help to distinguish between legal and illegal sequences, but 
also to parse a sequence into a data structure a program can work with. 使 用grammar判断字符串是否合法，并解析成程序里使用的数据结构 – The data structure produced from a grammar will often be a recursive 
data type. 通常是递归的数据结构
 Regular expression 正则表达式 – It is a widely-used tool for many string-processing tasks that need to 
disassemble a string, extract information from it, or transform it.
 A parser generator is a kind of tool that translate a grammar 
automatically into a parser for that grammar. 根据语法，开发一个它
的解析器，用于后续的解析
Software Construction
(1) Constituents of a Grammar
10 Construction for Change
Terminals: Literal Strings in a Grammar
 To describe a string of symbols, whether they are bytes, characters, 
or some other kind of symbol drawn from a fixed set, we use a 
compact representation called a grammar.
 A grammar defines a set of strings. 用语法定义一个“字符串” – For example, the grammar for URLs will specify the set of strings that are 
legal URLs in the HTTP protocol.
 The literal strings in a grammar are called terminals 终止节点、叶
节点– They’re called terminals because they are the leaves of a parse tree that 
represents the structure of the string. 语法解析树的叶子节点 – They don’t have any children, and can’t be expanded any further. 无法再
往下扩展 – We generally write terminals in quotes, like ‘http’ or ‘:’. 通常表示为字
符串
10 Construction for Change
Nonterminals and Productions in a Grammer
 A grammar is described by a set of productions 产生式节点, where 
each production defines a nonterminal 非终止节点 – A nonterminal is like a variable that stands for a set of strings, and the 
production as the definition of that variable in terms of other variables 
(nonterminals), operators, and constants (terminals). 遵循特定规则，利用
操作符、终止节点和其他非终止节点，构造新的字符串 – Nonterminals are internal nodes of the tree representing a string.
 A production in a grammar has the form – nonterminal ::= expression of terminals, nonterminals, and operators
 One of the nonterminals of the grammar is designated as the root. – The set of strings that the grammar recognizes are the ones that match the 
root nonterminal. – This nonterminal is often called root or start. 根节点
Software Construction
(2) Operators in a Grammar
10 Construction for Change
Three Basic Grammar Operators
 The three most important operators in a production expression are: – Concatenation 连接, represented not by a symbol, but just a space:
x ::= y z x matches y followed by z – Repetition 重复, represented by *:
x ::= y* x matches zero or more y – Union, also called alternation 选择, represented by |:
x ::= y | z x matches either y or z
10 Construction for Change
Grouping operators using parentheses
 By convention, the postfix operators *, ?, and + have highest 
precedence, which means they are applied first. 
 Concatenation is applied next. 
 Alternation | has lowest precedence, which means it is applied last. 
 Parentheses can be used to override precedence: – x ::= (y z | a b)* x matches zero or more yz or ab pairs – m ::= a (b|c) d m matches a, followed by either b or c, followed by d
10 Construction for Change
A small example
 url ::= 'http://mit.edu/' – Use these operators to generalize our url grammar to match some other 
hostnames, such as http://stanford.edu/ and http://google.com/.
 url ::= 'http://' hostname '/' – The url nonterminal matches strings that start with the literal string 
http://, followed by a match to the hostname nonterminal, followed by 
the literal string /.  hostname ::= 'mit.edu' | 'stanford.edu' | 'google.com' – A hostname can match one of the three literal strings, mit.edu or 
stanford.edu or google.com.  So this grammar represents the set of three strings.
10 Construction for Change
A small example
 hostname ::= 'mit.edu' | 'stanford.edu' | 'google.com' 
 To make it represent more URLs, we allow any lowercase word in 
place of mit, stanford, google, com and edu:
– The new word rule matches a string of zero or more lowercase letters, so 
the overall grammar can now match http://alibaba.com/ and 
http://zyxw.edu/ as well. – Unfortunately word can also match an empty string, so this url grammar 
also matches http://./, which is not a legal URL. 
10 Construction for Change
A small example
Too complicated!
10 Construction for Change
More grammar operators
 Additional operators are just syntactic sugar (i.e., they’re 
equivalent to combinations of the big three operators): – Optional (0 or 1 occurrence), represented by ?:
x ::= y? an x is a y or is the empty string
– 1 or more occurrences: represented by +:
x ::= y+ an x is one or more y (equivalent to x ::= y y* ) – A character class [...], representing the length-1 strings containing any of 
the characters listed in the square brackets:
x ::= [a-c] is equivalent to x ::= 'a' | 'b' | 'c' 
x ::= [aeiou] is equivalent to x ::= 'a' | 'e' | 'i' | 'o' | 'u' – An inverted character class [^...], representing the length-1 strings 
containing any character not listed in the brackets:
x ::= [^a-c] is equivalent to x ::= 'd' | 'e' | 'f' | ... 
(all other characters)
10 Construction for Change
Go back to the example
Software Construction
(3) Recursion in grammars
10 Construction for Change
Recursion in grammars
 Hostnames can have more than two components, and there can be 
an optional port number:
http://didit.csail.mit.edu:4949/
 To handle this kind of string, the grammar is now:
url ::= 'http://' hostname (':' port)? '/' 
hostname ::= word '.' hostname | word '.' word
port ::= [0-9]+
word ::= [a-z]+
 hostname is now defined recursively in terms of itself.
 Using the repetition operator, we could also write hostname 
without recursion, like this:
hostname ::= (word '.')+ word
10 Construction for Change
Exercise
 Consider this grammar:
S ::= (B C)* T
B ::= M+ | P B P
C ::= B | E+
 What are the nonterminals in this grammar? S B C
 What are the terminals in this grammar? T M P E
 Which productions are recursive? B
10 Construction for Change
Exercise
 Which strings match the root nonterminal of this grammar?
root ::= 'a'+ 'b'* 'c'?
 Strings
aabcc
bbbc
aaaaaaaa
abc
abab
aac
10 Construction for Change
Exercise
 Which strings match the root nonterminal of this grammar?
root ::= integer ('-' integer)+
integer ::= [0-9]+
 Strings
617
617-253
617-253-1000
---
integer-integer-integer
5--5
3-6-293-1
10 Construction for Change
Exercise
 Which strings match the root nonterminal of this grammar?
root ::= (A B)+
A ::= [Aa]
B ::= [Bb]
 Strings
aaaBBB
abababab
aBAbabAB
AbAbAbA
Software Construction
(4) Parse Trees
10 Construction for Change
Parse Tree
 Matching a grammar against a string can generate a parse tree that 
shows how parts of the string correspond to parts of the grammar. – The leaves of the parse tree are labeled with terminals, representing the 
parts of the string that have been parsed. – They don’t have any children, and can’t be expanded any further. – If we concatenate the leaves together, we get back the original string.
url ::= 'http://mit.edu/'
url ::= 'http://' hostname '/'
hostname ::= word '.' word
word ::= [a-z]+
10 Construction for Change
Parse Tree
url ::= 'http://' hostname (':' port)? '/' 
hostname ::= word '.' hostname | word '.' word
port ::= [0-9]+
word ::= [a-z]+ http://didit.csail.mit.edu:4949/
10 Construction for Change
Parse Tree
 If the same string was matched against this grammar with a non￾recursive hostname rule:
url ::= 'http://' hostname (':' port)? '/' 
hostname ::= (word '.')+ word
port ::= [0-9]+
word ::= [a-z]+
 What does its parse tree looks like?
http://didit.csail.mit.edu:4949/
10 Construction for Change
More generalizations…
 There are more things we should do to go farther: – Generalizing http to support the additional protocols that URLs can have, 
such as ftp, https, …
– Generalizing the / at the end to a slash-separated path, such as 
http://didit.csail.mit.edu:4949/homework/lab1/ – Allowing hostnames with the full set of legal characters instead of just a-z 
such as http://ou812.com/
 Can you do these?
url ::= protocol '://' hostname (':' port)? '/' (word '/')*
protocol ::= 'ftp' | 'http' | 'https'
hostname ::= (word '.')+ word
port ::= [0-9]+
word ::= [a-z 0-9]+
10 Construction for Change
Exercise
 We want the URL grammar to also match strings of the form: – https://websis.mit.edu/ – ftp://ftp.athena.mit.edu/
 but not strings of the form: – ptth://web.mit.edu/ – mailto:bitdiddle@mit.edu
 So we change the grammar to:
 What could you put in place of TODO to match the desirable URLs 
but not the undesirable ones? – word – 'ftp' | 'http' | 'https' – ('http' 's'?) | 'ftp' – ('f' | 'ht') 'tp' 's'?
url ::= protocol '://' hostname (':' 
port)? '/' 
protocol ::= TODO
hostname ::= word '.' hostname | 
word '.' word
port ::= [0-9]+
word ::= [a-z]+
Software Construction
(5) Markdown and HTML
10 Construction for Change
Markdown and HTML
 Markup languages: represents typographic style in text.
https://daringfireball.net/projects/markdown/syntax
 Markdown example for italics
This is _italic_.
 HTML example for italics
Here is an <i>italic</i> word. 
 For simplicity, we assume the plain text between the formatting 
delimiters is not allowed to use any formatting punctuation, like _ or <>.  Can you write down their grammars?
10 Construction for Change
Markdown and HTML
markdown ::= ( normal | italic ) *
italic ::= '_' normal '_'
normal ::= text
text ::= [^_]*
html ::= ( normal | italic ) *
italic ::= '<i>' html '</i>'
normal ::= text
text ::= [^<>]*
10 Construction for Change
Markdown and HTML
markdown ::= ( normal | italic ) *
italic ::= '_' normal '_'
normal ::= text
text ::= [^_]*
html ::= ( normal | italic ) *
italic ::= '<i>' html '</i>'
normal ::= text
text ::= [^<>]*
markdown: 
a_b_c_d_e
html: 
a<i>b<i>c</i>d</i>e
If you match the specified 
grammar against it, which letters 
are inside matches to the italic 
nonterminal?
10 Construction for Change
Documenting like programming: Markdown, LaTeX
10 Construction for Change
Donald E. Knuth（高德纳）
 Donald E. Knuth (1938- )
 Stanford University
 1974年图灵奖获得者
史上最年轻的图灵奖获得者
 被誉为现代计算机科学的鼻祖
 算法分析之父，为理论计算机科学
的发展做出重要贡献
 《计算机程序设计艺术》(The Art of Computer Programming)，计算
机科学理论与技术的经典巨著，其作用与地位可与《几何原本》相比。
 TeX的发明者
 “计算机老顽童”
10 Construction for Change
创造TEX和METAFONT
10 Construction for Change
创造TEX和METAFONT
 除了对排版美的追求，TEX使人们像编程一样写作文。
 TEX的版本号不是自然数列，也不是
年份，而是从3开始，不断逼近圆周率
(目前最新版本是3.14159265)，意思是
说：这个东西趋近完美，不可能再有
什么大的改进了
 设立了一个奖项：谁发现TEX的一个
错误，就付他2.56美元，第二个错误
5.12美元，第三个10.24美元……以此
类推
Software Construction
(6) Regular Grammars and Regular 
Expressions
10 Construction for Change
Regular grammar
 A regular grammar has a special property: by substituting every 
nonterminal (except the root one) with its righthand side, you can 
reduce it down to a single production for the root, with only 
terminals and operators on the right-hand side. 正则语法：简化之后
可以表达为一个产生式而不包含任何非终止节点
 Which of them are regular grammars?
url ::= 'http://' hostname (':' port)? '/' 
hostname ::= word '.' hostname | word '.' word
port ::= [0-9]+
word ::= [a-z]+
markdown ::= ( normal | italic ) *
italic ::= '_' normal '_'
normal ::= text
text ::= [^_]*
html ::= ( normal | italic ) *
italic ::= '<i>' html '</i>'
normal ::= text
text ::= [^<>]*
10 Construction for Change
Regular grammar
url ::= 'http://' ([a-z]+ '.')+ [a-z]+ (':' [0-9]+)? '/' 
Regular!
markdown ::= ([^_]* | '_' [^_]* '_' )* Regular!
html ::= ( [^<>]* | '<i>' html '</i>' )* Not regular!
url ::= 'http://' hostname (':' port)? '/' 
hostname ::= word '.' hostname | word '.' word
port ::= [0-9]+
word ::= [a-z]+
markdown ::= ( normal | italic ) *
italic ::= '_' normal '_'
normal ::= text
text ::= [^_]*
html ::= ( normal | italic ) *
italic ::= '<i>' html '</i>'
normal ::= text
text ::= [^<>]*
10 Construction for Change
Regular Expressions (regex)  The reduced expression of terminals and operators can be written 
in an even more compact form, called a regular expression. 正则表
达式
 A regular expression does away with the quotes around the 
terminals, and the spaces between terminals and operators, so that 
it consists just of terminal characters, parentheses for grouping, 
and operator characters. 去除引号和空格，从而表达更简洁(更难懂)
markdown ::= ([^_]* | '_' [^_]* '_' )*
markdown ::= ([^_]*|_[^_]*_)*
 Regular expressions are also called regex for short. – A regex is far less readable than the original grammar, because it lacks the 
nonterminal names that documented the meaning of each subexpression. – But a regex is fast to implement, and there are libraries in many 
programming languages that support regular expressions.
10 Construction for Change
Some special operators in regex
 . any single character
 \d any digit, same as [0-9]
 \s any whitespace character, including space, tab, newline
 \w any word character, including underscore, same as 
[a-zA-Z_0-9]
 \., \(, \), \*, \+, ...
escapes an operator or special character so that it matches literally
10 Construction for Change
An example
 Original:
'http://' ([a-z]+ '.')+ [a-z]+ (':' [0-9]+)? '/' 
 Compact:
http://([a-z]+.)+[a-z]+(:[0-9]+)?/ 
 With escape:
http://([a-z]+\.)+[a-z]+(:[0-9]+)?/
10 Construction for Change
Exercise
 Consider the following regular expression:
[A-G]+(♭|♯)?
 Which of the following strings match the regular expression? – A♭ – C♯ – ABK♭ – A♭B – GFE
10 Construction for Change
Context-Free Grammars
 In general, a language that can be expressed with a system of 
grammars is called context-free. – Not all context-free languages are also regular; that is, some grammars 
can’t be reduced to single nonrecursive productions. – The HTML grammar is context-free but not regular.
 The grammars for most programming languages are also context￾free. 
 In general, any language with nested structure (like nesting 
parentheses or braces) is context-free but not regular. 
课程《形式语言与自动机》
10 Construction for Change
Java grammar
10 Construction for Change
Java AST
while (b != 0) {
if (a > b) 
a = a – b;
else
b = b – a;
}
return a;
Software Construction
(7) * Parsers
10 Construction for Change
Parser 将输入文本转为parse tree
 A parser takes a sequence of characters and tries to match the 
sequence against the grammar. parser：输入一段文本，与特定的语
法规则建立匹配，输出结果
 The parser typically produces a parse tree, which shows how 
grammar productions are expanded into a sentence that matches 
the character sequence. parser：将文本转化为parse tree – The root of the parse tree is the starting nonterminal of the grammar. – Each node of the parse tree expands into one production of the grammar.
 The final step of parsing is to do something useful with this parse 
tree. 利用产生的parse tree，进行下一步的处理
 A recursive abstract data type that represents a language 
expression is called an abstract syntax tree (AST).
10 Construction for Change
Parser Generator 根据语法定义生成parser
 A parser generator is a tool that reads a grammar specification and 
converts it to a Java program that can recognize matches to the 
grammar. Parser generator是一个工具，根据语法规则生成一个
parser程序 – Read http://web.mit.edu/6.031/www/sp17/classes/18-parsers
This is not the mandatory contents of this course.
 More broadly: – A parser generator is a programming tool that creates a parser, interpreter, 
or compiler from some form of formal description of a language. – The input may be a text file containing the grammar written in BNF or 
EBNF that defines the syntax of a programming language. 输入是遵循BNF
或EBNF格式的文本文件 – The output is some source code of the parser for the grammar. 输出为
parser的源代码
10 Construction for Change
Backus Normal Form (BNF) 巴克斯范式
 1959年6月，Backus Normal Form (BNF)首次提出，以递归形式描述
语言的各种成分，凡遵守其规则的程序就可保证语法上的正确性。 – 经过Peter Naur的改进与完善以及Niklaus Wirth的扩充，形成了EBNF（
Extended BNF），也就是目前使用的BNF。 – 经Donald Knuth 的建议，BNF中的N变成了Naur (Backus-Naur Form)。
John Backus (1924-2007)
1977年图灵奖得主
Peter Naur (1928-2016)
2005年图灵奖得主
Niklaus Wirth (1934-)
1984年图灵奖得主
10 Construction for Change
Grammar, Parser Generator, and Parser
 Grammar定义语法规则（BNF格式的文本），Parser generator根据
语法规则产生一个parser，用户利用parser来解析文本，看其是否符
合语法定义并对其做各种处理（例如转成parse tree）
root ::= html;
html ::= ( italic | normal ) *;
italic ::= '<i>' html '</i>';
normal ::= text; 
text ::= [^<>]+; 
Grammar
Parser
Generator
(Tool) 
Parser
(API or tool) 
Here is an <i>italic</i> word.
例如：
正则表达式语法
HTML语法
Java语法
例如：
Java regex parser
HTML parser
Java compiler
例如：
Regex pattern
HTML tree
Java AST
10 Construction for Change
In your future study…
root ::= html;
html ::= ( italic | normal ) *;
italic ::= '<i>' html '</i>';
normal ::= text; 
text ::= [^<>]+; 
Grammar
Parser
Generator
(Tool) 
Parser
(API or tool) 
Here is an <i>italic</i> word.
例如：
正则表达式语法
HTML语法
Java语法
例如：
Java regex parser
HTML parser
Java compiler
例如：
Regex pattern
HTML tree
Java AST
基础：形式语言
任务：设计一种
语言
编译原理课程：
为某个语言设计
编译器
词法分析、
语法分析、
语义分析
Software Construction
(8) Using regular expressions in Java
在本课程里，只需要能够熟练掌握正则表达式regex这种
“基本语法” ，并熟练使用JDK提供的 regex parser进
行数据处理即可
10 Construction for Change
Using regular expressions in Java
 Regexes are widely used in programming.
 In Java, you can use regexes for manipulating strings (see 
String.split, String.matches, java.util.regex.Pattern). 
 They’re built-in as a first-class feature of modern scripting 
languages like Python, Ruby, and JavaScript, and you can use 
them in many text editors for find and replace. 
 Regular expressions are your friend! 
10 Construction for Change
java.util.regex for Regex processing
 The java.util.regex package primarily consists of three classes: – A Pattern object is a compiled representation of a regular expression. The 
Pattern class provides no public constructors. To create a pattern, you 
must first invoke one of its public static compile methods, which will then 
return a Pattern object. These methods accept a regular expression as the 
first argument. Pattern是对regex正则表达式进行编译之后得到的结果 – A Matcher object is the engine that interprets the pattern and performs 
match operations against an input string. Like the Pattern class, Matcher
defines no public constructors. You obtain a Matcher object by invoking 
the matcher method on a Pattern object. Matcher：利用Pattern对输入
字符串进行解析 – A PatternSyntaxException object is an unchecked exception that 
indicates a syntax error in a regular expression pattern.
10 Construction for Change
java.util.regex for Regex processing
10 Construction for Change
Using regular expressions in Java
 Replace all runs of spaces with a single space:
 Match a URL:
 Extract part of an HTML tag:
10 Construction for Change
Found value: This order was placed for QT3000! OK?
Found value: This order was placed for QT300
Found value: 0
// String to be scanned to find the pattern.
String line = "This order was placed for QT3000! OK?";
String pattern = "(.*)(\\d+)(.*)";
// Create a Pattern object
Pattern r = Pattern.compile(pattern);
// Now create matcher object.
Matcher m = r.matcher(line);
if (m.find( )) {
System.out.println("Found value: " + m.group(0) );
System.out.println("Found value: " + m.group(1) );
System.out.println("Found value: " + m.group(2) );
}else {
System.out.println("NO MATCH");
}
10 Construction for Change
An example
 Write the shortest regex you can to remove single-word, lowercase￾letter-only HTML tags from a string:
String input = "The <b>Good</b>, the <i>Bad</i>, and the 
<strong>Ugly</strong>";
String regex = "TODO";
String output = input.replaceAll(regex, "");
 If the desired output is "The Good, the Bad, and the Ugly", 
what is shortest regex you can put in place of TODO? 
</?[a-z]+>
10 Construction for Change
Character Classes
Construct Description
[abc] a, b, or c (simple class)
[^abc] Any character except a, b, or c (negation)
[a-zA-Z] a through z, or A through Z, inclusive (range)
[a-d[m-p]] a through d, or m through p: [a-dm-p] (union)
[a-z&&[def]] d, e, or f (intersection)
[a-z&&[^bc]] a through z, except for b and c: [ad-z] (subtraction)
[a-z&&[^m-p]] a through z, and not m through p: [a-lq-z] (subtraction)
Metacharacters: <([{\^-=$!|]})?*+.>
Two ways to force a metacharacter to be treated as an ordinary character:
• Precede the metacharacter with a backslash \ • Enclose it within \Q (which starts the quote) and \E (which ends it).
10 Construction for Change
Predefined Character Classes
Construct Description
. Any character (may or may not match line terminators)
\d A digit: [0-9]
\D A non-digit: [^0-9]
\s A whitespace character: [ \t\n\x0B\f\r]
\S A non-whitespace character: [^\s]
\w A word character: [a-zA-Z_0-9]
\W A non-word character: [^\w]
10 Construction for Change
Quantifiers
Greedy Reluctant Possessive Meaning
X? X?? X?+ X, once or not at all
X* X*? X*+ X, zero or more times
X+ X+? X++ X, one or more times
X{n} X{n}? X{n}+ X, exactly n times
X{n,} X{n,}? X{n,}+ X, at least n times
X{n,m} X{n,m}? X{n,m}+ X, at least n but not more than m times
10 Construction for Change
Boundary Matchers
Boundary Construct Description
^ The beginning of a line
$ The end of a line
\b A word boundary
\B A non-word boundary
\A The beginning of the input
\G The end of the previous match
\Z The end of the input but for the final terminator, if any
\z The end of the input
10 Construction for Change
Pattern method equivalents in java.lang.String
 public boolean matches(String regex): Tells whether or not 
this string matches the given regular expression. 
Pattern.matches(regex, str).
 public String[] split(String regex, int limit): Splits this 
string around matches of the given regular expression. 
Pattern.compile(regex).split(str, n)
 public String[] split(String regex): Splits this string 
around matches of the given regular expression. 
 public String replace(CharSequence target,CharSequence 
replacement) 
10 Construction for Change
Learn by yourself
 https://docs.oracle.com/javase/tutorial/essential/regex/index.html
 https://en.wikipedia.org/wiki/Regular_expression
10 Construction for Change
Summary
 Safe from bugs – Grammars and regular expressions are declarative specifications for 
strings and streams, which can be used directly by libraries and tools. – These specifications are often simpler, more direct, and less likely to be 
buggy than parsing code written by hand.
 Easy to understand
– A grammar captures the shape of a sequence in a form that is easier to 
understand than hand-written parsing code. – Regular expressions, alas, are often not easy to understand, because they 
are a one-line reduced form of what might have been a more 
understandable regular grammar.
 Ready for change – A grammar can be easily edited, but regular expressions, unfortunately, 
are much harder to change, because a complex regular expression is 
cryptic and hard to understand.
Software Construction
Summary
10 Construction for Change
Summary
 Software Maintenance and Evolution
 Metrics of Maintainability
 Modular Design and Modularity Principles
 OO Design Principles: SOLID
 Grammer-based Construction
 Machine-processed textual languages are ubiquitous in computer 
science. 
 Grammars are the most popular formalism for describing such 
languages
 Regular expressions are an important subclass of grammars that can 
be expressed without recursion.
Software Construction
The end
June 9, 2021Software Construction
11 Design Patterns for Reuse and 
Maintainability
面向可复用性和可维护性的设计模式
Wang Zhongjie
rainy@hit.edu.cn
June 14, 2021
11 Design Patterns for Reuse and Maintainability
Outline
 Creational patterns – Factory method pattern creates objects without specifying the exact class.
 Structural patterns – Adapter allows classes with incompatible interfaces to work together by 
wrapping its own interface around that of an already existing class. – Decorator dynamically adds/overrides behavior in a method of an object.
 Behavioral patterns – Strategy allows one of a family of algorithms to be selected at runtime. – Template method defines the skeleton of an algorithm as an abstract class, 
allowing its subclasses to provide concrete behavior. – Iterator accesses the elements of an object sequentially without exposing 
its underlying representation. – Visitor separates an algorithm from an object structure by moving the 
hierarchy of methods into one object.
11 Design Patterns for Reuse and Maintainability
Reading
 CMU 17-214：Sep 12、Sep 17
 设计模式：第1、2章；第4.1、4.4、4.5、5.4、5.9、5.10节  CMU 17-214：Nov 26
 设计模式：第3.1、3.2、3.3、4.2、4.3、4.7、5.5、5.7、5.11、(5.1)、
(5.2)节
11 Design Patterns for Reuse and Maintainability
Why reusable design patterns?
A design…
…enables flexibility to change (reusability)
…minimizes the introduction of new problems when fixing old ones 
(maintainability)
…allows the delivery of more functionality after an initial delivery 
(extensibility).
Design Patterns: a general, reusable solution to a commonly occurring 
problem within a given context in software design. 
OO design patterns typically show relationships and interactions 
between classes or objects, without specifying the final application 
classes or objects that are involved. 除了类本身，设计模式更强调多
个类/对象之间的关系和交互过程---比接口/类复用的粒度更大
11 Design Patterns for Reuse and Maintainability
Gang of Four
 Design Patterns: Elements of Reusable 
Object-Oriented Software
 By GoF (Gang of Four) – Erich Gamma – Richard Helm
– Ralph Johnson
– John Vlissides
11 Design Patterns for Reuse and Maintainability
Design patterns taxonomy
 Creational patterns 创建型模式 – Concern the process of object creation
 Structural patterns 结构型模式 – Deal with the composition of classes or objects
 Behavioral patterns 行为类模式 – Characterize the ways in which classes or objects interact and distribute 
responsibility.
Software Construction
1 Creational patterns
Software Construction
Factory Method pattern
工厂方法模式
11 Design Patterns for Reuse and Maintainability
Factory Method
 Also known as “Virtual Constructor” 虚拟构造器
 Intent: – Define an interface for creating an object, but let subclasses decide which 
class to instantiate. – Factory Method lets a class defer instantiation to subclasses. 
 When should we use Factory Method? ---- When a class: – Can’t predict the class of the objects it needs to create – Wants its subclasses to specify the objects that it creates – Delegates responsibility to one of multiple helper subclasses, and you 
need to localize the knowledge of which helper is the delegate.
当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体
创建的实例时，用工厂方法。
定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个
类的实例化延迟到其子类。
11 Design Patterns for Reuse and Maintainability
Factory Method
常规情况下，client直接创建具体对象
Product p = new ProductTwo();
在工厂方法模式下:
Product p = new ConcreteTwo().makeObject();
11 Design Patterns for Reuse and Maintainability
Example public interface Trace {
// turn on and off debugging
public void setDebug( boolean debug );
// write out a debug message
public void debug( String message );
// write out an error message
public void error( String message );
}
public class FileTrace implements Trace { 
private PrintWriter pw;
private boolean debug;
public FileTrace() throws IOException {
pw = new PrintWriter( new FileWriter( "t.log" ) );
}
public void setDebug( boolean debug ) {
this.debug = debug;
}
public void debug( String message ) {
if( debug ) {
pw.println( "DEBUG: " + message );
pw.flush();
} }
public void error( String message ) {
pw.println( "ERROR: " + message );
pw.flush();
} }
Abstract product
Concrete product 1
11 Design Patterns for Reuse and Maintainability
Example
public class SystemTrace implements Trace {
private boolean debug;
public void setDebug( boolean debug ) {
this.debug = debug;
}
public void debug( String message ) {
if( debug ) 
System.out.println( "DEBUG: " + message );
}
public void error( String message ) {
System.out.println( "ERROR: " + message );
} }
public interface Trace {
// turn on and off debugging
public void setDebug( boolean debug );
// write out a debug message
public void debug( String message );
// write out an error message
public void error( String message );
}
//... some code ...
Trace log = new SystemTrace();
log.debug( "entering log" );
Trace log2 = new FileTrace();
log.debug(“...”);
Concrete product 2
Abstract product
How to use?
The client code is tightly coupled with 
concrete products.
11 Design Patterns for Reuse and Maintainability
Example
public class Factory1 implements TraceFactory {
public Trace getTrace() {
return new SystemTrace();
} }
public class Factory2 implements TraceFactory {
public getTrace(String type) {
if(type.equals(“file”)
return new FileTrace();
else if (type.equals(“system”)
return new SystemTrace();
} }
Trace log1 = new Factory1().getTrace();
log1.setDebug(true);
log1.debug( "entering log" );
Trace log2 = new Factory2().getTrace("system");
log2.setDebug(false);
log2.debug("...");
Client使用
“工厂方法”
来创建实例，
得到实例的类
型是抽象接口
而非具体类
根据类型决定
创建哪个具体
产品
interface TraceFactory {
public Trace getTrace();
public Trace getTrace(String type);
void otherOperation(){};
}
有新的具体产品类
加入时，可以在工
厂类里修改或增加
新的工厂函数
(OCP)，不会影响
客户端代码
不仅包含
factory 
method，
还可以实现
其他功能
11 Design Patterns for Reuse and Maintainability
Example
public class TraceFactory1 {
public static Trace getTrace() {
return new SystemTrace();
} }
public class TraceFactory2 {
public static Trace getTrace(String type) {
if(type.equals(“file”)
return new FileTrace();
else if (type.equals(“system”)
return new SystemTrace();
} }
//... some code ...
Trace log1 = TraceFactory1.getTrace();
log1.setDebug(true);
log1.debug( "entering log" );
Trace log2 = TraceFactory2.getTrace(“system”);
log1.setDebug(true);
log2.debug(“...”);
静态工厂方法
既可以在ADT
内部实现，也
可以构造单独
的工厂类
11 Design Patterns for Reuse and Maintainability
Factory Method
 Advantage: – Eliminates the need to bind application-specific classes to your code. – Code deals only with the Product interface (Trace), so it can work with 
any user-defined ConcreteProduct (FileTrace, SystemTrace)  Potential Disadvantages – Clients may have to make a subclass of the Creator, just so they can 
create a certain ConcreteProduct. – This would be acceptable if the client has to subclass the Creator anyway, 
but if not then the client has to deal with another point of evolution.
 Open-Closed Principle (OCP) ——对扩展的开放，对修改已有代码的封闭
Software Construction
2 Structural patterns
Software Construction
(1) Adapter
适配器模式
11 Design Patterns for Reuse and Maintainability
Adapter Pattern
 Intent: Convert the interface of a class into another interface that 
clients expect to get. 将某个类/接口转换为client期望的其他形式 – Adapter lets classes work together that couldn't otherwise because of 
incompatible interfaces. – Wrap an existing class with a new interface. 通过增加一个接口，将已存在
的子类封装起来，client面向接口编程，从而隐藏了具体子类。
 Object: to reuse an old component to a new system (also called 
“wrapper”)
delegation
11 Design Patterns for Reuse and Maintainability
Example
 A LegacyRectangle component's display() method expects to 
receive "x, y, w, h" parameters. 
 But the client wants to pass "upper left x and y" and "lower right 
x and y". 
 This incongruity can be reconciled by adding an additional level of 
indirection – i.e. an Adapter object. ----Delegation
通过
delegation
完成适配
实际执行
的方法
Client里的调用代码怎么写？
11 Design Patterns for Reuse and Maintainability
Example: without Adaptor pattern
class LegacyRectangle {
void display(int x1, int y1, int w, int h) {... }
}
Delegation incompatible! class Client {
public display() {
new LegacyRectangle().display(x1, y1, x2, y2);
} }
11 Design Patterns for Reuse and Maintainability
Example: with Adaptor pattern
interface Shape {
void display(int x1, int y1, int x2, int y2);
}
class Rectangle implements Shape {
void display(int x1, int y1, int x2, int y2) {
new LegacyRectangle().display(x1, y1, x2-x1, y2-y1); 
} }
class LegacyRectangle {
void display(int x1, int y1, int w, int h) {...}
}
class Client {
Shape shape = new Rectangle();
public display() {
shape.display(x1, y1, x2, y2);
} }
Adaptor类实现抽象接口
具体实现方法的适配
对抽象接口编程，与
LegacyRectangle隔离
11 Design Patterns for Reuse and Maintainability
Example
定义一个接口，
隔离client与内
部具体实现
定义一个
抽象类
一组其他不
需要适配的
具体类
Adaptor也
作为抽象
类的子类
Legacy类
实现具体
功能
Question: How does a 
client use this 
OffshoreAccount?
Software Construction
(2) Decorator
装饰器模式
11 Design Patterns for Reuse and Maintainability
Motivating example of Decorator pattern
 Suppose you want various extensions of a Stack data structure…
– UndoStack: A stack that lets you undo previous push or pop operations – SecureStack: A stack that requires a password
– SynchronizedStack: A stack that serializes concurrent 
accesses – 用每个子类实现不同的特性
 And arbitrarily composable extensions: 如果需要特性的任意组合呢？ – SecureUndoStack: A stack that requires a password, and also lets you 
undo previous operations – SynchronizedUndoStack: A stack that serializes concurrent accesses, and 
also lets you undo previous operations – SecureSynchronizedStack: …
– SecureSynchronizedUndoStack: …
Inheritance
Inheritance 
hierarchies?
Multi-Inheritance?
11 Design Patterns for Reuse and Maintainability
Limitations of inheritance
11 Design Patterns for Reuse and Maintainability
Limitations of inheritance
 Combining inheritance hierarchies – Combinatorial explosion 组合爆炸！ – Massive code replication 大量的代码重复
11 Design Patterns for Reuse and Maintainability
Decorator
 Problem: You need arbitrary or dynamically composable extensions 
to individual objects. 为对象增加不同侧面的特性
 Solution: Implement a common interface as the object you are 
extending, add functionality, but delegate primary responsibility to 
an underlying object. 对每一个特性构造子类，通过委派机制增加到对
象上
 Consequences: – More flexible than static inheritance – Customizable, cohesive extensions
 Decorators use both subtyping
and delegation
11 Design Patterns for Reuse and Maintainability
Example of Decorator
11 Design Patterns for Reuse and Maintainability
The ArrayStack Class
interface Stack {
void push(Item e);
Item pop();
}
public class ArrayStack implements Stack {
... //rep
public ArrayStack() {...}
public void push(Item e) {
...
}
public Item pop() {
...
}
...
}
实现最基础的
Stack功能
11 Design Patterns for Reuse and Maintainability
The AbstractStackDecorator Class
interface Stack {
void push(Item e);
Item pop();
}
public abstract class StackDecorator implements Stack {
protected final Stack stack;
public StackDecorator(Stack stack) {
this.stack = stack;
}
public void push(Item e) {
stack.push(e);
}
public Item pop() {
return stack.pop();
}
...
}
Delegation 
(aggregation)
给出一个用于
decorator的
基础类
11 Design Patterns for Reuse and Maintainability
The concrete decorator classes
public class UndoStack
extends StackDecorator
implements Stack {
private final UndoLog log = new UndoLog();
public UndoStack(Stack stack) { 
super(stack); 
}
public void push(Item e) {
log.append(UndoLog.PUSH, e);
super.push(e);
}
public void undo() {
//implement decorator behaviors on stack
}
...
}
增加了新特性
基础功能通过
delegation实现
增加了新特性
11 Design Patterns for Reuse and Maintainability
Using the decorator classes
 To construct a plain stack: – Stack s = new ArrayStack();
 To construct an undo stack: – Stack t = new UndoStack(new ArrayStack());
 To construct a secure synchronized undo stack: – Stack t = new SecureStack(
new SynchronizedStack(
new UndoStack(s))
 Flexibly Composable!
客户端需要一
个具有多种特
性的object，通
过一层一层的
就像一层一 装饰来实现
层的穿衣服 …
11 Design Patterns for Reuse and Maintainability
Decorator vs. Inheritance
 Decorator composes features at run time – Inheritance composes features at compile time
 Decorator consists of multiple collaborating objects – Inheritance produces a single, clearly-typed object
 Can mix and match multiple decorations – Multiple inheritance is conceptually difficult
11 Design Patterns for Reuse and Maintainability
Decorators from java.util.Collections
 Turn a mutable list into an immutable list: – static List<T> unmodifiableList(List<T> lst); – static Set<T> unmodifiableSet( Set<T> set); – static Map<K,V> unmodifiableMap( Map<K,V> map);
 Similar for synchronization: – static List<T> synchronizedList( List<T> lst ); – static Set<T> synchronizedSet( Set<T> set); – static Map<K,V> synchronizedMap( Map<K,V> map);
See section 3-1
See section 10-1
List<Trace> ts = new LinkedList<>();
List<Trace> ts2 = 
(List<Trace>) Collections.unmodifiableCollection(ts);
如何使用
factory method
模式实现
public static Stack UndoStackFactory(Stack stack) {
return new UndoStack(stack);
}
Software Construction
3 Behavioral patterns
Software Construction
(1) Strategy
策略模式
11 Design Patterns for Reuse and Maintainability
Strategy Pattern
 Problem: Different algorithms exists for a specific task, but client can 
switch between the algorithms at run time in terms of dynamic 
context. 有多种不同的算法来实现同一个任务，但需要client根据需要
动态切换算法，而不是写死在代码里
 Example: Sorting a list of customers (bubble sort, mergesort, 
quicksort) 
 Solution: Create an interface for the algorithm, with an 
implementing class for each variant of the algorithm. 为不同的实现算
法构造抽象接口，利用delegation，运行时动态传入client倾向的算法
类实例
 Advantage: – Easily extensible for new algorithm implementations – Separates algorithm from client context
11 Design Patterns for Reuse and Maintainability
Strategy Pattern
11 Design Patterns for Reuse and Maintainability
Code example
11 Design Patterns for Reuse and Maintainability
Code example
public interface PaymentStrategy {
public void pay(int amount);
}
public class CreditCardStrategy implements PaymentStrategy {
private String name;
private String cardNumber;
private String cvv;
private String dateOfExpiry;
public CreditCardStrategy(String nm, String ccNum, 
String cvv, String expiryDate){
this.name=nm;
this.cardNumber=ccNum;
this.cvv=cvv;
this.dateOfExpiry=expiryDate;
}
@Override
public void pay(int amount) {
System.out.println(amount +" paid with credit card");
} }
11 Design Patterns for Reuse and Maintainability
Code example
public interface PaymentStrategy {
public void pay(int amount);
}
public class ShoppingCart {
...
public void pay(PaymentStrategy paymentMethod){
int amount = calculateTotal();
paymentMethod.pay(amount);
} }
public class PaypalStrategy implements PaymentStrategy {
private String emailId;
private String password;
public PaypalStrategy(String email, String pwd){
this.emailId=email;
this.password=pwd;
}
@Override
public void pay(int amount) {
System.out.println(amount + " paid using Paypal.");
} }
11 Design Patterns for Reuse and Maintainability
Code example
public interface PaymentStrategy {
public void pay(int amount);
}
public class ShoppingCartTest {
public static void main(String[] args) {
ShoppingCart cart = new ShoppingCart();
Item item1 = new Item("1234",10);
Item item2 = new Item("5678",40);
cart.addItem(item1);
cart.addItem(item2);
//pay by paypal
cart.pay(new PaypalStrategy("myemail@exp.com", "mypwd"));
//pay by credit card
cart.pay(new CreditCardStrategy(“Alice", "1234", "786", "12/18"));
} }
public class ShoppingCart {
...
public void pay(PaymentStrategy paymentMethod){
int amount = calculateTotal();
paymentMethod.pay(amount);
} }
delegation
Software Construction
(2) Template Method
模板模式
11 Design Patterns for Reuse and Maintainability
Template Method
 Problem: Several clients share the same algorithm but differ on the 
specifics, i.e., an algorithm consists of customizable parts and 
invariant parts. Common steps should not be duplicated in the 
subclasses but need to be reused. – 做事情的步骤一样，但具体方法不同
 Examples: – Executing a test suite of test cases – Opening, reading, writing documents of different types
 Solution: – The common steps of the algorithm are factored out into an abstract class, 
with abstract (unimplemented) primitive operations representing the 
customizable parts of the algorithm. 共性的步骤在抽象类内公共实现，差
异化的步骤在各个子类中实现 – Subclasses provide different realizations for each of these steps.
step1();
…
step2();
…
step3();
11 Design Patterns for Reuse and Maintainability
Template Method Pattern
 Template method pattern uses inheritance + overridable methods to 
vary part of an algorithm 使用继承和重写实现模板模式 – While strategy pattern uses delegation to vary the entire algorithm 
(interface and ad-hoc polymorphism). 
 Template Method is widely used in frameworks – The framework implements the invariants of the algorithm – The client customizations provide specialized steps for the algorithm
– Principle: “Don’t call us, we’ll call you”.
Whitebox or 
Blackbox 
framework?
11 Design Patterns for Reuse and Maintainability
Template Method pattern
11 Design Patterns for Reuse and Maintainability
Example
11 Design Patterns for Reuse and Maintainability
Example public abstract class OrderProcessTemplate {
public boolean isGift;
public abstract void doSelect();
public abstract void doPayment();
public final void giftWrap() {
System.out.println("Gift wrap done.");
}
public abstract void doDelivery();
public final void processOrder() {
doSelect();
doPayment();
if (isGift)
giftWrap();
doDelivery();
} }
11 Design Patterns for Reuse and Maintainability
Example OrderProcessTemplate netOrder = new NetOrder();
netOrder.processOrder();
OrderProcessTemplate storeOrder = new StoreOrder();
storeOrder.processOrder();
public class NetOrder
extends OrderProcessTemplate {
@Override
public void doSelect() { … }
@Override
public void doPayment() { … }
@Override
public void doDelivery() { … }
}
11 Design Patterns for Reuse and Maintainability
See the whitebox framework
Overriding
Extension via subclassing and overriding methods
Subclass has main method but gives control to framework
Overriding
Software Construction
(3) Iterator
11 Design Patterns for Reuse and Maintainability
Iterator Pattern
 Problem: Clients need uniform strategy to access all elements in a 
container, independent of the container type 客户端希望遍历被放入
容器/集合类的一组ADT对象，无需关心容器的具体类型 – 也就是说，不管对象被放进哪里，都应该提供同样的遍历方式
 Solution: A strategy pattern for iteration 
 Consequences: – Hides internal implementation of underlying container – Support multiple traversal strategies with uniform interface – Easy to change container type – Facilitates communication between parts of the program
11 Design Patterns for Reuse and Maintainability
Iterator Pattern
 Pattern structure – Abstract Iterator class defines traversal protocol – Concrete Iterator subclasses for each aggregate class – Aggregate instance creates instances of Iterator objects – Aggregate instance keeps reference to Iterator object
你希望能
够提供统
一遍历机
制的ADT
返回一个
iterator
对象
你所实现的
具体遍历类
（实现接口
中的三个方
法）
标准的遍历
协议：由三
个方法构成
11 Design Patterns for Reuse and Maintainability
Iterator pattern
 Iterable接口：实现该接口的集合对象是可迭代遍历的
public interface Iterable<T> {
...
Iterator<T> iterator();
}  Iterator接口：迭代器
 Iterator pattern：让自己的集合类实现Iterable接口，并实现自己的
独特Iterator迭代器(hasNext, next, remove)，允许客户端利用这
个迭代器进行显式或隐式的迭代遍历：
for (E e : collection) { … }
Iterator<E> iter = collection.iterator(); 
while(iter.hasNext()) { … }
public interface Iterator<E> {
boolean hasNext();
E next();
void remove();
}
11 Design Patterns for Reuse and Maintainability
Getting an Iterator
public interface Collection<E> extends Iterable<E> {
boolean add(E e);
boolean addAll(Collection<? extends E> c);
boolean remove(Object e);
boolean removeAll(Collection<?> c);
boolean retainAll(Collection<?> c);
boolean contains(Object e);
boolean containsAll(Collection<?> c);
void clear();
int size();
boolean isEmpty();
Iterator<E> iterator();
Object[] toArray()
<T> T[] toArray(T[] a);
… }
Defines an interface for creating 
an Iterator, but allows 
Collection implementation to 
decide which Iterator to 
create.
11 Design Patterns for Reuse and Maintainability
An example of Iterator pattern
public class Pair<E> implements Iterable<E> {
private final E first, second;
public Pair(E f, E s) { first = f; second = s; }
public Iterator<E> iterator() {
return new PairIterator();
}
private class PairIterator implements Iterator<E> {
private boolean seenFirst = false, seenSecond = false;
public boolean hasNext() { return !seenSecond; }
public E next() {
if (!seenFirst) { seenFirst = true; return first; }
if (!seenSecond) { seenSecond = true; return second; }
throw new NoSuchElementException();
}
public void remove() {
throw new UnsupportedOperationException();
} } }
Pair<String> pair = new Pair<String>("foo", "bar");
for (String s : pair) { … }
Software Construction
(4) Visitor
11 Design Patterns for Reuse and Maintainability
Visitor Pattern
 Visitor pattern: Allows for one or more operations to be applied to 
a set of objects at runtime, decoupling the operations from the 
object structure. 对特定类型的object的特定操作(visit)，在运行时将
二者动态绑定到一起，该操作可以灵活更改，无需更改被visit的类 – What the Visitor pattern actually does is to create an external class that 
uses data in the other classes. – If the logic of operation changes, then we need to make change only in the 
visitor implementation rather than doing it in all the item classes. 
 本质上：将数据和作用于数据上的某种/些特定操作分离开来。
 为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码
可以在不改变ADT本身的情况下通过delegation接入ADT
11 Design Patterns for Reuse and Maintainability
Visitor Pattern
你要开发的
ADT
代表需要扩展
的特定操作
accept()：与特定
的visitor子类联系
起来，允许其对自己
的数据做操作
多个element
可以形成复杂
结构如
Collections
操作的具体实
现（多种）
针对不同子类型的
element，分别实
现visit操作
11 Design Patterns for Reuse and Maintainability
Example
/* Abstract element interface (visitable) */
public interface ItemElement {
public int accept(ShoppingCartVisitor visitor);
}
/* Concrete element */
public class Book implements ItemElement{
private double price;
...
int accept(ShoppingCartVisitor visitor) {
visitor.visit(this);
} }
public class Fruit implements ItemElement{
private double weight;
...
int accept(ShoppingCartVisitor visitor) {
visitor.visit(this);
} }
将处理数据的
功能
delegate到
外部传入的
visitor
11 Design Patterns for Reuse and Maintainability
Example
/* Abstract visitor interface */
public interface ShoppingCartVisitor { 
int visit(Book book); 
int visit(Fruit fruit); 
} 
public class ShoppingCartVisitorImpl implements ShoppingCartVisitor {
public int visit(Book book) {
int cost=0;
if(book.getPrice() > 50){
cost = book.getPrice()-5;
}else 
cost = book.getPrice();
System.out.println("Book ISBN::"+book.getIsbnNumber() + " cost ="+cost);
return cost;
}
public int visit(Fruit fruit) {
int cost = fruit.getPricePerKg()*fruit.getWeight();
System.out.println(fruit.getName() + " cost = "+cost);
return cost;
} }
这里只列出了
一种visitor
实现
这个visit操作的功
能完全可以在Book类
内实现为一个方法，
但这就不可变了
11 Design Patterns for Reuse and Maintainability
Example
public class ShoppingCartClient {
public static void main(String[] args) {
ItemElement[] items = new ItemElement[]{
new Book(20, "1234"),new Book(100, "5678"),
new Fruit(10, 2, "Banana"), new Fruit(5, 5, "Apple")};
int total = calculatePrice(items);
System.out.println("Total Cost = "+total);
}
private static int calculatePrice(ItemElement[] items) {
ShoppingCartVisitor visitor = new ShoppingCartVisitorImpl();
int sum=0;
for(ItemElement item : items)
sum = sum + item.accept(visitor);
return sum;
} }
只要更换
visitor的具
体实现，即可
切换算法
11 Design Patterns for Reuse and Maintainability
Visitor vs Iterator
 Iterator: behavioral pattern, is used to access an aggregate 
sequentially without exposing its underlying representation. So you 
could hide a List or array or similar aggregates behind an 
Iterator. 迭代器：以遍历的方式访问集合数据而无需暴露其内部表
示，将“遍历”这项功能delegate到外部的iterator对象。
 Visitor: behavioral pattern, is used to perform an action on a 
structure of elements without changing the implementation of the 
elements themselves. 在特定ADT上执行某种特定操作，但该操作不
在ADT内部实现，而是delegate到独立的visitor对象，客户端可灵活
扩展/改变visitor的操作算法，而不影响ADT
11 Design Patterns for Reuse and Maintainability
Strategy vs visitor
 Visitor: behavioral pattern 
 Strategy: behavioral pattern
 二者都是通过delegation建立两个对象的动态联系 – 但是Visitor强调是的外部定义某种对ADT的操作，该操作于ADT自身关系
不大（只是访问ADT），故ADT内部只需要开放accept(visitor)即可，client
通过它设定visitor操作并在外部调用。 – 而Strategy则强调是对ADT内部某些要实现的功能的相应算法的灵活替换。
这些算法是ADT功能的重要组成部分，只不过是delegate到外部strategy类
而已。
 区别：visitor是站在外部client的角度，灵活增加对ADT的各种不同操
作（哪怕ADT没实现该操作），strategy则是站在内部ADT的角度，
灵活变化对其内部功能的不同配置。
Software Construction
4 Commonality and Difference of 
Design Patterns
11 Design Patterns for Reuse and Maintainability
设计模式的对比：共性样式1
Client
Sub Type 
1.1
Sub Type 
1.n
Interface 1
(or Abstract 
Class 1)
只使用“继承”，不使用“delegation”
核心思路：OCP/DIP
依赖反转，客户端只依赖“抽象”，不能
依赖于“具体”
发生变化时最好是“扩展”而不是“修改”
有些模式里有，
有些模式里无
11 Design Patterns for Reuse and Maintainability
Adaptor
Client
Sub Type 
1.1
Sub Type 
1.n
Interface 1
(or Abstract 
Class 1)
统一接口
被适配的类
Adaptor
适用场合：你已经有了一个类，
但其方法与目前client的需求不
一致。
根据OCP原则，不能改这个类，
所以扩展一个adaptor和一个统
一接口。
11 Design Patterns for Reuse and Maintainability
Template
Client
Sub Type 
1.1
Sub Type 
1.n
Interface 1
(or Abstract 
Class 1)
适用场合：有共性的算法流程，
但算法各步骤有不同的实现
典型的“将共性提升至超类型，
将个性保留在子类型”
(1)要提供一个统一的算法方法，
final的，按次序调用一系列
代表算法步骤的abstract方法
(2) 要提供一组abstract方法，
分别代表算法的某个步骤
注意：如果某个步骤不需要有
多种实现，直接在该抽象类里
写出共性实现即可。
每个子类型，只需要实
现上面的各个
abstract方法即可。
11 Design Patterns for Reuse and Maintainability
设计模式的对比：共性样式2
Client
Sub Type 
1.1
Sub Type 
1.n
Sub Type 
2.n
Sub Type 
2.1
Interface 1
(or Abstract 
Class 1)
Interface 2
(or Abstract 
Class 2)
delegation
delegation
两棵“继承树”，两个层次的“delegation”
11 Design Patterns for Reuse and Maintainability
Strategy
Client
Sub Type 
1.1
Sub Type 
1.n
Sub Type 
2.m
Sub Type 
2.1
Interface 1
(or Abstract 
Class 1)
Interface 2
(or Abstract 
Class 2)
delegation
delegation
算法的不同
实现（包括
数据和方法)
这里的某个方法需要使用
某个具体算法，运行时动
态传入subtype2.x的实
例，调用其具体算法
这里的delegation，不需要永
久保持，在使用算法的那个方
法里动态传入subtype2.x实例
即可，用完就扔掉
根据OCP原则，想有多个算法的实现，
在右侧树里扩展子类型即可，在左侧
子类型里传入不同的类型实例
左右两侧的两棵树的子类型，不需要
一一对应
11 Design Patterns for Reuse and Maintainability
Iterator
Client
Sub Type 
1.1
Sub Type 
1.n
Sub Type 
2.m
Sub Type 
2.1
Interface 1
(or Abstract 
Class 1)
Interface 2
(or Abstract 
Class 2)
delegation 这里代表你要定制的个
性化迭代器iterator，
重写next(), 
hasNext(), remove()
三个方法
Client希望能在Collection中遍历
ADT，所以ADT要实现这个Iterable
接口，能够通过getIterator返回
迭代器实例。你不需要写这个类，
就是JDK提供的Iterable接口
这里就是Iterator接口，
你不需要写，JDK已经
提供
delegation
该delegation
其实是工厂方法，
返回iterator
实例
这是你自
己的ADT
该关系是指：
client拿到
Iterator实
例之后，用
其遍历集合
在该模式里，左右两个树里，其实分别只有一个子类型
11 Design Patterns for Reuse and Maintainability
Factory Method
Client
Sub Type 
1.1
Sub Type 
1.n
Sub Type 
2.n
Sub Type 
2.1
Interface 1
(or Abstract 
Class 1)
Interface 2
(or Abstract 
Class 2)
delegation
delegation
Client想new的ADT
及其多个子类型
Client实际使用的工
厂接口和类
Delegation其实就
是调用右侧各子类型
的new操作
左右两棵树的子类型一一对应。如果在工厂方法里使用type表征右侧的子类型，
那么左侧的子类型只要1个即可。
11 Design Patterns for Reuse and Maintainability
Visitor
Client
Sub Type 
1.1
Sub Type 
1.n
Sub Type 
2.n
Sub Type 
2.1
Interface 1
(or Abstract 
Class 1)
Interface 2
(or Abstract 
Class 2)
双向delegation
这是Visitor接口，
扩展操作是
visit(ADT)
子类型的visit()都是同
样的写法，不同子类型的
visit()没差异
你设计的ADT，考虑到将来可能要
扩展某些操作，但根据OCP，不能
再修改其代码，所以提前预留扩展
点，即accept(visitor)
左右两侧的两棵树的子类型，基本上是一一
对应，但左侧树中的不同子类型可能对应右
侧树中的同一个子类型visitor
双向delegation
针对不同子类型
ADT，分别写其
特殊的visit()
Software Construction
Summary
11 Design Patterns for Reuse and Maintainability
Summary
 Creational patterns – Factory method 
 Structural patterns – Adapter – Decorator
 Behavioral patterns – Strategy
– Template method
– Iterator – Visitor
Software Construction
The end
June 14, 2021Software Construction
12 Construction for
Robustness and Correctness
面向正确性与健壮性的软件构造
Wang Zhongjie
rainy@hit.edu.cn
June 16, 2021
12 Construction for Robustness and Correctness
Outline
 What are Robustness and Correctness?
 How to measure Robustness and Correctness?
 Error and Exception in Java
 Exception Handling
 Assertions
 Defensive Programming
 The SpotBugs tool
 Summary
进入软件构造最关键的质量特性——健壮
性和正确性。
使用错误处理和exception提高robustness
使用断言、防御式编程提高correctness
12 Construction for Robustness and Correctness
Reading
 代码整洁之道：第7章  Java编程思想：第12章  Effective Java：第9章  MIT 6.031：09
 CMU 17-214：Oct 1
 代码大全：第8章
Software Construction
1 What are Robustness and 
Correctness?
12 Construction for Robustness and Correctness
Robustness 健壮性
 Robustness: “the degree to which a system or component can 
function correctly in the presence of invalid inputs or stressful 
environmental conditions“ (IEEE Std 610.12-1990) 健壮性：系统在不
正常输入或不正常外部环境下仍能够表现正常的程度
 Robust programming 面向健壮性的编程 – A style of programming that focuses on handling unexpected termination 
and unexpected actions. 处理未期望的行为和错误终止 – It requires code to handle these terminations and actions gracefully by 
displaying accurate and unambiguous error messages. 即使终止执行，也
要准确/无歧义的向用户展示全面的错误信息 – These error messages allow the user to more easily debug the program. 错
误信息有助于进行debug
12 Construction for Robustness and Correctness
Robustness principle (Postel’s Law)
 Paranoia (偏执狂) – A programmer assumes users are out to break 
their code, and assumes that his own written code may fail or work 
incorrectly. 总是假定用户恶意、假定自己的代码可能失败
 Stupidity - The programmer assumes users will try incorrect, bogus 
and malformed inputs. 把用户想象成白痴，可能输入任何东西 – As a consequence, the programmer returns to the user an unambiguous, 
intuitive error message that does not require looking up error codes. – The error message should try to be as accurate as possible without being 
misleading to the user, so that the problem can be fixed with ease. 返回给
用户的错误提示信息要详细、准确、无歧义
 Robustness principle (Postel’s Law): 对别人宽容点，对自己狠一点 – Be conservative in what you do; be liberal in what you accept from others. – “Be conservative in what you send, be liberal in what you accept”
对自己的代码要保守，对用户的行为要开放
12 Construction for Robustness and Correctness
Robustness principle (Postel’s Law)
Be conservative in what you do, be liberal in what 
you accept from others
(often reworded as "Be conservative in what you 
send, be liberal in what you accept").
12 Construction for Robustness and Correctness
Principles of robust programming 
 Dangerous implements - Users should not gain access to libraries,
data structures, or pointers to data structures. 封闭实现细节，限定
用户的恶意行为 – This information should be hidden from the user so that the user doesn't
accidentally modify them and introduce a bug in the code. – When such interfaces are correctly built, users use them without finding
loopholes to modify the interface. – The user therefore focuses solely on his or her own code.
 Can‘t happen - Code is modified and may introduce a possibility
that an “impossible” case occurs. 考虑极端情况，没有“不可能” – Impossible cases are therefore assumed to be highly unlikely instead. – The developer thinks about how to handle the case that is highly unlikely,
and implements the handling accordingly.
12 Construction for Robustness and Correctness
Correctness 正确性
 Correctness is defined as the software’s ability to perform according 
to its specification. 正确性：程序按照spec加以执行的能力，是最重要
的质量指标！
 Robustness vs. correctness: at opposite ends of the scale. – Correctness means never returning an inaccurate result; no result is better 
than an inaccurate result. 正确性：永不给用户错误的结果 – Robustness means always trying to do something that will allow the 
software to keep operating, even if that leads to results that are inaccurate 
sometimes. 健壮性：尽可能保持软件运行而不是总是退出
 Robustness adds built-in tolerance for common and non-critical 
mistakes, while correctness throws an error when it encounters 
anything less than perfect input. – 正确性倾向于直接报错(error)，健壮性则倾向于容错(fault-tolerance)
12 Construction for Robustness and Correctness
Comparison of Robustness and Correctness
Problem Robust approach Correct approach
A rogue web browser 
that adds trailing 
whitespace to HTTP 
headers. 浏览器发出包含
空格的URL
Strip whitespace, process 
request as normal.
Return HTTP 400 Bad 
Request error status to 
client.
A video file with corrupt 
frames.
视频文件有坏帧
Skip over corrupt area to 
next playable section.
Stop playback, raise 
“Corrupt video file” 
error.
A config file with lines 
commented out using the 
wrong character.
配置文件使用了非法字符
Internally recognize most 
common comment 
prefixes, ignore them.
Terminate on startup 
with “bad configuration” 
error.
A user who enters dates 
in a strange format.
奇怪格式的日期输入
Try parsing the string 
against a number of 
different date formats. 
Render the correct format 
back to the user.
Invalid date error.
12 Construction for Robustness and Correctness
"No Dashes Or Spaces"
 Credit card numbers are always 
printed and read aloud in 
groups of four digits.
 Computers are pretty good at 
text processing, so wasting the 
user’s time by forcing them to 
retype their credit card numbers 
in strange formats is pure 
laziness on behalf of developer.
 In Google Maps, you can enter 
just about anything in the search 
box and it will figure out a street 
address.
 健壮性：避免给用户太大压力，
帮助用户承担一些麻烦
12 Construction for Robustness and Correctness
Comparison of Robustness and Correctness
 Robustness makes life easier for users and third-party developers. – By building in a bit of well thought-out flexibility, it’s going to grant a 
second chance for users with clients that aren’t quite compliant, instead of 
kicking them out cold. 
 Correctness makes life easier for your developers. – Instead of bogging down checking/fixing parameters and working 
around strange edge cases, they can focus on the one single model where 
all assumptions are guaranteed. – Any states outside the main success path can thus be ignored— producing 
code that is briefer, easier to understand, and easier to maintain.
健壮性：
让用户变得更容易：出错也可
以容忍，程序内部已有容错机
制
正确性：
让开发者变得更容易：用户输
入错误，直接结束。
（不满足precondition的调用）
12 Construction for Robustness and Correctness
Comparison of Robustness and Correctness
 Externally and Internally: – External interfaces (UI, input files, configuration, API etc) exist primarily 
to serve users and third parties. Make them robust, and as accommodating 
as possible, with the expectation that people will input garbage. – An application’s internal model (i.e. domain model) should be as simple 
as possible, and always be in a 100% valid state. Use invariants and
assertions to make safe assumptions, and just throw a big fat exception
whenever you encounter anything that isn’t right. – Protect the internal model from external interfaces with an anti-corruption 
layer which maps and corrects invalid input where possible, before 
passing it to the internal model.在内外部之间做好隔离，防止“错误”扩散
 Make your external interfaces robust, and make your internal 
model correct 对外的接口，倾向于健壮；对内的实现，倾向于正确 – If you ignore users’ needs, no one will want to use your software. – If you ignore programmers’ needs, there won’t be any software. 
Internally, seek correctness; 
Externally, seek robustness.
12 Construction for Robustness and Correctness
Comparison of Robustness and Correctness
 Safety critical applications tend to favor correctness to robustness. – It is better to return no result than to return a wrong result.
 Consumer applications tend to favor robustness to correctness. – Any result what so ever is usually better than the software shutting down.
 Reliability (可靠性). The ability of a system to perform its required
functions under stated conditions whenever required—having a long
mean time between failures.
 Reliability = Robustness + Correctness
12 Construction for Robustness and Correctness
Steps for improving robustness and correctness
 Step 0: To program code with robustness and correctness 
objectives using assertions, defensive programing, code review, 
formal validation, etc
 Step 1: To observe failure symptoms (Memory dump, stack traces, 
execution logs, testing)  Step 2: To identify potential fault (bug localization, debug)  Step 3: To fix errors (code revision)
12 Construction for Robustness and Correctness
Techniques for Correctness and Robustness
Coding Testing Debugging
Correctness Robustness
How to program
with high correctness & 
robustness?
Verify
Validate
Improve
Ensure
Software
Assertion
Exception
Error Handling
Defensive Programming
Design of Test Case 
Unit Testing & Integration Testing
Black-box testing & White-box Testing
Test-First Programming
Realize
How to judge whether a 
software is correct and 
robust or not?
How to locate and fix 
defects？
Techniques for Debugging
(Reproduce,Diagnose and Fix)
Debugging tools
(Printing/tracing/Logging
Debugger)
Software Construction
2 How to measure robustness and 
correctness?
12 Construction for Robustness and Correctness
Mean time between failures (MTBF) 外部观察角度
 Mean time between failures (MTBF，平均失效间隔时间) is the 
predicted elapsed time between inherent failures of a system during 
operation. – MTBF is calculated as the arithmetic mean (average) time between failures 
of a system. 
 The definition of MTBF depends on the definition of what is 
considered a system failure. – For complex, repairable systems, failures are considered to be those out of 
design conditions which place the system out of service and into a state for 
repair. – Failures which occur that can be left or maintained in an unrepaired 
condition, and do not place the system out of service, are not considered 
failures under this definition.
12 Construction for Robustness and Correctness
Mean time between failures (MTBF)
 Mean time between failures (MTBF) describes the expected time 
between two failures for a repairable system, while mean time to 
failure (MTTF) denotes the expected time to failure for a non￾repairable system. 
12 Construction for Robustness and Correctness
Residual defect rates 内部观察角度（间接）
 Residual defect rates 残余缺陷率 refers to “bugs left over after the 
software has shipped” per KLOC: 每千行代码中遗留的bug的数量 – 1 - 10 defects/kloc: Typical industry software. – 0.1 - 1 defects/kloc: High-quality validation. The Java libraries might 
achieve this level of correctness. – 0.01 - 0.1 defects/kloc: The very best, safety-critical validation. NASA 
and companies like Praxis can achieve this level. 
 This can be discouraging for large systems. – For example, if you have shipped a million lines of typical industry source 
code (1 defect/kloc), it means you missed 1000 bugs! 
12 Construction for Robustness and Correctness
Recall Maintainability
 Halstead Volume: a composite 
metric based on the number of 
(distinct) operators and 
operands in source code.
Software Construction
3 Error and Exception in Java
12 Construction for Robustness and Correctness
“Abnormals” in Java
 The base class for all Exception objects is java.lang.Throwable, 
together with its two subclasses java.lang.Exception and 
java.lang.Error.
https://docs.oracle.com/javase/8/docs/api
/java/lang/Throwable.html
12 Construction for Robustness and Correctness
Error and Exception
 The Error class describes internal system errors and resource 
exhaustion situations inside the Java runtime system (e.g., 
VirtualMachineError, LinkageError) that rarely occur. – You should not throw an object of this type. – There is little you can do if such an internal error occurs, beyond notifying 
the user and trying to terminate the program gracefully. 
内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结束
 The Exception class describes the error caused by your program 
(e.g. FileNotFoundException, IOException). – These errors could be caught and handled by your program (e.g., perform 
an alternate action or do a graceful exit by closing all the files, network 
and database connections).
异常：你自己程序导致的问题，可以捕获、可以处理
12 Construction for Robustness and Correctness
Sorts of errors
 User input errors 用户输入错误 – In addition to the inevitable typos, some users like to blaze their own trail 
instead of following directions. – E.g. a user asks to connect to a URL that is syntactically wrong, the 
network layer will complain.
 Device errors 设备错误 – Hardware does not always do what you want it to. – The printer may be turned off. – A web page may be temporarily unavailable. – Devices will often fail in the middle of a task.
 Physical limitations 物理限制 – Disks can fill up
– You can run out of available memory
12 Construction for Robustness and Correctness
Error
在大多数时候，
程序员不需要实
例化Error
12 Construction for Robustness and Correctness
Some typical Errors
 VirtualMachineError: thrown to indicate that the Java Virtual 
Machine is broken or has run out of resources necessary for it to 
continue operating. – OutOfMemoryError: thrown when the Java Virtual Machine cannot 
allocate an object because it is out of memory, and no more memory could 
be made available by the garbage collector. – StackOverflowError: thrown when a stack overflow occurs because an 
application recurses too deeply. – InternalError: Thrown to indicate some unexpected internal error has 
occurred in the JVM.
 LinkageError: a class has some dependency on another class; 
however, the latter class has incompatibly changed after the 
compilation of the former class. – NoClassDefFoundError: Thrown if JVM or a ClassLoader instance tries 
to load in the definition of a class but no definition could be found.
Software Construction
4 Exception Handling
既然Error我们无能为力，
那就转向关注我们能处理的Exception
12 Construction for Robustness and Correctness
An Example
Software Construction
(1) What is Exception?
12 Construction for Robustness and Correctness
Exceptions
 An exception is an abnormal event that arises during the execution of 
the program and disrupts the normal flow of the program. 异常：程
序执行中的非正常事件，程序无法再按预想的流程执行
 Exceptions are a specific means by which code can pass along errors 
or exceptional events to the code that called it. 将错误信息传递给上层
调用者，并报告“案发现场”的信息
 Java allows every method an alternative exit path if it is unable to 
complete its task in the normal way. return之外的第二种退出途径 – The method throws an object that encapsulates the error information. – The method exits immediately and does not return any value. – Moreover, execution does not resume at the code that called the method; – Instead, the exception-handling mechanism begins its search for an 
exception handler that can deal with this particular error condition. 若找不
到异常处理程序，整个系统完全退出
12 Construction for Robustness and Correctness
Benefits of exceptions
FileInputStream fIn = new FileInputStream(fileName);
if (fIn == null) {
switch (errno) {
case _ENOFILE:
System.err.println(“File not found: “ + …);
return -1;
default:
System.err.println(“Something else bad happened: “ + …);
return -1;
} }
DataInput dataInput = new DataInputStream(fIn);
if (dataInput == null) {
System.err.println(“Unknown internal error.”);
return -1; // errno > 0 set by new DataInputStream
}
int i = dataInput.readInt();
if (errno > 0) {
System.err.println(“Error reading binary data from file”);
return -1;
}
return i;
Code that does not 
use Exceptions
12 Construction for Robustness and Correctness
Benefits of exceptions
Code that use 
Exceptions
FileInputStream fileInput = null;
try {
fileInput = new FileInputStream(fileName);
DataInput dataInput = new DataInputStream(fileInput);
return dataInput.readInt();
} 
catch (FileNotFoundException e) {
System.out.println("Could not open file " + fileName);
} 
catch (IOException e) {
System.out.println("Couldn’t read file: " + e);
} 
finally {
if (fileInput != null) fileInput.close();
}
Software Construction
(2) Classification of exceptions
12 Construction for Robustness and Correctness
Exceptions are derived from Throwable
 In Java programming language, an exception object is always an 
instance of a class derived from Throwable. 
12 Construction for Robustness and Correctness
12 Construction for Robustness and Correctness
Runtime Exception and Other Exceptions
 When doing Java programming, focus on the Exception hierarchy.
 The Exception hierarchy also splits into two branches: – Exceptions that derive from RuntimeException 运行时异常 – Those that do not. 其他异常
 General rule: – A RuntimeException happens because you made a programming error. 
运行时异常：由程序员在代码里处理不当造成 – Any other exception occurs because a bad thing, such as an I/O error, 
happened to your otherwise good program. 其他异常：由外部原因造成
12 Construction for Robustness and Correctness
Runtime Exception and Other Exceptions
 Exceptions that inherit from RuntimeException include such 
problems as: – A bad cast – An out-of-bounds array access – A null pointer access – ……
 Exceptions that do not inherit from RuntimeException include – Trying to read past the end of a file – Trying to open a file that doesn’t exist – Trying to find a Class object for a string that does not denote an existing 
class – ……
12 Construction for Robustness and Correctness
RuntimeException
 If it is a RuntimeException, it was your fault 运行时异常，是程序
源代码中引入的故障所造成的 – You could have avoided ArrayIndexOutOfBoundsException by testing 
the array index against the array bounds. – The NullPointerException would not have happened had you checked 
whether the variable was null before using it. – 如果在代码中提前进行验证，这些故障就可以避免
 How about a file that doesn’t exist? – Can’t you first check whether the file exists, and then open it? – Actually, the file might be deleted right after you checked for its existence. 
Thus, the notion of “existence” depends on the environment, not just on 
your code. 非运行时异常，是程序员无法完全控制的外在问题所导致的 – 即使在代码中提前加以验证（文件是否存在），也无法完全避免失效发生。
Software Construction
(3) Checked and unchecked exceptions
这是从异常处理机制的角度所做的分类
异常被谁check？——编译器、程序员
12 Construction for Robustness and Correctness
Again, the exception hierarchy in Java
12 Construction for Robustness and Correctness
How is an exception handled?
 When an exception occurs – You have to either catch and handle the exception, or tell compiler that 
you can't handle it by declaring that your method throws that exception, – Then the code that uses your method will have to handle that exception 
(may choose to declare that it throws the exception if it can't handle it). – Compiler will check that we have done one of the two things (catch, or 
declare). 编译器可帮助检查你的程序是否已抛出或处理了可能的异常
 Errors and Runtime Exceptions are not checked by compiler – Errors represent conditions occurring outside the application, such as 
crash of the system. Runtime exceptions are usually 
occur by fault in the application logic. – You can't do anything in these situations, but have 
to re-write your program code. So these are not checked by compiler. – These runtime exceptions will uncover in development, and testing 
period. Then we have to refactor our code to remove these errors.
Checked Exceptions
Unchecked 
Exceptions
12 Construction for Robustness and Correctness
Unchecked exceptions
 Unchecked exception: Programming error, other unrecoverable 
failure (Error + RuntimeException) – No action is required for program to compile, but uncaught exception will 
cause program to fail – 不需要在编译的时候用try…catch等机制处理
 从RuntimeException派生出子类型
可以不处理，编译没
问题，但执行时出现
就导致程序失败，代
表程序中的潜在bug
类似于编程语言中的
dynamic type 
checking
12 Construction for Robustness and Correctness
Checked exceptions
 Checked exception: An error that every caller should be aware of 
and handle 
 Must be caught or propagated, or program won’t compile (The 
compiler checks that you provide exception handlers for all 
checked exceptions)
 需要从Exception派生出子类型
必须捕获并指定错误
处理器handler，否则
编译无法通过
类似于编程语言中的
static type checking
12 Construction for Robustness and Correctness
Examples of unchecked exceptions
public class NullPointerExceptionExample {
public static void main(String args[]){
String str=null;
System.out.println(str.trim());
} }
Exception in thread "main" java.lang.NullPointerException
public class ArrayIndexOutOfBoundExceptionExample {
public static void main(String args[]){
String strArray[]={"Arpit","John","Martin"};
System.out.println(strArray[4]);
} }
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 4
12 Construction for Robustness and Correctness
Common Unchecked Exception Classes
 ArrayIndexOutOfBoundsException: thrown by JVM when your 
code uses an array index, which is outside the array's bounds.
int[] anArray = new int[3];
System.out.println(anArray[3]);
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 3
 NullPointerException: thrown by the JVM when your code 
attempts to use a null reference where an object reference is 
required. 
String[] strs = new String[3];
System.out.println(strs[0].length());
Exception in thread "main" java.lang.NullPointerException
在编程和编译的时候，IDE与编
译器均不会给出任何错误提示
12 Construction for Robustness and Correctness
Common Unchecked Exception Classes
 NumberFormatException: Thrown programmatically (e.g., by 
Integer.parseInt()) when an attempt is made to convert a string 
to a numeric type, but the string does not have the appropriate 
format. 
Integer.parseInt("abc");
Exception in thread "main" java.lang.NumberFormatException: 
For input string: "abc"
在编程和编译的时候，IDE与编
译器均不会给出任何错误提示
 ClassCastException: thrown by JVM 
when an attempt is made to cast an object reference fails. 
Object o = new Object();
Integer i = (Integer)o;
Exception in thread "main" java.lang.ClassCastException: 
java.lang.Object cannot be cast to java.lang.Integer
12 Construction for Robustness and Correctness
Checked Exception Handling Operations
 Five keywords are used in exception handling: – try – catch – finally – throws – throw
 Java’s exception handling consists of three operations: – Declaring exceptions (throws) 声明“本方法可能会发生XX异常” – Throwing an exception (throw) 抛出XX异常 – Catching an exception (try, catch, finally) 捕获并处理XX异常
12 Construction for Robustness and Correctness
Examples of checked exceptions
public static void main(String args[]) {
FileInputStream fis = null;
try {
fis = new FileInputStream("sample.txt");
int c;
while ((c = fis.read()) != -1)
System.out.print((char) c);
fis.close();
} catch (FileNotFoundException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
} catch (Exception e) {
e.printStackTrace();
} }
12 Construction for Robustness and Correctness
Examples of checked exceptions
public static void main(String args[]) throws IOException {
FileInputStream fis = null;
fis = new FileInputStream("sample.txt");
int k;
while ((k = fis.read()) != -1)
System.out.print((char) k);
fis.close();
}
12 Construction for Robustness and Correctness
A note
 Checked exceptions have to be either caught or declared in the 
method signature using throws, whereas with unchecked ones this 
is optional. Unchecked异常也可以使用throws声明或try/catch进
行捕获，但大多数时候是不需要的，也不应该这么做——掩耳盗铃，
对发现的编程错误充耳不闻
public class ArrayIndexOutOfBoundExceptionExample {
public static void main(String args[]){
try {
String strArray[]={"Arpit","John","Martin"};
System.out.println(strArray[4]);
} catch(ArrayIndexOutOfBoundsException e) {...}
} }
12 Construction for Robustness and Correctness
Use checked or unchecked exceptions in your code?
 When deciding on checked exceptions vs. unchecked exceptions, 
ask yourself, “What action can the client code take when the 
exception occurs? 当要决定是采用checked exception还是unchecked 
exception的时候，问一个问题：“如果这种异常一旦抛出，client会做
怎样的补救？”
Client's reaction when exception happens Exception type
Client code cannot do anything Make it an unchecked exception
action based on information in exception
Client code will take some useful recovery Make it a checked exception
– 如果客户端可以通过其他的方法恢复异常，那么采用checked exception； – 如果客户端对出现的这种异常无能为力，那么采用unchecked exception； – 异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。
12 Construction for Robustness and Correctness
Use checked or unchecked exceptions in your code?
 尽量使用unchecked exception来处理编程错误：因为unchecked 
exception不用使客户端代码显式的处理它们，它们自己会在出现的地
方挂起程序并打印出异常信息。 – 充分利用Java API中提供的丰富unchecked exception，如
NullPointerException , IllegalArgumentException和
IllegalStateException等，使用这些标准的异常类而不需亲自创建新的
异常类，使代码易于理解并避免过多消耗内存。
 如果client端对某种异常无能为力，可以把它转变
为一个unchecked exception，程序被挂起并返回
客户端异常信息
try{
..some code that throws SQLException
}catch(SQLException ex){
throw new RuntimeException(ex);
}
不同的程序员有不
同的观点，关于该
如何选择checked和
unchecked 
exceptions，在技术
人员中存有很大的
争论。
12 Construction for Robustness and Correctness
Use checked or unchecked exceptions in your code?
 Try not to create new custom exceptions if they do not have useful 
information for client code – 不要创建没有意义的异常，client应该从checked exception中获取更有价值
的信息(案发现场具体是什么样子)，利用异常返回的信息来明确操作失败的
原因。 – 如果client仅仅想看到异常信息，可以简单抛出一个unchecked exception:
throw new RuntimeException("Username already taken");
 Summary
– Checked exception应该让客户端从中得到丰富的信息。 – 要想让代码更加易读，倾向于用unchecked exception来处理程序中的错误
12 Construction for Robustness and Correctness
Use checked or unchecked exceptions in your code?
 Checked Exceptions should be used for expected, but 
unpreventable errors that are reasonable to recover from. 错误可预
料，但无法预防，但可以有手段从中恢复，此时使用checked 
exception。  Unchecked Exceptions should be used for everything else. 如果做
不到这一点，则使用unchecked exception
– Expected but unpreventable: 可预料但不可预防
• The caller did everything within their power to validate the input parameters, 
but some condition outside their control has caused the operation to fail. 
• For example, you try reading a file but someone deletes it between the time you 
check if it exists and the time the read operation begins. 
• By declaring a checked exception, you are telling the caller to anticipate this 
failure. 
• 不可预防：脱离了你的程序的控制范围
12 Construction for Robustness and Correctness
Use checked or unchecked exceptions in your code?
 Reasonable to recover from: 可合理的恢复 – There is no point telling callers to anticipate exceptions that they cannot 
recover from. – If a user attempts to read from an non-existing file, the caller can prompt 
them for a new filename. – On the other hand, if the method fails due to a programming bug (invalid 
method arguments or buggy method implementation) there is nothing the 
application can do to fix the problem in mid-execution. – The best it can do is log the problem and wait for the developer to fix it at 
a later time. – 如果读文件的时候发现文件不存在了，可以让用户选择其他文件；但是如果
调用某方法时传入了错误的参数，则无论如何都无法在不中止执行的前提下
进行恢复。
 Unless the exception you are throwing meets all of the above 
conditions it should use an Unchecked Exception.
12 Construction for Robustness and Correctness
Exception design considerations
 Use checked exceptions for special results (i.e., anticipated situations)
 Use unchecked exceptions to signal bugs (unexpected failures)
 You should use an unchecked exception only to signal an 
unexpected failure (i.e. a bug), or if you expect that clients will 
usually write code that ensures the exception will not happen, 
because there is a convenient and inexpensive way to avoid the 
exception;
 Otherwise you should use a checked exception.
12 Construction for Robustness and Correctness
Checked vs. Unchecked Exceptions
Checked exception Unchecked exception
Basic
The compiler checks the checked 
exception. If we do not handle the 
checked exception, then the compiler 
objects. 必须被显式地捕获或者传递
（try-catch-finally-throw)，否则编
译器无法通过
The compiler does not check
the Unchecked exception. 
Even if we do not handle the 
unchecked exception, the 
compiler doesn‘t object.异常可
以不必捕获或抛出，编译器不
去检查
Class of 
Exception
Except RuntimeException class, all the 
child classes of the class “Exception”, 
and the “Error” class and its child 
classes are Checked Exception. 继承自
Exception类
RuntimeException class and 
its child classes, are 
Unchecked Exceptions.继承自
RuntimeException类
Handling
从异常发生的现场获取详细的信息，利用
异常返回的信息来明确操作失败的原因，
并加以合理的恢复处理
简单打印异常信息，无法再继
续处理
Appearance 代码看起来复杂，正常逻辑代码和异常处
理代码混在一起 清晰，简单
Software Construction
(4) Declaring Checked Exceptions by 
throws
12 Construction for Robustness and Correctness
Declaring Checked Exceptions by throws
 A Java method can throw an exception if it encounters a situation it 
cannot handle. – A method will not only tell the Java compiler what values it can return, it 
is also going to tell the compiler what can go wrong. “异常”也是方法和
client端之间spec的一部分，在post-condition中刻画 – E.g. code that attempts to read from a file knows that the file might not 
exist or that it might be empty. The code that tries to process the 
information in a file therefore will need to notify the compiler that it can 
throw some sort of IOException.  The place in which you advertise that your method can throw an 
exception is the header of the method; the header changes to reflect 
the checked exceptions the method can throw.
public FileInputStream(String name) 
throws FileNotFoundException
12 Construction for Robustness and Correctness
How to declare exceptions in a specification
 Checked exceptions that signal a special result are always 
documented with a Javadoc @throws clause, specifying the 
conditions under which that special result occurs.
 Java may also require the exception to be included in the method 
signature, using a throws declaration.
12 Construction for Robustness and Correctness
How to declare exceptions in a specification
 As with Java methods that are part of the supplied classes, you 
declare that your method may throw an exception with an 
exception specification in the method header and in spec. 程序员必
须在方法的spec中明确写清本方法会抛出的所有checked exception，
以便于调用该方法的client加以处理
12 Construction for Robustness and Correctness
How to declare exceptions in a specification
 Unchecked exceptions that are used to signal unexpected failures –
bugs in either the client or the implementation – are not part of the 
postcondition of a method, so they should not appear in either 
@throws or throws.  For example, NullPointerException need never be mentioned in 
a spec.
12 Construction for Robustness and Correctness
Declare more than one Checked Exceptions
 If a method might throw more than one checked exception type, 
you must list all exception classes in the header.
class MyAnimation {
. . .
public Image loadImage(String s) 
throws FileNotFoundException, EOFException 
{
. . . 
} }
12 Construction for Robustness and Correctness
Declaring Checked Exceptions by throws
 When you write your own methods, you don’t have to advertise 
every possible throwable object that your method might actually 
throw. 你的方法应该throws什么异常？ – You call a method that throws a checked exception—for example, the 
FileInputStream constructor. 你所调用的其他函数抛出了一个checked 
exception——从其他函数传来的异常 – You detect an error and throw a checked exception with the throw
statement. 当前方法检测到错误并使用throws抛出了一个checked 
exception——你自己造出的异常
 Then you must tell the programmers who will use your method 
about the possibility of an exception. 此时需要告知你的client需要
处理这些异常 – If no handler catches the exception, the current thread of execution 
terminates. 如果没有handler来处理被抛出的checked exception，程序就终
止执行
12 Construction for Robustness and Correctness
Don’t throw Error and unchecked exceptions
 Do not need to advertise internal Java errors— exceptions 
inheriting from Error. – Any code could potentially throw those exceptions, and they are entirely 
beyond your control. – An internal error occurs in the virtual machine or runtime library.
 You should not advertise unchecked exceptions inheriting from 
RuntimeException. – These runtime errors are completely under your control. – If you are so concerned about array index errors, you should spend your 
time fixing them instead of advertising the possibility they can happen. – You make a programming error, such as a[-1] = 0 that gives rise to an 
unchecked exception (ArrayIndexOutOfBoundsException).
void drawImage(int i) throws ArrayIndexOutOfBoundsException 
// bad style!
12 Construction for Robustness and Correctness
Considering subtyping polymorphism 
 If you override a method from a superclass, the checked exceptions 
that the subclass method declares cannot be more general than 
those of the superclass method. 如果子类型中override了父类型中
的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型
更宽泛
 It is OK to throw more specific exceptions, or not to throw any 
exceptions in the subclass method. 子类型方法可以抛出更具体的异
常，也可以不抛出任何异常
 In particular, if the superclass method throws no checked 
exception at all, neither can the subclass. 如果父类型的方法未抛出
异常，那么子类型的方法也不能抛出异常。
参见LSP原则
目标是子类型多态：客户端可用统一的方式处理不
同类型的对象，子类型可替代父类型
12 Construction for Robustness and Correctness
Liskov Substitution Principle (LSP)
 LSP is a particular definition of a subtyping relation, called 
(strong) behavioral subtyping 强行为子类型化
 In programming languages, LSP is relied on the following 
restrictions: – Preconditions cannot be strengthened in a subtype. – Postconditions cannot be weakened in a subtype. – Invariants of the supertype must be preserved in a subtype. – Contravariance of method arguments in a subtype 子类型方法参数：逆变 – Covariance of return types in a subtype. 子类型方法的返回值：协变 – No new exceptions should be thrown by methods of the subtype, except 
where those exceptions are themselves subtypes of exceptions thrown by 
the methods of the supertype.
12 Construction for Robustness and Correctness
Considering subtyping polymorphism 
public class Test {
public boolean readFromFile() throws FileNotFoundException {
...
} }
class SubType extends Test {
@Override
public boolean readFromFile() throws IOException { 
...
} }
Software Construction
(5) How to Throw an Exception
12 Construction for Robustness and Correctness
How to Throw an Exception
 Suppose you have a method, readData, that is reading in a file. 
Something terrible has happened in your code. 
 You may decide this situation is so abnormal that you want to 
throw an exception EOFException with the description “Signals 
that an EOF has been reached unexpectedly during input.”
throw new EOFException(); 
or
EOFException e = new EOFException();
throw e;
12 Construction for Robustness and Correctness
How to Throw an Exception
String readData(Scanner in) throws EOFException
{
. . .
while (. . .)
{
if (!in.hasNext()) // EOF encountered
{
if (n < len)
throw new EOFException();
}
. . .
}
return s;
}
声明：本函
数可能发生
该异常
异常在这里
发生了
问题：还有可能
是在哪里抛出
EOFException？
12 Construction for Robustness and Correctness
How to Throw an Exception
 The EOFException has a second constructor that takes a string
argument. 
 You can put this to good use by describing the exceptional 
condition more carefully. 利用Exception的构造函数，将发生错误
的现场信息充分的传递给client。
String gripe = "Content-length: " + len + ", Received: " + n;
throw new EOFException(gripe);
12 Construction for Robustness and Correctness
How to Throw an Exception
 Throwing an exception is easy if one of the existing exception 
classes works for you: – Find an appropriate exception class 找到一个能表达错误的Exception类/
或者构造一个新的Exception类 – Make an object of that class 构造Exception类的实例，将错误信息写入 – Throw it 抛出它
 Once a method throws an exception, it does not return to its caller. 
This means you do not have to worry about cooking up a default 
return value or an error code 一旦抛出异常，方法不会再将控制权返
回给调用它的client，因此也无需考虑返回错误代码
Software Construction
(6) Creating Exception Classes
12 Construction for Robustness and Correctness
Creating Exception Classes
 Your code may run into a problem which is not adequately 
described by any of the standard exception classes. 
 In this case, it is easy enough to create your own exception class. 
 如果JDK提供的exception类无法充分描述你的程序发生的错误，可以
创建自己的异常类
 Just derive it from Exception, or from a child class of Exception
such as IOException.  It is customary to give both a default constructor and a constructor 
that contains a detailed message. – The toString method of the Throwable superclass returns a string 
containing that detailed message, which is handy for debugging.
12 Construction for Robustness and Correctness
An example for checked exception 
 To define a checked exception you create a subclass (or hierarchy 
of subclasses) of java.lang.Exception:
public class FooException extends Exception {
public FooException() { super(); }
public FooException(String message) { super(message); }
public FooException(String message, Throwable cause) { 
super(message, cause); 
}
public FooException(Throwable cause) { super(cause); }
}  Methods that can potentially throw or propagate this exception 
must declare it:
public void calculate(int i) throws FooException, IOException;
12 Construction for Robustness and Correctness
An example for checked exception 
 Code calling this method must either handle or propagate this 
exception (or both):
try {
...
} catch(FooException ex) {
ex.printStackTrace();
System.exit(1);
} catch(IOException ex) {
throw new FooException(ex);
}
12 Construction for Robustness and Correctness
An example for unchecked exception 
 Sometimes there will be situations where you don‘t want to force 
every method to declare your exception implementation in its 
throws clause. In this case you can create an unchecked exception 
that extends java.lang.RuntimeException. public class FooRuntimeException extends RuntimeException {
...
}  Methods can throw or propagate FooRuntimeException exception 
without declaring it.
public void calculate(int i) {
if (i < 0) {
throw new FooRuntimeException("i < 0: " + i);
} }
12 Construction for Robustness and Correctness
Creating more specific unchecked exception
class FileFormatException extends IOException {
public FileFormatException() {}
public FileFormatException(String gripe){ 
super(gripe);
} }
String readData(BufferedReader in) throws FileFormatException {
. . .
while (. . .){ 
if (ch == -1) { // EOF encountered 
if (n < len) {
String errorInfo = ...;
throw new FileFormatException(efforInfo);
} }
. . .
}
return s;
}
12 Construction for Robustness and Correctness
An exception class can contain more information
public class InsufficientFundsException extends Exception {
private double amount;
public InsufficientFundsException(double amount) {
this.amount = amount;
} 
public double getAmount(){
return amount;
} }
...
double needs = amount - balance;
throw new InsufficientFundsException(needs); 
...
try{ ...
}catch(InsufficientFundsException e){
System.out.println(“Money is short for "+ e.getAmount());
}
包含更多“案发现场
信息”的异常类定义
和辅助函数
抛出异常的时候，将
现场信息记入异常
在异常处理时，利用
这些信息给用户更有
价值的帮助
Software Construction
(7) Catching Exceptions
12 Construction for Robustness and Correctness
Catching Exceptions
 If an exception occurs that is not caught anywhere, the program 
will terminate and print a message to the console, giving the type 
of the exception and a stack trace. 异常发生后，如果找不到处理器，
就终止执行程序，在控制台打印出stack trace。 – GUI programs catch exceptions, print stack trace messages, and then go 
back to the user interface processing loop.
 To catch an exception, set up a try/catch block :
try {
code
more code
more code
} 
catch (ExceptionType e) {
handler for this type
}
12 Construction for Robustness and Correctness
Catching Exceptions
 If any code inside the try block throws an exception of the class 
specified in the catch clause, then
– The program skips the remainder of the code in the try block. – The program executes the handler code inside the catch clause. – If none of the code inside the try block throws an exception, then the 
program skips the catch clause. – If any of the code in a method throws an exception of a type other than the 
one named in the catch clause, this method exits immediately. – Hopefully, one of its callers has already provided a catch clause for that 
type.
12 Construction for Robustness and Correctness
Catching Exceptions
public void read(String filename) {
try {
InputStream in = new FileInputStream(filename);
int b;
while ((b = in.read()) != -1) {
process input...
} }
catch (IOException exception) {
exception.printStackTrace();
} }
12 Construction for Robustness and Correctness
Pass the exception on to the caller
 Another choice to handle the exceptions: do nothing at all and 
simply pass the exception on to the caller. 也可以不在本方法内处理，
而是传递给调用方，由client处理（“推卸责任”） – Let the caller of the read method worry about it! – Might be the best choice (prefer more correctness to robustness).
 If we take that approach, then we have to advertise the fact that the 
method may throw an IOException. public void read(String filename) throws IOException {
InputStream in = new FileInputStream(filename);
int b;
while ((b = in.read()) != -1) {...}
}  The compiler strictly enforces the throws specifiers. If you call a 
method that throws a checked exception, you must either handle it 
or pass it on. 
12 Construction for Robustness and Correctness
Try/catch and throw an exception?
 As a general rule, you should catch those exceptions that you know 
how to handle and propagate those that you do not know how to 
handle. 尽量在自己这里处理，实在不行就往上传——要承担责任！
 When you propagate an exception, you must add a throws
specifier to alert the caller that an exception may be thrown. 但有些
时候自己不知道如何处理，那么提醒上家，由client自己处理
 Notice: – If you are writing a method that overrides a superclass method which 
throws no exceptions, then you must catch each checked exception in the 
method’s code. 如果父类型中的方法没有抛出异常，那么子类型中的方法必
须捕获所有的checked exception——为什么? – You are not allowed to add more throws specifiers to a subclass method 
than are present in the superclass method. 子类型方法中不能抛出比父类型
方法更多的异常！
12 Construction for Robustness and Correctness
Get detailed information from an Exception
 The exception object may contain information about the nature of 
the exception.
 To find out more about the object, try e.getMessage() to get the 
detailed error message (if there is one)
 Use e.getClass().getName() to get the actual type of the 
exception object.
12 Construction for Robustness and Correctness
Catching Multiple Exceptions
 You can catch multiple exception types in a try block and handle 
each type differently. 
 Use a separate catch clause for each type as in the following 
example:
try {
code that might throw exceptions
}
catch (FileNotFoundException e) {
emergency action for missing files
}
catch (UnknownHostException e) {
emergency action for unknown hosts
}
catch (IOException e) {
emergency action for all other I/O problems
}
Software Construction
(8) Rethrowing and Chaining 
Exceptions
12 Construction for Robustness and Correctness
Rethrowing and Chaining Exceptions
 You can throw an exception in a catch clause 本来catch语句下面是
用来做exception handling的，但也可以在catch里抛出异常
 Typically, you do this when you want to change the exception type. 
 If you build a subsystem that other programmers use, it makes a 
lot of sense to use an exception type that indicates a failure of the 
subsystem. – E.g., ServletException, the code that executes a servlet may not want to 
know in minute detail what went wrong, but it definitely wants to know 
that the servlet was at fault.
 这么做的目的是：更改exception的类型，更方便client端获取错误信
息并处理
12 Construction for Robustness and Correctness
Rethrowing and Chaining Exceptions
 Here is how you can catch an exception and rethrow it:
try {
access the database
}
catch (SQLException e) {
throw new ServletException("database error: " + e.getMessage());
} Here, the ServletException is constructed with the message text
of the exception.
12 Construction for Robustness and Correctness
Rethrowing and Chaining Exceptions
 However, it is a better idea to set the original exception as the 
“cause” of the new exception 但这么做的时候最好保留“根原因”
try {
access the database
}
catch (SQLException e) {
Throwable se = new ServletException("database error");
se.initCause(e);
throw se;
}  When the exception is caught, the original exception can be 
retrieved
Throwable e = se.getCause();
 This wrapping technique is highly recommended. It allows you to 
throw high level exceptions in subsystems without losing the 
details of the original failure.
Software Construction
(9) finally Clause
12 Construction for Robustness and Correctness
finally Clause
 When your code throws an exception, it stops processing the 
remaining code in your method and exits the method. 当异常抛出
时，方法中正常执行的代码被终止
 This is a problem if the method has acquired some resource (files, 
database connections,…), which only this method knows about, 
and that resource must be cleaned up. 如果异常发生前曾申请过某
些资源，那么异常发生后这些资源要被恰当的清理
 One solution is to catch and rethrow all exceptions. 
 But this solution is tedious because you need to clean up the 
resource allocation in two places—in the normal code and in the 
exception code.
 Java has a better solution: the finally clause.
12 Construction for Robustness and Correctness
Try-Catch-Finally
 The code in the finally clause executes whether or not an exception 
was caught. 
 In the following example, the program will close the file under all 
circumstances: InputStream in = new FileInputStream(. . .);
try {
// 1
code that might throw exceptions
// 2
}
catch (IOException e) {
// 3
show error message
// 4
} 
finally {
// 5
in.close();
}
// 6
12 Construction for Robustness and Correctness
Try-Catch-Finally: case 1
 Three possible situations in 
which the program will execute 
the finally clause.
 Case 1: The code throws no 
exceptions. – The program first executes all the 
code in the try block. – Then, it executes the code in the 
finally clause. – Afterwards, execution continues 
with the first statement after the 
finally clause. – In other words, execution passes 
through points 1, 2, 5, and 6.
InputStream in = 
new FileInputStream(. . .);
try {
// 1
code that might throw exceptions
// 2
}
catch (IOException e) {
// 3
show error message
// 4
} 
finally {
// 5
in.close();
}
// 6
不管程序是否碰到异常，finally都会被执行
12 Construction for Robustness and Correctness
Try-Catch-Finally: case 2
 Case 2: The code throws an exception that is caught in a catch
clause. – The program executes all code in the try block, up to the point at which 
the exception was thrown. The remaining code in the try block is skipped. 
The program then executes the code in the matching catch clause, and 
then the code in the finally clause. – If the catch clause does not throw 
an exception, the program executes 
the first line after the finally clause. – Execution passes through points 1, 
3, 4, 5, and 6. – If catch clause throws an 
exception, then the exception 
is thrown back to the caller, and 
execution passes through points 
1, 3, and 5 only.
InputStream in = new FileInputStream(. . .);
try {
// 1
code that might throw exceptions
// 2
}
catch (IOException e) {
// 3
show error message
// 4
} 
finally {
// 5
in.close();
}
// 6
12 Construction for Robustness and Correctness
Try-Catch-Finally: case 3
 Case3: The code throws an exception that is not caught in any catch 
clause. – Here, the program executes all code in the try block until the exception is 
thrown. – The remaining code in the try block is skipped. – Then, the code in the finally
clause is executed, and the 
exception is thrown back to the 
caller of this method. – Execution passes through points 
1 and 5 only.
InputStream in = new FileInputStream(. . .);
try {
// 1
code that might throw exceptions
// 2
}
catch (IOException e) {
// 3
show error message
// 4
} 
finally {
// 5
in.close();
}
// 6
Go back to the client
12 Construction for Robustness and Correctness
Using finally without a Catch
 You can use the finally clause without a catch clause. 
 For example, consider the following try statement:
InputStream in = . . .;
try {
code that might throw exceptions
}
finally {
in.close();
}  The in.close() statement in the finally clause is executed 
whether or not an exception is encountered in the try block. 
 If an exception is encountered, it is rethrown and must be caught 
in another catch clause.
12 Construction for Robustness and Correctness
Problem
class Indecisive {
public static void main(String[] args) {
System.out.println(decision());
}
static boolean decision() {
try {
return true;
} finally {
return false;
} } }
The finally is processed 
after the try.
Software Construction
(10) Analyzing Stack Trace Elements
12 Construction for Robustness and Correctness
Stack trace (or call stack trace)
12 Construction for Robustness and Correctness
Method Call Stack
 A typical application involves 
many levels of method calls, 
which is managed by a so￾called method call stack.  A stack is a last-in-first-out 
queue.  What’s the result? – Enter main() – Enter methodA() – Enter methodB() – Enter methodC() – Exit methodC() – Exit methodB() – Exit methodA() – Exit main()
public class MethodCallStackDemo {
public static void main(String[] args) {
System.out.println("Enter main()");
methodA();
System.out.println("Exit main()");
}
public static void methodA() {
System.out.println("Enter methodA()");
methodB();
System.out.println("Exit methodA()");
}
public static void methodB() {
System.out.println("Enter methodB()");
methodC();
System.out.println("Exit methodB()");
}
public static void methodC() {
System.out.println("Enter methodC()");
System.out.println("Exit methodC()");
} }
12 Construction for Robustness and Correctness
Method Call Stack
 The sequence of events: – JVM invoke the main(). – main() pushed onto call stack, before invoking 
methodA(). – methodA() pushed onto call stack, before invoking 
methodB(). – methodB() pushed onto call stack, before invoking 
methodC(). – methodC() completes. – methodB() popped out from call stack and completes. – methodA() popped out from the call stack and 
completes. – main() popped out from the call stack and completes. 
Program exits.
12 Construction for Robustness and Correctness
Call Stack Trace
 Suppose methodC() carries out a "divide-by-0" operation, which 
triggers an ArithmeticException.  The exception message clearly shows the method call stack 
trace with the relevant statement line numbers:
Enter main()
Enter methodA()
Enter methodB()
Enter methodC()
Exception in thread "main" java.lang.ArithmeticException: / by zero
at MethodCallStackDemo.methodC(MethodCallStackDemo.java:22)
at MethodCallStackDemo.methodB(MethodCallStackDemo.java:16)
at MethodCallStackDemo.methodA(MethodCallStackDemo.java:10)
at MethodCallStackDemo.main(MethodCallStackDemo.java:4)
12 Construction for Robustness and Correctness
Call Stack Trace
 Process: – MethodC() triggers an ArithmeticException. As it does not handle this 
exception, it popped off from the call stack immediately. – MethodB() also does not handle this exception and popped off the call 
stack. So does methodA() and main() method. – The main() method passes back to JVM, which abruptly terminates the 
program and print the call stack trace.
Enter main()
Enter methodA()
Enter methodB()
Enter methodC()
Exception in thread "main" java.lang.ArithmeticException: / by zero
at MethodCallStackDemo.methodC(MethodCallStackDemo.java:22)
at MethodCallStackDemo.methodB(MethodCallStackDemo.java:16)
at MethodCallStackDemo.methodA(MethodCallStackDemo.java:10)
at MethodCallStackDemo.main(MethodCallStackDemo.java:4)
12 Construction for Robustness and Correctness
Exception & Call Stack
 When an exception occurs inside a Java method, the method creates 
an Exception object and passes the Exception object to the JVM 
(i.e., the method "throw" an Exception). 
 The Exception object contains the type of the exception, and the 
state of the program when the exception occurs. 
 The JVM is responsible for finding an exception handler to process 
the Exception object. – It searches backward through the call stack until it finds a matching 
exception handler for that particular class of Exception object (in Java 
term, it is called "catch" the Exception). – If the JVM cannot find a matching exception handler in all the methods in 
the call stack, it terminates the program.
12 Construction for Robustness and Correctness
Exception & Call Stack
 Suppose that methodD() encounters an abnormal condition and 
throws a XxxException to the JVM. 
 The JVM searches backward through the call stack for a matching 
exception handler. 
 It finds methodA() having
a XxxException handler 
and passes the exception 
object to the handler. – Notice that methodC() and
methodB() are required to 
declare "throws
XxxException" in their 
method signatures in order 
to compile the program.
12 Construction for Robustness and Correctness
Analyzing Stack Trace Elements
 A stack trace is a listing of all pending method calls at a particular 
point in the execution of a program. 
 You have almost certainly seen stack trace listings—they are 
displayed whenever a Java program terminates with an uncaught 
exception.
 You can access the text description of a stack trace by calling the 
printStackTrace method of the Throwable class.
Throwable t = new Throwable();
StringWriter out = new StringWriter();
t.printStackTrace(new PrintWriter(out));
String description = out.toString();
12 Construction for Robustness and Correctness
Analyzing Stack Trace Elements
 A more flexible approach is the getStackTrace method that yields 
an array of StackTraceElement objects, which you can analyze in 
your program. 
Throwable t = new Throwable();
StackTraceElement[] frames = t.getStackTrace();
for (StackTraceElement frame : frames)
analyze frame
 The StackTraceElement class has methods to obtain the file name 
and line number, as well as the class and method name, of the 
executing line of code. 
 The toString method yields a formatted string containing all of 
this information.
Software Construction
5 Assertions
12 Construction for Robustness and Correctness
First Defense: Make Bugs Impossible
 The best defense against bugs is to make them impossible by 
design. 最好的防御就是不要引入bug  – Static checking: eliminates many bugs by catching them at compile time. – Dynamic checking: Java makes array overflow bugs impossible by 
catching them dynamically. If you try to use an index outside the bounds 
of an array or a List, then Java automatically produces an error. ---
unchecked exception / runtime error – Immutability: An immutable type is a type whose values can never 
change once they have been created. – Immutable values: by final, which can be assigned once but never 
reassigned. – Immutable references: by final, which makes the reference 
unreassignable, but the object that the reference points to may be mutable 
or immutable.
12 Construction for Robustness and Correctness
Second Defense: Localize Bugs
 If we can’t prevent bugs, we can try to localize them to a small part 
of the program, so that we don’t have to look too hard to find the 
cause of a bug. 如果无法避免，尝试着将bug限制在最小的范围内 – When localized to a single method or small module, bugs may be found 
simply by studying the program text. 限定在一个方法内部，不扩散 – Fail fast: the earlier a problem is observed (the closer to its cause), the 
easier it is to fix. 尽快失败，就容易发现、越早修复 Pre-condition
如果违反，该方法
可以做任何事
Since the bad call indicates a bug in the caller, 
however, the most useful behavior would 
point out the bug as early as possible. 应该尽
可能早的指出client的bug
12 Construction for Robustness and Correctness
Second Defense: Localize Bugs
 Assertions 断言: When the precondition is not satisfied, this code 
terminates the program by throwing an AssertionError exception. 
The effects of the caller’s bug are prevented from propagating. Fail 
fast，避免扩散
 Checking preconditions is an example of defensive programming
检查前置条件是防御式编程的一种典型形式 – Real programs are rarely bug-free. – Defensive programming offers a way to mitigate the effects of bugs even if 
you don’t know where they are. 
Software Construction
(1) What and Why Assertions?
12 Construction for Robustness and Correctness
What is assertion?
 An assertion is code that’s used during development that allows a 
program to check itself as it runs, i.e., to test your assumptions about 
your program logic (such as pre-conditions, post-conditions, and 
invariants). 断言：在开发阶段的代码中嵌入，检验某些“假设”是否
成立。若成立，表明程序运行正常，否则表明存在错误。 – When an assertion is true, that means everything is operating as expected. – When it’s false, that means it has detected an unexpected error in the code. 
 An example
public class AssertionTest {
public static void main(String[] args) {
int number = -5; // assumed number is not negative
// This assert also serve as documentation
assert (number >= 0) : "number is negative: " + number;
// do something
System.out.println("The number is " + number);
} }
12 Construction for Robustness and Correctness
What is assertion?
 Each assertion contains a boolean expression that you believe will 
be true when the program executes. – If it is not true, the JVM will throw an AssertionError. – This error signals you that you have an invalid assumption that needs to 
be fixed. 出现AssertionError，意味着内部某些假设被违反了 – The assertion confirms your assumptions about the behavior of your 
program, increasing your confidence that the program is free of errors. 增
强程序员对代码质量的信心：对代码所做的假设都保持正确
 Assertion is much better than using if-else statements, as it 
serves as proper documentation on your assumptions, and it does 
not carry performance liability in the production environment. 
断言即是对代码中程序员所做假设的文档化，也不会影响运行时性能
(在实际使用时，assertion都会被disabled)
12 Construction for Robustness and Correctness
What is assertion?
 An assertion usually takes two arguments – A boolean expression that describes the assumption supposed to be true – A message to display if it isn’t. 
 The Java language has a keyword assert with two forms: – assert condition; – assert condition : message; – Both statements evaluate the condition and throw an AssertionError if 
the boolean expression evaluates to false. – In the second statement, the expression is passed to the constructor of the 
AssertionError object and turned into a message string. The description 
is printed in an error message when the assertion fails, so it can be used to 
provide additional details to the programmer about the cause of the 
failure. 
所构造的message在发生错误时显示给用户，便于快速发现错误所在
12 Construction for Robustness and Correctness
Assertion in Java
 To assert that x is non-negative, you can simply use the statement
assert x >= 0;
 Or pass the actual value of x into the AssertionError object, so that 
it gets displayed later: 
assert x >= 0 : “x is ” + x;
 If x == -1, then this assertion fails with the error message
x is -1
 This information is often enough to get started in finding the bug.
12 Construction for Robustness and Correctness
Assertion Example
public class AssertionSwitchTest {
public static void main(String[] args) {
// assumed either '+', '-', '*', '/' only
char operator = '%'; 
int operand1 = 5, operand2 = 6, result = 0;
switch (operator) {
case '+': result = operand1 + operand2; break;
case '-': result = operand1 - operand2; break;
case '*': result = operand1 * operand2; break;
case '/': result = operand1 / operand2; break;
default: assert false : "Unknown operator: " + operator;
}
System.out.println(operand1 + " " + operator + " " 
+ operand2 + " = " + result);
} }
Software Construction
(2) What to Assert and What not to?
12 Construction for Robustness and Correctness
When use assertions?
 Assertion can be used for verifying: – Internal Invariants 内部不变量: Assert that a value is within a certain 
constraint, e.g., assert x > 0. – Rep Invariants 表示不变量: Assert that an object's state is within a 
constraint. What must be true about each instance of a class before or after 
the execution of a method? Class invariants are typically verified via 
private boolean method, e.g., checkRep(). – Control-Flow Invariants 控制流不变量: Assert that a certain location will 
not be reached. For example, the default clause of a switch-case
statement. – Pre-conditions of methods 方法的前置条件: What must be true when a 
method is invoked? Typically expressed in terms of the method's 
arguments or the states of its objects. – Post-conditions of methods 方法的后置条件: What must be true after a 
method completes successfully?
12 Construction for Robustness and Correctness
What to Assert？  Pre-condition: method argument requirements 
 Post-condition: Method return value requirements – This kind of assertion is sometimes called a self check . public double sqrt(double x) { 
assert x >= 0; 
double r; 
... // compute result r 
assert Math.abs(r*r - x) < .0001; 
return r; 
}
12 Construction for Robustness and Correctness
What to Assert？  Control-flow: covering all – If a conditional statement or switch does not cover all the possible cases, it 
is good practice to use an assertion to block the illegal cases.
switch (vowel) { 
case 'a': 
case 'e': 
case 'i': 
case 'o': 
case 'u': return "A"; 
default: assert false; 
}
void foo() {
for (...) {
if (...)
return;
}
assert false; 
// Execution should never reach this point!
}
But don’t use the assert statement here, because it can be turned off. Instead, throw an 
exception in the illegal cases, so that the check will always happen: 
default: throw new AssertionError("must be a vowel, but was: " 
+ vowel);
12 Construction for Robustness and Correctness
What to Assert: more scenarios
 The value of an input-only variable is not changed by a method
 A pointer is non-NULL
 An array or other container passed into a method can contain at 
least X number of data elements
 A table has been initialized to contain real values
 A container is empty (or full) when a method begins executing (or 
when it finishes)
 The results from a highly optimized, complicated method match 
the results from a slower but clearly written routine
12 Construction for Robustness and Correctness
Example
What statements would be 
reasonable to write at 
position A?
And at position B?
• assert a != 0;
• assert b != 0;
• assert c != 0;
• assert roots.size() >= 0;
• assert roots.size() <= 2;
• for (double x : roots) { assert 
Math.abs(a*x*x + b*x + c) < 0.0001; }
12 Construction for Robustness and Correctness
When to use assertions? 
 Normally, you don’t want users to see assertion messages in 
production code; assertions are primarily for use during 
development and maintenance. 断言主要用于开发阶段，避免引入
和帮助发现bug
 Assertions are normally compiled into the code at development 
time and compiled out of the code for production. 实际运行阶段，
不再使用断言
 During production, they are compiled out of the code so that the 
assertions don’t degrade system performance. 避免降低性能
 When should you write runtime assertions? 使用断言的主要目的是
为了在开发阶段调试程序、尽快避免错误 – As you write the code, not after the fact. When you’re writing the code, 
you have the invariants in mind. – If you postpone writing assertions, you’re less likely to do it, and you’re 
liable to omit some important invariants.
12 Construction for Robustness and Correctness
Avoid putting executable code in assertions
 Since assertions may be disabled, the correctness of your program 
should never depend on whether or not the assertion expressions 
are executed. 
 In particular, asserted expressions should not have side-effects . – For example, if you want to assert that an element removed from a list was 
actually found in the list, don’t write it like this: 
 If assertions are disabled, the entire expression is skipped, and x is 
never removed from the list. Write it like this instead:
// don't do this: 
assert list.remove(x);
// do this: 
boolean found = list.remove(x); 
assert found;
12 Construction for Robustness and Correctness
Don’t Assert External Conditions
 Never use assertions to test conditions that are external to your 
program. 程序之外的事，不受你控制，不要乱断言 – Such as the existence of files, the availability of the network, or the 
correctness of input typed by a human user. 文件/网络/用户输入等 – Assertions test the internal state of your program to ensure that it is within 
the bounds of its specification. 断言只是检查程序的内部状态是否符合规约 – When an assertion fails, it indicates that the program has run off the rails 
in some sense, into a state in which it was not designed to function 
properly. Assertion failures therefore indicate bugs. 断言一旦false，程序
就停止执行 – External failures are not bugs, and there is no change you can make to 
your program in advance that will prevent them from happening. 你的代
码无法保证不出现此类外部错误 (recall section 7-2) – External failures should be handled using exceptions instead. Avoid trivial 
assertions, just as you would avoid uninformative comments. 外部错误要
使用Exception机制去处理
12 Construction for Robustness and Correctness
Turn on/off Assert in different phases
 Many assertion mechanisms are designed so that assertions are 
executed only during testing and debugging, and turned off when 
the program is released to users. – Assertions are a great tool for keeping your code safe from bugs, 
but Java has them off by default! Java缺省关闭断言，要记得打开(-ea)  The advantage of this approach is that you can write very 
expensive assertions that would otherwise seriously degrade the 
performance of your program. 断言非常影响运行时的性能 – For example, a procedure that searches an array using binary search has a 
requirement that the array be sorted. – Asserting this requirement requires scanning through the entire array, 
however, turning an operation that should run in logarithmic time into 
one that takes linear time. – You should be willing to pay this cost during testing, since it makes 
debugging much easier, but not after the program is released to users.
12 Construction for Robustness and Correctness
Enable & Disable assertions in Java
 Enable assertions – Running the program with the -enableassertions or -ea option:
• java -enableassertions MyApp – The option -ea... turns on assertions in all classes of the default package.
• java -ea:MyClass MyApp
 Disable assertions – Running the program with the 
-disableassertions or -da option:
• java -ea:... -da:MyClass MyApp
 By default, assertions are disabled. 
 Enable assertions in Eclipse: – In preferences, go to Java → Installed 
JREs . Click “Java SE 8”, click “Edit…”, 
and in the “Default VM arguments” 
box enter: -ea
Software Construction
(3) Guidelines for Using Assertions
12 Construction for Robustness and Correctness
Assertion vs. Exception?
 Assertions generally cover correctness issues of program. – If an assertion is fired for an anomalous condition, the corrective action is 
not merely to handle an error gracefully—the corrective action is to 
change the program’s source code, recompile, and release a new version of 
the software. 断言Correctness
 Exceptions generally cover robustness issues of program. – If error handling code is used to address an anomalous condition, the 
error handling will enable the program to respond to the error gracefully. 
错误/异常处理Robustness
 Assertions are especially useful in large, complicated programs 
and in high reliability programs. – They enable programmers to more quickly flush out mismatched interface 
assumptions, errors that creep in when code is modified, and so on.
12 Construction for Robustness and Correctness
Assertion vs. Exception?
 Use error handling code (exception) for conditions you expect to 
occur 使用异常来处理你“预料到可以发生”的不正常情况 – Error handling code checks for off-nominal circumstances that might not 
occur very often, but that have been anticipated by the programmer who 
wrote the code and that need to be handled by the production code. 
 Use assertions for conditions that should never occur 使用断言处理
“绝不应该发生”的情况 – Assertions check for bugs in the code.
12 Construction for Robustness and Correctness
Should pre-/post-condition be asserted?
 Another viewpoint: Do not use assertions 
for argument checking in public methods. 
在其他一些开发者眼里，不应该针对参数的
合法性使用断言。
 Reasons: – Argument checking is typically part of the 
published specifications (or contract) of a method, and these specifications 
must be obeyed whether assertions are enabled or disabled. 不管是否-ea，
spec中的pre-/post-conditions都能够被保证 – Another problem with using assertions for argument checking is that 
erroneous arguments should result in an appropriate runtime exception 
(such as IllegalArgumentException, IndexOutOfBoundsException, or 
NullPointerException). An assertion failure will not throw an 
appropriate exception. 即使spec被违反，也不应通过assert直接fail，而是
应抛出具体的runtime异常
12 Construction for Robustness and Correctness
Use Assertions for pre-/post- conditions 
 If the variables latitude, longitude, and elevation were coming 
from an external source, invalid values should be checked and 
handled by error handling code rather than assertions. 如果参数来
自于外部（不受自己控制），使用异常处理
 If the variables are coming 
from a trusted, internal source, 
however, and the routine’s 
design is based on the 
assumption that these values 
will be within their valid 
ranges, then assertions are 
appropriate. 如果来自于自己
所写的其他代码，可以使用断
言来帮助发现错误（例如post￾condition就需要）
float latitude;
float longitude;
float elevation；
//Preconditions
assert latitude>=-90 && latitude<=90;
assert longitude>=0 && longitude<360;
assert elevation>=-500 && elevation<=7500
//Postconditions
assert Velocity>=0 && Velocity <= 600
return Velocity;
12 Construction for Robustness and Correctness
Should pre-/post-condition be asserted?
/**
* Sets the refresh rate.
*
* @param rate refresh rate, in frames per second.
* @throws IllegalArgumentException if rate <= 0 or
* rate > MAX_REFRESH_RATE.
*/
public void setRefreshRate(int rate) {
// Enforce specified precondition in public method
if (rate <= 0 || rate > MAX_REFRESH_RATE)
throw new IllegalArgumentException("Illegal rate: " + rate);
setRefreshInterval(1000/rate);
}
12 Construction for Robustness and Correctness
Should pre-/post-condition be asserted?
 You can use an assertion to test a nonpublic method's precondition 
that you believe will be true no matter what a client does with the 
class.
/**
* Sets the refresh interval (which must correspond to a legal rate).
*
* @param interval refresh interval in milliseconds.
*/
private void setRefreshInterval(int interval) {
// Confirm adherence to precondition in nonpublic method
assert interval > 0 
&& interval <= 1000/MAX_REFRESH_RATE : interval;
... // Set the refresh interval
} 
12 Construction for Robustness and Correctness
Should pre-/post-condition be asserted?
 You can test postcondition with assertions in both public and 
nonpublic methods. 
/**
* Returns a BigInteger whose value is (this-1 mod m).
*
* @param m the modulus.
* @return this-1 mod m.
* @throws ArithmeticException m <= 0, or this BigInteger
* has no multiplicative inverse mod m (that is, this BigInteger
* is not relatively prime to m).
*/
public BigInteger modInverse(BigInteger m) {
if (m.signum <= 0)
throw new ArithmeticException("Modulus not positive: " + m);
... // Do the computation
assert this.multiply(result).mod(m).equals(ONE) : this;
return result;
}
12 Construction for Robustness and Correctness
Combine assert & exception handling for robustness
 Both assertions and exception handling code might be used to 
address the same error. 断言和异常处理都可以处理同样的错误 – In the source code for Microsoft Word, for example, conditions that 
should always be true are asserted, but such errors are also handled by 
error-handling code in case the assertion fails. – For extremely large, complex, long-lived applications like Word, 
assertions are valuable because they help to flush out as many 
development-time errors as possible. 
 But the application is so complex (million of lines of code) and has 
gone through so many generations of modification that it isn’t 
realistic to assume that every conceivable error will be detected 
and corrected before the software ships, and so errors must be 
handled in the production version of the system as well.
开发阶段用断言尽可能消除bugs
在发行版本里用异常处理机制处理漏掉的错误
Software Construction
6 Defensive Programming
12 Construction for Robustness and Correctness
What is defensive programming?
 Defensive programming is a form of defensive design intended to 
ensure the continuing function of a piece of software under 
unforeseen circumstances. – Defensive programming practices are often used where high availability, 
safety or security is needed.
 The idea can be viewed as reducing or eliminating the prospect of 
Murphy’s Law having effect. 
 “Your code should fail as 
early as possible!”
12 Construction for Robustness and Correctness
Murphy’s Law
12 Construction for Robustness and Correctness
What is defensive programming?
 The idea is based on defensive driving
– You adopt the mind-set that you’re never sure what the other drivers are 
going to do. – That way, you make sure that if they do something dangerous you won’t 
be hurt. – You take responsibility for 
protecting yourself even 
when it might be the other 
driver’s fault. – 眼观六路，耳听八方，一旦
其他车辆有对你产生危险的
症状，马上采取防御式行动
12 Construction for Robustness and Correctness
Techniques for defensive programming 
 Protecting programs from invalid inputs 
 Assertions
 Exceptions
 Specific error handling techniques
 Barricade
 Debugging aids
 The best form of defensive coding is not inserting errors in the 
first place. 
 You can use defensive programming in combination with the other 
techniques.
12 Construction for Robustness and Correctness
(1) Protecting Programs From Invalid Inputs
 “Garbage in, garbage out” – That expression is essentially software development’s version of caveat 
emptor: let the user beware. 货物出门概不退换
 For production software, garbage in, garbage out isn’t good 
enough. 
 A good program never puts out garbage, regardless of what it takes 
in. – “Garbage in, nothing out” – “Garbage in, error message out” – “No garbage allowed in”
 “Garbage in, garbage out” is the mark of a sloppy, non-secure 
program.
12 Construction for Robustness and Correctness
Protecting Programs From Invalid Inputs
 Check the values of all data from external sources 对来自外部的数
据源要仔细检查，例如：文件、网络数据、用户输入等 – When getting data from a file, a user, the network, or some other external 
interface, check to be sure that the data falls within the allowable range. 
 Examples: – Make sure that numeric values are within tolerances and that strings are 
short enough to handle. – If a string is intended to represent a restricted range of values (such as a 
financial transaction ID or something similar), be sure that the string is 
valid for its intended purpose; otherwise reject it. – If you’re working on a secure application, be especially leery of data that 
might attack your system: attempted buffer overflows, injected SQL 
commands, injected html or XML code, integer overflows, and so on.
12 Construction for Robustness and Correctness
Protecting Programs From Invalid Inputs
 Check the values of all routine input parameters 对每个函数的输入
参数合法性要做仔细检查，并决定如何处理非法输入 – Checking the values of routine input parameters is essentially the same as 
checking data that comes from an external source, except that the data 
comes from another routine instead of from an external interface.
 Decide how to handle bad inputs – Once you’ve detected an invalid parameter, what do you do with it? – Depending on the situation, you might choose any of a dozen different 
approaches, which are described in detail later in this chapter.
12 Construction for Robustness and Correctness
(2) Barricade 设置路障
 Barricades are a damage-containment strategy. – The reason is similar to that for having isolated compartments in the hull 
of a ship and firewalls in a building. – One way to barricade for defensive programming purposes is to designate 
certain interfaces as boundaries to “safe” areas. – Check data crossing the boundaries of a safe area for validity and respond 
sensibly if the data isn’t valid. 
Defining some parts of the 
software that work with dirty 
data and some that work with 
clean can be an effective way 
to relieve the majority of the 
code of the responsibility for 
checking for bad data.
12 Construction for Robustness and Correctness
Barricade
 The class’s public methods assume the data is unsafe, and they are 
responsible for checking the data and sanitizing it. 类的public方法
接收到的外部数据都应被认为是dirty的，需要处理干净再传递到
private方法——隔离舱 – Once the data has been accepted by the class’s public methods, the class’s 
private methods can assume the data is safe.
 Another way is as an operating-room technique. 操作间技术 – Data is sterilized before it’s allowed to enter the operating room. Anything 
that’s in the operating room is assumed to be safe. – The key design decision is deciding what to put in the operating room, 
what to keep out, and where to put the doors—which routines are 
considered to be inside the safety zone, which are outside, and which 
sanitize the data. – The easiest way to do this is usually by sanitizing external data as it 
arrives, but data often needs to be sanitized at more than one level, so 
multiple levels of sterilization are sometimes required.
12 Construction for Robustness and Correctness
Relationship between Barricades and Assertions
 The use of barricades makes the distinction between assertions 
and error handling clean cut. – Routines that are outside the barricade should use error handling because 
it isn’t safe to make any assumptions about the data. – Routines inside the barricade should use assertions, because the data 
passed to them is supposed to be sanitized before it’s passed across the 
barricade. If one of the routines inside the barricade detects bad data, 
that’s an error in the program rather than an error in the data.
 “隔离舱”外部的函数应使用异常处理，“隔离舱”内的函数应使用
断言。 – The use of barricades also illustrates the value of deciding at the 
architectural level how to handle errors. – Deciding which code is inside and which is outside the barricade is an 
architecture-level decision.
 Proxy设计模式？——隔离
Software Construction
7 The SpotBugs tool
12 Construction for Robustness and Correctness
早期版本：FindBugs
 FindBugs is a program which uses static analysis to look for bugs in 
Java code. Java静态代码分析工具 – It operates on Java bytecode.
 Potential errors are classified in four ranks: scariest, scary, troubling 
and of concern. This is a hint to the developer about their possible 
impact or severity. – Bug list can be found in 
http://findbugs.sourceforge.net/bugDescriptions.html
 It is distributed as a stand-alone GUI application, but also plug-ins 
available for Eclipse, Gradle, Maven, and Jenkins. – http://findbugs.sourceforge.net/
– http://findbugs.cs.umd.edu/eclipse/
12 Construction for Robustness and Correctness
FindBugs
12 Construction for Robustness and Correctness
FindBugs
12 Construction for Robustness and Correctness
SpotBugs
 SpotBugs is a program which uses static analysis to look for bugs in 
Java code. – It is the spiritual successor of FindBugs, carrying on from the point where 
it left off with support of its community.
 It checks for more than 400 bug patterns – https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html
 It can be used standalone and through several integrations, 
including: Ant, Maven, Gradle, and Eclipse
 开源Git仓库： – https://github.com/spotbugs/spotbugs
12 Construction for Robustness and Correctness
Examples of SpotBugs patterns
12 Construction for Robustness and Correctness
Software Construction
Summary
12 Construction for Robustness and Correctness
Summary
 What are Robustness and Correctness?
 How to measure Robustness and Correctness?
 Error and Exception in Java
 Exception Handling
 Assertions
 Defensive Programming
 The SpotBugs tool
Software Construction
The end
June 16, 2021Software Construction
2021年春季学期《软件构造》
期末考试说明
Wang Zhongjie
rainy@hit.edu.cn
June 23, 2021
期末考试说明
期末考试
 闭卷，无cheat sheet
 占总成绩60%
 18周周四（7月8日）10:00-12:00，正心楼
 单选题：考核对基本概念的理解，10-20题，30~45%分数
 简答与设计题： – 给出需求、ADT的基本代码 – 开展设计和代码：绘图/建模、设计、修改代码、写新代码 (不强调语法)、
写注释 (AF/RI/Spec/Testing Strategy/Safety from Rep Exposure)、设计
测试用例、改进/优化各项质量指标等 – 5-6题，55~70%分数
期末考试说明
答疑
 答疑时间： – 7月5日（周一） 晚上7:00-9:00 – 7月6日（周二） 上午8:30-11:00
 地点： – 新技术楼510房间
 微信上消息太多，在微信上提出问题恐无法及时回复
 鼓励在Piazza上提问
期末考试说明
考核重点
软件构造基础 (6学时) 第1、3讲，习题课1
ADT+OOP (14学时) 第4-8讲，习题课2
面向可复用性和可维护
性的软件构造 (8学时) 
第9-11讲，习题课3
实验1 (4学时) 实验2 (6学时)
实验3 (6学时)
面向健壮性与正确性的
软件构造 (4学时) 第2、12讲
5%
25%
60%
10%
期末考试说明
第1、3讲  软件构造的多维度视图
 软件构造的阶段划分、各阶段的构造活动
 内部/外部的质量指标
 软件配置管理SCM与版本控制系统VCS
 Git的结构、工作原理、基本指令
期末考试说明
第4-8讲  基本数据类型、对象数据类型
 静态/动态类型检查
 Mutable/Immutable
 值的改变、引用的改变、final
 防御式拷贝
 Snapshot diagram
 Specification、前置/后置条件
 行为等价性
 规约的强度
 ADT操作的四种类型
 表示独立性、表示泄露
 不变量、表示不变量RI
 表示空间、抽象空间、AF
 以注释的形式撰写AF、RI
 接口、抽象类、具体类
 继承、override
 多态、overload
 泛型
 等价性equals()和==
 equals()的自反、传递、对称
 hashCode()
 不可变对象的引用等价性、对象等价性
 可变对象的观察等价性、行为等价性
期末考试说明
第9讲 Programing for/with reuse
 LSP
 协变、反协变
 数组的子类型化
 泛型的子类型化
 泛型中的通配符(?)
 Delegation
 Comparator和Comparable
 CRP原则
 接口的组合
 白盒框架的原理与实现
 黑盒框架的原理与实现
期末考试说明
第10-11讲  可维护性的常见度量指标
 聚合度与耦合度
 SOLID
 语法、正则表达式
 设计模式adapter、decorator、strategy、template、
iterator/iterable、factory method、visitor
期末考试说明
第2、12讲  健壮性和正确性
 Throwable
 Error/Runtime异常、其他异常
 Checked异常、Unchecked异常
 Checked异常的处理机制： – 声明、抛出、捕获、处理、清理
现场、释放资源等
 自定义异常类
 断言的作用、应用场合
 防御式编程的基本思路
 黑盒测试用例的设计 – 等价类划分、边界值分析
 以注释的形式撰写测试策略
 JUnit测试用例写法
 测试覆盖度
Software Construction
这些是否已经变
Tips: 成了你的习惯？
写更多的代码
把使用工具变成习惯
独立完成实验
遇到问题，尽可能独立解决
学会用StackOverflow解决问题
多与教师/TA交流
多总结多反思/写博客
期末考试说明
欢迎后续的互动
 王忠杰 副院长、教授，博士生导师 – 计算机科学与技术学院 – 企业与服务智能计算研究中心 (ICES) – 电子邮件： rainy@hit.edu.cn
rainy.wang@gmail.com
– 联系电话： 18604507162 – 地点： 新技术楼510房间 – 研究方向：
• “云+端”融合的服务计算
• 软件体系结构
• 实证软件工程
Software Construction
预祝各位期末考试取得好成绩！
June 23, 2021
Java String equals() 方法
Java String类Java String类
equals() 方法用于将字符串与指定的对象比较。
String 类中重写了 equals() 方法用于比较两个字符串的内容是否相等。
语法
public boolean equals(Object anObject)
参数
anObject -- 与字符串进行比较的对象。
返回值
如果给定对象与字符串相等，则返回 true；否则返回 false。
实例
实例
public class Test {
    public static void main(String args[]) {
        String Str1 = new String("runoob");
        String Str2 = Str1;
        String Str3 = new String("runoob");
        boolean retVal;

        retVal = Str1.equals( Str2 );
        System.out.println("返回值 = " + retVal );

        retVal = Str1.equals( Str3 );
        System.out.println("返回值 = " + retVal );
    }
}
以上程序执行结果为：
返回值 = true
返回值 = true
使用 == 和 equals() 比较字符串。
String 中 == 比较引用地址是否相同，equals() 比较字符串的内容是否相同：
String s1 = "Hello";              // String 直接创建
String s2 = "Hello";              // String 直接创建
String s3 = s1;                   // 相同引用
String s4 = new String("Hello");  // String 对象创建
String s5 = new String("Hello");  // String 对象创建
 
s1 == s1;         // true, 相同引用
s1 == s2;         // true, s1 和 s2 都在公共池中，引用相同
s1 == s3;         // true, s3 与 s1 引用相同
s1 == s4;         // false, 不同引用地址
s4 == s5;         // false, 堆中不同引用地址
 
s1.equals(s3);    // true, 相同内容
s1.equals(s4);    // true, 相同内容
s4.equals(s5);    // true, 相同内容

Java String类Java String类
indexOf() 方法有以下四种形式：
public int indexOf(int ch): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
public int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
int indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
语法
public int indexOf(int ch )

或

public int indexOf(int ch, int fromIndex)

或

int indexOf(String str)

或

int indexOf(String str, int fromIndex)
参数
ch -- 字符，Unicode 编码。
fromIndex -- 开始搜索的索引位置，第一个字符是 0 ，第二个是 1 ，以此类推。
str -- 要搜索的子字符串。

返回值
查找字符串，或字符 Unicode 编码在字符串出现的位置:
实例 1
public class Main {
    public static void main(String args[]) {
        String string = "aaa456ac";  
        //查找指定字符是在字符串中的下标。在则返回所在字符串下标；不在则返回-1.  
        System.out.println(string.indexOf("b")); // indexOf(String str); 返回结果：-1，"b"不存在  
 
        // 从第四个字符位置开始往后继续查找，包含当前位置  
        System.out.println(string.indexOf("a",3));//indexOf(String str, int fromIndex); 返回结果：6  
 
        //（与之前的差别：上面的参数是 String 类型，下面的参数是 int 类型）参考数据：a-97,b-98,c-99  
 
        // 从头开始查找是否存在指定的字符  
        System.out.println(string.indexOf(99));//indexOf(int ch)；返回结果：7  
        System.out.println(string.indexOf('c'));//indexOf(int ch)；返回结果：7  
 
        //从fromIndex查找ch，这个是字符型变量，不是字符串。字符a对应的数字就是97。  
        System.out.println(string.indexOf(97,3));//indexOf(int ch, int fromIndex); 返回结果：6  
        System.out.println(string.indexOf('a',3));//indexOf(int ch, int fromIndex); 返回结果：6  
    }
}
输出结果为：
-1
6
7
7
6
6
指定子字符串在字符串中第一次出现处的索引，从指定的索引开始。
实例 2
public class Test {
    public static void main(String args[]) {
        String Str = new String("菜鸟教程:www.runoob.com");
        String SubStr1 = new String("runoob");
        String SubStr2 = new String("com");
 
        System.out.print("查找字符 o 第一次出现的位置 :" );
        System.out.println(Str.indexOf( 'o' ));
        System.out.print("从第14个位置查找字符 o 第一次出现的位置 :" );
        System.out.println(Str.indexOf( 'o', 14 ));
        System.out.print("子字符串 SubStr1 第一次出现的位置:" );
        System.out.println( Str.indexOf( SubStr1 ));
        System.out.print("从第十五个位置开始搜索子字符串 SubStr1 第一次出现的位置 :" );
        System.out.println( Str.indexOf( SubStr1, 15 ));
        System.out.print("子字符串 SubStr2 第一次出现的位置 :" );
        System.out.println(Str.indexOf( SubStr2 ));
    }
}
以上程序执行结果为：
查找字符 o 第一次出现的位置 :12
从第14个位置查找字符 o 第一次出现的位置 :17
子字符串 SubStr1 第一次出现的位置:9
从第十五个位置开始搜索子字符串 SubStr1 第一次出现的位置 :-1
子字符串 SubStr2 第一次出现的位置 :16
Java String类Java String类
java中contains方法是判断是否存在包含关系，比如说a =[1,2,3,4], b=1那么a就包含b

contains返回的是布尔类型true 和false，包含的话就返回true，不包含的话就返回false

复制代码
public class pratise {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        String a = "l love feng ye";
        String b = "love";
        boolean c = a.contains(b);
        System.out.println(a.contains(b));
        //assertEquals(a.contains(b), "true");
        assert(c)=true;//加断言
    }
}

输出结果是true
ava String contains() 方法
Java String类Java String类
contains() 方法用于判断字符串中是否包含指定的字符或字符串。
语法
public boolean contains(CharSequence chars)
参数
chars -- 要判断的字符或字符串。
返回值
如果包含指定的字符或字符串返回 true，否则返回 false。
实例
以下实例判断 Runoob 中是否包含字符或字符系列：
实例
public class Main {
    public static void main(String[] args) {
        String myStr = "Runoob";
        System.out.println(myStr.contains("Run"));
        System.out.println(myStr.contains("o"));
        System.out.println(myStr.contains("s"));
    }
}
以上程序执行结果为：
true
true
false
Java String类Java String类
List：允许元素重复.（JDK1.2）

允许添加null，且允许添加多个null。

相对于Collation加入了以下两个常用方法：
        get()  --> 根据索引取得元素
        set()  --> 修改指定索引元素的内，返回修改前内容

ArrayList （JDK1.2）

底层为数组,线程同步不安全。

其本质为对象动态数组。

默认容量为10，当数据超过当前容量会进行自动扩容，扩容规则为：

newCapacity = oldCapacity + (oldCapacity >> 1);

即：每次扩容原数组的1/2 。

简单实例：

import java.util.ArrayList;
import java.util.List;
 
public class TestCollection {
	public static void main(String[] args) {
		List<Integer> list = new ArrayList<>();// 在创建一个ArrayList对象时一般将其向上转型为List，
		// 在定义时,建议加上泛型
		list.add(9);
		list.add(5);
		list.add(2);
		list.set(2, 7);// List 独有方法 ,将下标为2的元素修改为7.
		System.out.println(list.get(1));
	}
}
LinkedList （JDK1.2）

底层为双向链表，线程同步不安全。

简单实例：

import java.util.LinkedList;
import java.util.List;
 
public class TestCollection {
	public static void main(String[] args) {
		List<Integer> list = new LinkedList<>();// 在创建一个LinkedList对象时一般将其向上转型为List，
		// 在定义时,建议加上泛型
		list.add(9);
		list.add(5);
		list.add(2);
		list.set(2, 7);// List 独有方法 ,将下标为2的元素修改为7.
		System.out.println(list.get(1));
	}
}
Vector(JDK1.0)

底层为数组，线程同步安全。但是，但是效率低一般不常用。

简单实例：

import java.util.List;
import java.util.Vector;
 
public class TestCollection {
	public static void main(String[] args) {
		List<Integer> list = new Vector<>();// 在创建一个Vector对象时一般将其向上转型为List，
		// 在定义时,建议加上泛型
		list.add(9);
		list.add(5);
		list.add(2);
		list.set(2, 7);// List 独有方法 ,将下标为2的元素修改为7.
		System.out.println(list.get(1));
	}
}
 

可以看到，ArrayList , LinkedList , Vector 在使用上的差别并不大。因此我们根据自己的需要选择合适的存储结构，比如插入删除比较多的时候就选用LinkedList , 如果随机访问比较多就使用ArrayList  , 如果要求线程安全就选用Vector 。

 

ArrayList和Vector的区别：

1.Vector 从JDK1.0开始，ArrayList从JDK1.2开始

2.加载方式：Vercor 底层基于数组，在实例化的时候会直接创建一个数组，ArrayList是懒加载机制，在第一次添加数据的时候在会创建数组;

3.扩容方式：Vector默认容量为10，扩容机制为newCapacity=2*oldCapacity，ArrayList的默认容量为10，扩容机制为newCapacity=oldCapacity+oldCapacity>>1;

4.输出方式：Vector多支持Enumeration输出方式。

3.Vector线程安全，ArrrayList线程不安全。

4.Vector同步处理，性能较低，ArrayList 异步处理，性能较高。

ArrayList和LinkedList的区别：

LinkedList和ArrayList的差别主要来自于Array和LinkedList数据结构的不同。

1) 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。

2) 相对于ArrayList，LinkedList插入是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。

3) 类似于插入数据，删除数据时，LinkedList也优于ArrayList。

4) LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。

如果List需要存储引用类型,并且使用到 .remove() , contains() 等方法，建议复写该引用类型的   .equals() 方法。

以下为复写 .equals()  的完整Student 实例

import java.util.ArrayList;
import java.util.List;
 
class Student {
	public int id;
	public String name;
 
	public Student(int id, String name) {
		this.id = id;
		this.name = name;
	}
 
	@Override
	public String toString() {
		return "id : " + id + "   name : " + name;
	}
 
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;//如果传进来的对象就是当前对象就直接返回true
		}
		if (obj instanceof Student) {
			Student stu = (Student) obj;
			if (this.id == stu.id) {
				if (this.name.equals(stu.name)) {
					return true;
				}
				return false;
			}
			return false;
		}
		return false;
	}
 
}
 
public class TestCollection {
	public static void main(String[] args) {
		List<Student> stu = new ArrayList<>();
		stu.add(new Student(1, "andy"));
		stu.add(new Student(2, "john"));
		stu.add(new Student(3, "jack"));
		Student black = new Student(4, "black");
		stu.add(black);
		System.out.println("stu是否包含这个对象："+stu.contains(new Student(3, "jack")));
		stu.remove(new Student(1, "andy"));
		System.out.println(stu.get(0));//id=1 的 andy 被成功删除
	}
}
打印结果：

stu是否包含这个对象：true
id : 2   name : john     //原来的第一个Student对象andy被成功删除

那出现这个现象的原因是什么呢？
点击 此处 查看详细原因。

 

Set：不允许元素重复.（JDK1.2）  ----  本质为没有value的Map

HashSet（JDK1.2）

底层为数组（Hash表），实际上就是HashMap。

允许为null，不能重复，元素乱序存储。

 

Set不允许元素重复，那么在存储这个元素时会判断这个元素是否重复，因为他的底层就是用了一个HashMap来实现，因此他怎么判断重复，后面的map会详细说。


 


TreeSet（JDK1.2）

底层为红黑二叉树，实际上就是TreeMap.
不允许为null，不能重复，有序存储（顺序可以自定义）//存储空会报错
TreeSet的有序存储，存储元素时会判断他是否重复，并且自动排序，判断重复元素由compareTo()方法来实现。因此自定义类要使用TreeSet必须覆写Comparable接口。具体的排序规则可以由我们自己来定。
 

自定义类实现Comparable接口实例：

import java.util.HashSet;
import java.util.Set;
 
class Person implements Comparable<Person> {
	public String name;
	public String school;
	private int age;
 
	public Person(String name, String school, int age) {
		this.name = name;
		this.school = school;
		this.age = age;
	}
 
	public String toString() {
		return "[name: " + this.name + "    school: " + this.school + "    age: " + age + "]";
	}
 
	/*
	 * 复写 .compareTo() 的规定： 当前对象大于传入对象，返回一个正数 当前对象等于传入对象，返回一个0 当前对象小于传入对象，返回一个负数
	 */
	@Override
	public int compareTo(Person o) {
		if (this.age > o.age) {
			return 1;
		} else if (this.age < o.age) {
			return -1;
		} else {
			int i = this.name.compareTo(o.name);
			if (i != 0) {
				return i;
			}
			return this.school.compareTo(school);
		}
	}
 
}
 
public class Test {
	public static void main(String[] args) {
		Set<Person> list = new HashSet<>();
		Person per1 = new Person("andy", "XUST", 21);
		list.add(per1);
		list.add(per1);
		list.add(new Person("hjj", "XUST", 22));
		list.add(new Person("zgd", "XUST", 23));
		for (Person person : list) {
			System.out.println(person);
		}
	}
}
Map（JDK1.2）

针对键值对,可以通过key值找到value。key不可重复，value可以重复。

常用方法：
    put(k,v);存储元素
    get(k);取出元素
    keySet();返回所有key信息保存在set接口（key值不能重复）
    Values();返回所有values信息保存在Collection集合中（value可以重复）
    entrySet();将Map集合转变成Set集合

HashMap（JDK1.2）

允许key，value为空，value允许多个空
内部实现：数组+链表
HashMap的初始化和扩容：

HashMap为懒加载机制，当创建HashMap的实例化对象的时候，HashMap并不会直接分配存储空间，当第一次添加元素的时候才会真正分配空间。默认容量为16，默认负载因子为0.75，当当前元素的个数大于或等于阈值（即当前数组大小*负载因子）的时候就会扩容为原大小的2倍。

HashMap一共有4个构造方法：

HashMap();  -->默认容量，默认负载因子

HashMap(int initalCapacity) -->指定容量，但是指定容量必须是2的倍数，如果不是2的倍数系统会自动将这个数转成大于这个数且最接近这个数且是二的倍数的一个数。

HashMap(int initalCapacity,float) -->指定容量，指定负载因子（一般情况下负载因子不建议指定）

HashMap(Map< ? extends Key,? extends Value>map ） 利用这个Map再构造一个HashMap对象

HashMap底层可以看作是数组（Node[] table）和链表结合组成的复合结构，数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储，这里需要注意的是，如果链表大小超过阈值

HashMap是以<K,V>的形式存储数据，当输入一个Key值会自动生成一个Hash值，再用（HashMap数组的大小-1）&这个Hash值就是元素的存储位置，如果插入的值这个位置已经有元素了那么就会忘链表的后面插入元素，当一个链表中的元素超过八个元素并且总元素的个数超过了64个就会将这个链表树化。如果链表中元素的个数减少到6个，就又会变成链表。

TreeMap（JDK1.2）

底层实现为红黑树，Key不可重复，且key不为null，输入null会抛出NullPointerException。

运用此类需要复写Comparable接口。

HashTable（JDK1.0）

HashTable 是最早实现这种二元偶对象数据结构，后期的设计只是将其实现了Map接口。

HashTable和HashMap的区别：


ConcurrentHashMap（JDK1.2）

ConcurrentHashMap 特点：线程安全，并且效率高，相当于HashMap 和HashTable的结合改良版。

JDK 1.7和JDK1.8的ConcurretHashMap实现原理的对比：

分离锁，也就是将内部进行分段（Segment），里面则是HashEntry 的数组，和 HashMap类似，哈希相同的条目也是以链表形式存放。
HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。

实现方式：其核心是利用分段设计，在进行并发操作的时候， 只需要锁定相应段，这样就有效避免了类似 Hashtable 整体同步的问题，大大提高了性能。
由于老师上课的时候讲到了ArrayList LinkList效率不同，于是课下查找资料，并写了一个二者效率对比的小代码。

首先通过查找资料我了解到：1. LinkedList和ArrayList的差别主要来自于Array和LinkedList数据结构的不同。ArrayList是基于数组实现的，LinkedList是基于双链表实现的。另外LinkedList类不仅是List接口的实现类，可以根据索引来随机访问集合中的元素，除此之外，LinkedList还实现了Deque接口，它代表一个双向队列，因此LinkedList可以作为双向队列 ，栈和List集合使用。

2. 因为Array是基于索引的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。

3. 相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引。

4. LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。

首先我们测试ArrayList LinkList增加新的内容时效率上的区别。代码如下：